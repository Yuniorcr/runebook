<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="perl">
    <body>
      <group id="perl">
        <trans-unit id="cc80a0a86bde9f9811deb2b4047a08d7c517bb7e" translate="yes" xml:space="preserve">
          <source>(W closed) The socket you're sending to got itself closed sometime before now. Check your control flow.</source>
          <target state="translated">(W closed) 당신이 보내고 자하는 소켓은 얼마 전에 닫혔습니다. 제어 흐름을 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="7aec4135b79438ad14c3a964c4630183be1a1b09" translate="yes" xml:space="preserve">
          <source>(W closed) You tried to do a bind on a closed socket. Did you forget to check the return value of your socket() call? See &lt;a href=&quot;functions/bind&quot;&gt;bind&lt;/a&gt;.</source>
          <target state="translated">(W closed) 닫힌 소켓에서 바인드를 시도했습니다. socket () 호출의 반환 값을 확인하는 것을 잊었습니까? &lt;a href=&quot;functions/bind&quot;&gt;bind를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="2c182385a4029ec290eb443378ddba969658ef79" translate="yes" xml:space="preserve">
          <source>(W closed) You tried to do a bind on a closed socket. Did you forget to check the return value of your socket() call? See &lt;a href=&quot;perlfunc#bind&quot;&gt;&quot;bind&quot; in perlfunc&lt;/a&gt;.</source>
          <target state="translated">(W closed) 닫힌 소켓에서 바인딩을 시도했습니다. socket () 호출의 반환 값을 확인하는 것을 잊었습니까? &lt;a href=&quot;perlfunc#bind&quot;&gt;perlfunc의 &quot;bind&quot;를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a483bc728ce89a356e49e93e25f177a39d0d0bd2" translate="yes" xml:space="preserve">
          <source>(W closed) You tried to do a connect on a closed socket. Did you forget to check the return value of your socket() call? See &lt;a href=&quot;functions/connect&quot;&gt;connect&lt;/a&gt;.</source>
          <target state="translated">(W 닫힘) 닫힌 소켓에서 연결을 시도했습니다. socket () 호출의 반환 값을 확인하는 것을 잊었습니까? &lt;a href=&quot;functions/connect&quot;&gt;connect를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="7fa342e3f8cf4aa7adcf62c9fcf1016406da423a" translate="yes" xml:space="preserve">
          <source>(W closed) You tried to do a connect on a closed socket. Did you forget to check the return value of your socket() call? See &lt;a href=&quot;perlfunc#connect&quot;&gt;&quot;connect&quot; in perlfunc&lt;/a&gt;.</source>
          <target state="translated">(W closed) 닫힌 소켓에서 연결을 시도했습니다. socket () 호출의 반환 값을 확인하는 것을 잊었습니까? &lt;a href=&quot;perlfunc#connect&quot;&gt;perlfunc의 &quot;connect&quot;를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="34608223004dc77e87fe9381938e96c7cf955ac4" translate="yes" xml:space="preserve">
          <source>(W closed) You tried to do a listen on a closed socket. Did you forget to check the return value of your socket() call? See &lt;a href=&quot;functions/listen&quot;&gt;listen&lt;/a&gt;.</source>
          <target state="translated">(W closed) 닫힌 소켓에서 청취하려고했습니다. socket () 호출의 반환 값을 확인하는 것을 잊었습니까? 관련 항목 &lt;a href=&quot;functions/listen&quot;&gt;들을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7e489b6a7aed7ecf31e032302a6848fcf950dd67" translate="yes" xml:space="preserve">
          <source>(W closed) You tried to do a listen on a closed socket. Did you forget to check the return value of your socket() call? See &lt;a href=&quot;perlfunc#listen&quot;&gt;&quot;listen&quot; in perlfunc&lt;/a&gt;.</source>
          <target state="translated">(W closed) 닫힌 소켓에서 청취하려고했습니다. socket () 호출의 반환 값을 확인하는 것을 잊었습니까? &lt;a href=&quot;perlfunc#listen&quot;&gt;perlfunc의 &quot;listen&quot;을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="71ee5dae4e8472748b97847b021b00dd16e56c28" translate="yes" xml:space="preserve">
          <source>(W closed) You tried to do a shutdown on a closed socket. Seems a bit superfluous.</source>
          <target state="translated">(W closed) 닫힌 소켓에서 시스템 종료를 시도했습니다. 약간 불필요한 것 같습니다.</target>
        </trans-unit>
        <trans-unit id="b0a054724012ff7380cc3bd3fbabe4c0f3adab15" translate="yes" xml:space="preserve">
          <source>(W closed) You tried to do an accept on a closed socket. Did you forget to check the return value of your socket() call? See &lt;a href=&quot;functions/accept&quot;&gt;accept&lt;/a&gt;.</source>
          <target state="translated">(W 폐쇄) 폐쇄 소켓에서 승인을 시도했습니다. socket () 호출의 반환 값을 확인하는 것을 잊었습니까? &lt;a href=&quot;functions/accept&quot;&gt;수락을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f7d75a460503da3530360bdc2a54ca0cd52c286a" translate="yes" xml:space="preserve">
          <source>(W closed) You tried to do an accept on a closed socket. Did you forget to check the return value of your socket() call? See &lt;a href=&quot;perlfunc#accept&quot;&gt;&quot;accept&quot; in perlfunc&lt;/a&gt;.</source>
          <target state="translated">(W closed) 닫힌 소켓에서 수락을 시도했습니다. socket () 호출의 반환 값을 확인하는 것을 잊었습니까? &lt;a href=&quot;perlfunc#accept&quot;&gt;perlfunc의 &quot;accept&quot;를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="686780402dcd5189e3de84bbbe7e8c3675a26cd5" translate="yes" xml:space="preserve">
          <source>(W closed) You tried to get a socket option on a closed socket. Did you forget to check the return value of your socket() call? See &lt;a href=&quot;functions/getsockopt&quot;&gt;getsockopt&lt;/a&gt;.</source>
          <target state="translated">(W closed) 닫힌 소켓에서 소켓 옵션을 얻으려고했습니다. socket () 호출의 반환 값을 확인하는 것을 잊었습니까? &lt;a href=&quot;functions/getsockopt&quot;&gt;getsockopt를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0767f5feb60728afb7dcc0b938d1d2420bdc90ee" translate="yes" xml:space="preserve">
          <source>(W closed) You tried to get a socket option on a closed socket. Did you forget to check the return value of your socket() call? See &lt;a href=&quot;perlfunc#getsockopt&quot;&gt;&quot;getsockopt&quot; in perlfunc&lt;/a&gt;.</source>
          <target state="translated">(W closed) 닫힌 소켓에서 소켓 옵션을 얻으려고했습니다. socket () 호출의 반환 값을 확인하는 것을 잊었습니까? &lt;a href=&quot;perlfunc#getsockopt&quot;&gt;perlfunc의 &quot;getsockopt&quot;를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b5f3fe4ba1c0a3fcc1fd82dbadf8c0a68a06899b" translate="yes" xml:space="preserve">
          <source>(W closed) You tried to get a socket or peer socket name on a closed socket. Did you forget to check the return value of your socket() call?</source>
          <target state="translated">(W closed) 닫힌 소켓에서 소켓 또는 피어 소켓 이름을 얻으려고했습니다. socket () 호출의 반환 값을 확인하는 것을 잊었습니까?</target>
        </trans-unit>
        <trans-unit id="9dd893f13813e0686f88d28dcaa995ea58eff6c6" translate="yes" xml:space="preserve">
          <source>(W closed) You tried to read from a closed filehandle.</source>
          <target state="translated">(W closed) 닫힌 파일 핸들에서 읽으려고했습니다.</target>
        </trans-unit>
        <trans-unit id="b1bc9bc2878143204e9bd4f8c5b8ef8fc1a1d196" translate="yes" xml:space="preserve">
          <source>(W closed) You tried to set a socket option on a closed socket. Did you forget to check the return value of your socket() call? See &lt;a href=&quot;functions/setsockopt&quot;&gt;setsockopt&lt;/a&gt;.</source>
          <target state="translated">(W closed) 닫힌 소켓에 소켓 옵션을 설정하려고했습니다. socket () 호출의 반환 값을 확인하는 것을 잊었습니까? &lt;a href=&quot;functions/setsockopt&quot;&gt;setsockopt를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="35e436938fc74d3430c8346b0f1154a9170d5347" translate="yes" xml:space="preserve">
          <source>(W closed) You tried to set a socket option on a closed socket. Did you forget to check the return value of your socket() call? See &lt;a href=&quot;perlfunc#setsockopt&quot;&gt;&quot;setsockopt&quot; in perlfunc&lt;/a&gt;.</source>
          <target state="translated">(W closed) 닫힌 소켓에 소켓 옵션을 설정하려고했습니다. socket () 호출의 반환 값을 확인하는 것을 잊었습니까? &lt;a href=&quot;perlfunc#setsockopt&quot;&gt;perlfunc의 &quot;setsockopt&quot;를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="6691ea148e323c92640a7e1d8e12d6db9b140e15" translate="yes" xml:space="preserve">
          <source>(W closure) An inner (nested)</source>
          <target state="translated">(W 잠금) 내부 (중첩)</target>
        </trans-unit>
        <trans-unit id="ac28de0cbad4c4dfc31aa274d0d0826540c4608a" translate="yes" xml:space="preserve">
          <source>(W closure) During compilation, an inner named subroutine or eval is attempting to capture an outer lexical subroutine that is not currently available. This can happen for one of two reasons. First, the lexical subroutine may be declared in an outer anonymous subroutine that has not yet been created. (Remember that named subs are created at compile time, while anonymous subs are created at run-time.) For example,</source>
          <target state="translated">(W 클로저) 컴파일 중에 이름 지정된 서브 루틴 또는 eval이 현재 사용할 수없는 외부 어휘 서브 루틴을 캡처하려고합니다. 이것은 두 가지 이유 중 하나로 발생할 수 있습니다. 먼저, 어휘 서브 루틴은 아직 작성되지 않은 외부 익명 서브 루틴에서 선언 될 수 있습니다. 명명 된 하위는 컴파일 타임에 생성되고 익명 하위는 런타임에 생성됩니다. 예를 들어,</target>
        </trans-unit>
        <trans-unit id="65c019298a1444d38d91fcf17700dfd268f80742" translate="yes" xml:space="preserve">
          <source>(W closure) During compilation, an inner named subroutine or eval is attempting to capture an outer lexical that is not currently available. This can happen for one of two reasons. First, the outer lexical may be declared in an outer anonymous subroutine that has not yet been created. (Remember that named subs are created at compile time, while anonymous subs are created at run-time.) For example,</source>
          <target state="translated">(W 클로저) 컴파일 중에 이름 지정된 서브 루틴 또는 eval이 현재 사용할 수없는 외부 어휘를 캡처하려고합니다. 이것은 두 가지 이유 중 하나로 발생할 수 있습니다. 먼저, 외부 어휘는 아직 작성되지 않은 외부 익명 서브 루틴에서 선언 될 수 있습니다. 명명 된 하위는 컴파일 타임에 생성되고 익명 하위는 런타임에 생성됩니다. 예를 들어,</target>
        </trans-unit>
        <trans-unit id="9b99fd281d6e3b0ca6d9cc6f78bf1f1eebea0030" translate="yes" xml:space="preserve">
          <source>(W digit) Here &lt;code&gt;%s&lt;/code&gt; is one of &quot;binary&quot;, &quot;octal&quot;, or &quot;hex&quot;. You may have tried to use a digit other than one that is legal for the given type, such as only 0 and 1 for binary. For octals, this is raised only if the illegal character is an '8' or '9'. For hex, 'A' - 'F' and 'a' - 'f' are legal. Interpretation of the number stopped just before the offending digit or character.</source>
          <target state="translated">(W 자리) 여기서 &lt;code&gt;%s&lt;/code&gt; 는 &quot;binary&quot;, &quot;octal&quot;또는 &quot;hex&quot;중 하나입니다. 바이너리의 경우 0과 1과 같이 주어진 유형에 적합한 숫자 이외의 숫자를 사용하려고 시도했을 수 있습니다. 8 진수의 경우 잘못된 문자가 '8'또는 '9'인 경우에만 발생합니다. 16 진수의 경우 'A'- 'F'및 'a'- 'f'는 합법적입니다. 문제가되는 숫자 나 문자 바로 앞에서 숫자 해석이 중지되었습니다.</target>
        </trans-unit>
        <trans-unit id="aeb7a7a3fdadc4b5bcf1a03e2ede998a58cf8cca" translate="yes" xml:space="preserve">
          <source>(W digit) In parsing a hexadecimal numeric constant, a character was unexpectedly encountered that isn't hexadecimal. The resulting value is as indicated.</source>
          <target state="translated">(W 자리) 16 진수 숫자 상수를 구문 분석 할 때 16 진수가 아닌 문자가 예기치 않게 발견되었습니다. 결과 값은 표시된대로입니다.</target>
        </trans-unit>
        <trans-unit id="f49f3db25d97d6915960909beefeac21238b6f2d" translate="yes" xml:space="preserve">
          <source>(W digit) In parsing an octal numeric constant, a character was unexpectedly encountered that isn't octal. The resulting value is as indicated.</source>
          <target state="translated">(W 숫자) 8 진 숫자 상수를 구문 분석 할 때 8 진수가 아닌 문자가 예기치 않게 발생했습니다. 결과 값은 표시된대로입니다.</target>
        </trans-unit>
        <trans-unit id="5e57358e7c1ec969e817e54f1e65d4d60ed6b951" translate="yes" xml:space="preserve">
          <source>(W digit) You may have tried to use a character other than 0 - 9 or A - F, a - f in a hexadecimal number. Interpretation of the hexadecimal number stopped before the illegal character.</source>
          <target state="translated">(W 숫자) 16 진수로 0-9 또는 A-F 이외의 문자를 사용하려고 시도했을 수 있습니다. 16 진수 숫자의 해석이 잘못된 문자 앞에 멈췄습니다.</target>
        </trans-unit>
        <trans-unit id="00a4e0b3bbab633922e651c73c2306c40de05654" translate="yes" xml:space="preserve">
          <source>(W digit) You may have tried to use a digit other than 0 or 1 in a binary number. Interpretation of the binary number stopped before the offending digit.</source>
          <target state="translated">(W 숫자) 이진수로 0 또는 1 이외의 숫자를 사용하려고 시도했을 수 있습니다. 이진수의 해석은 문제가되는 숫자보다 먼저 중지되었습니다.</target>
        </trans-unit>
        <trans-unit id="84e6efe8b571226f1c56d898f3595c47df2fa3d9" translate="yes" xml:space="preserve">
          <source>(W digit) You may have tried to use an 8 or 9 in an octal number. Interpretation of the octal number stopped before the 8 or 9.</source>
          <target state="translated">(W 숫자) 8 진수로 8 또는 9를 사용하려고 시도했을 수 있습니다. 8 진수의 해석은 8 또는 9 이전에 중지되었습니다.</target>
        </trans-unit>
        <trans-unit id="9fb9a032a154ac7b59a268710cf1949bc22fb256" translate="yes" xml:space="preserve">
          <source>(W exec) A system(), exec(), or piped open call could not execute the named program for the indicated reason. Typical reasons include: the permissions were wrong on the file, the file wasn't found in &lt;code&gt;$ENV{PATH}&lt;/code&gt; , the executable in question was compiled for another architecture, or the #! line in a script points to an interpreter that can't be run for similar reasons. (Or maybe your system doesn't support #! at all.)</source>
          <target state="translated">(W exec) system (), exec () 또는 파이프 열린 호출이 표시된 이유로 지정된 프로그램을 실행할 수 없습니다. 일반적인 이유는 다음과 같습니다. 파일에 대한 권한이 잘못 되었거나 &lt;code&gt;$ENV{PATH}&lt;/code&gt; 에 파일이 없거나 문제의 실행 파일이 다른 아키텍처 또는 #! 스크립트의 라인은 비슷한 이유로 실행할 수없는 인터프리터를 가리 킵니다. (또는 시스템이 #!를 전혀 지원하지 않을 수도 있습니다.)</target>
        </trans-unit>
        <trans-unit id="3b86ef50e35cd205cf0587cbb4b8c068a6ecca60" translate="yes" xml:space="preserve">
          <source>(W exec) A system(), exec(), or piped open call could not execute the named program for the indicated reason. Typical reasons include: the permissions were wrong on the file, the file wasn't found in &lt;code&gt;$ENV{PATH}&lt;/code&gt;, the executable in question was compiled for another architecture, or the #! line in a script points to an interpreter that can't be run for similar reasons. (Or maybe your system doesn't support #! at all.)</source>
          <target state="translated">(W exec) system (), exec () 또는 파이프 된 열기 호출이 표시된 이유로 인해 명명 된 프로그램을 실행할 수 없습니다. 일반적인 이유는 다음과 같습니다. 파일에 대한 권한이 잘못 되었거나, 파일이 &lt;code&gt;$ENV{PATH}&lt;/code&gt; 에서 발견되지 않았 거나, 문제의 실행 파일이 다른 아키텍처 용으로 컴파일되었거나, #! 스크립트의 줄은 비슷한 이유로 실행할 수없는 인터프리터를 가리 킵니다. (또는 시스템이 #!을 전혀 지원하지 않을 수도 있습니다.)</target>
        </trans-unit>
        <trans-unit id="40cf81f6b21e33cf0de9e73eab5064b147112369" translate="yes" xml:space="preserve">
          <source>(W exec) A warning peculiar to VMS. Waitpid() was asked to wait for a process which isn't a subprocess of the current process. While this is fine from VMS' perspective, it's probably not what you intended.</source>
          <target state="translated">(W exec) VMS 고유의 경고입니다. Waitpid ()는 현재 프로세스의 서브 프로세스가 아닌 프로세스를 기다리라는 요청을 받았습니다. 이것은 VMS의 관점에서는 문제가 없지만 의도 한 것은 아닐 것입니다.</target>
        </trans-unit>
        <trans-unit id="0ee5ddf7eeab37551318e6033433b97f7d5d48d1" translate="yes" xml:space="preserve">
          <source>(W exec) You did an exec() with some statement after it other than a die(). This is almost always an error, because exec() never returns unless there was a failure. You probably wanted to use system() instead, which does return. To suppress this warning, put the exec() in a block by itself.</source>
          <target state="translated">(W exec) die ()가 아닌 다른 명령문 뒤에 exec ()를 수행했습니다. exec ()는 실패하지 않는 한 반환하지 않기 때문에 이것은 거의 항상 오류입니다. 대신 system ()을 사용하고 싶을 수도 있습니다. 이 경고를 표시하지 않으려면 exec () 자체를 블록에 넣으십시오.</target>
        </trans-unit>
        <trans-unit id="278e1a884eb3739698a7e8956cfbb36c8f5f87f4" translate="yes" xml:space="preserve">
          <source>(W exiting) You are exiting a format by unconventional means, such as a goto, or a loop control statement.</source>
          <target state="translated">(W 종료) goto 또는 루프 제어문과 같은 비 전통적인 방법으로 형식을 종료합니다.</target>
        </trans-unit>
        <trans-unit id="67609a2a97401f2b99b78611043cd7f013a46fee" translate="yes" xml:space="preserve">
          <source>(W exiting) You are exiting a rather special block construct (like a sort block or subroutine) by unconventional means, such as a goto, or a loop control statement. See &lt;a href=&quot;functions/sort&quot;&gt;sort&lt;/a&gt;.</source>
          <target state="translated">(W 종료) goto 또는 루프 제어문과 같은 비 전통적인 수단을 사용하여 다소 특수한 블록 구성 (예 : 정렬 블록 또는 서브 루틴)을 종료합니다. &lt;a href=&quot;functions/sort&quot;&gt;sort&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="8b40b6b378e94e3e4cadc41efdaa751acbe0637e" translate="yes" xml:space="preserve">
          <source>(W exiting) You are exiting a rather special block construct (like a sort block or subroutine) by unconventional means, such as a goto, or a loop control statement. See &lt;a href=&quot;perlfunc#sort&quot;&gt;&quot;sort&quot; in perlfunc&lt;/a&gt;.</source>
          <target state="translated">(W 종료) goto 또는 루프 제어 명령문과 같은 비정상적인 수단으로 다소 특수한 블록 구성 (예 : 정렬 블록 또는 서브 루틴)을 종료하고 있습니다. &lt;a href=&quot;perlfunc#sort&quot;&gt;perlfunc의 &quot;sort&quot;를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="423b0191e4cbf769af53341d336458806707caeb" translate="yes" xml:space="preserve">
          <source>(W exiting) You are exiting a subroutine by unconventional means, such as a goto, or a loop control statement.</source>
          <target state="translated">(W 종료) goto 또는 루프 제어문과 같은 비 전통적인 수단으로 서브 루틴을 종료합니다.</target>
        </trans-unit>
        <trans-unit id="577ddf9c905e4347f8a9edb4c94bb3d05b393883" translate="yes" xml:space="preserve">
          <source>(W exiting) You are exiting a substitution by unconventional means, such as a return, a goto, or a loop control statement.</source>
          <target state="translated">(W 종료) 리턴, 이동 또는 루프 제어문과 같은 비 전통적인 수단으로 대체를 종료합니다.</target>
        </trans-unit>
        <trans-unit id="635b5ef261a420bb3046d7f8e4b7a552abb9ebd2" translate="yes" xml:space="preserve">
          <source>(W exiting) You are exiting an eval by unconventional means, such as a goto, or a loop control statement.</source>
          <target state="translated">(W 종료) goto 또는 루프 제어문과 같은 비 전통적인 수단으로 평가를 종료합니다.</target>
        </trans-unit>
        <trans-unit id="61f27ff7875edb61784c966ef6d387cd6a2988db" translate="yes" xml:space="preserve">
          <source>(W illegalproto) A character follows % or @ in a prototype. This is useless, since % and @ gobble the rest of the subroutine arguments.</source>
          <target state="translated">(W illegalproto) 프로토 타입에서 문자는 % 또는 @를 따릅니다. %와 @는 나머지 서브 루틴 인수를 뒤섞기 때문에 이것은 쓸모가 없습니다.</target>
        </trans-unit>
        <trans-unit id="c9ffd9aa561f3b86a313e40b450bfafd500921a5" translate="yes" xml:space="preserve">
          <source>(W illegalproto) A grouping was started with &lt;code&gt;[&lt;/code&gt; but never closed with &lt;code&gt;]&lt;/code&gt;.</source>
          <target state="translated">(W illegalproto) 그룹화가 &lt;code&gt;[&lt;/code&gt; 와 함께 시작 되었지만 결코 종료되지 않았습니다 &lt;code&gt;]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6112a30e9d70cd7305832f9bcd92076f9f034086" translate="yes" xml:space="preserve">
          <source>(W illegalproto) An illegal character was found in a prototype declaration. Legal characters in prototypes are $, @, %, *, ;, [, ], &amp;amp;, \, and +. Perhaps you were trying to write a subroutine signature but didn't enable that feature first (&lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature 'signatures'&lt;/code&gt; ), so your signature was instead interpreted as a bad prototype.</source>
          <target state="translated">(W illegalproto) 프로토 타입 선언에서 잘못된 문자가 발견되었습니다. 프로토 타입의 유효한 문자는 $, @, %, *,;, [,], &amp;amp;, \ 및 +입니다. 아마 당신은 서브 루틴 서명을 작성하려고했다하지만 첫 번째 (이 기능을 사용하지 않도록 설정 한 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature 'signatures'&lt;/code&gt; 서명 대신 나쁜 프로토 타입으로 해석 그래서,).</target>
        </trans-unit>
        <trans-unit id="e52bf0978448af6b58e107bc72b92c785c760bdf" translate="yes" xml:space="preserve">
          <source>(W illegalproto) An illegal character was found in a prototype declaration. Legal characters in prototypes are $, @, %, *, ;, [, ], &amp;amp;, \, and +. Perhaps you were trying to write a subroutine signature but didn't enable that feature first (&lt;code&gt;use feature 'signatures'&lt;/code&gt;), so your signature was instead interpreted as a bad prototype.</source>
          <target state="translated">(W illegalproto) 프로토 타입 선언에서 잘못된 문자가 발견되었습니다. 프로토 타입의 유효한 문자는 $, @, %, *,;, [,], &amp;amp;, \ 및 +입니다. 서브 루틴 서명을 작성하려고했지만 먼저 해당 기능을 활성화하지 않았으므로 ( &lt;code&gt;use feature 'signatures'&lt;/code&gt; ) 서명이 대신 잘못된 프로토 타입으로 해석되었을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1db9799c8c1e3509096b870feae3fbef0c02c544" translate="yes" xml:space="preserve">
          <source>(W illegalproto) An illegal character was found in a prototype declaration. The '_' in a prototype must be followed by a ';', indicating the rest of the parameters are optional, or one of '@' or '%', since those two will accept 0 or more final parameters.</source>
          <target state="translated">(W illegalproto) 프로토 타입 선언에서 잘못된 문자가 발견되었습니다. 프로토 타입의 '_'뒤에는 ';'이 와야합니다. 나머지 매개 변수는 선택 사항이거나 '@'또는 '%'중 하나를 나타내는데,이 두 개는 0 개 이상의 최종 매개 변수를 허용하기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="0a696416880193fa00f2a4266f8a348d0d4dde88" translate="yes" xml:space="preserve">
          <source>(W imprecision) The value you attempted to increment or decrement by one is too large for the underlying floating point representation to store accurately, hence the target of &lt;code&gt;++&lt;/code&gt; or &lt;code&gt;--&lt;/code&gt; is unchanged. Perl issues this warning because it has already switched from integers to floating point when values are too large for integers, and now even floating point is insufficient. You may wish to switch to using &lt;a href=&quot;Math::BigInt&quot;&gt;Math::BigInt&lt;/a&gt; explicitly.</source>
          <target state="translated">(W 부정확) 1 씩 증가 또는 감소하려는 값이 너무 커서 기본 부동 소수점 표현이 정확하게 저장할 수 없으므로 &lt;code&gt;++&lt;/code&gt; 또는 &lt;code&gt;--&lt;/code&gt; 의 대상 은 변경되지 않습니다. Perl은 값이 정수에 비해 너무 클 때 이미 정수에서 부동 소수점으로 전환 되었기 때문에이 경고를 표시하고 이제 부동 소수점도 충분하지 않습니다. &lt;a href=&quot;Math::BigInt&quot;&gt;Math :: BigInt를&lt;/a&gt; 명시 적으로 사용하도록 전환 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c7fd43abca207918c5fc4cdbdfec0cb27e79feb6" translate="yes" xml:space="preserve">
          <source>(W imprecision) The value you attempted to increment or decrement by one is too large for the underlying floating point representation to store accurately, hence the target of &lt;code&gt;++&lt;/code&gt; or &lt;code&gt;--&lt;/code&gt; is unchanged. Perl issues this warning because it has already switched from integers to floating point when values are too large for integers, and now even floating point is insufficient. You may wish to switch to using &lt;a href=&quot;math/bigint&quot;&gt;Math::BigInt&lt;/a&gt; explicitly.</source>
          <target state="translated">(W 부정확도) 1 씩 증가 또는 감소 시키려고 시도한 값이 기본 부동 소수점 표현이 정확하게 저장하기에 너무 커서 &lt;code&gt;++&lt;/code&gt; 또는 &lt;code&gt;--&lt;/code&gt; 의 목표 는 변경되지 않습니다. Perl은 정수에 대해 값이 너무 클 때 정수에서 부동 소수점으로 이미 전환되어 현재 부동 소수점조차도 충분하지 않기 때문에이 경고를 발행합니다. &lt;a href=&quot;math/bigint&quot;&gt;Math :: BigInt를&lt;/a&gt; 명시 적으로 사용하도록 전환 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0380d4e9c21d75260f15f61e0e8d75fffecf52b7" translate="yes" xml:space="preserve">
          <source>(W internal) A warning peculiar to VMS. Perl tried to read a logical name or CLI symbol definition when preparing to iterate over %ENV, and didn't see the expected delimiter between key and value, so the line was ignored.</source>
          <target state="translated">(W 내부) VMS 고유의 경고입니다. Perl은 % ENV를 반복 할 준비를 할 때 논리 이름 또는 CLI 기호 정의를 읽으려고했으나 키와 값 사이에 예상되는 구분 기호를 찾지 못해 행이 무시되었습니다.</target>
        </trans-unit>
        <trans-unit id="e0b79079d3e5d0700f6c79112c4f181694c27e32" translate="yes" xml:space="preserve">
          <source>(W internal) A warning peculiar to VMS. Perl tried to read the CRTL's internal environ array, and encountered an element without the &lt;code&gt;=&lt;/code&gt; delimiter used to separate keys from values. The element is ignored.</source>
          <target state="translated">(W 내부) VMS 고유의 경고입니다. Perl은 CRTL의 내부 환경 배열을 읽으려고했지만 키와 값을 구분하는 데 &lt;code&gt;=&lt;/code&gt; 구분 기호 가없는 요소를 발견했습니다 . 요소가 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="587287ad8ceaf64ab8230f7bcf5670e31503bcc1" translate="yes" xml:space="preserve">
          <source>(W internal) A warning peculiar to VMS. While Perl was preparing to iterate over %ENV, it encountered a logical name or symbol definition which was too long, so it was truncated to the string shown.</source>
          <target state="translated">(W 내부) VMS 고유의 경고입니다. Perl이 % ENV를 반복 할 준비를하는 중에 논리 이름이나 기호 정의가 너무 길어서 표시된 문자열로 잘 렸습니다.</target>
        </trans-unit>
        <trans-unit id="36ebe0800de98cf6f1b5bf24a60713b3518a1d0b" translate="yes" xml:space="preserve">
          <source>(W internal) Warnings peculiar to VMS. You tried to change or delete an element of the CRTL's internal environ array, but your copy of Perl wasn't built with a CRTL that contained the setenv() function. You'll need to rebuild Perl with a CRTL that does, or redefine</source>
          <target state="translated">(W 내부) VMS에 고유 한 경고. CRTL의 내부 환경 배열 요소를 변경하거나 삭제하려고했지만 Perl 사본이 setenv () 함수가 포함 된 CRTL로 작성되지 않았습니다. CRTL을 사용하여 Perl을 다시 작성하거나 재정의해야합니다.</target>
        </trans-unit>
        <trans-unit id="ef225bf78a4ffd17a5bb6a41738bbeb914a98db0" translate="yes" xml:space="preserve">
          <source>(W io) A filehandle represents an opened file, and when you opened the file it already went past any symlink you are presumably trying to look for. The operation returned &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;. Use a filename instead.</source>
          <target state="translated">(W io) 파일 핸들은 열린 파일을 나타내며 파일을 열었을 때 이미 찾고있는 심볼릭 링크를 지나갔습니다. 작업이 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 를 리턴했습니다 . 대신 파일 이름을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="d2da3ad1830577c29fb44eb869b1ca9384bf55d4" translate="yes" xml:space="preserve">
          <source>(W io) A filehandle represents an opened file, and when you opened the file it already went past any symlink you are presumably trying to look for. The operation returned &lt;code&gt;undef&lt;/code&gt;. Use a filename instead.</source>
          <target state="translated">(W io) 파일 핸들은 열린 파일을 나타내며 파일을 열었을 때 이미 찾고자하는 심볼릭 링크를 지나갔습니다. 작업이 &lt;code&gt;undef&lt;/code&gt; 를 반환했습니다 . 대신 파일 이름을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="ee0ffa3b5e5e88aa061e31df24e098e285623887" translate="yes" xml:space="preserve">
          <source>(W io) A single call to write() produced more lines than can fit on a page. See &lt;a href=&quot;perlform&quot;&gt;perlform&lt;/a&gt;.</source>
          <target state="translated">(W io) write ()에 대한 단일 호출은 페이지에 맞는 것보다 많은 행을 생성했습니다. &lt;a href=&quot;perlform&quot;&gt;perlform을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="3fae264d9cc122df4656cd9db14f53c587dced8a" translate="yes" xml:space="preserve">
          <source>(W io) The dirhandle you are doing a seekdir() on is either closed or not really a dirhandle. Check your control flow.</source>
          <target state="translated">seekdir ()을 수행하고있는 dirhandle이 닫혀 있거나 실제로 dirhandle이 아닙니다. 제어 흐름을 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="4e5653964bb3ce999ffdd1f023f2acfeb0cb1b2b" translate="yes" xml:space="preserve">
          <source>(W io) The dirhandle you tried to close is either closed or not really a dirhandle. Check your control flow.</source>
          <target state="translated">(W io) 닫으려는 dirhandle이 닫히거나 실제로 dirhandle이 아닙니다. 제어 흐름을 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="127a04276c120f78beaffbfc2313d45b73d1b33b" translate="yes" xml:space="preserve">
          <source>(W io) The dirhandle you tried to do a rewinddir() on is either closed or not really a dirhandle. Check your control flow.</source>
          <target state="translated">(window) rewinddir ()을 시도한 dirhandle이 닫히거나 실제로 dirhandle이 아닙니다. 제어 흐름을 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="1d737035b8d4f24c62b1ff52cc5128d37b308243" translate="yes" xml:space="preserve">
          <source>(W io) The dirhandle you tried to telldir() is either closed or not really a dirhandle. Check your control flow.</source>
          <target state="translated">(dir) telldir ()하려고 시도한 dirhandle은 닫혀 있거나 실제로 dirhandle이 아닙니다. 제어 흐름을 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="b257e2f649cabca0abfa99bff0088affded75975" translate="yes" xml:space="preserve">
          <source>(W io) The dirhandle you're reading from is either closed or not really a dirhandle. Check your control flow.</source>
          <target state="translated">(W io) 당신이 읽고있는 dirhandle은 닫혀 있거나 실제로 dirhandle이 아닙니다. 제어 흐름을 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="cc52e3a1ee5048b6a45ffd6085a3f6b30e6d1327" translate="yes" xml:space="preserve">
          <source>(W io) You opened for reading a filehandle that got the same filehandle id as STDOUT or STDERR. This occurred because you closed STDOUT or STDERR previously.</source>
          <target state="translated">(W io) STDOUT 또는 STDERR과 동일한 파일 핸들 ID를 가진 파일 핸들을 읽기 위해 열었습니다. 이전에 STDOUT 또는 STDERR을 닫았 기 때문에 발생했습니다.</target>
        </trans-unit>
        <trans-unit id="16c9c24089f7631f92df6e520f74b47f2a676640" translate="yes" xml:space="preserve">
          <source>(W io) You opened for writing a filehandle that got the same filehandle id as STDIN. This occurred because you closed STDIN previously.</source>
          <target state="translated">(W io) STDIN과 동일한 파일 핸들 ID를 가진 파일 핸들을 작성하기 위해 열었습니다. 이전에 STDIN을 닫았 기 때문에 발생했습니다.</target>
        </trans-unit>
        <trans-unit id="48e33ef7ad3bda2c544d27c4a2b881dd4cce8a01" translate="yes" xml:space="preserve">
          <source>(W io) You tried to do an lstat on a filehandle. What did you mean by that? lstat() makes sense only on filenames. (Perl did a fstat() instead on the filehandle.)</source>
          <target state="translated">(W io) 파일 핸들에서 lstat를 시도했습니다. 그게 무슨 소리 니? lstat ()는 파일 이름에서만 의미가 있습니다. (펄은 파일 핸들에서 fstat ()를 대신했다.)</target>
        </trans-unit>
        <trans-unit id="324bb1ba42f01059dfedd40debd4b1a4374a4560" translate="yes" xml:space="preserve">
          <source>(W io) You tried to open a scalar reference for reading or writing, using the 3-arg open() syntax:</source>
          <target state="translated">(W io) 3-arg open () 구문을 사용하여 읽기 또는 쓰기를위한 스칼라 참조를 열려고했습니다.</target>
        </trans-unit>
        <trans-unit id="cd0af26043dd5c8a624dc3d3fd913fb0da71fce7" translate="yes" xml:space="preserve">
          <source>(W io) You tried to read from a filehandle opened only for writing, If you intended it to be a read/write filehandle, you needed to open it with &quot;+&amp;lt;&quot; or &quot;+&amp;gt;&quot; or &quot;+&amp;gt;&amp;gt;&quot; instead of with &quot;&amp;gt;&quot;. If you intended only to read from the file, use &quot;&amp;lt;&quot;. See &lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;. Another possibility is that you attempted to open filedescriptor 0 (also known as STDIN) for output (maybe you closed STDIN earlier?).</source>
          <target state="translated">(W io) 쓰기 전용으로 열린 파일 핸들에서 읽으려고했습니다. 읽기 / 쓰기 파일 핸들로 사용하려는 경우 대신 &quot;+ &amp;lt;&quot;또는 &quot;+&amp;gt;&quot;또는 &quot;+ &amp;gt;&amp;gt;&quot;로 열어야합니다. &quot;&amp;gt;&quot;와 함께 파일에서 읽기만하려면 &quot;&amp;lt;&quot;를 사용하십시오. &lt;a href=&quot;functions/open&quot;&gt;open을&lt;/a&gt; 참조하십시오 . 또 다른 가능성은 출력을 위해 파일 디스크립터 0 (STDIN이라고도 함)을 열려고 시도했을 수 있습니다 (STDIN을 일찍 닫았을 수 있습니까?).</target>
        </trans-unit>
        <trans-unit id="26a86df58693ec2956cf4b78b4f1b98ee6ebb681" translate="yes" xml:space="preserve">
          <source>(W io) You tried to read from a filehandle opened only for writing, If you intended it to be a read/write filehandle, you needed to open it with &quot;+&amp;lt;&quot; or &quot;+&amp;gt;&quot; or &quot;+&amp;gt;&amp;gt;&quot; instead of with &quot;&amp;gt;&quot;. If you intended only to read from the file, use &quot;&amp;lt;&quot;. See &lt;a href=&quot;perlfunc#open&quot;&gt;&quot;open&quot; in perlfunc&lt;/a&gt;. Another possibility is that you attempted to open filedescriptor 0 (also known as STDIN) for output (maybe you closed STDIN earlier?).</source>
          <target state="translated">(W io) 쓰기 전용으로 열린 파일 핸들에서 읽으려고했습니다. 읽기 / 쓰기 파일 핸들을 의도 한 경우 대신 &quot;+ &amp;lt;&quot;또는 &quot;+&amp;gt;&quot;또는 &quot;+ &amp;gt;&amp;gt;&quot;를 사용하여 열어야합니다. / &quot;&amp;gt;&quot;. 파일에서 읽기만하려는 경우 &quot;&amp;lt;&quot;를 사용하십시오. &lt;a href=&quot;perlfunc#open&quot;&gt;perlfunc의 &quot;open&quot;을&lt;/a&gt; 참조하십시오 . 또 다른 가능성은 출력을 위해 filedescriptor 0 (STDIN이라고도 함)을 열려고 시도한 것입니다 (아마도 STDIN을 더 일찍 닫았습니까?).</target>
        </trans-unit>
        <trans-unit id="8be59eeb719b1de30aae260c360f6b5c60cae180" translate="yes" xml:space="preserve">
          <source>(W io) You tried to write on a read-only filehandle. If you intended it to be a read-write filehandle, you needed to open it with &quot;+&amp;lt;&quot; or &quot;+&amp;gt;&quot; or &quot;+&amp;gt;&amp;gt;&quot; instead of with &quot;&amp;lt;&quot; or nothing. If you intended only to write the file, use &quot;&amp;gt;&quot; or &quot;&amp;gt;&amp;gt;&quot;. See &lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;.</source>
          <target state="translated">(W io) 읽기 전용 파일 핸들에 쓰려고했습니다. 파일을 읽기 / 쓰기 파일 핸들로 사용하려는 경우 &quot;&amp;lt;&quot;대신 &quot;+ &amp;lt;&quot;또는 &quot;+&amp;gt;&quot;또는 &quot;+ &amp;gt;&amp;gt;&quot;로 열어야합니다. 파일 만 쓰려는 경우 &quot;&amp;gt;&quot;또는 &quot;&amp;gt;&amp;gt;&quot;를 사용하십시오. &lt;a href=&quot;functions/open&quot;&gt;open을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b0ae7a7db65e1788bd003926fece059a687b8735" translate="yes" xml:space="preserve">
          <source>(W io) You tried to write on a read-only filehandle. If you intended it to be a read-write filehandle, you needed to open it with &quot;+&amp;lt;&quot; or &quot;+&amp;gt;&quot; or &quot;+&amp;gt;&amp;gt;&quot; instead of with &quot;&amp;lt;&quot; or nothing. If you intended only to write the file, use &quot;&amp;gt;&quot; or &quot;&amp;gt;&amp;gt;&quot;. See &lt;a href=&quot;perlfunc#open&quot;&gt;&quot;open&quot; in perlfunc&lt;/a&gt;.</source>
          <target state="translated">(W io) 읽기 전용 파일 핸들에 쓰려고했습니다. 읽기-쓰기 파일 핸들이되도록 의도 한 경우 &quot;&amp;lt;&quot;또는 아무것도 사용하지 않고 &quot;+ &amp;lt;&quot;또는 &quot;+&amp;gt;&quot;또는 &quot;+ &amp;gt;&amp;gt;&quot;를 사용하여 열어야했습니다. 파일 만 작성하려는 경우 &quot;&amp;gt;&quot;또는 &quot;&amp;gt;&amp;gt;&quot;를 사용하십시오. &lt;a href=&quot;perlfunc#open&quot;&gt;perlfunc의 &quot;open&quot;을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="968ea45fb72fa2c7bd5bcdf03ea7400fdcd81829" translate="yes" xml:space="preserve">
          <source>(W layer) An attempt was made to push an unknown layer onto the Perl I/O system. (Layers take care of transforming data between external and internal representations.) Note that some layers, such as &lt;code&gt;mmap&lt;/code&gt; , are not supported in all environments. If your program didn't explicitly request the failing operation, it may be the result of the value of the environment variable PERLIO.</source>
          <target state="translated">(W 레이어) 알 수없는 레이어를 Perl I / O 시스템에 푸시하려고했습니다. 레이어는 외부 표현과 내부 표현 간의 데이터 변환을 처리합니다. &lt;code&gt;mmap&lt;/code&gt; 과 같은 일부 레이어 는 모든 환경에서 지원되는 것은 아닙니다. 프로그램이 실패한 조작을 명시 적으로 요청하지 않은 경우 환경 변수 PERLIO의 결과 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="54d67ddc1b4d29d590c9b5ebbb632ab7cf7be879" translate="yes" xml:space="preserve">
          <source>(W layer) An attempt was made to push an unknown layer onto the Perl I/O system. (Layers take care of transforming data between external and internal representations.) Note that some layers, such as &lt;code&gt;mmap&lt;/code&gt;, are not supported in all environments. If your program didn't explicitly request the failing operation, it may be the result of the value of the environment variable PERLIO.</source>
          <target state="translated">(W 계층) 알 수없는 계층을 Perl I / O 시스템으로 푸시하려고했습니다. (계층은 외부 및 내부 표현 간의 데이터 변환을 처리합니다.) &lt;code&gt;mmap&lt;/code&gt; 과 같은 일부 계층 은 모든 환경에서 지원되지 않습니다. 프로그램이 실패한 작업을 명시 적으로 요청하지 않은 경우 환경 변수 PERLIO 값의 결과 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3c622eaff4edeef916a3a7c575dcd4f69353b85c" translate="yes" xml:space="preserve">
          <source>(W layer) When pushing a layer with arguments onto the Perl I/O system you forgot the ) that closes the argument list. (Layers take care of transforming data between external and internal representations.) Perl stopped parsing the layer list at this point and did not attempt to push this layer. If your program didn't explicitly request the failing operation, it may be the result of the value of the environment variable PERLIO.</source>
          <target state="translated">(W 계층) 인수가있는 계층을 Perl I / O 시스템에 푸시 할 때 인수 목록을 닫는)을 잊어 버렸습니다. (레이어는 외부 표현과 내부 표현 간의 데이터 변환을 처리합니다.) Perl은이 시점에서 레이어 목록 구문 분석을 중지하고이 레이어를 푸시하려고 시도하지 않았습니다. 프로그램이 실패한 조작을 명시 적으로 요청하지 않은 경우 환경 변수 PERLIO 값의 결과 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ecde0fdfd45c81bcf2a4145082dc4dd084cab4f1" translate="yes" xml:space="preserve">
          <source>(W layer) When pushing layers onto the Perl I/O system, something other than a colon or whitespace was seen between the elements of a layer list. If the previous attribute had a parenthesised parameter list, perhaps that list was terminated too soon.</source>
          <target state="translated">(W 레이어) Perl I / O 시스템으로 레이어를 푸시 할 때 레이어 목록의 요소 사이에 콜론이나 공백 이외의 것이 나타납니다. 이전 속성에 괄호로 묶은 매개 변수 목록이있는 경우 해당 목록이 너무 빨리 종료되었을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b99a80d131d19e28dda9041e25eeb2f1f73775f2" translate="yes" xml:space="preserve">
          <source>(W locale) While in a single-byte locale (</source>
          <target state="translated">(W 로케일) 1 바이트 로케일 (</target>
        </trans-unit>
        <trans-unit id="0d7aae5004e480ec270f51ea7824d1434b43e076" translate="yes" xml:space="preserve">
          <source>(W locale) You are 1) running under &quot;&lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; &quot;; 2) the current locale is not a UTF-8 one; 3) you tried to do the designated case-change operation on the specified Unicode character; and 4) the result of this operation would mix Unicode and locale rules, which likely conflict. Mixing of different rule types is forbidden, so the operation was not done; instead the result is the indicated value, which is the best available that uses entirely Unicode rules. That turns out to almost always be the original character, unchanged.</source>
          <target state="translated">(W 로케일) 1) &quot; &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; &quot; 에서 실행 중입니다 . 2) 현재 로케일이 UTF-8이 아닙니다. 3) 지정된 유니 코드 문자에 대해 지정된 대 / 소문자 변경 작업을 시도했습니다. 4)이 작업의 결과는 유니 코드와 로캘 규칙을 혼합하여 충돌 할 수 있습니다. 다른 규칙 유형의 혼합은 금지되어 있으므로 작업이 수행되지 않았습니다. 대신 결과는 표시된 값이며, 이는 완전히 유니 코드 규칙을 사용하는 최상의 값입니다. 거의 항상 원래의 캐릭터로 바뀌지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="be916193296ba6f1abfb9d4a799698762333f1fa" translate="yes" xml:space="preserve">
          <source>(W locale) You are 1) running under &quot;&lt;code&gt;use locale&lt;/code&gt;&quot;; 2) the current locale is not a UTF-8 one; 3) you tried to do the designated case-change operation on the specified Unicode character; and 4) the result of this operation would mix Unicode and locale rules, which likely conflict. Mixing of different rule types is forbidden, so the operation was not done; instead the result is the indicated value, which is the best available that uses entirely Unicode rules. That turns out to almost always be the original character, unchanged.</source>
          <target state="translated">(W 로케일) 1) &quot; &lt;code&gt;use locale&lt;/code&gt; &quot;에서 실행 중입니다 . 2) 현재 로케일이 UTF-8이 아닙니다. 3) 지정된 유니 코드 문자에 대해 지정된 대 / 소문자 변경 작업을 시도했습니다. 4)이 작업의 결과로 유니 코드와 로케일 규칙이 혼합되어 충돌 할 가능성이 있습니다. 다른 규칙 유형을 혼합하는 것은 금지되어 있으므로 작업이 수행되지 않았습니다. 대신 결과는 전체 유니 코드 규칙을 사용하는 가장 좋은 값인 표시된 값입니다. 그것은 거의 항상 원래의 캐릭터로 밝혀졌습니다.</target>
        </trans-unit>
        <trans-unit id="9445c5833b7363d2fe4ae697fde2f870ddf47e7a" translate="yes" xml:space="preserve">
          <source>(W locale) You are matching a regular expression using locale rules, and a Unicode boundary is being matched, but the locale is not a Unicode one. This doesn't make sense. Perl will continue, assuming a Unicode (UTF-8) locale, but the results could well be wrong except if the locale happens to be ISO-8859-1 (Latin1) where this message is spurious and can be ignored.</source>
          <target state="translated">(W 로케일) 로케일 규칙을 사용하여 정규식을 일치 시키며 유니 코드 경계가 일치하지만 로케일이 유니 코드가 아닙니다. 이것은 말이되지 않습니다. Perl은 유니 코드 (UTF-8) 로케일을 가정하여 계속 진행하지만 로케일이 ISO-8859-1 (Latin1) 인 경우를 제외하고는 결과가 잘못 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1d45f88f1111394c6cdc41698876e92fbac17d26" translate="yes" xml:space="preserve">
          <source>(W locale) You are matching a regular expression using locale rules, and the specified construct was encountered. This construct is only valid for UTF-8 locales, which the current locale isn't. This doesn't make sense. Perl will continue, assuming a Unicode (UTF-8) locale, but the results are likely to be wrong.</source>
          <target state="translated">(W 로케일) 로케일 규칙을 사용하여 정규식을 일치시키고 지정된 구성이 발견되었습니다. 이 구조는 현재 로케일이 아닌 UTF-8 로케일에만 유효합니다. 이건 말이 안 돼. Perl은 유니 코드 (UTF-8) 로케일을 가정하여 계속되지만 결과가 잘못 될 가능성이 있습니다.</target>
        </trans-unit>
        <trans-unit id="cdc76003f2a88a493fa96a9a2786d3a712bf03ee" translate="yes" xml:space="preserve">
          <source>(W locale) You are using the named UTF-8 locale. UTF-8 locales are expected to have very particular behavior, which most do. This message arises when perl found some departures from the expectations, and is notifying you that the expected behavior overrides these differences. In some cases the differences are caused by the locale definition being defective, but the most common causes of this warning are when there are ambiguities and conflicts in following the Standard, and the locale has chosen an approach that differs from Perl's.</source>
          <target state="translated">(W 로케일) 명명 된 UTF-8 로케일을 사용하고 있습니다. UTF-8 로케일은 대부분의 경우 매우 특별한 동작을 할 것으로 예상됩니다. 이 메시지는 perl이 기대치에서 약간 벗어난 것을 발견했을 때 발생하며 예상되는 동작이 이러한 차이점을 재정의 함을 알려줍니다. 일부 경우 차이는 로케일 정의에 결함이 있기 때문에 발생하지만이 경고의 가장 일반적인 원인은 표준을 따르는 데 모호함과 충돌이 있고 로케일이 Perl과 다른 접근 방식을 선택한 경우입니다.</target>
        </trans-unit>
        <trans-unit id="02905fbf32b02f6a8ace973ce43a92893403bf4f" translate="yes" xml:space="preserve">
          <source>(W locale) You are using the named locale, which is a non-UTF-8 one, and which perl has determined is not fully compatible with what it can handle. The second &lt;code&gt;%s&lt;/code&gt; gives a reason.</source>
          <target state="translated">(W 로케일) UTF-8이 아닌 로케일이라는 이름이 지정된 로케일을 사용하고 있으며 perl이 처리 할 수있는 것과 완전히 호환되지 않는다고 판별했습니다. 두 번째 &lt;code&gt;%s&lt;/code&gt; 가 이유를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="30b58e17c41b99f616cb1685d4bbaf844b02ef96" translate="yes" xml:space="preserve">
          <source>(W locale) You used a locale category that perl doesn't recognize, so it cannot carry out your request. Check that you are using a valid category. If so, see &lt;a href=&quot;perllocale#Multi-threaded&quot;&gt;&quot;Multi-threaded&quot; in perllocale&lt;/a&gt; for advice on reporting this as a bug, and for modifying perl locally to accommodate your needs.</source>
          <target state="translated">(W 로케일) Perl이 인식하지 못하는 로케일 범주를 사용하여 요청을 수행 할 수 없습니다. 유효한 카테고리를 사용하고 있는지 확인하십시오. 만약 그렇다면, 이것을 버그로보고하고 당신의 필요를 수용하기 위해 perl을 로컬로 수정하는 것에 대한 조언을 위해 &lt;a href=&quot;perllocale#Multi-threaded&quot;&gt;perllocale의 &quot;Multi-threaded&quot;를&lt;/a&gt; 보십시오.</target>
        </trans-unit>
        <trans-unit id="03a33e2bd2daeb7394c123da8d1823f81a6f6a4f" translate="yes" xml:space="preserve">
          <source>(W misc) A &quot;my&quot; or &quot;state&quot; subroutine has been redeclared in the current scope or statement, effectively eliminating all access to the previous instance. This is almost always a typographical error. Note that the earlier subroutine will still exist until the end of the scope or until all closure references to it are destroyed.</source>
          <target state="translated">(W misc) &quot;my&quot;또는 &quot;state&quot;서브 루틴이 현재 범위 또는 명령문에서 다시 선언되어 이전 인스턴스에 대한 모든 액세스를 효과적으로 제거합니다. 이것은 거의 항상 인쇄상의 오류입니다. 이전 서브 루틴은 스코프가 끝날 때까지 또는 모든 클로저 참조가 파괴 될 때까지 계속 존재합니다.</target>
        </trans-unit>
        <trans-unit id="bbd888a8b12a9c45d7e56a1c333e4c20223eff1c" translate="yes" xml:space="preserve">
          <source>(W misc) A &quot;my&quot;, &quot;our&quot; or &quot;state&quot; variable has been redeclared in the current scope or statement, effectively eliminating all access to the previous instance. This is almost always a typographical error. Note that the earlier variable will still exist until the end of the scope or until all closure references to it are destroyed.</source>
          <target state="translated">(W misc) &quot;my&quot;, &quot;our&quot;또는 &quot;state&quot;변수는 현재 범위 또는 명령문에서 다시 선언되어 이전 인스턴스에 대한 모든 액세스를 효과적으로 제거합니다. 이것은 거의 항상 인쇄상의 오류입니다. 이전 변수는 범위가 끝날 때까지 또는 변수에 대한 모든 클로저 참조가 소멸 될 때까지 계속 존재합니다.</target>
        </trans-unit>
        <trans-unit id="0a437454e4e59c0c63ef790ff1715aba9f133c24" translate="yes" xml:space="preserve">
          <source>(W misc) A number has been passed as a bitmask argument to select(). Use the vec() function to construct the file descriptor bitmasks for select. See &lt;a href=&quot;functions/select&quot;&gt;select&lt;/a&gt;.</source>
          <target state="translated">(W misc) 숫자가 select ()에 비트 마스크 인수로 전달되었습니다. vec () 함수를 사용하여 선택을위한 파일 디스크립터 비트 마스크를 구성하십시오. &lt;a href=&quot;functions/select&quot;&gt;select를&lt;/a&gt; 참조 하십시오 .</target>
        </trans-unit>
        <trans-unit id="e58920f3c5056b2595ba9d4876478185d68fb2a7" translate="yes" xml:space="preserve">
          <source>(W misc) A number has been passed as a bitmask argument to select(). Use the vec() function to construct the file descriptor bitmasks for select. See &lt;a href=&quot;perlfunc#select&quot;&gt;&quot;select&quot; in perlfunc&lt;/a&gt;.</source>
          <target state="translated">(W 기타) select ()에 비트 마스크 인수로 숫자가 전달되었습니다. vec () 함수를 사용하여 선택을위한 파일 설명자 비트 마스크를 구성하십시오. &lt;a href=&quot;perlfunc#select&quot;&gt;perlfunc의 &quot;select&quot;를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0c94ce8244014ff24661c0ca75a55652169dcad2" translate="yes" xml:space="preserve">
          <source>(W misc) A sub was declared as sub foo : prototype(A) : prototype(B) {}, for example. Since each sub can only have one prototype, the earlier declaration(s) are discarded while the last one is applied.</source>
          <target state="translated">(W misc) 서브는 예를 들어 sub foo : prototype (A) : prototype (B) {}로 선언되었습니다. 각 서브는 하나의 프로토 타입 만 가질 수 있으므로 이전 선언은 적용되는 동안 이전 선언은 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="217c15d1789f3525b24856092f3f9184fdbf896a" translate="yes" xml:space="preserve">
          <source>(W misc) A warning peculiar to VMS. Perl tried to read the value of an %ENV element from a CLI symbol table, and found a resultant string longer than 1024 characters. The return value has been truncated to 1024 characters.</source>
          <target state="translated">(W misc) VMS 특유의 경고. Perl은 CLI 기호 테이블에서 % ENV 요소의 값을 읽으려고했으나 1024 자보다 긴 결과 문자열을 찾았습니다. 리턴 값이 1024 자로 잘 렸습니다.</target>
        </trans-unit>
        <trans-unit id="dd11fcb880f23ae872f44fc2e5336ede26ae40f1" translate="yes" xml:space="preserve">
          <source>(W misc) Although &lt;a href=&quot;attributes&quot;&gt;attributes.pm&lt;/a&gt; allows this, turning the lvalue attribute on or off on a Perl subroutine that is already defined does not always work properly. It may or may not do what you want, depending on what code is inside the subroutine, with exact details subject to change between Perl versions. Only do this if you really know what you are doing.</source>
          <target state="translated">(W misc) &lt;a href=&quot;attributes&quot;&gt;attributes.pm&lt;/a&gt; 이이를 허용 하지만 이미 정의 된 Perl 서브 루틴에서 lvalue 속성을 켜거나 끄는 것이 항상 제대로 작동하지는 않습니다. 서브 루틴 안에있는 코드에 따라 원하는 내용을 수행 할 수도 있고하지 않을 수도 있습니다. 자세한 내용은 Perl 버전간에 변경 될 수 있습니다. 실제로하고있는 일을 알고있는 경우에만이 작업을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="0776898ec0630aa335d5aaa8eb564217544bbcdc" translate="yes" xml:space="preserve">
          <source>(W misc) An undefined value was assigned to a typeglob, a la &lt;code&gt;*foo = &lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; . This does nothing. It's possible that you really mean &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt; *foo&lt;/code&gt; .</source>
          <target state="translated">(W misc) 정의되지 않은 값이 typeglob에 할당되었습니다 (la &lt;code&gt;*foo = &lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; . 이것은 아무것도하지 않습니다. 실제로 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt; *foo&lt;/code&gt; 의미 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c865e69bc7cd2b4f8456acb18190cdbe8327bc8f" translate="yes" xml:space="preserve">
          <source>(W misc) An undefined value was assigned to a typeglob, a la &lt;code&gt;*foo = undef&lt;/code&gt;. This does nothing. It's possible that you really mean &lt;code&gt;undef *foo&lt;/code&gt;.</source>
          <target state="translated">(W 기타) 정의되지 않은 값이 typeglob, a la &lt;code&gt;*foo = undef&lt;/code&gt; 에 할당되었습니다 . 이것은 아무것도하지 않습니다. 실제로 &lt;code&gt;undef *foo&lt;/code&gt; 의미 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="12437cd31e238da3b2ced4a2306fbe6e5acf5a48" translate="yes" xml:space="preserve">
          <source>(W misc) In a conditional expression, you used &amp;lt;HANDLE&amp;gt;, &amp;lt;*&amp;gt; (glob), &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each()&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;functions/readdir&quot;&gt;readdir()&lt;/a&gt;&lt;/code&gt; as a boolean value. Each of these constructs can return a value of &quot;0&quot;; that would make the conditional expression false, which is probably not what you intended. When using these constructs in conditional expressions, test their values with the &lt;code&gt;&lt;a href=&quot;functions/defined&quot;&gt;defined&lt;/a&gt;&lt;/code&gt; operator.</source>
          <target state="translated">(W misc) 조건식에서 &amp;lt;HANDLE&amp;gt;, &amp;lt;*&amp;gt; (glob), &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each()&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;functions/readdir&quot;&gt;readdir()&lt;/a&gt;&lt;/code&gt; 을 부울 값으로 사용했습니다. 이러한 각 구문은 &quot;0&quot;값을 반환 할 수 있습니다. 그것은 조건식을 거짓으로 만들 것입니다. 아마 당신이 의도 한 것이 아닙니다. 조건식에서 이러한 구문을 사용할 때는 &lt;code&gt;&lt;a href=&quot;functions/defined&quot;&gt;defined&lt;/a&gt;&lt;/code&gt; 연산자로 해당 값을 테스트하십시오 .</target>
        </trans-unit>
        <trans-unit id="501afb12981044c06cd7ef7909c762ec288cea69" translate="yes" xml:space="preserve">
          <source>(W misc) In a conditional expression, you used &amp;lt;HANDLE&amp;gt;, &amp;lt;*&amp;gt; (glob), &lt;code&gt;each()&lt;/code&gt;, or &lt;code&gt;readdir()&lt;/code&gt; as a boolean value. Each of these constructs can return a value of &quot;0&quot;; that would make the conditional expression false, which is probably not what you intended. When using these constructs in conditional expressions, test their values with the &lt;code&gt;defined&lt;/code&gt; operator.</source>
          <target state="translated">(W 기타) 조건식에서 부울 값으로 &amp;lt;HANDLE&amp;gt;, &amp;lt;*&amp;gt; (glob), &lt;code&gt;each()&lt;/code&gt; 또는 &lt;code&gt;readdir()&lt;/code&gt; 을 사용했습니다. 이러한 각 구성은 &quot;0&quot;값을 반환 할 수 있습니다. 조건식을 거짓으로 만들 수 있습니다. 이는 아마도 의도 한 것이 아닐 것입니다. 조건식에서 이러한 구문을 사용할 때 &lt;code&gt;defined&lt;/code&gt; 연산자를 사용하여 해당 값을 테스트하십시오 .</target>
        </trans-unit>
        <trans-unit id="20059d974af22a8333d150a247e06378d470385d" translate="yes" xml:space="preserve">
          <source>(W misc) Remember that &quot;our&quot; does not localize the declared global variable. You have declared it again in the same lexical scope, which seems superfluous.</source>
          <target state="translated">(W misc) &quot;우리&quot;는 선언 된 전역 변수를 현지화하지 않습니다. 동일한 어휘 범위에서 다시 선언했는데, 불필요한 것으로 보입니다.</target>
        </trans-unit>
        <trans-unit id="5844b97950c2a1072e2ddb5f148dc77415c11973" translate="yes" xml:space="preserve">
          <source>(W misc) The &quot;const&quot; attribute has no effect except on anonymous closure prototypes. You applied it to a subroutine via &lt;a href=&quot;attributes&quot;&gt;attributes.pm&lt;/a&gt;. This is only useful inside an attribute handler for an anonymous subroutine.</source>
          <target state="translated">(W misc) &quot;const&quot;속성은 익명 클로저 프로토 타입을 제외하고는 영향을 미치지 않습니다. &lt;a href=&quot;attributes&quot;&gt;attributes.pm을&lt;/a&gt; 통해 서브 루틴에 적용했습니다. . 이것은 익명 서브 루틴에 대한 속성 핸들러 내에서만 유용합니다.</target>
        </trans-unit>
        <trans-unit id="e5321cecc859e99ecb159dbfe2a76823e102eaf8" translate="yes" xml:space="preserve">
          <source>(W misc) The &lt;code&gt;const&lt;/code&gt; attribute has no effect except on anonymous closure prototypes. You applied it to a subroutine via &lt;a href=&quot;attributes&quot;&gt;attributes.pm&lt;/a&gt;. This is only useful inside an attribute handler for an anonymous subroutine.</source>
          <target state="translated">(W 기타) &lt;code&gt;const&lt;/code&gt; 속성은 익명 클로저 프로토 타입을 제외하고는 영향을 미치지 않습니다. &lt;a href=&quot;attributes&quot;&gt;attributes.pm을&lt;/a&gt; 통해 서브 루틴에 적용했습니다 . 이것은 익명 서브 루틴에 대한 속성 핸들러 내에서만 유용합니다.</target>
        </trans-unit>
        <trans-unit id="83ab71cdca9ba1d83ceb17577950410c9f6f3fff" translate="yes" xml:space="preserve">
          <source>(W misc) The pattern match (&lt;code&gt;//&lt;/code&gt; ), substitution (&lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt;), and transliteration (&lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr///&lt;/a&gt;&lt;/code&gt;) operators work on scalar values. If you apply one of them to an array or a hash, it will convert the array or hash to a scalar value (the length of an array, or the population info of a hash) and then work on that scalar value. This is probably not what you meant to do. See &lt;a href=&quot;functions/grep&quot;&gt;grep&lt;/a&gt; and &lt;a href=&quot;functions/map&quot;&gt;map&lt;/a&gt; for alternatives.</source>
          <target state="translated">(W misc) 패턴 일치 ( &lt;code&gt;//&lt;/code&gt; ), 치환 ( &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt; ) 및 음역 ( &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr///&lt;/a&gt;&lt;/code&gt; ) 연산자는 스칼라 값에서 작동합니다. 이 중 하나를 배열 또는 해시에 적용하면 배열 또는 해시를 스칼라 값 (배열 길이 또는 해시의 모집단 정보)으로 변환 한 다음 해당 스칼라 값에서 작동합니다. 이것은 아마도 당신이하려는 의도가 아닙니다. &lt;a href=&quot;functions/grep&quot;&gt;grep&lt;/a&gt; 및 &lt;a href=&quot;functions/map&quot;&gt;map&lt;/a&gt; 참조대안 을 .</target>
        </trans-unit>
        <trans-unit id="ea8277f6fd9deda90e934a7b57d44f7e17900b36" translate="yes" xml:space="preserve">
          <source>(W misc) The pattern match (&lt;code&gt;//&lt;/code&gt;), substitution (&lt;code&gt;s///&lt;/code&gt;), and transliteration (&lt;code&gt;tr///&lt;/code&gt;) operators work on scalar values. If you apply one of them to an array or a hash, it will convert the array or hash to a scalar value (the length of an array, or the population info of a hash) and then work on that scalar value. This is probably not what you meant to do. See &lt;a href=&quot;perlfunc#grep&quot;&gt;&quot;grep&quot; in perlfunc&lt;/a&gt; and &lt;a href=&quot;perlfunc#map&quot;&gt;&quot;map&quot; in perlfunc&lt;/a&gt; for alternatives.</source>
          <target state="translated">(W 기타) 패턴 일치 ( &lt;code&gt;//&lt;/code&gt; ), 대체 ( &lt;code&gt;s///&lt;/code&gt; ) 및 음역 ( &lt;code&gt;tr///&lt;/code&gt; ) 연산자는 스칼라 값에 대해 작동합니다. 그중 하나를 배열 또는 해시에 적용하면 배열 또는 해시를 스칼라 값 (배열의 길이 또는 해시의 모집단 정보)으로 변환 한 다음 해당 스칼라 값에 대해 작업합니다. 이것은 아마도 당신이 의도 한 것이 아닐 것입니다. 대안 &lt;a href=&quot;perlfunc#map&quot;&gt;은 perlfunc의 &lt;/a&gt;&lt;a href=&quot;perlfunc#grep&quot;&gt;&quot;grep&quot;&lt;/a&gt; 및 perlfunc의 &quot;map&quot;을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a6cb938b0a50f702bbe4e1a83af4f783e4f29b59" translate="yes" xml:space="preserve">
          <source>(W misc) The version string contains invalid characters at the end, which are being ignored.</source>
          <target state="translated">(W misc) 버전 문자열 끝에 잘못된 문자가 포함되어 있으며 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="1ac1e31d222cc4c0e5cec20c46a1416397109637" translate="yes" xml:space="preserve">
          <source>(W misc) This prefix usually indicates that a DESTROY() method raised the indicated exception. Since destructors are usually called by the system at arbitrary points during execution, and often a vast number of times, the warning is issued only once for any number of failures that would otherwise result in the same message being repeated.</source>
          <target state="translated">(W misc)이 접두사는 일반적으로 DESTROY () 메소드가 표시된 예외를 발생 시켰음을 나타냅니다. 소멸자는 일반적으로 실행 중에 임의의 지점에서 시스템에 의해 호출되기 때문에 종종 여러 번 호출되기 때문에 동일한 메시지가 반복되는 여러 번의 실패에 대해 경고가 한 번만 발행됩니다.</target>
        </trans-unit>
        <trans-unit id="5c525d33b2f6cbb2cbaccf27a61558723ac97f2a" translate="yes" xml:space="preserve">
          <source>(W misc) Using the &lt;code&gt;:lvalue&lt;/code&gt; declarative syntax to make a Perl subroutine an lvalue subroutine after it has been defined is not permitted. To make the subroutine an lvalue subroutine, add the lvalue attribute to the definition, or put the &lt;code&gt;&lt;a href=&quot;functions/sub&quot;&gt;sub&lt;/a&gt;
foo :lvalue;&lt;/code&gt; declaration before the definition.</source>
          <target state="translated">(W misc) &lt;code&gt;:lvalue&lt;/code&gt; 선언 구문을 사용하여 Perl 서브 루틴을 정의 된 후 lvalue 서브 루틴으로 만드는 것은 허용되지 않습니다. 서브 루틴을 lvalue 서브 루틴으로 만들려면 lvalue 속성을 정의에 추가하거나 &lt;code&gt;&lt;a href=&quot;functions/sub&quot;&gt;sub&lt;/a&gt; foo :lvalue;&lt;/code&gt; 정의 전의 선언.</target>
        </trans-unit>
        <trans-unit id="978dd57f7188385e009beba975ac2a15bd2cdb90" translate="yes" xml:space="preserve">
          <source>(W misc) Using the &lt;code&gt;:lvalue&lt;/code&gt; declarative syntax to make a Perl subroutine an lvalue subroutine after it has been defined is not permitted. To make the subroutine an lvalue subroutine, add the lvalue attribute to the definition, or put the &lt;code&gt;sub foo :lvalue;&lt;/code&gt; declaration before the definition.</source>
          <target state="translated">(W 기타) &lt;code&gt;:lvalue&lt;/code&gt; 선언 구문을 사용하여 Perl 서브 루틴을 정의한 후 lvalue 서브 루틴으로 만드는 것은 허용되지 않습니다. 서브 루틴을 lvalue 서브 루틴으로 만들려면 정의에 lvalue 속성을 추가하거나 &lt;code&gt;sub foo :lvalue;&lt;/code&gt; 정의 전에 선언.</target>
        </trans-unit>
        <trans-unit id="d7bb17126e54088f85c3c0ce7c1c0e874c4e1d14" translate="yes" xml:space="preserve">
          <source>(W misc) You are blessing a reference to a zero length string. This has the effect of blessing the reference into the package main. This is usually not what you want. Consider providing a default target package, e.g. bless($ref, $p || 'MyPackage');</source>
          <target state="translated">(W misc) 길이가 0 인 문자열에 대한 참조를 축복하고 있습니다. 이것은 패키지 메인에 대한 참조를 축복하는 효과가 있습니다. 이것은 일반적으로 원하는 것이 아닙니다. 기본 대상 패키지를 제공하십시오 (예 : bless ($ ref, $ p || 'MyPackage')).</target>
        </trans-unit>
        <trans-unit id="ed823eb758d423a401df73e799d2788b33feee1c" translate="yes" xml:space="preserve">
          <source>(W misc) You assigned to an lvalue subroutine, but what the subroutine returned was a temporary scalar about to be discarded, so the assignment had no effect.</source>
          <target state="translated">(W misc) lvalue 서브 루틴에 할당했지만 서브 루틴이 리턴 한 것은 버려 질 임시 스칼라이므로 할당이 적용되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="9b9202be79ef7c790da62232dde7b953dc21d5a6" translate="yes" xml:space="preserve">
          <source>(W misc) You attempted to specify an offset that was past the end of the array passed to splice(). Splicing will instead commence at the end of the array, rather than past it. If this isn't what you want, try explicitly pre-extending the array by assigning $#array = $offset. See &lt;a href=&quot;functions/splice&quot;&gt;splice&lt;/a&gt;.</source>
          <target state="translated">(W misc) splice ()에 전달 된 배열의 끝을 지난 오프셋을 지정하려고했습니다. 스 플라이 싱은 대신 어레이의 끝에서 시작하지 않고 시작됩니다. 이것이 원하는 것이 아닌 경우 $ # array = $ offset을 할당하여 명시 적으로 배열을 미리 확장 해보십시오. &lt;a href=&quot;functions/splice&quot;&gt;스플 라이스&lt;/a&gt; 참조 .</target>
        </trans-unit>
        <trans-unit id="6761f66b94b97d5a3830b77a974fe74b5a626781" translate="yes" xml:space="preserve">
          <source>(W misc) You attempted to specify an offset that was past the end of the array passed to splice(). Splicing will instead commence at the end of the array, rather than past it. If this isn't what you want, try explicitly pre-extending the array by assigning $#array = $offset. See &lt;a href=&quot;perlfunc#splice&quot;&gt;&quot;splice&quot; in perlfunc&lt;/a&gt;.</source>
          <target state="translated">(W misc) splice ()에 전달 된 배열의 끝을 지난 오프셋을 지정하려고했습니다. 스 플라이 싱은 어레이를 지나가는 대신 어레이의 끝에서 시작됩니다. 이것이 원하는 것이 아니라면 $ # array = $ offset을 할당하여 명시 적으로 배열을 사전 확장 해보십시오. &lt;a href=&quot;perlfunc#splice&quot;&gt;perlfunc의 &quot;splice&quot;를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e97344ac072c36fa30be5354dedbaf9a30a0a229" translate="yes" xml:space="preserve">
          <source>(W misc) You gave a single reference where Perl was expecting a list with an even number of elements (for assignment to a hash). This usually means that you used the anon hash constructor when you meant to use parens. In any case, a hash requires key/value &lt;b&gt;pairs&lt;/b&gt;.</source>
          <target state="translated">(W misc) Perl이 (해시에 할당하기 위해) 짝수 개의 요소가있는 목록을 기대하는 단일 참조를 제공했습니다. 이것은 일반적으로 parens를 사용할 때 anon hash 생성자를 사용했음을 의미합니다. 어쨌든 해시는 키 / 값 &lt;b&gt;쌍이&lt;/b&gt; 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="15abd042a39d9926d65656cbbe08be25424747c8" translate="yes" xml:space="preserve">
          <source>(W misc) You have a \E in a double-quotish string without a &lt;code&gt;\U&lt;/code&gt; , &lt;code&gt;\L&lt;/code&gt; or &lt;code&gt;\Q&lt;/code&gt; preceding it.</source>
          <target state="translated">(W misc) 앞에 &lt;code&gt;\U&lt;/code&gt; , &lt;code&gt;\L&lt;/code&gt; 또는 &lt;code&gt;\Q&lt;/code&gt; 없는 큰 따옴표 문자열에 \ E가 있습니다.</target>
        </trans-unit>
        <trans-unit id="f5379ec83465aa4ba2da68c968c659bdcd28d6bb" translate="yes" xml:space="preserve">
          <source>(W misc) You have a \E in a double-quotish string without a &lt;code&gt;\U&lt;/code&gt;, &lt;code&gt;\L&lt;/code&gt; or &lt;code&gt;\Q&lt;/code&gt; preceding it.</source>
          <target state="translated">(W 기타) 큰 따옴표 문자열에 &lt;code&gt;\U&lt;/code&gt; , &lt;code&gt;\L&lt;/code&gt; 또는 &lt;code&gt;\Q&lt;/code&gt; 앞에 없는 \ E가 있습니다.</target>
        </trans-unit>
        <trans-unit id="a467f8075d38661a8a595bf55aef2227df75349f" translate="yes" xml:space="preserve">
          <source>(W misc) You have attempted to unweaken a reference that is not weak. Doing so has no effect.</source>
          <target state="translated">(W 기타) 약하지 않은 참조를 해제하려고했습니다. 그렇게해도 효과가 없습니다.</target>
        </trans-unit>
        <trans-unit id="1c0eea9ec7a19fa6b579515762f1950808cc9b1d" translate="yes" xml:space="preserve">
          <source>(W misc) You have attempted to weaken a reference that is already weak. Doing so has no effect.</source>
          <target state="translated">(W misc) 이미 약한 참조를 약화하려고했습니다. 그렇게해도 효과가 없습니다.</target>
        </trans-unit>
        <trans-unit id="f563a1cd3b0e654993413a90e34bfc8ab4511a9c" translate="yes" xml:space="preserve">
          <source>(W misc) You have used a replacement list that is longer than the search list. So the additional elements in the replacement list are meaningless.</source>
          <target state="translated">(W misc) 검색 목록보다 긴 대체 목록을 사용했습니다. 따라서 교체 목록의 추가 요소는 의미가 없습니다.</target>
        </trans-unit>
        <trans-unit id="055eeb5e67fd76f17bce2fa389beccc4d1c206eb" translate="yes" xml:space="preserve">
          <source>(W misc) You have used the /d modifier where the searchlist has the same length as the replacelist. See &lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt; for more information about the /d modifier.</source>
          <target state="translated">(W misc) 검색 목록이 교체 목록과 길이가 같은 / d 수정자를 사용했습니다. / d 수정 자에 대한 자세한 내용은 &lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="1c43982d36144a2ffd4995fa369c53951ebca965" translate="yes" xml:space="preserve">
          <source>(W misc) You probably referred to an imported subroutine &amp;amp;FOO as $FOO or some such.</source>
          <target state="translated">(W misc) 가져온 서브 루틴 &amp;amp; FOO를 $ FOO 또는 이와 유사한 것으로 참조했을 것입니다.</target>
        </trans-unit>
        <trans-unit id="f28afcc36fb6d498d08aa34ce83936dd22526785" translate="yes" xml:space="preserve">
          <source>(W misc) You seem to have already declared the same global once before in the current lexical scope.</source>
          <target state="translated">(W misc) 현재 어휘 범위에서 이전에 같은 전역을 이미 한 번 선언 한 것 같습니다.</target>
        </trans-unit>
        <trans-unit id="5868eba0d9d25b18fa7c2e6fe83826d858642827" translate="yes" xml:space="preserve">
          <source>(W misc) You specified an odd number of elements to initialize a hash, which is odd, because hashes come in key/value pairs.</source>
          <target state="translated">(W misc) 해시가 키 / 값 쌍으로 이루어지기 때문에 해시를 초기화하기 위해 홀수 개의 요소를 지정했습니다.</target>
        </trans-unit>
        <trans-unit id="324ba9d70516662c8b6bfbd8be1d30db767f254c" translate="yes" xml:space="preserve">
          <source>(W misc) You tried to set the length of an array which has been freed. You can do this by storing a reference to the scalar representing the last index of an array and later assigning through that reference. For example</source>
          <target state="translated">(W misc) 해제 된 배열의 길이를 설정하려고했습니다. 배열의 마지막 인덱스를 나타내는 스칼라에 대한 참조를 저장하고 나중에 해당 참조를 통해 지정하여이를 수행 할 수 있습니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="10e6703969c96e985c2f8be5cfdd7a5050eb6807" translate="yes" xml:space="preserve">
          <source>(W misc) You tried to use a reference as an array index; this probably isn't what you mean, because references in numerical context tend to be huge numbers, and so usually indicates programmer error.</source>
          <target state="translated">(W misc) 참조를 배열 인덱스로 사용하려고했습니다. 숫자 컨텍스트의 참조는 숫자가 많기 때문에 일반적으로 프로그래머 오류를 나타 내기 때문에 이것은 아마도 의미하는 것이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="f739dd0df71ad92bcb1d57bfeb314866eb972173" translate="yes" xml:space="preserve">
          <source>(W misc) You undefined a subroutine which had previously been eligible for inlining. See &lt;a href=&quot;perlsub#Constant-Functions&quot;&gt;&quot;Constant Functions&quot; in perlsub&lt;/a&gt; for commentary and workarounds.</source>
          <target state="translated">(W misc) 이전에 인라인에 적합했던 서브 루틴을 정의하지 않았습니다. 주석 및 해결 방법 &lt;a href=&quot;perlsub#Constant-Functions&quot;&gt;은 perlsub의 &quot;상수 함수&quot;를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="961c127b9cc0ad4bd43847fe65d18cac036115ef" translate="yes" xml:space="preserve">
          <source>(W misc) You undefined a subroutine which had previously been eligible for inlining. See &lt;a href=&quot;perlsub#Constant-Functions&quot;&gt;Constant Functions in perlsub&lt;/a&gt; for commentary and workarounds.</source>
          <target state="translated">(W misc) 이전에 인라인 할 수있는 서브 루틴을 정의하지 않았습니다. 주석과 해결 방법 &lt;a href=&quot;perlsub#Constant-Functions&quot;&gt;은 perlsub의 상수 함수를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="dfe717cbd021e5996741b199692d40604f2ddd47" translate="yes" xml:space="preserve">
          <source>(W misc) You used a backslash-character combination which is not recognized by Perl. The character was understood literally, but this may change in a future version of Perl.</source>
          <target state="translated">(W misc) Perl에서 인식 할 수없는 백 슬래시 문자 조합을 사용했습니다. 캐릭터는 문자 그대로 이해되었지만 이후 버전의 Perl에서 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2e717da40f4bea7168a3f5280e24fbfb5da1b933" translate="yes" xml:space="preserve">
          <source>(W misc) You used the obsolescent &lt;code&gt;&lt;a href=&quot;functions/dump&quot;&gt;dump()&lt;/a&gt;&lt;/code&gt; built-in function, without fully qualifying it as &lt;code&gt;CORE::dump()&lt;/code&gt; . Maybe it's a typo. See &lt;a href=&quot;functions/dump&quot;&gt;dump&lt;/a&gt;.</source>
          <target state="translated">(W misc) &lt;code&gt;CORE::dump()&lt;/code&gt; 로 완전히 한정하지 않고 폐기 된 &lt;code&gt;&lt;a href=&quot;functions/dump&quot;&gt;dump()&lt;/a&gt;&lt;/code&gt; 내장 함수를 사용했습니다 . 어쩌면 오타 일 수도 있습니다. &lt;a href=&quot;functions/dump&quot;&gt;덤프&lt;/a&gt; 참조 .</target>
        </trans-unit>
        <trans-unit id="c0cd06fc5e07405e0a5250c8e4b98b249ba297bf" translate="yes" xml:space="preserve">
          <source>(W misc, regexp) You wrote something like &lt;code&gt;\08&lt;/code&gt; , or &lt;code&gt;\179&lt;/code&gt; in a double-quotish string. All but the last digit is treated as a single character, specified in octal. The last digit is the next character in the string. To tell Perl that this is indeed what you want, you can use the &lt;code&gt;\o{ }&lt;/code&gt; syntax, or use exactly three digits to specify the octal for the character.</source>
          <target state="translated">(W misc, regexp) 이중 따옴표 문자열에 &lt;code&gt;\08&lt;/code&gt; 또는 &lt;code&gt;\179&lt;/code&gt; 와 같은 것을 썼습니다 . 마지막 숫자를 제외한 모든 숫자는 8 진수로 지정된 단일 문자로 취급됩니다. 마지막 숫자는 문자열에서 다음 문자입니다. 펄에게 이것이 실제로 원하는 것임을 알리기 위해 &lt;code&gt;\o{ }&lt;/code&gt; 구문을 사용하거나 정확히 3 자리 숫자를 사용하여 문자의 8 진수를 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d87808370647207cb23c26a494895bd593e19c4c" translate="yes" xml:space="preserve">
          <source>(W missing) You called a function with fewer arguments than other arguments you supplied indicated would be needed.</source>
          <target state="translated">(W 누락) 제공 한 다른 인수보다 필요한 인수가 적은 함수를 호출했습니다.</target>
        </trans-unit>
        <trans-unit id="6e8560a7cea10e56b2966a8252b5c47858339b3b" translate="yes" xml:space="preserve">
          <source>(W newline) A file operation was attempted on a filename, and that operation failed, PROBABLY because the filename contained a newline, PROBABLY because you forgot to chomp() it off. See &lt;a href=&quot;functions/chomp&quot;&gt;chomp&lt;/a&gt;.</source>
          <target state="translated">(W 개행) 파일 이름에 파일 작업을 시도했지만 파일 이름에 개행 문자가 포함되어있어 PROBABLY 작업을 실패했습니다. &lt;a href=&quot;functions/chomp&quot;&gt;씹어&lt;/a&gt; 보기 .</target>
        </trans-unit>
        <trans-unit id="4e6f89715e8d89529ba2c8290b7087cd495b476d" translate="yes" xml:space="preserve">
          <source>(W newline) A file operation was attempted on a filename, and that operation failed, PROBABLY because the filename contained a newline, PROBABLY because you forgot to chomp() it off. See &lt;a href=&quot;perlfunc#chomp&quot;&gt;&quot;chomp&quot; in perlfunc&lt;/a&gt;.</source>
          <target state="translated">(W newline) 파일 이름에 대해 파일 작업을 시도했지만 해당 작업이 실패했습니다. PROBABLY 파일 이름에 줄 바꿈이 포함 되었기 때문에 PROBABLY는 chomp () 해제하는 것을 잊었 기 때문입니다. &lt;a href=&quot;perlfunc#chomp&quot;&gt;perlfunc의 &quot;chomp&quot;를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a309644b8190402a53564c85b006750e39463cd7" translate="yes" xml:space="preserve">
          <source>(W numeric) An alpha version can not be numified without losing information.</source>
          <target state="translated">(W 숫자) 알파 버전은 정보 손실없이 숫자로 표시 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="ecad68c5be5ba7eb54444965792ee7f2c653a4e2" translate="yes" xml:space="preserve">
          <source>(W numeric) The indicated string was fed as an argument to an operator that expected a numeric value instead. If you're fortunate the message will identify which operator was so unfortunate.</source>
          <target state="translated">(W numeric) 표시된 문자열이 대신 숫자 값을 예상하는 연산자에 인수로 제공되었습니다. 운이 좋으면 어떤 운영자가 불행한지 메시지가 나타납니다.</target>
        </trans-unit>
        <trans-unit id="ffa9508e53b0c92e963d1b02acbefd8a4acfe9fd" translate="yes" xml:space="preserve">
          <source>(W numeric) The indicated string was fed as an argument to the &lt;code&gt;++&lt;/code&gt; operator which expects either a number or a string matching &lt;code&gt;/^[a-zA-Z]*[0-9]*\z/&lt;/code&gt; . See &lt;a href=&quot;perlop#Auto-increment-and-Auto-decrement&quot;&gt;Auto-increment and Auto-decrement in perlop&lt;/a&gt; for details.</source>
          <target state="translated">(W 숫자) 표시된 문자열이 &lt;code&gt;++&lt;/code&gt; 연산자에 인수로 제공되어 &lt;code&gt;/^[a-zA-Z]*[0-9]*\z/&lt;/code&gt; 일치하는 숫자 또는 문자열이 필요합니다 . &lt;a href=&quot;perlop#Auto-increment-and-Auto-decrement&quot;&gt;Perlop에서 자동 증가 및 자동 감소를&lt;/a&gt; 참조하십시오. 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="586f7b4b33f7a7eb73f47c3aa95d9b299b4dc778" translate="yes" xml:space="preserve">
          <source>(W numeric) The indicated string was fed as an argument to the &lt;code&gt;++&lt;/code&gt; operator which expects either a number or a string matching &lt;code&gt;/^[a-zA-Z]*[0-9]*\z/&lt;/code&gt;. See &lt;a href=&quot;perlop#Auto-increment-and-Auto-decrement&quot;&gt;&quot;Auto-increment and Auto-decrement&quot; in perlop&lt;/a&gt; for details.</source>
          <target state="translated">(W 숫자) 표시된 문자열이 &lt;code&gt;/^[a-zA-Z]*[0-9]*\z/&lt;/code&gt; 일치하는 숫자 또는 문자열을 예상 하는 &lt;code&gt;++&lt;/code&gt; 연산자에 인수로 공급되었습니다 . 자세한 내용 &lt;a href=&quot;perlop#Auto-increment-and-Auto-decrement&quot;&gt;은 perlop의 &quot;자동 증가 및 자동 감소&quot;&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="c37f9be9cf8f0cf03e306716c8c88d4b4aa40c39" translate="yes" xml:space="preserve">
          <source>(W numeric) You tried to execute the &lt;a href=&quot;perlop#Multiplicative-Operators&quot;&gt;&lt;code&gt;x&lt;/code&gt;&lt;/a&gt; repetition operator &lt;code&gt;Inf&lt;/code&gt; (or &lt;code&gt;-Inf&lt;/code&gt;) or &lt;code&gt;NaN&lt;/code&gt; times, which doesn't make sense.</source>
          <target state="translated">(W 숫자) &lt;a href=&quot;perlop#Multiplicative-Operators&quot;&gt; &lt;code&gt;x&lt;/code&gt; &lt;/a&gt; 반복 연산자 &lt;code&gt;Inf&lt;/code&gt; (또는 &lt;code&gt;-Inf&lt;/code&gt; ) 또는 &lt;code&gt;NaN&lt;/code&gt; 번 을 실행하려고했지만 말이되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1e307f1452017df6d8d52d1e75849cb6202b8562" translate="yes" xml:space="preserve">
          <source>(W numeric) You tried to execute the &lt;a href=&quot;perlop#Multiplicative-Operators&quot;&gt;&lt;code&gt;x&lt;/code&gt;&lt;/a&gt; repetition operator fewer than 0 times, which doesn't make sense.</source>
          <target state="translated">(W 숫자) &lt;a href=&quot;perlop#Multiplicative-Operators&quot;&gt; &lt;code&gt;x&lt;/code&gt; &lt;/a&gt; 반복 연산자를 0 회 미만 으로 실행하려고했는데 말이 안됩니다.</target>
        </trans-unit>
        <trans-unit id="e747973f9086868d39efd9610fcbe587d13511fb" translate="yes" xml:space="preserve">
          <source>(W numeric) You tried to execute the &lt;a href=&quot;perlop#Multiplicative-Operators&quot;&gt;x &lt;/a&gt; repetition operator &lt;code&gt;Inf&lt;/code&gt; (or &lt;code&gt;-Inf&lt;/code&gt; ) or &lt;code&gt;NaN&lt;/code&gt; times, which doesn't make sense.</source>
          <target state="translated">(W 숫자) &lt;a href=&quot;perlop#Multiplicative-Operators&quot;&gt;x&lt;/a&gt; 반복 연산자 &lt;code&gt;Inf&lt;/code&gt; (또는 &lt;code&gt;-Inf&lt;/code&gt; ) 또는 &lt;code&gt;NaN&lt;/code&gt; 을 실행하려고했습니다. 시간 이치에 맞지 않습니다.</target>
        </trans-unit>
        <trans-unit id="df9ed2c03344d23e71c3f63e7cd7233301c17e01" translate="yes" xml:space="preserve">
          <source>(W numeric) You tried to execute the &lt;a href=&quot;perlop#Multiplicative-Operators&quot;&gt;x &lt;/a&gt; repetition operator fewer than 0 times, which doesn't make sense.</source>
          <target state="translated">(W 숫자) &lt;a href=&quot;perlop#Multiplicative-Operators&quot;&gt;x&lt;/a&gt; 를 실행하려고했습니다. 반복 연산자를 0 회 미만 이치에 맞지 않습니다.</target>
        </trans-unit>
        <trans-unit id="979df2325920e52daaa8be14ea206eccde22447a" translate="yes" xml:space="preserve">
          <source>(W once) Typographical errors often show up as unique variable names. If you had a good reason for having a unique name, then just mention it again somehow to suppress the message. The &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; declaration is also provided for this purpose.</source>
          <target state="translated">(W once) 인쇄상의 오류는 종종 고유 한 변수 이름으로 나타납니다. 고유 한 이름을 가진 충분한 이유가 있다면 메시지를 표시하지 않으려면 다시 언급하십시오. 그만큼 &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; 선언은이 목적을 위해 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="bb3ee992bffd8d0683e29ae27825063b750b7263" translate="yes" xml:space="preserve">
          <source>(W once) Typographical errors often show up as unique variable names. If you had a good reason for having a unique name, then just mention it again somehow to suppress the message. The &lt;code&gt;our&lt;/code&gt; declaration is also provided for this purpose.</source>
          <target state="translated">(W 한 번) 입력 오류는 종종 고유 한 변수 이름으로 나타납니다. 고유 한 이름을 가지고있는 타당한 이유가 있다면 어떻게 든 다시 언급하여 메시지를 표시하지 마십시오. ㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ &lt;code&gt;our&lt;/code&gt; 선언은이 목적을 위해 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="293cfd81dde512b2040983819ce42833b00e006e" translate="yes" xml:space="preserve">
          <source>(W overflow) Some portion of a version initialization is too large for the size of integers for your architecture. This is not a warning because there is no rational reason for a version to try and use an element larger than typically 2**32. This is usually caused by trying to use some odd mathematical operation as a version, like 100/9.</source>
          <target state="translated">(W overflow) 버전 초기화의 일부가 아키텍처의 정수 크기에 비해 너무 큽니다. 버전이 일반적으로 2 ** 32보다 큰 요소를 사용하려고하는 합리적인 이유가 없기 때문에 이것은 경고가 아닙니다. 이것은 보통 100/9와 같은 이상한 수학 연산을 버전으로 사용하려고 할 때 발생합니다.</target>
        </trans-unit>
        <trans-unit id="aa916c900301e3826afbb5c02eaae17fff9b2c9d" translate="yes" xml:space="preserve">
          <source>(W overflow) The hexadecimal floating point had internally more digits than could be output. This can be caused by unsupported long double formats, or by 64-bit integers not being available (needed to retrieve the digits under some configurations).</source>
          <target state="translated">(W overflow) 16 진 부동 소수점은 출력 할 수있는 것보다 내부적으로 더 많은 자릿수를 가졌습니다. 지원되지 않는 long double 형식이나 64 비트 정수를 사용할 수 없기 때문일 수 있습니다 (일부 구성에서는 숫자를 검색해야 함).</target>
        </trans-unit>
        <trans-unit id="138762264bdf623369c76bc48da2075b0cc318e5" translate="yes" xml:space="preserve">
          <source>(W overflow) The hexadecimal floating point has a larger exponent than the floating point supports.</source>
          <target state="translated">(W overflow) 16 진 부동 소수점은 부동 소수점 지원보다 지수가 큽니다.</target>
        </trans-unit>
        <trans-unit id="7814ff9e669078b81e726ef3a3f6f5a884ba7aa0" translate="yes" xml:space="preserve">
          <source>(W overflow) The hexadecimal floating point has a smaller exponent than the floating point supports.</source>
          <target state="translated">(W overflow) 16 진 부동 소수점은 부동 소수점 지원보다 지수가 작습니다.</target>
        </trans-unit>
        <trans-unit id="4f49472f844faea1f47f1bc6b1c6edd0b363a63b" translate="yes" xml:space="preserve">
          <source>(W overflow) The hexadecimal floating point has a smaller exponent than the floating point supports. With the IEEE 754 floating point, this may also mean that the subnormals (formerly known as denormals) are being used, which may or may not be an error.</source>
          <target state="translated">(W 오버플로) 16 진수 부동 소수점은 부동 소수점이 지원하는 것보다 더 작은 지수를 갖습니다. IEEE 754 부동 소수점을 사용하면 오류 일 수도 있고 아닐 수도있는 비정규 (이전에는 비정규라고 함)가 사용되고 있음을 의미 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="ffaf16a18b1f69a006ca7d0cf534ff6517d8ea76" translate="yes" xml:space="preserve">
          <source>(W overflow) The hexadecimal floating point literal had more bits in the mantissa (the part between the 0x and the exponent, also known as the fraction or the significand) than the floating point supports.</source>
          <target state="translated">(W overflow) 16 진 부동 소수점 리터럴은 부동 소수점 지원보다 가수 (0x와 지수 사이의 부분 (분수 또는 의미라고도 함)에 더 많은 비트가 있습니다.</target>
        </trans-unit>
        <trans-unit id="afbfa3b5e713c7cfd0fd6a0d70917f864ae78219" translate="yes" xml:space="preserve">
          <source>(W overflow) You called &lt;code&gt;&lt;a href=&quot;functions/gmtime&quot;&gt;gmtime&lt;/a&gt;&lt;/code&gt; with a number that it could not handle: too large, too small, or NaN. The returned value is &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">(W overflow) 처리 할 수없는 숫자로 &lt;code&gt;&lt;a href=&quot;functions/gmtime&quot;&gt;gmtime&lt;/a&gt;&lt;/code&gt; 을 호출 했습니다 : 너무 크거나 작거나 NaN. 반환 값은 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="0d036704b2cebe975d7e914b35acf789231af606" translate="yes" xml:space="preserve">
          <source>(W overflow) You called &lt;code&gt;&lt;a href=&quot;functions/gmtime&quot;&gt;gmtime&lt;/a&gt;&lt;/code&gt; with a number that was larger than it can reliably handle and &lt;code&gt;&lt;a href=&quot;functions/gmtime&quot;&gt;gmtime&lt;/a&gt;&lt;/code&gt; probably returned the wrong date. This warning is also triggered with NaN (the special not-a-number value).</source>
          <target state="translated">(W overflow) 안정적으로 처리 할 수있는 것보다 큰 숫자로 &lt;code&gt;&lt;a href=&quot;functions/gmtime&quot;&gt;gmtime&lt;/a&gt;&lt;/code&gt; 을 호출 했으며 &lt;code&gt;&lt;a href=&quot;functions/gmtime&quot;&gt;gmtime&lt;/a&gt;&lt;/code&gt; 이 잘못된 날짜를 반환했을 것입니다. 이 경고는 NaN (숫자가 아닌 특수 값)으로도 트리거됩니다.</target>
        </trans-unit>
        <trans-unit id="0a311f99c2c8b02930306682b9959eb1c20599da" translate="yes" xml:space="preserve">
          <source>(W overflow) You called &lt;code&gt;&lt;a href=&quot;functions/gmtime&quot;&gt;gmtime&lt;/a&gt;&lt;/code&gt; with a number that was smaller than it can reliably handle and &lt;code&gt;&lt;a href=&quot;functions/gmtime&quot;&gt;gmtime&lt;/a&gt;&lt;/code&gt; probably returned the wrong date.</source>
          <target state="translated">(W overflow) 안정적으로 처리하고 &lt;code&gt;&lt;a href=&quot;functions/gmtime&quot;&gt;gmtime&lt;/a&gt;&lt;/code&gt; 보다 작은 숫자로 &lt;code&gt;&lt;a href=&quot;functions/gmtime&quot;&gt;gmtime&lt;/a&gt;&lt;/code&gt; 을 호출 했습니다. 이 잘못된 날짜를 반환했을 것입니다.</target>
        </trans-unit>
        <trans-unit id="36f5779623dfa6f6e7074bdae41e1e41b89f241a" translate="yes" xml:space="preserve">
          <source>(W overflow) You called &lt;code&gt;&lt;a href=&quot;functions/localtime&quot;&gt;localtime&lt;/a&gt;&lt;/code&gt; with a number that it could not handle: too large, too small, or NaN. The returned value is &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">(W overflow) 너무 크거나 작거나 NaN과 같이 처리 할 수없는 숫자로 &lt;code&gt;&lt;a href=&quot;functions/localtime&quot;&gt;localtime&lt;/a&gt;&lt;/code&gt; 을 호출 했습니다. 반환 값은 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="59105a430199971f3675bfeb1fffaf7e49ff1f30" translate="yes" xml:space="preserve">
          <source>(W overflow) You called &lt;code&gt;&lt;a href=&quot;functions/localtime&quot;&gt;localtime&lt;/a&gt;&lt;/code&gt; with a number that was larger than it can reliably handle and &lt;code&gt;&lt;a href=&quot;functions/localtime&quot;&gt;localtime&lt;/a&gt;&lt;/code&gt; probably returned the wrong date. This warning is also triggered with NaN (the special not-a-number value).</source>
          <target state="translated">(W overflow) 안정적으로 처리 할 수있는 것보다 큰 숫자로 &lt;code&gt;&lt;a href=&quot;functions/localtime&quot;&gt;localtime&lt;/a&gt;&lt;/code&gt; 에 전화했고 &lt;code&gt;&lt;a href=&quot;functions/localtime&quot;&gt;localtime&lt;/a&gt;&lt;/code&gt; 에 잘못된 날짜가 반환되었을 수 있습니다. 이 경고는 NaN (숫자가 아닌 특수 값)으로도 트리거됩니다.</target>
        </trans-unit>
        <trans-unit id="a93e07bf0c0bd6b674d691a637cbeb2110ed1a3d" translate="yes" xml:space="preserve">
          <source>(W overflow) You called &lt;code&gt;&lt;a href=&quot;functions/localtime&quot;&gt;localtime&lt;/a&gt;&lt;/code&gt; with a number that was smaller than it can reliably handle and &lt;code&gt;&lt;a href=&quot;functions/localtime&quot;&gt;localtime&lt;/a&gt;&lt;/code&gt; probably returned the wrong date.</source>
          <target state="translated">(W overflow) 안정적으로 처리하고 &lt;code&gt;&lt;a href=&quot;functions/localtime&quot;&gt;localtime&lt;/a&gt;&lt;/code&gt; 보다 작은 숫자로 &lt;code&gt;&lt;a href=&quot;functions/localtime&quot;&gt;localtime&lt;/a&gt;&lt;/code&gt; 을 호출 했습니다. 에 잘못된 날짜가 반환되었을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5aa4610ff7a25c878af96eaca3bd3d08a52b4d72" translate="yes" xml:space="preserve">
          <source>(W overflow) You called &lt;code&gt;&lt;a href=&quot;functions/sleep&quot;&gt;sleep&lt;/a&gt;&lt;/code&gt; with a number that was larger than it can reliably handle and &lt;code&gt;&lt;a href=&quot;functions/sleep&quot;&gt;sleep&lt;/a&gt;&lt;/code&gt; probably slept for less time than requested.</source>
          <target state="translated">(W overflow) 안정적으로 처리하고 &lt;code&gt;&lt;a href=&quot;functions/sleep&quot;&gt;sleep&lt;/a&gt;&lt;/code&gt; 할 수있는 수보다 큰 수로 &lt;code&gt;&lt;a href=&quot;functions/sleep&quot;&gt;sleep&lt;/a&gt;&lt;/code&gt; 을 호출 했습니다. 이 요청한 것보다 적은 시간 동안 잠을 잤을 .</target>
        </trans-unit>
        <trans-unit id="2b7ab1891088a8322093f03fdbf6e0c72b772149" translate="yes" xml:space="preserve">
          <source>(W overflow) You called &lt;code&gt;gmtime&lt;/code&gt; with a number that it could not handle: too large, too small, or NaN. The returned value is &lt;code&gt;undef&lt;/code&gt;.</source>
          <target state="translated">(W overflow) 처리 할 수없는 숫자로 &lt;code&gt;gmtime&lt;/code&gt; 을 호출 했습니다 : 너무 큼, 너무 작음 또는 NaN. 반환 된 값은 &lt;code&gt;undef&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="4a4120ee25ae2afbb469b3700d99e2585fd342c4" translate="yes" xml:space="preserve">
          <source>(W overflow) You called &lt;code&gt;gmtime&lt;/code&gt; with a number that was larger than it can reliably handle and &lt;code&gt;gmtime&lt;/code&gt; probably returned the wrong date. This warning is also triggered with NaN (the special not-a-number value).</source>
          <target state="translated">(W overflow) 안정적으로 처리 할 수있는 것보다 큰 숫자로 &lt;code&gt;gmtime&lt;/code&gt; 을 호출 했으며 &lt;code&gt;gmtime&lt;/code&gt; 이 잘못된 날짜를 반환했을 수 있습니다 . 이 경고는 NaN (특수 not-a-number 값)으로도 트리거됩니다.</target>
        </trans-unit>
        <trans-unit id="a9c61e684dd33adf39b1df1c97260428987b3290" translate="yes" xml:space="preserve">
          <source>(W overflow) You called &lt;code&gt;gmtime&lt;/code&gt; with a number that was smaller than it can reliably handle and &lt;code&gt;gmtime&lt;/code&gt; probably returned the wrong date.</source>
          <target state="translated">(W overflow) 안정적으로 처리 할 수있는 것보다 작은 숫자로 &lt;code&gt;gmtime&lt;/code&gt; 을 호출 했으며 &lt;code&gt;gmtime&lt;/code&gt; 이 잘못된 날짜를 반환했을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="34ae715467aecc0bd7496ea4ae92702c0c0d4eb3" translate="yes" xml:space="preserve">
          <source>(W overflow) You called &lt;code&gt;localtime&lt;/code&gt; with a number that it could not handle: too large, too small, or NaN. The returned value is &lt;code&gt;undef&lt;/code&gt;.</source>
          <target state="translated">(W overflow) 처리 할 수없는 숫자 (너무 큼, 너무 작음 또는 NaN )로 &lt;code&gt;localtime&lt;/code&gt; 을 호출 했습니다. 반환 된 값은 &lt;code&gt;undef&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="b04a9b14d2a3ce481d67aebafaf3e179c55f5f24" translate="yes" xml:space="preserve">
          <source>(W overflow) You called &lt;code&gt;localtime&lt;/code&gt; with a number that was larger than it can reliably handle and &lt;code&gt;localtime&lt;/code&gt; probably returned the wrong date. This warning is also triggered with NaN (the special not-a-number value).</source>
          <target state="translated">(W overflow) 안정적으로 처리 할 수있는 것보다 큰 숫자로 &lt;code&gt;localtime&lt;/code&gt; 을 호출 했으며 &lt;code&gt;localtime&lt;/code&gt; 이 잘못된 날짜를 반환했을 수 있습니다 . 이 경고는 NaN (특수 not-a-number 값)으로도 트리거됩니다.</target>
        </trans-unit>
        <trans-unit id="5341b9595deb413aa636e268b7188996a07a564e" translate="yes" xml:space="preserve">
          <source>(W overflow) You called &lt;code&gt;localtime&lt;/code&gt; with a number that was smaller than it can reliably handle and &lt;code&gt;localtime&lt;/code&gt; probably returned the wrong date.</source>
          <target state="translated">(W overflow) 안정적으로 처리 할 수있는 것보다 작은 숫자로 &lt;code&gt;localtime&lt;/code&gt; 을 호출 했으며 &lt;code&gt;localtime&lt;/code&gt; 이 잘못된 날짜를 반환했을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4832e59a807f8103488238c9024a468acfff2a96" translate="yes" xml:space="preserve">
          <source>(W overflow) You called &lt;code&gt;sleep&lt;/code&gt; with a number that was larger than it can reliably handle and &lt;code&gt;sleep&lt;/code&gt; probably slept for less time than requested.</source>
          <target state="translated">(W overflow) 안정적으로 처리 할 수있는 것보다 더 큰 숫자로 &lt;code&gt;sleep&lt;/code&gt; 을 호출 했으며 요청한 것보다 더 적은 시간 동안 &lt;code&gt;sleep&lt;/code&gt; 것입니다.</target>
        </trans-unit>
        <trans-unit id="d9fd3dde1b871c801c860d8a346caace3870778c" translate="yes" xml:space="preserve">
          <source>(W overload) The &lt;a href=&quot;overload&quot;&gt;overload&lt;/a&gt; pragma was passed an argument it did not recognize. Did you mistype an operator?</source>
          <target state="translated">(W 과부하) &lt;a href=&quot;overload&quot;&gt;과부하&lt;/a&gt; pragma에 인식하지 못하는 인수가 전달되었습니다. 연산자를 잘못 입력 했습니까?</target>
        </trans-unit>
        <trans-unit id="e826b5fc0dae7ccc313c75bbbc79a59aff89f566" translate="yes" xml:space="preserve">
          <source>(W overload) The call to overload::constant contained an odd number of arguments. The arguments should come in pairs.</source>
          <target state="translated">(W 과부하) overload :: constant 호출에 홀수 개의 인수가 포함되었습니다. 인수는 쌍을 이루어야합니다.</target>
        </trans-unit>
        <trans-unit id="be93031fb1c1fd2693de7b970bf1f347826973be" translate="yes" xml:space="preserve">
          <source>(W overload) The second (fourth, sixth, ...) argument of overload::constant needs to be a code reference. Either an anonymous subroutine, or a reference to a subroutine.</source>
          <target state="translated">(W 과부하) overload :: constant의 두 번째 (4 번째, 6 번째, ...) 인수는 코드 참조 여야합니다. 익명 서브 루틴 또는 서브 루틴에 대한 참조입니다.</target>
        </trans-unit>
        <trans-unit id="bb652dad5fd63516cc2d111645fd00a245f45570" translate="yes" xml:space="preserve">
          <source>(W overload) You tried to overload a constant type the overload package is unaware of.</source>
          <target state="translated">(W 과부하) 과부하 패키지가 인식하지 못하는 상수 유형을 과부하하려고했습니다.</target>
        </trans-unit>
        <trans-unit id="cdc892f77860c2fc237ce50d76efd0c8dceb00a4" translate="yes" xml:space="preserve">
          <source>(W pack) Each line in an uuencoded string starts with a length indicator which can't encode values above 63. So there is no point in asking for a line length bigger than that. Perl will behave as if you specified &lt;code&gt;u63&lt;/code&gt; as the format.</source>
          <target state="translated">(W pack) uuencoded 문자열의 각 줄은 63보다 큰 값을 인코딩 할 수없는 길이 표시기로 시작합니다. 따라서 그보다 큰 줄 길이를 요구할 필요가 없습니다. 펄은 &lt;code&gt;u63&lt;/code&gt; 을 지정한 것처럼 동작합니다 을 형식으로 합니다.</target>
        </trans-unit>
        <trans-unit id="eb6f8e362bfe003b879f383a4c911b9a8c85c57c" translate="yes" xml:space="preserve">
          <source>(W pack) You said</source>
          <target state="translated">당신은 말했다</target>
        </trans-unit>
        <trans-unit id="6a2168c56cd322bfb883a2fd9dbaf886812e847c" translate="yes" xml:space="preserve">
          <source>(W pack) You tried something like</source>
          <target state="translated">(W pack) 너는 다음과 같은 것을 시도했다.</target>
        </trans-unit>
        <trans-unit id="331cf753fae1a080c528f36a302470f474fb3136" translate="yes" xml:space="preserve">
          <source>(W pack) You tried to pass a temporary value (like the result of a function, or a computed expression) to the &quot;p&quot; pack() template. This means the result contains a pointer to a location that could become invalid anytime, even before the end of the current statement. Use literals or global values as arguments to the &quot;p&quot; pack() template to avoid this warning.</source>
          <target state="translated">(W pack) &quot;p&quot;pack () 템플릿에 임시 값 (함수 또는 계산식과 같은)을 전달하려고했습니다. 이는 결과에 현재 명령문이 끝나기 전에도 언제든지 유효하지 않은 위치에 대한 포인터가 결과에 포함됨을 의미합니다. 이 경고를 피하려면 리터럴 또는 전역 값을 &quot;p&quot;pack () 템플릿의 인수로 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="512f02482767bcddc779471eaf5fc084e966f52c" translate="yes" xml:space="preserve">
          <source>(W parenthesis) You said something like</source>
          <target state="translated">(W 괄호) 너는 다음과 같이 말했다.</target>
        </trans-unit>
        <trans-unit id="ede1f656195c84e1f48728c83c4610d04755c430" translate="yes" xml:space="preserve">
          <source>(W pipe) A fork in a piped open failed with EAGAIN and will be retried after five seconds.</source>
          <target state="translated">(W 파이프) EAGAIN으로 파이프 열린 상태의 포크가 실패했으며 5 초 후에 다시 시도됩니다.</target>
        </trans-unit>
        <trans-unit id="b5a7c11775d339fb6b5d17e9b9676b5723086198" translate="yes" xml:space="preserve">
          <source>(W pipe) You tried to say &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;(CMD, &quot;|cmd|&quot;)&lt;/code&gt; , which is not supported. You can try any of several modules in the Perl library to do this, such as IPC::Open2. Alternately, direct the pipe's output to a file using &quot;&amp;gt;&quot;, and then read it in under a different file handle.</source>
          <target state="translated">(W 파이프) &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;(CMD, &quot;|cmd|&quot;)&lt;/code&gt; 지원되지 않는 . IPC :: Open2와 같이 Perl 라이브러리의 여러 모듈 중 하나를 사용하여이를 수행 할 수 있습니다. 또는 &quot;&amp;gt;&quot;를 사용하여 파이프의 출력을 파일로 보낸 다음 다른 파일 핸들 아래에서 읽습니다.</target>
        </trans-unit>
        <trans-unit id="19c768ef2795c654e49f763fa1951faf32c04ff6" translate="yes" xml:space="preserve">
          <source>(W pipe) You tried to say &lt;code&gt;open(CMD, &quot;|cmd|&quot;)&lt;/code&gt;, which is not supported. You can try any of several modules in the Perl library to do this, such as IPC::Open2. Alternately, direct the pipe's output to a file using &quot;&amp;gt;&quot;, and then read it in under a different file handle.</source>
          <target state="translated">(W 파이프) 지원되지 않는 &lt;code&gt;open(CMD, &quot;|cmd|&quot;)&lt;/code&gt; 이라고 말하려고했습니다 . 이를 위해 Perl 라이브러리의 여러 모듈 중 하나를 시도 할 수 있습니다 (예 : IPC :: Open2). 또는 &quot;&amp;gt;&quot;를 사용하여 파이프의 출력을 파일로 보낸 다음 다른 파일 핸들 아래에서 읽습니다.</target>
        </trans-unit>
        <trans-unit id="b9cd44d6f9338e432eca0100ebb8cf99a11652fc" translate="yes" xml:space="preserve">
          <source>(W pipe) You used the &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;(FH, &quot;| command&quot;)&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;(FH, &quot;command |&quot;)&lt;/code&gt; construction, but the command was missing or blank.</source>
          <target state="translated">(W 파이프) &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;(FH, &quot;| command&quot;)&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;(FH, &quot;command |&quot;)&lt;/code&gt; 구성을 사용했지만 명령이 없거나 비어 있습니다.</target>
        </trans-unit>
        <trans-unit id="687344f3aa731bf1d9d404caec4abbd832cb105d" translate="yes" xml:space="preserve">
          <source>(W pipe) You used the &lt;code&gt;open(FH, &quot;| command&quot;)&lt;/code&gt; or &lt;code&gt;open(FH, &quot;command |&quot;)&lt;/code&gt; construction, but the command was missing or blank.</source>
          <target state="translated">(W 파이프) &lt;code&gt;open(FH, &quot;| command&quot;)&lt;/code&gt; 또는 &lt;code&gt;open(FH, &quot;command |&quot;)&lt;/code&gt; 구성을 사용했지만 명령이 없거나 비어 있습니다.</target>
        </trans-unit>
        <trans-unit id="33a8500596670f4af1c72a4fafc0180e0691f8b6" translate="yes" xml:space="preserve">
          <source>(W portable) The binary number you specified is larger than 2**32-1 (4294967295) and therefore non-portable between systems. See &lt;a href=&quot;perlport&quot;&gt;perlport&lt;/a&gt; for more on portability concerns.</source>
          <target state="translated">(W 휴대용) 지정한 이진 숫자가 2 ** 32-1 (4294967295)보다 커서 시스템간에 이식 할 수 없습니다. 이식성 문제에 대한 자세한 내용은 &lt;a href=&quot;perlport&quot;&gt;perlport&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="09d1165dcd6590ca88ce45235db739b3730780ae" translate="yes" xml:space="preserve">
          <source>(W portable) The hexadecimal number you specified is larger than 2**32-1 (4294967295) and therefore non-portable between systems. See &lt;a href=&quot;perlport&quot;&gt;perlport&lt;/a&gt; for more on portability concerns.</source>
          <target state="translated">(W 휴대용) 지정한 16 진수는 2 ** 32-1 (4294967295)보다 커서 시스템간에 이식 할 수 없습니다. &lt;a href=&quot;perlport&quot;&gt;perlport&lt;/a&gt; 참조이식성 문제에 대한 자세한 를 .</target>
        </trans-unit>
        <trans-unit id="fc835297f2faad908ec35d66fe96ac88817ca399" translate="yes" xml:space="preserve">
          <source>(W portable) The octal number you specified is larger than 2**32-1 (4294967295) and therefore non-portable between systems. See &lt;a href=&quot;perlport&quot;&gt;perlport&lt;/a&gt; for more on portability concerns.</source>
          <target state="translated">(W 휴대용) 지정한 8 진수가 2 ** 32-1 (4294967295)보다 커서 시스템간에 이식 할 수 없습니다. 이식성 문제에 대한 자세한 내용은 &lt;a href=&quot;perlport&quot;&gt;perlport&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="64214d18f45799923abe2fb1d80cfb4e5a157cf3" translate="yes" xml:space="preserve">
          <source>(W portable) Using bit vector sizes larger than 32 is non-portable.</source>
          <target state="translated">(W portable) 32보다 큰 비트 벡터 크기를 사용하면 이식 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="d926270be302be5e7e03299af7637591efa9d859" translate="yes" xml:space="preserve">
          <source>(W precedence) Your program uses a bitwise logical operator in conjunction with a numeric comparison operator, like this :</source>
          <target state="translated">(W 우선 순위) 프로그램은 다음과 같이 숫자 비교 연산자와 함께 비트 논리 연산자를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="792bff25d5afceb382dc5952aa4d3237868dca22" translate="yes" xml:space="preserve">
          <source>(W printf) Perl does not understand the given format conversion. See &lt;a href=&quot;functions/sprintf&quot;&gt;sprintf&lt;/a&gt;.</source>
          <target state="translated">(W printf) Perl은 주어진 형식 변환을 이해하지 못합니다. &lt;a href=&quot;functions/sprintf&quot;&gt;sprintf를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e6d81bdc34e54445c201e18a346e2f9e257b60b8" translate="yes" xml:space="preserve">
          <source>(W printf) Perl does not understand the given format conversion. See &lt;a href=&quot;perlfunc#sprintf&quot;&gt;&quot;sprintf&quot; in perlfunc&lt;/a&gt;.</source>
          <target state="translated">(W printf) Perl은 주어진 형식 변환을 이해하지 못합니다. &lt;a href=&quot;perlfunc#sprintf&quot;&gt;perlfunc의 &quot;sprintf&quot;를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="9c27ac7b8639b06bd0fbaa78cd260cb1fd460614" translate="yes" xml:space="preserve">
          <source>(W prototype) A prototype was declared in both the parentheses after the sub name and via the prototype attribute. The prototype in parentheses is useless, since it will be replaced by the prototype from the attribute before it's ever used.</source>
          <target state="translated">(W 프로토 타입) 프로토 타입은 하위 이름 뒤의 괄호와 프로토 타입 속성을 통해 선언되었습니다. 괄호 안의 프로토 타입은 사용하기 전에 속성의 프로토 타입으로 대체되므로 쓸모가 없습니다.</target>
        </trans-unit>
        <trans-unit id="33b95571f8339a2cc0606dafed862a4db48c3be9" translate="yes" xml:space="preserve">
          <source>(W prototype) You've called a function that has a prototype before the parser saw a definition or declaration for it, and Perl could not check that the call conforms to the prototype. You need to either add an early prototype declaration for the subroutine in question, or move the subroutine definition ahead of the call to get proper prototype checking. Alternatively, if you are certain that you're calling the function correctly, you may put an ampersand before the name to avoid the warning. See &lt;a href=&quot;perlsub&quot;&gt;perlsub&lt;/a&gt;.</source>
          <target state="translated">(W 프로토 타입) 파서가 정의 또는 선언을보기 전에 프로토 타입이있는 함수를 호출했으며 호출이 프로토 타입을 준수하는지 확인할 수 없습니다. 문제가있는 서브 루틴에 대한 초기 프로토 타입 선언을 추가하거나 서브 루틴 정의를 호출보다 먼저 이동하여 프로토 타입을 올바르게 검사해야합니다. 또는 함수를 올바르게 호출한다고 확신하는 경우 경고를 피하기 위해 이름 앞에 앰퍼샌드를 넣을 수 있습니다. &lt;a href=&quot;perlsub&quot;&gt;perlsub를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="edd018a5f62f70fa66e12afd9da66c3f02d8c926" translate="yes" xml:space="preserve">
          <source>(W qw) qw() lists contain items separated by whitespace; as with literal strings, comment characters are not ignored, but are instead treated as literal data. (You may have used different delimiters than the parentheses shown here; braces are also frequently used.)</source>
          <target state="translated">(W qw) qw () 목록은 공백으로 구분 된 항목을 포함합니다. 리터럴 문자열과 마찬가지로 주석 문자는 무시되지 않고 리터럴 데이터로 처리됩니다. (여기에 표시된 괄호와 다른 구분 기호를 사용했을 수도 있습니다. 중괄호도 자주 사용됩니다.)</target>
        </trans-unit>
        <trans-unit id="578fcce7799c47789b0adac33008237c84ca3a49" translate="yes" xml:space="preserve">
          <source>(W qw) qw() lists contain items separated by whitespace; therefore commas aren't needed to separate the items. (You may have used different delimiters than the parentheses shown here; braces are also frequently used.)</source>
          <target state="translated">(W qw) qw () 목록은 공백으로 구분 된 항목을 포함합니다. 따라서 항목을 구분하기 위해 쉼표가 필요하지 않습니다. (여기에 표시된 괄호와 다른 구분 기호를 사용했을 수도 있습니다. 중괄호도 자주 사용됩니다.)</target>
        </trans-unit>
        <trans-unit id="f98cb1c68560387dbc563580499439d4e545c148" translate="yes" xml:space="preserve">
          <source>(W recursion) This subroutine has called itself (directly or indirectly) 100 times more than it has returned. This probably indicates an infinite recursion, unless you're writing strange benchmark programs, in which case it indicates something else.</source>
          <target state="translated">(W 재귀)이 서브 루틴은 리턴 된 것보다 100 배 더 직접적 또는 간접적으로 호출되었습니다. 이상한 벤치 마크 프로그램을 작성하지 않는 한 무한 재귀를 나타낼 수 있습니다.이 경우 다른 것을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="47929167f9b9dbf125f892daabe93ee9bacbdfe6" translate="yes" xml:space="preserve">
          <source>(W redefine) You redefined a format. To suppress this warning, say</source>
          <target state="translated">(W 재정의) 형식을 재정의했습니다. 이 경고를 표시하지 않으려면</target>
        </trans-unit>
        <trans-unit id="7ea1097acd4664a0298a650f6b5ed50b0394a5e8" translate="yes" xml:space="preserve">
          <source>(W redefine) You redefined a subroutine. To suppress this warning, say</source>
          <target state="translated">(W 재정의) 서브 루틴을 재정의했습니다. 이 경고를 표시하지 않으려면</target>
        </trans-unit>
        <trans-unit id="e221b86b64886bbbd0c221b56cfa1a70910e05ae" translate="yes" xml:space="preserve">
          <source>(W redefine)(S) You redefined a subroutine which had previously been eligible for inlining. See &lt;a href=&quot;perlsub#Constant-Functions&quot;&gt;&quot;Constant Functions&quot; in perlsub&lt;/a&gt; for commentary and workarounds.</source>
          <target state="translated">(W 재정의) (S) 이전에 인라인에 적합했던 서브 루틴을 재정의했습니다. 주석 및 해결 방법 &lt;a href=&quot;perlsub#Constant-Functions&quot;&gt;은 perlsub의 &quot;상수 함수&quot;를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="689f4b16660fc106afaec6518b73b97410cae44a" translate="yes" xml:space="preserve">
          <source>(W redefine)(S) You redefined a subroutine which had previously been eligible for inlining. See &lt;a href=&quot;perlsub#Constant-Functions&quot;&gt;Constant Functions in perlsub&lt;/a&gt; for commentary and workarounds.</source>
          <target state="translated">(W 재정의) (S) 이전에 인라인 할 수있는 서브 루틴을 재정의했습니다. 주석과 해결 방법 &lt;a href=&quot;perlsub#Constant-Functions&quot;&gt;은 perlsub의 상수 함수를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="3855dda462903bfd0f1cb6416b2c27b1d50dfe13" translate="yes" xml:space="preserve">
          <source>(W redundant) You called a function with more arguments than other arguments you supplied indicated would be needed. Currently only emitted when a printf-type format required fewer arguments than were supplied, but might be used in the future for e.g. &lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;.</source>
          <target state="translated">(W 이중화) 제공 한 다른 인수보다 많은 인수가있는 함수를 호출했습니다. 현재 printf 형식 형식이 제공된 것보다 적은 수의 인수가 필요한 경우에만 생성되지만 나중에 &lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt; 과 같이 사용될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3c730546b76271c57854b04aae7a64e30a0a44dc" translate="yes" xml:space="preserve">
          <source>(W redundant) You called a function with more arguments than other arguments you supplied indicated would be needed. Currently only emitted when a printf-type format required fewer arguments than were supplied, but might be used in the future for e.g. &lt;a href=&quot;perlfunc#pack&quot;&gt;&quot;pack&quot; in perlfunc&lt;/a&gt;.</source>
          <target state="translated">(W 중복) 제공 한 다른 인수가 필요하다고 표시 한 것보다 더 많은 인수를 사용하여 함수를 호출했습니다. 현재는 printf 유형 형식이 제공된 것보다 더 적은 인수를 필요로 할 때만 방출되지만 향후에 예를 들어 &lt;a href=&quot;perlfunc#pack&quot;&gt;perlfunc의 &quot;pack&quot;에&lt;/a&gt; 사용될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1214eb3b51b8ff26fb1eb34d1309ab5f40c42cad" translate="yes" xml:space="preserve">
          <source>(W regexp) (only under &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re 'strict'&lt;/code&gt; or within &lt;code&gt;(?[...])&lt;/code&gt; )</source>
          <target state="translated">(W 정규 표현식) ( &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re 'strict'&lt;/code&gt; 또는 &lt;code&gt;(?[...])&lt;/code&gt; 내 에서만 &lt;a href=&quot;functions/use&quot;&gt;사용&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="1418503f1e9d8eefed52fae9d7f65663df0cadff" translate="yes" xml:space="preserve">
          <source>(W regexp) (only under &lt;code&gt;use re 'strict'&lt;/code&gt; or within &lt;code&gt;(?[...])&lt;/code&gt;)</source>
          <target state="translated">(W regexp) ( &lt;code&gt;use re 'strict'&lt;/code&gt; 또는 &lt;code&gt;(?[...])&lt;/code&gt; 내에서만 )</target>
        </trans-unit>
        <trans-unit id="a1df92aaccc50fc27a2b7491f0201ce1e77d6b7c" translate="yes" xml:space="preserve">
          <source>(W regexp) (only under &lt;code&gt;use re 'strict'&lt;/code&gt;)</source>
          <target state="translated">(W regexp) ( &lt;code&gt;use re 'strict'&lt;/code&gt; 에서만 )</target>
        </trans-unit>
        <trans-unit id="96608d49c322029f8dcdf9e023697145af03af25" translate="yes" xml:space="preserve">
          <source>(W regexp) (only under &lt;code&gt;use re 'strict'&lt;/code&gt;) &lt;code&gt;(?)&lt;/code&gt; does nothing, so perhaps this is a typo.</source>
          <target state="translated">(W regexp) (only under &lt;code&gt;use re 'strict'&lt;/code&gt; ) &lt;code&gt;(?)&lt;/code&gt; 아무것도하지 않으므로 아마도 이것은 오타 일 것입니다.</target>
        </trans-unit>
        <trans-unit id="79d7f41c99f2c5e7af10bfeef990dcdf86b08c28" translate="yes" xml:space="preserve">
          <source>(W regexp) Extended character classes currently cannot handle operands that evaluate to more than one character. These are removed from the results of the expansion of the &lt;code&gt;\p{}&lt;/code&gt;.</source>
          <target state="translated">(W regexp) 확장 문자 클래스는 현재 둘 이상의 문자로 평가되는 피연산자를 처리 할 수 ​​없습니다. 이는 &lt;code&gt;\p{}&lt;/code&gt; 확장 결과에서 제거됩니다 .</target>
        </trans-unit>
        <trans-unit id="afe1f8b1a4d34adb7a2f8d5f9d1021945e4cb7e2" translate="yes" xml:space="preserve">
          <source>(W regexp) Minima should be less than or equal to maxima. If you really want your regexp to match something 0 times, just put {0}.</source>
          <target state="translated">(W 정규 표현식) 최소값은 최대 값보다 작거나 같아야합니다. 정규 표현식을 0 번 일치 시키려면 {0}을 넣으십시오.</target>
        </trans-unit>
        <trans-unit id="310e10e88bd557a50ffed62c0a92ae3cc181eb6a" translate="yes" xml:space="preserve">
          <source>(W regexp) Named Unicode character escapes (&lt;code&gt;\N{...}&lt;/code&gt; ) may return a zero-length sequence. When such an escape is used in a character class its behavior is not well defined. Check that the correct escape has been used, and the correct charname handler is in scope.</source>
          <target state="translated">(W 정규 표현식) 명명 된 유니 코드 문자 이스케이프 ( &lt;code&gt;\N{...}&lt;/code&gt; )는 길이가 0 인 시퀀스를 반환 할 수 있습니다. 이러한 이스케이프가 문자 클래스에서 사용될 때 해당 동작은 잘 정의되지 않습니다. 올바른 이스케이프가 사용되었고 올바른 문자 이름 핸들러가 범위 내에 있는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="60783e0f5062372ff8d45c06c31ac1f9f998a5fa" translate="yes" xml:space="preserve">
          <source>(W regexp) Named Unicode character escapes (&lt;code&gt;\N{...}&lt;/code&gt;) may return a zero-length sequence. When such an escape is used in a character class its behavior is not well defined. Check that the correct escape has been used, and the correct charname handler is in scope.</source>
          <target state="translated">(W regexp) 명명 된 유니 코드 문자 이스케이프 ( &lt;code&gt;\N{...}&lt;/code&gt; )는 길이가 0 인 시퀀스를 반환 할 수 있습니다. 이러한 이스케이프가 문자 클래스에서 사용되면 해당 동작이 잘 정의되지 않습니다. 올바른 이스케이프가 사용되었으며 올바른 charname 핸들러가 범위에 있는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="cac34d442feedb85a4f7352a0dc2a4c7f282aa35" translate="yes" xml:space="preserve">
          <source>(W regexp) Named Unicode character escapes &lt;code&gt;(\N{...})&lt;/code&gt; may return a multi-character sequence. Even though a character class is supposed to match just one character of input, perl will match the whole thing correctly, except when the class is inverted (&lt;code&gt;[^...]&lt;/code&gt;), or the escape is the beginning or final end point of a range. For these, what should happen isn't clear at all. In these circumstances, Perl discards all but the first character of the returned sequence, which is not likely what you want.</source>
          <target state="translated">(W regexp) 명명 된 유니 코드 문자 이스케이프 &lt;code&gt;(\N{...})&lt;/code&gt; 는 여러 문자 시퀀스를 반환 할 수 있습니다. 문자 클래스가 입력의 한 문자와 만 일치한다고 가정하더라도 클래스가 반전 되거나 ( &lt;code&gt;[^...]&lt;/code&gt; ) 이스케이프가 시작 또는 마지막 끝점 인 경우를 제외하고 perl은 모든 항목과 정확하게 일치합니다 . 범위. 이를 위해 어떤 일이 발생해야하는지 명확하지 않습니다. 이러한 상황에서 Perl은 리턴 된 순서의 첫 번째 문자를 제외한 모든 문자를 버립니다 (원하는 것은 아님).</target>
        </trans-unit>
        <trans-unit id="87050e38d01b07bff1acd9b58f28df12b4d2afa8" translate="yes" xml:space="preserve">
          <source>(W regexp) Perl thinks that you intended to write a POSIX character class, but didn't use enough brackets. These POSIX class constructs [: :], [= =], and [. .] go</source>
          <target state="translated">(W regexp) Perl은 POSIX 문자 클래스를 작성하려고했지만 충분한 대괄호를 사용하지 않았다고 생각합니다. 이러한 POSIX 클래스는 [: :], [= =] 및 [. .] 가다</target>
        </trans-unit>
        <trans-unit id="979a02ee883c9ec2b29353dd7dff24d69eb2d3ce" translate="yes" xml:space="preserve">
          <source>(W regexp) The &lt;code&gt;p&lt;/code&gt; modifier cannot be turned off once set. Trying to do so is futile.</source>
          <target state="translated">(W 정규식) &lt;code&gt;p&lt;/code&gt; 수정자를 설정 한 후에는 끌 수 없습니다. 그렇게하는 것은 쓸데없는 일입니다.</target>
        </trans-unit>
        <trans-unit id="8836615448ed9381b2dd52c5b2fbe6a905d13b4d" translate="yes" xml:space="preserve">
          <source>(W regexp) The character class constructs [: :], [= =], and [. .] go</source>
          <target state="translated">(W regexp) 문자 클래스는 [: :], [= =] 및 [. .] 가다</target>
        </trans-unit>
        <trans-unit id="9c9b13dc35d66abc0e2ef6aa56dcc54220fb0f95" translate="yes" xml:space="preserve">
          <source>(W regexp) The pattern you've specified would be an infinite loop if the regular expression engine didn't specifically check for that. The &amp;lt;-- HERE shows whereabouts in the regular expression the problem was discovered. See &lt;a href=&quot;perlre&quot;&gt;perlre&lt;/a&gt;.</source>
          <target state="translated">(W regexp) 정규 표현식 엔진이 특별히 확인하지 않은 경우 지정한 패턴은 무한 루프입니다. &amp;lt;-HERE는 정규식에서 문제가 발견 된 위치를 보여줍니다. &lt;a href=&quot;perlre&quot;&gt;perlre를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="34e218ab696b9069c9cee1fbdc8441bff0b2fd36" translate="yes" xml:space="preserve">
          <source>(W regexp) The regular expression engine uses recursion in complex situations where back-tracking is required. Recursion depth is limited to 32766, or perhaps less in architectures where the stack cannot grow arbitrarily. (&quot;Simple&quot; and &quot;medium&quot; situations are handled without recursion and are not subject to a limit.) Try shortening the string under examination; looping in Perl code (e.g. with &lt;code&gt;while&lt;/code&gt; ) rather than in the regular expression engine; or rewriting the regular expression so that it is simpler or backtracks less. (See &lt;a href=&quot;perlfaq2&quot;&gt;perlfaq2&lt;/a&gt; for information on</source>
          <target state="translated">(W regexp) 정규식 엔진은 역 추적이 필요한 복잡한 상황에서 재귀를 사용합니다. 재귀 깊이는 32766으로 제한되거나 스택이 임의로 성장할 수없는 아키텍처에서는 더 적습니다. ( &quot;단순&quot;및 &quot;중간&quot;상황은 재귀없이 처리되며 제한되지 않습니다.) 검사중인 문자열을 줄이십시오. 정규 표현식 엔진이 아닌 Perl 코드에서 반복 (예 : &lt;code&gt;while&lt;/code&gt; ); 또는 정규식을 다시 작성하여 더 단순하거나 역 추적 할 수 있습니다. (에 대한 정보는 &lt;a href=&quot;perlfaq2&quot;&gt;perlfaq2&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="dd6fc64cafd8819f8996fa316c8f285fd7746b68" translate="yes" xml:space="preserve">
          <source>(W regexp) The regular expression engine uses recursion in complex situations where back-tracking is required. Recursion depth is limited to 32766, or perhaps less in architectures where the stack cannot grow arbitrarily. (&quot;Simple&quot; and &quot;medium&quot; situations are handled without recursion and are not subject to a limit.) Try shortening the string under examination; looping in Perl code (e.g. with &lt;code&gt;while&lt;/code&gt;) rather than in the regular expression engine; or rewriting the regular expression so that it is simpler or backtracks less. (See &lt;a href=&quot;perlfaq2&quot;&gt;perlfaq2&lt;/a&gt; for information on</source>
          <target state="translated">(W regexp) 정규식 엔진은 역 추적이 필요한 복잡한 상황에서 재귀를 사용합니다. 재귀 깊이는 32766으로 제한되며 스택이 임의로 확장 될 수없는 아키텍처에서는 그 이하일 수 있습니다. ( &quot;단순&quot;및 &quot;중간&quot;상황은 재귀없이 처리되며 제한이 없습니다.) 검사중인 문자열을 줄이십시오. 정규식 엔진이 아닌 Perl 코드 (예 : &lt;code&gt;while&lt;/code&gt; 사용 ) 에서 루핑 ; 또는 정규 표현식을 다시 작성하여 더 간단하거나 역 추적을 줄입니다. (자세한 내용은 &lt;a href=&quot;perlfaq2&quot;&gt;perlfaq2&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="bcd893d4152d26d0c7cd216e85b74fd84798d49e" translate="yes" xml:space="preserve">
          <source>(W regexp) The simple rule to remember, if you want to match a literal &lt;code&gt;&quot;{&quot;&lt;/code&gt; character (U+007B &lt;code&gt;LEFT CURLY BRACKET&lt;/code&gt;) in a regular expression pattern, is to escape each literal instance of it in some way. Generally easiest is to precede it with a backslash, like &lt;code&gt;&quot;\{&quot;&lt;/code&gt; or enclose it in square brackets (&lt;code&gt;&quot;[{]&quot;&lt;/code&gt;). If the pattern delimiters are also braces, any matching right brace (&lt;code&gt;&quot;}&quot;&lt;/code&gt;) should also be escaped to avoid confusing the parser, for example,</source>
          <target state="translated">(W regexp) 정규식 패턴에서 리터럴 &lt;code&gt;&quot;{&quot;&lt;/code&gt; 문자 (U + 007B &lt;code&gt;LEFT CURLY BRACKET&lt;/code&gt; ) 를 일치시키려는 경우 기억해야 할 간단한 규칙 은 어떤 식 으로든 각 리터럴 인스턴스를 이스케이프하는 것입니다. 일반적으로 가장 쉬운 방법은 &lt;code&gt;&quot;\{&quot;&lt;/code&gt; 와 같이 백 슬래시를 앞에 붙이 거나 대괄호 ( &lt;code&gt;&quot;[{]&quot;&lt;/code&gt; )로 묶는 것입니다 . 패턴 구분 기호도 중괄호 인 경우 일치하는 오른쪽 중괄호 ( &lt;code&gt;&quot;}&quot;&lt;/code&gt; )도 구문 분석기를 혼동하지 않도록 이스케이프해야합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e80a3d940f8d1e707b0bc892519eccf16aea2d95" translate="yes" xml:space="preserve">
          <source>(W regexp) You applied a regular expression quantifier in a place where it makes no sense, such as on a zero-width assertion. Try putting the quantifier inside the assertion instead. For example, the way to match &quot;abc&quot; provided that it is followed by three repetitions of &quot;xyz&quot; is &lt;code&gt;/abc(?=(?:xyz){3})/&lt;/code&gt; , not &lt;code&gt;/abc(?=xyz){3}/&lt;/code&gt; .</source>
          <target state="translated">(W regexp) 너비가 0 인 어설 션과 같이 의미가없는 곳에 정규식 수량자를 적용했습니다. 대신 어설 션 안에 정량자를 넣으십시오. 예를 들어, 방법은 그것이 &quot;XYZ&quot;세 번 반복 하였다 것을 제공 &quot;ABC&quot;와 일치하는 &lt;code&gt;/abc(?=(?:xyz){3})/&lt;/code&gt; 하지 &lt;code&gt;/abc(?=xyz){3}/&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6b116c34912c573289d414f1c5ba731419acfc1d" translate="yes" xml:space="preserve">
          <source>(W regexp) You applied a regular expression quantifier in a place where it makes no sense, such as on a zero-width assertion. Try putting the quantifier inside the assertion instead. For example, the way to match &quot;abc&quot; provided that it is followed by three repetitions of &quot;xyz&quot; is &lt;code&gt;/abc(?=(?:xyz){3})/&lt;/code&gt;, not &lt;code&gt;/abc(?=xyz){3}/&lt;/code&gt;.</source>
          <target state="translated">(W regexp) 너비가 0 인 어설 션과 같이 의미가없는 곳에 정규식 한정자를 적용했습니다. 대신 어설 션 안에 수량자를 넣으십시오. 예를 들어, 방법은 그것이 &quot;XYZ&quot;세 번 반복 하였다 것을 제공 &quot;ABC&quot;와 일치하는 &lt;code&gt;/abc(?=(?:xyz){3})/&lt;/code&gt; 하지 &lt;code&gt;/abc(?=xyz){3}/&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5f9d6046f4892a59f0789eb9e0cd6b5353468138" translate="yes" xml:space="preserve">
          <source>(W regexp) You had something like these:</source>
          <target state="translated">(W regexp) 다음과 같은 것이 있습니다.</target>
        </trans-unit>
        <trans-unit id="136a9995a2e015be707b998b2100f17123be4162" translate="yes" xml:space="preserve">
          <source>(W regexp) You have used an internal modifier such as (?-o) that has no meaning unless removed from the entire regexp:</source>
          <target state="translated">(W 정규 표현식) 전체 정규 표현식에서 제거하지 않으면 의미가없는 (? -o)와 같은 내부 수정자를 사용했습니다.</target>
        </trans-unit>
        <trans-unit id="55d68e94b03df6dbd58f4c0d015f0fad8b599b8d" translate="yes" xml:space="preserve">
          <source>(W regexp) You have used an internal modifier such as (?o) that has no meaning unless applied to the entire regexp:</source>
          <target state="translated">(W 정규 표현식) 전체 정규 표현식에 적용되지 않는 한 의미가없는 (? o)와 같은 내부 수정자를 사용했습니다.</target>
        </trans-unit>
        <trans-unit id="b43adfc5e63fb549f624f667292c77a5d4453619" translate="yes" xml:space="preserve">
          <source>(W regexp) You specified a wildcard for a Unicode property value, but there is no property value in the current Unicode release that matches it. Check your spelling.</source>
          <target state="translated">(W regexp) 유니 코드 속성 값에 와일드 카드를 지정했지만 현재 유니 코드 릴리스에 일치하는 속성 값이 없습니다. 철자를 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="4dff6ec1a19e7de52b41046a33967e1771a1d39a" translate="yes" xml:space="preserve">
          <source>(W regexp) You specified something like these:</source>
          <target state="translated">(W regexp) 다음과 같이 지정했습니다.</target>
        </trans-unit>
        <trans-unit id="a554f4535489ad2df9ed3cca605416c0a1c6af75" translate="yes" xml:space="preserve">
          <source>(W regexp) You used a Unicode boundary (&lt;code&gt;\b{...}&lt;/code&gt; or &lt;code&gt;\B{...}&lt;/code&gt; ) in a portion of a regular expression where the character set modifiers &lt;code&gt;/a&lt;/code&gt; or &lt;code&gt;/aa&lt;/code&gt; are in effect. These two modifiers indicate an ASCII interpretation, and this doesn't make sense for a Unicode defintion. The generated regular expression will compile so that the boundary uses all of Unicode. No other portion of the regular expression is affected.</source>
          <target state="translated">(W regexp) 문자 세트 수정 자 &lt;code&gt;/a&lt;/code&gt; 또는 &lt;code&gt;/aa&lt;/code&gt; 가 적용 되는 정규 표현식 부분에서 유니 코드 경계 ( &lt;code&gt;\b{...}&lt;/code&gt; 또는 &lt;code&gt;\B{...}&lt;/code&gt; )를 사용했습니다 . 이 두 수정자는 ASCII 해석을 나타내며 유니 코드 정의에는 적합하지 않습니다. 생성 된 정규식은 경계가 모든 유니 코드를 사용하도록 컴파일됩니다. 정규식의 다른 부분은 영향을받지 않습니다.</target>
        </trans-unit>
        <trans-unit id="cd51f2ada30069ed0e5474392eee3320b75dfab6" translate="yes" xml:space="preserve">
          <source>(W regexp) You used a Unicode boundary (&lt;code&gt;\b{...}&lt;/code&gt; or &lt;code&gt;\B{...}&lt;/code&gt;) in a portion of a regular expression where the character set modifiers &lt;code&gt;/a&lt;/code&gt; or &lt;code&gt;/aa&lt;/code&gt; are in effect. These two modifiers indicate an ASCII interpretation, and this doesn't make sense for a Unicode definition. The generated regular expression will compile so that the boundary uses all of Unicode. No other portion of the regular expression is affected.</source>
          <target state="translated">(W regexp) 문자 집합 수정 자 &lt;code&gt;/a&lt;/code&gt; 또는 &lt;code&gt;/aa&lt;/code&gt; 가 적용 되는 정규식의 일부에서 유니 코드 경계 ( &lt;code&gt;\b{...}&lt;/code&gt; 또는 &lt;code&gt;\B{...}&lt;/code&gt; )를 사용했습니다 . 이 두 수정자는 ASCII 해석을 나타내며 유니 코드 정의에는 의미가 없습니다. 생성 된 정규식은 경계가 모든 유니 코드를 사용하도록 컴파일됩니다. 정규식의 다른 부분은 영향을받지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c858a1bb6c94f36a1ad78cfa5e12eef38835bc65" translate="yes" xml:space="preserve">
          <source>(W regexp) You used a backslash-character combination which is not recognized by Perl inside character classes. The character was understood literally, but this may change in a future version of Perl. The &amp;lt;-- HERE shows whereabouts in the regular expression the escape was discovered.</source>
          <target state="translated">(W regexp) 문자 클래스 내부에서 Perl에 의해 인식되지 않는 백 슬래시 문자 조합을 사용했습니다. 캐릭터는 문자 그대로 이해되었지만 이후 버전의 Perl에서 변경 될 수 있습니다. &amp;lt;-HERE는 이스케이프가 발견 된 정규식의 위치를 ​​보여줍니다.</target>
        </trans-unit>
        <trans-unit id="f4b5c5f036648db103b8f6b0d672a6297b55d830" translate="yes" xml:space="preserve">
          <source>(W regexp) You used a backslash-character combination which is not recognized by Perl. The character(s) were understood literally, but this may change in a future version of Perl. The &amp;lt;-- HERE shows whereabouts in the regular expression the escape was discovered.</source>
          <target state="translated">(W regexp) Perl에서 인식 할 수없는 백 슬래시 문자 조합을 사용했습니다. 문자는 문자 그대로 이해되었지만 이후 버전의 Perl에서 변경 될 수 있습니다. &amp;lt;-HERE는 이스케이프가 발견 된 정규식의 위치를 ​​보여줍니다.</target>
        </trans-unit>
        <trans-unit id="726bc29b79e757efbbf6291f3feab7738f4156dd" translate="yes" xml:space="preserve">
          <source>(W regexp) You used the /c modifier in a substitution. The /c modifier is not presently meaningful in substitutions.</source>
          <target state="translated">(W regexp) / c 수정자를 대체에 사용했습니다. / c 수정자는 현재 대체에 의미가 없습니다.</target>
        </trans-unit>
        <trans-unit id="f9138d3ceb624a8a5b53b139e9b01cf402ccd97d" translate="yes" xml:space="preserve">
          <source>(W regexp) You used the /c modifier with a regex operand, but didn't use the /g modifier. Currently, /c is meaningful only when /g is used. (This may change in the future.)</source>
          <target state="translated">(W regexp) 정규식 피연산자와 함께 / c 수정자를 사용했지만 / g 수정자를 사용하지 않았습니다. 현재 / c는 / g가 사용될 때만 의미가 있습니다. (향후 변경 될 수 있습니다.)</target>
        </trans-unit>
        <trans-unit id="05230a0b7de0944fc11913778fd1b00ae30b0de3" translate="yes" xml:space="preserve">
          <source>(W regexp) You used the /g modifier on the pattern for a &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; operator. Since &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; always tries to match the pattern repeatedly, the &lt;code&gt;/g&lt;/code&gt; has no effect.</source>
          <target state="translated">(W regexp) &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; 연산자 의 패턴에서 / g 수정자를 사용했습니다 . &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; 은 항상 패턴을 반복적으로 일치 시키려고하기 때문에 &lt;code&gt;/g&lt;/code&gt; 는 효과가 없습니다.</target>
        </trans-unit>
        <trans-unit id="fa05f976ea4a21f23deaf9fc8dc841cd7c0db3ed" translate="yes" xml:space="preserve">
          <source>(W regexp) You used the /g modifier on the pattern for a &lt;code&gt;split&lt;/code&gt; operator. Since &lt;code&gt;split&lt;/code&gt; always tries to match the pattern repeatedly, the &lt;code&gt;/g&lt;/code&gt; has no effect.</source>
          <target state="translated">(W regexp) &lt;code&gt;split&lt;/code&gt; 연산자 의 패턴에 / g 수정자를 사용했습니다 . &lt;code&gt;split&lt;/code&gt; 은 항상 패턴을 반복적으로 일치 시키려고하기 때문에 &lt;code&gt;/g&lt;/code&gt; 는 효과가 없습니다.</target>
        </trans-unit>
        <trans-unit id="fce92f52ceba5999bee49caf7c2b501e30f4a70d" translate="yes" xml:space="preserve">
          <source>(W regexp)(F) A character class range must start and end at a literal character, not another character class like &lt;code&gt;\d&lt;/code&gt; or &lt;code&gt;[:alpha:]&lt;/code&gt;. The &quot;-&quot; in your false range is interpreted as a literal &quot;-&quot;. In a &lt;code&gt;(?[...])&lt;/code&gt; construct, this is an error, rather than a warning. Consider quoting the &quot;-&quot;, &quot;\-&quot;. The &amp;lt;-- HERE shows whereabouts in the regular expression the problem was discovered. See &lt;a href=&quot;perlre&quot;&gt;perlre&lt;/a&gt;.</source>
          <target state="translated">(W regexp) (F) 문자 클래스 범위는 &lt;code&gt;\d&lt;/code&gt; 또는 &lt;code&gt;[:alpha:]&lt;/code&gt; 와 같은 다른 문자 클래스가 아닌 리터럴 문자로 시작하고 끝나야합니다 . 잘못된 범위의 &quot;-&quot;는 리터럴 &quot;-&quot;로 해석됩니다. A의 &lt;code&gt;(?[...])&lt;/code&gt; 구조물이 오히려 경고보다 오류이다. &quot;-&quot;, &quot;\-&quot;를 인용하십시오. &amp;lt;-HERE는 정규식에서 문제가 발견 된 위치를 보여줍니다. &lt;a href=&quot;perlre&quot;&gt;펄레&lt;/a&gt; 참조 .</target>
        </trans-unit>
        <trans-unit id="d8e9fa34a2adca3b8cdfab34d848f2df35e1e065" translate="yes" xml:space="preserve">
          <source>(W regexp)(F) The numeric escape (for example &lt;code&gt;\xHH&lt;/code&gt; ) of value &amp;lt; 256 didn't correspond to a single character through the conversion from the encoding specified by the encoding pragma. The escape was replaced with REPLACEMENT CHARACTER (U+FFFD) instead, except within &lt;code&gt;(?[   ])&lt;/code&gt; , where it is a fatal error. The &amp;lt;-- HERE shows whereabouts in the regular expression the escape was discovered.</source>
          <target state="translated">(W regexp) (F) 값이 &amp;lt;256 인 숫자 이스케이프 (예 : &lt;code&gt;\xHH&lt;/code&gt; )는 인코딩 pragma로 지정된 인코딩에서 변환하여 단일 문자에 해당하지 않습니다. 치명적 오류 인 &lt;code&gt;(?[ ])&lt;/code&gt; 내를 제외하고 대신 이스케이프가 REPLACEMENT CHARACTER (U + FFFD)로 대체되었습니다 . &amp;lt;-HERE는 이스케이프가 발견 된 정규식의 위치를 ​​보여줍니다.</target>
        </trans-unit>
        <trans-unit id="a257315534d5cc6e84833f33abd1dd3381a6b41c" translate="yes" xml:space="preserve">
          <source>(W regexp)(F) The numeric escape (for example &lt;code&gt;\xHH&lt;/code&gt;) of value &amp;lt; 256 didn't correspond to a single character through the conversion from the encoding specified by the encoding pragma. The escape was replaced with REPLACEMENT CHARACTER (U+FFFD) instead, except within &lt;code&gt;(?[ ])&lt;/code&gt;, where it is a fatal error. The &amp;lt;-- HERE shows whereabouts in the regular expression the escape was discovered.</source>
          <target state="translated">(W regexp) (F) 값 &amp;lt;256 의 숫자 이스케이프 (예 : &lt;code&gt;\xHH&lt;/code&gt; )가 인코딩 pragma에 지정된 인코딩에서 변환을 통해 단일 문자에 해당하지 않았습니다. 이스케이프는 대신 REPLACEMENT CHARACTER (U + FFFD)로 대체되었습니다. 단, &lt;code&gt;(?[ ])&lt;/code&gt; 에서는 치명적인 오류가 발생합니다. &amp;lt;-HERE는 정규식에서 이스케이프가 발견 된 위치를 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="ab5d2805454216bda7ba450af2c1070e6d07a77b" translate="yes" xml:space="preserve">
          <source>(W reserved) A lowercase attribute name was used that had a package-specific handler. That name might have a meaning to Perl itself some day, even though it doesn't yet. Perhaps you should use a mixed-case attribute name, instead. See &lt;a href=&quot;attributes&quot;&gt;attributes&lt;/a&gt;.</source>
          <target state="translated">(W reserved) 패키지 별 핸들러가있는 소문자 속성 이름이 사용되었습니다. 그 이름은 아직은 아니지만 언젠가 Perl 자체에 의미가있을 수 있습니다. 대신 대소 문자 혼합 속성 이름을 사용해야합니다. &lt;a href=&quot;attributes&quot;&gt;속성을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="28a74896a26f8e20c063399ec49864ab28f3d526" translate="yes" xml:space="preserve">
          <source>(W reserved) You used a bareword that might someday be claimed as a reserved word. It's best to put such a word in quotes, or capitalize it somehow, or insert an underbar into it. You might also declare it as a subroutine.</source>
          <target state="translated">(W reserved) 언젠가는 예약어로 주장 될 수있는 베어 워드를 사용했습니다. 그러한 단어를 따옴표로 묶거나 어떻게 든 대문자로 쓰거나 밑줄을 삽입하는 것이 가장 좋습니다. 서브 루틴으로 선언 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="b7f56b2509559b232b5aa9bdc88fbfd521c4a370" translate="yes" xml:space="preserve">
          <source>(W semicolon) A nearby syntax error was probably caused by a missing semicolon, or possibly some other missing operator, such as a comma.</source>
          <target state="translated">(W 세미콜론) 근처의 구문 오류는 세미콜론이 누락되었거나 쉼표와 같은 다른 누락 된 연산자로 인해 발생했을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="75808a105415bb63e05cf6d998b7aba9b280a40b" translate="yes" xml:space="preserve">
          <source>(W shadow) A &quot;my&quot; or &quot;state&quot; subroutine has been redeclared in the current scope or statement, effectively eliminating all access to the previous instance. This is almost always a typographical error. Note that the earlier subroutine will still exist until the end of the scope or until all closure references to it are destroyed.</source>
          <target state="translated">(W shadow) &quot;my&quot;또는 &quot;state&quot;서브 루틴이 현재 범위 또는 명령문에서 다시 선언되어 이전 인스턴스에 대한 모든 액세스를 효과적으로 제거합니다. 이것은 거의 항상 인쇄상의 오류입니다. 이전 서브 루틴은 범위가 끝날 때까지 또는 이에 대한 모든 클로저 참조가 소멸 될 때까지 계속 존재합니다.</target>
        </trans-unit>
        <trans-unit id="72e5c1f7f8c71e274cd33bf02f816a55e48749b0" translate="yes" xml:space="preserve">
          <source>(W shadow) A &quot;my&quot;, &quot;our&quot; or &quot;state&quot; variable has been redeclared in the current scope or statement, effectively eliminating all access to the previous instance. This is almost always a typographical error. Note that the earlier variable will still exist until the end of the scope or until all closure references to it are destroyed.</source>
          <target state="translated">(W shadow) &quot;my&quot;, &quot;our&quot;또는 &quot;state&quot;변수가 현재 범위 또는 명령문에서 다시 선언되어 이전 인스턴스에 대한 모든 액세스를 효과적으로 제거했습니다. 이것은 거의 항상 인쇄상의 오류입니다. 이전 변수는 범위가 끝날 때까지 또는 이에 대한 모든 클로저 참조가 소멸 될 때까지 계속 존재합니다.</target>
        </trans-unit>
        <trans-unit id="cb918e1b6994e324b9f74515b4c8e906a5d67301" translate="yes" xml:space="preserve">
          <source>(W shadow) Remember that &quot;our&quot; does not localize the declared global variable. You have declared it again in the same lexical scope, which seems superfluous.</source>
          <target state="translated">(W shadow) &quot;our&quot;는 선언 된 전역 변수를 지역화하지 않습니다. 불필요한 것처럼 보이는 동일한 어휘 범위에서 다시 선언했습니다.</target>
        </trans-unit>
        <trans-unit id="fb4c8592e41268e19a98f9c44343d5bbbe048bd6" translate="yes" xml:space="preserve">
          <source>(W shadow) You seem to have already declared the same global once before in the current lexical scope.</source>
          <target state="translated">(W shadow) 현재 어휘 범위에서 이전에 동일한 글로벌을 이미 한 번 선언 한 것 같습니다.</target>
        </trans-unit>
        <trans-unit id="c490a0614ad09a273c847f914c444441bd43e759" translate="yes" xml:space="preserve">
          <source>(W signal) Perl has detected that it is being run with the SIGCHLD signal (sometimes known as SIGCLD) disabled. Since disabling this signal will interfere with proper determination of exit status of child processes, Perl has reset the signal to its default value. This situation typically indicates that the parent program under which Perl may be running (e.g. cron) is being very careless.</source>
          <target state="translated">(W 신호) Perl은 SIGCHLD 신호 (SIGCLD라고도 함)가 비활성화 된 상태에서 실행되고 있음을 감지했습니다. 이 신호를 비활성화하면 하위 프로세스의 종료 상태를 올바르게 결정하는 데 방해가되기 때문에 Perl은 신호를 기본값으로 재설정했습니다. 이 상황은 일반적으로 Perl이 실행되는 상위 프로그램 (예 : cron)이 매우 부주의하다는 것을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="d36a3561d6f20cf601cc8fdcd8a0b693b632d4af" translate="yes" xml:space="preserve">
          <source>(W signal) The signal handler named in %SIG doesn't, in fact, exist. Perhaps you put it into the wrong package?</source>
          <target state="translated">(W 신호) % SIG로 명명 된 신호 처리기는 실제로 존재하지 않습니다. 아마도 당신은 그것을 잘못된 패키지에 넣었습니까?</target>
        </trans-unit>
        <trans-unit id="ebc35d5a02e4c063b197676d1cbd12f47c19df5b" translate="yes" xml:space="preserve">
          <source>(W signal) You specified a signal name as a subscript to %SIG that was not recognized. Say &lt;code&gt;&lt;a href=&quot;functions/kill&quot;&gt;kill&lt;/a&gt; -l&lt;/code&gt; in your shell to see the valid signal names on your system.</source>
          <target state="translated">(W 신호) 인식되지 않은 신호 이름을 % SIG의 첨자로 지정했습니다. 쉘에서 &lt;code&gt;&lt;a href=&quot;functions/kill&quot;&gt;kill&lt;/a&gt; -l&lt;/code&gt; 이라고 말하면 시스템에서 유효한 신호 이름을 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="29464a8694afd3b6f7fa2dedad18f5d42ea27aab" translate="yes" xml:space="preserve">
          <source>(W signal) You specified a signal name as a subscript to %SIG that was not recognized. Say &lt;code&gt;kill -l&lt;/code&gt; in your shell to see the valid signal names on your system.</source>
          <target state="translated">(W 신호) 인식되지 않는 % SIG의 아래 첨자로 신호 이름을 지정했습니다. 시스템에서 유효한 신호 이름을 보려면 쉘에서 &lt;code&gt;kill -l&lt;/code&gt; 이라고 말 하십시오.</target>
        </trans-unit>
        <trans-unit id="95ce3889bdccfd28d07038434edbc2f2493245c4" translate="yes" xml:space="preserve">
          <source>(W substr) You supplied a reference as the first argument to substr() used as an lvalue, which is pretty strange. Perhaps you forgot to dereference it first. See &lt;a href=&quot;functions/substr&quot;&gt;substr&lt;/a&gt;.</source>
          <target state="translated">(W substr) lvalue로 사용 된 substr ()의 첫 번째 인수로 참조를 제공했습니다. 이는 매우 이상합니다. 아마도 당신은 그것을 먼저 역 참조하는 것을 잊었을 것입니다. &lt;a href=&quot;functions/substr&quot;&gt;substr을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b3c16ce2faeb9fe19c37eae4699c0794a6365401" translate="yes" xml:space="preserve">
          <source>(W substr) You supplied a reference as the first argument to substr() used as an lvalue, which is pretty strange. Perhaps you forgot to dereference it first. See &lt;a href=&quot;perlfunc#substr&quot;&gt;&quot;substr&quot; in perlfunc&lt;/a&gt;.</source>
          <target state="translated">(W substr) lvalue로 사용되는 substr ()에 대한 첫 번째 인수로 참조를 제공했는데 이는 매우 이상합니다. 아마도 당신은 그것을 먼저 역 참조하는 것을 잊었을 것입니다. &lt;a href=&quot;perlfunc#substr&quot;&gt;perlfunc의 &quot;substr&quot;을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="45bd593b8e5b2713b2a66073ce71b9f0acf28d3e" translate="yes" xml:space="preserve">
          <source>(W substr)(F) You tried to reference a substr() that pointed outside of a string. That is, the absolute value of the offset was larger than the length of the string. See &lt;a href=&quot;functions/substr&quot;&gt;substr&lt;/a&gt;. This warning is fatal if substr is used in an lvalue context (as the left hand side of an assignment or as a subroutine argument for example).</source>
          <target state="translated">(W substr) (F) 문자열 외부를 가리키는 substr ()을 참조하려고했습니다. 즉, 오프셋의 절대 값이 문자열의 길이보다 컸습니다. 보다&lt;a href=&quot;functions/substr&quot;&gt;substr&lt;/a&gt; . substr이 lvalue 컨텍스트에서 사용되는 경우 (할당의 왼쪽 또는 서브 루틴 인수로)이 경고는 치명적입니다.</target>
        </trans-unit>
        <trans-unit id="fa3bd79208f2807a2e68a929f599e40382a62ba4" translate="yes" xml:space="preserve">
          <source>(W substr)(F) You tried to reference a substr() that pointed outside of a string. That is, the absolute value of the offset was larger than the length of the string. See &lt;a href=&quot;perlfunc#substr&quot;&gt;&quot;substr&quot; in perlfunc&lt;/a&gt;. This warning is fatal if substr is used in an lvalue context (as the left hand side of an assignment or as a subroutine argument for example).</source>
          <target state="translated">(W substr) (F) 문자열 외부를 가리키는 substr ()을 참조하려고했습니다. 즉, 오프셋의 절대 값이 문자열의 길이보다 큽니다. &lt;a href=&quot;perlfunc#substr&quot;&gt;perlfunc의 &quot;substr&quot;을&lt;/a&gt; 참조하십시오 . 이 경고는 substr이 lvalue 컨텍스트 (예 : 할당의 왼쪽 또는 서브 루틴 인수)에서 사용되는 경우 치명적입니다.</target>
        </trans-unit>
        <trans-unit id="3d3783a27c8ae64e0627e00b19a488f16e27fa85" translate="yes" xml:space="preserve">
          <source>(W syntax) A format specified more picture fields than the next line supplied. See &lt;a href=&quot;perlform&quot;&gt;perlform&lt;/a&gt;.</source>
          <target state="translated">(W 구문) 형식이 제공된 다음 행보다 많은 그림 필드를 지정했습니다. 보다&lt;a href=&quot;perlform&quot;&gt;perlform을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5675d244b6de72370cd69ca41f42a80de4dd6d27" translate="yes" xml:space="preserve">
          <source>(W syntax) An underscore (underbar) in a numeric constant did not separate two digits.</source>
          <target state="translated">(W 구문) 숫자 상수의 밑줄 (밑줄)은 두 자리를 분리하지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="1928c9501e662b0f8de723a59ea0b97a4ece6c53" translate="yes" xml:space="preserve">
          <source>(W syntax) In an ordinary expression, backslash is a unary operator that creates a reference to its argument. The use of backslash to indicate a backreference to a matched substring is valid only as part of a regular expression pattern. Trying to do this in ordinary Perl code produces a value that prints out looking like SCALAR(0xdecaf). Use the $1 form instead.</source>
          <target state="translated">(W 구문) 일반 표현식에서 백 슬래시는 인수에 대한 참조를 작성하는 단항 연산자입니다. 일치하는 하위 문자열에 대한 역 참조를 나타내는 데 백 슬래시를 사용하는 것은 정규식 패턴의 일부로 만 유효합니다. 일반적인 Perl 코드에서이 작업을 시도하면 SCALAR (0xdecaf)와 같은 값이 인쇄됩니다. 대신 $ 1 양식을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="8f8213e084e20348a91dcc660ab8e17dcde1e497" translate="yes" xml:space="preserve">
          <source>(W syntax) In scalar context, you've used a hash key/value slice (indicated by %) to select a single element of a hash. Generally it's better to ask for a scalar value (indicated by $). The difference is that &lt;code&gt;$foo{&amp;amp;bar}&lt;/code&gt; always behaves like a scalar, both in the value it returns and when evaluating its argument, while &lt;code&gt;@foo{&amp;amp;bar}&lt;/code&gt; and provides a list context to its subscript, which can do weird things if you're expecting only one subscript. When called in list context, it also returns the key in addition to the value.</source>
          <target state="translated">(W 구문) 스칼라 컨텍스트에서는 해시 키 / 값 슬라이스 (%로 표시)를 사용하여 해시의 단일 요소를 선택했습니다. 일반적으로 스칼라 값 ($로 표시)을 요청하는 것이 좋습니다. 차이점은 &lt;code&gt;$foo{&amp;amp;bar}&lt;/code&gt; 항상 반환하는 값과 인수를 평가할 때 스칼라처럼 동작하지만 &lt;code&gt;@foo{&amp;amp;bar}&lt;/code&gt; 는 첨자에 목록 컨텍스트를 제공하여 하나의 첨자를 기대합니다. 목록 컨텍스트에서 호출되면 값 외에도 키를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="139c16302575faefa44e53211603b79b770480b6" translate="yes" xml:space="preserve">
          <source>(W syntax) In scalar context, you've used an array index/value slice (indicated by %) to select a single element of an array. Generally it's better to ask for a scalar value (indicated by $). The difference is that &lt;code&gt;$foo[&amp;amp;bar]&lt;/code&gt; always behaves like a scalar, both in the value it returns and when evaluating its argument, while &lt;code&gt;%foo[&amp;amp;bar]&lt;/code&gt; provides a list context to its subscript, which can do weird things if you're expecting only one subscript. When called in list context, it also returns the index (what &lt;code&gt;&amp;amp;bar&lt;/code&gt; returns) in addition to the value.</source>
          <target state="translated">(W 구문) 스칼라 컨텍스트에서 배열 인덱스 / 값 슬라이스 (%로 표시)를 사용하여 배열의 단일 요소를 선택했습니다. 일반적으로 스칼라 값 ($로 표시)을 요청하는 것이 좋습니다. 차이점은 &lt;code&gt;$foo[&amp;amp;bar]&lt;/code&gt; 항상 반환하는 값과 인수를 평가할 때 스칼라처럼 동작하지만 &lt;code&gt;%foo[&amp;amp;bar]&lt;/code&gt; 는 첨자에 목록 컨텍스트를 제공합니다. 하나의 첨자를 기대합니다. 리스트 컨텍스트에서 호출되면 값과 함께 인덱스 ( &lt;code&gt;&amp;amp;bar&lt;/code&gt; 가 리턴하는 것)도 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="aaec30e2b82d4c39ee887958d74052bd7fee0a74" translate="yes" xml:space="preserve">
          <source>(W syntax) It is possible that the &lt;code&gt;@ISA&lt;/code&gt; contains a misspelled or never loaded package name, which can result in perl choosing an unexpected parent class's method to resolve the method call. If this is deliberate you can do something like</source>
          <target state="translated">(W 구문) &lt;code&gt;@ISA&lt;/code&gt; 에 철자가 틀리거나로드되지 않은 패키지 이름이 포함되어있을 수 있으며, 이로 인해 Perl이 예기치 않은 부모 클래스의 메서드를 선택하여 메서드 호출을 해결할 수 있습니다. 이것이 의도적 인 경우 다음과 같이 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d8bea33901ad329853cff0f65df1ca724eb5c0d4" translate="yes" xml:space="preserve">
          <source>(W syntax) Multidimensional arrays aren't written like &lt;code&gt;$foo[1,2,3]&lt;/code&gt; . They're written like &lt;code&gt;$foo[1][2][3]&lt;/code&gt; , as in C.</source>
          <target state="translated">(W 구문) 다차원 배열은 &lt;code&gt;$foo[1,2,3]&lt;/code&gt; 처럼 작성되지 않습니다 . C 에서처럼 &lt;code&gt;$foo[1][2][3]&lt;/code&gt; 처럼 작성되었습니다.</target>
        </trans-unit>
        <trans-unit id="80669e00996092e3d1a0e78e0b65c2cb0112cd12" translate="yes" xml:space="preserve">
          <source>(W syntax) Multidimensional arrays aren't written like &lt;code&gt;$foo[1,2,3]&lt;/code&gt;. They're written like &lt;code&gt;$foo[1][2][3]&lt;/code&gt;, as in C.</source>
          <target state="translated">(W 구문) 다차원 배열은 &lt;code&gt;$foo[1,2,3]&lt;/code&gt; 처럼 작성되지 않습니다 . C에서와 같이 &lt;code&gt;$foo[1][2][3]&lt;/code&gt; 와 같이 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="04868e0f94e46c3fd4ce21403945fec70d551ecb" translate="yes" xml:space="preserve">
          <source>(W syntax) Outside of patterns, backreferences live on as variables. The use of backslashes is grandfathered on the right-hand side of a substitution, but stylistically it's better to use the variable form because other Perl programmers will expect it, and it works better if there are more than 9 backreferences.</source>
          <target state="translated">(W 구문) 패턴 외부에서 역 참조는 변수로 존재합니다. 백 슬래시의 사용은 대체의 오른쪽에 할아버지가 있지만 문체 적으로 다른 Perl 프로그래머가 예상 할 수 있기 때문에 변수 형식을 사용하는 것이 좋으며 역 참조가 9 개 이상인 경우 더 잘 작동합니다.</target>
        </trans-unit>
        <trans-unit id="86e02829ec2db0aad141e5ff8b7b48fa26969bba" translate="yes" xml:space="preserve">
          <source>(W syntax) The &lt;code&gt;\c&lt;i&gt;X&lt;/i&gt;&lt;/code&gt; construct is intended to be a way to specify non-printable characters. You used it for a printable one, which is better written as simply itself, perhaps preceded by a backslash for non-word characters. Doing it the way you did is not portable between ASCII and EBCDIC platforms.</source>
          <target state="translated">(W 구문) &lt;code&gt;\c&lt;i&gt;X&lt;/i&gt;&lt;/code&gt; 구문은 인쇄 할 수없는 문자를 지정하기위한 것입니다. 인쇄용으로 사용했는데, 단어 자체가 아닌 문자의 경우 백 슬래시가 앞에 오는 단순한 자체로 더 잘 작성되었습니다. ASCII와 EBCDIC 플랫폼 간에는 그렇게 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="1e1aacc7413fa4819361698891a0668505640b7d" translate="yes" xml:space="preserve">
          <source>(W syntax) The @ISA array contained the name of another package that doesn't seem to exist.</source>
          <target state="translated">(W 구문) @ISA 배열에는 존재하지 않는 다른 패키지의 이름이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="f851398285267cd295332fc573c6ef5e8844f07f" translate="yes" xml:space="preserve">
          <source>(W syntax) The localization of lvalues such as &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local($x=10)&lt;/a&gt;&lt;/code&gt; is legal, but in fact the local() currently has no effect. This may change at some point in the future, but in the meantime such code is discouraged.</source>
          <target state="translated">(W 구문) &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local($x=10)&lt;/a&gt;&lt;/code&gt; 과 같은 lvalue의 지역화 는 합법적이지만 실제로 local ()은 효과가 없습니다. 향후 언젠가 변경 될 수 있지만 그 동안 해당 코드는 사용하지 않는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="7bd569ce6df70faf3a3011c533249f92b01128d2" translate="yes" xml:space="preserve">
          <source>(W syntax) The localization of lvalues such as &lt;code&gt;local($x=10)&lt;/code&gt; is legal, but in fact the local() currently has no effect. This may change at some point in the future, but in the meantime such code is discouraged.</source>
          <target state="translated">(W 구문) &lt;code&gt;local($x=10)&lt;/code&gt; 과 같은 lvalue의 지역화 는 합법적이지만 실제로 local ()은 현재 효과가 없습니다. 이것은 미래의 어느 시점에서 변경 될 수 있지만 그 동안에는 그러한 코드를 사용하지 않는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="868eed42e719045825fe91387bc9673310dc7aec" translate="yes" xml:space="preserve">
          <source>(W syntax) The non-matching operator is !~, not !=~. !=~ will be interpreted as the != (numeric not equal) and ~ (1's complement) operators: probably not what you intended.</source>
          <target state="translated">(W 구문) 일치하지 않는 연산자는! = ~가 아니라! ~입니다. ! = ~는! = (숫자가 같지 않음) 및 ~ (1의 보수) 연산자로 해석됩니다. 아마도 의도 한 것과 다릅니다.</target>
        </trans-unit>
        <trans-unit id="aabd129f499f5ee7efbffa7af96de54720d08c45" translate="yes" xml:space="preserve">
          <source>(W syntax) The package variables $a and $b are used for sort comparisons. You used $a or $b in as an operand to the &lt;code&gt;&amp;lt;=&amp;gt;&lt;/code&gt; or &lt;code&gt;cmp&lt;/code&gt; operator inside a sort comparison block, and the variable had earlier been declared as a lexical variable. Either qualify the sort variable with the package name, or rename the lexical variable.</source>
          <target state="translated">(W 구문) 패키지 변수 $ a 및 $ b는 정렬 비교에 사용됩니다. 정렬 비교 블록 내 에서 &lt;code&gt;&amp;lt;=&amp;gt;&lt;/code&gt; 또는 &lt;code&gt;cmp&lt;/code&gt; 연산자 의 피연산자로 $ a 또는 $ b를 사용 했으며 변수가 사전에 어휘 변수로 선언되었습니다. 패키지 이름으로 정렬 변수를 규정하거나 어휘 변수의 이름을 바꾸십시오.</target>
        </trans-unit>
        <trans-unit id="dc7dad0ebf00491f7af4d2d3eac617947a87a3f9" translate="yes" xml:space="preserve">
          <source>(W syntax) There is a possible problem with the mixing of a control flow operator (e.g. &lt;code&gt;&lt;a href=&quot;functions/return&quot;&gt;return&lt;/a&gt;&lt;/code&gt;) and a low-precedence operator like &lt;code&gt;or&lt;/code&gt; . Consider:</source>
          <target state="translated">(W 구문) 제어 흐름 연산자 (예 : &lt;code&gt;&lt;a href=&quot;functions/return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; )와 &lt;code&gt;or&lt;/code&gt; 와 같은 우선 순위가 낮은 연산자의 혼합에 문제가있을 수 있습니다 . 치다:</target>
        </trans-unit>
        <trans-unit id="7396f53553a9ba0906dcb36747c212abf2b3b9cf" translate="yes" xml:space="preserve">
          <source>(W syntax) There is a possible problem with the mixing of a control flow operator (e.g. &lt;code&gt;return&lt;/code&gt;) and a low-precedence operator like &lt;code&gt;or&lt;/code&gt;. Consider:</source>
          <target state="translated">(W 구문) 제어 흐름 연산자 (예 : &lt;code&gt;return&lt;/code&gt; )와 &lt;code&gt;or&lt;/code&gt; 같은 낮은 우선 순위 연산자를 혼합하면 문제가 발생할 수 있습니다 . 중히 여기다:</target>
        </trans-unit>
        <trans-unit id="3163cc17558e27986562b985237677c957ba5433" translate="yes" xml:space="preserve">
          <source>(W syntax) You assigned a bareword as a signal handler name. Unfortunately, you already have a subroutine of that name declared, which means that Perl 5 will try to call the subroutine when the assignment is executed, which is probably not what you want. (If it IS what you want, put an &amp;amp; in front.)</source>
          <target state="translated">(W 구문) 신호 어 이름으로 베어 워드를 할당했습니다. 불행히도, 이미 그 이름의 서브 루틴이 선언되어 있습니다. 이는 할당이 실행될 때 Perl 5가 서브 루틴을 호출하려고 시도한다는 것을 의미합니다. (원하는 경우 &amp;amp;를 앞에 두십시오.)</target>
        </trans-unit>
        <trans-unit id="454abddd8e9efc0d1f94b63b62c5983024ef3e6a" translate="yes" xml:space="preserve">
          <source>(W syntax) You called stat() on an array, but the array will be coerced to a scalar - the number of elements in the array.</source>
          <target state="translated">(W 구문) 배열에서 stat ()를 호출했지만 배열은 스칼라 (배열의 요소 수)로 강제 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="3f6363d73db132f7df27b47f3074c7aeebcfa96a" translate="yes" xml:space="preserve">
          <source>(W syntax) You have used a pattern where Perl expected to find a string, as in the first argument to &lt;code&gt;&lt;a href=&quot;functions/join&quot;&gt;join&lt;/a&gt;&lt;/code&gt;. Perl will treat the true or false result of matching the pattern against $_ as the string, which is probably not what you had in mind.</source>
          <target state="translated">(W 구문) 첫 번째 인수 &lt;code&gt;&lt;a href=&quot;functions/join&quot;&gt;join&lt;/a&gt;&lt;/code&gt; 에서와 같이 Perl이 문자열을 찾을 것으로 예상되는 패턴을 사용했습니다 . 펄은 패턴과 $ _를 일치시키는 참 또는 거짓 결과를 문자열로 취급 할 것입니다.</target>
        </trans-unit>
        <trans-unit id="9cdfb0330dca0a5928adfee6584985a16f53364e" translate="yes" xml:space="preserve">
          <source>(W syntax) You have used a pattern where Perl expected to find a string, as in the first argument to &lt;code&gt;join&lt;/code&gt;. Perl will treat the true or false result of matching the pattern against $_ as the string, which is probably not what you had in mind.</source>
          <target state="translated">(W 구문) &lt;code&gt;join&lt;/code&gt; 에 대한 첫 번째 인수에서와 같이 Perl이 문자열을 찾을 것으로 예상하는 패턴을 사용했습니다 . Perl은 $ _에 대한 패턴 일치의 참 또는 거짓 결과를 문자열로 취급합니다. 이는 아마도 여러분이 염두에 두었던 것이 아닐 것입니다.</target>
        </trans-unit>
        <trans-unit id="9cd4a5c747e6ea0c6874c1cfe913ee77b669c12b" translate="yes" xml:space="preserve">
          <source>(W syntax) You said</source>
          <target state="translated">(W 구문) 당신은 말했다</target>
        </trans-unit>
        <trans-unit id="4d42f0406bbe7b69e8abda38fcb04298e09064a5" translate="yes" xml:space="preserve">
          <source>(W syntax) You used &lt;code&gt;$[&lt;/code&gt; in a comparison, such as:</source>
          <target state="translated">(W 구문) 다음과 같은 비교에서 &lt;code&gt;$[&lt;/code&gt; 를 사용 했습니다.</target>
        </trans-unit>
        <trans-unit id="33175e7b41467f7650bcaf1be588d001196cdd86" translate="yes" xml:space="preserve">
          <source>(W syntax) You used length() on either an array or a hash when you probably wanted a count of the items.</source>
          <target state="translated">(W 구문) 항목 수를 원할 때 배열이나 해시에서 length ()를 사용했습니다.</target>
        </trans-unit>
        <trans-unit id="72ebcd152cb072c4a9ccbb021c00555dbd6dc1ac" translate="yes" xml:space="preserve">
          <source>(W syntax) You used the old package separator, &quot;'&quot;, in a variable named inside a double-quoted string; e.g., &lt;code&gt;&quot;In $name's house&quot;&lt;/code&gt;. This is equivalent to &lt;code&gt;&quot;In $name::s house&quot;&lt;/code&gt;. If you meant the former, put a backslash before the apostrophe (&lt;code&gt;&quot;In $name\'s house&quot;&lt;/code&gt;).</source>
          <target state="translated">(W 구문) 큰 따옴표로 묶인 문자열 안에 이름이 지정된 변수에서 이전 패키지 구분 기호 &quot; '&quot;를 사용했습니다. 예 : &lt;code&gt;&quot;In $name's house&quot;&lt;/code&gt; . 이것은 &lt;code&gt;&quot;In $name::s house&quot;&lt;/code&gt; 와 동일합니다 . 전자를 의미하는 경우 아포스트로피 앞에 백 슬래시를 넣으십시오 ( &lt;code&gt;&quot;In $name\'s house&quot;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="5612f1be811be95b9ea2e71d0bc87cb76a68fc16" translate="yes" xml:space="preserve">
          <source>(W syntax) You used the push() or unshift() function with no arguments apart from the array, like &lt;code&gt;&lt;a href=&quot;functions/push&quot;&gt;push(@x)&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/unshift&quot;&gt;unshift(@foo)&lt;/a&gt;&lt;/code&gt;. That won't usually have any effect on the array, so is completely useless. It's possible in principle that push(@tied_array) could have some effect if the array is tied to a class which implements a PUSH method. If so, you can write it as &lt;code&gt;&lt;a href=&quot;functions/push&quot;&gt;push(@tied_array,())&lt;/a&gt;&lt;/code&gt; to avoid this warning.</source>
          <target state="translated">(W 구문) &lt;code&gt;&lt;a href=&quot;functions/push&quot;&gt;push(@x)&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;functions/unshift&quot;&gt;unshift(@foo)&lt;/a&gt;&lt;/code&gt; 와 같이 배열과 별도로 인수없이 push () 또는 unshift () 함수를 사용했습니다 . 그것은 일반적으로 배열에 영향을 미치지 않으므로 완전히 쓸모가 없습니다. 배열이 PUSH 메소드를 구현하는 클래스에 묶여 있으면 push (@tied_array)가 원칙적으로 영향을 줄 수 있습니다. 그렇다면 이 경고를 피하기 위해 &lt;code&gt;&lt;a href=&quot;functions/push&quot;&gt;push(@tied_array,())&lt;/a&gt;&lt;/code&gt; 로 작성할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="51fcff0092b8ab3062fd4590001862a71c12702d" translate="yes" xml:space="preserve">
          <source>(W syntax) You used the push() or unshift() function with no arguments apart from the array, like &lt;code&gt;push(@x)&lt;/code&gt; or &lt;code&gt;unshift(@foo)&lt;/code&gt;. That won't usually have any effect on the array, so is completely useless. It's possible in principle that push(@tied_array) could have some effect if the array is tied to a class which implements a PUSH method. If so, you can write it as &lt;code&gt;push(@tied_array,())&lt;/code&gt; to avoid this warning.</source>
          <target state="translated">(W 구문) &lt;code&gt;push(@x)&lt;/code&gt; 또는 &lt;code&gt;unshift(@foo)&lt;/code&gt; 와 같이 배열과 별도로 인수없이 push () 또는 unshift () 함수를 사용했습니다 . 일반적으로 어레이에 영향을 미치지 않으므로 완전히 쓸모가 없습니다. 원칙적으로 push (@tied_array) 배열이 PUSH 메서드를 구현하는 클래스에 연결되어 있으면 효과가있을 수 있습니다. 그렇다면 이 경고를 피하기 위해 &lt;code&gt;push(@tied_array,())&lt;/code&gt; 로 작성할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9d9cf6e3535b5c2226e9e739821bfc01062bb73b" translate="yes" xml:space="preserve">
          <source>(W syntax) You wrote your assignment operator backwards. The = must always come last, to avoid ambiguity with subsequent unary operators.</source>
          <target state="translated">(W 구문) 할당 연산자를 거꾸로 썼습니다. 후속 단항 연산자의 모호성을 피하려면 =는 항상 마지막에 와야합니다.</target>
        </trans-unit>
        <trans-unit id="a8c628713322c0801c78ea0810ebb090ca0b28df" translate="yes" xml:space="preserve">
          <source>(W syntax) You've run afoul of the rule that says that any list operator followed by parentheses turns into a function, with all the list operators arguments found inside the parentheses. See &lt;a href=&quot;perlop#Terms-and-List-Operators-%28Leftward%29&quot;&gt;&quot;Terms and List Operators (Leftward)&quot; in perlop&lt;/a&gt;.</source>
          <target state="translated">(W 구문) 괄호 뒤에 오는 모든 목록 연산자가 함수로 바뀌고 모든 목록 연산자 인수가 괄호 안에 있다는 규칙을 위반했습니다. &lt;a href=&quot;perlop#Terms-and-List-Operators-%28Leftward%29&quot;&gt;perlop의 &quot;용어 및 목록 연산자 (왼쪽)&quot;를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0988dc3825f261bfe7e6ca09e93a7ef79f9698f8" translate="yes" xml:space="preserve">
          <source>(W syntax) You've run afoul of the rule that says that any list operator followed by parentheses turns into a function, with all the list operators arguments found inside the parentheses. See &lt;a href=&quot;perlop#Terms-and-List-Operators-(Leftward)&quot;&gt;Terms and List Operators (Leftward) in perlop&lt;/a&gt;.</source>
          <target state="translated">(W 구문) 괄호 안에있는 모든 목록 연산자와 괄호 안에있는 모든 연산자는 괄호 안에있는 모든 목록 연산자 인수와 함께 함수로 바뀐다는 규칙에 위배됩니다. &lt;a href=&quot;perlop#Terms-and-List-Operators-(Leftward)&quot;&gt;perlop의 용어 및 목록 연산자 (왼쪽)를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="8e677e4399169ad9de0bcb39499a466a52862aad" translate="yes" xml:space="preserve">
          <source>(W syntax) You've used a hash slice (indicated by @) to select a single element of a hash. Generally it's better to ask for a scalar value (indicated by $). The difference is that &lt;code&gt;$foo{&amp;amp;bar}&lt;/code&gt; always behaves like a scalar, both when assigning to it and when evaluating its argument, while &lt;code&gt;@foo{&amp;amp;bar}&lt;/code&gt; behaves like a list when you assign to it, and provides a list context to its subscript, which can do weird things if you're expecting only one subscript.</source>
          <target state="translated">(W 구문) 해시 슬라이스 (@로 표시)를 사용하여 해시의 단일 요소를 선택했습니다. 일반적으로 스칼라 값 ($로 표시)을 요청하는 것이 좋습니다. 차이점은 &lt;code&gt;$foo{&amp;amp;bar}&lt;/code&gt; 항상 스칼라처럼 행동하며, 인수를 할당 할 때와 인수를 평가할 때 모두 &lt;code&gt;@foo{&amp;amp;bar}&lt;/code&gt; 는 그것을 할당 할 때리스트처럼 행동하고 첨자에리스트 컨텍스트를 제공한다는 것입니다 아래 첨자를 하나만 기대하면 이상한 일을 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="95b0a75562e174b2496250be14ddc21db7f4d104" translate="yes" xml:space="preserve">
          <source>(W syntax) You've used an array slice (indicated by @) to select a single element of an array. Generally it's better to ask for a scalar value (indicated by $). The difference is that &lt;code&gt;$foo[&amp;amp;bar]&lt;/code&gt; always behaves like a scalar, both when assigning to it and when evaluating its argument, while &lt;code&gt;@foo[&amp;amp;bar]&lt;/code&gt; behaves like a list when you assign to it, and provides a list context to its subscript, which can do weird things if you're expecting only one subscript.</source>
          <target state="translated">(W 구문) 배열 슬라이스 (@로 표시)를 사용하여 배열의 단일 요소를 선택했습니다. 일반적으로 스칼라 값 ($로 표시)을 요청하는 것이 좋습니다. 차이점은 &lt;code&gt;$foo[&amp;amp;bar]&lt;/code&gt; 항상 스칼라처럼 행동하며, 인수 를 지정할 때와 인수를 평가할 때 모두 &lt;code&gt;@foo[&amp;amp;bar]&lt;/code&gt; 는 그것을 할당 할 때리스트처럼 행동하고 첨자에리스트 컨텍스트를 제공한다는 것입니다 아래 첨자를 하나만 기대하면 이상한 일을 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="641f51994699613e1549f7ef209d11a26e2b585e" translate="yes" xml:space="preserve">
          <source>(W syscalls) Embedded \0 characters in pathnames or other system call arguments produce a warning as of 5.20. The parts after the \0 were formerly ignored by system calls.</source>
          <target state="translated">(W syscalls) 경로 이름 또는 기타 시스템 호출 인수에 \ 0 문자가 포함되어 있으면 5.20부터 경고가 생성됩니다. \ 0 이후의 부분은 이전에 시스템 호출로 무시되었습니다.</target>
        </trans-unit>
        <trans-unit id="eea1d51b89def0acf7f618b47547913acc879ac7" translate="yes" xml:space="preserve">
          <source>(W taint, deprecated) You have supplied &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system()&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec()&lt;/a&gt;&lt;/code&gt; with multiple arguments and at least one of them is tainted. This used to be allowed but will become a fatal error in a future version of perl. Untaint your arguments. See &lt;a href=&quot;perlsec&quot;&gt;perlsec&lt;/a&gt;.</source>
          <target state="translated">(W taint, deprecated) &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system()&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec()&lt;/a&gt;&lt;/code&gt; 에 여러 개의 인수를 제공했으며 그 중 하나 이상이 오염되었습니다. 이것은 허용되었지만 이후 버전의 펄에서는 치명적인 오류가 될 것입니다. 당신의 주장을 억제하십시오. &lt;a href=&quot;perlsec&quot;&gt;perlsec을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="191ddfc76359c017ecd49d936cabb2aba72906d2" translate="yes" xml:space="preserve">
          <source>(W taint, deprecated) You have supplied &lt;code&gt;system()&lt;/code&gt; or &lt;code&gt;exec()&lt;/code&gt; with multiple arguments and at least one of them is tainted. This used to be allowed but will become a fatal error in a future version of perl. Untaint your arguments. See &lt;a href=&quot;perlsec&quot;&gt;perlsec&lt;/a&gt;.</source>
          <target state="translated">(W taint, deprecated) 여러 인수와 함께 &lt;code&gt;system()&lt;/code&gt; 또는 &lt;code&gt;exec()&lt;/code&gt; 했으며 그중 하나 이상이 오염되었습니다. 이전에는 허용되었지만 향후 버전의 펄에서 치명적인 오류가 될 것입니다. 당신의 주장을 훼손하지 마십시오. &lt;a href=&quot;perlsec&quot;&gt;perlsec을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="87212ba40dbca26f039d3c5f4668d06844b8cebb" translate="yes" xml:space="preserve">
          <source>(W uninitialized) An undefined value was used as if it were already defined. It was interpreted as a &quot;&quot; or a 0, but maybe it was a mistake. To suppress this warning assign a defined value to your variables.</source>
          <target state="translated">(W 초기화되지 않음) 정의되지 않은 값이 이미 정의 된 것처럼 사용되었습니다. &quot;&quot;또는 0으로 해석되었지만 실수 일 수 있습니다. 이 경고를 표시하지 않으려면 정의 된 값을 변수에 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="c21109fd4c9277652f34f7607902e64df01bc950" translate="yes" xml:space="preserve">
          <source>(W unopened) An I/O operation was attempted on a filehandle that was never initialized. You need to do an open(), a sysopen(), or a socket() call, or call a constructor from the FileHandle package.</source>
          <target state="translated">(W 열리지 않음) 초기화되지 않은 파일 핸들에서 I / O 작업을 시도했습니다. open (), sysopen () 또는 socket () 호출을 수행하거나 FileHandle 패키지에서 생성자를 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="9d13ce165320d52b11e43e90a5f319b3dff07700" translate="yes" xml:space="preserve">
          <source>(W unopened) You tried binmode() on a filehandle that was never opened. Check your control flow and number of arguments.</source>
          <target state="translated">(열리지 않은) 열린 적이없는 파일 핸들에서 binmode ()를 시도했습니다. 제어 흐름과 인수 수를 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="823eb5a294fbebdb362bfa7f1c4f046786f00b26" translate="yes" xml:space="preserve">
          <source>(W unopened) You tried chdir() on a filehandle that was never opened.</source>
          <target state="translated">(W unopened) 열리지 않은 파일 핸들에서 chdir ()을 시도했습니다.</target>
        </trans-unit>
        <trans-unit id="33254325809ca0f089876420266f8d46dd3cd36e" translate="yes" xml:space="preserve">
          <source>(W unopened) You tried ioctl() on a filehandle that was never opened. Check your control flow and number of arguments.</source>
          <target state="translated">(열리지 않은) 열린 적이없는 파일 핸들에서 ioctl ()을 시도했습니다. 제어 흐름과 인수 수를 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="aecaf35d1f0c4447f15709cfdd62df13ce2bfd7b" translate="yes" xml:space="preserve">
          <source>(W unopened) You tried to close a filehandle that was never opened.</source>
          <target state="translated">(열리지 않은 상태) 열지 않은 파일 핸들을 닫으려고했습니다.</target>
        </trans-unit>
        <trans-unit id="dc1d8c0f0b969290f1a5f95acb33bce413ff9ddb" translate="yes" xml:space="preserve">
          <source>(W unopened) You tried to invoke a file test operator on a filehandle that isn't open. Check your control flow. See also &lt;a href=&quot;functions/-x&quot;&gt;-X&lt;/a&gt;.</source>
          <target state="translated">(열리지 않은 상태) 열려 있지 않은 파일 핸들에서 파일 테스트 연산자를 호출하려고했습니다. 제어 흐름을 확인하십시오. &lt;a href=&quot;functions/-x&quot;&gt;-X&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ba22d8d96230581f685bde90e640c5f1bd374866" translate="yes" xml:space="preserve">
          <source>(W unopened) You tried to invoke a file test operator on a filehandle that isn't open. Check your control flow. See also &lt;a href=&quot;perlfunc#-X&quot;&gt;&quot;-X&quot; in perlfunc&lt;/a&gt;.</source>
          <target state="translated">(W unopened) 열려 있지 않은 파일 핸들에서 파일 테스트 연산자를 호출하려고했습니다. 제어 흐름을 확인하십시오. &lt;a href=&quot;perlfunc#-X&quot;&gt;perlfunc의 &quot;-X&quot;&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="4ba59f97dfd212a4396e40fc430b085c942e206e" translate="yes" xml:space="preserve">
          <source>(W unopened) You tried to read from a filehandle that was never opened.</source>
          <target state="translated">(열리지 않은 상태) 열린 적이없는 파일 핸들에서 읽으려고했습니다.</target>
        </trans-unit>
        <trans-unit id="7ca18c8e0d35c1b1ba436b62ea346403c379a134" translate="yes" xml:space="preserve">
          <source>(W unopened) You tried to use the seek() or sysseek() function on a filehandle that was either never opened or has since been closed.</source>
          <target state="translated">(열리지 않은 상태) 열리지 않았거나 닫힌 파일 핸들에서 seek () 또는 sysseek () 함수를 사용하려고했습니다.</target>
        </trans-unit>
        <trans-unit id="a687149754f7310ab9223be0e7d36b0c518b5d3d" translate="yes" xml:space="preserve">
          <source>(W unopened) You tried to use the stat() function on a filehandle that was either never opened or has since been closed.</source>
          <target state="translated">(열리지 않은 상태) 열지 않았거나 닫힌 파일 핸들에서 stat () 함수를 사용하려고했습니다.</target>
        </trans-unit>
        <trans-unit id="7d9b36aee9bb72aee190203d53735cc95832569f" translate="yes" xml:space="preserve">
          <source>(W unopened) You tried to use the tell() function on a filehandle that was either never opened or has since been closed.</source>
          <target state="translated">(열리지 않은 상태) 열리지 않았거나 닫힌 파일 핸들에서 tell () 함수를 사용하려고했습니다.</target>
        </trans-unit>
        <trans-unit id="b0b2a4cea9ad3f14457445c6831b6e0a484b46c2" translate="yes" xml:space="preserve">
          <source>(W unpack) You have applied the same modifier more than once after a type in a pack template. See &lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;.</source>
          <target state="translated">(W 압축 풀기) 팩 템플릿에서 유형을 지정한 후 동일한 수정자를 두 번 이상 적용했습니다. &lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="941681eda2db699a18f120a6b448df46afbef468" translate="yes" xml:space="preserve">
          <source>(W unpack) You have applied the same modifier more than once after a type in a pack template. See &lt;a href=&quot;perlfunc#pack&quot;&gt;&quot;pack&quot; in perlfunc&lt;/a&gt;.</source>
          <target state="translated">(W unpack) 팩 템플릿의 유형 후에 동일한 수정자를 두 번 이상 적용했습니다. &lt;a href=&quot;perlfunc#pack&quot;&gt;perlfunc의 &quot;pack&quot;을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c76fe56910f2e01af3e35d2cf6edcb6541e9310e" translate="yes" xml:space="preserve">
          <source>(W unpack) You tried something like</source>
          <target state="translated">(W unpack) 당신은 같은 것을 시도</target>
        </trans-unit>
        <trans-unit id="f8d42c367e5bdfdeea5af0d3e04a3e7a34f2c9f5" translate="yes" xml:space="preserve">
          <source>(W untie) A copy of the object returned from &lt;code&gt;&lt;a href=&quot;functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; (or &lt;code&gt;&lt;a href=&quot;functions/tied&quot;&gt;tied&lt;/a&gt;&lt;/code&gt;) was still valid when &lt;code&gt;&lt;a href=&quot;functions/untie&quot;&gt;untie&lt;/a&gt;&lt;/code&gt; was called.</source>
          <target state="translated">(W untie) &lt;code&gt;&lt;a href=&quot;functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; (또는 &lt;code&gt;&lt;a href=&quot;functions/tied&quot;&gt;tied&lt;/a&gt;&lt;/code&gt; ) 에서 반환 된 객체의 사본은 &lt;code&gt;&lt;a href=&quot;functions/untie&quot;&gt;untie&lt;/a&gt;&lt;/code&gt; 가 호출 될 때 여전히 유효했습니다 .</target>
        </trans-unit>
        <trans-unit id="cabf61570265befbb21d34e71c8aab20c5e1624b" translate="yes" xml:space="preserve">
          <source>(W untie) A copy of the object returned from &lt;code&gt;tie&lt;/code&gt; (or &lt;code&gt;tied&lt;/code&gt;) was still valid when &lt;code&gt;untie&lt;/code&gt; was called.</source>
          <target state="translated">(W untie) &lt;code&gt;tie&lt;/code&gt; (또는 &lt;code&gt;tied&lt;/code&gt; ) 에서 반환 된 객체의 복사본은 &lt;code&gt;untie&lt;/code&gt; 가 호출 되었을 때 여전히 유효했습니다 .</target>
        </trans-unit>
        <trans-unit id="46f9020a7dcd787c1bf1b13be87c622895afbd82" translate="yes" xml:space="preserve">
          <source>(W utf8) You passed a negative number to &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr&lt;/a&gt;&lt;/code&gt;. Negative numbers are not valid character numbers, so it returns the Unicode replacement character (U+FFFD).</source>
          <target state="translated">(W utf8) &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr&lt;/a&gt;&lt;/code&gt; 에 음수를 전달했습니다 . 음수는 유효한 문자 번호가 아니므로 유니 코드 대체 문자 (U + FFFD)를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="b58756471d926c76c1ab002a4d662fb9886153dd" translate="yes" xml:space="preserve">
          <source>(W utf8) You passed a negative number to &lt;code&gt;chr&lt;/code&gt;. Negative numbers are not valid character numbers, so it returns the Unicode replacement character (U+FFFD).</source>
          <target state="translated">(W utf8) &lt;code&gt;chr&lt;/code&gt; 에 음수를 전달했습니다 . 음수는 유효한 문자 번호가 아니므로 유니 코드 대체 문자 (U + FFFD)를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="66ebf288df73553c4980b27e84deb25ec3183f3c" translate="yes" xml:space="preserve">
          <source>(W utf8) You tried to open a reference to a scalar for read or append where the scalar contained code points over 0xFF. In-memory files model on-disk files and can only contain bytes.</source>
          <target state="translated">(W utf8) 스칼라에 0xFF 이상의 코드 포인트가 포함 된 읽기 또는 추가를 위해 스칼라에 대한 참조를 열려고했습니다. 인 메모리 파일은 디스크 파일을 모델링하며 바이트 만 포함 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8848dabe5fdd98b21a0c9d16e12de50ff0059dae" translate="yes" xml:space="preserve">
          <source>(W void) A CHECK or INIT block is being defined during run time proper, when the opportunity to run them has already passed. Perhaps you are loading a file with &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt;&lt;/code&gt; when you should be using &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; instead. Or perhaps you should put the &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt;&lt;/code&gt; inside a BEGIN block.</source>
          <target state="translated">(W void) CHECK 또는 INIT 블록은 실행 기회가 이미 지나갔을 때 적절한 런타임 중에 정의됩니다. 아마도 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 를 사용해야 &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt;&lt;/code&gt; 때 &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; 또는 do 로 파일을로드하고 있을 것입니다. 또는 BEGIN 블록 안에 &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; 넣거나 &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt;&lt;/code&gt; 해야 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e7e6a78d91d6843e00f27a1dd8c24417212661c7" translate="yes" xml:space="preserve">
          <source>(W void) A CHECK or INIT block is being defined during run time proper, when the opportunity to run them has already passed. Perhaps you are loading a file with &lt;code&gt;require&lt;/code&gt; or &lt;code&gt;do&lt;/code&gt; when you should be using &lt;code&gt;use&lt;/code&gt; instead. Or perhaps you should put the &lt;code&gt;require&lt;/code&gt; or &lt;code&gt;do&lt;/code&gt; inside a BEGIN block.</source>
          <target state="translated">(W void) CHECK 또는 INIT 블록은 실행할 기회가 이미 지나간 적절한 런타임 동안 정의됩니다. 대신 &lt;code&gt;use&lt;/code&gt; 를 사용해야 &lt;code&gt;do&lt;/code&gt; 때 &lt;code&gt;require&lt;/code&gt; 또는 do 로 파일을로드 할 수 있습니다 . 또는 BEGIN 블록 안에 &lt;code&gt;require&lt;/code&gt; 또는 &lt;code&gt;do&lt;/code&gt; 를 넣어야 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="90db3f1351f4d1a7f3df67accb71dce113e606f5" translate="yes" xml:space="preserve">
          <source>(W void) You did something without a side effect in a context that does nothing with the return value, such as a statement that doesn't return a value from a block, or the left side of a scalar comma operator. Very often this points not to stupidity on your part, but a failure of Perl to parse your program the way you thought it would. For example, you'd get this if you mixed up your C precedence with Python precedence and said</source>
          <target state="translated">(W void) 블록에서 값을 리턴하지 않는 명령문 또는 스칼라 쉼표 연산자의 왼쪽과 같이 리턴 값으로 아무것도 수행하지 않는 컨텍스트에서 부작용이없는 작업을 수행했습니다. 종종 이것은 당신의 어리 석음이 아니라 Perl이 당신이 생각한 방식으로 프로그램을 파싱하지 않는 것을 지적합니다. 예를 들어 C 우선 순위를 Python 우선 순위와 혼합하여 말했다면</target>
        </trans-unit>
        <trans-unit id="8c28b024772920f2fbe93cb3859bc1a02354768f" translate="yes" xml:space="preserve">
          <source>(W void) You used sort in scalar context, as in :</source>
          <target state="translated">(W void) 다음과 같이 스칼라 컨텍스트에서 정렬을 사용했습니다.</target>
        </trans-unit>
        <trans-unit id="d2694030ac2d81eb103264e70e38e170506566bf" translate="yes" xml:space="preserve">
          <source>(W) &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; overload&lt;/code&gt; was passed an argument it did not recognize. Did you mistype an operator?</source>
          <target state="translated">(W) &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; overload&lt;/code&gt; 가 인식하지 못하는 인수를 전달했습니다. 연산자를 잘못 입력 했습니까?</target>
        </trans-unit>
        <trans-unit id="e3ba7d4dfa17e099cdb8c2d3fac3b7c6f3304239" translate="yes" xml:space="preserve">
          <source>(W) &lt;code&gt;use overload&lt;/code&gt; was passed an argument it did not recognize. Did you mistype an operator?</source>
          <target state="translated">(W) &lt;code&gt;use overload&lt;/code&gt; 이 인식되지 않은 인수를 전달했습니다. 연산자를 잘못 입력 했습니까?</target>
        </trans-unit>
        <trans-unit id="21016a542724c1bfad5e9b7a16b1394b21adc2e5" translate="yes" xml:space="preserve">
          <source>(W) Pod::PlainText encountered a &lt;code&gt;=back&lt;/code&gt; command that didn't correspond to an &lt;code&gt;=over&lt;/code&gt; command.</source>
          <target state="translated">(W) Pod :: PlainText가 &lt;code&gt;=over&lt;/code&gt; 명령에 해당하지 않는 &lt;code&gt;=back&lt;/code&gt; 명령을 발견했습니다 .</target>
        </trans-unit>
        <trans-unit id="26bfb80fa009b521734a344e5a06b87f176f5beb" translate="yes" xml:space="preserve">
          <source>(W) Something has gone wrong in internal &lt;code&gt;=item&lt;/code&gt; processing. These messages indicate a bug in Pod::Text; you should never see them.</source>
          <target state="translated">(W) 내부 &lt;code&gt;=item&lt;/code&gt; 처리에 문제가 있습니다. 이 메시지는 Pod :: Text의 버그를 나타냅니다. 당신은 그들을 보지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="501975fffba0edbf57d1160976c85133c54a7baf" translate="yes" xml:space="preserve">
          <source>(W) Something has gone wrong in internal &lt;code&gt;=item&lt;/code&gt; processing. This message indicates a bug in Pod::PlainText; you should never see it.</source>
          <target state="translated">(W) 내부 &lt;code&gt;=item&lt;/code&gt; 처리에 문제가 있습니다. 이 메시지는 Pod :: PlainText의 버그를 나타냅니다. 당신은 그것을 보지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="c30dd949e9f2b3a1878daa9c110c45e03e38a3c9" translate="yes" xml:space="preserve">
          <source>(W) The POD source contained a non-standard internal sequence (something of the form &lt;code&gt;X&amp;lt;&amp;gt;&lt;/code&gt; ) that Pod::PlainText didn't know about.</source>
          <target state="translated">(W) POD 소스 에 Pod :: PlainText가 알지 못하는 비표준 내부 시퀀스 ( &lt;code&gt;X&amp;lt;&amp;gt;&lt;/code&gt; 형식 )가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="ea328e676adcf58b0759f1c04dd7eec880ac50e0" translate="yes" xml:space="preserve">
          <source>(W) The POD source contained an &lt;code&gt;E&amp;lt;&amp;gt;&lt;/code&gt; escape that Pod::PlainText didn't know about.</source>
          <target state="translated">(W) POD 소스 에 Pod :: PlainText가 알지 못한 &lt;code&gt;E&amp;lt;&amp;gt;&lt;/code&gt; 이스케이프가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="0a887755cdd505b29af6782ffbf2c58e91dc679f" translate="yes" xml:space="preserve">
          <source>(W) The call to overload::constant contained an odd number of arguments. The arguments should come in pairs.</source>
          <target state="translated">(W) overload :: constant 호출에 홀수 개의 인수가 포함되었습니다. 인수는 쌍을 이루어야합니다.</target>
        </trans-unit>
        <trans-unit id="70cde34602e73ad7fd4f730db8c2bcf41f111987" translate="yes" xml:space="preserve">
          <source>(W) The given character is not a valid pack or unpack type but used to be silently ignored.</source>
          <target state="translated">(W) 지정된 캐릭터가 유효한 팩 또는 언팩 타입은 아니지만 자동 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="e14f1e6bfcb9badd4f5af39b1f5de336049edc31" translate="yes" xml:space="preserve">
          <source>(W) The same, but in ANSI_COLORS_ALIASES. The color mapping was ignored.</source>
          <target state="translated">(W) 동일하지만 ANSI_COLORS_ALIASES. 색상 매핑이 무시되었습니다.</target>
        </trans-unit>
        <trans-unit id="d96a0ecd53e817b1ae2d676c0119d14bcfa595eb" translate="yes" xml:space="preserve">
          <source>(W) The second (fourth, sixth, ...) argument of overload::constant needs to be a code reference. Either an anonymous subroutine, or a reference to a subroutine.</source>
          <target state="translated">(W) overload :: constant의 두 번째 (4 번째, 6 번째, ...) 인수는 코드 참조 여야합니다. 익명 서브 루틴 또는 서브 루틴에 대한 참조입니다.</target>
        </trans-unit>
        <trans-unit id="5eb1c96d7547fa58d3105399dbdfb8e95f920587" translate="yes" xml:space="preserve">
          <source>(W) The specified color mapping from ANSI_COLORS_ALIASES is not valid and could not be parsed. It was ignored.</source>
          <target state="translated">(W) ANSI_COLORS_ALIASES에서 지정된 색상 매핑이 유효하지 않아 파싱 할 수 없습니다. 무시되었습니다.</target>
        </trans-unit>
        <trans-unit id="67419e06ec8f127222c04b5682b2736a4e491752" translate="yes" xml:space="preserve">
          <source>(W) This is a standard message issued by OS/2 applications, while *nix applications die in silence. It is considered a feature of the OS/2 port. One can easily disable this by appropriate sighandlers, see &lt;a href=&quot;perlipc#Signals&quot;&gt;&quot;Signals&quot; in perlipc&lt;/a&gt;. See also &quot;Process terminated by SIGTERM/SIGINT&quot; in &lt;a href=&quot;perlos2&quot;&gt;perlos2&lt;/a&gt;.</source>
          <target state="translated">(W) 이것은 OS / 2 응용 프로그램에서 발행하는 표준 메시지이지만 * nix 응용 프로그램은 조용히 죽습니다. OS / 2 포트의 기능으로 간주됩니다. 적절한 sighandler를 사용하여 쉽게 비활성화 할 수 있습니다 . &lt;a href=&quot;perlipc#Signals&quot;&gt;perlipc의 &quot;Signals&quot;를&lt;/a&gt; 참조하십시오 . &lt;a href=&quot;perlos2&quot;&gt;perlos2의&lt;/a&gt; &quot;SIGTERM / SIGINT에 의해 종료 된 프로세스&quot;도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="8acaee73233dd30d36c968a81b33d5c8ccba7c36" translate="yes" xml:space="preserve">
          <source>(W) This is a standard message issued by OS/2 applications, while *nix applications die in silence. It is considered a feature of the OS/2 port. One can easily disable this by appropriate sighandlers, see &lt;a href=&quot;perlipc#Signals&quot;&gt;Signals in perlipc&lt;/a&gt;. See also &quot;Process terminated by SIGTERM/SIGINT&quot; in &lt;a href=&quot;perlos2&quot;&gt;perlos2&lt;/a&gt;.</source>
          <target state="translated">(W) 이것은 OS / 2 어플리케이션이 발행 한 표준 메시지이며 * nix 어플리케이션은 침묵합니다. OS / 2 포트의 기능으로 간주됩니다. 적절한 sighandler에 의해이를 쉽게 비활성화 할 수 있습니다 (perlipc의 &lt;a href=&quot;perlipc#Signals&quot;&gt;신호&lt;/a&gt; 참조) . &lt;a href=&quot;perlos2&quot;&gt;perlos2의&lt;/a&gt; &quot;SIGTERM / SIGINT에 의해 종료 된 프로세스&quot;도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="1c10232da8d5a7a1db96c9e95d4de6579ffb3dcc" translate="yes" xml:space="preserve">
          <source>(W) This warning may be due to running a perl5 script through a perl4 interpreter, especially if the word that is being warned about is &quot;use&quot; or &quot;my&quot;.</source>
          <target state="translated">(W)이 경고는 perl4 인터프리터를 통해 perl5 스크립트를 실행했을 때, 특히 경고중인 단어가 &quot;사용&quot;또는 &quot;my&quot;인 경우에 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1212f80ef134690b670704c90585c6d0920a4a27" translate="yes" xml:space="preserve">
          <source>(W) You did &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re;&lt;/code&gt; without any arguments. That isn't very useful.</source>
          <target state="translated">(W) 당신은 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re;&lt;/code&gt; &lt;a href=&quot;functions/use&quot;&gt;사용했습니다&lt;/a&gt; . 논쟁없이 그다지 유용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="bab248385c5c2b1c84a111f5b896dc72b0354a3f" translate="yes" xml:space="preserve">
          <source>(W) You did &lt;code&gt;use re;&lt;/code&gt; without any arguments. That isn't very useful.</source>
          <target state="translated">(W) 당신은 &lt;code&gt;use re;&lt;/code&gt; 인수없이. 그다지 유용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e38b2fa8496c1774dd31b2c5fdb79143f6d43dd2" translate="yes" xml:space="preserve">
          <source>(W) You passed warn() an empty string (the equivalent of &lt;code&gt;&lt;a href=&quot;functions/warn&quot;&gt;warn&lt;/a&gt; &quot;&quot;&lt;/code&gt; ) or you called it with no args and &lt;code&gt;$@&lt;/code&gt; was empty.</source>
          <target state="translated">(W) warn ()을 빈 문자열 ( &lt;code&gt;&lt;a href=&quot;functions/warn&quot;&gt;warn&lt;/a&gt; &quot;&quot;&lt;/code&gt; 과 동일 )에 전달했거나 인수없이 호출했으며 &lt;code&gt;$@&lt;/code&gt; 가 비어있었습니다.</target>
        </trans-unit>
        <trans-unit id="6cf26d05866ab1c95908d2f20ddf8e96062948be" translate="yes" xml:space="preserve">
          <source>(W) You passed warn() an empty string (the equivalent of &lt;code&gt;warn &quot;&quot;&lt;/code&gt;) or you called it with no args and &lt;code&gt;$@&lt;/code&gt; was empty.</source>
          <target state="translated">(W) warn ()에 빈 문자열 ( &lt;code&gt;warn &quot;&quot;&lt;/code&gt; 에 해당 )을 전달했거나 인수없이 호출했으며 &lt;code&gt;$@&lt;/code&gt; 가 비어 있습니다.</target>
        </trans-unit>
        <trans-unit id="fc9c0aa78325e04e4fc87ad0e353fe824600632f" translate="yes" xml:space="preserve">
          <source>(W) You probably mistyped a constant color name such as:</source>
          <target state="translated">(W) 다음과 같은 일정한 색상 이름을 잘못 입력했을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0ad31e97078c78dbc2769be19839fd69cffdfd38" translate="yes" xml:space="preserve">
          <source>(W) You probably said %hash{$key} when you meant $hash{$key} or @hash{@keys}. On the other hand, maybe you just meant %hash and got carried away.</source>
          <target state="translated">(W) 아마도 $ hash {$ key} 또는 @hash {@keys}를 의미 할 때 % hash {$ key}라고 말했을 것입니다. 반면에, 아마도 당신은 % hash를 의미하고 쫓겨 났을 것입니다.</target>
        </trans-unit>
        <trans-unit id="3978bcd1515ac8ee88075eadc0c3770c9967d932" translate="yes" xml:space="preserve">
          <source>(W) You specified an invalid alias name on the left hand of the equal sign in a color mapping in ANSI_COLORS_ALIASES. The color mapping was ignored.</source>
          <target state="translated">(W) ANSI_COLORS_ALIASES의 색상 매핑에서 등호 왼쪽에 잘못된 별칭 이름을 지정했습니다. 색상 매핑이 무시되었습니다.</target>
        </trans-unit>
        <trans-unit id="1568d1a0f3b426e26a4ff1c09af9fd2ef4f0d8e9" translate="yes" xml:space="preserve">
          <source>(W) You specified an invalid attribute name on the right hand of the equal sign in a color mapping in ANSI_COLORS_ALIASES. The color mapping was ignored.</source>
          <target state="translated">(W) ANSI_COLORS_ALIASES의 색상 매핑에서 등호 오른쪽에 잘못된 속성 이름을 지정했습니다. 색상 매핑이 무시되었습니다.</target>
        </trans-unit>
        <trans-unit id="66c0aa947d58238ebc42c6ae5df6940103cf64ea" translate="yes" xml:space="preserve">
          <source>(W) You tried to overload a constant type the overload package is unaware of.</source>
          <target state="translated">(W) 과부하 패키지가 인식하지 못하는 상수 유형을 과부하하려고했습니다.</target>
        </trans-unit>
        <trans-unit id="e6c02830c69ec718530355cc9c731ec126bc1ac4" translate="yes" xml:space="preserve">
          <source>(W) You tried to use an unknown subpragma of the &quot;re&quot; pragma.</source>
          <target state="translated">(W) &quot;re&quot;pragma의 알 수없는 서브 프라그 마를 사용하려고했습니다.</target>
        </trans-unit>
        <trans-unit id="237221ab401f92d00b4b13fe24041204327569ad" translate="yes" xml:space="preserve">
          <source>(We use $^X in these examples because it's tainted by default.)</source>
          <target state="translated">(이 예제에서는 기본적으로 오염되어 있기 때문에 $ ^ X를 사용합니다.)</target>
        </trans-unit>
        <trans-unit id="ff0ae87e96bc4227f275a775529e881f38d9f545" translate="yes" xml:space="preserve">
          <source>(We used our knowledge that input conversion for &lt;code&gt;char *&lt;/code&gt; is a &quot;simple&quot; one, thus &lt;code&gt;host&lt;/code&gt; is initialized on the declaration line, and our assignment &lt;code&gt;h = host&lt;/code&gt; is not performed too early. Otherwise one would need to have the assignment &lt;code&gt;h = host&lt;/code&gt; in a CODE: or INIT: section.)</source>
          <target state="translated">(우리는 &lt;code&gt;char *&lt;/code&gt; 에 대한 입력 변환 이 &quot;간단한&quot;것으로 알고 있었 으므로 선언 행에서 &lt;code&gt;host&lt;/code&gt; 가 초기화되고 할당 &lt;code&gt;h = host&lt;/code&gt; 가 너무 일찍 수행되지 않습니다. 그렇지 않으면 할당 &lt;code&gt;h = host&lt;/code&gt; 가 필요 합니다 CODE : 또는 INIT : 섹션에 있습니다.)</target>
        </trans-unit>
        <trans-unit id="cfc6665de88f1833c4368f0118d03017f3a21353" translate="yes" xml:space="preserve">
          <source>(When dealing with floating-point comparisons, it is best to not check for equality, but rather that the difference between the expected and actual result is below a certain amount (called epsilon) which is 0.01 in this case)</source>
          <target state="translated">(부동 소수점 비교를 처리 할 때는 동등성을 확인하는 것이 가장 좋지만 예상 결과와 실제 결과의 차이가이 경우 0.01 인 엡실론이라고하는 특정 양 미만인 경우)</target>
        </trans-unit>
        <trans-unit id="ccac8451a2611ae759c9faf841bb5018f12b19d2" translate="yes" xml:space="preserve">
          <source>(Where BASEEXT is the last component of NAME, and OBJ_EXT is $Config{obj_ext}.)</source>
          <target state="translated">(BASEEXT는 NAME의 마지막 구성 요소이고 OBJ_EXT는 $ Config {obj_ext}입니다.)</target>
        </trans-unit>
        <trans-unit id="e02fb51bf8e3169540ecbf91f4d22e75cb7830a9" translate="yes" xml:space="preserve">
          <source>(Where BASEEXT is the last component of NAME.)</source>
          <target state="translated">(BASEEXT는 NAME의 마지막 구성 요소입니다.)</target>
        </trans-unit>
        <trans-unit id="d0de3cd68244c0838e032c884108802a5c0e7328" translate="yes" xml:space="preserve">
          <source>(Why do we have separate numeric and string comparisons? Because we don't have special variable types, and Perl needs to know whether to sort numerically (where 99 is less than 100) or alphabetically (where 100 comes before 99).</source>
          <target state="translated">(왜 우리는 별도의 숫자와 문자열 비교를해야합니까? 특수 변수 유형이 없기 때문에 Perl은 숫자 (99는 100보다 작은 경우) 또는 알파벳순 (100은 99보다 먼저 나오는 경우)을 알아야합니다.</target>
        </trans-unit>
        <trans-unit id="3a6da2b40f741b24ff596bed490732d33b00b6c1" translate="yes" xml:space="preserve">
          <source>(Win32) &quot;Cumulative&quot; times will be bogus. On anything other than Windows NT or Windows 2000, &quot;system&quot; time will be bogus, and &quot;user&quot; time is actually the time returned by the &lt;a href=&quot;http://man.he.net/man3/clock&quot;&gt;&lt;code&gt;clock()&lt;/code&gt;&lt;/a&gt; function in the C runtime library.</source>
          <target state="translated">(Win32) &quot;누적&quot;시간은 가짜입니다. Windows NT 또는 Windows 2000 이외의 경우 &quot;시스템&quot;시간은 가짜이며 &quot;사용자&quot;시간은 실제로 C 런타임 라이브러리 의 &lt;a href=&quot;http://man.he.net/man3/clock&quot;&gt; &lt;code&gt;clock()&lt;/code&gt; &lt;/a&gt; 함수에 의해 반환 된 시간 입니다.</target>
        </trans-unit>
        <trans-unit id="097ad5cbfe30f98022f46bfa2c48151ad2231444" translate="yes" xml:space="preserve">
          <source>(Win32) &lt;code&gt;-w&lt;/code&gt; only inspects the read-only file attribute (FILE_ATTRIBUTE_READONLY), which determines whether the directory can be deleted, not whether it can be written to. Directories always have read and write access unless denied by discretionary access control lists (DACLs).</source>
          <target state="translated">(Win32) &lt;code&gt;-w&lt;/code&gt; 는 읽기 전용 파일 속성 (FILE_ATTRIBUTE_READONLY) 만 검사합니다.이 속성은 디렉토리를 쓸 수 있는지 여부가 아니라 삭제할 수 있는지 여부를 결정합니다. DACL (임의 액세스 제어 목록)에서 거부하지 않는 한 디렉터리에는 항상 읽기 및 쓰기 액세스 권한이 있습니다.</target>
        </trans-unit>
        <trans-unit id="38cfa236d5999b07d8ee8339e8e2095171f45420" translate="yes" xml:space="preserve">
          <source>(Win32) &lt;code&gt;-x&lt;/code&gt; (or &lt;code&gt;-X&lt;/code&gt;) determine if a file ends in one of the executable suffixes. &lt;code&gt;-S&lt;/code&gt; is meaningless.</source>
          <target state="translated">(Win32) &lt;code&gt;-x&lt;/code&gt; (또는 &lt;code&gt;-X&lt;/code&gt; )는 파일이 실행 가능한 접미사 중 하나로 끝나는 지 확인합니다. &lt;code&gt;-S&lt;/code&gt; 는 무의미합니다.</target>
        </trans-unit>
        <trans-unit id="771d0069e508ec0eab7ae06b50a9126c57ebe81c" translate="yes" xml:space="preserve">
          <source>(Win32) &lt;code&gt;ctime&lt;/code&gt; is creation time instead of inode change time.</source>
          <target state="translated">(Win32) &lt;code&gt;ctime&lt;/code&gt; 은 inode 변경 시간 대신 생성 시간입니다.</target>
        </trans-unit>
        <trans-unit id="b759a9e27db37889e0259223e9b60d084acd51ec" translate="yes" xml:space="preserve">
          <source>(Win32) &lt;code&gt;dev&lt;/code&gt; and &lt;code&gt;ino&lt;/code&gt; are not meaningful.</source>
          <target state="translated">(Win32) &lt;code&gt;dev&lt;/code&gt; 및 &lt;code&gt;ino&lt;/code&gt; 는 의미가 없습니다.</target>
        </trans-unit>
        <trans-unit id="2a41b264a8847cf148e7f8f4528305955ad6d9f6" translate="yes" xml:space="preserve">
          <source>(Win32) &lt;code&gt;exec LIST&lt;/code&gt; without the use of indirect object syntax (&lt;code&gt;exec PROGRAM LIST&lt;/code&gt;) may fall back to trying the shell if the first &lt;code&gt;spawn()&lt;/code&gt; fails.</source>
          <target state="translated">(Win32) 간접 객체 구문을 사용하지 않는 &lt;code&gt;exec LIST&lt;/code&gt; ( &lt;code&gt;exec PROGRAM LIST&lt;/code&gt; )는 첫 번째 &lt;code&gt;spawn()&lt;/code&gt; 이 실패하면 셸을 시도하는 것으로 돌아갈 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="74bfa92e6c9b18362250b8ea3c63446b17f3e77c" translate="yes" xml:space="preserve">
          <source>(Win32) &lt;code&gt;kill(-9, $pid)&lt;/code&gt; will terminate the process specified by &lt;code&gt;$pid&lt;/code&gt; and recursively all child processes owned by it. This is different from the Unix semantics, where the signal will be delivered to all processes in the same process group as the process specified by &lt;code&gt;$pid&lt;/code&gt;.</source>
          <target state="translated">(Win32에서) &lt;code&gt;kill(-9, $pid)&lt;/code&gt; 로 지정된 프로세스를 종료합니다 &lt;code&gt;$pid&lt;/code&gt; 과 소유 재귀 적으로 모든 자식 프로세스를. 이것은 &lt;code&gt;$pid&lt;/code&gt; 지정된 프로세스와 동일한 프로세스 그룹의 모든 프로세스에 신호가 전달되는 Unix 의미 체계와 다릅니다 .</target>
        </trans-unit>
        <trans-unit id="3d9d02cc3296d6faebca2f9cb1b054bfc96b88c1" translate="yes" xml:space="preserve">
          <source>(Win32) &lt;code&gt;kill&lt;/code&gt; doesn't send a signal to the identified process like it does on Unix platforms. Instead &lt;code&gt;kill($sig, $pid)&lt;/code&gt; terminates the process identified by &lt;code&gt;$pid&lt;/code&gt;, and makes it exit immediately with exit status &lt;code&gt;$sig&lt;/code&gt;. As in Unix, if &lt;code&gt;$sig&lt;/code&gt; is 0 and the specified process exists, it returns true without actually terminating it.</source>
          <target state="translated">(Win32) &lt;code&gt;kill&lt;/code&gt; 은 Unix 플랫폼 에서처럼 식별 된 프로세스에 신호를 보내지 않습니다. 대신 &lt;code&gt;kill($sig, $pid)&lt;/code&gt; 는 &lt;code&gt;$pid&lt;/code&gt; 식별 된 프로세스 를 종료하고 종료 상태 &lt;code&gt;$sig&lt;/code&gt; 즉시 종료합니다 . Unix에서와 같이 &lt;code&gt;$sig&lt;/code&gt; 가 0이고 지정된 프로세스가 존재하면 실제로 종료하지 않고 true를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="76ba6e77c5869f927a0b71b2084ab1e64131af44" translate="yes" xml:space="preserve">
          <source>(Win32) &lt;code&gt;stat&lt;/code&gt; needs to open the file to determine the link count and update attributes that may have been changed through hard links. Setting &lt;a href=&quot;perlvar#%24%7B%5EWIN32_SLOPPY_STAT%7D&quot;&gt;&lt;code&gt;${^WIN32_SLOPPY_STAT}&lt;/code&gt;&lt;/a&gt; to a true value speeds up &lt;code&gt;stat&lt;/code&gt; by not performing this operation.</source>
          <target state="translated">(Win32) &lt;code&gt;stat&lt;/code&gt; 는 하드 링크를 통해 변경되었을 수있는 링크 수 및 업데이트 속성을 확인하기 위해 파일을 열어야합니다. &lt;a href=&quot;perlvar#%24%7B%5EWIN32_SLOPPY_STAT%7D&quot;&gt; &lt;code&gt;${^WIN32_SLOPPY_STAT}&lt;/code&gt; &lt;/a&gt; 를 true 값으로 설정하면 이 작업을 수행하지 않아 &lt;code&gt;stat&lt;/code&gt; 속도가 빨라집니다 .</target>
        </trans-unit>
        <trans-unit id="f9c2f95171f0df8ebdc995f9b736f8dcecb859ca" translate="yes" xml:space="preserve">
          <source>(Win32) &lt;code&gt;system LIST&lt;/code&gt; without the use of indirect object syntax (&lt;code&gt;system PROGRAM LIST&lt;/code&gt;) may fall back to trying the shell if the first &lt;code&gt;spawn()&lt;/code&gt; fails.</source>
          <target state="translated">(Win32) 간접 객체 구문을 사용하지 않는 &lt;code&gt;system LIST&lt;/code&gt; ( &lt;code&gt;system PROGRAM LIST&lt;/code&gt; )는 첫 번째 &lt;code&gt;spawn()&lt;/code&gt; 이 실패하면 셸을 시도하는 것으로 돌아갈 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="46d657187b6095caf9acb668a4893912e19e2208" translate="yes" xml:space="preserve">
          <source>(Win32) As an optimization, may not call the command shell specified in &lt;code&gt;$ENV{PERL5SHELL}&lt;/code&gt;. &lt;code&gt;system(1, @args)&lt;/code&gt; spawns an external process and immediately returns its process designator, without waiting for it to terminate. Return value may be used subsequently in &lt;a href=&quot;perlfunc#wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;perlfunc#waitpid-PID%2CFLAGS&quot;&gt;&lt;code&gt;waitpid&lt;/code&gt;&lt;/a&gt;. Failure to &lt;code&gt;spawn()&lt;/code&gt; a subprocess is indicated by setting &lt;a href=&quot;perlvar#%24%3F&quot;&gt;&lt;code&gt;$?&lt;/code&gt;&lt;/a&gt; to &lt;code&gt;255 &amp;lt;&amp;lt; 8&lt;/code&gt;. &lt;a href=&quot;perlvar#%24%3F&quot;&gt;&lt;code&gt;$?&lt;/code&gt;&lt;/a&gt; is set in a way compatible with Unix (i.e. the exit status of the subprocess is obtained by &lt;code&gt;$? &amp;gt;&amp;gt; 8&lt;/code&gt;, as described in the documentation).</source>
          <target state="translated">(Win32) 최적화로 &lt;code&gt;$ENV{PERL5SHELL}&lt;/code&gt; 지정된 명령 셸을 호출 할 수 없습니다 . &lt;code&gt;system(1, @args)&lt;/code&gt; 는 외부 프로세스를 생성하고 종료 될 때까지 기다리지 않고 즉시 프로세스 지정자를 반환합니다. 반환 값은 나중에 &lt;a href=&quot;perlfunc#wait&quot;&gt; &lt;code&gt;wait&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;perlfunc#waitpid-PID%2CFLAGS&quot;&gt; &lt;code&gt;waitpid&lt;/code&gt; &lt;/a&gt; 에서 사용할 수 있습니다 . 하위 프로세스 를 &lt;code&gt;spawn()&lt;/code&gt; 하는 데 실패하면 &lt;a href=&quot;perlvar#%24%3F&quot;&gt; &lt;code&gt;$?&lt;/code&gt; &lt;/a&gt;~ &lt;code&gt;255 &amp;lt;&amp;lt; 8&lt;/code&gt; . &lt;a href=&quot;perlvar#%24%3F&quot;&gt; &lt;code&gt;$?&lt;/code&gt; &lt;/a&gt;Unix와 호환되는 방식으로 설정됩니다 (즉 , 문서에 설명 된대로 하위 프로세스의 종료 상태는 &lt;code&gt;$? &amp;gt;&amp;gt; 8&lt;/code&gt; 얻음 ).</target>
        </trans-unit>
        <trans-unit id="2d623d1233c724bd1bf2d63c98124d2d35b94baa" translate="yes" xml:space="preserve">
          <source>(Win32) Available only for socket handles, and it does what the &lt;code&gt;ioctlsocket()&lt;/code&gt; call in the Winsock API does.</source>
          <target state="translated">(Win32) 소켓 핸들에만 사용할 수 있으며 Winsock API 의 &lt;code&gt;ioctlsocket()&lt;/code&gt; 호출이 수행하는 작업을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="bcff95b0b7ef4ddb8bf2e1aa93b589744a1f75e8" translate="yes" xml:space="preserve">
          <source>(Win32) Both of modes &lt;code&gt;|-&lt;/code&gt; and &lt;code&gt;-|&lt;/code&gt; are supported, but the list form is emulated since the Win32 API CreateProcess() accepts a simple string rather than an array of arguments. This may have security implications for your code.</source>
          <target state="translated">(Win32) 두 모드 모두 &lt;code&gt;|-&lt;/code&gt; 및 &lt;code&gt;-|&lt;/code&gt; 지원되지만 목록 형식은 Win32 API CreateProcess ()가 인수 배열이 아닌 간단한 문자열을 받아들이 기 때문에 에뮬레이션됩니다. 이것은 코드에 보안에 영향을 미칠 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9127ce15715004e5a5ed49a359264e052b40471a" translate="yes" xml:space="preserve">
          <source>(Win32) Can only be applied to process handles returned for processes spawned using &lt;code&gt;system(1, ...)&lt;/code&gt; or pseudo processes created with &lt;a href=&quot;perlfunc#fork&quot;&gt;&lt;code&gt;fork&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">(Win32) &lt;code&gt;system(1, ...)&lt;/code&gt; 또는 &lt;a href=&quot;perlfunc#fork&quot;&gt; &lt;code&gt;fork&lt;/code&gt; 로&lt;/a&gt; 생성 된 의사 프로세스를 사용하여 생성 된 프로세스에 대해 반환 된 프로세스 핸들에만 적용 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c8c7df891da3c5c606570ac870f377b32bccbb11" translate="yes" xml:space="preserve">
          <source>(Win32) Can't move directories between directories on different logical volumes.</source>
          <target state="translated">(Win32) 다른 논리 볼륨의 디렉터리간에 디렉터리를 이동할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="3f68950a944d856111c53bd76569330f59fdf556" translate="yes" xml:space="preserve">
          <source>(Win32) Does nothing, but won't fail.</source>
          <target state="translated">(Win32) 아무것도하지 않지만 실패하지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="7d52852a018af43b37937d531a878cd72956bc98" translate="yes" xml:space="preserve">
          <source>(Win32) Emulated using multiple interpreters. See &lt;a href=&quot;perlfork&quot;&gt;perlfork&lt;/a&gt;.</source>
          <target state="translated">(Win32) 여러 인터프리터를 사용하여 에뮬레이션됩니다. &lt;a href=&quot;perlfork&quot;&gt;perlfork를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="78115fe4dbca01a2cabfa77657b3596f65944163" translate="yes" xml:space="preserve">
          <source>(Win32) Emulated using synchronization functions such that it can be interrupted by &lt;a href=&quot;perlfunc#alarm-SECONDS&quot;&gt;&lt;code&gt;alarm&lt;/code&gt;&lt;/a&gt;, and limited to a maximum of 4294967 seconds, approximately 49 days.</source>
          <target state="translated">(Win32) &lt;a href=&quot;perlfunc#alarm-SECONDS&quot;&gt; &lt;code&gt;alarm&lt;/code&gt; &lt;/a&gt; 에 의해 중단 될 수 있도록 동기화 기능을 사용하여 에뮬레이션 되며 최대 4294967 초 (약 49 일)로 제한됩니다.</target>
        </trans-unit>
        <trans-unit id="6a5de5b856bdbc9d8a7a764aa2b3d89407731dce" translate="yes" xml:space="preserve">
          <source>(Win32) Emulated using timers that must be explicitly polled whenever Perl wants to dispatch &quot;safe signals&quot; and therefore cannot interrupt blocking system calls.</source>
          <target state="translated">(Win32) Perl이 &quot;안전 신호&quot;를 발송하려고 할 때마다 명시 적으로 폴링되어야하는 타이머를 사용하여 에뮬레이션되므로 차단 시스템 호출을 중단 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="cd80c6a536ded8bc2bf634f559b6bb1e2d3cec7c" translate="yes" xml:space="preserve">
          <source>(Win32) Hard links are implemented on Win32 under NTFS only. They are natively supported on Windows 2000 and later. On Windows NT they are implemented using the Windows POSIX subsystem support and the Perl process will need Administrator or Backup Operator privileges to create hard links.</source>
          <target state="translated">(Win32) 하드 링크는 NTFS에서만 Win32에서 구현됩니다. Windows 2000 이상에서 기본적으로 지원됩니다. Windows NT에서는 Windows POSIX 하위 시스템 지원을 사용하여 구현되며 Perl 프로세스는 하드 링크를 작성하기 위해 관리자 또는 백업 운영자 권한이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="3f1536b4c91f9320914f7df021f72a5346121abb" translate="yes" xml:space="preserve">
          <source>(Win32) If a FILEHANDLE is supplied, it must be writable and opened in append mode (i.e., use &lt;code&gt;open(my $fh, '&amp;gt;&amp;gt;', 'filename')&lt;/code&gt; or &lt;code&gt;sysopen(my $fh, ..., O_APPEND|O_RDWR)&lt;/code&gt;. If a filename is supplied, it should not be held open elsewhere.</source>
          <target state="translated">(Win32) FILEHANDLE이 제공되면 쓰기 가능해야하며 추가 모드에서 열어야합니다 (예 : &lt;code&gt;open(my $fh, '&amp;gt;&amp;gt;', 'filename')&lt;/code&gt; 또는 &lt;code&gt;sysopen(my $fh, ..., O_APPEND|O_RDWR)&lt;/code&gt; . 파일 이름이 제공되면 다른 곳에서 열어두면 안됩니다.</target>
        </trans-unit>
        <trans-unit id="39ac5f2850e738f851fce5c98cbf343f48b27b1c" translate="yes" xml:space="preserve">
          <source>(Win32) May not be available if library or source was not provided when building perl.</source>
          <target state="translated">(Win32) Perl 빌드시 라이브러리 또는 소스가 제공되지 않은 경우 사용하지 못할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2e4ce071f37a1af0083caf8a1a4fc21f92cdd025" translate="yes" xml:space="preserve">
          <source>(Win32) May not behave as expected. Behavior depends on the C runtime library's implementation of &lt;a href=&quot;http://man.he.net/man2/utime&quot;&gt;&lt;code&gt;utime()&lt;/code&gt;&lt;/a&gt;, and the filesystem being used. The FAT filesystem typically does not support an &quot;access time&quot; field, and it may limit timestamps to a granularity of two seconds.</source>
          <target state="translated">(Win32) 예상대로 작동하지 않을 수 있습니다. 동작은 C 런타임 라이브러리의 &lt;a href=&quot;http://man.he.net/man2/utime&quot;&gt; &lt;code&gt;utime()&lt;/code&gt; &lt;/a&gt; 구현 및 사용중인 파일 시스템에 따라 다릅니다 . FAT 파일 시스템은 일반적으로 &quot;액세스 시간&quot;필드를 지원하지 않으며 타임 스탬프를 2 초 단위로 제한 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="02b290a3466c2e14903396fe950e3c324ee0f9a2" translate="yes" xml:space="preserve">
          <source>(Win32) Not implemented.</source>
          <target state="translated">(Win32) 구현되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="15f1a44d6820ce91c7ed96f321a002a5e99a43bd" translate="yes" xml:space="preserve">
          <source>(Win32) Only good for changing &quot;owner&quot; read-write access; &quot;group&quot; and &quot;other&quot; bits are meaningless.</source>
          <target state="translated">(Win32) &quot;소유자&quot;읽기-쓰기 액세스 변경에만 유용합니다. &quot;그룹&quot;및 &quot;기타&quot;비트는 의미가 없습니다.</target>
        </trans-unit>
        <trans-unit id="29bf0832c122b51a368d18dbf4e03bb118291cc9" translate="yes" xml:space="preserve">
          <source>(Win32) Return values (especially for device and inode) may be bogus.</source>
          <target state="translated">(Win32) 반환 값 (특히 장치 및 inode의 경우)은 가짜 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6c918676cbe34b19ea0d3f7ba488c5cad5cac2ec" translate="yes" xml:space="preserve">
          <source>(Win32) The value returned by &lt;a href=&quot;perlfunc#tell-FILEHANDLE&quot;&gt;&lt;code&gt;tell&lt;/code&gt;&lt;/a&gt; may be affected after the call, and the filehandle may be flushed.</source>
          <target state="translated">(Win32) &lt;a href=&quot;perlfunc#tell-FILEHANDLE&quot;&gt; &lt;code&gt;tell&lt;/code&gt; 에&lt;/a&gt; 의해 반환 된 값 은 호출 후 영향을받을 수 있으며 파일 핸들이 플러시 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c16d57cfd8eeb546a9229ff270928505b42e20e5" translate="yes" xml:space="preserve">
          <source>(Win32) Will not cause &lt;a href=&quot;perlfunc#readdir-DIRHANDLE&quot;&gt;&lt;code&gt;readdir&lt;/code&gt;&lt;/a&gt; to re-read the directory stream. The entries already read before the &lt;code&gt;rewinddir&lt;/code&gt; call will just be returned again from a cache buffer.</source>
          <target state="translated">(Win32) &lt;a href=&quot;perlfunc#readdir-DIRHANDLE&quot;&gt; &lt;code&gt;readdir&lt;/code&gt; &lt;/a&gt; 이 디렉토리 스트림을 다시 읽도록 하지 않습니다 . &lt;code&gt;rewinddir&lt;/code&gt; 호출 전에 이미 읽은 항목 은 캐시 버퍼에서 다시 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="10bb22106c47904ba4de23ad61460103a68c77d9" translate="yes" xml:space="preserve">
          <source>(Win32, Plan 9) Not implemented.</source>
          <target state="translated">(Win32, Plan 9) 구현되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="7b3828212b5e1fac44f5e28173a528aabda2b566" translate="yes" xml:space="preserve">
          <source>(Win32, Plan 9, RISC OS) Not implemented.</source>
          <target state="translated">(Win32, Plan 9, RISC OS) 구현되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="40542d6ea9af81db545576518b945b986145aa7d" translate="yes" xml:space="preserve">
          <source>(Win32, RISC OS) Not implemented.</source>
          <target state="translated">(Win32, RISC OS) 구현되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="d26225477d3018755220f731bf9a8ab3068b4777" translate="yes" xml:space="preserve">
          <source>(Win32, VMS) Only implemented on sockets.</source>
          <target state="translated">(Win32, VMS) 소켓에서만 구현됩니다.</target>
        </trans-unit>
        <trans-unit id="5d6aa1625db6b86980d3dbaf700750f0d7c7c64e" translate="yes" xml:space="preserve">
          <source>(Win32, VMS, Plan 9, RISC OS, VOS) Not implemented.</source>
          <target state="translated">(Win32, VMS, Plan 9, RISC OS, VOS) 구현되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="3ad1926ff99fe753293050c329e9209673eea0dd" translate="yes" xml:space="preserve">
          <source>(Win32, VMS, RISC OS) &lt;code&gt;-R&lt;/code&gt;, &lt;code&gt;-W&lt;/code&gt;, &lt;code&gt;-X&lt;/code&gt;, &lt;code&gt;-O&lt;/code&gt; are indistinguishable from &lt;code&gt;-r&lt;/code&gt;, &lt;code&gt;-w&lt;/code&gt;, &lt;code&gt;-x&lt;/code&gt;, &lt;code&gt;-o&lt;/code&gt;.</source>
          <target state="translated">(Win32, VMS, RISC OS) &lt;code&gt;-R&lt;/code&gt; , &lt;code&gt;-W&lt;/code&gt; , &lt;code&gt;-X&lt;/code&gt; , &lt;code&gt;-O&lt;/code&gt; 는 &lt;code&gt;-r&lt;/code&gt; , &lt;code&gt;-w&lt;/code&gt; , &lt;code&gt;-x&lt;/code&gt; , &lt;code&gt;-o&lt;/code&gt; 와 구별 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="bf0e811dfd518ffe8ef2d881c87867a771eaf7b9" translate="yes" xml:space="preserve">
          <source>(Win32, VMS, RISC OS) &lt;code&gt;-g&lt;/code&gt;, &lt;code&gt;-k&lt;/code&gt;, &lt;code&gt;-l&lt;/code&gt;, &lt;code&gt;-u&lt;/code&gt;, &lt;code&gt;-A&lt;/code&gt; are not particularly meaningful.</source>
          <target state="translated">(Win32, VMS, RISC OS) &lt;code&gt;-g&lt;/code&gt; , &lt;code&gt;-k&lt;/code&gt; , &lt;code&gt;-l&lt;/code&gt; , &lt;code&gt;-u&lt;/code&gt; , &lt;code&gt;-A&lt;/code&gt; 는 특별히 의미가 없습니다.</target>
        </trans-unit>
        <trans-unit id="97e20ab673e91dfb74bf2c5e00e544b51f6a4b2f" translate="yes" xml:space="preserve">
          <source>(Win32, VMS, RISC OS) Not implemented.</source>
          <target state="translated">(Win32, VMS, RISC OS) 구현되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="62553efbe7c6123000971fd2d6d5ef25fc0044a8" translate="yes" xml:space="preserve">
          <source>(Win32, VMS, RISC OS, VOS) Not implemented.</source>
          <target state="translated">(Win32, VMS, RISC OS, VOS) 구현되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="8f1de96f55f7b2b16d13a5f2bab6a184220368b1" translate="yes" xml:space="preserve">
          <source>(Windows only.)</source>
          <target state="translated">(Windows 만 해당)</target>
        </trans-unit>
        <trans-unit id="c3a762aeddeefdae150565438093ccaddaaf9aad" translate="yes" xml:space="preserve">
          <source>(X) A general assertion failed. The file in question must be examined.</source>
          <target state="translated">(X) 일반 주장이 실패했습니다. 해당 파일을 검사해야합니다.</target>
        </trans-unit>
        <trans-unit id="d6a423c5d83c10add2738bacaabc87962a7da812" translate="yes" xml:space="preserve">
          <source>(X) An attempt was made to extend an array, a list, or a string beyond the largest possible memory allocation.</source>
          <target state="translated">(X) 가능한 최대 메모리 할당을 넘어 배열, 목록 또는 문자열을 확장하려고 시도했습니다.</target>
        </trans-unit>
        <trans-unit id="46db9c98808efa8657802d89fa63e7cd01916c84" translate="yes" xml:space="preserve">
          <source>(X) See &lt;a href=&quot;perlrun#PERL_SIGNALS&quot;&gt;&quot;PERL_SIGNALS&quot; in perlrun&lt;/a&gt; for legal values.</source>
          <target state="translated">(X) 유효한 값 &lt;a href=&quot;perlrun#PERL_SIGNALS&quot;&gt;은 perlrun의 &quot;PERL_SIGNALS&quot;를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="28dc575d7faf81030a7009c3890586ad0bfb13c7" translate="yes" xml:space="preserve">
          <source>(X) See &lt;a href=&quot;perlrun#PERL_SIGNALS&quot;&gt;PERL_SIGNALS in perlrun&lt;/a&gt; for legal values.</source>
          <target state="translated">(X) 유효한 값 &lt;a href=&quot;perlrun#PERL_SIGNALS&quot;&gt;은 perlrun의 PERL_SIGNALS를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="25eb4cc27ccccf735eed888542e4498eb2a2aa6d" translate="yes" xml:space="preserve">
          <source>(X) The #! line (or local equivalent) in a Perl script contains the &lt;b&gt;-M&lt;/b&gt;, &lt;b&gt;-m&lt;/b&gt; or &lt;b&gt;-C&lt;/b&gt; option.</source>
          <target state="translated">(X) #! Perl 스크립트의 line (또는 local equivalent)은 &lt;b&gt;-M&lt;/b&gt; , &lt;b&gt;-m&lt;/b&gt; 또는 &lt;b&gt;-C&lt;/b&gt; 옵션을 포함합니다.</target>
        </trans-unit>
        <trans-unit id="04d47aff5005157bb16498793c9ad8c2d7a871aa" translate="yes" xml:space="preserve">
          <source>(X) The #! line (or local equivalent) in a Perl script contains the &lt;b&gt;-T&lt;/b&gt; option (or the &lt;b&gt;-t&lt;/b&gt; option), but Perl was not invoked with &lt;b&gt;-T&lt;/b&gt; in its command line. This is an error because, by the time Perl discovers a &lt;b&gt;-T&lt;/b&gt; in a script, it's too late to properly taint everything from the environment. So Perl gives up.</source>
          <target state="translated">(X) #! Perl 스크립트의 line (또는 local equivalent)은 &lt;b&gt;-T&lt;/b&gt; 옵션 (또는 &lt;b&gt;-t&lt;/b&gt; 옵션)을 포함하지만 Perl은 명령 행에서 &lt;b&gt;-T&lt;/b&gt; 로 호출되지 않았습니다 . 이것은 Perl 이 스크립트에서 &lt;b&gt;-T&lt;/b&gt; 를 발견 할 때 환경에서 모든 것을 제대로 손상 시키기에는 너무 늦기 때문에 오류 입니다. 그래서 펄은 포기합니다.</target>
        </trans-unit>
        <trans-unit id="7d13ded5daf490cc1bc8bb6b0cd74a13b6c46c88" translate="yes" xml:space="preserve">
          <source>(X) The PERL5OPT environment variable may only be used to set the following switches: &lt;b&gt;-[CDIMUdmtw]&lt;/b&gt;.</source>
          <target state="translated">(X) PERL5OPT 환경 변수는 다음 스위치를 설정하는 데만 사용할 수 있습니다 &lt;b&gt;.-[CDIMUdmtw]&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="8e8047249d025e2fe0c43d96f901bbedf4764fe8" translate="yes" xml:space="preserve">
          <source>(X) The malloc package that comes with Perl had an internal failure.</source>
          <target state="translated">(X) Perl과 함께 제공되는 malloc 패키지에 내부 오류가 발생했습니다.</target>
        </trans-unit>
        <trans-unit id="65871f11cf57af573de156d366a86250bc7c9d6a" translate="yes" xml:space="preserve">
          <source>(X) The malloc() function returned 0, indicating there was insufficient remaining memory (or virtual memory) to satisfy the request. Perl has no option but to exit immediately.</source>
          <target state="translated">(X) malloc () 함수가 0을 리턴하여 요청을 충족시키기에 메모리 (또는 가상 메모리)가 충분하지 않음을 나타냅니다. Perl은 즉시 종료 할 수 밖에 없습니다.</target>
        </trans-unit>
        <trans-unit id="74578166360f01e0bd318023e9280f6c6b8eeab2" translate="yes" xml:space="preserve">
          <source>(X) You can't allocate more than 64K on an MS-DOS machine.</source>
          <target state="translated">(X) MS-DOS 시스템에서 64K를 초과하여 할당 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="d5e67ac60b668e8e894b678df3573f0eedbd9863" translate="yes" xml:space="preserve">
          <source>(X)(F) The malloc() function returned 0, indicating there was insufficient remaining memory (or virtual memory) to satisfy the request.</source>
          <target state="translated">(X) (F) malloc () 함수가 0을 리턴하여 요청을 충족시키기에 메모리 (또는 가상 메모리)가 충분하지 않음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="759c6fc4e8e069300c157debbe2514f2f0f2ba35" translate="yes" xml:space="preserve">
          <source>(XO_NFC)</source>
          <target state="translated">(XO_NFC)</target>
        </trans-unit>
        <trans-unit id="5eb03003bf58c317f5fcc12bb40f816384b7f89f" translate="yes" xml:space="preserve">
          <source>(XO_NFD)</source>
          <target state="translated">(XO_NFD)</target>
        </trans-unit>
        <trans-unit id="5ad3fc425ec3db40873d63b37909a2aa76c30974" translate="yes" xml:space="preserve">
          <source>(XO_NFKC)</source>
          <target state="translated">(XO_NFKC)</target>
        </trans-unit>
        <trans-unit id="012a737aa9d39f445b43cf9eee5b96a526347398" translate="yes" xml:space="preserve">
          <source>(XO_NFKD)</source>
          <target state="translated">(XO_NFKD)</target>
        </trans-unit>
        <trans-unit id="0aa007c669bc8d719d70515c0e663390b1a05031" translate="yes" xml:space="preserve">
          <source>(Yes, I know this function is named a bit oddly. Call it historic reasons.)</source>
          <target state="translated">(예,이 기능의 이름이 조금 이상하다는 것을 알고 있습니다. 역사적인 이유라고 부릅니다.)</target>
        </trans-unit>
        <trans-unit id="8eb8ab7981d2a7c45a30aad058d8576bb511d1b4" translate="yes" xml:space="preserve">
          <source>(Yes, we know that some of these OSes may fall under the Unix category, but we are not a standards body.)</source>
          <target state="translated">(예, 우리는 이러한 OS 중 일부가 유닉스 범주에 속할 수 있지만 표준 기관이 아님을 알고 있습니다.)</target>
        </trans-unit>
        <trans-unit id="b27bf5c66dc26e2275621e2196f427590315339a" translate="yes" xml:space="preserve">
          <source>(You can force portability by specifying a Unicode range, which means that the endpoints are specified by &lt;a href=&quot;perlrecharclass#Character-Ranges&quot;&gt;&lt;code&gt;\N{...}&lt;/code&gt;&lt;/a&gt;, but the meaning may still not be obvious.) The stricter rules require that ranges that start or stop with an ASCII character that is not a control have all their endpoints be the literal character, and not some escape sequence (like &lt;code&gt;&quot;\x41&quot;&lt;/code&gt;), and the ranges must be all digits, or all uppercase letters, or all lowercase letters.</source>
          <target state="translated">(유니 코드 범위를 지정하여 이식성을 강제 할 수 있습니다. 즉, 엔드 포인트가 &lt;a href=&quot;perlrecharclass#Character-Ranges&quot;&gt; &lt;code&gt;\N{...}&lt;/code&gt; &lt;/a&gt; 으로 지정되지만 의미가 여전히 명확하지 않을 수 있습니다.) 더 엄격한 규칙은 ASCII로 시작하거나 중지하는 범위를 요구합니다. 컨트롤이 아닌 문자는 모든 끝 점이 리터럴 문자이고 일부 이스케이프 시퀀스 (예 : &lt;code&gt;&quot;\x41&quot;&lt;/code&gt; )가 아니며 범위는 모두 숫자, 모두 대문자 또는 모두 소문자 여야합니다.</target>
        </trans-unit>
        <trans-unit id="a64a87faab12fe29e48406c908901fff7a63848d" translate="yes" xml:space="preserve">
          <source>(You can force portability by specifying a Unicode range, which means that the endpoints are specified by &lt;a href=&quot;perlrecharclass#Character-Ranges&quot;&gt;\N{...} &lt;/a&gt;, but the meaning may still not be obvious.) The stricter rules require that ranges that start or stop with an ASCII character that is not a control have all their endpoints be the literal character, and not some escape sequence (like &lt;code&gt;&quot;\x41&quot;&lt;/code&gt; ), and the ranges must be all digits, or all uppercase letters, or all lowercase letters.</source>
          <target state="translated">(엔드 포인트가 &lt;a href=&quot;perlrecharclass#Character-Ranges&quot;&gt;\ N {...}에&lt;/a&gt; 의해 지정됨을 의미하는 유니 코드 범위를 지정하여 이식성을 강제 할 수 있지만 그 의미는 여전히 명확하지 않을 수 있습니다.) 더 엄격한 규칙은 ASCII로 시작하거나 중지하는 범위를 요구합니다. 제어가 아닌 문자는 모든 엔드 포인트가 리터럴 문자이며 이스케이프 시퀀스 (예 : &lt;code&gt;&quot;\x41&quot;&lt;/code&gt; )가 아니며 범위는 모든 숫자, 모든 대문자 또는 모든 소문자 여야합니다.</target>
        </trans-unit>
        <trans-unit id="40103a04e475e9541eab1f3aaae6dd08be353894" translate="yes" xml:space="preserve">
          <source>(You can't just say &lt;code&gt;$ENV{$key} = $ENV{$key}&lt;/code&gt; , since the Perl optimizer is smart enough to elide the expression.)</source>
          <target state="translated">Perl 옵티마이 저가 표현식을 제거하기에 충분히 똑똑하기 때문에 &lt;code&gt;$ENV{$key} = $ENV{$key}&lt;/code&gt; 만 말할 수는 없습니다 .</target>
        </trans-unit>
        <trans-unit id="1171aa55fd6fe0863b56f6025193055e4cae7805" translate="yes" xml:space="preserve">
          <source>(You can't just say &lt;code&gt;$ENV{$key} = $ENV{$key}&lt;/code&gt;, since the Perl optimizer is smart enough to elide the expression.)</source>
          <target state="translated">( Perl 옵티마이 저는 표현식을 제거 할 수있을만큼 똑똑하기 때문에 &lt;code&gt;$ENV{$key} = $ENV{$key}&lt;/code&gt; 라고 말할 수 없습니다 .)</target>
        </trans-unit>
        <trans-unit id="102826bc7aefa33ccb389fa417f4b040a4a419e3" translate="yes" xml:space="preserve">
          <source>(You can, of course, specify single characters by using, &lt;code&gt;\x{...}&lt;/code&gt; , &lt;code&gt;\N{...}&lt;/code&gt; , etc.)</source>
          <target state="translated">(물론 &lt;code&gt;\x{...}&lt;/code&gt; , &lt;code&gt;\N{...}&lt;/code&gt; 등 을 사용하여 단일 문자를 지정할 수 있습니다 .)</target>
        </trans-unit>
        <trans-unit id="d359a2b41fdaad014858cbb77463584c32391c60" translate="yes" xml:space="preserve">
          <source>(You can, of course, specify single characters by using, &lt;code&gt;\x{...}&lt;/code&gt;, &lt;code&gt;\N{...}&lt;/code&gt;, etc.)</source>
          <target state="translated">(물론 &lt;code&gt;\x{...}&lt;/code&gt; , &lt;code&gt;\N{...}&lt;/code&gt; 등 을 사용하여 단일 문자를 지정할 수 있습니다 .)</target>
        </trans-unit>
        <trans-unit id="e54f3a24beb63ca6443b7641e7e1af7bcf5e3c2b" translate="yes" xml:space="preserve">
          <source>(You may, in fact, want to start with localizing to</source>
          <target state="translated">(실제로 현지화부터 시작하고 싶을 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="4bb2b230b54ad6957c49b6580f615df0eff17f93" translate="yes" xml:space="preserve">
          <source>(added in &lt;code&gt;Sys::Syslog&lt;/code&gt; 0.21). HP-UX is a system which uses such a named pipe.</source>
          <target state="translated">( &lt;code&gt;Sys::Syslog&lt;/code&gt; 0.21에 추가 ). HP-UX는 이러한 명명 된 파이프를 사용하는 시스템입니다.</target>
        </trans-unit>
        <trans-unit id="409526f33747b3d99190c22c4395e3c38ccf1ed4" translate="yes" xml:space="preserve">
          <source>(also known as 90 degrees).</source>
          <target state="translated">(90 도라 고도 함).</target>
        </trans-unit>
        <trans-unit id="7e5760178c4e5a5b7213e471eeab450909811a59" translate="yes" xml:space="preserve">
          <source>(also see &lt;a href=&quot;#gen_delimited_pat&quot;&gt;&quot;gen_delimited_pat&quot;&lt;/a&gt; below).</source>
          <target state="translated">( 아래의 &lt;a href=&quot;#gen_delimited_pat&quot;&gt;&quot;gen_delimited_pat&quot;&lt;/a&gt; 참조).</target>
        </trans-unit>
        <trans-unit id="0975309405add43e0212a50c2f0bc405f3954769" translate="yes" xml:space="preserve">
          <source>(also see &lt;a href=&quot;#gen_delimited_pat&quot;&gt;gen_delimited_pat&lt;/a&gt; below).</source>
          <target state="translated">( 아래 &lt;a href=&quot;#gen_delimited_pat&quot;&gt;gen_delimited_pat&lt;/a&gt; 참조).</target>
        </trans-unit>
        <trans-unit id="1cdc6cf7e203685897747bffc2262178c7977e11" translate="yes" xml:space="preserve">
          <source>(although &lt;code&gt;extract_tagged&lt;/code&gt; is not currently implemented that way, in order to preserve pre-5.005 compatibility).</source>
          <target state="translated">(하지만 &lt;code&gt;extract_tagged&lt;/code&gt; 현재의 방법, 순서대로 사전 5.005의 호환성을 유지하는 것을 구현되지 않습니다).</target>
        </trans-unit>
        <trans-unit id="f2cfa0da4ed10df5c469d6ab0c502d0727365ce2" translate="yes" xml:space="preserve">
          <source>(although in production code the substitutions might be done in the EBCDIC branch with the function call and separately in the ASCII branch without the expense of the identity map; in Perl v5.22, the identity map is optimized out so there is no expense, but the alternative above is simpler and is also available in v5.22).</source>
          <target state="translated">(프로덕션 코드에서 ID 맵을 사용하지 않고 EBCDIC 분기에서 함수 호출을 사용하고 ASCII 분기에서 별도로 대체를 수행 할 수 있지만 Perl v5.22에서는 ID 맵이 최적화되어 비용이 발생하지 않습니다. 그러나 위의 대안은 더 간단하고 v5.22에서도 사용할 수 있습니다).</target>
        </trans-unit>
        <trans-unit id="d32ccfc33694fd3b9b08e15cd17089eb0baac7ce" translate="yes" xml:space="preserve">
          <source>(and</source>
          <target state="translated">(and</target>
        </trans-unit>
        <trans-unit id="4f9622103ba7043a2f17e986f7fa6b31d025760e" translate="yes" xml:space="preserve">
          <source>(and problematic) UTF-8 behaviour of Perl 5.8.0. (See &lt;a href=&quot;https://perldoc.perl.org/5.26.0/perl581delta.html#UTF-8-no-longer-default-under-UTF-8-locales&quot;&gt;UTF-8 no longer default under UTF-8 locales in perl581delta&lt;/a&gt;.)</source>
          <target state="translated">(그리고 문제가있는) Perl 5.8.0의 UTF-8 동작. ( &lt;a href=&quot;https://perldoc.perl.org/5.26.0/perl581delta.html#UTF-8-no-longer-default-under-UTF-8-locales&quot;&gt;perl581delta의 UTF-8 로켈에서 더 이상 UTF-8이 기본값이 아님을&lt;/a&gt; 참조하십시오 .)</target>
        </trans-unit>
        <trans-unit id="c511b51313a0786c3fbbfa64fa588b599c3cae21" translate="yes" xml:space="preserve">
          <source>(and problematic) UTF-8 behaviour of Perl 5.8.0. (See &lt;a href=&quot;https://perldoc.perl.org/5.32.0/perl581delta#UTF-8-no-longer-default-under-UTF-8-locales&quot;&gt;&quot;UTF-8 no longer default under UTF-8 locales&quot; in perl581delta&lt;/a&gt;.)</source>
          <target state="translated">(문제가있는) Perl 5.8.0의 UTF-8 동작. ( &lt;a href=&quot;https://perldoc.perl.org/5.32.0/perl581delta#UTF-8-no-longer-default-under-UTF-8-locales&quot;&gt;perl581delta의 &quot;UTF-8은 더 이상 UTF-8 로케일에서 기본값이 아님&quot;을 참조하십시오&lt;/a&gt; .)</target>
        </trans-unit>
        <trans-unit id="692b42cc2b3e37f46870d9371dc5e76fada22536" translate="yes" xml:space="preserve">
          <source>(and you have to say &lt;code&gt;not_&lt;/code&gt; ; you can't use the bang &lt;code&gt;!&lt;/code&gt; form). This pseudo category is a shorthand for specifying both &lt;code&gt;:collate&lt;/code&gt; and &lt;code&gt;:ctype&lt;/code&gt; . Hence, in the negated form, it is nearly the same thing as saying</source>
          <target state="translated">(그리고 당신은 &lt;code&gt;not_&lt;/code&gt; 을 말해야 합니다 ; 당신은 bang &lt;code&gt;!&lt;/code&gt; 양식을 사용할 수 없습니다 ). 이 의사 범주는 &lt;code&gt;:collate&lt;/code&gt; 및 &lt;code&gt;:ctype&lt;/code&gt; 을 모두 지정하기위한 축약 형입니다 . 따라서 부정 된 형태로 말하는 것과 거의 같습니다.</target>
        </trans-unit>
        <trans-unit id="138c271ae8fbee88ee204a6c36a59c9dff93f77a" translate="yes" xml:space="preserve">
          <source>(and you have to say &lt;code&gt;not_&lt;/code&gt;; you can't use the bang &lt;code&gt;!&lt;/code&gt; form). This pseudo category is a shorthand for specifying both &lt;code&gt;:collate&lt;/code&gt; and &lt;code&gt;:ctype&lt;/code&gt;. Hence, in the negated form, it is nearly the same thing as saying</source>
          <target state="translated">(그리고 당신은 &lt;code&gt;not_&lt;/code&gt; 이라고 말해야합니다 ; 당신은 bang &lt;code&gt;!&lt;/code&gt; 형태를 사용할 수 없습니다 ). 이 의사 범주는 &lt;code&gt;:collate&lt;/code&gt; 및 &lt;code&gt;:ctype&lt;/code&gt; 을 모두 지정하는 약어입니다 . 따라서 부정 된 형태로 말하자면</target>
        </trans-unit>
        <trans-unit id="6aeff3579e72696260e1169c528784c27ec7b978" translate="yes" xml:space="preserve">
          <source>(answer contributed by brian d foy)</source>
          <target state="translated">(Brian D Foy가 제공 한 답변)</target>
        </trans-unit>
        <trans-unit id="e5076fd75f69e901d6b296f3219688b4e49af9fb" translate="yes" xml:space="preserve">
          <source>(as is one for 5.005_53), and the new version is 5.6.1. Create a file</source>
          <target state="translated">(5.005_53의 경우와 동일) 새 버전은 5.6.1입니다. 파일 만들기</target>
        </trans-unit>
        <trans-unit id="bd07f3e89f025430991fd3ab747b695ca2119809" translate="yes" xml:space="preserve">
          <source>(as modified under &lt;code&gt;/c&lt;/code&gt;), and these potentially modified lists are used as the basis for what follows. Any character in the target string that isn't in</source>
          <target state="translated">( &lt;code&gt;/c&lt;/code&gt; 에서 수정 됨 ) 잠재적으로 수정 된 목록은 다음 항목의 기초로 사용됩니다. 포함되지 않은 대상 문자열의 모든 문자</target>
        </trans-unit>
        <trans-unit id="2a87525a6c2a886c0eaf943b38e0ee76d77adf64" translate="yes" xml:space="preserve">
          <source>(as the filename of DUCET) is used. If you will prepare your own table file, any name other than</source>
          <target state="translated">(DUCET의 파일 이름으로)가 사용됩니다. 자신의 테이블 파일을 준비하는 경우 이외의 다른 이름</target>
        </trans-unit>
        <trans-unit id="786ef72f31164be533ff5c7e4a7e63ae5230f32a" translate="yes" xml:space="preserve">
          <source>(assuming the default installation location was chosen).</source>
          <target state="translated">(기본 설치 위치가 선택되었다고 가정).</target>
        </trans-unit>
        <trans-unit id="63c4a5f42cbbe3a05030f3bc9132df45a99212cd" translate="yes" xml:space="preserve">
          <source>(at least) the following lines</source>
          <target state="translated">(적어도) 다음 줄</target>
        </trans-unit>
        <trans-unit id="b948cb7a3253ff3b0a5238bd22a6d610864b716f" translate="yes" xml:space="preserve">
          <source>(at the very end for binary compatibility).</source>
          <target state="translated">(이진 호환성을 위해 맨 끝에).</target>
        </trans-unit>
        <trans-unit id="48792f7a9033374771dbfb100ac3abb29a32dab5" translate="yes" xml:space="preserve">
          <source>(because either it starts with a &quot;_&quot;, or because none of its lexicons have &lt;code&gt;_AUTO =&amp;gt; 1,&lt;/code&gt; ), then we have failed to find a normal way to maketext</source>
          <target state="translated">( &quot;_&quot;로 시작하거나 어휘집에 &lt;code&gt;_AUTO =&amp;gt; 1,&lt;/code&gt; 이 없기 때문에 ) 텍스트를 만드는 일반적인 방법을 찾지 못했습니다.</target>
        </trans-unit>
        <trans-unit id="89da1dcaa9a2597711f521770fdd8b5c61c39c1a" translate="yes" xml:space="preserve">
          <source>(because either it starts with a &quot;_&quot;, or because none of its lexicons have &lt;code&gt;_AUTO =&amp;gt; 1,&lt;/code&gt;), then we have failed to find a normal way to maketext</source>
          <target state="translated">( &quot;_&quot;로 시작하거나 어휘집에 &lt;code&gt;_AUTO =&amp;gt; 1,&lt;/code&gt; ) 가 없기 때문에 텍스트 를 만드는 일반적인 방법을 찾지 못했습니다.</target>
        </trans-unit>
        <trans-unit id="f6d16baf27904d45d89ec1d9d7ed8281fa17d9fe" translate="yes" xml:space="preserve">
          <source>(because in particular, simply assigning a weak reference back to itself does not work to unweaken it; &lt;code&gt;$REF = $REF&lt;/code&gt; does not work).</source>
          <target state="translated">(특히, 약한 참조를 자체로 다시 할당하면 해제되지 않습니다. &lt;code&gt;$REF = $REF&lt;/code&gt; 는 작동하지 않습니다).</target>
        </trans-unit>
        <trans-unit id="4b16cab82b532af855df5c5a4ca92e48f90985fe" translate="yes" xml:space="preserve">
          <source>(but slightly more complicated). This tree reflects the way Perl parsed your code, but has nothing to do with the execution order. There is an additional &quot;thread&quot; going through the nodes of the tree which shows the order of execution of the nodes. In our simplified example above it looks like:</source>
          <target state="translated">(그러나 약간 더 복잡합니다). 이 트리는 Perl이 코드를 구문 분석 한 방식을 반영하지만 실행 순서와는 아무런 관련이 없습니다. 노드의 실행 순서를 보여주는 트리의 노드를 통과하는 추가 &quot;스레드&quot;가 있습니다. 위의 간단한 예에서 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4693cf64bd9a521498526ddc1119c6dfd5c3b552" translate="yes" xml:space="preserve">
          <source>(c) Tels &lt;a href=&quot;http://bloodgate.com&quot;&gt;http://bloodgate.com&lt;/a&gt; 2003, 2004 - based on BigInt code by Tels from 2001-2003.</source>
          <target state="translated">(c) Tels &lt;a href=&quot;http://bloodgate.com&quot;&gt;http://bloodgate.com&lt;/a&gt; 2003, 2004-2001-2003 년 Tels의 BigInt 코드 기반.</target>
        </trans-unit>
        <trans-unit id="f6623ddfaf5c5328a69ecd651966b3d508f1ba1d" translate="yes" xml:space="preserve">
          <source>(change &quot;unrestricted&quot; to &quot;redistributable&quot;?)</source>
          <target state="translated">( &quot;무제한&quot;을 &quot;재배포 가능&quot;으로 변경 하시겠습니까?)</target>
        </trans-unit>
        <trans-unit id="f179f6995bed99ae8a0cfb9caaec4219d44a9f23" translate="yes" xml:space="preserve">
          <source>(configure, build, test, runtime, etc.) and</source>
          <target state="translated">(구성, 빌드, 테스트, 런타임 등) 및</target>
        </trans-unit>
        <trans-unit id="f705994b685d7ab39803fc55afe57bb501708c2b" translate="yes" xml:space="preserve">
          <source>(const) data, and the &lt;code&gt;U&lt;/code&gt; is &amp;lt;undefined&amp;gt;, external symbols referred to.</source>
          <target state="translated">(const) 데이터이고 &lt;code&gt;U&lt;/code&gt; 는 &amp;lt;undefined&amp;gt;이며 외부 기호가 참조됩니다.</target>
        </trans-unit>
        <trans-unit id="f2d8cd4b2f49ebe16d34218b69e616c4bfb7685e" translate="yes" xml:space="preserve">
          <source>(contributed by Alex Beamish)</source>
          <target state="translated">(Alex Beamish 제공)</target>
        </trans-unit>
        <trans-unit id="8a01f14aa6ea03ae12033993b8340bb14bc9dc2b" translate="yes" xml:space="preserve">
          <source>(contributed by Anno Siegel)</source>
          <target state="translated">(Anno Siegel 제공)</target>
        </trans-unit>
        <trans-unit id="fac38ab03b508c364ce52ea99dd09ac56e9be13a" translate="yes" xml:space="preserve">
          <source>(contributed by Ben Morrow)</source>
          <target state="translated">(Ben Morrow 제공)</target>
        </trans-unit>
        <trans-unit id="cab93540468b3299e5e7ff453d2c13989f42fd8e" translate="yes" xml:space="preserve">
          <source>(contributed by Brian McCauley)</source>
          <target state="translated">(브라이언 맥컬리 제공)</target>
        </trans-unit>
        <trans-unit id="5866c9a649588b2bcaf84ab58628c670110cf84d" translate="yes" xml:space="preserve">
          <source>(contributed by Michael Carman)</source>
          <target state="translated">(Michael Carman 제공)</target>
        </trans-unit>
        <trans-unit id="11aa83d938cb90075d1401151f2508d1510688fe" translate="yes" xml:space="preserve">
          <source>(contributed by Peter J. Holzer, hjp-usenet2@hjp.at)</source>
          <target state="translated">(Peter J. Holzer, hjp-usenet2@hjp.at 제공)</target>
        </trans-unit>
        <trans-unit id="5dee00bc78a497a9d448541fd31f216ca89ba87a" translate="yes" xml:space="preserve">
          <source>(contributed by Shlomi Fish)</source>
          <target state="translated">(Shlomi Fish에서 제공)</target>
        </trans-unit>
        <trans-unit id="1e46d3c5ed3722672a09f39374a1a7ffdac24e1c" translate="yes" xml:space="preserve">
          <source>(contributed by Xho)</source>
          <target state="translated">(Xho 제공)</target>
        </trans-unit>
        <trans-unit id="b1ad773d61a232c565a534ba9591dd6ec671fc74" translate="yes" xml:space="preserve">
          <source>(contributed by brian d foy and Ben Morrow)</source>
          <target state="translated">(브라이언 디 포이와 벤 모로우가 제공)</target>
        </trans-unit>
        <trans-unit id="da6037d0c8a0901dbdb8efa83408cf6cf316ca26" translate="yes" xml:space="preserve">
          <source>(contributed by brian d foy and Benjamin Goldberg)</source>
          <target state="translated">(브라이언 디 포이와 벤자민 골드버그가 제공)</target>
        </trans-unit>
        <trans-unit id="b450df445d93e3c6b0f335b0c69c72d7b68c7ec1" translate="yes" xml:space="preserve">
          <source>(contributed by brian d foy and Dave Cross)</source>
          <target state="translated">(brian d foy와 Dave Cross가 제공)</target>
        </trans-unit>
        <trans-unit id="31cee2f6fca37b4a710b6741f1b97ea6878162ca" translate="yes" xml:space="preserve">
          <source>(contributed by brian d foy with updates from others)</source>
          <target state="translated">(Brian d Foy가 다른 사람의 업데이트와 함께 기고 함)</target>
        </trans-unit>
        <trans-unit id="5ecf6719df9ae48ff24c5100a5d4b1ef446cd95f" translate="yes" xml:space="preserve">
          <source>(contributed by brian d foy)</source>
          <target state="translated">(brian d foy 제공)</target>
        </trans-unit>
        <trans-unit id="2c422c445de0783d3809d65cd3e3acd9a5e0e370" translate="yes" xml:space="preserve">
          <source>(contributed by brian d foy, updated Fri Jul 25 12:22:26 PDT 2008)</source>
          <target state="translated">(brian d foy 제공, Fri Jul 25 12:22:26 PDT 2008 업데이트)</target>
        </trans-unit>
        <trans-unit id="9c413c8db2fc0e0a195f2df6b3cb2359816721c7" translate="yes" xml:space="preserve">
          <source>(copyright 2004, Published by O'Reilly Media, Inc.), Damian Conway provides a list of criteria to use when deciding if OO is the right fit for your problem:</source>
          <target state="translated">(저작권 2004, O'Reilly Media, Inc.에서 발행), Damian Conway는 OO가 문제에 적합한 지 결정할 때 사용할 기준 목록을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="181e536cf1422cc7201f63d065eb7aa9c1490f16" translate="yes" xml:space="preserve">
          <source>(currently the last two may hit a wrong location, but this may improve soon). Under Win* see &lt;a href=&quot;#SYNOPSIS&quot;&gt;&quot;SYNOPSIS&quot;&lt;/a&gt;.</source>
          <target state="translated">(현재 마지막 두 개는 잘못된 위치에 도달 할 수 있지만 곧 개선 될 수 있습니다.) Win *에서 &lt;a href=&quot;#SYNOPSIS&quot;&gt;&quot;SYNOPSIS&quot;를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ea2654366590f288ae6ebd7fdc54bceaf9e6545c" translate="yes" xml:space="preserve">
          <source>(currently the last two may hit a wrong location, but this may improve soon). Under Win* see &lt;a href=&quot;#SYNOPSIS&quot;&gt;SYNOPSIS&lt;/a&gt;.</source>
          <target state="translated">(현재 마지막 두 개는 잘못된 위치에 도달 할 수 있지만 곧 개선 될 수 있습니다). Win *에서 &lt;a href=&quot;#SYNOPSIS&quot;&gt;SYNOPSIS를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="41e74bf7b4c32eb2f41eaf25ee2c6c323ec8d504" translate="yes" xml:space="preserve">
          <source>(cuttable). An atomic operation is an action that can&amp;rsquo;t be interrupted, not one forbidden in a nuclear-free zone.</source>
          <target state="translated">(절단 가능). 원자 작전은 핵없는 지역에서 금지 된 것이 아니라 중단 될 수없는 행동입니다.</target>
        </trans-unit>
        <trans-unit id="b3a9a8199852eb2a04185407b3827576c8e6172d" translate="yes" xml:space="preserve">
          <source>(defaults to the environment variable</source>
          <target state="translated">(기본적으로 환경 변수</target>
        </trans-unit>
        <trans-unit id="c979523d1a9c1a0d77ab7e430a7c98147073391d" translate="yes" xml:space="preserve">
          <source>(deprecated - use &lt;code&gt;(AV *)NULL&lt;/code&gt; instead)</source>
          <target state="translated">(더 이상 사용되지 않음- 대신 &lt;code&gt;(AV *)NULL&lt;/code&gt; 사용)</target>
        </trans-unit>
        <trans-unit id="887821ca73f1fcf6de46ded6b730b60d3beffd8e" translate="yes" xml:space="preserve">
          <source>(deprecated - use &lt;code&gt;(CV *)NULL&lt;/code&gt; instead)</source>
          <target state="translated">(더 이상 사용되지 않음- 대신 &lt;code&gt;(CV *)NULL&lt;/code&gt; 사용)</target>
        </trans-unit>
        <trans-unit id="b53d21700af9fd28a7f43adfe7247f1c0f49ab4c" translate="yes" xml:space="preserve">
          <source>(deprecated - use &lt;code&gt;(HV *)NULL&lt;/code&gt; instead)</source>
          <target state="translated">(더 이상 사용되지 않음- 대신 &lt;code&gt;(HV *)NULL&lt;/code&gt; 사용)</target>
        </trans-unit>
        <trans-unit id="4957206df9fb7ffd7b399b79b2a6449d69017a22" translate="yes" xml:space="preserve">
          <source>(do not forget to run &lt;code&gt;make regen_headers&lt;/code&gt; if you modify this file).</source>
          <target state="translated">( 이 파일을 수정하면 &lt;code&gt;make regen_headers&lt;/code&gt; 를 실행하는 것을 잊지 마십시오 ).</target>
        </trans-unit>
        <trans-unit id="47d764752c9dc13917cf2e5897bbaac62c58fbf5" translate="yes" xml:space="preserve">
          <source>(e.g., the application may hang, or generate an error) due to mutexes that are needed to control functionality within the &lt;a href=&quot;threads&quot;&gt;threads&lt;/a&gt; module.</source>
          <target state="translated">(예를 들어, &lt;a href=&quot;threads&quot;&gt;스레드&lt;/a&gt; 모듈 내의 기능을 제어하는 ​​데 필요한 뮤텍스로 인해 응용 프로그램이 중단되거나 오류가 발생할 수 있음) .</target>
        </trans-unit>
        <trans-unit id="ae81a9ce14e07a570fbb453b8b2d8a4343210087" translate="yes" xml:space="preserve">
          <source>(engineers use</source>
          <target state="translated">(엔지니어는</target>
        </trans-unit>
        <trans-unit id="a0b2466bb6153f054793526252c555c73aaf459d" translate="yes" xml:space="preserve">
          <source>(equal) if the operands are char-for-char identical. If you really want to know whether two strings--which &lt;code&gt;eq&lt;/code&gt; and &lt;code&gt;cmp&lt;/code&gt; may consider different--are equal as far as collation in the locale is concerned, see the discussion in &lt;a href=&quot;#Category-LC_COLLATE%3A-Collation&quot;&gt;&quot;Category &lt;code&gt;LC_COLLATE&lt;/code&gt;: Collation&quot;&lt;/a&gt;.</source>
          <target state="translated">(같음) 피연산자가 char-for-char 동일한 경우. 로케일의 데이터 정렬에 관한 한 &lt;code&gt;eq&lt;/code&gt; 와 &lt;code&gt;cmp&lt;/code&gt; 가 서로 다른 것으로 간주 할 수 있는 두 문자열 이 동일한 지 여부를 정말로 알고 싶다면 &lt;a href=&quot;#Category-LC_COLLATE%3A-Collation&quot;&gt;&quot;Category &lt;code&gt;LC_COLLATE&lt;/code&gt; : Collation&quot;&lt;/a&gt; 의 설명을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="4a54a48aa166f000450ddb5bbfffb162a4703f6a" translate="yes" xml:space="preserve">
          <source>(equal) if the operands are char-for-char identical. If you really want to know whether two strings--which &lt;code&gt;eq&lt;/code&gt; and &lt;code&gt;cmp&lt;/code&gt; may consider different--are equal as far as collation in the locale is concerned, see the discussion in &lt;a href=&quot;#Category-LC_COLLATE-%3a-Collation&quot;&gt;Category LC_COLLATE : Collation&lt;/a&gt;.</source>
          <target state="translated">피연산자가 char-for-char와 동일한 경우 (동일). 로케일의 데이터 정렬과 관련하여 &lt;code&gt;eq&lt;/code&gt; 와 &lt;code&gt;cmp&lt;/code&gt; 가 다른 것으로 간주 될 수 있는 두 개의 문자열 이 동일한 지 여부를 실제로 알고 싶다면 &lt;a href=&quot;#Category-LC_COLLATE-%3a-Collation&quot;&gt;LC_COLLATE : Collation 범주&lt;/a&gt; 의 설명을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="7d245ed086c5e828978b1419867a15ebe5c96265" translate="yes" xml:space="preserve">
          <source>(explained in the next paragraph), separated by spaces. (Other than as used to separate elements, spaces are to be ignored.) Case distinctions in the condition list are not significant. Conditions preceded by &quot;NON_&quot; represent the negation of the condition.</source>
          <target state="translated">(다음 단락에서 설명) 공백으로 구분합니다. (요소를 구분하는 데 사용되는 경우를 제외하고 공백은 무시됩니다.) 조건 목록의 대소 문자 구분이 중요하지 않습니다. &quot;NON_&quot;앞에 오는 조건은 조건의 부정을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="b7612ed7f2ab039566cbb6a180523b77c6c55c37" translate="yes" xml:space="preserve">
          <source>(for Win32 Perl)</source>
          <target state="translated">(Win32 Perl 용)</target>
        </trans-unit>
        <trans-unit id="52773988fa05986370e14e73b80f0d9b5d869e6f" translate="yes" xml:space="preserve">
          <source>(for pthreads platforms)</source>
          <target state="translated">(pthreads 플랫폼 용)</target>
        </trans-unit>
        <trans-unit id="f2baa49355f382d8855fa13bc94ef1ce38af8547" translate="yes" xml:space="preserve">
          <source>(have the directories with &lt;code&gt;*.exe&lt;/code&gt; on PATH, and &lt;code&gt;*.dll&lt;/code&gt; on LIBPATH);</source>
          <target state="translated">( PATH에 &lt;code&gt;*.exe&lt;/code&gt; , LIBPATH에 &lt;code&gt;*.dll&lt;/code&gt; 이있는 디렉토리가 있음 );</target>
        </trans-unit>
        <trans-unit id="8b307b3649a26281003eca21c9415192d0da1a2f" translate="yes" xml:space="preserve">
          <source>(have the directory on PATH);</source>
          <target state="translated">(PATH에 디렉토리가 있음);</target>
        </trans-unit>
        <trans-unit id="e78594face702b66af1259171d24ead963a0670c" translate="yes" xml:space="preserve">
          <source>(here the optional &lt;code&gt;IN&lt;/code&gt; keyword is omitted).</source>
          <target state="translated">(여기서 선택적 &lt;code&gt;IN&lt;/code&gt; 키워드는 생략됩니다).</target>
        </trans-unit>
        <trans-unit id="0ca1edf548683a8b18ee06ce8f4d27a28c75a756" translate="yes" xml:space="preserve">
          <source>(i.e. &lt;code&gt;A::foo&lt;/code&gt; is called twice).</source>
          <target state="translated">(즉, &lt;code&gt;A::foo&lt;/code&gt; 가 두 번 호출됩니다).</target>
        </trans-unit>
        <trans-unit id="8f8464e8307b268923dc0c2b5876277d2c0fd5db" translate="yes" xml:space="preserve">
          <source>(i.e., &lt;code&gt;(EXPR &amp;amp; 0700) &amp;gt; 0&lt;/code&gt; ), raises an exception. If umask(2) is not implemented and you are not trying to restrict access for yourself, returns &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">(예 : &lt;code&gt;(EXPR &amp;amp; 0700) &amp;gt; 0&lt;/code&gt; ) 예외가 발생합니다. umask (2)가 구현되지 않고 사용자 자신에 대한 액세스를 제한하지 않으면 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 를 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="8f5d49562cd8c87da892149a0b2d4a8af46e9d52" translate="yes" xml:space="preserve">
          <source>(i.e., &lt;code&gt;(EXPR &amp;amp; 0700) &amp;gt; 0&lt;/code&gt; ), raises an exception. If umask(2) is not implemented and you are not trying to restrict access for yourself, returns &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">(예 : &lt;code&gt;(EXPR &amp;amp; 0700) &amp;gt; 0&lt;/code&gt; ) 예외가 발생합니다. umask (2)가 구현되지 않고 사용자 자신에 대한 액세스를 제한하지 않으면 &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 를 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="d6522627c132299a9219dc1d891e679179a79502" translate="yes" xml:space="preserve">
          <source>(i.e., &lt;code&gt;(EXPR &amp;amp; 0700) &amp;gt; 0&lt;/code&gt;), raises an exception. If &lt;a href=&quot;http://man.he.net/man2/umask&quot;&gt;umask(2)&lt;/a&gt; is not implemented and you are not trying to restrict access for yourself, returns &lt;a href=&quot;#undef-EXPR&quot;&gt;&lt;code&gt;undef&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">(즉, &lt;code&gt;(EXPR &amp;amp; 0700) &amp;gt; 0&lt;/code&gt; ), 예외가 발생합니다. 경우 &lt;a href=&quot;http://man.he.net/man2/umask&quot;&gt;의 umask (2)가&lt;/a&gt; 구현되지 않고, 자신에 대한 액세스를 제한하는 것을 시도하지 않는, 반환 &lt;a href=&quot;#undef-EXPR&quot;&gt; &lt;code&gt;undef&lt;/code&gt; 를&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="55c213fac91606d567b36164fd0c347d752bb458" translate="yes" xml:space="preserve">
          <source>(i.e., Unix) you can configure perl with &lt;code&gt;-Accflags=-DPERL_DEBUG_READONLY_COW&lt;/code&gt; and it will turn buffer violations into crashes. You will find it to be marvellously slow, so you may want to skip perl's own tests.</source>
          <target state="translated">(즉, Unix) &lt;code&gt;-Accflags=-DPERL_DEBUG_READONLY_COW&lt;/code&gt; 를 사용 하여 perl을 구성 하면 버퍼 위반이 충돌로 바뀝니다. 놀랍게도 느리게 느껴지므로 펄 자신의 테스트를 건너 뛰고 싶을 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="ce300057bb6cbcc44d6adf16788915bba76efc18" translate="yes" xml:space="preserve">
          <source>(if &lt;a href=&quot;../cpan/meta&quot;&gt;CPAN::Meta&lt;/a&gt; is installed). Clients like &lt;a href=&quot;../cpan&quot;&gt;CPAN&lt;/a&gt; or &lt;a href=&quot;http://search.cpan.org/perldoc/CPANPLUS&quot;&gt;CPANPLUS&lt;/a&gt; will read this files to see what prerequisites must be fulfilled before building or testing the distribution. If you with to shut this feature off, set the &lt;code&gt;NO_MYMETA&lt;/code&gt;&lt;code&gt;WriteMakeFile()&lt;/code&gt; flag to true.</source>
          <target state="translated">( &lt;a href=&quot;../cpan/meta&quot;&gt;CPAN :: Meta&lt;/a&gt; 가 설치된 경우). &lt;a href=&quot;../cpan&quot;&gt;CPAN&lt;/a&gt; 또는 &lt;a href=&quot;http://search.cpan.org/perldoc/CPANPLUS&quot;&gt;CPANPLUS&lt;/a&gt; 와 같은 클라이언트 는이 파일을 읽고 분배를 빌드하거나 테스트하기 전에 충족해야하는 전제 조건을 확인합니다. 이 기능을 끄려면 &lt;code&gt;NO_MYMETA&lt;/code&gt; &lt;code&gt;WriteMakeFile()&lt;/code&gt; 플래그를 true로 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="1bb2e3e9c70daf92dbbbe2b3d1b529a91355eda5" translate="yes" xml:space="preserve">
          <source>(if &lt;a href=&quot;CPAN::Meta&quot;&gt;CPAN::Meta&lt;/a&gt; is installed). Clients like &lt;a href=&quot;cpan&quot;&gt;CPAN&lt;/a&gt; or &lt;a href=&quot;cpanplus&quot;&gt;CPANPLUS&lt;/a&gt; will read these files to see what prerequisites must be fulfilled before building or testing the distribution. If you wish to shut this feature off, set the &lt;code&gt;NO_MYMETA&lt;/code&gt;&lt;code&gt;WriteMakeFile()&lt;/code&gt; flag to true.</source>
          <target state="translated">( &lt;a href=&quot;CPAN::Meta&quot;&gt;CPAN :: Meta&lt;/a&gt; 가 설치된 경우). &lt;a href=&quot;cpan&quot;&gt;CPAN&lt;/a&gt; 또는 &lt;a href=&quot;cpanplus&quot;&gt;CPANPLUS&lt;/a&gt; 와 같은 클라이언트 는 배포를 빌드하거나 테스트하기 전에 충족해야하는 전제 조건을 확인하기 위해 이러한 파일을 읽습니다. 이 기능을 끄려면 &lt;code&gt;NO_MYMETA&lt;/code&gt; &lt;code&gt;WriteMakeFile()&lt;/code&gt; 플래그를 true로 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="74e7cc4a040d094131ce7adf1ccff6a9eb9bc3ff" translate="yes" xml:space="preserve">
          <source>(if it exists) are ignored.</source>
          <target state="translated">(있는 경우) 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="8bd7b4287b1a4320a59f0e97575d78114f1f439c" translate="yes" xml:space="preserve">
          <source>(ignore multiple &lt;code&gt;warning L4085&lt;/code&gt; ).</source>
          <target state="translated">(여러 &lt;code&gt;warning L4085&lt;/code&gt; 무시 ).</target>
        </trans-unit>
        <trans-unit id="22e1932e601e46590f4cd1081a5ac59daa128d38" translate="yes" xml:space="preserve">
          <source>(ignore multiple &lt;code&gt;warning L4085&lt;/code&gt;).</source>
          <target state="translated">(여러 &lt;code&gt;warning L4085&lt;/code&gt; 무시 ).</target>
        </trans-unit>
        <trans-unit id="51361c690dc77f93fb8886da6627b841196647e3" translate="yes" xml:space="preserve">
          <source>(in a new</source>
          <target state="translated">(새로운</target>
        </trans-unit>
        <trans-unit id="d346483f692f461af7f2b89212d442e1ef9e6fb1" translate="yes" xml:space="preserve">
          <source>(in cleanup) %s</source>
          <target state="translated">(정리 중) % s</target>
        </trans-unit>
        <trans-unit id="92af5b7be830c62c74b2cbee2ea3528c112d9b33" translate="yes" xml:space="preserve">
          <source>(in the CPAN distribution of this module) for how to create a class that supports object sharing.</source>
          <target state="translated">(이 모듈의 CPAN 배포판에서) 객체 공유를 지원하는 클래스를 만드는 방법</target>
        </trans-unit>
        <trans-unit id="facc7193d5281131d9b0521947b073e2e6c2eb5b" translate="yes" xml:space="preserve">
          <source>(installed as</source>
          <target state="translated">(로 설치</target>
        </trans-unit>
        <trans-unit id="70b861787e317f2c2b8cac2c8a1c5c4c08c57918" translate="yes" xml:space="preserve">
          <source>(installed as &lt;a href=&quot;perlamiga&quot;&gt;perlamiga&lt;/a&gt;).</source>
          <target state="translated">( &lt;a href=&quot;perlamiga&quot;&gt;perlamiga&lt;/a&gt; 로 설치됨 ).</target>
        </trans-unit>
        <trans-unit id="4a2fc6f0afe5ebafb971a5f6f6450a8a8966ee80" translate="yes" xml:space="preserve">
          <source>(installed as &lt;a href=&quot;perlcygwin&quot;&gt;perlcygwin&lt;/a&gt;), &lt;a href=&quot;http://www.cygwin.com/&quot;&gt;http://www.cygwin.com/&lt;/a&gt;</source>
          <target state="translated">( &lt;a href=&quot;perlcygwin&quot;&gt;perlcygwin으로&lt;/a&gt; 설치 ), &lt;a href=&quot;http://www.cygwin.com/&quot;&gt;http://www.cygwin.com/&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="30794954cc28f569f6a6161a7038ad0f0357c23b" translate="yes" xml:space="preserve">
          <source>(installed as &lt;a href=&quot;perlcygwin&quot;&gt;perlcygwin&lt;/a&gt;), &lt;a href=&quot;https://www.cygwin.com/&quot;&gt;https://www.cygwin.com/&lt;/a&gt;</source>
          <target state="translated">( &lt;a href=&quot;perlcygwin&quot;&gt;perlcygwin&lt;/a&gt; 으로 설치됨 ), &lt;a href=&quot;https://www.cygwin.com/&quot;&gt;https://www.cygwin.com/&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d21126d258fc7e5193f50e33b705649c9f31bd37" translate="yes" xml:space="preserve">
          <source>(installed as &lt;a href=&quot;perlvos&quot;&gt;perlvos&lt;/a&gt;)</source>
          <target state="translated">( &lt;a href=&quot;perlvos&quot;&gt;perlvos&lt;/a&gt; 로 설치됨 )</target>
        </trans-unit>
        <trans-unit id="69a2857991e5de08a1db31d1251389885ffd8caa" translate="yes" xml:space="preserve">
          <source>(internal use only)</source>
          <target state="translated">(내부 전용)</target>
        </trans-unit>
        <trans-unit id="3745d664a5cb578c0bc49111f2af5da3e3f2d003" translate="yes" xml:space="preserve">
          <source>(just by the name of the IO function, like &quot;Read&quot;) with the</source>
          <target state="translated">( &quot;읽기&quot;와 같은 IO 기능의 이름으로)</target>
        </trans-unit>
        <trans-unit id="cd5c26a005439b782269db0e964b40fc7eca11de" translate="yes" xml:space="preserve">
          <source>(like &lt;code&gt;COMBINING ACUTE ACCENT&lt;/code&gt; ). This sequence of base character and modifiers is called a</source>
          <target state="translated">( &lt;code&gt;COMBINING ACUTE ACCENT&lt;/code&gt; 와 같은 ). 이 기본 문자 및 수정 자의 순서를</target>
        </trans-unit>
        <trans-unit id="e4fb3e36ee76f262b7a838b518d4426d4da329c7" translate="yes" xml:space="preserve">
          <source>(like &lt;code&gt;COMBINING ACUTE ACCENT&lt;/code&gt;). This sequence of base character and modifiers is called a</source>
          <target state="translated">( &lt;code&gt;COMBINING ACUTE ACCENT&lt;/code&gt; 처럼 ). 이 기본 문자 및 수정 자의 시퀀스를</target>
        </trans-unit>
        <trans-unit id="8620bf49ecd95e38b6d7494e30b7d9014d4bad52" translate="yes" xml:space="preserve">
          <source>(like &lt;code&gt;LATIN CAPITAL LETTER A&lt;/code&gt; ) followed by one or more</source>
          <target state="translated">( &lt;code&gt;LATIN CAPITAL LETTER A&lt;/code&gt; 와 같은 ) 뒤에 하나 이상의</target>
        </trans-unit>
        <trans-unit id="684b38fe36448fe950b0ca06019115edb178737c" translate="yes" xml:space="preserve">
          <source>(like &lt;code&gt;LATIN CAPITAL LETTER A&lt;/code&gt;) followed by one or more</source>
          <target state="translated">( &lt;code&gt;LATIN CAPITAL LETTER A&lt;/code&gt; 와 같이 ) 뒤에 하나 이상의</target>
        </trans-unit>
        <trans-unit id="898558423b918aeed50b4db293c37dc4600aa4d3" translate="yes" xml:space="preserve">
          <source>(may be system dependent). If you want to force the creation of a new perl, it is recommended that you delete this</source>
          <target state="translated">(시스템에 따라 다를 수 있음). 새로운 펄을 만들려면 이것을 삭제하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="b135c873a61fbd2b70216d59897dae798e688cac" translate="yes" xml:space="preserve">
          <source>(minimum) width</source>
          <target state="translated">(최소) 폭</target>
        </trans-unit>
        <trans-unit id="fb68136270e91ed8ffdbfd39c681ea2d1e249f38" translate="yes" xml:space="preserve">
          <source>(nearly all modules) this has three side effects:</source>
          <target state="translated">(거의 모든 모듈) 여기에는 세 가지 부작용이 있습니다.</target>
        </trans-unit>
        <trans-unit id="394df79e888bb4bc8d5dd0e24df5f278d4cdc8b9" translate="yes" xml:space="preserve">
          <source>(no extension) give an argument &lt;code&gt;n:/bin/blah.&lt;/code&gt; (dot appended) to system().</source>
          <target state="translated">(확장자 없음) 인수 &lt;code&gt;n:/bin/blah.&lt;/code&gt; (점이 추가됨) system ().</target>
        </trans-unit>
        <trans-unit id="e0f8b79485e24e1aa85b5719818060e99b9fac5a" translate="yes" xml:space="preserve">
          <source>(non-super) languages that are probably acceptable to the user, to be used</source>
          <target state="translated">(슈퍼가 아닌) 사용자가 사용할 수있는 언어</target>
        </trans-unit>
        <trans-unit id="df56c4328df4065d33cb67c45603001892660f7c" translate="yes" xml:space="preserve">
          <source>(not locales). See the GNU &lt;code&gt;gettext&lt;/code&gt; library documentation for more information.</source>
          <target state="translated">(로케일이 아님). 자세한 내용은 GNU &lt;code&gt;gettext&lt;/code&gt; 라이브러리 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="ca133eb8cde4644a55bd2dd3514979460453ef7d" translate="yes" xml:space="preserve">
          <source>(not simply older ones) set the &lt;code&gt;UNINST&lt;/code&gt; variable.</source>
          <target state="translated">(오래된 것이 아니라) &lt;code&gt;UNINST&lt;/code&gt; 변수를 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="87ba0557f46520422b4ad12ed987b7a873c1f334" translate="yes" xml:space="preserve">
          <source>(not) +</source>
          <target state="translated">(아님) +</target>
        </trans-unit>
        <trans-unit id="516dc39365f26048e9a017e4305c1cd5470e6958" translate="yes" xml:space="preserve">
          <source>(note that the argument &lt;code&gt;-my_opts&lt;/code&gt; is taken care of by the &lt;code&gt;extproc&lt;/code&gt; line in your script, see &lt;a href=&quot;#extproc-on-the-first-line&quot;&gt;&quot;&lt;code&gt;extproc&lt;/code&gt; on the first line&quot;&lt;/a&gt;).</source>
          <target state="translated">(인수 &lt;code&gt;-my_opts&lt;/code&gt; 는 스크립트 의 &lt;code&gt;extproc&lt;/code&gt; 행에서 처리 됩니다. &lt;a href=&quot;#extproc-on-the-first-line&quot;&gt;&quot;첫 번째 행의 &lt;/a&gt; &lt;code&gt;extproc&lt;/code&gt; &quot; 참조 ).</target>
        </trans-unit>
        <trans-unit id="a87bac478adeaad45a131a7a1ff824736853050d" translate="yes" xml:space="preserve">
          <source>(note that the argument &lt;code&gt;-my_opts&lt;/code&gt; is taken care of by the &lt;code&gt;extproc&lt;/code&gt; line in your script, see &lt;a href=&quot;#extproc-on-the-first-line&quot;&gt;extproc on the first line&lt;/a&gt;).</source>
          <target state="translated">( &lt;code&gt;-my_opts&lt;/code&gt; 인수 는 스크립트 의 &lt;code&gt;extproc&lt;/code&gt; 행에 의해 처리 &lt;a href=&quot;#extproc-on-the-first-line&quot;&gt;됩니다. 첫 번째 행의 extproc&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="2252501faf83dd862f721d37d7fabacb6191045c" translate="yes" xml:space="preserve">
          <source>(note the capital 'O')?</source>
          <target state="translated">(수도 'O'에 주목)?</target>
        </trans-unit>
        <trans-unit id="2f31cea769a0a416e9dd648f32e14fc8c6b80912" translate="yes" xml:space="preserve">
          <source>(obsolete) supply object methods for directory handles</source>
          <target state="translated">(구식) 디렉터리 핸들에 대한 개체 메서드 제공</target>
        </trans-unit>
        <trans-unit id="7739136dc697141cd8d76585cab6736b910f012b" translate="yes" xml:space="preserve">
          <source>(or</source>
          <target state="translated">(or</target>
        </trans-unit>
        <trans-unit id="943a0a81a1832953a2e589fda6975dd0742c8224" translate="yes" xml:space="preserve">
          <source>(or a later version). Note that all these utilities are known to be available from LEO:</source>
          <target state="translated">(또는 이후 버전). 이러한 모든 유틸리티는 LEO에서 제공되는 것으로 알려져 있습니다.</target>
        </trans-unit>
        <trans-unit id="0be01a7b142b9329408575280612f9a80ba4041b" translate="yes" xml:space="preserve">
          <source>(or atomic subexpressions) are regular expressions, in the context of a larger regular expression, that function independently of the larger regular expression. That is, they consume as much or as little of the string as they wish without regard for the ability of the larger regexp to match. Independent subexpressions are represented by &lt;code&gt;(?&amp;gt;regexp)&lt;/code&gt; or (starting in 5.32, experimentally in 5.28) &lt;code&gt;(*atomic:regexp)&lt;/code&gt;. We can illustrate their behavior by first considering an ordinary regexp:</source>
          <target state="translated">(또는 원자 하위 표현식)은 더 큰 정규 표현식의 컨텍스트에서 더 큰 정규 표현식과 독립적으로 작동하는 정규 표현식입니다. 즉, 더 큰 정규 표현식이 일치하는지에 관계없이 원하는만큼 문자열을 많이 또는 적게 소비합니다. 독립 하위 표현식은 &lt;code&gt;(?&amp;gt;regexp)&lt;/code&gt; 또는 (5.32에서 시작, 5.28에서 실험적으로) &lt;code&gt;(*atomic:regexp)&lt;/code&gt; 로 표시 됩니다. 먼저 일반적인 정규식을 고려하여 동작을 설명 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c1d876dbf1a11aabf97fb7b5ced558dd7fc14007" translate="yes" xml:space="preserve">
          <source>(or current directory) and working back up to five levels of '..'.</source>
          <target state="translated">(또는 현재 디렉토리) 및 '..'의 최대 5 단계로 작업.</target>
        </trans-unit>
        <trans-unit id="5d789ea9ecbca64db40cc5cf855ac5aab3b99f9f" translate="yes" xml:space="preserve">
          <source>(or equivalent) to check for executable image, and</source>
          <target state="translated">실행 가능한 이미지를 확인하기 위해 (또는 이에 상응하는)</target>
        </trans-unit>
        <trans-unit id="8fad3115516a964cc9ebf7c5c7a5c31c4b8ee04f" translate="yes" xml:space="preserve">
          <source>(or filename) is stored the zip archive.</source>
          <target state="translated">(또는 파일 이름)은 zip 아카이브에 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="f682b3c18a9391cb4e366a7aa9b5a7cb465c2e8c" translate="yes" xml:space="preserve">
          <source>(or formerly</source>
          <target state="translated">(또는 이전</target>
        </trans-unit>
        <trans-unit id="10b8de91c04f0b369cf7eb571a6ee9c70e6c71ba" translate="yes" xml:space="preserve">
          <source>(or similar) must be executed to determine prerequisites.</source>
          <target state="translated">(또는 이와 유사한) 전제 조건을 결정하기 위해 실행되어야합니다.</target>
        </trans-unit>
        <trans-unit id="c13eec8ddce00beba6d30648385e210d2e5dbcd6" translate="yes" xml:space="preserve">
          <source>(or similar) must be executed when building this distribution, or whether it can be built, tested and installed solely from consulting its metadata file. The main reason to set this to a true value if that your module performs some dynamic configuration (asking questions, sensing the environment, etc.) as part of its build/install process.</source>
          <target state="translated">이 배포판을 빌드 할 때 또는 메타 데이터 파일을 참조하여 빌드, 테스트 및 설치할 수 있는지 여부에 관계없이 실행되어야합니다. 모듈이 빌드 / 설치 프로세스의 일부로 동적 구성 (질문, 환경 감지 등)을 수행하는 경우이 값을 참 값으로 설정하는 주된 이유입니다.</target>
        </trans-unit>
        <trans-unit id="d5020017a9c342ddf1d165a2f255f48cb8ec7e31" translate="yes" xml:space="preserve">
          <source>(or similar) must be executed when building this distribution, or whether it can be built, tested and installed solely from consulting its metadata file. The main reason to set this to a true value is that your module performs some dynamic configuration (asking questions, sensing the environment, etc.) as part of its build/install process.</source>
          <target state="translated">이 배포판을 빌드 할 때 또는 메타 데이터 파일을 참조하여 빌드, 테스트 및 설치할 수 있는지 여부에 관계없이 실행되어야합니다. 이 값을 true 값으로 설정하는 주된 이유는 모듈이 빌드 / 설치 프로세스의 일부로 동적 구성 (질문, 환경 감지 등)을 수행하기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="5391579085669783c7f6909d1b2de35a976a946e" translate="yes" xml:space="preserve">
          <source>(or similar) must be executed, or whether this module can be built, tested and installed solely from consulting its metadata file. The main reason to set this to a true value if that your module performs some dynamic configuration (asking questions, sensing the environment, etc.) as part of its build/install process.</source>
          <target state="translated">(또는 유사)를 실행하거나이 모듈을 메타 데이터 파일을 참조하여 구축, 테스트 및 설치할 수 있는지 여부를 확인해야합니다. 모듈이 빌드 / 설치 프로세스의 일부로 동적 구성 (질문, 환경 감지 등)을 수행하는 경우이 값을 참 값으로 설정하는 주된 이유입니다.</target>
        </trans-unit>
        <trans-unit id="d403fe550f70047da65adfbaaaa9a12d0ea25d65" translate="yes" xml:space="preserve">
          <source>(or something like that).</source>
          <target state="translated">(또는 그런 것).</target>
        </trans-unit>
        <trans-unit id="b78679543a880190c17b815dfea3958a0c6bb773" translate="yes" xml:space="preserve">
          <source>(or the second if the first character is a caret) character of a bracketed character class, it does not denote the end of the class (as you cannot have an empty class) and is considered part of the set of characters that can be matched without escaping.</source>
          <target state="translated">(또는 첫 번째 문자가 캐럿 인 경우 두 번째 문자) 대괄호 문자 클래스의 문자는 클래스의 끝을 나타내지 않으며 (빈 클래스를 가질 수 없으므로) 일치 할 수있는 문자 세트의 일부로 간주됩니다. 탈출하지 않고.</target>
        </trans-unit>
        <trans-unit id="d8c8bb7d961236b850f553d2b4e51bb846fabeed" translate="yes" xml:space="preserve">
          <source>(or the value is discarded if</source>
          <target state="translated">(또는 값은</target>
        </trans-unit>
        <trans-unit id="a47590de5dce94882f3eb07aab9c1f1f12b27039" translate="yes" xml:space="preserve">
          <source>(or you could just use &lt;code&gt;VMS::Stdio::remove&lt;/code&gt; , if you've installed the VMS::Stdio extension distributed with Perl). If &lt;code&gt;&lt;a href=&quot;functions/unlink&quot;&gt;unlink&lt;/a&gt;&lt;/code&gt; has to change the file protection to delete the file, and you interrupt it in midstream, the file may be left intact, but with a changed ACL allowing you delete access.</source>
          <target state="translated">(또는 Perl과 함께 배포 된 VMS :: Stdio 확장을 설치 한 경우 &lt;code&gt;VMS::Stdio::remove&lt;/code&gt; 사용할 수 있습니다 ). 링크를 &lt;code&gt;&lt;a href=&quot;functions/unlink&quot;&gt;unlink&lt;/a&gt;&lt;/code&gt; 하여 파일을 삭제하기 위해 파일 보호를 변경해야하고 파일을 중간 스트림에서 중단하면 파일이 그대로 남아 있지만 ACL을 변경하여 액세스를 삭제할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f28d131552eca4b6c0fe1f0e1d6122eb3b460e17" translate="yes" xml:space="preserve">
          <source>(or you could just use &lt;code&gt;VMS::Stdio::remove&lt;/code&gt;, if you've installed the VMS::Stdio extension distributed with Perl). If &lt;code&gt;unlink&lt;/code&gt; has to change the file protection to delete the file, and you interrupt it in midstream, the file may be left intact, but with a changed ACL allowing you delete access.</source>
          <target state="translated">(또는 Perl과 함께 배포 된 VMS :: Stdio 확장을 설치 한 경우 &lt;code&gt;VMS::Stdio::remove&lt;/code&gt; 사용할 수 있습니다 ). 링크 &lt;code&gt;unlink&lt;/code&gt; 가 파일을 삭제하기 위해 파일 보호를 변경해야하고 중간 스트림에서 중단하는 경우 파일은 그대로 유지 될 수 있지만 액세스를 삭제할 수 있도록 ACL이 변경됩니다.</target>
        </trans-unit>
        <trans-unit id="5cc4703905ea087120e18389a3b56b4989f1d0ce" translate="yes" xml:space="preserve">
          <source>(or your operating system's equivalent) could not be opened.</source>
          <target state="translated">(또는 운영 체제와 동등한 기능)을 열 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="d217df85ffcaff01b34839a3630a0f8777e5129a" translate="yes" xml:space="preserve">
          <source>(or your platform's equivalent procedure) to verify that &lt;b&gt;perl&lt;/b&gt; and its libraries have been installed correctly. A correct installation is verified by output that looks like:</source>
          <target state="translated">(또는 플랫폼의 동등한 절차)를 사용하여 &lt;b&gt;perl&lt;/b&gt; 및 해당 라이브러리가 올바르게 설치되었는지 확인하십시오. 다음과 같은 출력으로 올바른 설치가 확인됩니다.</target>
        </trans-unit>
        <trans-unit id="17fc4954c0e2adfe4c1931803c04d50628b02fa1" translate="yes" xml:space="preserve">
          <source>(or, you don't have to do this yourself because this example is predefined)</source>
          <target state="translated">(또는이 예제는 사전 정의되어 있으므로 직접 할 필요는 없습니다)</target>
        </trans-unit>
        <trans-unit id="0f663554f9cc36dcf3f1877c497fb678b76cc2ed" translate="yes" xml:space="preserve">
          <source>(override) Because of the difficulty concatenating VMS filepaths we must pre-expand the DEST* variables.</source>
          <target state="translated">(재정의) VMS 파일 경로를 연결하는 데 어려움이 있으므로 DEST * 변수를 미리 확장해야합니다.</target>
        </trans-unit>
        <trans-unit id="3e64e5c52f4cbf325d544d16b24131a72496547d" translate="yes" xml:space="preserve">
          <source>(part of the standard perl distribution), which never really got finished. If you find it somewhere,</source>
          <target state="translated">(표준 펄 배포판의 일부), 실제로 끝나지 않았습니다. 어딘가에 있으면</target>
        </trans-unit>
        <trans-unit id="922530c6dd5e24c25c5c1c085800263ea1126411" translate="yes" xml:space="preserve">
          <source>(partly contributed by Aaron Sherman)</source>
          <target state="translated">(아론 셔먼이 일부 기고)</target>
        </trans-unit>
        <trans-unit id="cd3adb25404edd24eec9d649c8bcb704ae0342ed" translate="yes" xml:space="preserve">
          <source>(portions of this answer contributed by Anno Siegel and brian d foy)</source>
          <target state="translated">(이 답변의 일부는 Anno Siegel과 brian d foy가 제공했습니다)</target>
        </trans-unit>
        <trans-unit id="3b2cc61f70b62caaa55962a8021228deb590a600" translate="yes" xml:space="preserve">
          <source>(rather than filename) based input and output. These are safe on the assumption that only pre-existing filehandles are available for use. Usually, to create new filehandles other ops such as open would need to be enabled, if you don't take into account the magical open of ARGV.</source>
          <target state="translated">(파일 이름 대신) 기반 입력 및 출력. 기존 파일 핸들 만 사용할 수 있다고 가정하면 안전합니다. 일반적으로 새 파일 핸들을 만들려면 ARGV의 마법적인 개방을 고려하지 않은 경우 open과 같은 다른 op를 활성화해야합니다.</target>
        </trans-unit>
        <trans-unit id="c4d5187232fa1c2393eaa02e491a4d557a5f182e" translate="yes" xml:space="preserve">
          <source>(requires, recommends, suggests, conflicts)</source>
          <target state="translated">(요구, 추천, 제안, 갈등)</target>
        </trans-unit>
        <trans-unit id="2848ad6e5d5a5174fbf33c0f002b92ca3e779b91" translate="yes" xml:space="preserve">
          <source>(rho, theta, pi)</source>
          <target state="translated">(rho, theta, pi)</target>
        </trans-unit>
        <trans-unit id="301eec20fcb8d08c4b477b134f84eea526c7c5a2" translate="yes" xml:space="preserve">
          <source>(rho, theta, z)</source>
          <target state="translated">(rho, theta, z)</target>
        </trans-unit>
        <trans-unit id="9feb62aa545ce8b013f06110c13fc0f3f902cb3f" translate="yes" xml:space="preserve">
          <source>(sc=Hrkt)</source>
          <target state="translated">(sc=Hrkt)</target>
        </trans-unit>
        <trans-unit id="f13ab2d0c2655750c1afca21b1b6d480ed898d5c" translate="yes" xml:space="preserve">
          <source>(scx=Hrkt)</source>
          <target state="translated">(scx=Hrkt)</target>
        </trans-unit>
        <trans-unit id="af691ce86674610a40b84683145b5d169360d61f" translate="yes" xml:space="preserve">
          <source>(see &lt;a href=&quot;#perl_.exe&quot;&gt;&quot;&lt;i&gt;perl_.exe&lt;/i&gt;&quot;&lt;/a&gt;) by</source>
          <target state="translated">( &lt;a href=&quot;#perl_.exe&quot;&gt;&quot; &lt;i&gt;perl_.exe&lt;/i&gt; &quot;&lt;/a&gt; 참조 )</target>
        </trans-unit>
        <trans-unit id="6f1730b3336db772520f06bb063d6d6eb975d7d1" translate="yes" xml:space="preserve">
          <source>(see &lt;a href=&quot;#perl_.exe&quot;&gt;perl_.exe&lt;/a&gt;) by</source>
          <target state="translated">에 의해 ( &lt;a href=&quot;#perl_.exe&quot;&gt;perl_.exe&lt;/a&gt; 참조 )</target>
        </trans-unit>
        <trans-unit id="c48f533c48ae737a843e0dd6b406a45fbb539ccb" translate="yes" xml:space="preserve">
          <source>(see &lt;a href=&quot;#perl__.exe&quot;&gt;&quot;perl__.exe&quot;&lt;/a&gt;) if you want to use PM code in your application (as Perl/Tk or OpenGL Perl modules do) without having a text-mode window present.</source>
          <target state="translated">( Perl / Tk 또는 OpenGL Perl 모듈처럼) 응용 프로그램에서 텍스트 모드 창없이 PM 코드를 사용하려면 &lt;a href=&quot;#perl__.exe&quot;&gt;&quot;perl __. exe&quot;를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="57d66dd0e5298b5e96ec3ad469013acc44ce6276" translate="yes" xml:space="preserve">
          <source>(see &lt;a href=&quot;#perl__.exe&quot;&gt;perl__.exe&lt;/a&gt;) if you want to use PM code in your application (as Perl/Tk or OpenGL Perl modules do) without having a text-mode window present.</source>
          <target state="translated">텍스트 모드 창없이 애플리케이션에서 PM 코드를 사용하려면 ( &lt;a href=&quot;#perl__.exe&quot;&gt;perl __. exe&lt;/a&gt; 참조 ) (Perl / Tk 또는 OpenGL Perl 모듈처럼)</target>
        </trans-unit>
        <trans-unit id="13897f93e1b34b9d187d47d10d0d7a7feddc3e26" translate="yes" xml:space="preserve">
          <source>(see &lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;) are for. (Avoid exec() (see &lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;) unless you know what you do).</source>
          <target state="translated">( &lt;a href=&quot;functions/open&quot;&gt;열기&lt;/a&gt; 참조 )입니다. (피 간부는 () (참조 &lt;a href=&quot;functions/exec&quot;&gt;간부&lt;/a&gt; 당신은 당신이 무엇을 알고하지 않는 한)).</target>
        </trans-unit>
        <trans-unit id="c6e5e1fe0ec06a97edec0d1b49eba2177a034033" translate="yes" xml:space="preserve">
          <source>(see &lt;a href=&quot;perlfunc#open&quot;&gt;&quot;open&quot; in perlfunc&lt;/a&gt;) are for. (Avoid exec() (see &lt;a href=&quot;perlfunc#exec&quot;&gt;&quot;exec&quot; in perlfunc&lt;/a&gt;) unless you know what you do).</source>
          <target state="translated">( &lt;a href=&quot;perlfunc#open&quot;&gt;perlfunc의 &quot;open&quot;&lt;/a&gt; 참조 ) ( 당신이 무엇을하는지 알지 못한다면 exec ()를 피하십시오 ( &lt;a href=&quot;perlfunc#exec&quot;&gt;perlfunc의 &quot;exec&quot;&lt;/a&gt; 참조 ).)</target>
        </trans-unit>
        <trans-unit id="166724a371ebce21c3789346fabcb64d75a9043d" translate="yes" xml:space="preserve">
          <source>(see &lt;a href=&quot;perlvms&quot;&gt;perlvms&lt;/a&gt;) so that environ is not searched.</source>
          <target state="translated">environ이 검색되지 않도록 ( &lt;a href=&quot;perlvms&quot;&gt;perlvms&lt;/a&gt; 참조 )</target>
        </trans-unit>
        <trans-unit id="54b36cc8bf5ee45ddbf22c302f0ff8899587445f" translate="yes" xml:space="preserve">
          <source>(see &lt;a href=&quot;perlvms&quot;&gt;perlvms&lt;/a&gt;) so that the environ array isn't the target of the change to %ENV which produced the warning.</source>
          <target state="translated">( &lt;a href=&quot;perlvms&quot;&gt;perlvms&lt;/a&gt; 참조 ) 환경 배열이 경고를 생성 한 % ENV 변경 대상이되지 않도록하십시오.</target>
        </trans-unit>
        <trans-unit id="fdb75cfc3f651d35ec9dce7ef8ff84370b4689f6" translate="yes" xml:space="preserve">
          <source>(see &lt;a href=&quot;warnings&quot;&gt;warnings&lt;/a&gt;). In this mode of operation, Perl will raise the warning for all matches against a non-Unicode code point (not just the arguable ones), and it skips the optimizations that might cause the warning to not be output. (It currently still won't warn if the match isn't even attempted, like in the &lt;code&gt;&quot;foobar&quot;&lt;/code&gt; example above.)</source>
          <target state="translated">( &lt;a href=&quot;warnings&quot;&gt;경고&lt;/a&gt; 참조 ). 이 작동 모드에서 Perl은 유니 코드가 아닌 코드 포인트 (논쟁 가능한 포인트가 아닌)에 대해 모든 일치에 대해 경고를 발생시키고 경고가 출력되지 않을 수있는 최적화를 건너 뜁니다. ( 위 의 &lt;code&gt;&quot;foobar&quot;&lt;/code&gt; 예제 에서와 같이 일치가 시도되지 않더라도 현재 경고는 표시되지 않습니다 .)</target>
        </trans-unit>
        <trans-unit id="ae2592aa43fa906f33435791e9b2cf177d7b8878" translate="yes" xml:space="preserve">
          <source>(see Annex 8, UAX #15; and</source>
          <target state="translated">(부록 8, UAX # 15 참조)</target>
        </trans-unit>
        <trans-unit id="bfe137530e41031a5af4ace868c82fe0baa9a25b" translate="yes" xml:space="preserve">
          <source>(see below) and/or</source>
          <target state="translated">(아래 참조) 및 / 또는</target>
        </trans-unit>
        <trans-unit id="2d2a37102316b6b5d1b884637aaaac148e2b754c" translate="yes" xml:space="preserve">
          <source>(see, it's even smart enough to fix my obvious date bug)</source>
          <target state="translated">(내 명백한 날짜 버그를 수정하기에 충분히 똑똑합니다)</target>
        </trans-unit>
        <trans-unit id="219b75b05739b79a0aeb3aa178076f50dcc11a3c" translate="yes" xml:space="preserve">
          <source>(short for Posix Space) Starting in 5.18, this is identical in all its forms to the corresponding &lt;code&gt;isSPACE()&lt;/code&gt; macros. The locale forms of this macro are identical to their corresponding &lt;code&gt;isSPACE()&lt;/code&gt; forms in all Perl releases. In releases prior to 5.18, the non-locale forms differ from their &lt;code&gt;isSPACE()&lt;/code&gt; forms only in that the &lt;code&gt;isSPACE()&lt;/code&gt; forms don't match a Vertical Tab, and the &lt;code&gt;isPSXSPC()&lt;/code&gt; forms do. Otherwise they are identical. Thus this macro is analogous to what &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m/[[:space:]]/&lt;/a&gt;&lt;/code&gt; matches in a regular expression. See the &lt;a href=&quot;#Character-classification&quot;&gt;top of this section&lt;/a&gt; for an explanation of variants &lt;code&gt;isPSXSPC_A&lt;/code&gt; , &lt;code&gt;isPSXSPC_L1&lt;/code&gt; , &lt;code&gt;isPSXSPC_uni&lt;/code&gt; , &lt;code&gt;isPSXSPC_utf8&lt;/code&gt; , &lt;code&gt;isPSXSPC_LC&lt;/code&gt; , &lt;code&gt;isPSXSPC_LC_uvchr&lt;/code&gt; , and &lt;code&gt;isPSXSPC_LC_utf8&lt;/code&gt; .</source>
          <target state="translated">(Posix Space의 약자) 5.18부터는 모든 형태에서 해당 &lt;code&gt;isSPACE()&lt;/code&gt; 매크로와 동일합니다. 이 매크로의 로케일 형식은 모든 Perl 릴리스 의 해당 &lt;code&gt;isSPACE()&lt;/code&gt; 형식 과 동일 합니다. 5.18 이전 버전에서는, 비 로케일 형태는 다를 &lt;code&gt;isSPACE()&lt;/code&gt; 에만 점에서 형태 &lt;code&gt;isSPACE()&lt;/code&gt; 형태가 수직 탭과 일치하지 않으며, &lt;code&gt;isPSXSPC()&lt;/code&gt; 형태 않습니다. 그렇지 않으면 동일합니다. 따라서이 매크로는 정규식에서 &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m/[[:space:]]/&lt;/a&gt;&lt;/code&gt; 와 일치하는 것과 유사합니다 . 참고 항목 &lt;a href=&quot;#Character-classification&quot;&gt;이 섹션의 상단&lt;/a&gt; 변종에 대한 설명 &lt;code&gt;isPSXSPC_A&lt;/code&gt; , &lt;code&gt;isPSXSPC_L1&lt;/code&gt; , &lt;code&gt;isPSXSPC_uni&lt;/code&gt; , &lt;code&gt;isPSXSPC_utf8&lt;/code&gt; , &lt;code&gt;isPSXSPC_LC&lt;/code&gt; , &lt;code&gt;isPSXSPC_LC_uvchr&lt;/code&gt; 및 &lt;code&gt;isPSXSPC_LC_utf8&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="960c415aa0b49a8eabe255141a5ba8c101a20ea4" translate="yes" xml:space="preserve">
          <source>(short for Posix Space) Starting in 5.18, this is identical in all its forms to the corresponding &lt;code&gt;isSPACE()&lt;/code&gt; macros. The locale forms of this macro are identical to their corresponding &lt;code&gt;isSPACE()&lt;/code&gt; forms in all Perl releases. In releases prior to 5.18, the non-locale forms differ from their &lt;code&gt;isSPACE()&lt;/code&gt; forms only in that the &lt;code&gt;isSPACE()&lt;/code&gt; forms don't match a Vertical Tab, and the &lt;code&gt;isPSXSPC()&lt;/code&gt; forms do. Otherwise they are identical. Thus this macro is analogous to what &lt;code&gt;m/[[:space:]]/&lt;/code&gt; matches in a regular expression. See the &lt;a href=&quot;#Character-classification&quot;&gt;top of this section&lt;/a&gt; for an explanation of variants &lt;code&gt;isPSXSPC_A&lt;/code&gt;, &lt;code&gt;isPSXSPC_L1&lt;/code&gt;, &lt;code&gt;isPSXSPC_uvchr&lt;/code&gt;, &lt;code&gt;isPSXSPC_utf8&lt;/code&gt;, &lt;code&gt;isPSXSPC_utf8_safe&lt;/code&gt;, &lt;code&gt;isPSXSPC_LC&lt;/code&gt;, &lt;code&gt;isPSXSPC_LC_uvchr&lt;/code&gt;, &lt;code&gt;isPSXSPC_LC_utf8&lt;/code&gt;, and &lt;code&gt;isPSXSPC_LC_utf8_safe&lt;/code&gt;.</source>
          <target state="translated">(Posix Space의 약자) 5.18부터는 모든 형태가 해당 &lt;code&gt;isSPACE()&lt;/code&gt; 매크로와 동일합니다. 이 매크로의 로케일 형식은 모든 Perl 릴리스 의 해당 &lt;code&gt;isSPACE()&lt;/code&gt; 형식 과 동일 합니다. 5.18 이전 버전에서는, 비 로케일 형태는 다를 &lt;code&gt;isSPACE()&lt;/code&gt; 에만 점에서 형태 &lt;code&gt;isSPACE()&lt;/code&gt; 형태가 수직 탭과 일치하지 않으며, &lt;code&gt;isPSXSPC()&lt;/code&gt; 형태 않습니다. 그렇지 않으면 동일합니다. 따라서이 매크로는 &lt;code&gt;m/[[:space:]]/&lt;/code&gt; 가 정규 표현식에서 일치하는 것과 유사합니다 . 참고 항목 &lt;a href=&quot;#Character-classification&quot;&gt;이 섹션의 상단&lt;/a&gt; 변종에 대한 설명 &lt;code&gt;isPSXSPC_A&lt;/code&gt; , &lt;code&gt;isPSXSPC_L1&lt;/code&gt; , &lt;code&gt;isPSXSPC_uvchr&lt;/code&gt; , &lt;code&gt;isPSXSPC_utf8&lt;/code&gt; , &lt;code&gt;isPSXSPC_utf8_safe&lt;/code&gt; , &lt;code&gt;isPSXSPC_LC&lt;/code&gt; , &lt;code&gt;isPSXSPC_LC_uvchr&lt;/code&gt; , &lt;code&gt;isPSXSPC_LC_utf8&lt;/code&gt; 및 &lt;code&gt;isPSXSPC_LC_utf8_safe&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4bd5a16e31ac15e68b14071791ee2945208fa3f4" translate="yes" xml:space="preserve">
          <source>(so &lt;code&gt;!foo&lt;/code&gt; would match anything</source>
          <target state="translated">(그래서 &lt;code&gt;!foo&lt;/code&gt; 는 무엇이든 일치합니다.</target>
        </trans-unit>
        <trans-unit id="cdb3187d740c81b42e6c70423b76a9971d547af9" translate="yes" xml:space="preserve">
          <source>(solidus; &lt;code&gt;U+002F&lt;/code&gt;) characters to reduce the risk of XSS (cross site scripting) that may be caused by &lt;code&gt;&amp;lt;/script&amp;gt;&lt;/code&gt; in a JSON text, with the cost of bloating the size of JSON texts.</source>
          <target state="translated">(solidus; &lt;code&gt;U+002F&lt;/code&gt; ) 문자를 사용하여 JSON 텍스트의 &lt;code&gt;&amp;lt;/script&amp;gt;&lt;/code&gt; 로 인해 발생할 수있는 XSS (교차 사이트 스크립팅)의 위험을 줄이고 JSON 텍스트의 크기를 늘리는 비용을 줄입니다.</target>
        </trans-unit>
        <trans-unit id="4c78e0c73b6b30ea430253f9fd658c00503bafdb" translate="yes" xml:space="preserve">
          <source>(that basically means POSIX fopen() style mode strings plus an optional number to indicate the compression level).</source>
          <target state="translated">(기본적으로 POSIX fopen () 스타일 모드 문자열과 압축 수준을 나타내는 선택적 숫자를 의미합니다).</target>
        </trans-unit>
        <trans-unit id="4b9770fcc7679e51bf57c83553ccf77d479a096c" translate="yes" xml:space="preserve">
          <source>(that is, the loop is broken) when Perl detects that a repeated expression matched a zero-length substring. Thus</source>
          <target state="translated">Perl이 반복 된 표현식이 길이가 0 인 하위 문자열과 일치 함을 감지하면 (즉, 루프가 끊어짐) 그러므로</target>
        </trans-unit>
        <trans-unit id="2c2b3767cd67fda7e4ff13d64bc55c53b4c03d5d" translate="yes" xml:space="preserve">
          <source>(that's not a misspelling!) has some good tips on optimization, too. Advice on benchmarking boils down to: benchmark and profile to make sure you're optimizing the right part, look for better algorithms instead of microtuning your code, and when all else fails consider just buying faster hardware. You will probably want to read the answer to the earlier question &quot;How do I profile my Perl programs?&quot; if you haven't done so already.</source>
          <target state="translated">(맞춤법이 아닙니다!)에는 최적화에 대한 유용한 팁도 있습니다. 벤치마킹에 대한 조언은 벤치마킹 및 프로파일로 요약하여 올바른 부분을 최적화하고 코드를 미세 조정하는 대신 더 나은 알고리즘을 찾으십시오. &quot;Perl 프로그램을 어떻게 프로파일 링합니까?&quot;라는 이전 질문에 대한 답을 원할 것입니다. 아직 그렇게하지 않았다면</target>
        </trans-unit>
        <trans-unit id="afd3f53e28b683fb99368ef0532ecf0f00244306" translate="yes" xml:space="preserve">
          <source>(the Camel, 3rd edition) or elsewhere, &lt;code&gt;:raw&lt;/code&gt; is</source>
          <target state="translated">(Camel, 3 판) 또는 다른 곳에서 &lt;code&gt;:raw&lt;/code&gt; is</target>
        </trans-unit>
        <trans-unit id="c0571c4fd0703d94ff1bd6301e1d544df5402954" translate="yes" xml:space="preserve">
          <source>(the bug, fixed in Perl 5.14, is described in &lt;a href=&quot;#BUGS&quot;&gt;&quot;BUGS&quot;&lt;/a&gt;). One can use this new interface as</source>
          <target state="translated">(Perl 5.14에서 수정 된 버그는 &lt;a href=&quot;#BUGS&quot;&gt;&quot;버그&quot;에&lt;/a&gt; 설명되어 있습니다 ). 이 새로운 인터페이스를 다음과 같이 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="47fb842f1ec30dc0c1028b06b28202730238d4d6" translate="yes" xml:space="preserve">
          <source>(the bug, fixed in Perl 5.14, is described in &lt;a href=&quot;#BUGS&quot;&gt;BUGS&lt;/a&gt;). One can use this new interface as</source>
          <target state="translated">Perl 5.14에서 수정 된 버그는 &lt;a href=&quot;#BUGS&quot;&gt;BUGS에&lt;/a&gt; 설명되어 있습니다. 이 새로운 인터페이스를</target>
        </trans-unit>
        <trans-unit id="d1c731c58fb8625c1995a9c0d6a37456f30eb3dd" translate="yes" xml:space="preserve">
          <source>(the natural logarithm base) to the power of EXPR. If EXPR is omitted, gives &lt;code&gt;&lt;a href=&quot;exp&quot;&gt;exp($_)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">EXPR의 거듭 제곱에 EXPR이 생략되면 &lt;code&gt;&lt;a href=&quot;exp&quot;&gt;exp($_)&lt;/a&gt;&lt;/code&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="9ca0b781f69e1f8267342418d798ec9abc7f7b5c" translate="yes" xml:space="preserve">
          <source>(the natural logarithm base) to the power of EXPR. If EXPR is omitted, gives &lt;code&gt;&lt;a href=&quot;functions/exp&quot;&gt;exp($_)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">EXPR의 거듭 제곱에 EXPR이 생략되면 &lt;code&gt;&lt;a href=&quot;functions/exp&quot;&gt;exp($_)&lt;/a&gt;&lt;/code&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="4a454988522cc6a4767026309bb67dafb4d33a38" translate="yes" xml:space="preserve">
          <source>(the natural logarithm base) to the power of EXPR. If EXPR is omitted, gives &lt;code&gt;exp($_)&lt;/code&gt;.</source>
          <target state="translated">(자연 로그 밑) EXPR의 거듭 제곱으로. EXPR이 생략되면 &lt;code&gt;exp($_)&lt;/code&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="e56b737030fe6f76e87a3edfc44265d91450bf34" translate="yes" xml:space="preserve">
          <source>(this may not work on some bizarre filesystems). One should conscientiously choose between the</source>
          <target state="translated">(일부 기괴한 파일 시스템에서는 작동하지 않을 수 있습니다). 양심적으로 선택해야합니다</target>
        </trans-unit>
        <trans-unit id="db0f2bd8ef346de7a033eeae78d90dc10831fa46" translate="yes" xml:space="preserve">
          <source>(to build miniperlmain.c). So under normal circumstances you won't have to deal with this module directly.</source>
          <target state="translated">(miniperlmain.c 빌드). 따라서 정상적인 상황에서는이 모듈을 직접 다룰 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="97ab80c9e1fe35bb7e8323fbb0d7feb27b6cbb77" translate="yes" xml:space="preserve">
          <source>(treat these hex digits as line noise). After this is fixed the build should finish without a lot of fuss.</source>
          <target state="translated">(이 16 진수를 라인 노이즈로 취급하십시오). 이것이 수정 된 후에는 많은 소란없이 빌드가 완료되어야합니다.</target>
        </trans-unit>
        <trans-unit id="5bbd0e9e8bb3970326f0ae59b614ac2f1aebcbf6" translate="yes" xml:space="preserve">
          <source>(true when evaluated inside of recursion or eval). Additionally the &lt;code&gt;&quot;R&quot;&lt;/code&gt; may be followed by a number, (which will be true when evaluated when recursing inside of the appropriate group), or by &lt;code&gt;&amp;amp;&lt;i&gt;NAME&lt;/i&gt;&lt;/code&gt;, in which case it will be true only when evaluated during recursion in the named group.</source>
          <target state="translated">(재귀 또는 평가 내부에서 평가할 때 참). 또한 &lt;code&gt;&quot;R&quot;&lt;/code&gt; 뒤에 숫자 (적절한 그룹 내 에서 반복 될 때 평가 될 때 참이 됨) 또는 &lt;code&gt;&amp;amp;&lt;i&gt;NAME&lt;/i&gt;&lt;/code&gt; 이 올 수 있습니다.이 경우 명명 된 그룹에서 재귀 중에 평가 될 때만 참이됩니다.</target>
        </trans-unit>
        <trans-unit id="1d7a9fe8570b8bcea8b9fe9361ea9bf6600d2508" translate="yes" xml:space="preserve">
          <source>(unless a</source>
          <target state="translated">(가 아니면</target>
        </trans-unit>
        <trans-unit id="4ec7a0d80a1ccd184b27056d454ee1153e6b5715" translate="yes" xml:space="preserve">
          <source>(used only by</source>
          <target state="translated">(만 사용</target>
        </trans-unit>
        <trans-unit id="ac5be747962c1aeaac7e7c81736092a7bc08bb8b" translate="yes" xml:space="preserve">
          <source>(user + system time) spent by the process since the first call to clock() (the definition is &lt;b&gt;not&lt;/b&gt; &quot;since the start of the process&quot;, though if you are lucky these times may be quite close to each other, depending on the system). What this means is that you probably need to store the result of your first call to clock(), and subtract that value from the following results of clock().</source>
          <target state="translated">(사용자 + 시스템 시간) clock ()에 대한 첫 번째 호출 이후 프로세스가 소비 한 것입니다 (정의는 &quot;프로세스 시작 이후&quot; 가 &lt;b&gt;아님)&lt;/b&gt; . 체계). 이것이 의미하는 것은 아마도 clock ()에 대한 첫 번째 호출 결과를 저장하고 다음 clock () 결과에서 해당 값을 빼야한다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="88e896a405e3f46934bf9370e95fa7933a886563" translate="yes" xml:space="preserve">
          <source>(using &lt;code&gt;Z_FULL_FLUSH&lt;/code&gt; ).</source>
          <target state="translated">( &lt;code&gt;Z_FULL_FLUSH&lt;/code&gt; 사용 ).</target>
        </trans-unit>
        <trans-unit id="a7541cab2a60860593c1a8ff9554f037ebc3c6c3" translate="yes" xml:space="preserve">
          <source>(using &lt;code&gt;Z_FULL_FLUSH&lt;/code&gt;).</source>
          <target state="translated">( &lt;code&gt;Z_FULL_FLUSH&lt;/code&gt; 사용 ).</target>
        </trans-unit>
        <trans-unit id="02603cd1eae933c0c785a3f79537a20ecf4da31e" translate="yes" xml:space="preserve">
          <source>(where</source>
          <target state="translated">(where</target>
        </trans-unit>
        <trans-unit id="eb610507830351fb8e108f368c849e043989f99c" translate="yes" xml:space="preserve">
          <source>(whether an htmlname, or a number in any base) must consist only of alphanumeric characters -- that is,</source>
          <target state="translated">(htmlname이든 기본 숫자 든) 영숫자로만 구성해야합니다. 즉,</target>
        </trans-unit>
        <trans-unit id="f4cc7c250419a5d866584f91196b41206d58a2e6" translate="yes" xml:space="preserve">
          <source>(which depend on the process)</source>
          <target state="translated">(프로세스에 따라 다름)</target>
        </trans-unit>
        <trans-unit id="a565a6a28b6032770c35f345aa4e5afd3ef5d6b8" translate="yes" xml:space="preserve">
          <source>(which do nothing, and return zero and -1, respectively) or for certain methods you may assume a default behaviour by using a NULL method. The Open method looks for help in the 'parent' layer. The following table summarizes the behaviour:</source>
          <target state="translated">(아무것도하지 않고 각각 0과 -1을 반환합니다) 또는 특정 메소드의 경우 NULL 메소드를 사용하여 기본 동작을 가정 할 수 있습니다. Open 메서드는 '부모'레이어에서 도움을 찾습니다. 다음 표는 동작을 요약 한 것입니다.</target>
        </trans-unit>
        <trans-unit id="d1bfbda3f08bba5e0a64d2c55993b9b59a747e61" translate="yes" xml:space="preserve">
          <source>(which finds the range of code points in the block using &lt;code&gt;prop_invlist&lt;/code&gt; , gets the lower end of the range (0th element) and then looks up the old name for its block using &lt;code&gt;charblock&lt;/code&gt; ).</source>
          <target state="translated">( &lt;code&gt;prop_invlist&lt;/code&gt; 를 사용하여 블록에서 코드 포인트의 범위를 찾고 범위의 맨 아래 (0 번째 요소)를 가져온 다음 &lt;code&gt;charblock&lt;/code&gt; 을 사용하여 해당 블록의 이전 이름을 찾습니다 ).</target>
        </trans-unit>
        <trans-unit id="8f6568a2b111b0c018d50940c31a36bda310d719" translate="yes" xml:space="preserve">
          <source>(which finds the range of code points in the block using &lt;code&gt;prop_invlist&lt;/code&gt;, gets the lower end of the range (0th element) and then looks up the old name for its block using &lt;code&gt;charblock&lt;/code&gt;).</source>
          <target state="translated">( &lt;code&gt;prop_invlist&lt;/code&gt; 를 사용하여 블록에서 코드 포인트 범위를 찾고 범위의 하단 (0 번째 요소)을 가져온 다음 &lt;code&gt;charblock&lt;/code&gt; 을 사용하여 해당 블록의 이전 이름을 찾습니다 .)</target>
        </trans-unit>
        <trans-unit id="ae14177069c91a23afccf755b4c6a1a6ba5baf27" translate="yes" xml:space="preserve">
          <source>(which is likely to produce a warning like this, which can be ignored:</source>
          <target state="translated">(다음과 같은 경고를 생성 할 가능성이 있으며 무시할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2bd9e615b04879bf500ca0444285c7b5f58ebaef" translate="yes" xml:space="preserve">
          <source>(which is part of the</source>
          <target state="translated">(이것은</target>
        </trans-unit>
        <trans-unit id="11e91a933773803dea4f7027fc85914141f0b47a" translate="yes" xml:space="preserve">
          <source>(which is used instead)</source>
          <target state="translated">(대신 사용됨)</target>
        </trans-unit>
        <trans-unit id="ae660a79b86b74eda7c896ee0e2ecc6cf658a4be" translate="yes" xml:space="preserve">
          <source>(which is valid if a group with the given name matched);</source>
          <target state="translated">(주어진 이름을 가진 그룹이 일치하면 유효 함);</target>
        </trans-unit>
        <trans-unit id="35afe972b2f8e533542c4fa6b31748bddbb4b04b" translate="yes" xml:space="preserve">
          <source>(which is valid if the corresponding pair of parentheses matched);</source>
          <target state="translated">(해당 괄호 쌍이 일치하면 유효 함);</target>
        </trans-unit>
        <trans-unit id="a6b9b21d617162cc10b61d0e599ca09bfc3a8860" translate="yes" xml:space="preserve">
          <source>(with a handful of exceptions). This is an unfortunate backwards compatibility feature and its use is &lt;b&gt;strongly &lt;a href=&quot;perlpolicy#discouraged&quot;&gt;discouraged&lt;/a&gt;&lt;/b&gt;. You should either prevent the exporting (by saying &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; POSIX ();&lt;/code&gt; , as usual) and then use fully qualified names (e.g. &lt;code&gt;POSIX::SEEK_END&lt;/code&gt; ), or give an explicit import list. If you do neither and opt for the default (as in &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; POSIX;&lt;/code&gt; ), you will import</source>
          <target state="translated">(소수의 예외가 있음). 이것은 불행한 이전 버전과의 호환성 기능이며, 그것의 사용이되어 &lt;b&gt;강하게 &lt;a href=&quot;perlpolicy#discouraged&quot;&gt;낙담&lt;/a&gt;&lt;/b&gt; . (말함으로써 당신도 수출 방지해야 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; POSIX ();&lt;/code&gt; 평소와 같이) 다음 정규화 된 이름 (예를 들어, 사용 &lt;code&gt;POSIX::SEEK_END&lt;/code&gt; ) 또는 명시 적 수입 목록을 제공합니다. 당신이 (에서와 같이 기본값으로 둘 경우 opt 설정하지 않으면 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; POSIX;&lt;/code&gt; ), 당신은 가져옵니다</target>
        </trans-unit>
        <trans-unit id="8e7dcc56ce0aa1317963b58fc17a4b509ad5c335" translate="yes" xml:space="preserve">
          <source>(with a handful of exceptions). This is an unfortunate backwards compatibility feature and its use is &lt;b&gt;strongly &lt;a href=&quot;perlpolicy#discouraged&quot;&gt;discouraged&lt;/a&gt;&lt;/b&gt;. You should either prevent the exporting (by saying &lt;code&gt;use POSIX ();&lt;/code&gt;, as usual) and then use fully qualified names (e.g. &lt;code&gt;POSIX::SEEK_END&lt;/code&gt;), or give an explicit import list. If you do neither and opt for the default (as in &lt;code&gt;use POSIX;&lt;/code&gt;), you will import</source>
          <target state="translated">(몇 가지 예외가 있음). 이것은 불행한 이전 버전과의 호환성 기능이며, 그것의 사용이되어 &lt;b&gt;강하게 &lt;a href=&quot;perlpolicy#discouraged&quot;&gt;낙담&lt;/a&gt;&lt;/b&gt; . 내보내기를 방지하고 ( 평상시처럼 &lt;code&gt;use POSIX ();&lt;/code&gt; 라고 말 하여) 정규화 된 이름 (예 : &lt;code&gt;POSIX::SEEK_END&lt;/code&gt; )을 사용하거나 명시적인 가져 오기 목록을 제공해야합니다. 둘 다 수행하지 않고 기본값을 선택하면 ( &lt;code&gt;use POSIX;&lt;/code&gt; 에서와 같이 ) 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="590241bfe1d1ab805f123f3dfeca95cb5df33342" translate="yes" xml:space="preserve">
          <source>(with the exception of &lt;code&gt;allow_nonref&lt;/code&gt;, which defaults to</source>
          <target state="translated">( 기본값 은 다음과 &lt;code&gt;allow_nonref&lt;/code&gt; 예외)</target>
        </trans-unit>
        <trans-unit id="306686237693efc97adb9873c6f395a689b08700" translate="yes" xml:space="preserve">
          <source>(without curly braces and</source>
          <target state="translated">(중괄호 및</target>
        </trans-unit>
        <trans-unit id="0e1ed24ac3f83e4bb613f4329aa059c4bf5a4c9c" translate="yes" xml:space="preserve">
          <source>(x, y, z)</source>
          <target state="translated">(x, y, z)</target>
        </trans-unit>
        <trans-unit id="b6f844fee20c55f354c3646d70d08bb8aafbffec" translate="yes" xml:space="preserve">
          <source>(you may need to manually add &lt;code&gt;PERLTYPE=-DPERL_CORE&lt;/code&gt; to this commandline on some versions of Perl; the symptom is that the command-line globbing does not work from OS/2 shells with the newly-compiled executable; check with</source>
          <target state="translated">( 일부 버전의 Perl에서이 명령 행에 &lt;code&gt;PERLTYPE=-DPERL_CORE&lt;/code&gt; 를 수동으로 추가해야 할 수도 있습니다 . 증상은 명령 행 글로브 빙 이 새로 컴파일 된 실행 파일이있는 OS / 2 쉘에서 작동하지 않는 것입니다.</target>
        </trans-unit>
        <trans-unit id="a4ad693788c41eaba8ea97f5859834b29c279024" translate="yes" xml:space="preserve">
          <source>(you probably need to add &lt;code&gt;-shared&lt;/code&gt; to the &amp;lt;-Alddlflags&amp;gt; line until RT #118199 is resolved)</source>
          <target state="translated">( RT # 118199가 해결 될 때까지 &amp;lt;-Alddlflags&amp;gt; 라인 에 &lt;code&gt;-shared&lt;/code&gt; 를 추가해야합니다 )</target>
        </trans-unit>
        <trans-unit id="e7064f0b80f61dbc65915311032d27baa569ae2a" translate="yes" xml:space="preserve">
          <source>)</source>
          <target state="translated">)</target>
        </trans-unit>
        <trans-unit id="eb95089a2aff367522b36d81eeb4af3aa05259c5" translate="yes" xml:space="preserve">
          <source>) Nested backslashed delimiters, embedded balanced bracket delimiters (for the quotelike operators), and trailing modifiers are all caught. For example, in:</source>
          <target state="translated">) 중첩 백 슬래시 구분 기호, 따옴표와 같은 연산자를위한 포함 된 대괄호 구분 기호 및 후행 수정자가 모두 포착됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="93d1e11773c70e0093dfdf1605f54536a30c04cb" translate="yes" xml:space="preserve">
          <source>) add together two &lt;code&gt;gvsv&lt;/code&gt; s.</source>
          <target state="translated">) 두 개의 &lt;code&gt;gvsv&lt;/code&gt; 를 함께 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="dfc5bb482b8cb8cbf302fc5f2490c2508552541d" translate="yes" xml:space="preserve">
          <source>) add together two &lt;code&gt;gvsv&lt;/code&gt;s.</source>
          <target state="translated">) 두 개의 &lt;code&gt;gvsv&lt;/code&gt; 를 더 합니다.</target>
        </trans-unit>
        <trans-unit id="487acab4d37dcb1f88d4268398b649368558f781" translate="yes" xml:space="preserve">
          <source>) and XS code (defined in</source>
          <target state="translated">) 및 XS 코드 (</target>
        </trans-unit>
        <trans-unit id="2af0dc8b4d4fee8ec4a7da24968fc60d5db6f74b" translate="yes" xml:space="preserve">
          <source>) and for which I'll ignore the return value (that's the</source>
          <target state="translated">)에 대해 반환 값을 무시합니다.</target>
        </trans-unit>
        <trans-unit id="95fe6fc6d1e10ab1a18355df450387c52489f3c6" translate="yes" xml:space="preserve">
          <source>) and then delete your local branch:</source>
          <target state="translated">) 다음 로컬 브랜치를 삭제합니다.</target>
        </trans-unit>
        <trans-unit id="5165405c0c57dc222008e31631e6e1160f7f0b2c" translate="yes" xml:space="preserve">
          <source>) and those are hidden inside</source>
          <target state="translated">) 안에 숨겨져 있습니다.</target>
        </trans-unit>
        <trans-unit id="1e5051ed7ca1b9ef31e15eb004126ec2dc0cfec0" translate="yes" xml:space="preserve">
          <source>) and widths (32-bit and 64-bit being the most common today). This affects your programs when they attempt to transfer numbers in binary format from one CPU architecture to another, usually either &quot;live&quot; via network connection, or by storing the numbers to secondary storage such as a disk file or tape.</source>
          <target state="translated">) 및 너비 (32 비트 및 64 비트가 오늘날 가장 일반적입니다). 이것은 하나의 CPU 아키텍처에서 다른 CPU 아키텍처로 2 진 형식으로 숫자를 전송하려고 할 때 (일반적으로 네트워크 연결을 통해 &quot;라이브&quot;) 또는 디스크 파일 또는 테이프와 같은 2 차 스토리지에 숫자를 저장하여 프로그램에 영향을줍니다.</target>
        </trans-unit>
        <trans-unit id="8a4f890fd31d5a7f8d389f42416df72924335dc7" translate="yes" xml:space="preserve">
          <source>) and you will see what is happening</source>
          <target state="translated">) 그리고 당신은 무슨 일이 일어나고 있는지 볼 것입니다</target>
        </trans-unit>
        <trans-unit id="78d8c7b5bfb4d1d699ad80186c17bd61d5ef6810" translate="yes" xml:space="preserve">
          <source>) are accessed in the function and &lt;code&gt;dTHX&lt;/code&gt; is not used (the &lt;code&gt;dTHX&lt;/code&gt; includes the &lt;code&gt;dVAR&lt;/code&gt; if necessary). One notices the need for &lt;code&gt;dVAR&lt;/code&gt; only with the said compile-time define, because otherwise the Perl global variables are visible as-is.</source>
          <target state="translated">) 함수에 액세스하고 &lt;code&gt;dTHX&lt;/code&gt; 가 사용되지합니다 ( &lt;code&gt;dTHX&lt;/code&gt; 는 포함 &lt;code&gt;dVAR&lt;/code&gt; 필요한 경우). 그렇지 않으면 Perl 전역 변수가있는 그대로 표시되므로, 컴파일 시간이 정의 된 경우에만 &lt;code&gt;dVAR&lt;/code&gt; 이 필요하다는 것을 알 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f0af76cebde929dc98391babdd9523facf0df1cb" translate="yes" xml:space="preserve">
          <source>) are also supported Since cygwin-1.7 non-POSIX pathnames are discouraged. Names may contain all printable characters.</source>
          <target state="translated">)도 지원됩니다. cygwin-1.7 비 POSIX 경로 이름은 권장되지 않습니다. 이름에는 인쇄 가능한 모든 문자가 포함될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4d63c0b1ccaa850ba2ad69dd4a8ae1f8f0b54402" translate="yes" xml:space="preserve">
          <source>) are now created with the names which contain a checksum, thus allowing workaround for OS/2 scheme of caching DLLs.</source>
          <target state="translated">)는 이제 체크섬을 포함하는 이름으로 작성되므로 DLL 캐싱의 OS / 2 체계에 대한 임시 해결책을 허용합니다.</target>
        </trans-unit>
        <trans-unit id="b9bcffac0b0e948cf7f6c750635e76e9488261a5" translate="yes" xml:space="preserve">
          <source>) are the same in both EBCDIC and UTF-EBCDIC. Often, documentation will use the term &quot;UTF-8&quot; to mean UTF-EBCDIC as well. This is the case in this document.</source>
          <target state="translated">)는 EBCDIC 및 UTF-EBCDIC에서 동일합니다. 종종 문서는 UTF-EBCDIC을 의미하기 위해 &quot;UTF-8&quot;이라는 용어를 사용합니다. 이 문서의 경우입니다.</target>
        </trans-unit>
        <trans-unit id="b688477e2141565165881be5ad0bc5987114795f" translate="yes" xml:space="preserve">
          <source>) are the same in both EBCDIC and UTF-EBCDIC.)</source>
          <target state="translated">)는 EBCDIC 및 UTF-EBCDIC에서 동일합니다.)</target>
        </trans-unit>
        <trans-unit id="b4703b8b08940fcfc8d37175488b06d9c5c2113f" translate="yes" xml:space="preserve">
          <source>) are to be ignored (because they cannot be linked against).</source>
          <target state="translated">)를 무시해야합니다 (연결할 수 없기 때문).</target>
        </trans-unit>
        <trans-unit id="228c4d656c7c5862fd93efef71f5a4b7ea37cfce" translate="yes" xml:space="preserve">
          <source>) as a hashref containing match criteria that determine if the current distribution matches the YAML document or not.</source>
          <target state="translated">)는 현재 분포가 YAML 문서와 일치하는지 여부를 결정하는 일치 조건을 포함하는 해시 참조로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="0094c9f9603398d1e8131509fbaec9e6e56aa8b2" translate="yes" xml:space="preserve">
          <source>) associated with the module. If so, these will be entirely transparent to the user of the module. It is the responsibility of the</source>
          <target state="translated">)를 모듈과 연관시킵니다. 그렇다면 모듈 사용자에게 완전히 투명하게됩니다. 의 책임입니다</target>
        </trans-unit>
        <trans-unit id="8680fc3067e5b942a71155614ce3702a9457283f" translate="yes" xml:space="preserve">
          <source>) but simply depends on the choice of tmpdir() returned by L&amp;lt;:spec&amp;gt;. On some implementations this location can be set using the C</source>
          <target state="translated">)이지만 L &amp;lt;: spec&amp;gt;이 반환 한 tmpdir ()의 선택에 따라 달라집니다. 일부 구현에서이 위치는 C를 사용하여 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c5659f7b4fec9440dfdc3905af70739f39cad629" translate="yes" xml:space="preserve">
          <source>) can be computed by the great_circle_direction() function:</source>
          <target state="translated">)는 great_circle_direction () 함수로 계산할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5fe6bd925320e38dae70ff8e3655937d2767bfc3" translate="yes" xml:space="preserve">
          <source>) can be tacked onto this variable to generate a list of directories to search.</source>
          <target state="translated">)를이 변수에 고정시켜 검색 할 디렉토리 목록을 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a71d8063cc2fcb4f0ab849a5cf4c8ea8ac77b0fa" translate="yes" xml:space="preserve">
          <source>) contains references to many socket functions which need to be resolved when it's loaded. Most platforms will automatically know where to find the 'dependent' library (e.g.,</source>
          <target state="translated">)에는로드시 해결해야하는 많은 소켓 함수에 대한 참조가 포함되어 있습니다. 대부분의 플랫폼은 '종속'라이브러리를 찾을 수있는 위치를 자동으로 인식합니다 (예 :</target>
        </trans-unit>
        <trans-unit id="5968b6b1837aae02e6a353cd4039edfa15befc28" translate="yes" xml:space="preserve">
          <source>) file.</source>
          <target state="translated">) 파일.</target>
        </trans-unit>
        <trans-unit id="fdb6308c871f74792c598b6316c52ceb7fdc771e" translate="yes" xml:space="preserve">
          <source>) files should be UTF-8 encoded. Users are responsible for proper encoding and decoding. In particular, the &lt;code&gt;read&lt;/code&gt; and &lt;code&gt;write&lt;/code&gt; methods do &lt;b&gt;not&lt;/b&gt; support UTF-8 and should not be used.</source>
          <target state="translated">) 파일은 UTF-8로 인코딩되어야합니다. 사용자는 적절한 인코딩 및 디코딩에 대한 책임이 있습니다. 특히 &lt;code&gt;read&lt;/code&gt; 및 &lt;code&gt;write&lt;/code&gt; 메서드는 UTF-8을 지원 하지 &lt;b&gt;않으므로&lt;/b&gt; 사용해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="0f4288bf07ec0228a3183e18634d69547b9f0364" translate="yes" xml:space="preserve">
          <source>) for a module, Test::Harness is usually used to run the tests (not all modules use Test::Harness but the majority do).</source>
          <target state="translated">) 모듈의 경우 Test :: Harness는 일반적으로 테스트를 실행하는 데 사용됩니다 (모든 모듈이 Test :: Harness를 사용하는 것은 아니지만 대부분이 사용합니다).</target>
        </trans-unit>
        <trans-unit id="6380e7df837c25d9969247c6e203303247a8eb62" translate="yes" xml:space="preserve">
          <source>) for a thorough grounding and reference on the topic.</source>
          <target state="translated">) 주제에 대한 철저한 접지 및 참조</target>
        </trans-unit>
        <trans-unit id="1ef4dbc4e616fa1d18518cdf57dc3f1eed3a7798" translate="yes" xml:space="preserve">
          <source>) for the default perl executable, but for a more ambitious host (like the one that would do fork() emulation) all the extra work needed to pretend that different interpreters are actually different &quot;processes&quot;, would be done here.</source>
          <target state="translated">) 기본 perl 실행 파일의 경우, fork () 에뮬레이션을 수행하는 호스트와 같은보다 야심 찬 호스트의 경우 다른 인터프리터가 실제로 다른 &quot;프로세스&quot;인 척하는 데 필요한 모든 추가 작업이 여기에서 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="b34bf46ab4b61641e16b10e09bd70715019def08" translate="yes" xml:space="preserve">
          <source>) for your machine. If your compiler complains that certain functions are undefined, or that it can't locate</source>
          <target state="translated">)를 확인하십시오. 컴파일러가 특정 함수가 정의되지 않았거나 찾을 수 없다고 불평하는 경우</target>
        </trans-unit>
        <trans-unit id="0c582b687e9340adf76bd136bafc7a4e60851dd4" translate="yes" xml:space="preserve">
          <source>) from the database.</source>
          <target state="translated">) 데이터베이스에서.</target>
        </trans-unit>
        <trans-unit id="116f8f88f4b3848fbd987990694e39bf840bb1eb" translate="yes" xml:space="preserve">
          <source>) guaranteed to be large enough to represent the size of any string that perl can handle.</source>
          <target state="translated">)는 perl이 처리 할 수있는 문자열의 크기를 나타낼만큼 충분히 커야합니다.</target>
        </trans-unit>
        <trans-unit id="337e0c227846bd92d32db8132d6dfda91291a31c" translate="yes" xml:space="preserve">
          <source>) happens to do both these things.</source>
          <target state="translated">)는이 두 가지를 모두 수행합니다.</target>
        </trans-unit>
        <trans-unit id="8ddfd9e5fba9d0bfae55c0a9cf8e0e887dd2de61" translate="yes" xml:space="preserve">
          <source>) if set, overrides the path to the perl executable that should be used to run the tests (the default being</source>
          <target state="translated">) 설정하면 테스트 실행에 사용해야하는 perl 실행 파일의 경로를 대체합니다 (기본값은</target>
        </trans-unit>
        <trans-unit id="ddd938892f2a1218d436a7ea869a8e613d6a7846" translate="yes" xml:space="preserve">
          <source>) if the constructor was called with UNLINK set to 1 (the default state if UNLINK is not specified).</source>
          <target state="translated">) UNLINK가 1로 설정된 상태에서 생성자가 호출 된 경우 (UNLINK가 지정되지 않은 경우 기본 상태).</target>
        </trans-unit>
        <trans-unit id="475773772c97e29ee6060b95810ad4e1376538fc" translate="yes" xml:space="preserve">
          <source>) illustrating the creation, use and monitoring of a pool of</source>
          <target state="translated">) 풀의 생성, 사용 및 모니터링을 설명</target>
        </trans-unit>
        <trans-unit id="e7e44a7e4150f8fa3f3b373c79a37f8b07bb4a24" translate="yes" xml:space="preserve">
          <source>) into an SV whose reference is rv. SV is blessed if &lt;code&gt;classname&lt;/code&gt; is non-null.</source>
          <target state="translated">)를 참조가 rv 인 SV로 &lt;code&gt;classname&lt;/code&gt; 이 null이 아닌 경우 SV는 축복 입니다.</target>
        </trans-unit>
        <trans-unit id="9dac485013a652075c8f1c4b7fb1d43f1f85a1a3" translate="yes" xml:space="preserve">
          <source>) into an executable:</source>
          <target state="translated">)를 실행 파일로 :</target>
        </trans-unit>
        <trans-unit id="81b4f6fe6b33e8129f5b68846e0235e4b8d609db" translate="yes" xml:space="preserve">
          <source>) is a somewhat special case inasmuch as the concatenation of &lt;code&gt;$File::Find::dir&lt;/code&gt; , &lt;code&gt;'/'&lt;/code&gt; and &lt;code&gt;$_&lt;/code&gt; is not literally equal to &lt;code&gt;$File::Find::name&lt;/code&gt; . The table below summarizes all variants:</source>
          <target state="translated">)는 &lt;code&gt;$File::Find::dir&lt;/code&gt; , &lt;code&gt;'/'&lt;/code&gt; 및 &lt;code&gt;$_&lt;/code&gt; 이 문자 그대로 &lt;code&gt;$File::Find::name&lt;/code&gt; 과 같지 않기 때문에 다소 특별한 경우 입니다. 아래 표에는 모든 변형이 요약되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="90c96507ab61376ee997f23c6d427ce68d7c9b72" translate="yes" xml:space="preserve">
          <source>) is a somewhat special case inasmuch as the concatenation of &lt;code&gt;$File::Find::dir&lt;/code&gt;, &lt;code&gt;'/'&lt;/code&gt; and &lt;code&gt;$_&lt;/code&gt; is not literally equal to &lt;code&gt;$File::Find::name&lt;/code&gt;. The table below summarizes all variants:</source>
          <target state="translated">)는 &lt;code&gt;$File::Find::dir&lt;/code&gt; , &lt;code&gt;'/'&lt;/code&gt; 및 &lt;code&gt;$_&lt;/code&gt; 이 문자 그대로 &lt;code&gt;$File::Find::name&lt;/code&gt; 과 같지 않기 때문에 다소 특별한 경우 입니다. 아래 표에는 모든 변형이 요약되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="cf9470af5d5cf93f057397bef4222a4e4cd5a518" translate="yes" xml:space="preserve">
          <source>) is called instead, otherwise falling back to &lt;code&gt;&amp;amp;DB::sub&lt;/code&gt; (</source>
          <target state="translated">) 대신 호출되며, 그렇지 않으면 &lt;code&gt;&amp;amp;DB::sub&lt;/code&gt; (</target>
        </trans-unit>
        <trans-unit id="6c8188ede998e6e037975c6c363a167896d77867" translate="yes" xml:space="preserve">
          <source>) is called instead, otherwise falling back to &lt;code&gt;&amp;amp;DB::sub&lt;/code&gt;(</source>
          <target state="translated">) 대신 호출됩니다. 그렇지 않으면 &lt;code&gt;&amp;amp;DB::sub&lt;/code&gt; (</target>
        </trans-unit>
        <trans-unit id="23696ac6362c5f53fb63901a51bae770c8ae962d" translate="yes" xml:space="preserve">
          <source>) is either a text-string or a reference to a &lt;b&gt;Pod::InteriorSequence&lt;/b&gt; object. The nodes appear in the parse-tree in the order in which they were parsed from left-to-right.</source>
          <target state="translated">)은 텍스트 문자열이거나 &lt;b&gt;Pod :: InteriorSequence&lt;/b&gt; 객체에 대한 참조 입니다. 노드는 왼쪽에서 오른쪽으로 구문 분석 된 순서대로 구문 분석 트리에 나타납니다.</target>
        </trans-unit>
        <trans-unit id="5767c1b2b6c18556726990ab8b5bc59c494545e8" translate="yes" xml:space="preserve">
          <source>) is in that special format.</source>
          <target state="translated">)는 그 특별한 형식입니다.</target>
        </trans-unit>
        <trans-unit id="32f86aa54464138379726463882cdceaf0bcc1f8" translate="yes" xml:space="preserve">
          <source>) is made instead, with &lt;code&gt;$DB::sub&lt;/code&gt; holding the name of the called subroutine. (This doesn't happen if the subroutine was compiled in the &lt;code&gt;DB&lt;/code&gt; package.)</source>
          <target state="translated">) 대신 &lt;code&gt;$DB::sub&lt;/code&gt; 가 호출 된 서브 루틴의 이름을 보유합니다. (서브 루틴이 &lt;code&gt;DB&lt;/code&gt; 패키지 에서 컴파일 된 경우에는 발생하지 않습니다 .)</target>
        </trans-unit>
        <trans-unit id="6f72da199407d17f3eb070ab79da4f95bcf5d247" translate="yes" xml:space="preserve">
          <source>) is made instead, with &lt;code&gt;$DB::sub&lt;/code&gt; set to identify the called subroutine. (This doesn't happen if the calling subroutine was compiled in the &lt;code&gt;DB&lt;/code&gt; package.) &lt;code&gt;$DB::sub&lt;/code&gt; normally holds the name of the called subroutine, if it has a name by which it can be looked up. Failing that, &lt;code&gt;$DB::sub&lt;/code&gt; will hold a reference to the called subroutine. Either way, the &lt;code&gt;&amp;amp;DB::sub&lt;/code&gt; subroutine can use &lt;code&gt;$DB::sub&lt;/code&gt; as a reference by which to call the called subroutine, which it will normally want to do.</source>
          <target state="translated">) 대신 호출 된 서브 루틴을 식별하기 위해 &lt;code&gt;$DB::sub&lt;/code&gt; 설정됩니다. (이는 호출 서브 루틴이 &lt;code&gt;DB&lt;/code&gt; 패키지 에서 컴파일 된 경우에는 발생하지 않습니다 .) &lt;code&gt;$DB::sub&lt;/code&gt; 는 조회 할 수있는 이름이있는 경우 일반적으로 호출 된 서브 루틴의 이름을 보유합니다. 실패하면 &lt;code&gt;$DB::sub&lt;/code&gt; 는 호출 된 서브 루틴에 대한 참조를 보유합니다. 어느 쪽이든, &lt;code&gt;&amp;amp;DB::sub&lt;/code&gt; 루틴 은 일반적으로 수행하려는 호출 된 서브 루틴을 호출하기위한 참조로 &lt;code&gt;$DB::sub&lt;/code&gt; 를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="09c02d83fc25240c47808099a2e4f821d696cb01" translate="yes" xml:space="preserve">
          <source>) is used as a package separator for documentation for packages, and as usual, sometimes you need to give the section - &lt;code&gt;3&lt;/code&gt; above - to avoid shadowing by the</source>
          <target state="translated">)는 패키지 문서화를위한 패키지 구분 기호로 사용되며, 평소와 같이 섀도 잉을 피하기 위해 위 의 섹션 &lt;code&gt;3&lt;/code&gt; 을 제공해야 합니다.</target>
        </trans-unit>
        <trans-unit id="5971125402714a98c492903d9612cbceea13e6b3" translate="yes" xml:space="preserve">
          <source>) model. However, some previous functionality is not available. Further, the data sharing models between the two thread models are completely different, and anything to do with data sharing has to be thought differently. With</source>
          <target state="translated">) 모델. 그러나 일부 이전 기능은 사용할 수 없습니다. 또한 두 스레드 모델 간의 데이터 공유 모델은 완전히 다르며 데이터 공유와 관련된 모든 내용은 다르게 생각해야합니다. 와</target>
        </trans-unit>
        <trans-unit id="c8900d677b2a01f7480862af7c53a8c9206bc052" translate="yes" xml:space="preserve">
          <source>) of EXPR. If EXPR is omitted, returns the log of &lt;a href=&quot;perlvar#%24_&quot;&gt;&lt;code&gt;$_&lt;/code&gt;&lt;/a&gt;. To get the log of another base, use basic algebra: The base-N log of a number is equal to the natural log of that number divided by the natural log of N. For example:</source>
          <target state="translated">)의 EXPR. EXPR을 생략하면 &lt;a href=&quot;perlvar#%24_&quot;&gt; &lt;code&gt;$_&lt;/code&gt; &lt;/a&gt; 로그를 반환합니다 . 다른 밑수의 로그를 얻으려면 기본 대수를 사용하십시오. 숫자의 밑수 N 로그는 해당 숫자의 자연 로그를 N의 자연 로그로 나눈 값과 같습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="50d605006e5819d9ee72b0368f957bba921207fa" translate="yes" xml:space="preserve">
          <source>) of EXPR. If EXPR is omitted, returns the log of &lt;code&gt;$_&lt;/code&gt; . To get the log of another base, use basic algebra: The base-N log of a number is equal to the natural log of that number divided by the natural log of N. For example:</source>
          <target state="translated">)의 EXPR. EXPR을 생략하면 &lt;code&gt;$_&lt;/code&gt; 로그를 리턴합니다 . 다른 밑의 로그를 구하려면 기본 대수를 사용하십시오. 숫자의 밑 N 로그는 해당 숫자의 자연 로그를 자연 로그 N으로 나눈 것과 같습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="73013703f8359c6292272932a5d96f3a21e4da8b" translate="yes" xml:space="preserve">
          <source>) of link target</source>
          <target state="translated">) 링크 대상</target>
        </trans-unit>
        <trans-unit id="1c4fc186c95906992ee9e790368dc6d7e6bb249e" translate="yes" xml:space="preserve">
          <source>) or $token-&amp;gt;is_tagname(</source>
          <target state="translated">) 또는 $ token-&amp;gt; is_tagname (</target>
        </trans-unit>
        <trans-unit id="34c99e6b33b978b2a76257b1ec099dd28fe4c5af" translate="yes" xml:space="preserve">
          <source>) or autoloaded subroutine definitions (often ending in</source>
          <target state="translated">) 또는 자동로드 서브 루틴 정의 (종종</target>
        </trans-unit>
        <trans-unit id="8be067842fd8dd4a9dda8652f213b0bfca2534f2" translate="yes" xml:space="preserve">
          <source>) or from</source>
          <target state="translated">) 또는</target>
        </trans-unit>
        <trans-unit id="6268b6d7aba0dddbda46ab70ff997d6de27b91a4" translate="yes" xml:space="preserve">
          <source>) or small pieces of modules to be autoloaded (ending in</source>
          <target state="translated">) 또는 자동로드 할 작은 모듈 조각 (</target>
        </trans-unit>
        <trans-unit id="e0b4a008b1b72c63ec0fe1bf922f01ecd1e7dcea" translate="yes" xml:space="preserve">
          <source>) regarding the license:</source>
          <target state="translated">) 라이센스와 관련하여 :</target>
        </trans-unit>
        <trans-unit id="a45f9f3bff2ba18d925d19d588022f6b22bbbb23" translate="yes" xml:space="preserve">
          <source>) result in single code points and are locale independent and unconditional, &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; is returned (which means that the case mappings, if any, for the code point are those returned by &lt;a href=&quot;#charinfo()&quot;&gt;charinfo()&lt;/a&gt;).</source>
          <target state="translated">)는 단일 코드 포인트가되며 로케일 독립적이며 무조건적이며 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 가 리턴됩니다 (즉, 코드 포인트의 경우 케이스 맵핑은 &lt;a href=&quot;#charinfo()&quot;&gt;charinfo ()에&lt;/a&gt; 의해 리턴 된 것임 ).</target>
        </trans-unit>
        <trans-unit id="391e0275a9d94cc4fb72b3fa708d0c427551dc20" translate="yes" xml:space="preserve">
          <source>) result in single code points and are locale independent and unconditional, &lt;code&gt;undef&lt;/code&gt; is returned (which means that the case mappings, if any, for the code point are those returned by &lt;a href=&quot;#charinfo%28%29&quot;&gt;&quot;charinfo()&quot;&lt;/a&gt;).</source>
          <target state="translated">) 결과 단일 코드 포인트가되고 로케일과 무조건 무조건 &lt;code&gt;undef&lt;/code&gt; 가 리턴됩니다 (즉, 코드 포인트에 대한 케이스 맵핑이 &lt;a href=&quot;#charinfo%28%29&quot;&gt;&quot;charinfo ()&quot;에서&lt;/a&gt; 리턴 된 것임을 의미합니다 ).</target>
        </trans-unit>
        <trans-unit id="a7093a28b00cb3f7379bae3a74ed546d6d759f1c" translate="yes" xml:space="preserve">
          <source>) returned 22</source>
          <target state="translated">) 22를 반환했습니다.</target>
        </trans-unit>
        <trans-unit id="290a554d5dd4f4fd53f4f0c3f26a8b92afe46af9" translate="yes" xml:space="preserve">
          <source>) routine is available to get the current process group.</source>
          <target state="translated">) 루틴을 사용하여 현재 프로세스 그룹을 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fbfc535d542b663f5fc6309d86a766d1da4fdbb5" translate="yes" xml:space="preserve">
          <source>) routine is available to set the current process group.</source>
          <target state="translated">) 루틴을 사용하여 현재 프로세스 그룹을 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="26e28f24fd9b1f154c2e8f05eec3ce59bdb7d39d" translate="yes" xml:space="preserve">
          <source>) see whether a scalar contains a string, an integer, or a floating-point number. But you can still peek and poke these if you will. See the next section.</source>
          <target state="translated">)는 스칼라에 문자열, 정수 또는 부동 소수점 숫자가 포함되어 있는지 확인하십시오. 그러나 당신이 원한다면 여전히 훔쳐 볼 수 있습니다. 다음 섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="edd28277fd127085fceb90541640e76ea071b695" translate="yes" xml:space="preserve">
          <source>) slashes, Universal Naming Codes (</source>
          <target state="translated">) 슬래시, 범용 명명 코드 (</target>
        </trans-unit>
        <trans-unit id="6fe21bfd6516c2f8c1ce99da2c5ba6214935b065" translate="yes" xml:space="preserve">
          <source>) that hide the details of the interpreter's context. THX stands for &quot;thread&quot;, &quot;this&quot;, or &quot;thingy&quot;, as the case may be. (And no, George Lucas is not involved. :-) The first character could be 'p' for a &lt;b&gt;p&lt;/b&gt;rototype, 'a' for &lt;b&gt;a&lt;/b&gt;rgument, or 'd' for &lt;b&gt;d&lt;/b&gt;eclaration, so we have &lt;code&gt;pTHX&lt;/code&gt; , &lt;code&gt;aTHX&lt;/code&gt; and &lt;code&gt;dTHX&lt;/code&gt; , and their variants.</source>
          <target state="translated">)는 통역사 컨텍스트의 세부 사항을 숨 깁니다. THX는 &quot;스레드&quot;, &quot;this&quot;또는 &quot;thingy&quot;를 의미합니다. (그리고 아니, 조지 루카스가 포함되어 있지 않습니다. :-) 첫 번째 문자가에 대한 'P'가 될 수 &lt;b&gt;페이지에&lt;/b&gt; 대한 rototype, 'A' 에 대한 rgument, 또는 'D' &lt;b&gt;D의&lt;/b&gt; 우리가 있도록, eclaration &lt;code&gt;pTHX&lt;/code&gt; , &lt;code&gt;aTHX&lt;/code&gt; 및 &lt;code&gt;dTHX&lt;/code&gt; 을 , 그리고 그들의 변종.&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="bebca5effcde7de71cb36899c8b7b5dd6966704c" translate="yes" xml:space="preserve">
          <source>) that hide the details of the interpreter's context. THX stands for &quot;thread&quot;, &quot;this&quot;, or &quot;thingy&quot;, as the case may be. (And no, George Lucas is not involved. :-) The first character could be 'p' for a &lt;b&gt;p&lt;/b&gt;rototype, 'a' for &lt;b&gt;a&lt;/b&gt;rgument, or 'd' for &lt;b&gt;d&lt;/b&gt;eclaration, so we have &lt;code&gt;pTHX&lt;/code&gt;, &lt;code&gt;aTHX&lt;/code&gt; and &lt;code&gt;dTHX&lt;/code&gt;, and their variants.</source>
          <target state="translated">) 통역사의 상황에 대한 세부 정보를 숨 깁니다. THX는 경우에 따라 &quot;thread&quot;, &quot;this&quot;또는 &quot;thingy&quot;를 나타냅니다. (그리고 아니, 조지 루카스가 포함되어 있지 않습니다. :-) 첫 번째 문자가에 대한 'P'가 될 수 &lt;b&gt;페이지에&lt;/b&gt; 대한 rototype, 'A' 에 대한 rgument, 또는 'D' &lt;b&gt;D의&lt;/b&gt; 우리가 있도록, eclaration &lt;code&gt;pTHX&lt;/code&gt; , &lt;code&gt;aTHX&lt;/code&gt; 및 &lt;code&gt;dTHX&lt;/code&gt; 을 , 및 그 변형.&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="e97548e96f2ddff38307a0e5c64c9b937c5a39a0" translate="yes" xml:space="preserve">
          <source>) this is:</source>
          <target state="translated">) 이것은:</target>
        </trans-unit>
        <trans-unit id="58d0b83faa9818666bc1ae3462657cd7ca7c19ae" translate="yes" xml:space="preserve">
          <source>) to &lt;code&gt;PATH&lt;/code&gt; ; copy &lt;code&gt;perl_.exe&lt;/code&gt; to &lt;code&gt;PATH&lt;/code&gt; as &lt;code&gt;perl_5.8.2.exe&lt;/code&gt; . Think whether you need backward-compatibility DLLs. In most cases you do not need to install them yet; but sometime this may simplify the following steps.</source>
          <target state="translated">) ~ &lt;code&gt;PATH&lt;/code&gt; ; 복사 &lt;code&gt;perl_.exe&lt;/code&gt; 을 에 &lt;code&gt;PATH&lt;/code&gt; 로 &lt;code&gt;perl_5.8.2.exe&lt;/code&gt; . 이전 버전과 호환되는 DLL이 필요한지 생각해보십시오. 대부분의 경우 아직 설치할 필요가 없습니다. 그러나 때때로 다음 단계를 단순화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="402bef1c99bbd938c61c5a9988380b210c5ec786" translate="yes" xml:space="preserve">
          <source>) to &lt;code&gt;PATH&lt;/code&gt;; copy &lt;code&gt;perl_.exe&lt;/code&gt; to &lt;code&gt;PATH&lt;/code&gt; as &lt;code&gt;perl_5.8.2.exe&lt;/code&gt;. Think whether you need backward-compatibility DLLs. In most cases you do not need to install them yet; but sometime this may simplify the following steps.</source>
          <target state="translated">)에서 &lt;code&gt;PATH&lt;/code&gt; 로 ; 복사 &lt;code&gt;perl_.exe&lt;/code&gt; 을 에 &lt;code&gt;PATH&lt;/code&gt; 로 &lt;code&gt;perl_5.8.2.exe&lt;/code&gt; . 이전 버전과의 호환성 DLL이 필요한지 생각해보십시오. 대부분의 경우 아직 설치할 필요가 없습니다. 그러나 때때로 이것은 다음 단계를 단순화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2bfb1d2c84b8f96364a15ab20bbedeb8fdc478cf" translate="yes" xml:space="preserve">
          <source>) unless the first thing after the =over is an =item</source>
          <target state="translated">) = over 이후의 첫 번째 항목이 = item이 아닌 경우</target>
        </trans-unit>
        <trans-unit id="ee8d0d482ba732e339db373655156b50d4f689fa" translate="yes" xml:space="preserve">
          <source>) variable.</source>
          <target state="translated">) 변수.</target>
        </trans-unit>
        <trans-unit id="8d6ab57f146723c24d110d324d107fe798a11b43" translate="yes" xml:space="preserve">
          <source>) where there are no parameters (except $_[0], the language handle).</source>
          <target state="translated">) 매개 변수가없는 경우 (언어 핸들 $ _ [0] 제외).</target>
        </trans-unit>
        <trans-unit id="20739558e894101738b809f5961ce2ec15d5ef69" translate="yes" xml:space="preserve">
          <source>) which itself uses a C or C++ library, this probably happened:</source>
          <target state="translated">) 자체는 C 또는 C ++ 라이브러리를 사용하며 아마도 이런 일이 발생했을 것입니다.</target>
        </trans-unit>
        <trans-unit id="9bb3b0590ce91e56d975340e4f059419f1cd3a34" translate="yes" xml:space="preserve">
          <source>) will return true but not actually set the bit.</source>
          <target state="translated">)는 true를 반환하지만 실제로 비트를 설정하지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="555eb93c31c2ff33a5f28e75533e9b13d5846308" translate="yes" xml:space="preserve">
          <source>) will return true but not actually set the bit. (Android)</source>
          <target state="translated">)는 true를 반환하지만 실제로 비트를 설정하지는 않습니다. (기계적 인조 인간)</target>
        </trans-unit>
        <trans-unit id="76964257ee68bb8fca6aa80c00dd5fc9f2ec1a64" translate="yes" xml:space="preserve">
          <source>) with a character class, and no string shorter than 7 characters can possibly match.</source>
          <target state="translated">)로 구성되며 7 자보다 짧은 문자열은 일치하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7b62adc5f8c3abd2eb86b6b1533af991c7edca58" translate="yes" xml:space="preserve">
          <source>) would otherwise terminate the loop. Again, &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; is returned only once. So if you're expecting a single value from a glob, it is much better to say</source>
          <target state="translated">그렇지 않으면 루프를 종료합니다. 다시 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 는 한 번만 리턴됩니다. 따라서 글로브에서 단일 값을 기대하는 경우 말하는 것이 훨씬 좋습니다</target>
        </trans-unit>
        <trans-unit id="c972a2d6506c7e630a1bc588ff59aaaa9c6a81f4" translate="yes" xml:space="preserve">
          <source>) would otherwise terminate the loop. Again, &lt;code&gt;undef&lt;/code&gt; is returned only once. So if you're expecting a single value from a glob, it is much better to say</source>
          <target state="translated">) 그렇지 않으면 루프가 종료됩니다. 다시 말하지만 &lt;code&gt;undef&lt;/code&gt; 는 한 번만 반환됩니다. 따라서 glob에서 단일 값을 기대하는 경우 다음과 같이 말하는 것이 훨씬 좋습니다.</target>
        </trans-unit>
        <trans-unit id="4810b75ef754b672275a3af2b5a078e21220cbc9" translate="yes" xml:space="preserve">
          <source>) you must still call the &lt;code&gt;PUSHMARK&lt;/code&gt; macro before you can call any of the</source>
          <target state="translated">) 여전히 &lt;code&gt;PUSHMARK&lt;/code&gt; 매크로를 호출해야합니다 .</target>
        </trans-unit>
        <trans-unit id="dd68868e123f57ff7ef38ff164a231d0c0a76fe0" translate="yes" xml:space="preserve">
          <source>) you want to rebuild.</source>
          <target state="translated">)를 다시 작성하고 싶습니다.</target>
        </trans-unit>
        <trans-unit id="02a91090e67572144de2f031f1bbc5cd3c4a2837" translate="yes" xml:space="preserve">
          <source>)&quot;). They may derive from the project class. They may derive from some other class altogether. Or via multiple inheritance, it may derive from any mixture of these.</source>
          <target state="translated">) &quot;). 프로젝트 클래스에서 파생 될 수 있습니다. 다른 클래스에서 모두 파생 될 수 있습니다. 또는 다중 상속을 통해 이러한 클래스를 혼합하여 파생 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e6747b651e587fe4f0093d11936c478b09099030" translate="yes" xml:space="preserve">
          <source>), &lt;a href=&quot;perlvms&quot;&gt;perlvms&lt;/a&gt;</source>
          <target state="translated">), &lt;a href=&quot;perlvms&quot;&gt;perlvms&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ba220f5b6e6ddf875b36f2ab6036ca1e73f1dfa8" translate="yes" xml:space="preserve">
          <source>), a binary distribution, or a non-core module (such as Tk, DBI, etc), then please see the documentation that came with that distribution to determine the correct place to report bugs.</source>
          <target state="translated">), 이진 배포 또는 비 핵심 모듈 (예 : Tk, DBI 등) 인 경우 버그를보고 할 올바른 위치를 결정하려면 해당 배포와 함께 제공된 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="37d7a98fcb3161e7f59b469e14532a94d36f9b12" translate="yes" xml:space="preserve">
          <source>), along with some helpful methods for interrogating that data.</source>
          <target state="translated">), 해당 데이터를 조사하는 데 유용한 몇 가지 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="7bbfc61f89bcf69b7d112e66034a33a974882ccb" translate="yes" xml:space="preserve">
          <source>), and into the Perl interpreter itself. Older versions of Perl contain bugs that may manifest themselves despite using the latest version of &lt;a href=&quot;threads&quot;&gt;threads&lt;/a&gt; from CPAN. There is no workaround for this other than upgrading to the latest version of Perl.</source>
          <target state="translated">) 및 Perl 통역사 자체로. 이전 버전의 Perl에는 CPAN 의 최신 버전의 &lt;a href=&quot;threads&quot;&gt;스레드&lt;/a&gt; 를 사용하더라도 버그가 발생할 수 있습니다 . 최신 버전의 Perl로 업그레이드하는 것 외에는 이에 대한 해결 방법이 없습니다.</target>
        </trans-unit>
        <trans-unit id="a812a48223447ff4a00c61dec758c7f63fc7d624" translate="yes" xml:space="preserve">
          <source>), and the Korn shell (</source>
          <target state="translated">) 및 Korn 쉘 (</target>
        </trans-unit>
        <trans-unit id="4dc3d4ea606f39cb0d51862e90b09132948ca8d9" translate="yes" xml:space="preserve">
          <source>), but never achieved universal adoption. The &lt;a href=&quot;Object::InsideOut&quot;&gt;Object::InsideOut&lt;/a&gt; module on CPAN provides a comprehensive implementation of this technique, and you may see it or other inside-out modules in the wild.</source>
          <target state="translated">), 그러나 보편적으로 채택되지는 않았습니다. CPAN 의 &lt;a href=&quot;Object::InsideOut&quot;&gt;Object :: InsideOut&lt;/a&gt; 모듈은이 기술의 포괄적 인 구현을 제공하며,이 기술이나 다른 내부 모듈을 야생에서 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5582722a931d80faec2c2604d236f55218c4801c" translate="yes" xml:space="preserve">
          <source>), but never achieved universal adoption. The &lt;a href=&quot;http://search.cpan.org/perldoc/Object::InsideOut&quot;&gt;Object::InsideOut&lt;/a&gt; module on CPAN provides a comprehensive implementation of this technique, and you may see it or other inside-out modules in the wild.</source>
          <target state="translated">), 보편적 인 채택을 달성 한 적이 없습니다. CPAN 의 &lt;a href=&quot;http://search.cpan.org/perldoc/Object::InsideOut&quot;&gt;Object :: InsideOut&lt;/a&gt; 모듈은이 기술의 포괄적 인 구현을 제공하며,이 모듈이나 다른 내부 출력 모듈을 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="be22299e2551650ec9efe8f43bc6cd3596bc5a87" translate="yes" xml:space="preserve">
          <source>), but the literal data is in the specified encoding.</source>
          <target state="translated">)이지만 리터럴 데이터는 지정된 인코딩에 있습니다.</target>
        </trans-unit>
        <trans-unit id="a13d6f5c889dfb868a65c83873de9aa4af2cc116" translate="yes" xml:space="preserve">
          <source>), especially many little-endians do the latter. This is only useful if you have select(), naturally.</source>
          <target state="translated">), 특히 많은 리틀 엔디 언이 후자를 수행합니다. 이것은 select ()가 자연스럽게있는 경우에만 유용합니다.</target>
        </trans-unit>
        <trans-unit id="a90a49817763911f4c5d2c811bd0265de9cdae6a" translate="yes" xml:space="preserve">
          <source>), even for negative shiftees. In arithmetic right shift the sign bit is replicated on the left, in logical shift zero bits come in from the left.</source>
          <target state="translated">), 심지어 부정적인 시프터에게도. 산술 오른쪽 시프트에서 부호 비트는 왼쪽에 복제되고 논리 시프트에서는 0 비트가 왼쪽에서 들어옵니다.</target>
        </trans-unit>
        <trans-unit id="1bdc1dfaa0689b15c5f1f5abeefc7919ff43e83f" translate="yes" xml:space="preserve">
          <source>), like</source>
          <target state="translated">), 처럼</target>
        </trans-unit>
        <trans-unit id="8e07233c7cb7d125bda9afb2d089c66b7362165d" translate="yes" xml:space="preserve">
          <source>), or &lt;code&gt;`glob a*b`&lt;/code&gt; (internal for ksh)? You need to specify your shell explicitly, like &lt;code&gt;`cmd /c copy a b`&lt;/code&gt; , since Perl cannot deduce which commands are internal to your shell.</source>
          <target state="translated">) 또는 &lt;code&gt;`glob a*b`&lt;/code&gt; (ksh의 내부)? Perl이 쉘 내부의 명령을 추론 할 수 없기 때문에 &lt;code&gt;`cmd /c copy a b`&lt;/code&gt; 와 같이 명시 적으로 쉘을 지정해야합니다 .</target>
        </trans-unit>
        <trans-unit id="778cde10ba3ce670335c0977b855f84fe72d11ca" translate="yes" xml:space="preserve">
          <source>), or &lt;code&gt;`glob a*b`&lt;/code&gt; (internal for ksh)? You need to specify your shell explicitly, like &lt;code&gt;`cmd /c copy a b`&lt;/code&gt;, since Perl cannot deduce which commands are internal to your shell.</source>
          <target state="translated">) 또는 &lt;code&gt;`glob a*b`&lt;/code&gt; (ksh의 내부)? Perl은 어떤 명령이 쉘 내부에 있는지 추론 할 수 없기 때문에 &lt;code&gt;`cmd /c copy a b`&lt;/code&gt; 와 같이 쉘을 명시 적으로 지정해야합니다 .</target>
        </trans-unit>
        <trans-unit id="5b4d9823b2af8d74d8d5e0c1ea2ff248c80ea3d4" translate="yes" xml:space="preserve">
          <source>), or in configurable location (see &lt;a href=&quot;#PERL_SH_DIR&quot;&gt;&quot;&lt;code&gt;PERL_SH_DIR&lt;/code&gt;&quot;&lt;/a&gt;).</source>
          <target state="translated">) 또는 구성 가능한 위치 ( &lt;a href=&quot;#PERL_SH_DIR&quot;&gt;&quot; &lt;code&gt;PERL_SH_DIR&lt;/code&gt; &quot;&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="0628cf3503bf4bbbc2ce5d535a543d4ded04903a" translate="yes" xml:space="preserve">
          <source>), or in configurable location (see &lt;a href=&quot;#PERL_SH_DIR&quot;&gt;PERL_SH_DIR&lt;/a&gt;).</source>
          <target state="translated">) 또는 구성 가능한 위치에 있습니다 ( &lt;a href=&quot;#PERL_SH_DIR&quot;&gt;PERL_SH_DIR&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="2491f48be12de5636116c5c0fd0e291876db397a" translate="yes" xml:space="preserve">
          <source>), or libdlcompat to</source>
          <target state="translated">) 또는 libdlcompat to</target>
        </trans-unit>
        <trans-unit id="e29686a525e32c01eab0fa60c7ad6d86eada0dd5" translate="yes" xml:space="preserve">
          <source>), otherwise unsigned C integers are used (</source>
          <target state="translated">), 그렇지 않으면 부호없는 C 정수가 사용됩니다 (</target>
        </trans-unit>
        <trans-unit id="b76430f0a63614c0383c191e6bda6c8b60a93154" translate="yes" xml:space="preserve">
          <source>), resulting in garbled output from the unrecognized attribute. Even if there were a way around that problem, the format doesn't know that the non-printing escape sequence is zero-length and would incorrectly format the output. For formatted output using color or other attributes, either use sprintf() instead or use formline() and then add the color or other attributes after formatting and before output.</source>
          <target state="translated">)가 인식되지 않아 속성이 잘못 출력되었습니다. 이 문제를 해결할 방법이 있더라도 비 인쇄 이스케이프 시퀀스의 길이가 0임을 알지 못하고 출력 형식을 잘못 지정합니다. 색상 또는 기타 속성을 사용하여 형식화 된 출력의 경우 대신 sprintf ()를 사용하거나 formline ()을 사용한 다음 형식화 후 및 출력 전에 색상 또는 기타 속성을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="27d4e0b75aa9979af9c60f48e50541e1084c0f21" translate="yes" xml:space="preserve">
          <source>), the C shell (</source>
          <target state="translated">), C 쉘 (</target>
        </trans-unit>
        <trans-unit id="36f69b726a9c53c3663307c2a768d21ad7c2d633" translate="yes" xml:space="preserve">
          <source>), the Unicode version of normalization implemented by this module depends on what has been compiled into your perl. The following table lists the default Unicode version that comes with various perl versions. (It is possible to change the Unicode version in any perl version to be any earlier Unicode version, so one could cause Unicode 3.2 to be used in any perl version starting with 5.8.0. Read</source>
          <target state="translated">),이 모듈에 의해 구현 된 정규화의 유니 코드 버전은 perl로 컴파일 된 항목에 따라 다릅니다. 다음 표에는 다양한 perl 버전과 함께 제공되는 기본 유니 코드 버전이 나열되어 있습니다. (모든 perl 버전의 유니 코드 버전을 이전 유니 코드 버전으로 변경할 수 있으므로 5.8.0으로 시작하는 모든 perl 버전에서 유니 코드 3.2를 사용할 수 있습니다. 읽기</target>
        </trans-unit>
        <trans-unit id="8921d13cc2e9b0e14e6863e00a16b9ef9534ecde" translate="yes" xml:space="preserve">
          <source>), the Unicode version of normalization implemented by this module depends on your perl's version.</source>
          <target state="translated">),이 모듈에 의해 구현 된 정규화의 유니 코드 버전은 perl의 버전에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="7847189040b71cd51c130c2436b0e22235a3d864" translate="yes" xml:space="preserve">
          <source>), the remainder of the text, and the skipped prefix (if any). If a suitable delimited substring is not found, the first element of the array is the empty string, the second is the complete original text, and the prefix returned in the third element is an empty string.</source>
          <target state="translated">), 나머지 텍스트 및 건너 뛴 접두사 (있는 경우) 적절한 구분 된 하위 문자열을 찾을 수 없으면 배열의 첫 번째 요소는 빈 문자열이고 두 번째는 완전한 원본 텍스트이며 세 번째 요소에 반환 된 접두사는 빈 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="f615146b0c5326d45eb59116d40a716c8d44a5d9" translate="yes" xml:space="preserve">
          <source>), while the latter is useful if $prefix is shared by many packages, e.g. if $prefix=</source>
          <target state="translated">), 후자는 많은 패키지가 $ prefix를 공유하는 경우에 유용합니다 (예 : $ prefix =</target>
        </trans-unit>
        <trans-unit id="2ddb6d2a78b2c77758ab5631f959dfe309c8ee8b" translate="yes" xml:space="preserve">
          <source>). A few platforms need to be told the location of the dependent library explicitly. Use @dl_resolve_using for this.</source>
          <target state="translated">). 일부 플랫폼에는 종속 라이브러리의 위치를 ​​명시 적으로 알려 주어야합니다. @dl_resolve_using을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="6e0d8f2fab340ca3e828a3d60cdc124f6a7963fd" translate="yes" xml:space="preserve">
          <source>). Almost all internally-used routines in</source>
          <target state="translated">). 내부적으로 사용되는 거의 모든 루틴</target>
        </trans-unit>
        <trans-unit id="2e3178a172620d14bf2d6fd49572a7f8b300111a" translate="yes" xml:space="preserve">
          <source>). And it is &lt;code&gt;F&lt;/code&gt; if there is only a</source>
          <target state="translated">). 그리고는 &lt;code&gt;F&lt;/code&gt; 는 만있는 경우</target>
        </trans-unit>
        <trans-unit id="191441749ef940028953be8e584c0530088683d7" translate="yes" xml:space="preserve">
          <source>). Anyhow, this module will neither refer to</source>
          <target state="translated">). 어쨌든이 모듈은</target>
        </trans-unit>
        <trans-unit id="740873c13ba23b24200aa2080c4fd9faa64f0e57" translate="yes" xml:space="preserve">
          <source>). If necessary, run just the failing scripts again sequentially and see if the failures go away.</source>
          <target state="translated">). 필요한 경우, 실패한 스크립트 만 순차적으로 다시 실행하고 실패가 사라지는 지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="f4fa6174028d9716fdac2ed031a49f5b83d140fe" translate="yes" xml:space="preserve">
          <source>). If this Perl code makes calls into this XS code, and/or this XS code makes calls to the Perl code, one should be careful with the order of initialization.</source>
          <target state="translated">). 이 Perl 코드가이 XS 코드를 호출하거나이 XS 코드가 Perl 코드를 호출하는 경우 초기화 순서에주의해야합니다.</target>
        </trans-unit>
        <trans-unit id="d00d1fa6ee0d8fc40d4a6589099f366d00ea1908" translate="yes" xml:space="preserve">
          <source>). In this model, each thread runs in its own Perl interpreter, and any data sharing between threads must be explicit. The user-level interface for</source>
          <target state="translated">). 이 모델에서 각 스레드는 고유 한 Perl 인터프리터에서 실행되며 스레드 간 데이터 공유는 명시 적이어야합니다. 에 대한 사용자 수준의 인터페이스</target>
        </trans-unit>
        <trans-unit id="7d5472f1ffe12c98e459541b4ae02160b6a93b4f" translate="yes" xml:space="preserve">
          <source>). It is &lt;code&gt;S&lt;/code&gt; if there are distinct folds,</source>
          <target state="translated">). 그것은이다 &lt;code&gt;S&lt;/code&gt; 를 별개의 주름이있는 경우,</target>
        </trans-unit>
        <trans-unit id="05a6e878bb179497ab31f32f00f95fb3899c774b" translate="yes" xml:space="preserve">
          <source>). Perl is not strictly a shell because it&amp;rsquo;s not interactive (although Perl programs can be interactive).</source>
          <target state="translated">). Perl은 대화식이 아니기 때문에 셸이 아닙니다 (Perl 프로그램은 대화식 일 수 있음).</target>
        </trans-unit>
        <trans-unit id="042b1859470effcbb8073926a97e8482ad8c8566" translate="yes" xml:space="preserve">
          <source>). President, ZeeGee Software Inc (</source>
          <target state="translated">). ZeeGee Software Inc (</target>
        </trans-unit>
        <trans-unit id="f78cffbbf89f8002aea6399c7a9ddf0dfac97229" translate="yes" xml:space="preserve">
          <source>). So long as</source>
          <target state="translated">). 한</target>
        </trans-unit>
        <trans-unit id="ea5a3d55458bd648431ff33d784b7d2a42d0fac1" translate="yes" xml:space="preserve">
          <source>). The following example computes the SHA-224 digest of the 7-bit message</source>
          <target state="translated">). 다음 예제는 7 비트 메시지의 SHA-224 다이제스트를 계산합니다.</target>
        </trans-unit>
        <trans-unit id="2153ee3bfe39da6fb29d4990a55e42d582ee704f" translate="yes" xml:space="preserve">
          <source>). The subroutine should return either nothing or else a list of up to four values in the following order:</source>
          <target state="translated">). 서브 루틴은 다음 순서로 아무 것도 반환하지 않거나 최대 4 개의 값 목록을 반환해야합니다.</target>
        </trans-unit>
        <trans-unit id="f2791a078af14b6f53c92cc496607d9ac596dc19" translate="yes" xml:space="preserve">
          <source>). These are &lt;b&gt;not&lt;/b&gt; yet available with newlib, the Cygwin libc.</source>
          <target state="translated">). 이들은 &lt;b&gt;하지&lt;/b&gt; newlib에, Cygwin에서의 libc와 아직 사용할.</target>
        </trans-unit>
        <trans-unit id="560023602febe7a40239bc4208c087508750d63d" translate="yes" xml:space="preserve">
          <source>). These ordinals can be accessed via the APIs:</source>
          <target state="translated">). 이 서수는 API를 통해 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b347823ca9f713e85046a6075137cf021c306fdd" translate="yes" xml:space="preserve">
          <source>). This is best demonstrated with this code:</source>
          <target state="translated">). 이것은이 코드로 가장 잘 설명됩니다.</target>
        </trans-unit>
        <trans-unit id="a1d6564a7c3672bec1a1bc0e927d67a7df20f8a1" translate="yes" xml:space="preserve">
          <source>). This is done, as in the examples above, by having the two components separated by an equal sign (or interchangeably, a colon), like &lt;code&gt;\p{Bidi_Class: Left}&lt;/code&gt; .</source>
          <target state="translated">). 이는 위의 예와 같이 &lt;code&gt;\p{Bidi_Class: Left}&lt;/code&gt; 와 같이 등호 (또는 상호 교환 적으로 콜론)로 두 구성 요소를 분리하여 수행됩니다 .</target>
        </trans-unit>
        <trans-unit id="d464c209f218a9aa2625304a1b1d634c64210d1e" translate="yes" xml:space="preserve">
          <source>). This is done, as in the examples above, by having the two components separated by an equal sign (or interchangeably, a colon), like &lt;code&gt;\p{Bidi_Class: Left}&lt;/code&gt;.</source>
          <target state="translated">). 위의 예에서와 같이 &lt;code&gt;\p{Bidi_Class: Left}&lt;/code&gt; 와 같이 두 구성 요소를 등호 (또는 서로 바꿔서 사용할 수있는 콜론)로 구분하여 수행합니다 .</target>
        </trans-unit>
        <trans-unit id="705bf65f5f48be0531b7a87c6aca35d55ff144f4" translate="yes" xml:space="preserve">
          <source>). This means that even if you do not</source>
          <target state="translated">). 이것은 당신이하지 않더라도</target>
        </trans-unit>
        <trans-unit id="d67ecb26991744a9d2868c66788af481b16bc33d" translate="yes" xml:space="preserve">
          <source>). Those flags, and others, are discussed in &lt;a href=&quot;perlcall&quot;&gt;perlcall&lt;/a&gt;.</source>
          <target state="translated">). 이러한 플래그 및 기타 플래그는 &lt;a href=&quot;perlcall&quot;&gt;perlcall&lt;/a&gt; 에서 논의됩니다 .</target>
        </trans-unit>
        <trans-unit id="6aa020a5258af192f5be7bb87b11f10731cd4d0d" translate="yes" xml:space="preserve">
          <source>). You need the latest version of</source>
          <target state="translated">). 최신 버전이 필요합니다</target>
        </trans-unit>
        <trans-unit id="53971837c357909ccaf3a6ac8079d2f764d799a4" translate="yes" xml:space="preserve">
          <source>). cereg.exe (which must be executed on a desktop pc with ActiveSync) is reported not to work on some devices. You have to create the registry entries by hand using a registry editor.</source>
          <target state="translated">). cereg.exe (ActiveSync가 설치된 데스크탑 PC에서 실행해야 함)가 일부 장치에서 작동하지 않는 것으로보고되었습니다. 레지스트리 편집기를 사용하여 수동으로 레지스트리 항목을 작성해야합니다.</target>
        </trans-unit>
        <trans-unit id="fb8631ca8bfdb01c1b65f1b35f5d1a40518d434a" translate="yes" xml:space="preserve">
          <source>);</source>
          <target state="translated">);</target>
        </trans-unit>
        <trans-unit id="1d59027579448d8af6f36a6dc3d4a00baffe8901" translate="yes" xml:space="preserve">
          <source>); or by name via the &lt;code&gt;%+&lt;/code&gt; hash, using &lt;code&gt;&quot;$+{&lt;i&gt;name&lt;/i&gt;}&quot;&lt;/code&gt;.</source>
          <target state="translated">); 또는 &lt;code&gt;&quot;$+{&lt;i&gt;name&lt;/i&gt;}&quot;&lt;/code&gt; &lt;i&gt;name&lt;/i&gt; }&quot;을 사용하여 &lt;code&gt;%+&lt;/code&gt; 해시 를 통한 &lt;i&gt;이름으로&lt;/i&gt; .&lt;i&gt;&lt;/i&gt;</target>
        </trans-unit>
        <trans-unit id="3e0ee17e99cbf2528fa040abfe91674006a4598e" translate="yes" xml:space="preserve">
          <source>); these were automatically generated by the installation process. You may also discover files in the library directory that end in either</source>
          <target state="translated">); 이들은 설치 과정에서 자동으로 생성되었습니다. 라이브러리 디렉토리에서 다음 중 하나로 끝나는 파일을 발견 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="f0f1ab06aabff0dd04ec2e7fdd0330f3f72717ad" translate="yes" xml:space="preserve">
          <source>* $status = $i-&amp;gt;inflate($input, $output [,$eof]) *</source>
          <target state="translated">* $ status = $ i-&amp;gt; 인플레이션 ($ input, $ output [, $ eof]) *</target>
        </trans-unit>
        <trans-unit id="711683a62464c1b947fc95a05857522c610a2052" translate="yes" xml:space="preserve">
          <source>* ($i, $status) = new Compress::Raw::Zlib::Inflate( [OPT] ) *</source>
          <target state="translated">* ($ i, $ status) = 새로운 Compress :: Raw :: Zlib :: Inflate ([OPT]) *</target>
        </trans-unit>
        <trans-unit id="4dca2a4ec9738b1daccbda871474b00c0a111b97" translate="yes" xml:space="preserve">
          <source>* &lt;a href=&quot;I18N::LangTags::List&quot;&gt;I18N::LangTags::List&lt;/a&gt;</source>
          <target state="translated">* &lt;a href=&quot;I18N::LangTags::List&quot;&gt;I18N::LangTags::List&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="662154abd6b12506d6af987521bf74a19afd4fd0" translate="yes" xml:space="preserve">
          <source>* &lt;a href=&quot;langtags/list&quot;&gt;I18N::LangTags::List&lt;/a&gt;</source>
          <target state="translated">* &lt;a href=&quot;langtags/list&quot;&gt;I18N :: LangTags :: 목록&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1f4fa87402fc5d37e84c5d48b561733bfecfda12" translate="yes" xml:space="preserve">
          <source>* Calls to &lt;code&gt;maketext&lt;/code&gt; (as Maketext's main function is called) happen thru a &quot;language session handle&quot;, notionally very much like an IO handle, in that you open one at the start of the session, and use it for &quot;sending signals&quot; to an object in order to have it return the text you want.</source>
          <target state="translated">* &lt;code&gt;maketext&lt;/code&gt; 호출 (Maketext의 주요 함수가 호출 됨)은 &quot;언어 세션 핸들&quot;을 통해 발생합니다. 개념적으로는 IO 핸들과 매우 유사합니다. 원하는 텍스트를 반환하도록하기위한 개체입니다.</target>
        </trans-unit>
        <trans-unit id="53698d1b06e8dd4ae73bc9c6c3f72d465836ed18" translate="yes" xml:space="preserve">
          <source>* Characters regarded as CJK unified ideographs (cf. &lt;code&gt;overrideCJK&lt;/code&gt; ) depend on &lt;code&gt;UCA_Version&lt;/code&gt; .</source>
          <target state="translated">* CJK 통합 표의 문자 ( &lt;code&gt;overrideCJK&lt;/code&gt; 참조 ) 로 간주되는 문자 는 &lt;code&gt;UCA_Version&lt;/code&gt; 에 따라 다릅니다 .</target>
        </trans-unit>
        <trans-unit id="a9f1a19955063b508d912267a743c01876e01d19" translate="yes" xml:space="preserve">
          <source>* Characters regarded as CJK unified ideographs (cf. &lt;code&gt;overrideCJK&lt;/code&gt;) depend on &lt;code&gt;UCA_Version&lt;/code&gt;.</source>
          <target state="translated">* CJK 통합 표의 문자 ( &lt;code&gt;overrideCJK&lt;/code&gt; 참조 ) 로 간주되는 문자 는 &lt;code&gt;UCA_Version&lt;/code&gt; 에 따라 다릅니다 .</target>
        </trans-unit>
        <trans-unit id="7091209d72896e2c39bfe2b79d29762aee8efbde" translate="yes" xml:space="preserve">
          <source>* Check then exit</source>
          <target state="translated">* 확인 후 종료</target>
        </trans-unit>
        <trans-unit id="ff54b7fd765cf7407f178535811ac43fe11764ba" translate="yes" xml:space="preserve">
          <source>* Fully ignorable characters were ignored, and would not interrupt contractions with &lt;code&gt;UCA_Version&lt;/code&gt; 9 and 11.</source>
          <target state="translated">* 무시할 수없는 문자는 무시되었으며 &lt;code&gt;UCA_Version&lt;/code&gt; 9 및 11과의 축소를 방해하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="c482699ba0d9eda15c09384bf56262c0a8ead969" translate="yes" xml:space="preserve">
          <source>* ISO 639-2, &quot;Codes for the representation of names of languages&quot;, including two-letter and three-letter codes, &lt;code&gt;&lt;a href=&quot;http://www.loc.gov/standards/iso639-2/php/code_list.php&quot;&gt;http://www.loc.gov/standards/iso639-2/php/code_list.php&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">* ISO 639-2, 2 자리 및 3 자리 코드를 포함한 &quot;언어 이름 표현을위한 코드&quot;, &lt;code&gt;&lt;a href=&quot;http://www.loc.gov/standards/iso639-2/php/code_list.php&quot;&gt;http://www.loc.gov/standards/iso639-2/php/code_list.php&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c970a3c0abb4e4f41ee7e5d7374c3df2f2d33f28" translate="yes" xml:space="preserve">
          <source>* Locale::Codes, in &lt;code&gt;&lt;a href=&quot;http://www.perl.com/CPAN/modules/by-module/Locale/&quot;&gt;http://www.perl.com/CPAN/modules/by-module/Locale/&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">* 로캘 :: 코드, &lt;code&gt;&lt;a href=&quot;http://www.perl.com/CPAN/modules/by-module/Locale/&quot;&gt;http://www.perl.com/CPAN/modules/by-module/Locale/&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1a89954fdb3af5eae5e55d02be3ce39795c43b97" translate="yes" xml:space="preserve">
          <source>* Many hangul jamo are assigned at &lt;code&gt;UCA_Version&lt;/code&gt; 20, that will affect &lt;code&gt;hangul_terminator&lt;/code&gt; .</source>
          <target state="translated">* 많은 한글 &lt;code&gt;UCA_Version&lt;/code&gt; 20에 할당되어 hangul_terminator에 영향을 &lt;code&gt;hangul_terminator&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1ccb2395cd0f2fb802c29014d60803ad3c29470b" translate="yes" xml:space="preserve">
          <source>* Many hangul jamo are assigned at &lt;code&gt;UCA_Version&lt;/code&gt; 20, that will affect &lt;code&gt;hangul_terminator&lt;/code&gt;.</source>
          <target state="translated">* &lt;code&gt;UCA_Version&lt;/code&gt; 20에서는 많은 한글 자모가 할당되어 한글 종결 자에 영향을 &lt;code&gt;hangul_terminator&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3e7cdc6678b63f68f1f731cd796dc594743e79af" translate="yes" xml:space="preserve">
          <source>* Noncharacters (e.g. U+FFFF) are not ignored, and can be overridden since &lt;code&gt;UCA_Version&lt;/code&gt; 22.</source>
          <target state="translated">* 비 문자 (예 : U + FFFF)는 무시되지 않으며 &lt;code&gt;UCA_Version&lt;/code&gt; 22 이후로 무시할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b1c01b3ace60123b87b3f718dd69b661047bea89" translate="yes" xml:space="preserve">
          <source>* Out-of-range codepoints (greater than U+10FFFF) are not ignored, and can be overridden since &lt;code&gt;UCA_Version&lt;/code&gt; 22.</source>
          <target state="translated">* 범위를 벗어난 코드 포인트 (U + 10FFFF보다 큼)는 무시되지 않으며 &lt;code&gt;UCA_Version&lt;/code&gt; 22 부터 무시할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3acf57a3122fd8676139be1b54b77e7a6c0f4419" translate="yes" xml:space="preserve">
          <source>* RFC 2231, &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc2231.txt&quot;&gt;http://www.ietf.org/rfc/rfc2231.txt&lt;/a&gt;&lt;/code&gt;, &quot;MIME Parameter Value and Encoded Word Extensions: Character Sets, Languages, and Continuations&quot;.</source>
          <target state="translated">* RFC 2231, &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc2231.txt&quot;&gt;http://www.ietf.org/rfc/rfc2231.txt&lt;/a&gt;&lt;/code&gt; , &quot;MIME 매개 변수 값 및 인코딩 된 단어 확장자 : 문자 세트, 언어 및 연속&quot;.</target>
        </trans-unit>
        <trans-unit id="7a7d7dbfc55209a71c5f7e824d67a357a6a16bbc" translate="yes" xml:space="preserve">
          <source>* RFC 2277, &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc2277.txt&quot;&gt;http://www.ietf.org/rfc/rfc2277.txt&lt;/a&gt;&lt;/code&gt;, &quot;IETF Policy on Character Sets and Languages&quot;.</source>
          <target state="translated">* RFC 2277, &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc2277.txt&quot;&gt;http://www.ietf.org/rfc/rfc2277.txt&lt;/a&gt;&lt;/code&gt; , &quot;문자 세트 및 언어에 대한 IETF 정책&quot;.</target>
        </trans-unit>
        <trans-unit id="9e8c6c9d9a4f36c517c3f295833e4f6eab416286" translate="yes" xml:space="preserve">
          <source>* RFC 2482, &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc2482.txt&quot;&gt;http://www.ietf.org/rfc/rfc2482.txt&lt;/a&gt;&lt;/code&gt;, &quot;Language Tagging in Unicode Plain Text&quot;.</source>
          <target state="translated">* RFC 2482, &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc2482.txt&quot;&gt;http://www.ietf.org/rfc/rfc2482.txt&lt;/a&gt;&lt;/code&gt; , &quot;유니 코드 일반 텍스트의 언어 태깅&quot;.</target>
        </trans-unit>
        <trans-unit id="a0423bc09cf4060b0b568dded73ce94844a1cdfb" translate="yes" xml:space="preserve">
          <source>* RFC 3066, &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc3066.txt&quot;&gt;http://www.ietf.org/rfc/rfc3066.txt&lt;/a&gt;&lt;/code&gt;, &quot;Tags for the Identification of Languages&quot;. (Obsoletes RFC 1766)</source>
          <target state="translated">* RFC 3066, &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc3066.txt&quot;&gt;http://www.ietf.org/rfc/rfc3066.txt&lt;/a&gt;&lt;/code&gt; , &quot;언어 식별 태그&quot;. (RFC 1766 사용되지 않음)</target>
        </trans-unit>
        <trans-unit id="0d995187844c913f0fc72fa490ae73510b255678" translate="yes" xml:space="preserve">
          <source>* See below &lt;code&gt;long_contraction&lt;/code&gt; with &lt;code&gt;UCA_Version&lt;/code&gt; 22 and 24.</source>
          <target state="translated">* &lt;code&gt;UCA_Version&lt;/code&gt; 22 및 24의 &lt;code&gt;long_contraction&lt;/code&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="623012ecef5bb9b062336a9ae7c0b0f3fc03627e" translate="yes" xml:space="preserve">
          <source>* See below for &lt;code&gt;long_contraction&lt;/code&gt; with &lt;code&gt;UCA_Version&lt;/code&gt; 22 and 24.</source>
          <target state="translated">* 아래를 참조 &lt;code&gt;long_contraction&lt;/code&gt; 와 &lt;code&gt;UCA_Version&lt;/code&gt; 22, 24.</target>
        </trans-unit>
        <trans-unit id="9659d778014dc9fe8cc992c94d2c75debd111108" translate="yes" xml:space="preserve">
          <source>* The IANA list of registered languages (hopefully up-to-date), &lt;code&gt;&lt;a href=&quot;http://www.iana.org/assignments/language-tags&quot;&gt;http://www.iana.org/assignments/language-tags&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">* 등록 된 언어의 IANA 목록 (최신 업데이트), &lt;code&gt;&lt;a href=&quot;http://www.iana.org/assignments/language-tags&quot;&gt;http://www.iana.org/assignments/language-tags&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="74b13d7787d563c4cc93632fd811f53e2f851184" translate="yes" xml:space="preserve">
          <source>* The shorthand uses code in brackets to indicate method calls that should be performed. A full explanation is not in order here, but a few examples will suffice:</source>
          <target state="translated">* 속기는 괄호 안의 코드를 사용하여 수행해야하는 메서드 호출을 나타냅니다. 여기에서는 전체 설명이 순서대로되어 있지 않지만 몇 가지 예만으로 충분합니다.</target>
        </trans-unit>
        <trans-unit id="fc59265402b2bcf12a045f141f3c84d1ac00a64c" translate="yes" xml:space="preserve">
          <source>* There are two exceptions to a bracketed character class matching a single character only. Each requires special handling by Perl to make things work:</source>
          <target state="translated">* 단일 문자 만 일치하는 대괄호 문자 클래스에는 두 가지 예외가 있습니다. 각각은 작업을 수행하기 위해 Perl의 특별한 처리가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="4586f310185f58f7f53d9296e7502d34140c05ef" translate="yes" xml:space="preserve">
          <source>* There is initial support for Log4perl if it is available, but I haven't gone through everything to make the NullLogger work out correctly if Log4perl is not installed.</source>
          <target state="translated">* 사용 가능한 경우 Log4perl에 대한 초기 지원이 있지만 Log4perl이 설치되지 않은 경우 NullLogger가 올바르게 작동하도록 모든 과정을 거치지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="897931bec8a15698dae5c444e1fbf89e322d1e04" translate="yes" xml:space="preserve">
          <source>* Treatment of ignorables after variables and some behaviors were changed at &lt;code&gt;UCA_Version&lt;/code&gt; 9.</source>
          <target state="translated">* &lt;code&gt;UCA_Version&lt;/code&gt; 9 에서 변수 및 일부 동작이 변경된 후 무시할 수있는 처리</target>
        </trans-unit>
        <trans-unit id="4ab6776ec3ae41680389bbd7fdeaf492e64beaea" translate="yes" xml:space="preserve">
          <source>* Warnings switch</source>
          <target state="translated">* 경고 스위치</target>
        </trans-unit>
        <trans-unit id="d39076f93b425658bb7a0773e365b9aebbb6b2dd" translate="yes" xml:space="preserve">
          <source>* When I capture CPAN.pm output, I need to check for errors and report them to the user.</source>
          <target state="translated">* CPAN.pm 출력을 캡처 할 때 오류를 확인하고 사용자에게보고해야합니다.</target>
        </trans-unit>
        <trans-unit id="bf1ce5c5a5f16390fceec5d1cfef5859ae6cb024" translate="yes" xml:space="preserve">
          <source>* Where a value in a %Lexicon hash is a contentful string instead of an anonymous sub (or, conceivably, a coderef), it would be interpreted as a sort of shorthand expression of what the sub does. When accessed for the first time in a session, it is parsed, turned into Perl code, and then eval'd into an anonymous sub; then that sub replaces the original string in that lexicon. (That way, the work of parsing and evaling the shorthand form for a given phrase is done no more than once per session.)</source>
          <target state="translated">* % Lexicon 해시의 값이 익명의 하위 (또는 아마도 coderef) 대신 콘텐츠가있는 문자열 인 경우 하위가 수행하는 작업에 대한 일종의 속기 표현으로 해석됩니다. 세션에서 처음으로 액세스하면 구문 분석되고 Perl 코드로 변환 된 다음 익명의 하위로 평가됩니다. 그러면 해당 하위가 해당 어휘집의 원래 문자열을 대체합니다. (이렇게하면 주어진 구문에 대한 속기 형식을 구문 분석하고 평가하는 작업이 세션 당 한 번만 수행됩니다.)</target>
        </trans-unit>
        <trans-unit id="eb19d00dbb35076b2cfb43afaaa8a44bc7567ca5" translate="yes" xml:space="preserve">
          <source>* an encoding of a formally valid language tag always is a string value that is defined, has length, and is true if considered as a boolean.</source>
          <target state="translated">* 형식적으로 유효한 언어 태그의 인코딩은 항상 정의되고 길이가 있으며 부울로 간주되는 경우 true 인 문자열 값입니다.</target>
        </trans-unit>
        <trans-unit id="d7b33d4317a74846c304b7cc9d62f9ea8e7ce5e2" translate="yes" xml:space="preserve">
          <source>* none noted</source>
          <target state="translated">* 언급되지 않음</target>
        </trans-unit>
        <trans-unit id="2557ef10c9aae34d34a75b9568a7e1eeddc1c5f2" translate="yes" xml:space="preserve">
          <source>* one shot configuration values from the command line</source>
          <target state="translated">* 명령 줄에서 원샷 구성 값</target>
        </trans-unit>
        <trans-unit id="cb89de7628537cdbcdcd2d5c31607dcd65d29209" translate="yes" xml:space="preserve">
          <source>* tags representing different languages never get the same encoding.</source>
          <target state="translated">* 다른 언어를 나타내는 태그는 동일한 인코딩을 얻지 못합니다.</target>
        </trans-unit>
        <trans-unit id="cfc914db0008bc5c5328a3a2456a7e925514bb85" translate="yes" xml:space="preserve">
          <source>* tags representing the same language always get the same encoding.</source>
          <target state="translated">* 같은 언어를 나타내는 태그는 항상 같은 인코딩을받습니다.</target>
        </trans-unit>
        <trans-unit id="f632df7964dda121448ae6e5ca4eb877ed15fde2" translate="yes" xml:space="preserve">
          <source>*$d-&amp;gt;adler32()*</source>
          <target state="translated">*$d-&amp;gt;adler32()*</target>
        </trans-unit>
        <trans-unit id="c35eaa4aaa4b0b36d04700f984d9950b54e08112" translate="yes" xml:space="preserve">
          <source>*$d-&amp;gt;crc32()*</source>
          <target state="translated">*$d-&amp;gt;crc32()*</target>
        </trans-unit>
        <trans-unit id="0c971c521366bf298521a0d1cb12de8653928b4d" translate="yes" xml:space="preserve">
          <source>*$d-&amp;gt;dict_adler()*</source>
          <target state="translated">*$d-&amp;gt;dict_adler()*</target>
        </trans-unit>
        <trans-unit id="64629fc19b2eab3d05adbf52fc5e32abcf625962" translate="yes" xml:space="preserve">
          <source>*$d-&amp;gt;get_BufSize()*</source>
          <target state="translated">*$d-&amp;gt;get_BufSize()*</target>
        </trans-unit>
        <trans-unit id="56aed9950c73a350f4bbada6fc3d5abe3158462a" translate="yes" xml:space="preserve">
          <source>*$d-&amp;gt;get_Level()*</source>
          <target state="translated">*$d-&amp;gt;get_Level()*</target>
        </trans-unit>
        <trans-unit id="3bf087cdc68f5ef42e9bbc91a4a61bc60dd22717" translate="yes" xml:space="preserve">
          <source>*$d-&amp;gt;get_Strategy()*</source>
          <target state="translated">*$d-&amp;gt;get_Strategy()*</target>
        </trans-unit>
        <trans-unit id="6a81c6c52f16a8d6923233b258116bbaae34938f" translate="yes" xml:space="preserve">
          <source>*$d-&amp;gt;msg()*</source>
          <target state="translated">*$d-&amp;gt;msg()*</target>
        </trans-unit>
        <trans-unit id="b63a3f7f425b1954a977386ef5d279e257384ce4" translate="yes" xml:space="preserve">
          <source>*$d-&amp;gt;total_in()*</source>
          <target state="translated">*$d-&amp;gt;total_in()*</target>
        </trans-unit>
        <trans-unit id="7be11abe1a981cdfe5c58e90cbe56c74620650fb" translate="yes" xml:space="preserve">
          <source>*$d-&amp;gt;total_out()*</source>
          <target state="translated">*$d-&amp;gt;total_out()*</target>
        </trans-unit>
        <trans-unit id="d80a4fc42d0165881aa2fa21601335f6a5b174f7" translate="yes" xml:space="preserve">
          <source>*$i-&amp;gt;adler32()*</source>
          <target state="translated">*$i-&amp;gt;adler32()*</target>
        </trans-unit>
        <trans-unit id="68674a7b4388b0adebddc415278aa8a461b56203" translate="yes" xml:space="preserve">
          <source>*$i-&amp;gt;crc32()*</source>
          <target state="translated">*$i-&amp;gt;crc32()*</target>
        </trans-unit>
        <trans-unit id="1660d213fb0cf4bed038244acbc0c77e58a9ffde" translate="yes" xml:space="preserve">
          <source>*$i-&amp;gt;dict_adler()*</source>
          <target state="translated">*$i-&amp;gt;dict_adler()*</target>
        </trans-unit>
        <trans-unit id="ed00afb6796ebd2d75d5fb6836b1271979dc5acd" translate="yes" xml:space="preserve">
          <source>*$i-&amp;gt;msg()*</source>
          <target state="translated">*$i-&amp;gt;msg()*</target>
        </trans-unit>
        <trans-unit id="2b2b2852d7c10fd41b04fd33545a78d54c94f1e6" translate="yes" xml:space="preserve">
          <source>*$i-&amp;gt;total_in()*</source>
          <target state="translated">*$i-&amp;gt;total_in()*</target>
        </trans-unit>
        <trans-unit id="a00928e02457981385f8e4dd086f63b3c7d4708f" translate="yes" xml:space="preserve">
          <source>*$i-&amp;gt;total_out()*</source>
          <target state="translated">*$i-&amp;gt;total_out()*</target>
        </trans-unit>
        <trans-unit id="04bb5391ea5a418de25822f423a009711407d686" translate="yes" xml:space="preserve">
          <source>*$status = $d-&amp;gt;deflate($input, $output)*</source>
          <target state="translated">* $ status = $ d-&amp;gt; delate ($ input, $ output) *</target>
        </trans-unit>
        <trans-unit id="c0ba780f9e7693de09966236201daf25c2601f99" translate="yes" xml:space="preserve">
          <source>*$status = $d-&amp;gt;deflateParams([OPT])*</source>
          <target state="translated">* $ status = $ d-&amp;gt; deflateParams ([OPT]) *</target>
        </trans-unit>
        <trans-unit id="254a6aafb8b04918fd23639de431468d8ff29ccd" translate="yes" xml:space="preserve">
          <source>*$status = $d-&amp;gt;deflateReset() *</source>
          <target state="translated">* $ status = $ d-&amp;gt; deflateReset () *</target>
        </trans-unit>
        <trans-unit id="d497a45f9cb78ca6b50b3a7e156fd6b9c7fb384d" translate="yes" xml:space="preserve">
          <source>*$status = $d-&amp;gt;deflateTune($good_length, $max_lazy, $nice_length, $max_chain)*</source>
          <target state="translated">* $ status = $ d-&amp;gt; deflateTune ($ good_length, $ max_lazy, $ nice_length, $ max_chain) *</target>
        </trans-unit>
        <trans-unit id="141b772af4aeeaea008ed027db1ed7bde5ce5676" translate="yes" xml:space="preserve">
          <source>*$status = $d-&amp;gt;flush($output [, $flush_type]) *</source>
          <target state="translated">* $ status = $ d-&amp;gt; flush ($ output [, $ flush_type]) *</target>
        </trans-unit>
        <trans-unit id="74f8a4eb98878730ef2f86aea42e666e1ee160bc" translate="yes" xml:space="preserve">
          <source>*$status = $i-&amp;gt;inflateReset() *</source>
          <target state="translated">* $ status = $ i-&amp;gt; inflateReset () *</target>
        </trans-unit>
        <trans-unit id="9db33bbf75bca37e8376afc3d73136b2ed6357e1" translate="yes" xml:space="preserve">
          <source>*$status = $i-&amp;gt;inflateSync($buffer)*</source>
          <target state="translated">* $ status = $ i-&amp;gt; inflateSync ($ 버퍼) *</target>
        </trans-unit>
        <trans-unit id="112c6b855140730d98a28cbfad625ebe4443a357" translate="yes" xml:space="preserve">
          <source>*$status = $i-&amp;gt;inflateSync($input)*</source>
          <target state="translated">* $ status = $ i-&amp;gt; inflateSync ($ 입력) *</target>
        </trans-unit>
        <trans-unit id="ac1cc2e7b1d14736f7f3c26c35c1e7b862a74263" translate="yes" xml:space="preserve">
          <source>*($d, $status) = deflateInit( [OPT] )*</source>
          <target state="translated">* ($ d, $ status) = deflateInit ([OPT]) *</target>
        </trans-unit>
        <trans-unit id="a1e0d6d4dfa07bb414b033b626ca0cac87b1dd85" translate="yes" xml:space="preserve">
          <source>*($d, $status) = new Compress::Raw::Zlib::Deflate( [OPT] ) *</source>
          <target state="translated">* ($ d, $ status) = new Compress :: Raw :: Zlib :: Deflate ([OPT]) *</target>
        </trans-unit>
        <trans-unit id="3374bc8edae5ea56b3cf3599aae276d721728d25" translate="yes" xml:space="preserve">
          <source>*($i, $status) = inflateInit()*</source>
          <target state="translated">* ($ i, $ status) = 인플레이션 초기화 () *</target>
        </trans-unit>
        <trans-unit id="10ad095b48dbd0069e2864202f1242314d07a5ef" translate="yes" xml:space="preserve">
          <source>*($out, $status) = $d-&amp;gt;deflate($buffer)*</source>
          <target state="translated">* ($ out, $ status) = $ d-&amp;gt; delate ($ buffer) *</target>
        </trans-unit>
        <trans-unit id="abc6e06c1d13c4e3bda0992462832a237f5a44c8" translate="yes" xml:space="preserve">
          <source>*($out, $status) = $d-&amp;gt;flush()* =head2 *($out, $status) = $d-&amp;gt;flush($flush_type)*</source>
          <target state="translated">* ($ out, $ status) = $ d-&amp;gt; flush () * = head2 * ($ out, $ status) = $ d-&amp;gt; flush ($ flush_type) *</target>
        </trans-unit>
        <trans-unit id="3c4770a854a915518ba1ea48502e3961a3be7950" translate="yes" xml:space="preserve">
          <source>*($out, $status) = $i-&amp;gt;inflate($buffer)*</source>
          <target state="translated">* ($ out, $ status) = $ i-&amp;gt; 인플레이션 ($ buffer) *</target>
        </trans-unit>
        <trans-unit id="40f47eef273f34142764782337cff559ed807120" translate="yes" xml:space="preserve">
          <source>** If you are unfamiliar with testing &lt;b&gt;read &lt;a href=&quot;Test::Tutorial&quot;&gt;Test::Tutorial&lt;/a&gt; first!&lt;/b&gt; **</source>
          <target state="translated">** 테스트에 익숙하지 않은 경우 &lt;b&gt;먼저 &lt;/b&gt;&lt;b&gt;&lt;a href=&quot;Test::Tutorial&quot;&gt;Test :: Tutorial을&lt;/a&gt;&lt;/b&gt;&lt;b&gt; 읽으십시오 ! &lt;/b&gt;**</target>
        </trans-unit>
        <trans-unit id="0d672a53a05ad4df9358326135542cc74a9d72d5" translate="yes" xml:space="preserve">
          <source>** If you are unfamiliar with testing &lt;b&gt;read &lt;a href=&quot;tutorial&quot;&gt;Test::Tutorial&lt;/a&gt; first!&lt;/b&gt; **</source>
          <target state="translated">** 테스트에 익숙하지 않은 경우 &lt;b&gt;&lt;a href=&quot;tutorial&quot;&gt;Test :: Tutorial을&lt;/a&gt;&lt;/b&gt;&lt;b&gt; 먼저 &lt;/b&gt;&lt;b&gt;읽으십시오 ! &lt;/b&gt;**</target>
        </trans-unit>
        <trans-unit id="6fb8eb5f7fd0333449dafeec8a54ea4e28516ebb" translate="yes" xml:space="preserve">
          <source>***INTERNALS NOTE***</source>
          <target state="translated">*** 내부 참고 사항 ***</target>
        </trans-unit>
        <trans-unit id="8b29010790c714176ac46c130dfb61773e0c13e0" translate="yes" xml:space="preserve">
          <source>*.PL</source>
          <target state="translated">*.PL</target>
        </trans-unit>
        <trans-unit id="5c455cfeca9fc61305db058d5b67796ca3d8f994" translate="yes" xml:space="preserve">
          <source>*.t</source>
          <target state="translated">*.t</target>
        </trans-unit>
        <trans-unit id="e06fa715f3e3bd676f73309b058b71ea1c00418c" translate="yes" xml:space="preserve">
          <source>*/man/</source>
          <target state="translated">*/man/</target>
        </trans-unit>
        <trans-unit id="030b7462745046bec4a3476bbbd9b7c622cb263d" translate="yes" xml:space="preserve">
          <source>*AutoLoader* vs. *SelfLoader*</source>
          <target state="translated">* AutoLoader * 대 * SelfLoader *</target>
        </trans-unit>
        <trans-unit id="b6da558cc8e40a9588c5a25bffee14e91b6e21e0" translate="yes" xml:space="preserve">
          <source>*Blocks versus Scripts*</source>
          <target state="translated">* 블록 대 스크립트 *</target>
        </trans-unit>
        <trans-unit id="6a49ec15388c609953d1dfeb20a9de1712f85c3d" translate="yes" xml:space="preserve">
          <source>*Matching Scripts and Blocks*</source>
          <target state="translated">* 매칭 스크립트 및 블록 *</target>
        </trans-unit>
        <trans-unit id="cb8fc69d4856a82c9d0d539da68de93134a668e2" translate="yes" xml:space="preserve">
          <source>*NOTE* You are strongly discouraged from using this function in non-test code and especially discouraged from using the set form of this function. The results of doing so may result in segmentation faults or other undefined behavior.</source>
          <target state="translated">* 참고 * 테스트가 아닌 코드에서이 함수를 사용하지 않는 것이 좋습니다. 특히이 함수의 집합 형식을 사용하지 않는 것이 좋습니다. 그 결과 분할 오류 또는 기타 정의되지 않은 동작이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4dbc7db62720fd7c360f08690c42352d5d4fde10" translate="yes" xml:space="preserve">
          <source>*Pod::InteriorSequence*</source>
          <target state="translated">*Pod::InteriorSequence*</target>
        </trans-unit>
        <trans-unit id="bd484e6a3fa2a69cf1b2fa912e8c64e369203cf3" translate="yes" xml:space="preserve">
          <source>*Pod::Paragraph*</source>
          <target state="translated">*Pod::Paragraph*</target>
        </trans-unit>
        <trans-unit id="f6118e75f44bd9c2e2e7a4dbaf8b93141735b0c7" translate="yes" xml:space="preserve">
          <source>*Pod::ParseTree*</source>
          <target state="translated">*Pod::ParseTree*</target>
        </trans-unit>
        <trans-unit id="a839f625dd453146a9ced9341bbff5ba4836fc73" translate="yes" xml:space="preserve">
          <source>*Warning*</source>
          <target state="translated">*Warning*</target>
        </trans-unit>
        <trans-unit id="39c05f977c871385cfb2ac67c7071d2d0749325c" translate="yes" xml:space="preserve">
          <source>*add_selection()*</source>
          <target state="translated">*add_selection()*</target>
        </trans-unit>
        <trans-unit id="22677ec6b58cd6de560696c1281301c8215b2261" translate="yes" xml:space="preserve">
          <source>*all_casefolds()*</source>
          <target state="translated">*all_casefolds()*</target>
        </trans-unit>
        <trans-unit id="495bb86a56fbdcbecef4efb0a07e0fb5a52d90bb" translate="yes" xml:space="preserve">
          <source>*begin_input()*</source>
          <target state="translated">*begin_input()*</target>
        </trans-unit>
        <trans-unit id="21491eaf691d94ff4dc5e18150f5741423ca33f3" translate="yes" xml:space="preserve">
          <source>*begin_pod()*</source>
          <target state="translated">*begin_pod()*</target>
        </trans-unit>
        <trans-unit id="e63f038d7ccfb8b7ed87a3e9a94136cc3acbaa84" translate="yes" xml:space="preserve">
          <source>*bidi_types()*</source>
          <target state="translated">*bidi_types()*</target>
        </trans-unit>
        <trans-unit id="3323378f9f296b7e09bbde8389f91b3f2e90a612" translate="yes" xml:space="preserve">
          <source>*casefold()*</source>
          <target state="translated">*casefold()*</target>
        </trans-unit>
        <trans-unit id="a382525e3184f3292d70ce3e64c30b550c9d60ca" translate="yes" xml:space="preserve">
          <source>*casespec()*</source>
          <target state="translated">*casespec()*</target>
        </trans-unit>
        <trans-unit id="2acb520d2f999e48e1e23f31071debab4019805a" translate="yes" xml:space="preserve">
          <source>*charblock()*</source>
          <target state="translated">*charblock()*</target>
        </trans-unit>
        <trans-unit id="5a1a95773194bbecc12f391b4130725b29ef1d4a" translate="yes" xml:space="preserve">
          <source>*charblocks()*</source>
          <target state="translated">*charblocks()*</target>
        </trans-unit>
        <trans-unit id="892910658fd4f7c8f9957928bae7464e9f794524" translate="yes" xml:space="preserve">
          <source>*charinfo()*</source>
          <target state="translated">*charinfo()*</target>
        </trans-unit>
        <trans-unit id="298c43cb9d5cbe40f064250a448e61dd4cb8783e" translate="yes" xml:space="preserve">
          <source>*charinrange()*</source>
          <target state="translated">*charinrange()*</target>
        </trans-unit>
        <trans-unit id="98a743c2f5c3d0d1a69423f01cff293fd38d8edb" translate="yes" xml:space="preserve">
          <source>*charprop()*</source>
          <target state="translated">*charprop()*</target>
        </trans-unit>
        <trans-unit id="aff3e7777f49ee087b89c8a05dbee3af17a26546" translate="yes" xml:space="preserve">
          <source>*charprops_all()*</source>
          <target state="translated">*charprops_all()*</target>
        </trans-unit>
        <trans-unit id="2096c542c885e6ff5b205d9c49075754580714c3" translate="yes" xml:space="preserve">
          <source>*charscript()*</source>
          <target state="translated">*charscript()*</target>
        </trans-unit>
        <trans-unit id="95242ddcdfaf5eacd2a726f8aaa11d7bc03daf57" translate="yes" xml:space="preserve">
          <source>*charscripts()*</source>
          <target state="translated">*charscripts()*</target>
        </trans-unit>
        <trans-unit id="e4821a2674ad1d26afcb87813851f804da9f5ead" translate="yes" xml:space="preserve">
          <source>*ckfun_p</source>
          <target state="translated">*ckfun_p</target>
        </trans-unit>
        <trans-unit id="0b5ab6a4a90ff2c6437322fa15586407ef2b4d11" translate="yes" xml:space="preserve">
          <source>*ckobj_p</source>
          <target state="translated">*ckobj_p</target>
        </trans-unit>
        <trans-unit id="5f7f65bb7d96d645f65805f5d460c10a6f06b354" translate="yes" xml:space="preserve">
          <source>*clear_selections()*</source>
          <target state="translated">*clear_selections()*</target>
        </trans-unit>
        <trans-unit id="5d9dc7c769c9e8f4cbeee5398ed00b6384904253" translate="yes" xml:space="preserve">
          <source>*command()*</source>
          <target state="translated">*command()*</target>
        </trans-unit>
        <trans-unit id="a139e96d8189b5a55d4a4e8e2d33902d4d0c5b9d" translate="yes" xml:space="preserve">
          <source>*compexcl()*</source>
          <target state="translated">*compexcl()*</target>
        </trans-unit>
        <trans-unit id="1b540946e2151155f214582cd243507ba7640019" translate="yes" xml:space="preserve">
          <source>*curr_headings()*</source>
          <target state="translated">*curr_headings()*</target>
        </trans-unit>
        <trans-unit id="b44c1e16cdabb8e05ed00563725662b1898a3124" translate="yes" xml:space="preserve">
          <source>*cutting()*</source>
          <target state="translated">*cutting()*</target>
        </trans-unit>
        <trans-unit id="1ddba136bdb0a3b6dbf3f58b0168d4a9181d08fc" translate="yes" xml:space="preserve">
          <source>*end_input()*</source>
          <target state="translated">*end_input()*</target>
        </trans-unit>
        <trans-unit id="a5f7375fd2de061c65ad2bf50ef73effa4294574" translate="yes" xml:space="preserve">
          <source>*end_pod()*</source>
          <target state="translated">*end_pod()*</target>
        </trans-unit>
        <trans-unit id="1d38830083f7ab5197ea4473920fe3ec232e92e5" translate="yes" xml:space="preserve">
          <source>*errorsub()*</source>
          <target state="translated">*errorsub()*</target>
        </trans-unit>
        <trans-unit id="83ae438f6c5d4adfa7da1a2ac708671df372b4bb" translate="yes" xml:space="preserve">
          <source>*filter() and anonymous sub*</source>
          <target state="translated">* filter () 및 익명 하위 *</target>
        </trans-unit>
        <trans-unit id="c5d36b4a9ac4410d0011698855500ff129fe6378" translate="yes" xml:space="preserve">
          <source>*filter_add()*</source>
          <target state="translated">*filter_add()*</target>
        </trans-unit>
        <trans-unit id="c590fd9b9ee4cb77f8c87dcc99cff21706f50d16" translate="yes" xml:space="preserve">
          <source>*flags</source>
          <target state="translated">*flags</target>
        </trans-unit>
        <trans-unit id="87bf87677970cfb50487269d83b12971442cad62" translate="yes" xml:space="preserve">
          <source>*general_categories()*</source>
          <target state="translated">*general_categories()*</target>
        </trans-unit>
        <trans-unit id="c8093d60d704e74fc21bb32d9a8ddd7a40063485" translate="yes" xml:space="preserve">
          <source>*import()*</source>
          <target state="translated">*import()*</target>
        </trans-unit>
        <trans-unit id="4af0e2a6bb704b69c7748e25de2a62d813d13313" translate="yes" xml:space="preserve">
          <source>*initialize()*</source>
          <target state="translated">*initialize()*</target>
        </trans-unit>
        <trans-unit id="a26c0f1de05a3c3080ce231702af1d37d1ffdcef" translate="yes" xml:space="preserve">
          <source>*input_file()*</source>
          <target state="translated">*input_file()*</target>
        </trans-unit>
        <trans-unit id="7b32820eda1a4cbba59b3c51ef02fe178f80b148" translate="yes" xml:space="preserve">
          <source>*input_handle()*</source>
          <target state="translated">*input_handle()*</target>
        </trans-unit>
        <trans-unit id="37cf554dca7439d60a53244dbe9a6f6f66666dbc" translate="yes" xml:space="preserve">
          <source>*interior_sequence()*</source>
          <target state="translated">*interior_sequence()*</target>
        </trans-unit>
        <trans-unit id="c16b57ca8bb2b15c81ee7888fb0cc3c088fd5605" translate="yes" xml:space="preserve">
          <source>*interpolate()*</source>
          <target state="translated">*interpolate()*</target>
        </trans-unit>
        <trans-unit id="1c763b56009fbad09ca114bbc6ad819659ad6849" translate="yes" xml:space="preserve">
          <source>*is_selected()*</source>
          <target state="translated">*is_selected()*</target>
        </trans-unit>
        <trans-unit id="950f1ac016fdc438a26ebe09acd34140f5d0a0b3" translate="yes" xml:space="preserve">
          <source>*len</source>
          <target state="translated">*len</target>
        </trans-unit>
        <trans-unit id="beaf32cf7b2e540d90a96b6fc45fac3a314cd55f" translate="yes" xml:space="preserve">
          <source>*len_p</source>
          <target state="translated">*len_p</target>
        </trans-unit>
        <trans-unit id="d670fa291475b584f9b4236a8ddfefd0211dcd71" translate="yes" xml:space="preserve">
          <source>*match_section()*</source>
          <target state="translated">*match_section()*</target>
        </trans-unit>
        <trans-unit id="159da2978736cbc50e92916d4ff2e95e3a6a3290" translate="yes" xml:space="preserve">
          <source>*namedseq()*</source>
          <target state="translated">*namedseq()*</target>
        </trans-unit>
        <trans-unit id="6523eee7c8959f955cebf19b0aaf21b556b5b09d" translate="yes" xml:space="preserve">
          <source>*new()*</source>
          <target state="translated">*new()*</target>
        </trans-unit>
        <trans-unit id="999e9b24506786f32dd08362c3037e9728f69c8e" translate="yes" xml:space="preserve">
          <source>*num()*</source>
          <target state="translated">*num()*</target>
        </trans-unit>
        <trans-unit id="7834a1138a40b68be0feedf680b5fc18cc6f66fd" translate="yes" xml:space="preserve">
          <source>*old_checker_p</source>
          <target state="translated">*old_checker_p</target>
        </trans-unit>
        <trans-unit id="3f69d68aed17e619c04ffa05320c5c7f0a776f85" translate="yes" xml:space="preserve">
          <source>*output_file()*</source>
          <target state="translated">*output_file()*</target>
        </trans-unit>
        <trans-unit id="068f4b4b0837c6d09f198f53062edaca42ca04da" translate="yes" xml:space="preserve">
          <source>*output_handle()*</source>
          <target state="translated">*output_handle()*</target>
        </trans-unit>
        <trans-unit id="e31580f4b34415c38c50584a8776797a08860c70" translate="yes" xml:space="preserve">
          <source>*parse_from_file()*</source>
          <target state="translated">*parse_from_file()*</target>
        </trans-unit>
        <trans-unit id="0e4cafcb90bfc690fd27784f3955de4a3db5693b" translate="yes" xml:space="preserve">
          <source>*parse_from_filehandle()*</source>
          <target state="translated">*parse_from_filehandle()*</target>
        </trans-unit>
        <trans-unit id="d75b3a0e94d1dfb9614e94eb5cd073abcca5f774" translate="yes" xml:space="preserve">
          <source>*parse_text()*</source>
          <target state="translated">*parse_text()*</target>
        </trans-unit>
        <trans-unit id="7e9078f3ae0ce35ce16daab81c0d4418d0c4ed4f" translate="yes" xml:space="preserve">
          <source>*parseopts()*</source>
          <target state="translated">*parseopts()*</target>
        </trans-unit>
        <trans-unit id="3da2f47adeba78e93b545821850c23066406dbeb" translate="yes" xml:space="preserve">
          <source>*podselect()*</source>
          <target state="translated">*podselect()*</target>
        </trans-unit>
        <trans-unit id="78275badea2a77aee3c8465d83cc3c29a208ed8e" translate="yes" xml:space="preserve">
          <source>*preprocess_line()*</source>
          <target state="translated">*preprocess_line()*</target>
        </trans-unit>
        <trans-unit id="e7392b32b770b3c307b1ac3aae8f31c9a2750031" translate="yes" xml:space="preserve">
          <source>*preprocess_paragraph()*</source>
          <target state="translated">*preprocess_paragraph()*</target>
        </trans-unit>
        <trans-unit id="1e0522e99f043488d01967be6bf4f6d936d08801" translate="yes" xml:space="preserve">
          <source>*prop_aliases()*</source>
          <target state="translated">*prop_aliases()*</target>
        </trans-unit>
        <trans-unit id="d5d69a3ec3326224cb4550ade7aa539c5fb45f01" translate="yes" xml:space="preserve">
          <source>*prop_invlist()*</source>
          <target state="translated">*prop_invlist()*</target>
        </trans-unit>
        <trans-unit id="234f2ef007831363f45ef51c92f38d945d0737d9" translate="yes" xml:space="preserve">
          <source>*prop_invmap()*</source>
          <target state="translated">*prop_invmap()*</target>
        </trans-unit>
        <trans-unit id="df3580135f73b64d1d0f62af129b6dd0b45e63bb" translate="yes" xml:space="preserve">
          <source>*prop_value_aliases()*</source>
          <target state="translated">*prop_value_aliases()*</target>
        </trans-unit>
        <trans-unit id="c188181d7f65501ad8b99f693c9e5ec20c1820a3" translate="yes" xml:space="preserve">
          <source>*prop_values()*</source>
          <target state="translated">*prop_values()*</target>
        </trans-unit>
        <trans-unit id="3f4b3903dff14b7e8a38a7f6ff8d3b0fa7159477" translate="yes" xml:space="preserve">
          <source>*result</source>
          <target state="translated">*result</target>
        </trans-unit>
        <trans-unit id="e290a8472581248e50ff3784a40db196f11140bd" translate="yes" xml:space="preserve">
          <source>*roff</source>
          <target state="translated">*roff</target>
        </trans-unit>
        <trans-unit id="ac8814bb7facb31b6ba9ea89e4e2f1de11aa27af" translate="yes" xml:space="preserve">
          <source>*search_invlist()*</source>
          <target state="translated">*search_invlist()*</target>
        </trans-unit>
        <trans-unit id="f3dfb0ed0691863c50f58061da07cc12a0958750" translate="yes" xml:space="preserve">
          <source>*select()*</source>
          <target state="translated">*select()*</target>
        </trans-unit>
        <trans-unit id="adf407e8d4bdf881ccd7881148dfd072c3a368aa" translate="yes" xml:space="preserve">
          <source>*sob*</source>
          <target state="translated">*sob*</target>
        </trans-unit>
        <trans-unit id="ae2a6aae4f89e2c4aba8b451b3f1c9a851c4e28e" translate="yes" xml:space="preserve">
          <source>*textblock()*</source>
          <target state="translated">*textblock()*</target>
        </trans-unit>
        <trans-unit id="35292c70accf6e1bc4a136d07d88e046e56f7fe0" translate="yes" xml:space="preserve">
          <source>*use Filter::Util::Call*</source>
          <target state="translated">* 필터 사용 :: 유틸리티 :: 전화 *</target>
        </trans-unit>
        <trans-unit id="90337027d7a839db57d3cb410b0b9d7721ba0b7c" translate="yes" xml:space="preserve">
          <source>*verbatim()*</source>
          <target state="translated">*verbatim()*</target>
        </trans-unit>
        <trans-unit id="a979ef10cc6f6a36df6b8a323307ee3bb2e2db9c" translate="yes" xml:space="preserve">
          <source>+</source>
          <target state="translated">+</target>
        </trans-unit>
        <trans-unit id="b84da6d40abc1f06bf25fb9e2240531ded3dac3a" translate="yes" xml:space="preserve">
          <source>++</source>
          <target state="translated">++</target>
        </trans-unit>
        <trans-unit id="5c10b5b2cd673a0616d529aa5234b12ee7153808" translate="yes" xml:space="preserve">
          <source>,</source>
          <target state="translated">,</target>
        </trans-unit>
        <trans-unit id="36bf9f1f4a651e20a84db17e6e502dde5df6f77d" translate="yes" xml:space="preserve">
          <source>, &quot;&lt;code&gt;ls *.txt&lt;/code&gt;&quot; or &quot;&lt;code&gt;dir *.*&lt;/code&gt;&quot;. In Perl, the patterns described by regular expressions are used not only to search strings, but to also extract desired parts of strings, and to do search and replace operations.</source>
          <target state="translated">, &quot; &lt;code&gt;ls *.txt&lt;/code&gt; &quot;또는 &quot; &lt;code&gt;dir *.*&lt;/code&gt; &quot;. Perl에서 정규식으로 설명 된 패턴은 문자열을 검색 할뿐만 아니라 원하는 문자열 부분을 추출하고 검색 및 바꾸기 작업을 수행하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="e6e0221340c67da9c25f33128b5db67e3221f333" translate="yes" xml:space="preserve">
          <source>, &quot;A + COMBINING RING&quot; is a grapheme cluster with base character &quot;A&quot; and combining character &quot;COMBINING RING, which translates in Danish to &quot;A&quot; with the circle atop it, as in the word &amp;Aring;ngstrom.</source>
          <target state="translated">, &quot;A + COMBINING RING&quot;은 기본 문자 &quot;A&quot;와 &amp;Aring;ngstrom이라는 단어에서와 같이 덴마크어로 &quot;A&quot;로 번역되는 &quot;A&quot;로 번역되는 문자를 결합한 자소 클러스터입니다.</target>
        </trans-unit>
        <trans-unit id="9834fcb181aba28c7b6e23e1a30b0012fd3c7711" translate="yes" xml:space="preserve">
          <source>, &quot;Creating a Perl Debugger&quot;, &lt;a href=&quot;http://www.ddj.com/184404522&quot;&gt;http://www.ddj.com/184404522&lt;/a&gt; , and &quot;Profiling in Perl&quot; &lt;a href=&quot;http://www.ddj.com/184404580&quot;&gt;http://www.ddj.com/184404580&lt;/a&gt; .</source>
          <target state="translated">, &quot;펄 디버거 만들기&quot; &lt;a href=&quot;http://www.ddj.com/184404522&quot;&gt;http://www.ddj.com/184404522&lt;/a&gt; 하고, &quot;펄 프로파일&quot; &lt;a href=&quot;http://www.ddj.com/184404580&quot;&gt;http://www.ddj.com/184404580을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1b632e1d6f728f496e56a5503ca92f66ab5bef88" translate="yes" xml:space="preserve">
          <source>, &quot;the &lt;code&gt;/x&lt;/code&gt; modifier&quot;, even though the delimiter in question might not really be a slash. The modifiers &lt;code&gt;/imnsxadlup&lt;/code&gt; may also be embedded within the regular expression itself using the &lt;code&gt;(?...)&lt;/code&gt; construct, see &lt;a href=&quot;#Extended-Patterns&quot;&gt;&quot;Extended Patterns&quot;&lt;/a&gt; below.</source>
          <target state="translated">, &quot; &lt;code&gt;/x&lt;/code&gt; 수정 자&quot;, 문제의 구분 기호가 실제로 슬래시가 아닐 수도 있습니다. 수정 자 &lt;code&gt;/imnsxadlup&lt;/code&gt; 은 &lt;code&gt;(?...)&lt;/code&gt; 구조를 사용하여 정규식 자체에 포함될 수도 있습니다 . 아래의 &lt;a href=&quot;#Extended-Patterns&quot;&gt;&quot;확장 패턴&quot;을&lt;/a&gt; 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="1ee9b85d69a1a45808d43e30360a8f9162ce4c12" translate="yes" xml:space="preserve">
          <source>, (abbreviated NFC), and the sequence &lt;code&gt;LATIN CAPITAL LETTER A&lt;/code&gt; followed by &lt;code&gt;COMBINING ACUTE ACCENT&lt;/code&gt; represents the same character in</source>
          <target state="translated">, (약식 NFC) 및 시퀀스 &lt;code&gt;LATIN CAPITAL LETTER A&lt;/code&gt; 와 뒤에 &lt;code&gt;COMBINING ACUTE ACCENT&lt;/code&gt; 가 같은 문자를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="730ddc40c82a93777903d7aac75c47f7ae79794b" translate="yes" xml:space="preserve">
          <source>, (places where the code seems to run slowly), change the code with the intention of making it run faster. Using version control software, like &lt;code&gt;subversion&lt;/code&gt; , will ensure no changes are irreversible. It's too easy to fiddle here and fiddle there - don't change too much at any one time or you might not discover which piece of code &lt;b&gt;really&lt;/b&gt; was the slow bit.</source>
          <target state="translated">, (코드가 느리게 실행되는 것처럼 보이는 곳) 더 빠르게 실행되도록 코드를 변경하십시오. &lt;code&gt;subversion&lt;/code&gt; 과 같은 버전 제어 소프트웨어를 사용하면 변경 사항을 되돌릴 수 없습니다. 여기에서 바이올린을 피우는 것은 너무 쉽습니다. 한 번에 너무 많이 변경하지 마십시오 . &lt;b&gt;실제로&lt;/b&gt; 어떤 코드가 &lt;b&gt;실제로&lt;/b&gt; 느린 비트 &lt;b&gt;인지&lt;/b&gt; 발견하지 못할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ee955b751cf3f782cae6274befc7336608afaaf6" translate="yes" xml:space="preserve">
          <source>, (places where the code seems to run slowly), change the code with the intention of making it run faster. Using version control software, like &lt;code&gt;subversion&lt;/code&gt;, will ensure no changes are irreversible. It's too easy to fiddle here and fiddle there - don't change too much at any one time or you might not discover which piece of code &lt;b&gt;really&lt;/b&gt; was the slow bit.</source>
          <target state="translated">, (코드가 느리게 실행되는 것처럼 보이는 곳), 더 빨리 실행되도록 코드를 변경하십시오. &lt;code&gt;subversion&lt;/code&gt; 과 같은 버전 제어 소프트웨어를 사용하면 변경 사항을 되돌릴 수 없습니다. 여기에서 바이올린을 조작하는 것은 너무 쉽습니다. 한 번에 너무 많이 변경하지 마십시오. 그렇지 않으면 어떤 코드가 &lt;b&gt;실제로&lt;/b&gt; 느린 부분인지 발견하지 못할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="256dae5fe812dd0a653073c3c142a5d806f220a4" translate="yes" xml:space="preserve">
          <source>, ...</source>
          <target state="translated">, ...</target>
        </trans-unit>
        <trans-unit id="b189223f9e086284fb9e5a2d4ce238755de8f49e" translate="yes" xml:space="preserve">
          <source>, ...parameters...) and there's no</source>
          <target state="translated">, ... 매개 변수 ...)</target>
        </trans-unit>
        <trans-unit id="7d9c9fe99988b3556a05480d92acc265eff93ca8" translate="yes" xml:space="preserve">
          <source>, ...parameters...), and there's no entry</source>
          <target state="translated">, ... parameters ...) 및 항목이 없습니다.</target>
        </trans-unit>
        <trans-unit id="91498e567e65fc55ee351426beca20dc70eece67" translate="yes" xml:space="preserve">
          <source>, ...parameters...), which should return a string that is generally meant for be used for &quot;output&quot; to the user -- regardless of whether this actually means printing to STDOUT, writing to a file, or putting into a GUI widget.</source>
          <target state="translated">, ... parameters ...)는 실제로 STDOUT에 인쇄하는지, 파일에 쓰거나, GUI 위젯.</target>
        </trans-unit>
        <trans-unit id="68cb9c38401d32e374d45576d1fe16f98edccd5c" translate="yes" xml:space="preserve">
          <source>, &lt;a href=&quot;handle&quot;&gt;IO::Handle&lt;/a&gt;, &lt;a href=&quot;select&quot;&gt;IO::Select&lt;/a&gt;</source>
          <target state="translated">, &lt;a href=&quot;handle&quot;&gt;IO :: Handle&lt;/a&gt; , &lt;a href=&quot;select&quot;&gt;IO :: 선택&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f38c4631f06af453e92ba616992751a1a1e31124" translate="yes" xml:space="preserve">
          <source>, &lt;a href=&quot;http://lexington.pm.org/meetings/022001.html&quot;&gt;http://lexington.pm.org/meetings/022001.html&lt;/a&gt;</source>
          <target state="translated">, &lt;a href=&quot;http://lexington.pm.org/meetings/022001.html&quot;&gt;http://lexington.pm.org/meetings/022001.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="007315ce711051c2a3299693a5a40842913289dd" translate="yes" xml:space="preserve">
          <source>, &lt;a href=&quot;http://www.faqs.org/rfcs/rfc3164.html&quot;&gt;http://www.faqs.org/rfcs/rfc3164.html&lt;/a&gt; -- Please note that this is an informational RFC, and therefore does not specify a standard of any kind.</source>
          <target state="translated">, &lt;a href=&quot;http://www.faqs.org/rfcs/rfc3164.html&quot;&gt;http://www.faqs.org/rfcs/rfc3164.html-&lt;/a&gt; 정보 용 RFC이므로 어떤 종류의 표준도 지정하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d3b3dad532b1f051eeb3fba0becc6bea982f5b86" translate="yes" xml:space="preserve">
          <source>, &lt;a href=&quot;http://www.faqs.org/rfcs/rfc3195.html&quot;&gt;http://www.faqs.org/rfcs/rfc3195.html&lt;/a&gt;</source>
          <target state="translated">, &lt;a href=&quot;http://www.faqs.org/rfcs/rfc3195.html&quot;&gt;http://www.faqs.org/rfcs/rfc3195.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="35d9e0f29d4fed3c7ae0a33dd19ec98ac2183348" translate="yes" xml:space="preserve">
          <source>, &lt;a href=&quot;http://www.stonehenge.com/merlyn/LinuxMag/col75.html&quot;&gt;http://www.stonehenge.com/merlyn/LinuxMag/col75.html&lt;/a&gt; .</source>
          <target state="translated">, &lt;a href=&quot;http://www.stonehenge.com/merlyn/LinuxMag/col75.html&quot;&gt;http://www.stonehenge.com/merlyn/LinuxMag/col75.html&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b47d0918c2a38bd4e2af6702ab10cf50ebd2add8" translate="yes" xml:space="preserve">
          <source>, &lt;a href=&quot;http://www.stonehenge.com/merlyn/UnixReview/col49.html&quot;&gt;http://www.stonehenge.com/merlyn/UnixReview/col49.html&lt;/a&gt; , and &quot;Profiling in Template Toolkit via Overriding&quot; for</source>
          <target state="translated">, &lt;a href=&quot;http://www.stonehenge.com/merlyn/UnixReview/col49.html&quot;&gt;http://www.stonehenge.com/merlyn/UnixReview/col49.html&lt;/a&gt; 및 '재정의를 통한 템플릿 툴킷 프로파일 링'</target>
        </trans-unit>
        <trans-unit id="77f493fddd2000dd703272507a4b40faa84d4ba6" translate="yes" xml:space="preserve">
          <source>, &lt;a href=&quot;perlapio&quot;&gt;perlapio&lt;/a&gt;, &lt;a href=&quot;perlcall&quot;&gt;perlcall&lt;/a&gt;, &lt;a href=&quot;perlclib&quot;&gt;perlclib&lt;/a&gt;, &lt;a href=&quot;perlfilter&quot;&gt;perlfilter&lt;/a&gt;, &lt;a href=&quot;perlguts&quot;&gt;perlguts&lt;/a&gt;, &lt;a href=&quot;perlmroapi&quot;&gt;perlmroapi&lt;/a&gt;, &lt;a href=&quot;perlxs&quot;&gt;perlxs&lt;/a&gt;, &lt;a href=&quot;perlxstut&quot;&gt;perlxstut&lt;/a&gt;, and &lt;a href=&quot;warnings&quot;&gt;warnings&lt;/a&gt;.</source>
          <target state="translated">, &lt;a href=&quot;perlapio&quot;&gt;perlapio&lt;/a&gt; , &lt;a href=&quot;perlcall&quot;&gt;perlcall&lt;/a&gt; , &lt;a href=&quot;perlclib&quot;&gt;perlclib&lt;/a&gt; , &lt;a href=&quot;perlfilter&quot;&gt;perlfilter&lt;/a&gt; , &lt;a href=&quot;perlguts&quot;&gt;perlguts&lt;/a&gt; , &lt;a href=&quot;perlmroapi&quot;&gt;perlmroapi&lt;/a&gt; , &lt;a href=&quot;perlxs&quot;&gt;perlxs&lt;/a&gt; , &lt;a href=&quot;perlxstut&quot;&gt;perlxstut&lt;/a&gt; 및 &lt;a href=&quot;warnings&quot;&gt;경고&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c492919f48867530188fb7d22191a67fbb7c3fa3" translate="yes" xml:space="preserve">
          <source>, &lt;a href=&quot;perldbmfilter&quot;&gt;perldbmfilter&lt;/a&gt;</source>
          <target state="translated">, &lt;a href=&quot;perldbmfilter&quot;&gt;perldbmfilter&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e96b82193d3adc8ae90d1b6a1d39c967eceb5aec" translate="yes" xml:space="preserve">
          <source>, &lt;a href=&quot;spec&quot;&gt;File::Spec&lt;/a&gt;</source>
          <target state="translated">, &lt;a href=&quot;spec&quot;&gt;파일 :: 사양&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1514b4aa12fe2361a1f8dc9777ce0c9c88e9219d" translate="yes" xml:space="preserve">
          <source>, &lt;b&gt;--center&lt;/b&gt;=</source>
          <target state="translated">, &lt;b&gt;--center&lt;/b&gt;=</target>
        </trans-unit>
        <trans-unit id="ec1ec166008e24f1d9c39660e2cb5af534fac4f6" translate="yes" xml:space="preserve">
          <source>, &lt;b&gt;--date&lt;/b&gt;=</source>
          <target state="translated">,- &lt;b&gt;날짜&lt;/b&gt; =</target>
        </trans-unit>
        <trans-unit id="42f4918fdf47fcb3bf2298cfaf6726020d123a5d" translate="yes" xml:space="preserve">
          <source>, &lt;b&gt;--indent=&lt;/b&gt;</source>
          <target state="translated">, &lt;b&gt;--indent=&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="8e69206560eda4dc9b771e2f2fc6b847f1de44ef" translate="yes" xml:space="preserve">
          <source>, &lt;b&gt;--left-margin&lt;/b&gt;=</source>
          <target state="translated">,- &lt;b&gt;왼쪽 여백&lt;/b&gt; =</target>
        </trans-unit>
        <trans-unit id="963a6f7e81b0e00944fb6512ad5545c5fc95976c" translate="yes" xml:space="preserve">
          <source>, &lt;b&gt;--margin&lt;/b&gt;=</source>
          <target state="translated">,- &lt;b&gt;마진&lt;/b&gt; =</target>
        </trans-unit>
        <trans-unit id="3c4d80bbad022d613c85d46b46034b627c202d72" translate="yes" xml:space="preserve">
          <source>, &lt;b&gt;--name&lt;/b&gt;=</source>
          <target state="translated">, &lt;b&gt;--name&lt;/b&gt;=</target>
        </trans-unit>
        <trans-unit id="6a39ce425c6265d1b63b042cb43c0fc901696044" translate="yes" xml:space="preserve">
          <source>, &lt;b&gt;--quotes&lt;/b&gt;=</source>
          <target state="translated">,- &lt;b&gt;따옴표&lt;/b&gt; =</target>
        </trans-unit>
        <trans-unit id="8ad6a104b7bbcf1d20b0bdb3099f6378eac172ee" translate="yes" xml:space="preserve">
          <source>, &lt;b&gt;--release&lt;/b&gt;=</source>
          <target state="translated">, &lt;b&gt;--release&lt;/b&gt;=</target>
        </trans-unit>
        <trans-unit id="7a8e17440a6fd521fa5803c11d3f91fcf6d5947c" translate="yes" xml:space="preserve">
          <source>, &lt;b&gt;--section&lt;/b&gt;=</source>
          <target state="translated">,- &lt;b&gt;섹션&lt;/b&gt; =</target>
        </trans-unit>
        <trans-unit id="871bde3f172b60a4dd3ded3ea41d670678f0dc12" translate="yes" xml:space="preserve">
          <source>, &lt;b&gt;-&lt;/b&gt;</source>
          <target state="translated">, &lt;b&gt;-&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="48c993c3ad6fdcd73107b423983292a0b10d7d43" translate="yes" xml:space="preserve">
          <source>, &lt;b&gt;AutoLoader&lt;/b&gt; will look for perl subroutines &lt;b&gt;POSIX&lt;/b&gt; in</source>
          <target state="translated">, &lt;b&gt;자동로드는&lt;/b&gt; 펄 서브 루틴을 찾을 것이다 &lt;b&gt;POSIX&lt;/b&gt; 에서</target>
        </trans-unit>
        <trans-unit id="38f2da13d7f63c25ad1931eef771da2bdb146cd3" translate="yes" xml:space="preserve">
          <source>, &lt;b&gt;Tgetent&lt;/b&gt; searches the files</source>
          <target state="translated">, &lt;b&gt;Tgetent&lt;/b&gt; 가 파일을 검색합니다</target>
        </trans-unit>
        <trans-unit id="899fa84c73aa4f702ca9b0a2dfa0626dc2a663bf" translate="yes" xml:space="preserve">
          <source>, &lt;code&gt;&quot;/foo\/bar/&quot;&lt;/code&gt;) serves this purpose.</source>
          <target state="translated">, &lt;code&gt;&quot;/foo\/bar/&quot;&lt;/code&gt; )가이 목적을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="1e03ac4e29872e2c267670242061f02f12f57063" translate="yes" xml:space="preserve">
          <source>, &lt;code&gt;$self&lt;/code&gt; , is the same reference that was passed to &lt;code&gt;filter_add&lt;/code&gt; blessed into the filter's package. See the example filters later on for details of using &lt;code&gt;$self&lt;/code&gt; .</source>
          <target state="translated">, &lt;code&gt;$self&lt;/code&gt; 는 필터 패키지에 축복 된 &lt;code&gt;filter_add&lt;/code&gt; 에 전달 된 것과 동일한 참조입니다 . &lt;code&gt;$self&lt;/code&gt; 사용에 대한 자세한 내용은 나중에 필터 예제를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0e40de7f354d2d3eddebe80404f446deabf02880" translate="yes" xml:space="preserve">
          <source>, &lt;code&gt;$self&lt;/code&gt;, is the same reference that was passed to &lt;code&gt;filter_add&lt;/code&gt; blessed into the filter's package. See the example filters later on for details of using &lt;code&gt;$self&lt;/code&gt;.</source>
          <target state="translated">, &lt;code&gt;$self&lt;/code&gt; 는 필터 패키지에 축복 된 &lt;code&gt;filter_add&lt;/code&gt; 에 전달 된 것과 동일한 참조입니다 . &lt;code&gt;$self&lt;/code&gt; 사용에 대한 자세한 내용은 나중에 예제 필터를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="8427e1854cb8f41a7151bfe175750f66c54d8bea" translate="yes" xml:space="preserve">
          <source>, &lt;code&gt;%ENV&lt;/code&gt;, &lt;code&gt;$1&lt;/code&gt;, &lt;code&gt;tie&lt;/code&gt;) gets copied, value magic doesn't (</source>
          <target state="translated">, &lt;code&gt;%ENV&lt;/code&gt; , &lt;code&gt;$1&lt;/code&gt; , &lt;code&gt;tie&lt;/code&gt; )는 복사되고 value magic은 복사되지 않습니다 (</target>
        </trans-unit>
        <trans-unit id="ae56078784168c372862d15f35078dd7477dd624" translate="yes" xml:space="preserve">
          <source>, &lt;code&gt;&amp;ndash;a &amp;ndash;b &amp;ndash;c&lt;/code&gt; ) into one switch (</source>
          <target state="translated">, &lt;code&gt;&amp;ndash;a &amp;ndash;b &amp;ndash;c&lt;/code&gt; )를 하나의 스위치 (</target>
        </trans-unit>
        <trans-unit id="6b9c9a7b2e7232a0d7ec8201b3b9a47fc17217c2" translate="yes" xml:space="preserve">
          <source>, &lt;code&gt;&amp;ndash;a &amp;ndash;b &amp;ndash;c&lt;/code&gt;) into one switch (</source>
          <target state="translated">, &lt;code&gt;&amp;ndash;a &amp;ndash;b &amp;ndash;c&lt;/code&gt; )를 하나의 스위치 (</target>
        </trans-unit>
        <trans-unit id="2809b44d364e51b37846cda09da4d124638daab2" translate="yes" xml:space="preserve">
          <source>, &lt;code&gt;&amp;ndash;abc&lt;/code&gt; ). Any switch with an additional &lt;b&gt;argument&lt;/b&gt; must be the last switch in a cluster.</source>
          <target state="translated">, &lt;code&gt;&amp;ndash;abc&lt;/code&gt; ). 추가 &lt;b&gt;인수가&lt;/b&gt; 있는 스위치는 클러스터의 마지막 스위치 여야합니다.</target>
        </trans-unit>
        <trans-unit id="55a2da4f7e069e28b422044a34a1371b0b31a095" translate="yes" xml:space="preserve">
          <source>, &lt;code&gt;&amp;ndash;abc&lt;/code&gt;). Any switch with an additional &lt;b&gt;argument&lt;/b&gt; must be the last switch in a cluster.</source>
          <target state="translated">, &lt;code&gt;&amp;ndash;abc&lt;/code&gt; ). 추가 &lt;b&gt;인수가&lt;/b&gt; 있는 모든 스위치 는 클러스터의 마지막 스위치 여야합니다.</target>
        </trans-unit>
        <trans-unit id="6c7155a3acee3001fa967b3890eeeda3999c4b72" translate="yes" xml:space="preserve">
          <source>, &lt;code&gt;(?-i)&lt;/code&gt;. Modifiers can also be combined into a single expression,</source>
          <target state="translated">, &lt;code&gt;(?-i)&lt;/code&gt; . 수정자는 단일 표현식으로 결합 될 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="ca162894968f42d426c9ba604ea288c5c07916e2" translate="yes" xml:space="preserve">
          <source>, &lt;code&gt;(?s-i)&lt;/code&gt; turns on single line mode and turns off case insensitivity.</source>
          <target state="translated">, &lt;code&gt;(?s-i)&lt;/code&gt; 는 단일 회선 모드를 켜고 대소 문자를 구분하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0ad542fba4a49b259c0748e429b369dce74c977b" translate="yes" xml:space="preserve">
          <source>, &lt;code&gt;Encode::FB_DEFAULT&lt;/code&gt; (== 0) is assumed.</source>
          <target state="translated">, &lt;code&gt;Encode::FB_DEFAULT&lt;/code&gt; (== 0)로 가정합니다.</target>
        </trans-unit>
        <trans-unit id="462879d51e479543994a8d4e84eeab49f5f2f27d" translate="yes" xml:space="preserve">
          <source>, &lt;code&gt;PLUS(7)&lt;/code&gt;. The middle lines describe some heuristics and optimizations performed before a match:</source>
          <target state="translated">, &lt;code&gt;PLUS(7)&lt;/code&gt; . 중간 줄은 일치 전에 수행 된 몇 가지 휴리스틱 및 최적화를 설명합니다.</target>
        </trans-unit>
        <trans-unit id="16d7d30fa0d27a63585cee71ee6b5e5bab0abd13" translate="yes" xml:space="preserve">
          <source>, &lt;code&gt;[:^digit:]&lt;/code&gt; corresponds to &lt;code&gt;\D&lt;/code&gt; and, under Unicode, &lt;code&gt;\P{IsDigit}&lt;/code&gt;. The Unicode and POSIX character classes can be used just like &lt;code&gt;\d&lt;/code&gt;, with the exception that POSIX character classes can only be used inside of a character class:</source>
          <target state="translated">, &lt;code&gt;[:^digit:]&lt;/code&gt; 는 &lt;code&gt;\D&lt;/code&gt; 해당하고 유니 코드에서는 &lt;code&gt;\P{IsDigit}&lt;/code&gt; 합니다. 유니 코드 및 POSIX 문자 클래스는 &lt;code&gt;\d&lt;/code&gt; 처럼 사용할 수 있습니다. 단 , POSIX 문자 클래스는 문자 클래스 내에서만 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="88dea9f45a2209f980bb3d2c13235b80b772b94e" translate="yes" xml:space="preserve">
          <source>, &lt;code&gt;\033&lt;/code&gt;, or hexadecimal escape sequence,</source>
          <target state="translated">, &lt;code&gt;\033&lt;/code&gt; 또는 16 진수 이스케이프 시퀀스,</target>
        </trans-unit>
        <trans-unit id="6c837892673073287d136dd02c954759c5482035" translate="yes" xml:space="preserve">
          <source>, &lt;code&gt;\x1B&lt;/code&gt; may be a more natural representation for your bytes. Here are some examples of escapes:</source>
          <target state="translated">, &lt;code&gt;\x1B&lt;/code&gt; 는 바이트를 더 자연스럽게 표현할 수 있습니다. 다음은 이스케이프의 몇 가지 예입니다.</target>
        </trans-unit>
        <trans-unit id="fe3dc5c2f0d585ebe9c77a5ef081a129a7712e00" translate="yes" xml:space="preserve">
          <source>, &lt;code&gt;binmode STDOUT, ':utf8'&lt;/code&gt;. Another way to turn off the warning is to add &lt;code&gt;no warnings 'utf8';&lt;/code&gt; but that is often closer to cheating. In general, you are supposed to explicitly mark the filehandle with an encoding, see &lt;a href=&quot;open&quot;&gt;open&lt;/a&gt; and &lt;a href=&quot;perlfunc#binmode&quot;&gt;&quot;binmode&quot; in perlfunc&lt;/a&gt;.</source>
          <target state="translated">, &lt;code&gt;binmode STDOUT, ':utf8'&lt;/code&gt; . 경고를 끄는 또 다른 방법은 &lt;code&gt;no warnings 'utf8';&lt;/code&gt; 를 추가 하지 않는 것입니다. 그러나 그것은 종종 부정 행위에 더 가깝습니다. 일반적으로 파일 핸들을 인코딩으로 명시 적으로 표시해야합니다 . &lt;a href=&quot;perlfunc#binmode&quot;&gt;perlfunc의 &lt;/a&gt;&lt;a href=&quot;open&quot;&gt;open&lt;/a&gt; 및 &quot;binmode&quot;를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d4b64e63a3c0223fd25236e90f27d457472226a1" translate="yes" xml:space="preserve">
          <source>, &lt;code&gt;code-style&lt;/code&gt; , &lt;a href=&quot;perlfaq&quot;&gt;hyperlinks&lt;/a&gt;, and more. Such codes are explained in the &quot;&lt;a href=&quot;#Formatting-Codes&quot;&gt;Formatting Codes&lt;/a&gt;&quot; section, below.</source>
          <target state="translated">, &lt;code&gt;code-style&lt;/code&gt; , &lt;a href=&quot;perlfaq&quot;&gt;하이퍼 링크&lt;/a&gt; 등이 있습니다. 이러한 코드는 아래 의 &quot; &lt;a href=&quot;#Formatting-Codes&quot;&gt;포맷 코드&lt;/a&gt; &quot;섹션에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="70c100bab44e4cf6cc68ee3c0cb6aa17d6a2a7ac" translate="yes" xml:space="preserve">
          <source>, &lt;code&gt;code-style&lt;/code&gt;, &lt;a href=&quot;perlfaq&quot;&gt;hyperlinks&lt;/a&gt;, and more. Such codes are explained in the &quot;&lt;a href=&quot;#Formatting-Codes&quot;&gt;Formatting Codes&lt;/a&gt;&quot; section, below.</source>
          <target state="translated">, &lt;code&gt;code-style&lt;/code&gt; , &lt;a href=&quot;perlfaq&quot;&gt;하이퍼 링크&lt;/a&gt; 등. 이러한 코드는 아래 의 &quot; &lt;a href=&quot;#Formatting-Codes&quot;&gt;형식화 코드&lt;/a&gt; &quot;섹션에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="70a0b45cf40ff1d2cfe85795b7abbde7954fbe91" translate="yes" xml:space="preserve">
          <source>, &lt;code&gt;qr!!&lt;/code&gt;, &lt;code&gt;qr{}&lt;/code&gt; or &lt;code&gt;qr~~&lt;/code&gt;. Apostrophes as delimiters (&lt;code&gt;qr''&lt;/code&gt;) inhibit any interpolation.</source>
          <target state="translated">, &lt;code&gt;qr!!&lt;/code&gt; , &lt;code&gt;qr{}&lt;/code&gt; 또는 &lt;code&gt;qr~~&lt;/code&gt; . 구분 기호로서의 아포스트로피 ( &lt;code&gt;qr''&lt;/code&gt; )는 보간을 금지합니다.</target>
        </trans-unit>
        <trans-unit id="b697447009b34f13911a7d0d08c9daa31a861e17" translate="yes" xml:space="preserve">
          <source>, &lt;code&gt;taint&lt;/code&gt;, &lt;code&gt;pos&lt;/code&gt;).</source>
          <target state="translated">, &lt;code&gt;taint&lt;/code&gt;, &lt;code&gt;pos&lt;/code&gt;).</target>
        </trans-unit>
        <trans-unit id="2357bd7f4335eff8d8daf0fa1da32b05aadee0e0" translate="yes" xml:space="preserve">
          <source>, C</source>
          <target state="translated">, 씨</target>
        </trans-unit>
        <trans-unit id="4a3b6b54a01d06829186977454076430f1593339" translate="yes" xml:space="preserve">
          <source>, Copyright &amp;copy; 2012 Tom Christiansen &amp;lt;et al.&amp;gt;, 2012-02-13 by O&amp;rsquo;Reilly Media. The code itself is freely redistributable, and you are encouraged to transplant, fold, spindle, and mutilate any of the examples in this manpage however you please for inclusion into your own programs without any encumbrance whatsoever. Acknowledgement via code comment is polite but not required.</source>
          <target state="translated">, 저작권 &amp;copy; 2012 Tom Christiansen &amp;lt;et al.&amp;gt;, 2012-02-13 O'Reilly Media. 코드 자체는 자유롭게 재배포 할 수 있으며이 맨 페이지의 예제를 이식, 접기, 스핀들 및 절단하는 것이 좋습니다. 그러나 어떠한 문제도없이 자신의 프로그램에 포함 시키십시오. 코드 주석을 통한 승인은 정중하지만 필수는 아닙니다.</target>
        </trans-unit>
        <trans-unit id="283d166baa4da2433ea6b8c5023e0c5383a472d9" translate="yes" xml:space="preserve">
          <source>, Fourth Edition, by Tom Christiansen, brian d foy, Larry Wall, &amp;amp; Jon Orwant. Copyright (c) 2000, 1996, 1991, 2012 O'Reilly Media, Inc. This document may be distributed under the same terms as Perl itself.</source>
          <target state="translated">, 제 4 판, Tom Christiansen, brian d foy, Larry Wall 및 Jon Orwant. Copyright (c) 2000, 1996, 1991, 2012 O'Reilly Media, Inc.이 문서는 Perl과 동일한 조건으로 배포 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a4710510ddd5139b0d57b1444caca5a0e1dbc934" translate="yes" xml:space="preserve">
          <source>, Fourth Edition. Words or phrases in bold are defined elsewhere in this glossary.</source>
          <target state="translated">, 제 4 판. 굵게 표시된 단어 나 문구는이 용어집의 다른 곳에 정의되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="eb3f1d4a19fa8c41000422fe5f0f14f333cda54d" translate="yes" xml:space="preserve">
          <source>, I hesitate to make 10 ways to do something&quot;. This is a tricky heuristic to navigate, though--one man's essential addition is another man's pointless cruft.</source>
          <target state="translated">, 나는 무언가를 할 수있는 10 가지 방법을 만드는 것을 망설이고있다.&amp;rdquo;이것은 탐색하기 까다로운 휴리스틱이지만, 한 사람의 필수 추가는 다른 사람의 무의미한 주름이다.</target>
        </trans-unit>
        <trans-unit id="ad45c1c8eec7555ccd92edae836e62ba22314f7b" translate="yes" xml:space="preserve">
          <source>, I used something like this:</source>
          <target state="translated">, 나는 이것을 다음과 같이 사용했다 :</target>
        </trans-unit>
        <trans-unit id="c65991634f6aa7daad894716fa3515f707c0dcd9" translate="yes" xml:space="preserve">
          <source>, January is 0, not 1; Sunday is 0, not 1; January 1st is 0, not 1. The year (&lt;code&gt;year&lt;/code&gt; ) is given in years since 1900,</source>
          <target state="translated">1 월은 1이 아니라 0입니다. 일요일은 1이 아니라 0입니다. 1 월 1 일은 1이 아니라 0입니다. 연도 ( &lt;code&gt;year&lt;/code&gt; )는 1900 년 이후의 연도 단위 로 주어집니다.</target>
        </trans-unit>
        <trans-unit id="278251f0cd32cd452e601bfc7f4ba837feb500cf" translate="yes" xml:space="preserve">
          <source>, January is 0, not 1; Sunday is 0, not 1; January 1st is 0, not 1. The year (&lt;code&gt;year&lt;/code&gt; ) is given in years since 1900;</source>
          <target state="translated">1 월은 1이 아니라 0입니다. 일요일은 1이 아니라 0입니다. 1 월 1 일은 1이 아니라 0입니다. 연도 ( &lt;code&gt;year&lt;/code&gt; )는 1900 년 이후의 연도 입니다.</target>
        </trans-unit>
        <trans-unit id="afb22a315d26614c38a5484f1c55cdc3c2b33492" translate="yes" xml:space="preserve">
          <source>, January is 0, not 1; Sunday is 0, not 1; January 1st is 0, not 1. The year (&lt;code&gt;year&lt;/code&gt;) is given in years since 1900,</source>
          <target state="translated">, 1 월은 1이 아니라 0입니다. 일요일은 1이 아니라 0입니다. 1 월 1 일은 1이 아니라 0입니다. 연도 ( &lt;code&gt;year&lt;/code&gt; )는 1900 년 이후의 연도 로 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="6d424da4b1335ce7612f2b3dc77b65ea06020e9c" translate="yes" xml:space="preserve">
          <source>, January is 0, not 1; Sunday is 0, not 1; January 1st is 0, not 1. The year (&lt;code&gt;year&lt;/code&gt;) is given in years since 1900;</source>
          <target state="translated">, 1 월은 1이 아니라 0입니다. 일요일은 1이 아니라 0입니다. 1 월 1 일은 1이 아니라 0입니다. 연도 ( &lt;code&gt;year&lt;/code&gt; )는 1900 년 이후 연도 로 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="dd182ebc9d81517e21729c826fb7210f389d7052" translate="yes" xml:space="preserve">
          <source>, L</source>
          <target state="translated">, L</target>
        </trans-unit>
        <trans-unit id="7fbf5c6d0f24b18219afd1efb585538657616790" translate="yes" xml:space="preserve">
          <source>, L&amp;lt;:spec&amp;gt;, L&amp;lt;:path&amp;gt;</source>
          <target state="translated">, L &amp;lt;: spec&amp;gt;, L &amp;lt;: path&amp;gt;</target>
        </trans-unit>
        <trans-unit id="cff6989687fa00c2222ce15a90a800a548dbd994" translate="yes" xml:space="preserve">
          <source>, Perl uses the same algorithm as</source>
          <target state="translated">Perl은 다음과 같은 알고리즘을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="df8f77da47481a5590b158d0835c14c3d411493e" translate="yes" xml:space="preserve">
          <source>, Recipe 13.12).</source>
          <target state="translated">레시피 13.12).</target>
        </trans-unit>
        <trans-unit id="6a45be8c0a733008fda1873b6942b65ae06a110b" translate="yes" xml:space="preserve">
          <source>, Tim Kientzle (tkientzle@ddj.com), Dr. Dobb's Journal, Issue 295, January 1999, pp 34-41</source>
          <target state="translated">, Tim Kientzle (tkientzle@ddj.com), Dr. Dobb 's Journal, Issue 295, 1999 년 1 월, pp 34-41</target>
        </trans-unit>
        <trans-unit id="2a5671053104bfa65fdb1b845e8f918f200dbaad" translate="yes" xml:space="preserve">
          <source>, Volume 2, Section 3.4.2, by Donald E. Knuth.</source>
          <target state="translated">, 제 2 권, 3.4.2 절 (Donald E. Knuth).</target>
        </trans-unit>
        <trans-unit id="633875e12973ea9004215c69c80143c016eb22c8" translate="yes" xml:space="preserve">
          <source>, a German magazine dedicated to Perl, at ( &lt;a href=&quot;http://www.foo-magazin.de&quot;&gt;http://www.foo-magazin.de&lt;/a&gt; ). The</source>
          <target state="translated">, Perl 전용 독일 잡지 ( &lt;a href=&quot;http://www.foo-magazin.de&quot;&gt;http://www.foo-magazin.de&lt;/a&gt; ). 그만큼</target>
        </trans-unit>
        <trans-unit id="14297948b11112ed3c840f341ffecd330757f94c" translate="yes" xml:space="preserve">
          <source>, a Perl script which uses the &lt;code&gt;MakeMaker&lt;/code&gt; library modules supplied with Perl to generate a</source>
          <target state="translated">, Perl 과 함께 제공되는 &lt;code&gt;MakeMaker&lt;/code&gt; 라이브러리 모듈을 사용하여</target>
        </trans-unit>
        <trans-unit id="855e80b07db61e1b1fac17edd36f618a095e2b73" translate="yes" xml:space="preserve">
          <source>, a collator via &lt;code&gt;Unicode::Collate-&amp;gt;new( )&lt;/code&gt; should be used; for</source>
          <target state="translated">&lt;code&gt;Unicode::Collate-&amp;gt;new( )&lt;/code&gt; 를 통한 collator를 사용해야합니다. ...에 대한</target>
        </trans-unit>
        <trans-unit id="337354a63807d72c18305c9618bef7795ca2d6b6" translate="yes" xml:space="preserve">
          <source>, a collator via &lt;code&gt;Unicode::Collate-&amp;gt;new(variable =&amp;gt; &quot;non-ignorable&quot;, level =&amp;gt; 3)&lt;/code&gt; .</source>
          <target state="translated">, &lt;code&gt;Unicode::Collate-&amp;gt;new(variable =&amp;gt; &quot;non-ignorable&quot;, level =&amp;gt; 3)&lt;/code&gt; 통한 콜 레이터 .</target>
        </trans-unit>
        <trans-unit id="7a2bbbfba58b32349454cb8b6cc55924756c4724" translate="yes" xml:space="preserve">
          <source>, a collator via &lt;code&gt;Unicode::Collate-&amp;gt;new(variable =&amp;gt; &quot;non-ignorable&quot;, level =&amp;gt; 3)&lt;/code&gt;.</source>
          <target state="translated">, &lt;code&gt;Unicode::Collate-&amp;gt;new(variable =&amp;gt; &quot;non-ignorable&quot;, level =&amp;gt; 3)&lt;/code&gt; 통한 조합기 .</target>
        </trans-unit>
        <trans-unit id="181354d61db1393a6d43dac9c961eb59f80b38ac" translate="yes" xml:space="preserve">
          <source>, a crude but sufficient utility to check the integrity of a UCM file. Check under the Encode/bin directory for this.</source>
          <target state="translated">, UCM 파일의 무결성을 검사하기위한 조잡하지만 충분한 유틸리티입니다. Encode / bin 디렉토리에서이를 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="bb64aa0b1dd472e37df99d4df5d224c083cbbbef" translate="yes" xml:space="preserve">
          <source>, a debug aid which allowed callers to identify themselves. This aid has been superseded by a new build option, &lt;code&gt;PERL_MEM_LOG&lt;/code&gt; (see &lt;a href=&quot;perlhacktips#PERL_MEM_LOG&quot;&gt;&quot;PERL_MEM_LOG&quot; in perlhacktips&lt;/a&gt;). The older API is still there for use in XS modules supporting older perls.</source>
          <target state="translated">, 호출자가 자신을 식별 할 수있는 디버그 지원 도구입니다. 이 지원은 새로운 빌드 옵션 인 &lt;code&gt;PERL_MEM_LOG&lt;/code&gt; 로 대체되었습니다 ( &lt;a href=&quot;perlhacktips#PERL_MEM_LOG&quot;&gt;perlhacktips의 &quot;PERL_MEM_LOG&quot;&lt;/a&gt; 참조 ). 이전 API는 이전 펄을 지원하는 XS 모듈에서 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cc2464c5d3dd253a99582f8c86235ec797d15976" translate="yes" xml:space="preserve">
          <source>, a debug aid which allowed callers to identify themselves. This aid has been superseded by a new build option, PERL_MEM_LOG (see &lt;a href=&quot;perlhacktips#PERL_MEM_LOG&quot;&gt;&quot;PERL_MEM_LOG&quot; in perlhacktips&lt;/a&gt;). The older API is still there for use in XS modules supporting older perls.</source>
          <target state="translated">, 호출자가 자신을 식별 할 수있는 디버그 지원 도구입니다. 이 지원은 새로운 빌드 옵션 인 PERL_MEM_LOG로 대체되었습니다 ( &lt;a href=&quot;perlhacktips#PERL_MEM_LOG&quot;&gt;perlhacktips의 &quot;PERL_MEM_LOG&quot;&lt;/a&gt; 참조 ). 이전 API는 이전 펄을 지원하는 XS 모듈에서 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ee470b6f82053958faf72f7660a0d296d09184d4" translate="yes" xml:space="preserve">
          <source>, a debug aid which allowed callers to identify themselves. This aid has been superseded by a new build option, PERL_MEM_LOG (see &lt;a href=&quot;perlhacktips#PERL_MEM_LOG&quot;&gt;PERL_MEM_LOG in perlhacktips&lt;/a&gt;). The older API is still there for use in XS modules supporting older perls.</source>
          <target state="translated">호출자가 자신을 식별 할 수 있도록하는 디버그 지원 이 지원은 새로운 빌드 옵션 PERL_MEM_LOG로 대체되었습니다 ( &lt;a href=&quot;perlhacktips#PERL_MEM_LOG&quot;&gt;perlhacktips의 PERL_MEM_LOG&lt;/a&gt; 참조 ). 이전 API는 이전 perls를 지원하는 XS 모듈에서 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1c0ccb86f1f831d7dbb113204354539bcbbbe342" translate="yes" xml:space="preserve">
          <source>, a file in the YAML Tiny format (for which, see &lt;a href=&quot;YAML::Tiny&quot;&gt;YAML::Tiny&lt;/a&gt;). Tools that consume distribution metadata from disk should be capable of loading</source>
          <target state="translated">, YAML Tiny 형식의 파일 ( &lt;a href=&quot;YAML::Tiny&quot;&gt;YAML :: Tiny&lt;/a&gt; 참조 ). 디스크에서 배포 메타 데이터를 사용하는 도구는로드 할 수 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="6eab92f00d041b0bb78d6d32d7c43effb305a18c" translate="yes" xml:space="preserve">
          <source>, a fixed number of characters long. Thus &lt;code&gt;(?&amp;lt;=(ab|bc))&lt;/code&gt; is fine, but &lt;code&gt;(?&amp;lt;=(ab)*)&lt;/code&gt; prior to 5.30 is not.</source>
          <target state="translated">, 고정 된 문자 수입니다. 따라서 &lt;code&gt;(?&amp;lt;=(ab|bc))&lt;/code&gt; 는 괜찮지 만 5.30 이전의 &lt;code&gt;(?&amp;lt;=(ab)*)&lt;/code&gt; 는 그렇지 않습니다.</target>
        </trans-unit>
        <trans-unit id="be95971fca9604306918e6af9caf54dadcd9baea" translate="yes" xml:space="preserve">
          <source>, a non-UTF-8 one), a multi-byte character was encountered. Perl considers this character to be the specified Unicode code point. Combining non-UTF-8 locales and Unicode is dangerous. Almost certainly some characters will have two different representations. For example, in the ISO 8859-7 (Greek) locale, the code point 0xC3 represents a Capital Gamma. But so also does 0x393. This will make string comparisons unreliable.</source>
          <target state="translated">, 비 UTF-8 문자) 멀티 바이트 문자가 발생했습니다. Perl은이 문자를 지정된 유니 코드 코드 포인트로 간주합니다. 비 UTF-8 로케일과 유니 코드를 결합하면 위험합니다. 거의 확실하게 일부 문자에는 두 가지 다른 표현이 있습니다. 예를 들어 ISO 8859-7 (Greek) 로캘에서 코드 포인트 0xC3은 대문자 감마를 나타냅니다. 그러나 0x393도 마찬가지입니다. 이렇게하면 문자열 비교를 신뢰할 수 없게됩니다.</target>
        </trans-unit>
        <trans-unit id="4a8a9cd0090598c42711026e8b2bedbe13afa859" translate="yes" xml:space="preserve">
          <source>, a scalar variable containing a filehandle. You can use it the same way you would a normal filehandle. For example, you can read one line from it this way:</source>
          <target state="translated">파일 핸들을 포함하는 스칼라 변수 일반적인 파일 핸들과 같은 방식으로 사용할 수 있습니다. 예를 들어 다음과 같이 한 줄을 읽을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="87346f4ea924d98273903e7b08eb5bb50fb07524" translate="yes" xml:space="preserve">
          <source>, a standard for representing the alphabets from virtually all of the world's written languages, and a host of symbols. Perl's text strings are Unicode strings, so they can contain characters with a value (codepoint or character number) higher than 255.</source>
          <target state="translated">세계 거의 모든 언어로 작성된 알파벳과 다양한 기호를 나타내는 표준입니다. Perl의 텍스트 문자열은 유니 코드 문자열이므로 값 (코드 포인트 또는 문자 번호)이 255보다 큰 문자를 포함 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a9ff749a1a77a1bd6de5d5980b0e406d37de2a87" translate="yes" xml:space="preserve">
          <source>, a utility to extract named sections from documents written in POD. For instance, while utilities have &quot;USAGE&quot; sections, Perl modules usually have &quot;SYNOPSIS&quot; sections: &lt;code&gt;podselect -s &quot;SYNOPSIS&quot; ...&lt;/code&gt; will extract this section for a given file.</source>
          <target state="translated">POD로 작성된 문서에서 명명 된 섹션을 추출하는 유틸리티입니다. 예를 들어 유틸리티에 &quot;USAGE&quot;섹션이 있지만 Perl 모듈에는 일반적으로 &quot;SYNOPSIS&quot;섹션이 있습니다. &lt;code&gt;podselect -s &quot;SYNOPSIS&quot; ...&lt;/code&gt; 은 주어진 파일에 대해이 섹션을 추출합니다.</target>
        </trans-unit>
        <trans-unit id="db014a48cc1ae20706ba0b5682336d456105e57c" translate="yes" xml:space="preserve">
          <source>, above, below, to one side or the other,</source>
          <target state="translated">위, 아래, 한쪽 또는 다른쪽으로</target>
        </trans-unit>
        <trans-unit id="5bf0fa78a7fe771f1c10ae24e95162b1b6bb2a45" translate="yes" xml:space="preserve">
          <source>, albeit fairly useless ones. All they does is filter the source stream without modifying it at all.</source>
          <target state="translated">비록 쓸모없는 것은 아니지만. 그들이하는 것은 소스 스트림을 전혀 수정하지 않고 필터링하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="5362fe8d34331626858b75f7fc5b14ff4d9fc4ab" translate="yes" xml:space="preserve">
          <source>, all IN UPPER CASE. Some control-type code points do not have names. This field will be empty for &lt;code&gt;Surrogate&lt;/code&gt; and &lt;code&gt;Private Use&lt;/code&gt; code points, and for the others without a name, it will contain a description enclosed in angle brackets, like &lt;code&gt;&amp;lt;control&amp;gt;&lt;/code&gt; .</source>
          <target state="translated">모두 대문자로되어 있습니다. 일부 제어 유형 코드 포인트에는 이름이 없습니다. 이 필드는 &lt;code&gt;Surrogate&lt;/code&gt; 및 &lt;code&gt;Private Use&lt;/code&gt; 코드 포인트의 경우 비어 있으며 이름이없는 다른 경우에는 &lt;code&gt;&amp;lt;control&amp;gt;&lt;/code&gt; 과 같이 꺾쇠 괄호로 묶은 설명이 포함됩니다 .</target>
        </trans-unit>
        <trans-unit id="8465d055b30b74c6e7423bbd7027a3bffaac3034" translate="yes" xml:space="preserve">
          <source>, all IN UPPER CASE. Some control-type code points do not have names. This field will be empty for &lt;code&gt;Surrogate&lt;/code&gt; and &lt;code&gt;Private Use&lt;/code&gt; code points, and for the others without a name, it will contain a description enclosed in angle brackets, like &lt;code&gt;&amp;lt;control&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">, 모두 대문자로 표시됩니다. 일부 제어 유형 코드 포인트에는 이름이 없습니다. 이 필드는 &lt;code&gt;Surrogate&lt;/code&gt; 및 &lt;code&gt;Private Use&lt;/code&gt; 코드 포인트의 경우 비어 있고 이름이없는 다른 필드의 경우 &lt;code&gt;&amp;lt;control&amp;gt;&lt;/code&gt; 과 같이 꺾쇠 괄호로 묶인 설명이 포함됩니다 .</target>
        </trans-unit>
        <trans-unit id="f664646812299a02b0171f588d3e3b25b20c386d" translate="yes" xml:space="preserve">
          <source>, all but the first posthumously assembled by CJRT. But</source>
          <target state="translated">CJRT가 사후에 처음으로 모은 것을 제외하고는 그러나</target>
        </trans-unit>
        <trans-unit id="bc5ed6d6260771787075622eea22b930d5fe4a65" translate="yes" xml:space="preserve">
          <source>, along with the header files</source>
          <target state="translated">헤더 파일과 함께</target>
        </trans-unit>
        <trans-unit id="1c56ef602b07cce67c23c54f38c6850a343a4ce2" translate="yes" xml:space="preserve">
          <source>, although you're better off reading the original YACC input in</source>
          <target state="translated">, 원본 YACC 입력을 읽는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="8278d2adba7612cf98a492d21a4ac4c78acb1202" translate="yes" xml:space="preserve">
          <source>, and</source>
          <target state="translated">,</target>
        </trans-unit>
        <trans-unit id="2d4ff8a41a5140058b5f07d5a7ff6c62d7dc6779" translate="yes" xml:space="preserve">
          <source>, and &lt;b&gt;pod2usage()&lt;/b&gt; adheres to this philosophy. If you are interested in seeing a number of different ways to invoke &lt;b&gt;pod2usage&lt;/b&gt; (although by no means exhaustive), please refer to &lt;a href=&quot;#EXAMPLES&quot;&gt;&quot;EXAMPLES&quot;&lt;/a&gt;.</source>
          <target state="translated">, 그리고 &lt;b&gt;pod2usage ()&lt;/b&gt; 는이 철학을 고수합니다. &lt;b&gt;pod2usage&lt;/b&gt; 를 호출하는 여러 가지 방법에 관심이 있다면 (완전한 것은 아니지만) &lt;a href=&quot;#EXAMPLES&quot;&gt;&quot;EXAMPLES&quot;&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0010f4c714dfcbbc2cef143cc9657ab05ffac473" translate="yes" xml:space="preserve">
          <source>, and &lt;b&gt;pod2usage()&lt;/b&gt; adheres to this philosophy. If you are interested in seeing a number of different ways to invoke &lt;b&gt;pod2usage&lt;/b&gt; (although by no means exhaustive), please refer to &lt;a href=&quot;#EXAMPLES&quot;&gt;EXAMPLES&lt;/a&gt;.</source>
          <target state="translated">및 &lt;b&gt;예문 ()&lt;/b&gt; 이 철학에 부착. &lt;b&gt;pod2usage&lt;/b&gt; 를 호출하는 여러 가지 방법을보고 싶은 경우 (완전히 철저하지는 않지만) &lt;a href=&quot;#EXAMPLES&quot;&gt;예&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="dd9e2024ba8a9984c63410d51fe1a587ce82acdf" translate="yes" xml:space="preserve">
          <source>, and &lt;code&gt;S_mro_get_linear_isa_dfs()&lt;/code&gt; in</source>
          <target state="translated">및 &lt;code&gt;S_mro_get_linear_isa_dfs()&lt;/code&gt; 에서</target>
        </trans-unit>
        <trans-unit id="7965adffe1bd5d2a5ae6fef9ed74cb1e415855b5" translate="yes" xml:space="preserve">
          <source>, and Perl will then dispatch the program to the correct interpreter for them.</source>
          <target state="translated">그런 다음 Perl은 해당 프로그램을 해당 언어로 올바른 통역사에게 발송합니다.</target>
        </trans-unit>
        <trans-unit id="d17b3bf1e5023500587f0bcfd04e502c3bc08dca" translate="yes" xml:space="preserve">
          <source>, and a type of</source>
          <target state="translated">의 유형</target>
        </trans-unit>
        <trans-unit id="11eff2ad6b0924ed9a9167101ce0e3ec0461d9bb" translate="yes" xml:space="preserve">
          <source>, and all standard-fearing programs ought to follow this convention. (This is, of course, a stern backing for one of the Lilliputian parties and may well influence the political development there.) So, if the protocol expects you to send a message by sending the length first, followed by just so many bytes, you could write:</source>
          <target state="translated">모든 표준 무시 프로그램은이 규칙을 따라야합니다. (물론 이것은 Lilliputian 당사자 중 하나에 대한 엄격한 후원이며 정치 발전에 영향을 줄 수 있습니다.) 따라서 프로토콜이 길이를 먼저 보내고 메시지를 보내면 바이트가 많을 것입니다. 당신은 쓸 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="09f5aea40a8a98f4ed0812b20a5158126d6be5b5" translate="yes" xml:space="preserve">
          <source>, and an SV argument for it is returned in</source>
          <target state="translated">에 대한 SV 인수가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="907df61a5a10c19d07f5b25bb871f858cdf3aedb" translate="yes" xml:space="preserve">
          <source>, and an SV argument for it is supplied in</source>
          <target state="translated">에 대한 SV 인수가 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="07578e4d2c674557fed4e3b460e007cddc507081" translate="yes" xml:space="preserve">
          <source>, and appends that data to the current state. The return value is the updated object itself.</source>
          <target state="translated">, 해당 데이터를 현재 상태에 추가합니다. 반환 값은 업데이트 된 객체 자체입니다.</target>
        </trans-unit>
        <trans-unit id="47d93ebc28ad85bac43459b74d7c9dbb3a691abc" translate="yes" xml:space="preserve">
          <source>, and arrange for some changes to be automatically undone at the end of it, either explicit, or via a non-local exit (via die()). A</source>
          <target state="translated">, 명시 적 또는 로컬이 아닌 종료 (die ()를 통해) 종료시 일부 변경 사항이 자동으로 취소되도록 정렬합니다. ㅏ</target>
        </trans-unit>
        <trans-unit id="9662074e67662b5481a257ab591d1bcd6cd373a7" translate="yes" xml:space="preserve">
          <source>, and choose &lt;code&gt;Link
object modules&lt;/code&gt; in</source>
          <target state="translated">에서 &lt;code&gt;Link object modules&lt;/code&gt; 선택 합니다 .</target>
        </trans-unit>
        <trans-unit id="110d41533f5d3ce6a781ca76529c953253c32c91" translate="yes" xml:space="preserve">
          <source>, and do not want to hand-edit thousands of your scripts, the long-term solution proposed on p5-p is to have a directive</source>
          <target state="translated">p5-p에 제안 된 장기적인 해결책은 지시어를 갖는 것입니다.</target>
        </trans-unit>
        <trans-unit id="cc9709da02255267935725dadd4e4f1b5070af04" translate="yes" xml:space="preserve">
          <source>, and even a blessed hash reference uses &quot;HASH&quot; as its</source>
          <target state="translated">축복받은 해시 참조조차도 &quot;HASH&quot;를</target>
        </trans-unit>
        <trans-unit id="5ef9d3e35d5e919080f798270609eb087c92e72c" translate="yes" xml:space="preserve">
          <source>, and executables go in</source>
          <target state="translated">실행 파일이 들어갑니다</target>
        </trans-unit>
        <trans-unit id="6d9c13d9981e85ee193ee4cdff8cf22c12e96f94" translate="yes" xml:space="preserve">
          <source>, and for a detailed look at the semantics of regular expressions. In particular, all modifiers except the largely obsolete &lt;code&gt;/o&lt;/code&gt; are further explained in &lt;a href=&quot;perlre#Modifiers&quot;&gt;&quot;Modifiers&quot; in perlre&lt;/a&gt;. &lt;code&gt;/o&lt;/code&gt; is described in the next section.</source>
          <target state="translated">, 정규식의 의미론에 대한 자세한 내용을 확인하십시오. 특히, 대체로 사용되지 않는 &lt;code&gt;/o&lt;/code&gt; 를 제외한 모든 수정자는 &lt;a href=&quot;perlre#Modifiers&quot;&gt;perlre의 &quot;수정 자&quot;에&lt;/a&gt; 자세히 설명되어 있습니다. &lt;code&gt;/o&lt;/code&gt; 는 다음 섹션에서 설명합니다.</target>
        </trans-unit>
        <trans-unit id="e99a7bbd8a62347c5bce742eeae839d4eb74e152" translate="yes" xml:space="preserve">
          <source>, and for a detailed look at the semantics of regular expressions. In particular, all modifiers except the largely obsolete &lt;code&gt;/o&lt;/code&gt; are further explained in &lt;a href=&quot;perlre#Modifiers&quot;&gt;Modifiers in perlre&lt;/a&gt;. &lt;code&gt;/o&lt;/code&gt; is described in the next section.</source>
          <target state="translated">정규 표현식의 의미를 자세히 살펴보십시오. 특히, 더 이상 사용되지 않는 &lt;code&gt;/o&lt;/code&gt; 를 제외한 모든 수정자는 &lt;a href=&quot;perlre#Modifiers&quot;&gt;perlre의 수정 자에&lt;/a&gt; 자세히 설명되어 있습니다. &lt;code&gt;/o&lt;/code&gt; 는 다음 섹션에서 설명합니다.</target>
        </trans-unit>
        <trans-unit id="fea8f1839cc7e75e58025f40c960d342144ecc35" translate="yes" xml:space="preserve">
          <source>, and have Perl create &lt;code&gt;#define&lt;/code&gt; 's for you, based on the current platform.</source>
          <target state="translated">현재 플랫폼을 기반으로 Perl이 &lt;code&gt;#define&lt;/code&gt; 을 만들도록 합니다.</target>
        </trans-unit>
        <trans-unit id="f813ba9205cc9645f513c4750afaaff03e0fb7d6" translate="yes" xml:space="preserve">
          <source>, and have Perl create &lt;code&gt;#define&lt;/code&gt;'s for you, based on the current platform.</source>
          <target state="translated">, Perl 이 현재 플랫폼을 기반으로 &lt;code&gt;#define&lt;/code&gt; 을 생성 하도록합니다.</target>
        </trans-unit>
        <trans-unit id="296963cd9bc200f3f9713e504f93b8fd98a91950" translate="yes" xml:space="preserve">
          <source>, and have a &lt;code&gt;Perl_ck_&lt;/code&gt; prefix. You can find out which check function is used for a particular op type by looking in</source>
          <target state="translated">이고 &lt;code&gt;Perl_ck_&lt;/code&gt; 접두사가 있습니다. 특정 작업 유형에 어떤 검사 기능이 사용되는지 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="13ff4447ae7e1c8dc95b022d007823261ea731b0" translate="yes" xml:space="preserve">
          <source>, and how many gettext items that'd take, but he keeps going... But where $directory_count % 10 is 2, 3, or 4 (except where $directory_count % 100 is 12, 13, or 14), the word for &quot;directories&quot; is forced to be genitive singular -- which means another ending... The room begins to spin around you, slowly at first... But with</source>
          <target state="translated">, 그리고 얼마나 많은 gettext 항목을 가져 갔지만 그는 계속 진행합니다 ... 그러나 $ directory_count % 10이 2, 3 또는 4 인 경우 ($ directory_count % 100이 12, 13 또는 14 인 경우 제외) &quot;디렉토리&quot;는 고유 한 단수로 지정됩니다. 즉, 또 다른 결말을 의미합니다. 처음에는 천천히 방이 회전하기 시작합니다.하지만</target>
        </trans-unit>
        <trans-unit id="900068e92f1192efacbc29ee3e1d53428f88cdd9" translate="yes" xml:space="preserve">
          <source>, and is initialized whenever Perl is invoked. In the &lt;b&gt;dynamic&lt;/b&gt; configuration, the extension's machine code is placed into a separate shareable image, which is mapped by Perl's DynaLoader when the extension is &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt;d or &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt;d in your script. This allows you to maintain the extension as a separate entity, at the cost of keeping track of the additional shareable image. Most extensions can be set up as either static or dynamic.</source>
          <target state="translated">Perl이 호출 될 때마다 초기화됩니다. 에서 &lt;b&gt;동적&lt;/b&gt; 구성, 확장의 기계 코드의 확장자는 펄의 DynaLoader에 의해 매핑 된 별도의 공유 이미지에 배치되어 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; d 또는 &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; 스크립트에서 거라고. 이렇게하면 추가 공유 가능 이미지를 추적하는 대신 확장을 별도의 엔티티로 유지할 수 있습니다. 대부분의 확장은 정적 또는 동적으로 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6a765a8ec93ccf021b9f7d34d5f9b4da144bc9fb" translate="yes" xml:space="preserve">
          <source>, and is initialized whenever Perl is invoked. In the &lt;b&gt;dynamic&lt;/b&gt; configuration, the extension's machine code is placed into a separate shareable image, which is mapped by Perl's DynaLoader when the extension is &lt;code&gt;use&lt;/code&gt;d or &lt;code&gt;require&lt;/code&gt;d in your script. This allows you to maintain the extension as a separate entity, at the cost of keeping track of the additional shareable image. Most extensions can be set up as either static or dynamic.</source>
          <target state="translated">이며 Perl이 호출 될 때마다 초기화됩니다. 에서 &lt;b&gt;동적&lt;/b&gt; 구성, 확장의 기계 코드의 확장자는 펄의 DynaLoader에 의해 매핑 된 별도의 공유 이미지에 배치되어 &lt;code&gt;use&lt;/code&gt; d 또는 &lt;code&gt;require&lt;/code&gt; 스크립트에서 거라고. 이렇게하면 추가 공유 가능한 이미지를 추적하는 대신 확장을 별도의 엔터티로 유지할 수 있습니다. 대부분의 확장은 정적 또는 동적으로 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b914301e3b694e04eb4c8f6d66927ba02c63ec35" translate="yes" xml:space="preserve">
          <source>, and is mainly used if</source>
          <target state="translated">그리고 주로 사용되는 경우</target>
        </trans-unit>
        <trans-unit id="5131123bb887b411a05999cb591c474e9daf98b5" translate="yes" xml:space="preserve">
          <source>, and is noted with a horizontal bar above the number, or &lt;code&gt;~z&lt;/code&gt; here.</source>
          <target state="translated">, 숫자 위에 가로 막대 또는 &lt;code&gt;~z&lt;/code&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="f3befe3ecdb52c3422eb6f93dd78d5aaedf3fabd" translate="yes" xml:space="preserve">
          <source>, and loaded by SWASHNEW, using</source>
          <target state="translated">을 사용하여 SWASHNEW에서로드</target>
        </trans-unit>
        <trans-unit id="1787c9612788394f8950dccec477064ff47cc618" translate="yes" xml:space="preserve">
          <source>, and located either in the wired-in-during-compile locations (usually</source>
          <target state="translated">, 유선 컴파일 중 위치 (일반적으로</target>
        </trans-unit>
        <trans-unit id="7f31e573a88ff53c20f2ccc0bbc44090c52c6791" translate="yes" xml:space="preserve">
          <source>, and looking at the file</source>
          <target state="translated">, 파일보기</target>
        </trans-unit>
        <trans-unit id="3f5db2f6d9247a04a8fdbc30fe1efcc305bcdcc0" translate="yes" xml:space="preserve">
          <source>, and many ops have their own optimizing functions.</source>
          <target state="translated">, 많은 작전에는 자체 최적화 기능이 있습니다.</target>
        </trans-unit>
        <trans-unit id="5edcae719ec7875f046ff91c0210af5ff89c2790" translate="yes" xml:space="preserve">
          <source>, and on Windows it would result in</source>
          <target state="translated">, Windows에서는</target>
        </trans-unit>
        <trans-unit id="744cb0990a11cbc554e464fe23863d4a00b4136e" translate="yes" xml:space="preserve">
          <source>, and returns one reference to the new &lt;code&gt;refcounted_he&lt;/code&gt; .</source>
          <target state="translated">, 새로운 &lt;code&gt;refcounted_he&lt;/code&gt; 에 대한 하나의 참조를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="0f2f2fac6d25d7ba621ec4876ee490192080dccc" translate="yes" xml:space="preserve">
          <source>, and returns the modified hash. The returned hash pointer is in general not the same as the hash pointer that was passed in. The input hash is consumed by the function, and the pointer to it must not be subsequently used. Use &lt;a href=&quot;#cophh_copy&quot;&gt;cophh_copy&lt;/a&gt; if you need both hashes.</source>
          <target state="translated">수정 된 해시를 반환합니다. 반환 된 해시 포인터는 일반적으로 전달 된 해시 포인터와 동일하지 않습니다. 입력 해시는 함수에 의해 소비되며 이후에 포인터를 사용해서는 안됩니다. 두 해시가 모두 필요한 경우 &lt;a href=&quot;#cophh_copy&quot;&gt;cophh_copy를&lt;/a&gt; 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="def96a3fb64ab61d8b47c5c7c69ce7251de754fe" translate="yes" xml:space="preserve">
          <source>, and run</source>
          <target state="translated">실행</target>
        </trans-unit>
        <trans-unit id="910d0b04d2f7ed13b6c81acf52dcf3b2185353b5" translate="yes" xml:space="preserve">
          <source>, and so we make a copy of</source>
          <target state="translated">그래서 우리는</target>
        </trans-unit>
        <trans-unit id="52cab3ae12ab735a21d73b832e20e1fc668ffa87" translate="yes" xml:space="preserve">
          <source>, and splits it up into chunks separated by lines of equal signs, which are placed in &lt;code&gt;@Fields&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;@Fields&lt;/code&gt; 에 배치 된 등호로 구분 된 청크로 분할합니다 .</target>
        </trans-unit>
        <trans-unit id="d24caa5ab98ab63cc81699c1451d226660e09521" translate="yes" xml:space="preserve">
          <source>, and splits it up into chunks separated by lines of equal signs, which are placed in &lt;code&gt;@Fields&lt;/code&gt;.</source>
          <target state="translated">, &lt;code&gt;@Fields&lt;/code&gt; 에 배치되는 등호 줄로 구분 된 청크로 분할합니다 .</target>
        </trans-unit>
        <trans-unit id="34ecfa8acd326d9d67e3ffa2f086f02a68db8dfb" translate="yes" xml:space="preserve">
          <source>, and start it by typing</source>
          <target state="translated">을 입력하여 시작하십시오.</target>
        </trans-unit>
        <trans-unit id="affc1115f6c03c2dc749890055b60424d0b55360" translate="yes" xml:space="preserve">
          <source>, and that &lt;a href=&quot;perlfunc#readdir-DIRHANDLE&quot;&gt;&lt;code&gt;readdir&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;perlfunc#glob-EXPR&quot;&gt;&lt;code&gt;glob&lt;/code&gt;&lt;/a&gt; cannot and do not attempt to emulate the reverse mapping. Other &lt;code&gt;.&lt;/code&gt;'s in filenames are translated to &lt;code&gt;/&lt;/code&gt;.</source>
          <target state="translated">, 그리고 그 &lt;a href=&quot;perlfunc#readdir-DIRHANDLE&quot;&gt; &lt;code&gt;readdir&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;perlfunc#glob-EXPR&quot;&gt; &lt;code&gt;glob&lt;/code&gt; &lt;/a&gt; 은 역 매핑을 에뮬레이트 할 수 없으며 시도하지도 않습니다. 기타 &lt;code&gt;.&lt;/code&gt; 의 파일 이름은 &lt;code&gt;/&lt;/code&gt; 로 번역됩니다 .</target>
        </trans-unit>
        <trans-unit id="2df22aba65ded74733f8217023fc9a2c713a5813" translate="yes" xml:space="preserve">
          <source>, and that &lt;code&gt;&lt;a href=&quot;functions/readdir&quot;&gt;readdir&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/glob&quot;&gt;glob&lt;/a&gt;&lt;/code&gt; cannot and do not attempt to emulate the reverse mapping. Other &lt;code&gt;.&lt;/code&gt;'s in filenames are translated to &lt;code&gt;/&lt;/code&gt;.</source>
          <target state="translated">, 그 &lt;code&gt;&lt;a href=&quot;functions/readdir&quot;&gt;readdir&lt;/a&gt;&lt;/code&gt; 을 하고 &lt;code&gt;&lt;a href=&quot;functions/glob&quot;&gt;glob&lt;/a&gt;&lt;/code&gt; 할 수 없습니다와 역 매핑을 모방하지 마십시오. 기타 &lt;code&gt;.&lt;/code&gt; 의 파일 이름은 &lt;code&gt;/&lt;/code&gt; 로 번역됩니다 .</target>
        </trans-unit>
        <trans-unit id="b3d815d4e6d0e0bf7a5070acb067a435d89afd9c" translate="yes" xml:space="preserve">
          <source>, and the</source>
          <target state="translated">, 그리고</target>
        </trans-unit>
        <trans-unit id="c629432bfcaf1e18a5d7be324021795ca597926d" translate="yes" xml:space="preserve">
          <source>, and the &lt;code&gt;&quot;=~&quot;&lt;/code&gt; operator along with the &lt;code&gt;m//&lt;/code&gt; tell Perl to try to match the pattern against the string. Note that the pattern is also a string, but a very special kind of one, as we will see. Patterns are in common use these days; examples are the patterns typed into a search engine to find web pages and the patterns used to list files in a directory,</source>
          <target state="translated">, &lt;code&gt;m//&lt;/code&gt; 와 함께 &lt;code&gt;&quot;=~&quot;&lt;/code&gt; 연산자 는 Perl에게 문자열과 패턴을 일치 시키도록 지시합니다. 패턴도 문자열이지만 우리가 보게 될 매우 특별한 종류라는 점에 유의하십시오. 요즘에는 패턴이 일반적으로 사용됩니다. 예는 웹 페이지를 찾기 위해 검색 엔진에 입력 된 패턴과 디렉토리의 파일을 나열하는 데 사용되는 패턴입니다.</target>
        </trans-unit>
        <trans-unit id="b3a5f939ce328cd3a253a4971e69a804f33e67d5" translate="yes" xml:space="preserve">
          <source>, and the Gulf of Guinea (think of the missing big chunk of Africa)</source>
          <target state="translated">기니 만 (아프리카의 잃어버린 큰 덩어리를 생각하십시오)</target>
        </trans-unit>
        <trans-unit id="49678bf28719f40cbc47bf372671fcd223bd7354" translate="yes" xml:space="preserve">
          <source>, and the error message will include the line and file where the failed request happened.</source>
          <target state="translated">오류 메시지에 실패한 요청이 발생한 행과 파일이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="c64023a04906dd729256ff3e0c07dcfe556d4b78" translate="yes" xml:space="preserve">
          <source>, and the rest of the things in the lexicon class as things that we know how to</source>
          <target state="translated">어휘 수업의 나머지 부분은 우리가</target>
        </trans-unit>
        <trans-unit id="6c2c13f1fd18de7a45c45c3b6d611d0fa6d993db" translate="yes" xml:space="preserve">
          <source>, and the second being the</source>
          <target state="translated">그리고 두 번째는</target>
        </trans-unit>
        <trans-unit id="10948b5578036f5ad32a0ed831bfc6d104fae454" translate="yes" xml:space="preserve">
          <source>, and the semaphore's count remains unchanged. Otherwise, the semaphore's count is decremented and this method returns</source>
          <target state="translated">세마포어 수는 변경되지 않습니다. 그렇지 않으면 세마포어 수가 감소하고이 메소드는</target>
        </trans-unit>
        <trans-unit id="73b36d5071f4b2d6973b107a88cccdf62d2e436d" translate="yes" xml:space="preserve">
          <source>, and the true value in the fourth argument means</source>
          <target state="translated">네 번째 인수의 실제 값은</target>
        </trans-unit>
        <trans-unit id="759ee7d0b93dff6747c3fbd234956c01b3c8260a" translate="yes" xml:space="preserve">
          <source>, and then the CRTL &lt;code&gt;environ&lt;/code&gt; array. This default order is reversed when the logical name</source>
          <target state="translated">그런 다음 CRTL &lt;code&gt;environ&lt;/code&gt; 배열입니다. 논리적 이름이이 기본 순서로 바뀌면</target>
        </trans-unit>
        <trans-unit id="4c771b3606fdd622281d6b0976acb1e8b29c8ab9" translate="yes" xml:space="preserve">
          <source>, and they will therefore all hold whatever was last in @array! It's similar to the problem demonstrated in the following C program:</source>
          <target state="translated">그러므로 그들은 모두 @array에서 마지막으로 있던 것을 잡아 줄 것입니다! 다음 C 프로그램에서 설명한 문제와 비슷합니다.</target>
        </trans-unit>
        <trans-unit id="35fc6eddaca9b3360e3738457e9a8b19ab25f937" translate="yes" xml:space="preserve">
          <source>, and using references is the key to managing complicated, structured data in Perl. Unfortunately, there's a lot of funny syntax to learn, and the main manual page can be hard to follow. The manual is quite complete, and sometimes people find that a problem, because it can be hard to tell what is important and what isn't.</source>
          <target state="translated">참조를 사용하는 것은 Perl에서 복잡하고 구조화 된 데이터를 관리하기위한 핵심입니다. 안타깝게도 배워야 할 재미있는 구문이 많고 메인 매뉴얼 페이지를 따라 가기가 어려울 수 있습니다. 매뉴얼은 매우 완전하며 때로는 사람들이 문제를 발견합니다. 왜냐하면 무엇이 중요하고 무엇이 중요하지 않은지 말하기가 어려울 수 있기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="ea985a0949a3673c272b8e0d49f54e041583c6c4" translate="yes" xml:space="preserve">
          <source>, and will be examined later.</source>
          <target state="translated">나중에 검토 할 예정입니다.</target>
        </trans-unit>
        <trans-unit id="c060f0c42881559e0dd3ac792535e84bb4d41c37" translate="yes" xml:space="preserve">
          <source>, and will free it.</source>
          <target state="translated">그리고 그것을 풀어줄 것입니다.</target>
        </trans-unit>
        <trans-unit id="88f40c683f759884090876f282199945cd762ea4" translate="yes" xml:space="preserve">
          <source>, and with dynamic CRT DLL. This executable is a VIO application.</source>
          <target state="translated">동적 CRT DLL 이 실행 파일은 VIO 응용 프로그램입니다.</target>
        </trans-unit>
        <trans-unit id="f5ffc67dd22fb19007fd6dce315aac48234ca530" translate="yes" xml:space="preserve">
          <source>, and writes change the value. In both cases the position in</source>
          <target state="translated">, 쓰기는 값을 변경합니다. 두 경우 모두</target>
        </trans-unit>
        <trans-unit id="4aa138eb7154eb226a5d7af0b04c19ffd9e3302e" translate="yes" xml:space="preserve">
          <source>, and you want the perl module be named as &lt;code&gt;Ext::Ension&lt;/code&gt; . If you need some preprocessor directives and/or linking with external libraries, see the flags &lt;code&gt;-F&lt;/code&gt; , &lt;code&gt;-L&lt;/code&gt; and &lt;code&gt;-l&lt;/code&gt; in &lt;a href=&quot;#OPTIONS&quot;&gt;OPTIONS&lt;/a&gt;.</source>
          <target state="translated">perl 모듈의 이름을 &lt;code&gt;Ext::Ension&lt;/code&gt; 으로 지정 하려고 합니다. 전 처리기 지시문이 필요하거나 외부 라이브러리와 연결해야하는 경우 &lt;a href=&quot;#OPTIONS&quot;&gt;OPTIONS&lt;/a&gt; 의 플래그 &lt;code&gt;-F&lt;/code&gt; , &lt;code&gt;-L&lt;/code&gt; 및 &lt;code&gt;-l&lt;/code&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="46f3dd98c315e3415f179fb63083dca1dd67234a" translate="yes" xml:space="preserve">
          <source>, and you want the perl module be named as &lt;code&gt;Ext::Ension&lt;/code&gt;. If you need some preprocessor directives and/or linking with external libraries, see the flags &lt;code&gt;-F&lt;/code&gt;, &lt;code&gt;-L&lt;/code&gt; and &lt;code&gt;-l&lt;/code&gt; in &lt;a href=&quot;#OPTIONS&quot;&gt;&quot;OPTIONS&quot;&lt;/a&gt;.</source>
          <target state="translated">, Perl 모듈의 이름을 &lt;code&gt;Ext::Ension&lt;/code&gt; 으로 지정 하려고 합니다. 일부 처리기 지시문이 필요 및 / 또는 외부 라이브러리에 연결하는 경우, 플래그를 참조하십시오 &lt;code&gt;-F&lt;/code&gt; , &lt;code&gt;-L&lt;/code&gt; 및 &lt;code&gt;-l&lt;/code&gt; 에서 &lt;a href=&quot;#OPTIONS&quot;&gt;&quot;옵션&quot;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f3432a5b49b7c2d6b8db782af36b21ccbf7c42da" translate="yes" xml:space="preserve">
          <source>, and you want to install the library in</source>
          <target state="translated">에 라이브러리를 설치하려고합니다.</target>
        </trans-unit>
        <trans-unit id="bfd8b43815ed413fbc5e63c75755527d7e1515b9" translate="yes" xml:space="preserve">
          <source>, any number of times</source>
          <target state="translated">, 횟수 제한 없음</target>
        </trans-unit>
        <trans-unit id="b51541dfdf2e1d289578b51a3a7d8f2c29834d37" translate="yes" xml:space="preserve">
          <source>, any number of times, but as few times as possible</source>
          <target state="translated">, 횟수 제한없이 가능한 한 적은 횟수</target>
        </trans-unit>
        <trans-unit id="548642e975a7aad08e0815d9a988055ad22fd668" translate="yes" xml:space="preserve">
          <source>, api_revision is the &lt;code&gt;5&lt;/code&gt; . Prior to 5.5.640, the format was a floating point number, like 5.00563.</source>
          <target state="translated">api_revision은 &lt;code&gt;5&lt;/code&gt; 입니다. 5.5.640 이전의 형식은 5.00563과 같은 부동 소수점 수였습니다.</target>
        </trans-unit>
        <trans-unit id="b591aff32ebed20b5f6017f4c43a986e5c9b6d83" translate="yes" xml:space="preserve">
          <source>, api_revision is the &lt;code&gt;5&lt;/code&gt;. Prior to 5.5.640, the format was a floating point number, like 5.00563.</source>
          <target state="translated">, api_revision은 &lt;code&gt;5&lt;/code&gt; 입니다. 5.5.640 이전에는 형식이 5.00563과 같은 부동 소수점 숫자였습니다.</target>
        </trans-unit>
        <trans-unit id="188a87e7240228ac91dcd0c1a6be3953445dc39d" translate="yes" xml:space="preserve">
          <source>, api_subversion is the &lt;code&gt;1&lt;/code&gt; . See api_revision for full details.</source>
          <target state="translated">api_subversion은 &lt;code&gt;1&lt;/code&gt; 입니다. 자세한 내용은 api_revision을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="476bb8ee4de99c6e30b031f6ec683d564a9accd6" translate="yes" xml:space="preserve">
          <source>, api_subversion is the &lt;code&gt;1&lt;/code&gt;. See api_revision for full details.</source>
          <target state="translated">, api_subversion은 &lt;code&gt;1&lt;/code&gt; 입니다. 자세한 내용은 api_revision을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="a73dc0145a278edd9b0c16fb3b9861e0ad5e4534" translate="yes" xml:space="preserve">
          <source>, api_version is the &lt;code&gt;6&lt;/code&gt; . See api_revision for full details. As a special case, 5.5.0 is rendered in the old-style as 5.005. (In the 5.005_0x maintenance series, this was the only versioned directory in $sitelib.)</source>
          <target state="translated">api_version은 &lt;code&gt;6&lt;/code&gt; 입니다. 자세한 내용은 api_revision을 참조하십시오. 특별한 경우 5.5.0은 이전 스타일에서 5.005로 렌더링됩니다. (5.005_0x 유지 보수 시리즈에서이 디렉토리는 $ sitelib의 유일한 버전 디렉토리였습니다.)</target>
        </trans-unit>
        <trans-unit id="cc17c10a5bc0146ee1fed71d1a8e153c465a9594" translate="yes" xml:space="preserve">
          <source>, api_version is the &lt;code&gt;6&lt;/code&gt;. See api_revision for full details. As a special case, 5.5.0 is rendered in the old-style as 5.005. (In the 5.005_0x maintenance series, this was the only versioned directory in $sitelib.)</source>
          <target state="translated">, api_version은 &lt;code&gt;6&lt;/code&gt; 입니다. 자세한 내용은 api_revision을 참조하십시오. 특별한 경우로 5.5.0은 이전 스타일에서 5.005로 렌더링됩니다. (5.005_0x 유지 보수 시리즈에서 이것은 $ sitelib의 유일한 버전 디렉토리였습니다.)</target>
        </trans-unit>
        <trans-unit id="2889576d565f5867fe9cc4e57258064d9a7e464a" translate="yes" xml:space="preserve">
          <source>, are generally reserved for use in regexp notation. The metacharacters are</source>
          <target state="translated">, 일반적으로 regexp 표기법에 사용하도록 예약되어 있습니다. 메타 문자는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7a97d37b678b945a449c7d36a99037c11f17aab4" translate="yes" xml:space="preserve">
          <source>, are generated when</source>
          <target state="translated">때 생성됩니다</target>
        </trans-unit>
        <trans-unit id="1677c7c3fc729a817e4acfa05dba2ce6dccfb2e7" translate="yes" xml:space="preserve">
          <source>, are reserved for use in regexp notation. The metacharacters are</source>
          <target state="translated">는 정규 표현식 표기법으로 사용하도록 예약되어 있습니다. 메타 문자는</target>
        </trans-unit>
        <trans-unit id="5cb6624450c0504e407388bb9dd4d65ed8a21177" translate="yes" xml:space="preserve">
          <source>, are three-dimensional coordinates which define a point in three-dimensional space. They are based on a cylinder surface. The radius of the cylinder is &lt;b&gt;rho&lt;/b&gt;, also known as the</source>
          <target state="translated">는 3 차원 공간에서 점을 정의하는 3 차원 좌표입니다. 그들은 실린더 표면을 기반으로합니다. 실린더의 반경이고 &lt;b&gt;, &amp;rho;&lt;/b&gt; 또한라고도</target>
        </trans-unit>
        <trans-unit id="08ae511c03da62c55bc28f08c497a5cd99f011a3" translate="yes" xml:space="preserve">
          <source>, are three-dimensional coordinates which define a point in three-dimensional space. They are based on a sphere surface. The radius of the sphere is &lt;b&gt;rho&lt;/b&gt;, also known as the</source>
          <target state="translated">는 3 차원 공간에서 점을 정의하는 3 차원 좌표입니다. 그들은 구 표면을 기반으로합니다. 구의 반지름은 &lt;b&gt;rho&lt;/b&gt; 이며</target>
        </trans-unit>
        <trans-unit id="f21c678c3b392bc1e40f88b091f81477c570711c" translate="yes" xml:space="preserve">
          <source>, as at &lt;a href=&quot;http://sunsite.dk/RFC/rfc/rfc3066.html&quot;&gt;http://sunsite.dk/RFC/rfc/rfc3066.html&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;http://sunsite.dk/RFC/rfc/rfc3066.html&quot;&gt;http://sunsite.dk/RFC/rfc/rfc3066.html&lt;/a&gt; 과 같이</target>
        </trans-unit>
        <trans-unit id="66ae827ead4750ffe3370a29e9f62b3a997007cd" translate="yes" xml:space="preserve">
          <source>, as described in the next paragraph. Or, if &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; charnames&lt;/code&gt; is used with script name arguments, then for &lt;code&gt;\N{&lt;i&gt;CHARNAME&lt;/i&gt;}&lt;/code&gt; the name</source>
          <target state="translated">다음 단락에 설명 된대로 또는 스크립트 이름 인수와 함께 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; charnames&lt;/code&gt; &lt;a href=&quot;functions/use&quot;&gt;사용을 사용&lt;/a&gt; 하는 경우 &lt;code&gt;\N{&lt;i&gt;CHARNAME&lt;/i&gt;}&lt;/code&gt; 경우 이름</target>
        </trans-unit>
        <trans-unit id="95e45217604baf8e939999d06ec7d1d5389a8867" translate="yes" xml:space="preserve">
          <source>, as described in the next paragraph. Or, if &lt;code&gt;use charnames&lt;/code&gt; is used with script name arguments, then for &lt;code&gt;\N{&lt;i&gt;CHARNAME&lt;/i&gt;}&lt;/code&gt; the name</source>
          <target state="translated">, 다음 단락에 설명되어 있습니다. 또는 &lt;code&gt;use charnames&lt;/code&gt; 가 스크립트 이름 인수와 함께 사용되는 경우 &lt;code&gt;\N{&lt;i&gt;CHARNAME&lt;/i&gt;}&lt;/code&gt; 경우 이름</target>
        </trans-unit>
        <trans-unit id="8a69d8284e4806cb3167c85fd84978d404a739e1" translate="yes" xml:space="preserve">
          <source>, as if the chain of unbroken output somehow ensures the survival of the program. If speed is in any way an issue, this approach is wrong.</source>
          <target state="translated">마치 끊임없는 출력 체인이 어떻게 든 프로그램의 생존을 보장하는 것처럼 말입니다. 속도가 문제라면,이 방법은 잘못된 것입니다.</target>
        </trans-unit>
        <trans-unit id="2447a9b3daed4b590f24d0dda264bc7a27cfb571" translate="yes" xml:space="preserve">
          <source>, as in &lt;code&gt;nstore&lt;/code&gt; and &lt;code&gt;nstore_fd&lt;/code&gt; . At retrieval time, your data will be correctly restored so you don't have to know whether you're restoring from native or network ordered data. Double values are stored stringified to ensure portability as well, at the slight risk of loosing some precision in the last decimals.</source>
          <target state="translated">,에서와 같이 &lt;code&gt;nstore&lt;/code&gt; 및 &lt;code&gt;nstore_fd&lt;/code&gt; . 검색시 데이터가 올바르게 복원되므로 기본 또는 네트워크 순서 데이터에서 복원 중인지 알 필요가 없습니다. 마지막 10 진수의 정밀도를 약간 잃을 위험이 있지만 이식성을 보장하기 위해 이중 값이 문자열로 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="940a2416c9cd3231a765cc84f2408062aefe1c7b" translate="yes" xml:space="preserve">
          <source>, as in &lt;code&gt;nstore&lt;/code&gt; and &lt;code&gt;nstore_fd&lt;/code&gt;. At retrieval time, your data will be correctly restored so you don't have to know whether you're restoring from native or network ordered data. Double values are stored stringified to ensure portability as well, at the slight risk of loosing some precision in the last decimals.</source>
          <target state="translated">, &lt;code&gt;nstore&lt;/code&gt; 및 &lt;code&gt;nstore_fd&lt;/code&gt; . 검색시 데이터가 올바르게 복원되므로 기본 또는 네트워크 주문 데이터에서 복원하는지 여부를 알 필요가 없습니다. 이중 값은 마지막 소수에서 정밀도를 잃을 수있는 약간의 위험이 있지만 이식성을 보장하기 위해 문자열로 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="44e9ce8f895c605d8b566ef8add0326c89ba8c44" translate="yes" xml:space="preserve">
          <source>, as many platforms have case-insensitive (or at least case-forgiving) filenames. Also, try not to have non-word characters (except for &lt;code&gt;.&lt;/code&gt;) in the names, and keep them to the 8.3 convention, for maximum portability, onerous a burden though this may appear.</source>
          <target state="translated">많은 플랫폼에서 대소 문자를 구분하지 않거나 최소한 대소 문자를 구분하는 파일 이름을 갖습니다. 또한, (제외 단어가 아닌 문자를하지 않으려 고 &lt;code&gt;.&lt;/code&gt; 이름에서), 그리고이 나타날 수 있지만 부담 부담, 최대 휴대 성, 8.3 규칙에 보관하십시오.</target>
        </trans-unit>
        <trans-unit id="86c4b8b976d7fe73a2f1d8c81c5d4231eab338d9" translate="yes" xml:space="preserve">
          <source>, as the other binaries are found relative to the perl binary.</source>
          <target state="translated">다른 바이너리는 perl 바이너리와 관련하여 발견됩니다.</target>
        </trans-unit>
        <trans-unit id="66215e5d0d7fcdf3b23116101a903820fe1c82b9" translate="yes" xml:space="preserve">
          <source>, as we set the PL_exit_flag PERL_EXIT_DESTRUCT_END which executes END blocks in perl_destruct.</source>
          <target state="translated">perl_destruct에서 END 블록을 실행하는 PL_exit_flag PERL_EXIT_DESTRUCT_END를 설정했습니다.</target>
        </trans-unit>
        <trans-unit id="1bf2ca6b0b5f214e584c8a25f06016391d5664fd" translate="yes" xml:space="preserve">
          <source>, as well as all tests in all subdirectories that reside under</source>
          <target state="translated">, 아래에있는 모든 하위 디렉토리의 모든 테스트</target>
        </trans-unit>
        <trans-unit id="f844aaaf402bacab2d52c88c71153b6f22ec5daa" translate="yes" xml:space="preserve">
          <source>, as well as make Perl the best language to use under OS/2. The secondary target is to try to make this work under DOS and Win* as well (but not &lt;b&gt;too&lt;/b&gt; hard).</source>
          <target state="translated">Perl을 OS / 2에서 사용하기에 가장 적합한 언어로 만듭니다. 두 번째 목표는 DOS 및 Win *에서도이 작업을 수행하는 것입니다 (그러나 &lt;b&gt;너무&lt;/b&gt; 어렵지는 않습니다 ).</target>
        </trans-unit>
        <trans-unit id="a3f536d0bd6e04654853520df988137e9eb59a9d" translate="yes" xml:space="preserve">
          <source>, as you'll need to understand the &lt;a href=&quot;TAP::Parser&quot;&gt;TAP::Parser&lt;/a&gt; API. A good place to start is by understanding how &lt;a href=&quot;#aggregate_tests&quot;&gt;&quot;aggregate_tests&quot;&lt;/a&gt; works.</source>
          <target state="translated">, &lt;a href=&quot;TAP::Parser&quot;&gt;TAP :: Parser&lt;/a&gt; API 를 이해해야합니다 . 시작하기 좋은 곳은 &lt;a href=&quot;#aggregate_tests&quot;&gt;&quot;aggregate_tests&quot;의&lt;/a&gt; 작동 방식을 이해하는 것 입니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
