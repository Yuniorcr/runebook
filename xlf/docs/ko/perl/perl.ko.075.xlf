<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="perl">
    <body>
      <group id="perl">
        <trans-unit id="71136eef26be831306f95a5bb63a84e27f7eef99" translate="yes" xml:space="preserve">
          <source>arithmetical operator</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="405928ee9a480fc2a8eade49b14a897e6af33c76" translate="yes" xml:space="preserve">
          <source>around</source>
          <target state="translated">around</target>
        </trans-unit>
        <trans-unit id="d95e887f901f26e63014aa2cdccb63b7fb5f1815" translate="yes" xml:space="preserve">
          <source>around the subroutine call.</source>
          <target state="translated">서브 루틴 호출 주위.</target>
        </trans-unit>
        <trans-unit id="19edc1210777ba4d45049c29280d9cc5e1064c25" translate="yes" xml:space="preserve">
          <source>array</source>
          <target state="translated">array</target>
        </trans-unit>
        <trans-unit id="ee52cfe001be3ed7048ad4373bb96e5fa2a3b08b" translate="yes" xml:space="preserve">
          <source>array and hash recursion limits are checked separately against the same recursion depth, a frozen structure with a large sequence of nested arrays within many nested hashes may exhaust the processor stack without triggering Storable's recursion protection.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb5ef87e4b652f27fd8991387223f83d56f88257" translate="yes" xml:space="preserve">
          <source>array context</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40c598025171195fc4a712080717583430cb5462" translate="yes" xml:space="preserve">
          <source>array elements and key-value pairs with commas. This can be annoying if you write JSON texts manually and want to be able to quickly append elements, so this extension accepts comma at the end of such items not just between them:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6996ca24f94a68ce49953711998dbd6942136600" translate="yes" xml:space="preserve">
          <source>array ref</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a52a0b3e02bac0d6784f4d079552610c345b5af" translate="yes" xml:space="preserve">
          <source>array ref is used to create a &lt;a href=&quot;TAP::Parser::Source&quot;&gt;TAP::Parser::Source&lt;/a&gt; that is passed to the &lt;a href=&quot;#iterator_factory_class&quot;&gt;&quot;iterator_factory_class&quot;&lt;/a&gt; which in turn figures out how to handle the source and creates a &amp;lt;TAP::Parser::Iterator&amp;gt; for it. The iterator is used by the parser to read in the TAP stream.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="276700d738a08a17c36c325a79d878275e1e62b7" translate="yes" xml:space="preserve">
          <source>array ref is used to create a &lt;a href=&quot;parser/source&quot;&gt;TAP::Parser::Source&lt;/a&gt; that is passed to the &lt;a href=&quot;#iterator_factory_class&quot;&gt;iterator_factory_class&lt;/a&gt; which in turn figures out how to handle the source and creates a &amp;lt;TAP::Parser::Iterator&amp;gt; for it. The iterator is used by the parser to read in the TAP stream.</source>
          <target state="translated">array ref는 &lt;a href=&quot;#iterator_factory_class&quot;&gt;iterator_factory_class&lt;/a&gt; 로 전달 되는 &lt;a href=&quot;parser/source&quot;&gt;TAP :: Parser :: Source&lt;/a&gt; 를 만드는 데 사용됩니다 . iterator_factory_class 는 소스를 처리하는 방법을 파악하고 &amp;lt;TAP :: Parser :: Iterator&amp;gt;를 만듭니다. 이터레이터는 파서에서 TAP 스트림을 읽는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="9b611f002dfdbbc7f417d7a701d0c0982f8295cb" translate="yes" xml:space="preserve">
          <source>array references</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f086a94a5c6545b992f6b27781fc7f73cd0f34a" translate="yes" xml:space="preserve">
          <source>arrays of arrays</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="87a3c7add3ea98d8bc57a46927c400f9ef4f5814" translate="yes" xml:space="preserve">
          <source>arrays of hashes</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47741cf980400a87afe9c94390f9126efceba961" translate="yes" xml:space="preserve">
          <source>article ( [ MSGID|MSGNUM ], [FH] )</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f007d443bf9be1cbb02a5647bc3ffc2ea4a7b0be" translate="yes" xml:space="preserve">
          <source>article about Maketext. It explains many important concepts underlying Locale::Maketext's design, and some insight into why Maketext is better than the plain old approach of having message catalogs that are just databases of sprintf formats.</source>
          <target state="translated">Maketext에 대한 기사. Locale :: Maketext의 디자인에 기초한 많은 중요한 개념과 왜 sprintf 형식의 데이터베이스 인 메시지 카탈로그를 갖는 기존의 접근 방식보다 Maketext가 더 나은지에 대한 통찰력을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="c39354a2afa38bb8867edb6c280fc4691cf93e48" translate="yes" xml:space="preserve">
          <source>article in the &quot;Far More Than You Ever Wanted To Know&quot; collection in &lt;a href=&quot;http://www.cpan.org/misc/olddoc/FMTEYEWTK.tgz&quot;&gt;http://www.cpan.org/misc/olddoc/FMTEYEWTK.tgz&lt;/a&gt; .</source>
          <target state="translated">&lt;a href=&quot;http://www.cpan.org/misc/olddoc/FMTEYEWTK.tgz&quot;&gt;http://www.cpan.org/misc/olddoc/FMTEYEWTK.tgz의&lt;/a&gt; &quot;알고 싶은 것보다 훨씬 더&quot;컬렉션에있는 기사 .</target>
        </trans-unit>
        <trans-unit id="770bc2c07a08614cf46186cc798c253673fb1442" translate="yes" xml:space="preserve">
          <source>article in the &quot;Far More Than You Ever Wanted To Know&quot; collection in &lt;a href=&quot;http://www.cpan.org/misc/olddoc/FMTEYEWTK.tgz&quot;&gt;http://www.cpan.org/misc/olddoc/FMTEYEWTK.tgz&lt;/a&gt; . To capture a command's STDERR and STDOUT together:</source>
          <target state="translated">&lt;a href=&quot;http://www.cpan.org/misc/olddoc/FMTEYEWTK.tgz&quot;&gt;http://www.cpan.org/misc/olddoc/FMTEYEWTK.tgz의&lt;/a&gt; &quot;알고 싶은 것보다 훨씬 더&quot;컬렉션에있는 기사 . 명령의 STDERR 및 STDOUT을 함께 캡처하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="d63a2a6a0595f68a45646a780e4852db4b72a660" translate="yes" xml:space="preserve">
          <source>article in the &quot;Far More Than You Ever Wanted To Know&quot; collection in &lt;a href=&quot;http://www.cpan.org/misc/olddoc/FMTEYEWTK.tgz&quot;&gt;http://www.cpan.org/misc/olddoc/FMTEYEWTK.tgz&lt;/a&gt; for more about this approach.</source>
          <target state="translated">이 접근 방식에 대한 자세한 내용 은 &lt;a href=&quot;http://www.cpan.org/misc/olddoc/FMTEYEWTK.tgz&quot;&gt;http://www.cpan.org/misc/olddoc/FMTEYEWTK.tgz의&lt;/a&gt; &quot;알고 싶은 것보다 더&quot;컬렉션의 기사를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0791a67844c8f4efbe5e99ac3105cf46b29ab17a" translate="yes" xml:space="preserve">
          <source>article in the &quot;Far More Than You Ever Wanted To Know&quot; collection in &lt;a href=&quot;http://www.cpan.org/misc/olddoc/FMTEYEWTK.tgz&quot;&gt;http://www.cpan.org/misc/olddoc/FMTEYEWTK.tgz&lt;/a&gt;, courtesy of Tom Phoenix, talks more about this. John von Neumann said, &quot;Anyone who attempts to generate random numbers by deterministic means is, of course, living in a state of sin.&quot;</source>
          <target state="translated">Tom Phoenix가 제공 한 &lt;a href=&quot;http://www.cpan.org/misc/olddoc/FMTEYEWTK.tgz&quot;&gt;http://www.cpan.org/misc/olddoc/FMTEYEWTK.tgz의&lt;/a&gt; &quot;알고 싶은 것보다 훨씬 더&quot;컬렉션에있는 기사에서 이에 대해 자세히 설명합니다. 존 폰 노이만 (John von Neumann)은 &quot;결정 론적 수단으로 난수를 생성하려는 사람은 물론 죄의 상태에 살고있다&quot;고 말했다.</target>
        </trans-unit>
        <trans-unit id="7de2a03beba8be3648bd55b5be4d022975548521" translate="yes" xml:space="preserve">
          <source>articlefh ( [ MSGID|MSGNUM ] )</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee853884bf8a2aa22c0c7ac39a07600efacbe3c2" translate="yes" xml:space="preserve">
          <source>artistic</source>
          <target state="translated">artistic</target>
        </trans-unit>
        <trans-unit id="df211ccdd94a63e0bcb9e6ae427a249484a49d60" translate="yes" xml:space="preserve">
          <source>as</source>
          <target state="translated">as</target>
        </trans-unit>
        <trans-unit id="a65837ad13e0fdf78d35e16e571d952b5ff6f7e1" translate="yes" xml:space="preserve">
          <source>as &lt;code&gt;load&lt;/code&gt; will use &lt;code&gt;&lt;a href=&quot;functions/caller&quot;&gt;caller&lt;/a&gt;&lt;/code&gt; to determine the package.</source>
          <target state="translated">로 &lt;code&gt;load&lt;/code&gt; 사용 &lt;code&gt;&lt;a href=&quot;functions/caller&quot;&gt;caller&lt;/a&gt;&lt;/code&gt; 패키지를 결정합니다.</target>
        </trans-unit>
        <trans-unit id="35bac7fe78f98bd7d83aaba5da7fad3ba2f57d8c" translate="yes" xml:space="preserve">
          <source>as &lt;code&gt;load&lt;/code&gt; will use &lt;code&gt;caller&lt;/code&gt; to determine the package.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70146c42ef768a95ce2127751f1aff9401a3be9b" translate="yes" xml:space="preserve">
          <source>as UTF-8. This takes into account if the call to the XS function is being made from within the scope of &lt;a href=&quot;bytes&quot;&gt;&lt;code&gt;use bytes&lt;/code&gt;&lt;/a&gt;. If so, the underlying bytes that comprise the UTF-8 string are to be exposed, rather than the character they represent. But this pragma should only really be used for debugging and perhaps low-level testing at the byte level. Hence most XS code need not concern itself with this, but various areas of the perl core do need to support it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54d62e679336367634a72a952dc99d5052db36db" translate="yes" xml:space="preserve">
          <source>as UTF-8. This takes into account if the call to the XS function is being made from within the scope of &lt;a href=&quot;bytes&quot;&gt;use bytes &lt;/a&gt;. If so, the underlying bytes that comprise the UTF-8 string are to be exposed, rather than the character they represent. But this pragma should only really be used for debugging and perhaps low-level testing at the byte level. Hence most XS code need not concern itself with this, but various areas of the perl core do need to support it.</source>
          <target state="translated">UTF-8로. XS 함수에 대한 호출이 &lt;a href=&quot;bytes&quot;&gt;사용 바이트&lt;/a&gt; 범위 내에서 수행되는 경우이를 고려 합니다 . 그렇다면 UTF-8 문자열을 구성하는 기본 바이트가 나타내는 문자가 아니라 노출됩니다. 그러나이 pragma는 바이트 수준에서 디버깅 및 아마도 저수준 테스트에만 사용해야합니다. 따라서 대부분의 XS 코드는 이것과 관련이 없지만 펄 코어의 다양한 영역에서이를 지원해야합니다.</target>
        </trans-unit>
        <trans-unit id="15cb6bc32b06c78e373977af44ccb471b3a1d4af" translate="yes" xml:space="preserve">
          <source>as a binary string of approximately 44 bytes which holds a set or zero or more operators.</source>
          <target state="translated">약 44 바이트의 이진 문자열로, 집합 또는 0 개 이상의 연산자를 보유합니다.</target>
        </trans-unit>
        <trans-unit id="49535962cebbc0ea94c6df25ea434365bc702259" translate="yes" xml:space="preserve">
          <source>as a hash itself, the only problem one has to circumvent is how to access this</source>
          <target state="translated">해시 자체로 우회해야 할 유일한 문제는 이것에 액세스하는 방법입니다.</target>
        </trans-unit>
        <trans-unit id="b3d154f01d41c1bc9eb1e234a00980811a7203a7" translate="yes" xml:space="preserve">
          <source>as a logical stream of bits, where each ASCII '0' or '1' character represents a 0 or 1 bit, respectively. All other characters are ignored. This provides a convenient way to calculate the digest values of partial-byte data by using files, rather than having to write separate programs employing the</source>
          <target state="translated">논리적 인 비트 스트림으로서 각 ASCII '0'또는 '1'문자는 각각 0 또는 1 비트를 나타냅니다. 다른 모든 문자는 무시됩니다. 이것은 파일을 사용하여 부분 바이트 데이터의 다이제스트 값을 계산하는 편리한 방법을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="0484899da16ac25f9334dc3c0f326506de8f3b2a" translate="yes" xml:space="preserve">
          <source>as a module hierarchy name etc.</source>
          <target state="translated">모듈 계층 이름 등으로</target>
        </trans-unit>
        <trans-unit id="2595e4d12822845ad19e585d97389ce1ab042a19" translate="yes" xml:space="preserve">
          <source>as a module hierarchy name, etc.</source>
          <target state="translated">모듈 계층 이름 등으로</target>
        </trans-unit>
        <trans-unit id="7489e1fa251bf45372d6ac9fae76ff03bb4fc00a" translate="yes" xml:space="preserve">
          <source>as a naive</source>
          <target state="translated">순진한</target>
        </trans-unit>
        <trans-unit id="74d1f75f898cb43e0472a9e5e56f2df27dec3699" translate="yes" xml:space="preserve">
          <source>as a regular expression.</source>
          <target state="translated">정규식으로.</target>
        </trans-unit>
        <trans-unit id="73ad2cf416dcc1436eb98bf0ea9e81a9ab178ed0" translate="yes" xml:space="preserve">
          <source>as a shell, thus I picked up &lt;code&gt;sh.exe&lt;/code&gt; . This assures almost 100% compatibility with the scripts coming from *nix. As an added benefit this works as well under DOS if you use DOS-enabled port of pdksh (see &lt;a href=&quot;#Prerequisites&quot;&gt;Prerequisites&lt;/a&gt;).</source>
          <target state="translated">쉘로 &lt;code&gt;sh.exe&lt;/code&gt; 를 선택했습니다 . 이는 * nix에서 제공되는 스크립트와 거의 100 %의 호환성을 보장합니다. pdksh의 DOS 사용 가능 포트를 사용하는 경우 DOS에서도 추가 이점이 있습니다 ( &lt;a href=&quot;#Prerequisites&quot;&gt;전제 조건&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="d53a1395e63eb46d9815bfd1a4ea2256702937d5" translate="yes" xml:space="preserve">
          <source>as a shell, thus I picked up &lt;code&gt;sh.exe&lt;/code&gt;. This assures almost 100% compatibility with the scripts coming from *nix. As an added benefit this works as well under DOS if you use DOS-enabled port of pdksh (see &lt;a href=&quot;#Prerequisites&quot;&gt;&quot;Prerequisites&quot;&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82888b2ea2ac983fcbffdc2a662722f9eb637ac9" translate="yes" xml:space="preserve">
          <source>as a simple macro call to the system's &lt;code&gt;signbit()&lt;/code&gt;. Users should just always call &lt;code&gt;Perl_signbit()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="219042fce9a9511b0a48448658f92bc608f91fc4" translate="yes" xml:space="preserve">
          <source>as a temporary development aid while securing legacy code: for real production code and for new secure code written from scratch, always use the real &lt;a href=&quot;#-T&quot;&gt;&quot;-T&quot;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7fc448ca1e6145126fcde1afbfc84e38e6144b79" translate="yes" xml:space="preserve">
          <source>as a temporary development aid while securing legacy code: for real production code and for new secure code written from scratch, always use the real &lt;b&gt;-T&lt;/b&gt;.</source>
          <target state="translated">레거시 코드를 보호하는 동안 임시 개발 지원으로 : 실제 프로덕션 코드 및 처음부터 작성된 새 보안 코드에는 항상 real &lt;b&gt;-T를&lt;/b&gt; 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="5a74d8f36fb474bb27b3f38f8cd94ae3c7f71fa4" translate="yes" xml:space="preserve">
          <source>as above would make for rather long-winded and repetitive code -- even if you wisely rewrote this to have quantification (as we call adding a number expression to a noun phrase) be a function called like:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7cfc9d5f69a8d6cbd4bb590ee3975431bc4e65a3" translate="yes" xml:space="preserve">
          <source>as after matching the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ab073688be2687e53685015f7b0f7521b1bb83a" translate="yes" xml:space="preserve">
          <source>as after matching the A but failing on the B the &lt;code&gt;(*THEN)&lt;/code&gt; verb will backtrack and try C; but the &lt;code&gt;(*PRUNE)&lt;/code&gt; verb will simply fail.</source>
          <target state="translated">A와 일치하지만 B에서 실패한 후 &lt;code&gt;(*THEN)&lt;/code&gt; 동사는 역 추적하고 C를 시도합니다. 그러나 &lt;code&gt;(*PRUNE)&lt;/code&gt; 동사는 단순히 실패합니다.</target>
        </trans-unit>
        <trans-unit id="9753eb43e6b71481134609a83fe7c9d127007ad0" translate="yes" xml:space="preserve">
          <source>as an additional linker argument.</source>
          <target state="translated">추가 링커 인수로.</target>
        </trans-unit>
        <trans-unit id="819da9a9443370e84fe6f05fc53d70984c447739" translate="yes" xml:space="preserve">
          <source>as an argument, and returns text to insert into the string instead of the &lt;code&gt;\N{&lt;i&gt;CHARNAME&lt;/i&gt;}&lt;/code&gt; escape.</source>
          <target state="translated">&lt;code&gt;\N{&lt;i&gt;CHARNAME&lt;/i&gt;}&lt;/code&gt; 이스케이프 대신 문자열에 삽입 할 텍스트를 인수로 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="a1e4232743f22df2b484ab094b5e1490c15a9dc6" translate="yes" xml:space="preserve">
          <source>as an array reference (as in the original Tie::Cycle example at the start of this section).</source>
          <target state="translated">이 섹션의 시작 부분에있는 원래 Tie :: Cycle 예제에서와 같이 배열 참조로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="1fedb298f571e978a357461bbaffb88fd67e6d25" translate="yes" xml:space="preserve">
          <source>as an input to makefile.pl above. Here</source>
          <target state="translated">위의 makefile.pl에 대한 입력으로. 여기</target>
        </trans-unit>
        <trans-unit id="22c9de0caa5ee810970ed637faf33df068656b95" translate="yes" xml:space="preserve">
          <source>as an instance method will reset the object to the initial state associated with</source>
          <target state="translated">인스턴스 메소드는 객체를 초기 상태로 재설정합니다.</target>
        </trans-unit>
        <trans-unit id="fec541f105313d0d35c30d128259bc532a7d9fe9" translate="yes" xml:space="preserve">
          <source>as are these</source>
          <target state="translated">이것들은</target>
        </trans-unit>
        <trans-unit id="3f566ada162944f7b5c8044e94db8ddd5ca7b693" translate="yes" xml:space="preserve">
          <source>as being identical to calling &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode($fh)&lt;/a&gt;&lt;/code&gt; - the stream is made suitable for passing binary data, i.e. each byte is passed as-is. The stream will still be buffered.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode($fh)&lt;/a&gt;&lt;/code&gt; 호출과 동일 -스트림은 이진 데이터를 전달하는 데 적합합니다. 즉, 각 바이트는 그대로 전달됩니다. 스트림은 여전히 ​​버퍼링됩니다.</target>
        </trans-unit>
        <trans-unit id="6161f340af63b0e200a55319e681127e8508a6df" translate="yes" xml:space="preserve">
          <source>as being identical to calling &lt;code&gt;binmode($fh)&lt;/code&gt; - the stream is made suitable for passing binary data, i.e. each byte is passed as-is. The stream will still be buffered (but this was not always true before Perl 5.14).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe36dc0e525faa7dfe808ab76ec97f002c503815" translate="yes" xml:space="preserve">
          <source>as characters in Perl's internal format. For example, to convert ISO-8859-1 data into Microsoft's CP1250 encoding:</source>
          <target state="translated">Perl의 내부 형식으로 문자로. 예를 들어, ISO-8859-1 데이터를 Microsoft의 CP1250 인코딩으로 변환하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="76512b54297f6cf3e5e9b678d4980ac295e114bd" translate="yes" xml:space="preserve">
          <source>as close as fsetpos() can get it -- for some record-structured files, it's not possible to return to the exact byte offset in the file). Because the file must be reopened, this function cannot be used on temporary-delete files. &lt;code&gt;binmode&lt;/code&gt; returns true if successful, and &lt;code&gt;undef&lt;/code&gt; if not.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52ad92a7cc1dc82c3b06fb1e695eb96d880a2a5a" translate="yes" xml:space="preserve">
          <source>as defined by ANSI C are</source>
          <target state="translated">ANSI C에서 정의한대로</target>
        </trans-unit>
        <trans-unit id="0db0e3d07dd3b225f470aaeae03a367dc468530e" translate="yes" xml:space="preserve">
          <source>as described &lt;a href=&quot;#The-Generic-Object&quot;&gt;further down&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#The-Generic-Object&quot;&gt;더 아래에&lt;/a&gt; 설명 된대로 .</target>
        </trans-unit>
        <trans-unit id="f8f8adcdf42c0a2a9a24916f1ba32a8d72714fa5" translate="yes" xml:space="preserve">
          <source>as expected. Without the specification of &lt;code&gt;&quot;&lt;/code&gt; as an embedded quoter:</source>
          <target state="translated">예상대로. 내장 인용 자로 &lt;code&gt;&quot;&lt;/code&gt; 를 지정하지 않은 경우 :</target>
        </trans-unit>
        <trans-unit id="50b0ba5762dbe68ffeef1f2372b2155aab4b196b" translate="yes" xml:space="preserve">
          <source>as far as &lt;code&gt;CODE:&lt;/code&gt; section or &lt;code&gt;PPCODE:&lt;/code&gt; section</source>
          <target state="translated">까지로 &lt;code&gt;CODE:&lt;/code&gt; 섹션 또는 &lt;code&gt;PPCODE:&lt;/code&gt; 섹션</target>
        </trans-unit>
        <trans-unit id="4baf8ad65f591cd293a9207d4c3e6ef80259ae5f" translate="yes" xml:space="preserve">
          <source>as far as you can in real-time.</source>
          <target state="translated">당신이 실시간으로 할 수있는 한.</target>
        </trans-unit>
        <trans-unit id="3f657c5685f4dbb2d51dff03864121342570902a" translate="yes" xml:space="preserve">
          <source>as follows). The name of suspects can either be canonical names or aliases.</source>
          <target state="translated">다음과 같이). 용의자 이름은 정식 이름 또는 별칭 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="44b2b85ecf80cc5b480b0158de904c01eefa0d24" translate="yes" xml:space="preserve">
          <source>as follows:</source>
          <target state="translated">다음과 같이 :</target>
        </trans-unit>
        <trans-unit id="ff4a3f206de020088e59ed005bda8b3029a132f8" translate="yes" xml:space="preserve">
          <source>as is</source>
          <target state="translated">그대로</target>
        </trans-unit>
        <trans-unit id="7be0a48e6cca430c773cf99a10b3b59e7934ed11" translate="yes" xml:space="preserve">
          <source>as it feels like a bit of an ugly hack in its current form.</source>
          <target state="translated">현재 형태의 약간 못생긴 해킹처럼 느껴집니다.</target>
        </trans-unit>
        <trans-unit id="878a917630b24304536b1a8522e60b14130b110d" translate="yes" xml:space="preserve">
          <source>as needed.</source>
          <target state="translated">필요에 따라.</target>
        </trans-unit>
        <trans-unit id="04c1652cedd98a02fd9b6c484913e570da0de636" translate="yes" xml:space="preserve">
          <source>as of version 2.x, these classes all work like their IO::Handle counterparts, so we have comparable functionality to IO::String.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b51e507fa59a767444dbf1b962a404eb04a8e4aa" translate="yes" xml:space="preserve">
          <source>as part of the 'distdir' target (and thus the 'dist' target). This is intended to seamlessly and rapidly populate CPAN with module meta-data. If you wish to shut this feature off, set the &lt;code&gt;NO_META&lt;/code&gt;&lt;code&gt;WriteMakefile()&lt;/code&gt; flag to true.</source>
          <target state="translated">'distdir'대상 ( 'dist'대상)의 일부로 이는 CPAN을 모듈 메타 데이터로 원활하고 빠르게 채울 수 있도록하기위한 것입니다. 이 기능을 끄려면 &lt;code&gt;NO_META&lt;/code&gt; &lt;code&gt;WriteMakefile()&lt;/code&gt; 플래그를 true로 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="1b4102fd0036fbd6a5a356f9ed338ac369433f6c" translate="yes" xml:space="preserve">
          <source>as passed in cannot be inferred from</source>
          <target state="translated">전달 된대로에서 추론 할 수없는</target>
        </trans-unit>
        <trans-unit id="6bfafaa825614e0de2c48caf94ccc39c5813c5c8" translate="yes" xml:space="preserve">
          <source>as returned by &lt;a href=&quot;#charblock%28%29&quot;&gt;&quot;charblock()&quot;&lt;/a&gt; and &lt;a href=&quot;#charscript%28%29&quot;&gt;&quot;charscript()&quot;&lt;/a&gt; or as the values of the hash returned by &lt;a href=&quot;#charblocks%28%29&quot;&gt;&quot;charblocks()&quot;&lt;/a&gt; and &lt;a href=&quot;#charscripts%28%29&quot;&gt;&quot;charscripts()&quot;&lt;/a&gt; by using &lt;code&gt;charinrange()&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a2383664a361c0b34599be3f0ddacd7781220e2a" translate="yes" xml:space="preserve">
          <source>as returned by &lt;a href=&quot;#charblock()&quot;&gt;charblock()&lt;/a&gt; and &lt;a href=&quot;#charscript()&quot;&gt;charscript()&lt;/a&gt; or as the values of the hash returned by &lt;a href=&quot;#charblocks()&quot;&gt;charblocks()&lt;/a&gt; and &lt;a href=&quot;#charscripts()&quot;&gt;charscripts()&lt;/a&gt; by using &lt;code&gt;charinrange()&lt;/code&gt; :</source>
          <target state="translated">로 돌려 &lt;a href=&quot;#charblock()&quot;&gt;charblock ()&lt;/a&gt; 및 &lt;a href=&quot;#charscript()&quot;&gt;charscript ()&lt;/a&gt; 또는에 의해 리턴 된 해시 값과 같은 &lt;a href=&quot;#charblocks()&quot;&gt;charblocks ()&lt;/a&gt; 및 &lt;a href=&quot;#charscripts()&quot;&gt;charscripts ()&lt;/a&gt; 를 사용하여 &lt;code&gt;charinrange()&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="c83d44be22c0359c7a8a15302b7f5e83e6b94790" translate="yes" xml:space="preserve">
          <source>as shown below.</source>
          <target state="translated">아래 그림과 같이.</target>
        </trans-unit>
        <trans-unit id="6daf9fe089003e9cf65e42ff59a1d2773ab32262" translate="yes" xml:space="preserve">
          <source>as the first argument</source>
          <target state="translated">첫 번째 논쟁으로</target>
        </trans-unit>
        <trans-unit id="9407051a9602683282da2f9d01eb30e33b699982" translate="yes" xml:space="preserve">
          <source>as the first character following a &lt;code&gt;&quot;|&quot;&lt;/code&gt; indicating alternation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="876bafcdbcd9c80a2d0e2065aacf3d301f41ca7b" translate="yes" xml:space="preserve">
          <source>as the first character following a quantifier</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31752488710cedb7490f87bbefd7d754b6bf2c00" translate="yes" xml:space="preserve">
          <source>as the first character in a parenthesized grouping like</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fbb92fe3e5232a0e7b3e34da6f4c5b70c782eec8" translate="yes" xml:space="preserve">
          <source>as the first character in a pattern, or following &lt;code&gt;&quot;^&quot;&lt;/code&gt; indicating to anchor the match to the beginning of a line.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ec18f4b29d19edda6a94614141eeda193afce50" translate="yes" xml:space="preserve">
          <source>as the first line in &lt;code&gt;*.cmd&lt;/code&gt; file (&lt;a href=&quot;#-S&quot;&gt;&quot;-S&quot;&lt;/a&gt; due to a bug in cmd.exe's `extproc' handling).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dcb44b7e0e1eb593d77c64f859e0a77259727455" translate="yes" xml:space="preserve">
          <source>as the first line in &lt;code&gt;*.cmd&lt;/code&gt; file (&lt;b&gt;-S&lt;/b&gt; due to a bug in cmd.exe's `extproc' handling).</source>
          <target state="translated">&lt;code&gt;*.cmd&lt;/code&gt; 파일 의 첫 줄로 ( cmd.exe의`extproc '처리 버그로 인해 &lt;b&gt;-S&lt;/b&gt; ).</target>
        </trans-unit>
        <trans-unit id="9afe0920031a79f7bd9f3454807b104ed19d1232" translate="yes" xml:space="preserve">
          <source>as the first line in &lt;code&gt;*.cmd&lt;/code&gt; file (&lt;code&gt;-S&lt;/code&gt; due to a bug in cmd.exe's &quot;extproc&quot; handling). For DOS one should first invent a corresponding batch file and codify it in &lt;code&gt;ALTERNATE_SHEBANG&lt;/code&gt; (see the</source>
          <target state="translated">&lt;code&gt;*.cmd&lt;/code&gt; 파일 의 첫 번째 줄로 ( cmd.exe의 &quot;extproc&quot;처리 버그로 인해 &lt;code&gt;-S&lt;/code&gt; ). DOS의 경우 먼저 해당 배치 파일을 발명하고 &lt;code&gt;ALTERNATE_SHEBANG&lt;/code&gt; 에 코드화해야 합니다 (</target>
        </trans-unit>
        <trans-unit id="aa88a9399009fa8389588f0aaf2da6151a41febb" translate="yes" xml:space="preserve">
          <source>as the first line instead. Or you can combine some of the above tricks:</source>
          <target state="translated">대신 첫 번째 줄로. 또는 위의 일부 트릭을 결합 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0d88bf94a93a4b61f0fa92dfc15bfef6b4012493" translate="yes" xml:space="preserve">
          <source>as the first line of the handler (see &lt;a href=&quot;../perlvar#%24%5eS&quot;&gt;$^S in perlvar&lt;/a&gt;). Because this promotes strange action at a distance, this counterintuitive behavior may be fixed in a future release.</source>
          <target state="translated">핸들러의 첫 번째 줄로 ( &lt;a href=&quot;../perlvar#%24%5eS&quot;&gt;perlvar의 $ ^ S&lt;/a&gt; 참조 ). 이로 인해 원거리에서 이상한 동작이 발생하므로이 반 직관적 인 동작은 향후 릴리스에서 수정 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fff15c63127de3a3ff7f6050294a22c662f8a08c" translate="yes" xml:space="preserve">
          <source>as the first line of the handler (see &lt;a href=&quot;perlvar#%24%5ES&quot;&gt;&quot;$^S&quot; in perlvar&lt;/a&gt;). Because this promotes strange action at a distance, this counterintuitive behavior may be fixed in a future release.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17abd9184d2928495e286f5f11862b4c9a8071d0" translate="yes" xml:space="preserve">
          <source>as the first line of the handler (see &lt;a href=&quot;perlvar#%24%5eS&quot;&gt;$^S in perlvar&lt;/a&gt;). Because this promotes strange action at a distance, this counterintuitive behavior may be fixed in a future release.</source>
          <target state="translated">핸들러의 첫 번째 줄로 ( &lt;a href=&quot;perlvar#%24%5eS&quot;&gt;perlvar의 $ ^ S&lt;/a&gt; 참조 ). 이로 인해 원거리에서 이상한 동작이 발생하므로이 반 직관적 인 동작은 향후 릴리스에서 수정 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bf7d822469082c4bfc650c2ae1a9bcefcadfb22e" translate="yes" xml:space="preserve">
          <source>as the key. In most cases, this contains only a few keys, but if Perl was invoked via the C &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec[lv]e()&lt;/a&gt;&lt;/code&gt; function, as is the case for some embedded Perl applications or when running under a shell such as GNV bash, the &lt;code&gt;environ&lt;/code&gt; array may have been populated by the calling program.</source>
          <target state="translated">열쇠로. 대부분의 경우 여기에는 몇 개의 키만 포함되어 있지만 Perl이 C &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec[lv]e()&lt;/a&gt;&lt;/code&gt; 함수 를 통해 호출 된 경우 일부 임베디드 Perl 응용 프로그램의 경우와 같이 또는 &lt;code&gt;environ&lt;/code&gt; GNV bash와 같은 쉘에서 실행될 때 호출 프로그램이 배열을 채웠을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="97749d136001e0ac0fff651b01f4546d71a8a4e7" translate="yes" xml:space="preserve">
          <source>as the key. In most cases, this contains only a few keys, but if Perl was invoked via the C &lt;code&gt;exec[lv]e()&lt;/code&gt; function, as is the case for some embedded Perl applications or when running under a shell such as GNV bash, the &lt;code&gt;environ&lt;/code&gt; array may have been populated by the calling program.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d01b7b2a5e71d9e7c928d505a1b934e42c98d8d" translate="yes" xml:space="preserve">
          <source>as the logical name. The normal search order of access modes is used.</source>
          <target state="translated">논리적 이름으로. 액세스 모드의 일반적인 검색 순서가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="24bb2a3db47e83fda820245153deab8162cb8ccb" translate="yes" xml:space="preserve">
          <source>as the name of the symbol. When reading an element of &lt;code&gt;%ENV&lt;/code&gt; , the local symbol table is scanned first, followed by the global symbol table.. The characters following &lt;code&gt;CLISYM_&lt;/code&gt; are significant when an element of &lt;code&gt;%ENV&lt;/code&gt; is set or deleted: if the complete string is &lt;code&gt;CLISYM_LOCAL&lt;/code&gt; , the change is made in the local symbol table; otherwise the global symbol table is changed.</source>
          <target state="translated">기호의 이름으로. &lt;code&gt;%ENV&lt;/code&gt; 요소를 읽을 때 로컬 기호 테이블이 먼저 스캔 된 다음 전역 기호 테이블이 스캔됩니다. &lt;code&gt;CLISYM_&lt;/code&gt; 뒤에 오는 문자 는 &lt;code&gt;%ENV&lt;/code&gt; 요소 가 설정되거나 삭제 될 때 중요 합니다. 전체 문자열이 &lt;code&gt;CLISYM_LOCAL&lt;/code&gt; 인 경우 변경 사항 로컬 심볼 테이블에서 이루어집니다. 그렇지 않으면 전역 기호 테이블이 변경됩니다.</target>
        </trans-unit>
        <trans-unit id="4a2e5b87c98feecb2abf855fc73ff54a461f6270" translate="yes" xml:space="preserve">
          <source>as the name of the symbol. When reading an element of &lt;code&gt;%ENV&lt;/code&gt;, the local symbol table is scanned first, followed by the global symbol table.. The characters following &lt;code&gt;CLISYM_&lt;/code&gt; are significant when an element of &lt;code&gt;%ENV&lt;/code&gt; is set or deleted: if the complete string is &lt;code&gt;CLISYM_LOCAL&lt;/code&gt;, the change is made in the local symbol table; otherwise the global symbol table is changed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43689b10d7e82ce746d34de5bbe78235ef4476bd" translate="yes" xml:space="preserve">
          <source>as though the argument to &lt;code&gt;given&lt;/code&gt; were an element of the hash &lt;code&gt;%foo&lt;/code&gt; , interpreting the braces as hash-element syntax.</source>
          <target state="translated">&lt;code&gt;given&lt;/code&gt; 인수가 해시 &lt;code&gt;%foo&lt;/code&gt; 의 요소 인 것처럼 중괄호를 해시 요소 구문으로 해석합니다.</target>
        </trans-unit>
        <trans-unit id="11a80ce09776b66373e6105adffc34d0f706cedb" translate="yes" xml:space="preserve">
          <source>as though the argument to &lt;code&gt;given&lt;/code&gt; were an element of the hash &lt;code&gt;%foo&lt;/code&gt;, interpreting the braces as hash-element syntax.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9aa9ebca57db525b108992870f6a6a0744343a91" translate="yes" xml:space="preserve">
          <source>as though you stored the same variable reference each time, you actually did not! This is a subtle distinction that can produce more efficient code at the risk of misleading all but the most experienced of programmers. So I usually advise against teaching it to beginners. In fact, except for passing arguments to functions, I seldom like to see the gimme-a-reference operator (backslash) used much at all in code. Instead, I advise beginners that they (and most of the rest of us) should try to use the much more easily understood constructors &lt;code&gt;[]&lt;/code&gt; and &lt;code&gt;{}&lt;/code&gt; instead of relying upon lexical (or dynamic) scoping and hidden reference-counting to do the right thing behind the scenes.</source>
          <target state="translated">매번 같은 변수 참조를 저장 한 것처럼 실제로는 그렇지 않습니다! 이것은 가장 숙련 된 프로그래머를 제외한 모든 사람을 오도 할 위험이있는보다 효율적인 코드를 생성 할 수있는 미묘한 차이입니다. 그래서 나는 보통 초보자에게 가르치지 말 것을 권합니다. 실제로 함수에 인수를 전달하는 것을 제외하고는 코드에서 김미-참조 연산자 (백 슬래시)가 많이 사용되는 것을 거의 좋아하지 않습니다. 대신 초보자들에게 (그리고 우리 대부분은 ) 올바른 어휘 (또는 동적) 범위 지정 및 숨겨진 참조 계산에 의존하는 대신 훨씬 쉽게 이해되는 생성자 &lt;code&gt;[]&lt;/code&gt; 및 &lt;code&gt;{}&lt;/code&gt; 를 사용해야한다고 조언합니다. 무대 뒤에서.</target>
        </trans-unit>
        <trans-unit id="1b721d8a6c65b8f505bf083f7362443eee48e0d5" translate="yes" xml:space="preserve">
          <source>as used in</source>
          <target state="translated">에 사용되는</target>
        </trans-unit>
        <trans-unit id="73b20ad0fd8d8906b930c36d48ac0a852e8a70ab" translate="yes" xml:space="preserve">
          <source>as usual</source>
          <target state="translated">평소와 같이</target>
        </trans-unit>
        <trans-unit id="44bbbac4257f66442d2eb3ff68d4b9dd4661140f" translate="yes" xml:space="preserve">
          <source>as we know that if the final quote does not match, backtracking will not help. See the independent subexpression &lt;a href=&quot;#%28%3F%3Epattern%29&quot;&gt;&quot;&lt;code&gt;(?&amp;gt;&lt;i&gt;pattern&lt;/i&gt;)&lt;/code&gt;&quot;&lt;/a&gt; for more details; possessive quantifiers are just syntactic sugar for that construct. For instance the above example could also be written as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9fa196bf1305f9de2ff08f52aee250714a733647" translate="yes" xml:space="preserve">
          <source>as we know that if the final quote does not match, backtracking will not help. See the independent subexpression &lt;a href=&quot;#(%3f%3epattern)&quot;&gt;(?&amp;gt;pattern)&lt;/a&gt; for more details; possessive quantifiers are just syntactic sugar for that construct. For instance the above example could also be written as follows:</source>
          <target state="translated">최종 견적이 일치하지 않으면 역 추적이 도움이되지 않습니다. 자세한 내용은 독립 하위 표현식 &lt;a href=&quot;#(%3f%3epattern)&quot;&gt;(?&amp;gt; 패턴)&lt;/a&gt; 을 참조하십시오. 소유 정량자는 그 구성에 대한 구문 설탕 일뿐입니다. 예를 들어 위의 예는 다음과 같이 작성할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="983291ad5e53a2455ef9e77e2de94ef019d4ba61" translate="yes" xml:space="preserve">
          <source>as well (I use one from pdksh). The path</source>
          <target state="translated">또한 (나는 pdksh에서 하나를 사용합니다). 경로</target>
        </trans-unit>
        <trans-unit id="ffcbb6274e566044113aaf2e534009b9310ede89" translate="yes" xml:space="preserve">
          <source>as well.</source>
          <target state="translated">게다가.</target>
        </trans-unit>
        <trans-unit id="0b2d56ecd63cccc527289487cbff82b5288f062d" translate="yes" xml:space="preserve">
          <source>as well. Here's a sample entry from that table:</source>
          <target state="translated">게다가. 해당 테이블의 샘플 항목은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="163b9e6ac2b85e0d1d3b25a5f039388d7483329f" translate="yes" xml:space="preserve">
          <source>as well. Options are not necessary for the program to work, hence the name 'option', but are used to modify its default behaviour. For example, a program could do its job quietly, but with a suitable option it could provide verbose information about what it did.</source>
          <target state="translated">게다가. 프로그램이 작동하는 데 옵션이 필요하지 않으므로 'option'이라는 이름이 사용되지만 기본 동작을 수정하는 데 사용됩니다. 예를 들어, 프로그램은 조용히 작업을 수행 할 수 있지만 적절한 옵션을 사용하면 수행 한 작업에 대한 자세한 정보를 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d09a858ce6260c8d7abc7cb8de62a0dcf62e09bc" translate="yes" xml:space="preserve">
          <source>as, say, an informal verbal description of the solution, or maybe of the problem itself. Isomorphism is, all things considered, a good thing -- it's what problem-solving (and solution-implementing) should look like.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eef0ed9c31886aeeaa457a7d910b34a3053cddad" translate="yes" xml:space="preserve">
          <source>as_array_ref</source>
          <target state="translated">as_array_ref</target>
        </trans-unit>
        <trans-unit id="e0f6619c3a0d789145899e0d26503b93025880f2" translate="yes" xml:space="preserve">
          <source>as_bin()</source>
          <target state="translated">as_bin()</target>
        </trans-unit>
        <trans-unit id="40bdfd6d624e1b42c7cc51b1e448916ea2d92b71" translate="yes" xml:space="preserve">
          <source>as_bytes()</source>
          <target state="translated">as_bytes()</target>
        </trans-unit>
        <trans-unit id="edc387c660a2b1d84db9f995c1394b0c8f7a00e2" translate="yes" xml:space="preserve">
          <source>as_embedded_typemap</source>
          <target state="translated">as_embedded_typemap</target>
        </trans-unit>
        <trans-unit id="6293714a50a40120f58b4889cff9a65fc732965e" translate="yes" xml:space="preserve">
          <source>as_float()</source>
          <target state="translated">as_float()</target>
        </trans-unit>
        <trans-unit id="c3bc5083cb007923550a1a79fad46180e4d878d7" translate="yes" xml:space="preserve">
          <source>as_hex()</source>
          <target state="translated">as_hex()</target>
        </trans-unit>
        <trans-unit id="bc3cc61bddf0ceabd9f1560cabae0f1be60cc55a" translate="yes" xml:space="preserve">
          <source>as_int()</source>
          <target state="translated">as_int()</target>
        </trans-unit>
        <trans-unit id="003d7a49b767183e39c1b831d4ce7263b750ea27" translate="yes" xml:space="preserve">
          <source>as_int()/as_number()</source>
          <target state="translated">as_int()/as_number()</target>
        </trans-unit>
        <trans-unit id="b901ccf25d95c87562bcdfb5d854356765564f55" translate="yes" xml:space="preserve">
          <source>as_number()</source>
          <target state="translated">as_number()</target>
        </trans-unit>
        <trans-unit id="1200fa194bbc6cba8352b08f67c5ac42078a226e" translate="yes" xml:space="preserve">
          <source>as_oct()</source>
          <target state="translated">as_oct()</target>
        </trans-unit>
        <trans-unit id="2dc8b10c6044c7ab41c6f916b29864155fdf6c87" translate="yes" xml:space="preserve">
          <source>as_string</source>
          <target state="translated">as_string</target>
        </trans-unit>
        <trans-unit id="79edeb962f22e5ee518d39d18e4506c6a2b5ec69" translate="yes" xml:space="preserve">
          <source>as_string_hash</source>
          <target state="translated">as_string_hash</target>
        </trans-unit>
        <trans-unit id="2e17f160551d1e72c91cdeef2d49ac65c0a67ed8" translate="yes" xml:space="preserve">
          <source>as_struct</source>
          <target state="translated">as_struct</target>
        </trans-unit>
        <trans-unit id="51c066b36ea8b32076964c766f8a0324ca4eb4b9" translate="yes" xml:space="preserve">
          <source>ascii</source>
          <target state="translated">ascii</target>
        </trans-unit>
        <trans-unit id="2c5c18b2494af0fdcd4a7646d2bde2acf847922a" translate="yes" xml:space="preserve">
          <source>ascii ()</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7bc42c101bb8f021d4d389de2f96e84e8de1f7a" translate="yes" xml:space="preserve">
          <source>ascii-ctrl</source>
          <target state="translated">ascii-ctrl</target>
        </trans-unit>
        <trans-unit id="37116f0d227d355bdd165be4b2525441b7ee7e2d" translate="yes" xml:space="preserve">
          <source>asin_real</source>
          <target state="translated">asin_real</target>
        </trans-unit>
        <trans-unit id="ce10f51d7f39f9fc7631435563d91f1e2dd622f5" translate="yes" xml:space="preserve">
          <source>ask DB not to stop in these packages</source>
          <target state="translated">이 패키지에서 DB를 멈추지 말라고 요청하십시오.</target>
        </trans-unit>
        <trans-unit id="dee174cbea8bd461e964d43d9629142d0f5e9d72" translate="yes" xml:space="preserve">
          <source>assemble_meta</source>
          <target state="translated">assemble_meta</target>
        </trans-unit>
        <trans-unit id="968a55475a44bc5482314bb7ff3d7a7b37523d7b" translate="yes" xml:space="preserve">
          <source>assert =&amp;gt; {...}</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60544f107576aa75a3a16e2a4d455e8086f18203" translate="yes" xml:space="preserve">
          <source>assertion</source>
          <target state="translated">assertion</target>
        </trans-unit>
        <trans-unit id="18b112e36da8d8376cd2fe7f89592c89b4aefda7" translate="yes" xml:space="preserve">
          <source>assertion botched: %s</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1487b0062ddd019485245d3093b4a8ca191dae6" translate="yes" xml:space="preserve">
          <source>assign arg_hashref, VALUE...</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1318e069379ae6cb3a70ee42a96546f428da471f" translate="yes" xml:space="preserve">
          <source>assign_func_args()</source>
          <target state="translated">assign_func_args()</target>
        </trans-unit>
        <trans-unit id="c4407719eccaafa9bde053b1db60d6c0d61f7672" translate="yes" xml:space="preserve">
          <source>assigned</source>
          <target state="translated">assigned</target>
        </trans-unit>
        <trans-unit id="f26b63d628c9b5679c54e6f8f5ee244932da2d7d" translate="yes" xml:space="preserve">
          <source>assignment</source>
          <target state="translated">assignment</target>
        </trans-unit>
        <trans-unit id="3ef74078d06ba61e79bd2aa5816e90a3035fcea9" translate="yes" xml:space="preserve">
          <source>assignment operator</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18237e23354148ad3de3fd278a74bf877d784ef2" translate="yes" xml:space="preserve">
          <source>assignment-variants of operators are present in the script, they may be generated by the optimizer. For example,</source>
          <target state="translated">연산자의 할당 변수는 스크립트에 존재하며 옵티 마이저에 의해 생성 될 수 있습니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="19f88cb673e51233787f63a133933b396397ecad" translate="yes" xml:space="preserve">
          <source>assigns the entire list value to array @foo, but</source>
          <target state="translated">전체 목록 값을 배열 @foo에 할당하지만</target>
        </trans-unit>
        <trans-unit id="bac4a6a253f6704e2643e1787606b1818276ab16" translate="yes" xml:space="preserve">
          <source>assigns the value of variable $bar to the scalar variable $foo. Note that the value of an actual array in scalar context is the length of the array; the following assigns the value 3 to $foo:</source>
          <target state="translated">변수 $ bar의 값을 스칼라 변수 $ foo에 지정합니다. 스칼라 컨텍스트에서 실제 배열의 값은 배열의 길이입니다. 다음은 값 3을 $ foo에 지정합니다.</target>
        </trans-unit>
        <trans-unit id="a2c480bb0d3fb166118fff165602dfb3d8755b71" translate="yes" xml:space="preserve">
          <source>associated with a particular file.</source>
          <target state="translated">특정 파일과 연관되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="d03fe2e108278a21db78ad03f95614754c65b243" translate="yes" xml:space="preserve">
          <source>associations</source>
          <target state="translated">associations</target>
        </trans-unit>
        <trans-unit id="c86461f009279cf7d8a8df8f4a2bee27c0ebd359" translate="yes" xml:space="preserve">
          <source>associative array</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eab9b6ea2f82fe54324a745a0be4d6d10a9fd0e5" translate="yes" xml:space="preserve">
          <source>associativity</source>
          <target state="translated">associativity</target>
        </trans-unit>
        <trans-unit id="ae321c05bada36b13f653e5d63881d2980254f64" translate="yes" xml:space="preserve">
          <source>assumes that either the layer has popped itself, or the layer is super special and needs to be retained for other reasons. In most cases it should return</source>
          <target state="translated">레이어 자체가 튀어 나오거나 레이어가 특별하고 다른 이유로 유지해야한다고 가정합니다. 대부분의 경우 반환해야합니다</target>
        </trans-unit>
        <trans-unit id="617755c776549d8f4f3362cdb6a17b675ef13281" translate="yes" xml:space="preserve">
          <source>assuming you have mounted that CD on /cdrom.</source>
          <target state="translated">CD를 / cdrom에 마운트했다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="c359d69f3f08bb920f2c3b51133205533462093e" translate="yes" xml:space="preserve">
          <source>asy</source>
          <target state="translated">asy</target>
        </trans-unit>
        <trans-unit id="0882a2912a64e563c60a0dab0177a420839995db" translate="yes" xml:space="preserve">
          <source>async BLOCK;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d752f2c5e9504352a8b5051da82d8c592e4d092" translate="yes" xml:space="preserve">
          <source>asynchronous</source>
          <target state="translated">asynchronous</target>
        </trans-unit>
        <trans-unit id="3602b9270e66ab97788614f8a3fd98920bdaf5c7" translate="yes" xml:space="preserve">
          <source>at &lt;a href=&quot;http://developer.apple.com/documentation/Darwin/Conceptual/64bitPorting/index.html&quot;&gt;http://developer.apple.com/documentation/Darwin/Conceptual/64bitPorting/index.html&lt;/a&gt;.</source>
          <target state="translated">에서 &lt;a href=&quot;http://developer.apple.com/documentation/Darwin/Conceptual/64bitPorting/index.html&quot;&gt;http://developer.apple.com/documentation/Darwin/Conceptual/64bitPorting/index.html&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="412f08a017337a56b4152e7bc3cd13375ff3254f" translate="yes" xml:space="preserve">
          <source>at &lt;a href=&quot;http://perltraining.com.au/tips/2008-08-20.html&quot;&gt;http://perltraining.com.au/tips/2008-08-20.html&lt;/a&gt;</source>
          <target state="translated">에서 &lt;a href=&quot;http://perltraining.com.au/tips/2008-08-20.html&quot;&gt;http://perltraining.com.au/tips/2008-08-20.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="03c141a669d4789a3576e1e16161a6d944f70e9f" translate="yes" xml:space="preserve">
          <source>at &lt;a href=&quot;https://developer.apple.com/library/archive/documentation/Darwin/Conceptual/64bitPorting/transition/transition.html&quot;&gt;https://developer.apple.com/library/archive/documentation/Darwin/Conceptual/64bitPorting/transition/transition.html&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="763fd237e6f3831141eb71f2fa9c664c2d5dde22" translate="yes" xml:space="preserve">
          <source>at a given position</source>
          <target state="translated">주어진 위치에서</target>
        </trans-unit>
        <trans-unit id="9a37607749afe8d9567c08deb31e518558e6f3b5" translate="yes" xml:space="preserve">
          <source>at any one time.</source>
          <target state="translated">어느 한 순간에.</target>
        </trans-unit>
        <trans-unit id="850ad5d4afbea97738fa95acd1da7e607bd530cc" translate="yes" xml:space="preserve">
          <source>at compile time</source>
          <target state="translated">컴파일 타임에</target>
        </trans-unit>
        <trans-unit id="b4e380389a774a586c5fa16ad6f747ccd0f5dd49" translate="yes" xml:space="preserve">
          <source>at least</source>
          <target state="translated">적어도</target>
        </trans-unit>
        <trans-unit id="9564a8b2dea482cb502ddc133f411fb7baa8cd10" translate="yes" xml:space="preserve">
          <source>at make time, so you should make perl to follow this along.</source>
          <target state="translated">제작 시간에 펄을 따라야합니다.</target>
        </trans-unit>
        <trans-unit id="fbb06e3442915398475cc3a04245a5bbaff4859c" translate="yes" xml:space="preserve">
          <source>at most</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32f22c8244d7198bc5973a52b7e608dea1b695bc" translate="yes" xml:space="preserve">
          <source>at run time</source>
          <target state="translated">런타임에</target>
        </trans-unit>
        <trans-unit id="e490f3a80d5cc3f15d3885d16099e39047e2c3bc" translate="yes" xml:space="preserve">
          <source>at startup (in a BEGIN block). This is a hook that allows the sysadmin to customize how Perl behaves. It can for instance be used to add entries to the @INC array to make Perl find modules in non-standard locations.</source>
          <target state="translated">시작시 (BEGIN 블록에서). 이것은 sysadmin이 Perl의 동작 방식을 사용자 정의 할 수있는 후크입니다. 예를 들어 @INC 배열에 항목을 추가하여 Perl이 비표준 위치에서 모듈을 찾도록하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="15d1d5e3a86f87da2663eae7907bc2307a399554" translate="yes" xml:space="preserve">
          <source>at startup.</source>
          <target state="translated">시작할 때.</target>
        </trans-unit>
        <trans-unit id="fdc8cfe05d049efd8ba3e7434e7eaf619158eb0f" translate="yes" xml:space="preserve">
          <source>at the C level</source>
          <target state="translated">C 레벨에서</target>
        </trans-unit>
        <trans-unit id="c1388282fa974c0f59a57d7833efecdf9f582735" translate="yes" xml:space="preserve">
          <source>at the end</source>
          <target state="translated">결국</target>
        </trans-unit>
        <trans-unit id="9217e9b0a48bcfc528a9d49dbdf842dbf2a6a760" translate="yes" xml:space="preserve">
          <source>at the end. The &lt;code&gt;ENTER&lt;/code&gt; /&lt;code&gt;SAVETMPS&lt;/code&gt; pair creates a boundary for any temporaries we create. This means that the temporaries we get rid of will be limited to those which were created after these calls.</source>
          <target state="translated">끝에. 는 &lt;code&gt;ENTER&lt;/code&gt; / &lt;code&gt;SAVETMPS&lt;/code&gt; 의 쌍 우리가 만드는 모든 임시직에 대한 경계를 만듭니다. 즉, 우리가 제거하는 임시는 이러한 호출 후 생성 된 임시로 제한됩니다.</target>
        </trans-unit>
        <trans-unit id="2c2abfb06e2552e16d1caee4efd7dc6a9a792926" translate="yes" xml:space="preserve">
          <source>at the end. The &lt;code&gt;ENTER&lt;/code&gt;/&lt;code&gt;SAVETMPS&lt;/code&gt; pair creates a boundary for any temporaries we create. This means that the temporaries we get rid of will be limited to those which were created after these calls.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8dcfd128d2ba54e6c9380293b323b1260cdc3701" translate="yes" xml:space="preserve">
          <source>at the same level of nesting</source>
          <target state="translated">같은 수준의 중첩</target>
        </trans-unit>
        <trans-unit id="8e1733375a8dd981de1735fa2875f132e477b6da" translate="yes" xml:space="preserve">
          <source>at the start (or near the start) of your program. (Note that this</source>
          <target state="translated">프로그램의 시작 (또는 시작 근처)에 (이것은</target>
        </trans-unit>
        <trans-unit id="37f302ce8124164c6fcfe7d012fcfb1e33675294" translate="yes" xml:space="preserve">
          <source>at the start of the function, and</source>
          <target state="translated">기능이 시작될 때</target>
        </trans-unit>
        <trans-unit id="9b151ca84837e5f88e85ae049f9b552e13c6fe0d" translate="yes" xml:space="preserve">
          <source>at the top of your code.</source>
          <target state="translated">코드 상단에.</target>
        </trans-unit>
        <trans-unit id="89c4f7ac43cc28c22dbb5ebc96fabde7dae0b382" translate="yes" xml:space="preserve">
          <source>at the top of your program, where &lt;b&gt;-mysw&lt;/b&gt; are any command line switches you want to pass to Perl. You can now invoke the program directly, by saying &lt;code&gt;perl program&lt;/code&gt; , or as a DCL procedure, by saying &lt;code&gt;@program&lt;/code&gt; (or implicitly via</source>
          <target state="translated">프로그램 맨 위에서 &lt;b&gt;-mysw&lt;/b&gt; 는 Perl에 전달할 명령 행 스위치입니다. 이제 &lt;code&gt;perl program&lt;/code&gt; 을 말 하거나 DCL 프로 시저로 &lt;code&gt;@program&lt;/code&gt; 을 말 하여 프로그램을 직접 호출 할 수 있습니다. (또는 암시 적으로 통해)을 통해</target>
        </trans-unit>
        <trans-unit id="010076c360aa51a67431ee949d9678e570e14d81" translate="yes" xml:space="preserve">
          <source>at the top of your program, where &lt;b&gt;-mysw&lt;/b&gt; are any command line switches you want to pass to Perl. You can now invoke the program directly, by saying &lt;code&gt;perl program&lt;/code&gt;, or as a DCL procedure, by saying &lt;code&gt;@program&lt;/code&gt; (or implicitly via</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e70d57f73905d45b6f79912c7b2b82874d2e8a5" translate="yes" xml:space="preserve">
          <source>at the top of your program. This aliases all the short names to the long names in the current package. Some even have medium names, generally borrowed from &lt;b&gt;awk&lt;/b&gt;. For more info, please see &lt;a href=&quot;english&quot;&gt;English&lt;/a&gt;.</source>
          <target state="translated">프로그램 맨 위에 이렇게하면 모든 짧은 이름이 현재 패키지의 긴 이름으로 별칭이 지정됩니다. 일부는 보통 &lt;b&gt;awk&lt;/b&gt; 에서 빌린 중간 이름을 갖습니다 . 자세한 내용은 &lt;a href=&quot;english&quot;&gt;영어&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="5c4d67f365ec49b947ee79badac65584b0444347" translate="yes" xml:space="preserve">
          <source>at the top of your script, Math::BigFloat and Math::BigInt will be loaded and any constant number will be converted to an object (Math::BigFloat for floats like 3.1415 and Math::BigInt for integers like 1234).</source>
          <target state="translated">스크립트 상단에 Math :: BigFloat 및 Math :: BigInt가로드되고 상수가 객체로 변환됩니다 (3.415와 같은 부동 소수점의 경우 Math :: BigFloat, 1234와 같은 정수의 경우 Math :: BigInt).</target>
        </trans-unit>
        <trans-unit id="c90414cee16b2af97b8d5180cc885c0f62d6800c" translate="yes" xml:space="preserve">
          <source>at which point %greetings has the contents:</source>
          <target state="translated">% greetings의 내용이있는 시점 :</target>
        </trans-unit>
        <trans-unit id="3bb758cfc583548bd5a6d49b0a553b6fe91a0689" translate="yes" xml:space="preserve">
          <source>at your peril</source>
          <target state="translated">당신의 위험에</target>
        </trans-unit>
        <trans-unit id="b1a7357ef61ecd1781b4633dc3e33a383686041c" translate="yes" xml:space="preserve">
          <source>atan2</source>
          <target state="translated">atan2</target>
        </trans-unit>
        <trans-unit id="fc337a53ff380e9cc91c7f4ada35b7c83e1170cd" translate="yes" xml:space="preserve">
          <source>atan2 Y,X</source>
          <target state="translated">atan2 Y, X</target>
        </trans-unit>
        <trans-unit id="e226f7ca13e8e842c24e08f6089be3e8e4a7dbda" translate="yes" xml:space="preserve">
          <source>atfork_lock</source>
          <target state="translated">atfork_lock</target>
        </trans-unit>
        <trans-unit id="7dedf46132af7daae669d99e34058a9d69562014" translate="yes" xml:space="preserve">
          <source>atfork_unlock</source>
          <target state="translated">atfork_unlock</target>
        </trans-unit>
        <trans-unit id="f7243228637fb0b2ed90f7f5c750564b9733bc3b" translate="yes" xml:space="preserve">
          <source>atmark</source>
          <target state="translated">atmark</target>
        </trans-unit>
        <trans-unit id="5604a15f93274b4be18e2e5703972fcae8d4191f" translate="yes" xml:space="preserve">
          <source>atolf.U</source>
          <target state="translated">atolf.U</target>
        </trans-unit>
        <trans-unit id="20378f82e37925c4f68137e0b5f0ceba9d2f7e7d" translate="yes" xml:space="preserve">
          <source>atoll.U</source>
          <target state="translated">atoll.U</target>
        </trans-unit>
        <trans-unit id="c6f57180e462a4f1e9de24fbe811cfb2c24a0cf9" translate="yes" xml:space="preserve">
          <source>atom</source>
          <target state="translated">atom</target>
        </trans-unit>
        <trans-unit id="7e56d75872e5c121dfdfb6a14a9691cd17d30089" translate="yes" xml:space="preserve">
          <source>atomic operation</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c4db99fa19aece67f97821a83c30ca20f360728" translate="yes" xml:space="preserve">
          <source>attach ( [FLAG] )</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e96175f76342acf17b6320df16c52fb6bb0caad" translate="yes" xml:space="preserve">
          <source>attrLetsToBits</source>
          <target state="translated">attrLetsToBits</target>
        </trans-unit>
        <trans-unit id="2c317cd0735d9046d7675c475fa1c6dce647953f" translate="yes" xml:space="preserve">
          <source>attribute</source>
          <target state="translated">attribute</target>
        </trans-unit>
        <trans-unit id="e23a34b8f5b2f31817cabbac17ddfd0c73c0f578" translate="yes" xml:space="preserve">
          <source>attribute and a &lt;a href=&quot;to&quot;&gt;to&lt;/a&gt; attribute. For example, this Pod source:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36eb16110eb8a88635119857df79b6c64c120d6b" translate="yes" xml:space="preserve">
          <source>attribute contains the raw, original, unescaped content of the &lt;code&gt;L&amp;lt;&amp;gt;&lt;/code&gt; formatting code. In addition to the examples above, take notice of the following event structure produced by the following &lt;code&gt;L&amp;lt;&amp;gt;&lt;/code&gt; formatting code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36c2be758a3cc76c4623d17431c991d982269863" translate="yes" xml:space="preserve">
          <source>attribute depends on what the raw content of the &lt;code&gt;L&amp;lt;&amp;gt;&lt;/code&gt; is, so that is why the event structure is the same &quot;for the most part&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aaa7447496328d92dc17c3d0fc8649f8ad7d1856" translate="yes" xml:space="preserve">
          <source>attribute for this start-token object to</source>
          <target state="translated">이 시작 토큰 객체의 속성을</target>
        </trans-unit>
        <trans-unit id="33337ed515c0adfa6a07049f9d97abb273869d7a" translate="yes" xml:space="preserve">
          <source>attribute for this start-token object, or undef.</source>
          <target state="translated">이 시작 토큰 객체의 속성 또는 undef.</target>
        </trans-unit>
        <trans-unit id="635b70015e7c05f3ddf797a8016ddd2b877116b9" translate="yes" xml:space="preserve">
          <source>attribute has the value &quot;4&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab2d8bd4a863914c6fe78c4af3b83e46cf21742e" translate="yes" xml:space="preserve">
          <source>attribute instead of a</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a27fffadd78aff8aea90f322d0e3c182ebe8fc6" translate="yes" xml:space="preserve">
          <source>attribute is always present, and always has the value &quot;preserve&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4de5ab6e74bf90046665d795fb6fd86c7fc33389" translate="yes" xml:space="preserve">
          <source>attribute is whatever value is after the &quot;=over&quot; directive, as in &quot;=over 8&quot;. If no such value is specified in the directive, then the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0dc11438dd7a3a71579ff2fbd4cbd865389001ea" translate="yes" xml:space="preserve">
          <source>attribute where any surrounding whitespace is condensed into a single ' '. For example, given L&amp;lt; link&amp;gt;,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5bd5029c0ee8c537ceb3bcafc356535c41535530" translate="yes" xml:space="preserve">
          <source>attribute will be the line number of the first Pod directive in the document.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d033607bbf34f83e3630b1dd80582d806a15726d" translate="yes" xml:space="preserve">
          <source>attribute will be the line number of the first line of this verbatim block. The</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01b5548d2ec00f76ce8edd8361665d4a2eee529f" translate="yes" xml:space="preserve">
          <source>attribute will be the line number of the start of the paragraph.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39b20fba0fab9ba18103ec2bd1356db9bef98d4f" translate="yes" xml:space="preserve">
          <source>attribute will not be meaningful; under current implementations, it will probably be the line number of the last line in the file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="120352409cf88bde6a5d6d735c82d284a63f2f2f" translate="yes" xml:space="preserve">
          <source>attribute,</source>
          <target state="translated">attribute,</target>
        </trans-unit>
        <trans-unit id="d3b2de5fec7ca4555161fd1b778fee83a6e6a5b7" translate="yes" xml:space="preserve">
          <source>attribute, and there will be no &lt;code&gt;content-implicit=&quot;yes&quot;&lt;/code&gt; attribute (whose presence means that the Pod parser had to infer what text should appear as the link text -- as opposed to cases where that attribute is absent, which means that the Pod parser did</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90d08262e5d32be186d16ff80c527ee8f0047168" translate="yes" xml:space="preserve">
          <source>attribute, or both. The &lt;code&gt;type=&quot;pod&quot;&lt;/code&gt; attribute is always specified for this type of L code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8109399516cf822497cfea4844218e9687c1dde1" translate="yes" xml:space="preserve">
          <source>attribute, whereas this Pod source:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="532e0b673f29b33974de4e5cfb765377c850dfdb" translate="yes" xml:space="preserve">
          <source>attribute. For example, this Pod source:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7f67a250d8254339cc572b200990d99fe1baf29" translate="yes" xml:space="preserve">
          <source>attributes</source>
          <target state="translated">attributes</target>
        </trans-unit>
        <trans-unit id="247d5e69b38550a7d0b09aea424ed5dab3a67bad" translate="yes" xml:space="preserve">
          <source>attributes - get/set subroutine or variable attributes</source>
          <target state="translated">속성-서브 루틴 또는 변수 속성 가져 오기 / 설정</target>
        </trans-unit>
        <trans-unit id="accd886bc0d434d8e4eb3d97214b963815364bb7" translate="yes" xml:space="preserve">
          <source>attributes are as with the other over-* events.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8ad7c39fecdf32064de2e39ae851da53a46bc0b" translate="yes" xml:space="preserve">
          <source>attributes of &quot;item-number&quot; elements in a given &quot;over-number&quot; area</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c6a96d02eaab4e91ebed96db44f05d3adbda240" translate="yes" xml:space="preserve">
          <source>attributes), and an error message might be issued to the user.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c96eab257b4cf4e5e658df68be3609a71585745" translate="yes" xml:space="preserve">
          <source>attrname</source>
          <target state="translated">attrname</target>
        </trans-unit>
        <trans-unit id="609ae5d56623717e5f042c6463571bf7716a83b4" translate="yes" xml:space="preserve">
          <source>auth ( SASL )</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da389447cc56fe63760b8bfd30bef22a857ad05a" translate="yes" xml:space="preserve">
          <source>auth ( USERNAME, PASSWORD )</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44e865e1c1b3297ce69dcf97f5261cfbf03fa105" translate="yes" xml:space="preserve">
          <source>authinfo ( USER, PASS )</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16e2db9ebc7cdc40e2963dd1da8e03b1d661a4ac" translate="yes" xml:space="preserve">
          <source>authinfo_simple ( USER, PASS )</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f64cd8e32f5ac7553c150bd05d6f2252bb73f68d" translate="yes" xml:space="preserve">
          <source>author</source>
          <target state="translated">author</target>
        </trans-unit>
        <trans-unit id="6c1a67bf1e74785e2b7674a2f30a0cf297f56720" translate="yes" xml:space="preserve">
          <source>author_id, owner_id</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c35d48339ebb4e1e77c1d6c3dffa846d1b19b66" translate="yes" xml:space="preserve">
          <source>authorize ( [AUTH [, RESP]])</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90e3fd0f012c27834ea5ef3cf1dfef96e9190b40" translate="yes" xml:space="preserve">
          <source>authors</source>
          <target state="translated">authors</target>
        </trans-unit>
        <trans-unit id="480abf89fe2d1830b23e7098edc6d51d774d0c2a" translate="yes" xml:space="preserve">
          <source>authors/id/TOMC/scripts/nshist.gz</source>
          <target state="translated">authors/id/TOMC/scripts/nshist.gz</target>
        </trans-unit>
        <trans-unit id="c33fcb6996455fe1e1fa0a761ee443d59c481aa3" translate="yes" xml:space="preserve">
          <source>auto/</source>
          <target state="translated">auto/</target>
        </trans-unit>
        <trans-unit id="379a77c54f6ae1790a2244a0d2c048af4e634475" translate="yes" xml:space="preserve">
          <source>auto/$module/$module.bs</source>
          <target state="translated">auto/$module/$module.bs</target>
        </trans-unit>
        <trans-unit id="220e6841a8a7621c4a89ea7b80f1f146f73eaf9b" translate="yes" xml:space="preserve">
          <source>auto/DBD/Oracle/Oracle.a</source>
          <target state="translated">auto/DBD/Oracle/Oracle.a</target>
        </trans-unit>
        <trans-unit id="51ebf6d6fd8909a977306dd245925df9ee90fd5f" translate="yes" xml:space="preserve">
          <source>auto/Foo/*.mo</source>
          <target state="translated">auto/Foo/*.mo</target>
        </trans-unit>
        <trans-unit id="e694098f1cf7520142821fcc984e3d661c44f43f" translate="yes" xml:space="preserve">
          <source>auto/Foo/*.po</source>
          <target state="translated">auto/Foo/*.po</target>
        </trans-unit>
        <trans-unit id="3c5e43613cff090be4fc50d8ae5dd6d77a6b436a" translate="yes" xml:space="preserve">
          <source>auto/Socket/Socket.a</source>
          <target state="translated">auto/Socket/Socket.a</target>
        </trans-unit>
        <trans-unit id="2be06c1e85af3aeda93bd94fc5f8c8f0ca1a6fcf" translate="yes" xml:space="preserve">
          <source>auto/Socket/Socket.so</source>
          <target state="translated">auto/Socket/Socket.so</target>
        </trans-unit>
        <trans-unit id="0159b1c4926c7d3e58575705e2b2446e2f089413" translate="yes" xml:space="preserve">
          <source>auto/funcname.al</source>
          <target state="translated">auto/funcname.al</target>
        </trans-unit>
        <trans-unit id="61fff2e1a22690e6d5947e853162ef541dc4e471" translate="yes" xml:space="preserve">
          <source>auto_abbrev</source>
          <target state="translated">auto_abbrev</target>
        </trans-unit>
        <trans-unit id="2afbae650d151ea0265adb3f3c3d215c4897c2f6" translate="yes" xml:space="preserve">
          <source>auto_commit</source>
          <target state="translated">auto_commit</target>
        </trans-unit>
        <trans-unit id="402c024f88b71207c57d4f97b705333a6f774f23" translate="yes" xml:space="preserve">
          <source>auto_help (default:disabled)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06e471b91c6b9278c4206cdf40a0c4bd988e44fa" translate="yes" xml:space="preserve">
          <source>auto_version (default:disabled)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29dbf9fbbc1982eb3494d98a1ba20678ee1cd75a" translate="yes" xml:space="preserve">
          <source>autobundle</source>
          <target state="translated">autobundle</target>
        </trans-unit>
        <trans-unit id="d7fdb81095b8f0d754d3385c78ee0178778a27e1" translate="yes" xml:space="preserve">
          <source>autochomp</source>
          <target state="translated">autochomp</target>
        </trans-unit>
        <trans-unit id="a577d5867e3da0a70fe888d4e799c74e3bb3acee" translate="yes" xml:space="preserve">
          <source>autodie</source>
          <target state="translated">autodie</target>
        </trans-unit>
        <trans-unit id="3d06c1fb0d41b3bcd406473263f2d39a8385f847" translate="yes" xml:space="preserve">
          <source>autodie - Replace functions with ones that succeed or die with lexical scope</source>
          <target state="translated">autodie-함수를 어휘 범위로 성공하거나 죽는 것으로 대체</target>
        </trans-unit>
        <trans-unit id="a11d8629a6714617f42a511f4ed6cd917d35963b" translate="yes" xml:space="preserve">
          <source>autodie and string eval</source>
          <target state="translated">autodie와 string eval</target>
        </trans-unit>
        <trans-unit id="dc0d67b14cb1a5d70192f36381979b2f933bf9e3" translate="yes" xml:space="preserve">
          <source>autodie::Scope::Guard</source>
          <target state="translated">autodie::Scope::Guard</target>
        </trans-unit>
        <trans-unit id="c111b8358fe6c36d7e3a144ae44091f187d31532" translate="yes" xml:space="preserve">
          <source>autodie::Scope::Guard - Wrapper class for calling subs at end of scope</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a22f61d277dedcb9888724212ede885048f0106e" translate="yes" xml:space="preserve">
          <source>autodie::Scope::GuardStack</source>
          <target state="translated">autodie::Scope::GuardStack</target>
        </trans-unit>
        <trans-unit id="014cb28009b96ff9c04108e0c47c7a66680b1e80" translate="yes" xml:space="preserve">
          <source>autodie::Scope::GuardStack - Hook stack for managing scopes via %^H</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d8095a3005474796d1569dd550928d5b1089df68" translate="yes" xml:space="preserve">
          <source>autodie::Util</source>
          <target state="translated">autodie::Util</target>
        </trans-unit>
        <trans-unit id="92da7bd8499bb8812f4a6d9227502313585550d0" translate="yes" xml:space="preserve">
          <source>autodie::Util - Internal Utility subroutines for autodie and Fatal</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1a1d00617abf34e5c8765165fc1ca159f49c23e" translate="yes" xml:space="preserve">
          <source>autodie::exception</source>
          <target state="translated">autodie::exception</target>
        </trans-unit>
        <trans-unit id="f12923cae5ec41be8c4851646d2770147ec3da87" translate="yes" xml:space="preserve">
          <source>autodie::exception - Exceptions from autodying functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05d35bf27341634100e35a0c8ca835be04f2fed3" translate="yes" xml:space="preserve">
          <source>autodie::exception::system</source>
          <target state="translated">autodie::exception::system</target>
        </trans-unit>
        <trans-unit id="4840ea88280488a903534f4a0c898c6024d8a774" translate="yes" xml:space="preserve">
          <source>autodie::exception::system - Exceptions from autodying system().</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e24167ca9afa6c7f2b5a925033e7618b5d44476" translate="yes" xml:space="preserve">
          <source>autodie::hints</source>
          <target state="translated">autodie::hints</target>
        </trans-unit>
        <trans-unit id="ec9975be99761c25ec7219a6a4cc33b4e8e51342" translate="yes" xml:space="preserve">
          <source>autodie::hints - Provide hints about user subroutines to autodie</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7aea00cb8279f90b1ef25b7437493aee07c83547" translate="yes" xml:space="preserve">
          <source>autodie::skip</source>
          <target state="translated">autodie::skip</target>
        </trans-unit>
        <trans-unit id="846768212cb683ca0ccba14874187744a3f4877e" translate="yes" xml:space="preserve">
          <source>autodie::skip - Skip a package when throwing autodie exceptions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7554acb29f084d6cb46fbc0e7508ae57a54cbdfc" translate="yes" xml:space="preserve">
          <source>autoexec.bat</source>
          <target state="translated">autoexec.bat</target>
        </trans-unit>
        <trans-unit id="b2858151dc8dfe7daca5d572d920ca322993a122" translate="yes" xml:space="preserve">
          <source>autoflush</source>
          <target state="translated">autoflush</target>
        </trans-unit>
        <trans-unit id="668672fa7b7fd5fb3d195b4a6baca1536dd33f27" translate="yes" xml:space="preserve">
          <source>autogeneration</source>
          <target state="translated">autogeneration</target>
        </trans-unit>
        <trans-unit id="e50d5312673c20578fdc133952a68f0db7e850f2" translate="yes" xml:space="preserve">
          <source>autoincrement</source>
          <target state="translated">autoincrement</target>
        </trans-unit>
        <trans-unit id="4f25d09afc26355e099f60888cb6afb436cd27bf" translate="yes" xml:space="preserve">
          <source>autoload</source>
          <target state="translated">autoload</target>
        </trans-unit>
        <trans-unit id="05012112e2ffc3c215bad8795054b22b58e0e1a6" translate="yes" xml:space="preserve">
          <source>autoload PACKAGE, VERSION, AUTOLOADER</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e9af19367e37b3fd7b0448b5a6cf2432cce858e" translate="yes" xml:space="preserve">
          <source>autoload_remote</source>
          <target state="translated">autoload_remote</target>
        </trans-unit>
        <trans-unit id="64e3d9c664534c5dc480d648743bea7d2acbe343" translate="yes" xml:space="preserve">
          <source>automatically assigns distinct sequential IDs to things for which no ID was supplied by the caller. A default value expression may also refer to parameters earlier in the signature, making the default for one parameter vary according to the earlier parameters. For example,</source>
          <target state="translated">발신자가 ID를 제공하지 않은 항목에 고유 한 순차적 ID를 자동으로 할당합니다. 기본값 표현식은 서명의 앞부분에있는 매개 변수를 참조하여 한 매개 변수의 기본값이 이전 매개 변수에 따라 달라집니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="6b7d64e164b77abd5a26b00692b29b74ebe0531e" translate="yes" xml:space="preserve">
          <source>automatically searches to find the earliest stable version for which the test case passes. Run &lt;code&gt;Porting/bisect.pl --help&lt;/code&gt; for the full documentation, including how to set the &lt;code&gt;Configure&lt;/code&gt; and build time options.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57017ac4b77af63d6b742fe5c253a70fa799e907" translate="yes" xml:space="preserve">
          <source>autosplit</source>
          <target state="translated">autosplit</target>
        </trans-unit>
        <trans-unit id="76fc9ebd6695f30477da08fb8142ffeedfeb7837" translate="yes" xml:space="preserve">
          <source>autosplit.ix</source>
          <target state="translated">autosplit.ix</target>
        </trans-unit>
        <trans-unit id="a5d5b1a8b0a28fc771323790020196c5accafa43" translate="yes" xml:space="preserve">
          <source>autouse</source>
          <target state="translated">autouse</target>
        </trans-unit>
        <trans-unit id="442893c8365aac3e6f7baa2c6d61b464ed2881a4" translate="yes" xml:space="preserve">
          <source>autouse - postpone load of modules until a function is used</source>
          <target state="translated">자동 사용-함수가 사용될 때까지 모듈의로드를 연기</target>
        </trans-unit>
        <trans-unit id="5d4dfc227465e494c0c115736952236fb57eead0" translate="yes" xml:space="preserve">
          <source>autovivification</source>
          <target state="translated">autovivification</target>
        </trans-unit>
        <trans-unit id="5c4337373ca318929efba1f1977eed88f111a055" translate="yes" xml:space="preserve">
          <source>aux_list(cv)</source>
          <target state="translated">aux_list(cv)</target>
        </trans-unit>
        <trans-unit id="dd1180454c203de060904d192ac433fa587b6a84" translate="yes" xml:space="preserve">
          <source>auxiliary/GraphemeBreakTest.html</source>
          <target state="translated">auxiliary/GraphemeBreakTest.html</target>
        </trans-unit>
        <trans-unit id="a63105fc1df24429a2b75699b2ca788863d0a84f" translate="yes" xml:space="preserve">
          <source>auxiliary/LineBreakTest.html</source>
          <target state="translated">auxiliary/LineBreakTest.html</target>
        </trans-unit>
        <trans-unit id="e8249568a2c6df401c77089426c797a70a610f82" translate="yes" xml:space="preserve">
          <source>auxiliary/SentenceBreakTest.html</source>
          <target state="translated">auxiliary/SentenceBreakTest.html</target>
        </trans-unit>
        <trans-unit id="a679f7ff1afe202cb29dd1069cb2ddd9d2ac3913" translate="yes" xml:space="preserve">
          <source>auxiliary/WordBreakTest.html</source>
          <target state="translated">auxiliary/WordBreakTest.html</target>
        </trans-unit>
        <trans-unit id="7d4a1ec6821afa3e290c645e7f8553cda905013e" translate="yes" xml:space="preserve">
          <source>av.c</source>
          <target state="translated">av.c</target>
        </trans-unit>
        <trans-unit id="d52131125e175ad369ff2ead93d060398ec44bd0" translate="yes" xml:space="preserve">
          <source>av_arylen_p</source>
          <target state="translated">av_arylen_p</target>
        </trans-unit>
        <trans-unit id="7fa2741f7a8e3e39c280147cc62e4f272dc30365" translate="yes" xml:space="preserve">
          <source>av_clear</source>
          <target state="translated">av_clear</target>
        </trans-unit>
        <trans-unit id="91ebee21b0f25534f0b8be977b1952e47feba575" translate="yes" xml:space="preserve">
          <source>av_create_and_push</source>
          <target state="translated">av_create_and_push</target>
        </trans-unit>
        <trans-unit id="b9a9f5f7fb30c245f071d3558efeee9878de90a8" translate="yes" xml:space="preserve">
          <source>av_create_and_unshift_one</source>
          <target state="translated">av_create_and_unshift_one</target>
        </trans-unit>
        <trans-unit id="f6c772a926129049a482f5e5eef4c0cef92a6df6" translate="yes" xml:space="preserve">
          <source>av_delete</source>
          <target state="translated">av_delete</target>
        </trans-unit>
        <trans-unit id="e0584133cb5a99f3ff703f123f1add680d923205" translate="yes" xml:space="preserve">
          <source>av_exists</source>
          <target state="translated">av_exists</target>
        </trans-unit>
        <trans-unit id="8cf315bfc28e4183097603e398dd606fb75a92e9" translate="yes" xml:space="preserve">
          <source>av_extend</source>
          <target state="translated">av_extend</target>
        </trans-unit>
        <trans-unit id="969538e0cc4f2f8bb79fff826bf4ba6204f3b9dd" translate="yes" xml:space="preserve">
          <source>av_extend_guts</source>
          <target state="translated">av_extend_guts</target>
        </trans-unit>
        <trans-unit id="4dbf9ad55ba810e631a283196ca048461ab7a775" translate="yes" xml:space="preserve">
          <source>av_fetch</source>
          <target state="translated">av_fetch</target>
        </trans-unit>
        <trans-unit id="63f7efd66eb3e9cacf0aa524cdb984668dcfe333" translate="yes" xml:space="preserve">
          <source>av_fill</source>
          <target state="translated">av_fill</target>
        </trans-unit>
        <trans-unit id="9808d394bec6fa760f60a4a47552a2370986ac9f" translate="yes" xml:space="preserve">
          <source>av_iter_p</source>
          <target state="translated">av_iter_p</target>
        </trans-unit>
        <trans-unit id="4111003113ddea377a1489ef31ff8e6afa039d3c" translate="yes" xml:space="preserve">
          <source>av_len</source>
          <target state="translated">av_len</target>
        </trans-unit>
        <trans-unit id="26ce24376c0af018931b9119a9cce5adf11f62ea" translate="yes" xml:space="preserve">
          <source>av_make</source>
          <target state="translated">av_make</target>
        </trans-unit>
        <trans-unit id="25c316683bf8917039852f251e39ae37bf398585" translate="yes" xml:space="preserve">
          <source>av_nonelem</source>
          <target state="translated">av_nonelem</target>
        </trans-unit>
        <trans-unit id="8722570d82a9920bffbbe0567144037d4ec2f9d8" translate="yes" xml:space="preserve">
          <source>av_pop</source>
          <target state="translated">av_pop</target>
        </trans-unit>
        <trans-unit id="730c41c52a3553ffdb53a9e7fff18ca7913135a3" translate="yes" xml:space="preserve">
          <source>av_push</source>
          <target state="translated">av_push</target>
        </trans-unit>
        <trans-unit id="2846461d400536cd450d6312e4d9cbf65d4b03e6" translate="yes" xml:space="preserve">
          <source>av_reify</source>
          <target state="translated">av_reify</target>
        </trans-unit>
        <trans-unit id="e59b0439f03a55c2dc789113a756420b7049e68d" translate="yes" xml:space="preserve">
          <source>av_reify called on tied array</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56413731c6443156c657c5ae1d4340cc43ca1a06" translate="yes" xml:space="preserve">
          <source>av_shift</source>
          <target state="translated">av_shift</target>
        </trans-unit>
        <trans-unit id="27ae04d947c907457183f29701206cc62ef9995b" translate="yes" xml:space="preserve">
          <source>av_store</source>
          <target state="translated">av_store</target>
        </trans-unit>
        <trans-unit id="2d64aa2c54986ec3e7999adee68aa2b6b7163139" translate="yes" xml:space="preserve">
          <source>av_tindex</source>
          <target state="translated">av_tindex</target>
        </trans-unit>
        <trans-unit id="3b213e0d90972281e7460bf469452b71ae88764f" translate="yes" xml:space="preserve">
          <source>av_top_index</source>
          <target state="translated">av_top_index</target>
        </trans-unit>
        <trans-unit id="33660ab02957b829adfb6323d75865fff942b1c5" translate="yes" xml:space="preserve">
          <source>av_undef</source>
          <target state="translated">av_undef</target>
        </trans-unit>
        <trans-unit id="a016ac9d25a267e84346d117bb2283bba27198e1" translate="yes" xml:space="preserve">
          <source>av_unshift</source>
          <target state="translated">av_unshift</target>
        </trans-unit>
        <trans-unit id="bf2d347acf0d2210411dbd48fd0188278826a510" translate="yes" xml:space="preserve">
          <source>available when the &lt;code&gt;seq&lt;/code&gt; method is used along with the R_CURSOR flag.</source>
          <target state="translated">&lt;code&gt;seq&lt;/code&gt; 메소드가 R_CURSOR 플래그와 함께 사용될 때 사용 가능합니다 .</target>
        </trans-unit>
        <trans-unit id="5b2f5ffc6516e12ddb85b8802e4260a6688c946b" translate="yes" xml:space="preserve">
          <source>available. After the first argument, &lt;code&gt;skip(...)&lt;/code&gt; works exactly the same way as &lt;code&gt;ok(...)&lt;/code&gt; does.</source>
          <target state="translated">유효한. 첫 번째 인수 다음에 &lt;code&gt;skip(...)&lt;/code&gt; 은 &lt;code&gt;ok(...)&lt;/code&gt; 와 동일한 방식으로 작동합니다 .</target>
        </trans-unit>
        <trans-unit id="de42df957f23daa4c8157074e0625209abd6488c" translate="yes" xml:space="preserve">
          <source>avoids such a degradation.</source>
          <target state="translated">그러한 저하를 피하십시오.</target>
        </trans-unit>
        <trans-unit id="c027a379a046e31dfb0f6b178d42c47ae4aba491" translate="yes" xml:space="preserve">
          <source>awk</source>
          <target state="translated">awk</target>
        </trans-unit>
        <trans-unit id="e418c6a55a4fb786dadd646e1573be4fd2df9653" translate="yes" xml:space="preserve">
          <source>awk.exe</source>
          <target state="translated">awk.exe</target>
        </trans-unit>
        <trans-unit id="2a2e1206b4222b0d7cc8c8a1d8b302ee70cfe817" translate="yes" xml:space="preserve">
          <source>ax</source>
          <target state="translated">ax</target>
        </trans-unit>
        <trans-unit id="6431b8949d26ab22586e5fea24d5e1fcf2e09540" translate="yes" xml:space="preserve">
          <source>axes. Mathematicians call</source>
          <target state="translated">축. 수학자 호출</target>
        </trans-unit>
        <trans-unit id="69036a2af9bfb0d5daf1763137608136cb2401bd" translate="yes" xml:space="preserve">
          <source>axis, and therefore</source>
          <target state="translated">축, 따라서</target>
        </trans-unit>
        <trans-unit id="e8e340942e36c5463f6d6ae678f806cf14a11886" translate="yes" xml:space="preserve">
          <source>axis. There is a notation for this using the exponential form, which is:</source>
          <target state="translated">중심선. 지수 형식을 사용하는 표기법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="85f73bad0a71d5e81d44f69fff24051a84f9e8cb" translate="yes" xml:space="preserve">
          <source>azimuthal</source>
          <target state="translated">azimuthal</target>
        </trans-unit>
        <trans-unit id="e9d71f5ee7c92d6dc9e92ffdad17b8bd49418f98" translate="yes" xml:space="preserve">
          <source>b</source>
          <target state="translated">b</target>
        </trans-unit>
        <trans-unit id="ee6b9af78e9cb7153a0b28a0742ca016f08ad71e" translate="yes" xml:space="preserve">
          <source>b [file]:[line] [condition]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ecb059c093cdc1dc92b2bc475757c7bd89bdf41" translate="yes" xml:space="preserve">
          <source>b [line] [condition]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da6f45e7b385d86d257b1bc01dfc782704515b7a" translate="yes" xml:space="preserve">
          <source>b compile subname</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aee7e3509d80477e6df0cb068049e37cacb4b1e0" translate="yes" xml:space="preserve">
          <source>b load filename</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14e45e5debaaf05d7e21f8517c89076892bf016f" translate="yes" xml:space="preserve">
          <source>b postpone subname [condition]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b4a44721f42a033859f77ab894662cf40bbb0ae" translate="yes" xml:space="preserve">
          <source>b subname [condition]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fddfc6e1d7666d90904c5e3b0ac5d66177c016ab" translate="yes" xml:space="preserve">
          <source>b)</source>
          <target state="translated">b)</target>
        </trans-unit>
        <trans-unit id="be0f342011df36195c2bdef07802b43a541d7d4c" translate="yes" xml:space="preserve">
          <source>b) How do I verify that an email address targets a valid recipient?</source>
          <target state="translated">b) 이메일 주소가 유효한 수신자를 대상으로하는지 확인하려면 어떻게합니까?</target>
        </trans-unit>
        <trans-unit id="99d2d8800a736d7dfa39e0baf946a6c21c96cb07" translate="yes" xml:space="preserve">
          <source>babs()</source>
          <target state="translated">babs()</target>
        </trans-unit>
        <trans-unit id="051ab161b3f3d1c554e991fe37a1c08598100515" translate="yes" xml:space="preserve">
          <source>backermann()</source>
          <target state="translated">backermann()</target>
        </trans-unit>
        <trans-unit id="e24941468d7edb7b4b97099853ae8f500000e6d5" translate="yes" xml:space="preserve">
          <source>backlink</source>
          <target state="translated">backlink</target>
        </trans-unit>
        <trans-unit id="3652c1c0d07ea36c0f41d5a5bd1906547467aa7c" translate="yes" xml:space="preserve">
          <source>backreference</source>
          <target state="translated">backreference</target>
        </trans-unit>
        <trans-unit id="84eb39aaf0e1b7cca7c174974634139b97dd390f" translate="yes" xml:space="preserve">
          <source>backreferences</source>
          <target state="translated">backreferences</target>
        </trans-unit>
        <trans-unit id="7509930d058130604f3243eff8e57a63497eff72" translate="yes" xml:space="preserve">
          <source>backticks</source>
          <target state="translated">backticks</target>
        </trans-unit>
        <trans-unit id="d6666df3cfe0a87d82053354efeb1ef3f1df123d" translate="yes" xml:space="preserve">
          <source>backtracking</source>
          <target state="translated">backtracking</target>
        </trans-unit>
        <trans-unit id="57a1bc6fe9d759dc23556c9a5fb2238494baf0a8" translate="yes" xml:space="preserve">
          <source>backward compatibility</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1d90f6ed95de8b2f849cb8fba9cb0695ea047bb" translate="yes" xml:space="preserve">
          <source>backwards</source>
          <target state="translated">backwards</target>
        </trans-unit>
        <trans-unit id="782bc23d1c84370a515e713f6f4bed332d243305" translate="yes" xml:space="preserve">
          <source>bacmp()</source>
          <target state="translated">bacmp()</target>
        </trans-unit>
        <trans-unit id="023e7452be147f47fab20b687cbf88f849f3973e" translate="yes" xml:space="preserve">
          <source>bacmp()/bcmp()</source>
          <target state="translated">bacmp()/bcmp()</target>
        </trans-unit>
        <trans-unit id="a30e4fdfae25e2407e88209d32fa3206cbd57707" translate="yes" xml:space="preserve">
          <source>bad for IBM's programs, but the same compiler was used for DLLs which are used with general-purpose applications. When these DLLs are used, the state of floating-point flags in the application is not predictable.</source>
          <target state="translated">IBM 프로그램에는 좋지 않지만, 범용 응용 프로그램과 함께 사용되는 DLL에는 동일한 컴파일러가 사용되었습니다. 이러한 DLL을 사용하면 응용 프로그램의 부동 소수점 플래그 상태를 예측할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="7f9cb3f34cd025e1205c4645d1e6aca0d8597e5b" translate="yes" xml:space="preserve">
          <source>badd()</source>
          <target state="translated">badd()</target>
        </trans-unit>
        <trans-unit id="bcea895e1a3b428cb9ae8f8bb6a77c80b6d1735c" translate="yes" xml:space="preserve">
          <source>badd()/bmul()/bsub()/bdiv()/bdec()/binc()</source>
          <target state="translated">badd()/bmul()/bsub()/bdiv()/bdec()/binc()</target>
        </trans-unit>
        <trans-unit id="28776fc2f596476304f65e05ae24e174fbc20745" translate="yes" xml:space="preserve">
          <source>bailey@newman.upenn.edu</source>
          <target state="translated">bailey@newman.upenn.edu</target>
        </trans-unit>
        <trans-unit id="d5f9d5e53a7c7d23a33fb2e87ff767a4dee06322" translate="yes" xml:space="preserve">
          <source>bailout methods</source>
          <target state="translated">구제 방법</target>
        </trans-unit>
        <trans-unit id="9e70978d8dfbac0d3ca9324bca230eea2b943e47" translate="yes" xml:space="preserve">
          <source>band()</source>
          <target state="translated">band()</target>
        </trans-unit>
        <trans-unit id="48eb22d8e4ba1a46c166c176e4d110720e1ea85a" translate="yes" xml:space="preserve">
          <source>banner ()</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="62cdb7020ff920e5aa642c3d4066950dd1f01f4d" translate="yes" xml:space="preserve">
          <source>bar</source>
          <target state="translated">bar</target>
        </trans-unit>
        <trans-unit id="961b1cd40787e3f47e9dd503958e048866722a96" translate="yes" xml:space="preserve">
          <source>bar.dll</source>
          <target state="translated">bar.dll</target>
        </trans-unit>
        <trans-unit id="e474af74a0c30c226d54cc12d642a5c13df423f2" translate="yes" xml:space="preserve">
          <source>bareStringify</source>
          <target state="translated">bareStringify</target>
        </trans-unit>
        <trans-unit id="0727d0a9104ddffed608ae2a79fd31f918ad3dde" translate="yes" xml:space="preserve">
          <source>bareword</source>
          <target state="translated">bareword</target>
        </trans-unit>
        <trans-unit id="1405df66cbe219b0bf6355bc3d60361a8376b6b4" translate="yes" xml:space="preserve">
          <source>base</source>
          <target state="translated">base</target>
        </trans-unit>
        <trans-unit id="82364d6e500f9e7c6d2e135ddc4ef3ae5df9c250" translate="yes" xml:space="preserve">
          <source>base - Establish an ISA relationship with base classes at compile time</source>
          <target state="translated">base-컴파일 타임에 기본 클래스와 ISA 관계 설정</target>
        </trans-unit>
        <trans-unit id="d5b858bb629f56a1b3bf07eec9afeff8cb2176cd" translate="yes" xml:space="preserve">
          <source>base character</source>
          <target state="translated">기본 캐릭터</target>
        </trans-unit>
        <trans-unit id="94f0cf029e34b46f8956546c3ca831b45b7757bb" translate="yes" xml:space="preserve">
          <source>base class</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb170bf0a7f9325c8aa7a0a138128b8ec5471d88" translate="yes" xml:space="preserve">
          <source>base.pm was unable to require the base package, because it was not found in your path.</source>
          <target state="translated">base.pm은 경로에 기본 패키지가 없기 때문에 기본 패키지를 요구할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="8095e159699116466e36cbafd09e1d845f29f2b9" translate="yes" xml:space="preserve">
          <source>base64</source>
          <target state="translated">base64</target>
        </trans-unit>
        <trans-unit id="e9e99739293e7367ccad4549a440bbf99651181f" translate="yes" xml:space="preserve">
          <source>basename(1)</source>
          <target state="translated">basename(1)</target>
        </trans-unit>
        <trans-unit id="9a441af68f4177c8bcff94839c442392a522bb71" translate="yes" xml:space="preserve">
          <source>baserev.U</source>
          <target state="translated">baserev.U</target>
        </trans-unit>
        <trans-unit id="c8a16b493c487d9f0d43546b842106bf2ffa7152" translate="yes" xml:space="preserve">
          <source>bash</source>
          <target state="translated">bash</target>
        </trans-unit>
        <trans-unit id="1da8eaa4a0d77769d77e901c7a8bd51a90b2108b" translate="yes" xml:space="preserve">
          <source>bash.btm</source>
          <target state="translated">bash.btm</target>
        </trans-unit>
        <trans-unit id="d7113141808e2d9571e4d8981caf323c56b50b9c" translate="yes" xml:space="preserve">
          <source>bash.exe</source>
          <target state="translated">bash.exe</target>
        </trans-unit>
        <trans-unit id="e25ac03f477736cf429678bb164c6ba39a46224c" translate="yes" xml:space="preserve">
          <source>basic block profiling</source>
          <target state="translated">기본 블록 프로파일 링</target>
        </trans-unit>
        <trans-unit id="bb86a2ae262d9c015cbc4346cbdae479e321322e" translate="yes" xml:space="preserve">
          <source>basic blocks</source>
          <target state="translated">기본 블록</target>
        </trans-unit>
        <trans-unit id="ce252839c8120fb5bca1f5ab1ecf317e2b8c1ad2" translate="yes" xml:space="preserve">
          <source>basic-block counting</source>
          <target state="translated">기본 블록 카운팅</target>
        </trans-unit>
        <trans-unit id="c09a78352f016692dcd8dd798d66441c80a78605" translate="yes" xml:space="preserve">
          <source>basic_text</source>
          <target state="translated">basic_text</target>
        </trans-unit>
        <trans-unit id="20dfaec48307e3cf13210a9ec0c330efc261304c" translate="yes" xml:space="preserve">
          <source>basically means this: look in the lexicon for $lang (which may inherit from any number of other lexicons), and find the function that we happen to associate with the string &quot;You have [quant,_1,piece] of new mail&quot; (which is, and should be, a functioning &quot;shorthand&quot; for this function in the native locale -- English in this case). If you find such a function, call it with $lang as its first parameter (as if it were a method), and then a copy of scalar(@messages) as its second, and then return that value. If that function was found, but was in string shorthand instead of being a fully specified function, parse it and make it into a function before calling it the first time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a78ae04842f1950e62670dd82c3cf7ad1b73b83e" translate="yes" xml:space="preserve">
          <source>batan()</source>
          <target state="translated">batan()</target>
        </trans-unit>
        <trans-unit id="6dbadea73d392ffaeb4be2ca32f3c9398f6e1e4f" translate="yes" xml:space="preserve">
          <source>batan2()</source>
          <target state="translated">batan2()</target>
        </trans-unit>
        <trans-unit id="504ee22084024022630f49c8572bc2a333f11490" translate="yes" xml:space="preserve">
          <source>batch_mode_page_object_init</source>
          <target state="translated">batch_mode_page_object_init</target>
        </trans-unit>
        <trans-unit id="75736a80f50247c7c9141706465352089a086efa" translate="yes" xml:space="preserve">
          <source>baz&quot;, and, going the other way, the optional parsing of groups of words joined by NBSP's as if each group were in a S&amp;lt;...&amp;gt; code, so that formatters may use the representation that maps best to what the output format demands.</source>
          <target state="translated">다른 방법으로, 각 그룹이 S &amp;lt;...&amp;gt; 코드에있는 것처럼 NBSP에 의해 결합 된 단어 그룹의 선택적 구문 분석은 포맷터가 출력 형식에 가장 적합한 맵핑을 사용할 수 있도록합니다. 요구합니다.</target>
        </trans-unit>
        <trans-unit id="541a5c612e022e7f06af776324ec7f5dbef7f667" translate="yes" xml:space="preserve">
          <source>bcc ( ADDRESS [, ADDRESS [...]] )</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89a83e99befe035db29117627cce4ee77338bd35" translate="yes" xml:space="preserve">
          <source>bceil()</source>
          <target state="translated">bceil()</target>
        </trans-unit>
        <trans-unit id="b6356d193cf6cf6c6164f0a61510cd2ff7bff517" translate="yes" xml:space="preserve">
          <source>bcmp()</source>
          <target state="translated">bcmp()</target>
        </trans-unit>
        <trans-unit id="71dfbd8ffe00a83c45102653482b2f06269a2017" translate="yes" xml:space="preserve">
          <source>bcos()</source>
          <target state="translated">bcos()</target>
        </trans-unit>
        <trans-unit id="a1ec6c7cd47b7ce21fb70948a7fe12d8f2de5652" translate="yes" xml:space="preserve">
          <source>bdat ( DATA )</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a43134b84c77c603d44bc9cb7a34ee28d61dda9b" translate="yes" xml:space="preserve">
          <source>bdatlast ( DATA )</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9dbb8d63710387f33e47eeed58434edbf43436e9" translate="yes" xml:space="preserve">
          <source>bdec()</source>
          <target state="translated">bdec()</target>
        </trans-unit>
        <trans-unit id="ebdf243fd741fd942cda9ff4274731be01ae03c1" translate="yes" xml:space="preserve">
          <source>bdfac()</source>
          <target state="translated">bdfac()</target>
        </trans-unit>
        <trans-unit id="baa52f89b3e557bf1b35ea846ac5228309ee68c4" translate="yes" xml:space="preserve">
          <source>bdigitsum()</source>
          <target state="translated">bdigitsum()</target>
        </trans-unit>
        <trans-unit id="8267458ce43cf249a67491d1d8861cd3d92a0e9d" translate="yes" xml:space="preserve">
          <source>bdiv()</source>
          <target state="translated">bdiv()</target>
        </trans-unit>
        <trans-unit id="0e538c18c393c21f3d8f35fb560355f4920bacf0" translate="yes" xml:space="preserve">
          <source>bdstr()</source>
          <target state="translated">bdstr()</target>
        </trans-unit>
        <trans-unit id="986b1bc1eb8de89643c50722910f99001c232865" translate="yes" xml:space="preserve">
          <source>be</source>
          <target state="translated">be</target>
        </trans-unit>
        <trans-unit id="36048f5f57efa9c9c207392cd7127b119b057243" translate="yes" xml:space="preserve">
          <source>be a bareword. The importation can be made conditional by using the &lt;a href=&quot;../if&quot;&gt;if&lt;/a&gt; module.</source>
          <target state="translated">말 그대로 &lt;a href=&quot;../if&quot;&gt;if&lt;/a&gt; 모듈 을 사용하여 가져 오기를 조건부로 만들 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e70616934e98e6243ad338b17e6d1d1a80ef47cd" translate="yes" xml:space="preserve">
          <source>be a bareword. The importation can be made conditional by using the &lt;a href=&quot;if&quot;&gt;if&lt;/a&gt; module.</source>
          <target state="translated">말 그대로 &lt;a href=&quot;if&quot;&gt;if&lt;/a&gt; 모듈 을 사용하여 가져 오기를 조건부로 만들 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6174cfdb1b6f1f01bc8c27356965cea1660ff655" translate="yes" xml:space="preserve">
          <source>be a string of octal digits: &lt;code&gt;0644&lt;/code&gt; is okay, but &lt;code&gt;&quot;0644&quot;&lt;/code&gt; is not. Returns the number of files successfully changed. See also &lt;a href=&quot;#oct&quot;&gt;oct&lt;/a&gt; if all you have is a string.</source>
          <target state="translated">8 진수 문자열이어야합니다. &lt;code&gt;0644&lt;/code&gt; 는 괜찮지 만 &lt;code&gt;&quot;0644&quot;&lt;/code&gt; 는 아닙니다. 성공적으로 변경된 파일 수를 반환합니다. 모든 것이 문자열이면 &lt;a href=&quot;#oct&quot;&gt;oct&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="cd4eacb457b1014a65c358074fe11c5634af92b0" translate="yes" xml:space="preserve">
          <source>be a string of octal digits: &lt;code&gt;0644&lt;/code&gt; is okay, but &lt;code&gt;&quot;0644&quot;&lt;/code&gt; is not. Returns the number of files successfully changed. See also &lt;a href=&quot;#oct-EXPR&quot;&gt;&lt;code&gt;oct&lt;/code&gt;&lt;/a&gt; if all you have is a string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="956f149445457ad325f5a84a0c7c25a363bcc21c" translate="yes" xml:space="preserve">
          <source>be a string of octal digits: &lt;code&gt;0644&lt;/code&gt; is okay, but &lt;code&gt;&quot;0644&quot;&lt;/code&gt; is not. Returns the number of files successfully changed. See also &lt;a href=&quot;oct&quot;&gt;oct&lt;/a&gt; if all you have is a string.</source>
          <target state="translated">8 진수 문자열이어야합니다. &lt;code&gt;0644&lt;/code&gt; 는 괜찮지 만 &lt;code&gt;&quot;0644&quot;&lt;/code&gt; 는 아닙니다. 성공적으로 변경된 파일 수를 반환합니다. 모든 것이 문자열이면 &lt;a href=&quot;oct&quot;&gt;oct&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="2f14746af9c291f92399b053f1e619f9de693adc" translate="yes" xml:space="preserve">
          <source>be a valid Perl package name and it</source>
          <target state="translated">유효한 Perl 패키지 이름이어야합니다.</target>
        </trans-unit>
        <trans-unit id="8bab9adc00fd7e4a64089f6b0ae5c963c3f36a5a" translate="yes" xml:space="preserve">
          <source>be able to tolerate layers compiled against an old version of the headers.</source>
          <target state="translated">이전 버전의 헤더에 대해 컴파일 된 레이어를 허용 할 수 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="14982941f96f6d84c8cd50b24f899b4c1845a614" translate="yes" xml:space="preserve">
          <source>be able to write:</source>
          <target state="translated">쓸 수있다 :</target>
        </trans-unit>
        <trans-unit id="34c1cc772dd68663334c7cc5a51270a9c162743c" translate="yes" xml:space="preserve">
          <source>be addressed by adding a</source>
          <target state="translated">추가하여 해결</target>
        </trans-unit>
        <trans-unit id="8800830eb2a63e7e498e064d670f9a27a029e1f7" translate="yes" xml:space="preserve">
          <source>be applied, even though strings like &lt;code&gt;&quot;01&quot;&lt;/code&gt; would normally look like a number to Perl.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="28396307a68e2c8ee56bd6b269f6e59ccaf41b7a" translate="yes" xml:space="preserve">
          <source>be assigned back to &lt;code&gt;$(&lt;/code&gt; without being forced numeric, such as by adding zero. Note that this is different to the effective gid (&lt;code&gt;$)&lt;/code&gt; ) which does take a list.</source>
          <target state="translated">0을 추가하는 등 강제 숫자없이 &lt;code&gt;$(&lt;/code&gt; 다시 할당 됩니다. 이는 목록을 취하는 유효 gid ( &lt;code&gt;$)&lt;/code&gt; 와 다릅니다 .</target>
        </trans-unit>
        <trans-unit id="0d9df9cfcca5cdea95acaf69cb6098179f7a4b09" translate="yes" xml:space="preserve">
          <source>be assigned back to &lt;code&gt;$(&lt;/code&gt; without being forced numeric, such as by adding zero. Note that this is different to the effective gid (&lt;code&gt;$)&lt;/code&gt;) which does take a list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="93202847d0c4f58d96ed2de441c5bae895f03f9f" translate="yes" xml:space="preserve">
          <source>be be treated as nested tags within the tagged text (even if they would match the start tag pattern).</source>
          <target state="translated">태그가 지정된 텍스트 내에 시작 태그 패턴과 일치하더라도 중첩 된 태그로 취급됩니다.</target>
        </trans-unit>
        <trans-unit id="3e275fd29837765cf3bc71fd6ce6d4f40b0be22d" translate="yes" xml:space="preserve">
          <source>be called exactly once, typically in a BOOT: section. If you are maintaining multiple interpreters, it should be called once in each interpreter instance, except for interpreters cloned from existing ones. (But see &lt;a href=&quot;#MY_CXT_CLONE&quot;&gt;&quot;MY_CXT_CLONE&quot;&lt;/a&gt; below.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1cd6e63a2e61c9b680434df73ca1618e7d52128" translate="yes" xml:space="preserve">
          <source>be called exactly once, typically in a BOOT: section. If you are maintaining multiple interpreters, it should be called once in each interpreter instance, except for interpreters cloned from existing ones. (But see &lt;a href=&quot;#MY_CXT_CLONE&quot;&gt;MY_CXT_CLONE&lt;/a&gt; below.)</source>
          <target state="translated">일반적으로 BOOT : 섹션에서 정확히 한 번 호출됩니다. 여러 개의 인터프리터를 유지 보수하는 경우 기존 인터프리터에서 복제 된 인터프리터를 제외하고 각 인터프리터 인스턴스에서 한 번씩 호출해야합니다. (하지만 아래 &lt;a href=&quot;#MY_CXT_CLONE&quot;&gt;MY_CXT_CLONE을&lt;/a&gt; 참조하십시오 .)</target>
        </trans-unit>
        <trans-unit id="9d2edd7898262b515a39df03229b24d227d1c626" translate="yes" xml:space="preserve">
          <source>be called explicitly.</source>
          <target state="translated">명시 적으로 불러야합니다.</target>
        </trans-unit>
        <trans-unit id="438a35efe202395aa4bfcea78aeb25f89d7ddb6d" translate="yes" xml:space="preserve">
          <source>be closed by calling &lt;code&gt;PerlIO_close()&lt;/code&gt; on the returned PerlIO *.</source>
          <target state="translated">반환 된 PerlIO *에서 &lt;code&gt;PerlIO_close()&lt;/code&gt; 를 호출하여 닫힙니다 .</target>
        </trans-unit>
        <trans-unit id="9934090830c2424ca6cc4ecf9b012220e6cb8ade" translate="yes" xml:space="preserve">
          <source>be closed until both the tied variable is untied and all copies of the saved object are destroyed.</source>
          <target state="translated">묶인 변수가 묶이지 않고 저장된 객체의 모든 복사본이 파괴 될 때까지 닫힙니다.</target>
        </trans-unit>
        <trans-unit id="c3e7ca4e78e0952264ac139095f7bf1f632db6fe" translate="yes" xml:space="preserve">
          <source>be consistent with each other (implementation may only use one or the other or may require both).</source>
          <target state="translated">서로 일치해야합니다 (구현은 하나만 사용하거나 둘 다 필요할 수 있음).</target>
        </trans-unit>
        <trans-unit id="bdfc850e994531d0f620111ecf403220532f49bb" translate="yes" xml:space="preserve">
          <source>be declared</source>
          <target state="translated">선언되다</target>
        </trans-unit>
        <trans-unit id="4bc6d0c7f9935408fb2bc64464a3d82819a4723d" translate="yes" xml:space="preserve">
          <source>be expanded as specified by the &lt;b&gt;-expand_seq&lt;/b&gt; option; Any such recursive expansion needs to be handled by the specified callback routine.]</source>
          <target state="translated">&lt;b&gt;-expand_seq&lt;/b&gt; 옵션 으로 지정된대로 확장하십시오 . 이러한 재귀 확장은 지정된 콜백 루틴에 의해 처리되어야합니다.]</target>
        </trans-unit>
        <trans-unit id="fb00294fdc4c477751afeb60eec17519d313dd85" translate="yes" xml:space="preserve">
          <source>be faster in certain circumstances for large files, and may result in less physical memory use when multiple processes are reading the same file.</source>
          <target state="translated">큰 파일의 경우 특정 환경에서 더 빠르며 여러 프로세스가 동일한 파일을 읽을 때 실제 메모리 사용이 줄어들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="89547cfa26f8957d4689489ae8e6da3bfe190445" translate="yes" xml:space="preserve">
          <source>be globrefs).</source>
          <target state="translated">globrefs이어야 함).</target>
        </trans-unit>
        <trans-unit id="aed67ceeb07b3aad12dfc70fda375fa903262c1b" translate="yes" xml:space="preserve">
          <source>be globrefs. Objects of &lt;code&gt;NamedFile&lt;/code&gt; should behave like a file opened for reading and also support the &lt;code&gt;name()&lt;/code&gt; method. This class juncture works with exception of the &lt;code&gt;Name_hash&lt;/code&gt; implementation, where object initialization fails because of the incompatibility of object bodies.</source>
          <target state="translated">globrefs입니다. &lt;code&gt;NamedFile&lt;/code&gt; 의 객체는 읽기 위해 열린 파일처럼 동작해야하며 &lt;code&gt;name()&lt;/code&gt; 메서드 도 지원해야합니다 . 이 클래스 &lt;code&gt;Name_hash&lt;/code&gt; 은 Name_hash 구현 을 제외하고 작동 하는데 , 여기서 오브젝트 본문의 비 호환성으로 인해 오브젝트 초기화에 실패합니다.</target>
        </trans-unit>
        <trans-unit id="96a908fc7385d1425e0ba694653b67ebf458eb65" translate="yes" xml:space="preserve">
          <source>be in effect.)</source>
          <target state="translated">효력이있다.)</target>
        </trans-unit>
        <trans-unit id="93fdaed10217b38690a5394ba6f117f7442dc2d0" translate="yes" xml:space="preserve">
          <source>be interpreted as simply &quot;codepoint</source>
          <target state="translated">단순히 &quot;코드 포인트&quot;로 해석됩니다</target>
        </trans-unit>
        <trans-unit id="3b8bb41a2a75cf63cb4e4b8dd89b36e596750288" translate="yes" xml:space="preserve">
          <source>be introduced with &lt;code&gt;--&lt;/code&gt; and bundles with &lt;code&gt;-&lt;/code&gt; .</source>
          <target state="translated">함께 소개 &lt;code&gt;--&lt;/code&gt; 와 함께 번들 &lt;code&gt;-&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cb60746a5d3bb1528e0214db460749edff43d872" translate="yes" xml:space="preserve">
          <source>be introduced with &lt;code&gt;--&lt;/code&gt; and bundles with &lt;code&gt;-&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42a1854f29dd88d78bf67b5c84417d21fb1c6102" translate="yes" xml:space="preserve">
          <source>be invoked.</source>
          <target state="translated">호출됩니다.</target>
        </trans-unit>
        <trans-unit id="7ffefc4005f2d8b9f6232ebeb883bef6adb2c998" translate="yes" xml:space="preserve">
          <source>be likely that code (possibly in Perl, as with Lingua::EN::Inflect, for English nouns) has already been written for the language in question, whether simple or complex.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b400f46c67266a74a7941beb8d8f3aa492d507c" translate="yes" xml:space="preserve">
          <source>be made read-only (by the caller), or at least should be treated as such.</source>
          <target state="translated">(발신자에 의해) 읽기 전용이되거나 최소한 그렇게 취급되어야합니다.</target>
        </trans-unit>
        <trans-unit id="2dfe41932637990aabde1fd9ab5b36a0129cdcb1" translate="yes" xml:space="preserve">
          <source>be of the format integer-dot-digit-digit, i.e. &lt;code&gt;25.57&lt;/code&gt;, optionally followed by underscore-digit-digit, i.e. &lt;code&gt;25.57_04&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22754b5f05d41004d65864397d8f7961e944c9f1" translate="yes" xml:space="preserve">
          <source>be only ASCII characters, and</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8aca838b806998e1c3a7660775bb22707c53a139" translate="yes" xml:space="preserve">
          <source>be open any more when the program is reincarnated, with possible resulting confusion by Perl.</source>
          <target state="translated">프로그램이 재연 될 때 더 이상 열리지 않으면 Perl에 의해 혼동 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4942a835a218847da1bc9474d15e7f7fecee9472" translate="yes" xml:space="preserve">
          <source>be parsed as two paragraphs in italics (with the I code starting in one paragraph and starting in another.) Instead, the first paragraph should generate a warning, but that aside, the above code must parse as if it were:</source>
          <target state="translated">기울임 꼴로 두 단락으로 구문 분석됩니다 (I 코드는 한 단락에서 시작하여 다른 단락에서 시작 함). 대신 첫 번째 단락은 경고를 생성해야하지만, 위 코드는 다음과 같이 구문 분석해야합니다.</target>
        </trans-unit>
        <trans-unit id="cac76875da8caea6da506441e4a3013ef795de69" translate="yes" xml:space="preserve">
          <source>be preceded with a blank line; &lt;code&gt;__END__&lt;/code&gt; is</source>
          <target state="translated">빈 줄이 앞에옵니다. &lt;code&gt;__END__&lt;/code&gt; 는</target>
        </trans-unit>
        <trans-unit id="56f17a9fa2003de9ef3c254fb72eb38377857e77" translate="yes" xml:space="preserve">
          <source>be present during testing.</source>
          <target state="translated">테스트 중에 나타납니다.</target>
        </trans-unit>
        <trans-unit id="5889addd1ea93bd05efcb1682728a15053a4b875" translate="yes" xml:space="preserve">
          <source>be provided by the end-user of &lt;code&gt;autodie&lt;/code&gt;, they are ideally written into the module itself, or into a helper module or sub-class of &lt;code&gt;autodie&lt;/code&gt; itself.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac6789e5ce6bb8c48ccfee0a53b55ecb18497192" translate="yes" xml:space="preserve">
          <source>be provided.</source>
          <target state="translated">제공된.</target>
        </trans-unit>
        <trans-unit id="8e7ed5c5b2648d3fb47f0ce1afb127706a1279f2" translate="yes" xml:space="preserve">
          <source>be restored.</source>
          <target state="translated">회복된다.</target>
        </trans-unit>
        <trans-unit id="c9bf9ad1188aa77634cd3b8aff0b84c5c12ad44c" translate="yes" xml:space="preserve">
          <source>be stopped by debugger, although &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt;s and INIT blocks will, and compile-time statements can be traced with the &lt;code&gt;AutoTrace&lt;/code&gt; option set in &lt;code&gt;PERLDB_OPTS&lt;/code&gt; ). From your own Perl code, however, you can transfer control back to the debugger using the following statement, which is harmless if the debugger is not running:</source>
          <target state="translated">s 및 INIT 블록이 &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; 하지만 디버거에 의해 중지되고 &lt;code&gt;PERLDB_OPTS&lt;/code&gt; 에 설정된 &lt;code&gt;AutoTrace&lt;/code&gt; 옵션을 사용하여 컴파일 타임 문을 추적 할 수 있습니다 . 그러나 자체 Perl 코드에서 다음 명령문을 사용하여 제어를 디버거로 다시 전송할 수 있습니다. 디버거가 실행되고 있지 않으면 무해합니다.</target>
        </trans-unit>
        <trans-unit id="b332da483597b431d4ebaf91c49d1c6eadbd8328" translate="yes" xml:space="preserve">
          <source>be stopped by debugger, although &lt;code&gt;require&lt;/code&gt;s and INIT blocks will, and compile-time statements can be traced with the &lt;code&gt;AutoTrace&lt;/code&gt; option set in &lt;code&gt;PERLDB_OPTS&lt;/code&gt;). From your own Perl code, however, you can transfer control back to the debugger using the following statement, which is harmless if the debugger is not running:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="400bf125e188b6776f7244947b865d3a2497a3b3" translate="yes" xml:space="preserve">
          <source>be stored as a single data paragraph (consisting of &quot;&amp;lt;img src='wirth_spokesmodeling_book.png'&amp;gt;\n\n&amp;lt;hr&amp;gt;\n&quot;).</source>
          <target state="translated">단일 데이터 단락으로 저장됩니다 ( &quot;&amp;lt;img src = 'wirth_spokesmodeling_book.png'&amp;gt; \ n \ n &amp;lt;hr&amp;gt; \ n&quot;으로 구성).</target>
        </trans-unit>
        <trans-unit id="16137519316b812afb2da09aa91b112ba92bff67" translate="yes" xml:space="preserve">
          <source>be stored as two data paragraphs (one consisting of &quot;&amp;lt;img src='wirth_spokesmodeling_book.png'&amp;gt;\n&quot; and another consisting of &quot;&amp;lt;hr&amp;gt;\n&quot;), but</source>
          <target state="translated">두 개의 데이터 단락 (하나는 &quot;&amp;lt;img src = 'wirth_spokesmodeling_book.png'&amp;gt; \ n&quot;으로 구성되고 다른 하나는 &quot;&amp;lt;hr&amp;gt; \ n&quot;으로 구성)으로 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="619ff8abea4d5f3ccd22e0c825463c6f2e928d79" translate="yes" xml:space="preserve">
          <source>be sure to invoke &lt;code&gt;$self-&amp;gt;SUPER::initialize()&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;$self-&amp;gt;SUPER::initialize()&lt;/code&gt; 를 호출하십시오 .</target>
        </trans-unit>
        <trans-unit id="b3127d5be257498591fa1b1e632079190d24627c" translate="yes" xml:space="preserve">
          <source>be sure to invoke the &lt;b&gt;initialize()&lt;/b&gt; method of the newly blessed object.</source>
          <target state="translated">새로 축복받은 객체 의 &lt;b&gt;initialize ()&lt;/b&gt; 메소드 를 호출하십시오 .</target>
        </trans-unit>
        <trans-unit id="6bd6f3dc5720d53f6325adeb9c38189554e2d06f" translate="yes" xml:space="preserve">
          <source>be the desired effect within a diamond hierarchy, but in others (e.g. for destructors) it may be more appropriate to call each method only once during a sequence of redispatches.</source>
          <target state="translated">다이아몬드 계층 구조 내에서 원하는 효과이지만, 다른 것 (예 : 소멸자)에서는 일련의 재발송 동안 각 메소드를 한 번만 호출하는 것이 더 적절할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f32b0724100efc9f3b38df25932dbc397348687a" translate="yes" xml:space="preserve">
          <source>be thrown if</source>
          <target state="translated">만약에 던져지면</target>
        </trans-unit>
        <trans-unit id="d996815a3551001f2437592e2dfe9cf2917da354" translate="yes" xml:space="preserve">
          <source>be treated as an error:</source>
          <target state="translated">오류로 취급됩니다 :</target>
        </trans-unit>
        <trans-unit id="5cfeeb86f388b90e9358708fb9a2cf2d92ff6a4c" translate="yes" xml:space="preserve">
          <source>be treated as an option, but passed to the program unharmed, in &lt;code&gt;@ARGV&lt;/code&gt; .</source>
          <target state="translated">옵션으로 취급되지만 &lt;code&gt;@ARGV&lt;/code&gt; 에서 무사히 프로그램에 전달됩니다 .</target>
        </trans-unit>
        <trans-unit id="3b05bc4410ad4d361cd1bc4b1aa6a2048076769c" translate="yes" xml:space="preserve">
          <source>be treated as an option, but passed to the program unharmed, in &lt;code&gt;@ARGV&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="213ce7c8d8fef7b5daff184033ed3b8b66ff7b3a" translate="yes" xml:space="preserve">
          <source>be undone (but not &lt;code&gt;&lt;a href=&quot;functions/pop&quot;&gt;pop&lt;/a&gt; @_&lt;/code&gt; or other splicing,</source>
          <target state="translated">취소 (그러나이 될 &lt;code&gt;&lt;a href=&quot;functions/pop&quot;&gt;pop&lt;/a&gt; @_&lt;/code&gt; 또는 다른 접합을,</target>
        </trans-unit>
        <trans-unit id="8002f964e7f54fd6c9a88e0e37e9510ff919095b" translate="yes" xml:space="preserve">
          <source>be undone (but not &lt;code&gt;&lt;a href=&quot;pop&quot;&gt;pop&lt;/a&gt; @_&lt;/code&gt; or other splicing,</source>
          <target state="translated">취소 (그러나이 될 &lt;code&gt;&lt;a href=&quot;pop&quot;&gt;pop&lt;/a&gt; @_&lt;/code&gt; 또는 다른 접합을,</target>
        </trans-unit>
        <trans-unit id="ab7c83905ae1d6a2e4d715e600c65628380b7d4b" translate="yes" xml:space="preserve">
          <source>be undone (but not &lt;code&gt;pop @_&lt;/code&gt; or other splicing,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17bd5dc5ae122c31aab12373873620d67a1c4b2d" translate="yes" xml:space="preserve">
          <source>be used for method calls. You can't use it for regular subroutine calls or class methods:</source>
          <target state="translated">메소드 호출에 사용됩니다. 일반 서브 루틴 호출 또는 클래스 메소드에는 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="4e471a2c455269486f9776c668e9c672d74418df" translate="yes" xml:space="preserve">
          <source>be used in interpolating strings (double quotes or the &lt;code&gt;&lt;a href=&quot;functions/qq&quot;&gt;qq&lt;/a&gt;&lt;/code&gt; operator), but only if the additional &lt;code&gt;postderef_qq&lt;/code&gt; feature is enabled.</source>
          <target state="translated">추가 &lt;code&gt;postderef_qq&lt;/code&gt; 기능이 활성화 된 경우에만 문자열 보간 (큰 따옴표 또는 &lt;code&gt;&lt;a href=&quot;functions/qq&quot;&gt;qq&lt;/a&gt;&lt;/code&gt; 연산자)에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="37c19bda8dda58aa4daba4c9519e4dc020b7a3f4" translate="yes" xml:space="preserve">
          <source>be used in interpolating strings (double quotes or the &lt;code&gt;&lt;a href=&quot;functions/qq&quot;&gt;qq&lt;/a&gt;&lt;/code&gt; operator), but only if the additional &lt;code&gt;postderef_qq&lt;/code&gt;&lt;a href=&quot;feature&quot;&gt;feature&lt;/a&gt; is enabled.</source>
          <target state="translated">추가 &lt;code&gt;postderef_qq&lt;/code&gt; &lt;a href=&quot;feature&quot;&gt;기능&lt;/a&gt; 이 활성화 된 경우에만 문자열 보간 (큰 따옴표 또는 &lt;code&gt;&lt;a href=&quot;functions/qq&quot;&gt;qq&lt;/a&gt;&lt;/code&gt; 연산자)에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="7d51185a9b3b31ade2b15536b4991747238d8a88" translate="yes" xml:space="preserve">
          <source>be used in interpolating strings (double quotes or the &lt;code&gt;qq&lt;/code&gt; operator), but only if the &lt;code&gt;postderef_qq&lt;/code&gt; feature is enabled.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="036092155ce8a9ff5d3badd8d0f0778afad82e9e" translate="yes" xml:space="preserve">
          <source>be used in interpolating strings (double quotes or the &lt;code&gt;qq&lt;/code&gt; operator), but only if the &lt;code&gt;postderef_qq&lt;/code&gt;&lt;a href=&quot;feature&quot;&gt;feature&lt;/a&gt; is enabled.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9eccf910fdd37c2a3bcdbac9f3427f38c70da9c0" translate="yes" xml:space="preserve">
          <source>bearing</source>
          <target state="translated">bearing</target>
        </trans-unit>
        <trans-unit id="1407501dd659df6fb3cfafb420938ddd4792bbdd" translate="yes" xml:space="preserve">
          <source>because it can match zero copies of &lt;code&gt;'X'&lt;/code&gt; at the beginning of the string. If you definitely want to match at least one &lt;code&gt;'X'&lt;/code&gt; , use &lt;code&gt;X+&lt;/code&gt; , not &lt;code&gt;X*&lt;/code&gt; .</source>
          <target state="translated">문자열의 시작 부분에 &lt;code&gt;'X'&lt;/code&gt; 의 복사본이 0과 일치 할 수 있기 때문 입니다. 적어도 하나의 &lt;code&gt;'X'&lt;/code&gt; 를 정확히 일치 시키려면 &lt;code&gt;X*&lt;/code&gt; 아니라 X &lt;code&gt;X+&lt;/code&gt; 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="a8504f4a94208d96382c46286dd2940ff2c6906b" translate="yes" xml:space="preserve">
          <source>because it can match zero copies of &lt;code&gt;'X'&lt;/code&gt; at the beginning of the string. If you definitely want to match at least one &lt;code&gt;'X'&lt;/code&gt;, use &lt;code&gt;X+&lt;/code&gt;, not &lt;code&gt;X*&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed626eff2ded4ff54496b1cd4f2b0a1c7d5ccbb9" translate="yes" xml:space="preserve">
          <source>because it is much faster - it reduces internal variables into the modulus whenever possible, so it operates on smaller numbers.</source>
          <target state="translated">훨씬 빠르기 때문에 가능할 때마다 내부 변수를 모듈러스로 줄이므로 더 적은 수로 작동합니다.</target>
        </trans-unit>
        <trans-unit id="c9ac39be8f080b55461591140c43654051426f56" translate="yes" xml:space="preserve">
          <source>because it was listed as a TODO test on the plan line. However, we are not aware of anyone actually using this feature and hard-coding test numbers is discouraged because it's very easy to add a test and break the test number sequence. This makes test suites very fragile. Instead, the following should be used:</source>
          <target state="translated">계획 라인에서 TODO 테스트로 나열 되었기 때문입니다. 그러나 실제로이 기능을 사용하는 사람은 없으며 테스트를 쉽게 추가하고 테스트 번호 시퀀스를 중단하기 때문에 하드 코딩 테스트 번호는 사용하지 않는 것이 좋습니다. 이것은 테스트 스위트를 매우 취약하게 만듭니다. 대신 다음을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="3716b55181b7d4ce5a8064066cc2010c3e1b6360" translate="yes" xml:space="preserve">
          <source>because of the strict regularization of Perl 5's grammar into unary and list operators. (The old open was a little of both.) You must put parentheses around the filehandle, or use the new &quot;or&quot; operator instead of &quot;||&quot;.</source>
          <target state="translated">Perl 5의 문법을 단항 및리스트 연산자로 엄격하게 정규화했기 때문입니다. (오래된 오픈은 둘 다 조금이었다.) 파일 핸들을 괄호로 묶거나 &quot;||&quot;대신 새 &quot;or&quot;연산자를 사용해야한다.</target>
        </trans-unit>
        <trans-unit id="71ee90a49bf1ab4bd322eb175c4eef72341f4bf3" translate="yes" xml:space="preserve">
          <source>because otherwise &lt;b&gt;xsubpp&lt;/b&gt; will believe that you made a duplicate definition of the function. Also, put a blank line before the #else/#endif so it will not be seen as part of the function body.</source>
          <target state="translated">그렇지 않으면 &lt;b&gt;xsubpp&lt;/b&gt; 는 함수를 중복 정의했다고 믿기 때문 입니다. 또한 # else / # endif 앞에 빈 줄을 넣어 함수 본문의 일부로 표시되지 않도록합니다.</target>
        </trans-unit>
        <trans-unit id="c57dfba8d90c3ee87942986e029f65c0a62033af" translate="yes" xml:space="preserve">
          <source>because the &quot;less than&quot; operator is interpreted as a closing delimiter.</source>
          <target state="translated">&quot;보다 작음&quot;연산자는 닫는 구분 기호로 해석되기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="91d068e640ed02bcfffdad4e89ae0a9db41b7044" translate="yes" xml:space="preserve">
          <source>because the embedded pairs of &lt;code&gt;'(..)'&lt;/code&gt; s and &lt;code&gt;'[..]'&lt;/code&gt; s are &quot;cross-nested&quot; and the embedded &lt;code&gt;'&amp;gt;'&lt;/code&gt; is unbalanced. (In a scalar context, this call would return an empty string. In a void context, &lt;code&gt;$text&lt;/code&gt; would be unchanged.)</source>
          <target state="translated">&lt;code&gt;'(..)'&lt;/code&gt; 및 &lt;code&gt;'[..]'&lt;/code&gt; 의 포함 된 쌍 은 &quot;교차&quot;되고 포함 된 &lt;code&gt;'&amp;gt;'&lt;/code&gt; 은 불균형하기 때문입니다. 스칼라 컨텍스트에서이 호출은 빈 문자열을 반환합니다. 빈 컨텍스트에서는 &lt;code&gt;$text&lt;/code&gt; 가 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2d05959105bc45a525dae5509143b16c5ce91fed" translate="yes" xml:space="preserve">
          <source>because the embedded pairs of &lt;code&gt;'(..)'&lt;/code&gt;s and &lt;code&gt;'[..]'&lt;/code&gt;s are &quot;cross-nested&quot; and the embedded &lt;code&gt;'&amp;gt;'&lt;/code&gt; is unbalanced. (In a scalar context, this call would return an empty string. In a void context, &lt;code&gt;$text&lt;/code&gt; would be unchanged.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="331252ee302b6da2035026aca3ba4ae99c1a4ea1" translate="yes" xml:space="preserve">
          <source>because the latter will alternate between returning a filename and returning false.</source>
          <target state="translated">후자는 파일 이름 반환과 false 반환 사이를 번갈아 표시하기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="f2ef9563189019bf8c9ac0f31b94f7d982047b5c" translate="yes" xml:space="preserve">
          <source>because the main point isn't whether the user typed &lt;b&gt;-v&lt;/b&gt; or not.</source>
          <target state="translated">요점은 사용자가 &lt;b&gt;-v를&lt;/b&gt; 입력했는지 여부가 아니기 때문 입니다.</target>
        </trans-unit>
        <trans-unit id="95dd904c935d8d74a8bd1af96d4e502e980aaabd" translate="yes" xml:space="preserve">
          <source>because the notion of &quot;compile-time&quot; is relative. Instead, you want:</source>
          <target state="translated">&quot;컴파일 타임&quot;이라는 개념이 상대적이기 때문입니다. 대신, 당신은 원합니다 :</target>
        </trans-unit>
        <trans-unit id="6a35b87feefdc6c196b1d4d33ac852a059f8f67f" translate="yes" xml:space="preserve">
          <source>because the second way hides the main point of the statement in a modifier. On the other hand</source>
          <target state="translated">두 번째 방법은 수정 자의 명령문의 주요 지점을 숨기므로 반면에</target>
        </trans-unit>
        <trans-unit id="b15c6a463c6e853f47c1bd82bf87355ef292954f" translate="yes" xml:space="preserve">
          <source>because they test functionality which</source>
          <target state="translated">그들은 기능을 테스트하기 때문에</target>
        </trans-unit>
        <trans-unit id="a73476a17fae6e74c5ac465bb722d65dca737d30" translate="yes" xml:space="preserve">
          <source>because you don't have to start a process on every filename found (but it's not faster than using the &lt;b&gt;-delete&lt;/b&gt; switch available in newer versions of</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c89a78424c4f276725f3f2424f018f5fc3348fbb" translate="yes" xml:space="preserve">
          <source>because you don't have to start a process on every filename found. It does suffer from the bug of mishandling newlines in pathnames, which you can fix if you follow the example under &lt;b&gt;-0&lt;/b&gt;.</source>
          <target state="translated">발견 된 모든 파일 이름에 대해 프로세스를 시작할 필요가 없기 때문입니다. 경로 이름에서 줄 바꿈을 잘못 처리하는 버그로 어려움을 겪습니다 . &lt;b&gt;-0&lt;/b&gt; 아래의 예제를 따르면 수정 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a217c7a44aead49b3247ffc0322e6ace486aeba7" translate="yes" xml:space="preserve">
          <source>because you'll get just references listed, and perl will never automatically dereference things for you. Instead, you have to roll yourself a loop or two. This prints the whole structure, using the shell-style for() construct to loop across the outer set of subscripts.</source>
          <target state="translated">왜냐하면 당신은 단지 참조를 열거 할 것이고, perl은 자동으로 당신을 대신 할 것입니다. 대신에, 당신은 자신에게 루프를 굴려야합니다. 이것은 쉘 구조의 for () 구문을 사용하여 전체 구조를 인쇄하여 외부 첨자 집합을 반복합니다.</target>
        </trans-unit>
        <trans-unit id="d53e9fb5cd89e4ca476b10b3690128590c751e12" translate="yes" xml:space="preserve">
          <source>become cumbersome when you need to inflect more than a few dozen words; and other solutions (like using algorithms to model the inflections, storing only root forms and irregularities)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e58ac78738f8185ee5c7c2c3d83aca0198db529" translate="yes" xml:space="preserve">
          <source>becomes</source>
          <target state="translated">becomes</target>
        </trans-unit>
        <trans-unit id="e0d2345f9f72fcdda8f445997826d44505e55aef" translate="yes" xml:space="preserve">
          <source>been in use as an Internet language tag, and RFC 3066 stipulates that it never should be, since a shorter tag (&quot;ar&quot;) exists.</source>
          <target state="translated">인터넷 언어 태그로 사용되고 있으며 RFC 3066은 더 짧은 태그 ( &quot;ar&quot;)가 있기 때문에 절대로 사용해서는 안된다고 규정합니다.</target>
        </trans-unit>
        <trans-unit id="51de2b835bd35a67eb32dbcd3d77d4b96e5aa39d" translate="yes" xml:space="preserve">
          <source>before</source>
          <target state="translated">before</target>
        </trans-unit>
        <trans-unit id="915c701ba2639a5081cecf4fc5bdf5de5ad69a85" translate="yes" xml:space="preserve">
          <source>before calling</source>
          <target state="translated">전화하기 전에</target>
        </trans-unit>
        <trans-unit id="0cbf8d2dc3ebc2ee1d97d9f37a08ec8f737756c3" translate="yes" xml:space="preserve">
          <source>before running your wide record pipe program. A larger value may improve performance at the expense of the BYTLM UAF quota.</source>
          <target state="translated">와이드 레코드 파이프 프로그램을 실행하기 전에. 값이 클수록 BYTLM UAF 할당량을 희생하여 성능이 향상 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0e5cdbaa0673f848d1b7128b629138e86739c8b2" translate="yes" xml:space="preserve">
          <source>before the &lt;code&gt;perl.h&lt;/code&gt;&lt;code&gt;#include&lt;/code&gt;. You can replace your &lt;code&gt;langinfo.h&lt;/code&gt;&lt;code&gt;#include&lt;/code&gt; with this one. (Doing it this way keeps out the symbols that plain &lt;code&gt;langinfo.h&lt;/code&gt; would try to import into the namespace for code that doesn't need it.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9dfe8489641883d87825274b161f0adcb018192e" translate="yes" xml:space="preserve">
          <source>before unpacking the archive.</source>
          <target state="translated">보관을 풀기 전에</target>
        </trans-unit>
        <trans-unit id="e00d3375a237dc6b36e090011f01e09a680f730b" translate="yes" xml:space="preserve">
          <source>begin with a colon, should not directly contain &quot;=head1&quot; ... &quot;=head4&quot; commands, nor &quot;=over&quot;, nor &quot;=back&quot;, nor &quot;=item&quot;. For example, this may be considered invalid:</source>
          <target state="translated">콜론으로 시작하고 &quot;= head1&quot;... &quot;= head4&quot;명령이나 &quot;= over&quot;, &quot;= back&quot;또는 &quot;= item&quot;을 직접 포함해서는 안됩니다. 예를 들어, 이것은 유효하지 않은 것으로 간주 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="35ee011e96122a1b4404f72436530569c798f3bc" translate="yes" xml:space="preserve">
          <source>begin with a colon, then &quot;text...&quot; will constitute a data paragraph. There is no way to use &quot;=for formatname text...&quot; to express &quot;text...&quot; as a verbatim paragraph.</source>
          <target state="translated">콜론으로 시작하면 &quot;text ...&quot;는 데이터 단락을 구성합니다. &quot;= formatname text ...&quot;를 사용하여 &quot;text ...&quot;를 축약 형 단락으로 표현하는 방법은 없습니다.</target>
        </trans-unit>
        <trans-unit id="a054a301f7e242f3320212ad3120381b20ffa4b5" translate="yes" xml:space="preserve">
          <source>begin with a colon, then non-command paragraphs are ordinary paragraphs or data paragraphs. This is discussed in detail in the section &lt;a href=&quot;#About-Data-Paragraphs-and-%22%3Dbegin%2F%3Dend%22-Regions&quot;&gt;&quot;About Data Paragraphs and &quot;=begin/=end&quot; Regions&quot;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01012d8e1a5ae715258cadbaf70262cad1cf8ef2" translate="yes" xml:space="preserve">
          <source>begin with a colon, then non-command paragraphs are ordinary paragraphs or data paragraphs. This is discussed in detail in the section &lt;a href=&quot;#About-Data-Paragraphs-and-%22%3dbegin%2f%3dend%22-Regions&quot;&gt;About Data Paragraphs and =begin/=end Regions&lt;/a&gt;.</source>
          <target state="translated">콜론으로 시작하면 명령이 아닌 단락은 일반 단락 또는 데이터 단락입니다. 이에 대해서는 &lt;a href=&quot;#About-Data-Paragraphs-and-%22%3dbegin%2f%3dend%22-Regions&quot;&gt;데이터 단락 및 = begin / = 종료 정보&lt;/a&gt; 섹션에서 자세히 설명 합니다 .</target>
        </trans-unit>
        <trans-unit id="43e8c372c4b8551232015b4964270e14bc96c611" translate="yes" xml:space="preserve">
          <source>begin with a colon.</source>
          <target state="translated">콜론으로 시작하십시오.</target>
        </trans-unit>
        <trans-unit id="f96514769306205e5e54b126ee406aa18da22231" translate="yes" xml:space="preserve">
          <source>begin with a literal colon (&quot;:&quot;). In some sense, a data paragraph is not part of Pod at all (i.e., effectively it's &quot;out-of-band&quot;), since it's not subject to most kinds of Pod parsing; but it is specified here, since Pod parsers need to be able to call an event for it, or store it in some form in a parse tree, or at least just parse</source>
          <target state="translated">리터럴 콜론 ( &quot;:&quot;)으로 시작하십시오. 어떤 의미에서, 데이터 단락은 대부분 포드의 일부가 아닙니다 (즉, 사실상 &quot;대역 외&quot;). 이는 대부분의 포드 파싱에 영향을받지 않기 때문입니다. 포드 파서는 이벤트를 호출하거나 파싱 트리에 어떤 형태로 저장하거나 최소한 파싱해야하기 때문에 여기에 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="1be9db5ec4d328a8c30fb304c0fe21d95b9feaf9" translate="yes" xml:space="preserve">
          <source>begin_av</source>
          <target state="translated">begin_av</target>
        </trans-unit>
        <trans-unit id="e2e281b54db81b16a35418fcd87978434eb58caf" translate="yes" xml:space="preserve">
          <source>begins with a colon,</source>
          <target state="translated">콜론으로 시작하고</target>
        </trans-unit>
        <trans-unit id="31a7e9902319755c10b8cad42a0fff59ce9d4052" translate="yes" xml:space="preserve">
          <source>behave like the bunzip2 program. It will only uncompress the first bunzip2 data stream in the file, as shown below</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97e34e04cce3092a3fbc1368e2721a7094461fac" translate="yes" xml:space="preserve">
          <source>behave like the gunzip program. It will only uncompress the first gzip data stream in the file, as shown below</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c831dd4349f7440d63aa005aa956edcf6570200" translate="yes" xml:space="preserve">
          <source>behaves approximately like</source>
          <target state="translated">대략적으로 행동</target>
        </trans-unit>
        <trans-unit id="49aa6a42431a52e8d5358eaf47e17fc9c0afb35d" translate="yes" xml:space="preserve">
          <source>behaves just like &lt;a href=&quot;#-e-commandline&quot;&gt;-e&lt;/a&gt;, except that it implicitly enables all optional features (in the main compilation unit). See &lt;a href=&quot;feature&quot;&gt;feature&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="878cb14881bc8cc40ffa36c11bd520865655b641" translate="yes" xml:space="preserve">
          <source>behaves just like &lt;b&gt;-e&lt;/b&gt;, except that it implicitly enables all optional features (in the main compilation unit). See &lt;a href=&quot;feature&quot;&gt;feature&lt;/a&gt;.</source>
          <target state="translated">기본 컴파일 단위에서 모든 선택적 기능을 암시 적으로 활성화한다는 점을 제외하고는 &lt;b&gt;-e&lt;/b&gt; 와 동일하게 작동 합니다. &lt;a href=&quot;feature&quot;&gt;기능을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="29c4a5cf676b2e6b5aac47ac451d31e3961499c9" translate="yes" xml:space="preserve">
          <source>behavior for a thread after it has been created. With a</source>
          <target state="translated">스레드가 작성된 후의 동작. 와</target>
        </trans-unit>
        <trans-unit id="ab7103d633748a477ad2572ee63045defbe35f36" translate="yes" xml:space="preserve">
          <source>behavior, for some inputs.) In 5.7, the quicksort implementation was replaced with a stable mergesort algorithm whose worst-case behavior is O(NlogN). But benchmarks indicated that for some inputs, on some platforms, the original quicksort was faster. 5.8 has a sort pragma for limited control of the sort. Its rather blunt control of the underlying algorithm may not persist into future Perls, but the ability to characterize the input or output in implementation independent ways quite probably will. See &lt;a href=&quot;../sort&quot;&gt;the sort pragma&lt;/a&gt;.</source>
          <target state="translated">5.7에서 quicksort 구현은 최악의 동작이 O (NlogN) 인 안정적인 병합 정렬 알고리즘으로 대체되었습니다. 그러나 벤치 마크에 따르면 일부 입력의 경우 일부 플랫폼에서 원래의 퀵 정렬이 더 빠르다. 5.8에는 정렬 제어를 제한하는 정렬 프라그 마가 있습니다. 근본적인 알고리즘에 대한 다소 둔한 제어는 미래의 Perls에서는 지속되지 않지만 구현 또는 독립적 인 방식으로 입력 또는 출력을 특성화하는 기능은 아마도 그럴 것입니다. &lt;a href=&quot;../sort&quot;&gt;pragma 정렬을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="7662c3889bf0376550fc93aa4448d4df9574c86b" translate="yes" xml:space="preserve">
          <source>behavior, for some inputs.) In 5.7, the quicksort implementation was replaced with a stable mergesort algorithm whose worst-case behavior is O(NlogN). But benchmarks indicated that for some inputs, on some platforms, the original quicksort was faster. 5.8 has a sort pragma for limited control of the sort. Its rather blunt control of the underlying algorithm may not persist into future Perls, but the ability to characterize the input or output in implementation independent ways quite probably will. See &lt;a href=&quot;sort&quot;&gt;the sort pragma&lt;/a&gt;.</source>
          <target state="translated">5.7에서 quicksort 구현은 최악의 동작이 O (NlogN) 인 안정적인 병합 정렬 알고리즘으로 대체되었습니다. 그러나 벤치 마크에 따르면 일부 입력의 경우 일부 플랫폼에서 원래의 퀵 정렬이 더 빠르다. 5.8에는 정렬 제어를 제한하는 정렬 프라그 마가 있습니다. 근본적인 알고리즘에 대한 다소 둔한 제어는 미래의 Perls에서는 지속되지 않지만 구현 또는 독립적 인 방식으로 입력 또는 출력을 특성화하는 기능은 아마도 그럴 것입니다. &lt;a href=&quot;sort&quot;&gt;pragma 정렬을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a4d45707cf30bc986faddb8a61f21a6e9cdaf80e" translate="yes" xml:space="preserve">
          <source>behaviour is different from the outer public API. The logic is that the &quot;unchecked&quot; case is useful when the encoding is part of a stream which may be reporting errors (e.g. STDERR). In such cases, it is desirable to get everything through somehow without causing additional errors which obscure the original one. Also, the encoding is best placed to know what the correct replacement character is, so if that is the desired behaviour then letting low level code do it is the most efficient.</source>
          <target state="translated">동작은 외부 공용 API와 다릅니다. 논리는 &quot;확인되지 않은&quot;경우가 인코딩이 오류를보고 할 수있는 스트림 (예 : STDERR)의 일부인 경우에 유용하다는 것입니다. 이러한 경우 원래 오류를 가릴 수있는 추가 오류를 발생시키지 않으면 서 모든 것을 얻는 것이 바람직합니다. 또한 올바른 대체 문자가 무엇인지 알기 위해 인코딩을 사용하는 것이 가장 좋습니다. 따라서 원하는 동작 인 경우 저수준 코드를 사용하는 것이 가장 효율적입니다.</target>
        </trans-unit>
        <trans-unit id="d665cbacbfa3c977993d51ac9f39d4889ffea309" translate="yes" xml:space="preserve">
          <source>behaviour. One can start</source>
          <target state="translated">행동. 하나는 시작할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="c4ad9e56b49ef76a7e8fcbc4f0e989ac69868fc0" translate="yes" xml:space="preserve">
          <source>behind its back; calling &lt;a href=&quot;#sync_locale&quot;&gt;sync_locale&lt;/a&gt; before calling this macro will update perl's records.)</source>
          <target state="translated">그 뒤에; 전화 &lt;a href=&quot;#sync_locale&quot;&gt;sync_locale을&lt;/a&gt; 펄의 기록을 업데이트합니다이 매크로를 호출하기 전에.)</target>
        </trans-unit>
        <trans-unit id="a55f3cbc5e20d676e8b6e31c3e6b1864eecba17a" translate="yes" xml:space="preserve">
          <source>being a subset of Unicode), while ASCII is.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53f8e0ff86be0a313b2007cbdd020a9b83a37fba" translate="yes" xml:space="preserve">
          <source>being data being sent to the server. Calls &lt;code&gt;debug_text&lt;/code&gt; before printing to STDERR.</source>
          <target state="translated">서버로 전송되는 데이터 STDERR로 인쇄하기 전에 &lt;code&gt;debug_text&lt;/code&gt; 를 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="70842494fd493a8f8803b71e1e93717e5ff8d7e2" translate="yes" xml:space="preserve">
          <source>being executed within the distribution file's working directory.</source>
          <target state="translated">배포 파일의 작업 디렉토리 내에서 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="c6309e2149391dbe0d16560dc35ff7f7d071ea27" translate="yes" xml:space="preserve">
          <source>being more accurate than C</source>
          <target state="translated">C보다 정확한 것</target>
        </trans-unit>
        <trans-unit id="ae7d864b083311cd426e7717f8e3a7be973f886e" translate="yes" xml:space="preserve">
          <source>being unfilled. In a threading situation,</source>
          <target state="translated">채워지지 않은. 스레딩 상황에서</target>
        </trans-unit>
        <trans-unit id="d4300189fdbe1cb5fe64ef0a483b7086eb450712" translate="yes" xml:space="preserve">
          <source>belongs to (used in &lt;code&gt;\p{Blk=...}&lt;/code&gt; ). The &lt;a href=&quot;#prop_value_aliases()&quot;&gt;prop_value_aliases()&lt;/a&gt; function can be used to get all the synonyms of the block name.</source>
          <target state="translated">( &lt;code&gt;\p{Blk=...}&lt;/code&gt; 사용)에 속합니다 . &lt;a href=&quot;#prop_value_aliases()&quot;&gt;prop_value_aliases ()&lt;/a&gt; 함수는 블록 이름의 모든 동의어를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="13c61da538d4ab019c7b05230a8f76ece1cba556" translate="yes" xml:space="preserve">
          <source>belongs to (used in &lt;code&gt;\p{Blk=...}&lt;/code&gt;). The &lt;a href=&quot;#prop_value_aliases%28%29&quot;&gt;&quot;prop_value_aliases()&quot;&lt;/a&gt; function can be used to get all the synonyms of the block name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78bdb1660a37a979308c6b38c35ed13226f4b481" translate="yes" xml:space="preserve">
          <source>belongs to. The &lt;a href=&quot;#prop_value_aliases%28%29&quot;&gt;&quot;prop_value_aliases()&quot;&lt;/a&gt; function can be used to get all the synonyms of the script name. Note that this is the older &quot;Script&quot; property value, and not the improved &quot;Script_Extensions&quot; value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a2fdbc23a85b8e4584cd5c7c6fb3ac1138bda7bd" translate="yes" xml:space="preserve">
          <source>belongs to. The &lt;a href=&quot;#prop_value_aliases()&quot;&gt;prop_value_aliases()&lt;/a&gt; function can be used to get all the synonyms of the script name.</source>
          <target state="translated">에 속한다. &lt;a href=&quot;#prop_value_aliases()&quot;&gt;prop_value_aliases ()&lt;/a&gt; 함수는 스크립트 이름의 모든 동의어를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="489c7fc8339f7c44efa172c21d3dbf41ad08c7e4" translate="yes" xml:space="preserve">
          <source>below</source>
          <target state="translated">below</target>
        </trans-unit>
        <trans-unit id="21b17c5ba622c38ebd7690a2824aa2f55d5b8a0f" translate="yes" xml:space="preserve">
          <source>below). The containing directory can be specified in &lt;code&gt;CPAN.pm&lt;/code&gt; in the &lt;code&gt;prefs_dir&lt;/code&gt; config variable. Try &lt;code&gt;o conf init
prefs_dir&lt;/code&gt; in the CPAN shell to set and activate the distroprefs system.</source>
          <target state="translated">이하). 포함 디렉토리는 &lt;code&gt;CPAN.pm&lt;/code&gt; 의 &lt;code&gt;prefs_dir&lt;/code&gt; 구성 변수 에서 지정할 수 있습니다 . 시험 &lt;code&gt;o conf init prefs_dir&lt;/code&gt; CPAN 쉘에서 conf init prefs_dir 을 하여 distroprefs 시스템을 설정하고 활성화하십시오.</target>
        </trans-unit>
        <trans-unit id="6ee65b4d48e2ac02540ecb32d3b43d908326681d" translate="yes" xml:space="preserve">
          <source>bench.pl</source>
          <target state="translated">bench.pl</target>
        </trans-unit>
        <trans-unit id="664ac432b4954d19c059a37e90f2549775ecb9d7" translate="yes" xml:space="preserve">
          <source>beq()</source>
          <target state="translated">beq()</target>
        </trans-unit>
        <trans-unit id="c5f5e4d75252d9788ce20300d00023fa1ccd4d19" translate="yes" xml:space="preserve">
          <source>best</source>
          <target state="translated">best</target>
        </trans-unit>
        <trans-unit id="a2db5af4b95c649c7f23f26e2d00914f22ca9241" translate="yes" xml:space="preserve">
          <source>best effort</source>
          <target state="translated">최고의 노력</target>
        </trans-unit>
        <trans-unit id="b8c1680ea7ea37db7233bc599faf01f592c8e529" translate="yes" xml:space="preserve">
          <source>bestr()</source>
          <target state="translated">bestr()</target>
        </trans-unit>
        <trans-unit id="709634051471385aada32356842983beeff4b065" translate="yes" xml:space="preserve">
          <source>between</source>
          <target state="translated">between</target>
        </trans-unit>
        <trans-unit id="857088f224d60f19170606b3f8e3e1d22d832425" translate="yes" xml:space="preserve">
          <source>between 0 and 255. These represent foreground and background colors, respectively, with the RGB values given by the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ff6cf52c304b7ca8d264e3830a9bb468d96fb99" translate="yes" xml:space="preserve">
          <source>between configuring and making steps.)</source>
          <target state="translated">구성 단계와 단계 사이에.)</target>
        </trans-unit>
        <trans-unit id="95b5da10cca6e837a526a6e638dc826063502032" translate="yes" xml:space="preserve">
          <source>bexp()</source>
          <target state="translated">bexp()</target>
        </trans-unit>
        <trans-unit id="d52f22fd878ee3706d7dd2feba05080b099127cc" translate="yes" xml:space="preserve">
          <source>bfac()</source>
          <target state="translated">bfac()</target>
        </trans-unit>
        <trans-unit id="f44d1f883a5070e98ee064df00c1a4df49e12190" translate="yes" xml:space="preserve">
          <source>bfib()</source>
          <target state="translated">bfib()</target>
        </trans-unit>
        <trans-unit id="7bbd3be39df70eda29db2e96251dc8a4c05ce7be" translate="yes" xml:space="preserve">
          <source>bfloor()</source>
          <target state="translated">bfloor()</target>
        </trans-unit>
        <trans-unit id="fae42f3e3aa55692f5e6f467a143b214b340ebc3" translate="yes" xml:space="preserve">
          <source>bfround ( +$scale )</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa75af0a26160b4c5285118a8300d1ffd1b896f0" translate="yes" xml:space="preserve">
          <source>bfround ( -$scale )</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a2b06e277ed5dd89cbb607d4e3cf03f44272f5f" translate="yes" xml:space="preserve">
          <source>bfround ( 0 )</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca23cd8cfb8590a5ac92910f20d66852f3bd4b84" translate="yes" xml:space="preserve">
          <source>bfround()</source>
          <target state="translated">bfround()</target>
        </trans-unit>
        <trans-unit id="dde1c58eeab957538292732d8b3578b0bbf195e1" translate="yes" xml:space="preserve">
          <source>bgcd()</source>
          <target state="translated">bgcd()</target>
        </trans-unit>
        <trans-unit id="2ddbbe441d748cbe42b9723164dbf9871d5c38df" translate="yes" xml:space="preserve">
          <source>bge()</source>
          <target state="translated">bge()</target>
        </trans-unit>
        <trans-unit id="8f2041749d677881debaab37d70b6c36707b39f5" translate="yes" xml:space="preserve">
          <source>bgt()</source>
          <target state="translated">bgt()</target>
        </trans-unit>
        <trans-unit id="e815c411019f3fe8a6e07303ec9c01ca20856c91" translate="yes" xml:space="preserve">
          <source>bidi_types()</source>
          <target state="translated">bidi_types()</target>
        </trans-unit>
        <trans-unit id="0eb26de54355ba1e1f99e33725a9d024cfd6b807" translate="yes" xml:space="preserve">
          <source>bidirectional type of</source>
          <target state="translated">양방향 유형</target>
        </trans-unit>
        <trans-unit id="38e4f23119f7668c81c56c877acdc10f397299d2" translate="yes" xml:space="preserve">
          <source>big-endian</source>
          <target state="translated">big-endian</target>
        </trans-unit>
        <trans-unit id="5f9c9d32d71f1ef8b8014c350a5f8aec50c577ec" translate="yes" xml:space="preserve">
          <source>bigint</source>
          <target state="translated">bigint</target>
        </trans-unit>
        <trans-unit id="83123b65dc13ec2d11ceae1c1cec211e7cef1cb6" translate="yes" xml:space="preserve">
          <source>bigint - Transparent BigInteger support for Perl</source>
          <target state="translated">bigint-Perl에 대한 투명한 BigInteger 지원</target>
        </trans-unit>
        <trans-unit id="dc0c0c0aa0c98c99641fd608b1168be57143c887" translate="yes" xml:space="preserve">
          <source>bigint recognizes some options that can be passed while loading it via use. The options can (currently) be either a single letter form, or the long form. The following options exist:</source>
          <target state="translated">bigint는 사용을 통해로드하는 동안 전달할 수있는 일부 옵션을 인식합니다. 옵션은 (현재) 단일 문자 형식이거나 긴 형식 일 수 있습니다. 다음과 같은 옵션이 있습니다.</target>
        </trans-unit>
        <trans-unit id="2c5ed18936a55186b9ba8eb22ac87953629628d3" translate="yes" xml:space="preserve">
          <source>bignum</source>
          <target state="translated">bignum</target>
        </trans-unit>
        <trans-unit id="ebef2dfbf356b1d6376d0a89d5a3dc3812dc7025" translate="yes" xml:space="preserve">
          <source>bignum - Transparent BigNumber support for Perl</source>
          <target state="translated">bignum-Perl에 대한 투명한 BigNumber 지원</target>
        </trans-unit>
        <trans-unit id="cfc363199f35898d0c10e170520f53e8601bb52d" translate="yes" xml:space="preserve">
          <source>bignum recognizes some options that can be passed while loading it via use. The options can (currently) be either a single letter form, or the long form. The following options exist:</source>
          <target state="translated">bignum은 사용을 통해로드하는 동안 전달할 수있는 일부 옵션을 인식합니다. 옵션은 (현재) 단일 문자 형식이거나 긴 형식 일 수 있습니다. 다음과 같은 옵션이 있습니다.</target>
        </trans-unit>
        <trans-unit id="59cfee0f6bb73ee64a7b9dbb363c27ea0eb9f302" translate="yes" xml:space="preserve">
          <source>bigrat</source>
          <target state="translated">bigrat</target>
        </trans-unit>
        <trans-unit id="dbf25a54f2fd0d3932bef731375b0ba1d051ef77" translate="yes" xml:space="preserve">
          <source>bigrat - Transparent BigNumber/BigRational support for Perl</source>
          <target state="translated">bigrat-Perl에 대한 투명한 BigNumber / BigRational 지원</target>
        </trans-unit>
        <trans-unit id="9a5d56716d566997fa290054d161af96305aff9a" translate="yes" xml:space="preserve">
          <source>bin</source>
          <target state="translated">bin</target>
        </trans-unit>
        <trans-unit id="7e19d6f26f79bdfbe7853603c9a8d51e943da151" translate="yes" xml:space="preserve">
          <source>bin.U</source>
          <target state="translated">bin.U</target>
        </trans-unit>
        <trans-unit id="22367761f269c4573006aea78f1e40ab220e3614" translate="yes" xml:space="preserve">
          <source>bin/</source>
          <target state="translated">bin/</target>
        </trans-unit>
        <trans-unit id="7e57cfe843145135aee1f4d0d63ceb7842093712" translate="yes" xml:space="preserve">
          <source>binary</source>
          <target state="translated">binary</target>
        </trans-unit>
        <trans-unit id="f7d496da369e602d60b03924e4f040c7d5dba6c5" translate="yes" xml:space="preserve">
          <source>binary ()</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1ee949aa75285ff225c696a370f886f46b556fe" translate="yes" xml:space="preserve">
          <source>binary operator</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7932f025d5ca969d2e5249dfaee5d1123fb29da" translate="yes" xml:space="preserve">
          <source>binary representation. Leaving floating point numbers aside for the moment, the salient properties of any such representation are:</source>
          <target state="translated">이진 표현. 현재 부동 소수점 숫자를 제외하고 이러한 표현의 두드러진 속성은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="988edf147febb2b4b364a6acf2ddf6d4e94e8f33" translate="yes" xml:space="preserve">
          <source>binary, setting the C pre-processor macro &lt;code&gt;PERL_SUB_DEPTH_WARN&lt;/code&gt; to the desired value.</source>
          <target state="translated">이진, C 전 처리기 매크로 &lt;code&gt;PERL_SUB_DEPTH_WARN&lt;/code&gt; 을 원하는 값으로 설정합니다.</target>
        </trans-unit>
        <trans-unit id="de2cc6807b3c1fe9f5060a6094b70de72fb1f441" translate="yes" xml:space="preserve">
          <source>binary, which affect its binary compatibility with extensions. &lt;code&gt;bincompat_options()&lt;/code&gt; and &lt;code&gt;non_bincompat_options()&lt;/code&gt; are shown together in the output of &lt;code&gt;perl -V&lt;/code&gt; as</source>
          <target state="translated">바이너리. 확장과 바이너리 호환성에 영향을줍니다. &lt;code&gt;bincompat_options()&lt;/code&gt; 및 &lt;code&gt;non_bincompat_options()&lt;/code&gt; 는 &lt;code&gt;perl -V&lt;/code&gt; 의 출력에 함께 표시 됩니다.</target>
        </trans-unit>
        <trans-unit id="b636cf5b464cf1767119b4fe29df7c510211a548" translate="yes" xml:space="preserve">
          <source>binary, which do not affect binary compatibility with extensions.</source>
          <target state="translated">이진은 확장과의 이진 호환성에 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="27b0abcf6d482c493480a28ab67814ecd71ae2f0" translate="yes" xml:space="preserve">
          <source>binary/&lt;code&gt;API&lt;/code&gt;</source>
          <target state="translated">binary/&lt;code&gt;API&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="363c3e51a7bf4d321b21be363e5368c645da7b66" translate="yes" xml:space="preserve">
          <source>binc()</source>
          <target state="translated">binc()</target>
        </trans-unit>
        <trans-unit id="ba42a913444427ae29604c87afb436d490ab0eee" translate="yes" xml:space="preserve">
          <source>bincompat_options()</source>
          <target state="translated">bincompat_options()</target>
        </trans-unit>
        <trans-unit id="6bdd4db977b0f96aaf3bff2e4300153c648ca382" translate="yes" xml:space="preserve">
          <source>bind</source>
          <target state="translated">bind</target>
        </trans-unit>
        <trans-unit id="15cb6b206f5309c215554249b37ea718b7489464" translate="yes" xml:space="preserve">
          <source>bind SOCKET,NAME</source>
          <target state="translated">SOCKET, NAME 바인딩</target>
        </trans-unit>
        <trans-unit id="3602debc77f793084d28f897c8db056aab9923a0" translate="yes" xml:space="preserve">
          <source>bind() on closed socket %s</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90d578a0959805111db0ca77352b04e9eeb22448" translate="yes" xml:space="preserve">
          <source>bind_match</source>
          <target state="translated">bind_match</target>
        </trans-unit>
        <trans-unit id="bb7a39d5637f4bd8a114f03f1fa7e0b4aff29e08" translate="yes" xml:space="preserve">
          <source>binf()</source>
          <target state="translated">binf()</target>
        </trans-unit>
        <trans-unit id="b8caa416ad22dfd04289ea1a80760faf5b038881" translate="yes" xml:space="preserve">
          <source>binmode</source>
          <target state="translated">binmode</target>
        </trans-unit>
        <trans-unit id="5e65b13dafb6dd4c759cc9455fddbe5bd69a8e0f" translate="yes" xml:space="preserve">
          <source>binmode FILEHANDLE</source>
          <target state="translated">빈 모드 파일 핸들</target>
        </trans-unit>
        <trans-unit id="baf4fab3113579642465b028f8be5d19dbe690da" translate="yes" xml:space="preserve">
          <source>binmode FILEHANDLE, LAYER</source>
          <target state="translated">binmode FILEHANDLE, LAYER</target>
        </trans-unit>
        <trans-unit id="f2a5994e1f71b5c1aff0822f4016cadaa9aebdf4" translate="yes" xml:space="preserve">
          <source>binmode( [LAYER] )</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fab68bdc2486879246a68125daf732306cd8090f" translate="yes" xml:space="preserve">
          <source>binmode() is important not only for readline() and print() operations, but also when using read(), seek(), sysread(), syswrite() and tell() (see &lt;a href=&quot;../perlport&quot;&gt;perlport&lt;/a&gt; for more details). See the &lt;code&gt;$/&lt;/code&gt; and &lt;code&gt;$\&lt;/code&gt; variables in &lt;a href=&quot;../perlvar&quot;&gt;perlvar&lt;/a&gt; for how to manually set your input and output line-termination sequences.</source>
          <target state="translated">binmode ()는 readline () 및 print () 작업뿐만 아니라 read (), seek (), sysread (), syswrite () 및 tell ()을 사용할 &lt;a href=&quot;../perlport&quot;&gt;때도 중요&lt;/a&gt; 합니다 (자세한 내용 은 perlport 참조). &lt;a href=&quot;../perlvar&quot;&gt;perlvar&lt;/a&gt; 의 &lt;code&gt;$/&lt;/code&gt; 및 &lt;code&gt;$\&lt;/code&gt; 변수를 참조하십시오입력 및 출력 라인 종료 시퀀스를 수동으로 설정하는 방법 .</target>
        </trans-unit>
        <trans-unit id="c6cf70d51d1b9249c9bedbb5a665191357d92d38" translate="yes" xml:space="preserve">
          <source>binmode() is important not only for readline() and print() operations, but also when using read(), seek(), sysread(), syswrite() and tell() (see &lt;a href=&quot;perlport&quot;&gt;perlport&lt;/a&gt; for more details). See the &lt;code&gt;$/&lt;/code&gt; and &lt;code&gt;$\&lt;/code&gt; variables in &lt;a href=&quot;perlvar&quot;&gt;perlvar&lt;/a&gt; for how to manually set your input and output line-termination sequences.</source>
          <target state="translated">binmode ()는 readline () 및 print () 작업뿐만 아니라 read (), seek (), sysread (), syswrite () 및 tell ()을 사용할 &lt;a href=&quot;perlport&quot;&gt;때도 중요&lt;/a&gt; 합니다 (자세한 내용 은 perlport 참조). 입력 및 출력 라인 종료 시퀀스를 수동으로 설정하는 방법 은 &lt;a href=&quot;perlvar&quot;&gt;perlvar&lt;/a&gt; 의 &lt;code&gt;$/&lt;/code&gt; 및 &lt;code&gt;$\&lt;/code&gt; 변수를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="60f702763d3ad5bf9903d9e678aa9e4af89e2238" translate="yes" xml:space="preserve">
          <source>binmode() on closed filehandle %s</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64304f0eaf264d4083a161af95cca3f4fc9956cd" translate="yes" xml:space="preserve">
          <source>binmode() operates similarly to open(): by default the specified layers are pushed on top of the existing stack.</source>
          <target state="translated">binmode ()는 open ()과 유사하게 작동합니다. 기본적으로 지정된 레이어는 기존 스택 위에 푸시됩니다.</target>
        </trans-unit>
        <trans-unit id="250fb1b9cb55ba7726de39c65a4415cec8af2124" translate="yes" xml:space="preserve">
          <source>bint()</source>
          <target state="translated">bint()</target>
        </trans-unit>
        <trans-unit id="31c29ae0733c42de73bfb453a629bee7e9b6fec2" translate="yes" xml:space="preserve">
          <source>bior()</source>
          <target state="translated">bior()</target>
        </trans-unit>
        <trans-unit id="20f2d91e547cecad3b564ae99be53b45a6e670cc" translate="yes" xml:space="preserve">
          <source>bison on BS2000</source>
          <target state="translated">BS2000의 들소</target>
        </trans-unit>
        <trans-unit id="026e996a3a5897970b058ffb093a163a1d763649" translate="yes" xml:space="preserve">
          <source>bit</source>
          <target state="translated">bit</target>
        </trans-unit>
        <trans-unit id="6e9475cbf618e2a540cd3ae4d7ab90c75f93bbeb" translate="yes" xml:space="preserve">
          <source>bit shift</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49f36fe2ba6ed4cff4356d9f8dea3adc00c78919" translate="yes" xml:space="preserve">
          <source>bit string</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f019d80321d209bdb5e25621a435c0f92ac86cfd" translate="yes" xml:space="preserve">
          <source>bits that is computed from the data value by doing sums. For numeric unpack codes, no big feat is achieved:</source>
          <target state="translated">합을 수행하여 데이터 값에서 계산되는 비트. 숫자 압축 해제 코드의 경우 큰 위업이 달성되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="40a983b6b8280be6ababf17747af9e90f24d20e5" translate="yes" xml:space="preserve">
          <source>bits()</source>
          <target state="translated">bits()</target>
        </trans-unit>
        <trans-unit id="5bf1fd927dfb8679496a2e6cf00cbe50c1c87145" translate="yes" xml:space="preserve">
          <source>blah</source>
          <target state="translated">blah</target>
        </trans-unit>
        <trans-unit id="fcfd8b08b9dfc18492f53d1d51ef8d9ad41fbf87" translate="yes" xml:space="preserve">
          <source>blah.</source>
          <target state="translated">blah.</target>
        </trans-unit>
        <trans-unit id="c6198477997fe2771883ee25a1a71d0e4c7432b1" translate="yes" xml:space="preserve">
          <source>blah.exe</source>
          <target state="translated">blah.exe</target>
        </trans-unit>
        <trans-unit id="d48f3ab263e0a433c016223a2cc9e17538ed8009" translate="yes" xml:space="preserve">
          <source>blcm()</source>
          <target state="translated">blcm()</target>
        </trans-unit>
        <trans-unit id="c781287b99805ae6221518d95023fb40e89c637d" translate="yes" xml:space="preserve">
          <source>ble()</source>
          <target state="translated">ble()</target>
        </trans-unit>
        <trans-unit id="b5d874c5300674b3f1fdbeb29f0902746ff358b4" translate="yes" xml:space="preserve">
          <source>blead</source>
          <target state="translated">blead</target>
        </trans-unit>
        <trans-unit id="710f4beb6f3094fc46248a083fb427bcc0ad2e24" translate="yes" xml:space="preserve">
          <source>bless</source>
          <target state="translated">bless</target>
        </trans-unit>
        <trans-unit id="e4f59c387f62cb1edb42a1911954c50219be47d9" translate="yes" xml:space="preserve">
          <source>bless REF</source>
          <target state="translated">REF를 축복</target>
        </trans-unit>
        <trans-unit id="2e44205459ae344b338868e3b6b33bce58faf520" translate="yes" xml:space="preserve">
          <source>bless REF,CLASSNAME</source>
          <target state="translated">REF, CLASSNAME 축복</target>
        </trans-unit>
        <trans-unit id="a49b3189e430e15827425d766ade8c8277059efb" translate="yes" xml:space="preserve">
          <source>bless, blessed, and ref</source>
          <target state="translated">축복, 축복, 심판</target>
        </trans-unit>
        <trans-unit id="f08a7a19e6f47e1125c9aee2336c6759c7798fe4" translate="yes" xml:space="preserve">
          <source>blessed</source>
          <target state="translated">blessed</target>
        </trans-unit>
        <trans-unit id="d4099c2cf9d57b9aa6b6e77ea9626851697cb3d9" translate="yes" xml:space="preserve">
          <source>blessed objects</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7cdb9aa0f32f7a30fb9e35578aff5c7297e84bc8" translate="yes" xml:space="preserve">
          <source>blessings</source>
          <target state="translated">blessings</target>
        </trans-unit>
        <trans-unit id="5948cd46ec4b37fb77f455070c85e3a53a5385e6" translate="yes" xml:space="preserve">
          <source>blib</source>
          <target state="translated">blib</target>
        </trans-unit>
        <trans-unit id="58725a4e858a2c6188cdb04784100e5472989d90" translate="yes" xml:space="preserve">
          <source>blib - Use MakeMaker's uninstalled version of a package</source>
          <target state="translated">blib-MakeMaker의 제거 된 버전의 패키지 사용</target>
        </trans-unit>
        <trans-unit id="a76058b40e0fac4a71812a9bc906c2fefb88858f" translate="yes" xml:space="preserve">
          <source>blibdirs_target</source>
          <target state="translated">blibdirs_target</target>
        </trans-unit>
        <trans-unit id="8da57d83e4710f0212054859934df64541f40cd0" translate="yes" xml:space="preserve">
          <source>blk</source>
          <target state="translated">blk</target>
        </trans-unit>
        <trans-unit id="0214b4b355d11ca8f2ce45a968c264651bdfbf83" translate="yes" xml:space="preserve">
          <source>block</source>
          <target state="translated">block</target>
        </trans-unit>
        <trans-unit id="ea5d1a0307254d54b411f8a86b15040e8cbfc1d0" translate="yes" xml:space="preserve">
          <source>block buffering</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="becaa99a9fe347b3fe23dad3399ecd24d24e190b" translate="yes" xml:space="preserve">
          <source>block_end</source>
          <target state="translated">block_end</target>
        </trans-unit>
        <trans-unit id="6e0db69ae9a110cb6559b4ef655ce755a7a4f145" translate="yes" xml:space="preserve">
          <source>block_gimme</source>
          <target state="translated">block_gimme</target>
        </trans-unit>
        <trans-unit id="97da064a01b65a84f70baff2ab2b7809d324186f" translate="yes" xml:space="preserve">
          <source>block_start</source>
          <target state="translated">block_start</target>
        </trans-unit>
        <trans-unit id="c898441623d0cc22ba93c724ee92159aa2b6b2da" translate="yes" xml:space="preserve">
          <source>blockhook_register</source>
          <target state="translated">blockhook_register</target>
        </trans-unit>
        <trans-unit id="ee446b079331cb4d066226bbfc81a241b9f5b572" translate="yes" xml:space="preserve">
          <source>blog()</source>
          <target state="translated">blog()</target>
        </trans-unit>
        <trans-unit id="a26effe1d3cc643c316da1033ce081d24a76b9b8" translate="yes" xml:space="preserve">
          <source>bls=INTEGER</source>
          <target state="translated">bls=INTEGER</target>
        </trans-unit>
        <trans-unit id="baf27f3dc38c3a93bf31c0a7a2de08fc0847febe" translate="yes" xml:space="preserve">
          <source>blsft()</source>
          <target state="translated">blsft()</target>
        </trans-unit>
        <trans-unit id="de78f4557b8f92abac734524c8092acd1ff00895" translate="yes" xml:space="preserve">
          <source>blsft()/brsft()</source>
          <target state="translated">blsft()/brsft()</target>
        </trans-unit>
        <trans-unit id="2fd0fd5e8785cded108a0b4c3987011a3f9a433d" translate="yes" xml:space="preserve">
          <source>blt()</source>
          <target state="translated">blt()</target>
        </trans-unit>
        <trans-unit id="d469821215ed8fdf1c01a8627ec36c65a0c24c61" translate="yes" xml:space="preserve">
          <source>blucas()</source>
          <target state="translated">blucas()</target>
        </trans-unit>
        <trans-unit id="6ad7da3d1b629d68c47436ccd4e4c6a0178702ac" translate="yes" xml:space="preserve">
          <source>blurt()</source>
          <target state="translated">blurt()</target>
        </trans-unit>
        <trans-unit id="2e264db45128e397f171695bf390adfeef3598d7" translate="yes" xml:space="preserve">
          <source>bmod()</source>
          <target state="translated">bmod()</target>
        </trans-unit>
        <trans-unit id="f86c0f154ec1ab4f7cd30137f9e8a89a6840eb8d" translate="yes" xml:space="preserve">
          <source>bmodinv()</source>
          <target state="translated">bmodinv()</target>
        </trans-unit>
        <trans-unit id="f5a284f7da3f4f73b7f14dfbaf90e3ce7dacf74f" translate="yes" xml:space="preserve">
          <source>bmodpow()</source>
          <target state="translated">bmodpow()</target>
        </trans-unit>
        <trans-unit id="d21319b5c7ceef0c5567dfd8d4c57a92446b6d7f" translate="yes" xml:space="preserve">
          <source>bmul()</source>
          <target state="translated">bmul()</target>
        </trans-unit>
        <trans-unit id="2e05368ab1d3b7d6116240a0313ea500b290658b" translate="yes" xml:space="preserve">
          <source>bmuladd()</source>
          <target state="translated">bmuladd()</target>
        </trans-unit>
        <trans-unit id="8a2a6d034355be7780085f14f8c5624812072e77" translate="yes" xml:space="preserve">
          <source>bnan()</source>
          <target state="translated">bnan()</target>
        </trans-unit>
        <trans-unit id="4bffed2ba79069b83e61d43558db9e0145189b86" translate="yes" xml:space="preserve">
          <source>bne()</source>
          <target state="translated">bne()</target>
        </trans-unit>
        <trans-unit id="acb2323220a9a7746a44255816d71f5351a4790a" translate="yes" xml:space="preserve">
          <source>bneg()</source>
          <target state="translated">bneg()</target>
        </trans-unit>
        <trans-unit id="33366fdd69ce84e94b98d8a229f85a41c634530c" translate="yes" xml:space="preserve">
          <source>bnok()</source>
          <target state="translated">bnok()</target>
        </trans-unit>
        <trans-unit id="c770c8e7173b85479c2dc8ac9f7dcbb9bc5fe2f3" translate="yes" xml:space="preserve">
          <source>bnorm()</source>
          <target state="translated">bnorm()</target>
        </trans-unit>
        <trans-unit id="32895dc66f25fd7dac0899bd9b4408dd1841faf8" translate="yes" xml:space="preserve">
          <source>bnorm() on a BigFloat object is now effectively a no-op, since the numbers are always stored in normalized form. On a string, it creates a BigFloat object.</source>
          <target state="translated">숫자가 항상 정규화 된 형식으로 저장되기 때문에 BigFloat 객체의 bnorm ()은 사실상 효과적으로 작동하지 않습니다. 문자열에서 BigFloat 오브젝트를 작성합니다.</target>
        </trans-unit>
        <trans-unit id="6b70c4805252a1f570e1c562fbc4bfa29477eff5" translate="yes" xml:space="preserve">
          <source>bnot()</source>
          <target state="translated">bnot()</target>
        </trans-unit>
        <trans-unit id="9cc5e5eaa9df15ad6ffcceb045fc439ba9eab576" translate="yes" xml:space="preserve">
          <source>bnstr()</source>
          <target state="translated">bnstr()</target>
        </trans-unit>
        <trans-unit id="02083f4579e08a612425c0c1a17ee47add783b94" translate="yes" xml:space="preserve">
          <source>body</source>
          <target state="translated">body</target>
        </trans-unit>
        <trans-unit id="07f7b599effa948213cb412138977cc6851f9893" translate="yes" xml:space="preserve">
          <source>body ( [ MSGID|MSGNUM ], [FH] )</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2dd66051b28e6f8b12d66a43475ba8fdeaaa1ce" translate="yes" xml:space="preserve">
          <source>bodyfh ( [ MSGID|MSGNUM ] )</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42e30168211d8a342d95644b4fce96a7ffe7889f" translate="yes" xml:space="preserve">
          <source>bone()</source>
          <target state="translated">bone()</target>
        </trans-unit>
        <trans-unit id="1aed26655fb288402a22a39e65ab37ea6faa2d19" translate="yes" xml:space="preserve">
          <source>book-keeping code to the generated code. During the execution of the code the basic block counters are then updated appropriately. The caveat is that the added extra code can skew the results: again, the profiling tools usually try to factor their own effects out of the results.</source>
          <target state="translated">생성 된 코드에 대한 부기 코드. 코드를 실행하는 동안 기본 블록 카운터가 적절하게 업데이트됩니다. 주의 할 점은 추가 된 추가 코드가 결과를 왜곡 할 수 있다는 것입니다. 다시 말하지만 프로파일 링 도구는 일반적으로 결과에서 자체 효과를 고려하려고합니다.</target>
        </trans-unit>
        <trans-unit id="cb16f9aff92a0c271f47676b6dc33d3ff149671b" translate="yes" xml:space="preserve">
          <source>boolSV</source>
          <target state="translated">boolSV</target>
        </trans-unit>
        <trans-unit id="15de74af85d07cd58ad10ef45f5cbb7c4ac1ac21" translate="yes" xml:space="preserve">
          <source>boolean_values</source>
          <target state="translated">boolean_values</target>
        </trans-unit>
        <trans-unit id="729e45dc00b922b49b39fefe181e1e856ed87ec4" translate="yes" xml:space="preserve">
          <source>boot_Module</source>
          <target state="translated">boot_Module</target>
        </trans-unit>
        <trans-unit id="ba663f22e3229112460a32e29c16274682d6bf7a" translate="yes" xml:space="preserve">
          <source>boot_ModuleName</source>
          <target state="translated">boot_ModuleName</target>
        </trans-unit>
        <trans-unit id="64c0e72dbf0f0628e440bc4de8d9b1e0c449a446" translate="yes" xml:space="preserve">
          <source>boot_core_PerlIO</source>
          <target state="translated">boot_core_PerlIO</target>
        </trans-unit>
        <trans-unit id="d12639f1803461ade20f59eabc548f63c620d600" translate="yes" xml:space="preserve">
          <source>boot_core_UNIVERSAL</source>
          <target state="translated">boot_core_UNIVERSAL</target>
        </trans-unit>
        <trans-unit id="452ef9046c45ab3336e7f180a67ce8abe7d63ed7" translate="yes" xml:space="preserve">
          <source>boot_core_mro</source>
          <target state="translated">boot_core_mro</target>
        </trans-unit>
        <trans-unit id="3c71cc99d2fc1c12a3d3e1b27e448ca612a89a1d" translate="yes" xml:space="preserve">
          <source>bootstrap</source>
          <target state="translated">bootstrap</target>
        </trans-unit>
        <trans-unit id="4b73f58647d46c351e92c5308bdff57c346a520b" translate="yes" xml:space="preserve">
          <source>bootstrap($module [...])</source>
          <target state="translated">부트 스트랩 ($ module [...])</target>
        </trans-unit>
        <trans-unit id="7e42e955dc52bdd16eb64e40e8cbb6e2038cb5a4" translate="yes" xml:space="preserve">
          <source>bootstrap()</source>
          <target state="translated">bootstrap()</target>
        </trans-unit>
        <trans-unit id="7910fb624621794d30d4a0171b4ef16c06efef31" translate="yes" xml:space="preserve">
          <source>bootstraps the shared library and</source>
          <target state="translated">공유 라이브러리를 부트 스트랩하고</target>
        </trans-unit>
        <trans-unit id="05b1f356646c24bf1765f6f1b65aea3bde7247e1" translate="yes" xml:space="preserve">
          <source>boss</source>
          <target state="translated">boss</target>
        </trans-unit>
        <trans-unit id="fc39b18f287d8bbfaceae020f4a4eb32ac5c1e70" translate="yes" xml:space="preserve">
          <source>both</source>
          <target state="translated">both</target>
        </trans-unit>
        <trans-unit id="5d5c5a75e87987f4e30517320181d3167e2e90c2" translate="yes" xml:space="preserve">
          <source>both &lt;code&gt;/x&lt;/code&gt; and &lt;code&gt;/xx&lt;/code&gt; are turned off during matching &lt;code&gt;foo&lt;/code&gt;. And in</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="abb0e3da05698e3415e8b8587366c2e5c9fe8869" translate="yes" xml:space="preserve">
          <source>both map to</source>
          <target state="translated">둘 다에 매핑</target>
        </trans-unit>
        <trans-unit id="654dc453fcad5d97496638c1771b5fea1e41eb18" translate="yes" xml:space="preserve">
          <source>both of which mean to enable locale awarness of all categories but &lt;code&gt;LC_CTYPE&lt;/code&gt; . Only one category argument may be specified in a &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; if it is of the negated form.</source>
          <target state="translated">둘 다 &lt;code&gt;LC_CTYPE&lt;/code&gt; 이외의 모든 범주에 대한 로케일 경고를 활성화 합니다. &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; 로케일 에는 하나의 범주 인수 만 지정할 수 있습니다.부정 형식 인 경우 .</target>
        </trans-unit>
        <trans-unit id="6ee6da7a89433b3846111e0827da206b1a6c3586" translate="yes" xml:space="preserve">
          <source>both of which mean to enable locale awarness of all categories but &lt;code&gt;LC_CTYPE&lt;/code&gt;. Only one category argument may be specified in a &lt;code&gt;use locale&lt;/code&gt; if it is of the negated form.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b71091a1e00fc7f0377bb487f77f1ea5a597b77" translate="yes" xml:space="preserve">
          <source>both result in the proper type due to the way the overloaded math works.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26d491c7e7617951114de7ec765c4e99eb127ce3" translate="yes" xml:space="preserve">
          <source>both s and m modifiers (//sm): Treat string as a single long line, but detect multiple lines. &lt;code&gt;'.'&lt;/code&gt; matches any character, even &lt;code&gt;&quot;\n&quot;&lt;/code&gt; . &lt;code&gt;^&lt;/code&gt; and &lt;code&gt;$&lt;/code&gt; , however, are able to match at the start or end of</source>
          <target state="translated">s 및 m 수정 자 (// sm) : 문자열을 하나의 긴 줄로 취급하지만 여러 줄을 감지합니다. &lt;code&gt;'.'&lt;/code&gt; &lt;code&gt;&quot;\n&quot;&lt;/code&gt; 조차 모든 문자와 일치합니다 . 그러나 &lt;code&gt;^&lt;/code&gt; 및 &lt;code&gt;$&lt;/code&gt; 는 시작 또는 끝에서 일치 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="da125409d0b04b5363bed4f7c169c16908244cb2" translate="yes" xml:space="preserve">
          <source>both s and m modifiers (&lt;code&gt;/sm&lt;/code&gt;): Treat string as a single long line, but detect multiple lines. &lt;code&gt;'.'&lt;/code&gt; matches any character, even &lt;code&gt;&quot;\n&quot;&lt;/code&gt;. &lt;code&gt;'^'&lt;/code&gt; and &lt;code&gt;'$'&lt;/code&gt;, however, are able to match at the start or end of</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d145e8b6add511128e3c21f5ad3c0317ad3aa0f5" translate="yes" xml:space="preserve">
          <source>both supply a list context to the right-hand side, while</source>
          <target state="translated">둘 다 오른쪽에 목록 컨텍스트를 제공하고</target>
        </trans-unit>
        <trans-unit id="ddb1e7c979a33eef473274634ab437e562e02159" translate="yes" xml:space="preserve">
          <source>bother</source>
          <target state="translated">bother</target>
        </trans-unit>
        <trans-unit id="f4072a98f3cc33db2397c1a6a2d723f3288e5a64" translate="yes" xml:space="preserve">
          <source>bpi()</source>
          <target state="translated">bpi()</target>
        </trans-unit>
        <trans-unit id="23998aef8c711bbb24e99222ca54b2d1029087d8" translate="yes" xml:space="preserve">
          <source>bpow()</source>
          <target state="translated">bpow()</target>
        </trans-unit>
        <trans-unit id="8a6b08579a9805d7dea44b94ea1dcb6609f11536" translate="yes" xml:space="preserve">
          <source>bracketed character classes, and are a convenient and descriptive way of listing a group of characters.</source>
          <target state="translated">대괄호 문자 클래스이며 문자 그룹을 나열하는 편리하고 설명적인 방법입니다.</target>
        </trans-unit>
        <trans-unit id="837cc1c54b7aa66d67f7d308af69db6dc69fbbe4" translate="yes" xml:space="preserve">
          <source>brackets subscripts, so you can shrink the above down to</source>
          <target state="translated">대괄호 아래 첨자를 사용하여 위의</target>
        </trans-unit>
        <trans-unit id="f58c2f1ddf1f99fbc5e588ef92122fd5f4e64d88" translate="yes" xml:space="preserve">
          <source>branch, and your repository is up to date:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f9cac8dbc4c67a388b8379dcc126c90c7c5e72a" translate="yes" xml:space="preserve">
          <source>break</source>
          <target state="translated">break</target>
        </trans-unit>
        <trans-unit id="ae39aad32a94dadfcf3189dc5c2a3e59c0c744ea" translate="yes" xml:space="preserve">
          <source>break function_name</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e5884029856e1077621c33f780a067f09de226f" translate="yes" xml:space="preserve">
          <source>break source.c:xxx</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb43d711172bd27bbb3fc18fb773e33edc6b3165" translate="yes" xml:space="preserve">
          <source>breaking down the problem into smaller parts,</source>
          <target state="translated">문제를 더 작은 부분으로 나누고</target>
        </trans-unit>
        <trans-unit id="ef6896ab2d5a3c6e8ba7ee46ba3e48c29057ad74" translate="yes" xml:space="preserve">
          <source>breakout</source>
          <target state="translated">breakout</target>
        </trans-unit>
        <trans-unit id="5c0a31c48cda57c40dc61b785110d76593834ffd" translate="yes" xml:space="preserve">
          <source>breakpoint</source>
          <target state="translated">breakpoint</target>
        </trans-unit>
        <trans-unit id="b33a5b3e6b7eb3b9f7f1a0e451dee877c2374873" translate="yes" xml:space="preserve">
          <source>breaks this paradigm;</source>
          <target state="translated">이 패러다임을 끊습니다.</target>
        </trans-unit>
        <trans-unit id="58bcf671da7c6005da184d1a734e880e766af7f5" translate="yes" xml:space="preserve">
          <source>brian d foy &lt;code&gt;&amp;lt;brian.d.foy@gmail.com&amp;gt;&lt;/code&gt;</source>
          <target state="translated">브라이언 디 포이 &lt;code&gt;&amp;lt;brian.d.foy@gmail.com&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d66ce35469f9f5b7a50b1393b2943fdd723739c2" translate="yes" xml:space="preserve">
          <source>brian d foy, &lt;code&gt;&amp;lt;bdfoy@cpan.org&amp;gt;&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61d0590ea80fc27ef2d48128cdc45e16256169d0" translate="yes" xml:space="preserve">
          <source>brian m. carlson &amp;lt;sandals@crustytoothpaste.net&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b58ccb7871e0261dfe6de9e4f5274543ebbebeb8" translate="yes" xml:space="preserve">
          <source>broadcast</source>
          <target state="translated">broadcast</target>
        </trans-unit>
        <trans-unit id="96a69616cc78fb488e50bb7f07bd37667d493f80" translate="yes" xml:space="preserve">
          <source>broken.</source>
          <target state="translated">broken.</target>
        </trans-unit>
        <trans-unit id="0b12bb49ef8a21331b0526566fe4b80e5eaec019" translate="yes" xml:space="preserve">
          <source>broot()</source>
          <target state="translated">broot()</target>
        </trans-unit>
        <trans-unit id="1bb9049aef8480778900302b76f274d373fd9aaa" translate="yes" xml:space="preserve">
          <source>bround ( +$scale )</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31feb56dfd8fcb4e7473c88c2003fc388b6520b7" translate="yes" xml:space="preserve">
          <source>bround ( -$scale ) and bround ( 0 )</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13660c144d6e63ed7a875821a88f3b27a21b7786" translate="yes" xml:space="preserve">
          <source>bround()</source>
          <target state="translated">bround()</target>
        </trans-unit>
        <trans-unit id="6fa78ae26f483beb12891190edb2dc005e4cbe3b" translate="yes" xml:space="preserve">
          <source>bround()/round()/bfround()</source>
          <target state="translated">bround()/round()/bfround()</target>
        </trans-unit>
        <trans-unit id="9ca2d10d5ef0cae97ebe373154409473b2e7e075" translate="yes" xml:space="preserve">
          <source>brsft()</source>
          <target state="translated">brsft()</target>
        </trans-unit>
        <trans-unit id="48f3f89ac3fac5337b47faa8a2f93eb8b298844e" translate="yes" xml:space="preserve">
          <source>bsd</source>
          <target state="translated">bsd</target>
        </trans-unit>
        <trans-unit id="7f4d4889db6efc5f4473f596054724e46849358d" translate="yes" xml:space="preserve">
          <source>bsd_glob</source>
          <target state="translated">bsd_glob</target>
        </trans-unit>
        <trans-unit id="1dbd729f945c8998e112203241f2035b87c572b0" translate="yes" xml:space="preserve">
          <source>bsd_glob() returns a list of matching paths, possibly zero length. If an error occurred, &amp;amp;File::Glob::GLOB_ERROR will be non-zero and &lt;code&gt;$!&lt;/code&gt; will be set. &amp;amp;File::Glob::GLOB_ERROR is guaranteed to be zero if no error occurred, or one of the following values otherwise:</source>
          <target state="translated">bsd_glob ()는 길이가 0 인 일치하는 경로 목록을 반환합니다. 오류가 발생하면 &amp;amp; File :: Glob :: GLOB_ERROR는 0이 아니며 &lt;code&gt;$!&lt;/code&gt; 설정됩니다. &amp;amp; File :: Glob :: GLOB_ERROR는 오류가 발생하지 않으면 0, 그렇지 않으면 다음 값 중 하나를 보장합니다.</target>
        </trans-unit>
        <trans-unit id="60747fb94e0ee1e6a3033c0be43d87212b33a4f5" translate="yes" xml:space="preserve">
          <source>bsddev.zip</source>
          <target state="translated">bsddev.zip</target>
        </trans-unit>
        <trans-unit id="3a8d931b6b3b0c9a1cc280dd0b5c81f1da1ad556" translate="yes" xml:space="preserve">
          <source>bsgn()</source>
          <target state="translated">bsgn()</target>
        </trans-unit>
        <trans-unit id="12b8a881b5b383f3a144a3c69221d0f08e530a29" translate="yes" xml:space="preserve">
          <source>bsin()</source>
          <target state="translated">bsin()</target>
        </trans-unit>
        <trans-unit id="98e6344878aedd07915a448203ac11106893ceb4" translate="yes" xml:space="preserve">
          <source>bsqrt()</source>
          <target state="translated">bsqrt()</target>
        </trans-unit>
        <trans-unit id="1c2f15e3472a6bf8ee81043d6243485c54d30bbe" translate="yes" xml:space="preserve">
          <source>bsstr()</source>
          <target state="translated">bsstr()</target>
        </trans-unit>
        <trans-unit id="2bd0fed432a2912a0d25f620e2789f60d1a512a3" translate="yes" xml:space="preserve">
          <source>bstr()</source>
          <target state="translated">bstr()</target>
        </trans-unit>
        <trans-unit id="d0f6068194aa4e1d1262dafb62bcf499c7cc6deb" translate="yes" xml:space="preserve">
          <source>bstr()/bsstr()</source>
          <target state="translated">bstr()/bsstr()</target>
        </trans-unit>
        <trans-unit id="980e1fb430966cca3406c283871633ee8baa3018" translate="yes" xml:space="preserve">
          <source>bsub()</source>
          <target state="translated">bsub()</target>
        </trans-unit>
        <trans-unit id="3f36bff1518edbd010b34e425c692562b53fe0ad" translate="yes" xml:space="preserve">
          <source>btdiv()</source>
          <target state="translated">btdiv()</target>
        </trans-unit>
        <trans-unit id="d4fd519d057429d2d758445e9374839a00ca1b21" translate="yes" xml:space="preserve">
          <source>btmod()</source>
          <target state="translated">btmod()</target>
        </trans-unit>
        <trans-unit id="fe1b2b96400138c433e3bcd27a0351d10505d6a4" translate="yes" xml:space="preserve">
          <source>btree(3)</source>
          <target state="translated">btree(3)</target>
        </trans-unit>
        <trans-unit id="827b8276dd99a8a945b710d5e1f7ccb6d9c39b16" translate="yes" xml:space="preserve">
          <source>bucket</source>
          <target state="translated">bucket</target>
        </trans-unit>
        <trans-unit id="e53c2ea1fe4bd2b78bf4723c7c155a578e020a25" translate="yes" xml:space="preserve">
          <source>buffer</source>
          <target state="translated">buffer</target>
        </trans-unit>
        <trans-unit id="bdc28be892a4dde516e1a5280e9c0bfe5afdc72a" translate="yes" xml:space="preserve">
          <source>bugtracker</source>
          <target state="translated">bugtracker</target>
        </trans-unit>
        <trans-unit id="80754af91bfb6d1073585b046fe0a474ce868509" translate="yes" xml:space="preserve">
          <source>build</source>
          <target state="translated">build</target>
        </trans-unit>
        <trans-unit id="39001d5c18f51088ca9e1057a5abbd818117d55a" translate="yes" xml:space="preserve">
          <source>build them, but you must link the XSUBs subroutines with the rest of Perl, creating a new executable. This situation is similar to Perl 4.</source>
          <target state="translated">이들을 빌드하되 XSUB 서브 루틴을 나머지 Perl과 링크하여 새 실행 파일을 작성해야합니다. 이 상황은 Perl 4와 유사합니다.</target>
        </trans-unit>
        <trans-unit id="bae58eaace8b2754bd7e021ee9fd629f49a70e0a" translate="yes" xml:space="preserve">
          <source>build_cache</source>
          <target state="translated">build_cache</target>
        </trans-unit>
        <trans-unit id="18bd034387c04d01dcb25b1dcf731365caa38d24" translate="yes" xml:space="preserve">
          <source>build_dir</source>
          <target state="translated">build_dir</target>
        </trans-unit>
        <trans-unit id="e64a2bbf05ec931c7e1cf57f9fa89ecf2f60a4ce" translate="yes" xml:space="preserve">
          <source>build_dir_reuse</source>
          <target state="translated">build_dir_reuse</target>
        </trans-unit>
        <trans-unit id="86d56dce4a9004aa00c2f6d659e3142638e7cd56" translate="yes" xml:space="preserve">
          <source>build_requires</source>
          <target state="translated">build_requires</target>
        </trans-unit>
        <trans-unit id="aefa500bb9b669c85109eeba4ef5252fdc5d8c36" translate="yes" xml:space="preserve">
          <source>build_requires_install_policy</source>
          <target state="translated">build_requires_install_policy</target>
        </trans-unit>
        <trans-unit id="f52318a05e518a5596012af2ed38de68ac26a468" translate="yes" xml:space="preserve">
          <source>builder</source>
          <target state="translated">builder</target>
        </trans-unit>
        <trans-unit id="9b72ae582cc1e1e343de827cc627cd49a4a6c7c4" translate="yes" xml:space="preserve">
          <source>building below the perl source directory. If you</source>
          <target state="translated">펄 소스 디렉토리 아래에 건물. 만약 너라면</target>
        </trans-unit>
        <trans-unit id="947d8f664d143e01412e73e257100b32b9ed0ecf" translate="yes" xml:space="preserve">
          <source>building below the perl source, INST_LIB and INST_ARCHLIB default to ../../lib, and INST_SCRIPT is not defined.</source>
          <target state="translated">펄 소스 아래에서 빌드하는 경우, INST_LIB 및 INST_ARCHLIB는 기본적으로 ../../lib이며 INST_SCRIPT는 정의되어 있지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f125862e397bf52c7831a13c2443aeda18c3ffb1" translate="yes" xml:space="preserve">
          <source>builds a PPD package that references a binary of the &lt;code&gt;Agent&lt;/code&gt; package, located in the &lt;code&gt;x86&lt;/code&gt; directory relative to the PPD itself.</source>
          <target state="translated">PPD 자체와 관련 하여 &lt;code&gt;x86&lt;/code&gt; 디렉토리 에 있는 &lt;code&gt;Agent&lt;/code&gt; 패키지 의 바이너리를 참조하는 PPD 패키지를 빌드 합니다.</target>
        </trans-unit>
        <trans-unit id="54c968766b16149a445212d3b145a5471982de2f" translate="yes" xml:space="preserve">
          <source>builds a Perl extension for use by Encode from either Unicode Character Mapping files (.ucm) or Tcl Encoding Files (.enc). Besides being used internally during the build process of the Encode module, you can use</source>
          <target state="translated">유니 코드 문자 매핑 파일 (.ucm) 또는 Tcl 인코딩 파일 (.enc)에서 Encode에서 사용할 Perl 확장을 빌드합니다. Encode 모듈의 빌드 프로세스 중에 내부적으로 사용되는 것 외에도</target>
        </trans-unit>
        <trans-unit id="02270db35bb6bd281f1f08fafc816eeb39611e44" translate="yes" xml:space="preserve">
          <source>builds a Perl extension from C header files. The extension will include functions which can be used to retrieve the value of any #define statement which was in the C header files.</source>
          <target state="translated">C 헤더 파일에서 Perl 확장을 빌드합니다. 확장명에는 C 헤더 파일에있는 #define 문의 값을 검색하는 데 사용할 수있는 함수가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="353c847ec3d51fb75d760939a900605ca2ba1152" translate="yes" xml:space="preserve">
          <source>built</source>
          <target state="translated">built</target>
        </trans-unit>
        <trans-unit id="20338f4396d53223790aaa148f621aa479ece3c0" translate="yes" xml:space="preserve">
          <source>built-in</source>
          <target state="translated">built-in</target>
        </trans-unit>
        <trans-unit id="26af528c9f66aa4c3245f46b32caf847b44d0509" translate="yes" xml:space="preserve">
          <source>bulkdd@cpan.org</source>
          <target state="translated">bulkdd@cpan.org</target>
        </trans-unit>
        <trans-unit id="d59795de8a4d83834e525b589b2bb0c12e4542c1" translate="yes" xml:space="preserve">
          <source>bundle</source>
          <target state="translated">bundle</target>
        </trans-unit>
        <trans-unit id="35e8277cc95cf8aaf1e8e9ffcb5ea39e6502bbd0" translate="yes" xml:space="preserve">
          <source>bundles</source>
          <target state="translated">bundles</target>
        </trans-unit>
        <trans-unit id="a31ed492140d39480ecda647d79e466b5ce2218c" translate="yes" xml:space="preserve">
          <source>bundling (default: disabled)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="77e25bc919e32ad451aa8e6adc14844860a2a627" translate="yes" xml:space="preserve">
          <source>bundling_override (default: disabled)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97bd27f135ae383d1ab339e2ddd56faabfe06a3c" translate="yes" xml:space="preserve">
          <source>bunzip2 $input_filename_or_reference =&amp;gt; $output_filename_or_reference [, OPTS]</source>
          <target state="translated">bunzip2 $ input_filename_or_reference =&amp;gt; $ output_filename_or_reference [, OPTS]</target>
        </trans-unit>
        <trans-unit id="ded851c3d8d9888e3e55d4afcffaa2a08724edd0" translate="yes" xml:space="preserve">
          <source>buparrow()</source>
          <target state="translated">buparrow()</target>
        </trans-unit>
        <trans-unit id="786e97b3ee9fc4b292d5852c2c5943153c4ce91a" translate="yes" xml:space="preserve">
          <source>but</source>
          <target state="translated">but</target>
        </trans-unit>
        <trans-unit id="cf72a790bf9220db925b72c5cbee1dd78ac17da1" translate="yes" xml:space="preserve">
          <source>but $var is referenced elsewhere and could be modified after the &lt;code&gt;&lt;a href=&quot;functions/sub&quot;&gt;sub&lt;/a&gt;&lt;/code&gt; expression is evaluated. Either it is explicitly modified elsewhere (&lt;code&gt;$var = 3&lt;/code&gt; ) or it is passed to a subroutine or to an operator like &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/map&quot;&gt;map&lt;/a&gt;&lt;/code&gt;, which may or may not modify the variable.</source>
          <target state="translated">그러나 $ var은 다른 곳에서 참조되며 &lt;code&gt;&lt;a href=&quot;functions/sub&quot;&gt;sub&lt;/a&gt;&lt;/code&gt; 표현식을 평가 한 후에 수정할 수 있습니다 . 다른 곳에서 명시 적으로 수정 되거나 ( &lt;code&gt;$var = 3&lt;/code&gt; ), 서브 루틴 또는 &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;functions/map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; 과 같은 연산자로 전달되어 변수를 수정하거나 수정하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d3309c6a5b5625d9bc8f85ff4b36ff98024811f1" translate="yes" xml:space="preserve">
          <source>but $var is referenced elsewhere and could be modified after the &lt;code&gt;sub&lt;/code&gt; expression is evaluated. Either it is explicitly modified elsewhere (&lt;code&gt;$var = 3&lt;/code&gt;) or it is passed to a subroutine or to an operator like &lt;code&gt;printf&lt;/code&gt; or &lt;code&gt;map&lt;/code&gt;, which may or may not modify the variable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5db1b56b00418784571960c2c16e06bc81c8bff7" translate="yes" xml:space="preserve">
          <source>but I immediately went looking for some more concise way to basically denote the same phrase-function -- a way that would also serve to concisely denote</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71b30c3e0c461e872d1934c8031a13c3d20f53a0" translate="yes" xml:space="preserve">
          <source>but a string consisting of two null bytes (the result of &lt;code&gt;&quot;\020\020&quot;
&amp;amp; &quot;\101\101&quot;&lt;/code&gt; ) is not a false value in Perl. You need:</source>
          <target state="translated">그러나 두 개의 널 바이트 ( &lt;code&gt;&quot;\020\020&quot; &amp;amp; &quot;\101\101&quot;&lt;/code&gt; 의 결과)로 구성된 문자열 은 Perl에서 잘못된 값이 아닙니다. 당신이 필요합니다 :</target>
        </trans-unit>
        <trans-unit id="8bc24902f3dcba2a5f69700cadd91dc5b3abff7c" translate="yes" xml:space="preserve">
          <source>but a string consisting of two null bytes (the result of &lt;code&gt;&quot;\020\020&quot; &amp;amp; &quot;\101\101&quot;&lt;/code&gt;) is not a false value in Perl. You need:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f5c833e6b8ad19de738251b4d0e198a912780cf" translate="yes" xml:space="preserve">
          <source>but avoids the need to know $cpt's package name.</source>
          <target state="translated">그러나 $ cpt의 패키지 이름을 알 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="14589f2bfb988ba357d07d902945d6c51ace67f6" translate="yes" xml:space="preserve">
          <source>but calling any method that modifies the number directly will result in &lt;b&gt;both&lt;/b&gt; the original and the copy being destroyed:</source>
          <target state="translated">하지만 수정 수가 직접 발생합니다 것을 어떤 방법 호출 &lt;b&gt;모두&lt;/b&gt; 원본과 사본 것은 파괴되고 :</target>
        </trans-unit>
        <trans-unit id="2a43af42a3edda8e818e0b4b4bad6b01d151755a" translate="yes" xml:space="preserve">
          <source>but doesn't spit out extra fields. It's also cheaper not to capture characters if you don't need to.</source>
          <target state="translated">추가 필드를 뱉어 내지 않습니다. 필요하지 않은 경우 캐릭터를 캡처하지 않는 것이 더 저렴합니다.</target>
        </trans-unit>
        <trans-unit id="1517c34ad4cc448c8f1a026222d0e9853c645be4" translate="yes" xml:space="preserve">
          <source>but doesn't spit out the delimiters themselves as extra fields (even though that's the behaviour of &lt;a href=&quot;perlfunc#split&quot;&gt;&quot;split&quot; in perlfunc&lt;/a&gt; when its pattern contains capturing groups). It's also cheaper not to capture characters if you don't need to.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f05e2fea5090f6357ce9a5813f0a47f400272a36" translate="yes" xml:space="preserve">
          <source>but failing on the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15e6be4e78dba9fceaa351875dbb83140728ef88" translate="yes" xml:space="preserve">
          <source>but faster.</source>
          <target state="translated">그러나 더 빠릅니다.</target>
        </trans-unit>
        <trans-unit id="5db5323d8075957d671047bee13d624d6956eafd" translate="yes" xml:space="preserve">
          <source>but in actual fact, you got</source>
          <target state="translated">하지만 실제로는</target>
        </trans-unit>
        <trans-unit id="17fdf913fd722397c7d21c60f0b25c837b358a3c" translate="yes" xml:space="preserve">
          <source>but instead closer to</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9923ef039c4b79c28905e398588d6eb79f30a4c3" translate="yes" xml:space="preserve">
          <source>but instead like this, bearing in mind that this is just a first stab:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f46b2388486d21f0ad260e041f0ddfc6e4c238c0" translate="yes" xml:space="preserve">
          <source>but instead you get:</source>
          <target state="translated">그러나 대신에 당신은 얻는다 :</target>
        </trans-unit>
        <trans-unit id="5f0e7a4318bb45ba256d78b7d932a4b745bc31cf" translate="yes" xml:space="preserve">
          <source>but is more efficient. Returns the number of elements in the array following the completed &lt;a href=&quot;#push-ARRAY%2CLIST&quot;&gt;&lt;code&gt;push&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="670c9eed4ef45780d6a27c66aa6737f774ca7361" translate="yes" xml:space="preserve">
          <source>but is more efficient. Returns the number of elements in the array following the completed &lt;code&gt;&lt;a href=&quot;functions/push&quot;&gt;push&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">그러나 더 효율적입니다. 완료된 &lt;code&gt;&lt;a href=&quot;functions/push&quot;&gt;push&lt;/a&gt;&lt;/code&gt; 다음에있는 배열의 요소 수를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="ea2b46c116a2c87653b1086423551aaba04ef434" translate="yes" xml:space="preserve">
          <source>but is more efficient. Returns the number of elements in the array following the completed &lt;code&gt;&lt;a href=&quot;push&quot;&gt;push&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">그러나 더 효율적입니다. 완료된 &lt;code&gt;&lt;a href=&quot;push&quot;&gt;push&lt;/a&gt;&lt;/code&gt; 다음에있는 배열의 요소 수를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="9d7f5ee2a89754fd0cb3b08ac980e8a4b203554b" translate="yes" xml:space="preserve">
          <source>but not</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="430a12560afed6b52405b428e0d46fec40e28bab" translate="yes" xml:space="preserve">
          <source>but not a mixture of both as in:</source>
          <target state="translated">그러나 다음과 같이 둘 다의 혼합물은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="07b3726c790e16484102349cd362b2dc216a33e9" translate="yes" xml:space="preserve">
          <source>but rather as class methods:</source>
          <target state="translated">오히려 클래스 메소드로 :</target>
        </trans-unit>
        <trans-unit id="9702a21ebfe300cef572f0598fe961666de341c4" translate="yes" xml:space="preserve">
          <source>but remember that there's a startup cost to pay in that case (see above &quot;libperl and Prebinding&quot;).</source>
          <target state="translated">그러나이 경우 지불해야하는 시작 비용이 있음을 기억하십시오 (위의 &quot;libperl 및 사전 바인딩&quot;참조).</target>
        </trans-unit>
        <trans-unit id="c6bc845a7a5bdc5bb3d298cf7a7d62fbdb84e0b7" translate="yes" xml:space="preserve">
          <source>but shorter. Parent directory specifications are stripped from the template itself. The &lt;code&gt;TMPDIR&lt;/code&gt; option is ignored if &lt;code&gt;DIR&lt;/code&gt; is set explicitly. Additionally, &lt;code&gt;TMPDIR&lt;/code&gt; is implied if neither a template nor a directory are supplied.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="acb2133a2923255080591abe8aebb2b94ab97c8d" translate="yes" xml:space="preserve">
          <source>but shorter. Parent directory specifications are stripped from the template itself. The C</source>
          <target state="translated">그러나 더 짧습니다. 상위 디렉토리 스펙은 템플리트 자체에서 제거됩니다. C</target>
        </trans-unit>
        <trans-unit id="62ddbd66e01cf82298f15351b5c586e039d8e26c" translate="yes" xml:space="preserve">
          <source>but since you anticipate localizing this, you write:</source>
          <target state="translated">그러나 이것을 현지화 할 것으로 예상하기 때문에 다음과 같이 씁니다.</target>
        </trans-unit>
        <trans-unit id="2033df8e9b543181e41e825d37dc00babfccc375" translate="yes" xml:space="preserve">
          <source>but that is completely accidental.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f4adbde7584db1a7c8b596705eb7136fbd8e99a5" translate="yes" xml:space="preserve">
          <source>but that makes no difference compared with the -Duse64bitint because of the &lt;code&gt;cc -64&lt;/code&gt; .</source>
          <target state="translated">그러나 &lt;code&gt;cc -64&lt;/code&gt; 때문에 -Duse64bitint와 비교해도 차이가 없습니다 .</target>
        </trans-unit>
        <trans-unit id="79e9388bb002566e7c1bfafce14408283c05c831" translate="yes" xml:space="preserve">
          <source>but that makes no difference compared with the -Duse64bitint because of the &lt;code&gt;cc -64&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23d8d8f376b2cff8835a27af9acf7c580e3a9e81" translate="yes" xml:space="preserve">
          <source>but that may be just luck. Other AntiVirus software may have similar issues.</source>
          <target state="translated">그러나 그것은 운이 좋을 수도 있습니다. 다른 안티 바이러스 소프트웨어에도 비슷한 문제가있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ed3d39f2ff5bb81326e9be2a017f7421168dc990" translate="yes" xml:space="preserve">
          <source>but that will be silently converted into &lt;code&gt;[3,-3pi/4]&lt;/code&gt;, since the modulus must be non-negative (it represents the distance to the origin in the complex plane).</source>
          <target state="translated">그러나 계수는 음이 아니어야하기 때문에 ( &lt;code&gt;[3,-3pi/4]&lt;/code&gt; 로 자동 변환됩니다 (복합 평면에서 원점까지의 거리를 나타냄).</target>
        </trans-unit>
        <trans-unit id="b509dd9066df836513e27436a8d4e7ade7f0b728" translate="yes" xml:space="preserve">
          <source>but the comma is not</source>
          <target state="translated">그러나 쉼표는 아닙니다</target>
        </trans-unit>
        <trans-unit id="9384ff012c073541ee4cf2ad0804fa1a41e628ac" translate="yes" xml:space="preserve">
          <source>but the syntax of Perl doesn't allow this. You need a comma after the string. (Of course, you may consider it a bug that commas between all the constants aren't required, in which case you may feel free to insert commas unless you're using $Term::ANSIColor::AUTORESET or PUSHCOLOR/POPCOLOR.)</source>
          <target state="translated">그러나 Perl의 구문은 이것을 허용하지 않습니다. 문자열 뒤에 쉼표가 필요합니다. (물론, 모든 상수 사이에 쉼표가 필요하지 않은 버그로 간주 될 수 있습니다.이 경우 $ Term :: ANSIColor :: AUTORESET 또는 PUSHCOLOR / POPCOLOR를 사용하지 않으면 쉼표를 삽입해도됩니다.)</target>
        </trans-unit>
        <trans-unit id="f59fd7340224ad23961f9ec29fad42c961b15b81" translate="yes" xml:space="preserve">
          <source>but then $foo no longer contains a glob.</source>
          <target state="translated">그러나 $ foo는 더 이상 glob를 포함하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="aa473e44fe39ed7c06c8dfcc198deb8c0788e03b" translate="yes" xml:space="preserve">
          <source>but then cannot see that &quot;En_US&quot; listed by the above-mentioned commands. You may see things like &quot;en_US.ISO8859-1&quot;, but that isn't the same. In this case, try running under a locale that you can list and which somehow matches what you tried. The rules for matching locale names are a bit vague because standardization is weak in this area. See again the &lt;a href=&quot;#Finding-locales&quot;&gt;&quot;Finding locales&quot;&lt;/a&gt; about general rules.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e375615161c63e7fc29a1c88b265148575b94e3" translate="yes" xml:space="preserve">
          <source>but then cannot see that &quot;En_US&quot; listed by the above-mentioned commands. You may see things like &quot;en_US.ISO8859-1&quot;, but that isn't the same. In this case, try running under a locale that you can list and which somehow matches what you tried. The rules for matching locale names are a bit vague because standardization is weak in this area. See again the &lt;a href=&quot;#Finding-locales&quot;&gt;Finding locales&lt;/a&gt; about general rules.</source>
          <target state="translated">그러나 위에서 언급 한 명령으로 &quot;En_US&quot;가 표시되지 않습니다. &quot;en_US.ISO8859-1&quot;과 같은 것을 볼 수 있지만 동일하지 않습니다. 이 경우, 나열 할 수있는 로케일에서 실행 해보십시오. 이 영역에서는 표준화가 약하기 때문에 로캘 이름 일치 규칙이 약간 모호합니다. 일반 규칙에 대한 &lt;a href=&quot;#Finding-locales&quot;&gt;로케일 찾기를&lt;/a&gt; 다시 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="3cac644780c84e33b8c8e17e1aa72c863bdc551c" translate="yes" xml:space="preserve">
          <source>but then modify it if the current Configure options warrant.</source>
          <target state="translated">그러나 현재 구성 옵션이 필요한 경우이를 수정하십시오.</target>
        </trans-unit>
        <trans-unit id="9bbd6063bd561229cf513f5487e005633f74b476" translate="yes" xml:space="preserve">
          <source>but these will fail:</source>
          <target state="translated">그러나 이것들은 실패 할 것입니다 :</target>
        </trans-unit>
        <trans-unit id="ca81437b80f2ad6457ea481a09d4317a77895103" translate="yes" xml:space="preserve">
          <source>but this can be altered by passing a second argument to &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; Filter::Simple&lt;/code&gt; or &lt;code&gt;FILTER&lt;/code&gt; (just remember: there's</source>
          <target state="translated">그러나 이것은 &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; Filter::Simple&lt;/code&gt; 또는 &lt;code&gt;FILTER&lt;/code&gt; 를 &lt;a href=&quot;../functions/use&quot;&gt;사용&lt;/a&gt; 하기 위해 두 번째 인수를 전달하여 변경할 수 있습니다 (단지 기억하십시오 :</target>
        </trans-unit>
        <trans-unit id="bd8dcfd0c5e2bbf5748ea9ea0c6fdd9fe8c26e08" translate="yes" xml:space="preserve">
          <source>but this can be altered by passing a second argument to &lt;code&gt;use Filter::Simple&lt;/code&gt; or &lt;code&gt;FILTER&lt;/code&gt; (just remember: there's</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e691b4ae28b1162e1f37e88fdb2e7fa3a57809e2" translate="yes" xml:space="preserve">
          <source>but this will not</source>
          <target state="translated">그러나 이것은하지 않습니다</target>
        </trans-unit>
        <trans-unit id="50607a6413ca39fe7073dd9a3b641d9d68b5acf2" translate="yes" xml:space="preserve">
          <source>but translates into</source>
          <target state="translated">그러나로 번역</target>
        </trans-unit>
        <trans-unit id="d32b03d32cae9215bc5e3eedc3a4a9edf0f113a6" translate="yes" xml:space="preserve">
          <source>but under a French locale</source>
          <target state="translated">그러나 프랑스어 로케일에서</target>
        </trans-unit>
        <trans-unit id="9006db57193ae835a928e37c6463a7cbc01420e8" translate="yes" xml:space="preserve">
          <source>but which does not &lt;code&gt;chdir&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="02bc126135ab3f34b2cc7b1c93207acc39efb18e" translate="yes" xml:space="preserve">
          <source>but with &lt;code&gt;extract_delimited&lt;/code&gt; it can be simplified to:</source>
          <target state="translated">그러나 &lt;code&gt;extract_delimited&lt;/code&gt; 를 사용 하면 다음 과 같이 단순화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5a3caba3b95cb830b6cd3bb3694f24d055d2aa69" translate="yes" xml:space="preserve">
          <source>but you have to say</source>
          <target state="translated">하지만 당신은 말해야</target>
        </trans-unit>
        <trans-unit id="790b666b737305903b34914bd264529abbf92746" translate="yes" xml:space="preserve">
          <source>but you should be aware that in this form, the &lt;code&gt;..&lt;/code&gt; operator creates a list of all integers in the range, which can take a lot of memory for large ranges. However, the problem does not occur when using &lt;code&gt;..&lt;/code&gt; within a &lt;code&gt;for&lt;/code&gt; loop, because in that case the range operator is optimized to</source>
          <target state="translated">그러나이 형식에서 &lt;code&gt;..&lt;/code&gt; 연산자는 범위 내의 모든 정수 목록을 작성하므로 넓은 범위의 경우 많은 메모리를 차지할 수 있습니다. 그러나 &lt;code&gt;for&lt;/code&gt; 루프 내에서 &lt;code&gt;..&lt;/code&gt; 를 사용할 때 문제가 발생하지 않습니다 . 이 경우 범위 연산자는</target>
        </trans-unit>
        <trans-unit id="920f4cbc6f3b3ccfd1fe8ce2d2eca6336d87c327" translate="yes" xml:space="preserve">
          <source>but your system might have more.</source>
          <target state="translated">그러나 시스템에 더 많은 것이있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0a0df778ce40c92b4130fd3cc1bc732e0dcd8097" translate="yes" xml:space="preserve">
          <source>but your version of perl is compiled without perlio, and this form of open is not supported.</source>
          <target state="translated">그러나 perl 버전은 perlio없이 컴파일되며이 형식의 개방은 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f6cf3e61369618c4d062082f34a8e4eb6950efaa" translate="yes" xml:space="preserve">
          <source>but, because &lt;code&gt;&quot;*&quot;&lt;/code&gt; is higher precedence than named operators:</source>
          <target state="translated">그러나 &lt;code&gt;&quot;*&quot;&lt;/code&gt; 가 명명 된 연산자보다 우선 순위가 높기 때문에 :</target>
        </trans-unit>
        <trans-unit id="2e58b63df0271d9d91bb2fb25b1d674542ccb1b2" translate="yes" xml:space="preserve">
          <source>bxor()</source>
          <target state="translated">bxor()</target>
        </trans-unit>
        <trans-unit id="408158643ed564c72fa0921826f8294d71ccbf7c" translate="yes" xml:space="preserve">
          <source>by</source>
          <target state="translated">by</target>
        </trans-unit>
        <trans-unit id="b562123d16a87ef1dd2d50e459ddac28857a828c" translate="yes" xml:space="preserve">
          <source>by &lt;code&gt;BEGIN{ $/ = &quot;\0digits&quot;; }&lt;/code&gt; .</source>
          <target state="translated">에 의해 &lt;code&gt;BEGIN{ $/ = &quot;\0digits&quot;; }&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="693c89736c2070fd31c626a46716305d2dcd07f7" translate="yes" xml:space="preserve">
          <source>by &lt;code&gt;BEGIN{ $/ = &quot;\0digits&quot;; }&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d7f03736d7aee983a0f27b66b3cd7bd23ae58bf" translate="yes" xml:space="preserve">
          <source>by Andreas Koenig &amp;lt;&lt;code&gt;k@anna.in-berlin.de&lt;/code&gt; &amp;gt; and Tim Bunce.</source>
          <target state="translated">Andreas Koenig &amp;lt; &lt;code&gt;k@anna.in-berlin.de&lt;/code&gt; &amp;gt; 및 Tim Bunce.</target>
        </trans-unit>
        <trans-unit id="c23116b526d815e85bf1c020a76bc213b62b8265" translate="yes" xml:space="preserve">
          <source>by Andreas Koenig &amp;lt;&lt;code&gt;k@anna.in-berlin.de&lt;/code&gt;&amp;gt; and Tim Bunce.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58b9be2f90b4b5e0f72bcc70fc011d637b555279" translate="yes" xml:space="preserve">
          <source>by Jeffrey Friedl (</source>
          <target state="translated">제프리 프리들 (Jeffrey Friedl)</target>
        </trans-unit>
        <trans-unit id="75c037b29723680ee8b90b4bf48df2df3306d348" translate="yes" xml:space="preserve">
          <source>by Jeffrey Friedl (&lt;a href=&quot;http://oreilly.com/catalog/9780596528126/&quot;&gt;http://oreilly.com/catalog/9780596528126/&lt;/a&gt;) for a thorough grounding and reference on the topic.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7d25fddceaf2bede4f0c1508fc9756858ff0f82" translate="yes" xml:space="preserve">
          <source>by Jeffrey Friedl (published by O'Reilly, ISBN 1556592-257-3).</source>
          <target state="translated">Jeffrey Friedl (O'Reilly 출판, ISBN 1556592-257-3).</target>
        </trans-unit>
        <trans-unit id="01bcdce954a667cee1cea208aa989626d65f08eb" translate="yes" xml:space="preserve">
          <source>by Jeffrey Friedl gives a wonderful discussion of this and other efficiency issues.</source>
          <target state="translated">Jeffrey Friedl이이 문제와 다른 효율성 문제에 대해 멋진 토론을합니다.</target>
        </trans-unit>
        <trans-unit id="292b840af5da5995eb868afee859b139a4198e22" translate="yes" xml:space="preserve">
          <source>by Jeffrey Friedl, published by O'Reilly and Associates.</source>
          <target state="translated">O'Reilly and Associates가 출판 한 Jeffrey Friedl</target>
        </trans-unit>
        <trans-unit id="a030535d3a4b6473025f29bd648142b0bfd7bded" translate="yes" xml:space="preserve">
          <source>by Jeffrey Friedl. He explains how the regular expressions engine works and why some patterns are surprisingly inefficient. Once you understand how perl applies regular expressions, you can tune them for individual situations.</source>
          <target state="translated">제프리 프리들 그는 정규 표현식 엔진의 작동 방식과 일부 패턴이 놀랍도록 비효율적 인 이유를 설명합니다. 펄이 정규 표현식을 적용하는 방법을 이해하면 개별 상황에 맞게 조정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0662c80629deb9e56e36b3c8498a287fee6d6d19" translate="yes" xml:space="preserve">
          <source>by Sean M. Burke and Jordan Lachler</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa3b42830418e798c60825381fd17fa38f07279b" translate="yes" xml:space="preserve">
          <source>by W. Richard Stevens (published by Prentice-Hall). Most books on networking address the subject from the perspective of a C programmer; translation to Perl is left as an exercise for the reader.</source>
          <target state="translated">W. Richard Stevens (Prentice-Hall 출판). 네트워킹에 관한 대부분의 책은 C 프로그래머의 관점에서 주제를 다루고 있습니다. Perl 로의 번역은 독자를위한 연습으로 남아 있습니다.</target>
        </trans-unit>
        <trans-unit id="aa39ccc1df65d58c55c7ad4408539c603519c108" translate="yes" xml:space="preserve">
          <source>by Yves Orton, 2006.</source>
          <target state="translated">이브 오튼, 2006.</target>
        </trans-unit>
        <trans-unit id="3e3c60c9a79bc01108d963cab52a79402baacea3" translate="yes" xml:space="preserve">
          <source>by compiling using gcc with the flag &lt;code&gt;-pg&lt;/code&gt; . Either edit</source>
          <target state="translated">&lt;code&gt;-pg&lt;/code&gt; 플래그로 gcc를 사용하여 컴파일 합니다. 편집하다</target>
        </trans-unit>
        <trans-unit id="19f7896cab4219f100a419456e0bdd3ba2ec060f" translate="yes" xml:space="preserve">
          <source>by compiling using gcc with the flag &lt;code&gt;-pg&lt;/code&gt;. Either edit</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5d400126bc4b2b2a0be4cb6f504f4a728dab5e6" translate="yes" xml:space="preserve">
          <source>by compiling using gcc with the flags &lt;code&gt;-fprofile-arcs -ftest-coverage&lt;/code&gt; . Either edit</source>
          <target state="translated">플래그 &lt;code&gt;-fprofile-arcs -ftest-coverage&lt;/code&gt; 와 함께 gcc를 사용하여 컴파일 합니다. 편집하다</target>
        </trans-unit>
        <trans-unit id="f8928b51e9787b60afbcaada877671cd348377c0" translate="yes" xml:space="preserve">
          <source>by compiling using gcc with the flags &lt;code&gt;-fprofile-arcs -ftest-coverage&lt;/code&gt;. Either edit</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed704a971a09b89d0355af9ed7f590b8d16afef1" translate="yes" xml:space="preserve">
          <source>by default</source>
          <target state="translated">기본적으로</target>
        </trans-unit>
        <trans-unit id="b995af8a25b522b801201b66c682fc8351af8011" translate="yes" xml:space="preserve">
          <source>by default the object is constructed as if &lt;code&gt;tempfile&lt;/code&gt; was called without options, but with the additional behaviour that the temporary file is removed by the object destructor if UNLINK is set to true (the default).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e935cb2d694a730a179e0fab14594701e7b71b6" translate="yes" xml:space="preserve">
          <source>by default the object is constructed as if C</source>
          <target state="translated">기본적으로 객체는 C처럼 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="76e18cd7b5438dfa50021afe47ddf6798a2380ea" translate="yes" xml:space="preserve">
          <source>by default, and this file is read by the &lt;code&gt;dprofpp&lt;/code&gt; program, which is already installed as part of the &lt;code&gt;Devel::DProf&lt;/code&gt; distribution. If you call &lt;code&gt;dprofpp&lt;/code&gt; with no options, it will read the</source>
          <target state="translated">기본적으로이 파일은 &lt;code&gt;dprofpp&lt;/code&gt; 프로그램에서 읽습니다.이 프로그램은 이미 &lt;code&gt;Devel::DProf&lt;/code&gt; 배포의 일부로 설치되어 있습니다. 옵션없이 &lt;code&gt;dprofpp&lt;/code&gt; 를 호출 하면</target>
        </trans-unit>
        <trans-unit id="ab0866dc7f2a672bc7b6be003ac55641a8c5066d" translate="yes" xml:space="preserve">
          <source>by default. Human readable reports can be generated from here by using the supplied &lt;code&gt;nytprofhtml&lt;/code&gt; (HTML output) and &lt;code&gt;nytprofcsv&lt;/code&gt; (CSV output) programs. We've used the Unix system &lt;code&gt;html2text&lt;/code&gt; utility to convert the</source>
          <target state="translated">기본적으로. 제공된 &lt;code&gt;nytprofhtml&lt;/code&gt; (HTML 출력) 및 &lt;code&gt;nytprofcsv&lt;/code&gt; (CSV 출력) 프로그램 을 사용하여 여기에서 사람이 읽을 수있는 보고서를 생성 할 수 있습니다 . 우리는 유닉스 시스템 &lt;code&gt;html2text&lt;/code&gt; 유틸리티를 사용하여</target>
        </trans-unit>
        <trans-unit id="0869a111f636cdf936dab450ab2b6d19f6144956" translate="yes" xml:space="preserve">
          <source>by doing something like:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76d6fc20656e3c76019aabc723d52e70642bd78d" translate="yes" xml:space="preserve">
          <source>by endianness</source>
          <target state="translated">엔디안으로</target>
        </trans-unit>
        <trans-unit id="b98507aaeb9a1c77075f94408b252b18efe599de" translate="yes" xml:space="preserve">
          <source>by just using the name of the program).</source>
          <target state="translated">프로그램 이름을 사용하여).</target>
        </trans-unit>
        <trans-unit id="2c5bb516b1987dabf813c98e4515eda07d81aaa5" translate="yes" xml:space="preserve">
          <source>by name</source>
          <target state="translated">이름으로</target>
        </trans-unit>
        <trans-unit id="5e3f04f999831235b9b402a22b7e7de4ce80d90f" translate="yes" xml:space="preserve">
          <source>by size</source>
          <target state="translated">크기별</target>
        </trans-unit>
        <trans-unit id="d5d90792858f3b6ce0d3e628c5cd82bf536aa2e2" translate="yes" xml:space="preserve">
          <source>by the DynaLoader when the shared object is loaded. See BSLOADLIBS below.</source>
          <target state="translated">공유 객체가로드 될 때 DynaLoader에 의해 아래 BSLOADLIBS를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="ac25d943ca16593ccd5b638578371920d418f826" translate="yes" xml:space="preserve">
          <source>by the Perl interpreter itself.</source>
          <target state="translated">Perl 통역사 자체에 의해.</target>
        </trans-unit>
        <trans-unit id="c2a3a0641c2dba021dc10a286962de22e15df633" translate="yes" xml:space="preserve">
          <source>by the Perl interpreter itself. This attribute's default value is &lt;b&gt;TRUE&lt;/b&gt;. If you want to search only specific directories, set $self-&amp;gt;inc(0) before calling $inc-&amp;gt;survey or $inc-&amp;gt;find.</source>
          <target state="translated">Perl 통역사 자체에 의해. 이 속성의 기본값은 &lt;b&gt;TRUE&lt;/b&gt; 입니다. 특정 디렉토리 만 검색하려면 $ inc-&amp;gt; survey 또는 $ inc-&amp;gt; find를 호출하기 전에 $ self-&amp;gt; inc (0)을 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="1899511ea754deb578535a8d92e9165fcbc88e82" translate="yes" xml:space="preserve">
          <source>by the ld command when the perl binary is linked with the extension library. See EXTRALIBS below.</source>
          <target state="translated">perl 바이너리가 확장 라이브러리와 링크 될 때 ld 명령에 의해. 아래 EXTRALIBS를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="b5f079545f5d4621415bdb75f7dcd595e58fae02" translate="yes" xml:space="preserve">
          <source>by the ld command when the shared object is built/linked. See LDLOADLIBS below.</source>
          <target state="translated">공유 객체가 빌드 / 링크 될 때 ld 명령에 의해. 아래의 LDLOADLIBS를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="7b420b941a02cf1568114573e2381fb3ec4ef20a" translate="yes" xml:space="preserve">
          <source>by the main thread (thread ID = 0) of a script. Therefore, setting up signal handlers in threads for purposes other than &lt;a href=&quot;#THREAD-SIGNALLING&quot;&gt;&quot;THREAD SIGNALLING&quot;&lt;/a&gt; as documented above will not accomplish what is intended.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb53580843b764dd08d059a4ffde7b32707736ab" translate="yes" xml:space="preserve">
          <source>by the main thread (thread ID = 0) of a script. Therefore, setting up signal handlers in threads for purposes other than &lt;a href=&quot;#THREAD-SIGNALLING&quot;&gt;THREAD SIGNALLING&lt;/a&gt; as documented above will not accomplish what is intended.</source>
          <target state="translated">스크립트의 메인 스레드 (스레드 ID = 0)에 의해 따라서 위에서 설명한 &lt;a href=&quot;#THREAD-SIGNALLING&quot;&gt;THREAD SIGNALING&lt;/a&gt; 이외의 목적으로 스레드에서 신호 처리기를 설정 하면 의도 한 것을 달성 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="08b3b402ddb7fb46a261bf00b77d547af5513e6c" translate="yes" xml:space="preserve">
          <source>by their very definition. It is of course possible to write a nearly instantaneous program, but it's not going to do very much, here's a very efficient one:</source>
          <target state="translated">그들의 정의에 의해. 물론 거의 즉각적인 프로그램을 작성하는 것도 가능하지만 그다지 많은 일을하지는 않을 것입니다. 여기에는 매우 효율적인 프로그램이 있습니다 :</target>
        </trans-unit>
        <trans-unit id="cd5f3427a5b91cc9194daa4a03c9e849e100f09d" translate="yes" xml:space="preserve">
          <source>by this:</source>
          <target state="translated">이로 인해:</target>
        </trans-unit>
        <trans-unit id="90078d2f7170e62d296450a6cf5226698468ce9b" translate="yes" xml:space="preserve">
          <source>by using calls like this one;</source>
          <target state="translated">이와 같은 호출을 사용함으로써;</target>
        </trans-unit>
        <trans-unit id="cda65ed6f996204ff01e4d76e80bf0eb135783c9" translate="yes" xml:space="preserve">
          <source>by-category</source>
          <target state="translated">by-category</target>
        </trans-unit>
        <trans-unit id="52d31c8a6d5578bdb0ba6c7bacaa72d3064e7f98" translate="yes" xml:space="preserve">
          <source>by-module</source>
          <target state="translated">by-module</target>
        </trans-unit>
        <trans-unit id="8cf1783fa99f62ca581f6fe8f3cd66b0f9ab9fc3" translate="yes" xml:space="preserve">
          <source>byte</source>
          <target state="translated">byte</target>
        </trans-unit>
        <trans-unit id="721b9babe5628970cc09024b3a1a9b932d9e0924" translate="yes" xml:space="preserve">
          <source>byte order marks</source>
          <target state="translated">바이트 순서 표시</target>
        </trans-unit>
        <trans-unit id="f0a787a9f181c667c66e67359a5c84c3f31a86d0" translate="yes" xml:space="preserve">
          <source>bytecode</source>
          <target state="translated">bytecode</target>
        </trans-unit>
        <trans-unit id="beb025390e6b44933a6bf16e1bc9c499925f957e" translate="yes" xml:space="preserve">
          <source>byteorder.U</source>
          <target state="translated">byteorder.U</target>
        </trans-unit>
        <trans-unit id="daf529a73101c2be626b99fc6938163e7a27620b" translate="yes" xml:space="preserve">
          <source>bytes</source>
          <target state="translated">bytes</target>
        </trans-unit>
        <trans-unit id="704a9eedbf658e779eedc2c2e635afc1745b9587" translate="yes" xml:space="preserve">
          <source>bytes - Perl pragma to expose the individual bytes of characters</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="305428c11e612a57e6dca43980d6a15186d3eedd" translate="yes" xml:space="preserve">
          <source>bytes - Perl pragma to force byte semantics rather than character semantics</source>
          <target state="translated">bytes-문자 의미가 아닌 바이트 의미를 강제하는 Perl pragma</target>
        </trans-unit>
        <trans-unit id="74e04eb86371917242f5f42e7825ff63f37fa8b7" translate="yes" xml:space="preserve">
          <source>bytes of data from</source>
          <target state="translated">의 데이터 바이트</target>
        </trans-unit>
        <trans-unit id="a6a3035438f8082d9bbe01b48538b14cd1cebf95" translate="yes" xml:space="preserve">
          <source>bytes of data into</source>
          <target state="translated">바이트의 데이터</target>
        </trans-unit>
        <trans-unit id="d285f82774e0d86e76e8e37aedf166837530e229" translate="yes" xml:space="preserve">
          <source>bytes of the character. The UTF8 flag is turned off. Returns nothing.</source>
          <target state="translated">문자의 바이트 UTF8 플래그가 꺼져 있습니다. 아무것도 반환하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a8d7a1f72563dfcee3b9751f0008a7ef3b69a283" translate="yes" xml:space="preserve">
          <source>bytes::substr() does not work as an lvalue().</source>
          <target state="translated">bytes :: substr ()은 lvalue ()로 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f937c564cb36928d98113040f718bc6dd5d3ca0b" translate="yes" xml:space="preserve">
          <source>bytes_cmp_utf8</source>
          <target state="translated">bytes_cmp_utf8</target>
        </trans-unit>
        <trans-unit id="03e7ed3ca3790aecfc45563afee0cb2ff5bd7a7f" translate="yes" xml:space="preserve">
          <source>bytes_from_utf8</source>
          <target state="translated">bytes_from_utf8</target>
        </trans-unit>
        <trans-unit id="5b3e650260dc94f6fb70b63ba8bfd7647d736688" translate="yes" xml:space="preserve">
          <source>bytes_read ()</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="192879142f96e8cb16867dcd093a7b74a3469850" translate="yes" xml:space="preserve">
          <source>bytes_to_utf8</source>
          <target state="translated">bytes_to_utf8</target>
        </trans-unit>
        <trans-unit id="84e0021d4ef7f34f6245f64e5b4fd6ad47f36e1e" translate="yes" xml:space="preserve">
          <source>bzero()</source>
          <target state="translated">bzero()</target>
        </trans-unit>
        <trans-unit id="18966dcea477ed087e87037c4255cd180be7d19e" translate="yes" xml:space="preserve">
          <source>bzip2</source>
          <target state="translated">bzip2</target>
        </trans-unit>
        <trans-unit id="8dddd252e4acf3054b159272da897404d0ef9a10" translate="yes" xml:space="preserve">
          <source>bzip2 $input_filename_or_reference =&amp;gt; $output_filename_or_reference [, OPTS]</source>
          <target state="translated">bzip2 $ input_filename_or_reference =&amp;gt; $ output_filename_or_reference [, OPTS]</target>
        </trans-unit>
        <trans-unit id="84a516841ba77a5b4648de2cd0dfcb30ea46dbb4" translate="yes" xml:space="preserve">
          <source>c</source>
          <target state="translated">c</target>
        </trans-unit>
        <trans-unit id="fd1b715eedecae251e0ef96fd721ea1904207f3b" translate="yes" xml:space="preserve">
          <source>c [line|sub]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9bf518bb1d83f8f8b94f6a75e535c0324b999e9e" translate="yes" xml:space="preserve">
          <source>c2ph</source>
          <target state="translated">c2ph</target>
        </trans-unit>
        <trans-unit id="aab64cc4582b2a7ac50ea4d29f8baf504eb3ffd7" translate="yes" xml:space="preserve">
          <source>c2ph, pstruct - Dump C structures as generated from &lt;code&gt;cc -g -S&lt;/code&gt; stabs</source>
          <target state="translated">c2ph, pstruct- &lt;code&gt;cc -g -S&lt;/code&gt; stab 에서 생성 된 C 구조 덤프</target>
        </trans-unit>
        <trans-unit id="16b4ae8ef0e46ee8dd3b2cbaefcb0f61f3bb0863" translate="yes" xml:space="preserve">
          <source>cBOOL</source>
          <target state="translated">cBOOL</target>
        </trans-unit>
        <trans-unit id="ed059a6df813b519fdb6d15158f569b8baa86ab5" translate="yes" xml:space="preserve">
          <source>c_o (o)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd027e134354087b398512762bc4fd137c292919" translate="yes" xml:space="preserve">
          <source>c_o (override)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b03592806efabfeeb709f5a70a7c172669b00538" translate="yes" xml:space="preserve">
          <source>cache</source>
          <target state="translated">cache</target>
        </trans-unit>
        <trans-unit id="4d2e4f51a884a410929c5ee17aaacc9fab869689" translate="yes" xml:space="preserve">
          <source>cache_metadata</source>
          <target state="translated">cache_metadata</target>
        </trans-unit>
        <trans-unit id="d85b8f213b4403a79accd9308a80dbb19a384193" translate="yes" xml:space="preserve">
          <source>cachedir</source>
          <target state="translated">cachedir</target>
        </trans-unit>
        <trans-unit id="3bd773e86fd5c86c7cdc6f0cd2327b9dc2862c38" translate="yes" xml:space="preserve">
          <source>cacheout EXPR</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c6318679b9ed5ee78a1c37484d918ff77ac07ef" translate="yes" xml:space="preserve">
          <source>cacheout MODE, EXPR</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ecce20b9ec4855087467bfaecc68195be1813592" translate="yes" xml:space="preserve">
          <source>caches, one for scalar values and one for list values. When your function is called in scalar context, its return value is cached in one hash, and when your function is called in list context, its value is cached in the other hash. You can control the caching behavior of both contexts independently with these options.</source>
          <target state="translated">하나는 스칼라 값이고 다른 하나는리스트 값입니다. 스칼라 컨텍스트에서 함수를 호출하면 반환 값이 한 해시에 캐시되고 함수가 목록 컨텍스트에서 호출되면 해당 값이 다른 해시에 캐시됩니다. 이 옵션을 사용하여 두 컨텍스트의 캐싱 동작을 독립적으로 제어 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="10bf64fff8ad28b9eceb40ae05ccd8d500f3edce" translate="yes" xml:space="preserve">
          <source>calcrpn VARIABLE { EXPRESSION }</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6066fec73bb15293850c8fc3846983a936a7356a" translate="yes" xml:space="preserve">
          <source>calculated</source>
          <target state="translated">calculated</target>
        </trans-unit>
        <trans-unit id="0d68cbf5b8fc5792e2b012765c8d99152d921657" translate="yes" xml:space="preserve">
          <source>calculator indeed.</source>
          <target state="translated">실제로 계산기.</target>
        </trans-unit>
        <trans-unit id="bc8d8647b02deea0ab3e715c220d041ee78cc19d" translate="yes" xml:space="preserve">
          <source>call</source>
          <target state="translated">call</target>
        </trans-unit>
        <trans-unit id="d26793c374d42f2321b52b9ab8c04fd33c02f47c" translate="yes" xml:space="preserve">
          <source>call &lt;code&gt;iota&lt;/code&gt; in scalar context and cache the result, but the &lt;code&gt;SCALAR_CACHE =&amp;gt; 'MERGE'&lt;/code&gt; option says not to do that, but to use the cache list-context value instead. But it cannot return a list of seven elements in a scalar context. In this case &lt;code&gt;$i7&lt;/code&gt; will receive the &lt;b&gt;first element&lt;/b&gt; of the cached list value, namely 7.</source>
          <target state="translated">스칼라 컨텍스트에서 &lt;code&gt;iota&lt;/code&gt; 를 호출 하고 결과를 캐시하지만 &lt;code&gt;SCALAR_CACHE =&amp;gt; 'MERGE'&lt;/code&gt; 옵션은이를 수행하지 말고 대신 캐시 목록 컨텍스트 값을 사용하라는 메시지를 표시합니다. 그러나 스칼라 컨텍스트에서 7 개의 요소 목록을 리턴 할 수 없습니다. 이 경우 &lt;code&gt;$i7&lt;/code&gt; 은 캐시 된 목록 값 의 &lt;b&gt;첫 번째 요소&lt;/b&gt; 인 7을받습니다.</target>
        </trans-unit>
        <trans-unit id="aea66ab9134e8035b60e502b44c9255902019bb8" translate="yes" xml:space="preserve">
          <source>call a method without void context. Use &lt;a href=&quot;autodie&quot;&gt;autodie&lt;/a&gt; instead if you need to be able to disable autodying/Fatal behaviour for a small block of code.</source>
          <target state="translated">빈 공간이없는 메소드를 호출하십시오. 작은 코드 블록에 대해 자동 염색 / 치명적 동작을 비활성화해야하는 경우 대신 &lt;a href=&quot;autodie&quot;&gt;autodie&lt;/a&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="a35b8b477980036b6f41e918ae640a3c562367e0" translate="yes" xml:space="preserve">
          <source>call an overridden &lt;code&gt;isa&lt;/code&gt; method in any class. Instead, use &lt;code&gt;reftype&lt;/code&gt; from &lt;a href=&quot;Scalar::Util&quot;&gt;Scalar::Util&lt;/a&gt; for the first case:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07ee532dfc7a5c9512fdcf2b4ab1a03d4a1d1bd8" translate="yes" xml:space="preserve">
          <source>call an overridden &lt;code&gt;isa&lt;/code&gt; method in any class. Instead, use &lt;code&gt;reftype&lt;/code&gt; from &lt;a href=&quot;scalar/util&quot;&gt;Scalar::Util&lt;/a&gt; for the first case:</source>
          <target state="translated">모든 클래스에서 재정의 된 &lt;code&gt;isa&lt;/code&gt; 메소드를 호출하십시오 . 대신, 사용 &lt;code&gt;reftype&lt;/code&gt; 에서 &lt;a href=&quot;scalar/util&quot;&gt;스칼라 :: 백분율&lt;/a&gt; 첫 번째 경우에 :</target>
        </trans-unit>
        <trans-unit id="75de3cdc4f7d6eeec6a5710a33b9b4b76a965466" translate="yes" xml:space="preserve">
          <source>call by reference</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4eaf4cc023dc61b8a07f4a1a444503dad24b7c33" translate="yes" xml:space="preserve">
          <source>call by value</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a301a28fa31b59f5762db2f0e4dae07ecf49b7f" translate="yes" xml:space="preserve">
          <source>call in call_Subtract reads:</source>
          <target state="translated">call_Subtract의 호출은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="09af65b77373b270115d65e0cc4152963620d518" translate="yes" xml:space="preserve">
          <source>call them indirectly:</source>
          <target state="translated">간접적으로 호출하십시오.</target>
        </trans-unit>
        <trans-unit id="bea45b65dbd679ba81c088f23290abf3a9afb91e" translate="yes" xml:space="preserve">
          <source>call to &lt;code&gt;filter_read&lt;/code&gt; or &lt;code&gt;filter_read_exact&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;filter_read&lt;/code&gt; 또는 &lt;code&gt;filter_read_exact&lt;/code&gt; 를 호출 하십시오 .</target>
        </trans-unit>
        <trans-unit id="65e4aaaab79c0d55c17e54353edfbb0030f9345a" translate="yes" xml:space="preserve">
          <source>call to &lt;code&gt;filter_read&lt;/code&gt; or &lt;code&gt;filter_read_exact&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c949d2de33459ca2d9973d9bf5448c9e6bdb1f6" translate="yes" xml:space="preserve">
          <source>call-back unit so that long doubles can be formatted without loss of precision.</source>
          <target state="translated">콜백 (back-back) 단위로 긴 복식을 정밀도 손실없이 포맷 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="01eeb3a3ce36a45d2ed8b640d6a38cc855a0aea9" translate="yes" xml:space="preserve">
          <source>call.</source>
          <target state="translated">call.</target>
        </trans-unit>
        <trans-unit id="a0a7cf13bc05b8452a04f1e2d381330099f264f0" translate="yes" xml:space="preserve">
          <source>call. For example:</source>
          <target state="translated">요구. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="fa4e53e51ebd0d0df17edd40ee676dc6179cfe87" translate="yes" xml:space="preserve">
          <source>call_*</source>
          <target state="translated">call_*</target>
        </trans-unit>
        <trans-unit id="5558c19f08af12e8462cd902d73078dd2305080f" translate="yes" xml:space="preserve">
          <source>call_AddSubScalar</source>
          <target state="translated">call_AddSubScalar</target>
        </trans-unit>
        <trans-unit id="90ff1a8ade713598c1646d49e8bd8e0ab53cf48c" translate="yes" xml:space="preserve">
          <source>call_AddSubtract</source>
          <target state="translated">call_AddSubtract</target>
        </trans-unit>
        <trans-unit id="2854630a13713d11a8b6885e7f79056447c62688" translate="yes" xml:space="preserve">
          <source>call_LeftString</source>
          <target state="translated">call_LeftString</target>
        </trans-unit>
        <trans-unit id="18631234b2a7bd26d823fa54e3df7188c8e989c8" translate="yes" xml:space="preserve">
          <source>call_Subtract</source>
          <target state="translated">call_Subtract</target>
        </trans-unit>
        <trans-unit id="d4a0b92fad95fc628341a5a87ec98cabb9a02a7d" translate="yes" xml:space="preserve">
          <source>call_argv</source>
          <target state="translated">call_argv</target>
        </trans-unit>
        <trans-unit id="b86ca5a7c01a8263e69196692db525f9c3e43f10" translate="yes" xml:space="preserve">
          <source>call_atexit</source>
          <target state="translated">call_atexit</target>
        </trans-unit>
        <trans-unit id="d3dedbd48597465617b49ff3add69e35b2273df4" translate="yes" xml:space="preserve">
          <source>call_list</source>
          <target state="translated">call_list</target>
        </trans-unit>
        <trans-unit id="6f635f2379199699013477fde9934d1b25b2ed69" translate="yes" xml:space="preserve">
          <source>call_method</source>
          <target state="translated">call_method</target>
        </trans-unit>
        <trans-unit id="c9b67be4160b43f537f38ed300d8d7d67ad56af8" translate="yes" xml:space="preserve">
          <source>call_pv</source>
          <target state="translated">call_pv</target>
        </trans-unit>
        <trans-unit id="8cecf04d9c1fddec48927de0af20f7d816c7d167" translate="yes" xml:space="preserve">
          <source>call_sv</source>
          <target state="translated">call_sv</target>
        </trans-unit>
        <trans-unit id="b4d5b37bf7a986c138ede89e0806f366b5cb1830" translate="yes" xml:space="preserve">
          <source>callback</source>
          <target state="translated">callback</target>
        </trans-unit>
        <trans-unit id="4e8127df1a4b3dbfb5b327173cfb08b8676ac454" translate="yes" xml:space="preserve">
          <source>callbacks</source>
          <target state="translated">callbacks</target>
        </trans-unit>
        <trans-unit id="970eeb47b2d091dc3fee38f7ecd0e8ec3352f34f" translate="yes" xml:space="preserve">
          <source>called</source>
          <target state="translated">called</target>
        </trans-unit>
        <trans-unit id="5b73d33ca4d0ef4a3df6b67b837e769d4cb0af6e" translate="yes" xml:space="preserve">
          <source>called &lt;code&gt;$some_pack::secret_version&lt;/code&gt; or anything; it's just $secret_version, unqualified and unqualifiable.</source>
          <target state="translated">라는 &lt;code&gt;$some_pack::secret_version&lt;/code&gt; 또는 아무것도; 그것은 단지 $ secret_version이며, 자격이 없으며 자격이 없습니다.</target>
        </trans-unit>
        <trans-unit id="1fb8b294c8dd06c5ddbfda59a1996397e5dff5ee" translate="yes" xml:space="preserve">
          <source>called for &lt;code&gt;=pod&lt;/code&gt; paragraphs.</source>
          <target state="translated">요구 &lt;code&gt;=pod&lt;/code&gt; 단락.</target>
        </trans-unit>
        <trans-unit id="4dca004e14e54a193da4bef6ddcce901570f9219" translate="yes" xml:space="preserve">
          <source>called immediately, and if Perl is using the system's &lt;code&gt;stdio&lt;/code&gt; library that library may restart the &lt;code&gt;&lt;a href=&quot;functions/read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; without returning to Perl to give it a chance to call the %SIG handler. If this happens on your system the solution is to use the &lt;code&gt;:perlio&lt;/code&gt; layer to do IO--at least on those handles that you want to be able to break into with signals. (The &lt;code&gt;:perlio&lt;/code&gt; layer checks the signal flags and calls %SIG handlers before resuming IO operation.)</source>
          <target state="translated">Perl이 시스템의 &lt;code&gt;stdio&lt;/code&gt; 라이브러리를 사용하는 경우 해당 라이브러리는 Perl로 돌아 가지 않고 &lt;code&gt;&lt;a href=&quot;functions/read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; 를 다시 시작 하여 % SIG 핸들러를 호출 할 수 있습니다. 이것이 시스템에서 발생하면 해결책은 &lt;code&gt;:perlio&lt;/code&gt; 레이어 를 사용하여 최소한 신호로 침입 할 수있는 핸들에서 IO를 수행하는 것입니다. ( &lt;code&gt;:perlio&lt;/code&gt; . 층 검사 신호 플래그 및 IO 동작을 재개하기 전에 호출 %의 SIG 핸들러)</target>
        </trans-unit>
        <trans-unit id="567f34b564f06580ebd9b48b199dfcf6a3094212" translate="yes" xml:space="preserve">
          <source>called immediately, and if Perl is using the system's &lt;code&gt;stdio&lt;/code&gt; library that library may restart the &lt;code&gt;read&lt;/code&gt; without returning to Perl to give it a chance to call the %SIG handler. If this happens on your system the solution is to use the &lt;code&gt;:perlio&lt;/code&gt; layer to do IO--at least on those handles that you want to be able to break into with signals. (The &lt;code&gt;:perlio&lt;/code&gt; layer checks the signal flags and calls %SIG handlers before resuming IO operation.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14dc69de2a1e6087529f02b62fd2888c90d741d3" translate="yes" xml:space="preserve">
          <source>caller</source>
          <target state="translated">caller</target>
        </trans-unit>
        <trans-unit id="a5f0d61e9b1c1b14054070cd5efad882cc10c593" translate="yes" xml:space="preserve">
          <source>caller EXPR</source>
          <target state="translated">발신자 EXPR</target>
        </trans-unit>
        <trans-unit id="7aba60747c4150b59b47e08abdd47c33cc7a6995" translate="yes" xml:space="preserve">
          <source>caller's scope</source>
          <target state="translated">발신자의 범위</target>
        </trans-unit>
        <trans-unit id="3ed7d1b856121d61369245edc58343a8a3706cee" translate="yes" xml:space="preserve">
          <source>caller_cx</source>
          <target state="translated">caller_cx</target>
        </trans-unit>
        <trans-unit id="d98fd2afc75d1c2e5e5747cc1f883a2419a27b8d" translate="yes" xml:space="preserve">
          <source>calling &lt;code&gt;CX_POP&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b31614a7ba28b398fab5be5b1f0abace81483c66" translate="yes" xml:space="preserve">
          <source>calling pod2usage, Pod::Usage will fail even on robust platforms. Don't do that. Or use &lt;a href=&quot;../findbin&quot;&gt;FindBin&lt;/a&gt; to locate the script:</source>
          <target state="translated">Pod :: Usage는 pod2usage를 호출하면 강력한 플랫폼에서도 실패합니다. 하지마 또는 &lt;a href=&quot;../findbin&quot;&gt;FindBin&lt;/a&gt; 을 사용 하여 스크립트를 찾으십시오.</target>
        </trans-unit>
        <trans-unit id="3748b809994db82e1012a20918e083abe4806a36" translate="yes" xml:space="preserve">
          <source>calling pod2usage, Pod::Usage will fail even on robust platforms. Don't do that. Or use &lt;a href=&quot;findbin&quot;&gt;FindBin&lt;/a&gt; to locate the script:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d6364ba311876adcb810e8ac5a5c3d73f55fa43" translate="yes" xml:space="preserve">
          <source>calloc</source>
          <target state="translated">calloc</target>
        </trans-unit>
        <trans-unit id="51b6cb253fc406fc1b9780eaa1fb645eb82e631d" translate="yes" xml:space="preserve">
          <source>calls</source>
          <target state="translated">calls</target>
        </trans-unit>
        <trans-unit id="4a782bf6f0127a0ab6a9b55b344eb864af06d6d9" translate="yes" xml:space="preserve">
          <source>calls &amp;amp;{&quot;${module}::bootstrap&quot;} to bootstrap the module (actually it uses the function reference returned by dl_install_xsub for speed)</source>
          <target state="translated">&amp;amp; { &quot;$ {module} :: bootstrap&quot;}을 호출하여 모듈을 부트 스트랩합니다 (실제로는 속도를 위해 dl_install_xsub에 의해 리턴 된 함수 참조를 사용함)</target>
        </trans-unit>
        <trans-unit id="8068c49fd178ebbbb1181c7892ff798980347f20" translate="yes" xml:space="preserve">
          <source>calls (e.g., using &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system()&lt;/a&gt;&lt;/code&gt; or back-ticks) made from threads use the environment variable settings from the</source>
          <target state="translated">스레드에서 작성된 호출 (예 : &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system()&lt;/a&gt;&lt;/code&gt; 또는 역 틱 사용)은 환경 변수 설정을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="e83aed67789fc3b96f90b751136395ce2ef41d6b" translate="yes" xml:space="preserve">
          <source>calls (e.g., using &lt;code&gt;system()&lt;/code&gt; or back-ticks) made from threads use the environment variable settings from the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23927d0aa967922575276101593ab186ac76a894" translate="yes" xml:space="preserve">
          <source>calls dl_find_symbol() for &quot;boot_$module&quot;</source>
          <target state="translated">&quot;boot_ $ module&quot;에 대해 dl_find_symbol ()을 호출합니다.</target>
        </trans-unit>
        <trans-unit id="df5598c9096a42a3629f35c7aa2f39e91fa80505" translate="yes" xml:space="preserve">
          <source>calls dl_install_xsub() to install it as &quot;${module}::bootstrap&quot;</source>
          <target state="translated">dl_install_xsub ()를 호출하여 &quot;$ {module} :: bootstrap&quot;으로 설치</target>
        </trans-unit>
        <trans-unit id="eeddbfb4bab615284264705345a27ee10700ba4b" translate="yes" xml:space="preserve">
          <source>calls dl_load_file() to load the file</source>
          <target state="translated">파일을로드하기 위해 dl_load_file ()을 호출합니다.</target>
        </trans-unit>
        <trans-unit id="60dd082e722533c84eb7e433f3fa4582d921f83b" translate="yes" xml:space="preserve">
          <source>calls dl_load_flags() to determine how to load the file.</source>
          <target state="translated">dl_load_flags ()를 호출하여 파일로드 방법을 결정합니다.</target>
        </trans-unit>
        <trans-unit id="c1e90b552179a525781d61e90b26ebd803e604f3" translate="yes" xml:space="preserve">
          <source>calls dl_undef_symbols() and warns if any symbols are undefined</source>
          <target state="translated">dl_undef_symbols ()를 호출하고 심볼이 정의되지 않은 경우 경고</target>
        </trans-unit>
        <trans-unit id="03b5ee56e23671d3878c7bc1765e42ba79aa3e0b" translate="yes" xml:space="preserve">
          <source>calls like the following</source>
          <target state="translated">다음과 같은 호출</target>
        </trans-unit>
        <trans-unit id="f02e2d24dc9d64bcb7041c2fc782098c29ed69dd" translate="yes" xml:space="preserve">
          <source>calls made by that thread.</source>
          <target state="translated">해당 스레드에 의해 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="2dcbf5bd7246d954454bd3f3804dead54471c5e2" translate="yes" xml:space="preserve">
          <source>calls the Perl subroutine specified by the C string stored in the &lt;code&gt;subname&lt;/code&gt; parameter. It also takes the usual &lt;code&gt;flags&lt;/code&gt; parameter. The final parameter, &lt;code&gt;argv&lt;/code&gt; , consists of a NULL-terminated list of C strings to be passed as parameters to the Perl subroutine. See</source>
          <target state="translated">&lt;code&gt;subname&lt;/code&gt; 매개 변수에 저장된 C 문자열로 지정된 Perl 서브 루틴을 호출합니다 . 일반적인 &lt;code&gt;flags&lt;/code&gt; 매개 변수도 사용합니다. 최종 매개 변수 &lt;code&gt;argv&lt;/code&gt; 는 Perl 서브 루틴에 매개 변수로 전달 될 NULL로 끝나는 C 문자열 목록으로 구성됩니다. 보다</target>
        </trans-unit>
        <trans-unit id="733d70ba4dcf7a96d02346548b017098743dd710" translate="yes" xml:space="preserve">
          <source>calls the Perl subroutine specified by the C string stored in the &lt;code&gt;subname&lt;/code&gt; parameter. It also takes the usual &lt;code&gt;flags&lt;/code&gt; parameter. The final parameter, &lt;code&gt;argv&lt;/code&gt;, consists of a NULL-terminated list of C strings to be passed as parameters to the Perl subroutine. See &lt;a href=&quot;#Using-call_argv&quot;&gt;&quot;Using call_argv&quot;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df5b12037f7721d936298a1dbbb871e6381c2da1" translate="yes" xml:space="preserve">
          <source>camel_flea</source>
          <target state="translated">camel_flea</target>
        </trans-unit>
        <trans-unit id="7e9219a0599eae1d9601883f894b4fbe60870586" translate="yes" xml:space="preserve">
          <source>can</source>
          <target state="translated">can</target>
        </trans-unit>
        <trans-unit id="699d91f476fc57b066fa45249291eed227b9fc79" translate="yes" xml:space="preserve">
          <source>can also be &lt;code&gt;I&lt;/code&gt; which is the same as &lt;code&gt;C&lt;/code&gt; but is a special case for dotted uppercase I and dotless lowercase i:</source>
          <target state="translated">&lt;code&gt;C&lt;/code&gt; 와 동일 하지만 점이있는 대문자 I 및 ​​점이없는 소문자 i에 대한 특별한 경우 인 &lt;code&gt;I&lt;/code&gt; 일 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e4fb56cea3d4b5b887c8b15f28fd462013d373d9" translate="yes" xml:space="preserve">
          <source>can be &lt;code&gt;@&lt;/code&gt; or &lt;code&gt;%&lt;/code&gt; to specify that the option is list or a hash valued. This is only needed when the destination for the option value is not otherwise specified. It should be omitted when not needed.</source>
          <target state="translated">옵션을 list 또는 해시 값으로 지정하려면 &lt;code&gt;@&lt;/code&gt; 또는 &lt;code&gt;%&lt;/code&gt; 일 수 있습니다 . 옵션 값의 대상이 달리 지정되지 않은 경우에만 필요합니다. 필요하지 않은 경우 생략해야합니다.</target>
        </trans-unit>
        <trans-unit id="b6cda2d35a3885df30bda9a688568f274c6b3e94" translate="yes" xml:space="preserve">
          <source>can be any combination of &lt;code&gt;'a'&lt;/code&gt;, &lt;code&gt;'aa'&lt;/code&gt;, &lt;code&gt;'d'&lt;/code&gt;, &lt;code&gt;'i'&lt;/code&gt;, &lt;code&gt;'l'&lt;/code&gt;, &lt;code&gt;'m'&lt;/code&gt;, &lt;code&gt;'n'&lt;/code&gt;, &lt;code&gt;'p'&lt;/code&gt;, &lt;code&gt;'s'&lt;/code&gt;, &lt;code&gt;'u'&lt;/code&gt;, &lt;code&gt;'x'&lt;/code&gt;, and/or &lt;code&gt;'xx'&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="24b476e0c0907463a17bc1306e027e47233cc399" translate="yes" xml:space="preserve">
          <source>can be any expression that evaluates to a name accepted by &lt;code&gt;\N{...}&lt;/code&gt; under the &lt;a href=&quot;#DESCRIPTION&quot;&gt;:full option&lt;/a&gt; to &lt;code&gt;charnames&lt;/code&gt; . In addition, any other options for the controlling &lt;code&gt;&quot;use charnames&quot;&lt;/code&gt; in the same scope apply, like &lt;code&gt;:loose&lt;/code&gt; or any &lt;a href=&quot;#DESCRIPTION&quot;&gt;script list, :short option&lt;/a&gt;, or &lt;a href=&quot;#CUSTOM-ALIASES&quot;&gt;custom aliases&lt;/a&gt; you may have defined.</source>
          <target state="translated">표현식이 될 수 수락 이름으로 평가 &lt;code&gt;\N{...}&lt;/code&gt; 세 이하 &lt;a href=&quot;#DESCRIPTION&quot;&gt;: 풀 옵션&lt;/a&gt; 에 &lt;code&gt;charnames&lt;/code&gt; . 또한 동일한 범위에서 &lt;code&gt;&quot;use charnames&quot;&lt;/code&gt; 을 제어하기위한 다른 옵션 ( 예 &lt;code&gt;:loose&lt;/code&gt; 또는 &lt;a href=&quot;#DESCRIPTION&quot;&gt;스크립트 목록, : short 옵션&lt;/a&gt; 또는 &lt;a href=&quot;#CUSTOM-ALIASES&quot;&gt;사용자 정의 별칭)&lt;/a&gt; 이 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="8207bfa2f86eef13b5e02a5d9219333c3795e5f4" translate="yes" xml:space="preserve">
          <source>can be any expression that evaluates to a name accepted by &lt;code&gt;\N{...}&lt;/code&gt; under the &lt;a href=&quot;#DESCRIPTION&quot;&gt;&lt;code&gt;:full&lt;/code&gt; option&lt;/a&gt; to &lt;code&gt;charnames&lt;/code&gt;. In addition, any other options for the controlling &lt;code&gt;&quot;use charnames&quot;&lt;/code&gt; in the same scope apply, like &lt;code&gt;:loose&lt;/code&gt; or any &lt;a href=&quot;#DESCRIPTION&quot;&gt;script list, &lt;code&gt;:short&lt;/code&gt; option&lt;/a&gt;, or &lt;a href=&quot;#CUSTOM-ALIASES&quot;&gt;custom aliases&lt;/a&gt; you may have defined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b34e29f857c70f78af80d100b29730e6cdc1149" translate="yes" xml:space="preserve">
          <source>can be any value which is valid as an assignment to an element of &lt;code&gt;%SIG&lt;/code&gt; . See &lt;a href=&quot;perlvar&quot;&gt;perlvar&lt;/a&gt; for examples of handler functions.</source>
          <target state="translated">&lt;code&gt;%SIG&lt;/code&gt; 의 요소에 대한 지정으로 유효한 값이 될 수 있습니다 . 핸들러 함수의 예는 &lt;a href=&quot;perlvar&quot;&gt;perlvar&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="60cf43db09eb171fc68adc4b27dc80a73ec633fc" translate="yes" xml:space="preserve">
          <source>can be any value which is valid as an assignment to an element of &lt;code&gt;%SIG&lt;/code&gt;. See &lt;a href=&quot;perlvar&quot;&gt;perlvar&lt;/a&gt; for examples of handler functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="461c0b19fe19c96b45408c038271b2fb35f66553" translate="yes" xml:space="preserve">
          <source>can be compressed with &lt;code&gt;/c:max&lt;/code&gt; (the bug only appears when there is a fixup in the last 6 bytes of a page (?); since the tiny executables are much smaller than a page, the bug will not hit). Do not compress &lt;code&gt;perl_.exe&lt;/code&gt; - it would not work under DOS.</source>
          <target state="translated">&lt;code&gt;/c:max&lt;/code&gt; 로 압축 할 수 있습니다 (버그는 페이지의 마지막 6 바이트에 수정이있을 때만 나타납니다 (?). 작은 실행 파일이 페이지보다 훨씬 작기 때문에 버그가 발생하지 않습니다). &lt;code&gt;perl_.exe&lt;/code&gt; 를 압축하지 마십시오 . DOS에서는 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="446662c59650e49f63dcfb6d7d27d374899b2abe" translate="yes" xml:space="preserve">
          <source>can be constructed using &lt;code&gt;pod2latex&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;pod2latex&lt;/code&gt; 를 사용하여 구성 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c098826fe346971c1bf153f18ba6624f6c2f2531" translate="yes" xml:space="preserve">
          <source>can be constructed using &lt;code&gt;pod2latex&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ce1fab0a60d1b9694716d9d022c1765f4978b16" translate="yes" xml:space="preserve">
          <source>can be either a canonical name or an alias. For encoding names and aliases, see &lt;a href=&quot;#Defining-Aliases&quot;&gt;&quot;Defining Aliases&quot;&lt;/a&gt;. For CHECK, see &lt;a href=&quot;#Handling-Malformed-Data&quot;&gt;&quot;Handling Malformed Data&quot;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb09ee0719d48bbcaac94dec85ce8d07308135f2" translate="yes" xml:space="preserve">
          <source>can be either a canonical name or an alias. For encoding names and aliases, see &lt;a href=&quot;#Defining-Aliases&quot;&gt;&quot;Defining Aliases&quot;&lt;/a&gt;; for</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="794d8b0a9b686ba34ee696408ef6df66c3a413de" translate="yes" xml:space="preserve">
          <source>can be either a canonical name or an alias. For encoding names and aliases, see &lt;a href=&quot;#Defining-Aliases&quot;&gt;Defining Aliases&lt;/a&gt;. For CHECK, see &lt;a href=&quot;#Handling-Malformed-Data&quot;&gt;Handling Malformed Data&lt;/a&gt;.</source>
          <target state="translated">정식 이름 또는 별칭 일 수 있습니다. 인코딩 이름 및 별명은 별명 &lt;a href=&quot;#Defining-Aliases&quot;&gt;정의를&lt;/a&gt; 참조하십시오 . 점검은 &lt;a href=&quot;#Handling-Malformed-Data&quot;&gt;조작 된 데이터 처리를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="8fd5395b7f9e578475974e9b86e078fb0ec61ac4" translate="yes" xml:space="preserve">
          <source>can be either a canonical name or an alias. For encoding names and aliases, see &lt;a href=&quot;#Defining-Aliases&quot;&gt;Defining Aliases&lt;/a&gt;; for</source>
          <target state="translated">정식 이름 또는 별칭 일 수 있습니다. 인코딩 이름 및 별명은 별명 &lt;a href=&quot;#Defining-Aliases&quot;&gt;정의를&lt;/a&gt; 참조하십시오 . ...에 대한</target>
        </trans-unit>
        <trans-unit id="e77ae9195619436cf623136bc0de83a787a047da" translate="yes" xml:space="preserve">
          <source>can be misparsed by pre-5.10.0 Perls as a non-terminated search pattern.</source>
          <target state="translated">종료되지 않은 검색 패턴으로 5.10.0 이전 Perls에 의해 잘못 구문 분석 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="102e5cd9960ccd33f4c8886eae28cc9c5d186cd5" translate="yes" xml:space="preserve">
          <source>can be represented by any of the strings &quot;Y&quot;, &quot;Yes&quot;, &quot;T&quot;, or &quot;True&quot;; and the General Category &quot;Punctuation&quot; by that string, or &quot;Punct&quot;, or simply &quot;P&quot;.</source>
          <target state="translated">&quot;Y&quot;, &quot;Yes&quot;, &quot;T&quot;또는 &quot;True&quot;문자열 중 하나로 표시 될 수 있습니다. 해당 문자열 또는 &quot;Punct&quot;또는 &quot;P&quot;로 일반 범주 &quot;Punctuation&quot;이 있습니다.</target>
        </trans-unit>
        <trans-unit id="ab1e1922e94c24432c2394888ae6becca02bff46" translate="yes" xml:space="preserve">
          <source>can be rewritten as the much more efficient</source>
          <target state="translated">훨씬 더 효율적으로 다시 쓸 수 있습니다</target>
        </trans-unit>
        <trans-unit id="6980df54f269ebb5f12cf9f66876a22b962b6463" translate="yes" xml:space="preserve">
          <source>can be specified as either a POSIX termios/SYSV termio speeds (where 9600 equals 9600) or an old DSD-style speed ( where 13 equals 9600).</source>
          <target state="translated">POSIX termios / SYSV termio speeds (9600은 9600) 또는 오래된 DSD 스타일 속도 (13은 9600)로 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="12f83e8f257938d5d877e46ff7b777e6d3e81ab3" translate="yes" xml:space="preserve">
          <source>can be specified for single elements by prepending dotted-form, i.e. &quot;com.example.my_application.my_property&quot;. Default namespace for META.yml is probably &quot;org.cpan.meta_author&quot; or something. Precedent for this is Apple's Carbon namespaces, I think.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a0b30925918e47087c2c3fd8ec3511807439d9a" translate="yes" xml:space="preserve">
          <source>can be supplied as true to force the loop body to be enclosed in its own scope.</source>
          <target state="translated">루프 본체를 자체 범위로 묶으려면 true로 제공 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2ec6c241c08eaa0e7cd65d17fc2d47fc2d922f6d" translate="yes" xml:space="preserve">
          <source>can be used any place a string (char *) is required:</source>
          <target state="translated">문자열 (char *)이 필요한 어느 곳에서나 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="18d75e94060e4bbccaab013dcc7609826491453a" translate="yes" xml:space="preserve">
          <source>can be used as a single statement, as in</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d8acc4b4615821e09fe517afa1e537f21aba062d" translate="yes" xml:space="preserve">
          <source>can be used as an alias for</source>
          <target state="translated">에 대한 별칭으로 사용할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="c83ef2aed21667cc47266aebbf22a19737c73278" translate="yes" xml:space="preserve">
          <source>can be used to initialize a new $x with the value of the old $x, and the expression</source>
          <target state="translated">이전 $ x의 값과 표현식으로 새로운 $ x를 초기화하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="32fde68489fc1913d62a482e299a8d35e0bda2c3" translate="yes" xml:space="preserve">
          <source>can be used to pass parameters to the methods which implement that part of the Makefile. Parameters are specified as a hash ref but are passed to the method as a hash.</source>
          <target state="translated">Makefile의 해당 부분을 구현하는 메소드에 매개 변수를 전달하는 데 사용할 수 있습니다. 매개 변수는 해시 참조로 지정되지만 해시로 메소드에 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="e020f4df52e0881b17e0bbdbefc5b62b50ac0eaa" translate="yes" xml:space="preserve">
          <source>can be used to test the locales on your system. Setting the environment variable &lt;code&gt;PERL_DEBUG_FULL_TEST&lt;/code&gt; to 1 will cause it to output detailed results. For example, on Linux, you could say</source>
          <target state="translated">시스템의 로케일을 테스트하는 데 사용할 수 있습니다. 환경 변수 &lt;code&gt;PERL_DEBUG_FULL_TEST&lt;/code&gt; 를 1로 설정하면 자세한 결과가 출력됩니다. 예를 들어 Linux에서는 다음과 같이 말할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1e41481e91bc4f56b11d91901bc53050dcf02bb4" translate="yes" xml:space="preserve">
          <source>can have several forms. The first form is simply an integer in parentheses &lt;code&gt;(&lt;i&gt;integer&lt;/i&gt;)&lt;/code&gt;. It is true if the corresponding backreference &lt;code&gt;\&lt;i&gt;integer&lt;/i&gt;&lt;/code&gt; matched earlier in the regexp. The same thing can be done with a name associated with a capture group, written as &lt;code&gt;(&amp;lt;&lt;i&gt;name&lt;/i&gt;&amp;gt;)&lt;/code&gt; or &lt;code&gt;('&lt;i&gt;name&lt;/i&gt;')&lt;/code&gt;. The second form is a bare zero-width assertion &lt;code&gt;(?...)&lt;/code&gt;, either a lookahead, a lookbehind, or a code assertion (discussed in the next section). The third set of forms provides tests that return true if the expression is executed within a recursion (&lt;code&gt;(R)&lt;/code&gt;) or is being called from some capturing group, referenced either by number (&lt;code&gt;(R1)&lt;/code&gt;, &lt;code&gt;(R2)&lt;/code&gt;,...) or by name (&lt;code&gt;(R&amp;amp;&lt;i&gt;name&lt;/i&gt;)&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec38106a7a2c4aeab519526f1fc64d639439ebe7" translate="yes" xml:space="preserve">
          <source>can now be called via the</source>
          <target state="translated">통해 통해 호출 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="073fc766b5f28ba9a5e826b65821aea6ad51da11" translate="yes" xml:space="preserve">
          <source>can refer either to a &quot;=head</source>
          <target state="translated">&quot;= 헤드를 참조 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f3e4c81c1862fa7e83f6209d035bc6b6a4c37811" translate="yes" xml:space="preserve">
          <source>can tell if it has been sourced already.</source>
          <target state="translated">이미 공급되었는지 알 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5bac399344eb2e104a9bc2cee9e2a722464b5047" translate="yes" xml:space="preserve">
          <source>can't</source>
          <target state="translated">can't</target>
        </trans-unit>
        <trans-unit id="aa8e4bd605454a2c4879074789b2c3bc3125ee62" translate="yes" xml:space="preserve">
          <source>can't speak proper Swahili,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a8a22e86ac17d30098c489cf550a7db6fd390cef" translate="yes" xml:space="preserve">
          <source>can($method)</source>
          <target state="translated">can($method)</target>
        </trans-unit>
        <trans-unit id="c8d25cbb91ed447dcaf3128a97e65bed4cab3d61" translate="yes" xml:space="preserve">
          <source>can_color</source>
          <target state="translated">can_color</target>
        </trans-unit>
        <trans-unit id="98058934126afcffdf3e1dca698b1e5933052270" translate="yes" xml:space="preserve">
          <source>can_dep_space</source>
          <target state="translated">can_dep_space</target>
        </trans-unit>
        <trans-unit id="0fe020b6183685ee95126629cfb433de7cb72737" translate="yes" xml:space="preserve">
          <source>can_handle</source>
          <target state="translated">can_handle</target>
        </trans-unit>
        <trans-unit id="9ff99e6b258032c4317631c5af7fa37d23ee6128" translate="yes" xml:space="preserve">
          <source>can_inet6 ()</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f1d8c600ccae6e37aa7bd1365c835614b2fdb93f" translate="yes" xml:space="preserve">
          <source>can_load_xs</source>
          <target state="translated">can_load_xs</target>
        </trans-unit>
        <trans-unit id="a209b8bb928c99b509b5b18a38b94f9d4a4de75f" translate="yes" xml:space="preserve">
          <source>can_read ( [ TIMEOUT ] )</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b48ac28ef2fa55ed9118eab541eb96b568c95c9" translate="yes" xml:space="preserve">
          <source>can_redirect_error</source>
          <target state="translated">can_redirect_error</target>
        </trans-unit>
        <trans-unit id="60f8214968771a1ddbf7e4ae68c3192535834642" translate="yes" xml:space="preserve">
          <source>can_run</source>
          <target state="translated">can_run</target>
        </trans-unit>
        <trans-unit id="4974b129614a62f685deb6d6e736e73cd5ee3ff9" translate="yes" xml:space="preserve">
          <source>can_ssl</source>
          <target state="translated">can_ssl</target>
        </trans-unit>
        <trans-unit id="5d377c8ff7c3eee7f6758a8308590bcdde3be6db" translate="yes" xml:space="preserve">
          <source>can_ssl ()</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="367cd53ab1517714b34de2f623eb8288be911cb9" translate="yes" xml:space="preserve">
          <source>can_write ( [ TIMEOUT ] )</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ec09fd5087f20f8f1487c0620fa4aae9bf6bd67" translate="yes" xml:space="preserve">
          <source>cancelling</source>
          <target state="translated">cancelling</target>
        </trans-unit>
        <trans-unit id="fd59deab53fb970cb6db2203923398c18970cf2b" translate="yes" xml:space="preserve">
          <source>candelete</source>
          <target state="translated">candelete</target>
        </trans-unit>
        <trans-unit id="7d85f050f65feb60efdb328e99782129924b16b6" translate="yes" xml:space="preserve">
          <source>cando</source>
          <target state="translated">cando</target>
        </trans-unit>
        <trans-unit id="6ef80072f39071d4118a6e7890e209d4dd07e504" translate="yes" xml:space="preserve">
          <source>cannot</source>
          <target state="translated">cannot</target>
        </trans-unit>
        <trans-unit id="04f7fc0aca9ad2b7aa0a289811be4f44339c3fa2" translate="yes" xml:space="preserve">
          <source>cannot be computed for all arguments because that would mean dividing by zero or taking logarithm of zero. These situations cause fatal runtime errors looking like this</source>
          <target state="translated">0으로 나누거나 로그를 0으로하는 것을 의미하므로 모든 인수에 대해 계산할 수 없습니다. 이러한 상황은 다음과 같은 치명적인 런타임 오류를 발생시킵니다</target>
        </trans-unit>
        <trans-unit id="07567c7d826aa63adc1a5eeccb8e1d221eb1a7bd" translate="yes" xml:space="preserve">
          <source>cannot be included, use</source>
          <target state="translated">포함 할 수 없습니다</target>
        </trans-unit>
        <trans-unit id="8204e50dcc76473893509dee81c209dd37748814" translate="yes" xml:space="preserve">
          <source>cannot be started directly using the above API. One needs a way to surround the doublequotes in some other quoting construction, necessarily having an extra non-Unixish shell in between.</source>
          <target state="translated">위 API를 사용하여 직접 시작할 수 없습니다. 다른 인용 구조에서 이중 인용 부호를 둘러싸는 방법이 필요하며, 그 사이에 여분의 비 유닉스 쉘이 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="d465e617560f92dce8bc51283aa8145e0c60c3e0" translate="yes" xml:space="preserve">
          <source>cannot chdir to [dir]: [errmsg]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3eaf667c9627ed2da90cfd5b6016c8e8a472866f" translate="yes" xml:space="preserve">
          <source>cannot chdir to [parent-dir] from [child-dir]: [errmsg], aborting. (FATAL)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a648d2f9903006477a495b4f91540d082ead7a5d" translate="yes" xml:space="preserve">
          <source>cannot fetch initial working directory: [errmsg]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6baf2d107957d5d2e553bf06c6534a12bcb1fc9" translate="yes" xml:space="preserve">
          <source>cannot find the needed</source>
          <target state="translated">필요한 것을 찾을 수 없습니다</target>
        </trans-unit>
        <trans-unit id="433ee83dd6e407f89126bb331d94555ce0d19f8b" translate="yes" xml:space="preserve">
          <source>cannot lead to &lt;code&gt;$b&lt;/code&gt; 's implementation of &lt;code&gt;*=&lt;/code&gt; being called, even if &lt;code&gt;$a&lt;/code&gt; is a scalar. (It can, however, generate a call to &lt;code&gt;$b&lt;/code&gt; 's method for &lt;code&gt;*&lt;/code&gt; ).</source>
          <target state="translated">&lt;code&gt;$a&lt;/code&gt; 가 스칼라 인 경우에도 &lt;code&gt;$b&lt;/code&gt; 의 &lt;code&gt;*=&lt;/code&gt; 구현을 호출 할 수 없습니다 . 그러나 &lt;code&gt;*&lt;/code&gt; 에 대한 &lt;code&gt;$b&lt;/code&gt; 의 메소드에 대한 호출을 생성 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="dd83e8b01f7f1fdc40dc495641566b805a24ec8b" translate="yes" xml:space="preserve">
          <source>cannot lead to &lt;code&gt;$b&lt;/code&gt;'s implementation of &lt;code&gt;*=&lt;/code&gt; being called, even if &lt;code&gt;$a&lt;/code&gt; is a scalar. (It can, however, generate a call to &lt;code&gt;$b&lt;/code&gt;'s method for &lt;code&gt;*&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d00e654937d383aa5e2544bd77f867714ad3d36" translate="yes" xml:space="preserve">
          <source>cannot make directory [dir] read+writeable: [errmsg]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1be69f68d73504ec012a9565b517c1b9463d71d9" translate="yes" xml:space="preserve">
          <source>cannot make directory [dir] writeable: [errmsg]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81a96ddf0f3954fa35593f7a585ed92c51a6e0a8" translate="yes" xml:space="preserve">
          <source>cannot make file [file] writeable: [errmsg]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da6cb26a84743c26c2ecbc4e48c4f28d88688590" translate="yes" xml:space="preserve">
          <source>cannot read [dir]: [errmsg]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="734f296c40d30b798622604be653765061795fd3" translate="yes" xml:space="preserve">
          <source>cannot remove [dir] when cwd is [dir]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ec7ffef6d7cd44a57a78e26c5eaf76b66bfae3f" translate="yes" xml:space="preserve">
          <source>cannot remove directory [dir]: [errmsg]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e345543a332529780084d3ceb40a4026183a4991" translate="yes" xml:space="preserve">
          <source>cannot reset chmod [dir]: [errmsg]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="453c3f2e83c134316656c22f4c107642acbd13f3" translate="yes" xml:space="preserve">
          <source>cannot restore permissions of [dir] to [0nnn]: [errmsg]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8313e84895b3827500b52620d5dec8879f8527e1" translate="yes" xml:space="preserve">
          <source>cannot restore permissions of [file] to [0nnn]: [errmsg]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b765111dee8c0530b99aca3ce0a503ef4efb9566" translate="yes" xml:space="preserve">
          <source>cannot stat initial working directory: [errmsg]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bab473ba2fe577a36d713ea25bc77c8bebd3ee28" translate="yes" xml:space="preserve">
          <source>cannot stat prior working directory [dir]: [errmsg], aborting. (FATAL)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e500880cc85cfa9a8a7c6e8d0548f13fbfe1fa4" translate="yes" xml:space="preserve">
          <source>cannot unlink file [file]: [errmsg]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58fe73ac67cf177f6dd33b4fe44d6bfd2952c07b" translate="yes" xml:space="preserve">
          <source>canonical</source>
          <target state="translated">canonical</target>
        </trans-unit>
        <trans-unit id="2d94d751b1a8bd191ec353d650d073728f718240" translate="yes" xml:space="preserve">
          <source>canonical names differ from that of the Encode module, they are always aliased if it ever be implemented. So you can safely tell if a given encoding is implemented or not just by passing the canonical name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f76cb80deae2e48cea0f820942e7707714f7a6a" translate="yes" xml:space="preserve">
          <source>canonname =&amp;gt; STRING</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="780d41095195df1101716119e3f1ab79a3891cda" translate="yes" xml:space="preserve">
          <source>canonpath</source>
          <target state="translated">canonpath</target>
        </trans-unit>
        <trans-unit id="b81343c3e8001b1c279a7cda21a2aed404cce598" translate="yes" xml:space="preserve">
          <source>canonpath (override)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c492234ccf4bfd72a658695d15dd5d1dd2ba8216" translate="yes" xml:space="preserve">
          <source>canonpath()</source>
          <target state="translated">canonpath()</target>
        </trans-unit>
        <trans-unit id="474cadb40e32b4119becfffe47b4bbfdaea3845f" translate="yes" xml:space="preserve">
          <source>capa ()</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c862423fef5374d23f7b23f924739b16a86439e3" translate="yes" xml:space="preserve">
          <source>capabilities ()</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="865f1ff7a475134380e8c1ade9c9257a3b2d3d4b" translate="yes" xml:space="preserve">
          <source>capabilities, such as the less program on Unix.</source>
          <target state="translated">유닉스에서 적은 프로그램과 같은 기능.</target>
        </trans-unit>
        <trans-unit id="24d36117a06589995877d65c61dd6ec645ccc49e" translate="yes" xml:space="preserve">
          <source>capabilities:</source>
          <target state="translated">capabilities:</target>
        </trans-unit>
        <trans-unit id="38b38f7a14c5d7d2a37fab0c0cc0bf70e3b650a6" translate="yes" xml:space="preserve">
          <source>capitalizes the letters &lt;code&gt;&quot;h&quot;&lt;/code&gt;, &lt;code&gt;&quot;i&quot;&lt;/code&gt;, &lt;code&gt;&quot;j&quot;&lt;/code&gt;, and &lt;code&gt;&quot;k&quot;&lt;/code&gt; and nothing else, no matter what the platform's character set is. In contrast, all of</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dfd6c29bb2543664179870bac088e53dbfe84e7f" translate="yes" xml:space="preserve">
          <source>capture variables</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2effdf32146d25bb2c901b1f072ba016c03522e0" translate="yes" xml:space="preserve">
          <source>capturing</source>
          <target state="translated">capturing</target>
        </trans-unit>
        <trans-unit id="cf3298ba24c6c4e554b7f8b9a3569ba924ef42f8" translate="yes" xml:space="preserve">
          <source>capturing groups, or else</source>
          <target state="translated">캡처 그룹 또는 기타</target>
        </trans-unit>
        <trans-unit id="27da055de62be5ea00a18b05686dc722ef504503" translate="yes" xml:space="preserve">
          <source>capturing parentheses will not be penalized. So avoid &lt;code&gt;$&amp;amp;&lt;/code&gt; , &lt;code&gt;$'&lt;/code&gt; , and &lt;code&gt;$`&lt;/code&gt; if you can, but if you can't (and some algorithms really appreciate them), once you've used them once, use them at will, because you've already paid the price.</source>
          <target state="translated">캡처 괄호는 처벌되지 않습니다. 따라서 가능하면 &lt;code&gt;$&amp;amp;&lt;/code&gt; , &lt;code&gt;$'&lt;/code&gt; 및 &lt;code&gt;$`&lt;/code&gt; 를 피 하십시오.하지만 할 수 없다면 (그리고 일부 알고리즘은 정말로 감사합니다), 일단 사용하면 마음대로 사용하십시오. 가격.</target>
        </trans-unit>
        <trans-unit id="042d4d8c4f82b7f6053e165e17cd35daf91cfdb5" translate="yes" xml:space="preserve">
          <source>capturing parentheses will not be penalized. So avoid &lt;code&gt;$&amp;amp;&lt;/code&gt;, &lt;code&gt;$'&lt;/code&gt;, and &lt;code&gt;$`&lt;/code&gt; if you can, but if you can't (and some algorithms really appreciate them), once you've used them once, use them at will, because you've already paid the price.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4fecdfe9582b11c15b0bff91598fe22c64541102" translate="yes" xml:space="preserve">
          <source>careful with this routine, as it short-circuits some of Perl's fundamental security features. XS module authors should not use this function unless they fully understand all the implications of unconditionally untainting the value. Untainting should be done in the standard perl fashion, via a carefully crafted regexp, rather than directly untainting variables.</source>
          <target state="translated">Perl의 기본 보안 기능 중 일부를 단락 시키므로이 루틴에주의하십시오. XS 모듈 작성자는 무조건 값을 유지하는 모든 의미를 완전히 이해하지 않는 한이 기능을 사용하지 않아야합니다. 오염 제거는 변수를 직접 보존하는 대신 신중하게 조작 된 정규식을 통해 표준 펄 방식으로 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="9afce1c402e5811bfb49ee8c05126552d7bb1c09" translate="yes" xml:space="preserve">
          <source>cargo cult</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96fdff65c5b9cc9c4dc303017fb373906a527a06" translate="yes" xml:space="preserve">
          <source>carp</source>
          <target state="translated">carp</target>
        </trans-unit>
        <trans-unit id="6cbdf6406b5f415f12805b8f898c3a5ea1b00238" translate="yes" xml:space="preserve">
          <source>cartesian_to_cylindrical</source>
          <target state="translated">cartesian_to_cylindrical</target>
        </trans-unit>
        <trans-unit id="7eefea0f102e55a1a442b0832d3a887167be55c6" translate="yes" xml:space="preserve">
          <source>cartesian_to_spherical</source>
          <target state="translated">cartesian_to_spherical</target>
        </trans-unit>
        <trans-unit id="6406510c31e0c9925733c7f21414bf6428333ed2" translate="yes" xml:space="preserve">
          <source>case</source>
          <target state="translated">case</target>
        </trans-unit>
        <trans-unit id="acfdc4b2f9d00e51d0b86829e77cfae27b4f24d2" translate="yes" xml:space="preserve">
          <source>case 2:</source>
          <target state="translated">사례 2 :</target>
        </trans-unit>
        <trans-unit id="ed78773f1951f45134453a07a9d4294e79a113b9" translate="yes" xml:space="preserve">
          <source>case scenario, but is worse than most. Most languages have simpler inflection systems; for example, in English or Swahili, there are generally no more than two possible inflected forms for a given noun (&quot;error/errors&quot;; &quot;kosa/makosa&quot;), and the rules for producing these forms are fairly simple -- or at least, simple rules can be formulated that work for most words, and you can then treat the exceptions as just &quot;irregular&quot;, at least relative to your ad hoc rules. A simpler inflection system (simpler rules, fewer forms) means that design decisions are less crucial to maintaining sanity, whereas the same decisions could incur overhead-versus-scalability problems in languages like Russian. It may</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ed4fff79f00f04280fca592028b62646ceebcb8" translate="yes" xml:space="preserve">
          <source>case_tolerant</source>
          <target state="translated">case_tolerant</target>
        </trans-unit>
        <trans-unit id="b83f8f59f1383d72553121432f37dd666722076d" translate="yes" xml:space="preserve">
          <source>case_tolerant (override)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58570d43acfee774a2f7f4a43b5132f35fa8bae0" translate="yes" xml:space="preserve">
          <source>case_tolerant_process</source>
          <target state="translated">case_tolerant_process</target>
        </trans-unit>
        <trans-unit id="63493395b85afc8cc3a7e5cbc6cba06b259565f2" translate="yes" xml:space="preserve">
          <source>casefold()</source>
          <target state="translated">casefold()</target>
        </trans-unit>
        <trans-unit id="72b31ebd561ec27a7f94f47b1a920740e13a9ca6" translate="yes" xml:space="preserve">
          <source>casefolding</source>
          <target state="translated">casefolding</target>
        </trans-unit>
        <trans-unit id="bb74bb201637d9faef338c7e6118fdc68f094025" translate="yes" xml:space="preserve">
          <source>casemapping</source>
          <target state="translated">casemapping</target>
        </trans-unit>
        <trans-unit id="b24341449997253bc14f8830942d1ead186cfe58" translate="yes" xml:space="preserve">
          <source>casespec()</source>
          <target state="translated">casespec()</target>
        </trans-unit>
        <trans-unit id="16c71304ae30f71d8ffe8067ff4329c77039c916" translate="yes" xml:space="preserve">
          <source>casey@geeknest.com</source>
          <target state="translated">casey@geeknest.com</target>
        </trans-unit>
        <trans-unit id="8d7fbe178bda9cc24bbe3201b4c4af74789b50cd" translate="yes" xml:space="preserve">
          <source>cast_I32(I)</source>
          <target state="translated">cast_I32(I)</target>
        </trans-unit>
        <trans-unit id="84e7b2086c8eb62f9d5237cc91e39c77706d2a2f" translate="yes" xml:space="preserve">
          <source>cast_i32</source>
          <target state="translated">cast_i32</target>
        </trans-unit>
        <trans-unit id="37c645c27768e8baa31df5776a5099f2fc56644e" translate="yes" xml:space="preserve">
          <source>cast_iv</source>
          <target state="translated">cast_iv</target>
        </trans-unit>
        <trans-unit id="905a5b5402cdbf782b1ca3a1f3c4ac93f2588b9a" translate="yes" xml:space="preserve">
          <source>cast_ulong</source>
          <target state="translated">cast_ulong</target>
        </trans-unit>
        <trans-unit id="9d185b287c28a9aa3f051786b148be727cbc45a0" translate="yes" xml:space="preserve">
          <source>cast_uv</source>
          <target state="translated">cast_uv</target>
        </trans-unit>
        <trans-unit id="9d989e8d27dc9e0ec3389fc855f142c3d40f0c50" translate="yes" xml:space="preserve">
          <source>cat</source>
          <target state="translated">cat</target>
        </trans-unit>
        <trans-unit id="b7a1dd9696988ff944977d50eecb627d1171afd1" translate="yes" xml:space="preserve">
          <source>cat -v</source>
          <target state="translated">고양이 -v</target>
        </trans-unit>
        <trans-unit id="e015224f52631d484760fb8f6eab59fe1a21e175" translate="yes" xml:space="preserve">
          <source>catdir</source>
          <target state="translated">catdir</target>
        </trans-unit>
        <trans-unit id="39a07535f2074530590703b6f4499ec9d01e478f" translate="yes" xml:space="preserve">
          <source>catdir (override)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="895295940961bf54e7860a91f978d53be44c1c97" translate="yes" xml:space="preserve">
          <source>catdir()</source>
          <target state="translated">catdir()</target>
        </trans-unit>
        <trans-unit id="f3e14269ef9d16f81051e26e771d77c24322ddc1" translate="yes" xml:space="preserve">
          <source>categorization, keyword, chapter_id</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8af4ddb2fd9d33e56485a48ce24f1383577c83a" translate="yes" xml:space="preserve">
          <source>catfile</source>
          <target state="translated">catfile</target>
        </trans-unit>
        <trans-unit id="ffce7c5404f3a5b4315dae8a52482fee7766d6f3" translate="yes" xml:space="preserve">
          <source>catfile (override)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b60ab76cfc1cf02868fb0f89de7fc8d4ca4329eb" translate="yes" xml:space="preserve">
          <source>catpath</source>
          <target state="translated">catpath</target>
        </trans-unit>
        <trans-unit id="b0494c131cb68c1a6d90eb9701049f402f647b75" translate="yes" xml:space="preserve">
          <source>catpath (override)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a36ba03c3d7efc39b3ba1cf8ede103f7270247c5" translate="yes" xml:space="preserve">
          <source>catpath()</source>
          <target state="translated">catpath()</target>
        </trans-unit>
        <trans-unit id="8b5241c71bbdffecbb391eeb3bd478542f088494" translate="yes" xml:space="preserve">
          <source>caught</source>
          <target state="translated">caught</target>
        </trans-unit>
        <trans-unit id="ce39e901b8f283aefa4925c1fe1b0dac3ebd0891" translate="yes" xml:space="preserve">
          <source>cause the strings &lt;code&gt;'my,ears,are,bleeding'&lt;/code&gt; and &lt;code&gt;'qw/my ears are bleeding'&lt;/code&gt; respectively to be passed as the data argument.</source>
          <target state="translated">문자열 &lt;code&gt;'my,ears,are,bleeding'&lt;/code&gt; 및 &lt;code&gt;'qw/my ears are bleeding'&lt;/code&gt; 각각 데이터 인수로 전달되도록합니다.</target>
        </trans-unit>
        <trans-unit id="d8573205b7f8e0810587a0422f70a6051e6cffc4" translate="yes" xml:space="preserve">
          <source>causes Perl to assume the following loop around your program, which makes it iterate over filename arguments somewhat like</source>
          <target state="translated">Perl이 프로그램 주변에서 다음과 같은 루프를 가정하여 파일 이름 인수를 약간 반복합니다.</target>
        </trans-unit>
        <trans-unit id="c70f8ca968cc2b84a2d8f9ff723dd921b777eee6" translate="yes" xml:space="preserve">
          <source>causes Perl to check the syntax of the program and then exit without executing it. Actually, it</source>
          <target state="translated">Perl이 프로그램의 구문을 확인한 다음 실행하지 않고 종료합니다. 실제로, 그것은</target>
        </trans-unit>
        <trans-unit id="7b78a06967eb0fcc80e6215114337d9827b4fb2f" translate="yes" xml:space="preserve">
          <source>causes error like this</source>
          <target state="translated">이와 같은 오류가 발생합니다</target>
        </trans-unit>
        <trans-unit id="088014ee15be0c288a8023edf6654b8083e4a8da" translate="yes" xml:space="preserve">
          <source>causes it to pass &lt;code&gt;[ ['till','ears','are','bleeding'] ]&lt;/code&gt; ; the array reference specified in the data being passed inside the standard array reference indicating successful interpretation.</source>
          <target state="translated">그것이 통과시킨다 &lt;code&gt;[ ['till','ears','are','bleeding'] ]&lt;/code&gt; ; 성공적인 해석을 나타내는 표준 배열 참조 내로 전달되는 데이터에 지정된 배열 참조</target>
        </trans-unit>
        <trans-unit id="a3cc1baa11fc4f877879bd4dcfa4403a99d07883" translate="yes" xml:space="preserve">
          <source>causes it to pass &lt;code&gt;[ ['till','ears','are','bleeding'] ]&lt;/code&gt;; the array reference specified in the data being passed inside the standard array reference indicating successful interpretation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2bf4396d07b4ae05a6896457aa1b58578889201" translate="yes" xml:space="preserve">
          <source>causes it to pass &lt;code&gt;['till','ears','are','bleeding']&lt;/code&gt; as the handler's data argument. While:</source>
          <target state="translated">이렇게 되었 원인 &lt;code&gt;['till','ears','are','bleeding']&lt;/code&gt; 핸들러의 데이터 인수로. 동안:</target>
        </trans-unit>
        <trans-unit id="df8cc3e0e2570acf8b47b8189932aad1db4bc131" translate="yes" xml:space="preserve">
          <source>causes the LoudDecl::Loud handler to be invoked (even if OtherClass also defines a handler for &lt;code&gt;:Loud&lt;/code&gt; attributes).</source>
          <target state="translated">LoudDecl :: Loud 핸들러가 호출되도록합니다 (OtherClass가 &lt;code&gt;:Loud&lt;/code&gt; 속성에 대한 핸들러를 정의하더라도 ).</target>
        </trans-unit>
        <trans-unit id="fb15d695643b39f8fa43791dc77a2c03e35f00b6" translate="yes" xml:space="preserve">
          <source>causes the above handler to be invoked, and passed:</source>
          <target state="translated">위의 핸들러를 호출하고 전달합니다.</target>
        </trans-unit>
        <trans-unit id="308c164380a37caf7cd1e563446905121804e3fe" translate="yes" xml:space="preserve">
          <source>causes the built, ready-to-install module code to be available below ./blib/lib and ./blib/arch and that there's a directory called 't' that contains our tests. Test::Harness isn't hardwired to that configuration but it saves me from explaining which files live where for each example.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="252e750ff47e4f26ef1004fd4eb884dc2b37ed2e" translate="yes" xml:space="preserve">
          <source>causes variables, subroutines, formats, and file and directory handles accessible via the identifier &lt;code&gt;richard&lt;/code&gt; also to be accessible via the identifier &lt;code&gt;dick&lt;/code&gt; . If you want to alias only a particular variable or subroutine, assign a reference instead:</source>
          <target state="translated">식별자 &lt;code&gt;richard&lt;/code&gt; 를 통해 액세스 할 수있는 변수, 서브 루틴, 형식 및 파일 및 디렉토리 핸들 이 식별자 &lt;code&gt;dick&lt;/code&gt; 을 통해 액세스 할 수도 있습니다 . 특정 변수 또는 서브 루틴 만 별명을 지정하려면 대신 참조를 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="6dabcc4bb085f06e75ae93460dbca046631fdb0c" translate="yes" xml:space="preserve">
          <source>causes variables, subroutines, formats, and file and directory handles accessible via the identifier &lt;code&gt;richard&lt;/code&gt; also to be accessible via the identifier &lt;code&gt;dick&lt;/code&gt;. If you want to alias only a particular variable or subroutine, assign a reference instead:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97cdd3e3456f4eba2c5ebe936e9035c0fa811d91" translate="yes" xml:space="preserve">
          <source>causes_fail</source>
          <target state="translated">causes_fail</target>
        </trans-unit>
        <trans-unit id="e508b6b6da08048585c78062e7dffd2c2aeec0ce" translate="yes" xml:space="preserve">
          <source>cbt</source>
          <target state="translated">cbt</target>
        </trans-unit>
        <trans-unit id="bdb480de655aa6ec75ca058c849c4faf3c0f75b1" translate="yes" xml:space="preserve">
          <source>cc</source>
          <target state="translated">cc</target>
        </trans-unit>
        <trans-unit id="f08937e90c24d400e577f9cc2ca1aa79597537fb" translate="yes" xml:space="preserve">
          <source>cc ( ADDRESS [, ADDRESS [...]] )</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e12e6002847af51b7fe034f4ae458d7c224ff7eb" translate="yes" xml:space="preserve">
          <source>cc.U</source>
          <target state="translated">cc.U</target>
        </trans-unit>
        <trans-unit id="36c653ca6aa745b9e24d538496bc8b8d0b36922e" translate="yes" xml:space="preserve">
          <source>cc1.exe</source>
          <target state="translated">cc1.exe</target>
        </trans-unit>
        <trans-unit id="68f8d306fda448cf5b8a4926cd857b55b1f90a46" translate="yes" xml:space="preserve">
          <source>ccflags(), ccdlflags()</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6bbfad7f25547b50fdac092afd8fe1321fabc60b" translate="yes" xml:space="preserve">
          <source>ccflags.U</source>
          <target state="translated">ccflags.U</target>
        </trans-unit>
        <trans-unit id="7077b0e5d2d87efca187d902e6880f495bdf6ecd" translate="yes" xml:space="preserve">
          <source>cco</source>
          <target state="translated">cco</target>
        </trans-unit>
        <trans-unit id="3e68cf2883a81fdd41ce12822f57f127e80cfe52" translate="yes" xml:space="preserve">
          <source>ccopts()</source>
          <target state="translated">ccopts()</target>
        </trans-unit>
        <trans-unit id="034778198a045c1ed80be271cdd029b76874f6fc" translate="yes" xml:space="preserve">
          <source>cd</source>
          <target state="translated">cd</target>
        </trans-unit>
        <trans-unit id="e992c3182d410b7ac370694b82237ca081ebad2b" translate="yes" xml:space="preserve">
          <source>cd /usr/local/ascii export IO_CONVERSION=NO gunzip &amp;lt; /usr/local/src/perl.tar.gz | pax -r</source>
          <target state="translated">cd / usr / local / ascii 내보내기 IO_CONVERSION = NO gunzip &amp;lt;/usr/local/src/perl.tar.gz | pax -r</target>
        </trans-unit>
        <trans-unit id="f7c8cd0c2b39e0615a3916ddfa03de4480bedc53" translate="yes" xml:space="preserve">
          <source>cd /usr/local/src IO_CONVERSION=YES cp -r /usr/local/ascii/perl5.005_02 ./</source>
          <target state="translated">cd / usr / local / src IO_CONVERSION = YES cp -r /usr/local/ascii/perl5.005_02 ./</target>
        </trans-unit>
        <trans-unit id="a48eb756cd6cdc5f26fdd31045cfd8710f8a3abd" translate="yes" xml:space="preserve">
          <source>cd Abstract</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db30a63094fef4c2f61b22e3289acc3079bfdecb" translate="yes" xml:space="preserve">
          <source>cdup ()</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="02cd8467dc324e9631313e2b2d896d1c32006648" translate="yes" xml:space="preserve">
          <source>ce-helpers/wince-reg.bat</source>
          <target state="translated">ce-helpers/wince-reg.bat</target>
        </trans-unit>
        <trans-unit id="305047e96ec089021660ee5965f893ac80268731" translate="yes" xml:space="preserve">
          <source>center</source>
          <target state="translated">center</target>
        </trans-unit>
        <trans-unit id="c92b40b9151b063c6a5976e4da985c5fd7c33df7" translate="yes" xml:space="preserve">
          <source>certain operations 'upgrade' their calculation and thus the result to the class Foo::Bar. Usually this is used in conjunction with Math::BigFloat:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f22c7b71da8e7b91af77c1e966a231ef482b7b4a" translate="yes" xml:space="preserve">
          <source>certain operations will 'upgrade' their calculation and thus the result to the class Foo::Bar. Usually this is used in conjunction with Math::BigFloat:</source>
          <target state="translated">특정 작업은 계산을 '업그레이드'하여 결과를 클래스 Foo :: Bar로 업그레이드합니다. 보통 이것은 Math :: BigFloat와 함께 사용됩니다 :</target>
        </trans-unit>
        <trans-unit id="1a1dc14cbfb80ebee3e6fa16d5973ad2a9773a40" translate="yes" xml:space="preserve">
          <source>cf_email.U</source>
          <target state="translated">cf_email.U</target>
        </trans-unit>
        <trans-unit id="0fee8d38867e35f1baff12ad4f0ab653efd982ee" translate="yes" xml:space="preserve">
          <source>cf_who.U</source>
          <target state="translated">cf_who.U</target>
        </trans-unit>
        <trans-unit id="f52d8c41a15e440b898d2ed0b47735955985f789" translate="yes" xml:space="preserve">
          <source>cflags</source>
          <target state="translated">cflags</target>
        </trans-unit>
        <trans-unit id="a5c2dd8275ddeae426e174270bdab985141b12f1" translate="yes" xml:space="preserve">
          <source>cflags (o)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b747cd2459e68bde21af86e6d507fe2284ab610" translate="yes" xml:space="preserve">
          <source>cflags (override)</source>
          <target state="new"/>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
