<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="perl">
    <body>
      <group id="perl">
        <trans-unit id="fb785a40ce237466b61cf74c58f19b12f7daa54a" translate="yes" xml:space="preserve">
          <source>Also note that there's no value for UNITCHECK-blocks. That's because those are run for each compilation unit individually, and therefore is not a global interpreter phase.</source>
          <target state="translated">또한 UNITCHECK 블록에는 값이 없습니다. 각 컴파일 단위마다 개별적으로 실행되므로 전역 인터프리터 단계가 아니기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="8af529a7344d9be72e889a1f3967799ba9dc98d6" translate="yes" xml:space="preserve">
          <source>Also note that these instructions are tailored for installing the module into your system's repository of Perl modules, but you can install modules into any directory you wish. For instance, where I say &lt;code&gt;perl Makefile.PL&lt;/code&gt; , you can substitute &lt;code&gt;perl Makefile.PL
PREFIX=/my/perl_directory&lt;/code&gt; to install the modules into</source>
          <target state="translated">또한이 지시 사항은 시스템의 Perl 모듈 저장소에 모듈을 설치하기위한 것이지만 원하는 디렉토리에 모듈을 설치할 수 있습니다. 예를 들어, &lt;code&gt;perl Makefile.PL&lt;/code&gt; 이라고 말하면 perl &lt;code&gt;perl Makefile.PL PREFIX=/my/perl_directory&lt;/code&gt; 를 대체 하여 모듈을 설치할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="981eced70a1fd7e3f9ca6ea4e94af48969947ff9" translate="yes" xml:space="preserve">
          <source>Also note that these instructions are tailored for installing the module into your system's repository of Perl modules, but you can install modules into any directory you wish. For instance, where I say &lt;code&gt;perl Makefile.PL&lt;/code&gt;, you can substitute &lt;code&gt;perl Makefile.PL PREFIX=/my/perl_directory&lt;/code&gt; to install the modules into</source>
          <target state="translated">또한이 지침은 시스템의 Perl 모듈 저장소에 모듈을 설치하는 데 적합하지만 원하는 디렉토리에 모듈을 설치할 수 있습니다. 예를 들어, 내가 &lt;code&gt;perl Makefile.PL&lt;/code&gt; 이라고 말하면 perl &lt;code&gt;perl Makefile.PL PREFIX=/my/perl_directory&lt;/code&gt; 로 대체 하여 모듈을 설치할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="736913cda9c361fafb5f7987b822471b70893809" translate="yes" xml:space="preserve">
          <source>Also note that this does not (yet) work with all configurations, it is known to fail with 64-bit versions of GCC.</source>
          <target state="translated">또한 모든 구성에서 작동하지는 않지만 64 비트 버전의 GCC에서는 실패하는 것으로 알려져 있습니다.</target>
        </trans-unit>
        <trans-unit id="1ab79db4a65e3d1bcd26f59f38af2eeb810bbb25" translate="yes" xml:space="preserve">
          <source>Also note that under the current implementation, shared variables use a little more memory and are a little slower than ordinary variables.</source>
          <target state="translated">또한 현재 구현에서 공유 변수는 메모리를 조금 더 사용하고 일반 변수보다 약간 느립니다.</target>
        </trans-unit>
        <trans-unit id="df7301891c8738a820a79c945053b0568b895b92" translate="yes" xml:space="preserve">
          <source>Also note that whether enums are implicitly morphable to ints varies between compilers, you might need to (int).</source>
          <target state="translated">또한 열거 형이 암시 적으로 int로 변경 가능한지 여부는 컴파일러마다 다르므로 (int)해야 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="3fe91d0953fd134d385ab62185c6773cb118c04f" translate="yes" xml:space="preserve">
          <source>Also note that while the order of the hash elements might be randomized, this &quot;pseudo-ordering&quot; should &lt;b&gt;not&lt;/b&gt; be used for applications like shuffling a list randomly (use &lt;code&gt;List::Util::shuffle()&lt;/code&gt; for that, see &lt;a href=&quot;List::Util&quot;&gt;List::Util&lt;/a&gt;, a standard core module since Perl 5.8.0; or the CPAN module &lt;code&gt;Algorithm::Numerical::Shuffle&lt;/code&gt;), or for generating permutations (use e.g. the CPAN modules &lt;code&gt;Algorithm::Permute&lt;/code&gt; or &lt;code&gt;Algorithm::FastPermute&lt;/code&gt;), or for any cryptographic applications.</source>
          <target state="translated">또한 해시 요소의 순서가 무작위로 지정 될 수 있지만이 &quot;의사 정렬&quot;은 목록을 무작위로 섞는 것과 같은 응용 프로그램에 사용 해서는 &lt;b&gt;안됩니다&lt;/b&gt; ( &lt;code&gt;List::Util::shuffle()&lt;/code&gt; 사용, &lt;a href=&quot;List::Util&quot;&gt;List :: Util&lt;/a&gt; 참조 ). , Perl 5.8.0 이후의 표준 코어 모듈, CPAN 모듈 &lt;code&gt;Algorithm::Numerical::Shuffle&lt;/code&gt; ), 순열 생성 (예 : CPAN 모듈 &lt;code&gt;Algorithm::Permute&lt;/code&gt; 또는 &lt;code&gt;Algorithm::FastPermute&lt;/code&gt; ) 또는 모든 암호화 애플리케이션 .</target>
        </trans-unit>
        <trans-unit id="971b7944044758dad02956ec65121b0bd485f6a2" translate="yes" xml:space="preserve">
          <source>Also note that while the order of the hash elements might be randomized, this &quot;pseudo-ordering&quot; should &lt;b&gt;not&lt;/b&gt; be used for applications like shuffling a list randomly (use &lt;code&gt;List::Util::shuffle()&lt;/code&gt; for that, see &lt;a href=&quot;list/util&quot;&gt;List::Util&lt;/a&gt;, a standard core module since Perl 5.8.0; or the CPAN module &lt;code&gt;Algorithm::Numerical::Shuffle&lt;/code&gt; ), or for generating permutations (use e.g. the CPAN modules &lt;code&gt;Algorithm::Permute&lt;/code&gt; or &lt;code&gt;Algorithm::FastPermute&lt;/code&gt; ), or for any cryptographic applications.</source>
          <target state="translated">또한, 해시 요소의 순서는 무작위 될 수 있지만,이 &quot;의사 순서&quot;는 것을주의 &lt;b&gt;하지&lt;/b&gt; 무작위 (사용 목록을 셔플과 같은 응용 프로그램에 사용되는 &lt;code&gt;List::Util::shuffle()&lt;/code&gt; 그것을 위해, 참조 &lt;a href=&quot;list/util&quot;&gt;목록 :: 백분율&lt;/a&gt; , Perl 5.8.0 이후의 표준 코어 모듈 또는 CPAN 모듈 &lt;code&gt;Algorithm::Numerical::Shuffle&lt;/code&gt; ) 또는 순열 생성 (예 : CPAN 모듈 &lt;code&gt;Algorithm::Permute&lt;/code&gt; 또는 &lt;code&gt;Algorithm::FastPermute&lt;/code&gt; ) 또는 모든 암호화 응용 프로그램 .</target>
        </trans-unit>
        <trans-unit id="1cc898b24b5934f9ecf52c4f2514750c1a887e03" translate="yes" xml:space="preserve">
          <source>Also note that you should set the &lt;code&gt;Efs&lt;/code&gt; option to true if you are working with UTF8 filenames.</source>
          <target state="translated">또한 UTF8 파일 이름으로 작업하는 경우 &lt;code&gt;Efs&lt;/code&gt; 옵션을 true로 설정해야합니다 .</target>
        </trans-unit>
        <trans-unit id="4516f893f396703a765e286979d300545dd3cb43" translate="yes" xml:space="preserve">
          <source>Also note that, for the superuser on the local filesystems, the &lt;code&gt;-r&lt;/code&gt; , &lt;code&gt;-R&lt;/code&gt; , &lt;code&gt;-w&lt;/code&gt; , and &lt;code&gt;-W&lt;/code&gt; tests always return 1, and &lt;code&gt;-x&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;-x&quot;&gt;-X&lt;/a&gt;&lt;/code&gt; return 1 if any execute bit is set in the mode. Scripts run by the superuser may thus need to do a stat() to determine the actual mode of the file, or temporarily set their effective uid to something else.</source>
          <target state="translated">또한 로컬 파일 시스템의 수퍼 유저에 대해 &lt;code&gt;-r&lt;/code&gt; , &lt;code&gt;-R&lt;/code&gt; , &lt;code&gt;-w&lt;/code&gt; 및 &lt;code&gt;-W&lt;/code&gt; 테스트는 항상 1을 리턴하고 실행 비트가 모드에서 설정되면 &lt;code&gt;-x&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;-x&quot;&gt;-X&lt;/a&gt;&lt;/code&gt; 가 1을 리턴합니다. 따라서 수퍼 유저가 실행하는 스크립트는 파일의 실제 모드를 결정하기 위해 stat ()를 수행하거나 유효 uid를 일시적으로 다른 것으로 설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="63277c7c7b95830e3556168d50e815433213b167" translate="yes" xml:space="preserve">
          <source>Also note that, for the superuser on the local filesystems, the &lt;code&gt;-r&lt;/code&gt; , &lt;code&gt;-R&lt;/code&gt; , &lt;code&gt;-w&lt;/code&gt; , and &lt;code&gt;-W&lt;/code&gt; tests always return 1, and &lt;code&gt;-x&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/-x&quot;&gt;-X&lt;/a&gt;&lt;/code&gt; return 1 if any execute bit is set in the mode. Scripts run by the superuser may thus need to do a stat() to determine the actual mode of the file, or temporarily set their effective uid to something else.</source>
          <target state="translated">또한 로컬 파일 시스템의 수퍼 유저에 대해 &lt;code&gt;-r&lt;/code&gt; , &lt;code&gt;-R&lt;/code&gt; , &lt;code&gt;-w&lt;/code&gt; 및 &lt;code&gt;-W&lt;/code&gt; 테스트는 항상 1을 리턴하고 실행 비트가 모드에서 설정되면 &lt;code&gt;-x&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;functions/-x&quot;&gt;-X&lt;/a&gt;&lt;/code&gt; 가 1을 리턴합니다. 따라서 수퍼 유저가 실행하는 스크립트는 파일의 실제 모드를 결정하기 위해 stat ()를 수행하거나 유효 uid를 일시적으로 다른 것으로 설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="4c12857d50953ae8911fef9be5deb3cb6261b630" translate="yes" xml:space="preserve">
          <source>Also note that, for the superuser on the local filesystems, the &lt;code&gt;-r&lt;/code&gt;, &lt;code&gt;-R&lt;/code&gt;, &lt;code&gt;-w&lt;/code&gt;, and &lt;code&gt;-W&lt;/code&gt; tests always return 1, and &lt;code&gt;-x&lt;/code&gt; and &lt;code&gt;-X&lt;/code&gt; return 1 if any execute bit is set in the mode. Scripts run by the superuser may thus need to do a &lt;a href=&quot;#stat-FILEHANDLE&quot;&gt;&lt;code&gt;stat&lt;/code&gt;&lt;/a&gt; to determine the actual mode of the file, or temporarily set their effective uid to something else.</source>
          <target state="translated">또한 로컬 파일 시스템의 수퍼 유저의 경우 &lt;code&gt;-r&lt;/code&gt; , &lt;code&gt;-R&lt;/code&gt; , &lt;code&gt;-w&lt;/code&gt; 및 &lt;code&gt;-W&lt;/code&gt; 테스트는 항상 1을 반환하고 모드에 실행 비트가 설정되어 있으면 &lt;code&gt;-x&lt;/code&gt; 및 &lt;code&gt;-X&lt;/code&gt; 는 1을 반환합니다. 따라서 수퍼 유저가 실행하는 스크립트 는 파일의 실제 모드를 결정하기 위해 &lt;a href=&quot;#stat-FILEHANDLE&quot;&gt; &lt;code&gt;stat&lt;/code&gt; &lt;/a&gt; 를 수행 하거나 임시로 유효한 uid를 다른 것으로 설정해야 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0d0223c3f3274398a55ed8725b06675a40efd8ef" translate="yes" xml:space="preserve">
          <source>Also note that:</source>
          <target state="translated">또한 다음을 참고하십시오.</target>
        </trans-unit>
        <trans-unit id="87da44cc851ca2f3b8c127c8f7ddc08e6bd458e4" translate="yes" xml:space="preserve">
          <source>Also note, that because all ASCII characters are UTF-8 invariant (meaning they have the exact same representation (always a single byte) whether encoded in UTF-8 or not), &lt;code&gt;isASCII&lt;/code&gt; will give the correct results when called with any byte in any string encoded or not in UTF-8. And similarly &lt;code&gt;isASCII_utf8&lt;/code&gt; will work properly on any string encoded or not in UTF-8.</source>
          <target state="translated">또한 모든 ASCII 문자가 UTF-8로 변하지 않기 때문에 (UTF-8로 인코딩되었는지 여부에 관계없이 동일한 바이트 (항상 단일 바이트) &lt;code&gt;isASCII&lt;/code&gt; 을 의미 함 ) isASCII 는 임의의 바이트로 호출 될 때 올바른 결과를 제공합니다. UTF-8로 인코딩되거나 인코딩되지 않은 문자열 마찬가지로 &lt;code&gt;isASCII_utf8&lt;/code&gt; 은 UTF-8로 인코딩되거나 인코딩되지 않은 모든 문자열에서 올바르게 작동합니다.</target>
        </trans-unit>
        <trans-unit id="523b244d1d9de0ba3f1938d9267c5634264d7182" translate="yes" xml:space="preserve">
          <source>Also notice that no matter what arguments you pass to perl_parse(), PERL_SYS_INIT3() must be invoked on the C main() argc, argv and env and only once.</source>
          <target state="translated">또한 perl_parse ()에 전달하는 인수에 관계없이 C main () argc, argv 및 env에서 PERL_SYS_INIT3 ()을 한 번만 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="84e807ea22d37e9fcac5bf336f329420c5d937c0" translate="yes" xml:space="preserve">
          <source>Also of use is &lt;a href=&quot;File::Basename&quot;&gt;&lt;code&gt;File::Basename&lt;/code&gt;&lt;/a&gt; from the standard distribution, which splits a pathname into pieces (base filename, full path to directory, and file suffix).</source>
          <target state="translated">또한 표준 배포판의 &lt;a href=&quot;File::Basename&quot;&gt; &lt;code&gt;File::Basename&lt;/code&gt; &lt;/a&gt; 사용됩니다.이 파일 은 경로 이름을 여러 조각 (기본 파일 이름, 디렉터리에 대한 전체 경로 및 파일 접미사)으로 분할합니다.</target>
        </trans-unit>
        <trans-unit id="e0b1e0d1886e4ff75f5ec5ef85846c4c02e181e1" translate="yes" xml:space="preserve">
          <source>Also of use is &lt;code&gt;File::Basename&lt;/code&gt; from the standard distribution, which splits a pathname into pieces (base filename, full path to directory, and file suffix).</source>
          <target state="translated">또한 표준 배포판의 &lt;code&gt;File::Basename&lt;/code&gt; 을 사용 하여 경로 이름을 조각 (기본 파일 이름, 디렉토리의 전체 경로 및 파일 접미사)으로 분할합니다.</target>
        </trans-unit>
        <trans-unit id="5f72eee36e825db36f597f9decf9236b17c32472" translate="yes" xml:space="preserve">
          <source>Also parsed as terms are the &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt; {}&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; {}&lt;/code&gt; constructs, as well as subroutine and method calls, and the anonymous constructors &lt;code&gt;[]&lt;/code&gt; and &lt;code&gt;{}&lt;/code&gt; .</source>
          <target state="translated">또한 &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt; {}&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; {}&lt;/code&gt; 구문뿐만 아니라 서브 루틴 및 메소드 호출, 익명 생성자 &lt;code&gt;[]&lt;/code&gt; 및 &lt;code&gt;{}&lt;/code&gt; 로도 구문 분석됩니다 .</target>
        </trans-unit>
        <trans-unit id="76e4187069aa3cdfe5b15fb66a75e8d762b8a3c7" translate="yes" xml:space="preserve">
          <source>Also parsed as terms are the &lt;code&gt;do {}&lt;/code&gt; and &lt;code&gt;eval {}&lt;/code&gt; constructs, as well as subroutine and method calls, and the anonymous constructors &lt;code&gt;[]&lt;/code&gt; and &lt;code&gt;{}&lt;/code&gt;.</source>
          <target state="translated">또한 용어로 구문 분석되는 것은 &lt;code&gt;do {}&lt;/code&gt; 및 &lt;code&gt;eval {}&lt;/code&gt; 구문, 서브 루틴 및 메서드 호출, 익명 생성자 &lt;code&gt;[]&lt;/code&gt; 및 &lt;code&gt;{}&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="4ab49029f03642de1877e97fc5e4ccdaa8f4d8b8" translate="yes" xml:space="preserve">
          <source>Also read the &lt;a href=&quot;#DESCRIPTION&quot;&gt;&quot;DESCRIPTION&quot;&lt;/a&gt; section above, about how &lt;code&gt;Carp&lt;/code&gt; decides where the error is reported from.</source>
          <target state="translated">또한 &lt;code&gt;Carp&lt;/code&gt; 이 오류가보고 된 위치를 결정 하는 방법에 대한 위 의 &lt;a href=&quot;#DESCRIPTION&quot;&gt;&quot;설명&quot;&lt;/a&gt; 섹션을 읽으십시오 .</target>
        </trans-unit>
        <trans-unit id="a2bae6f7ee0c691e590b07608d4c9653431dd798" translate="yes" xml:space="preserve">
          <source>Also read the &lt;a href=&quot;#DESCRIPTION&quot;&gt;DESCRIPTION&lt;/a&gt; section above, about how &lt;code&gt;Carp&lt;/code&gt; decides where the error is reported from.</source>
          <target state="translated">&lt;code&gt;Carp&lt;/code&gt; 가 오류가보고되는 위치를 결정 하는 방법에 대한 위 의 &lt;a href=&quot;#DESCRIPTION&quot;&gt;설명&lt;/a&gt; 섹션 도 읽으십시오 .</target>
        </trans-unit>
        <trans-unit id="6e8426be1042a9c74b01dabfc6cf09d489acf3c6" translate="yes" xml:space="preserve">
          <source>Also referred to as &quot;Dotted-Integer&quot;, these contains more than one decimal point and may have an optional embedded underscore, see &lt;a href=&quot;#Dotted-Decimal-Versions&quot;&gt;&quot;Dotted-Decimal Versions&quot;&lt;/a&gt;. This is what is commonly used in most open source software as the &quot;external&quot; version (the one used as part of the tag or tarfile name). A leading 'v' character is now required and will warn if it missing.</source>
          <target state="translated">&quot;점선 정수&quot;라고도하며 소수점이 두 개 이상 포함되어 있으며 선택적 밑줄이 포함될 수 있습니다. &lt;a href=&quot;#Dotted-Decimal-Versions&quot;&gt;&quot;점선 10 진수 버전&quot;을&lt;/a&gt; 참조하십시오 . 이것은 대부분의 오픈 소스 소프트웨어에서 &quot;외부&quot;버전 (태그 또는 타르 파일 이름의 일부로 사용되는 버전)으로 일반적으로 사용되는 것입니다. 이제 선행 'v'문자가 필요하며 누락 된 경우 경고합니다.</target>
        </trans-unit>
        <trans-unit id="8e594eb3334af2971f8b461e9ae7e0b95244811c" translate="yes" xml:space="preserve">
          <source>Also remember that &quot;|&quot; is interpreted as a literal within square brackets, so if you write &lt;code&gt;[fee|fie|foe]&lt;/code&gt; you're really only matching &lt;code&gt;[feio|]&lt;/code&gt; .</source>
          <target state="translated">또한 &quot;|&quot; 는 대괄호 안에 리터럴로 해석되므로 &lt;code&gt;[fee|fie|foe]&lt;/code&gt; 를 &lt;code&gt;[feio|]&lt;/code&gt; 실제로 [feio |] 만 일치 합니다.</target>
        </trans-unit>
        <trans-unit id="2d930463c65b067a74fc5ff7d23d0ccb6261af74" translate="yes" xml:space="preserve">
          <source>Also remember that C doesn't allow you to safely say &lt;code&gt;foo(SvPV(s, len),
len);&lt;/code&gt;. It might work with your compiler, but it won't work for everyone. Break this sort of statement up into separate assignments:</source>
          <target state="translated">또한 C는 &lt;code&gt;foo(SvPV(s, len), len);&lt;/code&gt; . 컴파일러에서는 작동하지만 모든 사람에게 작동하지는 않습니다. 이러한 종류의 진술을 별도의 과제로 나눕니다.</target>
        </trans-unit>
        <trans-unit id="f44fcd946ba2f23c70977904fbf45aba4b6fafca" translate="yes" xml:space="preserve">
          <source>Also remember that the &lt;code&gt;%p&lt;/code&gt; format really does require a void pointer:</source>
          <target state="translated">또한 &lt;code&gt;%p&lt;/code&gt; 형식에는 실제로 void 포인터가 필요 하다는 것을 기억하십시오 .</target>
        </trans-unit>
        <trans-unit id="d484e6b6d31da17dc2ff01d2d2dda31cda9e2d99" translate="yes" xml:space="preserve">
          <source>Also remember: If the META file contains a provides field, you shouldn't be indexing anything in the first place - just use that.</source>
          <target state="translated">또한 기억하십시오. META 파일에 제공 필드가 포함되어있는 경우 처음부터 어떤 것도 인덱싱해서는 안됩니다. 그냥 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="058a190dd3d11e3f9bf93212c115f6265d98bac0" translate="yes" xml:space="preserve">
          <source>Also see &lt;a href=&quot;functions/binmode&quot;&gt;binmode&lt;/a&gt; or &lt;a href=&quot;perlopentut&quot;&gt;perlopentut&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;functions/binmode&quot;&gt;binmode&lt;/a&gt; 또는 &lt;a href=&quot;perlopentut&quot;&gt;perlopentut&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f380eae13c59641be526fa28a59640fd146bd59e" translate="yes" xml:space="preserve">
          <source>Also see &lt;a href=&quot;perlfunc#binmode&quot;&gt;&quot;binmode&quot; in perlfunc&lt;/a&gt; or &lt;a href=&quot;perlopentut&quot;&gt;perlopentut&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;perlfunc#binmode&quot;&gt;perlfunc&lt;/a&gt; 또는 &lt;a href=&quot;perlopentut&quot;&gt;perlopentut의 &lt;/a&gt;&quot;binmode&quot; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b821601b2c44fa646b454cc4c61309ada267db9f" translate="yes" xml:space="preserve">
          <source>Also see the &lt;b&gt;--lquote&lt;/b&gt; and &lt;b&gt;--rquote&lt;/b&gt; options, which can be used to set the left and right quotes independently. If both &lt;b&gt;--quotes&lt;/b&gt; and one of the other options is set, &lt;b&gt;--lquote&lt;/b&gt; or &lt;b&gt;--rquote&lt;/b&gt; overrides &lt;b&gt;--quotes&lt;/b&gt;.</source>
          <target state="translated">왼쪽 및 오른쪽 따옴표를 독립적으로 설정하는 데 사용할 수있는 &lt;b&gt;--lquote&lt;/b&gt; 및 &lt;b&gt;--rquote&lt;/b&gt; 옵션 도 참조하세요 . &lt;b&gt;--quotes&lt;/b&gt; 와 다른 옵션 중 하나가 모두 설정된 경우 &lt;b&gt;--lquote&lt;/b&gt; 또는 &lt;b&gt;--rquote가 --quotes를&lt;/b&gt; 재정의 &lt;b&gt;합니다&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="124ca3ad4251372cd630b0c4f1d026a6e1bb631a" translate="yes" xml:space="preserve">
          <source>Also see the &lt;b&gt;--quotes&lt;/b&gt; option, which can be used to set both quotes at once. If both &lt;b&gt;--quotes&lt;/b&gt; and one of the other options is set, &lt;b&gt;--lquote&lt;/b&gt; or &lt;b&gt;--rquote&lt;/b&gt; overrides &lt;b&gt;--quotes&lt;/b&gt;.</source>
          <target state="translated">두 따옴표를 동시에 설정하는 데 사용할 수있는 &lt;b&gt;--quotes&lt;/b&gt; 옵션 도 참조하세요 . &lt;b&gt;--quotes&lt;/b&gt; 와 다른 옵션 중 하나가 모두 설정된 경우 &lt;b&gt;--lquote&lt;/b&gt; 또는 &lt;b&gt;--rquote가 --quotes를&lt;/b&gt; 재정의 &lt;b&gt;합니다&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="14f14f1236967cfa8b858394733973952439e548" translate="yes" xml:space="preserve">
          <source>Also see the &lt;code&gt;lquote&lt;/code&gt; and &lt;code&gt;rquote&lt;/code&gt; options, which can be used to set the left and right quotes independently. If both &lt;code&gt;quotes&lt;/code&gt; and one of the other options is set, &lt;code&gt;lquote&lt;/code&gt; or &lt;code&gt;rquote&lt;/code&gt; overrides &lt;code&gt;quotes&lt;/code&gt;.</source>
          <target state="translated">또한 왼쪽 및 오른쪽 따옴표를 독립적으로 설정하는 데 사용할 수있는 &lt;code&gt;lquote&lt;/code&gt; 및 &lt;code&gt;rquote&lt;/code&gt; 옵션을 참조하십시오 . &lt;code&gt;quotes&lt;/code&gt; 와 다른 옵션 중 하나가 모두 설정된 경우 &lt;code&gt;lquote&lt;/code&gt; 또는 &lt;code&gt;rquote&lt;/code&gt; 가 &lt;code&gt;quotes&lt;/code&gt; 재정의 합니다 .</target>
        </trans-unit>
        <trans-unit id="b43f69db8fdd0609b53e771f0c648e36f1cca6c0" translate="yes" xml:space="preserve">
          <source>Also see the &lt;code&gt;quotes&lt;/code&gt; option, which can be used to set both quotes at once. If both &lt;code&gt;quotes&lt;/code&gt; and one of the other options is set, &lt;code&gt;lquote&lt;/code&gt; or &lt;code&gt;rquote&lt;/code&gt; overrides &lt;code&gt;quotes&lt;/code&gt;.</source>
          <target state="translated">두 따옴표를 동시에 설정하는 데 사용할 수있는 &lt;code&gt;quotes&lt;/code&gt; 옵션 도 참조하십시오 . &lt;code&gt;quotes&lt;/code&gt; 와 다른 옵션 중 하나가 모두 설정된 경우 &lt;code&gt;lquote&lt;/code&gt; 또는 &lt;code&gt;rquote&lt;/code&gt; 가 &lt;code&gt;quotes&lt;/code&gt; 재정의 합니다 .</target>
        </trans-unit>
        <trans-unit id="aa855f9ba4cde9a2842bd3fc97af3045ad2e00c0" translate="yes" xml:space="preserve">
          <source>Also see:</source>
          <target state="translated">참조 :</target>
        </trans-unit>
        <trans-unit id="e8ab5cecbe34d47a3838306a541fd22a09e183f0" translate="yes" xml:space="preserve">
          <source>Also starting in v5.8.1, the &lt;code&gt;DATA&lt;/code&gt; pseudo-filehandle is translated from the encoding into UTF-8.</source>
          <target state="translated">또한 v5.8.1부터 &lt;code&gt;DATA&lt;/code&gt; 의사 파일 핸들이 인코딩에서 UTF-8로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="ab76f7fb0dafb2fd9b645c8d2859052a429122ce" translate="yes" xml:space="preserve">
          <source>Also study &lt;a href=&quot;perlport&quot;&gt;perlport&lt;/a&gt; carefully to avoid any bad assumptions about the operating system, filesystems, character set, and so forth.</source>
          <target state="translated">또한 운영 체제, 파일 시스템, 문자 집합 등에 대한 잘못된 가정을 피하기 위해 &lt;a href=&quot;perlport&quot;&gt;perlport를&lt;/a&gt; 신중하게 연구 하십시오 .</target>
        </trans-unit>
        <trans-unit id="2e87f20f7d97b568a4954fba96e48f292ed18abb" translate="yes" xml:space="preserve">
          <source>Also unchanged is the quoting of non-UTF-8 strings when outside the scope of a &lt;a href=&quot;feature#The-%27unicode_strings%27-feature&quot;&gt;&lt;code&gt;use feature 'unicode_strings'&lt;/code&gt;&lt;/a&gt;, which is to quote all characters in the upper Latin1 range. This provides complete backwards compatibility for old programs which do not use Unicode. (Note that &lt;code&gt;unicode_strings&lt;/code&gt; is automatically enabled within the scope of a &lt;code&gt;use v5.12&lt;/code&gt; or greater.)</source>
          <target state="translated">또한 변경되지 않은 것은 상위 Latin1 범위의 모든 문자를 인용 하는 &lt;a href=&quot;feature#The-%27unicode_strings%27-feature&quot;&gt; &lt;code&gt;use feature 'unicode_strings'&lt;/code&gt; &lt;/a&gt; 의 범위를 벗어난 경우 UTF-8이 아닌 문자열의 인용입니다 . 이것은 유니 코드를 사용하지 않는 이전 프로그램에 대한 완전한 역 호환성을 제공합니다. ( &lt;code&gt;unicode_strings&lt;/code&gt; 는 &lt;code&gt;use v5.12&lt;/code&gt; 이상 사용 범위 내에서 자동으로 활성화됩니다 .)</target>
        </trans-unit>
        <trans-unit id="330eeffd40ec44ea764cda155371e57d6de9d850" translate="yes" xml:space="preserve">
          <source>Also unchanged is the quoting of non-UTF-8 strings when outside the scope of a &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature 'unicode_strings'&lt;/code&gt; , which is to quote all characters in the upper Latin1 range. This provides complete backwards compatibility for old programs which do not use Unicode. (Note that &lt;code&gt;unicode_strings&lt;/code&gt; is automatically enabled within the scope of a &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; v5.12&lt;/code&gt; or greater.)</source>
          <target state="translated">또한 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature 'unicode_strings'&lt;/code&gt; 의 범위를 벗어난 비 UTF-8 문자열 인용은 변경되지 않으며 이는 상위 Latin1 범위의 모든 문자를 인용합니다. 이것은 유니 코드를 사용하지 않는 구식 프로그램에 대한 완전한 하위 호환성을 제공합니다. ( &lt;code&gt;unicode_strings&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; v5.12&lt;/code&gt; &lt;a href=&quot;functions/use&quot;&gt;사용&lt;/a&gt; 범위 내에서 자동으로 활성화됩니다. 이상의 .)</target>
        </trans-unit>
        <trans-unit id="d897a47e8affb873fdb6ab1911f0d831b446c551" translate="yes" xml:space="preserve">
          <source>Also unchanged is the quoting of non-UTF-8 strings when outside the scope of a &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; feature 'unicode_strings'&lt;/code&gt; , which is to quote all characters in the upper Latin1 range. This provides complete backwards compatibility for old programs which do not use Unicode. (Note that &lt;code&gt;unicode_strings&lt;/code&gt; is automatically enabled within the scope of a &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; v5.12&lt;/code&gt; or greater.)</source>
          <target state="translated">또한 &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; feature 'unicode_strings'&lt;/code&gt; 의 범위를 벗어난 비 UTF-8 문자열 인용은 변경되지 않으며 이는 상위 Latin1 범위의 모든 문자를 인용합니다. 이것은 유니 코드를 사용하지 않는 구식 프로그램에 대한 완전한 하위 호환성을 제공합니다. ( &lt;code&gt;unicode_strings&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; v5.12&lt;/code&gt; 이상의 &lt;a href=&quot;use&quot;&gt;사용&lt;/a&gt; 범위 내에서 자동으로 활성화됩니다 .)</target>
        </trans-unit>
        <trans-unit id="77e4638580e542bd7efbc6ad1037c219e33a2a27" translate="yes" xml:space="preserve">
          <source>Also unlike &lt;code&gt;fileparse()&lt;/code&gt; , &lt;code&gt;dirname()&lt;/code&gt; does not include a trailing slash on its returned path.</source>
          <target state="translated">또한 달리 &lt;code&gt;fileparse()&lt;/code&gt; , &lt;code&gt;dirname()&lt;/code&gt; 의 반환 경로에 후행 슬래시를 포함하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="26303c82ac6b3a7fa556573e39f86a09e33051c1" translate="yes" xml:space="preserve">
          <source>Also unlike &lt;code&gt;fileparse()&lt;/code&gt;, &lt;code&gt;dirname()&lt;/code&gt; does not include a trailing slash on its returned path.</source>
          <target state="translated">또한 달리 &lt;code&gt;fileparse()&lt;/code&gt; , &lt;code&gt;dirname()&lt;/code&gt; 의 반환 경로에 후행 슬래시를 포함하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3cf4e79f0d2cc479a41a6179c877f4a73d453199" translate="yes" xml:space="preserve">
          <source>Also when working on Perl programs on VMS, if you need a syntax in a specific operating system format, then you need either to check the appropriate DECC$ feature logical, or call a conversion routine to force it to that format.</source>
          <target state="translated">또한 VMS에서 Perl 프로그램을 작업 할 때 특정 운영 체제 형식의 구문이 필요한 경우 적절한 DECC $ 기능 논리를 확인하거나 변환 루틴을 호출하여 해당 형식으로 강제 실행해야합니다.</target>
        </trans-unit>
        <trans-unit id="5fc47794ba1a865aaaa0f149000e05b513e4f015" translate="yes" xml:space="preserve">
          <source>Also you have to be careful when using &lt;code&gt;&amp;amp;PL_sv_undef&lt;/code&gt; as a value in AVs or HVs (see &lt;a href=&quot;#AVs%2C-HVs-and-undefined-values&quot;&gt;&quot;AVs, HVs and undefined values&quot;&lt;/a&gt;).</source>
          <target state="translated">또한 AV 또는 HV의 값으로 &lt;code&gt;&amp;amp;PL_sv_undef&lt;/code&gt; 를 사용할 때주의해야합니다 ( &lt;a href=&quot;#AVs%2C-HVs-and-undefined-values&quot;&gt;&quot;AV, HV 및 정의되지 않은 값&quot;참조&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="b4a91fa72735b293f0702212cc8b8ff7dd3fc1bc" translate="yes" xml:space="preserve">
          <source>Also you have to be careful when using &lt;code&gt;&amp;amp;PL_sv_undef&lt;/code&gt; as a value in AVs or HVs (see &lt;a href=&quot;#AVs%2c-HVs-and-undefined-values&quot;&gt;AVs, HVs and undefined values&lt;/a&gt;).</source>
          <target state="translated">또한 AV 또는 HV의 값으로 &lt;code&gt;&amp;amp;PL_sv_undef&lt;/code&gt; 를 사용할 때주의해야합니다 ( &lt;a href=&quot;#AVs%2c-HVs-and-undefined-values&quot;&gt;AV, HV 및 정의되지 않은 값 참조&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="88b9515cdbcd45bb30a5ed0507a9f79663403c03" translate="yes" xml:space="preserve">
          <source>Also, &lt;b&gt;in Perl 5.8.x and earlier&lt;/b&gt;, this pragma uses pseudo-hashes, the effect being that you can have objects with named fields which are as compact and as fast arrays to access, as long as the objects are accessed through properly typed variables.</source>
          <target state="translated">또한 &lt;b&gt;Perl 5.8.x 및 이전 버전&lt;/b&gt; 에서이 pragma는 유사 해시를 사용합니다. 결과적으로 객체가 올바르게 입력 된 변수를 통해 액세스되는 한 액세스 가능한 컴팩트하고 빠른 배열 인 명명 된 필드를 가진 객체를 가질 수 있습니다. .</target>
        </trans-unit>
        <trans-unit id="67b0ddab77dcdca452f298cae2c04c86ed3d38be" translate="yes" xml:space="preserve">
          <source>Also, &lt;code&gt;\c\&lt;i&gt;X&lt;/i&gt;&lt;/code&gt; yields &lt;code&gt; chr(28) . &quot;&lt;i&gt;X&lt;/i&gt;&quot;&lt;/code&gt; for any</source>
          <target state="translated">또한 &lt;code&gt;\c\&lt;i&gt;X&lt;/i&gt;&lt;/code&gt; &lt;code&gt; chr(28) . &quot;&lt;i&gt;X&lt;/i&gt;&quot;&lt;/code&gt; 산출 합니다. &quot; &lt;i&gt;X&lt;/i&gt; &quot; 는</target>
        </trans-unit>
        <trans-unit id="d7b7987422ffa4fcf0f2ef8eb8b0440e2263954b" translate="yes" xml:space="preserve">
          <source>Also, Case_Folding is accessible through the &lt;code&gt;/i&lt;/code&gt; modifier in regular expressions, the &lt;code&gt;\F&lt;/code&gt; transliteration escape, and the &lt;code&gt;&lt;a href=&quot;functions/fc&quot;&gt;fc&lt;/a&gt;&lt;/code&gt; operator.</source>
          <target state="translated">또한 Case_Folding은 &lt;code&gt;/i&lt;/code&gt; 수정자를 통해 정규식, &lt;code&gt;\F&lt;/code&gt; 음역 이스케이프 및 &lt;code&gt;&lt;a href=&quot;functions/fc&quot;&gt;fc&lt;/a&gt;&lt;/code&gt; 연산자를 통해 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d028de5400e80b7bddfc22d550144658f5c96f35" translate="yes" xml:space="preserve">
          <source>Also, Case_Folding is accessible through the &lt;code&gt;/i&lt;/code&gt; modifier in regular expressions, the &lt;code&gt;\F&lt;/code&gt; transliteration escape, and the &lt;code&gt;&lt;a href=&quot;perlfunc#fc&quot;&gt;fc&lt;/a&gt;&lt;/code&gt; operator.</source>
          <target state="translated">또한 Case_Folding은 정규식 의 &lt;code&gt;/i&lt;/code&gt; 수정 자, &lt;code&gt;\F&lt;/code&gt; 음역 이스케이프 및 &lt;code&gt;&lt;a href=&quot;perlfunc#fc&quot;&gt;fc&lt;/a&gt;&lt;/code&gt; 연산자를 통해 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="329290910e0fbb3b491e01928584618de2f21b4e" translate="yes" xml:space="preserve">
          <source>Also, Configure might abort with</source>
          <target state="translated">또한 구성이 중단 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dbf6f9732bd6d02a3c14e683c3aa4b4c3c151f41" translate="yes" xml:space="preserve">
          <source>Also, a &lt;code&gt;&quot;r&quot;&lt;/code&gt; and/or &lt;code&gt;&quot;w&quot;&lt;/code&gt; in &lt;code&gt;$sMode&lt;/code&gt; is used to decide how the file descriptor is converted into a Perl file handle, even though this doesn't appear to make a difference. One of the following is used:</source>
          <target state="translated">또한, &lt;code&gt;&quot;r&quot;&lt;/code&gt; 및 / 또는 &lt;code&gt;&quot;w&quot;&lt;/code&gt; 에 &lt;code&gt;$sMode&lt;/code&gt; 파일 기술자가이 차이를 만들 표시되지 않는 경우에도, 펄 파일 핸들로 변환하는 방법을 결정하는 데 사용됩니다. 다음 중 하나가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="1e804a10723cc82e329f560a2f2a4e122d8ad225" translate="yes" xml:space="preserve">
          <source>Also, a backslash followed by two or three octal digits is considered an octal number.</source>
          <target state="translated">또한 백 슬래시 다음에 두 세 자리의 8 진수가 8 진수로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="931d2aa4d5ca7dba171a5dba8982f8a76fb7815e" translate="yes" xml:space="preserve">
          <source>Also, as of Perl 5.30, delimiters which are unassigned code points but that may someday become assigned are prohibited. Otherwise, code that works today would fail to compile if the currently unassigned delimiter ends up being something that isn't a stand-alone grapheme. Because Unicode is never going to assign &lt;a href=&quot;perlunicode#Noncharacter-code-points&quot;&gt;non-character code points&lt;/a&gt;, nor &lt;a href=&quot;perlunicode#Beyond-Unicode-code-points&quot;&gt;code points that are above the legal Unicode maximum&lt;/a&gt;, those can be delimiters.</source>
          <target state="translated">또한 Perl 5.30부터는 할당되지 않은 코드 포인트이지만 언젠가 할당 될 수있는 구분 기호는 금지됩니다. 그렇지 않으면 현재 할당되지 않은 구분 기호가 독립형 자소가 아닌 것으로 끝날 경우 오늘날 작동하는 코드는 컴파일되지 않습니다. 유니 코드는 &lt;a href=&quot;perlunicode#Noncharacter-code-points&quot;&gt;문자가 아닌 코드 포인트&lt;/a&gt; 나 &lt;a href=&quot;perlunicode#Beyond-Unicode-code-points&quot;&gt;합법적 인 유니 코드 최대 값을 초과하는 코드 포인트를&lt;/a&gt; 절대 할당 하지 않으므로 구분 기호가 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6cc421c7386da7b14eefaf275d4a113f5c542cb3" translate="yes" xml:space="preserve">
          <source>Also, both these methods currently allow only single characters to be named. To name a sequence of characters, use a &lt;a href=&quot;#CUSTOM-TRANSLATORS&quot;&gt;custom translator&lt;/a&gt; (described below).</source>
          <target state="translated">또한이 두 가지 방법 모두 현재 단일 문자 만 이름 지정할 수 있습니다. 일련의 문자 이름을 지정하려면 &lt;a href=&quot;#CUSTOM-TRANSLATORS&quot;&gt;사용자 정의 번역기를&lt;/a&gt; 사용하십시오 (아래 설명 참조).</target>
        </trans-unit>
        <trans-unit id="0b19a92a5a63a3defc0247ff7123f75e1b423945" translate="yes" xml:space="preserve">
          <source>Also, calling &amp;amp;$coderef($lh, ...parameters...) can throw any sort of exception (if, say, code in that sub tries to divide by zero). But a very common exception occurs when you have Bracket Notation text that says to call a method &quot;foo&quot;, but there is no such method. (E.g., &quot;You have [qua&lt;b&gt;tn&lt;/b&gt;,_1,ball].&quot; will throw an exception on trying to call $lh-&amp;gt;qua&lt;b&gt;tn&lt;/b&gt;($_[1],'ball') -- you presumably meant &quot;quant&quot;.) &lt;code&gt;maketext&lt;/code&gt; catches these exceptions, but only to make the error message more readable, at which point it rethrows the exception.</source>
          <target state="translated">또한 &amp;amp; $ coderef ($ lh, ... parameters ...)를 호출하면 모든 종류의 예외가 발생할 수 있습니다 (예 : 해당 하위의 코드가 0으로 나누려고 시도하는 경우). 그러나 &quot;foo&quot;메소드를 호출하는 브라켓 표기법 텍스트가있을 때 매우 일반적인 예외가 발생하지만 그러한 메소드는 없습니다. (예 : &quot;[qua &lt;b&gt;tn&lt;/b&gt; , _1, ball].&quot;은 $ lh-&amp;gt; qua &lt;b&gt;tn&lt;/b&gt; ($ _ [1], 'ball') 을 호출 할 때 예외가 발생 합니다. 아마도 &quot;quant&quot;를 의미했을 것입니다. ) &lt;code&gt;maketext&lt;/code&gt; 는 이러한 예외를 포착하지만 오류 메시지를 더 읽기 쉽게하기 위해 예외를 다시 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="bd6593efc170267903ffe758130a7c9bc58d5233" translate="yes" xml:space="preserve">
          <source>Also, entries like</source>
          <target state="translated">또한 다음과 같은 항목</target>
        </trans-unit>
        <trans-unit id="74a420b208a6c382bb28f75840a5f1acef599188" translate="yes" xml:space="preserve">
          <source>Also, every C program that uses Perl must link in the</source>
          <target state="translated">또한 Perl을 사용하는 모든 C 프로그램은</target>
        </trans-unit>
        <trans-unit id="34500a88731ba3291ee1333607a6b7ca5f090a54" translate="yes" xml:space="preserve">
          <source>Also, feel free to play with experimental features. Run</source>
          <target state="translated">또한 실험적인 기능으로 자유롭게 연주하십시오. 운영</target>
        </trans-unit>
        <trans-unit id="efa6c1b4904cf64e5362ea949feda8f167d890cd" translate="yes" xml:space="preserve">
          <source>Also, for a somewhat finer-grained set of characters that are in programming language identifiers beyond the ASCII range, you may wish to instead use the more customized &lt;a href=&quot;#Unicode-Properties&quot;&gt;&quot;Unicode Properties&quot;&lt;/a&gt;, &lt;code&gt;\p{ID_Start}&lt;/code&gt;, &lt;code&gt;\p{ID_Continue}&lt;/code&gt;, &lt;code&gt;\p{XID_Start}&lt;/code&gt;, and &lt;code&gt;\p{XID_Continue}&lt;/code&gt;. See &lt;a href=&quot;http://unicode.org/reports/tr31&quot;&gt;http://unicode.org/reports/tr31&lt;/a&gt;.</source>
          <target state="translated">또한 ASCII 범위를 벗어난 프로그래밍 언어 식별자에있는 좀 더 세밀한 문자 집합의 경우 대신 사용자 정의 된 &lt;a href=&quot;#Unicode-Properties&quot;&gt;&quot;유니 코드 속성&quot;&lt;/a&gt; , &lt;code&gt;\p{ID_Start}&lt;/code&gt; , &lt;code&gt;\p{ID_Continue}&lt;/code&gt; , &lt;code&gt;\p{XID_Start}&lt;/code&gt; 및 &lt;code&gt;\p{XID_Continue}&lt;/code&gt; . &lt;a href=&quot;http://unicode.org/reports/tr31&quot;&gt;http://unicode.org/reports/tr31을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="7b8f99a26ea97ae4edab854723c19d8a2e3a7a2e" translate="yes" xml:space="preserve">
          <source>Also, for a somewhat finer-grained set of characters that are in programming language identifiers beyond the ASCII range, you may wish to instead use the more customized &lt;a href=&quot;#Unicode-Properties&quot;&gt;Unicode Properties&lt;/a&gt;, &lt;code&gt;\p{ID_Start}&lt;/code&gt; , &lt;code&gt;\p{ID_Continue}&lt;/code&gt; , &lt;code&gt;\p{XID_Start}&lt;/code&gt; , and &lt;code&gt;\p{XID_Continue}&lt;/code&gt; . See &lt;a href=&quot;http://unicode.org/reports/tr31&quot;&gt;http://unicode.org/reports/tr31&lt;/a&gt;.</source>
          <target state="translated">또한 ASCII 범위를 넘어 프로그래밍 언어 식별자에있는 좀 더 세밀한 문자 집합의 경우보다 사용자 지정된 &lt;a href=&quot;#Unicode-Properties&quot;&gt;유니 코드 속성&lt;/a&gt; , &lt;code&gt;\p{ID_Start}&lt;/code&gt; , &lt;code&gt;\p{ID_Continue}&lt;/code&gt; , &lt;code&gt;\p{XID_Start}&lt;/code&gt; 및 &lt;code&gt;\p{XID_Continue}&lt;/code&gt; . &lt;a href=&quot;http://unicode.org/reports/tr31&quot;&gt;http://unicode.org/reports/tr31을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ccef320717b4d17e6eccfe71944895dfdb94c8a6" translate="yes" xml:space="preserve">
          <source>Also, having valid values as keys becomes very useful if you set up an _AUTO lexicon. _AUTO lexicons are discussed in a later section.</source>
          <target state="translated">또한 _AUTO 사전을 설정하면 유효한 값을 키로 사용하는 것이 매우 유용합니다. _AUTO 사전은 이후 섹션에서 설명합니다.</target>
        </trans-unit>
        <trans-unit id="57c4e07e0cc219d38dd06e6e1bcf0b1ea8e52540" translate="yes" xml:space="preserve">
          <source>Also, if the SV passed to &lt;code&gt;mg_find&lt;/code&gt; or &lt;code&gt;mg_findext&lt;/code&gt; is not of type SVt_PVMG, Perl may core dump.</source>
          <target state="translated">또한, SV가 &lt;code&gt;mg_find&lt;/code&gt; 또는 &lt;code&gt;mg_findext&lt;/code&gt; 로 전달 된 SV가 SVt_PVMG 유형이 아닌 경우, Perl은 코어 덤프 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a715fbfabba33c1ab0f07edc90c111741da66e2f" translate="yes" xml:space="preserve">
          <source>Also, in binary properties, 'Yes', 'T', and 'True' are all synonyms for 'Y'. And 'No', 'F', and 'False' are all synonyms for 'N'. The table shows 'Y*' and 'N*' to indicate this, and doesn't have separate entries for the other possibilities. Note that not all properties which have values 'Yes' and 'No' are binary, and they have all their values spelled out without using this wild card, and a &lt;code&gt;NOT&lt;/code&gt; clause in their description that highlights their not being binary. These also require the compound form to match them, whereas true binary properties have both single and compound forms available.</source>
          <target state="translated">또한 이진 속성에서 'Yes', 'T'및 'True'는 모두 'Y'의 동의어입니다. '아니오', 'F'및 '거짓'은 모두 'N'의 동의어입니다. 표는이를 나타내는 'Y *'및 'N *'을 보여 주며 다른 가능성에 대한 별도의 항목이 없습니다. 값이 'Yes'및 'No'인 모든 특성이 이진은 &lt;code&gt;NOT&lt;/code&gt; ,이 와일드 카드를 사용하지 않고 모든 값을 철자 하고 설명에서 NOT 절은 이진이 아님을 강조 표시합니다. 이것들은 또한 그것들과 일치하는 복합 형태를 요구하는 반면, 진정한 이진 특성은 단일 및 복합 형태를 모두 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a00a976f777c7c9555d5a4f1c975df6f1666beb4" translate="yes" xml:space="preserve">
          <source>Also, in the context of &lt;b&gt;Unicode&lt;/b&gt;, a writing system for a particular language or group of languages, such as Greek, Bengali, or Tengwar.</source>
          <target state="translated">또한 &lt;b&gt;유니 코드&lt;/b&gt; 와 관련하여 그리스어, 벵골어 또는 텡와 르와 같은 특정 언어 또는 언어 그룹에 대한 쓰기 시스템입니다.</target>
        </trans-unit>
        <trans-unit id="d74824efd3c4979bad6a6f8c4e477bf4cb023fd4" translate="yes" xml:space="preserve">
          <source>Also, it's worth noting that patterns defined this way probably will not be as efficient, as the optimizer is not very clever about handling them.</source>
          <target state="translated">또한, 이런 방식으로 정의 된 패턴은 아마 옵티마이 저가 그 패턴을 다루는 것에 대해 영리하지 않기 때문에 비효율적 일 것입니다.</target>
        </trans-unit>
        <trans-unit id="487cc7057b2c00a1fbc251ce9c403787bcbb592b" translate="yes" xml:space="preserve">
          <source>Also, lines should not be split within &lt;code&gt;CRLF&lt;/code&gt; (i.e. there is no empty line between &lt;code&gt;\r&lt;/code&gt; and &lt;code&gt;\n&lt;/code&gt; ). For &lt;code&gt;CRLF&lt;/code&gt; , try the &lt;code&gt;:crlf&lt;/code&gt; layer (see &lt;a href=&quot;perlio&quot;&gt;PerlIO&lt;/a&gt;).</source>
          <target state="translated">또한 &lt;code&gt;CRLF&lt;/code&gt; 내에서 행을 분할해서는 안됩니다 (예 : &lt;code&gt;\r&lt;/code&gt; 과 &lt;code&gt;\n&lt;/code&gt; 사이에 빈 행이 없음 ). 들어 &lt;code&gt;CRLF&lt;/code&gt; 의 시도 &lt;code&gt;:crlf&lt;/code&gt; (참조 계층 &lt;a href=&quot;perlio&quot;&gt;은 PerlIO을&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="f3992030bd7e3a922eb5df07ea510b7432d80298" translate="yes" xml:space="preserve">
          <source>Also, lines should not be split within &lt;code&gt;CRLF&lt;/code&gt; (i.e. there is no empty line between &lt;code&gt;\r&lt;/code&gt; and &lt;code&gt;\n&lt;/code&gt;). For &lt;code&gt;CRLF&lt;/code&gt;, try the &lt;code&gt;:crlf&lt;/code&gt; layer (see &lt;a href=&quot;perlio&quot;&gt;PerlIO&lt;/a&gt;).</source>
          <target state="translated">또한 행을 &lt;code&gt;CRLF&lt;/code&gt; 내에서 분할해서는 안됩니다 (즉, &lt;code&gt;\r&lt;/code&gt; 과 &lt;code&gt;\n&lt;/code&gt; 사이에 빈 행이 없어야합니다 ). 들어 &lt;code&gt;CRLF&lt;/code&gt; 의 시도 &lt;code&gt;:crlf&lt;/code&gt; (참조 계층 &lt;a href=&quot;perlio&quot;&gt;은 PerlIO을&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="63323aa4e4ec3045e43bf822a9f6601fadcf053b" translate="yes" xml:space="preserve">
          <source>Also, negative signal values don't do anything special under VMS; they're just converted to the corresponding positive value.</source>
          <target state="translated">또한 음의 신호 값은 VMS에서 특별한 작업을 수행하지 않습니다. 그들은 단지 해당 양수 값으로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="6a350d1c09fc9665a8e389e53064c822190440b0" translate="yes" xml:space="preserve">
          <source>Also, note that using the file tests for security purposes is a lost cause from the start: there is a window open for race conditions (who is to say that the permissions will not change between the test and the real operation?). Therefore if you are serious about security, just try the real operation and test for its success - think in terms of atomic operations. Filetests are more useful for filesystem administrative tasks, when you have no need for the content of the elements on disk.</source>
          <target state="translated">또한 보안 목적으로 파일 테스트를 사용하는 것은 시작부터 잃어버린 원인입니다. 경쟁 조건에 대한 창이 열려 있습니다 (누가 테스트와 실제 작업간에 권한이 변경되지 않습니까?). 따라서 보안에 대해 진지한 경우 실제 작업을 시도하고 성공 여부를 테스트하십시오. 원자 작업 측면에서 생각하십시오. 파일 테스트는 디스크의 요소 내용이 필요없는 파일 시스템 관리 작업에 더 유용합니다.</target>
        </trans-unit>
        <trans-unit id="d574d865815009daf05f1054bf415b0bf6943266" translate="yes" xml:space="preserve">
          <source>Also, note the following:</source>
          <target state="translated">또한 다음 사항에 유의하십시오.</target>
        </trans-unit>
        <trans-unit id="48ddb81f1627e1f3a6389ef3f6f1aa66ba367e47" translate="yes" xml:space="preserve">
          <source>Also, once a project is otherwise complete and you start to localize it, you can scrape together all the various keys you use, and pass it to a translator; and then the translator's work will go faster if what he's presented is this:</source>
          <target state="translated">또한 프로젝트가 완료되고 현지화가 시작되면 사용하는 다양한 키를 모두 긁어 번역기에 전달할 수 있습니다. 그리고 그가 제시 한 내용이 다음과 같으면 번역사의 작업이 더 빨라질 것입니다.</target>
        </trans-unit>
        <trans-unit id="25de230710079ae2e7ac75bdcf59f8719d1c3ed7" translate="yes" xml:space="preserve">
          <source>Also, perl can be recompiled to operate on an earlier version of the Unicode standard. Further information is at &lt;code&gt;$Config{privlib}&lt;/code&gt; /</source>
          <target state="translated">또한 perl은 이전 버전의 유니 코드 표준에서 작동하도록 재 컴파일 될 수 있습니다. 자세한 정보는 &lt;code&gt;$Config{privlib}&lt;/code&gt; /</target>
        </trans-unit>
        <trans-unit id="b542e84834d4e9866d33acb374e33e8f660c85fa" translate="yes" xml:space="preserve">
          <source>Also, perl can be recompiled to operate on an earlier version of the Unicode standard. Further information is at &lt;code&gt;$Config{privlib}&lt;/code&gt;/</source>
          <target state="translated">또한 이전 버전의 유니 코드 표준에서 작동하도록 perl을 다시 컴파일 할 수 있습니다. 자세한 정보는 &lt;code&gt;$Config{privlib}&lt;/code&gt; /</target>
        </trans-unit>
        <trans-unit id="76997e16af65c741ca3a61aadd72db51de092e73" translate="yes" xml:space="preserve">
          <source>Also, since &lt;code&gt;$x&lt;/code&gt; is lexical, it can't be reached or modified by any Perl code outside.</source>
          <target state="translated">또한 &lt;code&gt;$x&lt;/code&gt; 는 어휘이므로 외부의 Perl 코드로 도달하거나 수정할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="38f33518e3f4f0a218000c4a9eb29242c2ff03c6" translate="yes" xml:space="preserve">
          <source>Also, since the number of opcodes in your current version of perl might not be an exact multiple of eight, there may be unused bits in the last byte of an upset. This should not cause any problems (Opcode functions ignore those extra bits) but it does mean that using the ~ operator will typically not produce the same 'physical' opset 'string' as the invert_opset function.</source>
          <target state="translated">또한 현재 버전의 perl에서 opcode의 수는 정확히 8의 배수가 아닐 수 있으므로 마지막 바이트에는 사용되지 않은 비트가있을 수 있습니다. 이로 인해 문제가 발생하지 않아야합니다 (오퍼 코드 함수는 추가 비트를 무시합니다). ~ 연산자를 사용하면 일반적으로 invert_opset 함수와 동일한 '물리적'옵셋 '문자열'이 생성되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3ed7ac3c49479a3dd530e1364bfdfcfdef42d4e9" translate="yes" xml:space="preserve">
          <source>Also, some common socket &quot;newline&quot; constants are provided: the constants &lt;code&gt;CR&lt;/code&gt; , &lt;code&gt;LF&lt;/code&gt; , and &lt;code&gt;CRLF&lt;/code&gt; , as well as &lt;code&gt;$CR&lt;/code&gt; , &lt;code&gt;$LF&lt;/code&gt; , and &lt;code&gt;$CRLF&lt;/code&gt; , which map to &lt;code&gt;\015&lt;/code&gt; , &lt;code&gt;\012&lt;/code&gt; , and &lt;code&gt;\015\012&lt;/code&gt; . If you do not want to use the literal characters in your programs, then use the constants provided here. They are not exported by default, but can be imported individually, and with the &lt;code&gt;:crlf&lt;/code&gt; export tag:</source>
          <target state="translated">또한 일부 공통 소켓 &quot;개행&quot;상수가 제공됩니다. 상수 &lt;code&gt;CR&lt;/code&gt; , &lt;code&gt;LF&lt;/code&gt; 및 &lt;code&gt;CRLF&lt;/code&gt; 뿐만 아니라 &lt;code&gt;$CR&lt;/code&gt; , &lt;code&gt;$LF&lt;/code&gt; 및 &lt;code&gt;$CRLF&lt;/code&gt; 는 &lt;code&gt;\015&lt;/code&gt; , &lt;code&gt;\012&lt;/code&gt; 및 &lt;code&gt;\015\012&lt;/code&gt; 매핑됩니다 . 프로그램에서 리터럴 문자를 사용하지 않으려면 여기에 제공된 상수를 사용하십시오. 기본적으로 내보내지는 않지만 &lt;code&gt;:crlf&lt;/code&gt; 내보내기 태그를 사용하여 개별적으로 가져올 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="09c79652fdab8435dc64bf1d503eb44817957310" translate="yes" xml:space="preserve">
          <source>Also, some common socket &quot;newline&quot; constants are provided: the constants &lt;code&gt;CR&lt;/code&gt;, &lt;code&gt;LF&lt;/code&gt;, and &lt;code&gt;CRLF&lt;/code&gt;, as well as &lt;code&gt;$CR&lt;/code&gt;, &lt;code&gt;$LF&lt;/code&gt;, and &lt;code&gt;$CRLF&lt;/code&gt;, which map to &lt;code&gt;\015&lt;/code&gt;, &lt;code&gt;\012&lt;/code&gt;, and &lt;code&gt;\015\012&lt;/code&gt;. If you do not want to use the literal characters in your programs, then use the constants provided here. They are not exported by default, but can be imported individually, and with the &lt;code&gt;:crlf&lt;/code&gt; export tag:</source>
          <target state="translated">또한 몇 가지 공통 소켓 &quot;개행&quot;상수가 제공됩니다. &lt;code&gt;CR&lt;/code&gt; , &lt;code&gt;LF&lt;/code&gt; 및 &lt;code&gt;CRLF&lt;/code&gt; 상수 와 &lt;code&gt;\015&lt;/code&gt; , &lt;code&gt;\012&lt;/code&gt; 및 &lt;code&gt;\015\012&lt;/code&gt; 매핑 되는 &lt;code&gt;$CR&lt;/code&gt; , &lt;code&gt;$LF&lt;/code&gt; 및 &lt;code&gt;$CRLF&lt;/code&gt; . 프로그램에서 리터럴 문자를 사용하지 않으려면 여기에 제공된 상수를 사용하십시오. 기본적으로 내보내지지는 않지만 개별적으로 가져올 수 있으며 &lt;code&gt;:crlf&lt;/code&gt; export 태그를 사용하여 가져올 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="13c4a82fda1ed827381af159c98e8fcbdf05900b" translate="yes" xml:space="preserve">
          <source>Also, some special instructions for building Perl with Sun Studio on Linux. Following the normal &lt;code&gt;Configure&lt;/code&gt; , you have to run make as follows:</source>
          <target state="translated">또한 Linux에서 Sun Studio를 사용하여 Perl을 빌드하는 데 필요한 특별 지시 사항이 있습니다. 일반적인 &lt;code&gt;Configure&lt;/code&gt; 다음에 다음과 같이 make를 실행해야합니다.</target>
        </trans-unit>
        <trans-unit id="430b83395a22758023df144cbbf527affef6a44c" translate="yes" xml:space="preserve">
          <source>Also, subroutines could be declared with the &lt;code&gt;:locked&lt;/code&gt; attribute which would serialize access to the subroutine, but allowed different threads non-simultaneous access.</source>
          <target state="translated">또한 서브 루틴은 서브 루틴에 대한 액세스를 직렬화 하는 &lt;code&gt;:locked&lt;/code&gt; 속성 으로 선언 할 수 있지만 다른 스레드가 동시에 액세스 할 수는 없습니다.</target>
        </trans-unit>
        <trans-unit id="f700fce01f8bef830aa30a8774e7a762bfbaf65f" translate="yes" xml:space="preserve">
          <source>Also, the internal representation of Time::Piece-&amp;gt;strftime deviates from the standard POSIX implementation in that is uses the epoch (instead of separate year, month, day parts). This change was added in version 1.30. If you must have a more traditional strftime (which will normally never calculate day light saving times correctly), you can pass the date parts from Time::Piece into the strftime function provided by the POSIX module (see strftime in &lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt; ).</source>
          <target state="translated">또한 Time :: Piece-&amp;gt; strftime의 내부 표현은 (별도의 연도, 월, 일 부분 대신) epoch를 사용한다는 점에서 표준 POSIX 구현에서 벗어납니다. 이 변경 사항은 버전 1.30에서 추가되었습니다. 좀 더 전통적인 strftime (일반적으로 일광 절약 시간을 올바르게 계산하지 않음)이 있어야하는 경우 Time :: Piece의 날짜 부분을 POSIX 모듈에서 제공하는 strftime 함수로 전달할 수 있습니다 ( &lt;a href=&quot;posix&quot;&gt;POSIX의&lt;/a&gt; strftime 참조 ).</target>
        </trans-unit>
        <trans-unit id="e7201d576462a40ab9a535c50ec57d12c94dd4c2" translate="yes" xml:space="preserve">
          <source>Also, the object is configured such that it stringifies to the name of the temporary file and so can be compared to a filename directly. It numifies to the &lt;code&gt;refaddr&lt;/code&gt; the same as other handles and so can be compared to other handles with &lt;code&gt;==&lt;/code&gt;.</source>
          <target state="translated">또한 개체는 임시 파일의 이름으로 문자열 화되어 파일 이름과 직접 비교할 수 있도록 구성됩니다. 다른 핸들과 동일하게 &lt;code&gt;refaddr&lt;/code&gt; 에 번호를 부여 하므로 &lt;code&gt;==&lt;/code&gt; 를 사용 하여 다른 핸들과 비교할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="cdb14deb83dae5ba493a96acfadaf1236cbdc5ea" translate="yes" xml:space="preserve">
          <source>Also, the object is configured such that it stringifies to the name of the temporary file and so can be compared to a filename directly. It numifies to the C</source>
          <target state="translated">또한 개체는 임시 파일 이름으로 문자열 화되어 파일 이름과 직접 비교 될 수 있도록 구성됩니다. 그것은 C로 번호를 매 깁니다</target>
        </trans-unit>
        <trans-unit id="913c9e19c71d84db5eb4e7b9fa93a06fccc33227" translate="yes" xml:space="preserve">
          <source>Also, the range 'A' - 'Z' in ASCII is an unbroken sequence of 26 upper case alphabetic characters. That is not true in EBCDIC. Nor for 'a' to 'z'. But '0' - '9' is an unbroken range in both systems. Don't assume anything about other ranges. (Note that special handling of ranges in regular expression patterns and transliterations makes it appear to Perl code that the aforementioned ranges are all unbroken.)</source>
          <target state="translated">또한 ASCII의 'A'- 'Z'범위는 26 개의 알파벳 대문자로 구성된 끊김없는 시퀀스입니다. EBCDIC에서는 그렇지 않습니다. 'a'에서 'z'까지도 마찬가지입니다. 그러나 '0'- '9'는 두 시스템 모두에서 깨지지 않은 범위입니다. 다른 범위에 대해 아무것도 가정하지 마십시오. (정규식 패턴 및 음역에서 범위를 특수하게 처리하면 앞서 언급 한 범위가 모두 손상되지 않은 것으로 Perl 코드에 나타납니다.)</target>
        </trans-unit>
        <trans-unit id="ad7807da341a2e1187eef533ebec80cd0117d203" translate="yes" xml:space="preserve">
          <source>Also, the range 'A' - 'Z' in ASCII is an unbroken sequence of 26 upper case alphabetic characters. That is not true in EBCDIC. Nor for 'a' to 'z'. But '0' - '9' is an unbroken range in both systems. Don't assume anything about other ranges. (Note that special handling of ranges in regular expression patterns makes it appear to Perl code that the aforementioned ranges are all unbroken.)</source>
          <target state="translated">또한 ASCII에서 'A'- 'Z'범위는 26 자의 대문자 알파벳 문자로 구성됩니다. EBCDIC에서는 그렇지 않습니다. 'a'에서 'z'도 마찬가지입니다. 그러나 '0'- '9'는 두 시스템 모두에서 중단되지 않은 범위입니다. 다른 범위에 대해서는 아무 것도 가정하지 마십시오. (정규 표현식 패턴에서 범위를 특수하게 처리하면 위에서 언급 한 범위가 모두 깨지지 않은 것이 Perl 코드에 나타납니다.)</target>
        </trans-unit>
        <trans-unit id="ed48bbc731848457db80d2fadad2fe9e698169b3" translate="yes" xml:space="preserve">
          <source>Also, the use of Unicode may present security issues that aren't obvious, see &lt;a href=&quot;#Security-Implications-of-Unicode&quot;&gt;&quot;Security Implications of Unicode&quot;&lt;/a&gt; below.</source>
          <target state="translated">또한 유니 코드를 사용하면 분명하지 않은 보안 문제가 발생할 수 있습니다. 아래 &lt;a href=&quot;#Security-Implications-of-Unicode&quot;&gt;&quot;유니 코드의 보안 의미&quot;를&lt;/a&gt; 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="11e213d7b8a81bd451ffb3f3ae8fa862e904a6c3" translate="yes" xml:space="preserve">
          <source>Also, the use of Unicode may present security issues that aren't obvious. Read &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fwww.unicode.org%2freports%2ftr36&quot;&gt;Unicode Security Considerations&lt;/a&gt;.</source>
          <target state="translated">또한 유니 코드를 사용하면 명확하지 않은 보안 문제가 발생할 수 있습니다. &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fwww.unicode.org%2freports%2ftr36&quot;&gt;유니 코드 보안 고려 사항을&lt;/a&gt; 읽으십시오 .</target>
        </trans-unit>
        <trans-unit id="5a6ddd5f6cea51490776d1ee7aa46674933e080d" translate="yes" xml:space="preserve">
          <source>Also, under this modifier, case-insensitive matching works on the full set of Unicode characters. The &lt;code&gt;KELVIN SIGN&lt;/code&gt; , for example matches the letters &quot;k&quot; and &quot;K&quot;; and &lt;code&gt;LATIN SMALL LIGATURE FF&lt;/code&gt; matches the sequence &quot;ff&quot;, which, if you're not prepared, might make it look like a hexadecimal constant, presenting another potential security issue. See &lt;a href=&quot;http://unicode.org/reports/tr36&quot;&gt;http://unicode.org/reports/tr36&lt;/a&gt; for a detailed discussion of Unicode security issues.</source>
          <target state="translated">또한이 수정 자에서 대소 문자를 구분하지 않는 일치는 전체 유니 코드 문자 세트에서 작동합니다. &lt;code&gt;KELVIN SIGN&lt;/code&gt; 예에서는, 문자 &quot;K&quot;및 &quot;K&quot;를 일치; 및 &lt;code&gt;LATIN SMALL LIGATURE FF&lt;/code&gt; , 당신이 준비하지 않는 경우, 또 다른 잠재적 인 보안 문제를 제시, 16 진수 상수처럼 보이게 수있는 순서 &quot;FF&quot;를 일치합니다. 유니 코드 보안 문제에 대한 자세한 내용은 &lt;a href=&quot;http://unicode.org/reports/tr36&quot;&gt;http://unicode.org/reports/tr36&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="082c639d640961ab2741dc8437aea7d26245da44" translate="yes" xml:space="preserve">
          <source>Also, under this modifier, case-insensitive matching works on the full set of Unicode characters. The &lt;code&gt;KELVIN SIGN&lt;/code&gt;, for example matches the letters &quot;k&quot; and &quot;K&quot;; and &lt;code&gt;LATIN SMALL LIGATURE FF&lt;/code&gt; matches the sequence &quot;ff&quot;, which, if you're not prepared, might make it look like a hexadecimal constant, presenting another potential security issue. See &lt;a href=&quot;https://unicode.org/reports/tr36&quot;&gt;https://unicode.org/reports/tr36&lt;/a&gt; for a detailed discussion of Unicode security issues.</source>
          <target state="translated">또한이 수정 자에서 대소 문자를 구분하지 않는 일치는 전체 유니 코드 문자 세트에서 작동합니다. &lt;code&gt;KELVIN SIGN&lt;/code&gt; 예에서는, 문자 &quot;K&quot;및 &quot;K&quot;를 일치; 및 &lt;code&gt;LATIN SMALL LIGATURE FF&lt;/code&gt; , 당신이 준비하지 않는 경우, 또 다른 잠재적 인 보안 문제를 제시, 16 진수 상수처럼 보이게 수있는 순서 &quot;FF&quot;를 일치합니다. 유니 코드 보안 문제에 대한 자세한 내용은 &lt;a href=&quot;https://unicode.org/reports/tr36&quot;&gt;https://unicode.org/reports/tr36&lt;/a&gt; 을 참조 하십시오 .</target>
        </trans-unit>
        <trans-unit id="7d458ad7a020a232313ae8d56db7bcab0ded5305" translate="yes" xml:space="preserve">
          <source>Also, various synonyms like &lt;code&gt;\p{Alpha}&lt;/code&gt; for &lt;code&gt;\p{XPosixAlpha}&lt;/code&gt; ; all listed in &lt;a href=&quot;perluniprops#Properties-accessible-through-%5cp%7b%7d-and-%5cP%7b%7d&quot;&gt;Properties accessible through \p{} and \P{} in perluniprops&lt;/a&gt;</source>
          <target state="translated">또한, 같은 다양한 동의어 &lt;code&gt;\p{Alpha}&lt;/code&gt; 위한 &lt;code&gt;\p{XPosixAlpha}&lt;/code&gt; ; &lt;a href=&quot;perluniprops#Properties-accessible-through-%5cp%7b%7d-and-%5cP%7b%7d&quot;&gt;perluniprops의 \ p {} 및 \ P {}를 통해 액세스 할 수&lt;/a&gt; 있는 속성에 모두 나열 됨</target>
        </trans-unit>
        <trans-unit id="185cbf92e7b7051aa2f9930ee2ca151063ceb454" translate="yes" xml:space="preserve">
          <source>Also, various synonyms like &lt;code&gt;\p{Alpha}&lt;/code&gt; for &lt;code&gt;\p{XPosixAlpha}&lt;/code&gt;; all listed in &lt;a href=&quot;perluniprops#Properties-accessible-through-%5Cp%7B%7D-and-%5CP%7B%7D&quot;&gt;&quot;Properties accessible through \p{} and \P{}&quot; in perluniprops&lt;/a&gt;</source>
          <target state="translated">또한 &lt;code&gt;\p{XPosixAlpha}&lt;/code&gt; 대한 \ p { &lt;code&gt;\p{Alpha}&lt;/code&gt; 와 같은 다양한 동의어 ; &lt;a href=&quot;perluniprops#Properties-accessible-through-%5Cp%7B%7D-and-%5CP%7B%7D&quot;&gt;perluniprops의 &quot;\ p {} 및 \ P {}를 통해 액세스 할 수있는 속성&quot;에&lt;/a&gt; 나열된 모든 항목</target>
        </trans-unit>
        <trans-unit id="3fd51e4e1d10037d178287b3c2e52d39f31c50f2" translate="yes" xml:space="preserve">
          <source>Also, when your</source>
          <target state="translated">또한</target>
        </trans-unit>
        <trans-unit id="94df63c3696c6e9f216a0b26ed643a62ffdfe44b" translate="yes" xml:space="preserve">
          <source>Also, white space, hyphens, and underscores are normally ignored everywhere between the {braces}, and hence can be freely added or removed even if the &lt;code&gt;/x&lt;/code&gt; modifier hasn't been specified on the regular expression. But in the table below a '&lt;b&gt;T&lt;/b&gt;' at the beginning of an entry means that tighter (stricter) rules are used for that entry:</source>
          <target state="translated">또한 공백, 하이픈 및 밑줄은 일반적으로 {braces} 사이의 모든 위치에서 무시되므로 &lt;code&gt;/x&lt;/code&gt; 정규식에 / x 수정자가 지정되지 않은 . 그러나 아래 표 에서 항목 시작 부분의 ' &lt;b&gt;T&lt;/b&gt; '는 해당 항목에 더 엄격한 규칙이 사용됨을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="87ea7db4a430030d90185495584807fc225cd906" translate="yes" xml:space="preserve">
          <source>Also:</source>
          <target state="translated">Also:</target>
        </trans-unit>
        <trans-unit id="554a943cef6b1565f2a13a13d21f280b671c0db6" translate="yes" xml:space="preserve">
          <source>Alter regular expression behaviour</source>
          <target state="translated">정규식 동작 변경</target>
        </trans-unit>
        <trans-unit id="4b26f888988c3f23411577d380346f5e87008e97" translate="yes" xml:space="preserve">
          <source>Alternate Stack Manipulation</source>
          <target state="translated">대체 스택 조작</target>
        </trans-unit>
        <trans-unit id="baff84fe31ffd586fd0cbbd5cab56329f0775d04" translate="yes" xml:space="preserve">
          <source>Alternate form of specifying the local address to &lt;code&gt;bind()&lt;/code&gt; to. This should be an array of the form returned by &lt;code&gt;Socket::getaddrinfo&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;bind()&lt;/code&gt; 할 로컬 주소를 지정하는 대체 형식입니다 . &lt;code&gt;Socket::getaddrinfo&lt;/code&gt; 반환 한 형식의 배열이어야합니다 .</target>
        </trans-unit>
        <trans-unit id="0db36f7208c555076a29994a086e6ad6fe2b6c88" translate="yes" xml:space="preserve">
          <source>Alternate form of specifying the peer to &lt;code&gt;connect()&lt;/code&gt; to. This should be an array of the form returned by &lt;code&gt;Socket::getaddrinfo&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;connect()&lt;/code&gt; 피어를 지정하는 대체 형식입니다 . &lt;code&gt;Socket::getaddrinfo&lt;/code&gt; 반환 한 형식의 배열이어야합니다 .</target>
        </trans-unit>
        <trans-unit id="4495ae5a9f0394b58820a885d0978ae962fd139c" translate="yes" xml:space="preserve">
          <source>Alternately I can pass an open filehandle as source and have the parser read from that rather than attempting to run a test script:</source>
          <target state="translated">또는 열려있는 파일 핸들을 소스로 전달하고 파서가 테스트 스크립트를 실행하려고 시도하지 않고 읽도록 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bb5fc16ac82340f31ba65517d29fc05e91506541" translate="yes" xml:space="preserve">
          <source>Alternately I can supply the names of my substitute classes to the TAP::Harness constructor:</source>
          <target state="translated">또는 TAP :: Harness 생성자에 대체 클래스의 이름을 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9227d0ca3877e84e35d83f9ac364f43162e4ef9e" translate="yes" xml:space="preserve">
          <source>Alternately, if the language used to write my tests allows a shebang line I can use that to specify the interpreter. Here's a test written in PHP:</source>
          <target state="translated">또는 테스트를 작성하는 데 사용 된 언어가 shebang 라인을 허용하는 경우이를 사용하여 인터프리터를 지정할 수 있습니다. 다음은 PHP로 작성된 테스트입니다.</target>
        </trans-unit>
        <trans-unit id="fd038ee8b646edddd400b75f62f9db870f503cd5" translate="yes" xml:space="preserve">
          <source>Alternately, if you have an SV that is a blessed reference, you can find out the stash pointer by using:</source>
          <target state="translated">또는 복된 참조 인 SV가있는 경우 다음을 사용하여 숨김 포인터를 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6589e5a8ee283a61027f2499ac81f9bd22f55b5a" translate="yes" xml:space="preserve">
          <source>Alternately, if you import &lt;code&gt;:constants&lt;/code&gt; , you can use the following constants directly:</source>
          <target state="translated">또는 &lt;code&gt;:constants&lt;/code&gt; 를 가져 오는 경우 다음 상수를 직접 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8a245817c61d1ffafbf0a5d7c18cd6a72b400a7e" translate="yes" xml:space="preserve">
          <source>Alternately, if you import &lt;code&gt;:constants&lt;/code&gt;, you can use the following constants directly:</source>
          <target state="translated">또는 &lt;code&gt;:constants&lt;/code&gt; 를 가져 오는 경우 다음 상수를 직접 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3835ce5fac7a47f4550c37daaf24821ea36a9658" translate="yes" xml:space="preserve">
          <source>Alternately, if you use OS/2-ish shell, like CMD or 4os2, put the following at the start of your perl script:</source>
          <target state="translated">또는 CMD 또는 4os2와 같은 OS / 2-ish 쉘을 사용하는 경우 perl 스크립트의 시작 부분에 다음을 입력하십시오.</target>
        </trans-unit>
        <trans-unit id="3c02b30c04d1bd2e064bba714a6c966f7e7001cc" translate="yes" xml:space="preserve">
          <source>Alternately, try running pod2text on</source>
          <target state="translated">또는 pod2text를 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="c6586bf995507ef47c1e8462c0b96f9bda48432b" translate="yes" xml:space="preserve">
          <source>Alternately, you can change to binary mode on an existing handle this way:</source>
          <target state="translated">또는 기존 핸들에서이 방법으로 이진 모드로 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="436c604fc9e91f4036987513f30ceb0b117df526" translate="yes" xml:space="preserve">
          <source>Alternately, you can set the global variable &lt;code&gt;$Carp::Verbose&lt;/code&gt; to true. See the &lt;code&gt;GLOBAL VARIABLES&lt;/code&gt; section below.</source>
          <target state="translated">또는 전역 변수 &lt;code&gt;$Carp::Verbose&lt;/code&gt; 를 true로 설정할 수 있습니다 . 아래의 &lt;code&gt;GLOBAL VARIABLES&lt;/code&gt; 섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="15f2c59a8b9b5baf596fabaf5af782241acbedb6" translate="yes" xml:space="preserve">
          <source>Alternately, you can specify the exact directory to place the extension's files by placing a &quot;PREFIX=/destination/directory&quot; after the make install (or in between the make and install if you have a brain-dead version of make). This can be very useful if you are building an extension that will eventually be distributed to multiple systems. You can then just archive the files in the destination directory and distribute them to your destination systems.</source>
          <target state="translated">다른 방법으로, make 설치 후 (또는 make-brain Dead 버전이있는 경우 make와 install 사이에) &quot;PREFIX = / destination / directory&quot;를 배치하여 확장 파일을 배치 할 정확한 디렉토리를 지정할 수 있습니다. 이것은 결국 여러 시스템에 배포 될 확장을 구축 할 때 매우 유용합니다. 그런 다음 대상 디렉토리에 파일을 보관하고 대상 시스템에 배포 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e00c3a1ce8b9e2b0c7ee0051f3ec0d7cf8bcbdb9" translate="yes" xml:space="preserve">
          <source>Alternately, you can try to get a replacement for the system's &lt;b&gt;Execute&lt;/b&gt; command that honors the #!/usr/bin/perl syntax in scripts and set the s-Bit of your scripts. Then you can invoke your scripts like under UNIX with</source>
          <target state="translated">또는 스크립트의 #! / usr / bin / perl 구문 을 따르는 시스템의 &lt;b&gt;Execute&lt;/b&gt; 명령을 대체 하고 스크립트의 s-Bit을 설정할 수 있습니다. 그런 다음 UNIX에서와 같이 스크립트를 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="70b8f05f7796eca9b3373c7ecd058a653ad0409c" translate="yes" xml:space="preserve">
          <source>Alternately, you can use &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt;, the regular expression quote operator (see &lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt; for more details). It quotes and perhaps compiles the pattern, and you can apply regular expression flags to the pattern.</source>
          <target state="translated">또는 정규 표현식 따옴표 연산자 인 &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt; 사용할 수 있습니다 ( 자세한 내용 은 &lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt; 참조). 패턴을 인용하고 컴파일 할 수 있으며 패턴에 정규식 플래그를 적용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7d48931e8ff9955945645810ae372a2695434121" translate="yes" xml:space="preserve">
          <source>Alternately, you can use &lt;code&gt;qr//&lt;/code&gt;, the regular expression quote operator (see &lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt; for more details). It quotes and perhaps compiles the pattern, and you can apply regular expression flags to the pattern.</source>
          <target state="translated">또는 정규식 따옴표 연산자 인 &lt;code&gt;qr//&lt;/code&gt; 를 사용할 수 있습니다 ( 자세한 내용 은 &lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt; 참조). 패턴을 인용하고 컴파일하며 패턴에 정규식 플래그를 적용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5b04c7a5831dedb851aed975f051c1cac400682e" translate="yes" xml:space="preserve">
          <source>Alternation</source>
          <target state="translated">Alternation</target>
        </trans-unit>
        <trans-unit id="be9a6aa6691045b50a599c27892a7efaa458c7af" translate="yes" xml:space="preserve">
          <source>Alternation allows a regexp to choose among alternatives, but by itself it is unsatisfying. The reason is that each alternative is a whole regexp, but sometime we want alternatives for just part of a regexp. For instance, suppose we want to search for housecats or housekeepers. The regexp &lt;code&gt;housecat|housekeeper&lt;/code&gt; fits the bill, but is inefficient because we had to type &lt;code&gt;house&lt;/code&gt; twice. It would be nice to have parts of the regexp be constant, like &lt;code&gt;house&lt;/code&gt; , and some parts have alternatives, like &lt;code&gt;cat|keeper&lt;/code&gt; .</source>
          <target state="translated">대체는 정규 표현식이 다른 대안 중에서 선택할 수 있도록하지만 그 자체로는 만족스럽지 않습니다. 그 이유는 각 대안이 전체 정규 표현식이지만 때로는 정규 표현식의 일부에 대한 대안을 원하기 때문입니다. 예를 들어, 가정 고양이 나 가정부를 검색한다고 가정 해 봅시다. 정규식 &lt;code&gt;housecat|housekeeper&lt;/code&gt; 는 계산서에 적합하지만 &lt;code&gt;house&lt;/code&gt; 두 번 입력해야했기 때문에 비효율적 입니다. 정규 표현식의 일부를 &lt;code&gt;house&lt;/code&gt; 와 같이 일정하게 유지하는 것이 좋으며 일부 부분에는 &lt;code&gt;cat|keeper&lt;/code&gt; 과 같은 대안이 있습니다.</target>
        </trans-unit>
        <trans-unit id="2748d57020b2771f7481af94280b0d7745a90798" translate="yes" xml:space="preserve">
          <source>Alternation allows a regexp to choose among alternatives, but by itself it is unsatisfying. The reason is that each alternative is a whole regexp, but sometime we want alternatives for just part of a regexp. For instance, suppose we want to search for housecats or housekeepers. The regexp &lt;code&gt;housecat|housekeeper&lt;/code&gt; fits the bill, but is inefficient because we had to type &lt;code&gt;house&lt;/code&gt; twice. It would be nice to have parts of the regexp be constant, like &lt;code&gt;house&lt;/code&gt;, and some parts have alternatives, like &lt;code&gt;cat|keeper&lt;/code&gt;.</source>
          <target state="translated">대체를 사용하면 정규 표현식이 대안 중에서 선택할 수 있지만 그 자체로는 만족스럽지 않습니다. 그 이유는 각 대안이 전체 정규 표현식이지만 때로는 정규 표현식의 일부에 대한 대안이 필요하기 때문입니다. 예를 들어, 집 고양이 또는 집주인을 검색한다고 가정 해 보겠습니다. 정규 표현식 &lt;code&gt;housecat|housekeeper&lt;/code&gt; 는 계산서에 맞지만 &lt;code&gt;house&lt;/code&gt; 를 두 번 입력해야했기 때문에 비효율적 입니다. &lt;code&gt;house&lt;/code&gt; 와 같이 정규 표현식의 일부를 일정하게 유지 하고 일부는 &lt;code&gt;cat|keeper&lt;/code&gt; 와 같은 대안을 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="1cf43ccde7eeaee521a4a189652a63c1baacf5e0" translate="yes" xml:space="preserve">
          <source>Alternations behave the same way in groups as out of them: at a given string position, the leftmost alternative that allows the regexp to match is taken. So in the last example at the first string position, &lt;code&gt;&quot;20&quot;&lt;/code&gt; matches the second alternative, but there is nothing left over to match the next two digits &lt;code&gt;\d\d&lt;/code&gt; . So Perl moves on to the next alternative, which is the null alternative and that works, since &lt;code&gt;&quot;20&quot;&lt;/code&gt; is two digits.</source>
          <target state="translated">대체는 그룹에서와 동일한 방식으로 동작합니다. 주어진 문자열 위치에서 정규 표현식을 일치시킬 수있는 가장 왼쪽의 대안이 사용됩니다. 따라서 첫 번째 문자열 위치의 마지막 예에서 &lt;code&gt;&quot;20&quot;&lt;/code&gt; 은 두 번째 대안과 일치하지만 다음 두 자리 &lt;code&gt;\d\d&lt;/code&gt; 와 일치하는 것은 없습니다 . 따라서 Perl은 다음 대안으로 넘어갑니다. &lt;code&gt;&quot;20&quot;&lt;/code&gt; 이 두 자리 이기 때문에 null 대안이며 작동합니다 .</target>
        </trans-unit>
        <trans-unit id="ef0bb58311a4cc103103ca6beeb54a0245223e8c" translate="yes" xml:space="preserve">
          <source>Alternations behave the same way in groups as out of them: at a given string position, the leftmost alternative that allows the regexp to match is taken. So in the last example at the first string position, &lt;code&gt;&quot;20&quot;&lt;/code&gt; matches the second alternative, but there is nothing left over to match the next two digits &lt;code&gt;\d\d&lt;/code&gt;. So Perl moves on to the next alternative, which is the null alternative and that works, since &lt;code&gt;&quot;20&quot;&lt;/code&gt; is two digits.</source>
          <target state="translated">대체는 그룹에서 같은 방식으로 작동합니다. 주어진 문자열 위치에서 정규 표현식이 일치하도록 허용하는 가장 왼쪽의 대체가 사용됩니다. 따라서 첫 번째 문자열 위치의 마지막 예에서 &lt;code&gt;&quot;20&quot;&lt;/code&gt; 은 두 번째 대체 항목과 일치하지만 다음 두 자리 &lt;code&gt;\d\d&lt;/code&gt; 와 일치하는 항목이 남아 있지 않습니다 . 따라서 Perl은 &lt;code&gt;&quot;20&quot;&lt;/code&gt; 이 두 자리 숫자 이기 때문에 null 대안이고 작동하는 다음 대안으로 이동합니다 .</target>
        </trans-unit>
        <trans-unit id="d45912dbd856f0ddf337c48eab0e2b6ac8ae702c" translate="yes" xml:space="preserve">
          <source>Alternative Hash Functions</source>
          <target state="translated">대체 해시 함수</target>
        </trans-unit>
        <trans-unit id="92135acee6fb42da0402ddedc5b8263e8afa69de" translate="yes" xml:space="preserve">
          <source>Alternative capture group numbering</source>
          <target state="translated">대체 캡처 그룹 번호 매기기</target>
        </trans-unit>
        <trans-unit id="ef523340b1a308a5c82202213f6749b6e6b1eda0" translate="yes" xml:space="preserve">
          <source>Alternative libraries &lt;a href=&quot;Math::BigInt::Calc&quot;&gt;Math::BigInt::Calc&lt;/a&gt;, &lt;a href=&quot;Math::BigInt::GMP&quot;&gt;Math::BigInt::GMP&lt;/a&gt;, and &lt;a href=&quot;Math::BigInt::Pari&quot;&gt;Math::BigInt::Pari&lt;/a&gt;.</source>
          <target state="translated">대체 라이브러리 &lt;a href=&quot;Math::BigInt::Calc&quot;&gt;Math :: BigInt :: Calc&lt;/a&gt; , &lt;a href=&quot;Math::BigInt::GMP&quot;&gt;Math :: BigInt :: GMP&lt;/a&gt; 및 &lt;a href=&quot;Math::BigInt::Pari&quot;&gt;Math :: BigInt :: Pari&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="701e87ca0ad0ba8cd11eda21d6ba26ee826bdec9" translate="yes" xml:space="preserve">
          <source>Alternative libraries &lt;a href=&quot;Math::BigInt::FastCalc&quot;&gt;Math::BigInt::FastCalc&lt;/a&gt;, &lt;a href=&quot;Math::BigInt::GMP&quot;&gt;Math::BigInt::GMP&lt;/a&gt;, and &lt;a href=&quot;Math::BigInt::Pari&quot;&gt;Math::BigInt::Pari&lt;/a&gt;.</source>
          <target state="translated">대체 라이브러리 &lt;a href=&quot;Math::BigInt::FastCalc&quot;&gt;Math :: BigInt :: FastCalc&lt;/a&gt; , &lt;a href=&quot;Math::BigInt::GMP&quot;&gt;Math :: BigInt :: GMP&lt;/a&gt; 및 &lt;a href=&quot;Math::BigInt::Pari&quot;&gt;Math :: BigInt :: Pari&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="79c07200d4699b036f2138680fade3c9689f7058" translate="yes" xml:space="preserve">
          <source>Alternative math libraries</source>
          <target state="translated">대체 수학 라이브러리</target>
        </trans-unit>
        <trans-unit id="6aa5c766a08c26061e42a91b28e7696a27f14067" translate="yes" xml:space="preserve">
          <source>Alternative option starters</source>
          <target state="translated">대체 옵션 스타터</target>
        </trans-unit>
        <trans-unit id="443fe46b83982a5185e410eceac3b7185f7ae257" translate="yes" xml:space="preserve">
          <source>Alternative to Test::More::use_ok</source>
          <target state="translated">테스트 대안 :: 더보기 :: use_ok</target>
        </trans-unit>
        <trans-unit id="c7461a3c1c3204afbbfd69dbbccd1e2b59471f99" translate="yes" xml:space="preserve">
          <source>Alternative warn and die for modules</source>
          <target state="translated">모듈에 대한 대체 경고 및 다이</target>
        </trans-unit>
        <trans-unit id="12e5972b55b252c3c9bc2d82985850d79c96249e" translate="yes" xml:space="preserve">
          <source>Alternatively edit the init file interactively via: 3rd mouse button -&amp;gt; New Display -&amp;gt; Edit Menu</source>
          <target state="translated">또는 세 번째 마우스 버튼-&amp;gt; 새 디스플레이-&amp;gt; 편집 메뉴를 통해 대화식으로 init 파일을 편집하십시오</target>
        </trans-unit>
        <trans-unit id="44c86b27ab468eef89d417477ce09eb4480abfb2" translate="yes" xml:space="preserve">
          <source>Alternatively look here: &lt;a href=&quot;http://www.unix.com/man-page/FreeBSD/3/strftime/&quot;&gt;http://www.unix.com/man-page/FreeBSD/3/strftime/&lt;/a&gt;</source>
          <target state="translated">또는 여기를보십시오 : &lt;a href=&quot;http://www.unix.com/man-page/FreeBSD/3/strftime/&quot;&gt;http://www.unix.com/man-page/FreeBSD/3/strftime/&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e35a7c6545b16241ad2de0b09b446ca8d6a30265" translate="yes" xml:space="preserve">
          <source>Alternatively one can use the</source>
          <target state="translated">또는 하나를 사용할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="5d17661d2312f06dcd6c1a5156f20af2512c469b" translate="yes" xml:space="preserve">
          <source>Alternatively the list of subfields can by supplied as a scalar, thus</source>
          <target state="translated">또는 서브 필드 목록을 스칼라로 제공하여</target>
        </trans-unit>
        <trans-unit id="2d8ede1527fb5e6a736864b76d2f172c35af4997" translate="yes" xml:space="preserve">
          <source>Alternatively you can use the</source>
          <target state="translated">또는 다음을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="094a83381a58e4403aca1b491639e03749297bf0" translate="yes" xml:space="preserve">
          <source>Alternatively you can use the XPUSHs() macro, which combines a &lt;code&gt;EXTEND(SP, 1)&lt;/code&gt; and &lt;code&gt;PUSHs()&lt;/code&gt;. This is less efficient if you're pushing multiple values.</source>
          <target state="translated">또는 &lt;code&gt;EXTEND(SP, 1)&lt;/code&gt; 및 &lt;code&gt;PUSHs()&lt;/code&gt; 를 결합한 XPUSHs () 매크로를 사용할 수 있습니다 . 여러 값을 푸시하는 경우 효율성이 떨어집니다.</target>
        </trans-unit>
        <trans-unit id="0e3d4d311210785c85520063de48eeff7de6af69" translate="yes" xml:space="preserve">
          <source>Alternatively you can use the compiler directive our() to bring a dynamic variable into the current lexical scope.</source>
          <target state="translated">또는 컴파일러 지시문 our ()를 사용하여 동적 변수를 현재 어휘 범위로 가져올 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2cec5cf8bbfadcf33f7e5849e13d536e2c1766e0" translate="yes" xml:space="preserve">
          <source>Alternatively you can use:</source>
          <target state="translated">또는 다음을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="43f0cea439a0fe2f49f0e9b79ff517dcdbec8d84" translate="yes" xml:space="preserve">
          <source>Alternatively you may be able to get these docs prebuilt from &lt;code&gt;CPAN&lt;/code&gt; .</source>
          <target state="translated">또는 &lt;code&gt;CPAN&lt;/code&gt; 에서 이러한 문서를 미리 빌드 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f7f7013a74aa2034d027da86e6edefa6ad1f3b65" translate="yes" xml:space="preserve">
          <source>Alternatively you may be able to get these docs prebuilt from CPAN.</source>
          <target state="translated">또는 CPAN에서 이러한 문서를 미리 빌드 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="06dab9dc9469b67b9f013b1f7d978b8fd09b7e74" translate="yes" xml:space="preserve">
          <source>Alternatively, Berkeley DB version 1 is available at your nearest CPAN archive in</source>
          <target state="translated">또는 Berkeley DB 버전 1은 가까운 CPAN 아카이브에서 구할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4613df2f546fec79f85cfae70e64069cb1648bc9" translate="yes" xml:space="preserve">
          <source>Alternatively, a version range &lt;b&gt;may&lt;/b&gt; use the operators &amp;lt; (less than), &amp;lt;= (less than or equal), &amp;gt; (greater than), &amp;gt;= (greater than or equal), == (equal), and != (not equal). For example, the specification &lt;code&gt;&amp;lt; 2.0&lt;/code&gt; means that any version of the prerequisite less than 2.0 is suitable.</source>
          <target state="translated">또는 버전 범위 &lt;b&gt;는&lt;/b&gt; &amp;lt;(보다 작음), &amp;lt;= (작거나 같음),&amp;gt; (보다 큼),&amp;gt; = (크거나 같음), == (같음) 및! = (아님) 연산자를 사용할 수 있습니다. 같은). 예를 들어, 사양 &lt;code&gt;&amp;lt; 2.0&lt;/code&gt; 은 2.0 미만의 전제 조건 버전이 적합 함을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="18aa5e8fea6653b702c48738f98b3e8db633fcaf" translate="yes" xml:space="preserve">
          <source>Alternatively, an array reference of section specifications can be used:</source>
          <target state="translated">또는 섹션 사양의 배열 참조를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="89c6743b65649f02ac7d006f9c75c999b8c0f7a0" translate="yes" xml:space="preserve">
          <source>Alternatively, as of version 2.24, the configuration options may be passed together with the &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; statement:</source>
          <target state="translated">또는 버전 2.24부터 구성 옵션이 &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 문과 함께 전달 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="865e46b39731975715e5505f357dc99fc1bb9e96" translate="yes" xml:space="preserve">
          <source>Alternatively, as of version 2.24, the configuration options may be passed together with the &lt;code&gt;use&lt;/code&gt; statement:</source>
          <target state="translated">또는 버전 2.24부터 구성 옵션이 &lt;code&gt;use&lt;/code&gt; 문과 함께 전달 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fb6383e28e6083bea50110ff705c0169c065025b" translate="yes" xml:space="preserve">
          <source>Alternatively, if &lt;code&gt;decode_pod&lt;/code&gt; is set, it will decode the collected pod sections according to the &lt;code&gt;=encoding&lt;/code&gt; declaration.</source>
          <target state="translated">또는 &lt;code&gt;decode_pod&lt;/code&gt; 가 설정된 경우 &lt;code&gt;=encoding&lt;/code&gt; 선언 에 따라 수집 된 포드 섹션을 디코딩합니다 .</target>
        </trans-unit>
        <trans-unit id="c0f72336ff028f49493e1034a2d5aa23e62a23ff" translate="yes" xml:space="preserve">
          <source>Alternatively, if the &lt;code&gt;string&lt;/code&gt; parameter is given, the supplied string will be parsed instead of a file.</source>
          <target state="translated">또는 &lt;code&gt;string&lt;/code&gt; 매개 변수가 제공되면 제공된 문자열이 파일 대신 구문 분석됩니다.</target>
        </trans-unit>
        <trans-unit id="e9aa6c54c04158a408f2c0b76a7a51f158187ce5" translate="yes" xml:space="preserve">
          <source>Alternatively, if you don't need perlglob.exe and don't need to enable the USE_SETARGV option then you can safely just remove all mention of $(GLOBEXE) from win32/Makefile and setargv.obj won't be required anyway.</source>
          <target state="translated">또는 perlglob.exe가 필요하지 않고 USE_SETARGV 옵션을 활성화 할 필요가 없으면 win32 / Makefile에서 $ (GLOBEXE)에 대한 모든 언급을 안전하게 제거 할 수 있으며 setargv.obj는 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="068fceff1e33e5da627a6b110b456936f6082b0c" translate="yes" xml:space="preserve">
          <source>Alternatively, if you have the &lt;code&gt;gunzip&lt;/code&gt; program available, you can use this to read compressed files</source>
          <target state="translated">또는 &lt;code&gt;gunzip&lt;/code&gt; 프로그램을 사용할 수있는 경우이를 사용하여 압축 파일을 읽을 수 있습니다</target>
        </trans-unit>
        <trans-unit id="4d16466752d2c087e599f1526f5793b26a5e2b0a" translate="yes" xml:space="preserve">
          <source>Alternatively, if you want to read the &lt;code&gt;&quot;data1&quot;&lt;/code&gt; member into memory, use a scalar reference for the &lt;code&gt;output&lt;/code&gt; parameter.</source>
          <target state="translated">또는 &lt;code&gt;&quot;data1&quot;&lt;/code&gt; 멤버를 메모리 로 읽으려면 &lt;code&gt;output&lt;/code&gt; 매개 변수에 스칼라 참조를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="067a937688c2a4c5c986d21853b255fbc5aefe6e" translate="yes" xml:space="preserve">
          <source>Alternatively, one can round the results explicitly using one of &lt;a href=&quot;#round%28%29&quot;&gt;&quot;round()&quot;&lt;/a&gt;, &lt;a href=&quot;#bround%28%29&quot;&gt;&quot;bround()&quot;&lt;/a&gt; or &lt;a href=&quot;#bfround%28%29&quot;&gt;&quot;bfround()&quot;&lt;/a&gt; or by passing the desired accuracy to the method as an additional parameter:</source>
          <target state="translated">또는 &lt;a href=&quot;#round%28%29&quot;&gt;&quot;round ()&quot;&lt;/a&gt; , &lt;a href=&quot;#bround%28%29&quot;&gt;&quot;bround ()&quot;&lt;/a&gt; 또는 &lt;a href=&quot;#bfround%28%29&quot;&gt;&quot;bfround ()&quot;&lt;/a&gt; 중 하나를 사용 하거나 원하는 정확도를 추가 매개 변수로 메소드에 전달하여 명시 적으로 결과를 반올림 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="742c3c00178ebe72a9bfad0e3ef29810b62b04e9" translate="yes" xml:space="preserve">
          <source>Alternatively, put this as the first line of your script:</source>
          <target state="translated">또는 이것을 스크립트의 첫 줄로 넣으십시오.</target>
        </trans-unit>
        <trans-unit id="daefa0329439a8224d52050e5214c48286284b22" translate="yes" xml:space="preserve">
          <source>Alternatively, rather than having to explicitly name each of the files that you want to compress, you could use a fileglob to select all the &lt;code&gt;txt&lt;/code&gt; files in the current directory, as follows</source>
          <target state="translated">또는 압축하려는 각 파일의 이름을 명시 적으로 지정하지 않고 다음과 같이 fileglob를 사용 하여 현재 디렉토리의 모든 &lt;code&gt;txt&lt;/code&gt; 파일 을 선택할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="eefa7323e5eca7f13253bb419c7f371832614e4a" translate="yes" xml:space="preserve">
          <source>Alternatively, simply use &lt;code&gt;&amp;lt;=&amp;gt;&lt;/code&gt; for comparisons, this always gets it right. There is not yet a way to get a number automatically represented as a string that matches exactly the way Perl represents it.</source>
          <target state="translated">또는 단순히 비교 를 위해 &lt;code&gt;&amp;lt;=&amp;gt;&lt;/code&gt; 를 사용 하면 항상 올바른 결과를 얻을 수 있습니다. Perl이 나타내는 방식과 정확히 일치하는 문자열로 자동으로 숫자를 표시하는 방법은 아직 없습니다.</target>
        </trans-unit>
        <trans-unit id="c44b1aed9efe7eda393df0bd7f553f139ab03a17" translate="yes" xml:space="preserve">
          <source>Alternatively, simply use &lt;code&gt;&amp;lt;=&amp;gt;&lt;/code&gt; for comparisons, this will get it always right. There is not yet a way to get a number automatically represented as a string that matches exactly the way Perl represents it.</source>
          <target state="translated">또는 비교 를 위해 &lt;code&gt;&amp;lt;=&amp;gt;&lt;/code&gt; 를 사용 하면 항상 올바르게 얻을 수 있습니다. Perl이 나타내는 방식과 정확히 일치하는 문자열로 숫자를 자동으로 표시하는 방법은 아직 없습니다.</target>
        </trans-unit>
        <trans-unit id="055ca33d620827ab022a97400794bf3fb8a2807b" translate="yes" xml:space="preserve">
          <source>Alternatively, the &lt;a href=&quot;Text::ParseWords&quot;&gt;Text::ParseWords&lt;/a&gt; module (part of the standard Perl distribution) lets you say:</source>
          <target state="translated">또는 &lt;a href=&quot;Text::ParseWords&quot;&gt;Text :: ParseWords&lt;/a&gt; 모듈 (표준 Perl 배포판의 일부)을 사용하면 다음과 같이 말할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8ad4e77e5423588b083e2af8975456f597a84a91" translate="yes" xml:space="preserve">
          <source>Alternatively, the &lt;a href=&quot;text/parsewords&quot;&gt;Text::ParseWords&lt;/a&gt; module (part of the standard Perl distribution) lets you say:</source>
          <target state="translated">또는 &lt;a href=&quot;text/parsewords&quot;&gt;Text :: ParseWords&lt;/a&gt; 모듈 (표준 Perl 배포의 일부)을 통해 다음과 같이 말할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e3f5b7f0771697b931c8ecd89602848a9590421e" translate="yes" xml:space="preserve">
          <source>Alternatively, the crypt libraries in GNU libc have been ported to Cygwin.</source>
          <target state="translated">또는 GNU libc의 암호화 라이브러리가 Cygwin으로 포팅되었습니다.</target>
        </trans-unit>
        <trans-unit id="43ccb7ccf6de944158b57bdf33cf5e43082dfbc3" translate="yes" xml:space="preserve">
          <source>Alternatively, use the macro &lt;a href=&quot;#CopLABEL_len_flags&quot;&gt;&quot;&lt;code&gt;CopLABEL_len_flags&lt;/code&gt;&quot;&lt;/a&gt;; or if you don't need to know if the label is UTF-8 or not, the macro &lt;a href=&quot;#CopLABEL_len&quot;&gt;&quot;&lt;code&gt;CopLABEL_len&lt;/code&gt;&quot;&lt;/a&gt;; or if you additionally dont need to know the length, &lt;a href=&quot;#CopLABEL&quot;&gt;&quot;&lt;code&gt;CopLABEL&lt;/code&gt;&quot;&lt;/a&gt;.</source>
          <target state="translated">또는 &lt;a href=&quot;#CopLABEL_len_flags&quot;&gt;&quot; &lt;code&gt;CopLABEL_len_flags&lt;/code&gt; &quot;&lt;/a&gt; 매크로를 사용하십시오 . 또는 레이블이 UTF-8인지 여부를 알 필요가없는 경우 매크로 &lt;a href=&quot;#CopLABEL_len&quot;&gt;&quot; &lt;code&gt;CopLABEL_len&lt;/code&gt; &quot;&lt;/a&gt; ; 또는 길이를 추가로 알 필요가없는 경우 &lt;a href=&quot;#CopLABEL&quot;&gt;&quot; &lt;code&gt;CopLABEL&lt;/code&gt; &quot;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="996763dc438b824d04ceb178a7d6d2de1f4e3617" translate="yes" xml:space="preserve">
          <source>Alternatively, using a customized typemap for your purposes in the first place is probably preferable.</source>
          <target state="translated">또는 처음에 목적에 맞는 사용자 정의 유형 맵을 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="818d3daf2781969164beb46d939858b0992b14b8" translate="yes" xml:space="preserve">
          <source>Alternatively, we could have used &lt;code&gt;C&lt;/code&gt; to unpack the individually accessible byte registers FL, FH, AL, AH, etc.:</source>
          <target state="translated">또는 &lt;code&gt;C&lt;/code&gt; 를 사용하여 개별적으로 액세스 가능한 바이트 레지스터 FL, FH, AL, AH 등의 압축을 풀 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="87ca4d1f50f588b444c138934de28912a7c4fa3d" translate="yes" xml:space="preserve">
          <source>Alternatively, we might be able to use a command line option such as -R</source>
          <target state="translated">또는 -R과 같은 명령 줄 옵션을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="16c917006b223001c63f85b3d40138b38f9bf9a9" translate="yes" xml:space="preserve">
          <source>Alternatively, you can achieve a similar static effect by declaring the variable in a separate block outside the function, e.g.,</source>
          <target state="translated">또는 함수 외부의 별도 블록에서 변수를 선언하여 유사한 정적 효과를 얻을 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="973c34c798c56bb32a7153f1be5f39dd390df9c7" translate="yes" xml:space="preserve">
          <source>Alternatively, you can fiddle with the stack directly: &lt;code&gt;SP&lt;/code&gt; gives you the first element in your portion of the stack, and &lt;code&gt;TOP*&lt;/code&gt; gives you the top SV/IV/NV/etc. on the stack. So, for instance, to do unary negation of an integer:</source>
          <target state="translated">또는 스택으로 직접 바이올린을 사용할 수 있습니다. &lt;code&gt;SP&lt;/code&gt; 는 스택 부분의 첫 번째 요소를 제공 하고 &lt;code&gt;TOP*&lt;/code&gt; 는 최상위 SV / IV / NV / etc를 제공합니다. 스택에. 예를 들어 정수의 단항 부정을 수행하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="4486c955e53dc63730c2501b04fe03ec6d1fb66c" translate="yes" xml:space="preserve">
          <source>Alternatively, you can quote the class name:</source>
          <target state="translated">또는 클래스 이름을 인용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3dc4c1bc0515a5f540589d100b6ce1224a32ad91" translate="yes" xml:space="preserve">
          <source>Alternatively, you can specify that the option can have multiple values by adding a &quot;@&quot;, and pass a reference to a scalar as the destination:</source>
          <target state="translated">또는 &quot;@&quot;를 추가하여 옵션이 여러 값을 가질 수 있도록 지정하고 스칼라에 대한 참조를 대상으로 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9393a15204a23768f5fb6e120d832da535fff827" translate="yes" xml:space="preserve">
          <source>Alternatively, you can specify that the option can have multiple values by adding a &quot;@&quot;, and pass a scalar reference as the destination:</source>
          <target state="translated">또는 &quot;@&quot;를 추가하여 옵션이 여러 값을 가질 수 있도록 지정하고 스칼라 참조를 대상으로 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="86794ed15412a1fa79e33d4ba8f3e04841c9eebc" translate="yes" xml:space="preserve">
          <source>Alternatively, you can use the &lt;code&gt;plan()&lt;/code&gt; function. Useful for when you have to calculate the number of tests.</source>
          <target state="translated">또는 &lt;code&gt;plan()&lt;/code&gt; 함수를 사용할 수 있습니다 . 테스트 횟수를 계산해야 할 때 유용합니다.</target>
        </trans-unit>
        <trans-unit id="bd695ed1549655fbf2b6a69e34efa112b5887ecd" translate="yes" xml:space="preserve">
          <source>Alternatively, you can use the GCC_EXEC_PREFIX environment variable to ensure that Sun's as and ld are used. Consult your gcc documentation for further information on the -B option and the GCC_EXEC_PREFIX variable.</source>
          <target state="translated">또는 GCC_EXEC_PREFIX 환경 변수를 사용하여 Sun의 as 및 ld가 사용되도록 할 수 있습니다. -B 옵션 및 GCC_EXEC_PREFIX 변수에 대한 자세한 내용은 gcc 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="ee23e1f9045483d4017c29efb93306a8f81a02a3" translate="yes" xml:space="preserve">
          <source>Alternatively, you may inspect the value of &lt;a href=&quot;perlvar#%24%7B%5ECHILD_ERROR_NATIVE%7D&quot;&gt;&lt;code&gt;${^CHILD_ERROR_NATIVE}&lt;/code&gt;&lt;/a&gt; with the &lt;a href=&quot;posix#WIFEXITED&quot;&gt;&lt;code&gt;W*()&lt;/code&gt;&lt;/a&gt; calls from the &lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt; module.</source>
          <target state="translated">또는 &lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt; 모듈 의 &lt;a href=&quot;posix#WIFEXITED&quot;&gt; &lt;code&gt;W*()&lt;/code&gt; &lt;/a&gt; 호출 로 &lt;a href=&quot;perlvar#%24%7B%5ECHILD_ERROR_NATIVE%7D&quot;&gt; &lt;code&gt;${^CHILD_ERROR_NATIVE}&lt;/code&gt; &lt;/a&gt; 값을 검사 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5e3eb7cca34a1ce6ec3422f81caa582587938fc9" translate="yes" xml:space="preserve">
          <source>Alternatively, you may inspect the value of &lt;code&gt;${^CHILD_ERROR_NATIVE}&lt;/code&gt; with the &lt;code&gt;W*()&lt;/code&gt; calls from the POSIX module.</source>
          <target state="translated">또는 POSIX 모듈 의 &lt;code&gt;W*()&lt;/code&gt; 호출 로 &lt;code&gt;${^CHILD_ERROR_NATIVE}&lt;/code&gt; 값을 검사 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="273eb19a8880a15607895e1cd30f571a681e7c99" translate="yes" xml:space="preserve">
          <source>Alternatively, you may pass a single &lt;code&gt;ExtUtils::Typemaps::InputMap&lt;/code&gt; object.</source>
          <target state="translated">또는 단일 &lt;code&gt;ExtUtils::Typemaps::InputMap&lt;/code&gt; 개체를 전달할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="98574b24c9752f26b07d4e571e873801f591432e" translate="yes" xml:space="preserve">
          <source>Alternatively, you may pass a single &lt;code&gt;ExtUtils::Typemaps::OutputMap&lt;/code&gt; object.</source>
          <target state="translated">또는 단일 &lt;code&gt;ExtUtils::Typemaps::OutputMap&lt;/code&gt; 개체를 전달할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3baaa9fdf5df5a376581f707e9bd2202f9c63495" translate="yes" xml:space="preserve">
          <source>Alternatively, you may pass a single &lt;code&gt;ExtUtils::Typemaps::Type&lt;/code&gt; object.</source>
          <target state="translated">또는 단일 &lt;code&gt;ExtUtils::Typemaps::Type&lt;/code&gt; 개체를 전달할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="efc46e4aa2514a5747d9e66b804729fd4f6f91eb" translate="yes" xml:space="preserve">
          <source>Alternatives are tried from left to right, so the first alternative found for which the entire expression matches, is the one that is chosen. This means that alternatives are not necessarily greedy. For example: when matching &lt;code&gt;foo|foot&lt;/code&gt; against &quot;barefoot&quot;, only the &quot;foo&quot; part will match, as that is the first alternative tried, and it successfully matches the target string. (This might not seem important, but it is important when you are capturing matched text using parentheses.)</source>
          <target state="translated">대안은 왼쪽에서 오른쪽으로 시도되므로 전체 표현식과 일치하는 첫 번째 대안이 선택됩니다. 이것은 대안이 반드시 탐욕스럽지 않다는 것을 의미합니다. 예를 들어 , &quot;barefoot&quot;과 &lt;code&gt;foo|foot&lt;/code&gt; 을 일치시킬 때 , &quot;foo&quot;부분 만이 첫 번째 대안이므로 일치하며 대상 문자열과 성공적으로 일치합니다. (이것은 중요하지 않을 수도 있지만 괄호를 사용하여 일치하는 텍스트를 캡처 할 때 중요합니다.)</target>
        </trans-unit>
        <trans-unit id="c8af2aafd15c21262760094a19550be8139535e2" translate="yes" xml:space="preserve">
          <source>Alternatives are tried from left to right, so the first alternative found for which the entire expression matches, is the one that is chosen. This means that alternatives are not necessarily greedy. For example: when matching &lt;code&gt;foo|foot&lt;/code&gt; against &lt;code&gt;&quot;barefoot&quot;&lt;/code&gt;, only the &lt;code&gt;&quot;foo&quot;&lt;/code&gt; part will match, as that is the first alternative tried, and it successfully matches the target string. (This might not seem important, but it is important when you are capturing matched text using parentheses.)</source>
          <target state="translated">대안은 왼쪽에서 오른쪽으로 시도되므로 전체 표현식이 일치하는 첫 번째 대안이 선택된 것입니다. 이것은 대안이 반드시 탐욕 스럽지는 않다는 것을 의미합니다. 예를 들어 일치시킬 때 &lt;code&gt;foo|foot&lt;/code&gt; 에 대한 &lt;code&gt;&quot;barefoot&quot;&lt;/code&gt; 만 &lt;code&gt;&quot;foo&quot;&lt;/code&gt; 그 첫 번째 대안 시도와 같이 부분은 일치하고 성공적으로 대상 문자열과 일치합니다. (중요해 보이지 않을 수도 있지만 괄호를 사용하여 일치하는 텍스트를 캡처 할 때 중요합니다.)</target>
        </trans-unit>
        <trans-unit id="178ef3c8a39076052130de80299d367dd5e6090f" translate="yes" xml:space="preserve">
          <source>Alternatives to raw</source>
          <target state="translated">raw에 대한 대안</target>
        </trans-unit>
        <trans-unit id="52a09d99c8be7488acf8d5679596a3a7ebeeb466" translate="yes" xml:space="preserve">
          <source>Alternatives: &lt;a href=&quot;Test2::AsyncSubtest&quot;&gt;Test2::AsyncSubtest&lt;/a&gt; and &lt;a href=&quot;Test2::Workflow&quot;&gt;Test2::Workflow&lt;/a&gt; (not stable).</source>
          <target state="translated">대안 : &lt;a href=&quot;Test2::AsyncSubtest&quot;&gt;Test2 :: AsyncSubtest&lt;/a&gt; 및 &lt;a href=&quot;Test2::Workflow&quot;&gt;Test2 :: Workflow&lt;/a&gt; (안정적이지 않음).</target>
        </trans-unit>
        <trans-unit id="dcc6e5f9721668e6a6d8a7cd85c26663fa384cb4" translate="yes" xml:space="preserve">
          <source>Alternativly look at &lt;a href=&quot;Plack::Middleware::Auth::Basic&quot;&gt;Plack::Middleware::Auth::Basic&lt;/a&gt;, or one of the other &lt;a href=&quot;https://metacpan.org/search?q=plack+auth&quot;&gt;Plack authentication&lt;/a&gt; options.</source>
          <target state="translated">또는 &lt;a href=&quot;Plack::Middleware::Auth::Basic&quot;&gt;Plack :: Middleware :: Auth :: Basic&lt;/a&gt; 또는 다른 &lt;a href=&quot;https://metacpan.org/search?q=plack+auth&quot;&gt;Plack 인증&lt;/a&gt; 옵션 중 하나를 살펴보십시오.</target>
        </trans-unit>
        <trans-unit id="895965b31db8e4bfa4de954e884b587830b4927d" translate="yes" xml:space="preserve">
          <source>Alternativly look at &lt;a href=&quot;http://search.cpan.org/perldoc/Plack::Middleware::Auth::Basic&quot;&gt;Plack::Middleware::Auth::Basic&lt;/a&gt;, or one of the other &lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2fmetacpan.org%2fsearch%3fq%3dplack%2bauth&quot;&gt;Plack authentication&lt;/a&gt; options.</source>
          <target state="translated">&lt;a href=&quot;http://search.cpan.org/perldoc/Plack::Middleware::Auth::Basic&quot;&gt;Plack :: Middleware :: Auth :: Basic&lt;/a&gt; 또는 다른 &lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2fmetacpan.org%2fsearch%3fq%3dplack%2bauth&quot;&gt;Plack 인증&lt;/a&gt; 옵션 중 하나를 번갈아보십시오 .</target>
        </trans-unit>
        <trans-unit id="083655cd712cf57272ed2f0a7a5805f36d9802f0" translate="yes" xml:space="preserve">
          <source>Although &lt;b&gt;DB_File&lt;/b&gt; cannot do this directly, there is a module which can layer transparently over &lt;b&gt;DB_File&lt;/b&gt; to accomplish this feat.</source>
          <target state="translated">&lt;b&gt;DB_File&lt;/b&gt; 이이를 직접 수행 할 수는 없지만 &lt;b&gt;DB_File&lt;/b&gt; 위에 투명하게 &lt;b&gt;계층화&lt;/b&gt; 하여이 위업을 달성 할 수있는 모듈이 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3768f14455445c5980f80214d4ffa65dc7a14002" translate="yes" xml:space="preserve">
          <source>Although &lt;b&gt;DB_File&lt;/b&gt; is covered by the Perl license, the library it makes use of, namely Berkeley DB, is not. Berkeley DB has its own copyright and its own license. Please take the time to read it.</source>
          <target state="translated">&lt;b&gt;DB_File&lt;/b&gt; 에는 Perl 라이센스가 적용 되지만 Berkeley DB가 사용하는 라이브러리는 그렇지 않습니다. 버클리 DB는 자체 저작권 및 라이센스를 보유하고 있습니다. 시간을내어 읽으십시오.</target>
        </trans-unit>
        <trans-unit id="73b1840016122f68e05350fe0f1ab0303bd2fd8b" translate="yes" xml:space="preserve">
          <source>Although &lt;b&gt;DB_File&lt;/b&gt; is intended to be used with Berkeley DB version 1, it can also be used with version 2, 3 or 4. In this case the interface is limited to the functionality provided by Berkeley DB 1.x. Anywhere the version 2 or greater interface differs, &lt;b&gt;DB_File&lt;/b&gt; arranges for it to work like version 1. This feature allows &lt;b&gt;DB_File&lt;/b&gt; scripts that were built with version 1 to be migrated to version 2 or greater without any changes.</source>
          <target state="translated">비록 &lt;b&gt;DB_File는&lt;/b&gt; 버클리 DB 버전 1과 함께 사용하기위한 것이다, 그것은 또한이 경우 버전 2, 3 또는 4와 함께 사용할 수있는 인터페이스는 버클리 DB 1.x에서 제공하는 기능에 한정되고 버전 2 이상의 인터페이스가 다른 곳에서는 &lt;b&gt;DB_File&lt;/b&gt; 이 버전 1처럼 작동하도록 정렬합니다.이 기능을 사용하면 버전 1로 작성된 &lt;b&gt;DB_File&lt;/b&gt; 스크립트를 변경하지 않고 버전 2 이상으로 마이그레이션 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a4ee4e9c8be6f9bb865a03f9dd6635b3149d28d3" translate="yes" xml:space="preserve">
          <source>Although &lt;code&gt;$_&lt;/code&gt; doesn't actually appear explicitly in the sample filters above, it is implicitly used in a number of places.</source>
          <target state="translated">하지만 &lt;code&gt;$_&lt;/code&gt; 실제로 위의 샘플 필터에 명시 적으로 표시되지 않습니다, 그것은 암시 적으로 자주 사용되었다.</target>
        </trans-unit>
        <trans-unit id="80dfb6d994a40fa49e44520920eac36d9fa1f16f" translate="yes" xml:space="preserve">
          <source>Although &lt;code&gt;&lt;a href=&quot;functions/defined&quot;&gt;defined&lt;/a&gt; %hash&lt;/code&gt; is false on a plain not-yet-used hash, it becomes true in several non-obvious circumstances, including iterators, weak references, stash names, even remaining true after &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt; %hash&lt;/code&gt; . These things make &lt;code&gt;&lt;a href=&quot;functions/defined&quot;&gt;defined&lt;/a&gt; %hash&lt;/code&gt; fairly useless in practice, so it now generates a fatal error.</source>
          <target state="translated">하지만 &lt;code&gt;&lt;a href=&quot;functions/defined&quot;&gt;defined&lt;/a&gt; %hash&lt;/code&gt; 일반 없습니다 아직 사용되는 해시에 허위, 그것은 후에도 진정한 남아, 반복자, 약한 참조, 숨겨 놓은 이름을 포함하여 여러 확실치 않은 상황에서 참이 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt; %hash&lt;/code&gt; . 이러한 것들로 인해 &lt;code&gt;&lt;a href=&quot;functions/defined&quot;&gt;defined&lt;/a&gt; %hash&lt;/code&gt; 가 실제로 쓸모 없게되므로 치명적인 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="7ff687f6589d5bc55ea5b6cd3b7acf0a8989e998" translate="yes" xml:space="preserve">
          <source>Although &lt;code&gt;Compress::Zlib&lt;/code&gt; has a pair of functions called &lt;code&gt;compress&lt;/code&gt; and &lt;code&gt;uncompress&lt;/code&gt;, they are</source>
          <target state="translated">&lt;code&gt;Compress::Zlib&lt;/code&gt; 에는 &lt;code&gt;compress&lt;/code&gt; 및 &lt;code&gt;uncompress&lt;/code&gt; 라는 함수 쌍이 있지만 다음 과 같습니다.</target>
        </trans-unit>
        <trans-unit id="df1f79335b5e25baa8b910d3ca247a13fd7eda4e" translate="yes" xml:space="preserve">
          <source>Although &lt;code&gt;cmp_ok()&lt;/code&gt; was introduced in 0.40, 0.86 fixed an important bug to make it safe for overloaded objects; the fixed first shipped with Perl in 5.10.1 as part of Test::More 0.92.</source>
          <target state="translated">&lt;code&gt;cmp_ok()&lt;/code&gt; 가 0.40에 도입 되었지만 0.86은 오버로드 된 객체에 안전하도록 중요한 버그를 수정했습니다. 고정은 Test :: More 0.92의 일부로 5.10.1에서 Perl과 함께 처음 제공되었습니다.</target>
        </trans-unit>
        <trans-unit id="a46f1c081d434cfa72b0670296268695a927ef72" translate="yes" xml:space="preserve">
          <source>Although &lt;code&gt;defined %hash&lt;/code&gt; is false on a plain not-yet-used hash, it becomes true in several non-obvious circumstances, including iterators, weak references, stash names, even remaining true after &lt;code&gt;undef %hash&lt;/code&gt;. These things make &lt;code&gt;defined %hash&lt;/code&gt; fairly useless in practice, so it now generates a fatal error.</source>
          <target state="translated">하지만 &lt;code&gt;defined %hash&lt;/code&gt; 일반 없습니다 아직 사용되는 해시에 허위, 그것은 후에도 진정한 남아, 반복자, 약한 참조, 숨겨 놓은 이름을 포함하여 여러 확실치 않은 상황에서 참이 &lt;code&gt;undef %hash&lt;/code&gt; . 이러한 것들은 &lt;code&gt;defined %hash&lt;/code&gt; 를 실제로 상당히 쓸모 없게 만들 므로 이제 치명적인 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="1c4fc726a9484b19113d6eedd6d8805f1968eb73" translate="yes" xml:space="preserve">
          <source>Although FileCache can be used with piped opens ('-|' or '|-') doing so is strongly discouraged. If FileCache finds it necessary to close and then reopen a pipe, the command at the far end of the pipe will be reexecuted - the results of performing IO on FileCache'd pipes is unlikely to be what you expect. The ability to use FileCache on pipes may be removed in a future release.</source>
          <target state="translated">FileCache를 파이프 열기 ( '-|'또는 '|-')와 함께 사용할 수 있지만 그렇게하지 않는 것이 좋습니다. FileCache가 파이프를 닫았다가 다시 열어야하는 경우 파이프 맨 끝에있는 명령이 다시 실행됩니다. FileCache 파이프에서 IO를 수행 한 결과가 예상과 다를 수 있습니다. 파이프에서 FileCache를 사용하는 기능은 다음 릴리스에서 제거 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="077804ce34db1c72deaf81a9a83f1e62f8a114a7" translate="yes" xml:space="preserve">
          <source>Although I have made use of only the &lt;code&gt;POP*&lt;/code&gt; macros to access values returned from Perl subroutines, it is also possible to bypass these macros and read the stack using the &lt;code&gt;ST&lt;/code&gt; macro (See &lt;a href=&quot;perlxs&quot;&gt;perlxs&lt;/a&gt; for a full description of the &lt;code&gt;ST&lt;/code&gt; macro).</source>
          <target state="translated">난 단지의 사용으로 만든 있지만 &lt;code&gt;POP*&lt;/code&gt; 펄 서브 루틴에서 반환 된 액세스 값으로 매크로를, 이러한 매크로 바이 패스도 가능하며 사용하여 스택을 읽을 &lt;code&gt;ST&lt;/code&gt; 의 매크로 (참조 &lt;a href=&quot;perlxs&quot;&gt;perlxs&lt;/a&gt; 의 자세한 설명에 대한 &lt;code&gt;ST&lt;/code&gt; 의 매크로).</target>
        </trans-unit>
        <trans-unit id="ebf0c3d2a317483257bd5985b5509d45e615f5a4" translate="yes" xml:space="preserve">
          <source>Although PA-RISC binaries can run on Itanium systems, you should not attempt to use a PA-RISC version of Perl on an Itanium system. This is because shared libraries created on an Itanium system cannot be loaded while running a PA-RISC executable.</source>
          <target state="translated">PA-RISC 바이너리는 Itanium 시스템에서 실행될 수 있지만 Itanium 시스템에서는 PA-RISC 버전의 Perl을 사용해서는 안됩니다. PA-RISC 실행 파일을 실행하는 동안 Itanium 시스템에서 만든 공유 라이브러리를로드 할 수 없기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="2b071251c66f97d7a5a833d31d9bbb833fc948ef" translate="yes" xml:space="preserve">
          <source>Although Perl will automatically grow strings for you, if you need to force Perl to allocate more memory for your SV, you can use the macro</source>
          <target state="translated">Perl은 자동으로 문자열을 증가 시키지만, SV에 더 많은 메모리를 할당하도록 Perl을 강제 실행해야하는 경우 매크로를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3fece6ab5bd6d283eb840842e215942103cb610e" translate="yes" xml:space="preserve">
          <source>Although Plan 9 Perl currently only provides static loading, it is built with a number of useful extensions. These include Opcode, FileHandle, Fcntl, and POSIX. Expect to see others (and DynaLoading!) in the future.</source>
          <target state="translated">Plan 9 Perl은 현재 정적로드 만 제공하지만 여러 유용한 확장으로 빌드됩니다. 여기에는 Opcode, FileHandle, Fcntl 및 POSIX가 포함됩니다. 앞으로 다른 사람들 (및 DynaLoading!)을 보게 될 것입니다.</target>
        </trans-unit>
        <trans-unit id="e4e6f6df84571e93788f39ee96ef2a5f0752bec2" translate="yes" xml:space="preserve">
          <source>Although Test::More has been a core module in versions of Perl since 5.6.2, Test::More has evolved since then, and not all of the features you're used to will be present in the shipped version of Test::More. If you are writing a module, don't forget to indicate in your package metadata the minimum version of Test::More that you require. For instance, if you want to use &lt;code&gt;done_testing()&lt;/code&gt; but want your test script to run on Perl 5.10.0, you will need to explicitly require Test::More &amp;gt; 0.88.</source>
          <target state="translated">Test :: More는 5.6.2부터 Perl 버전의 핵심 모듈 이었지만 Test :: More는 그 이후로 발전했으며, 사용 된 모든 기능이 Test :: 더. 모듈을 작성하는 경우 패키지 메타 데이터에 필요한 최소 버전의 Test :: More를 표시해야합니다. 예를 들어 &lt;code&gt;done_testing()&lt;/code&gt; 을 사용 하고 싶지만 테스트 스크립트를 Perl 5.10.0에서 실행하려면 명시 적으로 Test :: More&amp;gt; 0.88이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="4b6eb7d4608b6bb5e2737f99ed626a9c3d3fdff3" translate="yes" xml:space="preserve">
          <source>Although all mathematical operations on version objects are forbidden by default, it is possible to retrieve a number which corresponds to the version object through the use of the $obj-&amp;gt;numify method. For formatting purposes, when displaying a number which corresponds a version object, all sub versions are assumed to have three decimal places. So for example:</source>
          <target state="translated">버전 개체에 대한 모든 수학적 연산은 기본적으로 금지되어 있지만 $ obj-&amp;gt; numify 메서드를 사용하여 버전 개체에 해당하는 번호를 검색 할 수 있습니다. 형식화를 위해 버전 개체에 해당하는 숫자를 표시 할 때 모든 하위 버전에는 소수점 세 자리가있는 것으로 간주됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a0cac5f469f6b90c62f4e56ab4bfa747637957a2" translate="yes" xml:space="preserve">
          <source>Although as of 5.14, that can be also be accomplished this way:</source>
          <target state="translated">5.14부터는 다음과 같이 수행 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="06dbd031cbe601d39502de2a4b463b8de205125c" translate="yes" xml:space="preserve">
          <source>Although at first sight there seems to be quite a lot going on in &lt;code&gt;Apache::GZip&lt;/code&gt;, you could sum up what the code was doing as follows -- read the contents of the file in &lt;code&gt;$r-&amp;gt;filename&lt;/code&gt;, compress it and write the compressed data to standard output. That's all.</source>
          <target state="translated">처음에는 &lt;code&gt;Apache::GZip&lt;/code&gt; 에서 많은 일이 벌어지고있는 것처럼 보이지만 , 코드가 다음과 같이 무엇을했는지 요약 할 수 있습니다. &lt;code&gt;$r-&amp;gt;filename&lt;/code&gt; 에서 파일의 내용을 읽고 압축하고 압축 된 데이터를 표준 출력으로 변환합니다. 그게 다야.</target>
        </trans-unit>
        <trans-unit id="b446ed3017bd4a5c94fd715dbc357d36cd8b9eae" translate="yes" xml:space="preserve">
          <source>Although if your manager accused you of seeking job security (or rapid insecurity) through inscrutable code, it would be hard to argue. :-) If I were you, I'd put that in a function:</source>
          <target state="translated">관리자가 엉뚱한 코드를 통해 직업 보안 (또는 급격한 불안감)을 추구한다고 비난하더라도 주장하기는 어렵습니다. :-) 내가 당신이라면, 나는 그것을 기능에 넣을 것입니다 :</target>
        </trans-unit>
        <trans-unit id="4a4e26bb6dd1017566ef68d6d6d4ea499d6e917f" translate="yes" xml:space="preserve">
          <source>Although it has no direct equivalent in C, Perl's &lt;code&gt;//&lt;/code&gt; operator is related to its C-style &quot;or&quot;. In fact, it's exactly the same as &lt;code&gt;||&lt;/code&gt;, except that it tests the left hand side's definedness instead of its truth. Thus, &lt;code&gt;EXPR1 // EXPR2&lt;/code&gt; returns the value of &lt;code&gt;EXPR1&lt;/code&gt; if it's defined, otherwise, the value of &lt;code&gt;EXPR2&lt;/code&gt; is returned. (&lt;code&gt;EXPR1&lt;/code&gt; is evaluated in scalar context, &lt;code&gt;EXPR2&lt;/code&gt; in the context of &lt;code&gt;//&lt;/code&gt; itself). Usually, this is the same result as &lt;code&gt;&lt;a href=&quot;functions/defined&quot;&gt;defined&lt;/a&gt;(EXPR1) ? EXPR1 : EXPR2&lt;/code&gt; (except that the ternary-operator form can be used as a lvalue, while &lt;code&gt;EXPR1 // EXPR2&lt;/code&gt; cannot). This is very useful for providing default values for variables. If you actually want to test if at least one of &lt;code&gt;$x&lt;/code&gt; and &lt;code&gt;$y&lt;/code&gt; is defined, use &lt;code&gt;&lt;a href=&quot;functions/defined&quot;&gt;defined&lt;/a&gt;($x // $y)&lt;/code&gt; .</source>
          <target state="translated">C에서 직접적으로 동등한 것은 아니지만 Perl의 &lt;code&gt;//&lt;/code&gt; 연산자는 C 스타일 &quot;또는&quot;과 관련이 있습니다. 실제로, 그것은 &lt;code&gt;||&lt;/code&gt; 사실 대신 왼쪽의 정의를 테스트한다는 점을 제외하고. 따라서 &lt;code&gt;EXPR1 // EXPR2&lt;/code&gt; 는 정의 된 경우 &lt;code&gt;EXPR1&lt;/code&gt; 의 값을 리턴하고 , 그렇지 않으면 &lt;code&gt;EXPR2&lt;/code&gt; 의 값을 리턴합니다. ( &lt;code&gt;EXPR1&lt;/code&gt; 은 스칼라 컨텍스트에서 평가되고, &lt;code&gt;//&lt;/code&gt; 자체 컨텍스트에서 &lt;code&gt;EXPR2&lt;/code&gt; 입니다 ). 일반적으로 이는 &lt;code&gt;&lt;a href=&quot;functions/defined&quot;&gt;defined&lt;/a&gt;(EXPR1) ? EXPR1 : EXPR2&lt;/code&gt; 결과 (EXPR1) 와 동일한 결과 입니까? EXPR1 : EXPR2 (3 진 연산자 양식을 lvalue로 사용할 수있는 것을 제외하고 &lt;code&gt;EXPR1 // EXPR2&lt;/code&gt; 할 수 없습니다). 변수에 기본값을 제공하는 데 매우 유용합니다. 실제로 &lt;code&gt;$x&lt;/code&gt; 및 &lt;code&gt;$y&lt;/code&gt; 중 하나 이상 이 정의되어 있는지 테스트하려는 경우 &lt;code&gt;&lt;a href=&quot;functions/defined&quot;&gt;defined&lt;/a&gt;($x // $y)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7fb2cc3c9a7a9c586fba874bcd544c7350b090af" translate="yes" xml:space="preserve">
          <source>Although it has no direct equivalent in C, Perl's &lt;code&gt;//&lt;/code&gt; operator is related to its C-style &quot;or&quot;. In fact, it's exactly the same as &lt;code&gt;||&lt;/code&gt;, except that it tests the left hand side's definedness instead of its truth. Thus, &lt;code&gt;EXPR1 // EXPR2&lt;/code&gt; returns the value of &lt;code&gt;EXPR1&lt;/code&gt; if it's defined, otherwise, the value of &lt;code&gt;EXPR2&lt;/code&gt; is returned. (&lt;code&gt;EXPR1&lt;/code&gt; is evaluated in scalar context, &lt;code&gt;EXPR2&lt;/code&gt; in the context of &lt;code&gt;//&lt;/code&gt; itself). Usually, this is the same result as &lt;code&gt;defined(EXPR1) ? EXPR1 : EXPR2&lt;/code&gt; (except that the ternary-operator form can be used as a lvalue, while &lt;code&gt;EXPR1 // EXPR2&lt;/code&gt; cannot). This is very useful for providing default values for variables. If you actually want to test if at least one of &lt;code&gt;$x&lt;/code&gt; and &lt;code&gt;$y&lt;/code&gt; is defined, use &lt;code&gt;defined($x // $y)&lt;/code&gt;.</source>
          <target state="translated">C에 직접 해당하는 것은 없지만 Perl의 &lt;code&gt;//&lt;/code&gt; 연산자는 C 스타일 &quot;or&quot;와 관련이 있습니다. 사실, 정확히 똑같아 &lt;code&gt;||&lt;/code&gt; , 진실 대신 왼쪽의 정의를 테스트한다는 점을 제외하고. 따라서 &lt;code&gt;EXPR1 // EXPR2&lt;/code&gt; 는 정의 된 경우 &lt;code&gt;EXPR1&lt;/code&gt; 의 값을 반환하고 그렇지 않은 경우 &lt;code&gt;EXPR2&lt;/code&gt; 의 값을 반환합니다. ( &lt;code&gt;EXPR1&lt;/code&gt; 은 스칼라 컨텍스트에서 평가되고, &lt;code&gt;EXPR2&lt;/code&gt; 는 &lt;code&gt;//&lt;/code&gt; 자체 컨텍스트에서 평가됩니다 .) 일반적으로 이는 &lt;code&gt;defined(EXPR1) ? EXPR1 : EXPR2&lt;/code&gt; (3 항 연산자 형식을 lvalue로 사용할 수 있다는 점을 제외하고 &lt;code&gt;EXPR1 // EXPR2&lt;/code&gt; 할 수 없습니다). 이것은 변수에 대한 기본값을 제공하는 데 매우 유용합니다. &lt;code&gt;$x&lt;/code&gt; 및 &lt;code&gt;$y&lt;/code&gt; 중 하나 이상 이 정의되어 있는지 실제로 테스트 하려면 &lt;code&gt;defined($x // $y)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3d57a21b7f19f0f3f2ceca275a472340c6e4e3a5" translate="yes" xml:space="preserve">
          <source>Although it has the same precedence as in C, Perl's &lt;code&gt;?:&lt;/code&gt; operator produces an lvalue. This assigns $x to either $if_true or $if_false, depending on the trueness of $maybe:</source>
          <target state="translated">C에서와 같은 우선 순위를 갖지만 Perl의 &lt;code&gt;?:&lt;/code&gt; 연산자는 lvalue를 생성합니다. $ maybe의 진실성에 따라 $ x를 $ if_true 또는 $ if_false에 할당합니다.</target>
        </trans-unit>
        <trans-unit id="5ee0b4360c14601bcb250b62e156bc4ae2010689" translate="yes" xml:space="preserve">
          <source>Although it is a bit confusing and some people object to the terminology, it is worth taking a look at a comment that has been in</source>
          <target state="translated">약간 혼란스럽고 일부 사람들은 용어에 반대하지만, 그 의견을 살펴볼 가치가 있습니다.</target>
        </trans-unit>
        <trans-unit id="da1e430c6e0d63cde26c5c8c71827f0d44bf6196" translate="yes" xml:space="preserve">
          <source>Although it is not illegal, the use of &lt;code&gt;MultiHomed&lt;/code&gt; on a socket which is in non-blocking mode is of little use. This is because the first connect will never fail with a timeout as the connect call will not block.</source>
          <target state="translated">불법은 아니지만 비 차단 모드 인 소켓 에서 &lt;code&gt;MultiHomed&lt;/code&gt; 를 사용하는 것은 거의 쓸모 가 없습니다 . 연결 호출이 차단되지 않기 때문에 첫 번째 연결이 시간 초과로 실패하지 않기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="e93362b29f52a34d35cc322a788d526233d087a7" translate="yes" xml:space="preserve">
          <source>Although it is possible (with some effort on your part) to use this module to access .zip files, there are other perl modules available that will do all the hard work for you. Check out &lt;code&gt;Archive::Zip&lt;/code&gt; , &lt;code&gt;Archive::Zip::SimpleZip&lt;/code&gt; , &lt;code&gt;IO::Compress::Zip&lt;/code&gt; and &lt;code&gt;IO::Uncompress::Unzip&lt;/code&gt; .</source>
          <target state="translated">이 모듈을 사용하여 .zip 파일에 액세스 할 수는 있지만 (모든 노력을 기울일 수있는) 다른 펄 모듈이 있습니다. 확인 &lt;code&gt;Archive::Zip&lt;/code&gt; , &lt;code&gt;Archive::Zip::SimpleZip&lt;/code&gt; , &lt;code&gt;IO::Compress::Zip&lt;/code&gt; 및 &lt;code&gt;IO::Uncompress::Unzip&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7c711291979b77793d98593cadd4dda9f5e5ad0f" translate="yes" xml:space="preserve">
          <source>Although it is possible (with some effort on your part) to use this module to access .zip files, there are other perl modules available that will do all the hard work for you. Check out &lt;code&gt;Archive::Zip&lt;/code&gt;, &lt;code&gt;Archive::Zip::SimpleZip&lt;/code&gt;, &lt;code&gt;IO::Compress::Zip&lt;/code&gt; and &lt;code&gt;IO::Uncompress::Unzip&lt;/code&gt;.</source>
          <target state="translated">이 모듈을 사용하여 .zip 파일에 액세스하는 것이 가능하지만 (여러분의 노력으로) 모든 노력을 수행 할 수있는 다른 펄 모듈이 있습니다. 확인 &lt;code&gt;Archive::Zip&lt;/code&gt; , &lt;code&gt;Archive::Zip::SimpleZip&lt;/code&gt; , &lt;code&gt;IO::Compress::Zip&lt;/code&gt; 및 &lt;code&gt;IO::Uncompress::Unzip&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7a135fdb236629c700a0674370bcc8d9bb97bd72" translate="yes" xml:space="preserve">
          <source>Although it may be considered internal, the class hierarchy does matter for both users and programmer. CPAN.pm deals with the four classes mentioned above, and those classes all share a set of methods. Classical single polymorphism is in effect. A metaclass object registers all objects of all kinds and indexes them with a string. The strings referencing objects have a separated namespace (well, not completely separated):</source>
          <target state="translated">내부적으로 간주 될 수 있지만 클래스 계층은 사용자와 프로그래머 모두에게 중요합니다. CPAN.pm은 위에서 언급 한 4 가지 클래스를 다루며, 이러한 클래스는 모두 일련의 메소드를 공유합니다. 고전적인 단일 다형성이 적용됩니다. 메타 클래스 객체는 모든 종류의 모든 객체를 등록하고 문자열로 색인합니다. 객체를 참조하는 문자열에는 분리 된 네임 스페이스가 있습니다 (완전히 분리되지는 않음).</target>
        </trans-unit>
        <trans-unit id="c770d25bc14389e491ccd1785ab555be61626cb8" translate="yes" xml:space="preserve">
          <source>Although it may not be immediately obvious from the code above, the associative array interface can be used to write values with duplicate keys, but it cannot be used to read them back from the database.</source>
          <target state="translated">위의 코드에서 즉시 알 수는 없지만 연관 배열 인터페이스를 사용하여 중복 키로 값을 쓸 수 있지만 데이터베이스에서 다시 읽을 수는 없습니다.</target>
        </trans-unit>
        <trans-unit id="180ef42cd3ef3f7ed108e6700423675760cce278" translate="yes" xml:space="preserve">
          <source>Although it might seem like a real pain, it is really worth the effort of having a &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict&lt;/code&gt; in all your scripts.</source>
          <target state="translated">그것은 진짜 고통처럼 보일지 모르지만, 모든 스크립트에서 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict&lt;/code&gt; &lt;a href=&quot;functions/use&quot;&gt;사용&lt;/a&gt; 하려는 노력의 가치가 있습니다.</target>
        </trans-unit>
        <trans-unit id="566dc93bd22756361b44728a27034002b97a3383" translate="yes" xml:space="preserve">
          <source>Although it might seem like a real pain, it is really worth the effort of having a &lt;code&gt;use strict&lt;/code&gt; in all your scripts.</source>
          <target state="translated">정말 고통스러워 보일지 모르지만 모든 스크립트에서 &lt;code&gt;use strict&lt;/code&gt; 하는 노력의 가치가 있습니다.</target>
        </trans-unit>
        <trans-unit id="1bf682b28167943a367ab8e4c8b1a462063a4d50" translate="yes" xml:space="preserve">
          <source>Although it's less convenient in some ways than the tied hash interface, you can also call methods directly to manipulate individual symbols. In some cases, this allows you finer control than using a tied hash aggregate. The following methods are supported:</source>
          <target state="translated">연결된 해시 인터페이스보다 어떤면에서는 덜 편리하지만 메서드를 직접 호출하여 개별 기호를 조작 할 수도 있습니다. 경우에 따라 연결된 해시 집계를 사용하는 것보다 더 세밀하게 제어 할 수 있습니다. 지원되는 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7eddb5fd279be6b295018b9f9f42e02ddccfda46" translate="yes" xml:space="preserve">
          <source>Although memory overhead of bigger buckets is kept inside the bucket, for smaller buckets, it is kept in separate areas. This field gives the total size of these areas.</source>
          <target state="translated">더 큰 버킷의 메모리 오버 헤드는 버킷 내부에 유지되지만 더 작은 버킷의 경우 별도의 영역에 유지됩니다. 이 필드는이 영역의 총 크기를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="89dede28bef0b8e7f141797013c579678fb08474" translate="yes" xml:space="preserve">
          <source>Although no warning is currently raised, the results are not well defined when these operations are performed on operands that aren't either numbers (see &lt;a href=&quot;#Integer-Arithmetic&quot;&gt;&quot;Integer Arithmetic&quot;&lt;/a&gt;) nor bitstrings (see &lt;a href=&quot;#Bitwise-String-Operators&quot;&gt;&quot;Bitwise String Operators&quot;&lt;/a&gt;).</source>
          <target state="translated">현재 경고가 발생하지 않지만 이러한 연산이 숫자 ( &lt;a href=&quot;#Integer-Arithmetic&quot;&gt;&quot;정수 산술&quot;&lt;/a&gt; 참조) 나 &lt;a href=&quot;#Bitwise-String-Operators&quot;&gt;비트 문자열&lt;/a&gt; ( &quot;비트 문자열 연산자&quot; 참조) 이 아닌 피연산자에 대해 수행되는 경우 결과가 제대로 정의되지 않았습니다 .</target>
        </trans-unit>
        <trans-unit id="5fe78f913ab3f5713143fe4461404c36ff017beb" translate="yes" xml:space="preserve">
          <source>Although no warning is currently raised, the results are not well defined when these operations are performed on operands that aren't either numbers (see &lt;a href=&quot;#Integer-Arithmetic&quot;&gt;Integer Arithmetic&lt;/a&gt;) nor bitstrings (see &lt;a href=&quot;#Bitwise-String-Operators&quot;&gt;Bitwise String Operators&lt;/a&gt;).</source>
          <target state="translated">현재 경고가 발생하지 않지만 숫자 ( &lt;a href=&quot;#Integer-Arithmetic&quot;&gt;정수 산술&lt;/a&gt; 참조 ) 또는 비트 열 ( &lt;a href=&quot;#Bitwise-String-Operators&quot;&gt;비트 별 문자열 연산자&lt;/a&gt; 참조) 이 아닌 피연산자에서 이러한 연산이 수행 될 때 결과가 제대로 정의되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="c94501363b8d49d883be5ef00569dcb0d5283b0f" translate="yes" xml:space="preserve">
          <source>Although not for the faint of heart, Perl does support a &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; statement. There are three forms: &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt;-LABEL, &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt;-EXPR, and &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt;-&amp;amp;NAME. A loop's LABEL is not actually a valid target for a &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt;; it's just the name of the loop.</source>
          <target state="translated">희미한 마음은 아니지만 Perl은 &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; 선언문을 지원합니다 . : 세 가지 형태가있다 &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; -label, &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; -EXPR, 그리고 &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; - &amp;amp; NAME은. 루프의 LABEL은 실제로 &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; 의 유효한 대상이 아닙니다 . 루프의 이름 일뿐입니다.</target>
        </trans-unit>
        <trans-unit id="1069922d0daa5d3be0e9150c826b5a6eaf7851b6" translate="yes" xml:space="preserve">
          <source>Although not for the faint of heart, Perl does support a &lt;code&gt;goto&lt;/code&gt; statement. There are three forms: &lt;code&gt;goto&lt;/code&gt;-LABEL, &lt;code&gt;goto&lt;/code&gt;-EXPR, and &lt;code&gt;goto&lt;/code&gt;-&amp;amp;NAME. A loop's LABEL is not actually a valid target for a &lt;code&gt;goto&lt;/code&gt;; it's just the name of the loop.</source>
          <target state="translated">희미한 마음은 아니지만 Perl은 &lt;code&gt;goto&lt;/code&gt; 문을 지원합니다 . : 세 가지 형태가있다 &lt;code&gt;goto&lt;/code&gt; -label, &lt;code&gt;goto&lt;/code&gt; -EXPR, 그리고 &lt;code&gt;goto&lt;/code&gt; - &amp;amp; NAME은. 루프의 LABEL은 실제로 &lt;code&gt;goto&lt;/code&gt; 의 유효한 대상이 아닙니다 . 루프의 이름 일뿐입니다.</target>
        </trans-unit>
        <trans-unit id="c556c081516373f750515951f1b9a5217dc9bdfc" translate="yes" xml:space="preserve">
          <source>Although one can already do quite a lot with the literal string regexps above, we've only scratched the surface of regular expression technology. In this and subsequent sections we will introduce regexp concepts (and associated metacharacter notations) that will allow a regexp to represent not just a single character sequence, but a</source>
          <target state="translated">위의 리터럴 문자열 정규 표현식으로 이미 많은 것을 할 수 있지만 정규 표현식 기술의 표면을 긁어 냈습니다. 이 섹션과 다음 섹션에서는 정규 표현식이 단일 문자 시퀀스뿐만 아니라 a를 나타내는 정규 표현식 개념 및 관련 메타 문자 표기법을 소개합니다.</target>
        </trans-unit>
        <trans-unit id="2365e59fbff407c44bacc5b415419bc0925eb6e4" translate="yes" xml:space="preserve">
          <source>Although one does not have to follow this convention, be aware that the convention for UNIX man pages for commands is for the man page title to be in all-uppercase, even if the command isn't.</source>
          <target state="translated">이 규칙을 따를 필요는 없지만 명령에 대한 UNIX man 페이지의 규칙은 명령이 그렇지 않더라도 man 페이지 제목이 모두 대문자로 표시되는 것입니다.</target>
        </trans-unit>
        <trans-unit id="18a0eac57e1c4484372ccab28955e18fb02ea640" translate="yes" xml:space="preserve">
          <source>Although one would expect the quantities $y and $z to be the same and equal to 100000 they will differ and instead will be 0 and 100000 respectively.</source>
          <target state="translated">비록 $ y와 $ z의 수량이 같고 100000과 같을 것으로 기대할지라도 그것들은 다르고 대신에 각각 0과 100000이 될 것입니다.</target>
        </trans-unit>
        <trans-unit id="5829c5fcc8ce3b64df01881896b3b15fd774741a" translate="yes" xml:space="preserve">
          <source>Although only a single value was expected to be returned from</source>
          <target state="translated">단 하나의 값만 반환 될 것으로 예상되었지만</target>
        </trans-unit>
        <trans-unit id="2a2b97db7310124d07426632d32011d83ef42107" translate="yes" xml:space="preserve">
          <source>Although primarily designed for use with multi-threaded Perl, the macros have been designed so that they will work with non-threaded Perl as well.</source>
          <target state="translated">매크로는 다중 스레드 Perl과 함께 사용하도록 설계되었지만 매크로는 스레드가 아닌 Perl에서도 작동하도록 설계되었습니다.</target>
        </trans-unit>
        <trans-unit id="797e69b4382557ebf9cc947a771d199448156185" translate="yes" xml:space="preserve">
          <source>Although similar, file path specifications differ between Unix, Windows, Mac OS, OS/2, VMS, VOS, RISC OS, and probably others. Unix, for example, is one of the few OSes that has the elegant idea of a single root directory.</source>
          <target state="translated">비슷하지만 파일 경로 사양은 Unix, Windows, Mac OS, OS / 2, VMS, VOS, RISC OS 및 아마도 다를 수 있습니다. 예를 들어, 유닉스는 단일 루트 디렉토리에 대한 우아한 아이디어를 가진 몇 안되는 OS 중 하나입니다.</target>
        </trans-unit>
        <trans-unit id="d6190ff15955860c6c9fdd297f5be90390874780" translate="yes" xml:space="preserve">
          <source>Although test failures should be enough, extra diagnostics can be triggered at the end of a test run. &lt;code&gt;onfail&lt;/code&gt; is passed an array ref of hash refs that describe each test failure. Each hash will contain at least the following fields: &lt;code&gt;&lt;a href=&quot;functions/package&quot;&gt;package&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;repetition&lt;/code&gt; , and &lt;code&gt;result&lt;/code&gt; . (You shouldn't rely on any other fields being present.) If the test had an expected value or a diagnostic (or &quot;note&quot;) string, these will also be included.</source>
          <target state="translated">테스트 실패는 충분해야하지만 테스트 실행이 끝나면 추가 진단이 트리거 될 수 있습니다. &lt;code&gt;onfail&lt;/code&gt; 에는 각 테스트 실패를 설명하는 해시 참조의 배열 참조가 전달됩니다. 각 해시에는 최소한 &lt;code&gt;&lt;a href=&quot;functions/package&quot;&gt;package&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;repetition&lt;/code&gt; 및 &lt;code&gt;result&lt;/code&gt; 필드가 포함됩니다 . (현재 존재하는 다른 필드에 의존해서는 안됩니다.) 테스트에 예상 값이나 진단 (또는 &quot;주&quot;) 문자열이 있으면 이것도 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="cb955315f15c5e807d16b61b980d5ee47a32430b" translate="yes" xml:space="preserve">
          <source>Although test failures should be enough, extra diagnostics can be triggered at the end of a test run. &lt;code&gt;onfail&lt;/code&gt; is passed an array ref of hash refs that describe each test failure. Each hash will contain at least the following fields: &lt;code&gt;package&lt;/code&gt;, &lt;code&gt;repetition&lt;/code&gt;, and &lt;code&gt;result&lt;/code&gt;. (You shouldn't rely on any other fields being present.) If the test had an expected value or a diagnostic (or &quot;note&quot;) string, these will also be included.</source>
          <target state="translated">테스트 실패로 충분해야하지만 테스트 실행이 끝날 때 추가 진단이 트리거 될 수 있습니다. &lt;code&gt;onfail&lt;/code&gt; 에는 각 테스트 실패를 설명하는 해시 참조의 배열 참조가 전달됩니다. 각 해시는 적어도 다음 필드를 포함합니다 : &lt;code&gt;package&lt;/code&gt; , &lt;code&gt;repetition&lt;/code&gt; 및 &lt;code&gt;result&lt;/code&gt; . (존재하는 다른 필드에 의존해서는 안됩니다.) 테스트에 예상 값이나 진단 (또는 &quot;참고&quot;) 문자열이있는 경우 이들도 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="224e863badf25248ea988718d8bd34cef72cce5a" translate="yes" xml:space="preserve">
          <source>Although that form may run into trouble in network transit (due to the presence of 8 bit characters) or on non ISO-Latin character sets. But it does allow &lt;code&gt;Is_c1&lt;/code&gt; to be rewritten so it works on Perls that don't have &lt;code&gt;'unicode_strings'&lt;/code&gt; (earlier than v5.14):</source>
          <target state="translated">이 형식은 네트워크 전송 (8 비트 문자로 인해) 또는 ISO- 라틴 문자 이외의 문자 집합에서 문제가 발생할 수 있습니다. 그러나 &lt;code&gt;Is_c1&lt;/code&gt; 을 다시 작성하여 &lt;code&gt;'unicode_strings'&lt;/code&gt; (v5.14 이전) 가없는 Perls에서 작동합니다 .</target>
        </trans-unit>
        <trans-unit id="99123ea723cf2a29473e47c091f28928ebbdafd8" translate="yes" xml:space="preserve">
          <source>Although the &lt;code&gt;%&lt;/code&gt; code is documented as returning a &quot;checksum&quot;: don't put your trust in such values! Even when applied to a small number of bytes, they won't guarantee a noticeable Hamming distance.</source>
          <target state="translated">&lt;code&gt;%&lt;/code&gt; 코드는 &quot;체크섬&quot;을 반환하는 것으로 문서화되어 있지만 이러한 값을 신뢰하지 마십시오! 적은 수의 바이트에 적용하더라도 눈에 띄는 해밍 거리를 보장하지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="6834c0c595f466c17dc9377b6377ec111fa7e11c" translate="yes" xml:space="preserve">
          <source>Although the above may seem a bit confusing at first, it generally does &quot;the right thing&quot; in most situations. This determination of the default values to use is based upon the following typical Unix conventions:</source>
          <target state="translated">위의 내용은 처음에는 약간 혼란스러워 보일 수 있지만 일반적으로 대부분의 상황에서 &quot;옳은 일&quot;을합니다. 사용할 기본값의 결정은 다음과 같은 일반적인 Unix 규칙을 기반으로합니다.</target>
        </trans-unit>
        <trans-unit id="a0b752b8fd0002195999a4940b4a67ff51de0cf2" translate="yes" xml:space="preserve">
          <source>Although the error message above refers to the second tie() statement in the script, the source of the problem is really with the untie() statement that precedes it.</source>
          <target state="translated">위의 오류 메시지는 스크립트의 두 번째 tie () 문을 참조하지만 문제의 원인은 실제로 앞에 나오는 untie () 문입니다.</target>
        </trans-unit>
        <trans-unit id="050771d84c3ebf7bfb6e4438000d2961a2adc2a7" translate="yes" xml:space="preserve">
          <source>Although the functionality provided by this flag may seem straightforward, it should be used only if there is a good reason to do so. The reason for being cautious is that, even if you have specified the G_NOARGS flag, it is still possible for the Perl subroutine that has been called to think that you have passed it parameters.</source>
          <target state="translated">이 플래그가 제공하는 기능은 간단 해 보일 수 있지만 그럴만한 이유가있는 경우에만 사용해야합니다. 주의해야 할 이유는 G_NOARGS 플래그를 지정한 경우에도 호출 된 Perl 서브 루틴이 매개 변수를 전달했다고 생각할 가능성이 있기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="0019a6a5066bef3137d87deda446668085e7063b" translate="yes" xml:space="preserve">
          <source>Although the ignored argument doesn't go into a variable, it is still mandatory for the caller to pass it.</source>
          <target state="translated">무시 된 인수는 변수로 들어 가지 않지만 호출자가 변수를 전달해야합니다.</target>
        </trans-unit>
        <trans-unit id="35ed9f698c7272524026c7a45834a834a74d7bb0" translate="yes" xml:space="preserve">
          <source>Although the main discussion of Perl security issues can be found in &lt;a href=&quot;perlsec&quot;&gt;perlsec&lt;/a&gt;, a discussion of Perl's locale handling would be incomplete if it did not draw your attention to locale-dependent security issues. Locales--particularly on systems that allow unprivileged users to build their own locales--are untrustworthy. A malicious (or just plain broken) locale can make a locale-aware application give unexpected results. Here are a few possibilities:</source>
          <target state="translated">Perl 보안 문제에 대한 주요 논의는 &lt;a href=&quot;perlsec&quot;&gt;perlsec&lt;/a&gt; 에서 찾을 수 있지만 , 로케일 종속 보안 문제에주의를 기울이지 않으면 Perl의 로케일 처리에 대한 논의는 불완전합니다. 권한이없는 사용자가 자신의 로캘을 만들 수있는 시스템의 로캘은 특히 신뢰할 수 없습니다. 악의적 인 (또는 단절된) 로캘은 로캘 인식 응용 프로그램에서 예기치 않은 결과를 제공 할 수 있습니다. 몇 가지 가능성이 있습니다.</target>
        </trans-unit>
        <trans-unit id="6ad8f5d884e3bfe99068d75f61c2b91c556f88ba" translate="yes" xml:space="preserve">
          <source>Although the most deeply nested array or hash element will not spring into existence just because its existence was tested, any intervening ones will. Thus &lt;code&gt;$ref-&amp;gt;{&quot;A&quot;}&lt;/code&gt; and &lt;code&gt;$ref-&amp;gt;{&quot;A&quot;}-&amp;gt;{&quot;B&quot;}&lt;/code&gt; will spring into existence due to the existence test for the $key element above. This happens anywhere the arrow operator is used, including even here:</source>
          <target state="translated">가장 깊게 중첩 된 배열 또는 해시 요소는 존재 여부가 테스트 되었기 때문에 존재하지 않을 것이지만, 어떤 중간 요소도 존재합니다. 따라서 &lt;code&gt;$ref-&amp;gt;{&quot;A&quot;}&lt;/code&gt; 및 &lt;code&gt;$ref-&amp;gt;{&quot;A&quot;}-&amp;gt;{&quot;B&quot;}&lt;/code&gt; 는 위의 $ key 요소에 대한 존재 테스트로 인해 존재하게됩니다. 여기에도 화살표 연산자가 사용되는 모든 곳에서 발생합니다.</target>
        </trans-unit>
        <trans-unit id="d1b22581bc0b80baeffbb205fa759bdb0ff242e5" translate="yes" xml:space="preserve">
          <source>Although the most deeply nested array or hash element will not spring into existence just because its existence was tested, any intervening ones will. Thus &lt;code&gt;$ref-&amp;gt;{&quot;A&quot;}&lt;/code&gt; and &lt;code&gt;$ref-&amp;gt;{&quot;A&quot;}-&amp;gt;{&quot;B&quot;}&lt;/code&gt; will spring into existence due to the existence test for the &lt;code&gt;$key&lt;/code&gt; element above. This happens anywhere the arrow operator is used, including even here:</source>
          <target state="translated">가장 깊이 중첩 된 배열 또는 해시 요소는 그 존재가 테스트 되었기 때문에 존재하지 않지만, 중간에있는 요소는 존재합니다. 따라서 &lt;code&gt;$ref-&amp;gt;{&quot;A&quot;}&lt;/code&gt; 및 &lt;code&gt;$ref-&amp;gt;{&quot;A&quot;}-&amp;gt;{&quot;B&quot;}&lt;/code&gt; 는 위 의 &lt;code&gt;$key&lt;/code&gt; 요소에 대한 존재 테스트로 인해 존재하게됩니다 . 이것은 여기를 포함하여 화살표 연산자가 사용되는 모든 곳에서 발생합니다.</target>
        </trans-unit>
        <trans-unit id="ece6731e40fd98f25883ef891976cdd74d8b5353" translate="yes" xml:space="preserve">
          <source>Although the optree is read-only, there is an overlay facility that allows you to override what values the various B::*OP methods return for a particular op. &lt;code&gt;$B::overlay&lt;/code&gt; should be set to reference a two-deep hash: indexed by OP address, then method name. Whenever a an op method is called, the value in the hash is returned if it exists. This facility is used by B::Deparse to &quot;undo&quot; some optimisations. For example:</source>
          <target state="translated">optree는 읽기 전용이지만 다양한 B :: * OP 메소드가 특정 op에 대해 리턴하는 값을 대체 할 수있는 오버레이 기능이 있습니다. &lt;code&gt;$B::overlay&lt;/code&gt; 는 OP 주소로 색인화 된 2 개의 깊은 해시와 메소드 이름을 참조하도록 설정해야합니다. op 메소드가 호출 될 때마다 해시의 값이 있으면 리턴됩니다. 이 기능은 B :: Deparse에서 일부 최적화를 &quot;실행 취소&quot;하기 위해 사용합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4006666c099c71fba2fd95778e8d769cab92e521" translate="yes" xml:space="preserve">
          <source>Although the primary purpose for the existence of &lt;code&gt;Compress::Raw::Bzip2&lt;/code&gt; is for use by the &lt;code&gt;IO::Compress::Bzip2&lt;/code&gt; and &lt;code&gt;IO::Compress::Bunzip2&lt;/code&gt; modules, it can be used on its own for simple compression/uncompression tasks.</source>
          <target state="translated">&lt;code&gt;Compress::Raw::Bzip2&lt;/code&gt; 의 기본 목적 은 &lt;code&gt;IO::Compress::Bzip2&lt;/code&gt; 및 &lt;code&gt;IO::Compress::Bunzip2&lt;/code&gt; 모듈에서 사용하기위한 것이지만 간단한 압축 / 압축 해제 작업을 위해 자체적으로 사용할 수 있습니다. .</target>
        </trans-unit>
        <trans-unit id="73cce3599d213093393a3d6545498d75ae280481" translate="yes" xml:space="preserve">
          <source>Although the techniques described here are applicable when embedding Perl in a C program, this is not the primary goal of this document. There are other details that must be considered and are specific to embedding Perl. For details on embedding Perl in C refer to &lt;a href=&quot;perlembed&quot;&gt;perlembed&lt;/a&gt;.</source>
          <target state="translated">여기에 설명 된 기술은 Perl을 C 프로그램에 임베드 할 때 적용 할 수 있지만이 문서의 기본 목표는 아닙니다. 고려해야 할 다른 세부 사항이 있으며 Perl 포함과 관련이 있습니다. C에서 Perl을 임베드하는 것에 대한 자세한 내용은 &lt;a href=&quot;perlembed&quot;&gt;perlembed를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="14e1e99a665303302472280aa271e6e7551860a9" translate="yes" xml:space="preserve">
          <source>Although there can be any number of source streams in existence at any given time, only one will be active.</source>
          <target state="translated">주어진 시간에 여러 소스 스트림이 존재할 수 있지만 하나만 활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="837688ce8fc062bca9030ce8b90ed396865f417d" translate="yes" xml:space="preserve">
          <source>Although these are grouped by family, they all have the precedence of assignment. These combined assignment operators can only operate on scalars, whereas the ordinary assignment operator can assign to arrays, hashes, lists and even references. (See &lt;a href=&quot;perldata#Context&quot;&gt;&quot;Context&quot;&lt;/a&gt; and &lt;a href=&quot;perldata#List-value-constructors&quot;&gt;&quot;List value constructors&quot; in perldata&lt;/a&gt;, and &lt;a href=&quot;perlref#Assigning-to-References&quot;&gt;&quot;Assigning to References&quot; in perlref&lt;/a&gt;.)</source>
          <target state="translated">이들은 가족별로 그룹화되어 있지만 모두 할당 우선 순위가 있습니다. 이러한 결합 된 할당 연산자는 스칼라에서만 작동 할 수있는 반면 일반 할당 연산자는 배열, 해시, 목록 및 참조에도 할당 할 수 있습니다. ( &lt;a href=&quot;perldata#List-value-constructors&quot;&gt;perldata의 &lt;/a&gt;&lt;a href=&quot;perldata#Context&quot;&gt;&quot;컨텍스트&quot;&lt;/a&gt; 및 &quot;목록 값 생성자&quot; 및 &lt;a href=&quot;perlref#Assigning-to-References&quot;&gt;perlref의 &quot;참조에 할당&quot;을 참조하십시오&lt;/a&gt; .)</target>
        </trans-unit>
        <trans-unit id="c84534656a685169f0194cbbe1e16531f562b033" translate="yes" xml:space="preserve">
          <source>Although these are grouped by family, they all have the precedence of assignment. These combined assignment operators can only operate on scalars, whereas the ordinary assignment operator can assign to arrays, hashes, lists and even references. (See &lt;a href=&quot;perldata#Context&quot;&gt;Context&lt;/a&gt; and &lt;a href=&quot;perldata#List-value-constructors&quot;&gt;List value constructors in perldata&lt;/a&gt;, and &lt;a href=&quot;perlref#Assigning-to-References&quot;&gt;Assigning to References in perlref&lt;/a&gt;.)</source>
          <target state="translated">이들은 가족별로 그룹화되어 있지만 모두 우선 순위가 있습니다. 이 결합 된 할당 연산자는 스칼라에서만 작동 할 수있는 반면 일반 할당 연산자는 배열, 해시, 목록 및 참조에도 할당 할 수 있습니다. ( &lt;a href=&quot;perldata#List-value-constructors&quot;&gt;perldata의 &lt;/a&gt;&lt;a href=&quot;perldata#Context&quot;&gt;컨텍스트&lt;/a&gt; 및 목록 값 생성자 및 &lt;a href=&quot;perlref#Assigning-to-References&quot;&gt;perlref의 참조에 지정 참조&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="1f0ef7687de397f14de7592d67f915d2f79f2a4c" translate="yes" xml:space="preserve">
          <source>Although this function returns its values on the perl argument stack, it doesn't take any parameters from that stack (and thus in particular there's no need to do a &lt;code&gt;PUSHMARK&lt;/code&gt; before calling it, unlike &lt;a href=&quot;#call_pv&quot;&gt;&quot;call_pv&quot;&lt;/a&gt; for example).</source>
          <target state="translated">이 함수는 perl 인수 스택에 해당 값을 반환하지만 해당 스택에서 매개 변수를 가져 오지 않습니다 (따라서 예를 들어 &lt;a href=&quot;#call_pv&quot;&gt;&quot;call_pv&quot;&lt;/a&gt; 와 달리 호출하기 전에 &lt;code&gt;PUSHMARK&lt;/code&gt; 를 수행 할 필요가 없습니다 ).</target>
        </trans-unit>
        <trans-unit id="459be48ccfdeb87ea73fbd1fbec51d1410292106" translate="yes" xml:space="preserve">
          <source>Although this function returns its values on the perl argument stack, it doesn't take any parameters from that stack (and thus in particular there's no need to do a PUSHMARK before calling it, unlike &lt;a href=&quot;#call_pv&quot;&gt;call_pv&lt;/a&gt; for example).</source>
          <target state="translated">이 기능은 펄 인수 스택에 그 값을 반환하지만, 그 스택에서 매개 변수를 고려하지 않습니다 (따라서 특히 달리를 호출하기 전에 푸쉬 마크를 할 필요가 없습니다 &lt;a href=&quot;#call_pv&quot;&gt;call_pv&lt;/a&gt; 예를 들어는).</target>
        </trans-unit>
        <trans-unit id="9ecb9099e922e4493577adbe3649de5e0005a135" translate="yes" xml:space="preserve">
          <source>Although this keyword is optional and in some cases provides redundant information it should always be used. This keyword will ensure that the XSUBs appear in the desired package.</source>
          <target state="translated">이 키워드는 선택 사항이며 경우에 따라 중복 정보를 제공하지만 항상 사용해야합니다. 이 키워드는 XSUB가 원하는 패키지에 표시되도록합니다.</target>
        </trans-unit>
        <trans-unit id="66fb31ad783a8264f17dab51f3aa1ad011017a08" translate="yes" xml:space="preserve">
          <source>Although this option can be used with the OO interface, it is of most use with the one-shot interface. For example, the code below shows how &lt;code&gt;FilterName&lt;/code&gt; can be used to remove the path component from a series of filenames before they are stored in &lt;code&gt;$zipfile&lt;/code&gt; .</source>
          <target state="translated">이 옵션은 OO 인터페이스와 함께 사용할 수 있지만 대부분 원샷 인터페이스와 함께 사용됩니다. 예를 들어, 아래 코드는 &lt;code&gt;FilterName&lt;/code&gt; 을 사용하여 &lt;code&gt;$zipfile&lt;/code&gt; 저장되기 전에 일련의 파일 이름에서 경로 구성 요소를 제거하는 방법을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="e7045e0d3148f2b5800c2c6d6d41c5d9e7c09642" translate="yes" xml:space="preserve">
          <source>Although this option can be used with the OO interface, it is of most use with the one-shot interface. For example, the code below shows how &lt;code&gt;FilterName&lt;/code&gt; can be used to remove the path component from a series of filenames before they are stored in &lt;code&gt;$zipfile&lt;/code&gt;.</source>
          <target state="translated">이 옵션은 OO 인터페이스와 함께 사용할 수 있지만 원샷 인터페이스에서 가장 많이 사용됩니다. 예를 들어, 아래 코드 는 &lt;code&gt;$zipfile&lt;/code&gt; 저장되기 전에 &lt;code&gt;FilterName&lt;/code&gt; 을 사용하여 일련의 파일 이름에서 경로 구성 요소를 제거하는 방법을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="2398658140451226b4cd3f1886215ebf8c65091f" translate="yes" xml:space="preserve">
          <source>Although this stuff is easier to explain using examples, you first need be aware of a few important definitions.</source>
          <target state="translated">이 내용은 예제를 사용하여 설명하기가 쉽지만 먼저 몇 가지 중요한 정의를 알고 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="5d6b9d5e42d7a86677e3f471c1e47e328daf1dc8" translate="yes" xml:space="preserve">
          <source>Although very useful, the big problem with using &lt;b&gt;-w&lt;/b&gt; on the command line to enable warnings is that it is all or nothing. Take the typical scenario when you are writing a Perl program. Parts of the code you will write yourself, but it's very likely that you will make use of pre-written Perl modules. If you use the &lt;b&gt;-w&lt;/b&gt; flag in this case, you end up enabling warnings in pieces of code that you haven't written.</source>
          <target state="translated">매우 유용하지만 경고를 활성화하기 위해 명령 줄에서 &lt;b&gt;-w&lt;/b&gt; 를 사용하는 데있어 큰 문제 는 전부 또는 아무것도 없다는 것입니다. Perl 프로그램을 작성할 때 일반적인 시나리오를 수행하십시오. 코드의 일부는 스스로 작성하지만 미리 작성된 Perl 모듈을 사용할 가능성이 큽니다. 이 경우 &lt;b&gt;-w&lt;/b&gt; 플래그 를 사용하면 작성하지 않은 코드 조각에 경고를 사용할 수있게됩니다.</target>
        </trans-unit>
        <trans-unit id="560edbbb945d8ba093edcea345708feb744a0493" translate="yes" xml:space="preserve">
          <source>Although we do suggest that you always build your own Perl from the source code, both for maximal configurability and for security, in case you are in a hurry you can check &lt;a href=&quot;http://www.cpan.org/ports/index.html&quot;&gt;http://www.cpan.org/ports/index.html&lt;/a&gt; for binary distributions.</source>
          <target state="translated">최대한의 구성 가능성과 보안을 위해 항상 소스 코드에서 자체 Perl을 빌드하는 것이 좋습니다. 급한 경우 &lt;a href=&quot;http://www.cpan.org/ports/index.html&quot;&gt;http://www.cpan.org/ports/index.html&lt;/a&gt; 을 확인할 수 있습니다 . 이진 분포.</target>
        </trans-unit>
        <trans-unit id="cd023125cfeba9eec78f15bbf69240c8b819181b" translate="yes" xml:space="preserve">
          <source>Although we wish to free any temps at the same time, we have to be careful not to free any temps which are keeping return args alive; nor to free the temps we have just created while mortal copying return args. Fortunately, &lt;code&gt;leave_adjust_stacks()&lt;/code&gt; is capable of making mortal copies of return args, shifting args down the stack, and only processing those entries on the temps stack that are safe to do so.</source>
          <target state="translated">비록 우리가 동시에 어떤 임시를 해제하길 원하지만, 우리는 return args를 유지하고있는 임시를 해방하지 않도록주의해야합니다; 필사자가 반환 인수를 복사하는 동안 방금 만든 임시를 해제하지도 않습니다. 다행히 &lt;code&gt;leave_adjust_stacks()&lt;/code&gt; 는 반환 인수의 필사적 복사본을 만들고 인수를 스택 아래로 이동하며 안전한 임시 스택의 항목 만 처리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="46ce08a44dd2ba4f6ce9e91fa3d420e93dff144d" translate="yes" xml:space="preserve">
          <source>Although write can work with lexical or package variables, whatever variables you use have to scope in the format. That most likely means you'll want to localize some package variables:</source>
          <target state="translated">쓰기가 어휘 또는 패키지 변수와 함께 작동 할 수 있지만 사용하는 모든 변수는 형식으로 범위를 지정해야합니다. 아마도 대부분의 패키지 변수를 현지화하고 싶을 것입니다.</target>
        </trans-unit>
        <trans-unit id="e5edf100e2a7db4baae600915e4757f07b6f80de" translate="yes" xml:space="preserve">
          <source>Although, for historical reasons, the &lt;a href=&quot;Test::Harness&quot;&gt;Test::Harness&lt;/a&gt; distribution takes its name from this module it now exists only to provide &lt;a href=&quot;TAP::Harness&quot;&gt;TAP::Harness&lt;/a&gt; with an interface that is somewhat backwards compatible with &lt;a href=&quot;Test::Harness&quot;&gt;Test::Harness&lt;/a&gt; 2.xx. If you're writing new code consider using &lt;a href=&quot;TAP::Harness&quot;&gt;TAP::Harness&lt;/a&gt; directly instead.</source>
          <target state="translated">역사적 이유로 &lt;a href=&quot;Test::Harness&quot;&gt;Test :: Harness&lt;/a&gt; 분포는이 모듈에서 이름을 따 왔지만 이제는 &lt;a href=&quot;Test::Harness&quot;&gt;Test :: Harness&lt;/a&gt; 2.xx 와 어느 정도 역 호환되는 인터페이스로 &lt;a href=&quot;TAP::Harness&quot;&gt;TAP :: Harness&lt;/a&gt; 를 제공하기 위해서만 존재합니다. 새 코드를 작성하는 경우 대신 &lt;a href=&quot;TAP::Harness&quot;&gt;TAP :: Harness를&lt;/a&gt; 직접 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="e1e9346790d51b0db2514b5ac70a5da4526349c7" translate="yes" xml:space="preserve">
          <source>Although, for historical reasons, the &lt;a href=&quot;harness&quot;&gt;Test::Harness&lt;/a&gt; distribution takes its name from this module it now exists only to provide &lt;a href=&quot;../tap/harness&quot;&gt;TAP::Harness&lt;/a&gt; with an interface that is somewhat backwards compatible with &lt;a href=&quot;harness&quot;&gt;Test::Harness&lt;/a&gt; 2.xx. If you're writing new code consider using &lt;a href=&quot;../tap/harness&quot;&gt;TAP::Harness&lt;/a&gt; directly instead.</source>
          <target state="translated">역사적 이유로 &lt;a href=&quot;harness&quot;&gt;Test :: Harness&lt;/a&gt; 분배는이 모듈에서 이름을 가져 왔지만 이제는 &lt;a href=&quot;harness&quot;&gt;Test :: Harness&lt;/a&gt; 2.xx 와 다소 역 호환되는 인터페이스를 &lt;a href=&quot;../tap/harness&quot;&gt;TAP :: Harness&lt;/a&gt; 에 제공하기 위해서만 존재합니다. 새 코드를 작성하는 경우 &lt;a href=&quot;../tap/harness&quot;&gt;TAP :: Harness를&lt;/a&gt; 직접 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="31fcae02d3e65b92831cdd124f189410606de910" translate="yes" xml:space="preserve">
          <source>Alvestrand, Harald Tveit. 1995.</source>
          <target state="translated">Alvestrand, Harald Tveit. 1995.</target>
        </trans-unit>
        <trans-unit id="f966b3ea336af8830bc18236a5389bd937c78b7c" translate="yes" xml:space="preserve">
          <source>Always be civil.</source>
          <target state="translated">항상 시민이 되십시오.</target>
        </trans-unit>
        <trans-unit id="c369c01b27ace1a743bc3e37d378c5dbbf093f50" translate="yes" xml:space="preserve">
          <source>Always check the return codes of system calls. Good error messages should go to &lt;code&gt;STDERR&lt;/code&gt; , include which program caused the problem, what the failed system call and arguments were, and (VERY IMPORTANT) should contain the standard system error message for what went wrong. Here's a simple but sufficient example:</source>
          <target state="translated">항상 시스템 호출의 리턴 코드를 확인하십시오. 좋은 오류 메시지는 &lt;code&gt;STDERR&lt;/code&gt; 로 이동해야합니다. 어떤 프로그램이 문제를 일으켰는지, 실패한 시스템 호출 및 인수가 무엇인지, (매우 중요 함)에는 무엇이 잘못되었는지에 대한 표준 시스템 오류 메시지가 포함되어야합니다. 간단하지만 충분한 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c9f2011c5ea88ecfcfb89f58ad78e623f2ab76d8" translate="yes" xml:space="preserve">
          <source>Always check the return codes of system calls. Good error messages should go to &lt;code&gt;STDERR&lt;/code&gt;, include which program caused the problem, what the failed system call and arguments were, and (VERY IMPORTANT) should contain the standard system error message for what went wrong. Here's a simple but sufficient example:</source>
          <target state="translated">항상 시스템 호출의 리턴 코드를 확인하십시오. 좋은 오류 메시지는 &lt;code&gt;STDERR&lt;/code&gt; 로 이동하고 , 문제를 일으킨 프로그램, 실패한 시스템 호출 및 인수가 무엇인지, (매우 중요 함)에는 무엇이 잘못되었는지에 대한 표준 시스템 오류 메시지가 포함되어야합니다. 다음은 간단하지만 충분한 예입니다.</target>
        </trans-unit>
        <trans-unit id="5844f1a31b652c47f84d0aaae5c714b741011321" translate="yes" xml:space="preserve">
          <source>Always commit changes to config variables to disk?</source>
          <target state="translated">항상 구성 변수에 대한 변경 사항을 디스크에 커밋합니까?</target>
        </trans-unit>
        <trans-unit id="c9994fb26151727507038319136d7dd61608906c" translate="yes" xml:space="preserve">
          <source>Always comparing to a version object will help avoid surprises:</source>
          <target state="translated">항상 버전 객체와 비교하면 놀라움을 피하는 데 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="cd2fdc72c972de55363038192e944aae07f2f5ef" translate="yes" xml:space="preserve">
          <source>Always decompose on the way in, then recompose on the way out.</source>
          <target state="translated">항상 도중에 분해 한 다음 밖으로 나갈 때 재구성하십시오.</target>
        </trans-unit>
        <trans-unit id="a981ab84adf96ff26a362806abc6776217d3e6df" translate="yes" xml:space="preserve">
          <source>Always evaluates to &lt;code&gt;%X&lt;/code&gt;, the locale's appropriate time representation.</source>
          <target state="translated">항상 로케일의 적절한 시간 표현 인 &lt;code&gt;%X&lt;/code&gt; 평가됩니다 .</target>
        </trans-unit>
        <trans-unit id="36ade828ef985c357a4f590a718feea06b8ef69f" translate="yes" xml:space="preserve">
          <source>Always evaluates to &lt;code&gt;%c&lt;/code&gt;, the locale's appropriate date and time representation.</source>
          <target state="translated">항상 로케일의 적절한 날짜 및 시간 표현 인 &lt;code&gt;%c&lt;/code&gt; 평가됩니다 .</target>
        </trans-unit>
        <trans-unit id="500eaed1bf2ab70574a92f0ee3e10b9af4499072" translate="yes" xml:space="preserve">
          <source>Always evaluates to &lt;code&gt;%x&lt;/code&gt;, the locale's appropriate date representation.</source>
          <target state="translated">항상 로케일의 적절한 날짜 표현 인 &lt;code&gt;%x&lt;/code&gt; 평가됩니다 .</target>
        </trans-unit>
        <trans-unit id="8c61fff2e0b1e2b49630e69bc2a2e99ec24ecff3" translate="yes" xml:space="preserve">
          <source>Always explicitly and immediately call close() on the writable end of any pipe, unless that process is actually writing to it. Even if you don't explicitly call close(), Perl will still close() all filehandles during global destruction. As previously discussed, if those filehandles have been opened with Safe Pipe Open, this will result in calling waitpid(), which may again deadlock.</source>
          <target state="translated">해당 프로세스가 실제로 파이프에 쓰지 않는 한 파이프의 쓰기 가능한 끝에서 항상 명시적이고 즉시 close ()를 호출하십시오. 명시 적으로 close ()를 호출하지 않더라도 Perl은 전역 삭제 중에 모든 파일 핸들을 닫습니다 (). 앞에서 설명한 것처럼 해당 파일 핸들을 Safe Pipe Open으로 열면 waitpid ()가 호출되어 교착 상태가 다시 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="242eddbfa115df236054209d0570301b5af3c68e" translate="yes" xml:space="preserve">
          <source>Always place the START_MY_CXT macro directly after the declaration of &lt;code&gt;my_cxt_t&lt;/code&gt; .</source>
          <target state="translated">항상 직접 선언 후 START_MY_CXT 매크로를 배치 &lt;code&gt;my_cxt_t&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2a1f78b377f3f4dbcc2f8cd296fbf35bd7322707" translate="yes" xml:space="preserve">
          <source>Always place the START_MY_CXT macro directly after the declaration of &lt;code&gt;my_cxt_t&lt;/code&gt;.</source>
          <target state="translated">항상 직접 선언 후 START_MY_CXT 매크로를 배치 &lt;code&gt;my_cxt_t&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="891f99ab9e41224456357d41b700c51457def43d" translate="yes" xml:space="preserve">
          <source>Always quote the version</source>
          <target state="translated">항상 버전을 인용</target>
        </trans-unit>
        <trans-unit id="33f26e154493acc9e3d45671d863271e7464d39e" translate="yes" xml:space="preserve">
          <source>Always strive to remain compatible with previous released versions. Otherwise try to add a mechanism to revert to the old behavior if people rely on it. Document incompatible changes.</source>
          <target state="translated">항상 이전에 출시 된 버전과 호환되도록 노력하십시오. 그렇지 않으면 사람들이 의존하는 경우 이전 동작으로 되돌릴 메커니즘을 추가하십시오. 호환되지 않는 변경 사항을 문서화하십시오.</target>
        </trans-unit>
        <trans-unit id="1c41f11cd18971bbdb3e2ef9969d459e5296677c" translate="yes" xml:space="preserve">
          <source>Always try to check and verify signatures if a SIGNATURE file is in the package and Module::Signature is installed (yes/no)?</source>
          <target state="translated">SIGNATURE 파일이 패키지에 있고 Module :: Signature가 설치된 경우 항상 서명을 확인하고 확인하려고합니까 (예 / 아니오)?</target>
        </trans-unit>
        <trans-unit id="24f1e77216b2edc00da08bfb70769a17a94800b4" translate="yes" xml:space="preserve">
          <source>Always try to show upload date with 'd' and 'm' command (yes/no)?</source>
          <target state="translated">항상 'd'및 'm'명령으로 업로드 날짜를 표시하려고합니까 (예 / 아니요)?</target>
        </trans-unit>
        <trans-unit id="ab3692e008452cea5b34a3fe52ad03c81207161c" translate="yes" xml:space="preserve">
          <source>Always use &lt;b&gt;-w&lt;/b&gt;.</source>
          <target state="translated">항상 &lt;b&gt;-w를&lt;/b&gt; 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="f5dc9ef4a983f2881df95298081703042e4c314a" translate="yes" xml:space="preserve">
          <source>Always use a dotted-decimal with (at least) three components</source>
          <target state="translated">항상 (적어도) 세 개의 구성 요소와 함께 점으로 구분 된 십진수를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="1af0291b70c5a30fa81736f480600ed39cabe174" translate="yes" xml:space="preserve">
          <source>Always use a leading-v</source>
          <target state="translated">항상 선행 v를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="8367b54257a55d960e03d572f3ffce6e4f988276" translate="yes" xml:space="preserve">
          <source>Always use with a subtag. Notable forms: {sgn-gb} British Sign Language (BSL); {sgn-ie} Irish Sign Language (ESL); {sgn-ni} Nicaraguan Sign Language (ISN); {sgn-us} American Sign Language (ASL).</source>
          <target state="translated">항상 하위 태그와 함께 사용하십시오. 주목할만한 형태 : {sgn-gb} 영국 수화 (BSL); {sgn-ie} 아일랜드 수화 (ESL); {sgn-ni} 니카라과 수화 (ISN); {sgn-us} 미국 수화 (ASL).</target>
        </trans-unit>
        <trans-unit id="d7fc26ae93e0cf00af5e88a1fe69971068f3bf0a" translate="yes" xml:space="preserve">
          <source>Ambiguous Local Times (DST)</source>
          <target state="translated">모호한 현지 시간 (DST)</target>
        </trans-unit>
        <trans-unit id="60b78dd3bc38b79497387b8798a6af56908b3286" translate="yes" xml:space="preserve">
          <source>Ambiguous call resolved as CORE::%s(), qualify as such or use &amp;amp;</source>
          <target state="translated">CORE :: % s ()로 확인 된 모호한 호출, 그 자체로 한정하거나 &amp;amp; 사용</target>
        </trans-unit>
        <trans-unit id="81d6325a5322b24a8cad3df61889fcccc37da082" translate="yes" xml:space="preserve">
          <source>Ambiguous range in transliteration operator</source>
          <target state="translated">음역 연산자의 모호한 범위</target>
        </trans-unit>
        <trans-unit id="edda76ce0ef49493fbd99f6a03d679fce823d7ca" translate="yes" xml:space="preserve">
          <source>Ambiguous use of %c resolved as operator %c</source>
          <target state="translated">% c의 모호한 사용이 % c 연산자로 해결되었습니다.</target>
        </trans-unit>
        <trans-unit id="97f919429ce49eab88ebaca27d4b763e67507277" translate="yes" xml:space="preserve">
          <source>Ambiguous use of %c{%s[...]} resolved to %c%s[...]</source>
          <target state="translated">% c {% s [...]}의 모호한 사용이 % c % s [...] (으)로 해결되었습니다.</target>
        </trans-unit>
        <trans-unit id="3c963134cf7d24b861988abb82e92519a22caf5a" translate="yes" xml:space="preserve">
          <source>Ambiguous use of %c{%s{...}} resolved to %c%s{...}</source>
          <target state="translated">% c {% s {...}}의 모호한 사용이 % c % s {...} (으)로 해결되었습니다.</target>
        </trans-unit>
        <trans-unit id="57d7860a6ad7ad4f88f893704243eeb8b4377d90" translate="yes" xml:space="preserve">
          <source>Ambiguous use of %c{%s} resolved to %c%s</source>
          <target state="translated">% c {% s}의 모호한 사용이 % c % s (으)로 해결되었습니다.</target>
        </trans-unit>
        <trans-unit id="d67f229db4a4d1b5f2225b9846f84a14f01ccc8d" translate="yes" xml:space="preserve">
          <source>Ambiguous use of %s resolved as %s</source>
          <target state="translated">% s의 모호한 사용이 % s (으)로 해결되었습니다.</target>
        </trans-unit>
        <trans-unit id="59caacddbf40a7be1f1b173255e30458a45962f9" translate="yes" xml:space="preserve">
          <source>Ambiguous use of -%s resolved as -&amp;amp;%s()</source>
          <target state="translated">-% s의 모호한 사용이-&amp;amp; % s ()로 해결되었습니다.</target>
        </trans-unit>
        <trans-unit id="b61e588022eb4910c7d278a411480210f9347590" translate="yes" xml:space="preserve">
          <source>Ambulation.pm</source>
          <target state="translated">Ambulation.pm</target>
        </trans-unit>
        <trans-unit id="7dec8f79f324daec9e2bc3cec19154d9b44d20cf" translate="yes" xml:space="preserve">
          <source>Amiga Developers Environment</source>
          <target state="translated">아미가 개발자 환경</target>
        </trans-unit>
        <trans-unit id="e2b08dd8d56c6933a46584a5b28aac8a3ed2befa" translate="yes" xml:space="preserve">
          <source>Amiga Specific Modules</source>
          <target state="translated">Amiga 특정 모듈</target>
        </trans-unit>
        <trans-unit id="7eb77f842d900a2dedf7fde5ab4f77cd221a01f3" translate="yes" xml:space="preserve">
          <source>Amiga,</source>
          <target state="translated">Amiga,</target>
        </trans-unit>
        <trans-unit id="e6b810bb50ff4aa9149ad36bef5c0f4e23da0b22" translate="yes" xml:space="preserve">
          <source>Amiga::ARexx</source>
          <target state="translated">Amiga::ARexx</target>
        </trans-unit>
        <trans-unit id="01a8977a9be8d612968643e3bf495cf6b7267806" translate="yes" xml:space="preserve">
          <source>Amiga::ARexx - Perl extension for ARexx support</source>
          <target state="translated">Amiga :: ARexx-ARexx 지원을위한 Perl 확장</target>
        </trans-unit>
        <trans-unit id="8adf028f8c6d2a6a1f2e1490947a8c498843d956" translate="yes" xml:space="preserve">
          <source>Amiga::ARexx METHODS</source>
          <target state="translated">Amiga :: ARexx 방법</target>
        </trans-unit>
        <trans-unit id="b06d09541ec208da13b7be9ff5bbfee7e66e27b2" translate="yes" xml:space="preserve">
          <source>Amiga::ARexx::Msg METHODS</source>
          <target state="translated">Amiga :: ARexx :: Msg 방법</target>
        </trans-unit>
        <trans-unit id="4c7974d6ce506c1fbe8763064a655033977f865b" translate="yes" xml:space="preserve">
          <source>Amiga::Exec</source>
          <target state="translated">Amiga::Exec</target>
        </trans-unit>
        <trans-unit id="d165b945227b32b2aec4eb213a7b6887056e595f" translate="yes" xml:space="preserve">
          <source>Amiga::Exec - Perl extension for low level amiga support</source>
          <target state="translated">Amiga :: Exec-낮은 수준의 amiga 지원을위한 Perl 확장</target>
        </trans-unit>
        <trans-unit id="6763cfad1bb35aed134ab02bf5d64d5a57ca8187" translate="yes" xml:space="preserve">
          <source>Amnesty will prevent a failed assertion from causing the overall test to fail. In other words it marks a failure as expected and allowed.</source>
          <target state="translated">앰네스티는 실패한 주장으로 인해 전체 테스트가 실패하는 것을 방지합니다. 즉, 예상 및 허용 된 실패를 표시합니다.</target>
        </trans-unit>
        <trans-unit id="3c76575f93cf9b6439e5c8c228d14871841f2be6" translate="yes" xml:space="preserve">
          <source>Among IBM EBCDIC character code sets there are 13 characters that are often mapped to different integer values. Those characters are known as the 13 &quot;variant&quot; characters and are:</source>
          <target state="translated">IBM EBCDIC 문자 코드 세트 중에는 종종 다른 정수 값에 맵핑되는 13 개의 문자가 있습니다. 이러한 문자는 13 개의 &quot;변형&quot;문자로 알려져 있으며 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="dc547e0c079def6202bb164de4204e6fef69df9c" translate="yes" xml:space="preserve">
          <source>Amongst the changes made for OS/2 are...</source>
          <target state="translated">OS / 2에서 변경된 사항은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="99690d58d4abd10cd0938a7adcb56ded08ef66ad" translate="yes" xml:space="preserve">
          <source>An</source>
          <target state="translated">An</target>
        </trans-unit>
        <trans-unit id="a57b3b45aeac822e093194b4bfd981f0e59fb655" translate="yes" xml:space="preserve">
          <source>An &quot;=over&quot; ... &quot;=back&quot; region containing no &quot;=item&quot; paragraphs at all, and containing only some number of ordinary/verbatim paragraphs, and possibly also some nested &quot;=over&quot; ... &quot;=back&quot; regions, &quot;=for...&quot; paragraphs, and &quot;=begin&quot;...&quot;=end&quot; regions. Such an itemless &quot;=over&quot; ... &quot;=back&quot; region in Pod is equivalent in meaning to a &quot;&amp;lt;blockquote&amp;gt;...&amp;lt;/blockquote&amp;gt;&quot; element in HTML.</source>
          <target state="translated">&quot;= 항목&quot;단락을 전혀 포함하지 않고 몇 개의 일반 / 언어 단락과 일부 중첩 된 &quot;= over&quot;... &quot;= back&quot;을 포함하는 &quot;= over&quot;... &quot;= back&quot;영역 region, &quot;= for ...&quot;단락 및 &quot;= begin&quot;... &quot;= end&quot;영역 포드에서 이러한 항목이없는 &quot;= over&quot;... &quot;= back&quot;영역은 HTML의 &quot;&amp;lt;blockquote&amp;gt; ... &amp;lt;/ blockquote&amp;gt;&quot;요소와 의미가 같습니다.</target>
        </trans-unit>
        <trans-unit id="a1fa998f4d85fe0a03c929b0df6c0b9a9c55bdd0" translate="yes" xml:space="preserve">
          <source>An &quot;=over&quot; ... &quot;=back&quot; region containing only &quot;=item *&quot; commands, each followed by some number of ordinary/verbatim paragraphs, other nested &quot;=over&quot; ... &quot;=back&quot; regions, &quot;=for...&quot; paragraphs, and &quot;=begin&quot;...&quot;=end&quot; regions.</source>
          <target state="translated">&quot;= item *&quot;명령 만 포함하는 &quot;= over&quot;... &quot;= back&quot;영역으로, 각각 몇 개의 일반 / 언어 단락이 이어지고 다른 중첩 된 &quot;= over&quot;... &quot;= back&quot;영역, &quot;= for ... &quot;단락 ​​및&quot;= 시작 &quot;...&quot;= 종료 &quot;영역</target>
        </trans-unit>
        <trans-unit id="f7c11a0a43a54d0c5011769a3613a3b8e32e4b7f" translate="yes" xml:space="preserve">
          <source>An &quot;=over&quot; ... &quot;=back&quot; region containing only &quot;=item [text]&quot; commands, each one (or each group of them) followed by some number of ordinary/verbatim paragraphs, other nested &quot;=over&quot; ... &quot;=back&quot; regions, or &quot;=for...&quot; paragraphs, and &quot;=begin&quot;...&quot;=end&quot; regions.</source>
          <target state="translated">&quot;= overm ...&quot;= back &quot;영역에는&quot;= item [text] &quot;명령 만 포함되며, 각 명령 (또는 각 그룹) 뒤에 몇 개의 일반 / verbatim 단락이 있고 다른 중첩 된&quot;= over &quot;가 있습니다. .. &quot;= back&quot;영역 또는 &quot;= for ...&quot;단락 및 &quot;= begin&quot;... &quot;= end&quot;영역</target>
        </trans-unit>
        <trans-unit id="bf06369b3eb3e5c957377be368c2f7244136f0a8" translate="yes" xml:space="preserve">
          <source>An &quot;=over&quot; ... &quot;=back&quot; region containing only &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m/\A=item\s+\d+\.?\s*\z/&lt;/a&gt;&lt;/code&gt; paragraphs, each one (or each group of them) followed by some number of ordinary/verbatim paragraphs, other nested &quot;=over&quot; ... &quot;=back&quot; regions, &quot;=for...&quot; paragraphs, and/or &quot;=begin&quot;...&quot;=end&quot; codes. Note that the numbers must start at 1 in each section, and must proceed in order and without skipping numbers.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m/\A=item\s+\d+\.?\s*\z/&lt;/a&gt;&lt;/code&gt; 단락 만 포함 된 &quot;= over&quot;... &quot;= back&quot;영역 일반 / 언어 단락, 기타 중첩 된 &quot;= over&quot;... &quot;= back&quot;영역, &quot;= for ...&quot;단락 및 / 또는 &quot;= begin&quot;... &quot;= end&quot;코드 번호는 각 섹션에서 1부터 시작해야하며 번호를 건너 뛰지 않고 순서대로 진행해야합니다.</target>
        </trans-unit>
        <trans-unit id="927c2fc26d9fdc3522cb89e03e51cb9a3f52db71" translate="yes" xml:space="preserve">
          <source>An &quot;=over&quot; ... &quot;=back&quot; region containing only &lt;code&gt;m/\A=item\s+\d+\.?\s*\z/&lt;/code&gt; paragraphs, each one (or each group of them) followed by some number of ordinary/verbatim paragraphs, other nested &quot;=over&quot; ... &quot;=back&quot; regions, &quot;=for...&quot; paragraphs, and/or &quot;=begin&quot;...&quot;=end&quot; codes. Note that the numbers must start at 1 in each section, and must proceed in order and without skipping numbers.</source>
          <target state="translated">&lt;code&gt;m/\A=item\s+\d+\.?\s*\z/&lt;/code&gt; 단락 만 포함 된 &quot;= over&quot;... &quot;= back&quot;영역 , 각 단락 (또는 각 그룹) 뒤에 몇 개의 일반 / verbatim 단락, 기타 중첩 된 &quot;= over&quot;... &quot;= back&quot;영역, &quot;= for ...&quot;단락 및 / 또는 &quot;= begin&quot;... &quot;= end&quot;코드. 번호는 각 섹션에서 1부터 시작해야하며 번호를 건너 뛰지 않고 순서대로 진행해야합니다.</target>
        </trans-unit>
        <trans-unit id="9c821406e2ce644bf837234397ad75d8f26b35cf" translate="yes" xml:space="preserve">
          <source>An &quot;independent&quot; subexpression, one which matches the substring that a</source>
          <target state="translated">&quot;독립적 인&quot;하위 식, 하위 문자열과 일치하는 하위 식</target>
        </trans-unit>
        <trans-unit id="16be1ac4526418524ec7dfd0204b1847a01b249e" translate="yes" xml:space="preserve">
          <source>An &quot;independent&quot; subexpression, one which matches the substring that a standalone</source>
          <target state="translated">&quot;독립적 인&quot;하위 표현식, 독립형 하위 문자열과 일치하는 하위 표현식</target>
        </trans-unit>
        <trans-unit id="3a02e2541679357b758fec91e5c00ccb84d49cd8" translate="yes" xml:space="preserve">
          <source>An &quot;internal&quot; derivative of &quot;perlio&quot; which can be used to provide Unread() function for layers which have no buffer or cannot be bothered. (Basically this layer's &lt;code&gt;Fill()&lt;/code&gt; pops itself off the stack and so resumes reading from layer below.)</source>
          <target state="translated">버퍼가 없거나 귀찮게 할 수없는 레이어에 Unread () 함수를 제공하는 데 사용할 수있는 &quot;perlio&quot;의 &quot;내부&quot;파생물입니다. (기본적으로이 레이어의 &lt;code&gt;Fill()&lt;/code&gt; 은 스택에서 스스로 터져서 아래 레이어에서 다시 읽습니다.)</target>
        </trans-unit>
        <trans-unit id="94f93318c67b8e306fa7a939182b6dc1a8d99788" translate="yes" xml:space="preserve">
          <source>An &quot;internal&quot; method, subject to change, currently called to allow an overriding class to cache information that will then be passed into all the &lt;code&gt;*param*&lt;/code&gt; calls. (Yes, having to read the source to make sense of this is considered a known bug).</source>
          <target state="translated">변경 될 &quot;내부&quot;메소드는 현재 대체 클래스가 정보를 캐시하여 모든 &lt;code&gt;*param*&lt;/code&gt; 호출에 전달할 수 있도록 현재 호출됩니다 . (예,이를 이해하기 위해 소스를 읽어야하는 것은 알려진 버그로 간주됩니다).</target>
        </trans-unit>
        <trans-unit id="c723dc089a4e0462d0565d4c223eb6a79ebcd3aa" translate="yes" xml:space="preserve">
          <source>An $eol of &quot;&quot; (the empty string) is special. In this case, no &quot;soft line breaks&quot; are introduced and binary mode is effectively enabled so that any &quot;\n&quot; in the original data is encoded as well.</source>
          <target state="translated">&quot;&quot;(빈 문자열)의 $ eol은 특별합니다. 이 경우 &quot;소프트 라인 나누기&quot;가 도입되지 않고 이진 모드가 효과적으로 활성화되어 원본 데이터의 &quot;\ n&quot;도 인코딩됩니다.</target>
        </trans-unit>
        <trans-unit id="5a6a13a346ab7340f151e0f470997f73ed378c5a" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;#eof-FILEHANDLE&quot;&gt;&lt;code&gt;eof&lt;/code&gt;&lt;/a&gt; without an argument uses the last file read. Using &lt;a href=&quot;#eof-FILEHANDLE&quot;&gt;&lt;code&gt;eof()&lt;/code&gt;&lt;/a&gt; with empty parentheses is different. It refers to the pseudo file formed from the files listed on the command line and accessed via the &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; operator. Since &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; isn't explicitly opened, as a normal filehandle is, an &lt;a href=&quot;#eof-FILEHANDLE&quot;&gt;&lt;code&gt;eof()&lt;/code&gt;&lt;/a&gt; before &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; has been used will cause &lt;a href=&quot;perlvar#%40ARGV&quot;&gt;&lt;code&gt;@ARGV&lt;/code&gt;&lt;/a&gt; to be examined to determine if input is available. Similarly, an &lt;a href=&quot;#eof-FILEHANDLE&quot;&gt;&lt;code&gt;eof()&lt;/code&gt;&lt;/a&gt; after &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; has returned end-of-file will assume you are processing another &lt;a href=&quot;perlvar#%40ARGV&quot;&gt;&lt;code&gt;@ARGV&lt;/code&gt;&lt;/a&gt; list, and if you haven't set &lt;a href=&quot;perlvar#%40ARGV&quot;&gt;&lt;code&gt;@ARGV&lt;/code&gt;&lt;/a&gt;, will read input from &lt;code&gt;STDIN&lt;/code&gt;; see &lt;a href=&quot;perlop#I%2FO-Operators&quot;&gt;&quot;I/O Operators&quot; in perlop&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#eof-FILEHANDLE&quot;&gt; &lt;code&gt;eof&lt;/code&gt; &lt;/a&gt; 인수없이 마지막 파일 읽기를 사용합니다. 빈 괄호와 함께 &lt;a href=&quot;#eof-FILEHANDLE&quot;&gt; &lt;code&gt;eof()&lt;/code&gt; &lt;/a&gt; 를 사용하는 것은 다릅니다. 명령 줄에 나열된 파일에서 형성되고 &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; 연산자 를 통해 액세스되는 의사 파일을 나타냅니다 . &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; 는 명시 적으로 열리지 않기 때문에 일반 파일 핸들처럼 &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; 이전 의 &lt;a href=&quot;#eof-FILEHANDLE&quot;&gt; &lt;code&gt;eof()&lt;/code&gt; &lt;/a&gt; 는 입력이 사용 가능한지 확인하기 위해 &lt;a href=&quot;perlvar#%40ARGV&quot;&gt; &lt;code&gt;@ARGV&lt;/code&gt; &lt;/a&gt; 를 검사하게합니다. 마찬가지로, &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; 가 파일 끝을 반환 한 후 &lt;a href=&quot;#eof-FILEHANDLE&quot;&gt; &lt;code&gt;eof()&lt;/code&gt; &lt;/a&gt; 는 다른 &lt;a href=&quot;perlvar#%40ARGV&quot;&gt; &lt;code&gt;@ARGV&lt;/code&gt; &lt;/a&gt; 목록을 처리하고 있다고 가정 하고 &lt;a href=&quot;perlvar#%40ARGV&quot;&gt; &lt;code&gt;@ARGV&lt;/code&gt; 를&lt;/a&gt; 설정하지 않은 경우 &lt;code&gt;STDIN&lt;/code&gt; 에서 입력을 읽습니다.; &lt;a href=&quot;perlop#I%2FO-Operators&quot;&gt;perlop의 &quot;I / O 연산자&quot;를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="1711b8c03a9928dbbe638d8c791d95aa2c85763c" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;#our-VARLIST&quot;&gt;&lt;code&gt;our&lt;/code&gt;&lt;/a&gt; declaration declares an alias for a package variable that will be visible across its entire lexical scope, even across package boundaries. The package in which the variable is entered is determined at the point of the declaration, not at the point of use. This means the following behavior holds:</source>
          <target state="translated">&lt;a href=&quot;#our-VARLIST&quot;&gt; &lt;code&gt;our&lt;/code&gt; &lt;/a&gt; 선언은 심지어 패키지 경계를 넘어, 전체 어휘 범위에서 볼 수 있습니다 패키지 변수에 대한 별칭을 선언합니다. 변수가 입력 된 패키지는 사용 시점이 아니라 선언 시점에서 결정됩니다. 이는 다음 동작이 유지됨을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="b91de5a24da27e5fce41ca7887051c5441493c51" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;#our-VARLIST&quot;&gt;&lt;code&gt;our&lt;/code&gt;&lt;/a&gt; declaration may also have a list of attributes associated with it.</source>
          <target state="translated">&lt;a href=&quot;#our-VARLIST&quot;&gt; &lt;code&gt;our&lt;/code&gt; &lt;/a&gt; 선언은 그와 관련된 속성의 목록을 가질 수있다.</target>
        </trans-unit>
        <trans-unit id="7efa71e97154f5e1c53935b4d4b0410d3433b623" translate="yes" xml:space="preserve">
          <source>An &lt;b&gt;XSUB&lt;/b&gt; forms the basic unit of the XS interface. After compilation by the &lt;b&gt;xsubpp&lt;/b&gt; compiler, each XSUB amounts to a C function definition which will provide the glue between Perl calling conventions and C calling conventions.</source>
          <target state="translated">&lt;b&gt;XSUB는&lt;/b&gt; XS를 인터페이스의 기본 단위를 형성한다. &lt;b&gt;xsubpp&lt;/b&gt; 컴파일러에 의해 컴파일 된 후 , 각 XSUB는 Perl 호출 규칙과 C 호출 규칙 사이의 결합을 제공하는 C 함수 정의에 해당합니다.</target>
        </trans-unit>
        <trans-unit id="09718e49ee8b20061f562ba9e5c34673e940b8ad" translate="yes" xml:space="preserve">
          <source>An &lt;b&gt;anonymous&lt;/b&gt; subroutine that, when a reference to it is generated at runtime, keeps track of the identities of externally visible &lt;b&gt;lexical variables&lt;/b&gt;, even after those lexical variables have supposedly gone out of &lt;b&gt;scope&lt;/b&gt;. They&amp;rsquo;re called &amp;ldquo;closures&amp;rdquo; because this sort of behavior gives mathematicians a sense of closure.</source>
          <target state="translated">&lt;b&gt;익명&lt;/b&gt; 에 대한 참조는 실행시에 생성되는 경우, 외부에서 볼의 신원을 추적 유지 루틴 &lt;b&gt;어휘 변수&lt;/b&gt; 그 어휘 변수 아마 외가 후에도 &lt;b&gt;범위&lt;/b&gt; . 이런 종류의 행동은 수학자에게 폐쇄 감을 부여하기 때문에&amp;ldquo;폐쇄&amp;rdquo;라고 불립니다.</target>
        </trans-unit>
        <trans-unit id="9e2f49be17e25fca915fffd9825b7a69527fa78a" translate="yes" xml:space="preserve">
          <source>An &lt;b&gt;argument&lt;/b&gt;-passing mechanism in which the &lt;b&gt;formal arguments&lt;/b&gt; refer directly to the &lt;b&gt;actual arguments&lt;/b&gt;, and the &lt;b&gt;subroutine&lt;/b&gt; can change the actual arguments by changing the formal arguments. That is, the formal argument is an &lt;b&gt;alias&lt;/b&gt; for the actual argument. See also &lt;b&gt;call by value&lt;/b&gt;.</source>
          <target state="translated">&lt;b&gt;형식 인수&lt;/b&gt; 가 &lt;b&gt;실제 인수를&lt;/b&gt; 직접 참조 하고 &lt;b&gt;서브 루틴&lt;/b&gt; 이 형식 인수를 변경하여 실제 인수를 변경할 수 있는 &lt;b&gt;인수&lt;/b&gt; 전달 메커니즘 . 즉, 형식 인수는 실제 인수 의 &lt;b&gt;별명&lt;/b&gt; 입니다. &lt;b&gt;value by call&lt;/b&gt; 도 참조하십시오 .&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="4e9ca74e5eb3ceca0031d5a290a9926f188e9f44" translate="yes" xml:space="preserve">
          <source>An &lt;b&gt;argument&lt;/b&gt;-passing mechanism in which the &lt;b&gt;formal arguments&lt;/b&gt; refer to a copy of the &lt;b&gt;actual arguments&lt;/b&gt;, and the &lt;b&gt;subroutine&lt;/b&gt; cannot change the actual arguments by changing the formal arguments. See also &lt;b&gt;call by reference&lt;/b&gt;.</source>
          <target state="translated">안 &lt;b&gt;인수&lt;/b&gt; -passing기구되는 &lt;b&gt;정규 인수&lt;/b&gt; 의 복사본을 참조 &lt;b&gt;실제 인수&lt;/b&gt; 및 &lt;b&gt;서브 루틴은&lt;/b&gt; 정규 인수를 변경함으로써 실제 인수를 변경할 수 없다. 참조로 &lt;b&gt;전화&lt;/b&gt; 하기도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="3ae7537da81b89a37f1fba19db52f45ea5a64265" translate="yes" xml:space="preserve">
          <source>An &lt;b&gt;assertion&lt;/b&gt; that peeks at the string to the left of the current match location.</source>
          <target state="translated">&lt;b&gt;주장&lt;/b&gt; 받는 문자열에서 엿봄 현재 경기 위치의 왼쪽있다.</target>
        </trans-unit>
        <trans-unit id="9186a718ac3c2fd4c0066859c2036b1188f86bf7" translate="yes" xml:space="preserve">
          <source>An &lt;b&gt;assertion&lt;/b&gt; that peeks at the string to the right of the current match location.</source>
          <target state="translated">&lt;b&gt;주장은&lt;/b&gt; 현재의 경기 위치의 오른쪽에있는 문자열에서 그 피킹합니다.</target>
        </trans-unit>
        <trans-unit id="fccd6c0eca3ee2fd48a0479b2f7467ef677a981b" translate="yes" xml:space="preserve">
          <source>An &lt;b&gt;assertion&lt;/b&gt; that states something exists and perhaps describes what it&amp;rsquo;s like, without giving any commitment as to how or where you&amp;rsquo;ll use it. A declaration is like the part of your recipe that says, &amp;ldquo;two cups flour, one large egg, four or five tadpoles&amp;hellip;&amp;rdquo; See &lt;b&gt;statement&lt;/b&gt; for its opposite. Note that some declarations also function as statements. Subroutine declarations also act as definitions if a body is supplied.</source>
          <target state="translated">&lt;b&gt;주장&lt;/b&gt; 뭔가를 말한다 존재 아마도 그것은에 어디에서 어떻게 당신이 그것을 사용할 것이다 어떠한 노력을 포기하지 않고, 어떤 건지 설명합니다. 선언은 말한다 조리법의 일부 &quot;두 잔 가루, 하나의 큰 계란, 네다섯 올챙이 ...&quot;를 참조 같다 &lt;b&gt;문&lt;/b&gt; 은 반대합니다. 일부 선언은 명령문으로도 작동합니다. 본문이 제공되는 경우 서브 루틴 선언도 정의의 역할을합니다.</target>
        </trans-unit>
        <trans-unit id="a79df62ffe9655f3bb9b573a11129a38c97d9727" translate="yes" xml:space="preserve">
          <source>An &lt;b&gt;attribute&lt;/b&gt; of an &lt;b&gt;object&lt;/b&gt;; data stored with the particular object rather than with the class as a whole.</source>
          <target state="translated">&lt;b&gt;속성&lt;/b&gt; 의 &lt;b&gt;물체&lt;/b&gt; ; 클래스 전체가 아닌 특정 객체와 함께 저장된 데이터</target>
        </trans-unit>
        <trans-unit id="6b5c38c6212536b2650f8fd4b5e6e9c46fa7ac78" translate="yes" xml:space="preserve">
          <source>An &lt;b&gt;expression&lt;/b&gt; that evaluates to something that can be used as a &lt;b&gt;filehandle&lt;/b&gt;: a &lt;b&gt;string&lt;/b&gt; (filehandle name), a &lt;b&gt;typeglob&lt;/b&gt;, a typeglob &lt;b&gt;reference&lt;/b&gt;, or a low-level &lt;b&gt;IO&lt;/b&gt; object.</source>
          <target state="translated">&lt;b&gt;파일 핸들&lt;/b&gt; 로 사용할 수있는 것으로 평가 되는 &lt;b&gt;표현식&lt;/b&gt; : &lt;b&gt;문자열&lt;/b&gt; (filehandle 이름), &lt;b&gt;typeglob&lt;/b&gt;&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt; , typeglob &lt;b&gt;참조&lt;/b&gt; 또는 저수준 &lt;b&gt;IO&lt;/b&gt; 객체.</target>
        </trans-unit>
        <trans-unit id="a9ea33da0846dba2dfc2c719e640a6b936943a76" translate="yes" xml:space="preserve">
          <source>An &lt;b&gt;expression&lt;/b&gt; that yields a &lt;b&gt;value&lt;/b&gt; that an &lt;b&gt;operator&lt;/b&gt; operates on. See also &lt;b&gt;precedence&lt;/b&gt;.</source>
          <target state="translated">&lt;b&gt;식&lt;/b&gt; 산출 &lt;b&gt;값&lt;/b&gt; 그&lt;b&gt; 오퍼레이터&lt;/b&gt; 에 동작한다. &lt;b&gt;우선 순위&lt;/b&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="cc6a827ebadd37467385c749c36afe5cfe5a720e" translate="yes" xml:space="preserve">
          <source>An &lt;b&gt;increment&lt;/b&gt; operator that knows how to bump up ASCII alphabetics as well as numbers.</source>
          <target state="translated">ASCII 알파벳 및 숫자를 부딪 치는 방법을 알고 있는 &lt;b&gt;증분&lt;/b&gt; 연산자입니다.</target>
        </trans-unit>
        <trans-unit id="6e6a46de7223236ab22a0ae8657b922fe424257e" translate="yes" xml:space="preserve">
          <source>An &lt;b&gt;instance&lt;/b&gt; of a &lt;b&gt;class&lt;/b&gt;. Something that &amp;ldquo;knows&amp;rdquo; what user-defined type (class) it is, and what it can do because of what class it is. Your program can request an object to do things, but the object gets to decide whether it wants to do them or not. Some objects are more accommodating than others.</source>
          <target state="translated">&lt;b&gt;예&lt;/b&gt; 의 &lt;b&gt;클래스&lt;/b&gt; . 어떤 사용자 정의 형식 (클래스)인지, 어떤 클래스인지에 따라 무엇을 할 수 있는지 &quot;알고있는 것&quot;. 프로그램은 객체에게 작업을 수행하도록 요청할 수 있지만 객체는 객체를 수행할지 여부를 결정합니다. 어떤 물체는 다른 물체보다 더 수용 적입니다.</target>
        </trans-unit>
        <trans-unit id="193974eee4df69740e47a6c9868c573734e793d8" translate="yes" xml:space="preserve">
          <source>An &lt;b&gt;object&lt;/b&gt; is a data structure that bundles together data and subroutines which operate on that data. An object's data is called &lt;b&gt;attributes&lt;/b&gt;, and its subroutines are called &lt;b&gt;methods&lt;/b&gt;. An object can be thought of as a noun (a person, a web service, a computer).</source>
          <target state="translated">&lt;b&gt;목적은&lt;/b&gt; 함께 그 데이터를 조작 데이터 및 서브 루틴 번들 데이터 구조이다. 객체의 데이터를 &lt;b&gt;속성&lt;/b&gt; 이라고 하고 서브 루틴을 호출합니다&lt;b&gt; 메소드 합니다&lt;/b&gt; . 객체는 명사 (사람, 웹 서비스, 컴퓨터)로 생각할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9f3264403f458576129fd753f7da0132d1126157" translate="yes" xml:space="preserve">
          <source>An &lt;b&gt;operator&lt;/b&gt; X&lt;code&gt;that looks something like a &lt;b&gt;literal&lt;/b&gt;,
such as the output-grabbing operator, &amp;lt;literal
moreinfo=&quot;none&quot;&lt;/code&gt;`&amp;gt;</source>
          <target state="translated">&lt;b&gt;운영자&lt;/b&gt; X &lt;code&gt;that looks something like a &lt;b&gt;literal&lt;/b&gt;, such as the output-grabbing operator, &amp;lt;literal moreinfo=&quot;none&quot;&lt;/code&gt; `&amp;gt;</target>
        </trans-unit>
        <trans-unit id="e3876b6031a7c1f940174f56c5f7362a7f615429" translate="yes" xml:space="preserve">
          <source>An &lt;b&gt;operator&lt;/b&gt; taking three &lt;b&gt;operands&lt;/b&gt;. Sometimes pronounced &lt;b&gt;trinary&lt;/b&gt;.</source>
          <target state="translated">&lt;b&gt;연산자&lt;/b&gt; 세 복용 &lt;b&gt;피연산자&lt;/b&gt; . 때때로 발음되는 &lt;b&gt;삼원&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="209f1fbbc9e85cade5ad6da705d3c26984c35559" translate="yes" xml:space="preserve">
          <source>An &lt;b&gt;operator&lt;/b&gt; that comes in between its &lt;b&gt;operands&lt;/b&gt;, such as multiplication in &lt;code&gt;24 * 7&lt;/code&gt; .</source>
          <target state="translated">&lt;b&gt;오퍼레이터&lt;/b&gt; 의 사이에 오는 &lt;b&gt;오퍼랜드&lt;/b&gt; 등의 곱셈으로서, &lt;code&gt;24 * 7&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e7f71291b7c0cc8bd6ef4195e1d392449e6f1d53" translate="yes" xml:space="preserve">
          <source>An &lt;b&gt;operator&lt;/b&gt; that comes in between its &lt;b&gt;operands&lt;/b&gt;, such as multiplication in &lt;code&gt;24 * 7&lt;/code&gt;.</source>
          <target state="translated">&lt;b&gt;오퍼레이터&lt;/b&gt; 의 사이에 오는 &lt;b&gt;오퍼랜드&lt;/b&gt; 등의 곱셈으로서, &lt;code&gt;24 * 7&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="463ba99d535672eaf8355ca19021da8d2cf33452" translate="yes" xml:space="preserve">
          <source>An &lt;b&gt;operator&lt;/b&gt; that does something with a list of values, such as &lt;code&gt;&lt;a href=&quot;functions/join&quot;&gt;join&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/grep&quot;&gt;grep&lt;/a&gt;&lt;/code&gt;. Usually used for named built-in operators (such as &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/unlink&quot;&gt;unlink&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt;) that do not require parentheses around their &lt;b&gt;argument&lt;/b&gt; list.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/join&quot;&gt;join&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;functions/grep&quot;&gt;grep&lt;/a&gt;&lt;/code&gt; 와 같은 값 목록으로 무언가를 수행 하는 &lt;b&gt;연산자&lt;/b&gt; 입니다 . 일반적으로 &lt;b&gt;인수&lt;/b&gt; 목록 주위에 괄호가 필요하지 않은 명명 된 내장 연산자 (예 : &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/unlink&quot;&gt;unlink&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; )에 사용 됩니다.&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="74d9d7e2bcff5578ed582b2be81c1fd95c4fc9ac" translate="yes" xml:space="preserve">
          <source>An &lt;b&gt;operator&lt;/b&gt; that does something with a list of values, such as &lt;code&gt;join&lt;/code&gt; or &lt;code&gt;grep&lt;/code&gt;. Usually used for named built-in operators (such as &lt;code&gt;print&lt;/code&gt;, &lt;code&gt;unlink&lt;/code&gt;, and &lt;code&gt;system&lt;/code&gt;) that do not require parentheses around their &lt;b&gt;argument&lt;/b&gt; list.</source>
          <target state="translated">&lt;code&gt;join&lt;/code&gt; 또는 &lt;code&gt;grep&lt;/code&gt; 과 같은 값 목록으로 작업을 수행 하는 &lt;b&gt;연산자&lt;/b&gt; 입니다 . 일반적으로 &lt;b&gt;인수&lt;/b&gt; 목록을 괄호로 묶지 않는 명명 된 내장 연산자 (예 : &lt;code&gt;print&lt;/code&gt; , &lt;code&gt;unlink&lt;/code&gt; 및 &lt;code&gt;system&lt;/code&gt; )에 사용 됩니다.&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="de2a4670adc782be015d0bb2ea5ffee02ea42397" translate="yes" xml:space="preserve">
          <source>An &lt;b&gt;operator&lt;/b&gt; that follows its &lt;b&gt;operand&lt;/b&gt;, as in &lt;code&gt;$x++&lt;/code&gt; .</source>
          <target state="translated">&lt;b&gt;운영자&lt;/b&gt; 는 다음과 &lt;b&gt;피연산자를&lt;/b&gt; 같이 &lt;code&gt;$x++&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f2a91b007dceec65feca65e72cf86b169ecd0ff6" translate="yes" xml:space="preserve">
          <source>An &lt;b&gt;operator&lt;/b&gt; that follows its &lt;b&gt;operand&lt;/b&gt;, as in &lt;code&gt;$x++&lt;/code&gt;.</source>
          <target state="translated">&lt;b&gt;운영자&lt;/b&gt; 는 다음과 &lt;b&gt;피연산자를&lt;/b&gt; 같이 &lt;code&gt;$x++&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2f7f1151c5c90e6fb1284f5e0bc779ad8ed2e33c" translate="yes" xml:space="preserve">
          <source>An &lt;b&gt;operator&lt;/b&gt; that precedes its &lt;b&gt;operand&lt;/b&gt;, as in &lt;code&gt;++$x&lt;/code&gt; .</source>
          <target state="translated">&lt;b&gt;운영자&lt;/b&gt; 의 앞에 &lt;b&gt;피연산자를&lt;/b&gt; 같이 &lt;code&gt;++$x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a25f284ffc65045a6c69870223421c5797a335e9" translate="yes" xml:space="preserve">
          <source>An &lt;b&gt;operator&lt;/b&gt; that precedes its &lt;b&gt;operand&lt;/b&gt;, as in &lt;code&gt;++$x&lt;/code&gt;.</source>
          <target state="translated">&lt;b&gt;운영자&lt;/b&gt; 의 앞에 &lt;b&gt;피연산자를&lt;/b&gt; 같이 &lt;code&gt;++$x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dabe188f0a1b9c27289c477dd8047df3b523cb5a" translate="yes" xml:space="preserve">
          <source>An &lt;b&gt;operator&lt;/b&gt; that says whether a particular ordering relationship is &lt;b&gt;true&lt;/b&gt; about a pair of &lt;b&gt;operands&lt;/b&gt;. Perl has both numeric and string relational operators. See &lt;b&gt;collating sequence&lt;/b&gt;.</source>
          <target state="translated">&lt;b&gt;운영자&lt;/b&gt; 특정 순서 관계가 있는지 여부를 말한다 &lt;b&gt;사실&lt;/b&gt; 의 쌍에 대한 &lt;b&gt;피연산자&lt;/b&gt; . Perl에는 숫자 및 문자열 관계 연산자가 있습니다. &lt;b&gt;조합 순서를&lt;/b&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="717a4af81f7132fc96e1d23c981f1ff3401e5290" translate="yes" xml:space="preserve">
          <source>An &lt;b&gt;operator&lt;/b&gt; that surrounds its &lt;b&gt;operand&lt;/b&gt;, like the angle operator, or parentheses, or a hug.</source>
          <target state="translated">&lt;b&gt;연산자&lt;/b&gt; 그 주변 &lt;b&gt;피연산자&lt;/b&gt; 각도 운영자 또는 괄호 또는 포옹처럼.</target>
        </trans-unit>
        <trans-unit id="355f7096b65520d72731600341dac924b0bb6aad" translate="yes" xml:space="preserve">
          <source>An &lt;b&gt;operator&lt;/b&gt; that takes two &lt;b&gt;operands&lt;/b&gt;.</source>
          <target state="translated">두 &lt;b&gt;피연산자를 사용&lt;/b&gt; 하는 &lt;b&gt;연산자&lt;/b&gt; 입니다 .&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="b7885e2c7085b9ecc7bc4fd21946e64edd22e910" translate="yes" xml:space="preserve">
          <source>An &lt;b&gt;operator&lt;/b&gt; whose assigned mission in life is to change the value of a &lt;b&gt;variable&lt;/b&gt;.</source>
          <target state="translated">&lt;b&gt;연산자&lt;/b&gt; 그 할당 임무 생활에서이 값으로 변경하는 &lt;b&gt;변수&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="7b3959ebca99af56cd591ab2c731b4edab6ffa5f" translate="yes" xml:space="preserve">
          <source>An &lt;b&gt;ordinary paragraph&lt;/b&gt;. A paragraph is an ordinary paragraph if its first line matches neither &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m/\A=[a-zA-Z]/&lt;/a&gt;&lt;/code&gt; nor &lt;code&gt;m/\A[ \t]/&lt;/code&gt; ,</source>
          <target state="translated">안 &lt;b&gt;일반 단락&lt;/b&gt; . 첫 번째 줄이 &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m/\A=[a-zA-Z]/&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;m/\A[ \t]/&lt;/code&gt; 와 일치하지 않으면 단락은 일반 단락입니다 .</target>
        </trans-unit>
        <trans-unit id="8dd7686cbc9fa2ea98c8a7eb1004bca8a6b2e068" translate="yes" xml:space="preserve">
          <source>An &lt;b&gt;ordinary paragraph&lt;/b&gt;. A paragraph is an ordinary paragraph if its first line matches neither &lt;code&gt;m/\A=[a-zA-Z]/&lt;/code&gt; nor &lt;code&gt;m/\A[ \t]/&lt;/code&gt;,</source>
          <target state="translated">&lt;b&gt;일반 단락&lt;/b&gt; . 첫 줄이 &lt;code&gt;m/\A=[a-zA-Z]/&lt;/code&gt; 또는 &lt;code&gt;m/\A[ \t]/&lt;/code&gt; 와 일치하지 않는 경우 단락은 일반 단락입니다 .</target>
        </trans-unit>
        <trans-unit id="d98f8de412a14cfe117cc1f33fdf08a188a327cd" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;&lt;a href=&quot;eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt; without an argument uses the last file read. Using &lt;code&gt;&lt;a href=&quot;eof&quot;&gt;eof()&lt;/a&gt;&lt;/code&gt; with empty parentheses is different. It refers to the pseudo file formed from the files listed on the command line and accessed via the &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; operator. Since &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; isn't explicitly opened, as a normal filehandle is, an &lt;code&gt;&lt;a href=&quot;eof&quot;&gt;eof()&lt;/a&gt;&lt;/code&gt; before &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; has been used will cause &lt;code&gt;@ARGV&lt;/code&gt; to be examined to determine if input is available. Similarly, an &lt;code&gt;&lt;a href=&quot;eof&quot;&gt;eof()&lt;/a&gt;&lt;/code&gt; after &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; has returned end-of-file will assume you are processing another &lt;code&gt;@ARGV&lt;/code&gt; list, and if you haven't set &lt;code&gt;@ARGV&lt;/code&gt; , will read input from &lt;code&gt;STDIN&lt;/code&gt; ; see &lt;a href=&quot;../perlop#I%2fO-Operators&quot;&gt;I/O Operators in perlop&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt; 인수없이 마지막 파일 읽기를 사용합니다. 빈 괄호와 함께 &lt;code&gt;&lt;a href=&quot;eof&quot;&gt;eof()&lt;/a&gt;&lt;/code&gt; 를 사용하는 것은 다릅니다. 명령 행에 나열되고 &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; 연산자 를 통해 액세스되는 파일로 구성된 의사 파일을 나타냅니다 . &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; 는 명시 적으로 열리지 않기 때문에 일반적인 파일 핸들처럼 &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; 이전 의 &lt;code&gt;&lt;a href=&quot;eof&quot;&gt;eof()&lt;/a&gt;&lt;/code&gt; 는 &lt;code&gt;@ARGV&lt;/code&gt; 를 검사하여 입력이 가능한지 확인합니다. 마찬가지로 &lt;code&gt;&lt;a href=&quot;eof&quot;&gt;eof()&lt;/a&gt;&lt;/code&gt; &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; 이 파일 끝을 반환 한 후 는 다른 &lt;code&gt;@ARGV&lt;/code&gt; 목록을 처리 하고 있고 &lt;code&gt;@ARGV&lt;/code&gt; 설정하지 않은 것으로 가정합니다 &lt;code&gt;STDIN&lt;/code&gt; 에서 입력을 읽습니다.; 참조하십시오&lt;a href=&quot;../perlop#I%2fO-Operators&quot;&gt;perlop의 I / O 연산자&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b538c9784366b2a5b380fc1646cd6d2c36676cbb" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt; ''&lt;/code&gt; executed within a subroutine defined in the &lt;code&gt;DB&lt;/code&gt; package doesn't see the usual surrounding lexical scope, but rather the scope of the first non-DB piece of code that called it. You don't normally need to worry about this unless you are writing a Perl debugger.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt; ''&lt;/code&gt; &lt;code&gt;DB&lt;/code&gt; 패키지에 정의 된 서브 루틴 내에서 실행 '' 은 일반적인 주변 어휘 범위가 아니라 그것을 호출 한 최초의 비 DB 조각 코드의 범위를 봅니다. Perl 디버거를 작성하지 않는 한 일반적으로 이것에 대해 걱정할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="9638cc264773db141fdbff9966aa75b61a42b264" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt; without an argument uses the last file read. Using &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof()&lt;/a&gt;&lt;/code&gt; with empty parentheses is different. It refers to the pseudo file formed from the files listed on the command line and accessed via the &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; operator. Since &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; isn't explicitly opened, as a normal filehandle is, an &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof()&lt;/a&gt;&lt;/code&gt; before &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; has been used will cause &lt;code&gt;@ARGV&lt;/code&gt; to be examined to determine if input is available. Similarly, an &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof()&lt;/a&gt;&lt;/code&gt; after &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; has returned end-of-file will assume you are processing another &lt;code&gt;@ARGV&lt;/code&gt; list, and if you haven't set &lt;code&gt;@ARGV&lt;/code&gt; , will read input from &lt;code&gt;STDIN&lt;/code&gt; ; see &lt;a href=&quot;perlop#I%2fO-Operators&quot;&gt;I/O Operators in perlop&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt; 인수없이 마지막 파일 읽기를 사용합니다. 빈 괄호와 함께 &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof()&lt;/a&gt;&lt;/code&gt; 를 사용하는 것은 다릅니다. 명령 행에 나열되고 &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; 연산자 를 통해 액세스되는 파일로 구성된 의사 파일을 나타냅니다 . &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; 는 명시 적으로 열리지 않기 때문에 일반적인 파일 핸들처럼 &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; 이전 의 &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof()&lt;/a&gt;&lt;/code&gt; 는 &lt;code&gt;@ARGV&lt;/code&gt; 를 검사하여 입력이 가능한지 확인합니다. 마찬가지로 &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; 이 파일 끝을 반환 한 후 &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof()&lt;/a&gt;&lt;/code&gt; 는 다른 &lt;code&gt;@ARGV&lt;/code&gt; 목록을 처리한다고 가정 하고 &lt;code&gt;@ARGV&lt;/code&gt; 를 설정하지 않은 경우 입력을 읽습니다 . 보다 &lt;code&gt;STDIN&lt;/code&gt; &lt;a href=&quot;perlop#I%2fO-Operators&quot;&gt;perlop의 I / O 연산자&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f39d8054296556b4b922794a4d5a34f617f1fc94" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval()&lt;/a&gt;&lt;/code&gt;, however, can see lexical variables of the scope it is being evaluated in, so long as the names aren't hidden by declarations within the &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval()&lt;/a&gt;&lt;/code&gt; itself. See &lt;a href=&quot;perlref&quot;&gt;perlref&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval()&lt;/a&gt;&lt;/code&gt; 이름이 선언 내에 숨겨져되지 않는 한, 그러나, 그렇게 긴가 평가되는 범위의 어휘 변수를 볼 수 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval()&lt;/a&gt;&lt;/code&gt; 자체. &lt;a href=&quot;perlref&quot;&gt;perlref를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="6342bae4fda60017077e5c45e326240a9752de8d" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; ''&lt;/code&gt; executed within a subroutine defined in the &lt;code&gt;DB&lt;/code&gt; package doesn't see the usual surrounding lexical scope, but rather the scope of the first non-DB piece of code that called it. You don't normally need to worry about this unless you are writing a Perl debugger.</source>
          <target state="translated">&lt;code&gt;DB&lt;/code&gt; 패키지에 정의 된 서브 루틴 내에서 실행 된 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; ''&lt;/code&gt; 은 일반적인 주변 어휘 범위가 아니라 그것을 호출 한 최초의 비 DB 조각 코드의 범위를 봅니다. Perl 디버거를 작성하지 않는 한 일반적으로 이것에 대해 걱정할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="e98b3b90e3045dc3b637b5a6dd09b73503e89407" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; declaration declares an alias for a package variable that will be visible across its entire lexical scope, even across package boundaries. The package in which the variable is entered is determined at the point of the declaration, not at the point of use. This means the following behavior holds:</source>
          <target state="translated">안 &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; 선언은 심지어 패키지 경계를 넘어, 전체 어휘 범위에서 볼 수 있습니다 패키지 변수에 대한 별칭을 선언합니다. 변수가 입력 된 패키지는 사용 시점이 아닌 선언 시점에서 결정됩니다. 이것은 다음과 같은 동작을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="b85b4821ea02e10c76868c61d73ce67c03c3c58f" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; declaration may also have a list of attributes associated with it.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; 선언은 그와 관련된 속성의 목록을 가질 수있다.</target>
        </trans-unit>
        <trans-unit id="0e6a38b5837351a0fa7ad12169129c95c04803d4" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;&lt;a href=&quot;our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; declaration declares an alias for a package variable that will be visible across its entire lexical scope, even across package boundaries. The package in which the variable is entered is determined at the point of the declaration, not at the point of use. This means the following behavior holds:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; 선언은 심지어 패키지 경계를 넘어, 전체 어휘 범위에서 볼 수 있습니다 패키지 변수에 대한 별칭을 선언합니다. 변수가 입력 된 패키지는 사용 시점이 아닌 선언 시점에서 결정됩니다. 이것은 다음과 같은 동작을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="ff67756e1b83b8c246879fd06b2405feac998276" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;&lt;a href=&quot;our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; declaration may also have a list of attributes associated with it.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; 선언은 그와 관련된 속성의 목록을 가질 수있다.</target>
        </trans-unit>
        <trans-unit id="09f284e34c7193100513bdbf0c748168a131c400" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;=item&lt;/code&gt; or &lt;code&gt;=back&lt;/code&gt; command has been found outside a &lt;code&gt;=over&lt;/code&gt; /&lt;code&gt;=back&lt;/code&gt; block.</source>
          <target state="translated">&lt;code&gt;=item&lt;/code&gt; 또는 &lt;code&gt;=back&lt;/code&gt; A는 외부 명령이 발견되었다 &lt;code&gt;=over&lt;/code&gt; / &lt;code&gt;=back&lt;/code&gt; 블록.</target>
        </trans-unit>
        <trans-unit id="74ddbf837617e690734ce4e331574925980ad4cf" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;=item&lt;/code&gt; or &lt;code&gt;=back&lt;/code&gt; command has been found outside a &lt;code&gt;=over&lt;/code&gt;/&lt;code&gt;=back&lt;/code&gt; block.</source>
          <target state="translated">&lt;code&gt;=item&lt;/code&gt; 또는 &lt;code&gt;=back&lt;/code&gt; A는 외부 명령이 발견되었다 &lt;code&gt;=over&lt;/code&gt; / &lt;code&gt;=back&lt;/code&gt; 블록.</target>
        </trans-unit>
        <trans-unit id="66cb1e02933a96ffc4b888e742e11e5e2a0810c8" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;END&lt;/code&gt; code block is executed as late as possible, that is, after perl has finished running the program and just before the interpreter is being exited, even if it is exiting as a result of a die() function. (But not if it's morphing into another program via &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt;, or being blown out of the water by a signal--you have to trap that yourself (if you can).) You may have multiple &lt;code&gt;END&lt;/code&gt; blocks within a file--they will execute in reverse order of definition; that is: last in, first out (LIFO). &lt;code&gt;END&lt;/code&gt; blocks are not executed when you run perl with the &lt;code&gt;-c&lt;/code&gt; switch, or if compilation fails.</source>
          <target state="translated">&lt;code&gt;END&lt;/code&gt; 의 코드 블록은 다이 () 함수의 결과, 종료 된 경우에도, 펄이 프로그램 실행 완료과 통역자가 종료되기 직전 후, 즉, 가능한 한 늦게 실행된다. (그러나 그것이 &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; 를 통해 다른 프로그램으로 변형 되거나 신호에 의해 물에서 날아가는 경우가 아니라면 자신을 잡아야합니다 (가능한 경우). 파일 내에 여러 개의 &lt;code&gt;END&lt;/code&gt; 블록 이있을 수 있습니다. 정의의 역순으로 실행; 즉 : 마지막, 먼저 (LIFO). &lt;code&gt;-c&lt;/code&gt; 스위치를 사용하여 perl을 실행 하거나 컴파일이 실패하면 &lt;code&gt;END&lt;/code&gt; 블록이 실행되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="e942cc0968d145d9b00a1b1c78467e33e46acc43" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;END&lt;/code&gt; code block is executed as late as possible, that is, after perl has finished running the program and just before the interpreter is being exited, even if it is exiting as a result of a die() function. (But not if it's morphing into another program via &lt;code&gt;exec&lt;/code&gt;, or being blown out of the water by a signal--you have to trap that yourself (if you can).) You may have multiple &lt;code&gt;END&lt;/code&gt; blocks within a file--they will execute in reverse order of definition; that is: last in, first out (LIFO). &lt;code&gt;END&lt;/code&gt; blocks are not executed when you run perl with the &lt;code&gt;-c&lt;/code&gt; switch, or if compilation fails.</source>
          <target state="translated">&lt;code&gt;END&lt;/code&gt; 의 코드 블록은 다이 () 함수의 결과, 종료 된 경우에도, 펄이 프로그램 실행 완료과 통역자가 종료되기 직전 후, 즉, 가능한 한 늦게 실행된다. (하지만 &lt;code&gt;exec&lt;/code&gt; 를 통해 다른 프로그램으로 변형 되거나 신호에 의해 물 밖으로 날아가는 경우가 아니라 직접 트랩해야합니다 (가능한 경우).) 파일 내에 여러 개의 &lt;code&gt;END&lt;/code&gt; 블록 이있을 수 있습니다. 정의의 역순으로 실행합니다. 즉, LIFO (last in, first out)입니다. &lt;code&gt;-c&lt;/code&gt; 스위치를 사용하여 perl을 실행 하거나 컴파일이 실패하면 &lt;code&gt;END&lt;/code&gt; 블록이 실행되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="2e32fa7ec52528fa53daf789a891351a0047191f" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;ExtUtils::Typemaps&lt;/code&gt; object.</source>
          <target state="translated">&lt;code&gt;ExtUtils::Typemaps&lt;/code&gt; 객체입니다.</target>
        </trans-unit>
        <trans-unit id="2106dcfb583dc95f2d7d0a7530b5308a6cea8ccd" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;IO::Handle&lt;/code&gt; object is a reference to a symbol/GLOB reference (see the &lt;code&gt;Symbol&lt;/code&gt; package). Some modules that inherit from &lt;code&gt;IO::Handle&lt;/code&gt; may want to keep object related variables in the hash table part of the GLOB. In an attempt to prevent modules trampling on each other I propose the that any such module should prefix its variables with its own name separated by _'s. For example the IO::Socket module keeps a &lt;code&gt;timeout&lt;/code&gt; variable in 'io_socket_timeout'.</source>
          <target state="translated">&lt;code&gt;IO::Handle&lt;/code&gt; 객체는 심볼 / GLOB 참조에 대한 참조합니다 (참조입니다 &lt;code&gt;Symbol&lt;/code&gt; 패키지). &lt;code&gt;IO::Handle&lt;/code&gt; 에서 상속 된 일부 모듈 은 GLOB의 해시 테이블 부분에 객체 관련 변수를 유지하려고 할 수 있습니다. 모듈이 서로 짓밟히는 것을 막기 위해 그러한 모듈은 변수 앞에 _로 구분 된 고유 이름을 붙여야한다고 제안합니다. 예를 들어 IO :: Socket 모듈 은 'io_socket_timeout'에 &lt;code&gt;timeout&lt;/code&gt; 변수를 유지합니다 .</target>
        </trans-unit>
        <trans-unit id="ddbf17a10e023000ccc30961ca5b0d4cd79dd73a" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;eval ''&lt;/code&gt; executed within a subroutine defined in the &lt;code&gt;DB&lt;/code&gt; package doesn't see the usual surrounding lexical scope, but rather the scope of the first non-DB piece of code that called it. You don't normally need to worry about this unless you are writing a Perl debugger.</source>
          <target state="translated">&lt;code&gt;DB&lt;/code&gt; 패키지에 정의 된 서브 루틴 내에서 실행 되는 &lt;code&gt;eval ''&lt;/code&gt; 은 일반적인 주변 어휘 범위가 아니라이를 호출 한 첫 번째 비 DB 코드 조각의 범위를 확인합니다. Perl 디버거를 작성하지 않는 한 일반적으로 이것에 대해 걱정할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="daf77a66a50c9398b1fd7246b531ff3583302d3a" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;eval()&lt;/code&gt;, however, can see lexical variables of the scope it is being evaluated in, so long as the names aren't hidden by declarations within the &lt;code&gt;eval()&lt;/code&gt; itself. See &lt;a href=&quot;perlref&quot;&gt;perlref&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;eval()&lt;/code&gt; 이름이 선언 내에 숨겨져되지 않는 한, 그러나, 그렇게 긴가 평가되는 범위의 어휘 변수를 볼 수 &lt;code&gt;eval()&lt;/code&gt; 자체. &lt;a href=&quot;perlref&quot;&gt;perlref를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="4327b0847cdc34977cdbdda7e68546f97fba6ace" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;https&lt;/code&gt; connection may be made via an &lt;code&gt;http&lt;/code&gt; proxy that supports the CONNECT command (i.e. RFC 2817). You may not proxy &lt;code&gt;https&lt;/code&gt; via a proxy that itself requires &lt;code&gt;https&lt;/code&gt; to communicate.</source>
          <target state="translated">&lt;code&gt;https&lt;/code&gt; 연결은 통해 이루어질 수 &lt;code&gt;http&lt;/code&gt; 프록시가 지원하는 CONNECT 명령 (즉, RFC 2817). 통신을 위해 자체적으로 &lt;code&gt;https&lt;/code&gt; 가 필요한 프록시를 통해 &lt;code&gt;https&lt;/code&gt; 를 프록시 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="bb7b8e2c63742b11c42dcae1ac500eab80f3ab56" translate="yes" xml:space="preserve">
          <source>An Array Reference</source>
          <target state="translated">배열 참조</target>
        </trans-unit>
        <trans-unit id="8d4bdf476b3365f09a887c13f6c40076ebfaf6c1" translate="yes" xml:space="preserve">
          <source>An Aside About Smarter and Safer Code</source>
          <target state="translated">더 똑똑하고 안전한 코드</target>
        </trans-unit>
        <trans-unit id="3b01e7833f6ef8368a6a19aec43504160373e004" translate="yes" xml:space="preserve">
          <source>An E&amp;lt;...&amp;gt; surrounding strange content</source>
          <target state="translated">이상한 콘텐츠를 둘러싼 E &amp;lt;...&amp;gt;</target>
        </trans-unit>
        <trans-unit id="e626c65821f55eedc24b3d056f760901055b33ab" translate="yes" xml:space="preserve">
          <source>An Error Handler</source>
          <target state="translated">오류 처리기</target>
        </trans-unit>
        <trans-unit id="d96ae95b9e6d2684c36b739e4e16b84332bd4be3" translate="yes" xml:space="preserve">
          <source>An Event-Driven Program</source>
          <target state="translated">이벤트 기반 프로그램</target>
        </trans-unit>
        <trans-unit id="dcd29613666219a97f2491f0610be4945ceed298" translate="yes" xml:space="preserve">
          <source>An Example</source>
          <target state="translated">예</target>
        </trans-unit>
        <trans-unit id="f8c1ce33e34656d389a163577db68ecf2ef0ded0" translate="yes" xml:space="preserve">
          <source>An Example -- the NULL termination problem.</source>
          <target state="translated">예-NULL 종료 문제</target>
        </trans-unit>
        <trans-unit id="b0338e71cce0b4ccb879ecd4b7099e83ebe3be92" translate="yes" xml:space="preserve">
          <source>An Example: the NULL termination problem.</source>
          <target state="translated">예 : NULL 종료 문제</target>
        </trans-unit>
        <trans-unit id="8c00947f1047eee3af23c94728ed5ad710d9cb2f" translate="yes" xml:space="preserve">
          <source>An INSTALL file should be included, and should contain simple installation instructions. When using ExtUtils::MakeMaker this will usually be:</source>
          <target state="translated">설치 파일이 포함되어야하며 간단한 설치 지침이 포함되어 있어야합니다. ExtUtils :: MakeMaker를 사용할 때 일반적으로 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="506b7c2a6739d4b086313431ab2d8807d26d26ea" translate="yes" xml:space="preserve">
          <source>An Input FileGlob string</source>
          <target state="translated">입력 FileGlob 문자열</target>
        </trans-unit>
        <trans-unit id="c6d4eb0ecab7adc479ea3b6eef3a6aca32ccbec3" translate="yes" xml:space="preserve">
          <source>An OFFSET may be specified to place the read data at some place in the string other than the beginning. A negative OFFSET specifies placement at that many characters counting backwards from the end of the string. A positive OFFSET greater than the length of SCALAR results in the string being padded to the required size with &lt;code&gt;&quot;\0&quot;&lt;/code&gt; bytes before the result of the read is appended.</source>
          <target state="translated">판독 데이터를 시작 이외의 문자열의 특정 위치에 배치하도록 OFFSET을 지정할 수 있습니다. 음수 OFFSET은 문자열 끝부터 거꾸로 세는 많은 문자의 배치를 지정합니다. SCALAR 길이보다 큰 양의 OFFSET은 문자열이 읽기 결과가 추가되기 전에 &lt;code&gt;&quot;\0&quot;&lt;/code&gt; 바이트로 필요한 크기로 채워집니다 .</target>
        </trans-unit>
        <trans-unit id="0dc3cbd84029f4f613840045b9422510efa87d84" translate="yes" xml:space="preserve">
          <source>An OFFSET may be specified to write the data from some part of the string other than the beginning. A negative OFFSET specifies writing that many characters counting backwards from the end of the string. If SCALAR is of length zero, you can only use an OFFSET of 0.</source>
          <target state="translated">문자열의 시작 부분 이외의 일부에서 데이터를 쓰도록 OFFSET을 지정할 수 있습니다. 음의 OFFSET은 많은 문자가 문자열 끝에서 거꾸로 세는 것을 쓰도록 지정합니다. SCALAR의 길이가 0이면 OFFSET 0 만 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bd9383fdee820dfd7a79259db8339a2ec8fb85d9" translate="yes" xml:space="preserve">
          <source>An Object is Simply a Data Structure</source>
          <target state="translated">객체는 단순히 데이터 구조입니다</target>
        </trans-unit>
        <trans-unit id="a75b7e5900f9f9a5e2336a6194fd54179bb27c7e" translate="yes" xml:space="preserve">
          <source>An Output FileGlob</source>
          <target state="translated">출력 파일</target>
        </trans-unit>
        <trans-unit id="813d4e6c344e0e779c908b93f3b8922ba5b51b2f" translate="yes" xml:space="preserve">
          <source>An RDF vocabulary to describe software projects. &lt;a href=&quot;http://usefulinc.com/doap&quot;&gt;http://usefulinc.com/doap&lt;/a&gt;.</source>
          <target state="translated">소프트웨어 프로젝트를 설명하는 RDF 어휘. &lt;a href=&quot;http://usefulinc.com/doap&quot;&gt;http://usefulinc.com/doap&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d2be5f7e627a6ada01e5f83f900c749a12504c5b" translate="yes" xml:space="preserve">
          <source>An RPN expression can also be interpreted in another way, as a sequence of operations on a stack, one operation per token. A literal or variable token pushes a value onto the stack. A binary operator pulls two items off the stack, performs a calculation with them, and pushes the result back onto the stack. The stack starts out empty, and at the end of the expression there must be exactly one value left on the stack.</source>
          <target state="translated">RPN 표현식은 스택에 대한 일련의 작업으로 토큰 당 하나의 작업으로 다른 방식으로 해석 될 수도 있습니다. 리터럴 또는 변수 토큰은 값을 스택에 푸시합니다. 이항 연산자는 스택에서 두 항목을 가져 와서 계산을 수행 한 다음 결과를 스택으로 다시 푸시합니다. 스택은 빈 상태로 시작하고 표현식의 끝에 정확히 하나의 값이 스택에 남아 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="451423395ae3ecccc772428a72078e3af59aea77" translate="yes" xml:space="preserve">
          <source>An RPN expression may be any of:</source>
          <target state="translated">RPN 표현식은 다음 중 하나 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e69ceb552111cae999e0e9d8f79c888a4e18b2ab" translate="yes" xml:space="preserve">
          <source>An SV (or AV, HV, etc.) is allocated in two parts: the head (struct sv, av, hv...) contains type and reference count information, and for many types, a pointer to the body (struct xrv, xpv, xpviv...), which contains fields specific to each type. Some types store all they need in the head, so don't have a body.</source>
          <target state="translated">SV (또는 AV, HV 등)는 두 부분으로 할당됩니다. head (struct sv, av, hv ...)는 유형 및 참조 횟수 정보를 포함하며 많은 유형의 경우 본문에 대한 포인터 (struct xrv) , xpv, xpviv ...), 각 유형에 특정한 필드를 포함합니다. 어떤 유형은 머리에 필요한 모든 것을 저장하므로 몸이 없습니다.</target>
        </trans-unit>
        <trans-unit id="0db48295b7cb634bd39479ea9baf6751db33420c" translate="yes" xml:space="preserve">
          <source>An SV can be created and loaded with one command. There are five types of values that can be loaded: an integer value (IV), an unsigned integer value (UV), a double (NV), a string (PV), and another scalar (SV). (&quot;PV&quot; stands for &quot;Pointer Value&quot;. You might think that it is misnamed because it is described as pointing only to strings. However, it is possible to have it point to other things. For example, it could point to an array of UVs. But, using it for non-strings requires care, as the underlying assumption of much of the internals is that PVs are just for strings. Often, for example, a trailing &lt;code&gt;NUL&lt;/code&gt; is tacked on automatically. The non-string use is documented only in this paragraph.)</source>
          <target state="translated">하나의 명령으로 SV를 생성하고로드 할 수 있습니다. 로드 할 수있는 값에는 정수 값 (IV), 부호없는 정수 값 (UV), 이중 (NV), 문자열 (PV) 및 다른 스칼라 (SV)의 5 가지 유형이 있습니다. ( &quot;PV&quot;는 &quot;포인터 값&quot;을 나타냅니다. 문자열만을 가리키는 것으로 설명되어 있기 때문에 이름이 잘못되었다고 생각할 수도 있지만 다른 것을 가리킬 수도 있습니다. 예를 들어 배열을 가리킬 수 있습니다 그러나 내부의 많은 부분의 기본 가정은 PV가 단지 문자열에 대한 것이라는 가정이기 때문에주의해야합니다. 예를 들어, 후행 &lt;code&gt;NUL&lt;/code&gt; 은 자동으로 고정됩니다. 이 단락에만 문서화되어 있습니다.)</target>
        </trans-unit>
        <trans-unit id="e49daf61f2f4bab338dc0435e2098c4740ae32f6" translate="yes" xml:space="preserve">
          <source>An SV may be passed as a second argument. If so, the name will be assigned to it and it will be returned. Otherwise the returned SV will be a new mortal.</source>
          <target state="translated">SV는 두 번째 인수로 전달 될 수 있습니다. 그렇다면 이름이 할당되고 반환됩니다. 그렇지 않으면 반환 된 SV는 새로운 필멸자가 될 것입니다.</target>
        </trans-unit>
        <trans-unit id="7e60a0da99f77ec00184644cb08929c2fbb88e98" translate="yes" xml:space="preserve">
          <source>An URL for a bug tracker (e.g. Bugzilla or RT queue) for this project.</source>
          <target state="translated">이 프로젝트에 대한 버그 추적기 (예 : Bugzilla 또는 RT 대기열)의 URL입니다.</target>
        </trans-unit>
        <trans-unit id="5cb53ac6b527ff22855aa21b588aeb5e456de693" translate="yes" xml:space="preserve">
          <source>An URL for an official statement of this distribution's license.</source>
          <target state="translated">이 배포 라이센스에 대한 공식 성명서의 URL입니다.</target>
        </trans-unit>
        <trans-unit id="c8d6fdbeeb22295aa04aac68ad9fd7f77cf9046a" translate="yes" xml:space="preserve">
          <source>An XS module that is locale-dependent could have been written under the assumption that it will never be called in a multi-threaded environment, and so uses other non-locale constructs that aren't multi-thread-safe. See &lt;a href=&quot;perlxs#Thread-aware-system-interfaces&quot;&gt;&quot;Thread-aware system interfaces&quot; in perlxs&lt;/a&gt;.</source>
          <target state="translated">로케일 종속적 인 XS 모듈은 다중 스레드 환경에서 절대 호출되지 않는다는 가정하에 작성되었을 수 있으므로 다중 스레드로부터 안전하지 않은 다른 비 로케일 구조를 사용합니다. &lt;a href=&quot;perlxs#Thread-aware-system-interfaces&quot;&gt;perlxs의 &quot;스레드 인식 시스템 인터페이스&quot;를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="35a93457850bdbb33ca102c024544fcdc99dd999" translate="yes" xml:space="preserve">
          <source>An XSUB section continues until another section-start keyword is found.</source>
          <target state="translated">XSUB 섹션은 다른 section-start 키워드가 발견 될 때까지 계속됩니다.</target>
        </trans-unit>
        <trans-unit id="db98408a971f988d838aae97c21a88cbfeff498b" translate="yes" xml:space="preserve">
          <source>An abstract character&amp;rsquo;s integer value. Same thing as &lt;b&gt;codepoint&lt;/b&gt;.</source>
          <target state="translated">추상 문자의 정수 값입니다. &lt;b&gt;codepoint&lt;/b&gt; 와 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="bd8526c4f7f2f82dc46961c40bfa270781cafa7e" translate="yes" xml:space="preserve">
          <source>An accessor function can be redefined in order to provide additional checking of values, etc. Here, we want the &lt;code&gt;count&lt;/code&gt; element always to be nonnegative, so we redefine the &lt;code&gt;count&lt;/code&gt; accessor accordingly.</source>
          <target state="translated">값 등을 추가로 확인하기 위해 접근 자 함수를 재정의 할 수 있습니다. 여기에서 &lt;code&gt;count&lt;/code&gt; 요소는 항상 음수가 아니므로 &lt;code&gt;count&lt;/code&gt; 접근 자를 재정의합니다 .</target>
        </trans-unit>
        <trans-unit id="76864d299088548272113a8d31dd2510d163d674" translate="yes" xml:space="preserve">
          <source>An accessor lets you add additional code around attribute access. For example, you could apply a default to an attribute that wasn't set in the constructor, or you could validate that a new value for the attribute is acceptable.</source>
          <target state="translated">접근자는 속성 액세스 주위에 추가 코드를 추가 할 수 있습니다. 예를 들어, 생성자에서 설정되지 않은 속성에 기본값을 적용하거나 속성의 새 값이 허용되는지 유효성을 검증 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7f7dfcb0e79b76d6607a032d4c42004b6d846b72" translate="yes" xml:space="preserve">
          <source>An action that terminates a process will terminate</source>
          <target state="translated">프로세스를 종료하는 작업은 종료됩니다</target>
        </trans-unit>
        <trans-unit id="3d55486b7ae618b0c9e5822b88065546dbd8b09b" translate="yes" xml:space="preserve">
          <source>An actual piece of data, in contrast to all the variables, references, keys, indices, operators, and whatnot that you need to access the value.</source>
          <target state="translated">모든 변수, 참조, 키, 인덱스, 연산자 및 값에 액세스해야하는 것과 대조되는 실제 데이터입니다.</target>
        </trans-unit>
        <trans-unit id="1e18a14c7435e1ad99b33d06cb67211ccd6f13ff" translate="yes" xml:space="preserve">
          <source>An adjectival pseudofunction that warps the meaning of an &lt;b&gt;lvalue&lt;/b&gt; in some declarative fashion. Currently there are three lvalue modifiers: &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;b&gt;lvalue&lt;/b&gt; 의 의미를 일부 선언적인 방식으로 왜곡하는 형용사 의사 함수 . 현재 세 개의 lvalue 수정 자 : &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; 이 있습니다.</target>
        </trans-unit>
        <trans-unit id="147929b2af4f7b23dfdf17e155cb639bdee82ce1" translate="yes" xml:space="preserve">
          <source>An adjectival pseudofunction that warps the meaning of an &lt;b&gt;lvalue&lt;/b&gt; in some declarative fashion. Currently there are three lvalue modifiers: &lt;code&gt;my&lt;/code&gt;, &lt;code&gt;our&lt;/code&gt;, and &lt;code&gt;local&lt;/code&gt;.</source>
          <target state="translated">선언적 방식으로 &lt;b&gt;lvalue&lt;/b&gt; 의 의미를 왜곡하는 형용사 의사 함수입니다 . 현재 &lt;code&gt;my&lt;/code&gt; , &lt;code&gt;our&lt;/code&gt; 및 &lt;code&gt;local&lt;/code&gt; 의 세 가지 lvalue 수정자가 있습니다.</target>
        </trans-unit>
        <trans-unit id="450e105909f5464a91b8d711013a548cdad0ecea" translate="yes" xml:space="preserve">
          <source>An algorithm to map a character set to a byte sequence. You don't have to be able to tell which character set a given byte sequence belongs. 7-bit ISO-2022 is a CES but it cannot be a CCS. EUC is an example of being both a CCS and CES.</source>
          <target state="translated">문자 집합을 바이트 시퀀스에 매핑하는 알고리즘입니다. 주어진 바이트 시퀀스가 ​​어떤 문자 집합에 속하는지 알 수있을 필요는 없습니다. 7 비트 ISO-2022는 CES이지만 CCS가 될 수 없습니다. EUC는 CCS와 CES 모두의 예입니다.</target>
        </trans-unit>
        <trans-unit id="1ddce428631d662b65df938a0ab59dc6d26df5c3" translate="yes" xml:space="preserve">
          <source>An alias can map to either an official Unicode character name (not a loose matched name) or to a numeric code point (ordinal). The latter is useful for assigning names to code points in Unicode private use areas such as U+E800 through U+F8FF. A numeric code point must be a non-negative integer, or a string beginning with &lt;code&gt;&quot;U+&quot;&lt;/code&gt; or &lt;code&gt;&quot;0x&quot;&lt;/code&gt; with the remainder considered to be a hexadecimal integer. A literal numeric constant must be unsigned; it will be interpreted as hex if it has a leading zero or contains non-decimal hex digits; otherwise it will be interpreted as decimal. If it begins with &lt;code&gt;&quot;U+&quot;&lt;/code&gt; , it is interpreted as the Unicode code point; otherwise it is interpreted as native. (Only code points below 256 can differ between Unicode and native.) Thus &lt;code&gt;U+41&lt;/code&gt; is always the Latin letter &quot;A&quot;; but &lt;code&gt;0x41&lt;/code&gt; can be &quot;NO-BREAK SPACE&quot; on EBCDIC platforms.</source>
          <target state="translated">별명은 공식 유니 코드 문자 이름 (느슨한 일치 이름이 아님) 또는 숫자 코드 포인트 (정수)에 맵핑 될 수 있습니다. 후자는 U + E800에서 U + F8FF와 같은 유니 코드 개인 사용 영역의 코드 포인트에 이름을 지정하는 데 유용합니다. 숫자 코드 포인트는 음이 아닌 정수이거나 &lt;code&gt;&quot;U+&quot;&lt;/code&gt; 또는 &lt;code&gt;&quot;0x&quot;&lt;/code&gt; 로 시작하는 문자열 이어야하며 나머지는 16 진수 정수로 간주됩니다. 리터럴 숫자 상수는 부호가 없어야합니다. 앞에 0이 있거나 16 진이 아닌 16 진수가 포함 된 경우 16 진으로 해석됩니다. 그렇지 않으면 십진수로 해석됩니다. &lt;code&gt;&quot;U+&quot;&lt;/code&gt; 시작 하면 유니 코드 코드 포인트로 해석됩니다. 그렇지 않으면 기본으로 해석됩니다. (256 미만의 코드 포인트 만 유니 코드와 네이티브간에 다를 수 있습니다.) 따라서 &lt;code&gt;U+41&lt;/code&gt; 은 항상 라틴 문자 &quot;A&quot;입니다. 그러나 EBCDIC 플랫폼 에서는 &lt;code&gt;0x41&lt;/code&gt; 이 &quot;NO-BREAK SPACE&quot;일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="307b5df586934d78ce8b5dabe9ab9b8c2f875563" translate="yes" xml:space="preserve">
          <source>An alias can map to either an official Unicode character name (not a loose matched name) or to a numeric code point (ordinal). The latter is useful for assigning names to code points in Unicode private use areas such as U+E800 through U+F8FF. A numeric code point must be a non-negative integer, or a string beginning with &lt;code&gt;&quot;U+&quot;&lt;/code&gt; or &lt;code&gt;&quot;0x&quot;&lt;/code&gt; with the remainder considered to be a hexadecimal integer. A literal numeric constant must be unsigned; it will be interpreted as hex if it has a leading zero or contains non-decimal hex digits; otherwise it will be interpreted as decimal. If it begins with &lt;code&gt;&quot;U+&quot;&lt;/code&gt;, it is interpreted as the Unicode code point; otherwise it is interpreted as native. (Only code points below 256 can differ between Unicode and native.) Thus &lt;code&gt;U+41&lt;/code&gt; is always the Latin letter &quot;A&quot;; but &lt;code&gt;0x41&lt;/code&gt; can be &quot;NO-BREAK SPACE&quot; on EBCDIC platforms.</source>
          <target state="translated">별칭은 공식 유니 코드 문자 이름 (느슨하게 일치하는 이름이 아님) 또는 숫자 코드 포인트 (서수)에 매핑 될 수 있습니다. 후자는 U + E800에서 U + F8FF까지와 같은 유니 코드 개인 사용 영역의 코드 포인트에 이름을 할당하는 데 유용합니다. 숫자 코드 포인트는 음수가 아닌 정수이거나 &lt;code&gt;&quot;U+&quot;&lt;/code&gt; 또는 &lt;code&gt;&quot;0x&quot;&lt;/code&gt; 로 시작하고 나머지는 16 진 정수로 간주 되는 문자열 이어야합니다. 리터럴 숫자 상수는 부호가 없어야합니다. 선행 0이 있거나 10 진수가 아닌 16 진수를 포함하는 경우 16 진수로 해석됩니다. 그렇지 않으면 십진수로 해석됩니다. &lt;code&gt;&quot;U+&quot;&lt;/code&gt; 시작 하면 유니 코드 코드 포인트로 해석됩니다. 그렇지 않으면 네이티브로 해석됩니다. (256 미만의 코드 포인트 만 유니 코드와 네이티브간에 다를 수 있습니다.) 따라서 &lt;code&gt;U+41&lt;/code&gt; 은 항상 라틴 문자 &quot;A&quot;입니다. 그러나 &lt;code&gt;0x41&lt;/code&gt; 은 EBCDIC 플랫폼에서 &quot;NO-BREAK SPACE&quot;가 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2346eaad655197a010139149e8271c64c649a891" translate="yes" xml:space="preserve">
          <source>An alias for fullname</source>
          <target state="translated">성명 별명</target>
        </trans-unit>
        <trans-unit id="7fe1e0c1ce121b1e661962490b3a8d17f0df008e" translate="yes" xml:space="preserve">
          <source>An alias for hostfqdn ().</source>
          <target state="translated">hostfqdn ()의 별명입니다.</target>
        </trans-unit>
        <trans-unit id="0f9c5134c84e70c19466ac6665667bdc11f335df" translate="yes" xml:space="preserve">
          <source>An alphanumeric name preceded by dollar sign refers to a Perl scalar variable. Only variables declared with &lt;code&gt;my&lt;/code&gt; or &lt;code&gt;state&lt;/code&gt; are supported. If the variable's value is not a native integer, it will be converted to an integer, by Perl's usual mechanisms, at the time it is evaluated.</source>
          <target state="translated">달러 기호가 앞에 오는 영숫자 이름은 Perl 스칼라 변수를 나타냅니다. &lt;code&gt;my&lt;/code&gt; 또는 &lt;code&gt;state&lt;/code&gt; 로 선언 된 변수 만 지원됩니다. 변수의 값이 원시 정수가 아니면 평가시 Perl의 일반적인 메커니즘에 의해 정수로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="fa449dd40ff0246bd3a833083086ff6fe9ea989c" translate="yes" xml:space="preserve">
          <source>An alternate (and possibly simpler) method to pushing values on the stack is to use the macro:</source>
          <target state="translated">스택에서 값을 푸시하는 또 다른 방법은 아마도 매크로를 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="1921a2093ccc86489ce0ad3cb2bb5dbbb1b5fcf0" translate="yes" xml:space="preserve">
          <source>An alternate delimiter may be specified using &lt;a href=&quot;#-Fpattern&quot;&gt;-F&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#-Fpattern&quot;&gt;-F를&lt;/a&gt; 사용하여 대체 구분 기호를 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="490e5f218f41d502acc0f80b9b4c03244664bdb6" translate="yes" xml:space="preserve">
          <source>An alternate delimiter may be specified using &lt;b&gt;-F&lt;/b&gt;.</source>
          <target state="translated">대체 구분 기호는 &lt;b&gt;-F를&lt;/b&gt; 사용하여 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a3cee96423e82840fff05ec16e3bc4bd5558bd28" translate="yes" xml:space="preserve">
          <source>An alternate filename that points to the real &lt;b&gt;filename&lt;/b&gt;, which in turn points to the real &lt;b&gt;file&lt;/b&gt;. Whenever the &lt;b&gt;operating system&lt;/b&gt; is trying to parse a &lt;b&gt;pathname&lt;/b&gt; containing a symbolic link, it merely substitutes the new name and continues parsing.</source>
          <target state="translated">또 다른 파일 이름이 실제 포인트 &lt;b&gt;파일 이름&lt;/b&gt; 의 실제에 지점을 설정, &lt;b&gt;파일&lt;/b&gt; . &lt;b&gt;운영 체제&lt;/b&gt; 가 기호 링크가 포함 된 &lt;b&gt;경로 이름&lt;/b&gt; 을 구문 분석하려고 할 때마다 새 이름을 대체하고 구문 분석을 계속합니다.</target>
        </trans-unit>
        <trans-unit id="567849086db2a3773d0ebaa265c330619cbbb371" translate="yes" xml:space="preserve">
          <source>An alternate interface to Filter::Util::Call is now available. See &lt;a href=&quot;../simple&quot;&gt;Filter::Simple&lt;/a&gt; for more details.</source>
          <target state="translated">Filter :: Util :: Call에 대한 대체 인터페이스를 사용할 수 있습니다. 자세한 내용은 &lt;a href=&quot;../simple&quot;&gt;Filter :: Simple&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="309e6a9857cb37095aa6e70561b74ca78f25b7d4" translate="yes" xml:space="preserve">
          <source>An alternate interface to Filter::Util::Call is now available. See &lt;a href=&quot;Filter::Simple&quot;&gt;Filter::Simple&lt;/a&gt; for more details.</source>
          <target state="translated">이제 Filter :: Util :: Call에 대한 대체 인터페이스를 사용할 수 있습니다. 자세한 내용은 &lt;a href=&quot;Filter::Simple&quot;&gt;Filter :: Simple&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="c1c89b199090d1d97e837c8f064d662931bf60c5" translate="yes" xml:space="preserve">
          <source>An alternate way to create a new version object is through the exported qv() sub. This is not strictly like other q? operators (like qq, qw), in that the only delimiters supported are parentheses (or spaces). It is the best way to initialize a short version without triggering the floating point interpretation. For example:</source>
          <target state="translated">새 버전 객체를 만드는 또 다른 방법은 내 보낸 qv () 하위를 사용하는 것입니다. 이것은 다른 q와 엄격하게 다르지 않습니까? 연산자 (예 : qq, qw), 지원되는 유일한 구분 기호는 괄호 (또는 공백)입니다. 부동 소수점 해석을 트리거하지 않고 짧은 버전을 초기화하는 가장 좋은 방법입니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="675501f93d17028172930c214a15945683c8e504" translate="yes" xml:space="preserve">
          <source>An alternative approach to cache flushing is to use the &lt;code&gt;HASH&lt;/code&gt; option (see above) to request that &lt;code&gt;Memoize&lt;/code&gt; use a particular hash variable as its cache. Then you can examine or modify the hash at any time in any way you desire. You may flush the cache by using &lt;code&gt;%hash = ()&lt;/code&gt; .</source>
          <target state="translated">캐시 플러싱에 대한 다른 방법은 &lt;code&gt;HASH&lt;/code&gt; 옵션 (위 참조)을 사용하여 &lt;code&gt;Memoize&lt;/code&gt; 가 특정 해시 변수를 캐시로 사용 하도록 요청하는 것 입니다. 그런 다음 언제든지 원하는 방식으로 해시를 검사하거나 수정할 수 있습니다. &lt;code&gt;%hash = ()&lt;/code&gt; 사용하여 캐시를 플러시 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e8b6136f62918ff1ea1ed138ea0c96c6d31fc586" translate="yes" xml:space="preserve">
          <source>An alternative approach to cache flushing is to use the &lt;code&gt;HASH&lt;/code&gt; option (see above) to request that &lt;code&gt;Memoize&lt;/code&gt; use a particular hash variable as its cache. Then you can examine or modify the hash at any time in any way you desire. You may flush the cache by using &lt;code&gt;%hash = ()&lt;/code&gt;.</source>
          <target state="translated">캐시 비우기에 대한 또 다른 접근 방식은 &lt;code&gt;HASH&lt;/code&gt; 옵션 (위 참조)을 사용하여 &lt;code&gt;Memoize&lt;/code&gt; 가 캐시로 특정 해시 변수를 사용 하도록 요청하는 것 입니다. 그런 다음 원하는 방식으로 언제든지 해시를 검사하거나 수정할 수 있습니다. &lt;code&gt;%hash = ()&lt;/code&gt; 사용하여 캐시를 플러시 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b2fe156c5b22968eab0fbdde266b1268db8760ef" translate="yes" xml:space="preserve">
          <source>An alternative is CamelBones, a framework that allows access to both Foundation and AppKit classes and objects, so that full GUI applications can be built in Perl. CamelBones can be found on SourceForge, at &lt;a href=&quot;http://www.sourceforge.net/projects/camelbones/&quot;&gt;http://www.sourceforge.net/projects/camelbones/&lt;/a&gt;.</source>
          <target state="translated">대안으로 CamelBones는 Foundation 및 AppKit 클래스와 객체 모두에 액세스 할 수있는 프레임 워크로 Perl에서 전체 GUI 응용 프로그램을 빌드 할 수 있습니다. CamelBone은 SourceForge ( &lt;a href=&quot;http://www.sourceforge.net/projects/camelbones/&quot;&gt;http://www.sourceforge.net/projects/camelbones/&lt;/a&gt; )에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5b9956d0c6aedc296243c0a951b58bd48cc08ba5" translate="yes" xml:space="preserve">
          <source>An alternative is CamelBones, a framework that allows access to both Foundation and AppKit classes and objects, so that full GUI applications can be built in Perl. CamelBones can be found on SourceForge, at &lt;a href=&quot;https://www.sourceforge.net/projects/camelbones/&quot;&gt;https://www.sourceforge.net/projects/camelbones/&lt;/a&gt;.</source>
          <target state="translated">대안은 CamelBones로, Foundation 및 AppKit 클래스와 객체 모두에 액세스 할 수 있도록하여 전체 GUI 응용 프로그램을 Perl로 구축 할 수 있습니다. CamelBones는 &lt;a href=&quot;https://www.sourceforge.net/projects/camelbones/&quot;&gt;https://www.sourceforge.net/projects/camelbones/의&lt;/a&gt; SourceForge에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="adf70c06c68960fa2b5ce48b474675e096b9430d" translate="yes" xml:space="preserve">
          <source>An alternative method of debugging regexps is to embed &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; statements within the regexp. This provides a blow-by-blow account of the backtracking in an alternation:</source>
          <target state="translated">정규 표현식 을 디버깅하는 다른 방법은 정규 표현식 내에 &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; 문 을 포함시키는 것 입니다. 이것은 교대로 역 추적에 대한 한 번에 한 번의 설명을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="d38adacc9748189f199af8dc89eab5c14ea53178" translate="yes" xml:space="preserve">
          <source>An alternative method of debugging regexps is to embed &lt;code&gt;print&lt;/code&gt; statements within the regexp. This provides a blow-by-blow account of the backtracking in an alternation:</source>
          <target state="translated">regexp 를 디버깅하는 또 다른 방법은 regexp 내에 &lt;code&gt;print&lt;/code&gt; 문 을 포함 하는 것입니다. 이것은 번갈아 가며 역 추적에 대한 타격 별 설명을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="797f91185d7afbacb2d3c5eed6df4adbd22d2a7d" translate="yes" xml:space="preserve">
          <source>An alternative reference is the Info-Zip appnote. This is available from &lt;a href=&quot;ftp://ftp.info-zip.org/pub/infozip/doc/&quot;&gt;ftp://ftp.info-zip.org/pub/infozip/doc/&lt;/a&gt;</source>
          <target state="translated">대체 참조는 Info-Zip appnote입니다. 이것은 &lt;a href=&quot;ftp://ftp.info-zip.org/pub/infozip/doc/&quot;&gt;ftp://ftp.info-zip.org/pub/infozip/doc/&lt;/a&gt; 에서 구할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="577bb949a7cbee63183e379cdce8743144bb2e97" translate="yes" xml:space="preserve">
          <source>An alternative to using &lt;a href=&quot;#substr-EXPR%2COFFSET%2CLENGTH%2CREPLACEMENT&quot;&gt;&lt;code&gt;substr&lt;/code&gt;&lt;/a&gt; as an lvalue is to specify the replacement string as the 4th argument. This allows you to replace parts of the EXPR and return what was there before in one operation, just as you can with &lt;a href=&quot;#splice-ARRAY%2COFFSET%2CLENGTH%2CLIST&quot;&gt;&lt;code&gt;splice&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">lvalue로 &lt;a href=&quot;#substr-EXPR%2COFFSET%2CLENGTH%2CREPLACEMENT&quot;&gt; &lt;code&gt;substr&lt;/code&gt; &lt;/a&gt; 을 사용하는 것에 대한 대안 은 대체 문자열을 네 번째 인수로 지정하는 것입니다. 이렇게하면 &lt;a href=&quot;#splice-ARRAY%2COFFSET%2CLENGTH%2CLIST&quot;&gt; &lt;code&gt;splice&lt;/code&gt; &lt;/a&gt; 에서와 마찬가지로 EXPR의 일부를 교체하고 한 번의 작업으로 이전에 있던 것을 반환 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="bf78a032596f44477dfca0392a1f37e462bfc42f" translate="yes" xml:space="preserve">
          <source>An alternative to using substr() as an lvalue is to specify the replacement string as the 4th argument. This allows you to replace parts of the EXPR and return what was there before in one operation, just as you can with splice().</source>
          <target state="translated">substr ()을 lvalue로 사용하는 대신 대체 문자열을 4 번째 인수로 지정하는 것입니다. 이를 통해 splice ()와 마찬가지로 EXPR의 일부를 교체하고 한 번의 작업으로 이전에 있던 것을 반환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="25b5286961be13762e984cfd1189ea7a9bb06d7a" translate="yes" xml:space="preserve">
          <source>An alternative to writing the filter in C is to create a separate executable in the language of your choice. The separate executable reads from standard input, does whatever processing is necessary, and writes the filtered data to standard output. &lt;code&gt;Filter::cpp&lt;/code&gt; is an example of a source filter implemented as a separate executable - the executable is the C preprocessor bundled with your C compiler.</source>
          <target state="translated">C로 필터를 작성하는 대안은 원하는 언어로 별도의 실행 파일을 만드는 것입니다. 별도의 실행 파일은 표준 입력에서 읽고 필요한 처리를 수행하며 필터링 된 데이터를 표준 출력에 씁니다. &lt;code&gt;Filter::cpp&lt;/code&gt; 는 별도의 실행 파일로 구현 된 소스 필터의 예입니다. 실행 파일은 C 컴파일러와 함께 번들로 제공되는 C 프리 프로세서입니다.</target>
        </trans-unit>
        <trans-unit id="9216315bb2214d5ed94f6db6fec42532477a8283" translate="yes" xml:space="preserve">
          <source>An alternative way of writing something more easily; a shortcut.</source>
          <target state="translated">보다 쉽게 ​​무언가를 작성하는 다른 방법; 바로 가기.</target>
        </trans-unit>
        <trans-unit id="d69bfaa7d98ebed8954a924a638458e2ecf0b867" translate="yes" xml:space="preserve">
          <source>An alternative way to achieve this can be seen in &lt;a href=&quot;Gtk2::CodeGen&quot;&gt;Gtk2::CodeGen&lt;/a&gt; and &lt;a href=&quot;Glib::CodeGen&quot;&gt;Glib::CodeGen&lt;/a&gt;.</source>
          <target state="translated">이를 달성하는 다른 방법은 &lt;a href=&quot;Gtk2::CodeGen&quot;&gt;Gtk2 :: CodeGen&lt;/a&gt; 및 &lt;a href=&quot;Glib::CodeGen&quot;&gt;Glib :: CodeGen&lt;/a&gt; 에서 볼 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3719242868ba601b24b2c4019225372b6d1ba5a6" translate="yes" xml:space="preserve">
          <source>An alternatively is the Info-Zip appnote. This is available from &lt;a href=&quot;ftp://ftp.info-zip.org/pub/infozip/doc/&quot;&gt;ftp://ftp.info-zip.org/pub/infozip/doc/&lt;/a&gt;</source>
          <target state="translated">대안은 Info-Zip appnote입니다. 이것은 &lt;a href=&quot;ftp://ftp.info-zip.org/pub/infozip/doc/&quot;&gt;ftp://ftp.info-zip.org/pub/infozip/doc/&lt;/a&gt; 에서 구할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f6ef70866e892e0391f54f3f0e595fde0691ccb0" translate="yes" xml:space="preserve">
          <source>An anchor useful in basic regexps is the</source>
          <target state="translated">기본 정규 표현식에 유용한 앵커는</target>
        </trans-unit>
        <trans-unit id="a941741e26d01bf48e71deca7cfe67d745df0d18" translate="yes" xml:space="preserve">
          <source>An anonymous array of alternative library specifications to be searched for (in order) until at least one library is found. E.g.</source>
          <target state="translated">하나 이상의 라이브러리를 찾을 때까지 (순서대로) 검색 할 대체 라이브러리 스펙의 익명 배열. 예 :</target>
        </trans-unit>
        <trans-unit id="c253698bf9e4f75c2b5d0a18558b851f2d3f6b5e" translate="yes" xml:space="preserve">
          <source>An application that takes the trouble to use information in &lt;code&gt;LC_MONETARY&lt;/code&gt; may format debits as if they were credits and vice versa if that locale has been subverted. Or it might make payments in US dollars instead of Hong Kong dollars.</source>
          <target state="translated">&lt;code&gt;LC_MONETARY&lt;/code&gt; 에서 정보를 사용하는 데 어려움을 겪는 응용 프로그램은 차변이 신용 인 것처럼 차변 에 서식을 지정할 수 있으며, 그 로케일이 파괴 된 경우에는 그 반대의 경우도 가능합니다. 또는 홍콩 달러 대신 미국 달러로 지불 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="01ac9da7b76fdd816e4e95bf07e705af326d0f2c" translate="yes" xml:space="preserve">
          <source>An application using Module can say something like:</source>
          <target state="translated">모듈을 사용하는 응용 프로그램은 다음과 같이 말할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a335ab967a8e1f5c521e6fbf8a762d039a0699ab" translate="yes" xml:space="preserve">
          <source>An archaic expression for what is more correctly referred to as &lt;b&gt;list context&lt;/b&gt;.</source>
          <target state="translated">보다 정확하게 &lt;b&gt;list context&lt;/b&gt; 라고하는 것에 대한 구식 입니다.</target>
        </trans-unit>
        <trans-unit id="7dd0ff3c6abfb69f462a62c5017ae088c797d806" translate="yes" xml:space="preserve">
          <source>An argument can be ignored by omitting the main part of the name from a parameter declaration, leaving just a bare &lt;code&gt;$&lt;/code&gt; sigil. For example,</source>
          <target state="translated">인수는 매개 변수 선언에서 이름의 주요 부분을 생략하고 그냥 맨손으로 남겨 둠으로써 무시 될 수 &lt;code&gt;$&lt;/code&gt; 의 인장을. 예를 들어</target>
        </trans-unit>
        <trans-unit id="3f5cfd48537bc41203499ec678c7f8d1ffcc4184" translate="yes" xml:space="preserve">
          <source>An argument line supplying values to plug into the previous picture line.</source>
          <target state="translated">이전 그림 줄에 연결할 값을 제공하는 인수 줄입니다.</target>
        </trans-unit>
        <trans-unit id="e1318b0f2b2dd2f7e8a55cad33c819c262a23ea1" translate="yes" xml:space="preserve">
          <source>An array can also change its length:</source>
          <target state="translated">배열은 길이를 변경할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="a7633012ecb371a2113d013c22d2c030bb2a3192" translate="yes" xml:space="preserve">
          <source>An array can be accessed one scalar at a time by specifying a dollar sign (&lt;code&gt;$&lt;/code&gt; ), then the name of the array (without the leading &lt;code&gt;@&lt;/code&gt; ), then the subscript inside square brackets. For example:</source>
          <target state="translated">배열은 달러 기호 ( &lt;code&gt;$&lt;/code&gt; ), 배열 이름 (앞에 &lt;code&gt;@&lt;/code&gt; 이없는 ), 대괄호 안에있는 첨자 를 지정하여 한 번에 한 스칼라에 액세스 할 수 있습니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="540cdd79efe573437a7605791a2eb1616100de60" translate="yes" xml:space="preserve">
          <source>An array can be accessed one scalar at a time by specifying a dollar sign (&lt;code&gt;$&lt;/code&gt;), then the name of the array (without the leading &lt;code&gt;@&lt;/code&gt;), then the subscript inside square brackets. For example:</source>
          <target state="translated">달러 기호 ( &lt;code&gt;$&lt;/code&gt; ), 배열 이름 (앞에 &lt;code&gt;@&lt;/code&gt; 없음 ), 대괄호 안의 아래 첨자 를 지정하여 한 번에 하나의 스칼라에 액세스 할 수 있습니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="015711954685a7b3ea99a44f6e657f520fa53416" translate="yes" xml:space="preserve">
          <source>An array of an array is just a regular old array @AoA that you can get at with two subscripts, like &lt;code&gt;$AoA[3][2]&lt;/code&gt; . Here's a declaration of the array:</source>
          <target state="translated">배열의 배열은 &lt;code&gt;$AoA[3][2]&lt;/code&gt; 와 같이 두 개의 아래 첨자로 얻을 수있는 일반적인 오래된 배열 @AoA입니다 . 배열의 선언은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="11613ff6241b5d0054882bce3b479c51b671807c" translate="yes" xml:space="preserve">
          <source>An array of an array is just a regular old array @AoA that you can get at with two subscripts, like &lt;code&gt;$AoA[3][2]&lt;/code&gt;. Here's a declaration of the array:</source>
          <target state="translated">배열의 배열은 &lt;code&gt;$AoA[3][2]&lt;/code&gt; 와 같이 두 개의 첨자로 얻을 수있는 일반적인 오래된 배열 @AoA입니다 . 다음은 배열의 선언입니다.</target>
        </trans-unit>
        <trans-unit id="ae61cf59e4cd9db6ee9b5a175cc315be8ef10741" translate="yes" xml:space="preserve">
          <source>An array of constants' names, either scalars containing names, or hashrefs as detailed in &lt;a href=&quot;#C_constant&quot;&gt;&quot;C_constant&quot;&lt;/a&gt;.</source>
          <target state="translated">상수 이름 배열, 이름을 포함하는 스칼라 또는 &lt;a href=&quot;#C_constant&quot;&gt;&quot;C_constant&quot;에&lt;/a&gt; 자세히 설명 된 해시 참조 .</target>
        </trans-unit>
        <trans-unit id="9aee3421650400587ce5406d39d397928a2add0e" translate="yes" xml:space="preserve">
          <source>An array of constants' names, either scalars containing names, or hashrefs as detailed in &lt;a href=&quot;#C_constant&quot;&gt;C_constant&lt;/a&gt;.</source>
          <target state="translated">이름을 포함하는 스칼라 또는 C_constant에 자세히 설명 된 &lt;a href=&quot;#C_constant&quot;&gt;해시&lt;/a&gt; 참조 인 상수 이름의 배열입니다 .</target>
        </trans-unit>
        <trans-unit id="f4dbdb6c0876baa594d12d6a72f40a78381bda16" translate="yes" xml:space="preserve">
          <source>An array of file names for the shared objects that were loaded.</source>
          <target state="translated">로드 된 공유 객체의 파일 이름 배열입니다.</target>
        </trans-unit>
        <trans-unit id="26930aebfa1fee021fd440dae3cf343080566995" translate="yes" xml:space="preserve">
          <source>An array of module (package) names that have been bootstrap'ed.</source>
          <target state="translated">부트 스트랩 된 모듈 (패키지) 이름의 배열입니다.</target>
        </trans-unit>
        <trans-unit id="e8f1da37492eab7b118aed0b3744e018cc0392dd" translate="yes" xml:space="preserve">
          <source>An array of non-negative integers that is used for comparison purposes with other version objects.</source>
          <target state="translated">다른 버전 개체와 비교 목적으로 사용되는 음이 아닌 정수의 배열입니다.</target>
        </trans-unit>
        <trans-unit id="792d37106ab796a9da516b2cfe4619175268f4f1" translate="yes" xml:space="preserve">
          <source>An array of patches on CPAN or on the local disk to be applied in order via an external patch program. If the value for the &lt;code&gt;-p&lt;/code&gt; parameter is &lt;code&gt;0&lt;/code&gt; or &lt;code&gt;1&lt;/code&gt; is determined by reading the patch beforehand. The path to each patch is either an absolute path on the local filesystem or relative to a patch directory specified in the &lt;code&gt;patches_dir&lt;/code&gt; configuration variable or in the format of a canonical distro name. For examples please consult the distroprefs/ directory in the CPAN.pm distribution (these examples are not installed by default).</source>
          <target state="translated">외부 패치 프로그램을 통해 순서대로 적용 할 CPAN 또는 로컬 디스크의 패치 배열. &lt;code&gt;-p&lt;/code&gt; 매개 변수 의 값 이 &lt;code&gt;0&lt;/code&gt; 또는 &lt;code&gt;1&lt;/code&gt; 인 경우, 패치를 미리 읽음으로써 결정됩니다. 각 패치의 경로는 로컬 파일 시스템의 절대 경로이거나, &lt;code&gt;patches_dir&lt;/code&gt; 구성 변수에 지정된 패치 디렉토리 또는 표준 배포 이름 형식의 상대 경로입니다 . 예를 들어 CPAN.pm 배포의 distroprefs / 디렉토리를 참조하십시오 (이 예제는 기본적으로 설치되지 않음).</target>
        </trans-unit>
        <trans-unit id="b89f1be8b64b665e2888aa36341ca67f3fc8a573" translate="yes" xml:space="preserve">
          <source>An array of the handles returned by successful calls to dl_load_file(), made by bootstrap, in the order in which they were loaded. Can be used with dl_find_symbol() to look for a symbol in any of the loaded files.</source>
          <target state="translated">부트 스트랩에 의해 작성된 dl_load_file ()에 대한 성공적인 호출에 의해 리턴 된 핸들의 배열. 로드 된 파일에서 기호를 찾기 위해 dl_find_symbol ()과 함께 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c823d47a703f9ce8bdd6c6bd99c53c578f964658" translate="yes" xml:space="preserve">
          <source>An array reference</source>
          <target state="translated">배열 참조</target>
        </trans-unit>
        <trans-unit id="2042400b9cf51420ca0bb02f4a95651f7d9e0fc1" translate="yes" xml:space="preserve">
          <source>An array represents a list of values:</source>
          <target state="translated">배열은 값 목록을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="7ce42eb4fb16bbef377321c32853b8f06079f21c" translate="yes" xml:space="preserve">
          <source>An array which exposes the contents of the capture buffers, if any, of the last successful pattern match, not counting patterns matched in nested blocks that have been exited already.</source>
          <target state="translated">이미 종료 된 중첩 된 블록에서 일치하는 패턴을 계산하지 않고 마지막으로 성공한 패턴 일치의 캡처 버퍼 (있는 경우)의 내용을 노출하는 배열입니다.</target>
        </trans-unit>
        <trans-unit id="d58bf09473fcb443f32238cd3f343fe1cb52e884" translate="yes" xml:space="preserve">
          <source>An array with multiple subscripts for finding a single element. Perl implements these using &lt;b&gt;references&lt;/b&gt;&amp;mdash;see Camel chapter 9, &amp;ldquo;Data Structures&amp;rdquo;.</source>
          <target state="translated">단일 요소를 찾기위한 여러 첨자가있는 배열입니다. Perl은 &lt;b&gt;참조를&lt;/b&gt; 사용하여이를 구현합니다. Camel 9 장 &quot;데이터 구조&quot; 를 &lt;b&gt;참조&lt;/b&gt; 하십시오.</target>
        </trans-unit>
        <trans-unit id="e730b7563caa7a9a3615b79242bd88575f2b5d2f" translate="yes" xml:space="preserve">
          <source>An attempt to &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; &quot;require $module&quot;&lt;/code&gt; failed, even though the list of extensions indicated that it should succeed. Correct by conducting a proper installation.</source>
          <target state="translated">확장 목록에서 성공해야한다고 표시했지만 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; &quot;require $module&quot;&lt;/code&gt; &lt;a href=&quot;functions/eval&quot;&gt;평가&lt;/a&gt; 시도가 실패했습니다. 올바르게 설치하여 수정하십시오.</target>
        </trans-unit>
        <trans-unit id="f00d85ec569efd3d0ba1b09d16f4a00196ee0d74" translate="yes" xml:space="preserve">
          <source>An attempt to &lt;code&gt;eval &quot;require $module&quot;&lt;/code&gt; failed, even though the list of extensions indicated that it should succeed. Correct by conducting a proper installation.</source>
          <target state="translated">확장 목록에 성공해야한다고 표시되었지만 &lt;code&gt;eval &quot;require $module&quot;&lt;/code&gt; 을 평가 하려는 시도가 실패했습니다. 적절한 설치를 수행하여 수정하십시오.</target>
        </trans-unit>
        <trans-unit id="8668d93103d45211068cbb7aa1991bd63b959bd9" translate="yes" xml:space="preserve">
          <source>An attempt to allocate memory failed.</source>
          <target state="translated">메모리 할당 시도가 실패했습니다.</target>
        </trans-unit>
        <trans-unit id="4965e597a6abdfe2d520970b55b8363275b2a451" translate="yes" xml:space="preserve">
          <source>An attempt to set an unrecognized attribute is a fatal error. (The error is trappable, but it still stops the compilation within that &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;.) Setting an attribute with a name that's all lowercase letters that's not a built-in attribute (such as &quot;foo&quot;) will result in a warning with &lt;b&gt;-w&lt;/b&gt; or &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings 'reserved'&lt;/code&gt; .</source>
          <target state="translated">인식 할 수없는 속성을 설정하려는 시도는 치명적인 오류입니다. (오류는 트랩 가능하지만 여전히 해당 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 내에서 컴파일을 중지합니다 .) 기본 제공 속성이 아닌 모든 소문자 이름으로 속성을 설정하면 (예 : &quot;foo&quot;) &lt;b&gt;-w&lt;/b&gt; 또는 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings 'reserved'&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a24018dbac9a81adda03170beee4acf228798de6" translate="yes" xml:space="preserve">
          <source>An attempt to set an unrecognized attribute is a fatal error. (The error is trappable, but it still stops the compilation within that &lt;code&gt;eval&lt;/code&gt;.) Setting an attribute with a name that's all lowercase letters that's not a built-in attribute (such as &quot;foo&quot;) will result in a warning with &lt;b&gt;-w&lt;/b&gt; or &lt;code&gt;use warnings 'reserved'&lt;/code&gt;.</source>
          <target state="translated">인식 할 수없는 속성을 설정하려는 시도는 치명적 오류입니다. (오류는 트랩 가능하지만 여전히 해당 &lt;code&gt;eval&lt;/code&gt; 내에서 컴파일을 중지합니다 .) 기본 제공 속성 (예 : &quot;foo&quot;)이 아닌 모두 소문자로 된 이름을 가진 속성을 설정하면 &lt;b&gt;-w&lt;/b&gt; 또는 &lt;code&gt;use warnings 'reserved'&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="93c1784b7ddee55af5b75a4bf233031106bc926c" translate="yes" xml:space="preserve">
          <source>An attribute handler was specified with an &lt;code&gt;:ATTR(&lt;i&gt;ref_type&lt;/i&gt;)&lt;/code&gt;, but the type of referent it was defined to handle wasn't one of the five permitted: &lt;code&gt;SCALAR&lt;/code&gt; , &lt;code&gt;ARRAY&lt;/code&gt; , &lt;code&gt;HASH&lt;/code&gt; , &lt;code&gt;CODE&lt;/code&gt; , or &lt;code&gt;ANY&lt;/code&gt; .</source>
          <target state="translated">속성 핸들러가 &lt;code&gt;:ATTR(&lt;i&gt;ref_type&lt;/i&gt;)&lt;/code&gt; 으로 지정 되었지만 처리하도록 정의 된 참조 유형이 &lt;code&gt;SCALAR&lt;/code&gt; , &lt;code&gt;ARRAY&lt;/code&gt; , &lt;code&gt;HASH&lt;/code&gt; , &lt;code&gt;CODE&lt;/code&gt; 또는 &lt;code&gt;ANY&lt;/code&gt; 중 하나가 아닙니다 .</target>
        </trans-unit>
        <trans-unit id="be2ec17006c02c47726210c596c995f951690163" translate="yes" xml:space="preserve">
          <source>An attribute handler was specified with an &lt;code&gt;:ATTR(&lt;i&gt;ref_type&lt;/i&gt;)&lt;/code&gt;, but the type of referent it was defined to handle wasn't one of the five permitted: &lt;code&gt;SCALAR&lt;/code&gt;, &lt;code&gt;ARRAY&lt;/code&gt;, &lt;code&gt;HASH&lt;/code&gt;, &lt;code&gt;CODE&lt;/code&gt;, or &lt;code&gt;ANY&lt;/code&gt;.</source>
          <target state="translated">속성 핸들러가 &lt;code&gt;:ATTR(&lt;i&gt;ref_type&lt;/i&gt;)&lt;/code&gt; 으로 지정 되었지만 처리하도록 정의 된 &lt;i&gt;리퍼&lt;/i&gt; 런트 유형이 &lt;code&gt;SCALAR&lt;/code&gt; , &lt;code&gt;ARRAY&lt;/code&gt; , &lt;code&gt;HASH&lt;/code&gt; , &lt;code&gt;CODE&lt;/code&gt; 또는 &lt;code&gt;ANY&lt;/code&gt; 의 5 개 중 하나가 허용되지 않았습니다 .</target>
        </trans-unit>
        <trans-unit id="9ed24a1addfea7e1a18f9560990ecafe644b6003" translate="yes" xml:space="preserve">
          <source>An attribute is a piece of data belonging to a particular object. Unlike most object-oriented languages, Perl provides no special syntax or support for declaring and manipulating attributes.</source>
          <target state="translated">속성은 특정 객체에 속하는 데이터입니다. 대부분의 객체 지향 언어와 달리 Perl은 속성을 선언하고 조작하기위한 특별한 구문이나 지원을 제공하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4774fb20b25b2c00d90761710a32f25902ad2435" translate="yes" xml:space="preserve">
          <source>An attribute list is a sequence of attribute specifications, separated by whitespace or a colon (with optional whitespace). Each attribute specification is a simple name, optionally followed by a parenthesised parameter list. If such a parameter list is present, it is scanned past as for the rules for the &lt;code&gt;&lt;a href=&quot;functions/q&quot;&gt;q()&lt;/a&gt;&lt;/code&gt; operator. (See &lt;a href=&quot;perlop#Quote-and-Quote-like-Operators&quot;&gt;Quote and Quote-like Operators in perlop&lt;/a&gt;.) The parameter list is passed as it was found, however, and not as per &lt;code&gt;&lt;a href=&quot;functions/q&quot;&gt;q()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">속성 목록은 공백 또는 콜론으로 구분 된 일련의 속성 사양입니다 (선택적 공백 포함). 각 속성 스펙은 간단한 이름이며 선택적으로 괄호로 묶은 매개 변수 목록이 뒤에옵니다. 이러한 매개 변수 목록이 있으면 &lt;code&gt;&lt;a href=&quot;functions/q&quot;&gt;q()&lt;/a&gt;&lt;/code&gt; 연산자 의 규칙에 대해 과거에 스캔됩니다 . ( &lt;a href=&quot;perlop#Quote-and-Quote-like-Operators&quot;&gt;perlop의 인용 및 인용 유사 연산자를&lt;/a&gt; 참조하십시오 .) 그러나 매개 변수 목록은 &lt;code&gt;&lt;a href=&quot;functions/q&quot;&gt;q()&lt;/a&gt;&lt;/code&gt; 아니라 발견 된대로 전달됩니다 .</target>
        </trans-unit>
        <trans-unit id="cc6c334100243f2c62d45354cd17461eb4374199" translate="yes" xml:space="preserve">
          <source>An attribute list is a sequence of attribute specifications, separated by whitespace or a colon (with optional whitespace). Each attribute specification is a simple name, optionally followed by a parenthesised parameter list. If such a parameter list is present, it is scanned past as for the rules for the &lt;code&gt;q()&lt;/code&gt; operator. (See &lt;a href=&quot;perlop#Quote-and-Quote-like-Operators&quot;&gt;&quot;Quote and Quote-like Operators&quot; in perlop&lt;/a&gt;.) The parameter list is passed as it was found, however, and not as per &lt;code&gt;q()&lt;/code&gt;.</source>
          <target state="translated">속성 목록은 공백 또는 콜론 (선택적 공백 포함)으로 구분 된 일련의 속성 사양입니다. 각 속성 사양은 간단한 이름이며 선택적으로 괄호로 묶인 매개 변수 목록이 뒤 따릅니다. 이러한 매개 변수 목록이 있으면 &lt;code&gt;q()&lt;/code&gt; 연산자 에 대한 규칙처럼 과거를 스캔 합니다. ( &lt;a href=&quot;perlop#Quote-and-Quote-like-Operators&quot;&gt;perlop의 &quot;Quote and Quote-like Operators&quot;를&lt;/a&gt; 참조하십시오 .) 매개 변수 목록은 발견 된대로 전달되지만 &lt;code&gt;q()&lt;/code&gt; 별로 전달되지는 않습니다 .</target>
        </trans-unit>
        <trans-unit id="f9a21fa1e7844543aacf6b214485b949a7b1705b" translate="yes" xml:space="preserve">
          <source>An early change, in fact the change that made Test2 an idea, was a change to the indentation of the subtest note. It was decided it would be more readable to outdent the subtest note instead of having it inline with the subtest:</source>
          <target state="translated">사실 Test2를 아이디어로 만든 초기 변경은 하위 테스트 노트의 들여 쓰기에 대한 변경이었습니다. 하위 테스트와 함께 인라인하는 대신 하위 테스트 노트를 내 어쓰는 것이 더 읽기 쉽게 결정되었습니다.</target>
        </trans-unit>
        <trans-unit id="6356b19b83a0de734fd036ef3412ad9e0499e73b" translate="yes" xml:space="preserve">
          <source>An effect similar to &lt;code&gt;(?&amp;gt;&lt;i&gt;pattern&lt;/i&gt;)&lt;/code&gt; may be achieved by writing &lt;code&gt;(?=(&lt;i&gt;pattern&lt;/i&gt;))\g{-1}&lt;/code&gt;. This matches the same substring as a standalone &lt;code&gt;a+&lt;/code&gt;, and the following &lt;code&gt;\g{-1}&lt;/code&gt; eats the matched string; it therefore makes a zero-length assertion into an analogue of &lt;code&gt;(?&amp;gt;...)&lt;/code&gt;. (The difference between these two constructs is that the second one uses a capturing group, thus shifting ordinals of backreferences in the rest of a regular expression.)</source>
          <target state="translated">&lt;code&gt;(?&amp;gt;&lt;i&gt;pattern&lt;/i&gt;)&lt;/code&gt; 과 유사한 효과 는 &lt;code&gt;(?=(&lt;i&gt;pattern&lt;/i&gt;))\g{-1}&lt;/code&gt; 을 작성하여 얻을 수 있습니다 . 이것은 독립형 &lt;code&gt;a+&lt;/code&gt; 와 동일한 하위 문자열과 일치하며 다음 &lt;code&gt;\g{-1}&lt;/code&gt; 은 일치하는 문자열을 먹습니다. 따라서 길이가 0 인 주장을 &lt;code&gt;(?&amp;gt;...)&lt;/code&gt; 의 유사체로 만듭니다 . (이 두 구문의 차이점은 두 번째 구문은 캡처 링 그룹을 사용하므로 나머지 정규 표현식에서 역 참조의 서수를 이동한다는 것입니다.)</target>
        </trans-unit>
        <trans-unit id="b6ff4a009f82a7cfb00247fff66222df5571297d" translate="yes" xml:space="preserve">
          <source>An effect similar to &lt;code&gt;(?&amp;gt;pattern)&lt;/code&gt; may be achieved by writing &lt;code&gt;(?=(pattern))\g{-1}&lt;/code&gt; . This matches the same substring as a standalone &lt;code&gt;a+&lt;/code&gt; , and the following &lt;code&gt;\g{-1}&lt;/code&gt; eats the matched string; it therefore makes a zero-length assertion into an analogue of &lt;code&gt;(?&amp;gt;...)&lt;/code&gt;. (The difference between these two constructs is that the second one uses a capturing group, thus shifting ordinals of backreferences in the rest of a regular expression.)</source>
          <target state="translated">&lt;code&gt;(?&amp;gt;pattern)&lt;/code&gt; &lt;code&gt;(?=(pattern))\g{-1}&lt;/code&gt; 을 쓰면 (?&amp;gt; pattern) 과 비슷한 효과를 얻을 수 있습니다 . 이것은 독립형 &lt;code&gt;a+&lt;/code&gt; 와 동일한 하위 문자열과 일치하며 다음 &lt;code&gt;\g{-1}&lt;/code&gt; 은 일치하는 문자열을 먹는다. 따라서 길이가 0 인 어설 션을 &lt;code&gt;(?&amp;gt;...)&lt;/code&gt; 의 유사체로 만듭니다 . (이 두 구성의 차이점은 두 번째 구성은 캡처 그룹을 사용하여 나머지 정규 표현식에서 역 참조 순서를 이동한다는 것입니다.)</target>
        </trans-unit>
        <trans-unit id="c5d792d65a737f380eae7ddca70051ed5bf418d1" translate="yes" xml:space="preserve">
          <source>An embedded perl needs to be started up while the global locale is in effect. See &lt;a href=&quot;perlembed#Using-embedded-Perl-with-POSIX-locales&quot;&gt;&quot;Using embedded Perl with POSIX locales&quot; in perlembed&lt;/a&gt;.</source>
          <target state="translated">임베디드 펄은 글로벌 로케일이 적용되는 동안 시작되어야합니다. &lt;a href=&quot;perlembed#Using-embedded-Perl-with-POSIX-locales&quot;&gt;perlembed의 &quot;POSIX 로케일과 함께 임베디드 Perl 사용&quot;을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="65503b1bc3cc6e29b56e0751024a1c32f6babaa5" translate="yes" xml:space="preserve">
          <source>An empty &lt;code&gt;L&amp;lt;&amp;gt;&lt;/code&gt;</source>
          <target state="translated">빈 &lt;code&gt;L&amp;lt;&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="830fe5530bf8a388dd3b4e1cd4354d40bf489efb" translate="yes" xml:space="preserve">
          <source>An empty E&amp;lt;&amp;gt;</source>
          <target state="translated">빈 E &amp;lt;&amp;gt;</target>
        </trans-unit>
        <trans-unit id="1de720044af3435092cdfe83370a7cafc924ed83" translate="yes" xml:space="preserve">
          <source>An empty X&amp;lt;&amp;gt;</source>
          <target state="translated">빈 X &amp;lt;&amp;gt;</target>
        </trans-unit>
        <trans-unit id="e5eb41f6f24dfa906c0da1eda1f150cd75892a06" translate="yes" xml:space="preserve">
          <source>An empty leading field is produced when there is a positive-width match at the beginning of EXPR. For instance:</source>
          <target state="translated">EXPR 시작시 양의 너비가 일치하면 빈 선행 필드가 생성됩니다. 예를 들어 :</target>
        </trans-unit>
        <trans-unit id="7c1d0be8e8ca70fd2b14e62fb21989504ef1df2a" translate="yes" xml:space="preserve">
          <source>An empty list as soon as an explicit &lt;code&gt;break&lt;/code&gt; is encountered.</source>
          <target state="translated">명시적인 &lt;code&gt;break&lt;/code&gt; 이 발생 하자마자 빈 목록 입니다.</target>
        </trans-unit>
        <trans-unit id="39e866d4dec47e8ffded31535bf330825a29cb83" translate="yes" xml:space="preserve">
          <source>An empty list, in list context</source>
          <target state="translated">목록 컨텍스트에서 빈 목록</target>
        </trans-unit>
        <trans-unit id="afbf0f80f22fc5d795da7f111754a1b9ed2a4fe4" translate="yes" xml:space="preserve">
          <source>An empty trailing field, on the other hand, is produced when there is a match at the end of EXPR, regardless of the length of the match (of course, unless a non-zero LIMIT is given explicitly, such fields are removed, as in the last example). Thus:</source>
          <target state="translated">반면 빈 후행 필드는 일치하는 길이에 관계없이 EXPR의 끝에 일치가있을 때 생성됩니다 (물론, 0이 아닌 LIMIT가 명시 적으로 지정되지 않은 경우 이러한 필드는 다음과 같이 제거됩니다). 마지막 예에서). 그러므로:</target>
        </trans-unit>
        <trans-unit id="cd562f569c7a192c547c6c2160f193f3f97949c6" translate="yes" xml:space="preserve">
          <source>An enchantment, illusion, phantasm, or jugglery. Said when Perl&amp;rsquo;s magical &lt;b&gt;dwimmer&lt;/b&gt; effects don&amp;rsquo;t do what you expect, but rather seem to be the product of arcane</source>
          <target state="translated">마법, 환상, 환상 또는 저글링. Perl의 마법 같은 &lt;b&gt;dwimmer&lt;/b&gt; 효과가 당신이 기대하는 것을하지 않고 오히려 비전의 산물 인 것처럼 보입니다.</target>
        </trans-unit>
        <trans-unit id="5a1e64f9893fb69df07a9e0956194fcfd71ca286" translate="yes" xml:space="preserve">
          <source>An endpoint for network communication among multiple &lt;b&gt;processes&lt;/b&gt; that works much like a telephone or a post office box. The most important thing about a socket is its &lt;b&gt;network address&lt;/b&gt; (like a phone number). Different kinds of sockets have different kinds of addresses&amp;mdash;some look like filenames, and some don&amp;rsquo;t.</source>
          <target state="translated">전화 또는 우체국 상자와 매우 유사한 여러 &lt;b&gt;프로세스&lt;/b&gt; 간의 네트워크 통신을위한 엔드 포인트입니다 . 소켓의 가장 중요한 점은 전화 번호와 같은 &lt;b&gt;네트워크 주소&lt;/b&gt; 입니다. 다른 종류의 소켓에는 다른 종류의 주소가 있습니다. 일부는 파일 이름처럼 보이지만 일부는 그렇지 않습니다.</target>
        </trans-unit>
        <trans-unit id="84340afb233fc1ed2c36b5178d0bb87bc821d3fd" translate="yes" xml:space="preserve">
          <source>An entire computer program crammed into one line of text.</source>
          <target state="translated">전체 컴퓨터 프로그램이 한 줄의 텍스트로 채워졌습니다.</target>
        </trans-unit>
        <trans-unit id="0b89a9a0affedc51570a8afe57fcceb747dbf5fe" translate="yes" xml:space="preserve">
          <source>An entity specified by number (dec, hex, oct) is out of range (1-255).</source>
          <target state="translated">숫자 (dec, hex, oct)로 지정된 엔터티가 범위 (1-255)를 벗어났습니다.</target>
        </trans-unit>
        <trans-unit id="e4a99f74cee987dba72920fbff7e10dc623de69d" translate="yes" xml:space="preserve">
          <source>An entry of the form &lt;code&gt;-La:\foo&lt;/code&gt; specifies the &lt;code&gt;a:\foo&lt;/code&gt; directory to look for the libraries that follow.</source>
          <target state="translated">&lt;code&gt;-La:\foo&lt;/code&gt; 형식의 항목은 뒤에 오는 라이브러리를 찾기 위해 &lt;code&gt;a:\foo&lt;/code&gt; 디렉토리를 지정합니다 .</target>
        </trans-unit>
        <trans-unit id="e872c91a08d6535bc529f64f8ec25e1266b0facd" translate="yes" xml:space="preserve">
          <source>An entry of the form &lt;code&gt;-lfoo&lt;/code&gt; specifies the library &lt;code&gt;foo&lt;/code&gt; , which may be spelled differently depending on what kind of compiler you are using. If you are using GCC, it gets translated to &lt;code&gt;libfoo.a&lt;/code&gt; , but for other win32 compilers, it becomes &lt;code&gt;foo.lib&lt;/code&gt; . If no files are found by those translated names, one more attempt is made to find them using either &lt;code&gt;foo.a&lt;/code&gt; or &lt;code&gt;libfoo.lib&lt;/code&gt; , depending on whether GCC or some other win32 compiler is being used, respectively.</source>
          <target state="translated">&lt;code&gt;-lfoo&lt;/code&gt; 형식의 항목은 라이브러리 &lt;code&gt;foo&lt;/code&gt; 를 지정하며 사용하는 컴파일러 종류에 따라 철자가 다르게 입력 될 수 있습니다. GCC를 사용하고 있다면 &lt;code&gt;libfoo.a&lt;/code&gt; 로 변환 되지만 다른 win32 컴파일러에서는 &lt;code&gt;foo.lib&lt;/code&gt; 가 됩니다. 번역 된 이름으로 파일을 찾지 못하면 GCC 또는 다른 win32 컴파일러의 사용 여부에 따라 &lt;code&gt;foo.a&lt;/code&gt; 또는 &lt;code&gt;libfoo.lib&lt;/code&gt; 를 사용하여 파일을 찾기 위해 한 번 더 시도 합니다.</target>
        </trans-unit>
        <trans-unit id="b955ec169e3cf404a025241c85cc35d91ed6e518" translate="yes" xml:space="preserve">
          <source>An entry of the form &lt;code&gt;-lfoo&lt;/code&gt; specifies the library &lt;code&gt;foo&lt;/code&gt;, which may be spelled differently depending on what kind of compiler you are using. If you are using GCC, it gets translated to &lt;code&gt;libfoo.a&lt;/code&gt;, but for other win32 compilers, it becomes &lt;code&gt;foo.lib&lt;/code&gt;. If no files are found by those translated names, one more attempt is made to find them using either &lt;code&gt;foo.a&lt;/code&gt; or &lt;code&gt;libfoo.lib&lt;/code&gt;, depending on whether GCC or some other win32 compiler is being used, respectively.</source>
          <target state="translated">&lt;code&gt;-lfoo&lt;/code&gt; 형식의 항목 은 사용중인 컴파일러의 종류에 따라 철자가 다를 수있는 라이브러리 &lt;code&gt;foo&lt;/code&gt; 를 지정합니다 . GCC를 사용하는 경우 &lt;code&gt;libfoo.a&lt;/code&gt; 로 변환 되지만 다른 win32 컴파일러의 경우 &lt;code&gt;foo.lib&lt;/code&gt; 가 됩니다. 번역 된 이름으로 파일을 찾을 수없는 경우 GCC 또는 다른 win32 컴파일러가 각각 사용되는지 여부에 따라 &lt;code&gt;foo.a&lt;/code&gt; 또는 &lt;code&gt;libfoo.lib&lt;/code&gt; 를 사용하여 파일을 찾으려고 한 번 더 시도 합니다.</target>
        </trans-unit>
        <trans-unit id="542b3550714b3908eea8d8c13ea7256018c9e930" translate="yes" xml:space="preserve">
          <source>An entry that matches &lt;code&gt;/:nodefault/i&lt;/code&gt; disables the appending of default libraries found in &lt;code&gt;$Config{perllibs}&lt;/code&gt; (this should be only needed very rarely).</source>
          <target state="translated">&lt;code&gt;/:nodefault/i&lt;/code&gt; 와 일치하는 항목 은 &lt;code&gt;$Config{perllibs}&lt;/code&gt; 있는 기본 라이브러리 추가를 비활성화합니다 (이것은 매우 드물게 필요합니다).</target>
        </trans-unit>
        <trans-unit id="54596c2d41917bea50cab186303f4d27d58e3783" translate="yes" xml:space="preserve">
          <source>An entry that matches &lt;code&gt;/:nosearch/i&lt;/code&gt; disables all searching for the libraries specified after it. Translation of &lt;code&gt;-Lfoo&lt;/code&gt; and &lt;code&gt;-lfoo&lt;/code&gt; still happens as appropriate (depending on compiler being used, as reflected by &lt;code&gt;$Config{cc}&lt;/code&gt; ), but the entries are not verified to be valid files or directories.</source>
          <target state="translated">&lt;code&gt;/:nosearch/i&lt;/code&gt; 와 일치하는 항목은 그 뒤에 지정된 라이브러리에 대한 모든 검색을 비활성화합니다. &lt;code&gt;-Lfoo&lt;/code&gt; 및 &lt;code&gt;-lfoo&lt;/code&gt; 의 변환은 여전히 적절하게 수행되지만 ( &lt;code&gt;$Config{cc}&lt;/code&gt; 의해 반영된대로 사용중인 컴파일러에 따라 ) 항목이 유효한 파일 또는 디렉토리인지 확인되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0f36c83e40eae68ee067d041dd5eaac816d400ba" translate="yes" xml:space="preserve">
          <source>An entry that matches &lt;code&gt;/:nosearch/i&lt;/code&gt; disables all searching for the libraries specified after it. Translation of &lt;code&gt;-Lfoo&lt;/code&gt; and &lt;code&gt;-lfoo&lt;/code&gt; still happens as appropriate (depending on compiler being used, as reflected by &lt;code&gt;$Config{cc}&lt;/code&gt;), but the entries are not verified to be valid files or directories.</source>
          <target state="translated">&lt;code&gt;/:nosearch/i&lt;/code&gt; 와 일치하는 항목은 그 뒤에 지정된 라이브러리에 대한 모든 검색을 비활성화합니다. &lt;code&gt;-Lfoo&lt;/code&gt; 및 &lt;code&gt;-lfoo&lt;/code&gt; 의 변환은 여전히 적절하게 발생하지만 (사용중인 컴파일러에 따라 &lt;code&gt;$Config{cc}&lt;/code&gt; 반영됨 ) 항목이 유효한 파일 또는 디렉토리인지 확인되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="341641ec8dfdfc884739074e9d2b0f226cf6a1e7" translate="yes" xml:space="preserve">
          <source>An entry that matches &lt;code&gt;/:search/i&lt;/code&gt; reenables searching for the libraries specified after it. You can put it at the end to enable searching for default libraries specified by &lt;code&gt;$Config{perllibs}&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;/:search/i&lt;/code&gt; 와 일치하는 항목은 그 뒤에 지정된 라이브러리를 검색 할 수있게합니다. &lt;code&gt;$Config{perllibs}&lt;/code&gt; 지정된 기본 라이브러리를 검색 할 수 있도록 마지막에 둘 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="58b3df12b9c4c1391c5d6a764ee07751d9f03ea6" translate="yes" xml:space="preserve">
          <source>An entry that matches &lt;code&gt;/:search/i&lt;/code&gt; reenables searching for the libraries specified after it. You can put it at the end to enable searching for default libraries specified by &lt;code&gt;$Config{perllibs}&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;/:search/i&lt;/code&gt; 와 일치하는 항목은 그 뒤에 지정된 라이브러리 검색을 다시 활성화합니다. &lt;code&gt;$Config{perllibs}&lt;/code&gt; 지정한 기본 라이브러리를 검색 할 수 있도록 끝에 넣을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="764e7bd0665e9fa3ca103f1f3c69a2b0a336ccc2" translate="yes" xml:space="preserve">
          <source>An enum of flags for Perl types. These are found in the file</source>
          <target state="translated">Perl 유형에 대한 플래그 열거. 파일에서 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="eac77ebce5cb434a4347aeb52157baf13e86e68f" translate="yes" xml:space="preserve">
          <source>An enum of flags for Perl types. These are found in the file &lt;b&gt;sv.h&lt;/b&gt; in the &lt;code&gt;svtype&lt;/code&gt; enum. Test these flags with the &lt;code&gt;SvTYPE&lt;/code&gt; macro.</source>
          <target state="translated">Perl 타입의 플래그의 열거입니다. 이러한 파일에서 발견되는 &lt;b&gt;sv.h&lt;/b&gt; 에서 &lt;code&gt;svtype&lt;/code&gt; 의 열거. &lt;code&gt;SvTYPE&lt;/code&gt; 매크로를 사용 하여이 플래그를 테스트하십시오 .</target>
        </trans-unit>
        <trans-unit id="a352e1f402bd0b0688137a6b2ecc0dfb6c13f18b" translate="yes" xml:space="preserve">
          <source>An enum value. Used to transfer an enum component from C. There is no reason to pass an enum value to C since it is stored as an IV inside perl.</source>
          <target state="translated">열거 형 값입니다. C에서 열거 형 구성 요소를 전송하는 데 사용됩니다. 열거 형 값을 C로 전달할 이유가 없습니다. perl 내부에 IV로 저장되어 있기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="22fd110d7c238cdd41592c0a602172ada41cc36a" translate="yes" xml:space="preserve">
          <source>An environment variable is used, rather than parallel make itself, because &lt;a href=&quot;TAP::Harness&quot;&gt;TAP::Harness&lt;/a&gt; needs to be able to schedule individual non-conflicting test scripts itself, and there is no standard interface to &lt;code&gt;make&lt;/code&gt; utilities to interact with their job schedulers.</source>
          <target state="translated">&lt;a href=&quot;TAP::Harness&quot;&gt;TAP :: Harness&lt;/a&gt; 는 충돌하지 않는 개별 테스트 스크립트 자체를 예약 할 수 있어야 하고 작업 스케줄러와 상호 작용할 유틸리티를 &lt;code&gt;make&lt;/code&gt; 표준 인터페이스가 없기 때문에 병렬 작성 자체가 아닌 환경 변수가 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="85b348ed9fe24e3e5ab044fd0ea208d3866c0f50" translate="yes" xml:space="preserve">
          <source>An environment variable is used, rather than parallel make itself, because &lt;a href=&quot;tap/harness&quot;&gt;TAP::Harness&lt;/a&gt; needs to be able to schedule individual non-conflicting test scripts itself, and there is no standard interface to &lt;code&gt;make&lt;/code&gt; utilities to interact with their job schedulers.</source>
          <target state="translated">&lt;a href=&quot;tap/harness&quot;&gt;TAP :: Harness&lt;/a&gt; 는 개별 비 충돌 테스트 스크립트 자체를 예약 할 수 있어야 &lt;code&gt;make&lt;/code&gt; 유틸리티가 작업 스케줄러와 상호 작용할 수 있도록하는 표준 인터페이스가 없기 때문에 병렬 변수 대신 환경 변수가 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="066862fe86f40b5704d122b8bfa39f1462669702" translate="yes" xml:space="preserve">
          <source>An error has occurred (for &lt;code&gt;PerlIO_error()&lt;/code&gt; ).</source>
          <target state="translated">오류가 발생했습니다 ( &lt;code&gt;PerlIO_error()&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="3d508ac8c71c775f43142d23e442e2000fbf79e9" translate="yes" xml:space="preserve">
          <source>An error has occurred (for &lt;code&gt;PerlIO_error()&lt;/code&gt;).</source>
          <target state="translated">오류가 발생했습니다 ( &lt;code&gt;PerlIO_error()&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="bf25473c20a4c33f096f0b4023a99e2a049e0b27" translate="yes" xml:space="preserve">
          <source>An essential part of any good development process is appropriate error handling with appropriately informative messages, however there exists a school of thought which suggests that log files should be</source>
          <target state="translated">올바른 개발 프로세스의 필수 부분은 적절한 정보를 제공하는 메시지로 오류를 처리하는 것이지만 로그 파일이 있어야한다고 제안하는 학교가 있습니다.</target>
        </trans-unit>
        <trans-unit id="66bdaa16d0763f3a76de0b4a13d35f1b3d80f29a" translate="yes" xml:space="preserve">
          <source>An even stranger template code is &lt;code&gt;%&lt;/code&gt; &amp;lt;</source>
          <target state="translated">심지어 낯선 템플릿 코드는 &lt;code&gt;%&lt;/code&gt; &amp;lt;</target>
        </trans-unit>
        <trans-unit id="c948915c37e1832c4cdb4ea5562b06199c7d0645" translate="yes" xml:space="preserve">
          <source>An even stranger template code is &lt;code&gt;%&lt;/code&gt;&amp;lt;</source>
          <target state="translated">더 낯선 템플릿 코드는 &lt;code&gt;%&lt;/code&gt; &amp;lt;</target>
        </trans-unit>
        <trans-unit id="8a5463243357a8ee13bfd32810dc057038bf9e07" translate="yes" xml:space="preserve">
          <source>An event that causes a &lt;b&gt;handler&lt;/b&gt; to be run.</source>
          <target state="translated">&lt;b&gt;핸들러&lt;/b&gt; 를 실행 시키는 이벤트입니다 .</target>
        </trans-unit>
        <trans-unit id="aa855332f899b198338c3e15641312b3dfa643e8" translate="yes" xml:space="preserve">
          <source>An example conversion function for a typemapped struct &lt;code&gt;foo_t *&lt;/code&gt; might be:</source>
          <target state="translated">타입 맵 된 구조체 &lt;code&gt;foo_t *&lt;/code&gt; 에 대한 변환 함수의 예 는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ec7aaa34ffb73c97f6ed68693695810184b33f37" translate="yes" xml:space="preserve">
          <source>An example disabling Nagle's algorithm on a socket:</source>
          <target state="translated">소켓에서 Nagle 알고리즘을 비활성화하는 예 :</target>
        </trans-unit>
        <trans-unit id="370a61094a87b707b90886b80eccf424717c5430" translate="yes" xml:space="preserve">
          <source>An example for Russian and some languages using the Cyrillic script:</source>
          <target state="translated">키릴 문자를 사용하는 러시아어 및 일부 언어의 예 :</target>
        </trans-unit>
        <trans-unit id="62a8d925afd0ed802ddeaf7e7056d235e6263d4e" translate="yes" xml:space="preserve">
          <source>An example may make this clearer:</source>
          <target state="translated">예를 들어이를 더 명확하게 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="562686eabf6589e6760dcb870fbc2918a4b18229" translate="yes" xml:space="preserve">
          <source>An example of all of the phases Perl code can see:</source>
          <target state="translated">Perl 코드의 모든 단계의 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b3f8fac7e809f312cdc7e6d944996bb2ded1f5bf" translate="yes" xml:space="preserve">
          <source>An example of how this is used is the &lt;a href=&quot;Test2::Formatter::TAP&quot;&gt;Test2::Formatter::TAP&lt;/a&gt; formatter. For unbuffered subtests the events are rendered as they are generated. At the end of the subtest, the final subtest event is rendered, but the &lt;code&gt;subevents&lt;/code&gt; attribute is ignored. For buffered subtests the opposite occurs, the events are NOT rendered as they are generated, instead the &lt;code&gt;subevents&lt;/code&gt; attribute is used to render them all at once. This is useful when running subtests tests in parallel, since without it the output from subtests would be interleaved together.</source>
          <target state="translated">이것이 사용되는 방법의 예는 &lt;a href=&quot;Test2::Formatter::TAP&quot;&gt;Test2 :: Formatter :: TAP&lt;/a&gt; 포맷터입니다. 버퍼링되지 않은 하위 테스트의 경우 이벤트가 생성 될 때 렌더링됩니다. 하위 검사의 끝에서, 마지막 하위 검사 이벤트가 렌더링되지만 &lt;code&gt;subevents&lt;/code&gt; 의 속성은 무시됩니다. 버퍼링 된 하위 테스트의 경우 반대가 발생하고 이벤트가 생성 될 때 렌더링되지 않고 대신 하위 &lt;code&gt;subevents&lt;/code&gt; 속성을 사용하여 한 번에 모두 렌더링합니다. 하위 테스트가 없으면 하위 테스트의 출력이 함께 인터리브되므로 하위 테스트 테스트를 병렬로 실행할 때 유용합니다.</target>
        </trans-unit>
        <trans-unit id="5242beac10407637f4a4b464517825d71718f4a4" translate="yes" xml:space="preserve">
          <source>An example of how this might be used is as follows:</source>
          <target state="translated">이것을 사용하는 방법의 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5a34b3fb3e9dbd7f514687e325a9fcbdaa8609fe" translate="yes" xml:space="preserve">
          <source>An example of this is</source>
          <target state="translated">이것의 예는</target>
        </trans-unit>
        <trans-unit id="af46ea4947cfe8e14d48ae32223fb001ec7bc498" translate="yes" xml:space="preserve">
          <source>An example of using Name property wildcards is</source>
          <target state="translated">이름 속성 와일드 카드를 사용하는 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ab9dc32ca31441503bc05feea6fc9cf1b0dfb98e" translate="yes" xml:space="preserve">
          <source>An example output might be:</source>
          <target state="translated">출력 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d132f664732cae183fc32adf49e25fe3aca9db69" translate="yes" xml:space="preserve">
          <source>An example taken from an article posted to comp.lang.perl.misc</source>
          <target state="translated">comp.lang.perl.misc에 게시 된 기사에서 발췌 한 예</target>
        </trans-unit>
        <trans-unit id="516a8fafa09adceb915093c484c5d89d031db306" translate="yes" xml:space="preserve">
          <source>An example usage looks like:</source>
          <target state="translated">사용 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f481ad49809e7c27b79d2e6d830283b22c04c1f7" translate="yes" xml:space="preserve">
          <source>An example:</source>
          <target state="translated">예를 들면 :</target>
        </trans-unit>
        <trans-unit id="b3e01d95d4f7169aa36a737a1211243d324cf5ef" translate="yes" xml:space="preserve">
          <source>An exception</source>
          <target state="translated">예외</target>
        </trans-unit>
        <trans-unit id="af317c13cfaee4d2548fba4cee59592a6612afcd" translate="yes" xml:space="preserve">
          <source>An exception event will display to STDERR, and will prevent the overall test file from passing.</source>
          <target state="translated">예외 이벤트가 STDERR에 표시되고 전체 테스트 파일이 통과하지 못하게합니다.</target>
        </trans-unit>
        <trans-unit id="66ab19b971476be687f1585d2d4d367fb367ec27" translate="yes" xml:space="preserve">
          <source>An exception is considered to match a string if:</source>
          <target state="translated">다음과 같은 경우 예외는 문자열과 일치하는 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="441facb85290f4d6c3e35bab01158ccc81039064" translate="yes" xml:space="preserve">
          <source>An exception to the above rule is that &lt;code&gt;\N{U+&lt;i&gt;hex number&lt;/i&gt;}&lt;/code&gt; is always interpreted as a Unicode code point, so that &lt;code&gt;\N{U+0050}&lt;/code&gt; is &lt;code&gt;&quot;P&quot;&lt;/code&gt; even on EBCDIC platforms.</source>
          <target state="translated">위의 규칙에 대한 예외는 &lt;code&gt;\N{U+&lt;i&gt;hex number&lt;/i&gt;}&lt;/code&gt; 는 항상 유니 코드 코드 포인트로 해석되므로 EBCDIC 플랫폼에서도 &lt;code&gt;\N{U+0050}&lt;/code&gt; 이 &lt;code&gt;&quot;P&quot;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="eb08b0a2e1d46bb5d472e490ea7b28d5dd9e956d" translate="yes" xml:space="preserve">
          <source>An exception to this is that you may assign to &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; in a list. This is useful for throwing away some of the return values of a function:</source>
          <target state="translated">이에 대한 예외 는 목록에서 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 를 할당 할 수 있다는 것 입니다. 이것은 함수의 반환 값 중 일부를 버릴 때 유용합니다.</target>
        </trans-unit>
        <trans-unit id="b907b876869fb91f8d35b06170f79ee9f948ffa2" translate="yes" xml:space="preserve">
          <source>An exception to this is that you may assign to &lt;code&gt;undef&lt;/code&gt; in a list. This is useful for throwing away some of the return values of a function:</source>
          <target state="translated">이에 대한 예외 는 목록에서 &lt;code&gt;undef&lt;/code&gt; 에 할당 할 수 있다는 것 입니다. 이것은 함수의 반환 값 중 일부를 버리는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="6d1bf7c1ca3df304818b1a482b2ae19817ae3aee" translate="yes" xml:space="preserve">
          <source>An exception will be raised if &lt;code&gt;verify_SSL&lt;/code&gt; is true and no CA certificate file is available.</source>
          <target state="translated">&lt;code&gt;verify_SSL&lt;/code&gt; 이 true이고 사용 가능한 CA 인증서 파일이 없으면 예외가 발생 합니다.</target>
        </trans-unit>
        <trans-unit id="0fc1d98cce4c241de46d33d676c33734f841fc89" translate="yes" xml:space="preserve">
          <source>An executable compiled on a PA-RISC 2.0 platform will not execute on a PA-RISC 1.1 platform, even if they are running the same version of HP-UX. If you are building Perl on a PA-RISC 2.0 platform and want that Perl to also run on a PA-RISC 1.1, the compiler flags +DAportable and +DS32 should be used.</source>
          <target state="translated">PA-RISC 2.0 플랫폼에서 컴파일 된 실행 파일은 동일한 HP-UX 버전을 실행하더라도 PA-RISC 1.1 플랫폼에서 실행되지 않습니다. PA-RISC 2.0 플랫폼에서 Perl을 빌드하고 있고 Perl이 PA-RISC 1.1에서도 실행되도록하려면 컴파일러 플래그 + DAportable 및 + DS32를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="089b36ce65cddba1918a51ae6a46d8831ee39956" translate="yes" xml:space="preserve">
          <source>An exit status of 0 implies &quot;success&quot;. For example, &lt;b&gt;diff(1)&lt;/b&gt; exits with a status of 0 if the two files have the same contents.</source>
          <target state="translated">종료 상태 0은 &quot;성공&quot;을 의미합니다. 예를 들어, 두 파일의 내용이 동일한 경우 &lt;b&gt;diff (1)&lt;/b&gt; 은 상태 0으로 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="bbd4429d08a5ebe605cc6bfbbfa2eaacec53a0f9" translate="yes" xml:space="preserve">
          <source>An exit status of 1 implies possibly abnormal, but non-defective, program termination. For example, &lt;b&gt;grep(1)&lt;/b&gt; exits with a status of 1 if it did</source>
          <target state="translated">종료 상태 1은 비정상이지만 결함이없는 프로그램 종료를 의미합니다. 예를 들어, &lt;b&gt;grep (1)&lt;/b&gt; 은 1 인 상태에서 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="e246081e6327d64a230056100ee6a6d47e29ef00" translate="yes" xml:space="preserve">
          <source>An exit status of 2 or more implies a fatal error. For example, &lt;b&gt;ls(1)&lt;/b&gt; exits with a status of 2 if you specify an illegal (unknown) option on the command line.</source>
          <target state="translated">종료 상태가 2 이상이면 치명적인 오류가 발생합니다. 예를 들어, 명령 줄에 잘못된 (알 수없는) 옵션을 지정하면 &lt;b&gt;ls (1)&lt;/b&gt; 은 상태 2로 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="1ff1cef51589fc8dbb6faba666f12b831fe6b899" translate="yes" xml:space="preserve">
          <source>An experimental pseudolayer that removes the topmost layer. Use with the same care as is reserved for nitroglycerine.</source>
          <target state="translated">최상층을 제거하는 실험적 의사 층. 니트로 글리세린과 동일한주의를 기울여 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="846db25d0ecc19ed2c5fd44070c00f6f8a9c0772" translate="yes" xml:space="preserve">
          <source>An explanation of VMS file specs can be found at &lt;a href=&quot;http://h71000.www7.hp.com/doc/731FINAL/4506/4506pro_014.html#apps_locating_naming_files&quot;&gt;http://h71000.www7.hp.com/doc/731FINAL/4506/4506pro_014.html#apps_locating_naming_files&lt;/a&gt;.</source>
          <target state="translated">VMS 파일 사양에 대한 설명은 &lt;a href=&quot;http://h71000.www7.hp.com/doc/731FINAL/4506/4506pro_014.html#apps_locating_naming_files&quot;&gt;http://h71000.www7.hp.com/doc/731FINAL/4506/4506pro_014.html#apps_locating_naming_files&lt;/a&gt; 에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b85172cf7a158b615a4c1e4c610cfa79b7fa2c51" translate="yes" xml:space="preserve">
          <source>An explicit format parameter index, such as &lt;code&gt;2$&lt;/code&gt;. By default sprintf will format the next unused argument in the list, but this allows you to take the arguments out of order:</source>
          <target state="translated">명시 적 형식 매개 변수 지수 등 &lt;code&gt;2$&lt;/code&gt; . 기본적으로 sprintf는 목록에서 사용되지 않은 다음 인수의 형식을 지정하지만 인수를 순서에 맞지 않게 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="52691b6df07cdbefee8cb7a498d3dc93b2c8dd90" translate="yes" xml:space="preserve">
          <source>An exploration of some of the issues facing Perl programmers on EBCDIC based computers.</source>
          <target state="translated">EBCDIC 기반 컴퓨터에서 Perl 프로그래머가 직면 한 일부 문제에 대한 탐구.</target>
        </trans-unit>
        <trans-unit id="372a1e4ea54335151ba75e3cd2ea53899b760f24" translate="yes" xml:space="preserve">
          <source>An expression which, when its value changes, causes a breakpoint in the Perl debugger.</source>
          <target state="translated">값이 변경 될 때 Perl 디버거에서 중단 점을 유발하는 표현식입니다.</target>
        </trans-unit>
        <trans-unit id="d16dfa398c1840b695b36040deeba3088ca6a02a" translate="yes" xml:space="preserve">
          <source>An extension is a way of calling compiled C code from Perl. Reading &lt;a href=&quot;perlxstut&quot;&gt;perlxstut&lt;/a&gt; is a good place to learn more about extensions.</source>
          <target state="translated">확장은 Perl에서 컴파일 된 C 코드를 호출하는 방법입니다. &lt;a href=&quot;perlxstut&quot;&gt;perlxstut를&lt;/a&gt; 읽는 것은 확장에 대해 더 배울 수있는 좋은 장소입니다.</target>
        </trans-unit>
        <trans-unit id="9164cae08d37bdf18edf58e540f0e6c559fb27cc" translate="yes" xml:space="preserve">
          <source>An extension that is built with the above steps is ready to use on systems supporting dynamic loading. On systems that do not support dynamic loading, any newly created extension has to be linked together with the available resources. MakeMaker supports the linking process by creating appropriate targets in the Makefile whenever an extension is built. You can invoke the corresponding section of the makefile with</source>
          <target state="translated">위 단계로 빌드 된 확장은 동적로드를 지원하는 시스템에서 사용할 수 있습니다. 동적로드를 지원하지 않는 시스템에서는 새로 작성된 확장을 사용 가능한 자원과 함께 링크해야합니다. MakeMaker는 확장 프로그램이 빌드 될 때마다 Makefile에 적절한 대상을 만들어 연결 프로세스를 지원합니다. 다음과 같이 makefile의 해당 섹션을 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="62fe96c831d4e5434f2a2484c5da0d22ce2c69d7" translate="yes" xml:space="preserve">
          <source>An external &lt;b&gt;subroutine&lt;/b&gt; defined in &lt;b&gt;XS&lt;/b&gt;.</source>
          <target state="translated">&lt;b&gt;XS에&lt;/b&gt; 정의 된 외부 &lt;b&gt;서브 루틴&lt;/b&gt; .&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="7422ed8b7617c92670f322946ad1f9ad0f35ee57" translate="yes" xml:space="preserve">
          <source>An extra field consists of zero or more subfields. Each subfield consists of a two byte header followed by the subfield data.</source>
          <target state="translated">추가 필드는 0 개 이상의 서브 필드로 구성됩니다. 각 서브 필드는 2 바이트 헤더와 서브 필드 데이터로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="18c0e84026650565acf5b36d62e6093af36330f9" translate="yes" xml:space="preserve">
          <source>An extraordinarily exported, expeditiously excellent, expressly eXternal Subroutine, executed in existing C or C++ or in an exciting extension language called (exasperatingly) XS.</source>
          <target state="translated">기존의 C 또는 C ++ 또는 XS (Experperatingly)라는 확장 언어로 실행되는 매우 뛰어난 익스포트, 매우 우수한 eXternal 서브 루틴.</target>
        </trans-unit>
        <trans-unit id="5ae0ec1c420230a4b9a6f6f5a35cd2c66a33eeb2" translate="yes" xml:space="preserve">
          <source>An extremely lightweight &lt;b&gt;DB_File&lt;/b&gt; wrapper that simply flocks a lockfile before tie-ing the database and drops the lock after the untie. Allows one to use the same lockfile for multiple databases to avoid deadlock problems, if desired. Use for databases where updates are reads are quick and simple flock locking semantics are enough.</source>
          <target state="translated">데이터베이스를 연결하기 전에 잠금 파일을 간단하게 정리하고 연결 해제 후 잠금을 해제하는 초경량 &lt;b&gt;DB_File&lt;/b&gt; 래퍼입니다. 원하는 경우 교착 상태 문제점을 피하기 위해 여러 데이터베이스에 동일한 잠금 파일을 사용할 수 있습니다. 업데이트가 읽기 쉽고 빠르고 간단한 잠금 잠금 시맨틱이있는 데이터베이스에 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="6c7aaf1b9af23250eb8ede6f4c91ca5fbe3ad083" translate="yes" xml:space="preserve">
          <source>An identifier (not necessarily related to the real name of a file) that represents a particular instance of opening a file, until you close it. If you&amp;rsquo;re going to open and close several different files in succession, it&amp;rsquo;s fine to open each of them with the same filehandle, so you don&amp;rsquo;t have to write out separate code to process each file.</source>
          <target state="translated">파일을 닫을 때까지 파일을 여는 특정 인스턴스를 나타내는 식별자 (파일의 실제 이름과 반드시 ​​관련된 것은 아님) 여러 개의 다른 파일을 연속으로 열고 닫을 경우 동일한 파일 핸들로 각 파일을 여는 것이 좋습니다. 따라서 각 파일을 처리하기 위해 별도의 코드를 작성할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="2ca4f6f5a018c6a780d2f920105ee21e87c135e6" translate="yes" xml:space="preserve">
          <source>An immediate filter allows you to specify the filter code to be used at the point where the filter is applied to a dbm. In this mode the Filter_*_Push methods expects to receive exactly two parameters.</source>
          <target state="translated">즉시 필터를 사용하면 필터가 dbm에 적용되는 지점에서 사용할 필터 코드를 지정할 수 있습니다. 이 모드에서 Filter _ * _ Push 메소드는 정확히 두 개의 매개 변수를 수신합니다.</target>
        </trans-unit>
        <trans-unit id="854d43de9440512807e67ff18407c545a932b325" translate="yes" xml:space="preserve">
          <source>An imperfect standard</source>
          <target state="translated">불완전한 표준</target>
        </trans-unit>
        <trans-unit id="20af74febdbf871248a6b2f4c417ca9aaffe6f3f" translate="yes" xml:space="preserve">
          <source>An important property of the digest algorithms is that the digest is</source>
          <target state="translated">다이제스트 알고리즘의 중요한 속성은 다이제스트가</target>
        </trans-unit>
        <trans-unit id="5358f4c4e85e881620623ef0fa458c651c57bf92" translate="yes" xml:space="preserve">
          <source>An incremental option is specified with a plus &lt;code&gt;+&lt;/code&gt; after the option name:</source>
          <target state="translated">옵션 이름 뒤에 &lt;code&gt;+&lt;/code&gt; 를 사용하여 증분 옵션을 지정합니다 .</target>
        </trans-unit>
        <trans-unit id="eff14445a69700081714d1ed9ff369fb4f2bc735" translate="yes" xml:space="preserve">
          <source>An index of character names is available on-line from the Unicode Consortium, &lt;a href=&quot;http://www.unicode.org/charts/charindex.html&quot;&gt;http://www.unicode.org/charts/charindex.html&lt;/a&gt;; explanatory material with links to other resources at &lt;a href=&quot;http://www.unicode.org/standard/where&quot;&gt;http://www.unicode.org/standard/where&lt;/a&gt;.</source>
          <target state="translated">문자 이름 색인은 유니 코드 컨소시엄 ( &lt;a href=&quot;http://www.unicode.org/charts/charindex.html&quot;&gt;http://www.unicode.org/charts/charindex.html)&lt;/a&gt; 에서 온라인으로 제공됩니다 . &lt;a href=&quot;http://www.unicode.org/standard/where&quot;&gt;http://www.unicode.org/standard/where의&lt;/a&gt; 다른 자료에 대한 링크가 포함 된 설명 자료 .</target>
        </trans-unit>
        <trans-unit id="00b6943f411e2de4ec124878b41ea6334f76e3b4" translate="yes" xml:space="preserve">
          <source>An index of character names is available on-line from the Unicode Consortium, &lt;a href=&quot;https://www.unicode.org/charts/charindex.html&quot;&gt;https://www.unicode.org/charts/charindex.html&lt;/a&gt;; explanatory material with links to other resources at &lt;a href=&quot;https://www.unicode.org/standard/where&quot;&gt;https://www.unicode.org/standard/where&lt;/a&gt;.</source>
          <target state="translated">문자 이름 색인은 Unicode Consortium ( &lt;a href=&quot;https://www.unicode.org/charts/charindex.html&quot;&gt;https://www.unicode.org/charts/charindex.html)&lt;/a&gt; 에서 온라인으로 제공됩니다 . &lt;a href=&quot;https://www.unicode.org/standard/where&quot;&gt;https://www.unicode.org/standard/where&lt;/a&gt; 에서 다른 리소스에 대한 링크가 포함 된 설명 자료 .</target>
        </trans-unit>
        <trans-unit id="ef770a25a15f3c0ce63ccdcd24649733fd026bd0" translate="yes" xml:space="preserve">
          <source>An indirect filehandle is the use of something other than a symbol in a place that a filehandle is expected. Here are ways to get indirect filehandles:</source>
          <target state="translated">간접 파일 핸들은 파일 핸들이 예상되는 장소에서 심볼 이외의 다른 것을 사용하는 것입니다. 간접 파일 핸들링을 얻는 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="858451a2efc846133fcc1f6e934e6a48b50f2e8c" translate="yes" xml:space="preserve">
          <source>An informative hash, accessible via &lt;code&gt;details()&lt;/code&gt; , is stored for each test you perform. So memory usage will scale linearly with each test run. Although this is not a problem for most test suites, it can become an issue if you do large (hundred thousands to million) combinatorics tests in the same run.</source>
          <target state="translated">&lt;code&gt;details()&lt;/code&gt; 를 통해 액세스 할 수있는 유익한 해시 가 수행하는 각 테스트마다 저장됩니다. 따라서 메모리 사용량은 각 테스트 실행마다 선형으로 확장됩니다. 이것은 대부분의 테스트 스위트에서 문제가되지는 않지만 동일한 실행에서 대규모 (수백에서 수백만)의 조합 테스트를 수행하면 문제가 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="701384a60361f136947eccd77eb6f91598d0f6e9" translate="yes" xml:space="preserve">
          <source>An informative hash, accessible via &lt;code&gt;details()&lt;/code&gt;, is stored for each test you perform. So memory usage will scale linearly with each test run. Although this is not a problem for most test suites, it can become an issue if you do large (hundred thousands to million) combinatorics tests in the same run.</source>
          <target state="translated">&lt;code&gt;details()&lt;/code&gt; 를 통해 액세스 할 수있는 유익한 해시 는 수행하는 각 테스트에 대해 저장됩니다. 따라서 메모리 사용량은 각 테스트 실행에 따라 선형 적으로 확장됩니다. 이것은 대부분의 테스트 스위트에서 문제가되지 않지만 같은 실행에서 대규모 (십만에서 백만)의 조합 테스트를 수행하면 문제가 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a9e6a3af85651e42bfa391fe495fc3734c02ae8b" translate="yes" xml:space="preserve">
          <source>An input file that uses source filtering probably won't be deparsed into runnable code, because it will still include the &lt;b&gt;use&lt;/b&gt; declaration for the source filtering module, even though the code that is produced is already ordinary Perl which shouldn't be filtered again.</source>
          <target state="translated">소스 필터링을 사용하는 입력 파일은 실행 가능한 코드로 파싱되지 않을 것 입니다. 생성 된 코드가 이미 일반 펄이더라도 다시 필터링하지 않아도 소스 필터링 모듈에 대한 &lt;b&gt;사용&lt;/b&gt; 선언이 포함되기 때문에 실행 가능한 코드로 파싱되지 않을 것입니다 .</target>
        </trans-unit>
        <trans-unit id="aa16b38820f7deb5595d1bc31e5c4264a804f15b" translate="yes" xml:space="preserve">
          <source>An installation can choose to allow any of these to be matched by downloading the Unicode database from &lt;a href=&quot;http://www.unicode.org/Public/&quot;&gt;http://www.unicode.org/Public/&lt;/a&gt; to &lt;code&gt;$Config{privlib}&lt;/code&gt; /</source>
          <target state="translated">설치시 유니 코드 데이터베이스를 &lt;a href=&quot;http://www.unicode.org/Public/&quot;&gt;http://www.unicode.org/Public/&lt;/a&gt; 에서 &lt;code&gt;$Config{privlib}&lt;/code&gt; / 로 다운로드하여 이들 중 하나를 일치시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="41c8e8c55ba26c070500d10138a4327fcb1ea456" translate="yes" xml:space="preserve">
          <source>An installation can choose to allow any of these to be matched by downloading the Unicode database from &lt;a href=&quot;http://www.unicode.org/Public/&quot;&gt;http://www.unicode.org/Public/&lt;/a&gt; to &lt;code&gt;$Config{privlib}&lt;/code&gt;/</source>
          <target state="translated">설치시 &lt;a href=&quot;http://www.unicode.org/Public/&quot;&gt;http://www.unicode.org/Public/&lt;/a&gt; 에서 &lt;code&gt;$Config{privlib}&lt;/code&gt; /로 유니 코드 데이터베이스를 다운로드하여 이러한 항목이 일치하도록 선택할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a014f84e1453ef226d46effcd0a9cbfe569a9f81" translate="yes" xml:space="preserve">
          <source>An instance of a running program. Under multitasking systems like Unix, two or more separate processes could be running the same program independently at the same time&amp;mdash;in fact, the &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork&lt;/a&gt;&lt;/code&gt; function is designed to bring about this happy state of affairs. Under other operating systems, processes are sometimes called &amp;ldquo;threads&amp;rdquo;, &amp;ldquo;tasks&amp;rdquo;, or &amp;ldquo;jobs&amp;rdquo;, often with slight nuances in meaning.</source>
          <target state="translated">실행중인 프로그램의 인스턴스 Unix와 같은 멀티 태스킹 시스템에서 두 개 이상의 개별 프로세스가 동일한 프로그램을 동시에 독립적으로 실행할 수 있습니다. 실제로 &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork&lt;/a&gt;&lt;/code&gt; 기능은이 행복한 상황을 가져 오도록 설계되었습니다. 다른 운영 체제에서는 프로세스를 종종 &quot;스레드&quot;, &quot;작업&quot;또는 &quot;작업&quot;이라고하며 약간의 미묘한 차이가 있습니다.</target>
        </trans-unit>
        <trans-unit id="d7bfae97a3fa7902fae2c04baaa1f1c2a7428aa8" translate="yes" xml:space="preserve">
          <source>An instance of a running program. Under multitasking systems like Unix, two or more separate processes could be running the same program independently at the same time&amp;mdash;in fact, the &lt;code&gt;fork&lt;/code&gt; function is designed to bring about this happy state of affairs. Under other operating systems, processes are sometimes called &amp;ldquo;threads&amp;rdquo;, &amp;ldquo;tasks&amp;rdquo;, or &amp;ldquo;jobs&amp;rdquo;, often with slight nuances in meaning.</source>
          <target state="translated">실행중인 프로그램의 인스턴스입니다. Unix와 같은 멀티 태스킹 시스템에서는 두 개 이상의 개별 프로세스가 동일한 프로그램을 동시에 독립적으로 실행할 수 있습니다. 실제로 &lt;code&gt;fork&lt;/code&gt; 기능은 이러한 행복한 상태를 가져 오도록 설계되었습니다. 다른 운영 체제에서는 프로세스를 &quot;스레드&quot;, &quot;작업&quot;또는 &quot;작업&quot;이라고하며 종종 의미에 약간의 뉘앙스가 있습니다.</target>
        </trans-unit>
        <trans-unit id="0214de560f2556559c172656f6d4683531a40229" translate="yes" xml:space="preserve">
          <source>An integer divisor when you&amp;rsquo;re interested in the remainder instead of the quotient.</source>
          <target state="translated">몫 대신 나머지에 관심이있는 경우 정수 제수입니다.</target>
        </trans-unit>
        <trans-unit id="ef97a772df2ab33140914238f0dfa09aa1f2481c" translate="yes" xml:space="preserve">
          <source>An integer in the range from 0 to 1, inclusive. The smallest possible unit of information storage. An eighth of a &lt;b&gt;byte&lt;/b&gt; or of a dollar. (The term &amp;ldquo;Pieces of Eight&amp;rdquo; comes from being able to split the old Spanish dollar into 8 bits, each of which still counted for money. That&amp;rsquo;s why a 25- cent piece today is still &amp;ldquo;two bits&amp;rdquo;.)</source>
          <target state="translated">0에서 1까지의 정수입니다. 가장 작은 정보 저장 단위. &lt;b&gt;바이트&lt;/b&gt; 또는 달러 의 8 분의 1 (&amp;ldquo;여덟 조각&amp;rdquo;이라는 용어는 오래된 스페인 달러를 8 비트로 나눌 수 있으며 각각은 여전히 ​​돈으로 계산됩니다. 이것이 오늘날 25 센트짜리 조각이 여전히&amp;ldquo;2 비트&amp;rdquo;입니다.)</target>
        </trans-unit>
        <trans-unit id="487c5ee86805465c96baeca407a9f1d4e496a654" translate="yes" xml:space="preserve">
          <source>An interesting property of the 32 C0 control characters in the ASCII table is that they can &quot;literally&quot; be constructed as control characters in Perl, e.g. &lt;code&gt;(&lt;a href=&quot;functions/chr&quot;&gt;chr&lt;/a&gt;(0)&lt;/code&gt; eq &lt;code&gt;\c@&lt;/code&gt; )&amp;gt; &lt;code&gt;(&lt;a href=&quot;functions/chr&quot;&gt;chr&lt;/a&gt;(1)&lt;/code&gt; eq &lt;code&gt;\cA&lt;/code&gt; )&amp;gt;, and so on. Perl on EBCDIC platforms has been ported to take &lt;code&gt;\c@&lt;/code&gt; to &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr(0)&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;\cA&lt;/code&gt; to &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr(1)&lt;/a&gt;&lt;/code&gt;, etc. as well, but the characters that result depend on which code page you are using. The table below uses the standard acronyms for the controls. The POSIX-BC and 1047 sets are identical throughout this range and differ from the 0037 set at only one spot (21 decimal). Note that the line terminator character may be generated by &lt;code&gt;\cJ&lt;/code&gt; on ASCII platforms but by &lt;code&gt;\cU&lt;/code&gt; on 1047 or POSIX-BC platforms and cannot be generated as a &lt;code&gt;&quot;\c.letter.&quot;&lt;/code&gt; control character on 0037 platforms. Note also that &lt;code&gt;\c\&lt;/code&gt; cannot be the final element in a string or regex, as it will absorb the terminator. But &lt;code&gt;\c\&lt;i&gt;X&lt;/i&gt;&lt;/code&gt; is a &lt;code&gt;FILE
SEPARATOR&lt;/code&gt; concatenated with</source>
          <target state="translated">ASCII 테이블에서 32 개의 C0 제어 문자의 흥미로운 특성은 Perl에서 제어 문자로 &quot;문자 그대로&quot;구성 될 수 있다는 것입니다. 예 : &lt;code&gt;(&lt;a href=&quot;functions/chr&quot;&gt;chr&lt;/a&gt;(0)&lt;/code&gt; eq &lt;code&gt;\c@&lt;/code&gt; )&amp;gt; &lt;code&gt;(&lt;a href=&quot;functions/chr&quot;&gt;chr&lt;/a&gt;(1)&lt;/code&gt; eq &lt;code&gt;\cA&lt;/code&gt; )&amp;gt; , 등등. EBCDIC 플랫폼의 Perl은 &lt;code&gt;\c@&lt;/code&gt; 를 &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr(0)&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;\cA&lt;/code&gt; 를 &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr(1)&lt;/a&gt;&lt;/code&gt; 로 가져 오도록 포팅되었습니다.등이 있지만 결과 문자는 사용중인 코드 페이지에 따라 다릅니다. 아래 표는 컨트롤에 표준 약어를 사용합니다. POSIX-BC 및 1047 세트는이 범위에서 동일하며 한 지점 (십진 21 자)에서만 0037 세트와 다릅니다. 줄 끝 문자에 의해 발생 될 수 있습니다 &lt;code&gt;\cJ&lt;/code&gt; ASCII 플랫폼 만에 의해 &lt;code&gt;\cU&lt;/code&gt; 1047 또는 POSIX-BC 플랫폼에서와 같이 생성 할 수 없습니다 &lt;code&gt;&quot;\c.letter.&quot;&lt;/code&gt; 0037 플랫폼에서 제어 문자. 또한 &lt;code&gt;\c\&lt;/code&gt; 는 종결자를 흡수하므로 문자열 또는 정규식의 마지막 요소가 될 수 없습니다. 그러나 &lt;code&gt;\c\&lt;i&gt;X&lt;/i&gt;&lt;/code&gt; 는 &lt;code&gt;FILE SEPARATOR&lt;/code&gt; 와 연결되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="5ec5858c69c508303478b5682163ba9de4ba1b6f" translate="yes" xml:space="preserve">
          <source>An interesting property of the 32 C0 control characters in the ASCII table is that they can &quot;literally&quot; be constructed as control characters in Perl, e.g. &lt;code&gt;(chr(0)&lt;/code&gt; eq &lt;code&gt;\c@&lt;/code&gt;)&amp;gt; &lt;code&gt;(chr(1)&lt;/code&gt; eq &lt;code&gt;\cA&lt;/code&gt;)&amp;gt;, and so on. Perl on EBCDIC platforms has been ported to take &lt;code&gt;\c@&lt;/code&gt; to &lt;code&gt;chr(0)&lt;/code&gt; and &lt;code&gt;\cA&lt;/code&gt; to &lt;code&gt;chr(1)&lt;/code&gt;, etc. as well, but the characters that result depend on which code page you are using. The table below uses the standard acronyms for the controls. The POSIX-BC and 1047 sets are identical throughout this range and differ from the 0037 set at only one spot (21 decimal). Note that the line terminator character may be generated by &lt;code&gt;\cJ&lt;/code&gt; on ASCII platforms but by &lt;code&gt;\cU&lt;/code&gt; on 1047 or POSIX-BC platforms and cannot be generated as a &lt;code&gt;&quot;\c.letter.&quot;&lt;/code&gt; control character on 0037 platforms. Note also that &lt;code&gt;\c\&lt;/code&gt; cannot be the final element in a string or regex, as it will absorb the terminator. But &lt;code&gt;\c\&lt;i&gt;X&lt;/i&gt;&lt;/code&gt; is a &lt;code&gt;FILE SEPARATOR&lt;/code&gt; concatenated with</source>
          <target state="translated">ASCII 테이블에있는 32 개의 C0 제어 문자의 흥미로운 속성은 Perl에서 제어 문자로 &quot;문자 그대로&quot;구성 할 수 있다는 것입니다. 예 : &lt;code&gt;(chr(0)&lt;/code&gt; eq &lt;code&gt;\c@&lt;/code&gt; )&amp;gt; &lt;code&gt;(chr(1)&lt;/code&gt; eq &lt;code&gt;\cA&lt;/code&gt; )&amp;gt; , 등등. EBCDIC 플랫폼의 Perl은 &lt;code&gt;\c@&lt;/code&gt; 를 &lt;code&gt;chr(0)&lt;/code&gt; , &lt;code&gt;\cA&lt;/code&gt; 를 &lt;code&gt;chr(1)&lt;/code&gt; 등 으로 포팅 되었지만 결과 문자는 사용중인 코드 페이지에 따라 다릅니다. 아래 표는 컨트롤에 대한 표준 약어를 사용합니다. POSIX-BC 및 1047 세트는이 범위 전체에서 동일하며 한 지점 (십진수 21)에만 설정된 0037과 다릅니다. 줄 종결 문자는 &lt;code&gt;\cJ&lt;/code&gt; 의해 생성 될 수 있습니다.ASCII 플랫폼에서는 &lt;code&gt;\cU&lt;/code&gt; 이지만 1047 또는 POSIX-BC 플랫폼에서는 &lt;code&gt;&quot;\c.letter.&quot;&lt;/code&gt; 이며 &quot;\ c.letter&quot; 로 생성 할 수 없습니다 . 0037 플랫폼의 제어 문자. 참고 또한 &lt;code&gt;\c\&lt;/code&gt; 는 터미네이터를 흡수 등의 문자열이나 정규 표현식의 마지막 요소가 될 수 없습니다. 그러나 &lt;code&gt;\c\&lt;i&gt;X&lt;/i&gt;&lt;/code&gt; 는 다음 과 연결된 &lt;code&gt;FILE SEPARATOR&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="aef88cb460d98eb7a1821664038bd8e659735536" translate="yes" xml:space="preserve">
          <source>An internal &amp;ldquo;glob value&amp;rdquo; typedef, holding a &lt;b&gt;typeglob&lt;/b&gt;. The &lt;code&gt;GV&lt;/code&gt; type is a subclass of &lt;b&gt;SV&lt;/b&gt;.</source>
          <target state="translated">내부 &quot;글로브 값&quot;형식 정의는 지주 &lt;b&gt;타입 글로브를&lt;/b&gt; . &lt;code&gt;GV&lt;/code&gt; 의 유형의 서브 클래스입니다 &lt;b&gt;SV&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="365d20928561014537aae861944e88c7698c35b5" translate="yes" xml:space="preserve">
          <source>An internal I/O object. Can also mean &lt;b&gt;indirect object&lt;/b&gt;.</source>
          <target state="translated">내부 I / O 객체 &lt;b&gt;간접 객체를&lt;/b&gt; 의미 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="56ae7164116e23d92fc781838b142ca53874c36a" translate="yes" xml:space="preserve">
          <source>An internal function to generate the embedded perl code that will regenerate the constant subroutines.</source>
          <target state="translated">상수 서브 루틴을 재생성 할 임베디드 펄 코드를 생성하는 내부 함수.</target>
        </trans-unit>
        <trans-unit id="7baaf8aedf397c98d596c2159887aa7f484b6db4" translate="yes" xml:space="preserve">
          <source>An internal function to generate the embedded perl code that will regenerate the constant subroutines. Parameters are the same as for C_constant.</source>
          <target state="translated">상수 서브 루틴을 재생성 할 임베디드 펄 코드를 생성하는 내부 함수. 매개 변수는 C_constant와 동일합니다.</target>
        </trans-unit>
        <trans-unit id="85667dd393cb7f2981dedf066accff60dc1411e5" translate="yes" xml:space="preserve">
          <source>An internal method to generate a suitable &lt;code&gt;switch&lt;/code&gt; clause, called by &lt;code&gt;C_constant&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;C_constant&lt;/code&gt; 에 의해 호출되는 적절한 &lt;code&gt;switch&lt;/code&gt; 절 을 생성하는 내부 메소드</target>
        </trans-unit>
        <trans-unit id="69e28cd04a2779fc9d5742eab6b3a6ded1892dd3" translate="yes" xml:space="preserve">
          <source>An internal representation of your program wherein lower-level &lt;b&gt;constructs&lt;/b&gt; dangle off the higher-level constructs enclosing them.</source>
          <target state="translated">하위 레벨 &lt;b&gt;구조&lt;/b&gt; 가 상위 레벨 구조를 둘러싼 프로그램의 내부 표현 .</target>
        </trans-unit>
        <trans-unit id="ce42a8cc64b6b6a7bf11b4b312683fee15a303f0" translate="yes" xml:space="preserve">
          <source>An internal shorthand for a &amp;ldquo;push- pop&amp;rdquo; code; that is, C code implementing Perl&amp;rsquo;s stack machine.</source>
          <target state="translated">&quot;푸시 팝&quot;코드의 내부 속기. 즉, Perl의 스택 머신을 구현하는 C 코드입니다.</target>
        </trans-unit>
        <trans-unit id="2be767144e56c8e338304ff9f530373044c5bc8a" translate="yes" xml:space="preserve">
          <source>An internal variable used by &lt;a href=&quot;perlio&quot;&gt;PerlIO&lt;/a&gt;. A string in two parts, separated by a &lt;code&gt;\0&lt;/code&gt; byte, the first part describes the input layers, the second part describes the output layers.</source>
          <target state="translated">&lt;a href=&quot;perlio&quot;&gt;PerlIO에서&lt;/a&gt; 사용하는 내부 변수 입니다. 두 부분으로 된 문자열은 &lt;code&gt;\0&lt;/code&gt; 바이트로 구분됩니다. 첫 번째 부분은 입력 레이어를 설명하고 두 번째 부분은 출력 레이어를 설명합니다.</target>
        </trans-unit>
        <trans-unit id="07d1d6d772129317410071c249632c5b5382b664" translate="yes" xml:space="preserve">
          <source>An internal variable used by PerlIO. A string in two parts, separated by a &lt;code&gt;\0&lt;/code&gt; byte, the first part describes the input layers, the second part describes the output layers.</source>
          <target state="translated">PerlIO에서 사용하는 내부 변수입니다. 두 부분으로 된 문자열은 &lt;code&gt;\0&lt;/code&gt; 바이트로 구분되며 첫 번째 부분은 입력 레이어를 나타내고 두 번째 부분은 출력 레이어를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="30d4f93cd3d13081a21910a8e9e9a9f2e19354af" translate="yes" xml:space="preserve">
          <source>An invalid POD command has been found. Valid are &lt;code&gt;=head1&lt;/code&gt; , &lt;code&gt;=head2&lt;/code&gt; , &lt;code&gt;=head3&lt;/code&gt; , &lt;code&gt;=head4&lt;/code&gt; , &lt;code&gt;=over&lt;/code&gt; , &lt;code&gt;=item&lt;/code&gt; , &lt;code&gt;=back&lt;/code&gt; , &lt;code&gt;=begin&lt;/code&gt; , &lt;code&gt;=end&lt;/code&gt; , &lt;code&gt;=for&lt;/code&gt; , &lt;code&gt;=pod&lt;/code&gt; , &lt;code&gt;=cut&lt;/code&gt;</source>
          <target state="translated">잘못된 POD 명령이 발견되었습니다. 유효한 것은 &lt;code&gt;=head1&lt;/code&gt; , &lt;code&gt;=head2&lt;/code&gt; , &lt;code&gt;=head3&lt;/code&gt; , &lt;code&gt;=head4&lt;/code&gt; , &lt;code&gt;=over&lt;/code&gt; , &lt;code&gt;=item&lt;/code&gt; , &lt;code&gt;=back&lt;/code&gt; , &lt;code&gt;=begin&lt;/code&gt; , &lt;code&gt;=end&lt;/code&gt; , &lt;code&gt;=for&lt;/code&gt; , &lt;code&gt;=pod&lt;/code&gt; , &lt;code&gt;=cut&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="680a8cfcc47d942c4c76eb14d38af7a01657dc85" translate="yes" xml:space="preserve">
          <source>An invalid POD command has been found. Valid are &lt;code&gt;=head1&lt;/code&gt;, &lt;code&gt;=head2&lt;/code&gt;, &lt;code&gt;=head3&lt;/code&gt;, &lt;code&gt;=head4&lt;/code&gt;, &lt;code&gt;=over&lt;/code&gt;, &lt;code&gt;=item&lt;/code&gt;, &lt;code&gt;=back&lt;/code&gt;, &lt;code&gt;=begin&lt;/code&gt;, &lt;code&gt;=end&lt;/code&gt;, &lt;code&gt;=for&lt;/code&gt;, &lt;code&gt;=pod&lt;/code&gt;, &lt;code&gt;=cut&lt;/code&gt;</source>
          <target state="translated">유효하지 않은 POD 명령이 발견되었습니다. 유효한 값은 &lt;code&gt;=head1&lt;/code&gt; , &lt;code&gt;=head2&lt;/code&gt; , &lt;code&gt;=head3&lt;/code&gt; , &lt;code&gt;=head4&lt;/code&gt; , &lt;code&gt;=over&lt;/code&gt; , &lt;code&gt;=item&lt;/code&gt; , &lt;code&gt;=back&lt;/code&gt; , &lt;code&gt;=begin&lt;/code&gt; , &lt;code&gt;=end&lt;/code&gt; , &lt;code&gt;=for&lt;/code&gt; , &lt;code&gt;=pod&lt;/code&gt; , &lt;code&gt;=cut&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8cf1c0648159d8ce5ec8b307b5ed4c7e4b2df3c9" translate="yes" xml:space="preserve">
          <source>An invalid markup command has been encountered. Valid are: &lt;code&gt;B&amp;lt;&amp;gt;&lt;/code&gt; , &lt;code&gt;C&amp;lt;&amp;gt;&lt;/code&gt; , &lt;code&gt;E&amp;lt;&amp;gt;&lt;/code&gt; , &lt;code&gt;F&amp;lt;&amp;gt;&lt;/code&gt; , &lt;code&gt;I&amp;lt;&amp;gt;&lt;/code&gt; , &lt;code&gt;L&amp;lt;&amp;gt;&lt;/code&gt; , &lt;code&gt;S&amp;lt;&amp;gt;&lt;/code&gt; , &lt;code&gt;X&amp;lt;&amp;gt;&lt;/code&gt; , &lt;code&gt;Z&amp;lt;&amp;gt;&lt;/code&gt;</source>
          <target state="translated">잘못된 마크 업 명령이 발생했습니다. 유효 : &lt;code&gt;B&amp;lt;&amp;gt;&lt;/code&gt; , &lt;code&gt;C&amp;lt;&amp;gt;&lt;/code&gt; , &lt;code&gt;E&amp;lt;&amp;gt;&lt;/code&gt; , &lt;code&gt;F&amp;lt;&amp;gt;&lt;/code&gt; , &lt;code&gt;I&amp;lt;&amp;gt;&lt;/code&gt; , &lt;code&gt;L&amp;lt;&amp;gt;&lt;/code&gt; , &lt;code&gt;S&amp;lt;&amp;gt;&lt;/code&gt; , &lt;code&gt;X&amp;lt;&amp;gt;&lt;/code&gt; , &lt;code&gt;Z&amp;lt;&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ab0cc889ac8e69a2e34e2105510c7875248e79d9" translate="yes" xml:space="preserve">
          <source>An invalid markup command has been encountered. Valid are: &lt;code&gt;B&amp;lt;&amp;gt;&lt;/code&gt;, &lt;code&gt;C&amp;lt;&amp;gt;&lt;/code&gt;, &lt;code&gt;E&amp;lt;&amp;gt;&lt;/code&gt;, &lt;code&gt;F&amp;lt;&amp;gt;&lt;/code&gt;, &lt;code&gt;I&amp;lt;&amp;gt;&lt;/code&gt;, &lt;code&gt;L&amp;lt;&amp;gt;&lt;/code&gt;, &lt;code&gt;S&amp;lt;&amp;gt;&lt;/code&gt;, &lt;code&gt;X&amp;lt;&amp;gt;&lt;/code&gt;, &lt;code&gt;Z&amp;lt;&amp;gt;&lt;/code&gt;</source>
          <target state="translated">잘못된 마크 업 명령이 발생했습니다. 유효한 값 : &lt;code&gt;B&amp;lt;&amp;gt;&lt;/code&gt; , &lt;code&gt;C&amp;lt;&amp;gt;&lt;/code&gt; , &lt;code&gt;E&amp;lt;&amp;gt;&lt;/code&gt; , &lt;code&gt;F&amp;lt;&amp;gt;&lt;/code&gt; , &lt;code&gt;I&amp;lt;&amp;gt;&lt;/code&gt; , &lt;code&gt;L&amp;lt;&amp;gt;&lt;/code&gt; , &lt;code&gt;S&amp;lt;&amp;gt;&lt;/code&gt; , &lt;code&gt;X&amp;lt;&amp;gt;&lt;/code&gt; , &lt;code&gt;Z&amp;lt;&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ee1262d5508556d2b36a24c42f3e9a2dee57cb72" translate="yes" xml:space="preserve">
          <source>An item &quot;_*&quot; is interpreted to mean &quot;all of @_ except $_[0]&quot;. I.e., &lt;code&gt;@_[1..$#_]&lt;/code&gt; . Note that this is an empty list in the case of calls like $lh-&amp;gt;maketext(</source>
          <target state="translated">&quot;_ *&quot;항목은 &quot;$ _ [0]을 (를) 제외한 모든 _&quot;을 의미하는 것으로 해석됩니다. 즉, &lt;code&gt;@_[1..$#_]&lt;/code&gt; 입니다. $ lh-&amp;gt; maketext (와 같은 호출의 경우에는 빈 목록입니다.</target>
        </trans-unit>
        <trans-unit id="c7832bda7130f94045f7bfb60ec1dccf55e7e697" translate="yes" xml:space="preserve">
          <source>An item &quot;_*&quot; is interpreted to mean &quot;all of @_ except $_[0]&quot;. I.e., &lt;code&gt;@_[1..$#_]&lt;/code&gt;. Note that this is an empty list in the case of calls like $lh-&amp;gt;maketext(</source>
          <target state="translated">항목 &quot;_ *&quot;는 &quot;$ _ [0]을 제외한 모든 @_&quot;를 의미하는 것으로 해석됩니다. 즉, &lt;code&gt;@_[1..$#_]&lt;/code&gt; . $ lh-&amp;gt; maketext (</target>
        </trans-unit>
        <trans-unit id="9af9ff7e003c973fa83a18c634e0daee75f8051b" translate="yes" xml:space="preserve">
          <source>An item that is &quot;_</source>
          <target state="translated">&quot;_ 인 항목</target>
        </trans-unit>
        <trans-unit id="7b5f2c15e59a54bf0587db95d2a9b094a2521830" translate="yes" xml:space="preserve">
          <source>An number specifying the maximum number of fields to return. If this argument is omitted (or &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;), split continues as long as possible.</source>
          <target state="translated">반환 할 최대 필드 수를 지정하는 숫자입니다. 이 인수를 생략하면 (또는 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; ) 가능한 한 split이 계속됩니다.</target>
        </trans-unit>
        <trans-unit id="da38298cadbae3dcfcb616625cc2268ee1079670" translate="yes" xml:space="preserve">
          <source>An number specifying the maximum number of fields to return. If this argument is omitted (or &lt;code&gt;undef&lt;/code&gt;), split continues as long as possible.</source>
          <target state="translated">반환 할 최대 필드 수를 지정하는 숫자입니다. 이 인수가 생략되면 (또는 &lt;code&gt;undef&lt;/code&gt; ) 분할이 가능한 한 오래 계속됩니다.</target>
        </trans-unit>
        <trans-unit id="eabc404e0d4e219ccc6748ea24d333aab485d543" translate="yes" xml:space="preserve">
          <source>An object belonging to a language class is called a &quot;language handle&quot;; it's typically a flyweight object.</source>
          <target state="translated">언어 클래스에 속하는 개체를 &quot;언어 핸들&quot;이라고합니다. 일반적으로 플라이급 객체입니다.</target>
        </trans-unit>
        <trans-unit id="49f2fe3106e7ff8ff917e823e3eefb2822882e64" translate="yes" xml:space="preserve">
          <source>An object corresponding to a paragraph of POD input text. It may be a plain paragraph, a verbatim paragraph, or a command paragraph (see &lt;a href=&quot;../perlpod&quot;&gt;perlpod&lt;/a&gt;).</source>
          <target state="translated">POD 입력 텍스트의 단락에 해당하는 객체입니다. 일반 단락, 축약 형 단락 또는 명령 단락 일 수 있습니다 ( &lt;a href=&quot;../perlpod&quot;&gt;perlpod&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="8c3786be4e01790b87960925526e572088af640f" translate="yes" xml:space="preserve">
          <source>An object corresponding to a tree of parsed POD text. Each &quot;node&quot; in a parse-tree (or</source>
          <target state="translated">구문 분석 된 POD 텍스트 트리에 해당하는 객체입니다. 구문 분석 트리의 각 &quot;노드&quot;</target>
        </trans-unit>
        <trans-unit id="7e0998ddd63a38891699bf9ec1b0ac44c576baee" translate="yes" xml:space="preserve">
          <source>An object corresponding to an interior sequence command from the POD input text (see &lt;a href=&quot;../perlpod&quot;&gt;perlpod&lt;/a&gt;).</source>
          <target state="translated">POD 입력 텍스트의 내부 시퀀스 명령에 해당하는 객체입니다 ( &lt;a href=&quot;../perlpod&quot;&gt;perlpod&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="9a21e67f15a49134056700786cd13ad755082aac" translate="yes" xml:space="preserve">
          <source>An object is simply a data structure that knows to which class it belongs.</source>
          <target state="translated">객체는 단순히 어떤 클래스에 속하는지를 알고있는 데이터 구조입니다.</target>
        </trans-unit>
        <trans-unit id="a359cbcceea3057766a3859aec9166b89f1082b5" translate="yes" xml:space="preserve">
          <source>An object method that initializes the first and last name to its two arguments. If called as a class method, &lt;code&gt;init()&lt;/code&gt; creates an object in the given class and initializes that.</source>
          <target state="translated">이름과 성을 두 개의 인수로 초기화하는 객체 메소드입니다. 클래스 메소드로 호출되면, &lt;code&gt;init()&lt;/code&gt; 는 주어진 클래스에 객체를 생성하고 초기화합니다.</target>
        </trans-unit>
        <trans-unit id="2624824193fa16111d4b98614c9c89fd43601093" translate="yes" xml:space="preserve">
          <source>An object of a class created by the first and third forms is based on an array, whereas an object of a class created by the second form is based on a hash. The array-based forms will be somewhat faster and smaller; the hash-based forms are more flexible.</source>
          <target state="translated">첫 번째 및 세 번째 양식으로 작성된 클래스의 오브젝트는 배열을 기반으로하는 반면 두 번째 양식으로 작성된 클래스의 오브젝트는 해시를 기반으로합니다. 배열 기반 형식은 다소 빠르며 작습니다. 해시 기반 양식이 더 유연합니다.</target>
        </trans-unit>
        <trans-unit id="439e33121717fb8b3802d4a57550afd4a17f81f5" translate="yes" xml:space="preserve">
          <source>An object of class Archive::Tar represents a .tar(.gz) archive full of files and things.</source>
          <target state="translated">Archive :: Tar 클래스의 객체는 파일과 사물로 가득 찬 .tar (.gz) 아카이브를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="fcd5621c0c225a91e3f7d06ac2a91fa4ab613367" translate="yes" xml:space="preserve">
          <source>An object representing a POD interior sequence command. It has the following methods/attributes:</source>
          <target state="translated">POD 내부 시퀀스 명령을 나타내는 객체입니다. 다음과 같은 방법 / 속성이 있습니다.</target>
        </trans-unit>
        <trans-unit id="c24cc2e914ce53bfd778879fef27948d64904b08" translate="yes" xml:space="preserve">
          <source>An object representing a paragraph of POD input text. It has the following methods/attributes:</source>
          <target state="translated">POD 입력 텍스트의 단락을 나타내는 객체입니다. 다음과 같은 방법 / 속성이 있습니다.</target>
        </trans-unit>
        <trans-unit id="6fdb094e1018942aa0eb673bb8c92b50838eeb01" translate="yes" xml:space="preserve">
          <source>An object represents a single discrete thing. For example, an object might represent a file. The attributes for a file object might include its path, content, and last modification time. If we created an object to represent</source>
          <target state="translated">객체는 하나의 별개의 것을 나타냅니다. 예를 들어, 객체는 파일을 나타낼 수 있습니다. 파일 객체의 속성에는 경로, 내용 및 마지막 수정 시간이 포함될 수 있습니다. 표시 할 객체를 만든 경우</target>
        </trans-unit>
        <trans-unit id="ca7e61e203c4b11d26a8c4d45f16575384df7da5" translate="yes" xml:space="preserve">
          <source>An object that overloads an assignment operator does so only in respect of assignments to that object. In other words, Perl never calls the corresponding methods with the third argument (the &quot;swap&quot; argument) set to TRUE. For example, the operation</source>
          <target state="translated">할당 연산자를 오버로드하는 객체는 해당 객체에 대한 할당에 대해서만 그렇게합니다. 즉, Perl은 세 번째 인수 ( &quot;스왑&quot;인수)를 TRUE로 설정하여 해당 메소드를 호출하지 않습니다. 예를 들어, 작업</target>
        </trans-unit>
        <trans-unit id="5dcc2b27aa012d9c72429af38062f2b4f54986c2" translate="yes" xml:space="preserve">
          <source>An object's members cannot be made accessible as variables. The closest Perl equivalent to &lt;code&gt;with(object) { method() }&lt;/code&gt; is &lt;code&gt;for&lt;/code&gt; , which can alias &lt;code&gt;$_&lt;/code&gt; to the object:</source>
          <target state="translated">객체의 멤버는 변수로 액세스 할 수 없습니다. &lt;code&gt;with(object) { method() }&lt;/code&gt; 가장 가까운 Perl 은 &lt;code&gt;for&lt;/code&gt; 이며, &lt;code&gt;$_&lt;/code&gt; 를 객체에 별칭으로 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="667eaf5552288796413270dd142cf8898197f884" translate="yes" xml:space="preserve">
          <source>An object's members cannot be made accessible as variables. The closest Perl equivalent to &lt;code&gt;with(object) { method() }&lt;/code&gt; is &lt;code&gt;for&lt;/code&gt;, which can alias &lt;code&gt;$_&lt;/code&gt; to the object:</source>
          <target state="translated">개체의 멤버는 변수로 액세스 할 수 없습니다. &lt;code&gt;with(object) { method() }&lt;/code&gt; 해당하는 가장 가까운 Perl 은 &lt;code&gt;for&lt;/code&gt; 이며 , 객체에 &lt;code&gt;$_&lt;/code&gt; 별칭을 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b940725a20a5223e137a3da755a048d1310c8a3b" translate="yes" xml:space="preserve">
          <source>An object, however, is a reference to blessed data, so if &lt;code&gt;$a&lt;/code&gt; and &lt;code&gt;$b&lt;/code&gt; are objects then the assignment &lt;code&gt;$a = $b&lt;/code&gt; copies only the reference, leaving &lt;code&gt;$a&lt;/code&gt; and &lt;code&gt;$b&lt;/code&gt; referring to the same object data. One might therefore expect the operation &lt;code&gt;--$a&lt;/code&gt; to decrement &lt;code&gt;$b&lt;/code&gt; as well as &lt;code&gt;$a&lt;/code&gt; . However, this would not be consistent with how we expect the mathematical operators to work.</source>
          <target state="translated">그러나 객체는 축복 된 데이터에 대한 참조이므로 &lt;code&gt;$a&lt;/code&gt; 및 &lt;code&gt;$b&lt;/code&gt; 가 객체 인 경우 할당 &lt;code&gt;$a = $b&lt;/code&gt; 는 참조 만 복사하므로 &lt;code&gt;$a&lt;/code&gt; 와 &lt;code&gt;$b&lt;/code&gt; 는 동일한 객체 데이터를 참조합니다. 하나는 따라서 동작 예상 &lt;code&gt;--$a&lt;/code&gt; 감소하는 &lt;code&gt;$b&lt;/code&gt; 뿐만 아니라 같은 &lt;code&gt;$a&lt;/code&gt; . 그러나 이것은 수학 연산자가 작동하는 방식과 일치하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="25fb12e7db9c947b1012ab13c08ddc21606a22cc" translate="yes" xml:space="preserve">
          <source>An object, however, is a reference to blessed data, so if &lt;code&gt;$a&lt;/code&gt; and &lt;code&gt;$b&lt;/code&gt; are objects then the assignment &lt;code&gt;$a = $b&lt;/code&gt; copies only the reference, leaving &lt;code&gt;$a&lt;/code&gt; and &lt;code&gt;$b&lt;/code&gt; referring to the same object data. One might therefore expect the operation &lt;code&gt;--$a&lt;/code&gt; to decrement &lt;code&gt;$b&lt;/code&gt; as well as &lt;code&gt;$a&lt;/code&gt;. However, this would not be consistent with how we expect the mathematical operators to work.</source>
          <target state="translated">목적은, 그러나, 만약 그렇다면, 복 데이터에 대한 참조 &lt;code&gt;$a&lt;/code&gt; 및 &lt;code&gt;$b&lt;/code&gt; 객체 후 할당되어 &lt;code&gt;$a = $b&lt;/code&gt; 남기고 사본만을 참조 &lt;code&gt;$a&lt;/code&gt; 와 &lt;code&gt;$b&lt;/code&gt; 동일한 오브젝트 데이터를 참조. 하나는 따라서 동작 예상 &lt;code&gt;--$a&lt;/code&gt; 감소하는 &lt;code&gt;$b&lt;/code&gt; 뿐만 아니라 같은 &lt;code&gt;$a&lt;/code&gt; . 그러나 이것은 수학 연산자가 작동 할 것으로 예상하는 방식과 일치하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="cee679c1ad7f71a88f44d59f19712e4063863e7e" translate="yes" xml:space="preserve">
          <source>An older style is to use a bareword as the filehandle, as</source>
          <target state="translated">오래된 스타일은 파일 핸들로 베어 워드를 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="60dc562d58d05afda178b352ef3aa2e15f8841ff" translate="yes" xml:space="preserve">
          <source>An op is a fundamental operation that Perl can perform: all the built-in functions and operators are ops, and there are a series of ops which deal with concepts the interpreter needs internally - entering and leaving a block, ending a statement, fetching a variable, and so on.</source>
          <target state="translated">op는 Perl이 수행 할 수있는 기본 조작입니다. 모든 내장 함수와 연산자는 op입니다. 인터프리터가 내부적으로 필요로하는 개념을 처리하는 일련의 ops가 있습니다. 변수 등.</target>
        </trans-unit>
        <trans-unit id="7d7b9e438ab0eb414e5789ea7e5ffe93395e4dff" translate="yes" xml:space="preserve">
          <source>An operator with only one &lt;b&gt;operand&lt;/b&gt;, like &lt;code&gt;!&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/chdir&quot;&gt;chdir&lt;/a&gt;&lt;/code&gt;. Unary operators are usually prefix operators; that is, they precede their operand. The &lt;code&gt;++&lt;/code&gt; and &lt;code&gt;&amp;ndash;&amp;ndash;&lt;/code&gt; operators can be either prefix or postfix. (Their position</source>
          <target state="translated">&lt;code&gt;!&lt;/code&gt; 처럼 &lt;b&gt;피연산자가&lt;/b&gt; 하나 뿐인 연산자 또는 &lt;code&gt;&lt;a href=&quot;functions/chdir&quot;&gt;chdir&lt;/a&gt;&lt;/code&gt; . 단항 연산자는 일반적으로 접두사 연산자입니다. 즉, 피연산자보다 앞에옵니다. &lt;code&gt;++&lt;/code&gt; 및 &lt;code&gt;&amp;ndash;&amp;ndash;&lt;/code&gt; 연산자는 하나 접두사 나 접미사가 될 수 있습니다. (그들의 위치</target>
        </trans-unit>
        <trans-unit id="2af9fb33db84bf30fe452d6a36fe8b4e335e0649" translate="yes" xml:space="preserve">
          <source>An operator with only one &lt;b&gt;operand&lt;/b&gt;, like &lt;code&gt;!&lt;/code&gt; or &lt;code&gt;chdir&lt;/code&gt;. Unary operators are usually prefix operators; that is, they precede their operand. The &lt;code&gt;++&lt;/code&gt; and &lt;code&gt;&amp;ndash;&amp;ndash;&lt;/code&gt; operators can be either prefix or postfix. (Their position</source>
          <target state="translated">&lt;b&gt;피연산자&lt;/b&gt; 가 하나만있는 연산자 , 예 : &lt;code&gt;!&lt;/code&gt; 또는 &lt;code&gt;chdir&lt;/code&gt; . 단항 연산자는 일반적으로 접두사 연산자입니다. 즉, 피연산자 앞에 있습니다. &lt;code&gt;++&lt;/code&gt; 및 &lt;code&gt;&amp;ndash;&amp;ndash;&lt;/code&gt; 연산자는 하나 접두사 나 접미사가 될 수 있습니다. (그들의 위치</target>
        </trans-unit>
        <trans-unit id="9f9db1e29b16d48958d935e90ad14b3aea77dc3c" translate="yes" xml:space="preserve">
          <source>An opname or optag can be prefixed with an exclamation mark, e.g., !mkdir. Negating an opname or optag means remove the corresponding ops from the accumulated set of ops at that point.</source>
          <target state="translated">opname 또는 optag 앞에 느낌표 (예 :! mkdir)를 접두어로 붙일 수 있습니다. opname 또는 optag를 무효화한다는 것은 해당 시점에서 누적 된 op 세트에서 해당 op를 제거하는 것을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="dd9db1bae968b2ebc8590123585766603b6be162" translate="yes" xml:space="preserve">
          <source>An option on a pattern or substitution, such as &lt;code&gt;/i&lt;/code&gt; to render the pattern case- insensitive.</source>
          <target state="translated">&lt;code&gt;/i&lt;/code&gt; 와 같은 패턴 또는 대체 옵션 을 사용하여 패턴을 대소 문자를 구분하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1a49163e236ca9288cd8e7003ee1066226da4567" translate="yes" xml:space="preserve">
          <source>An option you give on a command line to influence the way your program works, usually introduced with a minus sign. The word is also used as a nickname for a &lt;b&gt;switch statement&lt;/b&gt;.</source>
          <target state="translated">프로그램이 작동하는 방식에 영향을주기 위해 명령 줄에 제공하는 옵션으로, 일반적으로 빼기 부호가 있습니다. 이 단어는 또한 &lt;b&gt;switch 문의&lt;/b&gt; 별명으로 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="eab6379d02e7da9bfe1cac71088e9311f2348060" translate="yes" xml:space="preserve">
          <source>An optional array of other socket options to apply after the three listed above. The value is an ARRAY containing 2- or 3-element ARRAYrefs. Each inner array relates to a single option, giving the level and option name, and an optional value. If the value element is missing, it will be given the value of a platform-sized integer 1 constant (i.e. suitable to enable most of the common boolean options).</source>
          <target state="translated">위에 나열된 세 가지 다음에 적용 할 다른 소켓 옵션의 선택적 배열입니다. 값은 2 개 또는 3 개의 요소 ARRAYref를 포함하는 ARRAY입니다. 각 내부 배열은 단일 옵션과 관련되어 레벨 및 옵션 이름과 선택적 값을 제공합니다. 값 요소가 누락 된 경우 플랫폼 크기 정수 1 상수의 값이 제공됩니다 (즉, 대부분의 일반적인 부울 옵션을 활성화하는 데 적합 함).</target>
        </trans-unit>
        <trans-unit id="e2561efefd0f2b6e16416b85a2d7a359b74ad024" translate="yes" xml:space="preserve">
          <source>An optional feature provided by a CPAN distribution</source>
          <target state="translated">CPAN 배포에서 제공하는 선택적 기능</target>
        </trans-unit>
        <trans-unit id="9645245b8e6172ce42528bd667596edb4e44c226" translate="yes" xml:space="preserve">
          <source>An optional filehandle (or IO::Handle ) that output will be printed to.</source>
          <target state="translated">출력이 인쇄 될 선택적 파일 핸들 (또는 IO :: Handle)입니다.</target>
        </trans-unit>
        <trans-unit id="bcc5a81df3ac1dbb29e0b23ff110e8ac5f546061" translate="yes" xml:space="preserve">
          <source>An optional filehandle (or IO::Handle ) to which the output string will be printed.</source>
          <target state="translated">출력 문자열이 인쇄 될 선택적 파일 핸들 (또는 IO :: Handle)입니다.</target>
        </trans-unit>
        <trans-unit id="2f9901f0f16239239419edd137f25118d48c58b4" translate="yes" xml:space="preserve">
          <source>An optional parameter can be nameless just like a mandatory parameter. For example,</source>
          <target state="translated">선택적 매개 변수는 필수 매개 변수처럼 이름이 없을 수 있습니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="c0d6b2a0df46d7d7fb341e1412dc44bcca1bf51c" translate="yes" xml:space="preserve">
          <source>An optional part of a &lt;b&gt;subroutine&lt;/b&gt; declaration telling the Perl compiler how many and what flavor of arguments may be passed as &lt;b&gt;actual arguments&lt;/b&gt;, so you can write subroutine calls that parse much like built-in functions. (Or don&amp;rsquo;t parse, as the case may be.)</source>
          <target state="translated">&lt;b&gt;서브 루틴&lt;/b&gt; 선언 의 선택적 부분으로 Perl 컴파일러에게 &lt;b&gt;실제 인자&lt;/b&gt; 로 전달할 수있는 인자의 수와 종류를 알려주 므로 내장 함수와 매우 유사하게 구문 분석되는 서브 루틴 호출을 작성할 수 있습니다. (또는 경우에 따라 구문 분석하지 마십시오.)</target>
        </trans-unit>
        <trans-unit id="a21eb72be8656b34c88984249eec6f0bab32e544" translate="yes" xml:space="preserve">
          <source>An optional third parameter can be used to specify the buffer size used for copying. This is the number of bytes from the first file, that will be held in memory at any given time, before being written to the second file. The default buffer size depends upon the file, but will generally be the whole file (up to 2MB), or 1k for filehandles that do not reference files (eg. sockets).</source>
          <target state="translated">선택적 세 번째 매개 변수를 사용하여 복사에 사용되는 버퍼 크기를 지정할 수 있습니다. 이것은 첫 번째 파일의 바이트 수이며 두 번째 파일에 기록되기 전에 주어진 시간에 메모리에 보유됩니다. 기본 버퍼 크기는 파일에 따라 다르지만 일반적으로 전체 파일 (최대 2MB)이거나 파일을 참조하지 않는 파일 핸들 (예 : 소켓)의 경우 1k입니다.</target>
        </trans-unit>
        <trans-unit id="0ba928fdaea76c696564501e58ec48f20c5c9dc1" translate="yes" xml:space="preserve">
          <source>An ordered sequence of &lt;b&gt;values&lt;/b&gt;, stored such that you can easily access any of the values using an</source>
          <target state="translated">정렬 된 일련의 &lt;b&gt;값&lt;/b&gt; 으로 저장된 값을 사용하여 값에 쉽게 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2b793fb04f1842403dcb9eae8e630daf85625e60" translate="yes" xml:space="preserve">
          <source>An ordered set of scalar values.</source>
          <target state="translated">정렬 된 스칼라 값 집합입니다.</target>
        </trans-unit>
        <trans-unit id="5c49a2821f5a5074f3f77a39e2cb0f3e615a425e" translate="yes" xml:space="preserve">
          <source>An ordinary disk file.</source>
          <target state="translated">일반 디스크 파일.</target>
        </trans-unit>
        <trans-unit id="a77cc50988bf220f630f8fad5e50fc8b8f153295" translate="yes" xml:space="preserve">
          <source>An ordinary hard disk partition.</source>
          <target state="translated">일반 하드 디스크 파티션.</target>
        </trans-unit>
        <trans-unit id="93d009c1cdb4335605c0d3fe2975d2046a8496a5" translate="yes" xml:space="preserve">
          <source>An overview of the Perl interpreter source code and some details on how Perl does what it does.</source>
          <target state="translated">Perl 인터프리터 소스 코드 개요 및 Perl의 기능에 대한 세부 사항.</target>
        </trans-unit>
        <trans-unit id="bfd206b59d07c02456cd04b8e043a98488117f17" translate="yes" xml:space="preserve">
          <source>An overview of the Perl source tree. This will help you find the files you're looking for.</source>
          <target state="translated">Perl 소스 트리의 개요 원하는 파일을 찾는 데 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="a982a39a2d5d6b9f37342b5e83c23e1f0856fa85" translate="yes" xml:space="preserve">
          <source>An uncaught &lt;b&gt;exception&lt;/b&gt;, which causes termination of the &lt;b&gt;process&lt;/b&gt; after printing a message on your &lt;b&gt;standard error&lt;/b&gt; stream. Errors that happen inside an &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; are not fatal. Instead, the &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; terminates after placing the exception message in the &lt;code&gt;$@&lt;/code&gt; (&lt;code&gt;$EVAL_ERROR&lt;/code&gt; ) variable. You can try to provoke a fatal error with the &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; operator (known as throwing or raising an exception), but this may be caught by a dynamically enclosing &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;. If not caught, the &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; becomes a fatal error.</source>
          <target state="translated">포착되지 않은 &lt;b&gt;예외로 &lt;/b&gt;&lt;b&gt;표준 오류&lt;/b&gt; 스트림 에 메시지를 인쇄 한 후 &lt;b&gt;프로세스&lt;/b&gt; 가 종료됩니다 . &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 내에서 발생하는 오류는 치명적이지 않습니다. 대신, 예외 메시지를 &lt;code&gt;$@&lt;/code&gt; ( &lt;code&gt;$EVAL_ERROR&lt;/code&gt; ) 변수에 놓은 후 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 이 종료됩니다 . &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; 연산자를 사용하여 치명적인 오류를 유발하려고 시도 할 수 있지만 (예외 발생 또는 예외 발생) 동적으로 둘러싸인 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 에 의해 발생할 수 있습니다 . 잡히지 않으면 &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; 는 치명적인 오류가됩니다.&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="f1a5d434a9faff9684c6af59ceb8c569c1859cc2" translate="yes" xml:space="preserve">
          <source>An uncaught &lt;b&gt;exception&lt;/b&gt;, which causes termination of the &lt;b&gt;process&lt;/b&gt; after printing a message on your &lt;b&gt;standard error&lt;/b&gt; stream. Errors that happen inside an &lt;code&gt;eval&lt;/code&gt; are not fatal. Instead, the &lt;code&gt;eval&lt;/code&gt; terminates after placing the exception message in the &lt;code&gt;$@&lt;/code&gt; (&lt;code&gt;$EVAL_ERROR&lt;/code&gt;) variable. You can try to provoke a fatal error with the &lt;code&gt;die&lt;/code&gt; operator (known as throwing or raising an exception), but this may be caught by a dynamically enclosing &lt;code&gt;eval&lt;/code&gt;. If not caught, the &lt;code&gt;die&lt;/code&gt; becomes a fatal error.</source>
          <target state="translated">&lt;b&gt;표준 오류&lt;/b&gt; 스트림 에 메시지를 인쇄 한 후 &lt;b&gt;프로세스를&lt;/b&gt; 종료 하는 포착되지 않은 &lt;b&gt;예외&lt;/b&gt; 입니다. &lt;code&gt;eval&lt;/code&gt; 내에서 발생하는 오류는 치명적이지 않습니다. 대신 &lt;code&gt;$@&lt;/code&gt; ( &lt;code&gt;$EVAL_ERROR&lt;/code&gt; ) 변수에 예외 메시지를 배치 한 후 &lt;code&gt;eval&lt;/code&gt; 종료됩니다 . &lt;code&gt;die&lt;/code&gt; 연산자 (예외 발생 또는 발생이라고 함)로 치명적인 오류를 유발할 수 있지만 동적으로 둘러싸는 &lt;code&gt;eval&lt;/code&gt; 에 의해 포착 될 수 있습니다 . 잡히지 않으면 &lt;code&gt;die&lt;/code&gt; 는 치명적인 오류가됩니다.&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="fe98c7b5bde8acca47b9d777c6042909674e86b2" translate="yes" xml:space="preserve">
          <source>An unclosed formatting code</source>
          <target state="translated">닫히지 않은 서식 코드</target>
        </trans-unit>
        <trans-unit id="96b48446507c5be16337d09d4b16f13d55933f7d" translate="yes" xml:space="preserve">
          <source>An undefined $port argument is taken as zero; an undefined $ip6_address is considered a fatal error.</source>
          <target state="translated">정의되지 않은 $ port 인수는 0으로 간주됩니다. 정의되지 않은 $ ip6_address는 치명적인 오류로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="3f9293e352420d9fd32f5883ba4908461fd77eae" translate="yes" xml:space="preserve">
          <source>An undefined $port argument is taken as zero; an undefined $ip_address is considered a fatal error.</source>
          <target state="translated">정의되지 않은 $ port 인수는 0으로 간주됩니다. 정의되지 않은 $ ip_address는 치명적인 오류로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="54365bc1044b88eb77fbf7f1b4c0664f5bcb036c" translate="yes" xml:space="preserve">
          <source>An undefined value is not permitted as a record separator. Perl's special &quot;paragraph mode&quot; semantics (&amp;agrave; la &lt;code&gt;$/ = &quot;&quot;&lt;/code&gt; ) are not emulated.</source>
          <target state="translated">정의되지 않은 값은 레코드 분리 자로 허용되지 않습니다. Perl의 특수 &quot;단락 모드&quot;시맨틱 (a la &lt;code&gt;$/ = &quot;&quot;&lt;/code&gt; )은 에뮬레이션되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0407455390a08706db99e80a71be456dbdff3c3e" translate="yes" xml:space="preserve">
          <source>An undefined value is not permitted as a record separator. Perl's special &quot;paragraph mode&quot; semantics (&amp;agrave; la &lt;code&gt;$/ = &quot;&quot;&lt;/code&gt;) are not emulated.</source>
          <target state="translated">정의되지 않은 값은 레코드 분리 자로 허용되지 않습니다. Perl의 특별한 &quot;단락 모드&quot;의미 (&amp;agrave; la &lt;code&gt;$/ = &quot;&quot;&lt;/code&gt; )는 에뮬레이션되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b64166e760d6e4e08cfb550598a86717021fc931" translate="yes" xml:space="preserve">
          <source>An unnamed list of temporary scalar values that may be passed around within a program from any list-generating function to any function or construct that provides a &lt;b&gt;list context&lt;/b&gt;.</source>
          <target state="translated">프로그램 내에서 목록 생성 함수에서 &lt;b&gt;목록 컨텍스트&lt;/b&gt; 를 제공하는 함수 또는 구문으로 전달 될 수있는 이름없는 임시 스칼라 값 &lt;b&gt;목록&lt;/b&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="b7a4ac1dececd2f0138b0d9e87eae14a3bf0f323" translate="yes" xml:space="preserve">
          <source>An unordered association of &lt;b&gt;key&lt;/b&gt;/&lt;b&gt;value&lt;/b&gt; pairs, stored such that you can easily use a string &lt;b&gt;key&lt;/b&gt; to look up its associated data &lt;b&gt;value&lt;/b&gt;. This glossary is like a hash, where the word to be defined is the key and the definition is the value. A hash is also sometimes septisyllabically called an &amp;ldquo;associative array&amp;rdquo;, which is a pretty good reason for simply calling it a &amp;ldquo;hash&amp;rdquo; instead.</source>
          <target state="translated">문자열 &lt;b&gt;키&lt;/b&gt; 를 사용하여 연관된 데이터 &lt;b&gt;값&lt;/b&gt; 을 쉽게 찾을 수 있도록 저장된 &lt;b&gt;키&lt;/b&gt; / &lt;b&gt;값&lt;/b&gt; 쌍 의 정렬되지 않은 연관 . 이 용어집은 해시와 같습니다. 여기서 정의 할 단어가 핵심이고 정의는 값입니다. 해시는 종종 분리 적으로&amp;ldquo;연관 배열 (associative array)&amp;rdquo;이라고 불리기도합니다. 이는 단순히&amp;ldquo;해시&amp;rdquo;라고 부르는 아주 좋은 이유입니다.&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="b718389bf63428a7f7a0b8e8cfc5e0574b25619d" translate="yes" xml:space="preserve">
          <source>An unset or empty PERLIO is equivalent to the default set of layers for your platform; for example, &lt;code&gt;:unix:perlio&lt;/code&gt; on Unix-like systems and &lt;code&gt;:unix:crlf&lt;/code&gt; on Windows and other DOS-like systems.</source>
          <target state="translated">설정되지 않거나 비어있는 PERLIO는 플랫폼의 기본 레이어 세트와 같습니다. 예를 들어, Unix 계열 시스템의 경우 &lt;code&gt;:unix:perlio&lt;/code&gt; , Windows 및 기타 DOS 계열 시스템의 경우 &lt;code&gt;:unix:crlf&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="1b2099e63b3baac079849a311cb94bc9726d2b6a" translate="yes" xml:space="preserve">
          <source>An unsigned byte.</source>
          <target state="translated">부호없는 바이트</target>
        </trans-unit>
        <trans-unit id="17f8abaddabc70c518443c4340875b6f3d1f87f6" translate="yes" xml:space="preserve">
          <source>An unsigned integer.</source>
          <target state="translated">부호없는 정수</target>
        </trans-unit>
        <trans-unit id="6dc9fd633e86a9f8c5100a5a45701b6dac466c39" translate="yes" xml:space="preserve">
          <source>An upgrade to the PA-RISC design, it shipped for many years in many different system.</source>
          <target state="translated">PA-RISC 설계로의 업그레이드로 수년 동안 다양한 시스템으로 출하되었습니다.</target>
        </trans-unit>
        <trans-unit id="05468cfd5e27b4298d95a71824d624b7c4dbc8a7" translate="yes" xml:space="preserve">
          <source>An xV that is visible at the Perl level should not become unreferenced and thus be destroyed. Normally, an object will only become unreferenced when it is no longer visible, often by the same means that makes it invisible. For example, a Perl reference value (RV) owns a reference to its referent, so if the RV is overwritten that reference gets destroyed, and the no-longer-reachable referent may be destroyed as a result.</source>
          <target state="translated">Perl 수준에서 볼 수있는 xV는 참조되지 않아서 파괴되어서는 안됩니다. 일반적으로 객체는 더 이상 표시되지 않을 때만 참조되지 않으며, 종종 표시되지 않도록하는 동일한 방법을 사용합니다. 예를 들어, Perl 참조 값 (RV)은 참조 대상에 대한 참조를 소유하므로 RV를 덮어 쓰면 참조가 파괴되고 그 결과 더 이상 도달 할 수없는 참조 대상이 파괴 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="abd7bedc3ca5ffad7ed1a2379448571632c9a196" translate="yes" xml:space="preserve">
          <source>Analogously to &lt;code&gt;pTHX&lt;/code&gt; , there are equivalent forms for when the macro is the first or last in multiple arguments, where an underscore represents a comma, i.e. &lt;code&gt;_aMY_CXT&lt;/code&gt; , &lt;code&gt;aMY_CXT_&lt;/code&gt; , &lt;code&gt;_pMY_CXT&lt;/code&gt; and &lt;code&gt;pMY_CXT_&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;pTHX&lt;/code&gt; 와 유사하게 매크로가 여러 인수에서 첫 번째 또는 마지막 인 경우와 동등한 형식이 있습니다. 밑줄은 &lt;code&gt;_aMY_CXT&lt;/code&gt; , &lt;code&gt;aMY_CXT_&lt;/code&gt; , &lt;code&gt;_pMY_CXT&lt;/code&gt; 및 &lt;code&gt;pMY_CXT_&lt;/code&gt; 와 같이 쉼표를 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="39d947054eb91fd720a6dfc1c92ebab2af540974" translate="yes" xml:space="preserve">
          <source>Analogously to &lt;code&gt;pTHX&lt;/code&gt;, there are equivalent forms for when the macro is the first or last in multiple arguments, where an underscore represents a comma, i.e. &lt;code&gt;_aMY_CXT&lt;/code&gt;, &lt;code&gt;aMY_CXT_&lt;/code&gt;, &lt;code&gt;_pMY_CXT&lt;/code&gt; and &lt;code&gt;pMY_CXT_&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;pTHX&lt;/code&gt; 와 유사하게 매크로가 여러 인수에서 첫 번째 또는 마지막 인 경우에 해당하는 형식이 있습니다. 여기서 밑줄은 쉼표를 나타냅니다 (예 : &lt;code&gt;_aMY_CXT&lt;/code&gt; , &lt;code&gt;aMY_CXT_&lt;/code&gt; , &lt;code&gt;_pMY_CXT&lt;/code&gt; 및 &lt;code&gt;pMY_CXT_&lt;/code&gt; ) .</target>
        </trans-unit>
        <trans-unit id="edf45b9159d8cf5fded0f359396c02baabcce4fe" translate="yes" xml:space="preserve">
          <source>Analyses the string in order to make fast searches on it using fbm_instr() -- the Boyer-Moore algorithm.</source>
          <target state="translated">Boyer-Moore 알고리즘 인 fbm_instr ()을 사용하여 빠르게 검색하기 위해 문자열을 분석합니다.</target>
        </trans-unit>
        <trans-unit id="69b405aab620184a43024659654fa4b84c6160c1" translate="yes" xml:space="preserve">
          <source>Analyzes the string in order to make fast searches on it using &lt;code&gt;fbm_instr()&lt;/code&gt; -- the Boyer-Moore algorithm.</source>
          <target state="translated">Boyer-Moore 알고리즘 인 &lt;code&gt;fbm_instr()&lt;/code&gt; 사용하여 문자열을 빠르게 검색하기 위해 문자열을 분석합니다 .</target>
        </trans-unit>
        <trans-unit id="b23a158b83cb28ac3361aeaadb0ea701f833add8" translate="yes" xml:space="preserve">
          <source>Anantha Kesari H Y (hyanantha@novell.com) Aditya C (caditya@novell.com)</source>
          <target state="translated">아 난타 케 사리 HY (hyanantha@novell.com) Aditya C (caditya@novell.com)</target>
        </trans-unit>
        <trans-unit id="e7694709c56de3564de85fb7f6b62bf3f9d5a2dd" translate="yes" xml:space="preserve">
          <source>Anatomy of .xs file</source>
          <target state="translated">.xs 파일 분석</target>
        </trans-unit>
        <trans-unit id="c371090fde9f09dd68fd0c025b019139f11c3b43" translate="yes" xml:space="preserve">
          <source>Anatomy of a typemap</source>
          <target state="translated">타입 맵 분석</target>
        </trans-unit>
        <trans-unit id="a01e33f4dcdb6ba1ae9f34a97cf8f6deeedf1a8d" translate="yes" xml:space="preserve">
          <source>And</source>
          <target state="translated">And</target>
        </trans-unit>
        <trans-unit id="126b187e44894c18f8676c982d3d84ada9d1092e" translate="yes" xml:space="preserve">
          <source>And &lt;a href=&quot;Bit::Vector&quot;&gt;Bit::Vector&lt;/a&gt; supports odd bit counts:</source>
          <target state="translated">그리고 &lt;a href=&quot;Bit::Vector&quot;&gt;Bit :: Vector&lt;/a&gt; 는 홀수 비트 수를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="56126a3ba8ff8d615bfc883458ff2ad74c4445f8" translate="yes" xml:space="preserve">
          <source>And &lt;a href=&quot;http://search.cpan.org/perldoc/Bit::Vector&quot;&gt;Bit::Vector&lt;/a&gt; supports odd bit counts:</source>
          <target state="translated">그리고 &lt;a href=&quot;http://search.cpan.org/perldoc/Bit::Vector&quot;&gt;Bit :: Vector&lt;/a&gt; 는 홀수 비트 수를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="0fdb46cc394058268f8370b027acd6f7507ad5af" translate="yes" xml:space="preserve">
          <source>And a print to show what values we're currently using:</source>
          <target state="translated">현재 사용중인 값을 보여주는 인쇄 :</target>
        </trans-unit>
        <trans-unit id="3e6cfdab3639e924ccc0236d51702eea17278fbe" translate="yes" xml:space="preserve">
          <source>And add the following code to Mytest.t, while incrementing the &quot;11&quot; tests to &quot;13&quot;:</source>
          <target state="translated">그리고 &quot;11&quot;테스트를 &quot;13&quot;으로 늘리면서 Mytest.t에 다음 코드를 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="7e934152fc5094b95aee4b1e3cfca4dfe3b716a5" translate="yes" xml:space="preserve">
          <source>And also add the following function definition to the end of the .xs file:</source>
          <target state="translated">또한 .xs 파일 끝에 다음 함수 정의를 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="e095a5f2bc9f3ebef8eb601baecde5aacc183619" translate="yes" xml:space="preserve">
          <source>And an even parity bit can be determined like this:</source>
          <target state="translated">그리고 짝수 패리티 비트는 다음과 같이 결정될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fa65fe1d258f3efe5fa4b14f6a4bdf869e0bca12" translate="yes" xml:space="preserve">
          <source>And don't forget, all commands but &lt;code&gt;=encoding&lt;/code&gt; last up until the end of its</source>
          <target state="translated">그리고 &lt;code&gt;=encoding&lt;/code&gt; 을 제외한 모든 명령 은 끝날 때까지 지속됩니다.</target>
        </trans-unit>
        <trans-unit id="d49f8a3fb63a02de3bc96673eb479046741fcd21" translate="yes" xml:space="preserve">
          <source>And elsewhere:</source>
          <target state="translated">그리고 다른 곳 :</target>
        </trans-unit>
        <trans-unit id="81cb3b2a1b531c9a6c9a5580cd54769bc7cdb329" translate="yes" xml:space="preserve">
          <source>And especially its subject 8.</source>
          <target state="translated">특히 주제 8.</target>
        </trans-unit>
        <trans-unit id="0d86ebfaa42125fcbf7621caf9b51d0d516488b0" translate="yes" xml:space="preserve">
          <source>And even if you take all the above into account, ANSI still lets this:</source>
          <target state="translated">그리고 위의 모든 사항을 고려하더라도 ANSI는 여전히 이것을 허용합니다.</target>
        </trans-unit>
        <trans-unit id="7a24c6f39dbf571ec01b5431e8552ecca7394253" translate="yes" xml:space="preserve">
          <source>And finally create a file Makefile.PL that looks like this:</source>
          <target state="translated">마지막으로 다음과 같은 Makefile.PL 파일을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="ae77b129ec8a4042483f52a6f594546db002727e" translate="yes" xml:space="preserve">
          <source>And finally we'll test that we don't make Unicode strings if &lt;code&gt;U&lt;/code&gt; is &lt;b&gt;not&lt;/b&gt; the first active format:</source>
          <target state="translated">마지막으로 &lt;code&gt;U&lt;/code&gt; 가 첫 번째 활성 형식 이 &lt;b&gt;아닌&lt;/b&gt; 경우 유니 코드 문자열을 만들지 않는지 테스트 합니다.</target>
        </trans-unit>
        <trans-unit id="a3e1249d44e165c645bd656a34581eba0f8a1e5b" translate="yes" xml:space="preserve">
          <source>And finally, END OF CHARMAP ends the section.</source>
          <target state="translated">마지막으로 CHAR OF CHARMAP은 섹션을 종료합니다.</target>
        </trans-unit>
        <trans-unit id="2d457e986a9ae5a62a56559cd5a194f65f8d8696" translate="yes" xml:space="preserve">
          <source>And finally, in list context, it will try to extract as many objects from the stream as it can find and return them, or the empty list otherwise. For this to work, there must be no separators (other than whitespace) between the JSON objects or arrays, instead they must be concatenated back-to-back. If an error occurs, an exception will be raised as in the scalar context case. Note that in this case, any previously-parsed JSON texts will be lost.</source>
          <target state="translated">마지막으로 목록 컨텍스트에서 스트림에서 개체를 찾아서 반환 할 수있는만큼 많은 개체를 추출하거나 그렇지 않으면 빈 목록을 추출하려고합니다. 이 작업을 수행하려면 JSON 개체 또는 배열 사이에 구분 기호 (공백 제외)가 없어야하며 대신 연속적으로 연결되어야합니다. 오류가 발생하면 스칼라 컨텍스트의 경우와 같이 예외가 발생합니다. 이 경우 이전에 구문 분석 된 모든 JSON 텍스트가 손실됩니다.</target>
        </trans-unit>
        <trans-unit id="0fa08a28d9fbfd1e04544d3cbe387157894102ef" translate="yes" xml:space="preserve">
          <source>And finally, the &lt;code&gt;//&lt;/code&gt; default delimiters for a match can be changed to arbitrary delimiters by putting an &lt;code&gt;'m'&lt;/code&gt; out front:</source>
          <target state="translated">마지막으로 &lt;code&gt;//&lt;/code&gt; 일치하는 기본 구분 기호는 &lt;code&gt;'m'&lt;/code&gt; 을 앞에 두어 임의의 구분 기호로 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8bfb479933b19ce9cc3cdcd7ea52e1ab56622323" translate="yes" xml:space="preserve">
          <source>And finally, the flag UNICODE_WARN_ILLEGAL_INTERCHANGE selects all four of the above WARN flags; and UNICODE_DISALLOW_ILLEGAL_INTERCHANGE selects all four DISALLOW flags.</source>
          <target state="translated">마지막으로 UNICODE_WARN_ILLEGAL_INTERCHANGE 플래그는 위의 WARN 플래그 4 개를 모두 선택합니다. UNICODE_DISALLOW_ILLEGAL_INTERCHANGE는 4 개의 DISALLOW 플래그를 모두 선택합니다.</target>
        </trans-unit>
        <trans-unit id="805a895ac4ae294cb6372936f60badec42431ba0" translate="yes" xml:space="preserve">
          <source>And get the correct results.</source>
          <target state="translated">정확한 결과를 얻으십시오.</target>
        </trans-unit>
        <trans-unit id="e2f2205f3663f3c210b60bce452eee7ce9387b44" translate="yes" xml:space="preserve">
          <source>And have a look at the return value:</source>
          <target state="translated">그리고 반환 값을 살펴보십시오.</target>
        </trans-unit>
        <trans-unit id="fbc4c3241647a832011ec07f9650e675a0c500ca" translate="yes" xml:space="preserve">
          <source>And here are some alternative portable ways to write them:</source>
          <target state="translated">그리고 그것들을 쓸 수있는 다른 휴대용 방법들이 있습니다 :</target>
        </trans-unit>
        <trans-unit id="dd7d82addca3d88c7a2654bf3c9e6dcef14475a8" translate="yes" xml:space="preserve">
          <source>And here is an example of</source>
          <target state="translated">그리고 여기에 예가 있습니다</target>
        </trans-unit>
        <trans-unit id="d607f0d907db7da1691c33f97b8d6b2f2769c71d" translate="yes" xml:space="preserve">
          <source>And here is some Perl to test it.</source>
          <target state="translated">그리고 여기 펄이 있습니다.</target>
        </trans-unit>
        <trans-unit id="eae54ac5b1d17fae865a39da8414bc4e94611b48" translate="yes" xml:space="preserve">
          <source>And here is the function from</source>
          <target state="translated">그리고 여기의 기능은</target>
        </trans-unit>
        <trans-unit id="97a015e04d33b93191e1790b436d13c5a1d0ec08" translate="yes" xml:space="preserve">
          <source>And here is the previous example modified to use the &lt;code&gt;comment&lt;/code&gt; method (which requires the tied object):</source>
          <target state="translated">그리고 &lt;code&gt;comment&lt;/code&gt; 메소드 (연결된 객체가 필요함) 를 사용하도록 수정 된 이전 예제 는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="949c884471ed5b1d107f6efb48c3d4a2b28f9c98" translate="yes" xml:space="preserve">
          <source>And here it is as a subroutine, modeled after the above:</source>
          <target state="translated">그리고 여기에 위의 모델을 모델로 한 서브 루틴이 있습니다 :</target>
        </trans-unit>
        <trans-unit id="33110031311636694f867a410fcd13fa8bb80c0c" translate="yes" xml:space="preserve">
          <source>And here's a corresponding server to go along with it. We'll leave the address as &lt;code&gt;INADDR_ANY&lt;/code&gt; so that the kernel can choose the appropriate interface on multihomed hosts. If you want sit on a particular interface (like the external side of a gateway or firewall machine), fill this in with your real address instead.</source>
          <target state="translated">그리고 여기에 해당 서버가 있습니다. 커널이 멀티 홈 호스트에서 적절한 인터페이스를 선택할 수 있도록 주소를 &lt;code&gt;INADDR_ANY&lt;/code&gt; 로 유지합니다. 게이트웨이 나 방화벽 시스템의 외부와 같은 특정 인터페이스에 앉아 싶다면 실제 주소로 대신 채우십시오.</target>
        </trans-unit>
        <trans-unit id="dbd6a4af2108db6ae982ecf10d7522ed7e526a16" translate="yes" xml:space="preserve">
          <source>And here's a corresponding server. You don't have to worry about silly network terminators here because Unix domain sockets are guaranteed to be on the localhost, and thus everything works right.</source>
          <target state="translated">그리고 여기 해당 서버가 있습니다. 유닉스 도메인 소켓이 로컬 호스트에 보장되므로 모든 것이 올바르게 작동하기 때문에 바보 같은 네트워크 터미네이터에 대해 걱정할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="944b5652f25ab675361c7efd6d5681a5765fc752" translate="yes" xml:space="preserve">
          <source>And here's a multitasking version. It's multitasked in that like most typical servers, it spawns (fork()s) a slave server to handle the client request so that the master server can quickly go back to service a new client.</source>
          <target state="translated">그리고 멀티 태스킹 버전이 있습니다. 가장 일반적인 서버와 마찬가지로 멀티 태스킹되어 마스터 서버가 신속하게 새 클라이언트 서비스를 다시 시작할 수 있도록 클라이언트 요청을 처리하기 위해 슬레이브 서버를 생성 (fork ())합니다.</target>
        </trans-unit>
        <trans-unit id="412d21e904b4a5d9be299f9e46dd7d8fb8650015" translate="yes" xml:space="preserve">
          <source>And here's a reimplementation of the Perl &lt;code&gt;&lt;a href=&quot;functions/grep&quot;&gt;grep&lt;/a&gt;&lt;/code&gt; operator:</source>
          <target state="translated">다음은 Perl &lt;code&gt;&lt;a href=&quot;functions/grep&quot;&gt;grep&lt;/a&gt;&lt;/code&gt; 연산자를 다시 구현 한 것입니다 .</target>
        </trans-unit>
        <trans-unit id="328ddc059366c7b26584066902e71a55942bcb50" translate="yes" xml:space="preserve">
          <source>And here's a reimplementation of the Perl &lt;code&gt;grep&lt;/code&gt; operator:</source>
          <target state="translated">다음은 Perl &lt;code&gt;grep&lt;/code&gt; 연산자를 다시 구현 한 것입니다 .</target>
        </trans-unit>
        <trans-unit id="a39e0321aadc55f074a271968aaa41d7162f8c6f" translate="yes" xml:space="preserve">
          <source>And here's a safe pipe open for writing:</source>
          <target state="translated">그리고 여기에는 글을 쓸 수있는 안전한 파이프가 있습니다 :</target>
        </trans-unit>
        <trans-unit id="e0737e576532a52571f2f02f804f1b9fffb668de" translate="yes" xml:space="preserve">
          <source>And here's how it could be (ab)used:</source>
          <target state="translated">그리고 그것이 어떻게 사용될 수 있는지는 다음과 같습니다 :</target>
        </trans-unit>
        <trans-unit id="9d8d64c2d75cb873a59d78e68255422a53fcc02a" translate="yes" xml:space="preserve">
          <source>And here's how to start up a child process you intend to read from:</source>
          <target state="translated">다음은 읽을 자식 프로세스를 시작하는 방법입니다.</target>
        </trans-unit>
        <trans-unit id="4c941c96c3f11d53f1f07f2e00498b7a8046f1f0" translate="yes" xml:space="preserve">
          <source>And here's the &lt;code&gt;HotKey&lt;/code&gt; module, which hides the somewhat mystifying calls to manipulate the POSIX termios structures.</source>
          <target state="translated">그리고 여기 에 POSIX termios 구조를 조작하기위한 다소 신비로운 호출을 숨기는 &lt;code&gt;HotKey&lt;/code&gt; 모듈이 있습니다.</target>
        </trans-unit>
        <trans-unit id="c1de37a9a564348e268bb7765797260079df1212" translate="yes" xml:space="preserve">
          <source>And if it's an integer</source>
          <target state="translated">그리고 정수라면</target>
        </trans-unit>
        <trans-unit id="1e83d880ce4037fe2787ac7496582407c6b33838" translate="yes" xml:space="preserve">
          <source>And if the protocol you're using supports a way of letting the recipient know which character encoding you used, please help the receiving end by using that feature! For example, E-mail and HTTP support MIME headers, so you can use the &lt;code&gt;Content-Type&lt;/code&gt; header. They can also have &lt;code&gt;Content-Length&lt;/code&gt; to indicate the number of</source>
          <target state="translated">그리고 사용중인 프로토콜이 수신자에게 사용중인 문자 인코딩을 알려주는 방법을 지원하는 경우 해당 기능을 사용하여 수신 끝을 도와주세요! 예를 들어 전자 메일 및 HTTP는 MIME 헤더를 지원하므로 &lt;code&gt;Content-Type&lt;/code&gt; 헤더를 사용할 수 있습니다 . 또한 &lt;code&gt;Content-Length&lt;/code&gt; 를 사용하여</target>
        </trans-unit>
        <trans-unit id="c041e6b2053eeffc72c3a76864ceba40caffea7d" translate="yes" xml:space="preserve">
          <source>And if you used &lt;code&gt;&quot;*&quot;&lt;/code&gt;'s in the internal groups instead of limiting them to 0 through 5 matches, then it would take forever--or until you ran out of stack space. Moreover, these internal optimizations are not always applicable. For example, if you put &lt;code&gt;{0,5}&lt;/code&gt; instead of &lt;code&gt;&quot;*&quot;&lt;/code&gt; on the external group, no current optimization is applicable, and the match takes a long time to finish.</source>
          <target state="translated">그리고 내부 그룹에서 &lt;code&gt;&quot;*&quot;&lt;/code&gt; 를 0에서 5까지의 일치로 제한하는 대신 사용했다면 영원히 또는 스택 공간이 부족해질 때까지 걸릴 것입니다. 또한 이러한 내부 최적화가 항상 적용되는 것은 아닙니다. 예를 들어 외부 그룹에 &lt;code&gt;&quot;*&quot;&lt;/code&gt; 대신 &lt;code&gt;{0,5}&lt;/code&gt; 를 입력하면 현재 최적화를 적용 할 수 없으며 일치를 완료하는 데 오랜 시간이 걸립니다.</target>
        </trans-unit>
        <trans-unit id="530bb41f401dd9a37c76bab8cac0844cf9ab82e0" translate="yes" xml:space="preserve">
          <source>And if you used &lt;code&gt;*&lt;/code&gt; 's in the internal groups instead of limiting them to 0 through 5 matches, then it would take forever--or until you ran out of stack space. Moreover, these internal optimizations are not always applicable. For example, if you put &lt;code&gt;{0,5}&lt;/code&gt; instead of &lt;code&gt;*&lt;/code&gt; on the external group, no current optimization is applicable, and the match takes a long time to finish.</source>
          <target state="translated">그리고 내부 그룹에서 &lt;code&gt;*&lt;/code&gt; 를 사용 하여 0 ~ 5 일치로 제한하지 않으면 영원히 또는 스택 공간이 부족해질 때까지 시간이 걸립니다. 또한 이러한 내부 최적화가 항상 적용 가능한 것은 아닙니다. 예를 들어 외부 그룹 에 &lt;code&gt;*&lt;/code&gt; 대신 &lt;code&gt;{0,5}&lt;/code&gt; 를 입력하면 현재 최적화가 적용되지 않으며 일치하는 데 시간이 오래 걸립니다.</target>
        </trans-unit>
        <trans-unit id="85fb030d5b378f589d8d5a1abf4a0effa17a51ec" translate="yes" xml:space="preserve">
          <source>And if you want to repeat any previous command, use the exclamation: '&lt;b&gt;!&lt;/b&gt;':</source>
          <target state="translated">이전 명령을 반복하려면 느낌표를 사용하십시오. ' &lt;b&gt;! &lt;/b&gt;':</target>
        </trans-unit>
        <trans-unit id="e2e9c56949878c68d60537e13a0fee819e61a651" translate="yes" xml:space="preserve">
          <source>And if you want to update your remote-tracking branches for all defined remotes simultaneously you can do</source>
          <target state="translated">정의 된 모든 원격에 대한 원격 추적 분기를 동시에 업데이트하려면 다음을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="81ee0ae161979dc9986599ac47ae17f4297a5e95" translate="yes" xml:space="preserve">
          <source>And if you wanted to list line 5 again, type 'l 5', (note the space):</source>
          <target state="translated">5 행을 다시 나열하려면 'l 5'를 입력하십시오 (공백에 유의하십시오).</target>
        </trans-unit>
        <trans-unit id="749d2869c6a2cd1160d264bfc5684c9df865e407" translate="yes" xml:space="preserve">
          <source>And if you're not writing a formatter class, but are instead just writing a program that does something simple with a Pod::PullParser object (and not an object of a subclass), then there's no reason to bother subclassing to add a &lt;code&gt;run&lt;/code&gt; method.</source>
          <target state="translated">그리고 포매터 클래스를 작성하지 않고 대신 Pod :: PullParser 객체 (하위 클래스의 객체가 아님)를 사용하여 간단한 작업을 수행하는 프로그램을 작성하는 경우 하위 클래스를 작성하여 &lt;code&gt;run&lt;/code&gt; 을 추가 할 이유가 없습니다. 방법.</target>
        </trans-unit>
        <trans-unit id="a90e884faa57a601f440de65c751d0540510d763" translate="yes" xml:space="preserve">
          <source>And in gdb do:</source>
          <target state="translated">그리고 gdb에서 :</target>
        </trans-unit>
        <trans-unit id="81cf331b9c5b31a88becd7901f7891213a4ee929" translate="yes" xml:space="preserve">
          <source>And in gdb:</source>
          <target state="translated">그리고 gdb에서 :</target>
        </trans-unit>
        <trans-unit id="46441ba6d0d6e8d0a7cff3ad4e65de9157fcaa3a" translate="yes" xml:space="preserve">
          <source>And in the special case of Unix value 1 the encoding is:</source>
          <target state="translated">그리고 유닉스 값 1의 특별한 경우 인코딩은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c703bcbb84cf0b00ade16c5fcf17098b7ecf2788" translate="yes" xml:space="preserve">
          <source>And it worked; nowadays, those legacy standards are rarely used. Most everyone uses Unicode.</source>
          <target state="translated">그리고 그것은 효과가 있었다. 요즘에는 이러한 레거시 표준이 거의 사용되지 않습니다. 대부분의 사람들은 유니 코드를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="54037314563b22510a39098497cd62d4a291d5ca" translate="yes" xml:space="preserve">
          <source>And it'll be faster, too, since we can begin processing the program's stdout immediately, rather than waiting for the program to finish.</source>
          <target state="translated">또한 프로그램이 끝날 때까지 기다리지 않고 프로그램의 stdout 처리를 즉시 시작할 수 있기 때문에 속도도 더 빠릅니다.</target>
        </trans-unit>
        <trans-unit id="05b8d44f52c6cb1137bdef7406a03b86305390f3" translate="yes" xml:space="preserve">
          <source>And just before we start the loop, we'll set &lt;code&gt;patcopy&lt;/code&gt; to be the start of &lt;code&gt;pat&lt;/code&gt; :</source>
          <target state="translated">루프를 시작하기 직전에 &lt;code&gt;patcopy&lt;/code&gt; 를 &lt;code&gt;pat&lt;/code&gt; 의 시작으로 설정합니다 .</target>
        </trans-unit>
        <trans-unit id="1283b8c922466a3c7b07d1feee37151a4dce3090" translate="yes" xml:space="preserve">
          <source>And just before we start the loop, we'll set &lt;code&gt;patcopy&lt;/code&gt; to be the start of &lt;code&gt;pat&lt;/code&gt;:</source>
          <target state="translated">루프를 시작하기 직전에 &lt;code&gt;patcopy&lt;/code&gt; 를 &lt;code&gt;pat&lt;/code&gt; 의 시작으로 설정합니다 .</target>
        </trans-unit>
        <trans-unit id="5d9997bbf1b12f8dbc675ed04e53a7e01c218a79" translate="yes" xml:space="preserve">
          <source>And just use a multilevel hash to start with.</source>
          <target state="translated">다단계 해시를 사용하여 시작하십시오.</target>
        </trans-unit>
        <trans-unit id="6f762806ee86000a08af1e9120bb69dbd27df3b8" translate="yes" xml:space="preserve">
          <source>And let's have a look at it:</source>
          <target state="translated">그리고 살펴 보자.</target>
        </trans-unit>
        <trans-unit id="2fcd80e8aae7192e91938fbeb5e4135bca3cc513" translate="yes" xml:space="preserve">
          <source>And likewise, the &lt;code&gt;UNICODE_WARN_SUPER&lt;/code&gt; and &lt;code&gt;UNICODE_DISALLOW_SUPER&lt;/code&gt; flags affect the handling of code points that are above the Unicode maximum of 0x10FFFF. Languages other than Perl may not be able to accept files that contain these.</source>
          <target state="translated">마찬가지로 &lt;code&gt;UNICODE_WARN_SUPER&lt;/code&gt; 및 &lt;code&gt;UNICODE_DISALLOW_SUPER&lt;/code&gt; 플래그는 유니 코드 최대 값 인 0x10FFFF를 초과하는 코드 포인트 처리에 영향을줍니다. Perl 이외의 언어는이를 포함하는 파일을 허용하지 못할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3304a768e2182435437e989432d9119802e93fc2" translate="yes" xml:space="preserve">
          <source>And locally for months:</source>
          <target state="translated">그리고 몇 달 동안 현지에서 :</target>
        </trans-unit>
        <trans-unit id="a3a5e5aaccae80b6482e3c73484c3e27d16e3695" translate="yes" xml:space="preserve">
          <source>And make sure the '|1' or '|3' entry FOLLOWS the '|0' entry.</source>
          <target state="translated">'| 1'또는 '| 3'항목이 '| 0'항목을 따라야합니다.</target>
        </trans-unit>
        <trans-unit id="13b0bb554f54abc8fbffc8c8994d2d663c4a335c" translate="yes" xml:space="preserve">
          <source>And make the &lt;code&gt;SHELL&lt;/code&gt; environment variable point to this</source>
          <target state="translated">그리고 &lt;code&gt;SHELL&lt;/code&gt; 환경 변수가 이것을 가리 키도록하십시오</target>
        </trans-unit>
        <trans-unit id="be7020a4d943fe59e561bee80058c6fdc65ab9a2" translate="yes" xml:space="preserve">
          <source>And more miscellaneous functions:</source>
          <target state="translated">그리고 더 많은 기타 기능 :</target>
        </trans-unit>
        <trans-unit id="a60081f8386184766dad1be5fdc437aa5eeeb0e1" translate="yes" xml:space="preserve">
          <source>And note that unlike the first example, this will permanently set &lt;code&gt;$^W&lt;/code&gt; since it cannot both run during compile-time and be localized to a run-time block.</source>
          <target state="translated">첫 번째 예제와 달리 &lt;code&gt;$^W&lt;/code&gt; 는 컴파일 타임 동안 실행될 수없고 런타임 블록으로 지역화 될 수 없기 때문에 영구적으로 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="804a1ae29f0ee92582bcfc8bf24a3ed82f77d6d1" translate="yes" xml:space="preserve">
          <source>And note, that some items returned by &lt;code&gt;Localeconv&lt;/code&gt; are available through &lt;a href=&quot;perlapi#Perl_langinfo&quot;&gt;&quot;Perl_langinfo&quot; in perlapi&lt;/a&gt;.</source>
          <target state="translated">그리고 &lt;code&gt;Localeconv&lt;/code&gt; 에서 반환 된 일부 항목은 perlapi의 &lt;a href=&quot;perlapi#Perl_langinfo&quot;&gt;&quot;Perl_langinfo&quot;를&lt;/a&gt; 통해 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d2abac4d1c06c7d4176cadc5fbb88490348f44bd" translate="yes" xml:space="preserve">
          <source>And now some examples as a list operator:</source>
          <target state="translated">그리고 이제리스트 연산자로서의 몇 가지 예 :</target>
        </trans-unit>
        <trans-unit id="325f253298d4946260db0eee17abb5d004c58cf0" translate="yes" xml:space="preserve">
          <source>And now the Perl program calling &lt;code&gt;tzname&lt;/code&gt; , the two values will be assigned as in:</source>
          <target state="translated">이제 &lt;code&gt;tzname&lt;/code&gt; 을 호출하는 Perl 프로그램 에서 두 값이 다음과 같이 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="f59e966510e8c065dbf5dc3f3cc9146205ad5af4" translate="yes" xml:space="preserve">
          <source>And now the Perl program calling &lt;code&gt;tzname&lt;/code&gt;, the two values will be assigned as in:</source>
          <target state="translated">이제 &lt;code&gt;tzname&lt;/code&gt; 을 호출하는 Perl 프로그램 에서 두 값이 다음과 같이 할당됩니다.</target>
        </trans-unit>
        <trans-unit id="22d6d0f0cc9d0f09a7a155f9b933e949a3d93b8d" translate="yes" xml:space="preserve">
          <source>And now when we run it, we get &quot;\n&quot; still, but at least we know why. Just getting this script to compile has exposed the '$varl' (with the letter 'l') variable, and simply changing $varl to $var1 solves the problem.</source>
          <target state="translated">그리고 우리가 그것을 실행할 때, 우리는 여전히 &quot;\ n&quot;을 얻지 만, 적어도 우리는 이유를 알고 있습니다. 이 스크립트를 컴파일하면 '$ varl'(문자 'l') 변수가 노출되고 $ varl을 $ var1로 변경하면 문제가 해결됩니다.</target>
        </trans-unit>
        <trans-unit id="5ed144a58c9fd20df52c8636158ebb39098e1299" translate="yes" xml:space="preserve">
          <source>And now whenever either of those variables is accessed, its current system priority is retrieved and returned. If those variables are set, then the process's priority is changed!</source>
          <target state="translated">이제 이러한 변수 중 하나에 액세스 할 때마다 현재 시스템 우선 순위가 검색되어 리턴됩니다. 해당 변수가 설정되면 프로세스 우선 순위가 변경됩니다!</target>
        </trans-unit>
        <trans-unit id="f9560789fd59b77ec60e56d7ede2c768c8b84e1a" translate="yes" xml:space="preserve">
          <source>And now you will only have duplicates when the keys themselves are truly the same. (note: in versions of the db library prior to about November 1996, such duplicate keys were retained so it was possible to recover the original keys in sets of keys that compared as equal).</source>
          <target state="translated">이제는 키 자체가 완전히 동일한 경우에만 복제본을 갖게됩니다. (참고 : 1996 년 11 월 이전의 db 라이브러리 버전에서는 이러한 중복 키가 유지되었으므로 동일한 키 세트로 원래 키를 복구 할 수있었습니다).</target>
        </trans-unit>
        <trans-unit id="5a5750ab899553015c34706ef7f35d79aa761c9c" translate="yes" xml:space="preserve">
          <source>And of course a very basic test:</source>
          <target state="translated">물론 매우 기본적인 테스트 :</target>
        </trans-unit>
        <trans-unit id="892ba36b3022eacc3edbb4c21af99c36c593d715" translate="yes" xml:space="preserve">
          <source>And on the off chance you need a literal tilde in a bracket expression, you get it with &quot;~~&quot;.</source>
          <target state="translated">그리고 오프 기회에 당신은 대괄호 표현에 문자 물결표가 필요합니다, 당신은 그것을 &quot;~~&quot;로 얻습니다.</target>
        </trans-unit>
        <trans-unit id="7c31eaf7ebf6ce5c72185594ad0e1b74e04b6fe1" translate="yes" xml:space="preserve">
          <source>And only on Solaris 8 you also need:</source>
          <target state="translated">또한 Solaris 8에서만 다음이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="15fba9c4eb39007661b94becfb32901d56aa6cd3" translate="yes" xml:space="preserve">
          <source>And only the last two of these match:</source>
          <target state="translated">그리고이 중 마지막 두 개만 일치합니다.</target>
        </trans-unit>
        <trans-unit id="96df95971f3fa6b1c473a349d8884984b667322b" translate="yes" xml:space="preserve">
          <source>And other assignment variations are analogous to &lt;code&gt;'+='&lt;/code&gt; and &lt;code&gt;'-='&lt;/code&gt; (and similar to &lt;code&gt;'.='&lt;/code&gt; and &lt;code&gt;'x='&lt;/code&gt; above):</source>
          <target state="translated">다른 할당 변형은 &lt;code&gt;'+='&lt;/code&gt; 및 &lt;code&gt;'-='&lt;/code&gt; 와 유사합니다 (위의 &lt;code&gt;'.='&lt;/code&gt; 및 &lt;code&gt;'x='&lt;/code&gt; 와 유사 ).</target>
        </trans-unit>
        <trans-unit id="efa161d50be827f153878be8fe5d6eeddd3f9aab" translate="yes" xml:space="preserve">
          <source>And perhaps most importantly, keep the items consistent: either use &quot;=item *&quot; for all of them, to produce bullets; or use &quot;=item 1.&quot;, &quot;=item 2.&quot;, etc., to produce numbered lists; or use &quot;=item foo&quot;, &quot;=item bar&quot;, etc.--namely, things that look nothing like bullets or numbers.</source>
          <target state="translated">그리고 아마도 가장 중요한 것은 항목을 일관성있게 유지하는 것입니다. 모든 항목에 &quot;= item *&quot;를 사용하여 글 머리 기호를 생성하십시오. 또는 &quot;= 항목 1&quot;, &quot;= 항목 2&quot;등을 사용하여 번호 매기기 목록을 생성하십시오. 또는 &quot;= item foo&quot;, &quot;= item bar&quot;등을 사용하십시오. 즉, 글 머리 기호 나 숫자처럼 보이지 않는 것입니다.</target>
        </trans-unit>
        <trans-unit id="ac0a1fd097b0dfd986a143395713cf6857292218" translate="yes" xml:space="preserve">
          <source>And perhaps most importantly, keep the items consistent: either use &quot;=item *&quot; for all of them, to produce bullets; or use &quot;=item 1.&quot;, &quot;=item 2.&quot;, etc., to produce numbered lists; or use &quot;=item foo&quot;, &quot;=item bar&quot;, etc.--namely, things that look nothing like bullets or numbers. (If you have a list that contains both: 1) things that don't look like bullets nor numbers, plus 2) things that do, you should preface the bullet- or number-like items with &lt;code&gt;Z&amp;lt;&amp;gt;&lt;/code&gt;. See &lt;a href=&quot;#Z%3C%3E-a-null-%28zero-effect%29-formatting-code&quot;&gt;Z&amp;lt;&amp;gt;&lt;/a&gt; below for an example.)</source>
          <target state="translated">그리고 아마도 가장 중요한 것은 항목을 일관되게 유지하는 것입니다. 총알을 생성하려면 모든 항목에 대해 &quot;= item *&quot;을 사용하십시오. 또는 &quot;= item 1&quot;, &quot;= item 2.&quot;등을 사용하여 번호가 매겨진 목록을 생성합니다. 또는 &quot;= item foo&quot;, &quot;= item bar&quot;등을 사용합니다. 즉, 글 머리 기호 나 숫자처럼 보이지 않는 것입니다. (두 가지가 모두 포함 된 목록이있는 경우 : 1) 글 머리 기호 나 숫자처럼 보이지 않는 것, 2) 그런 것, 글 머리 기호 또는 숫자와 같은 항목 앞에 &lt;code&gt;Z&amp;lt;&amp;gt;&lt;/code&gt; 붙여야 합니다. 예제는 아래 &lt;a href=&quot;#Z%3C%3E-a-null-%28zero-effect%29-formatting-code&quot;&gt;Z &amp;lt;&amp;gt;를&lt;/a&gt; 참조하십시오 .)</target>
        </trans-unit>
        <trans-unit id="b837400890ba807a5f5e88629d11f36f624c30a2" translate="yes" xml:space="preserve">
          <source>And pull new changes from the repository, and update your local repository (must be clean first)</source>
          <target state="translated">그리고 저장소에서 새 변경 사항을 가져 와서 로컬 저장소를 업데이트합니다 (먼저 깨끗해야 함)</target>
        </trans-unit>
        <trans-unit id="3abab37034be7516f5a858adebbbb45b8ced8395" translate="yes" xml:space="preserve">
          <source>And push the branch to your fork:</source>
          <target state="translated">분기를 포크로 밉니다.</target>
        </trans-unit>
        <trans-unit id="f91e4f8b7302927647ddce5513c00f7d31bca99b" translate="yes" xml:space="preserve">
          <source>And since we're on that subject ...</source>
          <target state="translated">그리고 우리가 그 주제에 있기 때문에 ...</target>
        </trans-unit>
        <trans-unit id="787438686ae95a1032fa3a9e1aa177c6c4fd8565" translate="yes" xml:space="preserve">
          <source>And so do these:</source>
          <target state="translated">그리고 이것도 마찬가지입니다 :</target>
        </trans-unit>
        <trans-unit id="d57613d3e5e04fb527cb785d3cbc34d0addd45d8" translate="yes" xml:space="preserve">
          <source>And some of the entries are marked as &quot;undocumented&quot;. This means that they aren't necessarily considered stable, and could be changed or removed in some future release without warning. It is therefore a bad idea to use them without further checking. It could be that these are considered to be for perl core use only; or it could be, though, that &lt;code&gt;Devel::PPPort&lt;/code&gt; doesn't know where to find their documentation, or that it's just an oversight that they haven't been documented. If you want to use one, and potentially have it backported, first send mail to &lt;a href=&quot;mailto:perl5-porters@perl.org&quot;&gt;mailto:perl5-porters@perl.org&lt;/a&gt;.</source>
          <target state="translated">그리고 일부 항목은 &quot;문서화되지 않음&quot;으로 표시됩니다. 즉, 반드시 안정적인 것으로 간주되는 것은 아니며 일부 향후 릴리스에서 경고없이 변경 또는 제거 될 수 있습니다. 따라서 더 이상 확인하지 않고 사용하는 것은 좋지 않습니다. 이는 펄 코어 전용으로 간주 될 수 있습니다. 또는 &lt;code&gt;Devel::PPPort&lt;/code&gt; 가 문서를 어디에서 찾을 수 있는지 모르거나 문서화되지 않은 감독 일 수도 있습니다. 하나를 사용하고 잠재적으로 백 포트되도록하려면 먼저 &lt;a href=&quot;mailto:perl5-porters@perl.org&quot;&gt;mailto : perl5-porters@perl.org로&lt;/a&gt; 메일을 보내 십시오 .</target>
        </trans-unit>
        <trans-unit id="58a765d6600ae95d5f3b4bad120d6d7aba62ac6d" translate="yes" xml:space="preserve">
          <source>And success is always the value 0 in all behaviors.</source>
          <target state="translated">그리고 모든 행동에서 성공은 항상 0입니다.</target>
        </trans-unit>
        <trans-unit id="438bed71f720bad1480f9f02fbee09a0688495fa" translate="yes" xml:space="preserve">
          <source>And suppose then that you answer client requests for language $wanted by just looking up $greetings{$wanted}.</source>
          <target state="translated">그리고 $ greetings {$ wanted}를 조회하여 $ wanted 언어에 대한 클라이언트 요청에 응답한다고 가정하십시오.</target>
        </trans-unit>
        <trans-unit id="2669b5893403010caa914594080405bbbce0ff5c" translate="yes" xml:space="preserve">
          <source>And suppose you write a program that reads that file and then runs as a daemon, answering client requests that specify a language tag and then expect the string that says how to greet in that language. So an interaction looks like:</source>
          <target state="translated">그리고 해당 파일을 읽고 데몬으로 실행하는 프로그램을 작성하여 언어 태그를 지정하는 클라이언트 요청에 응답 한 다음 해당 언어로 인사하는 방법을 나타내는 문자열을 기대한다고 가정하십시오. 상호 작용은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2df99fba715f8ad036f73439b0d1c572a25bb0d8" translate="yes" xml:space="preserve">
          <source>And that does the Right Thing.</source>
          <target state="translated">그리고 그것은 옳은 일을합니다.</target>
        </trans-unit>
        <trans-unit id="f185ef04d67f1d1642dde1d5aaeb827268181df4" translate="yes" xml:space="preserve">
          <source>And that's where the first quirk strikes: &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; templates have to be stuffed with &lt;code&gt;x&lt;/code&gt; codes to get those extra fill bytes.</source>
          <target state="translated">그리고 첫 번째 단점은 &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; 템플릿에 여분의 채우기 바이트를 얻기 위해 &lt;code&gt;x&lt;/code&gt; 코드 가 채워져 있어야한다는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="faa61c2d15a96573c75e47bc47738ee4332bd44e" translate="yes" xml:space="preserve">
          <source>And that's where the first quirk strikes: &lt;code&gt;pack&lt;/code&gt; and &lt;code&gt;unpack&lt;/code&gt; templates have to be stuffed with &lt;code&gt;x&lt;/code&gt; codes to get those extra fill bytes.</source>
          <target state="translated">그리고 첫 번째 특질 파업의 것을 : &lt;code&gt;pack&lt;/code&gt; 및 &lt;code&gt;unpack&lt;/code&gt; 템플릿을 박제 할 필요가 &lt;code&gt;x&lt;/code&gt; 코드는 그 여분의 채우기 바이트를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1c2e146487dcd6b006ca0fe732ee06c5f66c58a6" translate="yes" xml:space="preserve">
          <source>And the &lt;code&gt;*&lt;/code&gt; quantifier (or its equivalent &lt;code&gt;(0,}&lt;/code&gt;) is illegal.</source>
          <target state="translated">그리고 &lt;code&gt;*&lt;/code&gt; 수량 자 (또는 이에 상응하는 &lt;code&gt;(0,}&lt;/code&gt; )는 불법입니다.</target>
        </trans-unit>
        <trans-unit id="69c7d2fddd9456e1d45eb87fbe318da0c23d0419" translate="yes" xml:space="preserve">
          <source>And the removal of:</source>
          <target state="translated">그리고 제거 :</target>
        </trans-unit>
        <trans-unit id="6321b918eecf63aae95252ec27d4a4007661cbea" translate="yes" xml:space="preserve">
          <source>And then at least you can use the values(), which will be real refs, instead of the keys(), which won't.</source>
          <target state="translated">그런 다음 적어도 keys () 대신 values ​​()를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4c721f20845157aa106a3ca5329f5d50475f12f2" translate="yes" xml:space="preserve">
          <source>And then hard-code it, leaving porting as an exercise to your successor.</source>
          <target state="translated">그런 다음 하드 코딩하여 후임자에게 연습으로 남겨 두십시오.</target>
        </trans-unit>
        <trans-unit id="47e6e2e5fec5f13213aa3c81c38b973ca1f59e41" translate="yes" xml:space="preserve">
          <source>And then instead of storing the compiled value in the lexicon hash it will store it in $lh-&amp;gt;{'_external_lex_cache'}</source>
          <target state="translated">그리고 어휘집에 컴파일 된 값을 저장하는 대신 $ lh-&amp;gt; { '_ external_lex_cache'}에 저장합니다</target>
        </trans-unit>
        <trans-unit id="4ddb0364527af5ee5b5762f819c0ea16f6ac0a17" translate="yes" xml:space="preserve">
          <source>And then open as before, choosing &lt;code&gt;&quot;&amp;lt;&quot;&lt;/code&gt; , &lt;code&gt;&quot;&amp;gt;&amp;gt;&quot;&lt;/code&gt; , or &lt;code&gt;&quot;&amp;gt;&quot;&lt;/code&gt; as needed:</source>
          <target state="translated">그런 다음 &lt;code&gt;&quot;&amp;lt;&quot;&lt;/code&gt; , &lt;code&gt;&quot;&amp;gt;&amp;gt;&quot;&lt;/code&gt; 를 선택하여 이전과 같이 엽니 다. 필요에 따라 또는 &lt;code&gt;&quot;&amp;gt;&quot;&lt;/code&gt; 를 .</target>
        </trans-unit>
        <trans-unit id="c1e2199a985f69bef0e671090e4f82d7d27c974b" translate="yes" xml:space="preserve">
          <source>And then open as before, choosing &lt;code&gt;&quot;&amp;lt;&quot;&lt;/code&gt;, &lt;code&gt;&quot;&amp;gt;&amp;gt;&quot;&lt;/code&gt;, or &lt;code&gt;&quot;&amp;gt;&quot;&lt;/code&gt; as needed:</source>
          <target state="translated">그런 다음 필요에 따라 &lt;code&gt;&quot;&amp;lt;&quot;&lt;/code&gt; , &lt;code&gt;&quot;&amp;gt;&amp;gt;&quot;&lt;/code&gt; 또는 &lt;code&gt;&quot;&amp;gt;&quot;&lt;/code&gt; 를 선택하여 이전과 같이 엽니 다 .</target>
        </trans-unit>
        <trans-unit id="733e92d2677896a5105fc9334a5547dcbabc4286" translate="yes" xml:space="preserve">
          <source>And then provide a typemap entry &lt;code&gt;T_PTROBJ_SPECIAL&lt;/code&gt; that maps underscores to double-colons (::), and declare &lt;code&gt;Net_Config&lt;/code&gt; to be of that type:</source>
          <target state="translated">그런 다음 밑줄을 이중 콜론 (: :)에 매핑 하는 형식 맵 항목 &lt;code&gt;T_PTROBJ_SPECIAL&lt;/code&gt; 을 제공 하고 선언하십시오. &lt;code&gt;Net_Config&lt;/code&gt; 를 해당 유형으로 하십시오 .</target>
        </trans-unit>
        <trans-unit id="0b78c6f57eb325a818fb40b5bb64b41ae51db883" translate="yes" xml:space="preserve">
          <source>And then replace the hash name with the reference:</source>
          <target state="translated">그런 다음 해시 이름을 참조로 바꿉니다.</target>
        </trans-unit>
        <trans-unit id="1482b41f1c8c23a1b6f51e392e8562858f488f4e" translate="yes" xml:space="preserve">
          <source>And then set PERL5LIB to</source>
          <target state="translated">그런 다음 PERL5LIB를</target>
        </trans-unit>
        <trans-unit id="e66399c5da24330a870822849d8e76cf4cddfe41" translate="yes" xml:space="preserve">
          <source>And then step until you hit what you're looking for. This works well in a loop if you want to only break at certain iterations:</source>
          <target state="translated">그리고 당신이 찾고있는 것을 칠 때까지 밟으십시오. 특정 반복에서만 중단하려는 경우 루프에서 잘 작동합니다.</target>
        </trans-unit>
        <trans-unit id="4fa5c1cdc4927fc4a1301e4902474775669ad62e" translate="yes" xml:space="preserve">
          <source>And these conditions hold</source>
          <target state="translated">그리고이 조건들은</target>
        </trans-unit>
        <trans-unit id="d5d9b0ee41acfcea7375d0a36877f181aee3c098" translate="yes" xml:space="preserve">
          <source>And they all mean exactly the same as this:</source>
          <target state="translated">그리고 그것들은 모두 이것과 정확히 같은 의미입니다 :</target>
        </trans-unit>
        <trans-unit id="8536c300c45ef5952d0313ea8b714a35911f6d2e" translate="yes" xml:space="preserve">
          <source>And this example uses anonymous subroutines to create separate counters:</source>
          <target state="translated">그리고이 예제는 익명 서브 루틴을 사용하여 별도의 카운터를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="2e09b2a3ab0575b70e3e084aed68993db1ebce78" translate="yes" xml:space="preserve">
          <source>And this is the XS code:</source>
          <target state="translated">그리고 이것은 XS 코드입니다.</target>
        </trans-unit>
        <trans-unit id="0991be3e57b74fce439099710428de62b394a4a0" translate="yes" xml:space="preserve">
          <source>And this is the reason that many of the C library string handling functions should not be used. They don't cope with the full generality of Perl strings. It may be that your test cases don't have embedded &lt;code&gt;NUL&lt;/code&gt;s, and so the tests pass, whereas there may well eventually arise real-world cases where they fail. A lesson here is to include &lt;code&gt;NUL&lt;/code&gt;s in your tests. Now it's fairly rare in most real world cases to get &lt;code&gt;NUL&lt;/code&gt;s, so your code may seem to work, until one day a &lt;code&gt;NUL&lt;/code&gt; comes along.</source>
          <target state="translated">그리고 이것이 많은 C 라이브러리 문자열 처리 함수를 사용해서는 안되는 이유입니다. 그들은 Perl 문자열의 완전한 일반성에 대처하지 못합니다. 테스트 케이스에 &lt;code&gt;NUL&lt;/code&gt; 이 포함되어 있지 않아 테스트가 통과 될 수 있지만 결국 실패하는 실제 사례가 발생할 수 있습니다. 여기서 교훈은 테스트에 &lt;code&gt;NUL&lt;/code&gt; 을 포함 하는 것입니다. 이제 대부분의 실제 사례에서 &lt;code&gt;NUL&lt;/code&gt; 을 얻는 것은 매우 드뭅니다 . 따라서 언젠가 &lt;code&gt;NUL&lt;/code&gt; 이 나올 때까지 코드가 작동하는 것처럼 보일 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1e0a495178fdf07510ea88975dd8d193311ceae6" translate="yes" xml:space="preserve">
          <source>And this is what the script above will print:</source>
          <target state="translated">그리고 이것은 위의 스크립트가 인쇄하는 것입니다 :</target>
        </trans-unit>
        <trans-unit id="f3108d27ee1408a1d7ae19ba3de728a5ab7ca78b" translate="yes" xml:space="preserve">
          <source>And this isn't the whole story. Starting in Perl v5.12, strings that aren't encoded in UTF-8 may also be treated as Unicode under various conditions (see &lt;a href=&quot;perlunicode#ASCII-Rules-versus-Unicode-Rules&quot;&gt;&quot;ASCII Rules versus Unicode Rules&quot; in perlunicode&lt;/a&gt;). This is only really a problem for characters whose ordinals are between 128 and 255, and their behavior varies under ASCII versus Unicode rules in ways that your code cares about (see &lt;a href=&quot;perlunicode#The-%22Unicode-Bug%22&quot;&gt;&quot;The &quot;Unicode Bug&quot;&quot; in perlunicode&lt;/a&gt;). There is no published API for dealing with this, as it is subject to change, but you can look at the code for &lt;code&gt;pp_lc&lt;/code&gt; in</source>
          <target state="translated">그리고 이것은 전체 이야기가 아닙니다. Perl v5.12부터 UTF-8로 인코딩되지 않은 문자열도 다양한 조건에서 유니 코드로 처리 될 수 있습니다 ( &lt;a href=&quot;perlunicode#ASCII-Rules-versus-Unicode-Rules&quot;&gt;perlunicode의 &quot;ASCII 규칙 대 유니 코드 규칙&quot;참조&lt;/a&gt; ). 이것은 서 수가 128에서 255 사이 인 문자의 경우에만 문제가됩니다. ASCII 대 유니 코드 규칙에 따라 코드가 신경 쓰는 방식으로 동작이 다릅니다 ( &lt;a href=&quot;perlunicode#The-%22Unicode-Bug%22&quot;&gt;perlunicode의 &quot;&quot;유니 코드 버그 &quot;&quot;참조&lt;/a&gt; ). 변경 될 수 있으므로이를 처리하기 위해 게시 된 API는 없지만 &lt;code&gt;pp_lc&lt;/code&gt; 에 대한 코드 는</target>
        </trans-unit>
        <trans-unit id="35194f4922bc124f887493e5a4a0600918a32f35" translate="yes" xml:space="preserve">
          <source>And this isn't the whole story. Starting in Perl v5.12, strings that aren't encoded in UTF-8 may also be treated as Unicode under various conditions (see &lt;a href=&quot;perlunicode#ASCII-Rules-versus-Unicode-Rules&quot;&gt;ASCII Rules versus Unicode Rules in perlunicode&lt;/a&gt;). This is only really a problem for characters whose ordinals are between 128 and 255, and their behavior varies under ASCII versus Unicode rules in ways that your code cares about (see &lt;a href=&quot;perlunicode#The-%22Unicode-Bug%22&quot;&gt;The Unicode Bug in perlunicode&lt;/a&gt;). There is no published API for dealing with this, as it is subject to change, but you can look at the code for &lt;code&gt;pp_lc&lt;/code&gt; in</source>
          <target state="translated">그리고 이것은 전체 이야기가 아닙니다. Perl v5.12부터 UTF-8로 인코딩되지 않은 문자열은 다양한 조건에서 유니 코드로 취급 될 수 있습니다 ( &lt;a href=&quot;perlunicode#ASCII-Rules-versus-Unicode-Rules&quot;&gt;perlunicode의 ASCII 규칙 대 유니 코드 규칙&lt;/a&gt; 참조 ). 이것은 서 수가 128과 255 사이 인 문자에만 실제로 문제가되며, ASCII와 유니 코드 규칙에 따라 코드의 처리 방식에 따라 동작이 달라집니다 ( &lt;a href=&quot;perlunicode#The-%22Unicode-Bug%22&quot;&gt;perlunicode의 유니 코드 버그&lt;/a&gt; 참조 ). 변경 될 수 있으므로이를 처리하기위한 게시 된 API는 없지만 &lt;code&gt;pp_lc&lt;/code&gt; 의 코드는 다음에서 확인할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="04dc4562232363a5a2cdcef5ad0c57a632cc4d72" translate="yes" xml:space="preserve">
          <source>And this one reads from the child:</source>
          <target state="translated">그리고 이것은 아이에게서 읽습니다.</target>
        </trans-unit>
        <trans-unit id="22fab1b1ab24735dd2f54767a6ec2977de574611" translate="yes" xml:space="preserve">
          <source>And this too is valid:</source>
          <target state="translated">그리고 이것도 유효합니다 :</target>
        </trans-unit>
        <trans-unit id="ca100b799213c6d95d191edf790bdf80dab3cf7a" translate="yes" xml:space="preserve">
          <source>And this:</source>
          <target state="translated">이:</target>
        </trans-unit>
        <trans-unit id="ca54ab72a0f62623ded9fadca0c4ae598b7f81fe" translate="yes" xml:space="preserve">
          <source>And to check the sequence in which the library directories are searched by perl, run</source>
          <target state="translated">perl이 라이브러리 디렉토리를 검색하는 순서를 확인하려면 다음을 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="362fec7b951a6425bfa81311e580eeb12dfb603d" translate="yes" xml:space="preserve">
          <source>And to desurrogate;</source>
          <target state="translated">그리고 대리하여;</target>
        </trans-unit>
        <trans-unit id="2615ff8743f40d3114fe04e3d5a96ce87c8f4c9d" translate="yes" xml:space="preserve">
          <source>And try again:</source>
          <target state="translated">그리고 다시 시도하십시오 :</target>
        </trans-unit>
        <trans-unit id="92794ee0d6f5c6f795ca92dffa6111092171b2bc" translate="yes" xml:space="preserve">
          <source>And we end up with the program:</source>
          <target state="translated">그리고 우리는 프로그램으로 끝납니다 :</target>
        </trans-unit>
        <trans-unit id="fea4a67d42b69d2a6859a380b25f39bb4220097d" translate="yes" xml:space="preserve">
          <source>And whitespace may be used between the &lt;code&gt;~&lt;/code&gt; and quoted delimiters:</source>
          <target state="translated">&lt;code&gt;~&lt;/code&gt; 와 따옴표로 묶인 구분자 사이에 공백을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="397d92a7cd41c0dad432b26c8f27299cae1c6b41" translate="yes" xml:space="preserve">
          <source>And with &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; encoding &quot;euc-jp&quot;&lt;/code&gt; in effect, it is the same thing as that code in UTF-8:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; encoding &quot;euc-jp&quot;&lt;/code&gt; 을 &lt;a href=&quot;functions/use&quot;&gt;사용&lt;/a&gt; 하면 UTF-8의 코드와 동일합니다.</target>
        </trans-unit>
        <trans-unit id="5057821b43bf3328e6eb98ddc5e990c468614ce5" translate="yes" xml:space="preserve">
          <source>And with &lt;code&gt;use encoding &quot;euc-jp&quot;&lt;/code&gt; in effect, it is the same thing as that code in UTF-8:</source>
          <target state="translated">&lt;code&gt;use encoding &quot;euc-jp&quot;&lt;/code&gt; 을 사용 하면 UTF-8 코드와 동일합니다.</target>
        </trans-unit>
        <trans-unit id="b354e965b809ff14ff904fafbdc0b4de89c4bc4e" translate="yes" xml:space="preserve">
          <source>And with boolean methods</source>
          <target state="translated">그리고 부울 메서드</target>
        </trans-unit>
        <trans-unit id="dd73bf27445a15ee33df36a7d8cf60d584177c03" translate="yes" xml:space="preserve">
          <source>And you can see the changes:</source>
          <target state="translated">그리고 변경 사항을 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3a140f07fc1f24b5deb3f2211fd3e22212c7dcd8" translate="yes" xml:space="preserve">
          <source>And you may also sense that you do not want to bother your translators with having to write Perl code -- you'd much rather that they spend their</source>
          <target state="translated">또한 Perl 코드를 작성해야하는 번역가를 괴롭 히고 싶지 않다는 것을 느낄 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="72514ebfb8885208b2209c125f8bbac4bdc3aa69" translate="yes" xml:space="preserve">
          <source>And you write:</source>
          <target state="translated">그리고 당신은 다음과 같이 씁니다.</target>
        </trans-unit>
        <trans-unit id="e0cc2408ca05432d5f7face5b62924a44acb8f84" translate="yes" xml:space="preserve">
          <source>And your caller module would be something like this:</source>
          <target state="translated">그리고 호출자 모듈은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f429519c2ad8f6db43559b6df0122aa7e92ef582" translate="yes" xml:space="preserve">
          <source>And, as you'll have noticed from the previous example, if you override &lt;code&gt;&lt;a href=&quot;functions/glob&quot;&gt;glob&lt;/a&gt;&lt;/code&gt;, the &lt;code&gt;&amp;lt;*&amp;gt;&lt;/code&gt; glob operator is overridden as well.</source>
          <target state="translated">이전 예제에서 알 수 있듯이 &lt;code&gt;&lt;a href=&quot;functions/glob&quot;&gt;glob&lt;/a&gt;&lt;/code&gt; 를 재정의 하면 &lt;code&gt;&amp;lt;*&amp;gt;&lt;/code&gt; glob 연산자도 재정의됩니다.</target>
        </trans-unit>
        <trans-unit id="09ddb5c3e778ae1b6a95dadacffb550e09674ca1" translate="yes" xml:space="preserve">
          <source>And, as you'll have noticed from the previous example, if you override &lt;code&gt;glob&lt;/code&gt;, the &lt;code&gt;&amp;lt;*&amp;gt;&lt;/code&gt; glob operator is overridden as well.</source>
          <target state="translated">그리고 이전 예제에서 알 수 있듯이 &lt;code&gt;glob&lt;/code&gt; 을 재정의 하면 &lt;code&gt;&amp;lt;*&amp;gt;&lt;/code&gt; glob 연산자도 재정의됩니다.</target>
        </trans-unit>
        <trans-unit id="f027b49b77d3cee2d1bd5a0ad1af1a5214bdb5ba" translate="yes" xml:space="preserve">
          <source>And, most importantly, there's all the practical details of how to actually go about deriving from Maketext so you can use it for your interfaces, and the various tools and conventions for starting out and maintaining individual language modules.</source>
          <target state="translated">그리고 가장 중요한 것은 Maketext에서 실제로 파생하는 방법에 대한 모든 실제 세부 사항이 있으므로 인터페이스에 사용할 수 있도록하고 개별 언어 모듈을 시작하고 유지 관리하기위한 다양한 도구와 규칙이 있습니다.</target>
        </trans-unit>
        <trans-unit id="0872d4a5d2061a3d40ffa31b9853ff607e66e0c5" translate="yes" xml:space="preserve">
          <source>And, the Name and Name_Aliases properties are accessible through the &lt;code&gt;\N{}&lt;/code&gt; interpolation in double-quoted strings and regular expressions; and functions &lt;code&gt;charnames::viacode()&lt;/code&gt; , &lt;code&gt;charnames::vianame()&lt;/code&gt; , and &lt;code&gt;charnames::string_vianame()&lt;/code&gt; (which require a &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; charnames ();&lt;/code&gt; to be specified.</source>
          <target state="translated">또한 Name 및 Name_Aliases 속성은 큰 따옴표로 묶인 문자열과 정규식에서 &lt;code&gt;\N{}&lt;/code&gt; 보간을 통해 액세스 할 수 있습니다 . 함수 &lt;code&gt;charnames::viacode()&lt;/code&gt; , &lt;code&gt;charnames::vianame()&lt;/code&gt; 및 &lt;code&gt;charnames::string_vianame()&lt;/code&gt; ( &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; charnames ();&lt;/code&gt; 이 필요함 ) .</target>
        </trans-unit>
        <trans-unit id="a3d4a9b48a0e71abc1829b589dc1a4bb4344372b" translate="yes" xml:space="preserve">
          <source>And, there is a technique that can be used to handle variable length lookbehinds on earlier releases, and longer than 255 characters. It is described in &lt;a href=&quot;http://www.drregex.com/2019/02/variable-length-lookbehinds-actually.html&quot;&gt;http://www.drregex.com/2019/02/variable-length-lookbehinds-actually.html&lt;/a&gt;.</source>
          <target state="translated">또한 이전 릴리스에서 255 자보다 긴 가변 길이 lookbehind를 처리하는 데 사용할 수있는 기술이 있습니다. &lt;a href=&quot;http://www.drregex.com/2019/02/variable-length-lookbehinds-actually.html&quot;&gt;http://www.drregex.com/2019/02/variable-length-lookbehinds-actually.html에&lt;/a&gt; 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="b49cf0754660175d0a77b4c857d087e651cbf367" translate="yes" xml:space="preserve">
          <source>And, with Perl 5.10 and later, you don't have to check for an inheritance to see if the object can handle a role. For that, you can use &lt;code&gt;DOES&lt;/code&gt; , which comes from &lt;code&gt;UNIVERSAL&lt;/code&gt; :</source>
          <target state="translated">또한 Perl 5.10 이상에서는 개체가 역할을 처리 할 수 ​​있는지 상속을 확인할 필요가 없습니다. 이를 위해 &lt;code&gt;UNIVERSAL&lt;/code&gt; 에서 제공되는 &lt;code&gt;DOES&lt;/code&gt; 를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="df1177936aa7e7d352017983c64995f489a2f05c" translate="yes" xml:space="preserve">
          <source>And, with Perl 5.10 and later, you don't have to check for an inheritance to see if the object can handle a role. For that, you can use &lt;code&gt;DOES&lt;/code&gt;, which comes from &lt;code&gt;UNIVERSAL&lt;/code&gt;:</source>
          <target state="translated">그리고 Perl 5.10 이상에서는 객체가 역할을 처리 할 수 ​​있는지 확인하기 위해 상속을 확인할 필요가 없습니다. 이를 위해 &lt;code&gt;UNIVERSAL&lt;/code&gt; 에서 온 &lt;code&gt;DOES&lt;/code&gt; 를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="973c0aeb4f70654b3b70d2e3c1f5c993e73805e5" translate="yes" xml:space="preserve">
          <source>Andreas J. Koenig</source>
          <target state="translated">Andreas J. Koenig</target>
        </trans-unit>
        <trans-unit id="84c4d01ab2b12800c7bf2f6468b98b449d53a99b" translate="yes" xml:space="preserve">
          <source>Andreas Koenig &amp;lt;andk@cpan.org&amp;gt;, Branislav Zahradnik &amp;lt;barney@cpan.org&amp;gt;</source>
          <target state="translated">Andreas Koenig &amp;lt;andk@cpan.org&amp;gt;, Branislav Zahradnik &amp;lt;barney@cpan.org&amp;gt;</target>
        </trans-unit>
        <trans-unit id="5b41c9a4e6f27e4cb868723e388d3e3baf23ec77" translate="yes" xml:space="preserve">
          <source>Andreas Koenig &lt;code&gt;&amp;lt;andk@cpan.org&amp;gt;&lt;/code&gt;</source>
          <target state="translated">Andreas Koenig &lt;code&gt;&amp;lt;andk@cpan.org&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="17721a7a6efc10cf2782e06109ae542e5e371c5d" translate="yes" xml:space="preserve">
          <source>Andreas Koenig &lt;code&gt;andreas.koenig@anima.de&lt;/code&gt;</source>
          <target state="translated">Andreas Koenig &lt;code&gt;andreas.koenig@anima.de&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1928f95c598b9e69462fcb512625cf8e28923044" translate="yes" xml:space="preserve">
          <source>Android</source>
          <target state="translated">Android</target>
        </trans-unit>
        <trans-unit id="f2f8905b2465e6f0ad9cfd91b9febf4156adfa14" translate="yes" xml:space="preserve">
          <source>Andy Armstong &amp;lt;andy@hexten.net&amp;gt;</source>
          <target state="translated">Andy Armstong &amp;lt;andy@hexten.net&amp;gt;</target>
        </trans-unit>
        <trans-unit id="d272317e48a940ed9b68adfad919572635019ce3" translate="yes" xml:space="preserve">
          <source>Andy Armstrong &lt;code&gt;&amp;lt;andy@hexten.net&amp;gt;&lt;/code&gt;</source>
          <target state="translated">앤디 암스트롱 &lt;code&gt;&amp;lt;andy@hexten.net&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0b85b5eb312e6917fec0aa730c7d70660252958f" translate="yes" xml:space="preserve">
          <source>Andy Armstrong, &amp;lt;andy@hexten.net&amp;gt;</source>
          <target state="translated">앤디 암스트롱, &amp;lt;andy@hexten.net&amp;gt;</target>
        </trans-unit>
        <trans-unit id="9084574cd986898323dbe20b46abf1751fbbf849" translate="yes" xml:space="preserve">
          <source>Andy Broad &amp;lt;andy@broad.ology.org.uk&amp;gt;</source>
          <target state="translated">Andy Broad &amp;lt;andy@broad.ology.org.uk&amp;gt;</target>
        </trans-unit>
        <trans-unit id="8e9ef1486d01c7ad977376f692dc981d906e478c" translate="yes" xml:space="preserve">
          <source>Andy Dougherty &lt;code&gt;doughera@lafayette.edu&lt;/code&gt; , Andreas K&amp;ouml;nig &lt;code&gt;andreas.koenig@mind.de&lt;/code&gt; , Tim Bunce &lt;code&gt;timb@cpan.org&lt;/code&gt; . VMS support by Charles Bailey &lt;code&gt;bailey@newman.upenn.edu&lt;/code&gt; . OS/2 support by Ilya Zakharevich &lt;code&gt;ilya@math.ohio-state.edu&lt;/code&gt; .</source>
          <target state="translated">Andy Dougherty &lt;code&gt;doughera@lafayette.edu&lt;/code&gt; , Andreas K&amp;ouml;nig &lt;code&gt;andreas.koenig@mind.de&lt;/code&gt; , Tim Bunce &lt;code&gt;timb@cpan.org&lt;/code&gt; . Charles Bailey &lt;code&gt;bailey@newman.upenn.edu&lt;/code&gt; 의 VMS 지원 . Ilya Zakharevich의 OS / 2 지원 &lt;code&gt;ilya@math.ohio-state.edu&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="54b2fb7511cb7a7c3493b4e0650ca3d85102f114" translate="yes" xml:space="preserve">
          <source>Andy Dougherty &lt;code&gt;doughera@lafayette.edu&lt;/code&gt;, Andreas K&amp;ouml;nig &lt;code&gt;andreas.koenig@mind.de&lt;/code&gt;, Tim Bunce &lt;code&gt;timb@cpan.org&lt;/code&gt;. VMS support by Charles Bailey &lt;code&gt;bailey@newman.upenn.edu&lt;/code&gt;. OS/2 support by Ilya Zakharevich &lt;code&gt;ilya@math.ohio-state.edu&lt;/code&gt;.</source>
          <target state="translated">Andy Dougherty &lt;code&gt;doughera@lafayette.edu&lt;/code&gt; , Andreas K&amp;ouml;nig &lt;code&gt;andreas.koenig@mind.de&lt;/code&gt; , Tim Bunce &lt;code&gt;timb@cpan.org&lt;/code&gt; . Charles Bailey의 VMS 지원 &lt;code&gt;bailey@newman.upenn.edu&lt;/code&gt; . Ilya Zakharevich &lt;code&gt;ilya@math.ohio-state.edu&lt;/code&gt; 의 OS / 2 지원 .</target>
        </trans-unit>
        <trans-unit id="adb884ee85ba557bf7e891804c953fd2fabe3f95" translate="yes" xml:space="preserve">
          <source>Andy Glew,</source>
          <target state="translated">Andy Glew,</target>
        </trans-unit>
        <trans-unit id="9371666f1dc2fa002dd7c688c18705bc84f8f9d0" translate="yes" xml:space="preserve">
          <source>Andy Lester</source>
          <target state="translated">앤디 레스터</target>
        </trans-unit>
        <trans-unit id="f309e7ea03de47735dc8e5cfc8cc01f796755634" translate="yes" xml:space="preserve">
          <source>Anecdotal estimates of source-to-compiled code bloat suggest an eightfold increase. This means that the compiled form of reasonable (normally commented, properly indented etc.) code will take about eight times more space in memory than the code took on disk.</source>
          <target state="translated">소스에서 컴파일 된 코드 팽창에 대한 일화적인 추정치는 8 배 증가한 것으로 나타났습니다. 이는 합법적 인 코드 (일반적으로 주석이 달린 코드, 들여 쓰기 등)가 디스크에서 코드보다 8 배나 더 많은 공간을 차지한다는 것을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="dd5ff38fa4ac27c93c3c6622ac77c49ca0b0e6b7" translate="yes" xml:space="preserve">
          <source>Angle brackets not written as &lt;code&gt;&amp;lt;lt&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;gt&amp;gt;&lt;/code&gt; can potentially cause errors as they could be misinterpreted as markup commands. This is only printed when the -warnings level is greater than 1.</source>
          <target state="translated">&lt;code&gt;&amp;lt;lt&amp;gt;&lt;/code&gt; 및 &lt;code&gt;&amp;lt;gt&amp;gt;&lt;/code&gt; 로 쓰지 않은 꺾쇠 괄호 는 마크 업 명령으로 잘못 해석 될 수 있으므로 잠재적으로 오류를 일으킬 수 있습니다. 경고 수준이 1보다 큰 경우에만 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="4a0daf5f778b84f7d47324f4951f69110d4d48b4" translate="yes" xml:space="preserve">
          <source>Anno Siegel (ANNO) wrote the xs code and the changes in perl proper Jerry Hedden (JDHEDDEN) made it faster</source>
          <target state="translated">Anno Siegel (ANNO)은 xs 코드를 작성했으며 Perl의 Jerry Jedden (JDHEDDEN)의 변경으로 인해 더 빨랐습니다.</target>
        </trans-unit>
        <trans-unit id="602afe4dcabe1b2fe81bdeaea0130200ac9160dc" translate="yes" xml:space="preserve">
          <source>AnnoCPAN: Annotated CPAN documentation</source>
          <target state="translated">AnnoCPAN : 주석이 달린 CPAN 문서</target>
        </trans-unit>
        <trans-unit id="4fa7bfd58b194e39ca2dde6c48f032e168048d8e" translate="yes" xml:space="preserve">
          <source>Annotated POD for &lt;a href=&quot;threads&quot;&gt;threads&lt;/a&gt;: &lt;a href=&quot;http://annocpan.org/?mode=search&amp;amp;field=Module&amp;amp;name=threads&quot;&gt;http://annocpan.org/?mode=search&amp;amp;field=Module&amp;amp;name=threads&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;threads&quot;&gt;스레드에&lt;/a&gt; 대한 주석이 달린 POD : &lt;a href=&quot;http://annocpan.org/?mode=search&amp;amp;field=Module&amp;amp;name=threads&quot;&gt;http://annocpan.org/?mode=search&amp;amp;field=Module&amp;amp;name=threads&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7858242352e2796cb227df6cabe7747dcc9c11c4" translate="yes" xml:space="preserve">
          <source>Annotated POD for &lt;a href=&quot;threads&quot;&gt;threads&lt;/a&gt;: &lt;a href=&quot;https://web.archive.org/web/20171028020148/http://annocpan.org/?mode=search&amp;amp;field=Module&amp;amp;name=threads&quot;&gt;https://web.archive.org/web/20171028020148/http://annocpan.org/?mode=search&amp;amp;field=Module&amp;amp;name=threads&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;threads&quot;&gt;스레드에&lt;/a&gt; 대한 주석이 달린 POD : &lt;a href=&quot;https://web.archive.org/web/20171028020148/http://annocpan.org/?mode=search&amp;amp;field=Module&amp;amp;name=threads&quot;&gt;https://web.archive.org/web/20171028020148/http://annocpan.org/?mode=search&amp;amp;field=Module&amp;amp;name=threads&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ba63b983b01c370d674ecdc009b4d7bcd13f4f33" translate="yes" xml:space="preserve">
          <source>Annotated POD for &lt;a href=&quot;threads/shared&quot;&gt;threads::shared&lt;/a&gt;: &lt;a href=&quot;http://annocpan.org/?mode=search&amp;amp;field=Module&amp;amp;name=threads%3A%3Ashared&quot;&gt;http://annocpan.org/?mode=search&amp;amp;field=Module&amp;amp;name=threads%3A%3Ashared&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;threads/shared&quot;&gt;스레드에&lt;/a&gt; 대한 주석이 달린 POD :: shared : &lt;a href=&quot;http://annocpan.org/?mode=search&amp;amp;field=Module&amp;amp;name=threads%3A%3Ashared&quot;&gt;http://annocpan.org/?mode=search&amp;amp;field=Module&amp;amp;name=threads%3A%3Ashared&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7ff3b3d306ae85d31c9461b66532ebdda6c7e205" translate="yes" xml:space="preserve">
          <source>Annotated POD for &lt;a href=&quot;threads::shared&quot;&gt;threads::shared&lt;/a&gt;: &lt;a href=&quot;https://web.archive.org/web/20171028020148/http://annocpan.org/?mode=search&amp;amp;field=Module&amp;amp;name=threads%3A%3Ashared&quot;&gt;https://web.archive.org/web/20171028020148/http://annocpan.org/?mode=search&amp;amp;field=Module&amp;amp;name=threads%3A%3Ashared&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;threads::shared&quot;&gt;스레드에&lt;/a&gt; 대한 주석이 달린 POD :: shared : &lt;a href=&quot;https://web.archive.org/web/20171028020148/http://annocpan.org/?mode=search&amp;amp;field=Module&amp;amp;name=threads%3A%3Ashared&quot;&gt;https://web.archive.org/web/20171028020148/http://annocpan.org/?mode=search&amp;amp;field=Module&amp;amp;name=threads%3A%3Ashared&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="4d0700dd0d246c337cd6fa922a92caa253e25b21" translate="yes" xml:space="preserve">
          <source>Annotated list of characters</source>
          <target state="translated">주석이 달린 문자 목록</target>
        </trans-unit>
        <trans-unit id="c10f845c88bdb301cd3ade696bdf99cccd4ed1f0" translate="yes" xml:space="preserve">
          <source>Annotated tags in the canonical perl.git repository will never be deleted or modified. Think long and hard about whether you want to push a local tag to perl.git before doing so. (Pushing simple tags is not allowed.)</source>
          <target state="translated">표준 perl.git 저장소의 주석이 달린 태그는 절대 삭제되거나 수정되지 않습니다. ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ 그렇게하기 전에 로컬 태그를 perl.git에 푸시 할 것인지에 대해 오래 열심히 생각하십시오. (단순 태그 푸시는 허용되지 않습니다.)</target>
        </trans-unit>
        <trans-unit id="d5154e030234862764507248749c6a7c751b8bc6" translate="yes" xml:space="preserve">
          <source>Anonymous Subroutines</source>
          <target state="translated">익명 서브 루틴</target>
        </trans-unit>
        <trans-unit id="911169a23e106a872e476c8d2fa5935672c571c0" translate="yes" xml:space="preserve">
          <source>Anonymous hash and array composers like these can be intermixed freely to produce as complicated a structure as you want. The multidimensional syntax described below works for these too. The values above are literals, but variables and expressions would work just as well, because assignment operators in Perl (even within local() or my()) are executable statements, not compile-time declarations.</source>
          <target state="translated">이와 같은 익명의 해시 및 배열 작성기를 자유롭게 혼합하여 원하는만큼 복잡한 구조를 만들 수 있습니다. 아래에 설명 된 다차원 구문은 이것들에도 적용됩니다. 위의 값은 리터럴이지만 Perl의 할당 연산자 (local () 또는 my () 내)도 컴파일 타임 선언이 아닌 실행 가능한 명령문이기 때문에 변수와 표현식도 잘 작동합니다.</target>
        </trans-unit>
        <trans-unit id="ddd265fb1f3b46963f4185e092c2f56d761a6e96" translate="yes" xml:space="preserve">
          <source>Anonymous subroutines act as closures with respect to my() variables, that is, variables lexically visible within the current scope. Closure is a notion out of the Lisp world that says if you define an anonymous function in a particular lexical context, it pretends to run in that context even when it's called outside the context.</source>
          <target state="translated">익명 서브 루틴은 my () 변수, 즉 현재 범위 내에서 어휘 적으로 볼 수있는 변수와 관련하여 클로저 역할을합니다. 클로저는 특정 어휘 컨텍스트에서 익명 함수를 정의하면 컨텍스트 외부에서 호출되는 경우에도 해당 컨텍스트에서 실행되는 것처럼 가장하는 Lisp 세계의 개념입니다.</target>
        </trans-unit>
        <trans-unit id="3eb95879a615d5ea34c741b40bf67030c1977968" translate="yes" xml:space="preserve">
          <source>Anonymous subroutines get to capture each time you execute the &lt;code&gt;&lt;a href=&quot;functions/sub&quot;&gt;sub&lt;/a&gt;&lt;/code&gt; operator, as they are created on the fly. If you are accustomed to using nested subroutines in other programming languages with their own private variables, you'll have to work at it a bit in Perl. The intuitive coding of this type of thing incurs mysterious warnings about &quot;will not stay shared&quot; due to the reasons explained above. For example, this won't work:</source>
          <target state="translated">익명 서브 루틴은 &lt;code&gt;&lt;a href=&quot;functions/sub&quot;&gt;sub&lt;/a&gt;&lt;/code&gt; 연산자가 실행될 때마다 서브 연산자 를 실행할 때마다 캡처됩니다 . 고유 한 개인 변수가있는 다른 프로그래밍 언어에서 중첩 서브 루틴을 사용하는 데 익숙하다면 Perl에서 약간의 작업을 수행해야합니다. 이 유형의 것을 직관적으로 코딩하면 위에서 설명한 이유 때문에 &quot;공유하지 않습니다&quot;라는 이상한 경고가 발생합니다. 예를 들어, 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="484e8735a38d0b2c3316b6b4767502150b9246c0" translate="yes" xml:space="preserve">
          <source>Anonymous subroutines get to capture each time you execute the &lt;code&gt;sub&lt;/code&gt; operator, as they are created on the fly. If you are accustomed to using nested subroutines in other programming languages with their own private variables, you'll have to work at it a bit in Perl. The intuitive coding of this type of thing incurs mysterious warnings about &quot;will not stay shared&quot; due to the reasons explained above. For example, this won't work:</source>
          <target state="translated">익명 서브 루틴 은 즉석에서 생성 되므로 &lt;code&gt;sub&lt;/code&gt; 연산자 를 실행할 때마다 캡처됩니다 . 다른 프로그래밍 언어에서 고유 한 개인 변수와 함께 중첩 된 서브 루틴을 사용하는 데 익숙하다면 Perl에서 약간 작업해야합니다. 이러한 유형의 직관적 인 코딩은 위에서 설명한 이유 때문에 &quot;공유되지 않을 것&quot;이라는 신비한 경고를 발생시킵니다. 예를 들어 다음은 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c0878cc2f5c4c23ed0c52c0dfcedfeb6916f96a7" translate="yes" xml:space="preserve">
          <source>Another Example</source>
          <target state="translated">다른 예시</target>
        </trans-unit>
        <trans-unit id="58127100a894b61eeb7ff5e87057e807d55c8b96" translate="yes" xml:space="preserve">
          <source>Another Example -- Key is a C int.</source>
          <target state="translated">또 다른 예-키는 C int입니다.</target>
        </trans-unit>
        <trans-unit id="60d38257f9d2129e1058114b1893e74a3db974bb" translate="yes" xml:space="preserve">
          <source>Another Example: Key is a C int.</source>
          <target state="translated">다른 예 : 키는 C int입니다.</target>
        </trans-unit>
        <trans-unit id="c610761bff33dc8f8934a509a66662b8c1def3f8" translate="yes" xml:space="preserve">
          <source>Another P5P contributor recommended installation and use of Devel::PatchPerl for this situation, first to determine the version of perl at the commit in question, then to patch the source code at that point to facilitate a build.</source>
          <target state="translated">다른 P5P 기여자는이 상황에 대해 Devel :: PatchPerl의 설치 및 사용을 권장했습니다. 먼저 해당 커밋에서 perl의 버전을 확인한 다음 빌드를 용이하게하기 위해 해당 지점에서 소스 코드를 패치합니다.</target>
        </trans-unit>
        <trans-unit id="be5842d0c6f0b2a32d5a2aac4ce0ec4bcd453989" translate="yes" xml:space="preserve">
          <source>Another Portable Binary Encoding</source>
          <target state="translated">또 다른 휴대용 이진 인코딩</target>
        </trans-unit>
        <trans-unit id="a3a811e6345c52a72030025da749e7378837c8a7" translate="yes" xml:space="preserve">
          <source>Another brief debugger, slightly more useful, can be created with only the line:</source>
          <target state="translated">약간 더 유용한 또 다른 간단한 디버거는 다음 줄만 사용하여 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="723c39858f051ddac15e8257e9c5bc5481712afe" translate="yes" xml:space="preserve">
          <source>Another common error is to use ordinary parentheses to construct a list reference when you should be using square or curly brackets, for example, if you say</source>
          <target state="translated">또 다른 일반적인 오류는 일반 괄호를 사용하여 대괄호 또는 중괄호를 사용해야하는 경우 목록 참조를 구성하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="989f6c267d1aa6631d47641c01947fa297495517" translate="yes" xml:space="preserve">
          <source>Another common use for this construct is when you need to execute something without the shell's interference. With system(), it's straightforward, but you can't use a pipe open or backticks safely. That's because there's no way to stop the shell from getting its hands on your arguments. Instead, use lower-level control to call exec() directly.</source>
          <target state="translated">이 구조의 또 다른 일반적인 용도는 쉘의 간섭없이 무언가를 실행해야 할 때입니다. system ()을 사용하면 간단하지만 파이프 개방 또는 백틱을 안전하게 사용할 수 없습니다. 쉘이 당신의 주장에 손을 대지 못하게 막을 방법이 없기 때문입니다. 대신 하위 수준 컨트롤을 사용하여 exec ()를 직접 호출하십시오.</target>
        </trans-unit>
        <trans-unit id="948bec86ec25e1c793c75848e3f095908f00b9e7" translate="yes" xml:space="preserve">
          <source>Another complication is that the representation used for the program differs if it needs to store Unicode, but it's not always possible to know for sure whether it does until midway through parsing. The Unicode representation for the program is larger, and cannot be matched as efficiently. (See &lt;a href=&quot;#Unicode-and-Localisation-Support&quot;&gt;&quot;Unicode and Localisation Support&quot;&lt;/a&gt; below for more details as to why.) If the pattern contains literal Unicode, it's obvious that the program needs to store Unicode. Otherwise, the parser optimistically assumes that the more efficient representation can be used, and starts sizing on this basis. However, if it then encounters something in the pattern which must be stored as Unicode, such as an &lt;code&gt;\x{...}&lt;/code&gt; escape sequence representing a character literal, then this means that all previously calculated sizes need to be redone, using values appropriate for the Unicode representation. This is another instance where the parsing needs to be restarted, and it can and is done immediately. The function returns failure, and sets the flag &lt;code&gt;RESTART_UTF8&lt;/code&gt; (encapsulated by using the macro &lt;code&gt;REQUIRE_UTF8&lt;/code&gt;). This restart request is propagated up the call chain in a similar fashion, until it is &quot;caught&quot; in &lt;code&gt;Perl_re_op_compile()&lt;/code&gt;, which marks the pattern as containing Unicode, and restarts the sizing pass. It is also possible for constructions within run-time code blocks to turn out to need Unicode representation., which is signalled by &lt;code&gt;S_compile_runtime_code()&lt;/code&gt; returning false to &lt;code&gt;Perl_re_op_compile()&lt;/code&gt;.</source>
          <target state="translated">또 다른 문제는 프로그램에 사용되는 표현이 유니 코드를 저장해야하는 경우 달라진다는 것입니다.하지만 파싱을 통해 중간까지 저장되는지 여부를 항상 알 수있는 것은 아닙니다. 프로그램의 유니 코드 표현이 더 크고 효율적으로 일치 할 수 없습니다. ( 이유에 대한 자세한 내용은 아래의 &lt;a href=&quot;#Unicode-and-Localisation-Support&quot;&gt;&quot;유니 코드 및 지역화 지원&quot;&lt;/a&gt; 을 참조하십시오.) 패턴에 리터럴 유니 코드가 포함되어 있으면 프로그램이 유니 코드를 저장해야한다는 것이 분명합니다. 그렇지 않으면 파서는 더 효율적인 표현을 사용할 수 있다고 낙관적으로 가정하고이를 기반으로 크기 조정을 시작합니다. 그러나 &lt;code&gt;\x{...}&lt;/code&gt; 와 같이 유니 코드로 저장되어야하는 패턴에서 무언가를 발견하면문자 리터럴을 나타내는 이스케이프 시퀀스는 유니 코드 표현에 적합한 값을 사용하여 이전에 계산 된 모든 크기를 다시 실행해야 함을 의미합니다. 이것은 구문 분석을 다시 시작해야하는 또 다른 인스턴스이며 즉시 수행 할 수 있습니다. 이 함수는 실패를 반환하고 &lt;code&gt;RESTART_UTF8&lt;/code&gt; 플래그를 설정합니다 ( &lt;code&gt;REQUIRE_UTF8&lt;/code&gt; 매크로를 사용하여 캡슐화 됨 ). 이 재시작 요청은 패턴이 유니 코드를 포함하는 것으로 표시하고 크기 조정 단계를 다시 시작하는 &lt;code&gt;Perl_re_op_compile()&lt;/code&gt; 에서 &quot;발견&quot;될 때까지 유사한 방식으로 호출 체인 위로 전파됩니다 . 런타임 코드 블록 내의 구성이 유니 코드 표현을 필요로하는 것으로 판명 될 수도 있습니다. 이는 &lt;code&gt;S_compile_runtime_code()&lt;/code&gt; 의해 신호를 받습니다. &lt;code&gt;Perl_re_op_compile()&lt;/code&gt; false 반환 .</target>
        </trans-unit>
        <trans-unit id="9e79a0e3805beb03c075ab9c59ea2fd3f85cbbe5" translate="yes" xml:space="preserve">
          <source>Another complication is that the representation used for the program differs if it needs to store Unicode, but it's not always possible to know for sure whether it does until midway through parsing. The Unicode representation for the program is larger, and cannot be matched as efficiently. (See &lt;a href=&quot;#Unicode-and-Localisation-Support&quot;&gt;Unicode and Localisation Support&lt;/a&gt; below for more details as to why.) If the pattern contains literal Unicode, it's obvious that the program needs to store Unicode. Otherwise, the parser optimistically assumes that the more efficient representation can be used, and starts sizing on this basis. However, if it then encounters something in the pattern which must be stored as Unicode, such as an &lt;code&gt;\x{...}&lt;/code&gt; escape sequence representing a character literal, then this means that all previously calculated sizes need to be redone, using values appropriate for the Unicode representation. Currently, all regular expression constructions which can trigger this are parsed by code in &lt;code&gt;regatom()&lt;/code&gt; .</source>
          <target state="translated">또 다른 문제는 유니 코드를 저장해야하는 경우 프로그램에 사용 된 표현이 다르지만 구문 분석 중반까지 수행되는지 여부를 항상 알 수있는 것은 아닙니다. 프로그램의 유니 코드 표현이 더 커서 효율적으로 일치시킬 수 없습니다. ( 이유에 대한 자세한 내용은 아래의 &lt;a href=&quot;#Unicode-and-Localisation-Support&quot;&gt;유니 코드 및 현지화 지원&lt;/a&gt; 을 참조하십시오.) 패턴에 리터럴 유니 코드가 포함 된 경우 프로그램에서 유니 코드를 저장해야합니다. 그렇지 않으면 파서는 더 효율적인 표현을 사용할 수 있다고 낙관적으로 가정하고이를 기반으로 크기 조정을 시작합니다. 그러나 패턴에서 유니 코드로 저장해야하는 패턴이 발견되면 &lt;code&gt;\x{...}&lt;/code&gt; 문자 리터럴을 나타내는 이스케이프 시퀀스 인 경우 이는 유니 코드 표현에 적절한 값을 사용하여 이전에 계산 된 모든 크기를 다시 실행해야 함을 의미합니다. 현재 이것을 트리거 할 수있는 모든 정규 표현식 구성은 &lt;code&gt;regatom()&lt;/code&gt; 코드로 구문 분석됩니다 .</target>
        </trans-unit>
        <trans-unit id="8b313efb71a57a4464cb94a659a9e8b90c24250e" translate="yes" xml:space="preserve">
          <source>Another confusion with both these properties is that the definition is not that the code point has been</source>
          <target state="translated">이 두 속성을 혼동하는 또 다른 혼동은 그 정의가 코드 포인트가 아니라는 것입니다</target>
        </trans-unit>
        <trans-unit id="8de6445149b9f420296053261c9997adf2340600" translate="yes" xml:space="preserve">
          <source>Another consequence of using &lt;a href=&quot;#binmode-FILEHANDLE%2C-LAYER&quot;&gt;&lt;code&gt;binmode&lt;/code&gt;&lt;/a&gt; (on some systems) is that special end-of-file markers will be seen as part of the data stream. For systems from the Microsoft family this means that, if your binary data contain &lt;code&gt;\cZ&lt;/code&gt;, the I/O subsystem will regard it as the end of the file, unless you use &lt;a href=&quot;#binmode-FILEHANDLE%2C-LAYER&quot;&gt;&lt;code&gt;binmode&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">(일부 시스템에서) &lt;a href=&quot;#binmode-FILEHANDLE%2C-LAYER&quot;&gt; &lt;code&gt;binmode&lt;/code&gt; &lt;/a&gt; 를 사용하는 또 다른 결과는 특별한 파일 끝 마커가 데이터 스트림의 일부로 표시된다는 것입니다. Microsoft 제품군의 시스템의 경우 바이너리 데이터에 &lt;code&gt;\cZ&lt;/code&gt; 포함되어 있으면 &lt;a href=&quot;#binmode-FILEHANDLE%2C-LAYER&quot;&gt; &lt;code&gt;binmode&lt;/code&gt; &lt;/a&gt; 를 사용하지 않는 한 I / O 하위 시스템이이를 파일의 끝으로 간주합니다 .</target>
        </trans-unit>
        <trans-unit id="a7643f36484ae100d2da2d3c144ef9dbeaed949e" translate="yes" xml:space="preserve">
          <source>Another consequence of using binmode() (on some systems) is that special end-of-file markers will be seen as part of the data stream. For systems from the Microsoft family this means that, if your binary data contain &lt;code&gt;\cZ&lt;/code&gt; , the I/O subsystem will regard it as the end of the file, unless you use binmode().</source>
          <target state="translated">binmode () 사용 (일부 시스템에서)의 또 다른 결과는 특수 파일 끝 마커가 데이터 스트림의 일부로 표시된다는 것입니다. Microsoft 제품군의 시스템에서 이는 바이너리 데이터에 &lt;code&gt;\cZ&lt;/code&gt; 포함 된 경우 binmode ()를 사용하지 않는 한 I / O 서브 시스템이이를 파일의 끝으로 간주 함을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="3cc44056a9f339f4466b010a8b6a440f514bb627" translate="yes" xml:space="preserve">
          <source>Another construct to be wary of is the inappropriate use of hex (unless you use &lt;code&gt;\N{U+...}&lt;/code&gt; ) or octal constants in regular expressions. Consider the following set of subs:</source>
          <target state="translated">주의해야 할 또 다른 구문 은 정규식에서 16 진 ( &lt;code&gt;\N{U+...}&lt;/code&gt; 을 사용하지 않는 한 ) 또는 8 진 상수를 부적절하게 사용하는 것입니다 . 다음과 같은 서브 세트를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="4bdabce8c57375ff87d8b683a0b4feedd678dfa2" translate="yes" xml:space="preserve">
          <source>Another construct to be wary of is the inappropriate use of hex (unless you use &lt;code&gt;\N{U+...}&lt;/code&gt;) or octal constants in regular expressions. Consider the following set of subs:</source>
          <target state="translated">주의해야 할 또 다른 구조 는 정규식에서 16 진수 ( &lt;code&gt;\N{U+...}&lt;/code&gt; 를 사용하지 않는 한 ) 또는 8 진수 상수를 부적절하게 사용하는 것입니다 . 다음 서브 세트를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="dd580d9d1c12fa08ea2d8378d289e2825dd48a0c" translate="yes" xml:space="preserve">
          <source>Another description starts with notions of &quot;better&quot;/&quot;worse&quot;. All the substrings which may be matched by the given regular expression can be sorted from the &quot;best&quot; match to the &quot;worst&quot; match, and it is the &quot;best&quot; match which is chosen. This substitutes the question of &quot;what is chosen?&quot; by the question of &quot;which matches are better, and which are worse?&quot;.</source>
          <target state="translated">또 다른 설명은 &quot;더 나은&quot;/ &quot;나쁜&quot;이라는 개념으로 시작합니다. 주어진 정규 표현식과 일치 할 수있는 모든 하위 문자열은 &quot;최고&quot;일치에서 &quot;최악&quot;일치로 정렬 될 수 있으며 선택된 &quot;최고&quot;일치입니다. 이것은 &quot;무엇을 선택합니까?&quot;라는 문제를 대체합니다. &quot;어떤 경기가 더 좋고 어떤 것이 더 나빠?&quot;</target>
        </trans-unit>
        <trans-unit id="856a6f6c8652259321cab00a9ad8f033dc81e6f4" translate="yes" xml:space="preserve">
          <source>Another drawback is only valid for Perl versions before 5.6.0. This drawback is that the seek and tell functions (both the builtin version and POSIX module version) will not perform correctly.</source>
          <target state="translated">또 다른 단점은 5.6.0 이전의 Perl 버전에만 유효합니다. 이 단점은 찾기 및 말하기 기능 (내장 버전 및 POSIX 모듈 버전 모두)이 올바르게 수행되지 않는다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="d8eeb28f49e1f9d89b4e036aaf71838ed7700dd9" translate="yes" xml:space="preserve">
          <source>Another dummy layer. When pushed it pops itself and sets the &lt;code&gt;PERLIO_F_UTF8&lt;/code&gt; flag on the layer which was (and now is once more) the top of the stack.</source>
          <target state="translated">또 다른 더미 층. 푸시되면 자체적으로 팝업 되고 스택의 맨 위에 있던 레이어에 &lt;code&gt;PERLIO_F_UTF8&lt;/code&gt; 플래그를 설정합니다 .</target>
        </trans-unit>
        <trans-unit id="d9e8985e4a56d117b356dcbeb0c42c3cbcba847b" translate="yes" xml:space="preserve">
          <source>Another example of a data paragraph:</source>
          <target state="translated">데이터 단락의 다른 예 :</target>
        </trans-unit>
        <trans-unit id="b5c62d28b9310748f7a00e0cde763766b0ceff47" translate="yes" xml:space="preserve">
          <source>Another example switched the first &quot;latin1&quot; encoding it finds to &quot;utf8&quot; in a pod file:</source>
          <target state="translated">다른 예제는 포드 파일에서 &quot;utf8&quot;로 찾은 첫 번째 &quot;latin1&quot;인코딩을 전환했습니다.</target>
        </trans-unit>
        <trans-unit id="50f1426af11ad7a924141e38d176e901ed8b9c69" translate="yes" xml:space="preserve">
          <source>Another example that shows that within &lt;code&gt;\p{...}&lt;/code&gt;, &lt;code&gt;/x&lt;/code&gt; isn't needed to have spaces:</source>
          <target state="translated">&lt;code&gt;\p{...}&lt;/code&gt; 에서 &lt;code&gt;/x&lt;/code&gt; 에 공백이 필요하지 않음 을 보여주는 또 다른 예 :</target>
        </trans-unit>
        <trans-unit id="dedf5ccdeb6bf446ef7cfb01d8db4c4b042b2078" translate="yes" xml:space="preserve">
          <source>Another example:</source>
          <target state="translated">다른 예시:</target>
        </trans-unit>
        <trans-unit id="ece934d7c44856dd3f545147d03b2aa737a1de6d" translate="yes" xml:space="preserve">
          <source>Another form of code expression is the</source>
          <target state="translated">코드 표현의 다른 형태는</target>
        </trans-unit>
        <trans-unit id="48b78ab1e531e9b3794c2d43c0589ca792ae0b42" translate="yes" xml:space="preserve">
          <source>Another form of optimisation that can occur is the post-parse &quot;peep-hole&quot; optimisation, where inefficient constructs are replaced by more efficient constructs. The &lt;code&gt;TAIL&lt;/code&gt; regops which are used during parsing to mark the end of branches and the end of groups are examples of this. These regops are used as place-holders during construction and &quot;always match&quot; so they can be &quot;optimised away&quot; by making the things that point to the &lt;code&gt;TAIL&lt;/code&gt; point to the thing that &lt;code&gt;TAIL&lt;/code&gt; points to, thus &quot;skipping&quot; the node.</source>
          <target state="translated">발생할 수있는 또 다른 형태의 최적화는 분석 후 &quot;핍홀&quot;최적화인데, 여기서 비효율적 인 구조는보다 효율적인 구조로 대체됩니다. &lt;code&gt;TAIL&lt;/code&gt; 에 가지 끝에 및 그룹의 끝을 표시하기 위해 분석하는 동안 사용되는 regops 이것의 예이다. 이 regops는 건설 기간 동안 위치 표시기로 사용 그들이 가리킨 있다는 것을하여 &quot;멀리 최적화&quot;할 수 있도록 &quot;항상 일치&quot;하는 &lt;code&gt;TAIL&lt;/code&gt; 의 물건을 가리키고 있음을 &lt;code&gt;TAIL&lt;/code&gt; 의 점, 따라서 노드를 &quot;건너 뛰기&quot;할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6a81857ae4b443a44f359782c057cbbbeb457048" translate="yes" xml:space="preserve">
          <source>Another good reason in addition to readability and maintainability for using relative backreferences is illustrated by the following example, where a simple pattern for matching peculiar strings is used:</source>
          <target state="translated">상대 역 참조를 사용하기위한 가독성 및 유지 관리성에 대한 또 다른 좋은 이유는 다음 예에 설명되어 있습니다. 여기서 고유 한 문자열을 일치시키기위한 간단한 패턴이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="bfac64b9584bc828981db16d0cc4e6658be646cc" translate="yes" xml:space="preserve">
          <source>Another interesting approach to IPC is making your single program go multiprocess and communicate between--or even amongst--yourselves. The open() function will accept a file argument of either &lt;code&gt;&quot;-|&quot;&lt;/code&gt; or &lt;code&gt;&quot;|-&quot;&lt;/code&gt; to do a very interesting thing: it forks a child connected to the filehandle you've opened. The child is running the same program as the parent. This is useful for safely opening a file when running under an assumed UID or GID, for example. If you open a pipe</source>
          <target state="translated">IPC에 대한 또 다른 흥미로운 접근 방식은 단일 프로그램을 다중 프로세스로 전환하여 서로간에 또는 심지어 서로간에 통신하게하는 것입니다. open () 함수는 &lt;code&gt;&quot;-|&quot;&lt;/code&gt; 의 파일 인수를 허용합니다. 또는 매우 흥미로운 일을하기 위해 &lt;code&gt;&quot;|-&quot;&lt;/code&gt; : 열린 파일 핸들에 연결된 자식을 포크합니다. 자식이 부모와 같은 프로그램을 실행하고 있습니다. 예를 들어, 가정 된 UID 또는 GID에서 실행할 때 파일을 안전하게 여는 데 유용합니다. 파이프를 열면</target>
        </trans-unit>
        <trans-unit id="4522d51a25407d48caa1899497ae3f892458c192" translate="yes" xml:space="preserve">
          <source>Another interesting approach to IPC is making your single program go multiprocess and communicate between--or even amongst--yourselves. The two-argument form of the open() function will accept a file argument of either &lt;code&gt;&quot;-|&quot;&lt;/code&gt; or &lt;code&gt;&quot;|-&quot;&lt;/code&gt; to do a very interesting thing: it forks a child connected to the filehandle you've opened. The child is running the same program as the parent. This is useful for safely opening a file when running under an assumed UID or GID, for example. If you open a pipe</source>
          <target state="translated">IPC에 대한 또 다른 흥미로운 접근 방식은 단일 프로그램을 다중 프로세스로 만들고 서로간에 또는 서로간에 통신하도록 만드는 것입니다. open () 함수의 두 인수 형식은 &lt;code&gt;&quot;-|&quot;&lt;/code&gt; 중 하나의 파일 인수를 허용합니다. 또는 &lt;code&gt;&quot;|-&quot;&lt;/code&gt; 를 사용하여 매우 흥미로운 작업을 수행합니다. 사용자가 연 파일 핸들에 연결된 자식을 분기합니다. 자녀는 부모와 동일한 프로그램을 실행하고 있습니다. 이는 예를 들어 가정 된 UID 또는 GID로 실행할 때 파일을 안전하게 여는 데 유용합니다. 파이프를 열면</target>
        </trans-unit>
        <trans-unit id="075cc903bac6f7e2aa6bd64ab5e44c58b488750c" translate="yes" xml:space="preserve">
          <source>Another interesting signal to send is signal number zero. This doesn't actually affect a child process, but instead checks whether it's alive or has changed its UIDs.</source>
          <target state="translated">전송할 또 다른 흥미로운 신호는 신호 번호 0입니다. 이것은 실제로 자식 프로세스에 영향을 미치지 않지만 대신 활성 상태인지 또는 UID를 변경했는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="5625c9da79ea74fa11d7487b4856a60b8a448f5c" translate="yes" xml:space="preserve">
          <source>Another interface for querying locale-dependent information is the &lt;code&gt;I18N::Langinfo::langinfo()&lt;/code&gt; function, available at least in Unix-like systems and VMS.</source>
          <target state="translated">로케일 종속 정보를 조회하기위한 또 다른 인터페이스는 &lt;code&gt;I18N::Langinfo::langinfo()&lt;/code&gt; 함수이며, 적어도 유닉스 계열 시스템 및 VMS에서 사용 가능합니다.</target>
        </trans-unit>
        <trans-unit id="b2c6ea999a64bd42bd0c393eb0d4d13d68bfe00e" translate="yes" xml:space="preserve">
          <source>Another interface for querying locale-dependent information is the &lt;code&gt;I18N::Langinfo::langinfo()&lt;/code&gt; function.</source>
          <target state="translated">로케일 종속 정보를 쿼리하는 또 다른 인터페이스는 &lt;code&gt;I18N::Langinfo::langinfo()&lt;/code&gt; 함수입니다.</target>
        </trans-unit>
        <trans-unit id="7e0169360cab902c54c29d1ed679e73f96ea0a5a" translate="yes" xml:space="preserve">
          <source>Another is</source>
          <target state="translated">또 하나는</target>
        </trans-unit>
        <trans-unit id="7cdba3e1788bc415b19d9a9a11cdf704cabf535e" translate="yes" xml:space="preserve">
          <source>Another kind of client-server setup is one that uses not connections, but messages. UDP communications involve much lower overhead but also provide less reliability, as there are no promises that messages will arrive at all, let alone in order and unmangled. Still, UDP offers some advantages over TCP, including being able to &quot;broadcast&quot; or &quot;multicast&quot; to a whole bunch of destination hosts at once (usually on your local subnet). If you find yourself overly concerned about reliability and start building checks into your message system, then you probably should use just TCP to start with.</source>
          <target state="translated">다른 종류의 클라이언트-서버 설정은 연결이 아니라 메시지를 사용하는 것입니다. UDP 통신은 오버 헤드가 훨씬 낮아 지지만 메시지의 순서와 무관심은 물론 메시지가 도착할 것이라는 약속이 없기 때문에 안정성이 떨어집니다. 그럼에도 불구하고 UDP는 한 번에 (대개 로컬 서브넷에서) 전체 대상 호스트에 &quot;브로드 캐스트&quot;또는 &quot;멀티 캐스트&quot;할 수있는 등 TCP보다 몇 가지 이점을 제공합니다. 안정성에 대해 지나치게 우려하고 메시지 시스템에 대한 검사를 시작하려면 TCP 만 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="15bc936b8bd7810df3b41eba0889fe66dfa9061e" translate="yes" xml:space="preserve">
          <source>Another memory limiting item to check is your MAXASSIZE parameter in your 'SYS1.PARMLIB(BPXPRMxx)' data set (note too that as of V2R8 address space limits can be set on a per user ID basis in the USS segment of a RACF profile). People have reported successful builds of Perl with MAXASSIZE parameters as small as 503316480 (and it may be possible to build Perl with a MAXASSIZE smaller than that).</source>
          <target state="translated">확인해야 할 또 다른 메모리 제한 항목은 'SYS1.PARMLIB (BPXPRMxx)'데이터 세트의 MAXASSIZE 매개 변수입니다 (RACF 프로파일의 USS 세그먼트에서 V2R8 주소 공간 한계를 사용자 ID별로 설정할 수 있음에 유의하십시오) . 사람들은 503316480만큼 작은 MAXASSIZE 매개 변수로 성공적인 Perl 빌드를보고했습니다 (그리고 MAXASSIZE보다 작은 Perl을 빌드하는 것이 가능할 수도 있습니다).</target>
        </trans-unit>
        <trans-unit id="7f12c23dd22baed9e55a21bc829f2cdbb2990e89" translate="yes" xml:space="preserve">
          <source>Another mnemonic for this modifier is &quot;Depends&quot;, as the rules actually used depend on various things, and as a result you can get unexpected results. See &lt;a href=&quot;perlunicode#The-%22Unicode-Bug%22&quot;&gt;&quot;The &quot;Unicode Bug&quot;&quot; in perlunicode&lt;/a&gt;. The Unicode Bug has become rather infamous, leading to yet another (without swearing) name for this modifier, &quot;Dodgy&quot;.</source>
          <target state="translated">이 수정 자에 대한 또 다른 니모닉은 &quot;Depends&quot;입니다. 실제로 사용되는 규칙은 다양한 사항에 따라 달라지며 결과적으로 예기치 않은 결과를 얻을 수 있습니다. &lt;a href=&quot;perlunicode#The-%22Unicode-Bug%22&quot;&gt;perlunicode의 &quot;&quot;유니 코드 버그 &quot;&quot;를&lt;/a&gt; 참조하십시오 . 유니 코드 버그는 다소 악명을 떨쳐이 수식어 &quot;Dodgy&quot;의 또 다른 이름 (욕설없이)으로 이어졌습니다.</target>
        </trans-unit>
        <trans-unit id="ce05ce9dfc0d776de0b8b42183a9011dbca61f46" translate="yes" xml:space="preserve">
          <source>Another mnemonic for this modifier is &quot;Depends&quot;, as the rules actually used depend on various things, and as a result you can get unexpected results. See &lt;a href=&quot;perlunicode#The-%22Unicode-Bug%22&quot;&gt;The Unicode Bug in perlunicode&lt;/a&gt;. The Unicode Bug has become rather infamous, leading to yet another (printable) name for this modifier, &quot;Dodgy&quot;.</source>
          <target state="translated">이 수정 자의 또 다른 니모닉은 &quot;의존&quot;입니다. 실제로 사용되는 규칙은 여러 가지에 따라 달라 지므로 예기치 않은 결과를 얻을 수 있습니다. &lt;a href=&quot;perlunicode#The-%22Unicode-Bug%22&quot;&gt;perlunicode의 유니 코드 버그를&lt;/a&gt; 참조하십시오 . 유니 코드 버그는 다소 악명이 높아져이 수정자인 &quot;Dodgy&quot;의 또 다른 이름 (인쇄 가능)으로 이어졌습니다.</target>
        </trans-unit>
        <trans-unit id="df7cbfe3fb975c17e692f6a855e0332ef03824f0" translate="yes" xml:space="preserve">
          <source>Another nonstandard extension to the JSON syntax, enabled with the &lt;code&gt;allow_tags&lt;/code&gt; setting, are tagged values. In this implementation, the</source>
          <target state="translated">&lt;code&gt;allow_tags&lt;/code&gt; 설정으로 활성화 된 JSON 구문에 대한 또 다른 비표준 확장 은 태그 값입니다. 이 구현에서</target>
        </trans-unit>
        <trans-unit id="3cfb16782780267975128af9b462f0c7f8f09971" translate="yes" xml:space="preserve">
          <source>Another odd-man-out in the template alphabet is &lt;code&gt;u&lt;/code&gt; , which packs a &quot;uuencoded string&quot;. (&quot;uu&quot; is short for Unix-to-Unix.) Chances are that you won't ever need this encoding technique which was invented to overcome the shortcomings of old-fashioned transmission mediums that do not support other than simple ASCII data. The essential recipe is simple: Take three bytes, or 24 bits. Split them into 4 six-packs, adding a space (0x20) to each. Repeat until all of the data is blended. Fold groups of 4 bytes into lines no longer than 60 and garnish them in front with the original byte count (incremented by 0x20) and a &lt;code&gt;&quot;\n&quot;&lt;/code&gt; at the end. - The &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; chef will prepare this for you, a la minute, when you select pack code &lt;code&gt;u&lt;/code&gt; on the menu:</source>
          <target state="translated">템플릿 알파벳의 또 다른 홀드 아웃은 &lt;code&gt;u&lt;/code&gt; 로 , &quot;uuencoded string&quot;을 포함합니다. ( &quot;uu&quot;는 Unix-to-Unix의 줄임말입니다.) 단순한 ASCII 데이터 이외의 다른 지원하지 않는 구식 전송 매체의 단점을 극복하기 위해 고안된이 인코딩 기술이 필요 없을 것입니다. 필수 레시피는 간단합니다. 3 바이트 또는 24 비트를 사용하십시오. 4 개의 6 팩으로 나누고 각각에 공백 (0x20)을 추가하십시오. 모든 데이터가 혼합 될 때까지 반복하십시오. 4 바이트 그룹을 60 줄 이하로 접어서 원래 바이트 수 (0x20 씩 증가)와 끝에 &lt;code&gt;&quot;\n&quot;&lt;/code&gt; 을 붙입니다 . - 메뉴 에서 팩 코드 &lt;code&gt;u&lt;/code&gt; 를 선택하면 &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; 셰프가 1 분 안에이를 준비 합니다.</target>
        </trans-unit>
        <trans-unit id="0815afa133e3357f3c224c29010f1fab6f9eb77d" translate="yes" xml:space="preserve">
          <source>Another odd-man-out in the template alphabet is &lt;code&gt;u&lt;/code&gt;, which packs a &quot;uuencoded string&quot;. (&quot;uu&quot; is short for Unix-to-Unix.) Chances are that you won't ever need this encoding technique which was invented to overcome the shortcomings of old-fashioned transmission mediums that do not support other than simple ASCII data. The essential recipe is simple: Take three bytes, or 24 bits. Split them into 4 six-packs, adding a space (0x20) to each. Repeat until all of the data is blended. Fold groups of 4 bytes into lines no longer than 60 and garnish them in front with the original byte count (incremented by 0x20) and a &lt;code&gt;&quot;\n&quot;&lt;/code&gt; at the end. - The &lt;code&gt;pack&lt;/code&gt; chef will prepare this for you, a la minute, when you select pack code &lt;code&gt;u&lt;/code&gt; on the menu:</source>
          <target state="translated">템플릿 알파벳의 또 다른 홀수 는 &quot;uuencoded 문자열&quot;을 포장하는 &lt;code&gt;u&lt;/code&gt; 입니다. ( &quot;uu&quot;는 Unix-to-Unix의 약자입니다.) 단순한 ASCII 데이터 외에는 지원하지 않는 구식 전송 매체의 단점을 극복하기 위해 발명 된이 인코딩 기술이 필요하지 않을 가능성이 있습니다. 필수 레시피는 간단합니다. 3 바이트 또는 24 비트를 사용합니다. 6 팩 4 개로 분할하여 각각에 공백 (0x20)을 추가합니다. 모든 데이터가 혼합 될 때까지 반복합니다. 4 바이트 그룹을 60 개 이하의 행으로 접고 앞에 원래 바이트 수 (0x20 씩 증가)와 끝에 &lt;code&gt;&quot;\n&quot;&lt;/code&gt; 을 추가합니다. - 메뉴 에서 팩 코드 &lt;code&gt;u&lt;/code&gt; 를 선택하면 &lt;code&gt;pack&lt;/code&gt; 셰프가 1 분 동안 준비해드립니다 .</target>
        </trans-unit>
        <trans-unit id="f3b90d55edc9bd711b381039fe4df0f81ca8e910" translate="yes" xml:space="preserve">
          <source>Another operator with surprising precedence is exponentiation. It binds more tightly even than unary minus, making &lt;code&gt;-2**2&lt;/code&gt; produce a negative four and not a positive one. It is also right-associating, meaning that &lt;code&gt;2**3**2&lt;/code&gt; is two raised to the ninth power, not eight squared.</source>
          <target state="translated">우선 순위가 놀라운 또 다른 연산자는 지수입니다. 이 값은 단항 마이너스보다 더 밀접하게 바인딩되므로 &lt;code&gt;-2**2&lt;/code&gt; 는 양수가 아닌 음수 4를 생성합니다. 또한 오른쪽 연관입니다. 즉, &lt;code&gt;2**3**2&lt;/code&gt; 는 8 제곱이 아니라 9 승으로 올립니다.</target>
        </trans-unit>
        <trans-unit id="0a8ead7308fc061719df6bc244f6348d6cfaf232" translate="yes" xml:space="preserve">
          <source>Another optimisation that can occur is that of &quot;&lt;code&gt;EXACT&lt;/code&gt; merging&quot; which is where two consecutive &lt;code&gt;EXACT&lt;/code&gt; nodes are merged into a single regop. An even more aggressive form of this is that a branch sequence of the form &lt;code&gt;EXACT BRANCH ... EXACT&lt;/code&gt; can be converted into a &lt;code&gt;TRIE-EXACT&lt;/code&gt; regop.</source>
          <target state="translated">발생할 수있는 또 다른 최적화 는 두 개의 연속 &lt;code&gt;EXACT&lt;/code&gt; 노드가 단일 regop으로 병합 되는 &quot; &lt;code&gt;EXACT&lt;/code&gt; merging&quot;입니다 . 이것의 더욱 공격적인 형태는 &lt;code&gt;EXACT BRANCH ... EXACT&lt;/code&gt; 형식의 분기 시퀀스를 &lt;code&gt;TRIE-EXACT&lt;/code&gt; 레고 프로 변환 할 수 있다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="bd2c2ceaa1b82e7064a95fc5a1daa0bbc069a63f" translate="yes" xml:space="preserve">
          <source>Another option for Perls starting with 5.16, if you only care about ASCII matches, is to add the &lt;code&gt;/aa&lt;/code&gt; modifier to the regex. This will exclude all these non-obvious matches, thus getting rid of this message. You can also say</source>
          <target state="translated">5.16으로 시작하는 Perls의 또 다른 옵션은 ASCII 일치에만 관심 이있는 경우 정규식에 &lt;code&gt;/aa&lt;/code&gt; 수정자를 추가하는 것 입니다. 이렇게하면 이러한 모든 불명확 한 일치 항목이 제외되어이 메시지가 제거됩니다. 당신은 또한 말할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="6aabd99f333ab712e259e5fbe14c5365c3fb3eb5" translate="yes" xml:space="preserve">
          <source>Another option is to use the &lt;code&gt;iter&lt;/code&gt; class method to iterate over the files in the tarball without reading them all in memory at once.</source>
          <target state="translated">또 다른 옵션은 &lt;code&gt;iter&lt;/code&gt; 클래스 메소드를 사용하여 메모리에서 모든 파일을 한 번에 읽지 않고 tarball의 파일을 반복하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="82d37f84faabd12d777cc2ff160de45bc66b098d" translate="yes" xml:space="preserve">
          <source>Another option is to use the make written in Perl, available from CPAN.</source>
          <target state="translated">다른 옵션은 CPAN에서 사용 가능한 Perl로 작성된 make를 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="655a86d88b6839dd2179128ff91b78ce22ba6c96" translate="yes" xml:space="preserve">
          <source>Another peculiarity of urllist is that the site that we could successfully fetch the last file from automatically gets a preference token and is tried as the first site for the next request. So if you add a new site at runtime it may happen that the previously preferred site will be tried another time. This means that if you want to disallow a site for the next transfer, it must be explicitly removed from urllist.</source>
          <target state="translated">urllist의 또 다른 특징은 우리가 마지막 파일을 성공적으로 가져올 수있는 사이트가 자동으로 기본 설정 토큰을 가져 와서 다음 요청의 첫 번째 사이트로 시도한다는 것입니다. 따라서 런타임에 새 사이트를 추가하면 이전에 선호했던 사이트가 다시 시도 될 수 있습니다. 즉, 다음 전송을 위해 사이트를 허용하지 않으려면 urllist에서 명시 적으로 제거해야합니다.</target>
        </trans-unit>
        <trans-unit id="ce6cb12c61e008cd3f2b006405f6306cfa9808f3" translate="yes" xml:space="preserve">
          <source>Another point worth noting is that in the first series of examples I have made use of only the</source>
          <target state="translated">주목할만한 또 다른 요점은 첫 번째 일련의 예제에서</target>
        </trans-unit>
        <trans-unit id="4398365ad3174110f099b9553fe6a9ab1f982409" translate="yes" xml:space="preserve">
          <source>Another popular use for &lt;code&gt;recompile&lt;/code&gt; is to act as a rescue in case your perl breaks binary compatibility. If one of the modules that CPAN uses is in turn depending on binary compatibility (so you cannot run CPAN commands), then you should try the CPAN::Nox module for recovery.</source>
          <target state="translated">&lt;code&gt;recompile&lt;/code&gt; 위한 또 다른 일반적인 용도 는 펄이 바이너리 호환성을 깨뜨릴 경우 구조하는 것입니다. CPAN이 사용하는 모듈 중 하나가 이진 호환성에 따라 (CPAN 명령을 실행할 수없는 경우) 복구를 위해 CPAN :: Nox 모듈을 시도해야합니다.</target>
        </trans-unit>
        <trans-unit id="9d8cd00450b93b9762fe1f4860bcee6a18ea20de" translate="yes" xml:space="preserve">
          <source>Another possibility is that you forgot a backslash. Perl isn't smart enough to figure out what you really meant.</source>
          <target state="translated">또 다른 가능성은 백 슬래시를 잊었을 수 있습니다. 펄은 당신이 실제로 무엇을 의미하는지 알아낼만큼 똑똑하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="385e095c764654e0fb183ec8deedb8c0e3232a76" translate="yes" xml:space="preserve">
          <source>Another possible reason for problems is that you've used the indirect object syntax (eg, &lt;code&gt;find Guru &quot;Samy&quot;&lt;/code&gt; ) on a class name before Perl has seen that such a package exists. It's wisest to make sure your packages are all defined before you start using them, which will be taken care of if you use the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; statement instead of &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt;. If not, make sure to use arrow notation (eg., &lt;code&gt;Guru-&amp;gt;find(&quot;Samy&quot;)&lt;/code&gt; ) instead. Object notation is explained in &lt;a href=&quot;perlobj&quot;&gt;perlobj&lt;/a&gt;.</source>
          <target state="translated">문제가 발생할 수있는 또 다른 이유는 Perl이 그러한 패키지가 존재하기 전에 클래스 이름에 간접 객체 구문 (예 : &lt;code&gt;find Guru &quot;Samy&quot;&lt;/code&gt; 사용했기 때문입니다 . 패키지를 사용하기 전에 패키지가 모두 정의되어 있는지 확인하는 것이 가장 좋습니다 . &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; 대신 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 문 을 사용하면 처리 됩니다 . 그렇지 않은 경우 화살표 표기법 (예 : &lt;code&gt;Guru-&amp;gt;find(&quot;Samy&quot;)&lt;/code&gt; )을 대신 사용하십시오. 객체 표기법은 &lt;a href=&quot;perlobj&quot;&gt;perlobj에&lt;/a&gt; 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="fb10e4ab85598fb1febe5de364db832f8ae6b33d" translate="yes" xml:space="preserve">
          <source>Another possible reason for problems is that you've used the indirect object syntax (eg, &lt;code&gt;find Guru &quot;Samy&quot;&lt;/code&gt;) on a class name before Perl has seen that such a package exists. It's wisest to make sure your packages are all defined before you start using them, which will be taken care of if you use the &lt;code&gt;use&lt;/code&gt; statement instead of &lt;code&gt;require&lt;/code&gt;. If not, make sure to use arrow notation (eg., &lt;code&gt;Guru-&amp;gt;find(&quot;Samy&quot;)&lt;/code&gt;) instead. Object notation is explained in &lt;a href=&quot;perlobj&quot;&gt;perlobj&lt;/a&gt;.</source>
          <target state="translated">문제의 또 다른 가능한 이유는 Perl이 그러한 패키지가 존재하는 것을 확인하기 전에 클래스 이름에 간접 객체 구문 (예 : &lt;code&gt;find Guru &quot;Samy&quot;&lt;/code&gt; )을 사용했기 때문입니다 . 패키지 사용을 시작하기 전에 패키지가 모두 정의되어 있는지 확인하는 것이 가장 현명 &lt;code&gt;require&lt;/code&gt; . require 대신 &lt;code&gt;use&lt;/code&gt; 문 을 사용하면 처리 됩니다 . 그렇지 않은 경우 화살표 표기법 (예 : &lt;code&gt;Guru-&amp;gt;find(&quot;Samy&quot;)&lt;/code&gt; )을 대신 사용하십시오. 객체 표기법은 &lt;a href=&quot;perlobj&quot;&gt;perlobj에&lt;/a&gt; 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="c972997167e011df9a56046ecd4a5023cc5037ca" translate="yes" xml:space="preserve">
          <source>Another problem that occurs with inside-out classes is serialization. Since the object data is not in its usual place, standard routines like &lt;code&gt;Storable::freeze()&lt;/code&gt; , &lt;code&gt;Storable::thaw()&lt;/code&gt; and &lt;code&gt;Data::Dumper::Dumper()&lt;/code&gt; can't deal with it on their own. Both &lt;code&gt;Data::Dumper&lt;/code&gt; and &lt;code&gt;Storable&lt;/code&gt; provide the necessary hooks to make things work, but the functions or methods used by the hooks must be provided by each inside-out class.</source>
          <target state="translated">내부 클래스에서 발생하는 또 다른 문제는 직렬화입니다. 객체 데이터가 일반적인 위치에 있지 않기 때문에 &lt;code&gt;Storable::freeze()&lt;/code&gt; , &lt;code&gt;Storable::thaw()&lt;/code&gt; 및 &lt;code&gt;Data::Dumper::Dumper()&lt;/code&gt; 와 같은 표준 루틴 은 자체적으로 처리 할 수 ​​없습니다. 두 &lt;code&gt;Data::Dumper&lt;/code&gt; 및 &lt;code&gt;Storable&lt;/code&gt; 가지 작업을하는 데 필요한 후크를 제공하지만, 후크가 사용하는 기능이나 방법은 각각의 내부 아웃 클래스에서 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="0ea375285a64fb396aba7ed50ea3def9a1613d41" translate="yes" xml:space="preserve">
          <source>Another problem that occurs with inside-out classes is serialization. Since the object data is not in its usual place, standard routines like &lt;code&gt;Storable::freeze()&lt;/code&gt;, &lt;code&gt;Storable::thaw()&lt;/code&gt; and &lt;code&gt;Data::Dumper::Dumper()&lt;/code&gt; can't deal with it on their own. Both &lt;code&gt;Data::Dumper&lt;/code&gt; and &lt;code&gt;Storable&lt;/code&gt; provide the necessary hooks to make things work, but the functions or methods used by the hooks must be provided by each inside-out class.</source>
          <target state="translated">인사이드-아웃 클래스에서 발생하는 또 다른 문제는 직렬화입니다. 객체 데이터가 일반적인 위치에 있지 않기 때문에 &lt;code&gt;Storable::freeze()&lt;/code&gt; , &lt;code&gt;Storable::thaw()&lt;/code&gt; 및 &lt;code&gt;Data::Dumper::Dumper()&lt;/code&gt; 와 같은 표준 루틴 은 자체적으로 처리 할 수 ​​없습니다. &lt;code&gt;Data::Dumper&lt;/code&gt; 와 &lt;code&gt;Storable&lt;/code&gt; 은 모두 작업을 수행하는 데 필요한 후크를 제공하지만 후크에서 사용하는 함수 또는 메서드는 각 인사이드-아웃 클래스에서 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="4838334963e3cee1c557a4f6afcd664375d054be" translate="yes" xml:space="preserve">
          <source>Another problem with this approach is that operations that cross the single byte/multiple byte boundary are not well-defined, and so are disallowed. (This boundary is between the codepoints at 255/256.) For example, lower casing LATIN CAPITAL LETTER Y WITH DIAERESIS (U+0178) should return LATIN SMALL LETTER Y WITH DIAERESIS (U+00FF). But in the Greek locale, for example, there is no character at 0xFF, and Perl has no way of knowing what the character at 0xFF is really supposed to represent. Thus it disallows the operation. In this mode, the lowercase of U+0178 is itself.</source>
          <target state="translated">이 접근법의 또 다른 문제점은 단일 바이트 / 여러 바이트 경계를 넘는 조작이 잘 정의되지 않아서 허용되지 않는다는 것입니다. (이 경계는 코드 포인트 255/256 사이에 있습니다.) 예를 들어, 하부 케이싱이있는 라틴 대문자 문자 Y가 DIAERESIS (U + 0178)이면 라틴 문자가 Y 인 DIAERESIS (U + 00FF)를 반환해야합니다. 그러나 그리스어 로케일의 경우 0xFF에는 문자가 없으며 Perl은 0xFF의 문자가 실제로 무엇을 나타내는 지 알 수 없습니다. 따라서 작업을 허용하지 않습니다. 이 모드에서 U + 0178의 소문자 자체입니다.</target>
        </trans-unit>
        <trans-unit id="e3482e337a3d87721af4bdffd6d9b7cb27fdfc8f" translate="yes" xml:space="preserve">
          <source>Another reason it isn't completely a drop-in replacement is that it is declared to return &lt;code&gt;const char *&lt;/code&gt;, whereas the system setlocale omits the &lt;code&gt;const&lt;/code&gt; (presumably because its API was specified long ago, and can't be updated; it is illegal to change the information &lt;code&gt;setlocale&lt;/code&gt; returns; doing so leads to segfaults.)</source>
          <target state="translated">완전히 드롭 인 대체가 아닌 또 다른 이유는 &lt;code&gt;const char *&lt;/code&gt; 를 반환하도록 선언 된 반면 시스템 setlocale은 &lt;code&gt;const&lt;/code&gt; 를 생략한다는 것입니다 (아마도 API가 오래 전에 지정되어 업데이트 할 수 없기 때문입니다. 이것은 불법입니다. &lt;code&gt;setlocale&lt;/code&gt; 이 반환 하는 정보를 변경하려면 segfault가 발생합니다.)</target>
        </trans-unit>
        <trans-unit id="1d25e58d1b57cecb55c387a5dd5c52709e7a7cf9" translate="yes" xml:space="preserve">
          <source>Another reason that folks sometimes think they want a variable to contain the name of a variable is that they don't know how to build proper data structures using hashes. For example, let's say they wanted two hashes in their program: %fred and %barney, and that they wanted to use another scalar variable to refer to those by name.</source>
          <target state="translated">사람들이 변수에 변수 이름을 포함시키고 싶어하는 또 다른 이유는 해시를 사용하여 적절한 데이터 구조를 만드는 방법을 모르기 때문입니다. 예를 들어, 프로그램에서 % fred와 % barney라는 두 개의 해시를 원했고 다른 스칼라 변수를 사용하여 이름으로 참조한다고 가정 해 봅시다.</target>
        </trans-unit>
        <trans-unit id="0421a2fa7b166fbdb782231a9f8dbd1fd87115e8" translate="yes" xml:space="preserve">
          <source>Another reason to use &lt;code&gt;HASH&lt;/code&gt; is to provide your own hash variable. You can then inspect or modify the contents of the hash to gain finer control over the cache management.</source>
          <target state="translated">&lt;code&gt;HASH&lt;/code&gt; 를 사용해야하는 또 다른 이유 는 고유 한 해시 변수를 제공하기위한 것입니다. 그런 다음 해시의 내용을 검사하거나 수정하여 캐시 관리를보다 세밀하게 제어 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1d033aa9337856f2221026f5c7e24c794df0edbb" translate="yes" xml:space="preserve">
          <source>Another sample module, &lt;a href=&quot;Memoize::Saves&quot;&gt;Memoize::Saves&lt;/a&gt;, is available in a separate distribution on CPAN. It implements a policy that allows you to specify that certain function values would always be looked up afresh. See the documentation for details.</source>
          <target state="translated">또 다른 샘플 모듈 인 &lt;a href=&quot;Memoize::Saves&quot;&gt;Memoize :: Saves&lt;/a&gt; 는 CPAN에서 별도의 배포판으로 제공됩니다. 특정 함수 값이 항상 새로 검색되도록 지정할 수있는 정책을 구현합니다. 자세한 내용은 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="8b8bed8e10e25cfa736414741ddf1e9e2d2b9072" translate="yes" xml:space="preserve">
          <source>Another sample module, &lt;a href=&quot;http://search.cpan.org/perldoc/Memoize::Saves&quot;&gt;Memoize::Saves&lt;/a&gt;, is available in a separate distribution on CPAN. It implements a policy that allows you to specify that certain function values would always be looked up afresh. See the documentation for details.</source>
          <target state="translated">다른 샘플 모듈 인 &lt;a href=&quot;http://search.cpan.org/perldoc/Memoize::Saves&quot;&gt;Memoize :: Saves&lt;/a&gt; 는 CPAN에서 별도의 배포판으로 제공됩니다. 특정 기능 값을 항상 새로 검색하도록 지정할 수있는 정책을 구현합니다. 자세한 내용은 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="5d1b15340e7ecbdf1f65260c165ba0bcb3105f71" translate="yes" xml:space="preserve">
          <source>Another subtle error that can occur in resolving prerequisites comes from the way that modules in prerequisites are indexed to distribution files on CPAN. When a module is deleted from a distribution, prerequisites calling for that module could indicate an older distribution should be installed, potentially overwriting files from a newer distribution.</source>
          <target state="translated">전제 조건을 해결하는 데 발생할 수있는 또 다른 미묘한 오류는 전제 조건의 모듈이 CPAN의 배포 파일에 인덱싱되는 방식에서 비롯됩니다. 배포판에서 모듈이 삭제되면 해당 모듈을 호출하는 전제 조건은 이전 배포판을 설치해야 함을 나타내며 잠재적으로 최신 배포판의 파일을 덮어 쓸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f67a475c6b156df5eac51c84854028a80181079b" translate="yes" xml:space="preserve">
          <source>Another thing to try is learning whether your Perl was compiled with the system malloc or with Perl's builtin malloc. Whichever one it is, try using the other one and see whether this makes a difference. Information about malloc is in the</source>
          <target state="translated">시도해야 할 또 다른 것은 Perl이 시스템 malloc 또는 Perl의 내장 malloc으로 컴파일되었는지를 배우는 것입니다. 어느 쪽이든, 다른 쪽을 사용해보고 차이가 있는지 확인하십시오. malloc에 ​​대한 정보는</target>
        </trans-unit>
        <trans-unit id="a1cb48749447600d090febf98d3e4d0e00ee484e" translate="yes" xml:space="preserve">
          <source>Another thing you should bear in mind is that the UNINST parameter can be dangerous when you are installing into a private area because you might accidentally remove modules that other people depend on that are not using the private area.</source>
          <target state="translated">명심해야 할 또 다른 사항은 개인 영역에 설치할 때 UNINST 매개 변수가 위험 할 수 있다는 것입니다. 개인 영역을 사용하지 않는 다른 사람들이 의존하는 모듈을 실수로 제거 할 수 있기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="254082198376f41ade29efc6ce1df2a3ebdfd235" translate="yes" xml:space="preserve">
          <source>Another thorough remedy to that runtime vs. compile-time trap is to use &lt;a href=&quot;Exporter::Easy&quot;&gt;Exporter::Easy&lt;/a&gt;, which is a wrapper of Exporter that allows all boilerplate code at a single gulp in the use statement.</source>
          <target state="translated">런타임 대 컴파일 타임 트랩에 대한 또 다른 철저한 해결책 은 use 문에서 모든 상용구 코드를 한 번에 입력 할 수있는 Exporter의 래퍼 인 Exporter &lt;a href=&quot;Exporter::Easy&quot;&gt;:: Easy&lt;/a&gt; 를 사용 하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="fc7600b26c92e308f5a7b9737781947f5e033b05" translate="yes" xml:space="preserve">
          <source>Another thorough remedy to that runtime vs. compile-time trap is to use &lt;a href=&quot;http://search.cpan.org/perldoc/Exporter::Easy&quot;&gt;Exporter::Easy&lt;/a&gt;, which is a wrapper of Exporter that allows all boilerplate code at a single gulp in the use statement.</source>
          <target state="translated">해당 런타임과 컴파일 타임 트랩에 대한 또 다른 해결책은 &lt;a href=&quot;http://search.cpan.org/perldoc/Exporter::Easy&quot;&gt;Exporter :: Easy&lt;/a&gt; 를 사용하는 것입니다. Exporter :: Easy 는 모든 statementplate 코드를 use 문에서 단일 gulp로 허용하는 Exporter 래퍼입니다.</target>
        </trans-unit>
        <trans-unit id="8f128db16727c4206b263e3f2e5e2f91028aada1" translate="yes" xml:space="preserve">
          <source>Another typical use of redispatch would be in &lt;code&gt;AUTOLOAD&lt;/code&gt; 'ed methods. If such a method determined that it was not able to handle a particular call, it might choose to redispatch that call, in the hope that some other &lt;code&gt;AUTOLOAD&lt;/code&gt; (above it, or to its left) might do better.</source>
          <target state="translated">redispatch의 또 다른 일반적인 사용은 &lt;code&gt;AUTOLOAD&lt;/code&gt; 'ed 메소드입니다. 그러한 메소드가 특정 호출을 처리 할 수 ​​없다고 판단한 경우, 다른 &lt;code&gt;AUTOLOAD&lt;/code&gt; (위 또는 왼쪽)가 더 좋을 수 있기를 희망하여 해당 호출을 재발송 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c4228b8c62bb634355292e1e3ac8e4544658301e" translate="yes" xml:space="preserve">
          <source>Another typical use of redispatch would be in &lt;code&gt;AUTOLOAD&lt;/code&gt;'ed methods. If such a method determined that it was not able to handle a particular call, it might choose to redispatch that call, in the hope that some other &lt;code&gt;AUTOLOAD&lt;/code&gt; (above it, or to its left) might do better.</source>
          <target state="translated">redispatch의 또 다른 일반적인 용도는 &lt;code&gt;AUTOLOAD&lt;/code&gt; 'ed 메서드입니다. 이러한 메서드가 특정 호출을 처리 할 수 ​​없다고 판단한 경우 다른 &lt;code&gt;AUTOLOAD&lt;/code&gt; (위 또는 왼쪽)가 더 잘 수행 될 수 있기를 바라며 해당 호출을 다시 배포하도록 선택할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="28f35e8d306941d11adce5505a92ca2044351acf" translate="yes" xml:space="preserve">
          <source>Another unofficial source of data. Currently, it is not used to get data, but the notes and explanatory material were very useful for understanding discrepancies between the sources.</source>
          <target state="translated">비공식 데이터의 또 다른 출처. 현재는 데이터를 얻는 데 사용되지 않지만 참고와 설명 자료는 소스 간의 불일치를 이해하는 데 매우 유용했습니다.</target>
        </trans-unit>
        <trans-unit id="a159ba74ceaa166e4b6d8831134290b3cd8265be" translate="yes" xml:space="preserve">
          <source>Another use for &lt;code&gt;MERGE&lt;/code&gt; is when you want both kinds of return values stored in the same disk file; this saves you from having to deal with two disk files instead of one. You can use a normalizer function to keep the two sets of return values separate. For example:</source>
          <target state="translated">&lt;code&gt;MERGE&lt;/code&gt; 의 또 다른 용도 는 동일한 디스크 파일에 두 종류의 반환 값을 모두 저장하려는 경우입니다. 이렇게하면 하나가 아닌 두 개의 디스크 파일을 처리하지 않아도됩니다. 노멀 라이저 함수를 사용하여 두 세트의 리턴 값을 별도로 유지할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3dd7e16e7ef3fb6df50c7af26f6bc9d68c338053" translate="yes" xml:space="preserve">
          <source>Another use for a closure is to make a variable</source>
          <target state="translated">클로저의 또 다른 용도는 변수를 만드는 것입니다</target>
        </trans-unit>
        <trans-unit id="5cec4425942c518509d1fda3df7b77a63ebbfefa" translate="yes" xml:space="preserve">
          <source>Another use for escape sequences is to specify characters that cannot (or which you prefer not to) be written literally. These are described in detail in &lt;a href=&quot;perlrebackslash#Character-Escapes&quot;&gt;&quot;Character Escapes&quot; in perlrebackslash&lt;/a&gt;, but the next three paragraphs briefly describe some of them.</source>
          <target state="translated">이스케이프 시퀀스의 또 다른 용도는 문자 그대로 쓸 수 없거나 선호하지 않는 문자를 지정하는 것입니다. 이것들은 &lt;a href=&quot;perlrebackslash#Character-Escapes&quot;&gt;perlrebackslash의 &quot;문자 이스케이프&quot;&lt;/a&gt; 에 자세히 설명되어 있지만 다음 세 단락에서는 그 중 일부를 간략하게 설명합니다.</target>
        </trans-unit>
        <trans-unit id="a46f51ca5d9afdb7291b96d0559a5eecba4e7c63" translate="yes" xml:space="preserve">
          <source>Another use for normalizers is when the function depends on data other than those in its arguments. Suppose you have a function which returns a value which depends on the current hour of the day:</source>
          <target state="translated">노멀 라이저의 또 다른 용도는 함수가 인수의 데이터 이외의 데이터에 의존하는 경우입니다. 현재 시간에 따라 값을 반환하는 함수가 있다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="62444c7bc781846313fe8302369f08d7688eae95" translate="yes" xml:space="preserve">
          <source>Another use for the INIT: section is to check for preconditions before making a call to the C function:</source>
          <target state="translated">INIT : 섹션의 또 다른 용도는 C 함수를 호출하기 전에 사전 조건을 확인하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="3a9f1ae19985a41ad9db3a10b2882d84afcc8d3c" translate="yes" xml:space="preserve">
          <source>Another use for typeglobs is to pass filehandles into a function or to create new filehandles. If you need to use a typeglob to save away a filehandle, do it this way:</source>
          <target state="translated">typeglobs의 또 다른 용도는 파일 핸들을 함수에 전달하거나 새 파일 핸들을 만드는 것입니다. typeglob을 사용하여 파일 핸들을 저장해야하는 경우 다음과 같이하십시오.</target>
        </trans-unit>
        <trans-unit id="bd85fb00e79bd02a66b771e2ae402c322124bc55" translate="yes" xml:space="preserve">
          <source>Another use is to indicate that</source>
          <target state="translated">또 다른 용도는</target>
        </trans-unit>
        <trans-unit id="385eea7f2546356b9012fe969f08ace72fffebdd" translate="yes" xml:space="preserve">
          <source>Another use of symbol tables is for making &quot;constant&quot; scalars.</source>
          <target state="translated">심볼 테이블의 또 다른 용도는 &quot;일정한&quot;스칼라를 만드는 것입니다.</target>
        </trans-unit>
        <trans-unit id="7e444bc856c81853904c1c90381dc826b2163cfa" translate="yes" xml:space="preserve">
          <source>Another use of the generic object would be as a template. It is a convenient place to store class-specific defaults for various fields to be used in actual object initialization.</source>
          <target state="translated">일반 객체의 또 다른 용도는 템플릿입니다. 실제 객체 초기화에 사용되는 다양한 필드에 대한 클래스 별 기본값을 저장하는 편리한 위치입니다.</target>
        </trans-unit>
        <trans-unit id="03d707d0fcf79e0d7b50ca27287f1758fef3a3d9" translate="yes" xml:space="preserve">
          <source>Another useful shortcut is that, if you use a literal array or hash as the argument to &lt;code&gt;given&lt;/code&gt; , it is turned into a reference. So &lt;code&gt;given(@foo)&lt;/code&gt; is the same as &lt;code&gt;given(\@foo)&lt;/code&gt; , for example.</source>
          <target state="translated">&lt;code&gt;given&lt;/code&gt; 의 인수로 리터럴 배열이나 해시 를 사용하면 참조로 바뀐다 는 또 다른 유용한 단축키가 있습니다. 그래서 &lt;code&gt;given(@foo)&lt;/code&gt; 동일하다 &lt;code&gt;given(\@foo)&lt;/code&gt; 예를 들어,.</target>
        </trans-unit>
        <trans-unit id="cc6a78b5df54e2e6affa44db83d9141a9a6580a8" translate="yes" xml:space="preserve">
          <source>Another useful shortcut is that, if you use a literal array or hash as the argument to &lt;code&gt;given&lt;/code&gt;, it is turned into a reference. So &lt;code&gt;given(@foo)&lt;/code&gt; is the same as &lt;code&gt;given(\@foo)&lt;/code&gt;, for example.</source>
          <target state="translated">또 다른 유용한 단축키는 &lt;code&gt;given&lt;/code&gt; 대한 인수로 리터럴 배열 또는 해시 를 사용하면 참조로 변환된다는 것입니다. 따라서 &lt;code&gt;given(@foo)&lt;/code&gt; 는 예를 들어 &lt;code&gt;given(\@foo)&lt;/code&gt; 과 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="4a05112cda91b50dc34bb4913074b7fa53fabce3" translate="yes" xml:space="preserve">
          <source>Another variation on a theme. This time we will modify the &lt;code&gt;Subst&lt;/code&gt; filter to allow a starting and stopping pattern to be specified as well as the</source>
          <target state="translated">테마의 또 다른 변형. 이번에는 &lt;code&gt;Subst&lt;/code&gt; 필터를 수정하여 시작 및 중지 패턴과</target>
        </trans-unit>
        <trans-unit id="95d0ad8589b46d03f061e120707df66c84d9cbde" translate="yes" xml:space="preserve">
          <source>Another version uses a global match in list context, then assigns the result to a scalar, producing a count of the number of matches.</source>
          <target state="translated">다른 버전에서는 목록 컨텍스트에서 전역 일치를 사용한 다음 결과를 스칼라에 할당하여 일치 횟수를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="a0589db0a4f4f29bef401c1107ff7696f0cffdbb" translate="yes" xml:space="preserve">
          <source>Another way is to assign to a substr() that's off the end of the string.</source>
          <target state="translated">또 다른 방법은 문자열의 끝 부분에있는 substr ()에 할당하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="d77d43e614a814160a75653eb86a2b6f1db8267e" translate="yes" xml:space="preserve">
          <source>Another way is to use the &lt;a href=&quot;Tie::File&quot;&gt;Tie::File&lt;/a&gt; module, which treats the entire file as an array. Simply access a random array element.</source>
          <target state="translated">또 다른 방법은 전체 파일을 배열로 취급하는 &lt;a href=&quot;Tie::File&quot;&gt;Tie :: File&lt;/a&gt; 모듈 을 사용하는 것 입니다. 임의의 배열 요소에 액세스하기 만하면됩니다.</target>
        </trans-unit>
        <trans-unit id="3c83abcaae94dfa04aa0d7e9c83f8b2a9880cd1b" translate="yes" xml:space="preserve">
          <source>Another way is to use the &lt;a href=&quot;tie/file&quot;&gt;Tie::File&lt;/a&gt; module, which treats the entire file as an array. Simply access a random array element.</source>
          <target state="translated">다른 방법은 전체 파일을 배열로 취급하는 &lt;a href=&quot;tie/file&quot;&gt;Tie :: File&lt;/a&gt; 모듈 을 사용하는 것 입니다. 임의의 배열 요소에 간단히 액세스하십시오.</target>
        </trans-unit>
        <trans-unit id="360771e8bfe1eade19d5dbc8ea8baae5f8a955ef" translate="yes" xml:space="preserve">
          <source>Another way is to use undef as an element on the left-hand-side:</source>
          <target state="translated">또 다른 방법은 undef를 왼쪽의 요소로 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="b6dde2905ab30997325ea52458484ff80b17847e" translate="yes" xml:space="preserve">
          <source>Another way of describing the operation is this: If &lt;code&gt;/c&lt;/code&gt; is specified, the</source>
          <target state="translated">작업을 설명하는 또 다른 방법은 다음과 같습니다. &lt;code&gt;/c&lt;/code&gt; 를 지정하면</target>
        </trans-unit>
        <trans-unit id="8b74b30f842e3a2fe422587280e297e6a0fb34e2" translate="yes" xml:space="preserve">
          <source>Another way of thinking about this function is finding a needle in a haystack. &lt;code&gt;big&lt;/code&gt; points to the first byte in the haystack. &lt;code&gt;big_end&lt;/code&gt; points to one byte beyond the final byte in the haystack. &lt;code&gt;little&lt;/code&gt; points to the first byte in the needle. &lt;code&gt;little_end&lt;/code&gt; points to one byte beyond the final byte in the needle. All the parameters must be non-&lt;code&gt;NULL&lt;/code&gt;.</source>
          <target state="translated">이 기능에 대해 생각하는 또 다른 방법은 건초 더미에서 바늘을 찾는 것입니다. &lt;code&gt;big&lt;/code&gt; 은 건초 더미의 첫 번째 바이트를 가리 킵니다. &lt;code&gt;big_end&lt;/code&gt; 는 건초 더미에서 마지막 바이트를 넘어서 1 바이트를 가리 킵니다. &lt;code&gt;little&lt;/code&gt; 바늘의 첫 번째 바이트를 가리 킵니다. &lt;code&gt;little_end&lt;/code&gt; 는 바늘의 마지막 바이트를 넘어서 1 바이트를 가리 킵니다. 모든 매개 변수는 &lt;code&gt;NULL&lt;/code&gt; 이 아니어야합니다 .</target>
        </trans-unit>
        <trans-unit id="f81299a8407385b954919f2cec05019d576de6e8" translate="yes" xml:space="preserve">
          <source>Another way to create anonymous filehandles is with the Symbol module or with the IO::Handle module and its ilk. These modules have the advantage of not hiding different types of the same name during the local(). See the bottom of &lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt; for an example.</source>
          <target state="translated">익명의 파일 핸들을 만드는 또 다른 방법은 Symbol 모듈이나 IO :: Handle 모듈과 해당 ilk를 사용하는 것입니다. 이 모듈은 local () 중에 같은 이름의 다른 유형을 숨기지 않는 이점이 있습니다. 예를 들어 &lt;a href=&quot;functions/open&quot;&gt;오픈&lt;/a&gt; 하단을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="6660859ea71d8fc8ba79b6222c7cabca290a534d" translate="yes" xml:space="preserve">
          <source>Another way to create anonymous filehandles is with the Symbol module or with the IO::Handle module and its ilk. These modules have the advantage of not hiding different types of the same name during the local(). See the bottom of &lt;a href=&quot;perlfunc#open&quot;&gt;&quot;open&quot; in perlfunc&lt;/a&gt; for an example.</source>
          <target state="translated">익명 파일 핸들을 만드는 또 다른 방법은 Symbol 모듈 또는 IO :: Handle 모듈과 ilk를 사용하는 것입니다. 이러한 모듈은 local () 동안 동일한 이름의 다른 유형을 숨기지 않는 장점이 있습니다. 예제 &lt;a href=&quot;perlfunc#open&quot;&gt;는 perlfunc&lt;/a&gt; 의 &quot;open&quot; 하단을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e614c6db5b38b002f45562db1a27e62289c42947" translate="yes" xml:space="preserve">
          <source>Another way to debug compile-time code is to start the debugger, set a breakpoint on the</source>
          <target state="translated">컴파일 타임 코드를 디버깅하는 또 다른 방법은 디버거를 시작하고 중단 점을 설정하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="9901f72c76524abdcc53f059c75aff5db9ab2a29" translate="yes" xml:space="preserve">
          <source>Another way to declare &lt;code&gt;host&lt;/code&gt; is to use a C block in the CODE: section:</source>
          <target state="translated">&lt;code&gt;host&lt;/code&gt; 를 선언하는 또 다른 방법 은 CODE : 섹션에서 C 블록을 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="205baf27defe296be93a335acebfa113cc8193c2" translate="yes" xml:space="preserve">
          <source>Another way to disable the safe signal behavior locally is to use the &lt;code&gt;Perl::Unsafe::Signals&lt;/code&gt; module from CPAN, which affects all signals.</source>
          <target state="translated">안전 신호 동작을 로컬로 비활성화하는 다른 방법 은 CPAN 의 &lt;code&gt;Perl::Unsafe::Signals&lt;/code&gt; 모듈 을 사용하여 모든 신호에 영향을주는 것입니다.</target>
        </trans-unit>
        <trans-unit id="11569e74dec6446efa52dec2c7a4e093532b6648" translate="yes" xml:space="preserve">
          <source>Another way to examine the tree is to use a compiler back-end module, such as &lt;a href=&quot;B::Concise&quot;&gt;B::Concise&lt;/a&gt;.</source>
          <target state="translated">트리를 검사하는 또 다른 방법은 &lt;a href=&quot;B::Concise&quot;&gt;B :: Concise&lt;/a&gt; 와 같은 컴파일러 백엔드 모듈을 사용하는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="68459b39b80a3326501665280a8d6df2de3c0dc3" translate="yes" xml:space="preserve">
          <source>Another way to examine the tree is to use a compiler back-end module, such as &lt;a href=&quot;b/concise&quot;&gt;B::Concise&lt;/a&gt;.</source>
          <target state="translated">트리를 검사하는 또 다른 방법은 &lt;a href=&quot;b/concise&quot;&gt;B :: Concise&lt;/a&gt; 와 같은 컴파일러 백엔드 모듈을 사용하는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="1475dee12421b2759f280ec12406b6a9a8686bb7" translate="yes" xml:space="preserve">
          <source>Another way to lay hands on a reference to the underlying object is to use the tied() function, so they might alternately have set clobber using:</source>
          <target state="translated">기본 객체를 참조하는 또 다른 방법은 tied () 함수를 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="00149c3d1137c9330feb23e2fe36062f95ccc0ba" translate="yes" xml:space="preserve">
          <source>Another way to look at it is via bits:</source>
          <target state="translated">그것을 보는 또 다른 방법은 비트를 이용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="87cb792899401773acea6f65b31b31644b7caaf0" translate="yes" xml:space="preserve">
          <source>Another way to modify &lt;code&gt;@INC&lt;/code&gt; without modifying the program, is to use the &lt;code&gt;lib&lt;/code&gt; pragma, e.g.:</source>
          <target state="translated">프로그램 을 수정 &lt;code&gt;@INC&lt;/code&gt; 않고 @INC 를 수정하는 다른 방법 은 다음과 같이 &lt;code&gt;lib&lt;/code&gt; pragma 를 사용하는 것입니다 .</target>
        </trans-unit>
        <trans-unit id="53f5ac93c7a0f074f16d88622079abd1a07b9541" translate="yes" xml:space="preserve">
          <source>Another way to see the output of a PM program is to run it as</source>
          <target state="translated">PM 프로그램의 출력을 보는 다른 방법은 다음과 같이 실행하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="60d4191bfc5b5a27fe1df7d104bb0fb301db392c" translate="yes" xml:space="preserve">
          <source>Another way to skip over characters in a UTF-8 string is to use &lt;code&gt;utf8_hop&lt;/code&gt; , which takes a string and a number of characters to skip over. You're on your own about bounds checking, though, so don't use it lightly.</source>
          <target state="translated">UTF-8 문자열에서 문자를 건너 뛰는 또 다른 방법은 &lt;code&gt;utf8_hop&lt;/code&gt; 을 사용하는 것입니다. utf8_hop 는 문자열과 건너 뛰기 위해 여러 문자를 사용합니다. 당신은 경계 검사에 대해 스스로하고 있으므로 가볍게 사용하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="bdbeba721ab6028c2b3830fe28f0b278956ef2ae" translate="yes" xml:space="preserve">
          <source>Another way to skip over characters in a UTF-8 string is to use &lt;code&gt;utf8_hop&lt;/code&gt;, which takes a string and a number of characters to skip over. You're on your own about bounds checking, though, so don't use it lightly.</source>
          <target state="translated">UTF-8 문자열에서 문자를 건너 뛰는 또 다른 방법은 건너 뛸 문자열과 문자 수를 취하는 &lt;code&gt;utf8_hop&lt;/code&gt; 을 사용 하는 것입니다. 그러나 경계 검사에 대해서는 혼자이므로 가볍게 사용하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="ebbeb1bfc20bbb2eabb0051011fd1f94e30bfced" translate="yes" xml:space="preserve">
          <source>Another way to specify many INSTALL directories with a single parameter is LIB.</source>
          <target state="translated">단일 매개 변수로 많은 INSTALL 디렉토리를 지정하는 다른 방법은 LIB입니다.</target>
        </trans-unit>
        <trans-unit id="ab320674027c2ae8c6c6ac4c9c8202490be618cd" translate="yes" xml:space="preserve">
          <source>Another way to write &lt;code&gt;Is_latin_1()&lt;/code&gt; would be to use the characters in the range explicitly:</source>
          <target state="translated">&lt;code&gt;Is_latin_1()&lt;/code&gt; 을 작성하는 또 다른 방법 은 범위 내의 문자를 명시 적으로 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="7b86cf4ed2b3d4be5d67a5a0ca22b08970c9b1b4" translate="yes" xml:space="preserve">
          <source>Ansgar Burchardt &amp;lt;ansgar@cpan.org&amp;gt;</source>
          <target state="translated">Ansgar Burchardt &amp;lt;ansgar@cpan.org&amp;gt;</target>
        </trans-unit>
        <trans-unit id="fcb531954bffd941479549648f2841c2d77a7164" translate="yes" xml:space="preserve">
          <source>Anton Tagunov doubts its usefulness.</source>
          <target state="translated">Anton Tagunov는 그 유용성을 의심합니다.</target>
        </trans-unit>
        <trans-unit id="697b561300a9259946d1254bc1d65f626fe87539" translate="yes" xml:space="preserve">
          <source>Any $(FOO) used in the examples are make variables, not Perl.</source>
          <target state="translated">예제에서 사용 된 $ (FOO)는 Perl이 아닌 make 변수입니다.</target>
        </trans-unit>
        <trans-unit id="bea7ca75aae1ff5f6e730010d46af50a09d7d1c8" translate="yes" xml:space="preserve">
          <source>Any &lt;a href=&quot;perlunicode#User-Defined-Character-Properties&quot;&gt;user-defined property&lt;/a&gt; used must be already defined by the time the regular expression is compiled (but note that this construct can be used instead of such properties).</source>
          <target state="translated">사용되는 모든 &lt;a href=&quot;perlunicode#User-Defined-Character-Properties&quot;&gt;사용자 정의 속성&lt;/a&gt; 은 정규식이 컴파일 될 때 이미 정의되어 있어야합니다 (그러나 이러한 속성 대신이 구문을 사용할 수 있습니다).</target>
        </trans-unit>
        <trans-unit id="31e755c53eda86352ddd4b11acb45031c2d27960" translate="yes" xml:space="preserve">
          <source>Any &lt;b&gt;class method&lt;/b&gt;, &lt;b&gt;instance&lt;/b&gt;, or &lt;b&gt;subroutine&lt;/b&gt; that composes, initializes, blesses, and returns an &lt;b&gt;object&lt;/b&gt;. Sometimes we use the term loosely to mean a &lt;b&gt;composer&lt;/b&gt;.</source>
          <target state="translated">&lt;b&gt;객체&lt;/b&gt; 를 작성, 초기화, 축복 및 반환하는 모든 &lt;b&gt;클래스 메소드&lt;/b&gt; , &lt;b&gt;인스턴스&lt;/b&gt; 또는 &lt;b&gt;서브 루틴&lt;/b&gt; . 때때로 우리는 &lt;b&gt;작곡가&lt;/b&gt; 를 의미하기 위해 느슨하게 용어를 사용합니다 .&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="ebc443723afa597f0f46ae7e71ea2b268b18eec2" translate="yes" xml:space="preserve">
          <source>Any &lt;code&gt;\&lt;/code&gt; (backslashes) are converted to &lt;code&gt;/&lt;/code&gt; (forward slashes), and then File::Spec::Unix canonpath() is called on the result.</source>
          <target state="translated">모든 &lt;code&gt;\&lt;/code&gt; (백 슬래시)는 &lt;code&gt;/&lt;/code&gt; (슬래시)로 변환 된 다음 File :: Spec :: Unix canonpath ()가 결과에서 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="0297ad87a59e1b9acfbd34804e1d88eb60665363" translate="yes" xml:space="preserve">
          <source>Any &lt;code&gt;make&lt;/code&gt; or &lt;code&gt;test&lt;/code&gt; is run unconditionally. An</source>
          <target state="translated">모든 &lt;code&gt;make&lt;/code&gt; 또는 &lt;code&gt;test&lt;/code&gt; 는 무조건 실행됩니다. 안</target>
        </trans-unit>
        <trans-unit id="bf7362a2fe12e03fc4b84c1c886bc1d5ed325938" translate="yes" xml:space="preserve">
          <source>Any &lt;code&gt;use utf8&lt;/code&gt; or &lt;code&gt;no utf8&lt;/code&gt; declarations within the string have no effect, and source filters are forbidden. (&lt;code&gt;unicode_strings&lt;/code&gt;, however, can appear within the string.) See also the &lt;a href=&quot;#evalbytes-EXPR&quot;&gt;&lt;code&gt;evalbytes&lt;/code&gt;&lt;/a&gt; operator, which works properly with source filters.</source>
          <target state="translated">모든 &lt;code&gt;use utf8&lt;/code&gt; 또는 &lt;code&gt;no utf8&lt;/code&gt; 문자열 내에서 선언은 아무런 영향을 미치지 않으며, 소스 필터는 금지되어 있습니다. ( 그러나 &lt;code&gt;unicode_strings&lt;/code&gt; 는 문자열 내에 나타날 수 있습니다.) 소스 필터에서 제대로 작동 하는 &lt;a href=&quot;#evalbytes-EXPR&quot;&gt; &lt;code&gt;evalbytes&lt;/code&gt; &lt;/a&gt; 연산자 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="3cd3503f8d612240a0cdcfcf3958cd4b47fd1bc1" translate="yes" xml:space="preserve">
          <source>Any SV may be magical, that is, it has special features that a normal SV does not have. These features are stored in the SV structure in a linked list of &lt;code&gt;struct magic&lt;/code&gt; 's, typedef'ed to &lt;code&gt;MAGIC&lt;/code&gt; .</source>
          <target state="translated">모든 SV는 마법적일 수 있습니다. 즉, 일반 SV에는없는 특별한 기능이 있습니다. 이러한 기능은 SV 구조에 &lt;code&gt;struct magic&lt;/code&gt; 의 링크 된 목록 으로 &lt;code&gt;MAGIC&lt;/code&gt; 에 typedef로 저장됩니다 .</target>
        </trans-unit>
        <trans-unit id="33b69c22f5834c109ce23cffa5c65513da0e84fe" translate="yes" xml:space="preserve">
          <source>Any SV may be magical, that is, it has special features that a normal SV does not have. These features are stored in the SV structure in a linked list of &lt;code&gt;struct magic&lt;/code&gt;'s, typedef'ed to &lt;code&gt;MAGIC&lt;/code&gt;.</source>
          <target state="translated">모든 SV는 마술적일 수 있습니다. 즉, 일반 SV에는없는 특별한 기능이 있습니다. 이러한 기능은 &lt;code&gt;MAGIC&lt;/code&gt; 에 typedef가 지정된 &lt;code&gt;struct magic&lt;/code&gt; 의 연결 목록에있는 SV 구조체에 저장됩니다 .</target>
        </trans-unit>
        <trans-unit id="3990dd07c484552abc78d056ff16c2e2a8e23114" translate="yes" xml:space="preserve">
          <source>Any additional arguments are expected to be names of modules to generate code for.</source>
          <target state="translated">추가 인수는 코드를 생성 할 모듈의 이름이어야합니다.</target>
        </trans-unit>
        <trans-unit id="33e9e1331c3f51ebe91a9bc05248aec433c1afce" translate="yes" xml:space="preserve">
          <source>Any additional arguments found before the &lt;b&gt;--&lt;/b&gt; token are expected to be names of modules to generate code for.</source>
          <target state="translated">&lt;b&gt;-&lt;/b&gt; 토큰 이전에 발견 된 추가 인수 는 코드를 생성 할 모듈의 이름이어야합니다.</target>
        </trans-unit>
        <trans-unit id="c6e53a3422c150f8910984634fe5fc4926bb37bc" translate="yes" xml:space="preserve">
          <source>Any additional flags you wish to pass to the linker.</source>
          <target state="translated">링커에 전달하려는 추가 플래그</target>
        </trans-unit>
        <trans-unit id="76af9e90cc2fb275b94658ee19c44c077d496116" translate="yes" xml:space="preserve">
          <source>Any argument provided is passed as CHECK to underlying Encode::decode() call. Pass the value &lt;code&gt;Encode::FB_CROAK&lt;/code&gt; to have the decoding croak if not all the command line arguments can be decoded. See &lt;a href=&quot;encode#Handling-Malformed-Data&quot;&gt;&quot;Handling Malformed Data&quot; in Encode&lt;/a&gt; for details on other options for CHECK.</source>
          <target state="translated">제공된 모든 인수는 기본 Encode :: decode () 호출에 CHECK로 전달됩니다. 모든 명령 줄 인수를 디코딩 할 수없는 경우 디코딩 &lt;code&gt;Encode::FB_CROAK&lt;/code&gt; 하도록 Encode :: FB_CROAK 값을 전달합니다. CHECK의 다른 옵션에 대한 자세한 내용 &lt;a href=&quot;encode#Handling-Malformed-Data&quot;&gt;은 Encode의 &quot;잘못된 형식의 데이터 처리&quot;를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="28fc9753c4799266fbd1d9873fa8ed5292bbf609" translate="yes" xml:space="preserve">
          <source>Any argument which looks like a signal name (that is, &lt;code&gt;/^[A-Z][A-Z0-9]*$/&lt;/code&gt; ) indicates that &lt;b&gt;sigtrap&lt;/b&gt; should install a handler for that name.</source>
          <target state="translated">신호 이름처럼 보이는 인수 (즉, &lt;code&gt;/^[A-Z][A-Z0-9]*$/&lt;/code&gt; )는 &lt;b&gt;sigtrap&lt;/b&gt; 이 해당 이름의 핸들러를 설치해야 함을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="f26e937185e1c5cd97a379a8dabb810b138157bc" translate="yes" xml:space="preserve">
          <source>Any argument which looks like a signal name (that is, &lt;code&gt;/^[A-Z][A-Z0-9]*$/&lt;/code&gt;) indicates that &lt;b&gt;sigtrap&lt;/b&gt; should install a handler for that name.</source>
          <target state="translated">신호 이름 (즉, &lt;code&gt;/^[A-Z][A-Z0-9]*$/&lt;/code&gt; ) 처럼 보이는 인수 는 &lt;b&gt;sigtrap&lt;/b&gt; 이 해당 이름에 대한 핸들러를 설치해야 함을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="669f46fd59266a6910f9368caa3825ce94a0d579" translate="yes" xml:space="preserve">
          <source>Any arguments after the second '--' token are additional linker arguments that will be examined for potential conflict. If there is no conflict, the additional arguments will be part of the output.</source>
          <target state="translated">두 번째 '-'토큰 뒤의 인수는 잠재적 인 충돌이 있는지 검사 할 추가 링커 인수입니다. 충돌이 없으면 추가 인수가 출력의 일부가됩니다.</target>
        </trans-unit>
        <trans-unit id="b8ba7c975cc3879d276e04e3e9eb8ad2f669d5cb" translate="yes" xml:space="preserve">
          <source>Any arguments passed in show up in the array &lt;code&gt;@_&lt;/code&gt; . (They may also show up in lexical variables introduced by a signature; see &lt;a href=&quot;#Signatures&quot;&gt;Signatures&lt;/a&gt; below.) Therefore, if you called a function with two arguments, those would be stored in &lt;code&gt;$_[0]&lt;/code&gt; and &lt;code&gt;$_[1]&lt;/code&gt; . The array &lt;code&gt;@_&lt;/code&gt; is a local array, but its elements are aliases for the actual scalar parameters. In particular, if an element &lt;code&gt;$_[0]&lt;/code&gt; is updated, the corresponding argument is updated (or an error occurs if it is not updatable). If an argument is an array or hash element which did not exist when the function was called, that element is created only when (and if) it is modified or a reference to it is taken. (Some earlier versions of Perl created the element whether or not the element was assigned to.) Assigning to the whole array &lt;code&gt;@_&lt;/code&gt; removes that aliasing, and does not update any arguments.</source>
          <target state="translated">전달 된 인수는 배열 &lt;code&gt;@_&lt;/code&gt; 에 표시됩니다 . (그들은 또한 서명에 의해 도입 된 어휘 변수에 표시 할 수있다; 참조 &lt;a href=&quot;#Signatures&quot;&gt;서명&lt;/a&gt; . 아래)을 따라서 두 개의 인자를 가진 함수를 호출하는 경우, 그가에 저장됩니다 &lt;code&gt;$_[0]&lt;/code&gt; 과 &lt;code&gt;$_[1]&lt;/code&gt; . 배열 &lt;code&gt;@_&lt;/code&gt; 은 로컬 배열이지만 해당 요소는 실제 스칼라 매개 변수의 별칭입니다. 특히 &lt;code&gt;$_[0]&lt;/code&gt; 요소가업데이트되면 해당 인수가 업데이트됩니다 (또는 업데이트 할 수없는 경우 오류가 발생 함). 인수가 함수가 호출 될 때 존재하지 않은 배열 또는 해시 요소 인 경우, 해당 요소는 수정되거나 참조 될 때만 작성됩니다. (이전 버전의 Perl은 요소의 할당 여부에 관계없이 요소를 작성했습니다.) 전체 배열에 할당하면 &lt;code&gt;@_&lt;/code&gt; 이 해당 앨리어싱을 제거하고 인수를 업데이트하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f35f240798e3c5e460d473d423be038d4c72e7d0" translate="yes" xml:space="preserve">
          <source>Any arguments passed in show up in the array &lt;code&gt;@_&lt;/code&gt;. (They may also show up in lexical variables introduced by a signature; see &lt;a href=&quot;#Signatures&quot;&gt;&quot;Signatures&quot;&lt;/a&gt; below.) Therefore, if you called a function with two arguments, those would be stored in &lt;code&gt;$_[0]&lt;/code&gt; and &lt;code&gt;$_[1]&lt;/code&gt;. The array &lt;code&gt;@_&lt;/code&gt; is a local array, but its elements are aliases for the actual scalar parameters. In particular, if an element &lt;code&gt;$_[0]&lt;/code&gt; is updated, the corresponding argument is updated (or an error occurs if it is not updatable). If an argument is an array or hash element which did not exist when the function was called, that element is created only when (and if) it is modified or a reference to it is taken. (Some earlier versions of Perl created the element whether or not the element was assigned to.) Assigning to the whole array &lt;code&gt;@_&lt;/code&gt; removes that aliasing, and does not update any arguments.</source>
          <target state="translated">전달 된 모든 인수는 &lt;code&gt;@_&lt;/code&gt; 배열에 표시됩니다 . (시그니처에 의해 도입 된 어휘 변수에도 표시 될 수 있습니다. 아래 &lt;a href=&quot;#Signatures&quot;&gt;&quot;서명&quot;을&lt;/a&gt; 참조하십시오 .) 따라서 두 개의 인수가있는 함수를 호출하면 &lt;code&gt;$_[0]&lt;/code&gt; 및 &lt;code&gt;$_[1]&lt;/code&gt; 에 저장 됩니다. 배열 &lt;code&gt;@_&lt;/code&gt; 는 로컬 배열이지만 해당 요소는 실제 스칼라 매개 변수의 별칭입니다. 특히 &lt;code&gt;$_[0]&lt;/code&gt; 요소가업데이트되면 해당 인수가 업데이트됩니다 (또는 업데이트 할 수없는 경우 오류가 발생 함). 인수가 함수가 호출 될 때 존재하지 않았던 배열 또는 해시 요소 인 경우 해당 요소는 수정되거나 참조를 가져 오는 경우에만 생성됩니다. (펄의 일부 이전 버전의 요소가 할당되었는지 여부 요소를 만들었습니다.) 전체 배열에 할당는 &lt;code&gt;@_&lt;/code&gt; 그 앨리어싱을 제거하고 인수를 업데이트하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ff6247c19341895e60632e62b6ff63ef2ca7a1ee" translate="yes" xml:space="preserve">
          <source>Any attempt by the code in STRING to use an operator which is not permitted by the compartment will cause an error (at run-time of the main program but at compile-time for the code in STRING). The error is of the form &quot;'%s' trapped by operation mask...&quot;.</source>
          <target state="translated">구획에 의해 허용되지 않는 연산자를 사용하여 STRING의 코드로 시도하면 오류가 발생합니다 (기본 프로그램의 런타임에는 STRING의 코드에 대해 컴파일 타임). 오류는 &quot; '% s'작업 마스크에 의해 트랩되었습니다 ...&quot;형식입니다.</target>
        </trans-unit>
        <trans-unit id="813cebd9a54eacff09b02a5f15b34a12df0ec8d1" translate="yes" xml:space="preserve">
          <source>Any backslashed prototype character represents an actual argument that must start with that character (optionally preceded by &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt;), with the exception of &lt;code&gt;$&lt;/code&gt; , which will accept any scalar lvalue expression, such as &lt;code&gt;$foo = 7&lt;/code&gt; or &lt;code&gt;my_function()-&amp;gt;[0]&lt;/code&gt; . The value passed as part of &lt;code&gt;@_&lt;/code&gt; will be a reference to the actual argument given in the subroutine call, obtained by applying &lt;code&gt;\&lt;/code&gt; to that argument.</source>
          <target state="translated">백 슬래시 프로토 타입 문자는 &lt;code&gt;$&lt;/code&gt; 을 제외 하고 해당 문자로 시작해야하는 실제 인수 (선택적으로 &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; )를 나타내며 &lt;code&gt;$foo = 7&lt;/code&gt; 또는 &lt;code&gt;my_function()-&amp;gt;[0]&lt;/code&gt; 과 같은 스칼라 lvalue 표현식을 허용합니다. &amp;gt; [0] . &lt;code&gt;@_&lt;/code&gt; 의 일부로 전달 된 값은 해당 인수에 &lt;code&gt;\&lt;/code&gt; 를 적용하여 얻은 서브 루틴 호출에 제공된 실제 인수에 대한 참조 입니다.</target>
        </trans-unit>
        <trans-unit id="ffa3112ef74eec5708dbce1d67d94690c63f3116" translate="yes" xml:space="preserve">
          <source>Any backslashed prototype character represents an actual argument that must start with that character (optionally preceded by &lt;code&gt;my&lt;/code&gt;, &lt;code&gt;our&lt;/code&gt; or &lt;code&gt;local&lt;/code&gt;), with the exception of &lt;code&gt;$&lt;/code&gt;, which will accept any scalar lvalue expression, such as &lt;code&gt;$foo = 7&lt;/code&gt; or &lt;code&gt;my_function()-&amp;gt;[0]&lt;/code&gt;. The value passed as part of &lt;code&gt;@_&lt;/code&gt; will be a reference to the actual argument given in the subroutine call, obtained by applying &lt;code&gt;\&lt;/code&gt; to that argument.</source>
          <target state="translated">백 슬래시가있는 모든 프로토 타입 문자는 해당 문자로 시작해야하는 실제 인수를 나타냅니다 (선택적으로 &lt;code&gt;my&lt;/code&gt; , &lt;code&gt;our&lt;/code&gt; 또는 &lt;code&gt;local&lt;/code&gt; 이 선행 됨 ). &lt;code&gt;$foo = 7&lt;/code&gt; 또는 &lt;code&gt;my_function()-&amp;gt;[0]&lt;/code&gt; 과 같은 모든 스칼라 lvalue 표현식을 허용하는 &lt;code&gt;$&lt;/code&gt; 는 예외입니다. &amp;gt; [0] . &lt;code&gt;@_&lt;/code&gt; 의 일부로 전달 된 값은 해당 인수에 &lt;code&gt;\&lt;/code&gt; 를 적용하여 얻은 서브 루틴 호출에 제공된 실제 인수에 대한 참조가됩니다 .</target>
        </trans-unit>
        <trans-unit id="e8738a2a75fb40cb2ee10b2d9e2137a995a5cab3" translate="yes" xml:space="preserve">
          <source>Any call from a package to itself is safe.</source>
          <target state="translated">패키지에서 자체로의 모든 호출은 안전합니다.</target>
        </trans-unit>
        <trans-unit id="4b72ee9b0cb5399c6a83f5d4a70d821be8027231" translate="yes" xml:space="preserve">
          <source>Any call from an internal Perl module is safe. (Nothing keeps user modules from marking themselves as internal to Perl, but this practice is discouraged.)</source>
          <target state="translated">내부 Perl 모듈의 모든 호출은 안전합니다. (사용자 모듈이 자신을 Perl의 내부로 표시하는 것을 막는 것은 없지만이 방법은 권장하지 않습니다.)</target>
        </trans-unit>
        <trans-unit id="32561ad60b0d62ef81eb27f4c0654f92745f16b5" translate="yes" xml:space="preserve">
          <source>Any call to Perl's warning system (eg Carp itself) is safe. (This rule is what keeps it from reporting the error at the point where you call &lt;code&gt;carp&lt;/code&gt; or &lt;code&gt;croak&lt;/code&gt; .)</source>
          <target state="translated">Perl의 경고 시스템 (예 : 잉어 자체)에 대한 전화는 안전합니다. (이 규칙은 &lt;code&gt;carp&lt;/code&gt; 또는 &lt;code&gt;croak&lt;/code&gt; 이라고하는 지점에서 오류를보고하지 못하게합니다 .)</target>
        </trans-unit>
        <trans-unit id="3b252f8b26d454c8056df1a78fc7a97e6d22f01f" translate="yes" xml:space="preserve">
          <source>Any call to Perl's warning system (eg Carp itself) is safe. (This rule is what keeps it from reporting the error at the point where you call &lt;code&gt;carp&lt;/code&gt; or &lt;code&gt;croak&lt;/code&gt;.)</source>
          <target state="translated">Perl의 경고 시스템 (예 : Carp 자체)에 대한 모든 호출은 안전합니다. (이 규칙은 &lt;code&gt;carp&lt;/code&gt; 또는 &lt;code&gt;croak&lt;/code&gt; 이라고 부르는 지점에서 오류를보고하지 못하도록합니다 .)</target>
        </trans-unit>
        <trans-unit id="6be54b4dca13888b86e758e818195dea970243c9" translate="yes" xml:space="preserve">
          <source>Any character not matched by &lt;code&gt;\d&lt;/code&gt; is matched by &lt;code&gt;\D&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;\d&lt;/code&gt; 와 일치하지 않는 문자 는 &lt;code&gt;\D&lt;/code&gt; 와 일치합니다 .</target>
        </trans-unit>
        <trans-unit id="a92f497a3debf42be69af7cf310d253bf9089f09" translate="yes" xml:space="preserve">
          <source>Any character not matched by &lt;code&gt;\d&lt;/code&gt; is matched by &lt;code&gt;\D&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;\d&lt;/code&gt; 와 일치하지 않는 모든 문자 는 &lt;code&gt;\D&lt;/code&gt; 와 일치합니다 .</target>
        </trans-unit>
        <trans-unit id="072286fccc69e711078f97acb3c710b733c38c10" translate="yes" xml:space="preserve">
          <source>Any character not matched by &lt;code&gt;\s&lt;/code&gt; is matched by &lt;code&gt;\S&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;\s&lt;/code&gt; 와 일치하지 않는 문자 는 &lt;code&gt;\S&lt;/code&gt; 와 일치합니다 .</target>
        </trans-unit>
        <trans-unit id="6f9b47e6ac747d8625677192454745261e50c9f3" translate="yes" xml:space="preserve">
          <source>Any character not matched by &lt;code&gt;\s&lt;/code&gt; is matched by &lt;code&gt;\S&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;\s&lt;/code&gt; 와 일치하지 않는 모든 문자 는 &lt;code&gt;\S&lt;/code&gt; 와 일치합니다 .</target>
        </trans-unit>
        <trans-unit id="edd14be74c570e6d8f1d353ef998bd9cdb853857" translate="yes" xml:space="preserve">
          <source>Any character not matched by &lt;code&gt;\w&lt;/code&gt; is matched by &lt;code&gt;\W&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;\w&lt;/code&gt; 와 일치하지 않는 문자 는 &lt;code&gt;\W&lt;/code&gt; 와 일치합니다 .</target>
        </trans-unit>
        <trans-unit id="ca92dc8b5b50382eccc8de66976a91add27a47ad" translate="yes" xml:space="preserve">
          <source>Any character not matched by &lt;code&gt;\w&lt;/code&gt; is matched by &lt;code&gt;\W&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;\w&lt;/code&gt; 와 일치하지 않는 모든 문자 는 &lt;code&gt;\W&lt;/code&gt; 와 일치합니다 .</target>
        </trans-unit>
        <trans-unit id="e45bb18b3ba9ff92c60226f6eef9c2b785d393ac" translate="yes" xml:space="preserve">
          <source>Any character not part of the 65-character base64 subset is silently ignored. Characters occurring after a '=' padding character are never decoded.</source>
          <target state="translated">65 자 base64 부분 집합에 속하지 않는 문자는 자동으로 무시됩니다. '='패딩 문자 다음에 발생하는 문자는 절대 디코딩되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="fdc4fb7a943f332e78ce7564ebae9fbe7a142c7e" translate="yes" xml:space="preserve">
          <source>Any character that is</source>
          <target state="translated">모든 문자</target>
        </trans-unit>
        <trans-unit id="d1ae992eb64cfaf05e3391f63560921ed6515ef6" translate="yes" xml:space="preserve">
          <source>Any character with the General Category of Combining Mark (&lt;code&gt;\p{GC=M}&lt;/code&gt; ), which may be spacing or nonspacing. Some are even invisible. A sequence of combining characters following a grapheme base character together make up a single user-visible character called a &lt;b&gt;grapheme&lt;/b&gt;. Most but not all diacritics are combining characters, and vice versa.</source>
          <target state="translated">간격이 있거나 공백이 아닐 수 있는 일반 범주의 결합 표시 ( &lt;code&gt;\p{GC=M}&lt;/code&gt; )가있는 문자. 일부는 보이지 않습니다. 그래 핀의 기본 문자 다음과 같은 결합 문자의 순서는 함께라는 단일 사용자가 볼 수있는 문자를 구성하는 &lt;b&gt;그래 핀을&lt;/b&gt; . 모든 분음 부호는 아니지만 대부분 문자를 결합하고 있으며 그 반대도 마찬가지입니다.</target>
        </trans-unit>
        <trans-unit id="f7f37ee9ffee4805d8681593ea741f6cb413f361" translate="yes" xml:space="preserve">
          <source>Any character with the General Category of Combining Mark (&lt;code&gt;\p{GC=M}&lt;/code&gt;), which may be spacing or nonspacing. Some are even invisible. A sequence of combining characters following a grapheme base character together make up a single user-visible character called a &lt;b&gt;grapheme&lt;/b&gt;. Most but not all diacritics are combining characters, and vice versa.</source>
          <target state="translated">일반 범주 조합 표시 ( &lt;code&gt;\p{GC=M}&lt;/code&gt; )가있는 모든 문자는 공백이거나 공백이 아닐 수 있습니다. 일부는 보이지 않습니다. 문자 소 기본 문자 다음에 오는 문자를 결합하는 시퀀스는 문자 소라고하는 사용자가 볼 수있는 단일 &lt;b&gt;문자를 구성&lt;/b&gt; 합니다. 모든 분음 부호는 아니지만 대부분의 분음 부호는 문자를 결합하며 그 반대의 경우도 마찬가지입니다.</target>
        </trans-unit>
        <trans-unit id="f47500f097947cd7ef6b655a33fe0adeaed93c8c" translate="yes" xml:space="preserve">
          <source>Any class derived from an overloaded class is also overloaded and inherits its operator implementations. If the same operator is overloaded in more than one ancestor then the implementation is determined by the usual inheritance rules.</source>
          <target state="translated">오버로드 된 클래스에서 파생 된 모든 클래스도 오버로드되어 해당 연산자 구현을 상속합니다. 동일한 연산자가 둘 이상의 조상에 오버로드되면 구현은 일반적인 상속 규칙에 따라 결정됩니다.</target>
        </trans-unit>
        <trans-unit id="82762c13b8c241690349f9ba71914d3aafcada68" translate="yes" xml:space="preserve">
          <source>Any class for which this function returns true is &quot;universal&quot; in the sense that all classes potentially inherit methods from it.</source>
          <target state="translated">이 함수가 true를 리턴하는 클래스는 모든 클래스가 잠재적으로 메소드를 상속한다는 의미에서 &quot;유니버설&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="4c366c83fbe5661336d1ed5dad628d12372f6675" translate="yes" xml:space="preserve">
          <source>Any class may define hooks that will be called during the serialization and deserialization process on objects that are instances of that class. Those hooks can redefine the way serialization is performed (and therefore, how the symmetrical deserialization should be conducted).</source>
          <target state="translated">모든 클래스는 직렬화 및 역 직렬화 프로세스 중에 해당 클래스의 인스턴스 인 객체에 대해 호출 될 후크를 정의 할 수 있습니다. 이러한 후크는 직렬화가 수행되는 방식을 다시 정의 할 수 있습니다 (따라서 대칭 역 직렬화가 수행되는 방법).</target>
        </trans-unit>
        <trans-unit id="6e6281f412687ca7280049212c9dd37d5f605837" translate="yes" xml:space="preserve">
          <source>Any command not recognized by the debugger is directly executed (&lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;'d) as Perl code in the current package. (The debugger uses the DB package for keeping its own state information.)</source>
          <target state="translated">디버거가 인식하지 못하는 모든 명령 은 현재 패키지에서 Perl 코드로 직접 실행됩니다 ( &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 'd). 디버거는 자체 ​​상태 정보를 유지하기 위해 DB 패키지를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="78f7d4f4e5eb056442905f4be332daa2d7078212" translate="yes" xml:space="preserve">
          <source>Any command not recognized by the debugger is directly executed (&lt;code&gt;eval&lt;/code&gt;'d) as Perl code in the current package. (The debugger uses the DB package for keeping its own state information.)</source>
          <target state="translated">디버거에서 인식하지 못하는 명령 은 현재 패키지에서 Perl 코드로 직접 실행됩니다 ( &lt;code&gt;eval&lt;/code&gt; 'd). (디버거는 자체 ​​상태 정보를 유지하기 위해 DB 패키지를 사용합니다.)</target>
        </trans-unit>
        <trans-unit id="e1fcc44228bcb7043c7f8789e115cc416dabfd31" translate="yes" xml:space="preserve">
          <source>Any committer may cherry-pick any commit from blead to a maint branch by first adding an entry to the relevant voting file in the maint-votes branch announcing the commit as a candidate for back-porting, and then waiting for at least two other committers to add their votes in support of this (i.e. a total of at least three votes is required before a commit may be back-ported).</source>
          <target state="translated">모든 커미터는 먼저 maint-votes 브랜치의 관련 투표 파일에 항목을 추가하여 blead에서 maint 브랜치로 커밋을 체리 선택할 수 있습니다. 이를 지원하기 위해 투표를 추가합니다 (즉, 커밋이 백 포트되기 전에 총 3 개 이상의 투표가 필요합니다).</target>
        </trans-unit>
        <trans-unit id="a8dc7e3add242376e935c5e7dec68c1bf0f28dae" translate="yes" xml:space="preserve">
          <source>Any committer may cherry-pick any commit from blead to a maint branch if they send mail to perl5-porters announcing their intent to cherry-pick a specific commit along with a rationale for doing so and at least two other committers respond to the list giving their assent. (This policy applies to current and former pumpkings, as well as other committers.)</source>
          <target state="translated">커미터는 perl5 포터에게 메일을 보내면 커밋에 대한 근거와 함께 특정 커밋을 선택하고 적어도 두 명의 다른 커미터가 목록 제공에 응답하면 블리드에서 메인 지점으로 커밋을 선택할 수 있습니다. 그들의 동의. (이 정책은 현재 및 이전 호박과 다른 커미터에 적용됩니다.)</target>
        </trans-unit>
        <trans-unit id="b95f0a7c9cbc43fb72281273ec465950ff501fea" translate="yes" xml:space="preserve">
          <source>Any contained POSIX character classes, including things like &lt;code&gt;\w&lt;/code&gt; and &lt;code&gt;\D&lt;/code&gt; respect the &lt;code&gt;/a&lt;/code&gt; (and &lt;code&gt;/aa&lt;/code&gt; ) modifiers.</source>
          <target state="translated">&lt;code&gt;\w&lt;/code&gt; 및 &lt;code&gt;\D&lt;/code&gt; 와 같은 것을 포함하여 포함 된 POSIX 문자 클래스 는 &lt;code&gt;/a&lt;/code&gt; (및 &lt;code&gt;/aa&lt;/code&gt; ) 수정자를 존중합니다 .</target>
        </trans-unit>
        <trans-unit id="ed912b6d995f34c695ed9e38e5b4d742feccc889" translate="yes" xml:space="preserve">
          <source>Any contained POSIX character classes, including things like &lt;code&gt;\w&lt;/code&gt; and &lt;code&gt;\D&lt;/code&gt; respect the &lt;code&gt;/a&lt;/code&gt; (and &lt;code&gt;/aa&lt;/code&gt;) modifiers.</source>
          <target state="translated">&lt;code&gt;\w&lt;/code&gt; 및 &lt;code&gt;\D&lt;/code&gt; 와 같은 것을 포함하여 포함 된 모든 POSIX 문자 클래스 는 &lt;code&gt;/a&lt;/code&gt; (및 &lt;code&gt;/aa&lt;/code&gt; ) 수정자를 존중합니다 .</target>
        </trans-unit>
        <trans-unit id="5db2df3ee56bd2a814ccc5209f324c5b3591842c" translate="yes" xml:space="preserve">
          <source>Any data types supported by &lt;a href=&quot;../threads/shared&quot;&gt;threads::shared&lt;/a&gt; can be passed via queues:</source>
          <target state="translated">&lt;a href=&quot;../threads/shared&quot;&gt;threads :: shared에서&lt;/a&gt; 지원하는 모든 데이터 유형 은 큐를 통해 전달 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4e0656683c3bae7fc0640dbcbac9a2b39fa2d301" translate="yes" xml:space="preserve">
          <source>Any data types supported by &lt;a href=&quot;threads::shared&quot;&gt;threads::shared&lt;/a&gt; can be passed via queues:</source>
          <target state="translated">&lt;a href=&quot;threads::shared&quot;&gt;threads :: shared에서&lt;/a&gt; 지원하는 모든 데이터 유형 은 큐를 통해 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e796dc658263f7829a0c740b0d175dbd881579ef" translate="yes" xml:space="preserve">
          <source>Any diagnostics that were output for the test. This only includes diagnostics output &lt;b&gt;after&lt;/b&gt; the test result is declared.</source>
          <target state="translated">테스트를 위해 출력 된 모든 진단. 여기에는 테스트 결과가 선언 된 &lt;b&gt;후&lt;/b&gt; 진단 출력 만 포함됩니다 .</target>
        </trans-unit>
        <trans-unit id="500c84c6a69d3cbc0070a804d35fd877c67e676d" translate="yes" xml:space="preserve">
          <source>Any directory to prefix to the extraction path, if any</source>
          <target state="translated">추출 경로 접두어가있는 디렉토리 (있는 경우)</target>
        </trans-unit>
        <trans-unit id="fe63280e6a478a3a4b2a298d74baf468659f885a" translate="yes" xml:space="preserve">
          <source>Any existing</source>
          <target state="translated">기존의 모든</target>
        </trans-unit>
        <trans-unit id="910f15fcdac4d39c624eb5925c6aedfca05cbd8f" translate="yes" xml:space="preserve">
          <source>Any extension to Perl, including those containing XSUBs, should have a Perl module to serve as the bootstrap which pulls the extension into Perl. This module will export the extension's functions and variables to the Perl program and will cause the extension's XSUBs to be linked into Perl. The following module will be used for most of the examples in this document and should be used from Perl with the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; command as shown earlier. Perl modules are explained in more detail later in this document.</source>
          <target state="translated">XSUB를 포함하는 확장을 포함하여 Perl에 대한 확장에는 확장을 Perl로 가져 오는 부트 스트랩 역할을하는 Perl 모듈이 있어야합니다. 이 모듈은 확장 기능과 변수를 Perl 프로그램으로 내보내고 확장 XSUB가 Perl에 링크되게합니다. 다음 모듈은이 문서에서 대부분의 예제에 사용되며 앞에서 표시된 것처럼 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 명령과 함께 Perl에서 사용해야 합니다. Perl 모듈에 대해서는이 문서의 뒷부분에서 자세히 설명합니다.</target>
        </trans-unit>
        <trans-unit id="4138f336ca25f7058dac8592c9829407df50fe3e" translate="yes" xml:space="preserve">
          <source>Any extension to Perl, including those containing XSUBs, should have a Perl module to serve as the bootstrap which pulls the extension into Perl. This module will export the extension's functions and variables to the Perl program and will cause the extension's XSUBs to be linked into Perl. The following module will be used for most of the examples in this document and should be used from Perl with the &lt;code&gt;use&lt;/code&gt; command as shown earlier. Perl modules are explained in more detail later in this document.</source>
          <target state="translated">XSUB를 포함하는 것을 포함하여 Perl에 대한 모든 확장에는 확장을 Perl로 가져 오는 부트 스트랩 역할을하는 Perl 모듈이 있어야합니다. 이 모듈은 확장의 기능과 변수를 Perl 프로그램으로 내보내고 확장의 XSUB가 Perl에 링크되도록합니다. 다음 모듈은이 문서에있는 대부분의 예제에 사용되며 이전에 표시된대로 &lt;code&gt;use&lt;/code&gt; 명령과 함께 Perl에서 사용해야 합니다. Perl 모듈은이 문서의 뒷부분에서 자세히 설명합니다.</target>
        </trans-unit>
        <trans-unit id="25a23450424903dcd5fa1cc3d1a014ad157de4c5" translate="yes" xml:space="preserve">
          <source>Any extra arguments which shouldn't be passed on to &lt;code&gt;plan()&lt;/code&gt; should be stripped off by this method.</source>
          <target state="translated">&lt;code&gt;plan()&lt;/code&gt; 으로 전달해서는 안되는 추가 인수는 이 메소드로 제거해야합니다.</target>
        </trans-unit>
        <trans-unit id="479572afcef4faf54a80923b02d6ecab023cba50" translate="yes" xml:space="preserve">
          <source>Any extra arguments you want passed into the subtest code.</source>
          <target state="translated">하위 테스트 코드에 전달하려는 추가 인수입니다.</target>
        </trans-unit>
        <trans-unit id="e812c3c14740bd790df37fd5ab976ff0e033c047" translate="yes" xml:space="preserve">
          <source>Any filehandles open at the time of the fork() will be dup()-ed. Thus, the files can be closed independently in the parent and child, but beware that the dup()-ed handles will still share the same seek pointer. Changing the seek position in the parent will change it in the child and vice-versa. One can avoid this by opening files that need distinct seek pointers separately in the child.</source>
          <target state="translated">fork () 시점에 열린 모든 파일 핸들은 dup ()-ed입니다. 따라서 파일은 부모와 자식에서 독립적으로 닫힐 수 있지만 dup () 핸들이 여전히 동일한 탐색 포인터를 공유한다는 점에주의하십시오. 부모의 탐색 위치를 변경하면 자식의 탐색 위치가 변경되고 그 반대도 마찬가지입니다. 자식에서 별도의 탐색 포인터가 필요한 파일을 열어서 이것을 피할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="187558535ccb5da9eca3826ba8e4d8b30ca76bc1" translate="yes" xml:space="preserve">
          <source>Any function in the list below may be used either with or without parentheses around its arguments. (The syntax descriptions omit the parentheses.) If you use parentheses, the simple but occasionally surprising rule is this: It</source>
          <target state="translated">아래 목록의 모든 함수는 인수 주위에 괄호를 사용하거나 사용하지 않고 사용할 수 있습니다. (구문 설명은 괄호를 생략합니다.) 괄호를 사용하는 경우 단순하지만 때로는 놀라운 규칙은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9f6c837fd47f5e061c1ecbb824c94df3994dcde5" translate="yes" xml:space="preserve">
          <source>Any good book on software engineering</source>
          <target state="translated">소프트웨어 엔지니어링에 대한 좋은 책</target>
        </trans-unit>
        <trans-unit id="24c8f5e2946c066d9a62168dcf66b92198c6784a" translate="yes" xml:space="preserve">
          <source>Any keys for which the value is &lt;code&gt;&lt;a href=&quot;../../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; will be ignored.</source>
          <target state="translated">값이있는 모든 키 &lt;code&gt;&lt;a href=&quot;../../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="0c7f27e33616c341daf05c0b6c508f0fa8fdbd74" translate="yes" xml:space="preserve">
          <source>Any keys for which the value is &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; will be ignored.</source>
          <target state="translated">값이있는 모든 키 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="b98397e3061065c914af3247fdcc89fdfd6a02c2" translate="yes" xml:space="preserve">
          <source>Any keys for which the value is &lt;code&gt;undef&lt;/code&gt; will be ignored.</source>
          <target state="translated">값이 &lt;code&gt;undef&lt;/code&gt; 인 모든 키는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="568e69d3500c9fb9cde3152f15ae5ed8fcf84af4" translate="yes" xml:space="preserve">
          <source>Any keys not described in this specification document (whether top-level or within compound data structures described herein) are considered</source>
          <target state="translated">이 사양 문서에 설명되지 않은 모든 키 (최상위 수준 또는 여기에 설명 된 복합 데이터 구조 내)는 고려됩니다.</target>
        </trans-unit>
        <trans-unit id="204edb5197689fcdc449ffc64469cd176c221d73" translate="yes" xml:space="preserve">
          <source>Any large IRC network (Dalnet, EFnet) is also likely to have a #perl channel, with varying activity levels.</source>
          <target state="translated">모든 대형 IRC 네트워크 (Dalnet, EFnet)는 다양한 활동 수준의 #perl 채널을 가질 가능성이 높습니다.</target>
        </trans-unit>
        <trans-unit id="9ec17e0cbd0b3e2eebd6b6cf6a596cebb4cfc33d" translate="yes" xml:space="preserve">
          <source>Any letters between &lt;code&gt;&quot;?&quot;&lt;/code&gt; and &lt;code&gt;&quot;:&quot;&lt;/code&gt; act as flags modifiers as with &lt;code&gt;(?adluimnsx-imnsx)&lt;/code&gt;. For example,</source>
          <target state="translated">&lt;code&gt;&quot;?&quot;&lt;/code&gt; 사이의 문자 및 &lt;code&gt;&quot;:&quot;&lt;/code&gt; 는 &lt;code&gt;(?adluimnsx-imnsx)&lt;/code&gt; 와 마찬가지로 플래그 수정 자 역할을합니다 . 예를 들면</target>
        </trans-unit>
        <trans-unit id="44271c2c405bf35e52ab0041e6847e60ca1ca0c2" translate="yes" xml:space="preserve">
          <source>Any letters between &lt;code&gt;?&lt;/code&gt; and &lt;code&gt;:&lt;/code&gt; act as flags modifiers as with &lt;code&gt;(?adluimsx-imsx)&lt;/code&gt; . For example,</source>
          <target state="translated">사이에 어떤 문자가 &lt;code&gt;?&lt;/code&gt; 및 &lt;code&gt;:&lt;/code&gt; &lt;code&gt;(?adluimsx-imsx)&lt;/code&gt; 와 같이 플래그 수정 자 역할을합니다 . 예를 들어</target>
        </trans-unit>
        <trans-unit id="5618684dee489724ebf8f57ba00718b3f30e3494" translate="yes" xml:space="preserve">
          <source>Any method calls on an object created with &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt; will be dispatched to the package as a normal object.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt; 작성된 객체에 대한 모든 메소드 호출 은 일반 객체로 패키지에 발송됩니다.</target>
        </trans-unit>
        <trans-unit id="26b68c72e2b484267b2f658de2349d6444e86420" translate="yes" xml:space="preserve">
          <source>Any method calls on an object created with &lt;code&gt;qr//&lt;/code&gt; will be dispatched to the package as a normal object.</source>
          <target state="translated">&lt;code&gt;qr//&lt;/code&gt; 생성 된 객체에 대한 모든 메서드 호출 은 일반 객체로 패키지에 발송됩니다.</target>
        </trans-unit>
        <trans-unit id="125ade77b67e2c4cd7a637af74e96e943bde8b70" translate="yes" xml:space="preserve">
          <source>Any methods marked</source>
          <target state="translated">표시된 모든 방법</target>
        </trans-unit>
        <trans-unit id="c1aa612608eba8166ce338b4b530d56d4e20399c" translate="yes" xml:space="preserve">
          <source>Any methods not listed here are derived from Math::BigFloat (or Math::BigInt), so make sure you check these two modules for further information.</source>
          <target state="translated">여기에 나열되지 않은 방법은 Math :: BigFloat (또는 Math :: BigInt)에서 파생 된 것이므로 자세한 내용은이 두 모듈을 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="9782a834fd90fe5d5545a24d61a39706e25bf926" translate="yes" xml:space="preserve">
          <source>Any mixture is possible. For example, the most frequently used options could be stored in variables while all other options get stored in the hash:</source>
          <target state="translated">임의의 혼합물이 가능하다. 예를 들어 가장 자주 사용되는 옵션은 변수에 저장하고 다른 모든 옵션은 해시에 저장합니다.</target>
        </trans-unit>
        <trans-unit id="d9afc9d2e9f12a7ae747d6b9bda2062ad21b9fd2" translate="yes" xml:space="preserve">
          <source>Any names which are not tags are added to &lt;code&gt;@EXPORT&lt;/code&gt; or &lt;code&gt;@EXPORT_OK&lt;/code&gt; unchanged but will trigger a warning (with &lt;code&gt;-w&lt;/code&gt; ) to avoid misspelt tags names being silently added to &lt;code&gt;@EXPORT&lt;/code&gt; or &lt;code&gt;@EXPORT_OK&lt;/code&gt; . Future versions may make this a fatal error.</source>
          <target state="translated">태그에 추가되지 않은 이름 &lt;code&gt;@EXPORT&lt;/code&gt; 또는 &lt;code&gt;@EXPORT_OK&lt;/code&gt; 변화하지만, (와 경고를 트리거 &lt;code&gt;-w&lt;/code&gt; 잘못 철자 태그 이름을 피하기 위해)를 자동으로 추가되는 &lt;code&gt;@EXPORT&lt;/code&gt; 또는 &lt;code&gt;@EXPORT_OK&lt;/code&gt; . 이후 버전에서는이 오류가 치명적일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f1edfb250e37d4b9a7863e1b2498e2a280885f23" translate="yes" xml:space="preserve">
          <source>Any names which are not tags are added to &lt;code&gt;@EXPORT&lt;/code&gt; or &lt;code&gt;@EXPORT_OK&lt;/code&gt; unchanged but will trigger a warning (with &lt;code&gt;-w&lt;/code&gt;) to avoid misspelt tags names being silently added to &lt;code&gt;@EXPORT&lt;/code&gt; or &lt;code&gt;@EXPORT_OK&lt;/code&gt;. Future versions may make this a fatal error.</source>
          <target state="translated">태그에 추가되지 않은 이름 &lt;code&gt;@EXPORT&lt;/code&gt; 또는 &lt;code&gt;@EXPORT_OK&lt;/code&gt; 변화하지만, (와 경고를 트리거 &lt;code&gt;-w&lt;/code&gt; 잘못 철자 태그 이름을 피하기 위해)를 자동으로 추가되는 &lt;code&gt;@EXPORT&lt;/code&gt; 또는 &lt;code&gt;@EXPORT_OK&lt;/code&gt; . 향후 버전에서는이 오류가 치명적인 오류가 될 수 있습니다. ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ</target>
        </trans-unit>
        <trans-unit id="485a3dceff3fe3343086f55cd7ded47422eb7429" translate="yes" xml:space="preserve">
          <source>Any newlines in $perl_code will be escaped. Leading and trailing newlines will be stripped. Makes this idiom much easier:</source>
          <target state="translated">$ perl_code의 모든 줄 바꿈은 이스케이프됩니다. 선행 및 후행 줄 바꿈이 제거됩니다. 이 관용구를 훨씬 쉽게 만듭니다.</target>
        </trans-unit>
        <trans-unit id="85505e3e03d4cfb2c5d76c353aad39b235819057" translate="yes" xml:space="preserve">
          <source>Any non-whitespace delimiter may replace the slashes. Add space after the &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; when using a character allowed in identifiers. If single quotes are used, no interpretation is done on the replacement string (the &lt;code&gt;/e&lt;/code&gt; modifier overrides this, however). Note that Perl treats backticks as normal delimiters; the replacement text is not evaluated as a command. If the</source>
          <target state="translated">공백이 아닌 분리 문자는 슬래시를 대체 할 수 있습니다. 식별자에 허용되는 문자를 사용할 때 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; 뒤에 공백을 추가하십시오 . 작은 따옴표를 사용하면 대체 문자열에 대한 해석이 수행되지 않습니다 ( 그러나 &lt;code&gt;/e&lt;/code&gt; 수정자가이를 대체합니다). Perl은 백틱을 일반 구분 기호로 취급합니다. 대체 텍스트는 명령으로 평가되지 않습니다. 만약</target>
        </trans-unit>
        <trans-unit id="48ec8f1e8af52f4ed4957bdfee1ffd49c84a8c6f" translate="yes" xml:space="preserve">
          <source>Any non-whitespace delimiter may replace the slashes. Add space after the &lt;code&gt;s&lt;/code&gt; when using a character allowed in identifiers. If single quotes are used, no interpretation is done on the replacement string (the &lt;code&gt;/e&lt;/code&gt; modifier overrides this, however). Note that Perl treats backticks as normal delimiters; the replacement text is not evaluated as a command. If the</source>
          <target state="translated">공백이 아닌 구분 기호는 슬래시를 대체 할 수 있습니다. 식별자에 허용 된 문자를 사용할 때 &lt;code&gt;s&lt;/code&gt; 뒤에 공백을 추가하십시오 . 작은 따옴표가 사용되면 대체 문자열에 대해 해석이 수행되지 않습니다 ( 그러나 &lt;code&gt;/e&lt;/code&gt; 수정자가이를 대체합니다). Perl은 백틱을 일반 구분 기호로 취급합니다. 대체 텍스트는 명령으로 평가되지 않습니다. 만약</target>
        </trans-unit>
        <trans-unit id="21321c35f59a007bf7dcddd13bebabd646dd3b58" translate="yes" xml:space="preserve">
          <source>Any number of &lt;code&gt;(*PRUNE)&lt;/code&gt; assertions may be used in a pattern.</source>
          <target state="translated">임의의 수의 &lt;code&gt;(*PRUNE)&lt;/code&gt; 어설 션이 패턴에 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8bc2478d6a5974c2f338a393e6f6ea8ec88b251c" translate="yes" xml:space="preserve">
          <source>Any number of arguments can occur in the list before the array but the input and output arrays must be the last elements in the list.</source>
          <target state="translated">배열 앞의 목록에서 여러 인수가 발생할 수 있지만 입력 및 출력 배열은 목록의 마지막 요소 여야합니다.</target>
        </trans-unit>
        <trans-unit id="637eecabf535d7591a4a05a68e784539a4cbb56d" translate="yes" xml:space="preserve">
          <source>Any number of tildes and surrounding whitespace will be collapsed to a single space.</source>
          <target state="translated">여러 개의 물결표와 주변 공백이 단일 공간으로 축소됩니다.</target>
        </trans-unit>
        <trans-unit id="6743acd9891044d5d8bdbb4fb2163336b42729f9" translate="yes" xml:space="preserve">
          <source>Any numerical value returned which is less than SVt_PVAV will be a scalar of some form.</source>
          <target state="translated">SVt_PVAV보다 작은 반환 된 숫자 값은 어떤 형식의 스칼라가됩니다.</target>
        </trans-unit>
        <trans-unit id="c027e1a6e6b64e23c560209fac7288c23f0070f0" translate="yes" xml:space="preserve">
          <source>Any of the &lt;a href=&quot;IO::Socket#CONSTRUCTOR-ARGUMENTS&quot;&gt;&quot;CONSTRUCTOR ARGUMENTS&quot; in IO::Socket&lt;/a&gt; may be passed to the constructor, but if any arguments are provided, then one of them must be the &lt;a href=&quot;IO::Socket#Domain&quot;&gt;&quot;Domain&quot; in IO::Socket&lt;/a&gt; argument. The &lt;a href=&quot;IO::Socket#Domain&quot;&gt;&quot;Domain&quot; in IO::Socket&lt;/a&gt; argument can, by default, be either &lt;code&gt;AF_INET&lt;/code&gt; or &lt;code&gt;AF_UNIX&lt;/code&gt;. Other domains can be used if a proper subclass for the domain family is registered. All other arguments will be passed to the &lt;code&gt;configuration&lt;/code&gt; method of the package for that domain.</source>
          <target state="translated">&lt;a href=&quot;IO::Socket#CONSTRUCTOR-ARGUMENTS&quot;&gt;IO :: Socket&lt;/a&gt; 의 &quot;CONSTRUCTOR ARGUMENTS&quot; 중 하나가 생성자에 전달 될 수 있지만 인수가 제공되면 그 중 하나가 &lt;a href=&quot;IO::Socket#Domain&quot;&gt;IO :: Socket&lt;/a&gt; 인수 의 &quot;도메인&quot; 이어야합니다 . &lt;a href=&quot;IO::Socket#Domain&quot;&gt;IO :: Socket&lt;/a&gt; 인수 의 &quot;도메인&quot;은 기본적으로 &lt;code&gt;AF_INET&lt;/code&gt; 또는 &lt;code&gt;AF_UNIX&lt;/code&gt; 일 수 있습니다 . 도메인 패밀리에 대한 적절한 하위 클래스가 등록 된 경우 다른 도메인을 사용할 수 있습니다. 다른 모든 인수는 해당 도메인에 대한 패키지 의 &lt;code&gt;configuration&lt;/code&gt; 방법 으로 전달됩니다 .</target>
        </trans-unit>
        <trans-unit id="d9c5d3662ce5a04f9a5a84a78523f9d65e2d1542" translate="yes" xml:space="preserve">
          <source>Any of the bit masks can also be &lt;a href=&quot;#undef-EXPR&quot;&gt;&lt;code&gt;undef&lt;/code&gt;&lt;/a&gt;. The timeout, if specified, is in seconds, which may be fractional. Note: not all implementations are capable of returning the &lt;code&gt;$timeleft&lt;/code&gt;. If not, they always return &lt;code&gt;$timeleft&lt;/code&gt; equal to the supplied &lt;code&gt;$timeout&lt;/code&gt;.</source>
          <target state="translated">모든 비트 마스크는 &lt;a href=&quot;#undef-EXPR&quot;&gt; &lt;code&gt;undef&lt;/code&gt; 가&lt;/a&gt; 될 수도 있습니다 . 지정된 경우 시간 제한은 초 단위이며 분수 일 수 있습니다. 참고 : 모든 구현이 &lt;code&gt;$timeleft&lt;/code&gt; 를 반환 할 수있는 것은 아닙니다 . 그렇지 않은 경우 항상 제공된 &lt;code&gt;$timeout&lt;/code&gt; 과 동일한 &lt;code&gt;$timeleft&lt;/code&gt; 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="799d3a594ea06ab8f69431e4521092706a0ca250" translate="yes" xml:space="preserve">
          <source>Any of the bit masks can also be undef. The timeout, if specified, is in seconds, which may be fractional. Note: not all implementations are capable of returning the $timeleft. If not, they always return $timeleft equal to the supplied $timeout.</source>
          <target state="translated">비트 마스크 중 어느 것도 정의 할 수 없습니다. 지정된 경우 제한 시간은 초 단위이며 소수 일 수 있습니다. 참고 : 모든 구현이 $ timeleft를 반환 할 수있는 것은 아닙니다. 그렇지 않으면 항상 $ timeleft를 제공된 $ timeout과 동일하게 반환합니다.</target>
        </trans-unit>
        <trans-unit id="96dac77ef4a45d1d47b4f15ad920f1efda518fb4" translate="yes" xml:space="preserve">
          <source>Any of these modifiers can be set to apply globally to all regular expressions compiled within the scope of a &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re&lt;/code&gt; . See &lt;a href=&quot;re#'%2fflags'-mode&quot;&gt;'/flags' mode in re&lt;/a&gt;.</source>
          <target state="translated">이 수정의 어떤은의 범위 내에서 컴파일 된 모든 정규 표현식에 전 세계적으로 적용하도록 설정할 수 있습니다 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re&lt;/code&gt; . &lt;a href=&quot;re#'%2fflags'-mode&quot;&gt;re의 '/ flags'모드를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="511eb3ecca55bf6890b46608108a95afce5c385f" translate="yes" xml:space="preserve">
          <source>Any of these modifiers can be set to apply globally to all regular expressions compiled within the scope of a &lt;code&gt;use re&lt;/code&gt;. See &lt;a href=&quot;re#%27%2Fflags%27-mode&quot;&gt;&quot;'/flags' mode&quot; in re&lt;/a&gt;.</source>
          <target state="translated">이러한 수정자는 &lt;code&gt;use re&lt;/code&gt; 범위 내에서 컴파일 된 모든 정규식에 전역 적으로 적용되도록 설정할 수 있습니다 . &lt;a href=&quot;re#%27%2Fflags%27-mode&quot;&gt;re의 &quot; '/ flags'모드&quot;를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d72e7a2b4416a01397ed95a3d69723c275ceb3de" translate="yes" xml:space="preserve">
          <source>Any of these statements are nice replacements for &lt;code&gt;BEGIN { &lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt; Exporter; @ISA = qw(Exporter); }&lt;/code&gt; with the same compile-time effect. The basic difference is that &lt;code&gt;base&lt;/code&gt; code interacts with declared &lt;code&gt;fields&lt;/code&gt; while &lt;code&gt;parent&lt;/code&gt; is a streamlined version of the older &lt;code&gt;base&lt;/code&gt; code to just establish the IS-A relationship.</source>
          <target state="translated">이러한 내용은 &lt;code&gt;BEGIN { &lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt; Exporter; @ISA = qw(Exporter); }&lt;/code&gt; 대체하는 훌륭한 대안입니다. { require Exporter; @ISA = qw (수출 업체); } 컴파일 시간 효과가 동일합니다. 기본 차이점은 &lt;code&gt;base&lt;/code&gt; 코드가 선언 된 &lt;code&gt;fields&lt;/code&gt; 와 상호 작용하는 반면 &lt;code&gt;parent&lt;/code&gt; 는 IS-A 관계를 설정하기 위해 이전 &lt;code&gt;base&lt;/code&gt; 코드 의 간소화 된 버전입니다 .</target>
        </trans-unit>
        <trans-unit id="a58afbeb2eaab93b0832f3d91597b76dd426bf94" translate="yes" xml:space="preserve">
          <source>Any of these statements are nice replacements for &lt;code&gt;BEGIN { require Exporter; @ISA = qw(Exporter); }&lt;/code&gt; with the same compile-time effect. The basic difference is that &lt;code&gt;base&lt;/code&gt; code interacts with declared &lt;code&gt;fields&lt;/code&gt; while &lt;code&gt;parent&lt;/code&gt; is a streamlined version of the older &lt;code&gt;base&lt;/code&gt; code to just establish the IS-A relationship.</source>
          <target state="translated">이러한 문장은 &lt;code&gt;BEGIN { require Exporter; @ISA = qw(Exporter); }&lt;/code&gt; 동일한 컴파일 타임 효과를 사용합니다. 기본적인 차이점은 &lt;code&gt;base&lt;/code&gt; 코드가 선언 된 &lt;code&gt;fields&lt;/code&gt; 와 상호 작용하는 반면 &lt;code&gt;parent&lt;/code&gt; 는 IS-A 관계를 설정하기 위한 이전 &lt;code&gt;base&lt;/code&gt; 코드 의 간소화 된 버전이라는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="54d3e07363608f1d20995e0548f7b8658feed7f4" translate="yes" xml:space="preserve">
          <source>Any omitted or empty regular expressions will default to &quot;.*&quot;. Please note that each regular expression given is implicitly anchored by adding &quot;^&quot; and &quot;$&quot; to the beginning and end. Also, if a given regular expression starts with a &quot;!&quot; character, then the expression is</source>
          <target state="translated">생략되거나 비어있는 정규 표현식의 기본값은 &quot;. *&quot;입니다. 주어진 각 정규 표현식은 시작과 끝에 &quot;^&quot;와 &quot;$&quot;를 추가하여 암시 적으로 고정됩니다. 또한 주어진 정규 표현식이 &quot;!&quot;로 시작하면 문자, 표현은</target>
        </trans-unit>
        <trans-unit id="0f87f06eba2caf7b827d1f8e16065d83ac575560" translate="yes" xml:space="preserve">
          <source>Any other character it taken literally.</source>
          <target state="translated">문자 그대로 찍은 다른 문자.</target>
        </trans-unit>
        <trans-unit id="3effb550cd8c77527aa9de81743828a3b7722f93" translate="yes" xml:space="preserve">
          <source>Any other parameters specific to the method</source>
          <target state="translated">방법에 특정한 다른 매개 변수</target>
        </trans-unit>
        <trans-unit id="c9c0186423c77aa8d8e97bed87ca7acf745a240d" translate="yes" xml:space="preserve">
          <source>Any other return code means that a flush point was not found. If more data is available, &lt;code&gt;inflateSync&lt;/code&gt; can be called repeatedly with more compressed data until the flush point is found.</source>
          <target state="translated">다른 리턴 코드는 플러시 지점을 찾을 수 없음을 의미합니다. 더 많은 데이터를 사용할 수있는 경우 플러시 지점을 찾을 때까지 더 압축 된 데이터로 &lt;code&gt;inflateSync&lt;/code&gt; 를 반복적으로 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f1dc9b8d3bdcecba91d97097df903ce52027fe14" translate="yes" xml:space="preserve">
          <source>Any other string</source>
          <target state="translated">다른 문자열</target>
        </trans-unit>
        <trans-unit id="26c9cefe7b574f70d77490b40ef9d059faa47f0c" translate="yes" xml:space="preserve">
          <source>Any parameters to be pushed onto the stack should be bracketed by the &lt;code&gt;PUSHMARK&lt;/code&gt; and &lt;code&gt;PUTBACK&lt;/code&gt; macros. The purpose of these two macros, in this context, is to count the number of parameters you are pushing automatically. Then whenever Perl is creating the &lt;code&gt;@_&lt;/code&gt; array for the subroutine, it knows how big to make it.</source>
          <target state="translated">스택에 푸시되는 모든 매개 변수는 &lt;code&gt;PUSHMARK&lt;/code&gt; 및 &lt;code&gt;PUTBACK&lt;/code&gt; 매크로로 묶어야 합니다. 이 문맥에서이 두 매크로의 목적은 자동으로 푸시하는 매개 변수의 수를 계산하는 것입니다. 그런 다음 Perl이 서브 루틴에 대한 &lt;code&gt;@_&lt;/code&gt; 배열을 작성할 때마다 얼마나 큰지 알고 있습니다.</target>
        </trans-unit>
        <trans-unit id="393576095a8de6bc0086f7597df6e48f941f115a" translate="yes" xml:space="preserve">
          <source>Any pattern containing a special backtracking verb that allows an argument has the special behaviour that when executed it sets the current package's &lt;code&gt;$REGERROR&lt;/code&gt; and &lt;code&gt;$REGMARK&lt;/code&gt; variables. When doing so the following rules apply:</source>
          <target state="translated">인수를 허용하는 특수 역 &lt;code&gt;$REGERROR&lt;/code&gt; 동사를 포함하는 패턴은 실행될 때 현재 패키지의 $ REGERROR 및 &lt;code&gt;$REGMARK&lt;/code&gt; 변수를 설정하는 특수 동작을 갖습니다 . 그렇게 할 때 다음 규칙이 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="0f7c0d8ab3a57bbfaec5da2f59e5489aaf2f7ee1" translate="yes" xml:space="preserve">
          <source>Any references that are the same as one of those passed in will be named &lt;code&gt;$VAR&lt;/code&gt;</source>
          <target state="translated">전달 된 참조 중 하나와 동일한 참조는 이름이 &lt;code&gt;$VAR&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d0947cd6471d04a9e9e7aba2d6ed254ce36b6a65" translate="yes" xml:space="preserve">
          <source>Any regular expression special characters in &lt;code&gt;$regex&lt;/code&gt; are still special, and the pattern still has to be valid or Perl will complain. For instance, in this pattern there is an unpaired parenthesis.</source>
          <target state="translated">&lt;code&gt;$regex&lt;/code&gt; 정규 표현식 특수 문자 는 여전히 특별하며 패턴이 여전히 유효해야합니다. 그렇지 않으면 Perl이 불평합니다. 예를 들어,이 패턴에는 짝이없는 괄호가 있습니다.</target>
        </trans-unit>
        <trans-unit id="fe7f6f318181e1a9721562694a44d98bb9f0d89c" translate="yes" xml:space="preserve">
          <source>Any scalar value that doesn&amp;rsquo;t evaluate to 0 or &lt;code&gt;&quot;&quot;&lt;/code&gt; .</source>
          <target state="translated">하지 않는 스칼라 값은 0 이상으로 평가 &lt;code&gt;&quot;&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bc814185c98806f976443ba7f707c9de190e5102" translate="yes" xml:space="preserve">
          <source>Any scalar value that doesn&amp;rsquo;t evaluate to 0 or &lt;code&gt;&quot;&quot;&lt;/code&gt;.</source>
          <target state="translated">0 또는 &lt;code&gt;&quot;&quot;&lt;/code&gt; 로 평가되지 않는 모든 스칼라 값 .</target>
        </trans-unit>
        <trans-unit id="1aef8e8c0d886239b79a86d40fbcb9638ca8176a" translate="yes" xml:space="preserve">
          <source>Any scalar variable may carry &lt;code&gt;PERL_MAGIC_collxfrm&lt;/code&gt; magic that contains the scalar data of the variable, but transformed to such a format that a normal memory comparison can be used to compare the data according to the locale settings.</source>
          <target state="translated">모든 스칼라 변수는 변수 의 스칼라 데이터를 포함하는 &lt;code&gt;PERL_MAGIC_collxfrm&lt;/code&gt; 마법을 전달할 수 있지만, 로케일 설정에 따라 데이터를 비교하는 데 일반 메모리 비교를 사용할 수있는 형식으로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="b9848f5389028c0e6f897c58baee24bbe4b4452b" translate="yes" xml:space="preserve">
          <source>Any scalar variable may carry PERL_MAGIC_collxfrm magic that contains the scalar data of the variable, but transformed to such a format that a normal memory comparison can be used to compare the data according to the locale settings.</source>
          <target state="translated">모든 스칼라 변수에는 변수의 스칼라 데이터가 포함 된 PERL_MAGIC_collxfrm 매직이 있지만 일반 메모리 비교를 사용하여 로캘 설정에 따라 데이터를 비교할 수있는 형식으로 변환되었습니다.</target>
        </trans-unit>
        <trans-unit id="38fbec488780a53c892b68c97c1898064ef5cf3c" translate="yes" xml:space="preserve">
          <source>Any simple statement may optionally be followed by a</source>
          <target state="translated">임의의 간단한 문장 뒤에 선택적으로</target>
        </trans-unit>
        <trans-unit id="6edad6532b87dcd9565ed8ca948fd8e9febfc827" translate="yes" xml:space="preserve">
          <source>Any single character in a pattern matches that same character in the target string, unless the character is a</source>
          <target state="translated">패턴의 단일 문자는 문자가 아닌 경우 대상 문자열의 동일한 문자와 일치합니다.</target>
        </trans-unit>
        <trans-unit id="d57ad08ad6b4b977666be8da12ed7e9b3597a3e6" translate="yes" xml:space="preserve">
          <source>Any single character matches itself, unless it is a</source>
          <target state="translated">모든 단일 문자는</target>
        </trans-unit>
        <trans-unit id="f581a0aac4749093894a9605cfac9a184c97919e" translate="yes" xml:space="preserve">
          <source>Any special flags that might need to be passed to ld to create a shared library suitable for dynamic loading. It is up to the makefile to use it. (See &lt;a href=&quot;../config#lddlflags&quot;&gt;lddlflags in Config&lt;/a&gt;)</source>
          <target state="translated">동적로드에 적합한 공유 라이브러리를 작성하기 위해 ld로 전달해야하는 특수 플래그. 그것을 사용하는 것은 makefile에 달려 있습니다. ( &lt;a href=&quot;../config#lddlflags&quot;&gt;구성의 lddlflags&lt;/a&gt; 참조 )</target>
        </trans-unit>
        <trans-unit id="bea6827ac537eb7924457a4cf759d617d88c98bb" translate="yes" xml:space="preserve">
          <source>Any special flags that might need to be passed to ld to create a shared library suitable for dynamic loading. It is up to the makefile to use it. (See &lt;a href=&quot;config#lddlflags&quot;&gt;&quot;lddlflags&quot; in Config&lt;/a&gt;)</source>
          <target state="translated">동적로드에 적합한 공유 라이브러리를 만들기 위해 ld에 전달해야 할 수있는 특수 플래그입니다. 그것을 사용하는 것은 makefile에 달려 있습니다. ( &lt;a href=&quot;config#lddlflags&quot;&gt;Config의 &quot;lddlflags&quot;&lt;/a&gt; 참조 )</target>
        </trans-unit>
        <trans-unit id="cae1c49f6637fcf58ae140f395f043a2e193fb5a" translate="yes" xml:space="preserve">
          <source>Any statement within the body of a loop that can make a loop prematurely stop looping or skip an &lt;b&gt;iteration&lt;/b&gt;. Generally, you shouldn&amp;rsquo;t try this on roller coasters.</source>
          <target state="translated">루프 본문 내에서 루프를 조기에 반복 중지하거나 &lt;b&gt;반복을&lt;/b&gt; 건너 뛸 수있는 명령문 . 일반적으로 롤러 코스터에서는 시도하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="a7b963c94b597f0a356b5a56744621822590c340" translate="yes" xml:space="preserve">
          <source>Any string eval which is executed by code executing in a compartment, or by code called from code executing in a compartment, will be eval'd in the namespace of the compartment. This is potentially a serious problem.</source>
          <target state="translated">구획에서 실행되는 코드 또는 구획에서 실행되는 코드에서 호출 된 코드에 의해 실행되는 모든 문자열 평가는 구획의 네임 스페이스에서 평가됩니다. 이것은 잠재적으로 심각한 문제입니다.</target>
        </trans-unit>
        <trans-unit id="8a7a9db7b2a7d9c3bc4a0371b24f090bb005ce01" translate="yes" xml:space="preserve">
          <source>Any switches in the &lt;code&gt;PERLDOC&lt;/code&gt; environment variable will be used before the command line arguments.</source>
          <target state="translated">&lt;code&gt;PERLDOC&lt;/code&gt; 환경 변수 의 모든 스위치 는 명령 행 인수 앞에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="7c3b8e236160fc72cba179bfa08e7e8fcf86e97c" translate="yes" xml:space="preserve">
          <source>Any test which does not match a rule will be run in sequence at the end of the run.</source>
          <target state="translated">규칙과 일치하지 않는 테스트는 실행이 끝날 때 순서대로 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="c697d8a2e427d5d56c9e1028dbc399fcc4b347e2" translate="yes" xml:space="preserve">
          <source>Any time after Perl starts running your main program. See also &lt;b&gt;compile phase&lt;/b&gt;. Run phase is mostly spent in &lt;b&gt;runtime&lt;/b&gt; but may also be spent in &lt;b&gt;compile time&lt;/b&gt; when &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">Perl이 메인 프로그램을 실행하기 시작한 후 언제든지 &lt;b&gt;컴파일 단계&lt;/b&gt; 도 참조하십시오 . 실행 단계는 대부분에 소요되는 &lt;b&gt;런타임&lt;/b&gt; 뿐만 아니라에서 소비 할 수있다 &lt;b&gt;컴파일 타임&lt;/b&gt; 때 &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e2c3d3bd0813c99a89a071ee04615c19b004d52d" translate="yes" xml:space="preserve">
          <source>Any time after Perl starts running your main program. See also &lt;b&gt;compile phase&lt;/b&gt;. Run phase is mostly spent in &lt;b&gt;runtime&lt;/b&gt; but may also be spent in &lt;b&gt;compile time&lt;/b&gt; when &lt;code&gt;require&lt;/code&gt;, &lt;code&gt;do&lt;/code&gt;</source>
          <target state="translated">Perl이 주 프로그램을 실행하기 시작한 후 언제든지. &lt;b&gt;컴파일 단계를&lt;/b&gt; 참조하십시오 . 실행 단계는 대부분에 소요되는 &lt;b&gt;런타임&lt;/b&gt; 뿐만 아니라에서 소비 할 수있다 &lt;b&gt;컴파일 타임&lt;/b&gt; 때 &lt;code&gt;require&lt;/code&gt; , &lt;code&gt;do&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="00807e0e44bec9e684bd05f5d6ca841ffb6f513c" translate="yes" xml:space="preserve">
          <source>Any time before Perl starts running your main program. See also &lt;b&gt;run phase&lt;/b&gt;. Compile phase is mostly spent in &lt;b&gt;compile time&lt;/b&gt;, but may also be spent in &lt;b&gt;runtime&lt;/b&gt; when &lt;code&gt;BEGIN&lt;/code&gt; blocks, &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt;&lt;/code&gt; declarations, or constant subexpressions are being evaluated. The startup and import code of any &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; declaration is also run during compile phase.</source>
          <target state="translated">Perl이 메인 프로그램을 실행하기 전에는 언제든지. &lt;b&gt;run phase&lt;/b&gt; 도 참조하십시오 . 컴파일 단계는 대부분 &lt;b&gt;컴파일 시간에&lt;/b&gt; 소비 되지만 &lt;code&gt;BEGIN&lt;/code&gt; 블록이 있거나 선언을 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 하거나 사용 &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt;&lt;/code&gt; 않거나 상수 하위 표현식을 평가할 때 &lt;b&gt;런타임에&lt;/b&gt; 사용될 수도 있습니다 . &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 선언 의 시작 및 가져 오기 코드 도 컴파일 단계에서 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="89bbb32771fb02c8c9a2b7c9c816ca4c3b49cddb" translate="yes" xml:space="preserve">
          <source>Any time before Perl starts running your main program. See also &lt;b&gt;run phase&lt;/b&gt;. Compile phase is mostly spent in &lt;b&gt;compile time&lt;/b&gt;, but may also be spent in &lt;b&gt;runtime&lt;/b&gt; when &lt;code&gt;BEGIN&lt;/code&gt; blocks, &lt;code&gt;use&lt;/code&gt; or &lt;code&gt;no&lt;/code&gt; declarations, or constant subexpressions are being evaluated. The startup and import code of any &lt;code&gt;use&lt;/code&gt; declaration is also run during compile phase.</source>
          <target state="translated">Perl이 주 프로그램을 실행하기 전에 언제든지. &lt;b&gt;실행 단계를&lt;/b&gt; 참조하십시오 . 컴파일 단계는 대부분에 소요되는 &lt;b&gt;시간을 컴파일&lt;/b&gt; 뿐만 아니라에서 소비 할 수있다 &lt;b&gt;런타임&lt;/b&gt; 때 &lt;code&gt;BEGIN&lt;/code&gt; 블록, &lt;code&gt;use&lt;/code&gt; 또는 &lt;code&gt;no&lt;/code&gt; 선언을, 또는 상수 표현식 평가되고있다. &lt;code&gt;use&lt;/code&gt; 선언 의 시작 및 가져 오기 코드 도 컴파일 단계에서 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="08963a941982a994fe2895ea2c775da89cda3e41" translate="yes" xml:space="preserve">
          <source>Any time you're doing a &quot;this equals that&quot; sort of test, use &lt;code&gt;is()&lt;/code&gt;. It even works on arrays. The test is always in scalar context, so you can test how many elements are in an array this way. [5]</source>
          <target state="translated">&quot;this equals that&quot;테스트를 수행 할 때마다 &lt;code&gt;is()&lt;/code&gt; . 배열에서도 작동합니다. 테스트는 항상 스칼라 컨텍스트에서 이루어 지므로 이러한 방식으로 배열에 몇 개의 요소가 있는지 테스트 할 수 있습니다. [5]</target>
        </trans-unit>
        <trans-unit id="aa83fb5c769020023303529abde854eefeaa0d66" translate="yes" xml:space="preserve">
          <source>Any version between 1.00 and 1.82 inclusive would be acceptable, except for 1.75.</source>
          <target state="translated">1.75를 제외하고 1.00에서 1.82 사이의 모든 버전이 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="c34097998161c40da19bcb944501b160cf796dc7" translate="yes" xml:space="preserve">
          <source>Any version from version 1.2 onward, except version 1.5, that also precedes version 2.0.</source>
          <target state="translated">버전 2.0 이전 버전을 제외하고 버전 1.2 이후의 모든 버전.</target>
        </trans-unit>
        <trans-unit id="db5515dadcc88944ac0dd16b3a430dc89d34c3d0" translate="yes" xml:space="preserve">
          <source>Any version which &quot;looks like a number&quot;, see &lt;a href=&quot;#Decimal-Versions&quot;&gt;&quot;Decimal Versions&quot;&lt;/a&gt;. This also includes versions with a single decimal point and a single embedded underscore, see &lt;a href=&quot;#Alpha-Versions&quot;&gt;&quot;Alpha Versions&quot;&lt;/a&gt;, even though these must be quoted to preserve the underscore formatting.</source>
          <target state="translated">&quot;숫자처럼 보이는 &lt;a href=&quot;#Decimal-Versions&quot;&gt;&quot;버전&lt;/a&gt; 은 &quot;10 진수 버전&quot;을 참조하십시오 . 여기에는 소수점 하나와 밑줄 하나가 포함 된 버전도 포함됩니다 . 밑줄 형식을 유지하려면 따옴표로 묶어야하지만 &lt;a href=&quot;#Alpha-Versions&quot;&gt;&quot;알파 버전&quot;을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="7bc6b65d5c451906eff3dea5dd5120214b2325bd" translate="yes" xml:space="preserve">
          <source>Any/all fields and accessors are autovivified into existence. There is no way to know what metadata may be added, so any is allowed.</source>
          <target state="translated">모든 필드와 접근자는 자동으로 존재합니다. 어떤 메타 데이터가 추가 될 수 있는지 알 수있는 방법이 없으므로 모두 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="5bea195cc0120bd58a5f6ddfad70e861a932bba8" translate="yes" xml:space="preserve">
          <source>AnyDBM_File</source>
          <target state="translated">AnyDBM_File</target>
        </trans-unit>
        <trans-unit id="abf989fc06a7a8552843b93b1474a012067198d8" translate="yes" xml:space="preserve">
          <source>AnyDBM_File - provide framework for multiple DBMs</source>
          <target state="translated">AnyDBM_File-여러 DBM을위한 프레임 워크 제공</target>
        </trans-unit>
        <trans-unit id="29c9b5ccd4a8843ac06d93de6db98a168d9747a5" translate="yes" xml:space="preserve">
          <source>Anyone interested in resurrecting this file should pull the old version from the MakeMaker CVS repository and contact makemaker@perl.org.</source>
          <target state="translated">이 파일을 부활시키려는 사람은 MakeMaker CVS 저장소에서 이전 버전을 가져와 makemaker@perl.org에 문의하십시오.</target>
        </trans-unit>
        <trans-unit id="f1313a33b13e0ad302add61f009e5344735237ef" translate="yes" xml:space="preserve">
          <source>Anything after this line is the description of XSUB functions. These descriptions are translated by &lt;b&gt;xsubpp&lt;/b&gt; into C code which implements these functions using Perl calling conventions, and which makes these functions visible from Perl interpreter.</source>
          <target state="translated">이 줄 다음에 나오는 것은 XSUB 함수에 대한 설명입니다. 이 설명은 &lt;b&gt;xsubpp&lt;/b&gt; 에 의해 Perl 호출 규칙을 사용하여 이러한 함수를 구현하고 이러한 함수를 Perl 인터프리터에서 볼 수있게하는 C 코드로 변환됩니다 .</target>
        </trans-unit>
        <trans-unit id="7767ddde79c4e54f955f8a8770af897489800878" translate="yes" xml:space="preserve">
          <source>Anything before this line is plain C code which describes which headers to include, and defines some convenience functions. No translations are performed on this part, apart from having embedded POD documentation skipped over (see &lt;a href=&quot;perlpod&quot;&gt;perlpod&lt;/a&gt;) it goes into the generated output C file as is.</source>
          <target state="translated">이 줄 앞의 것은 포함 할 헤더를 설명하고 편리한 기능을 정의하는 일반 C 코드입니다. 임베드 된 POD 문서를 건너 뛰고 ( &lt;a href=&quot;perlpod&quot;&gt;perlpod&lt;/a&gt; 참조 ) 생성 된 출력 C 파일로 그대로 들어가는 것 외에는이 부분에 대한 변환이 수행되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="9e010e0ae6e0590e5e1834d00dd2ae5e4328a555" translate="yes" xml:space="preserve">
          <source>Anything between white space and an end of line within a &lt;code&gt;MANIFEST&lt;/code&gt; file is considered to be a comment. Any line beginning with # is also a comment. Beginning with ExtUtils::Manifest 1.52, a filename may contain whitespace characters if it is enclosed in single quotes; single quotes or backslashes in that filename must be backslash-escaped.</source>
          <target state="translated">&lt;code&gt;MANIFEST&lt;/code&gt; 파일 내 공백과 줄 끝 사이의 모든 것은 주석으로 간주됩니다. #으로 시작하는 줄도 주석입니다. ExtUtils :: Manifest 1.52부터는 작은 따옴표로 묶인 파일 이름에 공백 문자가 포함될 수 있습니다. 해당 파일 이름의 작은 따옴표 나 백 슬래시는 백 슬래시 이스케이프되어야합니다.</target>
        </trans-unit>
        <trans-unit id="d23663e502213da0e6ba19093e62429d22e02845" translate="yes" xml:space="preserve">
          <source>Anything else is a Perl-specific convenience abbreviation. Specify one or more scripts by names if you want short names that are script-specific.</source>
          <target state="translated">다른 것은 Perl 특정 편의 약어입니다. 스크립트 별 짧은 이름을 원하면 이름으로 하나 이상의 스크립트를 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="7d749de0de5c93aeb0a7eeebe5226cb0dd35304d" translate="yes" xml:space="preserve">
          <source>Anything in EXPR that matches PATTERN is taken to be a separator that separates the EXPR into substrings (called &quot;</source>
          <target state="translated">PATTERN과 일치하는 EXPR의 모든 항목은 EXPR을 하위 문자열 ( &quot;</target>
        </trans-unit>
        <trans-unit id="beac50162375e06d01167c42cce2dc5426c4e092" translate="yes" xml:space="preserve">
          <source>Anything marked as BE is Big Endian (or network byte order) and LE is Little Endian (aka VAX byte order). For anything not marked either BE or LE, a character called Byte Order Mark (BOM) indicating the endianness is prepended to the string.</source>
          <target state="translated">BE로 표시된 것은 Big Endian (또는 네트워크 바이트 순서)이고 LE는 Little Endian (일명 VAX 바이트 순서)입니다. BE 또는 LE로 표시되지 않은 항목의 경우 엔디안을 나타내는 BOM (Byte Order Mark)이라는 문자가 문자열 앞에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="09e186b65803161a334d1142c77aae1e01d4460e" translate="yes" xml:space="preserve">
          <source>Anything not listed here is not part of the public API, and should not be used by extension writers at all. For these reasons, blindly using functions listed in proto.h is to be avoided when writing extensions.</source>
          <target state="translated">여기에 나열되지 않은 것은 공용 API의 일부가 아니므로 확장 작성자가 사용해서는 안됩니다. 이러한 이유로 proto.h에 나열된 함수를 맹목적으로 사용하는 것은 확장 기능을 작성할 때 피해야합니다.</target>
        </trans-unit>
        <trans-unit id="43c6485292ca5760fa287d9f9ae8c3f36373f766" translate="yes" xml:space="preserve">
          <source>Anything put here will be passed to &lt;a href=&quot;ExtUtils::MM_Any#postamble-%28o%29&quot;&gt;MY::postamble()&lt;/a&gt; if you have one.</source>
          <target state="translated">여기에 넣은 모든 것은 &lt;a href=&quot;ExtUtils::MM_Any#postamble-%28o%29&quot;&gt;MY :: postamble ()&lt;/a&gt; 로 전달됩니다 .</target>
        </trans-unit>
        <trans-unit id="595fc50992e17250599953061722960b35607014" translate="yes" xml:space="preserve">
          <source>Anything put here will be passed to MY::postamble() if you have one.</source>
          <target state="translated">여기에있는 것은 MY :: postamble ()이 있으면 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="eb489bfffc02c3f32a21cb7909eae48c47e3d9b4" translate="yes" xml:space="preserve">
          <source>Anything that follows &lt;code&gt;#&lt;/code&gt; is treated as a comment.</source>
          <target state="translated">&lt;code&gt;#&lt;/code&gt; 다음에 나오는 것은 주석으로 취급됩니다.</target>
        </trans-unit>
        <trans-unit id="aaea73d52ae0a47a220342d260ea4c54a027d322" translate="yes" xml:space="preserve">
          <source>Anything you can legally say in a spot where a &lt;b&gt;value&lt;/b&gt; is required. Typically composed of &lt;b&gt;literals&lt;/b&gt;, &lt;b&gt;variables&lt;/b&gt;, &lt;b&gt;operators&lt;/b&gt;, &lt;b&gt;functions&lt;/b&gt;, and &lt;b&gt;subroutine&lt;/b&gt; calls, not necessarily in that order.</source>
          <target state="translated">&lt;b&gt;가치&lt;/b&gt; 가 필요한 장소에서 합법적으로 말할 수있는 모든 것 . 일반적으로 &lt;b&gt;리터럴&lt;/b&gt; , &lt;b&gt;변수&lt;/b&gt; , &lt;b&gt;연산자&lt;/b&gt; , &lt;b&gt;함수&lt;/b&gt; 및 &lt;b&gt;서브 루틴&lt;/b&gt; 호출 로 구성되며 반드시 순서대로는 아닙니다.</target>
        </trans-unit>
        <trans-unit id="90ac4d3777dbcf43ec0f981e70e6cb4230e6e6f9" translate="yes" xml:space="preserve">
          <source>Anyway, here it is. Should run on perl v4 or greater. Maybe less.</source>
          <target state="translated">어쨌든 여기 있습니다. perl v4 이상에서 실행해야합니다. 아마 적을 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="2e755b3358691db1161de932e3c7e74daf5374dd" translate="yes" xml:space="preserve">
          <source>Anyway, this is what you can do if you can't help yourself.</source>
          <target state="translated">어쨌든, 이것은 당신이 스스로 도울 수 없다면 할 수있는 일입니다.</target>
        </trans-unit>
        <trans-unit id="61fbeb450419f819d1d3fb527e61bbd77f1f245b" translate="yes" xml:space="preserve">
          <source>Anywhere you'd put an identifier (or chain of identifiers) as part of a variable or subroutine name, you can replace the identifier with a BLOCK returning a reference of the correct type. In other words, the previous examples could be written like this:</source>
          <target state="translated">변수 또는 서브 루틴 이름의 일부로 식별자 (또는 식별자 체인)를 배치 할 때마다 올바른 유형의 참조를 반환하는 BLOCK으로 식별자를 바꿀 수 있습니다. 즉, 이전 예제는 다음과 같이 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c4897c70becad60eb583b067e9239c22c138553c" translate="yes" xml:space="preserve">
          <source>Anywhere you'd put an identifier (or chain of identifiers) as part of a variable or subroutine name, you can replace the identifier with a simple scalar variable containing a reference of the correct type:</source>
          <target state="translated">변수 또는 서브 루틴 이름의 일부로 식별자 (또는 식별자 체인)를 배치 할 때마다 올바른 유형의 참조를 포함하는 간단한 스칼라 변수로 식별자를 대체 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1152548ba48e279bc989a0c42814e21456001922" translate="yes" xml:space="preserve">
          <source>Apache::GZip Revisited</source>
          <target state="translated">Apache :: GZip 재 방문</target>
        </trans-unit>
        <trans-unit id="eef8ccdc1b5028a7590e9e7eb6807d9775169439" translate="yes" xml:space="preserve">
          <source>Apart from being non-portable to some operating systems, this made it difficult to use &lt;code&gt;gzopen&lt;/code&gt; in situations where you wanted to extract/create a gzip data stream that is embedded in a larger file, without having to resort to opening and closing the file multiple times.</source>
          <target state="translated">일부 운영 체제에서 이식 할 수없는 것 외에도 파일을 여러 번 열고 닫을 필요없이 더 큰 파일에 포함 된 gzip 데이터 스트림을 추출 / 생성하려는 상황에서 &lt;code&gt;gzopen&lt;/code&gt; 을 사용하기가 어려웠습니다. 타임스.</target>
        </trans-unit>
        <trans-unit id="4e3144b6ad1fe422c840b3431e9e995cf1a334a3" translate="yes" xml:space="preserve">
          <source>Apart from discussing the C interface provided by Perl for writing callbacks the document uses a series of examples to show how the interface actually works in practice. In addition some techniques for coding callbacks are covered.</source>
          <target state="translated">콜백을 작성하기 위해 Perl에서 제공 한 C 인터페이스를 논의하는 것 외에도이 문서는 일련의 예제를 사용하여 실제로 실제로 인터페이스가 작동하는 방식을 보여줍니다. 또한 콜백 코딩을위한 일부 기술이 설명됩니다.</target>
        </trans-unit>
        <trans-unit id="6c594049f559b0aa030aaa7fc2712868c419ba1f" translate="yes" xml:space="preserve">
          <source>Apart from now being a boolean, the &lt;code&gt;$^W&lt;/code&gt; variable operates in exactly the same horrible uncontrolled global way, except that it cannot disable/enable default warnings.</source>
          <target state="translated">현재 부울 인 것 외에도 &lt;code&gt;$^W&lt;/code&gt; 변수는 기본 경고를 비활성화 / 활성화 할 수 없다는 점을 제외하고는 끔찍한 제어되지 않는 전역 방식으로 작동합니다.</target>
        </trans-unit>
        <trans-unit id="03dfbadf395083cbac3ebe537f5fd26158769beb" translate="yes" xml:space="preserve">
          <source>Apart from resetting the iterator, &lt;code&gt;values @array&lt;/code&gt; in list context is the same as plain &lt;code&gt;@array&lt;/code&gt;. (We recommend that you use void context &lt;code&gt;keys @array&lt;/code&gt; for this, but reasoned that taking &lt;code&gt;values @array&lt;/code&gt; out would require more documentation than leaving it in.)</source>
          <target state="translated">반복자를 재설정하는 것 외에도 목록 컨텍스트의 &lt;code&gt;values @array&lt;/code&gt; 은 일반 &lt;code&gt;@array&lt;/code&gt; 와 동일 합니다. (이를 위해 빈 컨텍스트 &lt;code&gt;keys @array&lt;/code&gt; 를 사용하는 것이 좋지만 @array &lt;code&gt;values @array&lt;/code&gt; 을 가져 오려면 그대로 두는 것보다 더 많은 문서가 필요하다고 생각했습니다.)</target>
        </trans-unit>
        <trans-unit id="177ebac14cb8719946f6e7935d5609a89f70ecb3" translate="yes" xml:space="preserve">
          <source>Apart from the behavior described above, Perl does not expand multiple levels of interpolation. In particular, contrary to the expectations of shell programmers, back-quotes do</source>
          <target state="translated">위에서 설명한 동작 외에도 Perl은 여러 수준의 보간을 확장하지 않습니다. 특히, 쉘 프로그래머의 기대와 달리, 역 따옴표는</target>
        </trans-unit>
        <trans-unit id="5e5b5fcfebfb49c5cb95c4adedad19fe315234ce" translate="yes" xml:space="preserve">
          <source>Apart from the first parameter, import can accept an optional list of parameters. These can be used to pass parameters to the filter. For example:</source>
          <target state="translated">첫 번째 매개 변수 외에도 가져 오기는 선택적 매개 변수 목록을 승인 할 수 있습니다. 이것들은 파라미터를 필터에 전달하는데 사용될 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ea290b2592c04a29efbf4275fbffd4e15c783ad7" translate="yes" xml:space="preserve">
          <source>Apart from the overstrike, it in all ways functions like Pod::Text. See &lt;a href=&quot;../text&quot;&gt;Pod::Text&lt;/a&gt; for details and available options.</source>
          <target state="translated">오버 스트라이크 외에도 모든 방식으로 포드 : 텍스트와 같은 기능을 수행합니다. 자세한 내용과 사용 가능한 옵션 은 &lt;a href=&quot;../text&quot;&gt;포드 :: 텍스트&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="da695cf6105edcb1a8b40d8d706c52df71f42750" translate="yes" xml:space="preserve">
          <source>Apart from the overstrike, it in all ways functions like Pod::Text. See &lt;a href=&quot;Pod::Text&quot;&gt;Pod::Text&lt;/a&gt; for details and available options.</source>
          <target state="translated">오버 스트라이크를 제외하고는 모든면에서 Pod :: Text와 같은 기능을합니다. 자세한 내용과 사용 가능한 옵션 은 &lt;a href=&quot;Pod::Text&quot;&gt;Pod :: Text&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="9828a7d2d366fc4b8702a1f03e94b53802450369" translate="yes" xml:space="preserve">
          <source>Apollo Domain/OS</source>
          <target state="translated">아폴로 도메인 / OS</target>
        </trans-unit>
        <trans-unit id="29f771942800f2d67122e33798021164ef80e3a2" translate="yes" xml:space="preserve">
          <source>App::Cpan</source>
          <target state="translated">App::Cpan</target>
        </trans-unit>
        <trans-unit id="5d59978967734805e51a9980657b59fbf6558d9e" translate="yes" xml:space="preserve">
          <source>App::Cpan - easily interact with CPAN from the command line</source>
          <target state="translated">App :: Cpan-명령 줄에서 CPAN과 쉽게 상호 작용</target>
        </trans-unit>
        <trans-unit id="59fd50fcdac085cfabfc65f7db775038f8cecc31" translate="yes" xml:space="preserve">
          <source>App::Prove</source>
          <target state="translated">App::Prove</target>
        </trans-unit>
        <trans-unit id="3a1656ea85b06be3923d0763368c6414c09514c6" translate="yes" xml:space="preserve">
          <source>App::Prove - Implements the &lt;code&gt;prove&lt;/code&gt; command.</source>
          <target state="translated">App :: Prove- &lt;code&gt;prove&lt;/code&gt; 명령을 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="7174791288d36e70929f8c68ba39037f796046e4" translate="yes" xml:space="preserve">
          <source>App::Prove::State</source>
          <target state="translated">App::Prove::State</target>
        </trans-unit>
        <trans-unit id="39ce25b85982de5bdaced90b86fd5469adc9a51a" translate="yes" xml:space="preserve">
          <source>App::Prove::State - State storage for the &lt;code&gt;prove&lt;/code&gt; command.</source>
          <target state="translated">App :: Prove :: State- &lt;code&gt;prove&lt;/code&gt; 명령의 상태 저장소입니다 .</target>
        </trans-unit>
        <trans-unit id="96f79883bf2f299a489c18241a0f9c3ce22137d2" translate="yes" xml:space="preserve">
          <source>App::Prove::State::Result</source>
          <target state="translated">App::Prove::State::Result</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
