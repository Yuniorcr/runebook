<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="perl">
    <body>
      <group id="perl">
        <trans-unit id="254f31569eb5ae2200e952d6645d10bd474402c9" translate="yes" xml:space="preserve">
          <source>You can also insert hooks into the file inclusion system by putting Perl code directly into &lt;code&gt;@INC&lt;/code&gt; . Those hooks may be subroutine references, array references or blessed objects. See &lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt; for details.</source>
          <target state="translated">Perl 코드를 &lt;code&gt;@INC&lt;/code&gt; 에 직접 넣어 파일 포함 시스템에 후크를 삽입 할 수도 있습니다 . 이러한 후크는 서브 루틴 참조, 배열 참조 또는 축복 된 객체 일 수 있습니다. &lt;a href=&quot;functions/require&quot;&gt;요구&lt;/a&gt; 참조 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="0d00ca1cf68d3a16d0f398e68938a43a44653a67" translate="yes" xml:space="preserve">
          <source>You can also insert hooks into the file inclusion system by putting Perl code directly into &lt;code&gt;@INC&lt;/code&gt;. Those hooks may be subroutine references, array references or blessed objects. See &lt;a href=&quot;perlfunc#require&quot;&gt;&quot;require&quot; in perlfunc&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d3bd593043bf11a275706b2d003ae9bc2607ea6" translate="yes" xml:space="preserve">
          <source>You can also insert hooks into the import facility by putting Perl code directly into the &lt;a href=&quot;perlvar#%40INC&quot;&gt;&lt;code&gt;@INC&lt;/code&gt;&lt;/a&gt; array. There are three forms of hooks: subroutine references, array references, and blessed objects.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae3dcb264a37bf433b3f44d57e7b80c09701bead" translate="yes" xml:space="preserve">
          <source>You can also insert hooks into the import facility by putting Perl code directly into the @INC array. There are three forms of hooks: subroutine references, array references, and blessed objects.</source>
          <target state="translated">Perl 코드를 @INC 배열에 직접 넣어 가져 오기 기능에 후크를 삽입 할 수도 있습니다. 후크에는 서브 루틴 참조, 배열 참조 및 축복 된 객체의 세 가지 형태가 있습니다.</target>
        </trans-unit>
        <trans-unit id="05e59c02014a1d5de9eba1297e8dbc08a175322a" translate="yes" xml:space="preserve">
          <source>You can also just quickly &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; on an undefined value this way:</source>
          <target state="translated">당신은 또한 빨리 &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; 수 있습니다이 방법으로 정의되지 않은 값으로 .</target>
        </trans-unit>
        <trans-unit id="d08d52cd53b0788f14ad13e65f62fc4176471f69" translate="yes" xml:space="preserve">
          <source>You can also just quickly &lt;code&gt;die&lt;/code&gt; on an undefined value this way:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5af0b3086e446e033f6737e913de95b977971d84" translate="yes" xml:space="preserve">
          <source>You can also look for information at:</source>
          <target state="translated">다음에서 정보를 찾을 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="87644608210f2aa31bbb03fc62e8e9aeb59cfbac" translate="yes" xml:space="preserve">
          <source>You can also make the warnings fatal by importing this module as:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c87e0f17edfeca7f9eb08d5d17c96c80da6a5f2" translate="yes" xml:space="preserve">
          <source>You can also organize your tests within subdirectories in the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52f3afa40db22b85e32dd734c2f80ac43010fee7" translate="yes" xml:space="preserve">
          <source>You can also override &lt;code&gt;DOES&lt;/code&gt; directly in your own classes. If you override this method, it should never throw an exception.</source>
          <target state="translated">&lt;code&gt;DOES&lt;/code&gt; 를 재정의 할 수도 있습니다.자신의 클래스에서 직접 . 이 메소드를 대체하면 예외가 발생하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="95cd0a4f9ce9a6a1469a2469c1efc68cdb5fae5b" translate="yes" xml:space="preserve">
          <source>You can also pass &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; an explicit encoding to change it on the fly. This isn't exactly &quot;binary&quot; mode, but we still use &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; to do it:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; 에 명시 적 인코딩을 전달 하여 즉시 변경할 수도 있습니다. 이것은 정확히 &quot;이진&quot;모드는 아니지만 여전히 &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; 를 사용 하여 수행합니다.</target>
        </trans-unit>
        <trans-unit id="0073e68ffe2cd9f7e4c5d59bc4ac83d3762723b7" translate="yes" xml:space="preserve">
          <source>You can also pass &lt;code&gt;binmode&lt;/code&gt; an explicit encoding to change it on the fly. This isn't exactly &quot;binary&quot; mode, but we still use &lt;code&gt;binmode&lt;/code&gt; to do it:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f90ccf1fd48c6dc4de43f56b2888c9c3134e2996" translate="yes" xml:space="preserve">
          <source>You can also pass a subroutine reference in order to determine and return the proper program to run based on a given test script. The subroutine reference should expect the TAP::Harness object itself as the first argument, and the file name as the second argument. It should return an array reference containing the command to be run and including the test file name. It can also simply return &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;, in which case TAP::Harness will fall back on executing the test script in Perl:</source>
          <target state="translated">주어진 테스트 스크립트를 기반으로 실행할 적절한 프로그램을 결정하고 리턴하기 위해 서브 루틴 참조를 전달할 수도 있습니다. 서브 루틴 참조는 TAP :: Harness 오브젝트 자체를 첫 번째 인수로, 파일 이름을 두 번째 인수로 예상해야합니다. 실행할 명령을 포함하고 테스트 파일 이름을 포함하는 배열 참조를 리턴해야합니다. 또한 단순히 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 를 반환 할 수 있습니다 .이 경우 TAP :: Harness는 Perl에서 테스트 스크립트를 실행하면 대체됩니다.</target>
        </trans-unit>
        <trans-unit id="962bddff5bcc07f7f4968830992a0a3b3b51ad71" translate="yes" xml:space="preserve">
          <source>You can also pass a subroutine reference in order to determine and return the proper program to run based on a given test script. The subroutine reference should expect the TAP::Harness object itself as the first argument, and the file name as the second argument. It should return an array reference containing the command to be run and including the test file name. It can also simply return &lt;code&gt;undef&lt;/code&gt;, in which case TAP::Harness will fall back on executing the test script in Perl:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f73ef4e3f69ff87027791a2bee2e957755bc2ee3" translate="yes" xml:space="preserve">
          <source>You can also read and execute Perl statements from a file while in the midst of your C program, by placing the filename in</source>
          <target state="translated">파일 이름을 다음과 같이하여 C 프로그램 도중 파일에서 Perl 문을 읽고 실행할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="e9bed781c4a6044ffb67b23fe5c127e03e4dd1a1" translate="yes" xml:space="preserve">
          <source>You can also refer to capture groups relatively, by using a negative number, so that &lt;code&gt;\g-1&lt;/code&gt; and &lt;code&gt;\g{-1}&lt;/code&gt; both refer to the immediately preceding capture group, and &lt;code&gt;\g-2&lt;/code&gt; and &lt;code&gt;\g{-2}&lt;/code&gt; both refer to the group before it. For example:</source>
          <target state="translated">또한 음수를 사용하여 캡처 그룹을 상대적으로 참조 할 수 있으므로 &lt;code&gt;\g-1&lt;/code&gt; 및 &lt;code&gt;\g{-1}&lt;/code&gt; 은 바로 앞의 캡처 그룹을 참조하고 &lt;code&gt;\g-2&lt;/code&gt; 및 &lt;code&gt;\g{-2}&lt;/code&gt; 모두 그 전에 그룹을 참조하십시오. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="108a751b15dd5a65748cd5542a9f662a512fab15" translate="yes" xml:space="preserve">
          <source>You can also restrict names to a certain alphabet by specifying the &lt;a href=&quot;charnames&quot;&gt;charnames&lt;/a&gt; pragma:</source>
          <target state="translated">또한 지정하여 특정 알파벳으로 이름을 제한 할 수 있습니다 &lt;a href=&quot;charnames&quot;&gt;charnames의&lt;/a&gt; 프라그를 :</target>
        </trans-unit>
        <trans-unit id="0b5023bd40fe3a7df91e6504812de04a002532fe" translate="yes" xml:space="preserve">
          <source>You can also see in that example that we use &lt;code&gt;utf8_to_uvchr_buf&lt;/code&gt; to get the value of the character; the inverse function &lt;code&gt;uvchr_to_utf8&lt;/code&gt; is available for putting a UV into UTF-8:</source>
          <target state="translated">이 예에서 &lt;code&gt;utf8_to_uvchr_buf&lt;/code&gt; 를 사용 하여 캐릭터의 값을 얻는다는 것을 알 수 있습니다 . 반전 함수 &lt;code&gt;uvchr_to_utf8&lt;/code&gt; 은 UV를 UTF-8에 넣는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2fae27cd653314395e221d45c5f75ed85eb09446" translate="yes" xml:space="preserve">
          <source>You can also send patch files to &lt;a href=&quot;mailto:perl5-porters@perl.org&quot;&gt;perl5-porters@perl.org&lt;/a&gt; directly if the patch is not ready to be applied, but intended for discussion.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a3be218b57aec1fe1552cf95cde772b459e8c4a" translate="yes" xml:space="preserve">
          <source>You can also send pull requests to the Github repository:</source>
          <target state="translated">풀 요청을 Github 리포지토리로 보낼 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="36456f92328715ac88fc0c97cb1b9c2205f52562" translate="yes" xml:space="preserve">
          <source>You can also set up your user name and e-mail address. Most people do this once globally in their</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a4162cf16b37e0bb4e40d233ea23d3b932f7f0d" translate="yes" xml:space="preserve">
          <source>You can also specify the separator character using hexadecimal notation: &lt;b&gt;-0x&lt;i&gt;HHH...&lt;/i&gt;&lt;/b&gt;, where the &lt;code&gt;&lt;i&gt;H&lt;/i&gt;&lt;/code&gt; are valid hexadecimal digits. Unlike the octal form, this one may be used to specify any Unicode character, even those beyond 0xFF. So if you</source>
          <target state="translated">16 진수 표기법 &lt;b&gt;-0x &lt;i&gt;HHH ...를&lt;/i&gt;&lt;/b&gt; 사용하여 구분 기호 문자를 지정할 수도 있습니다. 여기서 &lt;code&gt;&lt;i&gt;H&lt;/i&gt;&lt;/code&gt; 는 유효한 16 진수입니다. 8 진 형식과 달리이 형식은 0xFF 이외의 문자를 포함하여 모든 유니 코드 문자를 지정하는 데 사용될 수 있습니다. 그래서 당신이</target>
        </trans-unit>
        <trans-unit id="5708c7cba5f95ced05791bc1f781cc7e3ab698d2" translate="yes" xml:space="preserve">
          <source>You can also specify to NOT use something:</source>
          <target state="translated">무언가를 사용하지 않도록 지정할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="d0e21d8042eb943e53a763ac42b81475843fd69a" translate="yes" xml:space="preserve">
          <source>You can also store data in network order to allow easy sharing across multiple platforms, or when storing on a socket known to be remotely connected. The routines to call have an initial &lt;code&gt;n&lt;/code&gt; prefix for</source>
          <target state="translated">또한 여러 플랫폼에서 쉽게 공유 할 수 있도록 또는 원격으로 연결된 소켓에 저장할 때 네트워크 순서대로 데이터를 저장할 수 있습니다. 호출 할 루틴에는 초기 &lt;code&gt;n&lt;/code&gt; 접두사가 있습니다.</target>
        </trans-unit>
        <trans-unit id="32a000612a53a9f73b8165e9ffd35ee663d455aa" translate="yes" xml:space="preserve">
          <source>You can also subscript a list to get a single element from it:</source>
          <target state="translated">리스트를 첨자 화하여 하나의 요소를 얻을 수도 있습니다 :</target>
        </trans-unit>
        <trans-unit id="e308900a9f85413017177815b933ee92128f909d" translate="yes" xml:space="preserve">
          <source>You can also test a class, to make sure that it has the right ancestor:</source>
          <target state="translated">클래스가 올바른 조상인지 확인하기 위해 클래스를 테스트 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="45cf05db45090a770c4e7c7739f97f42fdaa1b72" translate="yes" xml:space="preserve">
          <source>You can also test whether a version object is an alpha version, for example to prevent the use of some feature not present in the main release:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e940484c0812f3991ca3b5162180666fbbc774e9" translate="yes" xml:space="preserve">
          <source>You can also try &lt;code&gt;guess_encoding&lt;/code&gt; function which is exported by default. It takes $data to check and it also takes the list of suspects by option. The optional suspect list is</source>
          <target state="translated">기본적으로 내보내지는 &lt;code&gt;guess_encoding&lt;/code&gt; 함수를 사용해 볼 수도 있습니다 . 검사하는 데 $ data가 필요하며 옵션별로 용의자 목록이 필요합니다. 선택적 용의자 목록은</target>
        </trans-unit>
        <trans-unit id="c6c2bb7263fcb86f56120bac5220dbcae10e778f" translate="yes" xml:space="preserve">
          <source>You can also try to include the module in a one-liner to see if perl finds it:</source>
          <target state="translated">또한 펄이 모듈을 찾는 지 확인하기 위해 하나의 라이너에 모듈을 포함시킬 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="b15c66e70792efbd27fd6c112e317c6eb54c5b69" translate="yes" xml:space="preserve">
          <source>You can also try using &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork&lt;/a&gt;&lt;/code&gt;, as described in &lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt; (although this is the same thing that many of the modules will do for you).</source>
          <target state="translated">&lt;a href=&quot;perlfunc&quot;&gt;perlfunc에&lt;/a&gt; 설명 된대로 &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork&lt;/a&gt;&lt;/code&gt; 사용을 시도 할 수도 있습니다 (여러 모듈이 자동으로 수행하는 것과 동일하지만).</target>
        </trans-unit>
        <trans-unit id="74be7ad2f05258d57aeb18d3aea7623947196e74" translate="yes" xml:space="preserve">
          <source>You can also try using &lt;code&gt;fork&lt;/code&gt;, as described in &lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt; (although this is the same thing that many of the modules will do for you).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22d0b06ab6697336780029eb518e6cdd2c05382e" translate="yes" xml:space="preserve">
          <source>You can also use</source>
          <target state="translated">당신은 또한 사용할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="e0b40e46358631fd782ce6cd1e20ef0687b61198" translate="yes" xml:space="preserve">
          <source>You can also use 0x8e and 0x8f to indicate that the following sequence of characters belongs to yet another character set. To each following byte is added the value 0x80.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="202f7bfbf8f49e8ba6c221c617da66be05b837aa" translate="yes" xml:space="preserve">
          <source>You can also use &lt;a href=&quot;Class::Tiny::Antlers&quot;&gt;Class::Tiny::Antlers&lt;/a&gt; for &lt;code&gt;Moose&lt;/code&gt;-like syntax.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da89dff1ecf2505f23c0fe06386fc84d5b6555f6" translate="yes" xml:space="preserve">
          <source>You can also use &lt;a href=&quot;Devel::REPL&quot;&gt;Devel::REPL&lt;/a&gt; which is an interactive shell for Perl, commonly known as a REPL - Read, Evaluate, Print, Loop. It provides various handy features.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05db0e88a7c897c6cc9fa696a780cde648824d4d" translate="yes" xml:space="preserve">
          <source>You can also use &lt;a href=&quot;Tie::Cycle&quot;&gt;Tie::Cycle&lt;/a&gt; to use a scalar that always has the next element of the circular array:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8cb4cba1a89412d983ef34b9565f67b33c11cb2b" translate="yes" xml:space="preserve">
          <source>You can also use &lt;a href=&quot;Time::Piece&quot;&gt;Time::Piece&lt;/a&gt;, which comes with Perl and provides a &lt;code&gt;localtime&lt;/code&gt; that returns an object:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0304b03ea61e4912a40d9a36c7c0d47306360a9" translate="yes" xml:space="preserve">
          <source>You can also use &lt;a href=&quot;http://search.cpan.org/perldoc/Class::Tiny::Antlers&quot;&gt;Class::Tiny::Antlers&lt;/a&gt; for &lt;code&gt;Moose&lt;/code&gt; -like syntax.</source>
          <target state="translated">&lt;code&gt;Moose&lt;/code&gt; 와 유사한 구문에 &lt;a href=&quot;http://search.cpan.org/perldoc/Class::Tiny::Antlers&quot;&gt;Class :: Tiny :: Antlers&lt;/a&gt; 를 사용할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="37de0be164e83020017ecbe8445d1b73a8f2a1b8" translate="yes" xml:space="preserve">
          <source>You can also use &lt;a href=&quot;http://search.cpan.org/perldoc/Devel::REPL&quot;&gt;Devel::REPL&lt;/a&gt; which is an interactive shell for Perl, commonly known as a REPL - Read, Evaluate, Print, Loop. It provides various handy features.</source>
          <target state="translated">REPL-Read, Evaluate, Print, Loop로 알려진 Perl의 대화식 쉘인 &lt;a href=&quot;http://search.cpan.org/perldoc/Devel::REPL&quot;&gt;Devel :: REPL&lt;/a&gt; 을 사용할 수도 있습니다 . 다양한 편리한 기능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="9013c35ad3298535ad5c8c74739a6a896be46939" translate="yes" xml:space="preserve">
          <source>You can also use &lt;a href=&quot;http://search.cpan.org/perldoc/Tie::Cycle&quot;&gt;Tie::Cycle&lt;/a&gt; to use a scalar that always has the next element of the circular array:</source>
          <target state="translated">&lt;a href=&quot;http://search.cpan.org/perldoc/Tie::Cycle&quot;&gt;Tie :: Cycle&lt;/a&gt; 을 사용하여 항상 원형 배열의 다음 요소가있는 스칼라를 사용할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ed9079885add1db23c7b692dc26264a6c8112995" translate="yes" xml:space="preserve">
          <source>You can also use &lt;a href=&quot;http://search.cpan.org/perldoc/local::lib&quot;&gt;local::lib&lt;/a&gt; to do much of the same thing. Install modules using &lt;a href=&quot;http://search.cpan.org/perldoc/local::lib&quot;&gt;local::lib&lt;/a&gt;'s settings then use the module in your program:</source>
          <target state="translated">&lt;a href=&quot;http://search.cpan.org/perldoc/local::lib&quot;&gt;local :: lib&lt;/a&gt; 를 사용 하여 동일한 작업을 수행 할 수도 있습니다 . 사용 모듈 설치 &lt;a href=&quot;http://search.cpan.org/perldoc/local::lib&quot;&gt;지역 :: lib 디렉토리를&lt;/a&gt; 다음 프로그램에서 모듈을 사용의 설정을 :</target>
        </trans-unit>
        <trans-unit id="cee36dc459570b6060c3229ade20676c1103dac6" translate="yes" xml:space="preserve">
          <source>You can also use &lt;a href=&quot;local::lib&quot;&gt;local::lib&lt;/a&gt; to do much of the same thing. Install modules using &lt;a href=&quot;local::lib&quot;&gt;local::lib&lt;/a&gt;'s settings then use the module in your program:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38efc50c4c6a8567a3f07d734113580b8054b830" translate="yes" xml:space="preserve">
          <source>You can also use &lt;a href=&quot;time/piece&quot;&gt;Time::Piece&lt;/a&gt;, which comes with Perl and provides a &lt;code&gt;&lt;a href=&quot;functions/localtime&quot;&gt;localtime&lt;/a&gt;&lt;/code&gt; that returns an object:</source>
          <target state="translated">Perl과 함께 제공되며 객체를 반환하는 &lt;code&gt;&lt;a href=&quot;functions/localtime&quot;&gt;localtime&lt;/a&gt;&lt;/code&gt; &lt;a href=&quot;time/piece&quot;&gt; 시간&lt;/a&gt; 을 제공 하는 Time :: Piece를 사용할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fe8ff91507ad3e201158ab00126828440dda9b62" translate="yes" xml:space="preserve">
          <source>You can also use &lt;code&gt;HANDLE-&amp;gt;input_line_number(EXPR)&lt;/code&gt; to access the line counter for a given filehandle without having to worry about which handle you last accessed.</source>
          <target state="translated">당신은 또한 사용할 수 있습니다 &lt;code&gt;HANDLE-&amp;gt;input_line_number(EXPR)&lt;/code&gt; 마지막으로 액세스 핸들하는 걱정없이 주어진 파일 핸들의 라인 카운터에 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cfc194c704de65f5fa2e2dc7cdfca08cd861cafc" translate="yes" xml:space="preserve">
          <source>You can also use &lt;code&gt;cpan&lt;/code&gt; 's &lt;code&gt;-a&lt;/code&gt; switch to create an autobundle file that &lt;code&gt;CPAN.pm&lt;/code&gt; understands and can use to re-install every module:</source>
          <target state="translated">당신은 또한 사용할 수 있습니다 &lt;code&gt;cpan&lt;/code&gt; 의 &lt;code&gt;-a&lt;/code&gt; 있다는 autobundle 파일을 만들 수있는 스위치 &lt;code&gt;CPAN.pm&lt;/code&gt; 가 이해하고 사용할 수있는 모든 모듈을 다시 설치 :</target>
        </trans-unit>
        <trans-unit id="c32a4a11aa3d97ad829511eee7c584cbf65b7424" translate="yes" xml:space="preserve">
          <source>You can also use &lt;code&gt;cpan&lt;/code&gt;'s &lt;code&gt;-a&lt;/code&gt; switch to create an autobundle file that &lt;code&gt;CPAN.pm&lt;/code&gt; understands and can use to re-install every module:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ed04ee9d470ae5bb5ded41953f6884557aab9f4" translate="yes" xml:space="preserve">
          <source>You can also use &lt;code&gt;while&lt;/code&gt; in a post-condition:</source>
          <target state="translated">당신은 또한 사용할 수 있습니다 &lt;code&gt;while&lt;/code&gt; 후 상태 :</target>
        </trans-unit>
        <trans-unit id="d2490129a2ade6b9a949f50bed0b1d18208e8c0a" translate="yes" xml:space="preserve">
          <source>You can also use Perl one-liners to modify a file in-place. The following changes all 'Fred' to 'Barney' in</source>
          <target state="translated">Perl 원 라이너를 사용하여 파일을 내부에서 수정할 수도 있습니다. 다음은 모든 'Fred'를 'Barney'로 변경합니다.</target>
        </trans-unit>
        <trans-unit id="7bdc3a001959e967af8fbe560047483c608a1a86" translate="yes" xml:space="preserve">
          <source>You can also use PerlIO to convert larger amounts of data you don't want to bring into memory. For example, to convert between ISO-8859-1 (Latin 1) and UTF-8 (or UTF-EBCDIC in EBCDIC machines):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae806fe9a09487e09415c88d84054f11b5bab926" translate="yes" xml:space="preserve">
          <source>You can also use a commercial debugger such as Affrus (Mac OS X), Komodo from Activestate (Windows and Mac OS X), or EPIC (most platforms).</source>
          <target state="translated">Affrus (Mac OS X), Activestate의 Komodo (Windows 및 Mac OS X) 또는 EPIC (대부분의 플랫폼)과 같은 상용 디버거를 사용할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="79babd18e608e40e4da78366242734a20c79cee2" translate="yes" xml:space="preserve">
          <source>You can also use a double fork. You immediately &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait()&lt;/a&gt;&lt;/code&gt; for your first child, and the init daemon will &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait()&lt;/a&gt;&lt;/code&gt; for your grandchild once it exits.</source>
          <target state="translated">이중 포크를 사용할 수도 있습니다. 첫 번째 자식을 즉시 &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait()&lt;/a&gt;&lt;/code&gt; , init 데몬은 손자 가 &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait()&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d69e7ee5e4d94793bbffd2e90393fe6a378a73cd" translate="yes" xml:space="preserve">
          <source>You can also use a double fork. You immediately &lt;code&gt;wait()&lt;/code&gt; for your first child, and the init daemon will &lt;code&gt;wait()&lt;/code&gt; for your grandchild once it exits.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ef85cce54fb95ce8f948edcebadc50c579e68d3" translate="yes" xml:space="preserve">
          <source>You can also use a list slice to select only the elements that you need:</source>
          <target state="translated">목록 조각을 사용하여 필요한 요소 만 선택할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="d760c6f0200ce645ec4271e39ed0780a635d6be2" translate="yes" xml:space="preserve">
          <source>You can also use a localized &lt;code&gt;@ARGV&lt;/code&gt; to eliminate the &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">현지화 된 &lt;code&gt;@ARGV&lt;/code&gt; 를 사용 하여 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; 를 제거 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="52b5c5f91438f8f97a41eab3ee2f38fefeb189a7" translate="yes" xml:space="preserve">
          <source>You can also use a localized &lt;code&gt;@ARGV&lt;/code&gt; to eliminate the &lt;code&gt;open&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4613c51eb74aabc580ab960ede735ed7c5a84c03" translate="yes" xml:space="preserve">
          <source>You can also use a subroutine reference as a method:</source>
          <target state="translated">서브 루틴 참조를 메소드로 사용할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="55b643d1caec2f7008ddc9ff139f97c1c50f1aef" translate="yes" xml:space="preserve">
          <source>You can also use certain libraries like &lt;a href=&quot;config&quot;&gt;Config&lt;/a&gt; conditionally, but be sure to skip the test gracefully if it's not there.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f4a8095c707393fa806f56c74d791b44c5bdbd35" translate="yes" xml:space="preserve">
          <source>You can also use certain libraries like Config conditionally, but be sure to skip the test gracefully if it's not there.</source>
          <target state="translated">조건부로 Config와 같은 특정 라이브러리를 조건부로 사용할 수도 있지만 테스트가 없으면 정상적으로 건너 뛰십시오.</target>
        </trans-unit>
        <trans-unit id="aee62fec81f8fc5af73b94cc4b6a4396ba0e2b3e" translate="yes" xml:space="preserve">
          <source>You can also use dmake to build using Visual C++; provided, however, you set OSRELEASE to &quot;microsft&quot; (or whatever the directory name under which the Visual C dmake configuration lives) in your environment and edit win32/config.vc to change &quot;make=nmake&quot; into &quot;make=dmake&quot;. The latter step is only essential if you want to use dmake as your default make for building extensions using MakeMaker.</source>
          <target state="translated">dmake를 사용하여 Visual C ++를 사용하여 빌드 할 수도 있습니다. 그러나 사용자 환경에서 OSRELEASE를 &quot;microsft&quot;(또는 Visual C dmake 구성이있는 디렉토리 이름)로 설정하고 win32 / config.vc를 편집하여 &quot;make = nmake&quot;를 &quot;make = dmake&quot;로 변경하십시오. 후자의 단계는 MakeMaker를 사용하여 확장을 빌드하기위한 기본 make로 dmake를 사용하려는 경우에만 필수입니다.</target>
        </trans-unit>
        <trans-unit id="4fabe958607319aed5413ce7d91aa1937c4486e1" translate="yes" xml:space="preserve">
          <source>You can also use file-descriptor redirection to make STDERR a duplicate of STDOUT:</source>
          <target state="translated">파일 디스크립터 리디렉션을 사용하여 STDERR을 STDOUT의 복제본으로 만들 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="bb1f48473296bb1c89d7c3f43ff784b475814cae" translate="yes" xml:space="preserve">
          <source>You can also use negation in both &lt;code&gt;\p{}&lt;/code&gt; and &lt;code&gt;\P{}&lt;/code&gt; by introducing a caret (&lt;code&gt;^&lt;/code&gt;) between the first brace and the property name: &lt;code&gt;\p{^Tamil}&lt;/code&gt; is equal to &lt;code&gt;\P{Tamil}&lt;/code&gt; .</source>
          <target state="translated">첫 번째 괄호와 속성 이름 사이에 캐럿 ( &lt;code&gt;^&lt;/code&gt; ) 을 도입하여 &lt;code&gt;\p{}&lt;/code&gt; 및 &lt;code&gt;\P{}&lt;/code&gt; 에서 부정을 사용할 수도 있습니다 . &lt;code&gt;\p{^Tamil}&lt;/code&gt; 은 &lt;code&gt;\P{Tamil}&lt;/code&gt; 과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="54d20874570939ffd2d092114e0b4e19463ff0b5" translate="yes" xml:space="preserve">
          <source>You can also use negation in both &lt;code&gt;\p{}&lt;/code&gt; and &lt;code&gt;\P{}&lt;/code&gt; by introducing a caret (&lt;code&gt;^&lt;/code&gt;) between the first brace and the property name: &lt;code&gt;\p{^Tamil}&lt;/code&gt; is equal to &lt;code&gt;\P{Tamil}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e6a71e5490894554dcf75a2f44b77577d1780db" translate="yes" xml:space="preserve">
          <source>You can also use substr() as an lvalue.</source>
          <target state="translated">substr ()을 lvalue로 사용할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="c8a027b09bbb1035f68edd31b3dac9da865767c1" translate="yes" xml:space="preserve">
          <source>You can also use the -Duse64bitint flag to Configure. Although there are some minor differences between compiling Perl with this flag versus the -Duse64bitall flag, they should not be noticeable from a Perl user's perspective. When configuring -Duse64bitint using a 64bit gcc on a pa-risc architecture, -Duse64bitint is silently promoted to -Duse64bitall.</source>
          <target state="translated">-Duse64bitint 플래그를 사용하여 구성 할 수도 있습니다. 이 플래그를 사용하여 Perl을 컴파일하는 것과 -Duse64bitall 플래그를 컴파일하는 것에는 약간의 차이가 있지만 Perl 사용자의 관점에서는 눈에 띄지 않아야합니다. pa-risc 아키텍처에서 64 비트 gcc를 사용하여 -Duse64bitint를 구성하면 -Duse64bitint가 자동으로 -Duse64bitall로 승격됩니다.</target>
        </trans-unit>
        <trans-unit id="b2a60dda9b88e0346f381f0e7d0f8c46c74bcfba" translate="yes" xml:space="preserve">
          <source>You can also use the &lt;a href=&quot;Date::Calc&quot;&gt;Date::Calc&lt;/a&gt; module using its &lt;code&gt;Today_and_Now&lt;/code&gt; function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a700e3ed5372f353d27ba3249155ac84ffdf5ae" translate="yes" xml:space="preserve">
          <source>You can also use the &lt;a href=&quot;Tie::File&quot;&gt;Tie::File&lt;/a&gt; module which lets you access the lines through a tied array. You can use normal array operations to modify your file, including setting the last index and using &lt;code&gt;splice&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01f985bfd65126ce04f3352a8f1c24d2647a415c" translate="yes" xml:space="preserve">
          <source>You can also use the &lt;a href=&quot;http://search.cpan.org/perldoc/Date::Calc&quot;&gt;Date::Calc&lt;/a&gt; module using its &lt;code&gt;Today_and_Now&lt;/code&gt; function.</source>
          <target state="translated">&lt;code&gt;Today_and_Now&lt;/code&gt; 함수 를 사용하여 &lt;a href=&quot;http://search.cpan.org/perldoc/Date::Calc&quot;&gt;Date :: Calc&lt;/a&gt; 모듈을 사용할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="5948ec91fdfb792b5884ccadb56a91fc59d16359" translate="yes" xml:space="preserve">
          <source>You can also use the &lt;a href=&quot;tie/file&quot;&gt;Tie::File&lt;/a&gt; module which lets you access the lines through a tied array. You can use normal array operations to modify your file, including setting the last index and using &lt;code&gt;&lt;a href=&quot;functions/splice&quot;&gt;splice&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">당신은 또한 사용할 수 있습니다 &lt;a href=&quot;tie/file&quot;&gt;타이 :: 파일&lt;/a&gt; 당신이 묶여 배열을 통해 라인에 액세스 할 수 있습니다 모듈. 마지막 색인 설정 및 &lt;code&gt;&lt;a href=&quot;functions/splice&quot;&gt;splice&lt;/a&gt;&lt;/code&gt; 사용을 포함하여 일반적인 배열 작업을 사용하여 파일을 수정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="cea4cf5784aecf948d1c03056df0b1645df434de" translate="yes" xml:space="preserve">
          <source>You can also use the &lt;code&gt;**&lt;/code&gt; operator, see &lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;**&lt;/code&gt; 연산자를 사용할 수도 있습니다 ( &lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt; 참조) .</target>
        </trans-unit>
        <trans-unit id="aca7a853e98fdbbaafd79c6bf0b9e3d107072aaf" translate="yes" xml:space="preserve">
          <source>You can also use the &lt;code&gt;\G&lt;/code&gt; anchor in scalar context. You still need the &lt;code&gt;g&lt;/code&gt; flag.</source>
          <target state="translated">스칼라 컨텍스트에서 &lt;code&gt;\G&lt;/code&gt; 앵커를 사용할 수도 있습니다 . 여전히 &lt;code&gt;g&lt;/code&gt; 플래그 가 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="dd0679d81994a6f99aa92d35f6d6b0e5281b7e9d" translate="yes" xml:space="preserve">
          <source>You can also use the &lt;code&gt;\G&lt;/code&gt; anchor in scalar context. You still need the &lt;code&gt;g&lt;/code&gt; modifier.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c6b2b4f9f728f0a8f747fc021c92ba0dae0be15" translate="yes" xml:space="preserve">
          <source>You can also use the &lt;code&gt;open3()&lt;/code&gt; function from &lt;a href=&quot;IPC::Open3&quot;&gt;IPC::Open3&lt;/a&gt;. Benjamin Goldberg provides some sample code:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36d5ff0652d0a9cfb0d9a8028ed64cb97f87e026" translate="yes" xml:space="preserve">
          <source>You can also use the &lt;code&gt;open3()&lt;/code&gt; function from &lt;a href=&quot;ipc/open3&quot;&gt;IPC::Open3&lt;/a&gt;. Benjamin Goldberg provides some sample code:</source>
          <target state="translated">&lt;a href=&quot;ipc/open3&quot;&gt;IPC :: Open3&lt;/a&gt; 에서 &lt;code&gt;open3()&lt;/code&gt; 함수를 사용할 수도 있습니다 . Benjamin Goldberg는 몇 가지 샘플 코드를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="54c10825a7a9a0e79c4bc9a8acb25f8c895c8d2f" translate="yes" xml:space="preserve">
          <source>You can also use the Unix command mknod(1), or on some systems, mkfifo(1). These may not be in your normal path, though.</source>
          <target state="translated">Unix 명령 mknod (1) 또는 일부 시스템 인 mkfifo (1)을 사용할 수도 있습니다. 그러나 이것은 정상적인 경로에 있지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d558c8753e7739908d901edc4316bd26afe6b26c" translate="yes" xml:space="preserve">
          <source>You can also use the complement of \b, \B, to specify that there should not be a word boundary.</source>
          <target state="translated">\ b, \ B의 보수를 사용하여 단어 경계가 없어야 함을 지정할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="94817cf57f637575defe9d34927c35a3c77682d8" translate="yes" xml:space="preserve">
          <source>You can also use the following functions to extract the file header information from Storable images:</source>
          <target state="translated">다음 기능을 사용하여 저장 가능 이미지에서 파일 헤더 정보를 추출 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="621c9d7b846400426f6a8d8885a28fc12414361e" translate="yes" xml:space="preserve">
          <source>You can also write that as a single substitution, although it turns out the combined statement is slower than the separate ones. That might not matter to you, though:</source>
          <target state="translated">결합 된 명령문이 별도의 명령문보다 느리지 만 단일 대체로 작성할 수도 있습니다. 그러나 그것은 당신에게 중요하지 않을 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="6e736747d1920ca322bb92742d39b47addfde6fe" translate="yes" xml:space="preserve">
          <source>You can also:</source>
          <target state="translated">당신은 또한 수:</target>
        </trans-unit>
        <trans-unit id="9a39342cae5acfdbd6b63da64d2d504d73f599e3" translate="yes" xml:space="preserve">
          <source>You can alter the global variable $Params::Check::NO_DUPLICATES to control whether the &lt;code&gt;store&lt;/code&gt; 'd key will still be present in your result set. See the &lt;a href=&quot;#Global-Variables&quot;&gt;Global Variables&lt;/a&gt; section below.</source>
          <target state="translated">전역 변수 $ Params :: Check :: NO_DUPLICATES를 변경하여 &lt;code&gt;store&lt;/code&gt; 'd 키가 여전히 결과 세트에 존재 하는지 여부를 제어 할 수 있습니다. 아래의 &lt;a href=&quot;#Global-Variables&quot;&gt;전역 변수&lt;/a&gt; 섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="6da0fead206bedaefe0c555de0dec9128299e2e3" translate="yes" xml:space="preserve">
          <source>You can alter the global variable $Params::Check::NO_DUPLICATES to control whether the &lt;code&gt;store&lt;/code&gt;'d key will still be present in your result set. See the &lt;a href=&quot;#Global-Variables&quot;&gt;&quot;Global Variables&quot;&lt;/a&gt; section below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="330192003f1fea8edf49c86f71523fd9c154de87" translate="yes" xml:space="preserve">
          <source>You can always check the value you're using by printing it in octal notation to ensure it matches what you think it should be. Print it in octal and decimal format:</source>
          <target state="translated">8 진수 표기법으로 인쇄하여 원하는 값과 일치하는지 항상 확인하여 사용중인 값을 확인할 수 있습니다. 8 진수 및 10 진수 형식으로 인쇄하십시오.</target>
        </trans-unit>
        <trans-unit id="ef6c5c0a821b62556c215147b73e29172a7eabfd" translate="yes" xml:space="preserve">
          <source>You can always use an array reference, in curly braces, in place of the name of an array. For example, &lt;code&gt;@{$aref}&lt;/code&gt; instead of &lt;code&gt;@array&lt;/code&gt; .</source>
          <target state="translated">배열 이름 대신 항상 중괄호 안에 배열 참조를 사용할 수 있습니다. 예를 들어 &lt;code&gt;@array&lt;/code&gt; 대신 &lt;code&gt;@{$aref}&lt;/code&gt; 입니다 .</target>
        </trans-unit>
        <trans-unit id="150541d09f643b30e2058d1e0bade9c15ba89324" translate="yes" xml:space="preserve">
          <source>You can always use an array reference, in curly braces, in place of the name of an array. For example, &lt;code&gt;@{$aref}&lt;/code&gt; instead of &lt;code&gt;@array&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7165a3ffe3314c6d01e5a6307c924382d3b64487" translate="yes" xml:space="preserve">
          <source>You can arrange for a callback to be run just before the &lt;a href=&quot;#die-LIST&quot;&gt;&lt;code&gt;die&lt;/code&gt;&lt;/a&gt; does its deed, by setting the &lt;a href=&quot;perlvar#%25SIG&quot;&gt;&lt;code&gt;$SIG{__DIE__}&lt;/code&gt;&lt;/a&gt; hook. The associated handler is called with the exception as an argument, and can change the exception, if it sees fit, by calling &lt;a href=&quot;#die-LIST&quot;&gt;&lt;code&gt;die&lt;/code&gt;&lt;/a&gt; again. See &lt;a href=&quot;perlvar#%25SIG&quot;&gt;&quot;%SIG&quot; in perlvar&lt;/a&gt; for details on setting &lt;a href=&quot;perlvar#%25SIG&quot;&gt;&lt;code&gt;%SIG&lt;/code&gt;&lt;/a&gt; entries, and &lt;a href=&quot;#eval-EXPR&quot;&gt;&lt;code&gt;eval&lt;/code&gt;&lt;/a&gt; for some examples. Although this feature was to be run only right before your program was to exit, this is not currently so: the &lt;a href=&quot;perlvar#%25SIG&quot;&gt;&lt;code&gt;$SIG{__DIE__}&lt;/code&gt;&lt;/a&gt; hook is currently called even inside &lt;a href=&quot;#eval-EXPR&quot;&gt;&lt;code&gt;eval&lt;/code&gt;&lt;/a&gt;ed blocks/strings! If one wants the hook to do nothing in such situations, put</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4754996a46b2974a193b45735bde04e1ddad5927" translate="yes" xml:space="preserve">
          <source>You can arrange for a callback to be run just before the &lt;code&gt;&lt;a href=&quot;die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; does its deed, by setting the &lt;code&gt;$SIG{__DIE__}&lt;/code&gt; hook. The associated handler is called with the error text and can change the error message, if it sees fit, by calling &lt;code&gt;&lt;a href=&quot;die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; again. See &lt;a href=&quot;../perlvar#%25SIG&quot;&gt;%SIG in perlvar&lt;/a&gt; for details on setting &lt;code&gt;%SIG&lt;/code&gt; entries, and &lt;a href=&quot;#eval-BLOCK&quot;&gt;eval BLOCK&lt;/a&gt; for some examples. Although this feature was to be run only right before your program was to exit, this is not currently so: the &lt;code&gt;$SIG{__DIE__}&lt;/code&gt; hook is currently called even inside eval()ed blocks/strings! If one wants the hook to do nothing in such situations, put</source>
          <target state="translated">&lt;code&gt;$SIG{__DIE__}&lt;/code&gt; 후크 를 설정하여 &lt;code&gt;&lt;a href=&quot;die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; 가 작업을 수행하기 직전에 콜백을 실행할 수 있습니다 . 연관된 핸들러는 오류 텍스트와 함께 호출되며, 적절하다면 호출하여 오류 메시지를 변경할 수 있습니다. &lt;code&gt;&lt;a href=&quot;die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; 를 다시. &lt;code&gt;%SIG&lt;/code&gt; 항목설정에 대한 자세한 내용&lt;a href=&quot;../perlvar#%25SIG&quot;&gt; 은 perlvar의 % SIG를&lt;/a&gt; 참조하고 일부 예는&lt;a href=&quot;#eval-BLOCK&quot;&gt; eval BLOCK&lt;/a&gt; 을참조하십시오. 이 기능은 프로그램이 종료되기 직전에 실행되었지만 현재는 그렇지 않습니다. &lt;code&gt;$SIG{__DIE__}&lt;/code&gt; 후크는 현재 eval () 블록 / 문자열 내부에서도 호출됩니다! 그러한 상황에서 후크가 아무것도하지 않기를 원한다면</target>
        </trans-unit>
        <trans-unit id="6d6ebe42604b8b630167882d7abe0a8f91ccbdb6" translate="yes" xml:space="preserve">
          <source>You can arrange for a callback to be run just before the &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; does its deed, by setting the &lt;code&gt;$SIG{__DIE__}&lt;/code&gt; hook. The associated handler is called with the error text and can change the error message, if it sees fit, by calling &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; again. See &lt;a href=&quot;perlvar#%25SIG&quot;&gt;%SIG in perlvar&lt;/a&gt; for details on setting &lt;code&gt;%SIG&lt;/code&gt; entries, and &lt;a href=&quot;#eval-BLOCK&quot;&gt;eval BLOCK&lt;/a&gt; for some examples. Although this feature was to be run only right before your program was to exit, this is not currently so: the &lt;code&gt;$SIG{__DIE__}&lt;/code&gt; hook is currently called even inside eval()ed blocks/strings! If one wants the hook to do nothing in such situations, put</source>
          <target state="translated">&lt;code&gt;$SIG{__DIE__}&lt;/code&gt; 후크 를 설정하여 &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; 가 작업을 수행하기 직전에 콜백을 실행할 수 있습니다 . 연관된 핸들러는 오류 텍스트와 함께 호출되며, 적절한 경우 &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; 를 호출하여 오류 메시지를 변경할 수 있습니다. 다시 . &lt;code&gt;%SIG&lt;/code&gt; 항목 설정에 대한 자세한 내용&lt;a href=&quot;perlvar#%25SIG&quot;&gt; 은 perlvar의 % SIG를&lt;/a&gt; 참조 하고 일부 예는&lt;a href=&quot;#eval-BLOCK&quot;&gt; eval BLOCK&lt;/a&gt; 을 참조하십시오 . 이 기능은 프로그램이 종료되기 직전에 실행되었지만 현재는 그렇지 않습니다. &lt;code&gt;$SIG{__DIE__}&lt;/code&gt; 후크는 현재 eval () 블록 / 문자열 내부에서도 호출됩니다! 그러한 상황에서 후크가 아무것도하지 않기를 원한다면</target>
        </trans-unit>
        <trans-unit id="b111cf2dc7e21ab63d8886219ae9103dbe8e5745" translate="yes" xml:space="preserve">
          <source>You can ask &lt;code&gt;prove&lt;/code&gt; to remember the state of previous test runs and select and/or order the tests to be run based on that saved state.</source>
          <target state="translated">당신은 요청할 수 있습니다 &lt;code&gt;prove&lt;/code&gt; 이전 테스트 실행의 상태를 기억하고 선택 및 / 또는 저장 상태에 따라 실행되어야 할 시험 항목을 주문.</target>
        </trans-unit>
        <trans-unit id="691310b760f2429354c31b938255b9b2f1fdb135" translate="yes" xml:space="preserve">
          <source>You can avoid this by using a bracketed character class in the lookbehind assertion, like</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="291f7b02019a89ab9c5bae1789127ea82bbc5201" translate="yes" xml:space="preserve">
          <source>You can break circular references by creating a &quot;weak reference&quot;. A weak reference does not increment the reference count for a variable, which means that the object can go out of scope and be destroyed. You can weaken a reference with the &lt;code&gt;weaken&lt;/code&gt; function exported by the &lt;a href=&quot;Scalar::Util&quot;&gt;Scalar::Util&lt;/a&gt; module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5be6ec0673c2462bb7fe8ce793fcded60eef0f18" translate="yes" xml:space="preserve">
          <source>You can break circular references by creating a &quot;weak reference&quot;. A weak reference does not increment the reference count for a variable, which means that the object can go out of scope and be destroyed. You can weaken a reference with the &lt;code&gt;weaken&lt;/code&gt; function exported by the &lt;a href=&quot;scalar/util&quot;&gt;Scalar::Util&lt;/a&gt; module.</source>
          <target state="translated">&quot;약한 참조&quot;를 작성하여 순환 참조를 끊을 수 있습니다. 약한 참조는 변수의 참조 카운트를 증가시키지 않으므로 개체가 범위를 벗어나 파괴 될 수 있습니다. &lt;a href=&quot;scalar/util&quot;&gt;Scalar :: Util&lt;/a&gt; 모듈 에서 내 보낸 &lt;code&gt;weaken&lt;/code&gt; 함수를 사용하여 참조를 약화시킬 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7b50c9286c4042666f0e26f5a3f4bc1fff06eaf5" translate="yes" xml:space="preserve">
          <source>You can call the perl visible subroutine something other than &lt;code&gt;constant&lt;/code&gt; if you give the parameter</source>
          <target state="translated">매개 변수를 제공하면 perl visible 서브 루틴을 &lt;code&gt;constant&lt;/code&gt; 이외의 것으로 호출 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="03c6b44929e8d300ef044fa7166e3c54539d868d" translate="yes" xml:space="preserve">
          <source>You can capture its numeric and string content using:</source>
          <target state="translated">다음을 사용하여 숫자 및 문자열 컨텐츠를 캡처 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="596d44f0dc27aeca16b120bcaf752ef2dfa99248" translate="yes" xml:space="preserve">
          <source>You can categorize these CES by 3 criteria: size of each character, endianness, and Byte Order Mark.</source>
          <target state="translated">이러한 CES를 각 문자의 크기, 엔디안 및 바이트 순서 표시의 3 가지 기준으로 분류 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4b8f84adbeec6314eab49fb83df65b6443839d6c" translate="yes" xml:space="preserve">
          <source>You can cause characters that normally function as metacharacters to be interpreted literally by prefixing them with a &lt;code&gt;&quot;\&quot;&lt;/code&gt;, just like the pattern's delimiter must be escaped if it also occurs within the pattern. Thus, &lt;code&gt;&quot;\.&quot;&lt;/code&gt; matches just a literal dot, &lt;code&gt;&quot;.&quot;&lt;/code&gt; instead of its normal meaning. This means that the backslash is also a metacharacter, so &lt;code&gt;&quot;\\&quot;&lt;/code&gt; matches a single &lt;code&gt;&quot;\&quot;&lt;/code&gt;. And a sequence that contains an escaped metacharacter matches the same sequence (but without the escape) in the target string. So, the pattern &lt;code&gt;/blur\\fl/&lt;/code&gt; would match any target string that contains the sequence &lt;code&gt;&quot;blur\fl&quot;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b889973d01196115807ed3e24800abe92e6ed58" translate="yes" xml:space="preserve">
          <source>You can change an array element, but you can't change a list element:</source>
          <target state="translated">배열 요소는 변경할 수 있지만 목록 요소는 변경할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="d178a91245c223a6b3d558a26825e4086182ea75" translate="yes" xml:space="preserve">
          <source>You can change both the effective gid and the real gid at the same time by using &lt;code&gt;POSIX::setgid()&lt;/code&gt; (use only a single numeric argument). Changes to &lt;code&gt;$)&lt;/code&gt; require a check to &lt;code&gt;$!&lt;/code&gt; to detect any possible errors after an attempted change.</source>
          <target state="translated">&lt;code&gt;POSIX::setgid()&lt;/code&gt; 를 사용하여 유효 gid와 실제 gid를 동시에 변경할 수 있습니다 (단일 숫자 인수 만 사용). &lt;code&gt;$)&lt;/code&gt; 로 변경하려면 $를 확인해야합니다 &lt;code&gt;$!&lt;/code&gt; 변경 시도 후 가능한 오류를 감지합니다.</target>
        </trans-unit>
        <trans-unit id="59d9719ad7d1133b142fc0ce7a1557db385a25a2" translate="yes" xml:space="preserve">
          <source>You can change both the effective uid and the real uid at the same time by using &lt;code&gt;POSIX::setuid()&lt;/code&gt; . Changes to &lt;code&gt;$&amp;gt;&lt;/code&gt; require a check to &lt;code&gt;$!&lt;/code&gt; to detect any possible errors after an attempted change.</source>
          <target state="translated">&lt;code&gt;POSIX::setuid()&lt;/code&gt; 사용하여 유효 uid와 실제 uid를 동시에 변경할 수 있습니다 . &lt;code&gt;$&amp;gt;&lt;/code&gt; 로 변경하려면 $를 확인해야합니다 &lt;code&gt;$!&lt;/code&gt; 변경 시도 후 가능한 오류를 감지합니다.</target>
        </trans-unit>
        <trans-unit id="5c077fd437c354bc24be98de6cf2487d02c8a685" translate="yes" xml:space="preserve">
          <source>You can change both the effective uid and the real uid at the same time by using &lt;code&gt;POSIX::setuid()&lt;/code&gt;. Changes to &lt;code&gt;$&amp;gt;&lt;/code&gt; require a check to &lt;code&gt;$!&lt;/code&gt; to detect any possible errors after an attempted change.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57121de58d74f1a64c5b126aeda69842259d90c4" translate="yes" xml:space="preserve">
          <source>You can change both the real gid and the effective gid at the same time by using &lt;code&gt;POSIX::setgid()&lt;/code&gt; . Changes to &lt;code&gt;$(&lt;/code&gt; require a check to &lt;code&gt;$!&lt;/code&gt; to detect any possible errors after an attempted change.</source>
          <target state="translated">&lt;code&gt;POSIX::setgid()&lt;/code&gt; 사용하여 실제 gid와 유효 gid를 동시에 변경할 수 있습니다 . 변경 &lt;code&gt;$(&lt;/code&gt; 에 대한 확인이 필요 &lt;code&gt;$!&lt;/code&gt; 시도 후 가능한 오류를 감지 $! 를 .</target>
        </trans-unit>
        <trans-unit id="11e8003bdfd58a10a9ce8d2ff75b8afc3ab5c059" translate="yes" xml:space="preserve">
          <source>You can change both the real gid and the effective gid at the same time by using &lt;code&gt;POSIX::setgid()&lt;/code&gt;. Changes to &lt;code&gt;$(&lt;/code&gt; require a check to &lt;code&gt;$!&lt;/code&gt; to detect any possible errors after an attempted change.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b09c5405e2b602271ef0ef2f3017aa480c6d1079" translate="yes" xml:space="preserve">
          <source>You can change options from</source>
          <target state="translated">에서 옵션을 변경할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="d6315b4e978f53eeff4964ee1909c618fbc90cfa" translate="yes" xml:space="preserve">
          <source>You can change the underlying module that does the low-level math operations by using:</source>
          <target state="translated">다음을 사용하여 저수준 수학 연산을 수행하는 기본 모듈을 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ac0967b2c568b641678650e45e2b539ad81b2c7d" translate="yes" xml:space="preserve">
          <source>You can change this backend library by using:</source>
          <target state="translated">다음을 사용하여이 백엔드 라이브러리를 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e271d7bee0eb9af50859c996a87b147d97ca08b1" translate="yes" xml:space="preserve">
          <source>You can change this by using:</source>
          <target state="translated">다음을 사용하여이를 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a8c0aadd56b5a3424b47f02ac266fd1fef206d7e" translate="yes" xml:space="preserve">
          <source>You can check the values of these variables on your system with</source>
          <target state="translated">시스템에서 이러한 변수의 값을 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="19186d4d2aa107ae87a9009974a30d3e15b94cd1" translate="yes" xml:space="preserve">
          <source>You can choose if you want to always install (yes), never install (no) or be always asked. In the latter case you can set the default answer for the question to yes (ask/yes) or no (ask/no).</source>
          <target state="translated">항상 설치 (yes), 설치 (no) 또는 항상 요청 여부를 선택할 수 있습니다. 후자의 경우 질문에 대한 기본 답변을 yes (ask / yes) 또는 no (ask / no)로 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="432283768bc5fcc2cbc19482faa7326a0cb0200d" translate="yes" xml:space="preserve">
          <source>You can compare $s1 and $s2 above with</source>
          <target state="translated">위의 $ s1과 $ s2를 비교할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5cd28c9babbe3b0c5cce52c7e8b6bd3de247f8a7" translate="yes" xml:space="preserve">
          <source>You can compile a special debugging version of Perl, which allows you to use the &lt;code&gt;-D&lt;/code&gt; option of Perl to tell more about what Perl is doing. But sometimes there is no alternative than to dive in with a debugger, either to see the stack trace of a core dump (very useful in a bug report), or trying to figure out what went wrong before the core dump happened, or how did we end up having wrong or unexpected results.</source>
          <target state="translated">Perl의 특별한 디버깅 버전을 컴파일 할 수 있습니다. &lt;code&gt;-D&lt;/code&gt; 옵션 Perl이 수행하는 작업에 대해 더 자세히 알 수 있습니다. 그러나 때로는 코어 덤프의 스택 추적을 보거나 (버그 보고서에 매우 유용함) 코어 덤프가 발생하기 전에 무엇이 잘못되었는지 또는 어떻게 시도했는지 파악하기 위해 디버거를 사용하는 것 외에 대안이 없습니다. 우리는 잘못되거나 예기치 않은 결과를 얻습니다.</target>
        </trans-unit>
        <trans-unit id="87041007fca4b20217db14f0fb86e591cf75c1a4" translate="yes" xml:space="preserve">
          <source>You can compile perl as a universal binary (built for both ppc and intel). In Mac OS X 10.4 &quot;Tiger&quot;, you must export the 'u' variant of the SDK:</source>
          <target state="translated">perl을 범용 바이너리 (ppc 및 intel 용으로 빌드)로 컴파일 할 수 있습니다. Mac OS X 10.4 &quot;Tiger&quot;에서 SDK의 'u'변형을 내 보내야합니다.</target>
        </trans-unit>
        <trans-unit id="fa58ab427e59cc304b800becf278713e2a473dc4" translate="yes" xml:space="preserve">
          <source>You can compute spherical distances, called &lt;b&gt;great circle distances&lt;/b&gt;, by importing the great_circle_distance() function:</source>
          <target state="translated">&lt;b&gt;큰 원거리&lt;/b&gt; 라고하는 구면 거리를 계산할 수 있습니다&lt;b&gt;&lt;/b&gt;great_circle_distance () 함수를 가져와 .</target>
        </trans-unit>
        <trans-unit id="e0e56eaab18c95d9fc59dbbcb6020dceb739e042" translate="yes" xml:space="preserve">
          <source>You can configure &lt;code&gt;CPAN.pm&lt;/code&gt; to automatically use this option too:</source>
          <target state="translated">&lt;code&gt;CPAN.pm&lt;/code&gt; 을 구성 할 수 있습니다이 옵션도 자동으로 사용 을 .</target>
        </trans-unit>
        <trans-unit id="0a61232f0a79e5aed1425905026fb34cb9f7fecb" translate="yes" xml:space="preserve">
          <source>You can consult &lt;a href=&quot;http://dev.perl.org/perl5&quot;&gt;releases&lt;/a&gt; to determine the current stable release of Perl.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a1c9e7ff6eff00a8559dcb5573a19d0be7a958f" translate="yes" xml:space="preserve">
          <source>You can control the maximum array and hash recursion depths by modifying &lt;code&gt;$Storable::recursion_limit&lt;/code&gt; and &lt;code&gt;$Storable::recursion_limit_hash&lt;/code&gt; respectively. Either can be set to &lt;code&gt;-1&lt;/code&gt; to prevent any depth checks, though this isn't recommended.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f34654d1547e79b58fc6ed76c2c867b2e4c13c5" translate="yes" xml:space="preserve">
          <source>You can control which DBM library you use by loading that library before you call &lt;a href=&quot;#dbmopen-HASH%2CDBNAME%2CMASK&quot;&gt;&lt;code&gt;dbmopen&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d461022ba384996bf77747145dbd16f78eb1d3d" translate="yes" xml:space="preserve">
          <source>You can control which DBM library you use by loading that library before you call dbmopen():</source>
          <target state="translated">dbmopen ()을 호출하기 전에 해당 라이브러리를로드하여 사용하는 DBM 라이브러리를 제어 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b63a08beb712c643691cdd9c1e77329f30769a82" translate="yes" xml:space="preserve">
          <source>You can create endless loops if the things you serialize via freeze() (for instance) point back to the object we're trying to serialize in the hook.</source>
          <target state="translated">예를 들어 freeze ()를 통해 직렬화하는 것이 후크에서 직렬화하려는 객체를 가리키는 경우 무한 루프를 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="adf4a1b481a315cc2b37fc68aeedf4fc3bec4612" translate="yes" xml:space="preserve">
          <source>You can create your own names for characters, and override official ones when using &lt;code&gt;\N{...}&lt;/code&gt;. See &lt;a href=&quot;charnames#CUSTOM-ALIASES&quot;&gt;&quot;CUSTOM ALIASES&quot; in charnames&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="146fea6b6c62fcc84c6add6c6816ffff9347ea9e" translate="yes" xml:space="preserve">
          <source>You can define for all tie types an UNTIE method that will be called at untie(). See &lt;a href=&quot;#The-untie-Gotcha&quot;&gt;&quot;The &lt;code&gt;untie&lt;/code&gt; Gotcha&quot;&lt;/a&gt; below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8cc300aa058401f33bcdc1d74e140c0960d7fa90" translate="yes" xml:space="preserve">
          <source>You can define for all tie types an UNTIE method that will be called at untie(). See &lt;a href=&quot;#The-untie-Gotcha&quot;&gt;The untie Gotcha&lt;/a&gt; below.</source>
          <target state="translated">모든 타이 유형에 대해 untie ()에서 호출 될 UNTIE 메소드를 정의 할 수 있습니다. 아래 &lt;a href=&quot;#The-untie-Gotcha&quot;&gt;의 Untie Gotcha를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="cd22b39009d785c43f4f9453185f24b021494e27" translate="yes" xml:space="preserve">
          <source>You can define your own binary character properties by defining subroutines whose names begin with &lt;code&gt;&quot;In&quot;&lt;/code&gt; or &lt;code&gt;&quot;Is&quot;&lt;/code&gt; . (The experimental feature &lt;a href=&quot;perlre#(%3f%5b-%5d)&quot;&gt;(?[ ]) in perlre&lt;/a&gt; provides an alternative which allows more complex definitions.) The subroutines can be defined in any package. The user-defined properties can be used in the regular expression &lt;code&gt;\p{}&lt;/code&gt; and &lt;code&gt;\P{}&lt;/code&gt; constructs; if you are using a user-defined property from a package other than the one you are in, you must specify its package in the &lt;code&gt;\p{}&lt;/code&gt; or &lt;code&gt;\P{}&lt;/code&gt; construct.</source>
          <target state="translated">이름이 &lt;code&gt;&quot;In&quot;&lt;/code&gt; 또는 &lt;code&gt;&quot;Is&quot;&lt;/code&gt; 로 시작하는 서브 루틴을 정의하여 고유 한 2 진 문자 특성을 정의 할 수 있습니다 . ( &lt;a href=&quot;perlre#(%3f%5b-%5d)&quot;&gt;perlre&lt;/a&gt; 의 실험 기능 (? []) 은 더 복잡한 정의를 허용하는 대안을 제공합니다.) 서브 루틴은 모든 패키지에서 정의 할 수 있습니다. 사용자 정의 특성은 정규식 &lt;code&gt;\p{}&lt;/code&gt; 및 &lt;code&gt;\P{}&lt;/code&gt; 구문 에서 사용할 수 있습니다 . 현재 패키지가 아닌 다른 패키지에서 사용자 정의 속성을 사용하는 경우 &lt;code&gt;\p{}&lt;/code&gt; 또는 &lt;code&gt;\P{}&lt;/code&gt; 구문에 패키지를 지정해야합니다 .</target>
        </trans-unit>
        <trans-unit id="581b021633b88b8ca77368d47883217c97fc358f" translate="yes" xml:space="preserve">
          <source>You can define your own binary character properties by defining subroutines whose names begin with &lt;code&gt;&quot;In&quot;&lt;/code&gt; or &lt;code&gt;&quot;Is&quot;&lt;/code&gt;. (The experimental feature &lt;a href=&quot;perlre#%28%3F%5B-%5D%29&quot;&gt;&quot;(?[ ])&quot; in perlre&lt;/a&gt; provides an alternative which allows more complex definitions.) The subroutines can be defined in any package. They override any Unicode properties expressed as the same names. The user-defined properties can be used in the regular expression &lt;code&gt;\p{}&lt;/code&gt; and &lt;code&gt;\P{}&lt;/code&gt; constructs; if you are using a user-defined property from a package other than the one you are in, you must specify its package in the &lt;code&gt;\p{}&lt;/code&gt; or &lt;code&gt;\P{}&lt;/code&gt; construct.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ea972cce46eda2a3f1a7af312987a64fafa63f8" translate="yes" xml:space="preserve">
          <source>You can define your own character properties and use them in the regular expression with the &lt;code&gt;\p{}&lt;/code&gt; or &lt;code&gt;\P{}&lt;/code&gt; construct. See &lt;a href=&quot;#User-Defined-Character-Properties&quot;&gt;&quot;User-Defined Character Properties&quot;&lt;/a&gt; for more details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="107745b2e3d0c30dbe6a28beb79e3db6db75115c" translate="yes" xml:space="preserve">
          <source>You can define your own character properties and use them in the regular expression with the &lt;code&gt;\p{}&lt;/code&gt; or &lt;code&gt;\P{}&lt;/code&gt; construct. See &lt;a href=&quot;#User-Defined-Character-Properties&quot;&gt;User-Defined Character Properties&lt;/a&gt; for more details.</source>
          <target state="translated">&lt;code&gt;\p{}&lt;/code&gt; 또는 &lt;code&gt;\P{}&lt;/code&gt; 구문을 사용하여 고유 한 문자 속성을 정의하고 정규식에서 사용할 수 있습니다 . 자세한 내용은 &lt;a href=&quot;#User-Defined-Character-Properties&quot;&gt;사용자 정의 문자 속성&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="d07e5c5285c0856948c6976c6c8552f314a8bd96" translate="yes" xml:space="preserve">
          <source>You can define your own custom character classes, by putting into your pattern in the appropriate place(s), a list of all the characters you want in the set. You do this by enclosing the list within &lt;code&gt;[]&lt;/code&gt; bracket characters. These are called &quot;bracketed character classes&quot; when we are being precise, but often the word &quot;bracketed&quot; is dropped. (Dropping it usually doesn't cause confusion.) This means that the &lt;code&gt;&quot;[&quot;&lt;/code&gt; character is another metacharacter. It doesn't match anything just by itself; it is used only to tell Perl that what follows it is a bracketed character class. If you want to match a literal left square bracket, you must escape it, like &lt;code&gt;&quot;\[&quot;&lt;/code&gt;. The matching &lt;code&gt;&quot;]&quot;&lt;/code&gt; is also a metacharacter; again it doesn't match anything by itself, but just marks the end of your custom class to Perl. It is an example of a &quot;sometimes metacharacter&quot;. It isn't a metacharacter if there is no corresponding &lt;code&gt;&quot;[&quot;&lt;/code&gt;, and matches its literal self:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9472dcd36f94375050dea75545931297e23f500b" translate="yes" xml:space="preserve">
          <source>You can detect the OS mode using &quot;isainfo -v&quot;, e.g.</source>
          <target state="translated">&quot;isainfo -v&quot;를 사용하여 OS 모드를 감지 할 수 있습니다. 예 :</target>
        </trans-unit>
        <trans-unit id="ac56709f3e046a38d3f4f58f4d03fe93d1a1a7f4" translate="yes" xml:space="preserve">
          <source>You can determine your system endianness with this incantation:</source>
          <target state="translated">이 주문으로 시스템 엔디안을 결정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d720ebfa9c94db62cff235f1fc566ea523fe6220" translate="yes" xml:space="preserve">
          <source>You can directly disable thread support with one of the following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e10ee4faf1824e9c84d1fdce76b93c2ae5f9fd0" translate="yes" xml:space="preserve">
          <source>You can disable &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos()&lt;/a&gt;&lt;/code&gt; resets on fail with the &lt;code&gt;c&lt;/code&gt; flag, documented in &lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt; and &lt;a href=&quot;perlreref&quot;&gt;perlreref&lt;/a&gt;. Subsequent matches start where the last successful match ended (the value of &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos()&lt;/a&gt;&lt;/code&gt;) even if a match on the same string has failed in the meantime. In this case, the match after the &lt;code&gt;while()&lt;/code&gt; loop starts at the &lt;code&gt;a&lt;/code&gt; (where the last match stopped), and since it does not use any anchor it can skip over the &lt;code&gt;a&lt;/code&gt; to find &lt;code&gt;44&lt;/code&gt; .</source>
          <target state="translated">&lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt; 및 &lt;a href=&quot;perlreref&quot;&gt;perlreref에&lt;/a&gt; 문서화 된 &lt;code&gt;c&lt;/code&gt; 플래그를 사용하여 실패시 &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos()&lt;/a&gt;&lt;/code&gt; 재설정을 비활성화 할 수 있습니다 . 이후에 일치 하는 문자열은 일치하는 문자열이 일치하지 않더라도 마지막으로 성공한 일치가 종료 된 &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos()&lt;/a&gt;&lt;/code&gt; 값 )에서 시작됩니다. 이 경우 &lt;code&gt;while()&lt;/code&gt; 루프 이후의 일치 는 &lt;code&gt;a&lt;/code&gt; (마지막 일치가 중지 된 위치) 에서 시작하며 앵커를 사용하지 않으므로 &lt;code&gt;a&lt;/code&gt; 를 건너 뛰어 &lt;code&gt;44&lt;/code&gt; 를 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="762ba82b0f7c5bd42e2bb3f028578d05bfa6f570" translate="yes" xml:space="preserve">
          <source>You can disable &lt;code&gt;pos()&lt;/code&gt; resets on fail with the &lt;code&gt;c&lt;/code&gt; modifier, documented in &lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt; and &lt;a href=&quot;perlreref&quot;&gt;perlreref&lt;/a&gt;. Subsequent matches start where the last successful match ended (the value of &lt;code&gt;pos()&lt;/code&gt;) even if a match on the same string has failed in the meantime. In this case, the match after the &lt;code&gt;while()&lt;/code&gt; loop starts at the &lt;code&gt;a&lt;/code&gt; (where the last match stopped), and since it does not use any anchor it can skip over the &lt;code&gt;a&lt;/code&gt; to find &lt;code&gt;44&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="458912b1d0d0c5a77d13c3e7ffc4ddad22f59daf" translate="yes" xml:space="preserve">
          <source>You can dispense with numbers altogether and create named capture groups. The notation is &lt;code&gt;(?&amp;lt;&lt;i&gt;name&lt;/i&gt;&amp;gt;...)&lt;/code&gt; to declare and &lt;code&gt;\g{&lt;i&gt;name&lt;/i&gt;}&lt;/code&gt; to reference. (To be compatible with .Net regular expressions, &lt;code&gt;\g{&lt;i&gt;name&lt;/i&gt;}&lt;/code&gt; may also be written as &lt;code&gt;\k{&lt;i&gt;name&lt;/i&gt;}&lt;/code&gt;, &lt;code&gt;\k&amp;lt;&lt;i&gt;name&lt;/i&gt;&amp;gt;&lt;/code&gt; or &lt;code&gt;\k'&lt;i&gt;name&lt;/i&gt;'&lt;/code&gt;.)</source>
          <target state="translated">숫자를 모두 사용하지 않고 명명 된 캡처 그룹을 만들 수 있습니다. 표기법은 &lt;code&gt;(?&amp;lt;&lt;i&gt;name&lt;/i&gt;&amp;gt;...)&lt;/code&gt; 로 선언하고 &lt;code&gt;\g{&lt;i&gt;name&lt;/i&gt;}&lt;/code&gt; 으로 참조합니다. .Net 정규식과 호환되도록 &lt;code&gt;\g{&lt;i&gt;name&lt;/i&gt;}&lt;/code&gt; 을 &lt;code&gt;\k{&lt;i&gt;name&lt;/i&gt;}&lt;/code&gt; , &lt;code&gt;\k&amp;lt;&lt;i&gt;name&lt;/i&gt;&amp;gt;&lt;/code&gt; 또는 &lt;code&gt;\k'&lt;i&gt;name&lt;/i&gt;'&lt;/code&gt; 으로 쓸 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b18d3c8d444331784ad87d0c9066604ce83188e2" translate="yes" xml:space="preserve">
          <source>You can do a similar thing with the value of &lt;code&gt;$0&lt;/code&gt; , which holds the script name. That might hold a relative path, but &lt;code&gt;rel2abs&lt;/code&gt; can turn it into an absolute path. Once you have the</source>
          <target state="translated">스크립트 이름을 보유하는 &lt;code&gt;$0&lt;/code&gt; 값으로 비슷한 작업을 수행 할 수 있습니다 . 그것은 상대 경로를 &lt;code&gt;rel2abs&lt;/code&gt; 수 있지만 rel2abs 는 절대 경로로 바꿀 수 있습니다. 일단 당신이</target>
        </trans-unit>
        <trans-unit id="708b113fd606c824d990b531e5ec634fa7999b38" translate="yes" xml:space="preserve">
          <source>You can do a similar thing with the value of &lt;code&gt;$0&lt;/code&gt;, which holds the script name. That might hold a relative path, but &lt;code&gt;rel2abs&lt;/code&gt; can turn it into an absolute path. Once you have the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2cb0b5304ad3a2505b033f6205316fe91cd8667f" translate="yes" xml:space="preserve">
          <source>You can do it yourself:</source>
          <target state="translated">당신은 스스로 할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="3df3594ac830b3b367e2449531bc9481e6c2c743" translate="yes" xml:space="preserve">
          <source>You can do some customization by setting up a</source>
          <target state="translated">당신은 설정하여 일부 사용자 정의를 수행 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="e36b0a11441d7f370d1c8f3b9a2c5df0ed14fec0" translate="yes" xml:space="preserve">
          <source>You can do the same thing with foreach and a match using the c flag and the \G anchor, if you do not mind your entire file being in memory at the end.</source>
          <target state="translated">전체 파일이 메모리에 있다는 것을 신경 쓰지 않으면 c 플래그와 \ G 앵커를 사용하여 foreach 및 match와 동일한 작업을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="94475bd1aa00e25358f732725451e1c48c0023a3" translate="yes" xml:space="preserve">
          <source>You can do this by filtering a list of &lt;code&gt;Archive::Tar::File&lt;/code&gt; objects based on your criteria. For example, to extract only files that have the string &lt;code&gt;foo&lt;/code&gt; in their title, you would use:</source>
          <target state="translated">기준에 따라 &lt;code&gt;Archive::Tar::File&lt;/code&gt; 객체 목록을 필터링하여이 작업을 수행 할 수 있습니다 . 예를 들어 제목에 문자열 &lt;code&gt;foo&lt;/code&gt; 가있는 파일 만 추출 하려면 다음을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="e3b58ea141bf0b2ab8308eba04e2fe1187709b38" translate="yes" xml:space="preserve">
          <source>You can do this in</source>
          <target state="translated">당신은 이것을 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="0e82d2d4c5fee3c3455ee13c93472ac8305c2886" translate="yes" xml:space="preserve">
          <source>You can do various useful things to lists:</source>
          <target state="translated">다음과 같은 다양한 유용한 작업을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2293c83d7e9f41c388c0c9ef674c18441a39f91a" translate="yes" xml:space="preserve">
          <source>You can download the NDK from &lt;a href=&quot;http://developer.blackberry.com/native/downloads/&quot;&gt;http://developer.blackberry.com/native/downloads/&lt;/a&gt;.</source>
          <target state="translated">NDK는 &lt;a href=&quot;http://developer.blackberry.com/native/downloads/&quot;&gt;http://developer.blackberry.com/native/downloads/&lt;/a&gt; 에서 다운로드 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ccab4c9ebd3c859889355271883dcf42caad69df" translate="yes" xml:space="preserve">
          <source>You can download the NDK from &lt;a href=&quot;https://developer.android.com/tools/sdk/ndk/index.html&quot;&gt;https://developer.android.com/tools/sdk/ndk/index.html&lt;/a&gt;. You'll want the normal, non-legacy version.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34382fbd280654c58cbfc9d0110d2c77f2d872d7" translate="yes" xml:space="preserve">
          <source>You can easily do this yourself too by checking each level of the hash before you move onto the next level. This is essentially what &lt;a href=&quot;Data::Diver&quot;&gt;Data::Diver&lt;/a&gt; does for you:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2add1e5f384d4e366c7f0bda81dca221784f796a" translate="yes" xml:space="preserve">
          <source>You can easily do this yourself too by checking each level of the hash before you move onto the next level. This is essentially what &lt;a href=&quot;http://search.cpan.org/perldoc/Data::Diver&quot;&gt;Data::Diver&lt;/a&gt; does for you:</source>
          <target state="translated">다음 레벨로 넘어 가기 전에 해시의 각 레벨을 확인하여 쉽게이 작업을 수행 할 수 있습니다. 이것은 본질적으로 &lt;a href=&quot;http://search.cpan.org/perldoc/Data::Diver&quot;&gt;Data :: Diver&lt;/a&gt; 가 당신을 위해하는 일입니다.</target>
        </trans-unit>
        <trans-unit id="aca937c9b8249ef74f6bdd2a2c24ef2b2c942c33" translate="yes" xml:space="preserve">
          <source>You can effect a sleep of 250 milliseconds this way:</source>
          <target state="translated">이런 식으로 250 밀리 초의 절전 모드를 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2cf03e7d8c028c108e1f07b9fdfd93ec5a0911cb" translate="yes" xml:space="preserve">
          <source>You can either get the latest perl-for-amiga source from Ninemoons and extract it with:</source>
          <target state="translated">Ninemoons에서 최신 perl-for-amiga 소스를 가져 와서 다음과 같이 추출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dc1b686bd86f9825c512e3b19e24ca27d9b0e88c" translate="yes" xml:space="preserve">
          <source>You can embed Pod documentation in your Perl modules and scripts. Start your documentation with an empty line, a &quot;=head1&quot; command at the beginning, and end it with a &quot;=cut&quot; command and an empty line. The &lt;b&gt;perl&lt;/b&gt; executable will ignore the Pod text. You can place a Pod statement where &lt;b&gt;perl&lt;/b&gt; expects the beginning of a new statement, but not within a statement, as that would result in an error. See any of the supplied library modules for examples.</source>
          <target state="translated">Perl 모듈 및 스크립트에 포드 설명서를 포함시킬 수 있습니다. 빈 줄, 시작 부분에 &quot;= head1&quot;명령으로 문서를 시작하고 &quot;= cut&quot;명령 및 빈 줄로 끝냅니다. 그만큼&lt;b&gt;펄&lt;/b&gt; 실행 파일은 포드 텍스트를 무시합니다. &lt;b&gt;Perl&lt;/b&gt; 이 새 명령문의 시작을 예상하지만 명령문 내에는 오류가 발생할 수있는 포드 명령문을 배치 할 수 있습니다 . 예제는 제공된 라이브러리 모듈을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="4e8901a24d5203f278555dd6630e84e6495d5c32" translate="yes" xml:space="preserve">
          <source>You can enable automatic UTF-8-ification of your standard file handles, default &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; layer, and &lt;code&gt;@ARGV&lt;/code&gt; by using either the &lt;code&gt;-C&lt;/code&gt; command line switch or the &lt;code&gt;PERL_UNICODE&lt;/code&gt; environment variable, see &lt;a href=&quot;perlrun&quot;&gt;perlrun&lt;/a&gt; for the documentation of the &lt;code&gt;-C&lt;/code&gt; switch.</source>
          <target state="translated">당신은 표준 파일 핸들을 자동으로 UTF-8-ification 수 있도록 기본 수 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; 층 및 &lt;code&gt;@ARGV&lt;/code&gt; 을 중 하나를 사용하여 &lt;code&gt;-C&lt;/code&gt; 명령 줄 스위치 또는 &lt;code&gt;PERL_UNICODE&lt;/code&gt; 의 환경 변수를 참조 &lt;a href=&quot;perlrun&quot;&gt;perlrun&lt;/a&gt; 의 문서에 대한 &lt;code&gt;-C&lt;/code&gt; 스위치.</target>
        </trans-unit>
        <trans-unit id="82c6bb69edc2a1dcc5ef223d908dad512d68780d" translate="yes" xml:space="preserve">
          <source>You can enable automatic UTF-8-ification of your standard file handles, default &lt;code&gt;open()&lt;/code&gt; layer, and &lt;code&gt;@ARGV&lt;/code&gt; by using either the &lt;code&gt;-C&lt;/code&gt; command line switch or the &lt;code&gt;PERL_UNICODE&lt;/code&gt; environment variable, see &lt;a href=&quot;perlrun#-C-%5Bnumber%2Flist%5D&quot;&gt;perlrun&lt;/a&gt; for the documentation of the &lt;code&gt;-C&lt;/code&gt; switch.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b7d65e57af61c849fd344c325e8ff8558b6ea76" translate="yes" xml:space="preserve">
          <source>You can enable this program wide by setting the package variable &lt;code&gt;$Params::Check::VERBOSE&lt;/code&gt; to a true value. For details, see the section on &lt;code&gt;Global Variables&lt;/code&gt; below.</source>
          <target state="translated">패키지 변수 &lt;code&gt;$Params::Check::VERBOSE&lt;/code&gt; 를 true 값 으로 설정하여이 프로그램 전체를 사용할 수 있습니다 . 자세한 내용은 아래 &lt;code&gt;Global Variables&lt;/code&gt; 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="bd9f5fdd175da39fdf1b2aee95117b6f24089729" translate="yes" xml:space="preserve">
          <source>You can even add a line to the beginning of a file, since the current line prints at the end of the loop:</source>
          <target state="translated">현재 줄이 루프의 끝에 인쇄되기 때문에 파일의 시작 부분에 줄을 추가 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="469cbe63338eb0799dde10314ea7997fd8799ab7" translate="yes" xml:space="preserve">
          <source>You can even chain the operations together as usual:</source>
          <target state="translated">평소와 같이 작업을 함께 연결할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="2aadc431d196d9bef8923dcadb3a5f0c2d7f67b9" translate="yes" xml:space="preserve">
          <source>You can even set them to pipe commands. For example, this automatically filters compressed arguments through &lt;b&gt;gzip&lt;/b&gt;:</source>
          <target state="translated">파이프 명령으로 설정할 수도 있습니다. 예를 들어, &lt;b&gt;gzip을&lt;/b&gt; 통해 압축 된 인수를 자동으로 필터링합니다 .</target>
        </trans-unit>
        <trans-unit id="5959df3dd95aca5e6820f2cd7c4389121f214d69" translate="yes" xml:space="preserve">
          <source>You can examine the @INC variable from within a perl program to see the order in which Perl searches these directories.</source>
          <target state="translated">Perl 프로그램 내에서 @INC 변수를 검사하여 Perl이이 디렉토리를 검색하는 순서를 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b4227d7f6f90687ed1f952d3300efda038a669dd" translate="yes" xml:space="preserve">
          <source>You can examine your last commit with:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b698e2e22416ac9eb31f0b1d16a0dd9b5e075ed0" translate="yes" xml:space="preserve">
          <source>You can expand the macros in a</source>
          <target state="translated">에서 매크로를 확장 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="c6984ea0cc547a7d94d70f8b198039214ca8c15f" translate="yes" xml:space="preserve">
          <source>You can explore the endianness of your platform by unpacking a data structure packed in native format such as:</source>
          <target state="translated">다음과 같은 기본 형식으로 압축 된 데이터 구조를 풀면 플랫폼의 엔디안을 탐색 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="25084ad020c81115ae6c13e15f94c38c747b7c70" translate="yes" xml:space="preserve">
          <source>You can explore various information from the Unicode data files using the &lt;code&gt;Unicode::UCD&lt;/code&gt; module.</source>
          <target state="translated">&lt;code&gt;Unicode::UCD&lt;/code&gt; 모듈을 사용하여 유니 코드 데이터 파일에서 다양한 정보를 탐색 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="214226a1ed44146fabbcdf1d7ff955aea72e1c83" translate="yes" xml:space="preserve">
          <source>You can extend the data conversion shortcuts menu, so for example you can display an SV's IV value with one click, without doing any typing. To do that simply edit ~/.ddd/init file and add after:</source>
          <target state="translated">데이터 변환 바로 가기 메뉴를 확장 할 수 있으므로 예를 들어 입력하지 않고도 한 번의 클릭으로 SV의 IV 값을 표시 할 수 있습니다. 그렇게하려면 ~ / .ddd / init 파일을 편집 한 후 다음을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="9f3b19dace5e1ee6e80db897c83810c886662b0c" translate="yes" xml:space="preserve">
          <source>You can fake a static variable by using a lexical variable which goes out of scope. In this example, you define the subroutine &lt;code&gt;counter&lt;/code&gt; , and it uses the lexical variable &lt;code&gt;$count&lt;/code&gt; . Since you wrap this in a BEGIN block, &lt;code&gt;$count&lt;/code&gt; is defined at compile-time, but also goes out of scope at the end of the BEGIN block. The BEGIN block also ensures that the subroutine and the value it uses is defined at compile-time so the subroutine is ready to use just like any other subroutine, and you can put this code in the same place as other subroutines in the program text (i.e. at the end of the code, typically). The subroutine &lt;code&gt;counter&lt;/code&gt; still has a reference to the data, and is the only way you can access the value (and each time you do, you increment the value). The data in chunk of memory defined by &lt;code&gt;$count&lt;/code&gt; is private to &lt;code&gt;counter&lt;/code&gt; .</source>
          <target state="translated">범위를 벗어난 어휘 변수를 사용하여 정적 변수를 위조 할 수 있습니다. 이 예에서는 서브 루틴 &lt;code&gt;counter&lt;/code&gt; 를 정의 하고 어휘 변수 &lt;code&gt;$count&lt;/code&gt; 사용합니다 . 이것을 BEGIN 블록으로 래핑하기 때문에 &lt;code&gt;$count&lt;/code&gt; 는 컴파일 타임에 정의되지만 BEGIN 블록의 끝에서는 범위를 벗어납니다. BEGIN 블록은 또한 서브 루틴과 그 서브 루틴이 사용하는 값이 컴파일 타임에 정의되도록하여 서브 루틴이 다른 서브 루틴과 마찬가지로 사용할 수 있도록 준비하고,이 코드를 프로그램 텍스트의 다른 서브 루틴과 같은 곳에 배치 할 수 있습니다 ( 즉, 코드 끝에서) 서브 루틴 &lt;code&gt;counter&lt;/code&gt; 여전히 데이터에 대한 참조가 있으며 값에 액세스 할 수있는 유일한 방법입니다 (할 때마다 값을 증가시킵니다). &lt;code&gt;$count&lt;/code&gt; 의해 정의 된 메모리 청크의 데이터는 &lt;code&gt;counter&lt;/code&gt; 전용 입니다.</target>
        </trans-unit>
        <trans-unit id="d87a4ece96c240d1ec10cdcea1f450090af5432d" translate="yes" xml:space="preserve">
          <source>You can fake a static variable by using a lexical variable which goes out of scope. In this example, you define the subroutine &lt;code&gt;counter&lt;/code&gt;, and it uses the lexical variable &lt;code&gt;$count&lt;/code&gt;. Since you wrap this in a BEGIN block, &lt;code&gt;$count&lt;/code&gt; is defined at compile-time, but also goes out of scope at the end of the BEGIN block. The BEGIN block also ensures that the subroutine and the value it uses is defined at compile-time so the subroutine is ready to use just like any other subroutine, and you can put this code in the same place as other subroutines in the program text (i.e. at the end of the code, typically). The subroutine &lt;code&gt;counter&lt;/code&gt; still has a reference to the data, and is the only way you can access the value (and each time you do, you increment the value). The data in chunk of memory defined by &lt;code&gt;$count&lt;/code&gt; is private to &lt;code&gt;counter&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98bfa69a23c16121bcf7918a14cd66f9c3c6d27f" translate="yes" xml:space="preserve">
          <source>You can find documentation for this module with the perldoc command.</source>
          <target state="translated">perldoc 명령으로이 모듈에 대한 문서를 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2ec893daacd3a612f16b5ff8e3b0ca737de8a9f5" translate="yes" xml:space="preserve">
          <source>You can find more info about Configure's command line switches in the</source>
          <target state="translated">Configure의 명령 행 스위치에 대한 자세한 정보는</target>
        </trans-unit>
        <trans-unit id="60d30b2a5683150ee021b2d2efe823e684b28b49" translate="yes" xml:space="preserve">
          <source>You can find out whether Perl considers &quot;long double&quot; to be the default floating-point size to use on your platform via &lt;a href=&quot;../config&quot;&gt;Config&lt;/a&gt;:</source>
          <target state="translated">Perl이 &quot;long double&quot;을 &lt;a href=&quot;../config&quot;&gt;Config&lt;/a&gt; 를 통해 플랫폼에서 사용할 기본 부동 소수점 크기로 간주하는지 여부를 확인할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0a14665644553d1c1ca40b3a369c0cfc1687919b" translate="yes" xml:space="preserve">
          <source>You can find out whether Perl considers &quot;long double&quot; to be the default floating-point size to use on your platform via &lt;a href=&quot;config&quot;&gt;Config&lt;/a&gt;:</source>
          <target state="translated">Perl이 &quot;long double&quot;을 &lt;a href=&quot;config&quot;&gt;Config&lt;/a&gt; 를 통해 플랫폼에서 사용할 기본 부동 소수점 크기로 간주하는지 여부를 확인할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a8c0376796b23fff5ec186fab67f5500801dd3ed" translate="yes" xml:space="preserve">
          <source>You can find out whether your Perl supports quads via &lt;a href=&quot;../config&quot;&gt;Config&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;../config&quot;&gt;Config&lt;/a&gt; 를 통해 Perl이 쿼드를 지원하는지 확인할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="977c50ef8718482d8b17abe375d1697e8f9a2d66" translate="yes" xml:space="preserve">
          <source>You can find out whether your Perl supports quads via &lt;a href=&quot;config&quot;&gt;Config&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;config&quot;&gt;Config&lt;/a&gt; 를 통해 Perl이 쿼드를 지원하는지 확인할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="58566ff87e227e47e0a6175cb880b0492ff07d0d" translate="yes" xml:space="preserve">
          <source>You can find the bytes that make up a UTF-8 sequence with</source>
          <target state="translated">UTF-8 시퀀스를 구성하는 바이트를 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d66bda1e5630ce31a16d647268de04ca99f2d093" translate="yes" xml:space="preserve">
          <source>You can find the full DJGPP distribution on any of the mirrors listed here:</source>
          <target state="translated">여기에 나열된 미러에서 전체 DJGPP 배포를 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="53a7bd12f9a84d4d155f8bc43066fe15624ba305" translate="yes" xml:space="preserve">
          <source>You can find them for example by</source>
          <target state="translated">예를 들어</target>
        </trans-unit>
        <trans-unit id="abd3b038a5876faa8d912c01ba340b1b8ceaabfa" translate="yes" xml:space="preserve">
          <source>You can follow the formats with numbers to say how many characters should be affected by that format: &lt;code&gt;A12&lt;/code&gt; means &quot;take 12 characters&quot;; &lt;code&gt;x6&lt;/code&gt; means &quot;skip 6 bytes&quot; or &quot;character 0, 6 times&quot;.</source>
          <target state="translated">숫자로 된 형식을 따라 해당 형식의 영향을받는 문자 수를 말할 수 있습니다. &lt;code&gt;A12&lt;/code&gt; 는 &quot;12 자 사용&quot;을 의미합니다. &lt;code&gt;x6&lt;/code&gt; 은 &quot;6 바이트 건너 뛰기&quot;또는 &quot;문자 0, 6 회&quot;를 의미합니다.</target>
        </trans-unit>
        <trans-unit id="3e5ffde15ed2080164a5592bd7bb881aeab7fa67" translate="yes" xml:space="preserve">
          <source>You can force Perl to interpret the bareword as a class name by appending &quot;::&quot; to it, like we saw earlier:</source>
          <target state="translated">앞에서 본 것처럼 &quot;::&quot;를 추가하여 Perl이 기본 단어를 클래스 이름으로 해석하도록 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6a0f7fd6c71d8ef00acad73e562310bfdc7188b5" translate="yes" xml:space="preserve">
          <source>You can force Perl to use the first interpretation (i.e. as a method call on the class named &quot;Class&quot;) in two ways. First, you can append a &lt;code&gt;::&lt;/code&gt; to the class name:</source>
          <target state="translated">Perl이 두 가지 방식으로 첫 번째 해석 (즉, &quot;Class&quot;라는 클래스의 메소드 호출)을 사용하도록 할 수 있습니다. 먼저 클래스 이름에 &lt;code&gt;::&lt;/code&gt; 를 추가 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3683b364293548110b32df191aa4769c6b0d7861" translate="yes" xml:space="preserve">
          <source>You can force a backreference interpretation always by using the &lt;code&gt;\g{...}&lt;/code&gt; form. You can the force an octal interpretation always by using the &lt;code&gt;\o{...}&lt;/code&gt; form, or for numbers up through \077 (= 63 decimal), by using three digits, beginning with a &quot;0&quot;.</source>
          <target state="translated">&lt;code&gt;\g{...}&lt;/code&gt; 양식 을 사용하여 역 참조 해석을 항상 강제 할 수 있습니다 . &lt;code&gt;\o{...}&lt;/code&gt; 형식을 사용하거나 &quot;0&quot;으로 시작하는 세 자리 숫자를 사용하여 \ 077 (= 10 진수 63)까지의 숫자 를 사용하여 8 진 해석을 강제로 적용 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b877192684c9091db1ed512a1471d2f292aa330b" translate="yes" xml:space="preserve">
          <source>You can force an SV to make its own copy of its string buffer by calling &lt;code&gt;sv_force_normal(sv)&lt;/code&gt; or SvPV_force_nolen(sv).</source>
          <target state="translated">&lt;code&gt;sv_force_normal(sv)&lt;/code&gt; 또는 SvPV_force_nolen (sv) 를 호출하여 SV가 자체 문자열 버퍼 사본을 만들도록 강제 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="17a663e3d7a25b5bda8c7ec8fa9aff0d95066f73" translate="yes" xml:space="preserve">
          <source>You can force the thread-safe locale operations to always be used (if available) by recompiling perl with</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e323a2944066f4acfe2875190557e817154e971" translate="yes" xml:space="preserve">
          <source>You can force the type to be a JSON number by numifying it:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99a383c28a991c1f9ed0ee28b1f5306a152b1497" translate="yes" xml:space="preserve">
          <source>You can force the type to be a JSON string by stringifying it:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59bd5097130055276750c2a4628acf949f4c2e6b" translate="yes" xml:space="preserve">
          <source>You can get a precompiled version of gcc from &lt;a href=&quot;http://www.sunfreeware.com/&quot;&gt;http://www.sunfreeware.com/&lt;/a&gt; or &lt;a href=&quot;http://www.blastwave.org/&quot;&gt;http://www.blastwave.org/&lt;/a&gt;. Make sure you pick up the package for your Solaris release.</source>
          <target state="translated">&lt;a href=&quot;http://www.sunfreeware.com/&quot;&gt;http://www.sunfreeware.com/&lt;/a&gt; 또는 &lt;a href=&quot;http://www.blastwave.org/&quot;&gt;http://www.blastwave.org/&lt;/a&gt; 에서 사전 컴파일 된 gcc 버전을 얻을 수 있습니다 . Solaris 릴리스 용 패키지를 선택하십시오.</target>
        </trans-unit>
        <trans-unit id="6c43b7d416e3df44e0ee3889ce9e7a7e5b755245" translate="yes" xml:space="preserve">
          <source>You can get an overview of all the files with this command:</source>
          <target state="translated">이 명령으로 모든 파일에 대한 개요를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a325b2e4941194b844aaba1d34803d7f10c46f65" translate="yes" xml:space="preserve">
          <source>You can get and set the current length of the string stored in an SV with the following macros:</source>
          <target state="translated">다음 매크로를 사용하여 SV에 저장된 문자열의 현재 길이를 가져오고 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="498e28fc3884e7bafa55f40835a491ab14376104" translate="yes" xml:space="preserve">
          <source>You can get around this in several ways depending on our situation. First, if you don't want any of the characters in the string to be special, you can escape them with &lt;code&gt;&lt;a href=&quot;functions/quotemeta&quot;&gt;quotemeta&lt;/a&gt;&lt;/code&gt; before you use the string.</source>
          <target state="translated">상황에 따라 여러 가지 방법으로이 문제를 해결할 수 있습니다. 먼저 문자열의 문자 중 특수 문자를 원하지 않으면 문자열을 사용하기 전에 &lt;code&gt;&lt;a href=&quot;functions/quotemeta&quot;&gt;quotemeta&lt;/a&gt;&lt;/code&gt; 로 이스케이프 처리 할 수 ​​있습니다 .</target>
        </trans-unit>
        <trans-unit id="907671da7c158c5e53cf7c4009f169bdae8b7e54" translate="yes" xml:space="preserve">
          <source>You can get around this in several ways depending on our situation. First, if you don't want any of the characters in the string to be special, you can escape them with &lt;code&gt;quotemeta&lt;/code&gt; before you use the string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2880274dc7c0ec586da21bf05619e960d62718ce" translate="yes" xml:space="preserve">
          <source>You can get at any of these quantities from C very easily; just add &lt;code&gt;Sv&lt;/code&gt; to the name of the field shown in the snippet, and you've got a macro which will return the value: &lt;code&gt;SvCUR(sv)&lt;/code&gt; returns the current length of the string, &lt;code&gt;SvREFCOUNT(sv)&lt;/code&gt; returns the reference count, &lt;code&gt;SvPV(sv, len)&lt;/code&gt; returns the string itself with its length, and so on. More macros to manipulate these properties can be found in &lt;a href=&quot;perlguts&quot;&gt;perlguts&lt;/a&gt;.</source>
          <target state="translated">C에서 이러한 수량을 매우 쉽게 얻을 수 있습니다. 스 니펫에 표시된 필드 이름에 &lt;code&gt;Sv&lt;/code&gt; 를 추가 하면 값을 반환하는 매크로가 있습니다. &lt;code&gt;SvCUR(sv)&lt;/code&gt; 는 문자열의 현재 길이를 반환하고 &lt;code&gt;SvREFCOUNT(sv)&lt;/code&gt; 는 참조 카운트를 반환합니다. &lt;code&gt;SvPV(sv, len)&lt;/code&gt; 은 문자열 자체의 길이 등을 반환합니다. 이러한 속성을 조작하는 더 많은 매크로는 &lt;a href=&quot;perlguts&quot;&gt;perlguts&lt;/a&gt; 에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="98610d953793b8d3a809dccac32eb0df790fe7b6" translate="yes" xml:space="preserve">
          <source>You can get at lists of keys and values with &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys()&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/values&quot;&gt;values()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys()&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;functions/values&quot;&gt;values()&lt;/a&gt;&lt;/code&gt; 로 키와 값 목록을 얻을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="bfa837955bc2111631d4644a0aa1c41fcffdf11c" translate="yes" xml:space="preserve">
          <source>You can get at lists of keys and values with &lt;code&gt;keys()&lt;/code&gt; and &lt;code&gt;values()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55a77b36211d3d02a45104bff8d76788cd986acc" translate="yes" xml:space="preserve">
          <source>You can get commercial support of Perl if you wish, although for most users the informal support will more than suffice. See the answer to &quot;Where can I buy a commercial version of Perl?&quot; for more information.</source>
          <target state="translated">대부분의 사용자에게는 비공식적 인 지원만으로 충분하지만 원하는 경우 Perl에 대한 상업적 지원을받을 수 있습니다. &quot;Perl의 상용 버전은 어디에서 구입할 수 있습니까?&quot;에 대한 답변을 참조하십시오. 자세한 내용은.</target>
        </trans-unit>
        <trans-unit id="83877e131c38375e988c7edf4defa59ad28286ba" translate="yes" xml:space="preserve">
          <source>You can get gzip from &lt;a href=&quot;ftp://prep.ai.mit.edu/pub/gnu/&quot;&gt;ftp://prep.ai.mit.edu/pub/gnu/&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;ftp://prep.ai.mit.edu/pub/gnu/&quot;&gt;ftp://prep.ai.mit.edu/pub/gnu/&lt;/a&gt; 에서 gzip을 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5cc7caff36ea8191fb948cb25382a0802d8b70e3" translate="yes" xml:space="preserve">
          <source>You can get gzip from &lt;a href=&quot;http://www.s390.ibm.com/products/oe/bpxqp1.html&quot;&gt;http://www.s390.ibm.com/products/oe/bpxqp1.html&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;http://www.s390.ibm.com/products/oe/bpxqp1.html&quot;&gt;http://www.s390.ibm.com/products/oe/bpxqp1.html&lt;/a&gt; 에서 gzip을 얻을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ceb45063df183ed03ff063ebe2021495fbb9baff" translate="yes" xml:space="preserve">
          <source>You can get into trouble if you use constants in a context which automatically quotes barewords (as is true for any subroutine call). For example, you can't say &lt;code&gt;$hash{CONSTANT}&lt;/code&gt; because &lt;code&gt;CONSTANT&lt;/code&gt; will be interpreted as a string. Use &lt;code&gt;$hash{CONSTANT()}&lt;/code&gt; or &lt;code&gt;$hash{+CONSTANT}&lt;/code&gt; to prevent the bareword quoting mechanism from kicking in. Similarly, since the &lt;code&gt;=&amp;gt;&lt;/code&gt; operator quotes a bareword immediately to its left, you have to say &lt;code&gt;CONSTANT() =&amp;gt; 'value'&lt;/code&gt; (or simply use a comma in place of the big arrow) instead of &lt;code&gt;CONSTANT =&amp;gt; 'value'&lt;/code&gt; .</source>
          <target state="translated">하위 단어를 자동으로 인용하는 컨텍스트에서 상수를 사용하면 문제가 발생할 수 있습니다 (서브 루틴 호출의 경우와 동일). 예를 들어, &lt;code&gt;CONSTANT&lt;/code&gt; 는 문자열로 해석 되므로 &lt;code&gt;$hash{CONSTANT}&lt;/code&gt; 말할 수 없습니다 . 사용 &lt;code&gt;$hash{CONSTANT()}&lt;/code&gt; 또는 &lt;code&gt;$hash{+CONSTANT}&lt;/code&gt; 에서 발로에서 메커니즘에 따옴표 bareword는 것을 방지 할 수 있습니다. 마찬가지로, 이후 &lt;code&gt;=&amp;gt;&lt;/code&gt; 연산자 시세 bareword는 즉시 그 왼쪽에, 당신은 말을 &lt;code&gt;CONSTANT() =&amp;gt; 'value'&lt;/code&gt; &lt;code&gt;CONSTANT =&amp;gt; 'value'&lt;/code&gt; 대신 value ' (또는 단순히 큰 화살표 대신 쉼표를 사용하십시오) .</target>
        </trans-unit>
        <trans-unit id="da2f7597146611c6fbedf52c5830c6aad8de3611" translate="yes" xml:space="preserve">
          <source>You can get into trouble if you use constants in a context which automatically quotes barewords (as is true for any subroutine call). For example, you can't say &lt;code&gt;$hash{CONSTANT}&lt;/code&gt; because &lt;code&gt;CONSTANT&lt;/code&gt; will be interpreted as a string. Use &lt;code&gt;$hash{CONSTANT()}&lt;/code&gt; or &lt;code&gt;$hash{+CONSTANT}&lt;/code&gt; to prevent the bareword quoting mechanism from kicking in. Similarly, since the &lt;code&gt;=&amp;gt;&lt;/code&gt; operator quotes a bareword immediately to its left, you have to say &lt;code&gt;CONSTANT() =&amp;gt; 'value'&lt;/code&gt; (or simply use a comma in place of the big arrow) instead of &lt;code&gt;CONSTANT =&amp;gt; 'value'&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6872803f70582536909b7aa8df4da94cd4d37a4" translate="yes" xml:space="preserve">
          <source>You can have an environment variable PERL_INSTALL_ROOT set which will be prepended as a directory to each installed file (and directory).</source>
          <target state="translated">설치된 각 파일 (및 디렉토리)에 디렉토리로 추가 될 환경 변수 PERL_INSTALL_ROOT 세트를 가질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fa58ede728fa900b2be53c5925b3b4ff8069c044" translate="yes" xml:space="preserve">
          <source>You can ignore [pad]THXx when browsing the Perl headers/sources. Those are strictly for use within the core. Extensions and embedders need only be aware of [pad]THX.</source>
          <target state="translated">Perl 헤더 / 소스를 탐색 할 때 [pad] THXx를 무시할 수 있습니다. 그것들은 코어 내에서 엄격하게 사용됩니다. 확장 프로그램 및 내장 프로그램은 [pad] THX 만 인식하면됩니다.</target>
        </trans-unit>
        <trans-unit id="f0a479cb9681a1cb4f6cbb2bcf71ac6471f5092e" translate="yes" xml:space="preserve">
          <source>You can imagine how bad things would be if, for example, the SYS$MANAGER or SYS$SYSTEM logical names were deleted.</source>
          <target state="translated">예를 들어 SYS $ MANAGER 또는 SYS $ SYSTEM 논리 이름이 삭제 된 경우 상황이 얼마나 나쁜지 상상할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2157dc8c06b7685edcc449748ab0e77243e5a157" translate="yes" xml:space="preserve">
          <source>You can immediately see a slightly different focus to the subroutine profiling modules, and we start to see exactly which line of code is taking the most time. That regex line is looking a bit suspicious, for example. Remember that these tools are supposed to be used together, there is no single best way to profile your code, you need to use the best tools for the job.</source>
          <target state="translated">서브 루틴 프로파일 링 모듈에 대해 약간 다른 초점을 즉시 볼 수 있으며, 가장 시간이 오래 걸리는 코드를 정확히 파악하기 시작합니다. 예를 들어 그 정규식 줄은 조금 의심스러워 보입니다. 이러한 도구는 함께 사용되어야하며 코드를 프로파일 링하는 가장 좋은 방법은 없으며 작업에 가장 적합한 도구를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="01ccbef4b59df5e513c51a0c19924a7a01e4981e" translate="yes" xml:space="preserve">
          <source>You can import &lt;code&gt;:pushpop&lt;/code&gt; and maintain a stack of colors using PUSHCOLOR, POPCOLOR, and LOCALCOLOR. PUSHCOLOR takes the attribute string that starts its argument and pushes it onto a stack of attributes. POPCOLOR removes the top of the stack and restores the previous attributes set by the argument of a prior PUSHCOLOR. LOCALCOLOR surrounds its argument in a PUSHCOLOR and POPCOLOR so that the color resets afterward.</source>
          <target state="translated">PUSHCOLOR, POPCOLOR 및 LOCALCOLOR를 사용하여 &lt;code&gt;:pushpop&lt;/code&gt; 을 가져오고 색상 스택을 유지할 수 있습니다 . PUSHCOLOR는 인수를 시작하는 속성 문자열을 가져 와서 속성 스택으로 푸시합니다. POPCOLOR는 스택의 상단을 제거하고 이전 PUSHCOLOR의 인수로 설정된 이전 속성을 복원합니다. LOCALCOLOR는 PUSHCOLOR와 POPCOLOR에서 인수를 둘러싼 후 색상이 재설정됩니다.</target>
        </trans-unit>
        <trans-unit id="7225c37bbdccefc8a70c019da87c9b8dea7a6b29" translate="yes" xml:space="preserve">
          <source>You can import all the great circle formulas by</source>
          <target state="translated">당신은 모든 위대한 원 수식을 가져올 수 있습니다</target>
        </trans-unit>
        <trans-unit id="6ccdd2eb8d7e6ad6ca52482a2893e8ad5920726c" translate="yes" xml:space="preserve">
          <source>You can import radial coordinate conversion functions by using the &lt;code&gt;:radial&lt;/code&gt; tag:</source>
          <target state="translated">&lt;code&gt;:radial&lt;/code&gt; 태그를 사용하여 방사형 좌표 변환 함수를 가져올 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a747eb56defc25ea65ac8c773f590bb69f4cf6d4" translate="yes" xml:space="preserve">
          <source>You can import symbolic mode constants (&lt;code&gt;S_IF*&lt;/code&gt; ) and functions (&lt;code&gt;S_IS*&lt;/code&gt; ) from the Fcntl module:</source>
          <target state="translated">Fcntl 모듈에서 기호 모드 상수 ( &lt;code&gt;S_IF*&lt;/code&gt; ) 및 함수 ( &lt;code&gt;S_IS*&lt;/code&gt; )를 가져올 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="daf6e79cd146ad6c1ff8be35e0c5dd03545d96b4" translate="yes" xml:space="preserve">
          <source>You can import symbolic mode constants (&lt;code&gt;S_IF*&lt;/code&gt;) and functions (&lt;code&gt;S_IS*&lt;/code&gt;) from the &lt;a href=&quot;fcntl&quot;&gt;Fcntl&lt;/a&gt; module:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7c8f6c731717afeb2f914b548c9389d16df04b0" translate="yes" xml:space="preserve">
          <source>You can include one underscore between any two digits.</source>
          <target state="translated">두 자리 사이에 하나의 밑줄을 포함 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="06780cff3747acdd27c6cb36674311a1b2286d47" translate="yes" xml:space="preserve">
          <source>You can instead write</source>
          <target state="translated">대신 쓸 수 있습니다</target>
        </trans-unit>
        <trans-unit id="c4bd7d42db9b74a8aac6c0368becb036004d4652" translate="yes" xml:space="preserve">
          <source>You can intermix &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m//g&lt;/a&gt;&lt;/code&gt; matches with &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m/\G.../g&lt;/a&gt;&lt;/code&gt;, where &lt;code&gt;\G&lt;/code&gt; is a zero-width assertion that matches the exact position where the previous &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m//g&lt;/a&gt;&lt;/code&gt;, if any, left off. Without the &lt;code&gt;/g&lt;/code&gt; modifier, the &lt;code&gt;\G&lt;/code&gt; assertion still anchors at &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos()&lt;/a&gt;&lt;/code&gt; as it was at the start of the operation (see &lt;a href=&quot;functions/pos&quot;&gt;pos&lt;/a&gt;), but the match is of course only attempted once. Using &lt;code&gt;\G&lt;/code&gt; without &lt;code&gt;/g&lt;/code&gt; on a target string that has not previously had a &lt;code&gt;/g&lt;/code&gt; match applied to it is the same as using the &lt;code&gt;\A&lt;/code&gt; assertion to match the beginning of the string. Note also that, currently, &lt;code&gt;\G&lt;/code&gt; is only properly supported when anchored at the very beginning of the pattern.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m/\G.../g&lt;/a&gt;&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m//g&lt;/a&gt;&lt;/code&gt; 일치를 m / \ G ... / g 와 혼합 할 수 있습니다 . 여기서 &lt;code&gt;\G&lt;/code&gt; 는 이전 &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m//g&lt;/a&gt;&lt;/code&gt; 가있는 경우 정확한 위치와 일치하는 폭이 0 인 어설 션입니다 (있는 경우). &lt;code&gt;/g&lt;/code&gt; 수정자가 없으면 &lt;code&gt;\G&lt;/code&gt; 어설 션 은 작업 시작시와 같이 &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos()&lt;/a&gt;&lt;/code&gt; 여전히 고정 되지만 ( &lt;a href=&quot;functions/pos&quot;&gt;pos&lt;/a&gt; 참조 ) 일치는 물론 한 번만 시도됩니다. 사용 &lt;code&gt;\G&lt;/code&gt; 하지 않고 &lt;code&gt;/g&lt;/code&gt; 이전에 있었던 않은 대상 문자열 &lt;code&gt;/g&lt;/code&gt; 적용된 일치하는 것은 사용하는 것과 동일하다 &lt;code&gt;\A&lt;/code&gt; 문자열의 시작과 일치하도록 주장. 또한 현재 &lt;code&gt;\G&lt;/code&gt; 패턴의 맨 처음에 고정 된 경우에만 제대로 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="a2f99acf8ebf785cd6fcc65bebd6795b26da26f1" translate="yes" xml:space="preserve">
          <source>You can intermix &lt;code&gt;m//g&lt;/code&gt; matches with &lt;code&gt;m/\G.../g&lt;/code&gt;, where &lt;code&gt;\G&lt;/code&gt; is a zero-width assertion that matches the exact position where the previous &lt;code&gt;m//g&lt;/code&gt;, if any, left off. Without the &lt;code&gt;/g&lt;/code&gt; modifier, the &lt;code&gt;\G&lt;/code&gt; assertion still anchors at &lt;code&gt;pos()&lt;/code&gt; as it was at the start of the operation (see &lt;a href=&quot;perlfunc#pos&quot;&gt;&quot;pos&quot; in perlfunc&lt;/a&gt;), but the match is of course only attempted once. Using &lt;code&gt;\G&lt;/code&gt; without &lt;code&gt;/g&lt;/code&gt; on a target string that has not previously had a &lt;code&gt;/g&lt;/code&gt; match applied to it is the same as using the &lt;code&gt;\A&lt;/code&gt; assertion to match the beginning of the string. Note also that, currently, &lt;code&gt;\G&lt;/code&gt; is only properly supported when anchored at the very beginning of the pattern.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83b86b2d839c827310b20f3c55919cf18f3acb03" translate="yes" xml:space="preserve">
          <source>You can inversely compute the destination if you know the starting point, direction, and distance:</source>
          <target state="translated">시작점, 방향 및 거리를 알고 있으면 대상을 역으로 계산할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c770c9c675ab604224950a0310e7e3cbf6f8631c" translate="yes" xml:space="preserve">
          <source>You can list opcodes by names, or use a tag name; see &lt;a href=&quot;opcode#Predefined-Opcode-Tags&quot;&gt;&quot;Predefined Opcode Tags&quot; in Opcode&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0dfc74f0d7463fa46580b22cd874ca59538b399a" translate="yes" xml:space="preserve">
          <source>You can list opcodes by names, or use a tag name; see &lt;a href=&quot;opcode#Predefined-Opcode-Tags&quot;&gt;Predefined Opcode Tags in Opcode&lt;/a&gt;.</source>
          <target state="translated">이름별로 opcode를 나열하거나 태그 이름을 사용할 수 있습니다. &lt;a href=&quot;opcode#Predefined-Opcode-Tags&quot;&gt;Opcode의 사전 정의 된 Opcode 태그를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="5f4c7db1d02ea8c4d5d73863315380fa405b9daa" translate="yes" xml:space="preserve">
          <source>You can load a custom &lt;a href=&quot;TAP::Parser::Formatter&quot;&gt;TAP::Parser::Formatter&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="001468774175cba071073df8732faf49990cd65b" translate="yes" xml:space="preserve">
          <source>You can load a custom &lt;a href=&quot;http://search.cpan.org/perldoc/TAP::Parser::Formatter&quot;&gt;TAP::Parser::Formatter&lt;/a&gt;:</source>
          <target state="translated">사용자 정의 &lt;a href=&quot;http://search.cpan.org/perldoc/TAP::Parser::Formatter&quot;&gt;TAP :: Parser :: Formatter를&lt;/a&gt; 로드 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="922b68ea0df3880a69d6f0bb73214de0179f5c3f" translate="yes" xml:space="preserve">
          <source>You can load custom &lt;a href=&quot;TAP::Parser::SourceHandler&quot;&gt;TAP::Parser::SourceHandler&lt;/a&gt;s, to change the way the parser interprets particular</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97cc72d3ba21acacd11a8df6beb891397824853a" translate="yes" xml:space="preserve">
          <source>You can load custom &lt;a href=&quot;tap/parser/sourcehandler&quot;&gt;TAP::Parser::SourceHandler&lt;/a&gt;s, to change the way the parser interprets particular</source>
          <target state="translated">사용자 정의 &lt;a href=&quot;tap/parser/sourcehandler&quot;&gt;TAP :: Parser :: SourceHandler를&lt;/a&gt; 로드 하여 파서가 특정을 해석하는 방식을 변경할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="864c8cc598c8e4c08f636d6accb98e4216dd8dc6" translate="yes" xml:space="preserve">
          <source>You can log in to the bug tracking system and comment on existing bug reports. If you have additional information regarding an existing bug, please add it. This will help the porters fix the bug.</source>
          <target state="translated">버그 추적 시스템에 로그인하여 기존 버그 보고서에 댓글을 달 수 있습니다. 기존 버그에 관한 추가 정보가 있으면 추가하십시오. 포터가 버그를 수정하는 데 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="70b967da2737530b2ccb33fdb14ce4b355858a95" translate="yes" xml:space="preserve">
          <source>You can look into using the &lt;code&gt;DB_File&lt;/code&gt; module and &lt;code&gt;&lt;a href=&quot;functions/tie&quot;&gt;tie()&lt;/a&gt;&lt;/code&gt; using the &lt;code&gt;$DB_BTREE&lt;/code&gt; hash bindings as documented in &lt;a href=&quot;db_file#In-Memory-Databases&quot;&gt;In Memory Databases in DB_File&lt;/a&gt;. The &lt;a href=&quot;http://search.cpan.org/perldoc/Tie::IxHash&quot;&gt;Tie::IxHash&lt;/a&gt; module from CPAN might also be instructive. Although this does keep your hash sorted, you might not like the slowdown you suffer from the tie interface. Are you sure you need to do this? :)</source>
          <target state="translated">당신은 사용에 볼 수 &lt;code&gt;DB_File&lt;/code&gt; 의 모듈 &lt;code&gt;&lt;a href=&quot;functions/tie&quot;&gt;tie()&lt;/a&gt;&lt;/code&gt; 은 Using &lt;code&gt;$DB_BTREE&lt;/code&gt; 에 설명 된대로 해시 바인딩 &lt;a href=&quot;db_file#In-Memory-Databases&quot;&gt;DB_File에 메모리 데이터베이스&lt;/a&gt; . CPAN 의 &lt;a href=&quot;http://search.cpan.org/perldoc/Tie::IxHash&quot;&gt;Tie :: IxHash&lt;/a&gt; 모듈도 도움이 될 수 있습니다. 이렇게하면 해시가 정렬되어 유지되지만 넥타이 인터페이스로 인한 속도 저하를 좋아하지 않을 수 있습니다. 이 작업을 수행해야합니까? :)</target>
        </trans-unit>
        <trans-unit id="7b312039abf365be7292ef1e18c22e425bf6aa57" translate="yes" xml:space="preserve">
          <source>You can look into using the &lt;code&gt;DB_File&lt;/code&gt; module and &lt;code&gt;tie()&lt;/code&gt; using the &lt;code&gt;$DB_BTREE&lt;/code&gt; hash bindings as documented in &lt;a href=&quot;db_file#In-Memory-Databases&quot;&gt;&quot;In Memory Databases&quot; in DB_File&lt;/a&gt;. The &lt;a href=&quot;Tie::IxHash&quot;&gt;Tie::IxHash&lt;/a&gt; module from CPAN might also be instructive. Although this does keep your hash sorted, you might not like the slowdown you suffer from the tie interface. Are you sure you need to do this? :)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9625d3e38b4c49498359b9273455de8f35f225d" translate="yes" xml:space="preserve">
          <source>You can make a read-only clone of the repository by running:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d03c6c46e2fd91fc95b867e10fbdca9429550351" translate="yes" xml:space="preserve">
          <source>You can make references to anything, including scalars, functions, and other references.</source>
          <target state="translated">스칼라, 함수 및 기타 참조를 포함하여 모든 것을 참조 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f238aab29e64ee5c9b032d4d04c0ab30c79c6501" translate="yes" xml:space="preserve">
          <source>You can make the while loop a lot shorter with this suggestion from Benjamin Goldberg:</source>
          <target state="translated">Benjamin Goldberg의 제안으로 while 루프를 훨씬 짧게 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0ec5f2b2db5f7957e7b186e607473a4a56ae2fd0" translate="yes" xml:space="preserve">
          <source>You can make your configuration changes permanent by calling the command &lt;code&gt;o conf commit&lt;/code&gt; . Alternatively set the &lt;code&gt;auto_commit&lt;/code&gt; variable to true by running &lt;code&gt;o conf init auto_commit&lt;/code&gt; and answering the following question with yes.</source>
          <target state="translated">&lt;code&gt;o conf commit&lt;/code&gt; 명령을 호출하여 구성 변경을 영구적으로 만들 수 있습니다 . 또는 &lt;code&gt;o conf init auto_commit&lt;/code&gt; 을 실행 하고 yes로 다음 질문에 대답 하여 &lt;code&gt;auto_commit&lt;/code&gt; 변수를 true로 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="2011dcb658fe55c431da3ed5067e6f4bf4528970" translate="yes" xml:space="preserve">
          <source>You can mimic class subtraction using lookahead. For example, what UTS#18 might write as</source>
          <target state="translated">lookahead를 사용하여 클래스 빼기를 모방 할 수 있습니다. 예를 들어 UTS # 18은 다음과 같이 쓸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3461cd371c3715543776c435145f8478a0ac6ec8" translate="yes" xml:space="preserve">
          <source>You can mock TTY input to debugger by adding arbitrary commands to @DB::typeahead. For example, your</source>
          <target state="translated">@DB :: typeahead에 임의의 명령을 추가하여 디버거에 TTY 입력을 조롱 할 수 있습니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="cf9cef6663d4cd69a19179eacb290a6dcc1e8352" translate="yes" xml:space="preserve">
          <source>You can modify &lt;code&gt;@ARGV&lt;/code&gt; before the first &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; as long as the array ends up containing the list of filenames you really want. Line numbers (&lt;code&gt;$.&lt;/code&gt; ) continue as though the input were one big happy file. See the example in &lt;a href=&quot;functions/eof&quot;&gt;eof&lt;/a&gt; for how to reset line numbers on each file.</source>
          <target state="translated">배열이 실제로 원하는 파일 이름 목록을 포함하는 한 첫 번째 &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; 전에 &lt;code&gt;@ARGV&lt;/code&gt; 를 수정할 수 있습니다 . 입력이 하나의 큰 행복한 파일 인 것처럼 줄 번호 ( &lt;code&gt;$.&lt;/code&gt; )는 계속됩니다. 각 파일에서 줄 번호를 재설정하는 방법 은 &lt;a href=&quot;functions/eof&quot;&gt;eof&lt;/a&gt; 의 예를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="fef203404e7c4e26b3201a37c63c3bf76f7a448a" translate="yes" xml:space="preserve">
          <source>You can modify &lt;code&gt;@ARGV&lt;/code&gt; before the first &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; as long as the array ends up containing the list of filenames you really want. Line numbers (&lt;code&gt;$.&lt;/code&gt;) continue as though the input were one big happy file. See the example in &lt;a href=&quot;perlfunc#eof&quot;&gt;&quot;eof&quot; in perlfunc&lt;/a&gt; for how to reset line numbers on each file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c8a419c4027fffc2a00680692cdd50042e9d07e" translate="yes" xml:space="preserve">
          <source>You can modify the 'commands' for example to hardwire an absolute path by e.g.</source>
          <target state="translated">예를 들어 'commands'를 수정하여 절대 경로를 고정 배선 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b4169d013aca1666238580a9fd59a4dae77a7deb" translate="yes" xml:space="preserve">
          <source>You can not currently force the type in other, less obscure, ways.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e5494206985a4f40e7d6f949c9e6a6ea96245c15" translate="yes" xml:space="preserve">
          <source>You can now &lt;code&gt;use my::autodie&lt;/code&gt;, which will work just like the standard &lt;code&gt;autodie&lt;/code&gt;, but is now aware of any hints that you've set.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3de41be22b6a5efcacf396fbce08b0572f97fd60" translate="yes" xml:space="preserve">
          <source>You can only declare autoties for types &lt;code&gt;&quot;SCALAR&quot;&lt;/code&gt; , &lt;code&gt;&quot;ARRAY&quot;&lt;/code&gt; , and &lt;code&gt;&quot;HASH&quot;&lt;/code&gt; . They're the only things (apart from typeglobs -- which are not declarable) that Perl can tie.</source>
          <target state="translated">&lt;code&gt;&quot;SCALAR&quot;&lt;/code&gt; , &lt;code&gt;&quot;ARRAY&quot;&lt;/code&gt; 및 &lt;code&gt;&quot;HASH&quot;&lt;/code&gt; 유형에 대한 자동 제어 만 선언 할 수 있습니다 . 그것들은 Perl이 묶을 수있는 유일한 것입니다 (유형은 제외하고 &amp;ndash; 선언 할 수없는 것).</target>
        </trans-unit>
        <trans-unit id="d8980e8dd984a6627df441ec747331d50a1b07d8" translate="yes" xml:space="preserve">
          <source>You can only declare autoties for types &lt;code&gt;&quot;SCALAR&quot;&lt;/code&gt;, &lt;code&gt;&quot;ARRAY&quot;&lt;/code&gt;, and &lt;code&gt;&quot;HASH&quot;&lt;/code&gt;. They're the only things (apart from typeglobs -- which are not declarable) that Perl can tie.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48d6492d8d5c8ebf50c4b6f0278c97639e62301c" translate="yes" xml:space="preserve">
          <source>You can only obtain this using an alias, and Getopt::Long of at least version 2.13.</source>
          <target state="translated">별명과 최소한 버전 2.13의 Getopt :: Long을 사용하여이를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d146ace3315d8b55185b8781aa6332aa44a31223" translate="yes" xml:space="preserve">
          <source>You can only use the elliptical statement to stand in for a complete statement. Syntactically, &quot;&lt;code&gt;...;&lt;/code&gt;&quot; is a complete statement, but, as with other kinds of semicolon-terminated statement, the semicolon may be omitted if &quot;&lt;code&gt;...&lt;/code&gt;&quot; appears immediately before a closing brace. These examples show how the ellipsis works:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ce5924582aac2aa9ee7cd1ad99c9e8ff1e6ecea" translate="yes" xml:space="preserve">
          <source>You can only use the elliptical statement to stand in for a complete statement. These examples of how the ellipsis works:</source>
          <target state="translated">완전한 문장을 나타 내기 위해 타원형 문장 만 사용할 수 있습니다. 줄임표 작동 방식에 대한 다음 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9cae8654bfe063f888826b48470927a2c30f96cd" translate="yes" xml:space="preserve">
          <source>You can open a file for input or output using the &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; function. It's documented in extravagant detail in &lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt; and &lt;a href=&quot;perlopentut&quot;&gt;perlopentut&lt;/a&gt;, but in short:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; 함수를 사용하여 입력 또는 출력 할 파일을 열 수 있습니다 . &lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt; 및 &lt;a href=&quot;perlopentut&quot;&gt;perlopentut에 사소한&lt;/a&gt; 세부 사항으로 문서화되어 있지만 짧게 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="318c92a1d982aec365969dbe006cbe697f2326c8" translate="yes" xml:space="preserve">
          <source>You can open a file for input or output using the &lt;code&gt;open()&lt;/code&gt; function. It's documented in extravagant detail in &lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt; and &lt;a href=&quot;perlopentut&quot;&gt;perlopentut&lt;/a&gt;, but in short:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76ba77a9bf1f3b31a9c843fd61b1d22b18753582" translate="yes" xml:space="preserve">
          <source>You can open filehandles directly to Perl scalars instead of a file or other resource external to the program. To do so, provide a reference to that scalar as the third argument to &lt;code&gt;open&lt;/code&gt;, like so:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce96504bc4965bb9a6b5d98ed74131b7aef0ff79" translate="yes" xml:space="preserve">
          <source>You can override predefined aliases by simply applying define_alias(). The new alias is always evaluated first, and when necessary, define_alias() flushes the internal cache to make the new definition available.</source>
          <target state="translated">define_alias ()를 적용하면 미리 정의 된 별칭을 무시할 수 있습니다. 새 별명은 항상 먼저 평가되며, 필요한 경우 define_alias ()는 내부 캐시를 비워서 새 정의를 사용 가능하게합니다.</target>
        </trans-unit>
        <trans-unit id="ef785435f6086fb9fd6b00d9def6f92017001719" translate="yes" xml:space="preserve">
          <source>You can override the default and build a shared libperl if you wish (Configure ... -Duseshrplib).</source>
          <target state="translated">원하는 경우 기본값을 무시하고 공유 라이브러리를 구성 할 수 있습니다 (Configure ... -Duseshrplib).</target>
        </trans-unit>
        <trans-unit id="97ed2e27db33bd8f090672fcd70380db3caec730" translate="yes" xml:space="preserve">
          <source>You can override this by giving extra arguments; see below.</source>
          <target state="translated">추가 인수를 제공하여이를 무시할 수 있습니다. 아래를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="73f74d7cb907a2b7504c7060b4ad0ec87a6506fe" translate="yes" xml:space="preserve">
          <source>You can override this by passing the desired rounding mode as parameter to &lt;code&gt;as_number()&lt;/code&gt; :</source>
          <target state="translated">원하는 반올림 모드를 매개 변수로 &lt;code&gt;as_number()&lt;/code&gt; 에 전달하여이를 무시할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="82587933cae4e9f30d2fe8c8c0c7863b53e2375e" translate="yes" xml:space="preserve">
          <source>You can override this by passing the desired rounding mode as parameter to &lt;code&gt;as_number()&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7321ebb0b4eea0262a3b635a8b77554cb51e976a" translate="yes" xml:space="preserve">
          <source>You can override this default using the &lt;code&gt;T2_FORMATTER&lt;/code&gt; environment variable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92b4dbfc185a430ad159257351a9ef1b4f3e946a" translate="yes" xml:space="preserve">
          <source>You can pass an argument to your plugin by appending an &lt;code&gt;=&lt;/code&gt; after the plugin name, eg &lt;code&gt;-PMyPlugin=foo&lt;/code&gt; . You can pass multiple arguments using commas:</source>
          <target state="translated">플러그인 이름 뒤에 &lt;code&gt;=&lt;/code&gt; 를 추가하여 플러그인에 인수를 전달할 수 있습니다 ( 예 : &lt;code&gt;-PMyPlugin=foo&lt;/code&gt; ) . 쉼표를 사용하여 여러 인수를 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2736e3b985373c7bf800fbac7652d16fb607a369" translate="yes" xml:space="preserve">
          <source>You can pass an argument to your plugin by appending an &lt;code&gt;=&lt;/code&gt; after the plugin name, eg &lt;code&gt;-PMyPlugin=foo&lt;/code&gt;. You can pass multiple arguments using commas:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="577ba47f8467272240629f611eeec9e04fdaf1e6" translate="yes" xml:space="preserve">
          <source>You can pass arguments to your plugin by appending &lt;code&gt;=arg1,arg2,etc&lt;/code&gt; to the plugin name:</source>
          <target state="translated">플러그인 이름에 &lt;code&gt;=arg1,arg2,etc&lt;/code&gt; 을 추가하여 플러그인에 인수를 전달할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="386308dc979139b37676d9287d489e82d9329ea5" translate="yes" xml:space="preserve">
          <source>You can pass in &lt;code&gt;&quot;?&quot;&lt;/code&gt; for &lt;code&gt;$svAccess&lt;/code&gt; to have an error message displayed summarizing its possible values. This is very handy when doing on-the-fly programming using the Perl debugger:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2015c5b11227b45450c075073adbe76ec83f58eb" translate="yes" xml:space="preserve">
          <source>You can peek into the bisecting process with &lt;code&gt;git bisect log&lt;/code&gt; and &lt;code&gt;git bisect visualize&lt;/code&gt;. &lt;code&gt;git bisect reset&lt;/code&gt; will get you out of bisect mode.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9b26d7e57483cd1ed4bf2659755481a3ca93653" translate="yes" xml:space="preserve">
          <source>You can pick up prebuilt binaries for Solaris from &lt;a href=&quot;http://www.sunfreeware.com/&quot;&gt;http://www.sunfreeware.com/&lt;/a&gt;, &lt;a href=&quot;http://www.blastwave.org&quot;&gt;http://www.blastwave.org&lt;/a&gt;, ActiveState &lt;a href=&quot;http://www.activestate.com/&quot;&gt;http://www.activestate.com/&lt;/a&gt;, and &lt;a href=&quot;http://www.perl.com/&quot;&gt;http://www.perl.com/&lt;/a&gt; under the Binaries list at the top of the page. There are probably other sources as well. Please note that these sites are under the control of their respective owners, not the perl developers.</source>
          <target state="translated">&lt;a href=&quot;http://www.sunfreeware.com/&quot;&gt;http://www.sunfreeware.com/&lt;/a&gt; , &lt;a href=&quot;http://www.blastwave.org&quot;&gt;http://www.blastwave.org&lt;/a&gt; , ActiveState &lt;a href=&quot;http://www.activestate.com/&quot;&gt;http://www.activestate.com/&lt;/a&gt; 및 &lt;a href=&quot;http://www.perl.com/&quot;&gt;http : //www.perl&lt;/a&gt; 에서 Solaris 용 사전 빌드 바이너리를 선택할 수 있습니다 . .com / 페이지 상단의 바이너리 목록 아래에 있습니다. 다른 출처도있을 것입니다. 이 사이트는 perl 개발자가 아닌 해당 소유자의 통제를받습니다.</target>
        </trans-unit>
        <trans-unit id="afad181efc494d271a3d1339fc4bea9100125dd3" translate="yes" xml:space="preserve">
          <source>You can preallocate space for a hash by assigning to the keys() function. This rounds up the allocated buckets to the next power of two:</source>
          <target state="translated">keys () 함수에 할당하여 해시를위한 공간을 미리 할당 할 수 있습니다. 이렇게하면 할당 된 버킷이 다음 2의 제곱으로 반올림됩니다.</target>
        </trans-unit>
        <trans-unit id="627b7e3f88900bea51795d1c0d405285e2cec7cd" translate="yes" xml:space="preserve">
          <source>You can prevent regeneration by adding the setting</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ece78405c91977c16dd3a742419b856c5fd5394" translate="yes" xml:space="preserve">
          <source>You can probably expect your users to be able to guess that they can request less CPU or memory or just &quot;less&quot; overall.</source>
          <target state="translated">아마도 사용자가 적은 CPU 나 메모리를 요구하거나 전체적으로 &quot;낮은&quot;것을 추측 할 수있을 것으로 예상 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="02d6761deb2c7c6b18b97139af69b3430e2b5002" translate="yes" xml:space="preserve">
          <source>You can provide an argument, which will be available in the var &lt;code&gt;$REGMARK&lt;/code&gt; after the match completes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2bb56a3e59af78b8d5da4daff16effef12d060e2" translate="yes" xml:space="preserve">
          <source>You can provide this layer when &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt;ing the file:</source>
          <target state="translated">파일을 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; 때이 계층을 제공 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="add06e5808df8acbd3f7d2e5d056882c7fd1db80" translate="yes" xml:space="preserve">
          <source>You can provide this layer when &lt;code&gt;open&lt;/code&gt;ing the file:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="87d0d59bd2621cca1e6ec0d854420947ec5a4ec5" translate="yes" xml:space="preserve">
          <source>You can put a &lt;code&gt;+&lt;/code&gt; in front of the &lt;code&gt;&amp;gt;&lt;/code&gt; or &lt;code&gt;&amp;lt;&lt;/code&gt; to indicate that you want both read and write access to the file; thus &lt;code&gt;+&amp;lt;&lt;/code&gt; is almost always preferred for read/write updates--the &lt;code&gt;+&amp;gt;&lt;/code&gt; mode would clobber the file first. You can't usually use either read-write mode for updating textfiles, since they have variable-length records. See the &lt;b&gt;-i&lt;/b&gt; switch in &lt;a href=&quot;../perlrun&quot;&gt;perlrun&lt;/a&gt; for a better approach. The file is created with permissions of &lt;code&gt;0666&lt;/code&gt; modified by the process's &lt;code&gt;&lt;a href=&quot;umask&quot;&gt;umask&lt;/a&gt;&lt;/code&gt; value.</source>
          <target state="translated">파일에 대한 읽기 및 쓰기 액세스를 원한다는 것을 나타 내기 위해 &lt;code&gt;&amp;gt;&lt;/code&gt; 또는 &lt;code&gt;&amp;lt;&lt;/code&gt; 앞에 &lt;code&gt;+&lt;/code&gt; 를 넣을 수 있습니다 . 따라서 &lt;code&gt;+&amp;lt;&lt;/code&gt; 는 거의 항상 읽기 / 쓰기 업데이트에 적합합니다. &lt;code&gt;+&amp;gt;&lt;/code&gt; 모드는 파일을 먼저 복제합니다. 텍스트 파일에는 가변 길이 레코드가 있으므로 일반적으로 텍스트 파일을 업데이트하는 데 읽기 / 쓰기 모드를 사용할 수 없습니다. 더 나은 접근 방법 은 &lt;a href=&quot;../perlrun&quot;&gt;perlrun&lt;/a&gt; 의 &lt;b&gt;-i&lt;/b&gt; 스위치를 참조하십시오 . 파일은 프로세스의 &lt;code&gt;&lt;a href=&quot;umask&quot;&gt;umask&lt;/a&gt;&lt;/code&gt; 값에 의해 수정 된 권한 &lt;code&gt;0666&lt;/code&gt; 으로 작성됩니다 .&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="a5c78cfaaebb70f40ad0f93e0301fba4283c243b" translate="yes" xml:space="preserve">
          <source>You can put a &lt;code&gt;+&lt;/code&gt; in front of the &lt;code&gt;&amp;gt;&lt;/code&gt; or &lt;code&gt;&amp;lt;&lt;/code&gt; to indicate that you want both read and write access to the file; thus &lt;code&gt;+&amp;lt;&lt;/code&gt; is almost always preferred for read/write updates--the &lt;code&gt;+&amp;gt;&lt;/code&gt; mode would clobber the file first. You can't usually use either read-write mode for updating textfiles, since they have variable-length records. See the &lt;b&gt;-i&lt;/b&gt; switch in &lt;a href=&quot;perlrun&quot;&gt;perlrun&lt;/a&gt; for a better approach. The file is created with permissions of &lt;code&gt;0666&lt;/code&gt; modified by the process's &lt;code&gt;&lt;a href=&quot;functions/umask&quot;&gt;umask&lt;/a&gt;&lt;/code&gt; value.</source>
          <target state="translated">파일에 대한 읽기 및 쓰기 액세스를 원한다는 것을 나타 내기 위해 &lt;code&gt;&amp;gt;&lt;/code&gt; 또는 &lt;code&gt;&amp;lt;&lt;/code&gt; 앞에 &lt;code&gt;+&lt;/code&gt; 를 넣을 수 있습니다 . 따라서 &lt;code&gt;+&amp;lt;&lt;/code&gt; 는 거의 항상 읽기 / 쓰기 업데이트에 적합합니다. &lt;code&gt;+&amp;gt;&lt;/code&gt; 모드는 파일을 먼저 복제합니다. 텍스트 파일에는 가변 길이 레코드가 있으므로 일반적으로 텍스트 파일을 업데이트하는 데 읽기 / 쓰기 모드를 사용할 수 없습니다. 더 나은 접근 방법 은 &lt;a href=&quot;perlrun&quot;&gt;perlrun&lt;/a&gt; 의 &lt;b&gt;-i&lt;/b&gt; 스위치를 참조하십시오 . 파일은 프로세스의 &lt;code&gt;&lt;a href=&quot;functions/umask&quot;&gt;umask&lt;/a&gt;&lt;/code&gt; 값에 의해 수정 된 권한 &lt;code&gt;0666&lt;/code&gt; 으로 작성됩니다 .&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="764b0ecb923d2a9a161c6836b490b2d71dbd0c6c" translate="yes" xml:space="preserve">
          <source>You can put a &lt;code&gt;+&lt;/code&gt; in front of the &lt;code&gt;&amp;gt;&lt;/code&gt; or &lt;code&gt;&amp;lt;&lt;/code&gt; to indicate that you want both read and write access to the file; thus &lt;code&gt;+&amp;lt;&lt;/code&gt; is almost always preferred for read/write updates--the &lt;code&gt;+&amp;gt;&lt;/code&gt; mode would clobber the file first. You can't usually use either read-write mode for updating textfiles, since they have variable-length records. See the &lt;b&gt;-i&lt;/b&gt; switch in &lt;a href=&quot;perlrun#-i%5Bextension%5D&quot;&gt;perlrun&lt;/a&gt; for a better approach. The file is created with permissions of &lt;code&gt;0666&lt;/code&gt; modified by the process's &lt;a href=&quot;#umask-EXPR&quot;&gt;&lt;code&gt;umask&lt;/code&gt;&lt;/a&gt; value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c8c4f9eec7c5f71cbfe88cf0f5ec847885d12d2" translate="yes" xml:space="preserve">
          <source>You can put any backslash sequence character class (with the exception of &lt;code&gt;\N&lt;/code&gt; and &lt;code&gt;\R&lt;/code&gt; ) inside a bracketed character class, and it will act just as if you had put all characters matched by the backslash sequence inside the character class. For instance, &lt;code&gt;[a-f\d]&lt;/code&gt; matches any decimal digit, or any of the lowercase letters between 'a' and 'f' inclusive.</source>
          <target state="translated">백 슬래시 시퀀스 문자 클래스 ( &lt;code&gt;\N&lt;/code&gt; 및 &lt;code&gt;\R&lt;/code&gt; 제외)를 괄호 문자 클래스 안에 넣을 수 있으며, 백 슬래시 시퀀스와 일치하는 모든 문자를 문자 클래스 안에 넣은 것처럼 작동합니다. 예를 들어, &lt;code&gt;[a-f\d]&lt;/code&gt; 는 십진수 또는 'a'와 'f'사이의 소문자와 일치합니다.</target>
        </trans-unit>
        <trans-unit id="3f74a5262161afb2e7d36af12d2c0a5e7f5326b6" translate="yes" xml:space="preserve">
          <source>You can put any backslash sequence character class (with the exception of &lt;code&gt;\N&lt;/code&gt; and &lt;code&gt;\R&lt;/code&gt;) inside a bracketed character class, and it will act just as if you had put all characters matched by the backslash sequence inside the character class. For instance, &lt;code&gt;[a-f\d]&lt;/code&gt; matches any decimal digit, or any of the lowercase letters between 'a' and 'f' inclusive.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a88a6953f485e8c5fc3aeb601fd219de754900f0" translate="yes" xml:space="preserve">
          <source>You can read from an open filehandle using the &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; operator. In scalar context it reads a single line from the filehandle, and in list context it reads the whole file in, assigning each line to an element of the list:</source>
          <target state="translated">&lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; 연산자를 사용하여 열린 파일 핸들에서 읽을 수 있습니다 . 스칼라 문맥에서는 파일 핸들에서 한 줄을 읽고,리스트 문맥에서는 전체 파일을 읽어 각 줄을 목록의 요소에 할당합니다.</target>
        </trans-unit>
        <trans-unit id="91ab2ef6e453973e41443b71f9d3e34175e99630" translate="yes" xml:space="preserve">
          <source>You can read more about profiling in</source>
          <target state="translated">프로파일 링에 대한 자세한 내용은</target>
        </trans-unit>
        <trans-unit id="00f2324bbf3536a80f241b597db331417bcbe8c1" translate="yes" xml:space="preserve">
          <source>You can redistribute and/or modify this document under the same terms as Perl itself.</source>
          <target state="translated">Perl과 동일한 용어로이 문서를 재배포 및 / 또는 수정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d7dc0e1fc9ad5b87e77bf63d3f4081648cdf49ca" translate="yes" xml:space="preserve">
          <source>You can request that the flock() constants (LOCK_SH, LOCK_EX, LOCK_NB and LOCK_UN) be provided by using the tag &lt;code&gt;:&lt;a href=&quot;functions/flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; . See &lt;a href=&quot;exporter&quot;&gt;Exporter&lt;/a&gt;.</source>
          <target state="translated">당신은 무리 () 상수 (LOCK_SH, LOCK_EX, LOCK_NB 및 LOCK_UN)가 태그를 사용하여 제공하도록 요청할 수 있습니다 &lt;code&gt;:&lt;a href=&quot;functions/flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; . &lt;a href=&quot;exporter&quot;&gt;내보내기를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="bd402063fc23c838fdd082ec0039119a677f8477" translate="yes" xml:space="preserve">
          <source>You can request that the flock() constants (LOCK_SH, LOCK_EX, LOCK_NB and LOCK_UN) be provided by using the tag &lt;code&gt;:flock&lt;/code&gt;. See &lt;a href=&quot;exporter&quot;&gt;Exporter&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9f4701466ab8780e7a2b0e9f2a17e8d0b7017d5" translate="yes" xml:space="preserve">
          <source>You can request that the old constants (FAPPEND, FASYNC, FCREAT, FDEFER, FEXCL, FNDELAY, FNONBLOCK, FSYNC, FTRUNC) be provided for compatibility reasons by using the tag &lt;code&gt;:Fcompat&lt;/code&gt; . For new applications the newer versions of these constants are suggested (O_APPEND, O_ASYNC, O_CREAT, O_DEFER, O_EXCL, O_NDELAY, O_NONBLOCK, O_SYNC, O_TRUNC).</source>
          <target state="translated">&lt;code&gt;:Fcompat&lt;/code&gt; 태그를 사용하여 호환성을 위해 이전 상수 (FAPPEND, FASYNC, FCREAT, FDEFER, FEXCL, FNDELAY, FNONBLOCK, FSYNC, FTRUNC)를 제공하도록 요청할 수 있습니다. 새로운 애플리케이션의 경우 이러한 상수의 최신 버전 (O_APPEND, O_ASYNC, O_CREAT, O_DEFER, O_EXCL, O_NDELAY, O_NONBLOCK, O_SYNC, O_TRUNC)이 제안됩니다.</target>
        </trans-unit>
        <trans-unit id="2443b5b8d3d70bb42e56fa3047f34fa5b05587ad" translate="yes" xml:space="preserve">
          <source>You can request that the old constants (FAPPEND, FASYNC, FCREAT, FDEFER, FEXCL, FNDELAY, FNONBLOCK, FSYNC, FTRUNC) be provided for compatibility reasons by using the tag &lt;code&gt;:Fcompat&lt;/code&gt;. For new applications the newer versions of these constants are suggested (O_APPEND, O_ASYNC, O_CREAT, O_DEFER, O_EXCL, O_NDELAY, O_NONBLOCK, O_SYNC, O_TRUNC).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="caaaaed5194349d7e53889bf69ba7c88d167c7d9" translate="yes" xml:space="preserve">
          <source>You can reset this cache by assigning an empty hashref to it, or individually remove keys.</source>
          <target state="translated">빈 해시 참조를 할당하여 캐시를 재설정하거나 키를 개별적으로 제거 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c4fc671bd928d082df8dcbc4d77c81ac14538200" translate="yes" xml:space="preserve">
          <source>You can retrieve the result via -&amp;gt;data but usually you don't have to because the stringify operator (&quot;&quot;) is overridden to do exactly that.</source>
          <target state="translated">-&amp;gt; data를 통해 결과를 검색 할 수 있지만 stringify 연산자 ( &quot;&quot;)가이를 정확하게 재정의하기 때문에 일반적으로 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1bc6861c31e761832a97f33e3f90e04d306eb3ee" translate="yes" xml:space="preserve">
          <source>You can return the</source>
          <target state="translated">당신은 반환 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="c5203f3ceab8b6b9bc7b6ca2deddcda6d494d3e9" translate="yes" xml:space="preserve">
          <source>You can run a command in the background with:</source>
          <target state="translated">다음을 사용하여 백그라운드에서 명령을 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c92356e98ca4379f9b92a2bcc41db6e953218853" translate="yes" xml:space="preserve">
          <source>You can run all the tests with the following commands:</source>
          <target state="translated">다음 명령을 사용하여 모든 테스트를 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dab3a450deb8a8c4cd405b2e23f88d23efbbf2ec" translate="yes" xml:space="preserve">
          <source>You can run an individual test by a command similar to</source>
          <target state="translated">다음과 유사한 명령으로 개별 테스트를 실행할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="7019e534322025bbdc3a56a0ada6decc0fac6688" translate="yes" xml:space="preserve">
          <source>You can run into similar problems when you store &lt;code&gt;&amp;amp;PL_sv_yes&lt;/code&gt; or &lt;code&gt;&amp;amp;PL_sv_no&lt;/code&gt; into AVs or HVs. Trying to modify such elements will give you the following error:</source>
          <target state="translated">&lt;code&gt;&amp;amp;PL_sv_yes&lt;/code&gt; 또는 &lt;code&gt;&amp;amp;PL_sv_no&lt;/code&gt; 를 AV 또는 HV에 저장할 때 비슷한 문제가 발생할 수 있습니다 . 이러한 요소를 수정하려고하면 다음과 같은 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="48a3f2e45a171b8580b9277e027aa9cbf304aecf" translate="yes" xml:space="preserve">
          <source>You can run part of the test suite by hand by using one of the following commands from the</source>
          <target state="translated">에서 다음 명령 중 하나를 사용하여 테스트 스위트의 일부를 직접 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8428671802bcea1f2c15f381a5fa2ece33821ca0" translate="yes" xml:space="preserve">
          <source>You can safely ignore the line about &quot;prototyping behavior&quot; - it is explained in &lt;a href=&quot;perlxs#The-PROTOTYPES%3A-Keyword&quot;&gt;&quot;The PROTOTYPES: Keyword&quot; in perlxs&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9677002a55994cfb79edd644465223dc6f275627" translate="yes" xml:space="preserve">
          <source>You can safely ignore the line about &quot;prototyping behavior&quot; - it is explained in &lt;a href=&quot;perlxs#The-PROTOTYPES%3a-Keyword&quot;&gt;The PROTOTYPES: Keyword in perlxs&lt;/a&gt;.</source>
          <target state="translated">&quot;프로토 타이핑 동작&quot;에 대한 행을 무시 &lt;a href=&quot;perlxs#The-PROTOTYPES%3a-Keyword&quot;&gt;해도&lt;/a&gt; 됩니다. PROTOTYPES : 키워드의 perlxs에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="00bbb0e9f9b7d267fed175221358a00b2882f0e8" translate="yes" xml:space="preserve">
          <source>You can safely replace &lt;code&gt;isa&lt;/code&gt; with &lt;code&gt;DOES&lt;/code&gt; (although the converse is not true).</source>
          <target state="translated">&lt;code&gt;isa&lt;/code&gt; 를 &lt;code&gt;DOES&lt;/code&gt; 로 안전하게 바꿀 수 있습니다 (대화는 사실이 아니지만).</target>
        </trans-unit>
        <trans-unit id="f3c22b7008ae62adff98ca02982c07c25fd7ebcc" translate="yes" xml:space="preserve">
          <source>You can say &lt;code&gt;*foo{PACKAGE}&lt;/code&gt; and &lt;code&gt;*foo{NAME}&lt;/code&gt; to find out what name and package the *foo symbol table entry comes from. This may be useful in a subroutine that gets passed typeglobs as arguments:</source>
          <target state="translated">당신은 말할 수 &lt;code&gt;*foo{PACKAGE}&lt;/code&gt; 및 &lt;code&gt;*foo{NAME}&lt;/code&gt; 어떤 이름을 발견하고 * foo는 심볼 테이블 엔트리에서 오는 패키징. 이것은 typeglobs를 인수로 전달받는 서브 루틴에서 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1966e0b952d6a25db96c9f73b3f341a3e54cf712" translate="yes" xml:space="preserve">
          <source>You can say &lt;code&gt;BEGIN { $Exporter::Verbose=1 }&lt;/code&gt; to see how the specifications are being processed and what is actually being imported into modules.</source>
          <target state="translated">&lt;code&gt;BEGIN { $Exporter::Verbose=1 }&lt;/code&gt; 이라고 말하면 사양을 처리하는 방법과 실제로 모듈로 가져 오는 내용을 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0ffa8d04bb2be838b7be17e141561b51ef27dbcb" translate="yes" xml:space="preserve">
          <source>You can search CPAN on &lt;a href=&quot;http://metacpan.org&quot;&gt;http://metacpan.org&lt;/a&gt; or &lt;a href=&quot;http://search.cpan.org/&quot;&gt;http://search.cpan.org/&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://metacpan.org&quot;&gt;http://metacpan.org&lt;/a&gt; 또는 &lt;a href=&quot;http://search.cpan.org/&quot;&gt;http://search.cpan.org/&lt;/a&gt; 에서 CPAN을 검색 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="60a987a3bb2545fd9e1606745f4c8b7aa743cafc" translate="yes" xml:space="preserve">
          <source>You can search CPAN on &lt;a href=&quot;http://metacpan.org&quot;&gt;http://metacpan.org&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="decda746759f350cc820cd1383e913824bf2e767" translate="yes" xml:space="preserve">
          <source>You can search for &lt;a href=&quot;threads&quot;&gt;threads&lt;/a&gt; related bug reports at &lt;a href=&quot;http://rt.cpan.org/Public/&quot;&gt;http://rt.cpan.org/Public/&lt;/a&gt;. If needed submit any new bugs, problems, patches, etc. to: &lt;a href=&quot;http://rt.cpan.org/Public/Dist/Display.html?Name=threads&quot;&gt;http://rt.cpan.org/Public/Dist/Display.html?Name=threads&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;http://rt.cpan.org/Public/&quot;&gt;http://rt.cpan.org/Public/&lt;/a&gt; 에서 &lt;a href=&quot;threads&quot;&gt;스레드&lt;/a&gt; 관련 버그 보고서를 검색 할 수 있습니다 . 필요한 경우 새로운 버그, 문제, 패치 등을 다음 주소로 제출하십시오. &lt;a href=&quot;http://rt.cpan.org/Public/Dist/Display.html?Name=threads&quot;&gt;http://rt.cpan.org/Public/Dist/Display.html?Name=threads&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e97ec90c5b6d0afa6264e332a770f1df3b2195d9" translate="yes" xml:space="preserve">
          <source>You can search for &lt;a href=&quot;threads&quot;&gt;threads&lt;/a&gt; related bug reports at &lt;a href=&quot;https://rt.cpan.org/Public/&quot;&gt;https://rt.cpan.org/Public/&lt;/a&gt;. If needed submit any new bugs, problems, patches, etc. to: &lt;a href=&quot;https://rt.cpan.org/Public/Dist/Display.html?Name=threads&quot;&gt;https://rt.cpan.org/Public/Dist/Display.html?Name=threads&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="802f6c1f9273b694e1c0cdbd6edb66de5f11d6b4" translate="yes" xml:space="preserve">
          <source>You can see from the above that the effect of &lt;code&gt;unicode_strings&lt;/code&gt; increased over several Perl releases. (And Perl's support for Unicode continues to improve; it's best to use the latest available release in order to get the most complete and accurate results possible.) Note that &lt;code&gt;unicode_strings&lt;/code&gt; is automatically chosen if you &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; 5.012&lt;/code&gt; or higher.</source>
          <target state="translated">위에서 &lt;code&gt;unicode_strings&lt;/code&gt; 의 효과가 여러 Perl 릴리스에 비해 증가 했음을 알 수 있습니다 . Perl의 유니 코드에 대한 지원은 계속 향상됩니다. 가장 완벽하고 정확한 결과를 얻으려면 사용 가능한 최신 릴리스를 사용하는 것이 가장 좋습니다. &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; 5.012&lt;/code&gt; 이상 을 &lt;a href=&quot;functions/use&quot;&gt;사용하는&lt;/a&gt; 경우 &lt;code&gt;unicode_strings&lt;/code&gt; 가 자동으로 선택됩니다 .</target>
        </trans-unit>
        <trans-unit id="46b2856a8d70679ee475ab545d871ca0c4c93809" translate="yes" xml:space="preserve">
          <source>You can see from the above that the effect of &lt;code&gt;unicode_strings&lt;/code&gt; increased over several Perl releases. (And Perl's support for Unicode continues to improve; it's best to use the latest available release in order to get the most complete and accurate results possible.) Note that &lt;code&gt;unicode_strings&lt;/code&gt; is automatically chosen if you &lt;code&gt;use 5.012&lt;/code&gt; or higher.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd3b0475986391ff28ff08c186138fbea404f4a4" translate="yes" xml:space="preserve">
          <source>You can see recent commits:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="169f5a8ded36f882f89340ed4481186781ecd0dd" translate="yes" xml:space="preserve">
          <source>You can see this with the following:</source>
          <target state="translated">다음과 같이 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f79ce90f40044bb7e9b04185de2c778bbed128b2" translate="yes" xml:space="preserve">
          <source>You can see what files are changed:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a30453af312489e18bd58825504c04b5c3c816c5" translate="yes" xml:space="preserve">
          <source>You can see whether your Perl was built with PerlIO by running &lt;code&gt;perl -V&lt;/code&gt; and looking for the &lt;code&gt;useperlio=&lt;/code&gt; line. If &lt;code&gt;useperlio&lt;/code&gt; is &lt;code&gt;define&lt;/code&gt; , you have PerlIO; otherwise you don't.</source>
          <target state="translated">&lt;code&gt;perl -V&lt;/code&gt; 를 실행 하고 &lt;code&gt;useperlio=&lt;/code&gt; 행을 찾아서 PerlIO로 Perl을 빌드했는지 여부를 확인할 수 있습니다 . 경우 &lt;code&gt;useperlio&lt;/code&gt; 이 있다 &lt;code&gt;define&lt;/code&gt; , 당신은 PerlIO이있다; 그렇지 않으면 당신은하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1d64238a1676682fd78cc68f5aa21599974d313a" translate="yes" xml:space="preserve">
          <source>You can see which (or neither) threading flavour you have by running &lt;code&gt;perl -V&lt;/code&gt; and looking at the &lt;code&gt;Platform&lt;/code&gt; section. If you have &lt;code&gt;useithreads=define&lt;/code&gt; you have ithreads, if you have &lt;code&gt;use5005threads=define&lt;/code&gt; you have 5.005 threads. If you have neither, you don't have any thread support built in. If you have both, you are in trouble.</source>
          <target state="translated">&lt;code&gt;perl -V&lt;/code&gt; 를 실행 하고 &lt;code&gt;Platform&lt;/code&gt; 섹션을 보면 어떤 스레딩 풍미가 있는지 확인할 수 있습니다 . &lt;code&gt;useithreads=define&lt;/code&gt; 이 있으면 ithread 가 있고 , &lt;code&gt;use5005threads=define&lt;/code&gt; 이있는 경우 5.005 스레드가 있습니다. 둘 다 없으면 스레드 지원 기능이 내장되어 있지 않습니다. 둘 다 가지고 있으면 문제가있는 것입니다.</target>
        </trans-unit>
        <trans-unit id="8dc1d6869249a32d7f829c0b3a5e051d9383488b" translate="yes" xml:space="preserve">
          <source>You can see why the arrows are important. Without them, we would have had to write &lt;code&gt;${$a[1]}[2]&lt;/code&gt; instead of &lt;code&gt;$a[1][2]&lt;/code&gt; . For three-dimensional arrays, they let us write &lt;code&gt;$x[2][3][5]&lt;/code&gt; instead of the unreadable &lt;code&gt;${${$x[2]}[3]}[5]&lt;/code&gt; .</source>
          <target state="translated">화살표가 왜 중요한지 알 수 있습니다. 그들없이, 우리는 작성했을 것이다 &lt;code&gt;${$a[1]}[2]&lt;/code&gt; 대신 &lt;code&gt;$a[1][2]&lt;/code&gt; . 3 차원 배열 의 경우 읽을 수없는 &lt;code&gt;${${$x[2]}[3]}[5]&lt;/code&gt; 대신 &lt;code&gt;$x[2][3][5]&lt;/code&gt; 쓸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="317655eca25364352776afb5bed80ace1fea4f49" translate="yes" xml:space="preserve">
          <source>You can see why the arrows are important. Without them, we would have had to write &lt;code&gt;${$a[1]}[2]&lt;/code&gt; instead of &lt;code&gt;$a[1][2]&lt;/code&gt;. For three-dimensional arrays, they let us write &lt;code&gt;$x[2][3][5]&lt;/code&gt; instead of the unreadable &lt;code&gt;${${$x[2]}[3]}[5]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b46ad3852d414e337d72bbed36bfa27c57b29adc" translate="yes" xml:space="preserve">
          <source>You can set and query each of these options interactively in the cpan shell with the &lt;code&gt;o conf&lt;/code&gt; or the &lt;code&gt;o conf init&lt;/code&gt; command as specified below.</source>
          <target state="translated">아래에 지정된대로 &lt;code&gt;o conf&lt;/code&gt; 또는 &lt;code&gt;o conf init&lt;/code&gt; 명령을 사용 하여 cpan 쉘에서 이러한 각 옵션을 대화식으로 설정하고 쿼리 할 수 ​​있습니다 .</target>
        </trans-unit>
        <trans-unit id="16508b3f102bc9307eda4b040c0235215ac4aad7" translate="yes" xml:space="preserve">
          <source>You can set the &lt;code&gt;%POSIX::SIGRT&lt;/code&gt; elements to set the POSIX realtime signal handlers, use &lt;code&gt;&lt;a href=&quot;functions/delete&quot;&gt;delete&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/exists&quot;&gt;exists&lt;/a&gt;&lt;/code&gt; on the elements, and use &lt;code&gt;&lt;a href=&quot;functions/scalar&quot;&gt;scalar&lt;/a&gt;&lt;/code&gt; on the &lt;code&gt;%POSIX::SIGRT&lt;/code&gt; to find out how many POSIX realtime signals there are available &lt;code&gt;(SIGRTMAX - SIGRTMIN + 1&lt;/code&gt; , the &lt;code&gt;SIGRTMAX&lt;/code&gt; is a valid POSIX realtime signal).</source>
          <target state="translated">POSIX 실시간 신호 처리기를 설정하고 요소에 &lt;code&gt;&lt;a href=&quot;functions/delete&quot;&gt;delete&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;functions/exists&quot;&gt;exists&lt;/a&gt;&lt;/code&gt; 를 사용 하고 &lt;code&gt;%POSIX::SIGRT&lt;/code&gt; 에 &lt;code&gt;&lt;a href=&quot;functions/scalar&quot;&gt;scalar&lt;/a&gt;&lt;/code&gt; 를 사용하여 사용 가능한 POSIX 실시간 신호 수를 확인하려면 &lt;code&gt;%POSIX::SIGRT&lt;/code&gt; 요소를 설정할 수 있습니다 &lt;code&gt;(SIGRTMAX - SIGRTMIN + 1&lt;/code&gt; 이면 &lt;code&gt;SIGRTMAX&lt;/code&gt; 는 유효한 POSIX 실시간 신호입니다.</target>
        </trans-unit>
        <trans-unit id="79ff7651cbb8cbdef1e9fddeb8df40c39df09e89" translate="yes" xml:space="preserve">
          <source>You can set the &lt;code&gt;%POSIX::SIGRT&lt;/code&gt; elements to set the POSIX realtime signal handlers, use &lt;code&gt;delete&lt;/code&gt; and &lt;code&gt;exists&lt;/code&gt; on the elements, and use &lt;code&gt;scalar&lt;/code&gt; on the &lt;code&gt;%POSIX::SIGRT&lt;/code&gt; to find out how many POSIX realtime signals there are available &lt;code&gt;(SIGRTMAX - SIGRTMIN + 1&lt;/code&gt;, the &lt;code&gt;SIGRTMAX&lt;/code&gt; is a valid POSIX realtime signal).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f6da332e187deef2beadbe770ab6beeaee593c3" translate="yes" xml:space="preserve">
          <source>You can set the values of the &lt;code&gt;%SIG&lt;/code&gt; hash to be the functions you want to handle the signal. After perl catches the signal, it looks in &lt;code&gt;%SIG&lt;/code&gt; for a key with the same name as the signal, then calls the subroutine value for that key.</source>
          <target state="translated">신호를 처리하려는 함수 가 &lt;code&gt;%SIG&lt;/code&gt; 해시 값을 설정할 수 있습니다 . perl이 신호를 포착 한 후 신호 와 동일한 이름을 가진 키를 &lt;code&gt;%SIG&lt;/code&gt; 에서 찾은 다음 해당 키의 서브 루틴 값을 호출합니다.</target>
        </trans-unit>
        <trans-unit id="4b3c0110aa09f64da5c5df5eac7d33e443e6104d" translate="yes" xml:space="preserve">
          <source>You can set the variable &lt;code&gt;$File::Find::dont_use_nlink&lt;/code&gt; to 0 if you are sure the filesystem you are scanning reflects the number of subdirectories in the parent directory's &lt;code&gt;nlink&lt;/code&gt; count.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bee1469992dc1b9c8f0b603349904e7ab865deb8" translate="yes" xml:space="preserve">
          <source>You can set the variable &lt;code&gt;$File::Find::dont_use_nlink&lt;/code&gt; to 1, if you want to force File::Find to always stat directories. This was used for file systems that do not have an &lt;code&gt;nlink&lt;/code&gt; count matching the number of sub-directories. Examples are ISO-9660 (CD-ROM), AFS, HPFS (OS/2 file system), FAT (DOS file system) and a couple of others.</source>
          <target state="translated">File :: Find를 항상 stat 디렉토리로 강제 설정하려면 &lt;code&gt;$File::Find::dont_use_nlink&lt;/code&gt; 변수를 1로 설정할 수 있습니다 . 서브 디렉토리 수와 일치 하는 &lt;code&gt;nlink&lt;/code&gt; 수 를 갖지 않는 파일 시스템에 사용되었습니다 . 예는 ISO-9660 (CD-ROM), AFS, HPFS (OS / 2 파일 시스템), FAT (DOS 파일 시스템) 및 기타 몇 가지입니다.</target>
        </trans-unit>
        <trans-unit id="5472b025e4a5169aacbf87f4ca700aef907769b9" translate="yes" xml:space="preserve">
          <source>You can set these attributes on the parser object before you call &lt;code&gt;parse_file&lt;/code&gt; (or a similar method) on it:</source>
          <target state="translated">&lt;code&gt;parse_file&lt;/code&gt; (또는 유사한 메소드)을 호출하기 전에 구문 분석기 오브젝트에서 이러한 속성을 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d11091c76638b6f543204cac0351812864021173" translate="yes" xml:space="preserve">
          <source>You can set these with cereg.exe, a (remote) registry editor or via the PerlIDE.</source>
          <target state="translated">cereg.exe, (원격) 레지스트리 편집기 또는 PerlIDE를 통해이를 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a45d7d92f838159f25ad37c4eba92cfbf985fe7f" translate="yes" xml:space="preserve">
          <source>You can set this in your &lt;code&gt;CPAN.pm&lt;/code&gt; configuration so modules automatically install in your private library directory when you use the CPAN.pm shell:</source>
          <target state="translated">&lt;code&gt;CPAN.pm&lt;/code&gt; 구성 에서 이를 설정하면 CPAN.pm 쉘을 사용할 때 개인 라이브러리 디렉토리에 모듈이 자동으로 설치됩니다.</target>
        </trans-unit>
        <trans-unit id="30390221c1f07dd9de6ff3b92b3e83f72d1fc24c" translate="yes" xml:space="preserve">
          <source>You can sometimes</source>
          <target state="translated">때로는 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="7db7fa33c434550059625aa8e8d2392ae86f8c71" translate="yes" xml:space="preserve">
          <source>You can specify a character class, by enclosing a list of characters in &lt;code&gt;[]&lt;/code&gt; , which will match any character from the list. If the first character after the &quot;[&quot; is &quot;^&quot;, the class matches any character not in the list. Within a list, the &quot;-&quot; character specifies a range, so that &lt;code&gt;a-z&lt;/code&gt; represents all characters between &quot;a&quot; and &quot;z&quot;, inclusive. If you want either &quot;-&quot; or &quot;]&quot; itself to be a member of a class, put it at the start of the list (possibly after a &quot;^&quot;), or escape it with a backslash. &quot;-&quot; is also taken literally when it is at the end of the list, just before the closing &quot;]&quot;. (The following all specify the same class of three characters: &lt;code&gt;[-az]&lt;/code&gt; , &lt;code&gt;[az-]&lt;/code&gt; , and &lt;code&gt;[a\-z]&lt;/code&gt; . All are different from &lt;code&gt;[a-z]&lt;/code&gt; , which specifies a class containing twenty-six characters, even on EBCDIC-based character sets.) Also, if you try to use the character classes &lt;code&gt;\w&lt;/code&gt; , &lt;code&gt;\W&lt;/code&gt; , &lt;code&gt;\s&lt;/code&gt;, &lt;code&gt;\S&lt;/code&gt; , &lt;code&gt;\d&lt;/code&gt; , or &lt;code&gt;\D&lt;/code&gt; as endpoints of a range, the &quot;-&quot; is understood literally.</source>
          <target state="translated">문자 목록을 &lt;code&gt;[]&lt;/code&gt; 로 묶어 문자 클래스를 지정할 수 있으며,이 문자는 목록의 모든 문자와 일치합니다. &quot;[&quot;뒤의 첫 문자가 &quot;^&quot;이면 클래스는 목록에없는 문자와 일치합니다. 목록에서 &quot;-&quot;문자는 범위를 지정하므로 &lt;code&gt;a-z&lt;/code&gt; 는 &quot;a&quot;와 &quot;z&quot;사이의 모든 문자를 포함합니다. &quot;-&quot;또는 &quot;]&quot;자체가 클래스의 멤버가되도록하려면 목록의 시작 부분 ( &quot;^&quot;뒤에)에 넣거나 백 슬래시로 이스케이프 처리하십시오. &quot;-&quot;는 목록의 끝에있을 때 문자 그대로 &quot;&quot; &quot;닫기 직전에 나타납니다. (다음은 모두 &lt;code&gt;[-az]&lt;/code&gt; , &lt;code&gt;[az-]&lt;/code&gt; ,그리고 &lt;code&gt;[a\-z]&lt;/code&gt; . 모두 &lt;code&gt;[a-z]&lt;/code&gt; 와 다릅니다EBCDIC 기반 문자 세트에서도 26 개의 문자를 포함하는 클래스를 지정합니다.) 또한 문자 클래스 &lt;code&gt;\w&lt;/code&gt; , &lt;code&gt;\W&lt;/code&gt; , &lt;code&gt;\s&lt;/code&gt; , &lt;code&gt;\S&lt;/code&gt; , &lt;code&gt;\d&lt;/code&gt; 또는 &lt;code&gt;\D&lt;/code&gt; 를 엔드 포인트 로 사용하려고하면 &quot;-&quot;는 문자 그대로 이해됩니다.</target>
        </trans-unit>
        <trans-unit id="26fab1522afd0e2727fdb333919185675d766a45" translate="yes" xml:space="preserve">
          <source>You can specify a precision (for numeric conversions) or a maximum width (for string conversions) by specifying a &lt;code&gt;.&lt;/code&gt; followed by a number. For floating-point formats except &lt;code&gt;g&lt;/code&gt; and &lt;code&gt;G&lt;/code&gt; , this specifies how many places right of the decimal point to show (the default being 6). For example:</source>
          <target state="translated">을 지정하여 정밀도 (숫자 변환의 경우) 또는 최대 너비 (문자열 변환의 경우)를 지정할 수 &lt;code&gt;.&lt;/code&gt; 뒤에 숫자가옵니다. &lt;code&gt;g&lt;/code&gt; 및 &lt;code&gt;G&lt;/code&gt; 를 제외한 부동 소수점 형식 의 경우 소수점 오른쪽에 표시 할 위치 수를 지정합니다 (기본값은 6). 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="eb60daa97062d5b450232fe33f31d785b7b34956" translate="yes" xml:space="preserve">
          <source>You can specify a precision (for numeric conversions) or a maximum width (for string conversions) by specifying a &lt;code&gt;.&lt;/code&gt; followed by a number. For floating-point formats except &lt;code&gt;g&lt;/code&gt; and &lt;code&gt;G&lt;/code&gt;, this specifies how many places right of the decimal point to show (the default being 6). For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7117f36d5a9b63e0e2af83d4187313124e5bec9" translate="yes" xml:space="preserve">
          <source>You can specify a series of alternatives for a pattern using &quot;|&quot; to separate them, so that &lt;code&gt;fee|fie|foe&lt;/code&gt; will match any of &quot;fee&quot;, &quot;fie&quot;, or &quot;foe&quot; in the target string (as would &lt;code&gt;f(e|i|o)e&lt;/code&gt;). The first alternative includes everything from the last pattern delimiter (&quot;(&quot;, &quot;(?:&quot;, etc. or the beginning of the pattern) up to the first &quot;|&quot;, and the last alternative contains everything from the last &quot;|&quot; to the next closing pattern delimiter. That's why it's common practice to include alternatives in parentheses: to minimize confusion about where they start and end.</source>
          <target state="translated">&quot;|&quot;를 사용하여 패턴에 대한 일련의 대안을 지정할 수 있습니다 그 때문에, 그들을 분리하는 &lt;code&gt;fee|fie|foe&lt;/code&gt; &quot;수수료&quot;, &quot;헛소리&quot;, 또는 대상 문자열에 &quot;적&quot;과 일치합니다 (겠습니까의 같은 &lt;code&gt;f(e|i|o)e&lt;/code&gt; ). 첫 번째 대안은 마지막 패턴 구분 기호 ( &quot;(&quot;, &quot;(? :&quot;등 또는 패턴의 시작)부터 첫 번째 &quot;|&quot;까지)를 포함하고 마지막 대안은 마지막 &quot;|&quot; 다음 닫는 패턴 구분 기호에 괄호 안에 대안을 포함시키는 것이 일반적입니다. 시작 및 종료 위치에 대한 혼동을 최소화합니다.</target>
        </trans-unit>
        <trans-unit id="2c0acf2a3cfcada005163c068fb15aa1f1ca963b" translate="yes" xml:space="preserve">
          <source>You can specify several classes to try by joining them with commas or semicolons, as in &lt;code&gt;-MTk::SuperPod;Tk::Pod&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;-MTk::SuperPod;Tk::Pod&lt;/code&gt; 와 같이 쉼표 또는 세미콜론으로 조인하여 시도 할 여러 클래스를 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="641b8e676fa0d8d749c4f8fe7240158e55ec8e1b" translate="yes" xml:space="preserve">
          <source>You can specify several classes to try by joining them with commas or semicolons, as in &lt;code&gt;-MTk::SuperPod;Tk::Pod&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1590cfec6710042ae4b201c340cadca79997b8f8" translate="yes" xml:space="preserve">
          <source>You can stop using AutoLoader by simply</source>
          <target state="translated">간단하게 AutoLoader 사용을 중지 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="2a07cd3fd8cff327607dbfc5239cb17fe58be132" translate="yes" xml:space="preserve">
          <source>You can subclass an existing HashBase class.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1eb2363990bc861a2294e72254c60f889449d2d6" translate="yes" xml:space="preserve">
          <source>You can switch encodings on an already opened stream by using &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode()&lt;/a&gt;&lt;/code&gt;; see &lt;a href=&quot;functions/binmode&quot;&gt;binmode&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode()&lt;/a&gt;&lt;/code&gt; 를 사용하여 이미 열린 스트림에서 인코딩을 전환 할 수 있습니다 . &lt;a href=&quot;functions/binmode&quot;&gt;binmode를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="408bf98559257c5c2b42f635092e2cb73454caf6" translate="yes" xml:space="preserve">
          <source>You can switch encodings on an already opened stream by using &lt;code&gt;binmode()&lt;/code&gt;; see &lt;a href=&quot;perlfunc#binmode&quot;&gt;&quot;binmode&quot; in perlfunc&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad4a77a592ef4f50bebb75551ecc777ec47349e4" translate="yes" xml:space="preserve">
          <source>You can switch locales as often as you wish at run time with the &lt;code&gt;POSIX::setlocale()&lt;/code&gt; function:</source>
          <target state="translated">&lt;code&gt;POSIX::setlocale()&lt;/code&gt; 함수를 사용하여 런타임에 원하는만큼 로케일을 전환 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4591a0f85fb87cbd2147c9e7634ca2d54faf481c" translate="yes" xml:space="preserve">
          <source>You can tell if using locales is safe on your system by looking at the read-only boolean variable &lt;code&gt;${^SAFE_LOCALES}&lt;/code&gt;. The value is 1 if the perl is not threaded, or if it is using thread-safe locale operations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d35fb0ec3f2c6e87bec34d10cff3e1fa0aa39f99" translate="yes" xml:space="preserve">
          <source>You can test for these with Perl's &lt;b&gt;-S&lt;/b&gt; file test:</source>
          <target state="translated">Perl의 &lt;b&gt;-S&lt;/b&gt; 파일 테스트 를 통해이를 테스트 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="33cabbc3e6b78a04641195c801755295c5b1770a" translate="yes" xml:space="preserve">
          <source>You can test out changing these variables temporarily, and if the new settings seem to help, put those settings into your shell startup files. Consult your local documentation for the exact details. For Bourne-like shells (&lt;b&gt;sh&lt;/b&gt;, &lt;b&gt;ksh&lt;/b&gt;, &lt;b&gt;bash&lt;/b&gt;, &lt;b&gt;zsh&lt;/b&gt;):</source>
          <target state="translated">이러한 변수의 변경을 일시적으로 테스트 할 수 있으며 새로운 설정이 도움이되는 경우 해당 설정을 쉘 시작 파일에 넣으십시오. 자세한 내용은 지역 설명서를 참조하십시오. Bourne과 같은 쉘 ( &lt;b&gt;sh&lt;/b&gt; , &lt;b&gt;ksh&lt;/b&gt; , &lt;b&gt;bash&lt;/b&gt; , &lt;b&gt;zsh&lt;/b&gt; )의 경우 :</target>
        </trans-unit>
        <trans-unit id="9aef87ade0298c8e39a512c631e34755f8d99a1d" translate="yes" xml:space="preserve">
          <source>You can test whether an SV is using copy-on-write with &lt;code&gt;SvIsCOW(sv)&lt;/code&gt; .</source>
          <target state="translated">SV가 &lt;code&gt;SvIsCOW(sv)&lt;/code&gt; 와 함께 COW ( Copy-On-Write)를 사용 중인지 테스트 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="397833f042c8b1f602c31dae872891a03b284f7c" translate="yes" xml:space="preserve">
          <source>You can test whether an SV is using copy-on-write with &lt;code&gt;SvIsCOW(sv)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb7b765496cd5db87bb4e9bf905826761c1ac026" translate="yes" xml:space="preserve">
          <source>You can therefore save time by reusing this object as follows;</source>
          <target state="translated">따라서이 객체를 다음과 같이 재사용하여 시간을 절약 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9025bea13f42c28d6d27d405ef555cfdfb67e0c5" translate="yes" xml:space="preserve">
          <source>You can think of &lt;code&gt;&lt;a href=&quot;functions/ref&quot;&gt;ref&lt;/a&gt;&lt;/code&gt; as a &lt;code&gt;typeof&lt;/code&gt; operator.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/ref&quot;&gt;ref&lt;/a&gt;&lt;/code&gt; 를 &lt;code&gt;typeof&lt;/code&gt; 연산자 로 생각할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="cf104869dd9c15f6376b764dcf7d585d45ca8039" translate="yes" xml:space="preserve">
          <source>You can think of &lt;code&gt;&lt;a href=&quot;ref&quot;&gt;ref&lt;/a&gt;&lt;/code&gt; as a &lt;code&gt;typeof&lt;/code&gt; operator.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ref&quot;&gt;ref&lt;/a&gt;&lt;/code&gt; 를 &lt;code&gt;typeof&lt;/code&gt; 연산자 로 생각할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="728882433c08d9f5799a415b920db42fb16d9b1c" translate="yes" xml:space="preserve">
          <source>You can think of a module as the fundamental unit of reusable Perl code; see &lt;a href=&quot;perlmod&quot;&gt;perlmod&lt;/a&gt; for details. Whenever anyone creates a chunk of Perl code that they think will be useful to the world, they register as a Perl developer at &lt;a href=&quot;http://www.cpan.org/modules/04pause.html&quot;&gt;http://www.cpan.org/modules/04pause.html&lt;/a&gt; so that they can then upload their code to the CPAN. The CPAN is the Comprehensive Perl Archive Network and can be accessed at &lt;a href=&quot;http://www.cpan.org/&quot;&gt;http://www.cpan.org/&lt;/a&gt; , and searched at &lt;a href=&quot;http://search.cpan.org/&quot;&gt;http://search.cpan.org/&lt;/a&gt; .</source>
          <target state="translated">모듈을 재사용 가능한 Perl 코드의 기본 단위로 생각할 수 있습니다. 자세한 내용은 &lt;a href=&quot;perlmod&quot;&gt;perlmod&lt;/a&gt; 를 참조하십시오. 누구나 세상에 유용하다고 생각되는 Perl 코드 덩어리를 만들 때마다 &lt;a href=&quot;http://www.cpan.org/modules/04pause.html&quot;&gt;http://www.cpan.org/modules/04pause.html&lt;/a&gt; 에서 Perl 개발자로 등록 하여 코드를 CPAN. CPAN은 포괄적 인 Perl 아카이브 네트워크이며 &lt;a href=&quot;http://www.cpan.org/&quot;&gt;http://www.cpan.org/&lt;/a&gt; 에서 액세스 하고 &lt;a href=&quot;http://search.cpan.org/&quot;&gt;http://search.cpan.org/&lt;/a&gt; 에서 검색 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f66f02858677c3e7654c4ad6291c3ba16be82841" translate="yes" xml:space="preserve">
          <source>You can think of a module as the fundamental unit of reusable Perl code; see &lt;a href=&quot;perlmod&quot;&gt;perlmod&lt;/a&gt; for details. Whenever anyone creates a chunk of Perl code that they think will be useful to the world, they register as a Perl developer at &lt;a href=&quot;https://www.cpan.org/modules/04pause.html&quot;&gt;https://www.cpan.org/modules/04pause.html&lt;/a&gt; so that they can then upload their code to the CPAN. The CPAN is the Comprehensive Perl Archive Network and can be accessed at &lt;a href=&quot;https://www.cpan.org/&quot;&gt;https://www.cpan.org/&lt;/a&gt; , and searched at &lt;a href=&quot;https://metacpan.org/&quot;&gt;https://metacpan.org/&lt;/a&gt; .</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="969f96d8ec4df0c71d177e6b1625408e665ae979" translate="yes" xml:space="preserve">
          <source>You can tie the cache tables to any sort of tied hash that you want to, as long as it supports &lt;code&gt;TIEHASH&lt;/code&gt; , &lt;code&gt;FETCH&lt;/code&gt; , &lt;code&gt;STORE&lt;/code&gt; , and &lt;code&gt;EXISTS&lt;/code&gt; . For example,</source>
          <target state="translated">캐시 테이블이 &lt;code&gt;TIEHASH&lt;/code&gt; , &lt;code&gt;FETCH&lt;/code&gt; , &lt;code&gt;STORE&lt;/code&gt; 및 &lt;code&gt;EXISTS&lt;/code&gt; 를 지원하는 한 원하는 모든 종류의 묶인 해시에 연결할 수 있습니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="067fb5762580d2bd9d11414d9eb17e488c70c98d" translate="yes" xml:space="preserve">
          <source>You can tie the cache tables to any sort of tied hash that you want to, as long as it supports &lt;code&gt;TIEHASH&lt;/code&gt;, &lt;code&gt;FETCH&lt;/code&gt;, &lt;code&gt;STORE&lt;/code&gt;, and &lt;code&gt;EXISTS&lt;/code&gt;. For example,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5dff5882ff33a85a3a95fb0e709084606bfc8485" translate="yes" xml:space="preserve">
          <source>You can try using encryption via source filters (Filter::* from CPAN, or Filter::Util::Call and Filter::Simple since Perl 5.8). But crackers might be able to decrypt it. You can try using the byte code compiler and interpreter described below, but crackers might be able to de-compile it. You can try using the native-code compiler described below, but crackers might be able to disassemble it. These pose varying degrees of difficulty to people wanting to get at your code, but none can definitively conceal it (this is true of every language, not just Perl).</source>
          <target state="translated">소스 필터 (CPAN의 Filter :: * 또는 Perl 5.8 이후 Filter :: Util :: Call 및 Filter :: Simple)를 통해 암호화를 사용해 볼 수 있습니다. 그러나 크래커가 해독 할 수 있습니다. 아래에 설명 된 바이트 코드 컴파일러와 인터프리터를 사용해 볼 수 있지만 크래커가 디 컴파일 할 수 있습니다. 아래에 설명 된 네이티브 코드 컴파일러를 사용해 볼 수 있지만 크래커가이를 분해 할 수 있습니다. 이것들은 코드를 얻고 자하는 사람들에게 다양한 정도의 어려움을 초래하지만, 아무도 그것을 숨길 수는 없습니다 (Perl뿐만 아니라 모든 언어에 해당됩니다).</target>
        </trans-unit>
        <trans-unit id="bd149095683892a2c8050e33a089a96e4ba58ba3" translate="yes" xml:space="preserve">
          <source>You can try using encryption via source filters (Starting from Perl 5.8 the Filter::Simple and Filter::Util::Call modules are included in the standard distribution), but any decent programmer will be able to decrypt it. You can try using the byte code compiler and interpreter described later in &lt;a href=&quot;perlfaq3&quot;&gt;perlfaq3&lt;/a&gt;, but the curious might still be able to de-compile it. You can try using the native-code compiler described later, but crackers might be able to disassemble it. These pose varying degrees of difficulty to people wanting to get at your code, but none can definitively conceal it (true of every language, not just Perl).</source>
          <target state="translated">소스 필터 (Perl 5.8에서 시작하여 Filter :: Simple 및 Filter :: Util :: Call 모듈이 표준 배포에 포함됨)를 통해 암호화를 사용해 볼 수 있지만 괜찮은 프로그래머는이를 해독 할 수 있습니다. &lt;a href=&quot;perlfaq3&quot;&gt;perlfaq3&lt;/a&gt; 에서 나중에 설명하는 바이트 코드 컴파일러 및 인터프리터를 사용해 볼 수 있지만 궁금한 점이 여전히 디 컴파일 할 수 있습니다. 나중에 설명 할 네이티브 코드 컴파일러를 사용해 볼 수 있지만 크래커가이를 분해 할 수 있습니다. 이것들은 코드를 얻고 자하는 사람들에게 다양한 정도의 어려움을 초래하지만, 아무도 그것을 숨길 수는 없습니다 (Perl뿐만 아니라 모든 언어에 해당).</target>
        </trans-unit>
        <trans-unit id="2b09b812e89e288611a3620bc913b5b1b0fe4650" translate="yes" xml:space="preserve">
          <source>You can turn off that eagerness-to-help by declaring an attribute handler with the keyword &lt;code&gt;RAWDATA&lt;/code&gt; . For example:</source>
          <target state="translated">키워드 &lt;code&gt;RAWDATA&lt;/code&gt; 로 속성 핸들러를 선언하여 도움이되는 열망을 끌 수 있습니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="411d0a05d6b5a0d470da1b804c20182fb7f3b7be" translate="yes" xml:space="preserve">
          <source>You can turn off that eagerness-to-help by declaring an attribute handler with the keyword &lt;code&gt;RAWDATA&lt;/code&gt;. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f49d0ea6561f21345168a93b25795d827d9b3e56" translate="yes" xml:space="preserve">
          <source>You can use &lt;a href=&quot;#%28%3F%23text%29&quot;&gt;&quot;(?#text)&quot;&lt;/a&gt; to create a comment that ends earlier than the end of the current line, but &lt;code&gt;text&lt;/code&gt; also can't contain the closing delimiter unless escaped with a backslash.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5701868a13c5d43cf7a782ca599e3f4284f18bb" translate="yes" xml:space="preserve">
          <source>You can use &lt;a href=&quot;#(%3f%23text)&quot;&gt;(?#text)&lt;/a&gt; to create a comment that ends earlier than the end of the current line, but &lt;code&gt;text&lt;/code&gt; also can't contain the closing delimiter unless escaped with a backslash.</source>
          <target state="translated">당신은 사용할 수 있습니다 &lt;a href=&quot;#(%3f%23text)&quot;&gt;(?하는 #text)를&lt;/a&gt; 끝 이전 현재 행의 끝보다하지만 코멘트를 작성하는 &lt;code&gt;text&lt;/code&gt; 백 슬래시로 이스케이프가 아니면 닫는 구분 기호를 포함 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="46e1962292f1a1a38164468a62659371a7ced694" translate="yes" xml:space="preserve">
          <source>You can use &lt;a href=&quot;#prop_values%28%29&quot;&gt;&quot;prop_values()&quot;&lt;/a&gt; to find out if a given property is one which has a restricted set of values, and if so, what those values are. But usually each value actually has several synonyms. For example, in Unicode binary properties,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d944fb3215d0dd16d4105b924d26c8f26a00944" translate="yes" xml:space="preserve">
          <source>You can use &lt;a href=&quot;#prop_values()&quot;&gt;prop_values()&lt;/a&gt; to find out if a given property is one which has a restricted set of values, and if so, what those values are. But usually each value actually has several synonyms. For example, in Unicode binary properties,</source>
          <target state="translated">&lt;a href=&quot;#prop_values()&quot;&gt;prop_values ​​()&lt;/a&gt; 를 사용 하여 주어진 속성이 제한된 값 집합을 가진 속성인지 확인하고, 그렇다면 해당 값이 무엇인지 확인할 수 있습니다. 그러나 일반적으로 각 값에는 실제로 여러 동의어가 있습니다. 예를 들어 유니 코드 이진 속성에서</target>
        </trans-unit>
        <trans-unit id="53b328e86a1c8561fad7e05704d7dac310eecbe7" translate="yes" xml:space="preserve">
          <source>You can use &lt;a href=&quot;Number::Format&quot;&gt;Number::Format&lt;/a&gt; to separate places in a number. It handles locale information for those of you who want to insert full stops instead (or anything else that they want to use, really).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1c9a75863cb6d9c190a426b8b3063cbac50315b" translate="yes" xml:space="preserve">
          <source>You can use &lt;a href=&quot;URI::Find&quot;&gt;URI::Find&lt;/a&gt; or &lt;a href=&quot;URL::Search&quot;&gt;URL::Search&lt;/a&gt; to extract URLs from an arbitrary text document.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b53d0563bc5da053955b9d3b7d437fbd188f8795" translate="yes" xml:space="preserve">
          <source>You can use &lt;a href=&quot;http://search.cpan.org/perldoc/Number::Format&quot;&gt;Number::Format&lt;/a&gt; to separate places in a number. It handles locale information for those of you who want to insert full stops instead (or anything else that they want to use, really).</source>
          <target state="translated">&lt;a href=&quot;http://search.cpan.org/perldoc/Number::Format&quot;&gt;Number :: Format&lt;/a&gt; 을 사용 하여 숫자로 장소를 구분할 수 있습니다. 대신 전체 중지를 삽입하려는 사용자 (또는 실제로 사용하려는 다른 것)의 로캘 정보를 처리합니다.</target>
        </trans-unit>
        <trans-unit id="49f5dd665c5e9d2b71ecb4caa05c28940c8fc3d9" translate="yes" xml:space="preserve">
          <source>You can use &lt;a href=&quot;http://search.cpan.org/perldoc/URI::Find&quot;&gt;URI::Find&lt;/a&gt; to extract URLs from an arbitrary text document.</source>
          <target state="translated">&lt;a href=&quot;http://search.cpan.org/perldoc/URI::Find&quot;&gt;URI :: Find&lt;/a&gt; 를 사용하여 임의의 텍스트 문서에서 URL을 추출 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7fe2956ea1b7c9e1e517ba013b7204dc28c702c8" translate="yes" xml:space="preserve">
          <source>You can use &lt;b&gt;-C0&lt;/b&gt; (or &lt;code&gt;&quot;0&quot;&lt;/code&gt; for &lt;code&gt;PERL_UNICODE&lt;/code&gt; ) to explicitly disable all the above Unicode features.</source>
          <target state="translated">당신이 사용할 수있는 &lt;b&gt;-C0&lt;/b&gt; (또는 &lt;code&gt;&quot;0&quot;&lt;/code&gt; 에 대한 &lt;code&gt;PERL_UNICODE&lt;/code&gt; 명시 적으로 사용하지 않도록 설정하는) 모든 유니 위의 특징.</target>
        </trans-unit>
        <trans-unit id="463dcf8fc0cca782c4e0e34c3ad93d1f8a2e69a8" translate="yes" xml:space="preserve">
          <source>You can use &lt;b&gt;-C0&lt;/b&gt; (or &lt;code&gt;&quot;0&quot;&lt;/code&gt; for &lt;code&gt;PERL_UNICODE&lt;/code&gt;) to explicitly disable all the above Unicode features.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8820cb36e9b0a2ef9812096c3ae47e4337e70f22" translate="yes" xml:space="preserve">
          <source>You can use &lt;code&gt;-w optionname&lt;/code&gt; (without a value) as shorthand for &lt;code&gt;-w optionname:&lt;i&gt;TRUE&lt;/i&gt;&lt;/code&gt;. This is presumably useful in cases of on/off features like: &lt;code&gt;-w page_numbering&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;-w optionname:&lt;i&gt;TRUE&lt;/i&gt;&lt;/code&gt; &lt;i&gt;TRUE의&lt;/i&gt; 약어로 &lt;code&gt;-w optionname&lt;/code&gt; (값없이)을 사용할 수 있습니다 . 이것은 &lt;code&gt;-w page_numbering&lt;/code&gt; 과 같은 on / off 기능의 경우에 유용합니다 .&lt;i&gt;&lt;/i&gt;</target>
        </trans-unit>
        <trans-unit id="d92d50a80d7de3bbc1a703e905f54b306c769ca9" translate="yes" xml:space="preserve">
          <source>You can use &lt;code&gt;-w optionname&lt;/code&gt; (without a value) as shorthand for &lt;code&gt;-w optionname:&lt;i&gt;TRUE&lt;/i&gt;&lt;/code&gt;. This is presumably useful in cases of on/off features like: &lt;code&gt;-w page_numbering&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b34722383d4a6c958172dfe61f02074274ede7a9" translate="yes" xml:space="preserve">
          <source>You can use &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt; without parentheses to locate the end of each input file, in case you want to append to each file, or reset line numbering (see example in &lt;a href=&quot;functions/eof&quot;&gt;eof&lt;/a&gt;).</source>
          <target state="translated">당신은 사용할 수 있습니다 &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt; 경우에 각 파일 또는 리셋 라인 번호 (예 참조에 추가하려는 각 입력 파일의 끝을 괄호없이 &lt;a href=&quot;functions/eof&quot;&gt;EOF를&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="7509178f0cc142ffa6970d993aa78a311665535a" translate="yes" xml:space="preserve">
          <source>You can use &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; if the columns are separated by whitespace or some other delimiter, as long as whitespace or the delimiter cannot appear as part of the data.</source>
          <target state="translated">공백이나 구분 기호가 데이터의 일부로 표시되지 않는 한 열이 공백이나 다른 구분 기호로 분리 된 경우 &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; 을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6118fe862d5ba72dadefc97ab80da97946efe653" translate="yes" xml:space="preserve">
          <source>You can use &lt;code&gt;eof&lt;/code&gt; without parentheses to locate the end of each input file, in case you want to append to each file, or reset line numbering (see example in &lt;a href=&quot;perlfunc#eof&quot;&gt;&quot;eof&quot; in perlfunc&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a9d607e237fddf53d59f7e552edb64a49ae50a5" translate="yes" xml:space="preserve">
          <source>You can use &lt;code&gt;no Test2::IPC;&lt;/code&gt; to disable IPC for good. You can also use the T2_NO_IPC env var.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8daea58cf28c3fae97111d40d3f6273a0428003e" translate="yes" xml:space="preserve">
          <source>You can use &lt;code&gt;split&lt;/code&gt; if the columns are separated by whitespace or some other delimiter, as long as whitespace or the delimiter cannot appear as part of the data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="207bd81996c41f563d70786505a61f566bf7c9d1" translate="yes" xml:space="preserve">
          <source>You can use Andreas Koenig's CPAN module ( &lt;a href=&quot;http://www.cpan.org/modules/by-module/CPAN&quot;&gt;http://www.cpan.org/modules/by-module/CPAN&lt;/a&gt; ) to automate the following steps, from DECOMPRESS through INSTALL.</source>
          <target state="translated">Andreas Koenig의 CPAN 모듈 ( &lt;a href=&quot;http://www.cpan.org/modules/by-module/CPAN&quot;&gt;http://www.cpan.org/modules/by-module/CPAN&lt;/a&gt; )을 사용하여 DECOMPRESS에서 INSTALL에 이르기까지 다음 단계를 자동화 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e7b5250e276d656c30117b7ccc528681aa0fdc2f" translate="yes" xml:space="preserve">
          <source>You can use Andreas Koenig's CPAN module ( &lt;a href=&quot;https://metacpan.org/release/CPAN&quot;&gt;https://metacpan.org/release/CPAN&lt;/a&gt; ) to automate the following steps, from DECOMPRESS through INSTALL.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a4fa2e9a279c718478efb15dbd58f3963c395b2" translate="yes" xml:space="preserve">
          <source>You can use Perl's somewhat exotic &lt;code&gt;..&lt;/code&gt; operator (documented in &lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt;):</source>
          <target state="translated">Perl의 다소 이국적인 &lt;code&gt;..&lt;/code&gt; 연산자를 사용할 수 있습니다 ( &lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt; 문서로 작성 ).</target>
        </trans-unit>
        <trans-unit id="0352c7c82515615be31fde318d8a078c0a2c1a97" translate="yes" xml:space="preserve">
          <source>You can use a leading underscore to indicate that a variable or function should not be used outside the package that defined it.</source>
          <target state="translated">선행 밑줄을 사용하여 변수 또는 함수를 정의한 패키지 외부에서 사용해서는 안됨을 나타낼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="388231cbd33477282c1e5dc7ff7aa725ad26b114" translate="yes" xml:space="preserve">
          <source>You can use a string as if it were a reference. If you use the string &lt;code&gt;&quot;foo&quot;&lt;/code&gt; as an array reference, it's taken to be a reference to the array &lt;code&gt;@foo&lt;/code&gt; . This is called a</source>
          <target state="translated">문자열을 참조 인 것처럼 사용할 수 있습니다. 문자열 &lt;code&gt;&quot;foo&quot;&lt;/code&gt; 를 배열 참조로 사용하면 배열 &lt;code&gt;@foo&lt;/code&gt; 에 대한 참조로 간주됩니다 . 이것은</target>
        </trans-unit>
        <trans-unit id="f196929f5477404a496f1eb939b7d7fae56076c9" translate="yes" xml:space="preserve">
          <source>You can use a string as if it were a reference. If you use the string &lt;code&gt;&quot;foo&quot;&lt;/code&gt; as an array reference, it's taken to be a reference to the array &lt;code&gt;@foo&lt;/code&gt;. This is called a</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="adc3bc3485dafe6de0835e8cb890731728d4f233" translate="yes" xml:space="preserve">
          <source>You can use an &quot;=&quot; instead of the &quot;:&quot;, as in: &lt;code&gt;-w textsize=15&lt;/code&gt; . This might be more (or less) convenient, depending on what shell you use.</source>
          <target state="translated">&lt;code&gt;-w textsize=15&lt;/code&gt; 와 같이 &quot;:&quot;대신 &quot;=&quot;를 사용할 수 있습니다 . 어떤 쉘을 사용 하느냐에 따라 더 편리 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="574332bc08377fe482a2062d389f5bfcb77e4baa" translate="yes" xml:space="preserve">
          <source>You can use an &quot;=&quot; instead of the &quot;:&quot;, as in: &lt;code&gt;-w textsize=15&lt;/code&gt;. This might be more (or less) convenient, depending on what shell you use.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72421369c1a6f65beaf183288338ba69c655cf15" translate="yes" xml:space="preserve">
          <source>You can use an alternative library to drive Math::BigInt. See the section &lt;a href=&quot;#MATH-LIBRARY&quot;&gt;&quot;MATH LIBRARY&quot;&lt;/a&gt; for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="659b448e1309e418ec405468f01e562189ac5581" translate="yes" xml:space="preserve">
          <source>You can use an alternative library to drive Math::BigInt. See the section &lt;a href=&quot;#MATH-LIBRARY&quot;&gt;MATH LIBRARY&lt;/a&gt; for more information.</source>
          <target state="translated">대체 라이브러리를 사용하여 Math :: BigInt를 구동 할 수 있습니다. 자세한 내용은 &lt;a href=&quot;#MATH-LIBRARY&quot;&gt;MATH LIBRARY&lt;/a&gt; 섹션 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="f7c7a81f2a96d58e5477ffb42832551e4a65a1ae" translate="yes" xml:space="preserve">
          <source>You can use and redistribute this document under the same terms as Perl itself.</source>
          <target state="translated">Perl 자체와 동일한 용어로이 문서를 사용하고 재배포 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="02346143e059d2c6966f5b1da988acae6f664ce7" translate="yes" xml:space="preserve">
          <source>You can use another collation element table if desired.</source>
          <target state="translated">원하는 경우 다른 데이터 정렬 요소 테이블을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="80ffd7e86ab2f265c3b1b5af5301c88022dfacbd" translate="yes" xml:space="preserve">
          <source>You can use any combination of the methods from none to all four.</source>
          <target state="translated">none에서 four까지 방법의 조합을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="727cc3b9105721ca57e170521deb86b9cfbaaa16" translate="yes" xml:space="preserve">
          <source>You can use any combination of the methods, from none, to all four.</source>
          <target state="translated">없음에서 네 가지 방법 모두를 조합하여 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d63724145019d1ea36fba22c0caf955250b6107a" translate="yes" xml:space="preserve">
          <source>You can use either &lt;code&gt;filter()&lt;/code&gt; or &lt;code&gt;pre_filter()&lt;/code&gt;, depending on your needs. Both have identical syntax, so only &lt;code&gt;filter()&lt;/code&gt; is shown here.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6cf084acc213926a976c0b6e7b2d7ff58c8a1c98" translate="yes" xml:space="preserve">
          <source>You can use formatting codes in ordinary paragraphs, for &lt;b&gt;bold&lt;/b&gt;,</source>
          <target state="translated">&lt;b&gt;굵은 글씨&lt;/b&gt; 로 일반 단락에 서식 코드를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7b0f4d35c03dc40ee00f05e56f139894c4c251ca" translate="yes" xml:space="preserve">
          <source>You can use it as follows:</source>
          <target state="translated">다음과 같이 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cfbc7862683635b53050e53b7defa0eddc13b749" translate="yes" xml:space="preserve">
          <source>You can use more than one source filter on a single file. Similarly, you can reuse the same filter in as many files as you like.</source>
          <target state="translated">단일 파일에서 둘 이상의 소스 필터를 사용할 수 있습니다. 마찬가지로, 원하는만큼 많은 파일에서 동일한 필터를 재사용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cb2c65d2dbc0740833a918a76d1bf6977975706a" translate="yes" xml:space="preserve">
          <source>You can use parentheses for functions' arguments or omit them according to your personal taste. They are only required occasionally to clarify issues of precedence.</source>
          <target state="translated">함수의 인수에 괄호를 사용하거나 개인 취향에 따라 생략 할 수 있습니다. 우선 순위 문제를 명확히하기 위해 가끔 필요합니다.</target>
        </trans-unit>
        <trans-unit id="78045ec633e87e0c82678bcb8abea9b50b38e139" translate="yes" xml:space="preserve">
          <source>You can use that same structure to count the entries any way that you like. If you want the count of the keys with vowels in them, you just test for that instead:</source>
          <target state="translated">동일한 구조를 사용하여 원하는 방식으로 항목을 계산할 수 있습니다. 모음이있는 키의 수를 원한다면 대신 테스트하십시오.</target>
        </trans-unit>
        <trans-unit id="1690d1523426f507501d7105b1df0c66115ba59a" translate="yes" xml:space="preserve">
          <source>You can use the &lt;a href=&quot;#substr-EXPR%2COFFSET%2CLENGTH%2CREPLACEMENT&quot;&gt;&lt;code&gt;substr&lt;/code&gt;&lt;/a&gt; function as an lvalue, in which case EXPR must itself be an lvalue. If you assign something shorter than LENGTH, the string will shrink, and if you assign something longer than LENGTH, the string will grow to accommodate it. To keep the string the same length, you may need to pad or chop your value using &lt;a href=&quot;#sprintf-FORMAT%2C-LIST&quot;&gt;&lt;code&gt;sprintf&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8f3236da7ba1e40bfd7a845e9acaf4bc53886e9" translate="yes" xml:space="preserve">
          <source>You can use the &lt;a href=&quot;File::Random&quot;&gt;File::Random&lt;/a&gt; module which provides a function for that algorithm:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2ff1d721e6d422eb2eb3595a270ae28f16f631d" translate="yes" xml:space="preserve">
          <source>You can use the &lt;a href=&quot;Term::ANSIScreen&quot;&gt;Term::ANSIScreen&lt;/a&gt; module to get the special sequence. Import the &lt;code&gt;cls&lt;/code&gt; function (or the &lt;code&gt;:screen&lt;/code&gt; tag):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6328463814d0d727ad78cc1185df620969d34550" translate="yes" xml:space="preserve">
          <source>You can use the &lt;a href=&quot;Time::JulianDay&quot;&gt;Time::JulianDay&lt;/a&gt; module available on CPAN. Ensure that you really want to find a Julian day, though, as many people have different ideas about Julian days (see &lt;a href=&quot;http://www.hermetic.ch/cal_stud/jdn.htm&quot;&gt;http://www.hermetic.ch/cal_stud/jdn.htm&lt;/a&gt; for instance):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3fd3c53d8040ec103bb8a5c0b0a769aa081bccb4" translate="yes" xml:space="preserve">
          <source>You can use the &lt;a href=&quot;Time::Piece&quot;&gt;Time::Piece&lt;/a&gt; module, part of the Standard Library, which can convert a date/time to a Julian Day:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="264d904732b18badb8f8af0ee614fe938cb62fd3" translate="yes" xml:space="preserve">
          <source>You can use the &lt;a href=&quot;http://search.cpan.org/perldoc/File::Random&quot;&gt;File::Random&lt;/a&gt; module which provides a function for that algorithm:</source>
          <target state="translated">해당 알고리즘에 대한 기능을 제공하는 &lt;a href=&quot;http://search.cpan.org/perldoc/File::Random&quot;&gt;File :: Random&lt;/a&gt; 모듈을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="12dc43addaceb3325735b42235a5db7b043fe8e8" translate="yes" xml:space="preserve">
          <source>You can use the &lt;a href=&quot;http://search.cpan.org/perldoc/Term::ANSIScreen&quot;&gt;Term::ANSIScreen&lt;/a&gt; module to get the special sequence. Import the &lt;code&gt;cls&lt;/code&gt; function (or the &lt;code&gt;:screen&lt;/code&gt; tag):</source>
          <target state="translated">&lt;a href=&quot;http://search.cpan.org/perldoc/Term::ANSIScreen&quot;&gt;Term :: ANSIScreen&lt;/a&gt; 모듈을 사용하여 특수 시퀀스를 얻을 수 있습니다 . &lt;code&gt;cls&lt;/code&gt; 함수 (또는 &lt;code&gt;:screen&lt;/code&gt; 태그)를 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="5e45dc25f4fd438a13c8ce07a9424e43bd367039" translate="yes" xml:space="preserve">
          <source>You can use the &lt;a href=&quot;http://search.cpan.org/perldoc/Time::JulianDay&quot;&gt;Time::JulianDay&lt;/a&gt; module available on CPAN. Ensure that you really want to find a Julian day, though, as many people have different ideas about Julian days (see &lt;a href=&quot;http://www.hermetic.ch/cal_stud/jdn.htm&quot;&gt;http://www.hermetic.ch/cal_stud/jdn.htm&lt;/a&gt; for instance):</source>
          <target state="translated">당신은 사용 &lt;a href=&quot;http://search.cpan.org/perldoc/Time::JulianDay&quot;&gt;시간 : JULIANDAY의&lt;/a&gt; CPAN에서 사용 가능한 모듈을. 많은 사람들이 율리우스 일에 대해 다른 생각을 가지고 있기 때문에 율리우스 일을 정말로 찾고 싶습니다 ( 예 : &lt;a href=&quot;http://www.hermetic.ch/cal_stud/jdn.htm&quot;&gt;http://www.hermetic.ch/cal_stud/jdn.htm&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="ba1788ef1bedfa0514aebf9080742800f7823493" translate="yes" xml:space="preserve">
          <source>You can use the &lt;a href=&quot;time/piece&quot;&gt;Time::Piece&lt;/a&gt; module, part of the Standard Library, which can convert a date/time to a Julian Day:</source>
          <target state="translated">표준 라이브러리의 일부인 &lt;a href=&quot;time/piece&quot;&gt;Time :: Piece&lt;/a&gt; 모듈을 사용하면 날짜 / 시간을 율리우스 일로 변환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="19bff3f43fe0160ae5712a54b49b7225e08cf437" translate="yes" xml:space="preserve">
          <source>You can use the &lt;code&gt;${^GLOBAL_PHASE}&lt;/code&gt; variable to detect if you are currently in the global destruction phase:</source>
          <target state="translated">당신이 사용할 수있는 &lt;code&gt;${^GLOBAL_PHASE}&lt;/code&gt; 전역 파괴 단계에 현재있는 경우 감지 할 변수를 :</target>
        </trans-unit>
        <trans-unit id="c3b01f73c25a67d7de0988508e3d6a08d549191f" translate="yes" xml:space="preserve">
          <source>You can use the &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; keyword to fall through from one case to the next:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; 키워드를 사용하여 한 사례에서 다음 사례로 넘어갈 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0512ec103381f142d5cd53ad55c41fe8a57f36b8" translate="yes" xml:space="preserve">
          <source>You can use the &lt;code&gt;&lt;a href=&quot;functions/delete&quot;&gt;delete&lt;/a&gt; &lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt; $array[$idx]&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/delete&quot;&gt;delete&lt;/a&gt; &lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt; $hash{key}&lt;/code&gt; constructs to delete a composite type entry for the current block and restore it when it ends. They return the array/hash value before the localization, which means that they are respectively equivalent to</source>
          <target state="translated">사용자는 사용 &lt;code&gt;&lt;a href=&quot;functions/delete&quot;&gt;delete&lt;/a&gt; &lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt; $array[$idx]&lt;/code&gt; 그리고 &lt;code&gt;&lt;a href=&quot;functions/delete&quot;&gt;delete&lt;/a&gt; &lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt; $hash{key}&lt;/code&gt; 구조를 상기 현재 블록에 대한 복합 타입 항목을 삭제하고 끝나면 복원. 현지화 전에 배열 / 해시 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="e75c67446fa3d94c780e921da6acd4affb168a6f" translate="yes" xml:space="preserve">
          <source>You can use the &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys()&lt;/a&gt;&lt;/code&gt; built-in function in scalar context to find out have many entries you have in a hash:</source>
          <target state="translated">당신이 사용할 수있는 &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys()&lt;/a&gt;&lt;/code&gt; 이 해시에있는 많은 항목이 찾아 내장 기능 스칼라 문맥을 :</target>
        </trans-unit>
        <trans-unit id="32a43fdc7d4ed02e813e0075b65927b5536f01d4" translate="yes" xml:space="preserve">
          <source>You can use the &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/values&quot;&gt;values&lt;/a&gt;&lt;/code&gt; functions to reset &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each&lt;/a&gt;&lt;/code&gt;. To simply reset the iterator used by &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; without doing anything else, use one of them in void context:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;functions/values&quot;&gt;values&lt;/a&gt;&lt;/code&gt; 기능을 사용하여 &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; 을 재설정 할 수 있습니다 . 다른 작업을 수행하지 않고 &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; 의해 사용되는 반복자를 간단히 재설정하려면 void 컨텍스트에서 이들 중 하나를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="91d95a3ba11b677c44eabfc4c39139686174c03a" translate="yes" xml:space="preserve">
          <source>You can use the &lt;code&gt;END&lt;/code&gt; block to simulate &lt;code&gt;atexit()&lt;/code&gt; . Each package's &lt;code&gt;END&lt;/code&gt; block is called when the program or thread ends. See the &lt;a href=&quot;perlmod&quot;&gt;perlmod&lt;/a&gt; manpage for more details about &lt;code&gt;END&lt;/code&gt; blocks.</source>
          <target state="translated">&lt;code&gt;END&lt;/code&gt; 블록을 사용하여 &lt;code&gt;atexit()&lt;/code&gt; 를 시뮬레이션 할 수 있습니다 . 각 패키지의 &lt;code&gt;END&lt;/code&gt; 블록은 프로그램 또는 스레드가 종료 될 때 호출됩니다. 참고 항목 &lt;a href=&quot;perlmod&quot;&gt;perlmod를&lt;/a&gt; 대한 자세한 내용은 맨 &lt;code&gt;END&lt;/code&gt; 블록을.</target>
        </trans-unit>
        <trans-unit id="4356379b81876248477b6f357e68e2915cc3c4a7" translate="yes" xml:space="preserve">
          <source>You can use the &lt;code&gt;END&lt;/code&gt; block to simulate &lt;code&gt;atexit()&lt;/code&gt;. Each package's &lt;code&gt;END&lt;/code&gt; block is called when the program or thread ends. See the &lt;a href=&quot;perlmod&quot;&gt;perlmod&lt;/a&gt; manpage for more details about &lt;code&gt;END&lt;/code&gt; blocks.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="daf833c1822dba958c8327441530b019e90d9f3c" translate="yes" xml:space="preserve">
          <source>You can use the &lt;code&gt;Text::Soundex&lt;/code&gt; module. If you want to do fuzzy or close matching, you might also try the &lt;a href=&quot;String::Approx&quot;&gt;String::Approx&lt;/a&gt;, and &lt;a href=&quot;Text::Metaphone&quot;&gt;Text::Metaphone&lt;/a&gt;, and &lt;a href=&quot;Text::DoubleMetaphone&quot;&gt;Text::DoubleMetaphone&lt;/a&gt; modules.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23320d34367d7c8e19c4f3b2648a39107aaceafc" translate="yes" xml:space="preserve">
          <source>You can use the &lt;code&gt;Text::Soundex&lt;/code&gt; module. If you want to do fuzzy or close matching, you might also try the &lt;a href=&quot;http://search.cpan.org/perldoc/String::Approx&quot;&gt;String::Approx&lt;/a&gt;, and &lt;a href=&quot;http://search.cpan.org/perldoc/Text::Metaphone&quot;&gt;Text::Metaphone&lt;/a&gt;, and &lt;a href=&quot;http://search.cpan.org/perldoc/Text::DoubleMetaphone&quot;&gt;Text::DoubleMetaphone&lt;/a&gt; modules.</source>
          <target state="translated">&lt;code&gt;Text::Soundex&lt;/code&gt; 모듈을 사용할 수 있습니다 . 퍼지 또는 근접 일치를 수행하려면 &lt;a href=&quot;http://search.cpan.org/perldoc/String::Approx&quot;&gt;String :: Approx&lt;/a&gt; 및 &lt;a href=&quot;http://search.cpan.org/perldoc/Text::Metaphone&quot;&gt;Text :: Metaphone&lt;/a&gt; 및 &lt;a href=&quot;http://search.cpan.org/perldoc/Text::DoubleMetaphone&quot;&gt;Text :: DoubleMetaphone&lt;/a&gt; 모듈을 사용해보십시오 .</target>
        </trans-unit>
        <trans-unit id="488d88c32abab4c7103bc8a9f7d995aca32467c4" translate="yes" xml:space="preserve">
          <source>You can use the &lt;code&gt;UNIVERSAL&lt;/code&gt; class (see &lt;a href=&quot;universal&quot;&gt;UNIVERSAL&lt;/a&gt;). However, please be very careful to consider the consequences of doing this: adding methods to every object is very likely to have unintended consequences. If possible, it would be better to have all your object inherit from some common base class, or to use an object system like Moose that supports roles.</source>
          <target state="translated">&lt;code&gt;UNIVERSAL&lt;/code&gt; 클래스를 사용할 수 있습니다 ( &lt;a href=&quot;universal&quot;&gt;UNIVERSAL&lt;/a&gt; 참조 ). 그러나이 작업의 결과를 고려해야합니다. 모든 개체에 메서드를 추가하면 의도하지 않은 결과가 발생할 가능성이 큽니다. 가능하면 모든 객체를 공통 기본 클래스에서 상속하거나 역할을 지원하는 Moose와 같은 객체 시스템을 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="9e82c1f5d6a6827f8e16779cc47df9c04d7d8adc" translate="yes" xml:space="preserve">
          <source>You can use the &lt;code&gt;\[]&lt;/code&gt; backslash group notation to specify more than one allowed argument type. For example:</source>
          <target state="translated">당신은 사용할 수 있습니다 &lt;code&gt;\[]&lt;/code&gt; 하나 개 이상의 허용 인수 유형을 지정 백 슬래시 그룹 표기법을. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="29a5b3337e458ba95bc1ff4b8a89d182c9528c72" translate="yes" xml:space="preserve">
          <source>You can use the &lt;code&gt;break&lt;/code&gt; keyword to break out of the enclosing &lt;code&gt;given&lt;/code&gt; block. Every &lt;code&gt;when&lt;/code&gt; block is implicitly ended with a &lt;code&gt;break&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;break&lt;/code&gt; 키워드를 사용하여 &lt;code&gt;given&lt;/code&gt; 블록 에서 벗어날 수 있습니다 . 모든 &lt;code&gt;when&lt;/code&gt; 블록은 암시 적으로 종료 &lt;code&gt;break&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bba1699dbcdd0690079aefe9fd9ab593286631dc" translate="yes" xml:space="preserve">
          <source>You can use the &lt;code&gt;break&lt;/code&gt; keyword to break out of the enclosing &lt;code&gt;given&lt;/code&gt; block. Every &lt;code&gt;when&lt;/code&gt; block is implicitly ended with a &lt;code&gt;break&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="949c9a5e3f3716d2943d21cb6815e4a1eba07109" translate="yes" xml:space="preserve">
          <source>You can use the &lt;code&gt;continue&lt;/code&gt; keyword to fall through from one case to the next immediate &lt;code&gt;when&lt;/code&gt; or &lt;code&gt;default&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb5ebdd2538225dc5126d819377dd6fa733157f0" translate="yes" xml:space="preserve">
          <source>You can use the &lt;code&gt;delete local $array[$idx]&lt;/code&gt; and &lt;code&gt;delete local $hash{key}&lt;/code&gt; constructs to delete a composite type entry for the current block and restore it when it ends. They return the array/hash value before the localization, which means that they are respectively equivalent to</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="424781ac9f1048ec292a7a68c49b74676d773d63" translate="yes" xml:space="preserve">
          <source>You can use the &lt;code&gt;keys()&lt;/code&gt; built-in function in scalar context to find out have many entries you have in a hash:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d6ffcfb4d7d7a8b446a2b5b6c864d29b7abf92a" translate="yes" xml:space="preserve">
          <source>You can use the &lt;code&gt;keys&lt;/code&gt; or &lt;code&gt;values&lt;/code&gt; functions to reset &lt;code&gt;each&lt;/code&gt;. To simply reset the iterator used by &lt;code&gt;each&lt;/code&gt; without doing anything else, use one of them in void context:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4e6268ce8a22314d30cc236ac406a7320d8f9ec" translate="yes" xml:space="preserve">
          <source>You can use the Configure script in non-interactive mode too. When I built my</source>
          <target state="translated">비 대화식 모드에서도 Configure 스크립트를 사용할 수 있습니다. 내가 만들 때</target>
        </trans-unit>
        <trans-unit id="a88ac92f15e86bfef2bc330f6e37cbdfaa5d2949" translate="yes" xml:space="preserve">
          <source>You can use the POSIX character class syntax &lt;code&gt;/[[:alpha:]]/&lt;/code&gt; documented in &lt;a href=&quot;perlre&quot;&gt;perlre&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;perlre&quot;&gt;perlre에&lt;/a&gt; 문서화 된 POSIX 문자 클래스 구문 &lt;code&gt;/[[:alpha:]]/&lt;/code&gt; 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e278d58c9ab507fbb7f9453e431896c65ad5fd6f" translate="yes" xml:space="preserve">
          <source>You can use the SDK by exporting some additions to Perl's 'ccflags' and '..flags' config variables:</source>
          <target state="translated">Perl의 'ccflags'및 '..flags'구성 변수에 추가 사항을 내보내 SDK를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2cbe3a7e5b8b2c8d5af954d0911633deaa0d280d" translate="yes" xml:space="preserve">
          <source>You can use the WILDCARD option to enable the debugging output of this subpattern matching. Careful! This can lead to voluminous outputs, and it may not make much sense to you what and why Perl is doing what it is. But it may be helpful to you to see why things aren't going the way you expect.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dcba1d434e18427e8484e54d9e14e5566e79c6d1" translate="yes" xml:space="preserve">
          <source>You can use the builtin &lt;code&gt;&lt;a href=&quot;functions/getc&quot;&gt;getc()&lt;/a&gt;&lt;/code&gt; function for most filehandles, but it won't (easily) work on a terminal device. For STDIN, either use the Term::ReadKey module from CPAN or use the sample code in &lt;a href=&quot;functions/getc&quot;&gt;getc&lt;/a&gt;.</source>
          <target state="translated">대부분의 파일 핸들에 내장 &lt;code&gt;&lt;a href=&quot;functions/getc&quot;&gt;getc()&lt;/a&gt;&lt;/code&gt; 함수를 사용할 수 있지만 터미널 장치에서는 (쉽게) 작동하지 않습니다. STDIN의 경우 CPAN의 Term :: ReadKey 모듈을 사용하거나 &lt;a href=&quot;functions/getc&quot;&gt;getc&lt;/a&gt; 의 샘플 코드를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="576855da70920d778b0c9c1adac6f51a7f5843b4" translate="yes" xml:space="preserve">
          <source>You can use the builtin &lt;code&gt;getc()&lt;/code&gt; function for most filehandles, but it won't (easily) work on a terminal device. For STDIN, either use the Term::ReadKey module from CPAN or use the sample code in &lt;a href=&quot;perlfunc#getc&quot;&gt;&quot;getc&quot; in perlfunc&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad23301638fa59a074f7b5a830adc451b7882aec" translate="yes" xml:space="preserve">
          <source>You can use the debugger's &lt;code&gt;x&lt;/code&gt; command to dump out complex data structures. For example, given the assignment to $AoA above, here's the debugger output:</source>
          <target state="translated">디버거의 &lt;code&gt;x&lt;/code&gt; 명령을 사용하여 복잡한 데이터 구조를 덤프 할 수 있습니다 . 예를 들어, 위의 $ AoA에 할당 된 경우 디버거 출력은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="26aa247b07d1815cd4598322a5a4fc92732d8a40" translate="yes" xml:space="preserve">
          <source>You can use the file handle returned by &lt;code&gt;vmsopen&lt;/code&gt; just as you would any other Perl file handle. The class VMS::Stdio ISA IO::File, so you can call IO::File methods using the handle returned by &lt;code&gt;vmsopen&lt;/code&gt;. However, &lt;code&gt;use&lt;/code&gt;ing VMS::Stdio does not automatically &lt;code&gt;use&lt;/code&gt; IO::File; you must do so explicitly in your program if you want to call IO::File methods. This is done to avoid the overhead of initializing the IO::File package in programs which intend to use the handle returned by &lt;code&gt;vmsopen&lt;/code&gt; as a normal Perl file handle only. When the scalar containing a VMS::Stdio file handle is overwritten, &lt;code&gt;undef&lt;/code&gt;d, or goes out of scope, the associated file is closed automatically.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c95e7176a4cdb8eb19d859ce523240b91e0d516f" translate="yes" xml:space="preserve">
          <source>You can use the following types of values for allow:</source>
          <target state="translated">허용에 다음 유형의 값을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3ce0a691bebd0b371247224bb7f78a55fdff48f0" translate="yes" xml:space="preserve">
          <source>You can use the four-argument form of sysread to continually add to a buffer. After you add to the buffer, you check if you have a complete line (using your regular expression).</source>
          <target state="translated">4 개의 인수 형식의 sysread를 사용하여 지속적으로 버퍼에 추가 할 수 있습니다. 버퍼에 추가 한 후 정규식을 사용하여 완전한 행이 있는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="68293f8666171fe0ed45f0e78671e51ac55dfe3d" translate="yes" xml:space="preserve">
          <source>You can use the open source 7-zip ( &lt;a href=&quot;https://www.7-zip.org/&quot;&gt;https://www.7-zip.org/&lt;/a&gt; ) or the shareware Winzip ( &lt;a href=&quot;https://www.winzip.com&quot;&gt;https://www.winzip.com&lt;/a&gt; ) to decompress and unpack modules.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da343e9c661b7d9b54a6aef1473ed8a755544823" translate="yes" xml:space="preserve">
          <source>You can use the shareware Winzip ( &lt;a href=&quot;http://www.winzip.com&quot;&gt;http://www.winzip.com&lt;/a&gt; ) to decompress and unpack modules.</source>
          <target state="translated">쉐어웨어 Winzip ( &lt;a href=&quot;http://www.winzip.com&quot;&gt;http://www.winzip.com&lt;/a&gt; )을 사용하여 모듈의 압축을 풀고 압축을 풀 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="29131242da6a21b6f2efd67a20aaa973ec754794" translate="yes" xml:space="preserve">
          <source>You can use the substitution operator to find pairs of characters (or runs of characters) and replace them with a single instance. In this substitution, we find a character in &lt;code&gt;(.)&lt;/code&gt;. The memory parentheses store the matched character in the back-reference &lt;code&gt;\g1&lt;/code&gt; and we use that to require that the same thing immediately follow it. We replace that part of the string with the character in &lt;code&gt;$1&lt;/code&gt; .</source>
          <target state="translated">대체 연산자를 사용하여 문자 쌍 (또는 문자 수)을 찾아 단일 인스턴스로 바꿀 수 있습니다. 이 대체에서 &lt;code&gt;(.)&lt;/code&gt; 에서 문자를 찾습니다 . 메모리 괄호는 일치하는 문자를 역 참조 &lt;code&gt;\g1&lt;/code&gt; 하고이를 사용하여 동일한 문자를 즉시 따라야합니다. 문자열의 해당 부분을 &lt;code&gt;$1&lt;/code&gt; 의 문자로 바꿉니다 .</target>
        </trans-unit>
        <trans-unit id="7f3665d3fee5fef1523abafbe5cde6dfe44f5710" translate="yes" xml:space="preserve">
          <source>You can use the substitution operator to find pairs of characters (or runs of characters) and replace them with a single instance. In this substitution, we find a character in &lt;code&gt;(.)&lt;/code&gt;. The memory parentheses store the matched character in the back-reference &lt;code&gt;\g1&lt;/code&gt; and we use that to require that the same thing immediately follow it. We replace that part of the string with the character in &lt;code&gt;$1&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b56ec6ea26f22e6bec1d13c6dc597e46c1853d2d" translate="yes" xml:space="preserve">
          <source>You can use the substr() function as an lvalue, in which case EXPR must itself be an lvalue. If you assign something shorter than LENGTH, the string will shrink, and if you assign something longer than LENGTH, the string will grow to accommodate it. To keep the string the same length, you may need to pad or chop your value using &lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">substr () 함수를 lvalue로 사용할 수 있습니다.이 경우 EXPR 자체는 lvalue 여야합니다. LENGTH보다 짧은 것을 할당하면 문자열이 줄어들고 LENGTH보다 긴 것을 할당하면 문자열이 그것을 수용하도록 커집니다. 문자열의 길이를 동일하게 유지하려면 &lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf&lt;/a&gt;&lt;/code&gt; 를 사용하여 값을 채우 거나 잘라 내야 합니다.</target>
        </trans-unit>
        <trans-unit id="5696279d1bd6b651a532c13cf176bc61670cde27" translate="yes" xml:space="preserve">
          <source>You can use the substr() function as an lvalue, in which case EXPR must itself be an lvalue. If you assign something shorter than LENGTH, the string will shrink, and if you assign something longer than LENGTH, the string will grow to accommodate it. To keep the string the same length, you may need to pad or chop your value using &lt;code&gt;&lt;a href=&quot;sprintf&quot;&gt;sprintf&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">substr () 함수를 lvalue로 사용할 수 있습니다.이 경우 EXPR 자체는 lvalue 여야합니다. LENGTH보다 짧은 것을 할당하면 문자열이 줄어들고 LENGTH보다 긴 것을 할당하면 문자열이 그것을 수용하도록 커집니다. 문자열의 길이를 동일하게 유지하려면 &lt;code&gt;&lt;a href=&quot;sprintf&quot;&gt;sprintf&lt;/a&gt;&lt;/code&gt; 를 사용하여 값을 채우 거나 잘라 내야 합니다.</target>
        </trans-unit>
        <trans-unit id="370c9e4d882e8e3555298091312bb16cb7ba0b14" translate="yes" xml:space="preserve">
          <source>You can use the tainted() function of the Scalar::Util module, available from CPAN (or included with Perl since release 5.8.0). See also &lt;a href=&quot;perlsec#Laundering-and-Detecting-Tainted-Data&quot;&gt;&quot;Laundering and Detecting Tainted Data&quot; in perlsec&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cfeed36c7e84bfafbf0ea57f25867379b77f770c" translate="yes" xml:space="preserve">
          <source>You can use the tainted() function of the Scalar::Util module, available from CPAN (or included with Perl since release 5.8.0). See also &lt;a href=&quot;perlsec#Laundering-and-Detecting-Tainted-Data&quot;&gt;Laundering and Detecting Tainted Data in perlsec&lt;/a&gt;.</source>
          <target state="translated">CPAN에서 사용 가능하거나 릴리스 5.8.0 이후 Perl에 포함 된 Scalar :: Util 모듈의 tainted () 함수를 사용할 수 있습니다. &lt;a href=&quot;perlsec#Laundering-and-Detecting-Tainted-Data&quot;&gt;perlsec에서 오염 된 데이터 세탁 및 감지를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="67ef5a8d9d775587994b1c8525522dac443d6c25" translate="yes" xml:space="preserve">
          <source>You can use the three-argument form of open to specify I/O layers (sometimes referred to as &quot;disciplines&quot;) to apply to the new filehandle. These affect how the input and output are processed (see &lt;a href=&quot;open&quot;&gt;open&lt;/a&gt; and &lt;a href=&quot;perlio&quot;&gt;PerlIO&lt;/a&gt; for more details). For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="09d2af0acba58841da7d114d861e093a90573f8a" translate="yes" xml:space="preserve">
          <source>You can use these macros if you call code that may croak, but you need to do some cleanup before giving control back to Perl. For example:</source>
          <target state="translated">삐걱 거리는 코드를 호출하는 경우 이러한 매크로를 사용할 수 있지만 Perl에 제어권을 부여하기 전에 정리를 수행해야합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8d60246dfc629fa2c767c2383b114af7d8fad4bc" translate="yes" xml:space="preserve">
          <source>You can use this as a shortcut to determine whether &lt;code&gt;Archive::Tar&lt;/code&gt; will do what you think before passing compressed archives to its &lt;code&gt;&lt;a href=&quot;../functions/read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; method.</source>
          <target state="translated">압축 된 아카이브를 &lt;code&gt;&lt;a href=&quot;../functions/read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; 메소드 로 전달하기 전에 &lt;code&gt;Archive::Tar&lt;/code&gt; 가 사용자의 생각을 수행 할 것인지 여부를 판별하는 바로 가기로이를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="dbd42e35c7b3f7dd461bd372dbf9f5578060d86f" translate="yes" xml:space="preserve">
          <source>You can use this as a shortcut to determine whether &lt;code&gt;Archive::Tar&lt;/code&gt; will do what you think before passing compressed archives to its &lt;code&gt;read&lt;/code&gt; method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a2583bc76f12f41a833e44f457c707f446ecc90f" translate="yes" xml:space="preserve">
          <source>You can use this class as the base class for a Pod formatter/processor.</source>
          <target state="translated">이 클래스를 포드 포맷터 / 프로세서의 기본 클래스로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ddc269b809151a32259fd4bfb2f0eaf592a60142" translate="yes" xml:space="preserve">
          <source>You can use this subroutine to get and set the traversal mask for a specific hash. Setting the mask ensures that a given hash will produce the same key order. &lt;b&gt;Note&lt;/b&gt; that this does &lt;b&gt;not&lt;/b&gt; guarantee that &lt;b&gt;two&lt;/b&gt; hashes will produce the same key order for the same hash seed and traversal mask, items that collide into one bucket may have different orders regardless of this setting.</source>
          <target state="translated">이 서브 루틴을 사용하여 특정 해시에 대한 순회 마스크를 가져오고 설정할 수 있습니다. 마스크를 설정하면 지정된 해시가 동일한 키 순서를 생성합니다. &lt;b&gt;참고&lt;/b&gt; 이 않습니다 &lt;b&gt;하지&lt;/b&gt; 보장 &lt;b&gt;이&lt;/b&gt; 해시가 동일한 해시 씨와 탐색 마스크 같은 키 순서를 생성합니다이 항목은 도랑에에서 충돌이 설정에 관계없이 다른 순서를 가질 수있다.</target>
        </trans-unit>
        <trans-unit id="3cb82727ce61d8edf5281f6c0ba4e6a9919853bd" translate="yes" xml:space="preserve">
          <source>You can use this to concatenate two scalars:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e57a6a3e1ac0e576a34f1deb9cbe35e8438d88f" translate="yes" xml:space="preserve">
          <source>You can use this to find out whether two handles refer to the same underlying descriptor:</source>
          <target state="translated">이를 사용하여 두 핸들이 동일한 기본 설명자를 참조하는지 여부를 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e2f6df83e5ac1b378170dbde8b31e8b10cee41f6" translate="yes" xml:space="preserve">
          <source>You can use this to print out all the variables in a package, for instance. The standard but antiquated</source>
          <target state="translated">예를 들어 이것을 사용하여 패키지의 모든 변수를 인쇄 할 수 있습니다. 표준이지만 낡은</target>
        </trans-unit>
        <trans-unit id="2c064b95103461f4732f35fcd238f5be71635622" translate="yes" xml:space="preserve">
          <source>You can use this to record all events AFTER they have been sent to the formatter. No changes made here will be meaningful, except possibly to other listeners.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="973b86bb17e6d843653e8421a775f98d4d43a73b" translate="yes" xml:space="preserve">
          <source>You can use this to remove a listen callback. You must pass in the coderef returned by the &lt;code&gt;listen()&lt;/code&gt; method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6fe2602c37d36cd939b3f2966e9882c1457b54a" translate="yes" xml:space="preserve">
          <source>You can use whitespace and the &lt;code&gt;=&amp;gt;&lt;/code&gt; operator to lay them out more nicely:</source>
          <target state="translated">공백과 &lt;code&gt;=&amp;gt;&lt;/code&gt; 연산자를 사용하여 더 멋지게 배치 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2a2d95bc6981ab5724b117c21adf2c42ff1324ac" translate="yes" xml:space="preserve">
          <source>You can watch Perl's regular expression engine at work to verify for yourself if Perl is recompiling a regular expression. The &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re
'debug'&lt;/code&gt; pragma (comes with Perl 5.005 and later) shows the details. With Perls before 5.6, you should see &lt;code&gt;re&lt;/code&gt; reporting that its compiling the regular expression on each iteration. With Perl 5.6 or later, you should only see &lt;code&gt;re&lt;/code&gt; report that for the first iteration.</source>
          <target state="translated">Perl이 정규식을 다시 컴파일하는지 직접 확인하기 위해 직장에서 Perl의 정규식 엔진을 볼 수 있습니다. &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re 'debug'&lt;/code&gt; 프라 그마 (나중에 펄 5.005와 함께 제공) 세부 사항을 보여줍니다. 5.6 이전 Perls, 당신은 볼 수 &lt;code&gt;re&lt;/code&gt; 의 각 반복에 정규 표현식을 컴파일하는 것을보고. Perl 5.6 이상 에서는 첫 번째 반복에 대해서만 &lt;code&gt;re&lt;/code&gt; 보고 해야합니다 .</target>
        </trans-unit>
        <trans-unit id="be5157e72fec47ccda29a3884d0d6aa69a038c22" translate="yes" xml:space="preserve">
          <source>You can watch Perl's regular expression engine at work to verify for yourself if Perl is recompiling a regular expression. The &lt;code&gt;use re 'debug'&lt;/code&gt; pragma (comes with Perl 5.005 and later) shows the details. With Perls before 5.6, you should see &lt;code&gt;re&lt;/code&gt; reporting that its compiling the regular expression on each iteration. With Perl 5.6 or later, you should only see &lt;code&gt;re&lt;/code&gt; report that for the first iteration.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b95a7534126966a35fdb290a82cc3eb90110d990" translate="yes" xml:space="preserve">
          <source>You can work around the first case by using the fully qualified name (&lt;code&gt;$Package::FOO&lt;/code&gt; ) where you need a local value, or by overriding it by saying &lt;code&gt;*FOO = *Package::FOO&lt;/code&gt; in your script.</source>
          <target state="translated">로컬 값이 필요한 정규화 된 이름 ( &lt;code&gt;$Package::FOO&lt;/code&gt; ) 을 사용하거나 스크립트에서 &lt;code&gt;*FOO = *Package::FOO&lt;/code&gt; 라고 말하여 재정 의하여 첫 번째 경우 를 해결할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5d9ed6d1d4bf51c3f2d48b808ade1c9eb6d3e68f" translate="yes" xml:space="preserve">
          <source>You can work around the first case by using the fully qualified name (&lt;code&gt;$Package::FOO&lt;/code&gt;) where you need a local value, or by overriding it by saying &lt;code&gt;*FOO = *Package::FOO&lt;/code&gt; in your script.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74896a00006c71879750ed85d659cbff45ee1a05" translate="yes" xml:space="preserve">
          <source>You can write this by hand or generate it with 'make manifest'.</source>
          <target state="translated">직접 작성하거나 'make manifest'로 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b1c2fce28dbd805f8d7a870a949b6c5834632bf2" translate="yes" xml:space="preserve">
          <source>You can write this more briefly using a grep, which does the same thing.</source>
          <target state="translated">grep을 사용하여 더 간단하게 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="abb98a8eca7d1aa69e5a0eb195e9e9713bd18c72" translate="yes" xml:space="preserve">
          <source>You can write your regular expressions just like someone on an ASCII platform would do. But keep in mind that using octal or hex notation to specify a particular code point will give you the character that the EBCDIC code page natively maps to it. (This is also true of all double-quoted strings.) If you want to write portably, just use the &lt;code&gt;\N{U+...}&lt;/code&gt; notation everywhere where you would have used &lt;code&gt;\x{...}&lt;/code&gt; , and don't use octal notation at all.</source>
          <target state="translated">ASCII 플랫폼의 누군가와 마찬가지로 정규식을 작성할 수 있습니다. 그러나 8 진 또는 16 진 표기법을 사용하여 특정 코드 포인트를 지정하면 EBCDIC 코드 페이지가 기본적으로 해당 코드 포인트에 맵핑되는 문자를 제공합니다. (이것은 또한 모든 따옴표 문자열의 사실이다.) 당신이 이식 작성하려는 경우, 그냥 사용 &lt;code&gt;\N{U+...}&lt;/code&gt; 당신이 사용했을 경우 사방 표기법을 &lt;code&gt;\x{...}&lt;/code&gt; , 그리고하지 8 진법을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="7d266b91c488913460baf4dd560ddccb0fd29aed" translate="yes" xml:space="preserve">
          <source>You can write your regular expressions just like someone on an ASCII platform would do. But keep in mind that using octal or hex notation to specify a particular code point will give you the character that the EBCDIC code page natively maps to it. (This is also true of all double-quoted strings.) If you want to write portably, just use the &lt;code&gt;\N{U+...}&lt;/code&gt; notation everywhere where you would have used &lt;code&gt;\x{...}&lt;/code&gt;, and don't use octal notation at all.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c77e05c4dac877ccb1d3bc62136f650220cc0e0" translate="yes" xml:space="preserve">
          <source>You can't (directly) write a recursive lexical subroutine:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e94e5e7086b787cf553633de7398d82024090d60" translate="yes" xml:space="preserve">
          <source>You can't (easily) have any space in front of the tag.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="62834a834066a3093a80c93ec315493101e7f82e" translate="yes" xml:space="preserve">
          <source>You can't disambiguate that by saying &lt;code&gt;\{1}000&lt;/code&gt; , whereas you can fix it with &lt;code&gt;${1}000&lt;/code&gt;. The operation of interpolation should not be confused with the operation of matching a backreference. Certainly they mean two different things on the</source>
          <target state="translated">&lt;code&gt;\{1}000&lt;/code&gt; 이라고 말하면 명확하게 말할 수 없지만 &lt;code&gt;${1}000&lt;/code&gt; 수정할 수 있습니다 . 보간 연산은 역 참조 매칭 연산과 혼동되어서는 안됩니다. 확실히 그들은 두 가지 다른 것을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="446ed284a8405938957f84b57096d4442d17377f" translate="yes" xml:space="preserve">
          <source>You can't disambiguate that by saying &lt;code&gt;\{1}000&lt;/code&gt;, whereas you can fix it with &lt;code&gt;${1}000&lt;/code&gt;. The operation of interpolation should not be confused with the operation of matching a backreference. Certainly they mean two different things on the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="020ca4e878548eed17ca845dc3179b69179a2006" translate="yes" xml:space="preserve">
          <source>You can't do this with the &lt;code&gt;if&lt;/code&gt; pragma; however, you can achieve exactly this effect, at compile time, with:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="026d053774b9559119bfc24f712c71285ffb2ad2" translate="yes" xml:space="preserve">
          <source>You can't have =items (as at line</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b18683b4b76072abbee71a6881cdb8bc575df90f" translate="yes" xml:space="preserve">
          <source>You can't have a hash whose values are arrays; hash values can only be scalars. We're stuck with that. But a single reference can refer to an entire array, and references are scalars, so you can have a hash of references to arrays, and it'll act a lot like a hash of arrays, and it'll be just as useful as a hash of arrays.</source>
          <target state="translated">값이 배열 인 해시를 가질 수 없습니다. 해시 값은 스칼라 만 될 수 있습니다. 우리는 그것에 갇혀있다. 그러나 단일 참조는 전체 배열을 참조 할 수 있으며 참조는 스칼라이므로 배열에 대한 참조 해시를 가질 수 있으며 배열의 해시와 매우 유사하게 작동하며 배열 해시.</target>
        </trans-unit>
        <trans-unit id="d10d9e535268b6be7a5edad8c961bf0a3eba1a2f" translate="yes" xml:space="preserve">
          <source>You can't prevent people from sending your script bad data. Even if you add some client-side checks, people may disable them or bypass them completely. For instance, someone might use a module such as &lt;a href=&quot;http://search.cpan.org/perldoc/LWP&quot;&gt;LWP&lt;/a&gt; to submit to your web site. If you want to prevent data that try to use SQL injection or other sorts of attacks (and you should want to), you have to not trust any data that enter your program.</source>
          <target state="translated">사람들이 스크립트에 잘못된 데이터를 보내지 못하게 할 수는 없습니다. 클라이언트 쪽 검사를 추가하더라도 사람들이 검사를 비활성화하거나 완전히 무시할 수 있습니다. 예를 들어 누군가 &lt;a href=&quot;http://search.cpan.org/perldoc/LWP&quot;&gt;LWP&lt;/a&gt; 와 같은 모듈을 사용 하여 웹 사이트에 제출할 수 있습니다. SQL 인젝션이나 다른 종류의 공격을 시도하는 데이터를 방지하려면 (그리고 원한다면) 프로그램에 입력하는 데이터를 신뢰하지 않아도됩니다.</target>
        </trans-unit>
        <trans-unit id="6424e72f031416bce90e6701fa0fc1986967103a" translate="yes" xml:space="preserve">
          <source>You can't prevent people from sending your script bad data. Even if you add some client-side checks, people may disable them or bypass them completely. For instance, someone might use a module such as &lt;a href=&quot;lwp&quot;&gt;LWP&lt;/a&gt; to submit to your web site. If you want to prevent data that try to use SQL injection or other sorts of attacks (and you should want to), you have to not trust any data that enter your program.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8673b45bcf51a92e5bbd4f8ac4117b4afa807acf" translate="yes" xml:space="preserve">
          <source>You can't produce a tied constant by giving a tied scalar as the value. References to tied variables, however, can be used as constants without any problems.</source>
          <target state="translated">연결된 스칼라를 값으로 지정하여 연결된 상수를 생성 할 수 없습니다. 그러나 묶인 변수에 대한 참조는 문제없이 상수로 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="37d171546c154312737dfd62e998eea96bcef04d" translate="yes" xml:space="preserve">
          <source>You can't store GLOB, FORMLINE, REGEXP, etc.... If you can define semantics for those operations, feel free to enhance Storable so that it can deal with them.</source>
          <target state="translated">GLOB, FORMLINE, REGEXP 등을 저장할 수 없습니다. 이러한 작업의 의미를 정의 할 수 있으면 Storable을 향상시켜 처리 할 수 ​​있도록하십시오.</target>
        </trans-unit>
        <trans-unit id="67bd9de8b466ae8269d533b74dcf8f4858db7b40" translate="yes" xml:space="preserve">
          <source>You can't store GLOB, FORMLINE, etc.... If you can define semantics for those operations, feel free to enhance Storable so that it can deal with them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0c681bde3f10285d1065419cbcfdfe8d15a0638" translate="yes" xml:space="preserve">
          <source>You can't take the address of anything, although a similar operator in Perl is the backslash, which creates a reference.</source>
          <target state="translated">Perl의 유사한 연산자가 백 슬래시이므로 참조를 생성하지만 아무 주소도 취할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="3d03f47a54efdf6a567386eabfcea4dcbcebbcab" translate="yes" xml:space="preserve">
          <source>You can't use a reference to an array or hash in quite the same way that you would a real array or hash. For C or C++ programmers unused to distinguishing between arrays and pointers to the same, this can be confusing. If so, just think of it as the difference between a structure and a pointer to a structure.</source>
          <target state="translated">실제 배열이나 해시와 같은 방식으로 배열이나 해시에 대한 참조를 사용할 수 없습니다. 배열과 포인터를 구별하는 데 사용되지 않는 C 또는 C ++ 프로그래머의 경우 혼동 될 수 있습니다. 그렇다면 구조와 구조에 대한 포인터의 차이점으로 생각하십시오.</target>
        </trans-unit>
        <trans-unit id="f88b12efd9288b17ac8ba038151b3170bc987f73" translate="yes" xml:space="preserve">
          <source>You can't. Some use the UTF8 flag for this, but that's misuse, and makes well behaved modules like Data::Dumper look bad. The flag is useless for this purpose, because it's off when an 8 bit encoding (by default ISO-8859-1) is used to store the string.</source>
          <target state="translated">당신은 할 수 없습니다. 일부는 이것을 위해 UTF8 플래그를 사용하지만 오용이며 Data :: Dumper와 같은 잘 동작하는 모듈이 나쁘게 보입니다. 8 비트 인코딩 (기본적으로 ISO-8859-1)을 사용하여 문자열을 저장하면 플래그가 해제되므로이 용도로는 플래그가 쓸모가 없습니다.</target>
        </trans-unit>
        <trans-unit id="2fd8f1486a5edc4ee6dd1a50f986e5205ada1304" translate="yes" xml:space="preserve">
          <source>You can't. This is because UTF-8 data is stored in bytes just like non-UTF-8 data. The Unicode character 200, (&lt;code&gt;0xC8&lt;/code&gt; for you hex types) capital E with a grave accent, is represented by the two bytes &lt;code&gt;v196.172&lt;/code&gt; . Unfortunately, the non-Unicode string &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr(196).chr(172)&lt;/a&gt;&lt;/code&gt; has that byte sequence as well. So you can't tell just by looking -- this is what makes Unicode input an interesting problem.</source>
          <target state="translated">당신은 할 수 없습니다. UTF-8 데이터는 비 UTF-8 데이터와 마찬가지로 바이트로 저장되기 때문입니다. 억음 악센트가있는 유니 코드 문자 200 ( 16 진수 유형의 경우 &lt;code&gt;0xC8&lt;/code&gt; ) 대문자 E는 2 바이트 &lt;code&gt;v196.172&lt;/code&gt; 로 표시됩니다 . 불행하게도, 비 유니 코드 문자열 &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr(196).chr(172)&lt;/a&gt;&lt;/code&gt; 는 그 바이트 시퀀스도 가지고 있습니다. 따라서보고만으로는 알 수 없습니다. 이것이 유니 코드 입력을 흥미로운 문제로 만듭니다.</target>
        </trans-unit>
        <trans-unit id="7f972addc76fd0cd985b7d4af8bf74af7b31dec1" translate="yes" xml:space="preserve">
          <source>You can't. This is because UTF-8 data is stored in bytes just like non-UTF-8 data. The Unicode character 200, (&lt;code&gt;0xC8&lt;/code&gt; for you hex types) capital E with a grave accent, is represented by the two bytes &lt;code&gt;v196.172&lt;/code&gt;. Unfortunately, the non-Unicode string &lt;code&gt;chr(196).chr(172)&lt;/code&gt; has that byte sequence as well. So you can't tell just by looking -- this is what makes Unicode input an interesting problem.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e5a4ed4ed782a30731e5ac82f99a95d222b188b0" translate="yes" xml:space="preserve">
          <source>You can't. You need to imitate the &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system()&lt;/a&gt;&lt;/code&gt; call (see &lt;a href=&quot;perlipc&quot;&gt;perlipc&lt;/a&gt; for sample code) and then have a signal handler for the INT signal that passes the signal on to the subprocess. Or you can check for it:</source>
          <target state="translated">당신은 할 수 없습니다. &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system()&lt;/a&gt;&lt;/code&gt; 호출 을 모방 한 다음 ( 샘플 코드 는 &lt;a href=&quot;perlipc&quot;&gt;perlipc&lt;/a&gt; 참조 ) 신호를 서브 프로세스로 전달하는 INT 신호에 대한 신호 핸들러가 있어야합니다. 또는 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6e29577f40cc4b8214af8a5686eca5058c2c6b00" translate="yes" xml:space="preserve">
          <source>You can't. You need to imitate the &lt;code&gt;system()&lt;/code&gt; call (see &lt;a href=&quot;perlipc&quot;&gt;perlipc&lt;/a&gt; for sample code) and then have a signal handler for the INT signal that passes the signal on to the subprocess. Or you can check for it:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="969f4cfd26924af3983dcc03e66552409285562e" translate="yes" xml:space="preserve">
          <source>You can, of course, declare separate handlers for these types as well (but you'll need to specify &lt;code&gt;&lt;a href=&quot;../functions/no&quot;&gt;no&lt;/a&gt; warnings 'redefine'&lt;/code&gt; to do it quietly):</source>
          <target state="translated">물론 이러한 유형에 대해 별도의 핸들러를 선언 할 수도 있습니다 (하지만 조용히하기 위해 &lt;code&gt;&lt;a href=&quot;../functions/no&quot;&gt;no&lt;/a&gt; warnings 'redefine'&lt;/code&gt; 를 지정 &lt;a href=&quot;../functions/no&quot;&gt;하지&lt;/a&gt; 않아도 됨 ).</target>
        </trans-unit>
        <trans-unit id="9b9ddea33f9624effb8458a53428961e73756f4e" translate="yes" xml:space="preserve">
          <source>You can, of course, declare separate handlers for these types as well (but you'll need to specify &lt;code&gt;no warnings 'redefine'&lt;/code&gt; to do it quietly):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74374dec5e50007a2bb85f4a7c8771f4686fdade" translate="yes" xml:space="preserve">
          <source>You cannot Configure Perl to use long doubles unless you have at least Tru64 V5.0, the long double support simply wasn't functional enough before that. Perl's Configure will override attempts to use the long doubles (you can notice this by Configure finding out that the modfl() function does not work as it should).</source>
          <target state="translated">Tru64 V5.0 이상이 아닌 이상 Long Double을 사용하도록 Perl을 구성 할 수 없습니다. Long Double 지원은 그 이전에는 충분히 기능하지 않았습니다. Perl의 Configure는 long double을 사용하려는 시도보다 우선합니다 (modfl () 함수가 제대로 작동하지 않음을 알아 냄으로써 Configure에 의해 알 수 있습니다).</target>
        </trans-unit>
        <trans-unit id="9d01ce1702f639775b361fb520a4a77dd3873994" translate="yes" xml:space="preserve">
          <source>You cannot add a regular filter to a hub if the hub was created in another process or thread. You can always add a pre_filter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12d8ae48400ed6e2886a4d5be754a09a9e2677eb" translate="yes" xml:space="preserve">
          <source>You cannot call &lt;code&gt;format_formfeed()&lt;/code&gt; on a handle, only as a static method. See &lt;a href=&quot;IO::Handle&quot;&gt;IO::Handle&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d8bdeec288ef204b43d051952afe1296036c485c" translate="yes" xml:space="preserve">
          <source>You cannot call &lt;code&gt;format_formfeed()&lt;/code&gt; on a handle, only as a static method. See &lt;a href=&quot;io/handle&quot;&gt;IO::Handle&lt;/a&gt;.</source>
          <target state="translated">정적 메소드로만 핸들에서 &lt;code&gt;format_formfeed()&lt;/code&gt; 를 호출 할 수 없습니다 . &lt;a href=&quot;io/handle&quot;&gt;IO :: Handle을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="886d6e7860352adfbf36238a2c3195543ecc4842" translate="yes" xml:space="preserve">
          <source>You cannot call &lt;code&gt;format_line_break_characters()&lt;/code&gt; on a handle, only as a static method. See &lt;a href=&quot;IO::Handle&quot;&gt;IO::Handle&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="206c72a8b7cef7a32a6db021ff310a9ca6c22c22" translate="yes" xml:space="preserve">
          <source>You cannot call &lt;code&gt;format_line_break_characters()&lt;/code&gt; on a handle, only as a static method. See &lt;a href=&quot;io/handle&quot;&gt;IO::Handle&lt;/a&gt;.</source>
          <target state="translated">정적 메서드로만 핸들에서 &lt;code&gt;format_line_break_characters()&lt;/code&gt; 를 호출 할 수 없습니다 . &lt;a href=&quot;io/handle&quot;&gt;IO :: Handle을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e0ebaf2ed18c8c28bbb77a954b42ef5fea55a1b9" translate="yes" xml:space="preserve">
          <source>You cannot call &lt;code&gt;input_record_separator()&lt;/code&gt; on a handle, only as a static method. See &lt;a href=&quot;IO::Handle&quot;&gt;IO::Handle&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be794aed40b9701358348d087034d06f390762c7" translate="yes" xml:space="preserve">
          <source>You cannot call &lt;code&gt;input_record_separator()&lt;/code&gt; on a handle, only as a static method. See &lt;a href=&quot;io/handle&quot;&gt;IO::Handle&lt;/a&gt;.</source>
          <target state="translated">정적 메소드로만 핸들에서 &lt;code&gt;input_record_separator()&lt;/code&gt; 를 호출 할 수 없습니다 . &lt;a href=&quot;io/handle&quot;&gt;IO :: Handle을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b3fbf7abc01d969743407ff802897565a9f2a54c" translate="yes" xml:space="preserve">
          <source>You cannot call &lt;code&gt;output_field_separator()&lt;/code&gt; on a handle, only as a static method. See &lt;a href=&quot;IO::Handle&quot;&gt;IO::Handle&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e9632f1b73e717ca255777fe1c2f39799e45e4a" translate="yes" xml:space="preserve">
          <source>You cannot call &lt;code&gt;output_field_separator()&lt;/code&gt; on a handle, only as a static method. See &lt;a href=&quot;io/handle&quot;&gt;IO::Handle&lt;/a&gt;.</source>
          <target state="translated">정적 메소드로만 핸들에서 &lt;code&gt;output_field_separator()&lt;/code&gt; 를 호출 할 수 없습니다 . &lt;a href=&quot;io/handle&quot;&gt;IO :: Handle을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="2c8b5595acc49990fca235aed04153d4258b087b" translate="yes" xml:space="preserve">
          <source>You cannot call &lt;code&gt;output_record_separator()&lt;/code&gt; on a handle, only as a static method. See &lt;a href=&quot;IO::Handle&quot;&gt;IO::Handle&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c9f3ec65172d98e67d60dc40971034bddc7747e9" translate="yes" xml:space="preserve">
          <source>You cannot call &lt;code&gt;output_record_separator()&lt;/code&gt; on a handle, only as a static method. See &lt;a href=&quot;io/handle&quot;&gt;IO::Handle&lt;/a&gt;.</source>
          <target state="translated">정적 메소드로만 핸들에서 &lt;code&gt;output_record_separator()&lt;/code&gt; 를 호출 할 수 없습니다 . &lt;a href=&quot;io/handle&quot;&gt;IO :: Handle을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c9134fa5f451fb01a8e6eeae9f39b7f5a89fc7ce" translate="yes" xml:space="preserve">
          <source>You cannot change the ordering once the database has been created. Thus you must use the same compare function every time you access the database.</source>
          <target state="translated">데이터베이스가 작성된 후에는 순서를 변경할 수 없습니다. 따라서 데이터베이스에 액세스 할 때마다 동일한 비교 기능을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="9e33a69a0160e97c284c6f83bf69b3911fb50910" translate="yes" xml:space="preserve">
          <source>You cannot currently get the precision from a specified number, but it is intended that this will be possible in the future, for example using &lt;code&gt;.*2$&lt;/code&gt;:</source>
          <target state="translated">현재 지정된 숫자에서 정밀도를 얻을 수는 없지만 앞으로는 &lt;code&gt;.*2$&lt;/code&gt; 를 사용하여 가능할 것입니다 .</target>
        </trans-unit>
        <trans-unit id="9a19723c24ab74fcf1cad038cc364f2eed15903b" translate="yes" xml:space="preserve">
          <source>You cannot discern from mere inspection which builtins are unary operators (like chop() and chdir()) and which are list operators (like print() and unlink()). (Unless prototyped, user-defined subroutines can &lt;b&gt;only&lt;/b&gt; be list operators, never unary ones.) See &lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt; and &lt;a href=&quot;perlsub&quot;&gt;perlsub&lt;/a&gt;.</source>
          <target state="translated">chop () 및 chdir ()과 같은 단항 연산자와 print () 및 unlink ()와 같은 목록 연산자 인 내장 검사 만 구분할 수는 없습니다. 프로토 타입이 아닌 &lt;b&gt;경우&lt;/b&gt; 사용자 정의 서브 루틴은 목록 연산자 일 수 있으며 단항 연산자는 될 수 없습니다. &lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt; 및 &lt;a href=&quot;perlsub&quot;&gt;perlsub를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ab137c3fb7d6e07844b33eb499911ea797677bd5" translate="yes" xml:space="preserve">
          <source>You cannot easily tie a multilevel data structure (such as a hash of hashes) to a dbm file. The first problem is that all but GDBM and Berkeley DB have size limitations, but beyond that, you also have problems with how references are to be represented on disk. One experimental module that does partially attempt to address this need is the MLDBM module. Check your nearest CPAN site as described in &lt;a href=&quot;perlmodlib&quot;&gt;perlmodlib&lt;/a&gt; for source code to MLDBM.</source>
          <target state="translated">다중 레벨 데이터 구조 (예 : 해시 해시)를 dbm 파일에 쉽게 연결할 수 없습니다. 첫 번째 문제는 GDBM과 Berkeley DB를 제외한 모든 크기에는 크기 제한이 있지만 그 외에도 디스크에서 참조가 표현되는 방식에 문제가 있다는 것입니다. 이러한 요구를 부분적으로 해결하려는 실험 모듈 중 하나는 MLDBM 모듈입니다. 에 설명 된대로 가까운 CPAN 사이트를 확인 &lt;a href=&quot;perlmodlib&quot;&gt;perlmodlib&lt;/a&gt; MLDBM에 소스 코드.</target>
        </trans-unit>
        <trans-unit id="38213a95a75072574eb5ab9364f983653ee56ffc" translate="yes" xml:space="preserve">
          <source>You cannot easily tie a multilevel data structure (such as a hash of hashes) to a dbm file. The first problem is that all but GDBM and Berkeley DB have size limitations, but beyond that, you also have problems with how references are to be represented on disk. One module that does attempt to address this need is DBM::Deep. Check your nearest CPAN site as described in &lt;a href=&quot;perlmodlib&quot;&gt;perlmodlib&lt;/a&gt; for source code. Note that despite its name, DBM::Deep does not use dbm. Another earlier attempt at solving the problem is MLDBM, which is also available on the CPAN, but which has some fairly serious limitations.</source>
          <target state="translated">다중 레벨 데이터 구조 (예 : 해시 해시)를 dbm 파일에 쉽게 연결할 수 없습니다. 첫 번째 문제는 GDBM과 Berkeley DB를 제외한 모든 크기에는 크기 제한이 있지만 그 외에도 디스크에서 참조가 표현되는 방식에 문제가 있다는 것입니다. 이 요구를 해결하려는 하나의 모듈은 DBM :: Deep입니다. 소스 코드 는 &lt;a href=&quot;perlmodlib&quot;&gt;perlmodlib&lt;/a&gt; 에 설명 된대로 가장 가까운 CPAN 사이트를 확인하십시오 . 이름에도 불구하고 DBM :: Deep은 dbm을 사용하지 않습니다. 이 문제를 해결하기위한 또 다른 초기 시도는 MLDBM이며 CPAN에서도 사용 가능하지만 상당히 심각한 제한이 있습니다.</target>
        </trans-unit>
        <trans-unit id="54808a204fe862b1dfa25e752a892b2a04ab63bf" translate="yes" xml:space="preserve">
          <source>You cannot get stack frame information or in any fashion debug functions that were not compiled by Perl, such as those from C or C++ extensions.</source>
          <target state="translated">스택 프레임 정보 나 Perl에 의해 컴파일되지 않은 디버그 함수 (예 : C 또는 C ++ 확장의 함수)는 얻을 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="b370a3f9299c4f8abb35adc5b9b2b86568a00bc8" translate="yes" xml:space="preserve">
          <source>You cannot lock the individual elements of a container variable:</source>
          <target state="translated">컨테이너 변수의 개별 요소를 잠글 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="f2b8b7a26c050e538a292ea22f61da0581625210" translate="yes" xml:space="preserve">
          <source>You cannot portably &quot;stack&quot; cpp directives. For example in the above you need two separate BURGLE() #defines, one for each #ifdef branch.</source>
          <target state="translated">cpp 지시문을 이식 가능하게 &quot;스택&quot;할 수 없습니다. 예를 들어 위의 #ifdef 분기마다 하나씩 두 개의 별도 BURGLE () #defines이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="b918f134e01ab04a493d865bacd0ad2555d6eed0" translate="yes" xml:space="preserve">
          <source>You cannot set $RS to a pattern, only a string.</source>
          <target state="translated">$ RS를 패턴으로 설정할 수 없으며 문자열 만 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="891970fccef081510b98291902ea82121168e7ae" translate="yes" xml:space="preserve">
          <source>You cannot tie this routine directly to an option, e.g.:</source>
          <target state="translated">이 루틴을 옵션에 직접 연결할 수 없습니다. 예 :</target>
        </trans-unit>
        <trans-unit id="2d9b5eae243979aa930fce2644c85c94e98e03e5" translate="yes" xml:space="preserve">
          <source>You cannot use &lt;b&gt;-i&lt;/b&gt; to create directories or to strip extensions from files.</source>
          <target state="translated">&lt;b&gt;-i&lt;/b&gt; 를 사용하여 디렉토리를 작성하거나 파일에서 확장자를 제거 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="3d40633e0023663f60f6c6868c36efce9e85c50a" translate="yes" xml:space="preserve">
          <source>You compare the sort keys using a binary comparison and get the result of the comparison of the strings using UCA.</source>
          <target state="translated">이진 비교를 사용하여 정렬 키를 비교하고 UCA를 사용하여 문자열을 비교 한 결과를 얻습니다.</target>
        </trans-unit>
        <trans-unit id="794fe9a7963db4b15645c3e75175ca30a42e7c02" translate="yes" xml:space="preserve">
          <source>You could also exclude &lt;code&gt;LC_NUMERIC&lt;/code&gt; , if you don't need it, by</source>
          <target state="translated">필요하지 않은 경우 &lt;code&gt;LC_NUMERIC&lt;/code&gt; 을 제외 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="7f8b90476595b6a38493d09d09f4d09a3ee84510" translate="yes" xml:space="preserve">
          <source>You could also exclude &lt;code&gt;LC_NUMERIC&lt;/code&gt;, if you don't need it, by</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63946de92748533808fd29d4342bd54a0ec7a953" translate="yes" xml:space="preserve">
          <source>You could also have used the existing block property names:</source>
          <target state="translated">기존 블록 특성 이름을 사용할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="eaa54d59d0ed5e55dbc530f16d131415959a1711" translate="yes" xml:space="preserve">
          <source>You could also investigate the can() method in the UNIVERSAL class (part of the standard perl distribution).</source>
          <target state="translated">UNIVERSAL 클래스 (표준 perl 분배의 일부)에서 can () 메소드를 조사 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="802dff37470d190b2a864a13c708bc5907b98d91" translate="yes" xml:space="preserve">
          <source>You could also just know all the perl errors, and although there are some people who may know all of them, you probably don't. However, they all should be in the &lt;a href=&quot;perldiag&quot;&gt;perldiag&lt;/a&gt; manpage. If you don't find the error in there, it probably isn't a perl error.</source>
          <target state="translated">당신은 또한 모든 펄 오류를 알 수 있으며, 그것들을 모두 아는 사람들이 있지만 아마 그렇지 않을 것입니다. 그러나 모두 &lt;a href=&quot;perldiag&quot;&gt;perldiag&lt;/a&gt; 맨 페이지 에 있어야합니다 . 거기에서 오류를 찾지 못하면 아마도 perl 오류가 아닐 것입니다.</target>
        </trans-unit>
        <trans-unit id="80d2dd3ba7c4c2069cf58261b6aaeb6dcd467d24" translate="yes" xml:space="preserve">
          <source>You could also write a single get/set method using an optional argument:</source>
          <target state="translated">선택적 인수를 사용하여 단일 get / set 메소드를 작성할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="8444b9fc7a3ed8d2fa7659ffde996510ee7f1f46" translate="yes" xml:space="preserve">
          <source>You could build a web site using &lt;a href=&quot;http://search.cpan.org/perldoc/Plack&quot;&gt;Plack&lt;/a&gt; and your own code, but for anything other than a very basic web site, using a web framework (that uses &lt;a href=&quot;http://search.cpan.org/perldoc/Plack&quot;&gt;Plack&lt;/a&gt;) is a better option.</source>
          <target state="translated">&lt;a href=&quot;http://search.cpan.org/perldoc/Plack&quot;&gt;Plack&lt;/a&gt; 과 자체 코드를 사용하여 웹 사이트를 구축 할 수 있지만 매우 기본적인 웹 사이트 이외의 다른 웹 사이트에는 &lt;a href=&quot;http://search.cpan.org/perldoc/Plack&quot;&gt;Plack&lt;/a&gt; 을 사용하는 웹 프레임 워크를 사용 하는 것이 더 좋습니다.</target>
        </trans-unit>
        <trans-unit id="5c2c9c77f0aed52ec579ee2ac823c3d0735f4eb0" translate="yes" xml:space="preserve">
          <source>You could build a web site using &lt;a href=&quot;plack&quot;&gt;Plack&lt;/a&gt; and your own code, but for anything other than a very basic web site, using a web framework (that uses &lt;a href=&quot;https://plackperl.org&quot;&gt;https://plackperl.org&lt;/a&gt;) is a better option.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2158ae7a8b9ea3f34a07fb0e90c3b98892665dc8" translate="yes" xml:space="preserve">
          <source>You could conceivably do both.</source>
          <target state="translated">두 가지를 모두 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="49073618f97078f446e251732bebc1a46a9b86b9" translate="yes" xml:space="preserve">
          <source>You could do the memoization yourself, by rewriting the function, like this:</source>
          <target state="translated">다음과 같이 함수를 다시 작성하여 메모를 직접 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="958608f6d5208c278d0f2a3422ee32f9617b3a57" translate="yes" xml:space="preserve">
          <source>You could do this through opening an ordinary filehandle into each of those files, gradually building up an in-memory array of all the file contents you load this way, and finally sorting and filtering that array when you've run out of files to load.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a8bc28868b949ea5a73ffcd10a5a6d7af5c6ab02" translate="yes" xml:space="preserve">
          <source>You could do this:</source>
          <target state="translated">당신은 이것을 할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="9e128ecfca5b0e265baad327ad431d782e5e7ffc" translate="yes" xml:space="preserve">
          <source>You could edit that header yourself to remove that last '/', or you might note that Language Environment (LE) APAR PQ39997 describes the problem and PTF's UQ46272 and UQ46271 are the (R8 at least) fixes and apply them. If left unattended that syntax error will turn up as an inability for Perl to build its &quot;Socket&quot; extension.</source>
          <target state="translated">해당 헤더를 직접 편집하여 마지막 '/'를 제거하거나, 언어 환경 (LE) APAR PQ39997이 문제점을 설명하고 PTF의 UQ46272 및 UQ46271이 (적어도 R8) 수정 사항임을 적용 할 수 있습니다. 방치하면 구문 오류가 Perl이 &quot;소켓&quot;확장을 빌드 할 수없는 것으로 나타납니다.</target>
        </trans-unit>
        <trans-unit id="3e7ad6be7d9fb2b01433fa3be5444bc3be8a1d7d" translate="yes" xml:space="preserve">
          <source>You could instead do lookups on $wanted with:</source>
          <target state="translated">대신 다음과 같이 $ wanted에 대한 조회를 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="457f8e624ad1da28bfb9cf34b1f79dc6623d16da" translate="yes" xml:space="preserve">
          <source>You could just store all your dates as a number and then subtract. Life isn't always that simple though.</source>
          <target state="translated">모든 날짜를 숫자로 저장 한 다음 빼기 만하면됩니다. 인생이 항상 그렇게 간단한 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="c19f6ab6291cf9eaf2e211ed563b35ea9ac437b5" translate="yes" xml:space="preserve">
          <source>You could open the document in a web browser, and change the character set or character encoding until you can visually confirm that all characters look the way they should.</source>
          <target state="translated">웹 브라우저에서 문서를 열고 모든 문자가 원하는대로 보이는지 시각적으로 확인할 수있을 때까지 문자 세트 또는 문자 인코딩을 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6bbc1dc32472d30736fd70aa0522d187dae0801f" translate="yes" xml:space="preserve">
          <source>You could tell make to run tests in both of those directories with the following directives:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a20c232c667e613d02f2b4874878f40bc6c28f2" translate="yes" xml:space="preserve">
          <source>You could write the last two using the &lt;code&gt;-u&lt;/code&gt; and &lt;code&gt;-d&lt;/code&gt; operators. Commonly available &lt;code&gt;S_IF*&lt;/code&gt; constants are:</source>
          <target state="translated">&lt;code&gt;-u&lt;/code&gt; 및 &lt;code&gt;-d&lt;/code&gt; 연산자를 사용하여 마지막 두 개를 작성할 수 있습니다. 일반적으로 사용 가능한 &lt;code&gt;S_IF*&lt;/code&gt; 상수는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2516f9cbf3f3333565923611bf8e4c6225451c64" translate="yes" xml:space="preserve">
          <source>You create the queue with &lt;code&gt;Thread::Queue-&amp;gt;new()&lt;/code&gt; . Then you can add lists of scalars onto the end with &lt;code&gt;enqueue()&lt;/code&gt; , and pop scalars off the front of it with &lt;code&gt;dequeue()&lt;/code&gt; . A queue has no fixed size, and can grow as needed to hold everything pushed on to it.</source>
          <target state="translated">&lt;code&gt;Thread::Queue-&amp;gt;new()&lt;/code&gt; 대기열을 만듭니다 . 그런 다음 &lt;code&gt;enqueue()&lt;/code&gt; 를 사용하여 끝에 스칼라 목록을 추가 하고 &lt;code&gt;dequeue()&lt;/code&gt; 사용하여 스칼라를 앞에 표시 할 수 있습니다 . 대기열의 크기는 고정되어 있지 않으며 대기열에 푸시 된 모든 항목을 보관하는 데 필요에 따라 커질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c19ccf2bc39b48b6ea782f37420e2fd0ec94934e" translate="yes" xml:space="preserve">
          <source>You create the queue with &lt;code&gt;Thread::Queue-&amp;gt;new()&lt;/code&gt;. Then you can add lists of scalars onto the end with &lt;code&gt;enqueue()&lt;/code&gt;, and pop scalars off the front of it with &lt;code&gt;dequeue()&lt;/code&gt;. A queue has no fixed size, and can grow as needed to hold everything pushed on to it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dede4110b8ccb447bd7101130015f76cda530da1" translate="yes" xml:space="preserve">
          <source>You currently don't need to instantiate a factory in order to use it.</source>
          <target state="translated">현재 팩토리를 사용하기 위해 인스턴스화 할 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="94aa24e74566493da77121fdf1cf79a43455f271" translate="yes" xml:space="preserve">
          <source>You did not run &lt;code&gt;omflibs&lt;/code&gt; . See &lt;a href=&quot;#Prerequisites&quot;&gt;Prerequisites&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;omflibs&lt;/code&gt; 를 실행하지 않았습니다 . &lt;a href=&quot;#Prerequisites&quot;&gt;전제 조건을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="520c8e979cd55500908dc61d154b50983c533336" translate="yes" xml:space="preserve">
          <source>You did not run &lt;code&gt;omflibs&lt;/code&gt;. See &lt;a href=&quot;#Prerequisites&quot;&gt;&quot;Prerequisites&quot;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="351e72fc696e530c4b98b81dced35a153aee9b73" translate="yes" xml:space="preserve">
          <source>You did try the &lt;b&gt;-w&lt;/b&gt; switch, didn't you?</source>
          <target state="translated">&lt;b&gt;-w&lt;/b&gt; 스위치를 사용해 보지 않습니까?</target>
        </trans-unit>
        <trans-unit id="4eedca5e5af0ab78e40eb2863f783568ef2a973d" translate="yes" xml:space="preserve">
          <source>You do have &lt;code&gt;use strict&lt;/code&gt; and &lt;code&gt;use warnings&lt;/code&gt; enabled, don't you?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88ae653a2469feaccaacebc0c4775e33fd1da464" translate="yes" xml:space="preserve">
          <source>You do need to be careful with the logical names representing process-permanent files, such as &lt;code&gt;SYS$INPUT&lt;/code&gt; and &lt;code&gt;SYS$OUTPUT&lt;/code&gt; . The translations for these logical names are prepended with a two-byte binary value (0x1B 0x00) that needs to be stripped off if you want to use it. (In previous versions of Perl it wasn't possible to get the values of these logical names, as the null byte acted as an end-of-string marker)</source>
          <target state="translated">&lt;code&gt;SYS$INPUT&lt;/code&gt; 및 &lt;code&gt;SYS$OUTPUT&lt;/code&gt; 과 같은 프로세스 영구 파일을 나타내는 논리 이름에주의해야합니다 . 이러한 논리 이름에 대한 변환은 사용하려는 경우 제거해야하는 2 바이트 2 진 값 (0x1B 0x00)이 앞에 붙습니다. (이전 버전의 Perl에서는 널 바이트가 문자열 끝 마커로 작동하므로 이러한 논리적 이름의 값을 얻을 수 없었습니다)</target>
        </trans-unit>
        <trans-unit id="50985c33eacad99671dfcb8dd8006db36d362e65" translate="yes" xml:space="preserve">
          <source>You do need to be careful with the logical names representing process-permanent files, such as &lt;code&gt;SYS$INPUT&lt;/code&gt; and &lt;code&gt;SYS$OUTPUT&lt;/code&gt;. The translations for these logical names are prepended with a two-byte binary value (0x1B 0x00) that needs to be stripped off if you want to use it. (In previous versions of Perl it wasn't possible to get the values of these logical names, as the null byte acted as an end-of-string marker)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="058b0924bf8d4ec16b563bbf0577363645a7bf62" translate="yes" xml:space="preserve">
          <source>You do not call &lt;code&gt;setlogsock&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;setlogsock&lt;/code&gt; 을 호출하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="66b3b57985e95259e75aa2f231d8ac7e67d53cd1" translate="yes" xml:space="preserve">
          <source>You do not call &lt;code&gt;setlogsock&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0688f744612cb917b09a1848a221dbc87e7927a1" translate="yes" xml:space="preserve">
          <source>You do not have MT-safe</source>
          <target state="translated">MT 안전 장치가 없습니다</target>
        </trans-unit>
        <trans-unit id="2e1ca2f68a9ba2ef298384c1d65396bc3e584c1e" translate="yes" xml:space="preserve">
          <source>You do not have to override methods shown below unless you have to.</source>
          <target state="translated">필요한 경우가 아니면 아래에 표시된 방법을 재정의 할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="fb758f283ea1827a0e24eaa44c4a0b710b292031" translate="yes" xml:space="preserve">
          <source>You do not need to use this directly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d463f5c40ea27790902d715d5582fd331f2a8862" translate="yes" xml:space="preserve">
          <source>You do this by using &lt;a href=&quot;carp&quot;&gt;Carp&lt;/a&gt; and replacing your &lt;code&gt;&lt;a href=&quot;functions/warn&quot;&gt;warn&lt;/a&gt;&lt;/code&gt;s with &lt;code&gt;carp&lt;/code&gt; s. If you need to &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt;, say &lt;code&gt;croak&lt;/code&gt; instead. However, keep &lt;code&gt;&lt;a href=&quot;functions/warn&quot;&gt;warn&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; in place for your sanity checks - where it really is your module at fault.</source>
          <target state="translated">당신은 사용하여이 작업을 수행 &lt;a href=&quot;carp&quot;&gt;잉어를&lt;/a&gt; 하고 교체 &lt;code&gt;&lt;a href=&quot;functions/warn&quot;&gt;warn&lt;/a&gt;&lt;/code&gt; 에들 &lt;code&gt;carp&lt;/code&gt; 들. 당신이해야하는 경우 &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; 라고 &lt;code&gt;croak&lt;/code&gt; 대신. 그러나 위생 검사를 위해 &lt;code&gt;&lt;a href=&quot;functions/warn&quot;&gt;warn&lt;/a&gt;&lt;/code&gt; 하고 &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; -실제로 모듈이 고장난 곳.</target>
        </trans-unit>
        <trans-unit id="113f89135b9f076e711872b293b64852cb136b98" translate="yes" xml:space="preserve">
          <source>You do this by using &lt;a href=&quot;carp&quot;&gt;Carp&lt;/a&gt; and replacing your &lt;code&gt;warn&lt;/code&gt;s with &lt;code&gt;carp&lt;/code&gt;s. If you need to &lt;code&gt;die&lt;/code&gt;, say &lt;code&gt;croak&lt;/code&gt; instead. However, keep &lt;code&gt;warn&lt;/code&gt; and &lt;code&gt;die&lt;/code&gt; in place for your sanity checks - where it really is your module at fault.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="005e9bdc4a22cadca7bbf603665f85ba87cfef2b" translate="yes" xml:space="preserve">
          <source>You don't actually</source>
          <target state="translated">당신은 실제로하지 않습니다</target>
        </trans-unit>
        <trans-unit id="5d5d63d2e431a9c6b982f4e636021ca69ef4faa3" translate="yes" xml:space="preserve">
          <source>You don't actually &quot;trap&quot; a control character. Instead, that character generates a signal which is sent to your terminal's currently foregrounded process group, which you then trap in your process. Signals are documented in &lt;a href=&quot;perlipc#Signals&quot;&gt;&quot;Signals&quot; in perlipc&lt;/a&gt; and the section on &quot;Signals&quot; in the Camel.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="27b09323fd0303316a1e04f47208b954d9880846" translate="yes" xml:space="preserve">
          <source>You don't actually &quot;trap&quot; a control character. Instead, that character generates a signal which is sent to your terminal's currently foregrounded process group, which you then trap in your process. Signals are documented in &lt;a href=&quot;perlipc#Signals&quot;&gt;Signals in perlipc&lt;/a&gt; and the section on &quot;Signals&quot; in the Camel.</source>
          <target state="translated">실제로 제어 문자를 &quot;트랩&quot;하지는 않습니다. 대신, 해당 캐릭터는 터미널의 현재 포 그라운드 프로세스 그룹으로 전송되는 신호를 생성 한 다음 프로세스에 갇 힙니다. 신호는 &lt;a href=&quot;perlipc#Signals&quot;&gt;perlipc의 신호&lt;/a&gt; 및 Camel의 &quot;신호&quot;섹션에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="43005f5be66bea21174dcb83ad3e5e91f2ebadaa" translate="yes" xml:space="preserve">
          <source>You don't have to check for &lt;a href=&quot;#defined-EXPR&quot;&gt;&lt;code&gt;defined&lt;/code&gt;&lt;/a&gt; on the return from &lt;a href=&quot;#fcntl-FILEHANDLE%2CFUNCTION%2CSCALAR&quot;&gt;&lt;code&gt;fcntl&lt;/code&gt;&lt;/a&gt;. Like &lt;a href=&quot;#ioctl-FILEHANDLE%2CFUNCTION%2CSCALAR&quot;&gt;&lt;code&gt;ioctl&lt;/code&gt;&lt;/a&gt;, it maps a &lt;code&gt;0&lt;/code&gt; return from the system call into &lt;code&gt;&quot;0 but true&quot;&lt;/code&gt; in Perl. This string is true in boolean context and &lt;code&gt;0&lt;/code&gt; in numeric context. It is also exempt from the normal &lt;a href=&quot;perldiag#Argument-%22%25s%22-isn%27t-numeric%25s&quot;&gt;&lt;code&gt;Argument &quot;...&quot; isn't numeric&lt;/code&gt;&lt;/a&gt;&lt;a href=&quot;warnings&quot;&gt;warnings&lt;/a&gt; on improper numeric conversions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b1e2e036145d009e379c1e58f4e8404e4bb7c5f" translate="yes" xml:space="preserve">
          <source>You don't have to check for &lt;code&gt;&lt;a href=&quot;defined&quot;&gt;defined&lt;/a&gt;&lt;/code&gt; on the return from &lt;code&gt;&lt;a href=&quot;fcntl&quot;&gt;fcntl&lt;/a&gt;&lt;/code&gt;. Like &lt;code&gt;&lt;a href=&quot;ioctl&quot;&gt;ioctl&lt;/a&gt;&lt;/code&gt;, it maps a &lt;code&gt;0&lt;/code&gt; return from the system call into &lt;code&gt;&quot;0 but true&quot;&lt;/code&gt; in Perl. This string is true in boolean context and &lt;code&gt;0&lt;/code&gt; in numeric context. It is also exempt from the normal &lt;b&gt;-w&lt;/b&gt; warnings on improper numeric conversions.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;fcntl&quot;&gt;fcntl&lt;/a&gt;&lt;/code&gt; 로부터의 리턴 에 &lt;code&gt;&lt;a href=&quot;defined&quot;&gt;defined&lt;/a&gt;&lt;/code&gt; 것을 확인할 필요가 없습니다 . &lt;code&gt;&lt;a href=&quot;ioctl&quot;&gt;ioctl&lt;/a&gt;&lt;/code&gt; 과 마찬가지로 시스템 호출 의 &lt;code&gt;0&lt;/code&gt; 리턴을 Perl의 &lt;code&gt;&quot;0 but true&quot;&lt;/code&gt; 에 맵핑합니다 . 이 문자열은 부울 컨텍스트에서는 true이고 숫자 컨텍스트에서는 &lt;code&gt;0&lt;/code&gt; 입니다. 부적절한 숫자 변환에 대한 일반적인 &lt;b&gt;-w&lt;/b&gt; 경고 도 면제됩니다 .&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="91e28b8dde4eef2778828dc13bbb504ddd8429b3" translate="yes" xml:space="preserve">
          <source>You don't have to check for &lt;code&gt;&lt;a href=&quot;functions/defined&quot;&gt;defined&lt;/a&gt;&lt;/code&gt; on the return from &lt;code&gt;&lt;a href=&quot;functions/fcntl&quot;&gt;fcntl&lt;/a&gt;&lt;/code&gt;. Like &lt;code&gt;&lt;a href=&quot;functions/ioctl&quot;&gt;ioctl&lt;/a&gt;&lt;/code&gt;, it maps a &lt;code&gt;0&lt;/code&gt; return from the system call into &lt;code&gt;&quot;0 but true&quot;&lt;/code&gt; in Perl. This string is true in boolean context and &lt;code&gt;0&lt;/code&gt; in numeric context. It is also exempt from the normal &lt;b&gt;-w&lt;/b&gt; warnings on improper numeric conversions.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/fcntl&quot;&gt;fcntl&lt;/a&gt;&lt;/code&gt; 로부터의 리턴 에 &lt;code&gt;&lt;a href=&quot;functions/defined&quot;&gt;defined&lt;/a&gt;&lt;/code&gt; 것을 확인할 필요가 없습니다 . &lt;code&gt;&lt;a href=&quot;functions/ioctl&quot;&gt;ioctl&lt;/a&gt;&lt;/code&gt; 과 마찬가지로 시스템 호출 의 &lt;code&gt;0&lt;/code&gt; 리턴을 Perl의 &lt;code&gt;&quot;0 but true&quot;&lt;/code&gt; 에 맵핑합니다 . 이 문자열은 부울 컨텍스트에서는 true이고 숫자 컨텍스트에서는 &lt;code&gt;0&lt;/code&gt; 입니다. 부적절한 숫자 변환에 대한 일반적인 &lt;b&gt;-w&lt;/b&gt; 경고 도 면제됩니다 .&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="b28935e71a19f281a841ddb06e95aa9113f5e9af" translate="yes" xml:space="preserve">
          <source>You don't have to close FILEHANDLE if you are immediately going to do another &lt;a href=&quot;#open-FILEHANDLE%2CMODE%2CEXPR&quot;&gt;&lt;code&gt;open&lt;/code&gt;&lt;/a&gt; on it, because &lt;a href=&quot;#open-FILEHANDLE%2CMODE%2CEXPR&quot;&gt;&lt;code&gt;open&lt;/code&gt;&lt;/a&gt; closes it for you. (See &lt;a href=&quot;#open-FILEHANDLE%2CMODE%2CEXPR&quot;&gt;&lt;code&gt;open&lt;/code&gt;&lt;/a&gt;.) However, an explicit &lt;a href=&quot;#close-FILEHANDLE&quot;&gt;&lt;code&gt;close&lt;/code&gt;&lt;/a&gt; on an input file resets the line counter (&lt;a href=&quot;perlvar#%24.&quot;&gt;&lt;code&gt;$.&lt;/code&gt;&lt;/a&gt;), while the implicit close done by &lt;a href=&quot;#open-FILEHANDLE%2CMODE%2CEXPR&quot;&gt;&lt;code&gt;open&lt;/code&gt;&lt;/a&gt; does not.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3317a455934bcb4f5310b2ce1e13684a7b6884c6" translate="yes" xml:space="preserve">
          <source>You don't have to close FILEHANDLE if you are immediately going to do another &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; on it, because &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; closes it for you. (See &lt;a href=&quot;#open-FILEHANDLE&quot;&gt;open&lt;/a&gt;.) However, an explicit &lt;code&gt;&lt;a href=&quot;functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; on an input file resets the line counter (&lt;code&gt;$.&lt;/code&gt; ), while the implicit close done by &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; does not.</source>
          <target state="translated">당신은 즉시 다른가하려고하는 경우 FILEHANDLE을 닫을 필요가 없습니다 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; , 그것을 이유로 인해 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; 당신을 위해 닫히고을. ( &lt;a href=&quot;#open-FILEHANDLE&quot;&gt;open&lt;/a&gt; 참조 ) 그러나 입력 파일을 명시 적으로 &lt;code&gt;&lt;a href=&quot;functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; 행 카운터 ( &lt;code&gt;$.&lt;/code&gt; )가 재설정되지만 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; 으로 수행 된 암시 적 닫기는 재설정 되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d144697260e1beed6903444902a55fc7aceb423c" translate="yes" xml:space="preserve">
          <source>You don't have to close FILEHANDLE if you are immediately going to do another &lt;code&gt;&lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; on it, because &lt;code&gt;&lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; closes it for you. (See &lt;a href=&quot;#open-FILEHANDLE&quot;&gt;open&lt;/a&gt;.) However, an explicit &lt;code&gt;&lt;a href=&quot;close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; on an input file resets the line counter (&lt;code&gt;$.&lt;/code&gt; ), while the implicit close done by &lt;code&gt;&lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; does not.</source>
          <target state="translated">당신은 즉시 다른가하려고하는 경우 FILEHANDLE을 닫을 필요가 없습니다 &lt;code&gt;&lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; , 그것을 이유로 인해 &lt;code&gt;&lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; 당신을 위해 닫히고을. ( &lt;a href=&quot;#open-FILEHANDLE&quot;&gt;open&lt;/a&gt; 참조 ) 그러나 입력 파일을 명시 적으로 &lt;code&gt;&lt;a href=&quot;close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; 행 카운터 ( &lt;code&gt;$.&lt;/code&gt; )가 재설정되지만 &lt;code&gt;&lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; 으로 수행 된 암시 적 닫기는 재설정 되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ada37b6245f195e4fcd7aa6724d9b314782b9989" translate="yes" xml:space="preserve">
          <source>You don't have to do anything new in your extension to get this; since the Perl library provides Perl_get_context(), it will all just work.</source>
          <target state="translated">이를 위해 확장 프로그램에서 새로운 작업을 수행 할 필요는 없습니다. Perl 라이브러리는 Perl_get_context ()를 제공하므로 모두 작동합니다.</target>
        </trans-unit>
        <trans-unit id="0afa6281a85d9c8f0451db68d3408cd7d6bba6a9" translate="yes" xml:space="preserve">
          <source>You don't have to do this all on the command line, though, there are a few GUI options out there. The nice thing about these is you can wave a mouse over a variable and a dump of its data will appear in an appropriate window, or in a popup balloon, no more tiresome typing of 'x $varname' :-)</source>
          <target state="translated">명령 행에서이 작업을 모두 수행 할 필요는 없지만 몇 가지 GUI 옵션이 있습니다. 이것에 대한 좋은 점은 변수 위에 마우스를 흔들면 해당 데이터 덤프가 적절한 창이나 팝업 풍선에 나타나고 더 이상 'x $ varname'을 타이핑하지 않아도됩니다 :-)</target>
        </trans-unit>
        <trans-unit id="bc3f5455b30ee7863f96aa530c94393c0cafca20" translate="yes" xml:space="preserve">
          <source>You don't have to enclose POSIX class names inside double brackets, hence both of the following work:</source>
          <target state="translated">POSIX 클래스 이름을 이중 괄호 안에 넣을 필요가 없으므로 다음 작업이 모두 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="229ae092ed53a2ce77c4892afb43389969fbd9bc" translate="yes" xml:space="preserve">
          <source>You don't have to use \b to match words though. You can look for non-word characters surrounded by word characters. These strings match the pattern /\b'\b/.</source>
          <target state="translated">그래도 단어를 일치시키기 위해 \ b를 사용할 필요는 없습니다. 단어 문자로 둘러싸인 단어 이외의 문자를 찾을 수 있습니다. 이 문자열은 / \ b '\ b / 패턴과 일치합니다.</target>
        </trans-unit>
        <trans-unit id="21cad750fa1f143b35b4124baa7518d27d8319c9" translate="yes" xml:space="preserve">
          <source>You don't have to worry about finding or paying for Perl; it's freely available and several popular operating systems come with Perl. Community support in places such as Perlmonks ( &lt;a href=&quot;http://www.perlmonks.com&quot;&gt;http://www.perlmonks.com&lt;/a&gt; ) and the various Perl mailing lists ( &lt;a href=&quot;http://lists.perl.org&quot;&gt;http://lists.perl.org&lt;/a&gt; ) means that you can usually get quick answers to your problems.</source>
          <target state="translated">Perl을 찾거나 지불하는 것에 대해 걱정할 필요가 없습니다. 무료로 사용할 수 있으며 몇 가지 인기있는 운영 체제가 Perl과 함께 제공됩니다. Perlmonks ( &lt;a href=&quot;http://www.perlmonks.com&quot;&gt;http://www.perlmonks.com&lt;/a&gt; ) 및 다양한 Perl 메일 링리스트 ( &lt;a href=&quot;http://lists.perl.org&quot;&gt;http://lists.perl.org&lt;/a&gt; ) 와 같은 장소에서의 커뮤니티 지원 은 일반적으로 문제점에 대한 빠른 답변을 얻을 수 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="8365eeff3d04c895cb1076cf6e1217da1d00d04f" translate="yes" xml:space="preserve">
          <source>You don't just have to match on fixed strings. In fact, you can match on just about anything you could dream of by using more complex regular expressions. These are documented at great length in &lt;a href=&quot;perlre&quot;&gt;perlre&lt;/a&gt;, but for the meantime, here's a quick cheat sheet:</source>
          <target state="translated">고정 문자열에서만 일치시킬 필요는 없습니다. 사실, 더 복잡한 정규식을 사용하여 꿈꾸는 모든 것에 대해 일치시킬 수 있습니다. 이것들은 &lt;a href=&quot;perlre&quot;&gt;perlre&lt;/a&gt; 에 아주 길게 문서화되어 있지만 그 동안 빠른 치트 시트가 있습니다 :</target>
        </trans-unit>
        <trans-unit id="6fa3f4f65b9497a1fe4774a26aaf551f58ec3c5f" translate="yes" xml:space="preserve">
          <source>You don't need to have /usr/ucb/ in your PATH to build perl. If you want /usr/ucb/ in your PATH anyway, make sure that /usr/ucb/ is NOT in your PATH before the directory containing the right C compiler.</source>
          <target state="translated">PATH에 / usr / ucb /가 없어도 perl을 빌드 할 수 있습니다. 어쨌든 PATH에 / usr / ucb /를 원하면 올바른 C 컴파일러를 포함하는 디렉토리 전에 / usr / ucb /가 PATH에 있지 않은지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="fb446a8ceff857b0d30326b022d90618c379b51d" translate="yes" xml:space="preserve">
          <source>You don't need to specify wildcards if you only want to test within specific subdirectories. The following example will only run tests in</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e40dd09143f7def3dc81d2ff9344d2600d1d1ae7" translate="yes" xml:space="preserve">
          <source>You don't really have to count them yourself, though, since Perl already does that with the &lt;code&gt;$.&lt;/code&gt; variable, which is the current line number from the last filehandle read:</source>
          <target state="translated">그러나 Perl은 이미 &lt;code&gt;$.&lt;/code&gt; 그렇게하기 때문에 실제로 계산할 필요는 없습니다 . variable, 마지막으로 읽은 파일 핸들의 현재 줄 번호입니다.</target>
        </trans-unit>
        <trans-unit id="b24e0508e2da733e0f794e663fee88bb39a1e25a" translate="yes" xml:space="preserve">
          <source>You don't skip tests which are failing because there's a bug in your program, or for which you don't yet have code written. For that you use TODO. Read on.</source>
          <target state="translated">프로그램에 버그가 있거나 아직 코드를 작성하지 않았기 때문에 실패한 테스트는 건너 뛰지 않습니다. 이를 위해 TODO를 사용합니다. 읽어.</target>
        </trans-unit>
        <trans-unit id="eebc556ad68a7f00f0136b389c1fbe429ec9a58f" translate="yes" xml:space="preserve">
          <source>You first enter in bisect mode with:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4fdc25fa644377770199aae18193b3eaaa7f502c" translate="yes" xml:space="preserve">
          <source>You forgot a '=back' before '=head</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="93562b7ff5c979fa6f4e89c93b44f448f3599aca" translate="yes" xml:space="preserve">
          <source>You forgot a '=back' before '=head3'</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="710a0707d7d6991623d26d4226d9c4d860f3f7d5" translate="yes" xml:space="preserve">
          <source>You forgot to check &lt;code&gt;$?&lt;/code&gt; to see whether the program even ran correctly. Even if you wrote</source>
          <target state="translated">&lt;code&gt;$?&lt;/code&gt; 를 확인하는 것을 잊었 습니까? 프로그램이 제대로 실행되는지 확인하십시오. 당신이 쓴 경우에도</target>
        </trans-unit>
        <trans-unit id="fc90d9f18467dae7f984c44b04f6fed62e49d3b4" translate="yes" xml:space="preserve">
          <source>You get two references to the same array. If you modify &lt;code&gt;$aref1-&amp;gt;[23]&lt;/code&gt; and then look at &lt;code&gt;$aref2-&amp;gt;[23]&lt;/code&gt; you'll see the change.</source>
          <target state="translated">동일한 배열에 대한 두 개의 참조가 있습니다. 당신이 수정 한 경우 &lt;code&gt;$aref1-&amp;gt;[23]&lt;/code&gt; 다음에 보면 &lt;code&gt;$aref2-&amp;gt;[23]&lt;/code&gt; 당신은 변화를 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bc28177c520a27689ee52401d7752fede6fec23d" translate="yes" xml:space="preserve">
          <source>You have '=item x' instead of the expected '=item</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d8e5e5638bed24bad2d4ab312bfe1360cb8707ce" translate="yes" xml:space="preserve">
          <source>You have a data file that expresses greetings in different languages. Its format is &quot;[language tag]=[how to say 'Hello']&quot;, like:</source>
          <target state="translated">인사말을 다른 언어로 표현하는 데이터 파일이 있습니다. 형식은 &quot;[language tag] = [ 'Hello']하는 방법&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="afbb6b8d64f8b4b3f378ab57026bdb8753122fdc" translate="yes" xml:space="preserve">
          <source>You have a piece of data on which many different operations are applied.</source>
          <target state="translated">여러 가지 다른 작업이 적용되는 데이터가 있습니다.</target>
        </trans-unit>
        <trans-unit id="63d97bb84f94237f7e4b056d5ae5d88b12cd254c" translate="yes" xml:space="preserve">
          <source>You have a very old pdksh. See &lt;a href=&quot;#Prerequisites&quot;&gt;&quot;Prerequisites&quot;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8eed8b91591afe605349a4edd81010c1b4133d5" translate="yes" xml:space="preserve">
          <source>You have a very old pdksh. See &lt;a href=&quot;#Prerequisites&quot;&gt;Prerequisites&lt;/a&gt;.</source>
          <target state="translated">아주 오래된 pdksh가 있습니다. &lt;a href=&quot;#Prerequisites&quot;&gt;전제 조건을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0763fc81d3cd7a4189100a79a22596558a167896" translate="yes" xml:space="preserve">
          <source>You have an older version of</source>
          <target state="translated">이전 버전이 있습니다</target>
        </trans-unit>
        <trans-unit id="e430c6e7f2999710866cf3f6291d3dd58341a4a4" translate="yes" xml:space="preserve">
          <source>You have been warned already in &lt;a href=&quot;#Selecting-What-to-Export&quot;&gt;&quot;Selecting What to Export&quot;&lt;/a&gt; to not export:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72b9024251b30a14c45724d6bbd90abab3f232a3" translate="yes" xml:space="preserve">
          <source>You have been warned already in &lt;a href=&quot;#Selecting-What-to-Export&quot;&gt;Selecting What to Export&lt;/a&gt; to not export:</source>
          <target state="translated">&lt;a href=&quot;#Selecting-What-to-Export&quot;&gt;내보낼 항목&lt;/a&gt; 을 선택 하여 내 보내지 않음 에 대해 이미 경고했습니다 .</target>
        </trans-unit>
        <trans-unit id="43dfe62727996603d47468da8d91c958abc24b74" translate="yes" xml:space="preserve">
          <source>You have created an XSUB interface to an application's C API.</source>
          <target state="translated">애플리케이션의 C API에 대한 XSUB 인터페이스를 작성했습니다.</target>
        </trans-unit>
        <trans-unit id="c236e9b8bd9523c45d8e12fd36ee9331405ecbff" translate="yes" xml:space="preserve">
          <source>You have defined an END handler for an attribute that is being applied to a lexical variable. Since the variable may not be available during END this won't happen.</source>
          <target state="translated">어휘 변수에 적용되는 속성에 대한 END 핸들러를 정의했습니다. END 동안 변수를 사용할 수 없기 때문에 이런 일이 발생하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="717f15e5bfd4a04630296d7e18d1dc4a8563c670" translate="yes" xml:space="preserve">
          <source>You have set the &lt;code&gt;WindowBits&lt;/code&gt; parameter to &lt;code&gt;-MAX_WBITS&lt;/code&gt; in the constructor for this object, i.e. you are uncompressing a raw deflated data stream (RFC 1951).</source>
          <target state="translated">이 객체의 생성자에서 &lt;code&gt;WindowBits&lt;/code&gt; 매개 변수를 &lt;code&gt;-MAX_WBITS&lt;/code&gt; 로 설정했습니다 . 즉, 원시 수축 데이터 스트림을 압축 해제하고 있습니다 (RFC 1951).</target>
        </trans-unit>
        <trans-unit id="522d08a79de6280adc20232939d047a4cc891b57" translate="yes" xml:space="preserve">
          <source>You have the choice to set the config variable &lt;code&gt;scan_cache&lt;/code&gt; to &lt;code&gt;never&lt;/code&gt; . Then you must clean it up yourself. The other possible values, &lt;code&gt;atstart&lt;/code&gt; and &lt;code&gt;atexit&lt;/code&gt; clean up the build directory when you start (or more precisely, after the first extraction into the build directory) or exit the CPAN shell, respectively. If you never start up the CPAN shell, you probably also have to clean up the build directory yourself.</source>
          <target state="translated">구성 변수 &lt;code&gt;scan_cache&lt;/code&gt; 를 &lt;code&gt;never&lt;/code&gt; 로 설정할 수 있습니다 . 그런 다음 직접 청소해야합니다. 다른 시작 가능한 값인 &lt;code&gt;atstart&lt;/code&gt; 및 &lt;code&gt;atexit&lt;/code&gt; 은 각각 빌드 디렉토리를 처음 추출한 후 또는보다 정확하게 CPAN 쉘을 종료 할 때 빌드 디렉토리를 정리합니다. CPAN 쉘을 시작하지 않으면 빌드 디렉토리를 직접 정리해야합니다.</target>
        </trans-unit>
        <trans-unit id="d43912cc9e84a61faff2f02f26a4d03134058ada" translate="yes" xml:space="preserve">
          <source>You have the same problem with &lt;a href=&quot;Time::Local&quot;&gt;Time::Local&lt;/a&gt;, which will give the wrong answer for those same special cases:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2deb6a8cd98a82f2aaaef2ec6bec5741ef832ea" translate="yes" xml:space="preserve">
          <source>You have the same problem with &lt;a href=&quot;time/local&quot;&gt;Time::Local&lt;/a&gt;, which will give the wrong answer for those same special cases:</source>
          <target state="translated">&lt;a href=&quot;time/local&quot;&gt;Time :: Local&lt;/a&gt; 과 동일한 문제가 발생하여 동일한 특수한 경우에 대해 잘못된 답변을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="d93e439cde6acc82e52bf85fad48553b810a706b" translate="yes" xml:space="preserve">
          <source>You have to be prepared to &quot;reap&quot; the child process when it finishes.</source>
          <target state="translated">하위 프로세스가 완료되면 &quot;수거&quot;할 준비가되어 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="7bc9963f1adfa43aa2eba732c53b836ac12c4562" translate="yes" xml:space="preserve">
          <source>You have to decide whether you want to use string or numeric comparisons.</source>
          <target state="translated">문자열 또는 숫자 비교를 사용할지 결정해야합니다.</target>
        </trans-unit>
        <trans-unit id="4cf51b08c425e59c5631231a092f6037897d07c7" translate="yes" xml:space="preserve">
          <source>You have to decide whether your array has numeric or string indices.</source>
          <target state="translated">배열에 숫자 또는 문자열 인덱스가 있는지 여부를 결정해야합니다.</target>
        </trans-unit>
        <trans-unit id="a73461591d1d0c0412d08a5e1e1cc7e69b28c7fe" translate="yes" xml:space="preserve">
          <source>You have to have Pod::Simple::RTF installed (from the Pod::Simple dist), or this module won't work.</source>
          <target state="translated">Pod :: Simple :: RTF가 Pod :: Simple dist에서 설치되어 있어야합니다. 그렇지 않으면이 모듈이 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="58b51a173ef28ef95718c75aa4bacf0fb0ef7258" translate="yes" xml:space="preserve">
          <source>You have to have installed Pod::Simple::XMLOutStream (from the Pod::Simple dist), or this class won't work.</source>
          <target state="translated">Pod :: Simple :: XMLOutStream (Pod :: Simple dist에서)을 설치해야합니다. 그렇지 않으면이 클래스가 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f9f9dbede53dcc87c8a6c2c35d9ae17a92119e03" translate="yes" xml:space="preserve">
          <source>You have to have installed Tk::Pod first, or this class won't load.</source>
          <target state="translated">Tk :: Pod를 먼저 설치해야합니다. 그렇지 않으면이 클래스가로드되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="95bfc19d25cce1034c6f167e8df494025bec3f1c" translate="yes" xml:space="preserve">
          <source>You have to have two hex digits after a braceless &lt;code&gt;\x&lt;/code&gt; (use a leading zero to make two). These restrictions are to lower the incidence of typos causing the class to not match what you thought it would.</source>
          <target state="translated">괄호가없는 &lt;code&gt;\x&lt;/code&gt; 뒤에 16 진수 숫자가 두 개 있어야합니다 ( 앞에 0을 사용하여 두 개 만들기). 이러한 제한은 오타 발생률을 낮추어 클래스가 생각했던 것과 일치하지 않도록합니다.</target>
        </trans-unit>
        <trans-unit id="c268b51167b66309dd9d49ba2a2c249b1b287fa0" translate="yes" xml:space="preserve">
          <source>You have to keep track of N yourself. For example, let's say you want to change the fifth occurrence of &lt;code&gt;&quot;whoever&quot;&lt;/code&gt; or &lt;code&gt;&quot;whomever&quot;&lt;/code&gt; into &lt;code&gt;&quot;whosoever&quot;&lt;/code&gt; or &lt;code&gt;&quot;whomsoever&quot;&lt;/code&gt; , case insensitively. These all assume that $_ contains the string to be altered.</source>
          <target state="translated">N 자신을 추적해야합니다. 예를 들어,하자 당신의 다섯 번째 발생 변경하고 싶은 말은 &lt;code&gt;&quot;whoever&quot;&lt;/code&gt; 또는 &lt;code&gt;&quot;whomever&quot;&lt;/code&gt; 로 &lt;code&gt;&quot;whosoever&quot;&lt;/code&gt; 또는 &lt;code&gt;&quot;whomsoever&quot;&lt;/code&gt; 소문자를 구별, 케이스. 이들은 모두 $ _에 변경할 문자열이 포함되어 있다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="8f497ff3dd0b8c02bb7f0cfe45277ba739785588" translate="yes" xml:space="preserve">
          <source>You have to keep track of N yourself. For example, let's say you want to change the fifth occurrence of &lt;code&gt;&quot;whoever&quot;&lt;/code&gt; or &lt;code&gt;&quot;whomever&quot;&lt;/code&gt; into &lt;code&gt;&quot;whosoever&quot;&lt;/code&gt; or &lt;code&gt;&quot;whomsoever&quot;&lt;/code&gt;, case insensitively. These all assume that $_ contains the string to be altered.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac02203046e578344330c6d8542449742080d451" translate="yes" xml:space="preserve">
          <source>You have to run this program by hand; it's not run as part of the Perl installation.</source>
          <target state="translated">이 프로그램을 직접 실행해야합니다. Perl 설치의 일부로 실행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="64c3798560849a7dba79bf1106dd1dedfd652114" translate="yes" xml:space="preserve">
          <source>You have tried to use one of the &lt;code&gt;-rwxRWX&lt;/code&gt; filetests with &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt;
filetest 'access'&lt;/code&gt; in effect. &lt;code&gt;File::stat&lt;/code&gt; will ignore the pragma, and just use the information in the &lt;code&gt;mode&lt;/code&gt; member as usual.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; filetest 'access'&lt;/code&gt; 를 &lt;a href=&quot;../functions/use&quot;&gt;사용&lt;/a&gt; 하여 &lt;code&gt;-rwxRWX&lt;/code&gt; 파일 테스트 중 하나를 사용하려고했습니다 . &lt;code&gt;File::stat&lt;/code&gt; 는 pragma를 무시하고 평소대로 &lt;code&gt;mode&lt;/code&gt; 멤버 의 정보를 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="619430200c4656ad3bc2866c9b899c95858a7c7b" translate="yes" xml:space="preserve">
          <source>You have tried to use one of the &lt;code&gt;-rwxRWX&lt;/code&gt; filetests with &lt;code&gt;use filetest 'access'&lt;/code&gt; in effect. &lt;code&gt;File::stat&lt;/code&gt; will ignore the pragma, and just use the information in the &lt;code&gt;mode&lt;/code&gt; member as usual.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f298d6edd85361a4fe69a118c738c5c6d1ac6519" translate="yes" xml:space="preserve">
          <source>You just can't, okay? Instead, put all the specifications together with commas between them in a single &lt;code&gt;ATTR(&lt;i&gt;specification&lt;/i&gt;)&lt;/code&gt;.</source>
          <target state="translated">당신은 할 수 없습니다, 알 겠어요? 대신, 모든 스펙을 쉼표와 함께 하나의 &lt;code&gt;ATTR(&lt;i&gt;specification&lt;/i&gt;)&lt;/code&gt; 넣으십시오 .</target>
        </trans-unit>
        <trans-unit id="d2ae4f730c89fd94f9c70ee5552ee3019cb5e33a" translate="yes" xml:space="preserve">
          <source>You like this port? See &lt;a href=&quot;http://www.broad.ology.org.uk/amiga/&quot;&gt;http://www.broad.ology.org.uk/amiga/&lt;/a&gt; for how you can help.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="afbf451f9422303960f49b456d9bb760406138be" translate="yes" xml:space="preserve">
          <source>You likely need to figure out how this multi-byte character got mixed up with your single-byte locale (or perhaps you thought you had a UTF-8 locale, but Perl disagrees).</source>
          <target state="translated">이 멀티 바이트 문자가 단일 바이트 로케일과 어떻게 혼합되었는지 파악해야합니다 (또는 UTF-8 로케일이 있다고 생각했지만 Perl이 동의하지 않습니다).</target>
        </trans-unit>
        <trans-unit id="b36efc02e455a878d40bce54d0800047ed5ce051" translate="yes" xml:space="preserve">
          <source>You may (and usually should) use the three-argument form of open to specify I/O layers (sometimes referred to as &quot;disciplines&quot;) to apply to the handle that affect how the input and output are processed (see &lt;a href=&quot;../open&quot;&gt;open&lt;/a&gt; and &lt;a href=&quot;../perlio&quot;&gt;PerlIO&lt;/a&gt; for more details). For example:</source>
          <target state="translated">당신은 (일반적으로한다) I / 입력 및 출력이 처리되는 방식에 영향을 핸들에 적용 할 (때로는 &quot;분야&quot;라한다) O 레이어를 지정하기 위해 개방의 3 인자 양식을 사용할 수있다 (참조 &lt;a href=&quot;../open&quot;&gt;개방&lt;/a&gt; 및 &lt;a href=&quot;../perlio&quot;&gt;은 PerlIO&lt;/a&gt; 에 대한 자세한 내용은). 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f4242caecdd2a41134c434e48293066c09a61129" translate="yes" xml:space="preserve">
          <source>You may (and usually should) use the three-argument form of open to specify I/O layers (sometimes referred to as &quot;disciplines&quot;) to apply to the handle that affect how the input and output are processed (see &lt;a href=&quot;open&quot;&gt;open&lt;/a&gt; and &lt;a href=&quot;perlio&quot;&gt;PerlIO&lt;/a&gt; for more details). For example:</source>
          <target state="translated">당신은 (일반적으로한다) I / 입력 및 출력이 처리되는 방식에 영향을 핸들에 적용 할 (때로는 &quot;분야&quot;라한다) O 레이어를 지정하기 위해 개방의 3 인자 양식을 사용할 수있다 (참조 &lt;a href=&quot;open&quot;&gt;개방&lt;/a&gt; 및 &lt;a href=&quot;perlio&quot;&gt;은 PerlIO&lt;/a&gt; 에 대한 자세한 내용은). 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9e56389d96587e792278e4c558eb5807976007cf" translate="yes" xml:space="preserve">
          <source>You may access the repository over the web. This allows you to browse the tree, see recent commits, subscribe to RSS feeds for the changes, search for particular commits and more. You may access it at &lt;a href=&quot;http://perl5.git.perl.org/perl.git&quot;&gt;http://perl5.git.perl.org/perl.git&lt;/a&gt;. A mirror of the repository is found at &lt;a href=&quot;https://github.com/Perl/perl5&quot;&gt;https://github.com/Perl/perl5&lt;/a&gt;.</source>
          <target state="translated">웹을 통해 저장소에 액세스 할 수 있습니다. 이를 통해 트리를 탐색하고 최근 커밋을보고 변경 사항에 대한 RSS 피드를 구독하고 특정 커밋을 검색하는 등의 작업을 수행 할 수 있습니다. &lt;a href=&quot;http://perl5.git.perl.org/perl.git&quot;&gt;http://perl5.git.perl.org/perl.git&lt;/a&gt; 에서 액세스 할 수 있습니다 . 저장소의 미러는 &lt;a href=&quot;https://github.com/Perl/perl5&quot;&gt;https://github.com/Perl/perl5에&lt;/a&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="880fe17e1513224bf25aeb9d0faccae93b9cb553" translate="yes" xml:space="preserve">
          <source>You may access the repository over the web. This allows you to browse the tree, see recent commits, subscribe to repository notifications, search for particular commits and more. You may access it at &lt;a href=&quot;https://github.com/Perl/perl5&quot;&gt;https://github.com/Perl/perl5&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d839e720ae2e7bff2fab5b0520b346cd44ca6b4d" translate="yes" xml:space="preserve">
          <source>You may add other methods to the UNIVERSAL class via Perl or XS code. You do not need to &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; UNIVERSAL&lt;/code&gt; to make these methods available to your program (and you should not do so).</source>
          <target state="translated">Perl 또는 XS 코드를 통해 UNIVERSAL 클래스에 다른 메소드를 추가 할 수 있습니다. 프로그램에서 이러한 메소드를 사용 가능하게 하기 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; UNIVERSAL&lt;/code&gt; 을 사용할 필요 는 없습니다 (그렇지 않아야합니다).</target>
        </trans-unit>
        <trans-unit id="224f5909daef0b34d22040e764c9911e7daddf8b" translate="yes" xml:space="preserve">
          <source>You may add other methods to the UNIVERSAL class via Perl or XS code. You do not need to &lt;code&gt;use UNIVERSAL&lt;/code&gt; to make these methods available to your program (and you should not do so).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="100a6f059c39fc4530e46957891e388f20cf1052" translate="yes" xml:space="preserve">
          <source>You may also choose to assign the strings &lt;code&gt;&quot;IGNORE&quot;&lt;/code&gt; or &lt;code&gt;&quot;DEFAULT&quot;&lt;/code&gt; as the handler, in which case Perl will try to discard the signal or do the default thing.</source>
          <target state="translated">문자열 &lt;code&gt;&quot;IGNORE&quot;&lt;/code&gt; 또는 &lt;code&gt;&quot;DEFAULT&quot;&lt;/code&gt; 를 처리기 로 할당하도록 선택할 수도 있습니다 .이 경우 Perl은 신호를 삭제하거나 기본 작업을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="daa282ce292ff54483ba2ce846a92dc96f9168dc" translate="yes" xml:space="preserve">
          <source>You may also examine the &quot;safe&quot; flag on the output action object which is filled in when given as the third parameter to &lt;code&gt;POSIX::sigaction()&lt;/code&gt; :</source>
          <target state="translated">&lt;code&gt;POSIX::sigaction()&lt;/code&gt; 세 번째 매개 변수로 제공 될 때 채워지는 출력 조치 오브젝트에서 &quot;safe&quot;플래그를 검사 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="423918885baf5f3a8b58d2fd022436e7d14efbab" translate="yes" xml:space="preserve">
          <source>You may also examine the &quot;safe&quot; flag on the output action object which is filled in when given as the third parameter to &lt;code&gt;POSIX::sigaction()&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6858c6ae6b5f95e06bfedeb3afc148cdf748f135" translate="yes" xml:space="preserve">
          <source>You may also have found out by now why 7bit ISO-2022 cannot comprise a CCS. If you look at a byte sequence \x21\x21, you can't tell if it is two !'s or IDEOGRAPHIC SPACE. EUC maps the latter to \xA1\xA1 so you have no trouble differentiating between &quot;!!&quot;. and &quot; &quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01c5b9373dd2d19d42f55fdae95d97ea20dd07a1" translate="yes" xml:space="preserve">
          <source>You may also import all the structure fields directly into your namespace as regular variables using the :FIELDS import tag. (Note that this still overrides your core functions.) Access these fields as variables named with a preceding &lt;code&gt;gr_&lt;/code&gt; . Thus, &lt;code&gt;$group_obj-&amp;gt;gid()&lt;/code&gt; corresponds to $gr_gid if you import the fields. Array references are available as regular array variables, so &lt;code&gt;@{ $group_obj-&amp;gt;members() }&lt;/code&gt; would be simply @gr_members.</source>
          <target state="translated">: FIELDS import 태그를 사용하여 모든 구조 필드를 일반 변수로 네임 스페이스에 직접 가져올 수도 있습니다. (이것은 여전히 ​​핵심 기능을 무시합니다.)이 필드는 선행 &lt;code&gt;gr_&lt;/code&gt; 로 이름이 지정된 변수로 액세스하십시오 . 따라서 필드를 가져 오는 경우 &lt;code&gt;$group_obj-&amp;gt;gid()&lt;/code&gt; 는 $ gr_gid에 해당합니다. 배열 참조는 일반 배열 변수로 사용할 수 있으므로 &lt;code&gt;@{ $group_obj-&amp;gt;members() }&lt;/code&gt; 는 단순히 @gr_members입니다.</target>
        </trans-unit>
        <trans-unit id="caae676e8fb92488f8f5b8dcd2e680cb050048ef" translate="yes" xml:space="preserve">
          <source>You may also import all the structure fields directly into your namespace as regular variables using the :FIELDS import tag. (Note that this still overrides your core functions.) Access these fields as variables named with a preceding &lt;code&gt;gr_&lt;/code&gt;. Thus, &lt;code&gt;$group_obj-&amp;gt;gid()&lt;/code&gt; corresponds to $gr_gid if you import the fields. Array references are available as regular array variables, so &lt;code&gt;@{ $group_obj-&amp;gt;members() }&lt;/code&gt; would be simply @gr_members.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa4935199f235ba2f0cd0a1d49e3ac1a3bbd011f" translate="yes" xml:space="preserve">
          <source>You may also import all the structure fields directly into your namespace as regular variables using the :FIELDS import tag. (Note that this still overrides your core functions.) Access these fields as variables named with a preceding &lt;code&gt;h_&lt;/code&gt; . Thus, &lt;code&gt;$host_obj-&amp;gt;name()&lt;/code&gt; corresponds to $h_name if you import the fields. Array references are available as regular array variables, so for example &lt;code&gt;@{ $host_obj-&amp;gt;aliases()
}&lt;/code&gt; would be simply @h_aliases.</source>
          <target state="translated">: FIELDS import 태그를 사용하여 모든 구조 필드를 일반 변수로 네임 스페이스에 직접 가져올 수도 있습니다. (여전히 핵심 기능보다 우선합니다.)이 필드는 앞에 &lt;code&gt;h_&lt;/code&gt; 로 이름이 지정된 변수로 액세스하십시오 . 따라서 필드를 가져 오는 경우 &lt;code&gt;$host_obj-&amp;gt;name()&lt;/code&gt; 은 $ h_name에 해당합니다. 배열 참조는 일반 배열 변수로 사용할 수 있으므로 예를 들어 &lt;code&gt;@{ $host_obj-&amp;gt;aliases() }&lt;/code&gt; 는 단순히 @h_aliases입니다.</target>
        </trans-unit>
        <trans-unit id="da401673f6af44a50993b3561d0579f99e07eee9" translate="yes" xml:space="preserve">
          <source>You may also import all the structure fields directly into your namespace as regular variables using the :FIELDS import tag. (Note that this still overrides your core functions.) Access these fields as variables named with a preceding &lt;code&gt;h_&lt;/code&gt;. Thus, &lt;code&gt;$host_obj-&amp;gt;name()&lt;/code&gt; corresponds to $h_name if you import the fields. Array references are available as regular array variables, so for example &lt;code&gt;@{ $host_obj-&amp;gt;aliases() }&lt;/code&gt; would be simply @h_aliases.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60ec160f76fcfc38cc73d96c90a7ce874d6384c9" translate="yes" xml:space="preserve">
          <source>You may also import all the structure fields directly into your namespace as regular variables using the :FIELDS import tag. (Note that this still overrides your core functions.) Access these fields as variables named with a preceding &lt;code&gt;n_&lt;/code&gt; . Thus, &lt;code&gt;$net_obj-&amp;gt;name()&lt;/code&gt; corresponds to $n_name if you import the fields. Array references are available as regular array variables, so for example &lt;code&gt;@{ $net_obj-&amp;gt;aliases()
}&lt;/code&gt; would be simply @n_aliases.</source>
          <target state="translated">: FIELDS import 태그를 사용하여 모든 구조 필드를 일반 변수로 네임 스페이스에 직접 가져올 수도 있습니다. (여전히 핵심 기능보다 우선합니다.)이 필드는 앞에 &lt;code&gt;n_&lt;/code&gt; 으로 이름이 지정된 변수로 액세스하십시오 . 따라서 필드를 가져 오면 &lt;code&gt;$net_obj-&amp;gt;name()&lt;/code&gt; 은 $ n_name에 해당합니다. 배열 참조는 일반 배열 변수로 사용할 수 있으므로 예를 들어 &lt;code&gt;@{ $net_obj-&amp;gt;aliases() }&lt;/code&gt; 는 단순히 @n_aliases입니다.</target>
        </trans-unit>
        <trans-unit id="19db00abebd3ac2639c39bd38da2d23c013b0474" translate="yes" xml:space="preserve">
          <source>You may also import all the structure fields directly into your namespace as regular variables using the :FIELDS import tag. (Note that this still overrides your core functions.) Access these fields as variables named with a preceding &lt;code&gt;n_&lt;/code&gt;. Thus, &lt;code&gt;$net_obj-&amp;gt;name()&lt;/code&gt; corresponds to $n_name if you import the fields. Array references are available as regular array variables, so for example &lt;code&gt;@{ $net_obj-&amp;gt;aliases() }&lt;/code&gt; would be simply @n_aliases.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd8189e5c613aac0e23d3c0670ed3ce2f5ae13db" translate="yes" xml:space="preserve">
          <source>You may also import all the structure fields directly into your namespace as regular variables using the :FIELDS import tag. (Note that this still overrides your core functions.) Access these fields as variables named with a preceding &lt;code&gt;p_&lt;/code&gt; . Thus, &lt;code&gt;$proto_obj-&amp;gt;name()&lt;/code&gt; corresponds to $p_name if you import the fields. Array references are available as regular array variables, so for example &lt;code&gt;@{ $proto_obj-&amp;gt;aliases()
}&lt;/code&gt; would be simply @p_aliases.</source>
          <target state="translated">: FIELDS import 태그를 사용하여 모든 구조 필드를 일반 변수로 네임 스페이스에 직접 가져올 수도 있습니다. (이것은 여전히 ​​핵심 기능을 재정의합니다.)이 필드는 앞에 &lt;code&gt;p_&lt;/code&gt; 로 이름이 지정된 변수로 액세스하십시오 . 따라서 필드를 가져올 경우 &lt;code&gt;$proto_obj-&amp;gt;name()&lt;/code&gt; 은 $ p_name에 해당합니다. 배열 참조는 일반 배열 변수로 사용할 수 있으므로 예를 들어 &lt;code&gt;@{ $proto_obj-&amp;gt;aliases() }&lt;/code&gt; 는 단순히 @p_aliases입니다.</target>
        </trans-unit>
        <trans-unit id="59c78f0961227d9eef360c4cd0d66deb00f372b4" translate="yes" xml:space="preserve">
          <source>You may also import all the structure fields directly into your namespace as regular variables using the :FIELDS import tag. (Note that this still overrides your core functions.) Access these fields as variables named with a preceding &lt;code&gt;p_&lt;/code&gt;. Thus, &lt;code&gt;$proto_obj-&amp;gt;name()&lt;/code&gt; corresponds to $p_name if you import the fields. Array references are available as regular array variables, so for example &lt;code&gt;@{ $proto_obj-&amp;gt;aliases() }&lt;/code&gt; would be simply @p_aliases.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25ca76eb17a2cf86a0c57fdc15c696e88b6cf4c9" translate="yes" xml:space="preserve">
          <source>You may also import all the structure fields directly into your namespace as regular variables using the :FIELDS import tag. (Note that this still overrides your core functions.) Access these fields as variables named with a preceding &lt;code&gt;pw_&lt;/code&gt; in front their method names. Thus, &lt;code&gt;$passwd_obj-&amp;gt;shell&lt;/code&gt; corresponds to $pw_shell if you import the fields.</source>
          <target state="translated">: FIELDS import 태그를 사용하여 모든 구조 필드를 일반 변수로 네임 스페이스에 직접 가져올 수도 있습니다. (이것은 여전히 ​​핵심 기능을 무시합니다.) 메소드 이름 앞에 앞에 &lt;code&gt;pw_&lt;/code&gt; 로 이름이 지정된 변수로이 필드에 액세스하십시오 . 따라서 필드를 가져 오는 경우 &lt;code&gt;$passwd_obj-&amp;gt;shell&lt;/code&gt; 은 $ pw_shell에 해당합니다.</target>
        </trans-unit>
        <trans-unit id="274d859e81c068db4c48efa8f50c77493ca5cdbd" translate="yes" xml:space="preserve">
          <source>You may also import all the structure fields directly into your namespace as regular variables using the :FIELDS import tag. (Note that this still overrides your core functions.) Access these fields as variables named with a preceding &lt;code&gt;s_&lt;/code&gt; . Thus, &lt;code&gt;$serv_obj-&amp;gt;name()&lt;/code&gt; corresponds to $s_name if you import the fields. Array references are available as regular array variables, so for example &lt;code&gt;@{ $serv_obj-&amp;gt;aliases()}&lt;/code&gt; would be simply @s_aliases.</source>
          <target state="translated">: FIELDS import 태그를 사용하여 모든 구조 필드를 일반 변수로 네임 스페이스에 직접 가져올 수도 있습니다. (여전히 핵심 기능보다 우선합니다.)이 필드는 앞에 &lt;code&gt;s_&lt;/code&gt; 로 이름이 지정된 변수로 액세스하십시오 . 따라서 필드를 가져 오는 경우 &lt;code&gt;$serv_obj-&amp;gt;name()&lt;/code&gt; 은 $ s_name에 해당합니다. 배열 참조는 일반 배열 변수로 사용할 수 있으므로 예를 들어 &lt;code&gt;@{ $serv_obj-&amp;gt;aliases()}&lt;/code&gt; 는 단순히 @s_aliases입니다.</target>
        </trans-unit>
        <trans-unit id="18fe09aa2549872796afb74f39ab43e75ad25ff1" translate="yes" xml:space="preserve">
          <source>You may also import all the structure fields directly into your namespace as regular variables using the :FIELDS import tag. (Note that this still overrides your core functions.) Access these fields as variables named with a preceding &lt;code&gt;s_&lt;/code&gt;. Thus, &lt;code&gt;$serv_obj-&amp;gt;name()&lt;/code&gt; corresponds to $s_name if you import the fields. Array references are available as regular array variables, so for example &lt;code&gt;@{ $serv_obj-&amp;gt;aliases()}&lt;/code&gt; would be simply @s_aliases.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="447198c5b98b7b54155b70c415358589d509c62e" translate="yes" xml:space="preserve">
          <source>You may also import all the structure fields directly into your namespace as regular variables using the :FIELDS import tag. (Note that this still overrides your core functions.) Access these fields as variables named with a preceding &lt;code&gt;tm_&lt;/code&gt; in front their method names. Thus, &lt;code&gt;$tm_obj-&amp;gt;mday()&lt;/code&gt; corresponds to $tm_mday if you import the fields.</source>
          <target state="translated">: FIELDS import 태그를 사용하여 모든 구조 필드를 일반 변수로 네임 스페이스에 직접 가져올 수도 있습니다. (여전히 핵심 기능을 재정의합니다.) 메소드 이름 앞에 &lt;code&gt;tm_&lt;/code&gt; 로 이름이 지정된 변수로이 필드에 액세스하십시오 . 따라서 필드를 가져 오는 경우 &lt;code&gt;$tm_obj-&amp;gt;mday()&lt;/code&gt; 는 $ tm_mday에 해당합니다.</target>
        </trans-unit>
        <trans-unit id="5c856054dbb9356054cca7ccfef163a998ceb55f" translate="yes" xml:space="preserve">
          <source>You may also import all the structure fields directly into your namespace as regular variables using the :FIELDS import tag. (Note that this still overrides your stat() and lstat() functions.) Access these fields as variables named with a preceding &lt;code&gt;st_&lt;/code&gt; in front their method names. Thus, &lt;code&gt;$stat_obj-&amp;gt;dev()&lt;/code&gt; corresponds to $st_dev if you import the fields.</source>
          <target state="translated">: FIELDS import 태그를 사용하여 모든 구조 필드를 일반 변수로 네임 스페이스에 직접 가져올 수도 있습니다. (여전히 stat () 및 lstat () 함수보다 우선합니다.) 메소드 이름 앞에 앞에 &lt;code&gt;st_&lt;/code&gt; 로 이름이 지정된 변수로이 필드에 액세스하십시오 . 따라서 필드를 가져 오는 경우 &lt;code&gt;$stat_obj-&amp;gt;dev()&lt;/code&gt; 는 $ st_dev에 해당합니다.</target>
        </trans-unit>
        <trans-unit id="a6b6b26fcc9879eca82e69c4a67570540fca4ae9" translate="yes" xml:space="preserve">
          <source>You may also need to apply the patches supplied with the binary distribution of perl. It also makes sense to look on the perl5-porters mailing list for the latest OS/2-related patches (see &lt;a href=&quot;http://www.xray.mpe.mpg.de/mailing-lists/perl5-porters/&quot;&gt;http://www.xray.mpe.mpg.de/mailing-lists/perl5-porters/&lt;/a&gt;). Such patches usually contain strings &lt;code&gt;/os2/&lt;/code&gt; and &lt;code&gt;patch&lt;/code&gt; , so it makes sense looking for these strings.</source>
          <target state="translated">바이너리 배포판 perl과 함께 제공된 패치를 적용해야 할 수도 있습니다. 최신 OS / 2 관련 패치 ( &lt;a href=&quot;http://www.xray.mpe.mpg.de/mailing-lists/perl5-porters/&quot;&gt;http://www.xray.mpe.mpg.de/mailing-lists/perl5-porters/ 참조&lt;/a&gt; ) 는 perl5-porters 메일 링리스트에서 확인하는 것이 좋습니다. 이러한 패치에는 일반적으로 &lt;code&gt;/os2/&lt;/code&gt; 및 &lt;code&gt;patch&lt;/code&gt; 문자열이 포함 되므로 이러한 문자열을 찾는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="8e4529b370379079adb0c3991b105507c8bdaf29" translate="yes" xml:space="preserve">
          <source>You may also need to apply the patches supplied with the binary distribution of perl. It also makes sense to look on the perl5-porters mailing list for the latest OS/2-related patches (see &lt;a href=&quot;http://www.xray.mpe.mpg.de/mailing-lists/perl5-porters/&quot;&gt;http://www.xray.mpe.mpg.de/mailing-lists/perl5-porters/&lt;/a&gt;). Such patches usually contain strings &lt;code&gt;/os2/&lt;/code&gt; and &lt;code&gt;patch&lt;/code&gt;, so it makes sense looking for these strings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6aa8495c9efa1eb6aea78e6cd751529d33d7b29e" translate="yes" xml:space="preserve">
          <source>You may also need to comment out the &lt;code&gt;DELAYLOAD = ...&lt;/code&gt; line in the Makefile if you're using VC++ 6.0 without the latest service pack and the linker reports an internal error.</source>
          <target state="translated">최신 서비스 팩없이 VC ++ 6.0을 사용하고 링커에서 내부 오류를보고하는 경우 Makefile에서 &lt;code&gt;DELAYLOAD = ...&lt;/code&gt; 행 을 주석 처리해야 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="069c796ed1b4791a2efc8028daa2cfe58429ceb7" translate="yes" xml:space="preserve">
          <source>You may also refer to a distribution in the form A/AU/AUTHORID/TARBALL.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c64c3fbfbcaace5918da128791239c43cdf19d2" translate="yes" xml:space="preserve">
          <source>You may also use &lt;code&gt;&lt;a href=&quot;defined&quot;&gt;defined(&amp;amp;func)&lt;/a&gt;&lt;/code&gt; to check whether subroutine &lt;code&gt;&amp;amp;func&lt;/code&gt; has ever been defined. The return value is unaffected by any forward declarations of &lt;code&gt;&amp;amp;func&lt;/code&gt; . A subroutine that is not defined may still be callable: its package may have an &lt;code&gt;AUTOLOAD&lt;/code&gt; method that makes it spring into existence the first time that it is called; see &lt;a href=&quot;../perlsub&quot;&gt;perlsub&lt;/a&gt;.</source>
          <target state="translated">또한 &lt;code&gt;&lt;a href=&quot;defined&quot;&gt;defined(&amp;amp;func)&lt;/a&gt;&lt;/code&gt; 을 사용하여 서브 루틴 &lt;code&gt;&amp;amp;func&lt;/code&gt; 이 정의 되었는지 여부를 확인할 수 있습니다. 리턴 값은 &lt;code&gt;&amp;amp;func&lt;/code&gt; 의 모든 선언에 영향을받지 않습니다 . 정의되지 않은 서브 루틴은 여전히 ​​호출 가능합니다. 패키지에는 &lt;code&gt;AUTOLOAD&lt;/code&gt; 메소드가 있을 수 있습니다 . &lt;a href=&quot;../perlsub&quot;&gt;perlsub를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="172f346295165efa4fd86444269a98fd3b778c01" translate="yes" xml:space="preserve">
          <source>You may also use &lt;code&gt;&lt;a href=&quot;functions/defined&quot;&gt;defined(&amp;amp;func)&lt;/a&gt;&lt;/code&gt; to check whether subroutine &lt;code&gt;&amp;amp;func&lt;/code&gt; has ever been defined. The return value is unaffected by any forward declarations of &lt;code&gt;&amp;amp;func&lt;/code&gt; . A subroutine that is not defined may still be callable: its package may have an &lt;code&gt;AUTOLOAD&lt;/code&gt; method that makes it spring into existence the first time that it is called; see &lt;a href=&quot;perlsub&quot;&gt;perlsub&lt;/a&gt;.</source>
          <target state="translated">또한 &lt;code&gt;&lt;a href=&quot;functions/defined&quot;&gt;defined(&amp;amp;func)&lt;/a&gt;&lt;/code&gt; 을 사용하여 서브 루틴 &lt;code&gt;&amp;amp;func&lt;/code&gt; 이 정의 되었는지 여부를 확인할 수 있습니다. 리턴 값은 &lt;code&gt;&amp;amp;func&lt;/code&gt; 의 모든 선언에 영향을받지 않습니다 . 정의되지 않은 서브 루틴은 여전히 ​​호출 가능합니다. 패키지에는 &lt;code&gt;AUTOLOAD&lt;/code&gt; 메소드가 있을 수 있습니다 . &lt;a href=&quot;perlsub&quot;&gt;perlsub를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="2b8d15f86aa40a5b71c22fd3f0132310f48b5d79" translate="yes" xml:space="preserve">
          <source>You may also use &lt;code&gt;defined(&amp;amp;func)&lt;/code&gt; to check whether subroutine &lt;code&gt;func&lt;/code&gt; has ever been defined. The return value is unaffected by any forward declarations of &lt;code&gt;func&lt;/code&gt;. A subroutine that is not defined may still be callable: its package may have an &lt;code&gt;AUTOLOAD&lt;/code&gt; method that makes it spring into existence the first time that it is called; see &lt;a href=&quot;perlsub&quot;&gt;perlsub&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b5f7479dd4b17df91be39e0264b553fbc922288" translate="yes" xml:space="preserve">
          <source>You may also use backticks to invoke a DCL subprocess, whose output is used as the return value of the expression. The string between the backticks is handled as if it were the argument to the &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; operator (see below). In this case, Perl will wait for the subprocess to complete before continuing.</source>
          <target state="translated">백틱을 사용하여 DCL 서브 프로세스를 호출 할 수 있습니다. DCL 서브 프로세스는 출력이 표현식의 리턴 값으로 사용됩니다. 백틱 사이의 문자열은 마치 &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; 연산자에 대한 인수 인 것처럼 처리됩니다 (아래 참조). 이 경우 Perl은 계속하기 전에 서브 프로세스가 완료 될 때까지 기다립니다.</target>
        </trans-unit>
        <trans-unit id="4106bc4cad7712056a35b119b25c2a2d70a97ddc" translate="yes" xml:space="preserve">
          <source>You may also use backticks to invoke a DCL subprocess, whose output is used as the return value of the expression. The string between the backticks is handled as if it were the argument to the &lt;code&gt;system&lt;/code&gt; operator (see below). In this case, Perl will wait for the subprocess to complete before continuing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bbaa1ecf2a2a16f0a8eda0bda48b0855b6af1d1c" translate="yes" xml:space="preserve">
          <source>You may also use dmake or gmake. See &lt;a href=&quot;#Make&quot;&gt;&quot;Make&quot;&lt;/a&gt; above on how to get it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5448f65c98891197c6cecbe08ead986b82724f17" translate="yes" xml:space="preserve">
          <source>You may also use dmake. See &lt;a href=&quot;#Make&quot;&gt;Make&lt;/a&gt; above on how to get it.</source>
          <target state="translated">dmake를 사용할 수도 있습니다. 얻는 방법에 대해서는 위의 &lt;a href=&quot;#Make&quot;&gt;확인을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="6a9260264524823855ded5315edf6f0c9bddfa48" translate="yes" xml:space="preserve">
          <source>You may also use the &lt;a href=&quot;IPC::Open3&quot;&gt;IPC::Open3&lt;/a&gt; module (part of the standard perl distribution), but be warned that it has a different order of arguments from &lt;a href=&quot;IPC::Open2&quot;&gt;IPC::Open2&lt;/a&gt; (see &lt;a href=&quot;IPC::Open3&quot;&gt;IPC::Open3&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3196fa8d2ff4d6ac1033b15a7916441466060e42" translate="yes" xml:space="preserve">
          <source>You may also use the &lt;a href=&quot;ipc/open3&quot;&gt;IPC::Open3&lt;/a&gt; module (part of the standard perl distribution), but be warned that it has a different order of arguments from &lt;a href=&quot;ipc/open2&quot;&gt;IPC::Open2&lt;/a&gt; (see &lt;a href=&quot;ipc/open3&quot;&gt;IPC::Open3&lt;/a&gt;).</source>
          <target state="translated">&lt;a href=&quot;ipc/open3&quot;&gt;IPC :: Open3&lt;/a&gt; 모듈 (표준 perl 배포의 일부)을 사용할 수도 있지만 &lt;a href=&quot;ipc/open2&quot;&gt;IPC :: Open2&lt;/a&gt; 와 다른 순서의 인수가 있음을 경고합니다 ( &lt;a href=&quot;ipc/open3&quot;&gt;IPC :: Open3&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="71182d3aa143564846d6bda380e37d7713401c83" translate="yes" xml:space="preserve">
          <source>You may also use the operators &amp;lt; (less than), &amp;lt;= (less than or equal), &amp;gt; (greater than), &amp;gt;= (greater than or equal), == (equal), and != (not equal). For example, the specification &lt;code&gt;&amp;lt; 2.0&lt;/code&gt; means that any version of the prerequisite less than 2.0 is suitable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b7ef88e606ea55cb21f76eea0e0de1fb7b9db2f" translate="yes" xml:space="preserve">
          <source>You may also want to look at one other option for building a perl that will work on Windows: the README.cygwin file, which give a different set of rules to build a perl for Windows. This method will probably enable you to build a more Unix-compatible perl, but you will also need to download and use various other build-time and run-time support software described in that file.</source>
          <target state="translated">Windows에서 작동하는 perl을 빌드하기위한 다른 옵션 인 README.cygwin 파일을 살펴보면 Windows 용 perl을 빌드하기위한 다른 규칙 세트가 제공됩니다. 이 방법을 사용하면 더 많은 Unix 호환 펄을 빌드 할 수 있지만 해당 파일에 설명 된 다양한 기타 빌드 타임 및 런타임 지원 소프트웨어를 다운로드하여 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="47d8e5afa5f51ce60391c15623a30d357b47dac4" translate="yes" xml:space="preserve">
          <source>You may also want to override the &lt;b&gt;begin_input()&lt;/b&gt; and &lt;b&gt;end_input()&lt;/b&gt; methods for your subclass (to perform any needed per-file and/or per-document initialization or cleanup).</source>
          <target state="translated">서브 파일에 대해 &lt;b&gt;begin_input &lt;/b&gt;&lt;b&gt;()&lt;/b&gt; 및 &lt;b&gt;end_input ()&lt;/b&gt; 메소드 를 대체 할 수도 있습니다 &lt;b&gt;(&lt;/b&gt; 필요한 파일 별 및 / 또는 문서 별 초기화 또는 정리를 수행하기 위해).</target>
        </trans-unit>
        <trans-unit id="fad70035f3a1b89b3667a331878011a9d50cf74f" translate="yes" xml:space="preserve">
          <source>You may also want to read over the source for &lt;code&gt;File::Findgrep&lt;/code&gt; and its constituent modules -- they are a complete (if small) example application that uses Maketext.</source>
          <target state="translated">&lt;code&gt;File::Findgrep&lt;/code&gt; 및 그 구성 모듈에 대한 소스를 읽을 수도 있습니다 . Maketext를 사용하는 완전한 (작은 경우) 예제 응용 프로그램입니다.</target>
        </trans-unit>
        <trans-unit id="32c591edfbc105cf26f618c0c72cc57761fceff2" translate="yes" xml:space="preserve">
          <source>You may also wish to discuss with the translators the question of how to relate different subforms of the same language tag, considering how this reacts with &lt;code&gt;get_handle&lt;/code&gt; 's treatment of these. For example, if a user accepts interfaces in &quot;en, fr&quot;, and you have interfaces available in &quot;en-US&quot; and &quot;fr&quot;, what should they get? You may wish to resolve this by establishing that &quot;en&quot; and &quot;en-US&quot; are effectively synonymous, by having one class zero-derive from the other.</source>
          <target state="translated">또한 &lt;code&gt;get_handle&lt;/code&gt; 의 처리 와 어떻게 반응 하는지를 고려하여 번역가와 동일한 언어 태그의 여러 하위 양식을 연관시키는 방법에 대한 질문을 할 수 있습니다 . 예를 들어, 사용자가 &quot;en, fr&quot;의 인터페이스를 허용하고 &quot;en-US&quot;및 &quot;fr&quot;의 인터페이스를 사용할 수 있다면 무엇을 얻을 수 있습니까? &quot;en&quot;과 &quot;en-US&quot;가 한 클래스가 다른 클래스에서 0으로 파생되도록하여 실질적으로 동의어를 설정함으로써이 문제를 해결할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="91e1b897633821a7c3b5243be65043e6b7b07517" translate="yes" xml:space="preserve">
          <source>You may also wish to discuss with the translators the question of how to relate different subforms of the same language tag, considering how this reacts with &lt;code&gt;get_handle&lt;/code&gt;'s treatment of these. For example, if a user accepts interfaces in &quot;en, fr&quot;, and you have interfaces available in &quot;en-US&quot; and &quot;fr&quot;, what should they get? You may wish to resolve this by establishing that &quot;en&quot; and &quot;en-US&quot; are effectively synonymous, by having one class zero-derive from the other.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05003e2911012bca46d826b18714273b702cbb78" translate="yes" xml:space="preserve">
          <source>You may also, in the Bourne shell tradition, specify an EXPR beginning with &lt;code&gt;&amp;gt;&amp;amp;&lt;/code&gt;, in which case the rest of the string is interpreted as the name of a filehandle (or file descriptor, if numeric) to be duped (as &lt;code&gt;dup(2)&lt;/code&gt; ) and opened. You may use &lt;code&gt;&amp;amp;&lt;/code&gt; after &lt;code&gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;&lt;/code&gt; , &lt;code&gt;+&amp;gt;&lt;/code&gt;, &lt;code&gt;+&amp;gt;&amp;gt;&lt;/code&gt; , and &lt;code&gt;+&amp;lt;&lt;/code&gt; . The mode you specify should match the mode of the original filehandle. (Duping a filehandle does not take into account any existing contents of IO buffers.) If you use the three-argument form, then you can pass either a number, the name of a filehandle, or the normal &quot;reference to a glob&quot;.</source>
          <target state="translated">Bourne 쉘 전통에서 &lt;code&gt;&amp;gt;&amp;amp;&lt;/code&gt; 로 시작하는 EXPR을 지정할 수도 있습니다. 이 경우 나머지 문자열은 파일 처리 (또는 숫자 인 경우 파일 설명자)의 이름으로 해석됩니다 ( &lt;code&gt;dup(2)&lt;/code&gt; ) 개설했습니다. 당신은 사용할 수 있습니다 &lt;code&gt;&amp;amp;&lt;/code&gt; 후 &lt;code&gt;&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;&lt;/code&gt; , &lt;code&gt;+&amp;gt;&lt;/code&gt; , &lt;code&gt;+&amp;gt;&amp;gt;&lt;/code&gt; , 그리고 &lt;code&gt;+&amp;lt;&lt;/code&gt; . 지정한 모드는 원본 파일 핸들의 모드와 일치해야합니다. (파일 핸들을 복제하는 것은 IO 버퍼의 기존 내용을 고려하지 않습니다.) 3 인수 양식을 사용하는 경우 숫자, 파일 핸들 이름 또는 일반적인 &quot;글로브 참조&quot;를 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="36b7c7ac25178c324a91d61c24d7fde286a14a90" translate="yes" xml:space="preserve">
          <source>You may also, in the Bourne shell tradition, specify an EXPR beginning with &lt;code&gt;&amp;gt;&amp;amp;&lt;/code&gt;, in which case the rest of the string is interpreted as the name of a filehandle (or file descriptor, if numeric) to be duped (as in &lt;a href=&quot;http://man.he.net/man2/dup&quot;&gt;dup(2)&lt;/a&gt;) and opened. You may use &lt;code&gt;&amp;amp;&lt;/code&gt; after &lt;code&gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;+&amp;gt;&lt;/code&gt;, &lt;code&gt;+&amp;gt;&amp;gt;&lt;/code&gt;, and &lt;code&gt;+&amp;lt;&lt;/code&gt;. The mode you specify should match the mode of the original filehandle. (Duping a filehandle does not take into account any existing contents of IO buffers.) If you use the three-argument form, then you can pass either a number, the name of a filehandle, or the normal &quot;reference to a glob&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c5fc563eb0d1fd26ae839cfa02427332324573f" translate="yes" xml:space="preserve">
          <source>You may ask whether one of these was implemented on the system Perl was built on by asking the importable &lt;code&gt;pw_has&lt;/code&gt; function about them. This function returns true if all parameters are supported fields on the build platform, false if one or more were not, and raises an exception if you asked about a field that Perl never knows how to provide. Parameters may be in a space-separated string, or as separate arguments. If you pass no parameters, the function returns the list of &lt;code&gt;struct pwd&lt;/code&gt; fields supported by your build platform's C library, as a list in list context, or a space-separated string in scalar context. Note that just because your C library had a field doesn't necessarily mean that it's fully implemented on that system.</source>
          <target state="translated">임포트 가능한 &lt;code&gt;pw_has&lt;/code&gt; 함수를 요청하여 Perl이 빌드 된 시스템에서 이들 중 하나가 구현되었는지 여부를 물을 수 있습니다 . 이 함수는 모든 매개 변수가 빌드 플랫폼에서 지원되는 필드 인 경우 true를 리턴하고 하나 이상이 아닌 경우 false를 리턴하며 Perl이 제공 방법을 모르는 필드에 대해 요청한 경우 예외를 발생시킵니다. 매개 변수는 공백으로 구분 된 문자열에 있거나 별도의 인수 일 수 있습니다. 매개 변수를 전달하지 않으면 함수는 빌드 플랫폼의 C 라이브러리에서 지원하는 &lt;code&gt;struct pwd&lt;/code&gt; 필드 목록을 목록 컨텍스트의 목록으로 또는 스칼라 컨텍스트에서 공백으로 구분 된 문자열로 리턴합니다 . C 라이브러리에 필드가 있다고해서 반드시 해당 시스템에서 완전히 구현 된 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="56003b76083072e5d28f4c38591744948d360c03" translate="yes" xml:space="preserve">
          <source>You may at this point want to consider whether your base class (Projname::L10N), from which all lexicons inherit from (Projname::L10N::en, Projname::L10N::es, etc.), should be an _AUTO lexicon. It may be true that in theory, all needed messages will be in each language class; but in the presumably unlikely or &quot;impossible&quot; case of lookup failure, you should consider whether your program should throw an exception, emit text in English (or whatever your project's first language is), or some more complex solution as described in the section &quot;Controlling Lookup Failure&quot;, above.</source>
          <target state="translated">이 시점에서 모든 어휘집이 (Projname :: L10N :: en, Projname :: L10N :: es 등)에서 상속하는 기본 클래스 (Projname :: L10N)가 _AUTO인지 여부를 고려할 수 있습니다. 사전. 이론적으로 필요한 모든 메시지는 각 언어 클래스에있을 것입니다. 그러나 조회 실패의 가능성이 거의 없거나 &quot;불가능한&quot;경우, 프로그램에서 예외를 발생시켜야하는지, 영어로 텍스트를 내 보내야하는지 (또는 프로젝트의 모국어가 무엇이든) 또는 &quot; 위의 조회 실패 제어 &quot;를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="00dd50349ec2812a0e8ba87a508b17b844d30458" translate="yes" xml:space="preserve">
          <source>You may be able to figure out what's going wrong using the Perl debugger. For information about how to use the debugger &lt;b&gt;perldoc&lt;/b&gt;&lt;a href=&quot;perldebug&quot;&gt;perldebug&lt;/a&gt;.</source>
          <target state="translated">Perl 디버거를 사용하여 무엇이 잘못되었는지 파악할 수 있습니다. 디버거 &lt;b&gt;perldoc &lt;/b&gt;&lt;a href=&quot;perldebug&quot;&gt;perldebug&lt;/a&gt; 사용 방법에 대한 정보 .</target>
        </trans-unit>
        <trans-unit id="14e829b9ba39410c7fdd62b2c0459a78db997545" translate="yes" xml:space="preserve">
          <source>You may be able to get the CCTools app, which is free. Keep in mind that you want a full toolchain; some apps tend to default to installing only a barebones version without some important utilities, like ar or nm.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="538c1768e7dd08c154327dd9d81d8469210ac3b8" translate="yes" xml:space="preserve">
          <source>You may be mixing the Tru64 cc/ar/ld with the GNU gcc/ar/ld. That may work, but sometimes it doesn't (your gcc or GNU utils may have been compiled for an incompatible OS release).</source>
          <target state="translated">Tru64 cc / ar / ld와 GNU gcc / ar / ld를 혼합했을 수 있습니다. 작동하지만 때로는 작동하지 않습니다 (gcc 또는 GNU utils가 호환되지 않는 OS 릴리스 용으로 컴파일되었을 수 있습니다).</target>
        </trans-unit>
        <trans-unit id="569474da0977b8a6d57c606d4bf816045d439deb" translate="yes" xml:space="preserve">
          <source>You may be more comfortable with the Perl version of that:</source>
          <target state="translated">Perl 버전에 더 익숙 할 것입니다.</target>
        </trans-unit>
        <trans-unit id="55841621afe9413e5a4d96acdf404652aff0ba71" translate="yes" xml:space="preserve">
          <source>You may be presented with strings in any of these equivalent forms. There is currently nothing in Perl 5 that ignores the differences. So you'll have to specially handle it. The usual advice is to convert your inputs to &lt;code&gt;NFD&lt;/code&gt; before processing further.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a2c2934cf1eab265e83a97c11bed16b38a8b5801" translate="yes" xml:space="preserve">
          <source>You may be presented with strings in any of these equivalent forms. There is currently nothing in Perl 5 that ignores the differences. So you'll have to specially hanlde it. The usual advice is to convert your inputs to &lt;code&gt;NFD&lt;/code&gt; before processing further.</source>
          <target state="translated">이와 동등한 형식으로 문자열이 표시 될 수 있습니다. 현재 Perl 5에는 차이점을 무시하는 것이 없습니다. 그래서 당신은 특별히 그것을 hanlde해야합니다. 일반적인 조언은 추가 처리 전에 입력을 &lt;code&gt;NFD&lt;/code&gt; 로 변환하는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="58f64d73709bb7f46995ccc9ddf584cf761fc186" translate="yes" xml:space="preserve">
          <source>You may call &lt;code&gt;can&lt;/code&gt; as a class (static) method or an object method.</source>
          <target state="translated">&lt;code&gt;can&lt;/code&gt; 을 클래스 (정적) 메소드 또는 객체 메소드로 호출 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8cf034da6832021586a2104fbbd0c08a1605f5bc" translate="yes" xml:space="preserve">
          <source>You may call &lt;code&gt;hv_delete&lt;/code&gt; or &lt;code&gt;hv_delete_ent&lt;/code&gt; on the hash entry that the iterator currently points to, without losing your place or invalidating your iterator. Note that in this case the current entry is deleted from the hash with your iterator holding the last reference to it. Your iterator is flagged to free the entry on the next call to &lt;code&gt;hv_iternext&lt;/code&gt; , so you must not discard your iterator immediately else the entry will leak - call &lt;code&gt;hv_iternext&lt;/code&gt; to trigger the resource deallocation.</source>
          <target state="translated">자리를 잃거나 반복자를 무효화하지 않고 반복자가 현재 가리키는 해시 항목에서 &lt;code&gt;hv_delete&lt;/code&gt; 또는 &lt;code&gt;hv_delete_ent&lt;/code&gt; 를 호출 할 수 있습니다 . 이 경우 현재 항목은 마지막 참조를 보유한 반복자가 해시에서 삭제됩니다. 반복자는 &lt;code&gt;hv_iternext&lt;/code&gt; 에 대한 다음 호출에서 항목을 비우 도록 플래그가 지정 되므로 반복기를 즉시 버리지 않아야합니다. 그렇지 않으면 항목이 누출됩니다. &lt;code&gt;hv_iternext&lt;/code&gt; 를 호출 하여 자원 할당 해제를 트리거하십시오.</target>
        </trans-unit>
        <trans-unit id="224612e001a662c3d4076adbf22c1ddb33c4fc09" translate="yes" xml:space="preserve">
          <source>You may call &lt;code&gt;hv_delete&lt;/code&gt; or &lt;code&gt;hv_delete_ent&lt;/code&gt; on the hash entry that the iterator currently points to, without losing your place or invalidating your iterator. Note that in this case the current entry is deleted from the hash with your iterator holding the last reference to it. Your iterator is flagged to free the entry on the next call to &lt;code&gt;hv_iternext&lt;/code&gt;, so you must not discard your iterator immediately else the entry will leak - call &lt;code&gt;hv_iternext&lt;/code&gt; to trigger the resource deallocation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9be40ceb1a7306a76b520e9584d2eca0a12452f8" translate="yes" xml:space="preserve">
          <source>You may change the pager which is used via &lt;code&gt;o pager=...&lt;/code&gt; command.</source>
          <target state="translated">&lt;code&gt;o pager=...&lt;/code&gt; 명령을 통해 사용되는 호출기를 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8d0d219cb50b9b95de99bdba2a6790e3027b1988" translate="yes" xml:space="preserve">
          <source>You may choose one of six different protocols to use for the ping. The &quot;tcp&quot; protocol is the default. Note that a live remote host may still fail to be pingable by one or more of these protocols. For example, www.microsoft.com is generally alive but not &quot;icmp&quot; pingable.</source>
          <target state="translated">핑에 사용할 6 가지 프로토콜 중 하나를 선택할 수 있습니다. &quot;tcp&quot;프로토콜이 기본값입니다. 이 프로토콜 중 하나 이상에서 라이브 원격 호스트를 여전히 ping 할 수없는 경우가 있습니다. 예를 들어 www.microsoft.com은 일반적으로 &quot;icmp&quot;핑 가능하지는 않지만 살아 있습니다.</target>
        </trans-unit>
        <trans-unit id="5b9386b09cdd1212e7410c2ab62737e2149c7f2b" translate="yes" xml:space="preserve">
          <source>You may create a shared library that refers to another library, which may be either an archive library or a shared library. If this second library is a shared library, this is called a &quot;dependent library&quot;. The dependent library's name is recorded in the main shared library, but it is not linked into the shared library. Instead, it is loaded when the main shared library is loaded. This can cause problems if you build an extension on one system and move it to another system where the libraries may not be located in the same place as on the first system.</source>
          <target state="translated">아카이브 라이브러리 또는 공유 라이브러리 일 수있는 다른 라이브러리를 참조하는 공유 라이브러리를 작성할 수 있습니다. 이 두 번째 라이브러리가 공유 라이브러리 인 경우이를 &quot;종속 라이브러리&quot;라고합니다. 종속 라이브러리의 이름은 기본 공유 라이브러리에 기록되지만 공유 라이브러리에 링크되어 있지 않습니다. 대신 기본 공유 라이브러리가로드 될 때로드됩니다. 한 시스템에서 확장을 빌드하고 라이브러리를 첫 번째 시스템과 같은 위치에 있지 않은 다른 시스템으로 이동하면 문제가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9c69978ae72909c6a0d4c9ce7bda602f4029ade9" translate="yes" xml:space="preserve">
          <source>You may declare &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; variables at the outermost scope of a file to hide any such identifiers from the world outside that file. This is similar in spirit to C's static variables when they are used at the file level. To do this with a subroutine requires the use of a closure (an anonymous function that accesses enclosing lexicals). If you want to create a private subroutine that cannot be called from outside that block, it can declare a lexical variable containing an anonymous sub reference:</source>
          <target state="translated">당신은 선언 할 수있다 &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; 해당 파일 외부 세계에서 이러한 식별자를 숨길 수있는 파일의 가장 바깥 쪽 범위에서 변수를. 이것은 파일 수준에서 사용될 때 C의 정적 변수와 정신적으로 유사합니다. 서브 루틴으로이를 수행하려면 클로저 (내장 어휘에 액세스하는 익명 함수)를 사용해야합니다. 해당 블록 외부에서 호출 할 수없는 개인 서브 루틴을 작성하려는 경우 익명 서브 참조를 포함하는 어휘 변수를 선언 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="876f17265dbc24f5deeea94b0b905e8da6c53d61" translate="yes" xml:space="preserve">
          <source>You may declare &lt;code&gt;my&lt;/code&gt; variables at the outermost scope of a file to hide any such identifiers from the world outside that file. This is similar in spirit to C's static variables when they are used at the file level. To do this with a subroutine requires the use of a closure (an anonymous function that accesses enclosing lexicals). If you want to create a private subroutine that cannot be called from outside that block, it can declare a lexical variable containing an anonymous sub reference:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c485e566982c516f185802a5bb8005684c87aaf" translate="yes" xml:space="preserve">
          <source>You may do &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; threads qw(yield)&lt;/code&gt; , and then just use &lt;code&gt;yield()&lt;/code&gt; in your code.</source>
          <target state="translated">당신은 할 수 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; threads qw(yield)&lt;/code&gt; 한 다음 바로 사용 &lt;code&gt;yield()&lt;/code&gt; 코드에서.</target>
        </trans-unit>
        <trans-unit id="f4966f6d04fe64b0eb4295da47dec6c27a2bd019" translate="yes" xml:space="preserve">
          <source>You may do &lt;code&gt;use threads qw(yield)&lt;/code&gt;, and then just use &lt;code&gt;yield()&lt;/code&gt; in your code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6dafa2436cf995ba75a2bba335e0ce68071a9ad" translate="yes" xml:space="preserve">
          <source>You may downgrade strings with &lt;code&gt;Encode::encode&lt;/code&gt; and &lt;code&gt;utf8::encode&lt;/code&gt;. See &lt;a href=&quot;encode&quot;&gt;Encode&lt;/a&gt; and &lt;a href=&quot;utf8&quot;&gt;utf8&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad59ee540ee6c5334c4114152f24df062a49e4a1" translate="yes" xml:space="preserve">
          <source>You may encounter the following warning message at Perl startup:</source>
          <target state="translated">Perl 시작시 다음 경고 메시지가 표시 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="294037a277c0cf3bb9e6ace3733986ce5d32b057" translate="yes" xml:space="preserve">
          <source>You may find it helpful to have a &quot;macro dictionary&quot;, which you can produce by saying &lt;code&gt;cpp -dM perl.c | &lt;a href=&quot;functions/sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt; . Even then,</source>
          <target state="translated">&quot;매크로 사전&quot;을 갖는 것이 도움이 될 수 있습니다.이 사전은 &lt;code&gt;cpp -dM perl.c | &lt;a href=&quot;functions/sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt; 합니다. 그렇다하더라도,</target>
        </trans-unit>
        <trans-unit id="299fa4ce881470b697321e68c7758eae9bf1d1cf" translate="yes" xml:space="preserve">
          <source>You may find it helpful to have a &quot;macro dictionary&quot;, which you can produce by saying &lt;code&gt;cpp -dM perl.c | sort&lt;/code&gt;. Even then,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="972b606b3734fb1680ed24e777ce569b72a6f320" translate="yes" xml:space="preserve">
          <source>You may find it helpful to use letter case to indicate the scope or nature of a variable. For example:</source>
          <target state="translated">대소 문자를 사용하여 변수의 범위 또는 특성을 나타내는 것이 도움이 될 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c25f48a1ca763d34150d8bac8dc30aeefcd980b5" translate="yes" xml:space="preserve">
          <source>You may get a bus error core dump from the op/pwent or op/grent tests. If compiled with -g you will see a stack trace much like the following:</source>
          <target state="translated">op / pwent 또는 op / grent 테스트에서 버스 오류 코어 덤프를 얻을 수 있습니다. -g로 컴파일하면 다음과 같은 스택 추적이 나타납니다.</target>
        </trans-unit>
        <trans-unit id="108b6e50ab8abc6a709ca1e727e6115ff077c1f8" translate="yes" xml:space="preserve">
          <source>You may get a warning when doing a threaded build:</source>
          <target state="translated">스레드 빌드를 수행 할 때 경고가 표시 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="22f1e826336ce72e185bd16ea03c1b6430323fa0" translate="yes" xml:space="preserve">
          <source>You may have an optional comma before the closing parenthesis of a list literal, so that you can say:</source>
          <target state="translated">목록 리터럴의 닫는 괄호 앞에 선택적 쉼표가있을 수 있으므로 다음과 같이 말할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="94ced856f582ad7ad5a45cb74870b4f4ae27ed8b" translate="yes" xml:space="preserve">
          <source>You may have to add extra libraries as well. Which ones? Perhaps those printed by</source>
          <target state="translated">라이브러리를 추가해야 할 수도 있습니다. 어느 것? 아마</target>
        </trans-unit>
        <trans-unit id="adc5eceb43ab39f0721310d8a087b92c4cf96e19" translate="yes" xml:space="preserve">
          <source>You may have to re-read this entire section a few times...</source>
          <target state="translated">이 전체 섹션을 몇 번 다시 읽어야 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="9e568be51255384d52fb1c41217e7d274f15f0ca" translate="yes" xml:space="preserve">
          <source>You may ignore the error message for the first element of the archive (this doesn't look like a tar archive / skipping to next file...), it's only the directory which will be created automatically anyway.</source>
          <target state="translated">아카이브의 첫 번째 요소에 대한 오류 메시지를 무시할 수 있습니다 (tar 아카이브처럼 보이지 않음 / 다음 파일로 건너 뛰기 ...). 어쨌든 자동으로 생성되는 디렉토리 일뿐입니다.</target>
        </trans-unit>
        <trans-unit id="927c6b1abd9425ad341215fb99d87b72f734b089" translate="yes" xml:space="preserve">
          <source>You may intersperse documentation and Perl code within the .pm file. In fact, if you want to use method autoloading, you must do this, as the comment inside the .pm file explains.</source>
          <target state="translated">.pm 파일 내에 문서와 Perl 코드를 삽입 할 수 있습니다. 실제로, 메소드 자동로드를 사용하려면 .pm 파일 내의 주석에 설명 된대로이를 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="b911c24edf96323dfee0b5a16ac2655f93ba03e8" translate="yes" xml:space="preserve">
          <source>You may lock arrays and hashes as well as scalars. Locking an array, though, will not block subsequent locks on array elements, just lock attempts on the array itself.</source>
          <target state="translated">스칼라뿐만 아니라 배열과 해시를 잠글 수 있습니다. 그러나 배열을 잠그면 배열 요소에 대한 후속 잠금이 차단되지 않고 배열 자체에 대한 잠금 시도 만 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="00344360ec287bdb5274fbd2e88953a8065f329a" translate="yes" xml:space="preserve">
          <source>You may look into the file</source>
          <target state="translated">당신은 파일을 볼 수 있습니다</target>
        </trans-unit>
        <trans-unit id="9516dc740ae77942efcf6e8fd80e5504a8b1fd26" translate="yes" xml:space="preserve">
          <source>You may mail your bug reports (be sure to include full configuration information as output by the myconfig program in the perl source tree, or by &lt;code&gt;perl -V&lt;/code&gt; ) to perlbug@perl.org . If you've succeeded in compiling perl, the &lt;a href=&quot;perlbug&quot;&gt;perlbug&lt;/a&gt; script in the</source>
          <target state="translated">펄 소스 트리의 myconfig 프로그램 또는 &lt;code&gt;perl -V&lt;/code&gt; 에 의해 출력 된 전체 구성 정보를 포함하여 버그 보고서 를 perlbug@perl.org로 우송 할 수 있습니다. 펄 컴파일에 성공했다면, 펄 &lt;a href=&quot;perlbug&quot;&gt;버그&lt;/a&gt; 스크립트는</target>
        </trans-unit>
        <trans-unit id="9b598b6ebd49a9a2c8435acfea60cd639dc39cf9" translate="yes" xml:space="preserve">
          <source>You may need the following GNU programs in order to install perl:</source>
          <target state="translated">perl을 설치하려면 다음 GNU 프로그램이 필요할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="65000230f7491853635f8932fbc750e90e8f3c2d" translate="yes" xml:space="preserve">
          <source>You may need to be</source>
          <target state="translated">당신은해야 할 수도 있습니다</target>
        </trans-unit>
        <trans-unit id="64a7e3cbbe6d605d5c662e6d4594cef6c6e25ffe" translate="yes" xml:space="preserve">
          <source>You may need to carry out some system configuration tasks before running the Configure script for Perl.</source>
          <target state="translated">Perl에 대한 구성 스크립트를 실행하기 전에 일부 시스템 구성 태스크를 수행해야 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="b5c6282830e01b5eeb55fdff2a78b2efbd4e43e4" translate="yes" xml:space="preserve">
          <source>You may need to examine the test results in a more flexible way, for example, the diagnostic output may be quite long or complex or it may involve something that you cannot predict in advance like a timestamp. In this case you can get direct access to the test results:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d10056deec90cd668c3f12e0f304b01dde73621d" translate="yes" xml:space="preserve">
          <source>You may need to make this change to scripts written for a Unix system which expect that after a call to &lt;code&gt;&lt;a href=&quot;functions/unlink&quot;&gt;unlink&lt;/a&gt;&lt;/code&gt;, no files with the names passed to &lt;code&gt;&lt;a href=&quot;functions/unlink&quot;&gt;unlink&lt;/a&gt;&lt;/code&gt; will exist. (Note: This can be changed at compile time; if you &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; Config&lt;/code&gt; and &lt;code&gt;$Config{'d_unlink_all_versions'}&lt;/code&gt; is &lt;code&gt;define&lt;/code&gt; , then &lt;code&gt;&lt;a href=&quot;functions/unlink&quot;&gt;unlink&lt;/a&gt;&lt;/code&gt; will delete all versions of a file on the first call.)</source>
          <target state="translated">당신의 호출 후 기대 유닉스 시스템을 위해 작성된 스크립트에이 변경해야 할 수 있습니다 &lt;code&gt;&lt;a href=&quot;functions/unlink&quot;&gt;unlink&lt;/a&gt;&lt;/code&gt; , 이름과 어떤 파일이 전달되지 &lt;code&gt;&lt;a href=&quot;functions/unlink&quot;&gt;unlink&lt;/a&gt;&lt;/code&gt; 존재하는 것이다. (참고 : 이것은 컴파일 타임에 변경 될 수 있습니다. &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; Config&lt;/code&gt; 를 &lt;a href=&quot;functions/use&quot;&gt;사용&lt;/a&gt; 하고 &lt;code&gt;$Config{'d_unlink_all_versions'}&lt;/code&gt; 가 &lt;code&gt;define&lt;/code&gt; 인 경우 &lt;code&gt;&lt;a href=&quot;functions/unlink&quot;&gt;unlink&lt;/a&gt;&lt;/code&gt; 는 첫 번째 호출에서 파일의 모든 버전을 삭제합니다.)</target>
        </trans-unit>
        <trans-unit id="1ff29c0121a8a089447657f7329f05cee5d1935c" translate="yes" xml:space="preserve">
          <source>You may need to make this change to scripts written for a Unix system which expect that after a call to &lt;code&gt;unlink&lt;/code&gt;, no files with the names passed to &lt;code&gt;unlink&lt;/code&gt; will exist. (Note: This can be changed at compile time; if you &lt;code&gt;use Config&lt;/code&gt; and &lt;code&gt;$Config{'d_unlink_all_versions'}&lt;/code&gt; is &lt;code&gt;define&lt;/code&gt;, then &lt;code&gt;unlink&lt;/code&gt; will delete all versions of a file on the first call.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ec14405f03df7cdb78bb123848d4a14d07a8d45" translate="yes" xml:space="preserve">
          <source>You may not (usefully) use a reference as the key to a hash. It will be converted into a string:</source>
          <target state="translated">참조를 해시의 키로 (유용하게) 사용할 수 없습니다. 문자열로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="d8a434e0ce88a99bf8a5488e4b0fad4981c52cd7" translate="yes" xml:space="preserve">
          <source>You may not even need to write the module. Check whether it's already been done in Perl, and avoid re-inventing the wheel unless you have a good reason.</source>
          <target state="translated">모듈을 작성할 필요조차 없습니다. 이미 Perl에서 수행되었는지 확인하고 적절한 이유가 없으면 휠을 다시 발명하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="936986b9e470ced1f7fdf65dd9ad838a32d13386" translate="yes" xml:space="preserve">
          <source>You may not use data derived from outside your program to affect something else outside your program--at least, not by accident. All command line arguments, environment variables, locale information (see &lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt;), results of certain system calls (&lt;code&gt;&lt;a href=&quot;functions/readdir&quot;&gt;readdir()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/readlink&quot;&gt;readlink()&lt;/a&gt;&lt;/code&gt;, the variable of &lt;code&gt;&lt;a href=&quot;functions/shmread&quot;&gt;shmread()&lt;/a&gt;&lt;/code&gt;, the messages returned by &lt;code&gt;&lt;a href=&quot;functions/msgrcv&quot;&gt;msgrcv()&lt;/a&gt;&lt;/code&gt;, the password, gcos and shell fields returned by the &lt;code&gt;getpwxxx()&lt;/code&gt; calls), and all file input are marked as &quot;tainted&quot;. Tainted data may not be used directly or indirectly in any command that invokes a sub-shell, nor in any command that modifies files, directories, or processes, &lt;b&gt;with the following exceptions&lt;/b&gt;:</source>
          <target state="translated">프로그램 외부에서 파생 된 데이터를 사용하여 프로그램 외부의 다른 것에 영향을 미쳐서는 안됩니다 (적어도 우연이 아님). 모든 명령 행 인수, 환경 변수, 로케일 정보 ( &lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt; 참조 ), 특정 시스템 호출 결과 ( &lt;code&gt;&lt;a href=&quot;functions/readdir&quot;&gt;readdir()&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/readlink&quot;&gt;readlink()&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/shmread&quot;&gt;shmread()&lt;/a&gt;&lt;/code&gt; 변수 , &lt;code&gt;&lt;a href=&quot;functions/msgrcv&quot;&gt;msgrcv()&lt;/a&gt;&lt;/code&gt; 리턴 한 메시지 , 비밀번호, gcos 및 쉘) &lt;code&gt;getpwxxx()&lt;/code&gt; 호출에 의해 반환되는 필드 ) 및 모든 파일 입력은 &quot;오염 된&quot;것으로 표시됩니다. &lt;b&gt;다음과 같은 예외를 제외&lt;/b&gt; 하고 하위 쉘을 호출하는 명령이나 파일, 디렉토리 또는 프로세스를 수정하는 명령에서 오염 된 데이터를 직접 또는 간접적으로 사용할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="dd3902074b205dce05c67740cc2649d8a39ee898" translate="yes" xml:space="preserve">
          <source>You may not use data derived from outside your program to affect something else outside your program--at least, not by accident. All command line arguments, environment variables, locale information (see &lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt;), results of certain system calls (&lt;code&gt;readdir()&lt;/code&gt;, &lt;code&gt;readlink()&lt;/code&gt;, the variable of &lt;code&gt;shmread()&lt;/code&gt;, the messages returned by &lt;code&gt;msgrcv()&lt;/code&gt;, the password, gcos and shell fields returned by the &lt;code&gt;getpwxxx()&lt;/code&gt; calls), and all file input are marked as &quot;tainted&quot;. Tainted data may not be used directly or indirectly in any command that invokes a sub-shell, nor in any command that modifies files, directories, or processes, &lt;b&gt;with the following exceptions&lt;/b&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="591a9362d10f62521cdde4ccfa89567d331e2d8b" translate="yes" xml:space="preserve">
          <source>You may notice that &lt;code&gt;PL_FILES&lt;/code&gt; is not specified above, since the default of mapping each .PL file to its basename works well.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="656cab64db0943d80c2c347bdd21c8a07c645dc2" translate="yes" xml:space="preserve">
          <source>You may once in a while try a &quot;make microperl&quot; to see whether we can still compile Perl with just the bare minimum of interfaces. (See README.micro.)</source>
          <target state="translated">때때로 &quot;make microperl&quot;을 시도하여 최소한의 인터페이스만으로 Perl을 컴파일 할 수 있는지 확인할 수 있습니다. (README.micro 참조)</target>
        </trans-unit>
        <trans-unit id="67acb9777380059ff280be22d8c3f8940dae8cc7" translate="yes" xml:space="preserve">
          <source>You may or may not choose to follow this usage. But never write &quot;PERL&quot;, because perl is not an acronym.</source>
          <target state="translated">이 사용법을 따르거나 선택하지 않을 수 있습니다. 그러나 perl은 약어가 아니므로 &quot;PERL&quot;을 쓰지 마십시오.</target>
        </trans-unit>
        <trans-unit id="613fbbe8af8f9b1517992c7dc5a2a0283f5a8c13" translate="yes" xml:space="preserve">
          <source>You may override this as you like; Maketext doesn't use it for anything.</source>
          <target state="translated">당신이 원하는대로 이것을 무시할 수 있습니다; Maketext는 아무것도 사용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="402c7a6c9e9b95e1569244e1df01e166ced2b5b5" translate="yes" xml:space="preserve">
          <source>You may redistribute this under the same terms as Perl itself.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c300617b79443af38e0fcd704c86c317dd858ef3" translate="yes" xml:space="preserve">
          <source>You may report corrections, additions, and suggestions on the CPAN Request Tracker at</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="471b54cb9da3fd2429477493f77011df7439603d" translate="yes" xml:space="preserve">
          <source>You may run into memory limits, in which case you should use the -Xmx option:</source>
          <target state="translated">메모리 제한이 발생할 수 있습니다.이 경우 -Xmx 옵션을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="2b87668ec2b109de55eff18c1a93548bfc928cdb" translate="yes" xml:space="preserve">
          <source>You may see a message about errors while extracting</source>
          <target state="translated">추출하는 동안 오류에 대한 메시지가 표시 될 수 있습니다</target>
        </trans-unit>
        <trans-unit id="567b2cee3d4edcc53c5dd10d0ae801a480e80721" translate="yes" xml:space="preserve">
          <source>You may see some messages during Configure that seem suspicious.</source>
          <target state="translated">구성 중에 의심스러운 일부 메시지가 표시 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6272ef61085d34f4e76b635ae7f550e4bd67beb6" translate="yes" xml:space="preserve">
          <source>You may see the term &quot;invariant&quot; character or code point. This simply means that the character has the same numeric value and representation when encoded in UTF-8 (or UTF-EBCDIC) as when not. (Note that this is a very different concept from &lt;a href=&quot;#The-13-variant-characters&quot;&gt;&quot;The 13 variant characters&quot;&lt;/a&gt; mentioned above. Careful prose will use the term &quot;UTF-8 invariant&quot; instead of just &quot;invariant&quot;, but most often you'll see just &quot;invariant&quot;.) For example, the ordinal value of &quot;A&quot; is 193 in most EBCDIC code pages, and also is 193 when encoded in UTF-EBCDIC. All UTF-8 (or UTF-EBCDIC) variant code points occupy at least two bytes when encoded in UTF-8 (or UTF-EBCDIC); by definition, the UTF-8 (or UTF-EBCDIC) invariant code points are exactly one byte whether encoded in UTF-8 (or UTF-EBCDIC), or not. (By now you see why people typically just say &quot;UTF-8&quot; when they also mean &quot;UTF-EBCDIC&quot;. For the rest of this document, we'll mostly be casual about it too.) In ASCII UTF-8, the code points corresponding to the lowest 128 ordinal numbers (0 - 127: the ASCII characters) are invariant. In UTF-EBCDIC, there are 160 invariant characters. (If you care, the EBCDIC invariants are those characters which have ASCII equivalents, plus those that correspond to the C1 controls (128 - 159 on ASCII platforms).)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d40b88fd93e71db6719630cc623bcd6de5e08cd" translate="yes" xml:space="preserve">
          <source>You may see the term &quot;invariant&quot; character or code point. This simply means that the character has the same numeric value and representation when encoded in UTF-8 (or UTF-EBCDIC) as when not. (Note that this is a very different concept from &lt;a href=&quot;#The-13-variant-characters&quot;&gt;The 13 variant characters&lt;/a&gt; mentioned above. Careful prose will use the term &quot;UTF-8 invariant&quot; instead of just &quot;invariant&quot;, but most often you'll see just &quot;invariant&quot;.) For example, the ordinal value of &quot;A&quot; is 193 in most EBCDIC code pages, and also is 193 when encoded in UTF-EBCDIC. All UTF-8 (or UTF-EBCDIC) variant code points occupy at least two bytes when encoded in UTF-8 (or UTF-EBCDIC); by definition, the UTF-8 (or UTF-EBCDIC) invariant code points are exactly one byte whether encoded in UTF-8 (or UTF-EBCDIC), or not. (By now you see why people typically just say &quot;UTF-8&quot; when they also mean &quot;UTF-EBCDIC&quot;. For the rest of this document, we'll mostly be casual about it too.) In ASCII UTF-8, the code points corresponding to the lowest 128 ordinal numbers (0 - 127: the ASCII characters) are invariant. In UTF-EBCDIC, there are 160 invariant characters. (If you care, the EBCDIC invariants are those characters which have ASCII equivalents, plus those that correspond to the C1 controls (128 - 159 on ASCII platforms).)</source>
          <target state="translated">&quot;불변&quot;문자 또는 코드 포인트라는 용어가 표시 될 수 있습니다. 이는 문자가 UTF-8 (또는 UTF-EBCDIC)로 인코딩 될 때 문자가 숫자 값과 표현이 같지 않다는 것을 의미합니다. (이것은 &lt;a href=&quot;#The-13-variant-characters&quot;&gt;13 개의 변형 문자&lt;/a&gt; 와는 매우 다른 개념입니다 .위에 언급했듯이. 신중한 산문에서는 &quot;불변&quot;대신 &quot;UTF-8 불변&quot;이라는 용어를 사용하지만 대부분 &quot;불변&quot;만 표시됩니다. 예를 들어 대부분의 EBCDIC 코드 페이지에서 &quot;A&quot;의 서수 값은 193입니다. UTF-EBCDIC으로 인코딩 된 경우 193입니다. 모든 UTF-8 (또는 UTF-EBCDIC) 변형 코드 포인트는 UTF-8 (또는 UTF-EBCDIC)로 인코딩 된 경우 2 바이트 이상을 차지합니다. 정의상 UTF-8 (또는 UTF-EBCDIC)의 불변 코드 포인트는 UTF-8 (또는 UTF-EBCDIC)로 인코딩되었는지 여부에 관계없이 정확히 1 바이트입니다. (이제 사람들이 &quot;UTF-EBCDIC&quot;을 의미 할 때 일반적으로 &quot;UTF-8&quot;이라고 말하는 이유를 알 수 있습니다.이 문서의 나머지 부분에서는 대부분 우연히 설명 할 것입니다. ASCII UTF-8에서 가장 낮은 128 개의 서수 (0-127 : ASCII 문자)에 해당하는 코드 포인트는 변하지 않습니다.UTF-EBCDIC에는 160 개의 고정 문자가 있습니다. 관심이있는 경우 EBCDIC 불변 값은 ASCII에 해당하는 문자와 C1 제어 (ASCII 플랫폼의 경우 128-159)에 해당하는 문자입니다.</target>
        </trans-unit>
        <trans-unit id="79733aabc84104a70d6cbcc3a880d8aa4897ea07" translate="yes" xml:space="preserve">
          <source>You may sense that a lexicon (to use a non-committal catch-all term for a collection of things you know how to say, regardless of whether they're phrases or words) consisting of functions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa093d809cde8bd253ba564171319f316c1ecb65" translate="yes" xml:space="preserve">
          <source>You may set the &lt;code&gt;dw_size&lt;/code&gt; option to limit the amount of data that can be saved in the deferred write buffer. This limit may not exceed the total memory limit. For example, if you set &lt;code&gt;dw_size&lt;/code&gt; to 1000 and &lt;code&gt;memory&lt;/code&gt; to 2500, that means that no more than 1000 bytes of deferred writes will be saved up. The space available for the read cache will vary, but it will always be at least 1500 bytes (if the deferred write buffer is full) and it could grow as large as 2500 bytes (if the deferred write buffer is empty.)</source>
          <target state="translated">지연 쓰기 버퍼에 저장할 수있는 데이터의 양을 제한하기 위해 &lt;code&gt;dw_size&lt;/code&gt; 옵션을 설정할 수 있습니다. 이 제한은 총 메모리 제한을 초과 할 수 없습니다. 예를 들어, &lt;code&gt;dw_size&lt;/code&gt; 를 1000으로 설정 하고 &lt;code&gt;memory&lt;/code&gt; 를 2500으로 설정하면 지연된 쓰기가 1000 바이트 이하로 저장됩니다. 읽기 캐시에 사용 가능한 공간은 다양하지만 항상 최소 1500 바이트 (지연된 쓰기 버퍼가 가득 찬 경우)이고 2500 바이트 (지연된 쓰기 버퍼가 비어있는 경우)만큼 커질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e3ef89e73cb3013d59d9c9121bbae022ae6a75e6" translate="yes" xml:space="preserve">
          <source>You may submit your bug reports (be sure to include full configuration information as output by the myconfig program in the perl source tree, or by &lt;code&gt;perl -V&lt;/code&gt;) to &lt;a href=&quot;https://github.com/Perl/perl5/issues&quot;&gt;https://github.com/Perl/perl5/issues&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fbe802847d2e9437afa3772a7f3ed12ac0cb75f5" translate="yes" xml:space="preserve">
          <source>You may use any combination of these three values 'SUCCESS','FAILURE','DELAY' in the anonymous array reference as defined by RFC3461 (see &lt;a href=&quot;http://www.ietf.org/rfc/rfc3461.txt&quot;&gt;http://www.ietf.org/rfc/rfc3461.txt&lt;/a&gt; for more information. Note: quotations in this topic from same.).</source>
          <target state="translated">RFC3461에 정의 된 익명 배열 참조에서이 세 가지 값 'SUCCESS', 'FAILURE', 'DELAY'의 조합을 사용할 수 있습니다 ( 자세한 내용 은 &lt;a href=&quot;http://www.ietf.org/rfc/rfc3461.txt&quot;&gt;http://www.ietf.org/rfc/rfc3461.txt&lt;/a&gt; 참조) . 참고 :이 주제의 인용문은 동일합니다.).</target>
        </trans-unit>
        <trans-unit id="36629e1d8b3fb0403dc71736a38b10adc1877865" translate="yes" xml:space="preserve">
          <source>You may use any combination of these three values 'SUCCESS','FAILURE','DELAY' in the anonymous array reference as defined by RFC3461 (see http://www.ietf.org/rfc/rfc3461.txt for more information. Note: quotations in this topic from same.).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3726ab64bc777be024735266d80e288f34e7bd83" translate="yes" xml:space="preserve">
          <source>You may use the &lt;code&gt;mv&lt;/code&gt; alias for this function in the same way that you may use the &lt;code&gt;cp&lt;/code&gt; alias for &lt;code&gt;copy&lt;/code&gt; .</source>
          <target state="translated">당신은 사용할 수 있습니다 &lt;code&gt;mv&lt;/code&gt; 당신이 사용할 수있는 동일한 방법으로이 기능에 대한 별칭을 &lt;code&gt;cp&lt;/code&gt; 대한 별칭을 &lt;code&gt;copy&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fb0e3799f2ec470ffb4ae33dcfe538e7d9e90c15" translate="yes" xml:space="preserve">
          <source>You may use the &lt;code&gt;mv&lt;/code&gt; alias for this function in the same way that you may use the &lt;code&gt;cp&lt;/code&gt; alias for &lt;code&gt;copy&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9368b724095114d596f9a9bbd047855f785492a1" translate="yes" xml:space="preserve">
          <source>You may use the syntax &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; File::Copy &quot;cp&quot;&lt;/code&gt; to get at the &lt;code&gt;cp&lt;/code&gt; alias for this function. The syntax is</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; File::Copy &quot;cp&quot;&lt;/code&gt; 구문을 사용 하여이 함수 의 &lt;code&gt;cp&lt;/code&gt; 별명 을 얻을 수 있습니다. 문법은</target>
        </trans-unit>
        <trans-unit id="2cddc64528e49f0c1ae7766ec48b73a37ff2e0c8" translate="yes" xml:space="preserve">
          <source>You may use the syntax &lt;code&gt;use File::Copy &quot;cp&quot;&lt;/code&gt; to get at the &lt;code&gt;cp&lt;/code&gt; alias for this function. The syntax is</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="354ed25e81c6f68b0172423d879862310feed1c5" translate="yes" xml:space="preserve">
          <source>You may very well want to see how your subpattern gets compiled, but it is likely of less use to you to see how Perl matches that against all the legal possibilities, as that is under control of Perl, not you. Therefore, the debugging information of the compilation portion is as specified by the other options, but the debugging output of the matching portion is normally suppressed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ef4fe61a399da32f9cc97283defa049459439a2" translate="yes" xml:space="preserve">
          <source>You may want to configure something like</source>
          <target state="translated">다음과 같이 구성하고 싶을 수도 있습니다</target>
        </trans-unit>
        <trans-unit id="a188842328fc3a53256335dbb97698cdb0d7e65f" translate="yes" xml:space="preserve">
          <source>You may want to create the destination directory and give it the right permissions before installing, thus eliminating the need to build Perl as a super user.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="274166c866cd17a4a70da3e9dd16359e3df50e0e" translate="yes" xml:space="preserve">
          <source>You may want to use the &lt;code&gt;&lt;a href=&quot;perlrecharclass#Digits&quot;&gt;/\d/&lt;/a&gt;&lt;/code&gt; construct instead.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;perlrecharclass#Digits&quot;&gt;/\d/&lt;/a&gt;&lt;/code&gt; 구문을 대신 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3d3a0b34238678a39ac71745f1262bf0f4700e24" translate="yes" xml:space="preserve">
          <source>You may want to use the &lt;code&gt;&lt;a href=&quot;perlrecharclass#Whitespace&quot;&gt;/\s/&lt;/a&gt;&lt;/code&gt; construct instead.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;perlrecharclass#Whitespace&quot;&gt;/\s/&lt;/a&gt;&lt;/code&gt; 구문을 대신 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="30ce0fc76dee65d768e8b8edbb86d17b3ec69cef" translate="yes" xml:space="preserve">
          <source>You may want to use the &lt;code&gt;&lt;a href=&quot;perlrecharclass#Word-characters&quot;&gt;/\w/&lt;/a&gt;&lt;/code&gt; construct instead.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;perlrecharclass#Word-characters&quot;&gt;/\w/&lt;/a&gt;&lt;/code&gt; 구문을 대신 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="599db7e90374e2462ae43e1deb74b5ede6e00ac9" translate="yes" xml:space="preserve">
          <source>You may wish to put your version of perl in the PATH of all users by changing the link</source>
          <target state="translated">링크를 변경하여 펄 버전을 모든 사용자의 경로에 넣을 수 있습니다</target>
        </trans-unit>
        <trans-unit id="a667970ef9d2de2018d0cc9d89b6040168c92e68" translate="yes" xml:space="preserve">
          <source>You might also be interested in using the &lt;a href=&quot;benchmark&quot;&gt;Benchmark&lt;/a&gt; to measure and compare code snippets.</source>
          <target state="translated">&lt;a href=&quot;benchmark&quot;&gt;벤치 마크&lt;/a&gt; 를 사용하여 코드 스 니펫을 측정하고 비교할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e19209d2418cb6070db23de3b3f291f912738061" translate="yes" xml:space="preserve">
          <source>You might also find it more fun to use the standard &lt;a href=&quot;Tie::File&quot;&gt;Tie::File&lt;/a&gt; module, or the &lt;a href=&quot;db_file&quot;&gt;DB_File&lt;/a&gt; module's &lt;code&gt;$DB_RECNO&lt;/code&gt; bindings, which allow you to tie an array to a file so that accessing an element of the array actually accesses the corresponding line in the file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2fb8d4423459616a83c78e11c0c6368281abff5" translate="yes" xml:space="preserve">
          <source>You might also find it more fun to use the standard &lt;a href=&quot;tie/file&quot;&gt;Tie::File&lt;/a&gt; module, or the &lt;a href=&quot;db_file&quot;&gt;DB_File&lt;/a&gt; module's &lt;code&gt;$DB_RECNO&lt;/code&gt; bindings, which allow you to tie an array to a file so that accessing an element of the array actually accesses the corresponding line in the file.</source>
          <target state="translated">표준 &lt;a href=&quot;tie/file&quot;&gt;Tie :: File&lt;/a&gt; 모듈 또는 &lt;a href=&quot;db_file&quot;&gt;DB_File&lt;/a&gt; 모듈의 &lt;code&gt;$DB_RECNO&lt;/code&gt; 바인딩 을 사용하는 것이 더 재미있을 수도 있습니다. 이렇게하면 배열의 요소에 액세스 할 때 실제로 배열의 요소에 액세스 할 수 있습니다. 파일.</target>
        </trans-unit>
        <trans-unit id="e08469744ffe89846f236eef2581143171c3fbcd" translate="yes" xml:space="preserve">
          <source>You might also have loaded that from a function:</source>
          <target state="translated">함수에서로드했을 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="95a16ffa9a148d97aba69dab68818a05442a9c0f" translate="yes" xml:space="preserve">
          <source>You might also see the terms &lt;b&gt;getter&lt;/b&gt; and &lt;b&gt;setter&lt;/b&gt;. These are two types of accessors. A getter gets the attribute's value, while a setter sets it. Another term for a setter is &lt;b&gt;mutator&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;getter&lt;/b&gt; 및 &lt;b&gt;setter&lt;/b&gt; 라는 용어가 표시 될 수도 있습니다 . 이들은 두 가지 유형의 접근 자입니다. getter는 속성 값을 가져오고 setter는이를 설정합니다. 세터의 다른 용어는 &lt;b&gt;뮤 테이터입니다&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="a6f4008d05ac5a7684642f452fcea99bbe63649d" translate="yes" xml:space="preserve">
          <source>You might also think of closure as a way to write a subroutine template without using eval(). Here's a small example of how closures work:</source>
          <target state="translated">eval ()을 사용하지 않고 서브 루틴 템플릿을 작성하는 방법으로 클로저를 생각할 수도 있습니다. 클로저 작동 방식의 간단한 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="adab95dd47c51cc1af72771a0152072872dcbaaf" translate="yes" xml:space="preserve">
          <source>You might also want to check out &lt;a href=&quot;perlfaq8#How-do-I-keep-my-own-module%2Flibrary-directory%3F&quot;&gt;&quot;How do I keep my own module/library directory?&quot; in perlfaq8&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b07a183cbfa7c2c5ada23e1358bb836c0036ff82" translate="yes" xml:space="preserve">
          <source>You might also want to check out &lt;a href=&quot;perlfaq8#How-do-I-keep-my-own-module%2flibrary-directory%3f&quot;&gt;How do I keep my own module/library directory? in perlfaq8&lt;/a&gt;.</source>
          <target state="translated">또한 체크 아웃 할 수 있습니다 &lt;a href=&quot;perlfaq8#How-do-I-keep-my-own-module%2flibrary-directory%3f&quot;&gt;난 내 자신의 모듈 / 라이브러리 디렉토리를 유지하려면 어떻게합니까? perlfaq8에서&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c9d50c5088a6a6db1dd16f71b5a0b7ad311259d2" translate="yes" xml:space="preserve">
          <source>You might also want to employ anonymous functions for simple signal handlers:</source>
          <target state="translated">간단한 신호 처리기를 위해 익명 함수를 사용할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="c4f0a4c3456aabab2b8397ba18c3d239195efdd9" translate="yes" xml:space="preserve">
          <source>You might also want to have GNU groff for OS/390 installed before running the &quot;make install&quot; step for Perl.</source>
          <target state="translated">Perl에 대해 &quot;make install&quot;단계를 실행하기 전에 OS / 390 용 GNU groff를 설치하고 싶을 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="2fa0f7304d269ada4e265c5dcd91a35489923597" translate="yes" xml:space="preserve">
          <source>You might also want to trap any errors by wrapping an &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; block around the whole thing.</source>
          <target state="translated">모든 것을 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 블록으로 감싸서 오류를 잡을 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f194f9c87c4be6e7a8b64a94f082480b14ad7510" translate="yes" xml:space="preserve">
          <source>You might also want to trap any errors by wrapping an &lt;code&gt;eval&lt;/code&gt; block around the whole thing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae14caefeb104abfd32e1ac4b08ddaa6c43442c2" translate="yes" xml:space="preserve">
          <source>You might be tempted to think that deferred writing is like transactions, with &lt;code&gt;flush&lt;/code&gt; as &lt;code&gt;commit&lt;/code&gt; and &lt;code&gt;discard&lt;/code&gt; as &lt;code&gt;rollback&lt;/code&gt; , but it isn't, so don't.</source>
          <target state="translated">당신과 함께, 그 연기 쓰기 트랜잭션처럼 생각하는 유혹 할 수있는 &lt;code&gt;flush&lt;/code&gt; 로 &lt;code&gt;commit&lt;/code&gt; 및 &lt;code&gt;discard&lt;/code&gt; 등의 &lt;code&gt;rollback&lt;/code&gt; 하지만 그렇게하지,하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1c6b7aa981d94fea5d2afafa18044a92955cf0dc" translate="yes" xml:space="preserve">
          <source>You might be tempted to think that deferred writing is like transactions, with &lt;code&gt;flush&lt;/code&gt; as &lt;code&gt;commit&lt;/code&gt; and &lt;code&gt;discard&lt;/code&gt; as &lt;code&gt;rollback&lt;/code&gt;, but it isn't, so don't.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eadb7f27713b1af6126dec14d8fa3f25be31b545" translate="yes" xml:space="preserve">
          <source>You might be tempted to use &lt;code&gt;$#array + 1&lt;/code&gt; to tell you how many items there are in an array. Don't bother. As it happens, using &lt;code&gt;@array&lt;/code&gt; where Perl expects to find a scalar value (&quot;in scalar context&quot;) will give you the number of elements in the array:</source>
          <target state="translated">&lt;code&gt;$#array + 1&lt;/code&gt; 몇 개의 항목이 있는지 $ # array + 1 을 사용하고 싶을 수도 있습니다 . 귀찮게하지 마십시오. 펄이 스칼라 값 ( &quot;스칼라 컨텍스트에서&quot;)을 찾을 것으로 예상하는 곳에서 &lt;code&gt;@array&lt;/code&gt; 를 사용 하면 배열의 요소 수를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cdd5e43c44200a95eaa3aa45d374b3ef4d1b96c7" translate="yes" xml:space="preserve">
          <source>You might consider using just Math::BigInt or Math::BigFloat, since they allow you finer control over what get's done in which module/space. For instance, simple loop counters will be Math::BigInts under &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; bignum;&lt;/code&gt; and this is slower than keeping them as Perl scalars:</source>
          <target state="translated">Math :: BigInt 또는 Math :: BigFloat 만 사용하면 어떤 모듈 / 공간에서 수행되는 작업을보다 세밀하게 제어 할 수 있으므로 사용하는 것이 좋습니다. 예를 들어 간단한 루프 카운터는 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; bignum;&lt;/code&gt; 을 &lt;a href=&quot;functions/use&quot;&gt;사용하는&lt;/a&gt; Math :: BigInts입니다 . 그리고 이것은 Perl 스칼라로 유지하는 것보다 느립니다.</target>
        </trans-unit>
        <trans-unit id="30c848bd997fa1fb77285aa03d0d04fc4d8a21e7" translate="yes" xml:space="preserve">
          <source>You might consider using just Math::BigInt or Math::BigFloat, since they allow you finer control over what get's done in which module/space. For instance, simple loop counters will be Math::BigInts under &lt;code&gt;use bignum;&lt;/code&gt; and this is slower than keeping them as Perl scalars:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="602086881bebd3c9c81540dfd1686b9dc1e9a7c1" translate="yes" xml:space="preserve">
          <source>You might expect this to output &quot;12&quot;. In fact, it prints &quot;&amp;lt;&quot;: the ASCII result of treating &quot;|&quot; as a bitwise string operator - that is, the result of treating the operands as the strings &quot;4&quot; and &quot;8&quot; rather than numbers. The fact that numify (&lt;code&gt;0+&lt;/code&gt; ) is implemented but stringify (&lt;code&gt;&quot;&quot;&lt;/code&gt; ) isn't makes no difference since the latter is simply autogenerated from the former.</source>
          <target state="translated">&quot;12&quot;가 출력 될 것으로 예상 할 수 있습니다. 실제로 &quot;&amp;lt;&quot;를 출력합니다 : &quot;|&quot;를 처리 한 ASCII 결과 비트 문자열 연산자-즉 피연산자를 숫자가 아닌 문자열 &quot;4&quot;및 &quot;8&quot;로 처리 한 결과입니다. numify ( &lt;code&gt;0+&lt;/code&gt; )가 구현되었지만 stringify ( &lt;code&gt;&quot;&quot;&lt;/code&gt; )는 전자가 단순히 자동 생성되기 때문에 차이가 없습니다.</target>
        </trans-unit>
        <trans-unit id="aba6c51d79ac08de8cd8c4628728aebfc81fc52e" translate="yes" xml:space="preserve">
          <source>You might expect this to output &quot;12&quot;. In fact, it prints &quot;&amp;lt;&quot;: the ASCII result of treating &quot;|&quot; as a bitwise string operator - that is, the result of treating the operands as the strings &quot;4&quot; and &quot;8&quot; rather than numbers. The fact that numify (&lt;code&gt;0+&lt;/code&gt;) is implemented but stringify (&lt;code&gt;&quot;&quot;&lt;/code&gt;) isn't makes no difference since the latter is simply autogenerated from the former.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec2b6e72cccd9ea401a92e1c584d3ce729f0ed23" translate="yes" xml:space="preserve">
          <source>You might find these links useful:</source>
          <target state="translated">다음 링크가 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7041884103fb3be2206f9857bdd3e655cde0bf34" translate="yes" xml:space="preserve">
          <source>You might have expected test 3 to fail because it seems to a more general purpose version of test 1. The important difference between them is that test 3 contains a quantifier (&lt;code&gt;\D*&lt;/code&gt; ) and so can use backtracking, whereas test 1 will not. What's happening is that you've asked &quot;Is it true that at the start of $x, following 0 or more non-digits, you have something that's not 123?&quot; If the pattern matcher had let &lt;code&gt;\D*&lt;/code&gt; expand to &quot;ABC&quot;, this would have caused the whole pattern to fail.</source>
          <target state="translated">테스트 3은 좀 더 일반적인 목적의 테스트 1로 보이므로 테스트 3이 실패 할 것으로 예상했을 수 있습니다. 그 사이의 중요한 차이점은 테스트 3에 수량 화기 ( &lt;code&gt;\D*&lt;/code&gt; ) 가 포함되어 역 추적을 사용할 수 있지만 테스트 1은 그렇지 않습니다. 무슨 일이 일어나고 있는지 &quot;당신이 $ x의 시작에서 0이 아닌 숫자가 아닌 숫자 다음에 123이 아닌 것을 가지고 있다는 것이 사실입니까?&quot; 패턴 매 처가 &lt;code&gt;\D*&lt;/code&gt; 를 &quot;ABC&quot;로 확장하게 한 경우 전체 패턴이 실패했을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8d27aa5c6286c0d9603c5055be14cd21bce623ba" translate="yes" xml:space="preserve">
          <source>You might have expected test 3 to fail because it seems to a more general purpose version of test 1. The important difference between them is that test 3 contains a quantifier (&lt;code&gt;\D*&lt;/code&gt;) and so can use backtracking, whereas test 1 will not. What's happening is that you've asked &quot;Is it true that at the start of &lt;code&gt;$x&lt;/code&gt;, following 0 or more non-digits, you have something that's not 123?&quot; If the pattern matcher had let &lt;code&gt;\D*&lt;/code&gt; expand to &quot;ABC&quot;, this would have caused the whole pattern to fail.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5bd0f9bdd3b3f8f6c3d7920cb7c553cce6d6284" translate="yes" xml:space="preserve">
          <source>You might like to read Mark Jason Dominus's &quot;Suffering From Buffering&quot; at &lt;a href=&quot;http://perl.plover.com/FAQs/Buffering.html&quot;&gt;http://perl.plover.com/FAQs/Buffering.html&lt;/a&gt; .</source>
          <target state="translated">&lt;a href=&quot;http://perl.plover.com/FAQs/Buffering.html&quot;&gt;http://perl.plover.com/FAQs/Buffering.html&lt;/a&gt; 에서 Mark Jason Dominus의 &quot;Suffering From Buffering&quot;을 읽어보십시오 .</target>
        </trans-unit>
        <trans-unit id="46f43a5be926bef744cfabc91aaec25e6a108f46" translate="yes" xml:space="preserve">
          <source>You might like to use &lt;a href=&quot;#do-EXPR&quot;&gt;&lt;code&gt;do&lt;/code&gt;&lt;/a&gt; to read in a program configuration file. Manual error checking can be done this way:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5e0af742e5a24576127c7192de3da3f64667af3" translate="yes" xml:space="preserve">
          <source>You might like to use &lt;code&gt;&lt;a href=&quot;do&quot;&gt;do&lt;/a&gt;&lt;/code&gt; to read in a program configuration file. Manual error checking can be done this way:</source>
          <target state="translated">프로그램 구성 파일에서 &lt;code&gt;&lt;a href=&quot;do&quot;&gt;do&lt;/a&gt;&lt;/code&gt; 를 사용 하여 읽을 수 있습니다 . 다음과 같이 수동 오류 검사를 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ea3e43e35b42104c2dfdbbb81763643be691010c" translate="yes" xml:space="preserve">
          <source>You might like to use &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt;&lt;/code&gt; to read in a program configuration file. Manual error checking can be done this way:</source>
          <target state="translated">프로그램 구성 파일에서 &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt;&lt;/code&gt; 를 사용 하여 읽을 수 있습니다 . 다음과 같이 수동 오류 검사를 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2bd0dacd69a7ed36257e893211378330acac2cba" translate="yes" xml:space="preserve">
          <source>You might love it. You might feel that everyone else needs it. But there might not actually be any real demand for it out there. If you're unsure about the demand your module will have, consider asking the &lt;code&gt;module-authors@perl.org&lt;/code&gt; mailing list (send an email to &lt;code&gt;module-authors-subscribe@perl.org&lt;/code&gt; to subscribe; see &lt;a href=&quot;https://lists.perl.org/list/module-authors.html&quot;&gt;https://lists.perl.org/list/module-authors.html&lt;/a&gt; for more information and a link to the archives).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="052100b20ac103ab19054e70ed9a9d17e374ebf5" translate="yes" xml:space="preserve">
          <source>You might love it. You might feel that everyone else needs it. But there might not actually be any real demand for it out there. If you're unsure about the demand your module will have, consider sending out feelers on the &lt;code&gt;comp.lang.perl.modules&lt;/code&gt; newsgroup, or as a last resort, ask the modules list at &lt;code&gt;modules@perl.org&lt;/code&gt; . Remember that this is a closed list with a very long turn-around time - be prepared to wait a good while for a response from them.</source>
          <target state="translated">당신은 그것을 좋아할 것입니다. 다른 사람들이 필요하다고 느낄 수도 있습니다. 그러나 실제로는 실제 수요가 없을 수도 있습니다. 모듈의 요구 사항에 대해 잘 모르는 경우 &lt;code&gt;comp.lang.perl.modules&lt;/code&gt; 뉴스 그룹에서 &lt;code&gt;modules@perl.org&lt;/code&gt; 보내거나 마지막 수단으로 모듈 목록을 모듈 @ perl.org로 요청하십시오 . 이 답변은 처리 시간이 매우 긴 비공개 목록입니다. 답변을 기다리는 동안 준비를하시기 바랍니다.</target>
        </trans-unit>
        <trans-unit id="635f4d083c94bfb096f7bc0bc442f402e843c1a1" translate="yes" xml:space="preserve">
          <source>You might mistakenly think that &lt;code&gt;len&lt;/code&gt; is the number of bytes to add to the existing size, but instead it is the total size &lt;code&gt;sv&lt;/code&gt; should be.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="169bde04d58834aed9e29a6302664c4d13ccbcd6" translate="yes" xml:space="preserve">
          <source>You might not need all the power of XS. The Inline::C module lets you put C code directly in your Perl source. It handles all the magic to make it work. You still have to learn at least some of the perl API but you won't have to deal with the complexity of the XS support files.</source>
          <target state="translated">XS의 모든 기능이 필요하지 않을 수 있습니다. Inline :: C 모듈을 사용하면 C 코드를 Perl 소스에 직접 넣을 수 있습니다. 그것은 모든 마법을 처리하여 작동시킵니다. 여전히 최소한 perl API를 배워야하지만 XS 지원 파일의 복잡성을 처리 할 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="3b031c43f33840adc70b02de47a8fd1daefabaa6" translate="yes" xml:space="preserve">
          <source>You might notice several familiar Perl concepts in this collection of ACM columns from Jon Bentley. The similarity to the title of the major Perl book (which came later) is not completely accidental:</source>
          <target state="translated">Jon Bentley의이 ACM 컬럼 콜렉션에서 몇 가지 친숙한 Perl 개념을 알 수 있습니다. 주요 Perl 책의 제목과 비슷한 점은 나중에 우연히 나오는 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="66fdf1bb9d02362c3ab6fa3feaa38bdbfcec77f8" translate="yes" xml:space="preserve">
          <source>You might notice that you could use backticks for much the same effect as opening a pipe for reading:</source>
          <target state="translated">읽을 파이프를 여는 것과 같은 효과를 위해 백틱을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="42704287df9412e9063781246ba069342cd72b32" translate="yes" xml:space="preserve">
          <source>You might notice this when each of the elements of &lt;code&gt;@array&lt;/code&gt; end with a newline. You expect to print one element per line, but notice that every line after the first is indented:</source>
          <target state="translated">&lt;code&gt;@array&lt;/code&gt; 의 각 요소가 줄 바꿈으로 끝나는 경우이를 알 수 있습니다 . 한 줄에 하나의 요소를 인쇄 할 것으로 예상되지만 첫 번째 요소 이후의 모든 줄은 들여 쓰기됩니다.</target>
        </trans-unit>
        <trans-unit id="e3ccde21cef99ed04d4c1fb15da658aad8223bd5" translate="yes" xml:space="preserve">
          <source>You might prefer to go on to &lt;a href=&quot;perllol&quot;&gt;perllol&lt;/a&gt; instead of &lt;a href=&quot;perlref&quot;&gt;perlref&lt;/a&gt;; it discusses lists of lists and multidimensional arrays in detail. After that, you should move on to &lt;a href=&quot;perldsc&quot;&gt;perldsc&lt;/a&gt;; it's a Data Structure Cookbook that shows recipes for using and printing out arrays of hashes, hashes of arrays, and other kinds of data.</source>
          <target state="translated">당신 은 &lt;a href=&quot;perlref&quot;&gt;perlref&lt;/a&gt; 대신 &lt;a href=&quot;perllol&quot;&gt;perllol을&lt;/a&gt; 선호한다 ; 목록 및 다차원 배열 목록에 대해 자세히 설명합니다. 그런 다음 &lt;a href=&quot;perldsc&quot;&gt;perldsc&lt;/a&gt; 로 이동해야합니다 . 해시 배열, 해시 배열 및 기타 종류의 데이터를 사용하고 인쇄하는 방법을 보여주는 Data Structure Cookbook입니다.</target>
        </trans-unit>
        <trans-unit id="a6310ecb45c68b753610be852acb876a80aa3c10" translate="yes" xml:space="preserve">
          <source>You might relate this to a fictional 'Translate' module:</source>
          <target state="translated">이것을 가상의 '번역'모듈과 관련시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="13ab2e65d93fb0059f6f55ed6a75f22913178d96" translate="yes" xml:space="preserve">
          <source>You might remember &lt;code&gt;ok() or diag()&lt;/code&gt; with the mnemonic &lt;code&gt;&lt;a href=&quot;../functions/open&quot;&gt;open&lt;/a&gt;() or
&lt;a href=&quot;../functions/die&quot;&gt;die&lt;/a&gt;()&lt;/code&gt; .</source>
          <target state="translated">니모닉 &lt;code&gt;&lt;a href=&quot;../functions/open&quot;&gt;open&lt;/a&gt;() or &lt;a href=&quot;../functions/die&quot;&gt;die&lt;/a&gt;()&lt;/code&gt; () 또는 &lt;a href=&quot;../functions/die&quot;&gt;die&lt;/a&gt; ()로 &lt;code&gt;ok() or diag()&lt;/code&gt; 를 기억할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="88eec674517534aa08403d748f3a5041ffce6d87" translate="yes" xml:space="preserve">
          <source>You might remember &lt;code&gt;ok() or diag()&lt;/code&gt; with the mnemonic &lt;code&gt;open() or die()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c266ee238a4776706bced7eb857615f2dea1e3c" translate="yes" xml:space="preserve">
          <source>You might sometimes find that the original author has edited the branch's history. There are lots of good reasons for this. Sometimes, an author might simply be rebasing the branch onto a newer source point. Sometimes, an author might have found an error in an early commit which they wanted to fix before merging the branch to blead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37d4864369383102be2440cd5c5cb4b7987e528b" translate="yes" xml:space="preserve">
          <source>You might sometimes see reference to Rule 1 and Rule 2. Larry's power as Supreme Court is expressed in The Rules:</source>
          <target state="translated">때때로 규칙 1과 규칙 2에 대한 언급을 볼 수 있습니다. 대법원으로서의 래리의 권한은 규칙에 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="8dd311a23537c2ad8611321313121285ae51f8bb" translate="yes" xml:space="preserve">
          <source>You might try &lt;a href=&quot;Encode::Guess&quot;&gt;Encode::Guess&lt;/a&gt;, but it has a number of limitations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5b7d1197bc89948add2ed3f352d319d84d2e28b" translate="yes" xml:space="preserve">
          <source>You might try &lt;a href=&quot;encode/guess&quot;&gt;Encode::Guess&lt;/a&gt;, but it has a number of limitations.</source>
          <target state="translated">&lt;a href=&quot;encode/guess&quot;&gt;Encode :: Guess&lt;/a&gt; 시도해 볼 수 있지만 여러 가지 제한이 있습니다.</target>
        </trans-unit>
        <trans-unit id="193b85d5b4fe0e90a0d9c66d7d0b78036e923063" translate="yes" xml:space="preserve">
          <source>You might want to do the same thing for expressing key bindings or the like (since hardwiring &quot;q&quot; as the binding for the function that quits a screen/menu/program is useful only if your language happens to associate &quot;q&quot; with &quot;quit&quot;!)</source>
          <target state="translated">키 바인딩 등을 표현하기 위해 동일한 작업을 수행하고자 할 수 있습니다 (화면 / 메뉴 / 프로그램을 종료하는 기능의 바인딩이 &quot;q&quot;와 &quot;quit&quot;을 연관시키는 경우에만 유용하므로 하드와 이어링 &quot;q&quot;이므로) &quot;!)</target>
        </trans-unit>
        <trans-unit id="b5d495d915ce638287be04e211dc9e03d5ac46bf" translate="yes" xml:space="preserve">
          <source>You might want to keep these desktop references close by your keyboard:</source>
          <target state="translated">다음 데스크탑 참조를 키보드로 가까이 두십시오.</target>
        </trans-unit>
        <trans-unit id="d8a5e7dd7b9870679e3daf8f99524f8e40f1a078" translate="yes" xml:space="preserve">
          <source>You might want to use &lt;a href=&quot;#accuracy%28%29&quot;&gt;&quot;accuracy()&quot;&lt;/a&gt; instead. With &lt;a href=&quot;#accuracy%28%29&quot;&gt;&quot;accuracy()&quot;&lt;/a&gt; you set the number of digits each result should have, with &lt;a href=&quot;#precision%28%29&quot;&gt;&quot;precision()&quot;&lt;/a&gt; you set the place where to round.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d1eb54f95a4e04b463b84dfe6de9e8067695824" translate="yes" xml:space="preserve">
          <source>You might wonder why &lt;code&gt;'.'&lt;/code&gt; matches everything but &lt;code&gt;&quot;\n&quot;&lt;/code&gt; - why not every character? The reason is that often one is matching against lines and would like to ignore the newline characters. For instance, while the string &lt;code&gt;&quot;\n&quot;&lt;/code&gt; represents one line, we would like to think of it as empty. Then</source>
          <target state="translated">왜 &lt;code&gt;'.'&lt;/code&gt; &lt;code&gt;&quot;\n&quot;&lt;/code&gt; 제외한 모든 항목과 일치 -왜 모든 문자가 아닌가 그 이유는 종종 하나가 행과 일치하고 개행 문자를 무시하고 싶어하기 때문입니다. 예를 들어 문자열 &lt;code&gt;&quot;\n&quot;&lt;/code&gt; 은 한 줄을 나타내지 만 빈 줄로 생각하고 싶습니다. 그때</target>
        </trans-unit>
        <trans-unit id="e851d081cca3db1538b95133dfa4e2591e66b038" translate="yes" xml:space="preserve">
          <source>You must Configure perl with</source>
          <target state="translated">다음을 사용하여 perl을 구성해야합니다.</target>
        </trans-unit>
        <trans-unit id="2b0e2052701354699753b2ee60dea4ed06963928" translate="yes" xml:space="preserve">
          <source>You must be triply conscious of cross-platform concerns. This usually boils down to using &lt;a href=&quot;File::Spec&quot;&gt;File::Spec&lt;/a&gt;, avoiding things like &lt;code&gt;fork()&lt;/code&gt; and &lt;code&gt;system()&lt;/code&gt; unless absolutely necessary, and not assuming that a given character has a particular ordinal value (code point) or that its UTF-8 representation is composed of particular bytes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c18657846c86f19718177ea80036f400e403ff68" translate="yes" xml:space="preserve">
          <source>You must be triply conscious of cross-platform concerns. This usually boils down to using &lt;a href=&quot;file/spec&quot;&gt;File::Spec&lt;/a&gt;, avoiding things like &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork()&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system()&lt;/a&gt;&lt;/code&gt; unless absolutely necessary, and not assuming that a given character has a particular ordinal value (code point) or that its UTF-8 representation is composed of particular bytes.</source>
          <target state="translated">크로스 플랫폼 문제를 세 심하게 인식해야합니다. 이것은 일반적으로 &lt;a href=&quot;file/spec&quot;&gt;File :: Spec&lt;/a&gt; 을 사용하여 절대적으로 필요한 경우가 아니라면 &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork()&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system()&lt;/a&gt;&lt;/code&gt; () 과 같은 것을 피하고 주어진 문자에 특정 서수 값 (코드 포인트)이 있거나 UTF-8 표현이 구성되어 있다고 가정하지 않습니다 특정 바이트.</target>
        </trans-unit>
        <trans-unit id="8daf2a31e4062052794994fb1a77c6bf915b4376" translate="yes" xml:space="preserve">
          <source>You must call &lt;code&gt;plan(...)&lt;/code&gt; once and only once. You should call it in a &lt;code&gt;BEGIN {...}&lt;/code&gt; block, like so:</source>
          <target state="translated">&lt;code&gt;plan(...)&lt;/code&gt; 한 번만 호출해야합니다 . &lt;code&gt;BEGIN {...}&lt;/code&gt; 블록에서 다음과 같이 호출해야합니다 .</target>
        </trans-unit>
        <trans-unit id="ec48be76fb2e44c8427a737bacd675c106899a43" translate="yes" xml:space="preserve">
          <source>You must convert your non-ASCII, non-UTF-8 Perl scripts to be UTF-8.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d9b102a51e636379025c1716da72ec7158d144f" translate="yes" xml:space="preserve">
          <source>You must have a plan.</source>
          <target state="translated">계획이 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="f323bd128da70502b49397ad0f7c4f483197be9e" translate="yes" xml:space="preserve">
          <source>You must have a project base class, which you load, and which you then use as the first argument in the call to YourProjClass-&amp;gt;get_handle(...). It should derive (whether directly or indirectly) from Locale::Maketext. It &lt;b&gt;doesn't matter&lt;/b&gt; how you name this class, although assuming this is the localization component of your Super Mega Program, good names for your project class might be SuperMegaProgram::Localization, SuperMegaProgram::L10N, SuperMegaProgram::I18N, SuperMegaProgram::International, or even SuperMegaProgram::Languages or SuperMegaProgram::Messages.</source>
          <target state="translated">프로젝트베이스 클래스가 있어야하며,로드 한 다음 YourProjClass-&amp;gt; get_handle (...) 호출에서 첫 번째 인수로 사용합니다. Locale :: Maketext에서 (직접 또는 간접적으로) 파생되어야합니다. 그것은 &lt;b&gt;중요하지 않습니다&lt;/b&gt; 이 가정하는 것은 귀하의 슈퍼 메가 프로그램의 현지화 요소이지만 당신은이 클래스의 이름을 지정하는 방법, 프로젝트 클래스에 대한 좋은 이름은 SuperMegaProgram :: 현지화, SuperMegaProgram :: L10N, SuperMegaProgram :: 국제화, SuperMegaProgram 수 있습니다 :: 국제 또는 심지어 SuperMegaProgram :: Languages ​​또는 SuperMegaProgram :: Messages.</target>
        </trans-unit>
        <trans-unit id="739cc975a787be41633b91aa5de71e36b127ddec" translate="yes" xml:space="preserve">
          <source>You must install the &lt;code&gt;Expect&lt;/code&gt; module to use &lt;code&gt;eexpect&lt;/code&gt; . CPAN.pm does not install it for you.</source>
          <target state="translated">&lt;code&gt;eexpect&lt;/code&gt; 를 사용 하려면 &lt;code&gt;Expect&lt;/code&gt; 모듈을 설치해야합니다 . CPAN.pm은이를 설치하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="72fde4fbc93c4a749f9096aea6d3bd9a70e80b1d" translate="yes" xml:space="preserve">
          <source>You must install the &lt;code&gt;Expect&lt;/code&gt; module to use &lt;code&gt;expect&lt;/code&gt; . CPAN.pm does not install it for you.</source>
          <target state="translated">당신은 설치해야합니다 &lt;code&gt;Expect&lt;/code&gt; 사용에 모듈을 &lt;code&gt;expect&lt;/code&gt; . CPAN.pm은이를 설치하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4490a879ca5d596cdf1f67e2681afb5d54f17c52" translate="yes" xml:space="preserve">
          <source>You must make sure that any paths and path components are properly surrounded with double-quotes if they contain spaces. For example, &lt;code&gt;$potential_libs&lt;/code&gt; could be (literally):</source>
          <target state="translated">경로와 경로 구성 요소가 공백을 포함하는 경우 큰 따옴표로 올바르게 둘러싸여 있는지 확인해야합니다. 예를 들어 &lt;code&gt;$potential_libs&lt;/code&gt; 는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="30c4fd5a99a25cad991844e3c5c4f7509fd399a0" translate="yes" xml:space="preserve">
          <source>You must open your files before you print to them.</source>
          <target state="translated">파일을 인쇄하기 전에 파일을 열어야합니다.</target>
        </trans-unit>
        <trans-unit id="45897939488bd63d927112e2ca64e2fec16238a0" translate="yes" xml:space="preserve">
          <source>You must override the abstract methods as noted above.</source>
          <target state="translated">위에서 언급 한대로 추상 메소드를 대체해야합니다.</target>
        </trans-unit>
        <trans-unit id="2aa81922480ed45c435c4cf0c99c4c4aba3634fc" translate="yes" xml:space="preserve">
          <source>You must use &lt;code&gt;elsif&lt;/code&gt; rather than &lt;code&gt;else if&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;else if&lt;/code&gt; &lt;code&gt;elsif&lt;/code&gt; 대신 elsif 를 사용해야 합니다 .</target>
        </trans-unit>
        <trans-unit id="d5226624761673c1e1cddc0c742247733ee03083" translate="yes" xml:space="preserve">
          <source>You must use &lt;code&gt;elsif&lt;/code&gt; rather than &lt;code&gt;else if&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39c7a78d87a43f543e7180d2370d441ee16c546b" translate="yes" xml:space="preserve">
          <source>You must use an ANSI C compiler to build perl. Perl can be compiled with either Sun's add-on C compiler or with gcc. The C compiler that shipped with SunOS4 will not do.</source>
          <target state="translated">perl을 빌드하려면 ANSI C 컴파일러를 사용해야합니다. Perl은 Sun의 애드온 C 컴파일러 또는 gcc로 컴파일 할 수 있습니다. SunOS4와 함께 제공된 C 컴파일러는 그렇지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ac16e240bd822406d6dbb8a20f6f3e5d780cc6b4" translate="yes" xml:space="preserve">
          <source>You must use the cmd.exe, the Cygwin shell will not work. The PATH must include the SDK tools, including a Perl, which should be the case under cmd.exe. If you do not have that, see the end of symbian\sdk.pl for notes of how your environment should be set up for Symbian compiles.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c168b8ed4e8b351eba14fd33d598861cf2969e22" translate="yes" xml:space="preserve">
          <source>You must yourself do any alignment or padding by inserting, for example, enough &lt;code&gt;&quot;x&quot;&lt;/code&gt; es while packing. There is no way for pack() and unpack() to know where characters are going to or coming from, so they handle their output and input as flat sequences of characters.</source>
          <target state="translated">포장하는 동안 충분한 &lt;code&gt;&quot;x&quot;&lt;/code&gt; 를 삽입하여 정렬이나 패딩을 직접해야합니다 . pack () 및 unpack ()은 문자가 어디로 오거나 오는지를 알 수 없으므로 출력 및 입력을 플랫 문자 시퀀스로 처리합니다.</target>
        </trans-unit>
        <trans-unit id="da2b6f4499c28ef8f95dd1270da02ad4217bd0a5" translate="yes" xml:space="preserve">
          <source>You must yourself do any alignment or padding by inserting, for example, enough &lt;code&gt;&quot;x&quot;&lt;/code&gt;es while packing. There is no way for &lt;a href=&quot;#pack-TEMPLATE%2CLIST&quot;&gt;&lt;code&gt;pack&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#unpack-TEMPLATE%2CEXPR&quot;&gt;&lt;code&gt;unpack&lt;/code&gt;&lt;/a&gt; to know where characters are going to or coming from, so they handle their output and input as flat sequences of characters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="495ba80801ecf71f6944f8f06ac3f6b0ec33f568" translate="yes" xml:space="preserve">
          <source>You need a &quot;make&quot; program to build the sources. If you are using Visual C++ or the Windows SDK tools, nmake will work. Builds using the gcc need dmake.</source>
          <target state="translated">소스를 만들려면 &quot;make&quot;프로그램이 필요합니다. Visual C ++ 또는 Windows SDK 도구를 사용하는 경우 nmake가 작동합니다. gcc를 사용하는 빌드에는 dmake가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="6e03410c2453434206af384ed70ad4bb1fdfc03a" translate="yes" xml:space="preserve">
          <source>You need a &quot;make&quot; program to build the sources. If you are using Visual C++ or the Windows SDK tools, you can use nmake supplied with Visual C++ or Windows SDK. You may also use, for Visual C++ or Windows SDK, dmake or gmake instead of nmake. dmake is open source software, but is not included with Visual C++ or Windows SDK. Builds using gcc need dmake or gmake. nmake is not supported for gcc builds. Parallel building is only supported with dmake and gmake, not nmake. When using dmake it is recommended to use dmake 4.13 or newer for parallel building. Older dmakes, in parallel mode, have very high CPU usage and pound the disk/filing system with duplicate I/O calls in an aggressive polling loop.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="384c0cf5619a59f9ce19e0cd720b3f9bfb700b5a" translate="yes" xml:space="preserve">
          <source>You need a separate perl executable</source>
          <target state="translated">별도의 perl 실행 파일이 필요합니다</target>
        </trans-unit>
        <trans-unit id="aa34c474feea2ebcd51fe52bc61e21c7aa534d7c" translate="yes" xml:space="preserve">
          <source>You need an installed and working gccsdk cross compiler &lt;a href=&quot;http://gccsdk.riscos.info/&quot;&gt;http://gccsdk.riscos.info/&lt;/a&gt; and REXEN &lt;a href=&quot;http://www.cp15.org/programming/&quot;&gt;http://www.cp15.org/programming/&lt;/a&gt;</source>
          <target state="translated">설치 및 작동중인 gccsdk 크로스 컴파일러 &lt;a href=&quot;http://gccsdk.riscos.info/&quot;&gt;http://gccsdk.riscos.info/&lt;/a&gt; 및 REXEN &lt;a href=&quot;http://www.cp15.org/programming/&quot;&gt;http://www.cp15.org/programming/&lt;/a&gt; 이 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="4caefc1d4e2631b1200ec354d43fce32735ee7c7" translate="yes" xml:space="preserve">
          <source>You need at the very least AmigaOS version 2.0. Recommended is version 3.1.</source>
          <target state="translated">최소한 AmigaOS 버전 2.0이 필요합니다. 버전 3.1이 권장됩니다.</target>
        </trans-unit>
        <trans-unit id="5333f88ac5bf8fd24e224f0d8051b5fec4dfc6b5" translate="yes" xml:space="preserve">
          <source>You need the Unix emulation for AmigaOS, whose most important part is &lt;b&gt;ixemul.library&lt;/b&gt;. For a minimum setup, get the latest versions of the following packages from the Aminet archives ( &lt;a href=&quot;http://www.aminet.net/~aminet/&quot;&gt;http://www.aminet.net/~aminet/&lt;/a&gt; ):</source>
          <target state="translated">AmigaOS에 대한 Unix 에뮬레이션이 필요합니다 . 가장 중요한 부분은 &lt;b&gt;ixemul.library&lt;/b&gt; 입니다. 최소 설정을 위해서는 Aminet 아카이브 ( &lt;a href=&quot;http://www.aminet.net/~aminet/&quot;&gt;http://www.aminet.net/~aminet/&lt;/a&gt; ) 에서 다음 패키지의 최신 버전을 구 하십시오 .</target>
        </trans-unit>
        <trans-unit id="46e89c73cbc6b5dd39fd756e0f6110a1446e5be5" translate="yes" xml:space="preserve">
          <source>You need the following files to build perl (or add new modules):</source>
          <target state="translated">perl을 빌드하거나 새 모듈을 추가하려면 다음 파일이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="9f9c012bcf4380f633cf4f7379c24b96c60ecb4b" translate="yes" xml:space="preserve">
          <source>You need to add either braces or blanks to disambiguate.</source>
          <target state="translated">명확하게하려면 중괄호 또는 공백을 추가해야합니다.</target>
        </trans-unit>
        <trans-unit id="cd33ddce78ff1c7340f83b621a3b3b7072ee0d07" translate="yes" xml:space="preserve">
          <source>You need to apply the patches in</source>
          <target state="translated">패치를 적용해야합니다</target>
        </trans-unit>
        <trans-unit id="1e3349f1cb25ac13b86ae16e145a0b5decd29f3c" translate="yes" xml:space="preserve">
          <source>You need to correct all the entries which look like file paths (they currently start with &lt;code&gt;f:/&lt;/code&gt;).</source>
          <target state="translated">파일 경로처럼 보이는 모든 항목을 수정해야합니다 (현재 &lt;code&gt;f:/&lt;/code&gt; 로 시작 ).</target>
        </trans-unit>
        <trans-unit id="ac623d9d2638d8e7b4db69f0dfe7d1ff10e6b5e8" translate="yes" xml:space="preserve">
          <source>You need to create a local file or directory handle or a local function.</source>
          <target state="translated">로컬 파일 또는 디렉토리 핸들 또는 로컬 함수를 작성해야합니다.</target>
        </trans-unit>
        <trans-unit id="f1f5eb114f0c20a6807ea82566cc5f87d3a50a5b" translate="yes" xml:space="preserve">
          <source>You need to fetch the latest perl source (including developers releases). With some probability it is located in</source>
          <target state="translated">최신 펄 소스 (개발자 릴리스 포함)를 가져와야합니다. 약간의 확률로</target>
        </trans-unit>
        <trans-unit id="965f03aeeab996c747b3c012ec9e65e74625b61a" translate="yes" xml:space="preserve">
          <source>You need to give a global variable a temporary value, especially $_.</source>
          <target state="translated">전역 변수에 임시 값, 특히 $ _를 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="4566431899ec1f0737bac24e93a9db0aa49d528e" translate="yes" xml:space="preserve">
          <source>You need to have the latest &lt;b&gt;ixemul&lt;/b&gt; (Unix emulation for Amiga) from Aminet.</source>
          <target state="translated">&lt;b&gt;Aminet&lt;/b&gt; 의 최신 &lt;b&gt;ixemul&lt;/b&gt; (Amiga 용 Unix 에뮬레이션)이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="a7ac6e008f84ae7c7059b678b8182fe611763a32" translate="yes" xml:space="preserve">
          <source>You need to have the latest EMX development environment, the full GNU tool suite (gawk renamed to awk, and GNU</source>
          <target state="translated">최신 EMX 개발 환경, 전체 GNU 툴 슈트 (gawk의 이름이 awk, GNU)가 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="f0226c50fdff6c76ac2211b429b8387e73ade57a" translate="yes" xml:space="preserve">
          <source>You need to have zlib 1.2.1 or better if you want to use the &lt;code&gt;-Merge&lt;/code&gt; option with &lt;code&gt;IO::Compress::Gzip&lt;/code&gt; , &lt;code&gt;IO::Compress::Deflate&lt;/code&gt; and &lt;code&gt;IO::Compress::RawDeflate&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;IO::Compress::Gzip&lt;/code&gt; , &lt;code&gt;IO::Compress::Deflate&lt;/code&gt; 및 &lt;code&gt;IO::Compress::RawDeflate&lt;/code&gt; 와 함께 &lt;code&gt;-Merge&lt;/code&gt; 옵션 을 사용하려면 zlib 1.2.1 이상이 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="873959dbb9bde44be24f12aa34b3eef434338c60" translate="yes" xml:space="preserve">
          <source>You need to have zlib 1.2.1 or better if you want to use the &lt;code&gt;-Merge&lt;/code&gt; option with &lt;code&gt;IO::Compress::Gzip&lt;/code&gt;, &lt;code&gt;IO::Compress::Deflate&lt;/code&gt; and &lt;code&gt;IO::Compress::RawDeflate&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8fe783f272c0192721f39d883cea6a7e6d87c384" translate="yes" xml:space="preserve">
          <source>You need to indent a strictly positive number of spaces, not 0.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7d2bb828dde58ca4350b2c6d38a82848f926212" translate="yes" xml:space="preserve">
          <source>You need to make sure your script is executable, is accessible by the user CGI is running the script under (which is probably not the user account you tested it under), does not rely on any environment variables (like PATH) from the user it isn't running under, and isn't in a location where the CGI server can't find it, basically, more or less. Please see the following for more information:</source>
          <target state="translated">스크립트가 실행 가능한지, 사용자가 액세스 할 수 있는지 확인해야합니다. CGI가 아래에서 스크립트를 실행하고있을 것입니다 (아마도 테스트 한 사용자 계정이 아닐 수도 있음). 사용자의 PATH와 같은 환경 변수에 의존하지 않습니다. CGI 서버가 기본적으로 어느 정도 찾을 수없는 위치에서 실행되고 있지 않습니다. 자세한 내용은 다음을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="5378dd6faea905708bfdb72023c895700d44361d" translate="yes" xml:space="preserve">
          <source>You need to pass references to these objects. See &lt;a href=&quot;perlsub#Pass-by-Reference&quot;&gt;&quot;Pass by Reference&quot; in perlsub&lt;/a&gt; for this particular question, and &lt;a href=&quot;perlref&quot;&gt;perlref&lt;/a&gt; for information on references.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="28dffbeaeb79cbefc3a6182c3945facf9e0c58d9" translate="yes" xml:space="preserve">
          <source>You need to pass references to these objects. See &lt;a href=&quot;perlsub#Pass-by-Reference&quot;&gt;Pass by Reference in perlsub&lt;/a&gt; for this particular question, and &lt;a href=&quot;perlref&quot;&gt;perlref&lt;/a&gt; for information on references.</source>
          <target state="translated">이러한 객체에 대한 참조를 전달해야합니다. 참조 &lt;a href=&quot;perlsub#Pass-by-Reference&quot;&gt;perlsub 참조로 패스를&lt;/a&gt; 이 특정 질문에 대해, 그리고 &lt;a href=&quot;perlref&quot;&gt;perlref를&lt;/a&gt; 참조에 대한 자세한 내용은.</target>
        </trans-unit>
        <trans-unit id="f3725b76142cf0ba93578fc0f4b37b143a50c105" translate="yes" xml:space="preserve">
          <source>You need to perform the same general operations on related types of data, but with slight variations depending on the specific type of data the operations are applied to.</source>
          <target state="translated">관련 유형의 데이터에 대해 동일한 일반 작업을 수행해야하지만 작업이 적용되는 특정 데이터 유형에 따라 약간의 차이가 있습니다.</target>
        </trans-unit>
        <trans-unit id="97ad81b34d40212b78af8fc083ac0854544a24a5" translate="yes" xml:space="preserve">
          <source>You need to quote &quot;%s&quot;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="520b001573d6d14aabe35562ee4099fd076b8bd4" translate="yes" xml:space="preserve">
          <source>You need to use &lt;code&gt;sv_magicext&lt;/code&gt; to add magic to &lt;code&gt;SvREADONLY&lt;/code&gt; SVs and also to add more than one instance of the same &lt;code&gt;how&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eca7b2277d21c0c8eb2a5172b673ea24b48da4eb" translate="yes" xml:space="preserve">
          <source>You need to use &lt;code&gt;sv_magicext&lt;/code&gt; to add magic to SvREADONLY SVs and also to add more than one instance of the same 'how'.</source>
          <target state="translated">&lt;code&gt;sv_magicext&lt;/code&gt; 를 사용 하여 SvREADONLY SV에 마법을 추가하고 동일한 '방법'의 둘 이상의 인스턴스를 추가해야합니다.</target>
        </trans-unit>
        <trans-unit id="87282945868227dd2bfe22d624f87b781030217d" translate="yes" xml:space="preserve">
          <source>You never know what tools you call from within your own tool will need a context. Obtaining the context early ensures that nested tools can find the context you want them to find.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48a3262ccbefb20acd592d55306e17827a38c688" translate="yes" xml:space="preserve">
          <source>You now have better understanding of what a source filter is, and you might even have a possible use for them. If you feel like playing with source filters but need a bit of inspiration, here are some extra features you could add to the Debug filter.</source>
          <target state="translated">이제 소스 필터가 무엇인지 더 잘 이해하고 있으며이를 사용할 수도 있습니다. 소스 필터로 연주하고 싶지만 약간의 영감이 필요한 경우 디버그 필터에 추가 할 수있는 몇 가지 추가 기능이 있습니다.</target>
        </trans-unit>
        <trans-unit id="73cbac231eb90b456375cc000b5becdd4bf8f684" translate="yes" xml:space="preserve">
          <source>You probably cannot fix the thing that runs perl, but you can change how perl outputs its warnings by defining a custom warning and die functions.</source>
          <target state="translated">아마도 perl을 실행하는 것을 고칠 수는 없지만 커스텀 경고 및 다이 기능을 정의하여 perl이 경고를 출력하는 방법을 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c7c0603ac9ce1e85817396d548da858cc92fd4cc" translate="yes" xml:space="preserve">
          <source>You probably cannot mix &lt;a href=&quot;#alarm-SECONDS&quot;&gt;&lt;code&gt;alarm&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#sleep-EXPR&quot;&gt;&lt;code&gt;sleep&lt;/code&gt;&lt;/a&gt; calls, because &lt;a href=&quot;#sleep-EXPR&quot;&gt;&lt;code&gt;sleep&lt;/code&gt;&lt;/a&gt; is often implemented using &lt;a href=&quot;#alarm-SECONDS&quot;&gt;&lt;code&gt;alarm&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c42726aad22724c022f0c559e39f4d6e8477c11a" translate="yes" xml:space="preserve">
          <source>You probably cannot mix &lt;code&gt;&lt;a href=&quot;alarm&quot;&gt;alarm&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;sleep&quot;&gt;sleep&lt;/a&gt;&lt;/code&gt; calls, because &lt;code&gt;&lt;a href=&quot;sleep&quot;&gt;sleep&lt;/a&gt;&lt;/code&gt; is often implemented using &lt;code&gt;&lt;a href=&quot;alarm&quot;&gt;alarm&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;sleep&quot;&gt;sleep&lt;/a&gt;&lt;/code&gt; 은 종종 &lt;code&gt;&lt;a href=&quot;alarm&quot;&gt;alarm&lt;/a&gt;&lt;/code&gt; 을 사용하여 구현 되므로 &lt;code&gt;&lt;a href=&quot;alarm&quot;&gt;alarm&lt;/a&gt;&lt;/code&gt; 과 &lt;code&gt;&lt;a href=&quot;sleep&quot;&gt;sleep&lt;/a&gt;&lt;/code&gt; 호출을 혼합 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="15661abf22e3cef9f933847127ca80cfb4161e88" translate="yes" xml:space="preserve">
          <source>You probably cannot mix &lt;code&gt;&lt;a href=&quot;functions/alarm&quot;&gt;alarm&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/sleep&quot;&gt;sleep&lt;/a&gt;&lt;/code&gt; calls, because &lt;code&gt;&lt;a href=&quot;functions/sleep&quot;&gt;sleep&lt;/a&gt;&lt;/code&gt; is often implemented using &lt;code&gt;&lt;a href=&quot;functions/alarm&quot;&gt;alarm&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/sleep&quot;&gt;sleep&lt;/a&gt;&lt;/code&gt; 은 종종 &lt;code&gt;&lt;a href=&quot;functions/alarm&quot;&gt;alarm&lt;/a&gt;&lt;/code&gt; 을 사용하여 구현 되므로 &lt;code&gt;&lt;a href=&quot;functions/alarm&quot;&gt;alarm&lt;/a&gt;&lt;/code&gt; 과 &lt;code&gt;&lt;a href=&quot;functions/sleep&quot;&gt;sleep&lt;/a&gt;&lt;/code&gt; 호출을 혼합 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="c6ea02ffa42491538c740d65bba124e60d5ff937" translate="yes" xml:space="preserve">
          <source>You probably expect this code to print the equivalent of</source>
          <target state="translated">이 코드가</target>
        </trans-unit>
        <trans-unit id="d62ac8cab5911278724664b4481b34fb6ef41dfa" translate="yes" xml:space="preserve">
          <source>You probably meant to use &lt;code&gt;$]&lt;/code&gt; instead. &lt;code&gt;$[&lt;/code&gt; is the base for indexing arrays. &lt;code&gt;$]&lt;/code&gt; is the Perl version number in decimal.</source>
          <target state="translated">아마도 &lt;code&gt;$]&lt;/code&gt; 를 대신 사용하려고했을 것입니다 . &lt;code&gt;$[&lt;/code&gt; 는 배열 색인의 기초입니다. &lt;code&gt;$]&lt;/code&gt; 는 Perl 버전 번호 (10 진수)입니다.</target>
        </trans-unit>
        <trans-unit id="fd777891ad8556771da5ce520e6dfb0017006c11" translate="yes" xml:space="preserve">
          <source>You probably shouldn't rely upon the &lt;code&gt;&lt;a href=&quot;functions/warn&quot;&gt;warn()&lt;/a&gt;&lt;/code&gt; being podded out forever. Not all pod translators are well-behaved in this regard, and perhaps the compiler will become pickier.</source>
          <target state="translated">당신은 아마 &lt;code&gt;&lt;a href=&quot;functions/warn&quot;&gt;warn()&lt;/a&gt;&lt;/code&gt; 이 영원히 사라지는 것에 의존해서는 안됩니다 . 모든 포드 번역가가 이와 관련하여 잘 작동하는 것은 아니며 컴파일러가 더 까다로워 질 것입니다.</target>
        </trans-unit>
        <trans-unit id="fdea4fb0b549076471da0ef11cc5591c5ad20b5e" translate="yes" xml:space="preserve">
          <source>You probably shouldn't rely upon the &lt;code&gt;warn()&lt;/code&gt; being podded out forever. Not all pod translators are well-behaved in this regard, and perhaps the compiler will become pickier.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7e43d034a25f1af2139047ca7966917ab4cd1dd" translate="yes" xml:space="preserve">
          <source>You probably want to use one of the assortment of wrappers, such as &lt;code&gt;SvSetSV&lt;/code&gt; , &lt;code&gt;SvSetSV_nosteal&lt;/code&gt; , &lt;code&gt;SvSetMagicSV&lt;/code&gt; and &lt;code&gt;SvSetMagicSV_nosteal&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;SvSetSV&lt;/code&gt; , &lt;code&gt;SvSetSV_nosteal&lt;/code&gt; , &lt;code&gt;SvSetMagicSV&lt;/code&gt; 및 &lt;code&gt;SvSetMagicSV_nosteal&lt;/code&gt; 과 같은 다양한 랩퍼 중 하나를 사용 하고 싶을 것 입니다.</target>
        </trans-unit>
        <trans-unit id="26d6df5a722c4587c10d1e33caf64417a111e3b7" translate="yes" xml:space="preserve">
          <source>You probably want to use one of the assortment of wrappers, such as &lt;code&gt;SvSetSV&lt;/code&gt;, &lt;code&gt;SvSetSV_nosteal&lt;/code&gt;, &lt;code&gt;SvSetMagicSV&lt;/code&gt; and &lt;code&gt;SvSetMagicSV_nosteal&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d6ef8cdce7f3fb77e02bca3307aceacf65c4aa9" translate="yes" xml:space="preserve">
          <source>You probably wrote something like this:</source>
          <target state="translated">아마도 다음과 같이 썼을 것입니다 :</target>
        </trans-unit>
        <trans-unit id="39ad4b4dd2e75230f3579c0483b312257f0274c5" translate="yes" xml:space="preserve">
          <source>You really need GNU make to compile this. GNU make ships by default with QNX 4.23, but you can get it from quics for earlier versions.</source>
          <target state="translated">이것을 컴파일하려면 GNU make가 정말로 필요합니다. GNU는 기본적으로 QNX 4.23과 함께 제공되지만 이전 버전에서는 quic에서 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f29c66ebc5c2830e25ec34ca0ddd3f809b29ffce" translate="yes" xml:space="preserve">
          <source>You really probably want to be using &lt;a href=&quot;#my-VARLIST&quot;&gt;&lt;code&gt;my&lt;/code&gt;&lt;/a&gt; instead, because &lt;a href=&quot;#local-EXPR&quot;&gt;&lt;code&gt;local&lt;/code&gt;&lt;/a&gt; isn't what most people think of as &quot;local&quot;. See &lt;a href=&quot;perlsub#Private-Variables-via-my%28%29&quot;&gt;&quot;Private Variables via my()&quot; in perlsub&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e91eff73482d2359765ffe5506e4ead5d70a7574" translate="yes" xml:space="preserve">
          <source>You really probably want to be using &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; instead, because &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; isn't what most people think of as &quot;local&quot;. See &lt;a href=&quot;perlsub#Private-Variables-via-my()&quot;&gt;Private Variables via my() in perlsub&lt;/a&gt; for details.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; 은 대부분의 사람들이 &quot;로컬&quot;이라고 생각하지 않기 때문에 아마도 실제로 &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; 대신을 사용하고 싶을 것입니다. 자세한 내용 &lt;a href=&quot;perlsub#Private-Variables-via-my()&quot;&gt;은 perlsub에서 my ()를 통한 전용 변수를&lt;/a&gt; 참조 하십시오.</target>
        </trans-unit>
        <trans-unit id="ab88c992626b72f6894fc343016d386fe947c5ce" translate="yes" xml:space="preserve">
          <source>You really probably want to be using &lt;code&gt;&lt;a href=&quot;my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; instead, because &lt;code&gt;&lt;a href=&quot;local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; isn't what most people think of as &quot;local&quot;. See &lt;a href=&quot;../perlsub#Private-Variables-via-my()&quot;&gt;Private Variables via my() in perlsub&lt;/a&gt; for details.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; 은 대부분의 사람들이 &quot;로컬&quot;이라고 생각하지 않기 때문에 아마도 실제로 &lt;code&gt;&lt;a href=&quot;my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; 대신을 사용하고 싶을 것입니다. 자세한 내용 &lt;a href=&quot;../perlsub#Private-Variables-via-my()&quot;&gt;은 perlsub에서 my ()를 통한 전용 변수를&lt;/a&gt; 참조 하십시오.</target>
        </trans-unit>
        <trans-unit id="d15f62d6aa63d728245cd3284fc083f9f68cff93" translate="yes" xml:space="preserve">
          <source>You see, if you call pstruct by its other incybernation, c2ph, you have a code generator that translates C code into perl code! Well, structure and union declarations at least, but that's quite a bit.</source>
          <target state="translated">다른 incybernation, c2ph에 의해 pstruct를 호출하면 C 코드를 펄 코드로 변환하는 코드 생성기가 있습니다! 글쎄, 구조 및 공용체 선언은 적어도, 그러나 그것은 약간입니다.</target>
        </trans-unit>
        <trans-unit id="e40f965e1563da6a69b2b3cefacc4ba6dd9ef204" translate="yes" xml:space="preserve">
          <source>You should &lt;code&gt;use Test2::IPC;&lt;/code&gt; as early as possible in your test file. If you import this module after API initialization it will attempt to retrofit IPC onto the existing hubs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95f74aa64cd2ea580871d2847f70b2776302bedc" translate="yes" xml:space="preserve">
          <source>You should also &quot;register&quot; your op with the Perl interpreter so that it can produce sensible error and warning messages. Since it is possible to have multiple custom ops within the one &quot;logical&quot; op type &lt;code&gt;OP_CUSTOM&lt;/code&gt; , Perl uses the value of &lt;code&gt;o-&amp;gt;op_ppaddr&lt;/code&gt; to determine which custom op it is dealing with. You should create an &lt;code&gt;XOP&lt;/code&gt; structure for each ppaddr you use, set the properties of the custom op with &lt;code&gt;XopENTRY_set&lt;/code&gt; , and register the structure against the ppaddr using &lt;code&gt;Perl_custom_op_register&lt;/code&gt; . A trivial example might look like:</source>
          <target state="translated">또한 적절한 오류 및 경고 메시지를 생성 할 수 있도록 Perl 인터프리터에 op를 &quot;등록&quot;해야합니다. 하나의 &quot;논리적&quot;op 유형 &lt;code&gt;OP_CUSTOM&lt;/code&gt; 내에 여러 개의 사용자 정의 op가있을 수 있으므로 Perl은 &lt;code&gt;o-&amp;gt;op_ppaddr&lt;/code&gt; 값을 사용하여 처리중인 사용자 정의 op를 결정합니다. 당신은 만들어야합니다 &lt;code&gt;XOP&lt;/code&gt; 의 , 당신이 사용하는 각 ppaddr에 대한 구조와 사용자 정의 연산의 속성 설정 &lt;code&gt;XopENTRY_set&lt;/code&gt; 을 하고 사용 ppaddr에 대한 구조 등록 &lt;code&gt;Perl_custom_op_register&lt;/code&gt; 를 . 간단한 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a859b2e7cc53302cdc693e11c15d6ffe18891b34" translate="yes" xml:space="preserve">
          <source>You should also &quot;register&quot; your op with the Perl interpreter so that it can produce sensible error and warning messages. Since it is possible to have multiple custom ops within the one &quot;logical&quot; op type &lt;code&gt;OP_CUSTOM&lt;/code&gt;, Perl uses the value of &lt;code&gt;o-&amp;gt;op_ppaddr&lt;/code&gt; to determine which custom op it is dealing with. You should create an &lt;code&gt;XOP&lt;/code&gt; structure for each ppaddr you use, set the properties of the custom op with &lt;code&gt;XopENTRY_set&lt;/code&gt;, and register the structure against the ppaddr using &lt;code&gt;Perl_custom_op_register&lt;/code&gt;. A trivial example might look like:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8cd501f21ed6c5e9d05fc6e18329636984dc10c8" translate="yes" xml:space="preserve">
          <source>You should also check out the Frequently Asked Questions list in comp.unix.* for things like this: the answer is essentially the same. It's very system-dependent. Here's one solution that works on BSD systems:</source>
          <target state="translated">또한 comp.unix. *의 자주 묻는 질문 (FAQ) 목록에서 다음과 같은 사항을 확인해야합니다. 대답은 본질적으로 동일합니다. 매우 시스템에 따라 다릅니다. BSD 시스템에서 작동하는 솔루션은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f04dff0eea092cd0ec8988c859db7bf95d5caa53" translate="yes" xml:space="preserve">
          <source>You should also check your modules, and upgrade them if necessary. For example, HTML::Entities requires version &amp;gt;= 1.32 to function correctly, even though the changelog is silent about this.</source>
          <target state="translated">또한 모듈을 확인하고 필요한 경우 업그레이드하십시오. 예를 들어, HTML :: Entities는 changelog에 대해 자동이더라도 올바르게 작동하려면 버전&amp;gt; 1.32가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="216e237825c211374fe3090940c41c56504f6ae4" translate="yes" xml:space="preserve">
          <source>You should also have received a copy of the GNU General Public License along with this program in the file named &quot;Copying&quot;. If not, write to the Free Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA or visit their web page on the internet at &lt;a href=&quot;http://www.gnu.org/copyleft/gpl.html&quot;&gt;http://www.gnu.org/copyleft/gpl.html&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1bf271b2d5721f863cabe314c6f3ea53dab9ccef" translate="yes" xml:space="preserve">
          <source>You should also look at &lt;a href=&quot;perlfaq9&quot;&gt;perlfaq9&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;perlfaq9&quot;&gt;perlfaq9&lt;/a&gt; 도 봐야 합니다.</target>
        </trans-unit>
        <trans-unit id="a2a8e7bc27f2427aec43e373a1d93fb28c7dab24" translate="yes" xml:space="preserve">
          <source>You should also take a look at &lt;a href=&quot;perlmodstyle&quot;&gt;perlmodstyle&lt;/a&gt; for best practices in making a module.</source>
          <target state="translated">또한 모듈을 만드는 모범 사례 를 &lt;a href=&quot;perlmodstyle&quot;&gt;보려면 perlmodstyle&lt;/a&gt; 을 살펴보십시오 .</target>
        </trans-unit>
        <trans-unit id="50caca8ed03bfd57a516ccc3b6dfa215ef520713" translate="yes" xml:space="preserve">
          <source>You should also try to get feedback from people who are already familiar with the module's application domain and the CPAN naming system. Authors of similar modules, or modules with similar names, may be a good place to start, as are community sites like &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fwww.perlmonks.org&quot;&gt;Perl Monks&lt;/a&gt;.</source>
          <target state="translated">또한 모듈의 애플리케이션 도메인 및 CPAN 이름 지정 시스템에 이미 익숙한 사람들로부터 피드백을 받으십시오. &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fwww.perlmonks.org&quot;&gt;Perl Monks&lt;/a&gt; 와 같은 커뮤니티 사이트와 마찬가지로 유사한 모듈 또는 유사한 이름을 가진 모듈의 작성자를 시작하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="95145fec9529b3152d5a5f6f32c276f625174f2b" translate="yes" xml:space="preserve">
          <source>You should also try to get feedback from people who are already familiar with the module's application domain and the CPAN naming system. Authors of similar modules, or modules with similar names, may be a good place to start, as are community sites like &lt;a href=&quot;https://www.perlmonks.org&quot;&gt;Perl Monks&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6748d5917300372787fdc7a9ff0a6b3a57b1d0d9" translate="yes" xml:space="preserve">
          <source>You should always support a &lt;code&gt;HASH&lt;/code&gt; argument to &lt;code&gt;TIEHASH&lt;/code&gt; that ties the underlying cache so that the user can specify that the cache is also persistent or that it has some other interesting semantics. The example above demonstrates how to do this, as does &lt;code&gt;Memoize::Expire&lt;/code&gt; .</source>
          <target state="translated">기본 캐시를 연결하는 &lt;code&gt;TIEHASH&lt;/code&gt; 에 대한 &lt;code&gt;HASH&lt;/code&gt; 인수를 항상 지원해야 사용자가 캐시가 지속적이거나 다른 흥미로운 의미를 갖도록 지정할 수 있습니다. 위의 예는 &lt;code&gt;Memoize::Expire&lt;/code&gt; 와 같이이를 수행하는 방법을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="d1e2e0b2bc7e86a2fa76d37f5310a663f4f81bdc" translate="yes" xml:space="preserve">
          <source>You should always support a &lt;code&gt;HASH&lt;/code&gt; argument to &lt;code&gt;TIEHASH&lt;/code&gt; that ties the underlying cache so that the user can specify that the cache is also persistent or that it has some other interesting semantics. The example above demonstrates how to do this, as does &lt;code&gt;Memoize::Expire&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3be69763ec9a168e71d6a325f5feb839520bece8" translate="yes" xml:space="preserve">
          <source>You should attempt older code to fully use</source>
          <target state="translated">완전히 사용하려면 이전 코드를 시도해야합니다</target>
        </trans-unit>
        <trans-unit id="035ccc9a9d5711f4af1f69c6423f5fd457c6beb5" translate="yes" xml:space="preserve">
          <source>You should attempt to get older code to fully use</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2aa5702baea4b6cbbf8baf7ed5e04e20725d5137" translate="yes" xml:space="preserve">
          <source>You should be aware that it is unsupported, and is not claimed to be fit for any purpose. If your system allows installation of arbitrary locales, you may find the definitions useful as they are, or as a basis for the development of your own locales.</source>
          <target state="translated">지원되지 않으며 어떤 목적에도 적합하지 않다는 것을 알고 있어야합니다. 시스템에서 임의의 로케일 설치를 허용하는 경우, 정의가있는 그대로 또는 고유 한 로케일 개발의 기초로 정의를 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e3162405a76386caaa175c4a5b3c2a85402c9c86" translate="yes" xml:space="preserve">
          <source>You should be careful about creating mortal variables. Strange things can happen if you make the same value mortal within multiple contexts, or if you make a variable mortal multiple times. Thinking of &quot;Mortalization&quot; as deferred &lt;code&gt;SvREFCNT_dec&lt;/code&gt; should help to minimize such problems. For example if you are passing an SV which you</source>
          <target state="translated">필사자 변수 작성에주의해야합니다. 여러 상황에서 동일한 가치를 필멸의 상태로 만들거나 변수 필사자를 여러 번 만들면 이상한 일이 발생할 수 있습니다. &quot;Mortalization&quot;을 지연된 &lt;code&gt;SvREFCNT_dec&lt;/code&gt; 로 생각하면 이러한 문제를 최소화하는 데 도움이됩니다. 예를 들어 SV를 전달하는 경우</target>
        </trans-unit>
        <trans-unit id="9ad5df3f66f5b17aedb15ffe31f22d342f4b8c8e" translate="yes" xml:space="preserve">
          <source>You should be especially careful to remember what's being looked at when:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2612532f10e360a543e4698a0462860c195cea00" translate="yes" xml:space="preserve">
          <source>You should be using two different symbols instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f75000df91bba9bce6bbc0dce623bb898fe50b2f" translate="yes" xml:space="preserve">
          <source>You should be very careful when modifying the default values of most special variables described in this document. In most cases you want to localize these variables before changing them, since if you don't, the change may affect other modules which rely on the default values of the special variables that you have changed. This is one of the correct ways to read the whole file at once:</source>
          <target state="translated">이 문서에서 설명하는 대부분의 특수 변수의 기본값을 수정할 때 매우주의해야합니다. 대부분의 경우 이러한 변수를 변경하기 전에 현지화하려고합니다. 변경하지 않으면 변경 한 특수 변수의 기본값에 의존하는 다른 모듈에 영향을 줄 수 있습니다. 이것은 전체 파일을 한 번에 읽는 올바른 방법 중 하나입니다.</target>
        </trans-unit>
        <trans-unit id="949c1f70059f0d92507bf8500b354d7dab533cd7" translate="yes" xml:space="preserve">
          <source>You should by now have had a look at &lt;a href=&quot;perlguts&quot;&gt;perlguts&lt;/a&gt;, which tells you about Perl's internal variable types: SVs, HVs, AVs and the rest. If not, do that now.</source>
          <target state="translated">지금까지 &lt;a href=&quot;perlguts&quot;&gt;perlguts를&lt;/a&gt; 살펴 보았는데 , Perl의 내부 변수 유형 (SV, HV, AV 및 나머지)에 대해 알려줍니다. 그렇지 않다면 지금하십시오.</target>
        </trans-unit>
        <trans-unit id="8dc43c8dd65f9ea8dbe3744e02b3f2e2bf6fd033" translate="yes" xml:space="preserve">
          <source>You should have received a copy of the Artistic License with this Kit, in the file named &quot;Artistic&quot;. If not, I'll be glad to provide one.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1de8c82aa4b462c346cc4f7308a916f25f4fef57" translate="yes" xml:space="preserve">
          <source>You should have received a copy of the GNU General Public License along with this library program; it should be in the file &lt;code&gt;COPYING&lt;/code&gt; . If not, write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA</source>
          <target state="translated">이 라이브러리 프로그램과 함께 GNU General Public License의 사본을 받았어야합니다. &lt;code&gt;COPYING&lt;/code&gt; 파일에 있어야합니다 . 그렇지 않은 경우 미국 MA 02110-1301, Boston, 5 층, Franklin Street 51, Free Software Foundation, Inc.에 문의하십시오.</target>
        </trans-unit>
        <trans-unit id="89d4940a32ed3ab90e1b7165c58f90ef387f0c29" translate="yes" xml:space="preserve">
          <source>You should have received a copy of the GNU General Public License along with this library program; it should be in the file &lt;code&gt;COPYING&lt;/code&gt;. If not, write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e47e81623eb986394886e54e85f1183c3a98df4e" translate="yes" xml:space="preserve">
          <source>You should in general be leery of using functions that could potentially return lists in scalar context without explicitly stating such. This would be clearer to the casual reader:</source>
          <target state="translated">일반적으로 명시 적으로 언급하지 않고 스칼라 컨텍스트에서 잠재적으로 목록을 리턴 할 수있는 함수를 사용하는 것에 대해주의를 기울여야합니다. 이것은 일반 독자에게는 더 분명 할 것입니다.</target>
        </trans-unit>
        <trans-unit id="f07911b4c8d126039388d13cb35130da1027b105" translate="yes" xml:space="preserve">
          <source>You should make a module out of any code that you think is going to be useful to others. Anything that's likely to fill a hole in the communal library and which someone else can slot directly into their program. Any part of your code which you can isolate and extract and plug into something else is a likely candidate.</source>
          <target state="translated">다른 사람들에게 유용하다고 생각되는 코드로 모듈을 만들어야합니다. 공동 라이브러리의 구멍을 채울 가능성이 있고 다른 사람이 직접 프로그램에 슬롯을 넣을 수있는 모든 것. 코드에서 분리하고 추출하여 다른 것을 연결할 수있는 부분은 아마도 후보입니다.</target>
        </trans-unit>
        <trans-unit id="040633d0da585780031086722446751b04946152" translate="yes" xml:space="preserve">
          <source>You should neither care about nor depend on the internal representation; it might change without notice. Use &lt;b&gt;ONLY&lt;/b&gt; method calls like &lt;code&gt;$x-&amp;gt;sign();&lt;/code&gt; instead relying on the internal representation.</source>
          <target state="translated">내부 표현에 신경 쓰거나 의존해서는 안됩니다. 예고없이 변경 될 수 있습니다. &lt;code&gt;$x-&amp;gt;sign();&lt;/code&gt; 과 같은 메소드 호출 &lt;b&gt;만&lt;/b&gt; 사용하십시오 . 대신 내부 표현에 의존합니다.</target>
        </trans-unit>
        <trans-unit id="8e48507edb3519e34f20c7e3d955b48a4ed82ad2" translate="yes" xml:space="preserve">
          <source>You should normally only add directories to @INC. If you need to delete directories from @INC take care to only delete those which you added yourself or which you are certain are not needed by other modules in your script. Other modules may have added directories which they need for correct operation.</source>
          <target state="translated">일반적으로 @INC에만 디렉토리를 추가해야합니다. @INC에서 디렉토리를 삭제해야하는 경우 직접 추가했거나 스크립트의 다른 모듈에 필요하지 않은 디렉토리 만 삭제하십시오. 다른 모듈은 올바른 작동에 필요한 디렉토리를 추가했을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="693cc772a08fe2cee68cbfc24c2a6625d73c01c6" translate="yes" xml:space="preserve">
          <source>You should not depend on the internal format, all accesses must go through accessor methods. E.g. looking at $x-&amp;gt;{sign} is not a bright idea since there is no guaranty that the object in question has such a hashkey, nor is a hash underneath at all.</source>
          <target state="translated">내부 형식에 의존해서는 안되며 모든 액세스는 액세서 메소드를 거쳐야합니다. 예를 들어 $ x-&amp;gt; {sign}을 보는 것은 문제의 객체가 그러한 해시 키를 가지고 있거나 전혀 해시가 없다는 보장이 없기 때문에 밝은 생각이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="d13d5397797f2275509831750bfac02171b7d4f3" translate="yes" xml:space="preserve">
          <source>You should not depend on the internal format, all accesses must go through accessor methods. E.g. looking at $x-&amp;gt;{sign} is not a good idea since there is no guaranty that the object in question has such a hash key, nor is a hash underneath at all.</source>
          <target state="translated">내부 형식에 의존해서는 안되며 모든 액세스는 액세서 메소드를 거쳐야합니다. 예를 들어 $ x-&amp;gt; {sign}을 보는 것은 문제의 객체가 그러한 해시 키를 가지고 있지 않다는 보장이 없기 때문에 좋은 생각이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="6e8d21cc64f2bc1e9d1ef661a62db1a121e53da8" translate="yes" xml:space="preserve">
          <source>You should not even &lt;b&gt;want&lt;/b&gt; to use</source>
          <target state="translated">당신은 사용 &lt;b&gt;하고 싶지&lt;/b&gt; 않아야</target>
        </trans-unit>
        <trans-unit id="675338533405ed3338eef5ef4ee169f82f2ec7e6" translate="yes" xml:space="preserve">
          <source>You should not use perl's malloc if you are building with gcc. There are reports of core dumps, especially in the PDL module. The problem appears to go away under -DDEBUGGING, so it has been difficult to track down. Sun's compiler appears to be okay with or without perl's malloc. [XXX further investigation is needed here.]</source>
          <target state="translated">gcc로 빌드하는 경우 perl의 malloc을 사용하지 않아야합니다. 특히 PDL 모듈에서 코어 덤프에 대한 보고서가 있습니다. -DDEBUGGING에서 문제가 사라져서 추적하기가 어렵습니다. 썬의 컴파일러는 펄의 malloc이 있거나없는 것으로 보인다. [XXX 추가 조사가 필요합니다.]</target>
        </trans-unit>
        <trans-unit id="13af3135f590e4077444d490629ef8daddd658bc" translate="yes" xml:space="preserve">
          <source>You should note that, if it is necessary to store the SV (&lt;code&gt;name&lt;/code&gt; in the example above) which corresponds to the Perl subroutine so that it can be used later in the program, it not enough just to store a copy of the pointer to the SV. Say the code above had been like this:</source>
          <target state="translated">나중에 프로그램에서 사용할 수 있도록 Perl 서브 루틴에 해당하는 SV ( 위의 예에서 &lt;code&gt;name&lt;/code&gt; 를 저장해야하는 경우 포인터의 사본을 저장하는 것만으로는 충분하지 않습니다. SV. 위의 코드가 다음과 같다고 가정 해보십시오.</target>
        </trans-unit>
        <trans-unit id="be707fb5b1867bc329a5a5a540fc202148f2df94" translate="yes" xml:space="preserve">
          <source>You should now build perl and test your (merged) changes one last time (ideally run the whole test suite, but failing that at least run the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6b47aa7e3c4b13e3ddb21243f2aa9c3c7a0d993" translate="yes" xml:space="preserve">
          <source>You should now submit a Pull Request (PR) on GitHub from the new branch to blead. For more information, see the GitHub documentation at &lt;a href=&quot;https://help.github.com/en/articles/creating-a-pull-request-from-a-fork&quot;&gt;https://help.github.com/en/articles/creating-a-pull-request-from-a-fork&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d554ccba9c0cacff167113e9e842dbb2b577730c" translate="yes" xml:space="preserve">
          <source>You should only need to use this option if you want the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30d7be701b66af4a13ce23ca4f4637ef46685c93" translate="yes" xml:space="preserve">
          <source>You should probably be using lexical variables anyway, although the issue is the same here:</source>
          <target state="translated">어쨌든 어휘 변수를 사용해야 할 수도 있지만 문제는 여기에서 동일합니다.</target>
        </trans-unit>
        <trans-unit id="8df19768141a29740332079971ccdd9d5ccbe578" translate="yes" xml:space="preserve">
          <source>You should really look at &lt;a href=&quot;Test2::Suite&quot;&gt;Test2::Suite&lt;/a&gt;. This package is some very basic essential tools implemented using &lt;a href=&quot;test2&quot;&gt;Test2&lt;/a&gt;. This exists only so that &lt;a href=&quot;test2&quot;&gt;Test2&lt;/a&gt; and other tools required by &lt;a href=&quot;Test2::Suite&quot;&gt;Test2::Suite&lt;/a&gt; can be tested. This is the package &lt;a href=&quot;test2&quot;&gt;Test2&lt;/a&gt; uses to test itself.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54112594f7721aec0b526a825c8c553a794597d2" translate="yes" xml:space="preserve">
          <source>You should say</source>
          <target state="translated">당신은 말해야</target>
        </trans-unit>
        <trans-unit id="669aa98258ce9656dc2f7e8465e9a97f44e937fd" translate="yes" xml:space="preserve">
          <source>You should seldom if ever use &lt;code&gt;0644&lt;/code&gt; as argument to &lt;a href=&quot;#sysopen-FILEHANDLE%2CFILENAME%2CMODE&quot;&gt;&lt;code&gt;sysopen&lt;/code&gt;&lt;/a&gt;, because that takes away the user's option to have a more permissive umask. Better to omit it. See &lt;a href=&quot;#umask-EXPR&quot;&gt;&lt;code&gt;umask&lt;/code&gt;&lt;/a&gt; for more on this.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ae04df28b1ca8233ad4f14017b75003d4a4c0fc" translate="yes" xml:space="preserve">
          <source>You should seldom if ever use &lt;code&gt;0644&lt;/code&gt; as argument to &lt;code&gt;&lt;a href=&quot;functions/sysopen&quot;&gt;sysopen&lt;/a&gt;&lt;/code&gt;, because that takes away the user's option to have a more permissive umask. Better to omit it. See the perlfunc(1) entry on &lt;code&gt;&lt;a href=&quot;functions/umask&quot;&gt;umask&lt;/a&gt;&lt;/code&gt; for more on this.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/sysopen&quot;&gt;sysopen&lt;/a&gt;&lt;/code&gt; 의 인수로 &lt;code&gt;0644&lt;/code&gt; 를 사용하는 경우는 거의 없습니다 . 더 허용 가능한 umask를 갖기위한 사용자의 옵션을 제거하기 때문입니다. 생략하는 것이 좋습니다. 이에 대한 자세한 내용은 &lt;code&gt;&lt;a href=&quot;functions/umask&quot;&gt;umask&lt;/a&gt;&lt;/code&gt; 의 perlfunc (1) 항목을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a5da0398cef906098b3aedb900161f9013fc9dbe" translate="yes" xml:space="preserve">
          <source>You should seldom if ever use &lt;code&gt;0644&lt;/code&gt; as argument to &lt;code&gt;&lt;a href=&quot;sysopen&quot;&gt;sysopen&lt;/a&gt;&lt;/code&gt;, because that takes away the user's option to have a more permissive umask. Better to omit it. See the perlfunc(1) entry on &lt;code&gt;&lt;a href=&quot;umask&quot;&gt;umask&lt;/a&gt;&lt;/code&gt; for more on this.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;sysopen&quot;&gt;sysopen&lt;/a&gt;&lt;/code&gt; 의 인수로 &lt;code&gt;0644&lt;/code&gt; 를 사용하는 경우는 거의 없습니다 . 더 허용 가능한 umask를 갖기위한 사용자의 옵션을 제거하기 때문입니다. 생략하는 것이 좋습니다. 이에 대한 자세한 내용은 &lt;code&gt;&lt;a href=&quot;umask&quot;&gt;umask&lt;/a&gt;&lt;/code&gt; 의 perlfunc (1) 항목을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="93291955e6753d9b28d9290f1f843ab314e860d1" translate="yes" xml:space="preserve">
          <source>You should take great pains to try to pass the function the type of variable it wants, when possible. It will save you a lot of trouble in the long run.</source>
          <target state="translated">가능하면 함수에 원하는 변수 유형을 전달하기 위해 많은 노력을 기울여야합니다. 장기적으로 많은 문제를 해결합니다.</target>
        </trans-unit>
        <trans-unit id="12e9cbf7ef859529e7aa6ad559377e6f6b1073a2" translate="yes" xml:space="preserve">
          <source>You should think long and hard about why you need everything loaded at once. It's just not a scalable solution.</source>
          <target state="translated">한 번에 모든 것을로드해야하는 이유에 대해 길고 열심히 생각해야합니다. 확장 가능한 솔루션이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="60692fdbea6181558282af5a09ad1a91226b0568" translate="yes" xml:space="preserve">
          <source>You should use</source>
          <target state="translated">사용해야합니다</target>
        </trans-unit>
        <trans-unit id="6151ee9c13ae718ea297cb2924721c23869b50eb" translate="yes" xml:space="preserve">
          <source>You should use the &lt;b&gt;-T&lt;/b&gt; flag to enable taint checking (see &lt;a href=&quot;perlsec&quot;&gt;perlsec&lt;/a&gt;) even if we aren't running setuid or setgid. This is always a good idea for servers or any program run on behalf of someone else (like CGI scripts), because it lessens the chances that people from the outside will be able to compromise your system.</source>
          <target state="translated">setuid 또는 setgid를 실행하지 않는 경우에도 &lt;b&gt;-T&lt;/b&gt; 플래그를 사용하여 오염 검사 ( &lt;a href=&quot;perlsec&quot;&gt;perlsec&lt;/a&gt; 참조 ) 를 활성화 해야합니다 . 외부 사용자가 시스템을 손상시킬 수있는 가능성이 줄어들 기 때문에 서버 나 다른 프로그램 (CGI 스크립트 등)을 대신하여 실행되는 프로그램에는 항상 좋습니다.</target>
        </trans-unit>
        <trans-unit id="c6b52a2caf001c41f2fbe0900c81a2862fac3a04" translate="yes" xml:space="preserve">
          <source>You should use this</source>
          <target state="translated">이것을 사용해야합니다</target>
        </trans-unit>
        <trans-unit id="f980030e1ddd6415377ab007be132a7835310a08" translate="yes" xml:space="preserve">
          <source>You should use this option if you are using UTF-16 and others which linefeed is not $/.</source>
          <target state="translated">UTF-16 및 줄 바꿈이 $ /가 아닌 다른 항목을 사용하는 경우이 옵션을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="db384f65b44d08a41642068cf25462a07360e950" translate="yes" xml:space="preserve">
          <source>You should usually be able to ignore this and just use the module without thinking about deferring. However, special applications may require fine control over which writes are deferred, or may require that all writes be immediate. To disable the autodeferment feature, use</source>
          <target state="translated">일반적으로 이것을 무시하고 지연에 대해 생각하지 않고 모듈을 사용하면됩니다. 그러나 특수 응용 프로그램에서는 쓰기 지연을 정밀하게 제어해야하거나 모든 쓰기를 즉시 수행해야 할 수도 있습니다. 자동 지연 기능을 비활성화하려면</target>
        </trans-unit>
        <trans-unit id="962a252e8053766a043aa7e45b2c62a450a0683c" translate="yes" xml:space="preserve">
          <source>You shouldn't have to care. But you may if your Perl is before 5.14.0 or you haven't specified &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature 'unicode_strings'&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;
5.012&lt;/code&gt; (or higher) because otherwise the rules for the code points in the range 128 to 255 are different depending on whether the string they are contained within is in Unicode or not. (See &lt;a href=&quot;perlunicode#When-Unicode-Does-Not-Happen&quot;&gt;When Unicode Does Not Happen in perlunicode&lt;/a&gt;.)</source>
          <target state="translated">신경 쓸 필요는 없습니다. 하지만 당신은 할 수있다 펄은 5.14.0 전에 또는 당신은 지정하지 않은 경우 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature 'unicode_strings'&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; 5.012&lt;/code&gt; 이상을 인해 여부를 문자열에 따라 다릅니다 128 ~ 255 범위에서 코드 포인트에 대한 그렇지 않으면 규칙 그것들은 유니 코드로되어 있는지 여부에 포함되어 있습니다. &lt;a href=&quot;perlunicode#When-Unicode-Does-Not-Happen&quot;&gt;perlunicode에서 유니 코드가 발생하지 않는 경우를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="9aa9430e0cc51b74e3ef5d34b9f38ebd3c03a610" translate="yes" xml:space="preserve">
          <source>You shouldn't have to care. But you may if your Perl is before 5.14.0 or you haven't specified &lt;code&gt;use feature 'unicode_strings'&lt;/code&gt; or &lt;code&gt;use 5.012&lt;/code&gt; (or higher) because otherwise the rules for the code points in the range 128 to 255 are different depending on whether the string they are contained within is in Unicode or not. (See &lt;a href=&quot;perlunicode#When-Unicode-Does-Not-Happen&quot;&gt;&quot;When Unicode Does Not Happen&quot; in perlunicode&lt;/a&gt;.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a8856a657ecb3d97a5c46abba56a556f46cc66ed" translate="yes" xml:space="preserve">
          <source>You shouldn't need to set this variable, since File::Find should now detect such file systems on-the-fly and switch itself to using stat. This works even for parts of your file system, like a mounted CD-ROM.</source>
          <target state="translated">File :: Find는 이러한 파일 시스템을 즉시 감지하고 stat를 사용하여 자체적으로 전환하므로이 변수를 설정할 필요가 없습니다. 이것은 마운트 된 CD-ROM과 같은 파일 시스템의 일부에서도 작동합니다.</target>
        </trans-unit>
        <trans-unit id="07632dfd399f0ee08d2dcc1bc356caea0fb1fc3a" translate="yes" xml:space="preserve">
          <source>You shouldn't worry about what this format is, because conversion is automatically done when you decode or encode.</source>
          <target state="translated">디코딩 또는 인코딩시 변환이 자동으로 수행되므로이 ​​형식에 대해 걱정할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="1bf2aae490ef3108185dddeac7ace7d36d9b8359" translate="yes" xml:space="preserve">
          <source>You specified a character that has the given plainer way of writing it, and which is also portable to platforms running with different character sets.</source>
          <target state="translated">주어진 명확한 작성 방법을 가지고 있고 다른 문자 세트로 실행되는 플랫폼에 이식 가능한 문자를 지정했습니다.</target>
        </trans-unit>
        <trans-unit id="ba1446898cf703a433f10e50053c48b7c4bd65ea" translate="yes" xml:space="preserve">
          <source>You specify the parameters that will be passed into the XSUB on the line(s) after you declare the function's return value and name. Each input parameter line starts with optional whitespace, and may have an optional terminating semicolon.</source>
          <target state="translated">함수의 반환 값과 이름을 선언 한 후 행에서 XSUB로 전달 될 매개 변수를 지정합니다. 각 입력 매개 변수 행은 선택적 공백으로 시작하며 선택적 종결 세미콜론이있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5e23d741eb164f1a1d95de07ecc25c6899dd796b" translate="yes" xml:space="preserve">
          <source>You spend lots and lots of money on dedicated hardware, but this is bound to get you talked about.</source>
          <target state="translated">당신은 전용 하드웨어에 많은 돈을 소비하지만, 이것은 당신이 이야기 할 수밖에 없습니다.</target>
        </trans-unit>
        <trans-unit id="e47578a3d656799aa6fd209dfd66ed644e50edb2" translate="yes" xml:space="preserve">
          <source>You then can run the test(s) from your test suite that call &lt;a href=&quot;../builder&quot;&gt;Test::Builder&lt;/a&gt;. At this point the output of &lt;a href=&quot;../builder&quot;&gt;Test::Builder&lt;/a&gt; is safely captured by &lt;a href=&quot;tester&quot;&gt;Test::Builder::Tester&lt;/a&gt; rather than being interpreted as real test output.</source>
          <target state="translated">그런 다음 &lt;a href=&quot;../builder&quot;&gt;Test :: Builder&lt;/a&gt; 를 호출하는 테스트 스위트에서 테스트를 실행할 수 있습니다 . 이 시점에서 &lt;a href=&quot;../builder&quot;&gt;Test :: Builder&lt;/a&gt; 의 출력은 실제 테스트 출력으로 해석되지 않고 &lt;a href=&quot;tester&quot;&gt;Test :: Builder :: Tester에&lt;/a&gt; 의해 안전하게 캡처됩니다 .</target>
        </trans-unit>
        <trans-unit id="27cca9133f1312a001d7fe1a85c24e4f576073c8" translate="yes" xml:space="preserve">
          <source>You then can run the test(s) from your test suite that call &lt;a href=&quot;Test::Builder&quot;&gt;Test::Builder&lt;/a&gt;. At this point the output of &lt;a href=&quot;Test::Builder&quot;&gt;Test::Builder&lt;/a&gt; is safely captured by &lt;a href=&quot;Test::Builder::Tester&quot;&gt;Test::Builder::Tester&lt;/a&gt; rather than being interpreted as real test output.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="677380f0fc96290216b3b386e909881a38477756" translate="yes" xml:space="preserve">
          <source>You think about that, and realize that it doesn't even work right for English, as it can produce this output:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89f392c3f60b78b930a2c99b682f5745b402f97b" translate="yes" xml:space="preserve">
          <source>You tried to use a negative time argument.</source>
          <target state="translated">음의 시간 인수를 사용하려고했습니다.</target>
        </trans-unit>
        <trans-unit id="d0e63499831fb2a66fb9056cf426d7e6b0b72f22" translate="yes" xml:space="preserve">
          <source>You use an old version of GNU make. See &lt;a href=&quot;#Prerequisites&quot;&gt;&quot;Prerequisites&quot;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="215da501a4d763185822fdec5710086fea4dd9c5" translate="yes" xml:space="preserve">
          <source>You use an old version of GNU make. See &lt;a href=&quot;#Prerequisites&quot;&gt;Prerequisites&lt;/a&gt;.</source>
          <target state="translated">이전 버전의 GNU make를 사용하고 있습니다. &lt;a href=&quot;#Prerequisites&quot;&gt;전제 조건을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="220275358a49875c3abbea24e2340553d9cb4444" translate="yes" xml:space="preserve">
          <source>You use the &lt;code&gt;\G&lt;/code&gt; anchor to start the next match on the same string where the last match left off. The regular expression engine cannot skip over any characters to find the next match with this anchor, so &lt;code&gt;\G&lt;/code&gt; is similar to the beginning of string anchor, &lt;code&gt;^&lt;/code&gt;. The &lt;code&gt;\G&lt;/code&gt; anchor is typically used with the &lt;code&gt;g&lt;/code&gt; flag. It uses the value of &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos()&lt;/a&gt;&lt;/code&gt; as the position to start the next match. As the match operator makes successive matches, it updates &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos()&lt;/a&gt;&lt;/code&gt; with the position of the next character past the last match (or the first character of the next match, depending on how you like to look at it). Each string has its own &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos()&lt;/a&gt;&lt;/code&gt; value.</source>
          <target state="translated">&lt;code&gt;\G&lt;/code&gt; 앵커를 사용하여 마지막 일치가 중단 된 동일한 문자열에서 다음 일치를 시작합니다. 정규식 엔진은이 앵커와 일치하는 다음 문자를 찾기 위해 문자를 건너 뛸 수 없으므로 &lt;code&gt;\G&lt;/code&gt; 는 문자열 앵커의 시작 인 &lt;code&gt;^&lt;/code&gt; 와 유사합니다 . &lt;code&gt;\G&lt;/code&gt; 앵커는 일반적으로 사용되는 &lt;code&gt;g&lt;/code&gt; 의 플래그. 다음 일치를 시작하는 위치로 &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos()&lt;/a&gt;&lt;/code&gt; 값을 사용합니다 . 일치 연산자는 연속 일치를 수행하므로 마지막 일치 이후의 다음 문자 위치 (또는 원하는 모양에 따라 다음 일치의 첫 번째 문자 &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos()&lt;/a&gt;&lt;/code&gt; 로 pos () 를 업데이트합니다 . 각 문자열에는 자체 &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos()&lt;/a&gt;&lt;/code&gt; 값이 있습니다.</target>
        </trans-unit>
        <trans-unit id="1e5946dcfcf3479db4ae2e5695fe6c76f97743a7" translate="yes" xml:space="preserve">
          <source>You use the &lt;code&gt;\G&lt;/code&gt; anchor to start the next match on the same string where the last match left off. The regular expression engine cannot skip over any characters to find the next match with this anchor, so &lt;code&gt;\G&lt;/code&gt; is similar to the beginning of string anchor, &lt;code&gt;^&lt;/code&gt;. The &lt;code&gt;\G&lt;/code&gt; anchor is typically used with the &lt;code&gt;g&lt;/code&gt; modifier. It uses the value of &lt;code&gt;pos()&lt;/code&gt; as the position to start the next match. As the match operator makes successive matches, it updates &lt;code&gt;pos()&lt;/code&gt; with the position of the next character past the last match (or the first character of the next match, depending on how you like to look at it). Each string has its own &lt;code&gt;pos()&lt;/code&gt; value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc28690a1164ffed63384fc9d48573f0201b1c8c" translate="yes" xml:space="preserve">
          <source>You use the utime() function documented in &lt;a href=&quot;functions/utime&quot;&gt;utime&lt;/a&gt;. By way of example, here's a little program that copies the read and write times from its first argument to all the rest of them.</source>
          <target state="translated">utime에 문서화 된 &lt;a href=&quot;functions/utime&quot;&gt;utime&lt;/a&gt; () 함수를 사용합니다 . 예를 들어, 첫 번째 인수에서 나머지 모든 인수로 읽기 및 쓰기 시간을 복사하는 작은 프로그램이 있습니다.</target>
        </trans-unit>
        <trans-unit id="9d5d257c0d5834299b68e1d80c48e829b8bcc94a" translate="yes" xml:space="preserve">
          <source>You use the utime() function documented in &lt;a href=&quot;perlfunc#utime&quot;&gt;&quot;utime&quot; in perlfunc&lt;/a&gt;. By way of example, here's a little program that copies the read and write times from its first argument to all the rest of them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6636b861a3b2aa1c111b3f0b60ae946532727186" translate="yes" xml:space="preserve">
          <source>You usually can use the value of &lt;code&gt;$^X&lt;/code&gt; to re-invoke an independent copy of the same perl that is currently running, e.g.,</source>
          <target state="translated">일반적으로 &lt;code&gt;$^X&lt;/code&gt; 값을 사용하여 현재 실행중인 동일한 perl의 독립 사본을 다시 호출 할 수 있습니다 ( 예 :</target>
        </trans-unit>
        <trans-unit id="aa6e6cfea08fbea7a5de694a45b0570deb9eda14" translate="yes" xml:space="preserve">
          <source>You usually can't. Memory allocated to lexicals (i.e. my() variables) cannot be reclaimed or reused even if they go out of scope. It is reserved in case the variables come back into scope. Memory allocated to global variables can be reused (within your program) by using undef() and/or delete().</source>
          <target state="translated">당신은 보통 할 수 없습니다. 어휘에 할당 된 메모리 (예 : my () 변수)는 범위를 벗어난 경우에도 회수하거나 재사용 할 수 없습니다. 변수가 다시 범위로 돌아 오면 예약됩니다. 전역 변수에 할당 된 메모리는 undef () 및 / 또는 delete ()를 사용하여 프로그램 내에서 재사용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="654d5925759821a41f7b319f6f5acce1580b7e6a" translate="yes" xml:space="preserve">
          <source>You want to temporarily change just one element of an array or hash.</source>
          <target state="translated">배열 또는 해시의 한 요소 만 임시로 변경하려고합니다.</target>
        </trans-unit>
        <trans-unit id="d06ad7bf53cef6bd6922e06d9d929dd05f8dbea0" translate="yes" xml:space="preserve">
          <source>You will almost certainly be better off using the &lt;code&gt;PL_FILES&lt;/code&gt; system, instead. See above, or the &lt;a href=&quot;ExtUtils::MakeMaker::FAQ&quot;&gt;ExtUtils::MakeMaker::FAQ&lt;/a&gt; entry.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ba6881210a4041e425c0b40054f89e605a3c752" translate="yes" xml:space="preserve">
          <source>You will also need to be able to connect over the Internet to the public key servers, like pgp.mit.edu, and their port 11731 (the HKP protocol).</source>
          <target state="translated">또한 인터넷을 통해 pgp.mit.edu와 같은 공개 키 서버 및 해당 포트 11731 (HKP 프로토콜)에 연결할 수 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="c62030728cb5bac5bc525932491c14ac0a7adf6d" translate="yes" xml:space="preserve">
          <source>You will also need to download the &quot;Platform SDK&quot; (the &quot;Core SDK&quot; and &quot;MDAC SDK&quot; components are required) for header files, libraries and rc.exe, and &quot;.NET Framework SDK&quot; for more libraries and nmake.exe. Note that the latter (which also includes the free compiler and linker) requires the &quot;.NET Framework Redistributable&quot; to be installed first. This can be downloaded and installed separately, but is included in the &quot;Visual C++ Toolkit 2003&quot; anyway.</source>
          <target state="translated">또한 헤더 파일, 라이브러리 및 rc.exe의 경우 &quot;Platform SDK&quot;( &quot;Core SDK&quot;및 &quot;MDAC SDK&quot;구성 요소가 필요함) 및 추가 라이브러리 및 nmake.exe의 경우 &quot;.NET Framework SDK&quot;를 다운로드해야합니다. . 후자 (무료 컴파일러 및 링커 포함)는 &quot;.NET Framework 재배포 가능 파일&quot;을 먼저 설치해야합니다. 별도로 다운로드하여 설치할 수 있지만 &quot;Visual C ++ Toolkit 2003&quot;에는 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="356f5d0daa70748f28cbf7166d4f341295254619" translate="yes" xml:space="preserve">
          <source>You will also need to download the &quot;Windows SDK&quot; (the &quot;Core SDK&quot; and &quot;MDAC SDK&quot; components are required) for more header files and libraries.</source>
          <target state="translated">더 많은 헤더 파일 및 라이브러리를 보려면 &quot;Windows SDK&quot;( &quot;Core SDK&quot;및 &quot;MDAC SDK&quot;구성 요소가 필요함)를 다운로드해야합니다.</target>
        </trans-unit>
        <trans-unit id="a1a5cfadaa899360662110efdf3739aae4dbc6c1" translate="yes" xml:space="preserve">
          <source>You will encounter this particular error message when you have the &lt;code&gt;strict 'subs'&lt;/code&gt; pragma (or the full strict pragma) in your script. Consider this script:</source>
          <target state="translated">스크립트에 엄격한 &lt;code&gt;strict 'subs'&lt;/code&gt; subs'pragma (또는 전체 엄격한 pragma)가 있으면 이 특정 오류 메시지가 표시됩니다 . 이 스크립트를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="23e29e8947be99b87040c3c4a0668f86aaf880a4" translate="yes" xml:space="preserve">
          <source>You will find brief info on &lt;code&gt;EUC-CN&lt;/code&gt;, &lt;code&gt;GBK&lt;/code&gt; and mostly on &lt;code&gt;GB 18030&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d527eca4336857f6af5af5d0a105cad653a71a0" translate="yes" xml:space="preserve">
          <source>You will find this behavior is slightly different from that of &lt;a href=&quot;perlvar#%25SIG&quot;&gt;&lt;code&gt;$SIG{__DIE__}&lt;/code&gt;&lt;/a&gt; handlers (which don't suppress the error text, but can instead call &lt;a href=&quot;#die-LIST&quot;&gt;&lt;code&gt;die&lt;/code&gt;&lt;/a&gt; again to change it).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ef82421bf1d6104efddfdc8565b14c0ddc86aec" translate="yes" xml:space="preserve">
          <source>You will find this behavior is slightly different from that of &lt;code&gt;$SIG{__DIE__}&lt;/code&gt; handlers (which don't suppress the error text, but can instead call &lt;code&gt;&lt;a href=&quot;die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; again to change it).</source>
          <target state="translated">이 동작은 &lt;code&gt;$SIG{__DIE__}&lt;/code&gt; 핸들러의 동작과 약간 다릅니다 (에러 텍스트를 억제하지 않고 대신 &lt;code&gt;&lt;a href=&quot;die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; 를 다시 호출 하여 변경할 수 있음).</target>
        </trans-unit>
        <trans-unit id="7d85e118af6c81732006143a60990cead4fa03d5" translate="yes" xml:space="preserve">
          <source>You will find this behavior is slightly different from that of &lt;code&gt;$SIG{__DIE__}&lt;/code&gt; handlers (which don't suppress the error text, but can instead call &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; again to change it).</source>
          <target state="translated">이 동작은 &lt;code&gt;$SIG{__DIE__}&lt;/code&gt; 핸들러의 동작과 약간 다릅니다 (에러 텍스트를 억제하지 않고 대신 &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; 를 다시 호출 하여 변경할 수 있음).</target>
        </trans-unit>
        <trans-unit id="c01bddfdbad27a7674a351ac148e02cb61a266a6" translate="yes" xml:space="preserve">
          <source>You will get this error message when one of the parameters in the &lt;code&gt;&lt;a href=&quot;functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; call is wrong. Unfortunately there are quite a few parameters to get wrong, so it can be difficult to figure out which one it is.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; 호출 의 매개 변수 중 하나 가 잘못 되면이 오류 메시지가 표시됩니다 . 불행히도 잘못된 매개 변수는 매우 많으므로 어느 매개 변수인지 파악하기가 어려울 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6f39ce5468b191fe767e35548ddecfe66b13656d" translate="yes" xml:space="preserve">
          <source>You will get this error message when one of the parameters in the &lt;code&gt;tie&lt;/code&gt; call is wrong. Unfortunately there are quite a few parameters to get wrong, so it can be difficult to figure out which one it is.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b306755ccc7dd24d9d304eb11d95322f9c7d1c36" translate="yes" xml:space="preserve">
          <source>You will have to make sure that CCTYPE is set correctly and that CCHOME points to wherever you installed your compiler.</source>
          <target state="translated">CCTYPE이 올바르게 설정되어 있고 CCHOME이 컴파일러를 설치 한 곳을 가리키는 지 확인해야합니다.</target>
        </trans-unit>
        <trans-unit id="5a37a6f06ca5d5f038a38f2ddd94e62c35c0fb8e" translate="yes" xml:space="preserve">
          <source>You will have to make sure that CCTYPE is set correctly and that CCHOME points to wherever you installed your compiler. For GCC this should be the directory that contains the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8d67b6a7548006b180c9c0aa7f1777391e8e3f6" translate="yes" xml:space="preserve">
          <source>You will need a copy of Git for your computer. You can fetch a copy of the repository using the git protocol:</source>
          <target state="translated">컴퓨터에 Git 사본이 필요합니다. git 프로토콜을 사용하여 저장소 사본을 가져올 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7a0e1442c7d674a64133a4ac5cbad0b8f84016fe" translate="yes" xml:space="preserve">
          <source>You will need perl version 5.005_03 or newer.</source>
          <target state="translated">펄 버전 5.005_03 이상이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="c20642cf215c3811e3976c0a074a0bc8e167607f" translate="yes" xml:space="preserve">
          <source>You will need the packages mentioned in</source>
          <target state="translated">에 언급 된 패키지가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="125a7a338622da6411e41d9bf9ce7dc1495ae8ff" translate="yes" xml:space="preserve">
          <source>You will need to have Module::Signature installed, which in turn requires that you have at least one of Crypt::OpenPGP module or the command-line</source>
          <target state="translated">Module :: Signature가 설치되어 있어야하며 Crypt :: OpenPGP 모듈 또는 명령 줄 중 하나 이상이 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="26225667638a5ef1fac02d60146f2f3c0e15d299" translate="yes" xml:space="preserve">
          <source>You will need to open every other filehandle on your own. Although there are many variants, the most common way to call Perl's open() function is with three arguments and one return value:</source>
          <target state="translated">다른 모든 파일 핸들을 직접 열어야합니다. 많은 변형이 있지만 Perl의 open () 함수를 호출하는 가장 일반적인 방법은 세 개의 인수와 하나의 반환 값을 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="e7fe6fd13dad565a05157034d79dc2c0ed04e368" translate="yes" xml:space="preserve">
          <source>You will probably find these modifiers even more useful if you have to deal with big- or little-endian C structures. Be sure to read &lt;a href=&quot;#Packing-and-Unpacking-C-Structures&quot;&gt;&quot;Packing and Unpacking C Structures&quot;&lt;/a&gt; for more on that.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ced186b3bff5ac2b886750a50b53e155abe57dbc" translate="yes" xml:space="preserve">
          <source>You will probably find these modifiers even more useful if you have to deal with big- or little-endian C structures. Be sure to read &lt;a href=&quot;#Packing-and-Unpacking-C-Structures&quot;&gt;Packing and Unpacking C Structures&lt;/a&gt; for more on that.</source>
          <target state="translated">빅 엔디안 또는 리틀 엔디안 C 구조를 처리해야하는 경우 이러한 수정자가 더 유용 할 것입니다. 이에 대한 자세한 내용은 &lt;a href=&quot;#Packing-and-Unpacking-C-Structures&quot;&gt;포장 및 포장 풀기 C 구조&lt;/a&gt; 를 읽으십시오 .</target>
        </trans-unit>
        <trans-unit id="299bf5b3f1c12a5c613500fd1bf200a8e448ae9f" translate="yes" xml:space="preserve">
          <source>You will see a message about errors while extracting</source>
          <target state="translated">추출하는 동안 오류에 대한 메시지가 표시됩니다</target>
        </trans-unit>
        <trans-unit id="5094570ece83ba87b116e497a48639d59ad16c42" translate="yes" xml:space="preserve">
          <source>You will see your commits being re-applied, and you will then be able to push safely. More information about rebasing can be found in the documentation for the git-rebase(1) command.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4ae5109d0174e4b426288bcd1b8e77508718bce" translate="yes" xml:space="preserve">
          <source>You will sometimes see older books or documentation mention &quot;blessing a reference&quot; or describe an object as a &quot;blessed reference&quot;, but this is incorrect. It isn't the reference that is blessed as an object; it's the thing the reference refers to (i.e. the referent).</source>
          <target state="translated">오래된 책이나 문서에 &quot;참조 축복&quot;이라는 언급이 있거나 대상을 &quot;축복 참조&quot;로 묘사하는 경우가 있지만 이는 잘못된 것입니다. 그것은 대상으로서 축복받은 참조가 아닙니다. 참조가 참조하는 것 (즉, 참조 자)입니다.</target>
        </trans-unit>
        <trans-unit id="b76bd931ca4d3ee61d00134eaf02261405743feb" translate="yes" xml:space="preserve">
          <source>You will usually get this message if you are working with UTF-8 data and want to read/write it from/to a Berkeley DB database file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3ffa4e5392f74c061811f37be769a0d8e66a909" translate="yes" xml:space="preserve">
          <source>You wonder how you'll get gettext to handle this; to accommodate the ways Arabic, Chinese, and Italian deal with numbers in just these few very simple phrases, you need to write code that will ask gettext for different queries depending on whether the numerical values in question are 1, 2, more than 2, or in some cases 0, and you still haven't figured out the problem with the different word order in Chinese.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e797714a16ef1ab3d51adb0398a2351cdb2d4869" translate="yes" xml:space="preserve">
          <source>You would do</source>
          <target state="translated">당신은 할 것</target>
        </trans-unit>
        <trans-unit id="6a39b437275322e4ded1326f66b7e094ff120686" translate="yes" xml:space="preserve">
          <source>You would do well to understand that the TIEARRAY and TIEHASH interfaces are mere sugar to invoke some perl method calls while using the uniform hash and array syntax. The use of this sugar imposes some overhead (typically about two to four extra opcodes per FETCH/STORE operation, in addition to the creation of all the mortal variables required to invoke the methods). This overhead will be comparatively small if the TIE methods are themselves substantial, but if they are only a few statements long, the overhead will not be insignificant.</source>
          <target state="translated">TIEARRAY 및 TIEHASH 인터페이스는 균일 한 해시 및 배열 구문을 사용하는 동안 일부 perl 메소드 호출을 호출하기위한 단순한 설탕이라는 것을 이해해야합니다. 이 설탕을 사용하면 약간의 오버 헤드가 발생합니다 (일반적으로 FETCH / STORE 작업 당 약 2 ~ 4 개의 추가 opcode가 있으며 메소드를 호출하는 데 필요한 모든 필사자 변수 생성). TIE 방법 자체가 실질적인 경우이 오버 헤드는 상대적으로 작을 것입니다. 그러나 이들이 단지 몇 개의 진술 일 경우 오버 헤드는 중요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d4ff63e38580a86bc4e960e615187745a0cf46e6" translate="yes" xml:space="preserve">
          <source>You would tell &lt;code&gt;Memoize&lt;/code&gt; to use this normalizer this way:</source>
          <target state="translated">당신은 말할 것 &lt;code&gt;Memoize&lt;/code&gt; 을 이런 식으로 노멀이 사용하는 :</target>
        </trans-unit>
        <trans-unit id="26052a9c2b555b8c00fe517ca714ea40b56ea28f" translate="yes" xml:space="preserve">
          <source>You would think passing files to an XS is difficult, with all the typeglobs and stuff. Well, it isn't.</source>
          <target state="translated">모든 타입 글로브와 함께 XS로 파일을 전달하는 것이 어렵다고 생각할 것입니다. 글쎄요.</target>
        </trans-unit>
        <trans-unit id="0f48ec8747685a1be6881def5b864ffbb8151d2b" translate="yes" xml:space="preserve">
          <source>You would use the following &lt;code&gt;test&lt;/code&gt; directive:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ae49780570ada5605ad7b4d5f17a41e10f03f26" translate="yes" xml:space="preserve">
          <source>You wrote something like</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97f37569bdb5c4ba52eeb6c3306265613993e5ff" translate="yes" xml:space="preserve">
          <source>You'll also find that &lt;code&gt;foreach&lt;/code&gt; loop used to create a topicalizer and a switch:</source>
          <target state="translated">또한 &lt;code&gt;foreach&lt;/code&gt; 루프는 토픽 라이저와 스위치를 만드는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="5e9bf36ecbd53fc8e26acf6fb90205c1b5356d3c" translate="yes" xml:space="preserve">
          <source>You'll also have to choose the appropriate library directory (</source>
          <target state="translated">또한 적절한 라이브러리 디렉토리를 선택해야합니다 (</target>
        </trans-unit>
        <trans-unit id="d14f9a4e84e4a65a6fcadc471d3775e2d2026c66" translate="yes" xml:space="preserve">
          <source>You'll also need to add the following code to the top of the .xs file, just after the include of &quot;XSUB.h&quot;:</source>
          <target state="translated">또한 &quot;XSUB.h&quot;가 포함 된 직후 .xs 파일의 맨 위에 다음 코드를 추가해야합니다.</target>
        </trans-unit>
        <trans-unit id="067d0f39aaa002449de130921826b00edd6e52d4" translate="yes" xml:space="preserve">
          <source>You'll also see code that does this without a temporary variable, as in</source>
          <target state="translated">다음과 같이 임시 변수 없이이 작업을 수행하는 코드도 볼 수 있습니다</target>
        </trans-unit>
        <trans-unit id="e76c883ffb7e9e13e48b98bafcbb6fa1aa675b80" translate="yes" xml:space="preserve">
          <source>You'll be in trouble. Those should (in 99.8% of the cases) be the simpler and more direct:</source>
          <target state="translated">당신은 곤경에 처할 것입니다. 99.8 %의 경우 더 단순하고 직접적이어야합니다.</target>
        </trans-unit>
        <trans-unit id="f885bd4b3bb53aff3bed3dec0b066248d1576a12" translate="yes" xml:space="preserve">
          <source>You'll have to catch the SIGCHLD signal, and possibly SIGPIPE too. SIGCHLD is sent when the backgrounded process finishes. SIGPIPE is sent when you write to a filehandle whose child process has closed (an untrapped SIGPIPE can cause your program to silently die). This is not an issue with &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system(&quot;cmd&amp;amp;&quot;)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">SIGCHLD 신호를 포착하고 SIGPIPE도 포착해야합니다. 백그라운드 프로세스가 완료되면 SIGCHLD가 전송됩니다. 하위 프로세스가 닫힌 파일 핸들에 쓸 때 SIGPIPE가 전송됩니다 (트랩되지 않은 SIGPIPE로 인해 프로그램이 자동으로 종료 될 수 있음). &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system(&quot;cmd&amp;amp;&quot;)&lt;/a&gt;&lt;/code&gt; 의 문제는 아닙니다 .</target>
        </trans-unit>
        <trans-unit id="2cab58b27e2de2ea6f8506a9492db28f36b0db46" translate="yes" xml:space="preserve">
          <source>You'll have to catch the SIGCHLD signal, and possibly SIGPIPE too. SIGCHLD is sent when the backgrounded process finishes. SIGPIPE is sent when you write to a filehandle whose child process has closed (an untrapped SIGPIPE can cause your program to silently die). This is not an issue with &lt;code&gt;system(&quot;cmd&amp;amp;&quot;)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c26c7e5ed49de9efc0c0dba307a9def27936a34" translate="yes" xml:space="preserve">
          <source>You'll have to choose the appropriate compiler (</source>
          <target state="translated">적절한 컴파일러를 선택해야합니다 (</target>
        </trans-unit>
        <trans-unit id="e62d384e427e6ef82a853693fc0380e3a4a6bcdd" translate="yes" xml:space="preserve">
          <source>You'll know your submission has been processed when you receive an email from our ticket tracking system. This email will give you a ticket number. Once your patch has made it to the ticket tracking system, it will also be sent to the perl5-porters@perl.org list.</source>
          <target state="translated">티켓 추적 시스템에서 이메일을 받으면 제출이 처리되었음을 알 수 있습니다. 이 이메일은 티켓 번호를 알려줄 것입니다. 패치가 티켓 추적 시스템에 패치되면 perl5-porters@perl.org 목록으로 보내집니다.</target>
        </trans-unit>
        <trans-unit id="feea2270863ca6e9573aba26122b77d4eeb6b2e7" translate="yes" xml:space="preserve">
          <source>You'll need the &lt;code&gt;nmake&lt;/code&gt; utility, available at &lt;a href=&quot;http://download.microsoft.com/download/vc15/Patch/1.52/W95/EN-US/nmake15.exe&quot;&gt;http://download.microsoft.com/download/vc15/Patch/1.52/W95/EN-US/nmake15.exe&lt;/a&gt; or dmake, available on CPAN. &lt;a href=&quot;http://search.cpan.org/dist/dmake/&quot;&gt;http://search.cpan.org/dist/dmake/&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;http://download.microsoft.com/download/vc15/Patch/1.52/W95/EN-US/nmake15.exe&quot;&gt;http://download.microsoft.com/download/vc15/Patch/1.52/W95/EN-US/nmake15.exe에&lt;/a&gt; 있는 &lt;code&gt;nmake&lt;/code&gt; 유틸리티 또는 CPAN에있는 dmake 가 필요합니다 . &lt;a href=&quot;http://search.cpan.org/dist/dmake/&quot;&gt;http://search.cpan.org/dist/dmake/&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d5c934ac89d7dfe4684c6e54f3c503e7b13b2e6d" translate="yes" xml:space="preserve">
          <source>You'll need the &lt;code&gt;nmake&lt;/code&gt; utility, available at &lt;a href=&quot;http://download.microsoft.com/download/vc15/Patch/1.52/W95/EN-US/nmake15.exe&quot;&gt;http://download.microsoft.com/download/vc15/Patch/1.52/W95/EN-US/nmake15.exe&lt;/a&gt; or dmake, available on CPAN. &lt;a href=&quot;https://metacpan.org/release/dmake&quot;&gt;https://metacpan.org/release/dmake&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d98bbda9e4101a6a3cc3bbb0d325b9faa857f4a3" translate="yes" xml:space="preserve">
          <source>You'll want to do that in your Perl source tree so the debugger can read the source code. You should see the copyright message, followed by the prompt.</source>
          <target state="translated">디버거가 소스 코드를 읽을 수 있도록 Perl 소스 트리에서이를 수행하려고합니다. 저작권 메시지가 표시되고 프롬프트가 나타납니다.</target>
        </trans-unit>
        <trans-unit id="43eea0417aae56c41dd79afb85423b61a36ecf9b" translate="yes" xml:space="preserve">
          <source>You're confusing the purpose of &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system()&lt;/a&gt;&lt;/code&gt; and backticks (``). &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system()&lt;/a&gt;&lt;/code&gt; runs a command and returns exit status information (as a 16 bit value: the low 7 bits are the signal the process died from, if any, and the high 8 bits are the actual exit value). Backticks (``) run a command and return what it sent to STDOUT.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system()&lt;/a&gt;&lt;/code&gt; 및 backticks (``) 의 목적을 혼동하고 있습니다 . &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system()&lt;/a&gt;&lt;/code&gt; 은 명령을 실행하고 종료 상태 정보를 16 비트 값으로 리턴합니다. 하위 7 비트는 프로세스가 종료 된 신호이고 상위 8 비트는 실제 종료 값입니다. 백틱 (``)은 명령을 실행하고 STDOUT에 보낸 내용을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="08b0cf3cad789cb4d3af9f9bb75436a6878af698" translate="yes" xml:space="preserve">
          <source>You're confusing the purpose of &lt;code&gt;system()&lt;/code&gt; and backticks (``). &lt;code&gt;system()&lt;/code&gt; runs a command and returns exit status information (as a 16 bit value: the low 7 bits are the signal the process died from, if any, and the high 8 bits are the actual exit value). Backticks (``) run a command and return what it sent to STDOUT.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c524955aca90f8362890a62830c6184582bf776" translate="yes" xml:space="preserve">
          <source>You're encouraged to create self-tests for your module to ensure it's working as intended on the myriad platforms Perl supports; if you upload your module to CPAN, a host of testers will build your module and send you the results of the tests. Again, &lt;code&gt;module-starter&lt;/code&gt; and &lt;code&gt;h2xs&lt;/code&gt; provide a test framework which you can extend - you should do something more than just checking your module will compile. &lt;a href=&quot;Test::Simple&quot;&gt;Test::Simple&lt;/a&gt; and &lt;a href=&quot;Test::More&quot;&gt;Test::More&lt;/a&gt; are good places to start when writing a test suite.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0067a9abf52f5d5adc52730de693ce9354a17edf" translate="yes" xml:space="preserve">
          <source>You're encouraged to create self-tests for your module to ensure it's working as intended on the myriad platforms Perl supports; if you upload your module to CPAN, a host of testers will build your module and send you the results of the tests. Again, &lt;code&gt;module-starter&lt;/code&gt; and &lt;code&gt;h2xs&lt;/code&gt; provide a test framework which you can extend - you should do something more than just checking your module will compile. &lt;a href=&quot;test/simple&quot;&gt;Test::Simple&lt;/a&gt; and &lt;a href=&quot;test/more&quot;&gt;Test::More&lt;/a&gt; are good places to start when writing a test suite.</source>
          <target state="translated">Perl이 지원하는 수많은 플랫폼에서 의도 한대로 작동하는지 확인하기 위해 모듈에 대한 자체 테스트를 작성하는 것이 좋습니다. CPAN에 모듈을 업로드하면 여러 테스터가 모듈을 빌드하고 테스트 결과를 보냅니다. 다시 한 번 &lt;code&gt;module-starter&lt;/code&gt; 와 &lt;code&gt;h2xs&lt;/code&gt; 는 확장 할 수있는 테스트 프레임 워크를 제공합니다. 모듈이 컴파일되는지 확인하는 것 이상의 작업을 수행해야합니다. &lt;a href=&quot;test/simple&quot;&gt;Test :: Simple&lt;/a&gt; 및 &lt;a href=&quot;test/more&quot;&gt;Test :: Test&lt;/a&gt; Suite를 작성할 때 시작하기에 좋은 곳이 더 있습니다.</target>
        </trans-unit>
        <trans-unit id="1465c23d6a9abbc69d7c02001d0a261855c5206d" translate="yes" xml:space="preserve">
          <source>You're probably trying to convert a string to a number, which Perl only converts as a decimal number. When Perl converts a string to a number, it ignores leading spaces and zeroes, then assumes the rest of the digits are in base 10:</source>
          <target state="translated">문자열을 숫자로 변환하려고 할 것입니다. Perl은 십진수로만 변환합니다. Perl은 문자열을 숫자로 변환 할 때 선행 공백과 0을 무시하고 나머지 숫자는 10 진법으로 가정합니다.</target>
        </trans-unit>
        <trans-unit id="f32dee0623a34d25e555f7bd9fe977163f048dfb" translate="yes" xml:space="preserve">
          <source>You're still out of luck if you need to keep track of decaying protons though.</source>
          <target state="translated">쇠퇴하는 양성자를 추적해야 할 경우 여전히 운이 좋지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4522acbd81c14b3349dda685727b4174a91c46c1" translate="yes" xml:space="preserve">
          <source>You're unlikely to ever need to construct an object of this class for yourself, but if you want to, call &lt;code&gt;Pod::Simple::PullParserEndToken-&amp;gt;new( &lt;i&gt;tagname&lt;/i&gt; )&lt;/code&gt;</source>
          <target state="translated">이 클래스의 객체를 직접 만들 필요는 없지만 &lt;code&gt;Pod::Simple::PullParserEndToken-&amp;gt;new( &lt;i&gt;tagname&lt;/i&gt; )&lt;/code&gt; &lt;i&gt;tagname&lt;/i&gt; )을 호출하십시오.&lt;i&gt;&lt;/i&gt;</target>
        </trans-unit>
        <trans-unit id="13c2c796fe95a445a68ec254f6e70e50cbdb3db7" translate="yes" xml:space="preserve">
          <source>You're unlikely to ever need to construct an object of this class for yourself, but if you want to, call &lt;code&gt;Pod::Simple::PullParserStartToken-&amp;gt;new( &lt;i&gt;tagname&lt;/i&gt;, &lt;i&gt;attrhash&lt;/i&gt; )&lt;/code&gt;</source>
          <target state="translated">이 클래스의 객체를 직접 만들 필요는 없지만 원하는 경우 &lt;code&gt;Pod::Simple::PullParserStartToken-&amp;gt;new( &lt;i&gt;tagname&lt;/i&gt;, &lt;i&gt;attrhash&lt;/i&gt; )&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="63fdd43345f7726cfc85c93addac87c77eec8e6e" translate="yes" xml:space="preserve">
          <source>You're unlikely to ever need to construct an object of this class for yourself, but if you want to, call &lt;code&gt;Pod::Simple::PullParserTextToken-&amp;gt;new( &lt;i&gt;text&lt;/i&gt; )&lt;/code&gt;</source>
          <target state="translated">이 클래스의 객체를 직접 만들 필요는 없지만 &lt;code&gt;Pod::Simple::PullParserTextToken-&amp;gt;new( &lt;i&gt;text&lt;/i&gt; )&lt;/code&gt; &lt;i&gt;text&lt;/i&gt; )를 호출하십시오.&lt;i&gt;&lt;/i&gt;</target>
        </trans-unit>
        <trans-unit id="244e1e138ccb1ddf345dc218bc4eb88a0d9affd5" translate="yes" xml:space="preserve">
          <source>You've asked &lt;code&gt;Fatal&lt;/code&gt; to replace a subroutine, but it's not a Perl built-in, and &lt;code&gt;Fatal&lt;/code&gt; couldn't find it as a regular subroutine. It either doesn't exist or has not yet been defined.</source>
          <target state="translated">&lt;code&gt;Fatal&lt;/code&gt; 에 서브 루틴을 교체 하도록 요청 했지만 Perl이 내장되어 있지 않으며 &lt;code&gt;Fatal&lt;/code&gt; 이 서브 루틴을 일반 서브 루틴으로 찾을 수 없습니다. 존재하지 않거나 아직 정의되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="e40be2d06acbdf1af8b44d624778687fbb9e49ee" translate="yes" xml:space="preserve">
          <source>You've asked &lt;code&gt;Fatal&lt;/code&gt; to try and replace a subroutine which does not exist, or has not yet been defined.</source>
          <target state="translated">존재하지 않거나 아직 정의되지 않은 서브 루틴을 &lt;code&gt;Fatal&lt;/code&gt; 으로 교체 하도록 Fatal 에 요청했습니다 .</target>
        </trans-unit>
        <trans-unit id="b50e18d238da3dcc7957f257361d12bcaab56e61" translate="yes" xml:space="preserve">
          <source>You've called &lt;code&gt;Fatal&lt;/code&gt; with an argument that doesn't look like a subroutine name, nor a switch that this version of Fatal understands.</source>
          <target state="translated">서브 루틴 이름처럼 보이지 않는 인수 나이 버전의 Fatal이 이해하는 스위치를 사용하여 &lt;code&gt;Fatal&lt;/code&gt; 을 호출했습니다 .</target>
        </trans-unit>
        <trans-unit id="a27632c5e590274b1b4e11ad85f630e87b588ea0" translate="yes" xml:space="preserve">
          <source>You've called &lt;code&gt;autodie::hints-&amp;gt;set_hints_for()&lt;/code&gt; using a subroutine reference, but that reference could not be resolved back to a subroutine name. It may be an anonymous subroutine (which can't be made autodying), or may lack a name for other reasons.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dcf998c7dc1a2b4fcde7c406f8c5df0a1daf51ce" translate="yes" xml:space="preserve">
          <source>You've found a bug in &lt;code&gt;Fatal&lt;/code&gt; . Please report it using the &lt;code&gt;perlbug&lt;/code&gt; command.</source>
          <target state="translated">&lt;code&gt;Fatal&lt;/code&gt; 에서 버그를 발견했습니다 . &lt;code&gt;perlbug&lt;/code&gt; 명령을 사용하여보고하십시오 .</target>
        </trans-unit>
        <trans-unit id="186dc5c770148f3dd87e1d02da09c16c26a5cddd" translate="yes" xml:space="preserve">
          <source>You've found a bug in &lt;code&gt;Fatal&lt;/code&gt;. Please report it using the &lt;code&gt;perlbug&lt;/code&gt; command.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="475fb69a6a2555d09a61f2284d19f582455e0ff5" translate="yes" xml:space="preserve">
          <source>You've insisted on hints for user-subroutines, either by pre-pending a &lt;code&gt;!&lt;/code&gt; to the subroutine name itself, or earlier in the list of arguments to &lt;code&gt;autodie&lt;/code&gt; . However the subroutine in question does not have any hints available.</source>
          <target state="translated">!를 앞에 붙여서 사용자 서브 루틴에 대한 힌트를 주장했습니다 &lt;code&gt;!&lt;/code&gt; 서브 루틴 이름 자체 또는 &lt;code&gt;autodie&lt;/code&gt; 에 대한 인수 목록의 앞부분에 추가하십시오 . 그러나 해당 서브 루틴에는 사용 가능한 힌트가 없습니다.</target>
        </trans-unit>
        <trans-unit id="f41835786752a38d494d7d5ae837f154ec2c37cb" translate="yes" xml:space="preserve">
          <source>You've insisted on hints for user-subroutines, either by pre-pending a &lt;code&gt;!&lt;/code&gt; to the subroutine name itself, or earlier in the list of arguments to &lt;code&gt;autodie&lt;/code&gt;. However the subroutine in question does not have any hints available.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c13a053a1a459196298d76dc68f54350a5781eb" translate="yes" xml:space="preserve">
          <source>You've probably seen shuffling algorithms that work using splice, randomly picking another element to swap the current element with</source>
          <target state="translated">스플 라이스를 사용하여 작동하는 셔플 링 알고리즘을 보았을 수도 있습니다. 현재 요소를 다른 요소로 임의로 선택하여 현재 요소를</target>
        </trans-unit>
        <trans-unit id="bace4fda5dfa9e604000927d0b697f692a0161ba" translate="yes" xml:space="preserve">
          <source>You've provided either a &lt;code&gt;scalar&lt;/code&gt; hint without supplying a &lt;code&gt;list&lt;/code&gt; hint, or vice-versa. You</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f7734dcac6827c63f3c8f78e3f70fe360dc90d8" translate="yes" xml:space="preserve">
          <source>You've tried to use &lt;code&gt;Fatal&lt;/code&gt; on a Perl built-in that can't be overridden, such as &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt;, which means that &lt;code&gt;Fatal&lt;/code&gt; can't help you, although some other modules might. See the &lt;a href=&quot;#SEE-ALSO&quot;&gt;SEE ALSO&lt;/a&gt; section of this documentation.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; 과 같이 재정의 할 수없는 Perl 내장에서 &lt;code&gt;Fatal&lt;/code&gt; 을 사용하려고 시도했습니다 . 이는 다른 모듈 일지라도 &lt;code&gt;Fatal&lt;/code&gt; 이 도움을 줄 수 없음 을 의미합니다 . 참고 항목 &lt;a href=&quot;#SEE-ALSO&quot;&gt;참조 ALSO의&lt;/a&gt; 이 문서의 섹션을.</target>
        </trans-unit>
        <trans-unit id="f898c307fef56d8fb09d91955f3edb21ee3b471f" translate="yes" xml:space="preserve">
          <source>You've tried to use &lt;code&gt;Fatal&lt;/code&gt; on a Perl built-in that can't be overridden, such as &lt;code&gt;print&lt;/code&gt; or &lt;code&gt;system&lt;/code&gt;, which means that &lt;code&gt;Fatal&lt;/code&gt; can't help you, although some other modules might. See the &lt;a href=&quot;#SEE-ALSO&quot;&gt;&quot;SEE ALSO&quot;&lt;/a&gt; section of this documentation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="770547bed3b38328c9ebe9f8750573476f6753ff" translate="yes" xml:space="preserve">
          <source>Young and free of legacy weight, providing a lightweight and easy to learn API. Has a growing addon ecosystem. It is best used for smaller projects and very easy to learn for beginners.</source>
          <target state="translated">젊고 레거시 무게가 없어 가볍고 배우기 쉬운 API를 제공합니다. 애드온 생태계가 성장하고 있습니다. 소규모 프로젝트에 가장 적합하며 초보자도 쉽게 배울 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ba596fd35b1b636342c6fc7093ef0992a49f81fa" translate="yes" xml:space="preserve">
          <source>Your</source>
          <target state="translated">Your</target>
        </trans-unit>
        <trans-unit id="3c6f85b02933dd53061abea03a23ce712a1c9139" translate="yes" xml:space="preserve">
          <source>Your &lt;code&gt;&lt;a href=&quot;functions/int&quot;&gt;int()&lt;/a&gt;&lt;/code&gt; is most probably working just fine. It's the numbers that aren't quite what you think.</source>
          <target state="translated">귀하의 &lt;code&gt;&lt;a href=&quot;functions/int&quot;&gt;int()&lt;/a&gt;&lt;/code&gt; 아마 대부분 잘 작동한다. 당신이 생각하지 않는 숫자입니다.</target>
        </trans-unit>
        <trans-unit id="319f611f50fc6a22b8fa54c955965a1d3de00bce" translate="yes" xml:space="preserve">
          <source>Your &lt;code&gt;int()&lt;/code&gt; is most probably working just fine. It's the numbers that aren't quite what you think.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9533f1ccc20bdaeae76d10a75b07a721d13705b3" translate="yes" xml:space="preserve">
          <source>Your Chinese translator emails right back -- he says both of these phrases translate to the same thing in Chinese, because, in linguistic jargon, Chinese &quot;doesn't have number as a grammatical category&quot; -- whereas English does. That is, English has grammatical rules that refer to &quot;number&quot;, i.e., whether something is grammatically singular or plural; and one of these rules is the one that forces nouns to take a plural suffix (generally &quot;s&quot;) when in a plural context, as they are when they follow a number other than &quot;one&quot; (including, oddly enough, &quot;zero&quot;). Chinese has no such rules, and so has just the one phrase where English has two. But, no problem, you can have this one Chinese phrase appear as the translation for the two English phrases in the &quot;zh&quot; gettext lexicon for your program.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="02f7bdfd19e6ed7691bd6491da0df9046c99f10e" translate="yes" xml:space="preserve">
          <source>Your Italian translator emails you back and says that &quot;I searched 0 directories&quot; (a possible English output of your program) is stilted, and if you think that's fine English, that's your problem, but that</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df53f54d51a07584d7be09d83850a7da9c15786b" translate="yes" xml:space="preserve">
          <source>Your basic test. Pass if &lt;code&gt;$test&lt;/code&gt; is true, fail if $test is false. Just like Test::Simple's &lt;code&gt;ok()&lt;/code&gt; .</source>
          <target state="translated">기본 시험. 경우 합격 &lt;code&gt;$test&lt;/code&gt; 참 $ 테스트가 false 인 경우, 실패합니다. Test :: Simple 's &lt;code&gt;ok()&lt;/code&gt; 처럼 .</target>
        </trans-unit>
        <trans-unit id="13c1c0455bcc3acdf9c65a36998e43b91fb907cc" translate="yes" xml:space="preserve">
          <source>Your basic test. Pass if &lt;code&gt;$test&lt;/code&gt; is true, fail if $test is false. Just like Test::Simple's &lt;code&gt;ok()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b237ec1c8f3c84ff91c26a3b96b070c2410531e4" translate="yes" xml:space="preserve">
          <source>Your best bet is to use the single argument form:</source>
          <target state="translated">가장 좋은 방법은 단일 인수 형식을 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="30a923bd50861e3e1f2796d154bd6dcc6842fa55" translate="yes" xml:space="preserve">
          <source>Your choice:</source>
          <target state="translated">당신의 선택 :</target>
        </trans-unit>
        <trans-unit id="2240cd19d3c19a8cd0a6388378dc061fa17be90f" translate="yes" xml:space="preserve">
          <source>Your commit message should describe what part of the Perl core you're changing and what you expect your patch to do.</source>
          <target state="translated">커밋 메시지는 변경하려는 Perl 코어 부분과 패치가 수행 할 작업을 설명해야합니다.</target>
        </trans-unit>
        <trans-unit id="9f522992b80d434f30bfc99a44403ac7ea5d333f" translate="yes" xml:space="preserve">
          <source>Your commit message should describe why the change you are making is important. When someone looks at your change in six months or six years, your intent should be clear.</source>
          <target state="translated">커밋 메시지는 왜 변경이 중요한지 설명해야합니다. 6 개월 또는 6 년 후에 누군가가 변경 사항을 검토 할 때는 의도가 분명해야합니다.</target>
        </trans-unit>
        <trans-unit id="0e92f837de5ea84ed03360a4aeae41a080276983" translate="yes" xml:space="preserve">
          <source>Your current &lt;b&gt;directory&lt;/b&gt;, from which relative pathnames are interpreted by the &lt;b&gt;operating system&lt;/b&gt;. The operating system knows your current directory because you told it with a &lt;code&gt;&lt;a href=&quot;functions/chdir&quot;&gt;chdir&lt;/a&gt;&lt;/code&gt;, or because you started out in the place where your parent &lt;b&gt;process&lt;/b&gt; was when you were born.</source>
          <target state="translated">현재 &lt;b&gt;디렉토리&lt;/b&gt; 의 상대 경로 이름은로 해석되는, &lt;b&gt;운영 체제&lt;/b&gt; . &lt;code&gt;&lt;a href=&quot;functions/chdir&quot;&gt;chdir&lt;/a&gt;&lt;/code&gt; 으로 말 했거나 부모 &lt;b&gt;프로세스&lt;/b&gt; 가 태어 났을 때 시작했기 때문에 운영 체제는 현재 디렉토리를 알고 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d7167b4cc4e41309435c48692bb15d1df5a48299" translate="yes" xml:space="preserve">
          <source>Your current &lt;b&gt;directory&lt;/b&gt;, from which relative pathnames are interpreted by the &lt;b&gt;operating system&lt;/b&gt;. The operating system knows your current directory because you told it with a &lt;code&gt;chdir&lt;/code&gt;, or because you started out in the place where your parent &lt;b&gt;process&lt;/b&gt; was when you were born.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9200ca79b7b623bd2d92209c7c88d5edf0f0d25" translate="yes" xml:space="preserve">
          <source>Your custom type should then be picked up automatically by the &lt;a href=&quot;../parser&quot;&gt;TAP::Parser&lt;/a&gt;.</source>
          <target state="translated">그런 다음 &lt;a href=&quot;../parser&quot;&gt;TAP :: Parser가&lt;/a&gt; 사용자 정의 유형을 자동으로 선택해야합니다 .</target>
        </trans-unit>
        <trans-unit id="8f096288cb046102028aee2ab90a36c8f226071a" translate="yes" xml:space="preserve">
          <source>Your custom type should then be picked up automatically by the &lt;a href=&quot;TAP::Parser&quot;&gt;TAP::Parser&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e7f0615cde01baf7008f00eb9c075025028921a" translate="yes" xml:space="preserve">
          <source>Your distribution &lt;b&gt;must&lt;/b&gt; have a &lt;code&gt;NAME&lt;/code&gt; .</source>
          <target state="translated">배포판 에 &lt;code&gt;NAME&lt;/code&gt; 이&lt;b&gt;있어야합니다&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="7431b6da14bc1d6fd4725aa372c076a384c899d0" translate="yes" xml:space="preserve">
          <source>Your distribution &lt;b&gt;must&lt;/b&gt; have a &lt;code&gt;NAME&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aae118bff15580dd943332f565267249fec4d8f3" translate="yes" xml:space="preserve">
          <source>Your entire first hard disk. Doesn't work under Windows 95. This allows you to read or write raw sectors of your hard disk and to use &lt;code&gt;DeviceIoControl&lt;/code&gt; to perform miscellaneous queries and operations to the hard disk. Writing raw sectors and certain other operations can seriously damage your files or the function of your computer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5d2eb0a183e7ffe1856bdc0a5dc547498704b0f" translate="yes" xml:space="preserve">
          <source>Your first try should probably be the &lt;a href=&quot;Text::Balanced&quot;&gt;Text::Balanced&lt;/a&gt; module, which is in the Perl standard library since Perl 5.8. It has a variety of functions to deal with tricky text. The &lt;a href=&quot;Regexp::Common&quot;&gt;Regexp::Common&lt;/a&gt; module can also help by providing canned patterns you can use.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df70fd54c497020a59006e2165eb78aadc748605" translate="yes" xml:space="preserve">
          <source>Your first try should probably be the &lt;a href=&quot;text/balanced&quot;&gt;Text::Balanced&lt;/a&gt; module, which is in the Perl standard library since Perl 5.8. It has a variety of functions to deal with tricky text. The &lt;a href=&quot;http://search.cpan.org/perldoc/Regexp::Common&quot;&gt;Regexp::Common&lt;/a&gt; module can also help by providing canned patterns you can use.</source>
          <target state="translated">첫 번째 시도는 아마도 Perl 5.8 이후의 Perl 표준 라이브러리에 있는 &lt;a href=&quot;text/balanced&quot;&gt;Text :: Balanced&lt;/a&gt; 모듈 이어야합니다 . 까다로운 텍스트를 처리하는 다양한 기능이 있습니다. &lt;a href=&quot;http://search.cpan.org/perldoc/Regexp::Common&quot;&gt;정규 표현식 :: 공통&lt;/a&gt; 모듈 수 또한 당신이 사용할 수있는 통조림 패턴을 제공하여 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="880f6f429e2d63ef4a94f9a2206ede8287e74da3" translate="yes" xml:space="preserve">
          <source>Your interfaces should be understandable by an average Perl programmer. The following guidelines may help you judge whether your API is sufficiently straightforward:</source>
          <target state="translated">인터페이스는 일반적인 Perl 프로그래머가 이해할 수 있어야합니다. 다음 지침은 API가 충분히 간단한 지 판단하는 데 도움이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d26baf198cb18edde520e205142e25037414abf9" translate="yes" xml:space="preserve">
          <source>Your internet domain name</source>
          <target state="translated">인터넷 도메인 이름</target>
        </trans-unit>
        <trans-unit id="c8e05b300242eb52ca20c1b662ee525c5256fe27" translate="yes" xml:space="preserve">
          <source>Your interpreter doesn't know how to communicate with these extensions on its own. A little glue will help. Up until now you've been calling</source>
          <target state="translated">통역사는 이러한 확장 프로그램과의 통신 방법을 모릅니다. 작은 접착제가 도움이 될 것입니다. 지금까지 전화 했어</target>
        </trans-unit>
        <trans-unit id="926b6183d26bfd81c7f17ff04a868dae347149ae" translate="yes" xml:space="preserve">
          <source>Your mileage may vary...</source>
          <target state="translated">귀하의 마일리지가 다를 수 있습니다...</target>
        </trans-unit>
        <trans-unit id="60a065094064545ff1123708e618e1b6cf8cbd1c" translate="yes" xml:space="preserve">
          <source>Your mileage will vary. If in any doubt &lt;b&gt;do not use it&lt;/b&gt;.</source>
          <target state="translated">마일리지가 다를 수 있습니다. 의심스러운 경우 &lt;b&gt;사용하지 마십시오&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="c8a47834f473426f773c0b79429bd305f3db3ac9" translate="yes" xml:space="preserve">
          <source>Your module may be object oriented (OO) or not, or it may have both kinds of interfaces available. There are pros and cons of each technique, which should be considered when you design your API.</source>
          <target state="translated">모듈이 객체 지향 (OO)인지 아닌지 또는 두 종류의 인터페이스를 모두 사용할 수 있습니다. API를 디자인 할 때 고려해야 할 각 기술의 장단점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="4936a62e724ff21109fff06e820adf4197164d03" translate="yes" xml:space="preserve">
          <source>Your module should also include a README file describing the module and giving pointers to further information (website, author email).</source>
          <target state="translated">또한 모듈에는 모듈을 설명하고 추가 정보 (웹 사이트, 작성자 이메일)에 대한 포인터를 제공하는 README 파일이 포함되어야합니다.</target>
        </trans-unit>
        <trans-unit id="290b95e5d44851668b2e9d3e7d74fdc415789c4e" translate="yes" xml:space="preserve">
          <source>Your module should have a clearly defined scope which is no longer than a single sentence. Can your module be broken down into a family of related modules?</source>
          <target state="translated">모듈은 명확하게 정의 된 범위를 가져야하며 한 문장보다 길지 않아야합니다. 모듈을 관련 모듈로 분류 할 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="8348552a40cd77a386588c2671c4e766e50a33bd" translate="yes" xml:space="preserve">
          <source>Your module should include documentation aimed at Perl developers. You should use Perl's &quot;plain old documentation&quot; (POD) for your general technical documentation, though you may wish to write additional documentation (white papers, tutorials, etc) in some other format. You need to cover the following subjects:</source>
          <target state="translated">모듈에는 Perl 개발자를위한 문서가 포함되어야합니다. 일반적인 기술 문서에는 Perl의 &quot;일반 문서&quot;(POD)를 사용해야하지만 다른 형식으로 추가 문서 (백서, 자습서 등)를 작성하고 싶을 수도 있습니다. 다음과 같은 주제를 다루어야합니다.</target>
        </trans-unit>
        <trans-unit id="861d9c806a8066b7b2265b2640dfe765fcbec7fa" translate="yes" xml:space="preserve">
          <source>Your module should run successfully under the strict pragma and should run without generating any warnings. Your module should also handle taint-checking where appropriate, though this can cause difficulties in many cases.</source>
          <target state="translated">모듈은 엄격한 pragma에서 성공적으로 실행되어야하며 경고를 생성하지 않고 실행해야합니다. 모듈은 또한 적절한 경우 오염 검사를 처리해야하지만, 많은 경우 어려움을 일으킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="55948057c1f1e500efb989c6858ac749bffed2dd" translate="yes" xml:space="preserve">
          <source>Your module will be part of a developer's toolkit. It will not, in itself, form the &lt;b&gt;entire&lt;/b&gt; toolkit. It's tempting to add extra features until your code is a monolithic system rather than a set of modular building blocks.</source>
          <target state="translated">모듈은 개발자 툴킷의 일부가됩니다. 그 자체로는 &lt;b&gt;전체&lt;/b&gt; 툴킷을 형성하지 않습니다 . 코드가 모듈 식 빌딩 블록 세트가 아닌 모 놀리 식 시스템이 될 때까지 추가 기능을 추가하려는 유혹이 있습니다.</target>
        </trans-unit>
        <trans-unit id="ad14f196f53d1d71d675a079baed8e60dbe25d0c" translate="yes" xml:space="preserve">
          <source>Your name for distributing the package with the version number included. This is used by 'make dist' to name the resulting archive file.</source>
          <target state="translated">버전 번호가 포함 된 패키지 배포를위한 이름입니다. 'make dist'에서 결과 아카이브 파일의 이름을 지정하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="175b500be69da19db3c39bbbb8f52b905fefd909" translate="yes" xml:space="preserve">
          <source>Your naming should be consistent. For instance, it's better to have:</source>
          <target state="translated">이름이 일관되어야합니다. 예를 들어 다음을 갖는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="f42ef3040bfea4a52c4a41099b15560c160072e6" translate="yes" xml:space="preserve">
          <source>Your new toolkit</source>
          <target state="translated">새로운 툴킷</target>
        </trans-unit>
        <trans-unit id="ab842b2beec604e1059561d157771750a66116bd" translate="yes" xml:space="preserve">
          <source>Your patch may be returned with requests for changes, or requests for more detailed explanations about your fix.</source>
          <target state="translated">패치는 변경 요청 또는 수정에 대한 자세한 설명 요청과 함께 반환 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1fe050a844b774ad50502f71e6d05cbaaefcd33b" translate="yes" xml:space="preserve">
          <source>Your programs can use the Config module to check whether threads are enabled. If your program can't run without them, you can say something like:</source>
          <target state="translated">프로그램은 구성 모듈을 사용하여 스레드가 사용 가능한지 여부를 확인할 수 있습니다. 프로그램이 없으면 프로그램을 실행할 수 없으면 다음과 같이 말할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="729e5a3fcb0f2511564ed50f52f86e5648feda76" translate="yes" xml:space="preserve">
          <source>Your random numbers are not that random</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3998dbed349b6ee91c59e7ad32be8eef4f4d5eba" translate="yes" xml:space="preserve">
          <source>Your return address. The program will ask you to confirm its default if you don't use this option.</source>
          <target state="translated">귀국 주소 이 옵션을 사용하지 않으면 프로그램에서 기본값을 확인하도록 요청합니다.</target>
        </trans-unit>
        <trans-unit id="cba06454beaed255dda3071738eb1ee00c75c6c3" translate="yes" xml:space="preserve">
          <source>Your script will declare a skip with the reason why you skipped and exit immediately with a zero (success). See &lt;a href=&quot;Test::Harness&quot;&gt;Test::Harness&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4ef3a10fbcdb1f56987b1c90e4c788bb1481b23" translate="yes" xml:space="preserve">
          <source>Your script will declare a skip with the reason why you skipped and exit immediately with a zero (success). See &lt;a href=&quot;harness&quot;&gt;Test::Harness&lt;/a&gt; for details.</source>
          <target state="translated">스크립트는 건너 뛴 이유와 함께 건너 뛰기를 선언하고 즉시 0으로 종료합니다 (성공). 자세한 내용은 &lt;a href=&quot;harness&quot;&gt;Test :: Harness&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="c17c8db759a1044bdb9841bb5182137da0f0e667" translate="yes" xml:space="preserve">
          <source>Your subpattern can be just about anything, but for it to have some utility, it should match when called with either or both of a) the full name of the property value with underscores (and/or spaces in the Block property) and some things uppercase; or b) the property value in all lowercase with spaces and underscores squeezed out. For example,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e050859bb44c130f248bd693464de24c2fe62560" translate="yes" xml:space="preserve">
          <source>Your system documentation for &lt;a href=&quot;clock(3)&quot;&gt;&lt;code&gt;clock(3)&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;clock_gettime(2)&quot;&gt;&lt;code&gt;clock_gettime(2)&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;clock_getres(3)&quot;&gt;&lt;code&gt;clock_getres(3)&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;clock_nanosleep(3)&quot;&gt;&lt;code&gt;clock_nanosleep(3)&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;clock_settime(2)&quot;&gt;&lt;code&gt;clock_settime(2)&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;getitimer(2)&quot;&gt;&lt;code&gt;getitimer(2)&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;gettimeofday(2)&quot;&gt;&lt;code&gt;gettimeofday(2)&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;setitimer(2)&quot;&gt;&lt;code&gt;setitimer(2)&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;sleep(3)&quot;&gt;&lt;code&gt;sleep(3)&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;stat(2)&quot;&gt;&lt;code&gt;stat(2)&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;ualarm(3)&quot;&gt;&lt;code&gt;ualarm(3)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ffadff849a0704c5040d7dc21528967305be780" translate="yes" xml:space="preserve">
          <source>Your system documentation for &lt;code&gt;clock&lt;/code&gt; , &lt;code&gt;clock_gettime&lt;/code&gt; , &lt;code&gt;clock_getres&lt;/code&gt; , &lt;code&gt;clock_nanosleep&lt;/code&gt; , &lt;code&gt;clock_settime&lt;/code&gt; , &lt;code&gt;getitimer&lt;/code&gt; , &lt;code&gt;gettimeofday&lt;/code&gt; , &lt;code&gt;setitimer&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../functions/sleep&quot;&gt;sleep&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../functions/stat&quot;&gt;stat&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;ualarm&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;clock&lt;/code&gt; , &lt;code&gt;clock_gettime&lt;/code&gt; , &lt;code&gt;clock_getres&lt;/code&gt; , &lt;code&gt;clock_nanosleep&lt;/code&gt; , &lt;code&gt;clock_settime&lt;/code&gt; , &lt;code&gt;getitimer&lt;/code&gt; , &lt;code&gt;gettimeofday&lt;/code&gt; , &lt;code&gt;setitimer&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../functions/sleep&quot;&gt;sleep&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../functions/stat&quot;&gt;stat&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;ualarm&lt;/code&gt; 에 대한 시스템 문서 .</target>
        </trans-unit>
        <trans-unit id="f45278c990de17bddc07886e62872d5705e84df2" translate="yes" xml:space="preserve">
          <source>Your system may also have man pages installed for those modules, in which case you can probably just use the man(1) command.</source>
          <target state="translated">시스템에 해당 모듈에 대한 매뉴얼 페이지가 설치되어있을 수도 있습니다.이 경우 man (1) 명령 만 사용하면됩니다.</target>
        </trans-unit>
        <trans-unit id="f67311ed40fd91017f49e031b08d5e66ea348e7f" translate="yes" xml:space="preserve">
          <source>Your system may use lockfiles to control multiple access. Make sure you follow the correct protocol. Unpredictable behavior can result from multiple processes reading from one device.</source>
          <target state="translated">시스템은 잠금 파일을 사용하여 다중 액세스를 제어 할 수 있습니다. 올바른 프로토콜을 따르십시오. 하나의 장치에서 여러 프로세스를 읽는 경우 예기치 않은 동작이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="69b78ca3bd9762db3a1f2fc87f8707247fab00ca" translate="yes" xml:space="preserve">
          <source>Your terminal expects ISO-8859-1 (yes/no)?</source>
          <target state="translated">터미널에 ISO-8859-1이 필요합니까 (예 / 아니요)?</target>
        </trans-unit>
        <trans-unit id="eb27aa8afa0df31a742a7c36ee000dde7a333d59" translate="yes" xml:space="preserve">
          <source>Your test suite additions should generally follow these guidelines (courtesy of Gurusamy Sarathy &amp;lt;gsar@activestate.com&amp;gt;):</source>
          <target state="translated">테스트 스위트 추가는 일반적으로 다음 지침을 따라야합니다 (Grusamy Sarathy &amp;lt;gsar@activestate.com&amp;gt; 제공).</target>
        </trans-unit>
        <trans-unit id="6757bbaa3e59b9eae8d3358f1cb54cb3839ec256" translate="yes" xml:space="preserve">
          <source>Your text string will be sent using the bytes in Perl's internal format. In some cases, Perl will warn you that you're doing something wrong, with a friendly warning:</source>
          <target state="translated">텍스트 문자열은 Perl의 내부 형식으로 된 바이트를 사용하여 전송됩니다. 경우에 따라 Perl은 사용자에게 잘못된 경고 메시지를 표시하면서 경고합니다.</target>
        </trans-unit>
        <trans-unit id="e6fdf4d82698552aa3b04fea17dd3738278fad63" translate="yes" xml:space="preserve">
          <source>Your version number for distributing the package. This defaults to 0.1.</source>
          <target state="translated">패키지 배포를위한 버전 번호. 기본값은 0.1입니다.</target>
        </trans-unit>
        <trans-unit id="6470a2f4b416b0ce03b530f9156d5bf0649ff6c9" translate="yes" xml:space="preserve">
          <source>Your version number for the .xs file of this package. This defaults to the value of the VERSION attribute.</source>
          <target state="translated">이 패키지의 .xs 파일의 버전 번호입니다. 기본값은 VERSION 속성 값입니다.</target>
        </trans-unit>
        <trans-unit id="f943e56eab4587790a7d8e3702190e81dcdaf111" translate="yes" xml:space="preserve">
          <source>YourModule.pm</source>
          <target state="translated">YourModule.pm</target>
        </trans-unit>
        <trans-unit id="a032b09d002bfec745ff9618af85165922efa0c5" translate="yes" xml:space="preserve">
          <source>YourPackage.pm</source>
          <target state="translated">YourPackage.pm</target>
        </trans-unit>
        <trans-unit id="96b451942b04b66df98082b51a96fd9c21c979e6" translate="yes" xml:space="preserve">
          <source>YourPackage.xs</source>
          <target state="translated">YourPackage.xs</target>
        </trans-unit>
        <trans-unit id="3a63a963c11724e54297328f1cd01fab7cc056fb" translate="yes" xml:space="preserve">
          <source>YourProjClass-&amp;gt;fallback_language_classes()</source>
          <target state="translated">YourProjClass-&amp;gt;fallback_language_classes()</target>
        </trans-unit>
        <trans-unit id="93d7ab614acf51e6ed84bd194c23c002e0bc546a" translate="yes" xml:space="preserve">
          <source>YourProjClass-&amp;gt;fallback_languages()</source>
          <target state="translated">YourProjClass-&amp;gt;fallback_languages()</target>
        </trans-unit>
        <trans-unit id="98d44898a77a54f7718ada94977059bdfaa937a9" translate="yes" xml:space="preserve">
          <source>Yuval Kogman &amp;lt;nothingmuch@woobling.org&amp;gt;</source>
          <target state="translated">유발 코 그먼 &amp;lt;nothingmuch@woobling.org&amp;gt;</target>
        </trans-unit>
        <trans-unit id="07164f28ddae965cddce1176bfcf228c5d4cba8c" translate="yes" xml:space="preserve">
          <source>Yves Orton</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf3031c81c2a11248f63acc5b78e4d34caa6f6e1" translate="yes" xml:space="preserve">
          <source>Yves Orton suggested and helped for making &lt;code&gt;Sys::Syslog&lt;/code&gt; use the native event logger under Win32 systems.</source>
          <target state="translated">Yves Orton은 &lt;code&gt;Sys::Syslog&lt;/code&gt; 가 Win32 시스템에서 기본 이벤트 로거를 사용 하도록 제안하고 도움을주었습니다 .</target>
        </trans-unit>
        <trans-unit id="909f99a779adb66a76fc53ab56c7dd1caf35d0fd" translate="yes" xml:space="preserve">
          <source>Z</source>
          <target state="translated">Z</target>
        </trans-unit>
        <trans-unit id="d9d220ab2925c9b97a98a9d9b35059f864dbe73a" translate="yes" xml:space="preserve">
          <source>ZIP</source>
          <target state="translated">ZIP</target>
        </trans-unit>
        <trans-unit id="685e745370d7ffc08330b15ff0e898d01b1112c8" translate="yes" xml:space="preserve">
          <source>ZLIB</source>
          <target state="translated">ZLIB</target>
        </trans-unit>
        <trans-unit id="afc6c45769ec18ef9f8f79510ff88d4f56540059" translate="yes" xml:space="preserve">
          <source>Zero</source>
          <target state="translated">Zero</target>
        </trans-unit>
        <trans-unit id="acf70cc883c3ef52ca41acaeee58af2e53ac5854" translate="yes" xml:space="preserve">
          <source>Zero length \N{} in regex; marked by &amp;lt;-- HERE in m/%s/</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d48ab14b512dde996fa9a15aacd833945ec5f9a6" translate="yes" xml:space="preserve">
          <source>Zero or more embedded pattern-match modifiers, to be turned on (or turned off if preceded by &lt;code&gt;&quot;-&quot;&lt;/code&gt;) for the remainder of the pattern or the remainder of the enclosing pattern group (if any).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f655446e726aef6fcbbbc67b592301154abfb5dd" translate="yes" xml:space="preserve">
          <source>ZeroD</source>
          <target state="translated">ZeroD</target>
        </trans-unit>
        <trans-unit id="0093edc3abc07bdec91d7aaaa812118b59df0952" translate="yes" xml:space="preserve">
          <source>Zeus</source>
          <target state="translated">Zeus</target>
        </trans-unit>
        <trans-unit id="f2fd2a56c54b7c37d0d9f4b109a0de518f12a9a8" translate="yes" xml:space="preserve">
          <source>Zeus for Windows is another Win32 multi-language editor/IDE that comes with support for Perl.</source>
          <target state="translated">Windows 용 Zeus는 Perl을 지원하는 다른 Win32 다국어 편집기 / IDE입니다.</target>
        </trans-unit>
        <trans-unit id="5922f5ceeff38bcfdb993efd6cfd5c472f827fa9" translate="yes" xml:space="preserve">
          <source>Zimbabwe</source>
          <target state="translated">Zimbabwe</target>
        </trans-unit>
        <trans-unit id="e1fe5d84561f30200d262fed8306805379c095f6" translate="yes" xml:space="preserve">
          <source>Zip Resources</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="222ddf368cdba35bc5af070a0978dbd9007e77f9" translate="yes" xml:space="preserve">
          <source>Zip64</source>
          <target state="translated">Zip64</target>
        </trans-unit>
        <trans-unit id="c5b305a4c34b7027cdd20c60babbc737e1ea5ce5" translate="yes" xml:space="preserve">
          <source>Zipdetails displays information about the internal record structure of the zip file. It is not concerned with displaying any details of the compressed data stored in the zip file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db104e2c14625f90e76e1788e4a37b936ee652b6" translate="yes" xml:space="preserve">
          <source>Zlib Library Version Support</source>
          <target state="translated">Zlib 라이브러리 버전 지원</target>
        </trans-unit>
        <trans-unit id="b921378e5d6ffc3afd5712a860acbd0c806b6fd7" translate="yes" xml:space="preserve">
          <source>Zlib Resources</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4711f7565028433a4314c92a81925825c798cf57" translate="yes" xml:space="preserve">
          <source>Zombies</source>
          <target state="translated">Zombies</target>
        </trans-unit>
        <trans-unit id="1e5c2f367f02e47a8c160cda1cd9d91decbac441" translate="yes" xml:space="preserve">
          <source>[</source>
          <target state="translated">[</target>
        </trans-unit>
        <trans-unit id="c3eb06ad4792b7cd40a4451742b55657a2707dfb" translate="yes" xml:space="preserve">
          <source>[ Note: previous editions of the spec had &lt;code&gt;dir&lt;/code&gt; instead of &lt;code&gt;directory&lt;/code&gt; ]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1358ca17f4fbd1e63e273da592aecdd7f2d4541" translate="yes" xml:space="preserve">
          <source>[*] http://www.unicode.org/repos/cldr/tags/latest/seed/collation/</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd2a987f8fd28617d0641e26e1ee23e3f1c471fb" translate="yes" xml:space="preserve">
          <source>[.Foo.Bar]</source>
          <target state="translated">[.Foo.Bar]</target>
        </trans-unit>
        <trans-unit id="4b6373280a08e827a1ab5c68abe6349dceef8925" translate="yes" xml:space="preserve">
          <source>[.Lib.Auto.</source>
          <target state="translated">[.Lib.Auto.</target>
        </trans-unit>
        <trans-unit id="630f50e0cd8cffab6e0a142979fe618389586858" translate="yes" xml:space="preserve">
          <source>[.pod]</source>
          <target state="translated">[.pod]</target>
        </trans-unit>
        <trans-unit id="1184f5b8d4b6dd08709cf1513f26744167065e0d" translate="yes" xml:space="preserve">
          <source>[0]</source>
          <target state="translated">[0]</target>
        </trans-unit>
        <trans-unit id="e9310b0c165be166c43d717718981dd6c9379fbe" translate="yes" xml:space="preserve">
          <source>[10]</source>
          <target state="translated">[10]</target>
        </trans-unit>
        <trans-unit id="ead435550bed6c7728d2f8005c87a3108ae51206" translate="yes" xml:space="preserve">
          <source>[10] Perl has &lt;code&gt;\X&lt;/code&gt; and &lt;code&gt;\b{gcb}&lt;/code&gt;. Unicode has retracted their &quot;Grapheme Cluster Mode&quot;, and recently added string properties, which Perl does not yet support.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6431f9aef7720a5ded14cfda76812cbf19d9f7b5" translate="yes" xml:space="preserve">
          <source>[11] see &lt;a href=&quot;https://www.unicode.org/reports/tr29&quot;&gt;UAX#29 &quot;Unicode Text Segmentation&quot;&lt;/a&gt;,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9ee40540fe63a506ce6d36914c87bb4afea3cd2" translate="yes" xml:space="preserve">
          <source>[12] see &lt;a href=&quot;#Wildcards-in-Property-Values&quot;&gt;&quot;Wildcards in Property Values&quot;&lt;/a&gt; above.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="394d4974dd13620cf2e99365a3bb93bf704a4ae5" translate="yes" xml:space="preserve">
          <source>[13] Perl supports all the properties in the Unicode Character Database (UCD). It does not yet support the listed properties that come from other Unicode sources.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88ce2d0b777027047f49d6aebdade5275a4bb399" translate="yes" xml:space="preserve">
          <source>[14] The only optional property that Perl supports is Named Sequence. None of these properties are in the UCD.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f629ae44b7b3dcfed444d363e626edf411ec69a8" translate="yes" xml:space="preserve">
          <source>[1]</source>
          <target state="translated">[1]</target>
        </trans-unit>
        <trans-unit id="0cf7207af93f70e6c641ba1e90b8e15f86916573" translate="yes" xml:space="preserve">
          <source>[1] &lt;a href=&quot;http://en.wikipedia.org/wiki/Base64#URL_applications&quot;&gt;http://en.wikipedia.org/wiki/Base64#URL_applications&lt;/a&gt;</source>
          <target state="translated">[1] &lt;a href=&quot;http://en.wikipedia.org/wiki/Base64#URL_applications&quot;&gt;http://en.wikipedia.org/wiki/Base64#URL_applications&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d6819c355b216edc67b6c6a8c6dab5509cee1376" translate="yes" xml:space="preserve">
          <source>[1] &lt;a href=&quot;http://perl.plover.com/Rx/paper/&quot;&gt;http://perl.plover.com/Rx/paper/&lt;/a&gt;</source>
          <target state="translated">[1] &lt;a href=&quot;http://perl.plover.com/Rx/paper/&quot;&gt;http://perl.plover.com/Rx/paper/&lt;/a&gt;</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
