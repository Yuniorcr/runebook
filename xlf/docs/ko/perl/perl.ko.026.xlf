<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="perl">
    <body>
      <group id="perl">
        <trans-unit id="604c79e231e51591da6ce53e73549980b6c066b2" translate="yes" xml:space="preserve">
          <source>App::Prove::State::Result - Individual test suite results.</source>
          <target state="translated">App :: Prove :: State :: Result-개별 테스트 스위트 결과.</target>
        </trans-unit>
        <trans-unit id="83a53d94c22845a17e42b81ff706d21b9d9578b9" translate="yes" xml:space="preserve">
          <source>App::Prove::State::Result::Test</source>
          <target state="translated">App::Prove::State::Result::Test</target>
        </trans-unit>
        <trans-unit id="dcd1440850fc9e2913d7cf105103afc698a85230" translate="yes" xml:space="preserve">
          <source>App::Prove::State::Result::Test - Individual test results.</source>
          <target state="translated">App :: Prove :: State :: Result :: Test-개별 테스트 결과.</target>
        </trans-unit>
        <trans-unit id="a04f6596455dd68a60a8ad9f2a7176ca7fb0ee44" translate="yes" xml:space="preserve">
          <source>Apparently, IBM used a compiler (for some period of time around '95?) which changes FP mask right and left. This is not</source>
          <target state="translated">IBM은 FP 마스크를 좌우로 바꾸는 컴파일러 (약 95 년 정도)를 사용했습니다. 이것은 아니다</target>
        </trans-unit>
        <trans-unit id="3c4496c4495e5c99d047e29d461a211122789431" translate="yes" xml:space="preserve">
          <source>Appeal to their self interest! If Perl is new (and thus scary) to them, find something that Perl can do to solve one of their problems. That might mean that Perl either saves them something (time, headaches, money) or gives them something (flexibility, power, testability).</source>
          <target state="translated">자기 관심에 호소하십시오! Perl이 그들에게 새롭고 무서운 경우, Perl이 문제 중 하나를 해결하기 위해 할 수있는 것을 찾으십시오. 그것은 Perl이 그들에게 무언가 (시간, 두통, 돈)를 절약하거나 무언가 (유연성, 힘, 테스트 가능성)를 제공한다는 것을 의미 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7820ab67805cf1ba0f215418474bf3c391c0a394" translate="yes" xml:space="preserve">
          <source>Appearances can be deceptive, especially when it comes to emptiness. If you are scratching your head trying to work out why Test::Tester is saying that your diagnostics are wrong when they look perfectly right then the answer is probably whitespace. From version 0.10 on, Test::Tester surrounds the expected and got diag values with single quotes to make it easier to spot trailing whitespace. So in this example</source>
          <target state="translated">특히 공허함과 관련하여 외모는 기만적 일 수 있습니다. Test :: Tester가 진단이 완벽하게 올바르게 보일 때 잘못되었다고 말하는 이유를 알아 내려고 머리를 긁적 거리는 경우 대답은 아마도 공백 일 것입니다. 버전 0.10부터 Test :: Tester는 예상 및 얻은 진단 값을 작은 따옴표로 묶어 후행 공백을 쉽게 찾을 수 있도록합니다. 그래서이 예에서</target>
        </trans-unit>
        <trans-unit id="b71dbc9f1f2c8f41b80953098f3e95dfa1012f02" translate="yes" xml:space="preserve">
          <source>Append an item to the list of ops contained directly within a list-type op, returning the lengthened list.</source>
          <target state="translated">목록 유형 op 내에 직접 포함 된 op 목록에 항목을 추가하여 확장 된 목록을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="555e00ca2c34efb8f2b3198b481016b18bb0499c" translate="yes" xml:space="preserve">
          <source>Append an item to the list of ops contained directly within a list-type op, returning the lengthened list. &lt;code&gt;first&lt;/code&gt; is the list-type op, and &lt;code&gt;last&lt;/code&gt; is the op to append to the list. &lt;code&gt;optype&lt;/code&gt; specifies the intended opcode for the list. If &lt;code&gt;first&lt;/code&gt; is not already a list of the right type, it will be upgraded into one. If either &lt;code&gt;first&lt;/code&gt; or &lt;code&gt;last&lt;/code&gt; is null, the other is returned unchanged.</source>
          <target state="translated">목록 유형 작업 내에 직접 포함 된 작업 목록에 항목을 추가하여 길어진 목록을 반환합니다. &lt;code&gt;first&lt;/code&gt; 는 목록 유형 작업이고 &lt;code&gt;last&lt;/code&gt; 은 목록에 추가 할 작업입니다. &lt;code&gt;optype&lt;/code&gt; 은 목록의 의도 된 opcode를 지정합니다. &lt;code&gt;first&lt;/code&gt; 가 아직 올바른 유형의 목록이 아닌 경우 하나로 업그레이드됩니다. 어느 경우 &lt;code&gt;first&lt;/code&gt; 또는 &lt;code&gt;last&lt;/code&gt; null의 경우, 다른 하나는 변경되지 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="becdeb6adee05d280a8a50e1526a1a849bef0624" translate="yes" xml:space="preserve">
          <source>Append elements of</source>
          <target state="translated">요소 추가</target>
        </trans-unit>
        <trans-unit id="7b02fe45aa574073ed825bd38be9577b88d0ca63" translate="yes" xml:space="preserve">
          <source>Append elements of LIST to the array.</source>
          <target state="translated">LIST의 요소를 배열에 추가합니다.</target>
        </trans-unit>
        <trans-unit id="89394607a467e98868ad0332e6c7061404a979e4" translate="yes" xml:space="preserve">
          <source>Append run time for each test to output. Uses &lt;a href=&quot;../../time/hires&quot;&gt;Time::HiRes&lt;/a&gt; if available.</source>
          <target state="translated">각 테스트의 출력 시간을 추가하십시오. 사용 &lt;a href=&quot;../../time/hires&quot;&gt;시간 :시 HiRes를&lt;/a&gt; 사용할 수있는 경우.</target>
        </trans-unit>
        <trans-unit id="f3320c1303317ee828f35f641012da0ef7ad78b8" translate="yes" xml:space="preserve">
          <source>Append run time for each test to output. Uses &lt;a href=&quot;../time/hires&quot;&gt;Time::HiRes&lt;/a&gt; if available.</source>
          <target state="translated">각 테스트의 출력 시간을 추가하십시오. 사용 &lt;a href=&quot;../time/hires&quot;&gt;시간 :시 HiRes를&lt;/a&gt; 사용할 수있는 경우.</target>
        </trans-unit>
        <trans-unit id="c0d38ef820bcef303880baae14bb62295e88bb8d" translate="yes" xml:space="preserve">
          <source>Append run time for each test to output. Uses &lt;a href=&quot;Time::HiRes&quot;&gt;Time::HiRes&lt;/a&gt; if available.</source>
          <target state="translated">출력 할 각 테스트의 실행 시간을 추가합니다. 사용 &lt;a href=&quot;Time::HiRes&quot;&gt;시간 :시 HiRes를&lt;/a&gt; 사용할 수있는 경우.</target>
        </trans-unit>
        <trans-unit id="115b06d7e965b2c8ec031641d6914969c4847565" translate="yes" xml:space="preserve">
          <source>Appending the G_KEEPERR flag, so that the</source>
          <target state="translated">G_KEEPERR 플래그를 추가하여</target>
        </trans-unit>
        <trans-unit id="112a3bb05c1aa885c550b6193e7eaea408add2b6" translate="yes" xml:space="preserve">
          <source>Appends the given string or parse-tree or sequence object to the parse-tree of this interior sequence.</source>
          <target state="translated">지정된 문자열 또는 구문 분석 트리 또는 시퀀스 객체를이 내부 시퀀스의 구문 분석 트리에 추가합니다.</target>
        </trans-unit>
        <trans-unit id="bc939bc86e4ec12055b78bc1367433c6c3dc048c" translate="yes" xml:space="preserve">
          <source>Apple Mac OS 8/9</source>
          <target state="translated">Apple Mac OS 8/9</target>
        </trans-unit>
        <trans-unit id="6dd82bd12d46344a2006677b750f75da928a5f51" translate="yes" xml:space="preserve">
          <source>Application of the patches</source>
          <target state="translated">패치 적용</target>
        </trans-unit>
        <trans-unit id="e91f35534bce18d06e39334fde833d8a1d0115a1" translate="yes" xml:space="preserve">
          <source>Application release September 2001, HP-UX 11.00 is the first to ship with Perl. By the time it was perl-5.6.1 in /opt/perl. The first occurrence is on CD 5012-7954 and can be installed using</source>
          <target state="translated">응용 프로그램 릴리즈 2001 년 9 월, HP-UX 11.00은 Perl과 함께 처음 제공됩니다. 당시에는 / opt / perl에서 perl-5.6.1이었습니다. 첫 번째는 CD 5012-7954에 있으며 다음을 사용하여 설치할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="70dcb259ecf9216f358dc0f66966f145bfe54f70" translate="yes" xml:space="preserve">
          <source>Applies a syntactic context to an op tree representing an expression.</source>
          <target state="translated">표현식을 나타내는 op 트리에 구문 컨텍스트를 적용합니다.</target>
        </trans-unit>
        <trans-unit id="4e768fecef5f9dd672611658c8743f59705b1284" translate="yes" xml:space="preserve">
          <source>Applies a syntactic context to an op tree representing an expression. &lt;code&gt;o&lt;/code&gt; is the op tree, and &lt;code&gt;context&lt;/code&gt; must be &lt;code&gt;G_SCALAR&lt;/code&gt;, &lt;code&gt;G_ARRAY&lt;/code&gt;, or &lt;code&gt;G_VOID&lt;/code&gt; to specify the context to apply. The modified op tree is returned.</source>
          <target state="translated">표현식을 나타내는 op 트리에 구문 컨텍스트를 적용합니다. &lt;code&gt;o&lt;/code&gt; 는 op 트리이고 &lt;code&gt;context&lt;/code&gt; 는 적용 할 컨텍스트를 지정하기 위해 &lt;code&gt;G_SCALAR&lt;/code&gt; , &lt;code&gt;G_ARRAY&lt;/code&gt; 또는 &lt;code&gt;G_VOID&lt;/code&gt; 여야 합니다. 수정 된 연산 트리가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="d5ed3f5653497e355ed136e0b7c54a5982ace7b4" translate="yes" xml:space="preserve">
          <source>Applies dl_find_symbol() to the members of @dl_librefs and returns the first match found.</source>
          <target state="translated">dl_find_symbol ()을 @dl_librefs의 멤버에 적용하고 발견 된 첫 번째 일치를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="8f16d6f27d971ff843245cdc989aa538f3326e5f" translate="yes" xml:space="preserve">
          <source>Apply &lt;a href=&quot;#int-EXPR&quot;&gt;&lt;code&gt;int&lt;/code&gt;&lt;/a&gt; to the value returned by &lt;a href=&quot;#rand-EXPR&quot;&gt;&lt;code&gt;rand&lt;/code&gt;&lt;/a&gt; if you want random integers instead of random fractional numbers. For example,</source>
          <target state="translated">임의의 소수 대신 임의의 정수를 원하면 &lt;a href=&quot;#rand-EXPR&quot;&gt; &lt;code&gt;rand&lt;/code&gt; &lt;/a&gt; 가 반환 한 값에 &lt;a href=&quot;#int-EXPR&quot;&gt; &lt;code&gt;int&lt;/code&gt; &lt;/a&gt; 를 적용 합니다. 예를 들면</target>
        </trans-unit>
        <trans-unit id="197e68ad33f090de266ab7a82716d4dcf0c6223c" translate="yes" xml:space="preserve">
          <source>Apply &lt;code&gt;&lt;a href=&quot;functions/int&quot;&gt;int()&lt;/a&gt;&lt;/code&gt; to the value returned by &lt;code&gt;&lt;a href=&quot;functions/rand&quot;&gt;rand()&lt;/a&gt;&lt;/code&gt; if you want random integers instead of random fractional numbers. For example,</source>
          <target state="translated">임의의 소수 대신 임의의 정수를 원할 경우 &lt;code&gt;&lt;a href=&quot;functions/rand&quot;&gt;rand()&lt;/a&gt;&lt;/code&gt; 가 리턴 한 값에 &lt;code&gt;&lt;a href=&quot;functions/int&quot;&gt;int()&lt;/a&gt;&lt;/code&gt; 를 적용하십시오 . 예를 들어</target>
        </trans-unit>
        <trans-unit id="a60da6ae1477278e788b56dd12901cf6a9b5b818" translate="yes" xml:space="preserve">
          <source>Apply &lt;code&gt;&lt;a href=&quot;int&quot;&gt;int()&lt;/a&gt;&lt;/code&gt; to the value returned by &lt;code&gt;&lt;a href=&quot;rand&quot;&gt;rand()&lt;/a&gt;&lt;/code&gt; if you want random integers instead of random fractional numbers. For example,</source>
          <target state="translated">임의의 소수 대신 임의의 정수를 원할 경우 &lt;code&gt;&lt;a href=&quot;rand&quot;&gt;rand()&lt;/a&gt;&lt;/code&gt; 가 리턴 한 값에 &lt;code&gt;&lt;a href=&quot;int&quot;&gt;int()&lt;/a&gt;&lt;/code&gt; 를 적용하십시오 . 예를 들어</target>
        </trans-unit>
        <trans-unit id="974cf6b03d0010e4742b565eeb776443fe41243e" translate="yes" xml:space="preserve">
          <source>Apply Perl-specific heuristics to find the correct PODs. This includes stripping Perl-like extensions, omitting subdirectories that are numeric but do</source>
          <target state="translated">올바른 POD를 찾으려면 Perl 특정 휴리스틱을 적용하십시오. 여기에는 Perl과 유사한 확장을 제거하고 숫자는 있지만 하위 디렉토리는 생략합니다.</target>
        </trans-unit>
        <trans-unit id="baaa234761c2eef7e15c7c661df9bd832e32f420" translate="yes" xml:space="preserve">
          <source>Apply a list of switch options to the state, updating the internal object state as a result. Nothing is returned.</source>
          <target state="translated">스위치 옵션 목록을 상태에 적용하여 결과적으로 내부 개체 상태를 업데이트합니다. 아무것도 반환되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7b0453d0169f10e0dd546ac420ad360f4311387a" translate="yes" xml:space="preserve">
          <source>Applying %s to %s will act on scalar(%s)</source>
          <target state="translated">% s을 (를) % s에 적용하면 스칼라 (% s)에서 작동합니다.</target>
        </trans-unit>
        <trans-unit id="c72c1cee8e4b08228a22dc9c5e025abf27a61b14" translate="yes" xml:space="preserve">
          <source>Applying &lt;code&gt;autodie&lt;/code&gt; to &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; causes the exotic forms &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt; { $cmd } @args &lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt; { $cmd } @args&lt;/code&gt; to be considered a syntax error until the end of the lexical scope. If you really need to use the exotic form, you can call &lt;code&gt;CORE::system&lt;/code&gt; or &lt;code&gt;CORE::exec&lt;/code&gt; instead, or use &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; autodie qw(system exec)&lt;/code&gt; before calling the exotic form.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; 에 &lt;code&gt;autodie&lt;/code&gt; 를 적용하면 이국적인 양식 &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt; { $cmd } @args &lt;/code&gt; {$ cmd} @args 또는 &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt; { $cmd } @args&lt;/code&gt; {$ cmd} @args 가 어휘 범위가 끝날 때까지 구문 오류로 간주됩니다. 이국적인 양식을 사용해야하는 경우 &lt;code&gt;CORE::system&lt;/code&gt; 또는 &lt;code&gt;CORE::exec&lt;/code&gt; 대신 호출하거나 이국적인 양식을 호출하기 전에 &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; autodie qw(system exec)&lt;/code&gt; 를 사용 &lt;a href=&quot;functions/no&quot;&gt;하지&lt;/a&gt; 않아도 됩니다.</target>
        </trans-unit>
        <trans-unit id="73c33410e3cd1ef38b870e6e841b6a111c44ea15" translate="yes" xml:space="preserve">
          <source>Applying &lt;code&gt;autodie&lt;/code&gt; to &lt;code&gt;system&lt;/code&gt; or &lt;code&gt;exec&lt;/code&gt; causes the exotic forms &lt;code&gt;system { $cmd } @args &lt;/code&gt; or &lt;code&gt;exec { $cmd } @args&lt;/code&gt; to be considered a syntax error until the end of the lexical scope. If you really need to use the exotic form, you can call &lt;code&gt;CORE::system&lt;/code&gt; or &lt;code&gt;CORE::exec&lt;/code&gt; instead, or use &lt;code&gt;no autodie qw(system exec)&lt;/code&gt; before calling the exotic form.</source>
          <target state="translated">&lt;code&gt;autodie&lt;/code&gt; 를 &lt;code&gt;system&lt;/code&gt; 또는 &lt;code&gt;exec&lt;/code&gt; 에 적용하면 이국적인 양식 &lt;code&gt;system { $cmd } @args &lt;/code&gt; 또는 &lt;code&gt;exec { $cmd } @args&lt;/code&gt; 가 어휘 범위가 끝날 때까지 구문 오류로 간주됩니다. 정말로 이국적인 형식을 사용해야하는 경우 &lt;code&gt;CORE::system&lt;/code&gt; 또는 &lt;code&gt;CORE::exec&lt;/code&gt; 대신 호출하거나, 이국적인 형식을 호출하기 전에 &lt;code&gt;no autodie qw(system exec)&lt;/code&gt; 를 사용 하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7b6bbaf0846e0f6542bb5b50d36df38212d67922" translate="yes" xml:space="preserve">
          <source>Approximate Perl equivalent: &lt;code&gt;$myarray[$key] = $val;&lt;/code&gt; .</source>
          <target state="translated">대략적인 Perl 동등 : &lt;code&gt;$myarray[$key] = $val;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="255706027acb3bbb6c23a2beab5baa7da2561792" translate="yes" xml:space="preserve">
          <source>Approximate Perl equivalent: &lt;code&gt;&amp;amp;{&quot;$sub_name&quot;}(@$argv)&lt;/code&gt; .</source>
          <target state="translated">대략적인 Perl 동등 : &lt;code&gt;&amp;amp;{&quot;$sub_name&quot;}(@$argv)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9f08b9c9f0996e8f22c8e80713baa3b2c5d6b61a" translate="yes" xml:space="preserve">
          <source>Approximate Perl equivalent: &lt;code&gt;&amp;amp;{&quot;$sub_name&quot;}(@$argv)&lt;/code&gt;.</source>
          <target state="translated">Perl에 해당하는 대략적인 값 : &lt;code&gt;&amp;amp;{&quot;$sub_name&quot;}(@$argv)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="171752021f257ea835e63866304a10e0627a5496" translate="yes" xml:space="preserve">
          <source>Approximate Perl equivalent: &lt;code&gt;splice(@myarray, $key, 1, $val)&lt;/code&gt;.</source>
          <target state="translated">Perl의 근사치 : &lt;code&gt;splice(@myarray, $key, 1, $val)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2b7d5efdfeaa09de6b4d853375871c9207032b5a" translate="yes" xml:space="preserve">
          <source>April 04-07th, 1997: by Jarkko Hietaniemi, added the run-for-some-time functionality.</source>
          <target state="translated">1997 년 4 월 4 일 -07 일 : Jarkko Hietaniemi가 때때로 실행 기능을 추가했습니다.</target>
        </trans-unit>
        <trans-unit id="538beea89400340066f03de9b8531baacd233ee4" translate="yes" xml:space="preserve">
          <source>April 2010</source>
          <target state="translated">2010 년 4 월</target>
        </trans-unit>
        <trans-unit id="af4f4762f9bd3f0f4a10caf5b6e63dc4ce543724" translate="yes" xml:space="preserve">
          <source>Arabic</source>
          <target state="translated">Arabic</target>
        </trans-unit>
        <trans-unit id="5383ba59b7a51b492dcc518df7e4190d4cdf46a1" translate="yes" xml:space="preserve">
          <source>Arbitrary big rational numbers</source>
          <target state="translated">임의의 큰 유리수</target>
        </trans-unit>
        <trans-unit id="d355876ea51e167fe43014294b56e66adbafd342" translate="yes" xml:space="preserve">
          <source>Arbitrary size floating point math package</source>
          <target state="translated">임의의 크기 부동 소수점 수학 패키지</target>
        </trans-unit>
        <trans-unit id="94977ff2a6f2fcf0486458c46c172275ed7d1a6e" translate="yes" xml:space="preserve">
          <source>Arbitrary size integer/float math package</source>
          <target state="translated">임의 크기의 정수 / 부동 수학 패키지</target>
        </trans-unit>
        <trans-unit id="f96ddf323d8050458b6f5da00e7d15254e6e51f7" translate="yes" xml:space="preserve">
          <source>Arch</source>
          <target state="translated">Arch</target>
        </trans-unit>
        <trans-unit id="fa197ea9d1ebf357ab1895c0454edae5ed010094" translate="yes" xml:space="preserve">
          <source>Archive and test</source>
          <target state="translated">보관 및 테스트</target>
        </trans-unit>
        <trans-unit id="ba6c5bbd1305838d356b1a16f613e5175253fc77" translate="yes" xml:space="preserve">
          <source>Archive::Tar</source>
          <target state="translated">Archive::Tar</target>
        </trans-unit>
        <trans-unit id="57cc32f42ad2d2bee580d99c3d374961c6559947" translate="yes" xml:space="preserve">
          <source>Archive::Tar - module for manipulations of tar archives</source>
          <target state="translated">Archive :: Tar-tar 아카이브 조작을위한 모듈</target>
        </trans-unit>
        <trans-unit id="987b760cdf9eb8e8f22f82c621b2dbe3ee552aeb" translate="yes" xml:space="preserve">
          <source>Archive::Tar provides an object oriented mechanism for handling tar files. It provides class methods for quick and easy files handling while also allowing for the creation of tar file objects for custom manipulation. If you have the IO::Zlib module installed, Archive::Tar will also support compressed or gzipped tar files.</source>
          <target state="translated">Archive :: Tar은 tar 파일을 처리하기위한 객체 지향 메커니즘을 제공합니다. 빠르고 쉬운 파일 처리를위한 클래스 메소드를 제공하는 동시에 사용자 정의 조작을 위해 tar 파일 오브젝트를 작성할 수 있습니다. IO :: Zlib 모듈을 설치 한 경우 Archive :: Tar는 압축 또는 zip 압축 tar 파일도 지원합니다.</target>
        </trans-unit>
        <trans-unit id="2de9e103622352aeb9a5f8214ffe2d70dee8d73d" translate="yes" xml:space="preserve">
          <source>Archive::Tar will warn if you try to pass a bzip2 / xz compressed file and the IO::Uncompress::Bunzip2 / IO::Uncompress::UnXz are not available and simply return.</source>
          <target state="translated">Archive :: Tar는 bzip2 / xz 압축 파일을 전달하려고 시도하고 IO :: Uncompress :: Bunzip2 / IO :: Uncompress :: UnXz를 사용할 수 없으며 단순히 반환하면 경고합니다.</target>
        </trans-unit>
        <trans-unit id="7c0d8b6a96eeaeee2b14e15f99110273c20f8435" translate="yes" xml:space="preserve">
          <source>Archive::Tar will warn if you try to pass a bzip2 compressed file and the IO::Zlib / IO::Uncompress::Bunzip2 modules are not available and simply return.</source>
          <target state="translated">bzip2 압축 파일을 전달하려고하면 IO :: Zlib / IO :: Uncompress :: Bunzip2 모듈을 사용할 수없고 단순히 반환하면 Archive :: Tar가 경고합니다.</target>
        </trans-unit>
        <trans-unit id="ccbf19882dacfbec62ca802f4c207f93b26aac20" translate="yes" xml:space="preserve">
          <source>Archive::Tar-&amp;gt;can_handle_compressed_files</source>
          <target state="translated">Archive::Tar-&amp;gt;can_handle_compressed_files</target>
        </trans-unit>
        <trans-unit id="3b7da738f6421ea5f244ab2a75337cb19a765083" translate="yes" xml:space="preserve">
          <source>Archive::Tar-&amp;gt;create_archive($file, $compressed, @filelist)</source>
          <target state="translated">Archive :: Tar-&amp;gt; create_archive ($ file, $ compressed, @filelist)</target>
        </trans-unit>
        <trans-unit id="1dcbd289acf336b4bc9986937face374b8265d16" translate="yes" xml:space="preserve">
          <source>Archive::Tar-&amp;gt;extract_archive($file, $compressed)</source>
          <target state="translated">아카이브 :: Tar-&amp;gt; extract_archive ($ file, $ compressed)</target>
        </trans-unit>
        <trans-unit id="8336b53d325ea70cb860e4292e999b5eb8ccc20b" translate="yes" xml:space="preserve">
          <source>Archive::Tar-&amp;gt;iter( $filename, [ $compressed, {opt =&amp;gt; $val} ] )</source>
          <target state="translated">Archive :: Tar-&amp;gt; iter ($ filename, [$ compressed, {opt =&amp;gt; $ val}])</target>
        </trans-unit>
        <trans-unit id="7b5db2965e54185ceb8a82cfef6b3bcf83d67256" translate="yes" xml:space="preserve">
          <source>Archive::Tar-&amp;gt;list_archive($file, $compressed, [\@properties])</source>
          <target state="translated">Archive :: Tar-&amp;gt; list_archive ($ file, $ compressed, [\ @properties])</target>
        </trans-unit>
        <trans-unit id="2b89433003c5207f03c7ec11ee01b11e8497bdb8" translate="yes" xml:space="preserve">
          <source>Archive::Tar-&amp;gt;new( [$file, $compressed] )</source>
          <target state="translated">Archive :: Tar-&amp;gt; new ([$ file, $ compressed])</target>
        </trans-unit>
        <trans-unit id="3fdd79ccbef7cb27b73af9645a51c4748537632a" translate="yes" xml:space="preserve">
          <source>Archive::Tar::File</source>
          <target state="translated">Archive::Tar::File</target>
        </trans-unit>
        <trans-unit id="e4450126317363219e2891fd96c92d67bb8fdb14" translate="yes" xml:space="preserve">
          <source>Archive::Tar::File - a subclass for in-memory extracted file from Archive::Tar</source>
          <target state="translated">Archive :: Tar :: File-Archive :: Tar에서 메모리 내 추출 파일의 서브 클래스</target>
        </trans-unit>
        <trans-unit id="9bb643189669555fb8fc9a5ad660a12af02d7c6a" translate="yes" xml:space="preserve">
          <source>Archive::Tar::File-&amp;gt;new( chunk =&amp;gt; $chunk )</source>
          <target state="translated">Archive :: Tar :: File-&amp;gt; new (청크 =&amp;gt; $ chunk)</target>
        </trans-unit>
        <trans-unit id="ba9618dfc7889be15218e3ccacc09c8bf242756f" translate="yes" xml:space="preserve">
          <source>Archive::Tar::File-&amp;gt;new( data =&amp;gt; $path, $data, $opt )</source>
          <target state="translated">아카이브 :: Tar :: File-&amp;gt; new (data =&amp;gt; $ path, $ data, $ opt)</target>
        </trans-unit>
        <trans-unit id="a50e4ac8ad32b339e1eb6dee5ec96a58d21300c3" translate="yes" xml:space="preserve">
          <source>Archive::Tar::File-&amp;gt;new( file =&amp;gt; $path )</source>
          <target state="translated">Archive :: Tar :: File-&amp;gt; new (파일 =&amp;gt; $ path)</target>
        </trans-unit>
        <trans-unit id="752ab891c175e9890243ad0568d1b63da7b75555" translate="yes" xml:space="preserve">
          <source>Archive::Tar::Files provides a neat little object layer for in-memory extracted files. It's mostly used internally in Archive::Tar to tidy up the code, but there's no reason users shouldn't use this API as well.</source>
          <target state="translated">Archive :: Tar :: Files는 메모리 내 추출 파일에 대한 깔끔한 작은 객체 계층을 제공합니다. 코드를 정리하기 위해 대부분 Archive :: Tar에서 내부적으로 사용되지만 사용자가이 API를 사용하지 않아야하는 이유는 없습니다.</target>
        </trans-unit>
        <trans-unit id="2fa2e509f071fa28e01ed08cd42d1e6a982c1c93" translate="yes" xml:space="preserve">
          <source>Archiving and Compression</source>
          <target state="translated">보관 및 압축</target>
        </trans-unit>
        <trans-unit id="470ed7908583fc807812b6f6f1c733d168001e41" translate="yes" xml:space="preserve">
          <source>Are Perl regexes DFAs or NFAs? Are they POSIX compliant?</source>
          <target state="translated">Perl은 DFA 또는 NFA입니까? POSIX를 준수합니까?</target>
        </trans-unit>
        <trans-unit id="eb00fa046e6f0e29e318d2fe47833f95b6115931" translate="yes" xml:space="preserve">
          <source>Are These Threads The Same?</source>
          <target state="translated">이 스레드는 동일합니까?</target>
        </trans-unit>
        <trans-unit id="4b1b74d280a485e3d6be58ac5945ac8cbddc5958" translate="yes" xml:space="preserve">
          <source>Are not yet implemented.</source>
          <target state="translated">아직 구현되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="37ca7d873908345ae9a97f86f6ad04967916d66e" translate="yes" xml:space="preserve">
          <source>Are we at end of file?</source>
          <target state="translated">파일이 끝났습니까?</target>
        </trans-unit>
        <trans-unit id="1c7b6fd019a3db8f66c106580e36cbc2e27fdf91" translate="yes" xml:space="preserve">
          <source>Are you running Windows, and did you write</source>
          <target state="translated">Windows를 실행 중이고 작성 했습니까?</target>
        </trans-unit>
        <trans-unit id="d10b1e8f0d25e8ced1066c8aec43c1966f5ae507" translate="yes" xml:space="preserve">
          <source>Are you running the latest released version of perl?</source>
          <target state="translated">최신 출시 버전의 Perl을 실행하고 있습니까?</target>
        </trans-unit>
        <trans-unit id="c3fcfe8bf10e9354f16b7f74dc1d506d9b370761" translate="yes" xml:space="preserve">
          <source>Are you sure what you have is a bug?</source>
          <target state="translated">당신이 가지고있는 것이 버그라고 확신합니까?</target>
        </trans-unit>
        <trans-unit id="9835fff08898bf6d47cdf47b75c3d5a32e54abb7" translate="yes" xml:space="preserve">
          <source>Are you using a really old version of Perl?</source>
          <target state="translated">정말 오래된 버전의 Perl을 사용하고 있습니까?</target>
        </trans-unit>
        <trans-unit id="1f76843fe2bb213b3ad1c4d889f7769d9611e0fa" translate="yes" xml:space="preserve">
          <source>Arg too short for msgsnd</source>
          <target state="translated">msgsnd에 대한 인수가 너무 짧습니다.</target>
        </trans-unit>
        <trans-unit id="354bf98925838ca68611b950e2a37ebd11c21640" translate="yes" xml:space="preserve">
          <source>Argentina</source>
          <target state="translated">Argentina</target>
        </trans-unit>
        <trans-unit id="6fa0e4cab9d0443ef8c9e6c56e4240cbc1230cdb" translate="yes" xml:space="preserve">
          <source>Arguably, these are the only routines you'll ever need to execute snippets of Perl code from within your C program. Your code can be as long as you wish; it can contain multiple statements; it can employ &lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;, &lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;, and &lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt; to include external Perl files.</source>
          <target state="translated">아마도 이것은 C 프로그램 내에서 Perl 코드 스 니펫을 실행하는 데 필요한 유일한 루틴 일 것입니다. 코드는 원하는 길이만큼 길 수 있습니다. 여러 명령문을 포함 할 수 있습니다. 그것은 채택 할 수 &lt;a href=&quot;functions/use&quot;&gt;사용&lt;/a&gt; , &lt;a href=&quot;functions/require&quot;&gt;필요&lt;/a&gt; , 그리고 &lt;a href=&quot;functions/do&quot;&gt;어떻게&lt;/a&gt; 외부 펄 파일을 포함 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1bfedcdfdca0d5a6460d0d9a3f351f6cd3b4ab7e" translate="yes" xml:space="preserve">
          <source>Arguably, these are the only routines you'll ever need to execute snippets of Perl code from within your C program. Your code can be as long as you wish; it can contain multiple statements; it can employ &lt;a href=&quot;perlfunc#use&quot;&gt;&quot;use&quot; in perlfunc&lt;/a&gt;, &lt;a href=&quot;perlfunc#require&quot;&gt;&quot;require&quot; in perlfunc&lt;/a&gt;, and &lt;a href=&quot;perlfunc#do&quot;&gt;&quot;do&quot; in perlfunc&lt;/a&gt; to include external Perl files.</source>
          <target state="translated">틀림없이 이것들은 C 프로그램 내에서 Perl 코드 스 니펫을 실행하는 데 필요한 유일한 루틴입니다. 코드는 원하는만큼 길 수 있습니다. 여러 문을 포함 할 수 있습니다. 그것은 사용할 수있다 &lt;a href=&quot;perlfunc#use&quot;&gt;을 perlfunc에서 &quot;사용&quot;을&lt;/a&gt; , &lt;a href=&quot;perlfunc#require&quot;&gt;을 perlfunc의 &quot;요구&quot;&lt;/a&gt; 하고 &lt;a href=&quot;perlfunc#do&quot;&gt;을 perlfunc에 &quot;할&quot;&lt;/a&gt; 외부 펄 파일을 포함 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ce5e5792e97fe5c7861d6ae9b29cf5a25cc0e70a" translate="yes" xml:space="preserve">
          <source>Argument</source>
          <target state="translated">Argument</target>
        </trans-unit>
        <trans-unit id="a16749b15d046173fc9fcdf8d075749c151dba6a" translate="yes" xml:space="preserve">
          <source>Argument &quot;%s&quot; isn't numeric%s</source>
          <target state="translated">&quot;% s&quot;인수는 숫자가 아닙니다 % s</target>
        </trans-unit>
        <trans-unit id="c043537672dbd0f8f35895f8245f3c4e263a6c8f" translate="yes" xml:space="preserve">
          <source>Argument &quot;%s&quot; treated as 0 in increment (++)</source>
          <target state="translated">인수 &quot;% s&quot;는 증분에서 0으로 처리됩니다 (++).</target>
        </trans-unit>
        <trans-unit id="068c4f93ca844add9151394d87be6f0eff5098cb" translate="yes" xml:space="preserve">
          <source>Argument callback</source>
          <target state="translated">인수 콜백</target>
        </trans-unit>
        <trans-unit id="f421070543c0b96709c29a61e7bc0e29c9a6f773" translate="yes" xml:space="preserve">
          <source>Argument list not closed for PerlIO layer &quot;%s&quot;</source>
          <target state="translated">PerlIO 계층 &quot;% s&quot;에 대한 인수 목록이 닫히지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="becc16f3f9567f706b791b0867003075aa38f700" translate="yes" xml:space="preserve">
          <source>Argument stack</source>
          <target state="translated">인수 스택</target>
        </trans-unit>
        <trans-unit id="9acc1ee24f849a6b6943c3856e23bafeb8ea115e" translate="yes" xml:space="preserve">
          <source>Argument stack manipulation in the core is exactly the same as it is in XSUBs - see &lt;a href=&quot;perlxstut&quot;&gt;perlxstut&lt;/a&gt;, &lt;a href=&quot;perlxs&quot;&gt;perlxs&lt;/a&gt; and &lt;a href=&quot;perlguts&quot;&gt;perlguts&lt;/a&gt; for a longer description of the macros used in stack manipulation.</source>
          <target state="translated">코어의 인수 스택 조작은 XSUB 와 &lt;a href=&quot;perlguts&quot;&gt;동일&lt;/a&gt; 합니다. 스택 조작에 사용되는 매크로에 대한 자세한 설명 은 &lt;a href=&quot;perlxstut&quot;&gt;perlxstut&lt;/a&gt; , &lt;a href=&quot;perlxs&quot;&gt;perlxs&lt;/a&gt; 및 perlguts 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="cbb9fa252e60809efa55a7ad83aea5438ef56753" translate="yes" xml:space="preserve">
          <source>Arguments</source>
          <target state="translated">Arguments</target>
        </trans-unit>
        <trans-unit id="1e682d21a155016274d4c0edada169602cf2db63" translate="yes" xml:space="preserve">
          <source>Arguments are case insensitive.</source>
          <target state="translated">인수는 대소 문자를 구분하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f350823ca978137e84ceb658074c062e77adbc5a" translate="yes" xml:space="preserve">
          <source>Arguments are forced into the integer format if not strings.</source>
          <target state="translated">문자열이 아닌 경우 인수는 정수 형식으로 강제 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="e574a112087c49e835619f8e2053ef81199f3165" translate="yes" xml:space="preserve">
          <source>Arguments are passed to PP code and returned from PP code using the argument stack, &lt;code&gt;ST&lt;/code&gt; . The typical way to handle arguments is to pop them off the stack, deal with them how you wish, and then push the result back onto the stack. This is how, for instance, the cosine operator works:</source>
          <target state="translated">인수는 PP 코드로 전달되고 인수 스택 &lt;code&gt;ST&lt;/code&gt; 를 사용하여 PP 코드에서 반환됩니다 . 인수를 처리하는 일반적인 방법은 스택에서 인수를 꺼내어 원하는 방식으로 처리 한 다음 결과를 스택으로 다시 푸시하는 것입니다. 예를 들어 코사인 연산자의 작동 방식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ad4cbcd9603c1cc923fb5986131d15966c20d956" translate="yes" xml:space="preserve">
          <source>Arguments are passed to PP code and returned from PP code using the argument stack, &lt;code&gt;ST&lt;/code&gt;. The typical way to handle arguments is to pop them off the stack, deal with them how you wish, and then push the result back onto the stack. This is how, for instance, the cosine operator works:</source>
          <target state="translated">인수는 PP 코드로 전달되고 인수 스택 &lt;code&gt;ST&lt;/code&gt; 를 사용하여 PP 코드에서 반환됩니다 . 인수를 처리하는 일반적인 방법은 인수를 스택에서 꺼내고 원하는 방식으로 처리 한 다음 결과를 스택으로 다시 푸시하는 것입니다. 예를 들어 코사인 연산자가 작동하는 방식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5fccb02bffe9af13a6b48fc881c2035657ec7bff" translate="yes" xml:space="preserve">
          <source>Arguments are usually formatted to be only as wide as required to display the given value. You can override the width by putting a number here, or get the width from the next argument (with &lt;code&gt;*&lt;/code&gt; ) or from a specified argument (e.g., with &lt;code&gt;*2$&lt;/code&gt;):</source>
          <target state="translated">인수는 일반적으로 주어진 값을 표시하는 데 필요한만큼만 넓게 형식화됩니다. 여기에 숫자를 넣어 너비를 재정의하거나 다음 인수 ( &lt;code&gt;*&lt;/code&gt; 사용 ) 또는 지정된 인수 (예 : &lt;code&gt;*2$&lt;/code&gt; ) 에서 너비를 가져올 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="79b342195140d9018897c02d4477a0cd2a68bcbe" translate="yes" xml:space="preserve">
          <source>Arguments are usually formatted to be only as wide as required to display the given value. You can override the width by putting a number here, or get the width from the next argument (with &lt;code&gt;*&lt;/code&gt;) or from a specified argument (e.g., with &lt;code&gt;*2$&lt;/code&gt;):</source>
          <target state="translated">인수는 일반적으로 주어진 값을 표시하는 데 필요한 너비로만 형식이 지정됩니다. 여기에 숫자를 입력하여 너비를 재정의하거나 다음 인수 ( &lt;code&gt;*&lt;/code&gt; 사용 ) 또는 지정된 인수 (예 : &lt;code&gt;*2$&lt;/code&gt; ) 에서 너비를 가져올 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4fb3861e253aa9c040fd66d90deafd1a6d71292f" translate="yes" xml:space="preserve">
          <source>Arguments of the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; overload&lt;/code&gt; directive are (key, value) pairs. For the full set of legal keys, see &lt;a href=&quot;#Overloadable-Operations&quot;&gt;Overloadable Operations&lt;/a&gt; below.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; overload&lt;/code&gt; 지시문의 인수 는 (키, 값) 쌍입니다. 법적 키의 전체 세트는 아래의 &lt;a href=&quot;#Overloadable-Operations&quot;&gt;오버로드 가능한 조작을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="cb61e5648eb703f1cc9dab71a052768830d8cd36" translate="yes" xml:space="preserve">
          <source>Arguments of the &lt;code&gt;use overload&lt;/code&gt; directive are (key, value) pairs. For the full set of legal keys, see &lt;a href=&quot;#Overloadable-Operations&quot;&gt;&quot;Overloadable Operations&quot;&lt;/a&gt; below.</source>
          <target state="translated">&lt;code&gt;use overload&lt;/code&gt; 지시문의 인수 는 (키, 값) 쌍입니다. 합법적 인 키의 전체 세트는 아래의 &lt;a href=&quot;#Overloadable-Operations&quot;&gt;&quot;오버로드 가능한 작업&quot;을&lt;/a&gt; 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="5141dae339b17f35a7a4380f8f719ce252ef43f8" translate="yes" xml:space="preserve">
          <source>Arguments that don't start with a hyphen are taken to be the names of subroutines or formats to render; if no such functions are specified, the main body of the program (outside any subroutines, and not including use'd or require'd files) is rendered. Passing &lt;code&gt;BEGIN&lt;/code&gt; , &lt;code&gt;UNITCHECK&lt;/code&gt; , &lt;code&gt;CHECK&lt;/code&gt; , &lt;code&gt;INIT&lt;/code&gt; , or &lt;code&gt;END&lt;/code&gt; will cause all of the corresponding special blocks to be printed. Arguments must follow options.</source>
          <target state="translated">하이픈으로 시작하지 않는 인수는 렌더링 할 서브 루틴 또는 형식의 이름으로 간주됩니다. 이러한 기능을 지정하지 않으면 프로그램의 본체 (서브 루틴 이외의 파일, 사용 또는 필요 파일 제외)가 렌더링됩니다. 전달 &lt;code&gt;BEGIN&lt;/code&gt; , &lt;code&gt;UNITCHECK&lt;/code&gt; 는 , &lt;code&gt;CHECK&lt;/code&gt; , &lt;code&gt;INIT&lt;/code&gt; , 또는 &lt;code&gt;END&lt;/code&gt; 는 해당 특수 블록의 모든 인쇄하게됩니다. 인수는 옵션을 따라야합니다.</target>
        </trans-unit>
        <trans-unit id="c05d8fdf0d667d5e67ac75211debe610ccbb3189" translate="yes" xml:space="preserve">
          <source>Arguments that don't start with a hyphen are taken to be the names of subroutines or formats to render; if no such functions are specified, the main body of the program (outside any subroutines, and not including use'd or require'd files) is rendered. Passing &lt;code&gt;BEGIN&lt;/code&gt;, &lt;code&gt;UNITCHECK&lt;/code&gt;, &lt;code&gt;CHECK&lt;/code&gt;, &lt;code&gt;INIT&lt;/code&gt;, or &lt;code&gt;END&lt;/code&gt; will cause all of the corresponding special blocks to be printed. Arguments must follow options.</source>
          <target state="translated">하이픈으로 시작하지 않는 인수는 렌더링 할 서브 루틴 또는 형식의 이름으로 간주됩니다. 그러한 함수가 지정되지 않으면 프로그램의 본문 (서브 루틴 외부, use'd 또는 require'd 파일은 포함하지 않음)이 렌더링됩니다. 전달 &lt;code&gt;BEGIN&lt;/code&gt; , &lt;code&gt;UNITCHECK&lt;/code&gt; 는 , &lt;code&gt;CHECK&lt;/code&gt; , &lt;code&gt;INIT&lt;/code&gt; , 또는 &lt;code&gt;END&lt;/code&gt; 는 해당 특수 블록의 모든 인쇄하게됩니다. 인수는 옵션을 따라야합니다.</target>
        </trans-unit>
        <trans-unit id="ce73d1bc99ee20ea72fd21908b3617e55e0813cc" translate="yes" xml:space="preserve">
          <source>Arguments to &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/syswrite&quot;&gt;syswrite&lt;/a&gt;&lt;/code&gt; are &lt;b&gt;not&lt;/b&gt; checked for taintedness.</source>
          <target state="translated">인수하는 &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;functions/syswrite&quot;&gt;syswrite&lt;/a&gt;&lt;/code&gt; 되어 &lt;b&gt;있지&lt;/b&gt; taintedness 검사.</target>
        </trans-unit>
        <trans-unit id="4006b3311082c7bd892aab6f8d46c918fb22f118" translate="yes" xml:space="preserve">
          <source>Arguments to &lt;code&gt;print&lt;/code&gt; and &lt;code&gt;syswrite&lt;/code&gt; are &lt;b&gt;not&lt;/b&gt; checked for taintedness.</source>
          <target state="translated">인수하는 &lt;code&gt;print&lt;/code&gt; 및 &lt;code&gt;syswrite&lt;/code&gt; 되어 &lt;b&gt;있지&lt;/b&gt; taintedness 검사.</target>
        </trans-unit>
        <trans-unit id="5b24aafc030974a768212046c7dad5ef0c74d247" translate="yes" xml:space="preserve">
          <source>Arguments to Tests</source>
          <target state="translated">테스트에 대한 인수</target>
        </trans-unit>
        <trans-unit id="253657f116857073367b6474bc4203deb4236cb2" translate="yes" xml:space="preserve">
          <source>Arguments to be added to the command line</source>
          <target state="translated">명령 행에 추가 할 인수</target>
        </trans-unit>
        <trans-unit id="ef74aa3554ce37f3e92c7ca867fc499504f0b195" translate="yes" xml:space="preserve">
          <source>Arguments to these commands are either strings exactly matching the identification string of an object, or regular expressions matched case-insensitively against various attributes of the objects. The parser only recognizes a regular expression when you enclose it with slashes.</source>
          <target state="translated">이 명령에 대한 인수는 객체의 식별 문자열과 정확히 일치하는 문자열이거나 객체의 다양한 속성에 대해 대소 문자를 구분하지 않는 정규식입니다. 파서는 정규식을 슬래시로 묶을 때만 인식합니다.</target>
        </trans-unit>
        <trans-unit id="a0478ca5f4c068ca3ac12f9474f6a15865ce9053" translate="yes" xml:space="preserve">
          <source>Arguments:</source>
          <target state="translated">Arguments:</target>
        </trans-unit>
        <trans-unit id="2007b9d426cd74d2705e9cb985a4b287291d5413" translate="yes" xml:space="preserve">
          <source>Arguments: COUNT is the number of times to run the loop, and CODE is the code to run. CODE may be either a code reference or a string to be eval'd; either way it will be run in the caller's package.</source>
          <target state="translated">인수 : COUNT는 루프를 실행하는 횟수이고 CODE는 실행할 코드입니다. CODE는 코드 참조이거나 평가할 문자열 일 수 있습니다. 어느 쪽이든 호출자의 패키지에서 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="504073c25d9741031e514c8e9e91bef33965e548" translate="yes" xml:space="preserve">
          <source>Arguments: TIME is the minimum length of time to run CODE for, and CODE is the code to run. CODE may be either a code reference or a string to be eval'd; either way it will be run in the caller's package.</source>
          <target state="translated">인수 : TIME은 CODE를 실행하는 최소 시간 길이이며 CODE는 실행할 코드입니다. CODE는 코드 참조이거나 평가할 문자열 일 수 있습니다. 어느 쪽이든 호출자의 패키지에서 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="38bfcf708d6931f7d42f920765aaabb5369a9058" translate="yes" xml:space="preserve">
          <source>Aristotle</source>
          <target state="translated">Aristotle</target>
        </trans-unit>
        <trans-unit id="45f053dc732762c8c17889da40821807b746247b" translate="yes" xml:space="preserve">
          <source>Arithmetic</source>
          <target state="translated">Arithmetic</target>
        </trans-unit>
        <trans-unit id="aa4a9120c32b4442874b4d46d816ed7dd9bbe6c6" translate="yes" xml:space="preserve">
          <source>Arithmetic methods</source>
          <target state="translated">산술 방법</target>
        </trans-unit>
        <trans-unit id="d077356b7b5076ff62409f2fbd19527762e29c71" translate="yes" xml:space="preserve">
          <source>Arithmetic operators</source>
          <target state="translated">산술 연산자</target>
        </trans-unit>
        <trans-unit id="e6532be8ff2d954f60f4660f2c54f2ea6702b27e" translate="yes" xml:space="preserve">
          <source>Arithmetic operators during &lt;code&gt;use integer&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;use integer&lt;/code&gt; 중 산술 연산자</target>
        </trans-unit>
        <trans-unit id="104fd3fd5302e037fb8d66ee6c616a71d0739a71" translate="yes" xml:space="preserve">
          <source>Arizona</source>
          <target state="translated">Arizona</target>
        </trans-unit>
        <trans-unit id="2dd1feda95af0eae16b44852b3e991a7320b9877" translate="yes" xml:space="preserve">
          <source>Arnold, Ken and James Gosling. The Java Programming Language, 2nd ed. Addison-Wesley, 1998, ISBN 0-201-31006-6.</source>
          <target state="translated">아놀드, 켄, 제임스 고슬링 자바 프로그래밍 언어, 제 2 판. 애디슨-웨슬리, 1998, ISBN 0-201-31006-6.</target>
        </trans-unit>
        <trans-unit id="f59bbf13db8733c389e26cc50790aefa49bd87eb" translate="yes" xml:space="preserve">
          <source>Around line 755:</source>
          <target state="translated">라인 755 주변 :</target>
        </trans-unit>
        <trans-unit id="c85b5fb626816d8525d58d40352050c4cc00a98a" translate="yes" xml:space="preserve">
          <source>Around line 804:</source>
          <target state="translated">804 행 주변 :</target>
        </trans-unit>
        <trans-unit id="5ab366efdd1504cdfaa681a633d790c9ce967f2c" translate="yes" xml:space="preserve">
          <source>Arranges for &lt;code&gt;sv&lt;/code&gt; to be shared between threads if a suitable module has been loaded.</source>
          <target state="translated">적절한 모듈이로드 된 경우 &lt;code&gt;sv&lt;/code&gt; 가 스레드간에 공유되도록 정렬합니다 .</target>
        </trans-unit>
        <trans-unit id="f2eecdf1f299504d5505f21d414522aaf018f39c" translate="yes" xml:space="preserve">
          <source>Arranges for FILEHANDLE to be read or written in &quot;binary&quot; or &quot;text&quot; mode on systems where the run-time libraries distinguish between binary and text files. If FILEHANDLE is an expression, the value is taken as the name of the filehandle. Returns true on success, otherwise it returns &lt;a href=&quot;#undef-EXPR&quot;&gt;&lt;code&gt;undef&lt;/code&gt;&lt;/a&gt; and sets &lt;a href=&quot;perlvar#%24%21&quot;&gt;&lt;code&gt;$!&lt;/code&gt;&lt;/a&gt; (errno).</source>
          <target state="translated">런타임 라이브러리가 이진 파일과 텍스트 파일을 구분하는 시스템에서 FILEHANDLE을 &quot;이진&quot;또는 &quot;텍스트&quot;모드로 읽거나 쓸 수 있도록 정렬합니다. FILEHANDLE이 표현식이면 값은 파일 핸들의 이름으로 사용됩니다. 성공하면 true를 반환하고, 그렇지 않으면 &lt;a href=&quot;#undef-EXPR&quot;&gt; &lt;code&gt;undef&lt;/code&gt; 를&lt;/a&gt; 반환 하고 &lt;a href=&quot;perlvar#%24%21&quot;&gt; &lt;code&gt;$!&lt;/code&gt; &lt;/a&gt;(errno).</target>
        </trans-unit>
        <trans-unit id="41b85d47773b3148f4f3a1e9d404f9d2d3175fa5" translate="yes" xml:space="preserve">
          <source>Arranges for FILEHANDLE to be read or written in &quot;binary&quot; or &quot;text&quot; mode on systems where the run-time libraries distinguish between binary and text files. If FILEHANDLE is an expression, the value is taken as the name of the filehandle. Returns true on success, otherwise it returns &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; and sets &lt;code&gt;$!&lt;/code&gt; (errno).</source>
          <target state="translated">런타임 라이브러리가 이진 파일과 텍스트 파일을 구별하는 시스템에서 FILEHANDLE을 &quot;이진&quot;또는 &quot;텍스트&quot;모드로 읽거나 쓰도록 정렬합니다. FILEHANDLE이 표현식 인 경우 값은 파일 핸들의 이름으로 사용됩니다. 성공하면 true를 반환하고, 그렇지 않으면 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 를 반환 하고 &lt;code&gt;$!&lt;/code&gt; 설정합니다 ! (errno).</target>
        </trans-unit>
        <trans-unit id="1ffbadba9c3dce1044ad3f375a7830b9eb0ed44f" translate="yes" xml:space="preserve">
          <source>Arranges for FILEHANDLE to be read or written in &quot;binary&quot; or &quot;text&quot; mode on systems where the run-time libraries distinguish between binary and text files. If FILEHANDLE is an expression, the value is taken as the name of the filehandle. Returns true on success, otherwise it returns &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; and sets &lt;code&gt;$!&lt;/code&gt; (errno).</source>
          <target state="translated">런타임 라이브러리가 이진 파일과 텍스트 파일을 구별하는 시스템에서 FILEHANDLE을 &quot;이진&quot;또는 &quot;텍스트&quot;모드로 읽거나 쓰도록 정렬합니다. FILEHANDLE이 표현식 인 경우 값은 파일 핸들의 이름으로 사용됩니다. 성공하면 true를 반환하고, 그렇지 않으면 &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 를 반환 하고 &lt;code&gt;$!&lt;/code&gt; 설정합니다 ! (errno).</target>
        </trans-unit>
        <trans-unit id="9aa41e54fbd34ab084dcbe15fa8b4cafcc06eac6" translate="yes" xml:space="preserve">
          <source>Arranges for a mutual exclusion lock to be obtained on &lt;code&gt;sv&lt;/code&gt; if a suitable module has been loaded.</source>
          <target state="translated">적절한 모듈이로드 된 경우 &lt;code&gt;sv&lt;/code&gt; 에서 획득 할 상호 배제 잠금을 정렬합니다 .</target>
        </trans-unit>
        <trans-unit id="343c9f92b2508f5809b499c36c6237ee53dad8e9" translate="yes" xml:space="preserve">
          <source>Arranges for a mutual exclusion lock to be obtained on sv if a suitable module has been loaded.</source>
          <target state="translated">적합한 모듈이로드 된 경우 sv에서 상호 배제 잠금을 얻도록 정렬합니다.</target>
        </trans-unit>
        <trans-unit id="a5173bbe458c53871d9b1f27fa09a96bfb62b86e" translate="yes" xml:space="preserve">
          <source>Arranges for sv to be shared between threads if a suitable module has been loaded.</source>
          <target state="translated">적합한 모듈이로드 된 경우 sv이 스레드간에 공유되도록 정렬합니다.</target>
        </trans-unit>
        <trans-unit id="77504b93a8457067677bb3cc3aa5311d924675f5" translate="yes" xml:space="preserve">
          <source>Arranges to have a SIGALRM delivered to this process after the specified number of wallclock seconds has elapsed. If SECONDS is not specified, the value stored in &lt;a href=&quot;perlvar#%24_&quot;&gt;&lt;code&gt;$_&lt;/code&gt;&lt;/a&gt; is used. (On some machines, unfortunately, the elapsed time may be up to one second less or more than you specified because of how seconds are counted, and process scheduling may delay the delivery of the signal even further.)</source>
          <target state="translated">지정된 wallclock 초가 경과 한 후이 프로세스에 SIGALRM이 전달되도록합니다. SECONDS를 지정하지 않으면 &lt;a href=&quot;perlvar#%24_&quot;&gt; &lt;code&gt;$_&lt;/code&gt; &lt;/a&gt; 저장된 값 이 사용됩니다. (일부 컴퓨터에서는 초가 계산되는 방식으로 인해 경과 시간이 사용자가 지정한 것보다 최대 1 초 더 적거나 많을 수 있으며, 프로세스 스케줄링으로 인해 신호 전달이 더 지연 될 수 있습니다.)</target>
        </trans-unit>
        <trans-unit id="5e55b4fcd8dbc2fd2ba6c045d961bacb9e292142" translate="yes" xml:space="preserve">
          <source>Arranges to have a SIGALRM delivered to this process after the specified number of wallclock seconds has elapsed. If SECONDS is not specified, the value stored in &lt;code&gt;$_&lt;/code&gt; is used. (On some machines, unfortunately, the elapsed time may be up to one second less or more than you specified because of how seconds are counted, and process scheduling may delay the delivery of the signal even further.)</source>
          <target state="translated">지정된 벽시계 시간 (초)이 경과 한 후이 프로세스에 SIGALRM이 전달되도록 정렬합니다. SECONDS를 지정하지 않으면 &lt;code&gt;$_&lt;/code&gt; 저장된 값 이 사용됩니다. 불행하게도 일부 컴퓨터에서는 경과 시간이 초 계산 방법으로 인해 지정한 시간보다 최대 1 초 이하가 될 수 있으며 프로세스 예약은 신호 전달을 더 지연시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8d25b4a3297455b9e035c6b89f1c17b7c2bce696" translate="yes" xml:space="preserve">
          <source>Array (&lt;code&gt;'@'&lt;/code&gt; or &lt;code&gt;'*@'&lt;/code&gt;)</source>
          <target state="translated">배열 ( &lt;code&gt;'@'&lt;/code&gt; 또는 &lt;code&gt;'*@'&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="fc39e6a09e8f437b433c2957e8745936c343df43" translate="yes" xml:space="preserve">
          <source>Array Interpolation</source>
          <target state="translated">배열 보간</target>
        </trans-unit>
        <trans-unit id="946f892404632d1e1ef312d460522dbcef0e5ca6" translate="yes" xml:space="preserve">
          <source>Array Manipulation Functions</source>
          <target state="translated">배열 조작 함수</target>
        </trans-unit>
        <trans-unit id="380a0ee1c3f2add958e20ae4dd8479917cbbbae8" translate="yes" xml:space="preserve">
          <source>Array holding list of directories to be searched for</source>
          <target state="translated">검색 할 디렉토리 목록을 보유하는 배열</target>
        </trans-unit>
        <trans-unit id="e55ce1c88c52594e868f7dcd4b7c1bf4e8ab55e6" translate="yes" xml:space="preserve">
          <source>Array of extension names to be included when doing a static build. MakeMaker will normally build with all of the installed extensions when doing a static build, and that is usually the desired behavior. If INCLUDE_EXT is present then MakeMaker will build only with those extensions which are explicitly mentioned. (e.g. [ qw( Socket POSIX ) ])</source>
          <target state="translated">정적 빌드를 수행 할 때 포함 할 확장 이름의 배열입니다. 정적 빌드를 수행 할 때 MakeMaker는 일반적으로 설치된 모든 확장으로 빌드되며 이는 일반적으로 원하는 동작입니다. INCLUDE_EXT가 있으면 MakeMaker는 명시 적으로 언급 된 확장명으로 만 빌드합니다. (예 : [qw (Socket POSIX)])</target>
        </trans-unit>
        <trans-unit id="1a8fc45517962d9406be17b19c25fe3aa87b4fd8" translate="yes" xml:space="preserve">
          <source>Array of extension names to exclude when doing a static build. This is ignored if INCLUDE_EXT is present. Consult INCLUDE_EXT for more details. (e.g. [ qw( Socket POSIX ) ] )</source>
          <target state="translated">정적 빌드를 수행 할 때 제외 할 확장명 배열입니다. INCLUDE_EXT가 있으면 무시됩니다. 자세한 내용은 INCLUDE_EXT를 참조하십시오. (예 : [qw (Socket POSIX)])</target>
        </trans-unit>
        <trans-unit id="ab0eedcb736c58c9e1bf3d9da5ea7d522b690f73" translate="yes" xml:space="preserve">
          <source>Array of strings containing name (and email address) of package author(s). Is used in CPAN Meta files (META.yml or META.json) and PPD (Perl Package Description) files for PPM (Perl Package Manager).</source>
          <target state="translated">패키지 작성자의 이름 (및 이메일 주소)을 포함하는 문자열 배열. PPM (Perl Package Manager)의 CPAN 메타 파일 (META.yml 또는 META.json) 및 PPD (Perl Package Description) 파일에서 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="c57f3a7023d5d1d3793f2eb3d27a157609936e28" translate="yes" xml:space="preserve">
          <source>Array of symbol names for variables to be made available as universal symbols. Used only under AIX, OS/2, VMS and Win32 at present. Defaults to []. (e.g. [ qw(Foo_version Foo_numstreams Foo_tree ) ])</source>
          <target state="translated">변수를 범용 기호로 사용할 수 있도록하는 기호 이름 배열. 현재 AIX, OS / 2, VMS 및 Win32에서만 사용됩니다. 기본값은 []입니다. (예 : [qw (Foo_version Foo_numstreams Foo_tree)])</target>
        </trans-unit>
        <trans-unit id="9ab44c94b1ea31feff632108e9870b5e1654c616" translate="yes" xml:space="preserve">
          <source>Array operations, which change the scalars, rearrange them, or add or subtract some scalars, only work on arrays. These can't work on a list, which is fixed. Array operations include &lt;code&gt;&lt;a href=&quot;functions/shift&quot;&gt;shift&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/unshift&quot;&gt;unshift&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/push&quot;&gt;push&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/pop&quot;&gt;pop&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;functions/splice&quot;&gt;splice&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">스칼라를 변경하거나 재정렬하거나 일부 스칼라를 더하거나 빼는 배열 연산은 배열에서만 작동합니다. 이들은 목록에서 작동하지 않으며 고정되어 있습니다. 배열 연산에는 &lt;code&gt;&lt;a href=&quot;functions/shift&quot;&gt;shift&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/unshift&quot;&gt;unshift&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/push&quot;&gt;push&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/pop&quot;&gt;pop&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;functions/splice&quot;&gt;splice&lt;/a&gt;&lt;/code&gt; 가 포함 됩니다.</target>
        </trans-unit>
        <trans-unit id="4a460c81ea3de2b351104bc9016134c2ac95be02" translate="yes" xml:space="preserve">
          <source>Array operations, which change the scalars, rearrange them, or add or subtract some scalars, only work on arrays. These can't work on a list, which is fixed. Array operations include &lt;code&gt;shift&lt;/code&gt;, &lt;code&gt;unshift&lt;/code&gt;, &lt;code&gt;push&lt;/code&gt;, &lt;code&gt;pop&lt;/code&gt;, and &lt;code&gt;splice&lt;/code&gt;.</source>
          <target state="translated">스칼라를 변경하거나 재 배열하거나 일부 스칼라를 더하거나 빼는 배열 작업은 배열에서만 작동합니다. 이것은 수정 된 목록에서 작동하지 않습니다. 배열 작업에는 &lt;code&gt;shift&lt;/code&gt; , &lt;code&gt;unshift&lt;/code&gt; , &lt;code&gt;push&lt;/code&gt; , &lt;code&gt;pop&lt;/code&gt; 및 &lt;code&gt;splice&lt;/code&gt; 가 포함 됩니다.</target>
        </trans-unit>
        <trans-unit id="78674941505b9a2d4a3ebcad653295e98eb9dd4f" translate="yes" xml:space="preserve">
          <source>Array passed to stat will be coerced to a scalar%s</source>
          <target state="translated">stat에 전달 된 배열은 스칼라 % s로 강제 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="b9dd682c69e6440164f6188906ac10fd3b501a3b" translate="yes" xml:space="preserve">
          <source>Array reference of files to examine. May not be specified with &lt;code&gt;dir&lt;/code&gt;.</source>
          <target state="translated">검사 할 파일의 배열 참조입니다. &lt;code&gt;dir&lt;/code&gt; 로 지정할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="e4a46ecccd0814a0e990fda1f36238fc6513b396" translate="yes" xml:space="preserve">
          <source>Array refs</source>
          <target state="translated">배열 참조</target>
        </trans-unit>
        <trans-unit id="70c97244599437a3af8dc620ee670c18edb6906b" translate="yes" xml:space="preserve">
          <source>Array size can be obtained by doing:</source>
          <target state="translated">배열 크기는 다음을 수행하여 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4958f544bd9596999a8c5e79c668a1a1962b374e" translate="yes" xml:space="preserve">
          <source>Array, indexed by opcode, of functions that will be called for the &quot;check&quot; phase of optree building during compilation of Perl code. For most (but not all) types of op, once the op has been initially built and populated with child ops it will be filtered through the check function referenced by the appropriate element of this array. The new op is passed in as the sole argument to the check function, and the check function returns the completed op. The check function may (as the name suggests) check the op for validity and signal errors. It may also initialise or modify parts of the ops, or perform more radical surgery such as adding or removing child ops, or even throw the op away and return a different op in its place.</source>
          <target state="translated">Perl 코드를 컴파일하는 동안 optree 작성의 &quot;확인&quot;단계를 위해 호출 될 함수의 배열 (opcode로 색인화 됨). 대부분의 (전부는 아님) 유형의 op의 경우, op가 처음에 하위 op로 빌드되고 채워지면이 배열의 해당 요소가 참조하는 확인 기능을 통해 필터링됩니다. 새 op는 check 함수에 대한 유일한 인수로 전달되며 check 함수는 완료된 op를 반환합니다. 확인 기능은 (이름에서 알 수 있듯이) 연산의 유효성 및 신호 오류를 확인할 수 있습니다. 또한 작전의 일부를 초기화하거나 수정하거나 하위 작전을 추가하거나 제거하는 등의 과격한 수술을 수행하거나 심지어 작전을 버리고 다른 작전을 대신 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="cbf55f45c7afc72d6bf912afc7befb393f385b76" translate="yes" xml:space="preserve">
          <source>Arrayref containing the facet-data hashes of events nested under this one.</source>
          <target state="translated">여기에 중첩 된 이벤트의 패싯 데이터 해시를 포함하는 Arrayref입니다.</target>
        </trans-unit>
        <trans-unit id="7622ad2f459420f8cf1278b446072cfedac9e366" translate="yes" xml:space="preserve">
          <source>Arrayref. E.g. [qw(archname manext)] defines ARCHNAME &amp;amp; MANEXT from config.sh. MakeMaker will add to CONFIG the following values anyway: ar cc cccdlflags ccdlflags dlext dlsrc ld lddlflags ldflags libc lib_ext obj_ext ranlib sitelibexp sitearchexp so</source>
          <target state="translated">Arrayref. 예를 들어 [qw (archname manext)]는 config.sh에서 ARCHNAME &amp;amp; MANEXT를 정의합니다. MakeMaker는 어쨌든 다음 값을 CONFIG에 추가합니다. ar cc cccdlflags ccdlflags dlext dlsrc ld lddlflags ldflags libc lib_ext obj_ext ranlib sitelibexp sitearchexp so</target>
        </trans-unit>
        <trans-unit id="ac3c8cf1aba574321bc1f66afd6baee7d74ccdb5" translate="yes" xml:space="preserve">
          <source>Arrayref. E.g. [qw(name1 name2)] skip (do not write) sections of the Makefile. Caution! Do not use the SKIP attribute for the negligible speedup. It may seriously damage the resulting Makefile. Only use it if you really need it.</source>
          <target state="translated">Arrayref. 예를 들어 [qw (name1 name2)]는 Makefile의 섹션을 건너 뛰십시오 (쓰기 금지). 주의! 무시할만한 속도 향상을 위해 SKIP 속성을 사용하지 마십시오. 결과적인 Makefile이 심각하게 손상 될 수 있습니다. 정말로 필요한 경우에만 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="b90cc9bfd23567a2ff5ba1f00e7c63ca6da8755e" translate="yes" xml:space="preserve">
          <source>Arrays</source>
          <target state="translated">Arrays</target>
        </trans-unit>
        <trans-unit id="065b62648ae15e66467cb649a0f78784ebc20d69" translate="yes" xml:space="preserve">
          <source>Arrays and slices are interpolated into double-quoted strings by joining the elements with the delimiter specified in the &lt;code&gt;$&quot;&lt;/code&gt; variable (&lt;code&gt;$LIST_SEPARATOR&lt;/code&gt; if &quot;use English;&quot; is specified), space by default. The following are equivalent:</source>
          <target state="translated">배열과 슬라이스는 &lt;code&gt;$LIST_SEPARATOR&lt;/code&gt; &lt;code&gt;$&quot;&lt;/code&gt; 변수 ( &quot;use English; &quot;가 지정된 경우 $ LIST_SEPARATOR)에 지정된 구분 기호로 요소를 결합하여 큰 따옴표로 묶인 문자열로 보간됩니다 . 기본적으로 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="015aea03d19c4f5404b14d2e291f0bb807a559b3" translate="yes" xml:space="preserve">
          <source>Arrays are zero-indexed. Here's how you get at elements in an array:</source>
          <target state="translated">배열은 인덱스가 0입니다. 배열의 요소를 얻는 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="62a56f74931523c8c6be523e0f4189cd13f83348" translate="yes" xml:space="preserve">
          <source>Arrays index from 0. Likewise string positions in substr() and index().</source>
          <target state="translated">인덱스는 0부터 배열합니다. 마찬가지로 substr () 및 index ()의 문자열 위치입니다.</target>
        </trans-unit>
        <trans-unit id="c6d4028b66a4b9402be627f34603725a671721e9" translate="yes" xml:space="preserve">
          <source>Arrays:</source>
          <target state="translated">Arrays:</target>
        </trans-unit>
        <trans-unit id="758bdbae166b00a3d8e1212d185299f382e9e26b" translate="yes" xml:space="preserve">
          <source>Arrow Notation</source>
          <target state="translated">화살표 표기법</target>
        </trans-unit>
        <trans-unit id="d88829ea9618170c7e2c7635ccc9b881ef3d9e85" translate="yes" xml:space="preserve">
          <source>Arrow Rule</source>
          <target state="translated">화살표 규칙</target>
        </trans-unit>
        <trans-unit id="59f3e01c7f1fff089e4fc72d78498e369ebc8aba" translate="yes" xml:space="preserve">
          <source>Article about software localization</source>
          <target state="translated">소프트웨어 현지화 관련 기사</target>
        </trans-unit>
        <trans-unit id="7c422841b7e3951946583038790545c4ed38481b" translate="yes" xml:space="preserve">
          <source>Articles</source>
          <target state="translated">Articles</target>
        </trans-unit>
        <trans-unit id="c2be5dffac8f664ad6e121cb0e6596d1cc2f8c20" translate="yes" xml:space="preserve">
          <source>Articles that are either about &lt;b&gt;DB_File&lt;/b&gt; or make use of it.</source>
          <target state="translated">&lt;b&gt;DB_File&lt;/b&gt; 관련 기사 또는이를 사용 하는 기사 .</target>
        </trans-unit>
        <trans-unit id="a75b4962c21a671a678a35a002d5a9cabe9f37df" translate="yes" xml:space="preserve">
          <source>Artistic License</source>
          <target state="translated">예술적 라이선스</target>
        </trans-unit>
        <trans-unit id="5ec201db4d2d3c7be7bb34f8e626f24de679e0d7" translate="yes" xml:space="preserve">
          <source>Artur Bergman &amp;lt;sky AT crucially DOT net&amp;gt;</source>
          <target state="translated">Artur Bergman &amp;lt;하늘에서 결정적으로 DOT net&amp;gt;</target>
        </trans-unit>
        <trans-unit id="8abf83e588a6f8dbd23df54124d573a8d6e50b02" translate="yes" xml:space="preserve">
          <source>Artur Bergman, &quot;Where Wizards Fear To Tread&quot;, June 11, 2002, &lt;a href=&quot;http://www.perl.com/pub/a/2002/06/11/threads.html&quot;&gt;http://www.perl.com/pub/a/2002/06/11/threads.html&lt;/a&gt;</source>
          <target state="translated">Artur Bergman, &quot;마법사가 두려워하는 곳&quot;, 2002 년 6 월 11 일, &lt;a href=&quot;http://www.perl.com/pub/a/2002/06/11/threads.html&quot;&gt;http://www.perl.com/pub/a/2002/06/11/threads.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="9d31985fda87b26d6554bcfbfe7dbc398b51917e" translate="yes" xml:space="preserve">
          <source>As</source>
          <target state="translated">As</target>
        </trans-unit>
        <trans-unit id="47c29ec0c3f7f05bae80de5283a0b030f441a291" translate="yes" xml:space="preserve">
          <source>As &lt;a href=&quot;../functions/stat&quot;&gt;stat&lt;/a&gt; or &lt;a href=&quot;../functions/lstat&quot;&gt;lstat&lt;/a&gt; but with the access/modify/change file timestamps in subsecond resolution, if the operating system and the filesystem both support such timestamps. To override the standard stat():</source>
          <target state="translated">으로 &lt;a href=&quot;../functions/stat&quot;&gt;합계&lt;/a&gt; 또는 &lt;a href=&quot;../functions/lstat&quot;&gt;lstat는&lt;/a&gt; 하지만 초 미만 해상도의 액세스 / 수정 / 변경 파일 타임 스탬프와 운영 체제 및 파일 시스템을 모두 지원 등의 타임 스탬프 경우. 표준 stat ()를 재정의하려면</target>
        </trans-unit>
        <trans-unit id="cad0de4aeb2435c3e6250aa64da21872a52c4d61" translate="yes" xml:space="preserve">
          <source>As &lt;a href=&quot;perlfunc#stat&quot;&gt;&quot;stat&quot; in perlfunc&lt;/a&gt; or &lt;a href=&quot;perlfunc#lstat&quot;&gt;&quot;lstat&quot; in perlfunc&lt;/a&gt; but with the access/modify/change file timestamps in subsecond resolution, if the operating system and the filesystem both support such timestamps. To override the standard stat():</source>
          <target state="translated">로 &lt;a href=&quot;perlfunc#stat&quot;&gt;을 perlfunc에서 &quot;통계&quot;&lt;/a&gt; 또는 &lt;a href=&quot;perlfunc#lstat&quot;&gt;&quot;lstat는&quot;을 perlfunc에&lt;/a&gt; 있지만 초 미만 해상도의 액세스 / 수정 / 변경 파일 타임 스탬프와, 경우 운영 체제 및 파일 시스템을 모두 지원 등의 타임 스탬프. 표준 stat ()를 재정의하려면 :</target>
        </trans-unit>
        <trans-unit id="674c2b9678e49fe5c48ffe3cac937cee6706d2ff" translate="yes" xml:space="preserve">
          <source>As &lt;a href=&quot;perlfunc#utime&quot;&gt;&quot;utime&quot; in perlfunc&lt;/a&gt; but with the ability to set the access/modify file timestamps in subsecond resolution, if the operating system and the filesystem, and the mount options of the filesystem, all support such timestamps.</source>
          <target state="translated">로 &lt;a href=&quot;perlfunc#utime&quot;&gt;을 perlfunc에서 &quot;utime와&quot;&lt;/a&gt; 하지만 / 액세스를 설정, 초 미만의 해상도 파일 타임 스탬프를 수정하는 기능을 운영 체제 및 파일 시스템과 파일 시스템의 마운트 옵션을 모두 지원 등의 타임 스탬프 경우.</target>
        </trans-unit>
        <trans-unit id="02b2b57eecbbd649395f996ef53060747f75fc9c" translate="yes" xml:space="preserve">
          <source>As &lt;b&gt;-nok&lt;/b&gt; except it will report on older systems.</source>
          <target state="translated">으로 &lt;b&gt;-nok&lt;/b&gt; 은 이전 시스템에보고합니다 제외.</target>
        </trans-unit>
        <trans-unit id="4859922e8f70272693e823f3867ed24a92199eaa" translate="yes" xml:space="preserve">
          <source>As &lt;b&gt;-ok&lt;/b&gt; except it will report on older systems.</source>
          <target state="translated">으로 &lt;b&gt;-ok&lt;/b&gt; 는 이전 시스템에보고합니다 제외.</target>
        </trans-unit>
        <trans-unit id="11468a3ea9b3583c1d2e6860cce82a44a9b04f63" translate="yes" xml:space="preserve">
          <source>As &lt;code&gt;$form_name&lt;/code&gt; , one of the following names must be given.</source>
          <target state="translated">으로 &lt;code&gt;$form_name&lt;/code&gt; , 다음 이름 중 하나를 부여해야합니다.</target>
        </trans-unit>
        <trans-unit id="bdbf26fc42681222abf14a2b96b2aee6d500b3fc" translate="yes" xml:space="preserve">
          <source>As &lt;code&gt;$form_name&lt;/code&gt;, one of the following names must be given.</source>
          <target state="translated">으로 &lt;code&gt;$form_name&lt;/code&gt; , 다음 이름 중 하나를 부여해야합니다.</target>
        </trans-unit>
        <trans-unit id="2779b0caf565b7a913bad43d8e6bc994f2a3b086" translate="yes" xml:space="preserve">
          <source>As &lt;code&gt;-Dm&lt;/code&gt; is using the PerlIO layer for output, it will by itself allocate quite a bunch of SVs, which are hidden to avoid recursion. You can bypass the PerlIO layer if you use the SV logging provided by &lt;code&gt;-DPERL_MEM_LOG&lt;/code&gt; instead.</source>
          <target state="translated">으로 &lt;code&gt;-Dm&lt;/code&gt; 출력의은 PerlIO 층을 사용하고, 그 자체는 피할 재귀에 숨겨져의 SV 꽤 무리를 할당합니다으로. &lt;code&gt;-DPERL_MEM_LOG&lt;/code&gt; 에서 제공 한 SV 로깅을 대신 사용하면 PerlIO 계층을 무시할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2a4f04aeb40af858ae530be27c732d3a12776244" translate="yes" xml:space="preserve">
          <source>As DSM is a trimmed-down Linux system, it lacks many of the tools and libraries commonly found on Linux. The basic tools like sh, cp, rm, etc. are implemented using &lt;a href=&quot;https://en.wikipedia.org/wiki/BusyBox&quot;&gt;BusyBox&lt;/a&gt;.</source>
          <target state="translated">DSM은 축소 된 Linux 시스템이므로 Linux에서 일반적으로 발견되는 많은 도구와 라이브러리가 부족합니다. sh, cp, rm 등과 같은 기본 도구는 &lt;a href=&quot;https://en.wikipedia.org/wiki/BusyBox&quot;&gt;BusyBox를&lt;/a&gt; 사용하여 구현됩니다 .</target>
        </trans-unit>
        <trans-unit id="37a9797fcef19ae902b7dc1fdcbae68c956c3e1b" translate="yes" xml:space="preserve">
          <source>As I work on a particular part of my module it's most likely that the tests that cover that code will fail. I'd like to run the whole test suite but have it prioritize these 'hot' tests. I can tell prove to do this:</source>
          <target state="translated">모듈의 특정 부분을 작업 할 때 해당 코드를 다루는 테스트가 실패 할 가능성이 가장 큽니다. 전체 테스트 스위트를 실행하고 싶지만 이러한 '핫'테스트의 우선 순위를 지정합니다. 나는 이것을 증명할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3f4dc14381957936768414e0ffe59b0595e92060" translate="yes" xml:space="preserve">
          <source>As JSON cannot directly represent Perl objects, you have to choose between a pure JSON representation (without the ability to deserialise the object automatically again), and a nonstandard extension to the JSON syntax, tagged values.</source>
          <target state="translated">JSON은 Perl 객체를 직접 표현할 수 없으므로 순수한 JSON 표현 (객체를 다시 자동으로 역 직렬화하는 기능이 없음)과 JSON 구문에 대한 비표준 확장 인 태그 값 중에서 선택해야합니다.</target>
        </trans-unit>
        <trans-unit id="67afac02f586f9bebcefbfe5f3e2ccc5758a2739" translate="yes" xml:space="preserve">
          <source>As Perl is developed by a global team of volunteers, our documentation often contains spellings which look funny to</source>
          <target state="translated">전 세계 자원 봉사 팀이 Perl을 개발함에 따라, 우리의 문서에는 종종 우스운 철자가 들어 있습니다.</target>
        </trans-unit>
        <trans-unit id="56f06af6196a2958b2b24cc234e03f482b95a8e2" translate="yes" xml:space="preserve">
          <source>As Storable neither knows nor cares about character sets (although it does know that characters may be more than eight bits wide), any difference in the interpretation of character codes between a host and a target system is your problem. In particular, if host and target use different code points to represent the characters used in the text representation of floating-point numbers, you will not be able be able to exchange floating-point data, even with nstore().</source>
          <target state="translated">Storable은 문자 세트를 알거나 신경 쓰지 않기 때문에 (문자의 너비가 8 비트를 초과 할 수 있음을 알고 있지만) 호스트와 대상 시스템 간의 문자 코드 해석에 차이가있는 것이 문제입니다. 특히 호스트와 대상이 부동 소수점 숫자의 텍스트 표현에 사용 된 문자를 나타 내기 위해 다른 코드 포인트를 사용하는 경우 nstore ()와 함께 부동 소수점 데이터를 교환 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="4eb26264176ff313034cbea4b1e32ac9ca4ff4be" translate="yes" xml:space="preserve">
          <source>As a beginning Perl programmer, your most common use of OO Perl will be in using third-party modules, which are documented below.</source>
          <target state="translated">초창기 Perl 프로그래머로서 OO Perl의 가장 일반적인 사용은 아래에 설명 된 타사 모듈을 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="053c80fe967b67f5a7cb2ee310e9489c54536633" translate="yes" xml:space="preserve">
          <source>As a code reference, e.g.:</source>
          <target state="translated">코드 참조로, 예 :</target>
        </trans-unit>
        <trans-unit id="c668c33e20c8d7992e509e03d3adf2ab76f6474b" translate="yes" xml:space="preserve">
          <source>As a consequence of the fact that &lt;code&gt;:raw&lt;/code&gt; normally pops layers, it usually only makes sense to have it as the only or first element in a layer specification. When used as the first element it provides a known base on which to build e.g.</source>
          <target state="translated">&lt;code&gt;:raw&lt;/code&gt; 는 일반적으로 레이어를 팝 한다는 사실의 결과로 레이어 사양에서 유일한 요소 또는 첫 번째 요소로 사용하는 것이 좋습니다. 첫 번째 요소로 사용될 때 알려진 기초를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="85a48b10d40e66cd4a8aedc3b80bf9f3898c7f18" translate="yes" xml:space="preserve">
          <source>As a consequence, &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; ignores any number or &lt;code&gt;*&lt;/code&gt; after &lt;code&gt;P&lt;/code&gt; .</source>
          <target state="translated">결과적으로 &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; 은 &lt;code&gt;P&lt;/code&gt; 뒤의 숫자 또는 &lt;code&gt;*&lt;/code&gt; 를 무시합니다 .</target>
        </trans-unit>
        <trans-unit id="794de411ca7a9fef9a487a0fcead83c094be14c9" translate="yes" xml:space="preserve">
          <source>As a consequence, &lt;code&gt;pack&lt;/code&gt; ignores any number or &lt;code&gt;*&lt;/code&gt; after &lt;code&gt;P&lt;/code&gt;.</source>
          <target state="translated">결과적으로 &lt;code&gt;pack&lt;/code&gt; 은 &lt;code&gt;P&lt;/code&gt; 뒤에 있는 모든 숫자 또는 &lt;code&gt;*&lt;/code&gt; 를 무시합니다 .</target>
        </trans-unit>
        <trans-unit id="af58dfe35e68f1702e8805a513e543501b556b2f" translate="yes" xml:space="preserve">
          <source>As a consequence, the behavior of the operator % agrees with the behavior of Perl's built-in % operator (as documented in the perlop manpage), and the equation</source>
          <target state="translated">결과적으로 연산자 %의 동작은 Perlop의 내장 % 연산자 (perlop 맨 페이지에 설명 된대로)의 동작과 방정식에 동의합니다.</target>
        </trans-unit>
        <trans-unit id="b71d9a336a26729c423fab79edbbfcd18fbf6683" translate="yes" xml:space="preserve">
          <source>As a convenience, &lt;a href=&quot;IO::Socket&quot;&gt;IO::Socket&lt;/a&gt;'s setsockopt() method will convert a number into a packed byte buffer, and getsockopt() will unpack a byte buffer of the correct size back into a number.</source>
          <target state="translated">편의상 &lt;a href=&quot;IO::Socket&quot;&gt;IO :: Socket&lt;/a&gt; 의 setsockopt () 메서드는 숫자를 압축 된 바이트 버퍼로 변환하고 getsockopt ()는 올바른 크기의 바이트 버퍼를 다시 숫자로 압축 해제합니다.</target>
        </trans-unit>
        <trans-unit id="8ed20c41e94e838dcaa1f2e890809ac53aaadc11" translate="yes" xml:space="preserve">
          <source>As a convenience, &lt;a href=&quot;io/socket&quot;&gt;IO::Socket&lt;/a&gt;'s setsockopt() method will convert a number into a packed byte buffer, and getsockopt() will unpack a byte buffer of the correct size back into a number.</source>
          <target state="translated">편의상 &lt;a href=&quot;io/socket&quot;&gt;IO :: Socket&lt;/a&gt; 의 setsockopt () 메소드는 숫자를 묶음 바이트 버퍼로 변환하고 getsockopt ()는 올바른 크기의 바이트 버퍼를 다시 숫자로 압축 해제합니다.</target>
        </trans-unit>
        <trans-unit id="39dd3ca26236e47c7f0b84b7220b02b39c4ce6f1" translate="yes" xml:space="preserve">
          <source>As a convenience, if only one argument is passed then this argument is assumed to be the name of the test (as in the above examples.)</source>
          <target state="translated">편의상 하나의 인수 만 전달하면이 인수는 위의 예와 같이 테스트 이름으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="1cb03824a7a51fc71299760a7d72ef70c9f7d1d1" translate="yes" xml:space="preserve">
          <source>As a debugging aid, you can force Carp to treat a croak as a confess and a carp as a cluck across</source>
          <target state="translated">디버깅 보조 도구로, 잉어에게 고백을 고백으로, 잉어를 럭키로 취급하게 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5de9c4f1738c3fbc65c8014410d9308c0bceec73" translate="yes" xml:space="preserve">
          <source>As a derived class from Pod::Parser, Pod::PlainText supports the same methods and interfaces. See &lt;a href=&quot;parser&quot;&gt;Pod::Parser&lt;/a&gt; for all the details; briefly, one creates a new parser with &lt;code&gt;Pod::PlainText-&amp;gt;new()&lt;/code&gt; and then calls either parse_from_filehandle() or parse_from_file().</source>
          <target state="translated">Pod :: Parser에서 파생 된 클래스 인 Pod :: PlainText는 동일한 메서드와 인터페이스를 지원합니다. 자세한 내용은 &lt;a href=&quot;parser&quot;&gt;Pod :: Parser&lt;/a&gt; 를 참조 하십시오. 간단히 말해서 &lt;code&gt;Pod::PlainText-&amp;gt;new()&lt;/code&gt; 사용하여 새 파서를 만든 다음 parse_from_filehandle () 또는 parse_from_file ()을 호출합니다.</target>
        </trans-unit>
        <trans-unit id="64d726339f8e6e60df57582ad6893533391488ae" translate="yes" xml:space="preserve">
          <source>As a derived class from Pod::Simple, Pod::Man supports the same methods and interfaces. See &lt;a href=&quot;Pod::Simple&quot;&gt;Pod::Simple&lt;/a&gt; for all the details.</source>
          <target state="translated">Pod :: Simple에서 파생 된 클래스 인 Pod :: Man은 동일한 메서드와 인터페이스를 지원합니다. 자세한 내용은 &lt;a href=&quot;Pod::Simple&quot;&gt;Pod :: Simple&lt;/a&gt; 을 참조 하세요.</target>
        </trans-unit>
        <trans-unit id="f6ec952fc34afc28085390c8d52daf19e0a80643" translate="yes" xml:space="preserve">
          <source>As a derived class from Pod::Simple, Pod::Man supports the same methods and interfaces. See &lt;a href=&quot;simple&quot;&gt;Pod::Simple&lt;/a&gt; for all the details.</source>
          <target state="translated">Pod :: Simple에서 파생 된 클래스 인 Pod :: Man은 동일한 메소드와 인터페이스를 지원합니다. 자세한 내용은 &lt;a href=&quot;simple&quot;&gt;Pod :: Simple&lt;/a&gt; 을 참조 하십시오.</target>
        </trans-unit>
        <trans-unit id="7614b2907ce626d34be33e5f930e92fbced576b9" translate="yes" xml:space="preserve">
          <source>As a derived class from Pod::Simple, Pod::Text supports the same methods and interfaces. See &lt;a href=&quot;Pod::Simple&quot;&gt;Pod::Simple&lt;/a&gt; for all the details; briefly, one creates a new parser with &lt;code&gt;Pod::Text-&amp;gt;new()&lt;/code&gt; and then normally calls parse_file().</source>
          <target state="translated">Pod :: Simple에서 파생 된 클래스 인 Pod :: Text는 동일한 메서드와 인터페이스를 지원합니다. 자세한 내용은 &lt;a href=&quot;Pod::Simple&quot;&gt;Pod :: Simple&lt;/a&gt; 을 참조 하십시오. 간단히, &lt;code&gt;Pod::Text-&amp;gt;new()&lt;/code&gt; Text- &amp;gt; new ()를 사용하여 새 파서를 만든 다음 일반적으로 parse_file ()을 호출합니다.</target>
        </trans-unit>
        <trans-unit id="3e4fc5bdbe388e6ddf3cda0d8bc20220f607ea7d" translate="yes" xml:space="preserve">
          <source>As a derived class from Pod::Simple, Pod::Text supports the same methods and interfaces. See &lt;a href=&quot;simple&quot;&gt;Pod::Simple&lt;/a&gt; for all the details; briefly, one creates a new parser with &lt;code&gt;Pod::Text-&amp;gt;new()&lt;/code&gt; and then normally calls parse_file().</source>
          <target state="translated">Pod :: Simple에서 파생 된 클래스 인 Pod :: Text는 동일한 메서드와 인터페이스를 지원합니다. 자세한 내용은 &lt;a href=&quot;simple&quot;&gt;포드 :: 단순&lt;/a&gt; 을 참조 하십시오. 간단히 말해서 &lt;code&gt;Pod::Text-&amp;gt;new()&lt;/code&gt; Text- &amp;gt; new ()를 사용하여 새 파서를 만든 다음 일반적으로 parse_file ()을 호출합니다.</target>
        </trans-unit>
        <trans-unit id="b23f74daa8f57475a4ba46fd4485f5b745823a7e" translate="yes" xml:space="preserve">
          <source>As a final remark, note that one can fill %subr by</source>
          <target state="translated">마지막으로, % subr을 다음과 같이 채울 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4cc64b626e2a5166499114ddf2d5328e019929e3" translate="yes" xml:space="preserve">
          <source>As a final thought, remember that it's not (at the time of writing) possible to produce a useful program which will run in zero or negative time and this basic principle can be written as:</source>
          <target state="translated">마지막으로, 0 또는 음수 시간에 실행되는 유용한 프로그램을 생성 할 수 없으며 작성하는 것이 불가능하며이 기본 원칙은 다음과 같이 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b93fce445dda74a4e62d212ddcfc5d79912e276b" translate="yes" xml:space="preserve">
          <source>As a final word of warning, if you're using adb, &lt;code&gt;make test&lt;/code&gt; may appear to hang; this is because it doesn't output anything until it finishes running all tests. You can check its progress by logging into the device, moving to</source>
          <target state="translated">마지막 경고로 adb를 사용하는 경우 &lt;code&gt;make test&lt;/code&gt; 가 중단 된 것처럼 보일 수 있습니다. 이것은 모든 테스트 실행이 끝날 때까지 아무것도 출력하지 않기 때문입니다. 기기에 로그인하여 진행 상황을 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c76d7d0ab08773eceae9495e1336acd5bdc1e071" translate="yes" xml:space="preserve">
          <source>As a further example, this means that if you wanted to put these bits of code in &lt;code&gt;C&lt;/code&gt; (code) style:</source>
          <target state="translated">추가 예를 들어, 이러한 코드를 &lt;code&gt;C&lt;/code&gt; (코드) 스타일 로 배치하려면 다음을 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="a5d5c5dbed3ae73f59f4d512802a9cfe627521f0" translate="yes" xml:space="preserve">
          <source>As a further example: At time of writing, no &quot;biblio&quot; identifier is supported, but suppose some processor were written to recognize it as a way of (say) denoting a bibliographic reference (necessarily containing formatting codes in ordinary paragraphs). The fact that &quot;biblio&quot; paragraphs were meant for ordinary processing would be indicated by prefacing each &quot;biblio&quot; identifier with a colon:</source>
          <target state="translated">추가 예 : 작성시 &quot;biblio&quot;식별자가 지원되지 않지만 일부 프로세서가 서지 참조를 나타내는 방법 (예 : 일반 단락에 형식화 코드를 포함해야 함)으로 인식하도록 작성되었다고 가정하십시오. &quot;biblio&quot;단락이 일반적인 처리를 위해 사용되었다는 사실은 각 &quot;biblio&quot;식별자 앞에 콜론을 붙여서 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="32e712936b7f11c5ab2eb3ed80fcfadcc776b710" translate="yes" xml:space="preserve">
          <source>As a further optimisation, on exit from the eval block in the &lt;code&gt;FETCH&lt;/code&gt; , execution of the code following the block is still carried on in the inner loop. When an exception is raised, &lt;code&gt;docatch&lt;/code&gt; compares the &lt;code&gt;JMPENV&lt;/code&gt; level of the &lt;code&gt;CxEVAL&lt;/code&gt; with &lt;code&gt;PL_top_env&lt;/code&gt; and if they differ, just re-throws the exception. In this way any inner loops get popped.</source>
          <target state="translated">추가 최적화로서, &lt;code&gt;FETCH&lt;/code&gt; 의 평가 블록으로부터 나올 때, 블록 다음의 코드의 실행은 여전히 ​​내부 루프에서 수행된다. 예외가 발생하면 &lt;code&gt;docatch&lt;/code&gt; 는 CxEVAL 의 &lt;code&gt;JMPENV&lt;/code&gt; 레벨을 &lt;code&gt;CxEVAL&lt;/code&gt; 와 &lt;code&gt;PL_top_env&lt;/code&gt; 하고 다른 경우 예외를 다시 발생시킵니다. 이런 식으로 내부 루프가 튀어 나옵니다.</target>
        </trans-unit>
        <trans-unit id="52bd4fd38df2dbb2fd4340b3f74e473ef3bdf3bc" translate="yes" xml:space="preserve">
          <source>As a further optimisation, on exit from the eval block in the &lt;code&gt;FETCH&lt;/code&gt;, execution of the code following the block is still carried on in the inner loop. When an exception is raised, &lt;code&gt;docatch&lt;/code&gt; compares the &lt;code&gt;JMPENV&lt;/code&gt; level of the &lt;code&gt;CxEVAL&lt;/code&gt; with &lt;code&gt;PL_top_env&lt;/code&gt; and if they differ, just re-throws the exception. In this way any inner loops get popped.</source>
          <target state="translated">추가 최적화로 &lt;code&gt;FETCH&lt;/code&gt; 의 eval 블록을 종료 할 때 블록 뒤 의 코드 실행은 여전히 ​​내부 루프에서 수행됩니다. 예외가 발생하면 &lt;code&gt;docatch&lt;/code&gt; 는 CxEVAL 의 &lt;code&gt;JMPENV&lt;/code&gt; 수준을 &lt;code&gt;CxEVAL&lt;/code&gt; 와 &lt;code&gt;PL_top_env&lt;/code&gt; 하고 다른 경우 예외를 다시 발생시킵니다. 이런 식으로 내부 루프가 터집니다.</target>
        </trans-unit>
        <trans-unit id="3a1271bc4a381b470fd6a076ccacce4ffa6ad068" translate="yes" xml:space="preserve">
          <source>As a further performance optimisation, the various &lt;code&gt;PUSH&lt;/code&gt; macros all operate using a local variable &lt;code&gt;SP&lt;/code&gt;, rather than the interpreter-global variable &lt;code&gt;PL_stack_sp&lt;/code&gt;. This variable is declared by the &lt;code&gt;dSP&lt;/code&gt; macro - though it is normally implied by XSUBs and similar so it is rare you have to consider it directly. Once declared, the &lt;code&gt;PUSH&lt;/code&gt; macros will operate only on this local variable, so before invoking any other perl core functions you must use the &lt;code&gt;PUTBACK&lt;/code&gt; macro to return the value from the local &lt;code&gt;SP&lt;/code&gt; variable back to the interpreter variable. Similarly, after calling a perl core function which may have had reason to move the stack or push/pop values to it, you must use the &lt;code&gt;SPAGAIN&lt;/code&gt; macro which refreshes the local &lt;code&gt;SP&lt;/code&gt; value back from the interpreter one.</source>
          <target state="translated">추가 성능 최적화로 다양한 &lt;code&gt;PUSH&lt;/code&gt; 매크로는 모두 인터프리터 전역 변수 &lt;code&gt;PL_stack_sp&lt;/code&gt; 대신 로컬 변수 &lt;code&gt;SP&lt;/code&gt; 를 사용하여 작동합니다 . 이 변수는 &lt;code&gt;dSP&lt;/code&gt; 매크로에 의해 선언됩니다. 일반적으로 XSUB에 의해 암시되며 유사하므로 직접 고려해야하는 경우는 드뭅니다. 일단 선언되면 &lt;code&gt;PUSH&lt;/code&gt; 매크로는이 로컬 변수에서만 작동하므로 다른 펄 코어 함수를 호출하기 전에 &lt;code&gt;PUTBACK&lt;/code&gt; 매크로를 사용 하여 로컬 &lt;code&gt;SP&lt;/code&gt; 에서 값을 반환 해야합니다.변수를 인터프리터 변수로 되돌립니다. 마찬가지로 스택 또는 푸시 / 팝 값을 이동할 이유가있을 수있는 펄 코어 함수를 호출 한 후 인터프리터에서 로컬 &lt;code&gt;SP&lt;/code&gt; 값을 다시 새로 고치는 &lt;code&gt;SPAGAIN&lt;/code&gt; 매크로를 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="23702715810537d7f01f041b430e67e396dff672" translate="yes" xml:space="preserve">
          <source>As a general rule of thumb, your commit message should help a programmer who knows the Perl core quickly understand what you were trying to do, how you were trying to do it, and why the change matters to Perl.</source>
          <target state="translated">일반적으로 커밋 메시지는 Perl 코어를 아는 프로그래머가 수행하려는 작업, 수행 방법 및 변경이 Perl에 중요한 이유를 신속하게 이해하는 데 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="4e47a1601663426f056fd202a23442a94b37a934" translate="yes" xml:space="preserve">
          <source>As a general rule you should</source>
          <target state="translated">일반적으로</target>
        </trans-unit>
        <trans-unit id="f1a7ae8ef2fbb4b6cb7127db887caa429f079e93" translate="yes" xml:space="preserve">
          <source>As a general rule, if the module is trying to be object oriented then export nothing. If it's just a collection of functions then &lt;code&gt;@EXPORT_OK&lt;/code&gt; anything but use &lt;code&gt;@EXPORT&lt;/code&gt; with caution. For function and method names use barewords in preference to names prefixed with ampersands for the export lists.</source>
          <target state="translated">일반적으로 모듈이 객체 지향적이라면 아무것도 내 보내지 않습니다. 함수 모음 인 경우 &lt;code&gt;@EXPORT&lt;/code&gt; _OK &lt;code&gt;@EXPORT_OK&lt;/code&gt; @EXPORT 를 사용하지만 주의해서 사용하십시오. 함수 및 메소드 이름의 경우 내보내기 목록에 앰퍼샌드가 접두어로 붙은 이름보다 기본 단어를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="e17549d186f2cd9b2973080585cd98536cba2f89" translate="yes" xml:space="preserve">
          <source>As a general rule, if the module is trying to be object oriented then export nothing. If it's just a collection of functions then @EXPORT_OK anything but use @EXPORT with caution.</source>
          <target state="translated">일반적으로 모듈이 객체 지향적이라면 아무것도 내 보내지 않습니다. 함수 모음 인 경우 @EXPORT_OK 외에 @EXPORT를 사용하지만주의해서 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="433c99eba76250876af9c971ad06d88a2549474f" translate="yes" xml:space="preserve">
          <source>As a general rule, if the module is trying to be object-oriented then don't export anything. If it's just a collection of functions and variables, then you can export them via another array, called &lt;code&gt;@EXPORT_OK&lt;/code&gt; . This array does not automatically place its subroutine and variable names into the namespace unless the user specifically requests that this be done.</source>
          <target state="translated">일반적으로 모듈이 객체 지향적이라면 아무것도 내 보내지 마십시오. 함수와 변수의 모음 일 경우 &lt;code&gt;@EXPORT_OK&lt;/code&gt; 라는 다른 배열을 통해 내보낼 수 있습니다 . 이 배열은 사용자가 특별히 요청하지 않는 한 서브 루틴 및 변수 이름을 네임 스페이스에 자동으로 배치하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d1e3854176f62c2a9d9d5efd5fe3ab87123d6cec" translate="yes" xml:space="preserve">
          <source>As a general rule, if the module is trying to be object-oriented then don't export anything. If it's just a collection of functions and variables, then you can export them via another array, called &lt;code&gt;@EXPORT_OK&lt;/code&gt;. This array does not automatically place its subroutine and variable names into the namespace unless the user specifically requests that this be done.</source>
          <target state="translated">일반적으로 모듈이 객체 지향이 되려고하면 아무것도 내 보내지 마십시오. 함수와 변수의 모음 인 경우 &lt;code&gt;@EXPORT_OK&lt;/code&gt; 라는 다른 배열을 통해 내보낼 수 있습니다 . 이 배열은 사용자가 특별히 요청하지 않는 한 서브 루틴 및 변수 이름을 네임 스페이스에 자동으로 배치하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e7b6a2f89138fc36d28abf12c8042d8936138512" translate="yes" xml:space="preserve">
          <source>As a historical predecessor, Microsoft's variant probably has more rights for the name, though it may be objected that Microsoft shouldn't have used JIS as part of the name in the first place.</source>
          <target state="translated">역사적인 전임자로서 Microsoft의 변형은 이름에 대한 더 많은 권한을 가질 수 있지만, 처음에는 Microsoft가 이름의 일부로 JIS를 사용해서는 안된다는 이의를 제기 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a207991a7d026174ee51a8481f0b776cbc48b6ea" translate="yes" xml:space="preserve">
          <source>As a last resort, however:</source>
          <target state="translated">그러나 최후의 수단으로 :</target>
        </trans-unit>
        <trans-unit id="3ab2161dda92a73d5893b103484d832131038b70" translate="yes" xml:space="preserve">
          <source>As a last resort, you can use the perl one-liner:</source>
          <target state="translated">최후의 수단으로 펄 원 라이너를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9a117b27b5618d5856aaaf26d908e957a310a377" translate="yes" xml:space="preserve">
          <source>As a last resort, you could also use &lt;code&gt;PERL5DB&lt;/code&gt; to customize the debugger by directly setting internal variables or calling debugger functions.</source>
          <target state="translated">최후의 수단으로 &lt;code&gt;PERL5DB&lt;/code&gt; 를 사용 하여 내부 변수를 직접 설정하거나 디버거 함수를 호출하여 디버거를 사용자 지정할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3641087c3ef51813afe729b7c79e589f770bbb23" translate="yes" xml:space="preserve">
          <source>As a matter of policy we do &lt;b&gt;not&lt;/b&gt; edit the history of the blead and maint-* branches. If a typo (or worse) sneaks into a commit to blead or maint-*, we'll fix it in another commit. The only types of updates allowed on these branches are &quot;fast-forwards&quot;, where all history is preserved.</source>
          <target state="translated">정책 상 우리는 blead 및 maint- * 브랜치의 역사를 편집 하지 &lt;b&gt;않습니다&lt;/b&gt; . 오타 (또는 더 나쁜)가 blead 또는 maint- * 커밋에 몰래 들어가면 다른 커밋에서 수정합니다. 이러한 분기에서 허용되는 유일한 업데이트 유형은 모든 기록이 보존되는 &quot;빨리 감기&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="04cbbe97dbf5020460c7615ae57692f7d59ba371" translate="yes" xml:space="preserve">
          <source>As a nonstandard extension to the JSON syntax that is enabled by the &lt;code&gt;relaxed&lt;/code&gt; setting, shell-style comments are allowed. They can start anywhere outside strings and go till the end of the line.</source>
          <target state="translated">&lt;code&gt;relaxed&lt;/code&gt; 설정으로 활성화 된 JSON 구문에 대한 비표준 확장으로서 셸 스타일 주석이 허용됩니다. 그들은 문자열 외부에서 시작하여 줄 끝까지 갈 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="46efdbcc9fcabaefc1ffd7ba61888d42081d0818" translate="yes" xml:space="preserve">
          <source>As a noun, a piece of syntax made up of smaller pieces. As a transitive verb, to create an &lt;b&gt;object&lt;/b&gt; using a &lt;b&gt;constructor&lt;/b&gt;.</source>
          <target state="translated">명사로서, 작은 조각으로 구성된 구문 조각. 타동사로서, 생성하는 &lt;b&gt;객체&lt;/b&gt; 사용하여 &lt;b&gt;생성자를&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="d308f1d2a7a4e49c9b329da294e48e6b1847ac8e" translate="yes" xml:space="preserve">
          <source>As a qr// compiled regular expression, e.g.:</source>
          <target state="translated">qr // 컴파일 된 정규 표현식으로, 예 :</target>
        </trans-unit>
        <trans-unit id="3f0cb7718076aa901719a5347944ab158c02cce2" translate="yes" xml:space="preserve">
          <source>As a result of these problems, starting in v5.20, what Perl does is to treat non-Unicode code points as just typical unassigned Unicode characters, and matches accordingly. (Note: Unicode has atypical unassigned code points. For example, it has noncharacter code points, and ones that, when they do get assigned, are destined to be written Right-to-left, as Arabic and Hebrew are. Perl assumes that no non-Unicode code point has any atypical properties.)</source>
          <target state="translated">v5.20부터 이러한 문제의 결과로 Perl이 수행하는 것은 비 유니 코드 코드 포인트를 할당되지 않은 일반적인 유니 코드 문자로 취급하고 그에 따라 일치시키는 것입니다. (참고 : 유니 코드에는 비정형 할당되지 않은 코드 포인트가 있습니다. 예를 들어, 유니 코드가 아닌 코드 포인트가 있으며, 할당 될 때 아랍어와 히브리어와 같이 오른쪽에서 왼쪽으로 쓰여야합니다. 비 유니 코드 코드 포인트에는 비정형 속성이 있습니다.)</target>
        </trans-unit>
        <trans-unit id="dd723ff09f0dfd75022fcfe75451c37784da18b7" translate="yes" xml:space="preserve">
          <source>As a result, &lt;code&gt;$?&lt;/code&gt; will always be zero if the subprocess's exit status indicated successful completion, and non-zero if a warning or error occurred or a program compliant with encoding _POSIX_EXIT values was run and set a status.</source>
          <target state="translated">결과적으로 &lt;code&gt;$?&lt;/code&gt; 서브 프로세스의 종료 상태가 성공적으로 완료되었음을 표시하면 항상 0이되고, 경고 또는 오류가 발생했거나 인코딩 _POSIX_EXIT 값을 준수하는 프로그램이 실행되어 상태를 설정하면 0이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="c26b5ebaa65b4ac15b7d233c58e1a9bb61162748" translate="yes" xml:space="preserve">
          <source>As a scalar operator:</source>
          <target state="translated">스칼라 연산자로서 :</target>
        </trans-unit>
        <trans-unit id="752c53cfef8630f9f583dd0b9dbea60f05156327" translate="yes" xml:space="preserve">
          <source>As a shortcut &lt;code&gt;(*MARK:&lt;i&gt;NAME&lt;/i&gt;)&lt;/code&gt; can be written &lt;code&gt;(*:&lt;i&gt;NAME&lt;/i&gt;)&lt;/code&gt;.</source>
          <target state="translated">바로 가기 &lt;code&gt;(*MARK:&lt;i&gt;NAME&lt;/i&gt;)&lt;/code&gt; 로 쓸 수 있습니다 &lt;code&gt;(*:&lt;i&gt;NAME&lt;/i&gt;)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8274ec69a734737beb00f3f5313b731efea1dc76" translate="yes" xml:space="preserve">
          <source>As a shortcut &lt;code&gt;(*MARK:NAME)&lt;/code&gt; can be written &lt;code&gt;(*:NAME)&lt;/code&gt;.</source>
          <target state="translated">바로 가기 &lt;code&gt;(*MARK:NAME)&lt;/code&gt; 로 쓸 수 있습니다 &lt;code&gt;(*:NAME)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2b9a135b5dd5e3840c9d7b2126bd8f1513618105" translate="yes" xml:space="preserve">
          <source>As a shortcut a one-argument call takes the filename from the global scalar variable of the same name as the filehandle:</source>
          <target state="translated">하나의 인수 호출은 파일 핸들과 같은 이름의 전역 스칼라 변수에서 파일 이름을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="039d51ec286cc421077f33a0f875e9f7cff415a2" translate="yes" xml:space="preserve">
          <source>As a shortcut, a one-argument call takes the filename from the global scalar variable of the same name as the filehandle:</source>
          <target state="translated">바로 가기로 단일 인수 호출은 파일 핸들과 동일한 이름의 전역 스칼라 변수에서 파일 이름을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="9baecd622ad6ae8ccb368a1f47c6a9f4ae3fac55" translate="yes" xml:space="preserve">
          <source>As a shortcut, you can use the module &lt;a href=&quot;../bignum&quot;&gt;bignum&lt;/a&gt;:</source>
          <target state="translated">바로 가기로 &lt;a href=&quot;../bignum&quot;&gt;bignum&lt;/a&gt; 모듈을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="36ff34b524a3157846677e62919073347584851b" translate="yes" xml:space="preserve">
          <source>As a shortcut, you can use the module &lt;a href=&quot;bignum&quot;&gt;bignum&lt;/a&gt;:</source>
          <target state="translated">단축키로 &lt;a href=&quot;bignum&quot;&gt;bignum&lt;/a&gt; 모듈을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5b3e1134bf3b8109ecb5762080e2eff8e1996cc6" translate="yes" xml:space="preserve">
          <source>As a side effect, as &lt;code&gt;_&lt;/code&gt; doesn't work, stacked filetest operators (&lt;code&gt;-f -w $file&lt;/code&gt; ) won't work either.</source>
          <target state="translated">부작용으로 &lt;code&gt;_&lt;/code&gt; 가 작동하지 않기 때문에 스택 &lt;code&gt;-f -w $file&lt;/code&gt; 테스트 연산자 ( -f -w $ file )도 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="62159e969c4500e73917688c4b98b60605e2b166" translate="yes" xml:space="preserve">
          <source>As a side effect, as &lt;code&gt;_&lt;/code&gt; doesn't work, stacked filetest operators (&lt;code&gt;-f -w $file&lt;/code&gt;) won't work either.</source>
          <target state="translated">부작용으로 &lt;code&gt;_&lt;/code&gt; 가 작동하지 않으므로 스택 &lt;code&gt;-f -w $file&lt;/code&gt; 테스트 연산자 ( -f -w $ file )도 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="46d4d9254656022c6da49a40120c1e05ea2c02db" translate="yes" xml:space="preserve">
          <source>As a side effect, calling &lt;a href=&quot;#keys-HASH&quot;&gt;&lt;code&gt;keys&lt;/code&gt;&lt;/a&gt; resets the internal iterator of the HASH or ARRAY (see &lt;a href=&quot;#each-HASH&quot;&gt;&lt;code&gt;each&lt;/code&gt;&lt;/a&gt;) before yielding the keys. In particular, calling &lt;a href=&quot;#keys-HASH&quot;&gt;&lt;code&gt;keys&lt;/code&gt;&lt;/a&gt; in void context resets the iterator with no other overhead.</source>
          <target state="translated">부작용으로 &lt;a href=&quot;#keys-HASH&quot;&gt; &lt;code&gt;keys&lt;/code&gt; &lt;/a&gt; 호출 하면 키를 생성하기 전에 HASH 또는 ARRAY ( &lt;a href=&quot;#each-HASH&quot;&gt; &lt;code&gt;each&lt;/code&gt; &lt;/a&gt; 참조 ) 의 내부 반복기가 재설정 됩니다. 특히, void 컨텍스트에서 &lt;a href=&quot;#keys-HASH&quot;&gt; &lt;code&gt;keys&lt;/code&gt; &lt;/a&gt; 를 호출 하면 다른 오버 헤드없이 반복기가 재설정됩니다.</target>
        </trans-unit>
        <trans-unit id="2e28725785d22d9074c048ed573cb348e22b3201" translate="yes" xml:space="preserve">
          <source>As a side effect, calling &lt;a href=&quot;#values-HASH&quot;&gt;&lt;code&gt;values&lt;/code&gt;&lt;/a&gt; resets the HASH or ARRAY's internal iterator (see &lt;a href=&quot;#each-HASH&quot;&gt;&lt;code&gt;each&lt;/code&gt;&lt;/a&gt;) before yielding the values. In particular, calling &lt;a href=&quot;#values-HASH&quot;&gt;&lt;code&gt;values&lt;/code&gt;&lt;/a&gt; in void context resets the iterator with no other overhead.</source>
          <target state="translated">부작용으로 &lt;a href=&quot;#values-HASH&quot;&gt; &lt;code&gt;values&lt;/code&gt; &lt;/a&gt; 호출 하면 값을 산출하기 전에 HASH 또는 ARRAY의 내부 반복기 ( &lt;a href=&quot;#each-HASH&quot;&gt; &lt;code&gt;each&lt;/code&gt; &lt;/a&gt; 참조 )가 재설정 됩니다. 특히, void 컨텍스트에서 &lt;a href=&quot;#values-HASH&quot;&gt; &lt;code&gt;values&lt;/code&gt; &lt;/a&gt; 을 호출 하면 다른 오버 헤드없이 반복기가 재설정됩니다.</target>
        </trans-unit>
        <trans-unit id="e67c2575fdaa4cadca39640f540c5c1c25ff2b7b" translate="yes" xml:space="preserve">
          <source>As a side effect, calling keys() resets the internal iterator of the HASH or ARRAY (see &lt;a href=&quot;#each&quot;&gt;each&lt;/a&gt;). In particular, calling keys() in void context resets the iterator with no other overhead.</source>
          <target state="translated">부작용으로 keys ()를 호출하면 HASH 또는 ARRAY의 내부 반복기가 재설정됩니다 ( &lt;a href=&quot;#each&quot;&gt;각&lt;/a&gt; 참조 ). 특히, void 컨텍스트에서 keys ()를 호출하면 다른 오버 헤드없이 반복자가 재설정됩니다.</target>
        </trans-unit>
        <trans-unit id="c7b3fa9f58a42d510ccd961956edd3b53e1d0c57" translate="yes" xml:space="preserve">
          <source>As a side effect, calling keys() resets the internal iterator of the HASH or ARRAY (see &lt;a href=&quot;each&quot;&gt;each&lt;/a&gt;). In particular, calling keys() in void context resets the iterator with no other overhead.</source>
          <target state="translated">부작용으로 keys ()를 호출하면 HASH 또는 ARRAY의 내부 반복기가 재설정됩니다 ( &lt;a href=&quot;each&quot;&gt;각&lt;/a&gt; 참조 ). 특히, void 컨텍스트에서 keys ()를 호출하면 다른 오버 헤드없이 반복자가 재설정됩니다.</target>
        </trans-unit>
        <trans-unit id="aa184b78eeef36fa29a1577f9bf8458234354229" translate="yes" xml:space="preserve">
          <source>As a side effect, calling values() resets the HASH or ARRAY's internal iterator, see &lt;a href=&quot;#each&quot;&gt;each&lt;/a&gt;. (In particular, calling values() in void context resets the iterator with no other overhead. Apart from resetting the iterator, &lt;code&gt;&lt;a href=&quot;functions/values&quot;&gt;values&lt;/a&gt; @array&lt;/code&gt; in list context is the same as plain &lt;code&gt;@array&lt;/code&gt; . (We recommend that you use void context &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt; @array&lt;/code&gt; for this, but reasoned that taking &lt;code&gt;&lt;a href=&quot;functions/values&quot;&gt;values&lt;/a&gt; @array&lt;/code&gt; out would require more documentation than leaving it in.)</source>
          <target state="translated">부작용으로, values ​​()를 호출하면 HASH 또는 ARRAY의 내부 반복자가 재설정됩니다 ( &lt;a href=&quot;#each&quot;&gt;각&lt;/a&gt; 참조) . (특히 void 컨텍스트에서 values ​​()를 호출하면 다른 오버 헤드없이 반복자가 재설정됩니다. 반복자를 재설정하는 것 외에도 목록 컨텍스트의 &lt;code&gt;&lt;a href=&quot;functions/values&quot;&gt;values&lt;/a&gt; @array&lt;/code&gt; &lt;a href=&quot;functions/values&quot;&gt;값&lt;/a&gt; 은 일반 &lt;code&gt;@array&lt;/code&gt; 와 동일 합니다. (void context &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt; @array&lt;/code&gt; 사용하는 것이 좋습니다. 이를 위해 &lt;code&gt;&lt;a href=&quot;functions/values&quot;&gt;values&lt;/a&gt; @array&lt;/code&gt; &lt;a href=&quot;functions/values&quot;&gt;값&lt;/a&gt; 을 가져 가면 그대로 두는 것보다 더 많은 문서가 필요하다고 생각했습니다.)</target>
        </trans-unit>
        <trans-unit id="a91a0923e5abea890fdc2bd22bb84126ade104fe" translate="yes" xml:space="preserve">
          <source>As a side effect, calling values() resets the HASH or ARRAY's internal iterator, see &lt;a href=&quot;each&quot;&gt;each&lt;/a&gt;. (In particular, calling values() in void context resets the iterator with no other overhead. Apart from resetting the iterator, &lt;code&gt;&lt;a href=&quot;values&quot;&gt;values&lt;/a&gt; @array&lt;/code&gt; in list context is the same as plain &lt;code&gt;@array&lt;/code&gt; . (We recommend that you use void context &lt;code&gt;&lt;a href=&quot;keys&quot;&gt;keys&lt;/a&gt; @array&lt;/code&gt; for this, but reasoned that taking &lt;code&gt;&lt;a href=&quot;values&quot;&gt;values&lt;/a&gt; @array&lt;/code&gt; out would require more documentation than leaving it in.)</source>
          <target state="translated">부작용으로, values ​​()를 호출하면 HASH 또는 ARRAY의 내부 반복자가 재설정됩니다 ( &lt;a href=&quot;each&quot;&gt;각&lt;/a&gt; 참조) . (특히 void 컨텍스트에서 values ​​()를 호출하면 다른 오버 헤드없이 반복자가 재설정됩니다. 반복자를 재설정하는 것 외에도 목록 컨텍스트의 &lt;code&gt;&lt;a href=&quot;values&quot;&gt;values&lt;/a&gt; @array&lt;/code&gt; &lt;a href=&quot;values&quot;&gt;값&lt;/a&gt; 은 일반 &lt;code&gt;@array&lt;/code&gt; 와 동일 합니다. (void context &lt;code&gt;&lt;a href=&quot;keys&quot;&gt;keys&lt;/a&gt; @array&lt;/code&gt; 사용하는 것이 좋습니다. 이를 위해 &lt;code&gt;&lt;a href=&quot;values&quot;&gt;values&lt;/a&gt; @array&lt;/code&gt; &lt;a href=&quot;values&quot;&gt;값&lt;/a&gt; 을 가져 가면 그대로 두는 것보다 더 많은 문서가 필요하다고 생각했습니다.)</target>
        </trans-unit>
        <trans-unit id="af3e12604d06f443cb762354f1d6409bffc768b2" translate="yes" xml:space="preserve">
          <source>As a side effect, the timestamps of the written specfiles reflect the linear order of all dependencies.</source>
          <target state="translated">부작용으로 작성된 스펙 파일의 타임 스탬프는 모든 종속성의 선형 순서를 반영합니다.</target>
        </trans-unit>
        <trans-unit id="cb674c50cbe5a1c37b1e7edbe788950bfe9342b0" translate="yes" xml:space="preserve">
          <source>As a simple string.</source>
          <target state="translated">간단한 문자열로.</target>
        </trans-unit>
        <trans-unit id="e8e57a1c04bdc517b9206bb149b8d52cd1b60750" translate="yes" xml:space="preserve">
          <source>As a special case</source>
          <target state="translated">특별한 경우로</target>
        </trans-unit>
        <trans-unit id="0643313e18655a38535055ff2dedcaffb5a9d742" translate="yes" xml:space="preserve">
          <source>As a special case for &lt;a href=&quot;#split-%2FPATTERN%2F%2CEXPR%2CLIMIT&quot;&gt;&lt;code&gt;split&lt;/code&gt;&lt;/a&gt;, the empty pattern given in &lt;a href=&quot;perlop#m%2FPATTERN%2Fmsixpodualngc&quot;&gt;match operator&lt;/a&gt; syntax (&lt;code&gt;//&lt;/code&gt;) specifically matches the empty string, which is contrary to its usual interpretation as the last successful match.</source>
          <target state="translated">&lt;a href=&quot;#split-%2FPATTERN%2F%2CEXPR%2CLIMIT&quot;&gt; &lt;code&gt;split&lt;/code&gt; &lt;/a&gt; 의 특별한 경우로 , &lt;a href=&quot;perlop#m%2FPATTERN%2Fmsixpodualngc&quot;&gt;일치 연산자&lt;/a&gt; 구문 ( &lt;code&gt;//&lt;/code&gt; )에 제공된 빈 패턴은 특히 빈 문자열과 일치합니다. 이는 마지막으로 성공한 일치라는 일반적인 해석과 반대입니다.</target>
        </trans-unit>
        <trans-unit id="17ea6c6f4727b11c2b48648599d60dd30f72b5e8" translate="yes" xml:space="preserve">
          <source>As a special case for &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;&lt;/code&gt;, the empty pattern given in &lt;a href=&quot;perlop#m%2fPATTERN%2fmsixpodualngc&quot;&gt;match operator&lt;/a&gt; syntax (&lt;code&gt;//&lt;/code&gt; ) specifically matches the empty string, which is contrary to its usual interpretation as the last successful match.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; 의 특별한 경우로서, &lt;a href=&quot;perlop#m%2fPATTERN%2fmsixpodualngc&quot;&gt;일치 연산자&lt;/a&gt; 구문 ( &lt;code&gt;//&lt;/code&gt; )에 주어진 빈 패턴 은 빈 문자열과 일치합니다. 이는 빈 문자열과 일치합니다.</target>
        </trans-unit>
        <trans-unit id="59db895ceb1feffbf61c972fbfef8ae7b61e3fff" translate="yes" xml:space="preserve">
          <source>As a special case for &lt;code&gt;&lt;a href=&quot;split&quot;&gt;split&lt;/a&gt;&lt;/code&gt;, the empty pattern given in &lt;a href=&quot;../perlop#m%2fPATTERN%2fmsixpodualngc&quot;&gt;match operator&lt;/a&gt; syntax (&lt;code&gt;//&lt;/code&gt; ) specifically matches the empty string, which is contrary to its usual interpretation as the last successful match.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; 의 특별한 경우로서, &lt;a href=&quot;../perlop#m%2fPATTERN%2fmsixpodualngc&quot;&gt;일치 연산자&lt;/a&gt; 구문 ( &lt;code&gt;//&lt;/code&gt; )에 주어진 빈 패턴 은 빈 문자열과 일치합니다. 이는 빈 문자열과 일치합니다.</target>
        </trans-unit>
        <trans-unit id="527a25823c5b741d3ca1303c6cacef3dfa61f467" translate="yes" xml:space="preserve">
          <source>As a special case if the overload returns the object itself then it will be used directly. An overloaded conversion returning the object is probably a bug, because you're likely to get something that looks like &lt;code&gt;YourPackage=HASH(0x8172b34)&lt;/code&gt; .</source>
          <target state="translated">특별한 경우에 과부하가 객체 자체를 반환하면 직접 사용됩니다. &lt;code&gt;YourPackage=HASH(0x8172b34)&lt;/code&gt; 와 같은 것을 얻을 수 있기 때문에 객체를 반환하는 과부하 된 변환은 아마도 버그 일 것입니다 .</target>
        </trans-unit>
        <trans-unit id="a27c6716a696c868b2b90bc0841f6de8cd23a521" translate="yes" xml:space="preserve">
          <source>As a special case if the overload returns the object itself then it will be used directly. An overloaded conversion returning the object is probably a bug, because you're likely to get something that looks like &lt;code&gt;YourPackage=HASH(0x8172b34)&lt;/code&gt;.</source>
          <target state="translated">특별한 경우로 오버로드가 객체 자체를 반환하면 직접 사용됩니다. 객체를 반환하는 오버로드 된 변환은 아마도 버그 일 것입니다. &lt;code&gt;YourPackage=HASH(0x8172b34)&lt;/code&gt; 와 같은 것을 얻을 가능성이 있기 때문 입니다.</target>
        </trans-unit>
        <trans-unit id="6b483703a04a580981cff65069d8ecd06f49d995" translate="yes" xml:space="preserve">
          <source>As a special case the three-argument form with a read/write mode and the third argument being &lt;a href=&quot;#undef-EXPR&quot;&gt;&lt;code&gt;undef&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">특별한 경우로 읽기 / 쓰기 모드와 세 번째 인수가 &lt;a href=&quot;#undef-EXPR&quot;&gt; &lt;code&gt;undef&lt;/code&gt; 인&lt;/a&gt; 3 인수 형식 :</target>
        </trans-unit>
        <trans-unit id="898fa8e40ea8bbaf82f7657e12c724a39a6b933a" translate="yes" xml:space="preserve">
          <source>As a special case the three-argument form with a read/write mode and the third argument being &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">특별한 경우 읽기 / 쓰기 모드와 세 번째 인수는 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 인 세 개의 인수 형식입니다 .</target>
        </trans-unit>
        <trans-unit id="bfe8944e96951a5268014155bb5ff3707aad862a" translate="yes" xml:space="preserve">
          <source>As a special case the three-argument form with a read/write mode and the third argument being &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">특별한 경우 읽기 / 쓰기 모드와 세 번째 인수는 &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 인 세 개의 인수 형식입니다 .</target>
        </trans-unit>
        <trans-unit id="39d0f95cc62f9b7d251ca80f498d915dd0b1187f" translate="yes" xml:space="preserve">
          <source>As a special case, &lt;code&gt;\(@foo)&lt;/code&gt; returns a list of references to the contents of &lt;code&gt;@foo&lt;/code&gt; , not a reference to &lt;code&gt;@foo&lt;/code&gt; itself. Likewise for &lt;code&gt;%foo&lt;/code&gt; , except that the key references are to copies (since the keys are just strings rather than full-fledged scalars).</source>
          <target state="translated">특별한 경우, &lt;code&gt;\(@foo)&lt;/code&gt; 는 &lt;code&gt;@foo&lt;/code&gt; 자체에 대한 참조가 아니라 &lt;code&gt;@foo&lt;/code&gt; 의 내용에 대한 참조 목록을 반환 합니다. 키 참조가 복사에 대한 것임을 제외하고 &lt;code&gt;%foo&lt;/code&gt; 와 마찬가지로 (키는 완전한 스칼라가 아니라 문자열이기 때문에).</target>
        </trans-unit>
        <trans-unit id="783b2ec5714a2b5973ee8fd00ae088eee54cd571" translate="yes" xml:space="preserve">
          <source>As a special case, &lt;code&gt;\(@foo)&lt;/code&gt; returns a list of references to the contents of &lt;code&gt;@foo&lt;/code&gt;, not a reference to &lt;code&gt;@foo&lt;/code&gt; itself. Likewise for &lt;code&gt;%foo&lt;/code&gt;, except that the key references are to copies (since the keys are just strings rather than full-fledged scalars).</source>
          <target state="translated">특별한 경우로, &lt;code&gt;\(@foo)&lt;/code&gt; 는 &lt;code&gt;@foo&lt;/code&gt; 자체에 대한 참조가 아니라 &lt;code&gt;@foo&lt;/code&gt; 의 내용에 대한 참조 목록을 반환 합니다. 키 참조가 복사본에 대한 것이라는 점을 제외하면 &lt;code&gt;%foo&lt;/code&gt; 경우도 마찬가지입니다 (키는 완전한 스칼라가 아니라 문자열 일 뿐이 기 때문입니다).</target>
        </trans-unit>
        <trans-unit id="e559b691f686abba65a2b1bdefbe0a3fb92d6845" translate="yes" xml:space="preserve">
          <source>As a special case, if the constructor is passed a single argument (as opposed to an even-sized list of key/value pairs), it is taken to be the value of the &lt;code&gt;PeerAddr&lt;/code&gt; parameter. This is parsed in the same way, according to the behaviour given in the &lt;code&gt;PeerHost&lt;/code&gt; AND &lt;code&gt;LocalHost&lt;/code&gt; PARSING section below.</source>
          <target state="translated">특별한 경우로 생성자에 단일 인수가 전달되면 (짝수 크기의 키 / 값 쌍 목록과 반대) &lt;code&gt;PeerAddr&lt;/code&gt; 매개 변수 의 값으로 간주 됩니다. 아래 의 &lt;code&gt;PeerHost&lt;/code&gt; 및 &lt;code&gt;LocalHost&lt;/code&gt; PARSING 섹션에 제공된 동작에 따라 동일한 방식으로 구문 분석됩니다.</target>
        </trans-unit>
        <trans-unit id="9d3b4ecbd7d509c41643f820908fd45c356bb919" translate="yes" xml:space="preserve">
          <source>As a special case, if the test in the &lt;code&gt;for&lt;/code&gt; loop (or the corresponding &lt;code&gt;while&lt;/code&gt; loop) is empty, it is treated as true. That is, both</source>
          <target state="translated">특별한 경우, &lt;code&gt;for&lt;/code&gt; 루프 (또는 해당하는 &lt;code&gt;while&lt;/code&gt; 루프) 의 테스트 가 비어 있으면 true로 처리됩니다. 즉, 둘 다</target>
        </trans-unit>
        <trans-unit id="07d1fa15ef1af04fe7ac16e1712ceb861430b28a" translate="yes" xml:space="preserve">
          <source>As a special case, if the value of this variable is space-separated, the tail might be used to disable the ornaments by setting the tail to be &lt;code&gt;o=0&lt;/code&gt; or &lt;code&gt;ornaments=0&lt;/code&gt; . The head should be as described above, say</source>
          <target state="translated">특별한 경우로,이 변수의 값이 공백으로 분리 된 경우, 꼬리는 &lt;code&gt;o=0&lt;/code&gt; 또는 &lt;code&gt;ornaments=0&lt;/code&gt; 으로 설정하여 꼬리를 사용하여 장식품을 비활성화 할 수 있습니다 . 머리는 위에서 설명한대로해야합니다.</target>
        </trans-unit>
        <trans-unit id="ea8552b1560e05c9733562fefc877a4a04a62b1f" translate="yes" xml:space="preserve">
          <source>As a special case, if the value of this variable is space-separated, the tail might be used to disable the ornaments by setting the tail to be &lt;code&gt;o=0&lt;/code&gt; or &lt;code&gt;ornaments=0&lt;/code&gt;. The head should be as described above, say</source>
          <target state="translated">특별한 경우로이 변수의 값이 공백으로 구분 된 경우 꼬리를 &lt;code&gt;o=0&lt;/code&gt; 또는 &lt;code&gt;ornaments=0&lt;/code&gt; 으로 설정하여 장식을 비활성화하는 데 꼬리를 사용할 수 있습니다 . 머리는 위에서 설명한대로되어야합니다.</target>
        </trans-unit>
        <trans-unit id="0fde23ad411d5b9ebf1966fbf214f46640cb22f9" translate="yes" xml:space="preserve">
          <source>As a special case, if you specify the module name &lt;code&gt;Unicode&lt;/code&gt; , you'll get the version number of the Unicode Character Database bundled with the requested perl versions.</source>
          <target state="translated">특별한 경우, 모듈 이름 &lt;code&gt;Unicode&lt;/code&gt; 를 지정 하면 요청 된 perl 버전과 함께 번들로 제공된 유니 코드 문자 데이터베이스의 버전 번호를 얻게됩니다.</target>
        </trans-unit>
        <trans-unit id="ed0f26789d5db7e7c0ccec99b141a92d811bb2de" translate="yes" xml:space="preserve">
          <source>As a special case, if you specify the module name &lt;code&gt;Unicode&lt;/code&gt;, you'll get the version number of the Unicode Character Database bundled with the requested perl versions.</source>
          <target state="translated">특별한 경우로, 모듈 이름 &lt;code&gt;Unicode&lt;/code&gt; 를 지정 하면 요청 된 perl 버전과 함께 번들로 제공되는 Unicode Character Database의 버전 번호를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="03f58faea796a1077f97500a4e213c983487f04c" translate="yes" xml:space="preserve">
          <source>As a special case, when the accessor is called with a hash reference as the sole argument, this causes an assignment of the whole hash element. The object reference is returned.</source>
          <target state="translated">특별한 경우로, 접근자가 해시 참조를 단독 인수로 사용하여 호출하면 전체 해시 요소가 할당됩니다. 객체 참조가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="d80964d39654d27c73a60223b4ebc15d6e6b2f91" translate="yes" xml:space="preserve">
          <source>As a special case, when the accessor is called with an array reference as the sole argument, this causes an assignment of the whole array element. The object reference is returned.</source>
          <target state="translated">특별한 경우로, 접근자를 유일한 인수로 배열 참조와 함께 호출하면 전체 배열 요소가 할당됩니다. 객체 참조가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="261536d85ff532107bd0e6c855c28c78277c6b3c" translate="yes" xml:space="preserve">
          <source>As a special exception, when you slice a list (but not an array or a hash), if the list evaluates to empty, then taking a slice of that empty list will always yield the empty list in turn. Thus:</source>
          <target state="translated">특별한 예외로, 목록을 슬라이스 할 때 (배열이나 해시가 아닌) 목록이 비어있는 것으로 평가되면 해당 빈 목록의 슬라이스를 가져 오면 항상 빈 목록이 생성됩니다. 그러므로:</target>
        </trans-unit>
        <trans-unit id="267a52b216bf364239047183b439e3e80275f9ef" translate="yes" xml:space="preserve">
          <source>As a vendor, you may have a requirement to backport security fixes beyond our 3 year support commitment. We can provide limited support and advice to you as you do so and, where possible will try to apply those patches to the relevant -maint branches in git, though we may or may not choose to make numbered releases or &quot;official&quot; patches available. Contact us at &amp;lt;perl5-security-report@perl.org&amp;gt; to begin that process.</source>
          <target state="translated">공급 업체는 3 년 간의 지원 약속 이상의 보안 수정 사항을 백 포트해야 할 수도 있습니다. 우리는 귀하에게 제한된 지원과 조언을 제공 할 수 있으며, 가능한 경우 git의 관련 maint 브랜치에 해당 패치를 적용하려고 시도하지만 번호가 매겨진 릴리스 또는 &quot;공식&quot;패치를 사용하도록 선택하거나 선택하지 않을 수 있습니다. 해당 프로세스를 시작하려면 &amp;lt;perl5-security-report@perl.org&amp;gt;로 문의하십시오.</target>
        </trans-unit>
        <trans-unit id="f4351851a4bb7c858433022e707056375232e54d" translate="yes" xml:space="preserve">
          <source>As a vendor, you may have a requirement to backport security fixes beyond our 3 year support commitment. We can provide limited support and advice to you as you do so and, where possible will try to apply those patches to the relevant -maint branches in git, though we may or may not choose to make numbered releases or &quot;official&quot; patches available. See &lt;a href=&quot;perlsec#SECURITY-VULNERABILITY-CONTACT-INFORMATION&quot;&gt;&quot;SECURITY VULNERABILITY CONTACT INFORMATION&quot; in perlsec&lt;/a&gt; for details on how to begin that process.</source>
          <target state="translated">공급 업체는 3 년 지원 약정 이후 보안 수정 사항을 백 포트해야 할 수도 있습니다. 우리는 당신이 그렇게 할 때 제한적인 지원과 조언을 제공 할 수 있으며, 가능한 경우 해당 패치를 git의 관련 -maint 브랜치에 적용하려고 노력할 것입니다.하지만 번호가 매겨진 릴리스 나 &quot;공식&quot;패치를 사용 가능하게 할 수도 있고 그렇지 않을 수도 있습니다. 참조 &lt;a href=&quot;perlsec#SECURITY-VULNERABILITY-CONTACT-INFORMATION&quot;&gt;perlsec에서 &quot;보안 취약점 연락처 정보&quot;&lt;/a&gt; 그 과정을 시작하는 방법에 대한 자세한 내용을.</target>
        </trans-unit>
        <trans-unit id="6b767e1ab5bdc22f58c69583808a39ce8aa5393a" translate="yes" xml:space="preserve">
          <source>As a volunteer organization, the commitments we make are heavily dependent on the goodwill and hard work of individuals who have no obligation to contribute to Perl.</source>
          <target state="translated">자원 봉사 단체로서 우리가하는 약속은 Perl에 기여할 의무가없는 개인의 선의와 노력에 크게 좌우됩니다.</target>
        </trans-unit>
        <trans-unit id="b55a4625fdc844badd446c13482f0c20c8caa1b5" translate="yes" xml:space="preserve">
          <source>As above, but the destination node text of the link.</source>
          <target state="translated">위와 같지만 링크의 대상 노드 텍스트입니다.</target>
        </trans-unit>
        <trans-unit id="07731660b460e18f03465884e08d802967534966" translate="yes" xml:space="preserve">
          <source>As all values evaluate to true, a simple &lt;code&gt;if&lt;/code&gt; test is good enough to determine whether an extension is present.</source>
          <target state="translated">모든 값이 true로 평가 &lt;code&gt;if&lt;/code&gt; 확장이 있는지 여부를 판별하기에 충분할 경우 간단한 if 테스트가 적합합니다.</target>
        </trans-unit>
        <trans-unit id="049e8d249c3ad3a2a8b180055568baa12252b047" translate="yes" xml:space="preserve">
          <source>As alluded to earlier you can also declare inlined subs dynamically at BEGIN time if their body consists of a lexically-scoped scalar which has no other references. Only the first example here will be inlined:</source>
          <target state="translated">앞서 언급했듯이 본문이 다른 참조가없는 어휘 범위 스칼라로 구성된 경우 BEGIN 시간에 인라인 서브를 동적으로 선언 할 수도 있습니다. 여기서 첫 번째 예만 인라인됩니다.</target>
        </trans-unit>
        <trans-unit id="40622c1595c0e7b33c82f810ddadd26599013393" translate="yes" xml:space="preserve">
          <source>As alternatives to &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; and &lt;code&gt;||&lt;/code&gt; when used for control flow, Perl provides the &lt;code&gt;and&lt;/code&gt; and &lt;code&gt;or&lt;/code&gt; operators (see below). The short-circuit behavior is identical. The precedence of &lt;code&gt;&quot;and&quot;&lt;/code&gt; and &lt;code&gt;&quot;or&quot;&lt;/code&gt; is much lower, however, so that you can safely use them after a list operator without the need for parentheses:</source>
          <target state="translated">&lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; 및 &lt;code&gt;||&lt;/code&gt; 의 대안으로 제어 흐름에 사용될 때 Perl은 &lt;code&gt;and&lt;/code&gt; 및 &lt;code&gt;or&lt;/code&gt; 연산자를 제공합니다 (아래 참조). 단락 동작은 동일합니다. 그러나 &lt;code&gt;&quot;and&quot;&lt;/code&gt; 및 &lt;code&gt;&quot;or&quot;&lt;/code&gt; 의 우선 순위 는 훨씬 낮아서 괄호없이 목록 연산자 다음에 안전하게 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c44b3a4add0c470afd83290fbaea5d47d3bf3bcb" translate="yes" xml:space="preserve">
          <source>As always with Perl there is more than one way to do it. Below are a few examples of approaches to making common conversions between number representations. This is intended to be representational rather than exhaustive.</source>
          <target state="translated">항상 Perl과 마찬가지로 여러 가지 방법이 있습니다. 다음은 숫자 표현간에 일반적인 변환을 수행하는 방법의 몇 가지 예입니다. 이것은 철저하지 않고 표현하기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="a27e8bc51d6a9b14b4e2235fdc7ebedf28d134bc" translate="yes" xml:space="preserve">
          <source>As always, if any of these are ever officially declared as bugs, they'll be fixed and removed.</source>
          <target state="translated">언제나 그렇듯이 버그가 공식적으로 버그로 선언되면 수정 및 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="43d8cae7f79fc634e42b4fbb6869d40983003e1e" translate="yes" xml:space="preserve">
          <source>As always, setting up a server is little bit more involved than running a client. The model is that the server creates a special kind of socket that does nothing but listen on a particular port for incoming connections. It does this by calling the &lt;code&gt;IO::Socket::INET-&amp;gt;new()&lt;/code&gt; method with slightly different arguments than the client did.</source>
          <target state="translated">항상 그렇듯이 서버 설정은 클라이언트를 실행하는 것보다 조금 더 복잡합니다. 모델은 서버가 들어오는 연결을 위해 특정 포트에서 수신 대기하는 특수한 종류의 소켓을 작성한다는 것입니다. 클라이언트와 약간 다른 인수로 &lt;code&gt;IO::Socket::INET-&amp;gt;new()&lt;/code&gt; 메소드를 호출하여이를 수행합니다.</target>
        </trans-unit>
        <trans-unit id="b052d1d2bb45ec362535f92deef9adc1abd8b3f0" translate="yes" xml:space="preserve">
          <source>As an (ahem) accidental feature, &lt;code&gt;AUTOLOAD&lt;/code&gt; subroutines were looked up as methods (using the &lt;code&gt;@ISA&lt;/code&gt; hierarchy) even when the subroutines to be autoloaded were called as plain functions (e.g. &lt;code&gt;Foo::bar()&lt;/code&gt;), not as methods (e.g. &lt;code&gt;Foo-&amp;gt;bar()&lt;/code&gt; or &lt;code&gt;$obj-&amp;gt;bar()&lt;/code&gt;).</source>
          <target state="translated">(ahem) 우연한 기능으로 &lt;code&gt;AUTOLOAD&lt;/code&gt; 서브 루틴은 자동로드 될 서브 루틴이 메서드 (예 : &lt;code&gt;Foo-&amp;gt;bar()&lt;/code&gt; )가 아닌 일반 함수 (예 : &lt;code&gt;Foo::bar()&lt;/code&gt; ) 로 호출 된 경우에도 메서드 ( &lt;code&gt;@ISA&lt;/code&gt; 계층 사용)로 조회되었습니다. -&amp;gt; bar () 또는 &lt;code&gt;$obj-&amp;gt;bar()&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="90ed318055b1f6119d9ba187aa6944aea5c29dbe" translate="yes" xml:space="preserve">
          <source>As an added convenience, the Digest::SHA module offers routines to calculate keyed hashes using the HMAC-SHA-1/224/256/384/512 algorithms. These services exist in functional form only, and mimic the style and behavior of the</source>
          <target state="translated">편의상 Digest :: SHA 모듈은 HMAC-SHA-1 / 224 / 256 / 384 / 512 알고리즘을 사용하여 키 해시를 계산하는 루틴을 제공합니다. 이러한 서비스는 기능적 형태로만 존재하며 서비스의 스타일과 동작을 모방합니다.</target>
        </trans-unit>
        <trans-unit id="d0e4684ebfef4659c7147a264548f0d1e61303df" translate="yes" xml:space="preserve">
          <source>As an aid in resetting colors, colored() takes a scalar as the first argument and any number of attribute strings as the second argument and returns the scalar wrapped in escape codes so that the attributes will be set as requested before the string and reset to normal after the string. Alternately, you can pass a reference to an array as the first argument, and then the contents of that array will be taken as attributes and color codes and the remainder of the arguments as text to colorize.</source>
          <target state="translated">색상을 재설정하는 데 도움을주기 위해 colored ()는 스칼라를 첫 번째 인수로 사용하고 속성 문자열 수를 두 번째 인수로 사용하고 스칼라를 이스케이프 코드로 래핑하여 속성이 문자열 전에 요청 된대로 설정되어 다음으로 재설정되도록합니다. 문자열 뒤에 정상입니다. 또는 배열에 대한 참조를 첫 번째 인수로 전달한 다음 해당 배열의 내용을 속성 및 색상 코드로, 나머지 인수를 텍스트로 채색 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0317f97de63b01d4c67910fb17a2e6ee0d204ecf" translate="yes" xml:space="preserve">
          <source>As an alternative to subclassing the components I need to change I can attach callbacks to the default classes. TAP::Harness exposes these callbacks:</source>
          <target state="translated">변경해야하는 구성 요소를 서브 클래 싱하는 대신 기본 클래스에 콜백을 연결할 수 있습니다. TAP :: Harness는 다음 콜백을 노출합니다.</target>
        </trans-unit>
        <trans-unit id="9c1670ab0bb7042a354367f8f6979cab460d9b35" translate="yes" xml:space="preserve">
          <source>As an alternative to the above, you may prefer to throw exceptions using the Error module.</source>
          <target state="translated">위의 대안으로 Error 모듈을 사용하여 예외를 throw하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="8f3dc04daa3638b5aaf1c862a68465a157788d9e" translate="yes" xml:space="preserve">
          <source>As an alternative to the named parameters usage, you may pass in an &lt;code&gt;ExtUtils::Typemaps::InputMap&lt;/code&gt; object as first argument, a copy of which will be added to the typemap. In that case, only the &lt;code&gt;replace&lt;/code&gt; or &lt;code&gt;skip&lt;/code&gt; named parameters may be used after the object. Example:</source>
          <target state="translated">명명 된 매개 변수 사용에 대한 대안으로 &lt;code&gt;ExtUtils::Typemaps::InputMap&lt;/code&gt; 개체를 첫 번째 인수로 전달할 수 있으며 복사본이 typemap에 추가됩니다. 이 경우 개체 뒤에 &lt;code&gt;replace&lt;/code&gt; 또는 &lt;code&gt;skip&lt;/code&gt; 명명 된 매개 변수 만 사용할 수 있습니다. 예:</target>
        </trans-unit>
        <trans-unit id="f943c4f68c18459667f13d0990dfceca7c5ca2a9" translate="yes" xml:space="preserve">
          <source>As an alternative to the named parameters usage, you may pass in an &lt;code&gt;ExtUtils::Typemaps::Type&lt;/code&gt; object as first argument, a copy of which will be added to the typemap. In that case, only the &lt;code&gt;replace&lt;/code&gt; or &lt;code&gt;skip&lt;/code&gt; named parameters may be used after the object. Example:</source>
          <target state="translated">명명 된 매개 변수 사용에 대한 대안으로 &lt;code&gt;ExtUtils::Typemaps::Type&lt;/code&gt; 개체를 첫 번째 인수로 전달할 수 있으며, 복사본이 typemap에 추가됩니다. 이 경우 개체 뒤에 &lt;code&gt;replace&lt;/code&gt; 또는 &lt;code&gt;skip&lt;/code&gt; 명명 된 매개 변수 만 사용할 수 있습니다. 예:</target>
        </trans-unit>
        <trans-unit id="782eb5f652231f0fff9e780cbf2fef47e3527def" translate="yes" xml:space="preserve">
          <source>As an alternative, overloaded constants (see &lt;a href=&quot;overload&quot;&gt;overload&lt;/a&gt;) provide a simple way to extend the functionality of the RE engine, by substituting one pattern for another.</source>
          <target state="translated">대안으로, 과부하 상수 ( &lt;a href=&quot;overload&quot;&gt;과부하&lt;/a&gt; 참조 )는 하나의 패턴을 다른 패턴으로 대체하여 RE 엔진의 기능을 확장하는 간단한 방법을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="18772395363d0e88e55df307a43fbfe2be745eba" translate="yes" xml:space="preserve">
          <source>As an alternative, specify a number instead of list of letters (e.g., &lt;b&gt;-D14&lt;/b&gt; is equivalent to &lt;b&gt;-Dtls&lt;/b&gt;):</source>
          <target state="translated">대안으로, 숫자가 아닌 문자 (예,의 목록을 지정 &lt;b&gt;-D14는&lt;/b&gt; 동일합니다 &lt;b&gt;-Dtls&lt;/b&gt; ) :</target>
        </trans-unit>
        <trans-unit id="8f4ba5d9ceee180216d44c33a248904b28bf93a4" translate="yes" xml:space="preserve">
          <source>As an alternative, to keep the case of the replacement word if it is longer than the original, you can use this code, by Jeff Pinyan:</source>
          <target state="translated">대안으로, 원래 단어보다 긴 대체 단어의 경우를 유지하기 위해 Jeff Pinyan의이 코드를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b70856a89ed6672d06c69a35074c3c6f2093e9dd" translate="yes" xml:space="preserve">
          <source>As an example consider the structure of a zip file. This is a well-defined file format that mixes both compressed and uncompressed sections of data in a single file.</source>
          <target state="translated">예를 들어 zip 파일의 구조를 고려하십시오. 이것은 하나의 파일에서 데이터의 압축 및 비 압축 섹션을 모두 혼합하는 잘 정의 된 파일 형식입니다.</target>
        </trans-unit>
        <trans-unit id="edc86b424441622df9f0c07df7eb59f80cab5da3" translate="yes" xml:space="preserve">
          <source>As an example of something that is caught under &lt;code&gt;&quot;strict'&lt;/code&gt; , but not otherwise, is the pattern</source>
          <target state="translated">&lt;code&gt;&quot;strict'&lt;/code&gt; 잡히지 만 그렇지 않은 패턴의 예는</target>
        </trans-unit>
        <trans-unit id="ec5fbaf06c5491bc9e0146955b6b1bccb85f04a8" translate="yes" xml:space="preserve">
          <source>As an example of something that is caught under &lt;code&gt;&quot;strict'&lt;/code&gt;, but not otherwise, is the pattern</source>
          <target state="translated">&lt;code&gt;&quot;strict'&lt;/code&gt; 아래에서 잡히지 만 그렇지 않은 경우의 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="52b1b17f0c5a778dad149ae64ff9d232a5d6120e" translate="yes" xml:space="preserve">
          <source>As an example of this case, this code prints the message &quot;Perl exited with active threads: 2 running and unjoined&quot;:</source>
          <target state="translated">이 예제의 예로,이 코드는 &quot;Perl exits with active threads : 2 running and unjoined&quot;메시지를 출력합니다.</target>
        </trans-unit>
        <trans-unit id="fd8cd6983452bdbcd828fbbb431f9c0eaf4c793d" translate="yes" xml:space="preserve">
          <source>As an example where a possessive quantifier is suitable we consider matching a quoted string, as it appears in several programming languages. The backslash is used as an escape character that indicates that the next character is to be taken literally, as another character for the string. Therefore, after the opening quote, we expect a (possibly empty) sequence of alternatives: either some character except an unescaped quote or backslash or an escaped character.</source>
          <target state="translated">소유 정량화가 적합한 예로, 여러 프로그래밍 언어로 표시되는 인용 문자열을 일치시키는 것을 고려합니다. 백 슬래시는 이스케이프 문자로 사용되어 다음 문자가 문자 그대로 문자열의 다른 문자로 사용됨을 나타냅니다. 따라서 여는 따옴표 뒤에는 이스케이프 처리되지 않은 따옴표 나 백 슬래시를 제외한 일부 문자 또는 이스케이프 처리 된 문자 중 하나 (대체로 비어 있음)가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="5cd508967ae1e206046e267640fdf9448ece0fe7" translate="yes" xml:space="preserve">
          <source>As an example, let's implement a &lt;code&gt;THAW&lt;/code&gt; function that regenerates the &lt;code&gt;My::Object&lt;/code&gt; from the &lt;code&gt;FREEZE&lt;/code&gt; example earlier:</source>
          <target state="translated">예를 들어, 이전 &lt;code&gt;FREEZE&lt;/code&gt; 예제 에서 &lt;code&gt;My::Object&lt;/code&gt; 를 다시 생성 하는 &lt;code&gt;THAW&lt;/code&gt; 함수를 구현해 보겠습니다 .</target>
        </trans-unit>
        <trans-unit id="82731324b346859b9bccf9603560116021199d53" translate="yes" xml:space="preserve">
          <source>As an example, when Perl sees &lt;code&gt;$x = &lt;a href=&quot;functions/chr&quot;&gt;chr&lt;/a&gt;(400)&lt;/code&gt; , it encodes the character in UTF-8 and stores it in $x. Then it is marked as character data, so, for instance, &lt;code&gt;&lt;a href=&quot;functions/length&quot;&gt;length&lt;/a&gt; $x&lt;/code&gt; returns &lt;code&gt;1&lt;/code&gt; . However, in the scope of the &lt;code&gt;bytes&lt;/code&gt; pragma, $x is treated as a series of bytes - the bytes that make up the UTF8 encoding - and &lt;code&gt;&lt;a href=&quot;functions/length&quot;&gt;length&lt;/a&gt; $x&lt;/code&gt; returns &lt;code&gt;2&lt;/code&gt; :</source>
          <target state="translated">예를 들어, Perl이 &lt;code&gt;$x = &lt;a href=&quot;functions/chr&quot;&gt;chr&lt;/a&gt;(400)&lt;/code&gt; 이면 문자를 UTF-8로 인코딩하여 $ x에 저장합니다. 그런 다음 문자 데이터로 표시되므로 예를 들어 &lt;code&gt;&lt;a href=&quot;functions/length&quot;&gt;length&lt;/a&gt; $x&lt;/code&gt; 는 &lt;code&gt;1&lt;/code&gt; 을 반환합니다 . 그러나 &lt;code&gt;bytes&lt;/code&gt; pragma 의 범위 에서 $ x는 일련의 바이트 (UTF8 인코딩을 구성하는 바이트)로 취급되며 &lt;code&gt;&lt;a href=&quot;functions/length&quot;&gt;length&lt;/a&gt; $x&lt;/code&gt; 는 &lt;code&gt;2&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="4cc20e99e2c8e44ee448eca66f36aaad208e30f4" translate="yes" xml:space="preserve">
          <source>As an example, when Perl sees &lt;code&gt;$x = chr(400)&lt;/code&gt;, it encodes the character in UTF-8 and stores it in &lt;code&gt;$x&lt;/code&gt;. Then it is marked as character data, so, for instance, &lt;code&gt;length $x&lt;/code&gt; returns &lt;code&gt;1&lt;/code&gt;. However, in the scope of the &lt;code&gt;bytes&lt;/code&gt; pragma, &lt;code&gt;$x&lt;/code&gt; is treated as a series of bytes - the bytes that make up the UTF8 encoding - and &lt;code&gt;length $x&lt;/code&gt; returns &lt;code&gt;2&lt;/code&gt;:</source>
          <target state="translated">예를 들어 Perl이 &lt;code&gt;$x = chr(400)&lt;/code&gt; 을 볼 때 문자를 UTF-8로 인코딩하고 &lt;code&gt;$x&lt;/code&gt; 저장합니다 . 그런 다음 문자 데이터로 표시되므로 예를 들어 &lt;code&gt;length $x&lt;/code&gt; 는 &lt;code&gt;1&lt;/code&gt; 을 반환합니다 . 그러나 &lt;code&gt;bytes&lt;/code&gt; pragma 의 범위 에서 &lt;code&gt;$x&lt;/code&gt; 는 일련의 바이트 (UTF8 인코딩을 구성하는 바이트)로 취급되고 &lt;code&gt;length $x&lt;/code&gt; 는 &lt;code&gt;2&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="c313609d4ce2bde8a8cf3d1a920bc018f88eebaa" translate="yes" xml:space="preserve">
          <source>As an interim measure, you may either change the #! line of your scripts to specifically refer to the old perl version, e.g. on Solaris 9 use #!/usr/perl5/5.00503/bin/perl to use the perl version that was the default for Solaris 8, or if you have a large number of scripts it may be more convenient to make the old version of perl the default on your system. You can do this by changing the appropriate symlinks under /usr/perl5 as follows (example for Solaris 9):</source>
          <target state="translated">임시 조치로 #을 변경할 수 있습니다! 예를 들어 Solaris 9의 경우 #! / usr / perl5 / 5.00503 / bin / perl을 사용하여 Solaris 8의 기본값 인 perl 버전을 사용하거나 숫자가 큰 경우 스크립트에서 이전 버전의 perl을 시스템의 기본값으로 설정하는 것이 더 편리 할 수 ​​있습니다. 다음과 같이 / usr / perl5에서 적절한 심볼릭 링크를 변경하면됩니다 (Solaris 9의 예).</target>
        </trans-unit>
        <trans-unit id="373576f861e30b7c81e25bff74bee6e23c15298c" translate="yes" xml:space="preserve">
          <source>As an optimization, may not call the command shell specified in &lt;code&gt;$ENV{PERL5SHELL}&lt;/code&gt; . &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;(1, @args)&lt;/code&gt; spawns an external process and immediately returns its process designator, without waiting for it to terminate. Return value may be used subsequently in &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/waitpid&quot;&gt;waitpid&lt;/a&gt;&lt;/code&gt;. Failure to &lt;code&gt;spawn()&lt;/code&gt; a subprocess is indicated by setting &lt;code&gt;$?&lt;/code&gt; to &lt;code&gt;&quot;255 &amp;lt;&amp;lt; 8&quot;&lt;/code&gt; . &lt;code&gt;$?&lt;/code&gt; is set in a way compatible with Unix (i.e. the exitstatus of the subprocess is obtained by &lt;code&gt;&quot;$?&lt;/code&gt; 8&quot;&amp;gt;&amp;gt;, as described in the documentation). (Win32)</source>
          <target state="translated">최적화로서 &lt;code&gt;$ENV{PERL5SHELL}&lt;/code&gt; 지정된 명령 쉘을 호출하지 않을 수 있습니다 . &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;(1, @args)&lt;/code&gt; 는 외부 프로세스를 생성하고 프로세스 지정자를 종료하지 않고 즉시 프로세스 지정자를 반환합니다. 리턴 값은 이후 &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;functions/waitpid&quot;&gt;waitpid&lt;/a&gt;&lt;/code&gt; 에서 사용될 수 있습니다 . 하위 프로세스 &lt;code&gt;spawn()&lt;/code&gt; 실패 는 &lt;code&gt;$?&lt;/code&gt; 를 설정하여 표시됩니다 . 행 &lt;code&gt;&quot;255 &amp;lt;&amp;lt; 8&quot;&lt;/code&gt; . &lt;code&gt;$?&lt;/code&gt; Unix와 호환되는 방식으로 설정됩니다 (예 : 하위 프로세스의 종료 상태는 &lt;code&gt;&quot;$?&lt;/code&gt; 설명서에 설명 된대로 8&quot;&amp;gt;&amp;gt; ). (Win32)</target>
        </trans-unit>
        <trans-unit id="137d06b82a3cf943b3082535121ce9ca48c386c5" translate="yes" xml:space="preserve">
          <source>As another example, this Pod source:</source>
          <target state="translated">또 다른 예로이 포드 소스는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="24dac5f3b0ae02bfc967e018bd163c71db2de949" translate="yes" xml:space="preserve">
          <source>As another special case, &lt;a href=&quot;#split-%2FPATTERN%2F%2CEXPR%2CLIMIT&quot;&gt;&lt;code&gt;split&lt;/code&gt;&lt;/a&gt; emulates the default behavior of the command line tool &lt;b&gt;awk&lt;/b&gt; when the PATTERN is either omitted or a string composed of a single space character (such as &lt;code&gt;' '&lt;/code&gt; or &lt;code&gt;&quot;\x20&quot;&lt;/code&gt;, but not e.g. &lt;code&gt;/ /&lt;/code&gt;). In this case, any leading whitespace in EXPR is removed before splitting occurs, and the PATTERN is instead treated as if it were &lt;code&gt;/\s+/&lt;/code&gt;; in particular, this means that</source>
          <target state="translated">또 다른 특별한 경우로서 &lt;a href=&quot;#split-%2FPATTERN%2F%2CEXPR%2CLIMIT&quot;&gt; &lt;code&gt;split&lt;/code&gt; &lt;/a&gt; 은 PATTERN이 생략되거나 단일 공백 ​​문자로 구성된 문자열 (예 : &lt;code&gt;' '&lt;/code&gt; 또는 &lt;code&gt;&quot;\x20&quot;&lt;/code&gt; , 예 : &lt;code&gt;/ /&lt;/code&gt; )이 아닌 경우 명령 줄 도구 &lt;b&gt;awk&lt;/b&gt; 의 기본 동작을 에뮬레이트합니다 . 이 경우 분할이 발생하기 전에 EXPR의 선행 공백이 제거되고 대신 PATTERN이 &lt;code&gt;/\s+/&lt;/code&gt; 것처럼 처리됩니다 . 특히 이것은</target>
        </trans-unit>
        <trans-unit id="38474bdd192558dcfa688dfaf6e45817a6f595ea" translate="yes" xml:space="preserve">
          <source>As another special case, &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; emulates the default behavior of the command line tool &lt;b&gt;awk&lt;/b&gt; when the PATTERN is either omitted or a</source>
          <target state="translated">또 다른 특별한 경우, &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; 은 명령 행 도구 &lt;b&gt;awk&lt;/b&gt; 의 기본 동작을 에뮬레이트합니다&lt;b&gt;&lt;/b&gt; PATTERN이 생략되거나 a 일 때</target>
        </trans-unit>
        <trans-unit id="aab9f2eadc04a37e669ffc31217a1ec91df2a94d" translate="yes" xml:space="preserve">
          <source>As another special case, &lt;code&gt;&lt;a href=&quot;split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; emulates the default behavior of the command line tool &lt;b&gt;awk&lt;/b&gt; when the PATTERN is either omitted or a</source>
          <target state="translated">또 다른 특별한 경우로, &lt;code&gt;&lt;a href=&quot;split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; 은 PATTERN이 생략되거나 a 일 때 명령 행 도구 &lt;b&gt;awk&lt;/b&gt; 의 기본 동작을 에뮬레이트합니다</target>
        </trans-unit>
        <trans-unit id="46ab5c6135652ee2c4d494e00004b3edd1c35481" translate="yes" xml:space="preserve">
          <source>As another workaround for this problem, Perl 5.10.0 introduced &lt;code&gt;${^PREMATCH}&lt;/code&gt; , &lt;code&gt;${^MATCH}&lt;/code&gt; and &lt;code&gt;${^POSTMATCH}&lt;/code&gt; , which are equivalent to &lt;code&gt;$`&lt;/code&gt; , &lt;code&gt;$&amp;amp;&lt;/code&gt; and &lt;code&gt;$'&lt;/code&gt; , &lt;b&gt;except&lt;/b&gt; that they are only guaranteed to be defined after a successful match that was executed with the &lt;code&gt;/p&lt;/code&gt; (preserve) modifier. The use of these variables incurs no global performance penalty, unlike their punctuation char equivalents, however at the trade-off that you have to tell perl when you want to use them. As of Perl 5.20, these three variables are equivalent to &lt;code&gt;$`&lt;/code&gt; , &lt;code&gt;$&amp;amp;&lt;/code&gt; and &lt;code&gt;$'&lt;/code&gt; , and &lt;code&gt;/p&lt;/code&gt; is ignored.</source>
          <target state="translated">이 문제에 대한 또 다른 해결 방법으로, 펄 5.10.0 도입 &lt;code&gt;${^PREMATCH}&lt;/code&gt; , &lt;code&gt;${^MATCH}&lt;/code&gt; 와 &lt;code&gt;${^POSTMATCH}&lt;/code&gt; 에 해당되는, &lt;code&gt;$`&lt;/code&gt; , &lt;code&gt;$&amp;amp;&lt;/code&gt; 와 &lt;code&gt;$'&lt;/code&gt; , &lt;b&gt;제외하고&lt;/b&gt; 그들 만 보장되어 있는지를 &lt;code&gt;/p&lt;/code&gt; (preserve) 수정 자로 실행 된 성공적인 일치 후에 정의됩니다 . 이 변수를 사용하면 구두점 문자와 달리 전역 성능 저하가 발생하지 않지만 펄을 사용할 때는 펄에게 알려야합니다. Perl 5.20부터이 세 변수는 &lt;code&gt;$`&lt;/code&gt; , &lt;code&gt;$&amp;amp;&lt;/code&gt; 및 &lt;code&gt;$'&lt;/code&gt; 및 &lt;code&gt;/p&lt;/code&gt; 와 같습니다. 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="5306125a9b9482228b73d9001504cb8ff0235e3b" translate="yes" xml:space="preserve">
          <source>As another workaround for this problem, Perl 5.10.0 introduced &lt;code&gt;${^PREMATCH}&lt;/code&gt;, &lt;code&gt;${^MATCH}&lt;/code&gt; and &lt;code&gt;${^POSTMATCH}&lt;/code&gt;, which are equivalent to &lt;code&gt;$`&lt;/code&gt;, &lt;code&gt;$&amp;amp;&lt;/code&gt; and &lt;code&gt;$'&lt;/code&gt;, &lt;b&gt;except&lt;/b&gt; that they are only guaranteed to be defined after a successful match that was executed with the &lt;code&gt;/p&lt;/code&gt; (preserve) modifier. The use of these variables incurs no global performance penalty, unlike their punctuation character equivalents, however at the trade-off that you have to tell perl when you want to use them. As of Perl 5.20, these three variables are equivalent to &lt;code&gt;$`&lt;/code&gt;, &lt;code&gt;$&amp;amp;&lt;/code&gt; and &lt;code&gt;$'&lt;/code&gt;, and &lt;code&gt;/p&lt;/code&gt; is ignored.</source>
          <target state="translated">이 문제에 대한 또 다른 해결 방법으로, 펄 5.10.0 도입 &lt;code&gt;${^PREMATCH}&lt;/code&gt; , &lt;code&gt;${^MATCH}&lt;/code&gt; 와 &lt;code&gt;${^POSTMATCH}&lt;/code&gt; 에 해당되는, &lt;code&gt;$`&lt;/code&gt; , &lt;code&gt;$&amp;amp;&lt;/code&gt; 와 &lt;code&gt;$'&lt;/code&gt; , &lt;b&gt;제외하고&lt;/b&gt; 그들 만 보장되어 있는지를 &lt;code&gt;/p&lt;/code&gt; (보존) 수정 자로 실행 된 성공적인 일치 후에 정의되어야 합니다. 이러한 변수의 사용은 구두점 문자에 해당하는 것과는 달리 전역 성능 저하를 일으키지 않지만 사용하려는 경우 perl에 알려야한다는 절충안에서 발생합니다. Perl 5.20부터이 세 변수는 &lt;code&gt;$`&lt;/code&gt; , &lt;code&gt;$&amp;amp;&lt;/code&gt; 및 &lt;code&gt;$'&lt;/code&gt; 및 &lt;code&gt;/p&lt;/code&gt; 와 동일합니다. 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="faf1880e6e4e5e1670571e23b070295ae744c1fc" translate="yes" xml:space="preserve">
          <source>As described &lt;a href=&quot;#Calling-Conventions-and-Magic-Autogeneration&quot;&gt;above&lt;/a&gt;, Perl may call methods for operators like &lt;code&gt;+&lt;/code&gt; and &lt;code&gt;&amp;amp;&lt;/code&gt; in the course of implementing missing operations like &lt;code&gt;++&lt;/code&gt; , &lt;code&gt;+=&lt;/code&gt; , and &lt;code&gt;&amp;amp;=&lt;/code&gt; . While these methods may detect this usage by testing the definedness of the third argument, they should in all cases avoid changing their operands. This is because Perl does not call the copy constructor before invoking these methods.</source>
          <target state="translated">&lt;a href=&quot;#Calling-Conventions-and-Magic-Autogeneration&quot;&gt;위에서&lt;/a&gt; 설명한 것처럼 Perl은 &lt;code&gt;++&lt;/code&gt; , &lt;code&gt;+=&lt;/code&gt; 및 &lt;code&gt;&amp;amp;=&lt;/code&gt; 와 같은 누락 된 작업을 구현하는 과정에서 &lt;code&gt;+&lt;/code&gt; 및 &lt;code&gt;&amp;amp;&lt;/code&gt; 와 같은 연산자에 대한 메서드를 호출 할 수 있습니다 . 이러한 메소드는 세 번째 인수의 정의를 테스트하여이 사용법을 감지 할 수 있지만 모든 경우 피연산자를 변경하지 않아야합니다. Perl은 이러한 메소드를 호출하기 전에 복사 생성자를 호출하지 않기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="20dd96aab8100e801c2698dbb8e487016840bd2c" translate="yes" xml:space="preserve">
          <source>As described &lt;a href=&quot;#Calling-Conventions-and-Magic-Autogeneration&quot;&gt;above&lt;/a&gt;, Perl may call methods for operators like &lt;code&gt;+&lt;/code&gt; and &lt;code&gt;&amp;amp;&lt;/code&gt; in the course of implementing missing operations like &lt;code&gt;++&lt;/code&gt;, &lt;code&gt;+=&lt;/code&gt;, and &lt;code&gt;&amp;amp;=&lt;/code&gt;. While these methods may detect this usage by testing the definedness of the third argument, they should in all cases avoid changing their operands. This is because Perl does not call the copy constructor before invoking these methods.</source>
          <target state="translated">&lt;a href=&quot;#Calling-Conventions-and-Magic-Autogeneration&quot;&gt;위에서&lt;/a&gt; 설명한 것처럼 Perl은 &lt;code&gt;++&lt;/code&gt; , &lt;code&gt;+=&lt;/code&gt; 및 &lt;code&gt;&amp;amp;=&lt;/code&gt; 와 같은 누락 된 작업을 구현하는 과정에서 &lt;code&gt;+&lt;/code&gt; 및 &lt;code&gt;&amp;amp;&lt;/code&gt; 와 같은 연산자에 대한 메서드를 호출 할 수 있습니다 . 이러한 메서드는 세 번째 인수의 정의를 테스트하여 이러한 사용을 감지 할 수 있지만 모든 경우에 피연산자를 변경하지 않아야합니다. 이는 Perl이 이러한 메서드를 호출하기 전에 복사 생성자를 호출하지 않기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="e9c1d88156738ffdc72a22d4eb2c079c412ad705" translate="yes" xml:space="preserve">
          <source>As described earlier, if there are many changes on your smoke-me branch then you should prepare a merge commit in which to give an overview of those changes by using the following command instead of the last command above:</source>
          <target state="translated">앞에서 설명한 것처럼 smoke-me 브랜치에 많은 변경 사항이있는 경우 위의 마지막 명령 대신 다음 명령을 사용하여 이러한 변경 사항에 대한 개요를 제공하는 병합 커밋을 준비해야합니다.</target>
        </trans-unit>
        <trans-unit id="6ff132deadaac51720c9e117548f044618ad0a39" translate="yes" xml:space="preserve">
          <source>As discussed elsewhere, Perl has one foot (two hooves?) planted in each of two worlds: the old world of ASCII and single-byte locales, and the new world of Unicode, upgrading when necessary. If your legacy code does not explicitly use Unicode, no automatic switch-over to Unicode should happen.</source>
          <target state="translated">다른 곳에서 논의한 바와 같이, Perl은 두 세계 각각에 1 피트 (2 발굽?)를 심었습니다. 구세계 ASCII 및 단일 바이트 로케일과 새로운 유니 코드 세계는 필요할 때 업그레이드합니다. 레거시 코드에서 명시 적으로 유니 코드를 사용하지 않으면 유니 코드로 자동 전환되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3a28f6e945d7b1d8cd9440551fcd17f03dc59837" translate="yes" xml:space="preserve">
          <source>As explained above, an anonymous function with access to the lexical variables visible when that function was compiled, creates a closure. It retains access to those variables even though it doesn't get run until later, such as in a signal handler or a Tk callback.</source>
          <target state="translated">위에서 설명한 것처럼 함수를 컴파일 할 때 표시되는 어휘 변수에 액세스 할 수있는 익명 함수는 클로저를 만듭니다. 신호 처리기 또는 Tk 콜백과 같이 나중에 실행될 때에도 해당 변수에 대한 액세스 권한을 유지합니다.</target>
        </trans-unit>
        <trans-unit id="03fe8a37ea6c568501bcfeecc21187a67095c9a8" translate="yes" xml:space="preserve">
          <source>As explained in &lt;a href=&quot;#ASCII-Rules-versus-Unicode-Rules&quot;&gt;&quot;ASCII Rules versus Unicode Rules&quot;&lt;/a&gt;, under ASCII rules, they are considered to be unassigned characters.</source>
          <target state="translated">&lt;a href=&quot;#ASCII-Rules-versus-Unicode-Rules&quot;&gt;&quot;ASCII 규칙과 유니 코드 규칙&quot;에&lt;/a&gt; 설명 된대로 ASCII 규칙에서는 할당되지 않은 문자로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="de6278f8e877d258b1f62760a70228a073ba24fd" translate="yes" xml:space="preserve">
          <source>As explained in &lt;a href=&quot;#ASCII-Rules-versus-Unicode-Rules&quot;&gt;ASCII Rules versus Unicode Rules&lt;/a&gt;, under ASCII rules, they are considered to be unassigned characters.</source>
          <target state="translated">&lt;a href=&quot;#ASCII-Rules-versus-Unicode-Rules&quot;&gt;ASCII 규칙과 유니 코드 규칙에&lt;/a&gt; 설명 된대로 ASCII 규칙에서 할당되지 않은 문자로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="48e236093008993b6e4def956b958d0cb620db14" translate="yes" xml:space="preserve">
          <source>As explained in &lt;a href=&quot;#prop_invlist%28%29&quot;&gt;&quot;prop_invlist()&quot;&lt;/a&gt;, whether a code point is in the list or not depends on if the index is even (in) or odd (not in). And as explained in &lt;a href=&quot;#prop_invmap%28%29&quot;&gt;&quot;prop_invmap()&quot;&lt;/a&gt;, the index is used with the returned parallel array to find the mapping.</source>
          <target state="translated">&lt;a href=&quot;#prop_invlist%28%29&quot;&gt;&quot;prop_invlist ()&quot;&lt;/a&gt; 에서 설명했듯이 코드 포인트가 목록에 있는지 여부는 인덱스가 짝수 (in)인지 홀수 (in)인지에 따라 다릅니다. 그리고 &lt;a href=&quot;#prop_invmap%28%29&quot;&gt;&quot;prop_invmap ()&quot;&lt;/a&gt; 에서 설명했듯이 인덱스는 매핑을 찾기 위해 반환 된 병렬 배열과 함께 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="8ffaa22d40c8f644f2c59a68a07b28bdf08a1f8a" translate="yes" xml:space="preserve">
          <source>As explained in &lt;a href=&quot;#prop_invlist()&quot;&gt;prop_invlist()&lt;/a&gt;, whether a code point is in the list or not depends on if the index is even (in) or odd (not in). And as explained in &lt;a href=&quot;#prop_invmap()&quot;&gt;prop_invmap()&lt;/a&gt;, the index is used with the returned parallel array to find the mapping.</source>
          <target state="translated">&lt;a href=&quot;#prop_invlist()&quot;&gt;prop_invlist ()&lt;/a&gt; 에서 설명한 것처럼 코드 포인트가 목록에 있는지 여부는 인덱스가 짝수인지 (인지) 아니면 홀수인지 (인지)에 따라 다릅니다. &lt;a href=&quot;#prop_invmap()&quot;&gt;prop_invmap ()&lt;/a&gt; 에서 설명한 것처럼 인덱스는 반환 된 병렬 배열과 함께 사용되어 매핑을 찾습니다.</target>
        </trans-unit>
        <trans-unit id="bf0e7abd7a09ee9c2ba9a8344c5b618840f66e79" translate="yes" xml:space="preserve">
          <source>As far as creating the &lt;code&gt;$pOverlapped&lt;/code&gt; structure, you are currently on your own.</source>
          <target state="translated">&lt;code&gt;$pOverlapped&lt;/code&gt; 구조 를 생성하는 한 현재 사용자는 혼자입니다.</target>
        </trans-unit>
        <trans-unit id="101540b4758da815d4da97e60284cb84f98af97f" translate="yes" xml:space="preserve">
          <source>As for new features and requests to change common behaviors, please ask the author of JSON::XS (Marc Lehmann, &amp;lt;schmorp[at]schmorp.de&amp;gt;) first, by email (important!), to keep compatibility among JSON.pm backends.</source>
          <target state="translated">새로운 기능과 일반적인 동작 변경 요청은 JSON :: XS (Marc Lehmann, &amp;lt;schmorp [at] schmorp.de&amp;gt;) 작성자에게 먼저 이메일 (중요!)로 문의하여 JSON.pm 간의 호환성을 유지하십시오. 백엔드.</target>
        </trans-unit>
        <trans-unit id="c53e475afb32fdd8296f1c9a917ef2e75b376078" translate="yes" xml:space="preserve">
          <source>As for other operations, the subroutine implementing '=' is passed three arguments, though the last two are always &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;''&lt;/code&gt; .</source>
          <target state="translated">다른 연산의 경우 '='를 구현하는 서브 루틴에는 세 개의 인수가 전달되지만 마지막 두 개는 항상 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;''&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="bf65c0259648a27866b59740e85994dce5ffc5e7" translate="yes" xml:space="preserve">
          <source>As for other operations, the subroutine implementing '=' is passed three arguments, though the last two are always &lt;code&gt;undef&lt;/code&gt; and &lt;code&gt;''&lt;/code&gt;.</source>
          <target state="translated">다른 작업의 경우 '='를 구현하는 서브 루틴에 세 개의 인수가 전달되지만 마지막 두 개는 항상 &lt;code&gt;undef&lt;/code&gt; 및 &lt;code&gt;''&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="8cf2ef2540039c1386257379903eff22c20c0bad" translate="yes" xml:space="preserve">
          <source>As if all those classes weren't enough, Perl also defines POSIX-style character classes. These have the form &lt;code&gt;[:&lt;i&gt;name&lt;/i&gt;:]&lt;/code&gt;, with</source>
          <target state="translated">모든 클래스가 충분하지 않은 것처럼 Perl은 POSIX 스타일의 문자 클래스도 정의합니다. 형식은 &lt;code&gt;[:&lt;i&gt;name&lt;/i&gt;:]&lt;/code&gt; 이며</target>
        </trans-unit>
        <trans-unit id="2f54bd3297d1b4b8911e3de6ffd9e1ee35795e3c" translate="yes" xml:space="preserve">
          <source>As if all those classes weren't enough, Perl also defines POSIX-style character classes. These have the form &lt;code&gt;[:name:]&lt;/code&gt;, with &lt;code&gt;name&lt;/code&gt; the name of the POSIX class. The POSIX classes are &lt;code&gt;alpha&lt;/code&gt; , &lt;code&gt;alnum&lt;/code&gt; , &lt;code&gt;ascii&lt;/code&gt; , &lt;code&gt;cntrl&lt;/code&gt; , &lt;code&gt;digit&lt;/code&gt; , &lt;code&gt;graph&lt;/code&gt; , &lt;code&gt;lower&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;punct&lt;/code&gt; , &lt;code&gt;space&lt;/code&gt; , &lt;code&gt;upper&lt;/code&gt; , and &lt;code&gt;xdigit&lt;/code&gt; , and two extensions, &lt;code&gt;word&lt;/code&gt; (a Perl extension to match &lt;code&gt;\w&lt;/code&gt; ), and &lt;code&gt;blank&lt;/code&gt; (a GNU extension). The &lt;code&gt;//a&lt;/code&gt; modifier restricts these to matching just in the ASCII range; otherwise they can match the same as their corresponding Perl Unicode classes: &lt;code&gt;[:upper:]&lt;/code&gt; is the same as &lt;code&gt;\p{IsUpper}&lt;/code&gt; , etc. (There are some exceptions and gotchas with this; see &lt;a href=&quot;perlrecharclass&quot;&gt;perlrecharclass&lt;/a&gt; for a full discussion.) The &lt;code&gt;[:digit:]&lt;/code&gt;, &lt;code&gt;[:word:]&lt;/code&gt;, and &lt;code&gt;[:space:]&lt;/code&gt; correspond to the familiar &lt;code&gt;\d&lt;/code&gt; , &lt;code&gt;\w&lt;/code&gt; , and &lt;code&gt;\s&lt;/code&gt; character classes. To negate a POSIX class, put a &lt;code&gt;^&lt;/code&gt; in front of the name, so that, e.g., &lt;code&gt;[:^digit:]&lt;/code&gt; corresponds to &lt;code&gt;\D&lt;/code&gt; and, under Unicode, &lt;code&gt;\P{IsDigit}&lt;/code&gt; . The Unicode and POSIX character classes can be used just like &lt;code&gt;\d&lt;/code&gt; , with the exception that POSIX character classes can only be used inside of a character class:</source>
          <target state="translated">모든 클래스가 충분하지 않은 것처럼 Perl은 POSIX 스타일 문자 클래스도 정의합니다. 이러한 형태가 &lt;code&gt;[:name:]&lt;/code&gt; 함께 &lt;code&gt;name&lt;/code&gt; 는 POSIX 클래스의 이름을. POSIX 클래스는 &lt;code&gt;alpha&lt;/code&gt; , &lt;code&gt;alnum&lt;/code&gt; , &lt;code&gt;ascii&lt;/code&gt; , &lt;code&gt;cntrl&lt;/code&gt; , &lt;code&gt;digit&lt;/code&gt; , &lt;code&gt;graph&lt;/code&gt; , &lt;code&gt;lower&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;punct&lt;/code&gt; , &lt;code&gt;space&lt;/code&gt; , &lt;code&gt;upper&lt;/code&gt; , &lt;code&gt;xdigit&lt;/code&gt; , 두 개의 확장자, &lt;code&gt;word&lt;/code&gt; ( &lt;code&gt;\w&lt;/code&gt; 와 일치하는 Perl 확장자 ) 및 &lt;code&gt;blank&lt;/code&gt; (GNU 확장자)입니다. ). &lt;code&gt;//a&lt;/code&gt; 를수정자는 ASCII 범위에서만 일치하도록 제한합니다. 그렇지 않으면 그에 상응하는 펄 유니 코드 클래스와 동일하게 일치시킬 수 있습니다 : &lt;code&gt;[:upper:]&lt;/code&gt; 과 동일 &lt;code&gt;\p{IsUpper}&lt;/code&gt; 등 (이 일부 예외 망 가지고있다; 참조 &lt;a href=&quot;perlrecharclass&quot;&gt;perlrecharclass을&lt;/a&gt; 상세 논의하십시오.) &lt;code&gt;[:digit:]&lt;/code&gt; , &lt;code&gt;[:word:]&lt;/code&gt; 및 &lt;code&gt;[:space:]&lt;/code&gt; 는 익숙한 &lt;code&gt;\d&lt;/code&gt; , &lt;code&gt;\w&lt;/code&gt; 및 &lt;code&gt;\s&lt;/code&gt; 문자 클래스에 해당합니다. POSIX 클래스를 무효화하려면 이름 앞에 &lt;code&gt;^&lt;/code&gt; 를 넣으십시오. 예를 들어 &lt;code&gt;[:^digit:]&lt;/code&gt; 는 &lt;code&gt;\D&lt;/code&gt; 해당하고 유니 코드에서는 &lt;code&gt;\P{IsDigit}&lt;/code&gt; . POSIX 문자 클래스는 문자 클래스 내에서만 사용할 수 있다는 점을 제외하고는 &lt;code&gt;\d&lt;/code&gt; 와 마찬가지로 유니 코드 및 POSIX 문자 클래스를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c16f46255f2c5b016b34cc67482e93dd7025a2f9" translate="yes" xml:space="preserve">
          <source>As implied above, the environment accessed through &lt;a href=&quot;perlvar#%25ENV&quot;&gt;&lt;code&gt;%ENV&lt;/code&gt;&lt;/a&gt; is global, and the convention is that program specific environment variables are of the form &lt;code&gt;Program$Name&lt;/code&gt;. Each filesystem maintains a current directory, and the current filesystem's current directory is the &lt;b&gt;global&lt;/b&gt; current directory. Consequently, sociable programs don't change the current directory but rely on full pathnames, and programs (and Makefiles) cannot assume that they can spawn a child process which can change the current directory without affecting its parent (and everyone else for that matter).</source>
          <target state="translated">위에서 암시했듯이 &lt;a href=&quot;perlvar#%25ENV&quot;&gt; &lt;code&gt;%ENV&lt;/code&gt; &lt;/a&gt; 통해 액세스되는 환경 은 전역이며 프로그램 별 환경 변수는 &lt;code&gt;Program$Name&lt;/code&gt; 형식 입니다. 각 파일 시스템은 현재 디렉토리를 유지하고 현재 파일 시스템의 현재 디렉토리는 &lt;b&gt;전역&lt;/b&gt; 현재 디렉토리입니다. 결과적으로 사교적 프로그램은 현재 디렉터리를 변경하지 않고 전체 경로 이름에 의존하며 프로그램 (및 Makefile)은 부모 (및 그 문제에 대해 다른 모든 사람)에 영향을주지 않고 현재 디렉터리를 변경할 수있는 자식 프로세스를 생성 할 수 있다고 가정 할 수 없습니다. .</target>
        </trans-unit>
        <trans-unit id="460ff6781c9a7b0d42e2f096c304dc01b5296e55" translate="yes" xml:space="preserve">
          <source>As implied above, the environment accessed through &lt;code&gt;%ENV&lt;/code&gt; is global, and the convention is that program specific environment variables are of the form &lt;code&gt;Program$Name&lt;/code&gt; . Each filesystem maintains a current directory, and the current filesystem's current directory is the &lt;b&gt;global&lt;/b&gt; current directory. Consequently, sociable programs don't change the current directory but rely on full pathnames, and programs (and Makefiles) cannot assume that they can spawn a child process which can change the current directory without affecting its parent (and everyone else for that matter).</source>
          <target state="translated">위에서 알 수 있듯이 &lt;code&gt;%ENV&lt;/code&gt; 통해 액세스되는 환경 은 전역 적이며, 프로그램 별 환경 변수는 &lt;code&gt;Program$Name&lt;/code&gt; 형식 입니다. 각 파일 시스템은 현재 디렉토리를 유지 관리하며 현재 파일 시스템의 현재 디렉토리는 &lt;b&gt;전역&lt;/b&gt; 현재 디렉토리입니다. 따라서 사교적 인 프로그램은 현재 디렉토리를 변경하지 않고 전체 경로 이름에 의존하므로 프로그램 (및 Makefile)은 부모 (및 그 문제에 대한 다른 모든 사람)에게 영향을 미치지 않으면 서 현재 디렉토리를 변경할 수있는 자식 프로세스를 생성 할 수 있다고 가정 할 수 없습니다. .</target>
        </trans-unit>
        <trans-unit id="9cfe8ec9bce67c19def3a159ea6c0eb1d6dbe31c" translate="yes" xml:space="preserve">
          <source>As in some shells, you can enclose the variable name in braces to disambiguate it from following alphanumerics (and underscores). You must also do this when interpolating a variable into a string to separate the variable name from a following double-colon or an apostrophe, since these would be otherwise treated as a package separator:</source>
          <target state="translated">일부 셸에서와 같이 변수 이름을 중괄호로 묶어 다음의 영숫자 (및 밑줄)를 명확히 할 수 있습니다. 변수를 문자열로 보간 할 때 변수 이름을 다음 이중 콜론 또는 아포스트로피와 구분하기 위해이를 수행해야합니다. 패키지 구분 기호로 처리되기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="f260d12b5b1b7a497f5733dde8f966ff0dea7a60" translate="yes" xml:space="preserve">
          <source>As it stands it predates version.pm but has the same goal: make version strings visible and comparable.</source>
          <target state="translated">그것은 그대로 version.pm 이전이지만 동일한 목표를 가지고 있습니다 : 버전 문자열을 보이고 비교할 수있게하십시오.</target>
        </trans-unit>
        <trans-unit id="e22bdaf7af0b55a0257fbf249cc6b2acfdfc9220" translate="yes" xml:space="preserve">
          <source>As its name suggests, if your code tripped a mandatory warning, you would get a warning whether you wanted it or not. For example, the code below would always produce an &lt;code&gt;&quot;isn't numeric&quot;&lt;/code&gt; warning about the &quot;2:&quot;.</source>
          <target state="translated">이름에서 알 수 있듯이 코드에서 필수 경고가 발생하면 원하는지 여부에 관계없이 경고가 표시됩니다. 예를 들어 아래 코드는 항상 &quot;2 :&quot;에 대한 &quot; &lt;code&gt;&quot;isn't numeric&quot;&lt;/code&gt; 경고를 생성합니다 .</target>
        </trans-unit>
        <trans-unit id="299f8da88c7d33c41fa9b9da7b25493959ed6b3c" translate="yes" xml:space="preserve">
          <source>As just mentioned, all variables are, by default, thread local. To use shared variables, you need to also load &lt;a href=&quot;threads/shared&quot;&gt;threads::shared&lt;/a&gt;:</source>
          <target state="translated">방금 언급했듯이 모든 변수는 기본적으로 스레드 로컬입니다. 공유 변수를 사용하려면 &lt;a href=&quot;threads/shared&quot;&gt;threads :: shared도로드&lt;/a&gt; 해야합니다 .</target>
        </trans-unit>
        <trans-unit id="7273a25ae51ae519b823516d45a11747d27d1f68" translate="yes" xml:space="preserve">
          <source>As just mentioned, all variables are, by default, thread local. To use shared variables, you need to also load &lt;a href=&quot;threads::shared&quot;&gt;threads::shared&lt;/a&gt;:</source>
          <target state="translated">방금 언급했듯이 모든 변수는 기본적으로 스레드 로컬입니다. 공유 변수를 사용하려면 &lt;a href=&quot;threads::shared&quot;&gt;threads :: shared도로드&lt;/a&gt; 해야합니다 .</target>
        </trans-unit>
        <trans-unit id="1b2545d2ff62a227583262bedb22954e6e8e3fc3" translate="yes" xml:space="preserve">
          <source>As locks are advisory, they do not prevent data access or modification by another thread that does not itself attempt to obtain a lock on the variable.</source>
          <target state="translated">잠금은 권고이므로 변수에 대한 잠금을 얻으려고 시도하지 않는 다른 스레드에 의한 데이터 액세스 또는 수정을 방해하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3b3a54f56722c72f0cfe48a91b285385f9f3fe3e" translate="yes" xml:space="preserve">
          <source>As long as a context exists for a given hub, all tools that try to get a context will get the existing instance. If you try to store the context you will pollute other tools with incorrect context information.</source>
          <target state="translated">주어진 허브에 대한 컨텍스트가 존재하는 한 컨텍스트를 가져 오려는 모든 도구는 기존 인스턴스를 가져옵니다. 컨텍스트를 저장하려고하면 잘못된 컨텍스트 정보로 다른 도구를 오염시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="81ff74ffe73c98f024294d6b4b3ccdb104adb917" translate="yes" xml:space="preserve">
          <source>As long as all documents processed result in some output, even if that output includes errata (a &lt;code&gt;POD ERRORS&lt;/code&gt; section generated with &lt;code&gt;--errors=pod&lt;/code&gt; ), &lt;b&gt;pod2man&lt;/b&gt; will exit with status 0. If any of the documents being processed do not result in an output document, &lt;b&gt;pod2man&lt;/b&gt; will exit with status 1. If there are syntax errors in a POD document being processed and the error handling style is set to the default of &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt;, &lt;b&gt;pod2man&lt;/b&gt; will abort immediately with exit status 255.</source>
          <target state="translated">처리 된 모든 문서가 일부 출력을 생성하는 한, 해당 출력에 정오표 ( &lt;code&gt;--errors=pod&lt;/code&gt; 로 생성 된 &lt;code&gt;POD ERRORS&lt;/code&gt; 섹션 )가 포함되어 &lt;b&gt;있어도 pod2man&lt;/b&gt; 은 상태 0으로 종료됩니다. 처리중인 문서가 없으면 출력 문서에서 &lt;b&gt;pod2man&lt;/b&gt; 은 상태 1로 종료됩니다. 처리중인 POD 문서에 구문 오류가 있고 오류 처리 스타일이 기본값 인 &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; 로 &lt;b&gt;설정된&lt;/b&gt; 경우 &lt;b&gt;pod2man&lt;/b&gt; 은 종료 상태 255로 즉시 중단됩니다.&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="00a3a680bcee6a61521d2a5ef5058ff99a76856b" translate="yes" xml:space="preserve">
          <source>As long as all documents processed result in some output, even if that output includes errata (a &lt;code&gt;POD ERRORS&lt;/code&gt; section generated with &lt;code&gt;--errors=pod&lt;/code&gt; ), &lt;b&gt;pod2text&lt;/b&gt; will exit with status 0. If any of the documents being processed do not result in an output document, &lt;b&gt;pod2text&lt;/b&gt; will exit with status 1. If there are syntax errors in a POD document being processed and the error handling style is set to the default of &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt;, &lt;b&gt;pod2text&lt;/b&gt; will abort immediately with exit status 255.</source>
          <target state="translated">처리 된 모든 문서가 일부 출력을 생성하는 한, 해당 출력에 정오표 ( &lt;code&gt;--errors=pod&lt;/code&gt; 로 생성 된 &lt;code&gt;POD ERRORS&lt;/code&gt; 섹션 )가 포함되어 &lt;b&gt;있어도 pod2text&lt;/b&gt; 는 상태 0으로 종료됩니다. 처리중인 문서가 없으면 출력 문서 인 경우 &lt;b&gt;pod2text&lt;/b&gt; 는 상태 1로 종료됩니다. 처리중인 POD 문서에 구문 오류가 있고 오류 처리 스타일이 기본값 인 &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; 로 설정 되면 &lt;b&gt;pod2text&lt;/b&gt; 는 즉시 종료 상태 255로 중단됩니다.&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="0269a38b4ec57ba243ba2782b49b270dd9c32426" translate="yes" xml:space="preserve">
          <source>As long as all documents processed result in some output, even if that output includes errata (a &lt;code&gt;POD ERRORS&lt;/code&gt; section generated with &lt;code&gt;--errors=pod&lt;/code&gt;), &lt;b&gt;pod2man&lt;/b&gt; will exit with status 0. If any of the documents being processed do not result in an output document, &lt;b&gt;pod2man&lt;/b&gt; will exit with status 1. If there are syntax errors in a POD document being processed and the error handling style is set to the default of &lt;code&gt;die&lt;/code&gt;, &lt;b&gt;pod2man&lt;/b&gt; will abort immediately with exit status 255.</source>
          <target state="translated">처리 된 모든 문서에서 일부 출력이 발생하는 한 해당 출력에 에라타 ( &lt;code&gt;--errors=pod&lt;/code&gt; 로 생성 된 &lt;code&gt;POD ERRORS&lt;/code&gt; 섹션 )가 포함되어 &lt;b&gt;있어도 pod2man&lt;/b&gt; 은 상태 0으로 종료됩니다. 출력 문서, &lt;b&gt;pod2man&lt;/b&gt; 은 상태 1로 종료됩니다. 처리중인 POD 문서에 구문 오류가 있고 오류 처리 스타일이 기본값 인 &lt;code&gt;die&lt;/code&gt; 로 &lt;b&gt;설정된&lt;/b&gt; 경우 &lt;b&gt;pod2man&lt;/b&gt; 은 종료 상태 255로 즉시 중단됩니다.&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="03b9b379a8f2df5ad39a7bc04538ebad9bc6c049" translate="yes" xml:space="preserve">
          <source>As long as all documents processed result in some output, even if that output includes errata (a &lt;code&gt;POD ERRORS&lt;/code&gt; section generated with &lt;code&gt;--errors=pod&lt;/code&gt;), &lt;b&gt;pod2text&lt;/b&gt; will exit with status 0. If any of the documents being processed do not result in an output document, &lt;b&gt;pod2text&lt;/b&gt; will exit with status 1. If there are syntax errors in a POD document being processed and the error handling style is set to the default of &lt;code&gt;die&lt;/code&gt;, &lt;b&gt;pod2text&lt;/b&gt; will abort immediately with exit status 255.</source>
          <target state="translated">처리 된 모든 문서에서 일부 출력이 발생하는 한 해당 출력에 에라타 ( &lt;code&gt;--errors=pod&lt;/code&gt; 로 생성 된 &lt;code&gt;POD ERRORS&lt;/code&gt; 섹션 )가 포함되어 &lt;b&gt;있어도 pod2text&lt;/b&gt; 는 상태 0으로 종료됩니다. 출력 문서, &lt;b&gt;pod2text&lt;/b&gt; 는 상태 1로 종료됩니다. 처리중인 POD 문서에 구문 오류가 있고 오류 처리 스타일이 기본값 인 &lt;code&gt;die&lt;/code&gt; 로 &lt;b&gt;설정된&lt;/b&gt; 경우 &lt;b&gt;pod2text&lt;/b&gt; 는 종료 상태 255로 즉시 중단됩니다.&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="89c56046221181f7e1bfa30bafe704cdc7899788" translate="yes" xml:space="preserve">
          <source>As long as the code inside the SKIP block at least compiles. Please don't ask how. No, it's not a filter.</source>
          <target state="translated">SKIP 블록 내부의 코드가 적어도 컴파일되는 한. 방법을 묻지 마십시오. 아니요, 필터가 아닙니다.</target>
        </trans-unit>
        <trans-unit id="95c1aea5304f4de3806c6769617146a8ffc159e5" translate="yes" xml:space="preserve">
          <source>As long as the reference is never returned by any function within the module, no outside module can see the subroutine, because its name is not in any package's symbol table. Remember that it's not</source>
          <target state="translated">참조가 모듈 내의 함수에 의해 리턴되지 않는 한, 외부 모듈은 이름이 패키지의 기호 테이블에 없기 때문에 서브 루틴을 볼 수 없습니다. 그렇지 않다는 것을 기억하십시오</target>
        </trans-unit>
        <trans-unit id="9a46642b51b5bbcfbb8a5a0fab6a1a748c3835a7" translate="yes" xml:space="preserve">
          <source>As mentioned &lt;a href=&quot;#Mathemagic%2C-Mutators%2C-and-Copy-Constructors&quot;&gt;above&lt;/a&gt;, this operation is called when a mutator is applied to a reference that shares its object with some other reference. For example, if &lt;code&gt;$b&lt;/code&gt; is mathemagical, and &lt;code&gt;'++'&lt;/code&gt; is overloaded with &lt;code&gt;'incr'&lt;/code&gt;, and &lt;code&gt;'='&lt;/code&gt; is overloaded with &lt;code&gt;'clone'&lt;/code&gt;, then the code</source>
          <target state="translated">언급 한 바와 같이 &lt;a href=&quot;#Mathemagic%2C-Mutators%2C-and-Copy-Constructors&quot;&gt;전술 한&lt;/a&gt; , 이러한 동작들은 테이터는 기준에인가 될 때 다른 호출을 참조하여 주 그 목적이.되고 예를 들어 &lt;code&gt;$b&lt;/code&gt; 가 mathemagical이고 &lt;code&gt;'++'&lt;/code&gt; 가 &lt;code&gt;'incr'&lt;/code&gt; &lt;code&gt;'='&lt;/code&gt; 로 오버로드 되고 '=' 가 &lt;code&gt;'clone'&lt;/code&gt; 으로 오버로드 되면 코드는</target>
        </trans-unit>
        <trans-unit id="958bb5f65d2f4962aaa4f5dd2b31857927db841a" translate="yes" xml:space="preserve">
          <source>As mentioned &lt;a href=&quot;#Mathemagic%2c-Mutators%2c-and-Copy-Constructors&quot;&gt;above&lt;/a&gt;, this operation is called when a mutator is applied to a reference that shares its object with some other reference. For example, if &lt;code&gt;$b&lt;/code&gt; is mathemagical, and &lt;code&gt;'++'&lt;/code&gt; is overloaded with &lt;code&gt;'incr'&lt;/code&gt; , and &lt;code&gt;'='&lt;/code&gt; is overloaded with &lt;code&gt;'clone'&lt;/code&gt; , then the code</source>
          <target state="translated">언급 한 바와 같이 &lt;a href=&quot;#Mathemagic%2c-Mutators%2c-and-Copy-Constructors&quot;&gt;전술 한&lt;/a&gt; , 이러한 동작들은 테이터는 기준에인가 될 때 다른 호출을 참조하여 주 그 목적이.되고 예를 들어 &lt;code&gt;$b&lt;/code&gt; 가 mathemagical이고 &lt;code&gt;'++'&lt;/code&gt; 에 &lt;code&gt;'incr'&lt;/code&gt; 으로 과부하 되고 &lt;code&gt;'='&lt;/code&gt; 에 &lt;code&gt;'clone'&lt;/code&gt; 으로 과부하 된 경우 코드</target>
        </trans-unit>
        <trans-unit id="4a4d04edd6d111dfba357a91be03d0f8c653a2d2" translate="yes" xml:space="preserve">
          <source>As mentioned above under &lt;a href=&quot;#ALIASES&quot;&gt;&quot;ALIASES&quot;&lt;/a&gt;, Unicode 6.1 defines extra names (synonyms or aliases) for some code points, most of which were already available as Perl extensions. All these are accepted by &lt;code&gt;\N{...}&lt;/code&gt; and the other functions in this module, but &lt;code&gt;viacode&lt;/code&gt; has to choose which one name to return for a given input code point, so it returns the &quot;best&quot; name. To understand how this works, it is helpful to know more about the Unicode name properties. All code points actually have only a single name, which (starting in Unicode 2.0) can never change once a character has been assigned to the code point. But mistakes have been made in assigning names, for example sometimes a clerical error was made during the publishing of the Standard which caused words to be misspelled, and there was no way to correct those. The Name_Alias property was eventually created to handle these situations. If a name was wrong, a corrected synonym would be published for it, using Name_Alias. &lt;code&gt;viacode&lt;/code&gt; will return that corrected synonym as the &quot;best&quot; name for a code point. (It is even possible, though it hasn't happened yet, that the correction itself will need to be corrected, and so another Name_Alias can be created for that code point; &lt;code&gt;viacode&lt;/code&gt; will return the most recent correction.)</source>
          <target state="translated">&lt;a href=&quot;#ALIASES&quot;&gt;&quot;ALIASES&quot;&lt;/a&gt; 에서 위에서 언급했듯이 Unicode 6.1은 일부 코드 포인트에 대해 추가 이름 (동의어 또는 별칭)을 정의하며, 대부분은 이미 Perl 확장으로 사용 가능합니다. 이 모든 것은 &lt;code&gt;\N{...}&lt;/code&gt; 및이 모듈의 다른 기능에 의해 허용 되지만 &lt;code&gt;viacode&lt;/code&gt; 주어진 입력 코드 포인트에 대해 반환 할 이름을 선택해야하므로 &quot;최상의&quot;이름을 반환합니다. 이것이 어떻게 작동하는지 이해하려면 유니 코드 이름 속성에 대해 더 많이 아는 것이 도움이됩니다. 모든 코드 포인트에는 실제로 단일 이름 만 있으며 (유니 코드 2.0에서 시작) 문자가 코드 포인트에 할당 된 후에는 변경할 수 없습니다. 그러나 이름을 지정하는 데 실수가있었습니다. 예를 들어 표준을 게시하는 동안 때때로 성직자 오류가 발생하여 단어의 철자가 틀 렸으며이를 수정할 방법이 없었습니다. Name_Alias ​​속성은 결국 이러한 상황을 처리하기 위해 만들어졌습니다. 이름이 잘못된 경우 Name_Alias를 사용하여 수정 된 동의어가 게시됩니다. &lt;code&gt;viacode&lt;/code&gt; 수정 된 동의어를 코드 포인트의 &quot;최상의&quot;이름으로 반환합니다. (아직 발생하지 않았지만 수정 자체를 수정해야 할 수도 있으므로 해당 코드 포인트에 대해 다른 Name_Alias를 만들 수 있습니다. &lt;code&gt;viacode&lt;/code&gt; 는 가장 최근 수정을 반환합니다.)</target>
        </trans-unit>
        <trans-unit id="6db309618dd0587d20027a36c5759130977518d4" translate="yes" xml:space="preserve">
          <source>As mentioned above under &lt;a href=&quot;#ALIASES&quot;&gt;ALIASES&lt;/a&gt;, Unicode 6.1 defines extra names (synonyms or aliases) for some code points, most of which were already available as Perl extensions. All these are accepted by &lt;code&gt;\N{...}&lt;/code&gt; and the other functions in this module, but &lt;code&gt;viacode&lt;/code&gt; has to choose which one name to return for a given input code point, so it returns the &quot;best&quot; name. To understand how this works, it is helpful to know more about the Unicode name properties. All code points actually have only a single name, which (starting in Unicode 2.0) can never change once a character has been assigned to the code point. But mistakes have been made in assigning names, for example sometimes a clerical error was made during the publishing of the Standard which caused words to be misspelled, and there was no way to correct those. The Name_Alias property was eventually created to handle these situations. If a name was wrong, a corrected synonym would be published for it, using Name_Alias. &lt;code&gt;viacode&lt;/code&gt; will return that corrected synonym as the &quot;best&quot; name for a code point. (It is even possible, though it hasn't happened yet, that the correction itself will need to be corrected, and so another Name_Alias can be created for that code point; &lt;code&gt;viacode&lt;/code&gt; will return the most recent correction.)</source>
          <target state="translated">위에서 &lt;a href=&quot;#ALIASES&quot;&gt;ALIASES&lt;/a&gt; 에서 언급 한 바와 같이 , 유니 코드 6.1은 일부 코드 포인트에 대한 추가 이름 (동의어 또는 별명)을 정의하며 대부분은 이미 Perl 확장으로 사용 가능합니다. 이 모든 것은 &lt;code&gt;\N{...}&lt;/code&gt; 및이 모듈의 다른 기능에 의해 허용 되지만 &lt;code&gt;viacode&lt;/code&gt; 주어진 입력 코드 포인트에 대해 반환 할 이름을 선택해야하므로 &quot;최상의&quot;이름을 반환합니다. 이것이 어떻게 작동하는지 이해하려면 유니 코드 이름 속성에 대해 더 많이 아는 것이 도움이됩니다. 모든 코드 포인트는 실제로 단일 이름 만 가지고 있으며, 유니 코드 2.0으로 시작하면 코드 포인트에 문자가 할당 된 후에는 절대 변경할 수 없습니다. 그러나 이름 할당에 실수가 있었다. 예를 들어, 표준을 출판하는 동안 때때로 오류가 발생하여 단어의 철자가 틀 렸으며,이를 수정할 방법이 없었던 경우가있다. 이러한 상황을 처리하기 위해 Name_Alias ​​속성이 결국 만들어졌습니다. 이름이 잘못되면 Name_Alias를 사용하여 올바른 동의어가 게시됩니다. &lt;code&gt;viacode&lt;/code&gt; 수정 된 동의어를 코드 포인트의 &quot;최상의&quot;이름으로 반환합니다. (아직 발생하지는 않았지만 수정 자체를 수정해야 할 수 있으므로 해당 코드 포인트에 대해 다른 Name_Alias를 만들 수 있습니다. &lt;code&gt;viacode&lt;/code&gt; 코드 는 가장 최근의 수정을 반환합니다.)</target>
        </trans-unit>
        <trans-unit id="aa5ef151af9bb6073935edbcfff85b0147b33678" translate="yes" xml:space="preserve">
          <source>As mentioned above, UTF-8 uses a variable number of bytes to store a character. Characters with values 0...127 are stored in one byte, just like good ol' ASCII. Character 128 is stored as &lt;code&gt;v194.128&lt;/code&gt; ; this continues up to character 191, which is &lt;code&gt;v194.191&lt;/code&gt; . Now we've run out of bits (191 is binary &lt;code&gt;10111111&lt;/code&gt; ) so we move on; character 192 is &lt;code&gt;v195.128&lt;/code&gt; . And so it goes on, moving to three bytes at character 2048. &lt;a href=&quot;perlunicode#Unicode-Encodings&quot;&gt;Unicode Encodings in perlunicode&lt;/a&gt; has pictures of how this works.</source>
          <target state="translated">위에서 언급했듯이 UTF-8은 가변 바이트 수를 사용하여 문자를 저장합니다. 값이 0 ... 127 인 문자는 좋은 ol 'ASCII처럼 1 바이트에 저장됩니다. 문자 128은 &lt;code&gt;v194.128&lt;/code&gt; 로 저장됩니다 . 이는 문자 191 ( &lt;code&gt;v194.191&lt;/code&gt; ) 까지 계속됩니다 . 이제 비트가 부족합니다 (191은 이진수 &lt;code&gt;10111111&lt;/code&gt; 입니다 ). 문자 192는 &lt;code&gt;v195.128&lt;/code&gt; 입니다. 따라서 문자 2048에서 3 바이트로 이동합니다. &lt;a href=&quot;perlunicode#Unicode-Encodings&quot;&gt;perlunicode의 유니 코드 인코딩에는 이것이&lt;/a&gt; 어떻게 작동하는지에 대한 그림이 있습니다.</target>
        </trans-unit>
        <trans-unit id="6394bb5241172d16852f3bd3688b62b5907e9510" translate="yes" xml:space="preserve">
          <source>As mentioned above, UTF-8 uses a variable number of bytes to store a character. Characters with values 0...127 are stored in one byte, just like good ol' ASCII. Character 128 is stored as &lt;code&gt;v194.128&lt;/code&gt;; this continues up to character 191, which is &lt;code&gt;v194.191&lt;/code&gt;. Now we've run out of bits (191 is binary &lt;code&gt;10111111&lt;/code&gt;) so we move on; character 192 is &lt;code&gt;v195.128&lt;/code&gt;. And so it goes on, moving to three bytes at character 2048. &lt;a href=&quot;perlunicode#Unicode-Encodings&quot;&gt;&quot;Unicode Encodings&quot; in perlunicode&lt;/a&gt; has pictures of how this works.</source>
          <target state="translated">위에서 언급했듯이 UTF-8은 문자를 저장하기 위해 가변 바이트 수를 사용합니다. 값이 0 ... 127 인 문자는 좋은 ASCII와 마찬가지로 1 바이트에 저장됩니다. 문자 128은 &lt;code&gt;v194.128&lt;/code&gt; 로 저장됩니다 . 이것은 &lt;code&gt;v194.191&lt;/code&gt; 인 문자 191까지 계속됩니다 . 이제 우리는 비트 (191은 이진수 &lt;code&gt;10111111&lt;/code&gt; ) 가 부족 하여 계속 진행합니다. 문자 192는 &lt;code&gt;v195.128&lt;/code&gt; 입니다. 그리고 계속해서 2048 문자에서 3 바이트로 이동합니다. &lt;a href=&quot;perlunicode#Unicode-Encodings&quot;&gt;perlunicode의 &quot;Unicode Encodings&quot;에는 이것이&lt;/a&gt; 어떻게 작동하는지에 대한 그림이 있습니다.</target>
        </trans-unit>
        <trans-unit id="b80f86706a5e778489f2084a741a86389a8e67cd" translate="yes" xml:space="preserve">
          <source>As mentioned above, you can determine the context of the currently executing subroutine in Perl with</source>
          <target state="translated">위에서 언급 한 것처럼 Perl에서 현재 실행중인 서브 루틴의 컨텍스트를 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="00501a67a82ec0513abc29055abfbad02a55f669" translate="yes" xml:space="preserve">
          <source>As mentioned at the top of this document, if you are having problems with these example extensions, you might see if any of these help you.</source>
          <target state="translated">이 문서의 맨 위에 언급 된 것처럼 이러한 확장 예제에 문제가있는 경우 이러한 확장이 도움이되는지 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2746f2e141da00d82feca97a110b834cca59fd6d" translate="yes" xml:space="preserve">
          <source>As mentioned earlier, Perl can store a number in any one of three formats, but most operators typically understand only one of those formats. When a numeric value is passed as an argument to such an operator, it will be converted to the format understood by the operator.</source>
          <target state="translated">앞에서 언급했듯이 Perl은 세 가지 형식 중 하나로 숫자를 저장할 수 있지만 대부분의 연산자는 일반적으로 해당 형식 중 하나만 이해합니다. 이러한 연산자에 인수로 숫자 값을 전달하면 연산자가 이해하는 형식으로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="77154bb24a38474664192f3ea13c3d83da99f57f" translate="yes" xml:space="preserve">
          <source>As mentioned earlier, a &quot;callback&quot; key may be added to the &lt;code&gt;TAP::Parser&lt;/code&gt; constructor. If present, each callback corresponding to a given result type will be called with the result as the argument if the &lt;code&gt;run&lt;/code&gt; method is used. The callback is expected to be a subroutine reference (or anonymous subroutine) which is invoked with the parser result as its argument.</source>
          <target state="translated">앞에서 언급했듯이 &quot;콜백&quot;키가 &lt;code&gt;TAP::Parser&lt;/code&gt; 생성자에 추가 될 수 있습니다 . 존재하는 경우, 주어진 메소드 유형에 해당하는 각 콜백은 &lt;code&gt;run&lt;/code&gt; 메소드가 사용되는 경우 결과를 인수로 사용하여 호출 됩니다. 콜백은 파서 결과를 인수로 사용하여 호출되는 서브 루틴 참조 (또는 익명 서브 루틴) 여야합니다.</target>
        </trans-unit>
        <trans-unit id="4ebe40c302b03d332e451ead97b5b34c4f2894b9" translate="yes" xml:space="preserve">
          <source>As mentioned earlier, in the case of the default engines, the &lt;code&gt;pprivate&lt;/code&gt; will be a pointer to a regexp_internal structure which holds the compiled program and any additional data that is private to the regex engine implementation.</source>
          <target state="translated">앞에서 언급했듯이 기본 엔진의 경우 &lt;code&gt;pprivate&lt;/code&gt; 는 컴파일 된 프로그램과 정규식 엔진 구현 전용 인 추가 데이터를 보유하는 regexp_internal 구조에 대한 포인터입니다.</target>
        </trans-unit>
        <trans-unit id="05bef95fb25bb75da2eac006c647172d0c563725" translate="yes" xml:space="preserve">
          <source>As mentioned in &lt;a href=&quot;../encode&quot;&gt;Encode&lt;/a&gt;, encodings are (in the current implementation at least) defined as objects. The mapping of encoding name to object is via the &lt;code&gt;%Encode::Encoding&lt;/code&gt; hash. Though you can directly manipulate this hash, it is strongly encouraged to use this base class module and add encode() and decode() methods.</source>
          <target state="translated">&lt;a href=&quot;../encode&quot;&gt;Encode&lt;/a&gt; 에서 언급했듯이 인코딩은 (적어도 현재 구현에서는) 객체로 정의됩니다. 인코딩 이름과 객체의 매핑은 &lt;code&gt;%Encode::Encoding&lt;/code&gt; 해시를 통해 이루어집니다. 이 해시를 직접 조작 할 수 있지만이 기본 클래스 모듈을 사용하고 encode () 및 decode () 메소드를 추가하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="4b732b611600d48e618ee4980714b28a0f9ad12e" translate="yes" xml:space="preserve">
          <source>As mentioned in &lt;a href=&quot;encode&quot;&gt;Encode&lt;/a&gt;, encodings are (in the current implementation at least) defined as objects. The mapping of encoding name to object is via the &lt;code&gt;%Encode::Encoding&lt;/code&gt; hash. Though you can directly manipulate this hash, it is strongly encouraged to use this base class module and add encode() and decode() methods.</source>
          <target state="translated">&lt;a href=&quot;encode&quot;&gt;Encode&lt;/a&gt; 에서 언급했듯이 인코딩은 (적어도 현재 구현에서는) 객체로 정의됩니다. 개체에 대한 인코딩 이름의 매핑은 &lt;code&gt;%Encode::Encoding&lt;/code&gt; 해시를 통해 이루어집니다. 이 해시를 직접 조작 할 수 있지만이 기본 클래스 모듈을 사용하고 encode () 및 decode () 메서드를 추가하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="83fbfdaddc2272e65e0714e5d0f69ab35b42f974" translate="yes" xml:space="preserve">
          <source>As mentioned in the previous item, this still doesn't work when using socket I/O between Unix and Macintosh. You'll need to hard code your line terminators, in that case.</source>
          <target state="translated">이전 항목에서 언급했듯이 Unix와 Macintosh간에 소켓 I / O를 사용할 때는 여전히 작동하지 않습니다. 이 경우 줄 종결자를 하드 코딩해야합니다.</target>
        </trans-unit>
        <trans-unit id="ed52abb82f45ac71a451aad1bb7530a654fe2ad3" translate="yes" xml:space="preserve">
          <source>As mentioned previously, dynamic loading isn't currently available nor is MakeMaker. Both are high-priority items.</source>
          <target state="translated">앞에서 언급했듯이 동적 로딩은 현재 사용할 수 없으며 MakeMaker도 아닙니다. 둘 다 우선 순위가 높은 항목입니다.</target>
        </trans-unit>
        <trans-unit id="9fbc47f4ab04b1b192086c459c88acf77887350f" translate="yes" xml:space="preserve">
          <source>As mentioned, the function returns &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; if no name is known for the code point. In Unicode the proper name for these is the empty string, which &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; stringifies to. (If you ask for a code point past the legal Unicode maximum of U+10FFFF that you haven't assigned an alias to, you get &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; plus a warning.)</source>
          <target state="translated">언급 한 바와 같이, 함수는 코드 포인트에 대한 이름이 알려지지 않은 경우 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 를 리턴 합니다. 유니 코드에서 이것들에 대한 적절한 이름은 빈 문자열이며, &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 는 문자열 입니다. 별칭을 할당하지 않은 유효한 유니 코드 최대 U + 10FFFF를 초과하는 코드 포인트를 요청하면 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 와 경고가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="3d4ae46619b16556205991103a3ee51a24d3e1e6" translate="yes" xml:space="preserve">
          <source>As mentioned, the function returns &lt;code&gt;undef&lt;/code&gt; if no name is known for the code point. In Unicode the proper name for these is the empty string, which &lt;code&gt;undef&lt;/code&gt; stringifies to. (If you ask for a code point past the legal Unicode maximum of U+10FFFF that you haven't assigned an alias to, you get &lt;code&gt;undef&lt;/code&gt; plus a warning.)</source>
          <target state="translated">언급 &lt;code&gt;undef&lt;/code&gt; 함수는 코드 포인트에 대해 알려진 이름이 없으면 undef를 반환 합니다. 유니 코드에서 이들에 대한 적절한 이름은 &lt;code&gt;undef&lt;/code&gt; 문자열이되는 빈 문자열 입니다. (별칭을 할당하지 않은 유효한 유니 코드 최대 U + 10FFFF를 초과하는 코드 포인트를 요청하면 &lt;code&gt;undef&lt;/code&gt; 와 경고가 표시됩니다.)</target>
        </trans-unit>
        <trans-unit id="651eca43c6e2d73bc740fcae1016d17e36d82316" translate="yes" xml:space="preserve">
          <source>As most of the remaining expected output to the error stream will be created by &lt;a href=&quot;../builder&quot;&gt;Test::Builder&lt;/a&gt;'s &lt;code&gt;diag&lt;/code&gt; function, &lt;a href=&quot;tester&quot;&gt;Test::Builder::Tester&lt;/a&gt; provides a convenience function &lt;code&gt;test_diag&lt;/code&gt; that you can use instead of &lt;code&gt;test_err&lt;/code&gt; .</source>
          <target state="translated">오류 스트림에 남아있는 예상 출력의 대부분에 의해 생성 될 수있는 바와 같이 &lt;a href=&quot;../builder&quot;&gt;테스트 :: 빌더&lt;/a&gt; 의 &lt;code&gt;diag&lt;/code&gt; 기능, &lt;a href=&quot;tester&quot;&gt;테스트 :: 빌더 :: 테스터는&lt;/a&gt; 편리한 기능을 제공합니다 &lt;code&gt;test_diag&lt;/code&gt; 당신이 대신 사용할 수있는 &lt;code&gt;test_err&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="77c366c0e7fb4976a90caf137a45b2b3674180a3" translate="yes" xml:space="preserve">
          <source>As most of the remaining expected output to the error stream will be created by &lt;a href=&quot;Test::Builder&quot;&gt;Test::Builder&lt;/a&gt;'s &lt;code&gt;diag&lt;/code&gt; function, &lt;a href=&quot;Test::Builder::Tester&quot;&gt;Test::Builder::Tester&lt;/a&gt; provides a convenience function &lt;code&gt;test_diag&lt;/code&gt; that you can use instead of &lt;code&gt;test_err&lt;/code&gt;.</source>
          <target state="translated">오류 스트림에 남아있는 예상 출력의 대부분에 의해 생성 될 수있는 바와 같이 &lt;a href=&quot;Test::Builder&quot;&gt;테스트 :: 빌더&lt;/a&gt; 의 &lt;code&gt;diag&lt;/code&gt; 기능, &lt;a href=&quot;Test::Builder::Tester&quot;&gt;테스트 :: 빌더 :: 테스터는&lt;/a&gt; 편리한 기능을 제공합니다 &lt;code&gt;test_diag&lt;/code&gt; 당신이 대신 사용할 수있는 &lt;code&gt;test_err&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="7e01de119b6c27502755389f5ecb232b0f5fe3f3" translate="yes" xml:space="preserve">
          <source>As much as possible, the version.pm module remains compatible with all current code. However, if your module is using a module that has defined &lt;code&gt;$VERSION&lt;/code&gt; using the version class, there are a couple of things to be aware of. For purposes of discussion, we will assume that we have the following module installed:</source>
          <target state="translated">가능한 한 version.pm 모듈은 모든 현재 코드와 호환됩니다. 그러나 모듈이 버전 클래스를 사용하여 &lt;code&gt;$VERSION&lt;/code&gt; 을 정의한 모듈을 사용하는 경우 몇 가지 유의 해야 할 사항이 있습니다. 논의를 위해 다음 모듈이 설치되어 있다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="a3938aef953ff6d9fa864efd013ef275f9aaeca4" translate="yes" xml:space="preserve">
          <source>As noted above, if the file does not already exist, then the append-mode open will create it for you. But if the file does already exist, its contents are safe from harm because you will be adding your new text past the end of the old text.</source>
          <target state="translated">위에서 언급했듯이 파일이 존재하지 않으면 추가 모드가 열려 파일을 생성합니다. 그러나 파일이 이미 존재하는 경우 이전 텍스트의 끝을지나 새 텍스트를 추가하므로 파일 내용이 손상되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a7e52b3ee94a5bcfcbfa100ffa60b7bfdd3a2e7b" translate="yes" xml:space="preserve">
          <source>As noted above, the &lt;code&gt;mark&lt;/code&gt; variable itself will point at the most recently pushed value on the value stack before the list begins, and so the list itself starts at &lt;code&gt;mark + 1&lt;/code&gt;. The values of the list may be iterated by code such as</source>
          <target state="translated">위에서 언급했듯이 &lt;code&gt;mark&lt;/code&gt; 변수 자체는 목록이 시작되기 전에 값 스택에서 가장 최근에 푸시 된 값을 가리 키므로 목록 자체는 &lt;code&gt;mark + 1&lt;/code&gt; 에서 시작합니다 . 목록의 값은 다음과 같은 코드로 반복 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9988c3a40e007efc46894bc022da2f7d4a303e25" translate="yes" xml:space="preserve">
          <source>As noted above, xV references on the main value stack do not contribute to the reference count of an xV, and so another mechanism is used to track when temporary values which live on the stack must be released. This is the job of the temporaries stack.</source>
          <target state="translated">위에서 언급했듯이 기본 값 스택의 xV 참조는 xV의 참조 횟수에 기여하지 않으므로 스택에있는 임시 값을 해제해야하는시기를 추적하는 데 다른 메커니즘이 사용됩니다. 이것은 임시 스택의 작업입니다.</target>
        </trans-unit>
        <trans-unit id="aa50c7a75f631655fc7d60c7b218e502c8aba3fb" translate="yes" xml:space="preserve">
          <source>As noted earlier in this document, the scalar sense of list assignment is the number of elements on the right-hand side of the assignment. The null list contains no elements, so when the password file is exhausted, the result is 0, not 2.</source>
          <target state="translated">이 문서의 앞부분에서 언급했듯이 스칼라 목록 할당 감각은 할당 오른쪽에있는 요소의 수입니다. 널리스트에는 요소가 없으므로 암호 파일이 소진되면 결과는 2가 아니라 0입니다.</target>
        </trans-unit>
        <trans-unit id="3e5e8b8f30fce2b639027bd3be7728c79d978675" translate="yes" xml:space="preserve">
          <source>As noted in &lt;a href=&quot;#USING-LOCALES&quot;&gt;&quot;USING LOCALES&quot;&lt;/a&gt;, &lt;code&gt;cmp&lt;/code&gt; compares according to the current collation locale when &lt;code&gt;use locale&lt;/code&gt; is in effect, but falls back to a char-by-char comparison for strings that the locale says are equal. You can use &lt;code&gt;POSIX::strcoll()&lt;/code&gt; if you don't want this fall-back:</source>
          <target state="translated">&lt;a href=&quot;#USING-LOCALES&quot;&gt;&quot;USING LOCALES&quot;&lt;/a&gt; 에서 언급했듯이 , &lt;code&gt;cmp&lt;/code&gt; 는 &lt;code&gt;use locale&lt;/code&gt; 이 유효 할 때 현재 데이터 정렬 로케일에 따라 비교 하지만 로케일이 동일하다고 말하는 문자열에 대한 문자 별 비교로 돌아갑니다. 이 폴백을 원하지 않으면 &lt;code&gt;POSIX::strcoll()&lt;/code&gt; 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c32dd8a34a2658e1d2e1869aeb4cec0307b6493f" translate="yes" xml:space="preserve">
          <source>As noted in &lt;a href=&quot;#USING-LOCALES&quot;&gt;USING LOCALES&lt;/a&gt;, &lt;code&gt;cmp&lt;/code&gt; compares according to the current collation locale when &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; is in effect, but falls back to a char-by-char comparison for strings that the locale says are equal. You can use &lt;code&gt;POSIX::strcoll()&lt;/code&gt; if you don't want this fall-back:</source>
          <target state="translated">에 명시된 바와 같이 &lt;a href=&quot;#USING-LOCALES&quot;&gt;로케일을 사용&lt;/a&gt; , &lt;code&gt;cmp&lt;/code&gt; 때 현재 대조 지역에 따라 비교하여 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; 유효하지만, 로케일 동일 말한다 위로 스트링에 대한 문자 별 문자에 비해 떨어진다. 이 폴백을 원하지 않으면 &lt;code&gt;POSIX::strcoll()&lt;/code&gt; 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="39a23dc03cf7dc5e3d6e19189da7b65ab7a30cf2" translate="yes" xml:space="preserve">
          <source>As noted in &lt;a href=&quot;perlhack#TESTING&quot;&gt;&quot;TESTING&quot; in perlhack&lt;/a&gt;, when writing test scripts, the file</source>
          <target state="translated">&lt;a href=&quot;perlhack#TESTING&quot;&gt;perlhack의 &quot;TESTING&quot;에서&lt;/a&gt; 언급했듯이 테스트 스크립트를 작성할 때 파일은</target>
        </trans-unit>
        <trans-unit id="eda06429df1073940e96ea523060e042021aeec8" translate="yes" xml:space="preserve">
          <source>As noted in &lt;a href=&quot;perlhack#TESTING&quot;&gt;TESTING in perlhack&lt;/a&gt;, when writing test scripts, the file</source>
          <target state="translated">&lt;a href=&quot;perlhack#TESTING&quot;&gt;perlhack의 테스트에서&lt;/a&gt; 언급했듯이 테스트 스크립트를 작성할 때 파일</target>
        </trans-unit>
        <trans-unit id="1655e6b218596b71d5606712f426706cfda24e83" translate="yes" xml:space="preserve">
          <source>As of 1.37_02 install() supports the use of a list of patterns to filter out files that shouldn't be installed. If $skip is omitted or undefined then install will try to read the list from INSTALL.SKIP in the CWD. This file is a list of regular expressions and is just like the MANIFEST.SKIP file used by &lt;a href=&quot;ExtUtils::Manifest&quot;&gt;ExtUtils::Manifest&lt;/a&gt;.</source>
          <target state="translated">1.37_02부터 install ()은 설치하지 말아야 할 파일을 필터링하는 패턴 목록 사용을 지원합니다. $ skip이 생략되거나 정의되지 않은 경우 install은 CWD의 INSTALL.SKIP에서 목록을 읽으려고 시도합니다. 이 파일은 정규식 목록이며 &lt;a href=&quot;ExtUtils::Manifest&quot;&gt;ExtUtils :: Manifest에서&lt;/a&gt; 사용하는 MANIFEST.SKIP 파일과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="716cc3d3aff35fc6629ccc256677b64774af14df" translate="yes" xml:space="preserve">
          <source>As of 1.37_02 install() supports the use of a list of patterns to filter out files that shouldn't be installed. If $skip is omitted or undefined then install will try to read the list from INSTALL.SKIP in the CWD. This file is a list of regular expressions and is just like the MANIFEST.SKIP file used by &lt;a href=&quot;manifest&quot;&gt;ExtUtils::Manifest&lt;/a&gt;.</source>
          <target state="translated">1.37_02부터 install ()은 설치하지 않아야하는 파일을 필터링하기 위해 패턴 목록 사용을 지원합니다. $ skip이 생략되거나 정의되지 않은 경우 install은 CWD의 INSTALL.SKIP에서 목록을 읽으려고 시도합니다. 이 파일은 정규식 목록이며 &lt;a href=&quot;manifest&quot;&gt;ExtUtils :: Manifest에서&lt;/a&gt; 사용하는 MANIFEST.SKIP 파일과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="0f828a6d861469c7d75db52b836c69689c1760b7" translate="yes" xml:space="preserve">
          <source>As of 3.10, the internal data for all types of codes can be modified.</source>
          <target state="translated">3.10부터 모든 유형의 코드에 대한 내부 데이터를 수정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4f51af2e950bc010c45298268ec1c3013383b233" translate="yes" xml:space="preserve">
          <source>As of 5.14, none of these raises an exception if they are not supported on your platform. However, if warnings are enabled, a warning of the &lt;a href=&quot;warnings&quot;&gt;&lt;code&gt;printf&lt;/code&gt;&lt;/a&gt; warning class is issued on an unsupported conversion flag. Should you instead prefer an exception, do this:</source>
          <target state="translated">5.14부터는 플랫폼에서 지원되지 않는 경우 예외가 발생하지 않습니다. 그러나 경고가 사용 가능 하면 지원되지 않는 변환 플래그에 대해 &lt;a href=&quot;warnings&quot;&gt; &lt;code&gt;printf&lt;/code&gt; &lt;/a&gt; 경고 클래스의 경고가 발행됩니다. 대신 예외를 선호하는 경우 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="1d399ef50aa4f86fbc538d8e5d435b672ada57b9" translate="yes" xml:space="preserve">
          <source>As of 5.14, none of these raises an exception if they are not supported on your platform. However, if warnings are enabled, a warning of the &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; warning class is issued on an unsupported conversion flag. Should you instead prefer an exception, do this:</source>
          <target state="translated">5.14부터는 플랫폼에서 지원되지 않는 경우 예외가 발생하지 않습니다. 그러나 경고가 사용 가능한 경우 , 지원되지 않는 변환 플래그에 &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; 경고 클래스의 경고가 발행됩니다. 대신 예외를 선호하는 경우 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="fd9213ca43980debccb984d13f9caaa2e79748be" translate="yes" xml:space="preserve">
          <source>As of 5.14, none of these raises an exception if they are not supported on your platform. However, if warnings are enabled, a warning of the &lt;code&gt;&lt;a href=&quot;printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; warning class is issued on an unsupported conversion flag. Should you instead prefer an exception, do this:</source>
          <target state="translated">5.14부터는 플랫폼에서 지원되지 않는 경우 예외가 발생하지 않습니다. 그러나 경고가 사용 가능한 경우 , 지원되지 않는 변환 플래그에 &lt;code&gt;&lt;a href=&quot;printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; 경고 클래스의 경고가 발행됩니다. 대신 예외를 선호하는 경우 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="6791199e3f80fe4bbb43c0eaff9608d527ada74b" translate="yes" xml:space="preserve">
          <source>As of 5.14, that can also be written this way:</source>
          <target state="translated">5.14부터는 다음과 같이 쓸 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="b37d45aa3fafa285df8c8611054589c583244ea5" translate="yes" xml:space="preserve">
          <source>As of 5.19.9 setting &lt;code&gt;$/&lt;/code&gt; to any other form of reference will throw a fatal exception. This is in preparation for supporting new ways to set &lt;code&gt;$/&lt;/code&gt; in the future.</source>
          <target state="translated">5.19.9에서 &lt;code&gt;$/&lt;/code&gt; 를 다른 형식의 참조로 설정 하면 치명적인 예외가 발생합니다. 이것은 앞으로 &lt;code&gt;$/&lt;/code&gt; 를 설정하는 새로운 방법을 지원하기위한 준비입니다 .</target>
        </trans-unit>
        <trans-unit id="5090edb4c78c4b281b3a889d093a1c4d0aac43d2" translate="yes" xml:space="preserve">
          <source>As of 5.8.1, long doubles are working if you use the Sun compilers (needed for additional math routines not included in libm).</source>
          <target state="translated">5.8.1 현재 Sun 컴파일러를 사용하면 long doubles가 작동합니다 (libm에 포함되지 않은 추가 수학 루틴이 필요함).</target>
        </trans-unit>
        <trans-unit id="f508ee41697726e1567be3f0dd308006b0a11bbd" translate="yes" xml:space="preserve">
          <source>As of 5.8.1, the &lt;b&gt;-C&lt;/b&gt; can be followed either by a number or a list of option letters. The letters, their numeric values, and effects are as follows; listing the letters is equal to summing the numbers.</source>
          <target state="translated">5.8.1부터 &lt;b&gt;-C&lt;/b&gt; 뒤에 숫자 또는 옵션 문자 목록이 올 수 있습니다. 글자, 숫자 및 효과는 다음과 같습니다. 문자를 나열하는 것은 숫자를 합산하는 것과 같습니다.</target>
        </trans-unit>
        <trans-unit id="45cfda1b1b7f6423e5dd7ec6647effcbf0d30173" translate="yes" xml:space="preserve">
          <source>As of 5.9.5 the directive &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re 'debug'&lt;/code&gt; and its equivalents are lexically scoped, as are the other directives. However they have both compile-time and run-time effects.</source>
          <target state="translated">5.9.5 현재, 지시문 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re 'debug'&lt;/code&gt; 하고 다른 지시어와 마찬가지로 그 범위는 어휘 범위입니다. 그러나 컴파일 타임 및 런타임 효과가 모두 있습니다.</target>
        </trans-unit>
        <trans-unit id="d51f5d10f6eede269e073b2d28e8411b4b049f81" translate="yes" xml:space="preserve">
          <source>As of 5.9.5 the directive &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re 'debug'&lt;/code&gt; and its equivalents are lexically scoped, as the other directives are. However they have both compile-time and run-time effects.</source>
          <target state="translated">5.9.5 현재, 지시문 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re 'debug'&lt;/code&gt; 하고 다른 지시어와 마찬가지로 그 범위는 어휘 범위입니다. 그러나 컴파일 타임 및 런타임 효과가 모두 있습니다.</target>
        </trans-unit>
        <trans-unit id="88f554d7cda5067d9baf3d30fcba8c29b1dbb104" translate="yes" xml:space="preserve">
          <source>As of 5.9.5 the directive &lt;code&gt;use re 'debug'&lt;/code&gt; and its equivalents are lexically scoped, as are the other directives. However they have both compile-time and run-time effects.</source>
          <target state="translated">5.9.5부터 지시어 &lt;code&gt;use re 'debug'&lt;/code&gt; 하고 그에 상응하는 것은 다른 지시어와 마찬가지로 어휘 적으로 범위가 지정됩니다. 그러나 그들은 컴파일 타임과 런타임 효과를 모두 가지고 있습니다.</target>
        </trans-unit>
        <trans-unit id="6609b05c1701ded1ef1eec29d7bb5f4a5b93b02d" translate="yes" xml:space="preserve">
          <source>As of 5.9.5 the directive &lt;code&gt;use re 'debug'&lt;/code&gt; and its equivalents are lexically scoped, as the other directives are. However they have both compile-time and run-time effects.</source>
          <target state="translated">5.9.5부터 지시문 &lt;code&gt;use re 'debug'&lt;/code&gt; 하고 다른 지시문과 마찬가지로 그에 상응하는 범위가 어휘 적으로 지정됩니다. 그러나 그들은 컴파일 타임과 런타임 효과를 모두 가지고 있습니다.</target>
        </trans-unit>
        <trans-unit id="8b5a3958e4abf52ef71b991a4f025f997262e7e8" translate="yes" xml:space="preserve">
          <source>As of &lt;code&gt;Encode&lt;/code&gt; 2.12, &lt;code&gt;CHECK&lt;/code&gt; can also be a code reference which takes the ordinal value of the unmapped character as an argument and returns octets that represent the fallback character. For instance:</source>
          <target state="translated">현재 &lt;code&gt;Encode&lt;/code&gt; 2.12 &lt;code&gt;CHECK&lt;/code&gt; 는 또한 대체 문자를 나타내는 인수 및 반환 진수로 맵핑되지 않은 값의 문자 코드를 취하는 기준이 될 수있다. 예를 들어 :</target>
        </trans-unit>
        <trans-unit id="b411b3efc2bae2399e243c4103628c18af471dad" translate="yes" xml:space="preserve">
          <source>As of &lt;code&gt;Encode&lt;/code&gt; version 2.21, a new method &lt;code&gt;mime_name()&lt;/code&gt; is therefore added.</source>
          <target state="translated">현재 &lt;code&gt;Encode&lt;/code&gt; 버전 2.21, 새로운 방법 &lt;code&gt;mime_name()&lt;/code&gt; 따라서 첨가한다.</target>
        </trans-unit>
        <trans-unit id="703e152d6b7fb820f5c3dbc21f352bf9bc7a9e95" translate="yes" xml:space="preserve">
          <source>As of CPAN 1.9463, if you do not have permission to write the default perl library directories, CPAN's configuration process will ask you whether you want to bootstrap &amp;lt;local::lib&amp;gt;, which makes keeping a personal perl library directory easy.</source>
          <target state="translated">CPAN 1.9463부터 기본 perl 라이브러리 디렉토리를 작성할 수있는 권한이없는 경우 CPAN의 구성 프로세스는 &amp;lt;local :: lib&amp;gt;를 부트 스트랩 할 것인지 묻습니다. 이렇게하면 개인 perl 라이브러리 디렉토리를 쉽게 유지할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="07aaeb2f2c75fecbde3c90f6c2e907a83c502842" translate="yes" xml:space="preserve">
          <source>As of Encode 1.87, the older form</source>
          <target state="translated">Encode 1.87 기준으로 이전 형식</target>
        </trans-unit>
        <trans-unit id="b09ae12c2db054fb655cbb26f548a82db4c390c0" translate="yes" xml:space="preserve">
          <source>As of July 2002 (the Perl release 5.8.0), the following platforms were able to build Perl from the standard source code distribution available at &lt;a href=&quot;http://www.cpan.org/src/&quot;&gt;http://www.cpan.org/src/&lt;/a&gt;</source>
          <target state="translated">2002 년 7 월 (Perl 릴리스 5.8.0)부터 다음 플랫폼은 &lt;a href=&quot;http://www.cpan.org/src/&quot;&gt;http://www.cpan.org/src/에&lt;/a&gt; 있는 표준 소스 코드 배포에서 Perl을 빌드 할 수있었습니다 .</target>
        </trans-unit>
        <trans-unit id="fcab0673d5c88e7554da234165f977684b228be3" translate="yes" xml:space="preserve">
          <source>As of Perl 5.10, the &lt;code&gt;${^PREMATCH}&lt;/code&gt; , &lt;code&gt;${^MATCH}&lt;/code&gt; and &lt;code&gt;${^POSTMATCH}&lt;/code&gt; variables may be used. These are only set if the &lt;code&gt;/p&lt;/code&gt; modifier is present. Consequently they do not penalize the rest of the program. In Perl 5.20, &lt;code&gt;${^PREMATCH}&lt;/code&gt; , &lt;code&gt;${^MATCH}&lt;/code&gt; and &lt;code&gt;${^POSTMATCH}&lt;/code&gt; are available whether the &lt;code&gt;/p&lt;/code&gt; has been used or not (the modifier is ignored), and &lt;code&gt;$`&lt;/code&gt; , &lt;code&gt;$'&lt;/code&gt; and &lt;code&gt;$&amp;amp;&lt;/code&gt; do not cause any speed difference.</source>
          <target state="translated">Perl 5.10부터 &lt;code&gt;${^PREMATCH}&lt;/code&gt; , &lt;code&gt;${^MATCH}&lt;/code&gt; 및 &lt;code&gt;${^POSTMATCH}&lt;/code&gt; 변수를 사용할 수 있습니다. &lt;code&gt;/p&lt;/code&gt; 수정자가있는 경우에만 설정됩니다 . 결과적으로 그들은 프로그램의 나머지 부분에 불이익을주지 않습니다. 펄 5.20에서 &lt;code&gt;${^PREMATCH}&lt;/code&gt; , &lt;code&gt;${^MATCH}&lt;/code&gt; 와 &lt;code&gt;${^POSTMATCH}&lt;/code&gt; 여부를 확인할 수 있습니다 &lt;code&gt;/p&lt;/code&gt; (수정 무시) 사용 여부되었으며, &lt;code&gt;$`&lt;/code&gt; , &lt;code&gt;$'&lt;/code&gt; 와 &lt;code&gt;$&amp;amp;&lt;/code&gt; 하지 속도 차이가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="e79e99fb499b4f259d0eaa53033cd09b0a52555d" translate="yes" xml:space="preserve">
          <source>As of Perl 5.10, the &lt;code&gt;${^PREMATCH}&lt;/code&gt;, &lt;code&gt;${^MATCH}&lt;/code&gt; and &lt;code&gt;${^POSTMATCH}&lt;/code&gt; variables may be used. These are only set if the &lt;code&gt;/p&lt;/code&gt; modifier is present. Consequently they do not penalize the rest of the program. In Perl 5.20, &lt;code&gt;${^PREMATCH}&lt;/code&gt;, &lt;code&gt;${^MATCH}&lt;/code&gt; and &lt;code&gt;${^POSTMATCH}&lt;/code&gt; are available whether the &lt;code&gt;/p&lt;/code&gt; has been used or not (the modifier is ignored), and &lt;code&gt;$`&lt;/code&gt;, &lt;code&gt;$'&lt;/code&gt; and &lt;code&gt;$&amp;amp;&lt;/code&gt; do not cause any speed difference.</source>
          <target state="translated">Perl 5.10부터 &lt;code&gt;${^PREMATCH}&lt;/code&gt; , &lt;code&gt;${^MATCH}&lt;/code&gt; 및 &lt;code&gt;${^POSTMATCH}&lt;/code&gt; 변수를 사용할 수 있습니다. &lt;code&gt;/p&lt;/code&gt; 수정자가있는 경우에만 설정됩니다 . 따라서 나머지 프로그램에 불이익을주지 않습니다. Perl 5.20에서 &lt;code&gt;${^PREMATCH}&lt;/code&gt; , &lt;code&gt;${^MATCH}&lt;/code&gt; 및 &lt;code&gt;${^POSTMATCH}&lt;/code&gt; 는 &lt;code&gt;/p&lt;/code&gt; 사용 여부 (수정자는 무시 됨)에 관계없이 사용할 수 있으며 &lt;code&gt;$`&lt;/code&gt; , &lt;code&gt;$'&lt;/code&gt; 및 &lt;code&gt;$&amp;amp;&lt;/code&gt; 는 사용할 수 없습니다. 속도 차이가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="eafa84154e8f8c3596803a7b5e3904a497adc460" translate="yes" xml:space="preserve">
          <source>As of Perl 5.10, this pragma is lexically scoped and takes effect at compile time. In earlier versions its effect was global and took effect at run-time; the documentation suggested using &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval()&lt;/a&gt;&lt;/code&gt; to change the behaviour:</source>
          <target state="translated">Perl 5.10부터이 pragma는 어휘 범위가 있으며 컴파일시 적용됩니다. 이전 버전에서는 그 효과가 전역 적이며 런타임에 적용되었습니다. 설명서는 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval()&lt;/a&gt;&lt;/code&gt; 을 사용하여 동작을 변경하도록 제안했습니다 .</target>
        </trans-unit>
        <trans-unit id="331b4594e4263cc88f44953b4d0b8305968e3f99" translate="yes" xml:space="preserve">
          <source>As of Perl 5.10, this pragma is lexically scoped and takes effect at compile time. In earlier versions its effect was global and took effect at run-time; the documentation suggested using &lt;code&gt;eval()&lt;/code&gt; to change the behaviour:</source>
          <target state="translated">Perl 5.10부터이 pragma는 어휘 범위가 지정되며 컴파일 타임에 적용됩니다. 이전 버전에서는 그 효과가 전역 적이며 런타임에 적용되었습니다. 동작을 변경하기 위해 &lt;code&gt;eval()&lt;/code&gt; 을 사용하여 제안 된 문서 :</target>
        </trans-unit>
        <trans-unit id="86d4d0145ccce27050aa6a59ab5275c8b3a0cdb0" translate="yes" xml:space="preserve">
          <source>As of Perl 5.10, you can match balanced text with regular expressions using recursive patterns. Before Perl 5.10, you had to resort to various tricks such as using Perl code in &lt;code&gt;(??{})&lt;/code&gt; sequences.</source>
          <target state="translated">Perl 5.10부터 재귀 패턴을 사용하여 균형 잡힌 텍스트를 정규식과 일치시킬 수 있습니다. Perl 5.10 이전에는 &lt;code&gt;(??{})&lt;/code&gt; 시퀀스 에서 Perl 코드 사용과 같은 다양한 트릭을 사용해야했습니다 .</target>
        </trans-unit>
        <trans-unit id="eea5149372feb11e1db38e07d50576f276a6c743" translate="yes" xml:space="preserve">
          <source>As of Perl 5.10.0, Perl supports several Python/PCRE-specific extensions to the regex syntax. While Perl programmers are encouraged to use the Perl-specific syntax, the following are also accepted:</source>
          <target state="translated">Perl 5.10.0부터 Perl은 정규 표현식 구문에 대한 여러 Python / PCRE 특정 확장을 지원합니다. Perl 프로그래머는 Perl 특정 구문을 사용하도록 권장되지만 다음 사항도 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="793e424fe5bef6967b0c0b6751f2a3b12bcf501f" translate="yes" xml:space="preserve">
          <source>As of Perl 5.10.0, as a form of purely syntactic sugar, you can stack file test operators, in a way that &lt;code&gt;-f -w -x $file&lt;/code&gt; is equivalent to &lt;code&gt;-x $file &amp;amp;&amp;amp; -w _ &amp;amp;&amp;amp; -f _&lt;/code&gt; . (This is only fancy syntax: if you use the return value of &lt;code&gt;-f $file&lt;/code&gt; as an argument to another filetest operator, no special magic will happen.)</source>
          <target state="translated">Perl 5.10.0부터 순전히 구문 설탕의 형태로 &lt;code&gt;-f -w -x $file&lt;/code&gt; 이 &lt;code&gt;-x $file &amp;amp;&amp;amp; -w _ &amp;amp;&amp;amp; -f _&lt;/code&gt; 와 같은 방식으로 파일 테스트 연산자를 스택 할 수 있습니다 . (이것은 멋진 구문입니다. &lt;code&gt;-f $file&lt;/code&gt; 의 반환 값 을 다른 파일 테스트 연산자의 인수로 사용하면 특별한 마법이 발생하지 않습니다.)</target>
        </trans-unit>
        <trans-unit id="03db908cbb1531eee3e0f01a16bb3f1d5ad12f15" translate="yes" xml:space="preserve">
          <source>As of Perl 5.10.0, as a form of purely syntactic sugar, you can stack file test operators, in a way that &lt;code&gt;-f -w -x $file&lt;/code&gt; is equivalent to &lt;code&gt;-x $file &amp;amp;&amp;amp; -w _ &amp;amp;&amp;amp; -f _&lt;/code&gt;. (This is only fancy syntax: if you use the return value of &lt;code&gt;-f $file&lt;/code&gt; as an argument to another filetest operator, no special magic will happen.)</source>
          <target state="translated">Perl 5.10.0부터는 순전히 구문 적 설탕의 형태로 &lt;code&gt;-f -w -x $file&lt;/code&gt; 이 &lt;code&gt;-x $file &amp;amp;&amp;amp; -w _ &amp;amp;&amp;amp; -f _&lt;/code&gt; 와 동일한 방식으로 파일 테스트 연산자를 스택 할 수 있습니다 . (이것은 멋진 구문 일뿐입니다. &lt;code&gt;-f $file&lt;/code&gt; 의 반환 값 을 다른 filetest 연산자에 대한 인수로 사용하면 특별한 마법이 발생하지 않습니다.)</target>
        </trans-unit>
        <trans-unit id="4eb7e07d934fae953d19f8161458d55420e41446" translate="yes" xml:space="preserve">
          <source>As of Perl 5.10.0, one can create custom regular expression engines. This is not for the faint of heart, as they have to plug in at the C level. See &lt;a href=&quot;perlreapi&quot;&gt;perlreapi&lt;/a&gt; for more details.</source>
          <target state="translated">Perl 5.10.0부터 사용자 정의 정규식 엔진을 작성할 수 있습니다. C 레벨에서 플러그를 꽂아야하기 때문에 희미한 마음이 아닙니다. 자세한 내용은 &lt;a href=&quot;perlreapi&quot;&gt;perlreapi&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="0c7a09399a8f27b12757a6f71f279fa17b42fdfd" translate="yes" xml:space="preserve">
          <source>As of Perl 5.10.0, you can also use the &lt;code&gt;&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;&lt;/code&gt; modifiers to force big- or little-endian byte-order. This is useful if you want to store signed integers or 64-bit integers, for example.</source>
          <target state="translated">Perl 5.10.0부터는 &lt;code&gt;&amp;gt;&lt;/code&gt; 및 &lt;code&gt;&amp;lt;&lt;/code&gt; 수정자를 사용하여 빅 엔디안 또는 리틀 엔디안 바이트 순서를 강제 할 수도 있습니다 . 예를 들어 부호있는 정수 또는 64 비트 정수를 저장하려는 경우에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="835734cf27f076a5a1e9340fb76782ceeb1a149b" translate="yes" xml:space="preserve">
          <source>As of Perl 5.10.1 there is a new interface for plugging and using method resolution orders other than the default (linear depth first search). The C3 method resolution order added in 5.10.0 has been re-implemented as a plugin, without changing its Perl-space interface.</source>
          <target state="translated">Perl 5.10.1부터는 기본값 (선형 깊이 우선 검색) 이외의 방법 해결 순서를 연결하고 사용하기위한 새로운 인터페이스가 있습니다. 5.10.0에 추가 된 C3 메소드 분석 순서는 Perl-space 인터페이스를 변경하지 않고 플러그인으로 다시 구현되었습니다.</target>
        </trans-unit>
        <trans-unit id="ec3d8a5f4531571b478743636520cd49e4ac13cb" translate="yes" xml:space="preserve">
          <source>As of Perl 5.12 you can use a bare &lt;a href=&quot;#readdir-DIRHANDLE&quot;&gt;&lt;code&gt;readdir&lt;/code&gt;&lt;/a&gt; in a &lt;code&gt;while&lt;/code&gt; loop, which will set &lt;a href=&quot;perlvar#%24_&quot;&gt;&lt;code&gt;$_&lt;/code&gt;&lt;/a&gt; on every iteration. If either a &lt;code&gt;readdir&lt;/code&gt; expression or an explicit assignment of a &lt;code&gt;readdir&lt;/code&gt; expression to a scalar is used as a &lt;code&gt;while&lt;/code&gt;/&lt;code&gt;for&lt;/code&gt; condition, then the condition actually tests for definedness of the expression's value, not for its regular truth value.</source>
          <target state="translated">Perl 5.12 부터는 반복 할 때마다 &lt;a href=&quot;perlvar#%24_&quot;&gt; &lt;code&gt;$_&lt;/code&gt; &lt;/a&gt; 를 설정 하는 &lt;code&gt;while&lt;/code&gt; 루프 에서 베어 &lt;a href=&quot;#readdir-DIRHANDLE&quot;&gt; &lt;code&gt;readdir&lt;/code&gt; &lt;/a&gt; 을 사용할 수 있습니다 . 두 경우 &lt;code&gt;readdir&lt;/code&gt; 표현 또는 명시 적 할당 &lt;code&gt;readdir&lt;/code&gt; 스칼라에 대한 표현이 사용되는 &lt;code&gt;while&lt;/code&gt; / &lt;code&gt;for&lt;/code&gt; 조건 다음 조건은 실제로하지 정기적 인 진리 값에 대한 표현식의 값 definedness에 대한 테스트합니다.</target>
        </trans-unit>
        <trans-unit id="4ca2607d4b8da91c9aab14d61ac0b65b288bfff7" translate="yes" xml:space="preserve">
          <source>As of Perl 5.12 you can use a bare &lt;code&gt;&lt;a href=&quot;functions/readdir&quot;&gt;readdir&lt;/a&gt;&lt;/code&gt; in a &lt;code&gt;while&lt;/code&gt; loop, which will set &lt;code&gt;$_&lt;/code&gt; on every iteration.</source>
          <target state="translated">Perl 5.12 부터는 반복문에서 &lt;code&gt;$_&lt;/code&gt; 를 설정 하는 &lt;code&gt;while&lt;/code&gt; 루프 에서 베어 &lt;code&gt;&lt;a href=&quot;functions/readdir&quot;&gt;readdir&lt;/a&gt;&lt;/code&gt; 을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7ef4b7baf6bbb1a8636644643a30ec84c9a4f514" translate="yes" xml:space="preserve">
          <source>As of Perl 5.12 you can use a bare &lt;code&gt;&lt;a href=&quot;readdir&quot;&gt;readdir&lt;/a&gt;&lt;/code&gt; in a &lt;code&gt;while&lt;/code&gt; loop, which will set &lt;code&gt;$_&lt;/code&gt; on every iteration.</source>
          <target state="translated">Perl 5.12 부터는 반복문에서 &lt;code&gt;$_&lt;/code&gt; 를 설정 하는 &lt;code&gt;while&lt;/code&gt; 루프 에서 베어 &lt;code&gt;&lt;a href=&quot;readdir&quot;&gt;readdir&lt;/a&gt;&lt;/code&gt; 을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9aad368f35112b0ebb60af7e4b6035d03ee10832" translate="yes" xml:space="preserve">
          <source>As of Perl 5.12, deprecated features and modules warn the user as they're used. When a module is deprecated, it will also be made available on CPAN. Installing it from CPAN will silence deprecation warnings for that module.</source>
          <target state="translated">Perl 5.12부터는 더 이상 사용되지 않는 기능 및 모듈이 사용됨에 따라 경고합니다. 더 이상 사용되지 않는 모듈은 CPAN에서도 사용할 수 있습니다. CPAN에서 설치하면 해당 모듈에 대한 지원 중단 경고가 표시되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7bc75da6cf8214f9a49a145ca7f1ff6dd1976a38" translate="yes" xml:space="preserve">
          <source>As of Perl 5.18 every hash has its own hash traversal order, and this order changes every time a new element is inserted into the hash. This functionality is provided by maintaining an unsigned integer mask (U32) which is xor'ed with the actual bucket id during a traversal of the hash buckets using keys(), values() or each().</source>
          <target state="translated">Perl 5.18부터 모든 해시는 고유 한 해시 순회 순서를 가지며이 순서는 새 요소가 해시에 삽입 될 때마다 변경됩니다. 이 기능은 keys (), values ​​() 또는 each ()를 사용하여 해시 버킷을 순회하는 동안 실제 버킷 ID로 xor'ed 부호없는 정수 마스크 (U32)를 유지함으로써 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="52e65492e2356da13376652cd3b63537c008c53e" translate="yes" xml:space="preserve">
          <source>As of Perl 5.18 you can use a bare &lt;a href=&quot;#each-HASH&quot;&gt;&lt;code&gt;each&lt;/code&gt;&lt;/a&gt; in a &lt;code&gt;while&lt;/code&gt; loop, which will set &lt;a href=&quot;perlvar#%24_&quot;&gt;&lt;code&gt;$_&lt;/code&gt;&lt;/a&gt; on every iteration. If either an &lt;code&gt;each&lt;/code&gt; expression or an explicit assignment of an &lt;code&gt;each&lt;/code&gt; expression to a scalar is used as a &lt;code&gt;while&lt;/code&gt;/&lt;code&gt;for&lt;/code&gt; condition, then the condition actually tests for definedness of the expression's value, not for its regular truth value.</source>
          <target state="translated">Perl 5.18 부터는 &lt;code&gt;while&lt;/code&gt; 루프 에서 베어 &lt;a href=&quot;#each-HASH&quot;&gt; &lt;code&gt;each&lt;/code&gt; &lt;/a&gt; 을 사용할 수 있으며 , 이는 매 반복마다 &lt;a href=&quot;perlvar#%24_&quot;&gt; &lt;code&gt;$_&lt;/code&gt; &lt;/a&gt; 를 설정 합니다. 어느 쪽인가하면 &lt;code&gt;each&lt;/code&gt; 발현 또는 명시 적 할당 &lt;code&gt;each&lt;/code&gt; 스칼라에 대한 표현이 사용되는 &lt;code&gt;while&lt;/code&gt; / &lt;code&gt;for&lt;/code&gt; 조건 다음 조건은 실제로하지 정기적 인 진리 값에 대한 표현식의 값 definedness에 대한 테스트합니다.</target>
        </trans-unit>
        <trans-unit id="a8b875400d906734f1b4f9f29eb27503d8a35f16" translate="yes" xml:space="preserve">
          <source>As of Perl 5.18 you can use a bare &lt;code&gt;&lt;a href=&quot;each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; in a &lt;code&gt;while&lt;/code&gt; loop, which will set &lt;code&gt;$_&lt;/code&gt; on every iteration.</source>
          <target state="translated">펄 5.18의로서 당신은이 베어 사용할 수있는 &lt;code&gt;&lt;a href=&quot;each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; A의 &lt;code&gt;while&lt;/code&gt; 설정합니다 루프, &lt;code&gt;$_&lt;/code&gt; 모든 반복에.</target>
        </trans-unit>
        <trans-unit id="211e0f721f82a57a3e303b9bd4a37e7c878adb86" translate="yes" xml:space="preserve">
          <source>As of Perl 5.18 you can use a bare &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; in a &lt;code&gt;while&lt;/code&gt; loop, which will set &lt;code&gt;$_&lt;/code&gt; on every iteration.</source>
          <target state="translated">펄 5.18의로서 당신은이 베어 사용할 수있는 &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; A의 &lt;code&gt;while&lt;/code&gt; 설정합니다 루프, &lt;code&gt;$_&lt;/code&gt; 모든 반복에.</target>
        </trans-unit>
        <trans-unit id="c33c32e4c4b133822c39af8f8540bc2360a9b3e1" translate="yes" xml:space="preserve">
          <source>As of Perl 5.20, instead of &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings FATAL =&amp;gt; 'all';&lt;/code&gt; you can use:</source>
          <target state="translated">Perl 5.20부터 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings FATAL =&amp;gt; 'all';&lt;/code&gt; 대신 &lt;a href=&quot;functions/use&quot;&gt;사용&lt;/a&gt; FATAL =&amp;gt; 'all'; 당신이 사용할 수있는:</target>
        </trans-unit>
        <trans-unit id="9ee11b59ca6b84291fdd57fa90c4a5348d5dae02" translate="yes" xml:space="preserve">
          <source>As of Perl 5.20, instead of &lt;code&gt;use warnings FATAL =&amp;gt; 'all';&lt;/code&gt; you can use:</source>
          <target state="translated">Perl 5.20부터 &lt;code&gt;use warnings FATAL =&amp;gt; 'all';&lt;/code&gt; 를 사용하는 대신 FATAL =&amp;gt; 'all'; 당신이 사용할 수있는:</target>
        </trans-unit>
        <trans-unit id="c35a63f8082ff3fbb7b2bded313d23f6fdc3cfd9" translate="yes" xml:space="preserve">
          <source>As of Perl 5.22, there is an experimental variant of this loop that accepts a variable preceded by a backslash for VAR, in which case the items in the LIST must be references. The backslashed variable will become an alias to each referenced item in the LIST, which must be of the correct type. The variable needn't be a scalar in this case, and the backslash may be followed by &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt;. To use this form, you must enable the &lt;code&gt;refaliasing&lt;/code&gt; feature via &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature&lt;/code&gt; . (See &lt;a href=&quot;feature&quot;&gt;feature&lt;/a&gt;. See also &lt;a href=&quot;perlref#Assigning-to-References&quot;&gt;Assigning to References in perlref&lt;/a&gt;.)</source>
          <target state="translated">Perl 5.22부터는 VAR에 대해 백 슬래시가 앞에 오는 변수를 허용하는이 루프의 실험적인 변형이 있습니다.이 경우 LIST의 항목은 참조 여야합니다. 백 슬래시 변수는 LIST의 각 참조 항목에 대한 별명이되며 올바른 유형이어야합니다. 이 경우 변수는 스칼라 일 필요가 없으며 백 슬래시 뒤에 &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; 가 올 수 있습니다 . 이 양식을 사용하려면 활성화해야합니다 &lt;code&gt;refaliasing&lt;/code&gt; 를 통해 기능 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature&lt;/code&gt; . (참조 &lt;a href=&quot;feature&quot;&gt;기능을&lt;/a&gt; . 참조 &lt;a href=&quot;perlref#Assigning-to-References&quot;&gt;perlref에 참조로 지정&lt;/a&gt; .)</target>
        </trans-unit>
        <trans-unit id="4cc3a1608477d241ae1d9f45daf77429c175f625" translate="yes" xml:space="preserve">
          <source>As of Perl 5.22, there is an experimental variant of this loop that accepts a variable preceded by a backslash for VAR, in which case the items in the LIST must be references. The backslashed variable will become an alias to each referenced item in the LIST, which must be of the correct type. The variable needn't be a scalar in this case, and the backslash may be followed by &lt;code&gt;my&lt;/code&gt;. To use this form, you must enable the &lt;code&gt;refaliasing&lt;/code&gt; feature via &lt;code&gt;use feature&lt;/code&gt;. (See &lt;a href=&quot;feature&quot;&gt;feature&lt;/a&gt;. See also &lt;a href=&quot;perlref#Assigning-to-References&quot;&gt;&quot;Assigning to References&quot; in perlref&lt;/a&gt;.)</source>
          <target state="translated">Perl 5.22부터는 VAR에 대해 백 슬래시가 앞에 오는 변수를 받아들이는이 루프의 실험적인 변형이 있습니다.이 경우 LIST의 항목은 참조 여야합니다. 백 슬래시 변수는 LIST에서 참조 된 각 항목에 대한 별칭이되며 올바른 유형이어야합니다. 이 경우 변수는 스칼라 일 필요가 없으며 백 슬래시 뒤에 &lt;code&gt;my&lt;/code&gt; . 이 양식을 사용하려면 use feature를 통해 &lt;code&gt;refaliasing&lt;/code&gt; 기능을 활성화해야 &lt;code&gt;use feature&lt;/code&gt; . ( &lt;a href=&quot;feature&quot;&gt;기능 &lt;/a&gt;&lt;a href=&quot;perlref#Assigning-to-References&quot;&gt;참조&lt;/a&gt; . perlref의 &quot;참조에 할당&quot; 도 참조하십시오 .)</target>
        </trans-unit>
        <trans-unit id="df42579e1cb5e3f110d0c1cf4c3bbc08eda67128" translate="yes" xml:space="preserve">
          <source>As of Perl 5.22, this buggy behavior, while preserved for backward compatibility, is detected and emits a deprecation warning. If you want the subroutine to be inlined (with no warning), make sure the variable is not used in a context where it could be modified aside from where it is declared.</source>
          <target state="translated">Perl 5.22부터는이 버기 동작이 이전 버전과의 호환성을 위해 유지되는 동안 감지되어 사용 중단 경고가 표시됩니다. 서브 루틴을 경고없이 인라인하려면 변수가 선언 된 위치와 별도로 수정 될 수있는 컨텍스트에서 변수를 사용하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="b18e8f64ae6fd8a43ee4372bec94f73e67d74058" translate="yes" xml:space="preserve">
          <source>As of Perl 5.22, you can also use &lt;code&gt;(&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;)x2&lt;/code&gt; instead of &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;, &lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; . (You can also do &lt;code&gt;($x) x 2&lt;/code&gt; , which is less useful, because it assigns to the same variable twice, clobbering the first value assigned.)</source>
          <target state="translated">Perl 5.22부터 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;, &lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; , &lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt; 대신 &lt;code&gt;(&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;)x2&lt;/code&gt; 를 사용할 수도 있습니다 . ( &lt;code&gt;($x) x 2&lt;/code&gt; 수행 할 수도 있습니다.이 변수는 동일한 변수에 두 번 할당되어 할당 된 첫 번째 값을 방해하므로 덜 유용합니다.)</target>
        </trans-unit>
        <trans-unit id="adc72631156437f156fe787062790a9076462201" translate="yes" xml:space="preserve">
          <source>As of Perl 5.22, you can also use &lt;code&gt;(undef)x2&lt;/code&gt; instead of &lt;code&gt;undef, undef&lt;/code&gt;. (You can also do &lt;code&gt;($x) x 2&lt;/code&gt;, which is less useful, because it assigns to the same variable twice, clobbering the first value assigned.)</source>
          <target state="translated">Perl 5.22 &lt;code&gt;undef, undef&lt;/code&gt; 대신 &lt;code&gt;(undef)x2&lt;/code&gt; 를 사용할 수도 있습니다 . ( &lt;code&gt;($x) x 2&lt;/code&gt; 수행 할 수도 있는데, 이는 동일한 변수에 두 번 할당되어 할당 된 첫 번째 값을 방해하기 때문에 덜 유용합니다.)</target>
        </trans-unit>
        <trans-unit id="485dbe5ed6cb5d47f12b9abb8eb25ef72fc078a7" translate="yes" xml:space="preserve">
          <source>As of Perl 5.24, use of this feature no longer triggers a warning, though the &lt;code&gt;experimental::postderef&lt;/code&gt; warning category still exists (for compatibility with code that disables it).</source>
          <target state="translated">Perl 5.24 &lt;code&gt;experimental::postderef&lt;/code&gt; 기능을 사용하면 더 이상 경고가 발생하지 않지만, 실험적 :: postderef 경고 범주는 여전히 존재합니다 (사용하지 않는 코드와의 호환성을 위해).</target>
        </trans-unit>
        <trans-unit id="795c67df489058534540e8b295b838da24c8850d" translate="yes" xml:space="preserve">
          <source>As of Perl 5.25 the return was changed to be the count of keys in the hash. If you need access to the old behavior you can use &lt;code&gt;Hash::Util::bucket_ratio()&lt;/code&gt; instead.</source>
          <target state="translated">Perl 5.25에서 반환 값은 해시의 키 개수로 변경되었습니다. 이전 동작에 액세스해야하는 경우 대신 &lt;code&gt;Hash::Util::bucket_ratio()&lt;/code&gt; 를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9a4dc26e9cc8e6190d88b95c93b52fd5320659be" translate="yes" xml:space="preserve">
          <source>As of Perl 5.26, the list-context range operator on strings works as expected in the scope of &lt;a href=&quot;feature#The-%27unicode_strings%27-feature&quot;&gt;&lt;code&gt;&quot;use feature 'unicode_strings&quot;&lt;/code&gt;&lt;/a&gt;. In previous versions, and outside the scope of that feature, it exhibits &lt;a href=&quot;perlunicode#The-%22Unicode-Bug%22&quot;&gt;&quot;The &quot;Unicode Bug&quot;&quot; in perlunicode&lt;/a&gt;: its behavior depends on the internal encoding of the range endpoint.</source>
          <target state="translated">Perl 5.26부터 문자열에 대한 목록 컨텍스트 범위 연산자는 &lt;a href=&quot;feature#The-%27unicode_strings%27-feature&quot;&gt; &lt;code&gt;&quot;use feature 'unicode_strings&quot;&lt;/code&gt; &lt;/a&gt; 범위에서 예상대로 작동합니다 . 이전 버전에서는 해당 기능의 범위 밖에서 &lt;a href=&quot;perlunicode#The-%22Unicode-Bug%22&quot;&gt;perlunicode에서 &quot;The&quot;Unicode Bug &quot;&quot;가 나타납니다&lt;/a&gt; . 동작은 범위 끝점의 내부 인코딩에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="f8155f16a3b816f25d3b7bda9eaf9e783e3bae93" translate="yes" xml:space="preserve">
          <source>As of Perl 5.26, use of this feature no longer triggers a warning, though the &lt;code&gt;experimental::lexical_subs&lt;/code&gt; warning category still exists (for compatibility with code that disables it). In addition, this syntax is not only no longer experimental, but it is enabled for all Perl code, regardless of what feature declarations are in scope.</source>
          <target state="translated">Perl 5.26부터이 기능을 사용하면 더 이상 경고가 발생하지 않습니다. 그러나 &lt;code&gt;experimental::lexical_subs&lt;/code&gt; 경고 범주는 여전히 존재합니다 (비활성화하는 코드와의 호환성을 위해). 또한이 구문은 더 이상 실험적이지 않을뿐만 아니라 범위에있는 기능 선언에 관계없이 모든 Perl 코드에 대해 활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="644c2bcdf8b193d872fddb3b64677c202b8cacc1" translate="yes" xml:space="preserve">
          <source>As of Perl 5.26.0, this module has no effect. The internal Perl feature that was used to implement this module has been removed. In recent years, much work has been done on the Perl core to eliminate discrepancies in the treatment of upgraded versus downgraded strings. In addition, the &lt;a href=&quot;encoding&quot;&gt;encoding&lt;/a&gt; pragma, which caused many of the problems, is no longer supported. Thus, the warnings this module produced are no longer necessary.</source>
          <target state="translated">Perl 5.26.0부터이 모듈은 효과가 없습니다. 이 모듈을 구현하는 데 사용 된 내부 Perl 기능이 제거되었습니다. 최근에는 업그레이드 된 스트링과 다운 그레이드 된 스트링 처리의 불일치를 제거하기 위해 Perl 코어에 대한 많은 작업이 수행되었습니다. 또한 많은 문제를 일으킨 &lt;a href=&quot;encoding&quot;&gt;인코딩&lt;/a&gt; pragma가 더 이상 지원되지 않습니다. 따라서이 모듈이 생성 한 경고는 더 이상 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c1154c7dc017ae8cf6bc262f38694d16778c8f10" translate="yes" xml:space="preserve">
          <source>As of Perl 5.28, setting &lt;code&gt;$/&lt;/code&gt; to a reference of a non-positive integer throws a fatal error.</source>
          <target state="translated">Perl 5.28부터 &lt;code&gt;$/&lt;/code&gt; 를 양수가 아닌 정수의 참조로 설정 하면 치명적인 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="097112fced1ea44933320d3c2e627da3a57d8e96" translate="yes" xml:space="preserve">
          <source>As of Perl 5.28, these attributes are syntax errors. Since the attributes do not do anything, removing them from your code fixes the syntax error; and removing them will not influence the behaviour of your code.</source>
          <target state="translated">Perl 5.28부터 이러한 속성은 구문 오류입니다. 속성은 아무 작업도하지 않으므로 코드에서 속성을 제거하면 구문 오류가 수정됩니다. 제거해도 코드 동작에는 영향을주지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4698cfe65801c463a3e671c9cf65833d68ff49ae" translate="yes" xml:space="preserve">
          <source>As of Perl 5.28, this special-cased whitespace splitting works as expected in the scope of &lt;a href=&quot;feature#The-%27unicode_strings%27-feature&quot;&gt;&lt;code&gt;&quot;use feature 'unicode_strings&quot;&lt;/code&gt;&lt;/a&gt;. In previous versions, and outside the scope of that feature, it exhibits &lt;a href=&quot;perlunicode#The-%22Unicode-Bug%22&quot;&gt;&quot;The &quot;Unicode Bug&quot;&quot; in perlunicode&lt;/a&gt;: characters that are whitespace according to Unicode rules but not according to ASCII rules can be treated as part of fields rather than as field separators, depending on the string's internal encoding.</source>
          <target state="translated">Perl 5.28부터이 특수한 공백 분할은 &lt;a href=&quot;feature#The-%27unicode_strings%27-feature&quot;&gt; &lt;code&gt;&quot;use feature 'unicode_strings&quot;&lt;/code&gt; &lt;/a&gt; 범위에서 예상대로 작동합니다 . 이전 버전에서는 해당 기능의 범위를 벗어난 &lt;a href=&quot;perlunicode#The-%22Unicode-Bug%22&quot;&gt;&quot;The&quot;Unicode Bug &quot;&quot;가 perlunicode에 나타납니다&lt;/a&gt; . 유니 코드 규칙에 따라 공백이지만 ASCII 규칙에 따르지 않는 문자는 필드 구분 기호가 아닌 필드의 일부로 처리 될 수 있습니다. , 문자열의 내부 인코딩에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="df44a28f7cb4ce868d57f8dd07bcda2680ebf3e0" translate="yes" xml:space="preserve">
          <source>As of Perl 5.30, use of delimiters which are non-standalone graphemes is fatal, in order to move the language to be able to accept multi-character graphemes as delimiters.</source>
          <target state="translated">Perl 5.30부터는 다중 문자 자소를 구분자로 받아 들일 수 있도록 언어를 이동시키기 위해 비 독립적 인 자소 인 구분자를 사용하는 것은 치명적입니다.</target>
        </trans-unit>
        <trans-unit id="3dcb750cd92914748543d04c418a1857ae25be47" translate="yes" xml:space="preserve">
          <source>As of Perl 5.32, this message is no longer generated. Instead, see &lt;a href=&quot;#Non-octal-character-%27%25c%27-terminates-%5Co-early.-Resolved-as-%22%25s%22&quot;&gt;&quot;Non-octal character '%c' terminates \o early. Resolved as &quot;%s&quot;&quot;&lt;/a&gt;. (W misc, regexp) You wrote something like &lt;code&gt;\08&lt;/code&gt;, or &lt;code&gt;\179&lt;/code&gt; in a double-quotish string. All but the last digit is treated as a single character, specified in octal. The last digit is the next character in the string. To tell Perl that this is indeed what you want, you can use the &lt;code&gt;\o{ }&lt;/code&gt; syntax, or use exactly three digits to specify the octal for the character.</source>
          <target state="translated">Perl 5.32부터이 메시지는 더 이상 생성되지 않습니다. 대신 &lt;a href=&quot;#Non-octal-character-%27%25c%27-terminates-%5Co-early.-Resolved-as-%22%25s%22&quot;&gt;&quot;8 진수가 아닌 문자 '% c'가 \ o 일찍 종료됩니다.&quot;% s &quot;&quot;로 해결됨을&lt;/a&gt; 참조하십시오 . (W misc, regexp) 큰 따옴표 문자열에 &lt;code&gt;\08&lt;/code&gt; 또는 &lt;code&gt;\179&lt;/code&gt; 와 같은 것을 썼습니다 . 마지막 숫자를 제외한 모든 숫자는 8 진수로 지정된 단일 문자로 처리됩니다. 마지막 숫자는 문자열의 다음 문자입니다. Perl에게 이것이 실제로 원하는 것임을 알리려면 &lt;code&gt;\o{ }&lt;/code&gt; 구문을 사용하거나 정확히 3 자리 숫자를 사용하여 문자의 8 진수를 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6f3aa7e1697ed4bbe63edb4cde5bc634c7d4943e" translate="yes" xml:space="preserve">
          <source>As of Perl 5.6, you can represent filehandles with scalar variables which you treat as any other scalar.</source>
          <target state="translated">Perl 5.6부터는 다른 스칼라로 취급하는 스칼라 변수로 파일 핸들을 나타낼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="90e7536680dcd18ada661ef157609a74a6cebee3" translate="yes" xml:space="preserve">
          <source>As of Perl 5.8.0 after using this module you cannot use the implicit &lt;code&gt;$_&lt;/code&gt; or the special filehandle &lt;code&gt;_&lt;/code&gt; with stat() or lstat(), trying to do so leads into strange errors. The workaround is for &lt;code&gt;$_&lt;/code&gt; to be explicit</source>
          <target state="translated">이 모듈을 사용한 후 Perl 5.8.0부터 stat () 또는 lstat ()와 함께 내재적 &lt;code&gt;$_&lt;/code&gt; 또는 특수 파일 핸들 &lt;code&gt;_&lt;/code&gt; 을 사용할 수 없으므로 그렇게하면 이상한 오류가 발생합니다. 해결 방법은 &lt;code&gt;$_&lt;/code&gt; 명시 적입니다.</target>
        </trans-unit>
        <trans-unit id="115a406a7271cc4332af7b8bb93f168d625583f1" translate="yes" xml:space="preserve">
          <source>As of Perl 5.8.0, at least the following encodings are recognized. Note that unless otherwise specified, they are all case insensitive (via alias) and all occurrence of spaces are replaced with '-'. In other words, &quot;ISO 8859 1&quot; and &quot;iso-8859-1&quot; are identical.</source>
          <target state="translated">Perl 5.8.0부터 최소한 다음 인코딩이 인식됩니다. 달리 지정하지 않는 한 모두 대소 문자를 구분하지 않으며 (별칭을 통해) 모든 공백은 '-'로 대체됩니다. 즉, &quot;ISO 8859 1&quot;과 &quot;iso-8859-1&quot;은 동일합니다.</target>
        </trans-unit>
        <trans-unit id="5fd0a9a99a09c2a713ff60adbdf886450b68308c" translate="yes" xml:space="preserve">
          <source>As of Perl 5.8.0, the &quot;Full&quot; case-folding of</source>
          <target state="translated">Perl 5.8.0 기준으로 &quot;Full&quot;case-folding</target>
        </trans-unit>
        <trans-unit id="444326d8d5a5982dc22e2a52147d982ac07eb8e8" translate="yes" xml:space="preserve">
          <source>As of Perl 5.8.0, you can use &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; with multiple arguments. Just like the list forms of &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system()&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec()&lt;/a&gt;&lt;/code&gt;, no shell escapes happen.</source>
          <target state="translated">Perl 5.8.0부터 여러 인수와 함께 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; 을 사용할 수 있습니다 . &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system()&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec()&lt;/a&gt;&lt;/code&gt; 의 목록 형식과 마찬가지로 쉘 이스케이프가 발생하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="df8794a0813798e6a0cf5a13a0dc7223a79a0992" translate="yes" xml:space="preserve">
          <source>As of Perl 5.8.0, you can use &lt;code&gt;open()&lt;/code&gt; with multiple arguments. Just like the list forms of &lt;code&gt;system()&lt;/code&gt; and &lt;code&gt;exec()&lt;/code&gt;, no shell escapes happen.</source>
          <target state="translated">Perl 5.8.0부터는 여러 인수와 함께 &lt;code&gt;open()&lt;/code&gt; 을 사용할 수 있습니다 . &lt;code&gt;system()&lt;/code&gt; 및 &lt;code&gt;exec()&lt;/code&gt; 의 목록 형식과 마찬가지로 쉘 이스케이프가 발생하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a68a3c591a49e26bfd6e1872f3f7a653d522ef71" translate="yes" xml:space="preserve">
          <source>As of Perl 5.8.1 the dynamic loading of libraries (DynaLoader, XSLoader) also seems to have become broken in in SunOS 4.x. Therefore the default is to build Perl statically.</source>
          <target state="translated">Perl 5.8.1부터 라이브러리의 동적 로딩 (DynaLoader, XSLoader)도 SunOS 4.x에서 중단 된 것으로 보입니다. 따라서 기본값은 Perl을 정적으로 빌드하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="ef5cb6c37e267f59227533f0250c84c8718b7076" translate="yes" xml:space="preserve">
          <source>As of Perl 5.8.1, &lt;a href=&quot;utf8&quot;&gt;utf8&lt;/a&gt; also has the &lt;code&gt;utf8::is_utf8&lt;/code&gt; function.</source>
          <target state="translated">Perl 5.8.1부터 &lt;a href=&quot;utf8&quot;&gt;utf8&lt;/a&gt; 에는 &lt;code&gt;utf8::is_utf8&lt;/code&gt; 함수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="ab205322181f94cdf41d5eaaf572850bb63def33" translate="yes" xml:space="preserve">
          <source>As of Perl 5.9.5 there is a new interface for plugging and using regular expression engines other than the default one.</source>
          <target state="translated">Perl 5.9.5부터 기본 엔진 이외의 정규식 엔진을 연결하고 사용하기위한 새로운 인터페이스가 있습니다.</target>
        </trans-unit>
        <trans-unit id="02c3c3ae5c3a1698c2091dbb44ff1c48ff7a71dd" translate="yes" xml:space="preserve">
          <source>As of Perl Symbian port version 0.4.1 any part of Perl's standard regression test suite has not been run on a real Symbian device using the ported Perl, so innumerable bugs may lie in wait. Therefore there is absolutely no warranty.</source>
          <target state="translated">Perl Symbian 포트 버전 0.4.1부터 Perl의 표준 회귀 테스트 스위트의 일부는 이식 된 Perl을 사용하여 실제 Symbian 장치에서 실행되지 않았으므로 수많은 버그가 대기 중일 수 있습니다. 따라서 보증이 전혀 없습니다.</target>
        </trans-unit>
        <trans-unit id="470b823d90414a4ffaec0c54908966f5bb0b6779" translate="yes" xml:space="preserve">
          <source>As of Perl v5.16.0, it is implemented by the &lt;a href=&quot;arybase&quot;&gt;arybase&lt;/a&gt; module.</source>
          <target state="translated">Perl v5.16.0 &lt;a href=&quot;arybase&quot;&gt;부터는 arybase&lt;/a&gt; 모듈로 구현됩니다 .</target>
        </trans-unit>
        <trans-unit id="2a7301a461e47b0be61be125749323ecdfc5a92a" translate="yes" xml:space="preserve">
          <source>As of Perl v5.16.0, it is implemented by the &lt;a href=&quot;arybase&quot;&gt;arybase&lt;/a&gt; module. See &lt;a href=&quot;arybase&quot;&gt;arybase&lt;/a&gt; for more details on its behaviour.</source>
          <target state="translated">Perl v5.16.0 &lt;a href=&quot;arybase&quot;&gt;부터는 arybase&lt;/a&gt; 모듈로 구현됩니다 . 동작에 대한 자세한 내용 은 &lt;a href=&quot;arybase&quot;&gt;arybase&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="0cf84017310ef88efe853e952dd2c6c52ce61386" translate="yes" xml:space="preserve">
          <source>As of Perl v5.30.0, or under &lt;code&gt;use v5.16&lt;/code&gt;, or &lt;code&gt;no feature &quot;array_base&quot;&lt;/code&gt;, &lt;code&gt;$[&lt;/code&gt; no longer has any effect, and always contains 0. Assigning 0 to it is permitted, but any other value will produce an error.</source>
          <target state="translated">Perl v5.30.0부터 또는 &lt;code&gt;use v5.16&lt;/code&gt; 거나 &lt;code&gt;no feature &quot;array_base&quot;&lt;/code&gt; 경우 &lt;code&gt;$[&lt;/code&gt; 는 더 이상 효과가 없으며 항상 0을 포함합니다. 0을 할당 할 수 있지만 다른 값은 오류를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="9f7c19e511eae81348e03d06d3194e0d82d15184" translate="yes" xml:space="preserve">
          <source>As of R2.5 of USS for OS/390 and Version 2.3 of VM/ESA these Unix sub-systems do not support the &lt;code&gt;#!&lt;/code&gt; shebang trick for script invocation. Hence, on OS/390 and VM/ESA Perl scripts can be executed with a header similar to the following simple script:</source>
          <target state="translated">OS / 390 용 USS R2.5 및 VM / ESA 버전 2.3에서이 Unix 하위 시스템은 &lt;code&gt;#!&lt;/code&gt; 스크립트 호출을위한 shebang 트릭. 따라서 OS / 390 및 VM / ESA에서 Perl 스크립트는 다음 간단한 스크립트와 유사한 헤더를 사용하여 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4e29546f04e5cfe2122e46676161bb58e8a9f171" translate="yes" xml:space="preserve">
          <source>As of Unicode 6.0, this is always empty.</source>
          <target state="translated">유니 코드 6.0부터는 항상 비어 있습니다.</target>
        </trans-unit>
        <trans-unit id="6be62dadd6bbd6b8a9fe9bd5f460bd2ea3dfc014" translate="yes" xml:space="preserve">
          <source>As of VERSION 1.18 all IO::Socket objects have autoflush turned on by default. This was not the case with earlier releases.</source>
          <target state="translated">VERSION 1.18부터 모든 IO :: Socket 객체는 기본적으로 자동 플러시 기능을 사용합니다. 이전 릴리스에서는 그렇지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="9b18b6d1424b74e3d0360d9f0334585a766708d3" translate="yes" xml:space="preserve">
          <source>As of db-4.2.x it is no longer needed to do this by hand. Sleepycat has changed the configuration process to add +z on HP-UX automatically.</source>
          <target state="translated">db-4.2.x부터는 더 이상 수동으로이를 수행 할 필요가 없습니다. Sleepycat은 HP-UX에서 + z를 자동으로 추가하도록 구성 프로세스를 변경했습니다.</target>
        </trans-unit>
        <trans-unit id="d75d887c21a8a54a73e586867619f60f35cac751" translate="yes" xml:space="preserve">
          <source>As of libcrypt 1.3 (March 2016), you will need to install the libcrypt-devel package for Configure to detect crypt().</source>
          <target state="translated">libcrypt 1.3 (2016 년 3 월)부터 crypt ()를 감지하려면 Configure 용 libcrypt-devel 패키지를 설치해야합니다.</target>
        </trans-unit>
        <trans-unit id="ddb5b154eee158ecabd0abbac4ff1eab5e92e45f" translate="yes" xml:space="preserve">
          <source>As of perl 5.14 it is possible to hook into the compile-time lexical scope mechanism using &lt;code&gt;Perl_blockhook_register&lt;/code&gt; . This is used like this:</source>
          <target state="translated">perl 5.14부터는 &lt;code&gt;Perl_blockhook_register&lt;/code&gt; 를 사용하여 컴파일 타임 어휘 범위 메커니즘에 연결할 수 있습니다. 이것은 다음과 같이 사용됩니다 :</target>
        </trans-unit>
        <trans-unit id="ad95286c36cd410295b8a2ce1cb7201a227c4aba" translate="yes" xml:space="preserve">
          <source>As of perl 5.14 it is possible to hook into the compile-time lexical scope mechanism using &lt;code&gt;Perl_blockhook_register&lt;/code&gt;. This is used like this:</source>
          <target state="translated">Perl 5.14부터는 &lt;code&gt;Perl_blockhook_register&lt;/code&gt; 를 사용하여 컴파일 타임 어휘 범위 메커니즘에 연결할 수 있습니다. 이것은 다음과 같이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="11e27b1acb1512cd132ffd47cefd52584149d78c" translate="yes" xml:space="preserve">
          <source>As of perl 5.25 this function is used only for debugging purposes, and the number of used hash buckets is not in any way cached, thus this function can be costly to execute as it must iterate over all the buckets in the hash.</source>
          <target state="translated">perl 5.25부터이 함수는 디버깅 목적으로 만 사용되며 사용 된 해시 버킷의 수는 어떤 식 으로든 캐시되지 않으므로이 함수는 해시의 모든 버킷을 반복해야하므로 실행하는 데 많은 비용이들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="283446be77b5c5650a7aade52dfb5d3e56c4e299" translate="yes" xml:space="preserve">
          <source>As of perl 5.9.5 're' debug contains a number of utility functions that may be optionally exported into the caller's namespace. They are listed below.</source>
          <target state="translated">perl 5.9.5부터 're'디버그에는 호출자의 네임 스페이스로 선택적으로 내보낼 수있는 많은 유틸리티 함수가 포함되어 있습니다. 아래에 나열되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="e452fc188847c39d477f7724ca763c55646692fe" translate="yes" xml:space="preserve">
          <source>As of perl 5.9.5/Win32 0.27, these functions have been moved into the Win32 module. Win32CORE provides stubs for each of the former CORE Win32:: functions that internally just load the Win32 module and call it's version, and Win32CORE is statically linked to perl for both cygwin and regular win32 builds. This will permit these functions to be updated in the CPAN Win32 module independently of updating perl.</source>
          <target state="translated">Perl 5.9.5 / Win32 0.27부터 이러한 기능은 Win32 모듈로 이동되었습니다. Win32CORE는 내부적으로 Win32 모듈을로드하고 해당 버전을 호출하는 이전 CORE Win32 :: 함수 각각에 대한 스텁을 제공하며, Win32CORE는 cygwin 및 일반 win32 빌드 모두에 대해 perl에 정적으로 연결됩니다. 이렇게하면 perl을 업데이트하는 것과 관계없이 CPAN Win32 모듈에서 이러한 함수를 업데이트 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5916c6705e19aa4737c1eaecb1fdda26e7395e63" translate="yes" xml:space="preserve">
          <source>As of perl5.6, open() autovivifies file and directory handles as references if you pass it an uninitialized scalar variable. You can then pass these references just like any other scalar, and use them in the place of named handles.</source>
          <target state="translated">perl5.6에서, open ()은 파일 및 디렉토리 핸들을 초기화되지 않은 스칼라 변수에 전달하면 참조로 자동 활성화합니다. 그런 다음 다른 스칼라와 마찬가지로 이러한 참조를 전달하고 명명 된 핸들 대신 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0d06e02fdc69f862d76b045e6be72fc487c78e0b" translate="yes" xml:space="preserve">
          <source>As of perl5.7.2 all tests pass under:</source>
          <target state="translated">perl5.7.2부터 모든 테스트는 다음을 통과합니다.</target>
        </trans-unit>
        <trans-unit id="e7ebc726132cf88aa72c90598602d1b0ee48a664" translate="yes" xml:space="preserve">
          <source>As of perl5.8.1 there is at least one test still failing.</source>
          <target state="translated">perl5.8.1부터는 여전히 하나 이상의 테스트가 실패했습니다.</target>
        </trans-unit>
        <trans-unit id="1b82fd373dbd0883f99d276e806ca9d5f0a6e144" translate="yes" xml:space="preserve">
          <source>As of release 5 of Perl, assignment to &lt;code&gt;$[&lt;/code&gt; is treated as a compiler directive, and cannot influence the behavior of any other file. (That's why you can only assign compile-time constants to it.) Its use is highly discouraged.</source>
          <target state="translated">Perl의 릴리스 5부터 &lt;code&gt;$[&lt;/code&gt; 에 대한 지정은 컴파일러 지시문으로 취급되며 다른 파일의 동작에 영향을 줄 수 없습니다. (따라서 컴파일 타임 상수 만 할당 할 수 있습니다.) 사용을 권장하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1e2bbc98f0506e501d121cbf3463e0bb77e718b4" translate="yes" xml:space="preserve">
          <source>As of release 5.003_01 perl is linked to multithreaded C RTL DLL. If perl itself is not compiled multithread-enabled, so will not be perl's malloc(). However, extensions may use multiple thread on their own risk.</source>
          <target state="translated">릴리스 5.003_01부터 perl은 멀티 스레드 C RTL DLL에 연결됩니다. perl 자체가 멀티 스레드 가능 컴파일되지 않은 경우 perl의 malloc ()이되지 않습니다. 그러나 확장은 자체 위험에 따라 여러 스레드를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5dbdb753a9581b45c8e16e8caa7ad1fc9cd73184" translate="yes" xml:space="preserve">
          <source>As of right now, this returns 2 if the path is absolute with a volume, 1 if it's absolute with no volume, 0 otherwise.</source>
          <target state="translated">현재 경로가 볼륨에 절대적이면 2를 반환하고, 볼륨이 없으면 절대에 1을, 그렇지 않으면 0을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="cedde28f0889c00006609cd1f4e0ab992b6b315c" translate="yes" xml:space="preserve">
          <source>As of the date of this document's last update, the following systems contain PA-RISC 2.0 chips:</source>
          <target state="translated">이 문서의 마지막 업데이트 날짜부터 다음 시스템에는 PA-RISC 2.0 칩이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="361f300829fa013b44d60226e2c65866392ff21f" translate="yes" xml:space="preserve">
          <source>As of the date of this document, Perl is fully 64-bit compliant on HP-UX 11.00 and up for both cc- and gcc builds. If you are about to build a 64-bit perl with GNU gcc, please read the gcc section carefully.</source>
          <target state="translated">이 문서가 작성된 시점에서 Perl은 HP-UX 11.00에서 완전히 64 비트를 준수하며 cc 및 gcc 빌드 모두에 해당합니다. GNU gcc로 64 비트 perl을 만들려고한다면 gcc 섹션을주의 깊게 읽으십시오.</target>
        </trans-unit>
        <trans-unit id="6087654ae9665e2974920201f81ba084c4838564" translate="yes" xml:space="preserve">
          <source>As of the time this document was last revised, the following Perl functions were implemented in the VMS port of Perl (functions marked with * are discussed in more detail below):</source>
          <target state="translated">이 문서가 마지막으로 개정 된 시점에서 다음 Perl 기능은 Perl의 VMS 포트에서 구현되었습니다 (*로 표시된 기능은 아래에서 자세히 설명합니다).</target>
        </trans-unit>
        <trans-unit id="4d788164927e274de517225973608d97db84fe9f" translate="yes" xml:space="preserve">
          <source>As of this writing, any encoding whose class belongs to Encode::XS and Encode::Unicode works. The Encode module has a &lt;code&gt;perlio_ok&lt;/code&gt; method which you can use before applying PerlIO encoding to the filehandle. Here is an example:</source>
          <target state="translated">이 글을 쓰는 시점에서 클래스가 Encode :: XS 및 Encode :: Unicode에 속하는 모든 인코딩이 작동합니다. Encode 모듈에는 PerlIO 인코딩을 파일 핸들에 적용하기 전에 사용할 수 있는 &lt;code&gt;perlio_ok&lt;/code&gt; 메서드가 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2f434753b82171852395258695f5260796bd3e54" translate="yes" xml:space="preserve">
          <source>As of v5.14, Perl distinguishes three subclasses of UTF‑8 warnings.</source>
          <target state="translated">v5.14부터 Perl은 UTF-8 경고의 세 가지 서브 클래스를 구별합니다.</target>
        </trans-unit>
        <trans-unit id="3687eac7ed0d3e9a3819b6d8b59ffbbce6f96ce7" translate="yes" xml:space="preserve">
          <source>As of v5.18.0, both keys and values stored in &lt;code&gt;%ENV&lt;/code&gt; are stringified.</source>
          <target state="translated">v5.18.0부터는 &lt;code&gt;%ENV&lt;/code&gt; 저장된 키와 값이 모두 문자열 화되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="068ae70c04574cc37cc34db842b7ac8d0c145fb6" translate="yes" xml:space="preserve">
          <source>As of version 1.01 of the AutoSplit module it is possible to have multiple packages within a single file. Both of the following cases are supported:</source>
          <target state="translated">AutoSplit 모듈 버전 1.01부터 단일 파일 내에 여러 패키지가있을 수 있습니다. 다음 경우 모두 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="4d09237d697a620472d98ca9564ba252e7440a3a" translate="yes" xml:space="preserve">
          <source>As of version 1.02 (provided with perl 5.12) the object provides &lt;code&gt;&quot;-X&quot;&lt;/code&gt; overloading, so you can call filetest operators (&lt;code&gt;-f&lt;/code&gt; , &lt;code&gt;-x&lt;/code&gt; , and so on) on it. It also provides a &lt;code&gt;-&amp;gt;cando&lt;/code&gt; method, called like</source>
          <target state="translated">버전 1.02 (perl 5.12와 함께 제공)부터 객체는 &lt;code&gt;&quot;-X&quot;&lt;/code&gt; 오버로딩을 제공 하므로 파일 테스트 연산자 ( &lt;code&gt;-f&lt;/code&gt; , &lt;code&gt;-x&lt;/code&gt; 등)를 호출 할 수 있습니다 . 또한 &lt;code&gt;-&amp;gt;cando&lt;/code&gt; 메소드를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="3f4a112eabf93bbafc4bcc9a1025d0ef06b216ad" translate="yes" xml:space="preserve">
          <source>As of version 1.02 (provided with perl 5.12) the object provides &lt;code&gt;&quot;-X&quot;&lt;/code&gt; overloading, so you can call filetest operators (&lt;code&gt;-f&lt;/code&gt;, &lt;code&gt;-x&lt;/code&gt;, and so on) on it. It also provides a &lt;code&gt;-&amp;gt;cando&lt;/code&gt; method, called like</source>
          <target state="translated">버전 1.02 (perl 5.12와 함께 제공)부터 객체는 &lt;code&gt;&quot;-X&quot;&lt;/code&gt; 오버로딩을 제공 하므로 파일 테스트 연산자 ( &lt;code&gt;-f&lt;/code&gt; , &lt;code&gt;-x&lt;/code&gt; 등)를 호출 할 수 있습니다 . 또한 다음 과 같이 호출 되는 &lt;code&gt;-&amp;gt;cando&lt;/code&gt; 메소드를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="39c91a8aec6b3b91e09f6a8bd53c1515a32cc61b" translate="yes" xml:space="preserve">
          <source>As of version 1.04 (Perl 5.10), strict verifies that it is used as &quot;strict&quot; to avoid the dreaded Strict trap on case insensitive file systems.</source>
          <target state="translated">버전 1.04 (Perl 5.10)부터는 대소 문자를 구분하지 않는 파일 시스템에서 두려운 엄격한 트랩을 피하기 위해 &quot;strict&quot;로 사용되는지 엄격하게 확인합니다.</target>
        </trans-unit>
        <trans-unit id="5750d09d680a68ca093b8cb502caecf523fc46de" translate="yes" xml:space="preserve">
          <source>As of version 1.32 of this module, constants can be defined in packages other than the caller, by including the package name in the name of the constant:</source>
          <target state="translated">이 모듈의 버전 1.32부터 상수 이름에 패키지 이름을 포함시켜 호출자 이외의 패키지에서 상수를 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a9966baeb16dc71d9782450ad1960be303770497" translate="yes" xml:space="preserve">
          <source>As of version 1.47 the following additions were made to the install interface. Note that the new argument style and use of the %result hash is recommended.</source>
          <target state="translated">버전 1.47부터 설치 인터페이스에 다음이 추가되었습니다. 새로운 인수 스타일과 % result 해시를 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="e47319fd89f8639b4c6dc3d1dee645f4e3217716" translate="yes" xml:space="preserve">
          <source>As of version 2.12, &lt;code&gt;Encode&lt;/code&gt; supports coderef values for &lt;code&gt;CHECK&lt;/code&gt; ; see below.</source>
          <target state="translated">버전 2.12부터 &lt;code&gt;Encode&lt;/code&gt; 는 &lt;code&gt;CHECK&lt;/code&gt; 에 대한 코드 참조 값을 지원합니다 . 아래를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="ffc6a36f7c22fafbcd2974930b9d682b59ed0fd0" translate="yes" xml:space="preserve">
          <source>As of version 2.12, &lt;code&gt;Encode&lt;/code&gt; supports coderef values for &lt;code&gt;CHECK&lt;/code&gt;; see below.</source>
          <target state="translated">버전 2.12부터 &lt;code&gt;Encode&lt;/code&gt; 는 &lt;code&gt;CHECK&lt;/code&gt; 에 대한 coderef 값을 지원합니다 . 아래를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="feaefe7da5a3f173789e3bc38d1cc052b48f0697" translate="yes" xml:space="preserve">
          <source>As of version 2.32 Getopt::Long provides auto-help, a quick and easy way to add the options --help and -? to your program, and handle them.</source>
          <target state="translated">버전 2.32 현재 Getopt :: Long은 자동 도움말을 제공하여 옵션 --help 및-?를 빠르고 쉽게 추가 할 수 있습니다. 당신의 프로그램에 그들을 처리합니다.</target>
        </trans-unit>
        <trans-unit id="4961ac95a03fe72cd95305ebd10cd56767e6cd2e" translate="yes" xml:space="preserve">
          <source>As of version 5.00305, OS/2 perl binary distribution comes split into 11 components. Unfortunately, to enable configurable binary installation, the file paths in the zip files are not absolute, but relative to some directory.</source>
          <target state="translated">버전 5.00305부터 OS / 2 perl 이진 배포는 11 개의 구성 요소로 나뉩니다. 불행하게도, 구성 가능한 바이너리 설치를 가능하게하기 위해, zip 파일의 파일 경로는 절대적인 것이 아니라 일부 디렉토리에 상대적입니다.</target>
        </trans-unit>
        <trans-unit id="0a03b6b4ddea7ad90c28bf2de5b6b3532c441bd5" translate="yes" xml:space="preserve">
          <source>As of version 5.12.0, perl has stopped using the time implementation of the operating system it's running on. Instead, it has its own implementation of those routines with a safe range of at least +/- 2**52 (about 142 million years)</source>
          <target state="translated">버전 5.12.0부터 perl은 실행중인 운영 체제의 시간 구현 사용을 중지했습니다. 대신 최소 +/- 2 ** 52 (약 1 억 4,200 만 년)의 안전 범위로 이러한 루틴을 자체적으로 구현합니다.</target>
        </trans-unit>
        <trans-unit id="c5ef8d96f6d787f0f3cc3fb69a33144b75f432e6" translate="yes" xml:space="preserve">
          <source>As of version 5.12.0, perl has stopped using the underlying time library of the operating system it's running on and has its own implementation of those routines with a safe range of at least +/ 2**52 (about 142 million years).</source>
          <target state="translated">버전 5.12.0부터 perl은 운영 체제의 기본 시간 라이브러리 사용을 중단했으며 안전 범위가 최소 + / 2 ** 52 (약 1 억 2 천 6 백만 년) 인 루틴을 자체적으로 구현했습니다.</target>
        </trans-unit>
        <trans-unit id="ede48005eab24777f4cf1c1c51404cc14a546bbe" translate="yes" xml:space="preserve">
          <source>As of writing (2010-09) only the</source>
          <target state="translated">현재 (2010-09)</target>
        </trans-unit>
        <trans-unit id="9bba94e9dfeb863cebb5f1b8b07f6bae30ef1d7d" translate="yes" xml:space="preserve">
          <source>As opposed to &lt;a href=&quot;http://man.he.net/man3/atoi&quot;&gt;atoi(3)&lt;/a&gt; or &lt;a href=&quot;http://man.he.net/man3/strtol&quot;&gt;strtol(3)&lt;/a&gt;, &lt;code&gt;grok_atoUV&lt;/code&gt; does NOT allow optional leading whitespace, nor negative inputs. If such features are required, the calling code needs to explicitly implement those.</source>
          <target state="translated">반대로 &lt;a href=&quot;http://man.he.net/man3/atoi&quot;&gt;atoi 함수 (3)&lt;/a&gt; 또는 &lt;a href=&quot;http://man.he.net/man3/strtol&quot;&gt;strtol 함수 (3)&lt;/a&gt; , &lt;code&gt;grok_atoUV&lt;/code&gt; 는 옵션 선두 공백,도 부정적인 입력을 허용하지 않습니다. 이러한 기능이 필요한 경우 호출 코드에서이를 명시 적으로 구현해야합니다.</target>
        </trans-unit>
        <trans-unit id="53d68ae04ea90208ac09617d93481673c81dae0c" translate="yes" xml:space="preserve">
          <source>As per &lt;a href=&quot;functions/readline&quot;&gt;readline&lt;/a&gt;, in scalar context it should return the next line, or &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; for no more data. In list context it should return all remaining lines, or an empty list for no more data. The strings returned should include the input record separator &lt;code&gt;$/&lt;/code&gt; (see &lt;a href=&quot;perlvar&quot;&gt;perlvar&lt;/a&gt;), unless it is &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; (which means &quot;slurp&quot; mode).</source>
          <target state="translated">&lt;a href=&quot;functions/readline&quot;&gt;readline에&lt;/a&gt; 따라 스칼라 컨텍스트에서 다음 행을 반환하거나 더 이상 데이터가 없으면 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 해야합니다. 목록 컨텍스트에서 나머지 모든 행을 반환하거나 더 이상 데이터가 없으면 빈 목록을 반환해야합니다. 반환 된 문자열 은 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 가 아닌 경우 ( &quot;slurp&quot;모드를 의미하는 경우) 입력 레코드 구분 기호 &lt;code&gt;$/&lt;/code&gt; ( &lt;a href=&quot;perlvar&quot;&gt;perlvar&lt;/a&gt; 참조 )를 포함해야합니다 .</target>
        </trans-unit>
        <trans-unit id="008a0000ee5b61a83c14df2cf7cee7f4e080298a" translate="yes" xml:space="preserve">
          <source>As per &lt;a href=&quot;perlfunc#readline&quot;&gt;&lt;code&gt;readline&lt;/code&gt;&lt;/a&gt;, in scalar context it should return the next line, or &lt;code&gt;undef&lt;/code&gt; for no more data. In list context it should return all remaining lines, or an empty list for no more data. The strings returned should include the input record separator &lt;code&gt;$/&lt;/code&gt; (see &lt;a href=&quot;perlvar&quot;&gt;perlvar&lt;/a&gt;), unless it is &lt;code&gt;undef&lt;/code&gt; (which means &quot;slurp&quot; mode).</source>
          <target state="translated">&lt;a href=&quot;perlfunc#readline&quot;&gt; &lt;code&gt;readline&lt;/code&gt; 에&lt;/a&gt; 따라 스칼라 컨텍스트에서 다음 줄을 반환하거나 더 이상 데이터가없는 경우 &lt;code&gt;undef&lt;/code&gt; 를 반환해야 합니다. 목록 컨텍스트에서 나머지 모든 줄을 반환하거나 더 이상 데이터가없는 경우 빈 목록을 반환해야합니다. 반환 된 문자열 은 &lt;code&gt;undef&lt;/code&gt; ( &quot;slurp&quot;모드를 의미 )가 아닌 경우 입력 레코드 구분 기호 &lt;code&gt;$/&lt;/code&gt; ( &lt;a href=&quot;perlvar&quot;&gt;perlvar&lt;/a&gt; 참조 )를 포함해야합니다 .</target>
        </trans-unit>
        <trans-unit id="35db6e6083bf8853a0d7a773700bfc53f4f3833e" translate="yes" xml:space="preserve">
          <source>As per get(), but returns a tied filehandle. Reading from this filehandle returns the requested message. The filehandle will return EOF at the end of the message and should not be reused.</source>
          <target state="translated">get ()에 따라 묶인 파일 핸들을 반환합니다. 이 파일 핸들을 읽으면 요청 된 메시지가 리턴됩니다. 파일 핸들은 메시지 끝에서 EOF를 리턴하며 재사용해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="f8d3cabb86865ec30b2f81b742c043bb4dfa0006" translate="yes" xml:space="preserve">
          <source>As perl does not use it, it is not well tested.</source>
          <target state="translated">펄은 그것을 사용하지 않기 때문에 잘 테스트되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="04f2eace94f5ec9fb309f7ef275b1f53f5b18652" translate="yes" xml:space="preserve">
          <source>As pragmata are implemented as modules, like any other module, &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; myint;&lt;/code&gt; becomes</source>
          <target state="translated">pragmata가 다른 모듈과 마찬가지로 모듈로 구현되므로 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; myint;&lt;/code&gt; &lt;a href=&quot;functions/use&quot;&gt;사용&lt;/a&gt; 하십시오. 된다</target>
        </trans-unit>
        <trans-unit id="95ffc5a9c7d9d21832644aa0005e8ab6e5d3fda8" translate="yes" xml:space="preserve">
          <source>As pragmata are implemented as modules, like any other module, &lt;code&gt;use myint;&lt;/code&gt; becomes</source>
          <target state="translated">pragmata는 다른 모듈과 마찬가지로 모듈로 구현되므로 &lt;code&gt;use myint;&lt;/code&gt; 된다</target>
        </trans-unit>
        <trans-unit id="6ff69505257da499d009f94993a8c36d403bc517" translate="yes" xml:space="preserve">
          <source>As previously mentioned, the &quot;switch&quot; feature is considered highly experimental; it is subject to change with little notice. In particular, &lt;code&gt;when&lt;/code&gt; has tricky behaviours that are expected to change to become less tricky in the future. Do not rely upon its current (mis)implementation. Before Perl 5.18, &lt;code&gt;given&lt;/code&gt; also had tricky behaviours that you should still beware of if your code must run on older versions of Perl.</source>
          <target state="translated">앞에서 언급했듯이 &quot;스위치&quot;기능은 매우 실험적인 것으로 간주됩니다. 별다른 통지없이 변경 될 수 있습니다. 특히 앞으로 까다로워 질 까다로운 행동이 &lt;code&gt;when&lt;/code&gt; . 현재 (오용) 구현에 의존하지 마십시오. 펄 5.18 전에 &lt;code&gt;given&lt;/code&gt; 또한 당신은 여전히 당신의 코드는 펄의 이전 버전에서 실행해야하는 경우를 조심해야한다는 까다로운 행동을했다.</target>
        </trans-unit>
        <trans-unit id="d4ddd43c6028587c10020a05414bb6d70c1790ee" translate="yes" xml:space="preserve">
          <source>As previously noted, individual entries (as opposed to the whole hash) are settable. Perl only cares about Boolean true here, although the values used by</source>
          <target state="translated">앞에서 언급했듯이 개별 항목 (전체 해시와 반대)을 설정할 수 있습니다. Perl은 여기에서 사용되는 값에도 불구하고 Boolean true에만 관심이 있습니다.</target>
        </trans-unit>
        <trans-unit id="40863db850a5e2446412cc32d982d2e85c0c2a70" translate="yes" xml:space="preserve">
          <source>As setup, consider this (admittedly rather contrived) example of a tie; all it does is use a file to keep a log of the values assigned to a scalar.</source>
          <target state="translated">셋업으로서, 타이의이 (구체적으로 결정된) 예를 고려하십시오. 파일을 사용하여 스칼라에 지정된 값의 로그를 유지하기 만하면됩니다.</target>
        </trans-unit>
        <trans-unit id="d5e7901b05cd99e70f1eb4d22405e5ec5c43c73a" translate="yes" xml:space="preserve">
          <source>As shipped, the only command-line history supplied is a simplistic one that checks for leading exclamation points. However, if you install the Term::ReadKey and Term::ReadLine modules from CPAN (such as Term::ReadLine::Gnu, Term::ReadLine::Perl, ...) you will have full editing capabilities much like those GNU</source>
          <target state="translated">제공되는 유일한 명령 줄 기록은 단순한 느낌표를 확인하는 간단한 것입니다. 그러나 CPAN에서 Term :: ReadKey 및 Term :: ReadLine 모듈 (Term :: ReadLine :: Gnu, Term :: ReadLine :: Perl, ...)을 설치하면 다음과 같은 전체 편집 기능을 사용할 수 있습니다. 암소 비슷한 일종의 영양</target>
        </trans-unit>
        <trans-unit id="3c7b29c9acaba84b5dfa9d94a08362e636c880e4" translate="yes" xml:space="preserve">
          <source>As shown above, Perl creates the backup file whether or not any output is actually changed. So this is just a fancy way to copy files:</source>
          <target state="translated">위에 표시된 것처럼 Perl은 출력이 실제로 변경되는지 여부에 관계없이 백업 파일을 작성합니다. 따라서 이것은 파일을 복사하는 멋진 방법입니다.</target>
        </trans-unit>
        <trans-unit id="cf827d39576175b49dc1a1c39fee2ddfa72908f4" translate="yes" xml:space="preserve">
          <source>As shown in this example, &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt; EXPR&lt;/code&gt; is exempt from the &quot;looks like a function&quot; rule. A pair of parentheses following it does not (necessarily) delimit its argument. &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto(&quot;NE&quot;).&quot;XT&quot;&lt;/a&gt;&lt;/code&gt; is equivalent to &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt; NEXT&lt;/code&gt; . Also, unlike most named operators, this has the same precedence as assignment.</source>
          <target state="translated">이 예제에서 볼 수 있듯이 &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt; EXPR&lt;/code&gt; 은 &quot;함수 모양&quot;규칙에서 제외됩니다. 뒤에 오는 한 쌍의 괄호는 인수를 (필요하게) 구분하지 않습니다. &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto(&quot;NE&quot;).&quot;XT&quot;&lt;/a&gt;&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt; NEXT&lt;/code&gt; 와 같습니다 . 또한 대부분의 명명 된 연산자와 달리 할당과 동일한 우선 순위를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="a246c967f8c44d960de455229b31b368ecdb7f4c" translate="yes" xml:space="preserve">
          <source>As shown in this example, &lt;code&gt;&lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt; EXPR&lt;/code&gt; is exempt from the &quot;looks like a function&quot; rule. A pair of parentheses following it does not (necessarily) delimit its argument. &lt;code&gt;&lt;a href=&quot;goto&quot;&gt;goto(&quot;NE&quot;).&quot;XT&quot;&lt;/a&gt;&lt;/code&gt; is equivalent to &lt;code&gt;&lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt; NEXT&lt;/code&gt; . Also, unlike most named operators, this has the same precedence as assignment.</source>
          <target state="translated">이 예제에서 볼 수 있듯이 &lt;code&gt;&lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt; EXPR&lt;/code&gt; 은 &quot;함수 모양&quot;규칙에서 제외됩니다. 뒤에 오는 한 쌍의 괄호는 인수를 (필요하게) 구분하지 않습니다. &lt;code&gt;&lt;a href=&quot;goto&quot;&gt;goto(&quot;NE&quot;).&quot;XT&quot;&lt;/a&gt;&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt; NEXT&lt;/code&gt; 와 같습니다 . 또한 대부분의 명명 된 연산자와 달리 할당과 동일한 우선 순위를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="69217332278a487735b9f765568e5e6b60cb13f1" translate="yes" xml:space="preserve">
          <source>As shown in this example, &lt;code&gt;goto EXPR&lt;/code&gt; is exempt from the &quot;looks like a function&quot; rule. A pair of parentheses following it does not (necessarily) delimit its argument. &lt;code&gt;goto(&quot;NE&quot;).&quot;XT&quot;&lt;/code&gt; is equivalent to &lt;code&gt;goto NEXT&lt;/code&gt;. Also, unlike most named operators, this has the same precedence as assignment.</source>
          <target state="translated">이 예에서 볼 수 있듯이 &lt;code&gt;goto EXPR&lt;/code&gt; 은 &quot;looks like a function&quot;규칙에서 제외됩니다. 뒤에 오는 괄호 쌍은 인수를 (필수적으로) 구분하지 않습니다. &lt;code&gt;goto(&quot;NE&quot;).&quot;XT&quot;&lt;/code&gt; 는 &lt;code&gt;goto NEXT&lt;/code&gt; 와 동일합니다 . 또한 대부분의 명명 된 연산자와 달리 이것은 할당과 동일한 우선 순위를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="9bc78a790919531fd0718a68912f96b73236dccd" translate="yes" xml:space="preserve">
          <source>As some variables are reported by a different name in the output of &lt;code&gt;perl -V&lt;/code&gt; than their actual name in &lt;code&gt;%Config&lt;/code&gt;, I decided to leave the &lt;code&gt;config&lt;/code&gt; entry as close to reality as possible, and put in the entries that might have been guessed by the printed output in a separate block.</source>
          <target state="translated">일부 변수는 &lt;code&gt;perl -V&lt;/code&gt; 출력 에서 &lt;code&gt;%Config&lt;/code&gt; 의 실제 이름과 다른 이름으로보고 되므로 &lt;code&gt;config&lt;/code&gt; 항목을 가능한 한 현실에 가깝게두고 별도의 블록에 인쇄 된 출력.</target>
        </trans-unit>
        <trans-unit id="48a035147de7a604eb6e8f9633c18d50b5e19c9b" translate="yes" xml:space="preserve">
          <source>As soon as one of my failing tests passes it will be removed from the list of failed tests. Eventually I fix them all and prove can find no failing tests to run:</source>
          <target state="translated">내 실패한 테스트 중 하나가 통과하는 즉시 실패한 테스트 목록에서 제거됩니다. 결국 나는 그것들을 모두 고치고 실행에 실패한 테스트를 찾을 수 없음을 증명합니다.</target>
        </trans-unit>
        <trans-unit id="81930da4a8c9e7cfd6af4afe44478552245004db" translate="yes" xml:space="preserve">
          <source>As such, consumers may use this data for informational analysis, but presenting it to the user as canonical or relying on it as such is invariably the height of folly.</source>
          <target state="translated">따라서 소비자는 정보 분석을 위해이 데이터를 사용할 수 있지만 사용자에게이를 표준으로 제시하거나 그 자체로 의존하는 것은 변함없이 어리석은 일입니다.</target>
        </trans-unit>
        <trans-unit id="6d2e840402d6fc0f9fee1fa99ab3b3ed1f5042e9" translate="yes" xml:space="preserve">
          <source>As such, signals that would normally not be appropriate to use in the &lt;code&gt;&lt;a href=&quot;functions/kill&quot;&gt;kill()&lt;/a&gt;&lt;/code&gt; command (e.g., &lt;code&gt;&lt;a href=&quot;functions/kill&quot;&gt;kill&lt;/a&gt;('KILL', $$)&lt;/code&gt; ) are okay to use with the &lt;code&gt;-&amp;gt;kill()&lt;/code&gt; method (again, as illustrated above).</source>
          <target state="translated">따라서 &lt;code&gt;&lt;a href=&quot;functions/kill&quot;&gt;kill()&lt;/a&gt;&lt;/code&gt; 명령 에 사용하기에 일반적으로 적합하지 않은 신호 (예 : &lt;code&gt;&lt;a href=&quot;functions/kill&quot;&gt;kill&lt;/a&gt;('KILL', $$)&lt;/code&gt; )는 &lt;code&gt;-&amp;gt;kill()&lt;/code&gt; 메소드 와 함께 사용하는 것이 좋습니다 (위에 설명 된대로) .</target>
        </trans-unit>
        <trans-unit id="2afd2bab6cbdd50c9685439c6b9fc8e46337a3ed" translate="yes" xml:space="preserve">
          <source>As such, signals that would normally not be appropriate to use in the &lt;code&gt;kill()&lt;/code&gt; command (e.g., &lt;code&gt;kill('KILL', $$)&lt;/code&gt;) are okay to use with the &lt;code&gt;-&amp;gt;kill()&lt;/code&gt; method (again, as illustrated above).</source>
          <target state="translated">따라서 일반적으로 &lt;code&gt;kill()&lt;/code&gt; 명령 에서 사용하기에 적합하지 않은 신호 (예 : &lt;code&gt;kill('KILL', $$)&lt;/code&gt; )는 &lt;code&gt;-&amp;gt;kill()&lt;/code&gt; 메서드 와 함께 사용하는 것이 좋습니다. .</target>
        </trans-unit>
        <trans-unit id="24bd5acc92d8894261d7ef9b04b6f856fb374ce1" translate="yes" xml:space="preserve">
          <source>As such, you open a pipe using the same &lt;code&gt;open&lt;/code&gt; call that you use for opening files, setting the second (&lt;code&gt;MODE&lt;/code&gt;) argument to special characters that indicate either an input or an output pipe. Use &lt;code&gt;&quot;-|&quot;&lt;/code&gt; for a filehandle that will let your Perl program read data from an external program, and &lt;code&gt;&quot;|-&quot;&lt;/code&gt; for a filehandle that will send data to that program instead.</source>
          <target state="translated">따라서 파일을 여는 데 사용하는 것과 동일한 &lt;code&gt;open&lt;/code&gt; 호출을 사용하여 파이프를 열고 두 번째 ( &lt;code&gt;MODE&lt;/code&gt; ) 인수를 입력 또는 출력 파이프를 나타내는 특수 문자로 설정합니다 . 사용 &lt;code&gt;&quot;-|&quot;&lt;/code&gt; Perl 프로그램이 외부 프로그램에서 데이터를 읽을 수 있도록하는 파일 핸들의 경우, 대신 해당 프로그램으로 데이터를 보내는 파일 핸들의 경우 &lt;code&gt;&quot;|-&quot;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="a44ff5fd296684850a7eea8453ca8654e5ea2769" translate="yes" xml:space="preserve">
          <source>As system libraries (most notably glibc) are also triggering errors, valgrind allows to suppress such errors using suppression files. The default suppression file that comes with valgrind already catches a lot of them. Some additional suppressions are defined in</source>
          <target state="translated">시스템 라이브러리 (특히 glibc)도 오류를 유발하므로 valgrind는 억제 파일을 사용하여 이러한 오류를 억제 할 수 있습니다. valgrind와 함께 제공되는 기본 억제 파일은 이미 많은 파일을 포착합니다. 일부 추가 억제는</target>
        </trans-unit>
        <trans-unit id="e1a99808d733ec0659b941748add22eaba940233" translate="yes" xml:space="preserve">
          <source>As that is multiple C statements it is quite common so see this idiom instead:</source>
          <target state="translated">그것이 여러 C 문이므로 매우 일반적 이므로이 관용구를 대신 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="ac882702a8c758004edc0489caa0c38829169f81" translate="yes" xml:space="preserve">
          <source>As the &lt;code&gt;'IGNORE'&lt;/code&gt; hook is not supported by &lt;code&gt;__WARN__&lt;/code&gt; , you can disable warnings using the empty subroutine:</source>
          <target state="translated">는 AS &lt;code&gt;'IGNORE'&lt;/code&gt; 훅에 의해 지원되지 않습니다 &lt;code&gt;__WARN__&lt;/code&gt; , 당신은 빈 서브 루틴을 사용하여 경고를 해제 할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="d759f2151ab12005046fd0fb7fc374d93cc7fcaa" translate="yes" xml:space="preserve">
          <source>As the &lt;code&gt;'IGNORE'&lt;/code&gt; hook is not supported by &lt;code&gt;__WARN__&lt;/code&gt;, its effect is the same as using &lt;code&gt;'DEFAULT'&lt;/code&gt;. You can disable warnings using the empty subroutine:</source>
          <target state="translated">는 AS &lt;code&gt;'IGNORE'&lt;/code&gt; 후크는 지원되지 &lt;code&gt;__WARN__&lt;/code&gt; , 그 효과는 사용하는 것과 동일하다 &lt;code&gt;'DEFAULT'&lt;/code&gt; . 빈 서브 루틴을 사용하여 경고를 비활성화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="481d1ba67f45c383e883a88846da2edc2a1775aa" translate="yes" xml:space="preserve">
          <source>As the Perl interpreter looks at signal flags only when it is about to execute a new opcode, a signal that arrives during a long-running opcode (e.g. a regular expression operation on a very large string) will not be seen until the current opcode completes.</source>
          <target state="translated">Perl 인터프리터는 새 opcode를 실행하려고 할 때만 신호 플래그를 확인하므로 장기 opop 동안 도착하는 신호 (예 : 매우 큰 문자열에서 정규 표현식 작업)는 현재 opcode가 완료 될 때까지 보이지 않습니다. .</target>
        </trans-unit>
        <trans-unit id="f849d9355eec2f51b5cef2814ee106c18c309122" translate="yes" xml:space="preserve">
          <source>As the PerlIO layer uses raw IO (bytes) internally, all this totally ignores things like the type of your filesystem (ASCII or EBCDIC).</source>
          <target state="translated">PerlIO 계층은 내부적으로 원시 IO (바이트)를 사용하므로이 모든 것은 파일 시스템 유형 (ASCII 또는 EBCDIC)과 같은 것을 완전히 무시합니다.</target>
        </trans-unit>
        <trans-unit id="ef5f3ccf5711fff6ab130d18e6106225adf61f56" translate="yes" xml:space="preserve">
          <source>As the PerlIO layer uses raw IO internally, all this totally ignores the type of your filesystem (ASCII or EBCDIC) and the IO_CONVERSION environment variable. If you want to get the old behavior, that the BS2000 IO functions determine conversion depending on the filesystem PerlIO still is your friend. You use IO_CONVERSION as usual and tell Perl, that it should use the native IO layer:</source>
          <target state="translated">PerlIO 계층은 내부에서 원시 IO를 사용하므로이 모든 것은 파일 시스템 유형 (ASCII 또는 EBCDIC)과 IO_CONVERSION 환경 변수를 완전히 무시합니다. 이전 동작을 원한다면 BS2000 IO 함수가 파일 시스템 PerlIO에 따라 변환을 결정한다는 것은 여전히 ​​당신의 친구입니다. 평소와 같이 IO_CONVERSION을 사용하고 Perl에게 네이티브 IO 레이어를 사용해야한다고 알려줍니다.</target>
        </trans-unit>
        <trans-unit id="20b8fc20101f3d438a32270dc2621c0dd14971b3" translate="yes" xml:space="preserve">
          <source>As the comment says, this is not a good way to implement accessors. It's slow and too clever by far. However, you may see this as a way to provide accessors in older Perl code. See &lt;a href=&quot;perlootut&quot;&gt;perlootut&lt;/a&gt; for recommendations on OO coding in Perl.</source>
          <target state="translated">의견에서 알 수 있듯이 접근자를 구현하는 좋은 방법은 아닙니다. 훨씬 느리고 영리합니다. 그러나 이전 Perl 코드에서 접근자를 제공하는 방법으로 볼 수 있습니다. Perl의 OO 코딩에 대한 권장 사항 은 &lt;a href=&quot;perlootut&quot;&gt;perlootut&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="1139ca2064130f83bd2fbbeaae8eb84583cc89ac" translate="yes" xml:space="preserve">
          <source>As the example in &lt;a href=&quot;#new%28%29&quot;&gt;&quot;new()&quot;&lt;/a&gt; shows, you can always create a copy of an existing version object with the same value by the very compact:</source>
          <target state="translated">&lt;a href=&quot;#new%28%29&quot;&gt;&quot;new ()&quot;&lt;/a&gt; 의 예에서 볼 수 있듯이 매우 압축하여 항상 동일한 값을 가진 기존 버전 객체의 복사본을 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4fca5f01eab824b22bb6b1905a8d483f37ad2ed6" translate="yes" xml:space="preserve">
          <source>As the example shows, if the second argument is an empty string, the category's locale is returned to the default specified by the corresponding environment variables. Generally, this results in a return to the default that was in force when Perl started up: changes to the environment made by the application after startup may or may not be noticed, depending on your system's C library.</source>
          <target state="translated">예제에서 볼 수 있듯이 두 번째 인수가 빈 문자열이면 범주의 로캘은 해당 환경 변수에 지정된 기본값으로 반환됩니다. 일반적으로 이로 인해 Perl을 시작할 때 적용되었던 기본값으로 돌아갑니다. 시스템의 C 라이브러리에 따라 시작 후 응용 프로그램이 작성한 환경의 변경 사항이 눈에 띄거나 나타나지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1edaf8c27fdae81166329d8ebc45bdc56d4e0e72" translate="yes" xml:space="preserve">
          <source>As the final two examples above show, you can achieve portability to non-ASCII platforms by using the &lt;code&gt;\N{...}&lt;/code&gt; form for the range endpoints. These indicate that the specified range is to be interpreted using Unicode values, so &lt;code&gt;[\N{U+27}-\N{U+3F}]&lt;/code&gt; means to match &lt;code&gt;\N{U+27}&lt;/code&gt;, &lt;code&gt;\N{U+28}&lt;/code&gt;, &lt;code&gt;\N{U+29}&lt;/code&gt;, ..., &lt;code&gt;\N{U+3D}&lt;/code&gt;, &lt;code&gt;\N{U+3E}&lt;/code&gt;, and &lt;code&gt;\N{U+3F}&lt;/code&gt;, whatever the native code point versions for those are. These are called &quot;Unicode&quot; ranges. If either end is of the &lt;code&gt;\N{...}&lt;/code&gt; form, the range is considered Unicode. A &lt;code&gt;regexp&lt;/code&gt; warning is raised under &lt;code&gt;&quot;use re 'strict'&quot;&lt;/code&gt; if the other endpoint is specified non-portably:</source>
          <target state="translated">위의 마지막 두 예에서 볼 수 있듯이 범위 끝점에 &lt;code&gt;\N{...}&lt;/code&gt; 형식을 사용하여 비 ASCII 플랫폼으로 이식 할 수 있습니다 . 이는 지정된 범위가 유니 코드 값을 사용하여 해석됨을 나타내므로 &lt;code&gt;[\N{U+27}-\N{U+3F}]&lt;/code&gt; 는 &lt;code&gt;\N{U+27}&lt;/code&gt; , &lt;code&gt;\N{U+28}&lt;/code&gt; 과 일치 함을 의미합니다. , &lt;code&gt;\N{U+29}&lt;/code&gt; , ..., &lt;code&gt;\N{U+3D}&lt;/code&gt; , &lt;code&gt;\N{U+3E}&lt;/code&gt; , &lt;code&gt;\N{U+3F}&lt;/code&gt; , 기본 코드 포인트 버전이 무엇이든 상관 없습니다. 이를 &quot;유니 코드&quot;범위라고합니다. 한쪽 끝이 &lt;code&gt;\N{...}&lt;/code&gt; 형식이면 범위는 유니 코드로 간주됩니다. &lt;code&gt;regexp&lt;/code&gt; 경고에 따라 발생 &lt;code&gt;&quot;use re 'strict'&quot;&lt;/code&gt; 다른 끝 점이 이식 불가능하게 지정된 경우 :</target>
        </trans-unit>
        <trans-unit id="0a3da7dd18a3b2da7c7f36441b50e2eab858828a" translate="yes" xml:space="preserve">
          <source>As the final two examples above show, you can achieve portablity to non-ASCII platforms by using the &lt;code&gt;\N{...}&lt;/code&gt; form for the range endpoints. These indicate that the specified range is to be interpreted using Unicode values, so &lt;code&gt;[\N{U+27}-\N{U+3F}]&lt;/code&gt; means to match &lt;code&gt;\N{U+27}&lt;/code&gt; , &lt;code&gt;\N{U+28}&lt;/code&gt; , &lt;code&gt;\N{U+29}&lt;/code&gt; , ..., &lt;code&gt;\N{U+3D}&lt;/code&gt; , &lt;code&gt;\N{U+3E}&lt;/code&gt; , and &lt;code&gt;\N{U+3F}&lt;/code&gt; , whatever the native code point versions for those are. These are called &quot;Unicode&quot; ranges. If either end is of the &lt;code&gt;\N{...}&lt;/code&gt; form, the range is considered Unicode. A &lt;code&gt;regexp&lt;/code&gt; warning is raised under &lt;code&gt;&quot;use re 'strict'&quot;&lt;/code&gt; if the other endpoint is specified non-portably:</source>
          <target state="translated">위의 마지막 두 예제에서 알 수 있듯이 범위 끝점에 &lt;code&gt;\N{...}&lt;/code&gt; 형식을 사용하여 비 ASCII 플랫폼으로 이식 할 수 있습니다 . 이는 지정된 범위가 유니 코드 값을 사용하여 해석됨을 나타내므로 &lt;code&gt;[\N{U+27}-\N{U+3F}]&lt;/code&gt; 는 &lt;code&gt;\N{U+27}&lt;/code&gt; , &lt;code&gt;\N{U+28}&lt;/code&gt; 과 일치 함을 의미합니다. , &lt;code&gt;\N{U+29}&lt;/code&gt; , ..., &lt;code&gt;\N{U+3D}&lt;/code&gt; , &lt;code&gt;\N{U+3E}&lt;/code&gt; 및 &lt;code&gt;\N{U+3F}&lt;/code&gt; 등 기본 코드 포인트 버전에 관계없이 이를 &quot;유니 코드&quot;범위라고합니다. 양쪽 끝이 &lt;code&gt;\N{...}&lt;/code&gt; 형식이면 범위는 유니 코드로 간주됩니다. &quot; &lt;code&gt;regexp&lt;/code&gt; &lt;code&gt;&quot;use re 'strict'&quot;&lt;/code&gt; 에서 regexp 경고가 발생합니다. 다른 엔드 포인트가 이식 불가능하게 지정된 경우 :</target>
        </trans-unit>
        <trans-unit id="17c70cf277254845a8ce88c971a047564a105d87" translate="yes" xml:space="preserve">
          <source>As the last character of a prototype, or just before a semicolon, a &lt;code&gt;@&lt;/code&gt; or a &lt;code&gt;%&lt;/code&gt; , you can use &lt;code&gt;_&lt;/code&gt; in place of &lt;code&gt;$&lt;/code&gt; : if this argument is not provided, &lt;code&gt;$_&lt;/code&gt; will be used instead.</source>
          <target state="translated">프로토 타입의 마지막 문자 또는 세미콜론 ( &lt;code&gt;@&lt;/code&gt; 또는 a &lt;code&gt;%&lt;/code&gt; 직전) 으로 &lt;code&gt;$&lt;/code&gt; 대신 &lt;code&gt;_&lt;/code&gt; 을 사용할 수 있습니다 .이 인수가 제공되지 않으면 &lt;code&gt;$_&lt;/code&gt; 이 대신 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="9cd30084251e957fbd55793c63ff1e2e0b66c3d5" translate="yes" xml:space="preserve">
          <source>As the last character of a prototype, or just before a semicolon, a &lt;code&gt;@&lt;/code&gt; or a &lt;code&gt;%&lt;/code&gt;, you can use &lt;code&gt;_&lt;/code&gt; in place of &lt;code&gt;$&lt;/code&gt;: if this argument is not provided, &lt;code&gt;$_&lt;/code&gt; will be used instead.</source>
          <target state="translated">프로토 타입의 마지막 문자로, 아니면 그냥 세미콜론하는 전 &lt;code&gt;@&lt;/code&gt; 또는 &lt;code&gt;%&lt;/code&gt; , 당신은 사용할 수 있습니다 &lt;code&gt;_&lt;/code&gt; 대신에 &lt;code&gt;$&lt;/code&gt; :이 인수가 제공되지 않으면, &lt;code&gt;$_&lt;/code&gt; 대신 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="4b123b1845e08fc58170e4c4c4ab5952b56ae816" translate="yes" xml:space="preserve">
          <source>As the last example indicates, a handler may be set up to be (re)called in two or more phases. The phase name is passed as the handler's final argument.</source>
          <target state="translated">마지막 예에서 알 수 있듯이 핸들러는 둘 이상의 단계에서 (재) 호출되도록 설정할 수 있습니다. 단계 이름은 핸들러의 최종 인수로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="776d16ae4f440b015655f81050641c0ec6c3a0f2" translate="yes" xml:space="preserve">
          <source>As the parser reads the second and subsequent lines from the source stream, it feeds those lines through the &lt;code&gt;cpp&lt;/code&gt; source filter before processing them. The &lt;code&gt;cpp&lt;/code&gt; filter simply passes each line through the real C preprocessor. The output from the C preprocessor is then inserted back into the source stream by the filter.</source>
          <target state="translated">파서는 소스 스트림에서 두 번째 및 후속 라인을 읽을 때 처리하기 전에 &lt;code&gt;cpp&lt;/code&gt; 소스 필터를 통해 해당 라인을 공급 합니다. &lt;code&gt;cpp&lt;/code&gt; 필터가 단순히 실제 C 처리기를 통해 각각의 라인을 통과한다. C 전 처리기의 출력은 필터에 의해 소스 스트림으로 다시 삽입됩니다.</target>
        </trans-unit>
        <trans-unit id="de16f72d9bd04b071a155fd420870c413322270a" translate="yes" xml:space="preserve">
          <source>As the parser sees sections like:</source>
          <target state="translated">파서는 다음과 같은 섹션을 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b29477c3662cd388380e5f2f7edde392d4aa47d3" translate="yes" xml:space="preserve">
          <source>As the parser understands a Perl program, it builds up a tree of operations for the interpreter to perform during execution. The routines which construct and link together the various operations are to be found in</source>
          <target state="translated">파서는 Perl 프로그램을 이해함에 따라 인터프리터가 실행 중에 수행 할 작업 트리를 구성합니다. 다양한 작업을 구성하고 연결하는 루틴은</target>
        </trans-unit>
        <trans-unit id="720247a05069501ddebd25eded634ebdeed59cfd" translate="yes" xml:space="preserve">
          <source>As the sorting is done in the JSON::PP scope, you usually need to prepend &lt;code&gt;JSON::PP::&lt;/code&gt; to the subroutine name, and the special variables &lt;code&gt;$a&lt;/code&gt; and &lt;code&gt;$b&lt;/code&gt; used in the subrontine used by &lt;code&gt;sort&lt;/code&gt; function.</source>
          <target state="translated">정렬은 JSON :: PP 범위에서 수행되므로 일반적으로 &lt;code&gt;JSON::PP::&lt;/code&gt; 를 서브 루틴 이름 앞에 추가 하고 &lt;code&gt;sort&lt;/code&gt; 기능에서 사용하는 서브 론틴에 사용되는 특수 변수 &lt;code&gt;$a&lt;/code&gt; 및 &lt;code&gt;$b&lt;/code&gt; 를 추가해야 합니다.</target>
        </trans-unit>
        <trans-unit id="059620d29d96cd6f5eb8cd327a9137c1f47169b5" translate="yes" xml:space="preserve">
          <source>As there are various Make programs with incompatible syntax, which use operating system shells, again with incompatible syntax, it is important for users of this module to know which flavour of Make a Makefile has been written for so they'll use the correct one and won't have to face the possibly bewildering errors resulting from using the wrong one.</source>
          <target state="translated">운영 체제 쉘을 사용하는 호환되지 않는 구문을 가진 다양한 Make 프로그램이 있으며, 호환되지 않는 구문을 사용하는 경우에도이 모듈의 사용자는 Makefile의 어떤 풍미가 작성된 것인지 알고 있어야 올바른 것을 사용하게됩니다. 잘못된 오류를 사용하여 발생할 수있는 어리석은 오류에 직면 할 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="036fd1e2507560ce47135587c83032ff17f1287e" translate="yes" xml:space="preserve">
          <source>As there is an overlap between the error numbers used by</source>
          <target state="translated">에 의해 사용되는 오류 번호가 겹치므로</target>
        </trans-unit>
        <trans-unit id="267c472340bc23541eca7afc953c80b9af09e6af" translate="yes" xml:space="preserve">
          <source>As this callback gets called less often then the &lt;code&gt;filter_json_object&lt;/code&gt; one, decoding speed will not usually suffer as much. Therefore, single-key objects make excellent targets to serialise Perl objects into, especially as single-key JSON objects are as close to the type-tagged value concept as JSON gets (it's basically an ID/VALUE tuple). Of course, JSON does not support this in any way, so you need to make sure your data never looks like a serialised Perl hash.</source>
          <target state="translated">이 콜백은 &lt;code&gt;filter_json_object&lt;/code&gt; 1 보다 덜 자주 호출되므로 디코딩 속도는 일반적으로 그다지 좋지 않습니다. 따라서 단일 키 객체는 특히 단일 키 JSON 객체가 JSON이 가져 오는 유형 태그 값 개념에 가깝기 때문에 (기본적으로 ID / VALUE 튜플) Perl 객체를 직렬화하는 데 탁월한 대상이됩니다. 물론 JSON은이를 지원하지 않으므로 데이터가 직렬화 된 Perl 해시처럼 보이지 않도록해야합니다.</target>
        </trans-unit>
        <trans-unit id="4ae4c3659f41e6ea72787219e7dd135169795201" translate="yes" xml:space="preserve">
          <source>As to how you'd implement the Russian example from the beginning of the article, well, There's More Than One Way To Do It, but it could be something like this (using English words for Russian, just so you know what's going on):</source>
          <target state="translated">기사의 시작 부분에서 러시아어 예제를 구현하는 방법에 관해서는 여러 가지 방법이 있지만 다음과 같을 수 있습니다 (러시아어에 영어 단어를 사용하여 진행 상황을 알 수 있음) :</target>
        </trans-unit>
        <trans-unit id="7c1931b1f7f35afcd5d7f66942f927b9ab23c40a" translate="yes" xml:space="preserve">
          <source>As to sharing of auxiliary functions, consider the problem of Russian numbers from the beginning of this article; obviously, you'd want to write only once the hairy code that, given a numeric value, would return some specification of which case and number a given quantified noun should use. But suppose that you discover, while localizing an interface for, say, Ukranian (a Slavic language related to Russian, spoken by several million people, many of whom would be relieved to find that your Web site's or software's interface is available in their language), that the rules in Ukranian are the same as in Russian for quantification, and probably for many other grammatical functions. While there may well be no phrases in common between Russian and Ukranian, you could still choose to have the Ukranian module inherit from the Russian module, just for the sake of inheriting all the various grammatical methods. Or, probably better organizationally, you could move those functions to a module called &lt;code&gt;_E_Slavic&lt;/code&gt; or something, which Russian and Ukrainian could inherit useful functions from, but which would (presumably) provide no lexicon.</source>
          <target state="translated">보조 기능 공유와 관련하여이 기사의 시작 부분에서 러시아 숫자 문제를 고려하십시오. 분명히 숫자 값이 주어지면 주어진 수량화 된 명사가 사용해야하는 케이스와 숫자에 대한 사양을 반환하는 털이 많은 코드를 한 번만 작성하고 싶을 것입니다. 그러나 우크라이나어 (러시아어와 관련된 슬라브어, 수백만 명의 사용자가 사용하는 슬라브어)를 현지화하는 동안 웹 사이트 또는 소프트웨어의 인터페이스를 해당 언어로 사용할 수 있다는 사실을 알게되어 안심할 수 있습니다. , 우크라이나어의 규칙은 수량화에 대한 러시아어와 동일하며 다른 많은 문법 기능에 대해서도 동일합니다. 러시아어와 우크라이나어간에 공통된 문구가 없을 수도 있지만 여전히 우크라이나어 모듈이 러시아어 모듈에서 상속되도록 선택할 수 있습니다.모든 다양한 문법적 방법을 상속하기 위해서입니다. 또는 조직적으로 더 나은 방법으로 이러한 기능을 다음과 같은 모듈로 이동할 수 있습니다. &lt;code&gt;_E_Slavic&lt;/code&gt; 또는 러시아어와 우크라이나어가 유용한 기능을 상속받을 수 있지만 어휘를 제공하지 않을 것입니다.</target>
        </trans-unit>
        <trans-unit id="c2c40011ac031fbcf62ae0096c0f70fe3f04f6d4" translate="yes" xml:space="preserve">
          <source>As told above, Perl 5.6.1 was still good in AmigaOS, as was 5.7.2. After Perl 5.7.2 (change #11423, see the Changes file, and the file pod/perlhack.pod for how to get the individual changes) Perl dropped its internal support for vfork(), and that was very probably the step that broke AmigaOS (since the ixemul library has only vfork). The build finally fails when the ext/DynaLoader is being built, and PERL ends up as &quot;0&quot; in the produced Makefile, trying to run &quot;0&quot; does not quite work. Also, executing miniperl in backticks seems to generate nothing: very probably related to the (v)fork problems. &lt;b&gt;Fixing the breakage requires someone quite familiar with the ixemul library, and how one is supposed to run external commands in AmigaOS without fork().&lt;/b&gt;</source>
          <target state="translated">위에서 언급했듯이 Perl 5.6.1은 5.7.2와 마찬가지로 AmigaOS에서도 여전히 우수했습니다. Perl 5.7.2 (변경 사항 # 11423, 변경 사항 파일 및 개별 변경 사항을 얻는 방법은 pod / perlhack.pod 파일 참조) 이후 Perl은 vfork ()에 대한 내부 지원을 중단했으며 이는 아마도 파산 한 단계 일 것입니다. AmigaOS (ixemul 라이브러리에는 vfork 만 있기 때문에). ext / DynaLoader가 빌드 될 때 빌드가 실패하고 PERL은 생성 된 Makefile에서 &quot;0&quot;으로 끝나고 &quot;0&quot;을 실행하려고 시도하는 것은 효과가 없습니다. 또한 백틱에서 miniperl을 실행하면 아무것도 생성하지 않는 것 같습니다. 아마도 (v) 포크 문제와 관련이 있습니다. &lt;b&gt;파손을 해결하려면 ixemul 라이브러리에 익숙한 사람이 있어야하며 fork ()없이 AmigaOS에서 외부 명령을 실행하는 방법이 필요합니다.&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="7df201bc839d821d3a7ec829e521380838b10cef" translate="yes" xml:space="preserve">
          <source>As usual, &lt;code&gt;PL_restartop&lt;/code&gt; is extracted from the &lt;code&gt;CxEVAL&lt;/code&gt; , and a &lt;code&gt;JMPENV_JUMP(3)&lt;/code&gt; done, which pops the C stack back to the docatch:</source>
          <target state="translated">통상, &lt;code&gt;PL_restartop&lt;/code&gt; 는 로부터 추출 &lt;code&gt;CxEVAL&lt;/code&gt; 및 &lt;code&gt;JMPENV_JUMP(3)&lt;/code&gt; docatch에 C 스택 위로 팝하는 일 :</target>
        </trans-unit>
        <trans-unit id="2a573f9f62b976f78c5ac59164a50ae13a402046" translate="yes" xml:space="preserve">
          <source>As usual, &lt;code&gt;PL_restartop&lt;/code&gt; is extracted from the &lt;code&gt;CxEVAL&lt;/code&gt;, and a &lt;code&gt;JMPENV_JUMP(3)&lt;/code&gt; done, which pops the C stack back to the docatch:</source>
          <target state="translated">통상, &lt;code&gt;PL_restartop&lt;/code&gt; 는 로부터 추출 &lt;code&gt;CxEVAL&lt;/code&gt; 및 &lt;code&gt;JMPENV_JUMP(3)&lt;/code&gt; docatch에 C 스택 위로 팝하는 일 :</target>
        </trans-unit>
        <trans-unit id="43f8dfff8ebd277fcb05688b6c5164a9ecb709ab" translate="yes" xml:space="preserve">
          <source>As usual, run</source>
          <target state="translated">평소처럼</target>
        </trans-unit>
        <trans-unit id="6a12281792622fa54248b5b0512161ae986d73ec" translate="yes" xml:space="preserve">
          <source>As we have seen above, Principle 0 overrides the others. The regexp will be matched as early as possible, with the other principles determining how the regexp matches at that earliest character position.</source>
          <target state="translated">위에서 보았 듯이 원리 0은 다른 것들보다 우선합니다. 정규 표현식은 가능한 한 빨리 일치하며 다른 원칙은 정규 표현식이 가장 빠른 문자 위치에서 일치하는 방식을 결정합니다.</target>
        </trans-unit>
        <trans-unit id="f24d0557480129d0bec98f1d07b3bc35225e11b2" translate="yes" xml:space="preserve">
          <source>As we mentioned before, Perl's built-in OO system is very minimal, but also quite flexible. Over the years, many people have developed systems which build on top of Perl's built-in system to provide more features and convenience.</source>
          <target state="translated">앞에서 언급했듯이 Perl의 내장 OO 시스템은 매우 작지만 매우 유연합니다. 수년 동안 많은 사람들이 더 많은 기능과 편리함을 제공하기 위해 Perl의 내장 시스템 위에 구축 된 시스템을 개발했습니다.</target>
        </trans-unit>
        <trans-unit id="4f2e51cb7fb14eb8f1de406668bded94aec1752e" translate="yes" xml:space="preserve">
          <source>As we mentioned before, roles provide an alternative to inheritance, but Perl does not have any built-in role support. If you choose to use Moose, it comes with a full-fledged role implementation. However, if you use one of our other recommended OO modules, you can still use roles with &lt;a href=&quot;Role::Tiny&quot;&gt;Role::Tiny&lt;/a&gt;</source>
          <target state="translated">앞서 언급했듯이 역할은 상속에 대한 대안을 제공하지만 Perl에는 기본 제공 역할 지원이 없습니다. Moose를 사용하기로 선택하면 본격적인 역할 구현이 함께 제공됩니다. 그러나 다른 권장 OO 모듈 중 하나를 사용하는 경우 &lt;a href=&quot;Role::Tiny&quot;&gt;Role :: Tiny&lt;/a&gt; 와 함께 역할을 계속 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="09f78df2a986a05b74a05b4840bd77f0745f303d" translate="yes" xml:space="preserve">
          <source>As we mentioned before, roles provide an alternative to inheritance, but Perl does not have any built-in role support. If you choose to use Moose, it comes with a full-fledged role implementation. However, if you use one of our other recommended OO modules, you can still use roles with &lt;a href=&quot;http://search.cpan.org/perldoc/Role::Tiny&quot;&gt;Role::Tiny&lt;/a&gt;</source>
          <target state="translated">앞에서 언급했듯이 역할은 상속에 대한 대안을 제공하지만 Perl에는 기본 제공 역할 지원이 없습니다. Moose를 사용하기로 선택한 경우 본격적인 역할 구현이 제공됩니다. 그러나 다른 권장 OO 모듈 중 하나를 사용하면 &lt;a href=&quot;http://search.cpan.org/perldoc/Role::Tiny&quot;&gt;Role :: Tiny&lt;/a&gt; 와 함께 역할을 계속 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6f8a13dd0293aebd2b1466f31d349be90b2e062e" translate="yes" xml:space="preserve">
          <source>As we mentioned earlier, Perl provides no special constructor syntax. This means that a class must implement its own constructor. A constructor is simply a class method that returns a reference to a new object.</source>
          <target state="translated">앞에서 언급했듯이 Perl은 특별한 생성자 구문을 제공하지 않습니다. 이것은 클래스가 자체 생성자를 구현해야 함을 의미합니다. 생성자는 단순히 새 객체에 대한 참조를 반환하는 클래스 메서드입니다.</target>
        </trans-unit>
        <trans-unit id="34cb600e9a3f6e5e075e857de4110b1ef2b3324a" translate="yes" xml:space="preserve">
          <source>As we return an empty list, everything is fine.</source>
          <target state="translated">빈 목록을 반환하면 모든 것이 정상입니다.</target>
        </trans-unit>
        <trans-unit id="1bc0081962e83c9753eb5550755ad42af088433e" translate="yes" xml:space="preserve">
          <source>As we said before, Perl's minimal OO system has led to a profusion of OO systems on CPAN. While you can still drop down to the bare metal and write your classes by hand, there's really no reason to do that with modern Perl.</source>
          <target state="translated">앞에서 언급했듯이 Perl의 최소 OO 시스템은 CPAN에서 OO 시스템의 확산으로 이어졌습니다. 베어 메탈로 내려 가서 직접 수업을 작성할 수는 있지만, 현대 펄에서는 그렇게 할 이유가 없습니다.</target>
        </trans-unit>
        <trans-unit id="7867c988c2c06b2c05fdddd86e23a3f47b3a2862" translate="yes" xml:space="preserve">
          <source>As we said earlier, most Perl objects are hashes, but an object can be an instance of any Perl data type (scalar, array, etc.). Turning a plain data structure into an object is done by &lt;b&gt;blessing&lt;/b&gt; that data structure using Perl's &lt;code&gt;&lt;a href=&quot;functions/bless&quot;&gt;bless&lt;/a&gt;&lt;/code&gt; function.</source>
          <target state="translated">앞에서 언급했듯이 대부분의 Perl 객체는 해시이지만 객체는 모든 Perl 데이터 유형 (스칼라, 배열 등)의 인스턴스 일 수 있습니다. 평범한 데이터 구조를 객체로 바꾸는 것은 Perl의 &lt;code&gt;&lt;a href=&quot;functions/bless&quot;&gt;bless&lt;/a&gt;&lt;/code&gt; 기능을 사용하여 데이터 구조를 &lt;b&gt;축복&lt;/b&gt; 함으로써 이루어집니다 .</target>
        </trans-unit>
        <trans-unit id="4b99a5371cd1d193aeb40f1c8ec4bf090e8b2c97" translate="yes" xml:space="preserve">
          <source>As we said earlier, most Perl objects are hashes, but an object can be an instance of any Perl data type (scalar, array, etc.). Turning a plain data structure into an object is done by &lt;b&gt;blessing&lt;/b&gt; that data structure using Perl's &lt;code&gt;bless&lt;/code&gt; function.</source>
          <target state="translated">앞서 말했듯이 대부분의 Perl 객체는 해시이지만 객체는 모든 Perl 데이터 유형 (스칼라, 배열 등)의 인스턴스가 될 수 있습니다. 평범한 데이터 구조를 객체로 바꾸는 것은 Perl의 &lt;code&gt;bless&lt;/code&gt; 함수를 사용하여 데이터 구조를 &lt;b&gt;축복&lt;/b&gt; 함으로써 이루어집니다 .</target>
        </trans-unit>
        <trans-unit id="504d4df94aa612d7624624e4944523fc3497d648" translate="yes" xml:space="preserve">
          <source>As we saw earlier, an object is simply a data structure that has been blessed into a class via the &lt;code&gt;&lt;a href=&quot;functions/bless&quot;&gt;bless&lt;/a&gt;&lt;/code&gt; function. The &lt;code&gt;&lt;a href=&quot;functions/bless&quot;&gt;bless&lt;/a&gt;&lt;/code&gt; function can take either one or two arguments:</source>
          <target state="translated">앞에서 보았 듯이 객체는 단순히 &lt;code&gt;&lt;a href=&quot;functions/bless&quot;&gt;bless&lt;/a&gt;&lt;/code&gt; 기능을 통해 클래스에 축복 된 데이터 구조입니다 . 는 &lt;code&gt;&lt;a href=&quot;functions/bless&quot;&gt;bless&lt;/a&gt;&lt;/code&gt; 기능은 하나 또는 두 개의 인수를 취할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="86afd7b293cb09c0f55f2b3f4442d25492c71a40" translate="yes" xml:space="preserve">
          <source>As we saw earlier, an object is simply a data structure that has been blessed into a class via the &lt;code&gt;bless&lt;/code&gt; function. The &lt;code&gt;bless&lt;/code&gt; function can take either one or two arguments:</source>
          <target state="translated">앞서 살펴본 것처럼 객체는 &lt;code&gt;bless&lt;/code&gt; 함수 를 통해 클래스에 축복 된 데이터 구조 일뿐 입니다. 는 &lt;code&gt;bless&lt;/code&gt; 기능은 하나 또는 두 개의 인수를 취할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="a1d3a4a5afeb3f9e63b11e0b6c656dbcfa8f18b8" translate="yes" xml:space="preserve">
          <source>As we've already shown, &lt;code&gt;call_sv&lt;/code&gt; can be used to invoke an anonymous subroutine. However, our example showed a Perl script invoking an XSUB to perform this operation. Let's see how it can be done inside our C code:</source>
          <target state="translated">이미 &lt;code&gt;call_sv&lt;/code&gt; 를 사용하여 익명 서브 루틴을 호출 할 수 있습니다. 그러나이 예제는이 작업을 수행하기 위해 XSUB를 호출하는 Perl 스크립트를 보여줍니다. C 코드 내에서 어떻게 수행되는지 봅시다 :</target>
        </trans-unit>
        <trans-unit id="96d58f32e93788e5dbef34c03d0df80dbd089dab" translate="yes" xml:space="preserve">
          <source>As well as accessing Berkeley DB using a tied hash or array, it is also possible to make direct use of most of the API functions defined in the Berkeley DB documentation.</source>
          <target state="translated">연결된 해시 또는 배열을 사용하여 Berkeley DB에 액세스 할뿐만 아니라 Berkeley DB 설명서에 정의 된 대부분의 API 함수를 직접 사용할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="0237593efedf8b6eff88bac44019384e6b74f34f" translate="yes" xml:space="preserve">
          <source>As well as freeing all the elements of the array (like &lt;code&gt;av_clear()&lt;/code&gt;), this also frees the memory used by the av to store its list of scalars.</source>
          <target state="translated">배열의 모든 요소 (예 : &lt;code&gt;av_clear()&lt;/code&gt; )를 해제 할뿐만 아니라 av가 스칼라 목록을 저장하는 데 사용하는 메모리도 해제합니다.</target>
        </trans-unit>
        <trans-unit id="9a89b3b004de95ce93de721c0f8e3cdeec13f545" translate="yes" xml:space="preserve">
          <source>As well as freeing all the elements of the hash (like &lt;code&gt;hv_clear()&lt;/code&gt;), this also frees any auxiliary data and storage associated with the hash.</source>
          <target state="translated">해시의 모든 요소 (예 : &lt;code&gt;hv_clear()&lt;/code&gt; )를 해제 할뿐만 아니라 해시와 관련된 보조 데이터 및 저장소도 해제합니다.</target>
        </trans-unit>
        <trans-unit id="749b97b56149a492eb18a4cb65f04d306a596132" translate="yes" xml:space="preserve">
          <source>As well as freeing all the elements of the hash (like hv_clear()), this also frees any auxiliary data and storage associated with the hash.</source>
          <target state="translated">해시의 모든 요소 (예 : hv_clear ())를 해제 할뿐만 아니라 해시와 관련된 보조 데이터 및 스토리지도 해제합니다.</target>
        </trans-unit>
        <trans-unit id="2e0710bbe12c8de0ee3e47fce586245cf49652f2" translate="yes" xml:space="preserve">
          <source>As well as grouping, parentheses serve a second purpose. They can be used to capture the results of parts of the regexp match for later use. The results end up in &lt;code&gt;$1&lt;/code&gt; , &lt;code&gt;$2&lt;/code&gt; and so on.</source>
          <target state="translated">그룹화뿐만 아니라 괄호는 두 번째 목적을 제공합니다. 그것들은 나중에 사용하기 위해 정규 표현식 일치 부분의 결과를 캡처하는 데 사용될 수 있습니다. 결과는 &lt;code&gt;$1&lt;/code&gt; , &lt;code&gt;$2&lt;/code&gt; 등이됩니다.</target>
        </trans-unit>
        <trans-unit id="3a1788b97e5572fb886ee20a2620cc1ef5c829d9" translate="yes" xml:space="preserve">
          <source>As well as grouping, parentheses serve a second purpose. They can be used to capture the results of parts of the regexp match for later use. The results end up in &lt;code&gt;$1&lt;/code&gt;, &lt;code&gt;$2&lt;/code&gt; and so on.</source>
          <target state="translated">그룹화뿐만 아니라 괄호는 두 번째 용도로 사용됩니다. 나중에 사용하기 위해 regexp 일치 부분의 결과를 캡처하는 데 사용할 수 있습니다. 결과는 &lt;code&gt;$1&lt;/code&gt; , &lt;code&gt;$2&lt;/code&gt; 등이됩니다.</target>
        </trans-unit>
        <trans-unit id="998a4f37f47dfa1a21fcb95591647fa7596884ba" translate="yes" xml:space="preserve">
          <source>As well as the following methods, this class inherits all the methods in &lt;a href=&quot;IO::Socket&quot;&gt;IO::Socket&lt;/a&gt; and &lt;a href=&quot;IO::Handle&quot;&gt;IO::Handle&lt;/a&gt;.</source>
          <target state="translated">다음 메서드뿐만 아니라이 클래스는 &lt;a href=&quot;IO::Socket&quot;&gt;IO :: Socket&lt;/a&gt; 및 &lt;a href=&quot;IO::Handle&quot;&gt;IO :: Handle의&lt;/a&gt; 모든 메서드를 상속합니다 .</target>
        </trans-unit>
        <trans-unit id="7365f5053276b5ccb78d102d8d65d8a7cbb5a47c" translate="yes" xml:space="preserve">
          <source>As well as these two, there is another converter:</source>
          <target state="translated">이 두 가지 외에도 다른 변환기가 있습니다.</target>
        </trans-unit>
        <trans-unit id="79309f713ddbfafe2f6334a91eabf7f9425eca6b" translate="yes" xml:space="preserve">
          <source>As with &lt;a href=&quot;#exit-EXPR&quot;&gt;&lt;code&gt;exit&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;perlvar#%24%3F&quot;&gt;&lt;code&gt;$?&lt;/code&gt;&lt;/a&gt; is set prior to unwinding the call stack; any &lt;code&gt;DESTROY&lt;/code&gt; or &lt;code&gt;END&lt;/code&gt; handlers can then alter this value, and thus Perl's exit code.</source>
          <target state="translated">와 마찬가지로 &lt;a href=&quot;#exit-EXPR&quot;&gt; &lt;code&gt;exit&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;perlvar#%24%3F&quot;&gt; &lt;code&gt;$?&lt;/code&gt; &lt;/a&gt;호출 스택을 해제하기 전에 설정됩니다. 그러면 모든 &lt;code&gt;DESTROY&lt;/code&gt; 또는 &lt;code&gt;END&lt;/code&gt; 핸들러가이 값을 변경할 수 있으므로 Perl의 종료 코드가됩니다.</target>
        </trans-unit>
        <trans-unit id="5f09c013a494b22fb2c5704b9b33f8690cdb78ae" translate="yes" xml:space="preserve">
          <source>As with &lt;code&gt;&lt;a href=&quot;../functions/grep&quot;&gt;grep&lt;/a&gt;&lt;/code&gt; aliasing &lt;code&gt;$_&lt;/code&gt; to list elements, &lt;code&gt;pairfirst&lt;/code&gt; aliases &lt;code&gt;$a&lt;/code&gt; and &lt;code&gt;$b&lt;/code&gt; to elements of the given list. Any modifications of it by the code block will be visible to the caller.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../functions/grep&quot;&gt;grep&lt;/a&gt;&lt;/code&gt; 별명 지정 &lt;code&gt;$_&lt;/code&gt; 와 마찬가지로 요소를 나열하기 위해 &lt;code&gt;pairfirst&lt;/code&gt; 별명 &lt;code&gt;$a&lt;/code&gt; 와 &lt;code&gt;$b&lt;/code&gt; 를 주어진 목록의 요소에 쌍으로 지정하십시오. 코드 블록에 의해 수정 된 내용은 호출자가 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6ccb264713980d688f5b35e3f78e5d8bcc1b34f2" translate="yes" xml:space="preserve">
          <source>As with &lt;code&gt;&lt;a href=&quot;../functions/grep&quot;&gt;grep&lt;/a&gt;&lt;/code&gt; aliasing &lt;code&gt;$_&lt;/code&gt; to list elements, &lt;code&gt;pairgrep&lt;/code&gt; aliases &lt;code&gt;$a&lt;/code&gt; and &lt;code&gt;$b&lt;/code&gt; to elements of the given list. Any modifications of it by the code block will be visible to the caller.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../functions/grep&quot;&gt;grep&lt;/a&gt;&lt;/code&gt; 별명 지정 &lt;code&gt;$_&lt;/code&gt; 와 마찬가지로 요소를 나열하기 위해 &lt;code&gt;$a&lt;/code&gt; 및 &lt;code&gt;$b&lt;/code&gt; 를 지정된 목록의 요소에 &lt;code&gt;pairgrep&lt;/code&gt; 합니다 . 코드 블록에 의해 수정 된 내용은 호출자가 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0e0ea04c8e6030abec75f8b13970784d2a0b7c8f" translate="yes" xml:space="preserve">
          <source>As with &lt;code&gt;&lt;a href=&quot;../functions/map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; aliasing &lt;code&gt;$_&lt;/code&gt; to list elements, &lt;code&gt;pairmap&lt;/code&gt; aliases &lt;code&gt;$a&lt;/code&gt; and &lt;code&gt;$b&lt;/code&gt; to elements of the given list. Any modifications of it by the code block will be visible to the caller.</source>
          <target state="translated">와 마찬가지로 &lt;code&gt;&lt;a href=&quot;../functions/map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; 앨리어싱 &lt;code&gt;$_&lt;/code&gt; 리스트 요소에 대한 &lt;code&gt;pairmap&lt;/code&gt; 별칭 &lt;code&gt;$a&lt;/code&gt; 와 &lt;code&gt;$b&lt;/code&gt; 주어진 목록의 요소. 코드 블록에 의해 수정 된 내용은 호출자가 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fec85543ad9986bf912be9475be1ac989c167db7" translate="yes" xml:space="preserve">
          <source>As with &lt;code&gt;PERL5OPT&lt;/code&gt;, a string of additional &lt;code&gt;cpan(1)&lt;/code&gt; options to add to those you specify on the command line.</source>
          <target state="translated">&lt;code&gt;PERL5OPT&lt;/code&gt; 와 마찬가지로 명령 줄에서 지정한 옵션에 추가 할 추가 &lt;code&gt;cpan(1)&lt;/code&gt; 옵션 문자열입니다 .</target>
        </trans-unit>
        <trans-unit id="cc99e7ad503065bd82f24f799275058edae300da" translate="yes" xml:space="preserve">
          <source>As with &lt;code&gt;grep&lt;/code&gt; aliasing &lt;code&gt;$_&lt;/code&gt; to list elements, &lt;code&gt;pairfirst&lt;/code&gt; aliases &lt;code&gt;$a&lt;/code&gt; and &lt;code&gt;$b&lt;/code&gt; to elements of the given list. Any modifications of it by the code block will be visible to the caller.</source>
          <target state="translated">와 같이 &lt;code&gt;grep&lt;/code&gt; 에일리어싱 &lt;code&gt;$_&lt;/code&gt; 리스트 요소에 &lt;code&gt;pairfirst&lt;/code&gt; 별명 &lt;code&gt;$a&lt;/code&gt; 및 &lt;code&gt;$b&lt;/code&gt; 주어진리스트의 요소. 코드 블록에 의한 수정 사항은 호출자에게 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="4d482c5453c9dc11a8d1e3e4a1d4df1955e90671" translate="yes" xml:space="preserve">
          <source>As with &lt;code&gt;grep&lt;/code&gt; aliasing &lt;code&gt;$_&lt;/code&gt; to list elements, &lt;code&gt;pairgrep&lt;/code&gt; aliases &lt;code&gt;$a&lt;/code&gt; and &lt;code&gt;$b&lt;/code&gt; to elements of the given list. Any modifications of it by the code block will be visible to the caller.</source>
          <target state="translated">와 같이 &lt;code&gt;grep&lt;/code&gt; 에일리어싱 &lt;code&gt;$_&lt;/code&gt; 리스트 요소에 &lt;code&gt;pairgrep&lt;/code&gt; 별명 &lt;code&gt;$a&lt;/code&gt; 및 &lt;code&gt;$b&lt;/code&gt; 주어진리스트의 요소. 코드 블록에 의한 수정 사항은 호출자에게 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="852273f60001fb5cfcfc3f59c366b8a418d217ac" translate="yes" xml:space="preserve">
          <source>As with &lt;code&gt;gzerror()&lt;/code&gt; it returns an error number in numeric context and an error message in string context. Unlike &lt;code&gt;gzerror()&lt;/code&gt; though, the error message will correspond to the</source>
          <target state="translated">&lt;code&gt;gzerror()&lt;/code&gt; 와 마찬가지로 숫자 컨텍스트에서는 오류 번호를, 문자열 컨텍스트에서는 오류 메시지를 반환합니다. &lt;code&gt;gzerror()&lt;/code&gt; 와 달리 오류 메시지는</target>
        </trans-unit>
        <trans-unit id="ad8ddc963c1faca12f5a1122723298a5bb8081cc" translate="yes" xml:space="preserve">
          <source>As with &lt;code&gt;map&lt;/code&gt; aliasing &lt;code&gt;$_&lt;/code&gt; to list elements, &lt;code&gt;pairmap&lt;/code&gt; aliases &lt;code&gt;$a&lt;/code&gt; and &lt;code&gt;$b&lt;/code&gt; to elements of the given list. Any modifications of it by the code block will be visible to the caller.</source>
          <target state="translated">와 마찬가지로 &lt;code&gt;map&lt;/code&gt; 앨리어싱 &lt;code&gt;$_&lt;/code&gt; 리스트 요소에 대한 &lt;code&gt;pairmap&lt;/code&gt; 별칭 &lt;code&gt;$a&lt;/code&gt; 와 &lt;code&gt;$b&lt;/code&gt; 주어진 목록의 요소. 코드 블록에 의한 수정 사항은 호출자에게 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="89fce7a719c0828fb9010451c52ebed3b12f2d8d" translate="yes" xml:space="preserve">
          <source>As with &lt;code&gt;mro::get_linear_isa&lt;/code&gt; above, &lt;code&gt;UNIVERSAL&lt;/code&gt; is special. &lt;code&gt;UNIVERSAL&lt;/code&gt; (and parents') isarev lists do not include every class in existence, even though all classes are effectively descendants for method inheritance purposes.</source>
          <target state="translated">와 마찬가지로 &lt;code&gt;mro::get_linear_isa&lt;/code&gt; 위, &lt;code&gt;UNIVERSAL&lt;/code&gt; 은 특별하다. &lt;code&gt;UNIVERSAL&lt;/code&gt; (및 부모)의 isarev 목록은 모든 클래스가 메소드 상속 목적으로 효과적으로 후손이더라도 존재하는 모든 클래스를 포함하지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="32eae94f86fad4a1553a0eb1f5e32221b0ef149f" translate="yes" xml:space="preserve">
          <source>As with CORE::utime(), passing undef as both the atime and mtime will call the syscall with a NULL argument.</source>
          <target state="translated">CORE :: utime ()과 마찬가지로 undef를 atime 및 mtime으로 전달하면 NULL 인수를 사용하여 syscall을 호출합니다.</target>
        </trans-unit>
        <trans-unit id="1bfc8628cde1b50356023884cf039103db9706d2" translate="yes" xml:space="preserve">
          <source>As with G_SCALAR, this flag has 2 effects:</source>
          <target state="translated">G_SCALAR와 마찬가지로이 플래그에는 두 가지 효과가 있습니다.</target>
        </trans-unit>
        <trans-unit id="56fcac1f27b0d72bf38ecab8e2bf923c1135ad6d" translate="yes" xml:space="preserve">
          <source>As with GetOptionsFromArray, a first argument hash reference now becomes the second argument.</source>
          <target state="translated">GetOptionsFromArray와 마찬가지로 첫 번째 인수 해시 참조가 두 번째 인수가됩니다.</target>
        </trans-unit>
        <trans-unit id="f5b2adb567968a40150b99a2b38e37687da34625" translate="yes" xml:space="preserve">
          <source>As with all &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; directives, defining a constant happens at compile time. Thus, it's probably not correct to put a constant declaration inside of a conditional statement (like &lt;code&gt;if ($foo)
{ &lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; constant ... }&lt;/code&gt; ).</source>
          <target state="translated">모든 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 지시문 과 마찬가지로 상수 정의는 컴파일 타임에 발생합니다. 따라서 &lt;code&gt;if ($foo) { &lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; constant ... }&lt;/code&gt; 와 같이 조건문 안에 상수 선언을 넣는 것이 올바르지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5354f6304cc90aca1a4c69a0041cb7b6c7daa540" translate="yes" xml:space="preserve">
          <source>As with all &lt;code&gt;use&lt;/code&gt; directives, defining a constant happens at compile time. Thus, it's probably not correct to put a constant declaration inside of a conditional statement (like &lt;code&gt;if ($foo) { use constant ... }&lt;/code&gt;).</source>
          <target state="translated">모든 &lt;code&gt;use&lt;/code&gt; 지시문 과 마찬가지로 상수 정의는 컴파일 타임에 발생합니다. 따라서 조건문 안에 상수 선언을 넣는 것은 아마도 정확하지 않을 것입니다 (예 : &lt;code&gt;if ($foo) { use constant ... }&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="a9e166bc9c2d17d86e12b7d5456a5dc29e6460a0" translate="yes" xml:space="preserve">
          <source>As with all compiler backend options, these must follow directly after the '-MO=Deparse', separated by a comma but not any white space.</source>
          <target state="translated">모든 컴파일러 백엔드 옵션과 마찬가지로이 옵션은 공백이 아닌 쉼표로 구분 된 '-MO = Deparse'바로 뒤에 와야합니다.</target>
        </trans-unit>
        <trans-unit id="dec6818f5ac3b2a14f0cdaa20965c7cdeed80414" translate="yes" xml:space="preserve">
          <source>As with all standard commands, a single-character switch may be clustered with the following switch, if any.</source>
          <target state="translated">모든 표준 명령과 마찬가지로 단일 문자 스위치는 다음 스위치와 함께 클러스터 될 수 있습니다 (있는 경우).</target>
        </trans-unit>
        <trans-unit id="3f95467f687ea8e2cde45cd2aae56d762c10d52a" translate="yes" xml:space="preserve">
          <source>As with all things in Perl,</source>
          <target state="translated">펄의 모든 것들과 마찬가지로</target>
        </trans-unit>
        <trans-unit id="d4bf4ba0005710853f921b26431dc8a4fd4165e9" translate="yes" xml:space="preserve">
          <source>As with any advisory locking scheme, the protection only works if you systematically use &lt;code&gt;lock_store&lt;/code&gt; and &lt;code&gt;lock_retrieve&lt;/code&gt; . If one side of your application uses &lt;code&gt;store&lt;/code&gt; whilst the other uses &lt;code&gt;lock_retrieve&lt;/code&gt; , you will get no protection at all.</source>
          <target state="translated">권고 잠금 구성표와 마찬가지로 보호는 체계적으로 &lt;code&gt;lock_store&lt;/code&gt; 및 &lt;code&gt;lock_retrieve&lt;/code&gt; 를 사용하는 경우에만 작동합니다 . 애플리케이션의 한쪽이 &lt;code&gt;store&lt;/code&gt; 를 사용하고 다른 쪽이 &lt;code&gt;lock_retrieve&lt;/code&gt; 를 사용하는 경우 전혀 보호를받지 못합니다.</target>
        </trans-unit>
        <trans-unit id="cbbf76ef92d8f729f36aea391937508d71d89ba4" translate="yes" xml:space="preserve">
          <source>As with any advisory locking scheme, the protection only works if you systematically use &lt;code&gt;lock_store&lt;/code&gt; and &lt;code&gt;lock_retrieve&lt;/code&gt;. If one side of your application uses &lt;code&gt;store&lt;/code&gt; whilst the other uses &lt;code&gt;lock_retrieve&lt;/code&gt;, you will get no protection at all.</source>
          <target state="translated">모든 권고 잠금 체계와 마찬가지로 보호는 &lt;code&gt;lock_store&lt;/code&gt; 및 &lt;code&gt;lock_retrieve&lt;/code&gt; 를 체계적으로 사용하는 경우에만 작동합니다 . 애플리케이션의 한 쪽이 &lt;code&gt;store&lt;/code&gt; 를 사용하고 다른 쪽이 &lt;code&gt;lock_retrieve&lt;/code&gt; 를 사용 하면 전혀 보호되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="dfdecc72a46325c982361e944a60a5cc48397fb3" translate="yes" xml:space="preserve">
          <source>As with constructors, Perl provides no special accessor declaration syntax, so classes must provide explicitly written accessor methods. There are two common types of accessors, read-only and read-write.</source>
          <target state="translated">생성자와 마찬가지로 Perl은 특별한 접근 자 선언 구문을 제공하지 않으므로 클래스는 명시 적으로 작성된 접근 자 메소드를 제공해야합니다. 접근 자에는 읽기 전용과 읽기 / 쓰기의 두 가지 일반적인 유형이 있습니다.</target>
        </trans-unit>
        <trans-unit id="5d06ccd4ce0505718d0adf18033c22a5ca1bc63e" translate="yes" xml:space="preserve">
          <source>As with many unix ports, this one depends on a few &quot;standard&quot; unix utilities which are not necessarily standard for QNX4.</source>
          <target state="translated">많은 유닉스 포트와 마찬가지로, 이것은 하나의 &quot;표준&quot;유닉스 유틸리티에 의존하며, 반드시 QNX4에 대한 표준은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="522d69b5bf4a752ac2eed134a3a3d90b973940bc" translate="yes" xml:space="preserve">
          <source>As with normal Perl arrays, a RECNO array can be accessed using negative indexes. The index -1 refers to the last element of the array, -2 the second last, and so on. Attempting to access an element before the start of the array will raise a fatal run-time error.</source>
          <target state="translated">일반 Perl 배열과 마찬가지로 RECNO 배열은 음수 인덱스를 사용하여 액세스 할 수 있습니다. 인덱스 -1은 배열의 마지막 요소, -2는 두 번째 마지막 요소 등을 나타냅니다. 배열을 시작하기 전에 요소에 액세스하려고하면 치명적인 런타임 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="4f5b532a80f5e05a1cc6284ddbfce49edaec9bba" translate="yes" xml:space="preserve">
          <source>As with postfix array, postfix value slice dereferencing</source>
          <target state="translated">postfix 배열과 마찬가지로 postfix value slice dereferencing</target>
        </trans-unit>
        <trans-unit id="5f2a0ee0b6d450a60b564dbded3394cc767489a2" translate="yes" xml:space="preserve">
          <source>As with subroutines, the type of value returned from a thread's entry point function may be determined by the thread's</source>
          <target state="translated">서브 루틴과 마찬가지로 스레드의 진입 점 함수에서 반환 된 값의 유형은 스레드의</target>
        </trans-unit>
        <trans-unit id="b1cab3e1a5ac11251ae5d77c854023eac88d9ffb" translate="yes" xml:space="preserve">
          <source>As with the</source>
          <target state="translated">와 마찬가지로</target>
        </trans-unit>
        <trans-unit id="cd7300c50635cef829928b369e4af967b57015fd" translate="yes" xml:space="preserve">
          <source>As with the DB_HASH format, it is possible to provide a user defined Perl routine to perform the comparison of keys. By default, though, the keys are stored in lexical order.</source>
          <target state="translated">DB_HASH 형식과 마찬가지로 사용자 정의 Perl 루틴을 제공하여 키 비교를 수행 할 수 있습니다. 그러나 기본적으로 키는 어휘 순서로 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="69ca9bf5a86e0011eab25710aa599ffe7224ff94" translate="yes" xml:space="preserve">
          <source>As with the append mode, when you open a file in write-only mode, you can now write to that filehandle using any of &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/say&quot;&gt;say&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/write&quot;&gt;write&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;functions/syswrite&quot;&gt;syswrite&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">추가 모드와 마찬가지로, 쓰기 전용 모드에서 파일을 열면 이제 &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/say&quot;&gt;say&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/write&quot;&gt;write&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;functions/syswrite&quot;&gt;syswrite&lt;/a&gt;&lt;/code&gt; 를 사용하여 해당 파일 핸들에 쓸 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d97479933fa1462fae02a9e50ede26b28a53d5f2" translate="yes" xml:space="preserve">
          <source>As with the append mode, when you open a file in write-only mode, you can now write to that filehandle using any of &lt;code&gt;print&lt;/code&gt;, &lt;code&gt;printf&lt;/code&gt;, &lt;code&gt;say&lt;/code&gt;, &lt;code&gt;write&lt;/code&gt;, or &lt;code&gt;syswrite&lt;/code&gt;.</source>
          <target state="translated">추가 모드와 마찬가지로 쓰기 전용 모드로 파일을 열면 이제 &lt;code&gt;print&lt;/code&gt; , &lt;code&gt;printf&lt;/code&gt; , &lt;code&gt;say&lt;/code&gt; , &lt;code&gt;write&lt;/code&gt; 또는 &lt;code&gt;syswrite&lt;/code&gt; 중 하나를 사용하여 해당 파일 핸들에 쓸 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="166455d62d96ee30d0f7c0e9ebb9b193aa0e9037" translate="yes" xml:space="preserve">
          <source>As with the built-in &lt;code&gt;chmod()&lt;/code&gt;, &lt;code&gt;$file&lt;/code&gt; may be a filename or a file handle.</source>
          <target state="translated">내장과 마찬가지로 &lt;code&gt;chmod()&lt;/code&gt; , &lt;code&gt;$file&lt;/code&gt; 파일 이름이나 파일 핸들 수있다.</target>
        </trans-unit>
        <trans-unit id="1061a3cd33d1bd9d36627a353371c49a4d11968d" translate="yes" xml:space="preserve">
          <source>As with the mark stack to the value stack, the scope stack forms a pair with the save stack. The scope stack stores the height of the save stack at which nested scopes begin, and allows the save stack to be unwound back to that point when the scope is left.</source>
          <target state="translated">값 스택에 대한 마크 스택과 마찬가지로 스코프 스택은 저장 스택과 쌍을 형성합니다. 스코프 스택은 중첩 된 스코프가 시작되는 저장 스택의 높이를 저장하고 스코프가 남아있을 때 저장 스택을 해당 지점으로 되돌릴 수 있도록합니다.</target>
        </trans-unit>
        <trans-unit id="2a73b99d56aa400ec87ca02454010bfda953deea" translate="yes" xml:space="preserve">
          <source>As with the match &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m//&lt;/a&gt;&lt;/code&gt; operator, &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt; can use other delimiters, such as &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s!!!&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s{}{}&lt;/a&gt;&lt;/code&gt;, and even &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s{}//&lt;/a&gt;&lt;/code&gt;. If single quotes are used &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s'''&lt;/a&gt;&lt;/code&gt;, then the regexp and replacement are treated as single-quoted strings and there are no variable substitutions. &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt; in list context returns the same thing as in scalar context, i.e., the number of matches.</source>
          <target state="translated">match &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m//&lt;/a&gt;&lt;/code&gt; operator 와 마찬가지로 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s!!!&lt;/a&gt;&lt;/code&gt; 와 같은 다른 구분 기호를 사용할 수 있습니다 !!! 및 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s{}{}&lt;/a&gt;&lt;/code&gt; 및 심지어 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s{}//&lt;/a&gt;&lt;/code&gt; . 작은 따옴표가 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s'''&lt;/a&gt;&lt;/code&gt; 인 경우 정규 표현식과 대체는 작은 따옴표로 처리되며 변수 대체는 없습니다. 목록 컨텍스트에서 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt; 는 스칼라 컨텍스트에서와 동일한 항목, 즉 일치 횟수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="8a7f1aef7986985cb8cfbcb39be9e92c12b6802e" translate="yes" xml:space="preserve">
          <source>As with the match &lt;code&gt;m//&lt;/code&gt; operator, &lt;code&gt;s///&lt;/code&gt; can use other delimiters, such as &lt;code&gt;s!!!&lt;/code&gt; and &lt;code&gt;s{}{}&lt;/code&gt;, and even &lt;code&gt;s{}//&lt;/code&gt;. If single quotes are used &lt;code&gt;s'''&lt;/code&gt;, then the regexp and replacement are treated as single-quoted strings and there are no variable substitutions. &lt;code&gt;s///&lt;/code&gt; in list context returns the same thing as in scalar context,</source>
          <target state="translated">&lt;code&gt;m//&lt;/code&gt; 일치 연산자 와 마찬가지로 &lt;code&gt;s///&lt;/code&gt; 는 &lt;code&gt;s!!!&lt;/code&gt; 와 같은 다른 구분 기호를 사용할 수 있습니다. 및 &lt;code&gt;s{}{}&lt;/code&gt; , 심지어 &lt;code&gt;s{}//&lt;/code&gt; . 작은 따옴표가 사용 된 경우 &lt;code&gt;s'''&lt;/code&gt; , 정규식 및 대체는 작은 따옴표로 묶인 문자열로 처리되고 변수 대체가 없습니다. 목록 컨텍스트 &lt;code&gt;s///&lt;/code&gt; 는 스칼라 컨텍스트에서와 동일한 것을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="5751273786ef031d84398bd287378b577d2ec97d" translate="yes" xml:space="preserve">
          <source>As with the matching operator, the regexp quote can use different delimiters,</source>
          <target state="translated">일치 연산자와 마찬가지로 정규식 따옴표는 다른 구분 기호를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9cd8fd98a0003315162b3999969a156676702a25" translate="yes" xml:space="preserve">
          <source>As with the matching operator, the regexp quote can use different delimiters, e.g., &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr!!&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr{}&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr~~&lt;/a&gt;&lt;/code&gt;. Apostrophes as delimiters (&lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr''&lt;/a&gt;&lt;/code&gt;) inhibit any interpolation.</source>
          <target state="translated">매칭 연산자와 마찬가지로 정규 표현식 따옴표는 다른 구분 기호를 사용할 수 있습니다 (예 : &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr!!&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr{}&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr~~&lt;/a&gt;&lt;/code&gt; . 분리 문자 ( &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr''&lt;/a&gt;&lt;/code&gt; ) 인 아포스트로피는 보간을 억제합니다.</target>
        </trans-unit>
        <trans-unit id="e11bb01f2bd8c076a80300f6980985d85bb41c1a" translate="yes" xml:space="preserve">
          <source>As with the other types of ties, this method will be called when &lt;code&gt;&lt;a href=&quot;functions/untie&quot;&gt;untie&lt;/a&gt;&lt;/code&gt; happens. It may be appropriate to &quot;auto CLOSE&quot; when this occurs. See &lt;a href=&quot;#The-untie-Gotcha&quot;&gt;The untie Gotcha&lt;/a&gt; below.</source>
          <target state="translated">다른 유형의 타이와 &lt;code&gt;&lt;a href=&quot;functions/untie&quot;&gt;untie&lt;/a&gt;&lt;/code&gt; 메소드는 연결 해제 가 발생 하면 호출됩니다 . 이러한 상황이 발생하면 &quot;자동 닫기&quot;가 적절할 수 있습니다. 아래 &lt;a href=&quot;#The-untie-Gotcha&quot;&gt;의 Untie Gotcha를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="afcbb54437173c8bdb1b71e9fdd8c918462556a8" translate="yes" xml:space="preserve">
          <source>As with the other types of ties, this method will be called when &lt;code&gt;untie&lt;/code&gt; happens. It may be appropriate to &quot;auto CLOSE&quot; when this occurs. See &lt;a href=&quot;#The-untie-Gotcha&quot;&gt;&quot;The &lt;code&gt;untie&lt;/code&gt; Gotcha&quot;&lt;/a&gt; below.</source>
          <target state="translated">다른 유형의 동점과 &lt;code&gt;untie&lt;/code&gt; 메서드는 untie 가 발생할 때 호출됩니다 . 이 경우 &quot;자동 닫힘&quot;이 적절할 수 있습니다. 아래의 &lt;a href=&quot;#The-untie-Gotcha&quot;&gt;&quot;The &lt;code&gt;untie&lt;/code&gt; Gotcha&quot;를&lt;/a&gt; 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="4d1c8cd71dac7105bd6440effb2807ea501bbea1" translate="yes" xml:space="preserve">
          <source>As with the other types of ties, this method will be called when the tied handle is about to be destroyed. This is useful for debugging and possibly cleaning up.</source>
          <target state="translated">다른 유형의 타이와 마찬가지로이 메서드는 연결된 핸들이 파괴 되려고 할 때 호출됩니다. 디버깅 및 정리에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="c8628e08c07475c8f2b1e6b9f5f0e7ba611079bf" translate="yes" xml:space="preserve">
          <source>As with the return stack, it would be possible (and a small performance win) to pre-extend the return array before pushing data into it, since we know how many elements we will return:</source>
          <target state="translated">리턴 스택과 마찬가지로 데이터를 푸시하기 전에 리턴 배열을 미리 확장하는 것이 가능할 것입니다 (그리고 약간의 성능 승리).</target>
        </trans-unit>
        <trans-unit id="3d4c99ea11e7c5fcd5dc736377914de3be4bac49" translate="yes" xml:space="preserve">
          <source>As with the shell, in Perl the &lt;code&gt;&quot;&amp;lt;&quot;&lt;/code&gt; is used to open the file in read-only mode. If it succeeds, Perl allocates a brand new filehandle for you and fills in your previously undefined &lt;code&gt;$handle&lt;/code&gt; argument with a reference to that handle.</source>
          <target state="translated">쉘과 마찬가지로 Perl에서 &lt;code&gt;&quot;&amp;lt;&quot;&lt;/code&gt; 는 파일을 읽기 전용 모드로 여는 데 사용됩니다. 성공하면 Perl은 새로운 파일 핸들을 할당하고 이전에 정의되지 않은 &lt;code&gt;$handle&lt;/code&gt; 인수를 해당 핸들에 대한 참조로 채 웁니다 .</target>
        </trans-unit>
        <trans-unit id="7fd1e1a58893cf268ad48b11d78449c12dc31c5c" translate="yes" xml:space="preserve">
          <source>As you can see 3 records have been successfully created with key &lt;code&gt;Wall&lt;/code&gt; - the only thing is, when they are retrieved from the database they</source>
          <target state="translated">보시다시피 &lt;code&gt;Wall&lt;/code&gt; 키를 사용하여 3 개의 레코드가 성공적으로 작성되었습니다 . 데이터베이스에서 검색 할 때만</target>
        </trans-unit>
        <trans-unit id="07a24c035647250238dd385e01e0859319d79ee5" translate="yes" xml:space="preserve">
          <source>As you can see both modules have a broadly similar structure. They both make use of the &lt;code&gt;Filter::Util::Call&lt;/code&gt; module and both have an &lt;code&gt;&lt;a href=&quot;../../functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; method. The difference between them is that the</source>
          <target state="translated">보시다시피 두 모듈의 구조는 매우 비슷합니다. 둘 다 &lt;code&gt;Filter::Util::Call&lt;/code&gt; 모듈을 사용하고 &lt;code&gt;&lt;a href=&quot;../../functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; 메소드가 있습니다. 그들 사이의 차이점은</target>
        </trans-unit>
        <trans-unit id="6c90ba06fa5e1fe7496f3d2e8756e36b17de7ff3" translate="yes" xml:space="preserve">
          <source>As you can see both modules have a broadly similar structure. They both make use of the &lt;code&gt;Filter::Util::Call&lt;/code&gt; module and both have an &lt;code&gt;import&lt;/code&gt; method. The difference between them is that the</source>
          <target state="translated">보시다시피 두 모듈은 대체로 유사한 구조를 가지고 있습니다. 둘 다 &lt;code&gt;Filter::Util::Call&lt;/code&gt; 모듈을 사용하며 둘 다 &lt;code&gt;import&lt;/code&gt; 메소드가 있습니다. 그들 사이의 차이점은</target>
        </trans-unit>
        <trans-unit id="8f994dc63d7341f367ad1cc1ffc63c6ff1af1973" translate="yes" xml:space="preserve">
          <source>As you can see in the synopsis, based on your template, the arguments provided will be validated.</source>
          <target state="translated">시놉시스에서 볼 수 있듯이 템플릿을 기반으로 제공된 인수가 검증됩니다.</target>
        </trans-unit>
        <trans-unit id="fc43df7357cab99ebecef48bb020a483deb5469e" translate="yes" xml:space="preserve">
          <source>As you can see,</source>
          <target state="translated">보다시피,</target>
        </trans-unit>
        <trans-unit id="ba5fcb84fa73471a91e0f59090740d9676a886a8" translate="yes" xml:space="preserve">
          <source>As you can see, a new stream has been created for reading the source from &lt;code&gt;Fred.pm&lt;/code&gt; . This stream will remain active until all of &lt;code&gt;Fred.pm&lt;/code&gt; has been parsed. The source stream for &lt;code&gt;cpp_test&lt;/code&gt; will still exist, but is inactive. Once the parser has finished reading Fred.pm, the source stream associated with it will be destroyed. The source stream for &lt;code&gt;cpp_test&lt;/code&gt; then becomes active again and the parser reads line 4 and subsequent lines from &lt;code&gt;cpp_test&lt;/code&gt; .</source>
          <target state="translated">보다시피, &lt;code&gt;Fred.pm&lt;/code&gt; 에서 소스를 읽기위한 새로운 스트림이 만들어졌습니다 . 이 스트림은 모든 &lt;code&gt;Fred.pm&lt;/code&gt; 이 구문 분석 될 때까지 활성 상태를 유지 합니다. &lt;code&gt;cpp_test&lt;/code&gt; 의 소스 스트림 은 여전히 ​​존재하지만 비활성입니다. 파서가 Fred.pm 읽기를 마치면 해당 소스 스트림이 삭제됩니다. 그런 다음 &lt;code&gt;cpp_test&lt;/code&gt; 의 소스 스트림 이 다시 활성화되고 구문 분석기는 &lt;code&gt;cpp_test&lt;/code&gt; 에서 4 행 및 후속 행을 읽습니다 .</target>
        </trans-unit>
        <trans-unit id="d30857f7aa9b41378f7136a05fa07d62994d4300" translate="yes" xml:space="preserve">
          <source>As you can see, a new stream has been created for reading the source from &lt;code&gt;Fred.pm&lt;/code&gt;. This stream will remain active until all of &lt;code&gt;Fred.pm&lt;/code&gt; has been parsed. The source stream for &lt;code&gt;cpp_test&lt;/code&gt; will still exist, but is inactive. Once the parser has finished reading Fred.pm, the source stream associated with it will be destroyed. The source stream for &lt;code&gt;cpp_test&lt;/code&gt; then becomes active again and the parser reads line 4 and subsequent lines from &lt;code&gt;cpp_test&lt;/code&gt;.</source>
          <target state="translated">보시다시피 &lt;code&gt;Fred.pm&lt;/code&gt; 에서 소스를 읽기 위해 새 스트림이 생성되었습니다 . 이 스트림은 모든 &lt;code&gt;Fred.pm&lt;/code&gt; 이 구문 분석 될 때까지 활성 상태로 유지됩니다 . &lt;code&gt;cpp_test&lt;/code&gt; 의 소스 스트림 은 여전히 ​​존재하지만 비활성 상태입니다. 파서가 Fred.pm 읽기를 마치면 관련된 소스 스트림이 삭제됩니다. 그러면 &lt;code&gt;cpp_test&lt;/code&gt; 에 대한 소스 스트림 이 다시 활성화되고 구문 분석기는 &lt;code&gt;cpp_test&lt;/code&gt; 에서 4 행과 후속 행을 읽습니다 .</target>
        </trans-unit>
        <trans-unit id="25de0c5886c2da663b8272fdb54e70c4ca6e8f92" translate="yes" xml:space="preserve">
          <source>As you can see, either a bare number or a quoted string can usually be used interchangeably, except in the case of a trailing zero, which must be quoted to be converted properly. For this reason, it is strongly recommended that all initializers to qv() be quoted strings instead of bare numbers.</source>
          <target state="translated">보시다시피 베어 숫자 또는 인용 문자열은 일반적으로 올바르게 변환하기 위해 인용해야하는 후행 0의 경우를 제외하고 서로 바꿔서 사용할 수 있습니다. 이러한 이유로 qv ()에 대한 모든 이니셜 라이저는 맨 숫자 대신 따옴표로 묶인 문자열을 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="413492c2aba459a109ff8cf8bd650d35b867bf30" translate="yes" xml:space="preserve">
          <source>As you can see, even though we parsed out a branch and a piece, it was ultimately only an atom. The final program shows us how things work. We have an &lt;code&gt;EXACT&lt;/code&gt; regop, followed by an &lt;code&gt;END&lt;/code&gt; regop. The number in parens indicates where the &lt;code&gt;regnext&lt;/code&gt; of the node goes. The &lt;code&gt;regnext&lt;/code&gt; of an &lt;code&gt;END&lt;/code&gt; regop is unused, as &lt;code&gt;END&lt;/code&gt; regops mean we have successfully matched. The number on the left indicates the position of the regop in the regnode array.</source>
          <target state="translated">보시다시피, 우리는 가지와 조각을 파싱했지만 궁극적으로는 원자 일뿐입니다. 마지막 프로그램은 작동 방식을 보여줍니다. 우리는 &lt;code&gt;EXACT&lt;/code&gt; regop 다음에 &lt;code&gt;END&lt;/code&gt; regop이 있습니다. 괄호 안의 숫자 는 노드 의 &lt;code&gt;regnext&lt;/code&gt; 이가는 곳을 나타냅니다 . &lt;code&gt;regnext&lt;/code&gt; 의 &lt;code&gt;END&lt;/code&gt; 으로 regop는 사용되지 &lt;code&gt;END&lt;/code&gt; 의 regops 우리가 성공적으로 일치 한 것을 의미한다. 왼쪽의 숫자는 regnode 배열에서 regop의 위치를 ​​나타냅니다.</target>
        </trans-unit>
        <trans-unit id="a413e2eb7d932038f9ab1ac09695763b902b4d80" translate="yes" xml:space="preserve">
          <source>As you can see, it's getting a bit complicated. That's why sometimes is easier to take a temporary on your way through:</source>
          <target state="translated">보다시피, 조금 복잡해지고 있습니다. 그렇기 때문에 때때로 다음과 같은 과정을 거치는 것이 더 쉬운 이유입니다.</target>
        </trans-unit>
        <trans-unit id="3fa1293b0c00ad3a76c1e01bf182a9e2122f9fdc" translate="yes" xml:space="preserve">
          <source>As you can see, the &quot;big end&quot; of the arrow touches the &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt;, which is a nice way to remember that &lt;code&gt;&amp;gt;&lt;/code&gt; is the big-endian modifier. The same obviously works for &lt;code&gt;&amp;lt;&lt;/code&gt; , where the &quot;little end&quot; touches the code.</source>
          <target state="translated">보다시피, 화살표의 &quot;큰 끝&quot;은 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; 에 닿습니다. &lt;code&gt;&amp;gt;&lt;/code&gt; 는 big-endian 수정 자임 을 기억하는 좋은 방법 입니다. &quot;작은 끝&quot;이 코드에 닿는 &lt;code&gt;&amp;lt;&lt;/code&gt; 에 대해서도 마찬가지 입니다.</target>
        </trans-unit>
        <trans-unit id="e38e7377d2adf9700c078e4fa63c0bfa66881f41" translate="yes" xml:space="preserve">
          <source>As you can see, the &quot;big end&quot; of the arrow touches the &lt;code&gt;s&lt;/code&gt;, which is a nice way to remember that &lt;code&gt;&amp;gt;&lt;/code&gt; is the big-endian modifier. The same obviously works for &lt;code&gt;&amp;lt;&lt;/code&gt;, where the &quot;little end&quot; touches the code.</source>
          <target state="translated">보시다시피 화살표의 &quot;큰 끝&quot;은 &lt;code&gt;s&lt;/code&gt; 에 닿습니다 . 이는 &lt;code&gt;&amp;gt;&lt;/code&gt; 가 빅 엔디안 수정 자임 을 기억하는 좋은 방법 입니다. &quot;작은 끝&quot;이 코드에 닿는 &lt;code&gt;&amp;lt;&lt;/code&gt; 에서도 동일하게 작동 합니다.</target>
        </trans-unit>
        <trans-unit id="66163e2bfe72429a8264b60a772dffb530266b37" translate="yes" xml:space="preserve">
          <source>As you can see, the &lt;code&gt;&quot;|&quot;&lt;/code&gt; binds less tightly than a sequence of ordinary characters. We can override this by using the grouping metacharacters, the parentheses &lt;code&gt;&quot;(&quot;&lt;/code&gt; and &lt;code&gt;&quot;)&quot;&lt;/code&gt;.</source>
          <target state="translated">보시다시피 &lt;code&gt;&quot;|&quot;&lt;/code&gt; 일련의 일반 문자보다 덜 단단히 묶습니다. 그룹화 메타 문자, 괄호 &lt;code&gt;&quot;(&quot;&lt;/code&gt; 및 &lt;code&gt;&quot;)&quot;&lt;/code&gt; 를 사용하여이를 재정의 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8d3da9040412695027bfa4b6fb728646046f3571" translate="yes" xml:space="preserve">
          <source>As you can see, the continuation bytes all begin with &lt;code&gt;&quot;10&quot;&lt;/code&gt; , and the leading bits of the start byte tell how many bytes there are in the encoded character.</source>
          <target state="translated">보다시피, 연속 바이트는 모두 &lt;code&gt;&quot;10&quot;&lt;/code&gt; 으로 시작하고 시작 바이트의 선행 비트는 인코딩 된 문자에 몇 바이트가 있는지 알려줍니다.</target>
        </trans-unit>
        <trans-unit id="d1ec4366039f138acb113c4753f7ee644d2c9618" translate="yes" xml:space="preserve">
          <source>As you can see, the continuation bytes all begin with &lt;code&gt;&quot;10&quot;&lt;/code&gt;, and the leading bits of the start byte tell how many bytes there are in the encoded character.</source>
          <target state="translated">보시다시피 연속 바이트는 모두 &lt;code&gt;&quot;10&quot;&lt;/code&gt; 으로 시작하고 시작 바이트의 선행 비트는 인코딩 된 문자에 몇 바이트가 있는지 알려줍니다.</target>
        </trans-unit>
        <trans-unit id="3abefb49e57cec4dd056d885964fc7e8cddbabc0" translate="yes" xml:space="preserve">
          <source>As you can see, we've stored the path and file data in the object itself. Remember, under the hood, this object is still just a hash. Later, we'll write accessors to manipulate this data.</source>
          <target state="translated">보시다시피 경로와 파일 데이터를 객체 자체에 저장했습니다. 후드 아래에서이 객체는 여전히 해시 일뿐입니다. 나중에이 데이터를 조작하기 위해 접근자를 작성합니다.</target>
        </trans-unit>
        <trans-unit id="5a6344bf7b33dbff5320cfc2c10a629a29808655" translate="yes" xml:space="preserve">
          <source>As you can tell from a glance at &lt;a href=&quot;perlpod&quot;&gt;perlpod&lt;/a&gt;, the L&amp;lt;...&amp;gt; code is the most complex of the Pod formatting codes. The points below will hopefully clarify what it means and how processors should deal with it.</source>
          <target state="translated">&lt;a href=&quot;perlpod&quot;&gt;perlpod를&lt;/a&gt; 한눈에 알 수 있듯이 L &amp;lt;...&amp;gt; 코드는 포드 형식 코드 중 가장 복잡한 코드입니다. 아래의 요점은 그것이 의미하는 바와 프로세서가 어떻게 처리해야 하는지를 명확하게 설명 할 것입니다.</target>
        </trans-unit>
        <trans-unit id="9261097e2916c2cc0f66dd44d4a942cdcbac0f6d" translate="yes" xml:space="preserve">
          <source>As you craft each patch you intend to submit to the Perl core, it's important to write a good commit message. This is especially important if your submission will consist of a series of commits.</source>
          <target state="translated">Perl 코어에 제출할 각 패치를 만들 때 좋은 커밋 메시지를 작성하는 것이 중요합니다. 제출이 일련의 커밋으로 구성되는 경우 특히 중요합니다.</target>
        </trans-unit>
        <trans-unit id="585d50527e778d78ffa867804e8d6039ce87d004" translate="yes" xml:space="preserve">
          <source>As you may have inferred from the above documentation and examples, &lt;code&gt;ok&lt;/code&gt; 's prototype is &lt;code&gt;($;$$)&lt;/code&gt; (and, incidentally, &lt;code&gt;skip&lt;/code&gt; 's is &lt;code&gt;($;$$$)&lt;/code&gt;). This means, for example, that you can do &lt;code&gt;ok @foo, @bar&lt;/code&gt; to compare the</source>
          <target state="translated">위의 문서와 예제에서 추론지도 모르지만, &lt;code&gt;ok&lt;/code&gt; 의 프로토 타입이다 &lt;code&gt;($;$$)&lt;/code&gt; (부수적으로, 그리고 &lt;code&gt;skip&lt;/code&gt; 의이 ' &lt;code&gt;($;$$$)&lt;/code&gt; ). 예를 들어 &lt;code&gt;ok @foo, @bar&lt;/code&gt; 를 사용하여</target>
        </trans-unit>
        <trans-unit id="60f0e85b8faee0b99818f50244dd5f18552cf61a" translate="yes" xml:space="preserve">
          <source>As you may have inferred from the above documentation and examples, &lt;code&gt;ok&lt;/code&gt;'s prototype is &lt;code&gt;($;$$)&lt;/code&gt; (and, incidentally, &lt;code&gt;skip&lt;/code&gt;'s is &lt;code&gt;($;$$$)&lt;/code&gt;). This means, for example, that you can do &lt;code&gt;ok @foo, @bar&lt;/code&gt; to compare the</source>
          <target state="translated">위의 문서와 예제에서 추론 할 수 있듯이 &lt;code&gt;ok&lt;/code&gt; 의 프로토 타입은 &lt;code&gt;($;$$)&lt;/code&gt; (그리고 우연히 &lt;code&gt;skip&lt;/code&gt; 's는 &lt;code&gt;($;$$$)&lt;/code&gt; )입니다. 이것은 예를 들어 &lt;code&gt;ok @foo, @bar&lt;/code&gt; 를 수행하여</target>
        </trans-unit>
        <trans-unit id="d3a79c79e4e5a9fafc42ddaaf88736c1e2cc7621" translate="yes" xml:space="preserve">
          <source>As you may have noticed, the name of the FETCH method (et al.) is the same for all accesses, even though the constructors differ in names (TIESCALAR vs TIEARRAY). While in theory you could have the same class servicing several tied types, in practice this becomes cumbersome, and it's easiest to keep them at simply one tie type per class.</source>
          <target state="translated">아시다시피, 생성자가 이름이 다르더라도 FETCH 메소드의 이름 (et al.)은 모든 액세스에서 동일합니다 (TIESCALAR vs TIEARRAY). 이론적으로 여러 묶음 유형을 처리하는 동일한 클래스를 가질 수 있지만 실제로는 번거롭고 클래스 당 하나의 타이 유형으로 유지하는 것이 가장 쉽습니다.</target>
        </trans-unit>
        <trans-unit id="e80271d1fdc3feb0460f1e3a1704fc272e31f101" translate="yes" xml:space="preserve">
          <source>As you might know this calls the &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; function of &lt;code&gt;attributes&lt;/code&gt; at compile time with these parameters: 'attributes', the caller's package name, the reference to the code and 'method'.</source>
          <target state="translated">아시다시피 , 컴파일 타임에 'attributes', 호출자의 패키지 이름, 코드에 대한 참조 및 'method'매개 변수를 사용 하여 &lt;code&gt;attributes&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; 기능을 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="62f1e6ecdd027dd1eaef3a110461833a51c5767e" translate="yes" xml:space="preserve">
          <source>As you might know this calls the &lt;code&gt;import&lt;/code&gt; function of &lt;code&gt;attributes&lt;/code&gt; at compile time with these parameters: 'attributes', the caller's package name, the reference to the code and 'method'.</source>
          <target state="translated">아시다시피 컴파일 타임에 'attributes', 호출자의 패키지 이름, 코드에 대한 참조 및 'method'와 같은 매개 변수를 사용 하여 &lt;code&gt;attributes&lt;/code&gt; &lt;code&gt;import&lt;/code&gt; 함수를 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="0f14d6a62a3d5dfc412b082b83700a2aa2b31479" translate="yes" xml:space="preserve">
          <source>As you see from those examples, &lt;code&gt;STDOUT&lt;/code&gt; and &lt;code&gt;STDERR&lt;/code&gt; are output handles, and &lt;code&gt;STDIN&lt;/code&gt; and &lt;code&gt;ARGV&lt;/code&gt; are input handles. They are in all capital letters because they are reserved to Perl, much like the &lt;code&gt;@ARGV&lt;/code&gt; array and the &lt;code&gt;%ENV&lt;/code&gt; hash are. Their external associations were set up by your shell.</source>
          <target state="translated">이러한 예에서 볼 수 있듯이 &lt;code&gt;STDOUT&lt;/code&gt; 및 &lt;code&gt;STDERR&lt;/code&gt; 은 출력 핸들이고 &lt;code&gt;STDIN&lt;/code&gt; 및 &lt;code&gt;ARGV&lt;/code&gt; 는 입력 핸들입니다. &lt;code&gt;@ARGV&lt;/code&gt; 배열 및 &lt;code&gt;%ENV&lt;/code&gt; 해시 와 같이 Perl에 예약되어 있기 때문에 대문자로되어 있습니다. 외부 연결은 쉘에서 설정했습니다.</target>
        </trans-unit>
        <trans-unit id="e27f616d9e27793d35d5e898cb0fead7ca633114" translate="yes" xml:space="preserve">
          <source>As you see, it's quite easy to become confused. While some small portion of the blame for this can be attributed to the reference-based implementation, it's really more due to a lack of existing documentation with examples designed for the beginner.</source>
          <target state="translated">보시다시피 혼란스러워 쉽습니다. 이것에 대한 책임의 작은 부분은 참조 기반 구현에 기인 할 수 있지만 초보자를 위해 설계된 예제가 포함 된 기존 문서가 없기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="512c5953fca52adf9fe503c69215e4eb2353e34b" translate="yes" xml:space="preserve">
          <source>As you see, it's remarkably similar to the Internet domain TCP server, so much so, in fact, that we've omitted several duplicate functions--spawn(), logmsg(), ctime(), and REAPER()--which are the same as in the other server.</source>
          <target state="translated">보시다시피, 이것은 인터넷 도메인 TCP 서버와 매우 유사하므로 실제로는 여러 중복 함수 (spawn (), logmsg (), ctime () 및 REAPER ())를 생략했습니다. 다른 서버와 동일합니다.</target>
        </trans-unit>
        <trans-unit id="ea8178cd8e63a3e66a311fade3362af15d43aa5f" translate="yes" xml:space="preserve">
          <source>As you see, the name of the package is the name of the structure. Regular fields are just their own names. Plus the following accessor functions are provided for your convenience:</source>
          <target state="translated">보시다시피 패키지 이름은 구조 이름입니다. 일반 필드는 그 자체의 이름입니다. 또한 편의를 위해 다음과 같은 접근 자 기능이 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="1963330f0948df59dbdb1893ed34078a319f8af0" translate="yes" xml:space="preserve">
          <source>As you see, the next buffer begins with \x43. But \x43 is 'C' in ASCII, which is wrong in this case because we are now in JISX 0208 area so it has to convert \x43\x46, not \x43. Unlike utf8 and EUC, in escape-based encodings you can't tell if a given octet is a whole character or just part of it.</source>
          <target state="translated">보시다시피 다음 버퍼는 \ x43으로 시작합니다. 그러나 \ x43은 ASCII에서 'C'입니다.이 경우 우리는 이제 JISX 0208 영역에 있으므로 \ x43이 아니라 \ x43 \ x46을 변환해야합니다. utf8 및 EUC와 달리 이스케이프 기반 인코딩에서는 주어진 옥텟이 전체 문자인지 아니면 일부인지 알 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="b457b60332a38dcdc3bc2fb765fda15f087f9402" translate="yes" xml:space="preserve">
          <source>As you see, there is one exception: in ASCII. That way you can assume Goal #1. And with &lt;code&gt;Encode&lt;/code&gt; , Goal #2 is assumed but you still have to be careful in the cases mentioned in the &lt;b&gt;CAVEAT&lt;/b&gt; paragraphs above.</source>
          <target state="translated">보시다시피 ASCII에는 예외가 있습니다. 그렇게하면 목표 # 1을 가정 할 수 있습니다. 그리고 &lt;code&gt;Encode&lt;/code&gt; 를 사용 하면 목표 # 2가 가정되지만 위 의 &lt;b&gt;CAVEAT&lt;/b&gt; 단락에 언급 된 경우에는 여전히주의해야합니다 .</target>
        </trans-unit>
        <trans-unit id="7cc089f777993943781491fc9a72f85a9a2f245b" translate="yes" xml:space="preserve">
          <source>As you see, this can be a bit tricky. It's important to realize that a regular expression is merely a set of assertions that gives a definition of success. There may be 0, 1, or several different ways that the definition might succeed against a particular string. And if there are multiple ways it might succeed, you need to understand backtracking to know which variety of success you will achieve.</source>
          <target state="translated">보다시피, 이것은 약간 까다로울 수 있습니다. 정규식은 단지 성공의 정의를 제공하는 일련의 주장이라는 것을 인식하는 것이 중요합니다. 정의가 특정 문자열에 대해 성공할 수있는 0, 1 또는 여러 가지 다른 방법이있을 수 있습니다. 성공할 수있는 여러 방법이있는 경우 역 추적을 이해하여 어떤 성공을 거둘 수 있는지 알아야합니다.</target>
        </trans-unit>
        <trans-unit id="f1ce088efa2db68e2d881f71961d1904be5d37ad" translate="yes" xml:space="preserve">
          <source>As you would expect, this modifier causes, for example, &lt;code&gt;\D&lt;/code&gt; to mean the same thing as &lt;code&gt;[^0-9]&lt;/code&gt; ; in fact, all non-ASCII characters match &lt;code&gt;\D&lt;/code&gt; , &lt;code&gt;\S&lt;/code&gt; , and &lt;code&gt;\W&lt;/code&gt; . &lt;code&gt;\b&lt;/code&gt; still means to match at the boundary between &lt;code&gt;\w&lt;/code&gt; and &lt;code&gt;\W&lt;/code&gt; , using the &lt;code&gt;/a&lt;/code&gt; definitions of them (similarly for &lt;code&gt;\B&lt;/code&gt; ).</source>
          <target state="translated">예상 한대로이 수정자는 예를 들어 &lt;code&gt;\D&lt;/code&gt; 가 &lt;code&gt;[^0-9]&lt;/code&gt; 와 동일한 것을 의미합니다 . 실제로 모든 비 ASCII 문자는 &lt;code&gt;\D&lt;/code&gt; , &lt;code&gt;\S&lt;/code&gt; 및 &lt;code&gt;\W&lt;/code&gt; 와 일치 합니다. &lt;code&gt;\b&lt;/code&gt; 여전히 경계에 일치하는 것을 의미 &lt;code&gt;\w&lt;/code&gt; 와 &lt;code&gt;\W&lt;/code&gt; 사용 &lt;code&gt;/a&lt;/code&gt; (마찬가지로, 그들에 대한 정의를 &lt;code&gt;\B&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="326d016c49ef7a973850d57e2bcbf3c0189253be" translate="yes" xml:space="preserve">
          <source>As you would expect, this modifier causes, for example, &lt;code&gt;\D&lt;/code&gt; to mean the same thing as &lt;code&gt;[^0-9]&lt;/code&gt;; in fact, all non-ASCII characters match &lt;code&gt;\D&lt;/code&gt;, &lt;code&gt;\S&lt;/code&gt;, and &lt;code&gt;\W&lt;/code&gt;. &lt;code&gt;\b&lt;/code&gt; still means to match at the boundary between &lt;code&gt;\w&lt;/code&gt; and &lt;code&gt;\W&lt;/code&gt;, using the &lt;code&gt;/a&lt;/code&gt; definitions of them (similarly for &lt;code&gt;\B&lt;/code&gt;).</source>
          <target state="translated">예상 한대로이 수정자는 예를 들어 &lt;code&gt;\D&lt;/code&gt; 가 &lt;code&gt;[^0-9]&lt;/code&gt; 와 동일한 의미를 갖도록합니다 . 실제로 모든 비 ASCII 문자는 &lt;code&gt;\D&lt;/code&gt; , &lt;code&gt;\S&lt;/code&gt; 및 &lt;code&gt;\W&lt;/code&gt; 와 일치 합니다. &lt;code&gt;\b&lt;/code&gt; 여전히 &lt;code&gt;\w&lt;/code&gt; 와 &lt;code&gt;\W&lt;/code&gt; 사이의 경계에서 일치하는 것을 의미하며 , 이들 의 &lt;code&gt;/a&lt;/code&gt; 정의를 사용합니다 ( &lt;code&gt;\B&lt;/code&gt; 와 유사 함 ).</target>
        </trans-unit>
        <trans-unit id="26154301b1350500c1d0c8c752bea63ea6529192" translate="yes" xml:space="preserve">
          <source>As you're writing an application, you decide as you go what messages you need to emit. Normally you'd go to write this:</source>
          <target state="translated">응용 프로그램을 작성할 때 어떤 메시지를 내 보내야하는지 결정합니다. 일반적으로 다음과 같이 작성합니다.</target>
        </trans-unit>
        <trans-unit id="94a73ad4a31e87483d1616b8954f4b6c0ff428df" translate="yes" xml:space="preserve">
          <source>As you've seen, you can force &lt;code&gt;catdir()&lt;/code&gt; to create an absolute path by passing either an empty string or a path that begins with a volume name as the first argument. However, you are strongly encouraged not to do so, since this is done only for backward compatibility. Newer versions of File::Spec come with a method called &lt;code&gt;catpath()&lt;/code&gt; (see below), that is designed to offer a portable solution for the creation of absolute paths. It takes volume, directory and file portions and returns an entire path. While &lt;code&gt;catdir()&lt;/code&gt; is still suitable for the concatenation of</source>
          <target state="translated">앞에서 본 것처럼 빈 문자열이나 볼륨 이름으로 시작하는 경로를 첫 번째 인수로 전달하여 &lt;code&gt;catdir()&lt;/code&gt; 이 절대 경로를 만들 도록 할 수 있습니다 . 그러나 이전 버전과의 호환성을 위해서만 수행되므로 그렇게하지 않는 것이 좋습니다. 최신 버전의 File :: Spec에는 &lt;code&gt;catpath()&lt;/code&gt; (아래 참조 ) 라는 메서드 가 포함되어 있으며 절대 경로를 만들기위한 휴대용 솔루션을 제공하도록 설계되었습니다. 볼륨, 디렉토리 및 파일 부분을 차지하고 전체 경로를 반환합니다. &lt;code&gt;catdir()&lt;/code&gt; 은 여전히 ​​연결에 적합 하지만</target>
        </trans-unit>
        <trans-unit id="b050afe32e842917948687f3937c11147c83dc8c" translate="yes" xml:space="preserve">
          <source>As, &lt;code&gt;to_bin()&lt;/code&gt;, but with a &quot;0b&quot; prefix.</source>
          <target state="translated">로, &lt;code&gt;to_bin()&lt;/code&gt; 하지만, &quot;0B&quot;접두어.</target>
        </trans-unit>
        <trans-unit id="88a7400facc4c4fbcaa07e7c2bb5aa1602866660" translate="yes" xml:space="preserve">
          <source>As, &lt;code&gt;to_hex()&lt;/code&gt;, but with a &quot;0x&quot; prefix.</source>
          <target state="translated">로서 &lt;code&gt;to_hex()&lt;/code&gt; 하지만, &quot;0X&quot;접두어.</target>
        </trans-unit>
        <trans-unit id="743f14ce73f3cd35ea5c0dbbced7d93ed35d470e" translate="yes" xml:space="preserve">
          <source>As, &lt;code&gt;to_oct()&lt;/code&gt;, but with a &quot;0&quot; prefix.</source>
          <target state="translated">로서 &lt;code&gt;to_oct()&lt;/code&gt; 하지만, &quot;0&quot;접두어.</target>
        </trans-unit>
        <trans-unit id="a173e725607d0f98c78ebac0b31138d8d136aa84" translate="yes" xml:space="preserve">
          <source>Asia</source>
          <target state="translated">Asia</target>
        </trans-unit>
        <trans-unit id="ef98034aa566e13ada7b3540ed05db8863763db2" translate="yes" xml:space="preserve">
          <source>Aside from an experimental facility (see &lt;a href=&quot;#Signatures&quot;&gt;&quot;Signatures&quot;&lt;/a&gt; below), Perl does not have named formal parameters. In practice all you do is assign to a &lt;code&gt;my()&lt;/code&gt; list of these. Variables that aren't declared to be private are global variables. For gory details on creating private variables, see &lt;a href=&quot;#Private-Variables-via-my%28%29&quot;&gt;&quot;Private Variables via my()&quot;&lt;/a&gt; and &lt;a href=&quot;#Temporary-Values-via-local%28%29&quot;&gt;&quot;Temporary Values via local()&quot;&lt;/a&gt;. To create protected environments for a set of functions in a separate package (and probably a separate file), see &lt;a href=&quot;perlmod#Packages&quot;&gt;&quot;Packages&quot; in perlmod&lt;/a&gt;.</source>
          <target state="translated">실험 기능 (아래 &lt;a href=&quot;#Signatures&quot;&gt;&quot;서명&quot;&lt;/a&gt; 참조)을 제외하고 Perl에는 명명 된 형식 매개 변수가 없습니다. 실제로 당신이하는 일은 이것들 의 &lt;code&gt;my()&lt;/code&gt; 리스트에 할당하는 것 뿐입니다. 비공개로 선언되지 않은 변수는 전역 변수입니다. 개인 변수 생성에 대한 자세한 내용은 &lt;a href=&quot;#Private-Variables-via-my%28%29&quot;&gt;&quot;my ()를 통한 개인 변수&quot;&lt;/a&gt; 및 &lt;a href=&quot;#Temporary-Values-via-local%28%29&quot;&gt;&quot;local ()을 통한 임시 값&quot;을 참조하십시오&lt;/a&gt; . 별도의 패키지 (및 아마도 별도의 파일)에있는 함수 집합에 대한 보호 된 환경을 만들려면 &lt;a href=&quot;perlmod#Packages&quot;&gt;perlmod의 &quot;패키지&quot;를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f22fac8ac4e191689a82159394064af8e931487a" translate="yes" xml:space="preserve">
          <source>Aside from an experimental facility (see &lt;a href=&quot;#Signatures&quot;&gt;Signatures&lt;/a&gt; below), Perl does not have named formal parameters. In practice all you do is assign to a &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my()&lt;/a&gt;&lt;/code&gt; list of these. Variables that aren't declared to be private are global variables. For gory details on creating private variables, see &lt;a href=&quot;#Private-Variables-via-my()&quot;&gt;Private Variables via my()&lt;/a&gt; and &lt;a href=&quot;#Temporary-Values-via-local()&quot;&gt;Temporary Values via local()&lt;/a&gt;. To create protected environments for a set of functions in a separate package (and probably a separate file), see &lt;a href=&quot;perlmod#Packages&quot;&gt;Packages in perlmod&lt;/a&gt;.</source>
          <target state="translated">실험 시설을 제외하고 (아래 &lt;a href=&quot;#Signatures&quot;&gt;서명&lt;/a&gt; 참조) Perl에는 명명 된 공식 매개 변수가 없습니다. 실제로 당신이하는 일은 이것의 &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my()&lt;/a&gt;&lt;/code&gt; 목록에 할당하는 것 입니다. 비공개로 선언되지 않은 변수는 전역 변수입니다. 개인 변수 생성에 대한 자세한 내용은 &lt;a href=&quot;#Private-Variables-via-my()&quot;&gt;my ()를 통한 개인 변수&lt;/a&gt; 및 &lt;a href=&quot;#Temporary-Values-via-local()&quot;&gt;local ()을 통한 임시 값을&lt;/a&gt; 참조하십시오 . 별도의 패키지 (및 아마도 별도의 파일)에서 일련의 기능에 대한 보호 된 환경을 작성하려면 &lt;a href=&quot;perlmod#Packages&quot;&gt;perlmod의 패키지를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0befd0a8afa8c19a870d175a4fdb840002143042" translate="yes" xml:space="preserve">
          <source>Ask it to create new Perl executable:</source>
          <target state="translated">새 Perl 실행 파일을 작성하도록 요청하십시오.</target>
        </trans-unit>
        <trans-unit id="06d5ff26b7db3df6b27e4da48afc0d8940af7b07" translate="yes" xml:space="preserve">
          <source>Ask the current maintainer to make you a co-maintainer or transfer the module to you.</source>
          <target state="translated">현재 유지 보수 담당자에게 공동 유지 보수 담당자가되도록하거나 모듈을 귀하에게 이전하도록 요청하십시오.</target>
        </trans-unit>
        <trans-unit id="640918b79c5c24d060028d2fd27fecdba24558af" translate="yes" xml:space="preserve">
          <source>Ask the server for &quot;helpful information&quot; (that's what the RFC says) on the commands it accepts.</source>
          <target state="translated">수락하는 명령에 대한 &quot;유용한 정보&quot;(RFC가 말한 내용)를 서버에 요청하십시오.</target>
        </trans-unit>
        <trans-unit id="29957267ee0cac223134add5f2b52ea620705c23" translate="yes" xml:space="preserve">
          <source>Ask them for it. There are so many email providers available that it's unlikely the local system has any idea how to determine a user's email address.</source>
          <target state="translated">그들에게 물어보세요. 사용 가능한 이메일 제공자가 너무 많아 로컬 시스템이 사용자의 이메일 주소를 결정하는 방법을 알지 못할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8175f0d205c5d75254bfd57646dfed8cae5e64df" translate="yes" xml:space="preserve">
          <source>Assert that 2 strings are not the same.</source>
          <target state="translated">2 개의 문자열이 동일하지 않다고 가정하십시오.</target>
        </trans-unit>
        <trans-unit id="105ecea82b3155461bbe416d044a05c528e58f67" translate="yes" xml:space="preserve">
          <source>Assert that 2 strings are the same.</source>
          <target state="translated">두 개의 문자열이 동일하다는 것을 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="3cd83e9891bd9f5bea1baf962bedc44d308569ef" translate="yes" xml:space="preserve">
          <source>Assertion %s failed: file &quot;%s&quot;, line %d</source>
          <target state="translated">% s 어설 션 실패 : 파일 &quot;% s&quot;, 줄 % d</target>
        </trans-unit>
        <trans-unit id="49bf55dc112eb3597726ba8ecf785a4fae4cbce0" translate="yes" xml:space="preserve">
          <source>Assertions</source>
          <target state="translated">Assertions</target>
        </trans-unit>
        <trans-unit id="00331b7ae6edef1dff40c7175d1e39fd7f33aa69" translate="yes" xml:space="preserve">
          <source>Assertions are conditions that have to be true; they don't actually match parts of the substring. There are six assertions that are written as backslash sequences.</source>
          <target state="translated">주장은 사실이어야하는 조건입니다. 실제로는 부분 문자열의 일부와 일치하지 않습니다. 백 슬래시 시퀀스로 작성된 6 개의 어설 션이 있습니다.</target>
        </trans-unit>
        <trans-unit id="ec473104d4054125a1271db8c3a3c454c061191a" translate="yes" xml:space="preserve">
          <source>Assigned Charset Names by IANA</source>
          <target state="translated">IANA에 의해 할당 된 문자 집합 이름</target>
        </trans-unit>
        <trans-unit id="6a86826951e8fe2168fef92e79a3e63e6f4fad1f" translate="yes" xml:space="preserve">
          <source>Assigned value is not %s reference</source>
          <target state="translated">할당 된 값이 % s 참조가 아닙니다.</target>
        </trans-unit>
        <trans-unit id="9f6fd2dd7df68753c5a7360c0d8b35ab5d159443" translate="yes" xml:space="preserve">
          <source>Assigned value is not a reference</source>
          <target state="translated">할당 된 값은 참조가 아닙니다.</target>
        </trans-unit>
        <trans-unit id="bc266cdcbb6ece4821fb3ad4912b26e12d68bda4" translate="yes" xml:space="preserve">
          <source>Assigning Magic</source>
          <target state="translated">매직 할당</target>
        </trans-unit>
        <trans-unit id="50bb715253aae843187816dcb0ecbb87efcdec5e" translate="yes" xml:space="preserve">
          <source>Assigning a filehandle to a bareword</source>
          <target state="translated">베어 워드에 파일 핸들 할당</target>
        </trans-unit>
        <trans-unit id="5758c53717d47b26aecb2f1e95a4e608692a5e69" translate="yes" xml:space="preserve">
          <source>Assigning and Dereferencing Variables.</source>
          <target state="translated">변수 할당 및 역 참조.</target>
        </trans-unit>
        <trans-unit id="9b18b9bc51526dfb449c1c7223109c18c9530a59" translate="yes" xml:space="preserve">
          <source>Assigning non-zero to $[ is fatal</source>
          <target state="translated">$ [에 0이 아닌 값을 지정하는 것은 치명적입니다.</target>
        </trans-unit>
        <trans-unit id="a93015f6058ffbf0e4e5d995a578a534b1b45233" translate="yes" xml:space="preserve">
          <source>Assigning non-zero to $[ is no longer possible</source>
          <target state="translated">$ [에 0이 아닌 값을 할당하는 것은 더 이상 가능하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="39852930a7cbed0e34d5b478d338273371ea5664" translate="yes" xml:space="preserve">
          <source>Assigning non-zero to &lt;code&gt;$[&lt;/code&gt; is fatal</source>
          <target state="translated">&lt;code&gt;$[&lt;/code&gt; 0이 아닌 값을 지정하는 것은 치명적입니다.</target>
        </trans-unit>
        <trans-unit id="d524a6069dcf850237db76c5b77de165e1b358ee" translate="yes" xml:space="preserve">
          <source>Assigning to References</source>
          <target state="translated">참조에 할당</target>
        </trans-unit>
        <trans-unit id="c279a061dbc31dc7bee97d46022b90f62667a4ac" translate="yes" xml:space="preserve">
          <source>Assigning to a list of private variables to name your arguments:</source>
          <target state="translated">인수의 이름을 지정할 개인 변수 목록에 지정 :</target>
        </trans-unit>
        <trans-unit id="5095fe9fb68e9a62edc8c9686322a7856091bd87" translate="yes" xml:space="preserve">
          <source>Assigning to an entry in the hash will cause the time stamps of the file to be modified. If the file does not exist then it will be created. Assigning a single integer to a hash element will cause both the access and modification times to be changed to that value. Alternatively a reference to an array of two values can be passed. The first array element will be used to set the access time and the second element will be used to set the modification time.</source>
          <target state="translated">해시의 항목에 할당하면 파일의 타임 스탬프가 수정됩니다. 파일이 존재하지 않으면 파일이 작성됩니다. 해시 요소에 단일 정수를 할당하면 액세스 및 수정 시간이 모두 해당 값으로 변경됩니다. 또는 두 값의 배열에 대한 참조를 전달할 수 있습니다. 첫 번째 배열 요소는 액세스 시간을 설정하는 데 사용되고 두 번째 요소는 수정 시간을 설정하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="7ca1018fbacf1aa9c5974935df5ed892f5691b8b" translate="yes" xml:space="preserve">
          <source>Assigning to the special variable $[</source>
          <target state="translated">특수 변수 $ [</target>
        </trans-unit>
        <trans-unit id="7bec00ae67953bf63f8b1b3f8ddf8f9255f79d82" translate="yes" xml:space="preserve">
          <source>Assignment Operators</source>
          <target state="translated">할당 연산자</target>
        </trans-unit>
        <trans-unit id="91becff514df4bb52422a8c72ad2fa7e138a09c4" translate="yes" xml:space="preserve">
          <source>Assignment is a little bit special in that it uses its left argument to determine the context for the right argument. Assignment to a scalar evaluates the right-hand side in scalar context, while assignment to an array or hash evaluates the righthand side in list context. Assignment to a list (or slice, which is just a list anyway) also evaluates the right-hand side in list context.</source>
          <target state="translated">할당은 왼쪽 인수를 사용하여 오른쪽 인수의 컨텍스트를 결정한다는 점에서 약간 특별합니다. 스칼라에 할당하면 스칼라 컨텍스트에서 오른쪽이 평가되고, 배열 또는 해시에 할당되면 목록 컨텍스트에서 오른쪽이 평가됩니다. 리스트 (또는 슬라이스, 어쨌든 단지리스트)에 대한 할당은리스트 컨텍스트에서 오른쪽을 평가합니다.</target>
        </trans-unit>
        <trans-unit id="eeb7b7ef33aeb4c3b9e41b0d3c8c37efe141de32" translate="yes" xml:space="preserve">
          <source>Assignment operators work as in C. That is,</source>
          <target state="translated">할당 연산자는 C와 같이 작동합니다. 즉,</target>
        </trans-unit>
        <trans-unit id="e44ee3c1149f2c21100b91bdf4ef60fbcf7575f3" translate="yes" xml:space="preserve">
          <source>Assignment to a typeglob performs an aliasing operation, i.e.,</source>
          <target state="translated">타입 글로브에 할당은 앨리어싱 작업, 즉</target>
        </trans-unit>
        <trans-unit id="efdb1ec14f21e9ed5ad15f6e0bef5c8c9ed1a0b1" translate="yes" xml:space="preserve">
          <source>Assignment to both a list and a scalar</source>
          <target state="translated">목록과 스칼라 모두에 할당</target>
        </trans-unit>
        <trans-unit id="101d3fe15227197bfb043f8902c240196099b710" translate="yes" xml:space="preserve">
          <source>Assignment to references and non-references may be combined in lists and conditional ternary expressions, as long as the values on the right-hand side are the right type for each element on the left, though this may make for obfuscated code:</source>
          <target state="translated">오른쪽의 값이 왼쪽의 각 요소에 대해 올바른 유형 인 한 참조 및 비 참조에 대한 지정은 목록 및 조건부 삼항 표현식으로 결합 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="057d58c74d80136578cabbeee1b89206c3250bd4" translate="yes" xml:space="preserve">
          <source>Assignments</source>
          <target state="translated">Assignments</target>
        </trans-unit>
        <trans-unit id="38be444e6e51033245feebeecd19c780a4190e4e" translate="yes" xml:space="preserve">
          <source>Associated with the matching variables &lt;code&gt;$1&lt;/code&gt; , &lt;code&gt;$2&lt;/code&gt; , ... are the &lt;b&gt;backreferences&lt;/b&gt;&lt;code&gt;\g1&lt;/code&gt; , &lt;code&gt;\g2&lt;/code&gt; , ... Backreferences are matching variables that can be used</source>
          <target state="translated">일치하는 변수 &lt;code&gt;$1&lt;/code&gt; , &lt;code&gt;$2&lt;/code&gt; , ... 와 연관된 연관 은 &lt;b&gt;역 참조 &lt;/b&gt; &lt;code&gt;\g1&lt;/code&gt; , &lt;code&gt;\g2&lt;/code&gt; ... 역 참조는 사용할 수있는 일치하는 변수입니다</target>
        </trans-unit>
        <trans-unit id="de3f3ea1d0b7efcc3a2ee5d6b60bcc68b1043b48" translate="yes" xml:space="preserve">
          <source>Associated with the matching variables &lt;code&gt;$1&lt;/code&gt;, &lt;code&gt;$2&lt;/code&gt;, ... are the &lt;b&gt;backreferences&lt;/b&gt;&lt;code&gt;\g1&lt;/code&gt;, &lt;code&gt;\g2&lt;/code&gt;, ... Backreferences are matching variables that can be used</source>
          <target state="translated">일치하는 변수 &lt;code&gt;$1&lt;/code&gt; , &lt;code&gt;$2&lt;/code&gt; , ... 와 연관되어 있습니다. &lt;b&gt;역 참조는 &lt;/b&gt; &lt;code&gt;\g1&lt;/code&gt; , &lt;code&gt;\g2&lt;/code&gt; , ...입니다. 역 참조는 사용할 수있는 일치하는 변수입니다.</target>
        </trans-unit>
        <trans-unit id="68987493bca5f5e7abadf4c61d3d6f22214b34fc" translate="yes" xml:space="preserve">
          <source>Associates an internal FILEHANDLE with the external file specified by EXPR. That filehandle will subsequently allow you to perform I/O operations on that file, such as reading from it or writing to it.</source>
          <target state="translated">내부 FILEHANDLE을 EXPR에 지정된 외부 파일과 연관시킵니다. 해당 파일 핸들을 사용하면 해당 파일에서 읽기 또는 쓰기와 같은 I / O 작업을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6addecb62c84d829e48e459ba05882e03a175023" translate="yes" xml:space="preserve">
          <source>Assume &lt;b&gt;anything&lt;/b&gt; about structs (especially the ones you don't control, like the ones coming from the system headers)</source>
          <target state="translated">구조체에 대해 &lt;b&gt;무엇이든&lt;/b&gt; 가정하십시오 (특히 시스템 헤더에서 오는 것과 같이 제어하지 않는 것)</target>
        </trans-unit>
        <trans-unit id="9e766ffb9a2f9804774162774bb465b7a888d65a" translate="yes" xml:space="preserve">
          <source>Assume each sentence ends with two spaces and try to preserve that spacing. Without this option, all consecutive whitespace in non-verbatim paragraphs is compressed into a single space.</source>
          <target state="translated">각 문장이 두 칸으로 끝나고 그 간격을 유지한다고 가정하십시오. 이 옵션을 사용하지 않으면 비 언어 단락의 모든 연속 공백이 단일 공백으로 압축됩니다.</target>
        </trans-unit>
        <trans-unit id="eb29cb4a3a64a3e55d8f8b66fc5429f33cc90a54" translate="yes" xml:space="preserve">
          <source>Assume four classes, A,B,C &amp;amp; D.</source>
          <target state="translated">A, B, C &amp;amp; D의 네 가지 클래스를 가정하십시오.</target>
        </trans-unit>
        <trans-unit id="52c1183f42274e0344acc650141fdfaebc8ac557" translate="yes" xml:space="preserve">
          <source>Assume no one is paying attention and skips prompts for distributions that do that correctly. &lt;code&gt;cpan(1)&lt;/code&gt; sets this to &lt;code&gt;1&lt;/code&gt; unless it already has a value (even if that value is false).</source>
          <target state="translated">아무도주의를 기울이지 않고 올바르게 수행하는 배포에 대한 프롬프트를 건너 뛰지 않는다고 가정합니다. &lt;code&gt;cpan(1)&lt;/code&gt; 은 이미 값이없는 경우 (해당 값이 false 인 경우에도)이 값 을 &lt;code&gt;1&lt;/code&gt; 로 설정합니다 .</target>
        </trans-unit>
        <trans-unit id="2226e484e68600c3306101e70d0302d670391b19" translate="yes" xml:space="preserve">
          <source>Assume nothing about numerical values (&lt;a href=&quot;perlfunc#ord-EXPR&quot;&gt;&lt;code&gt;ord&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;perlfunc#chr-NUMBER&quot;&gt;&lt;code&gt;chr&lt;/code&gt;&lt;/a&gt;) of characters. Do not use explicit code point ranges (like &lt;code&gt;\xHH-\xHH)&lt;/code&gt;. However, starting in Perl v5.22, regular expression pattern bracketed character class ranges specified like &lt;code&gt;qr/[\N{U+HH}-\N{U+HH}]/&lt;/code&gt; are portable, and starting in Perl v5.24, the same ranges are portable in &lt;a href=&quot;perlop#tr%2FSEARCHLIST%2FREPLACEMENTLIST%2Fcdsr&quot;&gt;&lt;code&gt;tr///&lt;/code&gt;&lt;/a&gt;. You can portably use symbolic character classes like &lt;code&gt;[:print:]&lt;/code&gt;.</source>
          <target state="translated">문자의 숫자 값 ( &lt;a href=&quot;perlfunc#ord-EXPR&quot;&gt; &lt;code&gt;ord&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;perlfunc#chr-NUMBER&quot;&gt; &lt;code&gt;chr&lt;/code&gt; &lt;/a&gt; )에 대해 아무 것도 가정하지 마십시오 . 명시적인 코드 포인트 범위 (예 : &lt;code&gt;\xHH-\xHH)&lt;/code&gt; 사용하지 마십시오 . 그러나 Perl v5.22부터 &lt;code&gt;qr/[\N{U+HH}-\N{U+HH}]/&lt;/code&gt; 와 같이 지정된 정규식 패턴 대괄호 문자 클래스 범위 는 이식 가능하며 Perl v5.24부터는 동일한 범위는 &lt;a href=&quot;perlop#tr%2FSEARCHLIST%2FREPLACEMENTLIST%2Fcdsr&quot;&gt; &lt;code&gt;tr///&lt;/code&gt; &lt;/a&gt; 로 이식 가능 합니다. &lt;code&gt;[:print:]&lt;/code&gt; 와 같은 기호 문자 클래스를 이식 가능하게 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="900f642b83bb773e589683695c3e83ec1e64d87c" translate="yes" xml:space="preserve">
          <source>Assume nothing about numerical values (&lt;code&gt;&lt;a href=&quot;functions/ord&quot;&gt;ord&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr&lt;/a&gt;&lt;/code&gt;) of characters. Do not use explicit code point ranges (like &lt;code&gt;\xHH-\xHH)&lt;/code&gt; . However, starting in Perl v5.22, regular expression pattern bracketed character class ranges specified like &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr/[\N{U+HH}-\N{U+HH}]/&lt;/a&gt;&lt;/code&gt; are portable. You can portably use symbolic character classes like &lt;code&gt;[:print:]&lt;/code&gt;.</source>
          <target state="translated">문자의 숫자 값 ( &lt;code&gt;&lt;a href=&quot;functions/ord&quot;&gt;ord&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr&lt;/a&gt;&lt;/code&gt; )에 대해서는 아무 것도 가정하지 마십시오 . 명시적인 코드 포인트 범위 (예 : &lt;code&gt;\xHH-\xHH)&lt;/code&gt; 사용하지 마십시오 . 그러나 Perl v5.22부터 &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr/[\N{U+HH}-\N{U+HH}]/&lt;/a&gt;&lt;/code&gt; 와 같이 지정된 정규식 패턴 대괄호 문자 클래스 범위 는 이식 가능합니다. &lt;code&gt;[:print:]&lt;/code&gt; 와 같은 기호 문자 클래스를 이식 가능하게 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d225542d9c39b42f29197a0ce47f62fa7382a5c0" translate="yes" xml:space="preserve">
          <source>Assume that an integer cannot take less than 20 bytes of memory, a float cannot take less than 24 bytes, a string cannot take less than 32 bytes (all these examples assume 32-bit architectures, the result are quite a bit worse on 64-bit architectures). If a variable is accessed in two of three different ways (which require an integer, a float, or a string), the memory footprint may increase yet another 20 bytes. A sloppy malloc(3) implementation can inflate these numbers dramatically.</source>
          <target state="translated">정수는 20 바이트 미만의 메모리를 사용할 수없고, 부동 소수점은 24 바이트 미만을, 문자열은 32 바이트 미만을 취할 수 없다고 가정하십시오 (이 모든 예제는 32 비트 아키텍처를 가정하며 결과는 64에서 약간 더 나쁩니다. 비트 아키텍처). 정수, 부동 또는 문자열이 필요한 세 가지 방법 중 두 가지 방법으로 변수에 액세스하면 메모리 풋 프린트가 20 바이트 더 증가 할 수 있습니다. 조잡한 malloc (3) 구현은 이러한 숫자를 크게 증가시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5cf62705d74f3464ae65764bb487f8249da94d46" translate="yes" xml:space="preserve">
          <source>Assume that the old DLL is named</source>
          <target state="translated">이전 DLL의 이름이 지정되었다고 가정하십시오.</target>
        </trans-unit>
        <trans-unit id="2605c8584b04c7bf0a2b7cc3badf48edb3bf06d0" translate="yes" xml:space="preserve">
          <source>Assume that you are a seasoned porter, so are sure that all the necessary tools are already present on your system, and you know how to get the Perl source distribution. Untar it, change to the extract directory, and</source>
          <target state="translated">숙련 된 포터라고 가정하고 필요한 모든 도구가 시스템에 이미 존재하는지 확인하고 Perl 소스 배포판을 얻는 방법을 알고 있어야합니다. 압축을 풀고 추출 디렉토리로 변경 한 후</target>
        </trans-unit>
        <trans-unit id="111d847871723c094fda67b2b5bccd84d523f158" translate="yes" xml:space="preserve">
          <source>Assume this TAP version for &lt;a href=&quot;TAP::Parser&quot;&gt;TAP::Parser&lt;/a&gt; instead of default TAP version 12.</source>
          <target state="translated">기본 TAP 버전 12 대신 &lt;a href=&quot;TAP::Parser&quot;&gt;TAP :: Parser에&lt;/a&gt; 대해이 TAP 버전을 가정합니다 .</target>
        </trans-unit>
        <trans-unit id="aa1c680a74a55225e27707c2ac5fffa720c70f93" translate="yes" xml:space="preserve">
          <source>Assume this TAP version for &lt;a href=&quot;parser&quot;&gt;TAP::Parser&lt;/a&gt; instead of default TAP version 12.</source>
          <target state="translated">기본 TAP 버전 12 대신 &lt;a href=&quot;parser&quot;&gt;TAP :: Parser에&lt;/a&gt; 대해이 TAP 버전을 가정하십시오 .</target>
        </trans-unit>
        <trans-unit id="7fc8664d84c1446907ca24dadecd0bd664e1d82d" translate="yes" xml:space="preserve">
          <source>Assume very little about character sets.</source>
          <target state="translated">문자 집합에 대해 거의 가정하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="14aa653264a55e7f75e0cffdf8147628d06e0a12" translate="yes" xml:space="preserve">
          <source>Assumes that &lt;code&gt;PL_op&lt;/code&gt; is the OP that originally triggered the error, and that &lt;code&gt;PL_comppad&lt;/code&gt;/&lt;code&gt;PL_curpad&lt;/code&gt; points to the currently executing pad.</source>
          <target state="translated">것을 가정 &lt;code&gt;PL_op&lt;/code&gt; 은 원래 오류를 트리거 OP이며, 그 &lt;code&gt;PL_comppad&lt;/code&gt; / &lt;code&gt;PL_curpad&lt;/code&gt; 의 현재 실행 패드에 포인트.</target>
        </trans-unit>
        <trans-unit id="2b3c42e666c3f46061cf3e08ae5f736db9c6b58e" translate="yes" xml:space="preserve">
          <source>Assumes that PL_op is the op that originally triggered the error, and that PL_comppad/PL_curpad points to the currently executing pad.</source>
          <target state="translated">PL_op이 원래 오류를 트리거 한 op이고 PL_comppad / PL_curpad가 현재 실행중인 패드를 가리키는 것으로 가정합니다.</target>
        </trans-unit>
        <trans-unit id="40680f85edea3366c2b9e8f14183ac57a5e6081e" translate="yes" xml:space="preserve">
          <source>Assuming NOT a POSIX class since %s in regex; marked by &amp;lt;-- HERE in m/%s/</source>
          <target state="translated">정규식에서 % s 이후 POSIX 클래스가 아니라고 가정합니다. &amp;lt;-HERE (m / % s /)로 표시</target>
        </trans-unit>
        <trans-unit id="85a92465c7801a7593ae125acb124d7a78d00d62" translate="yes" xml:space="preserve">
          <source>Assuming one can dereference any type of pointer for any type of data</source>
          <target state="translated">모든 유형의 데이터에 대해 모든 유형의 포인터를 역 참조 할 수 있다고 가정</target>
        </trans-unit>
        <trans-unit id="3eba801518ac20c3e71b66588e69e8412d142226" translate="yes" xml:space="preserve">
          <source>Assuming sizeof(int) == sizeof(long)</source>
          <target state="translated">sizeof (int) == sizeof (long) 가정</target>
        </trans-unit>
        <trans-unit id="3b4336515b2aaf87ea7abdf5569d5fbbc17ae08d" translate="yes" xml:space="preserve">
          <source>Assuming that the &lt;code&gt;man&lt;/code&gt; -files were put on an appropriate location, this completes the installation of minimal Perl system. (The binary distribution contains also a lot of additional modules, and the documentation in INF format.)</source>
          <target state="translated">&lt;code&gt;man&lt;/code&gt; 파일 이 적절한 위치에 있다고 가정하면 최소 Perl 시스템 설치가 완료됩니다. (이진 배포판에는 많은 추가 모듈과 INF 형식의 설명서가 포함되어 있습니다.)</target>
        </trans-unit>
        <trans-unit id="d729092ca24191c5dd2dddf6e45eb913d7433329" translate="yes" xml:space="preserve">
          <source>Assuming that the &lt;code&gt;man&lt;/code&gt;-files were put on an appropriate location, this completes the installation of minimal Perl system. (The binary distribution contains also a lot of additional modules, and the documentation in INF format.)</source>
          <target state="translated">&lt;code&gt;man&lt;/code&gt; 파일 이 적절한 위치에 있다고 가정하면 최소 Perl 시스템 설치가 완료됩니다. (바이너리 배포판에는 많은 추가 모듈과 INF 형식의 문서도 포함되어 있습니다.)</target>
        </trans-unit>
        <trans-unit id="1b3d48dcc2393b6165f22e974c8fe37cb11cfa92" translate="yes" xml:space="preserve">
          <source>Assuming that we have to match calendar dates which may be given in one of the three formats yyyy-mm-dd, mm/dd/yyyy or dd.mm.yyyy, we can write three suitable patterns where we use 'd', 'm' and 'y' respectively as the names of the groups capturing the pertaining components of a date. The matching operation combines the three patterns as alternatives:</source>
          <target state="translated">yyyy-mm-dd, mm / dd / yyyy 또는 dd.mm.yyyy의 세 가지 형식 중 하나로 제공되는 달력 날짜와 일치해야한다고 가정하면 'd', ' 날짜의 관련 구성 요소를 캡처하는 그룹의 이름으로 각각 m '및'y '. 일치 작업은 세 가지 패턴을 대안으로 결합합니다.</target>
        </trans-unit>
        <trans-unit id="391cee4ecd3812f9caf92f329d5fa158ab37c5f3" translate="yes" xml:space="preserve">
          <source>Assuming that we have to match calendar dates which may be given in one of the three formats yyyy-mm-dd, mm/dd/yyyy or dd.mm.yyyy, we can write three suitable patterns where we use &lt;code&gt;'d'&lt;/code&gt;, &lt;code&gt;'m'&lt;/code&gt; and &lt;code&gt;'y'&lt;/code&gt; respectively as the names of the groups capturing the pertaining components of a date. The matching operation combines the three patterns as alternatives:</source>
          <target state="translated">yyyy-mm-dd, mm / dd / yyyy 또는 dd.mm.yyyy 세 가지 형식 중 하나로 제공 될 수있는 달력 날짜와 일치해야한다고 가정하면 &lt;code&gt;'d'&lt;/code&gt; , &lt;code&gt;'m'&lt;/code&gt; 사용하는 세 가지 적절한 패턴을 작성할 수 있습니다. m ' 및 &lt;code&gt;'y'&lt;/code&gt; 각각 날짜의 관련 구성 요소를 캡처하는 그룹의 이름입니다. 매칭 작업은 대안으로 세 가지 패턴을 결합합니다.</target>
        </trans-unit>
        <trans-unit id="31fc34e986ee3355963fe79a5b72db07365ea4e2" translate="yes" xml:space="preserve">
          <source>Assuming that you don't care about IEEE notations like &quot;NaN&quot; or &quot;Infinity&quot;, you probably just want to use a regular expression (see also &lt;a href=&quot;perlretut&quot;&gt;perlretut&lt;/a&gt; and &lt;a href=&quot;perlre&quot;&gt;perlre&lt;/a&gt;):</source>
          <target state="translated">&quot;NaN&quot;또는 &quot;Infinity&quot;와 같은 IEEE 표기법에 관심이 없다고 가정하면 정규 표현식을 사용하고 싶을 것입니다 ( &lt;a href=&quot;perlretut&quot;&gt;perlretut&lt;/a&gt; 및 &lt;a href=&quot;perlre&quot;&gt;perlre&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="0518d034f096809ab863fb80241126fe45a3c2bb" translate="yes" xml:space="preserve">
          <source>Assuming that you don't care about IEEE notations like &quot;NaN&quot; or &quot;Infinity&quot;, you probably just want to use a regular expression:</source>
          <target state="translated">&quot;NaN&quot;또는 &quot;Infinity&quot;와 같은 IEEE 표기법에 신경 쓰지 않는다고 가정하면 정규 표현식을 사용하고 싶을 것입니다.</target>
        </trans-unit>
        <trans-unit id="c5c2ab31ddb2d4e68552f61633bf186e98613579" translate="yes" xml:space="preserve">
          <source>Assuming the character set is ASCIIish</source>
          <target state="translated">문자 세트가 ASCII 인 것으로 가정</target>
        </trans-unit>
        <trans-unit id="657e33b27d387873c824a6e9282e0d4e22ed782e" translate="yes" xml:space="preserve">
          <source>Assuming the character set is just ASCII</source>
          <target state="translated">문자 집합이 ASCII라고 가정</target>
        </trans-unit>
        <trans-unit id="f18b4264a48b77c77d31682d53d915137b1c2a2b" translate="yes" xml:space="preserve">
          <source>Assuming the contents of static memory pointed to by the return values of Perl wrappers for C library functions doesn't change. Many C library functions return pointers to static storage that can be overwritten by subsequent calls to the same or related functions. Perl has light-weight wrappers for some of these functions, and which don't make copies of the static memory. A good example is the interface to the environment variables that are in effect for the program. Perl has &lt;code&gt;PerlEnv_getenv&lt;/code&gt; to get values from the environment. But the return is a pointer to static memory in the C library. If you are using the value to immediately test for something, that's fine, but if you save the value and expect it to be unchanged by later processing, you would be wrong, but perhaps you wouldn't know it because different C library implementations behave differently, and the one on the platform you're testing on might work for your situation. But on some platforms, a subsequent call to &lt;code&gt;PerlEnv_getenv&lt;/code&gt; or related function WILL overwrite the memory that your first call points to. This has led to some hard-to-debug problems. Do a &lt;a href=&quot;perlapi#savepv&quot;&gt;&quot;savepv&quot; in perlapi&lt;/a&gt; to make a copy, thus avoiding these problems. You will have to free the copy when you're done to avoid memory leaks. If you don't have control over when it gets freed, you'll need to make the copy in a mortal scalar, like so:</source>
          <target state="translated">C 라이브러리 함수에 대한 Perl 래퍼의 반환 값이 가리키는 정적 메모리의 내용이 변경되지 않는다고 가정합니다. 많은 C 라이브러리 함수는 동일한 또는 관련 함수에 대한 후속 호출로 덮어 쓸 수있는 정적 저장소에 대한 포인터를 반환합니다. Perl은 이러한 기능 중 일부를위한 경량 래퍼를 가지고 있으며 정적 메모리의 복사본을 만들지 않습니다. 좋은 예는 프로그램에 적용되는 환경 변수에 대한 인터페이스입니다. Perl에는 &lt;code&gt;PerlEnv_getenv&lt;/code&gt; 가 있습니다.환경에서 가치를 얻습니다. 그러나 반환은 C 라이브러리의 정적 메모리에 대한 포인터입니다. 값을 사용하여 무언가를 즉시 테스트하는 경우 괜찮지 만 값을 저장하고 나중에 처리해도 변경되지 않을 것으로 예상하면 잘못된 것이지만 다른 C 라이브러리 구현이 작동하기 때문에 알 수 없을 수도 있습니다. 다르게, 테스트중인 플랫폼의 플랫폼이 상황에 맞을 수 있습니다. 그러나 일부 플랫폼에서는 &lt;code&gt;PerlEnv_getenv&lt;/code&gt; 또는 관련 함수에 대한 후속 호출이 첫 번째 호출이 가리키는 메모리를 덮어 씁니다. 이로 인해 디버그하기 어려운 문제가 발생했습니다. &lt;a href=&quot;perlapi#savepv&quot;&gt;perlapi&lt;/a&gt; 에서 &quot;savepv&quot;수행복사하여 이러한 문제를 피할 수 있습니다. 메모리 누수를 방지하기 위해 작업이 끝나면 복사본을 해제해야합니다. ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ 해제시기를 제어 할 수없는 경우 다음과 같이 필사적 스칼라로 복사본을 만들어야합니다.</target>
        </trans-unit>
        <trans-unit id="7e0c2159a115b592c79f24b1d84f43c005948de3" translate="yes" xml:space="preserve">
          <source>Assuming the contents of static memory pointed to by the return values of Perl wrappers for C library functions doesn't change. Many C library functions return pointers to static storage that can be overwritten by subsequent calls to the same or related functions. Perl has light-weight wrappers for some of these functions, and which don't make copies of the static memory. A good example is the interface to the environment variables that are in effect for the program. Perl has &lt;code&gt;PerlEnv_getenv&lt;/code&gt; to get values from the environment. But the return is a pointer to static memory in the C library. If you are using the value to immediately test for something, that's fine, but if you save the value and expect it to be unchanged by later processing, you would be wrong, but perhaps you wouldn't know it because different C library implementations behave differently, and the one on the platform you're testing on might work for your situation. But on some platforms, a subsequent call to &lt;code&gt;PerlEnv_getenv&lt;/code&gt; or related function WILL overwrite the memory that your first call points to. This has led to some hard-to-debug problems. Do a &lt;a href=&quot;perlapi#savepv&quot;&gt;savepv in perlapi&lt;/a&gt; to make a copy, thus avoiding these problems. You will have to free the copy when you're done to avoid memory leaks. If you don't have control over when it gets freed, you'll need to make the copy in a mortal scalar, like so:</source>
          <target state="translated">C 라이브러리 함수에 대한 Perl 랩퍼의 리턴 값이 가리키는 정적 메모리의 내용이 변경되지 않는다고 가정하십시오. 많은 C 라이브러리 함수는 동일한 또는 관련 함수에 대한 후속 호출로 덮어 쓸 수있는 정적 스토리지에 대한 포인터를 리턴합니다. Perl에는 이러한 기능 중 일부를위한 경량 래퍼가 있으며 정적 메모리를 복사하지 않습니다. 좋은 예는 프로그램에 적용되는 환경 변수에 대한 인터페이스입니다. 펄은 &lt;code&gt;PerlEnv_getenv&lt;/code&gt; 를 있습니다환경으로부터 가치를 얻습니다. 그러나 리턴은 C 라이브러리의 정적 메모리에 대한 포인터입니다. 값을 사용하여 즉시 무언가를 테스트하는 경우 괜찮습니다. 그러나 값을 저장하고 나중에 처리해도 변경되지 않을 것으로 예상되는 경우 잘못된 것이지만 다른 C 라이브러리 구현이 작동하기 때문에 알 수 없을 것입니다 테스트하고있는 플랫폼의 플랫폼이 상황에 따라 작동 할 수 있습니다. 그러나 일부 플랫폼에서는 &lt;code&gt;PerlEnv_getenv&lt;/code&gt; 또는 관련 함수에 대한 후속 호출이 첫 번째 호출이 가리키는 메모리를 덮어 씁니다. 이로 인해 디버그하기 어려운 문제가 발생했습니다. 할&lt;a href=&quot;perlapi#savepv&quot;&gt; perlapi의 savepv을&lt;/a&gt;복사하여 이러한 문제를 피하십시오. 메모리 누수를 피하려면 복사를 해제해야합니다. 해제 될 때 제어 할 수 없으면 다음과 같이 필멸의 스칼라로 사본을 작성해야합니다.</target>
        </trans-unit>
        <trans-unit id="3368b5431ec704ea21f8185fe92770b3b042af71" translate="yes" xml:space="preserve">
          <source>Assuming the database from the previous example:</source>
          <target state="translated">이전 예제의 데이터베이스를 가정하면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="37f2465394b9cbdd91947c6e4e077a7d4b7dde8a" translate="yes" xml:space="preserve">
          <source>Assuming they are to behave analogously to Perl's &lt;code&gt;++&lt;/code&gt; and &lt;code&gt;--&lt;/code&gt; , overloaded implementations of these operators are required to mutate their operands.</source>
          <target state="translated">그들은 유사 펄에 행동이다 가정 &lt;code&gt;++&lt;/code&gt; 와 &lt;code&gt;--&lt;/code&gt; ,이 연산자의 오버로드 구현은 피연산자를 돌연변이해야합니다.</target>
        </trans-unit>
        <trans-unit id="3db726b30f88089aabcbf03ff0837b3e46de1fc1" translate="yes" xml:space="preserve">
          <source>Assuming they are to behave analogously to Perl's &lt;code&gt;++&lt;/code&gt; and &lt;code&gt;--&lt;/code&gt;, overloaded implementations of these operators are required to mutate their operands.</source>
          <target state="translated">Perl의 &lt;code&gt;++&lt;/code&gt; 및 &lt;code&gt;--&lt;/code&gt; 와 유사하게 동작한다고 가정하면 이러한 연산자의 오버로드 구현은 피연산자를 변경해야합니다.</target>
        </trans-unit>
        <trans-unit id="6c0a71c399dfe91f864d3abd9d93805888be04d4" translate="yes" xml:space="preserve">
          <source>Assuming we are on the branch &lt;code&gt;blead&lt;/code&gt; immediately after a pull, this command would be more or less equivalent to:</source>
          <target state="translated">당김 직후 브랜치 &lt;code&gt;blead&lt;/code&gt; 에 있다고 가정하면 이 명령은 다음과 거의 동일합니다.</target>
        </trans-unit>
        <trans-unit id="23383c34471c75b25927cfad7162ad1979bea49b" translate="yes" xml:space="preserve">
          <source>Assuming you call your class Projname::L10N, create a class consisting minimally of:</source>
          <target state="translated">Projname :: L10N 클래스를 호출한다고 가정하면 최소한으로 구성된 클래스를 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="a8c3ccec4be1ea177d36a955790696ae747518f7" translate="yes" xml:space="preserve">
          <source>Assuming you have good test coverage, your tests should fail with missing dependencies informing the user more strongly that something is wrong. You can write a</source>
          <target state="translated">테스트 범위가 양호하다고 가정하면 종속성이 누락되어 테스트에 실패하여 사용자에게 무언가 잘못되었음을 더 강력하게 알려줍니다. 당신은 쓸 수 있습니다</target>
        </trans-unit>
        <trans-unit id="562091b17215c5d2dabd5a6d27106f5a063623cd" translate="yes" xml:space="preserve">
          <source>Assuming you know you're dealing with a UTF-8 string, you can find out how long the first character in it is with the &lt;code&gt;UTF8SKIP&lt;/code&gt; macro:</source>
          <target state="translated">UTF-8 문자열을 다루고 있다고 가정하면 첫 번째 문자가 &lt;code&gt;UTF8SKIP&lt;/code&gt; 매크로 와 얼마나 긴지 알 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9da798a9d5da7f2f9d9ef9e1b52ebf21c8c17dc7" translate="yes" xml:space="preserve">
          <source>Assuming you're running under sufficient permissions, you should be able to set the system-wide date and time by running the &lt;code&gt;date(1)&lt;/code&gt; program. (There is no way to set the time and date on a per-process basis.) This mechanism will work for Unix, MS-DOS, Windows, and NT; the VMS equivalent is &lt;code&gt;set &lt;a href=&quot;functions/time&quot;&gt;time&lt;/a&gt;&lt;/code&gt; .</source>
          <target state="translated">충분한 권한으로 실행 중이라고 가정하면 &lt;code&gt;date(1)&lt;/code&gt; 프로그램 을 실행하여 시스템 전체 날짜 및 시간을 설정할 수 있어야합니다 . 프로세스별로 시간과 날짜를 설정할 수있는 방법은 없습니다.이 메커니즘은 Unix, MS-DOS, Windows 및 NT에서 작동합니다. VMS와 동등한 &lt;code&gt;set &lt;a href=&quot;functions/time&quot;&gt;time&lt;/a&gt;&lt;/code&gt; 이 설정 됩니다 .</target>
        </trans-unit>
        <trans-unit id="02ec0a4ff8284bf3708641e3963c674ad5d28a0e" translate="yes" xml:space="preserve">
          <source>Assuming you're running under sufficient permissions, you should be able to set the system-wide date and time by running the &lt;code&gt;date(1)&lt;/code&gt; program. (There is no way to set the time and date on a per-process basis.) This mechanism will work for Unix, MS-DOS, Windows, and NT; the VMS equivalent is &lt;code&gt;set time&lt;/code&gt;.</source>
          <target state="translated">충분한 권한으로 실행 중이라고 가정하면 &lt;code&gt;date(1)&lt;/code&gt; 프로그램 을 실행하여 시스템 전체의 날짜 및 시간을 설정할 수 있어야합니다 . (프로세스별로 시간과 날짜를 설정할 수있는 방법은 없습니다.)이 메커니즘은 Unix, MS-DOS, Windows 및 NT에서 작동합니다. VMS에 해당하는 값은 &lt;code&gt;set time&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="a50f834fa5c7b73ada293aca740d6156afc09752" translate="yes" xml:space="preserve">
          <source>Assuming your system supports such things, just send an appropriate signal to the process (see &lt;a href=&quot;functions/kill&quot;&gt;kill&lt;/a&gt;). It's common to first send a TERM signal, wait a little bit, and then send a KILL signal to finish it off.</source>
          <target state="translated">시스템이 그러한 것들을 지원한다고 가정하면 적절한 신호를 프로세스에 보내십시오 ( &lt;a href=&quot;functions/kill&quot;&gt;kill&lt;/a&gt; 참조 ). TERM 신호를 먼저 보내고 약간 기다린 다음 KILL 신호를 보내서 종료하는 것이 일반적입니다.</target>
        </trans-unit>
        <trans-unit id="a095cda27752254d76d70e270420e5ff5d39b90c" translate="yes" xml:space="preserve">
          <source>Assuming your system supports such things, just send an appropriate signal to the process (see &lt;a href=&quot;perlfunc#kill&quot;&gt;&quot;kill&quot; in perlfunc&lt;/a&gt;). It's common to first send a TERM signal, wait a little bit, and then send a KILL signal to finish it off.</source>
          <target state="translated">시스템이 이러한 기능을 지원한다고 가정하면 적절한 신호를 프로세스에 보내면됩니다 ( &lt;a href=&quot;perlfunc#kill&quot;&gt;perlfunc의 &quot;kill&quot;&lt;/a&gt; 참조 ). 먼저 TERM 신호를 보내고 조금 기다린 다음 KILL 신호를 보내서 종료하는 것이 일반적입니다.</target>
        </trans-unit>
        <trans-unit id="489e70109e67cf9da0e282567e7dfa75ecfec0d5" translate="yes" xml:space="preserve">
          <source>Asynchronous I/O.</source>
          <target state="translated">비동기 I / O.</target>
        </trans-unit>
        <trans-unit id="a34c6deba477e26d8810a3f5cd4114d33aa1e300" translate="yes" xml:space="preserve">
          <source>At 10:23, this function generates the 10th line of a data file; at 3:45 PM it generates the 15th line instead. By default, &lt;code&gt;Memoize&lt;/code&gt; will only see the $problem_type argument. To fix this, include the current hour in the normalizer:</source>
          <target state="translated">10:23에서이 함수는 데이터 파일의 10 번째 줄을 생성합니다. 오후 3시 45 분에 대신 15 번째 줄을 생성합니다. 기본적으로 &lt;code&gt;Memoize&lt;/code&gt; 에는 $ problem_type 인수 만 표시됩니다. 이 문제를 해결하려면 노멀 라이저에 현재 시간을 포함 시키십시오.</target>
        </trans-unit>
        <trans-unit id="0d3035d43f34a8f68a2af535ff4afe837cc1bf23" translate="yes" xml:space="preserve">
          <source>At a given character position, the first alternative that allows the regex match to succeed will be the one that matches. Here, all the alternatives match at the first string position, so the first matches.</source>
          <target state="translated">주어진 문자 위치에서 정규 표현식 일치를 허용하는 첫 번째 대안이 일치하는 것입니다. 여기에서 모든 대안은 첫 번째 문자열 위치에서 일치하므로 첫 번째 문자열이 일치합니다.</target>
        </trans-unit>
        <trans-unit id="35d56b3c766a2a7d81a6ef179791e69c5926ffe4" translate="yes" xml:space="preserve">
          <source>At any given time, exactly one of these modifiers is in effect. Their existence allows Perl to keep the originally compiled behavior of a regular expression, regardless of what rules are in effect when it is actually executed. And if it is interpolated into a larger regex, the original's rules continue to apply to it, and don't affect the other parts.</source>
          <target state="translated">주어진 시간에이 수정 자 중 정확히 하나가 적용됩니다. 이들의 존재를 통해 Perl은 실제로 실행될 때 어떤 규칙이 적용되는지에 관계없이 정규식의 원래 컴파일 된 동작을 유지할 수 있습니다. 그리고 더 큰 정규식으로 보간되면 원본의 규칙이 계속 적용되고 다른 부분에는 영향을주지 않습니다.</target>
        </trans-unit>
        <trans-unit id="fa1efd2d4349c6ea79b9b9fc2089c111f8b1ca40" translate="yes" xml:space="preserve">
          <source>At any given time, exactly one of these modifiers is in effect. Their existence allows Perl to keep the originally compiled behavior of a regular expression, regardless of what rules are in effect when it is actually executed. And if it is interpolated into a larger regex, the original's rules continue to apply to it, and only it.</source>
          <target state="translated">주어진 시간에 이러한 수정 자 중 정확히 하나가 적용됩니다. 이것의 존재로 인해 Perl은 실제로 실행될 때 어떤 규칙이 적용되는지에 관계없이 정규식의 원래 컴파일 된 동작을 유지할 수 있습니다. 그리고 더 큰 정규식으로 보간되면 원본의 규칙이 계속 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="7593f9fb00e51f006212d276b2834d5cb1e7bd4c" translate="yes" xml:space="preserve">
          <source>At any rate, the very use of &lt;code&gt;&lt;a href=&quot;functions/format&quot;&gt;format&lt;/a&gt;&lt;/code&gt; is questionable when it comes to unicode characters since you have to consider such things as character width (i.e. double-width for ideographs) and directions (i.e. BIDI for Arabic and Hebrew).</source>
          <target state="translated">여하튼, &lt;code&gt;&lt;a href=&quot;functions/format&quot;&gt;format&lt;/a&gt;&lt;/code&gt; 의 사용 문자 너비 (아이디어 그래프의 경우 두 배 너비) 및 방향 (예 : 아랍어 및 히브리어의 경우 BIDI)과 같은 항목을 고려해야하기 때문에 유니 코드 문자의 경우 것은 의문의 여지가 있습니다.</target>
        </trans-unit>
        <trans-unit id="b3d5fa45c550ce1b12a041713732b9ad3afd79b2" translate="yes" xml:space="preserve">
          <source>At any rate, the very use of &lt;code&gt;format&lt;/code&gt; is questionable when it comes to unicode characters since you have to consider such things as character width (i.e. double-width for ideographs) and directions (i.e. BIDI for Arabic and Hebrew).</source>
          <target state="translated">여하튼, 유니 코드 문자의 경우 문자 너비 (예 : 표의 문자의 경우 이중 너비) 및 방향 (예 : 아랍어 및 히브리어의 경우 BIDI)과 같은 사항을 고려해야하기 때문에 &lt;code&gt;format&lt;/code&gt; 의 사용 자체 가 의심 스럽 습니다.</target>
        </trans-unit>
        <trans-unit id="40530b4cf9ab5b3f6391788f6f588ae031f72498" translate="yes" xml:space="preserve">
          <source>At deserialization time, you will be given back the same LIST, but all the extra references will be pointing into the deserialized structure.</source>
          <target state="translated">직렬화 해제시 동일한 LIST가 다시 제공되지만 모든 추가 참조는 직렬화 해제 구조를 가리 킵니다.</target>
        </trans-unit>
        <trans-unit id="2359fa76d13a340de35eda7f896e38293fc5d5aa" translate="yes" xml:space="preserve">
          <source>At each stack level, the subroutine's name is displayed along with its parameters. For simple scalars, this is sufficient. For complex data types, such as objects and other references, this can simply display &lt;code&gt;'HASH(0x1ab36d8)'&lt;/code&gt; .</source>
          <target state="translated">각 스택 레벨에서 서브 루틴의 이름이 매개 변수와 함께 표시됩니다. 간단한 스칼라의 경우 이것으로 충분합니다. 객체 및 기타 참조와 같은 복잡한 데이터 유형의 경우 단순히 &lt;code&gt;'HASH(0x1ab36d8)'&lt;/code&gt; 표시 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d3499c5b318f8c7ae1f2cab230c6e5e96c7a777c" translate="yes" xml:space="preserve">
          <source>At each stack level, the subroutine's name is displayed along with its parameters. For simple scalars, this is sufficient. For complex data types, such as objects and other references, this can simply display &lt;code&gt;'HASH(0x1ab36d8)'&lt;/code&gt;.</source>
          <target state="translated">각 스택 레벨에서 서브 루틴의 이름이 매개 변수와 함께 표시됩니다. 단순 스칼라의 경우 이것으로 충분합니다. 객체 및 기타 참조와 같은 복잡한 데이터 유형의 경우 단순히 &lt;code&gt;'HASH(0x1ab36d8)'&lt;/code&gt; 를 표시 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="396433f01b9bc30bd1dc987a608f2db8a7b54ded" translate="yes" xml:space="preserve">
          <source>At entry points to perl, such as &lt;code&gt;perl_parse()&lt;/code&gt; , &lt;code&gt;perl_run()&lt;/code&gt; and &lt;code&gt;call_sv(cv, G_EVAL)&lt;/code&gt; each does a &lt;code&gt;JMPENV_PUSH&lt;/code&gt; , then enter a runops loop or whatever, and handle possible exception returns. For a 2 return, final cleanup is performed, such as popping stacks and calling &lt;code&gt;CHECK&lt;/code&gt; or &lt;code&gt;END&lt;/code&gt; blocks. Amongst other things, this is how scope cleanup still occurs during an &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;perl_parse()&lt;/code&gt; , &lt;code&gt;perl_run()&lt;/code&gt; 및 &lt;code&gt;call_sv(cv, G_EVAL)&lt;/code&gt; 과 같이 perl의 진입 점에서 각각 &lt;code&gt;JMPENV_PUSH&lt;/code&gt; 를 수행 한 다음 runops 루프 또는 기타를 입력하고 가능한 예외 리턴을 처리합니다. 2 리턴의 경우 스택 팝핑 및 &lt;code&gt;CHECK&lt;/code&gt; 또는 &lt;code&gt;END&lt;/code&gt; 블록 호출과 같은 최종 정리가 수행 됩니다. 무엇보다도 &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit&lt;/a&gt;&lt;/code&gt; 중에 스코프 정리가 여전히 발생하는 방식 입니다.</target>
        </trans-unit>
        <trans-unit id="2c5843723152f1754465e406a2b90b574561ffc4" translate="yes" xml:space="preserve">
          <source>At entry points to perl, such as &lt;code&gt;perl_parse()&lt;/code&gt;, &lt;code&gt;perl_run()&lt;/code&gt; and &lt;code&gt;call_sv(cv, G_EVAL)&lt;/code&gt; each does a &lt;code&gt;JMPENV_PUSH&lt;/code&gt;, then enter a runops loop or whatever, and handle possible exception returns. For a 2 return, final cleanup is performed, such as popping stacks and calling &lt;code&gt;CHECK&lt;/code&gt; or &lt;code&gt;END&lt;/code&gt; blocks. Amongst other things, this is how scope cleanup still occurs during an &lt;code&gt;exit&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;perl_parse()&lt;/code&gt; , &lt;code&gt;perl_run()&lt;/code&gt; 및 &lt;code&gt;call_sv(cv, G_EVAL)&lt;/code&gt; 과 같은 perl의 진입 점에서 각각 &lt;code&gt;JMPENV_PUSH&lt;/code&gt; 를 수행 한 다음 runops 루프 등을 입력하고 가능한 예외 반환을 처리합니다. 2 반환의 경우 스택을 팝하고 &lt;code&gt;CHECK&lt;/code&gt; 또는 &lt;code&gt;END&lt;/code&gt; 블록을 호출하는 것과 같은 최종 정리가 수행 됩니다. 무엇보다도 이것이 &lt;code&gt;exit&lt;/code&gt; 중에 여전히 범위 정리가 발생하는 방식 입니다.</target>
        </trans-unit>
        <trans-unit id="3b52a6611c3d532a492a587178e19cf7d8fea481" translate="yes" xml:space="preserve">
          <source>At first glance, you'd think that it shouldn't print, because obviously the &lt;code&gt;ddd&lt;/code&gt; isn't going to match the target string. But look at this example:</source>
          <target state="translated">언뜻보기에는 &lt;code&gt;ddd&lt;/code&gt; 가 대상 문자열과 일치하지 않기 때문에 인쇄하지 않아야한다고 생각할 것입니다 . 그러나이 예를보십시오 :</target>
        </trans-unit>
        <trans-unit id="a20d2e5d0ab73a1c97b3463749bc6385228a9028" translate="yes" xml:space="preserve">
          <source>At least for consistency with WinNT, you should keep the recommended value.</source>
          <target state="translated">최소한 WinNT와 일관성을 유지하려면 권장 값을 유지해야합니다.</target>
        </trans-unit>
        <trans-unit id="27bd45d9389cf551091228f338420922ea6613d9" translate="yes" xml:space="preserve">
          <source>At least in Unix you may be able to get past this by increasing your process datasize limits: in csh/tcsh use &lt;code&gt;limit&lt;/code&gt; and &lt;code&gt;limit datasize n&lt;/code&gt; (where &lt;code&gt;n&lt;/code&gt; is the number of kilobytes) to check the current limits and change them, and in ksh/bash/zsh use &lt;code&gt;ulimit -a&lt;/code&gt; and &lt;code&gt;ulimit -d n&lt;/code&gt; , respectively.</source>
          <target state="translated">적어도 유닉스에서는 프로세스 데이터 크기 제한을 늘려서 이것을 극복 할 수 있습니다 : csh / tcsh 사용 &lt;code&gt;limit&lt;/code&gt; 및 &lt;code&gt;limit datasize n&lt;/code&gt; (여기서 &lt;code&gt;n&lt;/code&gt; 은 킬로바이트 수) 및 현재 제한을 확인하고 변경하십시오. / bash / zsh는 각각 &lt;code&gt;ulimit -a&lt;/code&gt; 및 &lt;code&gt;ulimit -d n&lt;/code&gt; 사용 합니다.</target>
        </trans-unit>
        <trans-unit id="66f7b8a4f3dad67cd26cb07eaab73c32a3b79d31" translate="yes" xml:space="preserve">
          <source>At least in Unix you may be able to get past this by increasing your process datasize limits: in csh/tcsh use &lt;code&gt;limit&lt;/code&gt; and &lt;code&gt;limit datasize n&lt;/code&gt; (where &lt;code&gt;n&lt;/code&gt; is the number of kilobytes) to check the current limits and change them, and in ksh/bash/zsh use &lt;code&gt;ulimit -a&lt;/code&gt; and &lt;code&gt;ulimit -d n&lt;/code&gt;, respectively.</source>
          <target state="translated">적어도 Unix에서는 프로세스 데이터 크기 제한을 늘려서이 문제를 극복 할 수 있습니다. csh / tcsh에서는 &lt;code&gt;limit&lt;/code&gt; 및 &lt;code&gt;limit datasize n&lt;/code&gt; (여기서 &lt;code&gt;n&lt;/code&gt; 은 킬로바이트 수)을 사용하여 현재 제한을 확인하고 변경하고 ksh에서 변경할 수 있습니다. / bash / zsh는 각각 &lt;code&gt;ulimit -a&lt;/code&gt; 및 &lt;code&gt;ulimit -d n&lt;/code&gt; 사용 합니다.</target>
        </trans-unit>
        <trans-unit id="be275e2a07874324b642ea6224748e1cc7c92b91" translate="yes" xml:space="preserve">
          <source>At least it's backwards compatible in not doing much.</source>
          <target state="translated">적어도 많이하지 않으면 역 호환성이 있습니다.</target>
        </trans-unit>
        <trans-unit id="9e14e0bb06602e8d806ecd5603df3d1331d55d06" translate="yes" xml:space="preserve">
          <source>At least one of &lt;code&gt;s1&lt;/code&gt; and &lt;code&gt;s2&lt;/code&gt; must have a goal (at least one of &lt;code&gt;l1&lt;/code&gt; and &lt;code&gt;l2&lt;/code&gt; must be non-zero), and if both do, both have to be reached for a successful match. Also, if the fold of a character is multiple characters, all of them must be matched (see tr21 reference below for 'folding').</source>
          <target state="translated">&lt;code&gt;s1&lt;/code&gt; 및 &lt;code&gt;s2&lt;/code&gt; 중 하나 이상 에 목표가 있어야하며 ( &lt;code&gt;l1&lt;/code&gt; 및 &lt;code&gt;l2&lt;/code&gt; 중 하나 이상 이 0이 아니어야 함) 두 목표가 모두 일치해야 성공적으로 일치합니다. 또한 문자의 접힘이 여러 문자 인 경우 모든 문자가 일치해야합니다 ( '접기'에 대해서는 아래 tr21 참조 참조).</target>
        </trans-unit>
        <trans-unit id="9972c1cfc00f54bc3d4bf6854c0d9453527f2493" translate="yes" xml:space="preserve">
          <source>At least the three builtin functions &lt;code&gt;&lt;a href=&quot;functions/defined&quot;&gt;defined(...)&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/exists&quot;&gt;exists(...)&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof(...)&lt;/a&gt;&lt;/code&gt;. We might someday add more of these later if we think of them.</source>
          <target state="translated">편입 함수 세 적어도 &lt;code&gt;&lt;a href=&quot;functions/defined&quot;&gt;defined(...)&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/exists&quot;&gt;exists(...)&lt;/a&gt;&lt;/code&gt; 하고, &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof(...)&lt;/a&gt;&lt;/code&gt; . 우리가 언젠가 그것들을 생각한다면 이것들을 더 추가 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="36309277752b244d6584b5ffd8f2594deef16e94" translate="yes" xml:space="preserve">
          <source>At least the three builtin functions &lt;code&gt;defined(...)&lt;/code&gt;, &lt;code&gt;exists(...)&lt;/code&gt;, and &lt;code&gt;eof(...)&lt;/code&gt;. We might someday add more of these later if we think of them.</source>
          <target state="translated">최소한 세 개의 내장 함수 &lt;code&gt;defined(...)&lt;/code&gt; , &lt;code&gt;exists(...)&lt;/code&gt; 및 &lt;code&gt;eof(...)&lt;/code&gt; . 나중에 생각하면 나중에 더 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dc8bf4c3c86adf3ceb8a466491ba399fbc2b4c86" translate="yes" xml:space="preserve">
          <source>At line number 4 is a helpful pointer, that tells you where you are now. To see more code, type 'v' again:</source>
          <target state="translated">4 번 줄에는 현재 위치를 알려주는 유용한 포인터가 있습니다. 더 많은 코드를 보려면 'v'를 다시 입력하십시오.</target>
        </trans-unit>
        <trans-unit id="0f8b916c14aa42230cca14b7fbe9aee5db398694" translate="yes" xml:space="preserve">
          <source>At one time, it was legal in some standards to have code points up to 0x7FFF_FFFF, but not higher, and this code point is higher.</source>
          <target state="translated">한때 일부 표준에서는 최대 0x7FFF_FFFF까지의 코드 포인트를 갖는 것이 합법적 이었지만 더 높지는 않았으며이 코드 포인트는 더 높습니다.</target>
        </trans-unit>
        <trans-unit id="3706bce960e08579e2a93b26085ef7458b3bba0d" translate="yes" xml:space="preserve">
          <source>At present that list is: weaken, isweak, dualvar, isvstring, set_prototype</source>
          <target state="translated">현재이 목록은 약화, 약화, 이중 변수, isvstring, set_prototype입니다.</target>
        </trans-unit>
        <trans-unit id="945b483b1ccbe65e925900ec39e83bbc97a9ab8a" translate="yes" xml:space="preserve">
          <source>At present the following compression methods are supported by IO::Compress::Zip, namely Store (no compression at all), Deflate, Bzip2 and LZMA.</source>
          <target state="translated">현재 다음 압축 방법은 IO :: Compress :: Zip, 즉 Store (아무 압축 없음), Deflate, Bzip2 및 LZMA에서 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="a9a7ccc891020b1abe97ef7e238b5077a99ae99b" translate="yes" xml:space="preserve">
          <source>At present three compression methods are supported by IO::Compress::Zip, namely Store (no compression at all), Deflate, Bzip2 and LZMA.</source>
          <target state="translated">현재 IO :: Compress :: Zip, 즉 Store (압축 없음), Deflate, Bzip2 및 LZMA의 세 가지 압축 방법이 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="c6f3b56326d807044d12f7fa90b19c7ea2469f7b" translate="yes" xml:space="preserve">
          <source>At present, the first time you iterate over %ENV using &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;functions/values&quot;&gt;values&lt;/a&gt;&lt;/code&gt;, you will incur a time penalty as all logical names are read, in order to fully populate %ENV. Subsequent iterations will not reread logical names, so they won't be as slow, but they also won't reflect any changes to logical name tables caused by other programs.</source>
          <target state="translated">현재 &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;functions/values&quot;&gt;values&lt;/a&gt;&lt;/code&gt; 를 사용하여 % ENV를 처음 반복 할 때, % ENV를 완전히 채우려면 모든 논리적 이름을 읽을 때 시간 패널티가 발생합니다. 후속 반복은 논리적 이름을 다시 읽지 않으므로 느리지는 않지만 다른 프로그램으로 인한 논리적 이름 테이블의 변경 사항은 반영하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="214ce8ba80d0a179d1db87f227b4915a835aed62" translate="yes" xml:space="preserve">
          <source>At present, the first time you iterate over %ENV using &lt;code&gt;keys&lt;/code&gt;, or &lt;code&gt;values&lt;/code&gt;, you will incur a time penalty as all logical names are read, in order to fully populate %ENV. Subsequent iterations will not reread logical names, so they won't be as slow, but they also won't reflect any changes to logical name tables caused by other programs.</source>
          <target state="translated">현재 &lt;code&gt;keys&lt;/code&gt; 또는 &lt;code&gt;values&lt;/code&gt; 사용하여 % ENV를 처음으로 반복하면 % ENV 를 완전히 채우기 위해 모든 논리 이름을 읽을 때 시간 패널티가 발생합니다. 후속 반복은 논리적 이름을 다시 읽지 않으므로 느리지는 않지만 다른 프로그램으로 인한 논리적 이름 테이블의 변경 사항도 반영하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="25d8707372413087d65e69b61d9a6dc703b71cf2" translate="yes" xml:space="preserve">
          <source>At run time, each listed plugin is instantiated as a singleton object by running the equivalent of this pseudo code:</source>
          <target state="translated">런타임에 나열된 각 플러그인은 다음 의사 코드와 동일한 기능을 실행하여 단일 객체로 인스턴스화됩니다.</target>
        </trans-unit>
        <trans-unit id="0346a8b0d676351a6882db32e2f71fe2cd6612af" translate="yes" xml:space="preserve">
          <source>At run-time you can use:</source>
          <target state="translated">런타임시 다음을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="14c311a97bb302da658b5d5c146d94913481c6a7" translate="yes" xml:space="preserve">
          <source>At some moment the built may die, reporting a</source>
          <target state="translated">언젠가 빌드가 죽을 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="fdde3eae592d85a1bbf81dc1dcb5f03f478df9d3" translate="yes" xml:space="preserve">
          <source>At the 2008 QA Hackathon in Oslo, Perl module toolchain maintainers agreed to use the CPAN Meta format to communicate post-configuration requirements between toolchain components. These files,</source>
          <target state="translated">오슬로에서 열린 2008 QA Hackathon에서 Perl 모듈 도구 체인 관리자는 CPAN Meta 형식을 사용하여 도구 체인 구성 요소간에 사후 구성 요구 사항을 전달하는 데 동의했습니다. 이 파일들,</target>
        </trans-unit>
        <trans-unit id="8f94eca0c2d56d19683ad85c3b3f54fed0ab0893" translate="yes" xml:space="preserve">
          <source>At the 2008 QA Hackathon in Oslo, Perl module toolchain maintainers agrees to use the CPAN Meta format to communicate post-configuration requirements between toolchain components. These files,</source>
          <target state="translated">Oslo의 2008 QA Hackathon에서 Perl 모듈 툴체인 관리자는 CPAN 메타 형식을 사용하여 툴체인 구성 요소간에 구성 후 요구 사항을 전달하는 데 동의합니다. 이 파일들은</target>
        </trans-unit>
        <trans-unit id="86950d72bad1114392fd499fea36a75e7faf16d6" translate="yes" xml:space="preserve">
          <source>At the cost of a slight header overhead, you may store to an already opened file descriptor using the &lt;code&gt;store_fd&lt;/code&gt; routine, and retrieve from a file via &lt;code&gt;fd_retrieve&lt;/code&gt; . Those names aren't imported by default, so you will have to do that explicitly if you need those routines. The file descriptor you supply must be already opened, for read if you're going to retrieve and for write if you wish to store.</source>
          <target state="translated">약간의 헤더 오버 헤드 비용에서, 당신은 사용하여 이미 열려있는 파일 기술자에 저장할 수 &lt;code&gt;store_fd&lt;/code&gt; 의 루틴을, 그리고를 통해 파일에서 검색 &lt;code&gt;fd_retrieve&lt;/code&gt; . 이러한 이름은 기본적으로 가져 오지 않으므로 해당 루틴이 필요한 경우 명시 적으로 지정해야합니다. 제공하려는 파일 디스크립터는 이미 열람해야합니다. 검색하려는 경우 읽기 및 저장하려는 경우 쓰기를 위해.</target>
        </trans-unit>
        <trans-unit id="e5ffbd456858663ac301bf7789eac1b059f62c98" translate="yes" xml:space="preserve">
          <source>At the cost of a slight header overhead, you may store to an already opened file descriptor using the &lt;code&gt;store_fd&lt;/code&gt; routine, and retrieve from a file via &lt;code&gt;fd_retrieve&lt;/code&gt;. Those names aren't imported by default, so you will have to do that explicitly if you need those routines. The file descriptor you supply must be already opened, for read if you're going to retrieve and for write if you wish to store.</source>
          <target state="translated">약간의 헤더 오버 헤드 비용에서, 당신은 사용하여 이미 열려있는 파일 기술자에 저장할 수 &lt;code&gt;store_fd&lt;/code&gt; 의 루틴을, 그리고를 통해 파일에서 검색 &lt;code&gt;fd_retrieve&lt;/code&gt; . 이러한 이름은 기본적으로 가져 오지 않으므로 해당 루틴이 필요한 경우 명시 적으로 수행해야합니다. 제공하는 파일 설명자는 검색하려는 경우 읽기 용으로, 저장하려는 경우 쓰기 용으로 이미 열려 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="5655f269f9dae667811a30ef2f8f926fc9530ad6" translate="yes" xml:space="preserve">
          <source>At the end of</source>
          <target state="translated">끝에</target>
        </trans-unit>
        <trans-unit id="9572ac86c1b1da5c7ab83dd35ce00912ee7e613d" translate="yes" xml:space="preserve">
          <source>At the end of all &lt;code&gt;when&lt;/code&gt; blocks, there is an implicit &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt;. You can override that with an explicit &lt;code&gt;&lt;a href=&quot;functions/last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; if you're interested in only the first match alone.</source>
          <target state="translated">모든 &lt;code&gt;when&lt;/code&gt; 블록 의 끝에는 암시적인 &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; 가 있습니다. 첫 번째 경기에만 관심이 있다면 명시적인 &lt;code&gt;&lt;a href=&quot;functions/last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; 으로 덮어 쓸 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1e41ae8e63f613457fbc688a05901eda0e76d2fb" translate="yes" xml:space="preserve">
          <source>At the end of all &lt;code&gt;when&lt;/code&gt; blocks, there is an implicit &lt;code&gt;next&lt;/code&gt;. You can override that with an explicit &lt;code&gt;last&lt;/code&gt; if you're interested in only the first match alone.</source>
          <target state="translated">모든 &lt;code&gt;when&lt;/code&gt; 블록 의 끝에는 암시 적 &lt;code&gt;next&lt;/code&gt; 가 있습니다. 첫 번째 일치에만 관심이있는 경우 명시적인 &lt;code&gt;last&lt;/code&gt; 으로 재정의 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ca6a702d6cdcdadecdbaeb43444eca515cc146c7" translate="yes" xml:space="preserve">
          <source>At the end of the parse, call &lt;code&gt;$parser-&amp;gt;root&lt;/code&gt; to get the tree's top node.</source>
          <target state="translated">구문 분석이 끝나면 &lt;code&gt;$parser-&amp;gt;root&lt;/code&gt; 를 호출 하여 트리의 최상위 노드를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="7dfefef1d68ca5b408b29dae9e3fff68c7b274a2" translate="yes" xml:space="preserve">
          <source>At the end of the subtest, the final &lt;a href=&quot;Test2::Event::Subtest&quot;&gt;Test2::Event::Subtest&lt;/a&gt; event is sent to the formatter.</source>
          <target state="translated">하위 테스트가 끝나면 최종 &lt;a href=&quot;Test2::Event::Subtest&quot;&gt;Test2 :: Event :: Subtest&lt;/a&gt; 이벤트가 포맷터로 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="07a9cc69765068861817ec41e4a7228bd113195b" translate="yes" xml:space="preserve">
          <source>At the lowest level, the macros new_SV() and del_SV() grab and free an SV head. (If debugging with -DD, del_SV() calls the function S_del_sv() to return the SV to the free list with error checking.) new_SV() calls more_sv() / sv_add_arena() to add an extra arena if the free list is empty. SVs in the free list have their SvTYPE field set to all ones.</source>
          <target state="translated">가장 낮은 수준에서 매크로 new_SV () 및 del_SV ()는 SV 헤드를 잡고 해제합니다. (-DD로 디버깅하는 경우 del_SV ()는 S_del_sv () 함수를 호출하여 SV를 오류 검사와 함께 사용 가능한 목록으로 리턴합니다.) new_SV ()는 more_sv () / sv_add_arena ()를 호출하여 사용 가능한 목록이있는 경우 추가 아레나를 추가합니다 빈. 비어있는 목록의 SV는 SvTYPE 필드가 모두 1로 설정되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="6089cbc08fb43732445842a261366b161cee7872" translate="yes" xml:space="preserve">
          <source>At the moment of writing, AIX supports two different native C compilers, for which you have to pay: &lt;b&gt;xlC&lt;/b&gt; and &lt;b&gt;vac&lt;/b&gt;. If you decide to use either of these two (which is quite a lot easier than using gcc), be sure to upgrade to the latest available patch level. Currently:</source>
          <target state="translated">글을 쓰는 시점에서 AIX는 &lt;b&gt;xlC&lt;/b&gt; 와 &lt;b&gt;vac의&lt;/b&gt; 두 가지 다른 네이티브 C 컴파일러를 지원합니다 . 이 두 가지 중 하나를 사용하기로 결정한 경우 (gcc를 사용하는 것보다 훨씬 쉽습니다) 사용 가능한 최신 패치 수준으로 업그레이드하십시오. 현재 :</target>
        </trans-unit>
        <trans-unit id="af7b9b33fafaf83f9420acb89bb16618e9123d52" translate="yes" xml:space="preserve">
          <source>At the risk of stating the obvious, modules are intended to be modular. A Perl developer should be able to use modules to put together the building blocks of their application. However, it's important that the blocks are the right shape, and that the developer shouldn't have to use a big block when all they need is a small one.</source>
          <target state="translated">명백한 내용을 표시 할 위험이있는 모듈은 모듈 식입니다. Perl 개발자는 모듈을 사용하여 애플리케이션의 빌딩 블록을 구성 할 수 있어야합니다. 그러나 블록이 올바른 모양이어야하고 개발자가 필요로하는 모든 것이 작은 블록 일 때 큰 블록을 사용할 필요가 없어야합니다.</target>
        </trans-unit>
        <trans-unit id="1014d039b0716d418675db8cd3420cc810aff463" translate="yes" xml:space="preserve">
          <source>At the same time, this pragma cannot detect when such a module has installed from CPAN to the core library, and so it would endlessly and uselessly exhort the user to upgrade.</source>
          <target state="translated">동시에,이 pragma는 그러한 모듈이 CPAN에서 코어 라이브러리로 언제 설치되었는지 감지 할 수 없으므로 사용자에게 업그레이드를 끝없이 쓸모없이 촉구합니다.</target>
        </trans-unit>
        <trans-unit id="d2c548d72452435d78a5e713661472ad87fa3347" translate="yes" xml:space="preserve">
          <source>At the time of this writing (2009-03) there are three YAML implementations working: YAML, YAML::Syck, and YAML::XS. The latter two are faster but need a C compiler installed on your system. There may be more alternative YAML conforming modules. When I tried two other players, YAML::Tiny and YAML::Perl, they seemed not powerful enough to work with CPAN.pm. This may have changed in the meantime.</source>
          <target state="translated">이 글을 쓰는 시점 (2009-03)에는 YAML, YAML :: Syck 및 YAML :: XS의 세 가지 YAML 구현이 작동합니다. 후자는 빠르지 만 시스템에 C 컴파일러가 설치되어 있어야합니다. 대체 YAML 준수 모듈이있을 수 있습니다. 다른 두 명의 플레이어 인 YAML :: Tiny와 YAML :: Perl을 시도했을 때 CPAN.pm을 사용할 수있을만큼 강력하지 않은 것 같습니다. 그 동안 변경되었을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7ea634c02baa48b31e81ed3a00831f7dcbb2e678" translate="yes" xml:space="preserve">
          <source>At the time of this writing (June 2002), there is a known bug in the Tru64 libc printing of long doubles when not using &quot;e&quot; notation. The values are correct and usable, but you only get a limited number of digits displayed unless you force the issue by using &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf&lt;/a&gt;
&quot;%.33e&quot;,$num&lt;/code&gt; or the like. For Tru64 versions V5.0A through V5.1A, a patch is expected sometime after perl 5.8.0 is released. If your libc has not yet been patched, you'll get a warning from Configure when selecting long doubles.</source>
          <target state="translated">이 글을 쓰는 시점 (2002 년 6 월)에는 &quot;e&quot;표기법을 사용하지 않을 때 Tru64 libc 인쇄에서 long doubles의 알려진 버그가 있습니다. 값은 정확하고 사용 가능하지만 &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf&lt;/a&gt; &quot;%.33e&quot;,$num&lt;/code&gt; 를 사용하여 문제를 강제하지 않으면 제한된 숫자 만 표시됩니다. &quot;% .33e&quot;, $ num 등 . Tru64 버전 V5.0A에서 V5.1A의 경우 perl 5.8.0이 릴리스 된 후 언젠가 패치가 예상됩니다. libc가 아직 패치되지 않은 경우 long doubles를 선택할 때 Configure에서 경고가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="cff077ec447ff4f924a23e0da4a7a4062c468c7a" translate="yes" xml:space="preserve">
          <source>At the time of this writing (June 2002), there is a known bug in the Tru64 libc printing of long doubles when not using &quot;e&quot; notation. The values are correct and usable, but you only get a limited number of digits displayed unless you force the issue by using &lt;code&gt;printf &quot;%.33e&quot;,$num&lt;/code&gt; or the like. For Tru64 versions V5.0A through V5.1A, a patch is expected sometime after perl 5.8.0 is released. If your libc has not yet been patched, you'll get a warning from Configure when selecting long doubles.</source>
          <target state="translated">이 글을 쓰는 시점 (2002 년 6 월), &quot;e&quot;표기법을 사용하지 않을 때 long double의 Tru64 libc 인쇄에 알려진 버그가 있습니다. 값은 정확하고 사용할 수 있지만 &lt;code&gt;printf &quot;%.33e&quot;,$num&lt;/code&gt; 을 사용하여 문제를 강제하지 않는 한 제한된 숫자 만 표시됩니다 . Tru64 버전 V5.0A에서 V5.1A까지의 경우, perl 5.8.0이 출시 된 후 언젠가 패치가 예상됩니다. libc가 아직 패치되지 않은 경우 long double을 선택할 때 Configure에서 경고가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="1867a801fe6f9af5a7aceadb824f2be69014eb61" translate="yes" xml:space="preserve">
          <source>At the time of this writing, Perl 5.18.0 is considered to be well-hardened against algorithmic complexity attacks on its hash implementation. This is largely owed to the following measures mitigate attacks:</source>
          <target state="translated">이 글을 쓰는 시점에서 Perl 5.18.0은 해시 구현에 대한 알고리즘 복잡성 공격에 대해 잘 강화 된 것으로 간주됩니다. 이것은 주로 다음과 같은 조치로 인해 공격이 완화됩니다.</target>
        </trans-unit>
        <trans-unit id="8a33c676d1f79e763827316ea86000a157f0da7a" translate="yes" xml:space="preserve">
          <source>At the time of very final cleanup, sv_free_arenas() is called from perl_destruct() to physically free all the arenas allocated since the start of the interpreter.</source>
          <target state="translated">최종 정리시, perl_destruct ()에서 sv_free_arenas ()가 호출되어 인터프리터가 시작된 이후 할당 된 모든 경기장을 물리적으로 해제합니다.</target>
        </trans-unit>
        <trans-unit id="4ad7685293e30733157e0b0115df9c2bbc818321" translate="yes" xml:space="preserve">
          <source>At the time that f is created, it can't capture the current &quot;a&quot; sub, since the anonymous subroutine hasn't been created yet. Conversely, the following won't give a warning since the anonymous subroutine has by now been created and is live:</source>
          <target state="translated">익명 서브 루틴이 아직 작성되지 않았으므로 f가 작성 될 때 현재 &quot;a&quot;서브를 캡처 할 수 없습니다. 반대로, 익명 서브 루틴이 작성되어 활성화되었으므로 다음은 경고를 표시하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c7f753fb79bacf696f44e6edc3ce403746b9d93b" translate="yes" xml:space="preserve">
          <source>At the time that f is created, it can't capture the current value of $a, since the anonymous subroutine hasn't been created yet. Conversely, the following won't give a warning since the anonymous subroutine has by now been created and is live:</source>
          <target state="translated">익명 서브 루틴이 아직 작성되지 않았으므로 f가 작성 될 때 현재 값 $ a를 캡처 할 수 없습니다. 반대로, 익명 서브 루틴이 작성되어 현재 활성화되었으므로 다음은 경고를 표시하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9d72f28fef349b76a0adf7f5f7156e5e3f38d89f" translate="yes" xml:space="preserve">
          <source>At the time this document was last updated, Cygwin 1.7.16 was current.</source>
          <target state="translated">이 문서가 마지막으로 업데이트 될 당시 Cygwin 1.7.16이 최신 버전입니다.</target>
        </trans-unit>
        <trans-unit id="568132008f8ee29811084c20ba8f801b1aedb463" translate="yes" xml:space="preserve">
          <source>At the very least, this is useful to see what the SelfLoader thinks are stubs - in order to ensure future versions of the SelfStubber remain in step with the SelfLoader, the SelfStubber actually uses the SelfLoader to determine which stubs are needed.</source>
          <target state="translated">최소한 이것은 SelfLoader가 스텁이라고 생각하는 것을 보는 데 유용합니다. SelfStubber의 향후 버전이 SelfLoader와 계속 단계를 유지하기 위해 SelfStubber는 실제로 SelfLoader를 사용하여 필요한 스텁을 판별합니다.</target>
        </trans-unit>
        <trans-unit id="9d086f75055dc823d417d876f240b4ce1aa5f40a" translate="yes" xml:space="preserve">
          <source>At the very minimum, any subclass needs to provide its own &lt;code&gt;new()&lt;/code&gt; and can store additional hash keys in the object. There are also some package globals that must be defined, e.g.:</source>
          <target state="translated">최소한 모든 서브 클래스는 자체 &lt;code&gt;new()&lt;/code&gt; 를 제공해야 하며 객체에 추가 해시 키를 저장할 수 있습니다. 정의해야하는 몇 가지 패키지 전역도 있습니다. 예 :</target>
        </trans-unit>
        <trans-unit id="4c88d3fd177dc36a169a0f390f88ed358e376c27" translate="yes" xml:space="preserve">
          <source>At the very minimum, any subclass will need to provide its own &lt;code&gt;new()&lt;/code&gt; and can store additional hash keys in the object. There are also some package globals that must be defined, e.g.:</source>
          <target state="translated">최소한 모든 서브 클래스는 자체 &lt;code&gt;new()&lt;/code&gt; 를 제공해야하며 추가 해시 키를 객체에 저장할 수 있습니다. 정의해야 할 패키지 전역도 있습니다. 예 :</target>
        </trans-unit>
        <trans-unit id="edcf8fa241edee8ba6be389a9320a43680a858f9" translate="yes" xml:space="preserve">
          <source>At this point, if you're using the</source>
          <target state="translated">이 시점에서</target>
        </trans-unit>
        <trans-unit id="5a6511c6f50957ea6c619917499bccc60b76c492" translate="yes" xml:space="preserve">
          <source>At this point, we have all the basic regexp concepts covered, so let's give a more involved example of a regular expression. We will build a regexp that matches numbers.</source>
          <target state="translated">이 시점에서, 우리는 모든 정규 정규 표현식 개념을 다루었으므로보다 정규 표현식의 더 많은 예를 들어 봅시다. 숫자와 일치하는 정규 표현식을 작성합니다.</target>
        </trans-unit>
        <trans-unit id="370a5cf660692a42903691231af5dc8e0071bc25" translate="yes" xml:space="preserve">
          <source>At this point, xsubpp is doing very little work - the differences between Mytest.xs and Mytest.c are minimal.</source>
          <target state="translated">이 시점에서 xsubpp는 거의 작업을 수행하지 않습니다. Mytest.xs와 Mytest.c의 차이는 최소화됩니다.</target>
        </trans-unit>
        <trans-unit id="4cb351d8164d812dc7e335f6aa1c330c2f5b0d24" translate="yes" xml:space="preserve">
          <source>At this time, &lt;code&gt;study&lt;/code&gt; does nothing. This may change in the future.</source>
          <target state="translated">이때 &lt;code&gt;study&lt;/code&gt; 는 아무것도하지 않습니다. 이는 향후 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6e93ae94dda2105286d8d2c3c0189888d8aa45b7" translate="yes" xml:space="preserve">
          <source>At time of writing, &lt;code&gt;L&amp;lt;name&amp;gt;&lt;/code&gt; values are of two types: either the name of a Pod page like &lt;code&gt;L&amp;lt;Foo::Bar&amp;gt;&lt;/code&gt; (which might be a real Perl module or program in an @INC / PATH directory, or a .pod file in those places); or the name of a Unix man page, like &lt;code&gt;L&amp;lt;crontab(5)&amp;gt;&lt;/code&gt; . In theory, &lt;code&gt;L&amp;lt;chmod&amp;gt;&lt;/code&gt; in ambiguous between a Pod page called &quot;chmod&quot;, or the Unix man page &quot;chmod&quot; (in whatever man-section). However, the presence of a string in parens, as in &quot;crontab(5)&quot;, is sufficient to signal that what is being discussed is not a Pod page, and so is presumably a Unix man page. The distinction is of no importance to many Pod processors, but some processors that render to hypertext formats may need to distinguish them in order to know how to render a given &lt;code&gt;L&amp;lt;foo&amp;gt;&lt;/code&gt; code.</source>
          <target state="translated">작성 당시 &lt;code&gt;L&amp;lt;name&amp;gt;&lt;/code&gt; 값은 &lt;code&gt;L&amp;lt;Foo::Bar&amp;gt;&lt;/code&gt; 와 같은 포드 페이지 이름 (@INC / PATH 디렉토리의 실제 Perl 모듈 또는 프로그램 일 수 있음) 또는 해당 위치의 .pod 파일); 또는 &lt;code&gt;L&amp;lt;crontab(5)&amp;gt;&lt;/code&gt; 와 같은 Unix 매뉴얼 페이지의 이름입니다 . 이론적으로 &lt;code&gt;L&amp;lt;chmod&amp;gt;&lt;/code&gt; 는 &quot;chmod&quot;라는 포드 페이지 또는 Unix 매뉴얼 페이지 &quot;chmod&quot;(모든 섹션에서)간에 모호합니다. 그러나 &quot;crontab (5)&quot;에서와 같이 parens에 문자열이 있으면 논의중인 내용이 Pod 페이지가 아니며 Unix 매뉴얼 페이지 일 수도 있음을 알리기에 충분합니다. 이러한 차이점은 많은 포드 프로세서에서 중요하지 않습니다.하이퍼 텍스트 형식으로 렌더링하는 일부 프로세서는 특정 텍스트를 렌더링하는 방법을 알기 위해 구별해야 할 수도 있습니다. &lt;code&gt;L&amp;lt;foo&amp;gt;&lt;/code&gt; 코드입니다.</target>
        </trans-unit>
        <trans-unit id="1402e155751b829c93df5128b5d19d797691621a" translate="yes" xml:space="preserve">
          <source>At time of writing, &lt;code&gt;L&amp;lt;name&amp;gt;&lt;/code&gt; values are of two types: either the name of a Pod page like &lt;code&gt;L&amp;lt;Foo::Bar&amp;gt;&lt;/code&gt; (which might be a real Perl module or program in an @INC / PATH directory, or a .pod file in those places); or the name of a Unix man page, like &lt;code&gt;L&amp;lt;crontab(5)&amp;gt;&lt;/code&gt;. In theory, &lt;code&gt;L&amp;lt;chmod&amp;gt;&lt;/code&gt; is ambiguous between a Pod page called &quot;chmod&quot;, or the Unix man page &quot;chmod&quot; (in whatever man-section). However, the presence of a string in parens, as in &quot;crontab(5)&quot;, is sufficient to signal that what is being discussed is not a Pod page, and so is presumably a Unix man page. The distinction is of no importance to many Pod processors, but some processors that render to hypertext formats may need to distinguish them in order to know how to render a given &lt;code&gt;L&amp;lt;foo&amp;gt;&lt;/code&gt; code.</source>
          <target state="translated">작성 당시 &lt;code&gt;L&amp;lt;name&amp;gt;&lt;/code&gt; 값은 &lt;code&gt;L&amp;lt;Foo::Bar&amp;gt;&lt;/code&gt; 와 같은 포드 페이지의 이름 (@INC / PATH 디렉토리의 실제 Perl 모듈 또는 프로그램 일 수 있음) 의 두 가지 유형입니다. 해당 위치의 .pod 파일); 또는 &lt;code&gt;L&amp;lt;crontab(5)&amp;gt;&lt;/code&gt; 과 같은 Unix man 페이지의 이름 . 이론적으로 &lt;code&gt;L&amp;lt;chmod&amp;gt;&lt;/code&gt; 는 &quot;chmod&quot;라는 포드 페이지 또는 Unix 맨 페이지 &quot;chmod&quot;(맨 섹션에 관계없이)간에 모호합니다. 그러나 &quot;crontab (5)&quot;에서와 같이 괄호 안에 문자열이 있으면 논의중인 내용이 Pod 페이지가 아니라는 것을 알리기에 충분하며 아마도 Unix man 페이지 일 것입니다. 구별은 많은 Pod 프로세서에서 중요하지 않습니다.그러나 하이퍼 텍스트 형식으로 렌더링하는 일부 프로세서는 주어진 형식을 렌더링하는 방법을 알기 위해 구분해야 할 수 있습니다. &lt;code&gt;L&amp;lt;foo&amp;gt;&lt;/code&gt; 코드.</target>
        </trans-unit>
        <trans-unit id="24f8d626a483cf6ebf2f3cd6cefe211ee98242ab" translate="yes" xml:space="preserve">
          <source>At time of writing, I don't think you'll need to use this.</source>
          <target state="translated">글을 쓰는 시점에서는 이것을 사용할 필요가 없다고 생각합니다.</target>
        </trans-unit>
        <trans-unit id="6b127225208f5ac9bbb6a72b48b20b7d3616ff18" translate="yes" xml:space="preserve">
          <source>Atari MiNT</source>
          <target state="translated">아타리 MiNT</target>
        </trans-unit>
        <trans-unit id="7f3342f30bf4c3977d537b68719b3f6636e25cb1" translate="yes" xml:space="preserve">
          <source>Athena</source>
          <target state="translated">Athena</target>
        </trans-unit>
        <trans-unit id="fb5b8f9948a5df2cd992c1e84448561317bc6a25" translate="yes" xml:space="preserve">
          <source>Atrributes such as package, file, and caller are determined automatically, and cannot be specified.</source>
          <target state="translated">패키지, 파일 및 호출자와 같은 속성은 자동으로 결정되며 지정할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="3493cb8763751f88e1926ab01085068e369734c9" translate="yes" xml:space="preserve">
          <source>Attach the shared memory segment identified by ID to the address space of the calling process. See &lt;a href=&quot;http://man.he.net/man2/shmat&quot;&gt;shmat(2)&lt;/a&gt;.</source>
          <target state="translated">ID로 식별 된 공유 메모리 세그먼트를 호출 프로세스의 주소 공간에 연결하십시오. &lt;a href=&quot;http://man.he.net/man2/shmat&quot;&gt;shmat (2)를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d759da54d18d185bb5ccfc037b889a6ccc296532" translate="yes" xml:space="preserve">
          <source>Attach the shared memory segment identified by ID to the address space of the calling process. See &lt;a href=&quot;http://search.cpan.org/perldoc/shmat&quot;&gt;shmat&lt;/a&gt;.</source>
          <target state="translated">ID로 식별 된 공유 메모리 세그먼트를 호출 프로세스의 주소 공간에 연결하십시오. &lt;a href=&quot;http://search.cpan.org/perldoc/shmat&quot;&gt;shmat를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="225d31a7a030cd02427cb0b7456aa1f815b2914d" translate="yes" xml:space="preserve">
          <source>Attaching &lt;code&gt;PERL_MAGIC_uvar&lt;/code&gt; to arrays is permissible but has no effect.</source>
          <target state="translated">&lt;code&gt;PERL_MAGIC_uvar&lt;/code&gt; 를 배열에 연결 하는 것은 허용되지만 효과는 없습니다.</target>
        </trans-unit>
        <trans-unit id="d423c0cfec188bd6ee98e700b49e9beb58a1ac55" translate="yes" xml:space="preserve">
          <source>Attempt SASL authentication.</source>
          <target state="translated">SASL 인증을 시도하십시오.</target>
        </trans-unit>
        <trans-unit id="a57d83a2b0e335a567209ea75d9a6f7c18c72eb5" translate="yes" xml:space="preserve">
          <source>Attempt SASL authentication. Requires Authen::SASL module.</source>
          <target state="translated">SASL 인증을 시도하십시오. Authen :: SASL 모듈이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="ccd854e11a4d11e3e9e58ceb95944b13ef3a518a" translate="yes" xml:space="preserve">
          <source>Attempt SASL authentication. Requires Authen::SASL module. The first form constructs a new Authen::SASL object using the given username and password; the second form uses the given Authen::SASL object.</source>
          <target state="translated">SASL 인증을 시도합니다. Authen :: SASL 모듈이 필요합니다. 첫 번째 양식은 주어진 사용자 이름과 암호를 사용하여 새로운 Authen :: SASL 객체를 생성합니다. 두 번째 양식은 주어진 Authen :: SASL 객체를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="883f5c19fa9ca67ce62c443fd2ce7bac60b6089d" translate="yes" xml:space="preserve">
          <source>Attempt to access disallowed key '%s' in a restricted hash</source>
          <target state="translated">제한된 해시에서 허용되지 않는 키 '% s'에 액세스하려고합니다.</target>
        </trans-unit>
        <trans-unit id="5cf0ab65502bfcdd00cde497405332ccea4e648b" translate="yes" xml:space="preserve">
          <source>Attempt to bless into a freed package</source>
          <target state="translated">해방 된 패키지로 축복을 시도하십시오</target>
        </trans-unit>
        <trans-unit id="8614ea5fd745bc313cc5245a331edbc4dddec890" translate="yes" xml:space="preserve">
          <source>Attempt to bless into a reference</source>
          <target state="translated">참조로 축복하려는 시도</target>
        </trans-unit>
        <trans-unit id="0bfa31d2d4671313bd0af54f4bb1d33e8b3d1352" translate="yes" xml:space="preserve">
          <source>Attempt to change directory to the directory given in &lt;code&gt;$dir&lt;/code&gt; . If &lt;code&gt;$dir&lt;/code&gt; is &lt;code&gt;&quot;..&quot;&lt;/code&gt; , the FTP &lt;code&gt;CDUP&lt;/code&gt; command is used to attempt to move up one directory. If no directory is given then an attempt is made to change the directory to the root directory.</source>
          <target state="translated">디렉토리를 &lt;code&gt;$dir&lt;/code&gt; 제공된 디렉토리로 변경하십시오 . 경우 &lt;code&gt;$dir&lt;/code&gt; 있다 &lt;code&gt;&quot;..&quot;&lt;/code&gt; 는 FTP &lt;code&gt;CDUP&lt;/code&gt; 의 명령은 하나의 디렉토리를 이동하려고 시도하는 데 사용됩니다. 디렉토리가 제공되지 않으면 디렉토리를 루트 디렉토리로 변경하려고 시도합니다.</target>
        </trans-unit>
        <trans-unit id="6f0b75ab4748fe5742f8fdfbfa72a1464729d3b5" translate="yes" xml:space="preserve">
          <source>Attempt to change directory to the directory given in &lt;code&gt;$dir&lt;/code&gt;. If &lt;code&gt;$dir&lt;/code&gt; is &lt;code&gt;&quot;..&quot;&lt;/code&gt;, the FTP &lt;code&gt;CDUP&lt;/code&gt; command is used to attempt to move up one directory. If no directory is given then an attempt is made to change the directory to the root directory.</source>
          <target state="translated">&lt;code&gt;$dir&lt;/code&gt; 제공된 디렉토리로 디렉토리를 변경하십시오 . 경우 &lt;code&gt;$dir&lt;/code&gt; 있다 &lt;code&gt;&quot;..&quot;&lt;/code&gt; 는 FTP &lt;code&gt;CDUP&lt;/code&gt; 의 명령은 하나의 디렉토리를 이동하려고 시도하는 데 사용됩니다. 디렉토리가 제공되지 않으면 디렉토리를 루트 디렉토리로 변경하려고 시도합니다.</target>
        </trans-unit>
        <trans-unit id="c6aef18d28c95173a99a1a9cd9b174366e83e56c" translate="yes" xml:space="preserve">
          <source>Attempt to clear deleted array</source>
          <target state="translated">삭제 된 어레이 지우기 시도</target>
        </trans-unit>
        <trans-unit id="f1a553fb01152c680db2f1ac04b66addb3e1a32b" translate="yes" xml:space="preserve">
          <source>Attempt to convert an absolute file specification to a relative specification.</source>
          <target state="translated">절대 파일 스펙을 상대 스펙으로 변환하십시오.</target>
        </trans-unit>
        <trans-unit id="2c4880c9fdd4f4d9c5b79e2c012fb0e250d383e7" translate="yes" xml:space="preserve">
          <source>Attempt to delete disallowed key '%s' from a restricted hash</source>
          <target state="translated">제한된 해시에서 허용되지 않는 키 '% s'을 (를) 삭제하려고합니다.</target>
        </trans-unit>
        <trans-unit id="0798ebadbab9bffb1e99c85507d3edee83caa008" translate="yes" xml:space="preserve">
          <source>Attempt to delete readonly key '%s' from a restricted hash</source>
          <target state="translated">제한된 해시에서 읽기 전용 키 '% s'을 (를) 삭제하려고합니다.</target>
        </trans-unit>
        <trans-unit id="c6a6104d31483a82798cc43a56c3040f5b0e5915" translate="yes" xml:space="preserve">
          <source>Attempt to destroy all objects not yet freed.</source>
          <target state="translated">아직 해제되지 않은 모든 개체를 파괴하려고합니다.</target>
        </trans-unit>
        <trans-unit id="fe99a6ee8775c38ae61fdc7b8491eb15dc3ce181" translate="yes" xml:space="preserve">
          <source>Attempt to evaluate the current host's internet name and domain</source>
          <target state="translated">현재 호스트의 인터넷 이름과 도메인을 평가하려고합니다</target>
        </trans-unit>
        <trans-unit id="80fda9c03868b272773d0d41887e0dbe18413719" translate="yes" xml:space="preserve">
          <source>Attempt to free non-arena SV: 0x%x</source>
          <target state="translated">아레나가 아닌 SV 해제 시도 : 0x % x</target>
        </trans-unit>
        <trans-unit id="54d38b115a5aa938320799c6531228c69b9fa275" translate="yes" xml:space="preserve">
          <source>Attempt to free nonexistent shared string '%s'%s</source>
          <target state="translated">존재하지 않는 공유 문자열 '% s'% s을 (를) 해제하려고합니다.</target>
        </trans-unit>
        <trans-unit id="1b479273a362ea2e8c34f077e9e3c6360ab77808" translate="yes" xml:space="preserve">
          <source>Attempt to free temp prematurely: SV 0x%x</source>
          <target state="translated">임시로 임시 해제 시도 : SV 0x % x</target>
        </trans-unit>
        <trans-unit id="a34a51b6be5af9431919f62ebe158c42fa203ea7" translate="yes" xml:space="preserve">
          <source>Attempt to free unreferenced glob pointers</source>
          <target state="translated">참조되지 않은 glob 포인터 해제 시도</target>
        </trans-unit>
        <trans-unit id="40f310189c328c36df3675b24385fea4a52ffa6b" translate="yes" xml:space="preserve">
          <source>Attempt to free unreferenced scalar: SV 0x%x</source>
          <target state="translated">참조되지 않은 스칼라 해제 시도 : SV 0x % x</target>
        </trans-unit>
        <trans-unit id="51aff28048c322c0b88140e9c1dcb9278d5b60c1" translate="yes" xml:space="preserve">
          <source>Attempt to pack pointer to temporary value</source>
          <target state="translated">임시 값에 대한 포인터 팩 시도</target>
        </trans-unit>
        <trans-unit id="078cb982d4d92298b47355c08e74e2f224c181c7" translate="yes" xml:space="preserve">
          <source>Attempt to print summary information if run is interrupted by SIGINT (Ctrl-C).</source>
          <target state="translated">SIGINT (Ctrl-C)에 의해 실행이 중단 된 경우 요약 정보를 인쇄하려고합니다.</target>
        </trans-unit>
        <trans-unit id="b914600bb82ac0ae87b3e9ab97d2d1c2f3efb3a8" translate="yes" xml:space="preserve">
          <source>Attempt to produce color output.</source>
          <target state="translated">컬러 출력을 생성하려고합니다.</target>
        </trans-unit>
        <trans-unit id="efb3613b13587fe1f93cf60bf899f24390374124" translate="yes" xml:space="preserve">
          <source>Attempt to read &lt;code&gt;$length&lt;/code&gt; bytes of uncompressed data into &lt;code&gt;$buffer&lt;/code&gt; .</source>
          <target state="translated">압축되지 않은 &lt;code&gt;$length&lt;/code&gt; 바이트의 데이터를 &lt;code&gt;$buffer&lt;/code&gt; 로 읽으십시오 .</target>
        </trans-unit>
        <trans-unit id="09a9c5fb7a8cb670c472dd87151c6343a5662154" translate="yes" xml:space="preserve">
          <source>Attempt to read &lt;code&gt;$length&lt;/code&gt; bytes of uncompressed data into &lt;code&gt;$buffer&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;$length&lt;/code&gt; 바이트의 압축되지 않은 데이터를 &lt;code&gt;$buffer&lt;/code&gt; 로 읽으려고 합니다 .</target>
        </trans-unit>
        <trans-unit id="9e9d551547de808708f971d391e53086cf3f44fc" translate="yes" xml:space="preserve">
          <source>Attempt to reload %s aborted.</source>
          <target state="translated">% s 다시로드 시도가 중단되었습니다.</target>
        </trans-unit>
        <trans-unit id="87c4ceba341469a694caa6a8c164987d97a35645" translate="yes" xml:space="preserve">
          <source>Attempt to set length of freed array</source>
          <target state="translated">해제 된 배열의 길이 설정 시도</target>
        </trans-unit>
        <trans-unit id="cee621066cdf5eff50fe796c90fc14083ab2dd15" translate="yes" xml:space="preserve">
          <source>Attempt to use reference as lvalue in substr</source>
          <target state="translated">참조를 substr에서 lvalue로 사용하려고합니다.</target>
        </trans-unit>
        <trans-unit id="5b92f951c7fd86ee7f7ec9db2ae7b702bd512a11" translate="yes" xml:space="preserve">
          <source>Attempting to inherit from yourself generates a warning.</source>
          <target state="translated">자신으로부터 상속을 시도하면 경고가 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="940068c4484917346e58cd849ab63ab658a04374" translate="yes" xml:space="preserve">
          <source>Attempting to pack the special floating point values &lt;code&gt;Inf&lt;/code&gt; and &lt;code&gt;NaN&lt;/code&gt; (infinity, also in negative, and not-a-number) into packed integer values (like &lt;code&gt;&quot;L&quot;&lt;/code&gt; ) is a fatal error. The reason for this is that there simply isn't any sensible mapping for these special values into integers.</source>
          <target state="translated">특수 부동 소수점 값 &lt;code&gt;Inf&lt;/code&gt; 및 &lt;code&gt;NaN&lt;/code&gt; (무한 수, 음수 및 비수 )을 팩형 정수 값 (예 : &lt;code&gt;&quot;L&quot;&lt;/code&gt; )으로 묶으려고 하면 치명적인 오류가 발생합니다. 그 이유는 이러한 특수 값에 대한 현명한 매핑이 정수로 간단하지 않기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="d1f53d7ce9f579730ddb96734ab811ab0bbc0590" translate="yes" xml:space="preserve">
          <source>Attempting to pack the special floating point values &lt;code&gt;Inf&lt;/code&gt; and &lt;code&gt;NaN&lt;/code&gt; (infinity, also in negative, and not-a-number) into packed integer values (like &lt;code&gt;&quot;L&quot;&lt;/code&gt;) is a fatal error. The reason for this is that there simply isn't any sensible mapping for these special values into integers.</source>
          <target state="translated">특수 부동 소수점 값 &lt;code&gt;Inf&lt;/code&gt; 및 &lt;code&gt;NaN&lt;/code&gt; (무한대, 음수 및 숫자 아님)을 패킹 된 정수 값 (예 : &lt;code&gt;&quot;L&quot;&lt;/code&gt; ) 으로 패킹 하려는 시도 는 치명적 오류입니다. 그 이유는 이러한 특수 값에 대해 정수로의 적절한 매핑이 없기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="6015d4f519177c33ba06ab08404701540b4f2048" translate="yes" xml:space="preserve">
          <source>Attempting to reopen a database without closing it.</source>
          <target state="translated">데이터베이스를 닫지 않고 다시 열려고합니다.</target>
        </trans-unit>
        <trans-unit id="0bedf74043c203b86c1b5363d305f57a4b0c5fcb" translate="yes" xml:space="preserve">
          <source>Attempts several methods of getting the system hostname and then caches the result. It tries the first available of the C library's gethostname(), &lt;code&gt;`$Config{aphostname}`&lt;/code&gt; , uname(2), &lt;code&gt;&lt;a href=&quot;../functions/syscall&quot;&gt;syscall(SYS_gethostname)&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;`hostname`&lt;/code&gt; , &lt;code&gt;`uname -n`&lt;/code&gt; , and the file</source>
          <target state="translated">시스템 호스트 이름을 가져 오는 몇 가지 방법을 시도한 후 결과를 캐시합니다. C 라이브러리의 gethostname (), &lt;code&gt;`$Config{aphostname}`&lt;/code&gt; , uname (2), &lt;code&gt;&lt;a href=&quot;../functions/syscall&quot;&gt;syscall(SYS_gethostname)&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;`hostname`&lt;/code&gt; , &lt;code&gt;`uname -n`&lt;/code&gt; 및 파일 중 첫 번째로 사용 가능한 파일을 시도 합니다.</target>
        </trans-unit>
        <trans-unit id="82ba9728173d7f6ba4ffa539ae706dc3eec02b8f" translate="yes" xml:space="preserve">
          <source>Attempts several methods of getting the system hostname and then caches the result. It tries the first available of the C library's gethostname(), &lt;code&gt;`$Config{aphostname}`&lt;/code&gt;, uname(2), &lt;code&gt;syscall(SYS_gethostname)&lt;/code&gt;, &lt;code&gt;`hostname`&lt;/code&gt;, &lt;code&gt;`uname -n`&lt;/code&gt;, and the file</source>
          <target state="translated">시스템 호스트 이름을 가져 오는 여러 방법을 시도한 다음 결과를 캐시합니다. C 라이브러리의 gethostname (), &lt;code&gt;`$Config{aphostname}`&lt;/code&gt; , uname (2), &lt;code&gt;syscall(SYS_gethostname)&lt;/code&gt; , &lt;code&gt;`hostname`&lt;/code&gt; , &lt;code&gt;`uname -n`&lt;/code&gt; 및 파일 중 첫 번째로 사용 가능한 것을 시도 합니다.</target>
        </trans-unit>
        <trans-unit id="5ba76ae4290c1441342a9f4f7bc1b58233fe69fb" translate="yes" xml:space="preserve">
          <source>Attempts to connect to a remote socket, just like &lt;a href=&quot;http://man.he.net/man2/connect&quot;&gt;connect(2)&lt;/a&gt;. Returns true if it succeeded, false otherwise. NAME should be a packed address of the appropriate type for the socket. See the examples in &lt;a href=&quot;perlipc#Sockets%3A-Client%2FServer-Communication&quot;&gt;&quot;Sockets: Client/Server Communication&quot; in perlipc&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://man.he.net/man2/connect&quot;&gt;connect (2)&lt;/a&gt; 처럼 원격 소켓에 연결을 시도합니다 . 성공하면 true를 반환하고 그렇지 않으면 false를 반환합니다. NAME은 소켓에 적합한 유형의 패킹 된 주소 여야합니다. &lt;a href=&quot;perlipc#Sockets%3A-Client%2FServer-Communication&quot;&gt;perlipc의 &quot;소켓 : 클라이언트 / 서버 통신&quot;&lt;/a&gt; 의 예를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f998d3cd38777ee213006cd15fb0e0f6d2ddc7f7" translate="yes" xml:space="preserve">
          <source>Attempts to connect to a remote socket, just like connect(2). Returns true if it succeeded, false otherwise. NAME should be a packed address of the appropriate type for the socket. See the examples in &lt;a href=&quot;../perlipc#Sockets%3a-Client%2fServer-Communication&quot;&gt;Sockets: Client/Server Communication in perlipc&lt;/a&gt;.</source>
          <target state="translated">connect (2)와 같이 원격 소켓에 연결을 시도합니다. 성공하면 true를, 그렇지 않으면 false를 반환합니다. NAME은 소켓에 적합한 유형의 압축 된 주소 여야합니다. 의 예를 참조하십시오&lt;a href=&quot;../perlipc#Sockets%3a-Client%2fServer-Communication&quot;&gt;소켓 : perlipc의 클라이언트 / 서버 통신&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="64769a075153327a39fd4f2723d3853f980fe471" translate="yes" xml:space="preserve">
          <source>Attempts to connect to a remote socket, just like connect(2). Returns true if it succeeded, false otherwise. NAME should be a packed address of the appropriate type for the socket. See the examples in &lt;a href=&quot;perlipc#Sockets%3a-Client%2fServer-Communication&quot;&gt;Sockets: Client/Server Communication in perlipc&lt;/a&gt;.</source>
          <target state="translated">connect (2)와 같이 원격 소켓에 연결을 시도합니다. 성공하면 true를, 그렇지 않으면 false를 반환합니다. NAME은 소켓에 적합한 유형의 압축 된 주소 여야합니다. 의 예를 참조하십시오&lt;a href=&quot;perlipc#Sockets%3a-Client%2fServer-Communication&quot;&gt;소켓 : perlipc의 클라이언트 / 서버 통신&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4a0ddb935c0376b494edd76deb21d2e9aa4a1612" translate="yes" xml:space="preserve">
          <source>Attempts to convert in-place the octet sequence encoded as</source>
          <target state="translated">다음과 같이 인코딩 된 옥텟 시퀀스를 제자리에서 변환하려고합니다.</target>
        </trans-unit>
        <trans-unit id="bd9b4f39078d108026008c73a3d153cb14bae4bd" translate="yes" xml:space="preserve">
          <source>Attempts to convert the PV of an SV from characters to bytes. If the PV contains a character that cannot fit in a byte, this conversion will fail; in this case, either returns false or, if &lt;code&gt;fail_ok&lt;/code&gt; is not true, croaks.</source>
          <target state="translated">SV의 PV를 문자에서 바이트로 변환하려고합니다. PV에 바이트에 맞지 않는 문자가 포함되어 있으면이 변환이 실패합니다. 이 경우 false를 반환하거나 &lt;code&gt;fail_ok&lt;/code&gt; 가 true가 아닌 경우 크로 킹됩니다.</target>
        </trans-unit>
        <trans-unit id="64d7ec66819a9007136707554fdc8dbbef9567aa" translate="yes" xml:space="preserve">
          <source>Attempts to determine if a given host is outside your firewall. Possible return values are.</source>
          <target state="translated">지정된 호스트가 방화벽 외부에 있는지 확인합니다. 가능한 반환 값은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="015e99d4e0b5f5661a89b0c851595de01de6cc85" translate="yes" xml:space="preserve">
          <source>Attempts to read LENGTH</source>
          <target state="translated">LENGTH를 읽으려고 시도</target>
        </trans-unit>
        <trans-unit id="c8be1bb9a549008dc0e0461ce94dfbc02a8ed8c1" translate="yes" xml:space="preserve">
          <source>Attempts to read LENGTH bytes of data into variable SCALAR from the specified FILEHANDLE, using &lt;a href=&quot;http://man.he.net/man2/read&quot;&gt;read(2)&lt;/a&gt;. It bypasses any &lt;a href=&quot;perlio&quot;&gt;PerlIO&lt;/a&gt; layers including buffered IO (but is affected by the presence of the &lt;code&gt;:utf8&lt;/code&gt; layer as described later), so mixing this with other kinds of reads, &lt;a href=&quot;#print-FILEHANDLE-LIST&quot;&gt;&lt;code&gt;print&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#write-FILEHANDLE&quot;&gt;&lt;code&gt;write&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#seek-FILEHANDLE%2CPOSITION%2CWHENCE&quot;&gt;&lt;code&gt;seek&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#tell-FILEHANDLE&quot;&gt;&lt;code&gt;tell&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;#eof-FILEHANDLE&quot;&gt;&lt;code&gt;eof&lt;/code&gt;&lt;/a&gt; can cause confusion because the &lt;code&gt;:perlio&lt;/code&gt; or &lt;code&gt;:crlf&lt;/code&gt; layers usually buffer data. Returns the number of bytes actually read, &lt;code&gt;0&lt;/code&gt; at end of file, or undef if there was an error (in the latter case &lt;a href=&quot;perlvar#%24%21&quot;&gt;&lt;code&gt;$!&lt;/code&gt;&lt;/a&gt; is also set). SCALAR will be grown or shrunk so that the last byte actually read is the last byte of the scalar after the read.</source>
          <target state="translated">&lt;a href=&quot;http://man.he.net/man2/read&quot;&gt;read (2)를&lt;/a&gt; 사용하여 지정된 FILEHANDLE에서 LENGTH 바이트의 데이터를 변수 SCALAR로 읽으려고 시도합니다 . 버퍼링 된 IO를 포함한 모든 &lt;a href=&quot;perlio&quot;&gt;PerlIO&lt;/a&gt; 레이어를 우회하므로 (하지만 나중에 설명하는대로 &lt;code&gt;:utf8&lt;/code&gt; 레이어 의 존재에 의해 영향을받습니다 ),이를 다른 종류의 읽기, &lt;a href=&quot;#print-FILEHANDLE-LIST&quot;&gt; &lt;code&gt;print&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#write-FILEHANDLE&quot;&gt; &lt;code&gt;write&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#seek-FILEHANDLE%2CPOSITION%2CWHENCE&quot;&gt; &lt;code&gt;seek&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#tell-FILEHANDLE&quot;&gt; &lt;code&gt;tell&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#eof-FILEHANDLE&quot;&gt; &lt;code&gt;eof&lt;/code&gt; &lt;/a&gt; 와 혼합하면 다음과 같은 이유로 혼동이 발생할 수 있습니다 &lt;code&gt;:perlio&lt;/code&gt; 또는 &lt;code&gt;:crlf&lt;/code&gt; 레이어는 일반적으로 데이터를 버퍼링합니다. 실제로 읽은 바이트 수, 파일 끝 에서 &lt;code&gt;0&lt;/code&gt; , 오류가있는 경우 undef (후자의 경우 &lt;a href=&quot;perlvar#%24%21&quot;&gt; &lt;code&gt;$!&lt;/code&gt; &lt;/a&gt;설정 됨). SCALAR는 실제로 읽은 마지막 바이트가 읽은 후 스칼라의 마지막 바이트가되도록 증가 또는 축소됩니다.</target>
        </trans-unit>
        <trans-unit id="623d8fbf82dc2fdc9694f6bbe91f1257bb25f69a" translate="yes" xml:space="preserve">
          <source>Attempts to read LENGTH bytes of data into variable SCALAR from the specified FILEHANDLE, using the read(2). It bypasses buffered IO, so mixing this with other kinds of reads, &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/write&quot;&gt;write&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/tell&quot;&gt;tell&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt; can cause confusion because the perlio or stdio layers usually buffers data. Returns the number of bytes actually read, &lt;code&gt;0&lt;/code&gt; at end of file, or undef if there was an error (in the latter case &lt;code&gt;$!&lt;/code&gt; is also set). SCALAR will be grown or shrunk so that the last byte actually read is the last byte of the scalar after the read.</source>
          <target state="translated">read (2)를 사용하여 지정된 FILEHANDLE에서 LENGTH 바이트의 데이터를 변수 SCALAR로 읽으려고합니다. 버퍼 된 IO를 우회 하므로 perlio 또는 stdio 레이어는 일반적으로 데이터를 버퍼링하기 때문에 다른 종류의 읽기, &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/write&quot;&gt;write&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt; , seek , &lt;code&gt;&lt;a href=&quot;functions/tell&quot;&gt;tell&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt; 와 혼합 하면 혼동을 일으킬 수 있습니다. 실제로 읽은 바이트 수, 파일 끝 에서 &lt;code&gt;0&lt;/code&gt; 또는 오류가있는 경우 undef (후자의 경우 &lt;code&gt;$!&lt;/code&gt; 도 설정 됨)를 리턴합니다 . SCALAR는 실제로 읽은 마지막 바이트가 읽은 후 스칼라의 마지막 바이트가되도록 커지거나 줄어 듭니다.</target>
        </trans-unit>
        <trans-unit id="321c64867646f812228d15e7d459f8fc1a5c1183" translate="yes" xml:space="preserve">
          <source>Attempts to read LENGTH bytes of data into variable SCALAR from the specified FILEHANDLE, using the read(2). It bypasses buffered IO, so mixing this with other kinds of reads, &lt;code&gt;&lt;a href=&quot;print&quot;&gt;print&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;write&quot;&gt;write&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;tell&quot;&gt;tell&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt; can cause confusion because the perlio or stdio layers usually buffers data. Returns the number of bytes actually read, &lt;code&gt;0&lt;/code&gt; at end of file, or undef if there was an error (in the latter case &lt;code&gt;$!&lt;/code&gt; is also set). SCALAR will be grown or shrunk so that the last byte actually read is the last byte of the scalar after the read.</source>
          <target state="translated">read (2)를 사용하여 지정된 FILEHANDLE에서 LENGTH 바이트의 데이터를 변수 SCALAR로 읽으려고합니다. 버퍼 된 IO를 우회 하므로 perlio 또는 stdio 레이어는 일반적으로 데이터를 버퍼링하기 때문에 다른 종류의 읽기, &lt;code&gt;&lt;a href=&quot;print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;write&quot;&gt;write&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt; , seek , &lt;code&gt;&lt;a href=&quot;tell&quot;&gt;tell&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt; 와 혼합 하면 혼동을 일으킬 수 있습니다. 실제로 읽은 바이트 수, 파일 끝 에서 &lt;code&gt;0&lt;/code&gt; 또는 오류가있는 경우 undef (후자의 경우 &lt;code&gt;$!&lt;/code&gt; 도 설정 됨)를 리턴합니다 . SCALAR는 실제로 읽은 마지막 바이트가 읽은 후 스칼라의 마지막 바이트가되도록 커지거나 줄어 듭니다.</target>
        </trans-unit>
        <trans-unit id="1a8348f0c0ac76ec0ef2040ebe72ee4d10ad1e13" translate="yes" xml:space="preserve">
          <source>Attempts to set_hints_for unidentifiable subroutine</source>
          <target state="translated">식별 할 수없는 서브 루틴에 대해 set_hints_를 시도합니다.</target>
        </trans-unit>
        <trans-unit id="2e09b188ae4a3fab1a81562daadb429ed4fd7f6d" translate="yes" xml:space="preserve">
          <source>Attempts to write LENGTH bytes of data from variable SCALAR to the specified FILEHANDLE, using &lt;a href=&quot;http://man.he.net/man2/write&quot;&gt;write(2)&lt;/a&gt;. If LENGTH is not specified, writes whole SCALAR. It bypasses any &lt;a href=&quot;perlio&quot;&gt;PerlIO&lt;/a&gt; layers including buffered IO (but is affected by the presence of the &lt;code&gt;:utf8&lt;/code&gt; layer as described later), so mixing this with reads (other than &lt;code&gt;sysread)&lt;/code&gt;), &lt;a href=&quot;#print-FILEHANDLE-LIST&quot;&gt;&lt;code&gt;print&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#write-FILEHANDLE&quot;&gt;&lt;code&gt;write&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#seek-FILEHANDLE%2CPOSITION%2CWHENCE&quot;&gt;&lt;code&gt;seek&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#tell-FILEHANDLE&quot;&gt;&lt;code&gt;tell&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;#eof-FILEHANDLE&quot;&gt;&lt;code&gt;eof&lt;/code&gt;&lt;/a&gt; may cause confusion because the &lt;code&gt;:perlio&lt;/code&gt; and &lt;code&gt;:crlf&lt;/code&gt; layers usually buffer data. Returns the number of bytes actually written, or &lt;a href=&quot;#undef-EXPR&quot;&gt;&lt;code&gt;undef&lt;/code&gt;&lt;/a&gt; if there was an error (in this case the errno variable &lt;a href=&quot;perlvar#%24%21&quot;&gt;&lt;code&gt;$!&lt;/code&gt;&lt;/a&gt; is also set). If the LENGTH is greater than the data available in the SCALAR after the OFFSET, only as much data as is available will be written.</source>
          <target state="translated">&lt;a href=&quot;http://man.he.net/man2/write&quot;&gt;write (2)를&lt;/a&gt; 사용하여 SCALAR 변수에서 지정된 FILEHANDLE로 LENGTH 바이트의 데이터 쓰기를 시도합니다 . LENGTH가 지정되지 않은 경우 전체 SCALAR를 씁니다. 버퍼링 된 IO를 포함한 모든 &lt;a href=&quot;perlio&quot;&gt;PerlIO&lt;/a&gt; 레이어를 우회하므로 (하지만 나중에 설명하는대로 &lt;code&gt;:utf8&lt;/code&gt; 레이어 의 존재에 영향을받습니다 ),이를 reads ( &lt;code&gt;sysread)&lt;/code&gt; ), &lt;a href=&quot;#print-FILEHANDLE-LIST&quot;&gt; &lt;code&gt;print&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#write-FILEHANDLE&quot;&gt; &lt;code&gt;write&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#seek-FILEHANDLE%2CPOSITION%2CWHENCE&quot;&gt; &lt;code&gt;seek&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#tell-FILEHANDLE&quot;&gt; &lt;code&gt;tell&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#eof-FILEHANDLE&quot;&gt; &lt;code&gt;eof&lt;/code&gt; &lt;/a&gt; 와 혼합 하면 혼동이 발생할 수 있습니다. 때문에 &lt;code&gt;:perlio&lt;/code&gt; 하고 &lt;code&gt;:crlf&lt;/code&gt; 층은 일반적으로 데이터를 버퍼링. 실제로 쓰여진 바이트 수 또는 &lt;a href=&quot;#undef-EXPR&quot;&gt; &lt;code&gt;undef&lt;/code&gt; 를&lt;/a&gt; 반환합니다.오류가있는 경우 (이 경우 errno 변수 &lt;a href=&quot;perlvar#%24%21&quot;&gt; &lt;code&gt;$!&lt;/code&gt; &lt;/a&gt; 도 설정 됨). LENGTH가 OFFSET 이후 SCALAR에서 사용 가능한 데이터보다 크면 사용 가능한만큼의 데이터 만 기록됩니다.</target>
        </trans-unit>
        <trans-unit id="056c7c4b49d09bfb10b608aa560ae7f329c94639" translate="yes" xml:space="preserve">
          <source>Attempts to write LENGTH bytes of data from variable SCALAR to the specified FILEHANDLE, using write(2). If LENGTH is not specified, writes whole SCALAR. It bypasses buffered IO, so mixing this with reads (other than &lt;code&gt;&lt;a href=&quot;functions/sysread&quot;&gt;sysread())&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/write&quot;&gt;write&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/tell&quot;&gt;tell&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt; may cause confusion because the perlio and stdio layers usually buffer data. Returns the number of bytes actually written, or &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; if there was an error (in this case the errno variable &lt;code&gt;$!&lt;/code&gt; is also set). If the LENGTH is greater than the data available in the SCALAR after the OFFSET, only as much data as is available will be written.</source>
          <target state="translated">write (2)를 사용하여 변수 SCALAR에서 지정된 FILEHANDLE에 LENGTH 바이트의 데이터를 쓰려고 시도합니다. LENGTH를 지정하지 않으면 전체 SCALAR를 씁니다. 버퍼링 된 IO를 우회 하므로 perlio 및 stdio 레이어는 일반적으로 데이터를 버퍼링하므로 &lt;code&gt;&lt;a href=&quot;functions/sysread&quot;&gt;sysread())&lt;/a&gt;&lt;/code&gt; 이외의 read , &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/write&quot;&gt;write&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/tell&quot;&gt;tell&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt; 와 혼용 할 수 있습니다. 실제로 쓴 바이트 수를 반환하거나 오류가있는 경우 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 를 반환합니다 (이 경우 errno 변수 &lt;code&gt;$!&lt;/code&gt; 도 설정 됨). LENGTH가 오프셋 후 SCALAR에서 사용 가능한 데이터보다 크면 사용 가능한만큼의 데이터 만 기록됩니다.</target>
        </trans-unit>
        <trans-unit id="bf935c85345c3169ffc0b395c956f17c45a9fe82" translate="yes" xml:space="preserve">
          <source>Attempts to write LENGTH bytes of data from variable SCALAR to the specified FILEHANDLE, using write(2). If LENGTH is not specified, writes whole SCALAR. It bypasses buffered IO, so mixing this with reads (other than &lt;code&gt;&lt;a href=&quot;sysread&quot;&gt;sysread())&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;print&quot;&gt;print&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;write&quot;&gt;write&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;tell&quot;&gt;tell&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt; may cause confusion because the perlio and stdio layers usually buffer data. Returns the number of bytes actually written, or &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; if there was an error (in this case the errno variable &lt;code&gt;$!&lt;/code&gt; is also set). If the LENGTH is greater than the data available in the SCALAR after the OFFSET, only as much data as is available will be written.</source>
          <target state="translated">write (2)를 사용하여 변수 SCALAR에서 지정된 FILEHANDLE에 LENGTH 바이트의 데이터를 쓰려고 시도합니다. LENGTH를 지정하지 않으면 전체 SCALAR를 씁니다. 버퍼링 된 IO를 우회 하므로 perlio 및 stdio 레이어는 일반적으로 데이터를 버퍼링하므로 &lt;code&gt;&lt;a href=&quot;sysread&quot;&gt;sysread())&lt;/a&gt;&lt;/code&gt; 이외의 read , &lt;code&gt;&lt;a href=&quot;print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;write&quot;&gt;write&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;tell&quot;&gt;tell&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt; 와 혼용 할 수 있습니다. 실제로 쓴 바이트 수를 반환하거나 오류가있는 경우 &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 를 반환합니다 (이 경우 errno 변수 &lt;code&gt;$!&lt;/code&gt; 도 설정 됨). LENGTH가 오프셋 후 SCALAR에서 사용 가능한 데이터보다 크면 사용 가능한만큼의 데이터 만 기록됩니다.</target>
        </trans-unit>
        <trans-unit id="cf2ad2263d9deded93137fc6e93270ce22633fb0" translate="yes" xml:space="preserve">
          <source>Attempts word completion. Cannot be changed.</source>
          <target state="translated">단어 완성을 시도합니다. 변경할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="223e46f6b77744459f61cc252aea39f3bcaac056" translate="yes" xml:space="preserve">
          <source>Attribs</source>
          <target state="translated">Attribs</target>
        </trans-unit>
        <trans-unit id="295826f440604d6a675c4c66d0a324dc4eaca56b" translate="yes" xml:space="preserve">
          <source>Attribute prototype(%s) discards earlier prototype attribute in same sub</source>
          <target state="translated">속성 프로토 타입 (% s)이 동일한 하위에있는 이전 프로토 타입 속성을 버립니다.</target>
        </trans-unit>
        <trans-unit id="402319da749127eab7373ce69945d35452ea82aa" translate="yes" xml:space="preserve">
          <source>Attribute::Handlers</source>
          <target state="translated">Attribute::Handlers</target>
        </trans-unit>
        <trans-unit id="ab429cb97f17abf9bda7af427a4ab75a270a8eee" translate="yes" xml:space="preserve">
          <source>Attribute::Handlers - Simpler definition of attribute handlers</source>
          <target state="translated">Attribute :: Handlers-속성 핸들러의 간단한 정의</target>
        </trans-unit>
        <trans-unit id="1c8c525e5ee86dfc71e9832b4cad7c5124dad809" translate="yes" xml:space="preserve">
          <source>Attribute::Handlers makes strenuous efforts to convert the data argument (&lt;code&gt;$_[4]&lt;/code&gt; ) to a usable form before passing it to the handler (but see &lt;a href=&quot;#Non-interpretive-attribute-handlers&quot;&gt;Non-interpretive attribute handlers&lt;/a&gt;). If those efforts succeed, the interpreted data is passed in an array reference; if they fail, the raw data is passed as a string. For example, all of these:</source>
          <target state="translated">Attribute :: Handlers는 데이터 인수 ( &lt;code&gt;$_[4]&lt;/code&gt; )를 처리기에 전달하기 전에 사용 가능한 형식 으로 변환하기 위해 많은 노력을 기울입니다 (그러나 &lt;a href=&quot;#Non-interpretive-attribute-handlers&quot;&gt;해석 할 수없는 속성 처리기 참조&lt;/a&gt; ). 이러한 노력이 성공하면 해석 된 데이터가 배열 참조로 전달됩니다. 실패하면 원시 데이터가 문자열로 전달됩니다. 예를 들어, 다음은 모두</target>
        </trans-unit>
        <trans-unit id="04790e00da71beac2f86333318faed6cfab890a0" translate="yes" xml:space="preserve">
          <source>Attribute::Handlers makes strenuous efforts to convert the data argument (&lt;code&gt;$_[4]&lt;/code&gt;) to a usable form before passing it to the handler (but see &lt;a href=&quot;#Non-interpretive-attribute-handlers&quot;&gt;&quot;Non-interpretive attribute handlers&quot;&lt;/a&gt;). If those efforts succeed, the interpreted data is passed in an array reference; if they fail, the raw data is passed as a string. For example, all of these:</source>
          <target state="translated">Attribute :: Handlers는 데이터 인수 ( &lt;code&gt;$_[4]&lt;/code&gt; )를 핸들러로 전달하기 전에 사용 가능한 형식 으로 변환하기 위해 열심히 노력 합니다 (그러나 &lt;a href=&quot;#Non-interpretive-attribute-handlers&quot;&gt;&quot;비 해석 속성 핸들러&quot;참조&lt;/a&gt; ). 이러한 노력이 성공하면 해석 된 데이터가 배열 참조로 전달됩니다. 실패하면 원시 데이터가 문자열로 전달됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a6652617f2c799eb11ee727b16c5646c48af6905" translate="yes" xml:space="preserve">
          <source>Attributes</source>
          <target state="translated">Attributes</target>
        </trans-unit>
        <trans-unit id="4ce085fab8976266bb7771327c95a06a2d92883d" translate="yes" xml:space="preserve">
          <source>Attributes :locked and :unique</source>
          <target state="translated">속성 : locked 및 : unique</target>
        </trans-unit>
        <trans-unit id="57744968c9ece6a6fd393a9a1f9a16852d8d26e2" translate="yes" xml:space="preserve">
          <source>Attributes &lt;code&gt;:locked&lt;/code&gt; and &lt;code&gt;:unique&lt;/code&gt;</source>
          <target state="translated">속성 &lt;code&gt;:locked&lt;/code&gt; 및 &lt;code&gt;:unique&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f65ce706012d5cc8515dbfba3f0c94b3cae90800" translate="yes" xml:space="preserve">
          <source>Attributes =&amp;gt; $sAttributes</source>
          <target state="translated">속성 =&amp;gt; $ sAttributes</target>
        </trans-unit>
        <trans-unit id="7096373d5156eb6bd0032a6f3f3f6f2306181c31" translate="yes" xml:space="preserve">
          <source>Attributes are often stored in the object itself. For example, if the object is an anonymous hash, we can store the attribute values in the hash using the attribute name as the key.</source>
          <target state="translated">속성은 종종 객체 자체에 저장됩니다. 예를 들어 객체가 익명 해시 인 경우 속성 이름을 키로 사용하여 속성 값을 해시에 저장할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1ec0e5f9458a3d0b7666b49e580f1e144a9409de" translate="yes" xml:space="preserve">
          <source>Attributes are typically defined as read-only or read-write. Read-only attributes can only be set when the object is first created, while read-write attributes can be altered at any time.</source>
          <target state="translated">속성은 일반적으로 읽기 전용 또는 읽기 / 쓰기로 정의됩니다. 읽기 전용 속성은 개체를 처음 만들 때만 설정할 수 있으며 읽기 / 쓰기 속성은 언제든지 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e7c79e72c9cbf686713260fcf1aae8a2f9a1a49e" translate="yes" xml:space="preserve">
          <source>Attributes as &lt;code&gt;&lt;a href=&quot;../functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; interfaces</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; 인터페이스 로서의 속성</target>
        </trans-unit>
        <trans-unit id="dd541d956cc1115542e113d51d19e51923523667" translate="yes" xml:space="preserve">
          <source>Attributes as &lt;code&gt;tie&lt;/code&gt; interfaces</source>
          <target state="translated">&lt;code&gt;tie&lt;/code&gt; 인터페이스 로서의 속성</target>
        </trans-unit>
        <trans-unit id="6e1c2a2200f4dc51bc987e61b1d0f256256aa8d5" translate="yes" xml:space="preserve">
          <source>Attributes as tie interfaces</source>
          <target state="translated">타이 인터페이스로서의 속성</target>
        </trans-unit>
        <trans-unit id="5d582f3d2d463609c927f60d4eb884597e89efea" translate="yes" xml:space="preserve">
          <source>Attributes make an excellent and intuitive interface through which to tie variables. For example:</source>
          <target state="translated">속성은 변수를 연결할 수있는 우수하고 직관적 인 인터페이스를 만듭니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="508a5aa4d3d540c30ef29d403ada44bf44ff7142" translate="yes" xml:space="preserve">
          <source>Attributes, once set, last until they are unset (by printing the attribute &lt;code&gt;clear&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../functions/reset&quot;&gt;reset&lt;/a&gt;&lt;/code&gt;). Be careful to do this, or otherwise your attribute will last after your script is done running, and people get very annoyed at having their prompt and typing changed to weird colors.</source>
          <target state="translated">한 번 설정된 속성은 설정이 취소 될 때까지 지속됩니다 (속성을 &lt;code&gt;clear&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;../functions/reset&quot;&gt;reset&lt;/a&gt;&lt;/code&gt; 인쇄하여 ). 이 작업을 조심하십시오. 그렇지 않으면 스크립트 실행이 끝난 후에도 속성이 지속되며 사람들은 프롬프트와 입력이 이상한 색으로 바뀌는 것에 매우 화가납니다.</target>
        </trans-unit>
        <trans-unit id="8aad82b8fbc6c4c52822cc8ecd0cf935a1127780" translate="yes" xml:space="preserve">
          <source>Attributes, once set, last until they are unset (by printing the attribute &lt;code&gt;clear&lt;/code&gt; or &lt;code&gt;reset&lt;/code&gt;). Be careful to do this, or otherwise your attribute will last after your script is done running, and people get very annoyed at having their prompt and typing changed to weird colors.</source>
          <target state="translated">일단 설정되면 속성은 설정 해제 될 때까지 지속됩니다 (속성 &lt;code&gt;clear&lt;/code&gt; 또는 &lt;code&gt;reset&lt;/code&gt; 인쇄 ). 이 작업을주의하십시오. 그렇지 않으면 스크립트가 실행 된 후에도 속성이 지속되고 사람들은 프롬프트와 입력이 이상한 색상으로 변경되는 것에 매우 짜증을냅니다.</target>
        </trans-unit>
        <trans-unit id="d51da1fd65173253fff2051ffdb2fb4742bcd89d" translate="yes" xml:space="preserve">
          <source>Audrey Tang</source>
          <target state="translated">오드리 탕</target>
        </trans-unit>
        <trans-unit id="1874e0336adde0a00ba3a60dae1dc775409600bd" translate="yes" xml:space="preserve">
          <source>Audrey Tang &amp;lt;cpan@audreyt.org&amp;gt;</source>
          <target state="translated">오드리 탕 &amp;lt;cpan@audreyt.org&amp;gt;</target>
        </trans-unit>
        <trans-unit id="f2cb213ffe5688a539a9e042d127473bf2e3ad45" translate="yes" xml:space="preserve">
          <source>August 2005</source>
          <target state="translated">2005 년 8 월</target>
        </trans-unit>
        <trans-unit id="7b22c9a35903363899da803d503fe897e1743fa7" translate="yes" xml:space="preserve">
          <source>August 23, 2005</source>
          <target state="translated">2005 년 8 월 23 일</target>
        </trans-unit>
        <trans-unit id="ceafb51e2b0783d53dd620019dff3aa66708a26f" translate="yes" xml:space="preserve">
          <source>Australia</source>
          <target state="translated">Australia</target>
        </trans-unit>
        <trans-unit id="593905b31972f6ffe58325abf98595caf4ebf458" translate="yes" xml:space="preserve">
          <source>Austria</source>
          <target state="translated">Austria</target>
        </trans-unit>
        <trans-unit id="95786e021d4a315fb9439c8c152d524cf9f59cc3" translate="yes" xml:space="preserve">
          <source>Authen::SASL is required for AUTH support.</source>
          <target state="translated">AUTH 지원에는 Authen :: SASL이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="21c24cd01488e77938199d2e43d1c1e07248317d" translate="yes" xml:space="preserve">
          <source>Authenticate with the server identifying as &lt;code&gt;USER&lt;/code&gt; with password &lt;code&gt;PASS&lt;/code&gt; . Similar to &lt;a href=&quot;#login&quot;&gt;login&lt;/a&gt;, but the password is not sent in clear text.</source>
          <target state="translated">비밀번호가 &lt;code&gt;PASS&lt;/code&gt; 인 &lt;code&gt;USER&lt;/code&gt; 로 식별되는 서버로 인증하십시오 . &lt;a href=&quot;#login&quot;&gt;login&lt;/a&gt; 과 유사 하지만 암호는 일반 텍스트로 전송되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2d308c897b8201e557fb3734cdc42302c1f694dd" translate="yes" xml:space="preserve">
          <source>Authenticate with the server identifying as &lt;code&gt;USER&lt;/code&gt; with password &lt;code&gt;PASS&lt;/code&gt;. Similar to &lt;a href=&quot;#login&quot;&gt;&quot;login&quot;&lt;/a&gt;, but the password is not sent in clear text.</source>
          <target state="translated">&lt;code&gt;PASS&lt;/code&gt; 암호 를 &lt;code&gt;USER&lt;/code&gt; 하여 USER 로 식별되는 서버로 인증 합니다 . &lt;a href=&quot;#login&quot;&gt;&quot;login&quot;&lt;/a&gt; 과 유사 하지만 비밀번호가 일반 텍스트로 전송되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="507f24ee32e393058ec2717e7ff642ddf8b1dd65" translate="yes" xml:space="preserve">
          <source>Authenticates to the server (using the original AUTHINFO USER / AUTHINFO PASS form, defined in RFC2980) using the supplied username and password. Please note that the password is sent in clear text to the server. This command should not be used with valuable passwords unless the connection to the server is somehow protected.</source>
          <target state="translated">제공된 사용자 이름과 비밀번호를 사용하여 서버에 인증합니다 (RFC2980에 정의 된 원래 AUTHINFO USER / AUTHINFO PASS 양식 사용). 비밀번호는 서버에 일반 텍스트로 전송됩니다. 서버 연결이 어떻게 든 보호되지 않는 한이 명령은 중요한 암호와 함께 사용해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="4be2c3e4a055e66e61888715b3835a0acb5d7f3e" translate="yes" xml:space="preserve">
          <source>Authenticates to the server (using the proposed NNTP V2 AUTHINFO SIMPLE form, defined and deprecated in RFC2980) using the supplied username and password. As with &lt;a href=&quot;#authinfo&quot;&gt;&quot;authinfo&quot;&lt;/a&gt; the password is sent in clear text.</source>
          <target state="translated">제공된 사용자 이름 및 비밀번호를 사용하여 서버에 인증합니다 (제안 된 NNTP V2 AUTHINFO SIMPLE 양식, RFC2980에서 정의 및 사용 중단됨). &lt;a href=&quot;#authinfo&quot;&gt;&quot;authinfo&quot;&lt;/a&gt; 와 마찬가지로 암호는 일반 텍스트로 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="6f9130bcae1a2dee757ab825f2972f22149b8d0e" translate="yes" xml:space="preserve">
          <source>Authenticates to the server (using the proposed NNTP V2 AUTHINFO SIMPLE form, defined and deprecated in RFC2980) using the supplied username and password. As with &lt;a href=&quot;#authinfo&quot;&gt;authinfo&lt;/a&gt; the password is sent in clear text.</source>
          <target state="translated">제공된 사용자 이름과 비밀번호를 사용하여 서버에 인증합니다 (RFC2980에서 정의되고 더 이상 사용되지 않는 제안 된 NNTP V2 AUTHINFO SIMPLE 양식 사용). &lt;a href=&quot;#authinfo&quot;&gt;authinfo&lt;/a&gt; 와 마찬가지로 암호는 일반 텍스트로 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="561e59b47284192d792d6315e83a8df1bb4623e9" translate="yes" xml:space="preserve">
          <source>Authentication, Security, and Encryption</source>
          <target state="translated">인증, 보안 및 암호화</target>
        </trans-unit>
        <trans-unit id="5fda23d62015b99fb2a9f86b38bcdf2bdf7609c8" translate="yes" xml:space="preserve">
          <source>Author</source>
          <target state="translated">Author</target>
        </trans-unit>
        <trans-unit id="a250719f5509f4b060ed02cea92bc61a08d442f3" translate="yes" xml:space="preserve">
          <source>Author and Copyright Information</source>
          <target state="translated">저자 및 저작권 정보</target>
        </trans-unit>
        <trans-unit id="fd140dad60fa77aa1adfbcd64d1e9ea4bc89ff62" translate="yes" xml:space="preserve">
          <source>Author and Maintainer: The Perl5-Porters &amp;lt;perl5-porters@perl.org&amp;gt;</source>
          <target state="translated">저자 및 관리자 : Perl5-Porters &amp;lt;perl5-porters@perl.org&amp;gt;</target>
        </trans-unit>
        <trans-unit id="e41e820954a6b297983a7b6986adfdc7c083ed60" translate="yes" xml:space="preserve">
          <source>Author and Modification History</source>
          <target state="translated">저자 및 수정 이력</target>
        </trans-unit>
        <trans-unit id="dc4e711f40af1fee4327bcbd34d91d11e1b38a81" translate="yes" xml:space="preserve">
          <source>Author of this software makes no claim whatsoever about suitability, reliability, edability, editability or usability of this product, and should not be kept liable for any damage resulting from the use of it. If you can use it, you are in luck, if not, I should not be kept responsible. Keep a handy copy of your backup tape at hand.</source>
          <target state="translated">이 소프트웨어의 저자는이 제품의 적합성, 신뢰성, 식용 성, 편집 성 또는 유용성에 대해 어떠한 주장도하지 않으며,이 제품의 사용으로 인한 손상에 대해 책임을지지 않습니다. 당신이 그것을 사용할 수 있다면, 당신은 운이 좋으며, 그렇지 않다면, 나는 책임을지지 않아야합니다. 편리한 백업 테이프 사본을 준비하십시오.</target>
        </trans-unit>
        <trans-unit id="75a1f723a2c00ab3f9e540ebe5e3b630e531e2c3" translate="yes" xml:space="preserve">
          <source>Author: Mark Jason Dominus, Plover Systems (&lt;code&gt;mjd-perl-&lt;a href=&quot;functions/ref&quot;&gt;ref&lt;/a&gt;+@plover.com&lt;/code&gt; )</source>
          <target state="translated">저자 : Mark Jason Dominus, Plover Systems ( &lt;code&gt;mjd-perl-&lt;a href=&quot;functions/ref&quot;&gt;ref&lt;/a&gt;+@plover.com&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="b0d417f355d7d062d5dedda5f6e9d6e446d1132a" translate="yes" xml:space="preserve">
          <source>Author: Mark Jason Dominus, Plover Systems (&lt;code&gt;mjd-perl-ref+@plover.com&lt;/code&gt;)</source>
          <target state="translated">작성자 : Mark Jason Dominus, Plover Systems ( &lt;code&gt;mjd-perl-ref+@plover.com&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="d2a52548bd0852b99153ddd79a1f550f70674c7d" translate="yes" xml:space="preserve">
          <source>Authors</source>
          <target state="translated">Authors</target>
        </trans-unit>
        <trans-unit id="4e4bc3d81e572248f45b55f87eb6a695cc5d7e17" translate="yes" xml:space="preserve">
          <source>Authors must not nest L&amp;lt;...&amp;gt; codes. For example, &quot;L&amp;lt;The L&amp;lt;Foo::Bar&amp;gt; man page&amp;gt;&quot; should be treated as an error.</source>
          <target state="translated">작성자는 L &amp;lt;...&amp;gt; 코드를 중첩해서는 안됩니다. 예를 들어 &quot;L &amp;lt;The L &amp;lt;Foo :: Bar&amp;gt; man page&amp;gt;&quot;는 오류로 처리해야합니다.</target>
        </trans-unit>
        <trans-unit id="9a1f2888146e0b82120ccf28bf4584779813130b" translate="yes" xml:space="preserve">
          <source>Authors of Pod formatters are reminded that &quot;=over&quot; ... &quot;=back&quot; may map to several different constructs in your output format. For example, in converting Pod to (X)HTML, it can map to any of &amp;lt;ul&amp;gt;...&amp;lt;/ul&amp;gt;, &amp;lt;ol&amp;gt;...&amp;lt;/ol&amp;gt;, &amp;lt;dl&amp;gt;...&amp;lt;/dl&amp;gt;, or &amp;lt;blockquote&amp;gt;...&amp;lt;/blockquote&amp;gt;. Similarly, &quot;=item&quot; can map to &amp;lt;li&amp;gt; or &amp;lt;dt&amp;gt;.</source>
          <target state="translated">포드 포맷터 작성자는 &quot;= over&quot;... &quot;= back&quot;이 출력 형식의 여러 다른 구성에 매핑 될 수 있음을 상기시킵니다. 예를 들어 포드를 (X) HTML로 변환 할 때 &amp;lt;ul&amp;gt; ... &amp;lt;/ ul&amp;gt;, &amp;lt;ol&amp;gt; ... &amp;lt;/ ol&amp;gt;, &amp;lt;dl&amp;gt; ... &amp;lt;/ dl&amp;gt; 중 하나로 매핑 할 수 있습니다. 또는 &amp;lt;blockquote&amp;gt; ... &amp;lt;/ blockquote&amp;gt;입니다. 마찬가지로 &quot;= item&quot;은 &amp;lt;li&amp;gt; 또는 &amp;lt;dt&amp;gt;에 매핑 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="80bad0a974c0d7ed8e69ae0a2451cf949509d806" translate="yes" xml:space="preserve">
          <source>Authors of Pod formatters should note that this construct:</source>
          <target state="translated">포드 포맷터 작성자는이 구성에 유의해야합니다.</target>
        </trans-unit>
        <trans-unit id="0772af8ca884a475bc6c000e8a2e7ecd3771d821" translate="yes" xml:space="preserve">
          <source>Authors of Pod formatters/processors should make every effort to avoid writing their own Pod parser. There are already several in CPAN, with a wide range of interface styles -- and one of them, Pod::Parser, comes with modern versions of Perl.</source>
          <target state="translated">포드 포맷터 / 프로세서 작성자는 자신의 포드 파서를 작성하지 않도록 모든 노력을 기울여야합니다. CPAN에는 이미 다양한 인터페이스 스타일을 가진 몇 가지가 있으며 그 중 하나 인 Pod :: Parser는 최신 버전의 Perl과 함께 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="ee6ba2eca154c452d912ba72284ef9425f5cac4c" translate="yes" xml:space="preserve">
          <source>Authors of Pod formatters/processors should make every effort to avoid writing their own Pod parser. There are already several in CPAN, with a wide range of interface styles -- and one of them, Pod::Simple, comes with modern versions of Perl.</source>
          <target state="translated">포드 포맷터 / 프로세서 작성자는 자신의 포드 파서를 작성하지 않도록 모든 노력을 기울여야합니다. 다양한 인터페이스 스타일을 가진 CPAN에는 이미 여러 가지가 있으며 그중 하나 인 Pod :: Simple은 최신 버전의 Perl과 함께 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="5f5a6b2c86d1c842fb78879cb9847a9b86de0e1d" translate="yes" xml:space="preserve">
          <source>Authors of formatter subclasses might find these methods useful to call on a parser object that you haven't started pulling tokens from yet:</source>
          <target state="translated">포맷터 서브 클래스 작성자는 아직 토큰을 가져 오기 시작하지 않은 파서 객체를 호출하는 데 유용한 이러한 메소드를 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ba749f31a8ceaa34419e1f1f52af7da1b1065181" translate="yes" xml:space="preserve">
          <source>Auto-decrement of the value in the SV, doing string to numeric conversion if necessary. Handles 'get' magic and operator overloading.</source>
          <target state="translated">필요한 경우 문자열을 숫자로 변환하여 SV의 값을 자동 감소시킵니다. 'get'매직 및 연산자 오버로드를 처리합니다.</target>
        </trans-unit>
        <trans-unit id="cabef034701dc195b619657e11c47b3b4c7ed2cb" translate="yes" xml:space="preserve">
          <source>Auto-decrement of the value in the SV, doing string to numeric conversion if necessary. Handles operator overloading. Skips handling 'get' magic.</source>
          <target state="translated">필요한 경우 문자열을 숫자로 변환하여 SV의 값을 자동 감소시킵니다. 연산자 과부하를 처리합니다. 'get'매직 처리를 건너 뜁니다.</target>
        </trans-unit>
        <trans-unit id="f8df54de50b8630f73dd7c3210d2ed53c7051734" translate="yes" xml:space="preserve">
          <source>Auto-increment and Auto-decrement</source>
          <target state="translated">자동 증가 및 자동 감소</target>
        </trans-unit>
        <trans-unit id="9c2549c4f8e7b5156ddcd16c47fe624753b70037" translate="yes" xml:space="preserve">
          <source>Auto-increment of the value in the SV, doing string to numeric conversion if necessary. Handles 'get' magic and operator overloading.</source>
          <target state="translated">필요한 경우 문자열을 숫자로 변환하여 SV의 값을 자동 증가시킵니다. 'get'매직 및 연산자 오버로드를 처리합니다.</target>
        </trans-unit>
        <trans-unit id="11123412c221a7c2bf77f34ba93ea1498be1bd77" translate="yes" xml:space="preserve">
          <source>Auto-increment of the value in the SV, doing string to numeric conversion if necessary. Handles operator overloading. Skips handling 'get' magic.</source>
          <target state="translated">필요한 경우 문자열을 숫자로 변환하여 SV의 값을 자동 증가시킵니다. 연산자 과부하를 처리합니다. 'get'매직 처리를 건너 뜁니다.</target>
        </trans-unit>
        <trans-unit id="95b64723d9f40505396f5971cbc44d69372e59a7" translate="yes" xml:space="preserve">
          <source>Auto-upgrade</source>
          <target state="translated">Auto-upgrade</target>
        </trans-unit>
        <trans-unit id="57a4f42cae4d12771bda9f458a5b76498da8ce37" translate="yes" xml:space="preserve">
          <source>AutoLoader</source>
          <target state="translated">AutoLoader</target>
        </trans-unit>
        <trans-unit id="4bbd7ae289ef059e5890696f9cb149721a7b8e69" translate="yes" xml:space="preserve">
          <source>AutoLoader - load subroutines only on demand</source>
          <target state="translated">오토로더-필요할 때만 서브 루틴로드</target>
        </trans-unit>
        <trans-unit id="6851ab5ce9e022d9cc5797875048cf4a3f08af3e" translate="yes" xml:space="preserve">
          <source>AutoLoader may fail to find the autosplit files (or even find the wrong ones) in cases where &lt;code&gt;@INC&lt;/code&gt; contains relative paths, &lt;b&gt;and&lt;/b&gt; the program does &lt;code&gt;&lt;a href=&quot;functions/chdir&quot;&gt;chdir&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;@INC&lt;/code&gt; 에 상대 경로가 &lt;b&gt;있고&lt;/b&gt; 프로그램이 &lt;code&gt;&lt;a href=&quot;functions/chdir&quot;&gt;chdir&lt;/a&gt;&lt;/code&gt; 을 수행하는 경우 AutoLoader가 자동 분할 파일을 찾지 못하거나 심지어 잘못된 파일을 찾지 못할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4651f865ebaf11dee249fb89b162cf3da62c9078" translate="yes" xml:space="preserve">
          <source>AutoLoader may fail to find the autosplit files (or even find the wrong ones) in cases where &lt;code&gt;@INC&lt;/code&gt; contains relative paths, &lt;b&gt;and&lt;/b&gt; the program does &lt;code&gt;chdir&lt;/code&gt;.</source>
          <target state="translated">자동로드는 자동 구분 파일을 찾을 실패 (또는 잘못된 사람 찾기) 곳의 경우를 수 &lt;code&gt;@INC&lt;/code&gt; 상대 경로를 포함 &lt;b&gt;하고&lt;/b&gt; 프로그램을 수행합니다 &lt;code&gt;chdir&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5080d78f65857a5bb4650061f6068b73782d0765" translate="yes" xml:space="preserve">
          <source>AutoLoader vs. SelfLoader</source>
          <target state="translated">AutoLoader 대 SelfLoader</target>
        </trans-unit>
        <trans-unit id="8a635037412af6ace383fa21d0d50db8f0393e57" translate="yes" xml:space="preserve">
          <source>AutoLoaders prior to Perl 5.002 had a slightly different interface. Any old modules which use &lt;b&gt;AutoLoader&lt;/b&gt; should be changed to the new calling style. Typically this just means changing a require to a use, adding the explicit &lt;code&gt;'AUTOLOAD'&lt;/code&gt; import if needed, and removing &lt;b&gt;AutoLoader&lt;/b&gt; from &lt;code&gt;@ISA&lt;/code&gt; .</source>
          <target state="translated">Perl 5.002 이전의 오토로더는 인터페이스가 약간 다릅니다. &lt;b&gt;AutoLoader&lt;/b&gt; 를 사용하는 이전 모듈 은 새로운 호출 스타일로 변경해야합니다. 일반적으로 이것은 요구 사항을 용도로 변경하고 필요한 경우 명시 적 &lt;code&gt;'AUTOLOAD'&lt;/code&gt; 가져 오기를 추가하고 &lt;code&gt;@ISA&lt;/code&gt; 에서 &lt;b&gt;AutoLoader&lt;/b&gt; 를 제거하는 것을 의미 합니다.</target>
        </trans-unit>
        <trans-unit id="7e1e103fc57cef534d77a1863a7beda04c276011" translate="yes" xml:space="preserve">
          <source>AutoLoaders prior to Perl 5.002 had a slightly different interface. Any old modules which use &lt;b&gt;AutoLoader&lt;/b&gt; should be changed to the new calling style. Typically this just means changing a require to a use, adding the explicit &lt;code&gt;'AUTOLOAD'&lt;/code&gt; import if needed, and removing &lt;b&gt;AutoLoader&lt;/b&gt; from &lt;code&gt;@ISA&lt;/code&gt;.</source>
          <target state="translated">Perl 5.002 이전의 자동 로더는 인터페이스가 약간 다릅니다. &lt;b&gt;AutoLoader&lt;/b&gt; 를 사용하는 이전 모듈 은 새 호출 스타일로 변경해야합니다. 일반적으로 이것은 요구 사항을 용도로 변경하고 필요한 경우 명시 적 &lt;code&gt;'AUTOLOAD'&lt;/code&gt; 가져 오기를 추가하고 &lt;code&gt;@ISA&lt;/code&gt; 에서 &lt;b&gt;AutoLoader&lt;/b&gt; 를 제거하는 것을 의미 합니다.</target>
        </trans-unit>
        <trans-unit id="56be52307d7f516628d0435d04dbf15ef2be8e1c" translate="yes" xml:space="preserve">
          <source>AutoSplit</source>
          <target state="translated">AutoSplit</target>
        </trans-unit>
        <trans-unit id="141ac9ea73e406af3a95ffd453d7845aea91bee3" translate="yes" xml:space="preserve">
          <source>AutoSplit - split a package for autoloading</source>
          <target state="translated">AutoSplit-자동로드를 위해 패키지 분할</target>
        </trans-unit>
        <trans-unit id="68a652cb711d8eb8f8b2dadb0dc16bdffbba498d" translate="yes" xml:space="preserve">
          <source>Autocreating constants</source>
          <target state="translated">상수 자동 생성</target>
        </trans-unit>
        <trans-unit id="52fe0335e51acfb62f3dfd3073b3227b5b8c4846" translate="yes" xml:space="preserve">
          <source>Autodeferring</source>
          <target state="translated">Autodeferring</target>
        </trans-unit>
        <trans-unit id="f3589c4e74b1463fb3c579cd588ce9598fdbe87e" translate="yes" xml:space="preserve">
          <source>Autodie uses a simple set of categories to group together similar built-ins. Requesting a category type (starting with a colon) will enable autodie for all built-ins beneath that category. For example, requesting &lt;code&gt;:file&lt;/code&gt; will enable autodie for &lt;code&gt;&lt;a href=&quot;functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/fcntl&quot;&gt;fcntl&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/sysopen&quot;&gt;sysopen&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Autodie는 간단한 카테고리 세트를 사용하여 유사한 내장 기능을 그룹화합니다. 콜론으로 시작하는 카테고리 유형을 요청하면 해당 카테고리 아래의 모든 내장 기능에 대해 자동 다이를 사용할 수 있습니다. 예를 들어, &lt;code&gt;:file&lt;/code&gt; 을 요청 하면 &lt;code&gt;&lt;a href=&quot;functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/fcntl&quot;&gt;fcntl&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;functions/sysopen&quot;&gt;sysopen&lt;/a&gt;&lt;/code&gt; 에.</target>
        </trans-unit>
        <trans-unit id="d86d0ceb4ab6dfa49a2928ed69a6b234345c4271" translate="yes" xml:space="preserve">
          <source>Autodie uses a simple set of categories to group together similar built-ins. Requesting a category type (starting with a colon) will enable autodie for all built-ins beneath that category. For example, requesting &lt;code&gt;:file&lt;/code&gt; will enable autodie for &lt;code&gt;close&lt;/code&gt;, &lt;code&gt;fcntl&lt;/code&gt;, &lt;code&gt;open&lt;/code&gt; and &lt;code&gt;sysopen&lt;/code&gt;.</source>
          <target state="translated">Autodie는 간단한 범주 집합을 사용하여 유사한 내장 기능을 함께 그룹화합니다. 범주 유형 (콜론으로 시작)을 요청하면 해당 범주 아래의 모든 내장 기능에 대해 자동 실행이 활성화됩니다. 예를 들어 &lt;code&gt;:file&lt;/code&gt; 을 요청 하면 &lt;code&gt;close&lt;/code&gt; , &lt;code&gt;fcntl&lt;/code&gt; , &lt;code&gt;open&lt;/code&gt; 및 &lt;code&gt;sysopen&lt;/code&gt; 에 대해 autodie가 활성화됩니다 .</target>
        </trans-unit>
        <trans-unit id="f410fe9b046b8c8a478048e83efc2672d42d3c9c" translate="yes" xml:space="preserve">
          <source>Autodying &lt;code&gt;&lt;a href=&quot;functions/flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; will generate an exception if &lt;code&gt;&lt;a href=&quot;functions/flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; returns false with any other error.</source>
          <target state="translated">Autodying &lt;code&gt;&lt;a href=&quot;functions/flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; 경우 예외를 생성 &lt;code&gt;&lt;a href=&quot;functions/flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; 다른 오류와 false를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="dfa0c806bb2bafe199faa77554873951783b04df" translate="yes" xml:space="preserve">
          <source>Autodying &lt;code&gt;flock&lt;/code&gt; will generate an exception if &lt;code&gt;flock&lt;/code&gt; returns false with any other error.</source>
          <target state="translated">Autodying &lt;code&gt;flock&lt;/code&gt; 경우 예외를 생성 &lt;code&gt;flock&lt;/code&gt; 다른 오류와 false를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="3fa81ba949fafdad4688aed6d9380f82976ca9d7" translate="yes" xml:space="preserve">
          <source>Autoloading</source>
          <target state="translated">Autoloading</target>
        </trans-unit>
        <trans-unit id="a71f8461a563c747e56f2cb5fb124e64328506d5" translate="yes" xml:space="preserve">
          <source>Autoloading and package lexicals</source>
          <target state="translated">어휘 자동로드 및 패키지</target>
        </trans-unit>
        <trans-unit id="24023d5e4bccdad4a40c403d058e7c856f75ea71" translate="yes" xml:space="preserve">
          <source>Autoloading with XSUBs</source>
          <target state="translated">XSUB로 자동로드</target>
        </trans-unit>
        <trans-unit id="ea5735f59ad896a38c6b806f8d8b02abba9762e7" translate="yes" xml:space="preserve">
          <source>Automatic binary installation</source>
          <target state="translated">자동 바이너리 설치</target>
        </trans-unit>
        <trans-unit id="e7b3540721074f2b16f8319edcdb7f16ebcac6ca" translate="yes" xml:space="preserve">
          <source>Automatic filehandle closure</source>
          <target state="translated">자동 파일 핸들 잠금</target>
        </trans-unit>
        <trans-unit id="4347ed90164094c8291f74a6e4466cefbf468214" translate="yes" xml:space="preserve">
          <source>Automatic pipe flushing</source>
          <target state="translated">자동 파이프 플러싱</target>
        </trans-unit>
        <trans-unit id="b890d9b67b4f885e928a5dbcadc3dec7cd34f3ad" translate="yes" xml:space="preserve">
          <source>Automatically generate XSUBs basing on function declarations in the header file. The package &lt;code&gt;C::Scan&lt;/code&gt; should be installed. If this option is specified, the name of the header file may look like &lt;code&gt;NAME1,NAME2&lt;/code&gt; . In this case NAME1 is used instead of the specified string, but XSUBs are emitted only for the declarations included from file NAME2.</source>
          <target state="translated">헤더 파일에서 함수 선언을 기반으로 XSUB를 자동으로 생성합니다. &lt;code&gt;C::Scan&lt;/code&gt; 패키지 가 설치되어 있어야합니다. 이 옵션을 지정하면 헤더 파일 이름이 &lt;code&gt;NAME1,NAME2&lt;/code&gt; 와 같이 보일 수 있습니다 . 이 경우 지정된 문자열 대신 NAME1이 사용되지만 파일 NAME2에 포함 된 선언에 대해서만 XSUB가 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="5d64745dc0e8fe8b3b6097336c3b9ed3a673cecd" translate="yes" xml:space="preserve">
          <source>Automatically generate XSUBs basing on function declarations in the header file. The package &lt;code&gt;C::Scan&lt;/code&gt; should be installed. If this option is specified, the name of the header file may look like &lt;code&gt;NAME1,NAME2&lt;/code&gt;. In this case NAME1 is used instead of the specified string, but XSUBs are emitted only for the declarations included from file NAME2.</source>
          <target state="translated">헤더 파일의 함수 선언을 기반으로 XSUB를 자동으로 생성합니다. &lt;code&gt;C::Scan&lt;/code&gt; 패키지를 설치해야합니다. 이 옵션이 지정되면 헤더 파일의 이름은 &lt;code&gt;NAME1,NAME2&lt;/code&gt; 와 같이 보일 수 있습니다 . 이 경우 지정된 문자열 대신 NAME1이 사용되지만 XSUB는 파일 NAME2에서 포함 된 선언에 대해서만 내 보냅니다.</target>
        </trans-unit>
        <trans-unit id="974a6c8e46a4b4db1ad3a13139d3950f13a09a91" translate="yes" xml:space="preserve">
          <source>Automatically provide support for the &lt;b&gt;--help&lt;/b&gt; and &lt;b&gt;-?&lt;/b&gt; options if the application did not specify a handler for this option itself.</source>
          <target state="translated">에 대한 자동 지원 제공 &lt;b&gt;--help&lt;/b&gt; 및 &lt;b&gt;-?&lt;/b&gt;애플리케이션이이 옵션 자체에 대한 핸들러를 지정하지 않은 경우 옵션.</target>
        </trans-unit>
        <trans-unit id="909a15529b11dbad33480554d0c112bc56821029" translate="yes" xml:space="preserve">
          <source>Automatically provide support for the &lt;b&gt;--version&lt;/b&gt; option if the application did not specify a handler for this option itself.</source>
          <target state="translated">응용 프로그램이이 옵션 자체에 대한 처리기를 지정하지 않은 경우 &lt;b&gt;--version&lt;/b&gt; 옵션 을 자동으로 지원 합니다.</target>
        </trans-unit>
        <trans-unit id="859ddcc1d54c8f56f6fc79d681322ff6800ab918" translate="yes" xml:space="preserve">
          <source>Autoties are most commonly used in the module to which they actually tie, and need to export their attributes to any module that calls them. To facilitate this, Attribute::Handlers recognizes a special &quot;pseudo-class&quot; -- &lt;code&gt;__CALLER__&lt;/code&gt; , which may be specified as the qualifier of an attribute:</source>
          <target state="translated">autoties는 실제로 묶는 모듈에서 가장 일반적으로 사용되며 속성을 호출하는 모든 모듈로 속성을 내 보내야합니다. 이를 촉진하기 위해 Attribute :: Handlers는 특별한 &quot;의사 클래스&quot;를 인식합니다. &lt;code&gt;__CALLER__&lt;/code&gt; , 이는 속성의 규정 자로 지정 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="caebe3a78fcebc80600d1c2befdf4f9537e79eaa" translate="yes" xml:space="preserve">
          <source>Autoties are most commonly used in the module to which they actually tie, and need to export their attributes to any module that calls them. To facilitate this, Attribute::Handlers recognizes a special &quot;pseudo-class&quot; -- &lt;code&gt;__CALLER__&lt;/code&gt;, which may be specified as the qualifier of an attribute:</source>
          <target state="translated">Autoties는 실제로 연결된 모듈에서 가장 일반적으로 사용되며 해당 속성을 호출하는 모듈로 내 보내야합니다. 이를 용이하게하기 위해 Attribute :: Handlers는 특수한 &quot;의사 클래스&quot; &lt;code&gt;__CALLER__&lt;/code&gt; 인식하며 , 이는 속성의 한정자로 지정 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b404ad26695e85bc7cc28bdc0dded7208f879f3b" translate="yes" xml:space="preserve">
          <source>Autovivification</source>
          <target state="translated">Autovivification</target>
        </trans-unit>
        <trans-unit id="bf3b722c40bbbb50ad0fb62696f5d22f07dbb403" translate="yes" xml:space="preserve">
          <source>AvFILL</source>
          <target state="translated">AvFILL</target>
        </trans-unit>
        <trans-unit id="90bf7946c287adae3d715c64ee31d396014df2f6" translate="yes" xml:space="preserve">
          <source>AvFILLp</source>
          <target state="translated">AvFILLp</target>
        </trans-unit>
        <trans-unit id="c275699a9fcc5b1df221a4afe6ee0192241a51b8" translate="yes" xml:space="preserve">
          <source>Available Plugins</source>
          <target state="translated">사용 가능한 플러그인</target>
        </trans-unit>
        <trans-unit id="3f5fe2a468e50383b2ee86c82b0cbc98dd7d8c3d" translate="yes" xml:space="preserve">
          <source>Available Since 0.05.</source>
          <target state="translated">0.05부터 사용 가능합니다.</target>
        </trans-unit>
        <trans-unit id="a1689bbab8d96444cb240ecc94b27e3bd6e1fa9d" translate="yes" xml:space="preserve">
          <source>Available Subroutines</source>
          <target state="translated">사용 가능한 서브 루틴</target>
        </trans-unit>
        <trans-unit id="f8f5117038c185bf68b0bd33b349f9405e133955" translate="yes" xml:space="preserve">
          <source>Available exports</source>
          <target state="translated">사용 가능한 수출</target>
        </trans-unit>
        <trans-unit id="00239624abff2fe9a2fd406296f776638259fff8" translate="yes" xml:space="preserve">
          <source>Available in Perls 5.8.1 and later. If set to &lt;code&gt;&quot;unsafe&quot;&lt;/code&gt; , the pre-Perl-5.8.0 signal behaviour (which is immediate but unsafe) is restored. If set to &lt;code&gt;safe&lt;/code&gt; , then safe (but deferred) signals are used. See &lt;a href=&quot;perlipc#Deferred-Signals-(Safe-Signals)&quot;&gt;Deferred Signals (Safe Signals) in perlipc&lt;/a&gt;.</source>
          <target state="translated">Perls 5.8.1 이상에서 사용 가능합니다. &lt;code&gt;&quot;unsafe&quot;&lt;/code&gt; 로 설정하면 Per--5.8.0 이전 신호 동작 (즉시 안전하지만 안전하지 않음)이 복원됩니다. &lt;code&gt;safe&lt;/code&gt; 로 설정되면 안전 하지만 지연된 신호가 사용됩니다. &lt;a href=&quot;perlipc#Deferred-Signals-(Safe-Signals)&quot;&gt;perlipc의 지연된 신호 (안전 신호)를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="86ef598431b2f464d3fea7c4a79b483722ad9f02" translate="yes" xml:space="preserve">
          <source>Available in Perls 5.8.1 and later. If set to &lt;code&gt;&quot;unsafe&quot;&lt;/code&gt;, the pre-Perl-5.8.0 signal behaviour (which is immediate but unsafe) is restored. If set to &lt;code&gt;safe&lt;/code&gt;, then safe (but deferred) signals are used. See &lt;a href=&quot;perlipc#Deferred-Signals-%28Safe-Signals%29&quot;&gt;&quot;Deferred Signals (Safe Signals)&quot; in perlipc&lt;/a&gt;.</source>
          <target state="translated">Perls 5.8.1 이상에서 사용할 수 있습니다. &lt;code&gt;&quot;unsafe&quot;&lt;/code&gt; 로 설정하면 Perl-5.8.0 이전 신호 동작 (즉시 적이지만 안전하지 않음)이 복원됩니다. &lt;code&gt;safe&lt;/code&gt; 로 설정하면 안전한 (그러나 지연된) 신호가 사용됩니다. 참조 &lt;a href=&quot;perlipc#Deferred-Signals-%28Safe-Signals%29&quot;&gt;perlipc에서 &quot;이연 신호 (안전 신호를)&quot;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="06d7ad8e1c503f30109967f01a5055e60c428ad2" translate="yes" xml:space="preserve">
          <source>Available in version 2.22 and above.</source>
          <target state="translated">버전 2.22 이상에서 사용 가능합니다.</target>
        </trans-unit>
        <trans-unit id="ca47c0994a656fab74100d8043c17430984bfc08" translate="yes" xml:space="preserve">
          <source>Available in version 2.32 and above</source>
          <target state="translated">버전 2.32 이상에서 사용 가능</target>
        </trans-unit>
        <trans-unit id="6a2ef8d70aa0a54d8ffae1859cac80b4b3ca0c60" translate="yes" xml:space="preserve">
          <source>Available in version 2.66 and above.</source>
          <target state="translated">버전 2.66 이상에서 사용 가능합니다.</target>
        </trans-unit>
        <trans-unit id="46f1e6d4a99c839646d86f37c67e8ce5c790c2f7" translate="yes" xml:space="preserve">
          <source>Available in version 2.77 and above.</source>
          <target state="translated">버전 2.77 이상에서 사용 가능합니다.</target>
        </trans-unit>
        <trans-unit id="1ee0ed3a84dce710c7a16f8db82978050c4d2850" translate="yes" xml:space="preserve">
          <source>Available in version 2.99 and above.</source>
          <target state="translated">버전 2.99 이상에서 사용 가능합니다.</target>
        </trans-unit>
        <trans-unit id="d74a27e4b35b5f01b8ce5c3169c1b5a135f15fe4" translate="yes" xml:space="preserve">
          <source>Available in version 3.00 and above.</source>
          <target state="translated">버전 3.00 이상에서 사용 가능합니다.</target>
        </trans-unit>
        <trans-unit id="a51b57f95b46e8e4e842d85639326f6206ff272d" translate="yes" xml:space="preserve">
          <source>Available in version 6.18 and above.</source>
          <target state="translated">버전 6.18 이상에서 사용 가능합니다.</target>
        </trans-unit>
        <trans-unit id="c501834b7b0b901f2df0d6603e7d6136330ca271" translate="yes" xml:space="preserve">
          <source>Available in version 6.30_01 and above.</source>
          <target state="translated">버전 6.30_01 이상에서 사용 가능합니다.</target>
        </trans-unit>
        <trans-unit id="fe2902c53bc06bcbcd50a3060b02d4d1a785d162" translate="yes" xml:space="preserve">
          <source>Available in version 6.30_02 and above.</source>
          <target state="translated">버전 6.30_02 이상에서 사용 가능합니다.</target>
        </trans-unit>
        <trans-unit id="eb07b303f6d617426c6371968300dfb4f3ae0614" translate="yes" xml:space="preserve">
          <source>Available in version 6.31 and above.</source>
          <target state="translated">버전 6.31 이상에서 사용 가능합니다.</target>
        </trans-unit>
        <trans-unit id="e2eb2ee2a8a2421e0f16491afdee27929c55a640" translate="yes" xml:space="preserve">
          <source>Available in version 6.46 and above.</source>
          <target state="translated">버전 6.46 이상에서 사용 가능합니다.</target>
        </trans-unit>
        <trans-unit id="7b80e477803719c627e591ee3d93e9c48ad902d2" translate="yes" xml:space="preserve">
          <source>Available in version 6.48 and above.</source>
          <target state="translated">버전 6.48 이상에서 사용 가능합니다.</target>
        </trans-unit>
        <trans-unit id="6813343f2b8479035fb49fea7be4fff847bf5d84" translate="yes" xml:space="preserve">
          <source>Available in version 6.51_01 and above.</source>
          <target state="translated">버전 6.51_01 이상에서 사용 가능합니다.</target>
        </trans-unit>
        <trans-unit id="aec275cec443caa644465799fc156b88fcadd8ce" translate="yes" xml:space="preserve">
          <source>Available in version 6.52 and above.</source>
          <target state="translated">버전 6.52 이상에서 사용 가능합니다.</target>
        </trans-unit>
        <trans-unit id="4c5736820a885b4b84bf41953dc520dbc9201d97" translate="yes" xml:space="preserve">
          <source>Available in version 6.5503 and above.</source>
          <target state="translated">버전 6.5503 이상에서 사용 가능합니다.</target>
        </trans-unit>
        <trans-unit id="50ef4d62519ad32b490887468033714841e5c394" translate="yes" xml:space="preserve">
          <source>Available in version 6.55_03 and above.</source>
          <target state="translated">버전 6.55_03 이상에서 사용 가능합니다.</target>
        </trans-unit>
        <trans-unit id="b94a4ea271ebeb34f1da9b94033460c66ab594da" translate="yes" xml:space="preserve">
          <source>Available in version 6.57_02 and above.</source>
          <target state="translated">버전 6.57_02 이상에서 사용 가능합니다.</target>
        </trans-unit>
        <trans-unit id="608b36cf2b4b343801fc146cfc4244281c6223d0" translate="yes" xml:space="preserve">
          <source>Available in version 6.64 and above.</source>
          <target state="translated">버전 6.64 이상에서 사용 가능합니다.</target>
        </trans-unit>
        <trans-unit id="35008f0927cc370d80fa1feb2cb101b493da804e" translate="yes" xml:space="preserve">
          <source>Available in version 6.7501 and above.</source>
          <target state="translated">버전 6.7501 이상에서 사용 가능합니다.</target>
        </trans-unit>
        <trans-unit id="8a0f8c774f58768a8219ed32fc69bb6c645c818c" translate="yes" xml:space="preserve">
          <source>Available in version 6.8305 and above.</source>
          <target state="translated">버전 6.8305 이상에서 사용 가능합니다.</target>
        </trans-unit>
        <trans-unit id="b1a55162e32a4d313034aeda2facf36c09febf1e" translate="yes" xml:space="preserve">
          <source>Available in version 6.8502 and above.</source>
          <target state="translated">버전 6.8502 이상에서 사용 가능합니다.</target>
        </trans-unit>
        <trans-unit id="3781d883fbe89e1fc4d95fc3c8a343771b42879b" translate="yes" xml:space="preserve">
          <source>Available in version 7.12 and above.</source>
          <target state="translated">버전 7.12 이상에서 사용 가능합니다.</target>
        </trans-unit>
        <trans-unit id="0d6ce3bbbc75b8e9071a24da666baed09d9b758d" translate="yes" xml:space="preserve">
          <source>Available on 64 bit OpenVMS 8.2 and later. (VMS)</source>
          <target state="translated">64 비트 OpenVMS 8.2 이상에서 사용 가능합니다. (VMS)</target>
        </trans-unit>
        <trans-unit id="61cd670e85d7eb394067cdccaf9865a921e8dfe4" translate="yes" xml:space="preserve">
          <source>Available only for socket handles, and it does what the &lt;code&gt;ioctlsocket()&lt;/code&gt; call in the Winsock API does. (Win32)</source>
          <target state="translated">소켓 핸들에만 사용 가능 하며 Winsock API에서 &lt;code&gt;ioctlsocket()&lt;/code&gt; 호출이 수행하는 작업을 수행합니다. (Win32)</target>
        </trans-unit>
        <trans-unit id="7ff7a29d7d279f81c65111e3969b0de8be5b1d10" translate="yes" xml:space="preserve">
          <source>Available only for socket handles. (RISC OS)</source>
          <target state="translated">소켓 핸들에만 사용 가능합니다. (RISC OS)</target>
        </trans-unit>
        <trans-unit id="9f1e3ff1138fe80a24c7ddf73407362168941db0" translate="yes" xml:space="preserve">
          <source>Available only under threaded builds, this function allocates an entry in &lt;code&gt;PL_stashpad&lt;/code&gt; for the stash passed to it.</source>
          <target state="translated">스레드 빌드에서만 사용할 수있는이 함수는 전달 된 숨김에 대해 &lt;code&gt;PL_stashpad&lt;/code&gt; 에 항목을 할당 합니다.</target>
        </trans-unit>
        <trans-unit id="24db3617e94fd8213371a29596a3d186b94b903d" translate="yes" xml:space="preserve">
          <source>Available since 0.05.</source>
          <target state="translated">0.05부터 사용 가능합니다.</target>
        </trans-unit>
        <trans-unit id="8904628a4cafc1997d22ed36de689160cc550e45" translate="yes" xml:space="preserve">
          <source>Available since 0.14.</source>
          <target state="translated">0.14부터 사용 가능합니다.</target>
        </trans-unit>
        <trans-unit id="47b9977311f14febdb908b3d7c8768e488ba1bdf" translate="yes" xml:space="preserve">
          <source>Available since 0.15.</source>
          <target state="translated">0.15부터 사용 가능합니다.</target>
        </trans-unit>
        <trans-unit id="484973f71a15c235b16dffbc3bc34be0d16c15f0" translate="yes" xml:space="preserve">
          <source>Available since 0.19.</source>
          <target state="translated">0.19부터 사용 가능합니다.</target>
        </trans-unit>
        <trans-unit id="cf20cba49d40f80adc31be98bf7c874514e9c65b" translate="yes" xml:space="preserve">
          <source>Available since version 1.000020.</source>
          <target state="translated">버전 1.000020부터 사용 가능합니다.</target>
        </trans-unit>
        <trans-unit id="b4ebee27a76026f487f2506be21a330fd5bb55de" translate="yes" xml:space="preserve">
          <source>Available since version 2.141170.</source>
          <target state="translated">버전 2.141170부터 사용 가능합니다.</target>
        </trans-unit>
        <trans-unit id="04c0a2e766dbfbf8f4dc8178b6428ab302e4b061" translate="yes" xml:space="preserve">
          <source>Avar Arnfjord Bjarmason &amp;lt;avar@cpan.org&amp;gt;</source>
          <target state="translated">Avar Arnfjord Bjarmason &amp;lt;avar@cpan.org&amp;gt;</target>
        </trans-unit>
        <trans-unit id="e829311778d72727fd390df6d086e72d016b6e9b" translate="yes" xml:space="preserve">
          <source>Avoid /usr/ucb/cc.</source>
          <target state="translated">/ usr / ucb / cc를 피하십시오.</target>
        </trans-unit>
        <trans-unit id="20382d66f57ab5b9e0eec4292fa20991e9ee50cf" translate="yes" xml:space="preserve">
          <source>Avoid &lt;code&gt;$r-&amp;gt;Class::func()&lt;/code&gt; where using &lt;code&gt;@ISA=qw(... Class ...)&lt;/code&gt; and &lt;code&gt;$r-&amp;gt;func()&lt;/code&gt; would work.</source>
          <target state="translated">&lt;code&gt;@ISA=qw(... Class ...)&lt;/code&gt; 및 &lt;code&gt;$r-&amp;gt;func()&lt;/code&gt; 이 작동하는 &lt;code&gt;$r-&amp;gt;Class::func()&lt;/code&gt; 는 피하십시오 .</target>
        </trans-unit>
        <trans-unit id="653557f5998e677614fe1c110b44a8530b1a3295" translate="yes" xml:space="preserve">
          <source>Avoid assignments in conditionals, but if they're unavoidable, use extra paren, e.g. &quot;if (a &amp;amp;&amp;amp; (b = c)) ...&quot;</source>
          <target state="translated">조건부에서 할당을 피하되 피할 수없는 경우 &quot;예 (a &amp;amp;&amp;amp; (b = c)) ...&quot;와 같이 여분의 파렌을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="12cd7881c58cc2ba233002bb3f616c6a3c8332a8" translate="yes" xml:space="preserve">
          <source>Avoid barewords if you can, especially all lowercase ones. You can't tell by just looking at it whether a bareword is a function or a string. By using quotes on strings and parentheses on function calls, you won't ever get them confused.</source>
          <target state="translated">가능하면 베어 워드, 특히 모든 소문자를 피하십시오. 베어 워드가 함수인지 문자열인지 여부 만 살펴보면 알 수 없습니다. 함수 호출에 문자열과 괄호에 따옴표를 사용하면 혼동되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a2c60caa765bc1191575d1eafdff1bfe2d3195d5" translate="yes" xml:space="preserve">
          <source>Avoid class name tests like: &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt; &quot;Invalid&quot; unless &lt;a href=&quot;functions/ref&quot;&gt;ref&lt;/a&gt; $ref eq 'FOO'&lt;/code&gt; . Generally you can delete the &lt;code&gt;eq 'FOO'&lt;/code&gt; part with no harm at all. Let the objects look after themselves! Generally, avoid hard-wired class names as far as possible.</source>
          <target state="translated">피 클래스 이름 테스트 같은 : &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt; &quot;Invalid&quot; unless &lt;a href=&quot;functions/ref&quot;&gt;ref&lt;/a&gt; $ref eq 'FOO'&lt;/code&gt; . 일반적으로 &lt;code&gt;eq 'FOO'&lt;/code&gt; 부분을 ​​전혀 손상시키지 않고 삭제할 수 있습니다 . 물체가 스스로 돌보게하십시오! 일반적으로 유선 클래스 이름은 가능한 멀리 피하십시오.</target>
        </trans-unit>
        <trans-unit id="6c6177d46cc76c5db51cee88fceed0a2c4936349" translate="yes" xml:space="preserve">
          <source>Avoid class name tests like: &lt;code&gt;die &quot;Invalid&quot; unless ref $ref eq 'FOO'&lt;/code&gt;. Generally you can delete the &lt;code&gt;eq 'FOO'&lt;/code&gt; part with no harm at all. Let the objects look after themselves! Generally, avoid hard-wired class names as far as possible.</source>
          <target state="translated">&lt;code&gt;die &quot;Invalid&quot; unless ref $ref eq 'FOO'&lt;/code&gt; 와 같은 클래스 이름 테스트를 피하십시오 . 일반적으로 전혀 손상없이 &lt;code&gt;eq 'FOO'&lt;/code&gt; 부분을 삭제할 수 있습니다 . 물체가 스스로 돌보게하십시오! 일반적으로 가능한 한 고정 된 클래스 이름을 사용하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="98206b093bcf40d6e074eb698543fd4b6a25d539" translate="yes" xml:space="preserve">
          <source>Avoid keeping any state information in your packages. It makes it difficult for multiple other packages to use yours. Keep state information in objects.</source>
          <target state="translated">패키지에 상태 정보를 보관하지 마십시오. 여러 개의 다른 패키지를 사용하기가 어렵습니다. 상태 정보를 객체에 보관하십시오.</target>
        </trans-unit>
        <trans-unit id="b40cce256d04ce45459ded87307f5f3e8ae2760b" translate="yes" xml:space="preserve">
          <source>Avoid libucb.</source>
          <target state="translated">libucb를 피하십시오.</target>
        </trans-unit>
        <trans-unit id="b3ba9403766f60fa8e210155287efa18e1a9e739" translate="yes" xml:space="preserve">
          <source>Avoid starting a new top-level hierarchy, especially if a suitable hierarchy already exists under which you could place your module.</source>
          <target state="translated">모듈을 배치 할 수있는 적절한 계층이 이미 존재하는 경우 새 최상위 계층 구조를 시작하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="e368cb46427a0a7114b3f3aa59a320144f3a18b6" translate="yes" xml:space="preserve">
          <source>Avoid unnecessary quotes and stringification</source>
          <target state="translated">불필요한 따옴표 및 문자열 화를 피하십시오</target>
        </trans-unit>
        <trans-unit id="fd4b693367a701b3345901dbd6d82b5f0d6ce929" translate="yes" xml:space="preserve">
          <source>Avoid using &lt;code&gt;&lt;a href=&quot;functions/grep&quot;&gt;grep()&lt;/a&gt;&lt;/code&gt; (or &lt;code&gt;&lt;a href=&quot;functions/map&quot;&gt;map()&lt;/a&gt;&lt;/code&gt;) or `backticks` in a void context, that is, when you just throw away their return values. Those functions all have return values, so use them. Otherwise use a &lt;code&gt;foreach()&lt;/code&gt; loop or the &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system()&lt;/a&gt;&lt;/code&gt; function instead.</source>
          <target state="translated">void 컨텍스트에서, 즉 반환 값을 버릴 때 &lt;code&gt;&lt;a href=&quot;functions/grep&quot;&gt;grep()&lt;/a&gt;&lt;/code&gt; (또는 &lt;code&gt;&lt;a href=&quot;functions/map&quot;&gt;map()&lt;/a&gt;&lt;/code&gt; ) 또는 'backticks'를 사용하지 마십시오 . 이러한 함수에는 모두 반환 값이 있으므로 사용하십시오. 그렇지 않으면 &lt;code&gt;foreach()&lt;/code&gt; 루프 또는 &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system()&lt;/a&gt;&lt;/code&gt; 함수를 대신 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="4d1b147c04752308a754e45a088f0a5ced1e3189" translate="yes" xml:space="preserve">
          <source>Avoid using &lt;code&gt;grep()&lt;/code&gt; (or &lt;code&gt;map()&lt;/code&gt;) or `backticks` in a void context, that is, when you just throw away their return values. Those functions all have return values, so use them. Otherwise use a &lt;code&gt;foreach()&lt;/code&gt; loop or the &lt;code&gt;system()&lt;/code&gt; function instead.</source>
          <target state="translated">void 컨텍스트, 즉 반환 값을 버릴 때 &lt;code&gt;grep()&lt;/code&gt; (또는 &lt;code&gt;map()&lt;/code&gt; ) 또는`backticks`를 사용하지 마십시오 . 이러한 함수에는 모두 반환 값이 있으므로 사용하십시오. 그렇지 않으면 &lt;code&gt;foreach()&lt;/code&gt; 루프 또는 &lt;code&gt;system()&lt;/code&gt; 함수를 대신 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="342c7154cb2c0ee3ba1afbccab12770600c98259" translate="yes" xml:space="preserve">
          <source>Avoid using hardcoded test numbers whenever possible (the EXPECTED/GOT found in t/op/tie.t is much more maintainable, and gives better failure reports).</source>
          <target state="translated">가능할 때마다 하드 코딩 된 테스트 번호를 사용하지 마십시오 (t / op / tie.t에있는 EXPECTED / GOT는 훨씬 더 유지 보수 가능하며 더 나은 실패 보고서를 제공합니다).</target>
        </trans-unit>
        <trans-unit id="67de3787b457172bffd90b9f3faae7435e0dae2f" translate="yes" xml:space="preserve">
          <source>Avoid using qx// and system() unless you are testing for them. If you do use them, make sure that you cover _all_ perl platforms.</source>
          <target state="translated">테스트하지 않는 한 qx // 및 system ()을 사용하지 마십시오. 그것들을 사용한다면, _all_ perl 플랫폼을 다루어야합니다.</target>
        </trans-unit>
        <trans-unit id="0e92b74d5a979c26e7eb18be8603b8359a1d07fd" translate="yes" xml:space="preserve">
          <source>Avoiding Pipe Deadlocks</source>
          <target state="translated">파이프 교착 상태 방지</target>
        </trans-unit>
        <trans-unit id="6e3313e507db79bbbaea78fb241509ccc328aba1" translate="yes" xml:space="preserve">
          <source>Avoiding repetitions</source>
          <target state="translated">반복 피하기</target>
        </trans-unit>
        <trans-unit id="3721e8be2f4b8bf2c63f63312cdfa53888d8430d" translate="yes" xml:space="preserve">
          <source>Awk Traps</source>
          <target state="translated">어크 트랩</target>
        </trans-unit>
        <trans-unit id="ae4f281df5a5d0ff3cad6371f76d5c29b6d953ec" translate="yes" xml:space="preserve">
          <source>B</source>
          <target state="translated">B</target>
        </trans-unit>
        <trans-unit id="960ee8c49bfa63dfbcee503c121c56c7a1e4101b" translate="yes" xml:space="preserve">
          <source>B *</source>
          <target state="translated">B *</target>
        </trans-unit>
        <trans-unit id="bd2b125cd8de6e0701cdac6ee17fd331ce4a27c2" translate="yes" xml:space="preserve">
          <source>B - The Perl Compiler Backend</source>
          <target state="translated">B-Perl 컴파일러 백엔드</target>
        </trans-unit>
        <trans-unit id="66cbfa5966aea2edc7cf64e032e34c46ba4f5e91" translate="yes" xml:space="preserve">
          <source>B line</source>
          <target state="translated">B 라인</target>
        </trans-unit>
        <trans-unit id="b918b0aa2af36ef03dc69f56d877870ae5fd0aee" translate="yes" xml:space="preserve">
          <source>B-regex</source>
          <target state="translated">B-regex</target>
        </trans-unit>
        <trans-unit id="19869e35c46a3e66430c519067a6d3e7137c0ed7" translate="yes" xml:space="preserve">
          <source>B. Execution</source>
          <target state="translated">B. 실행</target>
        </trans-unit>
        <trans-unit id="f96bf8801b12adefc37c1e7fc962c4790aa5f3c1" translate="yes" xml:space="preserve">
          <source>B. K. Oxley (binkley),</source>
          <target state="translated">BK Oxley (빙 클리),</target>
        </trans-unit>
        <trans-unit id="4995b54293f85c5bb7976c9e655accd8fbd573ea" translate="yes" xml:space="preserve">
          <source>B. UNPACK</source>
          <target state="translated">B. 포장 풀기</target>
        </trans-unit>
        <trans-unit id="52b9020e3a04e67bbf5d1e8e1b850a5ce003849b" translate="yes" xml:space="preserve">
          <source>B::AV Methods</source>
          <target state="translated">B :: AV 방법</target>
        </trans-unit>
        <trans-unit id="dc2dfb25dd4ed2146470cd57ee95edac91f0306b" translate="yes" xml:space="preserve">
          <source>B::BINOP Method</source>
          <target state="translated">B :: BINOP 방법</target>
        </trans-unit>
        <trans-unit id="d151bd0866d55b4bfc156b14f486f63bf8d29ea8" translate="yes" xml:space="preserve">
          <source>B::BM Methods</source>
          <target state="translated">B :: BM 방법</target>
        </trans-unit>
        <trans-unit id="9055e894e201b212c293a29798f1091ff6d20491" translate="yes" xml:space="preserve">
          <source>B::COP Methods</source>
          <target state="translated">B :: COP 방법</target>
        </trans-unit>
        <trans-unit id="ad1f22ba3c95252a59969a1a218e1111bb139542" translate="yes" xml:space="preserve">
          <source>B::CV Methods</source>
          <target state="translated">B :: CV 방법</target>
        </trans-unit>
        <trans-unit id="c5987daa2aa6d7fac584555a51956a3b445f0843" translate="yes" xml:space="preserve">
          <source>B::Concise</source>
          <target state="translated">B::Concise</target>
        </trans-unit>
        <trans-unit id="0e99aa1c3be052d8105291584d6f4ee6b16f397c" translate="yes" xml:space="preserve">
          <source>B::Concise - Walk Perl syntax tree, printing concise info about ops</source>
          <target state="translated">B :: Concise-Walk Perl 구문 트리, ops에 대한 간결한 정보 인쇄</target>
        </trans-unit>
        <trans-unit id="d98d2c8e235d9494074cb2fd60569e8b9c12b5d6" translate="yes" xml:space="preserve">
          <source>B::Concise::reset_sequence()</source>
          <target state="translated">B::Concise::reset_sequence()</target>
        </trans-unit>
        <trans-unit id="553185e97d716b58f74fa982526081cbc642ddf4" translate="yes" xml:space="preserve">
          <source>B::Debug</source>
          <target state="translated">B::Debug</target>
        </trans-unit>
        <trans-unit id="7b2b543f6bc70176bf812e6ac813955a4e8d32ab" translate="yes" xml:space="preserve">
          <source>B::Debug - Walk Perl syntax tree, printing debug info about ops</source>
          <target state="translated">B :: Debug-Walk Perl 구문 트리, ops에 대한 디버그 정보 인쇄</target>
        </trans-unit>
        <trans-unit id="b2fba5e2c554e2a4492f4d6c8ba33e2e0b6a2475" translate="yes" xml:space="preserve">
          <source>B::Deparse</source>
          <target state="translated">B::Deparse</target>
        </trans-unit>
        <trans-unit id="45e0d250a6312bd5838511c6a45d0f47e7a90193" translate="yes" xml:space="preserve">
          <source>B::Deparse - Perl compiler backend to produce perl code</source>
          <target state="translated">B :: Deparse-Perl 코드를 생성하는 Perl 컴파일러 백엔드</target>
        </trans-unit>
        <trans-unit id="ef79da6fd85d8fa02ee778f0544d6ba33e8b3b18" translate="yes" xml:space="preserve">
          <source>B::Deparse can also be used on a sub-by-sub basis from other perl programs.</source>
          <target state="translated">B :: Deparse는 다른 perl 프로그램에서 하위별로 사용할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="187ec0fb4a4a04196e808c398a93708ba9275615" translate="yes" xml:space="preserve">
          <source>B::Deparse is a backend module for the Perl compiler that generates perl source code, based on the internal compiled structure that perl itself creates after parsing a program. The output of B::Deparse won't be exactly the same as the original source, since perl doesn't keep track of comments or whitespace, and there isn't a one-to-one correspondence between perl's syntactical constructions and their compiled form, but it will often be close. When you use the &lt;b&gt;-p&lt;/b&gt; option, the output also includes parentheses even when they are not required by precedence, which can make it easy to see if perl is parsing your expressions the way you intended.</source>
          <target state="translated">B :: Deparse는 프로그램을 구문 분석 한 후 perl 자체가 작성하는 내부 컴파일 된 구조를 기반으로 perl 소스 코드를 생성하는 Perl 컴파일러 용 백엔드 모듈입니다. 펄은 주석이나 공백을 추적하지 않으며 펄의 구문 구조와 컴파일 된 구조 사이에 일대일 대응이 없기 때문에 B :: Deparse의 출력은 원래 소스와 정확히 동일하지 않습니다. 형태, 그러나 종종 가까운 것입니다. &lt;b&gt;-p&lt;/b&gt; 를 사용할 때&lt;b&gt;&lt;/b&gt; 옵션 우선 순위에 따라 필요하지 않은 경우에도 출력에 괄호가 포함되므로 perl이 원하는 방식으로 표현식을 구문 분석하는지 쉽게 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fc31dbbc2ee8c07aa355011d5f82b2d63c5b6c00" translate="yes" xml:space="preserve">
          <source>B::GV Methods</source>
          <target state="translated">B :: GV 방법</target>
        </trans-unit>
        <trans-unit id="f507161ede02e20a9575d2189eb0e0194566355a" translate="yes" xml:space="preserve">
          <source>B::HV Methods</source>
          <target state="translated">B :: HV 방법</target>
        </trans-unit>
        <trans-unit id="e300bd8b4c95a3624e2aa219bf974f0118cef860" translate="yes" xml:space="preserve">
          <source>B::IO Methods</source>
          <target state="translated">B :: IO 방법</target>
        </trans-unit>
        <trans-unit id="35a3e95640c426b65cf8d850194a4f17b3215f07" translate="yes" xml:space="preserve">
          <source>B::IO objects derive from IO objects and you will get more information from the IO object itself.</source>
          <target state="translated">B :: IO 객체는 IO 객체에서 파생되며 IO 객체 자체에서 자세한 정보를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9329448ffaface57d41ef2b007c24eb18197a68b" translate="yes" xml:space="preserve">
          <source>B::IV Methods</source>
          <target state="translated">B :: IV 방법</target>
        </trans-unit>
        <trans-unit id="f3d775a1d64c4d9d033d742b01a011ef21c3139b" translate="yes" xml:space="preserve">
          <source>B::IV, B::NV, B::PV, B::PVIV, B::PVNV, B::PVMG, B::PVLV, B::AV, B::HV, B::CV, B::GV, B::FM, B::IO. These classes correspond in the obvious way to the underlying C structures of similar names. The inheritance hierarchy mimics the underlying C &quot;inheritance&quot;:</source>
          <target state="translated">B :: IV, B :: NV, B :: PV, B :: PVIV, B :: PVNV, B :: PVMG, B :: PVLV, B :: AV, B :: HV, B :: CV, B :: GV, B :: FM, B :: IO. 이러한 클래스는 유사한 이름의 기본 C 구조에 명백한 방식으로 대응합니다. 상속 계층 구조는 기본 C &quot;상속&quot;을 모방합니다.</target>
        </trans-unit>
        <trans-unit id="41ae1a755811beebf8ac2f49c8c1656753f2209c" translate="yes" xml:space="preserve">
          <source>B::IV, B::NV, B::RV, B::PV, B::PVIV, B::PVNV, B::PVMG, B::BM (5.9.5 and earlier), B::PVLV, B::AV, B::HV, B::CV, B::GV, B::FM, B::IO. These classes correspond in the obvious way to the underlying C structures of similar names. The inheritance hierarchy mimics the underlying C &quot;inheritance&quot;. For the 5.10.x branch, (</source>
          <target state="translated">B :: IV, B :: NV, B :: RV, B :: PV, B :: PVIV, B :: PVNV, B :: PVMG, B :: BM (5.9.5 이하), B :: PVLV, B :: AV, B :: HV, B :: CV, B :: GV, B :: FM, B :: IO. 이러한 클래스는 명백한 방식으로 유사한 이름의 기본 C 구조에 해당합니다. 상속 계층은 기본 C &quot;상속&quot;을 모방합니다. 5.10.x 분기의 경우 (</target>
        </trans-unit>
        <trans-unit id="47e3586b1ed7a7d56d8afab1073b55905757ce29" translate="yes" xml:space="preserve">
          <source>B::LISTOP Method</source>
          <target state="translated">B :: LISTOP 방법</target>
        </trans-unit>
        <trans-unit id="04688acb0cbf70d25c11e0314b06463ce4bde512" translate="yes" xml:space="preserve">
          <source>B::LOGOP Method</source>
          <target state="translated">B :: LOGOP 방법</target>
        </trans-unit>
        <trans-unit id="7263ed2af022568be1b85d473eacf000486dd697" translate="yes" xml:space="preserve">
          <source>B::LOOP Methods</source>
          <target state="translated">B :: 루프 방법</target>
        </trans-unit>
        <trans-unit id="83ceb8c6feb2e3fc2f3bf822a42dbcd07ff89ff2" translate="yes" xml:space="preserve">
          <source>B::MAGIC Methods</source>
          <target state="translated">B :: MAGIC 방법</target>
        </trans-unit>
        <trans-unit id="69a559c9b6f1bb1dde02c8b48310f4be42a91370" translate="yes" xml:space="preserve">
          <source>B::METHOP Methods (Since Perl 5.22)</source>
          <target state="translated">B :: METHOP 방법 (Perl 5.22 이후)</target>
        </trans-unit>
        <trans-unit id="ce0314b7717adf8f5e71d17e31bd593c95324507" translate="yes" xml:space="preserve">
          <source>B::NV Methods</source>
          <target state="translated">B :: NV 방법</target>
        </trans-unit>
        <trans-unit id="c0b4baaa7ca50074884462d7620fd16447077eec" translate="yes" xml:space="preserve">
          <source>B::OP Methods</source>
          <target state="translated">B :: OP 방법</target>
        </trans-unit>
        <trans-unit id="9f43dd0af65c2a7397a364fed7e94a6388954481" translate="yes" xml:space="preserve">
          <source>B::OP::terse</source>
          <target state="translated">B::OP::terse</target>
        </trans-unit>
        <trans-unit id="b8644ca464436a14d88fc7211463f2c65ed97695" translate="yes" xml:space="preserve">
          <source>B::Op_private</source>
          <target state="translated">B::Op_private</target>
        </trans-unit>
        <trans-unit id="67239ea053c2700f5ce63cb3454a4558b2cbf5e7" translate="yes" xml:space="preserve">
          <source>B::Op_private - OP op_private flag definitions</source>
          <target state="translated">B :: Op_private-OP op_private 플래그 정의</target>
        </trans-unit>
        <trans-unit id="5409024a3cb7db3e3ab0625fc65de3e420057bb4" translate="yes" xml:space="preserve">
          <source>B::PADLIST Methods</source>
          <target state="translated">B :: PADLIST 방법</target>
        </trans-unit>
        <trans-unit id="7aa1d371fde2d45d24f6903c528b83b6becc77cd" translate="yes" xml:space="preserve">
          <source>B::PADNAME Methods</source>
          <target state="translated">B :: PADNAME 방법</target>
        </trans-unit>
        <trans-unit id="f042ef0bca656a3a3db2a47dca50963fab567b10" translate="yes" xml:space="preserve">
          <source>B::PADNAMELIST Methods</source>
          <target state="translated">B :: PADNAMELIST 방법</target>
        </trans-unit>
        <trans-unit id="7fc794e6266342d3b9c5605f5dd3acf7f99c4eaf" translate="yes" xml:space="preserve">
          <source>B::PADOP Method</source>
          <target state="translated">B :: PADOP 방법</target>
        </trans-unit>
        <trans-unit id="3cfe6d3792643bf75e3768c357ceb15d1fcc2896" translate="yes" xml:space="preserve">
          <source>B::PMOP Methods</source>
          <target state="translated">B :: PMOP 방법</target>
        </trans-unit>
        <trans-unit id="935c8ee8b93bca030ffae3839fe2dd9b63ef8ee4" translate="yes" xml:space="preserve">
          <source>B::PV Methods</source>
          <target state="translated">B :: PV 방법</target>
        </trans-unit>
        <trans-unit id="2ae17602fe4096f70c3f88f15eb8e459f9c75ea9" translate="yes" xml:space="preserve">
          <source>B::PVLV Methods</source>
          <target state="translated">B :: PVLV 방법</target>
        </trans-unit>
        <trans-unit id="974a328507349d20edd58996d04366d5388a2f7c" translate="yes" xml:space="preserve">
          <source>B::PVMG Methods</source>
          <target state="translated">B :: PVMG 방법</target>
        </trans-unit>
        <trans-unit id="7210fef12d9bb7c60c3dee3ae3350db4f7b9f9ab" translate="yes" xml:space="preserve">
          <source>B::PVOP Method</source>
          <target state="translated">B :: PVOP 방법</target>
        </trans-unit>
        <trans-unit id="6455c3fb933990f5652e2d49c591cb379eb4bf8a" translate="yes" xml:space="preserve">
          <source>B::REGEXP Methods</source>
          <target state="translated">B :: REGEXP 방법</target>
        </trans-unit>
        <trans-unit id="5fb9902660751871b51829ac2f4124c1e0f71d1f" translate="yes" xml:space="preserve">
          <source>B::RV Methods</source>
          <target state="translated">B :: RV 방법</target>
        </trans-unit>
        <trans-unit id="1bc231286052c317542f678d841b72c83eca59c7" translate="yes" xml:space="preserve">
          <source>B::SV Methods</source>
          <target state="translated">B :: SV 방법</target>
        </trans-unit>
        <trans-unit id="ba72f1a9a3b75ef02445cdb3be5e5dfd9e626d0a" translate="yes" xml:space="preserve">
          <source>B::SVOP Methods</source>
          <target state="translated">B :: SVOP 방법</target>
        </trans-unit>
        <trans-unit id="6d49788efca655ce69693e7fc4afeb14e70c0677" translate="yes" xml:space="preserve">
          <source>B::Showlex</source>
          <target state="translated">B::Showlex</target>
        </trans-unit>
        <trans-unit id="950f98354a0be3d4d89c912c00828150ec365f96" translate="yes" xml:space="preserve">
          <source>B::Showlex - Show lexical variables used in functions or files</source>
          <target state="translated">B :: Showlex-함수 또는 파일에 사용 된 어휘 변수 표시</target>
        </trans-unit>
        <trans-unit id="fdd28b59d6f44b83715e2f882acc2a2a5588e605" translate="yes" xml:space="preserve">
          <source>B::Terse</source>
          <target state="translated">B::Terse</target>
        </trans-unit>
        <trans-unit id="c493225f0157e4f61a98bb3974699f2af44cb46f" translate="yes" xml:space="preserve">
          <source>B::Terse - Walk Perl syntax tree, printing terse info about ops</source>
          <target state="translated">B :: Terse-Walk Perl 구문 트리, op에 대한 간결한 정보 인쇄</target>
        </trans-unit>
        <trans-unit id="9f6685ca28bcfea09300907f0826a8f9a2c91850" translate="yes" xml:space="preserve">
          <source>B::UNOP Method</source>
          <target state="translated">B :: UNOP 방법</target>
        </trans-unit>
        <trans-unit id="69effd3b7e8802f540cc9b9e50328608e6736463" translate="yes" xml:space="preserve">
          <source>B::UNOP_AUX Methods (since 5.22)</source>
          <target state="translated">B :: UNOP_AUX 메소드 (5.12부터)</target>
        </trans-unit>
        <trans-unit id="c85e7a03e5bbe49c04256621164986ed11cb37ba" translate="yes" xml:space="preserve">
          <source>B::Xref</source>
          <target state="translated">B::Xref</target>
        </trans-unit>
        <trans-unit id="651c8208adb3fd49f31423f94f8ac43c0733aa36" translate="yes" xml:space="preserve">
          <source>B::Xref - Generates cross reference reports for Perl programs</source>
          <target state="translated">B :: Xref-Perl 프로그램에 대한 상호 참조 보고서를 생성합니다</target>
        </trans-unit>
        <trans-unit id="a61d2719382da67e2a1a2dbd76dd400accca9187" translate="yes" xml:space="preserve">
          <source>BACKWARD COMPATIBILITY AND DEPRECATION</source>
          <target state="translated">역 호환 및 감가 상각</target>
        </trans-unit>
        <trans-unit id="e5b45b4fc983ac2702f9e777eee2ac1b1e5f0f20" translate="yes" xml:space="preserve">
          <source>BACKWARDS COMPATIBILITY</source>
          <target state="translated">역 호환성</target>
        </trans-unit>
        <trans-unit id="bef6eec96c16ae54f978beec72807557ca3a9eaf" translate="yes" xml:space="preserve">
          <source>BASIC METHODS</source>
          <target state="translated">기본 방법</target>
        </trans-unit>
        <trans-unit id="aa6878b1c31a9420245df1daffb7b223338737a3" translate="yes" xml:space="preserve">
          <source>BBB</source>
          <target state="translated">BBB</target>
        </trans-unit>
        <trans-unit id="a76d28d6a4e36d4447b9f4c252abca9f3cac325b" translate="yes" xml:space="preserve">
          <source>BBEdit and TextWrangler</source>
          <target state="translated">BBEdit 및 TextWrangler</target>
        </trans-unit>
        <trans-unit id="8cf5cb57c99d3bbd6c48033a11d198c341ee5329" translate="yes" xml:space="preserve">
          <source>BEFORE YOU START WRITING A MODULE</source>
          <target state="translated">모듈 작성을 시작하기 전에</target>
        </trans-unit>
        <trans-unit id="3598517c826f1480a241800ce73f781ae2b1cd6a" translate="yes" xml:space="preserve">
          <source>BEGIN</source>
          <target state="translated">BEGIN</target>
        </trans-unit>
        <trans-unit id="d94255a33af2a233413bdca7bd8b5cd50ff62d1b" translate="yes" xml:space="preserve">
          <source>BEGIN blocks</source>
          <target state="translated">BEGIN 블록</target>
        </trans-unit>
        <trans-unit id="38cb5ebde363f32ca7879125654df658667bbf73" translate="yes" xml:space="preserve">
          <source>BEGIN failed--compilation aborted</source>
          <target state="translated">BEGIN 실패-컴파일이 중단되었습니다.</target>
        </trans-unit>
        <trans-unit id="70821eae507ac85cc9e07ce2b4ef46d0ec3667a3" translate="yes" xml:space="preserve">
          <source>BEGIN not safe after errors--compilation aborted</source>
          <target state="translated">BEGIN 오류 후 안전하지 않음-컴파일이 중단됨</target>
        </trans-unit>
        <trans-unit id="ed0ab3055b45605d8d3bfeee9675e3115e25dd63" translate="yes" xml:space="preserve">
          <source>BEGIN, UNITCHECK, CHECK, INIT and END</source>
          <target state="translated">시작, UNITCHECK, CHECK, INIT 및 END</target>
        </trans-unit>
        <trans-unit id="ee1ec7cf5d1203d7be37071bc2244af5ad59b465" translate="yes" xml:space="preserve">
          <source>BEHAVIOR HOOKS</source>
          <target state="translated">행동 고리</target>
        </trans-unit>
        <trans-unit id="82587c5990d27962027bcd8f44009a394aa03c6d" translate="yes" xml:space="preserve">
          <source>BENCHMARKS</source>
          <target state="translated">BENCHMARKS</target>
        </trans-unit>
        <trans-unit id="3eb8dc2707d319cff39e903c8f9e907ffde6faaa" translate="yes" xml:space="preserve">
          <source>BEST PRACTICE</source>
          <target state="translated">모범 사례</target>
        </trans-unit>
        <trans-unit id="9971e7204a8b08d861ca7fadb789c6c4fe6817b8" translate="yes" xml:space="preserve">
          <source>BINARY_LOCATION</source>
          <target state="translated">BINARY_LOCATION</target>
        </trans-unit>
        <trans-unit id="d6b920160b07e6d8ef62aeb966afe0559c1c4da6" translate="yes" xml:space="preserve">
          <source>BINMODE</source>
          <target state="translated">BINMODE</target>
        </trans-unit>
        <trans-unit id="5d021fda0b6b8ed6bd452bf1168689693b7edba7" translate="yes" xml:space="preserve">
          <source>BINMODE this</source>
          <target state="translated">BINMODE이</target>
        </trans-unit>
        <trans-unit id="bf55ddd9725aa1a87e415a1396e069c8d47b25d1" translate="yes" xml:space="preserve">
          <source>BLOCK</source>
          <target state="translated">BLOCK</target>
        </trans-unit>
        <trans-unit id="457d9dafbbea9f5d194f2f920ae5f010432f75b2" translate="yes" xml:space="preserve">
          <source>BLOCKDEV</source>
          <target state="translated">BLOCKDEV</target>
        </trans-unit>
        <trans-unit id="b09c96efee066cc539728b4e2b0f68b4e32a0350" translate="yes" xml:space="preserve">
          <source>BOM as integer when fetched in network byte order</source>
          <target state="translated">네트워크 바이트 순서로 가져올 때 BOM을 정수로 표시</target>
        </trans-unit>
        <trans-unit id="73fcc9dd1e6686a3a9e94d9fb16092a9ef3f9ef8" translate="yes" xml:space="preserve">
          <source>BOM_UTF8</source>
          <target state="translated">BOM_UTF8</target>
        </trans-unit>
        <trans-unit id="9afa89ba4b3340d7bc1c3e18c656cfc5abf6d9a7" translate="yes" xml:space="preserve">
          <source>BOOLEAN = less-&amp;gt;of( FEATURE )</source>
          <target state="translated">BOOLEAN = less-&amp;gt; of (피처)</target>
        </trans-unit>
        <trans-unit id="3e4c26e4f6f8343f03e02567a3c22dbf6978ed5f" translate="yes" xml:space="preserve">
          <source>BOTTOM_GV</source>
          <target state="translated">BOTTOM_GV</target>
        </trans-unit>
        <trans-unit id="5538bef04345694943fc69521fc1c479110399bf" translate="yes" xml:space="preserve">
          <source>BOTTOM_NAME</source>
          <target state="translated">BOTTOM_NAME</target>
        </trans-unit>
        <trans-unit id="247befebedd2ed6823933439f49eb30a07d09dca" translate="yes" xml:space="preserve">
          <source>BRACKET NOTATION</source>
          <target state="translated">브라켓 표기법</target>
        </trans-unit>
        <trans-unit id="17d26d9e28cc4c16fe9b307dc7f0b75e8a9d3b1b" translate="yes" xml:space="preserve">
          <source>BRACKET NOTATION SECURITY</source>
          <target state="translated">브래킷 표기 보안</target>
        </trans-unit>
        <trans-unit id="c25e7baf0562de8891b5c53dde5e9d802f4a0b6e" translate="yes" xml:space="preserve">
          <source>BREAKOUT_AT</source>
          <target state="translated">BREAKOUT_AT</target>
        </trans-unit>
        <trans-unit id="e7772b5b926c191f6bd98767963948f3ffc93baa" translate="yes" xml:space="preserve">
          <source>BS2000 POSIX doesn't support the shebang notation (&lt;code&gt;#!/usr/local/bin/perl&lt;/code&gt; ), so you have to use the following lines instead:</source>
          <target state="translated">BS2000 POSIX는 shebang 표기법 ( &lt;code&gt;#!/usr/local/bin/perl&lt;/code&gt; )을 지원하지 않으므로 대신 다음 줄을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="900c916101719763ca728f26535d16592b2fec22" translate="yes" xml:space="preserve">
          <source>BS2000 POSIX doesn't support the shebang notation (&lt;code&gt;#!/usr/local/bin/perl&lt;/code&gt;), so you have to use the following lines instead:</source>
          <target state="translated">BS2000 POSIX는 shebang 표기법 ( &lt;code&gt;#!/usr/local/bin/perl&lt;/code&gt; )을 지원하지 않으므로 대신 다음 줄을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="f442b9234477d8def500a9840cec8cff9ed97e5a" translate="yes" xml:space="preserve">
          <source>BSD</source>
          <target state="translated">BSD</target>
        </trans-unit>
        <trans-unit id="664c8d2ddb2e4dc2ea085ed16d6df4504ec03ee2" translate="yes" xml:space="preserve">
          <source>BSD::Resource on Solaris</source>
          <target state="translated">Solaris의 BSD :: Resource</target>
        </trans-unit>
        <trans-unit id="df51adc50ecdca424b6145ec6164f8c39197a14c" translate="yes" xml:space="preserve">
          <source>BSD::Resource versions earlier than 1.09 do not compile on Solaris with perl 5.6.0 and higher, for the same reasons as Proc::ProcessTable. BSD::Resource versions starting from 1.09 have a workaround for the problem.</source>
          <target state="translated">1.09 이전의 BSD :: Resource 버전은 Proc :: ProcessTable과 같은 이유로 perl 5.6.0 이상이 설치된 Solaris에서 컴파일되지 않습니다. 1.09부터 시작하는 BSD :: Resource 버전에는이 문제에 대한 해결 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="d7fe8d7ec43bafda1404b3733deb73b25528fcbd" translate="yes" xml:space="preserve">
          <source>BSLOADLIBS</source>
          <target state="translated">BSLOADLIBS</target>
        </trans-unit>
        <trans-unit id="502dbddd3b35610af6911c0fbc9ca3be4bfe6d63" translate="yes" xml:space="preserve">
          <source>BTW. Beware too of pressure from managers who see you speed a program up by 50% of the runtime once, only to get a request one month later to do the same again (true story) - you'll just have to point out you're only human, even if you are a Perl programmer, and you'll see what you can do...</source>
          <target state="translated">BTW. 프로그램을 한 번만 실행 속도를 50 %까지 높이고 한 달 후에 다시 요청하라는 요청을받는 관리자의 압박에주의하십시오 (사실). Perl 프로그래머라도 인간 만이 할 수있는 일을 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="78253234498ab9f80f071ee0cf6c83a489538d17" translate="yes" xml:space="preserve">
          <source>BUFFERED VS UNBUFFERED (OR STREAMED)</source>
          <target state="translated">버퍼링 됨 대 버퍼링되지 않음 (또는 스트리밍 됨)</target>
        </trans-unit>
        <trans-unit id="f95da7d5f97af571f044d5a433d68877d16ba4a5" translate="yes" xml:space="preserve">
          <source>BUFFERS</source>
          <target state="translated">BUFFERS</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
