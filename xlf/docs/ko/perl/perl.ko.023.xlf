<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="perl">
    <body>
      <group id="perl">
        <trans-unit id="d47de889df56d979834e9722ebde0c0a6a0fae68" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;character&lt;/b&gt; or &lt;b&gt;string&lt;/b&gt; that keeps two surrounding strings from being confused with each other. The &lt;code&gt;split&lt;/code&gt; function works on separators. Not to be confused with &lt;b&gt;delimiters&lt;/b&gt; or &lt;b&gt;terminators&lt;/b&gt;. The &amp;ldquo;or&amp;rdquo; in the previous sentence separated the two alternatives.</source>
          <target state="translated">두 개의 주변 문자열이 서로 혼동되지 않도록 하는 &lt;b&gt;문자&lt;/b&gt; 또는 &lt;b&gt;문자열&lt;/b&gt; 입니다. &lt;code&gt;split&lt;/code&gt; 기능은 분리에서 작동합니다. &lt;b&gt;구분자&lt;/b&gt; 또는 &lt;b&gt;종결 자&lt;/b&gt; 와 혼동하지 마십시오 . 이전 문장의 &quot;or&quot;는 두 가지 대안을 구분했습니다.</target>
        </trans-unit>
        <trans-unit id="ccc52a9bce5d37da72e4313c9442e3059934389e" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;character&lt;/b&gt; or &lt;b&gt;string&lt;/b&gt; that marks the end of another string. The &lt;code&gt;$/&lt;/code&gt; variable contains the string that terminates a &lt;code&gt;&lt;a href=&quot;functions/readline&quot;&gt;readline&lt;/a&gt;&lt;/code&gt; operation, which &lt;code&gt;&lt;a href=&quot;functions/chomp&quot;&gt;chomp&lt;/a&gt;&lt;/code&gt; deletes from the end. Not to be confused with &lt;b&gt;delimiters&lt;/b&gt; or &lt;b&gt;separators&lt;/b&gt;. The period at the end of this sentence is a terminator.</source>
          <target state="translated">&lt;b&gt;문자&lt;/b&gt; 또는 &lt;b&gt;문자열&lt;/b&gt; 표시 다른 문자열의 끝이. &lt;code&gt;$/&lt;/code&gt; 변수는 종료 문자열이 들어 &lt;code&gt;&lt;a href=&quot;functions/readline&quot;&gt;readline&lt;/a&gt;&lt;/code&gt; 운영, &lt;code&gt;&lt;a href=&quot;functions/chomp&quot;&gt;chomp&lt;/a&gt;&lt;/code&gt; 끝에서 삭제합니다. &lt;b&gt;구분 기호&lt;/b&gt; 나 &lt;b&gt;구분 기호&lt;/b&gt; 와 혼동하지 마십시오 . 이 문장의 끝 부분은 종결 자입니다.</target>
        </trans-unit>
        <trans-unit id="d839106acdc670985a28069f0c98ef61f88fbf3e" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;character&lt;/b&gt; or &lt;b&gt;string&lt;/b&gt; that marks the end of another string. The &lt;code&gt;$/&lt;/code&gt; variable contains the string that terminates a &lt;code&gt;readline&lt;/code&gt; operation, which &lt;code&gt;chomp&lt;/code&gt; deletes from the end. Not to be confused with &lt;b&gt;delimiters&lt;/b&gt; or &lt;b&gt;separators&lt;/b&gt;. The period at the end of this sentence is a terminator.</source>
          <target state="translated">다른 문자열의 끝을 표시 하는 &lt;b&gt;문자&lt;/b&gt; 또는 &lt;b&gt;문자열&lt;/b&gt; 입니다. &lt;code&gt;$/&lt;/code&gt; 변수는 종료 문자열이 들어 &lt;code&gt;readline&lt;/code&gt; 운영, &lt;code&gt;chomp&lt;/code&gt; 끝에서 삭제합니다. &lt;b&gt;구분 기호&lt;/b&gt; 또는 &lt;b&gt;구분 기호&lt;/b&gt; 와 혼동하지 마십시오 . 이 문장의 끝에있는 마침표는 종결 자입니다.</target>
        </trans-unit>
        <trans-unit id="c2ccb7e4dc3cd3bdbacbf8b76f79619db792d436" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;character&lt;/b&gt; or &lt;b&gt;string&lt;/b&gt; that sets bounds to an arbitrarily sized textual object, not to be confused with a &lt;b&gt;separator&lt;/b&gt; or &lt;b&gt;terminator&lt;/b&gt;. &amp;ldquo;To delimit&amp;rdquo; really just means &amp;ldquo;to surround&amp;rdquo; or &amp;ldquo;to enclose&amp;rdquo; (like these parentheses are doing).</source>
          <target state="translated">&lt;b&gt;문자&lt;/b&gt; 또는 &lt;b&gt;문자열&lt;/b&gt; 임의 크기의 텍스트 객체 세트 경계는 혼동되지 않아야한다는 &lt;b&gt;세퍼레이터&lt;/b&gt; 또는 &lt;b&gt;터미네이터&lt;/b&gt; . &quot;구분하다&quot;는 실제로 &quot;서라운드&quot;또는 &quot;동봉&quot;을 의미합니다 (이러한 괄호처럼).</target>
        </trans-unit>
        <trans-unit id="ea08291e93224eb22a8479c3ec9c014b05bce7f2" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;character&lt;/b&gt; that is</source>
          <target state="translated">&lt;b&gt;문자&lt;/b&gt; 입니다</target>
        </trans-unit>
        <trans-unit id="5cba1f2a968bf42f9b6478a5e49fa1b60b1a7141" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;character&lt;/b&gt; that moves your cursor but doesn&amp;rsquo;t otherwise put anything on your screen. Typically refers to any of: space, tab, line feed, carriage return, or form feed. In Unicode, matches many other characters that Unicode considers whitespace, including the ɴ-ʙʀ .</source>
          <target state="translated">&lt;b&gt;문자&lt;/b&gt; 커서를 이동하지만, 그렇지 않으면 화면에 아무것도 넣지 않습니다. 일반적으로 공간, 탭, 줄 바꿈, 캐리지 리턴 또는 용지 공급 중 하나를 나타냅니다. 유니 코드에서 ɴ-ʙʀ를 포함하여 유니 코드가 공백을 고려하는 다른 많은 문자와 일치합니다.</target>
        </trans-unit>
        <trans-unit id="2aa2a649bec9b1fd1ac1866bab10ba2afe8f796b" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;class&lt;/b&gt; defines the behavior of a category of objects. A class is a name for a category (like &quot;File&quot;), and a class also defines the behavior of objects in that category.</source>
          <target state="translated">의 &lt;b&gt;클래스&lt;/b&gt; 객체의 범주의 동작을 정의합니다. 클래스는 범주의 이름 (예 : &quot;파일&quot;)이며 클래스는 해당 범주에있는 객체의 동작을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="1a75079cb5fa51afe9c7f949ddf0f69d6f477b63" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;class&lt;/b&gt; that defines some of its &lt;b&gt;methods&lt;/b&gt; in terms of a more generic class, called a &lt;b&gt;base class&lt;/b&gt;. Note that classes aren&amp;rsquo;t classified exclusively into base classes or derived classes: a class can function as both a derived class and a base class simultaneously, which is kind of classy.</source>
          <target state="translated">&lt;b&gt;클래스&lt;/b&gt; 의 몇 가지 정의 &lt;b&gt;방법&lt;/b&gt; 보다 일반적인 클래스의 측면에서이 호출 된 &lt;b&gt;기본 클래스&lt;/b&gt; . 클래스는 기본 클래스 또는 파생 클래스로 독점적으로 분류되지 않습니다. 클래스는 파생 클래스와 기본 클래스로 동시에 작동 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="99d0667db3792046333bf54560031cc7b2ecf43e" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;command&lt;/b&gt; to the computer about what to do next, like a step in a recipe: &amp;ldquo;Add marmalade to batter and mix until mixed.&amp;rdquo; A statement is distinguished from a &lt;b&gt;declaration&lt;/b&gt;, which doesn&amp;rsquo;t tell the computer to do anything, but just to learn something.</source>
          <target state="translated">&lt;b&gt;명령&lt;/b&gt; 조리법의 단계처럼, 다음에 수행 할 작업에 대한 컴퓨터 &quot;. 타자와 혼합 될 때까지 혼합 마멀레이드 추가&quot; 문장은 &lt;b&gt;선언&lt;/b&gt; 과 구별되는데, &lt;b&gt;선언&lt;/b&gt; 은 컴퓨터에게 아무것도하지 말고 무언가를 배우라고 지시합니다.</target>
        </trans-unit>
        <trans-unit id="0c8b51997be5611d837a8ab6c5cb1982a471c7f6" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;command&lt;/b&gt;-line &lt;b&gt;interpreter&lt;/b&gt;. The program that interactively gives you a prompt, accepts one or more &lt;b&gt;lines&lt;/b&gt; of input, and executes the programs you mentioned, feeding each of them their proper &lt;b&gt;arguments&lt;/b&gt; and input data. Shells can also execute scripts containing such commands. Under Unix, typical shells include the Bourne shell (</source>
          <target state="translated">&lt;b&gt;명령&lt;/b&gt; - 라인의 &lt;b&gt;인터프리터&lt;/b&gt; . 대화식으로 프롬프트를 표시하고 하나 이상의 입력 &lt;b&gt;행&lt;/b&gt; 을 허용하며 언급 한 프로그램을 실행하여 각각 적절한 &lt;b&gt;인수&lt;/b&gt; 및 입력 데이터를 제공하는 프로그램입니다. 쉘은 그러한 명령을 포함하는 스크립트를 실행할 수도 있습니다. 유닉스에서 일반적인 쉘에는 Bourne 쉘 (</target>
        </trans-unit>
        <trans-unit id="52e02137a3f5dfcbaf26aaed0daa92b24d1f6a82" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;conditional&lt;/b&gt; or &lt;b&gt;loop&lt;/b&gt; that you put after the &lt;b&gt;statement&lt;/b&gt; instead of before, if you know what we mean.</source>
          <target state="translated">&lt;b&gt;조건&lt;/b&gt; 또는 &lt;b&gt;루프&lt;/b&gt; 는 후 넣어 &lt;b&gt;문&lt;/b&gt; 대신 전에, 당신이 알고있는 경우에 우리는 무엇을 의미하는지.</target>
        </trans-unit>
        <trans-unit id="8b7c0791290fe9b8909bf7acee3f40cc62fd3b4d" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;constructor&lt;/b&gt; creates a new object. In Perl, a class's constructor is just another method, unlike some other languages, which provide syntax for constructors. Most Perl classes use &lt;code&gt;new&lt;/code&gt; as the name for their constructor:</source>
          <target state="translated">&lt;b&gt;생성자는&lt;/b&gt; 새로운 객체를 생성합니다. Perl에서 클래스의 생성자는 다른 언어와 달리 생성자에 대한 구문을 제공하는 다른 방법 일뿐입니다. 대부분의 Perl 클래스는 &lt;code&gt;new&lt;/code&gt; 를 생성자의 이름으로 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="7959cb1d43e022aebe37e1efd0d8727ca1bc0118" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;cracker&lt;/b&gt; who is not a &lt;b&gt;hacker&lt;/b&gt; but knows just enough to run canned scripts. A &lt;b&gt;cargo-cult&lt;/b&gt; programmer.</source>
          <target state="translated">&lt;b&gt;해커는&lt;/b&gt; 아니지만 통조림 스크립트를 실행할만큼 의 &lt;b&gt;크래커&lt;/b&gt; 입니다 . &lt;b&gt;화물 숭배&lt;/b&gt; 프로그래머.&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="eb0c56375aec608f2fe483b5d49fe200437f6d13" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;data paragraph&lt;/b&gt;. This is a paragraph that</source>
          <target state="translated">&lt;b&gt;데이터 단락&lt;/b&gt; . 이 단락은</target>
        </trans-unit>
        <trans-unit id="f4407d7bf8b4e86a5ab3d8b6cfe6f792d1bff9b9" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;file&lt;/b&gt; that defines a &lt;b&gt;package&lt;/b&gt; of (almost) the same name, which can either &lt;b&gt;export&lt;/b&gt; symbols or function as an &lt;b&gt;object&lt;/b&gt; class. (A module&amp;rsquo;s main</source>
          <target state="translated">&lt;b&gt;파일&lt;/b&gt; 정의 &lt;b&gt;패키지&lt;/b&gt; (거의) 같은 이름의를하는 중 하나를 수행 할 수 있습니다 &lt;b&gt;수출&lt;/b&gt; AS를 문자 또는 함수 &lt;b&gt;객체의&lt;/b&gt; 클래스입니다. (모듈의 메인</target>
        </trans-unit>
        <trans-unit id="560dff37fc95faf8528a7887fa6dc08d1b06155b" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;file&lt;/b&gt; that is specially marked to tell the &lt;b&gt;operating system&lt;/b&gt; that it&amp;rsquo;s okay to run this file as a program. Usually shortened to &amp;ldquo;executable&amp;rdquo;.</source>
          <target state="translated">&lt;b&gt;파일&lt;/b&gt; 특별히 표시되어 이야기하는 &lt;b&gt;운영 체제를&lt;/b&gt; 이 프로그램으로이 파일을 실행 괜찮아있다. 일반적으로 &quot;실행 가능&quot;으로 줄었습니다.</target>
        </trans-unit>
        <trans-unit id="832195e4157a51d08607c1f931cf313eaae32121" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;file&lt;/b&gt; that&amp;rsquo;s not a &lt;b&gt;directory&lt;/b&gt;, a &lt;b&gt;device&lt;/b&gt;, a named &lt;b&gt;pipe&lt;/b&gt; or &lt;b&gt;socket&lt;/b&gt;, or a &lt;b&gt;symbolic link&lt;/b&gt;. Perl uses the &lt;code&gt;&amp;ndash;f&lt;/code&gt; file test operator to identify regular files. Sometimes called a &amp;ldquo;plain&amp;rdquo; file.</source>
          <target state="translated">&lt;b&gt;파일&lt;/b&gt; 아니다 &lt;b&gt;디렉토리&lt;/b&gt; 하는 &lt;b&gt;장치&lt;/b&gt; , 명명 된 &lt;b&gt;파이프&lt;/b&gt; 또는 &lt;b&gt;소켓&lt;/b&gt; 또는 &lt;b&gt;심볼릭 링크&lt;/b&gt; . Perl은 &lt;code&gt;&amp;ndash;f&lt;/code&gt; 파일 테스트 연산자를 사용하여 일반 파일을 식별합니다. &quot;일반&quot;파일이라고도합니다.</target>
        </trans-unit>
        <trans-unit id="ed2a6a7fae032e7b7f63170d07ec12a9d190796a" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;function&lt;/b&gt; call directly to the &lt;b&gt;operating system&lt;/b&gt;. Many of the important subroutines and functions you use aren&amp;rsquo;t direct system calls, but are built up in one or more layers above the system call level. In general, Perl programmers don&amp;rsquo;t need to worry about the distinction. However, if you do happen to know which Perl functions are really syscalls, you can predict which of these will set the &lt;code&gt;$!&lt;/code&gt; (&lt;code&gt;$ERRNO&lt;/code&gt; ) variable on failure. Unfortunately, beginning programmers often confusingly employ the term &amp;ldquo;system call&amp;rdquo; to mean what happens when you call the Perl &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; function, which actually involves many syscalls. To avoid any confusion, we nearly always say &amp;ldquo;syscall&amp;rdquo; for something you could call indirectly via Perl&amp;rsquo;s &lt;code&gt;&lt;a href=&quot;functions/syscall&quot;&gt;syscall&lt;/a&gt;&lt;/code&gt; function, and never for something you would call with Perl&amp;rsquo;s &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; function.</source>
          <target state="translated">&lt;b&gt;기능&lt;/b&gt; 받는 직접 전화 &lt;b&gt;운영 체제&lt;/b&gt; . 사용하는 많은 중요한 서브 루틴 및 기능은 직접 시스템 호출이 아니지만 시스템 호출 레벨 이상의 하나 이상의 계층에 구축됩니다. 일반적으로 Perl 프로그래머는 그 차이점에 대해 걱정할 필요가 없습니다. 그러나 어떤 펄 함수가 실제로 syscall인지 알고 있다면,이 중 어떤 것이 &lt;code&gt;$!&lt;/code&gt; 실패시 ( &lt;code&gt;$ERRNO&lt;/code&gt; ) 변수. 불행히도, 초보 프로그래머는 종종 &quot;시스템 호출&quot;이라는 용어를 혼동하여 Perl &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; 함수 를 호출 할 때 발생하는 것을 의미합니다 . 실제로 많은 시스템 호출이 필요합니다. 혼란을 피하기 위해, 우리는 거의 항상 Perl을 통해 간접적으로 호출 할 수있는 것에 대해 &quot;syscall&quot;이라고 말합니다. &lt;code&gt;&lt;a href=&quot;functions/syscall&quot;&gt;syscall&lt;/a&gt;&lt;/code&gt; 함수, Perl의 &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; 함수로호출 할 수있는기능은 없습니다.</target>
        </trans-unit>
        <trans-unit id="dcd5ec0f720736e7e329b0a32b061d1c915a3b97" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;function&lt;/b&gt; call directly to the &lt;b&gt;operating system&lt;/b&gt;. Many of the important subroutines and functions you use aren&amp;rsquo;t direct system calls, but are built up in one or more layers above the system call level. In general, Perl programmers don&amp;rsquo;t need to worry about the distinction. However, if you do happen to know which Perl functions are really syscalls, you can predict which of these will set the &lt;code&gt;$!&lt;/code&gt; (&lt;code&gt;$ERRNO&lt;/code&gt;) variable on failure. Unfortunately, beginning programmers often confusingly employ the term &amp;ldquo;system call&amp;rdquo; to mean what happens when you call the Perl &lt;code&gt;system&lt;/code&gt; function, which actually involves many syscalls. To avoid any confusion, we nearly always say &amp;ldquo;syscall&amp;rdquo; for something you could call indirectly via Perl&amp;rsquo;s &lt;code&gt;syscall&lt;/code&gt; function, and never for something you would call with Perl&amp;rsquo;s &lt;code&gt;system&lt;/code&gt; function.</source>
          <target state="translated">&lt;b&gt;기능&lt;/b&gt; 받는 직접 전화 &lt;b&gt;운영 체제&lt;/b&gt; . 사용하는 중요한 서브 루틴과 함수의 대부분은 직접 시스템 호출이 아니지만 시스템 호출 수준 위의 하나 이상의 계층에 구축됩니다. 일반적으로 Perl 프로그래머는 구별에 대해 걱정할 필요가 없습니다. 그러나 어떤 Perl 함수가 실제로 syscall인지 아는 경우,이 중 어떤 것이 &lt;code&gt;$!&lt;/code&gt; 를 설정할지 예측할 수 있습니다 . 실패시 ( &lt;code&gt;$ERRNO&lt;/code&gt; ) 변수. 안타깝게도 초보 프로그래머는 종종 &quot;시스템 호출&quot;이라는 용어를 사용하여 Perl &lt;code&gt;system&lt;/code&gt; 을 호출 할 때 발생하는 일을 의미 합니다.실제로 많은 syscall을 포함하는 함수입니다. 혼동을 피하기 위해 우리는 거의 항상 Perl의 &lt;code&gt;syscall&lt;/code&gt; 함수 를 통해 간접적으로 호출 할 수있는 항목에 대해 &quot;syscall&quot;이라고 말하고 Perl의 &lt;code&gt;system&lt;/code&gt; 함수로 호출 할 항목에 대해서는 절대로 말하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="d9dedded5626e20b474bf02bc245fb0066d03ede" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;function&lt;/b&gt; that is predefined in the language. Even when hidden by &lt;b&gt;overriding&lt;/b&gt;, you can always get at a built- in function by &lt;b&gt;qualifying&lt;/b&gt; its name with the &lt;code&gt;CORE::&lt;/code&gt; pseudopackage.</source>
          <target state="translated">&lt;b&gt;기능&lt;/b&gt; 언어에 미리 정의되어있다. &lt;b&gt;재정&lt;/b&gt; 의하여 숨겨져 있어도 &lt;code&gt;CORE::&lt;/code&gt; pseudopackage로 이름을 &lt;b&gt;한정&lt;/b&gt; 하여 내장 함수를 항상 얻을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="017327ec6f67ab86c897b578939f74863c44350b" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;grapheme&lt;/b&gt; consisting of either a carriage return followed by a line feed or any character with the Unicode Vertical Space &lt;b&gt;character property&lt;/b&gt;.</source>
          <target state="translated">캐리지 리턴 다음에 줄 바꿈 또는 Unicode Vertical Space &lt;b&gt;문자 속성이&lt;/b&gt; 있는 &lt;b&gt;문자&lt;/b&gt; 로 구성된 그래프 입니다.&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="8ef4c16c3e84bcc76d6d7f8f70086c0645d39a22" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;handler&lt;/b&gt; that you register with some other part of your program in the hope that the other part of your program will &lt;b&gt;trigger&lt;/b&gt; your handler when some event of interest transpires.</source>
          <target state="translated">관심있는 이벤트가 발생할 때 프로그램의 다른 부분이 핸들러 를 &lt;b&gt;트리거&lt;/b&gt; 하기를 희망하여 프로그램의 다른 부분에 등록 하는 &lt;b&gt;핸들러&lt;/b&gt; .&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="9a3af3525966bde47d8478ba5aa28630e345cb9d" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;lexical variable&lt;/b&gt; lexical&amp;gt;that is declared with a &lt;b&gt;class&lt;/b&gt; type: &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; Pony $bill&lt;/code&gt; .</source>
          <target state="translated">&lt;b&gt;클래스&lt;/b&gt; 유형으로 선언 된 &lt;b&gt;어휘 변수&lt;/b&gt; lexical&amp;gt; : &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; Pony $bill&lt;/code&gt; Pony $ bill .&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="0039cc9cd8e39570b8877a1785674415311675e9" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;lexical variable&lt;/b&gt; lexical&amp;gt;that is declared with a &lt;b&gt;class&lt;/b&gt; type: &lt;code&gt;my Pony $bill&lt;/code&gt;.</source>
          <target state="translated">&lt;b&gt;클래스&lt;/b&gt; 유형 &lt;code&gt;my Pony $bill&lt;/code&gt; 로 선언 된 &lt;b&gt;어휘 변수&lt;/b&gt; lexical&amp;gt; .&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="3c3163207648959163d9c84cb3f038389746ed27" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;line&lt;/b&gt; in a file consists of zero or more non-newline characters, terminated by either a newline or the end of the file.</source>
          <target state="translated">파일 의 &lt;b&gt;줄&lt;/b&gt; 은 개행 문자가 아닌 0 개 이상의 문자로 구성되며 줄 바꿈이나 파일 끝으로 끝납니다.</target>
        </trans-unit>
        <trans-unit id="e216248dbe62e4deb5d290410cf6cba07540c708" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;list value&lt;/b&gt; with zero elements, represented in Perl by &lt;code&gt;()&lt;/code&gt; .</source>
          <target state="translated">&lt;b&gt;리스트 값&lt;/b&gt; 에 의해 표현 펄 제로 요소, &lt;code&gt;()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0ab4abc50479b714a6d10020d55e78dc7b1940fd" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;list value&lt;/b&gt; with zero elements, represented in Perl by &lt;code&gt;()&lt;/code&gt;.</source>
          <target state="translated">&lt;b&gt;리스트 값&lt;/b&gt; 에 의해 표현 펄 제로 요소, &lt;code&gt;()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="45d256991d914c75f7b2e344bf10f0577b5147db" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;method&lt;/b&gt; of an &lt;b&gt;object&lt;/b&gt;, as opposed to a &lt;b&gt;class method&lt;/b&gt;.</source>
          <target state="translated">&lt;b&gt;방법&lt;/b&gt; 의 &lt;b&gt;객체&lt;/b&gt; 와 같은 반대 &lt;b&gt;클래스 메소드&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="cd9f719db48a7ef2cd4cdce77f9516eff0561abe" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;method&lt;/b&gt; used to indirectly inspect or update an &lt;b&gt;object&lt;/b&gt;&amp;rsquo;s state (its &lt;b&gt;instance variables&lt;/b&gt;).</source>
          <target state="translated">&lt;b&gt;방법은&lt;/b&gt; 간접적으로 조사 또는 업데이트 할 &lt;b&gt;객체&lt;/b&gt; 의 상태 (해당 &lt;b&gt;인스턴스 변수&lt;/b&gt; ).</target>
        </trans-unit>
        <trans-unit id="3f76f67b831d3545d647111a95485f14adb897eb" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;method&lt;/b&gt; whose &lt;b&gt;invocant&lt;/b&gt; is a &lt;b&gt;package&lt;/b&gt; name, not an &lt;b&gt;object&lt;/b&gt; reference. A method associated with the class as a whole. Also see &lt;b&gt;instance method&lt;/b&gt;.</source>
          <target state="translated">&lt;b&gt;있어서&lt;/b&gt; 그 &lt;b&gt;invocant는&lt;/b&gt; A는 &lt;b&gt;패키지&lt;/b&gt; 이름 아닌 &lt;b&gt;오브젝트&lt;/b&gt; 참조. 클래스 전체와 관련된 메소드입니다. &lt;b&gt;instance method&lt;/b&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="67eb1a20651dea215f187f74f8fc385e50d58eac" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;method&lt;/b&gt; whose &lt;b&gt;invocant&lt;/b&gt; is an &lt;b&gt;object&lt;/b&gt;, not a &lt;b&gt;package&lt;/b&gt; name. Every object of a class shares all the methods of that class, so an instance method applies to all instances of the class, rather than applying to a particular instance. Also see &lt;b&gt;class method&lt;/b&gt;.</source>
          <target state="translated">&lt;b&gt;있어서&lt;/b&gt; 그 &lt;b&gt;invocant는&lt;/b&gt; 인 &lt;b&gt;객체&lt;/b&gt; 가 아니라 &lt;b&gt;패키지&lt;/b&gt; 의 이름. 클래스의 모든 객체는 해당 클래스의 모든 메소드를 공유하므로 인스턴스 메소드는 특정 인스턴스에 적용하지 않고 클래스의 모든 인스턴스에 적용됩니다. &lt;b&gt;class method&lt;/b&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="9a608f9301d7c9b44868aa9a54155b51fc141a42" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;mortal&lt;/b&gt; SV.</source>
          <target state="translated">&lt;b&gt;인간&lt;/b&gt; SV.</target>
        </trans-unit>
        <trans-unit id="53f7bde55489a9151bd15ee3f737a362e089a682" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;namespace&lt;/b&gt; for global &lt;b&gt;variables&lt;/b&gt;, &lt;b&gt;subroutines&lt;/b&gt;, and the like, such that they can be kept separate from like-named &lt;b&gt;symbols&lt;/b&gt; in other namespaces. In a sense, only the package is global, since the symbols in the package&amp;rsquo;s symbol table are only accessible from code &lt;b&gt;compiled&lt;/b&gt; outside the package by naming the package. But in another sense, all package symbols are also globals&amp;mdash;they&amp;rsquo;re just well-organized globals.</source>
          <target state="translated">&lt;b&gt;네임 스페이스&lt;/b&gt; 세계에 대한 &lt;b&gt;변수&lt;/b&gt; , &lt;b&gt;서브 루틴&lt;/b&gt; 들이 유사한 이름 별도로 보관 될 수 있도록, 등, &lt;b&gt;기호를&lt;/b&gt; 다른 네임 스페이스입니다. 어떤 의미에서 패키지의 심볼 테이블에있는 심볼 은 패키지 이름을 지정하여 패키지 외부에서 &lt;b&gt;컴파일 된&lt;/b&gt; 코드에서만 액세스 할 수 있기 때문에 패키지 만 전역 적 입니다. 그러나 다른 의미에서, 모든 패키지 심볼은 글로벌 (global)이며, 잘 조직 된 글로벌 (global)입니다.</target>
        </trans-unit>
        <trans-unit id="28abc12d5fd2eda36e36f614d582aeb865b478e3" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;newline sequence&lt;/b&gt; is usually a platform-dependent concept, but Pod parsers should understand it to mean any of CR (ASCII 13), LF (ASCII 10), or a CRLF (ASCII 13 followed immediately by ASCII 10), in addition to any other system-specific meaning. The first CR/CRLF/LF sequence in the file may be used as the basis for identifying the newline sequence for parsing the rest of the file.</source>
          <target state="translated">&lt;b&gt;개행 시퀀스는&lt;/b&gt; 일반적으로 플랫폼 의존 개념이지만, 포드 파서는 CR (ASCII 13), LF (ASCII 10) 또는 CRLF 중 하나를 의미하는 것으로 이해해야한다 어느 이외에 (ASCII 13 즉시 ASCII 10 하였다) 다른 시스템 별 의미. 파일 내의 제 1 CR / CRLF / LF 시퀀스는 파일의 나머지를 파싱하기위한 개행 시퀀스를 식별하기위한 기초로서 사용될 수있다.</target>
        </trans-unit>
        <trans-unit id="28a5d8434506c4b65f1bc6f82e7222a2e44f2923" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;pipe&lt;/b&gt; with a name embedded in the &lt;b&gt;filesystem&lt;/b&gt; so that it can be accessed by two unrelated &lt;b&gt;processes&lt;/b&gt;.</source>
          <target state="translated">&lt;b&gt;파이프&lt;/b&gt; 에 포함 된 이름을 가진 &lt;b&gt;파일 시스템&lt;/b&gt; 이 두 개의 관련되지 않은 액세스 할 수 있도록하는 것이 &lt;b&gt;공정&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="b07ce80ba704512a4daf926d6423f21ae6d581f7" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;pod&lt;/b&gt; directive. See Camel chapter 23, &amp;ldquo;Plain Old Documentation&amp;rdquo;.</source>
          <target state="translated">&lt;b&gt;포드&lt;/b&gt; 지시어. 낙타 23 장 &quot;일반 문서&quot;를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="a7bb769998e6fdfcf3ee0c66d7f29c1ed39a8790" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;pumpkin&lt;/b&gt; holder, the person in charge of pumping the pump, or at least priming it. Must be willing to play the part of the Great Pumpkin now and then.</source>
          <target state="translated">&lt;b&gt;호박&lt;/b&gt; 홀더, 펌프를 펌핑, 또는 적어도 그것을 프라이밍 담당하는 사람입니다. 때때로 Great Pumpkin의 일부를 기꺼이 맡아야합니다.</target>
        </trans-unit>
        <trans-unit id="e6f9796d5e8ba560b9616a39b17ea2e32ae9ff4b" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;regular expression&lt;/b&gt; component potentially matching a &lt;b&gt;substring&lt;/b&gt; containing one or more characters and treated as an indivisible syntactic unit by any following &lt;b&gt;quantifier&lt;/b&gt;. (Contrast with an &lt;b&gt;assertion&lt;/b&gt; that matches something of &lt;b&gt;zero width&lt;/b&gt; and may not be quantified.)</source>
          <target state="translated">&lt;b&gt;정규식&lt;/b&gt; 요소는 잠재적으로 일치하는 &lt;b&gt;문자열&lt;/b&gt; 하나 이상의 문자 및 따라 불가분 신택 틱 단위로 처리 함유 &lt;b&gt;한정사를&lt;/b&gt; . &lt;b&gt;너비&lt;/b&gt; 가 &lt;b&gt;0 인&lt;/b&gt; 것과 일치 하는 &lt;b&gt;어설 션&lt;/b&gt; 과 대조되며 수량화되지 않을 수 있습니다.&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="a4efc9f0f784617b2ff5677e0ce1302bbda5d4d6" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;regular expression&lt;/b&gt; subpattern whose real purpose is to execute some Perl code&amp;mdash;for example, the &lt;code&gt;(?{...})&lt;/code&gt; and &lt;code&gt;(??{...})&lt;/code&gt; subpatterns.</source>
          <target state="translated">&lt;b&gt;정규식&lt;/b&gt; 그의 진정한 목적 서브 패턴 일부 펄 코드 예는 실행하는 것이다 &lt;code&gt;(?{...})&lt;/code&gt; 및 &lt;code&gt;(??{...})&lt;/code&gt; 서브 패턴.</target>
        </trans-unit>
        <trans-unit id="b7ffd563f4456054759e7694e65ebb89f76facae" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;scalar&lt;/b&gt;&lt;b&gt;value&lt;/b&gt; containing the actual address of a &lt;b&gt;referent&lt;/b&gt;, such that the referent&amp;rsquo;s &lt;b&gt;reference&lt;/b&gt; count accounts for it. (Some hard references are held internally, such as the implicit reference from one of a &lt;b&gt;typeglob&lt;/b&gt;&amp;rsquo;s variable slots to its corresponding referent.) A hard reference is different from a &lt;b&gt;symbolic reference&lt;/b&gt;.</source>
          <target state="translated">&lt;b&gt;스칼라 &lt;/b&gt;&lt;b&gt;값&lt;/b&gt; (A)의 실제 주소를 포함하는 &lt;b&gt;지시 대상은&lt;/b&gt; , 리파의되도록 &lt;b&gt;기준&lt;/b&gt; 카운트가 차지한다. ( &lt;b&gt;글로벌&lt;/b&gt; 의 가변 슬롯 중 하나 에서 해당하는 참조에 대한 암시 적 참조와 같은 일부 하드 참조는 내부적으로 보유됩니다 .) 하드 참조는 &lt;b&gt;기호 참조&lt;/b&gt; 와 다릅니다 .</target>
        </trans-unit>
        <trans-unit id="5022eeaf3b922dfb2c6df5364e9c4781dc19e0ff" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;stash&lt;/b&gt; is a hash that contains all variables that are defined within a package. Each key of the stash is a symbol name (shared by all the different types of objects that have the same name), and each value in the hash table is a GV (Glob Value). This GV in turn contains references to the various objects of that name, including (but not limited to) the following:</source>
          <target state="translated">&lt;b&gt;숨겨 놓은&lt;/b&gt; 패키지 내에서 정의 된 모든 변수를 포함하는 해시입니다. 숨김의 각 키는 기호 이름 (같은 이름을 가진 모든 다른 유형의 객체가 공유)이며 해시 테이블의 각 값은 GV (Glob Value)입니다. 이 GV에는 다음을 포함하여 해당 이름의 다양한 객체에 대한 참조가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="92b538532d72576aaeda7a7cef805a1cba7aaa2a" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;string&lt;/b&gt; containing no characters, not to be confused with a string containing a &lt;b&gt;null character&lt;/b&gt;, which has a positive length and is &lt;b&gt;true&lt;/b&gt;.</source>
          <target state="translated">&lt;b&gt;문자열&lt;/b&gt; 에 문자를 포함하지 않는가하는이 포함 된 문자열과 혼동하지 &lt;b&gt;NULL 문자&lt;/b&gt; 긍정적 인 길이이며, &lt;b&gt;사실을&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="f0d02500198bfb1874e50da33c4e532a6d834d3e" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;string&lt;/b&gt; or &lt;b&gt;file&lt;/b&gt; containing primarily printable characters.</source>
          <target state="translated">주로 인쇄 가능한 문자가 포함 된 &lt;b&gt;문자열&lt;/b&gt; 또는 &lt;b&gt;파일&lt;/b&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="963346bf337afa73872e46c5b7ebdcda13950ed0" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;subpattern&lt;/b&gt; whose &lt;b&gt;quantifier&lt;/b&gt; wants to match as many things as possible.</source>
          <target state="translated">&lt;b&gt;서브 패턴&lt;/b&gt; 누구의 &lt;b&gt;정량이&lt;/b&gt; 가능한 여러 가지로 일치하고 싶어.</target>
        </trans-unit>
        <trans-unit id="b40a047ee9609abd7c464a0e25538925a09e0994" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;subroutine&lt;/b&gt; or &lt;b&gt;method&lt;/b&gt; that Perl calls when your program needs to respond to some internal event, such as a &lt;b&gt;signal&lt;/b&gt;, or an encounter with an operator subject to &lt;b&gt;operator overloading&lt;/b&gt;. See also &lt;b&gt;callback&lt;/b&gt;.</source>
          <target state="translated">프로그램이 &lt;b&gt;신호&lt;/b&gt; 와 같은 일부 내부 이벤트에 응답 하거나 &lt;b&gt;운영자 과부하&lt;/b&gt; 가 발생할 수있는 운영자와의 만남에 필요할 때 Perl이 호출 하는 &lt;b&gt;서브 루틴&lt;/b&gt; 또는 &lt;b&gt;방법&lt;/b&gt; . &lt;b&gt;콜백&lt;/b&gt; 도 참조하십시오 .&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="b88557bd91c6ee2c1cde6ebbe7211914850d4976" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;subroutine&lt;/b&gt; that, instead of being content to be called in the normal fashion, sits around waiting for a bolt out of the blue before it will deign to &lt;b&gt;execute&lt;/b&gt;. Under Perl, bolts out of the blue are called signals, and you send them with the &lt;code&gt;&lt;a href=&quot;functions/kill&quot;&gt;kill&lt;/a&gt;&lt;/code&gt; built-in. See the &lt;code&gt;%SIG&lt;/code&gt; hash in Camel chapter 25, &amp;ldquo;Special Names&amp;rdquo; and the section &amp;ldquo;Signals&amp;rdquo; in Camel chapter 15, &amp;ldquo;Interprocess Communication&amp;rdquo;.</source>
          <target state="translated">콘텐츠가 일반적인 방식으로 호출되는 대신 파란 색의 볼트를 기다리고 &lt;b&gt;실행&lt;/b&gt; 되기 전에 대기 하는 &lt;b&gt;서브 루틴&lt;/b&gt; 입니다 . Perl에서 파란색의 볼트를 신호라고하며 &lt;code&gt;&lt;a href=&quot;functions/kill&quot;&gt;kill&lt;/a&gt;&lt;/code&gt; 내장 기능으로 전송합니다 . Camel 25 장, &quot;특수 이름&quot; 의 &lt;code&gt;%SIG&lt;/code&gt; 해시와 Camel 15 장, &quot;프로세스 간 통신&quot;의 &quot;신호&quot;섹션을 참조하십시오.&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="6eb90f749c779c72ed00584c8a37ccf80a60ff84" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;subroutine&lt;/b&gt; that, instead of being content to be called in the normal fashion, sits around waiting for a bolt out of the blue before it will deign to &lt;b&gt;execute&lt;/b&gt;. Under Perl, bolts out of the blue are called signals, and you send them with the &lt;code&gt;kill&lt;/code&gt; built-in. See the &lt;code&gt;%SIG&lt;/code&gt; hash in Camel chapter 25, &amp;ldquo;Special Names&amp;rdquo; and the section &amp;ldquo;Signals&amp;rdquo; in Camel chapter 15, &amp;ldquo;Interprocess Communication&amp;rdquo;.</source>
          <target state="translated">&lt;b&gt;서브 루틴&lt;/b&gt; 은 콴 티코의 예언자 전에 대신되는 콘텐츠 정상적인 방식으로 호출 할 수있는, 즉, 주변의 파란색에서 볼트를 기다리고 앉아 &lt;b&gt;실행합니다&lt;/b&gt; . Perl에서는 파란색에서 튀어 나온 볼트를 신호라고하며 &lt;code&gt;kill&lt;/code&gt; 내장 된 상태로 보냅니다 . Camel 25 장 &quot;특수 이름&quot; 의 &lt;code&gt;%SIG&lt;/code&gt; 해시와 Camel 15 장 &quot;프로세스 간 통신&quot;의 &quot;신호&quot;섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="322f029b3b0fb52a6b3d088717d1bec9ab25e434" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;subroutine&lt;/b&gt;.</source>
          <target state="translated">&lt;b&gt;서브 루틴&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="76724a25473397cad776a8c2a824ea6f3262e159" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;symbol&lt;/b&gt; such as &lt;code&gt;+&lt;/code&gt; or &lt;code&gt;/&lt;/code&gt; that tells Perl to do the arithmetic you were supposed to learn in grade school.</source>
          <target state="translated">&lt;b&gt;기호&lt;/b&gt; 와 같은 &lt;code&gt;+&lt;/code&gt; 나 &lt;code&gt;/&lt;/code&gt; 당신이 초등학교에서 배운하기로했다 산술을 할 펄을 알려줍니다.</target>
        </trans-unit>
        <trans-unit id="d32877203298997d4e4d665fab49d7f32caf1082" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;value&lt;/b&gt; chosen for you if you don&amp;rsquo;t supply a value of your own.</source>
          <target state="translated">&lt;b&gt;값은&lt;/b&gt; 당신이 당신의 자신의 값을 제공하지 않는 경우에 당신을위한 선택.</target>
        </trans-unit>
        <trans-unit id="87af2986b4851cce0bdd68d60a1169a1374d676b" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;value&lt;/b&gt; that indicates the position of a particular &lt;b&gt;array&lt;/b&gt;&lt;b&gt;element&lt;/b&gt; in an array.</source>
          <target state="translated">&lt;b&gt;값을&lt;/b&gt; 특정의 위치를 나타내는 &lt;b&gt;배열 &lt;/b&gt;&lt;b&gt;요소를&lt;/b&gt; 배열한다.</target>
        </trans-unit>
        <trans-unit id="56587e718c7ecb23875006ffccf7c7d756c6fa62" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;value&lt;/b&gt; that you might find on the right side of an &lt;b&gt;assignment&lt;/b&gt;. See also &lt;b&gt;lvalue&lt;/b&gt;.</source>
          <target state="translated">&lt;b&gt;과제&lt;/b&gt; 의 오른쪽에서 찾을 수 있는 &lt;b&gt;값&lt;/b&gt; 입니다 . &lt;b&gt;lvalue&lt;/b&gt; 도 참조하십시오 .&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="99b9fdd9de86d1d00f397b16abef1b9cafbc97c4" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;variable&lt;/b&gt; in a language like C that contains the exact memory location of some other item. Perl handles pointers internally so you don&amp;rsquo;t have to worry about them. Instead, you just use symbolic pointers in the form of &lt;b&gt;keys&lt;/b&gt; and &lt;b&gt;variable&lt;/b&gt; names, or &lt;b&gt;hard references&lt;/b&gt;, which aren&amp;rsquo;t pointers (but act like pointers and do in fact contain pointers).</source>
          <target state="translated">다른 항목의 정확한 메모리 위치를 포함하는 C와 같은 언어 의 &lt;b&gt;변수&lt;/b&gt; 입니다. Perl은 포인터를 내부적으로 처리하므로 걱정할 필요가 없습니다. 대신, 포인터 가 아닌 &lt;b&gt;키&lt;/b&gt; 와 &lt;b&gt;변수&lt;/b&gt; 이름 또는 &lt;b&gt;하드 참조&lt;/b&gt; 의 형태로 기호 포인터를 사용하십시오 (그러나 포인터처럼 작동하고 실제로 포인터를 포함합니다).</target>
        </trans-unit>
        <trans-unit id="51c90d619538801ef4598602775b97c77a42912f" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;variable&lt;/b&gt; prefixed with &lt;code&gt;$&lt;/code&gt; that holds a single value.</source>
          <target state="translated">&lt;b&gt;변수&lt;/b&gt; 로 시작 &lt;code&gt;$&lt;/code&gt; 단일 값을 보유하고 있습니다.</target>
        </trans-unit>
        <trans-unit id="a036ff35f0b4159168ba2281ee65e4b238ac5692" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;variable&lt;/b&gt; subject to &lt;b&gt;lexical scoping&lt;/b&gt;, declared by &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt;. Often just called a &amp;ldquo;lexical&amp;rdquo;. (The &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; declaration declares a lexically scoped name for a global variable, which is not itself a lexical variable.)</source>
          <target state="translated">&lt;b&gt;변수&lt;/b&gt; 에 따라 &lt;b&gt;어휘 범위 지정&lt;/b&gt; , 선언 &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; . 종종 &quot;어휘&quot;라고 불렀습니다. ( &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; 선언은 전역 변수에 대한 어휘 범위가 지정된 이름을 선언하는데, 그 자체는 어휘 변수가 아닙니다.)</target>
        </trans-unit>
        <trans-unit id="06985481b8abaac45139622f2df52c61b1d4a275" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;variable&lt;/b&gt; subject to &lt;b&gt;lexical scoping&lt;/b&gt;, declared by &lt;code&gt;my&lt;/code&gt;. Often just called a &amp;ldquo;lexical&amp;rdquo;. (The &lt;code&gt;our&lt;/code&gt; declaration declares a lexically scoped name for a global variable, which is not itself a lexical variable.)</source>
          <target state="translated">&lt;b&gt;변수&lt;/b&gt; 에 따라 &lt;b&gt;어휘 범위 지정&lt;/b&gt; , 선언 &lt;code&gt;my&lt;/code&gt; . 종종 &quot;어휘&quot;라고 불립니다. ( &lt;code&gt;our&lt;/code&gt; 선언은 그 자체가 어휘 변수가 아닌 전역 변수에 대해 어휘 범위 이름을 선언합니다.)</target>
        </trans-unit>
        <trans-unit id="d364f02d6990848dc623c28306b3b67cfe16a460" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;verbatim paragraph&lt;/b&gt;. The first line of this paragraph must be a literal space or tab, and this paragraph must not be inside a &quot;=begin</source>
          <target state="translated">&lt;b&gt;그대로 단락&lt;/b&gt; . 이 단락의 첫 줄은 문자 그대로의 공백 또는 탭이어야하며이 단락은 &quot;= 시작하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="42c5695455abfd814bba117ac56b83739b6fccd8" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;()&lt;/code&gt; group is a sub-TEMPLATE enclosed in parentheses. A group may take a repeat count either as postfix, or for &lt;a href=&quot;#unpack-TEMPLATE%2CEXPR&quot;&gt;&lt;code&gt;unpack&lt;/code&gt;&lt;/a&gt;, also via the &lt;code&gt;/&lt;/code&gt; template character. Within each repetition of a group, positioning with &lt;code&gt;@&lt;/code&gt; starts over at 0. Therefore, the result of</source>
          <target state="translated">&lt;code&gt;()&lt;/code&gt; 그룹은 괄호 안에 서브 템플릿이다. 그룹은 &lt;code&gt;/&lt;/code&gt; 템플릿 문자 를 통해 접미사 또는 &lt;a href=&quot;#unpack-TEMPLATE%2CEXPR&quot;&gt; &lt;code&gt;unpack&lt;/code&gt; &lt;/a&gt; 의 반복 횟수를 취할 수 있습니다 . 그룹의 각 반복 내에서 &lt;code&gt;@&lt;/code&gt; 를 사용한 위치 지정 은 0에서 시작합니다. 따라서</target>
        </trans-unit>
        <trans-unit id="6c2475be186a7213d2a980a851a800269b2e5a86" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;()&lt;/code&gt; group is a sub-TEMPLATE enclosed in parentheses. A group may take a repeat count either as postfix, or for unpack(), also via the &lt;code&gt;/&lt;/code&gt; template character. Within each repetition of a group, positioning with &lt;code&gt;@&lt;/code&gt; starts over at 0. Therefore, the result of</source>
          <target state="translated">&lt;code&gt;()&lt;/code&gt; 그룹은 괄호 안에 서브 템플릿이다. 그룹은 &lt;code&gt;/&lt;/code&gt; fix 문자 를 통해 postfix 또는 unpack ()에 대해 반복 횟수를 취할 수 있습니다 . 그룹이 반복 될 때마다 &lt;code&gt;@&lt;/code&gt; 로 위치가 0부터 시작합니다. 따라서</target>
        </trans-unit>
        <trans-unit id="a287ce1841efe5bc899e4207e715388b0c45e263" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;*&lt;/code&gt; allows the subroutine to accept a bareword, constant, scalar expression, typeglob, or a reference to a typeglob in that slot. The value will be available to the subroutine either as a simple scalar, or (in the latter two cases) as a reference to the typeglob. If you wish to always convert such arguments to a typeglob reference, use Symbol::qualify_to_ref() as follows:</source>
          <target state="translated">&lt;code&gt;*&lt;/code&gt; 은 서브 루틴이 bareword는 일정한 스칼라 식 타입 글로브, 또는 슬롯의 타입 글로브의 참조를 접수 할 수있다. 이 값은 서브 루틴에 간단한 스칼라로, 또는 후자의 경우에 타입 글로브에 대한 참조로 사용 가능합니다. 이러한 인수를 항상 typeglob 참조로 변환하려면 다음과 같이 Symbol :: qualify_to_ref ()를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="175dabd836c19199f903fe2faf157b003fcf09ec" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;*&lt;/code&gt; for the repeat count uses all characters of the input field. For &lt;a href=&quot;#unpack-TEMPLATE%2CEXPR&quot;&gt;&lt;code&gt;unpack&lt;/code&gt;&lt;/a&gt;, nybbles are converted to a string of hexadecimal digits.</source>
          <target state="translated">&lt;code&gt;*&lt;/code&gt; 반복 횟수에 대한 입력 필드의 모든 문자를 사용합니다. 의 경우 &lt;a href=&quot;#unpack-TEMPLATE%2CEXPR&quot;&gt; &lt;code&gt;unpack&lt;/code&gt; &lt;/a&gt; , nybbles는 16 진수 문자열로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="61da191aeee246a70549905e1a2b4d958c2fd1c9" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;*&lt;/code&gt; for the repeat count uses all characters of the input field. For unpack(), nybbles are converted to a string of hexadecimal digits.</source>
          <target state="translated">반복 횟수 의 &lt;code&gt;*&lt;/code&gt; 는 입력 필드의 모든 문자를 사용합니다. unpack ()의 ​​경우, nybbles는 16 진수 문자열로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="815c847c3d1b9e3c91a01ec8d23807326737a6a0" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;*&lt;/code&gt; for the repeat count uses all characters of the input field. On unpacking, bits are converted to a string of &lt;code&gt;0&lt;/code&gt; s and &lt;code&gt;1&lt;/code&gt; s.</source>
          <target state="translated">반복 횟수 의 &lt;code&gt;*&lt;/code&gt; 는 입력 필드의 모든 문자를 사용합니다. 언 패킹시 비트는 &lt;code&gt;0&lt;/code&gt; 과 &lt;code&gt;1&lt;/code&gt; 의 문자열로 변환됩니다 .</target>
        </trans-unit>
        <trans-unit id="f9e01e48d826d5a43209d5317fe5971b7609b128" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;*&lt;/code&gt; for the repeat count uses all characters of the input field. On unpacking, bits are converted to a string of &lt;code&gt;0&lt;/code&gt;s and &lt;code&gt;1&lt;/code&gt;s.</source>
          <target state="translated">&lt;code&gt;*&lt;/code&gt; 반복 횟수에 대한 입력 필드의 모든 문자를 사용합니다. 압축을 풀 때 비트는 &lt;code&gt;0&lt;/code&gt; 과 &lt;code&gt;1&lt;/code&gt; 의 문자열로 변환됩니다 .</target>
        </trans-unit>
        <trans-unit id="89c65ec9d77b183c5b39e5d9c73a8c71422dfc22" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;--&lt;/code&gt; signals the end of options and disables further option processing. Any arguments after the &lt;code&gt;--&lt;/code&gt; are treated as filenames and arguments.</source>
          <target state="translated">A는 &lt;code&gt;--&lt;/code&gt; 옵션 및 상기 비활성화 옵션 처리의 종료 신호를 보낸다. &lt;code&gt;--&lt;/code&gt; 다음의 인수 는 파일 이름과 인수로 취급됩니다.</target>
        </trans-unit>
        <trans-unit id="bde6ae184752daa5e5b6a5c7417008782a0b714a" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork()&lt;/a&gt;&lt;/code&gt; failure may result in the following tests failing:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork()&lt;/a&gt;&lt;/code&gt; 실패 실패 다음 테스트 될 수있다 :</target>
        </trans-unit>
        <trans-unit id="290859ef4b0199eb4b067a5c07f38a6730cc7301" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; is simply a modifier on an lvalue expression. When you assign to a &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt;ized variable, the &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; doesn't change whether its list is viewed as a scalar or an array. So</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; 단순히 좌변 식의 수정이다. 당신이에 할당 할 때 &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; 화된 변수의 &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; 그 목록들이 스칼라 나 배열로 보이는 것을 바꾸지 않는다. 그래서</target>
        </trans-unit>
        <trans-unit id="1ac670f70b9818c1a06875d85552011a54fbdd94" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; modifies its listed variables to be &quot;local&quot; to the enclosing block, &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt; FILE&lt;/code&gt; --and to</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; 수정은 나열된 변수 &quot;로컬&quot;이 둘러싸는 블록을 위해 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 하거나 &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt; FILE&lt;/code&gt; 에 - 그리고</target>
        </trans-unit>
        <trans-unit id="5e64f0ec46a4ae84b19fc32e43ef29768338a5a4" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; declares the listed variables to be local (lexically) to the enclosing block, file, or &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;. If more than one variable is listed, the list must be placed in parentheses.</source>
          <target state="translated">A는 &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; 나열된 변수는 둘러싸 블록, 파일 또는로 (어휘) 지역으로 선언 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; . 둘 이상의 변수가 나열되면 목록을 괄호 안에 넣어야합니다.</target>
        </trans-unit>
        <trans-unit id="f1479b4bde8f3dbb0c16d564288196fd25f56ff5" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; has both a compile-time and a run-time effect. At compile time, the compiler takes notice of it. The principal usefulness of this is to quiet &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict 'vars'&lt;/code&gt; , but it is also essential for generation of closures as detailed in &lt;a href=&quot;perlref&quot;&gt;perlref&lt;/a&gt;. Actual initialization is delayed until run time, though, so it gets executed at the appropriate time, such as each time through a loop, for example.</source>
          <target state="translated">A는 &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; 컴파일 시간과 런타임 효과를 모두 가지고있다. 컴파일 타임에 컴파일러가이를 주목합니다. 이것의 주요 유용성은 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict 'vars'&lt;/code&gt; 를 조용하게 &lt;a href=&quot;functions/use&quot;&gt;사용하는&lt;/a&gt; 것이지만 &lt;a href=&quot;perlref&quot;&gt;perlref에&lt;/a&gt; 자세히 설명 된대로 클로저 생성에도 필수적입니다 . 그러나 실제 초기화는 런타임까지 지연되므로 루프와 같이 매번 적절한 시간에 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="31962f6029a8a1eb17179745d335b5ef4fc0067e" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&lt;a href=&quot;functions/return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; statement may be used to exit a subroutine, optionally specifying the returned value, which will be evaluated in the appropriate context (list, scalar, or void) depending on the context of the subroutine call. If you specify no return value, the subroutine returns an empty list in list context, the undefined value in scalar context, or nothing in void context. If you return one or more aggregates (arrays and hashes), these will be flattened together into one large indistinguishable list.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; 명령문 임의로 서브 루틴 호출의 상황에 따라 적절한 컨텍스트 (목록, 스칼라, 또는 공극)에서 평가 될 리턴 값을 지정하는 서브 루틴을 종료하기 위해 사용될 수있다. 리턴 값을 지정하지 않으면 서브 루틴은리스트 컨텍스트에서 빈 목록, 스칼라 컨텍스트에서 정의되지 않은 값 또는 void 컨텍스트에서 아무것도 리턴하지 않습니다. 하나 이상의 집계 (배열 및 해시)를 반환하면 이들을 하나의 큰 구별 할 수없는 목록으로 병합합니다.</target>
        </trans-unit>
        <trans-unit id="0e88bf889822c4c5cba2a75e272c3a1e9aeaadd3" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&lt;a href=&quot;my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; declares the listed variables to be local (lexically) to the enclosing block, file, or &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;. If more than one variable is listed, the list must be placed in parentheses.</source>
          <target state="translated">A는 &lt;code&gt;&lt;a href=&quot;my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; 나열된 변수는 둘러싸 블록, 파일 또는로 (어휘) 지역으로 선언 &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; . 둘 이상의 변수가 나열되면 목록을 괄호 안에 넣어야합니다.</target>
        </trans-unit>
        <trans-unit id="7218467ff9ee5b0a5da705bdf5367f50f9fd934e" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;=begin&lt;/code&gt; command was found that has no matching =end command.</source>
          <target state="translated">&lt;code&gt;=begin&lt;/code&gt; 명령이 일치 = 최종 명령이없는 것을 알 수 있었다.</target>
        </trans-unit>
        <trans-unit id="4e47480cd5deac560f9564740a3fdd3588ea30d3" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;=begin&lt;/code&gt; command was found that is not followed by the formatter specification.</source>
          <target state="translated">&lt;code&gt;=begin&lt;/code&gt; 명령이 포맷터 사양에 따르지 것을 알 수 있었다.</target>
        </trans-unit>
        <trans-unit id="5a9827f3a3a35194fce6eb84ce82e990f6ef9b53" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;=cut&lt;/code&gt; command was found without a preceding POD paragraph.</source>
          <target state="translated">&lt;code&gt;=cut&lt;/code&gt; 명령은 이전 POD 단락없이 발견되었다.</target>
        </trans-unit>
        <trans-unit id="4af95277282f9dbbdb980c39fe078720a20bab01" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;=pod&lt;/code&gt; command was found after a preceding POD paragraph.</source>
          <target state="translated">&lt;code&gt;=pod&lt;/code&gt; 명령은 이전 POD의 단락 뒤에 발견되었다.</target>
        </trans-unit>
        <trans-unit id="31f4edd1c949bdbda291e425d6bef6044643ffd6" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;BEGIN&lt;/code&gt; code block is executed as soon as possible, that is, the moment it is completely defined, even before the rest of the containing file (or string) is parsed. You may have multiple &lt;code&gt;BEGIN&lt;/code&gt; blocks within a file (or eval'ed string); they will execute in order of definition. Because a &lt;code&gt;BEGIN&lt;/code&gt; code block executes immediately, it can pull in definitions of subroutines and such from other files in time to be visible to the rest of the compile and run time. Once a &lt;code&gt;BEGIN&lt;/code&gt; has run, it is immediately undefined and any code it used is returned to Perl's memory pool.</source>
          <target state="translated">A는 &lt;code&gt;BEGIN&lt;/code&gt; 코드 블록은 가능한 한 빨리이라고로 실행, 그것은 완전히 정의 된 순간에도 포함 파일 (또는 문자열)의 나머지 전에 구문 분석됩니다. 파일 (또는 평가 문자열) 내에 여러 &lt;code&gt;BEGIN&lt;/code&gt; 블록 이있을 수 있습니다 . 정의 순서대로 실행됩니다. &lt;code&gt;BEGIN&lt;/code&gt; 코드 블록은 즉시 실행 되기 때문에 다른 컴파일 및 런타임에서 볼 수 있도록 다른 파일에서 서브 루틴의 정의를 가져올 수 있습니다. &lt;code&gt;BEGIN&lt;/code&gt; 이 실행 되면 즉시 정의되지 않으며 사용 된 모든 코드가 Perl의 메모리 풀로 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="3948c72682ed13a39df444bd90a131ad77b87fa0" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;File::Fetch&lt;/code&gt; object has the following accessors</source>
          <target state="translated">&lt;code&gt;File::Fetch&lt;/code&gt; 객체는 다음과 같은 접근이있다</target>
        </trans-unit>
        <trans-unit id="a0df5f12010c9e2a341950853965986995045017" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;MAYBE&lt;/code&gt; string should contain at least one combining character or the like. For example, &lt;code&gt;COMBINING ACUTE ACCENT&lt;/code&gt; has the MAYBE_NFC/MAYBE_NFKC property.</source>
          <target state="translated">&lt;code&gt;MAYBE&lt;/code&gt; 문자열 등 적어도 하나 개의 결합 문자 또는 포함되어야합니다. 예를 들어, &lt;code&gt;COMBINING ACUTE ACCENT&lt;/code&gt; 에는 MAYBE_NFC / MAYBE_NFKC 속성이 있습니다.</target>
        </trans-unit>
        <trans-unit id="d9aa930129748b8e7f36983538600e4ef3003dd2" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;NUL&lt;/code&gt; character will be written after the end of the string.</source>
          <target state="translated">&lt;code&gt;NUL&lt;/code&gt; 의 문자는 문자열의 끝 이후에 기록됩니다.</target>
        </trans-unit>
        <trans-unit id="14e49abd4463a2df704c3d0c251781f20f08e519" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;PerlIOl *&lt;/code&gt; is a pointer to the struct, and the</source>
          <target state="translated">&lt;code&gt;PerlIOl *&lt;/code&gt; 는 구조체에 대한 포인터이며,</target>
        </trans-unit>
        <trans-unit id="e73ed792e4d7284609d9e1372b30eccc321faca0" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;SelectSaver&lt;/code&gt; object contains a reference to the file handle that was selected when it was created. If its &lt;code&gt;new&lt;/code&gt; method gets an extra parameter, then that parameter is selected; otherwise, the selected file handle remains unchanged.</source>
          <target state="translated">&lt;code&gt;SelectSaver&lt;/code&gt; 의 오브젝트가 생성 될 때 선택된 파일 핸들에 대한 참조를 포함한다. &lt;code&gt;new&lt;/code&gt; 메소드에 추가 매개 변수가 있으면 해당 매개 변수가 선택됩니다. 그렇지 않으면 선택한 파일 핸들이 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8fe48706c46ddab56d87823274b5a44ca94ef7e1" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;TAP::Parser::SourceHandler&lt;/code&gt; does whatever is necessary to produce &amp;amp; capture a stream of TAP from the</source>
          <target state="translated">&lt;code&gt;TAP::Parser::SourceHandler&lt;/code&gt; 생산 및으로부터 TAP의 스트림을 캡처 할 필요가 무엇이든지하지</target>
        </trans-unit>
        <trans-unit id="0a99f3f0858c303c1b78e0bc06e71d69f8940558" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;[&lt;/code&gt; is not special inside a character class, unless it's the start of a POSIX character class (see &lt;a href=&quot;#POSIX-Character-Classes&quot;&gt;&quot;POSIX Character Classes&quot;&lt;/a&gt; below). It normally does not need escaping.</source>
          <target state="translated">A는 &lt;code&gt;[&lt;/code&gt; 그것이 POSIX 문자 클래스의 시작 않는 한 (참조, 문자 클래스 내부에 특별하지 않다 &lt;a href=&quot;#POSIX-Character-Classes&quot;&gt;&quot;POSIX 문자 클래스&quot;&lt;/a&gt; 아래 참조). 일반적으로 이스케이프가 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="57c30b7d6b5dae1d9e52bc3dfa57d215caf5d862" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;[&lt;/code&gt; is not special inside a character class, unless it's the start of a POSIX character class (see &lt;a href=&quot;#POSIX-Character-Classes&quot;&gt;POSIX Character Classes&lt;/a&gt; below). It normally does not need escaping.</source>
          <target state="translated">A는 &lt;code&gt;[&lt;/code&gt; 그것이 POSIX 문자 클래스의 시작이다 (참조하지 않는 한, 문자 클래스 내부에 특별한되지 않습니다 &lt;a href=&quot;#POSIX-Character-Classes&quot;&gt;POSIX 문자 클래스&lt;/a&gt; 아래 참조). 일반적으로 이스케이프 할 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="6776cbbe11f1658efaaee2f3dd38010bf8c93b32" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;\L&lt;/code&gt; or &lt;code&gt;\U&lt;/code&gt; indicates a lasting conversion of case, until terminated by &lt;code&gt;\E&lt;/code&gt; or thrown over by another &lt;code&gt;\U&lt;/code&gt; or &lt;code&gt;\L&lt;/code&gt; :</source>
          <target state="translated">&lt;code&gt;\L&lt;/code&gt; 또는 &lt;code&gt;\U&lt;/code&gt; 종료 될 때까지, 케이스의 지속 변환을 나타냅니다 &lt;code&gt;\E&lt;/code&gt; 또는 다른 의해 던져 &lt;code&gt;\U&lt;/code&gt; 또는 &lt;code&gt;\L&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="a24307b632bac4af20bd3048bef792d9059be490" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;\L&lt;/code&gt; or &lt;code&gt;\U&lt;/code&gt; indicates a lasting conversion of case, until terminated by &lt;code&gt;\E&lt;/code&gt; or thrown over by another &lt;code&gt;\U&lt;/code&gt; or &lt;code&gt;\L&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;\L&lt;/code&gt; 또는 &lt;code&gt;\U&lt;/code&gt; 종료 될 때까지, 케이스의 지속 변환을 나타냅니다 &lt;code&gt;\E&lt;/code&gt; 또는 다른 의해 던져 &lt;code&gt;\U&lt;/code&gt; 또는 &lt;code&gt;\L&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="eb525767ec147f71507ec3fe5c0bbfd43e23622a" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;\w&lt;/code&gt; matches a single alphanumeric character (an alphabetic character, or a decimal digit); or a connecting punctuation character, such as an underscore (&quot;_&quot;); or a &quot;mark&quot; character (like some sort of accent) that attaches to one of those. It does not match a whole word. To match a whole word, use &lt;code&gt;\w+&lt;/code&gt; . This isn't the same thing as matching an English word, but in the ASCII range it is the same as a string of Perl-identifier characters.</source>
          <target state="translated">&lt;code&gt;\w&lt;/code&gt; 일치 한 영숫자 문자 (영문자, 또는 십진수 자리); 또는 밑줄 ( &quot;_&quot;)과 같은 연결 구두점 문자; 또는 그중 하나에 부착되는 &quot;마크&quot;문자 (일부 악센트와 같은). 전체 단어와 일치하지 않습니다. 전체 단어를 일치 시키려면 &lt;code&gt;\w+&lt;/code&gt; . 이것은 영어 단어와 일치하는 것과 같지 않지만 ASCII 범위에서는 Perl-identifier 문자의 문자열과 동일합니다.</target>
        </trans-unit>
        <trans-unit id="3bd4c66560dca0578d3070157d991dfce3ac854e" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;\w&lt;/code&gt; matches a single alphanumeric character (an alphabetic character, or a decimal digit); or a connecting punctuation character, such as an underscore (&quot;_&quot;); or a &quot;mark&quot; character (like some sort of accent) that attaches to one of those. It does not match a whole word. To match a whole word, use &lt;code&gt;\w+&lt;/code&gt;. This isn't the same thing as matching an English word, but in the ASCII range it is the same as a string of Perl-identifier characters.</source>
          <target state="translated">&lt;code&gt;\w&lt;/code&gt; 일치 한 영숫자 문자 (영문자, 또는 십진수 자리); 또는 밑줄 ( &quot;_&quot;)과 같은 연결 구두점 문자; 또는 그 중 하나에 붙는 &quot;마크&quot;문자 (일종의 악센트와 같은). 전체 단어와 일치하지 않습니다. 전체 단어를 일치 시키려면 &lt;code&gt;\w+&lt;/code&gt; . 이것은 영어 단어와 일치하는 것은 아니지만 ASCII 범위에서 Perl 식별자 문자의 문자열과 동일합니다.</target>
        </trans-unit>
        <trans-unit id="46827aa6986ffad2428550f266417b4a216e73cc" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;]&lt;/code&gt; is normally either the end of a POSIX character class (see &lt;a href=&quot;#POSIX-Character-Classes&quot;&gt;&quot;POSIX Character Classes&quot;&lt;/a&gt; below), or it signals the end of the bracketed character class. If you want to include a &lt;code&gt;]&lt;/code&gt; in the set of characters, you must generally escape it.</source>
          <target state="translated">A &lt;code&gt;]&lt;/code&gt; 는 일반적으로 POSIX 문자 클래스의 끝 (아래의 &lt;a href=&quot;#POSIX-Character-Classes&quot;&gt;&quot;POSIX 문자 클래스&quot;&lt;/a&gt; 참조)이거나 대괄호 문자 클래스의 끝을 나타냅니다. 문자 집합에 &lt;code&gt;]&lt;/code&gt; 를 포함 하려면 일반적으로 이스케이프해야합니다.</target>
        </trans-unit>
        <trans-unit id="387f0590ce374c162a12f59ad2a352b45a0b6a2e" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;]&lt;/code&gt; is normally either the end of a POSIX character class (see &lt;a href=&quot;#POSIX-Character-Classes&quot;&gt;POSIX Character Classes&lt;/a&gt; below), or it signals the end of the bracketed character class. If you want to include a &lt;code&gt;]&lt;/code&gt; in the set of characters, you must generally escape it.</source>
          <target state="translated">A &lt;code&gt;]&lt;/code&gt; 는 일반적으로 POSIX 문자 클래스의 끝 (아래 &lt;a href=&quot;#POSIX-Character-Classes&quot;&gt;POSIX 문자 클래스&lt;/a&gt; 참조)이거나 대괄호 문자 클래스의 끝을 나타냅니다. 문자 세트에 &lt;code&gt;]&lt;/code&gt; 를 포함 시키려면 일반적으로 이스케이프해야합니다.</target>
        </trans-unit>
        <trans-unit id="1193d9cb8f306d664b7ff329f363fa64604ab25b" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;bgzip&lt;/code&gt; file consists of a series of valid gzip-compliant data streams concatenated together. To read a file created by &lt;code&gt;bgzip&lt;/code&gt; with &lt;code&gt;IO::Uncompress::Gunzip&lt;/code&gt; use the &lt;code&gt;MultiStream&lt;/code&gt; option as shown in the previous section.</source>
          <target state="translated">&lt;code&gt;bgzip&lt;/code&gt; 의 파일은 함께 연결된 스트림 유효 gzip으로 호환 데이터의 일련의로 구성되어 있습니다. &lt;code&gt;IO::Uncompress::Gunzip&lt;/code&gt; 사용하여 &lt;code&gt;bgzip&lt;/code&gt; 으로 만든 파일을 읽으려면 이전 섹션에 표시된대로 &lt;code&gt;MultiStream&lt;/code&gt; 옵션을 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="2a086836899301702e84e6ebfd5a64e6e1514ec1" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;clean&lt;/code&gt; command results in a</source>
          <target state="translated">&lt;code&gt;clean&lt;/code&gt; 명령은 결과</target>
        </trans-unit>
        <trans-unit id="30a979776a12ffbd2ccae1dfa8877b7ee9e2e1ac" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;fork()&lt;/code&gt; failure may result in the following tests failing:</source>
          <target state="translated">&lt;code&gt;fork()&lt;/code&gt; 실패 실패 다음 테스트 될 수있다 :</target>
        </trans-unit>
        <trans-unit id="2260ddde35cc7bc21b5b592a2612689aeec99e22" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;local&lt;/code&gt; is simply a modifier on an lvalue expression. When you assign to a &lt;code&gt;local&lt;/code&gt;ized variable, the &lt;code&gt;local&lt;/code&gt; doesn't change whether its list is viewed as a scalar or an array. So</source>
          <target state="translated">&lt;code&gt;local&lt;/code&gt; 단순히 좌변 식의 수정이다. 당신이에 할당 할 때 &lt;code&gt;local&lt;/code&gt; 화된 변수의 &lt;code&gt;local&lt;/code&gt; 그 목록들이 스칼라 나 배열로 보이는 것을 바꾸지 않는다. 그래서</target>
        </trans-unit>
        <trans-unit id="0fa451e4004dc04e11969a902e7778f3071f1b2e" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;local&lt;/code&gt; modifies its listed variables to be &quot;local&quot; to the enclosing block, &lt;code&gt;eval&lt;/code&gt;, or &lt;code&gt;do FILE&lt;/code&gt;--and to</source>
          <target state="translated">&lt;code&gt;local&lt;/code&gt; 수정은 나열된 변수 &quot;로컬&quot;이 둘러싸는 블록을 위해 &lt;code&gt;eval&lt;/code&gt; 또는 &lt;code&gt;do FILE&lt;/code&gt; 에 - 그리고</target>
        </trans-unit>
        <trans-unit id="e6d318e0e7d10811cf9d04b1c9ec7142e2b390f3" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;my&lt;/code&gt; has both a compile-time and a run-time effect. At compile time, the compiler takes notice of it. The principal usefulness of this is to quiet &lt;code&gt;use strict 'vars'&lt;/code&gt;, but it is also essential for generation of closures as detailed in &lt;a href=&quot;perlref&quot;&gt;perlref&lt;/a&gt;. Actual initialization is delayed until run time, though, so it gets executed at the appropriate time, such as each time through a loop, for example.</source>
          <target state="translated">A는 &lt;code&gt;my&lt;/code&gt; 컴파일 시간과 런타임 효과를 모두 가지고있다. 컴파일 타임에 컴파일러는이를 인식합니다. 이것의 주된 유용성은 &lt;code&gt;use strict 'vars'&lt;/code&gt; 를 조용히 사용하는 것이지만, &lt;a href=&quot;perlref&quot;&gt;perlref에&lt;/a&gt; 자세히 설명 된 것처럼 클로저 생성에도 필수적입니다 . 그러나 실제 초기화는 런타임까지 지연되므로 예를 들어 루프를 통해 매번 같은 시간에 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="f82e2956ae874578dae0b862a6205fc9ad9a10d8" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;quiet&lt;/code&gt; parameter tells &lt;code&gt;CBuilder&lt;/code&gt; to not print its &lt;code&gt;&lt;a href=&quot;../functions/system&quot;&gt;system()&lt;/a&gt;&lt;/code&gt; commands before executing them:</source>
          <target state="translated">&lt;code&gt;quiet&lt;/code&gt; 매개 변수는 알 수 &lt;code&gt;CBuilder&lt;/code&gt; 를 자사의 인쇄하지 않는 &lt;code&gt;&lt;a href=&quot;../functions/system&quot;&gt;system()&lt;/a&gt;&lt;/code&gt; 을 실행하기 전에 명령을 :</target>
        </trans-unit>
        <trans-unit id="7e6166d094ef7a8c9acbf1912950fe415bf80619" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;quiet&lt;/code&gt; parameter tells &lt;code&gt;CBuilder&lt;/code&gt; to not print its &lt;code&gt;system()&lt;/code&gt; commands before executing them:</source>
          <target state="translated">&lt;code&gt;quiet&lt;/code&gt; 매개 변수는 알 수 &lt;code&gt;CBuilder&lt;/code&gt; 를 자사의 인쇄하지 않는 &lt;code&gt;system()&lt;/code&gt; 을 실행하기 전에 명령을 :</target>
        </trans-unit>
        <trans-unit id="537fa0e7c3fc8f4f2ff13df46f07e5efa8b0d873" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;regexp_paren_pair&lt;/code&gt; structure which defines offsets into the string being matched which correspond to the &lt;code&gt;$&amp;amp;&lt;/code&gt; and &lt;code&gt;$1&lt;/code&gt; , &lt;code&gt;$2&lt;/code&gt; etc. captures, the &lt;code&gt;regexp_paren_pair&lt;/code&gt; struct is defined as follows:</source>
          <target state="translated">&lt;code&gt;$&amp;amp;&lt;/code&gt; 및 &lt;code&gt;$1&lt;/code&gt; , &lt;code&gt;$2&lt;/code&gt; 등의 캡처에 해당하는 일치하는 문자열에 오프셋을 정의 하는 &lt;code&gt;regexp_paren_pair&lt;/code&gt; 구조 , &lt;code&gt;regexp_paren_pair&lt;/code&gt; 구조체는 다음과 같이 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="88f343e9050a80a8547d07e80fa1abe57f501fdb" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;regexp_paren_pair&lt;/code&gt; structure which defines offsets into the string being matched which correspond to the &lt;code&gt;$&amp;amp;&lt;/code&gt; and &lt;code&gt;$1&lt;/code&gt;, &lt;code&gt;$2&lt;/code&gt; etc. captures, the &lt;code&gt;regexp_paren_pair&lt;/code&gt; struct is defined as follows:</source>
          <target state="translated">&lt;code&gt;$&amp;amp;&lt;/code&gt; 및 &lt;code&gt;$1&lt;/code&gt; , &lt;code&gt;$2&lt;/code&gt; 등 캡처에 해당하는 일치하는 문자열로 오프셋을 정의 하는 &lt;code&gt;regexp_paren_pair&lt;/code&gt; 구조 , &lt;code&gt;regexp_paren_pair&lt;/code&gt; 구조는 다음과 같이 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="4c85a606418ea2141ddded1f2ff2c1a9dc2e0148" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;return&lt;/code&gt; statement may be used to exit a subroutine, optionally specifying the returned value, which will be evaluated in the appropriate context (list, scalar, or void) depending on the context of the subroutine call. If you specify no return value, the subroutine returns an empty list in list context, the undefined value in scalar context, or nothing in void context. If you return one or more aggregates (arrays and hashes), these will be flattened together into one large indistinguishable list.</source>
          <target state="translated">&lt;code&gt;return&lt;/code&gt; 명령문 임의로 서브 루틴 호출의 상황에 따라 적절한 컨텍스트 (목록, 스칼라, 또는 공극)에서 평가 될 리턴 값을 지정하는 서브 루틴을 종료하기 위해 사용될 수있다. 반환 값을 지정하지 않으면 서브 루틴은 목록 컨텍스트에서 빈 목록을 반환하고 스칼라 컨텍스트에서 정의되지 않은 값을 반환하거나 void 컨텍스트에서 아무 것도 반환하지 않습니다. 하나 이상의 집계 (배열 및 해시)를 반환하는 경우 이러한 집계는 구별 할 수없는 하나의 큰 목록으로 함께 평면화됩니다.</target>
        </trans-unit>
        <trans-unit id="c401b707420030372d274c701dc85d8905c95ac7" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;select()&lt;/code&gt; wrapper that compensates for platform peculiarities.</source>
          <target state="translated">플랫폼 특성을 보완 하는 &lt;code&gt;select()&lt;/code&gt; 래퍼입니다.</target>
        </trans-unit>
        <trans-unit id="9187cecc86ed031f1a1d91cbbf85586329ad9482" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;typedef&lt;/code&gt; will be created for &lt;code&gt;struct netconfig&lt;/code&gt; . The Perl object will be blessed in a class matching the name of the C type, with the tag &lt;code&gt;Ptr&lt;/code&gt; appended, and the name should not have embedded spaces if it will be a Perl package name. The destructor will be placed in a class corresponding to the class of the object and the PREFIX keyword will be used to trim the name to the word DESTROY as Perl will expect.</source>
          <target state="translated">&lt;code&gt;typedef&lt;/code&gt; 생성됩니다 &lt;code&gt;struct netconfig&lt;/code&gt; . Perl 객체는 태그 &lt;code&gt;Ptr&lt;/code&gt; 이 추가 된 C 유형의 이름과 일치하는 클래스에서 제공 되며 Perl 패키지 이름 인 경우 이름에 공백이 없어야합니다. 소멸자는 객체의 클래스에 해당하는 클래스에 배치되고 PREFIX 키워드는 Perl이 예상하는대로 DESTROY라는 단어로 이름을 자르는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="303080e3bc4b5d987f533b7d3f189bfcd0ce0dec" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;typedef&lt;/code&gt; will be created for &lt;code&gt;struct netconfig&lt;/code&gt;. The Perl object will be blessed in a class matching the name of the C type, with the tag &lt;code&gt;Ptr&lt;/code&gt; appended, and the name should not have embedded spaces if it will be a Perl package name. The destructor will be placed in a class corresponding to the class of the object and the PREFIX keyword will be used to trim the name to the word DESTROY as Perl will expect.</source>
          <target state="translated">&lt;code&gt;typedef&lt;/code&gt; 생성됩니다 &lt;code&gt;struct netconfig&lt;/code&gt; . Perl 객체는 태그 &lt;code&gt;Ptr&lt;/code&gt; 이 추가 된 C 유형의 이름과 일치하는 클래스에서 축복을 받게되며 Perl 패키지 이름 인 경우 이름에 공백이 없어야합니다. 소멸자는 객체의 클래스에 해당하는 클래스에 배치되고 PREFIX 키워드는 Perl이 예상하는대로 DESTROY라는 단어로 이름을 자르는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="91a29e0934f06be58e8f45f6ccaf516ef19ec003" translate="yes" xml:space="preserve">
          <source>A B::HV object representing the stash for 'our' variables.</source>
          <target state="translated">'우리'변수에 대한 숨김을 나타내는 AB :: HV 객체.</target>
        </trans-unit>
        <trans-unit id="f45e12c8a06cbfbc829397737665446dbd9373fc" translate="yes" xml:space="preserve">
          <source>A B::HV object representing the stash for a typed lexical.</source>
          <target state="translated">유형화 된 어휘에 대한 숨김을 나타내는 AB :: HV 오브젝트.</target>
        </trans-unit>
        <trans-unit id="42fcd5050adf426bbdb7192c3683fb606974ed22" translate="yes" xml:space="preserve">
          <source>A BLOCK by itself (labeled or not) is semantically equivalent to a loop that executes once. Thus you can use any of the loop control statements in it to leave or restart the block. (Note that this is</source>
          <target state="translated">BLOCK 자체 (표지 여부)는 의미 적으로 한 번 실행되는 루프와 동일합니다. 따라서 루프 제어문을 사용하여 블록을 종료하거나 재시작 할 수 있습니다. (이것은</target>
        </trans-unit>
        <trans-unit id="d2fb8a4ed8386e8349fe099520462ea5055d627c" translate="yes" xml:space="preserve">
          <source>A Buffer</source>
          <target state="translated">버퍼</target>
        </trans-unit>
        <trans-unit id="0b3fa7a6472c1947a3e3fb9a265bfaa097653d2a" translate="yes" xml:space="preserve">
          <source>A Build.PL is run by perl in a separate process. Likewise we run './Build' and './Build install' in separate processes. If you have any parameters you want to pass to the calls, please specify them here.</source>
          <target state="translated">Build.PL은 별도의 프로세스에서 perl에 의해 실행됩니다. 마찬가지로 './Build'와 './Build install'을 별도의 프로세스에서 실행합니다. 통화에 전달할 매개 변수가있는 경우 여기에 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="2b8f77588c05a56fb0aa83c01416be422180616b" translate="yes" xml:space="preserve">
          <source>A C expression for the value of the constant, or a list of C expressions if the type is aggregate. This defaults to the</source>
          <target state="translated">상수 값에 대한 AC 표현식 또는 유형이 집계 인 경우 C 표현식 목록. 기본값은</target>
        </trans-unit>
        <trans-unit id="e9567baf2c716fe48fcad56160dbe55dcf6fe52e" translate="yes" xml:space="preserve">
          <source>A CASE: might switch via a parameter of the XSUB, via the &lt;code&gt;ix&lt;/code&gt; ALIAS: variable (see &lt;a href=&quot;#The-ALIAS%3A-Keyword&quot;&gt;&quot;The ALIAS: Keyword&quot;&lt;/a&gt;), or maybe via the &lt;code&gt;items&lt;/code&gt; variable (see &lt;a href=&quot;#Variable-length-Parameter-Lists&quot;&gt;&quot;Variable-length Parameter Lists&quot;&lt;/a&gt;). The last CASE: becomes the &lt;b&gt;default&lt;/b&gt; case if it is not associated with a conditional. The following example shows CASE switched via &lt;code&gt;ix&lt;/code&gt; with a function &lt;code&gt;rpcb_gettime()&lt;/code&gt; having an alias &lt;code&gt;x_gettime()&lt;/code&gt;. When the function is called as &lt;code&gt;rpcb_gettime()&lt;/code&gt; its parameters are the usual &lt;code&gt;(char *host, time_t *timep)&lt;/code&gt;, but when the function is called as &lt;code&gt;x_gettime()&lt;/code&gt; its parameters are reversed, &lt;code&gt;(time_t *timep, char *host)&lt;/code&gt;.</source>
          <target state="translated">CASE : XSUB의 매개 변수, &lt;code&gt;ix&lt;/code&gt; ALIAS : 변수 ( &lt;a href=&quot;#The-ALIAS%3A-Keyword&quot;&gt;&quot;ALIAS : 키워드&quot;&lt;/a&gt; 참조) 또는 &lt;code&gt;items&lt;/code&gt; 변수 ( &lt;a href=&quot;#Variable-length-Parameter-Lists&quot;&gt;&quot;변수 길이 매개 변수 목록&quot;&lt;/a&gt; 참조) 를 통해 전환 할 수 있습니다 . 마지막 CASE : 조건부와 연결되지 않은 경우 &lt;b&gt;기본&lt;/b&gt; 케이스가됩니다. 다음 예제는 별칭이 &lt;code&gt;x_gettime()&lt;/code&gt; &lt;code&gt;rpcb_gettime()&lt;/code&gt; 함수 를 사용하여 &lt;code&gt;ix&lt;/code&gt; 를 통해 전환 된 CASE를 보여줍니다 . 함수가 &lt;code&gt;rpcb_gettime()&lt;/code&gt; 으로 호출되면 매개 변수는 보통 &lt;code&gt;(char *host, time_t *timep)&lt;/code&gt; 이지만 함수가 &lt;code&gt;x_gettime()&lt;/code&gt; 으로 호출되면 매개 변수가 반전됩니다. &lt;code&gt;(time_t *timep, char *host)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c9bca895b6521acf14049f748fb255c795b1e71c" translate="yes" xml:space="preserve">
          <source>A CASE: might switch via a parameter of the XSUB, via the &lt;code&gt;ix&lt;/code&gt; ALIAS: variable (see &lt;a href=&quot;#The-ALIAS%3a-Keyword&quot;&gt;The ALIAS: Keyword&lt;/a&gt;), or maybe via the &lt;code&gt;items&lt;/code&gt; variable (see &lt;a href=&quot;#Variable-length-Parameter-Lists&quot;&gt;Variable-length Parameter Lists&lt;/a&gt;). The last CASE: becomes the &lt;b&gt;default&lt;/b&gt; case if it is not associated with a conditional. The following example shows CASE switched via &lt;code&gt;ix&lt;/code&gt; with a function &lt;code&gt;rpcb_gettime()&lt;/code&gt; having an alias &lt;code&gt;x_gettime()&lt;/code&gt; . When the function is called as &lt;code&gt;rpcb_gettime()&lt;/code&gt; its parameters are the usual &lt;code&gt;(char *host, time_t *timep)&lt;/code&gt; , but when the function is called as &lt;code&gt;x_gettime()&lt;/code&gt; its parameters are reversed, &lt;code&gt;(time_t *timep, char *host)&lt;/code&gt; .</source>
          <target state="translated">경우는 다음 경유하여 XSUB의 매개 변수를 통해 전환 할 수도 있습니다 &lt;code&gt;ix&lt;/code&gt; ALIAS : 변수 (참조 &lt;a href=&quot;#The-ALIAS%3a-Keyword&quot;&gt;별칭 : 키워드&lt;/a&gt; ) 또는 어쩌면 통해 &lt;code&gt;items&lt;/code&gt; 변수 (참조 &lt;a href=&quot;#Variable-length-Parameter-Lists&quot;&gt;가변 길이 매개 변수리스트&lt;/a&gt; ). 마지막 CASE : 조건과 연결되지 않은 경우 &lt;b&gt;기본&lt;/b&gt; 사례가됩니다. 다음 예는 별명이 &lt;code&gt;x_gettime()&lt;/code&gt; &lt;code&gt;rpcb_gettime()&lt;/code&gt; 함수 를 사용하여 &lt;code&gt;ix&lt;/code&gt; 를 통해 전환 된 CASE를 보여줍니다 . 함수가 &lt;code&gt;rpcb_gettime()&lt;/code&gt; 으로 호출되면 해당 매개 변수는 일반적인 &lt;code&gt;(char *host, time_t *timep)&lt;/code&gt; 이지만 함수가 &lt;code&gt;x_gettime()&lt;/code&gt; 으로 호출되면 매개 변수가 반대로 설정됩니다. &lt;code&gt;(time_t *timep, char *host)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="428a171aa5c95cac510361d11fc204293b5e9395" translate="yes" xml:space="preserve">
          <source>A CD-ROM drive.</source>
          <target state="translated">CD-ROM 드라이브.</target>
        </trans-unit>
        <trans-unit id="14cb1f44ba3d5ff6c6389f7f3c7c6da1d1bedbef" translate="yes" xml:space="preserve">
          <source>A CES that was carefully designed to coexist with ASCII. There are a 7 bit version and an 8 bit version.</source>
          <target state="translated">ASCII와 공존하도록 신중하게 설계된 CES입니다. 7 비트 버전과 8 비트 버전이 있습니다.</target>
        </trans-unit>
        <trans-unit id="c55f978db59708209a54d8bfb17d98c3ae019b46" translate="yes" xml:space="preserve">
          <source>A CPAN mirror that includes just the latest versions for each distribution, probably created with &lt;code&gt;CPAN::Mini&lt;/code&gt; . See Camel chapter 19, &amp;ldquo;CPAN&amp;rdquo;.</source>
          <target state="translated">&lt;code&gt;CPAN::Mini&lt;/code&gt; 작성된 각 분배에 대한 최신 버전 만 포함하는 CPAN 미러 . 낙타 19 장 &quot;CPAN&quot;을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="27d5797833bb46c5943f83ed90ba2705b5e06f66" translate="yes" xml:space="preserve">
          <source>A CPAN mirror that includes just the latest versions for each distribution, probably created with &lt;code&gt;CPAN::Mini&lt;/code&gt;. See Camel chapter 19, &amp;ldquo;CPAN&amp;rdquo;.</source>
          <target state="translated">&lt;code&gt;CPAN::Mini&lt;/code&gt; 생성 된 각 배포에 대한 최신 버전 만 포함하는 CPAN 미러 . Camel 19 장, &quot;CPAN&quot;을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="2a412a9c43c3b078621b984e4d63b01678d573c0" translate="yes" xml:space="preserve">
          <source>A CPAN::Meta::Feature object describes an optional feature offered by a CPAN distribution and specified in the distribution's</source>
          <target state="translated">CPAN :: Meta :: Feature 객체는 CPAN 배포에서 제공하고 배포의</target>
        </trans-unit>
        <trans-unit id="7c9014220da96470ddba467afeca088e6c77df7b" translate="yes" xml:space="preserve">
          <source>A CPAN::Meta::Prereqs object represents the prerequisites for a CPAN distribution or one of its optional features. Each set of prereqs is organized by phase and type, as described in &lt;a href=&quot;CPAN::Meta::Prereqs&quot;&gt;CPAN::Meta::Prereqs&lt;/a&gt;.</source>
          <target state="translated">CPAN :: Meta :: Prereqs 객체는 CPAN 배포 또는 선택적 기능 중 하나에 대한 전제 조건을 나타냅니다. 각 전제 조건 세트는 &lt;a href=&quot;CPAN::Meta::Prereqs&quot;&gt;CPAN :: Meta :: Prereqs에&lt;/a&gt; 설명 된대로 단계 및 유형별로 구성됩니다 .</target>
        </trans-unit>
        <trans-unit id="ee116ec6b595415c9ecd2e7f6b24967dd7bd2c41" translate="yes" xml:space="preserve">
          <source>A CPAN::Meta::Requirements object models a set of version constraints like those specified in the</source>
          <target state="translated">CPAN :: Meta :: Requirements 객체는</target>
        </trans-unit>
        <trans-unit id="d79fea87c96ec94013ff8e4540cf4e641c3aa0b8" translate="yes" xml:space="preserve">
          <source>A Class is Simply a Package</source>
          <target state="translated">클래스는 단순히 패키지입니다</target>
        </trans-unit>
        <trans-unit id="6fbb257e39c68ad3d78df4ebee2ad99fbc20665b" translate="yes" xml:space="preserve">
          <source>A Comparison between various tar implementations</source>
          <target state="translated">다양한 tar 구현 간의 비교</target>
        </trans-unit>
        <trans-unit id="59bd5b6c5b1f4d50bad57e4bae0c86bf7e63ff03" translate="yes" xml:space="preserve">
          <source>A Complete Example</source>
          <target state="translated">완전한 예</target>
        </trans-unit>
        <trans-unit id="9f22eaf2aa717bb5924e306e9ab40bd24eefc92a" translate="yes" xml:space="preserve">
          <source>A DBM Filter allows the keys and/or values in a tied hash to be modified by some user-defined code just before it is written to the DBM file and just after it is read back from the DBM file. For example, this snippet of code</source>
          <target state="translated">DBM 필터를 사용하면 DBM 파일에 쓰여지기 직전 및 DBM 파일에서 다시 읽은 직후에 일부 사용자 정의 코드로 묶인 해시의 키 및 / 또는 값을 수정할 수 있습니다. 예를 들어이 코드 스 니펫</target>
        </trans-unit>
        <trans-unit id="a3dd10dc1183e2df3ed7ea791b7d9b7560ba9d95" translate="yes" xml:space="preserve">
          <source>A DBM Filter is a piece of code that is be used when you</source>
          <target state="translated">DBM 필터는 사용자가 사용할 때 사용되는 코드입니다</target>
        </trans-unit>
        <trans-unit id="5fea2d2439b0d67404b2ac6ae1e3bd78930fdef9" translate="yes" xml:space="preserve">
          <source>A Filehandle</source>
          <target state="translated">파일 핸들</target>
        </trans-unit>
        <trans-unit id="e7c2104df6e4f42e9c4248a2a9dcd9a50f8cd70b" translate="yes" xml:space="preserve">
          <source>A Filename</source>
          <target state="translated">파일 이름</target>
        </trans-unit>
        <trans-unit id="74127e4dc0844d9e1d0d37669c77b5e1d7d7dc1c" translate="yes" xml:space="preserve">
          <source>A GV is a structure which corresponds to to a Perl typeglob, ie *foo. It is a structure that holds a pointer to a scalar, an array, a hash etc, corresponding to $foo, @foo, %foo.</source>
          <target state="translated">GV는 Perl typeglob, 즉 * foo에 해당하는 구조입니다. $ foo, @foo, % foo에 해당하는 스칼라, 배열, 해시 등에 대한 포인터를 보유하는 구조입니다.</target>
        </trans-unit>
        <trans-unit id="13db893228041bbd750755e5ceeab1edf73eb3b3" translate="yes" xml:space="preserve">
          <source>A Graeco-Roman word meaning &amp;ldquo;to bring oneself to life&amp;rdquo;. In Perl, storage locations (&lt;b&gt;lvalues&lt;/b&gt;) spontaneously generate themselves as needed, including the creation of any &lt;b&gt;hard reference&lt;/b&gt; values to point to the next level of storage. The assignment &lt;code&gt;$a[5][5][5][5][5] = &quot;quintet&quot;&lt;/code&gt; potentially creates five scalar storage locations, plus four references (in the first four scalar locations) pointing to four new anonymous arrays (to hold the last four scalar locations). But the point of autovivification is that you don&amp;rsquo;t have to worry about it.</source>
          <target state="translated">&amp;ldquo;자신에게 생명을 불어 넣다&amp;rdquo;를 의미하는 Graeco- 로마 단어. Perl에서 스토리지 위치 ( &lt;b&gt;lvalue&lt;/b&gt; ) 는 다음 레벨의 스토리지를 가리키는 &lt;b&gt;하드 참조&lt;/b&gt; 값 작성을 포함하여 필요에 따라 자발적으로 생성됩니다 . 대입 &lt;code&gt;$a[5][5][5][5][5] = &quot;quintet&quot;&lt;/code&gt; 잠재적으로 5 개의 스칼라 저장 위치와 4 개의 새로운 익명 배열을 가리키는 4 개의 참조 (처음 4 개의 스칼라 위치)를 생성합니다. 마지막 네 스칼라 위치). 그러나 자동 생존의 요점은 걱정할 필요가 없다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="644fba68887f0f6c83a3c9ad6b03efeafe64485f" translate="yes" xml:space="preserve">
          <source>A HV structure represents a Perl hash. It consists mainly of an array of pointers, each of which points to a linked list of HE structures. The array is indexed by the hash function of the key, so each linked list represents all the hash entries with the same hash value. Each HE contains a pointer to the actual value, plus a pointer to a HEK structure which holds the key and hash value.</source>
          <target state="translated">HV 구조는 Perl 해시를 나타냅니다. 주로 포인터 배열로 구성되며 각 포인터는 HE 구조의 연결된 목록을 가리 킵니다. 배열은 키의 해시 함수에 의해 색인화되므로 링크 된 각 목록은 동일한 해시 값을 가진 모든 해시 항목을 나타냅니다. 각 HE는 실제 값에 대한 포인터와 키 및 해시 값을 보유하는 HEK 구조에 대한 포인터를 포함합니다.</target>
        </trans-unit>
        <trans-unit id="bee561e494291ea6e45d02ab405b622a25e73320" translate="yes" xml:space="preserve">
          <source>A JSON array becomes a reference to an array in Perl.</source>
          <target state="translated">JSON 배열은 Perl에서 배열에 대한 참조가됩니다.</target>
        </trans-unit>
        <trans-unit id="46b24830f56f4ce8a9945d4c6990fbf400347674" translate="yes" xml:space="preserve">
          <source>A JSON null atom becomes &lt;code&gt;undef&lt;/code&gt; in Perl.</source>
          <target state="translated">JSON null 원자는 &lt;code&gt;undef&lt;/code&gt; 에서 undef 가됩니다 .</target>
        </trans-unit>
        <trans-unit id="67ff79ae5f44199fcff8b98322b150333800977d" translate="yes" xml:space="preserve">
          <source>A JSON number becomes either an integer, numeric (floating point) or string scalar in perl, depending on its range and any fractional parts. On the Perl level, there is no difference between those as Perl handles all the conversion details, but an integer may take slightly less memory and might represent more values exactly than floating point numbers.</source>
          <target state="translated">JSON 숫자는 범위와 분수 부분에 따라 perl에서 정수, 숫자 (부동 소수점) 또는 string 형 스칼라가됩니다. Perl 수준에서는 Perl이 모든 변환 세부 정보를 처리하므로 차이가 없지만 정수는 메모리를 약간 덜 차지하고 부동 소수점 숫자보다 더 많은 값을 정확하게 나타낼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="84d89eab13bda50b0d87fbbc9b957fca297e5455" translate="yes" xml:space="preserve">
          <source>A JSON object becomes a reference to a hash in Perl. No ordering of object keys is preserved (JSON does not preserve object key ordering itself).</source>
          <target state="translated">JSON 객체는 Perl에서 해시에 대한 참조가됩니다. 객체 키의 순서는 보존되지 않습니다 (JSON은 객체 키 순서 자체를 보존하지 않습니다).</target>
        </trans-unit>
        <trans-unit id="87d71ce97eec8dd4e08afea15be12b4484ab4838" translate="yes" xml:space="preserve">
          <source>A JSON string becomes a string scalar in Perl - Unicode codepoints in JSON are represented by the same codepoints in the Perl string, so no manual decoding is necessary.</source>
          <target state="translated">JSON 문자열은 Perl에서 문자열 스칼라가됩니다. JSON의 유니 코드 코드 포인트는 Perl 문자열에서 동일한 코드 포인트로 표시되므로 수동 디코딩이 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ec06e557b7618ed05ba8c87c2bab1b53c6df4c84" translate="yes" xml:space="preserve">
          <source>A List of</source>
          <target state="translated">목록</target>
        </trans-unit>
        <trans-unit id="d0ae4d993cdecbfc0080ff736e7e6c054fcca9fe" translate="yes" xml:space="preserve">
          <source>A List of keywords that describe this distribution. Keywords &lt;b&gt;must not&lt;/b&gt; include whitespace.</source>
          <target state="translated">이 분포를 설명하는 키워드 목록입니다. 키워드 &lt;b&gt;는 안&lt;/b&gt; 공백을 포함한다.</target>
        </trans-unit>
        <trans-unit id="85434ba02f21ca07aa9cc6c2aef0afe50dbbf404" translate="yes" xml:space="preserve">
          <source>A Localization Horror Story: It Could Happen To You</source>
          <target state="translated">현지화 공포 이야기 : 당신에게 일어날 수있는 일</target>
        </trans-unit>
        <trans-unit id="01232ff6c4ca9ea380827b743047b1207b0966c9" translate="yes" xml:space="preserve">
          <source>A Method is Simply a Subroutine</source>
          <target state="translated">방법은 단순히 서브 루틴입니다</target>
        </trans-unit>
        <trans-unit id="4fc1e89e0ebaf9800ac39a369b83b7a80fc77ec4" translate="yes" xml:space="preserve">
          <source>A Note about the Examples</source>
          <target state="translated">실시 예에 관한 주</target>
        </trans-unit>
        <trans-unit id="0d72d9979807c702328842043bb2529c640d1c5d" translate="yes" xml:space="preserve">
          <source>A Notify parameter of 'DELAY' &quot;indicates the sender's willingness to receive delayed DSNs. Delayed DSNs may be issued if delivery of a message has been delayed for an unusual amount of time (as determined by the Message Transfer Agent (MTA) at which the message is delayed), but the final delivery status (whether successful or failure) cannot be determined. The absence of the DELAY keyword in a NOTIFY parameter requests that a &quot;delayed&quot; DSN NOT be issued under any conditions.&quot;</source>
          <target state="translated">'DELAY'의 알림 매개 변수는 &quot;발송인이 지연된 DSN을 수신 할 의사가 있음을 나타냅니다. 지연된 DSN은 메시지 배달이 비정상적인 시간 동안 지연된 경우 (메시지 전송 에이전트 (MTA)에 의해 결정됨) 메시지가 지연되지만 최종 배송 상태 (성공 또는 실패 여부)를 확인할 수 없습니다. NOTIFY 매개 변수에 DELAY 키워드가 없으면 &quot;지연된&quot;DSN이 어떤 조건에서도 발행되지 않도록 요청합니다. &quot;</target>
        </trans-unit>
        <trans-unit id="9dbcef065eab9753a6c0d2e89dd406c9f007951b" translate="yes" xml:space="preserve">
          <source>A Notify parameter of 'SUCCESS' or 'FAILURE' &quot;requests that a DSN be issued on successful delivery or delivery failure, respectively.&quot;</source>
          <target state="translated">'SUCCESS'또는 'FAILURE'의 알림 매개 변수는 &quot;성공적인 배달 또는 배달 실패시 각각 DSN을 발행하도록 요청합니다.&quot;</target>
        </trans-unit>
        <trans-unit id="7d978821811172b896c82b24fc810ad3863e3b13" translate="yes" xml:space="preserve">
          <source>A PID of &lt;code&gt;0&lt;/code&gt; indicates to wait for any child process whose process group ID is equal to that of the current process. A PID of less than &lt;code&gt;-1&lt;/code&gt; indicates to wait for any child process whose process group ID is equal to -PID. A PID of &lt;code&gt;-1&lt;/code&gt; indicates to wait for any child process.</source>
          <target state="translated">PID &lt;code&gt;0&lt;/code&gt; 은 프로세스 그룹 ID가 현재 프로세스의 ID와 동일한 하위 프로세스를 대기 함을 나타냅니다. &lt;code&gt;-1&lt;/code&gt; 미만의 PID는 프로세스 그룹 ID가 -PID와 같은 하위 프로세스를 대기 함을 나타냅니다. &lt;code&gt;-1&lt;/code&gt; 의 PID는 자식 프로세스를 기다림을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="c3f40c0f83e1e526b0b0b6c66a8b36e802555138" translate="yes" xml:space="preserve">
          <source>A Perl extension to the POSIX character class is the ability to negate it. This is done by prefixing the class name with a caret (&lt;code&gt;^&lt;/code&gt;). Some examples:</source>
          <target state="translated">POSIX 문자 클래스에 대한 Perl 확장은이를 무효화하는 기능입니다. 이것은 클래스 이름 앞에 캐럿 ( &lt;code&gt;^&lt;/code&gt; ) 을 붙여서 수행됩니다 . 몇 가지 예 :</target>
        </trans-unit>
        <trans-unit id="0d2d7129fe49ff692643bf989abc3c8db9550c7a" translate="yes" xml:space="preserve">
          <source>A Perl floating point number. Similar to T_IV and T_UV in that the return type is cast to the requested numeric type rather than to a specific type.</source>
          <target state="translated">Perl 부동 소수점 숫자 리턴 유형이 특정 유형이 아닌 요청 된 숫자 유형으로 캐스트된다는 점에서 T_IV 및 T_UV와 유사합니다.</target>
        </trans-unit>
        <trans-unit id="baf019a8a8ab4371dcf7bafbfc9ccbe01c8c24c2" translate="yes" xml:space="preserve">
          <source>A Perl module that also pulls in &lt;b&gt;compiled&lt;/b&gt; C or C++ code. More generally, any experimental option that can be &lt;b&gt;compiled&lt;/b&gt; into Perl, such as multithreading.</source>
          <target state="translated">&lt;b&gt;컴파일 된&lt;/b&gt; C 또는 C ++ 코드를 가져 오는 Perl 모듈 . 보다 일반적 으로 멀티 스레딩과 같이 Perl 로 &lt;b&gt;컴파일&lt;/b&gt; 할 수있는 모든 실험 옵션 .</target>
        </trans-unit>
        <trans-unit id="d50862820d3a8aab33b93133b7d33cb935834ef5" translate="yes" xml:space="preserve">
          <source>A Perl pattern that allows the disambiguation of long and short prefixes. Default is &lt;code&gt;--&lt;/code&gt; .</source>
          <target state="translated">길고 짧은 접두사를 명확하게하는 Perl 패턴. 기본값은 &lt;code&gt;--&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="0493d06ff5354c921727ebe3abf0dda51d197688" translate="yes" xml:space="preserve">
          <source>A Perl pattern that allows the disambiguation of long and short prefixes. Default is &lt;code&gt;--&lt;/code&gt;.</source>
          <target state="translated">길고 짧은 접두사의 명확성을 허용하는 Perl 패턴. 기본값은 &lt;code&gt;--&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="2e904ead9b94d6204fd6b39a939871c992e738f5" translate="yes" xml:space="preserve">
          <source>A Perl pattern that identifies the strings that introduce options. Default is &lt;code&gt;--|-|\+&lt;/code&gt; unless environment variable POSIXLY_CORRECT has been set, in which case it is &lt;code&gt;--|-&lt;/code&gt;.</source>
          <target state="translated">옵션을 소개하는 문자열을 식별하는 Perl 패턴. 환경 변수 POSIXLY_CORRECT가 설정되지 않은 경우 기본값은 &lt;code&gt;--|-|\+&lt;/code&gt; 이며,이 경우 &lt;code&gt;--|-&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="45c72c917209e7e654e9e53f35f4bca27fd858cf" translate="yes" xml:space="preserve">
          <source>A Perl program consists of a sequence of declarations and statements which run from the top to the bottom. Loops, subroutines, and other control structures allow you to jump around within the code.</source>
          <target state="translated">Perl 프로그램은 위에서 아래로 실행되는 일련의 선언 및 명령문으로 구성됩니다. 루프, 서브 루틴 및 기타 제어 구조를 사용하면 코드 내에서 이동할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8f1d991ccec8e09953b3e8579dace5ef70ea0563" translate="yes" xml:space="preserve">
          <source>A Perl program executes only once, not once for each input line. You can do an implicit loop with &lt;code&gt;-n&lt;/code&gt; or &lt;code&gt;-p&lt;/code&gt; .</source>
          <target state="translated">Perl 프로그램은 각 입력 라인에 대해 한 번이 아니라 한 번만 실행됩니다. &lt;code&gt;-n&lt;/code&gt; 또는 &lt;code&gt;-p&lt;/code&gt; 로 내재 된 루프를 수행 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="719dc6b149ed9df2e9b30d38b9f401996838ec54" translate="yes" xml:space="preserve">
          <source>A Perl program executes only once, not once for each input line. You can do an implicit loop with &lt;code&gt;-n&lt;/code&gt; or &lt;code&gt;-p&lt;/code&gt;.</source>
          <target state="translated">Perl 프로그램은 각 입력 행에 대해 한 번이 아니라 한 번만 실행됩니다. &lt;code&gt;-n&lt;/code&gt; 또는 &lt;code&gt;-p&lt;/code&gt; 를 사용하여 암시 적 루프를 수행 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b05351cbee8badd4677882f72f83a69a3c04e972" translate="yes" xml:space="preserve">
          <source>A Perl program to do these tasks takes the basic form of opening a file, printing its lines, then closing the file:</source>
          <target state="translated">이러한 작업을 수행하는 Perl 프로그램은 파일을 열고, 행을 인쇄 한 다음 파일을 닫는 기본 형식을 취합니다.</target>
        </trans-unit>
        <trans-unit id="9f85dbe5a418fb4bcdecb47b2f0b2cac2a377668" translate="yes" xml:space="preserve">
          <source>A Perl script or program consists of one or more statements. These statements are simply written in the script in a straightforward fashion. There is no need to have a &lt;code&gt;main()&lt;/code&gt; function or anything of that kind.</source>
          <target state="translated">Perl 스크립트 또는 프로그램은 하나 이상의 명령문으로 구성됩니다. 이 진술은 간단하게 대본으로 간단하게 작성됩니다. &lt;code&gt;main()&lt;/code&gt; 함수 나 그와 같은 것을 가질 필요는 없습니다 .</target>
        </trans-unit>
        <trans-unit id="ab689318c03ebde720ae51176a11effea3a569dc" translate="yes" xml:space="preserve">
          <source>A Perl user group, taking the form of its name from the New York Perl mongers, the first Perl user group. Find one near you at &lt;a href=&quot;http://www.pm.org&quot;&gt;http://www.pm.org&lt;/a&gt;.</source>
          <target state="translated">첫 번째 Perl 사용자 그룹 인 New York Perl mongers에서 이름 형식을 사용하는 Perl 사용자 그룹. &lt;a href=&quot;http://www.pm.org&quot;&gt;http://www.pm.org&lt;/a&gt; 에서 가까운 곳을 찾으십시오 .</target>
        </trans-unit>
        <trans-unit id="eefc3e21c06e6017f8c10a8bb69ea540ab281b02" translate="yes" xml:space="preserve">
          <source>A Pod formatter may also note, in a comment or warning, a list of what unrenderable characters were encountered.</source>
          <target state="translated">포드 포맷터는 코멘트 나 경고에서 어떤 렌더링 할 수없는 문자의 목록을 기록 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="90bcd0d55b890352044335ec7ff338d09cd4b9d1" translate="yes" xml:space="preserve">
          <source>A Pod processor may signal that the above (specifically the &quot;=head1&quot; paragraph) is an error. Note, however, that the following should</source>
          <target state="translated">포드 프로세서는 상기 (특히 &quot;= head1&quot;단락)가 에러임을 신호 할 수있다. 그러나 다음 사항에 유의하십시오.</target>
        </trans-unit>
        <trans-unit id="185a19a7a82d49a0358676fb031bca8138fc5f0d" translate="yes" xml:space="preserve">
          <source>A Rename script</source>
          <target state="translated">이름 바꾸기 스크립트</target>
        </trans-unit>
        <trans-unit id="bb0e1d56b4fab0cf7a60aa29b48524e0458e7730" translate="yes" xml:space="preserve">
          <source>A Simple Client</source>
          <target state="translated">간단한 고객</target>
        </trans-unit>
        <trans-unit id="b671ac0d028246c423146116e7e15964cde16b69" translate="yes" xml:space="preserve">
          <source>A Simple Example</source>
          <target state="translated">간단한 예</target>
        </trans-unit>
        <trans-unit id="35d2688dd60f4771865d489a975386b1e2e85efc" translate="yes" xml:space="preserve">
          <source>A Social Contract about Artistic Control</source>
          <target state="translated">예술적 통제에 관한 사회 계약</target>
        </trans-unit>
        <trans-unit id="ce9f49f53bf8557e68c16a6cb0cab50ed319c852" translate="yes" xml:space="preserve">
          <source>A Solution</source>
          <target state="translated">해결책</target>
        </trans-unit>
        <trans-unit id="33b832366f848ffdd1c9a8efe9f8d3f20e39c539" translate="yes" xml:space="preserve">
          <source>A TAP</source>
          <target state="translated">손가락으로하는 가벼운 터치</target>
        </trans-unit>
        <trans-unit id="f5889f236a4188d2629daf331b9d72acfd600c43" translate="yes" xml:space="preserve">
          <source>A TAP parser consumes input from a single</source>
          <target state="translated">TAP 파서는 하나의 입력을 소비합니다.</target>
        </trans-unit>
        <trans-unit id="ebf6d3df00e862a08b0d79e0b9d4a2527d73a290" translate="yes" xml:space="preserve">
          <source>A TAP parser creates &lt;a href=&quot;TAP::Parser::Result&quot;&gt;TAP::Parser::Result&lt;/a&gt;s as it iterates through the input</source>
          <target state="translated">TAP 파서 는 입력을 반복 할 때 &lt;a href=&quot;TAP::Parser::Result&quot;&gt;TAP :: Parser :: Result를&lt;/a&gt; 생성 합니다.</target>
        </trans-unit>
        <trans-unit id="7010880f6ae20816985e9d146f66cebdc5b3456f" translate="yes" xml:space="preserve">
          <source>A TAP parser creates &lt;a href=&quot;parser/result&quot;&gt;TAP::Parser::Result&lt;/a&gt;s as it iterates through the input</source>
          <target state="translated">TAP 파서 는 입력을 반복 할 때 &lt;a href=&quot;parser/result&quot;&gt;TAP :: Parser :: Result를&lt;/a&gt; 생성 합니다.</target>
        </trans-unit>
        <trans-unit id="cbc0d3fb42afd0ba8dd15a85a63c440071f45982" translate="yes" xml:space="preserve">
          <source>A TAP parser uses</source>
          <target state="translated">TAP 파서는</target>
        </trans-unit>
        <trans-unit id="c7adba530805a495085a55a74870dea40f6e16bc" translate="yes" xml:space="preserve">
          <source>A TAP source &amp;amp; meta data about it</source>
          <target state="translated">TAP 소스 및 메타 데이터</target>
        </trans-unit>
        <trans-unit id="92ce2bc3533d042b851a960d43bdd7c40fb70ee1" translate="yes" xml:space="preserve">
          <source>A TERM has the highest precedence in Perl. They include variables, quote and quote-like operators, any expression in parentheses, and any function whose arguments are parenthesized. Actually, there aren't really functions in this sense, just list operators and unary operators behaving as functions because you put parentheses around the arguments. These are all documented in &lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt;.</source>
          <target state="translated">TERM은 Perl에서 가장 우선 순위가 높습니다. 여기에는 변수, 따옴표 및 따옴표와 같은 연산자, 괄호 안의 표현식 및 인수가 괄호로 묶인 함수가 포함됩니다. 실제로, 이러한 의미에서 실제로 함수가있는 것은 아닙니다. 인수 주위에 괄호를두기 때문에 함수로 동작하는 연산자와 단항 연산자 만 나열하면됩니다. 이것들은 모두 &lt;a href=&quot;perlfunc&quot;&gt;perlfunc에&lt;/a&gt; 문서화되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="7b1a6a3b8076da1517275a693db5de38381afda3" translate="yes" xml:space="preserve">
          <source>A TRUE return means that at least one code point represented by the sequence either is a wide character not representable as a single byte, or the representation differs depending on whether the sequence is encoded in UTF-8 or not.</source>
          <target state="translated">TRUE 반환은 시퀀스가 ​​나타내는 하나 이상의 코드 포인트가 단일 바이트로 표현할 수없는 와이드 문자이거나 시퀀스가 ​​UTF-8로 인코딩되었는지 여부에 따라 표현이 다르다는 것을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="83c2c3a67955f622ae2a621c93e51552fb8bf822" translate="yes" xml:space="preserve">
          <source>A Thread Pitfall: Deadlocks</source>
          <target state="translated">스레드 함정 : 교착 상태</target>
        </trans-unit>
        <trans-unit id="54dda450dbc946f563a52bcd0e2371c672a57c0d" translate="yes" xml:space="preserve">
          <source>A UCM file looks like this.</source>
          <target state="translated">UCM 파일은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="43f36bb558eea29df73dc728bcd3a54abd7ec2ae" translate="yes" xml:space="preserve">
          <source>A UTF in 16-bit encoding. Can either be in big endian or little endian. The big endian version is called UTF-16BE (equal to UCS-2 + surrogate support) and the little endian version is called UTF-16LE.</source>
          <target state="translated">16 비트 인코딩의 UTF. 빅 엔디안 또는 리틀 엔디안 일 수 있습니다. 빅 엔디안 버전은 UTF-16BE (UCS-2 + 대리 지원과 동일)라고하며 리틀 엔디안 버전은 UTF-16LE라고합니다.</target>
        </trans-unit>
        <trans-unit id="311a8f73aa0632dde20a979ee931fae45488ea90" translate="yes" xml:space="preserve">
          <source>A Unicode</source>
          <target state="translated">유니 코드</target>
        </trans-unit>
        <trans-unit id="636617240302996a8f020159cb2e15c959a81dd5" translate="yes" xml:space="preserve">
          <source>A Unicode boundary (&lt;code&gt;\b{}&lt;/code&gt; ), available starting in v5.22, is a spot between two characters, or before the first character in the string, or after the final character in the string where certain criteria defined by Unicode are met. See &lt;a href=&quot;perlrebackslash#%5cb%7b%7d%2c-%5cb%2c-%5cB%7b%7d%2c-%5cB&quot;&gt;\b{}, \b, \B{}, \B in perlrebackslash&lt;/a&gt; for details.</source>
          <target state="translated">v5.22부터 사용 가능한 유니 코드 경계 ( &lt;code&gt;\b{}&lt;/code&gt; )는 두 문자 사이 또는 문자열의 첫 문자 앞 또는 문자열의 마지막 문자 뒤에 유니 코드로 정의 된 특정 기준이 충족되는 지점입니다. 자세한 내용 &lt;a href=&quot;perlrebackslash#%5cb%7b%7d%2c-%5cb%2c-%5cB%7b%7d%2c-%5cB&quot;&gt;은 perlrebackslash에서 \ b {}, \ b, \ B {}, \ B&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="76eb73f0015e13b24af055123c49d9a38b6acaf0" translate="yes" xml:space="preserve">
          <source>A Unicode boundary (&lt;code&gt;\b{}&lt;/code&gt;), available starting in v5.22, is a spot between two characters, or before the first character in the string, or after the final character in the string where certain criteria defined by Unicode are met. See &lt;a href=&quot;perlrebackslash#%5Cb%7B%7D%2C-%5Cb%2C-%5CB%7B%7D%2C-%5CB&quot;&gt;&quot;\b{}, \b, \B{}, \B&quot; in perlrebackslash&lt;/a&gt; for details.</source>
          <target state="translated">v5.22부터 사용할 수 있는 유니 코드 경계 ( &lt;code&gt;\b{}&lt;/code&gt; )는 두 문자 사이, 문자열의 첫 번째 문자 앞 또는 유니 코드로 정의 된 특정 기준이 충족되는 문자열의 마지막 문자 뒤입니다. 자세한 내용 &lt;a href=&quot;perlrebackslash#%5Cb%7B%7D%2C-%5Cb%2C-%5CB%7B%7D%2C-%5CB&quot;&gt;은 perlrebackslash의 &quot;\ b {}, \ b, \ B {}, \ B&quot;&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="fd6ccb5c3173a4892e5e2944faba0f70f7b55ac3" translate="yes" xml:space="preserve">
          <source>A Unicode linebreak matches the two-character CRLF grapheme or any of seven vertical whitespace characters. Good for dealing with textfiles coming from different operating systems.</source>
          <target state="translated">유니 코드 줄 바꿈은 2 문자 CRLF 그래프 또는 7 개의 수직 공백 문자와 일치합니다. 다른 운영 체제에서 오는 텍스트 파일을 처리하는 데 좋습니다.</target>
        </trans-unit>
        <trans-unit id="d796a3e99a29b5e8798e5ee8787d53dec284ccde" translate="yes" xml:space="preserve">
          <source>A Webget Client</source>
          <target state="translated">웹겟 클라이언트</target>
        </trans-unit>
        <trans-unit id="50dd095330e040b6a4649d187065a771e5fe7217" translate="yes" xml:space="preserve">
          <source>A YAML &lt;a href=&quot;http://yaml.org/spec/history/2002-10-31.html#syntax-mapping&quot;&gt;mapping&lt;/a&gt; indicating the Perl modules required for building and/or testing of this distribution. These dependencies are not required after the module is installed.</source>
          <target state="translated">이 배포판의 빌드 및 / 또는 테스트에 필요한 Perl 모듈을 나타내는 YAML &lt;a href=&quot;http://yaml.org/spec/history/2002-10-31.html#syntax-mapping&quot;&gt;매핑&lt;/a&gt; 입니다. 모듈이 설치된 후에는 이러한 종속성이 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="155290232ccec43841ef670c256ec20f15263b43" translate="yes" xml:space="preserve">
          <source>A YAML &lt;a href=&quot;http://yaml.org/spec/history/2002-10-31.html#syntax-mapping&quot;&gt;mapping&lt;/a&gt; indicating the Perl modules that cannot be installed while this distribution is installed. This is a pretty uncommon situation.</source>
          <target state="translated">이 배포판이 설치되는 동안 설치할 수없는 Perl 모듈을 나타내는 YAML &lt;a href=&quot;http://yaml.org/spec/history/2002-10-31.html#syntax-mapping&quot;&gt;매핑&lt;/a&gt; 입니다. 이것은 매우 드문 상황입니다.</target>
        </trans-unit>
        <trans-unit id="a23933c4c7f89ad6b6468098ec568e0891d00fbb" translate="yes" xml:space="preserve">
          <source>A YAML &lt;a href=&quot;http://yaml.org/spec/history/2002-10-31.html#syntax-mapping&quot;&gt;mapping&lt;/a&gt; indicating the Perl modules this distribution recommends for enhanced operation.</source>
          <target state="translated">이 배포가 향상된 작업을 위해 권장하는 Perl 모듈을 나타내는 YAML &lt;a href=&quot;http://yaml.org/spec/history/2002-10-31.html#syntax-mapping&quot;&gt;매핑&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="7dcc493f623faaa5166c4233037cd1025c6b0ae1" translate="yes" xml:space="preserve">
          <source>A YAML &lt;a href=&quot;http://yaml.org/spec/history/2002-10-31.html#syntax-mapping&quot;&gt;mapping&lt;/a&gt; indicating the Perl modules this distribution requires for proper operation. The keys are the module names, and the values are version specifications as described in the &lt;a href=&quot;Module::Build::API#requires&quot;&gt;documentation for Module::Build's &quot;requires&quot; parameter&lt;/a&gt;.</source>
          <target state="translated">이 배포판이 적절한 작동을 위해 필요한 Perl 모듈을 나타내는 YAML &lt;a href=&quot;http://yaml.org/spec/history/2002-10-31.html#syntax-mapping&quot;&gt;매핑&lt;/a&gt; 입니다. 키는 모듈 이름이고 값은 &lt;a href=&quot;Module::Build::API#requires&quot;&gt;Module :: Build의 &quot;requires&quot;매개 변수 문서에&lt;/a&gt; 설명 된 버전 사양 입니다.</target>
        </trans-unit>
        <trans-unit id="625ef9e7e1c1fa35b033333425cc32cf0c3ed6bf" translate="yes" xml:space="preserve">
          <source>A backslash sequence is a sequence of characters, the first one of which is a backslash. Perl ascribes special meaning to many such sequences, and some of these are character classes. That is, they match a single character each, provided that the character belongs to the specific set of characters defined by the sequence.</source>
          <target state="translated">백 슬래시 시퀀스는 문자 시퀀스이며, 첫 번째는 백 슬래시입니다. Perl은 이러한 많은 시퀀스에 특별한 의미를 부여하며 그 중 일부는 문자 클래스입니다. 즉, 문자가 시퀀스에 의해 정의 된 특정 문자 세트에 속하는 경우 각각 단일 문자와 일치합니다.</target>
        </trans-unit>
        <trans-unit id="0a7351fee5999f66ec79553b15a43f5d86c41d6e" translate="yes" xml:space="preserve">
          <source>A backward-compatibility alias for TYPE.</source>
          <target state="translated">TYPE의 하위 호환성 별칭</target>
        </trans-unit>
        <trans-unit id="f7fb814e1c2c79d0e734419e57ea9495c267d50e" translate="yes" xml:space="preserve">
          <source>A backward-compatible version of &lt;code&gt;GIMME_V&lt;/code&gt; which can only return &lt;code&gt;G_SCALAR&lt;/code&gt; or &lt;code&gt;G_ARRAY&lt;/code&gt; ; in a void context, it returns &lt;code&gt;G_SCALAR&lt;/code&gt; . Deprecated. Use &lt;code&gt;GIMME_V&lt;/code&gt; instead.</source>
          <target state="translated">&lt;code&gt;G_SCALAR&lt;/code&gt; 또는 &lt;code&gt;G_ARRAY&lt;/code&gt; 만 반환 할 수 있는 이전 버전과 호환되는 &lt;code&gt;GIMME_V&lt;/code&gt; 버전 ; 빈 공간에서는 &lt;code&gt;G_SCALAR&lt;/code&gt; 를 반환합니다 . 더 이상 사용되지 않습니다. 대신 &lt;code&gt;GIMME_V&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="ea63daaa7584ad162122c04feefcccd273238637" translate="yes" xml:space="preserve">
          <source>A backward-compatible version of &lt;code&gt;GIMME_V&lt;/code&gt; which can only return &lt;code&gt;G_SCALAR&lt;/code&gt; or &lt;code&gt;G_ARRAY&lt;/code&gt;; in a void context, it returns &lt;code&gt;G_SCALAR&lt;/code&gt;. Deprecated. Use &lt;code&gt;GIMME_V&lt;/code&gt; instead.</source>
          <target state="translated">&lt;code&gt;G_SCALAR&lt;/code&gt; 또는 &lt;code&gt;G_ARRAY&lt;/code&gt; 만 반환 할 수 있는 &lt;code&gt;GIMME_V&lt;/code&gt; 의 이전 버전과 호환되는 버전입니다 . void 컨텍스트에서는 &lt;code&gt;G_SCALAR&lt;/code&gt; 를 반환합니다 . 더 이상 사용되지 않습니다. 대신 &lt;code&gt;GIMME_V&lt;/code&gt; 를 사용 하세요 .</target>
        </trans-unit>
        <trans-unit id="825d3b4cdbdd793ff6bcae81fea3eedc9476aefd" translate="yes" xml:space="preserve">
          <source>A bare declaration like that declares the function to be a list operator, not a unary operator, so you have to be careful to use parentheses (or &lt;code&gt;or&lt;/code&gt; instead of &lt;code&gt;||&lt;/code&gt;.) The &lt;code&gt;||&lt;/code&gt; operator binds too tightly to use after list operators; it becomes part of the last element. You can always use parentheses around the list operators arguments to turn the list operator back into something that behaves more like a function call. Alternatively, you can use the prototype &lt;code&gt;($)&lt;/code&gt; to turn the subroutine into a unary operator:</source>
          <target state="translated">당신이 (또는 괄호를 사용에주의해야하므로 그와 같은 베어 선언은리스트 연산자가 아니라 단항 연산자로 함수를 선언 &lt;code&gt;or&lt;/code&gt; 대신 &lt;code&gt;||&lt;/code&gt; 하십시오.) &lt;code&gt;||&lt;/code&gt; 연산자가 목록 연산자 뒤에 사용하기에 너무 단단히 바인딩됩니다. 마지막 요소의 일부가됩니다. 리스트 연산자 인수 주위에 항상 괄호를 사용하여리스트 연산자를 함수 호출과 유사한 동작으로 되돌릴 수 있습니다. 또는 프로토 타입 &lt;code&gt;($)&lt;/code&gt; 을 사용하여 서브 루틴을 단항 연산자로 전환 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="79d7fc67720af71225bb992fc841089461a260dd" translate="yes" xml:space="preserve">
          <source>A bare, single &lt;b&gt;statement&lt;/b&gt;, without any braces, hanging off an &lt;code&gt;if&lt;/code&gt; or &lt;code&gt;while&lt;/code&gt; conditional. C allows them. Perl doesn&amp;rsquo;t.</source>
          <target state="translated">&lt;code&gt;if&lt;/code&gt; 또는 &lt;code&gt;while&lt;/code&gt; 조건부 에서 중단없이 중괄호가없는 간단한 단일 &lt;b&gt;명령문&lt;/b&gt; . C는 그들을 허용합니다. 펄은 그렇지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7c021cbe956d43771e93a19ff22791f5da1edc86" translate="yes" xml:space="preserve">
          <source>A basic building block. When you&amp;rsquo;re talking about an &lt;b&gt;array&lt;/b&gt;, it&amp;rsquo;s one of the items that make up the array.</source>
          <target state="translated">기본 빌딩 블록. &lt;b&gt;배열&lt;/b&gt; 에 대해 이야기 할 때 &lt;b&gt;배열&lt;/b&gt; 을 구성하는 항목 중 하나입니다.</target>
        </trans-unit>
        <trans-unit id="dc24770c94125e3eea533d29f62a33f6fca11b44" translate="yes" xml:space="preserve">
          <source>A basic example</source>
          <target state="translated">기본 예</target>
        </trans-unit>
        <trans-unit id="f7282a24ce95eed40d8f1f24671950459bbf71d8" translate="yes" xml:space="preserve">
          <source>A basic non-buffered layer which calls Unix/POSIX &lt;code&gt;&lt;a href=&quot;functions/read&quot;&gt;read()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/write&quot;&gt;write()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;lseek()&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/close&quot;&gt;close()&lt;/a&gt;&lt;/code&gt;. No buffering. Even on platforms that distinguish between O_TEXT and O_BINARY this layer is always O_BINARY.</source>
          <target state="translated">Unix / POSIX &lt;code&gt;&lt;a href=&quot;functions/read&quot;&gt;read()&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/write&quot;&gt;write()&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;lseek()&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/close&quot;&gt;close()&lt;/a&gt;&lt;/code&gt; 를 호출하는 버퍼되지 않은 기본 레이어입니다 . 버퍼링이 없습니다. O_TEXT와 O_BINARY를 구분하는 플랫폼에서도이 레이어는 항상 O_BINARY입니다.</target>
        </trans-unit>
        <trans-unit id="96f31fcb471e12245ded4f9a6d4759ba999aaaaa" translate="yes" xml:space="preserve">
          <source>A basic non-buffered layer which calls Unix/POSIX &lt;code&gt;read()&lt;/code&gt;, &lt;code&gt;write()&lt;/code&gt;, &lt;code&gt;lseek()&lt;/code&gt;, &lt;code&gt;close()&lt;/code&gt;. No buffering. Even on platforms that distinguish between O_TEXT and O_BINARY this layer is always O_BINARY.</source>
          <target state="translated">Unix / POSIX &lt;code&gt;read()&lt;/code&gt; , &lt;code&gt;write()&lt;/code&gt; , &lt;code&gt;lseek()&lt;/code&gt; , &lt;code&gt;close()&lt;/code&gt; 를 호출하는 기본 비 버퍼 레이어 . 버퍼링이 없습니다. O_TEXT와 O_BINARY를 구분하는 플랫폼에서도이 레이어는 항상 O_BINARY입니다.</target>
        </trans-unit>
        <trans-unit id="3269aa1ef3bfcd123309b115096aa27b3b0a0aa8" translate="yes" xml:space="preserve">
          <source>A bigger, fancier sort of &lt;b&gt;program&lt;/b&gt; with a fancier name so people don&amp;rsquo;t realize they are using a program.</source>
          <target state="translated">의 더 큰, 애호가 종류의 &lt;b&gt;프로그램&lt;/b&gt; 애호가 이름을 가진 사람들은이 프로그램을 사용하는 인식하지 않도록.</target>
        </trans-unit>
        <trans-unit id="3fc8298d557ca48e82c9d8c77d3a4da35fed0d13" translate="yes" xml:space="preserve">
          <source>A binary search such as that provided by &lt;a href=&quot;#search_invlist%28%29&quot;&gt;&quot;search_invlist()&quot;&lt;/a&gt;, can be used to quickly find a code point in the inversion list, and hence its corresponding mapping.</source>
          <target state="translated">&lt;a href=&quot;#search_invlist%28%29&quot;&gt;&quot;search_invlist ()&quot;&lt;/a&gt; 에서 제공하는 것과 같은 이진 검색을 사용하면 반전 목록에서 코드 포인트를 빠르게 찾을 수 있으므로 해당 매핑을 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1395a44d1527cd51acf9f72e88e221dc5e7a43dc" translate="yes" xml:space="preserve">
          <source>A binary search such as that provided by &lt;a href=&quot;#search_invlist()&quot;&gt;search_invlist()&lt;/a&gt;, can be used to quickly find a code point in the inversion list, and hence its corresponding mapping.</source>
          <target state="translated">&lt;a href=&quot;#search_invlist()&quot;&gt;search_invlist ()&lt;/a&gt; 에서 제공하는 것과 같은 이진 검색을 사용하여 반전 목록에서 코드 포인트를 신속하게 찾아 해당 매핑을 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a3982f0643b548a46d27f9bb45d706ffed3877fd" translate="yes" xml:space="preserve">
          <source>A bit of magic: executing Perl code in a regular expression</source>
          <target state="translated">약간의 마술 : 정규식으로 Perl 코드 실행</target>
        </trans-unit>
        <trans-unit id="a21b7a38b7737dbecfe5abeb569d1f5e67680088" translate="yes" xml:space="preserve">
          <source>A bitfield containing &lt;code&gt;AI_*&lt;/code&gt; constants; see below.</source>
          <target state="translated">&lt;code&gt;AI_*&lt;/code&gt; 상수를 포함하는 비트 필드 . 아래를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="5315c3bf863fe0d813794db09004e209616806a3" translate="yes" xml:space="preserve">
          <source>A bolt out of the blue; that is, an event triggered by the &lt;b&gt;operating system&lt;/b&gt;, probably when you&amp;rsquo;re least expecting it.</source>
          <target state="translated">파란색에서 볼트; 즉 , 아마도 &lt;b&gt;운영 체제&lt;/b&gt; 에 의해 트리거되는 이벤트 일 것입니다.</target>
        </trans-unit>
        <trans-unit id="37f6985b23fa2a35e2960a3080f908d1bc2f10c9" translate="yes" xml:space="preserve">
          <source>A boolean comparison operator such as &lt;code&gt;$_ &amp;lt; 10&lt;/code&gt; or &lt;code&gt;$x eq &quot;abc&quot;&lt;/code&gt; . The relational operators that this applies to are the six numeric comparisons (&lt;code&gt;&amp;lt;&lt;/code&gt; , &lt;code&gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;=&lt;/code&gt; , &lt;code&gt;&amp;gt;=&lt;/code&gt; , &lt;code&gt;==&lt;/code&gt; , and &lt;code&gt;!=&lt;/code&gt; ), and the six string comparisons (&lt;code&gt;lt&lt;/code&gt; , &lt;code&gt;gt&lt;/code&gt; , &lt;code&gt;le&lt;/code&gt; , &lt;code&gt;ge&lt;/code&gt; , &lt;code&gt;eq&lt;/code&gt; , and &lt;code&gt;ne&lt;/code&gt; ).</source>
          <target state="translated">같은 부울 비교 연산자 &lt;code&gt;$_ &amp;lt; 10&lt;/code&gt; 또는 &lt;code&gt;$x eq &quot;abc&quot;&lt;/code&gt; . 이것이 적용되는 관계 연산자는 6 개의 숫자 비교 ( &lt;code&gt;&amp;lt;&lt;/code&gt; , &lt;code&gt;&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;=&lt;/code&gt; , &lt;code&gt;&amp;gt;=&lt;/code&gt; , &lt;code&gt;==&lt;/code&gt; 및 &lt;code&gt;!=&lt;/code&gt; ) 및 6 개의 문자열 비교 ( &lt;code&gt;lt&lt;/code&gt; , &lt;code&gt;gt&lt;/code&gt; , &lt;code&gt;le&lt;/code&gt; , &lt;code&gt;ge&lt;/code&gt; , &lt;code&gt;eq&lt;/code&gt; 및 &lt;code&gt;ne&lt;/code&gt; )입니다. .</target>
        </trans-unit>
        <trans-unit id="f872d192d60363c8ec38811eaa9cd396b2186576" translate="yes" xml:space="preserve">
          <source>A boolean comparison operator such as &lt;code&gt;$_ &amp;lt; 10&lt;/code&gt; or &lt;code&gt;$x eq &quot;abc&quot;&lt;/code&gt;. The relational operators that this applies to are the six numeric comparisons (&lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;=&lt;/code&gt;, &lt;code&gt;&amp;gt;=&lt;/code&gt;, &lt;code&gt;==&lt;/code&gt;, and &lt;code&gt;!=&lt;/code&gt;), and the six string comparisons (&lt;code&gt;lt&lt;/code&gt;, &lt;code&gt;gt&lt;/code&gt;, &lt;code&gt;le&lt;/code&gt;, &lt;code&gt;ge&lt;/code&gt;, &lt;code&gt;eq&lt;/code&gt;, and &lt;code&gt;ne&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;$_ &amp;lt; 10&lt;/code&gt; 또는 &lt;code&gt;$x eq &quot;abc&quot;&lt;/code&gt; 와 같은 부울 비교 연산자 . 이 적용된다는 관계 연산자는 여섯 개 숫자 비교하다 ( &lt;code&gt;&amp;lt;&lt;/code&gt; , &lt;code&gt;&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;=&lt;/code&gt; , &lt;code&gt;&amp;gt;=&lt;/code&gt; , &lt;code&gt;==&lt;/code&gt; 와 &lt;code&gt;!=&lt;/code&gt; ), 그리고 여섯 개 문자열 비교 ( &lt;code&gt;lt&lt;/code&gt; , &lt;code&gt;gt&lt;/code&gt; , &lt;code&gt;le&lt;/code&gt; , &lt;code&gt;ge&lt;/code&gt; , &lt;code&gt;eq&lt;/code&gt; , 및 &lt;code&gt;ne&lt;/code&gt; ) .</target>
        </trans-unit>
        <trans-unit id="d16e0ea8efa85160b2ce98c496eca41e4f3f0abe" translate="yes" xml:space="preserve">
          <source>A boolean flag indicating whether a</source>
          <target state="translated">여부를 나타내는 부울 플래그</target>
        </trans-unit>
        <trans-unit id="5784bf453d1712122e0236fafc88e209e3c6adfe" translate="yes" xml:space="preserve">
          <source>A boolean flag that indicates if this argument was a required argument. If marked as required and not provided, check() will fail.</source>
          <target state="translated">이 인수가 필수 인수인지 여부를 나타내는 부울 플래그입니다. 필수로 표시되고 제공되지 않으면 check ()가 실패합니다.</target>
        </trans-unit>
        <trans-unit id="e6fe446e073ed79c5385621f6ed10de019fdcb46" translate="yes" xml:space="preserve">
          <source>A boolean indicating whether or not the test suite passed</source>
          <target state="translated">테스트 스위트가 통과했는지 여부를 나타내는 부울</target>
        </trans-unit>
        <trans-unit id="26eff46626719c9961598f48502b4f5bf7c8df23" translate="yes" xml:space="preserve">
          <source>A boolean indicating whether or not this call is for a subtest</source>
          <target state="translated">이 호출이 하위 테스트를위한 것인지 여부를 나타내는 부울</target>
        </trans-unit>
        <trans-unit id="8e5d923e23cbfcf9ddbcab23430ab0d60567d207" translate="yes" xml:space="preserve">
          <source>A boolean that denotes whether this is a decimal or dotted-decimal version. See &lt;a href=&quot;version#is_qv%28%29&quot;&gt;&quot;is_qv()&quot; in version&lt;/a&gt;.</source>
          <target state="translated">10 진수 버전인지 점으로 구분 된 10 진수 버전인지를 나타내는 부울입니다. &lt;a href=&quot;version#is_qv%28%29&quot;&gt;버전의 &quot;is_qv ()&quot;를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0f45f2fd37a08c482eccef8f9a0e056c9088589f" translate="yes" xml:space="preserve">
          <source>A boolean that denotes whether this is an alpha version. NOTE: that the underscore can only appear in the last position. See &lt;a href=&quot;version#is_alpha%28%29&quot;&gt;&quot;is_alpha()&quot; in version&lt;/a&gt;.</source>
          <target state="translated">알파 버전인지 여부를 나타내는 부울입니다. 참고 : 밑줄은 마지막 위치에만 나타날 수 있습니다. &lt;a href=&quot;version#is_alpha%28%29&quot;&gt;버전의 &quot;is_alpha ()&quot;를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="806d4e84607ce29c56416e6b774c66e8a0e936b0" translate="yes" xml:space="preserve">
          <source>A boolean to indicate whether &lt;code&gt;check&lt;/code&gt; should be verbose and warn about what went wrong in a check or not.</source>
          <target state="translated">&lt;code&gt;check&lt;/code&gt; 이 장황 해야하는지 여부를 표시 하고 점검에서 무엇이 잘못되었는지 경고 하는 부울 입니다.</target>
        </trans-unit>
        <trans-unit id="75de768f80b992cf9735e1b55771968cbd72780f" translate="yes" xml:space="preserve">
          <source>A boolean type. This can be used to pass true and false values to and from C.</source>
          <target state="translated">부울 유형입니다. C와의 true 및 false 값을 전달하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="aaea9ae3f33d9df07a73532337b752e2bd4004dd" translate="yes" xml:space="preserve">
          <source>A boolean value indicating whether or not the module was found to be at least the version you specified. If you did not specify a version, uptodate will always be true if the module was found. If no parsable version was found in the module, uptodate will also be true, since &lt;code&gt;check_install&lt;/code&gt; had no way to verify clearly.</source>
          <target state="translated">모듈이 최소한 지정한 버전인지 여부를 나타내는 부울 값입니다. 버전을 지정하지 않은 경우 모듈이 발견되면 항상 최신 상태가됩니다. 모듈에서 구문 분석 가능한 버전을 찾지 못하면 &lt;code&gt;check_install&lt;/code&gt; 이 명확하게 확인할 방법이 없으므로 최신 버전도 적용됩니다 .</target>
        </trans-unit>
        <trans-unit id="cf5fbd766ee0c61b894a2e6590881532089d7fdc" translate="yes" xml:space="preserve">
          <source>A brief description for most of the mentioned CJK encodings is contained in &lt;a href=&quot;http://www.debian.org/doc/manuals/intro-i18n/ch-codes.en.html&quot;&gt;http://www.debian.org/doc/manuals/intro-i18n/ch-codes.en.html&lt;/a&gt;</source>
          <target state="translated">언급 된 대부분의 CJK 인코딩에 대한 간략한 설명은 &lt;a href=&quot;http://www.debian.org/doc/manuals/intro-i18n/ch-codes.en.html&quot;&gt;http://www.debian.org/doc/manuals/intro-i18n/ch-codes.en.html&lt;/a&gt; 에 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f4da841a146cb38a789f449f32f4b854b9d0c640" translate="yes" xml:space="preserve">
          <source>A built-in unary operator that you use to determine whether something is &lt;b&gt;true&lt;/b&gt; about a file, such as &lt;code&gt;&amp;ndash;o
$filename&lt;/code&gt; to test whether you&amp;rsquo;re the owner of the file.</source>
          <target state="translated">파일 소유자인지 여부를 테스트하기 위해 &lt;code&gt;&amp;ndash;o $filename&lt;/code&gt; 과 같이 파일에 대해 어떤 것이 &lt;b&gt;사실&lt;/b&gt; 인지 확인하기 위해 사용하는 내장 단항 연산자입니다 .</target>
        </trans-unit>
        <trans-unit id="7359d066cd43a6821cadbf98e46de3780a2f14da" translate="yes" xml:space="preserve">
          <source>A bundle is just a perl module in the namespace Bundle:: that does not define any functions or methods. It usually only contains documentation.</source>
          <target state="translated">번들은 네임 스페이스 Bundle ::의 펄 모듈 일 뿐이며, 함수 나 메소드를 정의하지 않습니다. 일반적으로 문서 만 포함합니다.</target>
        </trans-unit>
        <trans-unit id="dcc2eb86ccf8cc61d11e939a89cf35406fa7d7cc" translate="yes" xml:space="preserve">
          <source>A call to &lt;a href=&quot;#DECLARATION_FOR_LC_NUMERIC_MANIPULATION&quot;&gt;&quot;DECLARATION_FOR_LC_NUMERIC_MANIPULATION&quot;&lt;/a&gt; must have been made to declare at compile time a private variable used by this macro and the two &lt;code&gt;STORE&lt;/code&gt; ones. This macro should be called as a single statement, not an expression, but with an empty argument list, like this:</source>
          <target state="translated">&lt;a href=&quot;#DECLARATION_FOR_LC_NUMERIC_MANIPULATION&quot;&gt;&quot;DECLARATION_FOR_LC_NUMERIC_MANIPULATION&quot;에&lt;/a&gt; 대한 호출 은 컴파일 타임에이 매크로와 두 개의 &lt;code&gt;STORE&lt;/code&gt; 항목 에서 사용하는 개인 변수를 선언해야 합니다. 이 매크로는 표현식이 아니라 다음과 같이 빈 인수 목록이있는 단일 문으로 호출되어야합니다.</target>
        </trans-unit>
        <trans-unit id="ae8e1c29a7f993180d6961dbd822ca7a9b81fdce" translate="yes" xml:space="preserve">
          <source>A call to &lt;a href=&quot;#DECLARATION_FOR_LC_NUMERIC_MANIPULATION&quot;&gt;&quot;DECLARATION_FOR_LC_NUMERIC_MANIPULATION&quot;&lt;/a&gt; must have been made to declare at compile time a private variable used by this macro. This macro should be called as a single statement, not an expression, but with an empty argument list, like this:</source>
          <target state="translated">&lt;a href=&quot;#DECLARATION_FOR_LC_NUMERIC_MANIPULATION&quot;&gt;&quot;DECLARATION_FOR_LC_NUMERIC_MANIPULATION&quot;에&lt;/a&gt; 대한 호출 이이 매크로에서 사용하는 개인 변수를 컴파일 타임에 선언하도록 만들어 졌어 야합니다. 이 매크로는 표현식이 아니라 다음과 같이 빈 인수 목록이있는 단일 문으로 호출되어야합니다.</target>
        </trans-unit>
        <trans-unit id="dcefaccadd4fc0b82966dd6fe0502b4a54a13075" translate="yes" xml:space="preserve">
          <source>A call to &lt;a href=&quot;#DECLARATION_FOR_LC_NUMERIC_MANIPULATION&quot;&gt;DECLARATION_FOR_LC_NUMERIC_MANIPULATION&lt;/a&gt; must have been made to declare at compile time a private variable used by this macro and the two &lt;code&gt;STORE&lt;/code&gt; ones. This macro should be called as a single statement, not an expression, but with an empty argument list, like this:</source>
          <target state="translated">컴파일 &lt;a href=&quot;#DECLARATION_FOR_LC_NUMERIC_MANIPULATION&quot;&gt;시이&lt;/a&gt; 매크로와 두 개의 &lt;code&gt;STORE&lt;/code&gt; 변수가 사용하는 개인 변수를 선언 하기 위해 DECLARATION_FOR_LC_NUMERIC_MANIPULATION을 호출 해야 합니다. 이 매크로는 표현식이 아니라 다음과 같이 인수 목록이 비어있는 단일 명령문으로 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="85dcd887c15b971af653f15a54e47c2790e7a16c" translate="yes" xml:space="preserve">
          <source>A call to &lt;a href=&quot;#DECLARATION_FOR_LC_NUMERIC_MANIPULATION&quot;&gt;DECLARATION_FOR_LC_NUMERIC_MANIPULATION&lt;/a&gt; must have been made to declare at compile time a private variable used by this macro. This macro should be called as a single statement, not an expression, but with an empty argument list, like this:</source>
          <target state="translated">컴파일 &lt;a href=&quot;#DECLARATION_FOR_LC_NUMERIC_MANIPULATION&quot;&gt;시이&lt;/a&gt; 매크로가 사용하는 개인 변수를 선언 하기 위해 DECLARATION_FOR_LC_NUMERIC_MANIPULATION을 호출 해야합니다. 이 매크로는 표현식이 아니라 다음과 같이 인수 목록이 비어있는 단일 명령문으로 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="6d081cdfc1719628de161b242cc46c6122417557" translate="yes" xml:space="preserve">
          <source>A call to &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; will cause Perl to exit, and to invoke the command given as an argument to &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; via &lt;code&gt;lib$do_command&lt;/code&gt; . If the argument begins with '@' or '$' (other than as part of a filespec), then it is executed as a DCL command. Otherwise, the first token on the command line is treated as the filespec of an image to run, and an attempt is made to invoke it (using</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; 를 호출 하면 Perl이 종료되고 &lt;code&gt;lib$do_command&lt;/code&gt; 를 통해 &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; 에 인수로 제공된 명령이 호출 됩니다. 인수가 '@'또는 '$'(filespec의 일부가 아닌)로 시작하면 DCL 명령으로 실행됩니다. 그렇지 않으면, 명령 행의 첫 번째 토큰은 실행할 이미지의 파일 스펙으로 취급되며이를 호출하려고 시도합니다 (</target>
        </trans-unit>
        <trans-unit id="85638aa0428bad6b05c5801235d5757932516e51" translate="yes" xml:space="preserve">
          <source>A call to &lt;code&gt;exec&lt;/code&gt; will cause Perl to exit, and to invoke the command given as an argument to &lt;code&gt;exec&lt;/code&gt; via &lt;code&gt;lib$do_command&lt;/code&gt;. If the argument begins with '@' or '$' (other than as part of a filespec), then it is executed as a DCL command. Otherwise, the first token on the command line is treated as the filespec of an image to run, and an attempt is made to invoke it (using</source>
          <target state="translated">&lt;code&gt;exec&lt;/code&gt; 를 호출 하면 Perl이 종료되고 &lt;code&gt;lib$do_command&lt;/code&gt; 를 통해 &lt;code&gt;exec&lt;/code&gt; 에 대한 인수로 제공된 명령이 호출 됩니다. 인수가 '@'또는 '$'(파일 사양의 일부 제외)로 시작하면 DCL 명령으로 실행됩니다. 그렇지 않으면 명령 줄의 첫 번째 토큰이 실행할 이미지의 파일 사양으로 처리되고이를 호출하려고 시도합니다 (사용</target>
        </trans-unit>
        <trans-unit id="9b1310b4d6c00ffc23a2f0bae5e7870ed9e6ede4" translate="yes" xml:space="preserve">
          <source>A character class is a way of denoting a set of characters in such a way that one character of the set is matched. It's important to remember that: matching a character class consumes exactly one character in the source string. (The source string is the string the regular expression is matched against.)</source>
          <target state="translated">문자 클래스는 세트의 한 문자가 일치하는 방식으로 문자 세트를 나타내는 방법입니다. 문자 클래스를 일치시키는 것은 소스 문자열에서 정확히 하나의 문자를 소비합니다. 소스 문자열은 정규식과 일치하는 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="2d7e4b0e3a328dba3c81ba02d01a3c0f782c72a5" translate="yes" xml:space="preserve">
          <source>A character encoding form plus byte serialization. There are Seven character encoding schemes in Unicode: UTF-8, UTF-16, UTF-16BE, UTF-16LE, UTF-32 (UCS-4), UTF-32BE (UCS-4BE) and UTF-32LE (UCS-4LE), and UTF-7.</source>
          <target state="translated">문자 인코딩 형식과 바이트 직렬화 유니 코드에는 UTF-8, UTF-16, UTF-16BE, UTF-16LE, UTF-32 (UCS-4), UTF-32BE (UCS-4BE) 및 UTF-32LE (UCS-4LE)의 7 가지 문자 인코딩 체계가 있습니다. ) 및 UTF-7입니다.</target>
        </trans-unit>
        <trans-unit id="e2b2859306209b5e788c7205519699be5962c3a1" translate="yes" xml:space="preserve">
          <source>A character entity was found that does not belong to the standard ISO set or the POD specials &lt;code&gt;verbar&lt;/code&gt; and &lt;code&gt;sol&lt;/code&gt; .</source>
          <target state="translated">표준 ISO 세트 또는 POD 스페셜 &lt;code&gt;verbar&lt;/code&gt; 및 &lt;code&gt;sol&lt;/code&gt; 에 속하지 않는 문자 엔티티가 발견되었습니다 .</target>
        </trans-unit>
        <trans-unit id="3efbfb7c6f5b656c49fa17f73fcaa9b6dc991658" translate="yes" xml:space="preserve">
          <source>A character entity was found that does not belong to the standard ISO set or the POD specials &lt;code&gt;verbar&lt;/code&gt; and &lt;code&gt;sol&lt;/code&gt;.</source>
          <target state="translated">표준 ISO 세트 또는 POD 스페셜 &lt;code&gt;verbar&lt;/code&gt; 및 &lt;code&gt;sol&lt;/code&gt; 에 속하지 않는 문자 엔티티가 발견되었습니다 .</target>
        </trans-unit>
        <trans-unit id="6b3facef3525988e61e4c03673d831959bbb24fc" translate="yes" xml:space="preserve">
          <source>A character in the range 0 .. 2**32-1 (or more); what Perl's strings are made of.</source>
          <target state="translated">0 .. 2 ** 32-1 (또는 그 이상) 범위의 문자; 펄의 줄이 만들어지는 것.</target>
        </trans-unit>
        <trans-unit id="4c66dbdd31c41ff8290d5b9e5b84c42f44091393" translate="yes" xml:space="preserve">
          <source>A character in the range 0..255; a special case of a Perl character.</source>
          <target state="translated">0..255 범위의 문자; 펄 캐릭터의 특별한 경우.</target>
        </trans-unit>
        <trans-unit id="deb99f697e889e229888732646e1d9a4b2cd77a6" translate="yes" xml:space="preserve">
          <source>A character range may be specified with a hyphen, so &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr/A-J/0-9/&lt;/a&gt;&lt;/code&gt; does the same replacement as &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr/ACEGIBDFHJ/0246813579/&lt;/a&gt;&lt;/code&gt;. For &lt;b&gt;sed&lt;/b&gt; devotees, &lt;code&gt;&lt;a href=&quot;functions/y&quot;&gt;y&lt;/a&gt;&lt;/code&gt; is provided as a synonym for &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr&lt;/a&gt;&lt;/code&gt;. If the</source>
          <target state="translated">문자 범위는 하이픈으로 지정할 수 있으므로 &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr/A-J/0-9/&lt;/a&gt;&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr/ACEGIBDFHJ/0246813579/&lt;/a&gt;&lt;/code&gt; 와 동일한 대체를 수행합니다 . 들면 &lt;b&gt;나오지&lt;/b&gt; 헌신, &lt;code&gt;&lt;a href=&quot;functions/y&quot;&gt;y&lt;/a&gt;&lt;/code&gt; 동의어로 제공된다 &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr&lt;/a&gt;&lt;/code&gt; . 만약</target>
        </trans-unit>
        <trans-unit id="62e5445beeff56a35c0dc5ca65bde86d53c27ebb" translate="yes" xml:space="preserve">
          <source>A character set comprising all the major character sets of the world, more or less. See &lt;a href=&quot;http://www.unicode.org&quot;&gt;http://www.unicode.org&lt;/a&gt;.</source>
          <target state="translated">월드의 모든 주요 문자 세트로 구성되는 문자 세트. &lt;a href=&quot;http://www.unicode.org&quot;&gt;http://www.unicode.org를&lt;/a&gt; 참조 하십시오 .</target>
        </trans-unit>
        <trans-unit id="5e5a861e5d79ec9801dc0afc379f1516aa190f92" translate="yes" xml:space="preserve">
          <source>A character set that aims to include all character repertoires of the world. Many character sets in various national as well as industrial standards have become, in a way, just subsets of Unicode.</source>
          <target state="translated">전 세계의 모든 캐릭터 레퍼토리를 포함하는 것을 목표로하는 캐릭터 세트입니다. 다양한 국가 및 산업 표준의 많은 문자 집합은 어떤면에서 유니 코드의 하위 집합이되었습니다.</target>
        </trans-unit>
        <trans-unit id="dcd6e4ff71c892f21b92e2e5137c07d6d2cc0f6c" translate="yes" xml:space="preserve">
          <source>A character set that is mapped in a way computers can use directly. Many character encodings, including EUC, fall in this category.</source>
          <target state="translated">컴퓨터가 직접 사용할 수있는 방식으로 매핑 된 문자 집합입니다. EUC를 포함한 많은 문자 인코딩이이 범주에 속합니다.</target>
        </trans-unit>
        <trans-unit id="8c07be0779b2376c619d1a65316d136daa5c26ab" translate="yes" xml:space="preserve">
          <source>A character symbolizing the type of IO Handle.</source>
          <target state="translated">IO 핸들의 유형을 상징하는 문자.</target>
        </trans-unit>
        <trans-unit id="ad2f4627442f7e9e5cdd45c11902cca0d8325c3b" translate="yes" xml:space="preserve">
          <source>A character with the numeric value of zero. It&amp;rsquo;s used by C to terminate strings, but Perl allows strings to contain a null.</source>
          <target state="translated">숫자 값이 0 인 문자 C에서 문자열을 종료하는 데 사용되지만 Perl에서는 문자열에 null이 포함될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a98fe200a320861843965673193461dc42788194" translate="yes" xml:space="preserve">
          <source>A check is made to make sure that the file that is found does contain some pod documentation.</source>
          <target state="translated">찾은 파일에 일부 포드 설명서가 포함되어 있는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="dff052af6a3279311d539bddc8b2f4ffb4c3bccf" translate="yes" xml:space="preserve">
          <source>A check routine is called when the node is fully constructed except for the execution-order thread. Since at this time there are no back-links to the currently constructed node, one can do most any operation to the top-level node, including freeing it and/or creating new nodes above/below it.</source>
          <target state="translated">실행 순서 스레드를 제외하고 노드가 완전히 구성되면 점검 루틴이 호출됩니다. 현재는 현재 구성된 노드에 대한 백 링크가 없기 때문에 노드 해제 및 / 또는 위 / 아래에 새 노드 생성을 포함하여 최상위 노드에 대한 모든 작업을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ffb83db9b043670ff139e922da8f6f1ecd3cdb22" translate="yes" xml:space="preserve">
          <source>A class implementing a filehandle should have the following methods:</source>
          <target state="translated">파일 핸들을 구현하는 클래스에는 다음 메소드가 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="78efc3f39c8e446fbaac2a63562d8cf90bbe3489" translate="yes" xml:space="preserve">
          <source>A class implementing a hash should have the following methods:</source>
          <target state="translated">해시를 구현하는 클래스에는 다음과 같은 메소드가 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="c29da3bd78457adcea44e08fd7ad308e312eac90" translate="yes" xml:space="preserve">
          <source>A class implementing a scalar should have the following methods:</source>
          <target state="translated">스칼라를 구현하는 클래스에는 다음 메소드가 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="63533b67267a9fe7a63e719b4e79f437e64bb6e7" translate="yes" xml:space="preserve">
          <source>A class implementing a tied filehandle should define the following methods: TIEHANDLE, at least one of PRINT, PRINTF, WRITE, READLINE, GETC, READ, and possibly CLOSE, UNTIE and DESTROY. The class can also provide: BINMODE, OPEN, EOF, FILENO, SEEK, TELL - if the corresponding perl operators are used on the handle.</source>
          <target state="translated">묶인 파일 핸들을 구현하는 클래스는 TIEHANDLE, PRINT, PRINTF, WRITE, READLINE, GETC, READ 및 CLOSE, UNTIE 및 DESTROY 중 하나 이상을 정의해야합니다. 클래스는 BINMODE, OPEN, EOF, FILENO, SEEK, TELL을 제공 할 수 있습니다. 해당 perl 연산자가 핸들에 사용 된 경우.</target>
        </trans-unit>
        <trans-unit id="860765a0ff8cee1341ccc04233da280b71701cf8" translate="yes" xml:space="preserve">
          <source>A class implementing a tied ordinary array should define the following methods: TIEARRAY, FETCH, STORE, FETCHSIZE, STORESIZE, CLEAR and perhaps UNTIE and/or DESTROY.</source>
          <target state="translated">연결된 일반 배열을 구현하는 클래스는 TIEARRAY, FETCH, STORE, FETCHSIZE, STORESIZE, CLEAR 및 UNTIE 및 / 또는 DESTROY 메소드를 정의해야합니다.</target>
        </trans-unit>
        <trans-unit id="bf2fe5249c3fde4bdfb3247a51b433da9021cc26" translate="yes" xml:space="preserve">
          <source>A class implementing a tied scalar should define the following methods: TIESCALAR, FETCH, STORE, and possibly UNTIE and/or DESTROY.</source>
          <target state="translated">연결된 스칼라를 구현하는 클래스는 TIESCALAR, FETCH, STORE 및 UNTIE 및 / 또는 DESTROY 메소드를 정의해야합니다.</target>
        </trans-unit>
        <trans-unit id="172ef2f1ff718aa5d74e2eddddd8780306842005" translate="yes" xml:space="preserve">
          <source>A class implementing an ordinary array should have the following methods:</source>
          <target state="translated">일반 배열을 구현하는 클래스에는 다음 메소드가 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="7a3aaef4b6bdc65044d6cee8905b655c826b75aa" translate="yes" xml:space="preserve">
          <source>A class is simply a package. A class provides methods that expect to operate on objects.</source>
          <target state="translated">클래스는 단순히 패키지입니다. 클래스는 객체에서 작동 할 것으로 예상되는 메서드를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="db991666cef49d40c1a8876d8e678d10cc5c5920" translate="yes" xml:space="preserve">
          <source>A class providing an object based interface to SysV IPC message queues.</source>
          <target state="translated">SysV IPC 메시지 큐에 객체 기반 인터페이스를 제공하는 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="4b371730a083c396c011c1644f5fee33b2fe22c7" translate="yes" xml:space="preserve">
          <source>A class providing an object based interface to SysV IPC semaphores.</source>
          <target state="translated">SysV IPC 세마포어에 객체 기반 인터페이스를 제공하는 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="937b26fb80fdcafceefce4e180073ce7c0d23781" translate="yes" xml:space="preserve">
          <source>A class providing an object based interface to SysV IPC shared memory.</source>
          <target state="translated">SysV IPC 공유 메모리에 객체 기반 인터페이스를 제공하는 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="bd175d0ab34111d2e7b8c50a111622dec0708ca3" translate="yes" xml:space="preserve">
          <source>A class:</source>
          <target state="translated">클래스 :</target>
        </trans-unit>
        <trans-unit id="fa2558ecb874a35a0f9b83568f215824db4e665c" translate="yes" xml:space="preserve">
          <source>A cleaner interface.</source>
          <target state="translated">깔끔한 인터페이스.</target>
        </trans-unit>
        <trans-unit id="243557da44bd0a5796f8364017fe91e379f3fd89" translate="yes" xml:space="preserve">
          <source>A client for such a server could be</source>
          <target state="translated">이러한 서버의 클라이언트는</target>
        </trans-unit>
        <trans-unit id="057ca0c3c407c4a073d1e7a556976d6dc49abacf" translate="yes" xml:space="preserve">
          <source>A code for the type of media. See the &lt;code&gt;&quot;:MEDIA_TYPE&quot;&lt;/code&gt; export class.</source>
          <target state="translated">미디어 유형에 대한 코드입니다. &lt;code&gt;&quot;:MEDIA_TYPE&quot;&lt;/code&gt; 내보내기 클래스를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d38d53db5215d12738985d5f40428b967eb33230" translate="yes" xml:space="preserve">
          <source>A collection of unique characters. A</source>
          <target state="translated">독특한 캐릭터 모음. ㅏ</target>
        </trans-unit>
        <trans-unit id="8ac161b3e973b3214fa6c5dba36e6bf752d3c13d" translate="yes" xml:space="preserve">
          <source>A comma-separated list of mirrors to use for just this run. The &lt;code&gt;-P&lt;/code&gt; option can find them for you automatically.</source>
          <target state="translated">이 실행에만 사용할 쉼표로 구분 된 미러 목록입니다. &lt;code&gt;-P&lt;/code&gt; 의 옵션이 자동으로 당신을 위해 그들을 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="551df32d5b94297e0a676020a161e26c925fb485" translate="yes" xml:space="preserve">
          <source>A command &quot;=begin</source>
          <target state="translated">&quot;= 시작된 명령</target>
        </trans-unit>
        <trans-unit id="4b51cb486fb82b1f8836c9909ccc915ba4671256" translate="yes" xml:space="preserve">
          <source>A command paragraph (also called a &quot;directive&quot;). The first line of this paragraph must match &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m/\A=[a-zA-Z]/&lt;/a&gt;&lt;/code&gt;. Command paragraphs are typically one line, as in:</source>
          <target state="translated">명령 단락 ( &quot;지시적&quot;이라고도 함) 이 단락의 첫 줄은 &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m/\A=[a-zA-Z]/&lt;/a&gt;&lt;/code&gt; 와 일치해야합니다 . 명령 단락은 일반적으로 다음과 같이 한 줄입니다.</target>
        </trans-unit>
        <trans-unit id="a57f5a78e79b4e4e45aef57f5fe85eaf31a249f1" translate="yes" xml:space="preserve">
          <source>A command paragraph (also called a &quot;directive&quot;). The first line of this paragraph must match &lt;code&gt;m/\A=[a-zA-Z]/&lt;/code&gt;. Command paragraphs are typically one line, as in:</source>
          <target state="translated">명령 단락 ( &quot;지시문&quot;이라고도 함). 이 단락의 첫 번째 줄은 &lt;code&gt;m/\A=[a-zA-Z]/&lt;/code&gt; 와 일치해야합니다 . 명령 단락은 일반적으로 다음과 같이 한 줄입니다.</target>
        </trans-unit>
        <trans-unit id="a63e70d9d65f24f45184b420c514e63650be0655" translate="yes" xml:space="preserve">
          <source>A command paragraph is used for special treatment of whole chunks of text, usually as headings or parts of lists.</source>
          <target state="translated">명령 단락은 전체 텍스트 청크를 일반적으로 제목 또는 목록의 일부로 처리하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="d9ff878c605ee9fd388f0b2eb88f5ce5a0c8f433" translate="yes" xml:space="preserve">
          <source>A command such as this can vastly reduce the volume of material to actually sort through in the first place, and should not be too lightly disregarded purely on the basis of its simplicity. The &lt;code&gt;KISS&lt;/code&gt; principle is too often overlooked - the next example uses the simple system &lt;code&gt;&lt;a href=&quot;functions/time&quot;&gt;time&lt;/a&gt;&lt;/code&gt; utility to demonstrate. Let's take a look at an actual example of sorting the contents of a large file, an apache logfile would do. This one has over a quarter of a million lines, is 50M in size, and a snippet of it looks like this:</source>
          <target state="translated">이와 같은 명령은 처음부터 실제로 분류 할 재료의 양을 크게 줄일 수 있으며 단순성만으로는 너무 가볍게 무시해서는 안됩니다. &lt;code&gt;KISS&lt;/code&gt; 의 원칙은 너무 자주 간과 - 다음 예는 간단한 시스템 사용 &lt;code&gt;&lt;a href=&quot;functions/time&quot;&gt;time&lt;/a&gt;&lt;/code&gt; 입증하는 유틸리티. 큰 파일의 내용을 정렬하는 실제 예를 살펴 보겠습니다. 아파치 로그 파일이 할 것입니다. 이것은 1 억 5 천 개의 줄을 가지고 있으며 크기는 50M이며, 그 조각은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0aea28bdea157023aa3d7cd5bd7e48a433c74487" translate="yes" xml:space="preserve">
          <source>A command such as this can vastly reduce the volume of material to actually sort through in the first place, and should not be too lightly disregarded purely on the basis of its simplicity. The &lt;code&gt;KISS&lt;/code&gt; principle is too often overlooked - the next example uses the simple system &lt;code&gt;time&lt;/code&gt; utility to demonstrate. Let's take a look at an actual example of sorting the contents of a large file, an apache logfile would do. This one has over a quarter of a million lines, is 50M in size, and a snippet of it looks like this:</source>
          <target state="translated">이와 같은 명령은 처음부터 실제로 분류 할 재료의 양을 크게 줄일 수 있으며 단순성에 근거하여 너무 가볍게 무시해서는 안됩니다. &lt;code&gt;KISS&lt;/code&gt; 의 원칙은 너무 자주 간과 - 다음 예는 간단한 시스템 사용 &lt;code&gt;time&lt;/code&gt; 입증하는 유틸리티. 큰 파일의 내용을 정렬하는 실제 예를 살펴 보겠습니다. 아파치 로그 파일이 수행합니다. 이것은 25 만 줄이 넘고 크기는 50M이며 그 일부는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="950be6f2b3fd35cd65faf61436fcb9557d03c11d" translate="yes" xml:space="preserve">
          <source>A command which has ended up in the middle of a paragraph or other command, such as</source>
          <target state="translated">단락의 중간에 끝나는 명령 또는 다음과 같은 다른 명령</target>
        </trans-unit>
        <trans-unit id="dfc138f19fcb5bcbc53f0752d4f1867a8fa0e913" translate="yes" xml:space="preserve">
          <source>A command-line front-end to &lt;code&gt;Module::CoreList&lt;/code&gt; , to query what modules were shipped with given versions of perl.</source>
          <target state="translated">주어진 버전의 perl과 함께 제공된 모듈을 조회 하기위한 &lt;code&gt;Module::CoreList&lt;/code&gt; 의 명령 행 프론트 엔드 .</target>
        </trans-unit>
        <trans-unit id="03a5eed393d50b8ebdff34b45b799ace9b9158b6" translate="yes" xml:space="preserve">
          <source>A command-line front-end to &lt;code&gt;Module::CoreList&lt;/code&gt;, to query what modules were shipped with given versions of perl.</source>
          <target state="translated">주어진 버전의 perl과 함께 어떤 모듈이 제공되었는지 쿼리 하기위한 &lt;code&gt;Module::CoreList&lt;/code&gt; 대한 명령 줄 프런트 엔드 입니다.</target>
        </trans-unit>
        <trans-unit id="9cbae24479d2e6391e2d1be21dd08d1626f00360" translate="yes" xml:space="preserve">
          <source>A comment</source>
          <target state="translated">코멘트</target>
        </trans-unit>
        <trans-unit id="79414afc2393f5f2f467ceef02de3748e14d7a7a" translate="yes" xml:space="preserve">
          <source>A comment, indicated by putting a '#' in the first column.</source>
          <target state="translated">첫 번째 열에 '#'을 넣으면 표시되는 주석입니다.</target>
        </trans-unit>
        <trans-unit id="b093d0d89cc94439fab7e6d11818a74b1c71812b" translate="yes" xml:space="preserve">
          <source>A comment. The</source>
          <target state="translated">코멘트. 그만큼</target>
        </trans-unit>
        <trans-unit id="ee091682ad4b542f16ac50d991bfff2ba6d1e9a6" translate="yes" xml:space="preserve">
          <source>A comment. The text is ignored. Note that Perl closes the comment as soon as it sees a &lt;code&gt;)&lt;/code&gt;, so there is no way to put a literal &lt;code&gt;)&lt;/code&gt; in the comment. The pattern's closing delimiter must be escaped by a backslash if it appears in the comment.</source>
          <target state="translated">의견. 텍스트는 무시됩니다. 펄은 곧 그것이 보는만큼 주석을 닫을 것을 주 &lt;code&gt;)&lt;/code&gt; , 그래서 문자를 넣어하는 방법은 없습니다 &lt;code&gt;)&lt;/code&gt; 주석에. 주석에 패턴이 나타나면 패턴의 닫는 분리 문자는 백 슬래시로 이스케이프되어야합니다.</target>
        </trans-unit>
        <trans-unit id="1efe142409d27cde9607bba9f906e0c889b26956" translate="yes" xml:space="preserve">
          <source>A commit message isn't intended to take the place of comments in your code. Commit messages should describe the change you made, while code comments should describe the current state of the code.</source>
          <target state="translated">커밋 메시지는 코드에서 주석을 대신하지 않습니다. 커밋 메시지는 변경 사항을 설명해야하며 코드 주석은 코드의 현재 상태를 설명해야합니다.</target>
        </trans-unit>
        <trans-unit id="bf7ad1fec29a3549dc58ded16ba4af5fb14c45da" translate="yes" xml:space="preserve">
          <source>A common abuse of this power stems from the ability to make infinite loops using regular expressions, with something as innocuous as:</source>
          <target state="translated">이 힘의 일반적인 남용은 다음과 같은 무해한 정규식을 사용하여 무한 루프를 만드는 기능에서 비롯됩니다.</target>
        </trans-unit>
        <trans-unit id="80ff7af3da26f57aaa8f224ec06b92247a2ede78" translate="yes" xml:space="preserve">
          <source>A common bit of code &lt;b&gt;NOT TO USE&lt;/b&gt; is this:</source>
          <target state="translated">&lt;b&gt;사용하지 말아야 할&lt;/b&gt; 일반적인 코드 는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="bcd3e6faa389885dcad88118cf027340603a19e2" translate="yes" xml:space="preserve">
          <source>A common misconception in socket programming is that &lt;code&gt;\n &lt;a href=&quot;functions/eq&quot;&gt;eq&lt;/a&gt; \012&lt;/code&gt; everywhere. When using protocols such as common Internet protocols, &lt;code&gt;\012&lt;/code&gt; and &lt;code&gt;\015&lt;/code&gt; are called for specifically, and the values of the logical &lt;code&gt;\n&lt;/code&gt; and &lt;code&gt;\r&lt;/code&gt; (carriage return) are not reliable.</source>
          <target state="translated">소켓 프로그래밍의 일반적인 오해는 &lt;code&gt;\n &lt;a href=&quot;functions/eq&quot;&gt;eq&lt;/a&gt; \012&lt;/code&gt; 입니다. 일반적인 인터넷 프로토콜과 같은 프로토콜을 사용하는 경우, 구체적으로 &lt;code&gt;\012&lt;/code&gt; 및 &lt;code&gt;\015&lt;/code&gt; 가 호출되며 논리 &lt;code&gt;\n&lt;/code&gt; 및 &lt;code&gt;\r&lt;/code&gt; (캐리지 리턴)의 값은 신뢰할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="547a6fcaad39d8d2e51072980c79106e4d8f2797" translate="yes" xml:space="preserve">
          <source>A common misconception in socket programming is that &lt;code&gt;\n eq \012&lt;/code&gt; everywhere. When using protocols such as common Internet protocols, &lt;code&gt;\012&lt;/code&gt; and &lt;code&gt;\015&lt;/code&gt; are called for specifically, and the values of the logical &lt;code&gt;\n&lt;/code&gt; and &lt;code&gt;\r&lt;/code&gt; (carriage return) are not reliable.</source>
          <target state="translated">소켓 프로그래밍의 일반적인 오해는 모든 곳에서 &lt;code&gt;\n eq \012&lt;/code&gt; 입니다. 일반적인 인터넷 프로토콜과 같은 프로토콜을 사용하는 경우 특히 &lt;code&gt;\012&lt;/code&gt; 및 &lt;code&gt;\015&lt;/code&gt; 가 호출되고 논리 &lt;code&gt;\n&lt;/code&gt; 및 &lt;code&gt;\r&lt;/code&gt; (캐리지 리턴)의 값은 신뢰할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="b9e9593af1f1c680a3827d8f5e0edca15a66c226" translate="yes" xml:space="preserve">
          <source>A common mistake is to try to separate the words with commas or to put comments into a multi-line &lt;code&gt;&lt;a href=&quot;functions/qw&quot;&gt;qw&lt;/a&gt;&lt;/code&gt;-string. For this reason, the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings&lt;/code&gt; pragma and the &lt;b&gt;-w&lt;/b&gt; switch (that is, the &lt;code&gt;$^W&lt;/code&gt; variable) produces warnings if the</source>
          <target state="translated">일반적인 실수는 단어를 쉼표로 분리하거나 여러 줄로 된 &lt;code&gt;&lt;a href=&quot;functions/qw&quot;&gt;qw&lt;/a&gt;&lt;/code&gt; 문자열 에 주석을 넣는 것입니다. 이러한 이유로 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings&lt;/code&gt; pragma 및 &lt;b&gt;-w&lt;/b&gt; 스위치 (즉, &lt;code&gt;$^W&lt;/code&gt; 변수)는 다음과 같은 경우 경고를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="7281583226716ee344a88588c1f30e8169fcc770" translate="yes" xml:space="preserve">
          <source>A common mistake is to try to separate the words with commas or to put comments into a multi-line &lt;code&gt;qw&lt;/code&gt;-string. For this reason, the &lt;code&gt;use warnings&lt;/code&gt; pragma and the &lt;b&gt;-w&lt;/b&gt; switch (that is, the &lt;code&gt;$^W&lt;/code&gt; variable) produces warnings if the</source>
          <target state="translated">일반적인 실수는 단어를 쉼표로 분리하거나 여러 줄의 &lt;code&gt;qw&lt;/code&gt; 문자열 에 주석을 넣는 것입니다. 이러한 이유로 &lt;code&gt;use warnings&lt;/code&gt; pragma 및 &lt;b&gt;-w&lt;/b&gt; 스위치 (즉, &lt;code&gt;$^W&lt;/code&gt; 변수)는 다음과 같은 경우 경고를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="aad5d9b3c5a0d882bf3ecc970194923dc4421054" translate="yes" xml:space="preserve">
          <source>A common mistake is to write:</source>
          <target state="translated">일반적인 실수는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7892054117b48e6a3618b7ba1c611a106354c30a" translate="yes" xml:space="preserve">
          <source>A common pitfall is to forget that &lt;code&gt;&quot;#&quot;&lt;/code&gt; characters begin a comment under &lt;code&gt;/x&lt;/code&gt; and are not matched literally. Just keep that in mind when trying to puzzle out why a particular &lt;code&gt;/x&lt;/code&gt; pattern isn't working as expected.</source>
          <target state="translated">일반적인 함정은 &lt;code&gt;&quot;#&quot;&lt;/code&gt; 문자가 &lt;code&gt;/x&lt;/code&gt; 아래에서 주석으로 시작되고 문자 그대로 일치하지 않는다는 사실을 잊는 것입니다 . 특정 &lt;code&gt;/x&lt;/code&gt; 패턴이 예상대로 작동하지 않는 이유를 파악하려고 할 때이 점을 염두에 두십시오 .</target>
        </trans-unit>
        <trans-unit id="053544785eaa005951fc7923348a6ed5ac918733" translate="yes" xml:space="preserve">
          <source>A common pitfall is to use &lt;a href=&quot;#precision%28%29&quot;&gt;&quot;precision()&quot;&lt;/a&gt; when you want to round a result to a certain number of digits:</source>
          <target state="translated">일반적인 함정은 결과를 특정 자릿수로 반올림하려는 경우 &lt;a href=&quot;#precision%28%29&quot;&gt;&quot;precision ()&quot;&lt;/a&gt; 을 사용 하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="2a1998491c1e38cb900464f10bbb2d155c01472d" translate="yes" xml:space="preserve">
          <source>A common pitfall is to use &lt;a href=&quot;#precision()&quot;&gt;precision()&lt;/a&gt; when you want to round a result to a certain number of digits:</source>
          <target state="translated">일반적인 함정은 결과를 특정 자릿수로 반올림하려는 경우 &lt;a href=&quot;#precision()&quot;&gt;precision ()&lt;/a&gt; 을 사용 하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="008944edbc996e59046c342b9a5abf856d868927" translate="yes" xml:space="preserve">
          <source>A common sight is code which looks something like this:</source>
          <target state="translated">일반적인 시각은 다음과 같은 코드입니다.</target>
        </trans-unit>
        <trans-unit id="7a1613d252216a78f3f6c4f13b80070f584c7ea5" translate="yes" xml:space="preserve">
          <source>A common value you might want would be just &quot;.&quot; for the current directory:</source>
          <target state="translated">원하는 일반적인 값은 &quot;.&quot;입니다. 현재 디렉토리의 경우 :</target>
        </trans-unit>
        <trans-unit id="fe5d8a965ad75566e7f17ed9a970119fdb9dbef8" translate="yes" xml:space="preserve">
          <source>A comparison of GNU and POSIX tar standards; &lt;code&gt;http://www.delorie.com/gnu/docs/tar/tar_114.html&lt;/code&gt;</source>
          <target state="translated">GNU와 POSIX tar 표준의 비교; &lt;code&gt;http://www.delorie.com/gnu/docs/tar/tar_114.html&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0c241c23e5c55b1df65f14fa3926fd6466b90d17" translate="yes" xml:space="preserve">
          <source>A complete list of Perl's error messages and warnings with explanatory text can be found in &lt;a href=&quot;perldiag&quot;&gt;perldiag&lt;/a&gt;. You can also use the splain program (distributed with Perl) to explain the error messages:</source>
          <target state="translated">펄의 오류 메시지 및 설명 텍스트와 경고의 전체 목록은에서 찾을 수 있습니다 &lt;a href=&quot;perldiag&quot;&gt;것은 perldiag&lt;/a&gt; . 또한 오류 프로그램 (Perl과 함께 배포 됨)을 사용하여 오류 메시지를 설명 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2766232819d1e10808eb2c0fa9745fbc9935b0e0" translate="yes" xml:space="preserve">
          <source>A complete list of blocks and their shortcuts is in &lt;a href=&quot;perluniprops&quot;&gt;perluniprops&lt;/a&gt;.</source>
          <target state="translated">전체 블록 목록과 바로 가기는 &lt;a href=&quot;perluniprops&quot;&gt;perluniprops에&lt;/a&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="4cbbc7ef27b343f02ecb00286ffab06c25627261" translate="yes" xml:space="preserve">
          <source>A complete list of blocks is in &lt;a href=&quot;perluniprops&quot;&gt;perluniprops&lt;/a&gt;.</source>
          <target state="translated">전체 블록 목록은 &lt;a href=&quot;perluniprops&quot;&gt;perluniprops에&lt;/a&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="1c9c8e1e2ba56e67cb98e64490d656c0331322db" translate="yes" xml:space="preserve">
          <source>A complete list of models at the time the OS was built is in the file /usr/sam/lib/mo/sched.models. The first column corresponds to the last part of the output of the &quot;model&quot; command. The second column is the PA-RISC version and the third column is the exact chip type used. (Start browsing at the bottom to prevent confusion ;-)</source>
          <target state="translated">OS가 구축 될 당시의 전체 모델 목록은 /usr/sam/lib/mo/sched.models 파일에 있습니다. 첫 번째 열은 &quot;model&quot;명령 출력의 마지막 부분에 해당합니다. 두 번째 열은 PA-RISC 버전이고 세 번째 열은 사용 된 정확한 칩 유형입니다. (혼란을 피하기 위해 하단에서 탐색을 시작하십시오 ;-)</target>
        </trans-unit>
        <trans-unit id="57f247bd806924e603c825d46c359f392e5225bb" translate="yes" xml:space="preserve">
          <source>A complete list of scripts and their shortcuts is in &lt;a href=&quot;perluniprops&quot;&gt;perluniprops&lt;/a&gt;.</source>
          <target state="translated">전체 스크립트 목록과 바로 가기는 &lt;a href=&quot;perluniprops&quot;&gt;perluniprops에&lt;/a&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="352eea5d492543a075b98638f01aabee71fa53f5" translate="yes" xml:space="preserve">
          <source>A complete thread tutorial could fill a book (and has, many times), but with what we've covered in this introduction, you should be well on your way to becoming a threaded Perl expert.</source>
          <target state="translated">완전한 실습 서가 책을 채울 수 있지만 여러 번이 책에서 다룬 내용을 통해 실감 나는 펄 전문가가 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="018d8cf23f3e4a65b253a6e3de9afa4ba28bc385" translate="yes" xml:space="preserve">
          <source>A component of a &lt;b&gt;regular expression&lt;/b&gt; pattern.</source>
          <target state="translated">&lt;b&gt;정규식&lt;/b&gt; 패턴 의 구성 요소입니다 .</target>
        </trans-unit>
        <trans-unit id="f5c9d218e3a29ce718317121d0020d3ccf6b9e88" translate="yes" xml:space="preserve">
          <source>A component of a &lt;b&gt;regular expression&lt;/b&gt; specifying how many times the foregoing &lt;b&gt;atom&lt;/b&gt; may occur.</source>
          <target state="translated">전술 한 &lt;b&gt;원자가&lt;/b&gt; 몇 번 나타날 수 있는지 를 나타내는 &lt;b&gt;정규식&lt;/b&gt; 의 구성 요소 .&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="ca17448c2b0615d183e89c2b8af18e1466ef0123" translate="yes" xml:space="preserve">
          <source>A component of a &lt;b&gt;regular expression&lt;/b&gt; that must be true for the pattern to match but does not necessarily match any characters itself. Often used specifically to mean a &lt;b&gt;zero-width&lt;/b&gt; assertion.</source>
          <target state="translated">패턴이 일치해야하지만 문자 자체와 반드시 일치 할 필요는없는 &lt;b&gt;정규식&lt;/b&gt; 의 구성 요소입니다 . &lt;b&gt;너비&lt;/b&gt; 가 &lt;b&gt;0 인&lt;/b&gt; 어설 션 을 의미하기 위해 종종 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="e4b110fd2e9cb16d7f0633f61d623ac063cd7727" translate="yes" xml:space="preserve">
          <source>A comprehensive list of Perl-related mailing lists can be found at &lt;a href=&quot;http://lists.perl.org/&quot;&gt;http://lists.perl.org/&lt;/a&gt;</source>
          <target state="translated">Perl 관련 메일 링리스트의 전체 목록은 &lt;a href=&quot;http://lists.perl.org/&quot;&gt;http://lists.perl.org/&lt;/a&gt; 에서 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="93cab815f48685f272ec4cd3a106ebc83fa3cbb8" translate="yes" xml:space="preserve">
          <source>A comprehensive overview of the Korean (&lt;code&gt;KS *&lt;/code&gt;) standards.</source>
          <target state="translated">한국어 ( &lt;code&gt;KS *&lt;/code&gt; ) 표준에 대한 포괄적 인 개요입니다 .</target>
        </trans-unit>
        <trans-unit id="7b95e9b387684f580231ace97a79e9e9349d1ddf" translate="yes" xml:space="preserve">
          <source>A consequence of the &lt;code&gt;split&lt;/code&gt; formulation is that &lt;b&gt;-M&lt;i&gt;MODULE&lt;/i&gt;=number&lt;/b&gt; never does a version check, unless &lt;code&gt;&lt;i&gt;MODULE&lt;/i&gt;::import()&lt;/code&gt; itself is set up to do a version check, which could happen for example if</source>
          <target state="translated">&lt;code&gt;split&lt;/code&gt; 공식화 의 결과는 &lt;code&gt;&lt;i&gt;MODULE&lt;/i&gt;::import()&lt;/code&gt; :: import () 자체가 버전 검사를 수행하도록 설정되어 있지 않는 한 &lt;b&gt;-M &lt;i&gt;MODULE&lt;/i&gt; = number&lt;/b&gt; 가 버전 검사 를 수행하지 않는다는 것입니다.&lt;i&gt;&lt;/i&gt;</target>
        </trans-unit>
        <trans-unit id="6ffdc43a299a7177f53314c9b7e876aeb0c84ac8" translate="yes" xml:space="preserve">
          <source>A consequence of this is that &lt;b&gt;-M&lt;i&gt;MODULE&lt;/i&gt;=number&lt;/b&gt; never does a version check, unless &lt;code&gt;&lt;i&gt;MODULE&lt;/i&gt;::import()&lt;/code&gt; itself is set up to do a version check, which could happen for example if</source>
          <target state="translated">결과적으로 &lt;code&gt;&lt;i&gt;MODULE&lt;/i&gt;::import()&lt;/code&gt; :: import () 자체가 버전 확인을 수행하도록 설정되어 있지 않으면 &lt;b&gt;-M &lt;i&gt;MODULE&lt;/i&gt; = number&lt;/b&gt; 는 버전 확인 을 수행하지 않습니다.&lt;i&gt;&lt;/i&gt;</target>
        </trans-unit>
        <trans-unit id="350e3e899dba4b57e7486366f0fbf9264f9b61f7" translate="yes" xml:space="preserve">
          <source>A constant with a name in the list &lt;code&gt;STDIN STDOUT STDERR ARGV ARGVOUT
ENV INC SIG&lt;/code&gt; is not allowed anywhere but in package &lt;code&gt;main::&lt;/code&gt; , for technical reasons.</source>
          <target state="translated">&lt;code&gt;STDIN STDOUT STDERR ARGV ARGVOUT ENV INC SIG&lt;/code&gt; 목록에 이름이있는 상수 는 기술적 인 이유로 &lt;code&gt;main::&lt;/code&gt; 패키지에 허용되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="33082690d5a42fa2c8743ad22c40a6af2321de88" translate="yes" xml:space="preserve">
          <source>A constant with a name in the list &lt;code&gt;STDIN STDOUT STDERR ARGV ARGVOUT ENV INC SIG&lt;/code&gt; is not allowed anywhere but in package &lt;code&gt;main::&lt;/code&gt;, for technical reasons.</source>
          <target state="translated">&lt;code&gt;STDIN STDOUT STDERR ARGV ARGVOUT ENV INC SIG&lt;/code&gt; 목록에 이름이있는 상수 는 기술적 인 이유로 &lt;code&gt;main::&lt;/code&gt; 패키지 에서만 허용 됩니다.</target>
        </trans-unit>
        <trans-unit id="78f90a10d8180ed5dc542d1b277136194356a682" translate="yes" xml:space="preserve">
          <source>A construct that performs something repeatedly, like a roller coaster.</source>
          <target state="translated">롤러 코스터와 같이 무언가를 반복적으로 수행하는 구조.</target>
        </trans-unit>
        <trans-unit id="98c376c5464a7cbd0f7597422425141a29b3dc1e" translate="yes" xml:space="preserve">
          <source>A construct that sometimes looks like a function but really isn&amp;rsquo;t. Usually reserved for &lt;b&gt;lvalue&lt;/b&gt; modifiers like &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt;, for &lt;b&gt;context&lt;/b&gt; modifiers like &lt;code&gt;&lt;a href=&quot;functions/scalar&quot;&gt;scalar&lt;/a&gt;&lt;/code&gt;, and for the pick-your-own-quotes constructs, &lt;code&gt;&lt;a href=&quot;functions/q&quot;&gt;q//&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/qq&quot;&gt;qq//&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/qx&quot;&gt;qx//&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/qw&quot;&gt;qw//&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m//&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/y&quot;&gt;y///&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr///&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">때때로 함수처럼 보이지만 실제로는 그렇지 않은 구문. 일반적으로 다음 과 같은 &lt;b&gt;lvalue&lt;/b&gt; 수정 &lt;b&gt;자용&lt;/b&gt; 으로 예약되어 있습니다. &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/scalar&quot;&gt;scalar&lt;/a&gt;&lt;/code&gt; 같은&lt;b&gt; 컨텍스트&lt;/b&gt; 수정 자및 pick-your-own-quotes 구문, &lt;code&gt;&lt;a href=&quot;functions/q&quot;&gt;q//&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/qq&quot;&gt;qq//&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/qx&quot;&gt;qx//&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/qw&quot;&gt;qw//&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m//&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/y&quot;&gt;y///&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr///&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="806f6b00b71ddb7f8c4ade43c00b3953a355f7bd" translate="yes" xml:space="preserve">
          <source>A construct that sometimes looks like a function but really isn&amp;rsquo;t. Usually reserved for &lt;b&gt;lvalue&lt;/b&gt; modifiers like &lt;code&gt;my&lt;/code&gt;, for &lt;b&gt;context&lt;/b&gt; modifiers like &lt;code&gt;scalar&lt;/code&gt;, and for the pick-your-own-quotes constructs, &lt;code&gt;q//&lt;/code&gt;, &lt;code&gt;qq//&lt;/code&gt;, &lt;code&gt;qx//&lt;/code&gt;, &lt;code&gt;qw//&lt;/code&gt;, &lt;code&gt;qr//&lt;/code&gt;, &lt;code&gt;m//&lt;/code&gt;, &lt;code&gt;s///&lt;/code&gt;, &lt;code&gt;y///&lt;/code&gt;, and &lt;code&gt;tr///&lt;/code&gt;.</source>
          <target state="translated">때때로 함수처럼 보이지만 실제로는 그렇지 않은 구조. 일반적으로 &lt;code&gt;my&lt;/code&gt; 와 같은 &lt;b&gt;lvalue&lt;/b&gt; 수정 자 , &lt;code&gt;scalar&lt;/code&gt; 와 같은 &lt;b&gt;컨텍스트&lt;/b&gt; 수정 자 및 사용자가 직접 따옴표를 선택하는 구문 인 &lt;code&gt;q//&lt;/code&gt; , &lt;code&gt;qq//&lt;/code&gt; , &lt;code&gt;qx//&lt;/code&gt; , &lt;code&gt;qw//&lt;/code&gt; , &lt;code&gt;qr//&lt;/code&gt; , &lt;code&gt;m//&lt;/code&gt; , &lt;code&gt;s///&lt;/code&gt; , &lt;code&gt;y///&lt;/code&gt; 및 &lt;code&gt;tr///&lt;/code&gt; .&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="b8552f673941f3d1978946011be4253061336584" translate="yes" xml:space="preserve">
          <source>A contact email address for the author/maintainer</source>
          <target state="translated">작성자 / 유지 업체의 연락처 이메일 주소</target>
        </trans-unit>
        <trans-unit id="1e9afcf85fc0132156a56c6d8cb4ffccff6b369d" translate="yes" xml:space="preserve">
          <source>A convenience function which combines creating an object and calling &lt;code&gt;isa_ok()&lt;/code&gt; on that object.</source>
          <target state="translated">객체 생성과 해당 객체에서 &lt;code&gt;isa_ok()&lt;/code&gt; 호출을 결합하는 편리한 함수입니다 .</target>
        </trans-unit>
        <trans-unit id="53128330b7badc08928ea23290fdacf578eb391d" translate="yes" xml:space="preserve">
          <source>A convenience variable which is typically used with &lt;code&gt;SvPV&lt;/code&gt; when one doesn't care about the length of the string. It is usually more efficient to either declare a local variable and use that instead or to use the &lt;code&gt;SvPV_nolen&lt;/code&gt; macro.</source>
          <target state="translated">문자열의 길이를 신경 쓰지 않을 때 일반적으로 &lt;code&gt;SvPV&lt;/code&gt; 와 함께 사용되는 편의 변수입니다 . 일반적으로 로컬 변수를 선언하고 대신 사용하거나 &lt;code&gt;SvPV_nolen&lt;/code&gt; 매크로 를 사용하는 것이 더 효율적 입니다.</target>
        </trans-unit>
        <trans-unit id="df5714f0f92eb562b41f83c46ccd5b057e98cc38" translate="yes" xml:space="preserve">
          <source>A convenient shortcut to operating on even-sized lists of pairs, this function returns a list of &lt;code&gt;ARRAY&lt;/code&gt; references, each containing two items from the given list. It is a more efficient version of</source>
          <target state="translated">짝수 크기의 쌍 목록 작업에 대한 편리한 바로 가기 인이 함수는 주어진 목록의 두 항목을 각각 포함하는 &lt;code&gt;ARRAY&lt;/code&gt; 참조 목록을 반환 합니다. 보다 효율적인 버전입니다.</target>
        </trans-unit>
        <trans-unit id="638f854b99669da73bce286ea189e697af8d4b5f" translate="yes" xml:space="preserve">
          <source>A convenient shortcut to operating on even-sized lists of pairs, this function returns a list of ARRAY references, each containing two items from the given list. It is a more efficient version of</source>
          <target state="translated">짝수 크기의 쌍 목록에서 작동하는 편리한 바로 가기 인이 함수는 주어진 목록에서 각각 2 개의 항목을 포함하는 ARRAY 참조 목록을 반환합니다. 보다 효율적인 버전입니다</target>
        </trans-unit>
        <trans-unit id="1166e931ea27a942799d52c7c1f3e445e7d6efa2" translate="yes" xml:space="preserve">
          <source>A convenient shortcut to operating on even-sized lists of pairs, this function returns a list of the the first values of each of the pairs in the given list. It is a more efficient version of</source>
          <target state="translated">짝수 크기의 쌍 목록에서 작동하는 편리한 바로 가기 인이 함수는 주어진 목록에서 각 쌍의 첫 번째 값 목록을 반환합니다. 보다 효율적인 버전입니다</target>
        </trans-unit>
        <trans-unit id="0dbcf107b79ffefab41fba2fbb5cf9a734cd1746" translate="yes" xml:space="preserve">
          <source>A convenient shortcut to operating on even-sized lists of pairs, this function returns a list of the the second values of each of the pairs in the given list. It is a more efficient version of</source>
          <target state="translated">짝수 크기의 쌍 목록에서 작동하는 편리한 바로 가기 인이 함수는 주어진 목록에서 각 쌍의 두 번째 값 목록을 반환합니다. 보다 효율적인 버전입니다</target>
        </trans-unit>
        <trans-unit id="77f68a02d61a77d7eed2d175da1b876e8aceace1" translate="yes" xml:space="preserve">
          <source>A convenient way to set up your tests. Call this and Test::Builder will print the appropriate headers and take the appropriate actions.</source>
          <target state="translated">테스트를 설정하는 편리한 방법입니다. 이것을 호출하면 Test :: Builder가 적절한 헤더를 인쇄하고 적절한 조치를 취합니다.</target>
        </trans-unit>
        <trans-unit id="d87e8f492879ce02bf236daf94692483d0fd4b5c" translate="yes" xml:space="preserve">
          <source>A conventional (not inside-out) implementation where an object is a hash that stores the field values, without support by &lt;code&gt;Hash::Util::FieldHash&lt;/code&gt; . This implementation doesn't allow arbitrary inheritance.</source>
          <target state="translated">객체가 &lt;code&gt;Hash::Util::FieldHash&lt;/code&gt; 지원없이 필드 값을 저장하는 해시 인 일반적인 내부 구현이 아닌 구현 입니다. 이 구현은 임의의 상속을 허용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e03c6ee9246ced2486b144fcb4c37588f21f6f7f" translate="yes" xml:space="preserve">
          <source>A conventional (not inside-out) implementation where an object is a hash that stores the field values, without support by &lt;code&gt;Hash::Util::FieldHash&lt;/code&gt;. This implementation doesn't allow arbitrary inheritance.</source>
          <target state="translated">객체가 &lt;code&gt;Hash::Util::FieldHash&lt;/code&gt; 지원없이 필드 값을 저장하는 해시 인 기존 (인사이드 아웃 아님) 구현 입니다. 이 구현은 임의의 상속을 허용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="646b8162acfbdd090f426555f4c9a32ee73eeb01" translate="yes" xml:space="preserve">
          <source>A copy of IO::Scalar for Test::Builder</source>
          <target state="translated">Test :: Builder의 IO :: Scalar 사본</target>
        </trans-unit>
        <trans-unit id="5a070156d8ac581b1ec13fda608b6d3f5d95a087" translate="yes" xml:space="preserve">
          <source>A copy of a Win* viewer is contained in the &quot;Just add OS/2 Warp&quot; package</source>
          <target state="translated">Win * 뷰어 사본은 &quot;Just add OS / 2 Warp&quot;패키지에 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="6e407ab7758af4150015ce0b8baf63576cf02a27" translate="yes" xml:space="preserve">
          <source>A copyright notice - see below.</source>
          <target state="translated">저작권 고지-아래를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="d687cc7b81ffa630de399555f3a224dda7b56cfa" translate="yes" xml:space="preserve">
          <source>A correct CPAN version number is a floating point number with at least 2 digits after the decimal. You can test whether it conforms to CPAN by using</source>
          <target state="translated">올바른 CPAN 버전 번호는 소수점 이하 2 자리 이상의 부동 소수점 숫자입니다. CPAN을 준수하는지 테스트하여 다음을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8295d6831975ca50ed9530db07dca19a25c715be" translate="yes" xml:space="preserve">
          <source>A count passed to Tpad to modify the padding applied to the output string. If $cnt is zero or one then the resulting string will be cached.</source>
          <target state="translated">출력 문자열에 적용된 패딩을 수정하기 위해 Tpad에 전달 된 수입니다. $ cnt가 0 또는 1이면 결과 문자열이 캐시됩니다.</target>
        </trans-unit>
        <trans-unit id="3ca2814f3e720b9b1b346f0c76354ef75ff06f2d" translate="yes" xml:space="preserve">
          <source>A crude table of contents for the Perl manpage set is found in &lt;a href=&quot;http://search.cpan.org/perldoc/perltoc&quot;&gt;perltoc&lt;/a&gt;.</source>
          <target state="translated">Perl 맨 페이지 세트에 대한 조잡한 목차는 &lt;a href=&quot;http://search.cpan.org/perldoc/perltoc&quot;&gt;perltoc에&lt;/a&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="2162bc552d862ed6307a58382e17717e6d290a61" translate="yes" xml:space="preserve">
          <source>A crude table of contents for the Perl manpage set is found in &lt;a href=&quot;perltoc&quot;&gt;perltoc&lt;/a&gt;.</source>
          <target state="translated">Perl 맨 페이지 세트에 대한 조잡한 목차는 &lt;a href=&quot;perltoc&quot;&gt;perltoc에&lt;/a&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="03adc2f14ebb3d0a7a9ba21528d13d42030133f9" translate="yes" xml:space="preserve">
          <source>A data debugging tool for the XS programmer</source>
          <target state="translated">XS 프로그래머를위한 데이터 디버깅 도구</target>
        </trans-unit>
        <trans-unit id="07e1664c3b50241d29a1670852c2daa101e50db7" translate="yes" xml:space="preserve">
          <source>A data repository. Instead of computing expensive answers several times, compute it once and save the result.</source>
          <target state="translated">데이터 저장소. 값 비싼 답변을 여러 번 계산하는 대신 한 번 계산하여 결과를 저장하십시오.</target>
        </trans-unit>
        <trans-unit id="40b9a92df275c1cef5fb6a4e3d00cf2b3d4203b3" translate="yes" xml:space="preserve">
          <source>A data structure used internally by Perl for implementing associative arrays (hashes) efficiently. See also &lt;b&gt;bucket&lt;/b&gt;.</source>
          <target state="translated">연관 배열 (해시)을 효율적으로 구현하기 위해 Perl에서 내부적으로 사용하는 데이터 구조입니다. &lt;b&gt;bucket&lt;/b&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b6431d472e1b30028a75ba55229126e2e191ae3c" translate="yes" xml:space="preserve">
          <source>A declaration can be put anywhere a statement can, but has no effect on the execution of the primary sequence of statements: declarations all take effect at compile time. All declarations are typically put at the beginning or the end of the script. However, if you're using lexically-scoped private variables created with &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/state&quot;&gt;state()&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our()&lt;/a&gt;&lt;/code&gt;, you'll have to make sure your format or subroutine definition is within the same block scope as the my if you expect to be able to access those private variables.</source>
          <target state="translated">선언은 명령문이 할 수있는 어느 곳에 나 배치 할 수 있지만, 기본 명령문 시퀀스 실행에는 영향을 미치지 않습니다. 선언은 모두 컴파일시 적용됩니다. 모든 선언은 일반적으로 스크립트의 시작 또는 끝에 있습니다. 그러나 &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my()&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/state&quot;&gt;state()&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our()&lt;/a&gt;&lt;/code&gt; 만든 어휘 범위 개인 변수를 사용하는 경우 형식 또는 서브 루틴 정의가 my if와 동일한 블록 범위 내에 있는지 확인해야합니다 개인 변수에 액세스 할 수있을 것으로 기대합니다.</target>
        </trans-unit>
        <trans-unit id="07181764640c06f85b9c3b200709c9c9e50a1f77" translate="yes" xml:space="preserve">
          <source>A declaration can be put anywhere a statement can, but has no effect on the execution of the primary sequence of statements: declarations all take effect at compile time. All declarations are typically put at the beginning or the end of the script. However, if you're using lexically-scoped private variables created with &lt;code&gt;my()&lt;/code&gt;, &lt;code&gt;state()&lt;/code&gt;, or &lt;code&gt;our()&lt;/code&gt;, you'll have to make sure your format or subroutine definition is within the same block scope as the my if you expect to be able to access those private variables.</source>
          <target state="translated">선언은 명령문이 할 수있는 곳에 둘 수 있지만 명령문의 기본 시퀀스 실행에는 영향을주지 않습니다. 선언은 모두 컴파일 타임에 적용됩니다. 모든 선언은 일반적으로 스크립트의 시작 또는 끝에 배치됩니다. 그러나 &lt;code&gt;my()&lt;/code&gt; , &lt;code&gt;state()&lt;/code&gt; 또는 &lt;code&gt;our()&lt;/code&gt; 생성 된 어휘 범위 개인 변수를 사용하는 경우 형식 또는 서브 루틴 정의가 my와 동일한 블록 범위 내에 있는지 확인해야합니다. 이러한 개인 변수에 액세스 할 수 있기를 기대합니다.</target>
        </trans-unit>
        <trans-unit id="753d1d91d799e4e070ffae305c67c5e3d698281a" translate="yes" xml:space="preserve">
          <source>A default hashing algorithm, which will be adequate for most applications, is built into Berkeley DB. If you do need to use your own hashing algorithm it is possible to write your own in Perl and have &lt;b&gt;DB_File&lt;/b&gt; use it instead.</source>
          <target state="translated">대부분의 응용 프로그램에 적합한 기본 해싱 알고리즘이 Berkeley DB에 내장되어 있습니다. 자체 해싱 알고리즘을 사용해야하는 경우 Perl로 직접 작성 하고 대신 &lt;b&gt;DB_File을&lt;/b&gt; 사용하도록 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b9828da4e803d376a194bd30931557a328ae046c" translate="yes" xml:space="preserve">
          <source>A default site INSTALL.SKIP may be provided by setting then environment variable EU_INSTALL_SITE_SKIPFILE, this will only be used when there isn't a distribution specific INSTALL.SKIP. If the environment variable EU_INSTALL_IGNORE_SKIP is true then no install file filtering will be performed.</source>
          <target state="translated">환경 변수 EU_INSTALL_SITE_SKIPFILE을 설정하여 기본 사이트 INSTALL.SKIP를 제공 할 수 있습니다. 이는 분배 특정 INSTALL.SKIP가없는 경우에만 사용됩니다. 환경 변수 EU_INSTALL_IGNORE_SKIP가 true 인 경우 설치 파일 필터링이 수행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0e649d4a2c7d23eccbd6705217dd0baed80106ea" translate="yes" xml:space="preserve">
          <source>A deferred action like this:</source>
          <target state="translated">다음과 같은 지연된 조치 :</target>
        </trans-unit>
        <trans-unit id="3f6d365313b0491e7a9d65439f28a847ca8b2399" translate="yes" xml:space="preserve">
          <source>A deprecated property may also be stabilized, but this fact is not shown.</source>
          <target state="translated">더 이상 사용되지 않는 속성도 안정화 될 수 있지만이 사실은 표시되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="deb6a6e39c30f33cc261f9965991eae25b915199" translate="yes" xml:space="preserve">
          <source>A deprecated property may be made unavailable in a future Perl version, so it is best to move away from them.</source>
          <target state="translated">더 이상 사용되지 않는 속성은 향후 Perl 버전에서 사용할 수 없게 될 수 있으므로 해당 속성에서 벗어나는 것이 가장 좋습니다.</target>
        </trans-unit>
        <trans-unit id="c7b7b32d1f43857ac978062d5529fcaa75b008c1" translate="yes" xml:space="preserve">
          <source>A description of how C types may be transformed to and from Perl types within an &lt;b&gt;extension&lt;/b&gt; module written in &lt;b&gt;XS&lt;/b&gt;.</source>
          <target state="translated">&lt;b&gt;XS로&lt;/b&gt; 작성된 &lt;b&gt;확장&lt;/b&gt; 모듈 내에서 C 유형을 Perl 유형으로 변환하거나 변환하는 방법에 대한 설명 .&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="152e62c7af6a3030011c43a7ed3a060f156647cc" translate="yes" xml:space="preserve">
          <source>A description of the callable function in each module</source>
          <target state="translated">각 모듈에서 호출 가능한 함수에 대한 설명</target>
        </trans-unit>
        <trans-unit id="a361777f63c2dac8a5f187498445ea69ff2e5fd2" translate="yes" xml:space="preserve">
          <source>A description of the module/package/extension etc.</source>
          <target state="translated">모듈 / 패키지 / 확장 등에 대한 설명</target>
        </trans-unit>
        <trans-unit id="2d3ff2a56a13511ba72ba40a6fa6a2c401a75cdb" translate="yes" xml:space="preserve">
          <source>A detailed document on Encode and PerlIO</source>
          <target state="translated">Encode 및 PerlIO에 대한 자세한 문서</target>
        </trans-unit>
        <trans-unit id="6acb6151fda2f69cbd4a7ea5c8537d8c57875e5a" translate="yes" xml:space="preserve">
          <source>A device you can put things on the top of, and later take them back off in the opposite order in which you put them on. See &lt;b&gt;LIFO&lt;/b&gt;.</source>
          <target state="translated">물건을 맨 위에 놓을 수 있고 나중에 반대 방향으로 다시 놓을 수있는 장치입니다. &lt;b&gt;LIFO를&lt;/b&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ce6d3879a0b885e4f02b96959f6d870d8f5b1fa8" translate="yes" xml:space="preserve">
          <source>A different approach is to autoload seldom-used Perl code. See the AutoSplit and AutoLoader modules in the standard distribution for that. Or you could locate the bottleneck and think about writing just that part in C, the way we used to take bottlenecks in C code and write them in assembler. Similar to rewriting in C, modules that have critical sections can be written in C (for instance, the PDL module from CPAN).</source>
          <target state="translated">다른 방법은 거의 사용하지 않는 Perl 코드를 자동로드하는 것입니다. 표준 배포판에서 AutoSplit 및 AutoLoader 모듈을 참조하십시오. 또는 병목 현상을 찾아 C 코드에서 병목 현상을 발생시키고 어셈블러에서 작성하는 방식 인 C로 해당 부분을 작성하는 방법을 생각할 수 있습니다. C에서 다시 쓰는 것과 마찬가지로 중요한 섹션이있는 모듈을 C로 작성할 수 있습니다 (예 : CPAN의 PDL 모듈).</target>
        </trans-unit>
        <trans-unit id="fd02787c52da0901c066d4ccff09232fd888e22e" translate="yes" xml:space="preserve">
          <source>A different type of portability issue arises when writing XS code: availability of a C compiler on the end-user's system. C brings with it its own portability issues, and writing XS code will expose you to some of those. Writing purely in Perl is an easier way to achieve portability.</source>
          <target state="translated">XS 코드를 작성할 때 다른 유형의 이식성 문제가 발생합니다. 최종 사용자 시스템에서 C 컴파일러의 가용성입니다. C에는 자체 이식성 문제가 있으며 XS 코드를 작성하면 그 중 일부에 노출됩니다. Perl로 순수하게 작성하는 것이 이식성을 얻는 쉬운 방법입니다.</target>
        </trans-unit>
        <trans-unit id="7549e9114a09a619af3acd4b50c3c4a53ce35871" translate="yes" xml:space="preserve">
          <source>A direct &lt;b&gt;connection&lt;/b&gt; that carries the output of one &lt;b&gt;process&lt;/b&gt; to the input of another without an intermediate temporary file. Once the pipe is set up, the two processes in question can read and write as if they were talking to a normal file, with some caveats.</source>
          <target state="translated">하나의 &lt;b&gt;프로세스&lt;/b&gt; 출력을 전달 하는 직접 &lt;b&gt;연결&lt;/b&gt;&lt;b&gt;&lt;/b&gt;중간 임시 파일없이 의 입력으로 . 파이프가 설정되면 문제의 두 프로세스가 정상적인 파일과 대화하고있는 것처럼 읽고 쓸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4b845b5f598804539b9d3429d1e0dde292769ef5" translate="yes" xml:space="preserve">
          <source>A distribution of modules to handle locale codes</source>
          <target state="translated">로캘 코드를 처리하기위한 모듈 배포</target>
        </trans-unit>
        <trans-unit id="36dbba4844dbb20711f751da227a18044b073c86" translate="yes" xml:space="preserve">
          <source>A distribution's original author is usually the contact listed within this field. Co-maintainers, successor maintainers or mailing lists devoted to the distribution may also be listed in addition to or instead of the original author.</source>
          <target state="translated">배포본의 원래 작성자는 일반적으로이 필드에 나열된 연락처입니다. 공동 관리자, 후임 관리자 또는 배포에 전념하는 메일 링 목록은 원본 작성자와 함께 또는 대신에 나열 될 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="3e6b7ccc64e5147f1acc2484c6d3b919c5bc2282" translate="yes" xml:space="preserve">
          <source>A document having more than one &quot;=encoding&quot; line should be considered an error. Pod processors may silently tolerate this if the not-first &quot;=encoding&quot; lines are just duplicates of the first one (e.g., if there's a &quot;=encoding utf8&quot; line, and later on another &quot;=encoding utf8&quot; line). But Pod processors should complain if there are contradictory &quot;=encoding&quot; lines in the same document (e.g., if there is a &quot;=encoding utf8&quot; early in the document and &quot;=encoding big5&quot; later). Pod processors that recognize BOMs may also complain if they see an &quot;=encoding&quot; line that contradicts the BOM (e.g., if a document with a UTF-16LE BOM has an &quot;=encoding shiftjis&quot; line).</source>
          <target state="translated">&quot;= 인코딩&quot;줄이 둘 이상인 문서는 오류로 간주해야합니다. 포드 프로세서가 아닌 첫 번째 &quot;= 인코딩&quot;행이 첫 번째 행의 복제 본인 경우 (예 : &quot;= 인코딩 utf8&quot;행이 있고 나중에 다른 &quot;= 인코딩 utf8&quot;행에있는 경우) 포드 프로세서는 자동으로이를 허용 할 수 있습니다. 그러나 포드 프로세서는 동일한 문서에 모순되는 &quot;= 인코딩&quot;행이있는 경우 (예 : 문서의 초기에 &quot;= 인코딩 utf8&quot;이 있고 나중에 &quot;= 인코딩 big5&quot;인 경우) 불만을 제기해야합니다. BOM을 인식하는 포드 프로세서는 BOM과 모순되는 &quot;= 인코딩&quot;행이 표시 될 경우 (예 : UTF-16LE BOM이있는 문서에 &quot;= 인코딩 시프트 지&quot;행이있는 경우) 불만을 제기 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4df78e410296e2b3f4b712de1ae484fe7cd130b2" translate="yes" xml:space="preserve">
          <source>A document type tag for the file. This option is not set by default.</source>
          <target state="translated">파일의 문서 유형 태그입니다. 이 옵션은 기본적으로 설정되어 있지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d80c6e485dc27886043d9d72950290e87158018b" translate="yes" xml:space="preserve">
          <source>A domain of names. You needn&amp;rsquo;t worry about whether the names in one such domain have been used in another. See &lt;b&gt;package&lt;/b&gt;.</source>
          <target state="translated">이름의 도메인. 한 도메인의 이름이 다른 도메인의 이름에 사용되었는지 여부에 대해 걱정할 필요가 없습니다. &lt;b&gt;package를&lt;/b&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="7598f11ff5b1103678a9d5639c3dfc75e6d4a5e6" translate="yes" xml:space="preserve">
          <source>A double precision floating point number. This typemap guarantees to return a variable cast to a &lt;code&gt;double&lt;/code&gt; .</source>
          <target state="translated">배정 밀도 부동 소수점 숫자 이 타입 맵은 변수 캐스트를 &lt;code&gt;double&lt;/code&gt; 로 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="3f284c3eb8e2f99c285a6237d4bc92dc027b78cd" translate="yes" xml:space="preserve">
          <source>A double precision floating point number. This typemap guarantees to return a variable cast to a &lt;code&gt;double&lt;/code&gt;.</source>
          <target state="translated">배정 밀도 부동 소수점 숫자입니다. 이 타입 맵은 변수 캐스트를 &lt;code&gt;double&lt;/code&gt; 로 반환하도록 보장합니다 .</target>
        </trans-unit>
        <trans-unit id="102050331265d60ae1056cdc3a0d24fd9e06376e" translate="yes" xml:space="preserve">
          <source>A double-quoted, interpolated string.</source>
          <target state="translated">큰 따옴표로 묶어 보간 된 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="faeb399a5d08eaa739b873af03a2a402dd907834" translate="yes" xml:space="preserve">
          <source>A dummy layer which never exists on the layer stack. Instead when &quot;pushed&quot; it actually pops the stack removing itself, it then calls Binmode function table entry on all the layers in the stack - normally this (via PerlIOBase_binmode) removes any layers which do not have &lt;code&gt;PERLIO_K_RAW&lt;/code&gt; bit set. Layers can modify that behaviour by defining their own Binmode entry.</source>
          <target state="translated">레이어 스택에 존재하지 않는 더미 레이어. 대신에 &quot;푸시&quot;된 경우 실제로 스택 자체가 제거되어 팝업에서 스택의 모든 레이어에 대해 Binmode 함수 테이블 항목을 호출합니다. 일반적으로 PerlIOBase_binmode를 통해 &lt;code&gt;PERLIO_K_RAW&lt;/code&gt; 비트가 설정 되지 않은 모든 레이어를 제거합니다 . 레이어는 자체 Binmode 항목을 정의하여 해당 동작을 수정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f90a52847d42c09984d572f3b595cda347017f00" translate="yes" xml:space="preserve">
          <source>A failed match or changing the target string resets the position. If you don't want the position reset after failure to match, add the &lt;code&gt;//c&lt;/code&gt; , as in &lt;code&gt;/regex/gc&lt;/code&gt; .</source>
          <target state="translated">일치하지 않거나 대상 문자열을 변경하면 위치가 재설정됩니다. 실패한 후 위치를 재설정하지 않으려면 &lt;code&gt;/regex/gc&lt;/code&gt; 와 같이 &lt;code&gt;//c&lt;/code&gt; 를 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="d5efee2d4f79d8ba35cf758e77756920ee770903" translate="yes" xml:space="preserve">
          <source>A failed match or changing the target string resets the position. If you don't want the position reset after failure to match, add the &lt;code&gt;//c&lt;/code&gt; , as in &lt;code&gt;/regexp/gc&lt;/code&gt; . The current position in the string is associated with the string, not the regexp. This means that different strings have different positions and their respective positions can be set or read independently.</source>
          <target state="translated">일치하지 않거나 대상 문자열을 변경하면 위치가 재설정됩니다. 실패 후 위치 재설정을 원하지 않으면 &lt;code&gt;/regexp/gc&lt;/code&gt; 에서와 같이 &lt;code&gt;//c&lt;/code&gt; 를 추가하십시오 . 문자열의 현재 위치는 정규 표현식이 아닌 문자열과 연결됩니다. 이것은 다른 스트링이 다른 위치를 가지며 각각의 위치가 독립적으로 설정되거나 읽힐 수 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="7f27a18129c02d053ab6f802e18b05e35c62f037" translate="yes" xml:space="preserve">
          <source>A failed match or changing the target string resets the position. If you don't want the position reset after failure to match, add the &lt;code&gt;/c&lt;/code&gt;, as in &lt;code&gt;/regex/gc&lt;/code&gt;.</source>
          <target state="translated">일치하지 않거나 대상 문자열을 변경하면 위치가 재설정됩니다. 일치 실패 후 위치 재설정을 원하지 않는 경우 &lt;code&gt;/regex/gc&lt;/code&gt; 에서와 같이 &lt;code&gt;/c&lt;/code&gt; 를 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="b67a945b29a3d1fe6def81e71ffaffd29e4c4803" translate="yes" xml:space="preserve">
          <source>A failed match or changing the target string resets the position. If you don't want the position reset after failure to match, add the &lt;code&gt;/c&lt;/code&gt;, as in &lt;code&gt;/regexp/gc&lt;/code&gt;. The current position in the string is associated with the string, not the regexp. This means that different strings have different positions and their respective positions can be set or read independently.</source>
          <target state="translated">일치하지 않거나 대상 문자열을 변경하면 위치가 재설정됩니다. 일치 실패 후 위치 재설정을 원하지 않는 경우 &lt;code&gt;/regexp/gc&lt;/code&gt; 에서와 같이 &lt;code&gt;/c&lt;/code&gt; 를 추가하십시오 . 문자열의 현재 위치는 정규 표현식이 아닌 문자열과 연결됩니다. 이것은 서로 다른 문자열이 서로 다른 위치를 가지며 각각의 위치를 ​​독립적으로 설정하거나 읽을 수 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="656a7d55b2753fa751b87d85db4a4654a61963c4" translate="yes" xml:space="preserve">
          <source>A fairly common feature in applications is to allow you to define a C function that will be called whenever something nasty occurs. What we would like is to be able to specify a Perl subroutine that will be called instead.</source>
          <target state="translated">응용 프로그램에서 상당히 일반적인 기능은 문제가 발생할 때마다 호출되는 C 함수를 정의 할 수 있도록하는 것입니다. 우리가 원하는 것은 대신 호출 될 Perl 서브 루틴을 지정할 수있는 것입니다.</target>
        </trans-unit>
        <trans-unit id="4373b47dc81d066ae69b5e362fdbfdc644e26aed" translate="yes" xml:space="preserve">
          <source>A fairly common use-case is where compressed data is embedded in a larger file/buffer and you want to read both.</source>
          <target state="translated">상당히 일반적인 사용 사례는 압축 된 데이터가 더 큰 파일 / 버퍼에 포함되어 있고 둘 다 읽으려는 경우입니다.</target>
        </trans-unit>
        <trans-unit id="e23193c87a7c196063bf7501e9b39457a40a9ece" translate="yes" xml:space="preserve">
          <source>A faithful representation of the value used to initialize this version object. The only time this will not be precisely the same characters that exist in the source file is if a short dotted-decimal version like v1.2 was used (in which case it will contain 'v1.2'). This form is &lt;b&gt;STRONGLY&lt;/b&gt; discouraged, in that it will confuse you and your users.</source>
          <target state="translated">이 버전 객체를 초기화하는 데 사용되는 값의 충실한 표현입니다. 소스 파일에 존재하는 문자와 정확히 일치하지 않는 유일한 경우는 v1.2와 같은 점으로 구분 된 짧은 10 진수 버전이 사용 된 경우입니다 (이 경우 'v1.2'가 포함됨). 이 양식은있다 &lt;b&gt;강력히&lt;/b&gt; 은 당신과 당신의 사용자를 혼란스럽게한다는 점에서 실망.</target>
        </trans-unit>
        <trans-unit id="145432bffd79619206143de90cf2e154ae94a2c3" translate="yes" xml:space="preserve">
          <source>A false value, in scalar context</source>
          <target state="translated">스칼라 컨텍스트에서 거짓 값</target>
        </trans-unit>
        <trans-unit id="e27669facce8e75680a82515ceb4a7dde4554488" translate="yes" xml:space="preserve">
          <source>A fancy computer science term meaning &amp;ldquo;to follow a &lt;b&gt;reference&lt;/b&gt; to what it points to&amp;rdquo;. The &amp;ldquo;de&amp;rdquo; part of it refers to the fact that you&amp;rsquo;re taking away one level of &lt;b&gt;indirection&lt;/b&gt;.</source>
          <target state="translated">&amp;ldquo; 이것이 가리키는 것을 &lt;b&gt;참조&lt;/b&gt; 하는 것 &amp;rdquo;을 의미하는 멋진 컴퓨터 과학 용어 . 그것의 &quot;de&quot;부분은 당신이 한 수준의 &lt;b&gt;간접적&lt;/b&gt; 인 &lt;b&gt;태도를&lt;/b&gt; 취하고 있다는 사실을 말합니다 .</target>
        </trans-unit>
        <trans-unit id="8f4dde098cc45c330d3e8fa85a502fc0eae6cde3" translate="yes" xml:space="preserve">
          <source>A fancy kind of interlock that prevents multiple &lt;b&gt;threads&lt;/b&gt; or &lt;b&gt;processes&lt;/b&gt; from using up the same resources simultaneously.</source>
          <target state="translated">여러 &lt;b&gt;스레드&lt;/b&gt; 또는 &lt;b&gt;프로세스&lt;/b&gt; 가 동일한 리소스를 동시에 사용 하지 못하게하는 멋진 종류의 인터록입니다 .</target>
        </trans-unit>
        <trans-unit id="2f52178a4e9cc243237404e962bb98cf1d11d03e" translate="yes" xml:space="preserve">
          <source>A fancy term for an error. See &lt;b&gt;fatal error&lt;/b&gt;.</source>
          <target state="translated">오류에 대한 멋진 용어. &lt;b&gt;치명적인 오류를&lt;/b&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d130552cd3247973054cf88d786bc01b68b3a6e5" translate="yes" xml:space="preserve">
          <source>A fatal error will be thrown if the Compress::Zlib module is not available.</source>
          <target state="translated">Compress :: Zlib 모듈을 사용할 수 없으면 치명적인 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="c1f172aa731045204a1719d56bb2cc8625060274" translate="yes" xml:space="preserve">
          <source>A fatal error will be thrown if:</source>
          <target state="translated">다음과 같은 경우 치명적인 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="206dcfa56d21a53d3ca90835f2da1335f0ce9141" translate="yes" xml:space="preserve">
          <source>A feature of &lt;b&gt;operator overloading&lt;/b&gt; of &lt;b&gt;objects&lt;/b&gt;, whereby the behavior of certain &lt;b&gt;operators&lt;/b&gt; can be reasonably deduced using more fundamental operators. This assumes that the overloaded operators will often have the same relationships as the regular operators. See Camel chapter 13, &amp;ldquo;Overloading&amp;rdquo;.</source>
          <target state="translated">의 특징 &lt;b&gt;연산자 오버로딩&lt;/b&gt; 의 &lt;b&gt;객체&lt;/b&gt; 특정의 동작함으로써, &lt;b&gt;운영자가&lt;/b&gt; 합리적으로 더 근본적인 연산자를 사용하여 추론 할 수있다. 이것은 오버로드 된 연산자가 종종 일반 연산자와 동일한 관계를 갖는 것으로 가정합니다. 낙타 13 장 &quot;오버로딩&quot;을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="96f7456dc10c0f5e5c69de568de641b9d361467e" translate="yes" xml:space="preserve">
          <source>A few dir-vs-file optimizations result in glob importation being 10 times faster than using perlglob.exe, and using perlglob.bat is only twice as slow as perlglob.exe (GSAR 28-MAY-97)</source>
          <target state="translated">몇 가지 dir-vs-file 최적화는 perlglob.exe를 사용하는 것보다 글로브 가져 오기가 10 배 더 빠르며 perlglob.bat를 사용하는 것이 perlglob.exe보다 2 배 느립니다 (GSAR 28-MAY-97)</target>
        </trans-unit>
        <trans-unit id="29b977997a9e174d5b0509df5c6aa92021e1d1e4" translate="yes" xml:space="preserve">
          <source>A few example globmaps</source>
          <target state="translated">글로브 맵 예제</target>
        </trans-unit>
        <trans-unit id="4079515a56f3376aa599af18d3ce02d4fa762708" translate="yes" xml:space="preserve">
          <source>A few functions are not implemented because they are C specific. If you attempt to call these, they will print a message telling you that they aren't implemented, and suggest using the Perl equivalent, should one exist. For example, trying to access the &lt;code&gt;setjmp()&lt;/code&gt; call will elicit the message &quot;&lt;code&gt;setjmp() is C-specific: &lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; &lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; {} instead&lt;/code&gt; &quot;.</source>
          <target state="translated">일부 기능은 C에 고유하기 때문에 구현되지 않습니다. 이것을 호출하려고 시도하면 구현되지 않았 음을 알리는 메시지를 인쇄하고 Perl과 동등한 것을 사용하도록 제안합니다. 예를 들어, 액세스를 시도 &lt;code&gt;setjmp()&lt;/code&gt; 메시지 이끌어내는 것이다 전화를 &quot; &lt;code&gt;setjmp() is C-specific: &lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; &lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; {} instead&lt;/code&gt; &quot;.</target>
        </trans-unit>
        <trans-unit id="a9aa66452d6cc33fe8925436987e0f746352b862" translate="yes" xml:space="preserve">
          <source>A few functions are not implemented because they are C specific. If you attempt to call these, they will print a message telling you that they aren't implemented, and suggest using the Perl equivalent, should one exist. For example, trying to access the &lt;code&gt;setjmp()&lt;/code&gt; call will elicit the message &quot;&lt;code&gt;setjmp() is C-specific: use eval {} instead&lt;/code&gt;&quot;.</source>
          <target state="translated">일부 함수는 C에 따라 구현되지 않습니다. 이를 호출하려고하면 구현되지 않았 음을 알리는 메시지를 인쇄하고 해당하는 Perl을 사용할 것을 제안합니다. 예를 들어 &lt;code&gt;setjmp()&lt;/code&gt; 호출 에 액세스하려고하면 &quot; &lt;code&gt;setjmp() is C-specific: use eval {} instead&lt;/code&gt; &quot;라는 메시지가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="de0bccac60c0333be23e859b75e6846e6cbff2f2" translate="yes" xml:space="preserve">
          <source>A few functions take no arguments at all, and therefore work as neither unary nor list operators. These include such functions as &lt;a href=&quot;#time&quot;&gt;&lt;code&gt;time&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#endpwent&quot;&gt;&lt;code&gt;endpwent&lt;/code&gt;&lt;/a&gt;. For example, &lt;code&gt;time+86_400&lt;/code&gt; always means &lt;code&gt;time() + 86_400&lt;/code&gt;.</source>
          <target state="translated">일부 함수는 인수를 전혀 사용하지 않으므로 단항 또는 목록 연산자로 작동하지 않습니다. 여기에는 &lt;a href=&quot;#time&quot;&gt; &lt;code&gt;time&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#endpwent&quot;&gt; &lt;code&gt;endpwent&lt;/code&gt; &lt;/a&gt; 와 같은 함수가 포함됩니다 . 예를 들어, &lt;code&gt;time+86_400&lt;/code&gt; 은 항상 &lt;code&gt;time() + 86_400&lt;/code&gt; 의미 합니다 .</target>
        </trans-unit>
        <trans-unit id="dcd9feea0227978a722652bf64b2da3e239d9119" translate="yes" xml:space="preserve">
          <source>A few functions take no arguments at all, and therefore work as neither unary nor list operators. These include such functions as &lt;code&gt;&lt;a href=&quot;functions/time&quot;&gt;time&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/endpwent&quot;&gt;endpwent&lt;/a&gt;&lt;/code&gt;. For example, &lt;code&gt;&lt;a href=&quot;functions/time&quot;&gt;time+86_400&lt;/a&gt;&lt;/code&gt; always means &lt;code&gt;&lt;a href=&quot;functions/time&quot;&gt;time&lt;/a&gt;() + 86_400&lt;/code&gt; .</source>
          <target state="translated">일부 함수는 인수를 전혀 취하지 않으므로 단항 연산자 나 목록 연산자로 작동하지 않습니다. 여기에는 &lt;code&gt;&lt;a href=&quot;functions/time&quot;&gt;time&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;functions/endpwent&quot;&gt;endpwent&lt;/a&gt;&lt;/code&gt; 와 같은 기능이 포함됩니다 . 예를 들어 &lt;code&gt;&lt;a href=&quot;functions/time&quot;&gt;time+86_400&lt;/a&gt;&lt;/code&gt; 은 항상 &lt;code&gt;&lt;a href=&quot;functions/time&quot;&gt;time&lt;/a&gt;() + 86_400&lt;/code&gt; 의미 합니다 .</target>
        </trans-unit>
        <trans-unit id="18d4ec4509605bbb34d201f389b34f426f595148" translate="yes" xml:space="preserve">
          <source>A few general-purpose tools are shipped with perl, mostly because they came along modules included in the perl distribution.</source>
          <target state="translated">일부 범용 도구는 펄 배포판에 포함 된 모듈을 사용했기 때문에 펄과 함께 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="6c69ec260ad056301204f0c643b8c2696665eb7e" translate="yes" xml:space="preserve">
          <source>A few methods are provided to do the &lt;code&gt;&lt;a href=&quot;../../functions/use&quot;&gt;use&lt;/a&gt; Your::Module tests =&amp;gt; 23&lt;/code&gt; part for you.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../../functions/use&quot;&gt;use&lt;/a&gt; Your::Module tests =&amp;gt; 23&lt;/code&gt; 부분을 &lt;a href=&quot;../../functions/use&quot;&gt;사용&lt;/a&gt; 하기 위한 몇 가지 방법이 제공됩니다 .</target>
        </trans-unit>
        <trans-unit id="8472b15b35050b2df3090f934f689efe2217997e" translate="yes" xml:space="preserve">
          <source>A few methods are provided to do the &lt;code&gt;use Your::Module tests =&amp;gt; 23&lt;/code&gt; part for you.</source>
          <target state="translated">&lt;code&gt;use Your::Module tests =&amp;gt; 23&lt;/code&gt; part를 사용하기 위해 몇 가지 방법이 제공됩니다 .</target>
        </trans-unit>
        <trans-unit id="aa6d4c905f963b3015f8686516337be08979225b" translate="yes" xml:space="preserve">
          <source>A few more:</source>
          <target state="translated">몇 가지 더 :</target>
        </trans-unit>
        <trans-unit id="f6dd53866881999d8a6a377532c2c8626c21bab7" translate="yes" xml:space="preserve">
          <source>A few of the entries in the list below are marked as DEPRECATED. You should not use these for new code, and should be converting existing uses to use something better.</source>
          <target state="translated">아래 목록의 일부 항목은 DEPRECATED로 표시됩니다. 새로운 코드에 사용해서는 안되며, 더 나은 것을 사용하기 위해 기존 사용을 변환해야합니다. ㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ</target>
        </trans-unit>
        <trans-unit id="6eb9b3626d6aeb9e84350d1131ed3080f1617e37" translate="yes" xml:space="preserve">
          <source>A few of the options need extra discussion here. When used, the C equivalent of the keys &lt;code&gt;hash&lt;/code&gt; , &lt;code&gt;compare&lt;/code&gt; and &lt;code&gt;prefix&lt;/code&gt; store pointers to C functions. In &lt;b&gt;DB_File&lt;/b&gt; these keys are used to store references to Perl subs. Below are templates for each of the subs:</source>
          <target state="translated">몇 가지 옵션은 여기에서 추가 토론이 필요합니다. 사용될 때, 키의 C 당량 &lt;code&gt;hash&lt;/code&gt; , &lt;code&gt;compare&lt;/code&gt; 및 &lt;code&gt;prefix&lt;/code&gt; C 함수 포인터를 저장. 에서 &lt;b&gt;DB_File&lt;/b&gt; 이 키는 펄 잠수정에 대한 참조를 저장하는 데 사용됩니다. 아래는 각 서브에 대한 템플릿입니다.</target>
        </trans-unit>
        <trans-unit id="492f5e2fcdceaa8c5ab146c091e30572e3a68f3d" translate="yes" xml:space="preserve">
          <source>A few of the options need extra discussion here. When used, the C equivalent of the keys &lt;code&gt;hash&lt;/code&gt;, &lt;code&gt;compare&lt;/code&gt; and &lt;code&gt;prefix&lt;/code&gt; store pointers to C functions. In &lt;b&gt;DB_File&lt;/b&gt; these keys are used to store references to Perl subs. Below are templates for each of the subs:</source>
          <target state="translated">여기에서 몇 가지 옵션에 대해 추가 논의가 필요합니다. 사용되는 경우 키에 해당하는 C 는 C 함수에 대한 포인터를 &lt;code&gt;hash&lt;/code&gt; , &lt;code&gt;compare&lt;/code&gt; 및 &lt;code&gt;prefix&lt;/code&gt; 저장합니다. 에서 &lt;b&gt;DB_File&lt;/b&gt; 이 키는 펄 잠수정에 대한 참조를 저장하는 데 사용됩니다. 다음은 각 구독자에 대한 템플릿입니다.</target>
        </trans-unit>
        <trans-unit id="c283830e9199de7049f4c9e9b8481f0f4f024e4c" translate="yes" xml:space="preserve">
          <source>A few of these variables are considered &quot;read-only&quot;. This means that if you try to assign to this variable, either directly or indirectly through a reference, you'll raise a run-time exception.</source>
          <target state="translated">이러한 변수 중 일부는 &quot;읽기 전용&quot;으로 간주됩니다. 즉, 참조를 통해 직접 또는 간접적으로이 변수에 할당하려고하면 런타임 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="8090aa705fafbfcbe40caa6a39d4969f2ffa75f0" translate="yes" xml:space="preserve">
          <source>A few points to note about this example:</source>
          <target state="translated">이 예제에서주의해야 할 사항은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5940abb3e966e0e3ab0e5074976963a86d9bf337" translate="yes" xml:space="preserve">
          <source>A few special SV heads are not allocated from an arena, but are instead directly created in the interpreter structure, eg PL_sv_undef. The size of arenas can be changed from the default by setting PERL_ARENA_SIZE appropriately at compile time.</source>
          <target state="translated">몇몇 특수 SV 헤드는 경기장에서 할당되지 않지만 대신 인터프리터 구조 (예 : PL_sv_undef)에 직접 생성됩니다. 컴파일시 PERL_ARENA_SIZE를 적절하게 설정하여 경기장의 크기를 기본값에서 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="99bc1dc13c67f6154f44d88464d4083e5ca5c87d" translate="yes" xml:space="preserve">
          <source>A fifo is convenient when you want to connect a process to an unrelated one. When you open a fifo, the program will block until there's something on the other end.</source>
          <target state="translated">프로세스를 관련없는 프로세스에 연결하려는 경우 fifo가 편리합니다. fifo를 열면 다른 쪽 끝에 무언가가있을 때까지 프로그램이 차단됩니다.</target>
        </trans-unit>
        <trans-unit id="0034cae2f50c204559522cfff1ceebd6deb989fa" translate="yes" xml:space="preserve">
          <source>A file containing certain required definitions that you must include &amp;ldquo;ahead&amp;rdquo; of the rest of your program to do certain obscure operations. A C header file has a</source>
          <target state="translated">특정 모호한 조작을 수행하기 위해 나머지 프로그램의 &quot;미리&quot;를 포함해야하는 특정 필수 정의가 포함 된 파일. AC 헤더 파일에는</target>
        </trans-unit>
        <trans-unit id="731000aad647991373ca7dfb79bf96ee23280bc2" translate="yes" xml:space="preserve">
          <source>A file full of regular expressions to exclude when using 'make manifest' to generate the MANIFEST. These regular expressions are checked against each file path found in the distribution (so you're matching against &quot;t/foo.t&quot; not &quot;foo.t&quot;).</source>
          <target state="translated">'make manifest'를 사용하여 MANIFEST를 생성 할 때 제외 할 정규식으로 가득 찬 파일입니다. 이 정규식은 배포판에서 찾은 각 파일 경로에 대해 검사되므로 &quot;foo.t&quot;가 아닌 &quot;t / foo.t&quot;와 일치합니다.</target>
        </trans-unit>
        <trans-unit id="a17865a45ecaf1ad63bbdbb5dd8742ba69a071dc" translate="yes" xml:space="preserve">
          <source>A file in XS format starts with a C language section which goes until the first &lt;code&gt;MODULE =&lt;/code&gt; directive. Other XS directives and XSUB definitions may follow this line. The &quot;language&quot; used in this part of the file is usually referred to as the XS language. &lt;b&gt;xsubpp&lt;/b&gt; recognizes and skips POD (see &lt;a href=&quot;perlpod&quot;&gt;perlpod&lt;/a&gt;) in both the C and XS language sections, which allows the XS file to contain embedded documentation.</source>
          <target state="translated">XS 형식의 파일은 첫 번째 &lt;code&gt;MODULE =&lt;/code&gt; 지시문 까지 진행되는 C 언어 섹션으로 시작 합니다. 다른 XS 지시문 및 XSUB 정의는이 줄을 따를 수 있습니다. 파일의이 부분에서 사용되는 &quot;언어&quot;는 일반적으로 XS 언어라고합니다. &lt;b&gt;xsubpp&lt;/b&gt; 는 C 및 XS 언어 섹션에서 POD ( &lt;a href=&quot;perlpod&quot;&gt;perlpod&lt;/a&gt; 참조 )를 인식하고 건너 뛰 므로 XS 파일에 포함 된 문서가 포함될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ef34906ac9f2871761f209af13c79ffbe88cb8f1" translate="yes" xml:space="preserve">
          <source>A file test, where X is one of the letters listed below. This unary operator takes one argument, either a filename, a filehandle, or a dirhandle, and tests the associated file to see if something is true about it. If the argument is omitted, tests &lt;a href=&quot;perlvar#%24_&quot;&gt;&lt;code&gt;$_&lt;/code&gt;&lt;/a&gt;, except for &lt;code&gt;-t&lt;/code&gt;, which tests STDIN. Unless otherwise documented, it returns &lt;code&gt;1&lt;/code&gt; for true and &lt;code&gt;''&lt;/code&gt; for false. If the file doesn't exist or can't be examined, it returns &lt;a href=&quot;#undef-EXPR&quot;&gt;&lt;code&gt;undef&lt;/code&gt;&lt;/a&gt; and sets &lt;a href=&quot;perlvar#%24%21&quot;&gt;&lt;code&gt;$!&lt;/code&gt;&lt;/a&gt; (errno). With the exception of the &lt;code&gt;-l&lt;/code&gt; test they all follow symbolic links because they use &lt;code&gt;stat()&lt;/code&gt; and not &lt;code&gt;lstat()&lt;/code&gt; (so dangling symlinks can't be examined and will therefore report failure).</source>
          <target state="translated">파일 테스트. 여기서 X는 아래 나열된 문자 중 하나입니다. 이 단항 연산자는 파일 이름, 파일 핸들 또는 dirhandle 중 하나의 인수를 취하고 관련 파일을 테스트하여 해당 파일에 대해 사실인지 확인합니다. 인수가 생략되면 STDIN을 테스트하는 &lt;code&gt;-t&lt;/code&gt; 를 제외하고 &lt;a href=&quot;perlvar#%24_&quot;&gt; &lt;code&gt;$_&lt;/code&gt; &lt;/a&gt; 를 테스트합니다. 달리 문서화되지 않는 한, true 인 경우 &lt;code&gt;1&lt;/code&gt; 을 , false 인 경우 &lt;code&gt;''&lt;/code&gt; 를 반환합니다 . 파일이 없거나 검사 할 수없는 경우 &lt;a href=&quot;#undef-EXPR&quot;&gt; &lt;code&gt;undef&lt;/code&gt; 를&lt;/a&gt; 반환 하고 &lt;a href=&quot;perlvar#%24%21&quot;&gt; &lt;code&gt;$!&lt;/code&gt; &lt;/a&gt;(errno). &lt;code&gt;-l&lt;/code&gt; 테스트를 제외하고는 모두 &lt;code&gt;lstat()&lt;/code&gt; 아닌 &lt;code&gt;stat()&lt;/code&gt; 를 사용하기 때문에 심볼릭 링크를 따릅니다. (따라서 매달린 심볼릭 링크는 검사 할 수 없으므로 실패를보고합니다).</target>
        </trans-unit>
        <trans-unit id="51841b4270c479a7cdbc29c3d5f66446edf393a3" translate="yes" xml:space="preserve">
          <source>A file test, where X is one of the letters listed below. This unary operator takes one argument, either a filename, a filehandle, or a dirhandle, and tests the associated file to see if something is true about it. If the argument is omitted, tests &lt;code&gt;$_&lt;/code&gt; , except for &lt;code&gt;-t&lt;/code&gt; , which tests STDIN. Unless otherwise documented, it returns &lt;code&gt;1&lt;/code&gt; for true and &lt;code&gt;''&lt;/code&gt; for false. If the file doesn't exist or can't be examined, it returns &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; and sets &lt;code&gt;$!&lt;/code&gt; (errno). Despite the funny names, precedence is the same as any other named unary operator. The operator may be any of:</source>
          <target state="translated">파일 테스트. 여기서 X는 아래 나열된 문자 중 하나입니다. 이 단항 연산자는 파일 이름, 파일 핸들 또는 dirhandle 중 하나의 인수를 사용하여 연관된 파일을 테스트하여 그에 대한 것이 사실인지 확인합니다. 인수가 생략되면 STDIN을 테스트하는 &lt;code&gt;-t&lt;/code&gt; 를 제외하고 &lt;code&gt;$_&lt;/code&gt; 를 테스트하십시오. 달리 문서화되어 있지 않으면 true이면 &lt;code&gt;1&lt;/code&gt; 을, false에는 &lt;code&gt;''&lt;/code&gt; 를 반환합니다 . 파일이 없거나 검사 할 수 없으면 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 를 반환 하고 &lt;code&gt;$!&lt;/code&gt; 를 설정합니다 . (errno). 재미있는 이름에도 불구하고 우선 순위는 다른 이름이 지정된 단항 연산자와 동일합니다. 운영자는 다음 중 하나 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1c04b0088e704fdeb38d1fecd8838e16e9a29f09" translate="yes" xml:space="preserve">
          <source>A file test, where X is one of the letters listed below. This unary operator takes one argument, either a filename, a filehandle, or a dirhandle, and tests the associated file to see if something is true about it. If the argument is omitted, tests &lt;code&gt;$_&lt;/code&gt; , except for &lt;code&gt;-t&lt;/code&gt; , which tests STDIN. Unless otherwise documented, it returns &lt;code&gt;1&lt;/code&gt; for true and &lt;code&gt;''&lt;/code&gt; for false. If the file doesn't exist or can't be examined, it returns &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; and sets &lt;code&gt;$!&lt;/code&gt; (errno). Despite the funny names, precedence is the same as any other named unary operator. The operator may be any of:</source>
          <target state="translated">파일 테스트. 여기서 X는 아래 나열된 문자 중 하나입니다. 이 단항 연산자는 파일 이름, 파일 핸들 또는 dirhandle 중 하나의 인수를 사용하여 연관된 파일을 테스트하여 그에 대한 것이 사실인지 확인합니다. 인수가 생략되면 STDIN을 테스트하는 &lt;code&gt;-t&lt;/code&gt; 를 제외하고 &lt;code&gt;$_&lt;/code&gt; 를 테스트하십시오. 달리 문서화되어 있지 않으면 true이면 &lt;code&gt;1&lt;/code&gt; 을, false에는 &lt;code&gt;''&lt;/code&gt; 를 반환합니다 . 파일이 없거나 검사 할 수 없으면 &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 를 반환 하고 &lt;code&gt;$!&lt;/code&gt; 를 설정합니다 . (errno). 재미있는 이름에도 불구하고 우선 순위는 다른 이름이 지정된 단항 연산자와 동일합니다. 운영자는 다음 중 하나 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="85304934df21007f1e6dacead79952e515167d3e" translate="yes" xml:space="preserve">
          <source>A file that controls the compilation of a program. Perl programs don&amp;rsquo;t usually need a &lt;b&gt;Makefile&lt;/b&gt; because the Perl compiler has plenty of self-control.</source>
          <target state="translated">프로그램 컴파일을 제어하는 ​​파일입니다. Perl 컴파일러에는 많은 자체 제어 기능이 있으므로 Perl 프로그램에는 일반적으로 &lt;b&gt;Makefile이&lt;/b&gt; 필요하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="9c91c447fc7873fa1590ab524304262f61375872" translate="yes" xml:space="preserve">
          <source>A filehandle</source>
          <target state="translated">파일 핸들</target>
        </trans-unit>
        <trans-unit id="0ef0646f1946010fd71391d670cdd7f3f2cde9ba" translate="yes" xml:space="preserve">
          <source>A filehandle for catching standard output.</source>
          <target state="translated">표준 출력을 잡기위한 파일 핸들.</target>
        </trans-unit>
        <trans-unit id="dddbea875ae221e63e546196812256d3f13f54a9" translate="yes" xml:space="preserve">
          <source>A filehandle is opened but the file operations are performed &quot;in-memory&quot; on a scalar variable. All the normal file operations can be performed on the handle. The scalar is considered a stream of bytes. Currently fileno($fh) returns -1.</source>
          <target state="translated">파일 핸들이 열리지 만 파일 작업은 스칼라 변수에서 &quot;메모리 내&quot;로 수행됩니다. 핸들에서 모든 일반 파일 작업을 수행 할 수 있습니다. 스칼라는 바이트 스트림으로 간주됩니다. 현재 fileno ($ fh)는 -1을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="2ead9b8d6ddfb62275b7ebf2bc90be0c9e8b9ced" translate="yes" xml:space="preserve">
          <source>A filehandle that should read or write UTF-8</source>
          <target state="translated">UTF-8을 읽거나 써야하는 파일 핸들</target>
        </trans-unit>
        <trans-unit id="c2227149e71cd22222d8c43a50c19d04660c6c2c" translate="yes" xml:space="preserve">
          <source>A filehandle to write the C code to. If not given, then</source>
          <target state="translated">C 코드를 작성할 파일 핸들입니다. 제공하지 않으면</target>
        </trans-unit>
        <trans-unit id="51118efef78727e7eccbadc9f314bd7f4afcf597" translate="yes" xml:space="preserve">
          <source>A filehandle to write the XS code to. If not given, then</source>
          <target state="translated">XS 코드를 작성할 파일 핸들입니다. 제공하지 않으면</target>
        </trans-unit>
        <trans-unit id="94e7ed7be4ff1750888b6ea45dc5effd2b37d94d" translate="yes" xml:space="preserve">
          <source>A filehandle, from which the file will be read.</source>
          <target state="translated">파일을 읽을 파일 핸들.</target>
        </trans-unit>
        <trans-unit id="7c79e2e3cdb811630721119bd1fda8fa5ffcd8fa" translate="yes" xml:space="preserve">
          <source>A filename</source>
          <target state="translated">파일 이름</target>
        </trans-unit>
        <trans-unit id="c34303a3b313a718df7cf274a0efcf1c25994c0c" translate="yes" xml:space="preserve">
          <source>A filetest operator, with exactly 4 exceptions: &lt;code&gt;-s&lt;/code&gt; , &lt;code&gt;-M&lt;/code&gt; , &lt;code&gt;-A&lt;/code&gt; , and &lt;code&gt;-C&lt;/code&gt; , as these return numerical values, not boolean ones. The &lt;code&gt;-z&lt;/code&gt; filetest operator is not included in the exception list.</source>
          <target state="translated">부울 값이 아닌 숫자 값을 반환하므로 &lt;code&gt;-s&lt;/code&gt; , &lt;code&gt;-M&lt;/code&gt; , &lt;code&gt;-A&lt;/code&gt; 및 &lt;code&gt;-C&lt;/code&gt; 정확히 4 개의 예외가있는 파일 테스트 연산자 입니다. &lt;code&gt;-z&lt;/code&gt; 파일 테스트 연산자 예외 목록에 포함되지 않는다.</target>
        </trans-unit>
        <trans-unit id="f4fe6298165162f938688f8a2c671c5d42d80d9b" translate="yes" xml:space="preserve">
          <source>A filetest operator, with exactly 4 exceptions: &lt;code&gt;-s&lt;/code&gt;, &lt;code&gt;-M&lt;/code&gt;, &lt;code&gt;-A&lt;/code&gt;, and &lt;code&gt;-C&lt;/code&gt;, as these return numerical values, not boolean ones. The &lt;code&gt;-z&lt;/code&gt; filetest operator is not included in the exception list.</source>
          <target state="translated">정확히 4 개의 예외가있는 filetest 연산자 : &lt;code&gt;-s&lt;/code&gt; , &lt;code&gt;-M&lt;/code&gt; , &lt;code&gt;-A&lt;/code&gt; , &lt;code&gt;-C&lt;/code&gt; . 부울 값이 아닌 숫자 값을 반환하기 때문입니다. &lt;code&gt;-z&lt;/code&gt; 파일 테스트 연산자 예외 목록에 포함되지 않는다.</target>
        </trans-unit>
        <trans-unit id="571b7a68e22aaaa36cb39947748347ab43ae89aa" translate="yes" xml:space="preserve">
          <source>A filter program, in the traditional Unix sense (input from stdin, output to stdout) that is passed on each .pm file during the build (in the pm_to_blib() phase). It is empty by default, meaning no filtering is done.</source>
          <target state="translated">빌드 과정 (pm_to_blib () 단계에서) 동안 각 .pm 파일에 전달되는 일반적인 Unix 의미 (stdin에서 입력, 출력으로 stdout으로)의 필터 프로그램입니다. 기본적으로 비어 있으므로 필터링이 수행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f1bffd13ce3099184de722f73a1304bb3285fcc2" translate="yes" xml:space="preserve">
          <source>A filter program, in the traditional Unix sense (input from stdin, output to stdout) that is passed on each .pm file during the build (in the pm_to_blib() phase). It is empty by default, meaning no filtering is done. You could use:</source>
          <target state="translated">빌드 중 (pm_to_blib () 단계에서) 각 .pm 파일에 전달되는 전통적인 Unix 의미 (stdin에서 입력, stdout으로 출력)의 필터 프로그램. 기본적으로 비어 있으므로 필터링이 수행되지 않습니다. 다음을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fb35ae131a8a2012ab4bde2210fbfdcbd7023aa3" translate="yes" xml:space="preserve">
          <source>A fix for Proc::ProcessTable is to edit Makefile to explicitly remove the largefile flags from the ones MakeMaker picks up from Config.pm. This will result in Proc::ProcessTable being built under the correct environment. Everything should then be OK as long as Proc::ProcessTable doesn't try to share off_t's with the rest of perl, or if it does they should be explicitly specified as off64_t.</source>
          <target state="translated">Proc :: ProcessTable에 대한 수정은 Makefile을 편집하여 Config.pm에서 MakeMaker가 선택하는 것에서 큰 파일 플래그를 명시 적으로 제거하는 것입니다. 이로 인해 Proc :: ProcessTable이 올바른 환경에서 빌드됩니다. Proc :: ProcessTable이 off_t를 나머지 perl과 공유하려고 시도하지 않는 한, 그렇지 않으면 명시 적으로 off64_t로 지정되어야합니다.</target>
        </trans-unit>
        <trans-unit id="a9d22545c3578b64eb5fa290d40cfb8cd3124e35" translate="yes" xml:space="preserve">
          <source>A fix for that problem is scheduled to be released in the following levels of AIX, all of which should be coming out in the 4th quarter of 2009:</source>
          <target state="translated">이 문제점에 대한 픽스는 다음 레벨의 AIX에서 릴리스 될 예정이며, 모두 2009 년 4 분기에 출시 될 예정입니다.</target>
        </trans-unit>
        <trans-unit id="42701417421c1ef72d52e9b7e2d8ce1f61f1f95a" translate="yes" xml:space="preserve">
          <source>A fixed hard disk.</source>
          <target state="translated">고정 하드 디스크.</target>
        </trans-unit>
        <trans-unit id="fbcd311c30c802b9eee4a011f2523c74bbb4eeb7" translate="yes" xml:space="preserve">
          <source>A fixed length thing, given as a [pointer, length] pair. If you know the length of a string at compile time you may use this instead of</source>
          <target state="translated">[포인터, 길이] 쌍으로 주어진 고정 길이의 것. 컴파일 타임에 문자열의 길이를 알고 있다면 대신에 이것을 사용할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="2dd9070969808d13493b31f8533aee2df5f82471" translate="yes" xml:space="preserve">
          <source>A fixed number of digits before (positive) or after (negative) the decimal point. For example, 123.45 has a precision of -2. 0 means an integer like 123 (or 120). A precision of 2 means two digits to the left of the decimal point are zero, so 123 with P = 1 becomes 120. Note that numbers with zeros before the decimal point may have different precisions, because 1200 can have p = 0, 1 or 2 (depending on what the initial value was). It could also have p &amp;lt; 0, when the digits after the decimal point are zero.</source>
          <target state="translated">소수점 앞 (양수) 또는 이후 (음수)의 고정 자릿수입니다. 예를 들어, 123.45의 정밀도는 -2입니다. 0은 123 (또는 120)과 같은 정수를 의미합니다. 정밀도 2는 소수점 왼쪽의 두 자리 숫자가 0이므로 P = 1 인 123은 120이됩니다. 소수점 앞에 0이있는 숫자는 정밀도가 다를 수 있습니다. 1200은 p = 0, 1 또는 2 (초기 값에 따라 다름). 소수점 뒤의 숫자가 0 일 때 p &amp;lt;0을 가질 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="27aa36567c7de687c1256c668f8713e83fe0a789" translate="yes" xml:space="preserve">
          <source>A flag for whether item 3 (if present) is a URL (like &quot;&lt;a href=&quot;http://lists.perl.org&quot;&gt;http://lists.perl.org&lt;/a&gt;&quot; is), in which case there should be no section attribute; a Pod name (like &quot;perldoc&quot; and &quot;Getopt::Std&quot; are); or possibly a man page name (like &quot;crontab(5)&quot; is).</source>
          <target state="translated">항목 3 (있는 경우)이 URL (예 : &quot; &lt;a href=&quot;http://lists.perl.org&quot;&gt;http://lists.perl.org&lt;/a&gt; &quot; 와 같은)인지 여부에 대한 플래그입니다 .이 경우 섹션 속성이 없어야합니다. 포드 이름 (예 : &quot;perldoc&quot;및 &quot;Getopt :: Std&quot;); 또는 맨 페이지 이름 (예 : &quot;crontab (5)&quot;은)입니다.</target>
        </trans-unit>
        <trans-unit id="106d15351f4a75ec3f2797be6646ec091bf455c8" translate="yes" xml:space="preserve">
          <source>A flag for whether item 3 (if present) is a URL (like &quot;http://lists.perl.org&quot; is), in which case there should be no section attribute; a Pod name (like &quot;perldoc&quot; and &quot;Getopt::Std&quot; are); or possibly a man page name (like &quot;crontab(5)&quot; is).</source>
          <target state="translated">항목 3 (있는 경우)이 URL (예 : &quot;http://lists.perl.org&quot;)인지 여부에 대한 플래그,이 경우 섹션 속성이 없어야합니다. 포드 이름 (예 : &quot;perldoc&quot;및 &quot;Getopt :: Std&quot;) 또는 매뉴얼 페이지 이름 (예 : &quot;crontab (5)&quot;)입니다.</target>
        </trans-unit>
        <trans-unit id="aa81fd53ffda939e60f21a6a48bc3fd1ecb33421" translate="yes" xml:space="preserve">
          <source>A floating point number potentially has a sign, an integral part, a decimal point, a fractional part, and an exponent. One or more of these parts is optional, so we need to check out the different possibilities. Floating point numbers which are in proper form include 123., 0.345, .34, -1e6, and 25.4E-72. As with integers, the sign out front is completely optional and can be matched by &lt;code&gt;[+-]?&lt;/code&gt;. We can see that if there is no exponent, floating point numbers must have a decimal point, otherwise they are integers. We might be tempted to model these with &lt;code&gt;\d*\.\d*&lt;/code&gt;, but this would also match just a single decimal point, which is not a number. So the three cases of floating point number without exponent are</source>
          <target state="translated">부동 소수점 숫자에는 부호, 정수 부분, 소수점, 분수 부분 및 지수가있을 수 있습니다. 이러한 부분 중 하나 이상은 선택 사항이므로 다양한 가능성을 확인해야합니다. 올바른 형식의 부동 소수점 숫자는 123., 0.345, .34, -1e6 및 25.4E-72를 포함합니다. 정수와 마찬가지로 부호 앞면은 선택 사항이며 &lt;code&gt;[+-]?&lt;/code&gt; 와 일치시킬 수 있습니까? . 지수가없는 경우 부동 소수점 숫자에는 소수점이 있어야하며 그렇지 않으면 정수입니다. 우리는 이것을 &lt;code&gt;\d*\.\d*&lt;/code&gt; 로 모델링하고 싶을 수도 있지만 이것은 숫자가 아닌 하나의 소수점과도 일치합니다. 따라서 지수가없는 부동 소수점 숫자의 세 가지 경우는</target>
        </trans-unit>
        <trans-unit id="ff8a1f9e295a3b368fdb0bcb2f6682d3f1a7706d" translate="yes" xml:space="preserve">
          <source>A floating point number. This typemap guarantees to return a variable cast to a &lt;code&gt;float&lt;/code&gt; .</source>
          <target state="translated">부동 소수점 숫자 이 타입 맵은 변수 캐스트를 &lt;code&gt;float&lt;/code&gt; 로 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="989e51ade0bc6499f4e6912c535b030573178b2b" translate="yes" xml:space="preserve">
          <source>A floating point number. This typemap guarantees to return a variable cast to a &lt;code&gt;float&lt;/code&gt;.</source>
          <target state="translated">부동 소수점 숫자. 이 타입 맵은 변수 캐스트를 &lt;code&gt;float&lt;/code&gt; 로 반환하도록 보장합니다 .</target>
        </trans-unit>
        <trans-unit id="032a7b56b1da4c1e8613c276b9cfb6d58696eaf8" translate="yes" xml:space="preserve">
          <source>A floppy diskette drive or other removable media drive, but not a CD-ROM drive.</source>
          <target state="translated">플로피 디스켓 드라이브 또는 기타 이동식 미디어 드라이브 (CD-ROM 드라이브 제외).</target>
        </trans-unit>
        <trans-unit id="cb62089bcb14b38f0a60a1ce278c6aa2cfaf6aec" translate="yes" xml:space="preserve">
          <source>A flow of data into or out of a process as a steady sequence of bytes or characters, without the appearance of being broken up into packets. This is a kind of &lt;b&gt;interface&lt;/b&gt;&amp;mdash;the underlying &lt;b&gt;implementation&lt;/b&gt; may well break your data up into separate packets for delivery, but this is hidden from you.</source>
          <target state="translated">패킷으로 나뉘 지 않고 꾸준한 바이트 또는 문자 시퀀스로 프로세스 내부 또는 외부에서 데이터 흐름. 이것은 일종의 &lt;b&gt;인터페이스입니다.&lt;/b&gt; 기본 &lt;b&gt;구현&lt;/b&gt; 은 데이터를 전달하기 위해 별도의 패킷으로 나눌 수 있지만 이것은 숨겨져 있습니다.</target>
        </trans-unit>
        <trans-unit id="e81e65da76994db0744db8c12c18f7cc1632c8c6" translate="yes" xml:space="preserve">
          <source>A fork of &lt;a href=&quot;parent&quot;&gt;parent&lt;/a&gt; that provides version checking in parent class modules.</source>
          <target state="translated">부모 클래스 모듈에서 버전 검사를 제공 하는 &lt;a href=&quot;parent&quot;&gt;부모&lt;/a&gt; 포크입니다 .</target>
        </trans-unit>
        <trans-unit id="f7f93ab55d0cd5dedac331be7a34ca8ef2c56a43" translate="yes" xml:space="preserve">
          <source>A form name &lt;code&gt;Unicode::Normalize::normalize()&lt;/code&gt; accepts will be applied as &lt;code&gt;$normalization_form&lt;/code&gt; . Acceptable names include &lt;code&gt;'NFD'&lt;/code&gt; , &lt;code&gt;'NFC'&lt;/code&gt; , &lt;code&gt;'NFKD'&lt;/code&gt; , and &lt;code&gt;'NFKC'&lt;/code&gt; . See &lt;code&gt;Unicode::Normalize::normalize()&lt;/code&gt; for detail. If omitted, &lt;code&gt;'NFD'&lt;/code&gt; is used.</source>
          <target state="translated">&lt;code&gt;Unicode::Normalize::normalize()&lt;/code&gt; 수락 형식 이름 은 &lt;code&gt;$normalization_form&lt;/code&gt; 으로 적용됩니다 . 허용 가능한 이름은 &lt;code&gt;'NFD'&lt;/code&gt; , &lt;code&gt;'NFC'&lt;/code&gt; , &lt;code&gt;'NFKD'&lt;/code&gt; 및 &lt;code&gt;'NFKC'&lt;/code&gt; 입니다. 자세한 내용은 &lt;code&gt;Unicode::Normalize::normalize()&lt;/code&gt; 를 참조하십시오 . 생략하면 &lt;code&gt;'NFD'&lt;/code&gt; 가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="561ab06d7f47c467c676cc1068bd4564e1083a7b" translate="yes" xml:space="preserve">
          <source>A form name &lt;code&gt;Unicode::Normalize::normalize()&lt;/code&gt; accepts will be applied as &lt;code&gt;$normalization_form&lt;/code&gt;. Acceptable names include &lt;code&gt;'NFD'&lt;/code&gt;, &lt;code&gt;'NFC'&lt;/code&gt;, &lt;code&gt;'NFKD'&lt;/code&gt;, and &lt;code&gt;'NFKC'&lt;/code&gt;. See &lt;code&gt;Unicode::Normalize::normalize()&lt;/code&gt; for detail. If omitted, &lt;code&gt;'NFD'&lt;/code&gt; is used.</source>
          <target state="translated">&lt;code&gt;Unicode::Normalize::normalize()&lt;/code&gt; 수락 하는 양식 이름 은 &lt;code&gt;$normalization_form&lt;/code&gt; 으로 적용됩니다 . 허용되는 이름에는 &lt;code&gt;'NFD'&lt;/code&gt; , &lt;code&gt;'NFC'&lt;/code&gt; , &lt;code&gt;'NFKD'&lt;/code&gt; 및 &lt;code&gt;'NFKC'&lt;/code&gt; 가 있습니다. 자세한 내용은 &lt;code&gt;Unicode::Normalize::normalize()&lt;/code&gt; 를 참조하십시오 . 생략하면 &lt;code&gt;'NFD'&lt;/code&gt; 가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="c49b8a933b39ce175d6f4d01ed275b88dda586c3" translate="yes" xml:space="preserve">
          <source>A form of &lt;b&gt;scalar context&lt;/b&gt; in which an &lt;b&gt;expression&lt;/b&gt; is not expected to return any &lt;b&gt;value&lt;/b&gt; at all and is evaluated for its &lt;b&gt;side effects&lt;/b&gt; alone.</source>
          <target state="translated">&lt;b&gt;표현식&lt;/b&gt; 이 어떤 &lt;b&gt;값도&lt;/b&gt; 반환하지 않을 것으로 예상되고 &lt;b&gt;부작용&lt;/b&gt; 만 평가 되는 &lt;b&gt;스칼라 컨텍스트&lt;/b&gt; 형식입니다 .&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="95b8b92c738006a6a5118bef738de47b796e9ea2" translate="yes" xml:space="preserve">
          <source>A formal grammar would look similar to the following:</source>
          <target state="translated">공식 문법은 다음과 유사합니다.</target>
        </trans-unit>
        <trans-unit id="721d8611bd61e5ecdf8561b50e0139065e69ec6d" translate="yes" xml:space="preserve">
          <source>A formalized definition of the legal forms for version strings is included in the &lt;code&gt;version::regex&lt;/code&gt; class. Primitives are included for common elements, although they are scoped to the file so they are useful for reference purposes only. There are two publicly accessible scalars that can be used in other code (not exported):</source>
          <target state="translated">&lt;code&gt;version::regex&lt;/code&gt; 클래스 에는 버전 문자열에 대한 법적 형식의 공식화 된 정의가 포함되어 있습니다. 기본 요소는 공통 요소에 포함되지만 파일 범위가 지정되어 참조 목적으로 만 유용합니다. 다른 코드 (내 보내지 않음)에서 사용할 수있는 공개적으로 액세스 할 수있는 스칼라 두 개가 있습니다.</target>
        </trans-unit>
        <trans-unit id="8f6424f6bb5e3764fd5434bcd18cd75bdd7582fd" translate="yes" xml:space="preserve">
          <source>A format name of &quot;comment&quot; is common for just making notes (presumably to yourself) that won't appear in any formatted version of the Pod document:</source>
          <target state="translated">&quot;댓글&quot;의 형식 이름은 Pod 문서의 형식화 된 버전에 표시되지 않는 메모 (아마도 자신에게)를 작성하는 데 일반적입니다.</target>
        </trans-unit>
        <trans-unit id="2446a10134816c33cde7e4a21588ee8f42d4b1d2" translate="yes" xml:space="preserve">
          <source>A formatter can specify by implementing the &lt;code&gt;hide_buffered()&lt;/code&gt; method. If this method returns true then events generated inside a buffered subtest will not be sent independently of the final subtest event.</source>
          <target state="translated">포맷터는 &lt;code&gt;hide_buffered()&lt;/code&gt; 메서드를 구현하여 지정할 수 있습니다 . 이 메서드가 true를 반환하면 버퍼링 된 하위 테스트 내에서 생성 된 이벤트가 최종 하위 테스트 이벤트와 독립적으로 전송되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a76335714c7e25f79355585f9f9381d9b64c34cd" translate="yes" xml:space="preserve">
          <source>A formatter is any package or object with a &lt;code&gt;write($event, $num)&lt;/code&gt; method.</source>
          <target state="translated">포맷터는 &lt;code&gt;write($event, $num)&lt;/code&gt; 메서드 가있는 모든 패키지 또는 개체입니다 .</target>
        </trans-unit>
        <trans-unit id="d26b5fa96c287794c375f977fd86d1fe4bad1833" translate="yes" xml:space="preserve">
          <source>A formatting code starts with a capital letter (just US-ASCII [A-Z]) followed by a &quot;&amp;lt;&quot;, any number of characters, and ending with the first matching &quot;&amp;gt;&quot;. Examples:</source>
          <target state="translated">서식 코드는 대문자 (US-ASCII [AZ])로 시작하고 그 뒤에 &quot;&amp;lt;&quot;, 문자 수 및 첫 번째로 일치하는 &quot;&amp;gt;&quot;로 끝납니다. 예 :</target>
        </trans-unit>
        <trans-unit id="e1ebaf29b6e50a9147fa41854529f9f91464bbca" translate="yes" xml:space="preserve">
          <source>A formatting code starts with a capital letter (just US-ASCII [A-Z]) followed by two or more &quot;&amp;lt;&quot;'s, one or more whitespace characters, any number of characters, one or more whitespace characters, and ending with the first matching sequence of two or more &quot;&amp;gt;&quot;'s, where the number of &quot;&amp;gt;&quot;'s equals the number of &quot;&amp;lt;&quot;'s in the opening of this formatting code. Examples:</source>
          <target state="translated">서식 코드는 대문자로 시작하고 (US-ASCII [AZ] 만) 두 개 이상의 &quot;&amp;lt;&quot;, 하나 이상의 공백 문자, 여러 문자, 하나 이상의 공백 문자 및 첫 번째 문자로 끝납니다. 두 개 이상의 &quot;&amp;gt;&quot;의 일치 순서. 여기서 &quot;&amp;gt;&quot;의 수는이 형식화 코드의 시작에서 &quot;&amp;lt;&quot;의 수와 같습니다. 예 :</target>
        </trans-unit>
        <trans-unit id="ee13838be926e942481224190d1b48d665a53c86" translate="yes" xml:space="preserve">
          <source>A free perl5-based PERL.NLM for Novell Netware is available in precompiled binary and source code form from &lt;a href=&quot;http://www.novell.com/&quot;&gt;http://www.novell.com/&lt;/a&gt; as well as from CPAN.</source>
          <target state="translated">Novell Netware 용 무료 perl5 기반 PERL.NLM은 &lt;a href=&quot;http://www.novell.com/&quot;&gt;http://www.novell.com/&lt;/a&gt; 과 CPAN 에서 사전 컴파일 된 이진 및 소스 코드 형식 으로 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="3b03ecae28b894e59a1c00c717f1b1e736c5b6b6" translate="yes" xml:space="preserve">
          <source>A from scratch implementation of buffering for PerlIO. Provides fast access to the buffer for &lt;code&gt;sv_gets&lt;/code&gt; which implements Perl's readline/&amp;lt;&amp;gt; and in general attempts to minimize data copying.</source>
          <target state="translated">PerlIO에 대한 버퍼링의 처음부터 구현. Perl의 readline / &amp;lt;&amp;gt;을 구현하고 일반적으로 데이터 복사를 최소화하려는 시도를하는 &lt;code&gt;sv_gets&lt;/code&gt; 에 대한 버퍼에 대한 빠른 액세스를 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="601ccb979c895092a89a9db855c8bb290abdfbb7" translate="yes" xml:space="preserve">
          <source>A from scratch implementation of buffering for PerlIO. Provides fast access to the buffer for &lt;code&gt;sv_gets&lt;/code&gt; which implements perl's readline/&amp;lt;&amp;gt; and in general attempts to minimize data copying.</source>
          <target state="translated">PerlIO를위한 처음부터 버퍼링 구현. perl의 readline / &amp;lt;&amp;gt;을 구현하고 일반적으로 데이터 복사를 최소화하려는 &lt;code&gt;sv_gets&lt;/code&gt; 의 버퍼에 빠르게 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0f062561102eb36fb52de67c711e92bb30c79c71" translate="yes" xml:space="preserve">
          <source>A full commandline to run via &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system()&lt;/a&gt;&lt;/code&gt;. During execution, the environment variable PERL is set to $^X (but with an absolute path). If &lt;code&gt;commandline&lt;/code&gt; is specified, &lt;code&gt;args&lt;/code&gt; is not used.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system()&lt;/a&gt;&lt;/code&gt; 통해 실행되는 전체 명령 줄 . 실행 중에 환경 변수 PERL은 $ ^ X (절대 경로 포함)로 설정됩니다. 경우 &lt;code&gt;commandline&lt;/code&gt; 지정, &lt;code&gt;args&lt;/code&gt; 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="14cec31abd2e629547d353d78977abf26c0ffa5f" translate="yes" xml:space="preserve">
          <source>A full set of HTML documentation is installed, so you should be able to use it if you have a web browser installed on your system.</source>
          <target state="translated">HTML 문서의 전체 세트가 설치되어 있으므로 시스템에 웹 브라우저가 설치되어 있으면이를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6a2c1a54fe4430e99127181c7879f97150ac83b4" translate="yes" xml:space="preserve">
          <source>A fully qualified filename such as</source>
          <target state="translated">정규화 된 파일 이름 (예 :</target>
        </trans-unit>
        <trans-unit id="66350a7ced5e0598bbaa01d95aa21c1aa8b64d66" translate="yes" xml:space="preserve">
          <source>A function named &lt;code&gt;new&lt;/code&gt; must not be explicitly defined in a class created by &lt;code&gt;struct&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;new&lt;/code&gt; 라는 함수 는 &lt;code&gt;struct&lt;/code&gt; 가 만든 클래스에 명시 적으로 정의되어서는 안됩니다 .</target>
        </trans-unit>
        <trans-unit id="cbfff922711d57d226b2688d07195e70805b9750" translate="yes" xml:space="preserve">
          <source>A function named &lt;code&gt;new&lt;/code&gt; must not be explicitly defined in a class created by &lt;code&gt;struct&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;new&lt;/code&gt; 라는 함수 는 &lt;code&gt;struct&lt;/code&gt; 에 의해 생성 된 클래스에 명시 적으로 정의되어서는 안됩니다 .</target>
        </trans-unit>
        <trans-unit id="2945149f02dd35ba51bde27d2145bb414391b9dd" translate="yes" xml:space="preserve">
          <source>A function returning a single scalar with &lt;code&gt;#define&lt;/code&gt; definitions for the constants used internally between the generated C and XS functions.</source>
          <target state="translated">생성 된 C 함수와 XS 함수 사이에 내부적으로 사용되는 상수에 대해 &lt;code&gt;#define&lt;/code&gt; 정의가 있는 단일 스칼라를 반환하는 함수입니다.</target>
        </trans-unit>
        <trans-unit id="b69855856bd43ed93ca10429f84d959193788fea" translate="yes" xml:space="preserve">
          <source>A function that needs a filehandle of its own must use &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local()&lt;/a&gt;&lt;/code&gt; on a complete typeglob. This can be used to create new symbol table entries:</source>
          <target state="translated">자체 파일 핸들이 필요한 함수 는 완전한 typeglob에서 &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local()&lt;/a&gt;&lt;/code&gt; 을 사용해야합니다 . 새 심볼 테이블 항목을 만드는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="60bce2f6faa5df9b0e4a3b944a64f25b88cc7ae4" translate="yes" xml:space="preserve">
          <source>A function that needs a filehandle of its own must use &lt;code&gt;local()&lt;/code&gt; on a complete typeglob. This can be used to create new symbol table entries:</source>
          <target state="translated">자체 파일 핸들이 필요한 함수 는 완전한 typeglob에서 &lt;code&gt;local()&lt;/code&gt; 을 사용해야합니다 . 새 기호 테이블 항목을 만드는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="074e275ec83817fc8f7919a77c7d1bc574268f70" translate="yes" xml:space="preserve">
          <source>A function that returns a &lt;b&gt;list&lt;/b&gt; of C subroutine definitions that return the value and type of constants when passed the name by the XS wrapper.</source>
          <target state="translated">XS 랩퍼가 이름을 전달할 때 상수 및 값 유형을 리턴하는 C 서브 루틴 정의 &lt;b&gt;목록&lt;/b&gt; 을 리턴하는 함수입니다 .</target>
        </trans-unit>
        <trans-unit id="16f5ca42729ef594d519db59b85f9698b43a3153" translate="yes" xml:space="preserve">
          <source>A function to generate perl code for Makefile.PL that will regenerate the constant subroutines. Parameters are named as passed to &lt;code&gt;WriteConstants&lt;/code&gt; , with the addition of &lt;code&gt;INDENT&lt;/code&gt; to specify the number of leading spaces (default 2).</source>
          <target state="translated">상수 서브 루틴을 재생성하는 Makefile.PL에 대한 펄 코드를 생성하는 함수입니다. 선행 공간 수를 지정하기 위해 &lt;code&gt;INDENT&lt;/code&gt; 를 추가 하여 매개 변수의 이름이 &lt;code&gt;WriteConstants&lt;/code&gt; 로 전달됩니다 (기본값 2).</target>
        </trans-unit>
        <trans-unit id="d909b3c9635ad08512fcce3363f9ca841d9148f8" translate="yes" xml:space="preserve">
          <source>A function to generate perl code for Makefile.PL that will regenerate the constant subroutines. Parameters are named as passed to &lt;code&gt;WriteConstants&lt;/code&gt;, with the addition of &lt;code&gt;INDENT&lt;/code&gt; to specify the number of leading spaces (default 2).</source>
          <target state="translated">상수 서브 루틴을 재생성 할 Makefile.PL 용 펄 코드를 생성하는 함수입니다. 매개 변수는 &lt;code&gt;WriteConstants&lt;/code&gt; 에 전달 된대로 이름 이 지정되며 선행 공백 수를 지정하기 위해 &lt;code&gt;INDENT&lt;/code&gt; 가 추가됩니다 (기본값 2).</target>
        </trans-unit>
        <trans-unit id="6f1112f59bf733c8ebebfbb190c9c3efe0aeac9b" translate="yes" xml:space="preserve">
          <source>A function to generate the AUTOLOAD subroutine for the module</source>
          <target state="translated">모듈에 대한 AUTOLOAD 서브 루틴을 생성하는 기능</target>
        </trans-unit>
        <trans-unit id="b0a02614782733bf06479ea297bf790f7927505f" translate="yes" xml:space="preserve">
          <source>A function to generate the XS code to implement the perl subroutine</source>
          <target state="translated">Perl 서브 루틴을 구현하기 위해 XS 코드를 생성하는 기능</target>
        </trans-unit>
        <trans-unit id="94d15a8aa6cbd7f8b0a2a414f5a5f7d2b35f7284" translate="yes" xml:space="preserve">
          <source>A function which returns a 7 bit ASCII correctly \ escaped version of the string passed suitable for C's &quot;&quot; or ''. It will die if passed Unicode characters.</source>
          <target state="translated">C의 &quot;&quot;또는 ''에 적합하게 전달 된 문자열의 7 비트 ASCII를 올바르게 이스케이프 된 버전을 반환하는 함수입니다. 유니 코드 문자를 전달하면 죽습니다.</target>
        </trans-unit>
        <trans-unit id="c45b17fcb375003bf4d5bd87967dc1245beb7fd4" translate="yes" xml:space="preserve">
          <source>A function which returns a 7 bit ASCII correctly \ escaped version of the string passed suitable for a perl &quot;&quot; string.</source>
          <target state="translated">perl &quot;&quot;문자열에 적합하게 전달 된 문자열의 7 비트 ASCII를 올바르게 이스케이프 된 버전을 반환하는 함수입니다.</target>
        </trans-unit>
        <trans-unit id="5e16a22c3d8b0f460cffd4d274f2db99a8a3ae51" translate="yes" xml:space="preserve">
          <source>A fundamental feature of regular expression matching involves the notion called</source>
          <target state="translated">정규 표현식 일치의 기본 기능에는</target>
        </trans-unit>
        <trans-unit id="f32db861d817164e66eceb71b5a4c52967492203" translate="yes" xml:space="preserve">
          <source>A general function for editing the structure of an existing chain of op_sibling nodes. By analogy with the perl-level &lt;code&gt;splice()&lt;/code&gt; function, allows you to delete zero or more sequential nodes, replacing them with zero or more different nodes. Performs the necessary op_first/op_last housekeeping on the parent node and op_sibling manipulation on the children. The last deleted node will be marked as the last node by updating the op_sibling/op_sibparent or op_moresib field as appropriate.</source>
          <target state="translated">op_sibling 노드의 기존 체인 구조를 편집하기위한 일반 기능입니다. perl 수준의 &lt;code&gt;splice()&lt;/code&gt; 함수 와 유사하게 0 개 이상의 순차적 노드를 삭제하여 0 개 이상의 다른 노드로 대체 할 수 있습니다. 부모 노드에 대해 필요한 op_first / op_last 하우스 키핑을 수행하고 자식에 대해 op_sibling 조작을 수행합니다. 마지막으로 삭제 된 노드는 op_sibling / op_sibparent 또는 op_moresib 필드를 적절하게 업데이트하여 마지막 노드로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="2100c9b6a5bc83c2e9c2b9fd7c9dc09b08c1aad2" translate="yes" xml:space="preserve">
          <source>A general function for editing the structure of an existing chain of op_sibling nodes. By analogy with the perl-level splice() function, allows you to delete zero or more sequential nodes, replacing them with zero or more different nodes. Performs the necessary op_first/op_last housekeeping on the parent node and op_sibling manipulation on the children. The last deleted node will be marked as as the last node by updating the op_sibling/op_sibparent or op_moresib field as appropriate.</source>
          <target state="translated">기존 op_sibling 노드 체인의 구조를 편집하는 일반적인 기능입니다. perl- 레벨 splice () 함수와 유사하게, 0 개 이상의 순차적 노드를 삭제하여 0 개 이상의 다른 노드로 대체 할 수 있습니다. 부모 노드에서 필요한 op_first / op_last 하우스 키핑과 자식에서 op_sibling 조작을 수행합니다. op_sibling / op_sibparent 또는 op_moresib 필드를 적절하게 업데이트하여 마지막으로 삭제 된 노드가 마지막 노드로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="16b0d3e317f9f7b5ddb72b16cb53e05b583e9133" translate="yes" xml:space="preserve">
          <source>A general solution to the serialization problem would require another level of registry, one that associates</source>
          <target state="translated">직렬화 문제에 대한 일반적인 솔루션에는 다른 수준의 레지스트리가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="ed526677b5c541991128da9f35ea30909114035f" translate="yes" xml:space="preserve">
          <source>A generic &lt;b&gt;object&lt;/b&gt; type; that is, a &lt;b&gt;class&lt;/b&gt; from which other, more specific classes are derived genetically by &lt;b&gt;inheritance&lt;/b&gt;. Also called a &amp;ldquo;superclass&amp;rdquo; by people who respect their ancestors.</source>
          <target state="translated">일반 &lt;b&gt;객체&lt;/b&gt; 유형. 즉, A는 &lt;b&gt;클래스&lt;/b&gt; 보다 구체적인 다른 클래스로 유전자 유도되는 &lt;b&gt;상속&lt;/b&gt; . 조상을 존중하는 사람들에 의해&amp;ldquo;슈퍼 클래스&amp;rdquo;라고도합니다.</target>
        </trans-unit>
        <trans-unit id="0a9918e5dda4793cf3ecc366ce8266f117c17195" translate="yes" xml:space="preserve">
          <source>A generic file fetching mechanism</source>
          <target state="translated">일반 파일 가져 오기 메커니즘</target>
        </trans-unit>
        <trans-unit id="a625d1d6246943bf40d50608e758f2319151f17b" translate="yes" xml:space="preserve">
          <source>A generic input parsing/checking mechanism.</source>
          <target state="translated">일반적인 입력 파싱 / 확인 메커니즘.</target>
        </trans-unit>
        <trans-unit id="af15d07731a55a9ecedf87f6009285e2acc4ef80" translate="yes" xml:space="preserve">
          <source>A git GUI shell extension for Windows such as TortoiseGit will cause the build and later &lt;code&gt;make test&lt;/code&gt; to run much slower since every file is checked for its git status as soon as it is created and/or modified. TortoiseGit doesn't cause any test failures or build problems unlike the antivirus software described above, but it does cause similar slowness. It is suggested to use Task Manager to look for background processes which use high CPU amounts during the building process.</source>
          <target state="translated">TortoiseGit과 같은 Windows 용 git GUI 쉘 확장은 빌드 및 / 또는 나중에 모든 파일이 작성 및 / 또는 수정 되 자마자 git 상태를 점검하기 때문에 &lt;code&gt;make test&lt;/code&gt; 가 훨씬 느리게 실행되게합니다. TortoiseGit은 위에서 설명한 바이러스 백신 소프트웨어와 달리 테스트 실패를 일으키거나 문제를 일으키지 않지만 비슷한 속도 저하를 유발합니다. 작업 프로세스를 사용하여 구축 과정에서 많은 양의 CPU를 사용하는 백그라운드 프로세스를 찾는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="ca6613321ff6c370136985bf48b668224b2f6734" translate="yes" xml:space="preserve">
          <source>A gizmo that transforms some number of input values to some number of output values, often built into a language with a special syntax or symbol. A given operator may have specific expectations about what &lt;b&gt;types&lt;/b&gt; of data you give as its arguments (&lt;b&gt;operands&lt;/b&gt;) and what type of data you want back from it.</source>
          <target state="translated">일부 입력 값을 일부 출력 값으로 변환하는 기즈모로, 종종 특수 구문 또는 기호가있는 언어로 작성됩니다. 주어진 연산자는 어떤 &lt;b&gt;유형&lt;/b&gt; 의 데이터를 인수 ( &lt;b&gt;피연산자&lt;/b&gt; )로 제공하고 어떤 유형의 데이터에서 다시 원하는지 에 대한 특정 기대치를 가질 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b0da5e61aa8557d6b28694e8c5217513361c3a66" translate="yes" xml:space="preserve">
          <source>A glossary of terms (technical and otherwise) used in the Perl documentation, derived from the Glossary of</source>
          <target state="translated">Perl 문서에 사용 된 용어 (기술 및 기타)의 용어집</target>
        </trans-unit>
        <trans-unit id="b29b7f7af6cfd5aa471dc4da158609e558212777" translate="yes" xml:space="preserve">
          <source>A glyph used in magic. Or, for Perl, the symbol in front of a variable name, such as &lt;code&gt;$&lt;/code&gt; , &lt;code&gt;@&lt;/code&gt; , and &lt;code&gt;%&lt;/code&gt; .</source>
          <target state="translated">마법에 사용되는 글리프. 또는 Perl의 경우 변수 이름 앞에있는 기호 (예 : &lt;code&gt;$&lt;/code&gt; , &lt;code&gt;@&lt;/code&gt; 및 &lt;code&gt;%&lt;/code&gt; ) .</target>
        </trans-unit>
        <trans-unit id="d989c44f106d0ab2b9ca7513c2727428f0d1bd66" translate="yes" xml:space="preserve">
          <source>A glyph used in magic. Or, for Perl, the symbol in front of a variable name, such as &lt;code&gt;$&lt;/code&gt;, &lt;code&gt;@&lt;/code&gt;, and &lt;code&gt;%&lt;/code&gt;.</source>
          <target state="translated">마법에 사용되는 문양. 또는 Perl의 경우 &lt;code&gt;$&lt;/code&gt; , &lt;code&gt;@&lt;/code&gt; 및 &lt;code&gt;%&lt;/code&gt; 와 같은 변수 이름 앞의 기호 .</target>
        </trans-unit>
        <trans-unit id="010767009a82e3c3f2315997ed16da6d8fa110ca" translate="yes" xml:space="preserve">
          <source>A good book on OO on Perl is the &quot;Object-Oriented Perl&quot; by Damian Conway from Manning Publications, or &quot;Intermediate Perl&quot; by Randal Schwartz, brian d foy, and Tom Phoenix from O'Reilly Media.</source>
          <target state="translated">OO에 관한 OO에 관한 좋은 책은 Manning Publications의 Damian Conway의 &quot;Object-Oriented Perl&quot;또는 Randal Schwartz의 &quot;Intermediate Perl&quot;, brian d foy, O'Reilly Media의 Tom Phoenix입니다.</target>
        </trans-unit>
        <trans-unit id="b82c3e9cadf17adecf1d24dc6cb64a89ca8103d6" translate="yes" xml:space="preserve">
          <source>A good place to start is &lt;a href=&quot;perlootut&quot;&gt;perlootut&lt;/a&gt;, and you can use &lt;a href=&quot;perlobj&quot;&gt;perlobj&lt;/a&gt; for reference.</source>
          <target state="translated">시작하기에 좋은 장소는 &lt;a href=&quot;perlootut&quot;&gt;perlootut&lt;/a&gt; 이며 &lt;a href=&quot;perlobj&quot;&gt;perlobj&lt;/a&gt; 를 사용 하여 참조 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="96ba2b7e6fee57191ec1137ef371aff044df9901" translate="yes" xml:space="preserve">
          <source>A good resource on the predefined macros for various operating systems, compilers, and so forth is &lt;a href=&quot;http://sourceforge.net/p/predef/wiki/Home/&quot;&gt;http://sourceforge.net/p/predef/wiki/Home/&lt;/a&gt;</source>
          <target state="translated">다양한 운영 체제, 컴파일러 등에 대해 미리 정의 된 매크로에 대한 좋은 리소스는 &lt;a href=&quot;http://sourceforge.net/p/predef/wiki/Home/&quot;&gt;http://sourceforge.net/p/predef/wiki/Home/&lt;/a&gt; 입니다 .</target>
        </trans-unit>
        <trans-unit id="878d4536576dbff5139c196eb475074b04b81dfd" translate="yes" xml:space="preserve">
          <source>A good test case has most of these attributes: short, simple code; few dependencies on external commands, modules, or libraries; no platform-dependent code (unless it's a platform-specific bug); clear, simple documentation.</source>
          <target state="translated">좋은 테스트 사례는 다음과 같은 특성을 대부분 가지고 있습니다. 짧고 간단한 코드; 외부 명령, 모듈 또는 라이브러리에 대한 종속성이 거의 없습니다. 플랫폼 별 버그가 아닌 경우 (플랫폼 별 버그가 아닌 한); 명확하고 간단한 문서.</target>
        </trans-unit>
        <trans-unit id="819fe6a0aff125bab30e82da5634d29a9188e255" translate="yes" xml:space="preserve">
          <source>A good test case is almost always a good candidate to be included in Perl's test suite. If you have the time, consider writing your test case so that it can be easily included into the standard test suite.</source>
          <target state="translated">좋은 테스트 사례는 거의 항상 Perl의 테스트 스위트에 포함될 수있는 좋은 후보입니다. 시간이 있다면 표준 테스트 스위트에 쉽게 포함될 수 있도록 테스트 케이스 작성을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="6800c5039fcfc25d3805f20efcfc998a8922a07e" translate="yes" xml:space="preserve">
          <source>A grab bag of methods to generate specific macros and commands.</source>
          <target state="translated">특정 매크로 및 명령을 생성하는 다양한 방법을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="52f74d52da3fd8ec9d4b9513d833d3c381a80abc" translate="yes" xml:space="preserve">
          <source>A grammar for the Test Anything Protocol.</source>
          <target state="translated">Test Anything Protocol에 대한 문법.</target>
        </trans-unit>
        <trans-unit id="4068f0366f48575a0048eca3205a24ad39495e7b" translate="yes" xml:space="preserve">
          <source>A grammar form might be something like this:</source>
          <target state="translated">문법 형식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="856ecf1b456990ad6225d8774e68fb8a4307706a" translate="yes" xml:space="preserve">
          <source>A grapheme is what appears to a native-speaker of a language to be a character. In Unicode (and hence Perl) a grapheme may actually be several adjacent characters that together form a complete grapheme. For example, there can be a base character, like &quot;R&quot; and an accent, like a circumflex &quot;^&quot;, that appear to be a single character when displayed, with the circumflex hovering over the &quot;R&quot;.</source>
          <target state="translated">자소는 언어의 원어민에게 캐릭터로 보이는 것입니다. 유니 코드 (및 Perl)에서 문자 소는 실제로 함께 완전한 문자 소를 형성하는 여러 인접 문자 일 수 있습니다. 예를 들어 &quot;R&quot;과 같은 기본 문자와 곡절 악센트 &quot;^&quot;와 같은 악센트가 표시 될 때 단일 문자로 나타나며 곡절 악센트가 &quot;R&quot;위에 놓일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="19193405de37cb91769fc940baebbd6ae904906a" translate="yes" xml:space="preserve">
          <source>A graphene is an allotrope of carbon arranged in a hexagonal crystal lattice one atom thick. A &lt;b&gt;grapheme&lt;/b&gt;, or more fully, a</source>
          <target state="translated">그래 핀은 한 원자 두께의 육각형 결정 격자로 배열 된 탄소의 동소체이다. &lt;b&gt;그래 핀&lt;/b&gt; , 또는 좀 더 완벽하게하는</target>
        </trans-unit>
        <trans-unit id="07663ed8c039244f1bbba8bbd0f2248a550eeeb7" translate="yes" xml:space="preserve">
          <source>A graphical representation of complex numbers is possible in a plane (also called the</source>
          <target state="translated">복소수의 그래픽 표현은 평면에서 가능합니다.</target>
        </trans-unit>
        <trans-unit id="b2a17fedc722e35cf530893f218ec96ab466a1ef" translate="yes" xml:space="preserve">
          <source>A great circle is section of a circle that contains the circle diameter: the shortest distance between two (non-antipodal) points on the spherical surface goes along the great circle connecting those two points.</source>
          <target state="translated">큰 원은 원의 지름을 포함하는 원의 단면입니다. 구면의 두 (비대 동물) 점 사이의 최단 거리는이 두 점을 연결하는 큰 원을 따릅니다.</target>
        </trans-unit>
        <trans-unit id="cf830d0f970841c8b5873e5f5dc448f292f1330c" translate="yes" xml:space="preserve">
          <source>A group of related modules on &lt;b&gt;CPAN&lt;/b&gt;. (Also sometimes refers to a group of command-line switches grouped into one &lt;b&gt;switch cluster&lt;/b&gt;.)</source>
          <target state="translated">&lt;b&gt;CPAN&lt;/b&gt; 의 관련 모듈 그룹 . 또한 때때로 하나의 &lt;b&gt;스위치 클러스터&lt;/b&gt; 로 그룹화 된 명령 줄 스위치 그룹을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="d92a635a2c1e502bba680458b972125c4a0be466" translate="yes" xml:space="preserve">
          <source>A group that is required to bundle a set of alternatives may or may not be useful as a capturing group. If it isn't, it just creates a superfluous addition to the set of available capture group values, inside as well as outside the regexp. Non-capturing groupings, denoted by &lt;code&gt;(?:regexp)&lt;/code&gt;, still allow the regexp to be treated as a single unit, but don't establish a capturing group at the same time. Both capturing and non-capturing groupings are allowed to co-exist in the same regexp. Because there is no extraction, non-capturing groupings are faster than capturing groupings. Non-capturing groupings are also handy for choosing exactly which parts of a regexp are to be extracted to matching variables:</source>
          <target state="translated">대안 세트를 묶어야하는 그룹은 캡처 그룹으로서 유용하거나 유용하지 않을 수 있습니다. 그렇지 않은 경우 정규 표현식 내부 및 외부에서 사용 가능한 캡처 그룹 값 세트에 불필요한 추가를 생성합니다. &lt;code&gt;(?:regexp)&lt;/code&gt; 로 표시되는 비 캡처 그룹화 는 정규 표현식을 단일 단위로 처리 할 수 ​​있지만 동시에 캡처 그룹을 설정하지는 않습니다. 캡처 및 비 캡처 그룹화는 동일한 정규식에서 공존 할 수 있습니다. 추출이 없기 때문에 비 캡처 그룹화는 그룹화 캡처보다 빠릅니다. 캡처하지 않은 그룹화는 정규 표현식에서 일치하는 변수로 추출 할 부분을 정확하게 선택하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="e98254b9797c79a405fb849ceb15e69b1be1e9de" translate="yes" xml:space="preserve">
          <source>A handful of characters have a dedicated</source>
          <target state="translated">소수의 캐릭터는 전용</target>
        </trans-unit>
        <trans-unit id="f93caa5208bfa6818a90d520fb7ad0e15665c128" translate="yes" xml:space="preserve">
          <source>A handler for an attributes with an all-lowercase name was declared. An attribute with an all-lowercase name might have a meaning to Perl itself some day, even though most don't yet. Use a mixed-case attribute name, instead.</source>
          <target state="translated">모두 소문자 이름을 가진 속성에 대한 핸들러가 선언되었습니다. 이름이 모두 소문자 인 속성은 언젠가 Perl 자체에 의미가있을 수 있습니다. 대신 대소 문자 속성 이름을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="c3e6d55f9badd1667902eb5523efa20bcbd3e70c" translate="yes" xml:space="preserve">
          <source>A handler for attributes of the specified name</source>
          <target state="translated">지정된 이름의 속성에 대한 핸들러</target>
        </trans-unit>
        <trans-unit id="49edbe08e4bfabb8ba065c602451240e8c0f2a33" translate="yes" xml:space="preserve">
          <source>A handy tag name for a</source>
          <target state="translated">편리한 태그 이름</target>
        </trans-unit>
        <trans-unit id="3aa757aa90e3b991f02cc566dd247ec484d84771" translate="yes" xml:space="preserve">
          <source>A hash &lt;code&gt;%DB::sub&lt;/code&gt; is maintained, whose keys are subroutine names and whose values have the form &lt;code&gt;filename:startline-endline&lt;/code&gt; . &lt;code&gt;filename&lt;/code&gt; has the form &lt;code&gt;(&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; 34)&lt;/code&gt; for subroutines defined inside &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;s.</source>
          <target state="translated">키가 서브 루틴 이름이고 값이 &lt;code&gt;filename:startline-endline&lt;/code&gt; 형식 인 해시 &lt;code&gt;%DB::sub&lt;/code&gt; 가 유지 됩니다. &lt;code&gt;filename&lt;/code&gt; 형태 갖는다 &lt;code&gt;(&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; 34)&lt;/code&gt; &lt;a href=&quot;functions/eval&quot;&gt;평가&lt;/a&gt; 34) 내에 정의 된 서브 루틴 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 들.</target>
        </trans-unit>
        <trans-unit id="c68c21cffb386f2efa2b6778aa32c6a355b62cff" translate="yes" xml:space="preserve">
          <source>A hash &lt;code&gt;%DB::sub&lt;/code&gt; is maintained, whose keys are subroutine names and whose values have the form &lt;code&gt;filename:startline-endline&lt;/code&gt;. &lt;code&gt;filename&lt;/code&gt; has the form &lt;code&gt;(eval 34)&lt;/code&gt; for subroutines defined inside &lt;code&gt;eval&lt;/code&gt;s.</source>
          <target state="translated">키가 서브 루틴 이름이고 값이 &lt;code&gt;filename:startline-endline&lt;/code&gt; 형식 인 해시 &lt;code&gt;%DB::sub&lt;/code&gt; 가 유지 됩니다. &lt;code&gt;filename&lt;/code&gt; 형태 갖는다 &lt;code&gt;(eval 34)&lt;/code&gt; 내에 정의 된 서브 루틴 &lt;code&gt;eval&lt;/code&gt; 들.</target>
        </trans-unit>
        <trans-unit id="44b55c7f5cfe4830cdb1fa796511bc1073b11348" translate="yes" xml:space="preserve">
          <source>A hash can be initialized using a literal list holding pairs of items to be interpreted as a key and a value:</source>
          <target state="translated">키와 값으로 해석 될 항목 쌍을 보유한 리터럴 목록을 사용하여 해시를 초기화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8a814541e8cdf1052da6ce7b4056b3b5847f1f69" translate="yes" xml:space="preserve">
          <source>A hash is an ideal mechanism to store the mapping between C and Perl.</source>
          <target state="translated">해시는 C와 Perl 간의 매핑을 저장하는 이상적인 메커니즘입니다.</target>
        </trans-unit>
        <trans-unit id="70381f72f3a7fd8e9863739e409cd4fabcba3c1e" translate="yes" xml:space="preserve">
          <source>A hash of array references in list context. Each entry of the hash has the fully qualified method name as its key and a reference to an array containing the method's list-context return values as its value.</source>
          <target state="translated">리스트 문맥에서의 배열 참조의 해시 해시의 각 항목에는 키로 정규화 된 메소드 이름과 메소드의 목록 컨텍스트 리턴 값을 값으로 포함하는 배열에 대한 참조가 있습니다.</target>
        </trans-unit>
        <trans-unit id="5ea60218a99582e9bc2b801ff2d5e8c50e9c5afa" translate="yes" xml:space="preserve">
          <source>A hash of hashes keyed on perl version and on module name. If a module is defined it indicates that that module is deprecated in that perl version and is scheduled for removal from core at some future point.</source>
          <target state="translated">펄 버전과 모듈 이름을 기준으로 해시 해시. 모듈이 정의 된 경우 해당 perl 버전에서 해당 모듈이 더 이상 사용되지 않으며 향후 코어에서 코어에서 제거 될 예정임을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="3ce60ae7ced566f5220eb260ad49e428425ac3a8" translate="yes" xml:space="preserve">
          <source>A hash of hashes that is keyed on perl version as indicated in $]. The second level hash is module =&amp;gt; version pairs.</source>
          <target state="translated">$]에 표시된대로 펄 버전에서 키를 생성하는 해시 해시. 두 번째 수준의 해시는 모듈 =&amp;gt; 버전 쌍입니다.</target>
        </trans-unit>
        <trans-unit id="2c10d53a97cb7fcb7d7054e473e3b77644c85cb9" translate="yes" xml:space="preserve">
          <source>A hash of hashes that is keyed on perl version as indicated in $]. The second level hash is utility / defined pairs.</source>
          <target state="translated">$]에 표시된대로 perl 버전에서 키가 지정된 해시의 해시입니다. 두 번째 수준 해시는 유틸리티 / 정의 된 쌍입니다.</target>
        </trans-unit>
        <trans-unit id="5c605211961bb9e43df625e92f911448dae2ef07" translate="yes" xml:space="preserve">
          <source>A hash of modules that are needed to build your module but not run it.</source>
          <target state="translated">모듈을 빌드하지만 실행하지는 않는 모듈 해시.</target>
        </trans-unit>
        <trans-unit id="e6392db0e8aa8a4e0a54f37942aac32926d2e82c" translate="yes" xml:space="preserve">
          <source>A hash of modules that are needed to run your module. The keys are the module names ie. Test::More, and the minimum version is the value. If the required version number is 0 any version will do.</source>
          <target state="translated">모듈을 실행하는 데 필요한 모듈 해시. 키는 모듈 이름입니다. Test :: More 및 최소 버전이 값입니다. 필요한 버전 번호가 0이면 모든 버전이 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="1e045c2b4c33d3a322a7c93d405ec1e436652383" translate="yes" xml:space="preserve">
          <source>A hash of modules that are needed to run your module. The keys are the module names ie. Test::More, and the minimum version is the value. If the required version number is 0 any version will do. The versions given may be a Perl v-string (see &lt;a href=&quot;version&quot;&gt;version&lt;/a&gt;) or a range (see &lt;a href=&quot;CPAN::Meta::Requirements&quot;&gt;CPAN::Meta::Requirements&lt;/a&gt;).</source>
          <target state="translated">모듈을 실행하는 데 필요한 모듈의 해시입니다. 키는 모듈 이름입니다. Test :: More, 최소 버전은 값입니다. 필요한 버전 번호가 0이면 모든 버전이 수행됩니다. 제공된 버전은 Perl v-string ( &lt;a href=&quot;version&quot;&gt;version&lt;/a&gt; 참조 ) 또는 범위 ( &lt;a href=&quot;CPAN::Meta::Requirements&quot;&gt;CPAN :: Meta :: Requirements 참조&lt;/a&gt; ) 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="922e915de9e8740eca506cd44d1ed8c10a9b1671" translate="yes" xml:space="preserve">
          <source>A hash of modules that are needed to test your module but not run or build it.</source>
          <target state="translated">모듈을 테스트하지만 실행하거나 빌드하지 않는 데 필요한 모듈 해시.</target>
        </trans-unit>
        <trans-unit id="cd4d1c09ebac99b02cf9a7c9fa8cd90d4f94f599" translate="yes" xml:space="preserve">
          <source>A hash of modules that are required to run Makefile.PL itself, but not to run your distribution.</source>
          <target state="translated">Makefile.PL 자체를 실행하는 데 필요하지만 배포를 실행하지 않는 모듈의 해시.</target>
        </trans-unit>
        <trans-unit id="f704787fb624926417400f97106f18daa25dcf15" translate="yes" xml:space="preserve">
          <source>A hash of the POSIX realtime signal handlers. It is an extension of the standard &lt;code&gt;%SIG&lt;/code&gt; , the &lt;code&gt;$POSIX::SIGRT{SIGRTMIN}&lt;/code&gt; is roughly equivalent to &lt;code&gt;$SIG{SIGRTMIN}&lt;/code&gt; , but the right POSIX moves (see below) are made with the &lt;code&gt;POSIX::SigSet&lt;/code&gt; and &lt;code&gt;POSIX::sigaction&lt;/code&gt; instead of accessing the &lt;code&gt;%SIG&lt;/code&gt; .</source>
          <target state="translated">POSIX 실시간 신호 처리기의 해시. 이 표준의 확장 &lt;code&gt;%SIG&lt;/code&gt; 는 &lt;code&gt;$POSIX::SIGRT{SIGRTMIN}&lt;/code&gt; 거의 비슷하다 &lt;code&gt;$SIG{SIGRTMIN}&lt;/code&gt; 있지만, 올바른 POSIX 이동은 (아래 참조)로 만들어집니다 &lt;code&gt;POSIX::SigSet&lt;/code&gt; 및 &lt;code&gt;POSIX::sigaction&lt;/code&gt; 대신 액세스 &lt;code&gt;%SIG&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="28dd39596f5df333ab0f97240c1b59801abaec4f" translate="yes" xml:space="preserve">
          <source>A hash of the POSIX realtime signal handlers. It is an extension of the standard &lt;code&gt;%SIG&lt;/code&gt;, the &lt;code&gt;$POSIX::SIGRT{SIGRTMIN}&lt;/code&gt; is roughly equivalent to &lt;code&gt;$SIG{SIGRTMIN}&lt;/code&gt;, but the right POSIX moves (see below) are made with the &lt;code&gt;POSIX::SigSet&lt;/code&gt; and &lt;code&gt;POSIX::sigaction&lt;/code&gt; instead of accessing the &lt;code&gt;%SIG&lt;/code&gt;.</source>
          <target state="translated">POSIX 실시간 신호 처리기의 해시입니다. 이 표준의 확장 &lt;code&gt;%SIG&lt;/code&gt; 는 &lt;code&gt;$POSIX::SIGRT{SIGRTMIN}&lt;/code&gt; 거의 비슷하다 &lt;code&gt;$SIG{SIGRTMIN}&lt;/code&gt; 있지만, 올바른 POSIX 이동은 (아래 참조)로 만들어집니다 &lt;code&gt;POSIX::SigSet&lt;/code&gt; 및 &lt;code&gt;POSIX::sigaction&lt;/code&gt; &lt;code&gt;%SIG&lt;/code&gt; 에 액세스하는 대신 sigaction .</target>
        </trans-unit>
        <trans-unit id="60ab26088a220041ec5c97911d9e6f565f5cbd7a" translate="yes" xml:space="preserve">
          <source>A hash or array element can be true only if it's defined and defined only if it exists, but the reverse doesn't necessarily hold true.</source>
          <target state="translated">해시 또는 배열 요소는 존재하는 경우에만 정의되고 정의 된 경우에만 true 일 수 있지만 그 반대의 경우도 마찬가지입니다.</target>
        </trans-unit>
        <trans-unit id="0bf79c7c035d7be8a20888854f2234466da28ff7" translate="yes" xml:space="preserve">
          <source>A hash reference containing various parsing options (see below)</source>
          <target state="translated">다양한 파싱 옵션을 포함하는 해시 참조 (아래 참조)</target>
        </trans-unit>
        <trans-unit id="71468d46c3d10b4d4aab17a5abca352e48601869" translate="yes" xml:space="preserve">
          <source>A hash represents a set of key/value pairs:</source>
          <target state="translated">해시는 일련의 키 / 값 쌍을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="10f78a1f223b35e25505609f4916f6f91875834d" translate="yes" xml:space="preserve">
          <source>A hash that contains information on the appropriate bug tracker for each core module.</source>
          <target state="translated">각 코어 모듈에 대한 적절한 버그 추적기에 대한 정보가 포함 된 해시.</target>
        </trans-unit>
        <trans-unit id="567327a8b7280b6715ced030a81d31782682314b" translate="yes" xml:space="preserve">
          <source>A hash that contains information on where patches should be directed for each core module.</source>
          <target state="translated">각 코어 모듈에 대한 패치를 지시해야하는 위치에 대한 정보가 포함 된 해시.</target>
        </trans-unit>
        <trans-unit id="9f6e2604d963e87b1664555e25f241bb06bae1e9" translate="yes" xml:space="preserve">
          <source>A hash that maps from each Pod filespec to its pod-name (like &quot;/whatever/plib/Stuff/Thing.pm&quot; =&amp;gt; &quot;Stuff::Thing&quot;)</source>
          <target state="translated">각 포드 파일 사양에서 해당 포드 이름으로 매핑되는 해시 (예 : &quot;/whatever/plib/Stuff/Thing.pm&quot;=&amp;gt; &quot;Stuff :: Thing&quot;)</target>
        </trans-unit>
        <trans-unit id="215fe982a4e5c65f0b82e82b7b97c0bfc5c0deef" translate="yes" xml:space="preserve">
          <source>A hash that maps from each pod-name to the filespec (like &quot;Stuff::Thing&quot; =&amp;gt; &quot;/whatever/plib/Stuff/Thing.pm&quot;)</source>
          <target state="translated">각 포드 이름에서 파일 사양으로 매핑되는 해시 (예 : &quot;Stuff :: Thing&quot;=&amp;gt; &quot;/whatever/plib/Stuff/Thing.pm&quot;)</target>
        </trans-unit>
        <trans-unit id="bb3108415359d307ae0dd29af4dd93824067960c" translate="yes" xml:space="preserve">
          <source>A hashref of items to add to the CPAN Meta file (</source>
          <target state="translated">CPAN 메타 파일에 추가 할 항목의 해시 참조 (</target>
        </trans-unit>
        <trans-unit id="b8c62243e4644d3b1d9b849dccb04e48b7d5ff46" translate="yes" xml:space="preserve">
          <source>A hashref of options may be appended to modify the request.</source>
          <target state="translated">요청을 수정하기 위해 옵션의 해시 참조를 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="039b44468fab1aa4f939b768b655c31c005e5690" translate="yes" xml:space="preserve">
          <source>A hashref with one or more of the keys &lt;code&gt;distribution&lt;/code&gt; , &lt;code&gt;module&lt;/code&gt; , &lt;code&gt;perl&lt;/code&gt; , &lt;code&gt;perlconfig&lt;/code&gt; , and &lt;code&gt;env&lt;/code&gt; that specify whether a document is targeted at a specific CPAN distribution or installation. Keys prefixed with &lt;code&gt;not_&lt;/code&gt; negates the corresponding match.</source>
          <target state="translated">문서가 특정 CPAN 배포 또는 설치를 대상으로하는지 여부를 지정하는 하나 이상의 키 &lt;code&gt;distribution&lt;/code&gt; , &lt;code&gt;module&lt;/code&gt; , &lt;code&gt;perl&lt;/code&gt; , &lt;code&gt;perlconfig&lt;/code&gt; 및 &lt;code&gt;env&lt;/code&gt; 가있는 해시 참조 . &lt;code&gt;not_&lt;/code&gt; 접두사가 붙은 키 는 해당 일치를 무효화합니다.</target>
        </trans-unit>
        <trans-unit id="8c60ca8fe75e29a9dfda50be5b6bb79ab9c86c02" translate="yes" xml:space="preserve">
          <source>A heading (&lt;code&gt;=head1&lt;/code&gt; or &lt;code&gt;=head2&lt;/code&gt; ) without any text? That ain't no heading!</source>
          <target state="translated">텍스트가없는 제목 ( &lt;code&gt;=head1&lt;/code&gt; 또는 &lt;code&gt;=head2&lt;/code&gt; )? 그것은 제목이 아닙니다!</target>
        </trans-unit>
        <trans-unit id="e61f2f28c623b8bf615200619cdf69dae431768b" translate="yes" xml:space="preserve">
          <source>A heading (&lt;code&gt;=head1&lt;/code&gt; or &lt;code&gt;=head2&lt;/code&gt;) without any text? That ain't no heading!</source>
          <target state="translated">텍스트가없는 제목 ( &lt;code&gt;=head1&lt;/code&gt; 또는 &lt;code&gt;=head2&lt;/code&gt; )? 제목이 아닙니다!</target>
        </trans-unit>
        <trans-unit id="f9832f7772423825e7be09c103f042abd3956ccc" translate="yes" xml:space="preserve">
          <source>A hex dump of &lt;code&gt;$berbuf&lt;/code&gt; , with spaces inserted at the right places, shows 01 8100 8101 81807F. Since the last byte is always less than 128, &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; knows where to stop.</source>
          <target state="translated">올바른 위치에 공백이 삽입 된 &lt;code&gt;$berbuf&lt;/code&gt; 의 16 진 덤프 는 01 8100 8101 81807F를 보여줍니다. 마지막 바이트는 항상 128보다 작으므로 &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; 은 중지 할 위치를 알고 있습니다.</target>
        </trans-unit>
        <trans-unit id="e25c820f972869adef22f733ce82d7969564bd8d" translate="yes" xml:space="preserve">
          <source>A hex dump of &lt;code&gt;$berbuf&lt;/code&gt;, with spaces inserted at the right places, shows 01 8100 8101 81807F. Since the last byte is always less than 128, &lt;code&gt;unpack&lt;/code&gt; knows where to stop.</source>
          <target state="translated">올바른 위치에 공백이 삽입 된 &lt;code&gt;$berbuf&lt;/code&gt; 의 16 진 덤프 는 01 8100 8101 81807F를 표시합니다. 마지막 바이트는 항상 128보다 작기 때문에 &lt;code&gt;unpack&lt;/code&gt; 은 중지 할 위치를 알고 있습니다.</target>
        </trans-unit>
        <trans-unit id="e2983a66dc1728b3d6b6e5a9cf2faed1865191ff" translate="yes" xml:space="preserve">
          <source>A hex dump of the bytes in field in the order they are stored in the zip file.</source>
          <target state="translated">zip 파일에 저장된 순서대로 필드에있는 바이트의 16 진 덤프.</target>
        </trans-unit>
        <trans-unit id="b40a76a5eb1fbe1d4b01f9b8fcd76ad6df4acf92" translate="yes" xml:space="preserve">
          <source>A hex string consists of hex digits and an optional &lt;code&gt;0x&lt;/code&gt; or &lt;code&gt;x&lt;/code&gt; prefix. Each hex digit may be preceded by a single underscore, which will be ignored. Any other character triggers a warning and causes the rest of the string to be ignored (even leading whitespace, unlike &lt;a href=&quot;#oct-EXPR&quot;&gt;&lt;code&gt;oct&lt;/code&gt;&lt;/a&gt;). Only integers can be represented, and integer overflow triggers a warning.</source>
          <target state="translated">16 진 문자열은 16 진 숫자와 선택적 &lt;code&gt;0x&lt;/code&gt; 또는 &lt;code&gt;x&lt;/code&gt; 접두사로 구성됩니다. 각 16 진 숫자 앞에는 단일 밑줄이 올 수 있으며 무시됩니다. 다른 모든 문자는 경고를 트리거하고 나머지 문자열을 무시합니다 ( &lt;a href=&quot;#oct-EXPR&quot;&gt; &lt;code&gt;oct&lt;/code&gt; &lt;/a&gt; 와 달리 선행 공백 포함 ). 정수만 표시 할 수 있으며 정수 오버플로는 경고를 트리거합니다.</target>
        </trans-unit>
        <trans-unit id="38e7070b1f249f379f9a778af2f10d3b11497505" translate="yes" xml:space="preserve">
          <source>A hierarchy of &quot;categories&quot; have been defined to allow groups of warnings to be enabled/disabled in isolation.</source>
          <target state="translated">&quot;범주&quot;계층이 정의되어 경고 그룹을 개별적으로 활성화 / 비활성화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="536684f67238bfdb66acbda52de51ea79291a12f" translate="yes" xml:space="preserve">
          <source>A is the root class, B is a subclass of A, C is a subclass of B, and D is another subclass of A.</source>
          <target state="translated">A는 루트 클래스이고 B는 A의 서브 클래스, C는 B의 서브 클래스, D는 A의 다른 서브 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="8f3e40034aa0308d28f4dfc54288a8825f6cfd1e" translate="yes" xml:space="preserve">
          <source>A kind of &lt;b&gt;overloading&lt;/b&gt; that you can do on built-in &lt;b&gt;operators&lt;/b&gt; to make them work on &lt;b&gt;objects&lt;/b&gt; as if the objects were ordinary scalar values, but with the actual semantics supplied by the object class. This is set up with the overload &lt;b&gt;pragma&lt;/b&gt;&amp;mdash;see Camel chapter 13, &amp;ldquo;Overloading&amp;rdquo;.</source>
          <target state="translated">의 종류 &lt;b&gt;과부하&lt;/b&gt; 당신이 내장에 할 수있는 &lt;b&gt;사업자하기&lt;/b&gt; 에 그들을 작동하도록 &lt;b&gt;객체를&lt;/b&gt; 객체가 있지만, 객체 클래스에서 제공하는 실제 의미와, 일반 스칼라 값 인 것처럼. 이것은 과부하 &lt;b&gt;pragma&lt;/b&gt; 와 함께 설정됩니다. Camel 13 장, &quot;오버로딩&quot;을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="e9cfe5685ea0ecd4847a06232a077cb874b35be7" translate="yes" xml:space="preserve">
          <source>A kind of action that an &lt;b&gt;object&lt;/b&gt; can take if you tell it to. See Camel chapter 12, &amp;ldquo;Objects&amp;rdquo;.</source>
          <target state="translated">당신이 말하면 &lt;b&gt;객체&lt;/b&gt; 가 취할 수 있는 행동 . 낙타 12 장 &quot;객체&quot;를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="dfe222b0c92a8225eafa0e0da38f08258e2a6e75" translate="yes" xml:space="preserve">
          <source>A kind of key or name attached to a loop (or roller coaster) so that loop control statements can talk about which loop they want to control.</source>
          <target state="translated">루프 제어문이 제어하려는 루프에 대해 이야기 할 수 있도록 루프 (또는 롤러 코스터)에 부착 된 일종의 키 또는 이름입니다.</target>
        </trans-unit>
        <trans-unit id="e7d72d06babc67750c6b28a2b28bed949fa33a88" translate="yes" xml:space="preserve">
          <source>A kinder, gentler tutorial on object-oriented programming in Perl can be found in &lt;a href=&quot;perlootut&quot;&gt;perlootut&lt;/a&gt;. You should also check out &lt;a href=&quot;perlmodlib&quot;&gt;perlmodlib&lt;/a&gt; for some style guides on constructing both modules and classes.</source>
          <target state="translated">Perl의 객체 지향 프로그래밍에 대한 더 친절하고 부드러운 튜토리얼은 &lt;a href=&quot;perlootut&quot;&gt;perlootut&lt;/a&gt; 에서 찾을 수 있습니다 . 또한 모듈과 클래스를 구성하는 데 대한 일부 스타일 안내서는 &lt;a href=&quot;perlmodlib&quot;&gt;perlmodlib&lt;/a&gt; 를 확인해야합니다 .</target>
        </trans-unit>
        <trans-unit id="b68c5f288b44308b58cb523d3e60b493b484f9c4" translate="yes" xml:space="preserve">
          <source>A language beloved by many for its inside-out &lt;b&gt;type&lt;/b&gt; definitions, inscrutable &lt;b&gt;precedence&lt;/b&gt; rules, and heavy &lt;b&gt;overloading&lt;/b&gt; of the function-call mechanism. (Well, actually, people first switched to C because they found lowercase identifiers easier to read than upper.) Perl is written in C, so it&amp;rsquo;s not surprising that Perl borrowed a few ideas from it.</source>
          <target state="translated">많은 사람들이 내부 &lt;b&gt;형식&lt;/b&gt; 정의, 불가피한 &lt;b&gt;우선 순위&lt;/b&gt; 규칙 및 함수 호출 메커니즘의 &lt;b&gt;과부하&lt;/b&gt; 로 인해 사랑받는 언어 입니다. (실제로 사람들은 대문자보다 소문자 식별자를 읽기 쉽기 때문에 먼저 C로 전환했습니다.) Perl은 C로 작성되었으므로 Perl이 몇 가지 아이디어를 빌린 것은 놀라운 일이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="7a70c2d1db9e3781c948c3f568d555da43db83b2" translate="yes" xml:space="preserve">
          <source>A language class is a class containing a lexicon of phrases as class data, and possibly also some methods that are of use in interpreting phrases in the lexicon, or otherwise dealing with text in that language.</source>
          <target state="translated">언어 클래스는 구문 데이터를 클래스 데이터로 포함하는 클래스이며 어휘의 구문을 해석하거나 해당 언어의 텍스트를 처리하는 데 사용되는 일부 메소드 일 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="c64c47113f6df7e33ad198a5fed1bb8f3af6d13f" translate="yes" xml:space="preserve">
          <source>A language handle is a flyweight object -- i.e., it doesn't (necessarily) carry any data of interest, other than just being a member of whatever class it belongs to.</source>
          <target state="translated">언어 핸들은 플라이급 객체입니다. 즉, 클래스가 속한 클래스의 멤버가 아닌 관심있는 데이터를 (필요하게) 가지고 있지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c3a083f1f9c38b9c0d77465662a942c4c5d48d8d" translate="yes" xml:space="preserve">
          <source>A language handle is implemented as a blessed hash. Subclasses of yours can store whatever data you want in the hash. Currently the only hash entry used by any crucial Maketext method is &quot;fail&quot;, so feel free to use anything else as you like.</source>
          <target state="translated">언어 핸들은 축복 된 해시로 구현됩니다. 서브 클래스는 원하는 데이터를 해시에 저장할 수 있습니다. 현재 중요한 Maketext 메서드에서 사용하는 유일한 해시 항목은 &quot;실패&quot;이므로 원하는대로 자유롭게 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="9fb1cb589c473c75eb212d9b744da125c770bad8" translate="yes" xml:space="preserve">
          <source>A language such as Perl that is good at hooking things together that weren&amp;rsquo;t intended to be hooked together.</source>
          <target state="translated">서로 연결되어 있지 않은 것을 연결하는 데 유용한 Perl과 같은 언어입니다.</target>
        </trans-unit>
        <trans-unit id="7ea3dfebe2530a429cde54a5f0bc78f862792455" translate="yes" xml:space="preserve">
          <source>A large scalar that you know can only contain ASCII</source>
          <target state="translated">아는 큰 스칼라에는 ASCII 만 포함 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8078fbdb7cd614c0fbe18240c94f727ccdf4ed5e" translate="yes" xml:space="preserve">
          <source>A layer can be added that does &quot;\n&quot; to CRLF translation. This layer can be used on any platform, not just those that normally do such things.</source>
          <target state="translated">CRLF 변환에서 &quot;\ n&quot;을 수행하는 레이어를 추가 할 수 있습니다. 이 계층은 일반적으로 이러한 작업을 수행하는 플랫폼뿐만 아니라 모든 플랫폼에서 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c418f05188c75b7cf5ccc4221979555d292c85f1" translate="yes" xml:space="preserve">
          <source>A layer contains a &quot;vtable&quot;, the table of I/O operations (at C level a table of function pointers), and status flags. The functions in the vtable implement operations like &quot;open&quot;, &quot;read&quot;, and &quot;write&quot;.</source>
          <target state="translated">계층에는 &quot;vtable&quot;, I / O 작업 테이블 (C 수준에서 함수 포인터 테이블) 및 상태 플래그가 포함됩니다. vtable의 함수는 &quot;open&quot;, &quot;read&quot;및 &quot;write&quot;와 같은 작업을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="4f0330995dfa2fce16816cd443c9581a48699cf3" translate="yes" xml:space="preserve">
          <source>A layer derived using &quot;perlio&quot; as a base class. It provides Win32-like &quot;\n&quot; to CR,LF translation. Can either be applied above &quot;perlio&quot; or serve as the buffer layer itself. &quot;crlf&quot; over &quot;unix&quot; is the default if system distinguishes between &lt;code&gt;O_TEXT&lt;/code&gt; and &lt;code&gt;O_BINARY&lt;/code&gt; opens. (At some point &quot;unix&quot; will be replaced by a &quot;native&quot; Win32 IO layer on that platform, as Win32's read/write layer has various drawbacks.) The &quot;crlf&quot; layer is a reasonable model for a layer which transforms data in some way.</source>
          <target state="translated">&quot;perlio&quot;를 기본 클래스로 사용하여 파생 된 레이어입니다. CR, LF 로의 Win32와 유사한 &quot;\ n&quot;을 제공합니다. &quot;perlio&quot;위에 적용하거나 버퍼 계층 자체로 사용할 수 있습니다. 시스템이 &lt;code&gt;O_TEXT&lt;/code&gt; 와 &lt;code&gt;O_BINARY&lt;/code&gt; 를 구별 할 경우 &quot;unix&quot;보다 &quot;crlf&quot;가 기본값이됩니다 . (Win32의 읽기 / 쓰기 레이어에는 여러 가지 단점이 있기 때문에 &quot;유닉스&quot;는 플랫폼에서 &quot;네이티브&quot;Win32 IO 레이어로 대체 될 것입니다.) &quot;crlf&quot;레이어는 일부 데이터를 변환하는 레이어에 대한 합리적인 모델입니다. 방법.</target>
        </trans-unit>
        <trans-unit id="c575f3b4bff37dcf26ab538523523b73298b17f9" translate="yes" xml:space="preserve">
          <source>A layer does not have to implement all the functions, but the whole table has to be present. Unimplemented slots can be NULL (which will result in an error when called) or can be filled in with stubs to &quot;inherit&quot; behaviour from a &quot;base class&quot;. This &quot;inheritance&quot; is fixed for all instances of the layer, but as the layer chooses which stubs to populate the table, limited &quot;multiple inheritance&quot; is possible.</source>
          <target state="translated">레이어가 모든 기능을 구현할 필요는 없지만 전체 테이블이 있어야합니다. 구현되지 않은 슬롯은 NULL (호출시 오류 발생)이거나 &quot;기본 클래스&quot;에서 &quot;상속&quot;동작을위한 스텁으로 채워질 수 있습니다. 이 &quot;상속&quot;은 계층의 모든 인스턴스에 대해 고정되어 있지만 계층이 테이블을 채울 스텁을 선택함에 따라 제한된 &quot;다중 상속&quot;이 가능합니다.</target>
        </trans-unit>
        <trans-unit id="f3c275bcbbeb5e10eabf8b5098a80ac8ed647d3b" translate="yes" xml:space="preserve">
          <source>A layer implementing &quot;in memory&quot; files using scalar variables, automatically used in place of the platform defaults for IO when opening such a handle. As such, the scalar is expected to act like a file, only containing or storing bytes. See &lt;a href=&quot;PerlIO::scalar&quot;&gt;PerlIO::scalar&lt;/a&gt; for more information.</source>
          <target state="translated">이러한 핸들을 열 때 IO에 대한 플랫폼 기본값 대신 자동으로 사용되는 스칼라 변수를 사용하여 &quot;메모리 내&quot;파일을 구현하는 계층입니다. 따라서 스칼라는 바이트 만 포함하거나 저장하는 파일처럼 작동 할 것으로 예상됩니다. 자세한 내용은 &lt;a href=&quot;PerlIO::scalar&quot;&gt;PerlIO :: scalar&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="7f64a4152a5af0c9ac4baa66afb914d700fb3ea6" translate="yes" xml:space="preserve">
          <source>A layer that implements &quot;reading&quot; of files by using</source>
          <target state="translated">다음을 사용하여 파일의 &quot;읽기&quot;를 구현하는 계층</target>
        </trans-unit>
        <trans-unit id="29bee167ef354a3d46f2326d367f6d5e9ab52d50" translate="yes" xml:space="preserve">
          <source>A layer that implements DOS/Windows like CRLF line endings. On read converts pairs of CR,LF to a single &quot;\n&quot; newline character. On write converts each &quot;\n&quot; to a CR,LF pair. Note that this layer will silently refuse to be pushed on top of itself.</source>
          <target state="translated">CRLF 줄 끝과 같은 DOS / Windows를 구현하는 계층입니다. 읽기시 CR, LF 쌍을 단일 &quot;\ n&quot;줄 바꿈 문자로 변환합니다. 쓰기시 각 &quot;\ n&quot;을 CR, LF 쌍으로 변환합니다. 이 레이어는 자동으로 푸시되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="49890359753a7b7c09475de22e069c5121e36bd2" translate="yes" xml:space="preserve">
          <source>A layer which does CRLF to &lt;code&gt;&quot;\n&quot;&lt;/code&gt; translation distinguishing &quot;text&quot; and &quot;binary&quot; files in the manner of MS-DOS and similar operating systems, and also provides buffering similar to &lt;code&gt;:perlio&lt;/code&gt; on these architectures.</source>
          <target state="translated">MS-DOS 및 유사한 운영 체제의 방식으로 &quot;텍스트&quot;및 &quot;바이너리&quot;파일을 구분 하는 &lt;code&gt;&quot;\n&quot;&lt;/code&gt; 변환을 CRLF하는 계층이며 이러한 아키텍처 에서 &lt;code&gt;:perlio&lt;/code&gt; 와 유사한 버퍼링도 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="a9b39500363434cc0ff0f52b520ce130f3b3a554" translate="yes" xml:space="preserve">
          <source>A layer which does CRLF to &lt;code&gt;&quot;\n&quot;&lt;/code&gt; translation distinguishing &quot;text&quot; and &quot;binary&quot; files in the manner of MS-DOS and similar operating systems. (It currently does</source>
          <target state="translated">MS-DOS 및 유사한 운영 체제의 방식으로 &quot;텍스트&quot;및 &quot;이진&quot;파일을 구별 하는 CRLF를 &lt;code&gt;&quot;\n&quot;&lt;/code&gt; 변환 하는 계층입니다 . (현재는</target>
        </trans-unit>
        <trans-unit id="d99ca2d73d6bc9954c1f5d38358ae63b3448d053" translate="yes" xml:space="preserve">
          <source>A layer which implements &quot;reading&quot; of files by using &lt;code&gt;mmap()&lt;/code&gt; to make a (whole) file appear in the process's address space, and then using that as PerlIO's &quot;buffer&quot;. This</source>
          <target state="translated">&lt;code&gt;mmap()&lt;/code&gt; 을 사용하여 (전체) 파일을 프로세스의 주소 공간에 표시 한 다음이를 PerlIO의 &quot;버퍼&quot; 로 사용하여 파일의 &quot;읽기&quot;를 구현하는 계층입니다 . 이</target>
        </trans-unit>
        <trans-unit id="fd687d324576d9173f6d5752bc85ac325e3d235f" translate="yes" xml:space="preserve">
          <source>A layer which provides the PerlIO API via the layer scheme, but implements it by calling system's stdio. This is (currently) the default if system's stdio provides sufficient access to allow perl's &quot;fast gets&quot; access and which do not distinguish between &lt;code&gt;O_TEXT&lt;/code&gt; and &lt;code&gt;O_BINARY&lt;/code&gt; .</source>
          <target state="translated">계층 체계를 통해 PerlIO API를 제공하지만 시스템의 stdio를 호출하여 구현하는 계층입니다. 시스템의 stdio가 perl의 &quot;빠른 가져 &lt;code&gt;O_TEXT&lt;/code&gt; &quot;액세스를 허용하기에 충분한 액세스를 제공하고 O_TEXT 와 &lt;code&gt;O_BINARY&lt;/code&gt; 를 구분하지 않는 경우 이는 현재의 기본값 입니다.</target>
        </trans-unit>
        <trans-unit id="05d6c08e7d4d9ce599909cfee99a9592e335ccd5" translate="yes" xml:space="preserve">
          <source>A layer which provides the PerlIO API via the layer scheme, but implements it by calling system's stdio. This is (currently) the default if system's stdio provides sufficient access to allow perl's &quot;fast gets&quot; access and which do not distinguish between &lt;code&gt;O_TEXT&lt;/code&gt; and &lt;code&gt;O_BINARY&lt;/code&gt;.</source>
          <target state="translated">계층 체계를 통해 PerlIO API를 제공하지만 시스템의 stdio를 호출하여 구현하는 계층입니다. 이것은 (현재) 시스템의 stdio가 perl의 &quot;빠른 가져 &lt;code&gt;O_TEXT&lt;/code&gt; &quot;액세스를 허용하기에 충분한 액세스를 제공하고 O_TEXT 와 &lt;code&gt;O_BINARY&lt;/code&gt; 를 구분하지 않는 경우 기본값 입니다.</target>
        </trans-unit>
        <trans-unit id="1841e889a880ebb77b0a2697210c6744f8df031b" translate="yes" xml:space="preserve">
          <source>A leading ! indicates that matching names should be deleted from the list of names to import. If the first specification is a deletion it is treated as though preceded by :DEFAULT. If you just want to import extra names in addition to the default set you will still need to include :DEFAULT explicitly.</source>
          <target state="translated">최고의! 가져올 이름 목록에서 일치하는 이름을 삭제해야 함을 나타냅니다. 첫 번째 스펙이 삭제 인 경우 앞에 : DEFAULT가있는 것처럼 처리됩니다. 기본 설정 외에 추가 이름을 가져 오려면 여전히 명시 적으로 : DEFAULT를 포함해야합니다.</target>
        </trans-unit>
        <trans-unit id="f747bcc2647296135613b88a3e62cca47b6c1dc6" translate="yes" xml:space="preserve">
          <source>A leading colon removes the &quot;name=&quot; part of the response, this allows you to map to the name you need. (mnemonic: empty label)</source>
          <target state="translated">선행 콜론은 응답의 &quot;name =&quot;부분을 제거하므로 필요한 이름으로 매핑 할 수 있습니다. (니모닉 : 빈 라벨)</target>
        </trans-unit>
        <trans-unit id="96fa00367bcfdb4784c34a4a3babbe9475afc22d" translate="yes" xml:space="preserve">
          <source>A legally formed name for most anything in which a computer program might be interested. Many languages (including Perl) allow identifiers to start with an alphabetic character, and then contain alphabetics and digits. Perl also allows connector punctuation like the underscore character wherever it allows alphabetics. (Perl also has more complicated names, like &lt;b&gt;qualified&lt;/b&gt; names.)</source>
          <target state="translated">컴퓨터 프로그램이 관심을 가질만한 모든 것을 합법적으로 정립 한 이름입니다. Perl을 포함한 많은 언어는 식별자가 알파벳 문자로 시작한 다음 알파벳과 숫자를 포함 할 수 있습니다. 펄은 알파벳 문자를 허용하는 곳이라면 밑줄 문자와 같은 커넥터 구두점을 허용합니다. (Perl에는 &lt;b&gt;규정 된&lt;/b&gt; 이름 과 같이 더 복잡한 이름도 있습니다 .)</target>
        </trans-unit>
        <trans-unit id="69d4d84a09fc968a07bdda5a53812534fa74783b" translate="yes" xml:space="preserve">
          <source>A library only needs to deal with unsigned big integers. Testing of input parameter validity is done by the caller, so there is no need to worry about underflow (e.g., in &lt;code&gt;_sub()&lt;/code&gt; and &lt;code&gt;_dec()&lt;/code&gt; ) nor about division by zero (e.g., in &lt;code&gt;_div()&lt;/code&gt; ) or similar cases.</source>
          <target state="translated">라이브러리는 부호없는 큰 정수만 처리하면됩니다. 입력 매개 변수 유효성 테스트는 호출자가 수행하므로 언더 플로 (예 : &lt;code&gt;_sub()&lt;/code&gt; 및 &lt;code&gt;_dec()&lt;/code&gt; ) 나 0으로 나누기 (예 : &lt;code&gt;_div()&lt;/code&gt; ) 또는 이와 유사한 경우에 대해 걱정할 필요가 없습니다 .</target>
        </trans-unit>
        <trans-unit id="d63d0720eeb53645d19249b7b0b30c1e9040b91f" translate="yes" xml:space="preserve">
          <source>A library only needs to deal with unsigned big integers. Testing of input parameter validity is done by the caller, so there is no need to worry about underflow (e.g., in &lt;code&gt;_sub()&lt;/code&gt; and &lt;code&gt;_dec()&lt;/code&gt;) or about division by zero (e.g., in &lt;code&gt;_div()&lt;/code&gt; and &lt;code&gt;_mod()&lt;/code&gt;)) or similar cases.</source>
          <target state="translated">라이브러리는 부호없는 큰 정수만 처리하면됩니다. 입력 매개 변수 유효성 테스트는 호출자가 수행하므로 언더 플로 (예 : &lt;code&gt;_sub()&lt;/code&gt; 및 &lt;code&gt;_dec()&lt;/code&gt; ) 또는 0으로 나누기에 대해 걱정할 필요가 없습니다 (예 : &lt;code&gt;_div()&lt;/code&gt; 및 &lt;code&gt;_mod()&lt;/code&gt; )). 또는 유사한 경우.</target>
        </trans-unit>
        <trans-unit id="3bf7193a51535e24fe6d6e597b0723102b292f35" translate="yes" xml:space="preserve">
          <source>A line</source>
          <target state="translated">라인</target>
        </trans-unit>
        <trans-unit id="0b89fa4e541f30b4e921956619e05676831d4d1c" translate="yes" xml:space="preserve">
          <source>A line number may be prefixed by a single letter:</source>
          <target state="translated">줄 번호 앞에는 단일 문자가 붙을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2d89336c3df3636aebec0ee20d5e9be98d7da075" translate="yes" xml:space="preserve">
          <source>A line-oriented form of quoting is based on the shell &quot;here-document&quot; syntax. Following a &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; you specify a string to terminate the quoted material, and all lines following the current line down to the terminating string are the value of the item.</source>
          <target state="translated">따옴표로 묶인 행 형식은 &quot;here-document&quot;쉘 구문을 기반으로합니다. &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; 다음에 인용 된 재료를 종료 할 문자열을 지정하고 현재 줄 다음에 끝나는 문자열까지의 모든 줄은 항목의 값입니다.</target>
        </trans-unit>
        <trans-unit id="ba737ca3db1e413142acc2b22e379ceb469071d3" translate="yes" xml:space="preserve">
          <source>A list containing a single undef, in list context</source>
          <target state="translated">목록 컨텍스트에서 단일 undef를 포함하는 목록</target>
        </trans-unit>
        <trans-unit id="75e8b52d2267761231a600214a302dc93a9097e4" translate="yes" xml:space="preserve">
          <source>A list introduced by &lt;code&gt;=over&lt;/code&gt; starts with a text or verbatim paragraph, but continues with &lt;code&gt;=item&lt;/code&gt; s. Move the non-item paragraph out of the &lt;code&gt;=over&lt;/code&gt; /&lt;code&gt;=back&lt;/code&gt; block.</source>
          <target state="translated">&lt;code&gt;=over&lt;/code&gt; 에 의해 도입 된리스트 는 텍스트 또는 축약 단락으로 시작하지만 &lt;code&gt;=item&lt;/code&gt; 으로 계속됩니다 . 항목이 아닌 단락을 &lt;code&gt;=over&lt;/code&gt; / &lt;code&gt;=back&lt;/code&gt; 블록 밖으로 이동하십시오 .</target>
        </trans-unit>
        <trans-unit id="1e132d5a818c0fde195a981571859eee6be87b1c" translate="yes" xml:space="preserve">
          <source>A list introduced by &lt;code&gt;=over&lt;/code&gt; starts with a text or verbatim paragraph, but continues with &lt;code&gt;=item&lt;/code&gt;s. Move the non-item paragraph out of the &lt;code&gt;=over&lt;/code&gt;/&lt;code&gt;=back&lt;/code&gt; block.</source>
          <target state="translated">&lt;code&gt;=over&lt;/code&gt; 에 의해 도입 된 목록 은 텍스트 또는 축 어적 단락으로 시작하지만 &lt;code&gt;=item&lt;/code&gt; 으로 계속됩니다 . 항목이 아닌 단락을 &lt;code&gt;=over&lt;/code&gt; / &lt;code&gt;=back&lt;/code&gt; 블록 밖으로 이동합니다 .</target>
        </trans-unit>
        <trans-unit id="9aee76ae2469acd57d2557387480876b03411474" translate="yes" xml:space="preserve">
          <source>A list is a fixed collection of scalars. An array is a variable that holds a variable collection of scalars. An array can supply its collection for list operations, so list operations also work on arrays:</source>
          <target state="translated">리스트는 고정 된 스칼라 모음입니다. 배열은 스칼라의 변수 콜렉션을 보유하는 변수입니다. 배열은 목록 작업에 대한 컬렉션을 제공 할 수 있으므로 목록 작업은 배열에서도 작동합니다.</target>
        </trans-unit>
        <trans-unit id="b201394353dbcc6ef2561ba6cd863dea90b88222" translate="yes" xml:space="preserve">
          <source>A list of additional libraries or other shared objects which can be used to resolve any undefined symbols that might be generated by a later call to load_file().</source>
          <target state="translated">나중에 load_file ()을 호출하여 생성 될 수있는 정의되지 않은 기호를 확인하는 데 사용할 수있는 추가 라이브러리 또는 기타 공유 객체의 목록입니다.</target>
        </trans-unit>
        <trans-unit id="e216fd26bc604e567680be656aeb4002407fb587" translate="yes" xml:space="preserve">
          <source>A list of all the INSTALL* variables without the INSTALL prefix. Useful for iteration or building related variable sets.</source>
          <target state="translated">INSTALL 접두어가없는 모든 INSTALL * 변수 목록 반복 또는 빌드 관련 변수 세트에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="e85ab034c5cddfa0ece70fbf99712ce6eb1bc6c8" translate="yes" xml:space="preserve">
          <source>A list of custom keys are available from the &lt;code&gt;custom_keys&lt;/code&gt; method and particular keys may be retrieved with the &lt;code&gt;custom&lt;/code&gt; method.</source>
          <target state="translated">&lt;code&gt;custom_keys&lt;/code&gt; 메서드 에서 사용자 지정 키 목록을 사용할 수 있으며 &lt;code&gt;custom&lt;/code&gt; 메서드를 사용하여 특정 키를 검색 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="94957d0f7514017339244da4cc1607583b5fc84e" translate="yes" xml:space="preserve">
          <source>A list of directories in which to look for Perl library files before looking in the standard library and the current directory. Any architecture-specific and version-specific directories, such as</source>
          <target state="translated">표준 라이브러리와 현재 디렉토리를 찾기 전에 Perl 라이브러리 파일을 찾을 디렉토리 목록. 다음과 같은 아키텍처 별 및 버전 별 디렉토리</target>
        </trans-unit>
        <trans-unit id="7103902d7143d091cfd2b7d907958a451f56b4e9" translate="yes" xml:space="preserve">
          <source>A list of directories in which to look for Perl library files before looking in the standard library and the current directory. If PERL5LIB is defined, PERLLIB is not used.</source>
          <target state="translated">표준 라이브러리와 현재 디렉토리를 찾기 전에 Perl 라이브러리 파일을 찾을 디렉토리 목록. PERL5LIB가 정의되면 PERLLIB가 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="74c3a8ebaa1190b475b719545a9be33666f3621e" translate="yes" xml:space="preserve">
          <source>A list of directories in which to look for Perl library files before looking in the standard library. Any architecture-specific and version-specific directories, such as</source>
          <target state="translated">표준 라이브러리를 찾기 전에 Perl 라이브러리 파일을 찾을 디렉토리 목록입니다. 다음과 같은 아키텍처 별 및 버전 별 디렉토리</target>
        </trans-unit>
        <trans-unit id="39b17875309177ed716e25c72207fa65946c2db9" translate="yes" xml:space="preserve">
          <source>A list of directories in which to look for Perl library files before looking in the standard library. If &lt;a href=&quot;#PERL5LIB&quot;&gt;&quot;PERL5LIB&quot;&lt;/a&gt; is defined, PERLLIB is not used.</source>
          <target state="translated">표준 라이브러리를 찾기 전에 Perl 라이브러리 파일을 찾을 디렉토리 목록입니다. 경우 &lt;a href=&quot;#PERL5LIB&quot;&gt;&quot;PERL5LIB가&quot;&lt;/a&gt; 정의, PERLLIB은 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f3cc07c6f57898b2ef6aaadd57be04cf61845061" translate="yes" xml:space="preserve">
          <source>A list of directory paths. If the input file does not exist, then it will be searched for in the given directory list (in the order the directories appear in the list). It defaults to the list of directories implied by &lt;code&gt;$ENV{PATH}&lt;/code&gt; . The list may be specified either by a reference to an array, or by a string of directory paths which use the same path separator as &lt;code&gt;$ENV{PATH}&lt;/code&gt; on your system (e.g., &lt;code&gt;:&lt;/code&gt; for Unix, &lt;code&gt;;&lt;/code&gt; for MSWin32 and DOS).</source>
          <target state="translated">디렉토리 경로 목록. 입력 파일이 존재하지 않으면 주어진 디렉토리 목록에서 디렉토리가 목록에 나타나는 순서대로 검색됩니다. &lt;code&gt;$ENV{PATH}&lt;/code&gt; 의해 암시 된 디렉토리 목록이 기본값 입니다. 이 목록은 배열에 대한 참조 또는 시스템에서 &lt;code&gt;$ENV{PATH}&lt;/code&gt; 와 동일한 경로 구분 기호를 사용하는 디렉토리 경로 문자열로 지정 될 수 있습니다 (예 &lt;code&gt;:&lt;/code&gt; Unix의 경우 &lt;code&gt;;&lt;/code&gt; MSWin32 및 DOS의 경우).</target>
        </trans-unit>
        <trans-unit id="f2a928fe21ff1b5f7955724187f967a836701c95" translate="yes" xml:space="preserve">
          <source>A list of directory paths. If the input file does not exist, then it will be searched for in the given directory list (in the order the directories appear in the list). It defaults to the list of directories implied by &lt;code&gt;$ENV{PATH}&lt;/code&gt;. The list may be specified either by a reference to an array, or by a string of directory paths which use the same path separator as &lt;code&gt;$ENV{PATH}&lt;/code&gt; on your system (e.g., &lt;code&gt;:&lt;/code&gt; for Unix, &lt;code&gt;;&lt;/code&gt; for MSWin32 and DOS).</source>
          <target state="translated">디렉토리 경로 목록입니다. 입력 파일이 존재하지 않으면 주어진 디렉토리 목록에서 검색됩니다 (디렉토리가 목록에 나타나는 순서대로). 기본값은 &lt;code&gt;$ENV{PATH}&lt;/code&gt; 암시하는 디렉토리 목록입니다 . 목록은 배열에 대한 참조 또는 시스템에서 &lt;code&gt;$ENV{PATH}&lt;/code&gt; 와 동일한 경로 구분 기호를 사용하는 디렉토리 경로 문자열로 지정 될 수 있습니다 (예 &lt;code&gt;:&lt;/code&gt; Unix의 경우 &lt;code&gt;;&lt;/code&gt; MSWin32 및 DOS의 경우).</target>
        </trans-unit>
        <trans-unit id="337601b93965c28568bbedd0632699f2eefded6b" translate="yes" xml:space="preserve">
          <source>A list of files in the distribution, one file per line. The MANIFEST always uses Unix filepath conventions even if you're not on Unix. This means</source>
          <target state="translated">분배에서 파일 목록 (한 줄에 하나씩). MANIFEST는 Unix를 사용하지 않는 경우에도 항상 Unix 파일 경로 규칙을 사용합니다. 이것은 의미</target>
        </trans-unit>
        <trans-unit id="0555d0b38c03024b415a75a77593c5880fa79206" translate="yes" xml:space="preserve">
          <source>A list of one or more symbol names that are in the library/object file to be dynamically loaded. This is only required on some platforms.</source>
          <target state="translated">라이브러리 / 객체 파일에 동적으로로드 될 하나 이상의 심볼 이름 목록입니다. 일부 플랫폼에서만 필요합니다.</target>
        </trans-unit>
        <trans-unit id="681b6abf464391de8dd3a7916ae06f2d521a9817" translate="yes" xml:space="preserve">
          <source>A list of pads. The first one contains the names.</source>
          <target state="translated">패드 목록. 첫 번째는 이름을 포함합니다.</target>
        </trans-unit>
        <trans-unit id="da9e40582037de588b1af66d3e9b3a340700ef73" translate="yes" xml:space="preserve">
          <source>A list of pads. The first one is a B::PADNAMELIST containing the names. The rest are currently B::AV objects, but that could change in future versions.</source>
          <target state="translated">패드 목록입니다. 첫 번째는 이름이 포함 된 B :: PADNAMELIST입니다. 나머지는 현재 B :: AV 객체이지만 향후 버전에서 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="02f9cb55d32eb52f68051c89a619f41d785a1129" translate="yes" xml:space="preserve">
          <source>A list of possible choices from which you may select only one, as in, &amp;ldquo;Would you like door A, B, or C?&amp;rdquo; Alternatives in regular expressions are separated with a single vertical bar: &lt;code&gt;|&lt;/code&gt;. Alternatives in normal Perl expressions are separated with a double vertical bar: &lt;code&gt;||&lt;/code&gt;. Logical alternatives in &lt;b&gt;Boolean&lt;/b&gt; expressions are separated with either &lt;code&gt;||&lt;/code&gt; or &lt;code&gt;or&lt;/code&gt; .</source>
          <target state="translated">&amp;ldquo;문 A, B 또는 C를 원하십니까?&amp;rdquo;에서와 같이 하나만 선택할 수있는 가능한 선택 목록 정규식의 대체는 단일 세로 막대로 구분됩니다. &lt;code&gt;|&lt;/code&gt; . 일반 Perl 표현식의 대안은 이중 수직 막대로 구분됩니다. &lt;code&gt;||&lt;/code&gt; . &lt;b&gt;부울&lt;/b&gt; 식의 논리 대안은 &lt;code&gt;||&lt;/code&gt; 또는 &lt;code&gt;or&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a2d1159bd9f6222036057dab76c68aab36c4921c" translate="yes" xml:space="preserve">
          <source>A list of possible choices from which you may select only one, as in, &amp;ldquo;Would you like door A, B, or C?&amp;rdquo; Alternatives in regular expressions are separated with a single vertical bar: &lt;code&gt;|&lt;/code&gt;. Alternatives in normal Perl expressions are separated with a double vertical bar: &lt;code&gt;||&lt;/code&gt;. Logical alternatives in &lt;b&gt;Boolean&lt;/b&gt; expressions are separated with either &lt;code&gt;||&lt;/code&gt; or &lt;code&gt;or&lt;/code&gt;.</source>
          <target state="translated">&quot;문 A, B 또는 C를 원하십니까?&quot;와 같이 하나만 선택할 수있는 가능한 선택 목록 정규식의 대안은 단일 수직 막대로 구분됩니다. &lt;code&gt;|&lt;/code&gt; . 일반 Perl 표현식의 대안은 이중 수직 막대로 구분됩니다. &lt;code&gt;||&lt;/code&gt; . &lt;b&gt;부울&lt;/b&gt; 표현식의 논리적 대안은 &lt;code&gt;||&lt;/code&gt; 또는 &lt;code&gt;or&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="346e1107e8ac97822d23a43881fe3f608701a635" translate="yes" xml:space="preserve">
          <source>A list of signal names supported by the current platform can be found in &lt;code&gt;$Config{sig_name}&lt;/code&gt; , which is provided by the &lt;code&gt;Config&lt;/code&gt; module. See &lt;a href=&quot;../config&quot;&gt;Config&lt;/a&gt; for more details.</source>
          <target state="translated">현재 플랫폼에서 지원되는 신호 이름 목록은 &lt;code&gt;Config&lt;/code&gt; 모듈에서 제공하는 &lt;code&gt;$Config{sig_name}&lt;/code&gt; 에서 찾을 수 있습니다 . 자세한 내용은 &lt;a href=&quot;../config&quot;&gt;구성&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="d9eb54a7b38bb34c8e5e028a36e767398adf41e8" translate="yes" xml:space="preserve">
          <source>A list of signal names supported by the current platform can be found in &lt;code&gt;$Config{sig_name}&lt;/code&gt; , which is provided by the &lt;code&gt;Config&lt;/code&gt; module. See &lt;a href=&quot;config&quot;&gt;Config&lt;/a&gt; for more details.</source>
          <target state="translated">현재 플랫폼에서 지원되는 신호 이름 목록은 &lt;code&gt;Config&lt;/code&gt; 모듈에서 제공하는 &lt;code&gt;$Config{sig_name}&lt;/code&gt; 에서 찾을 수 있습니다 . 자세한 내용은 &lt;a href=&quot;config&quot;&gt;구성&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="fc0773d86c1f156c02879741dc6d62b20714e966" translate="yes" xml:space="preserve">
          <source>A list of signal names supported by the current platform can be found in &lt;code&gt;$Config{sig_name}&lt;/code&gt;, which is provided by the &lt;a href=&quot;config&quot;&gt;&lt;code&gt;Config&lt;/code&gt;&lt;/a&gt; module. See &lt;a href=&quot;config&quot;&gt;Config&lt;/a&gt; for more details.</source>
          <target state="translated">현재 플랫폼에서 지원하는 신호 이름 목록은 &lt;a href=&quot;config&quot;&gt; &lt;code&gt;Config&lt;/code&gt; &lt;/a&gt; 모듈에서 제공하는 &lt;code&gt;$Config{sig_name}&lt;/code&gt; 에서 찾을 수 있습니다 . 자세한 내용은 &lt;a href=&quot;config&quot;&gt;구성&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="eccc6f087795a7e9086a2d2fafcbe724d6efe6cc" translate="yes" xml:space="preserve">
          <source>A list of tailorable locales</source>
          <target state="translated">맞춤형 로케일 목록</target>
        </trans-unit>
        <trans-unit id="d6a6ca6e50a55d219bc744f957b355e8b7592c8a" translate="yes" xml:space="preserve">
          <source>A list of the built-in functions in Perl can be found in &lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt;.</source>
          <target state="translated">Perl의 내장 함수 목록은 &lt;a href=&quot;perlfunc&quot;&gt;perlfunc에&lt;/a&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="372e15c083e652a86b064f2068748142c2ada459" translate="yes" xml:space="preserve">
          <source>A list of variant codes and their aliases</source>
          <target state="translated">변형 코드 및 별칭 목록</target>
        </trans-unit>
        <trans-unit id="35384fe66627b2cc2fb84aa2b93b3f9464bdd2e5" translate="yes" xml:space="preserve">
          <source>A list started with e.g. a bullet-like &lt;code&gt;=item&lt;/code&gt; and continued with a numbered one. This is obviously inconsistent. For most translators the type of the</source>
          <target state="translated">목록은 예를 들어 글 머리 기호와 같은 &lt;code&gt;=item&lt;/code&gt; 으로 시작 하여 번호가 매겨진 목록으로 계속되었습니다. 이것은 분명히 일관성이 없습니다. 대부분의 번역가에게</target>
        </trans-unit>
        <trans-unit id="aa018bd7e5de867ce0e0e74c715e38d76832212f" translate="yes" xml:space="preserve">
          <source>A list value may also be subscripted like a normal array. You must put the list in parentheses to avoid ambiguity. For example:</source>
          <target state="translated">리스트 값은 일반 배열처럼 첨자 화 될 수도 있습니다. 모호성을 피하기 위해 목록을 괄호 안에 넣어야합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6d0412d7581939fe7cd594904f6d1f6283358f69" translate="yes" xml:space="preserve">
          <source>A list-type op is usually constructed one kid at a time via &lt;code&gt;newLISTOP&lt;/code&gt; , &lt;code&gt;op_prepend_elem&lt;/code&gt; and &lt;code&gt;op_append_elem&lt;/code&gt; . Then finally it is passed to &lt;code&gt;op_convert_list&lt;/code&gt; to make it the right type.</source>
          <target state="translated">목록 유형 op는 일반적으로 &lt;code&gt;newLISTOP&lt;/code&gt; , &lt;code&gt;op_prepend_elem&lt;/code&gt; 및 &lt;code&gt;op_append_elem&lt;/code&gt; 을 통해 한 번에 한 아이 씩 구성 됩니다. 그런 다음 올바른 유형으로 만들기 위해 &lt;code&gt;op_convert_list&lt;/code&gt; 로 전달됩니다 .</target>
        </trans-unit>
        <trans-unit id="14189fe432e4560d9641abb356065b320734ccfd" translate="yes" xml:space="preserve">
          <source>A list-type op is usually constructed one kid at a time via &lt;code&gt;newLISTOP&lt;/code&gt;, &lt;code&gt;op_prepend_elem&lt;/code&gt; and &lt;code&gt;op_append_elem&lt;/code&gt;. Then finally it is passed to &lt;code&gt;op_convert_list&lt;/code&gt; to make it the right type.</source>
          <target state="translated">목록 유형 작업은 일반적으로 &lt;code&gt;newLISTOP&lt;/code&gt; , &lt;code&gt;op_prepend_elem&lt;/code&gt; 및 &lt;code&gt;op_append_elem&lt;/code&gt; 을 통해 한 번에 한 아이 씩 구성 됩니다. 그런 다음 마지막으로 &lt;code&gt;op_convert_list&lt;/code&gt; 에 전달되어 올바른 유형으로 만듭니다.</target>
        </trans-unit>
        <trans-unit id="9f682c29d99c6edee87a4e2c8b480a19c081d9f4" translate="yes" xml:space="preserve">
          <source>A literal of the form &lt;code&gt;v1.20.300.4000&lt;/code&gt; is parsed as a string composed of characters with the specified ordinals. This form, known as v-strings, provides an alternative, more readable way to construct strings, rather than use the somewhat less readable interpolation form &lt;code&gt;&quot;\x{1}\x{14}\x{12c}\x{fa0}&quot;&lt;/code&gt; . This is useful for representing Unicode strings, and for comparing version &quot;numbers&quot; using the string comparison operators, &lt;code&gt;cmp&lt;/code&gt; , &lt;code&gt;gt&lt;/code&gt; , &lt;code&gt;lt&lt;/code&gt; etc. If there are two or more dots in the literal, the leading &lt;code&gt;v&lt;/code&gt; may be omitted.</source>
          <target state="translated">&lt;code&gt;v1.20.300.4000&lt;/code&gt; 형식의 리터럴은 지정된 서 수가있는 문자로 구성된 문자열로 구문 분석됩니다. v- 문자열이라고하는이 형식은 다소 읽기 어려운 보간 형식 &lt;code&gt;&quot;\x{1}\x{14}\x{12c}\x{fa0}&quot;&lt;/code&gt; 사용하는 대신 문자열을 구성하는 더 읽기 쉬운 대안을 제공합니다. &quot; . 이것은 유니 코드 문자열을 나타내거나 문자열 비교 연산자 &lt;code&gt;cmp&lt;/code&gt; , &lt;code&gt;gt&lt;/code&gt; , &lt;code&gt;lt&lt;/code&gt; 등을 사용하여 버전 &quot;숫자&quot;를 비교하는 데 유용 합니다. 리터럴에 두 개 이상의 점이있는 경우 선행 &lt;code&gt;v&lt;/code&gt; 는 생략 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2818d2fc350cf7ade47132bea5c3b21871e52fea" translate="yes" xml:space="preserve">
          <source>A literal of the form &lt;code&gt;v1.20.300.4000&lt;/code&gt; is parsed as a string composed of characters with the specified ordinals. This form, known as v-strings, provides an alternative, more readable way to construct strings, rather than use the somewhat less readable interpolation form &lt;code&gt;&quot;\x{1}\x{14}\x{12c}\x{fa0}&quot;&lt;/code&gt;. This is useful for representing Unicode strings, and for comparing version &quot;numbers&quot; using the string comparison operators, &lt;code&gt;cmp&lt;/code&gt;, &lt;code&gt;gt&lt;/code&gt;, &lt;code&gt;lt&lt;/code&gt; etc. If there are two or more dots in the literal, the leading &lt;code&gt;v&lt;/code&gt; may be omitted.</source>
          <target state="translated">&lt;code&gt;v1.20.300.4000&lt;/code&gt; 형식의 리터럴은 지정된 서수를 가진 문자로 구성된 문자열로 구문 분석됩니다. v- 문자열로 알려진이 형식은 다소 읽기 어려운 보간 형식 &lt;code&gt;&quot;\x{1}\x{14}\x{12c}\x{fa0}&quot;&lt;/code&gt; 사용하는 대신 문자열을 구성하는 더 읽기 쉬운 대체 방법을 제공합니다. &quot; . 이것은 유니 코드 문자열을 표현하고 문자열 비교 연산자 &lt;code&gt;cmp&lt;/code&gt; , &lt;code&gt;gt&lt;/code&gt; , &lt;code&gt;lt&lt;/code&gt; 등을 사용하여 버전 &quot;숫자&quot;를 비교하는 데 유용 합니다. 리터럴에 두 개 이상의 점이 있으면 선행 &lt;code&gt;v&lt;/code&gt; 를 생략 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="59f7e21c905ecc7463ec1c2d73cca6ccc870ec21" translate="yes" xml:space="preserve">
          <source>A little bit less simple options</source>
          <target state="translated">조금 덜 간단한 옵션</target>
        </trans-unit>
        <trans-unit id="6b6e0528ee125aa344dac0cd2afd7b5168d26910" translate="yes" xml:space="preserve">
          <source>A little bit of magic happens here. When running on anything but MacOS, all the tests run normally. But when on MacOS, &lt;code&gt;skip()&lt;/code&gt; causes the entire contents of the SKIP block to be jumped over. It never runs. Instead, &lt;code&gt;skip()&lt;/code&gt; prints special output that tells &lt;a href=&quot;Test::Harness&quot;&gt;Test::Harness&lt;/a&gt; that the tests have been skipped.</source>
          <target state="translated">여기서 약간의 마법이 일어납니다. MacOS가 아닌 다른 곳에서 실행하면 모든 테스트가 정상적으로 실행됩니다. 그러나 MacOS에서 &lt;code&gt;skip()&lt;/code&gt; 은 SKIP 블록의 전체 내용이 건너 뛰 도록합니다. 실행되지 않습니다. 대신 &lt;code&gt;skip()&lt;/code&gt; 은 &lt;a href=&quot;Test::Harness&quot;&gt;테스트를&lt;/a&gt; 건너 뛰었 음을 Test :: Harness에 알리는 특수 출력을 인쇄합니다 .</target>
        </trans-unit>
        <trans-unit id="1cd2ad667ca8cebc07144e83ae02050c5a406af0" translate="yes" xml:space="preserve">
          <source>A little builtin syntactic sugar means you can also say &lt;b&gt;-m&lt;i&gt;MODULE&lt;/i&gt;=foo,bar&lt;/b&gt; or &lt;b&gt;-M&lt;i&gt;MODULE&lt;/i&gt;=foo,bar&lt;/b&gt; as a shortcut for &lt;b&gt;'-M&lt;i&gt;MODULE&lt;/i&gt; qw(foo bar)'&lt;/b&gt;. This avoids the need to use quotes when importing symbols. The actual code generated by &lt;b&gt;-M&lt;i&gt;MODULE&lt;/i&gt;=foo,bar&lt;/b&gt; is &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; module &lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;(/,/,q{foo,bar})&lt;/code&gt; . Note that the &lt;code&gt;=&lt;/code&gt; form removes the distinction between &lt;b&gt;-m&lt;/b&gt; and &lt;b&gt;-M&lt;/b&gt;; that is, &lt;b&gt;-m&lt;i&gt;MODULE&lt;/i&gt;=foo,bar&lt;/b&gt; is the same as &lt;b&gt;-M&lt;i&gt;MODULE&lt;/i&gt;=foo,bar&lt;/b&gt;.</source>
          <target state="translated">약간의 내장 된 구문 설탕은 &lt;b&gt;-m &lt;i&gt;MODULE&lt;/i&gt; = foo, bar&lt;/b&gt; 또는 &lt;b&gt;-M &lt;i&gt;MODULE&lt;/i&gt; = foo, bar&lt;/b&gt; 를 &lt;b&gt;'-M &lt;i&gt;MODULE&lt;/i&gt; qw (foo bar)'에&lt;/b&gt; 대한 바로 가기로 말할 수도 있음을 의미합니다 . 따라서 심볼을 가져올 때 따옴표를 사용할 필요가 없습니다. 에 의해 생성 된 실제 코드 &lt;b&gt;-M &lt;i&gt;MODULE&lt;/i&gt; 바 = 푸,&lt;/b&gt; 인 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; module &lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;(/,/,q{foo,bar})&lt;/code&gt; . 점을 유의 &lt;code&gt;=&lt;/code&gt; 양식의 차이 제거 &lt;b&gt;-m&lt;/b&gt; 과 &lt;b&gt;-M을&lt;/b&gt; ; 즉, &lt;b&gt;-m &lt;i&gt;MODULE&lt;/i&gt; = foo, bar&lt;/b&gt; 는 &lt;b&gt;-M &lt;i&gt;MODULE&lt;/i&gt; = foo, bar와 같습니다.&lt;/b&gt;.</target>
        </trans-unit>
        <trans-unit id="7fd937dfbc8cdfcbf7f8d9bddf92ad4d9bacfca0" translate="yes" xml:space="preserve">
          <source>A little builtin syntactic sugar means you can also say &lt;b&gt;-m&lt;i&gt;MODULE&lt;/i&gt;=foo,bar&lt;/b&gt; or &lt;b&gt;-M&lt;i&gt;MODULE&lt;/i&gt;=foo,bar&lt;/b&gt; as a shortcut for &lt;b&gt;'-M&lt;i&gt;MODULE&lt;/i&gt; qw(foo bar)'&lt;/b&gt;. This avoids the need to use quotes when importing symbols. The actual code generated by &lt;b&gt;-M&lt;i&gt;MODULE&lt;/i&gt;=foo,bar&lt;/b&gt; is &lt;code&gt;use module split(/,/,q{foo,bar})&lt;/code&gt;. Note that the &lt;code&gt;=&lt;/code&gt; form removes the distinction between &lt;b&gt;-m&lt;/b&gt; and &lt;b&gt;-M&lt;/b&gt;; that is, &lt;b&gt;-m&lt;i&gt;MODULE&lt;/i&gt;=foo,bar&lt;/b&gt; is the same as &lt;b&gt;-M&lt;i&gt;MODULE&lt;/i&gt;=foo,bar&lt;/b&gt;.</source>
          <target state="translated">약간의 내장 구문 설탕은 &lt;b&gt;'-M &lt;/b&gt;&lt;b&gt;&lt;i&gt;MODULE&lt;/i&gt;&lt;/b&gt;&lt;b&gt; qw (foo bar)'&lt;/b&gt; 의 바로 가기로 &lt;b&gt;-m &lt;i&gt;MODULE&lt;/i&gt; = foo, bar&lt;/b&gt; 또는 &lt;b&gt;-M &lt;i&gt;MODULE&lt;/i&gt; = foo, bar&lt;/b&gt; 라고 말할 수도 있음을 의미합니다 . 이렇게하면 기호를 가져올 때 따옴표를 사용할 필요가 없습니다. &lt;b&gt;-M &lt;/b&gt;&lt;b&gt;&lt;i&gt;MODULE&lt;/i&gt;&lt;/b&gt;&lt;b&gt; = foo, bar에&lt;/b&gt; 의해 생성 된 실제 코드 는 &lt;code&gt;use module split(/,/,q{foo,bar})&lt;/code&gt; 입니다. 점을 유의 &lt;code&gt;=&lt;/code&gt; 양식의 차이 제거 &lt;b&gt;-m&lt;/b&gt; 과 &lt;b&gt;-M을&lt;/b&gt; ; 즉, &lt;b&gt;-m &lt;/b&gt;&lt;b&gt;&lt;i&gt;MODULE&lt;/i&gt;&lt;/b&gt;&lt;b&gt; = foo, bar&lt;/b&gt; 는 &lt;b&gt;-M &lt;/b&gt;&lt;b&gt;&lt;i&gt;MODULE&lt;/i&gt;&lt;/b&gt;&lt;b&gt; = foo, bar&lt;/b&gt; 와 동일 &lt;b&gt;합니다&lt;/b&gt; .&lt;b&gt;&lt;i&gt;&lt;/i&gt;&lt;/b&gt;&lt;b&gt;&lt;i&gt;&lt;/i&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;i&gt;&lt;/i&gt;&lt;/b&gt;&lt;b&gt;&lt;i&gt;&lt;/i&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="b161330532dd0ec0afc3fa6fafbca99d0e5e09ac" translate="yes" xml:space="preserve">
          <source>A little funky, because VOS's notion of ownership is a little funky (VOS).</source>
          <target state="translated">VOS의 소유권 개념이 약간 펑키 (VOS)이기 때문에 약간 펑키합니다.</target>
        </trans-unit>
        <trans-unit id="fe38aea6f56711cc8a09262301b75b1d00f515d0" translate="yes" xml:space="preserve">
          <source>A little interface to ExtUtils::Installed to examine installed modules, validate your packlists and even create a tarball from an installed module.</source>
          <target state="translated">ExtUtils :: Installed에 대한 작은 인터페이스로 설치된 모듈을 검사하고, 팩리스트를 확인하고, 설치된 모듈에서 타르볼을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="fab5a9063d3279beff24f900f22a1e9be454b440" translate="yes" xml:space="preserve">
          <source>A little-known feature of &lt;a href=&quot;../test/harness&quot;&gt;Test::Harness&lt;/a&gt; is that it supported TODO lists in the plan:</source>
          <target state="translated">&lt;a href=&quot;../test/harness&quot;&gt;Test :: Harness&lt;/a&gt; 의 거의 알려지지 않은 기능은 계획에서 TODO 목록을 지원한다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="e09dee149111fbdc75066a3a4b04ff33ac64fdce" translate="yes" xml:space="preserve">
          <source>A little-known feature of &lt;a href=&quot;Test::Harness&quot;&gt;Test::Harness&lt;/a&gt; is that it supported TODO lists in the plan:</source>
          <target state="translated">&lt;a href=&quot;Test::Harness&quot;&gt;Test :: Harness&lt;/a&gt; 의 잘 알려지지 않은 기능은 계획에서 TODO 목록을 지원한다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="18dd594cfef1216511213db962d79c422701e3a6" translate="yes" xml:space="preserve">
          <source>A local modifies the listed variables to be local to the enclosing block, file, or eval. If more than one value is listed, the list must be placed in parentheses. See &lt;a href=&quot;../perlsub#Temporary-Values-via-local()&quot;&gt;Temporary Values via local() in perlsub&lt;/a&gt; for details, including issues with tied arrays and hashes.</source>
          <target state="translated">로컬은 나열된 변수를 둘러싸는 블록, 파일 또는 평가에 로컬로 수정합니다. 둘 이상의 값이 나열되면 목록을 괄호 안에 넣어야합니다. 연결된 배열 및 해시 문제를 포함하여 자세한 내용 &lt;a href=&quot;../perlsub#Temporary-Values-via-local()&quot;&gt;은 perlsub에서 local ()을 통한 임시 값을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c4f458b856b0a12ad8d1fe86f374dff1cb18e135" translate="yes" xml:space="preserve">
          <source>A local modifies the listed variables to be local to the enclosing block, file, or eval. If more than one value is listed, the list must be placed in parentheses. See &lt;a href=&quot;perlsub#Temporary-Values-via-local%28%29&quot;&gt;&quot;Temporary Values via local()&quot; in perlsub&lt;/a&gt; for details, including issues with tied arrays and hashes.</source>
          <target state="translated">로컬은 나열된 변수를 둘러싸는 블록, 파일 또는 평가판에 로컬이되도록 수정합니다. 둘 이상의 값이 나열되면 목록을 괄호로 묶어야합니다. 연결된 배열 및 해시 문제를 포함하여 자세한 내용 &lt;a href=&quot;perlsub#Temporary-Values-via-local%28%29&quot;&gt;은 perlsub의 &quot;local ()을 통한 임시 값&quot;을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d9869654ca036fa59fd44e2a08b434b738df4df1" translate="yes" xml:space="preserve">
          <source>A local modifies the listed variables to be local to the enclosing block, file, or eval. If more than one value is listed, the list must be placed in parentheses. See &lt;a href=&quot;perlsub#Temporary-Values-via-local()&quot;&gt;Temporary Values via local() in perlsub&lt;/a&gt; for details, including issues with tied arrays and hashes.</source>
          <target state="translated">로컬은 나열된 변수를 둘러싸는 블록, 파일 또는 평가에 로컬로 수정합니다. 둘 이상의 값이 나열되면 목록을 괄호 안에 넣어야합니다. 연결된 배열 및 해시 문제를 포함하여 자세한 내용 &lt;a href=&quot;perlsub#Temporary-Values-via-local()&quot;&gt;은 perlsub에서 local ()을 통한 임시 값을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="851216238693688504d3297975d3a9648a0c15ac" translate="yes" xml:space="preserve">
          <source>A locale is a set of data that describes various aspects of how various communities in the world categorize their world. These categories are broken down into the following types (some of which include a brief note here):</source>
          <target state="translated">로케일은 세계의 여러 커뮤니티가 세계를 분류하는 방법의 다양한 측면을 설명하는 데이터 세트입니다. 이러한 범주는 다음과 같은 유형으로 분류됩니다 (일부는 여기에 간단한 메모 포함).</target>
        </trans-unit>
        <trans-unit id="13e5d1d67a5e143b58f5105851151e51a7ee96cb" translate="yes" xml:space="preserve">
          <source>A location in a &lt;b&gt;hash table&lt;/b&gt; containing (potentially) multiple entries whose keys &amp;ldquo;hash&amp;rdquo; to the same hash value according to its hash function. (As internal policy, you don&amp;rsquo;t have to worry about it unless you&amp;rsquo;re into internals, or policy.)</source>
          <target state="translated">해시 함수에 따라 키가 동일한 해시 값으로 &quot;해시&quot;되는 여러 항목이 포함 된 &lt;b&gt;해시 테이블&lt;/b&gt; 의 위치입니다 . (내부 정책으로서 내부 또는 정책에 속하지 않는 한 걱정할 필요가 없습니다.)</target>
        </trans-unit>
        <trans-unit id="62c12399ed6b551ce7f2dd44832d843392fa0233" translate="yes" xml:space="preserve">
          <source>A lock can either be used to guard the data contained within the variable being locked, or it can be used to guard something else, like a section of code. In this latter case, the variable in question does not hold any useful data, and exists only for the purpose of being locked. In this respect, the variable behaves like the mutexes and basic semaphores of traditional thread libraries.</source>
          <target state="translated">잠금은 잠긴 변수에 포함 된 데이터를 보호하는 데 사용되거나 코드 섹션과 같은 다른 것을 보호하는 데 사용될 수 있습니다. 후자의 경우, 해당 변수는 유용한 데이터를 보유하지 않으며 잠그기위한 목적으로 만 존재합니다. 이와 관련하여 변수는 기존 스레드 라이브러리의 뮤텍스 및 기본 세마포어처럼 동작합니다.</target>
        </trans-unit>
        <trans-unit id="e53273bd96405d6a9351857fe0d8e6743bfe42f3" translate="yes" xml:space="preserve">
          <source>A log of changes you've made to this module. The layout is free-form. Here's an example:</source>
          <target state="translated">이 모듈의 변경 사항에 대한 로그입니다. 레이아웃은 자유 형식입니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e77a6f13193bcd6e24d605469f11ccf9737a2eb7" translate="yes" xml:space="preserve">
          <source>A lone dash on the command line will now be a legal option, and using it will set variable &lt;code&gt;$stdio&lt;/code&gt; .</source>
          <target state="translated">명령 행에서 고독 대시는 이제 유효한 옵션이며이를 사용하여 &lt;code&gt;$stdio&lt;/code&gt; 변수를 설정합니다 .</target>
        </trans-unit>
        <trans-unit id="82708ef5882db99166c7c8cd03934807e0af6cda" translate="yes" xml:space="preserve">
          <source>A lone dash on the command line will now be a legal option, and using it will set variable &lt;code&gt;$stdio&lt;/code&gt;.</source>
          <target state="translated">명령 줄에있는 단일 대시는 이제 합법적 인 옵션이되며이를 사용하면 변수 &lt;code&gt;$stdio&lt;/code&gt; 가 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="518574ccfd2af3125f764f2199d90530c80ca8ba" translate="yes" xml:space="preserve">
          <source>A longer sequence is a script run if and only if &lt;b&gt;all&lt;/b&gt; of the following conditions are met:</source>
          <target state="translated">그리고 경우에만 경우 더 이상 시퀀스는 스크립트가 실행되는 &lt;b&gt;모든&lt;/b&gt; 다음과 같은 조건이 충족 :</target>
        </trans-unit>
        <trans-unit id="96e09920138d7232024aa812a56f04053ae3c9db" translate="yes" xml:space="preserve">
          <source>A longer, more complete description of the purpose or intended use of the distribution than the one provided by the &lt;code&gt;abstract&lt;/code&gt; key.</source>
          <target state="translated">&lt;code&gt;abstract&lt;/code&gt; 키에서 제공하는 것보다 배포의 목적 또는 의도 된 사용에 대한 더 길고 완전한 설명입니다 .</target>
        </trans-unit>
        <trans-unit id="cdb4c7413d2efeeaac13a33033548176fe547847" translate="yes" xml:space="preserve">
          <source>A lot of &lt;code&gt;bad free&lt;/code&gt;</source>
          <target state="translated">많은 &lt;code&gt;bad free&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2ebb7eb8448d50869adcfaf8c37d6e3e449e059f" translate="yes" xml:space="preserve">
          <source>A lot of Git tools (Gitweb, GitHub, git log --pretty=oneline, ...) will only display the first line (cut off at 50 characters) when presenting commit summaries.</source>
          <target state="translated">많은 Git 도구 (Gitweb, GitHub, git log --pretty = oneline, ...)는 커밋 요약을 제시 할 때 첫 줄만 표시합니다 (50 자로 잘림).</target>
        </trans-unit>
        <trans-unit id="02a8d66dfb847fc32e205ee4aa1e54636c91fd8e" translate="yes" xml:space="preserve">
          <source>A lot of opcodes (this is an elementary operation in the internal perl stack machine) put an SV* on the stack. However, as an optimization the corresponding SV is (usually) not recreated each time. The opcodes reuse specially assigned SVs (</source>
          <target state="translated">많은 opcode (내부 perl stack machine의 기본 작업)는 SV *를 스택에 넣습니다. 그러나 최적화로서 해당 SV는 매번 다시 생성되지 않습니다. opcode는 특별히 할당 된 SV를 재사용합니다 (</target>
        </trans-unit>
        <trans-unit id="afe9679193e46dcbc5b397149b0a40382533461a" translate="yes" xml:space="preserve">
          <source>A lot of the behaviour of &lt;code&gt;check()&lt;/code&gt; can be altered by setting package variables. See the section on &lt;code&gt;Global Variables&lt;/code&gt; for details on this.</source>
          <target state="translated">패키지 변수를 설정 하여 &lt;code&gt;check()&lt;/code&gt; 의 많은 동작을 변경할 수 있습니다. 이에 대한 자세한 내용은 &lt;code&gt;Global Variables&lt;/code&gt; 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="fc40634e762614784aeafebfe726c582b35ad008" translate="yes" xml:space="preserve">
          <source>A lot of the methods in this package are accessors to the various fields in the tar header:</source>
          <target state="translated">이 패키지의 많은 메소드는 tar 헤더의 다양한 필드에 대한 접근 자입니다.</target>
        </trans-unit>
        <trans-unit id="fdb88e271e5277826500f05676e2c0be0095eb4c" translate="yes" xml:space="preserve">
          <source>A maliciously crafted file might cause perl to crash or even expose a security vulnerability.</source>
          <target state="translated">악의적으로 제작 된 파일로 인해 perl이 충돌하거나 보안 취약점이 노출 될 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="565ddf2f41fdaae2f6c398d4a9fce10061d3fdb0" translate="yes" xml:space="preserve">
          <source>A map to the empty string means that there is no alias defined for the code point.</source>
          <target state="translated">빈 문자열에 대한 맵은 코드 포인트에 대해 정의 된 별명이 없음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="962035547fe5a8c87c148cca16aad0a4071407ed" translate="yes" xml:space="preserve">
          <source>A mask of those &lt;b&gt;permission bits&lt;/b&gt; that should be forced off when creating files or directories, in order to establish a policy of whom you&amp;rsquo;ll ordinarily deny access to. See the &lt;code&gt;&lt;a href=&quot;functions/umask&quot;&gt;umask&lt;/a&gt;&lt;/code&gt; function.</source>
          <target state="translated">일반적으로 액세스를 거부 할 정책을 설정하기 위해 파일 또는 디렉토리를 작성할 때 강제로 사용해야 하는 &lt;b&gt;권한 비트&lt;/b&gt; 마스크 . &lt;code&gt;&lt;a href=&quot;functions/umask&quot;&gt;umask&lt;/a&gt;&lt;/code&gt; 기능을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c1942e2dc4da6fcab23b5c63e120680f59662794" translate="yes" xml:space="preserve">
          <source>A mask of those &lt;b&gt;permission bits&lt;/b&gt; that should be forced off when creating files or directories, in order to establish a policy of whom you&amp;rsquo;ll ordinarily deny access to. See the &lt;code&gt;umask&lt;/code&gt; function.</source>
          <target state="translated">일반적으로 액세스를 거부 할 정책을 설정하기 위해 파일 또는 디렉토리를 만들 때 강제로 해제해야하는 &lt;b&gt;권한 비트&lt;/b&gt; 의 마스크입니다 . &lt;code&gt;umask&lt;/code&gt; 함수를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="dfb92546e7ee6f466e3b9ad9b8c6c91db11b1f74" translate="yes" xml:space="preserve">
          <source>A meaningless value will currently be returned if the input is not an unsigned integer.</source>
          <target state="translated">입력이 부호없는 정수가 아닌 경우 현재 의미없는 값이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="46b7f4ae99fce16ec6771e2703c08b126f8c5237" translate="yes" xml:space="preserve">
          <source>A mechanism by which some high-level agent such as a user can pass its preferences down to its future offspring (child &lt;b&gt;processes&lt;/b&gt;, grandchild processes, great-grandchild processes, and so on). Each environment variable is a &lt;b&gt;key&lt;/b&gt;/&lt;b&gt;value&lt;/b&gt; pair, like one entry in a &lt;b&gt;hash&lt;/b&gt;.</source>
          <target state="translated">사용자와 같은 일부 고급 에이전트는 기본 설정을 미래의 자손 (자식 &lt;b&gt;프로세스&lt;/b&gt; , 손자 프로세스, 손자 프로세스 등)으로 전달할 수있는 메커니즘 입니다. 각 환경 변수는 &lt;b&gt;해시의&lt;/b&gt; 하나의 항목과 같은 &lt;b&gt;키&lt;/b&gt; / &lt;b&gt;값&lt;/b&gt; 쌍 입니다.&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="2a69447aeea5209e44940fc7462f35a5d6ac88b2" translate="yes" xml:space="preserve">
          <source>A mechanism in Perl that lets you store up the output of each Perl &lt;b&gt;command&lt;/b&gt; and then flush it out as a single request to the &lt;b&gt;operating system&lt;/b&gt;. It&amp;rsquo;s enabled by setting the &lt;code&gt;$|&lt;/code&gt; (&lt;code&gt;$AUTOFLUSH&lt;/code&gt; ) variable to a true value. It&amp;rsquo;s used when you don&amp;rsquo;t want data sitting around, not going where it&amp;rsquo;s supposed to, which may happen because the default on a &lt;b&gt;file&lt;/b&gt; or &lt;b&gt;pipe&lt;/b&gt; is to use &lt;b&gt;block buffering&lt;/b&gt;.</source>
          <target state="translated">각 Perl &lt;b&gt;명령&lt;/b&gt; 의 출력을 저장 한 다음 &lt;b&gt;운영 체제에&lt;/b&gt; 단일 요청으로 플러시 할 수있는 Perl 메커니즘 . &lt;code&gt;$|&lt;/code&gt; 를 설정하면 활성화됩니다 ( &lt;code&gt;$AUTOFLUSH&lt;/code&gt; ) 변수를 true 값으로 설정하십시오. &lt;b&gt;파일&lt;/b&gt; 이나 &lt;b&gt;파이프&lt;/b&gt; 의 기본값 이 &lt;b&gt;블록 버퍼링&lt;/b&gt; 을 사용 하기 때문에 발생할 수있는 곳으로 이동하지 않고 데이터를 원하지 않는 경우에 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="73a790a34f989c156e242df378ee398a811d0fa6" translate="yes" xml:space="preserve">
          <source>A mechanism in Perl that lets you store up the output of each Perl &lt;b&gt;command&lt;/b&gt; and then flush it out as a single request to the &lt;b&gt;operating system&lt;/b&gt;. It&amp;rsquo;s enabled by setting the &lt;code&gt;$|&lt;/code&gt; (&lt;code&gt;$AUTOFLUSH&lt;/code&gt;) variable to a true value. It&amp;rsquo;s used when you don&amp;rsquo;t want data sitting around, not going where it&amp;rsquo;s supposed to, which may happen because the default on a &lt;b&gt;file&lt;/b&gt; or &lt;b&gt;pipe&lt;/b&gt; is to use &lt;b&gt;block buffering&lt;/b&gt;.</source>
          <target state="translated">각 Perl &lt;b&gt;명령&lt;/b&gt; 의 출력을 저장 한 다음 &lt;b&gt;운영 체제에&lt;/b&gt; 대한 단일 요청으로 플러시 할 수있는 Perl의 메커니즘입니다 . &lt;code&gt;$|&lt;/code&gt; 를 설정하면 활성화됩니다. ( &lt;code&gt;$AUTOFLUSH&lt;/code&gt; ) 변수를 참 값으로 설정합니다. &lt;b&gt;파일&lt;/b&gt; 이나 &lt;b&gt;파이프&lt;/b&gt; 의 기본값 이 &lt;b&gt;블록 버퍼링&lt;/b&gt; 을 사용 하는 것이기 때문에 발생할 수있는 데이터가 있어야하는 곳으로 이동하지 않고 주변에있는 데이터를 원하지 않을 때 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="51120e7f8481f25cf88f8c7a272aee4be9724200" translate="yes" xml:space="preserve">
          <source>A memory address (pointer). Typically associated with a &lt;code&gt;void *&lt;/code&gt; type.</source>
          <target state="translated">메모리 주소 (포인터). 일반적으로 &lt;code&gt;void *&lt;/code&gt; 유형 과 연관됩니다 .</target>
        </trans-unit>
        <trans-unit id="3a89278430a1f2647d19e07faa6dcd5ce49e8cc5" translate="yes" xml:space="preserve">
          <source>A message of the form:</source>
          <target state="translated">다음과 같은 형식의 메시지 :</target>
        </trans-unit>
        <trans-unit id="f4fff5e041e8ffd1750d8230d717d49c7140db99" translate="yes" xml:space="preserve">
          <source>A message printed to the &lt;code&gt;STDERR&lt;/code&gt; stream to the effect that something might be wrong but isn&amp;rsquo;t worth blowing up over. See &lt;code&gt;&lt;a href=&quot;functions/warn&quot;&gt;warn&lt;/a&gt;&lt;/code&gt; in Camel chapter 27, &amp;ldquo;Functions&amp;rdquo; and the &lt;code&gt;warnings&lt;/code&gt; pragma in Camel chapter 28, &amp;ldquo;Pragmantic Modules&amp;rdquo;.</source>
          <target state="translated">&lt;code&gt;STDERR&lt;/code&gt; 스트림에 메시지가 인쇄되어 무언가 잘못되었을 수 있지만 그만한 가치는 없습니다. Camel 27 장, &quot;기능&quot;및 Camel 28 장, &quot;Pragmantic Modules&quot; 의 &lt;code&gt;warnings&lt;/code&gt; pragma에서 &lt;code&gt;&lt;a href=&quot;functions/warn&quot;&gt;warn&lt;/a&gt;&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="698adb24081e5dd75873b482d129bef5c7d6f56b" translate="yes" xml:space="preserve">
          <source>A message printed to the &lt;code&gt;STDERR&lt;/code&gt; stream to the effect that something might be wrong but isn&amp;rsquo;t worth blowing up over. See &lt;code&gt;warn&lt;/code&gt; in Camel chapter 27, &amp;ldquo;Functions&amp;rdquo; and the &lt;code&gt;warnings&lt;/code&gt; pragma in Camel chapter 28, &amp;ldquo;Pragmantic Modules&amp;rdquo;.</source>
          <target state="translated">&lt;code&gt;STDERR&lt;/code&gt; 스트림에 인쇄 된 메시지 는 무언가 잘못되었을 수 있지만 폭파 할 가치가 없다는 효과를 나타냅니다. 참조 &lt;code&gt;warn&lt;/code&gt; 낙타 장 27, &quot;기능&quot;및 &lt;code&gt;warnings&lt;/code&gt; 낙타 28 장에서 프라 그마, &quot;Pragmantic 모듈&quot;.</target>
        </trans-unit>
        <trans-unit id="6a6e29399630661da9d8d4454f316b8b579ac7c9" translate="yes" xml:space="preserve">
          <source>A message to print prior to &lt;code&gt;@args&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;@args&lt;/code&gt; 이전에 인쇄 할 메시지 입니다.</target>
        </trans-unit>
        <trans-unit id="f32f46fd3a16d86d6b29b7249d408acc0fd9dade" translate="yes" xml:space="preserve">
          <source>A message to print prior to &lt;code&gt;@args&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;@args&lt;/code&gt; 이전에 인쇄 할 메시지 입니다.</target>
        </trans-unit>
        <trans-unit id="cd1e82245324d77d7c4b1f38686539fbc87f4207" translate="yes" xml:space="preserve">
          <source>A metacharacter can be matched by putting a backslash before it:</source>
          <target state="translated">메타 문자는 뒤에 백 슬래시를 넣어서 일치시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="22cc73f771c76a642b402e7e0f9c578239ac498b" translate="yes" xml:space="preserve">
          <source>A metacharacter can be matched literally by putting a backslash before it:</source>
          <target state="translated">메타 문자는 앞에 백 슬래시를 넣어 문자 그대로 일치시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fb23d39b57fee733dc53600af45c98c9b288bdde" translate="yes" xml:space="preserve">
          <source>A method is simply a subroutine that expects a reference to an object (or a package name, for class methods) as the first argument.</source>
          <target state="translated">메소드는 단순히 첫 번째 인수로 오브젝트 (또는 클래스 메소드의 패키지 이름)에 대한 참조를 예상하는 서브 루틴입니다.</target>
        </trans-unit>
        <trans-unit id="8b793382672991d71fa4d5891acf893cacd7e306" translate="yes" xml:space="preserve">
          <source>A method of making input and output efficient by passing one &lt;b&gt;block&lt;/b&gt; at a time. By default, Perl does block buffering to disk files. See &lt;b&gt;buffer&lt;/b&gt; and &lt;b&gt;command buffering&lt;/b&gt;.</source>
          <target state="translated">한 번에 하나의 &lt;b&gt;블록&lt;/b&gt; 을 전달하여 입력 및 출력을 효율적으로 만드는 방법입니다 . 기본적으로 Perl은 디스크 파일에 대한 버퍼링을 차단합니다. &lt;b&gt;버퍼&lt;/b&gt; 및 &lt;b&gt;명령 버퍼링을&lt;/b&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="caf2b56be7a3ef3288ab77eb65ba11acb464aa6d" translate="yes" xml:space="preserve">
          <source>A method of storing numbers in &amp;ldquo;scientific notation&amp;rdquo;, such that the precision of the number is independent of its magnitude (the decimal point &amp;ldquo;floats&amp;rdquo;). Perl does its numeric work with floating-point numbers (sometimes called &amp;ldquo;floats&amp;rdquo;) when it can&amp;rsquo;t get away with using &lt;b&gt;integers&lt;/b&gt;. Floating-point numbers are mere approximations of real numbers.</source>
          <target state="translated">숫자의 정밀도가 크기 (소수점 &quot;floats&quot;)와 무관하도록 숫자를 &quot;과학적 표기법&quot;으로 저장하는 방법. Perl은 &lt;b&gt;integers&lt;/b&gt; 를 사용하여 벗어날 수 없을 때 부동 소수점 숫자 (때로는&amp;ldquo;floats&amp;rdquo;라고 함)로 숫자를 처리 합니다. 부동 소수점 숫자는 단순한 실수의 근사치입니다.</target>
        </trans-unit>
        <trans-unit id="944278d690e3fc7e64864c32faa75a96c4fa698a" translate="yes" xml:space="preserve">
          <source>A method returning a scalar containing definitions needed, typically for a C header file.</source>
          <target state="translated">일반적으로 C 헤더 파일에 필요한 정의를 포함하는 스칼라를 리턴하는 메소드입니다.</target>
        </trans-unit>
        <trans-unit id="b261259b0ea34efe663b89fa4a355d967119ff59" translate="yes" xml:space="preserve">
          <source>A method to return a suitable &lt;code&gt;#ifdef&lt;/code&gt; clause.</source>
          <target state="translated">적합한 &lt;code&gt;#ifdef&lt;/code&gt; 절 을 반환하는 메서드 입니다.</target>
        </trans-unit>
        <trans-unit id="e298259952faa9b6dc589a73a54938eb75e8b9ca" translate="yes" xml:space="preserve">
          <source>A method to return a suitable C &lt;code&gt;if&lt;/code&gt; statement to check whether</source>
          <target state="translated">적합한 C &lt;code&gt;if&lt;/code&gt; 문 을 반환하여 여부를 확인하는 방법</target>
        </trans-unit>
        <trans-unit id="b8d289dec370b10085acc876037d4a80d75d741c" translate="yes" xml:space="preserve">
          <source>A method to return a suitable assignment clause. If</source>
          <target state="translated">적합한 할당 절을 반환하는 방법. 만약</target>
        </trans-unit>
        <trans-unit id="0c03f6a0b53898fc9e24cba2362fd5fb8fa53375" translate="yes" xml:space="preserve">
          <source>A miniature type system</source>
          <target state="translated">소형 시스템</target>
        </trans-unit>
        <trans-unit id="b7330449bff2c39517a4e897b762ab9507a795d4" translate="yes" xml:space="preserve">
          <source>A minimal required perl version, if present, will look like this:</source>
          <target state="translated">필요한 경우 최소한의 필수 perl 버전은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e9a3539678256349db8d3cedb932d5bd4be41d3e" translate="yes" xml:space="preserve">
          <source>A misnamed feature&amp;mdash;it should be called, &amp;ldquo;expecting your mother to pick up after you&amp;rdquo;. Strictly speaking, Perl doesn&amp;rsquo;t do this, but it relies on a reference-counting mechanism to keep things tidy. However, we rarely speak strictly and will often refer to the reference-counting scheme as a form of garbage collection. (If it&amp;rsquo;s any comfort, when your interpreter exits, a &amp;ldquo;real&amp;rdquo; garbage collector runs to make sure everything is cleaned up if you&amp;rsquo;ve been messy with circular references and such.)</source>
          <target state="translated">이름이 잘못 지정된 기능 &amp;mdash;&amp;ldquo;어머니가 당신을 데리러 오기를 기대하십시오&amp;rdquo;라고 부릅니다. 엄밀히 말하면, Perl은 이것을하지 않지만, 물건을 깔끔하게 유지하기 위해 참조 계산 메커니즘에 의존합니다. 그러나 우리는 거의 엄격하게 말하지 않으며 종종 참조 계산 체계를 가비지 수집의 형태로 언급합니다. (편안한 경우 통역사가 종료되면 순환 참조 등으로 지저분한 경우 모든 것이 정리되도록 &quot;실제&quot;가비지 수집기가 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="b76b41563e694ef10941bc1da1406e4e19d640cf" translate="yes" xml:space="preserve">
          <source>A modifier available specifically to search and replace is the &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///e&lt;/a&gt;&lt;/code&gt; evaluation modifier. &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///e&lt;/a&gt;&lt;/code&gt; treats the replacement text as Perl code, rather than a double-quoted string. The value that the code returns is substituted for the matched substring. &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///e&lt;/a&gt;&lt;/code&gt; is useful if you need to do a bit of computation in the process of replacing text. This example counts character frequencies in a line:</source>
          <target state="translated">검색 및 교체에 특별히 사용 가능한 수정자는 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///e&lt;/a&gt;&lt;/code&gt; 평가 수정 자입니다. &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///e&lt;/a&gt;&lt;/code&gt; 는 대체 텍스트를 큰 따옴표로 묶은 문자열이 아닌 Perl 코드로 취급합니다. 코드가 반환하는 값은 일치하는 하위 문자열로 대체됩니다. &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///e&lt;/a&gt;&lt;/code&gt; 는 텍스트를 바꾸는 과정에서 약간의 계산이 필요한 경우에 유용합니다. 이 예는 한 줄로 문자 빈도를 계산합니다.</target>
        </trans-unit>
        <trans-unit id="978f8f9b8df9741b30748f830e018b2a20eda4a7" translate="yes" xml:space="preserve">
          <source>A modifier available specifically to search and replace is the &lt;code&gt;s///e&lt;/code&gt; evaluation modifier. &lt;code&gt;s///e&lt;/code&gt; treats the replacement text as Perl code, rather than a double-quoted string. The value that the code returns is substituted for the matched substring. &lt;code&gt;s///e&lt;/code&gt; is useful if you need to do a bit of computation in the process of replacing text. This example counts character frequencies in a line:</source>
          <target state="translated">검색 및 교체에 특별히 사용할 수있는 수정자는 &lt;code&gt;s///e&lt;/code&gt; 평가 수정 자입니다. &lt;code&gt;s///e&lt;/code&gt; 는 대체 텍스트를 큰 따옴표로 묶인 문자열이 아닌 Perl 코드로 처리합니다. 코드가 반환하는 값은 일치하는 하위 문자열로 대체됩니다. &lt;code&gt;s///e&lt;/code&gt; 는 텍스트를 교체하는 과정에서 약간의 계산이 필요한 경우 유용합니다. 이 예는 한 줄의 문자 빈도를 계산합니다.</target>
        </trans-unit>
        <trans-unit id="85f750d1b2bf1dcd617bfb9b0ddbb157dd528256" translate="yes" xml:space="preserve">
          <source>A modifier is overridden by later occurrences of this construct in the same scope containing the same modifier, so that</source>
          <target state="translated">수정자는 동일한 수정자를 포함하는 동일한 범위에서이 구성의 이후 발생에 의해 재정의되므로</target>
        </trans-unit>
        <trans-unit id="68d67d7e195f6e0fb6e2bd79bf9224c3c8d1e2fd" translate="yes" xml:space="preserve">
          <source>A module for loading must be quoted.</source>
          <target state="translated">로드 할 모듈을 인용해야합니다.</target>
        </trans-unit>
        <trans-unit id="8d98e6118bd0f23607596b779080678b5a48db1b" translate="yes" xml:space="preserve">
          <source>A module is a file that (by convention) provides a class of the same name (sans the .pm), plus an import method in that class that can be called to fetch exported symbols. This module may implement some of its methods by loading dynamic C or C++ objects, but that should be totally transparent to the user of the module. Likewise, the module might set up an AUTOLOAD function to slurp in subroutine definitions on demand, but this is also transparent. Only the</source>
          <target state="translated">모듈은 규칙에 따라 동일한 이름의 클래스 (.pm)와 내 보낸 심볼을 가져 오기 위해 호출 할 수있는 해당 클래스의 가져 오기 메소드를 제공하는 파일입니다. 이 모듈은 동적 C 또는 C ++ 객체를로드하여 일부 메서드를 구현할 수 있지만 모듈 사용자에게는 완전히 투명해야합니다. 마찬가지로, 모듈은 필요에 따라 서브 루틴 정의를 처리하기 위해 AUTOLOAD 기능을 설정할 수도 있지만 이는 투명합니다. 오직</target>
        </trans-unit>
        <trans-unit id="22a73f9dccbade36d652d965f87a8dc414d1002a" translate="yes" xml:space="preserve">
          <source>A module is just a set of related functions in a library file, i.e., a Perl package with the same name as the file. It is specifically designed to be reusable by other modules or programs. It may do this by providing a mechanism for exporting some of its symbols into the symbol table of any package using it, or it may function as a class definition and make its semantics available implicitly through method calls on the class and its objects, without explicitly exporting anything. Or it can do a little of both.</source>
          <target state="translated">모듈은 라이브러리 파일, 즉 파일과 이름이 같은 Perl 패키지의 관련 기능 세트 일뿐입니다. 다른 모듈이나 프로그램에서 재사용 할 수 있도록 특별히 설계되었습니다. 이를 사용하여 일부 심볼을 ​​패키지의 심볼 테이블로 내보내는 메커니즘을 제공하여이를 수행하거나 클래스 정의로 기능하고 클래스 및 해당 오브젝트에 대한 메소드 호출을 통해 의미를 암시 적으로 사용 가능하게 할 수 있습니다. 무엇이든 내보내기. 아니면 둘 다 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e2c608d01740d058ca105f502acc61136af2e317" translate="yes" xml:space="preserve">
          <source>A module that breaks a program text into a sequence of &lt;b&gt;tokens&lt;/b&gt; for later analysis by a parser.</source>
          <target state="translated">파서가 나중에 분석 할 수 있도록 프로그램 텍스트를 일련의 &lt;b&gt;토큰&lt;/b&gt; 으로 나누는 모듈입니다 .</target>
        </trans-unit>
        <trans-unit id="a247d01be7fadaf27f2b9413690f6e9d188b0db4" translate="yes" xml:space="preserve">
          <source>A module that helps you test testing modules that are built with &lt;a href=&quot;../builder&quot;&gt;Test::Builder&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../builder&quot;&gt;Test :: Builder&lt;/a&gt; 로 빌드 된 테스트 모듈을 테스트하는 데 도움이되는 모듈 .</target>
        </trans-unit>
        <trans-unit id="5af87f8a65e9ecb41934ff3d4e29f132cd6922de" translate="yes" xml:space="preserve">
          <source>A module that helps you test testing modules that are built with &lt;a href=&quot;Test::Builder&quot;&gt;Test::Builder&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;Test::Builder&quot;&gt;Test :: Builder&lt;/a&gt; 로 빌드 된 테스트 모듈을 테스트하는 데 도움이되는 모듈입니다 .</target>
        </trans-unit>
        <trans-unit id="3605e1a22b2192fa5aa9baada403491f3d035bb2" translate="yes" xml:space="preserve">
          <source>A module that implements DOS-like globbing with a few enhancements. It is largely compatible with perlglob.exe (the M$ setargv.obj version) in all but one respect--it understands wildcards in directory components.</source>
          <target state="translated">몇 가지 향상된 기능으로 DOS와 같은 글 로빙을 구현하는 모듈입니다. perlglob.exe (M $ setargv.obj 버전)와 거의 호환되며 디렉토리 구성 요소의 와일드 카드를 이해합니다.</target>
        </trans-unit>
        <trans-unit id="28b02d8f461ab26400c63c168a94b3b2407585a9" translate="yes" xml:space="preserve">
          <source>A module's code has to be warning and strict-clean, since you can't guarantee the conditions that it'll be used under. Besides, you wouldn't want to distribute code that wasn't warning or strict-clean anyway, right?</source>
          <target state="translated">모듈의 코드는 사용 조건을 보장 할 수 없으므로 경고 및 엄격해야합니다. 게다가 경고 나 엄격하지 않은 코드를 배포하고 싶지 않을 것입니다.</target>
        </trans-unit>
        <trans-unit id="c91f5a59bb26aa2af0fbaed73706b37f93fe9a63" translate="yes" xml:space="preserve">
          <source>A more complete and flexible interface for reading/writing gzip files/buffers is included with the module &lt;code&gt;IO-Compress-Zlib&lt;/code&gt; . See &lt;a href=&quot;../io/compress/gzip&quot;&gt;IO::Compress::Gzip&lt;/a&gt; and &lt;a href=&quot;../io/uncompress/gunzip&quot;&gt;IO::Uncompress::Gunzip&lt;/a&gt; for more details.</source>
          <target state="translated">gzip 파일 / 버퍼 읽기 / 쓰기를위한보다 완전하고 유연한 인터페이스는 &lt;code&gt;IO-Compress-Zlib&lt;/code&gt; 모듈에 포함되어 있습니다. &lt;a href=&quot;../io/compress/gzip&quot;&gt;IO :: Compress :: Gzip&lt;/a&gt; 및 &lt;a href=&quot;../io/uncompress/gunzip&quot;&gt;IO :: Uncompress :: Gunzip을&lt;/a&gt; 참조하십시오. 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="d54d0f134a7e139701b0fa7cb70f024a89595497" translate="yes" xml:space="preserve">
          <source>A more complete and flexible interface for reading/writing gzip files/buffers is included with the module &lt;code&gt;IO-Compress-Zlib&lt;/code&gt;. See &lt;a href=&quot;IO::Compress::Gzip&quot;&gt;IO::Compress::Gzip&lt;/a&gt; and &lt;a href=&quot;IO::Uncompress::Gunzip&quot;&gt;IO::Uncompress::Gunzip&lt;/a&gt; for more details.</source>
          <target state="translated">gzip 파일 / 버퍼 읽기 / 쓰기를위한보다 완전하고 유연한 인터페이스가 모듈 &lt;code&gt;IO-Compress-Zlib&lt;/code&gt; 에 포함되어 있습니다. 자세한 내용은 &lt;a href=&quot;IO::Compress::Gzip&quot;&gt;IO :: Compress :: Gzip&lt;/a&gt; 및 &lt;a href=&quot;IO::Uncompress::Gunzip&quot;&gt;IO :: Uncompress :: Gunzip&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="a47893a0d4c8d8763c8f1003ea95b492858375e4" translate="yes" xml:space="preserve">
          <source>A more complete example of this is the Shell module on CPAN, which can treat undefined subroutine calls as calls to external programs.</source>
          <target state="translated">보다 완전한 예는 CPAN의 쉘 모듈로, 정의되지 않은 서브 루틴 호출을 외부 프로그램에 대한 호출로 취급 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="548a58ac3a8a4f644d16e2322da948be053c0188" translate="yes" xml:space="preserve">
          <source>A more dangerous version of getcwd(), but potentially faster.</source>
          <target state="translated">보다 위험한 getcwd () 버전이지만 잠재적으로 더 빠릅니다.</target>
        </trans-unit>
        <trans-unit id="9c501a7097bf538c4d236187aed836b438d78d12" translate="yes" xml:space="preserve">
          <source>A more dangerous, but potentially faster version of abs_path.</source>
          <target state="translated">더 위험하지만 잠재적으로 더 빠른 abs_path 버전입니다.</target>
        </trans-unit>
        <trans-unit id="2fcc75b6685bd19dcf8c164fa65f41da165a633c" translate="yes" xml:space="preserve">
          <source>A more direct work around is to change the filehandles used by &lt;a href=&quot;Test::Builder&quot;&gt;Test::Builder&lt;/a&gt;.</source>
          <target state="translated">보다 직접적인 해결 방법은 &lt;a href=&quot;Test::Builder&quot;&gt;Test :: Builder에서&lt;/a&gt; 사용하는 파일 핸들을 변경하는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="ac7a13ddb80b2e7ad5a52fa1664ac4bd3c5aef4e" translate="yes" xml:space="preserve">
          <source>A more direct work around is to change the filehandles used by &lt;a href=&quot;builder&quot;&gt;Test::Builder&lt;/a&gt;.</source>
          <target state="translated">보다 직접적인 해결 방법은 &lt;a href=&quot;builder&quot;&gt;Test :: Builder에서&lt;/a&gt; 사용하는 파일 핸들을 변경하는 것입니다. 입니다.</target>
        </trans-unit>
        <trans-unit id="3f085d06d504bc04c8c1f364c54e3b2d32d488c0" translate="yes" xml:space="preserve">
          <source>A more elegant (and safer) interface is needed.</source>
          <target state="translated">보다 우아하고 안전한 인터페이스가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="d906501834bb08ebb1263e2b0973fc289f4c913f" translate="yes" xml:space="preserve">
          <source>A more general approach is to intervene manually, as with an example for the DB_File module, which requires SleepyCat's libdb.sl:</source>
          <target state="translated">SleepyCat의 libdb.sl이 필요한 DB_File 모듈의 예와 같이보다 일반적인 접근 방식은 수동으로 개입하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="a0a3703fe588fb0e60a0c01fcfb0d140fe8770a1" translate="yes" xml:space="preserve">
          <source>A more readable, and perhaps more &quot;plain&quot; way is to use an alternate set of delimiters that doesn't require a single &quot;&amp;gt;&quot; to be escaped. Doubled angle brackets (&quot;&amp;lt;&amp;lt;&quot; and &quot;&amp;gt;&amp;gt;&quot;) may be used</source>
          <target state="translated">더 읽기 쉽고 &quot;일반적인&quot;방법은 단일 &quot;&amp;gt;&quot;를 이스케이프 처리하지 않아도되는 대체 구분 기호 집합을 사용하는 것입니다. 이중 꺾쇠 괄호 ( &quot;&amp;lt;&amp;lt;&quot;및 &quot;&amp;gt;&amp;gt;&quot;)를 사용할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="4f3108171bdddd798db1e9b26d8d770fd7116c20" translate="yes" xml:space="preserve">
          <source>A morpheme in a programming language, the smallest unit of text with semantic significance.</source>
          <target state="translated">의미 상 의미가있는 가장 작은 텍스트 단위 인 프로그래밍 언어의 형태소.</target>
        </trans-unit>
        <trans-unit id="2790cfc68a916af917f3cc04e172e9586561a9c1" translate="yes" xml:space="preserve">
          <source>A naive, but often sufficient heuristic on ASCII platforms, for testing the first highbit byte-sequence in a BOM-less file (whether in code or in Pod!), to see whether that sequence is valid as UTF-8 (RFC 2279) is to check whether that the first byte in the sequence is in the range 0xC2 - 0xFD</source>
          <target state="translated">ASCII 플랫폼에서 순진하지만 충분한 휴리스틱으로 BOM이없는 파일 (코드 또는 포드 등)에서 첫 번째 하이 비트 바이트 시퀀스를 테스트하여 시퀀스가 ​​UTF-8로 유효한지 여부를 확인합니다 (RFC 2279). 시퀀스의 첫 번째 바이트가 0xC2-0xFD 범위에 있는지 확인하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="826c2733de66381609264a147718bd8a6dee2df5" translate="yes" xml:space="preserve">
          <source>A name for a concrete set of behaviors. A role is a way to add behavior to a class without inheritance.</source>
          <target state="translated">구체적인 행동 집합의 이름입니다. 역할은 상속없이 클래스에 동작을 추가하는 방법입니다.</target>
        </trans-unit>
        <trans-unit id="6cc90f6ad3d71e4b26203e2d58a28aac467dba0f" translate="yes" xml:space="preserve">
          <source>A name that represents a particular instance of opening a directory to read it, until you close it. See the &lt;code&gt;&lt;a href=&quot;functions/opendir&quot;&gt;opendir&lt;/a&gt;&lt;/code&gt; function.</source>
          <target state="translated">디렉토리를 닫을 때까지 읽을 디렉토리를 여는 특정 인스턴스를 나타내는 이름입니다. &lt;code&gt;&lt;a href=&quot;functions/opendir&quot;&gt;opendir&lt;/a&gt;&lt;/code&gt; 함수를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f6c6fe92e40ceff3ff69d97ca9dd71043580f61d" translate="yes" xml:space="preserve">
          <source>A name that represents a particular instance of opening a directory to read it, until you close it. See the &lt;code&gt;opendir&lt;/code&gt; function.</source>
          <target state="translated">닫을 때까지 읽기 위해 디렉토리를 여는 특정 인스턴스를 나타내는 이름입니다. &lt;code&gt;opendir&lt;/code&gt; 함수를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="57d4f638a5f1b060674c6232dbb757e9b9e2d99e" translate="yes" xml:space="preserve">
          <source>A name you give to a &lt;b&gt;statement&lt;/b&gt; so that you can talk about that statement elsewhere in the program.</source>
          <target state="translated">당신이에 제공하는 이름입니다 &lt;b&gt;문&lt;/b&gt; 이 프로그램에서 그 진술의 다른 곳에서 이야기 할 수 있도록.</target>
        </trans-unit>
        <trans-unit id="c7a5f11c051d5e99d07f67bdaab9eaa5cf1c7964" translate="yes" xml:space="preserve">
          <source>A named array in scalar context is quite different from what would at first glance appear to be a list in scalar context. You can't get a list like &lt;code&gt;(1,2,3)&lt;/code&gt; into being in scalar context, because the compiler knows the context at compile time. It would generate the scalar comma operator there, not the list concatenation version of the comma. That means it was never a list to start with.</source>
          <target state="translated">스칼라 컨텍스트의 명명 된 배열은 언뜻보기에 스칼라 컨텍스트의 목록으로 보이는 배열과 상당히 다릅니다. 컴파일러가 컴파일 타임에 컨텍스트를 알고 있기 때문에 &lt;code&gt;(1,2,3)&lt;/code&gt; 과 같은 목록 을 스칼라 컨텍스트에 넣을 수 없습니다 . 쉼표의 목록 연결 버전이 아니라 스칼라 쉼표 연산자를 생성합니다. 이는 시작 목록이 아니었다는 것을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="9e963f1a0b66c9a6c01f8278ff2607d7847c7265" translate="yes" xml:space="preserve">
          <source>A named array in scalar context is quite different from what would at first glance appear to be a list in scalar context. You can't get a list like &lt;code&gt;(1,2,3)&lt;/code&gt; into being in scalar context, because the compiler knows the context at compile time. It would generate the scalar comma operator there, not the list construction version of the comma. That means it was never a list to start with.</source>
          <target state="translated">스칼라 컨텍스트의 명명 된 배열은 언뜻보기에 스칼라 컨텍스트의 목록으로 보이는 것과는 상당히 다릅니다. 컴파일러는 컴파일 타임에 컨텍스트를 알고 있기 때문에 &lt;code&gt;(1,2,3)&lt;/code&gt; 과 같은 목록 을 스칼라 컨텍스트에있는 것으로 가져올 수 없습니다 . 쉼표의 목록 구성 버전이 아닌 스칼라 쉼표 연산자를 생성합니다. 그것은 처음부터 목록이 아니었다는 것을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="ccb2fe3157763e6463fb7171376abf423c75879f" translate="yes" xml:space="preserve">
          <source>A named capture group. Identical in every respect to normal capturing parentheses &lt;code&gt;()&lt;/code&gt; but for the additional fact that the group can be referred to by name in various regular expression constructs (like &lt;code&gt;\g{&lt;i&gt;NAME&lt;/i&gt;}&lt;/code&gt;) and can be accessed by name after a successful match via &lt;code&gt;%+&lt;/code&gt; or &lt;code&gt;%-&lt;/code&gt;. See &lt;a href=&quot;perlvar&quot;&gt;perlvar&lt;/a&gt; for more details on the &lt;code&gt;%+&lt;/code&gt; and &lt;code&gt;%-&lt;/code&gt; hashes.</source>
          <target state="translated">명명 된 캡처 그룹. 일반 캡처 괄호 &lt;code&gt;()&lt;/code&gt; 와 관련하여 모든 측면에서 동일 하지만 그룹이 다양한 정규식 구문 (예 : &lt;code&gt;\g{&lt;i&gt;NAME&lt;/i&gt;}&lt;/code&gt; )에서 이름으로 참조 될 수 있으며 &lt;code&gt;%+&lt;/code&gt; 를 통해 성공적으로 일치 한 후 이름으로 액세스 할 수 있다는 추가 사실이 있습니다. 또는 &lt;code&gt;%-&lt;/code&gt; . &lt;code&gt;%+&lt;/code&gt; 및 &lt;code&gt;%-&lt;/code&gt; 해시 에 대한 자세한 내용 은 &lt;a href=&quot;perlvar&quot;&gt;perlvar&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="75daf7108ed110da5eff87e476f0ddf2290f10b8" translate="yes" xml:space="preserve">
          <source>A named capture group. Identical in every respect to normal capturing parentheses &lt;code&gt;()&lt;/code&gt; but for the additional fact that the group can be referred to by name in various regular expression constructs (like &lt;code&gt;\g{NAME}&lt;/code&gt; ) and can be accessed by name after a successful match via &lt;code&gt;%+&lt;/code&gt; or &lt;code&gt;%-&lt;/code&gt; . See &lt;a href=&quot;perlvar&quot;&gt;perlvar&lt;/a&gt; for more details on the &lt;code&gt;%+&lt;/code&gt; and &lt;code&gt;%-&lt;/code&gt; hashes.</source>
          <target state="translated">명명 된 캡처 그룹 모든 점에서 일반적인 캡처 괄호 &lt;code&gt;()&lt;/code&gt; 와 동일 하지만 그룹은 다양한 정규 표현식 구조 (예 : &lt;code&gt;\g{NAME}&lt;/code&gt; )에서 이름으로 참조 될 수 있으며 &lt;code&gt;%+&lt;/code&gt; 를 통해 성공적으로 일치 한 후에 이름으로 액세스 할 수 있다는 추가 사실 또는 &lt;code&gt;%-&lt;/code&gt; . &lt;code&gt;%+&lt;/code&gt; 및 &lt;code&gt;%-&lt;/code&gt; 해시 에 대한 자세한 내용 은 &lt;a href=&quot;perlvar&quot;&gt;perlvar&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="184923b65ef8ae0c8a3e87da3ade2989c9cad4ca" translate="yes" xml:space="preserve">
          <source>A named collection of data, usually stored on disk in a &lt;b&gt;directory&lt;/b&gt; in a &lt;b&gt;filesystem&lt;/b&gt;. Roughly like a document, if you&amp;rsquo;re into office metaphors. In modern filesystems, you can actually give a file more than one name. Some files have special properties, like directories and devices.</source>
          <target state="translated">명명 된 데이터 모음으로, 일반적으로 &lt;b&gt;파일 시스템&lt;/b&gt; 의 &lt;b&gt;디렉토리&lt;/b&gt; 에있는 디스크에 저장됩니다 . 사무실 은유에 관한 문서와 거의 같습니다. 최신 파일 시스템에서는 실제로 파일에 둘 이상의 이름을 지정할 수 있습니다. 일부 파일에는 디렉토리 및 장치와 같은 특별한 속성이 있습니다.&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="6a9ab3c01eb064a3661e1bb7b921e5b073d19ecd" translate="yes" xml:space="preserve">
          <source>A named or otherwise accessible piece of program that can be invoked from elsewhere in the program in order to accomplish some subgoal of the program. A subroutine is often parameterized to accomplish different but related things depending on its input &lt;b&gt;arguments&lt;/b&gt;. If the subroutine returns a meaningful &lt;b&gt;value&lt;/b&gt;, it is also called a &lt;b&gt;function&lt;/b&gt;.</source>
          <target state="translated">프로그램의 일부 목표를 달성하기 위해 프로그램의 다른 곳에서 호출 할 수있는 명명되거나 액세스 가능한 프로그램. 서브 루틴은 종종 입력 &lt;b&gt;인수&lt;/b&gt; 에 따라 다르지만 관련된 것을 달성하기 위해 매개 변수화됩니다 . 서브 루틴이 의미있는 &lt;b&gt;값을&lt;/b&gt; 리턴하면 이를 &lt;b&gt;함수&lt;/b&gt; 라고도 &lt;b&gt;합니다&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="fd84ea80f8d7433a1aa60b125a9e6b4dc8885ca9" translate="yes" xml:space="preserve">
          <source>A named pipe (often referred to as a FIFO) is an old Unix IPC mechanism for processes communicating on the same machine. It works just like regular anonymous pipes, except that the processes rendezvous using a filename and need not be related.</source>
          <target state="translated">명명 된 파이프 (종종 FIFO라고도 함)는 동일한 컴퓨터에서 통신하는 프로세스를위한 오래된 Unix IPC 메커니즘입니다. 파일 이름을 사용하여 프로세스가 랑데부하고 관련 될 필요가 없다는 점을 제외하면 일반 익명 파이프와 동일하게 작동합니다.</target>
        </trans-unit>
        <trans-unit id="1bcf4b5c3266b1cc1c63363a98c94938d5445b2f" translate="yes" xml:space="preserve">
          <source>A named pipe, created via &lt;code&gt;CreateNamedPipe&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;CreateNamedPipe&lt;/code&gt; 를 통해 생성 된 명명 된 파이프 .</target>
        </trans-unit>
        <trans-unit id="e0d06a3ea39fd5acfb66f824c51baebd59e34891" translate="yes" xml:space="preserve">
          <source>A named storage location that can hold any of various kinds of &lt;b&gt;value&lt;/b&gt;, as your program sees fit.</source>
          <target state="translated">프로그램이 적합하다고 생각 하는 다양한 종류의 &lt;b&gt;가치를&lt;/b&gt; 담을 수있는 명명 된 저장 위치 .</target>
        </trans-unit>
        <trans-unit id="092b494909d87658298161632e734b7420bfadba" translate="yes" xml:space="preserve">
          <source>A negatable option is specified with an exclamation mark &lt;code&gt;!&lt;/code&gt; after the option name:</source>
          <target state="translated">무시할 수있는 옵션은 느낌표로 지정됩니다 &lt;code&gt;!&lt;/code&gt; 옵션 이름 다음에 :</target>
        </trans-unit>
        <trans-unit id="99e2aec2990f88ba3867f8f52b0dfe7ccc80feb8" translate="yes" xml:space="preserve">
          <source>A negated expression, whether &lt;code&gt;!(EXPR)&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/not&quot;&gt;not(EXPR)&lt;/a&gt;&lt;/code&gt;, or a logical exclusive-or, &lt;code&gt;(EXPR1) &lt;a href=&quot;functions/xor&quot;&gt;xor&lt;/a&gt; (EXPR2)&lt;/code&gt; . The bitwise versions (&lt;code&gt;~&lt;/code&gt; and &lt;code&gt;^&lt;/code&gt;) are not included.</source>
          <target state="translated">&lt;code&gt;!(EXPR)&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;functions/not&quot;&gt;not(EXPR)&lt;/a&gt;&lt;/code&gt; 또는 논리 배타적 또는 &lt;code&gt;(EXPR1) &lt;a href=&quot;functions/xor&quot;&gt;xor&lt;/a&gt; (EXPR2)&lt;/code&gt; 여부에 관계없이 부정 된 표현식 입니다. 비트 버전 ( &lt;code&gt;~&lt;/code&gt; 및 &lt;code&gt;^&lt;/code&gt; )은 포함되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9d1e74169dd288f80b0a507b493221feacddf276" translate="yes" xml:space="preserve">
          <source>A negated expression, whether &lt;code&gt;!(EXPR)&lt;/code&gt; or &lt;code&gt;not(EXPR)&lt;/code&gt;, or a logical exclusive-or, &lt;code&gt;(EXPR1) xor (EXPR2)&lt;/code&gt;. The bitwise versions (&lt;code&gt;~&lt;/code&gt; and &lt;code&gt;^&lt;/code&gt;) are not included.</source>
          <target state="translated">부정 된 표현 여부를 &lt;code&gt;!(EXPR)&lt;/code&gt; 또는 &lt;code&gt;not(EXPR)&lt;/code&gt; , 또는 논리적 배타적 또는 &lt;code&gt;(EXPR1) xor (EXPR2)&lt;/code&gt; . 비트 버전 ( &lt;code&gt;~&lt;/code&gt; 및 &lt;code&gt;^&lt;/code&gt; )은 포함되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="854efffaefa787b0da74283032eac82589c1370b" translate="yes" xml:space="preserve">
          <source>A negative signal name is the same as a negative signal number, killing process groups instead of processes. For example, &lt;code&gt;&lt;a href=&quot;functions/kill&quot;&gt;kill&lt;/a&gt; '-KILL', $pgrp&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/kill&quot;&gt;kill&lt;/a&gt; -9, $pgrp&lt;/code&gt; will send &lt;code&gt;SIGKILL&lt;/code&gt; to the entire process group specified. That means you usually want to use positive not negative signals.</source>
          <target state="translated">음의 신호 이름은 음의 신호 번호와 동일하며 프로세스 대신 프로세스 그룹을 종료합니다. 예를 들어, &lt;code&gt;&lt;a href=&quot;functions/kill&quot;&gt;kill&lt;/a&gt; '-KILL', $pgrp&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;functions/kill&quot;&gt;kill&lt;/a&gt; -9, $pgrp&lt;/code&gt; 는 지정된 전체 프로세스 그룹에 &lt;code&gt;SIGKILL&lt;/code&gt; 을 보냅니다 . 즉, 일반적으로 음이 아닌 양의 신호를 사용하려고합니다.</target>
        </trans-unit>
        <trans-unit id="489423251916154fc8d55b14cad49fcf24beefc2" translate="yes" xml:space="preserve">
          <source>A negative signal name is the same as a negative signal number, killing process groups instead of processes. For example, &lt;code&gt;&lt;a href=&quot;kill&quot;&gt;kill&lt;/a&gt; '-KILL', $pgrp&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;kill&quot;&gt;kill&lt;/a&gt; -9, $pgrp&lt;/code&gt; will send &lt;code&gt;SIGKILL&lt;/code&gt; to the entire process group specified. That means you usually want to use positive not negative signals.</source>
          <target state="translated">음의 신호 이름은 음의 신호 번호와 동일하며 프로세스 대신 프로세스 그룹을 종료합니다. 예를 들어, &lt;code&gt;&lt;a href=&quot;kill&quot;&gt;kill&lt;/a&gt; '-KILL', $pgrp&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;kill&quot;&gt;kill&lt;/a&gt; -9, $pgrp&lt;/code&gt; 는 지정된 전체 프로세스 그룹에 &lt;code&gt;SIGKILL&lt;/code&gt; 을 보냅니다 . 즉, 일반적으로 음이 아닌 양의 신호를 사용하려고합니다.</target>
        </trans-unit>
        <trans-unit id="5839d6eebd6bf96dcf15322f2ba95d945cb0ed5b" translate="yes" xml:space="preserve">
          <source>A negative signal name is the same as a negative signal number, killing process groups instead of processes. For example, &lt;code&gt;kill '-KILL', $pgrp&lt;/code&gt; and &lt;code&gt;kill -9, $pgrp&lt;/code&gt; will send &lt;code&gt;SIGKILL&lt;/code&gt; to the entire process group specified. That means you usually want to use positive not negative signals.</source>
          <target state="translated">음의 신호 이름은 음의 신호 번호와 동일하므로 프로세스 대신 프로세스 그룹을 종료합니다. 예를 들어, &lt;code&gt;kill '-KILL', $pgrp&lt;/code&gt; 및 &lt;code&gt;kill -9, $pgrp&lt;/code&gt; 는 지정된 전체 프로세스 그룹에 &lt;code&gt;SIGKILL&lt;/code&gt; 을 보냅니다 . 즉, 일반적으로 부정적인 신호가 아닌 긍정적 인 신호를 사용하기를 원합니다.</target>
        </trans-unit>
        <trans-unit id="ea7af62eb6dd0992f67ddc428ca2b71250ece618" translate="yes" xml:space="preserve">
          <source>A nested code block was found that started with a delimiter that was specified as being only to be used as an outermost bracket.</source>
          <target state="translated">가장 바깥 쪽 대괄호로만 사용되도록 지정된 분리 문자로 시작된 중첩 된 코드 블록이 발견되었습니다.</target>
        </trans-unit>
        <trans-unit id="ef68acbebe6cbfeffd4c2199fc642b8e08d6c12d" translate="yes" xml:space="preserve">
          <source>A network share.</source>
          <target state="translated">네트워크 공유.</target>
        </trans-unit>
        <trans-unit id="adfb1c2f0e03b3f5c0a88fd5a3243fdba91d6307" translate="yes" xml:space="preserve">
          <source>A new Net::POP3 object must be created with the</source>
          <target state="translated">새로운 Net :: POP3 객체는</target>
        </trans-unit>
        <trans-unit id="a6942aa9b1458599174d5fd62309534ead314562" translate="yes" xml:space="preserve">
          <source>A new Net::SMTP object must be created with the</source>
          <target state="translated">새로운 Net :: SMTP 객체는</target>
        </trans-unit>
        <trans-unit id="a156df59890d9311b601d33944f7c60f5c525f91" translate="yes" xml:space="preserve">
          <source>A new dumper is created by a call</source>
          <target state="translated">새로운 덤퍼는 호출에 의해 생성됩니다</target>
        </trans-unit>
        <trans-unit id="ce307d445764b039e813c87b536bf4d7ae071734" translate="yes" xml:space="preserve">
          <source>A new executable loads an extension compiled for the old executable when an old perl executable is running. In this case the extension will not pick up the forwarder - with fatal results.</source>
          <target state="translated">이전 perl 실행 파일이 실행될 때 새 실행 파일이 이전 실행 파일 용으로 컴파일 된 확장을로드합니다. 이 경우 확장 프로그램은 전달자를 선택하지 않으며 치명적인 결과를 초래합니다.</target>
        </trans-unit>
        <trans-unit id="ebbd18c3575dd80f81d435a80fe2d3c8ed42ba76" translate="yes" xml:space="preserve">
          <source>A new feature that allows the declaration of &lt;b&gt;variables&lt;/b&gt; and &lt;b&gt;subroutines&lt;/b&gt; with modifiers, as in &lt;code&gt;sub foo : locked
method&lt;/code&gt; . Also another name for an &lt;b&gt;instance variable&lt;/b&gt; of an &lt;b&gt;object&lt;/b&gt;.</source>
          <target state="translated">&lt;code&gt;sub foo : locked method&lt;/code&gt; 와 같이 수정자를 사용하여 &lt;b&gt;변수&lt;/b&gt; 및 &lt;b&gt;서브 루틴&lt;/b&gt; 을 선언 할 수있는 새로운 기능 . &lt;b&gt;객체&lt;/b&gt; 의 &lt;b&gt;인스턴스 변수&lt;/b&gt; 에 대한 또 다른 이름 .&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="c0543491269b3103c51b9af9cf33ea5cb5bbeafd" translate="yes" xml:space="preserve">
          <source>A new feature that allows the declaration of &lt;b&gt;variables&lt;/b&gt; and &lt;b&gt;subroutines&lt;/b&gt; with modifiers, as in &lt;code&gt;sub foo : locked method&lt;/code&gt;. Also another name for an &lt;b&gt;instance variable&lt;/b&gt; of an &lt;b&gt;object&lt;/b&gt;.</source>
          <target state="translated">&lt;code&gt;sub foo : locked method&lt;/code&gt; 에서와 같이 수정자를 사용하여 &lt;b&gt;변수&lt;/b&gt; 및 &lt;b&gt;서브 루틴&lt;/b&gt; 을 선언 할 수있는 새로운 기능입니다 . 또한 &lt;b&gt;객체&lt;/b&gt; 의 &lt;b&gt;인스턴스 변수&lt;/b&gt; 에 대한 또 다른 이름입니다 .&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="bc0af11825c345bf1ba555a00fc78d3675a49bab" translate="yes" xml:space="preserve">
          <source>A new version object can be created as a copy of an existing version object, either as a class method:</source>
          <target state="translated">새 버전 개체는 클래스 메서드로 기존 버전 개체의 복사본으로 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e164afa95fb2ed837b476e0b8fef0b485a678f9f" translate="yes" xml:space="preserve">
          <source>A new version of the output file is always created, which inherits the structure and RMS attributes of the input file, except for owner and protections (and possibly timestamps; see below). All data from the input file is copied to the output file; if either of the first two parameters to &lt;code&gt;rmscopy&lt;/code&gt; is a file handle, its position is unchanged. (Note that this means a file handle pointing to the output file will be associated with an old version of that file after &lt;code&gt;rmscopy&lt;/code&gt; returns, not the newly created version.)</source>
          <target state="translated">소유자 및 보호 (및 타임 스탬프, 아래 참조)를 제외한 입력 파일의 구조 및 RMS 속성을 상속하는 새 버전의 출력 파일이 항상 작성됩니다. 입력 파일의 모든 데이터가 출력 파일로 복사됩니다. &lt;code&gt;rmscopy&lt;/code&gt; 에 대한 처음 두 매개 변수 중 하나가 파일 핸들 인 경우 해당 위치는 변경되지 않습니다. (이는 출력 파일을 가리키는 파일 핸들 이 새로 작성된 버전이 아니라 &lt;code&gt;rmscopy&lt;/code&gt; 가 리턴 된 후 해당 파일의 이전 버전과 연관 됨을 의미 합니다.)</target>
        </trans-unit>
        <trans-unit id="c0eacc7ea97ca14f2375b6edf715d33122368ca7" translate="yes" xml:space="preserve">
          <source>A nice general-purpose fixer-upper function for indented here documents follows. It expects to be called with a here document as its argument. It looks to see whether each line begins with a common substring, and if so, strips that substring off. Otherwise, it takes the amount of leading whitespace found on the first line and removes that much off each subsequent line.</source>
          <target state="translated">여기에 들여 쓰기 된 문서를위한 훌륭한 범용 정착액-위 기능이 있습니다. 인수로 here 문서와 함께 호출 될 것으로 예상됩니다. 각 줄이 공통 하위 문자열로 시작하는지 확인하고, 그렇다면 해당 하위 문자열을 제거합니다. 그렇지 않으면 첫 번째 줄에서 발견되는 선행 공백의 양을 가져 와서 각 후속 줄에서 그 정도를 제거합니다.</target>
        </trans-unit>
        <trans-unit id="0198bb3fbec60180f4c0bac09f0a4bb94105a46c" translate="yes" xml:space="preserve">
          <source>A nickname for something, which behaves in all ways as though you&amp;rsquo;d used the original name instead of the nickname. Temporary aliases are implicitly created in the loop variable for &lt;code&gt;foreach&lt;/code&gt; loops, in the &lt;code&gt;$_&lt;/code&gt; variable for &lt;code&gt;&lt;a href=&quot;functions/map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/grep&quot;&gt;grep&lt;/a&gt;&lt;/code&gt; operators, in &lt;code&gt;$a&lt;/code&gt; and &lt;code&gt;$b&lt;/code&gt; during &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt;&amp;rsquo;s comparison function, and in each element of &lt;code&gt;@_&lt;/code&gt; for the &lt;b&gt;actual arguments&lt;/b&gt; of a subroutine call. Permanent aliases are explicitly created in &lt;b&gt;packages&lt;/b&gt; by &lt;b&gt;importing&lt;/b&gt; symbols or by assignment to &lt;b&gt;typeglobs&lt;/b&gt;. Lexically scoped aliases for package variables are explicitly created by the &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; declaration.</source>
          <target state="translated">닉네임 대신 원래 이름을 사용한 것처럼 모든 방식으로 작동하는 무언가의 닉네임입니다. 임시 별명은 암시에 대한 루프 변수에 생성 된 &lt;code&gt;foreach&lt;/code&gt; 문 에, 루프 &lt;code&gt;$_&lt;/code&gt; 에 대한 변수 &lt;code&gt;&lt;a href=&quot;functions/map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;functions/grep&quot;&gt;grep&lt;/a&gt;&lt;/code&gt; 연산자, &lt;code&gt;$a&lt;/code&gt; 와 &lt;code&gt;$b&lt;/code&gt; 동안 &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt; 비교 함수의, 그리고 각 요소에 &lt;code&gt;@_&lt;/code&gt; 에 대한 &lt;b&gt;실제 인수&lt;/b&gt; 의 서브 루틴 호출. 영구 별명은 기호 를 &lt;b&gt;가져 오거나 &lt;/b&gt;&lt;b&gt;typeglob&lt;/b&gt; 에 지정하여 &lt;b&gt;패키지&lt;/b&gt; 에서 명시 적으로 작성됩니다.&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;. 패키지 변수에 대한 어휘 범위 별명은 명시 적으로 생성되는 &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; 선언.</target>
        </trans-unit>
        <trans-unit id="91ae023a14ec4220bee3363a586d5172c30ca7a4" translate="yes" xml:space="preserve">
          <source>A nickname for something, which behaves in all ways as though you&amp;rsquo;d used the original name instead of the nickname. Temporary aliases are implicitly created in the loop variable for &lt;code&gt;foreach&lt;/code&gt; loops, in the &lt;code&gt;$_&lt;/code&gt; variable for &lt;code&gt;map&lt;/code&gt; or &lt;code&gt;grep&lt;/code&gt; operators, in &lt;code&gt;$a&lt;/code&gt; and &lt;code&gt;$b&lt;/code&gt; during &lt;code&gt;sort&lt;/code&gt;&amp;rsquo;s comparison function, and in each element of &lt;code&gt;@_&lt;/code&gt; for the &lt;b&gt;actual arguments&lt;/b&gt; of a subroutine call. Permanent aliases are explicitly created in &lt;b&gt;packages&lt;/b&gt; by &lt;b&gt;importing&lt;/b&gt; symbols or by assignment to &lt;b&gt;typeglobs&lt;/b&gt;. Lexically scoped aliases for package variables are explicitly created by the &lt;code&gt;our&lt;/code&gt; declaration.</source>
          <target state="translated">닉네임 대신 원래 이름을 사용한 것처럼 모든 방식으로 작동하는 무언가의 닉네임입니다. 임시 별칭은 &lt;code&gt;foreach&lt;/code&gt; 루프의 경우 루프 변수 , &lt;code&gt;map&lt;/code&gt; 또는 &lt;code&gt;grep&lt;/code&gt; 연산자의 경우 &lt;code&gt;$_&lt;/code&gt; 변수 , &lt;code&gt;sort&lt;/code&gt; 의 비교 함수 중 &lt;code&gt;$b&lt;/code&gt; 및 $ b &lt;code&gt;$a&lt;/code&gt; 그리고 a 의 &lt;b&gt;실제 인수&lt;/b&gt; 에 대한 &lt;code&gt;@_&lt;/code&gt; 의 각 요소에 암시 적으로 생성됩니다 . 서브 루틴 호출. 영구 별칭은 심볼 을 &lt;b&gt;가져 오거나 &lt;/b&gt;&lt;b&gt;typeglobs&lt;/b&gt; 에 할당하여 &lt;b&gt;패키지&lt;/b&gt; 에 명시 적으로 생성됩니다.&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;. 패키지 변수에 대한 어휘 범위 별명은 명시 적으로 생성되는 &lt;code&gt;our&lt;/code&gt; 선언.</target>
        </trans-unit>
        <trans-unit id="c1173dc0bd47411653c3329572e8d27b49fadacc" translate="yes" xml:space="preserve">
          <source>A no-op job.</source>
          <target state="translated">무직 직업.</target>
        </trans-unit>
        <trans-unit id="fb1ec4028a0ac13b58d2706d78d6f0e42a16b590" translate="yes" xml:space="preserve">
          <source>A no-op job. Returned by &lt;code&gt;TAP::Parser::Scheduler&lt;/code&gt; as an instruction to the harness to spin (keep executing tests) while the scheduler can't return a real job.</source>
          <target state="translated">무직 직업. 에 의해 반환 된 &lt;code&gt;TAP::Parser::Scheduler&lt;/code&gt; 스핀에 하네스 명령으로 스케줄러가 진짜 직업을 반환 할 수는 없지만 (테스트를 실행 유지).</target>
        </trans-unit>
        <trans-unit id="7309346a0851b1fe75cb3e5cdad78936072ace5d" translate="yes" xml:space="preserve">
          <source>A non-empty Z&amp;lt;&amp;gt;</source>
          <target state="translated">비어 있지 않은 Z &amp;lt;&amp;gt;</target>
        </trans-unit>
        <trans-unit id="3187ac42757f3c2b53340569d4306b0db3207981" translate="yes" xml:space="preserve">
          <source>A non-optional prefix was specified but wasn't found at the start of the text.</source>
          <target state="translated">선택 사항이 아닌 접두사가 지정되었지만 텍스트 시작 부분에 없습니다.</target>
        </trans-unit>
        <trans-unit id="f9ce11826e25a9f2a78731b7ee2ed1865f372e1a" translate="yes" xml:space="preserve">
          <source>A not so obvious caveat with this (see [RT #79908]) is that the variable will be immediately inlined, and will stop behaving like a normal lexical variable, e.g. this will print &lt;code&gt;79907&lt;/code&gt; , not &lt;code&gt;79908&lt;/code&gt; :</source>
          <target state="translated">이것에 대한 명백하지 않은 경고 ([RT # 79908] 참조)는 변수가 즉시 인라인되고 일반적인 어휘 변수처럼 동작이 중지된다는 것입니다. 예를 들어 &lt;code&gt;79908&lt;/code&gt; 이 아니라 &lt;code&gt;79907&lt;/code&gt; 이 인쇄됩니다 .</target>
        </trans-unit>
        <trans-unit id="f08995644089d73bded5c431bbdb0a14a2ba0c4e" translate="yes" xml:space="preserve">
          <source>A not so obvious caveat with this (see [RT #79908]) is that the variable will be immediately inlined, and will stop behaving like a normal lexical variable, e.g. this will print &lt;code&gt;79907&lt;/code&gt;, not &lt;code&gt;79908&lt;/code&gt;:</source>
          <target state="translated">([RT # 79908] 참조) 그다지 분명하지 않은 경고는 변수가 즉시 인라인되고 일반 어휘 변수처럼 작동 하지 &lt;code&gt;79908&lt;/code&gt; 것입니다. 예를 들어 79908이 아닌 &lt;code&gt;79907&lt;/code&gt; 이 인쇄됩니다 .</target>
        </trans-unit>
        <trans-unit id="33aa5e0c48db29d1cb8a94c57d888257eb0656f5" translate="yes" xml:space="preserve">
          <source>A notable and rather unavoidable problem with this method: &quot;x-mingo-tom&quot; has an &quot;x&quot; because the whole tag isn't an IANA-registered tag -- but super_languages('x-mingo-tom') is ('x-mingo') -- which isn't really right, since 'i-mingo' is registered. But this module has no way of knowing that. (But note that same_language_tag('x-mingo', 'i-mingo') is TRUE.)</source>
          <target state="translated">이 방법에서 주목할 만하고 피할 수없는 문제 : &quot;x-mingo-tom&quot;은 전체 태그가 IANA 등록 태그가 아니기 때문에 &quot;x&quot;를 갖지만 super_languages ​​( 'x-mingo-tom')는 ( ' x-mingo ')-'i-mingo '가 등록되어 있기 때문에 실제로 올바르지 않습니다. 그러나이 모듈은 그것을 알 방법이 없습니다. (그러나 same_language_tag ( 'x-mingo', 'i-mingo')는 TRUE입니다.)</target>
        </trans-unit>
        <trans-unit id="11f822ddf21914cec4db6b8a6e4ef4d83bd0921c" translate="yes" xml:space="preserve">
          <source>A note about prefixes</source>
          <target state="translated">접두사에 대한 참고 사항</target>
        </trans-unit>
        <trans-unit id="76a89e2dcaf10bf4c615af7db34f35d8d2e129e8" translate="yes" xml:space="preserve">
          <source>A note on derived files</source>
          <target state="translated">파생 파일에 대한 참고 사항</target>
        </trans-unit>
        <trans-unit id="0a3c02a71990e114ae348bdc123412980dc80cfc" translate="yes" xml:space="preserve">
          <source>A note on freshness</source>
          <target state="translated">신선도에 대한 메모</target>
        </trans-unit>
        <trans-unit id="fabcf1ad8a30bffca7d5c34f9a41567038863f1c" translate="yes" xml:space="preserve">
          <source>A note: to save time, &quot;regular expression&quot; is often abbreviated as regexp or regex. Regexp is a more natural abbreviation than regex, but is harder to pronounce. The Perl pod documentation is evenly split on regexp vs regex; in Perl, there is more than one way to abbreviate it. We'll use regexp in this tutorial.</source>
          <target state="translated">참고 : 시간을 절약하기 위해 &quot;정규식&quot;은 종종 regexp 또는 regex로 축약됩니다. Regexp는 regex보다 자연스러운 약어이지만 발음하기가 더 어렵습니다. Perl 포드 문서는 regexp와 regex로 균등하게 분할됩니다. Perl에는이를 축약하는 방법이 여러 가지가 있습니다. 이 자습서에서는 regexp를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="b0e5798976260679942afb564efdac5fe47bc36f" translate="yes" xml:space="preserve">
          <source>A note: to save time, 'regular expression' is often abbreviated as regexp or regex. Regexp is a more natural abbreviation than regex, but is harder to pronounce. The Perl pod documentation is evenly split on regexp vs regex; in Perl, there is more than one way to abbreviate it. We'll use regexp in this tutorial.</source>
          <target state="translated">참고 : 시간을 절약하기 위해 '정규 표현식'은 종종 정규 표현식 또는 정규 표현식으로 축약됩니다. 정규 표현식은 정규 표현식보다 더 자연스러운 약어이지만 발음하기가 더 어렵습니다. Perl 포드 문서는 정규 표현식과 정규 표현식에서 균등하게 나뉩니다. Perl에는 두 가지 이상의 방법이 있습니다. 이 튜토리얼에서는 regexp를 사용할 것입니다.</target>
        </trans-unit>
        <trans-unit id="7a28dfd2dad981af662c7cb062386ed614bc87a3" translate="yes" xml:space="preserve">
          <source>A notional &amp;ldquo;baton&amp;rdquo; handed around the Perl community indicating who is the lead integrator in some arena of development.</source>
          <target state="translated">Perl 커뮤니티 주변에 명목상의&amp;ldquo;배턴 (Baton)&amp;rdquo;이 주어졌으며, 일부 개발 분야에서 누가 리드 통합 자인지를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="ab0d25629a9f27d8e2343a6d3ae7ea4be0af2ea6" translate="yes" xml:space="preserve">
          <source>A number in base 16, &amp;ldquo;hex&amp;rdquo; for short. The digits for 10 through 15 are customarily represented by the letters &lt;code&gt;a&lt;/code&gt; through &lt;code&gt;f&lt;/code&gt; . Hexadecimal constants in Perl start with &lt;code&gt;0x&lt;/code&gt; . See also the &lt;code&gt;&lt;a href=&quot;functions/hex&quot;&gt;hex&lt;/a&gt;&lt;/code&gt; function in Camel chapter 27, &amp;ldquo;Functions&amp;rdquo;.</source>
          <target state="translated">16 진법의 숫자, 간단히 말하면&amp;ldquo;16 진수&amp;rdquo;입니다. 10에서 15까지의 숫자는 관례 적으로 &lt;code&gt;a&lt;/code&gt; - &lt;code&gt;f&lt;/code&gt; 문자 로 표시됩니다 . Perl의 16 진 상수는 &lt;code&gt;0x&lt;/code&gt; 로 시작 합니다. Camel 27 장,&amp;ldquo;함수&amp;rdquo; 의 &lt;code&gt;&lt;a href=&quot;functions/hex&quot;&gt;hex&lt;/a&gt;&lt;/code&gt; 함수 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f9e8cabeba10a3bcb61dba08b487b1b09e68f5dd" translate="yes" xml:space="preserve">
          <source>A number in base 16, &amp;ldquo;hex&amp;rdquo; for short. The digits for 10 through 15 are customarily represented by the letters &lt;code&gt;a&lt;/code&gt; through &lt;code&gt;f&lt;/code&gt;. Hexadecimal constants in Perl start with &lt;code&gt;0x&lt;/code&gt;. See also the &lt;code&gt;hex&lt;/code&gt; function in Camel chapter 27, &amp;ldquo;Functions&amp;rdquo;.</source>
          <target state="translated">16 진법의 숫자, 줄여서 &quot;hex&quot;. 10에서 15까지의 숫자는 일반적으로 &lt;code&gt;a&lt;/code&gt; 에서 &lt;code&gt;f&lt;/code&gt; 까지의 문자 로 표시됩니다 . Perl의 16 진 상수는 &lt;code&gt;0x&lt;/code&gt; 로 시작 합니다. Camel 27 장, &quot;함수&quot; 의 &lt;code&gt;hex&lt;/code&gt; 함수 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a2e5df9d465cc20aefe1124101a063a27122315b" translate="yes" xml:space="preserve">
          <source>A number in base 8. Only the digits 0 through 7 are allowed. Octal constants in Perl start with 0, as in 013. See also the &lt;code&gt;&lt;a href=&quot;functions/oct&quot;&gt;oct&lt;/a&gt;&lt;/code&gt; function.</source>
          <target state="translated">기수 8의 숫자입니다. 0에서 7까지의 숫자 만 허용됩니다. Perl의 8 진 상수는 013에서와 같이 0으로 시작 합니다. &lt;code&gt;&lt;a href=&quot;functions/oct&quot;&gt;oct&lt;/a&gt;&lt;/code&gt; 함수 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="8fa37e6f196e06e72c5f214ea85cb6255f2f8ebd" translate="yes" xml:space="preserve">
          <source>A number in base 8. Only the digits 0 through 7 are allowed. Octal constants in Perl start with 0, as in 013. See also the &lt;code&gt;oct&lt;/code&gt; function.</source>
          <target state="translated">8 진법의 숫자입니다. 0에서 7까지의 숫자 만 허용됩니다. Perl의 8 진 상수는 013에서와 같이 0으로 시작 합니다. &lt;code&gt;oct&lt;/code&gt; 함수 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a69cd7220ef5a1c647fe095901d92bd9cd440d40" translate="yes" xml:space="preserve">
          <source>A number of backslash sequences have to do with changing the character, or characters following them. &lt;code&gt;\l&lt;/code&gt; will lowercase the character following it, while &lt;code&gt;\u&lt;/code&gt; will uppercase (or, more accurately, titlecase) the character following it. They provide functionality similar to the functions &lt;code&gt;&lt;a href=&quot;functions/lcfirst&quot;&gt;lcfirst&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/ucfirst&quot;&gt;ucfirst&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">많은 백 슬래시 시퀀스는 문자 또는 그 뒤의 문자를 변경하는 것과 관련이 있습니다. &lt;code&gt;\l&lt;/code&gt; 은 뒤에 오는 문자를 소문자로 사용하고 &lt;code&gt;\u&lt;/code&gt; 는 뒤에 오는 문자 를 대문자로 (또는 더 정확하게 제목) 표시합니다. &lt;code&gt;&lt;a href=&quot;functions/lcfirst&quot;&gt;lcfirst&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;functions/ucfirst&quot;&gt;ucfirst&lt;/a&gt;&lt;/code&gt; 함수와 유사한 기능을 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="93a2720acec49cfe060d50c7a0a7fff2508e38b0" translate="yes" xml:space="preserve">
          <source>A number of backslash sequences have to do with changing the character, or characters following them. &lt;code&gt;\l&lt;/code&gt; will lowercase the character following it, while &lt;code&gt;\u&lt;/code&gt; will uppercase (or, more accurately, titlecase) the character following it. They provide functionality similar to the functions &lt;code&gt;lcfirst&lt;/code&gt; and &lt;code&gt;ucfirst&lt;/code&gt;.</source>
          <target state="translated">많은 백 슬래시 시퀀스는 문자 또는 그 뒤에 오는 문자 변경과 관련이 있습니다. &lt;code&gt;\l&lt;/code&gt; 은 뒤에 오는 문자를 소문자로, &lt;code&gt;\u&lt;/code&gt; 는 뒤에 오는 문자 를 대문자 (또는 더 정확하게는 제목)로 표시합니다. &lt;code&gt;lcfirst&lt;/code&gt; 및 &lt;code&gt;ucfirst&lt;/code&gt; 함수와 유사한 기능을 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="459b7ae43dc0118e5f951dff6050b593d0645ae4" translate="yes" xml:space="preserve">
          <source>A number of canned filers are provided with this module. They cover a number of the main areas that filters are needed when interfacing with DBM files. They also act as templates for your own filters.</source>
          <target state="translated">이 모듈에는 여러 통조림 파일러가 제공됩니다. DBM 파일과 인터페이스 할 때 필터가 필요한 여러 가지 주요 영역을 다룹니다. 또한 필터를위한 템플릿 역할을합니다.</target>
        </trans-unit>
        <trans-unit id="f165970578836ece242fb56057dfca4b475f795a" translate="yes" xml:space="preserve">
          <source>A number of functions are supplied in</source>
          <target state="translated">많은 기능이 제공됩니다</target>
        </trans-unit>
        <trans-unit id="6be56084a39af168e51355bee3d9a2b6a1443404" translate="yes" xml:space="preserve">
          <source>A number of symbolic constants are required by some methods in &lt;code&gt;IO::Compress::Deflate&lt;/code&gt; . None are imported by default.</source>
          <target state="translated">&lt;code&gt;IO::Compress::Deflate&lt;/code&gt; 일부 메소드에는 많은 기호 상수가 필요 합니다 . 기본적으로는 가져 오지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4deb3640bfb1ba76e4eb91a284fff22ce6cde951" translate="yes" xml:space="preserve">
          <source>A number of symbolic constants are required by some methods in &lt;code&gt;IO::Compress::Deflate&lt;/code&gt;. None are imported by default.</source>
          <target state="translated">&lt;code&gt;IO::Compress::Deflate&lt;/code&gt; 일부 메서드에는 여러 기호 상수가 필요 합니다 . 기본적으로 가져 오는 것은 없습니다.</target>
        </trans-unit>
        <trans-unit id="f171c4c952b5198d03d74dd09582818a3af3ac23" translate="yes" xml:space="preserve">
          <source>A number of symbolic constants are required by some methods in &lt;code&gt;IO::Compress::Gzip&lt;/code&gt; . None are imported by default.</source>
          <target state="translated">&lt;code&gt;IO::Compress::Gzip&lt;/code&gt; 일부 메소드에는 많은 기호 상수가 필요합니다 . 기본적으로는 가져 오지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3c0835dba02f363011b0b421bc52d49d766ce416" translate="yes" xml:space="preserve">
          <source>A number of symbolic constants are required by some methods in &lt;code&gt;IO::Compress::Gzip&lt;/code&gt;. None are imported by default.</source>
          <target state="translated">&lt;code&gt;IO::Compress::Gzip&lt;/code&gt; 일부 메서드에는 여러 기호 상수가 필요합니다 . 기본적으로 가져 오는 것은 없습니다.</target>
        </trans-unit>
        <trans-unit id="8444a37c81d8d0b0573487ab107c561cc0dcc2fd" translate="yes" xml:space="preserve">
          <source>A number of symbolic constants are required by some methods in &lt;code&gt;IO::Compress::RawDeflate&lt;/code&gt; . None are imported by default.</source>
          <target state="translated">&lt;code&gt;IO::Compress::RawDeflate&lt;/code&gt; 일부 메소드에는 많은 기호 상수가 필요합니다 . 기본적으로는 가져 오지 않습니다.</target>
        </trans-unit>
        <trans-unit id="625cd39bbda422f4927006460178ed47c79bf138" translate="yes" xml:space="preserve">
          <source>A number of symbolic constants are required by some methods in &lt;code&gt;IO::Compress::RawDeflate&lt;/code&gt;. None are imported by default.</source>
          <target state="translated">&lt;code&gt;IO::Compress::RawDeflate&lt;/code&gt; 일부 메서드에는 여러 기호 상수가 필요합니다 . 기본적으로 가져 오는 것은 없습니다.</target>
        </trans-unit>
        <trans-unit id="2b8207ded75c4eb74b9b2506733acf10f3db4dee" translate="yes" xml:space="preserve">
          <source>A number of symbolic constants are required by some methods in &lt;code&gt;IO::Compress::Zip&lt;/code&gt; . None are imported by default.</source>
          <target state="translated">&lt;code&gt;IO::Compress::Zip&lt;/code&gt; 일부 메소드에는 많은 기호 상수가 필요합니다 . 기본적으로는 가져 오지 않습니다.</target>
        </trans-unit>
        <trans-unit id="81a3e04f06d43cad2f607ec957e7b72dedcb4f99" translate="yes" xml:space="preserve">
          <source>A number of symbolic constants are required by some methods in &lt;code&gt;IO::Compress::Zip&lt;/code&gt;. None are imported by default.</source>
          <target state="translated">&lt;code&gt;IO::Compress::Zip&lt;/code&gt; 일부 메서드에는 여러 기호 상수가 필요합니다 . 기본적으로 가져 오는 것은 없습니다.</target>
        </trans-unit>
        <trans-unit id="13520cd60b01e1d5b0a654b3de30cd8d691bfd72" translate="yes" xml:space="preserve">
          <source>A number of the perl self-tests fails for various reasons; generally these are minor and due to subtle differences between common POSIX-based environments and the OpenVOS POSIX environment. Ensure that you conduct sufficient testing of your code to guarantee that it works properly in the OpenVOS environment.</source>
          <target state="translated">여러 가지 펄 자체 테스트는 여러 가지 이유로 실패합니다. 일반적으로 이는 사소하고 일반적인 POSIX 기반 환경과 OpenVOS POSIX 환경의 미묘한 차이로 인해 발생합니다. OpenVOS 환경에서 코드가 올바르게 작동하는지 확인하기 위해 코드를 충분히 테스트해야합니다.</target>
        </trans-unit>
        <trans-unit id="6938035226ed22bf21a82d2591890e65b71e1814" translate="yes" xml:space="preserve">
          <source>A number or quoted &lt;b&gt;string&lt;/b&gt;&amp;mdash;an actual &lt;b&gt;value&lt;/b&gt; in the text of your program, as opposed to a &lt;b&gt;variable&lt;/b&gt;.</source>
          <target state="translated">&lt;b&gt;변수&lt;/b&gt; 와 달리 프로그램 텍스트의 실제 &lt;b&gt;값인&lt;/b&gt; 숫자 또는 따옴표로 묶은 &lt;b&gt;문자열&lt;/b&gt; 입니다.&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="817e0a226397234bf07db9517946a4f73aedf564" translate="yes" xml:space="preserve">
          <source>A number with no fractional (decimal) part. A counting number, like 1, 2, 3, and so on, but including 0 and the negatives.</source>
          <target state="translated">소수 (10 진) 부분이없는 숫자입니다. 1, 2, 3 등과 같은 계수 숫자이지만 0과 음수를 포함합니다.</target>
        </trans-unit>
        <trans-unit id="c7326b507f702c91b1651bab340f7fd9d1233ba7" translate="yes" xml:space="preserve">
          <source>A numeric value corresponding to the desired exit status</source>
          <target state="translated">원하는 종료 상태에 해당하는 숫자 값</target>
        </trans-unit>
        <trans-unit id="516dd9f40fab20fab164bbcf97c01e41beccb620" translate="yes" xml:space="preserve">
          <source>A numeric value corresponding to the desired exit status.</source>
          <target state="translated">원하는 종료 상태에 해당하는 숫자 값입니다.</target>
        </trans-unit>
        <trans-unit id="f65805b27975bd2ea9ebc728a7ffd9aba1dc2684" translate="yes" xml:space="preserve">
          <source>A one- or two-character abbreviation for the OP's name.</source>
          <target state="translated">OP 이름의 한자 또는 두자 약어.</target>
        </trans-unit>
        <trans-unit id="3834679d6aeef19dae7b1ac9263711aa538649cc" translate="yes" xml:space="preserve">
          <source>A opposite problem occurs if you extract a UTF8-encoded file from a tarball. Using &lt;code&gt;get_content()&lt;/code&gt; on the &lt;code&gt;Archive::Tar::File&lt;/code&gt; object will return its content as a bytestring, not as a Unicode string.</source>
          <target state="translated">tarball에서 UTF8로 인코딩 된 파일을 추출하면 반대의 문제가 발생합니다. &lt;code&gt;Archive::Tar::File&lt;/code&gt; 객체 에서 &lt;code&gt;get_content()&lt;/code&gt; 를 사용하면 내용이 유니 코드 문자열이 아닌 바이트 문자열로 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="d534bb490c9aaec5af5d234ddc4047716ba79bca" translate="yes" xml:space="preserve">
          <source>A package statement affects dynamic variables only, including those you've used &lt;a href=&quot;#local-EXPR&quot;&gt;&lt;code&gt;local&lt;/code&gt;&lt;/a&gt; on, but</source>
          <target state="translated">패키지 문은 &lt;a href=&quot;#local-EXPR&quot;&gt; &lt;code&gt;local&lt;/code&gt; &lt;/a&gt; 에서 사용한 변수를 포함하여 동적 변수에만 영향을 미칩니다.</target>
        </trans-unit>
        <trans-unit id="7d591c8e0c3b224f857fbffdd8e1cd395cd343c4" translate="yes" xml:space="preserve">
          <source>A package statement affects dynamic variables only, including those you've used &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; on, but</source>
          <target state="translated">package 문은 &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; 에서 사용한 변수를 포함하여 동적 변수에만 영향을 주지만</target>
        </trans-unit>
        <trans-unit id="fb0a21b3a9fa52dc9e4b76474cd2a329094bf2cb" translate="yes" xml:space="preserve">
          <source>A package statement affects dynamic variables only, including those you've used &lt;code&gt;&lt;a href=&quot;local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; on, but</source>
          <target state="translated">package 문은 &lt;code&gt;&lt;a href=&quot;local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; 에서 사용한 변수를 포함하여 동적 변수에만 영향을 주지만</target>
        </trans-unit>
        <trans-unit id="17811bc7788393455d0445378861485836290fe5" translate="yes" xml:space="preserve">
          <source>A packet of data, such as a &lt;b&gt;UDP&lt;/b&gt; message, that (from the viewpoint of the programs involved) can be sent independently over the network. (In fact, all packets are sent independently at the &lt;b&gt;IP&lt;/b&gt; level, but &lt;b&gt;stream&lt;/b&gt; protocols such as &lt;b&gt;TCP&lt;/b&gt; hide this from your program.)</source>
          <target state="translated">&lt;b&gt;UDP&lt;/b&gt; 메시지 와 같은 데이터 패킷은 관련 프로그램의 관점에서 네트워크를 통해 독립적으로 전송 될 수 있습니다. 실제로 모든 패킷은 &lt;b&gt;IP&lt;/b&gt; 수준 에서 독립적으로 전송 되지만 &lt;b&gt;TCP&lt;/b&gt; 와 같은 &lt;b&gt;스트림&lt;/b&gt; 프로토콜은 이를 프로그램에서 숨 깁니다.&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="41fc1fe8da73d2058878cb04079cedd356502e52" translate="yes" xml:space="preserve">
          <source>A parameter list for the constructor is a hash, which can include a special key &lt;code&gt;locale&lt;/code&gt; and its value (case-insensitive) standing for a Unicode base language code (two or three-letter). For example, &lt;code&gt;Unicode::Collate::Locale-&amp;gt;new(locale =&amp;gt; 'ES')&lt;/code&gt; returns a collator tailored for Spanish.</source>
          <target state="translated">생성자에 대한 매개 변수 목록은 해시로, 유니 코드 기본 언어 코드 (2 자 또는 3 자)를 나타내는 특수 키 &lt;code&gt;locale&lt;/code&gt; 및 해당 값 (대소 문자 구분 안함)을 포함 할 수 있습니다 . 예를 들어 &lt;code&gt;Unicode::Collate::Locale-&amp;gt;new(locale =&amp;gt; 'ES')&lt;/code&gt; 는 스페인어에 맞게 조정 된 조합기를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="a8fade7e7e6957062a1ff55f1cde07bb98b07451" translate="yes" xml:space="preserve">
          <source>A parenthesized &lt;b&gt;subpattern&lt;/b&gt; used to group parts of a &lt;b&gt;regular expression&lt;/b&gt; into a single &lt;b&gt;atom&lt;/b&gt;.</source>
          <target state="translated">&lt;b&gt;정규 표현식의&lt;/b&gt; 일부를 단일 &lt;b&gt;원자로&lt;/b&gt; 그룹화하는 데 사용되는 괄호로 묶인 &lt;b&gt;하위 패턴&lt;/b&gt; 입니다.&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="d31a105759b488881233b964b8bc299b268f919f" translate="yes" xml:space="preserve">
          <source>A particular 8-bit extension to ASCII that includes grave and acute accented Latin characters. Languages that can employ ISO 8859-1 include all the languages covered by ASCII as well as Afrikaans, Albanian, Basque, Catalan, Danish, Faroese, Finnish, Norwegian, Portuguese, Spanish, and Swedish. Dutch is covered albeit without the ij ligature. French is covered too but without the oe ligature. German can use ISO 8859-1 but must do so without German-style quotation marks. This set is based on Western European extensions to ASCII and is commonly encountered in world wide web work. In IBM character code set identification terminology, ISO 8859-1 is also known as CCSID 819 (or sometimes 0819 or even 00819).</source>
          <target state="translated">억음 악센트가있는 라틴 문자를 포함하는 ASCII의 특정 8 비트 확장. ISO 8859-1을 사용할 수있는 언어에는 ASCII뿐만 아니라 아프리칸스어, 알바니아어, 바스크어, 카탈로니아 어, 덴마크어, 파로 어, 핀란드어, 노르웨이어, 포르투갈어, 스페인어 및 스웨덴어가 포함 된 모든 언어가 포함됩니다. 네덜란드어는 ij 합자 없이도 보장됩니다. 프랑스어도 oe 합자없이 적용됩니다. 독일어는 ISO 8859-1을 사용할 수 있지만 독일어 스타일 인용 부호없이 사용해야합니다. 이 세트는 ASCII에 대한 서유럽 확장을 기반으로하며 일반적으로 월드 와이드 웹 작업에서 발생합니다. IBM 문자 코드 세트 식별 용어에서 ISO 8859-1은 CCSID 819 (또는 때로는 0819 또는 00819)라고도합니다.</target>
        </trans-unit>
        <trans-unit id="e0e8dc4da39b64602467413f10af7327c1334e77" translate="yes" xml:space="preserve">
          <source>A past developer of this module once said that it was no longer being actively developed. However, rumors of its demise were greatly exaggerated. Feedback and suggestions are quite welcome.</source>
          <target state="translated">이 모듈의 과거 개발자는 더 이상 적극적으로 개발되고 있지 않다고 말했습니다. 그러나 그 소멸에 대한 소문이 크게 과장되었습니다. 피드백과 제안은 매우 환영합니다.</target>
        </trans-unit>
        <trans-unit id="8c54ff10ac1e2c9e724650394df49761e14faa10" translate="yes" xml:space="preserve">
          <source>A patch is likely to be rejected if it closes off future avenues of development. For instance, a patch that placed a true and final interpretation on prototypes is likely to be rejected because there are still options for the future of prototypes that haven't been addressed.</source>
          <target state="translated">패치가 향후 개발 경로를 막 으면 거부 될 수 있습니다. 예를 들어, 프로토 타입에 대해 진실되고 최종적인 해석을 한 패치는 아직 해결되지 않은 프로토 타입의 미래에 대한 옵션이 여전히 있기 때문에 거부 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8b84380ed4a63c4a53b35f4fed5c94c1acb30451" translate="yes" xml:space="preserve">
          <source>A pattern that contains one or more variables to be interpolated before parsing the pattern as a &lt;b&gt;regular expression&lt;/b&gt;, and that therefore cannot be analyzed at compile time, but must be reanalyzed each time the pattern match operator is evaluated. Runtime patterns are useful but expensive.</source>
          <target state="translated">패턴을 파싱하기 전에 보간 할 하나 이상의 변수를 포함하는 패턴 &lt;b&gt; 정규식&lt;/b&gt; 컴파일시 분석 할 수 없지만 패턴 일치 연산자가 평가 될 때마다 재분석되어야합니다. 런타임 패턴은 유용하지만 비용이 많이 듭니다.</target>
        </trans-unit>
        <trans-unit id="e54b749fa56abf529dd225e42a12bbcecb4cb20e" translate="yes" xml:space="preserve">
          <source>A pattern that is compiled with the &lt;code&gt;/u&lt;/code&gt; or &lt;code&gt;/a&lt;/code&gt; modifiers is treated as Unicode (though there are some restrictions with &lt;code&gt;/a&lt;/code&gt; ). Under the &lt;code&gt;/d&lt;/code&gt; and &lt;code&gt;/l&lt;/code&gt; modifiers, there are several other indications for Unicode; see &lt;a href=&quot;perlre#Character-set-modifiers&quot;&gt;Character set modifiers in perlre&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;/u&lt;/code&gt; 또는 &lt;code&gt;/a&lt;/code&gt; 수정 자로 컴파일 된 패턴은 유니 코드로 취급됩니다 ( &lt;code&gt;/a&lt;/code&gt; 에는 약간의 제한 이 있음 ). &lt;code&gt;/d&lt;/code&gt; 및 &lt;code&gt;/l&lt;/code&gt; 수정 자 아래에는 유니 코드에 대한 여러 가지 다른 표시가 있습니다. 보다&lt;a href=&quot;perlre#Character-set-modifiers&quot;&gt;perlre의 문자 세트 수정자를&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c44383cd9d72dfa1b63f63e5ddbda12ce021d43c" translate="yes" xml:space="preserve">
          <source>A pattern that is compiled with the &lt;code&gt;/u&lt;/code&gt; or &lt;code&gt;/a&lt;/code&gt; modifiers is treated as Unicode (though there are some restrictions with &lt;code&gt;/a&lt;/code&gt;). Under the &lt;code&gt;/d&lt;/code&gt; and &lt;code&gt;/l&lt;/code&gt; modifiers, there are several other indications for Unicode; see &lt;a href=&quot;perlre#Character-set-modifiers&quot;&gt;&quot;Character set modifiers&quot; in perlre&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;/u&lt;/code&gt; 또는 &lt;code&gt;/a&lt;/code&gt; 수정 자로 컴파일 된 패턴은 유니 코드로 처리됩니다 ( &lt;code&gt;/a&lt;/code&gt; 에는 몇 가지 제한 사항 이 있음 ). &lt;code&gt;/d&lt;/code&gt; 및 &lt;code&gt;/l&lt;/code&gt; 수정 자 아래에는 유니 코드에 대한 몇 가지 다른 표시가 있습니다. &lt;a href=&quot;perlre#Character-set-modifiers&quot;&gt;perlre의 &quot;문자 세트 수정 자&quot;를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ac81362ffb97f570e29dfbe7c502b0eb97a9aae0" translate="yes" xml:space="preserve">
          <source>A person with permissions to index a &lt;b&gt;namespace&lt;/b&gt; in &lt;b&gt;PAUSE&lt;/b&gt;. Anyone can upload any namespace, but only primary and co-maintainers get their contributions indexed.</source>
          <target state="translated">인덱스 A는 권한을 가진 사람 &lt;b&gt;네임 스페이스&lt;/b&gt; 에서 &lt;b&gt;PAUSE&lt;/b&gt; . 누구나 네임 스페이스를 업로드 할 수 있지만 기본 및 공동 유지 관리자 만 기여를 색인화합니다.</target>
        </trans-unit>
        <trans-unit id="9102b11ae3e872fd1d8e80bc53ef699d92261f27" translate="yes" xml:space="preserve">
          <source>A phrase is a function; a phrasebook is a bunch of functions.</source>
          <target state="translated">구는 기능입니다. 관용구는 여러 기능입니다.</target>
        </trans-unit>
        <trans-unit id="bdf584f5364a06bf31c21ab092ad59923872f304" translate="yes" xml:space="preserve">
          <source>A pidgin-like lingo spoken among &amp;rsquo;droids when they don&amp;rsquo;t wish to reveal their orientation (see &lt;b&gt;endian&lt;/b&gt;). Named after some similar languages spoken (for similar reasons) between compilers and interpreters in the late 20ᵗʰ century. These languages are characterized by representing everything as a nonarchitecture-dependent sequence of bytes.</source>
          <target state="translated">방향을 밝히고 싶지 않을 때 '드로이드들 사이에서 말하는 피진 같은 링고 ( &lt;b&gt;엔디안&lt;/b&gt; 참조)&lt;b&gt;&lt;/b&gt; ). 20 세기 후반 컴파일러와 인터프리터 사이에서 비슷한 이유로 사용되는 유사한 언어의 이름을 따서 명명되었습니다. 이러한 언어는 모든 것을 아키텍처에 의존하지 않는 바이트 시퀀스로 나타내는 것이 특징입니다.</target>
        </trans-unit>
        <trans-unit id="d44cad0ebf83404ba135e65877b0a7348740b15c" translate="yes" xml:space="preserve">
          <source>A piece of &lt;b&gt;memory&lt;/b&gt; accessible by two different &lt;b&gt;processes&lt;/b&gt; who otherwise would not see each other&amp;rsquo;s memory.</source>
          <target state="translated">의 조각 &lt;b&gt;메모리&lt;/b&gt; 두 개의 서로 다른 액세스 &lt;b&gt;프로세스&lt;/b&gt; 그렇지 않으면 서로의 메모리를 참조하지 않을 것입니다.</target>
        </trans-unit>
        <trans-unit id="ae75b42221a978d2300d9bbb31da21cdb6583f30" translate="yes" xml:space="preserve">
          <source>A piece of data supplied to a &lt;b&gt;program&lt;/b&gt;, &lt;b&gt;subroutine&lt;/b&gt;, &lt;b&gt;function&lt;/b&gt;, or &lt;b&gt;method&lt;/b&gt; to tell it what it&amp;rsquo;s supposed to do. Also called a &amp;ldquo;parameter&amp;rdquo;.</source>
          <target state="translated">데이터의 조각은 공급 &lt;b&gt;프로그램&lt;/b&gt; , &lt;b&gt;서브 루틴&lt;/b&gt; , &lt;b&gt;기능&lt;/b&gt; , 또는 &lt;b&gt;방법&lt;/b&gt; 이하기로되어 있는지를 알 수 있습니다. &quot;파라미터&quot;라고도합니다.</target>
        </trans-unit>
        <trans-unit id="94f70c32cf9b02415f8a7273bc9818046dbf12f7" translate="yes" xml:space="preserve">
          <source>A piece of data worth eight &lt;b&gt;bits&lt;/b&gt; in most places.</source>
          <target state="translated">8 &lt;b&gt;비트&lt;/b&gt; 가치의 데이터&lt;b&gt;&lt;/b&gt;대부분의 장소에서 .</target>
        </trans-unit>
        <trans-unit id="b577f26c3053457a977acc838db8d07639cc6ac7" translate="yes" xml:space="preserve">
          <source>A pitfall when fallback is TRUE and Perl resorts to a built-in implementation of an operator is that some operators have more than one semantic, for example &lt;code&gt;|&lt;/code&gt;:</source>
          <target state="translated">대체가 TRUE와 펄 리조트 인 함정 내장 연산자의 구현 일부 사업자는 예를 들어, 하나 이상의 의미가 있다는 것입니다 &lt;code&gt;|&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="d50a84892f70340bd3a9931b241841288e99df2a" translate="yes" xml:space="preserve">
          <source>A plain &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; autodie&lt;/code&gt; implies &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; autodie qw(:default)&lt;/code&gt; . Note that &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; are not enabled by default. &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; requires the optional &lt;a href=&quot;http://search.cpan.org/perldoc/IPC::System::Simple&quot;&gt;IPC::System::Simple&lt;/a&gt; module to be installed, and enabling &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; will invalidate their exotic forms. See &lt;a href=&quot;#BUGS&quot;&gt;BUGS&lt;/a&gt; below for more details.</source>
          <target state="translated">일반 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; autodie&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; autodie qw(:default)&lt;/code&gt; 의미 합니다 . 참고 &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; 기본적으로 활성화되어 있지 않습니다. &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; 에는 옵션 &lt;a href=&quot;http://search.cpan.org/perldoc/IPC::System::Simple&quot;&gt;IPC :: System :: Simple&lt;/a&gt; 모듈을 설치해야하며 &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; 를 활성화 하면 이국적인 형식이 무효화됩니다. 자세한 내용은 아래 &lt;a href=&quot;#BUGS&quot;&gt;버그&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="784586eba74e7681571d441503dffdaa38283f14" translate="yes" xml:space="preserve">
          <source>A plain &lt;code&gt;use autodie&lt;/code&gt; implies &lt;code&gt;use autodie qw(:default)&lt;/code&gt;. Note that &lt;code&gt;system&lt;/code&gt; and &lt;code&gt;exec&lt;/code&gt; are not enabled by default. &lt;code&gt;system&lt;/code&gt; requires the optional &lt;a href=&quot;IPC::System::Simple&quot;&gt;IPC::System::Simple&lt;/a&gt; module to be installed, and enabling &lt;code&gt;system&lt;/code&gt; or &lt;code&gt;exec&lt;/code&gt; will invalidate their exotic forms. See &lt;a href=&quot;#BUGS&quot;&gt;&quot;BUGS&quot;&lt;/a&gt; below for more details.</source>
          <target state="translated">일반 &lt;code&gt;use autodie&lt;/code&gt; &lt;code&gt;use autodie qw(:default)&lt;/code&gt; 의미 합니다 . 참고 &lt;code&gt;system&lt;/code&gt; 및 &lt;code&gt;exec&lt;/code&gt; 기본적으로 활성화되어 있지 않습니다. &lt;code&gt;system&lt;/code&gt; 은 선택적인 &lt;a href=&quot;IPC::System::Simple&quot;&gt;IPC :: System :: Simple&lt;/a&gt; 모듈을 설치해야하며 &lt;code&gt;system&lt;/code&gt; 또는 &lt;code&gt;exec&lt;/code&gt; 를 활성화 하면 이국적인 형식이 무효화됩니다. 자세한 내용은 아래 &lt;a href=&quot;#BUGS&quot;&gt;&quot;버그&quot;&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="b5112ffa79f8fbea8b85cd379c0dac6621cfbb1b" translate="yes" xml:space="preserve">
          <source>A port of SysV IPC is available for Cygwin.</source>
          <target state="translated">Cygwin에 SysV IPC 포트를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="608e0fee3c4504f82197f6257599cc064afc0c33" translate="yes" xml:space="preserve">
          <source>A port of dmake for Windows is available from:</source>
          <target state="translated">Windows 용 dmake 포트는 다음에서 사용 가능합니다.</target>
        </trans-unit>
        <trans-unit id="107ead699a34a6b92016575e257f6bfde51b2d06" translate="yes" xml:space="preserve">
          <source>A portion of a &lt;b&gt;string&lt;/b&gt;, starting at a certain &lt;b&gt;character&lt;/b&gt; position (&lt;b&gt;offset&lt;/b&gt;) and proceeding for a certain number of characters.</source>
          <target state="translated">특정 &lt;b&gt;문자&lt;/b&gt; 위치 에서 시작 하는 &lt;b&gt;문자열&lt;/b&gt; 의 일부 ( &lt;b&gt;오프셋&lt;/b&gt;&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt; ) 수로 진행 .</target>
        </trans-unit>
        <trans-unit id="2df08b2dab9ca8b1fdefb915b96c623e0200cba0" translate="yes" xml:space="preserve">
          <source>A positional parameter is made optional by giving a default value, separated from the parameter name by &lt;code&gt;=&lt;/code&gt; :</source>
          <target state="translated">위치 매개 변수는 매개 변수 이름과 &lt;code&gt;=&lt;/code&gt; 로 구분 된 기본값을 제공하여 선택 사항입니다 .</target>
        </trans-unit>
        <trans-unit id="0b4ce78434f00859636eea671cd22aebe6d9b1f5" translate="yes" xml:space="preserve">
          <source>A positional parameter is made optional by giving a default value, separated from the parameter name by &lt;code&gt;=&lt;/code&gt;:</source>
          <target state="translated">위치 매개 변수는 &lt;code&gt;=&lt;/code&gt; 로 매개 변수 이름과 구분 된 기본값을 제공하여 선택 사항이됩니다 .</target>
        </trans-unit>
        <trans-unit id="b85d6bf4f6c4fdd5d60e077f21d5dcceb61dc47f" translate="yes" xml:space="preserve">
          <source>A possibly-threaded program using a possibly-threaded module might have code like this:</source>
          <target state="translated">스레드 가능 모듈을 사용하는 스레드 가능 프로그램에는 다음과 같은 코드가있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d97df54b4f20c3925188511860c47d716ece4831" translate="yes" xml:space="preserve">
          <source>A powerful tool for optimizing such beasts is what is known as an &quot;independent group&quot;, which does not backtrack (see &lt;a href=&quot;#%28%3F%3Epattern%29&quot;&gt;&quot;&lt;code&gt;(?&amp;gt;pattern)&lt;/code&gt;&quot;&lt;/a&gt;). Note also that zero-length lookahead/lookbehind assertions will not backtrack to make the tail match, since they are in &quot;logical&quot; context: only whether they match is considered relevant. For an example where side-effects of lookahead</source>
          <target state="translated">이러한 야수를 최적화하기위한 강력한 도구는 &quot;독립 그룹&quot;으로 알려진 것으로 역 추적하지 않습니다 ( &lt;a href=&quot;#%28%3F%3Epattern%29&quot;&gt;&quot; &lt;code&gt;(?&amp;gt;pattern)&lt;/code&gt; &quot;참조&lt;/a&gt; ). 길이가 0 인 lookahead / lookbehind 어설 션은 &quot;논리적&quot;컨텍스트에 있기 때문에 꼬리 일치를 만들기 위해 역 추적하지 않습니다. 일치 여부 만 관련이있는 것으로 간주됩니다. 예견의 부작용이있는 경우</target>
        </trans-unit>
        <trans-unit id="6b3a72b5c10540ed557a8982bdee312dd7a07842" translate="yes" xml:space="preserve">
          <source>A powerful tool for optimizing such beasts is what is known as an &quot;independent group&quot;, which does not backtrack (see &lt;a href=&quot;#(%3f%3epattern)&quot;&gt;(?&amp;gt;pattern)&lt;/a&gt;). Note also that zero-length look-ahead/look-behind assertions will not backtrack to make the tail match, since they are in &quot;logical&quot; context: only whether they match is considered relevant. For an example where side-effects of look-ahead</source>
          <target state="translated">이러한 짐승을 최적화하기위한 강력한 도구는 &quot;독립 그룹&quot;으로 알려져 있으며 역 추적을하지 않습니다 ( &lt;a href=&quot;#(%3f%3epattern)&quot;&gt;(?&amp;gt; 패턴&lt;/a&gt; 참조 ) ). 길이가 0 인 미리보기 / look-behind 어설 션은 &quot;논리적&quot;컨텍스트에 있기 때문에 꼬리가 일치하도록 역 추적하지 않습니다. 일치 여부 만 관련이있는 것으로 간주됩니다. 예견의 부작용이있는 예</target>
        </trans-unit>
        <trans-unit id="f8090f10d3e078e45a1b56ad19ca0993e67735bf" translate="yes" xml:space="preserve">
          <source>A pragma is a module which influences some aspect of the compile time or run time behaviour of Perl, such as &lt;code&gt;strict&lt;/code&gt; or &lt;code&gt;warnings&lt;/code&gt; . With Perl 5.10 you are no longer limited to the built in pragmata; you can now create user pragmata that modify the behaviour of user functions within a lexical scope.</source>
          <target state="translated">pragma는 &lt;code&gt;strict&lt;/code&gt; 또는 &lt;code&gt;warnings&lt;/code&gt; 와 같이 Perl의 컴파일 시간 또는 런타임 동작의 일부 측면에 영향을주는 모듈입니다. . Perl 5.10에서는 더 이상 내장 된 pragmata로 제한되지 않습니다. 이제 어휘 범위 내에서 사용자 기능의 동작을 수정하는 사용자 pragmata를 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="49eb60196e1bcc3fb82f50394c222a091a65381b" translate="yes" xml:space="preserve">
          <source>A pragma is a module which influences some aspect of the compile time or run time behaviour of Perl, such as &lt;code&gt;strict&lt;/code&gt; or &lt;code&gt;warnings&lt;/code&gt;. With Perl 5.10 you are no longer limited to the built in pragmata; you can now create user pragmata that modify the behaviour of user functions within a lexical scope.</source>
          <target state="translated">pragma는 &lt;code&gt;strict&lt;/code&gt; 또는 &lt;code&gt;warnings&lt;/code&gt; 와 같은 Perl의 컴파일 시간 또는 런타임 동작의 일부 측면에 영향을주는 모듈입니다 . Perl 5.10에서는 더 이상 내장 된 pragmata로 제한되지 않습니다. 이제 어휘 범위 내에서 사용자 함수의 동작을 수정하는 사용자 pragmata를 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3adf63746ff6644ce7bf5f35f924e0b644796838" translate="yes" xml:space="preserve">
          <source>A precomputed hash value for the MRO's name, or 0.</source>
          <target state="translated">MRO 이름의 사전 계산 된 해시 값 또는 0</target>
        </trans-unit>
        <trans-unit id="fef186fd41bd258794b7d0075ad4e261c2b3c05f" translate="yes" xml:space="preserve">
          <source>A predefined &lt;b&gt;character class&lt;/b&gt; matchable by the &lt;code&gt;\p&lt;/code&gt; or &lt;code&gt;\P&lt;/code&gt;&lt;b&gt;metasymbol&lt;/b&gt;. &lt;b&gt;Unicode&lt;/b&gt; defines hundreds of standard properties for every possible codepoint, and Perl defines a few of its own, too.</source>
          <target state="translated">미리 정의 된 &lt;b&gt;문자 클래스&lt;/b&gt; 바이 정합 가능한 &lt;code&gt;\p&lt;/code&gt; 또는 &lt;code&gt;\P&lt;/code&gt; &lt;b&gt;metasymbol&lt;/b&gt; . &lt;b&gt;유니 코드&lt;/b&gt; 는 가능한 모든 코드 포인트에 대해 수백 가지의 표준 속성을 정의하고 Perl도 고유 한 몇 가지를 정의합니다.</target>
        </trans-unit>
        <trans-unit id="a831506546d580a7eadbcde59099e4315b6e4d7c" translate="yes" xml:space="preserve">
          <source>A prerequisite for any of the SDKs is to install ActivePerl from ActiveState, &lt;a href=&quot;http://www.activestate.com/Products/ActivePerl/&quot;&gt;http://www.activestate.com/Products/ActivePerl/&lt;/a&gt;</source>
          <target state="translated">SDK의 전제 조건은 ActiveState ( &lt;a href=&quot;http://www.activestate.com/Products/ActivePerl/&quot;&gt;http://www.activestate.com/Products/ActivePerl/)&lt;/a&gt; 에서 ActivePerl을 설치하는 것입니다 .</target>
        </trans-unit>
        <trans-unit id="753111eab29b1d3a3d48d9bfe5c8e1db8a75f990" translate="yes" xml:space="preserve">
          <source>A private implementation of the &lt;code&gt;SvIVx&lt;/code&gt; macro for compilers which can't cope with complex macro expressions. Always use the macro instead.</source>
          <target state="translated">의 개인 구현 &lt;code&gt;SvIVx&lt;/code&gt; 복잡한 매크로 표현에 대처할 수없는 컴파일러 용 매크로 . 항상 매크로를 대신 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="194c1f16db6963ad188c9a67ab4a97692452c7d0" translate="yes" xml:space="preserve">
          <source>A private implementation of the &lt;code&gt;SvNVx&lt;/code&gt; macro for compilers which can't cope with complex macro expressions. Always use the macro instead.</source>
          <target state="translated">의 개인 구현 &lt;code&gt;SvNVx&lt;/code&gt; 복잡한 매크로 표현에 대처할 수없는 컴파일러 용 SvNVx 매크로 . 항상 매크로를 대신 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="45f81efd0665fe345ae1ff71f7dc78b1d8a8b9cf" translate="yes" xml:space="preserve">
          <source>A private implementation of the &lt;code&gt;SvPV&lt;/code&gt; macro for compilers which can't cope with complex macro expressions. Always use the macro instead.</source>
          <target state="translated">의 개인 구현 &lt;code&gt;SvPV&lt;/code&gt; 복잡한 매크로 표현식에 대처할 수없는 컴파일러 용 SvPV 매크로 . 항상 매크로를 대신 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="28ff9ef13649ddfcf7cbf759240331fcc05c09ec" translate="yes" xml:space="preserve">
          <source>A private implementation of the &lt;code&gt;SvPVbyte&lt;/code&gt; macro for compilers which can't cope with complex macro expressions. Always use the macro instead.</source>
          <target state="translated">의 개인 구현 &lt;code&gt;SvPVbyte&lt;/code&gt; 복잡한 매크로 표현식에 대처할 수없는 컴파일러 용 SvPVbyte 매크로 . 항상 매크로를 대신 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="4c48a8487b346d5dd9b069a77af5f464c4aaa911" translate="yes" xml:space="preserve">
          <source>A private implementation of the &lt;code&gt;SvPVutf8&lt;/code&gt; macro for compilers which can't cope with complex macro expressions. Always use the macro instead.</source>
          <target state="translated">의 개인 구현 &lt;code&gt;SvPVutf8&lt;/code&gt; 복잡한 매크로 표현식에 대처할 수없는 컴파일러 용 매크로 . 항상 매크로를 대신 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="ccefc2a8adb4ddac3b369c74930a6dbb95e32f5b" translate="yes" xml:space="preserve">
          <source>A private implementation of the &lt;code&gt;SvUVx&lt;/code&gt; macro for compilers which can't cope with complex macro expressions. Always use the macro instead.</source>
          <target state="translated">&lt;code&gt;SvUVx&lt;/code&gt; 의 개인 구현복잡한 매크로 표현에 대처할 수없는 컴파일러 용 매크로 . 항상 매크로를 대신 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="daa3f361ccd92e0c8c69a72e7a450ec455f808bd" translate="yes" xml:space="preserve">
          <source>A process that has died (exited) but whose parent has not yet received proper notification of its demise by virtue of having called &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/waitpid&quot;&gt;waitpid&lt;/a&gt;&lt;/code&gt;. If you &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork&lt;/a&gt;&lt;/code&gt;, you must clean up after your child processes when they exit; otherwise, the process table will fill up and your system administrator will Not Be Happy with you.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait&lt;/a&gt;&lt;/code&gt; (종료)되었지만 부모가 wait 또는 &lt;code&gt;&lt;a href=&quot;functions/waitpid&quot;&gt;waitpid&lt;/a&gt;&lt;/code&gt; 를 호출하여 사망에 대한 적절한 알림을받지 않은 프로세스입니다 . &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork&lt;/a&gt;&lt;/code&gt; 하면 자녀가 퇴장 할 때 처리 한 후에 청소해야합니다. 그렇지 않으면 프로세스 테이블이 채워지고 시스템 관리자가 만족하지 않을 것입니다.</target>
        </trans-unit>
        <trans-unit id="10a925aa1992fe1dac52557b4ea82e693d886104" translate="yes" xml:space="preserve">
          <source>A process that has died (exited) but whose parent has not yet received proper notification of its demise by virtue of having called &lt;code&gt;wait&lt;/code&gt; or &lt;code&gt;waitpid&lt;/code&gt;. If you &lt;code&gt;fork&lt;/code&gt;, you must clean up after your child processes when they exit; otherwise, the process table will fill up and your system administrator will Not Be Happy with you.</source>
          <target state="translated">종료 (종료)되었지만 부모가 &lt;code&gt;wait&lt;/code&gt; 또는 &lt;code&gt;waitpid&lt;/code&gt; 를 호출하여 종료에 대한 적절한 알림을 아직받지 못한 프로세스입니다 . 당신이 경우 &lt;code&gt;fork&lt;/code&gt; 가 종료 할 때, 당신은 당신의 자식 프로세스 후에 정리해야합니다; 그렇지 않으면 프로세스 테이블이 채워지고 시스템 관리자가 만족하지 않을 것입니다.</target>
        </trans-unit>
        <trans-unit id="8efafe66eae216a82a4ad38f05565ca385de1f6b" translate="yes" xml:space="preserve">
          <source>A process that usually starts when the system boots and shuts down when the system is shut down is called a daemon (Disk And Execution MONitor). If a daemon process has a configuration file which is modified after the process has been started, there should be a way to tell that process to reread its configuration file without stopping the process. Many daemons provide this mechanism using a &lt;code&gt;SIGHUP&lt;/code&gt; signal handler. When you want to tell the daemon to reread the file, simply send it the &lt;code&gt;SIGHUP&lt;/code&gt; signal.</source>
          <target state="translated">일반적으로 시스템이 부팅 될 때 시작되고 시스템이 종료 될 때 종료되는 프로세스를 데몬 (디스크 및 실행 모니터)이라고합니다. 데몬 프로세스에 프로세스가 시작된 후 수정 된 구성 파일이있는 경우 프로세스를 중지하지 않고 해당 프로세스가 구성 파일을 다시 읽도록 지시 할 수있는 방법이 있습니다. 많은 데몬이 &lt;code&gt;SIGHUP&lt;/code&gt; 신호 처리기를 사용하여이 메커니즘을 제공 합니다. 데몬에게 파일을 다시 읽도록 지시하려면 &lt;code&gt;SIGHUP&lt;/code&gt; 신호 를 보내십시오 .</target>
        </trans-unit>
        <trans-unit id="2cb736d823d351c183302791cfaf0e9b2bb8195b" translate="yes" xml:space="preserve">
          <source>A program designed to take a &lt;b&gt;stream&lt;/b&gt; of input and transform it into a stream of output.</source>
          <target state="translated">입력 &lt;b&gt;스트림&lt;/b&gt; 을 가져 와서 출력 스트림으로 변환 하도록 설계된 프로그램입니다 .</target>
        </trans-unit>
        <trans-unit id="0e57854f673e33842a3f502762fb9daa3a8e1f70" translate="yes" xml:space="preserve">
          <source>A program or subroutine that runs some other program or subroutine for you, modifying some of its input or output to better suit your purposes.</source>
          <target state="translated">목적에 맞게 일부 입력 또는 출력을 수정하여 다른 프로그램 또는 서브 루틴을 실행하는 프로그램 또는 서브 루틴.</target>
        </trans-unit>
        <trans-unit id="d4949b399696681050e02e3aa6d195b375c7c318" translate="yes" xml:space="preserve">
          <source>A program technique that lets you evaluate an &lt;b&gt;expression&lt;/b&gt; and then, based on the value of the expression, do a multiway branch to the appropriate piece of code for that value. Also called a &amp;ldquo;case structure&amp;rdquo;, named after the similar Pascal construct. Most switch statements in Perl are spelled &lt;code&gt;given&lt;/code&gt; . See &amp;ldquo;The &lt;code&gt;given&lt;/code&gt; statement&amp;rdquo; in Camel chapter 4, &amp;ldquo;Statements and Declarations&amp;rdquo;.</source>
          <target state="translated">&lt;b&gt;식&lt;/b&gt; 을 평가 한 다음 &lt;b&gt;식&lt;/b&gt; 의 값을 기반으로 해당 값에 해당하는 코드 조각에 대한 다중 분기를 수행 할 수있는 프로그램 기술입니다 . 비슷한 파스칼 구문의 이름을 딴&amp;ldquo;케이스 구조&amp;rdquo;라고도합니다. Perl의 대부분의 switch 문은 철자가 &lt;code&gt;given&lt;/code&gt; . Camel 4 장, &quot;설명 및 선언&quot;의 &quot; &lt;code&gt;given&lt;/code&gt; 진술&quot;을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="226a5640a6bc542b475e6c67b50cca7825517b1f" translate="yes" xml:space="preserve">
          <source>A program technique that lets you evaluate an &lt;b&gt;expression&lt;/b&gt; and then, based on the value of the expression, do a multiway branch to the appropriate piece of code for that value. Also called a &amp;ldquo;case structure&amp;rdquo;, named after the similar Pascal construct. Most switch statements in Perl are spelled &lt;code&gt;given&lt;/code&gt;. See &amp;ldquo;The &lt;code&gt;given&lt;/code&gt; statement&amp;rdquo; in Camel chapter 4, &amp;ldquo;Statements and Declarations&amp;rdquo;.</source>
          <target state="translated">&lt;b&gt;식&lt;/b&gt; 을 평가 한 다음 &lt;b&gt;식&lt;/b&gt; 의 값을 기반으로 해당 값에 대한 적절한 코드 조각으로 다중 분기를 수행 할 수있는 프로그램 기술입니다 . 유사한 Pascal 구조의 이름을 따서 명명 된 &quot;케이스 구조&quot;라고도합니다. Perl의 대부분의 switch 문은 철자가 &lt;code&gt;given&lt;/code&gt; . Camel 4 장,&amp;ldquo;진술 및 선언&amp;rdquo;의&amp;ldquo; &lt;code&gt;given&lt;/code&gt; 진술&amp;rdquo;을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="5911c3911da879ac96181b5190227b6bb058fcf1" translate="yes" xml:space="preserve">
          <source>A program that lets you step through the &lt;b&gt;execution&lt;/b&gt; of your program, stopping or printing things out here and there to see whether anything has gone wrong, and, if so, what. The &amp;ldquo;symbolic&amp;rdquo; part just means that you can talk to the debugger using the same symbols with which your program is written.</source>
          <target state="translated">프로그램 &lt;b&gt;실행&lt;/b&gt; 을 단계별로 진행 하여 여기저기서 인쇄하거나 중지하여 문제가 발생했는지 여부를 확인하는 프로그램입니다. &quot;기호&quot;부분은 프로그램 작성과 동일한 기호를 사용하여 디버거와 통신 할 수 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="e0a439842f796bec28d81800d0c2072dc425e000" translate="yes" xml:space="preserve">
          <source>A property may be deprecated, perhaps because its original intent has been replaced by another property, or because its specification was somehow defective. This means that its use is strongly discouraged, so much so that a warning will be issued if used, unless the regular expression is in the scope of a &lt;code&gt;no warnings 'deprecated'&lt;/code&gt; statement. A '&lt;b&gt;D&lt;/b&gt;' flags each such entry in the table, and the entry there for the longest, most descriptive version of the property will give the reason it is deprecated, and perhaps advice. Perl may issue such a warning, even for properties that aren't officially deprecated by Unicode, when there used to be characters or code points that were matched by them, but no longer. This is to warn you that your program may not work like it did on earlier Unicode releases.</source>
          <target state="translated">원래 의도가 다른 속성으로 대체되었거나 사양에 결함이 있었기 때문에 속성이 더 이상 사용되지 않을 수 있습니다. 즉, 정규식이 &lt;code&gt;no warnings 'deprecated'&lt;/code&gt; 문의 범위에 있지 않는 한 사용하면 경고가 발생하므로 사용하지 않는 것이 좋습니다. A ' &lt;b&gt;D&lt;/b&gt;'는 테이블의 각 항목에 플래그를 지정하고 속성의 가장 길고 가장 설명적인 버전에 대한 항목은 더 이상 사용되지 않는 이유와 조언을 제공합니다. Perl은 유니 코드에 의해 공식적으로 더 이상 사용되지 않는 속성에 대해서도 일치하지만 더 이상 일치하지 않는 문자 또는 코드 포인트가있을 때 이러한 경고를 표시 할 수 있습니다. 이는 프로그램이 이전 유니 코드 릴리스에서와 같이 작동하지 않을 수 있음을 경고하기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="58ccfd6a1d722c44d4bb4f0ae8561be32c66dd88" translate="yes" xml:space="preserve">
          <source>A property may be stabilized. Such a determination does not indicate that the property should or should not be used; instead it is a declaration that the property will not be maintained nor extended for newly encoded characters. Such properties are marked with an '&lt;b&gt;S&lt;/b&gt;' in the table.</source>
          <target state="translated">속성이 안정 될 수 있습니다. 그러한 결정은 해당 부동산이 사용되어야하거나 사용되어서는 안된다는 것을 나타내지 않습니다. 대신 새로 인코딩 된 문자에 대해 속성이 유지되거나 확장되지 않는다는 선언입니다. 이러한 속성은 표에서 ' &lt;b&gt;S&lt;/b&gt; ' 로 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="8959e21bc141d47a80e97a7ffb793dfa86254ad0" translate="yes" xml:space="preserve">
          <source>A property named 'var' is assumed to exist for the opcodes, and is interpolated into the rendering.</source>
          <target state="translated">'var'이라는 속성은 opcode에 대해 존재한다고 가정하고 렌더링에 보간됩니다.</target>
        </trans-unit>
        <trans-unit id="7afee4b0974cba3382e7bb4183222667ce915680" translate="yes" xml:space="preserve">
          <source>A property of certain characters. Originally, typesetter stored capital letters in the upper of two cases and small letters in the lower one. Unicode recognizes three cases: &lt;b&gt;lowercase&lt;/b&gt; (&lt;b&gt;character property&lt;/b&gt;&lt;code&gt;\p{lower}&lt;/code&gt; ), &lt;b&gt;titlecase&lt;/b&gt; (&lt;code&gt;\p{title}&lt;/code&gt; ), and &lt;b&gt;uppercase&lt;/b&gt; (&lt;code&gt;\p{upper}&lt;/code&gt; ). A fourth casemapping called &lt;b&gt;foldcase&lt;/b&gt; is not itself a distinct case, but it is used internally to implement &lt;b&gt;casefolding&lt;/b&gt;. Not all letters have case, and some nonletters have case.</source>
          <target state="translated">특정 문자의 속성. 원래, typeetter는 대문자 2 개를 대문자로, 소문자를 대문자로 저장했습니다. 유니 코드는 &lt;b&gt;소문자&lt;/b&gt; ( &lt;b&gt;문자 속성 &lt;/b&gt; &lt;code&gt;\p{lower}&lt;/code&gt; ), &lt;b&gt;제목&lt;/b&gt; ( &lt;code&gt;\p{title}&lt;/code&gt; ) 및 &lt;b&gt;대문자&lt;/b&gt; ( &lt;code&gt;\p{upper}&lt;/code&gt; )의 세 가지 경우를 인식 합니다. 네 번째 casemapping라는 &lt;b&gt;foldcase이&lt;/b&gt; 뚜렷한 경우 그 자체이지만 구현하기 위해 내부적으로 사용되는 &lt;b&gt;casefolding을&lt;/b&gt; . 모든 문자에 대소 문자가있는 것은 아니며 일부 비 문자에는 대소 문자가 있습니다.</target>
        </trans-unit>
        <trans-unit id="33b899d68b6367eee5e01ad07784bbb907d587b3" translate="yes" xml:space="preserve">
          <source>A property of certain characters. Originally, typesetter stored capital letters in the upper of two cases and small letters in the lower one. Unicode recognizes three cases: &lt;b&gt;lowercase&lt;/b&gt; (&lt;b&gt;character property&lt;/b&gt;&lt;code&gt;\p{lower}&lt;/code&gt;), &lt;b&gt;titlecase&lt;/b&gt; (&lt;code&gt;\p{title}&lt;/code&gt;), and &lt;b&gt;uppercase&lt;/b&gt; (&lt;code&gt;\p{upper}&lt;/code&gt;). A fourth casemapping called &lt;b&gt;foldcase&lt;/b&gt; is not itself a distinct case, but it is used internally to implement &lt;b&gt;casefolding&lt;/b&gt;. Not all letters have case, and some nonletters have case.</source>
          <target state="translated">특정 캐릭터의 속성. 원래 식 자기는 대문자는 대문자 2 개, 소문자는 소문자로 저장했습니다. 유니 코드는 &lt;b&gt;소문자&lt;/b&gt; ( &lt;b&gt;문자 속성 &lt;/b&gt; &lt;code&gt;\p{lower}&lt;/code&gt; ), &lt;b&gt;제목&lt;/b&gt; ( &lt;code&gt;\p{title}&lt;/code&gt; ) 및 &lt;b&gt;대문자&lt;/b&gt; ( &lt;code&gt;\p{upper}&lt;/code&gt; )의 세 가지 경우를 인식 합니다. foldcase라고하는 네 번째 케이스 &lt;b&gt;매핑&lt;/b&gt; 은 그 자체가 별개의 케이스가 아니라 케이스 &lt;b&gt;폴딩&lt;/b&gt; 을 구현하기 위해 내부적으로 사용됩니다 . 모든 문자에 대소 문자가있는 것은 아니며 일부 비 문자에는 대소 문자가 있습니다.</target>
        </trans-unit>
        <trans-unit id="992dca0adb9b646b76591cb61fee4cdfffebc9ec" translate="yes" xml:space="preserve">
          <source>A pseudo layer that removes the top-most layer. Gives perl code a way to manipulate the layer stack. Note that &lt;code&gt;:&lt;a href=&quot;functions/pop&quot;&gt;pop&lt;/a&gt;&lt;/code&gt; only works on real layers and will not undo the effects of pseudo layers like &lt;code&gt;:utf8&lt;/code&gt; . An example of a possible use might be:</source>
          <target state="translated">최상위 레이어를 제거하는 의사 레이어. 펄 코드에 레이어 스택을 조작하는 방법을 제공합니다. 참고 &lt;code&gt;:&lt;a href=&quot;functions/pop&quot;&gt;pop&lt;/a&gt;&lt;/code&gt; 만 실제 계층에서 작동하며 같은 의사 층의 효과가 취소되지 않습니다 &lt;code&gt;:utf8&lt;/code&gt; . 사용 가능한 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e9e574b20ec44e2ea9a82161cd9d396ddf6c16be" translate="yes" xml:space="preserve">
          <source>A pseudo-layer that removes the top-most layer. Gives Perl code a way to manipulate the layer stack. Note that &lt;code&gt;:pop&lt;/code&gt; only works on real layers and will not undo the effects of pseudo-layers or flags like &lt;code&gt;:utf8&lt;/code&gt;. An example of a possible use might be:</source>
          <target state="translated">최상위 레이어를 제거하는 의사 레이어입니다. Perl 코드에 레이어 스택을 조작하는 방법을 제공합니다. 참고 &lt;code&gt;:pop&lt;/code&gt; 만 실제 계층에서 작동하며 같은 의사 층의 효과 나 플래그 취소되지 않습니다 &lt;code&gt;:utf8&lt;/code&gt; . 가능한 사용의 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ff419cc31e5dd99b3e00b537155bcea526bbe610" translate="yes" xml:space="preserve">
          <source>A pseudolayer that enables a flag in the layer below to tell Perl that output should be in utf8 and that input should be regarded as already in valid utf8 form. &lt;b&gt;WARNING: It does not check for validity and as such should be handled with extreme caution for input, because security violations can occur with non-shortest UTF-8 encodings, etc.&lt;/b&gt; Generally &lt;code&gt;:encoding(utf8)&lt;/code&gt; is the best option when reading UTF-8 encoded data.</source>
          <target state="translated">아래 레이어의 플래그가 Perl에게 출력이 utf8이어야하고 입력이 이미 유효한 utf8 형식으로 간주되어야한다고 알 수있게하는 의사 레이어. &lt;b&gt;경고 : 유효성을 검사하지 않으므로 UTF-8 인코딩이 가장 짧지 않은 등의 보안 위반이 발생할 수 있으므로 입력시주의를 기울여 처리해야합니다. UTF-8을&lt;/b&gt; 읽을 때 일반적으로 &lt;code&gt;:encoding(utf8)&lt;/code&gt; 이 가장 좋습니다. 8 개의 인코딩 된 데이터.</target>
        </trans-unit>
        <trans-unit id="c46a1417af942e441ec740293a77160106782547" translate="yes" xml:space="preserve">
          <source>A pseudolayer that manipulates other layers. Applying the &lt;code&gt;:raw&lt;/code&gt; layer is equivalent to calling &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode($fh)&lt;/a&gt;&lt;/code&gt;. It makes the stream pass each byte as-is without translation. In particular, both CRLF translation and intuiting &lt;code&gt;:utf8&lt;/code&gt; from the locale are disabled.</source>
          <target state="translated">다른 레이어를 조작하는 의사 레이어입니다. &lt;code&gt;:raw&lt;/code&gt; 레이어를 적용하는 것은 &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode($fh)&lt;/a&gt;&lt;/code&gt; 를 호출하는 것과 같습니다 . 변환없이 스트림이 각 바이트를 그대로 전달합니다. 특히 로케일의 CRLF 변환 및 intuiting &lt;code&gt;:utf8&lt;/code&gt; 이 모두 사용 불가능합니다.</target>
        </trans-unit>
        <trans-unit id="fefe2bbba2d7bf83c98ed3d05237098307bf7f4b" translate="yes" xml:space="preserve">
          <source>A pseudolayer that turns the &lt;code&gt;:utf8&lt;/code&gt; flag</source>
          <target state="translated">&lt;code&gt;:utf8&lt;/code&gt; 플래그를 바꾸는 의사 층</target>
        </trans-unit>
        <trans-unit id="ecc09e716a2c2d18e2be806f7183c30c2f3b51c2" translate="yes" xml:space="preserve">
          <source>A psychoactive drug, popular in the &amp;rsquo;80s, probably developed at UC Berkeley or thereabouts. Similar in many ways to the prescription-only medication called &amp;ldquo;System V&amp;rdquo;, but infinitely more useful. (Or, at least, more fun.) The full chemical name is &amp;ldquo;Berkeley Standard Distribution&amp;rdquo;.</source>
          <target state="translated">80 년대에 유행 한 향정 신약은 UC 버클리 나 그 주변에서 개발되었을 것입니다. &amp;ldquo;System V&amp;rdquo;라고하는 처방전 전용 의약품과 여러 가지면에서 유사하지만 훨씬 더 유용합니다. (또는 적어도 더 재미 있습니다.) 전체 화학명은 &quot;Berkeley Standard Distribution&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="b62f9f104139d9b8c4e453ea5b9cd7a8ac0140f4" translate="yes" xml:space="preserve">
          <source>A public function (i.e. part of the internal API, but not necessarily sanctioned for use in extensions) begins like this:</source>
          <target state="translated">공개 함수 (즉, 내부 API의 일부이지만 확장에 사용하기 위해 반드시 승인 된 것은 아님)는 다음과 같이 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="1fcfaef1b89a51f30ffb896e8c738cde9ef6077c" translate="yes" xml:space="preserve">
          <source>A pull-parser interface to parsing Pod</source>
          <target state="translated">포드를 파싱하기위한 풀 파서 인터페이스</target>
        </trans-unit>
        <trans-unit id="ce01020c3704b898a0c0774b915a9978c7a43b90" translate="yes" xml:space="preserve">
          <source>A question mark was chosen for this and for the minimal-matching construct because 1) question marks are rare in older regular expressions, and 2) whenever you see one, you should stop and &quot;question&quot; exactly what is going on. That's psychology....</source>
          <target state="translated">1) 이전 정규 표현식에서는 물음표가 드물고 2) 물음표가 표시 될 때마다 정확히 멈추고 &quot;질문&quot;해야하기 때문에 물음표와 최소 일치 구문에 대해 물음표가 선택되었습니다. 그것은 심리학입니다 ....</target>
        </trans-unit>
        <trans-unit id="7af52ef72c21fce506c2fc73241d0f35d841b4ef" translate="yes" xml:space="preserve">
          <source>A queue is a special thread-safe object that lets you put data in one end and take it out the other without having to worry about synchronization issues. They're pretty straightforward, and look like this:</source>
          <target state="translated">큐는 동기화 문제에 대해 걱정할 필요없이 한쪽 끝에 데이터를 넣고 다른 쪽을 꺼낼 수있는 특수한 스레드 안전 개체입니다. 그들은 매우 간단하며 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ce5a6f66f06330588b1d9e78cc960a0c4ce6fd02" translate="yes" xml:space="preserve">
          <source>A quick and dirty fix involves a little bit of code, but this may be all you need to figure out the problem.</source>
          <target state="translated">빠르고 더러운 수정에는 약간의 코드가 필요하지만 문제를 해결하는 데 필요한 전부일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6e5b863f1eff6fa26a4e90b6efd2628e9a8b1279" translate="yes" xml:space="preserve">
          <source>A quick bit of zip file terminology -- A zip archive consists of one or more</source>
          <target state="translated">간단한 zip 파일 용어-zip 아카이브는 하나 이상의</target>
        </trans-unit>
        <trans-unit id="a1f4c66121a13dbcd4a35fcb46d7559bf401584e" translate="yes" xml:space="preserve">
          <source>A quick fix to the offending line (insert the missing parentheses) in the actual program and we're finished.</source>
          <target state="translated">실제 프로그램에서 문제를 일으키는 행에 대한 빠른 수정 (없는 괄호 삽입)이 완료되었습니다.</target>
        </trans-unit>
        <trans-unit id="ee22003c9d3f871e01a3bbc57135bc551a023e8c" translate="yes" xml:space="preserve">
          <source>A quick flag check to see whether an &lt;code&gt;sv&lt;/code&gt; should be passed to &lt;code&gt;sv_force_normal&lt;/code&gt; to be &quot;downgraded&quot; before &lt;code&gt;SvIVX&lt;/code&gt; or &lt;code&gt;SvPVX&lt;/code&gt; can be modified directly.</source>
          <target state="translated">&lt;code&gt;SvIVX&lt;/code&gt; 또는 &lt;code&gt;SvPVX&lt;/code&gt; 를 직접 수정 하기 전에 &lt;code&gt;sv&lt;/code&gt; 가 &lt;code&gt;sv_force_normal&lt;/code&gt; 에 &quot;다운 그레이드&quot; 되어야 하는지 여부를 확인하는 빠른 플래그 검사 입니다.</target>
        </trans-unit>
        <trans-unit id="caf25dde2a598596295bb7a94644c4b4622cf06c" translate="yes" xml:space="preserve">
          <source>A quick flag check to see whether an sv should be passed to sv_force_normal to be &quot;downgraded&quot; before SvIVX or SvPVX can be modified directly.</source>
          <target state="translated">SvIVX 또는 SvPVX를 직접 수정하기 전에 sv를 &quot;다운 그레이드&quot;하기 위해 sv를 sv_force_normal로 전달해야하는지 여부를 확인하는 빠른 플래그입니다.</target>
        </trans-unit>
        <trans-unit id="5714e693202d7afa5eda5b56d0aae30074e97131" translate="yes" xml:space="preserve">
          <source>A quick note on terms</source>
          <target state="translated">용어에 대한 간단한 메모</target>
        </trans-unit>
        <trans-unit id="1d94544d51208195a231709cf1963af0c4de7162" translate="yes" xml:space="preserve">
          <source>A race condition exists when the result of several interrelated events depends on the ordering of those events, but that order cannot be guaranteed due to nondeterministic timing effects. If two or more programs, or parts of the same program, try to go through the same series of events, one might interrupt the work of the other. This is a good way to find an &lt;b&gt;exploit&lt;/b&gt;.</source>
          <target state="translated">여러 관련 이벤트의 결과가 해당 이벤트의 순서에 따라 다를 때 경쟁 조건이 존재하지만 비 결정적 타이밍 효과로 인해 해당 순서를 보장 할 수 없습니다. 둘 이상의 프로그램 또는 동일한 프로그램의 일부가 동일한 일련의 이벤트를 진행하려고하면 하나의 작업이 중단 될 수 있습니다. 이것은 &lt;b&gt;익스플로잇&lt;/b&gt; 을 찾는 좋은 방법 입니다.</target>
        </trans-unit>
        <trans-unit id="b4fd04892bbded81531e522d3212286340ec1840" translate="yes" xml:space="preserve">
          <source>A read-write accessor will allow the caller to set the value as well as get it:</source>
          <target state="translated">읽기-쓰기 접근자는 호출자가 값을 설정하고 가져올 수 있도록합니다.</target>
        </trans-unit>
        <trans-unit id="caaace35cefc12e27812e75c68a502f8caf0f7cf" translate="yes" xml:space="preserve">
          <source>A recent net or commercial release of Cygwin is required.</source>
          <target state="translated">Cygwin의 최신 순 또는 상업용 릴리스가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="279e88205b97d17edeab01fe3aebcdc1b843db2f" translate="yes" xml:space="preserve">
          <source>A recent version of perl for the Amiga can be found at the Geek Gadgets section of the Aminet:</source>
          <target state="translated">Amiga의 최신 perl 버전은 Aminet의 Geek Gadgets 섹션에서 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="091b3fb1a508c2d701cd7e6f7c6e6e5c3add3716" translate="yes" xml:space="preserve">
          <source>A recipe book for programming with CPAN.pm</source>
          <target state="translated">CPAN.pm으로 프로그래밍하기위한 레시피 북</target>
        </trans-unit>
        <trans-unit id="2d7c582850510d1397c7e76f17b16cc5d91e6066" translate="yes" xml:space="preserve">
          <source>A recreational vehicle, not to be confused with vehicular recreation. RV also means an internal Reference Value of the type a &lt;b&gt;scalar&lt;/b&gt; can hold. See also &lt;b&gt;IV&lt;/b&gt; and &lt;b&gt;NV&lt;/b&gt; if you&amp;rsquo;re not confused yet.</source>
          <target state="translated">차량 레크리에이션과 혼동하지 않는 레크리에이션 차량. RV는 또한 &lt;b&gt;스칼라&lt;/b&gt; 가 보유 할 수 있는 유형의 내부 참조 값을 의미합니다 . 아직 혼란스럽지 않은 경우 &lt;b&gt;IV&lt;/b&gt; 및 &lt;b&gt;NV를&lt;/b&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ad0a627886d7457b4c1bf3b7879c79721531858f" translate="yes" xml:space="preserve">
          <source>A reference can be blessed into a package with the following function:</source>
          <target state="translated">다음 함수를 사용하여 패키지에 참조를 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b9d8f8326d44e724663f7d05cf4610dd9fa3fff9" translate="yes" xml:space="preserve">
          <source>A reference can be created by using a special syntax, lovingly known as the *foo{THING} syntax. *foo{THING} returns a reference to the THING slot in *foo (which is the symbol table entry which holds everything known as foo).</source>
          <target state="translated">* foo {THING} 구문으로 알려진 특수 구문을 사용하여 참조를 작성할 수 있습니다. * foo {THING}은 * foo에서 THING 슬롯에 대한 참조를 리턴합니다 (이것은 foo로 알려진 모든 것을 보유하는 기호 테이블 항목입니다).</target>
        </trans-unit>
        <trans-unit id="aa895f94ce4272825894257bb4b5f46a12e2a648" translate="yes" xml:space="preserve">
          <source>A reference is a scalar value and can refer to any other Perl data type. So by storing a reference as the value of an array or hash element, you can easily create lists and hashes within lists and hashes. The following example shows a 2 level hash of hash structure using anonymous hash references.</source>
          <target state="translated">참조는 스칼라 값이며 다른 Perl 데이터 유형을 참조 할 수 있습니다. 따라서 참조를 배열 또는 해시 요소의 값으로 저장하면 목록과 해시 내에 목록과 해시를 쉽게 만들 수 있습니다. 다음 예는 익명 해시 참조를 사용하는 2 단계 해시 구조 해시를 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="31756567f0b0edb207ae4b6d556e511492c04f15" translate="yes" xml:space="preserve">
          <source>A reference is a scalar value that</source>
          <target state="translated">참조는 스칼라 값입니다.</target>
        </trans-unit>
        <trans-unit id="9246f92f3034b3a452a0afe45331277281745beb" translate="yes" xml:space="preserve">
          <source>A reference that doesn&amp;rsquo;t get counted normally. When all the normal references to data disappear, the data disappears. These are useful for circular references that would never disappear otherwise.</source>
          <target state="translated">정상적으로 계산되지 않는 참조. 데이터에 대한 모든 일반 참조가 사라지면 데이터가 사라집니다. 이것들은 달리 사라지지 않는 순환 참조에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="5bbf68c2e549802b044298b09b378b5fd28092c9" translate="yes" xml:space="preserve">
          <source>A reference to a filehandle, or the pathname of a file from which the invoking script's pod documentation should be read. It defaults to the file indicated by &lt;code&gt;$0&lt;/code&gt; (&lt;code&gt;$PROGRAM_NAME&lt;/code&gt; for users of</source>
          <target state="translated">파일 핸들에 대한 참조 또는 호출 스크립트의 포드 문서를 읽어야하는 파일의 경로 이름. 기본적으로 &lt;code&gt;$0&lt;/code&gt; ( &lt;code&gt;$PROGRAM_NAME&lt;/code&gt; 사용자)</target>
        </trans-unit>
        <trans-unit id="f5b22d93dc114d0a0d964dd5bfa61e077311cb6a" translate="yes" xml:space="preserve">
          <source>A reference to a filehandle, or the pathname of a file to which the usage message should be written. The default is &lt;code&gt;\*STDERR&lt;/code&gt; unless the exit value is less than 2 (in which case the default is &lt;code&gt;\*STDOUT&lt;/code&gt; ).</source>
          <target state="translated">파일 핸들에 대한 참조 또는 사용법 메시지를 작성해야하는 파일의 경로 이름. 종료 값이 2보다 작지 않은 경우 기본값은 &lt;code&gt;\*STDERR&lt;/code&gt; 입니다 (이 경우 기본값은 &lt;code&gt;\*STDOUT&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="980006b576a2cc0a15260aa4e5fea4bbf14c9495" translate="yes" xml:space="preserve">
          <source>A reference to a filehandle, or the pathname of a file to which the usage message should be written. The default is &lt;code&gt;\*STDERR&lt;/code&gt; unless the exit value is less than 2 (in which case the default is &lt;code&gt;\*STDOUT&lt;/code&gt;).</source>
          <target state="translated">파일 핸들에 대한 참조 또는 사용법 메시지를 작성해야하는 파일의 경로 이름입니다. 종료 값이 2 미만이 아니면 기본값은 &lt;code&gt;\*STDERR&lt;/code&gt; 입니다 (이 경우 기본값은 &lt;code&gt;\*STDOUT&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="1be21fde0d5a369b6626dd71f37562d95b7a892a" translate="yes" xml:space="preserve">
          <source>A reference to a hash</source>
          <target state="translated">해시에 대한 참조</target>
        </trans-unit>
        <trans-unit id="caf281724b21daca5b76b0ce26ffdceb6ed5b592" translate="yes" xml:space="preserve">
          <source>A reference to a hash of rules that control which tests may be executed in parallel. If no rules are declared and &lt;a href=&quot;../cpan/meta/yaml&quot;&gt;CPAN::Meta::YAML&lt;/a&gt; is available, &lt;code&gt;TAP::Harness&lt;/code&gt; attempts to load rules from a YAML file specified by the &lt;code&gt;rulesfile&lt;/code&gt; parameter. If no rules file exists, the default is for all tests to be eligible to be run in parallel.</source>
          <target state="translated">병렬로 실행할 테스트를 제어하는 ​​규칙 해시에 대한 참조입니다. 규칙이 선언되지 않고 &lt;a href=&quot;../cpan/meta/yaml&quot;&gt;CPAN :: Meta :: YAML&lt;/a&gt; 을 사용할 수있는 경우 &lt;code&gt;TAP::Harness&lt;/code&gt; 는 &lt;code&gt;rulesfile&lt;/code&gt; 매개 변수로 지정된 YAML 파일에서 규칙을로드하려고 시도합니다 . 규칙 파일이없는 경우 기본값은 모든 테스트를 병렬로 실행할 수있는 것입니다.</target>
        </trans-unit>
        <trans-unit id="a706802a8a2475d51bc83970dc392f76564c5864" translate="yes" xml:space="preserve">
          <source>A reference to a hash of rules that control which tests may be executed in parallel. If no rules are declared and &lt;a href=&quot;CPAN::Meta::YAML&quot;&gt;CPAN::Meta::YAML&lt;/a&gt; is available, &lt;code&gt;TAP::Harness&lt;/code&gt; attempts to load rules from a YAML file specified by the &lt;code&gt;rulesfile&lt;/code&gt; parameter. If no rules file exists, the default is for all tests to be eligible to be run in parallel.</source>
          <target state="translated">병렬로 실행할 수있는 테스트를 제어하는 ​​규칙의 해시에 대한 참조입니다. 규칙이 선언되지 않고 &lt;a href=&quot;CPAN::Meta::YAML&quot;&gt;CPAN :: Meta :: YAML&lt;/a&gt; 을 사용할 수있는 경우 &lt;code&gt;TAP::Harness&lt;/code&gt; 는 &lt;code&gt;rulesfile&lt;/code&gt; 매개 변수로 지정된 YAML 파일에서 규칙을로드하려고 시도합니다 . 규칙 파일이없는 경우 기본값은 모든 테스트를 병렬로 실행할 수있는 것입니다.</target>
        </trans-unit>
        <trans-unit id="cd42c7f4f6784f49153b357722a869874cd7cab5" translate="yes" xml:space="preserve">
          <source>A reference to a hash of scalar values in scalar context. Each entry of the hash has the fully qualified method name as its key and the method's scalar-context return values as its value.</source>
          <target state="translated">스칼라 컨텍스트에서 스칼라 값의 해시에 대한 참조입니다. 해시의 각 항목은 정규화 된 메소드 이름을 키로 사용하고 메소드의 스칼라 컨텍스트 리턴 값을 값으로 갖습니다.</target>
        </trans-unit>
        <trans-unit id="c3a87c12004d018bcf7a69155be997af1914286c" translate="yes" xml:space="preserve">
          <source>A reference to a hash.</source>
          <target state="translated">해시에 대한 참조</target>
        </trans-unit>
        <trans-unit id="9c7f4017cfb229c284c5327072ab9da27410d7df" translate="yes" xml:space="preserve">
          <source>A reference to a list of netmask strings in the form &lt;code&gt;&quot;134.99.4.0/24&quot;&lt;/code&gt; . These are used by the &lt;code&gt;requires_firewall&lt;/code&gt; function to determine if a given host is inside or outside your firewall.</source>
          <target state="translated">&lt;code&gt;&quot;134.99.4.0/24&quot;&lt;/code&gt; 형식의 넷 마스크 문자열 목록에 대한 참조 입니다. 이들은 호스트가 방화벽 내부 또는 외부에 있는지 여부를 판별하기 위해 &lt;code&gt;requires_firewall&lt;/code&gt; 기능에 의해 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="55220c7cc22e62cddb006a6a8bf77ab5a2807bb5" translate="yes" xml:space="preserve">
          <source>A reference to a list of netmask strings in the form &lt;code&gt;&quot;134.99.4.0/24&quot;&lt;/code&gt;. These are used by the &lt;code&gt;requires_firewall&lt;/code&gt; function to determine if a given host is inside or outside your firewall.</source>
          <target state="translated">&lt;code&gt;&quot;134.99.4.0/24&quot;&lt;/code&gt; 형식의 넷 마스크 문자열 목록에 대한 참조 입니다. 이들은 &lt;code&gt;requires_firewall&lt;/code&gt; 함수에서 지정된 호스트가 방화벽 내부에 있는지 외부에 있는지 확인하는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="30ea49a873c1ff374f329e97efef0ff346dccc25" translate="yes" xml:space="preserve">
          <source>A reference to a list of subroutine references and/or qr// objects and/or literal strings and/or hash references, specifying the extractors to be used to split the string. If this argument is omitted (or &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;) the list:</source>
          <target state="translated">서브 루틴 참조 및 / 또는 qr // 객체 및 / 또는 리터럴 문자열 및 / 또는 해시 참조 목록에 대한 참조로, 문자열을 분할하는 데 사용할 추출기를 지정합니다. 이 인수가 생략되면 (또는 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; ) 목록이 나타납니다.</target>
        </trans-unit>
        <trans-unit id="dd1cf33c811e37d20a0f1536729842fe8b28cf07" translate="yes" xml:space="preserve">
          <source>A reference to a list of subroutine references and/or qr// objects and/or literal strings and/or hash references, specifying the extractors to be used to split the string. If this argument is omitted (or &lt;code&gt;undef&lt;/code&gt;) the list:</source>
          <target state="translated">문자열을 분할하는 데 사용할 추출기를 지정하는 서브 루틴 참조 및 / 또는 qr // 객체 및 / 또는 리터럴 문자열 및 / 또는 해시 참조 목록에 대한 참조입니다. 이 인수가 생략 된 경우 (또는 &lt;code&gt;undef&lt;/code&gt; ) 목록은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2512ecb6dd2165eaa0de868a807f9b3c24936be1" translate="yes" xml:space="preserve">
          <source>A reference to a list of tests which are allowed to fail. See &lt;a href=&quot;#TODO-TESTS&quot;&gt;&quot;TODO TESTS&quot;&lt;/a&gt;.</source>
          <target state="translated">실패 할 수있는 테스트 목록에 대한 참조입니다. &lt;a href=&quot;#TODO-TESTS&quot;&gt;&quot;TODO 테스트&quot;를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c0f47fcb868f1bdb2ed44c13b2967f53238fb92e" translate="yes" xml:space="preserve">
          <source>A reference to a list of tests which are allowed to fail. See &lt;a href=&quot;#TODO-TESTS&quot;&gt;TODO TESTS&lt;/a&gt;.</source>
          <target state="translated">실패 할 수있는 테스트 목록에 대한 참조입니다. &lt;a href=&quot;#TODO-TESTS&quot;&gt;TODO TESTS를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a16beaf14f9ebf81709ac7687142e7324bffbcbc" translate="yes" xml:space="preserve">
          <source>A reference to a scalar, containing any initial source code to prepend to the file or generator output.</source>
          <target state="translated">파일 또는 생성기 출력 앞에 추가 할 초기 소스 코드가 포함 된 스칼라에 대한 참조입니다.</target>
        </trans-unit>
        <trans-unit id="ca57032a4acbb0f04dd265f2403ba03843451cb5" translate="yes" xml:space="preserve">
          <source>A reference to a simple scalar</source>
          <target state="translated">간단한 스칼라에 대한 참조</target>
        </trans-unit>
        <trans-unit id="2f7717bc46f8882825267f8fb5ae31ad534d8604" translate="yes" xml:space="preserve">
          <source>A reference to a subroutine</source>
          <target state="translated">서브 루틴에 대한 참조</target>
        </trans-unit>
        <trans-unit id="13ea76e1a2a772c23eb3e3af45f4e6c39d604a09" translate="yes" xml:space="preserve">
          <source>A reference to a subroutine. If there is no filehandle (previous item), then this subroutine is expected to generate one line of source code per call, writing the line into &lt;a href=&quot;perlvar#%24_&quot;&gt;&lt;code&gt;$_&lt;/code&gt;&lt;/a&gt; and returning 1, then finally at end of file returning 0. If there is a filehandle, then the subroutine will be called to act as a simple source filter, with the line as read in &lt;a href=&quot;perlvar#%24_&quot;&gt;&lt;code&gt;$_&lt;/code&gt;&lt;/a&gt;. Again, return 1 for each valid line, and 0 after all lines have been returned. For historical reasons the subroutine will receive a meaningless argument (in fact always the numeric value zero) as &lt;code&gt;$_[0]&lt;/code&gt;.</source>
          <target state="translated">서브 루틴에 대한 참조. 파일 핸들 (이전 항목)이 없으면이 서브 루틴은 호출 당 한 줄의 소스 코드를 생성하여 &lt;a href=&quot;perlvar#%24_&quot;&gt; &lt;code&gt;$_&lt;/code&gt; &lt;/a&gt; 줄을 쓰고 1을 반환 한 다음 마지막으로 파일 끝에 0을 반환합니다. 파일 핸들이있는 경우 그러면 서브 루틴이 호출되어 &lt;a href=&quot;perlvar#%24_&quot;&gt; &lt;code&gt;$_&lt;/code&gt; &lt;/a&gt; 에서 읽은 행과 함께 간단한 소스 필터로 작동 합니다. 다시 말하지만, 유효한 각 줄에 대해 1을 반환하고 모든 줄이 반환 된 후에는 0을 반환합니다. 역사적 이유로 서브 루틴은 &lt;code&gt;$_[0]&lt;/code&gt; 으로 무의미한 인수 (사실상 항상 숫자 값 0)를 받습니다.</target>
        </trans-unit>
        <trans-unit id="b60540604d1e514c1059c3b516595d77c9c95f5f" translate="yes" xml:space="preserve">
          <source>A reference to a subroutine. If there is no filehandle (previous item), then this subroutine is expected to generate one line of source code per call, writing the line into &lt;code&gt;$_&lt;/code&gt; and returning 1, then finally at end of file returning 0. If there is a filehandle, then the subroutine will be called to act as a simple source filter, with the line as read in &lt;code&gt;$_&lt;/code&gt; . Again, return 1 for each valid line, and 0 after all lines have been returned.</source>
          <target state="translated">서브 루틴에 대한 참조 파일 핸들이없는 경우 (이전 항목)이 서브 루틴은 호출 당 한 줄의 소스 코드를 생성하여 &lt;code&gt;$_&lt;/code&gt; 행을 작성하고 1을 반환 한 다음 마지막으로 파일 끝에서 0을 반환합니다. 그러면 서브 루틴은 &lt;code&gt;$_&lt;/code&gt; 에서 행을 읽은 간단한 소스 필터로 작동하도록 호출됩니다 . 다시 한 번, 유효한 각 줄마다 1을 반환하고 모든 줄이 반환되면 0을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="69d2c7af1b1feb58183b6cd3ab9665d62ba3318e" translate="yes" xml:space="preserve">
          <source>A reference to an &lt;code&gt;@INC&lt;/code&gt; style array of arguments to be passed to each test program.</source>
          <target state="translated">각 테스트 프로그램에 전달 될 인수 의 &lt;code&gt;@INC&lt;/code&gt; 스타일 배열에 대한 참조 입니다.</target>
        </trans-unit>
        <trans-unit id="c036eaf04cdd3c79b7e1454ebb2a945c2a1cd7fe" translate="yes" xml:space="preserve">
          <source>A reference to an SV which holds a C pointer</source>
          <target state="translated">C 포인터를 보유한 SV에 대한 참조</target>
        </trans-unit>
        <trans-unit id="23549f2151bb51628d2f58bbcf1156a64c3296ce" translate="yes" xml:space="preserve">
          <source>A reference to an anonymous array can be created using square brackets:</source>
          <target state="translated">익명 배열에 대한 참조는 대괄호를 사용하여 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="227fa37704dcf65c895f6b48accf114132dd71b4" translate="yes" xml:space="preserve">
          <source>A reference to an anonymous hash can be created using curly brackets:</source>
          <target state="translated">중괄호를 사용하여 익명 해시에 대한 참조를 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="75f71bb1e5a64ddcdb9e050cbea388199a1108b3" translate="yes" xml:space="preserve">
          <source>A reference to an anonymous subroutine can be created by using &lt;code&gt;&lt;a href=&quot;functions/sub&quot;&gt;sub&lt;/a&gt;&lt;/code&gt; without a subname:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/sub&quot;&gt;sub&lt;/a&gt;&lt;/code&gt; 네임없이 sub 를 사용하여 익명 서브 루틴에 대한 참조를 작성할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c2b28a0f04f7d25df0ba15127b6c78099a8d8001" translate="yes" xml:space="preserve">
          <source>A reference to an anonymous subroutine can be created by using &lt;code&gt;sub&lt;/code&gt; without a subname:</source>
          <target state="translated">익명 서브 루틴에 대한 참조 는 하위 이름없이 &lt;code&gt;sub&lt;/code&gt; 를 사용하여 만들 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8b1d9fe90cb9aed401ad78a9cb46511d34021ee8" translate="yes" xml:space="preserve">
          <source>A reference to an array</source>
          <target state="translated">배열에 대한 참조</target>
        </trans-unit>
        <trans-unit id="e31779df8d209b3542cc04e2be4c9b32f5d08f2c" translate="yes" xml:space="preserve">
          <source>A reference to an array of sections specifications (as described in &lt;a href=&quot;#SECTION-SPECIFICATIONS&quot;&gt;SECTION SPECIFICATIONS&lt;/a&gt;) which indicate the desired set of POD sections and subsections to be selected from input. If no section specifications are given, then all sections of the PODs are used.</source>
          <target state="translated">(AS 섹션에 기재된 사양의 배열에 대한 참조 &lt;a href=&quot;#SECTION-SPECIFICATIONS&quot;&gt;SECTION 사양&lt;/a&gt; POD 부 및 하위의 바람직한 세트를 나타냄)으로부터 선택 입력한다. 섹션 지정이 없으면 POD의 모든 섹션이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="c89226f4c3258d3bce7e696eba292fd5daa132bc" translate="yes" xml:space="preserve">
          <source>A reference to the object for a virtual method or the name of the class for a static method</source>
          <target state="translated">가상 메소드의 오브젝트에 대한 참조 또는 정적 메소드의 클래스 이름</target>
        </trans-unit>
        <trans-unit id="21f30d908543711c9f728d7de0ea1261250a9055" translate="yes" xml:space="preserve">
          <source>A regression in AIX 7 causes a failure in make test in Time::Piece during daylight savings time. APAR IV16514 provides the fix for this. A quick test to see if it's required, assuming it is currently daylight savings in Eastern Time, would be to run &lt;code&gt; TZ=EST5 date +%Z &lt;/code&gt; . This will come back with &lt;code&gt;EST&lt;/code&gt; normally, but nothing if you have the problem.</source>
          <target state="translated">AIX 7의 회귀는 일광 절약 시간 동안 Time :: Piece에서 make 테스트에 실패합니다. APAR IV16514는 이에 대한 수정 사항을 제공합니다. 현재 동부 표준시로 일광 절약 시간을 가정하고 필요한지 확인하는 빠른 테스트는 &lt;code&gt; TZ=EST5 date +%Z &lt;/code&gt; 를 실행하는 것 입니다. 이것은 &lt;code&gt;EST&lt;/code&gt; 와 함께 정상적으로 돌아 오지만 문제가 있으면 아무것도 없습니다.</target>
        </trans-unit>
        <trans-unit id="f9c19d164e4eea1cf98cc917d39776c748efd08d" translate="yes" xml:space="preserve">
          <source>A regression in AIX 7 causes a failure in make test in Time::Piece during daylight savings time. APAR IV16514 provides the fix for this. A quick test to see if it's required, assuming it is currently daylight savings in Eastern Time, would be to run &lt;code&gt; TZ=EST5 date +%Z &lt;/code&gt;. This will come back with &lt;code&gt;EST&lt;/code&gt; normally, but nothing if you have the problem.</source>
          <target state="translated">AIX 7의 회귀로 인해 일광 절약 시간 동안 Time :: Piece에서 make 테스트가 실패합니다. APAR IV16514는 이에 대한 수정 사항을 제공합니다. 현재 동부 표준시의 일광 절약 시간이라고 가정하고 필요한지 확인하는 빠른 테스트는 &lt;code&gt; TZ=EST5 date +%Z &lt;/code&gt; 를 실행하는 것 입니다. 이것은 &lt;code&gt;EST&lt;/code&gt; 와 함께 정상적으로 돌아 오지만 문제가있는 경우에는 아무 일도 일어나지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0fc4dbf2e586369f7ce889ec848c85dffcc1c599" translate="yes" xml:space="preserve">
          <source>A regular expression engine is a program that takes a set of constraints specified in a mini-language, and then applies those constraints to a target string, and determines whether or not the string satisfies the constraints. See &lt;a href=&quot;perlre&quot;&gt;perlre&lt;/a&gt; for a full definition of the language.</source>
          <target state="translated">정규 표현식 엔진은 미니 언어로 지정된 일련의 제약 조건을 취한 다음 해당 제약 조건을 대상 문자열에 적용하고 문자열이 제약 조건을 만족하는지 여부를 결정하는 프로그램입니다. 언어의 전체 정의는 &lt;a href=&quot;perlre&quot;&gt;perlre&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="898d96d1a86448c10c01fff6d7c680ca19e7f093" translate="yes" xml:space="preserve">
          <source>A regular expression match in the form of &lt;code&gt;/REGEX/&lt;/code&gt; , &lt;code&gt;$foo =~ /REGEX/&lt;/code&gt; , or &lt;code&gt;$foo =~ EXPR&lt;/code&gt; . Also, a negated regular expression match in the form &lt;code&gt;!/REGEX/&lt;/code&gt; , &lt;code&gt;$foo !~ /REGEX/&lt;/code&gt; , or &lt;code&gt;$foo !~ EXPR&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;/REGEX/&lt;/code&gt; , &lt;code&gt;$foo =~ /REGEX/&lt;/code&gt; 또는 &lt;code&gt;$foo =~ EXPR&lt;/code&gt; 형식의 정규식 일치 . 또한 부정 된 정규식은 &lt;code&gt;!/REGEX/&lt;/code&gt; , &lt;code&gt;$foo !~ /REGEX/&lt;/code&gt; 또는 &lt;code&gt;$foo !~ EXPR&lt;/code&gt; 형식으로 일치합니다 .</target>
        </trans-unit>
        <trans-unit id="01f7272df9cfce47663749712543393fb8ccb06b" translate="yes" xml:space="preserve">
          <source>A regular expression match in the form of &lt;code&gt;/REGEX/&lt;/code&gt;, &lt;code&gt;$foo =~ /REGEX/&lt;/code&gt;, or &lt;code&gt;$foo =~ EXPR&lt;/code&gt;. Also, a negated regular expression match in the form &lt;code&gt;!/REGEX/&lt;/code&gt;, &lt;code&gt;$foo !~ /REGEX/&lt;/code&gt;, or &lt;code&gt;$foo !~ EXPR&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;/REGEX/&lt;/code&gt; , &lt;code&gt;$foo =~ /REGEX/&lt;/code&gt; 또는 &lt;code&gt;$foo =~ EXPR&lt;/code&gt; 형식의 정규식 일치 . 또한 부정 정규식은 &lt;code&gt;!/REGEX/&lt;/code&gt; , &lt;code&gt;$foo !~ /REGEX/&lt;/code&gt; 또는 &lt;code&gt;$foo !~ EXPR&lt;/code&gt; 형식으로 일치합니다 .</target>
        </trans-unit>
        <trans-unit id="6b61a0c27a77da1e69f8478b8fd9175ff4c338f9" translate="yes" xml:space="preserve">
          <source>A regular expression that otherwise would compile using &lt;code&gt;/d&lt;/code&gt; rules, and which uses this construct will instead use &lt;code&gt;/u&lt;/code&gt; . Thus this construct tells Perl that you don't want &lt;code&gt;/d&lt;/code&gt; rules for the entire regular expression containing it.</source>
          <target state="translated">그렇지 않으면 &lt;code&gt;/d&lt;/code&gt; 규칙을 사용하여 컴파일 하고이 구문을 사용 하는 정규식 은 대신 &lt;code&gt;/u&lt;/code&gt; 를 사용 합니다. 따라서이 구문은 Perl에 포함 된 전체 정규 표현식에 대해 &lt;code&gt;/d&lt;/code&gt; 규칙을 원하지 않는다고 알려줍니다 .</target>
        </trans-unit>
        <trans-unit id="3b6937e0ce314d5ad6696b2c87b4dd9e05cd8786" translate="yes" xml:space="preserve">
          <source>A regular expression that otherwise would compile using &lt;code&gt;/d&lt;/code&gt; rules, and which uses this construct will instead use &lt;code&gt;/u&lt;/code&gt;. Thus this construct tells Perl that you don't want &lt;code&gt;/d&lt;/code&gt; rules for the entire regular expression containing it.</source>
          <target state="translated">그렇지 않으면 &lt;code&gt;/d&lt;/code&gt; 규칙을 사용하여 컴파일되고이 구문을 사용하는 정규식 은 대신 &lt;code&gt;/u&lt;/code&gt; 를 사용 합니다. 따라서이 구조는 Perl에게 이를 포함하는 전체 정규식에 대해 &lt;code&gt;/d&lt;/code&gt; 규칙을 원하지 않는다는 것을 알려줍니다 .</target>
        </trans-unit>
        <trans-unit id="8052f2558ed14ca1695f0756ea843781532061f7" translate="yes" xml:space="preserve">
          <source>A related issue is thread-safety. When a new thread is created, the Perl interpreter is cloned, which implies that all reference addresses in use will be replaced with new ones. Thus, if a class tries to access a field of a cloned object its (cloned) data will still be stored under the now invalid reference address of the original in the parent thread. A general &lt;code&gt;CLONE&lt;/code&gt; method must be provided to re-establish the association.</source>
          <target state="translated">관련 문제는 스레드 안전성입니다. 새 스레드가 작성되면 Perl 인터프리터가 복제되어 사용중인 모든 참조 주소가 새 주소로 대체됩니다. 따라서 클래스가 복제 된 객체의 필드에 액세스하려고 시도해도 복제 된 데이터는 여전히 상위 스레드에서 원본의 유효하지 않은 참조 주소 아래에 저장됩니다. 연결을 다시 설정하려면 일반 &lt;code&gt;CLONE&lt;/code&gt; 방법을 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="c5a4d830992a6346407400c2bf4e88b4a6e3e575" translate="yes" xml:space="preserve">
          <source>A related issue is use with perl's malloc. Perl's malloc uses &lt;code&gt;sbrk()&lt;/code&gt; to get memory, and &lt;code&gt;sbrk()&lt;/code&gt; is limited to the first allocation so in this case something like:</source>
          <target state="translated">관련된 문제는 perl의 malloc과 함께 사용하는 것입니다. Perl의 malloc은 &lt;code&gt;sbrk()&lt;/code&gt; 를 사용하여 메모리를 가져오고 &lt;code&gt;sbrk()&lt;/code&gt; 는 첫 번째 할당으로 제한 되므로이 경우 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="773c247356b687b3912aff9a0cf7c1a25f2fade5" translate="yes" xml:space="preserve">
          <source>A related strategy that's less open to forgery is to give them a PIN (personal ID number). Record the address and PIN (best that it be a random one) for later processing. In the mail you send, include a link to your site with the PIN included. If the mail bounces, you know it's not valid. If they don't click on the link, either they forged the address or (assuming they got the message) following through wasn't important so you don't need to worry about it.</source>
          <target state="translated">위조에 덜 개방적인 관련 전략은 PIN (개인 ID 번호)을 제공하는 것입니다. 나중에 처리 할 수 ​​있도록 주소와 PIN (임의의 것이 가장 좋음)을 기록하십시오. 보내는 메일에 PIN이 포함 된 사이트 링크를 포함 시키십시오. 메일이 반송되면 유효하지 않은 것입니다. 링크를 클릭하지 않으면 주소를 위조하거나 (메시지가 있다고 가정) 중요하지 않으므로 걱정할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="1b0e6d749250f42dda0dbf4bdf376cdb3adb5626" translate="yes" xml:space="preserve">
          <source>A relationship between two &lt;b&gt;objects&lt;/b&gt; in which one object is considered to be a more specific version of the other, generic object: &amp;ldquo;A camel is a mammal.&amp;rdquo; Since the generic object really only exists in a Platonic sense, we usually add a little abstraction to the notion of objects and think of the relationship as being between a generic &lt;b&gt;base class&lt;/b&gt; and a specific &lt;b&gt;derived class&lt;/b&gt;. Oddly enough, Platonic classes don&amp;rsquo;t always have Platonic relationships&amp;mdash;see &lt;b&gt;inheritance&lt;/b&gt;.</source>
          <target state="translated">한 대상이 다른 일반 대상의보다 구체적인 버전으로 간주되는 두 &lt;b&gt;대상&lt;/b&gt; 간의 관계 :&amp;ldquo;낙타는 포유류&amp;rdquo;입니다. 일반 객체는 실제로 Platonic 의미로만 존재하기 때문에 일반적으로 객체 개념에 약간의 추상화를 추가하고 일반 &lt;b&gt;기본 클래스&lt;/b&gt; 와 특정 &lt;b&gt;파생 클래스&lt;/b&gt; 사이의 관계로 생각합니다 . 이상하게도 플라톤의 클래스가 플라톤의 관계를 항상 가지고있는 것은 아닙니다 . &lt;b&gt;상속을보십시오&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="9cc57b74bcbf78eacbd6b02d09950f83d1e82c98" translate="yes" xml:space="preserve">
          <source>A relatively new conference franchise with a large Perl portion is the Open Source Developers Conference or OSDC. First held in Australia it has recently also spread to Israel and France. More information can be found at: &lt;a href=&quot;http://www.osdc.com.au/&quot;&gt;http://www.osdc.com.au/&lt;/a&gt; for Australia, &lt;a href=&quot;http://www.osdc.org.il&quot;&gt;http://www.osdc.org.il&lt;/a&gt; for Israel, and &lt;a href=&quot;http://www.osdc.fr/&quot;&gt;http://www.osdc.fr/&lt;/a&gt; for France.</source>
          <target state="translated">Perl 부분이 많은 비교적 새로운 컨퍼런스 프랜차이즈는 오픈 소스 개발자 컨퍼런스 또는 OSDC입니다. 호주에서 처음 개최 된이 도시는 최근 이스라엘과 프랑스에도 전파되었습니다. 자세한 내용은 &lt;a href=&quot;http://www.osdc.com.au/&quot;&gt;http://www.osdc.com.au/ (&lt;/a&gt; 호주), &lt;a href=&quot;http://www.osdc.org.il&quot;&gt;http://www.osdc.org.il (&lt;/a&gt; 이스라엘), &lt;a href=&quot;http://www.osdc.fr/&quot;&gt;http://www.osdc.fr/ (&lt;/a&gt; 프랑스)에서 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="125bb83bd0e2557d465d8cae2a201d255865cfc8" translate="yes" xml:space="preserve">
          <source>A relatively recent addition to socket functions, may not be implemented even in Unix platforms.</source>
          <target state="translated">소켓 기능에 비교적 최근에 추가 된 것은 Unix 플랫폼에서도 구현되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0fb2c7925dc01622384910beb32c259581a32e6c" translate="yes" xml:space="preserve">
          <source>A remark that doesn&amp;rsquo;t affect the meaning of the program. In Perl, a comment is introduced by a &lt;code&gt;#&lt;/code&gt; character and continues to the end of the line.</source>
          <target state="translated">프로그램의 의미에 영향을 미치지 않는 말. Perl에서 주석은 &lt;code&gt;#&lt;/code&gt; 문자로 시작하고 줄 끝까지 계속됩니다.</target>
        </trans-unit>
        <trans-unit id="05ceaec7b64c7ce9cdeec60b39e51b96ddb09fbd" translate="yes" xml:space="preserve">
          <source>A repeat count after &lt;code&gt;u&lt;/code&gt; sets the number of bytes to put into an uuencoded line, which is the maximum of 45 by default, but could be set to some (smaller) integer multiple of three. &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; simply ignores the repeat count.</source>
          <target state="translated">&lt;code&gt;u&lt;/code&gt; 이후의 반복 횟수 는 기본적으로 최대 45 자이지만 uuencoded 행에 넣을 바이트 수를 설정하지만 3의 정수 (작은) 정수로 설정할 수 있습니다. &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; 은 단순히 반복 횟수를 무시합니다.</target>
        </trans-unit>
        <trans-unit id="39e5a93524da5ebc880d6f2d48ae7f4158fdf997" translate="yes" xml:space="preserve">
          <source>A repeat count after &lt;code&gt;u&lt;/code&gt; sets the number of bytes to put into an uuencoded line, which is the maximum of 45 by default, but could be set to some (smaller) integer multiple of three. &lt;code&gt;unpack&lt;/code&gt; simply ignores the repeat count.</source>
          <target state="translated">&lt;code&gt;u&lt;/code&gt; 이후의 반복 횟수 는 uuencoded 행에 넣을 바이트 수를 설정합니다. 이는 기본적으로 최대 45 개이지만 일부 (더 작은) 정수 배수로 설정할 수 있습니다. &lt;code&gt;unpack&lt;/code&gt; 은 단순히 반복 횟수를 무시합니다.</target>
        </trans-unit>
        <trans-unit id="3a53eb20270176512fa5bd8bf4b4f1be0776d385" translate="yes" xml:space="preserve">
          <source>A return code of 1 means that the requested key was not in the database.</source>
          <target state="translated">리턴 코드 1은 요청 된 키가 데이터베이스에 없음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="ed4d8a6dc7b98d70bce7c0cb5069c17fe03ce939" translate="yes" xml:space="preserve">
          <source>A rudimentary command-line completion is also available, including lexical variables in the current scope if the &lt;code&gt;PadWalker&lt;/code&gt; module is installed.</source>
          <target state="translated">&lt;code&gt;PadWalker&lt;/code&gt; 모듈이 설치된 경우 현재 범위의 어휘 변수를 포함하여 기본적인 명령 줄 완성도 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="195465d41845715cc8feeb944d84d82eca7db90c" translate="yes" xml:space="preserve">
          <source>A safe filename for the package.</source>
          <target state="translated">패키지의 안전한 파일 이름입니다.</target>
        </trans-unit>
        <trans-unit id="e965283a692e93e5f3c352fa50ba572d5ad94533" translate="yes" xml:space="preserve">
          <source>A sample Configure invocation looks something like this:</source>
          <target state="translated">샘플 구성 호출은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c38c9f9afa364c973ff5615c1cc8f4fc08593cdb" translate="yes" xml:space="preserve">
          <source>A sanitized VERSION with . replaced by _. For places where . has special meaning (some filesystems, RCS labels, etc...)</source>
          <target state="translated">으로 위생 처리 된 버전입니다. 로 교체되다 _. 장소가. 특별한 의미가 있습니다 (일부 파일 시스템, RCS 레이블 등).</target>
        </trans-unit>
        <trans-unit id="854d2d0c342e6a9cd9c52af8350f79c5b69ee115" translate="yes" xml:space="preserve">
          <source>A sanity check is done to ensure that the versions of the</source>
          <target state="translated">위생 점검은 버전의</target>
        </trans-unit>
        <trans-unit id="52b0650d241bfe8b8773b0c925166a2b232578a5" translate="yes" xml:space="preserve">
          <source>A sanity check that what Perl thinks the architecture is and what Config thinks the architecture is are the same. If they're not it will return false and show a diagnostic message.</source>
          <target state="translated">Perl이 아키텍처를 생각하는 것과 Config가 아키텍처를 동일하게 생각하는 것이 동일한지를 확인하십시오. 그렇지 않으면 false를 반환하고 진단 메시지를 표시합니다.</target>
        </trans-unit>
        <trans-unit id="a5df5a5c29d978bd67d46cf69079761e359c23a8" translate="yes" xml:space="preserve">
          <source>A scalar reference</source>
          <target state="translated">스칼라 참조</target>
        </trans-unit>
        <trans-unit id="13eb257f5c15cd87da91e7109e5621a0b92dd55a" translate="yes" xml:space="preserve">
          <source>A scalar represents a single value:</source>
          <target state="translated">스칼라는 단일 값을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="63bf2744d770c46d6894e17a03796eb6868d8317" translate="yes" xml:space="preserve">
          <source>A scalar that is going to be passed to some extension</source>
          <target state="translated">어떤 확장으로 전달 될 스칼라</target>
        </trans-unit>
        <trans-unit id="b892a705ca325c138b52905f099e8858ffbdfac0" translate="yes" xml:space="preserve">
          <source>A scalar value is interpreted as FALSE in the Boolean sense if it is undefined, the null string or the number 0 (or its string equivalent, &quot;0&quot;), and TRUE if it is anything else. The Boolean context is just a special kind of scalar context where no conversion to a string or a number is ever performed.</source>
          <target state="translated">스칼라 값은 정의되지 않은 경우 부울 의미에서 FALSE, 널 (null) 문자열 또는 숫자 0 (또는 해당 문자열 &quot;0&quot;), 그렇지 않으면 TRUE로 해석됩니다. 부울 컨텍스트는 문자열이나 숫자로의 변환이 수행되지 않는 특별한 종류의 스칼라 컨텍스트입니다.</target>
        </trans-unit>
        <trans-unit id="751493f8cb7ec6843259111a93c03239b2cd2168" translate="yes" xml:space="preserve">
          <source>A scalar value is interpreted as FALSE in the Boolean sense if it is undefined, the null string or the number 0 (or its string equivalent, &quot;0&quot;), and TRUE if it is anything else. The Boolean context is just a special kind of scalar context where no conversion to a string or a number is ever performed. Negation of a true value by &lt;code&gt;!&lt;/code&gt; or &lt;code&gt;not&lt;/code&gt; returns a special false value. When evaluated as a string it is treated as &lt;code&gt;&quot;&quot;&lt;/code&gt;, but as a number, it is treated as 0. Most Perl operators that return true or false behave this way.</source>
          <target state="translated">스칼라 값은 정의되지 않은 경우 부울 의미에서 FALSE, 널 문자열 또는 숫자 0 (또는 해당 문자열, &quot;0&quot;)으로 해석되며, 다른 값이면 TRUE로 해석됩니다. 부울 컨텍스트는 문자열이나 숫자로의 변환이 수행되지 않는 특별한 종류의 스칼라 컨텍스트입니다. &lt;code&gt;!&lt;/code&gt; 에 의한 참값 부정 or &lt;code&gt;not&lt;/code&gt; 은 특별한 거짓 값을 반환합니다. 문자열로 평가되면 &lt;code&gt;&quot;&quot;&lt;/code&gt; 로 처리 되지만 숫자로 처리되면 0으로 처리됩니다. true 또는 false를 반환하는 대부분의 Perl 연산자는 이러한 방식으로 동작합니다.</target>
        </trans-unit>
        <trans-unit id="ecf273fc6dfd9742bd76d45138d207f0b0c7c11c" translate="yes" xml:space="preserve">
          <source>A scalar we got back from an extension</source>
          <target state="translated">확장에서 얻은 스칼라</target>
        </trans-unit>
        <trans-unit id="7153eab5e3c20636ca530d5dc26c52e39ac43559" translate="yes" xml:space="preserve">
          <source>A scratchpad keeps SVs which are lexicals for the current unit and are targets for opcodes. A previous version of this document stated that one can deduce that an SV lives on a scratchpad by looking on its flags: lexicals have &lt;code&gt;SVs_PADMY&lt;/code&gt; set, and</source>
          <target state="translated">스크래치 패드는 현재 장치에 대한 어휘이고 opcode의 대상인 SV를 유지합니다. 이 문서의 이전 버전에서는 SV가 플래그를보고 스크래치 패드에있는 것으로 추론 할 수 있다고 언급했습니다. lexicals에는 &lt;code&gt;SVs_PADMY&lt;/code&gt; 가 설정되어 있으며</target>
        </trans-unit>
        <trans-unit id="9b4b51a187f878ac1e93c009ee393256c5f3fed7" translate="yes" xml:space="preserve">
          <source>A script called &quot;runperl.bat&quot; is available that can be copied to any filename (along with the .bat suffix). For example, if you call it &quot;foo.bat&quot;, it will run the file &quot;foo&quot; when it is executed. Since you can run batch files on Windows platforms simply by typing the name (without the extension), this effectively runs the file &quot;foo&quot;, when you type either &quot;foo&quot; or &quot;foo.bat&quot;. With this method, &quot;foo.bat&quot; can even be in a different location than the file &quot;foo&quot;, as long as &quot;foo&quot; is available somewhere on the PATH. If your scripts are on a filesystem that allows symbolic links, you can even avoid copying &quot;runperl.bat&quot;.</source>
          <target state="translated">&quot;runperl.bat&quot;라는 스크립트를 사용하여 모든 파일 이름으로 복사 할 수 있습니다 (.bat 접미사와 함께). 예를 들어, &quot;foo.bat&quot;라고하면 실행시 &quot;foo&quot;파일이 실행됩니다. 확장명없이 이름을 입력하기 만하면 Windows 플랫폼에서 배치 파일을 실행할 수 있으므로 &quot;foo&quot;또는 &quot;foo.bat&quot;를 입력하면 &quot;foo&quot;파일이 효과적으로 실행됩니다. 이 방법을 사용하면 &quot;foo&quot;가 PATH 어딘가에있는 한 &quot;foo.bat&quot;는 &quot;foo&quot;파일과 다른 위치에있을 수도 있습니다. 스크립트가 기호 링크를 허용하는 파일 시스템에있는 경우 &quot;runperl.bat&quot;를 복사하지 않아도됩니다.</target>
        </trans-unit>
        <trans-unit id="8a0dd42d0c5f72d1648c67ceada410b1cd803819" translate="yes" xml:space="preserve">
          <source>A script run is basically a sequence of characters, all from the same Unicode script (see &lt;a href=&quot;perlunicode#Scripts&quot;&gt;&quot;Scripts&quot; in perlunicode&lt;/a&gt;), such as Latin or Greek. In most places a single word would never be written in multiple scripts, unless it is a spoofing attack. An infamous example, is</source>
          <target state="translated">스크립트 실행은 기본적 으로 라틴어 또는 그리스어와 같은 동일한 유니 코드 스크립트 ( &lt;a href=&quot;perlunicode#Scripts&quot;&gt;perlunicode의 &quot;스크립트&quot;&lt;/a&gt; 참조 ) 에서 가져온 일련의 문자 입니다. 대부분의 경우 스푸핑 공격이 아닌 한 한 단어가 여러 스크립트로 작성되지 않습니다. 악명 높은 예는</target>
        </trans-unit>
        <trans-unit id="6e410531e148f9094643156d14e90843980c3dfe" translate="yes" xml:space="preserve">
          <source>A script that emulates the standard unix archive (aka library) utility. Under Watcom 10.6, ar is linked to wlib and provides the expected interface. With Watcom 9.5, a cover function is required. This one is fairly crude but has proved adequate for compiling perl.</source>
          <target state="translated">표준 유닉스 아카이브 (일명 라이브러리) 유틸리티를 에뮬레이트하는 스크립트. Watcom 10.6에서 ar은 wlib에 연결되어 있고 예상되는 인터페이스를 제공합니다. Watcom 9.5에서는 커버 기능이 필요합니다. 이것은 상당히 조잡하지만 펄을 컴파일하기에 충분한 것으로 판명되었습니다.</target>
        </trans-unit>
        <trans-unit id="e8eda0c28ba2fe483ef84daa3f54b909c119dec0" translate="yes" xml:space="preserve">
          <source>A script that provides C preprocessing functionality. Configure can generate a similar cover, but it doesn't handle all the command-line options that perl throws at it. This might be reasonably placed in /usr/local/bin.</source>
          <target state="translated">C 전처리 기능을 제공하는 스크립트. Configure는 비슷한 커버를 생성 할 수 있지만 perl이 처리하는 모든 명령 행 옵션을 처리하지는 않습니다. 이것은 / usr / local / bin에 합리적으로 배치 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f63efe767441f9b6cae7b2dee9e50e81364ad873" translate="yes" xml:space="preserve">
          <source>A searchable archive of the list is available at &lt;a href=&quot;http://markmail.org/search/?q=perl5-porters&quot;&gt;http://markmail.org/search/?q=perl5-porters&lt;/a&gt;. There is also an archive at &lt;a href=&quot;http://archive.develooper.com/perl5-porters@perl.org/&quot;&gt;http://archive.develooper.com/perl5-porters@perl.org/&lt;/a&gt;.</source>
          <target state="translated">목록의 검색 가능한 아카이브는 &lt;a href=&quot;http://markmail.org/search/?q=perl5-porters&quot;&gt;http://markmail.org/search/?q=perl5-porters&lt;/a&gt; 에서 사용할 수 있습니다 . &lt;a href=&quot;http://archive.develooper.com/perl5-porters@perl.org/&quot;&gt;http://archive.develooper.com/perl5-porters@perl.org/&lt;/a&gt; 에도 아카이브가 있습니다 .</target>
        </trans-unit>
        <trans-unit id="752d32391bfcd52e9f67370c3e3b59a46e33094d" translate="yes" xml:space="preserve">
          <source>A searchable archive of the list is available at &lt;a href=&quot;https://markmail.org/search/?q=perl5-porters&quot;&gt;https://markmail.org/search/?q=perl5-porters&lt;/a&gt;. There is also an archive at &lt;a href=&quot;https://archive.develooper.com/perl5-porters@perl.org/&quot;&gt;https://archive.develooper.com/perl5-porters@perl.org/&lt;/a&gt;.</source>
          <target state="translated">목록의 검색 가능한 아카이브는 &lt;a href=&quot;https://markmail.org/search/?q=perl5-porters&quot;&gt;https://markmail.org/search/?q=perl5-porters&lt;/a&gt; 에서 사용할 수 있습니다 . &lt;a href=&quot;https://archive.develooper.com/perl5-porters@perl.org/&quot;&gt;https://archive.develooper.com/perl5-porters@perl.org/&lt;/a&gt; 에도 아카이브가 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1598e0f0cd8f36f911067e3fef88a3cdc16b3aed" translate="yes" xml:space="preserve">
          <source>A section is started by the named heading or item. For example, &lt;code&gt;L&amp;lt;perlvar/$.&amp;gt;&lt;/code&gt; or &lt;code&gt;L&amp;lt;perlvar/&quot;$.&quot;&amp;gt;&lt;/code&gt; both link to the section started by &quot;&lt;code&gt;=item $.&lt;/code&gt; &quot; in perlvar. And &lt;code&gt;L&amp;lt;perlsyn/For Loops&amp;gt;&lt;/code&gt; or &lt;code&gt;L&amp;lt;perlsyn/&quot;For Loops&quot;&amp;gt;&lt;/code&gt; both link to the section started by &quot;&lt;code&gt;=head2 For Loops&lt;/code&gt; &quot; in perlsyn.</source>
          <target state="translated">섹션은 명명 된 제목 또는 항목으로 시작됩니다. 예를 들어, &lt;code&gt;L&amp;lt;perlvar/$.&amp;gt;&lt;/code&gt; 또는 &lt;code&gt;L&amp;lt;perlvar/&quot;$.&quot;&amp;gt;&lt;/code&gt; 은 perlvar에서 &quot; &lt;code&gt;=item $.&lt;/code&gt; &quot;로 시작하는 섹션에 연결됩니다 . 그리고 &lt;code&gt;L&amp;lt;perlsyn/For Loops&amp;gt;&lt;/code&gt; 또는 &lt;code&gt;L&amp;lt;perlsyn/&quot;For Loops&quot;&amp;gt;&lt;/code&gt; 는 perlsyn에서 &quot; &lt;code&gt;=head2 For Loops&lt;/code&gt; &quot;로 시작하는 섹션으로 연결됩니다 .</target>
        </trans-unit>
        <trans-unit id="50daaeb1a2fab8aef823f07b1ef237ef7fd7c501" translate="yes" xml:space="preserve">
          <source>A section is started by the named heading or item. For example, &lt;code&gt;L&amp;lt;perlvar/$.&amp;gt;&lt;/code&gt; or &lt;code&gt;L&amp;lt;perlvar/&quot;$.&quot;&amp;gt;&lt;/code&gt; both link to the section started by &quot;&lt;code&gt;=item $.&lt;/code&gt;&quot; in perlvar. And &lt;code&gt;L&amp;lt;perlsyn/For Loops&amp;gt;&lt;/code&gt; or &lt;code&gt;L&amp;lt;perlsyn/&quot;For Loops&quot;&amp;gt;&lt;/code&gt; both link to the section started by &quot;&lt;code&gt;=head2 For Loops&lt;/code&gt;&quot; in perlsyn.</source>
          <target state="translated">섹션은 명명 된 표제 또는 항목으로 시작됩니다. 예를 들어, &lt;code&gt;L&amp;lt;perlvar/$.&amp;gt;&lt;/code&gt; 또는 &lt;code&gt;L&amp;lt;perlvar/&quot;$.&quot;&amp;gt;&lt;/code&gt; 둘 다 perlvar에서 &quot; &lt;code&gt;=item $.&lt;/code&gt; &quot;로 시작하는 섹션에 연결됩니다 . 그리고 &lt;code&gt;L&amp;lt;perlsyn/For Loops&amp;gt;&lt;/code&gt; 또는 &lt;code&gt;L&amp;lt;perlsyn/&quot;For Loops&quot;&amp;gt;&lt;/code&gt; 둘 다 perlsyn에서 &quot; &lt;code&gt;=head2 For Loops&lt;/code&gt; &quot;로 시작하는 섹션에 연결됩니다 .</target>
        </trans-unit>
        <trans-unit id="2bd968f32a9ca757550679bcb38ba91ae56c38c6" translate="yes" xml:space="preserve">
          <source>A selection of any number of &lt;b&gt;elements&lt;/b&gt; from a &lt;b&gt;list&lt;/b&gt;, &lt;b&gt;array&lt;/b&gt;, or &lt;b&gt;hash&lt;/b&gt;.</source>
          <target state="translated">&lt;b&gt;list&lt;/b&gt; , &lt;b&gt;array&lt;/b&gt; 또는 &lt;b&gt;hash&lt;/b&gt; 에서 원하는 수의 &lt;b&gt;요소&lt;/b&gt; 를 선택합니다 .&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="c8bb7e9a293c6c000ed25150f0f4d86b8b09ae48" translate="yes" xml:space="preserve">
          <source>A selection of general-utility hash subroutines</source>
          <target state="translated">범용 유틸리티 해시 서브 루틴 선택</target>
        </trans-unit>
        <trans-unit id="7f015133979033409d91eedccc2323e573bc6368" translate="yes" xml:space="preserve">
          <source>A selection of general-utility list subroutines</source>
          <target state="translated">일반 유틸리티 목록 서브 루틴 선택</target>
        </trans-unit>
        <trans-unit id="28d3d211918b04ba8766082d56a39fef4fdf3700" translate="yes" xml:space="preserve">
          <source>A selection of general-utility scalar subroutines</source>
          <target state="translated">범용 유틸리티 스칼라 서브 루틴 선택</target>
        </trans-unit>
        <trans-unit id="6c2a22b80753e149c4a3e936da6e37252cc4db3f" translate="yes" xml:space="preserve">
          <source>A selection of utility subroutines for subs and CODE references</source>
          <target state="translated">서브 및 CODE 참조를위한 유틸리티 서브 루틴 선택</target>
        </trans-unit>
        <trans-unit id="047fc7c9d2dc1ac28d49429eb7bc7a3322abc4af" translate="yes" xml:space="preserve">
          <source>A semicolon (&lt;code&gt;;&lt;/code&gt; ) separates mandatory arguments from optional arguments. It is redundant before &lt;code&gt;@&lt;/code&gt; or &lt;code&gt;%&lt;/code&gt; , which gobble up everything else.</source>
          <target state="translated">세미콜론 ( &lt;code&gt;;&lt;/code&gt; )은 필수 인수를 선택적 인수와 구분합니다. &lt;code&gt;@&lt;/code&gt; 또는 &lt;code&gt;%&lt;/code&gt; 앞에 중복되어 다른 모든 것을 망칠 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fcc144c5cd365b46474f5e986e9bf1d79c5d34db" translate="yes" xml:space="preserve">
          <source>A semicolon (&lt;code&gt;;&lt;/code&gt;) separates mandatory arguments from optional arguments. It is redundant before &lt;code&gt;@&lt;/code&gt; or &lt;code&gt;%&lt;/code&gt;, which gobble up everything else.</source>
          <target state="translated">세미콜론 ( &lt;code&gt;;&lt;/code&gt; )은 필수 인수와 선택적 인수를 구분합니다. &lt;code&gt;@&lt;/code&gt; 또는 &lt;code&gt;%&lt;/code&gt; 앞에 중복되어 다른 모든 것을 먹습니다.</target>
        </trans-unit>
        <trans-unit id="f511bb1ccbd67c6c6ca9d2e6f48560176d03c2b5" translate="yes" xml:space="preserve">
          <source>A sequence of &lt;b&gt;bits&lt;/b&gt; that is actually being thought of as a sequence of bits, for once.</source>
          <target state="translated">실제로 &lt;b&gt;비트&lt;/b&gt; 시퀀스 로 생각되는 비트 시퀀스는 한 번입니다.</target>
        </trans-unit>
        <trans-unit id="cae9f6dde987a755ec3121175496d8328940bd06" translate="yes" xml:space="preserve">
          <source>A sequence of characters such as &amp;ldquo;He said !@#*&amp;amp;%@#*?!&amp;rdquo;. A string does not have to be entirely printable.</source>
          <target state="translated">&amp;ldquo;그는! @ # * &amp;amp; % @ # * ?!&amp;rdquo;와 같은 일련의 문자입니다. 문자열을 완전히 인쇄 할 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="2d1e5cc5993ad4e16630359feaa4c2a48e6f7df3" translate="yes" xml:space="preserve">
          <source>A sequence of digits is an unsigned decimal literal number.</source>
          <target state="translated">일련의 숫자는 부호없는 10 진수 리터럴 숫자입니다.</target>
        </trans-unit>
        <trans-unit id="3c0733fdb6bad90c8e5cff763f33aac838dc3a41" translate="yes" xml:space="preserve">
          <source>A sequence of relational operators, such as &lt;code&gt;&quot;$x &amp;lt; $y &amp;lt;= $z&quot;&lt;/code&gt;, performs chained comparisons, in the manner described above in the section &lt;a href=&quot;#Operator-Precedence-and-Associativity&quot;&gt;&quot;Operator Precedence and Associativity&quot;&lt;/a&gt;. Beware that they do not chain with equality operators, which have lower precedence.</source>
          <target state="translated">&lt;code&gt;&quot;$x &amp;lt; $y &amp;lt;= $z&quot;&lt;/code&gt; 와 같은 일련의 관계 연산자 는 위의 &lt;a href=&quot;#Operator-Precedence-and-Associativity&quot;&gt;&quot;연산자 우선 순위 및 연관성&quot;&lt;/a&gt; 섹션에서 설명한 방식으로 연결 비교를 수행합니다 . 우선 순위가 낮은 등호 연산자와 연결되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3e8a71fa4ea97586fb33bedb544c35984db92bc7" translate="yes" xml:space="preserve">
          <source>A sequence of the above equality operators, such as &lt;code&gt;&quot;$x == $y == $z&quot;&lt;/code&gt;, performs chained comparisons, in the manner described above in the section &lt;a href=&quot;#Operator-Precedence-and-Associativity&quot;&gt;&quot;Operator Precedence and Associativity&quot;&lt;/a&gt;. Beware that they do not chain with relational operators, which have higher precedence.</source>
          <target state="translated">&lt;code&gt;&quot;$x == $y == $z&quot;&lt;/code&gt; 와 같은 위의 등식 연산자 시퀀스는 위의 &lt;a href=&quot;#Operator-Precedence-and-Associativity&quot;&gt;&quot;연산자 우선 순위 및 연관성&quot;&lt;/a&gt; 섹션에서 설명한 방식으로 연결 비교를 수행합니다 . 우선 순위가 더 높은 관계 연산자와 연결되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="fec7ee11f629dd8914f5fb3939fa45a8d0ac8f26" translate="yes" xml:space="preserve">
          <source>A sequence, such as &lt;code&gt;=head1&lt;/code&gt; , that denotes the start of a &lt;b&gt;pod&lt;/b&gt; section.</source>
          <target state="translated">&lt;b&gt;포드&lt;/b&gt; 섹션 의 시작을 나타내는 &lt;code&gt;=head1&lt;/code&gt; 과 같은 시퀀스 입니다.&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="b626bb1acba7e95f123c1e8cb0f3ca8665a27861" translate="yes" xml:space="preserve">
          <source>A sequence, such as &lt;code&gt;=head1&lt;/code&gt;, that denotes the start of a &lt;b&gt;pod&lt;/b&gt; section.</source>
          <target state="translated">&lt;b&gt;포드&lt;/b&gt; 섹션 의 시작을 나타내는 시퀀스 (예 : &lt;code&gt;=head1&lt;/code&gt; ) .&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="615050343b7872b60001479c7e1e5357ce76b3e7" translate="yes" xml:space="preserve">
          <source>A series of &lt;b&gt;processes&lt;/b&gt; all in a row, linked by &lt;b&gt;pipes&lt;/b&gt;, where each passes its output stream to the next.</source>
          <target state="translated">&lt;b&gt;파이프로&lt;/b&gt; 연결된 일련의 &lt;b&gt;프로세스가&lt;/b&gt; 모두 &lt;b&gt;파이프로&lt;/b&gt; 연결되어 있으며 각 &lt;b&gt;프로세스&lt;/b&gt; 는 출력 스트림을 다음 스트림으로 전달합니다.</target>
        </trans-unit>
        <trans-unit id="5e7b6708245b79eaeed5d38bcac016afddbd6e09" translate="yes" xml:space="preserve">
          <source>A series of characters matches that series of characters in the target string, so the pattern &lt;code&gt;blurfl&lt;/code&gt; would match &quot;blurfl&quot; in the target string.</source>
          <target state="translated">일련의 문자는 대상 문자열의 해당 일련의 문자와 일치하므로 패턴 &lt;code&gt;blurfl&lt;/code&gt; 은 대상 문자열의 &quot;blurfl&quot;과 일치합니다.</target>
        </trans-unit>
        <trans-unit id="cb6d59d3792163250639b9090bf480c17ab2f55e" translate="yes" xml:space="preserve">
          <source>A set of &lt;b&gt;directories&lt;/b&gt; and &lt;b&gt;files&lt;/b&gt; residing on a partition of the disk. Sometimes known as a &amp;ldquo;partition&amp;rdquo;. You can change the file&amp;rsquo;s name or even move a file around from directory to directory within a filesystem without actually moving the file itself, at least under Unix.</source>
          <target state="translated">디스크 파티션에있는 &lt;b&gt;디렉토리&lt;/b&gt; 및 &lt;b&gt;파일&lt;/b&gt; 세트 . &quot;파티션&quot;이라고도합니다. 적어도 Unix에서 실제로 파일 자체를 이동하지 않고도 파일 이름을 변경하거나 파일 시스템 내 디렉토리에서 디렉토리로 파일을 이동할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="a5ce6ae6f62d942a0f2702d5475445785e80396f" translate="yes" xml:space="preserve">
          <source>A set of criteria used to validate a particular piece of data if it has to adhere to particular rules.</source>
          <target state="translated">특정 규칙을 준수해야하는 경우 특정 데이터를 확인하는 데 사용되는 일련의 기준.</target>
        </trans-unit>
        <trans-unit id="abcc0ff1d11111cc38f19c5047e331b6ce4f3ede" translate="yes" xml:space="preserve">
          <source>A set of distribution prerequisites by phase and type</source>
          <target state="translated">단계 및 유형별 분배 전제 조건 세트</target>
        </trans-unit>
        <trans-unit id="2054435ebeb82c104e8cc6baf030893f06d8bca6" translate="yes" xml:space="preserve">
          <source>A set of macros makes accessing the fields easier and more consistent. These include &lt;code&gt;OP()&lt;/code&gt; , which is used to determine the type of a &lt;code&gt;regnode&lt;/code&gt; -like structure; &lt;code&gt;NEXT_OFF()&lt;/code&gt; , which is the offset to the next node (more on this later); &lt;code&gt;ARG()&lt;/code&gt; , &lt;code&gt;ARG1()&lt;/code&gt; , &lt;code&gt;ARG2()&lt;/code&gt; , &lt;code&gt;ARG_SET()&lt;/code&gt; , and equivalents for reading and setting the arguments; and &lt;code&gt;STR_LEN()&lt;/code&gt; , &lt;code&gt;STRING()&lt;/code&gt; and &lt;code&gt;OPERAND()&lt;/code&gt; for manipulating strings and regop bearing types.</source>
          <target state="translated">매크로 세트를 사용하면 필드에보다 쉽고 일관성있게 액세스 할 수 있습니다. 여기에는 &lt;code&gt;regnode&lt;/code&gt; 형 구조 의 유형을 결정하는 데 사용되는 &lt;code&gt;OP()&lt;/code&gt; 가 포함됩니다 . 다음 노드에 대한 오프셋 인 &lt;code&gt;NEXT_OFF()&lt;/code&gt; ). &lt;code&gt;ARG()&lt;/code&gt; , &lt;code&gt;ARG1()&lt;/code&gt; , &lt;code&gt;ARG2()&lt;/code&gt; , &lt;code&gt;ARG_SET()&lt;/code&gt; 및 인수를 읽고 설정하는 등가물; 및 &lt;code&gt;STR_LEN()&lt;/code&gt; , &lt;code&gt;STRING()&lt;/code&gt; 및 &lt;code&gt;OPERAND()&lt;/code&gt; 조작 문자열 및 regop 베어링 타입.</target>
        </trans-unit>
        <trans-unit id="405ee0a4d5617474f5f68f2671ed8caabd78eb2a" translate="yes" xml:space="preserve">
          <source>A set of macros makes accessing the fields easier and more consistent. These include &lt;code&gt;OP()&lt;/code&gt;, which is used to determine the type of a &lt;code&gt;regnode&lt;/code&gt;-like structure; &lt;code&gt;NEXT_OFF()&lt;/code&gt;, which is the offset to the next node (more on this later); &lt;code&gt;ARG()&lt;/code&gt;, &lt;code&gt;ARG1()&lt;/code&gt;, &lt;code&gt;ARG2()&lt;/code&gt;, &lt;code&gt;ARG_SET()&lt;/code&gt;, and equivalents for reading and setting the arguments; and &lt;code&gt;STR_LEN()&lt;/code&gt;, &lt;code&gt;STRING()&lt;/code&gt; and &lt;code&gt;OPERAND()&lt;/code&gt; for manipulating strings and regop bearing types.</source>
          <target state="translated">일련의 매크로를 사용하면 필드에 더 쉽고 일관되게 액세스 할 수 있습니다. 여기에는 &lt;code&gt;regnode&lt;/code&gt; 와 유사한 구조 의 유형을 결정하는 데 사용되는 &lt;code&gt;OP()&lt;/code&gt; 가 포함됩니다 . &lt;code&gt;NEXT_OFF()&lt;/code&gt; , 다음 노드에 대한 오프셋입니다 (나중에 자세히 설명). &lt;code&gt;ARG()&lt;/code&gt; , &lt;code&gt;ARG1()&lt;/code&gt; , &lt;code&gt;ARG2()&lt;/code&gt; , &lt;code&gt;ARG_SET()&lt;/code&gt; 및 인수를 읽고 설정하는 등가물; 및 &lt;code&gt;STR_LEN()&lt;/code&gt; , &lt;code&gt;STRING()&lt;/code&gt; 및 &lt;code&gt;OPERAND()&lt;/code&gt; 조작 문자열 및 regop 베어링 타입.</target>
        </trans-unit>
        <trans-unit id="5b89ed012267a41a30013b79a6117c49ce7fdacf" translate="yes" xml:space="preserve">
          <source>A set of possible values, together with all the operations that know how to deal with those values. For example, a numeric data type has a certain set of numbers that you can work with, as well as various mathematical operations that you can do on the numbers, but would make little sense on, say, a string such as &lt;code&gt;&quot;Kilroy&quot;&lt;/code&gt; . Strings have their own operations, such as &lt;b&gt;concatenation&lt;/b&gt;. Compound types made of a number of smaller pieces generally have operations to compose and decompose them, and perhaps to rearrange them. &lt;b&gt;Objects&lt;/b&gt; that model things in the real world often have operations that correspond to real activities. For instance, if you model an elevator, your elevator object might have an &lt;code&gt;open_door&lt;/code&gt;&lt;b&gt;method&lt;/b&gt;.</source>
          <target state="translated">해당 값을 처리하는 방법을 알고있는 모든 작업과 함께 가능한 값 집합입니다. 예를 들어, 숫자 데이터 유형에는 작업 할 수있는 특정 숫자 세트와 숫자에 대해 수행 할 수있는 다양한 수학 연산이 있지만 &lt;code&gt;&quot;Kilroy&quot;&lt;/code&gt; 와 같은 문자열에는 의미가 없습니다 . 문자열에는 &lt;b&gt;concatenation&lt;/b&gt; 과 같은 자체 연산이 있습니다. 다수의 더 작은 조각들로 이루어진 화합물 유형은 일반적으로 이들을 구성 및 분해하고, 아마도 그것들을 재배 열하는 조작을 갖는다. 현실 세계에서 &lt;b&gt;사물&lt;/b&gt; 을 모델링하는 &lt;b&gt;객체&lt;/b&gt; 에는 종종 실제 활동에 해당하는 작업이 있습니다. 예를 들어 엘리베이터를 모델링하는 경우 엘리베이터 객체에 &lt;code&gt;open_door&lt;/code&gt; &lt;b&gt;메서드&lt;/b&gt; 가있을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="46aa5c9b6882b1651ea253eff267521cde51f269" translate="yes" xml:space="preserve">
          <source>A set of possible values, together with all the operations that know how to deal with those values. For example, a numeric data type has a certain set of numbers that you can work with, as well as various mathematical operations that you can do on the numbers, but would make little sense on, say, a string such as &lt;code&gt;&quot;Kilroy&quot;&lt;/code&gt;. Strings have their own operations, such as &lt;b&gt;concatenation&lt;/b&gt;. Compound types made of a number of smaller pieces generally have operations to compose and decompose them, and perhaps to rearrange them. &lt;b&gt;Objects&lt;/b&gt; that model things in the real world often have operations that correspond to real activities. For instance, if you model an elevator, your elevator object might have an &lt;code&gt;open_door&lt;/code&gt;&lt;b&gt;method&lt;/b&gt;.</source>
          <target state="translated">해당 값을 처리하는 방법을 알고있는 모든 작업과 함께 가능한 값 집합입니다. 예를 들어 숫자 데이터 유형에는 작업 할 수있는 특정 숫자 집합과 숫자에 대해 수행 할 수있는 다양한 수학 연산이 있지만 &lt;code&gt;&quot;Kilroy&quot;&lt;/code&gt; 와 같은 문자열에는 거의 의미가 없습니다 . 문자열에는 &lt;b&gt;연결&lt;/b&gt; 과 같은 고유 한 작업이 있습니다. 여러 개의 작은 조각으로 구성된 복합 유형에는 일반적으로이를 구성 및 분해하고 아마도 재정렬하는 작업이 있습니다. 현실 세계에서 &lt;b&gt;사물&lt;/b&gt; 을 모델링하는 &lt;b&gt;객체&lt;/b&gt; 에는 종종 실제 활동에 해당하는 작업이 있습니다. 예를 들어 엘리베이터를 모델링하는 경우 엘리베이터 객체에 &lt;code&gt;open_door&lt;/code&gt; &lt;b&gt;메서드&lt;/b&gt; 가있을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="af57cf3203f1cd3e2de0a1965dff9d274c21ca2b" translate="yes" xml:space="preserve">
          <source>A set of related data values in a &lt;b&gt;file&lt;/b&gt; or &lt;b&gt;stream&lt;/b&gt;, often associated with a unique &lt;b&gt;key&lt;/b&gt; field. In Unix, often commensurate with a &lt;b&gt;line&lt;/b&gt;, or a blank-line&amp;ndash;terminated set of lines (a &amp;ldquo;paragraph&amp;rdquo;). Each line of the</source>
          <target state="translated">종종 고유 &lt;b&gt;키&lt;/b&gt; 필드 와 연관된 &lt;b&gt;파일&lt;/b&gt; 또는 &lt;b&gt;스트림&lt;/b&gt; 의 관련 데이터 값 세트입니다 . 유닉스에서는 종종 &lt;b&gt;line&lt;/b&gt; 또는 빈 줄로 끝나는 줄 (&amp;ldquo;문단&amp;rdquo;)에 비례 합니다. 의 각 줄&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="1e3ce769bdcb624305623c0e39fad86b6550d415" translate="yes" xml:space="preserve">
          <source>A set of users of which you are a member. In some operating systems (like Unix), you can give certain file access permissions to other members of your group.</source>
          <target state="translated">귀하가 회원 인 일련의 사용자. 일부 운영 체제 (예 : Unix)에서는 그룹의 다른 구성원에게 특정 파일 액세스 권한을 부여 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a3f080c404572d6a66e864a2fec8d37666d88fa5" translate="yes" xml:space="preserve">
          <source>A set of version requirements for a CPAN dist</source>
          <target state="translated">CPAN dist에 대한 버전 요구 사항 세트</target>
        </trans-unit>
        <trans-unit id="a023ae4922155fc45ad5e15036082f2112e5376d" translate="yes" xml:space="preserve">
          <source>A seven-bit safe (non-eight-bit) encoding, which is useful if the transport or storage is not eight-bit safe. Defined by RFC 2152.</source>
          <target state="translated">전송 또는 저장이 8 비트 안전하지 않은 경우에 유용한 7 비트 안전 (8 비트가 아닌) 인코딩입니다. RFC 2152에 의해 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="a600cb53b0fe3c2106640728c33066b8be46fd29" translate="yes" xml:space="preserve">
          <source>A short description of the function of the op.</source>
          <target state="translated">op의 기능에 대한 간단한 설명.</target>
        </trans-unit>
        <trans-unit id="d96648e3b3628e3e472e306b3dd3028622349739" translate="yes" xml:space="preserve">
          <source>A short description of your module, what it does, why someone would use it and its limitations. CPAN automatically pulls your README file out of the archive and makes it available to CPAN users, it is the first thing they will read to decide if your module is right for them.</source>
          <target state="translated">모듈에 대한 간단한 설명, 기능, 누군가 모듈을 사용하는 이유 및 제한 사항. CPAN은 자동으로 README 파일을 아카이브에서 가져와 CPAN 사용자가 사용할 수 있도록합니다. 모듈이 자신에게 적합한 지 결정하기 위해 가장 먼저 읽어야 할 것입니다.</target>
        </trans-unit>
        <trans-unit id="3eb927617c6b6dee09c1f05661af50c2789df3ce" translate="yes" xml:space="preserve">
          <source>A short name for your op. This will be included in some error messages, and will also be returned as &lt;code&gt;$op-&amp;gt;name&lt;/code&gt; by the &lt;a href=&quot;b&quot;&gt;B&lt;/a&gt; module, so it will appear in the output of module like &lt;a href=&quot;B::Concise&quot;&gt;B::Concise&lt;/a&gt;.</source>
          <target state="translated">작전의 짧은 이름입니다. 이것은 일부 오류 메시지에 포함되며 &lt;a href=&quot;b&quot;&gt;B&lt;/a&gt; 모듈에 의해 &lt;code&gt;$op-&amp;gt;name&lt;/code&gt; 으로 반환 되므로 &lt;a href=&quot;B::Concise&quot;&gt;B :: Concise&lt;/a&gt; 와 같은 모듈의 출력에 나타납니다 .</target>
        </trans-unit>
        <trans-unit id="7054451d8531a19f5986333d608566f0e421b059" translate="yes" xml:space="preserve">
          <source>A short name for your op. This will be included in some error messages, and will also be returned as &lt;code&gt;$op-&amp;gt;name&lt;/code&gt; by the &lt;a href=&quot;b&quot;&gt;B&lt;/a&gt; module, so it will appear in the output of module like &lt;a href=&quot;b/concise&quot;&gt;B::Concise&lt;/a&gt;.</source>
          <target state="translated">작전의 짧은 이름입니다. 이것은 일부 오류 메시지에 포함되며 &lt;a href=&quot;b&quot;&gt;B&lt;/a&gt; 모듈에 의해 &lt;code&gt;$op-&amp;gt;name&lt;/code&gt; 으로 반환 되므로 &lt;a href=&quot;b/concise&quot;&gt;B :: Concise&lt;/a&gt; 와 같은 모듈의 출력에 나타납니다 .</target>
        </trans-unit>
        <trans-unit id="659172f97956f35000461e8175c3ae20d404aec4" translate="yes" xml:space="preserve">
          <source>A short usage summary for programs and functions. This section is mandatory for section 3 pages. For Perl module documentation, it's usually convenient to have the contents of this section be a verbatim block showing some (brief) examples of typical ways the module is used.</source>
          <target state="translated">프로그램 및 기능에 대한 간단한 사용법 요약. 이 섹션은 섹션 3 페이지에 필수적입니다. Perl 모듈 문서의 경우, 일반적으로이 섹션의 내용을 모듈이 사용되는 일반적인 방법의 일부 (간략한) 예를 보여주는 축약 형 블록으로 만드는 것이 편리합니다.</target>
        </trans-unit>
        <trans-unit id="ecd576fa5b368299ace3b5dd153caef33335850b" translate="yes" xml:space="preserve">
          <source>A shortcut for $token-&amp;gt;tagname(...)</source>
          <target state="translated">$ token-&amp;gt; tagname (...)의 단축키</target>
        </trans-unit>
        <trans-unit id="889d9060f1528398717f26dcafe44f09ac88a287" translate="yes" xml:space="preserve">
          <source>A shortcut to return Math::BigInt-&amp;gt;binf(). Useful because Perl does not always handle bareword &lt;code&gt;inf&lt;/code&gt; properly.</source>
          <target state="translated">Math :: BigInt-&amp;gt; binf ()를 반환하는 바로 가기입니다. 펄은 항상 bareword는 처리하지 못하기 때문에 유용한 &lt;code&gt;inf&lt;/code&gt; 제대로.</target>
        </trans-unit>
        <trans-unit id="c597d44b686300cfd664e15765135328081ac79a" translate="yes" xml:space="preserve">
          <source>A shortcut to return Math::BigInt-&amp;gt;bnan(). Useful because Perl does not always handle bareword &lt;code&gt;NaN&lt;/code&gt; properly.</source>
          <target state="translated">Math :: BigInt-&amp;gt; bnan ()을 반환하는 바로 가기입니다. Perl이 베어 워드 &lt;code&gt;NaN&lt;/code&gt; 을 항상 올바르게 처리하지는 않기 때문에 유용 합니다.</target>
        </trans-unit>
        <trans-unit id="588514bdb3ad44f23f4111f5dfe923f166cc27ed" translate="yes" xml:space="preserve">
          <source>A side effect of this representation is that you can use &lt;a href=&quot;perlop#Equality-Operators&quot;&gt;&lt;code&gt;eq&lt;/code&gt;&lt;/a&gt; to see if two references refer to the same thing. (But you should usually use &lt;a href=&quot;perlop#Equality-Operators&quot;&gt;&lt;code&gt;==&lt;/code&gt;&lt;/a&gt; instead because it's much faster.)</source>
          <target state="translated">이 표현의 부작용은 &lt;a href=&quot;perlop#Equality-Operators&quot;&gt; &lt;code&gt;eq&lt;/code&gt; &lt;/a&gt; 를 사용 하여 두 참조가 동일한 것을 참조하는지 확인할 수 있다는 것입니다. (하지만 훨씬 더 빠르기 때문에 일반적으로 &lt;a href=&quot;perlop#Equality-Operators&quot;&gt; &lt;code&gt;==&lt;/code&gt; &lt;/a&gt; 를 사용해야합니다 .)</target>
        </trans-unit>
        <trans-unit id="4c2bf7bb028dd860429a797ea74f61d6f6006cc5" translate="yes" xml:space="preserve">
          <source>A side effect of this representation is that you can use &lt;code&gt;eq&lt;/code&gt; to see if two references refer to the same thing. (But you should usually use &lt;code&gt;==&lt;/code&gt; instead because it's much faster.)</source>
          <target state="translated">이 표현의 부작용은 &lt;code&gt;eq&lt;/code&gt; 를 사용 하여 두 참조가 동일한 것을 참조하는지 확인할 수 있다는 것입니다. (하지만 훨씬 빠르기 때문에 보통 &lt;code&gt;==&lt;/code&gt; 를 사용해야합니다 .)</target>
        </trans-unit>
        <trans-unit id="521c212b6a17d7bb672fae4188d350c73713a7f4" translate="yes" xml:space="preserve">
          <source>A sigil followed by a single character matching the &lt;code&gt;\p{POSIX_Punct}&lt;/code&gt; property, like &lt;code&gt;$!&lt;/code&gt; or &lt;code&gt;%+&lt;/code&gt; , except the character &lt;code&gt;&quot;{&quot;&lt;/code&gt; doesn't work.</source>
          <target state="translated">&lt;code&gt;$!&lt;/code&gt; 와 같이 &lt;code&gt;\p{POSIX_Punct}&lt;/code&gt; 속성과 일치하는 단일 문자가 뒤 따릅니다 . 문자 &lt;code&gt;&quot;{&quot;&lt;/code&gt; 를 제외한 &lt;code&gt;%+&lt;/code&gt; 또는 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="78b33a149b8ec79d1db1e7ff3c6da388ca1d2f6f" translate="yes" xml:space="preserve">
          <source>A sigil followed by a single character matching the &lt;code&gt;\p{POSIX_Punct}&lt;/code&gt; property, like &lt;code&gt;$!&lt;/code&gt; or &lt;code&gt;%+&lt;/code&gt;, except the character &lt;code&gt;&quot;{&quot;&lt;/code&gt; doesn't work.</source>
          <target state="translated">시길 뒤에 &lt;code&gt;$!&lt;/code&gt; 와 같이 &lt;code&gt;\p{POSIX_Punct}&lt;/code&gt; 속성과 일치하는 단일 문자가옵니다 . 또는 &lt;code&gt;%+&lt;/code&gt; . 단, 문자 &lt;code&gt;&quot;{&quot;&lt;/code&gt; 는 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f3ab0e2e7434b80376db123861053e1dd6f58146" translate="yes" xml:space="preserve">
          <source>A sigil, followed by a caret and any one of the characters &lt;code&gt;[][A-Z^_?\]&lt;/code&gt;, like &lt;code&gt;$^V&lt;/code&gt; or &lt;code&gt;$^]&lt;/code&gt;.</source>
          <target state="translated">시길, 캐럿 및 &lt;code&gt;$^V&lt;/code&gt; 또는 &lt;code&gt;$^]&lt;/code&gt; 와 같은 문자 &lt;code&gt;[][A-Z^_?\]&lt;/code&gt; 중 하나 .</target>
        </trans-unit>
        <trans-unit id="96dcc4bc70d20a77f933afc7e767e66a7d6afd1e" translate="yes" xml:space="preserve">
          <source>A sigil, followed by any single character in the range &lt;code&gt;[\xA1-\xAC\xAE-\xFF]&lt;/code&gt; when not under &lt;code&gt;&quot;use utf8&quot;&lt;/code&gt;. (Under &lt;code&gt;&quot;use utf8&quot;&lt;/code&gt;, the normal identifier rules given earlier in this section apply.) Use of non-graphic characters (the C1 controls, the NO-BREAK SPACE, and the SOFT HYPHEN) has been disallowed since v5.26.0. The use of the other characters is unwise, as these are all reserved to have special meaning to Perl, and none of them currently do have special meaning, though this could change without notice.</source>
          <target state="translated">&lt;code&gt;&quot;use utf8&quot;&lt;/code&gt; 아래에 있지 않을 때 &lt;code&gt;[\xA1-\xAC\xAE-\xFF]&lt;/code&gt; 범위의 단일 문자가 뒤에 오는시길 . ( &lt;code&gt;&quot;use utf8&quot;&lt;/code&gt; 아래 에서이 섹션의 앞부분에 제공된 일반 식별자 규칙이 적용됩니다.) v5.26.0부터 그래픽이 아닌 문자 (C1 컨트롤, NO-BREAK SPACE 및 SOFT HYPHEN)의 사용이 허용되지 않습니다. 다른 문자를 사용하는 것은 현명하지 못합니다. 이들은 모두 Perl에 특별한 의미를 갖도록 예약되어 있고 현재는 특별한 의미가 없지만 예고없이 변경 될 수 있기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="2cc8d7ea546cfbfc32e7048bc99953161b5c5af3" translate="yes" xml:space="preserve">
          <source>A sigil, followed by either a caret and a single POSIX uppercase letter, like &lt;code&gt;$^V&lt;/code&gt; or &lt;code&gt;$^W&lt;/code&gt; , or a sigil followed by a literal non-space, non-&lt;code&gt;NUL&lt;/code&gt; control character matching the &lt;code&gt;\p{POSIX_Cntrl}&lt;/code&gt; property. Due to a historical oddity, if not running under &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; , the 128 characters in the &lt;code&gt;[0x80-0xff]&lt;/code&gt; range are considered to be controls, and may also be used in length-one variables. However, the use of non-graphical characters is deprecated as of v5.22, and support for them will be removed in a future version of perl. ASCII space characters and &lt;code&gt;NUL&lt;/code&gt; already aren't allowed, so this means that a single-character variable name with that name being any other C0 control &lt;code&gt;[0x01-0x1F]&lt;/code&gt; , or &lt;code&gt;DEL&lt;/code&gt; will generate a deprecated warning. Already, under &lt;code&gt;&quot;use
utf8&quot;&lt;/code&gt; , non-ASCII characters must match &lt;code&gt;Perl_XIDS&lt;/code&gt; . As of v5.22, when not under &lt;code&gt;&quot;use utf8&quot;&lt;/code&gt; C1 controls &lt;code&gt;[0x80-0x9F]&lt;/code&gt; , NO BREAK SPACE, and SOFT HYPHEN (&lt;code&gt;SHY&lt;/code&gt; )) generate a deprecated warning.</source>
          <target state="translated">캐럿 뒤에 &lt;code&gt;$^V&lt;/code&gt; 또는 &lt;code&gt;$^W&lt;/code&gt; 와 같은 캐럿 및 단일 POSIX 대문자 또는 &lt;code&gt;\p{POSIX_Cntrl}&lt;/code&gt; 속성과 일치 하는 문자가 아닌 공백이 아닌 &lt;code&gt;NUL&lt;/code&gt; 제어 문자가 뒤에 오는 sigil . 역사적 이상으로 인해 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; &lt;a href=&quot;functions/use&quot;&gt;사용시&lt;/a&gt; 실행되지 않는 경우 &lt;code&gt;[0x80-0xff]&lt;/code&gt; 범위 의 128 자는 제어로 간주되며 길이가 1 인 변수에도 사용될 수 있습니다. 그러나 비 그래픽 문자의 사용은 v5.22부터 더 이상 사용되지 않으며 이후 버전의 perl에서 지원되지 않습니다. ASCII 공백 문자 및 &lt;code&gt;NUL&lt;/code&gt; 이미 허용되지 않으므로 이는 해당 이름을 가진 단일 문자 변수 이름이 다른 C0 제어 &lt;code&gt;[0x01-0x1F]&lt;/code&gt; 또는 &lt;code&gt;DEL&lt;/code&gt; 에서 사용되지 않는 경고를 생성 함을 의미합니다. 이미 &lt;code&gt;&quot;use utf8&quot;&lt;/code&gt; 에서 비 ASCII 문자는 &lt;code&gt;Perl_XIDS&lt;/code&gt; 와 일치해야합니다 . v5.22부터 &lt;code&gt;&quot;use utf8&quot;&lt;/code&gt; 아닌 경우 C1 제어 &lt;code&gt;[0x80-0x9F]&lt;/code&gt; , NO BREAK SPACE 및 SOHY HYPHEN ( &lt;code&gt;SHY&lt;/code&gt; )은 더 이상 사용되지 않는 경고를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="25c7b41e2f3083fca5663c24cdf9d0f7721da4bb" translate="yes" xml:space="preserve">
          <source>A sigil, followed solely by digits matching &lt;code&gt;\p{POSIX_Digit}&lt;/code&gt; , like &lt;code&gt;$0&lt;/code&gt; , &lt;code&gt;$1&lt;/code&gt; , or &lt;code&gt;$10000&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;$0&lt;/code&gt; , &lt;code&gt;$1&lt;/code&gt; 또는 &lt;code&gt;$10000&lt;/code&gt; 과 같이 &lt;code&gt;\p{POSIX_Digit}&lt;/code&gt; 와 일치하는 숫자 만 뒤에 오는시길 .</target>
        </trans-unit>
        <trans-unit id="1a882085b42cb0bab19f2ed527e7af342a0ee517" translate="yes" xml:space="preserve">
          <source>A sigil, followed solely by digits matching &lt;code&gt;\p{POSIX_Digit}&lt;/code&gt;, like &lt;code&gt;$0&lt;/code&gt;, &lt;code&gt;$1&lt;/code&gt;, or &lt;code&gt;$10000&lt;/code&gt;.</source>
          <target state="translated">시길 뒤에 &lt;code&gt;$0&lt;/code&gt; , &lt;code&gt;$1&lt;/code&gt; 또는 &lt;code&gt;$10000&lt;/code&gt; 과 같이 &lt;code&gt;\p{POSIX_Digit}&lt;/code&gt; 와 일치하는 숫자 만옵니다 .</target>
        </trans-unit>
        <trans-unit id="e3df970159f7cc9815aae935a27c2abc1cbc161b" translate="yes" xml:space="preserve">
          <source>A sign of 'NaN' is used to represent the result when input arguments are not numbers or as a result of 0/0. '+inf' and '-inf' represent plus respectively minus infinity. You get '+inf' when dividing a positive number by 0, and '-inf' when dividing any negative number by 0.</source>
          <target state="translated">'NaN'부호는 입력 인수가 숫자가 아니거나 0/0의 결과 일 때 결과를 나타내는 데 사용됩니다. '+ inf'및 '-inf'는 각각 플러스 마이너스 무한대를 나타냅니다. 양수를 0으로 나눌 때 '+ inf'를, 음수를 0으로 나눌 때 '-inf'를 얻습니다.</target>
        </trans-unit>
        <trans-unit id="c803de64703554f9c3355b0bb0b711df0025cdae" translate="yes" xml:space="preserve">
          <source>A sign of 'NaN' is used to represent the result when input arguments are not numbers or as a result of 0/0. '+inf' and '-inf' represent plus respectively minus infinity. You will get '+inf' when dividing a positive number by 0, and '-inf' when dividing any negative number by 0.</source>
          <target state="translated">'NaN'의 부호는 입력 인수가 숫자가 아니거나 0/0의 결과 인 경우 결과를 나타내는 데 사용됩니다. '+ inf'및 '-inf'는 플러스 마이너스 무한대를 나타냅니다. 양수를 0으로 나누면 '+ inf', 음수를 0으로 나누면 '-inf'가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="acfa2fff17c2c760f059166beff68ca97cf27024" translate="yes" xml:space="preserve">
          <source>A signature may be entirely empty, in which case all it does is check that the caller passed no arguments:</source>
          <target state="translated">서명이 완전히 비어있을 수 있습니다.이 경우 호출자가 인수를 전달하지 않았는지 확인하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="31a0e78fd112747fd282a616f307965e9e97ecc5" translate="yes" xml:space="preserve">
          <source>A signature parameter must start with '$', '@' or '%'</source>
          <target state="translated">서명 매개 변수는 '$', '@'또는 '%'로 시작해야합니다.</target>
        </trans-unit>
        <trans-unit id="a3b7bfaadf566cb42bb060b59ab39877bdce37fb" translate="yes" xml:space="preserve">
          <source>A signed integer. This is cast to the required integer type when passed to C and converted to an IV when passed back to Perl.</source>
          <target state="translated">부호있는 정수 이것은 C로 전달 될 때 필요한 정수 유형으로 캐스트되고 Perl로 다시 전달 될 때 IV로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="1575087c19c9eb3e9ca21e23f5fecff11363ecdb" translate="yes" xml:space="preserve">
          <source>A signed integer. This typemap converts the Perl value to a native integer type (the &lt;code&gt;&lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt;&lt;/code&gt; type on the current platform). When returning the value to perl it is processed in the same way as for T_IV.</source>
          <target state="translated">부호있는 정수 이 유형 맵은 Perl 값을 기본 정수 유형 ( 현재 플랫폼 의 &lt;code&gt;&lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt;&lt;/code&gt; 유형)으로 변환합니다. perl에 값을 리턴 할 때 T_IV와 동일한 방식으로 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="f69f9b6922b305d309dd50acaf19b40451a94ff0" translate="yes" xml:space="preserve">
          <source>A signed integer. This typemap converts the Perl value to a native integer type (the &lt;code&gt;int&lt;/code&gt; type on the current platform). When returning the value to perl it is processed in the same way as for T_IV.</source>
          <target state="translated">부호있는 정수. 이 타입 맵은 Perl 값을 기본 정수 유형 ( 현재 플랫폼 의 &lt;code&gt;int&lt;/code&gt; 유형)으로 변환합니다. 값을 perl로 반환하면 T_IV와 동일한 방식으로 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="9a6e260265e056207c62a15cda251b7b04ab7de2" translate="yes" xml:space="preserve">
          <source>A significant number of the bug reports we get turn out to be documented features in Perl. Make sure the issue you've run into isn't intentional by glancing through the documentation that comes with the Perl distribution.</source>
          <target state="translated">우리가 얻는 많은 버그 보고서는 Perl에 문서화 된 기능으로 밝혀졌습니다. Perl 배포판과 함께 제공되는 설명서를 통해 문제가 의도하지 않은지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="80837079263cda7d0c48b62c5a2b8e0aa29ed989" translate="yes" xml:space="preserve">
          <source>A similar but more subtle problem is illustrated with this code:</source>
          <target state="translated">이 코드에는 비슷하지만 더 미묘한 문제가 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="81ab11bae0fce0f2612a231d95d1eecf127ccce2" translate="yes" xml:space="preserve">
          <source>A similar effect applies to</source>
          <target state="translated">비슷한 효과가 적용됩니다</target>
        </trans-unit>
        <trans-unit id="a23425aa80f51fe5db313d5664fb7ac8f4d286d0" translate="yes" xml:space="preserve">
          <source>A similar strategy would work for wildcard expansion via &lt;code&gt;&lt;a href=&quot;functions/glob&quot;&gt;glob&lt;/a&gt;&lt;/code&gt;, although you can use &lt;code&gt;&lt;a href=&quot;functions/readdir&quot;&gt;readdir&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/readdir&quot;&gt;readdir&lt;/a&gt;&lt;/code&gt; 을 대신 사용할 수 있지만 &lt;code&gt;&lt;a href=&quot;functions/glob&quot;&gt;glob&lt;/a&gt;&lt;/code&gt; 를 통한 와일드 카드 확장에 대해서도 비슷한 전략이 적용 됩니다.</target>
        </trans-unit>
        <trans-unit id="676cee5371668926c1dabdcd2aa4d10e661b2ca7" translate="yes" xml:space="preserve">
          <source>A similar strategy would work for wildcard expansion via &lt;code&gt;glob&lt;/code&gt;, although you can use &lt;code&gt;readdir&lt;/code&gt; instead.</source>
          <target state="translated">유사한 전략이 &lt;code&gt;glob&lt;/code&gt; 을 통한 와일드 카드 확장에 대해 작동 하지만 대신 &lt;code&gt;readdir&lt;/code&gt; 을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="eb1349e3e7bc2ad99052d135eb76b4bea7da2dc2" translate="yes" xml:space="preserve">
          <source>A similar task is to find words consisting of two identical parts:</source>
          <target state="translated">비슷한 작업은 두 개의 동일한 부분으로 구성된 단어를 찾는 것입니다.</target>
        </trans-unit>
        <trans-unit id="ee2213ceffd8c1f2a6f17c3aee8ab7cdf3d4092c" translate="yes" xml:space="preserve">
          <source>A similar trick involves the</source>
          <target state="translated">비슷한 트릭은</target>
        </trans-unit>
        <trans-unit id="8848997a2920d88084bbf780cebe39466ec879ee" translate="yes" xml:space="preserve">
          <source>A simple API to convert seconds to other date values</source>
          <target state="translated">초를 다른 날짜 값으로 변환하는 간단한 API</target>
        </trans-unit>
        <trans-unit id="c123404763bd10d42cf8e7c2eaf59ecc97ce202f" translate="yes" xml:space="preserve">
          <source>A simple boolean indicating if the command executed without errors or not.</source>
          <target state="translated">명령이 오류없이 실행되었는지 여부를 나타내는 간단한 부울입니다.</target>
        </trans-unit>
        <trans-unit id="5bd4089058361e948e8b28ab1128c297a0f82d9e" translate="yes" xml:space="preserve">
          <source>A simple call to &lt;code&gt;isnt()&lt;/code&gt; usually does not provide a strong test but there are cases when you cannot say much more about a value than that it is different from some other value:</source>
          <target state="translated">&lt;code&gt;isnt()&lt;/code&gt; 대한 간단한 호출은 일반적으로 강력한 테스트를 제공하지 않지만 다른 값과 다른 값보다 더 많은 값을 말할 수없는 경우가 있습니다.</target>
        </trans-unit>
        <trans-unit id="4fbcc760723f31ac561f9cef482138111eb6931b" translate="yes" xml:space="preserve">
          <source>A simple checking routine, which will return true if &lt;code&gt;Archive::Tar&lt;/code&gt; is able to uncompress compressed archives on the fly with &lt;code&gt;IO::Zlib&lt;/code&gt; and &lt;code&gt;IO::Compress::Bzip2&lt;/code&gt; or false if not both are installed.</source>
          <target state="translated">간단한 검사 루틴 &lt;code&gt;Archive::Tar&lt;/code&gt; 가 &lt;code&gt;IO::Zlib&lt;/code&gt; 및 &lt;code&gt;IO::Compress::Bzip2&lt;/code&gt; 를 사용하여 압축 된 아카이브를 압축 해제 할 수있는 경우 true를 리턴 하고 둘 다 설치되지 않은 경우 false 를 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="10951c632f33a4f0fc994717dc96bab5fd305add" translate="yes" xml:space="preserve">
          <source>A simple checking routine, which will return true if &lt;code&gt;Archive::Tar&lt;/code&gt; is able to uncompress compressed archives on the fly with &lt;code&gt;IO::Zlib&lt;/code&gt;, &lt;code&gt;IO::Compress::Bzip2&lt;/code&gt; and &lt;code&gt;IO::Compress::Xz&lt;/code&gt; or false if not both are installed.</source>
          <target state="translated">&lt;code&gt;Archive::Tar&lt;/code&gt; 가 &lt;code&gt;IO::Zlib&lt;/code&gt; , &lt;code&gt;IO::Compress::Bzip2&lt;/code&gt; 및 &lt;code&gt;IO::Compress::Xz&lt;/code&gt; 를 사용하여 압축 된 아카이브를 즉시 압축 해제 할 수있는 경우 true를 반환 하고 둘 다 그렇지 않은 경우 false 를 반환하는 간단한 검사 루틴 설치되었습니다.</target>
        </trans-unit>
        <trans-unit id="afc5b3faec4a3f9f01b28a9e7d12132d66ab6e1d" translate="yes" xml:space="preserve">
          <source>A simple listing of all the files in your distribution.</source>
          <target state="translated">배포판에있는 모든 파일의 간단한 목록입니다.</target>
        </trans-unit>
        <trans-unit id="372959c464065982896bbbe2c2818eb6cad5f8a5" translate="yes" xml:space="preserve">
          <source>A simple mapping of the op type number to its type (like 'COP' or 'BINOP').</source>
          <target state="translated">연산 유형 번호를 해당 유형에 간단히 매핑 (예 : 'COP'또는 'BINOP').</target>
        </trans-unit>
        <trans-unit id="d472680931a17874166dba160d7f69e6352eb56b" translate="yes" xml:space="preserve">
          <source>A simple read-only accessor simply gets the value of a single attribute:</source>
          <target state="translated">간단한 읽기 전용 접근자는 단순히 단일 속성의 값을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="681ff201b3498a43f7a62245e78650fd37d86b77" translate="yes" xml:space="preserve">
          <source>A simple scalar number</source>
          <target state="translated">간단한 스칼라 숫자</target>
        </trans-unit>
        <trans-unit id="1b93dcb8f21d326777ddc52bfa4bdd011dd04c4a" translate="yes" xml:space="preserve">
          <source>A simple scalar string</source>
          <target state="translated">간단한 스칼라 문자열</target>
        </trans-unit>
        <trans-unit id="5776d9f23e070178afac4296b05b65fd1f748404" translate="yes" xml:space="preserve">
          <source>A simple scalar with an extra reference</source>
          <target state="translated">추가 참조가있는 간단한 스칼라</target>
        </trans-unit>
        <trans-unit id="f593aa1a652c40c9b2c700bcf9bdc1dacfbe433a" translate="yes" xml:space="preserve">
          <source>A simple summary of the tests so far. True for pass, false for fail. This is a logical pass/fail, so todos are passes.</source>
          <target state="translated">지금까지 테스트에 대한 간단한 요약. 통과하면 true, 실패하면 false 이것은 논리적 합격 / 불합격이므로 할일은 합격입니다.</target>
        </trans-unit>
        <trans-unit id="e9ed86741cb6e707485ef431b1b242bee25c8fe1" translate="yes" xml:space="preserve">
          <source>A simple, singular value; a number, &lt;b&gt;string&lt;/b&gt;, or &lt;b&gt;reference&lt;/b&gt;.</source>
          <target state="translated">단순하고 특이한 가치; 숫자 &lt;b&gt;스트링&lt;/b&gt; 또는 &lt;b&gt;참조&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="41fbe0f5dde0b71cac36adde6b1e65c7f6388dac" translate="yes" xml:space="preserve">
          <source>A single &lt;code&gt;/x&lt;/code&gt; tells the regular expression parser to ignore most whitespace that is neither backslashed nor within a bracketed character class. You can use this to break up your regular expression into more readable parts. Also, the &lt;code&gt;&quot;#&quot;&lt;/code&gt; character is treated as a metacharacter introducing a comment that runs up to the pattern's closing delimiter, or to the end of the current line if the pattern extends onto the next line. Hence, this is very much like an ordinary Perl code comment. (You can include the closing delimiter within the comment only if you precede it with a backslash, so be careful!)</source>
          <target state="translated">단일 &lt;code&gt;/x&lt;/code&gt; 는 정규식 구문 분석기가 백 슬래시도 아니고 대괄호 문자 클래스도 아닌 대부분의 공백을 무시하도록 지시합니다. 이를 사용하여 정규식을 더 읽기 쉬운 부분으로 나눌 수 있습니다. 또한 &lt;code&gt;&quot;#&quot;&lt;/code&gt; 문자는 패턴의 닫는 구분 기호까지 또는 패턴이 다음 행으로 확장되는 경우 현재 행의 끝까지 실행되는 주석을 소개하는 메타 문자로 처리됩니다. 따라서 이것은 일반적인 Perl 코드 주석과 매우 유사합니다. (주석 앞에 백 슬래시가있는 경우에만 닫는 구분 기호를 포함 할 수 있으므로주의하십시오!)</target>
        </trans-unit>
        <trans-unit id="5a7d12449647b7d47425008bd7d9de56b3bffa22" translate="yes" xml:space="preserve">
          <source>A single character that represents the end of a line, with the ASCII value of 012 octal under Unix (but 015 on a Mac), and represented by &lt;code&gt;\n&lt;/code&gt; in Perl strings. For Windows machines writing text files, and for certain physical devices like terminals, the single newline gets automatically translated by your C library into a line feed and a carriage return, but normally, no translation is done.</source>
          <target state="translated">Unix에서 ASCII 값이 012 8 진수 (Mac에서는 015) 인 행의 끝을 나타내는 단일 문자 이며 Perl 문자열에서 &lt;code&gt;\n&lt;/code&gt; 으로 표시됩니다 . 텍스트 파일을 작성하는 Windows 시스템과 터미널과 같은 특정 물리적 장치의 경우 단일 개행은 C 라이브러리에서 자동으로 줄 바꿈 및 캐리지 리턴으로 변환되지만 일반적으로 변환은 수행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2a1618c928b45217b1ecfab89b72e2f9c62e981a" translate="yes" xml:space="preserve">
          <source>A single entity with various interpretations, like an elephant. To a computer scientist, it&amp;rsquo;s a grammar for a little language in which some strings are legal and others aren&amp;rsquo;t. To normal people, it&amp;rsquo;s a pattern you can use to find what you&amp;rsquo;re looking for when it varies from case to case. Perl&amp;rsquo;s regular expressions are far from regular in the theoretical sense, but in regular use they work quite well. Here&amp;rsquo;s a regular expression: &lt;code&gt;/Oh s.*t./&lt;/code&gt; . This will match strings like &amp;ldquo;&lt;code&gt;Oh &lt;a href=&quot;functions/say&quot;&gt;say&lt;/a&gt; can you see by the dawn's early light&lt;/code&gt; &amp;rdquo; and &amp;ldquo;&lt;code&gt;Oh sit!&lt;/code&gt; &amp;rdquo;. See Camel chapter 5, &amp;ldquo;Pattern Matching&amp;rdquo;.</source>
          <target state="translated">코끼리처럼 다양한 해석이 가능한 단일 개체입니다. 컴퓨터 과학자에게는 일부 문자열이 합법적이고 다른 문자열이 합법적이지 않은 작은 언어에 대한 문법입니다. 정상적인 사람들에게, 그것은 당신이 찾고있는 것이 무엇인지를 찾는 데 사용할 수있는 패턴입니다. Perl의 정규 표현식은 이론적 인 의미에서 정규 표현식과는 거리가 멀지 만 정기적으로 사용하면 상당히 잘 작동합니다. 정규식은 다음과 같습니다. &lt;code&gt;/Oh s.*t./&lt;/code&gt; . 이것은 &quot;와 같은 문자열을 일치 &lt;code&gt;Oh &lt;a href=&quot;functions/say&quot;&gt;say&lt;/a&gt; can you see by the dawn's early light&lt;/code&gt; &quot;와 &quot; &lt;code&gt;Oh sit!&lt;/code&gt; &amp;rdquo;. 낙타 5 장 &quot;패턴 일치&quot;를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="bd9d52f50401e07be14bc39be94bfc90b5fed1b7" translate="yes" xml:space="preserve">
          <source>A single entity with various interpretations, like an elephant. To a computer scientist, it&amp;rsquo;s a grammar for a little language in which some strings are legal and others aren&amp;rsquo;t. To normal people, it&amp;rsquo;s a pattern you can use to find what you&amp;rsquo;re looking for when it varies from case to case. Perl&amp;rsquo;s regular expressions are far from regular in the theoretical sense, but in regular use they work quite well. Here&amp;rsquo;s a regular expression: &lt;code&gt;/Oh s.*t./&lt;/code&gt;. This will match strings like &amp;ldquo;&lt;code&gt;Oh say can you see by the dawn's early light&lt;/code&gt;&amp;rdquo; and &amp;ldquo;&lt;code&gt;Oh sit!&lt;/code&gt;&amp;rdquo;. See Camel chapter 5, &amp;ldquo;Pattern Matching&amp;rdquo;.</source>
          <target state="translated">코끼리처럼 다양한 해석을 가진 단일 개체. 컴퓨터 과학자에게 이것은 일부 문자열은 합법적이고 다른 문자열은 그렇지 않은 작은 언어에 대한 문법입니다. 평범한 사람들에게는 케이스마다 다를 때 원하는 것을 찾는 데 사용할 수있는 패턴입니다. Perl의 정규식은 이론적 의미에서 정규식과는 거리가 멀지 만 정규적으로 사용하면 꽤 잘 작동합니다. 다음은 정규식입니다. &lt;code&gt;/Oh s.*t./&lt;/code&gt; . &quot; &lt;code&gt;Oh say can you see by the dawn's early light&lt;/code&gt; &lt;code&gt;Oh sit!&lt;/code&gt; &quot;및 &quot; 오 앉아! &quot;와 같은 문자열과 일치합니다 . &amp;rdquo;. Camel 5 장, &quot;패턴 일치&quot;를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="f0c7b2b0b88a0fcb03de95938de74348bdc84aea" translate="yes" xml:space="preserve">
          <source>A single flag bit associated with this message, in a &lt;code&gt;SVuv&lt;/code&gt;. The bit corresponds to some bit in the &lt;code&gt;*errors&lt;/code&gt; return value, such as &lt;code&gt;UNICODE_GOT_SURROGATE&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;SVuv&lt;/code&gt; 에서이 메시지와 관련된 단일 플래그 비트 입니다. 이 비트 는 &lt;code&gt;UNICODE_GOT_SURROGATE&lt;/code&gt; 와 같은 &lt;code&gt;*errors&lt;/code&gt; 반환 값 의 일부 비트에 해당합니다 .</target>
        </trans-unit>
        <trans-unit id="823574b7a9a841c68fa3382fefc5234c4a20c603" translate="yes" xml:space="preserve">
          <source>A single flag bit associated with this message, in a &lt;code&gt;SVuv&lt;/code&gt;. The bit corresponds to some bit in the &lt;code&gt;*errors&lt;/code&gt; return value, such as &lt;code&gt;UTF8_GOT_LONG&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;SVuv&lt;/code&gt; 에서이 메시지와 관련된 단일 플래그 비트 입니다. 비트는 &lt;code&gt;*errors&lt;/code&gt; 반환 값 의 일부 비트에 해당 합니다 (예 : &lt;code&gt;UTF8_GOT_LONG&lt;/code&gt; ) .</target>
        </trans-unit>
        <trans-unit id="829152f3dcb1ed16bfc3e8ca36bfa63ebf05d7eb" translate="yes" xml:space="preserve">
          <source>A single hexadecimal number denoting a code point to include.</source>
          <target state="translated">포함 할 코드 포인트를 나타내는 단일 16 진수입니다.</target>
        </trans-unit>
        <trans-unit id="27a4bf6aaf65d7e6150de844a569f0f9a5f667a4" translate="yes" xml:space="preserve">
          <source>A single piece of numeric or string data that is part of a longer &lt;b&gt;string&lt;/b&gt;, &lt;b&gt;record&lt;/b&gt;, or &lt;b&gt;line&lt;/b&gt;. Variable-width fields are usually split up by &lt;b&gt;separators&lt;/b&gt; (so use &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; to extract the fields), while fixed-width fields are usually at fixed positions (so use &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt;). &lt;b&gt;Instance variables&lt;/b&gt; are also known as &amp;ldquo;fields&amp;rdquo;.</source>
          <target state="translated">더 긴 &lt;b&gt;문자열&lt;/b&gt; , &lt;b&gt;레코드&lt;/b&gt; 또는 &lt;b&gt;행의&lt;/b&gt; 일부인 단일 숫자 또는 문자열 데이터입니다 . 가변 너비 필드는 일반적으로 &lt;b&gt;구분 기호로 &lt;/b&gt; &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; 되므로 필드를 추출 하려면 split 을 사용하십시오. 반면 고정 너비 필드는 일반적으로 고정 위치에 있습니다 ( &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; 사용 ). &lt;b&gt;인스턴스 변수&lt;/b&gt; 는 &quot;필드&quot;라고도합니다.</target>
        </trans-unit>
        <trans-unit id="9c9a04c7fe7162d287f0a6bf5101410d1b801612" translate="yes" xml:space="preserve">
          <source>A single piece of numeric or string data that is part of a longer &lt;b&gt;string&lt;/b&gt;, &lt;b&gt;record&lt;/b&gt;, or &lt;b&gt;line&lt;/b&gt;. Variable-width fields are usually split up by &lt;b&gt;separators&lt;/b&gt; (so use &lt;code&gt;split&lt;/code&gt; to extract the fields), while fixed-width fields are usually at fixed positions (so use &lt;code&gt;unpack&lt;/code&gt;). &lt;b&gt;Instance variables&lt;/b&gt; are also known as &amp;ldquo;fields&amp;rdquo;.</source>
          <target state="translated">긴 &lt;b&gt;문자열&lt;/b&gt; , &lt;b&gt;레코드&lt;/b&gt; 또는 &lt;b&gt;행의&lt;/b&gt; 일부인 단일 숫자 또는 문자열 데이터 . 가변 너비 필드는 일반적으로 &lt;b&gt;구분 기호로&lt;/b&gt; 분할되며 (따라서 &lt;code&gt;split&lt;/code&gt; 을 사용하여 필드를 추출) 고정 너비 필드는 일반적으로 고정 위치에 있습니다 (따라서 &lt;code&gt;unpack&lt;/code&gt; 사용 ). &lt;b&gt;인스턴스 변수&lt;/b&gt; 는 &quot;필드&quot;라고도합니다.</target>
        </trans-unit>
        <trans-unit id="3ff4db73bde7c1d7cfd3e2062dd1951912b9e366" translate="yes" xml:space="preserve">
          <source>A single symbol abbreviating the class of the OP.</source>
          <target state="translated">OP 클래스를 약칭하는 단일 기호.</target>
        </trans-unit>
        <trans-unit id="ed641668fea177eedad336e7089851d18b828e16" translate="yes" xml:space="preserve">
          <source>A single testing job.</source>
          <target state="translated">단일 테스트 작업.</target>
        </trans-unit>
        <trans-unit id="41bf4051bfbbef3d6c2986f2065087b05c2359b5" translate="yes" xml:space="preserve">
          <source>A single-quoted, literal string. A backslash represents a backslash unless followed by the delimiter or another backslash, in which case the delimiter or backslash is interpolated.</source>
          <target state="translated">작은 따옴표로 묶인 리터럴 문자열. 백 슬래시는 분리 문자 나 다른 백 슬래시가 뒤 따르지 않는 한 백 슬래시를 나타냅니다.이 경우 분리 문자 나 백 슬래시는 보간됩니다.</target>
        </trans-unit>
        <trans-unit id="8add36465a616cf6d47e4a5aef01fb690927c1f3" translate="yes" xml:space="preserve">
          <source>A slice accesses several elements of a list, an array, or a hash simultaneously using a list of subscripts. It's more convenient than writing out the individual elements as a list of separate scalar values.</source>
          <target state="translated">슬라이스는 아래 첨자 목록을 사용하여 목록, 배열 또는 해시의 여러 요소에 동시에 액세스합니다. 개별 요소를 별도의 스칼라 값 목록으로 작성하는 것보다 편리합니다.</target>
        </trans-unit>
        <trans-unit id="7f8a4967d94ac75566470d147a5f123047048bbb" translate="yes" xml:space="preserve">
          <source>A slight modification also removes C++ comments, possibly spanning multiple lines using a continuation character:</source>
          <target state="translated">약간만 수정하면 C ++ 주석이 제거되어 연속 문자를 사용하여 여러 줄에 걸쳐있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e99cb7094afcbc76a76c4efa1f4eefdffe5bff51" translate="yes" xml:space="preserve">
          <source>A slightly larger piece of code will provide something on which a profiler can produce more extensive reporting statistics. This example uses the simplistic &lt;code&gt;wordmatch&lt;/code&gt; program which parses a given input file and spews out a short report on the contents.</source>
          <target state="translated">약간 더 큰 코드는 프로파일 러가보다 광범위한보고 통계를 생성 할 수있는 무언가를 제공합니다. 이 예에서는 주어진 입력 파일을 구문 분석하고 내용에 대한 간단한 보고서를 생성하는 간단한 &lt;code&gt;wordmatch&lt;/code&gt; 프로그램을 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="03934c7f98da92e385e9ea42d12c3ed3bec3632f" translate="yes" xml:space="preserve">
          <source>A slurpy hash parameter may be nameless just like other kinds of parameter. It still insists that the number of arguments available to it be even, even though they're not being put into a variable.</source>
          <target state="translated">슬러 피 해시 파라미터는 다른 종류의 파라미터와 마찬가지로 이름이 없을 수 있습니다. 변수에 넣지 않아도 사용할 수있는 인수의 수는 여전히 균등하다고 주장합니다.</target>
        </trans-unit>
        <trans-unit id="30988eefa9eacb81270153c8608fad35b31b7f98" translate="yes" xml:space="preserve">
          <source>A slurpy parameter may instead be a hash, in which case the arguments available to it are interpreted as alternating keys and values. There must be as many keys as values: if there is an odd argument then an exception will be thrown. Keys will be stringified, and if there are duplicates then the later instance takes precedence over the earlier, as with standard hash construction.</source>
          <target state="translated">slurpy 매개 변수는 대신 해시 일 수 있으며,이 경우 사용 가능한 인수는 대체 키와 값으로 해석됩니다. 값만큼의 키가 있어야합니다. 홀수 인수가 있으면 예외가 발생합니다. 키가 문자열 화되고 중복이있는 경우 표준 해시 구성에서와 같이 이후 인스턴스가 이전 인스턴스보다 우선합니다.</target>
        </trans-unit>
        <trans-unit id="7ae153b0845a4f9cd82e184d9134e9263fb0358d" translate="yes" xml:space="preserve">
          <source>A slurpy parameter may not have a default value</source>
          <target state="translated">불분명 한 매개 변수에는 기본값이 없을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="76d8ab783e8ae2210ac2fb7506feb3637ad91b4b" translate="yes" xml:space="preserve">
          <source>A slurpy parameter, either array or hash, must be the last thing in the signature. It may follow mandatory and optional positional parameters; it may also be the only thing in the signature. Slurpy parameters cannot have default values: if no arguments are supplied for them then you get an empty array or empty hash.</source>
          <target state="translated">시그니처의 마지막 항목은 배열 또는 해시 중 하나입니다. 필수 및 선택적 위치 매개 변수를 따를 수 있습니다. 서명에서 유일한 것일 수도 있습니다. Slurpy 매개 변수는 기본값을 가질 수 없습니다. 인수가 제공되지 않으면 빈 배열 또는 빈 해시를 얻습니다.</target>
        </trans-unit>
        <trans-unit id="c7ed55a78ba712132c2ae6c86e583e8efc503821" translate="yes" xml:space="preserve">
          <source>A small example demonstrating SysV message queues:</source>
          <target state="translated">SysV 메시지 큐를 보여주는 작은 예 :</target>
        </trans-unit>
        <trans-unit id="15bb640f66c323688300cc265de617018ed0c375" translate="yes" xml:space="preserve">
          <source>A small script which yields the problem will probably be of help. It would also be useful if this script was run with the extra options &lt;code&gt;Debug =&amp;gt; 1&lt;/code&gt; passed to the constructor, and the output sent with the bug report. If you cannot include a small script then please include a Debug trace from a run of your program which does yield the problem.</source>
          <target state="translated">문제를 일으키는 작은 스크립트가 도움이 될 것입니다. 이 스크립트가 생성자에 전달 된 추가 옵션 &lt;code&gt;Debug =&amp;gt; 1&lt;/code&gt; 과 함께 실행되고 출력이 버그 보고서와 함께 전송 된 경우에도 유용합니다 . 작은 스크립트를 포함 할 수없는 경우 문제를 일으키는 프로그램 실행의 디버그 추적을 포함하십시오.</target>
        </trans-unit>
        <trans-unit id="b0014acccc6b5556fca51e530830260283cc77d0" translate="yes" xml:space="preserve">
          <source>A small script which yields the problem will probably be of help. It would also be useful if this script was run with the extra options &lt;code&gt;Debug =&lt;/code&gt; 1&amp;gt; passed to the constructor, and the output sent with the bug report. If you cannot include a small script then please include a Debug trace from a run of your program which does yield the problem.</source>
          <target state="translated">문제를 일으키는 작은 스크립트가 도움이 될 것입니다. 이 스크립트가 생성자에게 전달 된 추가 옵션 &lt;code&gt;Debug =&lt;/code&gt; 1&amp;gt; 과 함께 실행되고 출력이 버그 보고서와 함께 전송 된 경우에도 유용합니다 . 작은 스크립트를 포함시킬 수 없으면 프로그램 실행에서 디버그 추적을 포함시켜 문제를 발생 시키십시오.</target>
        </trans-unit>
        <trans-unit id="c165dd6d48bb6848a9c96904378fd915f9518c69" translate="yes" xml:space="preserve">
          <source>A small, simple, correct HTTP/1.1 client</source>
          <target state="translated">작고 간단한 올바른 HTTP / 1.1 클라이언트</target>
        </trans-unit>
        <trans-unit id="27545b929364aeeb83be800c720a5090d4d35630" translate="yes" xml:space="preserve">
          <source>A smart match that uses an explicit &lt;code&gt;~~&lt;/code&gt; operator, such as &lt;code&gt;EXPR ~~ EXPR&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;EXPR ~~ EXPR&lt;/code&gt; 과 같은 명시 적 &lt;code&gt;~~&lt;/code&gt; 연산자 를 사용하는 스마트 일치입니다 .</target>
        </trans-unit>
        <trans-unit id="0b57b94fbdb028a48b1bf7791227cc60c86bb4ce" translate="yes" xml:space="preserve">
          <source>A smart match that uses an explicit &lt;code&gt;~~&lt;/code&gt; operator, such as &lt;code&gt;EXPR ~~ EXPR&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;EXPR ~~ EXPR&lt;/code&gt; 과 같은 명시 적 &lt;code&gt;~~&lt;/code&gt; 연산자 를 사용하는 스마트 일치 .</target>
        </trans-unit>
        <trans-unit id="5ee7049b5826d72a2f103072d053d50784d7d0da" translate="yes" xml:space="preserve">
          <source>A sneaky &lt;code&gt;LC_COLLATE&lt;/code&gt; locale could result in the names of students with &quot;D&quot; grades appearing ahead of those with &quot;A&quot;s.</source>
          <target state="translated">몰래 &lt;code&gt;LC_COLLATE&lt;/code&gt; 로캘로 인해 &quot;D&quot;등급의 학생 이름이 &quot;A&quot;등급의 학생보다 먼저 나타날 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3fa57a01d182c489f4440aa3ceec23094b8bdecb" translate="yes" xml:space="preserve">
          <source>A solution to this and many similar issues is to use the &lt;code&gt;mem&lt;/code&gt;</source>
          <target state="translated">이것과 많은 유사한 문제에 대한 해결책은 &lt;code&gt;mem&lt;/code&gt; 을 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="5bd3117b0bc435a9ddefeeeda5fe0b0754edfcc4" translate="yes" xml:space="preserve">
          <source>A solution to this is to use a library which uses pseudottys to make your program behave more reasonably. This way you don't have to have control over the source code of the program you're using. The &lt;code&gt;Expect&lt;/code&gt; module from CPAN also addresses this kind of thing. This module requires two other modules from CPAN, &lt;code&gt;IO::Pty&lt;/code&gt; and &lt;code&gt;IO::Stty&lt;/code&gt; . It sets up a pseudo terminal to interact with programs that insist on talking to the terminal device driver. If your system is supported, this may be your best bet.</source>
          <target state="translated">이에 대한 해결책은 의사를 사용하여 프로그램을보다 합리적으로 동작시키는 라이브러리를 사용하는 것입니다. 이렇게하면 사용중인 프로그램의 소스 코드를 제어 할 필요가 없습니다. CPAN 의 &lt;code&gt;Expect&lt;/code&gt; 모듈도 이러한 종류의 문제를 해결합니다. 이 모듈에는 CPAN의 다른 두 모듈 인 &lt;code&gt;IO::Pty&lt;/code&gt; 및 &lt;code&gt;IO::Stty&lt;/code&gt; 합니다. 터미널 장치 드라이버와 통신해야하는 프로그램과 상호 작용하도록 의사 터미널을 설정합니다. 시스템이 지원되는 경우 가장 좋은 방법 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8b65901bcbb4cd6d842da55cf32921b07fcc8591" translate="yes" xml:space="preserve">
          <source>A solution to this is to use a library which uses pseudottys to make your program behave more reasonably. This way you don't have to have control over the source code of the program you're using. The &lt;code&gt;Expect&lt;/code&gt; module from CPAN also addresses this kind of thing. This module requires two other modules from CPAN, &lt;code&gt;IO::Pty&lt;/code&gt; and &lt;code&gt;IO::Stty&lt;/code&gt;. It sets up a pseudo terminal to interact with programs that insist on talking to the terminal device driver. If your system is supported, this may be your best bet.</source>
          <target state="translated">이에 대한 해결책은 pseudotty를 사용하는 라이브러리를 사용하여 프로그램이보다 합리적으로 작동하도록하는 것입니다. 이렇게하면 사용중인 프로그램의 소스 코드를 제어 할 필요가 없습니다. CPAN 의 &lt;code&gt;Expect&lt;/code&gt; 모듈은 이러한 종류의 문제도 해결합니다. ㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ 이 모듈에는 CPAN, &lt;code&gt;IO::Pty&lt;/code&gt; 및 &lt;code&gt;IO::Stty&lt;/code&gt; 다른 두 모듈이 필요합니다 . 터미널 장치 드라이버와의 통신을 요구하는 프로그램과 상호 작용하도록 의사 터미널을 설정합니다. 시스템이 지원되는 경우 이것이 최선의 선택 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="34d33fafbade920ec9b14eb3241088b584cc3390" translate="yes" xml:space="preserve">
          <source>A somewhat misleadingly named synonym for &lt;code&gt;UNICODE_WARN_PERL_EXTENDED&lt;/code&gt; is retained for backward compatibility: &lt;code&gt;UNICODE_WARN_ABOVE_31_BIT&lt;/code&gt;. Similarly, &lt;code&gt;UNICODE_DISALLOW_ABOVE_31_BIT&lt;/code&gt; is usable instead of the more accurately named &lt;code&gt;UNICODE_DISALLOW_PERL_EXTENDED&lt;/code&gt;. The names are misleading because on EBCDIC platforms,these flags can apply to code points that actually do fit in 31 bits. The new names accurately describe the situation in all cases.</source>
          <target state="translated">에 대한 다소 오해라는 이름의 동의어 &lt;code&gt;UNICODE_WARN_PERL_EXTENDED&lt;/code&gt; 은 이전 버전과의 호환성을 위해 유지된다 &lt;code&gt;UNICODE_WARN_ABOVE_31_BIT&lt;/code&gt; . 마찬가지로, 더 정확하게 명명 된 &lt;code&gt;UNICODE_DISALLOW_PERL_EXTENDED&lt;/code&gt; 대신 &lt;code&gt;UNICODE_DISALLOW_ABOVE_31_BIT&lt;/code&gt; 를 사용할 수 있습니다. EBCDIC 플랫폼에서이 플래그는 실제로 31 비트에 맞는 코드 포인트에 적용될 수 있기 때문에 이름이 오해의 소지가 있습니다. 새 이름은 모든 경우의 상황을 정확하게 설명합니다.</target>
        </trans-unit>
        <trans-unit id="b41ba2a5e34ef24872cc78663b3c8e0fdb24a9d8" translate="yes" xml:space="preserve">
          <source>A somewhat misleadingly named synonym for &lt;code&gt;UTF8_WARN_PERL_EXTENDED&lt;/code&gt; is retained for backward compatibility: &lt;code&gt;UTF8_WARN_ABOVE_31_BIT&lt;/code&gt;. Similarly, &lt;code&gt;UTF8_DISALLOW_ABOVE_31_BIT&lt;/code&gt; is usable instead of the more accurately named &lt;code&gt;UTF8_DISALLOW_PERL_EXTENDED&lt;/code&gt;. The names are misleading because these flags can apply to code points that actually do fit in 31 bits. This happens on EBCDIC platforms, and sometimes when the &lt;a href=&quot;#UTF8_GOT_LONG&quot;&gt;overlong malformation&lt;/a&gt; is also present. The new names accurately describe the situation in all cases.</source>
          <target state="translated">&lt;code&gt;UTF8_WARN_PERL_EXTENDED&lt;/code&gt; 에 대해 다소 오해의 소지가있는 이름의 동의어 는 이전 버전과의 호환성을 위해 유지됩니다 : &lt;code&gt;UTF8_WARN_ABOVE_31_BIT&lt;/code&gt; . 마찬가지로 &lt;code&gt;UTF8_DISALLOW_ABOVE_31_BIT&lt;/code&gt; 는 더 정확하게 명명 된 &lt;code&gt;UTF8_DISALLOW_PERL_EXTENDED&lt;/code&gt; 대신 사용할 수 있습니다. 이러한 플래그는 실제로 31 비트에 맞는 코드 포인트에 적용될 수 있기 때문에 이름이 잘못된 것입니다. 이것은 EBCDIC 플랫폼에서 발생하며 때로는 &lt;a href=&quot;#UTF8_GOT_LONG&quot;&gt;지나치게 긴 기형&lt;/a&gt; 이 있을 때도 발생합니다 . 새 이름은 모든 경우의 상황을 정확하게 설명합니다.</target>
        </trans-unit>
        <trans-unit id="0b80c1598a0b057abd1403fd2b9a7dc757cff1ce" translate="yes" xml:space="preserve">
          <source>A source filter is a special kind of Perl module that intercepts and modifies a source stream before it reaches the parser. A source filter changes our diagram like this:</source>
          <target state="translated">소스 필터는 파서에 도달하기 전에 소스 스트림을 가로 채고 수정하는 특수한 종류의 Perl 모듈입니다. 소스 필터는 다음과 같이 다이어그램을 변경합니다.</target>
        </trans-unit>
        <trans-unit id="8b0be58db42e648ec049b8d1ddee43ac5d107082" translate="yes" xml:space="preserve">
          <source>A space (or colon) separated list of PerlIO layers. If perl is built to use PerlIO system for IO (the default) these layers affect Perl's IO.</source>
          <target state="translated">공백 (또는 콜론)으로 구분 된 PerlIO 레이어 목록입니다. perl이 IO (기본값)에 PerlIO 시스템을 사용하도록 빌드 된 경우 이러한 계층은 Perl의 IO에 영향을줍니다.</target>
        </trans-unit>
        <trans-unit id="0badf9ed68d3af0c4f3cd1c0a7af9f9020afc01b" translate="yes" xml:space="preserve">
          <source>A special &lt;b&gt;method&lt;/b&gt; that is called when an &lt;b&gt;object&lt;/b&gt; is thinking about &lt;b&gt;destroying&lt;/b&gt; itself. A Perl program&amp;rsquo;s &lt;code&gt;DESTROY&lt;/code&gt; method doesn&amp;rsquo;t do the actual destruction; Perl just &lt;b&gt;triggers&lt;/b&gt; the method in case the &lt;b&gt;class&lt;/b&gt; wants to do any associated cleanup.</source>
          <target state="translated">&lt;b&gt;객체&lt;/b&gt; 가 자신을 &lt;b&gt;파괴&lt;/b&gt; 하려고 생각할 때 호출 되는 특수 &lt;b&gt;메소드&lt;/b&gt; 입니다 . Perl 프로그램의 &lt;code&gt;DESTROY&lt;/code&gt; 메소드는 실제 파괴를 수행하지 않습니다. Perl 은 &lt;b&gt;클래스&lt;/b&gt; 가 연관된 정리를 수행하려는 경우 메소드를 &lt;b&gt;트리거&lt;/b&gt; 합니다 .&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="ef35c437c5c84fa1b46b5dc38d46f6fde11ec243" translate="yes" xml:space="preserve">
          <source>A special case is if the expression is a subroutine reference (in either &lt;code&gt;&lt;a href=&quot;functions/sub&quot;&gt;sub&lt;/a&gt; {...}&lt;/code&gt; syntax or &lt;code&gt;\&amp;amp;foo&lt;/code&gt; syntax). In that case, it is executed and its value (true or false) determines if the test passes or fails. For example,</source>
          <target state="translated">특별한 경우는 표현식이 서브 루틴 참조 인 경우입니다 ( &lt;code&gt;&lt;a href=&quot;functions/sub&quot;&gt;sub&lt;/a&gt; {...}&lt;/code&gt; 구문 또는 &lt;code&gt;\&amp;amp;foo&lt;/code&gt; 구문). 이 경우 테스트가 실행되고 해당 값 (true 또는 false)에 따라 테스트 통과 또는 실패 여부가 결정됩니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="9916746eced8e5680d9be3db4c1b0f01137572d1" translate="yes" xml:space="preserve">
          <source>A special case is if the expression is a subroutine reference (in either &lt;code&gt;sub {...}&lt;/code&gt; syntax or &lt;code&gt;\&amp;amp;foo&lt;/code&gt; syntax). In that case, it is executed and its value (true or false) determines if the test passes or fails. For example,</source>
          <target state="translated">특별한 경우는 표현식이 서브 루틴 참조 ( &lt;code&gt;sub {...}&lt;/code&gt; 구문 또는 &lt;code&gt;\&amp;amp;foo&lt;/code&gt; 구문) 인 경우입니다. 이 경우 실행되고 해당 값 (true 또는 false)이 테스트의 통과 또는 실패 여부를 결정합니다. 예를 들면</target>
        </trans-unit>
        <trans-unit id="4d4bdb3b56feee845f988c80b59a2de393b4d25c" translate="yes" xml:space="preserve">
          <source>A special entry &lt;code&gt;GetOptionsFromString&lt;/code&gt; can be used to parse options from an arbitrary string.</source>
          <target state="translated">특수한 항목 &lt;code&gt;GetOptionsFromString&lt;/code&gt; 을 사용하여 임의의 문자열에서 옵션을 구문 분석 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f5f25c2de52c4c00b53b25ba03c614f087fa031c" translate="yes" xml:space="preserve">
          <source>A special file that contains other files. Some &lt;b&gt;operating systems&lt;/b&gt; call these &amp;ldquo;folders&amp;rdquo;, &amp;ldquo;drawers&amp;rdquo;, &amp;ldquo;catalogues&amp;rdquo;, or &amp;ldquo;catalogs&amp;rdquo;.</source>
          <target state="translated">다른 파일을 포함하는 특수 파일. 일부 &lt;b&gt;운영 체제에서는&lt;/b&gt; 이러한 &quot;폴더&quot;, &quot;서랍&quot;, &quot;카탈로그&quot;또는 &quot;카탈로그&quot;라고합니다.</target>
        </trans-unit>
        <trans-unit id="9d4dee1bf51d9988b7b651c7e34b5ae56c3d23f3" translate="yes" xml:space="preserve">
          <source>A special form is the &lt;code&gt;(DEFINE)&lt;/code&gt; predicate, which never executes its yes-pattern directly, and does not allow a no-pattern. This allows one to define subpatterns which will be executed only by the recursion mechanism. This way, you can define a set of regular expression rules that can be bundled into any pattern you choose.</source>
          <target state="translated">특수 형식은 &lt;code&gt;(DEFINE)&lt;/code&gt; 술어입니다.이 술어는 yes 패턴을 직접 실행하지 않으며 패턴을 허용하지 않습니다. 이를 통해 재귀 메커니즘에 의해서만 실행될 서브 패턴을 정의 할 수 있습니다. 이렇게하면 선택한 패턴에 묶을 수있는 정규식 규칙 집합을 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="098ae82dbb47389fd0f04911d56700422f9e1bbd" translate="yes" xml:space="preserve">
          <source>A special internal spot in which Perl keeps the information about the last &lt;b&gt;file&lt;/b&gt; on which you requested information.</source>
          <target state="translated">Perl이 정보 를 요청한 마지막 &lt;b&gt;파일&lt;/b&gt; 에 대한 정보를 보관하는 특별한 내부 지점입니다 .</target>
        </trans-unit>
        <trans-unit id="79eddc4100fb4306d07fc838a90fb71a102a9485" translate="yes" xml:space="preserve">
          <source>A special kind of &lt;b&gt;module&lt;/b&gt; that does &lt;b&gt;preprocessing&lt;/b&gt; on your script just before it gets to the &lt;b&gt;tokener&lt;/b&gt;.</source>
          <target state="translated">&lt;b&gt;토큰에&lt;/b&gt; 도달하기 직전에 스크립트에서 &lt;b&gt;전처리&lt;/b&gt; 를 수행 하는 특수한 종류의 &lt;b&gt;모듈&lt;/b&gt; .&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="0c845e10d2c5e7d853c713ce339e272a56f03f5c" translate="yes" xml:space="preserve">
          <source>A special kind of &lt;b&gt;scalar context&lt;/b&gt; used in conditionals to decide whether the &lt;b&gt;scalar value&lt;/b&gt; returned by an expression is &lt;b&gt;true&lt;/b&gt; or &lt;b&gt;false&lt;/b&gt;. Does not evaluate as either a string or a number. See &lt;b&gt;context&lt;/b&gt;.</source>
          <target state="translated">표현식에 의해 반환되는 &lt;b&gt;스칼라 값&lt;/b&gt; 이 &lt;b&gt;true&lt;/b&gt; 또는 &lt;b&gt;false&lt;/b&gt; 인지를 결정하기 위해 조건부 &lt;b&gt;에서&lt;/b&gt; 사용되는 특수한 종류의 &lt;b&gt;스칼라 컨텍스트&lt;/b&gt; 입니다. 문자열 또는 숫자로 평가되지 않습니다. &lt;b&gt;context를&lt;/b&gt; 참조하십시오 .&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="89b7b57b006b340679bccefff3860259f11cee5d" translate="yes" xml:space="preserve">
          <source>A special note about fetching files from an ftp uri:</source>
          <target state="translated">ftp uri에서 파일을 가져 오는 것에 대한 특별 참고 사항 :</target>
        </trans-unit>
        <trans-unit id="daa44f44af6529c7f53a78e2c82f295d89b6e71e" translate="yes" xml:space="preserve">
          <source>A special option 'name' &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; can be used to designate a subroutine to handle non-option arguments. When GetOptions() encounters an argument that does not look like an option, it will immediately call this subroutine and passes it one parameter: the argument name.</source>
          <target state="translated">특수 옵션 'name' &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; 을 사용하여 비 옵션 인수를 처리 할 서브 루틴을 지정할 수 있습니다. GetOptions ()가 옵션처럼 보이지 않는 인수를 발견하면 즉시이 서브 루틴을 호출하고 하나의 매개 변수 인 인수 이름을 전달합니다.</target>
        </trans-unit>
        <trans-unit id="2a568b09a052a4fda0da31a9dd45e8de43daae28" translate="yes" xml:space="preserve">
          <source>A special option 'name' &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; can be used to designate a subroutine to handle non-option arguments. When GetOptions() encounters an argument that does not look like an option, it will immediately call this subroutine and passes it one parameter: the argument name. Well, actually it is an object that stringifies to the argument name.</source>
          <target state="translated">특수 옵션 'name' &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; 을 사용하여 비 옵션 인수를 처리 할 서브 루틴을 지정할 수 있습니다. GetOptions ()가 옵션처럼 보이지 않는 인수를 발견하면 즉시이 서브 루틴을 호출하고 인수 이름이라는 매개 변수를 전달합니다. 사실, 그것은 인수 이름으로 문자열을 만드는 객체입니다.</target>
        </trans-unit>
        <trans-unit id="9bb864d2ebf5f6403ee2f29fbe30d0ca7cb3bbfc" translate="yes" xml:space="preserve">
          <source>A special program that runs on the bare machine and hides the gory details of managing &lt;b&gt;processes&lt;/b&gt; and &lt;b&gt;devices&lt;/b&gt;. Usually used in a looser sense to indicate a particular culture of programming. The loose sense can be used at varying levels of specificity. At one extreme, you might say that all versions of Unix and Unix-lookalikes are the same operating system (upsetting many people, especially lawyers and other advocates). At the other extreme, you could say this particular version of this particular vendor&amp;rsquo;s operating system is different from any other version of this or any other vendor&amp;rsquo;s operating system. Perl is much more portable across operating systems than many other languages. See also &lt;b&gt;architecture&lt;/b&gt; and &lt;b&gt;platform&lt;/b&gt;.</source>
          <target state="translated">베어 시스템에서 실행되고 &lt;b&gt;프로세스&lt;/b&gt; 및 &lt;b&gt;장치&lt;/b&gt; 관리에 대한 까다로운 세부 사항을 숨기는 특수 프로그램입니다 . 일반적으로 특정 프로그래밍 문화를 나타 내기 위해 느슨한 의미로 사용됩니다. 느슨한 감각은 다양한 수준의 특이성에서 사용될 수 있습니다. 극단적으로, 모든 버전의 Unix와 Unix-lookalikes가 같은 운영 체제라고 말할 수 있습니다 (많은 사람들, 특히 변호사와 다른 옹호자들을 화나게합니다). 다른 극단적 인 경우,이 특정 공급 업체 운영 체제의 특정 버전이이 버전 또는 다른 공급 업체 운영 체제의 다른 버전과 다르다고 말할 수 있습니다. Perl은 다른 많은 언어보다 운영 체제에서 훨씬 이식성이 뛰어납니다. &lt;b&gt;아키텍처&lt;/b&gt; 및 &lt;b&gt;플랫폼&lt;/b&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b03867324ba36517f3a9d0e823f68ebcc5db216b" translate="yes" xml:space="preserve">
          <source>A special programming gizmo that keeps track of where you are in something that you&amp;rsquo;re trying to iterate over. The &lt;code&gt;foreach&lt;/code&gt; loop in Perl contains an iterator; so does a hash, allowing you to &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; through it.</source>
          <target state="translated">반복하려는 무언가의 위치를 ​​추적하는 특수 프로그래밍 기즈모입니다. Perl 의 &lt;code&gt;foreach&lt;/code&gt; 루프에는 반복자가 포함되어 있습니다. 그래서 당신을 수 있도록 해시를 수행 &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; 그것을 통해.</target>
        </trans-unit>
        <trans-unit id="ee10f3c342b9f05f366b2abdcd5237c7367d7d5d" translate="yes" xml:space="preserve">
          <source>A special programming gizmo that keeps track of where you are in something that you&amp;rsquo;re trying to iterate over. The &lt;code&gt;foreach&lt;/code&gt; loop in Perl contains an iterator; so does a hash, allowing you to &lt;code&gt;each&lt;/code&gt; through it.</source>
          <target state="translated">반복하려는 무언가에서 현재 위치를 추적하는 특수 프로그래밍 기즈모입니다. Perl 의 &lt;code&gt;foreach&lt;/code&gt; 루프에는 반복기가 포함되어 있습니다. 해시도 마찬가지 입니다. &lt;code&gt;each&lt;/code&gt; 통과 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cb2ae230ab87141b90e09da012ca49eb173d1f62" translate="yes" xml:space="preserve">
          <source>A special thanks to Damian Conway, who didn't only suggest important changes, but also took the time to count the number of listed features and make a Perl 6 version to show that Perl will stay Perl.</source>
          <target state="translated">중요한 변경 사항을 제안 할뿐만 아니라 나열된 기능의 수를 세고 Perl 6 버전을 만들어 Perl이 Perl을 유지한다는 것을 보여 주었던 Damian Conway에게 특별한 감사를드립니다.</target>
        </trans-unit>
        <trans-unit id="ba47d8229178e976b4e17fac8c50f7480fa0cd1c" translate="yes" xml:space="preserve">
          <source>A special thanks to Damian Conway, who didn't only suggest important changes, but also took the time to count the number of listed features and make a Raku version to show that Perl will stay Perl.</source>
          <target state="translated">중요한 변경 사항을 제안했을뿐만 아니라 나열된 기능의 수를 세고 Perl이 Perl을 유지한다는 것을 보여주는 Raku 버전을 만드는 데 시간을 할애 한 Damian Conway에게 특별한 감사를드립니다.</target>
        </trans-unit>
        <trans-unit id="dbd3a98639e4de23b8ab5b1ce7e392825e327157" translate="yes" xml:space="preserve">
          <source>A special token that compiles to the current line number.</source>
          <target state="translated">현재 줄 번호로 컴파일되는 특수 토큰.</target>
        </trans-unit>
        <trans-unit id="44f4cd0691d6b1f249950031c94d5eba6a8b7ab3" translate="yes" xml:space="preserve">
          <source>A special token that compiles to the current line number. It can be altered by the mechanism described at &lt;a href=&quot;perlsyn#Plain-Old-Comments-%28Not%21%29&quot;&gt;&quot;Plain Old Comments (Not!)&quot; in perlsyn&lt;/a&gt;.</source>
          <target state="translated">현재 줄 번호로 컴파일되는 특수 토큰입니다. &lt;a href=&quot;perlsyn#Plain-Old-Comments-%28Not%21%29&quot;&gt;perlsyn의 &quot;Plain Old Comments (Not!)&quot;에&lt;/a&gt; 설명 된 메커니즘으로 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b3a5128be0078d880657071bac7267720f138c1c" translate="yes" xml:space="preserve">
          <source>A special token that returns a reference to the current subroutine, or &lt;a href=&quot;#undef-EXPR&quot;&gt;&lt;code&gt;undef&lt;/code&gt;&lt;/a&gt; outside of a subroutine.</source>
          <target state="translated">현재 서브 루틴에 대한 참조를 리턴하거나 서브 루틴 외부의 &lt;a href=&quot;#undef-EXPR&quot;&gt; &lt;code&gt;undef&lt;/code&gt; &lt;/a&gt; 를 리턴하는 특수 토큰입니다 .</target>
        </trans-unit>
        <trans-unit id="f8db7e23c364c11a426f9d30c1e28cd4da6326e7" translate="yes" xml:space="preserve">
          <source>A special token that returns a reference to the current subroutine, or &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; outside of a subroutine.</source>
          <target state="translated">현재 서브 루틴에 대한 참조를 반환하거나 서브 루틴 외부에서 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 를 지정 하는 특수 토큰 .</target>
        </trans-unit>
        <trans-unit id="d6eea162b97cdf5937cc80c12d97f68b73850c69" translate="yes" xml:space="preserve">
          <source>A special token that returns a reference to the current subroutine, or &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; outside of a subroutine.</source>
          <target state="translated">현재 서브 루틴에 대한 참조를 반환하거나 서브 루틴 외부에서 &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 를 지정 하는 특수 토큰 .</target>
        </trans-unit>
        <trans-unit id="2c26f3ebdbb02dd6bf3cbae9d5ef0c2e36ca2b14" translate="yes" xml:space="preserve">
          <source>A special token that returns the name of the file in which it occurs.</source>
          <target state="translated">발생하는 파일의 이름을 반환하는 특수 토큰.</target>
        </trans-unit>
        <trans-unit id="4d534cc3d24e8095df0fd43eb483a4f531a852ee" translate="yes" xml:space="preserve">
          <source>A special token that returns the name of the file in which it occurs. It can be altered by the mechanism described at &lt;a href=&quot;perlsyn#Plain-Old-Comments-%28Not%21%29&quot;&gt;&quot;Plain Old Comments (Not!)&quot; in perlsyn&lt;/a&gt;.</source>
          <target state="translated">발생하는 파일의 이름을 반환하는 특수 토큰입니다. &lt;a href=&quot;perlsyn#Plain-Old-Comments-%28Not%21%29&quot;&gt;perlsyn의 &quot;Plain Old Comments (Not!)&quot;에&lt;/a&gt; 설명 된 메커니즘으로 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="48496bf275cb62c80b11546a66125c1e011d6e73" translate="yes" xml:space="preserve">
          <source>A special token that returns the name of the package in which it occurs.</source>
          <target state="translated">발생하는 패키지의 이름을 반환하는 특수 토큰.</target>
        </trans-unit>
        <trans-unit id="07395fd97ce6a28d8015ab2eaad3eae19ab86b6e" translate="yes" xml:space="preserve">
          <source>A specialised variant of &lt;code&gt;croak()&lt;/code&gt; for emitting the usage message for xsubs</source>
          <target state="translated">xsub에 대한 사용법 메시지를 출력하기위한 &lt;code&gt;croak()&lt;/code&gt; 의 특수 변형</target>
        </trans-unit>
        <trans-unit id="bc379211e591381ed14a5306c8c0734c9a94f69f" translate="yes" xml:space="preserve">
          <source>A specialised version of &lt;a href=&quot;#newHVhv&quot;&gt;&quot;newHVhv&quot;&lt;/a&gt; for copying &lt;code&gt;%^H&lt;/code&gt;. &lt;code&gt;ohv&lt;/code&gt; must be a pointer to a hash (which may have &lt;code&gt;%^H&lt;/code&gt; magic, but should be generally non-magical), or &lt;code&gt;NULL&lt;/code&gt; (interpreted as an empty hash). The content of &lt;code&gt;ohv&lt;/code&gt; is copied to a new hash, which has the &lt;code&gt;%^H&lt;/code&gt;-specific magic added to it. A pointer to the new hash is returned.</source>
          <target state="translated">&lt;code&gt;%^H&lt;/code&gt; 복사를위한 &lt;a href=&quot;#newHVhv&quot;&gt;&quot;newHVhv&quot;&lt;/a&gt; 의 특수 버전입니다 . &lt;code&gt;ohv&lt;/code&gt; 는 해시에 대한 포인터 ( &lt;code&gt;%^H&lt;/code&gt; 마법이있을 수 있지만 일반적으로 마 법적이지 않아야 함) 또는 &lt;code&gt;NULL&lt;/code&gt; (빈 해시로 해석 됨 )이어야합니다 . &lt;code&gt;ohv&lt;/code&gt; 의 내용은 &lt;code&gt;%^H&lt;/code&gt; 특정 마법이 추가 된 새 해시로 복사됩니다 . 새 해시에 대한 포인터가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="89a1130f5dbd32f8addbfbf8cc52dc9647058465" translate="yes" xml:space="preserve">
          <source>A specialised version of &lt;a href=&quot;#newHVhv&quot;&gt;newHVhv&lt;/a&gt; for copying &lt;code&gt;%^H&lt;/code&gt; .</source>
          <target state="translated">의 전문 버전 &lt;a href=&quot;#newHVhv&quot;&gt;newHVhv&lt;/a&gt; 복사하는 &lt;code&gt;%^H&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8e58efa1c2b3f0ec95f611bcd359aa9037253ccf" translate="yes" xml:space="preserve">
          <source>A specification of how many spaces and digits and things to put somewhere so that whatever you&amp;rsquo;re printing comes out nice and pretty.</source>
          <target state="translated">인쇄하는 모든 것이 멋지고 예쁘게 나올 수 있도록 몇 개의 공백과 숫자 및 어딘가에 넣을 물건에 대한 사양.</target>
        </trans-unit>
        <trans-unit id="ece2ff0c58aaa5372289e45e695e7991badd8557" translate="yes" xml:space="preserve">
          <source>A spoonerism of &amp;ldquo;creeping featurism&amp;rdquo;, noting the biological urge to add just one more feature to a program.</source>
          <target state="translated">생물학적 기능이 프로그램에 하나 이상의 기능을 추가해야한다는 생물학적 충동을 지적하면서&amp;ldquo;크리핑 피처 리즘&amp;rdquo;의 숟가락.</target>
        </trans-unit>
        <trans-unit id="d575cbf3544d0e35868eb03520f7ba9dff410b04" translate="yes" xml:space="preserve">
          <source>A spot in your program where you&amp;rsquo;ve told the debugger to stop &lt;b&gt;execution&lt;/b&gt; so you can poke around and see whether anything is wrong yet.</source>
          <target state="translated">프로그램에서 디버거에게 &lt;b&gt;실행&lt;/b&gt; 을 중지 하도록 지시 한 지점으로, 찌르고 아직 문제가 있는지 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c8d0045954f55c0ef11ccdf21fdc1fefc0f23ff1" translate="yes" xml:space="preserve">
          <source>A square-bracketed list of characters used in a &lt;b&gt;regular expression&lt;/b&gt; to indicate that any character of the set may occur at a given point. Loosely, any predefined set of characters so used.</source>
          <target state="translated">&lt;b&gt;정규식에&lt;/b&gt; 사용되는 대괄호로 묶인 문자 목록은 세트의 모든 문자가 주어진 지점에서 발생할 수 있음을 나타냅니다. 느슨하게도, 사전 정의 된 문자 세트가 사용되었습니다.</target>
        </trans-unit>
        <trans-unit id="a4537030d9c45923983b601a7f64bbae6c4af141" translate="yes" xml:space="preserve">
          <source>A stable sort means that for records that compare equal, the original input ordering is preserved. Mergesort is stable, quicksort is not. Stability will matter only if elements that compare equal can be distinguished in some other way. That means that simple numerical and lexical sorts do not profit from stability, since equal elements are indistinguishable. However, with a comparison such as</source>
          <target state="translated">안정적인 정렬은 동일하게 비교되는 레코드의 경우 원래 입력 순서가 유지됨을 의미합니다. Mergesort는 안정적이며 quicksort는 그렇지 않습니다. 동일하게 비교되는 요소를 다른 방식으로 구별 할 수있는 경우에만 안정성이 중요합니다. 즉, 동일한 수의 요소를 구분할 수 없기 때문에 단순한 숫자 및 어휘 정렬은 안정성에서 이익을 얻지 못합니다. 그러나 다음과 같은 비교</target>
        </trans-unit>
        <trans-unit id="aaebd4ab6e5cf8a78012927baac4719189a65694" translate="yes" xml:space="preserve">
          <source>A stable sort means that for records that compare equal, the original input ordering is preserved. Stability will matter only if elements that compare equal can be distinguished in some other way. That means that simple numerical and lexical sorts do not profit from stability, since equal elements are indistinguishable. However, with a comparison such as</source>
          <target state="translated">안정적인 정렬은 동일하게 비교되는 레코드의 경우 원래 입력 순서가 유지됨을 의미합니다. 동일하게 비교되는 요소를 다른 방식으로 구별 할 수있는 경우에만 안정성이 중요합니다. 즉, 동일한 요소를 구별 할 수 없기 때문에 간단한 숫자 및 어휘 정렬은 안정성에서 이익을 얻지 못합니다. 그러나 다음과 같은 비교를 통해</target>
        </trans-unit>
        <trans-unit id="0bc56d9c1394b0fa0321168c0b37750c90b88391" translate="yes" xml:space="preserve">
          <source>A standalone &lt;code&gt;=end&lt;/code&gt; command was found.</source>
          <target state="translated">독립형 &lt;code&gt;=end&lt;/code&gt; 명령이 발견되었습니다.</target>
        </trans-unit>
        <trans-unit id="90d81dc6a3e1d8ac5702b6911f4d25957cbc4616" translate="yes" xml:space="preserve">
          <source>A standard C library for doing &lt;b&gt;buffered&lt;/b&gt; input and output to the &lt;b&gt;operating system&lt;/b&gt;. (The &amp;ldquo;standard&amp;rdquo; of standard I/O is at most marginally related to the &amp;ldquo;standard&amp;rdquo; of standard input and output.) In general, Perl relies on whatever implementation of standard I/O a given operating system supplies, so the buffering characteristics of a Perl program on one machine may not exactly match those on another machine. Normally this only influences efficiency, not semantics. If your standard I/O package is doing block buffering and you want it to &lt;b&gt;flush&lt;/b&gt; the buffer more often, just set the &lt;code&gt;$|&lt;/code&gt; variable to a true value.</source>
          <target state="translated">&lt;b&gt;운영 체제에 &lt;/b&gt;&lt;b&gt;버퍼링 된&lt;/b&gt; 입력 및 출력을 수행하기위한 표준 C 라이브러리 . (표준 I / O의 &quot;표준&quot;은 표준 입력 및 출력의 &quot;표준&quot;과 거의 관련이 없습니다.) 일반적으로 Perl은 특정 운영 체제 공급 장치의 표준 I / O 구현에 의존하므로 버퍼링 특성 한 시스템의 Perl 프로그램 중 하나가 다른 시스템의 프로그램과 정확히 일치하지 않을 수 있습니다. 일반적으로 이것은 의미론이 아닌 효율성에만 영향을 미칩니다. 표준 I / O 패키지가 블록 버퍼링을 수행하고 있고 더 자주 버퍼 를 &lt;b&gt;플러시&lt;/b&gt; 하려면 &lt;code&gt;$|&lt;/code&gt; 변수를 실제 값으로&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="ffe116dcbea9e5d21815e3d329637659dd6eec04" translate="yes" xml:space="preserve">
          <source>A standard module whose practical hints and suggestions are received (and possibly ignored) at compile time. Pragmas are named in all lowercase.</source>
          <target state="translated">실용적인 힌트와 제안이 컴파일 타임에 수신되고 무시 될 수있는 표준 모듈입니다. Pragma는 모두 소문자로 이름이 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="3042ccfccce8001b84bc5b8d8019cf025a6017d9" translate="yes" xml:space="preserve">
          <source>A standard, bundled release of a system of software. The default usage implies source code is included. If that is not the case, it will be called a &amp;ldquo;binary-only&amp;rdquo; distribution.</source>
          <target state="translated">소프트웨어 시스템의 표준 번들 릴리스. 기본 사용법은 소스 코드가 포함되어 있음을 의미합니다. 그렇지 않은 경우&amp;ldquo;이진 전용&amp;rdquo;배포라고합니다.</target>
        </trans-unit>
        <trans-unit id="c6647b8f10e57534f902ddf1aa4bccf61236fd6c" translate="yes" xml:space="preserve">
          <source>A statement sequence may contain declarations of lexically-scoped variables, but apart from declaring a variable name, the declaration acts like an ordinary statement, and is elaborated within the sequence of statements as if it were an ordinary statement. That means it actually has both compile-time and run-time effects.</source>
          <target state="translated">문장 순서는 어휘 범위 변수의 선언을 포함 할 수 있지만 변수 이름을 선언하는 것 외에도 선언은 일반적인 문장처럼 작동하며 문장의 시퀀스 내에서 마치 일반적인 문장 인 것처럼 설명됩니다. 그것은 실제로 컴파일 타임과 런타임 이펙트를 모두 가지고 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="fa46e467d8cdc232f6a66d28e35057665324ee9f" translate="yes" xml:space="preserve">
          <source>A string (char *).</source>
          <target state="translated">문자열 (char *).</target>
        </trans-unit>
        <trans-unit id="75e5df3441233543315a78a7205a2debb8ad739c" translate="yes" xml:space="preserve">
          <source>A string &lt;a href=&quot;functions/eval&quot;&gt;eval EXPR&lt;/a&gt; parses its expression as standard Perl. It is therefore expecting the decimal point to be a dot. If &lt;code&gt;LC_NUMERIC&lt;/code&gt; is set to have this be a comma instead, the parsing will be confused, perhaps silently.</source>
          <target state="translated">문자열 &lt;a href=&quot;functions/eval&quot;&gt;평가 EXPR&lt;/a&gt; 은 해당 표현식을 표준 Perl로 구문 분석합니다. 따라서 소수점이 점이 될 것으로 예상됩니다. 경우 &lt;code&gt;LC_NUMERIC&lt;/code&gt; 은 이 대신 쉼표로 설정되어, 구문 분석은 아마도 자동으로 혼동 될 것이다.</target>
        </trans-unit>
        <trans-unit id="e32ce4794e8e4c22eb37cafd0ff465a6583267c2" translate="yes" xml:space="preserve">
          <source>A string &lt;a href=&quot;perlfunc#eval-EXPR&quot;&gt;eval&lt;/a&gt; parses its expression as standard Perl. It is therefore expecting the decimal point to be a dot. If &lt;code&gt;LC_NUMERIC&lt;/code&gt; is set to have this be a comma instead, the parsing will be confused, perhaps silently.</source>
          <target state="translated">문자열 &lt;a href=&quot;perlfunc#eval-EXPR&quot;&gt;평가&lt;/a&gt; 는 해당 표현식을 표준 Perl로 구문 분석합니다. 따라서 소수점이 점이 될 것으로 예상합니다. 경우 &lt;code&gt;LC_NUMERIC&lt;/code&gt; 은 이 대신 쉼표로 설정되어, 구문 분석은 아마도 자동으로 혼동 될 것이다.</target>
        </trans-unit>
        <trans-unit id="b9568afdc53a4a7f1711d767a18a8d9f968593e6" translate="yes" xml:space="preserve">
          <source>A string beginning with &lt;code&gt;CLISYM_&lt;/code&gt; tells Perl to consult the CLI's symbol tables, using</source>
          <target state="translated">&lt;code&gt;CLISYM_&lt;/code&gt; 로 시작하는 문자열 은 Perl에게 다음을 사용하여 CLI의 기호 테이블을 참조하도록 지시합니다.</target>
        </trans-unit>
        <trans-unit id="f111ed51d2b3bdc540d8eea8f3e95bb03014421d" translate="yes" xml:space="preserve">
          <source>A string beginning with &lt;code&gt;CLISYM_&lt;/code&gt;tells Perl to consult the CLI's symbol tables, using</source>
          <target state="translated">&lt;code&gt;CLISYM_&lt;/code&gt; 로 시작하는 문자열 은 Perl에게 다음을 사용하여 CLI의 기호 테이블을 참조하도록 지시합니다.</target>
        </trans-unit>
        <trans-unit id="73539349cf3164d1f6eed3ab55aa660f24e3b757" translate="yes" xml:space="preserve">
          <source>A string containing all characters that should be encoded as HTML entities, specified using the regular expression character class syntax (what you find within brackets in regular expressions). This value will be passed as the second argument to the &lt;code&gt;encode_entities&lt;/code&gt; function of &lt;a href=&quot;HTML::Entities&quot;&gt;HTML::Entities&lt;/a&gt;. If &lt;a href=&quot;HTML::Entities&quot;&gt;HTML::Entities&lt;/a&gt; is not installed, then any characters other than &lt;code&gt;&amp;amp;&amp;lt;&lt;/code&gt;&quot;'&amp;gt; will be encoded numerically.</source>
          <target state="translated">정규식 문자 클래스 구문 (정규식에서 대괄호 안에있는 항목)을 사용하여 지정된 HTML 엔티티로 인코딩되어야하는 모든 문자를 포함하는 문자열입니다. 이 값은 &lt;a href=&quot;HTML::Entities&quot;&gt;HTML :: Entities&lt;/a&gt; 의 &lt;code&gt;encode_entities&lt;/code&gt; 함수에 두 번째 인수로 전달됩니다 . 경우 &lt;a href=&quot;HTML::Entities&quot;&gt;HTML :: 엔티티가&lt;/a&gt; 설치되어 있지 않은 경우, 이외의 문자 &lt;code&gt;&amp;amp;&amp;lt;&lt;/code&gt; ''&amp;gt; 숫자로 인코딩됩니다.</target>
        </trans-unit>
        <trans-unit id="afb88c9d62f1cca49157633840f22b59a116a8ab" translate="yes" xml:space="preserve">
          <source>A string containing all characters that should be encoded as HTML entities, specified using the regular expression character class syntax (what you find within brackets in regular expressions). This value will be passed as the second argument to the &lt;code&gt;encode_entities&lt;/code&gt; function of &lt;a href=&quot;http://search.cpan.org/perldoc/HTML::Entities&quot;&gt;HTML::Entities&lt;/a&gt;. If &lt;a href=&quot;http://search.cpan.org/perldoc/HTML::Entities&quot;&gt;HTML::Entities&lt;/a&gt; is not installed, then any characters other than &lt;code&gt;&amp;amp;&amp;lt;&lt;/code&gt; &quot;'&amp;gt; will be encoded numerically.</source>
          <target state="translated">정규식 문자 클래스 구문 (정규식에서 괄호 안에있는 것)을 사용하여 지정된 HTML 엔티티로 인코딩되어야하는 모든 문자를 포함하는 문자열입니다. 이 값은 &lt;a href=&quot;http://search.cpan.org/perldoc/HTML::Entities&quot;&gt;HTML :: Entities&lt;/a&gt; 의 &lt;code&gt;encode_entities&lt;/code&gt; 함수에 두 번째 인수로 전달됩니다 . 경우 &lt;a href=&quot;http://search.cpan.org/perldoc/HTML::Entities&quot;&gt;HTML :: 엔티티가&lt;/a&gt; 설치되어 있지 않은 경우, 이외의 문자 &lt;code&gt;&amp;amp;&amp;lt;&lt;/code&gt; ''&amp;gt; 숫자로 인코딩됩니다.</target>
        </trans-unit>
        <trans-unit id="2c6988b512688bb605e69e65500198db5054baa8" translate="yes" xml:space="preserve">
          <source>A string containing the text of a message to print</source>
          <target state="translated">인쇄 할 메시지의 텍스트를 포함하는 문자열</target>
        </trans-unit>
        <trans-unit id="bf5bf16fd07f45d581debfd5241308f05f5b876d" translate="yes" xml:space="preserve">
          <source>A string corresponding to the desired output file (or &quot;&amp;gt;&amp;amp;STDOUT&quot; or &quot;&amp;gt;&amp;amp;STDERR&quot;), or a filehandle to write on. The default is to use standard output.</source>
          <target state="translated">원하는 출력 파일 (또는 &quot;&amp;gt; &amp;amp; STDOUT&quot;또는 &quot;&amp;gt; &amp;amp; STDERR&quot;) 또는 쓸 파일 핸들에 해당하는 문자열입니다. 기본값은 표준 출력을 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="e81c48705eb13d4df1f22c2acd8523f46384c993" translate="yes" xml:space="preserve">
          <source>A string enclosed by backticks (grave accents) first undergoes double-quote interpolation. It is then interpreted as an external command, and the output of that command is the value of the backtick string, like in a shell. In scalar context, a single string consisting of all output is returned. In list context, a list of values is returned, one per line of output. (You can set &lt;code&gt;$/&lt;/code&gt; to use a different line terminator.) The command is executed each time the pseudo-literal is evaluated. The status value of the command is returned in &lt;code&gt;$?&lt;/code&gt; (see &lt;a href=&quot;perlvar&quot;&gt;perlvar&lt;/a&gt; for the interpretation of &lt;code&gt;$?&lt;/code&gt; ). Unlike in &lt;b&gt;csh&lt;/b&gt;, no translation is done on the return data--newlines remain newlines. Unlike in any of the shells, single quotes do not hide variable names in the command from interpretation. To pass a literal dollar-sign through to the shell you need to hide it with a backslash. The generalized form of backticks is &lt;code&gt;&lt;a href=&quot;functions/qx&quot;&gt;qx//&lt;/a&gt;&lt;/code&gt;. (Because backticks always undergo shell expansion as well, see &lt;a href=&quot;perlsec&quot;&gt;perlsec&lt;/a&gt; for security concerns.)</source>
          <target state="translated">백틱 (가시 악센트)으로 묶인 문자열은 먼저 큰 따옴표 보간을받습니다. 그런 다음 외부 명령으로 해석되며 해당 명령의 출력은 쉘에서와 같이 백틱 문자열의 값입니다. 스칼라 컨텍스트에서는 모든 출력으로 구성된 단일 문자열이 반환됩니다. 목록 컨텍스트에서 출력 라인 당 하나씩 값 목록이 리턴됩니다. ( 다른 줄 종결자를 사용하도록 &lt;code&gt;$/&lt;/code&gt; 를 설정할 수 있습니다 .) 의사 리터럴이 평가 될 때마다 명령이 실행됩니다. 명령의 상태 값은 &lt;code&gt;$?&lt;/code&gt; ( &lt;code&gt;$?&lt;/code&gt; 의 해석에 대해서는 &lt;a href=&quot;perlvar&quot;&gt;perlvar&lt;/a&gt; 를 참조하십시오 ). &lt;b&gt;csh&lt;/b&gt; 와 달리&lt;b&gt;&lt;/b&gt;반환 데이터에 대해서는 번역이 수행되지 않으며, 줄 바꿈은 줄 바꿈으로 유지됩니다. 쉘과 달리 작은 따옴표는 명령에서 변수 이름을 해석에서 숨기지 않습니다. 리터럴 달러 기호를 쉘에 전달하려면 백 슬래시로 숨겨야합니다. 백틱의 일반화 된 형태는 &lt;code&gt;&lt;a href=&quot;functions/qx&quot;&gt;qx//&lt;/a&gt;&lt;/code&gt; 입니다. (백틱도 항상 셸 확장을 거치 &lt;a href=&quot;perlsec&quot;&gt;므로&lt;/a&gt; 보안 문제는 perlsec 을 참조하십시오 .)</target>
        </trans-unit>
        <trans-unit id="6a59c28b10f1e469c8f302761a4c4403491075e7" translate="yes" xml:space="preserve">
          <source>A string enclosed by backticks (grave accents) first undergoes double-quote interpolation. It is then interpreted as an external command, and the output of that command is the value of the backtick string, like in a shell. In scalar context, a single string consisting of all output is returned. In list context, a list of values is returned, one per line of output. (You can set &lt;code&gt;$/&lt;/code&gt; to use a different line terminator.) The command is executed each time the pseudo-literal is evaluated. The status value of the command is returned in &lt;code&gt;$?&lt;/code&gt; (see &lt;a href=&quot;perlvar&quot;&gt;perlvar&lt;/a&gt; for the interpretation of &lt;code&gt;$?&lt;/code&gt;). Unlike in &lt;b&gt;csh&lt;/b&gt;, no translation is done on the return data--newlines remain newlines. Unlike in any of the shells, single quotes do not hide variable names in the command from interpretation. To pass a literal dollar-sign through to the shell you need to hide it with a backslash. The generalized form of backticks is &lt;code&gt;qx//&lt;/code&gt;, or you can call the &lt;a href=&quot;perlfunc#readpipe&quot;&gt;&quot;readpipe&quot; in perlfunc&lt;/a&gt; function. (Because backticks always undergo shell expansion as well, see &lt;a href=&quot;perlsec&quot;&gt;perlsec&lt;/a&gt; for security concerns.)</source>
          <target state="translated">역 따옴표 (억음 악센트)로 묶인 문자열은 먼저 큰 따옴표 보간을받습니다. 그런 다음 외부 명령으로 해석되고 해당 명령의 출력은 쉘에서와 같이 백틱 문자열의 값입니다. 스칼라 컨텍스트에서는 모든 출력으로 구성된 단일 문자열이 반환됩니다. 목록 컨텍스트에서 값 목록이 출력 라인 당 하나씩 반환됩니다. ( &lt;code&gt;$/&lt;/code&gt; 를 설정 하여 다른 줄 종결자를 사용할 수 있습니다 .)이 명령은 의사 리터럴이 평가 될 때마다 실행됩니다. 명령의 상태 값은 &lt;code&gt;$?&lt;/code&gt; ( &lt;code&gt;$?&lt;/code&gt; 의 해석 은 &lt;a href=&quot;perlvar&quot;&gt;perlvar&lt;/a&gt; 참조 ). &lt;b&gt;csh&lt;/b&gt; 와 달리&lt;b&gt;&lt;/b&gt;, 반환 데이터에 대한 번역이 수행되지 않고 개행은 개행으로 유지됩니다. 다른 쉘과 달리 작은 따옴표는 해석에서 명령의 변수 이름을 숨기지 않습니다. 문자 그대로 달러 기호를 쉘에 전달하려면 백 슬래시로 숨겨야합니다. 일반화 된 형태의 백틱은 &lt;code&gt;qx//&lt;/code&gt; 또는 &lt;a href=&quot;perlfunc#readpipe&quot;&gt;perlfunc&lt;/a&gt; 함수 에서 &quot;readpipe&quot;를 호출 할 수 있습니다 . (백틱도 항상 셸 확장을 거치 &lt;a href=&quot;perlsec&quot;&gt;므로&lt;/a&gt; 보안 문제는 perlsec 을 참조하십시오 .)</target>
        </trans-unit>
        <trans-unit id="8188c86cb7ff03c08e73a3bf26c2466b54d74c0a" translate="yes" xml:space="preserve">
          <source>A string encoded in UTF-EBCDIC may be longer (but never shorter) than one encoded in UTF-8. Perl extends UTF-8 so that it can encode code points above the Unicode maximum of U+10FFFF. It extends UTF-EBCDIC as well, but due to the inherent limitations in UTF-EBCDIC, the maximum code point expressible is U+7FFF_FFFF, even if the word size is more than 32 bits.</source>
          <target state="translated">UTF-EBCDIC으로 인코딩 된 문자열은 UTF-8로 인코딩 된 문자열보다 길 수 있지만 더 짧을 수는 없습니다. Perl은 UTF-8을 확장하여 유니 코드 최대 값 U + 10FFFF를 초과하는 코드 포인트를 인코딩 할 수 있습니다. UTF-EBCDIC도 확장하지만 UTF-EBCDIC의 고유 제한 사항으로 인해 워드 크기가 32 비트를 초과하더라도 표현 가능한 최대 코드 포인트는 U + 7FFF_FFFF입니다.</target>
        </trans-unit>
        <trans-unit id="914a74b444d9ba99a9fe1b62c1ecf5a7f252527d" translate="yes" xml:space="preserve">
          <source>A string encoded in UTF-EBCDIC may be longer (very rarely shorter) than one encoded in UTF-8. Perl extends both UTF-8 and UTF-EBCDIC so that they can encode code points above the Unicode maximum of U+10FFFF. Both extensions are constructed to allow encoding of any code point that fits in a 64-bit word.</source>
          <target state="translated">UTF-EBCDIC로 인코딩 된 문자열은 UTF-8로 인코딩 된 문자열보다 길 수 있습니다 (아주 짧지 않음). Perl은 UTF-8 및 UTF-EBCDIC를 모두 확장하여 유니 코드 최대 U + 10FFFF를 초과하는 코드 포인트를 인코딩 할 수 있습니다. 두 확장은 모두 64 비트 단어에 맞는 모든 코드 포인트의 인코딩을 허용하도록 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="f4917965ca44eb0c4faae94a841c4f89027d6938" translate="yes" xml:space="preserve">
          <source>A string of alternative option starter characters may be passed as the first argument (or the first argument after a leading hash reference argument).</source>
          <target state="translated">대체 옵션 시작 문자 문자열이 첫 번째 인수 (또는 선행 해시 참조 인수 다음의 첫 번째 인수)로 전달 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="88c258b6d0e7c9ac246c86ffd1bb6de9b44ef38f" translate="yes" xml:space="preserve">
          <source>A string of portable printable characters. This is the base64 encoded representation of the digest with any trailing padding removed. The string will be about 30% longer than the binary version. &lt;a href=&quot;MIME::Base64&quot;&gt;MIME::Base64&lt;/a&gt; tells you more about this encoding.</source>
          <target state="translated">휴대용 인쇄 가능한 문자의 문자열입니다. 이것은 후행 패딩이 제거 된 다이제스트의 base64 인코딩 표현입니다. 문자열은 바이너리 버전보다 약 30 % 더 길 것입니다. &lt;a href=&quot;MIME::Base64&quot;&gt;MIME :: Base64&lt;/a&gt; 는이 인코딩에 대해 자세히 알려줍니다.</target>
        </trans-unit>
        <trans-unit id="46c47b9481cf147721b670360f462acc06f6b68e" translate="yes" xml:space="preserve">
          <source>A string of portable printable characters. This is the base64 encoded representation of the digest with any trailing padding removed. The string will be about 30% longer than the binary version. &lt;a href=&quot;mime/base64&quot;&gt;MIME::Base64&lt;/a&gt; tells you more about this encoding.</source>
          <target state="translated">휴대용 인쇄 가능한 문자열입니다. 후행 패딩이 제거 된 다이제스트의 base64 인코딩 표현입니다. 문자열은 이진 버전보다 약 30 % 길어집니다. &lt;a href=&quot;mime/base64&quot;&gt;MIME :: Base64&lt;/a&gt; 가이 인코딩에 대해 자세히 알려줍니다.</target>
        </trans-unit>
        <trans-unit id="1b085cd0478f87c6aa68ec36d4064dfac1577470" translate="yes" xml:space="preserve">
          <source>A string of zero or more characters from &lt;code&gt;&quot;achorst&quot;&lt;/code&gt; [see &lt;code&gt;attrLetsToBits&lt;/code&gt; for more information] which are converted to &lt;code&gt;FILE_ATTRIBUTE_*&lt;/code&gt; bits to be set in the &lt;code&gt;$uFlags&lt;/code&gt; argument passed to &lt;code&gt;CreateFile&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;CreateFile&lt;/code&gt; 에 전달 된 &lt;code&gt;$uFlags&lt;/code&gt; 인수에 설정 될 &lt;code&gt;FILE_ATTRIBUTE_*&lt;/code&gt; 비트로 변환 되는 &lt;code&gt;&quot;achorst&quot;&lt;/code&gt; [ 자세한 내용 은 &lt;code&gt;attrLetsToBits&lt;/code&gt; 참조 ] 의 0 개 이상의 문자 문자열입니다 .</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
