<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="perl">
    <body>
      <group id="perl">
        <trans-unit id="77df0281a5c47be5d00ae61a57ff00e23d9d5e5b" translate="yes" xml:space="preserve">
          <source>EXPORTABLE FUNCTIONS</source>
          <target state="translated">수출 가능한 기능</target>
        </trans-unit>
        <trans-unit id="22d0596dab83a0920d66ad899d3e61f47464b88e" translate="yes" xml:space="preserve">
          <source>EXPORTABLE VARIABLES</source>
          <target state="translated">수출 가능한 변수</target>
        </trans-unit>
        <trans-unit id="43aade251566381046f1d9dd6f51422fde3c0fbd" translate="yes" xml:space="preserve">
          <source>EXPORTED FUNCTIONS</source>
          <target state="translated">수출 된 기능</target>
        </trans-unit>
        <trans-unit id="8b30e3050a39fae8e0c617ff76ab8d47b5f0b044" translate="yes" xml:space="preserve">
          <source>EXPORTED SYMBOLS</source>
          <target state="translated">수출 된 상징</target>
        </trans-unit>
        <trans-unit id="e9e012170f2df7cb18fa26019e2b46cbf4a91319" translate="yes" xml:space="preserve">
          <source>EXPORTS</source>
          <target state="translated">EXPORTS</target>
        </trans-unit>
        <trans-unit id="7b479848a0ec11ad7c3ba1025f3ac20068015bb9" translate="yes" xml:space="preserve">
          <source>EXPORTS (by request only)</source>
          <target state="translated">수출 (요청에 의해서만)</target>
        </trans-unit>
        <trans-unit id="6b6562ec1f5d1b67f0bbd288b913382cd128ba1e" translate="yes" xml:space="preserve">
          <source>EXPORT_LIST: name of a file that is passed to linker to define symbols to be exported.</source>
          <target state="translated">EXPORT_LIST : 내보낼 심볼을 정의하기 위해 링커로 전달되는 파일 이름입니다.</target>
        </trans-unit>
        <trans-unit id="a6fc3ffe71e48b679d9c5609def42ab3c69aa49f" translate="yes" xml:space="preserve">
          <source>EXPORT_OK</source>
          <target state="translated">EXPORT_OK</target>
        </trans-unit>
        <trans-unit id="f817892a6b7b040f6bf499b1ab6645711184a4f1" translate="yes" xml:space="preserve">
          <source>EXPR</source>
          <target state="translated">EXPR</target>
        </trans-unit>
        <trans-unit id="62af5da98ccf954a1bd12d8422eab969d058949e" translate="yes" xml:space="preserve">
          <source>EXPR is executed as a system command. The collected standard output of the command is returned. In scalar context, it comes back as a single (potentially multi-line) string. In list context, returns a list of lines (however you've defined lines with &lt;a href=&quot;perlvar#%24%2F&quot;&gt;&lt;code&gt;$/&lt;/code&gt;&lt;/a&gt; (or &lt;code&gt;$INPUT_RECORD_SEPARATOR&lt;/code&gt; in &lt;a href=&quot;english&quot;&gt;English&lt;/a&gt;)). This is the internal function implementing the &lt;code&gt;qx/EXPR/&lt;/code&gt; operator, but you can use it directly. The &lt;code&gt;qx/EXPR/&lt;/code&gt; operator is discussed in more detail in &lt;a href=&quot;perlop#qx%2FSTRING%2F&quot;&gt;&quot;&lt;code&gt;qx/&lt;i&gt;STRING&lt;/i&gt;/&lt;/code&gt;&quot; in perlop&lt;/a&gt;. If EXPR is omitted, uses &lt;a href=&quot;perlvar#%24_&quot;&gt;&lt;code&gt;$_&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3499643610f3dd44dae6eb02d7fed2d648b428d9" translate="yes" xml:space="preserve">
          <source>EXPR is executed as a system command. The collected standard output of the command is returned. In scalar context, it comes back as a single (potentially multi-line) string. In list context, returns a list of lines (however you've defined lines with &lt;code&gt;$/&lt;/code&gt; or &lt;code&gt;$INPUT_RECORD_SEPARATOR&lt;/code&gt; ). This is the internal function implementing the &lt;code&gt;&lt;a href=&quot;functions/qx&quot;&gt;qx/EXPR/&lt;/a&gt;&lt;/code&gt; operator, but you can use it directly. The &lt;code&gt;&lt;a href=&quot;functions/qx&quot;&gt;qx/EXPR/&lt;/a&gt;&lt;/code&gt; operator is discussed in more detail in &lt;a href=&quot;perlop#I%2fO-Operators&quot;&gt;I/O Operators in perlop&lt;/a&gt;. If EXPR is omitted, uses &lt;code&gt;$_&lt;/code&gt; .</source>
          <target state="translated">EXPR은 시스템 명령으로 실행됩니다. 명령의 수집 된 표준 출력이 리턴됩니다. 스칼라 컨텍스트에서는 단일 (잠재적으로 여러 줄) 문자열로 돌아옵니다. 목록 컨텍스트에서 행 목록을 리턴합니다 (그러나 &lt;code&gt;$/&lt;/code&gt; 또는 &lt;code&gt;$INPUT_RECORD_SEPARATOR&lt;/code&gt; 하여 행을 정의 했습니다 ). 이것은 &lt;code&gt;&lt;a href=&quot;functions/qx&quot;&gt;qx/EXPR/&lt;/a&gt;&lt;/code&gt; 연산자를 구현하는 내부 함수 이지만 직접 사용할 수 있습니다. &lt;code&gt;&lt;a href=&quot;functions/qx&quot;&gt;qx/EXPR/&lt;/a&gt;&lt;/code&gt; 오퍼레이터에 자세히 설명되어 &lt;a href=&quot;perlop#I%2fO-Operators&quot;&gt;perlop에서 I / O 연산자&lt;/a&gt; . EXPR이 생략되면 &lt;code&gt;$_&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f586c420e6eaf4cfbda37e4566d4c88b6984ca54" translate="yes" xml:space="preserve">
          <source>EXPR is executed as a system command. The collected standard output of the command is returned. In scalar context, it comes back as a single (potentially multi-line) string. In list context, returns a list of lines (however you've defined lines with &lt;code&gt;$/&lt;/code&gt; or &lt;code&gt;$INPUT_RECORD_SEPARATOR&lt;/code&gt; ). This is the internal function implementing the &lt;code&gt;&lt;a href=&quot;qx&quot;&gt;qx/EXPR/&lt;/a&gt;&lt;/code&gt; operator, but you can use it directly. The &lt;code&gt;&lt;a href=&quot;qx&quot;&gt;qx/EXPR/&lt;/a&gt;&lt;/code&gt; operator is discussed in more detail in &lt;a href=&quot;../perlop#I%2fO-Operators&quot;&gt;I/O Operators in perlop&lt;/a&gt;. If EXPR is omitted, uses &lt;code&gt;$_&lt;/code&gt; .</source>
          <target state="translated">EXPR은 시스템 명령으로 실행됩니다. 명령의 수집 된 표준 출력이 리턴됩니다. 스칼라 컨텍스트에서는 단일 (잠재적으로 여러 줄) 문자열로 돌아옵니다. 목록 컨텍스트에서 행 목록을 리턴합니다 (그러나 &lt;code&gt;$/&lt;/code&gt; 또는 &lt;code&gt;$INPUT_RECORD_SEPARATOR&lt;/code&gt; 하여 행을 정의 했습니다 ). 이것은 &lt;code&gt;&lt;a href=&quot;qx&quot;&gt;qx/EXPR/&lt;/a&gt;&lt;/code&gt; 연산자를 구현하는 내부 함수 이지만 직접 사용할 수 있습니다. &lt;code&gt;&lt;a href=&quot;qx&quot;&gt;qx/EXPR/&lt;/a&gt;&lt;/code&gt; 오퍼레이터에 자세히 설명되어 &lt;a href=&quot;../perlop#I%2fO-Operators&quot;&gt;perlop에서 I / O 연산자&lt;/a&gt; . EXPR이 생략되면 &lt;code&gt;$_&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="891bbd450e125f5b1ee12d035ddc1a7eef7a872c" translate="yes" xml:space="preserve">
          <source>EXPRESSION</source>
          <target state="translated">EXPRESSION</target>
        </trans-unit>
        <trans-unit id="6f64d0b0e54fcf9769746a65fbf9b2ecb163ee70" translate="yes" xml:space="preserve">
          <source>EXTEND</source>
          <target state="translated">EXTEND</target>
        </trans-unit>
        <trans-unit id="105f8f5f3c21e49b28c3216ab6b37ce1503d78bf" translate="yes" xml:space="preserve">
          <source>EXTEND this, count</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4a4d24b33941bccd86ff7ba0c19dc15933e36a4" translate="yes" xml:space="preserve">
          <source>EXTENDED CONSTRUCTS</source>
          <target state="translated">확장 된 구조</target>
        </trans-unit>
        <trans-unit id="b070e356144357fb71137b31e2e89f09d2f73b53" translate="yes" xml:space="preserve">
          <source>EXTERN.h</source>
          <target state="translated">EXTERN.h</target>
        </trans-unit>
        <trans-unit id="92f627e6114fde8ec8e85f5dc7eb0d8548926fd9" translate="yes" xml:space="preserve">
          <source>EXTERNAL</source>
          <target state="translated">EXTERNAL</target>
        </trans-unit>
        <trans-unit id="21d7721c8d41e278d11d43cf30b3f64d4c13b7f4" translate="yes" xml:space="preserve">
          <source>EXTRA</source>
          <target state="translated">EXTRA</target>
        </trans-unit>
        <trans-unit id="13ae0f4e98553c4041bca1bd5b70b21a5aa6d865" translate="yes" xml:space="preserve">
          <source>EXTRALIBS</source>
          <target state="translated">EXTRALIBS</target>
        </trans-unit>
        <trans-unit id="3633746b067241666bc462dcfe7a24ff23a8db68" translate="yes" xml:space="preserve">
          <source>Each</source>
          <target state="translated">Each</target>
        </trans-unit>
        <trans-unit id="64713135c29a168f621e3cd6c59750f2ec3360d2" translate="yes" xml:space="preserve">
          <source>Each &quot;=over&quot; ... &quot;=back&quot; region should be one of the following:</source>
          <target state="translated">각 &quot;= over&quot;... &quot;= back&quot;영역은 다음 중 하나 여야합니다.</target>
        </trans-unit>
        <trans-unit id="8573b03d1dbd851733546c18897b586541b26327" translate="yes" xml:space="preserve">
          <source>Each &lt;b&gt;File&lt;/b&gt; section reports on a single file. Each &lt;b&gt;Subroutine&lt;/b&gt; section reports on a single subroutine apart from the special cases &quot;(definitions)&quot; and &quot;(main)&quot;. These report, respectively, on subroutine definitions found by the initial symbol table walk and on the main part of the program or module external to all subroutines.</source>
          <target state="translated">각 &lt;b&gt;파일&lt;/b&gt; 섹션은 단일 파일에 대해보고합니다. 각 &lt;b&gt;서브 루틴&lt;/b&gt; 섹션은 특수한 경우 &quot;(definitions)&quot;및 &quot;(main)&quot;을 제외하고 단일 서브 루틴에 대해보고합니다. 이 보고서는 각각 초기 기호 테이블에서 찾은 서브 루틴 정의와 모든 서브 루틴 외부의 프로그램 또는 모듈의 주요 부분에 대한 보고서입니다.</target>
        </trans-unit>
        <trans-unit id="c3f67868071b09e484f931abe029f1f8f7b5dc16" translate="yes" xml:space="preserve">
          <source>Each &lt;code&gt;--$source-option&lt;/code&gt; option must specify a key/value pair separated by an &lt;code&gt;=&lt;/code&gt; . If an option can take multiple values, just specify it multiple times, as with the &lt;code&gt;extensions=&lt;/code&gt; examples above. If the option should be a hash reference, specify the value as a second pair separated by a &lt;code&gt;=&lt;/code&gt; , as in the &lt;code&gt;pset=&lt;/code&gt; examples above (escape &lt;code&gt;=&lt;/code&gt; with a backslash).</source>
          <target state="translated">각 &lt;code&gt;--$source-option&lt;/code&gt; 옵션은 키 / 값 쌍을 &lt;code&gt;=&lt;/code&gt; 로 구분하여 지정해야합니다 . 옵션이 여러 값을 가질 수있는 경우 위 의 &lt;code&gt;extensions=&lt;/code&gt; 예제 와 같이 옵션을 여러 번 지정하십시오 . 옵션이 해시 참조 여야하는 경우 위 의 &lt;code&gt;pset=&lt;/code&gt; 예제와 같이 두 번째 쌍으로 값을 a &lt;code&gt;=&lt;/code&gt; 로 구분하여 지정하십시오 (이스케이프 &lt;code&gt;=&lt;/code&gt; 백 슬래시 포함).</target>
        </trans-unit>
        <trans-unit id="72aa1e6906c5ec0ac410f03e5bee3a9d52fb4bb1" translate="yes" xml:space="preserve">
          <source>Each &lt;code&gt;--$source-option&lt;/code&gt; option must specify a key/value pair separated by an &lt;code&gt;=&lt;/code&gt;. If an option can take multiple values, just specify it multiple times, as with the &lt;code&gt;extensions=&lt;/code&gt; examples above. If the option should be a hash reference, specify the value as a second pair separated by a &lt;code&gt;=&lt;/code&gt;, as in the &lt;code&gt;pset=&lt;/code&gt; examples above (escape &lt;code&gt;=&lt;/code&gt; with a backslash).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="114f01b386e99faf35799463e66245b3c628986d" translate="yes" xml:space="preserve">
          <source>Each C type is represented by an entry in the typemap file that is responsible for converting perl variables (SV, AV, HV, CV, etc.) to and from that type. The following sections list all XS types that come with perl by default.</source>
          <target state="translated">각 C 유형은 펄 변수 (SV, AV, HV, CV 등)를 해당 유형으로 변환하는 책임이있는 유형 맵 파일의 항목으로 표시됩니다. 다음 섹션에는 기본적으로 perl과 함께 제공되는 모든 XS 유형이 나열되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="45fe11f5c5ad8666badf6e1b74648061569fd2e9" translate="yes" xml:space="preserve">
          <source>Each CV has a pointer, &lt;code&gt;CvOUTSIDE()&lt;/code&gt; , to its lexically enclosing CV (if any). Because pointers to anonymous sub prototypes are stored in &lt;code&gt;&amp;amp;&lt;/code&gt; pad slots, it is a possible to get a circular reference, with the parent pointing to the child and vice-versa. To avoid the ensuing memory leak, we do not increment the reference count of the CV pointed to by &lt;code&gt;CvOUTSIDE&lt;/code&gt; in the</source>
          <target state="translated">각 CV에는 &lt;code&gt;CvOUTSIDE()&lt;/code&gt; 포인터 가 어휘 적으로 둘러싸인 CV (있는 경우 )에 대한 포인터가 있습니다. 익명의 하위 프로토 타입에 대한 포인터는 &lt;code&gt;&amp;amp;&lt;/code&gt; 패드 슬롯에 저장 되므로 부모가 자식을 가리키고 그 반대도 순환 참조를 얻을 수 있습니다. 계속되는 메모리 누수를 피하기 위해 &lt;code&gt;CvOUTSIDE&lt;/code&gt; 가 가리키는 CV의 참조 카운트를 증가시키지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="0a552f3c9f394752d19b918c33b1679413791b25" translate="yes" xml:space="preserve">
          <source>Each CV has a pointer, &lt;code&gt;CvOUTSIDE()&lt;/code&gt;, to its lexically enclosing CV (if any). Because pointers to anonymous sub prototypes are stored in &lt;code&gt;&amp;amp;&lt;/code&gt; pad slots, it is a possible to get a circular reference, with the parent pointing to the child and vice-versa. To avoid the ensuing memory leak, we do not increment the reference count of the CV pointed to by &lt;code&gt;CvOUTSIDE&lt;/code&gt; in the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="877f690dc448228c6c71438f034057615156195d" translate="yes" xml:space="preserve">
          <source>Each INPUT or OUTPUT typemap entry is a double-quoted Perl string that will be evaluated in the presence of certain variables to get the final C code for mapping a certain C type.</source>
          <target state="translated">각 INPUT 또는 OUTPUT 형식 맵 항목은 특정 변수가있는 경우 특정 C 형식을 매핑하기위한 최종 C 코드를 얻기 위해 평가되는 큰 따옴표로 묶인 Perl 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="fb013f151204036ffe28cd6f1b7420c85313acfd" translate="yes" xml:space="preserve">
          <source>Each NAME is assumed to be in the calling package. See share_from for an alternative method (which &lt;code&gt;share&lt;/code&gt; uses).</source>
          <target state="translated">각 NAME은 호출 패키지에 있다고 가정합니다. 대체 방법 ( &lt;code&gt;share&lt;/code&gt; 사용)에 대해서는 share_from을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="5c9985ee57f0e8b2c8e51c7278e3d4c3d9b47d87" translate="yes" xml:space="preserve">
          <source>Each NAME must be the &lt;b&gt;name&lt;/b&gt; of a non-lexical variable, typically with the leading type identifier included. A bareword is treated as a function name.</source>
          <target state="translated">각 NAME은 일반적으로 선행 유형 식별자가 포함 된 비-어휘 변수 의 &lt;b&gt;이름&lt;/b&gt; 이어야합니다 . 베어 워드는 함수 이름으로 취급됩니다.</target>
        </trans-unit>
        <trans-unit id="2d1afe9f64b8afc5ff5d1587bde457161df361bb" translate="yes" xml:space="preserve">
          <source>Each array &lt;code&gt;@{&quot;_&amp;lt;$filename&quot;}&lt;/code&gt; holds the lines of $filename for a file compiled by Perl. The same is also true for &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;ed strings that contain subroutines, or which are currently being executed. The $filename for &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;ed strings looks like &lt;code&gt;(&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; 34)&lt;/code&gt; .</source>
          <target state="translated">각 배열 &lt;code&gt;@{&quot;_&amp;lt;$filename&quot;}&lt;/code&gt; 은 Perl에 의해 컴파일 된 파일에 대한 $ filename 행을 보유합니다. 서브 루틴을 포함하거나 현재 실행중인 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 문자열 도 마찬가지입니다 . &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 문자열 의 $ filename은 다음과 같습니다 &lt;code&gt;(&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; 34)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4542f557bdf7a70f332f8c5d8d58355f058485ae" translate="yes" xml:space="preserve">
          <source>Each array &lt;code&gt;@{&quot;_&amp;lt;$filename&quot;}&lt;/code&gt; holds the lines of $filename for a file compiled by Perl. The same is also true for &lt;code&gt;eval&lt;/code&gt;ed strings that contain subroutines, or which are currently being executed. The $filename for &lt;code&gt;eval&lt;/code&gt;ed strings looks like &lt;code&gt;(eval 34)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83f0c2f3d8605c13877f68e54dd82f6341b8fae0" translate="yes" xml:space="preserve">
          <source>Each class can define its &lt;b&gt;attributes&lt;/b&gt;. When we instantiate an object, we assign values to those attributes. For example, every &lt;code&gt;File&lt;/code&gt; object has a path. Attributes are sometimes called &lt;b&gt;properties&lt;/b&gt;.</source>
          <target state="translated">각 클래스는 &lt;b&gt;속성을&lt;/b&gt; 정의 할 수 있습니다 . 객체를 인스턴스화 할 때 해당 속성에 값을 할당합니다. 예를 들어, 모든 &lt;code&gt;File&lt;/code&gt; 객체에는 경로가 있습니다. 속성을 속성이라고도 &lt;b&gt;합니다&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="64bf8b278b40ceb1457596f928446c91560cdf44" translate="yes" xml:space="preserve">
          <source>Each compartment has an associated &quot;operator mask&quot;. Recall that perl code is compiled into an internal format before execution. Evaluating perl code (e.g. via &quot;eval&quot; or &quot;do 'file'&quot;) causes the code to be compiled into an internal format and then, provided there was no error in the compilation, executed. Code evaluated in a compartment compiles subject to the compartment's operator mask. Attempting to evaluate code in a compartment which contains a masked operator will cause the compilation to fail with an error. The code will not be executed.</source>
          <target state="translated">각 구획에는 관련 &quot;오퍼레이터 마스크&quot;가 있습니다. 펄 코드는 실행 전에 내부 형식으로 컴파일된다는 것을 기억하십시오. perl 코드를 평가하면 (예 : &quot;eval&quot;또는 &quot;do 'file'&quot;을 통해) 코드가 내부 형식으로 컴파일 된 다음 컴파일에 오류가없는 경우 실행됩니다. 구획에서 평가 된 코드는 구획의 운영자 마스크에 따라 컴파일됩니다. 마스크 처리 된 연산자가 포함 된 구획에서 코드를 평가하려고하면 컴파일 오류가 발생합니다. 코드가 실행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c6c4ed2bbcee866615b18a5377b47f14999fe9bd" translate="yes" xml:space="preserve">
          <source>Each context entry is labelled with a context type, &lt;code&gt;cx_type&lt;/code&gt;. Typical context types are &lt;code&gt;CXt_SUB&lt;/code&gt;, &lt;code&gt;CXt_EVAL&lt;/code&gt; etc., as well as &lt;code&gt;CXt_BLOCK&lt;/code&gt; and &lt;code&gt;CXt_NULL&lt;/code&gt; which represent a basic scope (as pushed by &lt;code&gt;pp_enter&lt;/code&gt;) and a sort block. The type determines which part of the context union are valid.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="035a2860cc641f9a6aba917e368a923359692185" translate="yes" xml:space="preserve">
          <source>Each element in the struct data has an accessor method, which is used to assign to the element and to fetch its value. The default accessor can be overridden by declaring a &lt;code&gt;&lt;a href=&quot;../functions/sub&quot;&gt;sub&lt;/a&gt;&lt;/code&gt; of the same name in the package. (See Example 2.)</source>
          <target state="translated">구조체 데이터의 각 요소에는 요소에 할당하고 해당 값을 가져 오는 데 사용되는 접근 자 메서드가 있습니다. 패키지에서 같은 이름 의 &lt;code&gt;&lt;a href=&quot;../functions/sub&quot;&gt;sub&lt;/a&gt;&lt;/code&gt; 를 선언하여 기본 접근자를 재정의 할 수 있습니다 . (실시 예 2 참조)</target>
        </trans-unit>
        <trans-unit id="79c8cb706f1fcfacc217858c7c85ae02ae2f4052" translate="yes" xml:space="preserve">
          <source>Each element in the struct data has an accessor method, which is used to assign to the element and to fetch its value. The default accessor can be overridden by declaring a &lt;code&gt;sub&lt;/code&gt; of the same name in the package. (See Example 2.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd1373d9ec88c46f95e3a35afb96af5418baf7f3" translate="yes" xml:space="preserve">
          <source>Each element of &lt;code&gt;%!&lt;/code&gt; has a true value only if &lt;code&gt;$!&lt;/code&gt; is set to that value. For example, &lt;code&gt;$!{ENOENT}&lt;/code&gt; is true if and only if the current value of &lt;code&gt;$!&lt;/code&gt; is &lt;code&gt;ENOENT&lt;/code&gt; ; that is, if the most recent error was &quot;No such file or directory&quot; (or its moral equivalent: not all operating systems give that exact error, and certainly not all languages). To check if a particular key is meaningful on your system, use &lt;code&gt;&lt;a href=&quot;functions/exists&quot;&gt;exists&lt;/a&gt;
$!{the_key}&lt;/code&gt; ; for a list of legal keys, use &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt; %!&lt;/code&gt; . See &lt;a href=&quot;errno&quot;&gt;Errno&lt;/a&gt; for more information, and also see &lt;a href=&quot;#%24!&quot;&gt;$!&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;%!&lt;/code&gt; 각 요소 ! true 값 만이 &lt;code&gt;$!&lt;/code&gt; 해당 값으로 설정되어 있습니다. 예를 들어 &lt;code&gt;$!{ENOENT}&lt;/code&gt; 는 현재 값이 &lt;code&gt;$!&lt;/code&gt; 인 경우에만 true입니다 . 이다 &lt;code&gt;ENOENT&lt;/code&gt; 는 ; 즉, 가장 최근의 오류가 &quot;No such file or directory&quot;(또는 그러한 파일이나 디렉토리가 없음) 인 경우 (또는 그와 동등한 도덕적 : 모든 운영 체제가 정확한 오류를 제공하는 것은 아니며, 모든 언어가 아님) 특정 키가 시스템에 의미가 있는지 확인하려면, 사용은 &lt;code&gt;&lt;a href=&quot;functions/exists&quot;&gt;exists&lt;/a&gt; $!{the_key}&lt;/code&gt; ; 유효한 키 목록을 보려면 &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt; %!&lt;/code&gt; 사용하십시오 ! . 자세한 내용은 &lt;a href=&quot;errno&quot;&gt;Errno&lt;/a&gt; 를 참조하고 &lt;a href=&quot;#%24!&quot;&gt;$&lt;/a&gt; 도 참조하십시오 ! .</target>
        </trans-unit>
        <trans-unit id="e3f755ecf95a73dbcb1fefb62d992d2bd88e203f" translate="yes" xml:space="preserve">
          <source>Each element of &lt;code&gt;%!&lt;/code&gt; has a true value only if &lt;code&gt;$!&lt;/code&gt; is set to that value. For example, &lt;code&gt;$!{ENOENT}&lt;/code&gt; is true if and only if the current value of &lt;code&gt;$!&lt;/code&gt; is &lt;code&gt;ENOENT&lt;/code&gt;; that is, if the most recent error was &quot;No such file or directory&quot; (or its moral equivalent: not all operating systems give that exact error, and certainly not all languages). The specific true value is not guaranteed, but in the past has generally been the numeric value of &lt;code&gt;$!&lt;/code&gt;. To check if a particular key is meaningful on your system, use &lt;code&gt;exists $!{the_key}&lt;/code&gt;; for a list of legal keys, use &lt;code&gt;keys %!&lt;/code&gt;. See &lt;a href=&quot;errno&quot;&gt;Errno&lt;/a&gt; for more information, and also see &lt;a href=&quot;#%24%21&quot;&gt;&quot;$!&quot;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06a2d451f571f682ca87c1d143e9cc5d9cc9752a" translate="yes" xml:space="preserve">
          <source>Each element of the &lt;code&gt;@tests&lt;/code&gt; array is either:</source>
          <target state="translated">&lt;code&gt;@tests&lt;/code&gt; 배열 의 각 요소는 다음 중 하나입니다.</target>
        </trans-unit>
        <trans-unit id="d55ab66461652be4398995f0bc7395b92cdadc85" translate="yes" xml:space="preserve">
          <source>Each element on the right-hand side must be a reference to a datum of the right type. Parentheses immediately surrounding an array (and possibly also &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt;/&lt;code&gt;&lt;a href=&quot;functions/state&quot;&gt;state&lt;/a&gt;&lt;/code&gt;/&lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt;/&lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt;) will make each element of the array an alias to the corresponding scalar referenced on the right-hand side:</source>
          <target state="translated">오른쪽의 각 요소는 올바른 유형의 데이텀에 대한 참조 여야합니다. 배열을 둘러싼 괄호 (및 아마도 &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; / &lt;code&gt;&lt;a href=&quot;functions/state&quot;&gt;state&lt;/a&gt;&lt;/code&gt; / &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; / &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; )는 배열의 각 요소를 오른쪽에서 참조되는 해당 스칼라의 별칭으로 만듭니다.</target>
        </trans-unit>
        <trans-unit id="73d053df17de770313a9997b0c6b33ddac74a8d7" translate="yes" xml:space="preserve">
          <source>Each element on the right-hand side must be a reference to a datum of the right type. Parentheses immediately surrounding an array (and possibly also &lt;code&gt;my&lt;/code&gt;/&lt;code&gt;state&lt;/code&gt;/&lt;code&gt;our&lt;/code&gt;/&lt;code&gt;local&lt;/code&gt;) will make each element of the array an alias to the corresponding scalar referenced on the right-hand side:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4684b159123c6d2eb2be5f3fb5fb6b32cbd2c836" translate="yes" xml:space="preserve">
          <source>Each element's type can be scalar, array, hash, or class.</source>
          <target state="translated">각 요소의 유형은 스칼라, 배열, 해시 또는 클래스 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4a18db593068986b02fcc2822d10b93bd6ae4e04" translate="yes" xml:space="preserve">
          <source>Each engine is supposed to provide access to a constant structure of the following format:</source>
          <target state="translated">각 엔진은 다음 형식의 일정한 구조에 대한 액세스를 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="df21f7171545bb80d42912cbb46608328ace6052" translate="yes" xml:space="preserve">
          <source>Each field in a picture line starts with either &quot;@&quot; (at) or &quot;^&quot; (caret), indicating what we'll call, respectively, a &quot;regular&quot; or &quot;special&quot; field. The choice of pad characters determines whether a field is textual or numeric. The tilde operators are not part of a field. Let's look at the various possibilities in detail.</source>
          <target state="translated">그림 라인의 각 필드는 &quot;@&quot;(at) 또는 &quot;^&quot;(캐럿)으로 시작하며 각각 &quot;일반&quot;또는 &quot;특별&quot;필드라고 부릅니다. 패드 문자 선택은 필드가 텍스트인지 숫자인지를 결정합니다. 물결표 연산자는 필드의 일부가 아닙니다. 다양한 가능성을 자세하게 살펴 보자.</target>
        </trans-unit>
        <trans-unit id="e86751063b4744e62f491d3c6500569d32c72d11" translate="yes" xml:space="preserve">
          <source>Each filehandle in Perl counts the number of lines that have been read from it. (Depending on the value of &lt;code&gt;$/&lt;/code&gt; , Perl's idea of what constitutes a line may not match yours.) When a line is read from a filehandle (via &lt;code&gt;&lt;a href=&quot;functions/readline&quot;&gt;readline()&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; ), or when &lt;code&gt;&lt;a href=&quot;functions/tell&quot;&gt;tell()&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/seek&quot;&gt;seek()&lt;/a&gt;&lt;/code&gt; is called on it, &lt;code&gt;$.&lt;/code&gt; becomes an alias to the line counter for that filehandle.</source>
          <target state="translated">Perl의 각 파일 핸들은 읽은 행 수를 계산합니다. ( &lt;code&gt;$/&lt;/code&gt; 의 값에 따라 라인을 구성하는 것에 대한 Perl의 아이디어는 귀하의 라인과 일치하지 않을 수 있습니다.) 파일 핸들에서 라인을 읽을 때 ( &lt;code&gt;&lt;a href=&quot;functions/readline&quot;&gt;readline()&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; ), &lt;code&gt;&lt;a href=&quot;functions/tell&quot;&gt;tell()&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;functions/seek&quot;&gt;seek()&lt;/a&gt;&lt;/code&gt; 가 그것에 불렀다, &lt;code&gt;$.&lt;/code&gt; 해당 파일 핸들의 행 카운터에 대한 별명이됩니다.</target>
        </trans-unit>
        <trans-unit id="8e57c60a3cb6708806cfdda0d69fc8cd46dd15f5" translate="yes" xml:space="preserve">
          <source>Each filehandle in Perl counts the number of lines that have been read from it. (Depending on the value of &lt;code&gt;$/&lt;/code&gt;, Perl's idea of what constitutes a line may not match yours.) When a line is read from a filehandle (via &lt;code&gt;readline()&lt;/code&gt; or &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt;), or when &lt;code&gt;tell()&lt;/code&gt; or &lt;code&gt;seek()&lt;/code&gt; is called on it, &lt;code&gt;$.&lt;/code&gt; becomes an alias to the line counter for that filehandle.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31a9624b1b717a0ce3347c2a7723ee1a1d25abab" translate="yes" xml:space="preserve">
          <source>Each handle can be an &lt;code&gt;IO::Handle&lt;/code&gt; object, an integer or an array reference where the first element is an &lt;code&gt;IO::Handle&lt;/code&gt; or an integer.</source>
          <target state="translated">각 핸들은 &lt;code&gt;IO::Handle&lt;/code&gt; 객체, 정수 또는 첫 번째 요소가 &lt;code&gt;IO::Handle&lt;/code&gt; 또는 정수인 배열 참조 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c1d7462289e4cec1a7aa1fe4c855d903202ec597" translate="yes" xml:space="preserve">
          <source>Each hash &lt;code&gt;%{&quot;_&amp;lt;$filename&quot;}&lt;/code&gt; contains breakpoints and actions keyed by line number. Individual entries (as opposed to the whole hash) are settable. Perl only cares about Boolean true here, although the values used by</source>
          <target state="translated">각 해시 &lt;code&gt;%{&quot;_&amp;lt;$filename&quot;}&lt;/code&gt; 에는 줄 번호를 기준으로 중단 점과 작업이 포함되어 있습니다. 전체 항목과 달리 개별 항목을 설정할 수 있습니다. Perl은 여기에서 사용되는 값에도 불구하고 Boolean true에만 관심이 있습니다.</target>
        </trans-unit>
        <trans-unit id="62cc45eed91752b51404de9ea925a035fb43cbad" translate="yes" xml:space="preserve">
          <source>Each id must be unique within the document.</source>
          <target state="translated">각 ID는 문서 내에서 고유해야합니다.</target>
        </trans-unit>
        <trans-unit id="667975ad4758db6be064d162ec07e954e503457b" translate="yes" xml:space="preserve">
          <source>Each individual compressed data stream is read until the logical end-of-file is reached. Then &lt;code&gt;nextStream&lt;/code&gt; is called. This will skip to the start of the next compressed data stream and clear the end-of-file flag.</source>
          <target state="translated">논리적 개별 파일 끝에 도달 할 때까지 각 개별 압축 데이터 스트림을 읽습니다. 그런 다음 &lt;code&gt;nextStream&lt;/code&gt; 이 호출됩니다. 이것은 다음 압축 데이터 스트림의 시작으로 건너 뛰고 파일 끝 플래그를 지 웁니다.</target>
        </trans-unit>
        <trans-unit id="18f2cec26478e04f9b7de7d10fcbddee95e58d2c" translate="yes" xml:space="preserve">
          <source>Each initializer is a pair of values:</source>
          <target state="translated">각 이니셜 라이저는 한 쌍의 값입니다.</target>
        </trans-unit>
        <trans-unit id="16164820a467e235638c757ccfe00052f4c79b5f" translate="yes" xml:space="preserve">
          <source>Each is a reference to an array of hostnames (in order of preference), which should be used for the given protocol</source>
          <target state="translated">각각은 주어진 프로토콜에 사용해야하는 호스트 이름의 배열에 대한 참조입니다 (기본 설정 순서대로).</target>
        </trans-unit>
        <trans-unit id="d29b86c40a3e654b348fa005424d750255213988" translate="yes" xml:space="preserve">
          <source>Each is an instance of a class with the following methods:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0eab90b97db650ebd8f6bc0b1085529dd6f2a05" translate="yes" xml:space="preserve">
          <source>Each key is the property name in its longest, most descriptive form. The values are what &lt;a href=&quot;#charprop%28%29&quot;&gt;&quot;charprop()&quot;&lt;/a&gt; would return.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7c5e455da6b08e4d8e8bc9f42db356fdab7233a" translate="yes" xml:space="preserve">
          <source>Each key is the property name in its longest, most descriptive form. The values are what &lt;a href=&quot;#charprop()&quot;&gt;charprop()&lt;/a&gt; would return.</source>
          <target state="translated">각 키는 가장 길고 가장 설명적인 형식의 속성 이름입니다. 값은 무엇입니까 &lt;a href=&quot;#charprop()&quot;&gt;charprop ()&lt;/a&gt; 반환합니다.</target>
        </trans-unit>
        <trans-unit id="47492265b46ae806bb067e9b524f132422627a4f" translate="yes" xml:space="preserve">
          <source>Each letter may optionally be followed by a number indicating the repeat count. A numeric repeat count may optionally be enclosed in brackets, as in &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;(&quot;C[80]&quot;, @arr)&lt;/code&gt; . The repeat count gobbles that many values from the LIST when used with all format types other than &lt;code&gt;a&lt;/code&gt; , &lt;code&gt;A&lt;/code&gt; , &lt;code&gt;Z&lt;/code&gt; , &lt;code&gt;b&lt;/code&gt; , &lt;code&gt;B&lt;/code&gt; , &lt;code&gt;h&lt;/code&gt; , &lt;code&gt;H&lt;/code&gt; , &lt;code&gt;@&lt;/code&gt; , &lt;code&gt;.&lt;/code&gt;, &lt;code&gt;x&lt;/code&gt; , &lt;code&gt;X&lt;/code&gt; , and &lt;code&gt;P&lt;/code&gt; , where it means something else, described below. Supplying a &lt;code&gt;*&lt;/code&gt; for the repeat count instead of a number means to use however many items are left, except for:</source>
          <target state="translated">각 문자 다음에는 반복 횟수를 나타내는 숫자가 선택적으로 올 수 있습니다. &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;(&quot;C[80]&quot;, @arr)&lt;/code&gt; 에서와 같이 숫자 반복 횟수는 선택적으로 대괄호로 묶을 수 있습니다 . 반복 횟수는 &lt;code&gt;a&lt;/code&gt; , &lt;code&gt;A&lt;/code&gt; , &lt;code&gt;Z&lt;/code&gt; , &lt;code&gt;b&lt;/code&gt; , &lt;code&gt;B&lt;/code&gt; , &lt;code&gt;h&lt;/code&gt; , &lt;code&gt;H&lt;/code&gt; , &lt;code&gt;@&lt;/code&gt; , 이외 의 모든 형식 유형과 함께 사용될 때 LIST에서 많은 값을 가져옵니다 &lt;code&gt;.&lt;/code&gt; , &lt;code&gt;x&lt;/code&gt; , &lt;code&gt;X&lt;/code&gt; , &lt;code&gt;P&lt;/code&gt; 는 아래에 설명 된 다른 의미입니다. 공급 &lt;code&gt;*&lt;/code&gt; 숫자 대신 반복 횟수는 다음을 제외하고 많은 항목이 남아 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="f1b93edbbeb731023c3dcd7b867f87661f785306" translate="yes" xml:space="preserve">
          <source>Each letter may optionally be followed by a number indicating the repeat count. A numeric repeat count may optionally be enclosed in brackets, as in &lt;code&gt;&lt;a href=&quot;pack&quot;&gt;pack&lt;/a&gt;(&quot;C[80]&quot;, @arr)&lt;/code&gt; . The repeat count gobbles that many values from the LIST when used with all format types other than &lt;code&gt;a&lt;/code&gt; , &lt;code&gt;A&lt;/code&gt; , &lt;code&gt;Z&lt;/code&gt; , &lt;code&gt;b&lt;/code&gt; , &lt;code&gt;B&lt;/code&gt; , &lt;code&gt;h&lt;/code&gt; , &lt;code&gt;H&lt;/code&gt; , &lt;code&gt;@&lt;/code&gt; , &lt;code&gt;.&lt;/code&gt;, &lt;code&gt;x&lt;/code&gt; , &lt;code&gt;X&lt;/code&gt; , and &lt;code&gt;P&lt;/code&gt; , where it means something else, described below. Supplying a &lt;code&gt;*&lt;/code&gt; for the repeat count instead of a number means to use however many items are left, except for:</source>
          <target state="translated">각 문자 다음에는 반복 횟수를 나타내는 숫자가 선택적으로 올 수 있습니다. &lt;code&gt;&lt;a href=&quot;pack&quot;&gt;pack&lt;/a&gt;(&quot;C[80]&quot;, @arr)&lt;/code&gt; 에서와 같이 숫자 반복 횟수는 선택적으로 대괄호로 묶을 수 있습니다 . 반복 횟수는 &lt;code&gt;a&lt;/code&gt; , &lt;code&gt;A&lt;/code&gt; , &lt;code&gt;Z&lt;/code&gt; , &lt;code&gt;b&lt;/code&gt; , &lt;code&gt;B&lt;/code&gt; , &lt;code&gt;h&lt;/code&gt; , &lt;code&gt;H&lt;/code&gt; , &lt;code&gt;@&lt;/code&gt; , 이외 의 모든 형식 유형과 함께 사용될 때 LIST에서 많은 값을 가져옵니다 &lt;code&gt;.&lt;/code&gt; , &lt;code&gt;x&lt;/code&gt; , &lt;code&gt;X&lt;/code&gt; , &lt;code&gt;P&lt;/code&gt; 는 아래에 설명 된 다른 의미입니다. 공급 &lt;code&gt;*&lt;/code&gt; 숫자 대신 반복 횟수는 다음을 제외하고 많은 항목이 남아 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="0ed7a060f431ab2cc494847effa3cd5278eb7c4f" translate="yes" xml:space="preserve">
          <source>Each letter may optionally be followed by a number indicating the repeat count. A numeric repeat count may optionally be enclosed in brackets, as in &lt;code&gt;pack(&quot;C[80]&quot;, @arr)&lt;/code&gt;. The repeat count gobbles that many values from the LIST when used with all format types other than &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;A&lt;/code&gt;, &lt;code&gt;Z&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt;, &lt;code&gt;B&lt;/code&gt;, &lt;code&gt;h&lt;/code&gt;, &lt;code&gt;H&lt;/code&gt;, &lt;code&gt;@&lt;/code&gt;, &lt;code&gt;.&lt;/code&gt;, &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;X&lt;/code&gt;, and &lt;code&gt;P&lt;/code&gt;, where it means something else, described below. Supplying a &lt;code&gt;*&lt;/code&gt; for the repeat count instead of a number means to use however many items are left, except for:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ca2b686ea513abcdcd81b004dc80b72da247c37" translate="yes" xml:space="preserve">
          <source>Each locale key is a reference to a hash that has the form above, and gives the casing rules for that particular locale, which take precedence over the locale-independent ones when in that locale.</source>
          <target state="translated">각 로케일 키는 위 형식의 해시에 대한 참조이며 해당 로케일에있을 때 로케일 독립적 인 키보다 우선하는 특정 로케일에 대한 케이싱 규칙을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="b81c66f6a67c62b4046a77844c9acd84b539087f" translate="yes" xml:space="preserve">
          <source>Each method returns the old value of the &lt;code&gt;IO::Handle&lt;/code&gt; attribute. The methods each take an optional EXPR, which, if supplied, specifies the new value for the &lt;code&gt;IO::Handle&lt;/code&gt; attribute in question. If not supplied, most methods do nothing to the current value--except for &lt;code&gt;autoflush()&lt;/code&gt; , which will assume a 1 for you, just to be different.</source>
          <target state="translated">각 메소드는 &lt;code&gt;IO::Handle&lt;/code&gt; 속성 의 이전 값을 리턴 합니다. 메소드는 각각 옵션 인 EXPR을 사용하며, 제공되는 경우 해당 &lt;code&gt;IO::Handle&lt;/code&gt; 속성 의 새 값을 지정합니다 . 제공되지 않은 경우 대부분의 메소드는 현재 값에 아무런 영향을 미치지 않습니다. &lt;code&gt;autoflush()&lt;/code&gt; 예외입니다 .</target>
        </trans-unit>
        <trans-unit id="549fa064c8357d58112301aba532e091511a4996" translate="yes" xml:space="preserve">
          <source>Each method returns the old value of the &lt;code&gt;IO::Handle&lt;/code&gt; attribute. The methods each take an optional EXPR, which, if supplied, specifies the new value for the &lt;code&gt;IO::Handle&lt;/code&gt; attribute in question. If not supplied, most methods do nothing to the current value--except for &lt;code&gt;autoflush()&lt;/code&gt;, which will assume a 1 for you, just to be different.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a408a79f13c6ec4a0cd81e57c787564393f289b" translate="yes" xml:space="preserve">
          <source>Each name-type pair declares one element of the struct. Each element name will be defined as an accessor method unless a method by that name is explicitly defined; in the latter case, a warning is issued if the warning flag (&lt;b&gt;-w&lt;/b&gt;) is set.</source>
          <target state="translated">각 이름 유형 쌍은 구조체의 한 요소를 선언합니다. 각 요소 이름은 해당 이름의 메소드가 명시 적으로 정의되지 않은 한 접근 자 메소드로 정의됩니다. 후자의 경우 경고 플래그 ( &lt;b&gt;-w&lt;/b&gt; )가 설정 되면 경고가 발행됩니다 .</target>
        </trans-unit>
        <trans-unit id="bea2fa8177204a00acbe330d65cd373309740d46" translate="yes" xml:space="preserve">
          <source>Each of the &lt;code&gt;$section_spec&lt;/code&gt; arguments should be a section specification as described in &lt;a href=&quot;#SECTION-SPECIFICATIONS&quot;&gt;SECTION SPECIFICATIONS&lt;/a&gt;. The section specifications are parsed by this method and the resulting regular expressions are stored in the invoking object.</source>
          <target state="translated">각 &lt;code&gt;$section_spec&lt;/code&gt; 인수는 &lt;a href=&quot;#SECTION-SPECIFICATIONS&quot;&gt;SECTION SPECIFICATIONS에&lt;/a&gt; 설명 된 섹션 스펙이어야합니다 . 섹션 스펙은이 메소드에 의해 구문 분석되며 결과 정규식은 호출 오브젝트에 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="9af6792ba1f44d7cb824f7440960f3ef5c01b6ba" translate="yes" xml:space="preserve">
          <source>Each of the POSIX classes matches exactly the same as their ASCII-range counterparts.</source>
          <target state="translated">각 POSIX 클래스는 ASCII 범위의 클래스와 정확히 일치합니다.</target>
        </trans-unit>
        <trans-unit id="be167c32ebe292b1abf425a82a9d67c142fdc9a5" translate="yes" xml:space="preserve">
          <source>Each of the argument lists above comes out of the &lt;code&gt;normalize_f&lt;/code&gt; function looking exactly the same, like this:</source>
          <target state="translated">위의 각 인수 목록은 다음과 같이 정확하게 동일한 &lt;code&gt;normalize_f&lt;/code&gt; 함수 에서 나옵니다 .</target>
        </trans-unit>
        <trans-unit id="93679dc7d627c4c7a6a3897712645c4450ba1379" translate="yes" xml:space="preserve">
          <source>Each of the commands that produce listings of modules (&lt;code&gt;r&lt;/code&gt; , &lt;code&gt;autobundle&lt;/code&gt; , &lt;code&gt;u&lt;/code&gt; ) also return a list of the IDs of all modules within the list.</source>
          <target state="translated">모듈 목록 ( &lt;code&gt;r&lt;/code&gt; , &lt;code&gt;autobundle&lt;/code&gt; , &lt;code&gt;u&lt;/code&gt; ) 을 생성하는 각 명령 은 목록에있는 모든 모듈의 ID 목록도 반환합니다.</target>
        </trans-unit>
        <trans-unit id="36a145ce6b55d2eacd4e152e8b778cb0812f1b4c" translate="yes" xml:space="preserve">
          <source>Each of the elementary pieces of regular expressions which were described before (such as &lt;code&gt;ab&lt;/code&gt; or &lt;code&gt;\Z&lt;/code&gt; ) could match at most one substring at the given position of the input string. However, in a typical regular expression these elementary pieces are combined into more complicated patterns using combining operators &lt;code&gt;ST&lt;/code&gt; , &lt;code&gt;S|T&lt;/code&gt; , &lt;code&gt;S*&lt;/code&gt; etc. (in these examples &lt;code&gt;S&lt;/code&gt; and &lt;code&gt;T&lt;/code&gt; are regular subexpressions).</source>
          <target state="translated">이전에 설명한 정규 표현식의 각 기본 조각 (예 : &lt;code&gt;ab&lt;/code&gt; 또는 &lt;code&gt;\Z&lt;/code&gt; )은 입력 문자열의 지정된 위치에서 최대 하나의 하위 문자열과 일치 할 수 있습니다. 그러나, 전형적인 정규식에서, 이러한 기본 조각들은 결합 연산자 &lt;code&gt;ST&lt;/code&gt; , &lt;code&gt;S|T&lt;/code&gt; , &lt;code&gt;S*&lt;/code&gt; 등을 사용하여보다 복잡한 패턴으로 결합된다 (이 예에서 &lt;code&gt;S&lt;/code&gt; 및 &lt;code&gt;T&lt;/code&gt; 는 규칙적인 하위 표현이다).</target>
        </trans-unit>
        <trans-unit id="c1f94498db7cafa14ac711805deae194684f4e3e" translate="yes" xml:space="preserve">
          <source>Each of the elementary pieces of regular expressions which were described before (such as &lt;code&gt;ab&lt;/code&gt; or &lt;code&gt;\Z&lt;/code&gt;) could match at most one substring at the given position of the input string. However, in a typical regular expression these elementary pieces are combined into more complicated patterns using combining operators &lt;code&gt;ST&lt;/code&gt;, &lt;code&gt;S|T&lt;/code&gt;, &lt;code&gt;S*&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf85de30bb2350d06139ae6bc58a79af96a26e97" translate="yes" xml:space="preserve">
          <source>Each of the following invocations of &lt;code&gt;pod2usage()&lt;/code&gt; will print a message of &quot;Syntax error.&quot; (followed by a newline) to &lt;code&gt;STDERR&lt;/code&gt; , immediately followed by just the &quot;SYNOPSIS&quot; section (also printed to &lt;code&gt;STDERR&lt;/code&gt; ) and will exit with a status of 2:</source>
          <target state="translated">다음의 &lt;code&gt;pod2usage()&lt;/code&gt; 호출 은 &quot;구문 오류&quot;메시지를 인쇄합니다. (개행 문자 다음에) &lt;code&gt;STDERR&lt;/code&gt; 에 바로 다음에 &quot;SYNOPSIS&quot;섹션 ( &lt;code&gt;STDERR&lt;/code&gt; 에 인쇄 됨 ) 바로 다음에 상태 2로 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="c471e82fa0389f6962922185f6c1c022a3af5d32" translate="yes" xml:space="preserve">
          <source>Each of the following invocations of &lt;code&gt;pod2usage()&lt;/code&gt; will print a message of &quot;Syntax error.&quot; (followed by a newline) to &lt;code&gt;STDERR&lt;/code&gt;, immediately followed by just the &quot;SYNOPSIS&quot; section (also printed to &lt;code&gt;STDERR&lt;/code&gt;) and will exit with a status of 2:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da247936c8bb95b82240dfbb57e8459e5c728eb2" translate="yes" xml:space="preserve">
          <source>Each of the following invocations of &lt;code&gt;pod2usage()&lt;/code&gt; will print just the &quot;SYNOPSIS&quot; section to &lt;code&gt;STDERR&lt;/code&gt; and will exit with a status of 2:</source>
          <target state="translated">다음의 &lt;code&gt;pod2usage()&lt;/code&gt; 호출은 각각 &quot;SYNOPSIS&quot;섹션 만 &lt;code&gt;STDERR&lt;/code&gt; 로 인쇄 하고 상태가 2로 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="c3bf15a510b108560bc55f9dc642118c67f04409" translate="yes" xml:space="preserve">
          <source>Each of the following invocations of &lt;code&gt;pod2usage()&lt;/code&gt; will print the &quot;SYNOPSIS&quot; section and any &quot;OPTIONS&quot; and/or &quot;ARGUMENTS&quot; sections to &lt;code&gt;STDOUT&lt;/code&gt; and will exit with a status of 1:</source>
          <target state="translated">다음의 &lt;code&gt;pod2usage()&lt;/code&gt; 호출은 각각 &quot;SYNOPSIS&quot;섹션 및 &quot;OPTIONS&quot;및 / 또는 &quot;ARGUMENTS&quot;섹션을 &lt;code&gt;STDOUT&lt;/code&gt; 에 인쇄 하고 상태가 1로 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="8a8549150e98bb7d0199412efeddf54defc2c85f" translate="yes" xml:space="preserve">
          <source>Each of the following invocations of &lt;code&gt;pod2usage()&lt;/code&gt; will print the entire manual page to &lt;code&gt;STDOUT&lt;/code&gt; and will exit with a status of 1:</source>
          <target state="translated">다음의 &lt;code&gt;pod2usage()&lt;/code&gt; 호출은 전체 매뉴얼 페이지를 &lt;code&gt;STDOUT&lt;/code&gt; 으로 인쇄하고 상태 1로 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="159291495d574283955b7dd83a0159a4cbe57ab7" translate="yes" xml:space="preserve">
          <source>Each of the following methods will return the total number of corresponding tests if called in scalar context. If called in list context, returns the descriptions of the parsers which contain the corresponding tests (see &lt;code&gt;add&lt;/code&gt; for an explanation of description.</source>
          <target state="translated">다음 각 메소드는 스칼라 컨텍스트에서 호출 된 경우 해당 테스트의 총 수를 리턴합니다. 목록 컨텍스트에서 호출되면 해당 테스트가 포함 된 구문 분석기의 설명을 리턴합니다 (설명에 대한 설명은 &lt;code&gt;add&lt;/code&gt; 참조) .</target>
        </trans-unit>
        <trans-unit id="b4805d0a6e23a882a6f379f5e1aaffac33d67fcd" translate="yes" xml:space="preserve">
          <source>Each of the functions will now be discussed in turn.</source>
          <target state="translated">각 기능에 대해 차례로 설명합니다.</target>
        </trans-unit>
        <trans-unit id="cf8ee854b23795d139b708dbd25340dc64f25e5b" translate="yes" xml:space="preserve">
          <source>Each of the functions will return</source>
          <target state="translated">각 함수는</target>
        </trans-unit>
        <trans-unit id="67d949b14cef9bc96632c4a26c1317dd5c052479" translate="yes" xml:space="preserve">
          <source>Each of the integer pack codes &lt;code&gt;sSlLqQ&lt;/code&gt; results in a fixed number of bytes, no matter where you execute your program. This may be useful for some applications, but it does not provide for a portable way to pass data structures between Perl and C programs (bound to happen when you call XS extensions or the Perl function &lt;code&gt;&lt;a href=&quot;functions/syscall&quot;&gt;syscall&lt;/a&gt;&lt;/code&gt;), or when you read or write binary files. What you'll need in this case are template codes that depend on what your local C compiler compiles when you code &lt;code&gt;short&lt;/code&gt; or &lt;code&gt;unsigned long&lt;/code&gt; , for instance. These codes and their corresponding byte lengths are shown in the table below. Since the C standard leaves much leeway with respect to the relative sizes of these data types, actual values may vary, and that's why the values are given as expressions in C and Perl. (If you'd like to use values from &lt;code&gt;%Config&lt;/code&gt; in your program you have to import it with &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; Config&lt;/code&gt; .)</source>
          <target state="translated">정수 팩 코드 &lt;code&gt;sSlLqQ&lt;/code&gt; 는 프로그램 실행 위치에 관계없이 고정 된 바이트 수를 생성합니다. 이것은 일부 응용 프로그램에는 유용 ​​할 수 있지만 Perl과 C 프로그램간에 데이터 구조를 전달하는 이식 가능한 방법 (XS 확장 또는 Perl 함수 &lt;code&gt;&lt;a href=&quot;functions/syscall&quot;&gt;syscall&lt;/a&gt;&lt;/code&gt; 을 호출 할 때 발생 함 ) 또는 이진 파일을 읽거나 쓸 때 제공되지 않습니다. . 이 경우에 필요한 것은 &lt;code&gt;short&lt;/code&gt; 거나 &lt;code&gt;unsigned long&lt;/code&gt; 을 코딩 할 때 로컬 C 컴파일러가 컴파일하는 것에 의존하는 템플릿 코드입니다.예를 들어. 이 코드와 해당 바이트 길이는 아래 표에 나와 있습니다. C 표준은 이러한 데이터 유형의 상대적 크기와 관련하여 많은 여유를 가지기 때문에 실제 값은 다를 수 있으므로 값이 C 및 Perl의 표현식으로 제공됩니다. ( 프로그램 에서 &lt;code&gt;%Config&lt;/code&gt; 값을 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; Config&lt;/code&gt; 를 사용 하여 가져와야합니다 .)</target>
        </trans-unit>
        <trans-unit id="6060e81492ddf46249708e305af675d2cd8e4300" translate="yes" xml:space="preserve">
          <source>Each of the integer pack codes &lt;code&gt;sSlLqQ&lt;/code&gt; results in a fixed number of bytes, no matter where you execute your program. This may be useful for some applications, but it does not provide for a portable way to pass data structures between Perl and C programs (bound to happen when you call XS extensions or the Perl function &lt;code&gt;syscall&lt;/code&gt;), or when you read or write binary files. What you'll need in this case are template codes that depend on what your local C compiler compiles when you code &lt;code&gt;short&lt;/code&gt; or &lt;code&gt;unsigned long&lt;/code&gt;, for instance. These codes and their corresponding byte lengths are shown in the table below. Since the C standard leaves much leeway with respect to the relative sizes of these data types, actual values may vary, and that's why the values are given as expressions in C and Perl. (If you'd like to use values from &lt;code&gt;%Config&lt;/code&gt; in your program you have to import it with &lt;code&gt;use Config&lt;/code&gt;.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="35d0d0049982558d7e176e2f3ab3ea596bc6e428" translate="yes" xml:space="preserve">
          <source>Each of the methods below (except config(), accuracy() and precision()) accepts three additional parameters. These arguments &lt;code&gt;$A&lt;/code&gt; , &lt;code&gt;$P&lt;/code&gt; and &lt;code&gt;$R&lt;/code&gt; are &lt;code&gt;accuracy&lt;/code&gt; , &lt;code&gt;precision&lt;/code&gt; and &lt;code&gt;round_mode&lt;/code&gt; . Please see the section about &lt;a href=&quot;#ACCURACY-and-PRECISION&quot;&gt;ACCURACY and PRECISION&lt;/a&gt; for more information.</source>
          <target state="translated">아래의 각 메소드 (config (), precision () 및 precision () 제외)는 세 개의 추가 매개 변수를 허용합니다. 이러한 인수 &lt;code&gt;$A&lt;/code&gt; , &lt;code&gt;$P&lt;/code&gt; 및 &lt;code&gt;$R&lt;/code&gt; 은 &lt;code&gt;accuracy&lt;/code&gt; , &lt;code&gt;precision&lt;/code&gt; 및 &lt;code&gt;round_mode&lt;/code&gt; 입니다. 자세한 내용은 &lt;a href=&quot;#ACCURACY-and-PRECISION&quot;&gt;정확성 및 정밀성&lt;/a&gt; 섹션 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="2d2b46938dbf24928125c2dd236a1a486381e417" translate="yes" xml:space="preserve">
          <source>Each of the methods below (except config(), accuracy() and precision()) accepts three additional parameters. These arguments &lt;code&gt;$A&lt;/code&gt;, &lt;code&gt;$P&lt;/code&gt; and &lt;code&gt;$R&lt;/code&gt; are &lt;code&gt;accuracy&lt;/code&gt;, &lt;code&gt;precision&lt;/code&gt; and &lt;code&gt;round_mode&lt;/code&gt;. Please see the section about &lt;a href=&quot;#ACCURACY-and-PRECISION&quot;&gt;&quot;ACCURACY and PRECISION&quot;&lt;/a&gt; for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69bb55af40d1c4ccf668c4ee509cae7b3650aeb0" translate="yes" xml:space="preserve">
          <source>Each of the methods works identically, and is used to install (or uninstall) a single DBM Filter. The only difference between them is the place that the filter is installed.</source>
          <target state="translated">각 방법은 동일하게 작동하며 단일 DBM 필터를 설치 (또는 설치 제거)하는 데 사용됩니다. 그들 사이의 유일한 차이점은 필터가 설치된 장소입니다.</target>
        </trans-unit>
        <trans-unit id="d70d3afe0fc2fcaf924f4e6c71f92047845119e3" translate="yes" xml:space="preserve">
          <source>Each of the targets is created only once (but see &lt;a href=&quot;#Scratchpads-and-recursion&quot;&gt;&quot;Scratchpads and recursion&quot;&lt;/a&gt; below), and when an opcode needs to put an integer, a double, or a string on stack, it just sets the corresponding parts of its</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="deb52f34c0e7c886d38c077a6693f8fac31c72b2" translate="yes" xml:space="preserve">
          <source>Each of the targets is created only once (but see &lt;a href=&quot;#Scratchpads-and-recursion&quot;&gt;Scratchpads and recursion&lt;/a&gt; below), and when an opcode needs to put an integer, a double, or a string on stack, it just sets the corresponding parts of its</source>
          <target state="translated">각 대상은 한 번만 생성되지만 (아래의 &lt;a href=&quot;#Scratchpads-and-recursion&quot;&gt;스크래치 패드 및 재귀&lt;/a&gt; 참조) opcode가 정수, 이중 또는 문자열을 스택에 배치해야하는 경우 해당 대상의 해당 부분 만 설정합니다.</target>
        </trans-unit>
        <trans-unit id="61645526a5f8cc5b5b38c365e573e3b9ce2a363a" translate="yes" xml:space="preserve">
          <source>Each of these areas will be discussed in the following sections.</source>
          <target state="translated">이러한 각 영역에 대해서는 다음 섹션에서 설명합니다.</target>
        </trans-unit>
        <trans-unit id="4a7e0927366cb3008e3cb582f1225e023afb76ec" translate="yes" xml:space="preserve">
          <source>Each of these functions are called without arguments and return the absolute path of the current working directory.</source>
          <target state="translated">이러한 각 함수는 인수없이 호출되며 현재 작업 디렉토리의 절대 경로를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="fb6c26bfd690fb609fa0a362b968489c94f785d7" translate="yes" xml:space="preserve">
          <source>Each of these input objects are described in further detail in the sections which follow.</source>
          <target state="translated">이러한 입력 개체 각각에 대해서는 다음 섹션에서 자세히 설명합니다.</target>
        </trans-unit>
        <trans-unit id="cd0ac943df3c5c0919c257e9e2ba53e934e28e43" translate="yes" xml:space="preserve">
          <source>Each of these methods may modify the first input argument, except</source>
          <target state="translated">이러한 각 메소드는 첫 번째 입력 인수를 수정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="94636e821462a702e9dcf821156451ce10166f58" translate="yes" xml:space="preserve">
          <source>Each of these methods may modify the first input argument.</source>
          <target state="translated">이러한 각 메소드는 첫 번째 입력 인수를 수정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1fd6321d309f67bf764c8af9cff581fae0812fa5" translate="yes" xml:space="preserve">
          <source>Each of these nodes represents an op, a fundamental operation inside the Perl core. The code which implements each operation can be found in the</source>
          <target state="translated">이러한 각 노드는 Perl 코어 내부의 기본 작업 인 op를 나타냅니다. 각 작업을 구현하는 코드는</target>
        </trans-unit>
        <trans-unit id="eb5de442d3b4d44516edecf88d3338777e703e96" translate="yes" xml:space="preserve">
          <source>Each of these objects may be replaced by calling one of these parser methods:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33d6b2a3cedc47a8c8496247740303b046f066c7" translate="yes" xml:space="preserve">
          <source>Each of these options is optional; you can include some, all, or none of them.</source>
          <target state="translated">이러한 각 옵션은 선택 사항입니다. 일부를 포함하거나 전혀 포함하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b15a1940399791f7b94602b4451362ab540da911" translate="yes" xml:space="preserve">
          <source>Each of these routines accepts a file specification in either VMS or Unix syntax, and returns the converted file specification, or &lt;code&gt;undef&lt;/code&gt; if an error occurs. The conversions are, for the most part, simply string manipulations; the routines do not check the details of syntax (e.g. that only legal characters are used). There is one exception: when running under VMS, conversions from VMS syntax use the $PARSE service to expand specifications, so illegal syntax, or a relative directory specification which extends above the tope of the current directory path (e.g [---.foo] when in dev:[dir.sub]) will cause errors. In general, any legal file specification will be converted properly, but garbage input tends to produce garbage output.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="86b7bd343bf185137324ab08afba721e66b470a2" translate="yes" xml:space="preserve">
          <source>Each of these routines is prototyped as taking a single scalar argument, so you can use them as unary operators in complex expressions (as long as you don't use the &lt;code&gt;&amp;amp;&lt;/code&gt; form of subroutine call, which bypasses prototype checking).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33fde8ca981b648a0a7df0eccad95608e9bb268d" translate="yes" xml:space="preserve">
          <source>Each op is preceded by two pointers: one points to the next op in the slab, and the other points to the slab that owns it. The next-op pointer is needed so that Perl can iterate over a slab and free all its ops. (Op structures are of different sizes, so the slab's ops can't merely be treated as a dense array.) The slab pointer is needed for accessing a reference count on the slab: when the last op on a slab is freed, the slab itself is freed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1f0b67ca5c809a794efbf846b5f11a39a783c34" translate="yes" xml:space="preserve">
          <source>Each operand is considered in a modified scalar context, the modification being that array and hash variables are passed by reference to the operator, which implicitly dereferences them. Both elements of each pair are the same:</source>
          <target state="translated">각 피연산자는 수정 된 스칼라 컨텍스트에서 고려되며, 수정은 배열 및 해시 변수가 연산자에 대한 참조로 전달되므로 암시 적으로 역 참조됩니다. 각 쌍의 두 요소는 동일합니다.</target>
        </trans-unit>
        <trans-unit id="76254c26642feac52117b7e65ad2b643499a9d47" translate="yes" xml:space="preserve">
          <source>Each operator has both a terse name (its opname) and a more verbose or recognisable descriptive name. The opdesc function can be used to return a list of descriptions for a list of operators.</source>
          <target state="translated">각 연산자에는 간결한 이름 (opname)과보다 자세하거나 알기 쉬운 설명 이름이 있습니다. opdesc 함수는 연산자 목록에 대한 설명 목록을 리턴하는 데 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0ffccbf8d7d785427858064bfe414c9a343b8478" translate="yes" xml:space="preserve">
          <source>Each option specifier consists of two parts: the name specification and the argument specification.</source>
          <target state="translated">각 옵션 지정자는 이름 스펙과 인수 스펙의 두 부분으로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="49dbe9df44df46422e8ed79c89a972f7e0a049b6" translate="yes" xml:space="preserve">
          <source>Each package contains a special array called &lt;code&gt;@ISA&lt;/code&gt; . The &lt;code&gt;@ISA&lt;/code&gt; array contains a list of that class's parent classes, if any. This array is examined when Perl does method resolution, which we will cover later.</source>
          <target state="translated">각 패키지에는 &lt;code&gt;@ISA&lt;/code&gt; 라는 특수 배열이 포함되어 있습니다 . &lt;code&gt;@ISA&lt;/code&gt; 에 있는 경우 배열은, 그 클래스의 부모 클래스의 목록이 포함되어 있습니다. 이 배열은 Perl이 메소드 분석을 수행 할 때 검토되며, 나중에 다루겠습니다.</target>
        </trans-unit>
        <trans-unit id="ddf57d8082b4349ec2c54b6a8bdc282825375550" translate="yes" xml:space="preserve">
          <source>Each package contains a special array called &lt;code&gt;@ISA&lt;/code&gt; which contains a list of that class's parent classes, if any. This array is simply a list of scalars, each of which is a string that corresponds to a package name. The array is examined when Perl does method resolution, which is covered in &lt;a href=&quot;perlobj&quot;&gt;perlobj&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9236fa90d77c1443c1fcc30f0eb2e90c48b3b452" translate="yes" xml:space="preserve">
          <source>Each package contains a special array called &lt;code&gt;@ISA&lt;/code&gt;. The &lt;code&gt;@ISA&lt;/code&gt; array contains a list of that class's parent classes, if any. This array is examined when Perl does method resolution, which we will cover later.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd56746947dceb1b1ebf83666e64df3d893f0573" translate="yes" xml:space="preserve">
          <source>Each pair is an array reference with two elements - namely the</source>
          <target state="translated">각 쌍은 두 가지 요소가있는 배열 참조입니다.</target>
        </trans-unit>
        <trans-unit id="79339b4554cd8ab3b93700df12bacff7c6d9a530" translate="yes" xml:space="preserve">
          <source>Each pathname that is a directory that matches the pattern has a slash appended.</source>
          <target state="translated">패턴과 일치하는 디렉토리 인 각 경로 이름에는 슬래시가 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="20b56d27482026f6b453dfe18f7f652ebd744ed0" translate="yes" xml:space="preserve">
          <source>Each plugin should register itself by providing the following structure</source>
          <target state="translated">각 플러그인은 다음 구조를 제공하여 자체적으로 등록해야합니다.</target>
        </trans-unit>
        <trans-unit id="4bc675eeb53212d68aff2215974b513fa9d0ff3e" translate="yes" xml:space="preserve">
          <source>Each programmer will, of course, have his or her own preferences in regards to formatting, but there are some general guidelines that will make your programs easier to read, understand, and maintain.</source>
          <target state="translated">물론 각 프로그래머는 형식과 관련하여 자신의 취향을 갖지만 프로그램을보다 쉽게 ​​읽고 이해하고 유지하는 데 도움이되는 일반적인 지침이 있습니다.</target>
        </trans-unit>
        <trans-unit id="e2d7e5e3cbcd85e0f15e433073f3c09c16649807" translate="yes" xml:space="preserve">
          <source>Each pseudo-process maintains its own virtual environment. Modifications to %ENV affect the virtual environment, and are only visible within that pseudo-process, and in any processes (or pseudo-processes) launched from it.</source>
          <target state="translated">각 의사 프로세스는 자체 가상 환경을 유지 관리합니다. % ENV에 대한 수정 사항은 가상 환경에 영향을 미치며 해당 의사 프로세스 및 해당 프로세스에서 시작된 프로세스 (또는 의사 프로세스)에서만 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="25a97b930031adadf111787667688ded94505539" translate="yes" xml:space="preserve">
          <source>Each pseudo-process maintains its own virtual idea of the current directory. Modifications to the current directory using chdir() are only visible within that pseudo-process, and in any processes (or pseudo-processes) launched from it. All file and directory accesses from the pseudo-process will correctly map the virtual working directory to the real working directory appropriately.</source>
          <target state="translated">각 의사 프로세스는 현재 디렉토리에 대한 자체 가상 아이디어를 유지합니다. chdir ()을 사용하여 현재 디렉토리에 대한 수정은 해당 의사 프로세스와 해당 프로세스에서 시작된 프로세스 (또는 의사 프로세스)에서만 볼 수 있습니다. 의사 프로세스에서 모든 파일 및 디렉토리 액세스는 가상 작업 디렉토리를 실제 작업 디렉토리에 올바르게 맵핑합니다.</target>
        </trans-unit>
        <trans-unit id="8f4f1268e7fb63f76b0f62897f0f8014b138b792" translate="yes" xml:space="preserve">
          <source>Each result bit is based on the least-significant bit of the corresponding input character, i.e., on &lt;code&gt;&lt;a href=&quot;functions/ord&quot;&gt;ord($char)%2&lt;/a&gt;&lt;/code&gt;. In particular, characters &lt;code&gt;&quot;0&quot;&lt;/code&gt; and &lt;code&gt;&quot;1&quot;&lt;/code&gt; generate bits 0 and 1, as do characters &lt;code&gt;&quot;\000&quot;&lt;/code&gt; and &lt;code&gt;&quot;\001&quot;&lt;/code&gt; .</source>
          <target state="translated">각 결과 비트는 해당 입력 문자의 최하위 비트, 즉 &lt;code&gt;&lt;a href=&quot;functions/ord&quot;&gt;ord($char)%2&lt;/a&gt;&lt;/code&gt; 합니다. 특히 문자 &lt;code&gt;&quot;0&quot;&lt;/code&gt; 및 &lt;code&gt;&quot;1&quot;&lt;/code&gt; 은 문자 &lt;code&gt;&quot;\000&quot;&lt;/code&gt; 및 &lt;code&gt;&quot;\001&quot;&lt;/code&gt; 과 마찬가지로 비트 0과 1을 생성 합니다.</target>
        </trans-unit>
        <trans-unit id="abf39ff7c44d3c8c17f0be2056a001c031f6f08e" translate="yes" xml:space="preserve">
          <source>Each result bit is based on the least-significant bit of the corresponding input character, i.e., on &lt;code&gt;&lt;a href=&quot;ord&quot;&gt;ord($char)%2&lt;/a&gt;&lt;/code&gt;. In particular, characters &lt;code&gt;&quot;0&quot;&lt;/code&gt; and &lt;code&gt;&quot;1&quot;&lt;/code&gt; generate bits 0 and 1, as do characters &lt;code&gt;&quot;\000&quot;&lt;/code&gt; and &lt;code&gt;&quot;\001&quot;&lt;/code&gt; .</source>
          <target state="translated">각 결과 비트는 해당 입력 문자의 최하위 비트, 즉 &lt;code&gt;&lt;a href=&quot;ord&quot;&gt;ord($char)%2&lt;/a&gt;&lt;/code&gt; 합니다. 특히 문자 &lt;code&gt;&quot;0&quot;&lt;/code&gt; 및 &lt;code&gt;&quot;1&quot;&lt;/code&gt; 은 문자 &lt;code&gt;&quot;\000&quot;&lt;/code&gt; 및 &lt;code&gt;&quot;\001&quot;&lt;/code&gt; 과 마찬가지로 비트 0과 1을 생성 합니다.</target>
        </trans-unit>
        <trans-unit id="f1993b5736422a8ea772061042ca6c62dead2e8c" translate="yes" xml:space="preserve">
          <source>Each result bit is based on the least-significant bit of the corresponding input character, i.e., on &lt;code&gt;ord($char)%2&lt;/code&gt;. In particular, characters &lt;code&gt;&quot;0&quot;&lt;/code&gt; and &lt;code&gt;&quot;1&quot;&lt;/code&gt; generate bits 0 and 1, as do characters &lt;code&gt;&quot;\000&quot;&lt;/code&gt; and &lt;code&gt;&quot;\001&quot;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1801d81c7323468b4de78bc480016b6092b96d8e" translate="yes" xml:space="preserve">
          <source>Each result fetched is a result object of a different type. There are common methods to each result object and different types may have methods unique to their type. Sometimes a type method may be overridden in a subclass, but its use is guaranteed to be identical.</source>
          <target state="translated">가져온 각 결과는 다른 유형의 결과 개체입니다. 각 결과 개체에 공통적 인 방법이 있으며 다른 유형에는 해당 유형에 고유 한 방법이있을 수 있습니다. 때때로 서브 클래스에서 타입 메소드가 오버라이드 될 수 있지만 그 사용은 동일하게 보장됩니다.</target>
        </trans-unit>
        <trans-unit id="4e19bf2bd96e365232fc6a017a9d4e2f9f8f058b" translate="yes" xml:space="preserve">
          <source>Each result returned is a &lt;a href=&quot;TAP::Parser::Result&quot;&gt;TAP::Parser::Result&lt;/a&gt; subclass, referred to as</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fca0f4c2c0d0f6d5b588e090e9018c1d20041904" translate="yes" xml:space="preserve">
          <source>Each result returned is a &lt;a href=&quot;parser/result&quot;&gt;TAP::Parser::Result&lt;/a&gt; subclass, referred to as</source>
          <target state="translated">리턴 된 각 결과는 &lt;a href=&quot;parser/result&quot;&gt;TAP :: Parser :: Result&lt;/a&gt; 서브 클래스이며</target>
        </trans-unit>
        <trans-unit id="ce5b6f7b029d0c88c7f3bdd0a0914e98b5dca329" translate="yes" xml:space="preserve">
          <source>Each result returned is a subclass of &lt;a href=&quot;TAP::Parser::Result&quot;&gt;TAP::Parser::Result&lt;/a&gt;. See that module and related classes for more information on how to use them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0a1f92895a8d5d3bca2a476a0ec322b95e7589a" translate="yes" xml:space="preserve">
          <source>Each result returned is a subclass of &lt;a href=&quot;parser/result&quot;&gt;TAP::Parser::Result&lt;/a&gt;. See that module and related classes for more information on how to use them.</source>
          <target state="translated">리턴 된 각 결과는 &lt;a href=&quot;parser/result&quot;&gt;TAP :: Parser :: Result&lt;/a&gt; 의 서브 클래스입니다 . 사용 방법에 대한 자세한 내용은 해당 모듈 및 관련 클래스를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="8f5ef808a290d77bcb78c1a52baf58c7827e311b" translate="yes" xml:space="preserve">
          <source>Each scalar &lt;code&gt;${&quot;_&amp;lt;$filename&quot;}&lt;/code&gt; contains &lt;code&gt;&quot;_&amp;lt;$filename&quot;&lt;/code&gt; . This is also the case for evaluated strings that contain subroutines, or which are currently being executed. The $filename for &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;ed strings looks like &lt;code&gt;(&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; 34)&lt;/code&gt; .</source>
          <target state="translated">각 스칼라 &lt;code&gt;${&quot;_&amp;lt;$filename&quot;}&lt;/code&gt; 에는 &lt;code&gt;&quot;_&amp;lt;$filename&quot;&lt;/code&gt; 있습니다. 서브 루틴을 포함하거나 현재 실행중인 평가 된 문자열의 경우에도 마찬가지입니다. &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 문자열 의 $ filename은 다음과 같습니다 &lt;code&gt;(&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; 34)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ccc94bfc366f53a70874613dffa08986828d80a8" translate="yes" xml:space="preserve">
          <source>Each scalar &lt;code&gt;${&quot;_&amp;lt;$filename&quot;}&lt;/code&gt; contains &lt;code&gt;&quot;_&amp;lt;$filename&quot;&lt;/code&gt;. This is also the case for evaluated strings that contain subroutines, or which are currently being executed. The $filename for &lt;code&gt;eval&lt;/code&gt;ed strings looks like &lt;code&gt;(eval 34)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b759249474717644d66332dcc04eba32c6b818f" translate="yes" xml:space="preserve">
          <source>Each semaphore has a counter attached to it. By default, semaphores are created with the counter set to one, &lt;code&gt;down()&lt;/code&gt; decrements the counter by one, and &lt;code&gt;up()&lt;/code&gt; increments by one. However, we can override any or all of these defaults simply by passing in different values:</source>
          <target state="translated">각 세마포어에는 카운터가 부착되어 있습니다. 기본적으로 세마포어는 카운터가 1로 설정되어 만들어지고 &lt;code&gt;down()&lt;/code&gt; 은 카운터를 1 씩 줄이고 &lt;code&gt;up()&lt;/code&gt; 은 1 씩 증가합니다. 그러나 단순히 다른 값을 전달하여 이러한 기본값 중 일부 또는 전부를 무시할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9e3598640cb6381c253bcf070a1e62dc7e9d0823" translate="yes" xml:space="preserve">
          <source>Each step is of the form &lt;code&gt;n &amp;lt;x&amp;gt; &amp;lt;y&amp;gt;&lt;/code&gt;, with &lt;code&gt;&amp;lt;x&amp;gt;&lt;/code&gt; the part of the string matched and &lt;code&gt;&amp;lt;y&amp;gt;&lt;/code&gt; the part not yet matched. The &lt;code&gt;|  1:  STAR&lt;/code&gt; says that Perl is at line number 1 in the compilation list above. See &lt;a href=&quot;perldebguts#Debugging-Regular-Expressions&quot;&gt;Debugging Regular Expressions in perldebguts&lt;/a&gt; for much more detail.</source>
          <target state="translated">각 단계는 &lt;code&gt;n &amp;lt;x&amp;gt; &amp;lt;y&amp;gt;&lt;/code&gt; 이며 &lt;code&gt;&amp;lt;x&amp;gt;&lt;/code&gt; 는 문자열 부분이 일치하고 &lt;code&gt;&amp;lt;y&amp;gt;&lt;/code&gt; 부분은 아직 일치하지 않습니다. &lt;code&gt;| 1: STAR&lt;/code&gt; 는 Perl이 위의 컴파일 목록에서 1 번 라인에 있다고 말합니다. 자세한 내용 &lt;a href=&quot;perldebguts#Debugging-Regular-Expressions&quot;&gt;은 perldebguts에서 정규 표현식 디버깅을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="621b92ce1167d60ce7eabc3bf97a2ce373df3b42" translate="yes" xml:space="preserve">
          <source>Each step is of the form &lt;code&gt;n &amp;lt;x&amp;gt; &amp;lt;y&amp;gt;&lt;/code&gt;, with &lt;code&gt;&amp;lt;x&amp;gt;&lt;/code&gt; the part of the string matched and &lt;code&gt;&amp;lt;y&amp;gt;&lt;/code&gt; the part not yet matched. The &lt;code&gt;| 1: STAR&lt;/code&gt; says that Perl is at line number 1 in the compilation list above. See &lt;a href=&quot;perldebguts#Debugging-Regular-Expressions&quot;&gt;&quot;Debugging Regular Expressions&quot; in perldebguts&lt;/a&gt; for much more detail.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f223fa7c50954c6826a1fdb18aaf28328cfda343" translate="yes" xml:space="preserve">
          <source>Each test can be given a little descriptive name as the second argument to &lt;code&gt;ok()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4bdc8ff98493a9f7ade9d6296926319855358f97" translate="yes" xml:space="preserve">
          <source>Each thread (except the main thread) is started using the C locale. The main thread is started like all other Perl programs; see &lt;a href=&quot;perllocale#ENVIRONMENT&quot;&gt;&quot;ENVIRONMENT&quot; in perllocale&lt;/a&gt;. You can switch locales in any thread as often as you like.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3defe21495aad5ab5041830fd4fe29198a67142" translate="yes" xml:space="preserve">
          <source>Each time &lt;code&gt;$finder-&amp;gt;next&lt;/code&gt; is called, the iterator returns one of two possible values:</source>
          <target state="translated">&lt;code&gt;$finder-&amp;gt;next&lt;/code&gt; 가 호출 될 때마다 반복자는 두 가지 가능한 값 중 하나를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="54bbe29b947a5618329ec98194ec80f8aabe46b6" translate="yes" xml:space="preserve">
          <source>Each type of section can appear an arbitrary number of times and does not have to appear at all. For example, a typemap may commonly lack &lt;code&gt;INPUT&lt;/code&gt; and &lt;code&gt;OUTPUT&lt;/code&gt; sections if all it needs to do is associate additional C types with core XS types like T_PTROBJ. Lines that start with a hash &lt;code&gt;#&lt;/code&gt; are considered comments and ignored in the &lt;code&gt;TYPEMAP&lt;/code&gt; section, but are considered significant in &lt;code&gt;INPUT&lt;/code&gt; and &lt;code&gt;OUTPUT&lt;/code&gt; . Blank lines are generally ignored.</source>
          <target state="translated">각 섹션 유형은 임의의 횟수로 나타날 수 있으며 전혀 나타나지 않아도됩니다. 예를 들어 타입 맵에 추가 C 유형을 T_PTROBJ와 같은 핵심 XS 유형과 연결하기 만하면 &lt;code&gt;INPUT&lt;/code&gt; 및 &lt;code&gt;OUTPUT&lt;/code&gt; 섹션이 부족할 수 있습니다 . 해시 &lt;code&gt;#&lt;/code&gt; 로 시작하는 행 은 주석으로 간주되고 &lt;code&gt;TYPEMAP&lt;/code&gt; 섹션 에서 무시 되지만 &lt;code&gt;INPUT&lt;/code&gt; 및 &lt;code&gt;OUTPUT&lt;/code&gt; 에서 중요한 것으로 간주됩니다 . 빈 줄은 일반적으로 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="b8ab41b525aa7b7c38e4e3da5cf8193e961a308c" translate="yes" xml:space="preserve">
          <source>Each type of section can appear an arbitrary number of times and does not have to appear at all. For example, a typemap may commonly lack &lt;code&gt;INPUT&lt;/code&gt; and &lt;code&gt;OUTPUT&lt;/code&gt; sections if all it needs to do is associate additional C types with core XS types like T_PTROBJ. Lines that start with a hash &lt;code&gt;#&lt;/code&gt; are considered comments and ignored in the &lt;code&gt;TYPEMAP&lt;/code&gt; section, but are considered significant in &lt;code&gt;INPUT&lt;/code&gt; and &lt;code&gt;OUTPUT&lt;/code&gt;. Blank lines are generally ignored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c99826defe1aa3e0e7dfa632ce9b50c12211fd46" translate="yes" xml:space="preserve">
          <source>Each typedef has specific routines that manipulate the various data types.</source>
          <target state="translated">각 typedef에는 다양한 데이터 유형을 조작하는 특정 루틴이 있습니다.</target>
        </trans-unit>
        <trans-unit id="a786e808038f24779f10721b5785e1d471731d02" translate="yes" xml:space="preserve">
          <source>Each value in the results list will be a hash reference containing the following fields:</source>
          <target state="translated">결과 목록의 각 값은 다음 필드를 포함하는 해시 참조입니다.</target>
        </trans-unit>
        <trans-unit id="d6fa3b1f2df46de4d0da0473d7f7df5be8fdd538" translate="yes" xml:space="preserve">
          <source>Each version of Perl comes with the documentation that was current at the time of release. This poses a problem for content such as book lists. There are probably very nice books published after this list was included in your Perl release, and you can check the latest released version at &lt;a href=&quot;http://perldoc.perl.org/perlbook.html&quot;&gt;http://perldoc.perl.org/perlbook.html&lt;/a&gt; .</source>
          <target state="translated">Perl의 각 버전은 릴리스 당시의 최신 설명서와 함께 제공됩니다. 이것은 책 목록과 같은 내용에 문제가됩니다. 이 목록이 Perl 릴리스에 포함 된 후에 게시 된 훌륭한 책이있을 수 있으며 &lt;a href=&quot;http://perldoc.perl.org/perlbook.html&quot;&gt;http://perldoc.perl.org/perlbook.html&lt;/a&gt; 에서 최신 릴리스 버전을 확인할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a017204ca793ea63195213655418d18b5e46cf36" translate="yes" xml:space="preserve">
          <source>Earlier Mac OS X releases (10.2 &quot;Jaguar&quot; and older) did not include a completely thread-safe libc, so threading is not fully supported. Also, earlier releases included a buggy libdb, so some of the DB_File tests are known to fail on those releases.</source>
          <target state="translated">이전 Mac OS X 릴리스 (10.2 &quot;Jaguar&quot;및 이전 버전)에는 완전히 스레드 안전 libc가 포함되어 있지 않으므로 스레딩이 완전히 지원되지 않습니다. 또한 이전 릴리스에는 버그가있는 libdb가 포함되었으므로 일부 DB_File 테스트는 해당 릴리스에서 실패하는 것으로 알려져 있습니다.</target>
        </trans-unit>
        <trans-unit id="a252186ae05a758597f2268019d7fe33e7216333" translate="yes" xml:space="preserve">
          <source>Earlier releases caveats</source>
          <target state="translated">초기 릴리스주의</target>
        </trans-unit>
        <trans-unit id="8144bf937e246b0c3995f39e74e8340a0ff57aa1" translate="yes" xml:space="preserve">
          <source>Earlier than Perl 5.10, you have a bit of work to do. You want to avoid compiling a regular expression every time you want to match it. In this example, perl must recompile the regular expression for every iteration of the &lt;code&gt;foreach&lt;/code&gt; loop since it has no way to know what &lt;code&gt;$pattern&lt;/code&gt; will be:</source>
          <target state="translated">Perl 5.10 이전에는 약간의 작업이 필요합니다. 일치시킬 때마다 정규 표현식을 컴파일하지 않으려 고합니다. 이 예제에서 perl은 &lt;code&gt;$pattern&lt;/code&gt; 이 무엇인지 알 수있는 방법이 없으므로 &lt;code&gt;foreach&lt;/code&gt; 루프 의 모든 반복에 대해 정규식을 다시 컴파일해야합니다 .</target>
        </trans-unit>
        <trans-unit id="2412eca1a81df7ff0f1d8fd57bf151a2e60cb6ee" translate="yes" xml:space="preserve">
          <source>Earlier versions of Perl accepted almost all the 6.1 names. These were most extensively documented in the v5.14 version of this pod: &lt;a href=&quot;http://perldoc.perl.org/5.14.0/charnames.html#ALIASES&quot;&gt;http://perldoc.perl.org/5.14.0/charnames.html#ALIASES&lt;/a&gt;.</source>
          <target state="translated">이전 버전의 Perl은 거의 모든 6.1 이름을 허용했습니다. :이 가장 광범위하게이 포드의 v5.14 버전에 설명 된 &lt;a href=&quot;http://perldoc.perl.org/5.14.0/charnames.html#ALIASES&quot;&gt;http://perldoc.perl.org/5.14.0/charnames.html#ALIASES&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="041f750894a2130f024fa1d40c0e0cb8140d53b7" translate="yes" xml:space="preserve">
          <source>Earlier versions of Storable would immediately croak if they encountered a file with a higher internal version number than the reading Storable knew about. Internal version numbers are increased each time new data types (such as restricted hashes) are added to the vocabulary of the file format. This meant that a newer Storable module had no way of writing a file readable by an older Storable, even if the writer didn't store newer data types.</source>
          <target state="translated">Storable이 알고있는 것보다 내부 버전 번호가 높은 파일을 발견 한 경우 Storable의 이전 버전은 즉시 사라집니다. 새로운 데이터 유형 (예 : 제한된 해시)이 파일 형식의 어휘에 추가 될 때마다 내부 버전 번호가 증가합니다. 이것은 새로운 Storable 모듈이 기록기가 새로운 데이터 유형을 저장하지 않더라도 이전 Storable이 읽을 수있는 파일을 작성할 수있는 방법이 없음을 의미했습니다.</target>
        </trans-unit>
        <trans-unit id="e4b297dbcd2a6bb824d7c2a7ee2008800dedb8e3" translate="yes" xml:space="preserve">
          <source>Earlier, we mentioned that the &lt;code&gt;File&lt;/code&gt; class's &lt;code&gt;last_mod_time&lt;/code&gt; accessor could return a &lt;a href=&quot;datetime&quot;&gt;DateTime&lt;/a&gt; object. This is a perfect example of composition. We could go even further, and make the &lt;code&gt;path&lt;/code&gt; and &lt;code&gt;content&lt;/code&gt; accessors return objects as well. The &lt;code&gt;File&lt;/code&gt; class would then be &lt;b&gt;composed&lt;/b&gt; of several other objects.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="641edf650debd12f3350ba77247f6ae399c9cef3" translate="yes" xml:space="preserve">
          <source>Earlier, we mentioned that the &lt;code&gt;File&lt;/code&gt; class's &lt;code&gt;last_mod_time&lt;/code&gt; accessor could return a &lt;a href=&quot;http://search.cpan.org/perldoc/DateTime&quot;&gt;DateTime&lt;/a&gt; object. This is a perfect example of composition. We could go even further, and make the &lt;code&gt;path&lt;/code&gt; and &lt;code&gt;content&lt;/code&gt; accessors return objects as well. The &lt;code&gt;File&lt;/code&gt; class would then be &lt;b&gt;composed&lt;/b&gt; of several other objects.</source>
          <target state="translated">앞서 &lt;code&gt;File&lt;/code&gt; 클래스의 &lt;code&gt;last_mod_time&lt;/code&gt; 접근자가 &lt;a href=&quot;http://search.cpan.org/perldoc/DateTime&quot;&gt;DateTime&lt;/a&gt; 객체를 반환 할 수 있다고 언급했습니다 . 이것은 구성의 완벽한 예입니다. 더 나아가서 &lt;code&gt;path&lt;/code&gt; 와 &lt;code&gt;content&lt;/code&gt; 접근자가 객체를 반환 하도록 만들 수 있습니다. &lt;code&gt;File&lt;/code&gt; 클래스는 다음 될 &lt;b&gt;구성&lt;/b&gt; 여러 가지 다른 개체로.</target>
        </trans-unit>
        <trans-unit id="0f33a9394c2fcd538084772b52d2341a61de3e00" translate="yes" xml:space="preserve">
          <source>Early Perl versions worked on some EBCDIC machines, but the last known version that ran on EBCDIC was v5.8.7, until v5.22, when the Perl core again works on z/OS. Theoretically, it could work on OS/400 or Siemens' BS2000 (or their successors), but this is untested. In v5.22 and 5.24, not all the modules found on CPAN but shipped with core Perl work on z/OS.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e2d95ddabd105e29656829184c35d2859c555dc" translate="yes" xml:space="preserve">
          <source>Early Perl versions worked on some EBCDIC machines, but the last known version that ran on EBCDIC was v5.8.7, until v5.22, when the Perl core again works on z/OS. Theoretically, it could work on OS/400 or Siemens' BS2000 (or their successors), but this is untested. In v5.22, not all the modules found on CPAN but shipped with core Perl work on z/OS.</source>
          <target state="translated">초기 Perl 버전은 일부 EBCDIC 시스템에서 작동했지만 EBCDIC에서 실행 된 마지막으로 알려진 버전은 Perl 코어가 z / OS에서 다시 작동 할 때 v5.22까지 v5.8.7입니다. 이론적으로 OS / 400 또는 Siemens의 BS2000 (또는 그 후속 제품)에서 작동 할 수 있지만 이것은 테스트되지 않았습니다. v5.22에서 CPAN에있는 모든 모듈은 아니지만 z / OS에서 핵심 Perl과 함께 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="59b164194e7edb2e85034e9b78794d560a716b37" translate="yes" xml:space="preserve">
          <source>Ease testing test modules built with Test::Builder</source>
          <target state="translated">Test :: Builder로 빌드 한 손쉬운 테스트 테스트 모듈</target>
        </trans-unit>
        <trans-unit id="dae7ef5eb7ee790d1fea0c60a9c1de322881c27f" translate="yes" xml:space="preserve">
          <source>Easier to test new testing tools.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a188f6f02161d17a281a3ef192ea2346304b188" translate="yes" xml:space="preserve">
          <source>Easily interact with CPAN from the command line</source>
          <target state="translated">명령 줄에서 CPAN과 쉽게 상호 작용</target>
        </trans-unit>
        <trans-unit id="45fc6c80b5f40c599a9996e4565f6c3c0441f578" translate="yes" xml:space="preserve">
          <source>Eclipse</source>
          <target state="translated">Eclipse</target>
        </trans-unit>
        <trans-unit id="995f14f2d2d8a63a7a9da7579e9e95a2acf52319" translate="yes" xml:space="preserve">
          <source>Ed Avis</source>
          <target state="translated">에드 에비스</target>
        </trans-unit>
        <trans-unit id="9b2f1a6097a83d57a9f13c69653ee867428c4309" translate="yes" xml:space="preserve">
          <source>Ed Avis &amp;lt;eda@linux01.wcl.local&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00837140532ce93fe6f2a0b0f08779867c4ee055" translate="yes" xml:space="preserve">
          <source>Ed J &amp;lt;mohawk2@users.noreply.github.com&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="528c45b93e145146f93473cbaa4675f9b54b16c1" translate="yes" xml:space="preserve">
          <source>Edgar &quot;Trizor&quot; Bering &amp;lt;trizor@gmail.com&amp;gt;</source>
          <target state="translated">Edgar &quot;Trizor&quot;Bering &amp;lt;trizor@gmail.com&amp;gt;</target>
        </trans-unit>
        <trans-unit id="1f7a7e23b64ce5747c4a63c4739d2a868d6ca53c" translate="yes" xml:space="preserve">
          <source>Edit the GNUmakefile, makefile.mk (or Makefile, if you're using nmake) and change the values of INST_DRV and INST_TOP. You can also enable various build flags. These are explained in the makefiles.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e76b3763dae70623eb55885995406de6279fdb6e" translate="yes" xml:space="preserve">
          <source>Edit the Makefile.PL file so that the corresponding line looks like this:</source>
          <target state="translated">해당 줄이 다음과 같이되도록 Makefile.PL 파일을 편집하십시오.</target>
        </trans-unit>
        <trans-unit id="f7940347fff54108cd46081728a5cf85408a717b" translate="yes" xml:space="preserve">
          <source>Edit the files generated. You don't have to if you have no time AND no intention to give it to someone else. But it is a good idea to edit the pod and to add more tests.</source>
          <target state="translated">생성 된 파일을 편집하십시오. 시간이없고 다른 사람에게 줄 의사가 없다면 할 필요가 없습니다. 그러나 포드를 편집하고 더 많은 테스트를 추가하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="954ea018e0a987091c4440d55ba64f48e0cccfe8" translate="yes" xml:space="preserve">
          <source>Edit the makefile.mk (or Makefile, if you're using nmake) and change the values of INST_DRV and INST_TOP. You can also enable various build flags. These are explained in the makefiles.</source>
          <target state="translated">makefile.mk (또는 nmake를 사용하는 경우 Makefile)를 편집하고 INST_DRV 및 INST_TOP의 값을 변경하십시오. 다양한 빌드 플래그를 활성화 할 수도 있습니다. 이것들은 makefile에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="b93bb818c85552f3fcd19e172c258ef9c6aad22d" translate="yes" xml:space="preserve">
          <source>Editor Support for Debugging</source>
          <target state="translated">디버깅을위한 에디터 지원</target>
        </trans-unit>
        <trans-unit id="68575b9eb0c3bb98d30a72178c5ff21f9fae81f0" translate="yes" xml:space="preserve">
          <source>Editor to use.</source>
          <target state="translated">사용할 편집기.</target>
        </trans-unit>
        <trans-unit id="77cd7c3d29d911531fb7afe572b99c8c5ba4e8b7" translate="yes" xml:space="preserve">
          <source>Editorial adjustments by Gurusamy Sarathy &amp;lt;gsar@ActiveState.com&amp;gt;</source>
          <target state="translated">Gurusamy Sarathy &amp;lt;gsar@ActiveState.com&amp;gt;의 편집 조정</target>
        </trans-unit>
        <trans-unit id="e5b26fe0f2ccbc86d51353217407910ecc40ac72" translate="yes" xml:space="preserve">
          <source>Edward Zborowski &amp;lt;ed@rubensteintech.com&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73be54c86084c8c273a09c1c9821e5a9131296dd" translate="yes" xml:space="preserve">
          <source>Effect:</source>
          <target state="translated">Effect:</target>
        </trans-unit>
        <trans-unit id="8117456b097c6d57fb7d1f1dab282a3702937b2f" translate="yes" xml:space="preserve">
          <source>Efficient removal of characters from the beginning of the string buffer. &lt;code&gt;SvPOK(sv)&lt;/code&gt;, or at least &lt;code&gt;SvPOKp(sv)&lt;/code&gt;, must be true and &lt;code&gt;ptr&lt;/code&gt; must be a pointer to somewhere inside the string buffer. &lt;code&gt;ptr&lt;/code&gt; becomes the first character of the adjusted string. Uses the &lt;code&gt;OOK&lt;/code&gt; hack. On return, only &lt;code&gt;SvPOK(sv)&lt;/code&gt; and &lt;code&gt;SvPOKp(sv)&lt;/code&gt; among the &lt;code&gt;OK&lt;/code&gt; flags will be true.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b7ac9002bbe557a0e89e8f9ac76410e740b68c3" translate="yes" xml:space="preserve">
          <source>Efficient removal of characters from the beginning of the string buffer. SvPOK(sv), or at least SvPOKp(sv), must be true and the &lt;code&gt;ptr&lt;/code&gt; must be a pointer to somewhere inside the string buffer. The &lt;code&gt;ptr&lt;/code&gt; becomes the first character of the adjusted string. Uses the &quot;OOK hack&quot;. On return, only SvPOK(sv) and SvPOKp(sv) among the OK flags will be true.</source>
          <target state="translated">문자열 버퍼의 시작 부분에서 문자를 효율적으로 제거합니다. SvPOK (sv) 또는 적어도 SvPOKp (sv)는 true 여야하며 &lt;code&gt;ptr&lt;/code&gt; 은 문자열 버퍼 내부의 포인터 여야합니다. &lt;code&gt;ptr&lt;/code&gt; 조정 된 문자열의 첫 번째 문자가됩니다. &quot;OOK 핵&quot;을 사용합니다. 돌아 왔을 때, OK 플래그 중 SvPOK (sv) 및 SvPOKp (sv)만이 참이됩니다.</target>
        </trans-unit>
        <trans-unit id="f18b25f084ce81b950168aedca18f94cb1425062" translate="yes" xml:space="preserve">
          <source>Efficiently compute time from local and GMT time</source>
          <target state="translated">로컬 및 GMT 시간에서 시간을 효율적으로 계산</target>
        </trans-unit>
        <trans-unit id="654f6a3bdd1d9e4bdcf155781a2de9b4ed80c132" translate="yes" xml:space="preserve">
          <source>Either &lt;code&gt;IO::String&lt;/code&gt; or &lt;code&gt;perlio&lt;/code&gt; support is needed to support writing stringified archives. Currently, &lt;code&gt;perlio&lt;/code&gt; is the preferred method, if available.</source>
          <target state="translated">어느 &lt;code&gt;IO::String&lt;/code&gt; 또는 &lt;code&gt;perlio&lt;/code&gt; 지원도 캐릭터 라인 아카이브를 작성 지원하기 위해 필요합니다. 현재 가능한 경우 &lt;code&gt;perlio&lt;/code&gt; 가 선호되는 방법입니다.</target>
        </trans-unit>
        <trans-unit id="85dba161f5ca6a960a7dc8fa1039724a8c09cad4" translate="yes" xml:space="preserve">
          <source>Either &lt;code&gt;\g&lt;i&gt;N&lt;/i&gt;&lt;/code&gt; (starting in Perl 5.10.0), or &lt;code&gt;\&lt;i&gt;N&lt;/i&gt;&lt;/code&gt; (old-style) where</source>
          <target state="translated">어느 &lt;code&gt;\g&lt;i&gt;N&lt;/i&gt;&lt;/code&gt; , 또는 (펄 5.10.0부터) &lt;code&gt;\&lt;i&gt;N&lt;/i&gt;&lt;/code&gt; (구식)</target>
        </trans-unit>
        <trans-unit id="52f049aa56476852e6a153929348eb18e7bf1459" translate="yes" xml:space="preserve">
          <source>Either a named or anonymous pipe.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb02a27773229541ab59b1944bd46b1d5a6ebed2" translate="yes" xml:space="preserve">
          <source>Either a regular &lt;b&gt;assignment&lt;/b&gt; or a compound &lt;b&gt;operator&lt;/b&gt; composed of an ordinary assignment and some other operator, that changes the value of a variable in place; that is, relative to its old value. For example, &lt;code&gt;$a += 2&lt;/code&gt; adds &lt;code&gt;2&lt;/code&gt; to &lt;code&gt;$a&lt;/code&gt; .</source>
          <target state="translated">정규 &lt;b&gt;할당&lt;/b&gt; 또는 일반 할당과 일부 다른 연산자로 구성된 복합 &lt;b&gt;연산자&lt;/b&gt; 로 변수의 값을 적절하게 변경합니다. 즉, 이전 값과 관련이 있습니다. 예를 들어, &lt;code&gt;$a += 2&lt;/code&gt; 는 &lt;code&gt;2&lt;/code&gt; 를 &lt;code&gt;$a&lt;/code&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="0dd3a0e7d7fd04d60cdb8e08fb04cc78c683756e" translate="yes" xml:space="preserve">
          <source>Either a regular &lt;b&gt;assignment&lt;/b&gt; or a compound &lt;b&gt;operator&lt;/b&gt; composed of an ordinary assignment and some other operator, that changes the value of a variable in place; that is, relative to its old value. For example, &lt;code&gt;$a += 2&lt;/code&gt; adds &lt;code&gt;2&lt;/code&gt; to &lt;code&gt;$a&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="281cd0fa078fd4c1ba948d728426cec878f64c16" translate="yes" xml:space="preserve">
          <source>Either assimilate new technologies, or build bridges to them.</source>
          <target state="translated">새로운 기술을 동화 시키거나 그들과의 가교를 구축하십시오.</target>
        </trans-unit>
        <trans-unit id="616b8deb9c86ed3074fc60088a26151e3856d891" translate="yes" xml:space="preserve">
          <source>Either form above will work. This will return a list of attributes defined on the object. This list is returned in the attribute definition order, parent class attributes are listed before subclass attributes. Duplicate attributes will be removed before the list is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2577d609c330867bbdb6a4c63c0df0f3f5ae7cc8" translate="yes" xml:space="preserve">
          <source>Either have an argumentless =over, or have its argument a strictly positive number.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66b1d548fa9375ac8cee4b6bb3288cae52feda67" translate="yes" xml:space="preserve">
          <source>Either not implemented or a no-op. (Android)</source>
          <target state="translated">구현되지 않았거나 작동하지 않습니다. (기계적 인조 인간)</target>
        </trans-unit>
        <trans-unit id="9fd8e33d6202aef3ccb0a1588e2309a6eeaf7193" translate="yes" xml:space="preserve">
          <source>Either of &lt;code&gt;LocalService&lt;/code&gt; or &lt;code&gt;PeerService&lt;/code&gt; (or their &lt;code&gt;...Port&lt;/code&gt; synonyms) can be either a service name, a decimal number, or a string containing both a service name and number, in a form such as</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6aadb20634080f518a8887a688da9b1fee48d93" translate="yes" xml:space="preserve">
          <source>Either of the above forms of &quot;layer&quot; specifications can be made the default for a lexical scope with the &lt;code&gt;use open ...&lt;/code&gt; pragma. See &lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c47f17b2cb7b7674bb2cbd89473a3cd6f362bf48" translate="yes" xml:space="preserve">
          <source>Either of the following will work instead:</source>
          <target state="translated">대신 다음 중 하나가 작동합니다.</target>
        </trans-unit>
        <trans-unit id="e5a6a14049fff21a602c284699a2c9fbe3ca6693" translate="yes" xml:space="preserve">
          <source>Either single-quote your strings, or (preferably) use forward slashes. Since all DOS and Windows versions since something like MS-DOS 2.0 or so have treated &lt;code&gt;/&lt;/code&gt; and &lt;code&gt;\&lt;/code&gt; the same in a path, you might as well use the one that doesn't clash with Perl--or the POSIX shell, ANSI C and C++, awk, Tcl, Java, or Python, just to mention a few. POSIX paths are more portable, too.</source>
          <target state="translated">문자열을 작은 따옴표로 묶거나 슬래시를 사용하십시오. 모든 DOS 및 Windows 버전은 MS-DOS 2.0과 같이 경로에서 &lt;code&gt;/&lt;/code&gt; 및 &lt;code&gt;\&lt;/code&gt; 를 동일하게 취급하므로 Perl과 충돌하지 않는 버전 또는 POSIX 셸, ANSI C 및 C ++, awk, Tcl, Java 또는 Python 중 일부만 언급하면됩니다. POSIX 경로도 이식성이 뛰어납니다.</target>
        </trans-unit>
        <trans-unit id="a48425d47cea1024da1aa0b5eb56b9a2e8f4b87c" translate="yes" xml:space="preserve">
          <source>Either stringify the structure yourself (no fun), or else get the MLDBM (which uses Data::Dumper) module from CPAN and layer it on top of either DB_File or GDBM_File. You might also try DBM::Deep, but it can be a bit slow.</source>
          <target state="translated">구조를 직접 문자열로 지정하거나 (재미 없음) CPAN에서 MLDBM (Data :: Dumper를 사용하는) 모듈을 가져 와서 DB_File 또는 GDBM_File 위에 계층화하십시오. DBM :: Deep을 사용해 볼 수도 있지만 약간 느릴 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f91179ba5041e3cd11279b2a09e8c8dafe42d600" translate="yes" xml:space="preserve">
          <source>Either the 5.006001 or the 5.6.1 format is acceptable.</source>
          <target state="translated">5.006001 또는 5.6.1 형식 중 하나를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f3046bc2658fc9703b653ff4f645f1c7f4b09d3a" translate="yes" xml:space="preserve">
          <source>Either the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings&lt;/code&gt; pragma or the &lt;b&gt;-w&lt;/b&gt; flag will warn you when you use an array slice with a single index.</source>
          <target state="translated">중 하나를 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings&lt;/code&gt; 프라그 또는 &lt;b&gt;-w&lt;/b&gt; 단일 인덱스 배열 슬라이스를 사용할 때 플래그는 경고합니다.</target>
        </trans-unit>
        <trans-unit id="175fe2f08cb303f8f8870d3f7cd0357b5f36d7a6" translate="yes" xml:space="preserve">
          <source>Either the &lt;code&gt;use warnings&lt;/code&gt; pragma or the &lt;b&gt;-w&lt;/b&gt; flag will warn you when you use an array slice with a single index.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="906b6fd14fb2f43afa53be4e9384438767144648" translate="yes" xml:space="preserve">
          <source>Either the &lt;code&gt;warnings::warn&lt;/code&gt; or &lt;code&gt;warnings::warnif&lt;/code&gt; function should be used to actually display the warnings message. This is because they can make use of the feature that allows warnings to be escalated into fatal errors. So in this case</source>
          <target state="translated">중 하나를 &lt;code&gt;warnings::warn&lt;/code&gt; 또는 &lt;code&gt;warnings::warnif&lt;/code&gt; 기능은 실제로 경고 메시지를 표시하는 데 사용되어야한다. 경고를 치명적인 오류로 에스컬레이션 할 수있는 기능을 사용할 수 있기 때문입니다. 따라서이 경우</target>
        </trans-unit>
        <trans-unit id="0780376e7962816fa4ff7b6a652f65ef6eadb7db" translate="yes" xml:space="preserve">
          <source>Either use parentheses or the high-precedence variant of the operator.</source>
          <target state="translated">괄호 나 우선 순위가 높은 연산자를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="ac2efacdb85d4049866934d48a775a119bbac29d" translate="yes" xml:space="preserve">
          <source>Either way, the implementation isn't going to generate results larger than the size of the integer type Perl was built with (32 bits or 64 bits).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6479b4a431808cf309ed8137f781bb957df27d9" translate="yes" xml:space="preserve">
          <source>Either you don't have more than one line in the string you're looking at (probably), or else you aren't using the correct modifier(s) on your pattern (possibly).</source>
          <target state="translated">찾고있는 문자열에 둘 이상의 줄이 없거나 (아마도) 패턴에 올바른 수정자를 사용하고 있지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e153f909edaedd24892df1d401944b8821af0128" translate="yes" xml:space="preserve">
          <source>Elapsed Real Time</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e45775ed8dae80c63b3497b4ea826a44ca2dea3f" translate="yes" xml:space="preserve">
          <source>Elapsed returns a &lt;a href=&quot;../../benchmark&quot;&gt;Benchmark&lt;/a&gt; object that represents the running time of the aggregated tests. In order for &lt;code&gt;elapsed&lt;/code&gt; to be valid you must call &lt;code&gt;start&lt;/code&gt; before running the tests and &lt;code&gt;stop&lt;/code&gt; immediately afterwards.</source>
          <target state="translated">경과는 집계 된 테스트의 실행 시간을 나타내는 &lt;a href=&quot;../../benchmark&quot;&gt;벤치 마크&lt;/a&gt; 객체를 반환합니다 . 위해에 대한 &lt;code&gt;elapsed&lt;/code&gt; 하면 호출해야 유효한 것으로 &lt;code&gt;start&lt;/code&gt; 테스트를 실행하기 전에 및 &lt;code&gt;stop&lt;/code&gt; 후 즉시.</target>
        </trans-unit>
        <trans-unit id="2fb6b6b80655efc89d39c9e3dbc4f534ad641e2d" translate="yes" xml:space="preserve">
          <source>Elapsed returns a &lt;a href=&quot;benchmark&quot;&gt;Benchmark&lt;/a&gt; object that represents the running time of the aggregated tests. In order for &lt;code&gt;elapsed&lt;/code&gt; to be valid you must call &lt;code&gt;start&lt;/code&gt; before running the tests and &lt;code&gt;stop&lt;/code&gt; immediately afterwards.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="685684a16f4001786549b1ab800e18b9d9c7dce4" translate="yes" xml:space="preserve">
          <source>Electronic mail address of the perl5 administrator.</source>
          <target state="translated">perl5 관리자의 전자 우편 주소</target>
        </trans-unit>
        <trans-unit id="0206d29187ee24de18ffe8c7060208c783959fc1" translate="yes" xml:space="preserve">
          <source>Electronic mail address of the person who ran Configure. This can be used by units that require the user's e-mail, like</source>
          <target state="translated">Configure를 실행 한 사람의 전자 메일 주소입니다. 이것은 사용자의 이메일을 요구하는 장치에서 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fb92ce1ec6eee388978bf1476ef4da0f49ddc2f4" translate="yes" xml:space="preserve">
          <source>Element Types and Accessor Methods</source>
          <target state="translated">요소 유형 및 접근 자 방법</target>
        </trans-unit>
        <trans-unit id="56be9d95047d3837a8e260ecf6fab5aa5091179f" translate="yes" xml:space="preserve">
          <source>Eliminate the macros in the output to the MMS/MMK file.</source>
          <target state="translated">출력에서 매크로를 MMS / MMK 파일로 제거하십시오.</target>
        </trans-unit>
        <trans-unit id="0043730cfa58902fc1eb2bab5c9cf7b854c601fd" translate="yes" xml:space="preserve">
          <source>Eliminates any information in the type-ahead buffer on a read from the terminal.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="372fe5af53dfb10b96df623d9727deb1110a3dd2" translate="yes" xml:space="preserve">
          <source>Email any corrections or questions to me.</source>
          <target state="translated">수정 사항이나 질문이 있으면 나에게 이메일을 보내십시오.</target>
        </trans-unit>
        <trans-unit id="2f6c017bc97bb2714dd0b54f8c31090aba3e0c32" translate="yes" xml:space="preserve">
          <source>Email::Sender::Transport::SMTP</source>
          <target state="translated">Email::Sender::Transport::SMTP</target>
        </trans-unit>
        <trans-unit id="f4fe0960af2e7da0a8e6abd0220f7fb9ccfc0f82" translate="yes" xml:space="preserve">
          <source>Email::Sender::Transport::Sendmail</source>
          <target state="translated">Email::Sender::Transport::Sendmail</target>
        </trans-unit>
        <trans-unit id="a5bcdc422fa0c0f86b08b10ed2c448b54076951e" translate="yes" xml:space="preserve">
          <source>Embedded Code Execution Frequency</source>
          <target state="translated">임베디드 코드 실행 빈도</target>
        </trans-unit>
        <trans-unit id="1c0d431f261d9feabca2f4bf0f5d2be5226959da" translate="yes" xml:space="preserve">
          <source>Embedded Ctrl-As (octal 001) in the input will be mapped to spaces on output, due to an internal implementation detail.</source>
          <target state="translated">입력에 내장 된 Ctrl-A (8 진수 001)는 내부 구현 세부 사항으로 인해 출력의 공백에 맵핑됩니다.</target>
        </trans-unit>
        <trans-unit id="b65de96935df088746b85b44766bded2aa4a92cf" translate="yes" xml:space="preserve">
          <source>Embedded modifiers can also turn off any modifiers already present by using,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="036d707633278129886b9180244ca67da739555e" translate="yes" xml:space="preserve">
          <source>Embedded modifiers can also turn off any modifiers already present by using, e.g., &lt;code&gt;(?-i)&lt;/code&gt;. Modifiers can also be combined into a single expression, e.g., &lt;code&gt;(?s-i)&lt;/code&gt; turns on single line mode and turns off case insensitivity.</source>
          <target state="translated">임베디드 수정자는 또한 예를 들어 &lt;code&gt;(?-i)&lt;/code&gt; 를 사용하여 이미 존재하는 수정자를 끌 수 있습니다 . 수정자를 단일 표현으로 결합 할 수도 있습니다. 예를 들어 &lt;code&gt;(?s-i)&lt;/code&gt; 는 단일 회선 모드를 켜고 대 / 소문자를 구분하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="609e053d4c0081ee95d3a87942874703d9f5ab55" translate="yes" xml:space="preserve">
          <source>Embedded modifiers can have two important advantages over the usual modifiers. Embedded modifiers allow a custom set of modifiers for</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b8b1388248a7771ad7a19db052c3e57cdc37002" translate="yes" xml:space="preserve">
          <source>Embedded modifiers can have two important advantages over the usual modifiers. Embedded modifiers allow a custom set of modifiers to</source>
          <target state="translated">임베디드 수정자는 일반적인 수정 자보다 두 가지 중요한 장점을 가질 수 있습니다. 내장 된 수정자는 사용자 정의 수정 자 집합을</target>
        </trans-unit>
        <trans-unit id="77fff13bcd07ad216d2d3e4a9dc81f2e17688911" translate="yes" xml:space="preserve">
          <source>Embedded modifiers may also be added to a non-capturing grouping. &lt;code&gt;(?i-m:regexp)&lt;/code&gt; is a non-capturing grouping that matches &lt;code&gt;regexp&lt;/code&gt; case insensitively and turns off multi-line mode.</source>
          <target state="translated">임베디드 수정자는 캡처하지 않은 그룹화에 추가 될 수도 있습니다. &lt;code&gt;(?i-m:regexp)&lt;/code&gt; 는 &lt;code&gt;regexp&lt;/code&gt; / 소문자를 구분하지 않고 캡처하는 다중 캡처 그룹으로, 다중 회선 모드를 해제합니다.</target>
        </trans-unit>
        <trans-unit id="b92d8665944f4979bd50de8585ed3b0fd45dfa5f" translate="yes" xml:space="preserve">
          <source>Embedding Functions</source>
          <target state="translated">임베드 기능</target>
        </trans-unit>
        <trans-unit id="dfab320700daa38157038d3e70e9093fcfa26c1f" translate="yes" xml:space="preserve">
          <source>Embedding Perl inside a 64-bit application.</source>
          <target state="translated">64 비트 응용 프로그램에 Perl을 포함시킵니다.</target>
        </trans-unit>
        <trans-unit id="0694b8bb0407da0c117f25cc81dd5d48908ff82d" translate="yes" xml:space="preserve">
          <source>Embedding Perl under Win32</source>
          <target state="translated">Win32 아래에 Perl 임베딩</target>
        </trans-unit>
        <trans-unit id="9cbcae97b606ebda37a4c9c0051aab393c7f7d13" translate="yes" xml:space="preserve">
          <source>Embedding Pods in Perl Modules</source>
          <target state="translated">Perl 모듈에 포드 내장</target>
        </trans-unit>
        <trans-unit id="3332088412158a65b80fc73f2172f27d8031dce4" translate="yes" xml:space="preserve">
          <source>Embedding comments and modifiers in a regular expression</source>
          <target state="translated">정규 표현식에 주석 및 수정 자 임베드</target>
        </trans-unit>
        <trans-unit id="2f84d71eabfb2db471c3906b955c997d8f2ea42c" translate="yes" xml:space="preserve">
          <source>Emboldened by this, you dive into the second phrase that your software needs to output: &quot;Your query matched 10 files in 4 directories.&quot;. You notice that if you want to treat phrases as indivisible, as the gettext manual wisely advises, you need four cases now, instead of two, to cover the permutations of singular and plural on the two items, $dir_count and $file_count. So you try this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f7beea65f566b123cc3fc19969be422b43965af" translate="yes" xml:space="preserve">
          <source>Emit the popular wake-on-lan magic udp packet to wake up a local device. See also &lt;a href=&quot;Net::Wake&quot;&gt;Net::Wake&lt;/a&gt;, but this has the mac address as 1st arg. &lt;code&gt;$host&lt;/code&gt; should be the local gateway. Without it will broadcast.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b1ebe53d6ccd7815c61ce7589f6b78c18dd612d" translate="yes" xml:space="preserve">
          <source>Emits a warning, usually by printing it to &lt;code&gt;STDERR&lt;/code&gt;. &lt;code&gt;warn&lt;/code&gt; interprets its operand LIST in the same way as &lt;code&gt;die&lt;/code&gt;, but is slightly different in what it defaults to when LIST is empty or makes an empty string. If it is empty and &lt;a href=&quot;perlvar#%24%40&quot;&gt;&lt;code&gt;$@&lt;/code&gt;&lt;/a&gt; already contains an exception value then that value is used after appending &lt;code&gt;&quot;\t...caught&quot;&lt;/code&gt;. If it is empty and &lt;code&gt;$@&lt;/code&gt; is also empty then the string &lt;code&gt;&quot;Warning: Something's wrong&quot;&lt;/code&gt; is used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44d5d024243158295b0b17ef00bb9b23203d9360" translate="yes" xml:space="preserve">
          <source>EmojiSources.txt</source>
          <target state="translated">EmojiSources.txt</target>
        </trans-unit>
        <trans-unit id="182fa8e51f2878e5ebff39e46c9563939a1274d1" translate="yes" xml:space="preserve">
          <source>Empty (?) without any modifiers in regex; marked by &amp;lt;-- HERE in m/%s/</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00ea7a43c3020a563e25bd1eedc14c28db07661d" translate="yes" xml:space="preserve">
          <source>Empty \%c in regex; marked by &amp;lt;-- HERE in m/%s/</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="482c748a5823d75ff12d9a6680ae909964eacc76" translate="yes" xml:space="preserve">
          <source>Empty \%c{}</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c45054945a8770b05f8103d2a4a0bb1b804cbf85" translate="yes" xml:space="preserve">
          <source>Empty \%c{} in regex; marked by &amp;lt;-- HERE in m/%s/</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="abbe29d0eda029ba0d774099d16a176aaf760777" translate="yes" xml:space="preserve">
          <source>Empty parts of the file/buffer will have NULL (0x00) bytes written to them.</source>
          <target state="translated">파일 / 버퍼의 빈 부분에는 NULL (0x00) 바이트가 기록됩니다.</target>
        </trans-unit>
        <trans-unit id="bd4ef1b6c1ef24f987c292a748ebade1052ce4dc" translate="yes" xml:space="preserve">
          <source>Empty strings as well as other illegal numbers results in 'NaN'.</source>
          <target state="translated">빈 문자열과 기타 잘못된 숫자는 'NaN'이됩니다.</target>
        </trans-unit>
        <trans-unit id="b78fcf2b7184ff747f91ac2d4e85304d73a66a8f" translate="yes" xml:space="preserve">
          <source>Emptying a file of existing contents, either automatically when opening a file for writing or explicitly via the &lt;code&gt;&lt;a href=&quot;functions/truncate&quot;&gt;truncate&lt;/a&gt;&lt;/code&gt; function.</source>
          <target state="translated">쓰기 위해 파일을 열 때 자동으로 또는 &lt;code&gt;&lt;a href=&quot;functions/truncate&quot;&gt;truncate&lt;/a&gt;&lt;/code&gt; 기능을 통해 명시 적으로 기존 내용의 파일 비우기 .</target>
        </trans-unit>
        <trans-unit id="f60475c9fb8f070699dc0b6997447641f41933fa" translate="yes" xml:space="preserve">
          <source>Emptying a file of existing contents, either automatically when opening a file for writing or explicitly via the &lt;code&gt;truncate&lt;/code&gt; function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3810839f51735c2952e4638769a72e1f188779e" translate="yes" xml:space="preserve">
          <source>Emulate low-level math with BigInt code</source>
          <target state="translated">BigInt 코드로 저수준 수학 에뮬레이션</target>
        </trans-unit>
        <trans-unit id="eaff5ce9fb66a8294a29b4afda7fa93b8fb7b74b" translate="yes" xml:space="preserve">
          <source>Emulated using multiple interpreters. See &lt;a href=&quot;perlfork&quot;&gt;perlfork&lt;/a&gt;. (Win32)</source>
          <target state="translated">여러 개의 인터프리터를 사용하여 에뮬레이트 &lt;a href=&quot;perlfork&quot;&gt;perlfork를&lt;/a&gt; 참조하십시오 . (Win32)</target>
        </trans-unit>
        <trans-unit id="a7b07a2e86e21bbe02318bb5339e9e3819d02d9c" translate="yes" xml:space="preserve">
          <source>Emulated using synchronization functions such that it can be interrupted by &lt;code&gt;&lt;a href=&quot;functions/alarm&quot;&gt;alarm()&lt;/a&gt;&lt;/code&gt;, and limited to a maximum of 4294967 seconds, approximately 49 days. (Win32)</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/alarm&quot;&gt;alarm()&lt;/a&gt;&lt;/code&gt; 의해 중단 될 수 있고 대략 42 일로 최대 4294967 초로 제한 될 수 있도록 동기화 함수를 사용하여 에뮬레이트 됩니다. (Win32)</target>
        </trans-unit>
        <trans-unit id="2fab2548b326a0aed3bd44319bab854e6c0cf455" translate="yes" xml:space="preserve">
          <source>Emulated using timers that must be explicitly polled whenever Perl wants to dispatch &quot;safe signals&quot; and therefore cannot interrupt blocking system calls. (Win32)</source>
          <target state="translated">Perl이 &quot;안전한 신호&quot;를 보내려고 할 때마다 명시 적으로 폴링해야하는 타이머를 사용하여 에뮬레이트되므로 시스템 호출 차단을 방해 할 수 없습니다. (Win32)</target>
        </trans-unit>
        <trans-unit id="9b1e45abf8f6f88976507fbf984db8d99aa517be" translate="yes" xml:space="preserve">
          <source>Emulates Unix &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit()&lt;/a&gt;&lt;/code&gt; (which considers &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit&lt;/a&gt; 1&lt;/code&gt; to indicate an error) by mapping the &lt;code&gt;1&lt;/code&gt; to &lt;code&gt;SS$_ABORT&lt;/code&gt; (&lt;code&gt;44&lt;/code&gt; ). This behavior may be overridden with the pragma &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; vmsish 'exit'&lt;/code&gt; . As with the CRTL's &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit()&lt;/a&gt;&lt;/code&gt; function, &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit&lt;/a&gt; 0&lt;/code&gt; is also mapped to an exit status of &lt;code&gt;SS$_NORMAL&lt;/code&gt; (&lt;code&gt;1&lt;/code&gt; ); this mapping cannot be overridden. Any other argument to &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit()&lt;/a&gt;&lt;/code&gt; is used directly as Perl's exit status. On VMS, unless the future POSIX_EXIT mode is enabled, the exit code should always be a valid VMS exit code and not a generic number. When the POSIX_EXIT mode is enabled, a generic number will be encoded in a method compatible with the C library _POSIX_EXIT macro so that it can be decoded by other programs, particularly ones written in C, like the GNV package. (VMS)</source>
          <target state="translated">&lt;code&gt;1&lt;/code&gt; 을 &lt;code&gt;SS$_ABORT&lt;/code&gt; ( &lt;code&gt;44&lt;/code&gt; ) 에 매핑하여 Unix &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit()&lt;/a&gt;&lt;/code&gt; 에뮬레이트합니다 ( &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit&lt;/a&gt; 1&lt;/code&gt; 을 고려 하여 오류를 나타냄 ). 이 동작은 pragma &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; vmsish 'exit'&lt;/code&gt; vmsish 'exit' 로 재정의 될 수 있습니다 . CRTL의 &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit()&lt;/a&gt;&lt;/code&gt; 함수 와 마찬가지로 &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit&lt;/a&gt; 0&lt;/code&gt; 0 도 종료 상태 &lt;code&gt;SS$_NORMAL&lt;/code&gt; ( &lt;code&gt;1&lt;/code&gt; )에 매핑됩니다 . 이 매핑은 재정의 할 수 없습니다. &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit()&lt;/a&gt;&lt;/code&gt; 다른 인수Perl의 종료 상태로 직접 사용됩니다. VMS에서 향후 POSIX_EXIT 모드를 사용하지 않으면 종료 코드는 항상 일반 번호가 아닌 유효한 VMS 종료 코드 여야합니다. POSIX_EXIT 모드가 활성화되면 일반 번호는 C 라이브러리 _POSIX_EXIT 매크로와 호환되는 방법으로 인코딩되어 다른 프로그램, 특히 GNV 패키지와 같이 C로 작성된 프로그램에서 디코딩 될 수 있습니다. (VMS)</target>
        </trans-unit>
        <trans-unit id="2c857b36dcd15d79dca987f0a21532d5543740f0" translate="yes" xml:space="preserve">
          <source>Emulation is provided for &lt;code&gt;runtests&lt;/code&gt; and &lt;code&gt;execute_tests&lt;/code&gt; but the pluggable 'Straps' interface that previous versions of &lt;a href=&quot;Test::Harness&quot;&gt;Test::Harness&lt;/a&gt; supported is not reproduced here. Straps is now available as a stand alone module: &lt;a href=&quot;Test::Harness::Straps&quot;&gt;Test::Harness::Straps&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a8694061aed01e45167cf3a5722aa921d3e6ee71" translate="yes" xml:space="preserve">
          <source>Emulation is provided for &lt;code&gt;runtests&lt;/code&gt; and &lt;code&gt;execute_tests&lt;/code&gt; but the pluggable 'Straps' interface that previous versions of &lt;a href=&quot;harness&quot;&gt;Test::Harness&lt;/a&gt; supported is not reproduced here. Straps is now available as a stand alone module: &lt;a href=&quot;http://search.cpan.org/perldoc/Test::Harness::Straps&quot;&gt;Test::Harness::Straps&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;runtests&lt;/code&gt; 및 &lt;code&gt;execute_tests&lt;/code&gt; 에뮬레이션이 제공 되지만 이전 버전의 &lt;a href=&quot;harness&quot;&gt;Test :: Harness가&lt;/a&gt; 지원 하는 플러그 가능 '스트랩'인터페이스 는 여기에서 재현되지 않습니다. 스트랩은 이제 독립형 모듈로 제공됩니다 : &lt;a href=&quot;http://search.cpan.org/perldoc/Test::Harness::Straps&quot;&gt;Test :: Harness :: Straps&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0c3201c23058080f5cca7ba534770368c083d322" translate="yes" xml:space="preserve">
          <source>Enable DUMP and all execute options. Equivalent to:</source>
          <target state="translated">DUMP 및 모든 실행 옵션을 활성화하십시오. 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3519927c57abd6568424c455930c1e3320ae7f4f" translate="yes" xml:space="preserve">
          <source>Enable DUMP and all non-extra execute options. Equivalent to:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3687b13f8be99eb4a1bd7121c185ac6fb0233a5d" translate="yes" xml:space="preserve">
          <source>Enable Verbose mode</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7bb7295d3b950c4331c9fe377d6496cd34ea08ee" translate="yes" xml:space="preserve">
          <source>Enable all options at once except OFFSETS, OFFSETSDBG and BUFFERS. (To get every single option without exception, use both ALL and EXTRA.)</source>
          <target state="translated">OFFSETS, OFFSETSDBG 및 BUFFERS를 제외한 모든 옵션을 한 번에 활성화하십시오. (예외없이 모든 단일 옵션을 얻으려면 ALL과 EXTRA를 모두 사용하십시오.)</target>
        </trans-unit>
        <trans-unit id="605ee0c2cc03659c524ca183e1ce55b5400e895c" translate="yes" xml:space="preserve">
          <source>Enable all options at once except OFFSETS, OFFSETSDBG, BUFFERS, WILDCARD, and DUMP_PRE_OPTIMIZE. (To get every single option without exception, use both ALL and EXTRA, or starting in 5.30 on a &lt;code&gt;-DDEBUGGING&lt;/code&gt;-enabled perl interpreter, use the &lt;b&gt;-Drv&lt;/b&gt; command-line switches.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c54f50dbe8b1d2b9d4279a847b1af1e242ac5db" translate="yes" xml:space="preserve">
          <source>Enable caching of timings for the null loop. The time taken for COUNT rounds of the null loop will be calculated only once for each different COUNT used.</source>
          <target state="translated">널 루프에 대한 타이밍 캐싱을 사용 가능하게하십시오. null 루프의 COUNT 라운드에 걸리는 시간은 사용 된 다른 COUNT마다 한 번 씩만 계산됩니다.</target>
        </trans-unit>
        <trans-unit id="af34a92294247e0324cf9cb4ab7591c0157d3cc4" translate="yes" xml:space="preserve">
          <source>Enable debugging of offsets information. This emits copious amounts of trace information and doesn't mesh well with other debug options.</source>
          <target state="translated">오프셋 정보의 디버깅을 활성화합니다. 이것은 많은 양의 추적 정보를 방출하며 다른 디버그 옵션과 잘 맞지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b22eafe66ff9363c232181834545b3e27fc24dda" translate="yes" xml:space="preserve">
          <source>Enable debugging of start-point optimisations.</source>
          <target state="translated">시작점 최적화 디버깅을 활성화합니다.</target>
        </trans-unit>
        <trans-unit id="b1ed4094a3f33fb70b77d3ab5d3985c70cad2408" translate="yes" xml:space="preserve">
          <source>Enable debugging of states in the engine.</source>
          <target state="translated">엔진에서 상태 디버깅을 활성화합니다.</target>
        </trans-unit>
        <trans-unit id="6cc2f783a9f51a88860f66f38bb6654412ccd3b7" translate="yes" xml:space="preserve">
          <source>Enable debugging of the \G modifier.</source>
          <target state="translated">\ G 수정 자의 디버깅을 활성화합니다.</target>
        </trans-unit>
        <trans-unit id="8b1fc985774fbcf866da54c3c69b513cb35f440c" translate="yes" xml:space="preserve">
          <source>Enable debugging of the recursion stack in the engine. Enabling or disabling this option automatically does the same for debugging states as well. This output from this can be quite large.</source>
          <target state="translated">엔진에서 재귀 스택의 디버깅을 활성화합니다. 이 옵션을 활성화하거나 비활성화하면 디버깅 상태에서도 자동으로 동일하게 수행됩니다. 이 결과는 상당히 클 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ed7bfb6f5b63e62332ddfc6bbbaf1f7a2a0d576b" translate="yes" xml:space="preserve">
          <source>Enable debugging output.</source>
          <target state="translated">디버깅 출력을 활성화합니다.</target>
        </trans-unit>
        <trans-unit id="139048524bc56f6e0f7692e0183c038f5bfd94d8" translate="yes" xml:space="preserve">
          <source>Enable debugging the capture group storage during match. Warning, this can potentially produce extremely large output.</source>
          <target state="translated">일치하는 동안 캡처 그룹 스토리지 디버깅을 사용하십시오. 경고, 이것은 잠재적으로 매우 큰 출력을 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d009cb1e8dd02879690564369c53161c26ba761e" translate="yes" xml:space="preserve">
          <source>Enable enhanced TRIE debugging. Enhances both TRIEE and TRIEC.</source>
          <target state="translated">향상된 TRIE 디버깅을 활성화하십시오. TRIEE와 TRIEC을 모두 향상시킵니다.</target>
        </trans-unit>
        <trans-unit id="ef5eb4e7b2447bf19044b39ea2e195cd6618fd76" translate="yes" xml:space="preserve">
          <source>Enable enhanced optimisation debugging and start-point optimisations. Probably not useful except when debugging the regexp engine itself.</source>
          <target state="translated">향상된 최적화 디버깅 및 시작점 최적화를 가능하게합니다. 정규식 엔진 자체를 디버깅하는 경우를 제외하고는 유용하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="07e248f2e2b8869e02ee4bbd9a3b445fa1e02104" translate="yes" xml:space="preserve">
          <source>Enable new features</source>
          <target state="translated">새로운 기능 사용</target>
        </trans-unit>
        <trans-unit id="82441ac52d9ab4a30896d0bdffedf2a9be220d10" translate="yes" xml:space="preserve">
          <source>Enable recognition of &lt;code&gt;IN&lt;/code&gt; , &lt;code&gt;OUT_LIST&lt;/code&gt; and &lt;code&gt;INOUT_LIST&lt;/code&gt; declarations. Default is true.</source>
          <target state="translated">&lt;code&gt;IN&lt;/code&gt; , &lt;code&gt;OUT_LIST&lt;/code&gt; 및 &lt;code&gt;INOUT_LIST&lt;/code&gt; 선언을 인식 할 수 있습니다. 기본값은 true입니다.</target>
        </trans-unit>
        <trans-unit id="fdedc1b60d005db3c310868a2b39cafdd59a5eb1" translate="yes" xml:space="preserve">
          <source>Enable recognition of &lt;code&gt;IN&lt;/code&gt;, &lt;code&gt;OUT_LIST&lt;/code&gt; and &lt;code&gt;INOUT_LIST&lt;/code&gt; declarations. Default is true.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a04f3ebaeb9867e3812b1e018ab387d5924f7ef6" translate="yes" xml:space="preserve">
          <source>Enable recognition of ANSI-like descriptions of function signature. Default is true.</source>
          <target state="translated">함수 서명에 대한 ANSI와 같은 설명을 인식 할 수 있습니다. 기본값은 true입니다.</target>
        </trans-unit>
        <trans-unit id="8fa85b7034e330ca755a5c73c63b76397e087c71" translate="yes" xml:space="preserve">
          <source>Enable simple signal handling</source>
          <target state="translated">간단한 신호 처리 가능</target>
        </trans-unit>
        <trans-unit id="3c3a9e686f47a71d2d2bd49c91054de061662284" translate="yes" xml:space="preserve">
          <source>Enable the breakpoint so it will stop the execution of the program.</source>
          <target state="translated">중단 점을 활성화하여 프로그램 실행을 중지하십시오.</target>
        </trans-unit>
        <trans-unit id="4a2a1634a6a3ef06d28edb649a7e0d6a7bf8554f" translate="yes" xml:space="preserve">
          <source>Enable the dumping of the compiled pattern before the optimization phase.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dcd4f88c7522d41d4cd111539c1b1db699d331e1" translate="yes" xml:space="preserve">
          <source>Enable the options enabled by &quot;All&quot;, plus STATE, TRIEC, and TRIEM.</source>
          <target state="translated">&quot;모두&quot;와 STATE, TRIEC 및 TRIEM으로 활성화 된 옵션을 활성화하십시오.</target>
        </trans-unit>
        <trans-unit id="6607ef3ad5faa3d582896ad07ab9785dae90ca8e" translate="yes" xml:space="preserve">
          <source>Enable this option if you wish all spawned processes to be killed if the initially spawned process (the parent) is killed or dies without waiting for child processes.</source>
          <target state="translated">처음 생성 된 프로세스 (부모)가 자식 프로세스를 기다리지 않고 종료되거나 종료 된 경우 생성 된 모든 프로세스를 종료하려면이 옵션을 활성화하십시오.</target>
        </trans-unit>
        <trans-unit id="b7b7c90b9b4e4815dd4d9b7ad285d70eda8ebb7d" translate="yes" xml:space="preserve">
          <source>Enable/disable UTF-8 (or UTF-EBCDIC) in source code</source>
          <target state="translated">소스 코드에서 UTF-8 (또는 UTF-EBCDIC) 활성화 / 비활성화</target>
        </trans-unit>
        <trans-unit id="80acee2f67ff4da70c6002b5a0e094b4d2f31c43" translate="yes" xml:space="preserve">
          <source>Enables all warnings regardless of &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; warnings&lt;/code&gt; or &lt;code&gt;$^W&lt;/code&gt; . See &lt;a href=&quot;warnings&quot;&gt;warnings&lt;/a&gt;.</source>
          <target state="translated">에 관계없이 모든 경고 가능 &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; warnings&lt;/code&gt; 또는 &lt;code&gt;$^W&lt;/code&gt; . &lt;a href=&quot;warnings&quot;&gt;경고를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="7b9030574fd9ae227a9d9bdb446332c94bd2ab62" translate="yes" xml:space="preserve">
          <source>Enables all warnings regardless of &lt;code&gt;no warnings&lt;/code&gt; or &lt;code&gt;$^W&lt;/code&gt;. See &lt;a href=&quot;warnings&quot;&gt;warnings&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1089d1ea88536805f57559da91fba3d7a2761ecb" translate="yes" xml:space="preserve">
          <source>Enables certain optimizations. The only optimization that is currently affected is the use of</source>
          <target state="translated">특정 최적화를 가능하게합니다. 현재 영향을받는 유일한 최적화 방법은</target>
        </trans-unit>
        <trans-unit id="c2846984fdcc8df09665bcc109bb5474af315f7d" translate="yes" xml:space="preserve">
          <source>Enables or disable debugging by setting the &lt;code&gt;$Benchmark::Debug&lt;/code&gt; flag:</source>
          <target state="translated">&lt;code&gt;$Benchmark::Debug&lt;/code&gt; 플래그 를 설정하여 디버깅을 활성화하거나 비활성화합니다 .</target>
        </trans-unit>
        <trans-unit id="9d480a633ce9bb7aa941c3d98a4cbb4d5ac2bf6a" translate="yes" xml:space="preserve">
          <source>Enables output related to the optimisation phase of compilation.</source>
          <target state="translated">컴파일의 최적화 단계와 관련된 출력을 활성화합니다.</target>
        </trans-unit>
        <trans-unit id="8017ccdfaea2ad3f4aa3c94d96674940233700a6" translate="yes" xml:space="preserve">
          <source>Enables use of the prompt specified by pmt=usr-prmpt on input from the terminal.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e55c00ee236233e66b2d47bad2c1ced81c03c99b" translate="yes" xml:space="preserve">
          <source>Enabling &lt;code&gt;bundling_values&lt;/code&gt; will disable the other two styles of bundling.</source>
          <target state="translated">사용 &lt;code&gt;bundling_values&lt;/code&gt; 는 번들의 다른 두 가지 스타일을 사용할 수 없게됩니다.</target>
        </trans-unit>
        <trans-unit id="b18f32d5490f57e3f4e0f875c588a069b00f5590" translate="yes" xml:space="preserve">
          <source>Enabling the &lt;code&gt;utf8&lt;/code&gt; pragma has the following effect:</source>
          <target state="translated">&lt;code&gt;utf8&lt;/code&gt; pragma를 활성화하면 다음과 같은 효과가 있습니다.</target>
        </trans-unit>
        <trans-unit id="7fe2071dd005ed63dfae111e383f15806253aa16" translate="yes" xml:space="preserve">
          <source>Enabling this option will allow single-character options to be bundled. To distinguish bundles from long option names, long options</source>
          <target state="translated">이 옵션을 활성화하면 단일 문자 옵션을 묶을 수 있습니다. 긴 옵션 이름, 긴 옵션과 번들을 구별하려면</target>
        </trans-unit>
        <trans-unit id="867d7c3018e88764391a8a8cad25d71d6020f155" translate="yes" xml:space="preserve">
          <source>Encapsulation</source>
          <target state="translated">Encapsulation</target>
        </trans-unit>
        <trans-unit id="2059232562a427f990749c23a8c8ebdde1b9014d" translate="yes" xml:space="preserve">
          <source>Encapsulation is important for several reasons. First, it allows you to separate the public API from the private implementation. This means you can change that implementation without breaking the API.</source>
          <target state="translated">캡슐화는 여러 가지 이유로 중요합니다. 먼저 공개 API를 개인 구현과 분리 할 수 ​​있습니다. 즉, API를 중단하지 않고 해당 구현을 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="782e817cf07d938d62f7f0517e130f19ec6b4cf1" translate="yes" xml:space="preserve">
          <source>Encode</source>
          <target state="translated">Encode</target>
        </trans-unit>
        <trans-unit id="e276943b90499b3ae3cf8000afe6554906eb7f6a" translate="yes" xml:space="preserve">
          <source>Encode - character encodings in Perl</source>
          <target state="translated">인코딩-Perl의 문자 인코딩</target>
        </trans-unit>
        <trans-unit id="3c5a64c26d9e551da565d681ba9a9c2bc735a49c" translate="yes" xml:space="preserve">
          <source>Encode Implementation Base Class</source>
          <target state="translated">구현 기본 클래스 인코딩</target>
        </trans-unit>
        <trans-unit id="39e91613c24a80edc94f024f6bfb3382d7e896d8" translate="yes" xml:space="preserve">
          <source>Encode a scalar, hash reference or array reference as YAML.</source>
          <target state="translated">스칼라, 해시 참조 또는 배열 참조를 YAML로 인코딩하십시오.</target>
        </trans-unit>
        <trans-unit id="a78fa70f2287f5b23c037b4b8025fba5e083909c" translate="yes" xml:space="preserve">
          <source>Encode aliases &lt;code&gt;GB2312&lt;/code&gt; to &lt;code&gt;euc-cn&lt;/code&gt; in full agreement with IANA registration. &lt;code&gt;cp936&lt;/code&gt; is supported separately.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="09bb3342b0d46392bfdbf9d685c504c20ab444c4" translate="yes" xml:space="preserve">
          <source>Encode aliases &lt;code&gt;KS_C_5601-1987&lt;/code&gt; to &lt;code&gt;cp949&lt;/code&gt; to reflect this common misusage.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53b3896738d8cf6b15e5278f1369de611febee2e" translate="yes" xml:space="preserve">
          <source>Encode and decode according to the base64 scheme for &quot;URL applications&quot; [1]. This is a variant of the base64 encoding which does not use padding, does not break the string into multiple lines and use the characters &quot;-&quot; and &quot;_&quot; instead of &quot;+&quot; and &quot;/&quot; to avoid using reserved URL characters.</source>
          <target state="translated">&quot;URL 응용 프로그램&quot;에 대한 base64 체계에 따라 인코딩 및 디코딩합니다 [1]. 이것은 패딩을 사용하지 않고 문자열을 여러 줄로 나누지 않고 예약 된 URL 문자 사용을 피하기 위해 &quot;+&quot;및 &quot;/&quot;대신 &quot;-&quot;및 &quot;_&quot;문자를 사용하는 base64 인코딩의 변형입니다.</target>
        </trans-unit>
        <trans-unit id="3d01d8346257820c445f334ba81d16daa9f20915" translate="yes" xml:space="preserve">
          <source>Encode consists of a collection of modules whose details are too extensive to fit in one document. This one itself explains the top-level APIs and general topics at a glance. For other topics and more details, see the documentation for these modules:</source>
          <target state="translated">Encode는 세부 사항이 너무 광범위하여 하나의 문서에 맞지 않는 모듈 콜렉션으로 구성됩니다. 이것 자체가 최상위 API 및 일반 주제를 한 눈에 설명합니다. 다른 주제와 자세한 내용은 다음 모듈의 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="90f9c590e83b0f216769d26a64108ee3d5af71e4" translate="yes" xml:space="preserve">
          <source>Encode converts from the beginning to \x7E, leaving \xe3 in the buffer because it is invalid (partial character).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5888dafc03b9c4595a9ef704f5d312540bc3c184" translate="yes" xml:space="preserve">
          <source>Encode data by calling the encode_base64() function. The first argument is the byte string to encode. The second argument is the line-ending sequence to use. It is optional and defaults to &quot;\n&quot;. The returned encoded string is broken into lines of no more than 76 characters each and it will end with $eol unless it is empty. Pass an empty string as second argument if you do not want the encoded string to be broken into lines.</source>
          <target state="translated">encode_base64 () 함수를 호출하여 데이터를 인코딩하십시오. 첫 번째 인수는 인코딩 할 바이트 문자열입니다. 두 번째 인수는 사용할 행 끝 순서입니다. 선택 사항이며 기본값은 &quot;\ n&quot;입니다. 반환 된 인코딩 된 문자열은 각각 76 자 이하의 줄로 분리되며 비어 있지 않으면 $ eol로 끝납니다. 인코딩 된 문자열을 줄로 나누지 않으려면 빈 문자열을 두 번째 인수로 전달하십시오.</target>
        </trans-unit>
        <trans-unit id="41b574dce061d3c694f8cd7218cbb982019874dd" translate="yes" xml:space="preserve">
          <source>Encode method takes a scalar string as its input and uses &lt;a href=&quot;encode#UTF-8-vs.-utf8-vs.-UTF8&quot;&gt;strict UTF-8&lt;/a&gt; encoder for encoding it to UTF-8 bytes. Then a sequence of UTF-8 bytes is encoded into MIME encoded-words (&lt;code&gt;MIME-Header&lt;/code&gt; and &lt;code&gt;MIME-B&lt;/code&gt; use a Base64 variant while &lt;code&gt;MIME-Q&lt;/code&gt; uses a Quoted-Printable variant) where each MIME encoded-word is limited to 75 characters. MIME encoded-words are separated by &lt;code&gt;CRLF SPACE&lt;/code&gt; and joined to one output string. Output string is suitable for unstructured field body of the email header.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1878d2d011ae54a82ea1609093ac6e764e131f0" translate="yes" xml:space="preserve">
          <source>Encode separately supports &lt;code&gt;Big5&lt;/code&gt; and &lt;code&gt;cp950&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18f5b904d93724daaede7a0f5d5a6e265bb69f88" translate="yes" xml:space="preserve">
          <source>Encode separately supports &lt;code&gt;Shift_JIS&lt;/code&gt; and &lt;code&gt;cp932&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ceff1e1e1923f02a7939b507f33300e3a696eaa2" translate="yes" xml:space="preserve">
          <source>Encode up to 1.86 internally used &quot;local $_&quot; to implement this older form. But consider the code below;</source>
          <target state="translated">내부적으로 사용 된 &quot;local $ _&quot;을 1.86까지 인코딩하여이 이전 양식을 구현하십시오. 그러나 아래 코드를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="dec95d5717280ac4e0be7dcb9e6fc7bc4a47ecee" translate="yes" xml:space="preserve">
          <source>Encode uses the Unicode Character Map (UCM) format for source character mappings. This format is used by IBM's ICU package and was adopted by Nick Ing-Simmons for use with the Encode module. Since UCM is more flexible than Tcl's Encoding Map and far more user-friendly, this is the recommended format for Encode now.</source>
          <target state="translated">인코딩은 소스 문자 매핑에 UCM (Unicode Character Map) 형식을 사용합니다. 이 형식은 IBM의 ICU 패키지에서 사용되며 Nick Ing-Simmons에서 Encode 모듈과 함께 사용하도록 채택되었습니다. UCM은 Tcl의 인코딩 맵보다 훨씬 유연하고 사용자에게 훨씬 친숙하기 때문에 현재 인코딩에 권장되는 형식입니다.</target>
        </trans-unit>
        <trans-unit id="5d2cad9401edfbef92e75be01cb40c4e9ecc4cf6" translate="yes" xml:space="preserve">
          <source>Encode::Alias</source>
          <target state="translated">Encode::Alias</target>
        </trans-unit>
        <trans-unit id="552324ae1eb023be362415291b1291f3f52556a7" translate="yes" xml:space="preserve">
          <source>Encode::Alias - alias definitions to encodings</source>
          <target state="translated">Encode :: Alias-인코딩에 대한 별명 정의</target>
        </trans-unit>
        <trans-unit id="cc91ef6d8b4186209599d785324e380db05af545" translate="yes" xml:space="preserve">
          <source>Encode::Byte</source>
          <target state="translated">Encode::Byte</target>
        </trans-unit>
        <trans-unit id="d4b97f8bcca673137fe3a8c4311fa29b1376a129" translate="yes" xml:space="preserve">
          <source>Encode::Byte - Single Byte Encodings</source>
          <target state="translated">인코딩 :: 바이트-단일 바이트 인코딩</target>
        </trans-unit>
        <trans-unit id="930606b772f93c8896784219cc491d7a0cee7e76" translate="yes" xml:space="preserve">
          <source>Encode::Byte -- Extended ASCII</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34f240792605e5eac4a6580e33ee29dcc7a428c2" translate="yes" xml:space="preserve">
          <source>Encode::Byte implements most single-byte encodings except for Symbols and EBCDIC. The following encodings are based on single-byte encodings implemented as extended ASCII. Most of them map \x80-\xff (upper half) to non-ASCII characters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8da29f26c3e55351d546a404e8b09b53f82affc8" translate="yes" xml:space="preserve">
          <source>Encode::CJKConstants</source>
          <target state="translated">Encode::CJKConstants</target>
        </trans-unit>
        <trans-unit id="97376755cadc9b08ac2bdcffa80b5c4759e6f7df" translate="yes" xml:space="preserve">
          <source>Encode::CJKConstants.pm -- Internally used by Encode::??::ISO_2022_*</source>
          <target state="translated">Encode :: CJKConstants.pm-Encode :: ?? :: ISO_2022_ *에서 내부적으로 사용</target>
        </trans-unit>
        <trans-unit id="44fea5bddc6721fb4b956554b9d88900826d60c7" translate="yes" xml:space="preserve">
          <source>Encode::CN</source>
          <target state="translated">Encode::CN</target>
        </trans-unit>
        <trans-unit id="40f3392265131b672490757c292c084a525d4184" translate="yes" xml:space="preserve">
          <source>Encode::CN - China-based Chinese Encodings</source>
          <target state="translated">Encode :: CN-중국 기반 중국어 인코딩</target>
        </trans-unit>
        <trans-unit id="56aaed97f5a41017265e5458630887666002ff6b" translate="yes" xml:space="preserve">
          <source>Encode::CN -- Continental China</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="207660f321fc12762f2e79b28e35fbb26736a3e7" translate="yes" xml:space="preserve">
          <source>Encode::CN::HZ</source>
          <target state="translated">Encode::CN::HZ</target>
        </trans-unit>
        <trans-unit id="622d7b0a21ca0c1a08d6dda20da0057e0358570c" translate="yes" xml:space="preserve">
          <source>Encode::CN::HZ -- internally used by Encode::CN</source>
          <target state="translated">Encode :: CN :: HZ-Encode :: CN에서 내부적으로 사용</target>
        </trans-unit>
        <trans-unit id="b24bb381f68ba02b49c4c2cd2767f183910da09e" translate="yes" xml:space="preserve">
          <source>Encode::Config</source>
          <target state="translated">Encode::Config</target>
        </trans-unit>
        <trans-unit id="0b7c024127a98fc8be2586eade5f76bc22701aab" translate="yes" xml:space="preserve">
          <source>Encode::Config -- internally used by Encode</source>
          <target state="translated">Encode :: Config-Encode에서 내부적으로 사용</target>
        </trans-unit>
        <trans-unit id="2a8ba6ae9bd0735a827d283930aa3dc28cd2cae3" translate="yes" xml:space="preserve">
          <source>Encode::EBCDIC</source>
          <target state="translated">Encode::EBCDIC</target>
        </trans-unit>
        <trans-unit id="3b31a7154f7c03e9be274aacce1e4dc5a66d5ec6" translate="yes" xml:space="preserve">
          <source>Encode::EBCDIC - EBCDIC Encodings</source>
          <target state="translated">인코딩 :: EBCDIC-EBCDIC 인코딩</target>
        </trans-unit>
        <trans-unit id="a0fb1479e2e68a75a05e36aff16d787758a1778e" translate="yes" xml:space="preserve">
          <source>Encode::Encoder</source>
          <target state="translated">Encode::Encoder</target>
        </trans-unit>
        <trans-unit id="3bfd37620385e094ff5d1811f8a5aaf8e5a7a125" translate="yes" xml:space="preserve">
          <source>Encode::Encoder -- Object Oriented Encoder</source>
          <target state="translated">Encode :: Encoder-객체 지향 인코더</target>
        </trans-unit>
        <trans-unit id="4551a7e4c9181d379ae1288237c1ebecccd59bb8" translate="yes" xml:space="preserve">
          <source>Encode::Encoding</source>
          <target state="translated">Encode::Encoding</target>
        </trans-unit>
        <trans-unit id="932dfcdaef25e880e85283d712d29f239746970b" translate="yes" xml:space="preserve">
          <source>Encode::Encoding - Encode Implementation Base Class</source>
          <target state="translated">Encode :: Encoding-인코딩 구현 기본 클래스</target>
        </trans-unit>
        <trans-unit id="77662ad703615bf25ca69905bb6db23d72296bb9" translate="yes" xml:space="preserve">
          <source>Encode::GSM0338</source>
          <target state="translated">Encode::GSM0338</target>
        </trans-unit>
        <trans-unit id="ede01420f58b4c2565b3da82244d84c95da5b4af" translate="yes" xml:space="preserve">
          <source>Encode::GSM0338 -- ESTI GSM 03.38 Encoding</source>
          <target state="translated">인코딩 :: GSM0338-ESTI GSM 03.38 인코딩</target>
        </trans-unit>
        <trans-unit id="e93ed447e10d95864f0386c026ec121cd47c60ab" translate="yes" xml:space="preserve">
          <source>Encode::Guess</source>
          <target state="translated">Encode::Guess</target>
        </trans-unit>
        <trans-unit id="8b1b151431a67a55222cbbcf0270cd834cbd2d46" translate="yes" xml:space="preserve">
          <source>Encode::Guess -- Guesses encoding from data</source>
          <target state="translated">Encode :: Guess-데이터 인코딩을 추측합니다</target>
        </trans-unit>
        <trans-unit id="f460e270f104cac10b54ab28764ae1739d32a63f" translate="yes" xml:space="preserve">
          <source>Encode::Guess does not work on EBCDIC platforms.</source>
          <target state="translated">EBCDIC 플랫폼에서는 Encode :: Guess가 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8030a57667933f97cc9c39195dbf244e622a18a0" translate="yes" xml:space="preserve">
          <source>Encode::Guess enables you to guess in what encoding a given data is encoded, or at least tries to.</source>
          <target state="translated">Encode :: Guess를 사용하면 주어진 데이터가 어떤 인코딩으로 인코딩되었는지 또는 최소한 시도하는지 추측 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4c76dcf9e721cd63d6b7c64ae9ac390cd36bca44" translate="yes" xml:space="preserve">
          <source>Encode::Guess-&amp;gt;add_suspects</source>
          <target state="translated">Encode::Guess-&amp;gt;add_suspects</target>
        </trans-unit>
        <trans-unit id="e5a679cb789609bd6b4f6bc29c3c93aa2af2b209" translate="yes" xml:space="preserve">
          <source>Encode::Guess-&amp;gt;guess($data)</source>
          <target state="translated">Encode::Guess-&amp;gt;guess($data)</target>
        </trans-unit>
        <trans-unit id="91b94bb51243fdcafbdb22a3d3b975f9b8695d1d" translate="yes" xml:space="preserve">
          <source>Encode::Guess-&amp;gt;set_suspects</source>
          <target state="translated">Encode::Guess-&amp;gt;set_suspects</target>
        </trans-unit>
        <trans-unit id="a0735b72517ca9ff3c7f14337ef1ad3eeea0e3f0" translate="yes" xml:space="preserve">
          <source>Encode::HanExtra -- More Chinese via CPAN</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f9eb31f93d16c6f8ad3ca48a91dab8c5071fe46" translate="yes" xml:space="preserve">
          <source>Encode::JIS2K -- JIS X 0213 encodings via CPAN</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e37ee0e2e550bc3634d116c838f3ba94375b8c47" translate="yes" xml:space="preserve">
          <source>Encode::JP</source>
          <target state="translated">Encode::JP</target>
        </trans-unit>
        <trans-unit id="341afac777ffb0b1e52b3a6aa26c1fcd31687ea1" translate="yes" xml:space="preserve">
          <source>Encode::JP - Japanese Encodings</source>
          <target state="translated">인코딩 :: JP-일본어 인코딩</target>
        </trans-unit>
        <trans-unit id="4d2ce26abda0dd0d175937050c97398037e5cc87" translate="yes" xml:space="preserve">
          <source>Encode::JP -- Japan</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e6a27be2a727bdf7e4a113a80bef5ed7da8c32a" translate="yes" xml:space="preserve">
          <source>Encode::JP::H2Z</source>
          <target state="translated">Encode::JP::H2Z</target>
        </trans-unit>
        <trans-unit id="61c842d29f655e9a02cc88f2dfe176c79b0a7ccb" translate="yes" xml:space="preserve">
          <source>Encode::JP::H2Z -- internally used by Encode::JP::2022_JP*</source>
          <target state="translated">Encode :: JP :: H2Z-Encode :: JP :: 2022_JP *에서 내부적으로 사용</target>
        </trans-unit>
        <trans-unit id="57d3b7cea6d80534a4eab96981ae8b12e91a572d" translate="yes" xml:space="preserve">
          <source>Encode::JP::JIS7</source>
          <target state="translated">Encode::JP::JIS7</target>
        </trans-unit>
        <trans-unit id="728d78512ef0e5fd10db6af9228f9f55491f142e" translate="yes" xml:space="preserve">
          <source>Encode::JP::JIS7 -- internally used by Encode::JP</source>
          <target state="translated">Encode :: JP :: JIS7-Encode :: JP에서 내부적으로 사용</target>
        </trans-unit>
        <trans-unit id="9292d6d6d6c3d612ab88b4d0a9b44cce420ff5ea" translate="yes" xml:space="preserve">
          <source>Encode::KR</source>
          <target state="translated">Encode::KR</target>
        </trans-unit>
        <trans-unit id="32eef4f01d06c098fb548d1006c901f52a812e7e" translate="yes" xml:space="preserve">
          <source>Encode::KR - Korean Encodings</source>
          <target state="translated">Encode :: KR-한국어 인코딩</target>
        </trans-unit>
        <trans-unit id="1af58b45e5ddb5840265bad145aa164eaffbeea7" translate="yes" xml:space="preserve">
          <source>Encode::KR -- Korea</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="adea371ce7b9ff3c3566f35ac1420ac2e2ede009" translate="yes" xml:space="preserve">
          <source>Encode::KR::2022_KR</source>
          <target state="translated">Encode::KR::2022_KR</target>
        </trans-unit>
        <trans-unit id="3976fa623737771006bbaafdf23430529728651d" translate="yes" xml:space="preserve">
          <source>Encode::KR::2022_KR -- internally used by Encode::KR</source>
          <target state="translated">Encode :: KR :: 2022_KR-Encode :: KR에서 내부적으로 사용</target>
        </trans-unit>
        <trans-unit id="e9d431857fb2daca858cf0e24708414e6076d14b" translate="yes" xml:space="preserve">
          <source>Encode::MIME::Header</source>
          <target state="translated">Encode::MIME::Header</target>
        </trans-unit>
        <trans-unit id="f2030bc40a6a13ab85bce58de044a451e0f2022a" translate="yes" xml:space="preserve">
          <source>Encode::MIME::Header -- MIME 'B' and 'Q' header encoding</source>
          <target state="translated">인코딩 :: MIME :: 헤더-MIME 'B'및 'Q'헤더 인코딩</target>
        </trans-unit>
        <trans-unit id="8d4bde122083dca41ec16dc22bc309e1ca8f4388" translate="yes" xml:space="preserve">
          <source>Encode::MIME::Header -- MIME encoding for an unstructured email header</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="660e24530b4b214dbcf404910cce6c40e5661246" translate="yes" xml:space="preserve">
          <source>Encode::MIME::NAME -- internally used by Encode</source>
          <target state="translated">Encode :: MIME :: NAME-Encode에서 내부적으로 사용</target>
        </trans-unit>
        <trans-unit id="5f4e8291cc2cc181fac6cfb29c5aaebe19ffe8d7" translate="yes" xml:space="preserve">
          <source>Encode::MIME::Name</source>
          <target state="translated">Encode::MIME::Name</target>
        </trans-unit>
        <trans-unit id="28fab0785bc684a2a52d97e53a66b49d5527d9be" translate="yes" xml:space="preserve">
          <source>Encode::PerlIO</source>
          <target state="translated">Encode::PerlIO</target>
        </trans-unit>
        <trans-unit id="41a3b8bb23e3f7b5138303897788011e915cffdf" translate="yes" xml:space="preserve">
          <source>Encode::PerlIO -- a detailed document on Encode and PerlIO</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ecd20dbfc849a216b8ec8f0aae8d9f22755869e7" translate="yes" xml:space="preserve">
          <source>Encode::Supported</source>
          <target state="translated">Encode::Supported</target>
        </trans-unit>
        <trans-unit id="eb0c5a3a273c3a4c4ad776ddaca0c86b8236ef3c" translate="yes" xml:space="preserve">
          <source>Encode::Supported -- Encodings supported by Encode</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="617dc5e07f69ab0016776f02fcae4aa5417d4cf3" translate="yes" xml:space="preserve">
          <source>Encode::Symbol</source>
          <target state="translated">Encode::Symbol</target>
        </trans-unit>
        <trans-unit id="305d6a4ecfbcb83575125920205199ebfad9ecbc" translate="yes" xml:space="preserve">
          <source>Encode::Symbol - Symbol Encodings</source>
          <target state="translated">인코딩 :: 기호-기호 인코딩</target>
        </trans-unit>
        <trans-unit id="246710749ac240e0889edf0116d38bdff86ae7a9" translate="yes" xml:space="preserve">
          <source>Encode::Symbols</source>
          <target state="translated">Encode::Symbols</target>
        </trans-unit>
        <trans-unit id="7353083e24fd78826faff9ec9dd3ca1f0abfeb68" translate="yes" xml:space="preserve">
          <source>Encode::TW</source>
          <target state="translated">Encode::TW</target>
        </trans-unit>
        <trans-unit id="169a69c17f2e47c33a2090f250bc6f54465bac9c" translate="yes" xml:space="preserve">
          <source>Encode::TW - Taiwan-based Chinese Encodings</source>
          <target state="translated">Encode :: TW-대만 기반 중국어 인코딩</target>
        </trans-unit>
        <trans-unit id="0a45467a524b47a94315245ccf968b728241554a" translate="yes" xml:space="preserve">
          <source>Encode::TW -- Taiwan</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f419db0e193bdb95ad1bf1d32e4308acad0add9f" translate="yes" xml:space="preserve">
          <source>Encode::Unicode</source>
          <target state="translated">Encode::Unicode</target>
        </trans-unit>
        <trans-unit id="2ba2c8325c871771b84294002113cdbbccea72d4" translate="yes" xml:space="preserve">
          <source>Encode::Unicode -- Various Unicode Transformation Formats</source>
          <target state="translated">Encode :: Unicode-다양한 유니 코드 변환 형식</target>
        </trans-unit>
        <trans-unit id="510f299bed8b57aaad0840b1977677d5faf52278" translate="yes" xml:space="preserve">
          <source>Encode::Unicode -- other Unicode encodings</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="24e91aa87151df83dcd6a084acf2bef4fbe28cca" translate="yes" xml:space="preserve">
          <source>Encode::Unicode::UTF7</source>
          <target state="translated">Encode::Unicode::UTF7</target>
        </trans-unit>
        <trans-unit id="46189c892fa791248c9e1697ba2bd11d7d60c2a5" translate="yes" xml:space="preserve">
          <source>Encode::Unicode::UTF7 -- UTF-7 encoding</source>
          <target state="translated">인코딩 :: 유니 코드 :: UTF7-UTF-7 인코딩</target>
        </trans-unit>
        <trans-unit id="89d34727747f027f9d8e6303c1a70b2655a0c0fe" translate="yes" xml:space="preserve">
          <source>Encode::decode(&quot;Guess&quot; ...)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ca2ce49b12c2ee816a410523ba091dc693a60d6" translate="yes" xml:space="preserve">
          <source>Encodes a scalar, hash reference or array reference as YAMLish.</source>
          <target state="translated">스칼라, 해시 참조 또는 배열 참조를 YAMLish로 인코딩합니다.</target>
        </trans-unit>
        <trans-unit id="225ac8da293afbab880950db9793bf5ef9a811e8" translate="yes" xml:space="preserve">
          <source>Encodes the invocand as a byte string in the given format as specified in IEEE 754-2008. Note that the encoded value is the nearest possible representation of the value. This value might not be exactly the same as the value in the invocand.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f4c840f47e19e39ed11ebf36e763d836813b7799" translate="yes" xml:space="preserve">
          <source>Encodes the scalar value</source>
          <target state="translated">스칼라 값을 인코딩합니다</target>
        </trans-unit>
        <trans-unit id="5821fec7ee87050117e2081a31b307f34868a8ad" translate="yes" xml:space="preserve">
          <source>Encoding</source>
          <target state="translated">Encoding</target>
        </trans-unit>
        <trans-unit id="8febd2fa21d6fa8e1d3dfe269d8ca87dc204d2c3" translate="yes" xml:space="preserve">
          <source>Encoding Classification (by Anton Tagunov and Dan Kogai)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f33835dcaa05ba53de2779ac501c0b636ae0c061" translate="yes" xml:space="preserve">
          <source>Encoding Names</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e649a0b553388aa0aefbd82d8b0f0d1a27873465" translate="yes" xml:space="preserve">
          <source>Encoding and decoding of base64 strings</source>
          <target state="translated">base64 문자열의 인코딩 및 디코딩</target>
        </trans-unit>
        <trans-unit id="6b77915998634f10773a65ebf127633caa0903b3" translate="yes" xml:space="preserve">
          <source>Encoding and decoding of quoted-printable strings</source>
          <target state="translated">인용 인쇄 가능한 문자열의 인코딩 및 디코딩</target>
        </trans-unit>
        <trans-unit id="a998510992fa4d69263beacea1ddcc7415077441" translate="yes" xml:space="preserve">
          <source>Encoding handling assumes that PerlIO is available and does not work properly if it isn't. The &lt;code&gt;utf8&lt;/code&gt; option is therefore not supported unless Perl is built with PerlIO support.</source>
          <target state="translated">인코딩 처리는 PerlIO가 사용 가능하고 사용 가능하지 않으면 제대로 작동하지 않는다고 가정합니다. &lt;code&gt;utf8&lt;/code&gt; 펄이은 PerlIO 지원을 내장하지 않는 옵션 때문에 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="04cfa3e7800a4d240dc7f677c9407b294c248bcf" translate="yes" xml:space="preserve">
          <source>Encoding layer</source>
          <target state="translated">인코딩 레이어</target>
        </trans-unit>
        <trans-unit id="b9782d5b4b9e78ce07208ac3d1921ad180cd2fcb" translate="yes" xml:space="preserve">
          <source>Encoding names</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="680e8d978db89c29bc9f5396c102c8ec2731a094" translate="yes" xml:space="preserve">
          <source>Encoding names are case insensitive. White space in names is ignored. In addition, an encoding may have aliases. Each encoding has one &quot;canonical&quot; name. The &quot;canonical&quot; name is chosen from the names of the encoding by picking the first in the following sequence (with a few exceptions).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01cbaf646f7cdfb7eb0fbb21f815c71c722e02c1" translate="yes" xml:space="preserve">
          <source>Encoding via PerlIO</source>
          <target state="translated">PerlIO를 통한 인코딩</target>
        </trans-unit>
        <trans-unit id="46fade9210aeab4b837cd79bdf4256d2a5f65faf" translate="yes" xml:space="preserve">
          <source>Encoding vs. Charset -- terminology</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="27e06c1fc55b2907153074d333e66853227f2028" translate="yes" xml:space="preserve">
          <source>Encodings are categorized and implemented in several different modules but you don't have to &lt;code&gt;use Encode::XX&lt;/code&gt; to make them available for most cases. Encode.pm will automatically load those modules on demand.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bcc5b05d5a707cb27dff01159bcf1a3ca6a46e7c" translate="yes" xml:space="preserve">
          <source>Encodings supported by Encode</source>
          <target state="translated">인코딩이 지원하는 인코딩</target>
        </trans-unit>
        <trans-unit id="f136f667340e5f4c44804d0073e50a60db219512" translate="yes" xml:space="preserve">
          <source>Encrypted communication channel</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c4ae224ac38c50705eb255694dceb50337fe4c9" translate="yes" xml:space="preserve">
          <source>End of File. Sometimes used metaphorically as the terminating string of a &lt;b&gt;here document&lt;/b&gt;.</source>
          <target state="translated">파일 끝. &lt;b&gt;here 문서&lt;/b&gt; 의 종료 문자열로 은유 적으로 사용되기도 &lt;b&gt;합니다&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="e61fae84390da1a34c4b2fbd657622d5073292c7" translate="yes" xml:space="preserve">
          <source>End of file.</source>
          <target state="translated">파일 끝.</target>
        </trans-unit>
        <trans-unit id="d1e4562e3c175d8468bb1a01a7952bd0d3b259e1" translate="yes" xml:space="preserve">
          <source>End the sending of data to the remote server. This is done by ensuring that the data already sent ends with CRLF then sending '.CRLF' to end the transmission. Once this data has been sent &lt;code&gt;dataend&lt;/code&gt; calls &lt;code&gt;response&lt;/code&gt; and returns true if &lt;code&gt;response&lt;/code&gt; returns CMD_OK.</source>
          <target state="translated">원격 서버로의 데이터 전송을 종료하십시오. 이것은 이미 전송 된 데이터가 CRLF로 끝난 다음 '.CRLF'를 전송하여 전송을 종료함으로써 이루어집니다. 이 데이터가 전송되면 &lt;code&gt;dataend&lt;/code&gt; 는 &lt;code&gt;response&lt;/code&gt; 를 호출 하고 &lt;code&gt;response&lt;/code&gt; 가 CMD_OK를 반환 하면 true를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="5b395d065aa5966c6da16e4b8c501ca68c3ecd37" translate="yes" xml:space="preserve">
          <source>End-tokens from Pod::Simple::PullParser</source>
          <target state="translated">Pod :: Simple :: PullParser의 엔드 토큰</target>
        </trans-unit>
        <trans-unit id="8676dbbd19637e0c1604c4bcd69f9208a03cfa1a" translate="yes" xml:space="preserve">
          <source>End.U</source>
          <target state="translated">End.U</target>
        </trans-unit>
        <trans-unit id="d1787011d64eb206cd1d2b206a7e53314fc2df0d" translate="yes" xml:space="preserve">
          <source>Ends a try block. See &lt;a href=&quot;perlguts#Exception-Handling&quot;&gt;&quot;Exception Handling&quot; in perlguts&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f4d04612cae76dda50e81f179859b4b712ba14ff" translate="yes" xml:space="preserve">
          <source>Ends a try block. See &lt;a href=&quot;perlguts#Exception-Handling&quot;&gt;Exception Handling in perlguts&lt;/a&gt;.</source>
          <target state="translated">try 블록을 종료합니다. &lt;a href=&quot;perlguts#Exception-Handling&quot;&gt;perlguts의 예외 처리를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="5ea2083617805ed93273c46ed0c4792fa3da7a0b" translate="yes" xml:space="preserve">
          <source>Enforce type integrity if required</source>
          <target state="translated">필요한 경우 형식 무결성 시행</target>
        </trans-unit>
        <trans-unit id="286ca1647ce3f25ee107c4a9d50837ecd6b2a964" translate="yes" xml:space="preserve">
          <source>Enforcing redispatch</source>
          <target state="translated">재발급 시행</target>
        </trans-unit>
        <trans-unit id="a1681854c9f0debb40072c691fd6f403e3a9401c" translate="yes" xml:space="preserve">
          <source>Enginsite</source>
          <target state="translated">Enginsite</target>
        </trans-unit>
        <trans-unit id="649df08a448ee3fa90f3746baaf6b0907df42c91" translate="yes" xml:space="preserve">
          <source>English</source>
          <target state="translated">English</target>
        </trans-unit>
        <trans-unit id="256aa1d5dab6cf2100434b619aada1a930ae7c7d" translate="yes" xml:space="preserve">
          <source>English ('en') is</source>
          <target state="translated">영어 ( 'en')는</target>
        </trans-unit>
        <trans-unit id="7aa949020d6b22aac250e3885290aa830dd72a15" translate="yes" xml:space="preserve">
          <source>English - use nice English (or awk) names for ugly punctuation variables</source>
          <target state="translated">영어-못생긴 구두점 변수에 멋진 영어 (또는 awk) 이름 사용</target>
        </trans-unit>
        <trans-unit id="34afa6db1cf569bd02a3ffe4f7e6036f1798a631" translate="yes" xml:space="preserve">
          <source>English.pm</source>
          <target state="translated">English.pm</target>
        </trans-unit>
        <trans-unit id="99343727bceed607c32f483621540aee48471580" translate="yes" xml:space="preserve">
          <source>Enough of the definition talk! Let's have a few examples.</source>
          <target state="translated">충분한 정의 이야기! 몇 가지 예를 들어 봅시다.</target>
        </trans-unit>
        <trans-unit id="d899ea5401439c93a0c8f86febf8bb8f4f088e5d" translate="yes" xml:space="preserve">
          <source>Ensure that colons marking targets are preceded by space, in order to distinguish the target delimiter from a colon appearing as part of a filespec.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8988a13726c59d935ea79d755d1455be0fc83772" translate="yes" xml:space="preserve">
          <source>Ensure that you know what \b really does: it's the boundary between a word character, \w, and something that isn't a word character. That thing that isn't a word character might be \W, but it can also be the start or end of the string.</source>
          <target state="translated">\ b가 실제로 무엇을하는지 확인하십시오 : 단어 문자 \ w와 단어 문자가 아닌 것 사이의 경계입니다. 단어 문자가 아닌 것은 \ W 일 수도 있지만 문자열의 시작 또는 끝일 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="8680a11001e2d2163c0b3f5d95efb035f3fa7b03" translate="yes" xml:space="preserve">
          <source>Ensure you're following the latest advice</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21287dbbbfc03a6ee27ae105b87e32fa291261eb" translate="yes" xml:space="preserve">
          <source>Ensure your module works under &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict&lt;/code&gt; and &lt;code&gt;-w&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict&lt;/code&gt; 하고 &lt;code&gt;-w&lt;/code&gt; 를&lt;a href=&quot;functions/use&quot;&gt;사용&lt;/a&gt; 하여 모듈이 작동하는지 확인</target>
        </trans-unit>
        <trans-unit id="ee84d37b57aec0c02ba775d818a3471f6da99fba" translate="yes" xml:space="preserve">
          <source>Ensure your module works under &lt;code&gt;use strict&lt;/code&gt; and &lt;code&gt;-w&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3137a5d79c4479978038346bf282e1d45e0aa011" translate="yes" xml:space="preserve">
          <source>Ensures that &lt;code&gt;MoveFileEx&lt;/code&gt; won't return until the operation has finished and been flushed to disk. This is not supported under Windows 95. Only affects file renames to another file system, forcing a buffer flush at the end of the copy operation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f974b332a5fa28c86d4229cace8185f73744894" translate="yes" xml:space="preserve">
          <source>Ensures that sv is a SVt_PV and that its SvCUR is 0, and that it is properly null terminated. Equivalent to sv_setpvs(&quot;&quot;), but more efficient.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1279af9b58018ff33488efc0656bb62fda8db44f" translate="yes" xml:space="preserve">
          <source>Enter interactive mode by running</source>
          <target state="translated">다음을 실행하여 대화식 모드로 들어갑니다.</target>
        </trans-unit>
        <trans-unit id="74eb99da3b9ba3df5f4be61ae4522068a9b27d10" translate="yes" xml:space="preserve">
          <source>Entire arrays (and slices of arrays and hashes) are denoted by '@', which works much as the word &quot;these&quot; or &quot;those&quot; does in English, in that it indicates multiple values are expected.</source>
          <target state="translated">전체 배열 (및 배열 및 해시 조각)은 '@'로 표시되는데, 이는 &quot;these&quot;또는 &quot;those&quot;라는 단어가 영어로하는 것처럼 작동하며 여러 값이 예상됨을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="d245bbc8252b0b71ede0a2f949fc5b29d829fd5d" translate="yes" xml:space="preserve">
          <source>Entire hashes are denoted by '%':</source>
          <target state="translated">전체 해시는 '%'로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="4f918189cf78ab84f6519ba2dcb57f2ae316f72b" translate="yes" xml:space="preserve">
          <source>Entries cannot be plain object files, as many Win32 compilers will not handle object files in the place of libraries.</source>
          <target state="translated">많은 Win32 컴파일러가 라이브러리 대신 객체 파일을 처리하지 않으므로 항목은 일반 객체 파일이 될 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="673fba8e1fb3916663891e031f77ca1343408944" translate="yes" xml:space="preserve">
          <source>Entries in &lt;code&gt;$potential_libs&lt;/code&gt; beginning with a colon and followed by alphanumeric characters are treated as flags. Unknown flags will be ignored.</source>
          <target state="translated">콜론 &lt;code&gt;$potential_libs&lt;/code&gt; 시작하고 그 뒤에 영숫자 문자가 오는 $ potential_libs의 항목은 플래그로 처리됩니다. 알 수없는 플래그는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="a95d99085680ef5c64c2fe5754604ba2f596d896" translate="yes" xml:space="preserve">
          <source>Entries such as:</source>
          <target state="translated">다음과 같은 항목 :</target>
        </trans-unit>
        <trans-unit id="8d07f7a288d3779719c1509961105704b61f4cef" translate="yes" xml:space="preserve">
          <source>Entry in the INPUT section of a typemap</source>
          <target state="translated">타입 맵의 INPUT 섹션에있는 항목</target>
        </trans-unit>
        <trans-unit id="237fc607826e845da2eb03390fed5a45c866b715" translate="yes" xml:space="preserve">
          <source>Entry in the OUTPUT section of a typemap</source>
          <target state="translated">타입 맵의 OUTPUT 섹션에있는 항목</target>
        </trans-unit>
        <trans-unit id="81a846de6d38920893fe50bf678fb10abc3847e2" translate="yes" xml:space="preserve">
          <source>Entry in the TYPEMAP section of a typemap</source>
          <target state="translated">타입 맵의 TYPEMAP 섹션에있는 항목</target>
        </trans-unit>
        <trans-unit id="f211ac2a755354cfc7e79a205b52eb23e2f010b1" translate="yes" xml:space="preserve">
          <source>Entware-ng comes with a precompiled 5.24.1 (June 2017) that allowes building shared XS code. Note that this installation does &lt;b&gt;not&lt;/b&gt; use a site_perl folder. The available &lt;code&gt;cpan&lt;/code&gt; works. If all required development packages are installed too, also for XS.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a2562690818adae41c773c584b6f6c09ebb4d39c" translate="yes" xml:space="preserve">
          <source>Env</source>
          <target state="translated">Env</target>
        </trans-unit>
        <trans-unit id="fbbe5fa808eea7f4c74b5ba16db47dab460bc3b9" translate="yes" xml:space="preserve">
          <source>Env - perl module that imports environment variables as scalars or arrays</source>
          <target state="translated">환경 변수를 스칼라 또는 배열로 가져 오는 펄 모듈</target>
        </trans-unit>
        <trans-unit id="ec072bba7befaa68af710fe3549eb0491d7badd1" translate="yes" xml:space="preserve">
          <source>Environment Variables</source>
          <target state="translated">환경 변수</target>
        </trans-unit>
        <trans-unit id="e19f8816c6f7ccbb7d40a44b81def1ffb731d4e0" translate="yes" xml:space="preserve">
          <source>Environment for Compiling perl on Solaris</source>
          <target state="translated">Solaris에서 perl을 컴파일하기위한 환경</target>
        </trans-unit>
        <trans-unit id="1173b2e11bd16e5dc36c119a4b84f02be11626b5" translate="yes" xml:space="preserve">
          <source>Environment variables</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7e160747cc9ac3da385ca9f9c1cb6f2e6810dff" translate="yes" xml:space="preserve">
          <source>Environment variables that the program cares about, normally presented as a list using &lt;code&gt;=over&lt;/code&gt; , &lt;code&gt;=item&lt;/code&gt; , and &lt;code&gt;=back&lt;/code&gt; . For example:</source>
          <target state="translated">프로그램이 관심을 갖는 환경 변수는 일반적으로 &lt;code&gt;=over&lt;/code&gt; , &lt;code&gt;=item&lt;/code&gt; 및 &lt;code&gt;=back&lt;/code&gt; 을 사용하여 목록으로 표시됩니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="047031c84702987a532453c9aba009b3c909ceb6" translate="yes" xml:space="preserve">
          <source>Environment variables that the program cares about, normally presented as a list using &lt;code&gt;=over&lt;/code&gt;, &lt;code&gt;=item&lt;/code&gt;, and &lt;code&gt;=back&lt;/code&gt;. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59ed6121898e672a267f0f15674f039aebf49694" translate="yes" xml:space="preserve">
          <source>Environment variables to be set during the command</source>
          <target state="translated">명령 중에 설정 될 환경 변수</target>
        </trans-unit>
        <trans-unit id="ec3aedc215415465ba248c2b745d070af96045ef" translate="yes" xml:space="preserve">
          <source>Eof</source>
          <target state="translated">Eof</target>
        </trans-unit>
        <trans-unit id="7264243f4aeaaab7fbb98bd7afd5e953b5900f7b" translate="yes" xml:space="preserve">
          <source>Equality Operators</source>
          <target state="translated">평등 연산자</target>
        </trans-unit>
        <trans-unit id="f6a4eb155ac0505cd34f3102780f106892d4662a" translate="yes" xml:space="preserve">
          <source>Equivalence between Decimal and Dotted-Decimal Versions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1cfd756767e68de5473421aba90c9077344def28" translate="yes" xml:space="preserve">
          <source>Equivalent examples:</source>
          <target state="translated">동등한 예 :</target>
        </trans-unit>
        <trans-unit id="c61e2265d123d76133484971263eb3576ac59dd9" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;$octets = encode(&quot;utf8&quot;, $string)&lt;/code&gt; . The characters in $string are encoded in Perl's internal format, and the result is returned as a sequence of octets. Because all possible characters in Perl have a (loose, not strict) UTF-8 representation, this function cannot fail.</source>
          <target state="translated">상당 &lt;code&gt;$octets = encode(&quot;utf8&quot;, $string)&lt;/code&gt; . $ string의 문자는 Perl의 내부 형식으로 인코딩되며 결과는 일련의 8 진수로 반환됩니다. Perl의 모든 가능한 문자는 (느슨하고 엄격하지 않은) UTF-8 표현을 가지므로이 기능은 실패 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="2e78d6f894c7d9e2878d9273592738107eb000e0" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;$octets = encode(&quot;utf8&quot;, $string)&lt;/code&gt;. The characters in $string are encoded in Perl's internal format, and the result is returned as a sequence of octets. Because all possible characters in Perl have a (loose, not strict) utf8 representation, this function cannot fail.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a263a53c5879a617814d231b90b810689cbeec78" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;$string = decode(&quot;utf8&quot;, $octets [, CHECK])&lt;/code&gt; . The sequence of octets represented by $octets is decoded from UTF-8 into a sequence of logical characters. Because not all sequences of octets are valid UTF-8, it is quite possible for this function to fail. For CHECK, see &lt;a href=&quot;#Handling-Malformed-Data&quot;&gt;Handling Malformed Data&lt;/a&gt;.</source>
          <target state="translated">동등 &lt;code&gt;$string = decode(&quot;utf8&quot;, $octets [, CHECK])&lt;/code&gt; . $ octets로 표시되는 8 진수 시퀀스는 UTF-8에서 논리 문자 시퀀스로 디코딩됩니다. 모든 8 진수 시퀀스가 ​​유효한 UTF-8이 아니기 때문에이 함수가 실패 할 수 있습니다. CHECK는 &lt;a href=&quot;#Handling-Malformed-Data&quot;&gt;조작 된 데이터 처리를&lt;/a&gt; 참조하십시오. .</target>
        </trans-unit>
        <trans-unit id="98fe51deeaa55823d52414f5281c460f4be56e6e" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;$string = decode(&quot;utf8&quot;, $octets [, CHECK])&lt;/code&gt;. The sequence of octets represented by $octets is decoded from (loose, not strict) utf8 into a sequence of logical characters. Because not all sequences of octets are valid not strict utf8, it is quite possible for this function to fail. For CHECK, see &lt;a href=&quot;#Handling-Malformed-Data&quot;&gt;&quot;Handling Malformed Data&quot;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="032e60eb7c99d19d4d7f40467e50e02c1b3b3e31" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;&lt;a href=&quot;functions/exp&quot;&gt;exp&lt;/a&gt;(x) - 1&lt;/code&gt; , but more precise for small argument values [C99].</source>
          <target state="translated">등가 &lt;code&gt;&lt;a href=&quot;functions/exp&quot;&gt;exp&lt;/a&gt;(x) - 1&lt;/code&gt; 하지만 작은 인수 값 [C99]의보다 정확한.</target>
        </trans-unit>
        <trans-unit id="48506d548803ae745c6c6681b3b6b358f76d6d1f" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;&lt;a href=&quot;functions/log&quot;&gt;log&lt;/a&gt;(1 + x)&lt;/code&gt; , but more stable results for small argument values [C99].</source>
          <target state="translated">등가 &lt;code&gt;&lt;a href=&quot;functions/log&quot;&gt;log&lt;/a&gt;(1 + x)&lt;/code&gt; 작은 인수 값 [C99]의, 그러나 더 안정적인 결과.</target>
        </trans-unit>
        <trans-unit id="22c30bad53a9801aa2549ef28438b22b8be2db3e" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt; FILEHANDLE &lt;a href=&quot;functions/sprintf&quot;&gt;sprintf&lt;/a&gt;(FORMAT, LIST)&lt;/code&gt; , except that &lt;code&gt;$\&lt;/code&gt; (the output record separator) is not appended. The FORMAT and the LIST are actually parsed as a single list. The first argument of the list will be interpreted as the &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; format. This means that &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf(@_)&lt;/a&gt;&lt;/code&gt; will use &lt;code&gt;$_[0]&lt;/code&gt; as the format. See &lt;a href=&quot;#sprintf-FORMAT%2c-LIST&quot;&gt;sprintf&lt;/a&gt; for an explanation of the format argument. If &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; for &lt;code&gt;LC_NUMERIC&lt;/code&gt; Look for this throught pod is in effect and POSIX::setlocale() has been called, the character used for the decimal separator in formatted floating-point numbers is affected by the &lt;code&gt;LC_NUMERIC&lt;/code&gt; locale setting. See &lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt; and &lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;$\&lt;/code&gt; (출력 레코드 구분 기호)가 추가되지 않은 것을 제외하고 &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt; FILEHANDLE &lt;a href=&quot;functions/sprintf&quot;&gt;sprintf&lt;/a&gt;(FORMAT, LIST)&lt;/code&gt; &lt;a href=&quot;functions/sprintf&quot;&gt;sprintf&lt;/a&gt; (FORMAT, LIST) &lt;a href=&quot;functions/print&quot;&gt;인쇄&lt;/a&gt; 와 동일합니다 . FORMAT과 LIST는 실제로 단일 목록으로 구문 분석됩니다. 목록의 첫 번째 인수는 &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; 형식 으로 해석됩니다 . 이것은 &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf(@_)&lt;/a&gt;&lt;/code&gt; 가 &lt;code&gt;$_[0]&lt;/code&gt; 을 형식으로 사용 한다는 것을 의미 합니다. format 인수에 대한 설명은 &lt;a href=&quot;#sprintf-FORMAT%2c-LIST&quot;&gt;sprintf&lt;/a&gt; 를 참조하십시오 . &lt;code&gt;LC_NUMERIC&lt;/code&gt; &lt;code&gt;LC_NUMERIC&lt;/code&gt; 로케일 설정에 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; 을 &lt;a href=&quot;functions/use&quot;&gt;사용하는&lt;/a&gt; 경우 . &lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt; 및 &lt;a href=&quot;posix&quot;&gt;POSIX를&lt;/a&gt; 참조하십시오 . 이 축복하는 포드를 찾아 적용 및 POSIX ::은 setlocale ()가 호출 된에, 형식의 부동 소수점 숫자의 소수 구분에 사용되는 문자는에 의해 영향을 받는다</target>
        </trans-unit>
        <trans-unit id="200de086c8cd5535e67b47001e5f819da8109f8f" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;&lt;a href=&quot;functions/sqrt&quot;&gt;sqrt&lt;/a&gt;(x * x + y * y)&lt;/code&gt; except more stable on very large or very small arguments [C99].</source>
          <target state="translated">상당 &lt;code&gt;&lt;a href=&quot;functions/sqrt&quot;&gt;sqrt&lt;/a&gt;(x * x + y * y)&lt;/code&gt; 매우 크거나 매우 작은 인수에보다 안정적인 제외 [C99].</target>
        </trans-unit>
        <trans-unit id="0f1d23c2683b2580eee5762a2646e2cfdbd51243" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;&lt;a href=&quot;print&quot;&gt;print&lt;/a&gt; FILEHANDLE &lt;a href=&quot;sprintf&quot;&gt;sprintf&lt;/a&gt;(FORMAT, LIST)&lt;/code&gt; , except that &lt;code&gt;$\&lt;/code&gt; (the output record separator) is not appended. The FORMAT and the LIST are actually parsed as a single list. The first argument of the list will be interpreted as the &lt;code&gt;&lt;a href=&quot;printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; format. This means that &lt;code&gt;&lt;a href=&quot;printf&quot;&gt;printf(@_)&lt;/a&gt;&lt;/code&gt; will use &lt;code&gt;$_[0]&lt;/code&gt; as the format. See &lt;a href=&quot;#sprintf-FORMAT%2c-LIST&quot;&gt;sprintf&lt;/a&gt; for an explanation of the format argument. If &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; for &lt;code&gt;LC_NUMERIC&lt;/code&gt; Look for this throught pod is in effect and POSIX::setlocale() has been called, the character used for the decimal separator in formatted floating-point numbers is affected by the &lt;code&gt;LC_NUMERIC&lt;/code&gt; locale setting. See &lt;a href=&quot;../perllocale&quot;&gt;perllocale&lt;/a&gt; and &lt;a href=&quot;../posix&quot;&gt;POSIX&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;$\&lt;/code&gt; (출력 레코드 구분 기호)가 추가되지 않은 것을 제외하고 &lt;code&gt;&lt;a href=&quot;print&quot;&gt;print&lt;/a&gt; FILEHANDLE &lt;a href=&quot;sprintf&quot;&gt;sprintf&lt;/a&gt;(FORMAT, LIST)&lt;/code&gt; &lt;a href=&quot;sprintf&quot;&gt;sprintf&lt;/a&gt; (FORMAT, LIST) &lt;a href=&quot;print&quot;&gt;인쇄&lt;/a&gt; 와 동일합니다 . FORMAT과 LIST는 실제로 단일 목록으로 구문 분석됩니다. 목록의 첫 번째 인수는 &lt;code&gt;&lt;a href=&quot;printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; 형식 으로 해석됩니다 . 이것은 &lt;code&gt;&lt;a href=&quot;printf&quot;&gt;printf(@_)&lt;/a&gt;&lt;/code&gt; 가 &lt;code&gt;$_[0]&lt;/code&gt; 을 형식으로 사용 한다는 것을 의미 합니다. format 인수에 대한 설명은 &lt;a href=&quot;#sprintf-FORMAT%2c-LIST&quot;&gt;sprintf&lt;/a&gt; 를 참조하십시오 . 경우 &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; 로케일 에 대한 &lt;code&gt;LC_NUMERIC&lt;/code&gt; 이 축복하는 포드를 찾아 적용 및 POSIX ::은 setlocale ()가 호출 된에, 형식의 부동 소수점 숫자의 소수 구분에 사용되는 문자는에 의해 영향을 받는다 &lt;code&gt;LC_NUMERIC&lt;/code&gt; 로캘 설정 &lt;a href=&quot;../perllocale&quot;&gt;perllocale&lt;/a&gt; 및 &lt;a href=&quot;../posix&quot;&gt;POSIX를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="756e8875e122c06649638568056dc5b432d11a8e" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;exp(x) - 1&lt;/code&gt;, but more precise for small argument values [C99].</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c725f59de42f50ead6905d172ab4b7ba28d808a" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;log(1 + x)&lt;/code&gt;, but more stable results for small argument values [C99].</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3145a78dd9afcf2f738531a37fc2117722087949" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;print FILEHANDLE sprintf(FORMAT, LIST)&lt;/code&gt;, except that &lt;a href=&quot;perlvar#%24%5C&quot;&gt;&lt;code&gt;$\&lt;/code&gt;&lt;/a&gt; (the output record separator) is not appended. The FORMAT and the LIST are actually parsed as a single list. The first argument of the list will be interpreted as the &lt;a href=&quot;#printf-FILEHANDLE-FORMAT%2C-LIST&quot;&gt;&lt;code&gt;printf&lt;/code&gt;&lt;/a&gt; format. This means that &lt;code&gt;printf(@_)&lt;/code&gt; will use &lt;code&gt;$_[0]&lt;/code&gt; as the format. See &lt;a href=&quot;#sprintf-FORMAT%2C-LIST&quot;&gt;sprintf&lt;/a&gt; for an explanation of the format argument. If &lt;code&gt;use locale&lt;/code&gt; (including &lt;code&gt;use locale ':not_characters'&lt;/code&gt;) is in effect and &lt;a href=&quot;posix#setlocale&quot;&gt;&lt;code&gt;POSIX::setlocale&lt;/code&gt;&lt;/a&gt; has been called, the character used for the decimal separator in formatted floating-point numbers is affected by the &lt;code&gt;LC_NUMERIC&lt;/code&gt; locale setting. See &lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt; and &lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8b67359eada935d408cfee6f1b32b93eb73c3ef" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;sqrt(x * x + y * y)&lt;/code&gt; except more stable on very large or very small arguments [C99].</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a8b647b2f27ee1659c31db9d984b63f0b9e63a18" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;sv_setsv(sv, &amp;amp;PL_sv_undef)&lt;/code&gt;, but more efficient. Doesn't handle set magic.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d4e0dc744110e721ecf88197993cbcc2b45d001" translate="yes" xml:space="preserve">
          <source>Equivalent to Perl code &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt; $gv&lt;/code&gt; .</source>
          <target state="translated">Perl 코드 &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt; $gv&lt;/code&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="3ac49f4bdd12fc964afb5f8290211f9aa65a79c7" translate="yes" xml:space="preserve">
          <source>Equivalent to Perl code &lt;code&gt;local $gv&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="876fc7d247587a71d98917cb3c3453fd65fea359" translate="yes" xml:space="preserve">
          <source>Equivalent to running mktemp() with $dir/$prefixXXXXXXXX (using unix file convention as an example)</source>
          <target state="translated">$ dir / $ prefixXXXXXXXX로 mktemp ()를 실행하는 것과 같습니다 (예를 들어 유닉스 파일 규칙 사용).</target>
        </trans-unit>
        <trans-unit id="4dba35bcd4ac839e52783da10b5058566f3e3b91" translate="yes" xml:space="preserve">
          <source>Equivalent to specifying a DIR of &quot;File::Spec-&amp;gt;tmpdir&quot;, writing the file into the same temporary directory as would be used if no template was specified at all.</source>
          <target state="translated">&quot;File :: Spec-&amp;gt; tmpdir&quot;의 DIR을 지정하는 것과 동일하며, 템플리트가 전혀 지정되지 않은 경우 사용되는 것과 동일한 임시 디렉토리에 파일을 기록합니다.</target>
        </trans-unit>
        <trans-unit id="bb3d71a18fde90428e21cf7d4198ea242cfa57c5" translate="yes" xml:space="preserve">
          <source>Equivalent to the &lt;a href=&quot;#-C-%5Bnumber%2Flist%5D&quot;&gt;-C&lt;/a&gt; command-line switch. Note that this is not a boolean variable. Setting this to &lt;code&gt;&quot;1&quot;&lt;/code&gt; is not the right way to &quot;enable Unicode&quot; (whatever that would mean). You can use &lt;code&gt;&quot;0&quot;&lt;/code&gt; to &quot;disable Unicode&quot;, though (or alternatively unset PERL_UNICODE in your shell before starting Perl). See the description of the &lt;a href=&quot;#-C-%5Bnumber%2Flist%5D&quot;&gt;-C&lt;/a&gt; switch for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a667e4f94596d8444896d0c578ec8dad154ae9ae" translate="yes" xml:space="preserve">
          <source>Equivalent to the &lt;b&gt;-C&lt;/b&gt; command-line switch. Note that this is not a boolean variable. Setting this to &lt;code&gt;&quot;1&quot;&lt;/code&gt; is not the right way to &quot;enable Unicode&quot; (whatever that would mean). You can use &lt;code&gt;&quot;0&quot;&lt;/code&gt; to &quot;disable Unicode&quot;, though (or alternatively unset PERL_UNICODE in your shell before starting Perl). See the description of the &lt;b&gt;-C&lt;/b&gt; switch for more information.</source>
          <target state="translated">&lt;b&gt;-C&lt;/b&gt; 명령 행 스위치 와 동일합니다 . 이것은 부울 변수가 아닙니다. 이것을 &lt;code&gt;&quot;1&quot;&lt;/code&gt; 로 설정하는 것이 &quot; 유니 코드&quot;를 가능하게하는 올바른 방법이 아닙니다 (무엇이든). &lt;code&gt;&quot;0&quot;&lt;/code&gt; 을 사용하여 &quot;유니 코드&quot;를 비활성화 할 수 있습니다 (또는 Perl을 시작하기 전에 쉘에서 PERL_UNICODE를 설정 해제 할 수도 있음). 자세한 정보 는 &lt;b&gt;-C&lt;/b&gt; 스위치에 대한 설명 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="d371f28bfea1e852f448381bb4f0bdfccaa7149e" translate="yes" xml:space="preserve">
          <source>Equivalent to:</source>
          <target state="translated">다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7cc25c4fa96172ec73030c6c0f3dc9c51687c491" translate="yes" xml:space="preserve">
          <source>Equivalents of</source>
          <target state="translated">등가물</target>
        </trans-unit>
        <trans-unit id="7ebcf33d0a14ddb91ad477ae52a7af6de25e76c9" translate="yes" xml:space="preserve">
          <source>Er, that's it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0256add701298dc7a17e42cc9eb936d630438581" translate="yes" xml:space="preserve">
          <source>Erases one character. Defined by</source>
          <target state="translated">한 문자를 지 웁니다. 에 의해 정의</target>
        </trans-unit>
        <trans-unit id="7c24401b7c6f89af67334e697241400ad5298e5f" translate="yes" xml:space="preserve">
          <source>Erases the current input. Defined by</source>
          <target state="translated">현재 입력을 지 웁니다. 에 의해 정의</target>
        </trans-unit>
        <trans-unit id="2bfde103fe0a2fc7c857d2e77fed8dacf0bc3d48" translate="yes" xml:space="preserve">
          <source>Eric L. Brine,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5b196c5d2b8bc0f57dd78e558fed28f0a83be47" translate="yes" xml:space="preserve">
          <source>Eric Wilhelm &amp;lt;ewilhelm@cpan.org&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3053d2e8a81cd1d9716eddc9ced731b4c51383d" translate="yes" xml:space="preserve">
          <source>Eric Wilhelm @ &amp;lt;ewilhelm at cpan dot org&amp;gt;</source>
          <target state="translated">에릭 빌헬름 @ &amp;lt;팬 팟 조직에서의 ewilhelm&amp;gt;</target>
        </trans-unit>
        <trans-unit id="d8bf3fea74cb51ac9ebccafa9b5bfc9e28b1c902" translate="yes" xml:space="preserve">
          <source>Errno</source>
          <target state="translated">Errno</target>
        </trans-unit>
        <trans-unit id="76cf9c662cbb85bc782a4c519361391afd6f8281" translate="yes" xml:space="preserve">
          <source>Errno - System errno constants</source>
          <target state="translated">Errno-시스템 오류 상수</target>
        </trans-unit>
        <trans-unit id="27356fe30834096ffaeafbce7b977e0f80915dea" translate="yes" xml:space="preserve">
          <source>Erroneous numbering of =item numbers; they need to ascend consecutively.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f2f6a15cf8da2b27e5a4af47b58e7ad71c0b3d9" translate="yes" xml:space="preserve">
          <source>Error</source>
          <target state="translated">Error</target>
        </trans-unit>
        <trans-unit id="6cc16f28f695995f841e32ad9be43613256395fe" translate="yes" xml:space="preserve">
          <source>Error Checking</source>
          <target state="translated">오류 확인</target>
        </trans-unit>
        <trans-unit id="ecbd14ea4e6e17d8a2dc17467fb021874d4a82c9" translate="yes" xml:space="preserve">
          <source>Error Variables</source>
          <target state="translated">오류 변수</target>
        </trans-unit>
        <trans-unit id="cfb1de7f5665b658bcddfda7619c881aef88520a" translate="yes" xml:space="preserve">
          <source>Error checking is, as usual, left as an exercise for the reader.</source>
          <target state="translated">오류 점검은 평소와 같이 독자의 연습으로 남습니다.</target>
        </trans-unit>
        <trans-unit id="da4e40dd69c1ef29292868ee52af685e14566b19" translate="yes" xml:space="preserve">
          <source>Error checking, as always, has been left as an exercise for the reader.</source>
          <target state="translated">항상 그렇듯이 오류 점검은 독자의 연습으로 남았습니다.</target>
        </trans-unit>
        <trans-unit id="deb19663fe1130ad1a6752c882ecbce1fa91037d" translate="yes" xml:space="preserve">
          <source>Error converting file specification %s</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e1fae3d7127b124ae1e94579e5dd51376530e7b" translate="yes" xml:space="preserve">
          <source>Error handling and messages</source>
          <target state="translated">오류 처리 및 메시지</target>
        </trans-unit>
        <trans-unit id="34660817ebc668307d6b9b58b072f03bc4a8634d" translate="yes" xml:space="preserve">
          <source>Error handling is still a work in progress. If the program encounters a problem reading a zip file it is likely to terminate with an unhelpful error message.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8bb7b0a0be7d85a55ee74f50c125415c68cb8808" translate="yes" xml:space="preserve">
          <source>Error information specific to the current operating system. At the moment, this differs from &lt;code&gt;$!&lt;/code&gt; under only VMS, OS/2, and Win32 (and for MacPerl). On all other platforms, &lt;code&gt;$^E&lt;/code&gt; is always just the same as &lt;code&gt;$!&lt;/code&gt; .</source>
          <target state="translated">현재 운영 체제에 특정한 오류 정보. 현재 이것은 &lt;code&gt;$!&lt;/code&gt; 와 다릅니다 ! VMS, OS / 2 및 Win32 (및 MacPerl)에서만. 다른 모든 플랫폼에서 &lt;code&gt;$^E&lt;/code&gt; 는 항상 &lt;code&gt;$!&lt;/code&gt; 와 같습니다 ! .</target>
        </trans-unit>
        <trans-unit id="f630bce8e4480d279f4c43b7f93e39940eec25e0" translate="yes" xml:space="preserve">
          <source>Error information specific to the current operating system. At the moment, this differs from &lt;code&gt;&lt;a href=&quot;#%24%21&quot;&gt;&quot;$!&quot;&lt;/a&gt;&lt;/code&gt; under only VMS, OS/2, and Win32 (and for MacPerl). On all other platforms, &lt;code&gt;$^E&lt;/code&gt; is always just the same as &lt;code&gt;$!&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="915cf7d6fb5fed9ebc1249138f0ba313553fae0a" translate="yes" xml:space="preserve">
          <source>Error message &quot;No error definitions found&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36186555ca5a85354d834f18239bd5446de015bb" translate="yes" xml:space="preserve">
          <source>Error message text from the last failed DynaLoader function. Note that, similar to errno in unix, a successful function call does not reset this message.</source>
          <target state="translated">마지막으로 실패한 DynaLoader 기능의 오류 메시지 텍스트. 유닉스에서의 errno와 마찬가지로 성공적인 함수 호출은이 메시지를 재설정하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="50134ffbfcda43f0c3168aa2876061d57b69c6ae" translate="yes" xml:space="preserve">
          <source>Error results (warning and fatal) contain:</source>
          <target state="translated">오류 결과 (경고 및 치명적)에는 다음이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="805e86a8cbf628e38e4c45612c005a504009e79a" translate="yes" xml:space="preserve">
          <source>Errors</source>
          <target state="translated">Errors</target>
        </trans-unit>
        <trans-unit id="e722317f0272c736783202d0439c1a84302bd3c9" translate="yes" xml:space="preserve">
          <source>Errors in rendering (non-existent function-name, non-existent coderef) are written to the STDOUT, or wherever you've set it via walk_output().</source>
          <target state="translated">존재하지 않는 function-name, 존재하지 않는 coderef 렌더링 오류는 STDOUT에 작성되거나 walk_output ()을 통해 설정 한 위치에 기록됩니다.</target>
        </trans-unit>
        <trans-unit id="da8460251cea0573bc6a64a9a743976f334f7752" translate="yes" xml:space="preserve">
          <source>Errors set by Winsock functions are now put directly into &lt;code&gt;$^E&lt;/code&gt;, and the relevant &lt;code&gt;WSAE*&lt;/code&gt; error codes are now exported from the &lt;a href=&quot;errno&quot;&gt;Errno&lt;/a&gt; and &lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt; modules for testing this against.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0934c88916cf6f7537fb99e4833669f3818f9855" translate="yes" xml:space="preserve">
          <source>Errors using the various *style* calls, and bad args to walk_output(), result in die(). Use an eval if you wish to catch these errors and continue processing.</source>
          <target state="translated">다양한 * style * 호출을 사용하는 오류와 walk_output ()에 대한 잘못된 인수로 인해 die ()가 발생합니다. 이러한 오류를 포착하고 처리를 계속하려면 eval을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="2a3a3e693d223668963c1734745a9c3d61b5507c" translate="yes" xml:space="preserve">
          <source>Eryq (</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7b714d8f396c877eacf7d3ad661cfe313a3efe9" translate="yes" xml:space="preserve">
          <source>Escape backslashes (&lt;code&gt;\&lt;/code&gt;) in prototype strings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa094bf265d4ea86b5f894d7a380cedfb2baed9e" translate="yes" xml:space="preserve">
          <source>Escape sequences</source>
          <target state="translated">이스케이프 시퀀스</target>
        </trans-unit>
        <trans-unit id="a95db9b35f0577a2b6c8dd20cb8afa6149f7b7b9" translate="yes" xml:space="preserve">
          <source>Escapes a given code source name (typically a file name but can also be a command that was read from) so that double-quotes and backslashes are escaped.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="afa6da9272c9b7871ca718b60455b77d2d266044" translate="yes" xml:space="preserve">
          <source>Escapes all &lt;code&gt;$&lt;/code&gt; so they are not interpreted as make variables.</source>
          <target state="translated">모든 &lt;code&gt;$&lt;/code&gt; 를 이스케이프 하여 make 변수로 해석되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d630054693cd8886f832682006b6bb07e97c811d" translate="yes" xml:space="preserve">
          <source>Escapes at most the first &quot;count&quot; chars of pv and puts the results into dsv such that the size of the escaped string will not exceed &quot;max&quot; chars and will not contain any incomplete escape sequences. The number of bytes escaped will be returned in the STRLEN *escaped parameter if it is not null. When the dsv parameter is null no escaping actually occurs, but the number of bytes that would be escaped were it not null will be calculated.</source>
          <target state="translated">pv의 첫 번째 &quot;카운트&quot;문자를 이스케이프하고 이스케이프 된 문자열의 크기가 &quot;max&quot;문자를 초과하지 않고 불완전한 이스케이프 시퀀스를 포함하지 않도록 결과를 dsv에 넣습니다. 이스케이프 된 바이트 수는 널이 아닌 경우 STRLEN * escaped 매개 변수에 리턴됩니다. dsv 매개 변수가 널인 경우 실제로 이스케이프가 발생하지 않지만 이스케이프 될 바이트 수는 널이 아닌 경우 계산됩니다.</target>
        </trans-unit>
        <trans-unit id="e9331784f47985d4023ae09824ecf12ebdf39d50" translate="yes" xml:space="preserve">
          <source>Escapes at most the first &lt;code&gt;count&lt;/code&gt; chars of &lt;code&gt;pv&lt;/code&gt; and puts the results into &lt;code&gt;dsv&lt;/code&gt; such that the size of the escaped string will not exceed &lt;code&gt;max&lt;/code&gt; chars and will not contain any incomplete escape sequences. The number of bytes escaped will be returned in the &lt;code&gt;STRLEN *escaped&lt;/code&gt; parameter if it is not null. When the &lt;code&gt;dsv&lt;/code&gt; parameter is null no escaping actually occurs, but the number of bytes that would be escaped were it not null will be calculated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b73daf05e61c2f4ceabfe0f8dc9e8bd0fe087922" translate="yes" xml:space="preserve">
          <source>Escapes stray &lt;code&gt;$&lt;/code&gt; so they are not interpreted as make variables.</source>
          <target state="translated">이스케이프는 &lt;code&gt;$&lt;/code&gt; 를 길러서 변수 만들기로 해석되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="92b417d4a5ce0ac686aeee5640af004624297a4e" translate="yes" xml:space="preserve">
          <source>Especially &lt;a href=&quot;bignum&quot;&gt;bignum&lt;/a&gt;.</source>
          <target state="translated">특히 &lt;a href=&quot;bignum&quot;&gt;bignum&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="51e6f8fb1216de07279b7184fe32486c4afcbbd5" translate="yes" xml:space="preserve">
          <source>Especially &lt;a href=&quot;bigrat&quot;&gt;bigrat&lt;/a&gt; as in &lt;code&gt;perl -Mbigrat -le 'print 1/3+1/4'&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;perl -Mbigrat -le 'print 1/3+1/4'&lt;/code&gt; 에서와 같이 특히 &lt;a href=&quot;bigrat&quot;&gt;bigrat&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="bcd99d9147aed607626e5d2c3fbf27fa8eaba872" translate="yes" xml:space="preserve">
          <source>Especially &lt;a href=&quot;bigrat&quot;&gt;bigrat&lt;/a&gt; as in &lt;code&gt;perl -Mbigrat -le 'print 1/3+1/4'&lt;/code&gt; and &lt;a href=&quot;bignum&quot;&gt;bignum&lt;/a&gt; as in &lt;code&gt;perl -Mbignum -le 'print sqrt(2)'&lt;/code&gt; .</source>
          <target state="translated">특히 &lt;a href=&quot;bigrat&quot;&gt;bigrat&lt;/a&gt; 같이 &lt;code&gt;perl -Mbigrat -le 'print 1/3+1/4'&lt;/code&gt; 과 &lt;a href=&quot;bignum&quot;&gt;의 bignum를&lt;/a&gt; 같이 &lt;code&gt;perl -Mbignum -le 'print sqrt(2)'&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5485ef59e2abd6d9fec5641c427b8c1a89ee861e" translate="yes" xml:space="preserve">
          <source>Essentially this is the same as the &lt;code&gt;__LINE__&lt;/code&gt; macro, but the &lt;code&gt;line_num(+3)&lt;/code&gt; idiom is arguably nicer.</source>
          <target state="translated">본질적으로 이것은 &lt;code&gt;__LINE__&lt;/code&gt; 매크로 와 동일 하지만 &lt;code&gt;line_num(+3)&lt;/code&gt; 관용구가 더 좋을 것입니다.</target>
        </trans-unit>
        <trans-unit id="0c6dff48b0f039b109420e87e1e42abbab8710f8" translate="yes" xml:space="preserve">
          <source>Establish an ISA relationship with base classes at compile time</source>
          <target state="translated">컴파일 타임에 기본 클래스와 ISA 관계 설정</target>
        </trans-unit>
        <trans-unit id="576347ec826f38428d8c8a6f8ec4acb2bceab911" translate="yes" xml:space="preserve">
          <source>Europe</source>
          <target state="translated">Europe</target>
        </trans-unit>
        <trans-unit id="aa9b05a82a74755dccc358002821ca69d31c5e54" translate="yes" xml:space="preserve">
          <source>European Computer Manufacturers Association &lt;a href=&quot;http://www.ecma.ch&quot;&gt;http://www.ecma.ch&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0309a3b568036fa350070f80c5e87dff1124fc90" translate="yes" xml:space="preserve">
          <source>Eval the codeblock, return success or failure, and the error message. This code protects $@ and $!, they will be restored by the end of the run. This code also temporarily blocks $SIG{DIE} handlers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57720a74163f29f2034ea0831d9223b2072fcf53" translate="yes" xml:space="preserve">
          <source>Eval-group in insecure regular expression</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3de6a23b74739863fdcb66dba07f712f221ab630" translate="yes" xml:space="preserve">
          <source>Eval-group not allowed at runtime, use re 'eval' in regex m/%s/</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c9fc4317afc6d18f75173c8034624de946965f7e" translate="yes" xml:space="preserve">
          <source>Eval-group not allowed, use re 'eval' in regex m/%s/</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15622021802352824cd00f0a03614ec0fdf9d50b" translate="yes" xml:space="preserve">
          <source>Evaluates EXPR and exits immediately with that value. Example:</source>
          <target state="translated">EXPR을 평가하고 해당 값으로 즉시 종료합니다. 예:</target>
        </trans-unit>
        <trans-unit id="c44b93a0add3946a941d2db7675bb524bcd7719a" translate="yes" xml:space="preserve">
          <source>Evaluates its expression in list context and dumps out the result in a pretty-printed fashion. Nested data structures are printed out recursively, unlike the real &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; function in Perl. When dumping hashes, you'll probably prefer 'x \%h' rather than 'x %h'. See &lt;a href=&quot;dumpvalue&quot;&gt;Dumpvalue&lt;/a&gt; if you'd like to do this yourself.</source>
          <target state="translated">목록 컨텍스트에서 표현식을 평가하고 결과를 예쁘게 인쇄합니다. 중첩 된 데이터 구조는 Perl 의 실제 &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; 기능 과 달리 재귀 적으로 인쇄됩니다 . 해시를 덤프 할 때는 아마도 'x % h'보다는 'x \ % h'를 선호 할 것입니다. 이 작업을 직접 수행하려면 &lt;a href=&quot;dumpvalue&quot;&gt;Dumpvalue를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a5bd312d1ed9e2d998f61c992d1949d05f3189c8" translate="yes" xml:space="preserve">
          <source>Evaluates its expression in list context and dumps out the result in a pretty-printed fashion. Nested data structures are printed out recursively, unlike the real &lt;code&gt;print&lt;/code&gt; function in Perl. When dumping hashes, you'll probably prefer 'x \%h' rather than 'x %h'. See &lt;a href=&quot;dumpvalue&quot;&gt;Dumpvalue&lt;/a&gt; if you'd like to do this yourself.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ac54d42c3ebf7c1eb1985e5c37def23568be458" translate="yes" xml:space="preserve">
          <source>Evaluates the BLOCK or EXPR for each element of LIST (locally setting &lt;a href=&quot;perlvar#%24_&quot;&gt;&lt;code&gt;$_&lt;/code&gt;&lt;/a&gt; to each element) and composes a list of the results of each such evaluation. Each element of LIST may produce zero, one, or more elements in the generated list, so the number of elements in the generated list may differ from that in LIST. In scalar context, returns the total number of elements so generated. In list context, returns the generated list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c6b463c629f711f381a6e44374ee5717c9b5851" translate="yes" xml:space="preserve">
          <source>Evaluates the BLOCK or EXPR for each element of LIST (locally setting &lt;a href=&quot;perlvar#%24_&quot;&gt;&lt;code&gt;$_&lt;/code&gt;&lt;/a&gt; to each element) and returns the list value consisting of those elements for which the expression evaluated to true. In scalar context, returns the number of times the expression was true.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9eee27e1be9e7d28580a29bfa24323cac2b1efa9" translate="yes" xml:space="preserve">
          <source>Evaluates the BLOCK or EXPR for each element of LIST (locally setting &lt;code&gt;$_&lt;/code&gt; to each element) and returns the list value composed of the results of each such evaluation. In scalar context, returns the total number of elements so generated. Evaluates BLOCK or EXPR in list context, so each element of LIST may produce zero, one, or more elements in the returned value.</source>
          <target state="translated">LIST의 각 요소 (로컬에 &lt;code&gt;$_&lt;/code&gt; 를 각 요소 로 설정)에 대한 BLOCK 또는 EXPR을 평가하고 이러한 각 평가 결과로 구성된 목록 값을 리턴합니다. 스칼라 문맥에서 이렇게 생성 된 총 요소 수를 반환합니다. 목록 컨텍스트에서 BLOCK 또는 EXPR을 평가하므로 LIST의 각 요소는 리턴 된 값에서 0 개 또는 하나 이상의 요소를 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e159565a978e2dbd25deef6d431807eb47abbd14" translate="yes" xml:space="preserve">
          <source>Evaluates the BLOCK or EXPR for each element of LIST (locally setting &lt;code&gt;$_&lt;/code&gt; to each element) and returns the list value consisting of those elements for which the expression evaluated to true. In scalar context, returns the number of times the expression was true.</source>
          <target state="translated">LIST의 각 요소 (로컬에 &lt;code&gt;$_&lt;/code&gt; 를 각 요소 로 설정)에 대해 BLOCK 또는 EXPR을 평가하고 표현식이 true로 평가 된 요소로 구성된 목록 값을 리턴합니다. 스칼라 컨텍스트에서 표현식이 true 인 횟수를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="cf5a5afbdf639c60540cb29b1afb8482a4c27513" translate="yes" xml:space="preserve">
          <source>Evaluates the hash in scalar context and returns the result.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="adb27bcd152d36bb6aa40c050f7aa6bc064a148c" translate="yes" xml:space="preserve">
          <source>Evaluates the hash in scalar context and returns the result. Handles magic when the hash is tied.</source>
          <target state="translated">스칼라 컨텍스트에서 해시를 평가하고 결과를 리턴합니다. 해시가 묶일 때 마법을 처리합니다.</target>
        </trans-unit>
        <trans-unit id="4e9ac4c1ee356b0a19d18eecf82ac765b9101304" translate="yes" xml:space="preserve">
          <source>Evaluates the passed SV. Result handling is done the same as for &lt;code&gt;call_sv()&lt;/code&gt; etc.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="808c33dddbb9e00ae9c3a4845059fe43368d7b0a" translate="yes" xml:space="preserve">
          <source>Evaluates to 0xFFFD, the code point of the Unicode REPLACEMENT CHARACTER</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48c62a6c57ccf104ad2d41815aed270108351d20" translate="yes" xml:space="preserve">
          <source>Evaluates to 1 if the byte &lt;code&gt;c&lt;/code&gt; represents the same character when encoded in UTF-8 as when not; otherwise evaluates to 0. UTF-8 invariant characters can be copied as-is when converting to/from UTF-8, saving time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="100562c78d7cbca55f4722b4014576ae868df4e3" translate="yes" xml:space="preserve">
          <source>Evaluates to 1 if the representation of code point &lt;code&gt;cp&lt;/code&gt; is the same whether or not it is encoded in UTF-8; otherwise evaluates to 0. UTF-8 invariant characters can be copied as-is when converting to/from UTF-8, saving time. &lt;code&gt;cp&lt;/code&gt; is Unicode if above 255; otherwise is platform-native.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8bb14ed1a5da1a7d197c5bfa2c110468f119a341" translate="yes" xml:space="preserve">
          <source>Evaluates to TRUE if the plain locale pragma without a parameter (&lt;code&gt;use locale&lt;/code&gt;) is in effect.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47f226763df7ae244c2d5731a8cec87c6ad68b9c" translate="yes" xml:space="preserve">
          <source>Evaluates to TRUE if, when compiling a perl program (including an &lt;code&gt;eval&lt;/code&gt;) if the plain locale pragma without a parameter (&lt;code&gt;use locale&lt;/code&gt;) is in effect.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f195a4b1422deea528999a2aea4d2e3abe0a2cb0" translate="yes" xml:space="preserve">
          <source>Evaluates to TRUE if, when executing a perl program (including an &lt;code&gt;eval&lt;/code&gt;) if the plain locale pragma without a parameter (&lt;code&gt;use locale&lt;/code&gt;) is in effect.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b7efdaaae8c2d5acf037415de9e55f35d46853a" translate="yes" xml:space="preserve">
          <source>Evaluates to a list of the words extracted out of</source>
          <target state="translated">추출 된 단어 목록으로 평가</target>
        </trans-unit>
        <trans-unit id="d65f4596e5b21853db6815029e47b4d12178eb0e" translate="yes" xml:space="preserve">
          <source>Evaluates to non-zero if the first few bytes of the string starting at &lt;code&gt;s&lt;/code&gt; and looking no further than &lt;code&gt;e - 1&lt;/code&gt; are well-formed UTF-8 that represents one of the Unicode non-character code points; otherwise it evaluates to 0. If non-zero, the value gives how many bytes starting at &lt;code&gt;s&lt;/code&gt; comprise the code point's representation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2ba361513dd4325cee403415d7567ac05c0deb6" translate="yes" xml:space="preserve">
          <source>Evaluates to non-zero if the first few bytes of the string starting at &lt;code&gt;s&lt;/code&gt; and looking no further than &lt;code&gt;e - 1&lt;/code&gt; are well-formed UTF-8 that represents one of the Unicode surrogate code points; otherwise it evaluates to 0. If non-zero, the value gives how many bytes starting at &lt;code&gt;s&lt;/code&gt; comprise the code point's representation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0b4e5bdfedcccceafa909bcd677f735ead45367" translate="yes" xml:space="preserve">
          <source>Evaluates to non-zero if the first few bytes of the string starting at &lt;code&gt;s&lt;/code&gt; and looking no further than &lt;code&gt;e - 1&lt;/code&gt; are well-formed UTF-8 that represents some Unicode code point completely acceptable for open interchange between all applications; otherwise it evaluates to 0. If non-zero, the value gives how many bytes starting at &lt;code&gt;s&lt;/code&gt; comprise the code point's representation. Any bytes remaining before &lt;code&gt;e&lt;/code&gt;, but beyond the ones needed to form the first code point in &lt;code&gt;s&lt;/code&gt;, are not examined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="394362d7a28197545d54a3464886ae1b442e8f27" translate="yes" xml:space="preserve">
          <source>Evaluates to non-zero if the first few bytes of the string starting at &lt;code&gt;s&lt;/code&gt; and looking no further than &lt;code&gt;e - 1&lt;/code&gt; are well-formed UTF-8 that represents some Unicode non-surrogate code point; otherwise it evaluates to 0. If non-zero, the value gives how many bytes starting at &lt;code&gt;s&lt;/code&gt; comprise the code point's representation. Any bytes remaining before &lt;code&gt;e&lt;/code&gt;, but beyond the ones needed to form the first code point in &lt;code&gt;s&lt;/code&gt;, are not examined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c5579ca82ad3ea408feb922437fb3356d093b24" translate="yes" xml:space="preserve">
          <source>Evaluates to non-zero if the first few bytes of the string starting at &lt;code&gt;s&lt;/code&gt; and looking no further than &lt;code&gt;e - 1&lt;/code&gt; are well-formed UTF-8, as extended by Perl, that represents some code point, subject to the restrictions given by &lt;code&gt;flags&lt;/code&gt;; otherwise it evaluates to 0. If non-zero, the value gives how many bytes starting at &lt;code&gt;s&lt;/code&gt; comprise the code point's representation. Any bytes remaining before &lt;code&gt;e&lt;/code&gt;, but beyond the ones needed to form the first code point in &lt;code&gt;s&lt;/code&gt;, are not examined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b70279dc7ca9469f018e588c174a215d906087c5" translate="yes" xml:space="preserve">
          <source>Evaluates to non-zero if the first few bytes of the string starting at &lt;code&gt;s&lt;/code&gt; and looking no further than &lt;code&gt;e - 1&lt;/code&gt; are well-formed UTF-8, as extended by Perl, that represents some code point; otherwise it evaluates to 0. If non-zero, the value gives how many bytes starting at &lt;code&gt;s&lt;/code&gt; comprise the code point's representation. Any bytes remaining before &lt;code&gt;e&lt;/code&gt;, but beyond the ones needed to form the first code point in &lt;code&gt;s&lt;/code&gt;, are not examined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11f4958a116f001f9e79787b5473e92c45467956" translate="yes" xml:space="preserve">
          <source>Evaluating a Perl statement from your C program</source>
          <target state="translated">C 프로그램에서 Perl 문 평가</target>
        </trans-unit>
        <trans-unit id="fdfaa902629988731ecf820e3310a76ecb105be5" translate="yes" xml:space="preserve">
          <source>Evaluating perl code (e.g. via &quot;eval&quot; or &quot;do 'file'&quot;) causes the code to be compiled into an internal format and then, provided there was no error in the compilation, executed. The internal format is based on many distinct</source>
          <target state="translated">perl 코드를 평가하면 (예 : &quot;eval&quot;또는 &quot;do 'file'&quot;을 통해) 코드가 내부 형식으로 컴파일 된 다음 컴파일에 오류가없는 경우 실행됩니다. 내부 형식은 여러 가지 고유 한 방식을 기반으로합니다.</target>
        </trans-unit>
        <trans-unit id="e1f930d87a7c101ffac9391f41733ff5b3321f0a" translate="yes" xml:space="preserve">
          <source>Even &lt;code&gt;$x += 5&lt;/code&gt; or &lt;code&gt;$x++&lt;/code&gt; are not guaranteed to be atomic.</source>
          <target state="translated">&lt;code&gt;$x += 5&lt;/code&gt; 또는 &lt;code&gt;$x++&lt;/code&gt; 조차 원 자성이 될 수는 없습니다.</target>
        </trans-unit>
        <trans-unit id="459a068431296abdc9a0ee020cbb72e87da92588" translate="yes" xml:space="preserve">
          <source>Even after they stabilize, some tests may fail.</source>
          <target state="translated">이들이 안정화 된 후에도 일부 테스트가 실패 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1dd817d2a76ad639afa2f373c6b0e32abc7df4b3" translate="yes" xml:space="preserve">
          <source>Even if a certain letter is tailored, its equivalent would not always tailored as well as it. For example, even though W is tailored, fullwidth W (&lt;code&gt;U+FF37&lt;/code&gt;), W with acute (&lt;code&gt;U+1E82&lt;/code&gt;), etc. are not tailored. The result may depend on whether source strings are normalized or not, and whether decomposed or composed. Thus &lt;code&gt;(normalization =&amp;gt; undef)&lt;/code&gt; is less preferred.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="014c0223d524d2f9046bd74912b924b926ef1dba" translate="yes" xml:space="preserve">
          <source>Even if a module is thread-safe, it doesn't mean that the module is optimized to work well with threads. A module could possibly be rewritten to utilize the new features in threaded Perl to increase performance in a threaded environment.</source>
          <target state="translated">모듈이 스레드로부터 안전하다고해서 모듈이 스레드와 잘 작동하도록 최적화 된 것은 아닙니다. 스레드 환경에서 성능을 향상시키기 위해 스레드 Perl의 새로운 기능을 활용하도록 모듈을 다시 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ea9410fd8b85c13558ab2ec195f440b39ef94e1e" translate="yes" xml:space="preserve">
          <source>Even if a prototype is available at compile time, the body of the subroutine is not (it hasn't been &lt;code&gt;AUTOLOAD&lt;/code&gt; ed yet). perl needs to examine both the &lt;code&gt;()&lt;/code&gt; prototype and the body of a subroutine at compile time to detect that it can safely replace calls to that subroutine with the constant value.</source>
          <target state="translated">컴파일 타임에 프로토 타입을 사용할 수 있더라도 서브 루틴의 본문은 아직 없습니다 ( 아직 &lt;code&gt;AUTOLOAD&lt;/code&gt; 되지 않았습니다). perl 은 컴파일 타임에 &lt;code&gt;()&lt;/code&gt; 프로토 타입과 서브 루틴 본문을 모두 검사 하여 서브 루틴에 대한 호출을 상수 값으로 안전하게 대체 할 수 있는지 감지해야합니다.</target>
        </trans-unit>
        <trans-unit id="732edb0c232306cf9f713f481702d02637baa9d1" translate="yes" xml:space="preserve">
          <source>Even if a prototype is available at compile time, the body of the subroutine is not (it hasn't been &lt;code&gt;AUTOLOAD&lt;/code&gt;ed yet). perl needs to examine both the &lt;code&gt;()&lt;/code&gt; prototype and the body of a subroutine at compile time to detect that it can safely replace calls to that subroutine with the constant value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e9d9a1a7409534a2957addc0cb2ac7a35e101e4" translate="yes" xml:space="preserve">
          <source>Even if no</source>
          <target state="translated">아니더라도</target>
        </trans-unit>
        <trans-unit id="9a52563c6b228851d7bd722e9df68900d397ecd2" translate="yes" xml:space="preserve">
          <source>Even if there are no groupings in a regexp, it is still possible to find out what exactly matched in a string. If you use them, Perl will set &lt;code&gt;$`&lt;/code&gt; to the part of the string before the match, will set &lt;code&gt;$&amp;amp;&lt;/code&gt; to the part of the string that matched, and will set &lt;code&gt;$'&lt;/code&gt; to the part of the string after the match. An example:</source>
          <target state="translated">정규 표현식에 그룹화가 없더라도 문자열에서 정확히 일치하는 항목을 찾을 수 있습니다. 그것들을 사용하면, Perl은 일치하기 전에 문자열의 일부로 &lt;code&gt;$`&lt;/code&gt; 를 설정 하고 일치 하는 문자열의 일부로 &lt;code&gt;$&amp;amp;&lt;/code&gt; 를 설정 하고 일치 후에 문자열의 일부로 &lt;code&gt;$'&lt;/code&gt; 를 설정 합니다. 예를 들면 :</target>
        </trans-unit>
        <trans-unit id="d0239289e914ec51bf43e7158f9d72ad004bea40" translate="yes" xml:space="preserve">
          <source>Even if you aren't in doubt, consider the mental welfare of the person who has to maintain the code after you, and who will probably put parentheses in the wrong place.</source>
          <target state="translated">확실하지 않은 경우에도, 코드를 관리해야하는 사람과 괄호를 잘못된 곳에 넣는 사람의 정신적 복지를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="2698b39349f79453a318cb744bc9cc6aed1c6f70" translate="yes" xml:space="preserve">
          <source>Even if you don't currently make use of the API interface, it is still worth reading it.</source>
          <target state="translated">현재 API 인터페이스를 사용하지 않더라도 여전히 읽을 가치가 있습니다.</target>
        </trans-unit>
        <trans-unit id="7c8671eab5d7a940c940da36a9cbcdd6d20bec94" translate="yes" xml:space="preserve">
          <source>Even if you don't want to modify an array, this mechanism is useful for passing multiple arrays in a single LIST, because normally the LIST mechanism will merge all the array values so that you can't extract out the individual arrays. For more on typeglobs, see &lt;a href=&quot;perldata#Typeglobs-and-Filehandles&quot;&gt;&quot;Typeglobs and Filehandles&quot; in perldata&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11193f6fb31e4425ba4f294d83acb0ef83b5308c" translate="yes" xml:space="preserve">
          <source>Even if you don't want to modify an array, this mechanism is useful for passing multiple arrays in a single LIST, because normally the LIST mechanism will merge all the array values so that you can't extract out the individual arrays. For more on typeglobs, see &lt;a href=&quot;perldata#Typeglobs-and-Filehandles&quot;&gt;Typeglobs and Filehandles in perldata&lt;/a&gt;.</source>
          <target state="translated">배열을 수정하지 않더라도이 메커니즘은 단일 LIST에서 여러 배열을 전달하는 데 유용합니다. 일반적으로 LIST 메커니즘은 개별 배열을 추출 할 수 없도록 모든 배열 값을 병합합니다. typeglobs에 대한 자세한 내용 &lt;a href=&quot;perldata#Typeglobs-and-Filehandles&quot;&gt;은 perldata의 Typeglobs 및 Filehandles를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="704c6dd5d66c1d05562f24b58fe540e4c1622bbc" translate="yes" xml:space="preserve">
          <source>Even in a pattern that is interpolated and compiled at run-time, literal code blocks will be compiled once, at perl compile time; the following prints &quot;ABCD&quot;:</source>
          <target state="translated">런타임에 보간되고 컴파일되는 패턴에서도 리터럴 코드 블록은 perl 컴파일 타임에 한 번 컴파일됩니다. 다음은 &quot;ABCD&quot;를 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="f9a57fec05cf4b4012f5962aa352266b10461d68" translate="yes" xml:space="preserve">
          <source>Even more drastic example of a process-scope change is &lt;code&gt;&lt;a href=&quot;functions/chroot&quot;&gt;chroot()&lt;/a&gt;&lt;/code&gt;: the root directory of all the threads changes, and no thread can undo it (as opposed to &lt;code&gt;&lt;a href=&quot;functions/chdir&quot;&gt;chdir()&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">프로세스 범위 변경의 더 극적인 예는 &lt;code&gt;&lt;a href=&quot;functions/chroot&quot;&gt;chroot()&lt;/a&gt;&lt;/code&gt; . 모든 스레드의 루트 디렉토리가 변경되며 &lt;code&gt;&lt;a href=&quot;functions/chdir&quot;&gt;chdir()&lt;/a&gt;&lt;/code&gt; 과 달리 스레드를 취소 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="d47488f3c7fd4b4fcceda28125544a987450d2a0" translate="yes" xml:space="preserve">
          <source>Even more drastic example of a process-scope change is &lt;code&gt;chroot()&lt;/code&gt;: the root directory of all the threads changes, and no thread can undo it (as opposed to &lt;code&gt;chdir()&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fba46823e424c4e147c0d6ca9c73a6300bf0908c" translate="yes" xml:space="preserve">
          <source>Even numbered minor versions (5.14, 5.16, 5.18) are production versions, and odd numbered minor versions (5.15, 5.17, 5.19) are development versions. Unless you want to try out an experimental feature, you probably never want to install a development version of Perl.</source>
          <target state="translated">짝수 마이너 버전 (5.14, 5.16, 5.18)은 프로덕션 버전이고 홀수 마이너 버전 (5.15, 5.17, 5.19)은 개발 버전입니다. 실험적인 기능을 사용하지 않으려는 경우 Perl의 개발 버전을 설치하고 싶지 않을 것입니다.</target>
        </trans-unit>
        <trans-unit id="985c32669ab9bb43127ab9478cdf373b1b43c14e" translate="yes" xml:space="preserve">
          <source>Even the fallback for &lt;code&gt;decode&lt;/code&gt; must return octets, which are then decoded with the character encoding that &lt;code&gt;decode&lt;/code&gt; accepts. So for example if you wish to decode octets as UTF-8, and use ISO-8859-15 as a fallback for bytes that are not valid UTF-8, you could write</source>
          <target state="translated">&lt;code&gt;decode&lt;/code&gt; 대한 폴백조차도 옥텟을 반환해야하며, 디코딩 된 문자 인코딩으로 &lt;code&gt;decode&lt;/code&gt; 됩니다. 예를 들어 옥텟을 UTF-8로 디코딩하고 유효한 UTF-8이 아닌 바이트에 대한 폴백으로 ISO-8859-15를 사용하려는 경우 다음을 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="899cce7279e173a144c83044ba4c75852234efbb" translate="yes" xml:space="preserve">
          <source>Even though &lt;code&gt;dog&lt;/code&gt; is the first alternative in the second regex, &lt;code&gt;cat&lt;/code&gt; is able to match earlier in the string.</source>
          <target state="translated">비록 &lt;code&gt;dog&lt;/code&gt; 두 번째 정규 표현식의 첫 번째 대안은, &lt;code&gt;cat&lt;/code&gt; 문자열에서 이전과 일치 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="491ac4fd5a527c06bb95d6b29c3d2ceec9e2c0d4" translate="yes" xml:space="preserve">
          <source>Even though &lt;code&gt;dog&lt;/code&gt; is the first alternative in the second regexp, &lt;code&gt;cat&lt;/code&gt; is able to match earlier in the string.</source>
          <target state="translated">비록 &lt;code&gt;dog&lt;/code&gt; 두 번째 정규 표현식의 첫 번째 대안은, &lt;code&gt;cat&lt;/code&gt; 문자열에서 이전과 일치 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9e410bea532f43017a3bc057208bf28febe91829" translate="yes" xml:space="preserve">
          <source>Even though HP-UX 10.20 and 11.00 are not actively maintained by HP anymore, updates for the HP ANSI C compiler are still available from time to time, and it might be advisable to see if updates are applicable. At the moment of writing, the latests available patches for 11.00 that should be applied are PHSS_35098, PHSS_35175, PHSS_35100, PHSS_33036, and PHSS_33902). If you have a SUM account, you can use it to search for updates/patches. Enter &quot;ANSI&quot; as keyword.</source>
          <target state="translated">HP에서 더 이상 HP-UX 10.20 및 11.00을 유지 관리하지 않더라도 HP ANSI C 컴파일러에 대한 업데이트는 수시로 제공되며 업데이트가 적용 가능한지 확인하는 것이 좋습니다. 작성 시점에 적용해야 할 최신 11.00 패치는 PHSS_35098, PHSS_35175, PHSS_35100, PHSS_33036 및 PHSS_33902)입니다. SUM 계정이있는 경우이를 사용하여 업데이트 / 패치를 검색 할 수 있습니다. 키워드로 &quot;ANSI&quot;를 입력하십시오.</target>
        </trans-unit>
        <trans-unit id="66ef75af64ac05e5f42a2e25f67b5dd40dad7f74" translate="yes" xml:space="preserve">
          <source>Even though VOS allows the slash character to appear in object names, because the VOS port of Perl interprets it as a pathname delimiting character, VOS files, directories, or links whose names contain a slash character cannot be processed. Such files must be renamed before they can be processed by Perl.</source>
          <target state="translated">VOS가 슬래시 문자를 오브젝트 이름에 표시하도록 허용하더라도 Perl의 VOS 포트는이를 경로 이름으로 구분하는 문자, VOS 파일, 디렉토리 또는 슬래시 문자가 포함 된 링크로 해석 할 수 없기 때문에 처리 할 수 ​​없습니다. 이러한 파일은 Perl에서 처리하기 전에 이름을 바꿔야합니다.</target>
        </trans-unit>
        <trans-unit id="cdd82719baf99cfe9734df3eaad725f4efdb196d" translate="yes" xml:space="preserve">
          <source>Even though a reference may be declared as a constant, the reference may point to data which may be changed, as this code shows.</source>
          <target state="translated">참조가 상수로 선언 될 수 있지만이 코드가 보여주는 것처럼 참조는 변경 될 수있는 데이터를 가리킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6c1ced7503a24a96a968e8abe517680e11868256" translate="yes" xml:space="preserve">
          <source>Even though it doesn't do much, it is still preferable to writing your own classes from scratch.</source>
          <target state="translated">많은 일을하지 않아도 자신의 클래스를 처음부터 작성하는 것이 여전히 바람직합니다.</target>
        </trans-unit>
        <trans-unit id="5d86d002ba38ad23c3e6f35071476718335949c5" translate="yes" xml:space="preserve">
          <source>Even though it looks as though they're the same method calls (uid), they aren't, because a &lt;code&gt;File::stat&lt;/code&gt; object is different from a &lt;code&gt;User::pwent&lt;/code&gt; object.</source>
          <target state="translated">&lt;code&gt;File::stat&lt;/code&gt; 객체가 &lt;code&gt;User::pwent&lt;/code&gt; 객체 와 다르기 때문에 동일한 메소드 호출 (uid) 인 것처럼 보이지만 그렇지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="6dc6e1961fe501af8f7b8e43fd427c0320c933fd" translate="yes" xml:space="preserve">
          <source>Even though some of this section may not be understandable to you on first reading, we think it's important enough to highlight some of the gotchas before delving further, so here goes:</source>
          <target state="translated">이 섹션 중 일부는 처음 읽을 때 이해하기 어려울 수 있지만 더 자세히 살펴보기 전에 문제를 강조 표시하는 것이 중요하다고 생각합니다.</target>
        </trans-unit>
        <trans-unit id="a15d3a1eac0736a5f4619bbd0fabeec7d4b2fc07" translate="yes" xml:space="preserve">
          <source>Even though these two matches might be thought of as complements, until v5.20 they were so only on Unicode code points.</source>
          <target state="translated">이 두 개의 일치 항목이 보완으로 생각 될 수 있지만 v5.20까지는 유니 코드 코드 포인트에만 적용되었습니다.</target>
        </trans-unit>
        <trans-unit id="763ed71064b10dfe0eadc8f471bf100bdbc4763d" translate="yes" xml:space="preserve">
          <source>Even though with normal text files a &quot;\n&quot; will do the trick, there is still no unified scheme for terminating a line that is portable between Unix, DOS/Win, and Macintosh, except to terminate</source>
          <target state="translated">일반 텍스트 파일의 경우 &quot;\ n&quot;을 사용하여 트릭을 수행 할 수 있지만 Unix, DOS / Win 및 Macintosh간에 이식 가능한 회선을 종료하기위한 통합 체계는 아직 없습니다.</target>
        </trans-unit>
        <trans-unit id="4630d8c85d1750185c25d65fe850b66a19d12625" translate="yes" xml:space="preserve">
          <source>Even though you started with a completely empty hash, after that call to &lt;code&gt;&lt;a href=&quot;functions/exists&quot;&gt;exists&lt;/a&gt;&lt;/code&gt; you've created the structure you needed to check for &lt;code&gt;key3&lt;/code&gt; :</source>
          <target state="translated">완전히 빈 해시로 시작했지만 그 호출이 &lt;code&gt;&lt;a href=&quot;functions/exists&quot;&gt;exists&lt;/a&gt;&lt;/code&gt; 하면 &lt;code&gt;key3&lt;/code&gt; 를 확인하는 데 필요한 구조를 만들었습니다 .</target>
        </trans-unit>
        <trans-unit id="65c079978ec4f4cfbd582b4959b8aaf4fe2b2dbe" translate="yes" xml:space="preserve">
          <source>Even though you started with a completely empty hash, after that call to &lt;code&gt;exists&lt;/code&gt; you've created the structure you needed to check for &lt;code&gt;key3&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08c088010f5560d49366ca00a6983df9e83535cb" translate="yes" xml:space="preserve">
          <source>Even when on a single platform (if you can call Unix a single platform), remember not to count on the existence or the contents of particular system-specific files or directories, like</source>
          <target state="translated">단일 플랫폼에서 (유닉스를 단일 플랫폼으로 호출 할 수있는 경우) 특정 시스템 특정 파일 또는 디렉토리의 존재 또는 내용을 신뢰하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="1602f4d9817a3dceaa33d17e6c176137283825a5" translate="yes" xml:space="preserve">
          <source>Even with all this work, regexp matching happens remarkably fast. To speed things up, Perl compiles the regexp into a compact sequence of opcodes that can often fit inside a processor cache. When the code is executed, these opcodes can then run at full throttle and search very quickly.</source>
          <target state="translated">이 모든 작업에도 불구하고 정규 표현식 일치는 매우 빠릅니다. 속도를 높이기 위해 Perl은 정규식을 종종 프로세서 캐시 내에 들어갈 수있는 간단한 opcode 시퀀스로 컴파일합니다. 코드가 실행될 때이 opcode는 최대 스로틀에서 실행되고 매우 빠르게 검색 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="35946850beee8b541477d17361e646c61666892c" translate="yes" xml:space="preserve">
          <source>Even with the latest version of Perl, it is known that certain constructs with threads may result in warning messages concerning leaked scalars or unreferenced scalars. However, such warnings are harmless, and may safely be ignored.</source>
          <target state="translated">최신 버전의 Perl을 사용하더라도 스레드가있는 특정 구성은 누출 된 스칼라 또는 참조되지 않은 스칼라와 관련된 경고 메시지를 생성 할 수 있습니다. 그러나 이러한 경고는 무해하며 무시해도됩니다.</target>
        </trans-unit>
        <trans-unit id="878e531bfbade13b1bab65a888ae7d4bdc1140e8" translate="yes" xml:space="preserve">
          <source>Event Log</source>
          <target state="translated">이벤트 로그</target>
        </trans-unit>
        <trans-unit id="d3032d704e23194c50435cf4a6371b080589c4eb" translate="yes" xml:space="preserve">
          <source>Event driven.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d1394956111c7856f6f7f78713d6c0aa968cc8b" translate="yes" xml:space="preserve">
          <source>Event for TAP version.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb79b9266fc643c28f6d3ecc5b6b3731a8786707" translate="yes" xml:space="preserve">
          <source>Event for a simple failed assertion</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fcd541c73c6d801e12ef6ab2a2ef6eeb8678fe31" translate="yes" xml:space="preserve">
          <source>Event for a simple passing assertion</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1cbb1e51381ea5f156ee24e974d0e8c3d15bb5e6" translate="yes" xml:space="preserve">
          <source>Event for subtest types</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa125b31576ec16d1e191efd5ca768b2aa4efa32" translate="yes" xml:space="preserve">
          <source>Event package name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5497bca58468ae64aed6c0fd921109217988db3" translate="yes" xml:space="preserve">
          <source>Events</source>
          <target state="translated">Events</target>
        </trans-unit>
        <trans-unit id="3cece53956ddc248529397d0c65ecaab5ebb07b6" translate="yes" xml:space="preserve">
          <source>Events live under this namespace. It is considered acceptable for third party distributions to add new event types in this namespace.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50edb0cf580f75f4a0fea837a24e96eb1cff3aca" translate="yes" xml:space="preserve">
          <source>Events use this facet when they need to set the plan.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98b8ce2e1404f72b01628a7fbd8afce9a0ca4416" translate="yes" xml:space="preserve">
          <source>Events within a buffered subtest may or may not be sent to the formatter as they happen. If a formatter fails to specify then the default is to &lt;b&gt;NOT SEND&lt;/b&gt; the events as they are generated, instead the formatter can pull them from the &lt;code&gt;subevents&lt;/code&gt; attribute.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4538af23a815bef65c32e32809e639186875a9f" translate="yes" xml:space="preserve">
          <source>Eventually, with better documentation and possible some cleanup, this could be part of &lt;code&gt;ExtUtils::Typemaps&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d002601ef62e11979d8b7c94cd10d54da0d3a8e1" translate="yes" xml:space="preserve">
          <source>Ever wanted to know what a regex looked like? You'll need perl compiled with the DEBUGGING flag for this one:</source>
          <target state="translated">정규식이 어떻게 생겼는지 알고 싶습니까? 이것을 위해 DEBUGGING 플래그로 컴파일 된 펄이 필요합니다 :</target>
        </trans-unit>
        <trans-unit id="d845fa7f9ca71d8879b9cc1aee98930cd966bdbd" translate="yes" xml:space="preserve">
          <source>Every CPAN module has a bug tracker set up in RT, &lt;a href=&quot;http://rt.cpan.org&quot;&gt;http://rt.cpan.org&lt;/a&gt;. You can submit bugs to RT either through its web interface or by email. To email a bug report, send it to bug-&amp;lt;distribution-name&amp;gt;@rt.cpan.org . For example, if you wanted to report a bug in &lt;a href=&quot;Business::ISBN&quot;&gt;Business::ISBN&lt;/a&gt;, you could send a message to bug-Business-ISBN@rt.cpan.org .</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3fc9126b1847307a5366bc653e3a3467f58a3dfa" translate="yes" xml:space="preserve">
          <source>Every CPAN module has a bug tracker set up in RT, &lt;a href=&quot;http://rt.cpan.org&quot;&gt;http://rt.cpan.org&lt;/a&gt;. You can submit bugs to RT either through its web interface or by email. To email a bug report, send it to bug-&amp;lt;distribution-name&amp;gt;@rt.cpan.org . For example, if you wanted to report a bug in &lt;a href=&quot;http://search.cpan.org/perldoc/Business::ISBN&quot;&gt;Business::ISBN&lt;/a&gt;, you could send a message to bug-Business-ISBN@rt.cpan.org .</source>
          <target state="translated">모든 CPAN 모듈에는 RT ( &lt;a href=&quot;http://rt.cpan.org&quot;&gt;http://rt.cpan.org)&lt;/a&gt; 에 버그 추적기가 설정되어 있습니다 . 웹 인터페이스 또는 이메일을 통해 RT에 버그를 제출할 수 있습니다. 버그 보고서를 이메일로 보내려면 bug- &amp;lt;distribution-name&amp;gt; @ rt.cpan.org로 보내십시오. 예를 들어 &lt;a href=&quot;http://search.cpan.org/perldoc/Business::ISBN&quot;&gt;Business :: ISBN&lt;/a&gt; 에서 버그를보고하려는 경우 bug-Business-ISBN@rt.cpan.org로 메시지를 보낼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b8dc7000ca1bb13ca17faed27406eccbd7bcf88b" translate="yes" xml:space="preserve">
          <source>Every Makefile.PL is run by perl in a separate process. Likewise we run 'make' and 'make install' in separate processes. If you have any parameters (e.g. PREFIX, UNINST or the like) you want to pass to the calls, please specify them here.</source>
          <target state="translated">모든 Makefile.PL은 별도의 프로세스에서 perl에 의해 실행됩니다. 마찬가지로 별도의 프로세스에서 'make'및 'make install'을 실행합니다. 호출에 전달할 매개 변수 (예 : PREFIX, UNINST 등)가있는 경우 여기에 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="5243f64d154762b9f500ff300bf1242e41c19e00" translate="yes" xml:space="preserve">
          <source>Every Unicode character is assigned a general category, which is the &quot;most usual categorization of a character&quot; (from &lt;a href=&quot;http://www.unicode.org/reports/tr44&quot;&gt;http://www.unicode.org/reports/tr44&lt;/a&gt;).</source>
          <target state="translated">모든 유니 코드 문자에는 일반 범주가 할당되는데, 이는 &quot;가장 일반적인 문자 분류&quot;( &lt;a href=&quot;http://www.unicode.org/reports/tr44&quot;&gt;http://www.unicode.org/reports/tr44&lt;/a&gt; )입니다.</target>
        </trans-unit>
        <trans-unit id="44bc5eca50d1bb33525106b332f679e0c37967c9" translate="yes" xml:space="preserve">
          <source>Every Unicode character is assigned a general category, which is the &quot;most usual categorization of a character&quot; (from &lt;a href=&quot;https://www.unicode.org/reports/tr44&quot;&gt;https://www.unicode.org/reports/tr44&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2fe5013abe724619f4b95c9d05a2b40a50dbbb59" translate="yes" xml:space="preserve">
          <source>Every YAML document represents a single hash reference. The valid keys in this hash are as follows:</source>
          <target state="translated">모든 YAML 문서는 단일 해시 참조를 나타냅니다. 이 해시의 유효한 키는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="302f7ff33fa3b90fdd2132b2697fb84f8705e874" translate="yes" xml:space="preserve">
          <source>Every YAML file may contain arbitrary documents according to the YAML specification, and every document is treated as an entity that can specify the treatment of a single distribution.</source>
          <target state="translated">모든 YAML 파일은 YAML 사양에 따라 임의의 문서를 포함 할 수 있으며 모든 문서는 단일 배포 처리를 지정할 수있는 엔티티로 취급됩니다.</target>
        </trans-unit>
        <trans-unit id="08580b590313edf277a406f46fd0c846e6d3947e" translate="yes" xml:space="preserve">
          <source>Every case has a specific application and one or more exceptions, and there is no replacement for running a few tests and finding out which method works best for your particular environment, this is why writing optimal code is not an exact science, and why we love using Perl so much - TMTOWTDI.</source>
          <target state="translated">모든 사례에는 특정 응용 프로그램과 하나 이상의 예외가 있으며, 몇 가지 테스트를 실행하고 특정 환경에 가장 적합한 방법을 찾기위한 대체 방법이 없으므로 최적의 코드 작성이 정확한 과학이 아니며 왜 우리가 좋아하는지 펄을 너무 많이 사용-TMTOWTDI.</target>
        </trans-unit>
        <trans-unit id="5d3966578fbc31ddc5c9c823b10c9d09c4de1eb0" translate="yes" xml:space="preserve">
          <source>Every code point can be represented by more than one possible syntactically valid UTF-8 sequence. Early on, both Unicode and Perl considered any of these to be valid, but now, all sequences longer than the shortest possible one are considered to be malformed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e844c7ea0f1cedd3ae0259a6817d00e2a02c10f0" translate="yes" xml:space="preserve">
          <source>Every developer publishing modules on CPAN needs a CPAN ID. Visit &lt;code&gt;&lt;a href=&quot;http://pause.perl.org/&quot;&gt;http://pause.perl.org/&lt;/a&gt;&lt;/code&gt;, select &quot;Request PAUSE Account&quot;, and wait for your request to be approved by the PAUSE administrators.</source>
          <target state="translated">CPAN의 모든 개발자 공개 모듈에는 CPAN ID가 필요합니다. &lt;code&gt;&lt;a href=&quot;http://pause.perl.org/&quot;&gt;http://pause.perl.org/&lt;/a&gt;&lt;/code&gt; 를 방문 하여 &quot;PAUSE 계정 요청&quot;을 선택하고 PAUSE 관리자가 요청을 승인 할 때까지 기다리십시오.</target>
        </trans-unit>
        <trans-unit id="e4befbeaf4f0b8eb62e07538a8708d75b3c87445" translate="yes" xml:space="preserve">
          <source>Every element in an arrayref directly below a 'par' key is eligible to be run in parallel, while vavalues directly below a 'seq' key must be run in sequence.</source>
          <target state="translated">'par'키 바로 아래의 arrayref에있는 모든 요소는 병렬로 실행할 수 있지만 'seq'키 바로 아래의 vavalue는 순서대로 실행해야합니다.</target>
        </trans-unit>
        <trans-unit id="e1c563b6d35c0f4b5118e9474a1d4ce3c52e7bcc" translate="yes" xml:space="preserve">
          <source>Every element node in the parse tree is represented by an arrayref of the form: &lt;code&gt;[ &lt;i&gt;elementname&lt;/i&gt;, \%attributes, &lt;i&gt;...subnodes...&lt;/i&gt; ]&lt;/code&gt;. See the example tree dump in the Synopsis, above.</source>
          <target state="translated">구문 분석 트리의 모든 요소 노드는 &lt;code&gt;[ &lt;i&gt;elementname&lt;/i&gt;, \%attributes, &lt;i&gt;...subnodes...&lt;/i&gt; ]&lt;/code&gt; 형식의 arrayref로 표시됩니다 . 위의 개요에서 트리 덤프 예를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="6134bc0f6fbba39ed1a9d9da08c6587b9ff61665" translate="yes" xml:space="preserve">
          <source>Every line here (apart from the braces, of course) contains a macro. The first line sets up the function declaration as Perl expects for PP code; line 3 sets up variable declarations for the argument stack and the target, the return value of the operation. Finally, it tries to see if the addition operation is overloaded; if so, the appropriate subroutine is called.</source>
          <target state="translated">여기의 모든 줄은 물론 중괄호를 제외하고 매크로를 포함합니다. 첫 번째 줄은 Perl이 PP 코드에 대해 기대하는대로 함수 선언을 설정합니다. 3 행은 인수 스택과 대상에 대한 변수 선언, 작업의 반환 값을 설정합니다. 마지막으로 추가 작업이 오버로드되었는지 확인하려고 시도합니다. 그렇다면 적절한 서브 루틴이 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="9871a7eb268ef840aca89ae1947284ed4718351a" translate="yes" xml:space="preserve">
          <source>Every line here (apart from the braces, of course) contains a macro. The first line sets up the function declaration as Perl expects for PP code; line 3 sets up variable declarations for the argument stack and the target, the return value of the operation. Line 4 tries to see if the addition operation is overloaded; if so, the appropriate subroutine is called.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16573fbf6c4df85710f7971d1598380405b3cf7c" translate="yes" xml:space="preserve">
          <source>Every single tool in the chain from this, to &lt;code&gt;ok&lt;/code&gt;, to anything &lt;code&gt;ok&lt;/code&gt; calls needs to increment the &lt;code&gt;$Level&lt;/code&gt; variable. When an error occurs Test::Builder will do a trace to the stack frame determined by &lt;code&gt;$Level&lt;/code&gt;, and report that file+line as the one where the error occurred. If you or any other tool you use forgets to set &lt;code&gt;$Level&lt;/code&gt; then errors will be reported to the wrong place.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a07a9740c8c1d7a3f895cbb42b5e873e7ccb12fd" translate="yes" xml:space="preserve">
          <source>Every source stream is associated with only one file.</source>
          <target state="translated">모든 소스 스트림은 하나의 파일에만 연결됩니다.</target>
        </trans-unit>
        <trans-unit id="5b61ca48fb706399cd7458bb7c44f76e50b97e70" translate="yes" xml:space="preserve">
          <source>Every text node in the tree is represented by a simple (non-ref) string scalar. So you can test &lt;code&gt;&lt;a href=&quot;../../functions/ref&quot;&gt;ref($node)&lt;/a&gt;&lt;/code&gt; to see whether you have an element node or just a text node.</source>
          <target state="translated">트리의 모든 텍스트 노드는 단순한 (비 참조) 문자열 스칼라로 표시됩니다. 따라서 &lt;code&gt;&lt;a href=&quot;../../functions/ref&quot;&gt;ref($node)&lt;/a&gt;&lt;/code&gt; 를 테스트 하여 요소 노드가 있는지 아니면 텍스트 노드 만 있는지 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4b4dd92417b29f82a4df6cf833806102b2032c12" translate="yes" xml:space="preserve">
          <source>Every text node in the tree is represented by a simple (non-ref) string scalar. So you can test &lt;code&gt;ref($node)&lt;/code&gt; to see whether you have an element node or just a text node.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f280cfdb5544f17d8056c7b9960291300e70ff8a" translate="yes" xml:space="preserve">
          <source>Every variable type has its own namespace, as do several non-variable identifiers. This means that you can, without fear of conflict, use the same name for a scalar variable, an array, or a hash--or, for that matter, for a filehandle, a directory handle, a subroutine name, a format name, or a label. This means that $foo and @foo are two different variables. It also means that &lt;code&gt;$foo[1]&lt;/code&gt; is a part of @foo, not a part of $foo. This may seem a bit weird, but that's okay, because it is weird.</source>
          <target state="translated">변수가 아닌 여러 식별자와 마찬가지로 모든 변수 유형에는 고유 한 네임 스페이스가 있습니다. 즉, 충돌에 대한 두려움없이 스칼라 변수, 배열 또는 해시에 대해 동일한 이름을 사용할 수 있습니다. 즉, 파일 핸들, 디렉토리 핸들, 서브 루틴 이름, 형식 이름, 또는 라벨. 이것은 $ foo와 @foo가 서로 다른 변수라는 것을 의미합니다. 또한 &lt;code&gt;$foo[1]&lt;/code&gt; 은 $ foo의 일부가 아닌 @foo의 일부 임을 의미합니다 . 조금 이상하게 보일 수도 있지만, 이상하기 때문에 괜찮습니다.</target>
        </trans-unit>
        <trans-unit id="c6b180367788582d4ac065b82e10c88a1c69b113" translate="yes" xml:space="preserve">
          <source>Every version of perl has some number of features present but considered &quot;experimental.&quot; For much of the life of Perl 5, this was only a designation found in the documentation. Starting in Perl v5.10.0, and more aggressively in v5.18.0, experimental features were placed behind pragmata used to enable the feature and disable associated warnings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88a304f3d76dc1d9d113e9e43b3de43a63253440" translate="yes" xml:space="preserve">
          <source>Everyone needs compound data structures, and in Perl the way you get them is with references. There are four important rules for managing references: Two for making references and two for using them. Once you know these rules you can do most of the important things you need to do with references.</source>
          <target state="translated">누구나 복합 데이터 구조가 필요하며 Perl에서는 참조 방식을 사용합니다. 참조 관리를위한 4 가지 중요한 규칙이 있습니다. 이러한 규칙을 알고 나면 참조로해야 할 중요한 작업을 대부분 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d9f3a853f21ee670feb2d57d64386bb213e70924" translate="yes" xml:space="preserve">
          <source>Everything is exported by default</source>
          <target state="translated">기본적으로 모든 것이 내보내집니다</target>
        </trans-unit>
        <trans-unit id="821563e027b1aef4013748dd378d74e1f89659aa" translate="yes" xml:space="preserve">
          <source>Everything that comes with the official</source>
          <target state="translated">공식과 함께 제공되는 모든 것</target>
        </trans-unit>
        <trans-unit id="f760e16023bf894abde8086e9d7f6c930e923eae" translate="yes" xml:space="preserve">
          <source>Evolution</source>
          <target state="translated">Evolution</target>
        </trans-unit>
        <trans-unit id="be9e0b5a60df791db5db8c0c5ce8e708153692fd" translate="yes" xml:space="preserve">
          <source>Exact name value matching means you have to specify case, hyphens, underscores, and spaces precisely in the name you want. Loose matching follows the Unicode rules &lt;a href=&quot;https://www.unicode.org/reports/tr44/tr44-24.html#UAX44-LM2&quot;&gt;https://www.unicode.org/reports/tr44/tr44-24.html#UAX44-LM2&lt;/a&gt;, where these are mostly irrelevant. Except for a few outlier character names, these are the same rules as are already used for any other &lt;code&gt;\p{...}&lt;/code&gt; property.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7b6ebbed9d8b46f1eee90eb921f0ea47e548b03" translate="yes" xml:space="preserve">
          <source>Exact version of acceptance unclear, but no later than Perl 5.18.</source>
          <target state="translated">정확한 수용 버전은 확실하지 않지만 Perl 5.18 이하입니다.</target>
        </trans-unit>
        <trans-unit id="e38657e86225451957dba5ba0d3e55c8be9b8de9" translate="yes" xml:space="preserve">
          <source>Exactly equivalent to &lt;code&gt;Perl_croak(aTHX_ &quot;%s&quot;, PL_no_modify)&lt;/code&gt; , but generates terser object code than using &lt;code&gt;Perl_croak&lt;/code&gt; . Less code used on exception code paths reduces CPU cache pressure.</source>
          <target state="translated">&lt;code&gt;Perl_croak(aTHX_ &quot;%s&quot;, PL_no_modify)&lt;/code&gt; 와 정확히 동일 하지만 &lt;code&gt;Perl_croak&lt;/code&gt; 를 사용하는 것보다 terser 객체 코드를 생성합니다 . 예외 코드 경로에 사용되는 코드가 적 으면 CPU 캐시 압력이 줄어 듭니다.</target>
        </trans-unit>
        <trans-unit id="1def74e4170191cc1ecc96e344d4615200db8d79" translate="yes" xml:space="preserve">
          <source>Exactly equivalent to &lt;code&gt;Perl_croak(aTHX_ &quot;%s&quot;, PL_no_modify)&lt;/code&gt;, but generates terser object code than using &lt;code&gt;Perl_croak&lt;/code&gt;. Less code used on exception code paths reduces CPU cache pressure.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6053d16ee562b64ba170e6e47fc5857d6aeb0497" translate="yes" xml:space="preserve">
          <source>Exactly like &lt;a href=&quot;#gv_fetchmeth_pvn&quot;&gt;&quot;gv_fetchmeth_pvn&quot;&lt;/a&gt;, but takes a nul-terminated string instead of a string/length pair.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd790b9a98470795c376e22181e112aefbda6acd" translate="yes" xml:space="preserve">
          <source>Exactly like &lt;a href=&quot;#gv_fetchmeth_pvn&quot;&gt;&quot;gv_fetchmeth_pvn&quot;&lt;/a&gt;, but takes the name string in the form of an SV instead of a string/length pair.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c8b76dc891dae007ee34c3cafc01118a9a75f9f" translate="yes" xml:space="preserve">
          <source>Exactly like &lt;a href=&quot;#gv_fetchmeth_pvn&quot;&gt;gv_fetchmeth_pvn&lt;/a&gt;, but takes a nul-terminated string instead of a string/length pair.</source>
          <target state="translated">&lt;a href=&quot;#gv_fetchmeth_pvn&quot;&gt;gv_fetchmeth_pvn&lt;/a&gt; 과 정확히 동일 하지만 문자열 / 길이 쌍 대신 널 종료 문자열을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="108d410dddfe12b3ba82a3d3c5aded251e31ceaa" translate="yes" xml:space="preserve">
          <source>Exactly like &lt;a href=&quot;#gv_fetchmeth_pvn&quot;&gt;gv_fetchmeth_pvn&lt;/a&gt;, but takes the name string in the form of an SV instead of a string/length pair.</source>
          <target state="translated">&lt;a href=&quot;#gv_fetchmeth_pvn&quot;&gt;gv_fetchmeth_pvn&lt;/a&gt; 과 정확히 동일 하지만 문자열 / 길이 쌍 대신 SV 형식으로 이름 문자열을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="70cd839834c4360be38cc8d256d0d20412f0b989" translate="yes" xml:space="preserve">
          <source>Exactly like &lt;a href=&quot;#gv_fetchmeth_pvn_autoload&quot;&gt;&quot;gv_fetchmeth_pvn_autoload&quot;&lt;/a&gt;, but takes a nul-terminated string instead of a string/length pair.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11580dd84621e2b64c36cda28026ace99fe93821" translate="yes" xml:space="preserve">
          <source>Exactly like &lt;a href=&quot;#gv_fetchmeth_pvn_autoload&quot;&gt;&quot;gv_fetchmeth_pvn_autoload&quot;&lt;/a&gt;, but takes the name string in the form of an SV instead of a string/length pair.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="752e1ac766f2cea599a309e02440f40a97bb8d75" translate="yes" xml:space="preserve">
          <source>Exactly like &lt;a href=&quot;#gv_fetchmeth_pvn_autoload&quot;&gt;gv_fetchmeth_pvn_autoload&lt;/a&gt;, but takes a nul-terminated string instead of a string/length pair.</source>
          <target state="translated">&lt;a href=&quot;#gv_fetchmeth_pvn_autoload&quot;&gt;gv_fetchmeth_pvn_autoload&lt;/a&gt; 와 똑같지 만 문자열 / 길이 쌍 대신 널 종료 문자열을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="a2b3eb60980e277cbebb6619993b224a080d7c7e" translate="yes" xml:space="preserve">
          <source>Exactly like &lt;a href=&quot;#gv_fetchmeth_pvn_autoload&quot;&gt;gv_fetchmeth_pvn_autoload&lt;/a&gt;, but takes the name string in the form of an SV instead of a string/length pair.</source>
          <target state="translated">&lt;a href=&quot;#gv_fetchmeth_pvn_autoload&quot;&gt;gv_fetchmeth_pvn_autoload&lt;/a&gt; 와 똑같지 만 문자열 / 길이 쌍 대신 SV 형식으로 이름 문자열을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="0d559e98d13b3a163a9ac6d26cc159b061a846ce" translate="yes" xml:space="preserve">
          <source>Exactly like &lt;a href=&quot;#pad_add_name_pvn&quot;&gt;&quot;pad_add_name_pvn&quot;&lt;/a&gt;, but takes a literal string instead of a string/length pair.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="241177ff9d4a9c2896853e85618eb16dd97a70c1" translate="yes" xml:space="preserve">
          <source>Exactly like &lt;a href=&quot;#pad_add_name_pvn&quot;&gt;&quot;pad_add_name_pvn&quot;&lt;/a&gt;, but takes a nul-terminated string instead of a string/length pair.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ca8fa3e370c992adee4f86a24ca37067ce4aaf2" translate="yes" xml:space="preserve">
          <source>Exactly like &lt;a href=&quot;#pad_add_name_pvn&quot;&gt;&quot;pad_add_name_pvn&quot;&lt;/a&gt;, but takes the name string in the form of an SV instead of a string/length pair.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2fed67a8755ba4f29f90415a63203b5925d94458" translate="yes" xml:space="preserve">
          <source>Exactly like &lt;a href=&quot;#pad_add_name_pvn&quot;&gt;pad_add_name_pvn&lt;/a&gt;, but takes a literal string instead of a string/length pair.</source>
          <target state="translated">&lt;a href=&quot;#pad_add_name_pvn&quot;&gt;pad_add_name_pvn&lt;/a&gt; 과 정확히 동일 하지만 문자열 / 길이 쌍 대신 리터럴 문자열을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="08b5afa04635fafa6b86d20073dca412668556d2" translate="yes" xml:space="preserve">
          <source>Exactly like &lt;a href=&quot;#pad_add_name_pvn&quot;&gt;pad_add_name_pvn&lt;/a&gt;, but takes a nul-terminated string instead of a string/length pair.</source>
          <target state="translated">&lt;a href=&quot;#pad_add_name_pvn&quot;&gt;pad_add_name_pvn&lt;/a&gt; 과 정확히 동일 하지만 문자열 / 길이 쌍 대신 널 종료 문자열을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="2ec05cc4ebe9d68aa94cb00389e8f5276b127226" translate="yes" xml:space="preserve">
          <source>Exactly like &lt;a href=&quot;#pad_add_name_pvn&quot;&gt;pad_add_name_pvn&lt;/a&gt;, but takes the name string in the form of an SV instead of a string/length pair.</source>
          <target state="translated">&lt;a href=&quot;#pad_add_name_pvn&quot;&gt;pad_add_name_pvn&lt;/a&gt; 과 정확히 동일 하지만 문자열 / 길이 쌍 대신 SV 형식으로 이름 문자열을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="721fb60df3440b2db377705e79d6aa33255046e5" translate="yes" xml:space="preserve">
          <source>Exactly like &lt;a href=&quot;#pad_findmy_pvn&quot;&gt;&quot;pad_findmy_pvn&quot;&lt;/a&gt;, but takes a literal string instead of a string/length pair.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="858cd1e7a5bd641a77589913581d976a28b686b2" translate="yes" xml:space="preserve">
          <source>Exactly like &lt;a href=&quot;#pad_findmy_pvn&quot;&gt;&quot;pad_findmy_pvn&quot;&lt;/a&gt;, but takes a nul-terminated string instead of a string/length pair.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94c2f18b7b484bc1bcc0d307015d1cb3e5fc9527" translate="yes" xml:space="preserve">
          <source>Exactly like &lt;a href=&quot;#pad_findmy_pvn&quot;&gt;&quot;pad_findmy_pvn&quot;&lt;/a&gt;, but takes the name string in the form of an SV instead of a string/length pair.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1fc43c20a7b147a5aa429b8bfb5b2198f1bee606" translate="yes" xml:space="preserve">
          <source>Exactly like &lt;a href=&quot;#pad_findmy_pvn&quot;&gt;pad_findmy_pvn&lt;/a&gt;, but takes a literal string instead of a string/length pair.</source>
          <target state="translated">&lt;a href=&quot;#pad_findmy_pvn&quot;&gt;pad_findmy_pvn&lt;/a&gt; 과 정확히 동일 하지만 문자열 / 길이 쌍 대신 리터럴 문자열을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="1f5dc14f0356699ed601763f5b30ea66b583f929" translate="yes" xml:space="preserve">
          <source>Exactly like &lt;a href=&quot;#pad_findmy_pvn&quot;&gt;pad_findmy_pvn&lt;/a&gt;, but takes a nul-terminated string instead of a string/length pair.</source>
          <target state="translated">&lt;a href=&quot;#pad_findmy_pvn&quot;&gt;pad_findmy_pvn&lt;/a&gt; 과 정확히 동일 하지만 문자열 / 길이 쌍 대신 널 종료 문자열을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="381384c344ba8cf1c452502a4a84edc8e962e04a" translate="yes" xml:space="preserve">
          <source>Exactly like &lt;a href=&quot;#pad_findmy_pvn&quot;&gt;pad_findmy_pvn&lt;/a&gt;, but takes the name string in the form of an SV instead of a string/length pair.</source>
          <target state="translated">&lt;a href=&quot;#pad_findmy_pvn&quot;&gt;pad_findmy_pvn&lt;/a&gt; 과 정확히 동일 하지만 문자열 / 길이 쌍 대신 SV 형식으로 이름 문자열을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="18d3309cb57d37bd7fd350ad135bb897c6c3caec" translate="yes" xml:space="preserve">
          <source>Exactly like &lt;a href=&quot;#sv_derived_from_pv&quot;&gt;&quot;sv_derived_from_pv&quot;&lt;/a&gt;, but doesn't take a &lt;code&gt;flags&lt;/code&gt; parameter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7e2d16336a0ca2ee4b68d73a469a9a7d8cd8bf4" translate="yes" xml:space="preserve">
          <source>Exactly like &lt;a href=&quot;#sv_derived_from_pv&quot;&gt;sv_derived_from_pv&lt;/a&gt;, but doesn't take a &lt;code&gt;flags&lt;/code&gt; parameter.</source>
          <target state="translated">&lt;a href=&quot;#sv_derived_from_pv&quot;&gt;sv_derived_from_pv&lt;/a&gt; 와 정확히 동일 하지만 &lt;code&gt;flags&lt;/code&gt; 매개 변수를 사용 하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="3b2c74334223dd3188d999503340448a8a7e5fef" translate="yes" xml:space="preserve">
          <source>Exactly like &lt;a href=&quot;#sv_derived_from_pvn&quot;&gt;&quot;sv_derived_from_pvn&quot;&lt;/a&gt;, but takes a nul-terminated string instead of a string/length pair.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ba2fef806c19d8e36b1b9aa042130a5d1188a1f" translate="yes" xml:space="preserve">
          <source>Exactly like &lt;a href=&quot;#sv_derived_from_pvn&quot;&gt;&quot;sv_derived_from_pvn&quot;&lt;/a&gt;, but takes the name string in the form of an SV instead of a string/length pair. This is the advised form.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ca422a64172952765c1b42b368f2ea1d836ab7e" translate="yes" xml:space="preserve">
          <source>Exactly like &lt;a href=&quot;#sv_derived_from_pvn&quot;&gt;sv_derived_from_pvn&lt;/a&gt;, but takes a nul-terminated string instead of a string/length pair.</source>
          <target state="translated">정확히 &lt;a href=&quot;#sv_derived_from_pvn&quot;&gt;sv_derived_from_pvn&lt;/a&gt; 과 비슷 하지만 문자열 / 길이 쌍 대신 널 종료 문자열을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="89c565bb719c5d7bd5d0a569932a9c743f646c23" translate="yes" xml:space="preserve">
          <source>Exactly like &lt;a href=&quot;#sv_derived_from_pvn&quot;&gt;sv_derived_from_pvn&lt;/a&gt;, but takes the name string in the form of an SV instead of a string/length pair.</source>
          <target state="translated">정확히 &lt;a href=&quot;#sv_derived_from_pvn&quot;&gt;sv_derived_from_pvn&lt;/a&gt; 과 비슷 하지만 문자열 / 길이 쌍 대신 SV 형식으로 이름 문자열을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="f536be833f98474874e14c0022645d10cd4c4708" translate="yes" xml:space="preserve">
          <source>Exactly like &lt;code&gt;XopENTRY(XopENTRY(Perl_custom_op_xop(aTHX_ o), which)&lt;/code&gt; but more efficient. The</source>
          <target state="translated">정확하게 &lt;code&gt;XopENTRY(XopENTRY(Perl_custom_op_xop(aTHX_ o), which)&lt;/code&gt; 비슷하지만 더 효율적입니다.</target>
        </trans-unit>
        <trans-unit id="ed85a2d94251cb3b70317fcac3c7aa7dfac953f8" translate="yes" xml:space="preserve">
          <source>Exactly like &lt;code&gt;XopENTRY(XopENTRY(Perl_custom_op_xop(aTHX_ o), which)&lt;/code&gt; but more efficient. The &lt;code&gt;which&lt;/code&gt; parameter is identical to &lt;a href=&quot;#XopENTRY&quot;&gt;&quot;XopENTRY&quot;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="91cb14ad58a1b4462086f211195165ae13adba9c" translate="yes" xml:space="preserve">
          <source>Exactly like C:</source>
          <target state="translated">정확히 C와 같습니다.</target>
        </trans-unit>
        <trans-unit id="7525b0bc0e061494669779471f34623f62998790" translate="yes" xml:space="preserve">
          <source>Exactly what the</source>
          <target state="translated">정확히 무엇</target>
        </trans-unit>
        <trans-unit id="738aaf2dccc78981e8b455dca2a194bd2ca3770c" translate="yes" xml:space="preserve">
          <source>Exactly what were the failed locale settings varies. In the above the settings were that the LC_ALL was &quot;En_US&quot; and the LANG had no value. This error means that Perl detected that you and/or your operating system supplier and/or system administrator have set up the so-called locale system but Perl could not use those settings. This was not dead serious, fortunately: there is a &quot;default locale&quot; called &quot;C&quot; that Perl can and will use, and the script will be run. Before you really fix the problem, however, you will get the same error message each time you run Perl. How to really fix the problem can be found in &lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt; section &lt;b&gt;LOCALE PROBLEMS&lt;/b&gt;.</source>
          <target state="translated">실패한 로케일 설정은 정확히 다릅니다. 위의 설정은 LC_ALL이 &quot;En_US&quot;이고 LANG에 값이 없었습니다. 이 오류는 Perl이 사용자 및 / 또는 운영 체제 공급 업체 및 / 또는 시스템 관리자가 소위 로케일 시스템을 설정했지만 Perl이 해당 설정을 사용할 수 없음을 감지했음을 의미합니다. 다행스럽게도 이것은 죽지 않았습니다. Perl이 사용할 수 있고 사용할 스크립트 인 &quot;C&quot;라는 &quot;기본 로케일&quot;이 있으며 스크립트가 실행됩니다. 그러나 실제로 문제를 해결하기 전에 Perl을 실행할 때마다 동일한 오류 메시지가 나타납니다. 실제로 문제를 해결하는 방법은 &lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt; 섹션 &lt;b&gt;LOCALE &lt;/b&gt;PROBLEMS 에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d8b6b2bbc7b58a995a5244483a44038c0c9b80cc" translate="yes" xml:space="preserve">
          <source>Examine signals that are blocked and pending. This uses &lt;code&gt;POSIX::SigSet&lt;/code&gt; objects for the &lt;code&gt;sigset&lt;/code&gt; argument. Consult your system's &lt;code&gt;sigpending&lt;/code&gt; manpage for details.</source>
          <target state="translated">차단 및 보류중인 신호를 검사하십시오. 이 사용 &lt;code&gt;POSIX::SigSet&lt;/code&gt; 에 대한 객체 &lt;code&gt;sigset&lt;/code&gt; 의 인수. 자세한 내용은 시스템의 &lt;code&gt;sigpending&lt;/code&gt; 맨 페이지를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="9cc359cbd82e941e0ce6d56fc00bde6962483e78" translate="yes" xml:space="preserve">
          <source>Examines an op, which is expected to identify a subroutine at runtime, and attempts to determine at compile time which subroutine it identifies. This is normally used during Perl compilation to determine whether a prototype can be applied to a function call.</source>
          <target state="translated">런타임시 서브 루틴을 식별 할 것으로 예상되는 op를 검사하고 컴파일시 서브 루틴이 식별하는 서브 루틴을 판별하려고 시도합니다. 일반적으로 Perl 컴파일 중에 프로토 타입을 함수 호출에 적용 할 수 있는지 여부를 판별하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="2816ec163840831fe4101935d11468555274d9b0" translate="yes" xml:space="preserve">
          <source>Examines an op, which is expected to identify a subroutine at runtime, and attempts to determine at compile time which subroutine it identifies. This is normally used during Perl compilation to determine whether a prototype can be applied to a function call. &lt;code&gt;cvop&lt;/code&gt; is the op being considered, normally an &lt;code&gt;rv2cv&lt;/code&gt; op. A pointer to the identified subroutine is returned, if it could be determined statically, and a null pointer is returned if it was not possible to determine statically.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce88b50818f0436a7682c61cd164aaafa21bdd4b" translate="yes" xml:space="preserve">
          <source>Examines the value of EXPR, expecting it to be a reference, and returns a string giving information about the reference and the type of referent. If EXPR is not specified, &lt;a href=&quot;perlvar#%24_&quot;&gt;&lt;code&gt;$_&lt;/code&gt;&lt;/a&gt; will be used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21009b11f09e3868b5cd364062bd16a01cd87baf" translate="yes" xml:space="preserve">
          <source>Examining internal data structures with the &lt;code&gt;&lt;a href=&quot;functions/dump&quot;&gt;dump&lt;/a&gt;&lt;/code&gt; functions</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/dump&quot;&gt;dump&lt;/a&gt;&lt;/code&gt; 함수를 사용하여 내부 데이터 구조 검사</target>
        </trans-unit>
        <trans-unit id="1f9b5ae7207832dd1764b8c81e77154d27039133" translate="yes" xml:space="preserve">
          <source>Examining internal data structures with the &lt;code&gt;dump&lt;/code&gt; functions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e9d648412ff129c07a7aa241744818aaa63c13b" translate="yes" xml:space="preserve">
          <source>Examining internal data structures with the dump functions</source>
          <target state="translated">덤프 함수를 사용하여 내부 데이터 구조 검사</target>
        </trans-unit>
        <trans-unit id="f25587ebeed31098679dd0a945296052447509f8" translate="yes" xml:space="preserve">
          <source>Examining the tree</source>
          <target state="translated">나무 검사</target>
        </trans-unit>
        <trans-unit id="0f01ed56a1e32a05e5ef96e4d779f34784af9a96" translate="yes" xml:space="preserve">
          <source>Example</source>
          <target state="translated">Example</target>
        </trans-unit>
        <trans-unit id="3ee687a4836f2979219916954f4addd8522f2875" translate="yes" xml:space="preserve">
          <source>Example - a Hexadecimal Handle</source>
          <target state="translated">예-16 진 핸들</target>
        </trans-unit>
        <trans-unit id="6dcd3f46d09547b62bf07ba9b2943c95d53ddae3" translate="yes" xml:space="preserve">
          <source>Example 1</source>
          <target state="translated">실시 예 1</target>
        </trans-unit>
        <trans-unit id="d64751054e2d27b855282a556af039128d434ede" translate="yes" xml:space="preserve">
          <source>Example 1: A simple filter.</source>
          <target state="translated">예 1 : 간단한 필터.</target>
        </trans-unit>
        <trans-unit id="1c56ea49918b9baed94cf4bc0ee9f324efc8841a" translate="yes" xml:space="preserve">
          <source>Example 2</source>
          <target state="translated">실시 예 2</target>
        </trans-unit>
        <trans-unit id="c9ff53c2379b7cde740f23e7a5efd8af7e83e70f" translate="yes" xml:space="preserve">
          <source>Example 2: Using the context</source>
          <target state="translated">예 2 : 컨텍스트 사용</target>
        </trans-unit>
        <trans-unit id="fbf4dab701189a344fa5ab06d7b87c11a74e3da0" translate="yes" xml:space="preserve">
          <source>Example 3</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="93fa8f292e6f2e8759c24edf270a2f53c96a1766" translate="yes" xml:space="preserve">
          <source>Example 3: Using the context within the filter</source>
          <target state="translated">예 3 : 필터 내에서 컨텍스트 사용</target>
        </trans-unit>
        <trans-unit id="39e8f452734bc5ce3b169811da6ab1984a676dbf" translate="yes" xml:space="preserve">
          <source>Example 4: Using filter_del</source>
          <target state="translated">예 4 : filter_del 사용</target>
        </trans-unit>
        <trans-unit id="82dd29f8b1cca5a0b9d8a8b5b47aff607b15559f" translate="yes" xml:space="preserve">
          <source>Example Distroprefs Files</source>
          <target state="translated">Distroprefs 파일 예</target>
        </trans-unit>
        <trans-unit id="1a2aefe8979aba9b8da50d2227d60de10fe393b6" translate="yes" xml:space="preserve">
          <source>Example corrected to show map of maps instead of list of maps (though descriptive text said 'map' even in v1.3)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1479866f8111c0730b394a4d0e54b9686736ec4" translate="yes" xml:space="preserve">
          <source>Example hints</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c67a372e04bf6d9b9e0054bc94bbe354f79d761" translate="yes" xml:space="preserve">
          <source>Example implementation might be:</source>
          <target state="translated">구현 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="65cdc590a56f144422e8ab9d8551b4654f6b8393" translate="yes" xml:space="preserve">
          <source>Example of use of &lt;code&gt;%m&lt;/code&gt; :</source>
          <target state="translated">&lt;code&gt;%m&lt;/code&gt; 사용 예 :</target>
        </trans-unit>
        <trans-unit id="1e6115c04f6e10d5d5d6b87e30e1b6023acf08e4" translate="yes" xml:space="preserve">
          <source>Example of use of &lt;code&gt;%m&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec471d84b36457f0d9d75c03377c9e3cd5f3de93" translate="yes" xml:space="preserve">
          <source>Example of use:</source>
          <target state="translated">사용 예 :</target>
        </trans-unit>
        <trans-unit id="ea87c9b65b6478fdd7882c8529d632b267f39539" translate="yes" xml:space="preserve">
          <source>Example similar to MAN1PODS.</source>
          <target state="translated">MAN1PODS와 유사한 예.</target>
        </trans-unit>
        <trans-unit id="5ab7721397827b925456d2a147cb5704105a62a7" translate="yes" xml:space="preserve">
          <source>Example usage:</source>
          <target state="translated">사용법 예 :</target>
        </trans-unit>
        <trans-unit id="6f46925524d1c01021e97594cd0f9813ff23d01d" translate="yes" xml:space="preserve">
          <source>Example wrapper function, using a custom stacktrace:</source>
          <target state="translated">사용자 정의 스택 추적을 사용하는 래퍼 함수 예제 :</target>
        </trans-unit>
        <trans-unit id="917f746ede8d074c95df4b99d59d955a898465de" translate="yes" xml:space="preserve">
          <source>Example, convert all JSON objects into the integer 5:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38a0b26277d048bcac5dd947ecabce4cb52276c3" translate="yes" xml:space="preserve">
          <source>Example, decode JSON objects of the form &lt;code&gt;{ &quot;__widget__&quot; =&amp;gt; &amp;lt;id&amp;gt; }&lt;/code&gt; into the corresponding &lt;code&gt;$WIDGET{&amp;lt;id&amp;gt;}&lt;/code&gt; object:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7278e6c050b8c04dedcbda9af1550657a42fb4fe" translate="yes" xml:space="preserve">
          <source>Example, decode UTF-32LE-encoded JSON:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bfdc025886948570c6fbbadab1e6327c7c909d59" translate="yes" xml:space="preserve">
          <source>Example, encode a Perl scalar as JSON value without enabled &lt;code&gt;allow_nonref&lt;/code&gt;, resulting in an error:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ed5be0c52bbf20defd0c9e845ecf60ed4c32045" translate="yes" xml:space="preserve">
          <source>Example, output UTF-16BE-encoded JSON:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70eed4e935f1e0e0b91352974e074471d01f2095" translate="yes" xml:space="preserve">
          <source>Example, space_before and indent disabled, space_after enabled:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b78e4fad7b27510e9dff599bdcd34d99787fce83" translate="yes" xml:space="preserve">
          <source>Example, space_before enabled, space_after and indent disabled:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21504e5520a63c06708e793261e7989f6e598670" translate="yes" xml:space="preserve">
          <source>Example.pm</source>
          <target state="translated">Example.pm</target>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="2f9aab2ce8a7f69580f3ffba5062983af60212df" translate="yes" xml:space="preserve">
          <source>Example: &lt;code&gt;0.16&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d1b656e9d62a39986b515e970fb598d7c6a0a28" translate="yes" xml:space="preserve">
          <source>Example: &lt;code&gt;0&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d065a1b59988aa6c329900c3cada65931aeef53b" translate="yes" xml:space="preserve">
          <source>Example: &lt;code&gt;Module-Build&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="723a51aade7b3dfa260aa71d4fea09d109817345" translate="yes" xml:space="preserve">
          <source>Example: &lt;code&gt;Module::Build version 0.16&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fcb81d7d81b9c7defbedc3997e69a4b739f84df6" translate="yes" xml:space="preserve">
          <source>Example: &lt;code&gt;module&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="118e06607524b497bf1e00dd9542fcda25763c44" translate="yes" xml:space="preserve">
          <source>Example: &lt;code&gt;perl&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cad6ecdc1416c4a99a21cafbb2b565e4a7ce52ac" translate="yes" xml:space="preserve">
          <source>Example: Altering Concise Renderings</source>
          <target state="translated">예 : 간결한 렌더링 변경</target>
        </trans-unit>
        <trans-unit id="e9234fbd94650af302f3c53c866ca9eab6d98b89" translate="yes" xml:space="preserve">
          <source>Example: At the command prompt Type &quot;nmake nwinstall&quot;. This will install NetWare Perl on the NetWare Server. Similarly, if you type &quot;nmake install&quot;, this will cause the binaries to be installed on the local machine. (Typically under the c:\perl folder)</source>
          <target state="translated">예 : 명령 프롬프트에서 &quot;nmake nwinstall&quot;을 입력하십시오. NetWare 서버에 NetWare Perl을 설치합니다. 마찬가지로 &quot;nmake install&quot;을 입력하면 이진 파일이 로컬 컴퓨터에 설치됩니다. (일반적으로 c : \ perl 폴더 아래)</target>
        </trans-unit>
        <trans-unit id="24e5d3a101404316459c21180a1f55d046da675c" translate="yes" xml:space="preserve">
          <source>Example: Encode::ROT13</source>
          <target state="translated">예 : Encode :: ROT13</target>
        </trans-unit>
        <trans-unit id="d0830c89a9652382868513b8862db0a3cc84254e" translate="yes" xml:space="preserve">
          <source>Example: Parse some JSON arrays/objects in a given string and return them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0721ccbd9aaee85c90df176a3976ea110912494f" translate="yes" xml:space="preserve">
          <source>Example: The following code</source>
          <target state="translated">예 : 다음 코드</target>
        </trans-unit>
        <trans-unit id="57772da1cf0c7d363a78ec1c7ba403554cdf5105" translate="yes" xml:space="preserve">
          <source>Example: You can execute the following on the command prompt.</source>
          <target state="translated">예 : 명령 프롬프트에서 다음을 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f2749017763b820ec8a5aab014519f7d7e9831d5" translate="yes" xml:space="preserve">
          <source>Example: base64 transcoder</source>
          <target state="translated">예 : base64 트랜스 코더</target>
        </trans-unit>
        <trans-unit id="eb01bf04c9a0e8a71c45816513df424f1c7ffedb" translate="yes" xml:space="preserve">
          <source>Examples</source>
          <target state="translated">Examples</target>
        </trans-unit>
        <trans-unit id="1d7dd2b19077ebadaa57d2f6ba2c64d87037ae05" translate="yes" xml:space="preserve">
          <source>Examples (assuming an ASCII platform)</source>
          <target state="translated">예 (ASCII 플랫폼 가정)</target>
        </trans-unit>
        <trans-unit id="47370b8eea1efa5172e76cf237bd26e7f736ebd6" translate="yes" xml:space="preserve">
          <source>Examples for converting:</source>
          <target state="translated">변환의 예 :</target>
        </trans-unit>
        <trans-unit id="386c7abd2323831ffe2716ae79487fcd14a21d5e" translate="yes" xml:space="preserve">
          <source>Examples for rounding:</source>
          <target state="translated">반올림의 예 :</target>
        </trans-unit>
        <trans-unit id="49d15bdd087c216bc7ae6d4ea03d99c8cec52e40" translate="yes" xml:space="preserve">
          <source>Examples in documentation should be illustrative of the concept they're explaining. Sometimes, the best way to show how a language feature works is with a small program the reader can run without modification. More often, examples will consist of a snippet of code containing only the &quot;important&quot; bits. The definition of &quot;important&quot; varies from snippet to snippet. Sometimes it's important to declare &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings&lt;/code&gt; , initialize all variables and fully catch every error condition. More often than not, though, those things obscure the lesson the example was intended to teach.</source>
          <target state="translated">문서의 예는 설명하는 개념을 설명해야합니다. 언어 기능의 작동 방식을 보여주는 가장 좋은 방법은 독자가 수정하지 않고도 실행할 수있는 작은 프로그램을 사용하는 것입니다. 더 자주, 예제는 &quot;중요한&quot;비트 만 포함하는 코드 스 니펫으로 구성됩니다. &quot;중요&quot;의 정의는 스 니펫마다 다릅니다. 때때로 선언하는 것이 중요합니다 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings&lt;/code&gt; , 모든 변수를 초기화하고 완벽하게 모든 오류 상태를 잡을 수있어. 그러나 종종 그러한 것들은 본 모범이 가르치고 자하는 교훈을 모호하게합니다.</target>
        </trans-unit>
        <trans-unit id="d11119ca6453ac0e54148249adca86e00f07f1e8" translate="yes" xml:space="preserve">
          <source>Examples in documentation should be illustrative of the concept they're explaining. Sometimes, the best way to show how a language feature works is with a small program the reader can run without modification. More often, examples will consist of a snippet of code containing only the &quot;important&quot; bits. The definition of &quot;important&quot; varies from snippet to snippet. Sometimes it's important to declare &lt;code&gt;use strict&lt;/code&gt; and &lt;code&gt;use warnings&lt;/code&gt;, initialize all variables and fully catch every error condition. More often than not, though, those things obscure the lesson the example was intended to teach.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a591376177b86768f6394133fb691d5a829d17d6" translate="yes" xml:space="preserve">
          <source>Examples of invalid syntax:</source>
          <target state="translated">유효하지 않은 구문의 예 :</target>
        </trans-unit>
        <trans-unit id="0d4621bd6639238b0ab788dd2cc321e39c7fc192" translate="yes" xml:space="preserve">
          <source>Examples of legal names are '$foo' for a scalar, '@foo' for an array, '%foo' for a hash, '&amp;amp;foo' or 'foo' for a subroutine and '*foo' for a glob (i.e. all symbol table entries associated with &quot;foo&quot;, including scalar, array, hash, sub and filehandle).</source>
          <target state="translated">유효한 이름의 예는 스칼라의 경우 '$ foo', 배열의 경우 '@foo', 해시의 경우 '% foo', 서브 루틴의 경우 '&amp;amp; foo'또는 'foo', 글로브의 경우 '* foo'입니다 (예 : 모두 스칼라, 배열, 해시, 서브 및 파일 핸들을 포함하여 &quot;foo&quot;와 연관된 기호 테이블 항목).</target>
        </trans-unit>
        <trans-unit id="d7c5ae33ac348a4d6e7614da1b0d7da380e1b269" translate="yes" xml:space="preserve">
          <source>Examples of use</source>
          <target state="translated">사용 예</target>
        </trans-unit>
        <trans-unit id="1a5dea85313337dc5454525e91430329e3b9eb0f" translate="yes" xml:space="preserve">
          <source>Examples of valid syntax (even though the attributes are unknown):</source>
          <target state="translated">유효한 구문의 예 (속성을 알 수는 없지만) :</target>
        </trans-unit>
        <trans-unit id="45b39bd436c5d9cd8f4ca9dd2c7eb59c66eb58b2" translate="yes" xml:space="preserve">
          <source>Examples section another documentation provided by John Heidemann &amp;lt;johnh@ISI.EDU&amp;gt;</source>
          <target state="translated">예제는 John Heidemann &amp;lt;johnh@ISI.EDU&amp;gt;에서 제공하는 다른 문서 섹션</target>
        </trans-unit>
        <trans-unit id="628a5608e1a43ca4bfb86500d847d49e2edd6c80" translate="yes" xml:space="preserve">
          <source>Examples where callbacks are necessary include</source>
          <target state="translated">콜백이 필요한 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="fb3447b632f6a431215776dcf254a01001a40c4f" translate="yes" xml:space="preserve">
          <source>Examples:</source>
          <target state="translated">Examples:</target>
        </trans-unit>
        <trans-unit id="f98a53c84b8d27c6aba2afa49d1eb4984f22de98" translate="yes" xml:space="preserve">
          <source>Examples: &quot;[_1]&quot; and &quot;[,_1]&quot;, which are synonymous; and &quot;&lt;code&gt;[,ID-(,_4,-,_2,)]&lt;/code&gt; &quot;, which compiles as &lt;code&gt;&lt;a href=&quot;../functions/join&quot;&gt;join&lt;/a&gt; &quot;&quot;, &quot;ID-(&quot;, $_[4], &quot;-&quot;, $_[2], &quot;)&quot;&lt;/code&gt; .</source>
          <target state="translated">예 : 동의어 인 &quot;[_1]&quot;및 &quot;[, _1]&quot;; &lt;code&gt;&lt;a href=&quot;../functions/join&quot;&gt;join&lt;/a&gt; &quot;&quot;, &quot;ID-(&quot;, $_[4], &quot;-&quot;, $_[2], &quot;)&quot;&lt;/code&gt; &lt;a href=&quot;../functions/join&quot;&gt;조인으로&lt;/a&gt; 컴파일되는 &quot; &lt;code&gt;[,ID-(,_4,-,_2,)]&lt;/code&gt; &quot; .</target>
        </trans-unit>
        <trans-unit id="0be9a5482bf17e8c5fe99a02aec7a8cea84f74f4" translate="yes" xml:space="preserve">
          <source>Examples: &quot;[_1]&quot; and &quot;[,_1]&quot;, which are synonymous; and &quot;&lt;code&gt;[,ID-(,_4,-,_2,)]&lt;/code&gt;&quot;, which compiles as &lt;code&gt;join &quot;&quot;, &quot;ID-(&quot;, $_[4], &quot;-&quot;, $_[2], &quot;)&quot;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc4e742ff692e5060c86af7b99c37b81006ce99b" translate="yes" xml:space="preserve">
          <source>Except &lt;code&gt;(normalization =&amp;gt; &lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;)&lt;/code&gt; , &lt;b&gt;Unicode::Normalize&lt;/b&gt; is required (see also &lt;b&gt;CAVEAT&lt;/b&gt;).</source>
          <target state="translated">제외 &lt;code&gt;(normalization =&amp;gt; &lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;)&lt;/code&gt; , &lt;b&gt;유니 :: 정규화가&lt;/b&gt; 필요 (참고 &lt;b&gt;주의를&lt;/b&gt; ).</target>
        </trans-unit>
        <trans-unit id="750b06c4e20cd4bb5392f789eb453ec81bdf0ee9" translate="yes" xml:space="preserve">
          <source>Except &lt;code&gt;(normalization =&amp;gt; undef)&lt;/code&gt;, &lt;b&gt;Unicode::Normalize&lt;/b&gt; is required (see also &lt;b&gt;CAVEAT&lt;/b&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9a44f67c097a553bfa410868c60dd16cabf490e" translate="yes" xml:space="preserve">
          <source>Except being faster.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f7f15d16385003ab5d07150052df64664c66bff" translate="yes" xml:space="preserve">
          <source>Except for &lt;a href=&quot;#The-Basics&quot;&gt;&quot;The Basics&quot;&lt;/a&gt; section, this page assumes you are familiar with regular expression basics, like what is a &quot;pattern&quot;, what does it look like, and how it is basically used. For a reference on how they are used, plus various examples of the same, see discussions of &lt;code&gt;m//&lt;/code&gt;, &lt;code&gt;s///&lt;/code&gt;, &lt;code&gt;qr//&lt;/code&gt; and &lt;code&gt;&quot;??&quot;&lt;/code&gt; in &lt;a href=&quot;perlop#Regexp-Quote-Like-Operators&quot;&gt;&quot;Regexp Quote-Like Operators&quot; in perlop&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26b1235f5e6dc422681dc01e8714586f7ad38364" translate="yes" xml:space="preserve">
          <source>Except for &lt;code&gt;FILTER_ONLY code =&amp;gt; &lt;a href=&quot;../functions/sub&quot;&gt;sub&lt;/a&gt; {...}&lt;/code&gt; , each of the component filters is called repeatedly, once for each component found in the source code.</source>
          <target state="translated">&lt;code&gt;FILTER_ONLY code =&amp;gt; &lt;a href=&quot;../functions/sub&quot;&gt;sub&lt;/a&gt; {...}&lt;/code&gt; 제외하고 각 구성 요소 필터는 소스 코드에서 찾은 각 구성 요소마다 한 번씩 반복적으로 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="4893191369665d6053617936c829c46737cadf4b" translate="yes" xml:space="preserve">
          <source>Except for &lt;code&gt;FILTER_ONLY code =&amp;gt; sub {...}&lt;/code&gt;, each of the component filters is called repeatedly, once for each component found in the source code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21a10e7180b4b8a76ea58d012850b5f1c4bcb634" translate="yes" xml:space="preserve">
          <source>Except importing the functions, 'autoload' is same as 'load'.</source>
          <target state="translated">함수 가져 오기를 제외하고 'autoload'는 'load'와 동일합니다.</target>
        </trans-unit>
        <trans-unit id="18f4bd6df6292a6b95734ee2a00973430550afe7" translate="yes" xml:space="preserve">
          <source>Except specifing the package and quoting module name, 'autoload_remote' is same as 'load_remote'.</source>
          <target state="translated">패키지 지정 및 모듈 이름 인용을 제외하고 'autoload_remote'는 'load_remote'와 동일합니다.</target>
        </trans-unit>
        <trans-unit id="16e04cb1bb937a46789e35dba24fd14a5feb954d" translate="yes" xml:space="preserve">
          <source>Except specifing the package and quoting module name, 'load_remote' is same as 'load'.</source>
          <target state="translated">패키지 지정 및 모듈 이름 인용을 제외하고 'load_remote'는 'load'와 동일합니다.</target>
        </trans-unit>
        <trans-unit id="f55cf6c06e02d10efcfcfb37efbd0c881f531275" translate="yes" xml:space="preserve">
          <source>Excepting those listed above, we're currently unable to guarantee that B::Deparse will produce a pragma at the correct point in the program. (Specifically, pragmas at the beginning of a block often appear right before the start of the block instead.) Since the effects of pragmas are often lexically scoped, this can mean that the pragma holds sway over a different portion of the program than in the input file.</source>
          <target state="translated">위에 나열된 것을 제외하고는 현재 B :: Deparse가 프로그램의 올바른 지점에서 pragma를 생성한다고 보장 할 수 없습니다. (구체적으로, 블록의 시작 부분에있는 pragma는 종종 대신에 블록의 시작 직전에 나타납니다.) pragma의 효과는 어휘 범위가 있기 때문에 pragma는 입력 파일.</target>
        </trans-unit>
        <trans-unit id="20788aa11834509830be30396b88f6404f087e8c" translate="yes" xml:space="preserve">
          <source>Exception Handling</source>
          <target state="translated">예외 처리</target>
        </trans-unit>
        <trans-unit id="826f288dbfc038dead10724f69465c1bfe17a68f" translate="yes" xml:space="preserve">
          <source>Exception Handling (simple) Macros</source>
          <target state="translated">예외 처리 (단순) 매크로</target>
        </trans-unit>
        <trans-unit id="c63dbeff42b8bdcfbb58c593ff1bf6b1c3d8a3ca" translate="yes" xml:space="preserve">
          <source>Exception class used by</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4a349dc2d7ddd050d57ee72af0506a4a2b31cc9" translate="yes" xml:space="preserve">
          <source>Exception event</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa345b763368fc4f9065828d77e9729e19d258cc" translate="yes" xml:space="preserve">
          <source>Exception handing</source>
          <target state="translated">예외 처리</target>
        </trans-unit>
        <trans-unit id="3ab46cd93f74baf3da5f557d5f2997aae41ff3b1" translate="yes" xml:space="preserve">
          <source>Exceptions from &lt;code&gt;max_size&lt;/code&gt;, &lt;code&gt;timeout&lt;/code&gt; or other errors will result in a pseudo-HTTP status code of 599 and a reason of &quot;Internal Exception&quot;. The content field in the response will contain the text of the exception.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d504b2a99c5e1f8d7e7350318f686e5cbee7a60e" translate="yes" xml:space="preserve">
          <source>Exceptions from autodying functions.</source>
          <target state="translated">자동 염색 기능의 예외.</target>
        </trans-unit>
        <trans-unit id="1242bf8dd433a51fa4c19b0e3a208b834c9fc265" translate="yes" xml:space="preserve">
          <source>Exceptions from autodying system().</source>
          <target state="translated">autodying system ()의 예외.</target>
        </trans-unit>
        <trans-unit id="48741c44a476b90391e45eac22eeaa9b0d399fee" translate="yes" xml:space="preserve">
          <source>Exceptions produced by the &lt;code&gt;autodie&lt;/code&gt; pragma are members of the &lt;a href=&quot;autodie/exception&quot;&gt;autodie::exception&lt;/a&gt; class. The preferred way to work with these exceptions under Perl 5.10 is as follows:</source>
          <target state="translated">&lt;code&gt;autodie&lt;/code&gt; pragma에 의해 생성 된 예외 는 &lt;a href=&quot;autodie/exception&quot;&gt;autodie :: exception&lt;/a&gt; 클래스의 멤버입니다 . Perl 5.10에서 이러한 예외를 처리하는 기본 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="53d59c8491a17793e5a74a9328b1458c0ce10dc9" translate="yes" xml:space="preserve">
          <source>Exceptions produced by the &lt;code&gt;autodie&lt;/code&gt; pragma are members of the &lt;a href=&quot;autodie::exception&quot;&gt;autodie::exception&lt;/a&gt; class. The preferred way to work with these exceptions under Perl 5.10 is as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5986414d0fc4bb9c4ee5d8198af90a5eb243568c" translate="yes" xml:space="preserve">
          <source>Exceptions, error return codes, exit statuses, and errno settings. Typically used for function or module documentation; program documentation uses DIAGNOSTICS instead. The general rule of thumb is that errors printed to &lt;code&gt;STDOUT&lt;/code&gt; or &lt;code&gt;STDERR&lt;/code&gt; and intended for the end user are documented in DIAGNOSTICS while errors passed internal to the calling program and intended for other programmers are documented in ERRORS. When documenting a function that sets errno, a full list of the possible errno values should be given here.</source>
          <target state="translated">예외, 오류 리턴 코드, 종료 상태 및 errno 설정. 일반적으로 기능 또는 모듈 문서에 사용됩니다. 프로그램 설명서는 대신 DIAGNOSTICS를 사용합니다. 일반적으로 &lt;code&gt;STDOUT&lt;/code&gt; 또는 &lt;code&gt;STDERR&lt;/code&gt; 로 인쇄되고 최종 사용자를위한 오류는 진단에 문서화되고 호출 프로그램 내부에 전달 된 오류는 다른 프로그래머에 대한 오류는 오류에 문서화됩니다. errno를 설정하는 함수를 문서화 할 때 가능한 errno 값의 전체 목록을 여기에 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="3e8ef9fa750a38a235f6f5db2c10f6d27bcf66b2" translate="yes" xml:space="preserve">
          <source>Excessive pride, the sort of thing for which Zeus zaps you. Also the quality that makes you write (and maintain) programs that other people won&amp;rsquo;t want to say bad things about. Hence, the third great virtue of a programmer. See also &lt;b&gt;laziness&lt;/b&gt; and &lt;b&gt;impatience&lt;/b&gt;.</source>
          <target state="translated">과도한 자부심, 제우스가 당신을 za 거리는 것. 또한 다른 사람들이 나쁜 말을하고 싶지 않은 프로그램을 작성하고 유지하게하는 품질. 따라서 프로그래머의 세 번째 미덕. &lt;b&gt;게으름&lt;/b&gt; 과 &lt;b&gt;조바심&lt;/b&gt; 참조 .</target>
        </trans-unit>
        <trans-unit id="a5d912f09e4af174aa651a0745dc7cd68fcf8fd2" translate="yes" xml:space="preserve">
          <source>Excessively long &amp;lt;&amp;gt; operator</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ff53c1a7c6e7525075531f3d6b8357745fac262" translate="yes" xml:space="preserve">
          <source>Exchanging signed integers between different platforms works only when all platforms store them in the same format. Most platforms store signed integers in two's-complement notation, so usually this is not an issue.</source>
          <target state="translated">다른 플랫폼간에 부호있는 정수 교환은 모든 플랫폼이 동일한 형식으로 저장 한 경우에만 작동합니다. 대부분의 플랫폼은 부호있는 정수를 2의 보수 표기법으로 저장하므로 일반적으로 문제가되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6d598c708e755dc53aa35c070da1bc37864ef85e" translate="yes" xml:space="preserve">
          <source>Exclude the given routine and its descendants from the profile.</source>
          <target state="translated">지정된 루틴 및 해당 하위 항목을 프로파일에서 제외하십시오.</target>
        </trans-unit>
        <trans-unit id="712815e07d58e914b686a30fadb75309ce36dd4f" translate="yes" xml:space="preserve">
          <source>Excommunicated</source>
          <target state="translated">Excommunicated</target>
        </trans-unit>
        <trans-unit id="ce52f407fe57f7ce5f94a6ed1047c07eafabc89f" translate="yes" xml:space="preserve">
          <source>Executables for Perl utilities</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a8a72f8f7694a401a32218abd4406ae1d283fcc" translate="yes" xml:space="preserve">
          <source>Executables for gzip, zip, and VMStar:</source>
          <target state="translated">gzip, zip 및 VMStar의 실행 파일 :</target>
        </trans-unit>
        <trans-unit id="58de6b665842567beab85d292c3b5870de1c65ae" translate="yes" xml:space="preserve">
          <source>Execute a regexp. The arguments are</source>
          <target state="translated">정규 표현식을 실행하십시오. 논쟁은</target>
        </trans-unit>
        <trans-unit id="bac595ee7bf88de92060cce1abba1b3d844e6519" translate="yes" xml:space="preserve">
          <source>Execute command as a Perl statement. A trailing semicolon will be supplied. If the Perl statement would otherwise be confused for a Perl debugger, use a leading semicolon, too.</source>
          <target state="translated">Perl 문으로 명령을 실행하십시오. 후미 세미콜론이 제공됩니다. Perl 명령문이 Perl 디버거에 대해 혼동 될 경우 선행 세미콜론도 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="ec1ff77553768eb52e9d8af54796c7b0bfee25e2" translate="yes" xml:space="preserve">
          <source>Execute related options</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e45a9d6764cd8a4584e5070807ab16a657d631e8" translate="yes" xml:space="preserve">
          <source>Execute the following commands:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c456233f2824914a52bfceba7c1ea3f220aec8f" translate="yes" xml:space="preserve">
          <source>Execute the given C code and print its results. &lt;b&gt;WARNING&lt;/b&gt;: Perl makes heavy use of macros, and</source>
          <target state="translated">주어진 C 코드를 실행하고 결과를 인쇄하십시오. &lt;b&gt;경고&lt;/b&gt; : Perl은 매크로를 많이 사용하며</target>
        </trans-unit>
        <trans-unit id="9ac88dd7c0b19c435fb63cfe3bac19cbfc350e4d" translate="yes" xml:space="preserve">
          <source>Execute the provided install script from shell or via its icon.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="061e9bcfa95dc9f2f39332fda78eedc474b39569" translate="yes" xml:space="preserve">
          <source>Execute this statement for a hint about where to find CORE:</source>
          <target state="translated">CORE를 찾을 수있는 위치에 대한 힌트를 보려면이 명령문을 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="a79b5094cc2990d328a2ac30ea62e13817dec0a0" translate="yes" xml:space="preserve">
          <source>Executes a &lt;code&gt;GET&lt;/code&gt; request for the URL and saves the response body to the file name provided. The URL must have unsafe characters escaped and international domain names encoded. If the file already exists, the request will include an &lt;code&gt;If-Modified-Since&lt;/code&gt; header with the modification timestamp of the file. You may specify a different &lt;code&gt;If-Modified-Since&lt;/code&gt; header yourself in the &lt;code&gt;$options-&amp;gt;{headers}&lt;/code&gt; hash.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a2aff22989bc6aeac5d6cd7864aab55a4f7fed20" translate="yes" xml:space="preserve">
          <source>Executes an HTTP request of the given method type ('GET', 'HEAD', 'POST', 'PUT', etc.) on the given URL. The URL must have unsafe characters escaped and international domain names encoded.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="574f52d839fd11f8f8f4c4d0ddacf0528556159a" translate="yes" xml:space="preserve">
          <source>Executing a postponed regular expression 50 times without consuming any input string will result in a fatal error. The maximum depth is compiled into perl, so changing it requires a custom build.</source>
          <target state="translated">입력 문자열을 소비하지 않고 연기 된 정규 표현식을 50 번 실행하면 치명적인 오류가 발생합니다. 최대 깊이는 perl로 컴파일되므로이를 변경하려면 사용자 정의 빌드가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="92a60b45df076860f644e5d058a8c446b0d5be54" translate="yes" xml:space="preserve">
          <source>Executing a postponed regular expression too many times without consuming any input string will also result in a fatal error. The depth at which that happens is compiled into perl, so it can be changed with a custom build.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d525b71568c2d982f46feb96b332bedcdc6e4a0" translate="yes" xml:space="preserve">
          <source>Execution</source>
          <target state="translated">Execution</target>
        </trans-unit>
        <trans-unit id="13709dfa0128b531e84d0b60f2a2419c6bf04dbf" translate="yes" xml:space="preserve">
          <source>Execution of END blocks</source>
          <target state="translated">END 블록의 실행</target>
        </trans-unit>
        <trans-unit id="675e718a6b33ba2b7929f770db612d9a80f9b87e" translate="yes" xml:space="preserve">
          <source>Execution of a regex generally involves two phases, the first being finding the start point in the string where we should match from, and the second being running the regop interpreter.</source>
          <target state="translated">정규식의 실행에는 일반적으로 두 단계가 포함되는데, 첫 번째 단계는 일치해야하는 문자열에서 시작점을 찾고 두 번째 단계는 정규표 해석기를 실행합니다.</target>
        </trans-unit>
        <trans-unit id="119f08e3cf8da3d7fe34ab1131df979eb14179b1" translate="yes" xml:space="preserve">
          <source>Execution of any &lt;code&gt;CHECK&lt;/code&gt; blocks.</source>
          <target state="translated">모든 &lt;code&gt;CHECK&lt;/code&gt; 블록의 실행</target>
        </trans-unit>
        <trans-unit id="0603019ab35ef11320acde0ed06d6533404cfee9" translate="yes" xml:space="preserve">
          <source>Execution of any &lt;code&gt;END&lt;/code&gt; blocks.</source>
          <target state="translated">모든 &lt;code&gt;END&lt;/code&gt; 블록의 실행</target>
        </trans-unit>
        <trans-unit id="f4f82800233d6c7223698c2e187aa3ccc7d2dc01" translate="yes" xml:space="preserve">
          <source>Execution of the interpreter itself used to be recursive, but thanks to the efforts of Dave Mitchell in the 5.9.x development track, that has changed: now an internal stack is maintained on the heap and the routine is fully iterative. This can make it tricky as the code is quite conservative about what state it stores, with the result that two consecutive lines in the code can actually be running in totally different contexts due to the simulated recursion.</source>
          <target state="translated">인터프리터 자체의 실행은 재귀 적이지만 5.9.x 개발 트랙에서 Dave Mitchell의 노력 덕분에 변경되었습니다. 이제 내부 스택이 힙에 유지되고 루틴은 완전히 반복됩니다. 이것은 코드가 저장하는 상태에 대해 코드가 상당히 보수적이기 때문에 까다로울 수 있으며, 결과적으로 코드의 두 개의 연속 라인이 시뮬레이션 된 재귀로 인해 완전히 다른 컨텍스트에서 실제로 실행될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4e9f10726faddb4d512801b20f95c6f56436cea8" translate="yes" xml:space="preserve">
          <source>Exercises the C function of the same name in scalar context. Returns the same SV that the C function returns.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4dc06ef2194671cce285095b6f928f8f2f608822" translate="yes" xml:space="preserve">
          <source>Exercises the C function of the same name. Returns nothing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="248b9fcc2702356b63c40509208ebb73f559ce07" translate="yes" xml:space="preserve">
          <source>Exhaustive information on the topic of references can be found in &lt;a href=&quot;perlreftut&quot;&gt;perlreftut&lt;/a&gt;, &lt;a href=&quot;perllol&quot;&gt;perllol&lt;/a&gt;, &lt;a href=&quot;perlref&quot;&gt;perlref&lt;/a&gt; and &lt;a href=&quot;perldsc&quot;&gt;perldsc&lt;/a&gt;.</source>
          <target state="translated">참고 주제에 대한 &lt;a href=&quot;perlreftut&quot;&gt;완전한 정보&lt;/a&gt; 는 perlreftut , &lt;a href=&quot;perllol&quot;&gt;perllol&lt;/a&gt; , &lt;a href=&quot;perlref&quot;&gt;perlref&lt;/a&gt; 및 &lt;a href=&quot;perldsc&quot;&gt;perldsc&lt;/a&gt; 에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="76b5089ada110a0136449f09bf11c2275168e2c5" translate="yes" xml:space="preserve">
          <source>Existing 32 bit apps are properly known as LP32, i.e. Longs and Pointers are 32 bit. 64-bit apps are more properly known as LP64. The discriminating feature of a LP64 bit app is its ability to utilise a 64-bit address space. It is perfectly possible to have a LP32 bit app that supports both 64-bit integers (long long) and largefiles (&amp;gt; 2GB), and this is the default for perl-5.6.0.</source>
          <target state="translated">기존 32 비트 앱은 LP32로 올바르게 알려져 있습니다. 즉 Longs 및 Pointers는 32 비트입니다. 64 비트 앱은 LP64로 더 잘 알려져 있습니다. LP64 비트 앱의 차별화 된 기능은 64 비트 주소 공간을 활용하는 기능입니다. 64 비트 정수 (long long)와 큰 파일 (&amp;gt; 2GB)을 모두 지원하는 LP32 비트 앱을 사용하는 것이 가능하며 이는 perl-5.6.0의 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="3ce132dcaab82a474dd839ab951c3eef1631d645" translate="yes" xml:space="preserve">
          <source>Existing syntax and semantics should only be marked for destruction in very limited circumstances. If they are believed to be very rarely used, stand in the way of actual improvement to the Perl language or perl interpreter, and if affected code can be easily updated to continue working, they may be considered for removal. When in doubt, caution dictates that we will favor backward compatibility. When a feature is deprecated, a statement of reasoning describing the decision process will be posted, and a link to it will be provided in the relevant perldelta documents.</source>
          <target state="translated">기존 구문과 의미는 매우 제한된 상황에서만 파기되어야합니다. 그것들이 매우 드물게 사용되는 것으로 여겨지면, Perl 언어 또는 perl 인터프리터를 실제로 개선하는 방식으로 서십시오. 영향을받는 코드를 계속 업데이트하기 위해 쉽게 업데이트 할 수 있다면 제거를 고려할 수 있습니다. 확실하지 않은 경우, 이전 버전과의 호환성을 선호 할 것입니다. 기능이 더 이상 사용되지 않으면 의사 결정 프로세스를 설명하는 추론 진술이 게시되고 관련 perldelta 문서에 해당 기능에 대한 링크가 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="6d9d19533b0fbf724f69a3d7a99a413b54990645" translate="yes" xml:space="preserve">
          <source>Exit Code</source>
          <target state="translated">종료 코드</target>
        </trans-unit>
        <trans-unit id="45d746a8ea75007a4818f4a9a13d84ba46bc8da2" translate="yes" xml:space="preserve">
          <source>Exiting eval via %s</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc760fc51ed4d60f1f58db324e3b3ab5637ff7f6" translate="yes" xml:space="preserve">
          <source>Exiting format via %s</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d6b6283c09f2fd4cd4d37232a60ec674d66805a" translate="yes" xml:space="preserve">
          <source>Exiting pseudo-block via %s</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08a99dd93f7907c63d9f314a53349298ea450b60" translate="yes" xml:space="preserve">
          <source>Exiting subroutine via %s</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eedf12ff192cfbfe7957d4a6c26105640adbff0b" translate="yes" xml:space="preserve">
          <source>Exiting substitution via %s</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d71626cd31b069ac3980d7ed6a6abb80f71225a3" translate="yes" xml:space="preserve">
          <source>Exits</source>
          <target state="translated">Exits</target>
        </trans-unit>
        <trans-unit id="bc031d65eaef8ccada69a0c994a430a53a41354d" translate="yes" xml:space="preserve">
          <source>Exotic Templates</source>
          <target state="translated">이국적인 템플릿</target>
        </trans-unit>
        <trans-unit id="2c6c990ee216fb59d7ad72ee8d28ebcceeb5a21e" translate="yes" xml:space="preserve">
          <source>Expand and unexpand tabs like unix expand(1) and unexpand(1)</source>
          <target state="translated">unix expand (1) 및 unexpand (1)와 같은 탭 펼치기 및 펼치기</target>
        </trans-unit>
        <trans-unit id="2b116400884e9dbc3a5bf5fe94b7d6faa8b0dd38" translate="yes" xml:space="preserve">
          <source>Expand conventional syntax constructions into equivalent ones that expose their internal operation.</source>
          <target state="translated">기존 구문 구조를 내부 조작을 노출시키는 동등한 구문 구조로 확장하십시오.</target>
        </trans-unit>
        <trans-unit id="a24145087edc62ad61c2e0e0ed9777002b6b1d94" translate="yes" xml:space="preserve">
          <source>Expand double-quoted strings into the corresponding combinations of concatenation, uc, ucfirst, lc, lcfirst, quotemeta, and join. For instance, print</source>
          <target state="translated">큰 따옴표로 묶은 문자열을 연결, uc, ucfirst, lc, lcfirst, quotemeta 및 join의 해당 조합으로 확장하십시오. 예를 들어, 인쇄</target>
        </trans-unit>
        <trans-unit id="a3cec9741cec0dca8594001a6d2ea842476ee2ac" translate="yes" xml:space="preserve">
          <source>Expand patterns that start with '~' to user name home directories.</source>
          <target state="translated">'~'로 시작하는 패턴을 사용자 이름 홈 디렉토리로 확장하십시오.</target>
        </trans-unit>
        <trans-unit id="6b6e1cee8dd20e696133457bd5f5a86ddd470c1e" translate="yes" xml:space="preserve">
          <source>Expanding on these:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8fc5537d5aa41a3bee835484d8a71db89d04af82" translate="yes" xml:space="preserve">
          <source>Expands MM[KS]/Make macros in a text string, using the contents of identically named elements of &lt;code&gt;%$self&lt;/code&gt; , and returns the result as a file specification in Unix syntax.</source>
          <target state="translated">&lt;code&gt;%$self&lt;/code&gt; 와 동일한 이름을 가진 요소의 내용을 사용하여 텍스트 문자열에서 MM [KS] / Make 매크로를 확장 하고 결과를 파일 형식으로 Unix 구문으로 반환합니다.</target>
        </trans-unit>
        <trans-unit id="bb3eba70260caae42d2a56d669b04a37e9fa0e09" translate="yes" xml:space="preserve">
          <source>Expands MM[KS]/Make macros in a text string, using the contents of identically named elements of &lt;code&gt;%$self&lt;/code&gt;, and returns the result as a file specification in Unix syntax.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f5783f703e4997395da1ed4bfbdfa29354401cb" translate="yes" xml:space="preserve">
          <source>Expands a message, intended for the user, to include an indication of the current location in the code, if the message does not already appear to be complete.</source>
          <target state="translated">메시지가 아직 완료되지 않은 것으로 나타나면 코드에 현재 위치를 표시하도록 사용자를위한 메시지를 확장합니다.</target>
        </trans-unit>
        <trans-unit id="acbbc593d8399af8ae3b5c591c83e4cbee77c103" translate="yes" xml:space="preserve">
          <source>Expands the character buffer in the SV so that it has room for the indicated number of bytes (remember to reserve space for an extra trailing &lt;code&gt;NUL&lt;/code&gt; character). Calls &lt;code&gt;sv_grow&lt;/code&gt; to perform the expansion if necessary. Returns a pointer to the character buffer. SV must be of type &amp;gt;= &lt;code&gt;SVt_PV&lt;/code&gt;. One alternative is to call &lt;code&gt;sv_grow&lt;/code&gt; if you are not sure of the type of SV.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="adde8be1848474c5303345a29bcef52bb4a7e17d" translate="yes" xml:space="preserve">
          <source>Expands the character buffer in the SV so that it has room for the indicated number of bytes (remember to reserve space for an extra trailing &lt;code&gt;NUL&lt;/code&gt; character). Calls &lt;code&gt;sv_grow&lt;/code&gt; to perform the expansion if necessary. Returns a pointer to the character buffer. SV must be of type &amp;gt;= SVt_PV. One alternative is to call &lt;code&gt;sv_grow&lt;/code&gt; if you are not sure of the type of SV.</source>
          <target state="translated">SV에서 문자 버퍼를 확장하여 표시된 바이트 수를위한 공간을 확보합니다 (추가 후행 &lt;code&gt;NUL&lt;/code&gt; 문자를 위한 공간을 확보해야 함 ). 필요한 경우 &lt;code&gt;sv_grow&lt;/code&gt; 를 호출 하여 확장을 수행합니다. 문자 버퍼에 대한 포인터를 반환합니다. SV는&amp;gt; = SVt_PV 유형이어야합니다. 한 가지 대안은 SV 유형을 잘 &lt;code&gt;sv_grow&lt;/code&gt; 경우 sv_grow 를 호출 하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="e07f45c58aaef41c3cc48eff8856e3deb378b3c7" translate="yes" xml:space="preserve">
          <source>Expands the character buffer in the SV. If necessary, uses &lt;code&gt;sv_unref&lt;/code&gt; and upgrades the SV to &lt;code&gt;SVt_PV&lt;/code&gt; . Returns a pointer to the character buffer. Use the &lt;code&gt;SvGROW&lt;/code&gt; wrapper instead.</source>
          <target state="translated">SV에서 문자 버퍼를 확장합니다. 필요한 경우 &lt;code&gt;sv_unref&lt;/code&gt; 를 사용 하고 SV를 &lt;code&gt;SVt_PV&lt;/code&gt; 로 업그레이드합니다 . 문자 버퍼에 대한 포인터를 반환합니다. 대신 &lt;code&gt;SvGROW&lt;/code&gt; 래퍼를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="bdfec9c6e27c21de38d0ad42245bca4c56a0db95" translate="yes" xml:space="preserve">
          <source>Expands the character buffer in the SV. If necessary, uses &lt;code&gt;sv_unref&lt;/code&gt; and upgrades the SV to &lt;code&gt;SVt_PV&lt;/code&gt;. Returns a pointer to the character buffer. Use the &lt;code&gt;SvGROW&lt;/code&gt; wrapper instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53b55719b11400ab3946110ac0b6da5f10e36cb7" translate="yes" xml:space="preserve">
          <source>Expands_On_NFC</source>
          <target state="translated">Expands_On_NFC</target>
        </trans-unit>
        <trans-unit id="6067c08bd93995f39d3f36483e3f4ef3039e3007" translate="yes" xml:space="preserve">
          <source>Expands_On_NFD</source>
          <target state="translated">Expands_On_NFD</target>
        </trans-unit>
        <trans-unit id="5df7d510e0afb51aa87d43b92bcf880d99423548" translate="yes" xml:space="preserve">
          <source>Expands_On_NFKC</source>
          <target state="translated">Expands_On_NFKC</target>
        </trans-unit>
        <trans-unit id="cc2ac673ebfc4ca4115add5e1d8491f6e16313e9" translate="yes" xml:space="preserve">
          <source>Expands_On_NFKD</source>
          <target state="translated">Expands_On_NFKD</target>
        </trans-unit>
        <trans-unit id="60ad5e3c5be34af787f1a5a9f57ebcde8c336258" translate="yes" xml:space="preserve">
          <source>Expected '=item</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4cf0de321b4edfe39f598e66ba458f32fd64da99" translate="yes" xml:space="preserve">
          <source>Expected '=item *'</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="777c7b4c3fe35b49213cdaeefc6c1268989f5da0" translate="yes" xml:space="preserve">
          <source>Expecting a single value is not quite the same as knowing that there will be one. If someone modified</source>
          <target state="translated">하나의 가치를 기대하는 것은 하나의 가치가 있다는 것을 아는 것과는 다릅니다. 누군가가 수정 한 경우</target>
        </trans-unit>
        <trans-unit id="64185a4c949e7204414cf46ff03bc3f1606cbf77" translate="yes" xml:space="preserve">
          <source>Expecting close bracket in regex; marked by &amp;lt;-- HERE in m/%s/</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65287be72b978ac388e5b50adfdc25bcb62b5804" translate="yes" xml:space="preserve">
          <source>Expecting interpolated extended charclass in regex; marked by &amp;lt;-- HERE in m/%s/</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf72e88f58634dcb4936f677084e0a00acfdd002" translate="yes" xml:space="preserve">
          <source>Expects an anonymous hash of name =&amp;gt; value pairs. Same rules apply for names as in &lt;code&gt;new&lt;/code&gt; . If no argument is supplied, will return the &quot;seen&quot; list of name =&amp;gt; value pairs, in a list context. Otherwise, returns the object itself.</source>
          <target state="translated">이름 =&amp;gt; 값 쌍의 익명 해시가 필요합니다. &lt;code&gt;new&lt;/code&gt; 규칙과 동일한 규칙이 이름에 적용됩니다 . 인수가 제공되지 않으면 목록 컨텍스트에서 이름 =&amp;gt; 값 쌍의 &quot;본&quot;목록을 리턴합니다. 그렇지 않으면 객체 자체를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="4d7959ebdbd1eb9b37094b35dddbe6785e49b443" translate="yes" xml:space="preserve">
          <source>Expects an anonymous hash of name =&amp;gt; value pairs. Same rules apply for names as in &lt;code&gt;new&lt;/code&gt;. If no argument is supplied, will return the &quot;seen&quot; list of name =&amp;gt; value pairs, in a list context. Otherwise, returns the object itself.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc66b53e07eb3ff24ec3024a45e5d4fb318685f8" translate="yes" xml:space="preserve">
          <source>Experimental %s on scalar is now forbidden</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04b17e379ead5f797c5aa37eb9dc9a107df81896" translate="yes" xml:space="preserve">
          <source>Experimental Details on given and when</source>
          <target state="translated">주어진 시간과 시간에 대한 실험적 세부 사항</target>
        </trans-unit>
        <trans-unit id="f6f74c01abe74837a83d80a82742b5139aa6cefe" translate="yes" xml:space="preserve">
          <source>Experimental Support for Sun Studio Compilers for Linux OS</source>
          <target state="translated">Linux OS 용 Sun Studio 컴파일러에 대한 실험 지원</target>
        </trans-unit>
        <trans-unit id="7e049d90ac73798a976f271b4843fd29805765d5" translate="yes" xml:space="preserve">
          <source>Experimental aliasing via reference not enabled</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e15651ca047ada36f7efb9c2f8e000cd639262b" translate="yes" xml:space="preserve">
          <source>Experimental features made easy</source>
          <target state="translated">간편한 실험 기능</target>
        </trans-unit>
        <trans-unit id="ed2ea169fad6a1c0c998398ba26a1941a42d9f93" translate="yes" xml:space="preserve">
          <source>Experimental features must be experimental in two stable releases before being marked non-experimental. Experimental features will only have their experimental status revoked when they no longer have any design-changing bugs open against them and when they have remained unchanged in behavior for the entire length of a development cycle. In other words, a feature present in v5.20.0 may be marked no longer experimental in v5.22.0 if and only if its behavior is unchanged throughout all of v5.21.</source>
          <target state="translated">실험적인 특징은 실험적이지 않은 것으로 표시되기 전에 두 개의 안정된 릴리스에서 실험되어야합니다. 실험 기능은 더 이상 디자인 변경 버그가 열려 있지 않고 개발주기의 전체 길이 동안 동작이 변경되지 않은 경우에만 실험 상태가 취소됩니다. 즉, v5.20.0에있는 기능은 모든 v5.21에서 동작이 변경되지 않은 경우에만 v5.22.0에서 더 이상 실험적으로 표시되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="812cee3839ce593c6e7f8fb81f34a218fc92295b" translate="yes" xml:space="preserve">
          <source>Experimental implementation to deal with optional_features from META.yml. Still needs coordination with installer software and currently works only for META.yml declaring &lt;code&gt;dynamic_config=0&lt;/code&gt; . Use with caution.</source>
          <target state="translated">META.yml의 optional_features를 처리하기위한 실험적 구현. 여전히 설치 프로그램 소프트웨어와의 조정이 필요하며 현재 &lt;code&gt;dynamic_config=0&lt;/code&gt; 을 선언하는 META.yml에서만 작동합니다 . 주의해서 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="134ab6b7ca3f00324871d474fd88846598632c3d" translate="yes" xml:space="preserve">
          <source>Experimental subroutine signatures not enabled</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1a2e6bb257f27dcbf131f0e4c5090288b803bfa" translate="yes" xml:space="preserve">
          <source>Experimental support for using Intel C++ Compiler has been added. Edit win32/Makefile and pick the correct CCTYPE for the Visual C that Intel C was installed into. Also uncomment __ICC to enable Intel C on Visual C support. To set up the build enviroment, from the Start Menu run IA-32 Visual Studio 20__ mode or Intel 64 Visual Studio 20__ mode as appropriate. Then run nmake as usually in that prompt box.</source>
          <target state="translated">Intel C ++ Compiler 사용에 대한 실험적인 지원이 추가되었습니다. win32 / Makefile을 편집하고 Intel C가 설치된 Visual C의 올바른 CCTYPE을 선택하십시오. 또한 Visual C 지원에서 Intel C를 활성화하려면 __ICC의 주석을 해제하십시오. 빌드 환경을 설정하려면 시작 메뉴에서 IA-32 Visual Studio 20__ 모드 또는 Intel 64 Visual Studio 20__ 모드를 적절히 실행하십시오. 그런 다음 해당 프롬프트 상자에서 일반적으로 nmake를 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="910b0326198fc0d6a945d746fbbbc76ed369e62f" translate="yes" xml:space="preserve">
          <source>Experimental support for using Intel C++ Compiler has been added. Edit win32/Makefile and pick the correct CCTYPE for the Visual C that Intel C was installed into. Also uncomment __ICC to enable Intel C on Visual C support. To set up the build environment, from the Start Menu run IA-32 Visual Studio 20__ mode or Intel 64 Visual Studio 20__ mode as appropriate. Then run nmake as usually in that prompt box.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="512d10cc80bbcc4b910ab34f44eacc0c8a8cab5b" translate="yes" xml:space="preserve">
          <source>Explain how to make a valid fh without going through open()(i.e. apply a layer). For example if the file is not opened through perl, but we want to get back a fh, like it was opened by Perl.</source>
          <target state="translated">open ()을 거치지 않고 유효한 fh를 만드는 방법을 설명하십시오 (즉, 레이어 적용). 예를 들어 파일이 perl을 통해 열리지 않았지만 Perl에서 열린 것처럼 fh를 되 찾으려고합니다.</target>
        </trans-unit>
        <trans-unit id="c3c57a0034753db204133ffc1a0baecdf062f580" translate="yes" xml:space="preserve">
          <source>Explanation of the error, or the error itself (such as an exception). In perl exceptions may be blessed objects, so this field may contain a blessed object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd7eb7e15c45c52322c743748d0912cc8c1637a0" translate="yes" xml:space="preserve">
          <source>Explicit blessing to '' (assuming package main)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ae3abeefc2986f2eb842d3cd9632c0a0316ad1f" translate="yes" xml:space="preserve">
          <source>Explicit context</source>
          <target state="translated">명시 적 컨텍스트</target>
        </trans-unit>
        <trans-unit id="04ff6c95ad88a6e349a482b76bfc08416f18ea96" translate="yes" xml:space="preserve">
          <source>Explicitly forces no carriage control.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2d335bbeeb032574984b5eec4fdf9e2563d5abb" translate="yes" xml:space="preserve">
          <source>Explicitly using the &lt;code&gt;ENTER&lt;/code&gt; /&lt;code&gt;SAVETMPS&lt;/code&gt; --&lt;code&gt;FREETMPS&lt;/code&gt; /&lt;code&gt;LEAVE&lt;/code&gt; pairing</source>
          <target state="translated">&lt;code&gt;ENTER&lt;/code&gt; / &lt;code&gt;SAVETMPS&lt;/code&gt; - &lt;code&gt;FREETMPS&lt;/code&gt; / &lt;code&gt;LEAVE&lt;/code&gt; 페어링을 명시 적으로 사용</target>
        </trans-unit>
        <trans-unit id="6e87a66444e923290e00f1a8b43474c974953b7a" translate="yes" xml:space="preserve">
          <source>Explicitly using the &lt;code&gt;ENTER&lt;/code&gt;/&lt;code&gt;SAVETMPS&lt;/code&gt;--&lt;code&gt;FREETMPS&lt;/code&gt;/&lt;code&gt;LEAVE&lt;/code&gt; pairing</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d165ee97f26b031b938fc12621899c47ca3e7175" translate="yes" xml:space="preserve">
          <source>Exponentiation</source>
          <target state="translated">Exponentiation</target>
        </trans-unit>
        <trans-unit id="f3e4fadb9e370a1e2c0c622c01fc8c77daf93a2c" translate="yes" xml:space="preserve">
          <source>Export</source>
          <target state="translated">Export</target>
        </trans-unit>
        <trans-unit id="b04b1d43c804b579fc2179b2b3b449ae1560ae80" translate="yes" xml:space="preserve">
          <source>Export tags defined</source>
          <target state="translated">태그 내보내기 정의</target>
        </trans-unit>
        <trans-unit id="a10fabb79509133b618928fd32456dad097bd96f" translate="yes" xml:space="preserve">
          <source>Exportable Functions</source>
          <target state="translated">내보낼 수있는 기능</target>
        </trans-unit>
        <trans-unit id="087b5b3729015829a7b8d0086f8e5125870ab2b2" translate="yes" xml:space="preserve">
          <source>Exportable Methods</source>
          <target state="translated">수출 가능한 방법</target>
        </trans-unit>
        <trans-unit id="3fb8ab7d4fdb770897f754d6218d2ea74b86ecf3" translate="yes" xml:space="preserve">
          <source>Exportable constants</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60fa04392e9fbe49aa17d919da35cd7332fea185" translate="yes" xml:space="preserve">
          <source>Exported utility variables</source>
          <target state="translated">내 보낸 유틸리티 변수</target>
        </trans-unit>
        <trans-unit id="0cd84bdcb23e59371516a9290d82778263ec9c7c" translate="yes" xml:space="preserve">
          <source>Exporter</source>
          <target state="translated">Exporter</target>
        </trans-unit>
        <trans-unit id="e3272220a019edf889f502d8e939100dd7ba6db5" translate="yes" xml:space="preserve">
          <source>Exporter - Implements default import method for modules</source>
          <target state="translated">내보내기-모듈의 기본 가져 오기 방법을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="9677334ff1544480ffd2a9303280ab252a694823" translate="yes" xml:space="preserve">
          <source>Exporter guts</source>
          <target state="translated">수출 용기</target>
        </trans-unit>
        <trans-unit id="733f73993629cd5a5a17865554f4f49f3a533105" translate="yes" xml:space="preserve">
          <source>Exporter has a special method, 'export_to_level' which is used in situations where you can't directly call Exporter's import method. The export_to_level method looks like:</source>
          <target state="translated">Exporter에는 Exporter의 import 메소드를 직접 호출 할 수없는 상황에서 사용되는 특수한 'export_to_level'메소드가 있습니다. export_to_level 메소드는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e3e659931fe986137a62058f2b4abcef03d65202" translate="yes" xml:space="preserve">
          <source>Exporter.pm</source>
          <target state="translated">Exporter.pm</target>
        </trans-unit>
        <trans-unit id="dc76f5ce6b0b38a5f000b46176cc35b9cb43b24a" translate="yes" xml:space="preserve">
          <source>Exporter::Heavy</source>
          <target state="translated">Exporter::Heavy</target>
        </trans-unit>
        <trans-unit id="1d1140249dd08a40f776c20b9ddd54b5796c4a08" translate="yes" xml:space="preserve">
          <source>Exporter::Heavy - Exporter guts</source>
          <target state="translated">수출 :: 무거운-수출 용기</target>
        </trans-unit>
        <trans-unit id="5212c627287d01ea51f61b228d900e6e7aa1a003" translate="yes" xml:space="preserve">
          <source>Exporting Without Inheriting from Exporter</source>
          <target state="translated">내보내기에서 상속하지 않고 내보내기</target>
        </trans-unit>
        <trans-unit id="b76a470ae357815e917068bbc5728a8478edaac1" translate="yes" xml:space="preserve">
          <source>Exporting Without Using Exporter's import Method</source>
          <target state="translated">내보내기의 가져 오기 방법을 사용하지 않고 내보내기</target>
        </trans-unit>
        <trans-unit id="1b7c31e16f36f853e2c6c57c0f5c8d014a8558d8" translate="yes" xml:space="preserve">
          <source>Exporting variables is not a good idea. They can change under the hood, provoking horrible effects at-a-distance that are too hard to track and to fix. Trust me: they are not worth it.</source>
          <target state="translated">변수 내보내기는 좋지 않습니다. 그들은 추적하고 고치기가 너무 어려운 거리에서 끔찍한 효과를 유발하여 후드 아래에서 변화 할 수 있습니다. 저를 믿으십시오 : 그들은 가치가 없습니다.</target>
        </trans-unit>
        <trans-unit id="071e64c7e24a9d0c7e9058c9548f279b0db62c55" translate="yes" xml:space="preserve">
          <source>Exporting your new function</source>
          <target state="translated">새로운 기능 내보내기</target>
        </trans-unit>
        <trans-unit id="0e16537914a0163e01ecd7e0945bc56c50eb3849" translate="yes" xml:space="preserve">
          <source>Exports</source>
          <target state="translated">Exports</target>
        </trans-unit>
        <trans-unit id="78a2a7642c638f47b6ed7502eab44ca9b2bee2ca" translate="yes" xml:space="preserve">
          <source>Exports all the test functions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0cf2ed8b53d5a014c877f2053b8b2d2b823e37e6" translate="yes" xml:space="preserve">
          <source>Exports in this section are not commonly needed. These all have the 'test2_' prefix to help ensure they stand out. You should look at the &lt;a href=&quot;#MAIN-API-EXPORTS&quot;&gt;&quot;MAIN API EXPORTS&quot;&lt;/a&gt; section before looking here. This section is one where &quot;Great power comes with great responsibility&quot;. It is possible to break things badly if you are not careful with these.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a78d15b2b917cc03293d31b108e05ce4d52026f" translate="yes" xml:space="preserve">
          <source>Exports pollute the namespace of the module user. If you must export try to use &lt;code&gt;@EXPORT_OK&lt;/code&gt; in preference to &lt;code&gt;@EXPORT&lt;/code&gt; and avoid short or common symbol names to reduce the risk of name clashes.</source>
          <target state="translated">내보내기는 모듈 사용자의 네임 스페이스를 오염시킵니다. 내 &lt;code&gt;@EXPORT_OK&lt;/code&gt; 하는 경우 &lt;code&gt;@EXPORT&lt;/code&gt; 보다 _OK 를 사용하고 이름 충돌의 위험을 줄이기 위해 짧거나 일반적인 기호 이름을 사용하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="19680f4d8bc35c089321258ed1726974e515bb01" translate="yes" xml:space="preserve">
          <source>Exports pollute the namespace of the module user. If you must export try to use @EXPORT_OK in preference to @EXPORT and avoid short or common names to reduce the risk of name clashes.</source>
          <target state="translated">내보내기는 모듈 사용자의 네임 스페이스를 오염시킵니다. 내 보내야하는 경우 @EXPORT보다 @EXPORT_OK를 사용하고 이름 충돌의 위험을 줄이기 위해 짧거나 일반적인 이름을 사용하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="991118c2b6b3c16c0bc4bf38a36f6ec2aa05622c" translate="yes" xml:space="preserve">
          <source>Expose the individual bytes of characters</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b67fdeebc6a730537832b31cf1e590434ac7ad11" translate="yes" xml:space="preserve">
          <source>Exposes the POSIX function getcwd(3) or re-implements it if it's not available.</source>
          <target state="translated">POSIX 함수 getcwd (3)를 노출하거나 사용할 수없는 경우 다시 구현합니다.</target>
        </trans-unit>
        <trans-unit id="30e13c3f2f4b6a85ea0443e9079e6877bde86d9e" translate="yes" xml:space="preserve">
          <source>Expressing the command as a list</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="848bbebe9b69edd539cf121a71439bdfe81b397c" translate="yes" xml:space="preserve">
          <source>Expressions like this are useful in conditionals:</source>
          <target state="translated">이와 같은 표현식은 조건부에서 유용합니다.</target>
        </trans-unit>
        <trans-unit id="130f8cc58ed68e3a1fe427428482f60dc97e9301" translate="yes" xml:space="preserve">
          <source>Ext/Ension</source>
          <target state="translated">Ext/Ension</target>
        </trans-unit>
        <trans-unit id="ae4a822ac4b76bc07804416206c3daa608046771" translate="yes" xml:space="preserve">
          <source>ExtUtils</source>
          <target state="translated">ExtUtils</target>
        </trans-unit>
        <trans-unit id="8adb87135c238343780172ae48188681cf370acf" translate="yes" xml:space="preserve">
          <source>ExtUtils::CBuilder</source>
          <target state="translated">ExtUtils::CBuilder</target>
        </trans-unit>
        <trans-unit id="0dd29c2a17cfd9dc6e5beb4505e91940187682bf" translate="yes" xml:space="preserve">
          <source>ExtUtils::CBuilder - Compile and link C code for Perl modules</source>
          <target state="translated">ExtUtils :: CBuilder-Perl 모듈을위한 C 코드 컴파일 및 링크</target>
        </trans-unit>
        <trans-unit id="de9e9dbbe64dfc1f06076f5b598c40c5b97a4f07" translate="yes" xml:space="preserve">
          <source>ExtUtils::CBuilder is maintained as part of the Perl 5 core. Please submit any bug reports via the</source>
          <target state="translated">ExtUtils :: CBuilder는 Perl 5 코어의 일부로 유지됩니다. 를 통해 버그 보고서를 제출하십시오</target>
        </trans-unit>
        <trans-unit id="6d9aae08362d79c65318eda6627f0ab746bbee95" translate="yes" xml:space="preserve">
          <source>ExtUtils::CBuilder::Platform::Windows</source>
          <target state="translated">ExtUtils::CBuilder::Platform::Windows</target>
        </trans-unit>
        <trans-unit id="ec8f2943e4d10ff3dad921becf4700a9c605fc5f" translate="yes" xml:space="preserve">
          <source>ExtUtils::CBuilder::Platform::Windows - Builder class for Windows platforms</source>
          <target state="translated">ExtUtils :: CBuilder :: Platform :: Windows-Windows 플랫폼 용 빌더 클래스</target>
        </trans-unit>
        <trans-unit id="0f5f8c4e317cb9e14dbc99f8c4725e7101d063e0" translate="yes" xml:space="preserve">
          <source>ExtUtils::Command</source>
          <target state="translated">ExtUtils::Command</target>
        </trans-unit>
        <trans-unit id="13685feaf020782447b9941746d4b335bddf0883" translate="yes" xml:space="preserve">
          <source>ExtUtils::Command - utilities to replace common UNIX commands in Makefiles etc.</source>
          <target state="translated">ExtUtils :: Command-Makefile 등에서 일반적인 UNIX 명령을 대체하는 유틸리티</target>
        </trans-unit>
        <trans-unit id="1e0e65de42d77495693723755508f19700283291" translate="yes" xml:space="preserve">
          <source>ExtUtils::Command::MM</source>
          <target state="translated">ExtUtils::Command::MM</target>
        </trans-unit>
        <trans-unit id="57baedd89a659e1e0ecff540830bcf69ebde4c0c" translate="yes" xml:space="preserve">
          <source>ExtUtils::Command::MM - Commands for the MM's to use in Makefiles</source>
          <target state="translated">ExtUtils :: Command :: MM-MM이 Makefile에서 사용할 명령</target>
        </trans-unit>
        <trans-unit id="e8520d9305bb1b6b30673860c2a9fc7e0bb43af7" translate="yes" xml:space="preserve">
          <source>ExtUtils::Command::MM encapsulates code which would otherwise have to be done with large &quot;one&quot; liners.</source>
          <target state="translated">ExtUtils :: Command :: MM은 큰 &quot;하나&quot;라이너로 수행해야하는 코드를 캡슐화합니다.</target>
        </trans-unit>
        <trans-unit id="01aca525aa3b0d3504eab62f629ea7ae316a1df9" translate="yes" xml:space="preserve">
          <source>ExtUtils::Constant</source>
          <target state="translated">ExtUtils::Constant</target>
        </trans-unit>
        <trans-unit id="eb53ab587c5df3bac6d41d873980d0a80f5c155a" translate="yes" xml:space="preserve">
          <source>ExtUtils::Constant - generate XS code to import C header constants</source>
          <target state="translated">ExtUtils :: Constant-C 헤더 상수를 가져 오기 위해 XS 코드 생성</target>
        </trans-unit>
        <trans-unit id="2bfb67938397e6eb325051359a5d323e79a220d8" translate="yes" xml:space="preserve">
          <source>ExtUtils::Constant facilitates generating C and XS wrapper code to allow perl modules to AUTOLOAD constants defined in C library header files. It is principally used by the &lt;code&gt;h2xs&lt;/code&gt; utility, on which this code is based. It doesn't contain the routines to scan header files to extract these constants.</source>
          <target state="translated">ExtUtils :: Constant는 C 및 XS 래퍼 코드 생성을 용이하게하여 perl 모듈이 C 라이브러리 헤더 파일에 정의 된 상수를 AUTOLOAD 할 수 있도록합니다. 이 코드 는 기본적으로 &lt;code&gt;h2xs&lt;/code&gt; 유틸리티에서 사용됩니다 . 이러한 상수를 추출하기 위해 헤더 파일을 스캔하는 루틴은 포함되어 있지 않습니다.</target>
        </trans-unit>
        <trans-unit id="66069119c4474ce5db2c00c2fc5c7ebe74e509d3" translate="yes" xml:space="preserve">
          <source>ExtUtils::Constant::Base</source>
          <target state="translated">ExtUtils::Constant::Base</target>
        </trans-unit>
        <trans-unit id="a5a92bf27fd8a70fb8d0d04675721591091d31a8" translate="yes" xml:space="preserve">
          <source>ExtUtils::Constant::Base - base class for ExtUtils::Constant objects</source>
          <target state="translated">ExtUtils :: Constant :: Base-ExtUtils :: Constant 객체의 기본 클래스</target>
        </trans-unit>
        <trans-unit id="37d28c0e096d851a074af795694f3e4ed605e4fe" translate="yes" xml:space="preserve">
          <source>ExtUtils::Constant::Base exports no subroutines. The following methods are available</source>
          <target state="translated">ExtUtils :: Constant :: Base는 서브 루틴을 내 보내지 않습니다. 다음과 같은 방법을 사용할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="cc85f41228edcbb25fda849b24e857773037224e" translate="yes" xml:space="preserve">
          <source>ExtUtils::Constant::Base provides a base implementation of methods to generate C code to give fast constant value lookup by named string. Currently it's mostly used ExtUtils::Constant::XS, which generates the lookup code for the constant() subroutine found in many XS modules.</source>
          <target state="translated">ExtUtils :: Constant :: Base는 C 코드를 생성하여 명명 된 문자열로 빠른 상수 값 조회를 제공하는 기본 메소드 구현을 제공합니다. 현재 대부분 ExtUtils :: Constant :: XS를 사용하고 있으며, 많은 XS 모듈에서 발견되는 constant () 서브 루틴에 대한 조회 코드를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="01123cf69ee0503631a353722ce7083ea5078bc4" translate="yes" xml:space="preserve">
          <source>ExtUtils::Constant::Utils</source>
          <target state="translated">ExtUtils::Constant::Utils</target>
        </trans-unit>
        <trans-unit id="eb7021c674be1dbbac0f5d2f00a2ee805361885c" translate="yes" xml:space="preserve">
          <source>ExtUtils::Constant::Utils - helper functions for ExtUtils::Constant</source>
          <target state="translated">ExtUtils :: Constant :: Utils-ExtUtils :: Constant 도우미 함수</target>
        </trans-unit>
        <trans-unit id="88fa01ca987de7b887a3c79f4e501e05801215f9" translate="yes" xml:space="preserve">
          <source>ExtUtils::Constant::Utils packages up utility subroutines used by ExtUtils::Constant, ExtUtils::Constant::Base and derived classes. All its functions are explicitly exportable.</source>
          <target state="translated">ExtUtils :: Constant :: Utils는 ExtUtils :: Constant, ExtUtils :: Constant :: Base 및 파생 클래스에서 사용하는 유틸리티 서브 루틴을 패키지합니다. 모든 기능은 명시 적으로 내보낼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="691e427f212f20f1a4e97a292f83b191a9330664" translate="yes" xml:space="preserve">
          <source>ExtUtils::Constant::XS</source>
          <target state="translated">ExtUtils::Constant::XS</target>
        </trans-unit>
        <trans-unit id="7b304383401bf8b504f1c4575e883635046c55a8" translate="yes" xml:space="preserve">
          <source>ExtUtils::Constant::XS - generate C code for XS modules' constants.</source>
          <target state="translated">ExtUtils :: Constant :: XS-XS 모듈 상수에 대한 C 코드를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="a134fe12059f0bb9cd89ef6f92c5ae2e9810c57e" translate="yes" xml:space="preserve">
          <source>ExtUtils::Constant::XS overrides ExtUtils::Constant::Base to generate C code for XS modules' constants.</source>
          <target state="translated">ExtUtils :: Constant :: XS는 ExtUtils :: Constant :: Base를 재정 의하여 XS 모듈 상수에 대한 C 코드를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="5fb8ee5bc96080dc35b8c113dc4ab7e19f1f7f22" translate="yes" xml:space="preserve">
          <source>ExtUtils::Embed</source>
          <target state="translated">ExtUtils::Embed</target>
        </trans-unit>
        <trans-unit id="939f083947624f21f9b736c75a4f6438e18f6655" translate="yes" xml:space="preserve">
          <source>ExtUtils::Embed - Utilities for embedding Perl in C/C++ applications</source>
          <target state="translated">ExtUtils :: Embed-C / C ++ 응용 프로그램에 Perl을 임베드하기위한 유틸리티</target>
        </trans-unit>
        <trans-unit id="66d1280ba3865302835b81bea028e8fe495e808d" translate="yes" xml:space="preserve">
          <source>ExtUtils::Install</source>
          <target state="translated">ExtUtils::Install</target>
        </trans-unit>
        <trans-unit id="e1917ee01b8bd661c56eb9ac792b975c3df2f5a1" translate="yes" xml:space="preserve">
          <source>ExtUtils::Install - install files from here to there</source>
          <target state="translated">ExtUtils :: Install-여기에서 거기까지 파일 설치</target>
        </trans-unit>
        <trans-unit id="b703bea959a592e6e8e04477edfce4ad8bd309c6" translate="yes" xml:space="preserve">
          <source>ExtUtils::Installed</source>
          <target state="translated">ExtUtils::Installed</target>
        </trans-unit>
        <trans-unit id="3984de1657750a05991b5ea96245f59313691aaf" translate="yes" xml:space="preserve">
          <source>ExtUtils::Installed - Inventory management of installed modules</source>
          <target state="translated">ExtUtils :: Installed-설치된 모듈의 재고 관리</target>
        </trans-unit>
        <trans-unit id="b02212efafd95acf708fbde6c1ea9a18a4ebc3b3" translate="yes" xml:space="preserve">
          <source>ExtUtils::Installed provides a standard way to find out what core and module files have been installed. It uses the information stored in .packlist files created during installation to provide this information. In addition it provides facilities to classify the installed files and to extract directory information from the .packlist files.</source>
          <target state="translated">ExtUtils :: Installed는 설치된 코어 및 모듈 파일을 찾는 표준 방법을 제공합니다. 설치 중에 작성된 .packlist 파일에 저장된 정보를 사용하여이 정보를 제공합니다. 또한 설치된 파일을 분류하고 .packlist 파일에서 디렉토리 정보를 추출하는 기능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="42c25bbd2df5e46fa299efe94a0a5ec1d56bc561" translate="yes" xml:space="preserve">
          <source>ExtUtils::Liblist</source>
          <target state="translated">ExtUtils::Liblist</target>
        </trans-unit>
        <trans-unit id="1c444f69f6d944829dae0bfb3cb19187e41f4b3d" translate="yes" xml:space="preserve">
          <source>ExtUtils::Liblist - determine libraries to use and how to use them</source>
          <target state="translated">ExtUtils :: Liblist-사용할 라이브러리 및 사용 방법 결정</target>
        </trans-unit>
        <trans-unit id="d6d8f29d2d6c812d8608b7eecff6b50d5b23bb32" translate="yes" xml:space="preserve">
          <source>ExtUtils::MM</source>
          <target state="translated">ExtUtils::MM</target>
        </trans-unit>
        <trans-unit id="d9944867a30cc09571228059a446b44834907174" translate="yes" xml:space="preserve">
          <source>ExtUtils::MM - OS adjusted ExtUtils::MakeMaker subclass</source>
          <target state="translated">ExtUtils :: MM-OS 조정 ExtUtils :: MakeMaker 서브 클래스</target>
        </trans-unit>
        <trans-unit id="8e1a56d427b6cdce97fbab94a739a6369e0e5125" translate="yes" xml:space="preserve">
          <source>ExtUtils::MM is a subclass of &lt;a href=&quot;ExtUtils::MakeMaker&quot;&gt;ExtUtils::MakeMaker&lt;/a&gt; which automatically chooses the appropriate OS specific subclass for you (ie. &lt;a href=&quot;ExtUtils::MM_Unix&quot;&gt;ExtUtils::MM_Unix&lt;/a&gt;, etc...).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db5ed850a839f5d75d47dcc96cd13b3666aca25d" translate="yes" xml:space="preserve">
          <source>ExtUtils::MM is a subclass of ExtUtils::MakeMaker which automatically chooses the appropriate OS specific subclass for you (ie. ExtUils::MM_Unix, etc...).</source>
          <target state="translated">ExtUtils :: MM은 ExtUtils :: MakeMaker의 서브 클래스로, 적합한 OS 특정 서브 클래스 (예 : ExtUils :: MM_Unix 등)를 자동으로 선택합니다.</target>
        </trans-unit>
        <trans-unit id="f20ad18d2cdfe05b996f3064f2baa9077e90198e" translate="yes" xml:space="preserve">
          <source>ExtUtils::MM_AIX</source>
          <target state="translated">ExtUtils::MM_AIX</target>
        </trans-unit>
        <trans-unit id="e2c65ab01c23a32d98e8b4e3a0d77782b9a1b0c7" translate="yes" xml:space="preserve">
          <source>ExtUtils::MM_AIX - AIX specific subclass of ExtUtils::MM_Unix</source>
          <target state="translated">ExtUtils :: MM_AIX-ExtUtils :: MM_Unix의 AIX 특정 서브 클래스</target>
        </trans-unit>
        <trans-unit id="82f6a9462d97b2eeba15d489f4c29f1201ca8139" translate="yes" xml:space="preserve">
          <source>ExtUtils::MM_Any</source>
          <target state="translated">ExtUtils::MM_Any</target>
        </trans-unit>
        <trans-unit id="28e6e24f25939bb77bd8b0e8b5c1b5591ab0a63a" translate="yes" xml:space="preserve">
          <source>ExtUtils::MM_Any - Platform-agnostic MM methods</source>
          <target state="translated">ExtUtils :: MM_Any-플랫폼에 구애받지 않는 MM 메소드</target>
        </trans-unit>
        <trans-unit id="f1beb9206779be8013b3e4a60d1eb3c845414417" translate="yes" xml:space="preserve">
          <source>ExtUtils::MM_Any is a subclass of &lt;a href=&quot;File::Spec&quot;&gt;File::Spec&lt;/a&gt;. The methods noted here override File::Spec.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4017c7fd6c6b1a7382d3693845441ec57607400" translate="yes" xml:space="preserve">
          <source>ExtUtils::MM_Any is a subclass of File::Spec. The methods noted here override File::Spec.</source>
          <target state="translated">ExtUtils :: MM_Any는 File :: Spec의 하위 클래스입니다. 여기에 언급 된 메소드는 File :: Spec을 대체합니다.</target>
        </trans-unit>
        <trans-unit id="a07e79b177dfcc3d173d4e96906fb19054e96233" translate="yes" xml:space="preserve">
          <source>ExtUtils::MM_Any is a superclass for the ExtUtils::MM_* set of modules. It contains methods which are either inherently cross-platform or are written in a cross-platform manner.</source>
          <target state="translated">ExtUtils :: MM_Any는 ExtUtils :: MM_ * 모듈 세트의 수퍼 클래스입니다. 여기에는 기본적으로 크로스 플랫폼 방식이거나 크로스 플랫폼 방식으로 작성된 방법이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="01e79daa480a30aec67c1c77b38113a2fa75acb1" translate="yes" xml:space="preserve">
          <source>ExtUtils::MM_BeOS</source>
          <target state="translated">ExtUtils::MM_BeOS</target>
        </trans-unit>
        <trans-unit id="ff7047e18f778da31bd8596ebbae3ca3c16815a1" translate="yes" xml:space="preserve">
          <source>ExtUtils::MM_BeOS - methods to override UN*X behaviour in ExtUtils::MakeMaker</source>
          <target state="translated">ExtUtils :: MM_BeOS-ExtUtils :: MakeMaker에서 UN * X 동작을 재정의하는 메소드</target>
        </trans-unit>
        <trans-unit id="32f54e4d1cdff9fa869169ffbe48a1f8a6442f8d" translate="yes" xml:space="preserve">
          <source>ExtUtils::MM_Cygwin</source>
          <target state="translated">ExtUtils::MM_Cygwin</target>
        </trans-unit>
        <trans-unit id="26a23a31e9ae337b30e976cee9bfe04ee8714af5" translate="yes" xml:space="preserve">
          <source>ExtUtils::MM_Cygwin - methods to override UN*X behaviour in ExtUtils::MakeMaker</source>
          <target state="translated">ExtUtils :: MM_Cygwin-ExtUtils :: MakeMaker에서 UN * X 동작을 재정의하는 메소드</target>
        </trans-unit>
        <trans-unit id="83b34173b4084fe7b0f1b8e7080f5e44721c1652" translate="yes" xml:space="preserve">
          <source>ExtUtils::MM_DOS</source>
          <target state="translated">ExtUtils::MM_DOS</target>
        </trans-unit>
        <trans-unit id="ce09d2a78829bfe3f6e4a91c1fda8bf736e91cd1" translate="yes" xml:space="preserve">
          <source>ExtUtils::MM_DOS - DOS specific subclass of ExtUtils::MM_Unix</source>
          <target state="translated">ExtUtils :: MM_DOS-ExtUtils :: MM_Unix의 DOS 특정 서브 클래스</target>
        </trans-unit>
        <trans-unit id="95c4b06cdebc87ea8f0b490c31911c2d3a160085" translate="yes" xml:space="preserve">
          <source>ExtUtils::MM_Darwin</source>
          <target state="translated">ExtUtils::MM_Darwin</target>
        </trans-unit>
        <trans-unit id="ce3594f7f3d66367be8d04f9a60ed3e5b23e61ae" translate="yes" xml:space="preserve">
          <source>ExtUtils::MM_Darwin - special behaviors for OS X</source>
          <target state="translated">ExtUtils :: MM_Darwin-OS X의 특수 동작</target>
        </trans-unit>
        <trans-unit id="a35d39f1996d06db96e0eb3bc7581c9d1bb37583" translate="yes" xml:space="preserve">
          <source>ExtUtils::MM_MacOS</source>
          <target state="translated">ExtUtils::MM_MacOS</target>
        </trans-unit>
        <trans-unit id="a75ee91bd51d22344f5f01dea69463550d1b77f8" translate="yes" xml:space="preserve">
          <source>ExtUtils::MM_MacOS - once produced Makefiles for MacOS Classic</source>
          <target state="translated">ExtUtils :: MM_MacOS-한 번 MacOS Classic 용 Makefile 생성</target>
        </trans-unit>
        <trans-unit id="05b1c57f6a3a8d6a042ca608dff6a349761c8182" translate="yes" xml:space="preserve">
          <source>ExtUtils::MM_NW5</source>
          <target state="translated">ExtUtils::MM_NW5</target>
        </trans-unit>
        <trans-unit id="c8c1829d86b2c857e5650f081f857c1eaf86f3e8" translate="yes" xml:space="preserve">
          <source>ExtUtils::MM_NW5 - methods to override UN*X behaviour in ExtUtils::MakeMaker</source>
          <target state="translated">ExtUtils :: MM_NW5-ExtUtils :: MakeMaker에서 UN * X 동작을 재정의하는 메소드</target>
        </trans-unit>
        <trans-unit id="e0950761db3807deb0218887807e7b7bff1a358b" translate="yes" xml:space="preserve">
          <source>ExtUtils::MM_OS2</source>
          <target state="translated">ExtUtils::MM_OS2</target>
        </trans-unit>
        <trans-unit id="9c18e1ac0450cd34c6460b2c5c7a1220fbf998b2" translate="yes" xml:space="preserve">
          <source>ExtUtils::MM_OS2 - methods to override UN*X behaviour in ExtUtils::MakeMaker</source>
          <target state="translated">ExtUtils :: MM_OS2-ExtUtils :: MakeMaker에서 UN * X 동작을 재정의하는 메소드</target>
        </trans-unit>
        <trans-unit id="9754f9a33576ee28f994ec3ff4f6032e292d0ec1" translate="yes" xml:space="preserve">
          <source>ExtUtils::MM_QNX</source>
          <target state="translated">ExtUtils::MM_QNX</target>
        </trans-unit>
        <trans-unit id="5c959f779c55270f8bb8da4da99da8c51701f934" translate="yes" xml:space="preserve">
          <source>ExtUtils::MM_QNX - QNX specific subclass of ExtUtils::MM_Unix</source>
          <target state="translated">ExtUtils :: MM_QNX-ExtUtils :: MM_Unix의 QNX 특정 서브 클래스</target>
        </trans-unit>
        <trans-unit id="d9cffc939c33c81ae491e577ff7a0f67f32115db" translate="yes" xml:space="preserve">
          <source>ExtUtils::MM_UWIN</source>
          <target state="translated">ExtUtils::MM_UWIN</target>
        </trans-unit>
        <trans-unit id="392dbc1b30426cf86e8bbd0156b4353d7aae576c" translate="yes" xml:space="preserve">
          <source>ExtUtils::MM_UWIN - U/WIN specific subclass of ExtUtils::MM_Unix</source>
          <target state="translated">ExtUtils :: MM_UWIN-ExtUtils :: MM_Unix의 U / WIN 특정 서브 클래스</target>
        </trans-unit>
        <trans-unit id="6b69e4024267a17dfff2456177fce03e32e171de" translate="yes" xml:space="preserve">
          <source>ExtUtils::MM_Unix</source>
          <target state="translated">ExtUtils::MM_Unix</target>
        </trans-unit>
        <trans-unit id="c828df98d7850f84de0cbb81d4e4596caa76f94a" translate="yes" xml:space="preserve">
          <source>ExtUtils::MM_Unix - methods used by ExtUtils::MakeMaker</source>
          <target state="translated">ExtUtils :: MM_Unix-ExtUtils :: MakeMaker에서 사용하는 메소드</target>
        </trans-unit>
        <trans-unit id="2f00201cd4f3a6fbb76802bb39ac7a005b8f24e3" translate="yes" xml:space="preserve">
          <source>ExtUtils::MM_Unix. This is a temporary solution.</source>
          <target state="translated">ExtUtils :: MM_Unix. 이것은 임시 해결책입니다.</target>
        </trans-unit>
        <trans-unit id="5bbe314072fa79cbbe64e27d3c034cb7ecbc2df1" translate="yes" xml:space="preserve">
          <source>ExtUtils::MM_VMS</source>
          <target state="translated">ExtUtils::MM_VMS</target>
        </trans-unit>
        <trans-unit id="c328e4aa3661448cfc600baf641ce3b368446553" translate="yes" xml:space="preserve">
          <source>ExtUtils::MM_VMS - methods to override UN*X behaviour in ExtUtils::MakeMaker</source>
          <target state="translated">ExtUtils :: MM_VMS-ExtUtils :: MakeMaker에서 UN * X 동작을 재정의하는 메소드</target>
        </trans-unit>
        <trans-unit id="cbf6a31d4b30a3697a77d880951a740af6fe002e" translate="yes" xml:space="preserve">
          <source>ExtUtils::MM_VOS</source>
          <target state="translated">ExtUtils::MM_VOS</target>
        </trans-unit>
        <trans-unit id="248c1927adaa54c68b53917bcd12ca60bc242150" translate="yes" xml:space="preserve">
          <source>ExtUtils::MM_VOS - VOS specific subclass of ExtUtils::MM_Unix</source>
          <target state="translated">ExtUtils :: MM_VOS-ExtUtils :: MM_Unix의 VOS 특정 서브 클래스</target>
        </trans-unit>
        <trans-unit id="01b2b6f5d2a1e4c4ed0f2cb32046a9a5d606a04c" translate="yes" xml:space="preserve">
          <source>ExtUtils::MM_Win32</source>
          <target state="translated">ExtUtils::MM_Win32</target>
        </trans-unit>
        <trans-unit id="31634682156707a3a92d7105825df2529eb4f747" translate="yes" xml:space="preserve">
          <source>ExtUtils::MM_Win32 - methods to override UN*X behaviour in ExtUtils::MakeMaker</source>
          <target state="translated">ExtUtils :: MM_Win32-ExtUtils :: MakeMaker에서 UN * X 동작을 재정의하는 메서드</target>
        </trans-unit>
        <trans-unit id="dd4f189a6328e4d51489c48940b1b07f49808b7b" translate="yes" xml:space="preserve">
          <source>ExtUtils::MM_Win95</source>
          <target state="translated">ExtUtils::MM_Win95</target>
        </trans-unit>
        <trans-unit id="ef84388c3c22f4aa37ab1ec6dcdd24ddaa801da4" translate="yes" xml:space="preserve">
          <source>ExtUtils::MM_Win95 - method to customize MakeMaker for Win9X</source>
          <target state="translated">ExtUtils :: MM_Win95-Win9X 용 MakeMaker를 사용자 정의하는 방법</target>
        </trans-unit>
        <trans-unit id="2eeeaab10b029e1825f471249451e612175f476c" translate="yes" xml:space="preserve">
          <source>ExtUtils::MY</source>
          <target state="translated">ExtUtils::MY</target>
        </trans-unit>
        <trans-unit id="a29677c3a7812ab9e27275d7d315711580baa3c5" translate="yes" xml:space="preserve">
          <source>ExtUtils::MY - ExtUtils::MakeMaker subclass for customization</source>
          <target state="translated">ExtUtils :: MY-사용자 정의를위한 ExtUtils :: MakeMaker 서브 클래스</target>
        </trans-unit>
        <trans-unit id="8c6225988b72e5033c42e6301547dce425e25ee5" translate="yes" xml:space="preserve">
          <source>ExtUtils::MY is a subclass of &lt;a href=&quot;ExtUtils::MM&quot;&gt;ExtUtils::MM&lt;/a&gt;. Its provided in your Makefile.PL for you to add and override MakeMaker functionality.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="077ce2e66cf34d26fc93548b5aa4b0a365551ad3" translate="yes" xml:space="preserve">
          <source>ExtUtils::MY is a subclass of ExtUtils::MM. Its provided in your Makefile.PL for you to add and override MakeMaker functionality.</source>
          <target state="translated">ExtUtils :: MY는 ExtUtils :: MM의 서브 클래스입니다. MakeMaker 기능을 추가하고 무시할 수 있도록 Makefile.PL에 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="a8d99fc9d222321dd1dd6e7c9d39239d74c92fb3" translate="yes" xml:space="preserve">
          <source>ExtUtils::MY might turn out to be a temporary solution, but MY won't go away.</source>
          <target state="translated">ExtUtils :: MY는 임시 솔루션으로 판명 될 수 있지만 MY은 사라지지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6da8b7232afb53dfdcd9b1c4dde891781d5ce223" translate="yes" xml:space="preserve">
          <source>ExtUtils::MakeMaker</source>
          <target state="translated">ExtUtils::MakeMaker</target>
        </trans-unit>
        <trans-unit id="b8052cbade448d159716f320bb8b7066c1c35927" translate="yes" xml:space="preserve">
          <source>ExtUtils::MakeMaker (EUMM) is object oriented. Each directory below the current directory that contains a Makefile.PL is treated as a separate object. This makes it possible to write an unlimited number of Makefiles with a single invocation of WriteMakefile().</source>
          <target state="translated">ExtUtils :: MakeMaker (EUMM)는 객체 지향입니다. Makefile.PL을 포함하는 현재 디렉토리 아래의 각 디렉토리는 별도의 오브젝트로 취급됩니다. 이를 통해 WriteMakefile ()을 한 번 호출하여 무제한의 Makefile을 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6ea38d2404e8bb2fe915619afea85f24fef8c2cc" translate="yes" xml:space="preserve">
          <source>ExtUtils::MakeMaker - Create a module Makefile</source>
          <target state="translated">ExtUtils :: MakeMaker-모듈 Makefile 만들기</target>
        </trans-unit>
        <trans-unit id="e6df2289ed559a450ea26d00c0d0e4cee5508740" translate="yes" xml:space="preserve">
          <source>ExtUtils::MakeMaker subclass for customization</source>
          <target state="translated">사용자 정의를위한 ExtUtils :: MakeMaker 서브 클래스</target>
        </trans-unit>
        <trans-unit id="c60c158c602a516f81a6ae9bca65b474a071fe74" translate="yes" xml:space="preserve">
          <source>ExtUtils::MakeMaker::Config</source>
          <target state="translated">ExtUtils::MakeMaker::Config</target>
        </trans-unit>
        <trans-unit id="d3014ef697f5ada430bc56427a7b9caae4e6e02c" translate="yes" xml:space="preserve">
          <source>ExtUtils::MakeMaker::Config - Wrapper around Config.pm</source>
          <target state="translated">ExtUtils :: MakeMaker :: Config-Config.pm 주위 래퍼</target>
        </trans-unit>
        <trans-unit id="9ccd57b3ecc86c99f88666a4cbfa65fcc3d9511f" translate="yes" xml:space="preserve">
          <source>ExtUtils::MakeMaker::FAQ</source>
          <target state="translated">ExtUtils::MakeMaker::FAQ</target>
        </trans-unit>
        <trans-unit id="30461ff8ef34cae5ca5dc88e0a98e8273138112a" translate="yes" xml:space="preserve">
          <source>ExtUtils::MakeMaker::FAQ - Frequently Asked Questions About MakeMaker</source>
          <target state="translated">ExtUtils :: MakeMaker :: FAQ-MakeMaker에 대한 질문과 대답</target>
        </trans-unit>
        <trans-unit id="51e7eb76f593803326b81c0b7eddf02ecc2dca1f" translate="yes" xml:space="preserve">
          <source>ExtUtils::MakeMaker::Locale</source>
          <target state="translated">ExtUtils::MakeMaker::Locale</target>
        </trans-unit>
        <trans-unit id="95b89cbe7015202586c4481ef682b645c3e89ac2" translate="yes" xml:space="preserve">
          <source>ExtUtils::MakeMaker::Locale - bundled Encode::Locale</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c91ea2c313a203d7ca441511bcd463e56db95e2e" translate="yes" xml:space="preserve">
          <source>ExtUtils::MakeMaker::Tutorial</source>
          <target state="translated">ExtUtils::MakeMaker::Tutorial</target>
        </trans-unit>
        <trans-unit id="a40c04994e7a37e13af27331a991a5aa646c9b73" translate="yes" xml:space="preserve">
          <source>ExtUtils::MakeMaker::Tutorial - Writing a module with MakeMaker</source>
          <target state="translated">ExtUtils :: MakeMaker :: Tutorial-MakeMaker로 모듈 작성</target>
        </trans-unit>
        <trans-unit id="b357eaa10f6891f76e970ffb5f2bf93f495e4a17" translate="yes" xml:space="preserve">
          <source>ExtUtils::Manifest</source>
          <target state="translated">ExtUtils::Manifest</target>
        </trans-unit>
        <trans-unit id="c2882ccdd5737a1b3d2f4dc3d31014e58dd46653" translate="yes" xml:space="preserve">
          <source>ExtUtils::Manifest - Utilities to write and check a MANIFEST file</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3226afa87ddca4ba7171d22b9f2b78d098b58f76" translate="yes" xml:space="preserve">
          <source>ExtUtils::Manifest - utilities to write and check a MANIFEST file</source>
          <target state="translated">ExtUtils :: Manifest-매니페스트 파일을 작성하고 확인하는 유틸리티</target>
        </trans-unit>
        <trans-unit id="5668766f97bcd05c6bdb7c965133d9727537b625" translate="yes" xml:space="preserve">
          <source>ExtUtils::Manifest exports no functions by default. The following are exported on request</source>
          <target state="translated">ExtUtils :: Manifest는 기본적으로 함수를 내 보내지 않습니다. 다음은 요청시 수출됩니다</target>
        </trans-unit>
        <trans-unit id="bdbe036be435e29a3c3c98d79b72ee067d6d642d" translate="yes" xml:space="preserve">
          <source>ExtUtils::Manifest exports no functions by default. The following are exported on request:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d683dc5b10b650f60d4d9d340eeb5154c9725c7" translate="yes" xml:space="preserve">
          <source>ExtUtils::Miniperl</source>
          <target state="translated">ExtUtils::Miniperl</target>
        </trans-unit>
        <trans-unit id="a62bb061ae9acdfb750b378b1f62a97de2f7165a" translate="yes" xml:space="preserve">
          <source>ExtUtils::Miniperl - write the C code for miniperlmain.c and perlmain.c</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9fc3f091d177ebdf88e70a7d90d1a0e96a9ebda2" translate="yes" xml:space="preserve">
          <source>ExtUtils::Miniperl - write the C code for perlmain.c</source>
          <target state="translated">ExtUtils :: Miniperl-perlmain.c에 대한 C 코드 작성</target>
        </trans-unit>
        <trans-unit id="1c32c7f84e8dc881e25db6f6d50706131d6d8758" translate="yes" xml:space="preserve">
          <source>ExtUtils::Mkbootstrap</source>
          <target state="translated">ExtUtils::Mkbootstrap</target>
        </trans-unit>
        <trans-unit id="bbfa5e60d2823fa64c959ef9034364b18eddc3e9" translate="yes" xml:space="preserve">
          <source>ExtUtils::Mkbootstrap - make a bootstrap file for use by DynaLoader</source>
          <target state="translated">ExtUtils :: Mkbootstrap-DynaLoader에서 사용할 부트 스트랩 파일 만들기</target>
        </trans-unit>
        <trans-unit id="6719b923f8e283bd552384bd5af81cadfef85883" translate="yes" xml:space="preserve">
          <source>ExtUtils::Mksymlists</source>
          <target state="translated">ExtUtils::Mksymlists</target>
        </trans-unit>
        <trans-unit id="15ab523f4d3c60af2d551125aa18471a39d07e7c" translate="yes" xml:space="preserve">
          <source>ExtUtils::Mksymlists - write linker options files for dynamic extension</source>
          <target state="translated">ExtUtils :: Mksymlists-동적 확장을위한 링커 옵션 파일 작성</target>
        </trans-unit>
        <trans-unit id="dac17ac78f3539cbb386b1e56ee2b529662e80e5" translate="yes" xml:space="preserve">
          <source>ExtUtils::Packlist</source>
          <target state="translated">ExtUtils::Packlist</target>
        </trans-unit>
        <trans-unit id="2fd0b32af3911843b6577751529d4515df509939" translate="yes" xml:space="preserve">
          <source>ExtUtils::Packlist - manage .packlist files</source>
          <target state="translated">ExtUtils :: Packlist-.packlist 파일 관리</target>
        </trans-unit>
        <trans-unit id="b6cb6e0433e264b8d9ae4674f7b9ee20c7cc9a0e" translate="yes" xml:space="preserve">
          <source>ExtUtils::Packlist provides a standard way to manage .packlist files. Functions are provided to read and write .packlist files. The original .packlist format is a simple list of absolute pathnames, one per line. In addition, this package supports an extended format, where as well as a filename each line may contain a list of attributes in the form of a space separated list of key=value pairs. This is used by the installperl script to differentiate between files and links, for example.</source>
          <target state="translated">ExtUtils :: Packlist는 .packlist 파일을 관리하는 표준 방법을 제공합니다. .packlist 파일을 읽고 쓰는 기능이 제공됩니다. 원래 .packlist 형식은 한 줄에 하나씩 절대 경로 이름의 간단한 목록입니다. 또한이 패키지는 확장 형식을 지원합니다. 여기서 파일 이름뿐만 아니라 각 줄은 공백으로 구분 된 키 = 값 쌍 목록 형식의 속성 목록을 포함 할 수 있습니다. 예를 들어 installperl 스크립트에서 파일과 링크를 구별하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="c27f6826e3e72b1481e238cd590b927b9a8c7674" translate="yes" xml:space="preserve">
          <source>ExtUtils::ParseXS</source>
          <target state="translated">ExtUtils::ParseXS</target>
        </trans-unit>
        <trans-unit id="a0bc42ea6560aea10d0d6a20cba29d9f0d9456c6" translate="yes" xml:space="preserve">
          <source>ExtUtils::ParseXS - converts Perl XS code into C code</source>
          <target state="translated">ExtUtils :: ParseXS-Perl XS 코드를 C 코드로 변환</target>
        </trans-unit>
        <trans-unit id="03159689beb1e83556a0d792cc8509ee6422dca5" translate="yes" xml:space="preserve">
          <source>ExtUtils::ParseXS::Constants</source>
          <target state="translated">ExtUtils::ParseXS::Constants</target>
        </trans-unit>
        <trans-unit id="cf5795919350a424f2fdddb099257f73945e1a05" translate="yes" xml:space="preserve">
          <source>ExtUtils::ParseXS::Constants - Initialization values for some globals</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34afc1a15abc59a30f0d297ced64f7e5d7089b18" translate="yes" xml:space="preserve">
          <source>ExtUtils::ParseXS::Eval</source>
          <target state="translated">ExtUtils::ParseXS::Eval</target>
        </trans-unit>
        <trans-unit id="b114f3881b5796ad889d6328dec9b5e233d60f40" translate="yes" xml:space="preserve">
          <source>ExtUtils::ParseXS::Eval - Clean package to evaluate code in</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd75ce4683a9aa22ba6c700ca353d47d601b2384" translate="yes" xml:space="preserve">
          <source>ExtUtils::ParseXS::Utilities</source>
          <target state="translated">ExtUtils::ParseXS::Utilities</target>
        </trans-unit>
        <trans-unit id="92bd9c932412ce4f8422b75c6801374ed24acdf2" translate="yes" xml:space="preserve">
          <source>ExtUtils::ParseXS::Utilities - Subroutines used with ExtUtils::ParseXS</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="244cbf4be92c60aff1ddbf35e6ab53db17abecdd" translate="yes" xml:space="preserve">
          <source>ExtUtils::Typemaps</source>
          <target state="translated">ExtUtils::Typemaps</target>
        </trans-unit>
        <trans-unit id="d3f0982ef48a7ff5c4bec28af01b2fc9c1b9e324" translate="yes" xml:space="preserve">
          <source>ExtUtils::Typemaps - Read/Write/Modify Perl/XS typemap files</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10f91cda6d284fa20124d5451bc24b51143532bb" translate="yes" xml:space="preserve">
          <source>ExtUtils::Typemaps::Cmd</source>
          <target state="translated">ExtUtils::Typemaps::Cmd</target>
        </trans-unit>
        <trans-unit id="795fa4eef7e8ecb9427bfc09a6b1dcc43d73ee93" translate="yes" xml:space="preserve">
          <source>ExtUtils::Typemaps::Cmd - Quick commands for handling typemaps</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd9969ccb534d5e151d4ccb9e73ab988320ed4b6" translate="yes" xml:space="preserve">
          <source>ExtUtils::Typemaps::InputMap</source>
          <target state="translated">ExtUtils::Typemaps::InputMap</target>
        </trans-unit>
        <trans-unit id="c325c829d365d7d7a6812090290f7b83b3596b1c" translate="yes" xml:space="preserve">
          <source>ExtUtils::Typemaps::InputMap - Entry in the INPUT section of a typemap</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="237c9b6dbebb9b4ed396f0dce6a67fb3af72515a" translate="yes" xml:space="preserve">
          <source>ExtUtils::Typemaps::OutputMap</source>
          <target state="translated">ExtUtils::Typemaps::OutputMap</target>
        </trans-unit>
        <trans-unit id="661bb31eef11ca983e8d0917113f95b3a60d7add" translate="yes" xml:space="preserve">
          <source>ExtUtils::Typemaps::OutputMap - Entry in the OUTPUT section of a typemap</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6feaee53a536421bc2b64881bb22fc287b99e2b4" translate="yes" xml:space="preserve">
          <source>ExtUtils::Typemaps::Type</source>
          <target state="translated">ExtUtils::Typemaps::Type</target>
        </trans-unit>
        <trans-unit id="42aba54068b70ea208aa1cd601ae498fb974dba4" translate="yes" xml:space="preserve">
          <source>ExtUtils::Typemaps::Type - Entry in the TYPEMAP section of a typemap</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="973e953fd629b20b4ca87588491035c2a7556141" translate="yes" xml:space="preserve">
          <source>ExtUtils::XSSymSet</source>
          <target state="translated">ExtUtils::XSSymSet</target>
        </trans-unit>
        <trans-unit id="f716c096c97d144856a93624d2a5d5bd094c5cae" translate="yes" xml:space="preserve">
          <source>ExtUtils::XSSymSet - keep sets of symbol names palatable to the VMS linker</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f01cb2601da9ca9e6f049c24d0b16efdb7998074" translate="yes" xml:space="preserve">
          <source>ExtUtils::testlib</source>
          <target state="translated">ExtUtils::testlib</target>
        </trans-unit>
        <trans-unit id="c819a99ea2471502c8a0521252e569cacdf6e150" translate="yes" xml:space="preserve">
          <source>ExtUtils::testlib - add blib/* directories to @INC</source>
          <target state="translated">ExtUtils :: testlib-@INC에 blib / * 디렉토리 추가</target>
        </trans-unit>
        <trans-unit id="1a8525beca2f4f9e103dd4931ef378f407141d6e" translate="yes" xml:space="preserve">
          <source>Extend File Glob to Allow Input and Output Files</source>
          <target state="translated">입력 및 출력 파일을 허용하도록 파일 글로브 확장</target>
        </trans-unit>
        <trans-unit id="82d26601ba012fb977fae11b9393fa91fb289790" translate="yes" xml:space="preserve">
          <source>Extend your pattern's legibility by permitting whitespace and comments. Details in &lt;a href=&quot;#%2Fx-and-%2Fxx&quot;&gt;&quot;/x and /xx&quot;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fab77626f5cddcb8bbb657382d4af81d5cdf9048" translate="yes" xml:space="preserve">
          <source>Extend your pattern's legibility by permitting whitespace and comments. Details in &lt;a href=&quot;#%2fx&quot;&gt;/x&lt;/a&gt;</source>
          <target state="translated">공백과 주석을 허용하여 패턴의 가독성을 확장하십시오. &lt;a href=&quot;#%2fx&quot;&gt;/ x의&lt;/a&gt; 세부 사항</target>
        </trans-unit>
        <trans-unit id="1d44d230ea6fe0935f3b1482cff787c6266b3d3b" translate="yes" xml:space="preserve">
          <source>Extended &lt;code&gt;expect&lt;/code&gt; . This is a hash reference with four allowed keys, &lt;code&gt;mode&lt;/code&gt; , &lt;code&gt;timeout&lt;/code&gt; , &lt;code&gt;reuse&lt;/code&gt; , and &lt;code&gt;talk&lt;/code&gt; .</source>
          <target state="translated">확장 &lt;code&gt;expect&lt;/code&gt; . 이것은 허용되는 4 개의 키, &lt;code&gt;mode&lt;/code&gt; , &lt;code&gt;timeout&lt;/code&gt; , &lt;code&gt;reuse&lt;/code&gt; 및 &lt;code&gt;talk&lt;/code&gt; 가있는 해시 참조입니다 .</target>
        </trans-unit>
        <trans-unit id="efc98640815d67fe8a62500e0c5368b07039dddc" translate="yes" xml:space="preserve">
          <source>Extended Bracketed Character Classes</source>
          <target state="translated">확장 된 브라켓 문자 클래스</target>
        </trans-unit>
        <trans-unit id="08ad66702e505f4acfeb7ef02a28aef2a444692f" translate="yes" xml:space="preserve">
          <source>Extended Grapheme Clusters (Logical characters)</source>
          <target state="translated">확장 그래프 클러스터 (논리 문자)</target>
        </trans-unit>
        <trans-unit id="b408f65a0dc6251545ba8a1cae00a09cef180586" translate="yes" xml:space="preserve">
          <source>Extended Patterns</source>
          <target state="translated">확장 패턴</target>
        </trans-unit>
        <trans-unit id="5acbb8b9cc41fceabb939a9490161468292c9ddc" translate="yes" xml:space="preserve">
          <source>Extended Unix Character. See ISO-2022.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57638586a902beff6d532df64e0c7307238ec6d1" translate="yes" xml:space="preserve">
          <source>Extended description and discussion of the program or functions, or the body of the documentation for man pages that document something else. If particularly long, it's a good idea to break this up into subsections &lt;code&gt;=head2&lt;/code&gt; directives like:</source>
          <target state="translated">프로그램이나 기능에 대한 자세한 설명과 토론, 또는 다른 것을 문서화하는 매뉴얼 페이지의 설명서 본문. 특히 길다면 이것을 다음 과 같은 하위 섹션 &lt;code&gt;=head2&lt;/code&gt; 지시어 로 나누는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="e1eee637af0775263c15116e6a9a092f2dd1ed43" translate="yes" xml:space="preserve">
          <source>Extended integer, Perl style. This can be either an optional leading plus or minus sign, followed by a sequence of digits, or an octal string (a zero, optionally followed by '0', '1', .. '7'), or a hexadecimal string (&lt;code&gt;0x&lt;/code&gt; followed by '0' .. '9', 'a' .. 'f', case insensitive), or a binary string (&lt;code&gt;0b&lt;/code&gt; followed by a series of '0' and '1').</source>
          <target state="translated">확장 정수, Perl 스타일. 선택적인 선행 더하기 또는 빼기 부호, 그 뒤에 일련의 숫자 또는 8 진 문자열 (0, 선택적으로 '0', '1', .. '7') 또는 16 진 문자열 ( &lt;code&gt;0x&lt;/code&gt; 뒤에 '0'.. '9', 'a'.. 'f', 대소 문자 구분 안 함) 또는 이진 문자열 ( &lt;code&gt;0b&lt;/code&gt; 뒤에 일련의 '0'및 '1') 이옵니다 .</target>
        </trans-unit>
        <trans-unit id="7f8a27621bd1b83106ef3b26b5852eb1064f0fc5" translate="yes" xml:space="preserve">
          <source>Extended processing of command line options</source>
          <target state="translated">명령 줄 옵션의 확장 된 처리</target>
        </trans-unit>
        <trans-unit id="5db438e4dc97c2c680eb06228229b5484c1bdab3" translate="yes" xml:space="preserve">
          <source>Extending and Embedding Test::More</source>
          <target state="translated">테스트 확장 및 포함 :: 더</target>
        </trans-unit>
        <trans-unit id="8093cc064296db81eb0f5514264d7ee6d955b145" translate="yes" xml:space="preserve">
          <source>Extending it to csh patterns is left as an exercise to the reader.</source>
          <target state="translated">그것을 csh 패턴으로 확장하는 것은 독자에게 연습으로 남습니다.</target>
        </trans-unit>
        <trans-unit id="4e50bd25f128e6a96c634dc99854b32ea96ab716" translate="yes" xml:space="preserve">
          <source>Extending your Extension</source>
          <target state="translated">확장 연장</target>
        </trans-unit>
        <trans-unit id="4f8331dd312ba43f266e8a83a2d73cbbbec52b3f" translate="yes" xml:space="preserve">
          <source>Extension Layers</source>
          <target state="translated">확장 레이어</target>
        </trans-unit>
        <trans-unit id="7e80c98508d4f62822b0432554091a536a41d48e" translate="yes" xml:space="preserve">
          <source>Extension Modules</source>
          <target state="translated">확장 모듈</target>
        </trans-unit>
        <trans-unit id="bd951e4e9e05b88a206b50063022ae727663d6c9" translate="yes" xml:space="preserve">
          <source>Extension based on</source>
          <target state="translated">기반 확장</target>
        </trans-unit>
        <trans-unit id="c6f2131d44d90eead55c47a30930686fccd53dcc" translate="yes" xml:space="preserve">
          <source>Extension based on .h and .c files</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67518e197246f71238efe738515b0409050e6007" translate="yes" xml:space="preserve">
          <source>Extension based on _.h_ and _.c_ files</source>
          <target state="translated">_.h_ 및 _.c_ 파일 기반 확장</target>
        </trans-unit>
        <trans-unit id="4711cbf045a57cbff83b6f9f271bd795fbb6b53d" translate="yes" xml:space="preserve">
          <source>Extension methods</source>
          <target state="translated">확장 방법</target>
        </trans-unit>
        <trans-unit id="cce4d271f69e77a8f0acdb625f0076753f28069c" translate="yes" xml:space="preserve">
          <source>Extension modules are written in C (or a mix of Perl and C). They are usually dynamically loaded into Perl if and when you need them, but may also be linked in statically. Supported extension modules include Socket, Fcntl, and POSIX.</source>
          <target state="translated">확장 모듈은 C (또는 Perl과 C의 혼합)로 작성됩니다. 필요한 경우 그리고 필요할 때 일반적으로 Perl에 동적으로로드되지만 정적으로 연결될 수도 있습니다. 지원되는 확장 모듈에는 Socket, Fcntl 및 POSIX가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="60ffce38ec556078960f77c6601f9f4334d9b141" translate="yes" xml:space="preserve">
          <source>Extension modules can also hook into the Perl parser to define new kinds of compound statements. These are introduced by a keyword which the extension recognizes, and the syntax following the keyword is defined entirely by the extension. If you are an implementor, see &lt;a href=&quot;perlapi#PL_keyword_plugin&quot;&gt;&quot;PL_keyword_plugin&quot; in perlapi&lt;/a&gt; for the mechanism. If you are using such a module, see the module's documentation for details of the syntax that it defines.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5c486c72e2c41ab9d29ece60988b5356674e74f" translate="yes" xml:space="preserve">
          <source>Extension modules can also hook into the Perl parser to define new kinds of compound statements. These are introduced by a keyword which the extension recognizes, and the syntax following the keyword is defined entirely by the extension. If you are an implementor, see &lt;a href=&quot;perlapi#PL_keyword_plugin&quot;&gt;PL_keyword_plugin in perlapi&lt;/a&gt; for the mechanism. If you are using such a module, see the module's documentation for details of the syntax that it defines.</source>
          <target state="translated">확장 모듈은 Perl 구문 분석기에 연결하여 새로운 종류의 복합 명령문을 정의 할 수도 있습니다. 이것들은 확장 기능이 인식하는 키워드에 의해 소개되고, 키워드 다음의 구문은 전적으로 확장 기능에 의해 정의됩니다. 구현 &lt;a href=&quot;perlapi#PL_keyword_plugin&quot;&gt;자인&lt;/a&gt; 경우 메커니즘 에 대해서는 perlapi의 PL_keyword_plugin 을 참조하십시오 . 이러한 모듈을 사용하는 경우 해당 모듈에서 정의한 구문에 대한 자세한 내용은 모듈 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="b6efb310f19bf6564f19089c880a0a0d87286db9" translate="yes" xml:space="preserve">
          <source>Extension modules can also hook into the Perl parser to define new kinds of keyword-headed expression. These may look like functions, but may also look completely different. The syntax following the keyword is defined entirely by the extension. If you are an implementor, see &lt;a href=&quot;perlapi#PL_keyword_plugin&quot;&gt;&quot;PL_keyword_plugin&quot; in perlapi&lt;/a&gt; for the mechanism. If you are using such a module, see the module's documentation for details of the syntax that it defines.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17db2bf16378aa10db2e67a8c2600f3a25122fec" translate="yes" xml:space="preserve">
          <source>Extension modules can also hook into the Perl parser to define new kinds of keyword-headed expression. These may look like functions, but may also look completely different. The syntax following the keyword is defined entirely by the extension. If you are an implementor, see &lt;a href=&quot;perlapi#PL_keyword_plugin&quot;&gt;PL_keyword_plugin in perlapi&lt;/a&gt; for the mechanism. If you are using such a module, see the module's documentation for details of the syntax that it defines.</source>
          <target state="translated">확장 모듈은 Perl 파서에 연결하여 새로운 종류의 키워드 머리 식을 정의 할 수도 있습니다. 이것들은 기능처럼 보일 수도 있지만 완전히 다르게 보일 수도 있습니다. 키워드 다음의 구문은 전적으로 확장자로 정의됩니다. 구현 &lt;a href=&quot;perlapi#PL_keyword_plugin&quot;&gt;자인&lt;/a&gt; 경우 메커니즘 에 대해서는 perlapi의 PL_keyword_plugin 을 참조하십시오 . 이러한 모듈을 사용하는 경우 해당 모듈에서 정의한 구문에 대한 자세한 내용은 모듈 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="656bcfe284e2da39c77d4fdab55b16ad3c654719" translate="yes" xml:space="preserve">
          <source>Extensions</source>
          <target state="translated">Extensions</target>
        </trans-unit>
        <trans-unit id="6e975483dac372a5ca9dfd4b8e5e57b37a1180dd" translate="yes" xml:space="preserve">
          <source>Extensions and XS are, in theory, buildable by anyone using free tools. In practice, many don't, as users of the Acorn platform are used to binary distributions. MakeMaker does run, but no available make currently copes with MakeMaker's makefiles; even if and when this should be fixed, the lack of a Unix-like shell will cause problems with makefile rules, especially lines of the form &lt;code&gt;cd
sdbm &amp;amp;&amp;amp; make all&lt;/code&gt; , and anything using quoting.</source>
          <target state="translated">확장 기능과 XS는 이론적으로 무료 도구를 사용하는 사람이라면 누구나 만들 수 있습니다. 실제로, Acorn 플랫폼의 사용자가 바이너리 배포판에 익숙하기 때문에 많은 사람들이 그렇지 않습니다. MakeMaker는 실행되지만 현재 사용 가능한 make는 MakeMaker의 makefile에 대응하지 않습니다. 이 문제를 수정해야 할 때에도 유닉스 계열 쉘이 없으면 makefile 규칙, 특히 &lt;code&gt;cd sdbm &amp;amp;&amp;amp; make all&lt;/code&gt; 형식의 줄 과 인용 부호를 사용하는 모든 문제가 발생합니다 .</target>
        </trans-unit>
        <trans-unit id="23912b80f63053ec1a446ffda41e3d5c9d541b79" translate="yes" xml:space="preserve">
          <source>Extensions and XS are, in theory, buildable by anyone using free tools. In practice, many don't, as users of the Acorn platform are used to binary distributions. MakeMaker does run, but no available make currently copes with MakeMaker's makefiles; even if and when this should be fixed, the lack of a Unix-like shell will cause problems with makefile rules, especially lines of the form &lt;code&gt;cd sdbm &amp;amp;&amp;amp; make all&lt;/code&gt;, and anything using quoting.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8be19ac765682f953ef7dfbb23fec79e7869c76" translate="yes" xml:space="preserve">
          <source>Extensions may be built either using the contents of the perl source directory tree or from the installed perl library. The recommended way is to build extensions after you have run 'make install' on perl itself. You can do that in any directory on your hard disk that is not below the perl source tree. The support for extensions below the ext directory of the perl distribution is only good for the standard extensions that come with perl.</source>
          <target state="translated">확장은 perl 소스 디렉토리 트리의 내용을 사용하거나 설치된 perl 라이브러리에서 빌드 할 수 있습니다. 권장되는 방법은 perl 자체에서 'make install'을 실행 한 후 확장을 빌드하는 것입니다. 펄 소스 트리 아래에 있지 않은 하드 디스크의 모든 디렉토리에서이를 수행 할 수 있습니다. perl 배포의 ext 디렉토리 아래 확장에 대한 지원은 perl과 함께 제공되는 표준 확장에만 적합합니다.</target>
        </trans-unit>
        <trans-unit id="fd1105050ae42d352634f9a22fd2cfbe7c3340ac" translate="yes" xml:space="preserve">
          <source>Extensions.U</source>
          <target state="translated">Extensions.U</target>
        </trans-unit>
        <trans-unit id="8e77bd8de5230e7d94a54f34b54e4ee866ebaf07" translate="yes" xml:space="preserve">
          <source>External Subroutines (XS)</source>
          <target state="translated">외부 서브 루틴 (XS)</target>
        </trans-unit>
        <trans-unit id="fe58f6fb5713c9d9970ba20c8c7e99ac12d8ebd1" translate="yes" xml:space="preserve">
          <source>External scripts may be called by their basename. Perl will try the same extensions as when processing &lt;b&gt;-S&lt;/b&gt; command-line switch.</source>
          <target state="translated">외부 스크립트는 기본 이름으로 호출 할 수 있습니다. Perl은 &lt;b&gt;-S&lt;/b&gt; 명령 행 스위치를 처리 할 때와 동일한 확장을 시도합니다 .</target>
        </trans-unit>
        <trans-unit id="ac98225101654b1670f972aaf6165f07d86a4dc2" translate="yes" xml:space="preserve">
          <source>External scripts starting with &lt;code&gt;#!&lt;/code&gt; or &lt;code&gt;extproc &lt;/code&gt; will be executed directly, without calling the shell, by calling the program specified on the rest of the first line.</source>
          <target state="translated">&lt;code&gt;#!&lt;/code&gt; 시작하는 외부 스크립트 또는 &lt;code&gt;extproc &lt;/code&gt; 은 쉘을 호출하지 않고 첫 번째 줄의 나머지 부분에 지정된 프로그램을 호출하여 직접 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="26bf182753057236397eb723fd4891db5f117a3e" translate="yes" xml:space="preserve">
          <source>External subroutines (XSUBs) that maintain their own global state may not work correctly. Such XSUBs will either need to maintain locks to protect simultaneous access to global data from different pseudo-processes, or maintain all their state on the Perl symbol table, which is copied naturally when fork() is called. A callback mechanism that provides extensions an opportunity to clone their state will be provided in the near future.</source>
          <target state="translated">자체 글로벌 상태를 유지하는 외부 서브 루틴 (XSUB)은 올바르게 작동하지 않을 수 있습니다. 이러한 XSUB는 다른 의사 프로세스에서 글로벌 데이터에 대한 동시 액세스를 보호하기 위해 잠금을 유지하거나 fork ()가 호출 될 때 자연스럽게 복사되는 Perl 기호 테이블에서 모든 상태를 유지해야합니다. 확장 기능으로 상태를 복제 할 수있는 기회를 제공하는 콜백 메커니즘이 조만간 제공 될 예정입니다.</target>
        </trans-unit>
        <trans-unit id="fc2399f06f4a8800f1e9f8c63e75b404573137c6" translate="yes" xml:space="preserve">
          <source>Extname</source>
          <target state="translated">Extname</target>
        </trans-unit>
        <trans-unit id="38bd9c2b38d963363075f657df2649a5a865d34f" translate="yes" xml:space="preserve">
          <source>Extra RECNO Methods</source>
          <target state="translated">여분의 RECNO 방법</target>
        </trans-unit>
        <trans-unit id="080170d5c582217b07d6b630ccf123361bce391b" translate="yes" xml:space="preserve">
          <source>Extra arguments given to &lt;code&gt;subtest&lt;/code&gt; are passed to the callback. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f428c72b95856a35d58cb6523d1d9bf0d7e2e713" translate="yes" xml:space="preserve">
          <source>Extra debugging of how tries execute.</source>
          <target state="translated">시도 실행 방법에 대한 추가 디버깅</target>
        </trans-unit>
        <trans-unit id="642e34f2d2485598d6a1289983f49ac33667a504" translate="yes" xml:space="preserve">
          <source>Extra debugging options</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d0f7f868e14cfcf2986def25df2bc4196200327" translate="yes" xml:space="preserve">
          <source>Extra layers can be inserted to process the data as it flows through. This was the driving need for including the scheme in perl 5.7.0+ - we needed a mechanism to allow data to be translated between perl's internal encoding (conceptually at least Unicode as UTF-8), and the &quot;native&quot; format used by the system. This is provided by the &quot;:encoding(xxxx)&quot; layer which typically sits above the buffering layer.</source>
          <target state="translated">데이터가 통과 할 때 데이터를 처리하기 위해 추가 레이어를 삽입 할 수 있습니다. 이것은 perl 5.7.0+의 체계를 포함시키기위한 원동력이되었습니다.-perl의 내부 인코딩 (개념적으로는 UTF-8과 같은 개념적으로 최소한 UTF-8)과 체계. 이것은 일반적으로 버퍼링 레이어 위에있는 &quot;: encoding (xxxx)&quot;레이어에 의해 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="678bd1bdccc15e114b793e04d18d631885eca63c" translate="yes" xml:space="preserve">
          <source>Extract delimited text sequences from strings.</source>
          <target state="translated">문자열에서 구분 된 텍스트 시퀀스를 추출하십시오.</target>
        </trans-unit>
        <trans-unit id="7254948dbbd318f1e97d0a1eeb40a1eb2d41c79b" translate="yes" xml:space="preserve">
          <source>Extract it like this</source>
          <target state="translated">이렇게 추출</target>
        </trans-unit>
        <trans-unit id="05a2f0e61aa11822c7799b10cf19bd9f231551af" translate="yes" xml:space="preserve">
          <source>Extract it to a spaceless path but not into the perl build source. Don't extract it into the same directory as celib. Make a copy of the &quot;wince-arm-pocket-wce300&quot; folder and rename the copy to &quot;wince-arm-pocket-wce400&quot;. This is a hack so we can build a CE 4.0 binary by linking in CE 3.0 ARM asm; the linker doesn't care. Windows Mobile/WinCE are backwards compatible with machine code like Desktop Windows.</source>
          <target state="translated">공백이없는 경로로 추출하지만 perl 빌드 소스에는 추출하지 마십시오. celib와 동일한 디렉토리에 추출하지 마십시오. &quot;wince-arm-pocket-wce300&quot;폴더의 사본을 작성하고 사본의 이름을 &quot;wince-arm-pocket-wce400&quot;으로 바꾸십시오. 이것은 해킹이므로 CE 3.0 ARM asm에서 링크하여 CE 4.0 바이너리를 빌드 할 수 있습니다. 링커는 상관하지 않습니다. Windows Mobile / WinCE는 데스크톱 Windows와 같은 기계 코드와 호환됩니다.</target>
        </trans-unit>
        <trans-unit id="7749ca362c5039000e30519eec908556e69a793e" translate="yes" xml:space="preserve">
          <source>Extract it to a spaceless path but not into the perl build source. I call this directory &quot;celib-palm-3.0&quot; but in the GitHub snapshot it will be called &quot;celib-master&quot;. Make a copy of the &quot;wince-arm-pocket-wce300-release&quot; folder and rename the copy to &quot;wince-arm-pocket-wce400&quot;. This is a hack so we can build a CE 4.0 binary by linking in CE 3.0 ARM asm; the linker doesn't care. Windows Mobile/WinCE are backwards compatible with machine code like Desktop Windows.</source>
          <target state="translated">공백이없는 경로로 추출하지만 perl 빌드 소스에는 추출하지 마십시오. 이 디렉토리를 &quot;celib-palm-3.0&quot;이라고 부르지 만 GitHub 스냅 샷에서는 &quot;celib-master&quot;라고합니다. &quot;wince-arm-pocket-wce300-release&quot;폴더의 사본을 작성하고 사본의 이름을 &quot;wince-arm-pocket-wce400&quot;으로 바꾸십시오. 이것은 해킹이므로 CE 3.0 ARM asm에서 링크하여 CE 4.0 바이너리를 빌드 할 수 있습니다. 링커는 상관하지 않습니다. Windows Mobile / WinCE는 데스크톱 Windows와 같은 기계 코드와 호환됩니다.</target>
        </trans-unit>
        <trans-unit id="6a5aa60c177bb5d75235a8c111f9e4b6cea8ac1c" translate="yes" xml:space="preserve">
          <source>Extract selected sections of POD from input</source>
          <target state="translated">입력에서 선택된 POD 섹션 추출</target>
        </trans-unit>
        <trans-unit id="48348ed6315b959bdb6c19c5f46693033fe9a289" translate="yes" xml:space="preserve">
          <source>Extract this object, optionally to an alternative name.</source>
          <target state="translated">선택적으로 대체 이름으로이 오브젝트를 추출하십시오.</target>
        </trans-unit>
        <trans-unit id="700d36da6316894ea4553b7a4764bc2e9b2ffb63" translate="yes" xml:space="preserve">
          <source>Extracted from core distribution for publishing on the CPAN by S&amp;eacute;bastien Aperghis-Tramoni &amp;lt;sebastien (at) aperghis.net&amp;gt;.</source>
          <target state="translated">S&amp;eacute;bastien Aperghis-Tramoni &amp;lt;sebastien (at) aperghis.net&amp;gt;에 의해 CPAN에 게시하기 위해 핵심 배포본에서 추출했습니다.</target>
        </trans-unit>
        <trans-unit id="8d01377458bb164941cbab45b0257bce76f2aaf1" translate="yes" xml:space="preserve">
          <source>Extracting Version Numbers from Perl Modules</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33342b226b64c6cbc40d180e3ba186ad44a5f06f" translate="yes" xml:space="preserve">
          <source>Extracting matches</source>
          <target state="translated">일치 추출</target>
        </trans-unit>
        <trans-unit id="16e9f64b08e09da9325dc889d58611a8376664da" translate="yes" xml:space="preserve">
          <source>Extracts a substring out of EXPR and returns it. First character is at offset zero. If OFFSET is negative, starts that far back from the end of the string. If LENGTH is omitted, returns everything through the end of the string. If LENGTH is negative, leaves that many characters off the end of the string.</source>
          <target state="translated">EXPR에서 하위 문자열을 추출하여 리턴합니다. 첫 문자는 오프셋 0입니다. OFFSET이 음수이면 문자열 끝에서 멀리 시작합니다. LENGTH를 생략하면 문자열 끝까지 모든 것을 반환합니다. LENGTH가 음수이면 문자열 끝에 많은 문자를 남겨 둡니다.</target>
        </trans-unit>
        <trans-unit id="7e02013b2bc8b8b15efdd928d9932b054c7620a2" translate="yes" xml:space="preserve">
          <source>Extracts the contents of the tar file. The first argument can either be the name of the tar file to create or a reference to an open file handle (e.g. a GLOB reference). All relative paths in the tar file will be created underneath the current working directory.</source>
          <target state="translated">tar 파일의 내용을 추출합니다. 첫 번째 인수는 작성할 tar 파일의 이름이거나 열린 파일 핸들에 대한 참조 (예 : GLOB 참조) 일 수 있습니다. tar 파일의 모든 상대 경로는 현재 작업 디렉토리 아래에 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="885f6e090c877a36591aaa902dd00c6dd7b9efec" translate="yes" xml:space="preserve">
          <source>Extras.U</source>
          <target state="translated">Extras.U</target>
        </trans-unit>
        <trans-unit id="f680827447f98b26a0af418fbc0405801d7796f6" translate="yes" xml:space="preserve">
          <source>Extremely high code points were never specified in any standard, and require an extension to UTF-8 to express, which Perl does. It is likely that programs written in something other than Perl would not be able to read files that contain these; nor would Perl understand files written by something that uses a different extension. For these reasons, there is a separate set of flags that can warn and/or disallow these extremely high code points, even if other above-Unicode ones are accepted. They are the &lt;code&gt;UNICODE_WARN_PERL_EXTENDED&lt;/code&gt; and &lt;code&gt;UNICODE_DISALLOW_PERL_EXTENDED&lt;/code&gt; flags. For more information see &lt;a href=&quot;#UTF8_GOT_PERL_EXTENDED&quot;&gt;&quot;&lt;code&gt;UTF8_GOT_PERL_EXTENDED&lt;/code&gt;&quot;&lt;/a&gt;. Of course &lt;code&gt;UNICODE_DISALLOW_SUPER&lt;/code&gt; will treat all above-Unicode code points, including these, as malformations. (Note that the Unicode standard considers anything above 0x10FFFF to be illegal, but there are standards predating it that allow up to 0x7FFF_FFFF (2**31 -1))</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1a686562152550b10f6394ec5f13fc276de5710" translate="yes" xml:space="preserve">
          <source>Extremely high code points were never specified in any standard, and require an extension to UTF-8 to express, which Perl does. It is likely that programs written in something other than Perl would not be able to read files that contain these; nor would Perl understand files written by something that uses a different extension. For these reasons, there is a separate set of flags that can warn and/or disallow these extremely high code points, even if other above-Unicode ones are accepted. They are the &lt;code&gt;UTF8_WARN_PERL_EXTENDED&lt;/code&gt; and &lt;code&gt;UTF8_DISALLOW_PERL_EXTENDED&lt;/code&gt; flags. For more information see &lt;a href=&quot;#UTF8_GOT_PERL_EXTENDED&quot;&gt;&quot;&lt;code&gt;UTF8_GOT_PERL_EXTENDED&lt;/code&gt;&quot;&lt;/a&gt;. Of course &lt;code&gt;UTF8_DISALLOW_SUPER&lt;/code&gt; will treat all above-Unicode code points, including these, as malformations. (Note that the Unicode standard considers anything above 0x10FFFF to be illegal, but there are standards predating it that allow up to 0x7FFF_FFFF (2**31 -1))</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42f25b6a320c5687fd271f37b1ee97e7d69228f2" translate="yes" xml:space="preserve">
          <source>Extremely similar to open2(), open3() spawns the given $cmd and connects CHLD_OUT for reading from the child, CHLD_IN for writing to the child, and CHLD_ERR for errors. If CHLD_ERR is false, or the same file descriptor as CHLD_OUT, then STDOUT and STDERR of the child are on the same filehandle (this means that an autovivified lexical cannot be used for the STDERR filehandle, see SYNOPSIS). The CHLD_IN will have autoflush turned on.</source>
          <target state="translated">open2 ()와 매우 유사한 open3 ()은 주어진 $ cmd를 생성하고 자식에서 읽기위한 CHLD_OUT, 자식에게 쓰기위한 CHLD_IN, 오류에 대한 CHLD_ERR을 연결합니다. CHLD_ERR이 false이거나 CHLD_OUT과 동일한 파일 디스크립터 인 경우, 하위의 STDOUT 및 STDERR이 동일한 파일 핸들에 있습니다 (이는 자동 활성화 어휘를 STDERR 파일 핸들에 사용할 수 없음을 의미합니다. 시놉시스 참조). CHLD_IN에 자동 세척 기능이 설정되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="92eb55a6ceeed67d784ed90769a2d53fa3c77acb" translate="yes" xml:space="preserve">
          <source>Extremely similar to open2(), open3() spawns the given command and connects $chld_out for reading from the child, $chld_in for writing to the child, and $chld_err for errors. If $chld_err is false, or the same file descriptor as $chld_out, then STDOUT and STDERR of the child are on the same filehandle. This means that an autovivified lexical cannot be used for the STDERR filehandle, but gensym from &lt;a href=&quot;symbol&quot;&gt;Symbol&lt;/a&gt; can be used to vivify a new glob reference, see &lt;a href=&quot;#SYNOPSIS&quot;&gt;&quot;SYNOPSIS&quot;&lt;/a&gt;. The $chld_in will have autoflush turned on.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2122187dffca50e0b79b010ea05ebfa6a4d1181" translate="yes" xml:space="preserve">
          <source>Extshortname</source>
          <target state="translated">Extshortname</target>
        </trans-unit>
        <trans-unit id="e69f20e9f683920d3fb4329abd951e878b1f9372" translate="yes" xml:space="preserve">
          <source>F</source>
          <target state="translated">F</target>
        </trans-unit>
        <trans-unit id="ade1d38216915151ba7db0ce62f3199d7bf8e743" translate="yes" xml:space="preserve">
          <source>F:/bin</source>
          <target state="translated">F:/bin</target>
        </trans-unit>
        <trans-unit id="16a6231368962f338e8f37dfc91ca30753938154" translate="yes" xml:space="preserve">
          <source>FACET FIELDS</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03688ba6aa340b87549088aa5739944cb6b1dc73" translate="yes" xml:space="preserve">
          <source>FAQ</source>
          <target state="translated">FAQ</target>
        </trans-unit>
        <trans-unit id="3f8b9d0d8f1563ce34d8f76abc9faf53ac55bb32" translate="yes" xml:space="preserve">
          <source>FAQs, tricks and tips for &lt;a href=&quot;ExtUtils::MakeMaker&quot;&gt;ExtUtils::MakeMaker&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65569c995a4785c8ee0ddac72f9a5d5496ad6056" translate="yes" xml:space="preserve">
          <source>FAQs, tricks and tips for &lt;code&gt;ExtUtils::MakeMaker&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;ExtUtils::MakeMaker&lt;/code&gt; 대한 FAQ, 요령 및 팁 .</target>
        </trans-unit>
        <trans-unit id="dec5a3344b6b1da0ebe322bd0a2dfc8eb4528955" translate="yes" xml:space="preserve">
          <source>FATAL errors will cause the program to halt (&lt;code&gt;croak&lt;/code&gt; ), since the problem is so severe that it would be dangerous to continue. (This can always be trapped with &lt;code&gt;&lt;a href=&quot;../functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;, but it's not a good idea. Under the circumstances, dying is the best thing to do).</source>
          <target state="translated">치명적 오류는 문제가 너무 심해서 계속 진행하는 것이 위험하기 때문에 프로그램을 중지 ( &lt;code&gt;croak&lt;/code&gt; )시킵니다. (이것은 항상 &lt;code&gt;&lt;a href=&quot;../functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 로 갇힐 수 있지만 좋은 생각은 아닙니다. 상황에서 죽는 것이 가장 좋습니다.)</target>
        </trans-unit>
        <trans-unit id="6b6f2d1eafcc9e88114df946d6ac19bc0f376a0c" translate="yes" xml:space="preserve">
          <source>FATAL errors will cause the program to halt (&lt;code&gt;croak&lt;/code&gt;), since the problem is so severe that it would be dangerous to continue. (This can always be trapped with &lt;code&gt;eval&lt;/code&gt;, but it's not a good idea. Under the circumstances, dying is the best thing to do).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69754788a4c6beb4ec0ff140aa5c158dca3bfa2a" translate="yes" xml:space="preserve">
          <source>FB_CROAK</source>
          <target state="translated">FB_CROAK</target>
        </trans-unit>
        <trans-unit id="b626cf33b4a041c5ce4d521b41bf3a7b58bd485d" translate="yes" xml:space="preserve">
          <source>FB_DEFAULT</source>
          <target state="translated">FB_DEFAULT</target>
        </trans-unit>
        <trans-unit id="757934dd26eb29cb3152a5f387ec3d2edb168405" translate="yes" xml:space="preserve">
          <source>FB_PERLQQ FB_HTMLCREF FB_XMLCREF</source>
          <target state="translated">FB_PERLQQ FB_HTMLCREF FB_XMLCREF</target>
        </trans-unit>
        <trans-unit id="0a74cbd8c5cb0982de1a9bcfa6850e000455346d" translate="yes" xml:space="preserve">
          <source>FB_QUIET</source>
          <target state="translated">FB_QUIET</target>
        </trans-unit>
        <trans-unit id="0dd7f31fe0e5f67c669f4440fb273121e4c806e4" translate="yes" xml:space="preserve">
          <source>FB_WARN</source>
          <target state="translated">FB_WARN</target>
        </trans-unit>
        <trans-unit id="8e8b3f3bb48e9f1566f046dd9abec5d58654f4a5" translate="yes" xml:space="preserve">
          <source>FCNTL</source>
          <target state="translated">FCNTL</target>
        </trans-unit>
        <trans-unit id="47dadeeeb2bc9f5421eaa6bbbe50810a393d4c66" translate="yes" xml:space="preserve">
          <source>FEATURE BUNDLES</source>
          <target state="translated">기능 번들</target>
        </trans-unit>
        <trans-unit id="ec8e87c2f7d4da8aaca114d6270ea98cb522428f" translate="yes" xml:space="preserve">
          <source>FEATURES = less-&amp;gt;of()</source>
          <target state="translated">특징 = less-&amp;gt; of ()</target>
        </trans-unit>
        <trans-unit id="489edc9160737f1f5321c8439e0d90f85d95108c" translate="yes" xml:space="preserve">
          <source>FEEDBACK</source>
          <target state="translated">FEEDBACK</target>
        </trans-unit>
        <trans-unit id="a721f50a7a690a4a15e9a37c997197a6892fe7c1" translate="yes" xml:space="preserve">
          <source>FETCH</source>
          <target state="translated">FETCH</target>
        </trans-unit>
        <trans-unit id="a36834b47beb7b8fa9cc177881caffbc9273b059" translate="yes" xml:space="preserve">
          <source>FETCH this</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2b96ae35c4cdaf0d5015e044df05ffbf062155e" translate="yes" xml:space="preserve">
          <source>FETCH this, index</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f0417b5bc981c089adeff175d8d240c193a1c5f" translate="yes" xml:space="preserve">
          <source>FETCH this, key</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c895bf1dc50f257bb516434bac2edbda6ee48875" translate="yes" xml:space="preserve">
          <source>FETCHSIZE and STORESIZE are used to provide &lt;code&gt;$#array&lt;/code&gt; and equivalent &lt;code&gt;&lt;a href=&quot;functions/scalar&quot;&gt;scalar(@array)&lt;/a&gt;&lt;/code&gt; access.</source>
          <target state="translated">FETCHSIZE 및 STORESIZE는 &lt;code&gt;$#array&lt;/code&gt; 및 동등한 &lt;code&gt;&lt;a href=&quot;functions/scalar&quot;&gt;scalar(@array)&lt;/a&gt;&lt;/code&gt; 액세스 를 제공하는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="9a55d444e2f42ff3332a7b20892e03b42c0dde45" translate="yes" xml:space="preserve">
          <source>FETCHSIZE and STORESIZE are used to provide &lt;code&gt;$#array&lt;/code&gt; and equivalent &lt;code&gt;scalar(@array)&lt;/code&gt; access.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="655cf3f775d1131bb1cd13d50dcc9384058c7e74" translate="yes" xml:space="preserve">
          <source>FETCHSIZE returned a negative value</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ffdae04b785f3e9a65f525eb253a77d31047f28b" translate="yes" xml:space="preserve">
          <source>FETCHSIZE this</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="845bc45b1b1e5326c244df2ee7648f3ddd776170" translate="yes" xml:space="preserve">
          <source>FETCH_</source>
          <target state="translated">FETCH_</target>
        </trans-unit>
        <trans-unit id="05cf9a52ee9997400d322323b2f4f5f087799c04" translate="yes" xml:space="preserve">
          <source>FIELDS</source>
          <target state="translated">FIELDS</target>
        </trans-unit>
        <trans-unit id="07c257b16606b468b4287bbfd069963fcb6c04a5" translate="yes" xml:space="preserve">
          <source>FIFO</source>
          <target state="translated">FIFO</target>
        </trans-unit>
        <trans-unit id="3f799155fde6a8df0e53471e8ebc22e51aee5205" translate="yes" xml:space="preserve">
          <source>FIFO (named pipe).</source>
          <target state="translated">FIFO (명명 된 파이프).</target>
        </trans-unit>
        <trans-unit id="b4915d3a7ef82abdf96f2b5042452a69b2ea344c" translate="yes" xml:space="preserve">
          <source>FILE</source>
          <target state="translated">FILE</target>
        </trans-unit>
        <trans-unit id="188699dbc4f938b6c1d493b9b4e73beaae160b4d" translate="yes" xml:space="preserve">
          <source>FILE may contain Unicode characters outside the system codepage. Once the file has been created you can use Win32::GetANSIPathName() to get a name that can be passed to system calls and external programs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1037b28078b931a2bcf7381d1504e913f7749ea4" translate="yes" xml:space="preserve">
          <source>FILEGV</source>
          <target state="translated">FILEGV</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
