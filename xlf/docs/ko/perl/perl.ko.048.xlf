<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="perl">
    <body>
      <group id="perl">
        <trans-unit id="2859cc3896fe55bbb891ae357f5f5a8329f3cec3" translate="yes" xml:space="preserve">
          <source>Perl 5.10 added three specials, &lt;code&gt;${^MATCH}&lt;/code&gt;, &lt;code&gt;${^PREMATCH}&lt;/code&gt;, and &lt;code&gt;${^POSTMATCH}&lt;/code&gt; to do the same job but without the global performance penalty. Perl 5.10 only sets these variables if you compile or execute the regular expression with the &lt;code&gt;/p&lt;/code&gt; modifier.</source>
          <target state="translated">Perl 5.10 은 동일한 작업을 수행하지만 전역 성능 저하없이 &lt;code&gt;${^MATCH}&lt;/code&gt; , &lt;code&gt;${^PREMATCH}&lt;/code&gt; 및 &lt;code&gt;${^POSTMATCH}&lt;/code&gt; 세 가지 특수 기능을 추가했습니다 . Perl 5.10은 &lt;code&gt;/p&lt;/code&gt; 수정자를 사용하여 정규식을 컴파일하거나 실행하는 경우에만 이러한 변수를 설정합니다 .</target>
        </trans-unit>
        <trans-unit id="ce44e09ff142e65fee17e89d97567bf27f5d29b1" translate="yes" xml:space="preserve">
          <source>Perl 5.10 also introduced named capture groups and named backreferences. To attach a name to a capturing group, you write either &lt;code&gt;(?&amp;lt;name&amp;gt;...)&lt;/code&gt; or &lt;code&gt;(?'name'...)&lt;/code&gt;. The backreference may then be written as &lt;code&gt;\g{name}&lt;/code&gt; . It is permissible to attach the same name to more than one group, but then only the leftmost one of the eponymous set can be referenced. Outside of the pattern a named capture group is accessible through the &lt;code&gt;%+&lt;/code&gt; hash.</source>
          <target state="translated">Perl 5.10은 또한 명명 된 캡처 그룹과 명명 된 역 참조를 도입했습니다. 캡처 그룹에 이름을 첨부하려면 &lt;code&gt;(?&amp;lt;name&amp;gt;...)&lt;/code&gt; 또는 &lt;code&gt;(?'name'...)&lt;/code&gt; . 역 참조는 &lt;code&gt;\g{name}&lt;/code&gt; 으로 작성 될 수 있습니다 . 동일한 이름을 둘 이상의 그룹에 첨부 할 수 있지만 가장 왼쪽의 시조 세트 만 참조 할 수 있습니다. 패턴 외부에서 명명 된 캡처 그룹은 &lt;code&gt;%+&lt;/code&gt; 해시를 통해 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="115264f71824b47785d298c1ef35a6a89f372587" translate="yes" xml:space="preserve">
          <source>Perl 5.10 also introduced named capture groups and named backreferences. To attach a name to a capturing group, you write either &lt;code&gt;(?&amp;lt;name&amp;gt;...)&lt;/code&gt; or &lt;code&gt;(?'name'...)&lt;/code&gt;. The backreference may then be written as &lt;code&gt;\g{name}&lt;/code&gt;. It is permissible to attach the same name to more than one group, but then only the leftmost one of the eponymous set can be referenced. Outside of the pattern a named capture group is accessible through the &lt;code&gt;%+&lt;/code&gt; hash.</source>
          <target state="translated">Perl 5.10은 또한 명명 된 캡처 그룹 및 명명 된 역 참조를 도입했습니다. 캡처 그룹에 이름을 첨부하려면 &lt;code&gt;(?&amp;lt;name&amp;gt;...)&lt;/code&gt; 또는 &lt;code&gt;(?'name'...)&lt;/code&gt; 합니다. 그런 다음 역 참조는 &lt;code&gt;\g{name}&lt;/code&gt; 로 작성 될 수 있습니다 . 둘 이상의 그룹에 동일한 이름을 첨부하는 것은 허용되지만 시조 집합 중 가장 왼쪽에있는 집합 만 참조 할 수 있습니다. 패턴 외부에서 명명 된 캡처 그룹은 &lt;code&gt;%+&lt;/code&gt; 해시를 통해 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d78bc07daf7287cd2d82e764c55679c183debb95" translate="yes" xml:space="preserve">
          <source>Perl 5.10 introduced a number of control verbs intended to provide detailed control over the backtracking process, by directly influencing the regexp engine and by providing monitoring techniques. As all the features in this group are experimental and subject to change or removal in a future version of Perl, the interested reader is referred to &lt;a href=&quot;perlre#Special-Backtracking-Control-Verbs&quot;&gt;Special Backtracking Control Verbs in perlre&lt;/a&gt; for a detailed description.</source>
          <target state="translated">Perl 5.10은 정규식 엔진에 직접 영향을 미치고 모니터링 기술을 제공함으로써 역 추적 프로세스에 대한 세부적인 제어를 제공하기위한 많은 제어 동사를 도입했습니다. 이 그룹의 모든 기능은 실험적이며 향후 Perl 버전에서 변경 또는 제거 될 예정이므로 자세한 설명 은 관심있는 독자 &lt;a href=&quot;perlre#Special-Backtracking-Control-Verbs&quot;&gt;를 perlre의 특수 역 추적 제어 동사로&lt;/a&gt; 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="8d197238627a1653007f58ee33834bfb110a45a3" translate="yes" xml:space="preserve">
          <source>Perl 5.10 introduced a number of control verbs intended to provide detailed control over the backtracking process, by directly influencing the regexp engine and by providing monitoring techniques. See &lt;a href=&quot;perlre#Special-Backtracking-Control-Verbs&quot;&gt;&quot;Special Backtracking Control Verbs&quot; in perlre&lt;/a&gt; for a detailed description.</source>
          <target state="translated">Perl 5.10은 regexp 엔진에 직접 영향을 미치고 모니터링 기술을 제공하여 역 추적 프로세스에 대한 세부 제어를 제공하기 위해 여러 제어 동사를 도입했습니다. 자세한 설명 &lt;a href=&quot;perlre#Special-Backtracking-Control-Verbs&quot;&gt;은 perlre의 &quot;Special Backtracking Control Verbs&quot;를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="584eeb9af5c995523642f05c75ed86704463abbd" translate="yes" xml:space="preserve">
          <source>Perl 5.10.0 has a bug when compiled with newer gcc versions. This bug causes a segfault whenever a new thread is launched. Test2 will attempt to detect this, and note that the system is not capable of forking when it is detected.</source>
          <target state="translated">Perl 5.10.0은 최신 gcc 버전으로 컴파일 할 때 버그가 있습니다. 이 버그는 새 스레드가 시작될 때마다 segfault를 발생시킵니다. Test2는이를 감지하려고 시도하고 시스템이 감지 될 때 분기 할 수 없다는 점에 유의합니다.</target>
        </trans-unit>
        <trans-unit id="d8fc66ff20f940e5def5d5b04e16e404fe2d5094" translate="yes" xml:space="preserve">
          <source>Perl 5.12 an newer is not compatible with the IBM fileset perl.libext.</source>
          <target state="translated">Perl 5.12 최신 버전은 IBM 파일 세트 perl.libext와 호환되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="22c1a552baa41f722e50e202fb00024c3ebfb6db" translate="yes" xml:space="preserve">
          <source>Perl 5.16</source>
          <target state="translated">펄 5.16</target>
        </trans-unit>
        <trans-unit id="ea53addd5f513ae8ff9630b1ab8b434a441c0d82" translate="yes" xml:space="preserve">
          <source>Perl 5.16 introduced a slightly more efficient mechanism that notes separately whether each of &lt;code&gt;$`&lt;/code&gt; , &lt;code&gt;$&amp;amp;&lt;/code&gt; , and &lt;code&gt;$'&lt;/code&gt; have been seen, and thus may only need to copy part of the string. Perl 5.20 introduced a much more efficient copy-on-write mechanism which eliminates any slowdown.</source>
          <target state="translated">Perl 5.16은 각각의 &lt;code&gt;$`&lt;/code&gt; 여부를 별도로 기록하는 약간 더 효율적인 메커니즘을 도입했습니다 . &lt;code&gt;$&amp;amp;&lt;/code&gt; 및 &lt;code&gt;$'&lt;/code&gt; 하여 문자열의 일부만 복사하면됩니다. Perl 5.20은 속도를 늦추지 않는 훨씬 효율적인 복사 중 복사 메커니즘을 도입했습니다.</target>
        </trans-unit>
        <trans-unit id="a1e98cc406baf109c9d02615750864a42131b157" translate="yes" xml:space="preserve">
          <source>Perl 5.16 introduced a slightly more efficient mechanism that notes separately whether each of &lt;code&gt;$`&lt;/code&gt;, &lt;code&gt;$&amp;amp;&lt;/code&gt;, and &lt;code&gt;$'&lt;/code&gt; have been seen, and thus may only need to copy part of the string. Perl 5.20 introduced a much more efficient copy-on-write mechanism which eliminates any slowdown.</source>
          <target state="translated">Perl 5.16은 &lt;code&gt;$`&lt;/code&gt; , &lt;code&gt;$&amp;amp;&lt;/code&gt; 및 &lt;code&gt;$'&lt;/code&gt; 각각이 표시되었는지 여부를 별도로 기록하는 약간 더 효율적인 메커니즘을 도입했습니다. 따라서 문자열의 일부만 복사하면됩니다. Perl 5.20은 속도 저하를 제거하는 훨씬 더 효율적인 copy-on-write 메커니즘을 도입했습니다.</target>
        </trans-unit>
        <trans-unit id="ecdd633a06acc3333c70644f93001a3679676523" translate="yes" xml:space="preserve">
          <source>Perl 5.18 introduced a new class, B::PADLIST, returned by B::CV's &lt;code&gt;PADLIST&lt;/code&gt; method.</source>
          <target state="translated">Perl 5.18은 B :: CV가 반환 한 새로운 클래스 B :: PADLIST를 도입했습니다. &lt;code&gt;PADLIST&lt;/code&gt; 메소드에 .</target>
        </trans-unit>
        <trans-unit id="6b567ee259b41361a0ad9018ea4088cb70239efc" translate="yes" xml:space="preserve">
          <source>Perl 5.22 also introduces the experimental &quot;const&quot; attribute as an alternative. (Disable the &quot;experimental::const_attr&quot; warnings if you want to use it.) When applied to an anonymous subroutine, it forces the sub to be called when the &lt;code&gt;&lt;a href=&quot;functions/sub&quot;&gt;sub&lt;/a&gt;&lt;/code&gt; expression is evaluated. The return value is captured and turned into a constant subroutine:</source>
          <target state="translated">Perl 5.22는 실험적인 &quot;const&quot;속성을 대안으로 소개합니다. (사용하려는 경우 &quot;experimental :: const_attr&quot;경고를 비활성화하십시오.) 익명 서브 루틴에 적용될 때 서브 우퍼가 &lt;code&gt;&lt;a href=&quot;functions/sub&quot;&gt;sub&lt;/a&gt;&lt;/code&gt; 표현식이 평가. 리턴 값은 캡처되어 일정한 서브 루틴으로 바뀝니다.</target>
        </trans-unit>
        <trans-unit id="31d7199897d8b920eebab904073bac73dc70089f" translate="yes" xml:space="preserve">
          <source>Perl 5.22 also introduces the experimental &quot;const&quot; attribute as an alternative. (Disable the &quot;experimental::const_attr&quot; warnings if you want to use it.) When applied to an anonymous subroutine, it forces the sub to be called when the &lt;code&gt;sub&lt;/code&gt; expression is evaluated. The return value is captured and turned into a constant subroutine:</source>
          <target state="translated">Perl 5.22는 대안으로 실험적인 &quot;const&quot;속성을 도입했습니다. (사용하려면 &quot;experimental :: const_attr&quot;경고를 비활성화합니다.) 익명 서브 루틴에 적용하면 &lt;code&gt;sub&lt;/code&gt; 표현식이 평가 될 때 하위 가 호출되도록합니다 . 반환 값이 캡처되고 상수 서브 루틴으로 바뀝니다.</target>
        </trans-unit>
        <trans-unit id="cf5bb1f9d37da5d5c2d35eb2fe5db684768a1718" translate="yes" xml:space="preserve">
          <source>Perl 5.22 introduced the B::PADNAMELIST and B::PADNAME classes.</source>
          <target state="translated">Perl 5.22는 B :: PADNAMELIST 및 B :: PADNAME 클래스를 도입했습니다.</target>
        </trans-unit>
        <trans-unit id="8eb64573fd28436266ef8b83ae879c922aa2718a" translate="yes" xml:space="preserve">
          <source>Perl 5.24</source>
          <target state="translated">펄 5.24</target>
        </trans-unit>
        <trans-unit id="d4d54e9a22b86ccb042ec9ad9cdcb8b20f3feb99" translate="yes" xml:space="preserve">
          <source>Perl 5.26</source>
          <target state="translated">펄 5.26</target>
        </trans-unit>
        <trans-unit id="0d7d5255cbd686c042840f5ff2f1c80ef3b153ed" translate="yes" xml:space="preserve">
          <source>Perl 5.28</source>
          <target state="translated">펄 5.28</target>
        </trans-unit>
        <trans-unit id="87966d58d51aae325250821ef9dbcdd86c8cbe91" translate="yes" xml:space="preserve">
          <source>Perl 5.30</source>
          <target state="translated">펄 5.30</target>
        </trans-unit>
        <trans-unit id="366edd1a774f9c1660a61ddaa3d7c12fc7af5703" translate="yes" xml:space="preserve">
          <source>Perl 5.32</source>
          <target state="translated">펄 5.32</target>
        </trans-unit>
        <trans-unit id="16cebccb7e37f3bcda23a91f5a5b4aa3276930af" translate="yes" xml:space="preserve">
          <source>Perl 5.32.0 Documentation</source>
          <target state="translated">Perl 5.32.0 문서</target>
        </trans-unit>
        <trans-unit id="b2d0ccd58dc8c574da7bcb06529ab63a9227edf7" translate="yes" xml:space="preserve">
          <source>Perl 5.34</source>
          <target state="translated">펄 5.34</target>
        </trans-unit>
        <trans-unit id="2c423e3fdc417abd5c0a870160561ad280c5b05c" translate="yes" xml:space="preserve">
          <source>Perl 5.6 added support for Unicode characters with code points &amp;gt; 255, and Perl 5.8 has full support for Unicode characters in hash keys. Perl internally encodes strings with these characters using utf8, and Storable serializes them as utf8. By default, if an older version of Perl encounters a utf8 value it cannot represent, it will &lt;code&gt;croak()&lt;/code&gt; . To change this behaviour so that Storable deserializes utf8 encoded values as the string of bytes (effectively dropping the</source>
          <target state="translated">Perl 5.6은 코드 포인트가 255보다 큰 유니 코드 문자에 대한 지원을 추가했으며 Perl 5.8은 해시 키의 유니 코드 문자를 완벽하게 지원합니다. Perl은 utf8을 사용하여 이러한 문자로 문자열을 내부적으로 인코딩하고 Storable은 문자열을 utf8로 직렬화합니다. 기본적으로 이전 버전의 Perl에서 utf8 값을 발견 할 수없는 경우 &lt;code&gt;croak()&lt;/code&gt; 됩니다. Storable이 utf8로 인코딩 된 값을 바이트 문자열로 deserialize하도록이 동작을 변경하려면</target>
        </trans-unit>
        <trans-unit id="cde995577e5439f98ee44f0a1873e0f95b95226b" translate="yes" xml:space="preserve">
          <source>Perl 5.6 added support for Unicode characters with code points &amp;gt; 255, and Perl 5.8 has full support for Unicode characters in hash keys. Perl internally encodes strings with these characters using utf8, and Storable serializes them as utf8. By default, if an older version of Perl encounters a utf8 value it cannot represent, it will &lt;code&gt;croak()&lt;/code&gt;. To change this behaviour so that Storable deserializes utf8 encoded values as the string of bytes (effectively dropping the</source>
          <target state="translated">Perl 5.6은 코드 포인트가 255보다 큰 유니 코드 문자에 대한 지원을 추가했으며 Perl 5.8은 해시 키에서 유니 코드 문자를 완벽하게 지원합니다. Perl은 내부적으로 utf8을 사용하여 이러한 문자로 문자열을 인코딩하고 Storable은이를 utf8로 직렬화합니다. 기본적으로 이전 버전의 Perl이 나타낼 수없는 utf8 값을 발견하면 &lt;code&gt;croak()&lt;/code&gt; 됩니다. Storable이 utf8 인코딩 값을 바이트 문자열로 역 직렬화하도록이 동작을 변경하려면 (효과적으로</target>
        </trans-unit>
        <trans-unit id="4d666cc8f0c2aafb781a5c3ee7854aa462c22563" translate="yes" xml:space="preserve">
          <source>Perl 5.6 and earlier used a quicksort algorithm to implement sort. That algorithm was not stable, so</source>
          <target state="translated">Perl 5.6 및 이전 버전에서는 빠른 정렬 알고리즘을 사용하여 정렬을 구현했습니다. 그 알고리즘은 안정적이지 않아서</target>
        </trans-unit>
        <trans-unit id="cc23cb198586dd32a543690c051c8df0366d1085" translate="yes" xml:space="preserve">
          <source>Perl 5.6 lets you write binary numbers directly with the &lt;code&gt;0b&lt;/code&gt; notation:</source>
          <target state="translated">Perl 5.6을 사용하면 &lt;code&gt;0b&lt;/code&gt; 로 직접 이진수를 쓸 수 있습니다 표기법으로 .</target>
        </trans-unit>
        <trans-unit id="45926b613d53010c55908af141dded6cf0223b03" translate="yes" xml:space="preserve">
          <source>Perl 5.6.0 introduced Unicode support. It's important for porters and XS writers to understand this support and make sure that the code they write does not corrupt Unicode data.</source>
          <target state="translated">Perl 5.6.0은 유니 코드 지원을 도입했습니다. 포터와 XS 작성자가이 지원을 이해하고 작성하는 코드가 유니 코드 데이터를 손상시키지 않는 것이 중요합니다.</target>
        </trans-unit>
        <trans-unit id="d766774f1389bd4f4ba4c170949b6d3cfbd45c53" translate="yes" xml:space="preserve">
          <source>Perl 5.6.x introduced the ability to optional configure the perl interpreter to use C's &lt;code&gt;long long&lt;/code&gt; type to allow scalars to store 64 bit integers on 32 bit systems. However, due to the way the Perl configuration system generated the C configuration files on non-Windows platforms, and the way Storable generates its header, nothing in the Storable file header reflected whether the perl writing was using 32 or 64 bit integers, despite the fact that Storable was storing some data differently in the file. Hence Storable running on perl with 64 bit integers will read the header from a file written by a 32 bit perl, not realise that the data is actually in a subtly incompatible format, and then go horribly wrong (possibly crashing) if it encountered a stored integer. This is a design failure.</source>
          <target state="translated">Perl 5.6.x는 스칼라가 32 비트 시스템에 64 비트 정수를 저장할 수 있도록 C의 &lt;code&gt;long long&lt;/code&gt; 유형을 사용하도록 perl 인터프리터를 선택적으로 구성하는 기능을 도입했습니다 . 그러나 Perl 구성 시스템이 Windows 이외의 플랫폼에서 C 구성 파일을 생성하는 방식과 Storable이 헤더를 생성하는 방식으로 인해 Storable 파일 헤더에는 Perl 쓰기가 32 비트 또는 64 비트 정수를 사용하는지 여부가 반영되지 않았습니다. Storable이 일부 데이터를 파일에 다르게 저장했다는 사실. 따라서 64 비트 정수로 perl에서 실행 가능한 Storable은 32 비트 perl로 작성된 파일에서 헤더를 읽습니다. 데이터가 실제로 미묘하게 호환되지 않는 형식임을 알지 못합니다. 정수. 이것은 설계 실패입니다.</target>
        </trans-unit>
        <trans-unit id="85ca30a6ededa148e4bfea0d2618456fe4f02a72" translate="yes" xml:space="preserve">
          <source>Perl 5.8 adds support for restricted hashes, which have keys restricted to a given set, and can have values locked to be read only. By default, when Storable encounters a restricted hash on a perl that doesn't support them, it will deserialize it as a normal hash, silently discarding any placeholder keys and leaving the keys and all values unlocked. To make Storable &lt;code&gt;croak()&lt;/code&gt; instead, set &lt;code&gt;$Storable::downgrade_restricted&lt;/code&gt; to a &lt;code&gt;FALSE&lt;/code&gt; value. To restore the default set it back to some &lt;code&gt;TRUE&lt;/code&gt; value.</source>
          <target state="translated">Perl 5.8은 키가 지정된 세트로 제한되어 있고 읽기 전용으로 잠긴 값을 가질 수있는 제한된 해시에 대한 지원을 추가합니다. 기본적으로 Storable은이를 지원하지 않는 펄에서 제한된 해시를 발견하면이를 일반 해시로 역 직렬화하여 자리 표시 자 키를 자동으로 버리고 키와 모든 값을 잠금 해제 상태로 둡니다. 대신 Storable &lt;code&gt;croak()&lt;/code&gt; 를 만들려면 &lt;code&gt;$Storable::downgrade_restricted&lt;/code&gt; 를 &lt;code&gt;FALSE&lt;/code&gt; 값으로 설정하십시오. 기본값을 복원하려면 다시 &lt;code&gt;TRUE&lt;/code&gt; 값 으로 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="565a4d4fa800ce5182da9b6ba981e8a739829623" translate="yes" xml:space="preserve">
          <source>Perl 5.8.0 added support for Unicode on EBCDIC platforms. This support was allowed to lapse in later releases, but was revived in 5.22. Unicode support is somewhat more complex to implement since additional conversions are needed. See &lt;a href=&quot;perlebcdic&quot;&gt;perlebcdic&lt;/a&gt; for more information.</source>
          <target state="translated">Perl 5.8.0은 EBCDIC 플랫폼에서 유니 코드에 대한 지원을 추가했습니다. 이 지원은 이후 릴리스에서 없어 질 수 있었지만 5.22에서 부활했습니다. 추가 변환이 필요하므로 유니 코드 지원은 구현하기가 다소 복잡합니다. 자세한 정보는 &lt;a href=&quot;perlebcdic&quot;&gt;perlebcdic&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="1d3bf07733afdb8eccda724369492b44b06d3912" translate="yes" xml:space="preserve">
          <source>Perl 5.8.0 and later avoid these problems by &quot;deferring&quot; signals. That is, when the signal is delivered to the process by the system (to the C code that implements Perl) a flag is set, and the handler returns immediately. Then at strategic &quot;safe&quot; points in the Perl interpreter (e.g. when it is about to execute a new opcode) the flags are checked and the Perl level handler from %SIG is executed. The &quot;deferred&quot; scheme allows much more flexibility in the coding of signal handlers as we know the Perl interpreter is in a safe state, and that we are not in a system library function when the handler is called. However the implementation does differ from previous Perls in the following ways:</source>
          <target state="translated">Perl 5.8.0 이상은 신호를 &quot;지연&quot;하여 이러한 문제를 방지합니다. 즉, 신호가 시스템에 의해 프로세스 (Perl을 구현하는 C 코드로)에 전달되면 플래그가 설정되고 핸들러는 즉시 리턴합니다. 그런 다음 Perl 인터프리터의 전략적인 &quot;안전한&quot;지점 (예 : 새 opcode를 실행하려고 할 때)에서 플래그를 확인하고 % SIG의 Perl 레벨 핸들러를 실행합니다. &quot;지연된 (deferred)&quot;체계는 Perl 인터프리터가 안전한 상태에 있고 핸들러가 호출 될 때 시스템 라이브러리 함수에 있지 않다는 것을 알기 때문에 신호 핸들러의 코딩에 훨씬 더 많은 유연성을 허용합니다. 그러나 다음과 같은 점에서 구현이 이전 Perls와 다릅니다.</target>
        </trans-unit>
        <trans-unit id="e73fd9ce0c7c872add12735883aa527cd3cbf5df" translate="yes" xml:space="preserve">
          <source>Perl 5.8.0 or later</source>
          <target state="translated">Perl 5.8.0 이상</target>
        </trans-unit>
        <trans-unit id="5a0af5a1468c03fa40c2af7be5d9056970a7782e" translate="yes" xml:space="preserve">
          <source>Perl 5.8.1 and beyond are able to automatically quote v-strings but that is not possible in earlier versions of Perl. In other words:</source>
          <target state="translated">Perl 5.8.1 이상은 v- 문자열을 자동으로 인용 할 수 있지만 이전 버전의 Perl에서는 불가능합니다. 다시 말해:</target>
        </trans-unit>
        <trans-unit id="4e8757ee96021b145f4cb52d1033c040338543b5" translate="yes" xml:space="preserve">
          <source>Perl 6 is a reinvention of Perl, it is a language in the same lineage but not compatible. The two are complementary, not mutually exclusive. Perl 6 is not meant to replace Perl 5, and vice versa. See &lt;a href=&quot;#What-is-Perl-6%3f&quot;&gt;What is Perl 6?&lt;/a&gt; below to find out more.</source>
          <target state="translated">Perl 6은 Perl의 재발 명입니다. 동일한 계보의 언어이지만 호환되지는 않습니다. 이 둘은 상호 배타적이지 않고 상호 보완 적입니다. Perl 6은 Perl 5를 대체하지 않으며 그 반대도 마찬가지입니다. 참조 &lt;a href=&quot;#What-is-Perl-6%3f&quot;&gt;펄 6은 무엇입니까? &lt;/a&gt;자세한 내용은 아래를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="70eed57e9021b8ec1bdc60c299cf0007c990e85c" translate="yes" xml:space="preserve">
          <source>Perl 6 was</source>
          <target state="translated">펄 6은</target>
        </trans-unit>
        <trans-unit id="c935317046cb2fe37bcb5104606c71edb33387e0" translate="yes" xml:space="preserve">
          <source>Perl &lt;b&gt;borrows syntax&lt;/b&gt; and concepts from many languages: awk, sed, C, Bourne Shell, Smalltalk, Lisp and even English. Other languages have borrowed syntax from Perl, particularly its regular expression extensions. So if you have programmed in another language you will see familiar pieces in Perl. They often work the same, but see &lt;a href=&quot;perltrap&quot;&gt;perltrap&lt;/a&gt; for information about how they differ.</source>
          <target state="translated">Perl &lt;b&gt;은&lt;/b&gt; awk, sed, C, Bourne Shell, Smalltalk, Lisp 및 영어와 같은 여러 언어에서 &lt;b&gt;구문&lt;/b&gt; 과 개념을 &lt;b&gt;빌 렸습니다&lt;/b&gt; . 다른 언어는 Perl에서 구문, 특히 정규 표현식 확장을 빌 렸습니다. 따라서 다른 언어로 프로그래밍 한 경우 Perl에 익숙한 조각이 표시됩니다. 그들은 종종 동일하게 작동하지만 &lt;a href=&quot;perltrap&quot;&gt;차이점에&lt;/a&gt; 대한 정보는 perltrap 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a37780bb487077495edf8f34f760c1da9044ebae" translate="yes" xml:space="preserve">
          <source>Perl API not supported by ppport.h</source>
          <target state="translated">ppport.h가 지원하지 않는 Perl API</target>
        </trans-unit>
        <trans-unit id="50704605d6b6262fd96cb32c233850a8761b03e3" translate="yes" xml:space="preserve">
          <source>Perl API version %s of %s does not match %s</source>
          <target state="translated">Perl API 버전 % s (% s)이 (가) % s과 (와) 일치하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5b7471df455475e2c7d2175b53792162c97edfe3" translate="yes" xml:space="preserve">
          <source>Perl Authors Upload Server. Contains links to information for module authors.</source>
          <target state="translated">Perl Authors 업로드 서버. 모듈 작성자를위한 정보 링크가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="8bf74964bb9b0e9e3d4da81f0703933934a7c358" translate="yes" xml:space="preserve">
          <source>Perl Best Practices</source>
          <target state="translated">펄 베스트 프랙티스</target>
        </trans-unit>
        <trans-unit id="2cc43b42e51a4a8837fffe3af550658174edb610" translate="yes" xml:space="preserve">
          <source>Perl Books</source>
          <target state="translated">펄 북</target>
        </trans-unit>
        <trans-unit id="ed1deb6e5d999d91341ff20898eb3858a1d9c995" translate="yes" xml:space="preserve">
          <source>Perl Bugs and the CPAN Version of &lt;a href=&quot;threads&quot;&gt;threads&lt;/a&gt;</source>
          <target state="translated">Perl 버그 및 CPAN 버전의 &lt;a href=&quot;threads&quot;&gt;스레드&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a3a9e748e5c4dd7f9dfa7cc95a251e60be896a8f" translate="yes" xml:space="preserve">
          <source>Perl Classes</source>
          <target state="translated">펄 클래스</target>
        </trans-unit>
        <trans-unit id="e482403a1124e0521d166c90c8a0769c85673b5e" translate="yes" xml:space="preserve">
          <source>Perl Cookbook</source>
          <target state="translated">펄 요리 책</target>
        </trans-unit>
        <trans-unit id="d4efb54c65e7e3af46d13e87c7581a8dcba624d0" translate="yes" xml:space="preserve">
          <source>Perl DLL</source>
          <target state="translated">펄 DLL</target>
        </trans-unit>
        <trans-unit id="aeebc1579f8d617b27fe89ad608591410feec7ff" translate="yes" xml:space="preserve">
          <source>Perl Documentation</source>
          <target state="translated">Perl 문서</target>
        </trans-unit>
        <trans-unit id="3283f18cd28cbde0549accd86697398505934bb4" translate="yes" xml:space="preserve">
          <source>Perl Editor by EngInSite is a complete integrated development environment (IDE) for creating, testing, and debugging Perl scripts; the tool runs on Windows 9x/NT/2000/XP or later.</source>
          <target state="translated">EngInSite의 Perl Editor는 Perl 스크립트 작성, 테스트 및 디버깅을위한 완벽한 통합 개발 환경 (IDE)입니다. 이 도구는 Windows 9x / NT / 2000 / XP 이상에서 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="7ac9d4c93ef979889b211c88f596e981156f45f4" translate="yes" xml:space="preserve">
          <source>Perl Extensions</source>
          <target state="translated">펄 확장</target>
        </trans-unit>
        <trans-unit id="f71fad82087d419a133c0dced88c67e1f9877063" translate="yes" xml:space="preserve">
          <source>Perl FAQ</source>
          <target state="translated">펄 FAQ</target>
        </trans-unit>
        <trans-unit id="da7c8c4aaafde8c9b2e5f84c7552444fbb08c636" translate="yes" xml:space="preserve">
          <source>Perl Fails Because Of Unresolved Symbol sockatmark</source>
          <target state="translated">해결되지 않은 기호 sockatmark로 인해 Perl이 실패 함</target>
        </trans-unit>
        <trans-unit id="7c3d43451e7cda778a3f9c97b52abf3fd44bedb9" translate="yes" xml:space="preserve">
          <source>Perl Functions by Category</source>
          <target state="translated">카테고리 별 펄 함수</target>
        </trans-unit>
        <trans-unit id="920e14089fbbc423ee2d5724c1de68632aef3813" translate="yes" xml:space="preserve">
          <source>Perl GNU Info Files on AmigaOS</source>
          <target state="translated">AmigaOS의 Perl GNU 정보 파일</target>
        </trans-unit>
        <trans-unit id="37de2a8ad505f52fcef06a6993c850291e480520" translate="yes" xml:space="preserve">
          <source>Perl HTML Documentation on AmigaOS</source>
          <target state="translated">AmigaOS에 대한 Perl HTML 문서</target>
        </trans-unit>
        <trans-unit id="05eb1caf8706fb276d9b12087337d5c6103138c5" translate="yes" xml:space="preserve">
          <source>Perl LaTeX Documentation on AmigaOS</source>
          <target state="translated">AmigaOS에 대한 Perl LaTeX 문서</target>
        </trans-unit>
        <trans-unit id="04d3717cc2f7e5ee505e9248aa236712bb68755e" translate="yes" xml:space="preserve">
          <source>Perl Module Tests</source>
          <target state="translated">Perl 모듈 테스트</target>
        </trans-unit>
        <trans-unit id="91a43bc6de8b72c656ec8849bbbaebef043357f9" translate="yes" xml:space="preserve">
          <source>Perl Modules</source>
          <target state="translated">펄 모듈</target>
        </trans-unit>
        <trans-unit id="1444928d77d0dfce158ff301d3dbfb2b1588dd16" translate="yes" xml:space="preserve">
          <source>Perl Modules/Scripts</source>
          <target state="translated">Perl 모듈 / 스크립트</target>
        </trans-unit>
        <trans-unit id="216d171ee4524430a28634ae1013da6c2f558efa" translate="yes" xml:space="preserve">
          <source>Perl Objects And C Structures</source>
          <target state="translated">펄 객체와 C 구조</target>
        </trans-unit>
        <trans-unit id="a472684894e509305085eced5d45bf35bf21cca5" translate="yes" xml:space="preserve">
          <source>Perl Smokers ( &lt;a href=&quot;http://www.nntp.perl.org/group/perl.daily-build/&quot;&gt;http://www.nntp.perl.org/group/perl.daily-build/&lt;/a&gt; and &lt;a href=&quot;http://www.nntp.perl.org/group/perl.daily-build.reports/&quot;&gt;http://www.nntp.perl.org/group/perl.daily-build.reports/&lt;/a&gt; ) automatically test Perl source releases on platforms with various configurations.</source>
          <target state="translated">Perl Smokers ( &lt;a href=&quot;http://www.nntp.perl.org/group/perl.daily-build/&quot;&gt;http://www.nntp.perl.org/group/perl.daily-build/&lt;/a&gt; 및 &lt;a href=&quot;http://www.nntp.perl.org/group/perl.daily-build.reports/&quot;&gt;http://www.nntp.perl.org/group/perl.daily-build.reports/&lt;/a&gt; ) 자동으로 Perl을 테스트 다양한 구성의 플랫폼에서 소스 릴리스.</target>
        </trans-unit>
        <trans-unit id="134999afb97cf5b769bf8c4b178dce62bcebf389" translate="yes" xml:space="preserve">
          <source>Perl Smokers ( &lt;a href=&quot;https://www.nntp.perl.org/group/perl.daily-build/&quot;&gt;https://www.nntp.perl.org/group/perl.daily-build/&lt;/a&gt; and &lt;a href=&quot;https://www.nntp.perl.org/group/perl.daily-build.reports/&quot;&gt;https://www.nntp.perl.org/group/perl.daily-build.reports/&lt;/a&gt; ) automatically test Perl source releases on platforms with various configurations.</source>
          <target state="translated">Perl Smokers ( &lt;a href=&quot;https://www.nntp.perl.org/group/perl.daily-build/&quot;&gt;https://www.nntp.perl.org/group/perl.daily-build/&lt;/a&gt; 및 &lt;a href=&quot;https://www.nntp.perl.org/group/perl.daily-build.reports/&quot;&gt;https://www.nntp.perl.org/group/perl.daily-build.reports/&lt;/a&gt; )는 Perl을 자동으로 테스트합니다. 다양한 구성을 가진 플랫폼의 소스 릴리스.</target>
        </trans-unit>
        <trans-unit id="a5b49734e895fa49b2262a8eac32c0a87b309e7f" translate="yes" xml:space="preserve">
          <source>Perl Source Filter</source>
          <target state="translated">펄 소스 필터</target>
        </trans-unit>
        <trans-unit id="d9385cb28cfa7ddf46c00b8a389aa72f1c3ecd2f" translate="yes" xml:space="preserve">
          <source>Perl Source Filter Utility Module</source>
          <target state="translated">펄 소스 필터 유틸리티 모듈</target>
        </trans-unit>
        <trans-unit id="11827d68497a169d041d5a9b84cc14e0b5402701" translate="yes" xml:space="preserve">
          <source>Perl Threads Are Not X Threads</source>
          <target state="translated">펄 스레드는 X 스레드가 아닙니다</target>
        </trans-unit>
        <trans-unit id="0d5f49a6432453dfdae5c9b853d5d2137d7a3d82" translate="yes" xml:space="preserve">
          <source>Perl Traps</source>
          <target state="translated">펄 트랩</target>
        </trans-unit>
        <trans-unit id="baee6a50a34759c52a5448ef022819377b034948" translate="yes" xml:space="preserve">
          <source>Perl VIO and PM executables (dynamically linked)</source>
          <target state="translated">Perl VIO 및 PM 실행 파일 (동적으로 연결됨)</target>
        </trans-unit>
        <trans-unit id="e81612c89b54aaefee5157e85c78728a2455e0ca" translate="yes" xml:space="preserve">
          <source>Perl XS' attempt at a solution to this is the concept of typemaps. At an abstract level, a Perl XS typemap is nothing but a recipe for converting from a certain Perl data structure to a certain C data structure and vice versa. Since there can be C types that are sufficiently similar to one another to warrant converting with the same logic, XS typemaps are represented by a unique identifier, henceforth called an &lt;b&gt;XS type&lt;/b&gt; in this document. You can then tell the XS compiler that multiple C types are to be mapped with the same XS typemap.</source>
          <target state="translated">Perl XS의 해결책은 타입 맵의 개념입니다. 추상적 인 수준에서 Perl XS 타입 맵은 특정 Perl 데이터 구조에서 특정 C 데이터 구조로 또는 그 반대로 변환하기위한 레시피 일뿐입니다. 동일한 논리로 변환하기 위해 서로 충분히 유사한 C 유형이있을 수 있으므로 &lt;b&gt;XS 유형&lt;/b&gt; 맵은 고유 식별자로 표시되므로이 문서 에서는 &lt;b&gt;XS 유형&lt;/b&gt; 이라고합니다 . 그런 다음 여러 C 유형이 동일한 XS 유형 맵으로 맵핑되도록 XS 컴파일러에 알릴 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5aedddb9bed4a6f9cc4928e309c3362165c3d8aa" translate="yes" xml:space="preserve">
          <source>Perl actually inserts the following code:</source>
          <target state="translated">Perl은 실제로 다음 코드를 삽입합니다.</target>
        </trans-unit>
        <trans-unit id="0370590002494d49cbee29303986558b8c939d60" translate="yes" xml:space="preserve">
          <source>Perl actually stands for Pathologically Eclectic Rubbish Lister, but don't tell anyone I said that.</source>
          <target state="translated">펄은 실제로 병리학 적으로 절충 적 쓰레기 목록을 나타내지 만, 내가 말한 사람에게는 아무 것도 말하지 않는다.</target>
        </trans-unit>
        <trans-unit id="4ac1014663aa23e842df07d5739089aa502fbf6c" translate="yes" xml:space="preserve">
          <source>Perl adds magic to an SV using the sv_magic function:</source>
          <target state="translated">Perl은 sv_magic 함수를 사용하여 SV에 마법을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="c3b8bb4554b031723a2e07241fd747dea1d44323" translate="yes" xml:space="preserve">
          <source>Perl after 5.8.7 has support for the &lt;code&gt;CLONE_SKIP&lt;/code&gt; special subroutine. Like &lt;code&gt;CLONE&lt;/code&gt; , &lt;code&gt;CLONE_SKIP&lt;/code&gt; is called once per package; however, it is called just before cloning starts, and in the context of the parent thread. If it returns a true value, then no objects of that class will be cloned; or rather, they will be copied as unblessed, undef values. For example: if in the parent there are two references to a single blessed hash, then in the child there will be two references to a single undefined scalar value instead. This provides a simple mechanism for making a module threadsafe; just add &lt;code&gt;sub CLONE_SKIP { 1 }&lt;/code&gt; at the top of the class, and &lt;code&gt;DESTROY()&lt;/code&gt; will now only be called once per object. Of course, if the child thread needs to make use of the objects, then a more sophisticated approach is needed.</source>
          <target state="translated">5.8.7 이후의 Perl은 &lt;code&gt;CLONE_SKIP&lt;/code&gt; 특수 서브 루틴을 지원합니다 . 마찬가지로 &lt;code&gt;CLONE&lt;/code&gt; , &lt;code&gt;CLONE_SKIP&lt;/code&gt; 은 패키지에 한 번이라고합니다; 그러나 복제가 시작되기 직전 및 상위 스레드 컨텍스트에서 호출됩니다. true 값을 반환하면 해당 클래스의 개체가 복제되지 않습니다. 또는 오히려 축복되지 않은 undef 값으로 복사됩니다. 예를 들어, 부모에 단일 축복 해시에 대한 두 개의 참조가있는 경우 자식에는 정의되지 않은 단일 스칼라 값에 대한 두 개의 참조가 대신 사용됩니다. 이것은 모듈을 스레드로부터 안전하게 만드는 간단한 메커니즘을 제공합니다. 클래스 상단에 &lt;code&gt;sub CLONE_SKIP { 1 }&lt;/code&gt; 을 추가 하고 &lt;code&gt;DESTROY()&lt;/code&gt; 개체 당 한 번만 호출됩니다. 물론 자식 스레드가 객체를 사용해야하는 경우보다 정교한 접근 방식이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="cc574da81e120f807b416b88f2c0641a8912116e" translate="yes" xml:space="preserve">
          <source>Perl after 5.8.7 has support for the &lt;code&gt;CLONE_SKIP&lt;/code&gt; special subroutine. Like &lt;code&gt;CLONE&lt;/code&gt;, &lt;code&gt;CLONE_SKIP&lt;/code&gt; is called once per package; however, it is called just before cloning starts, and in the context of the parent thread. If it returns a true value, then no objects of that class will be cloned; or rather, they will be copied as unblessed, undef values. For example: if in the parent there are two references to a single blessed hash, then in the child there will be two references to a single undefined scalar value instead. This provides a simple mechanism for making a module threadsafe; just add &lt;code&gt;sub CLONE_SKIP { 1 }&lt;/code&gt; at the top of the class, and &lt;code&gt;DESTROY()&lt;/code&gt; will now only be called once per object. Of course, if the child thread needs to make use of the objects, then a more sophisticated approach is needed.</source>
          <target state="translated">5.8.7 이후의 Perl은 &lt;code&gt;CLONE_SKIP&lt;/code&gt; 특수 서브 루틴을 지원합니다 . 마찬가지로 &lt;code&gt;CLONE&lt;/code&gt; , &lt;code&gt;CLONE_SKIP&lt;/code&gt; 은 패키지에 한 번이라고합니다; 그러나 복제가 시작되기 직전에 부모 스레드의 컨텍스트에서 호출됩니다. 참 값을 반환하면 해당 클래스의 개체가 복제되지 않습니다. 또는 오히려 그들은 unblessed, undef 값으로 복사됩니다. 예를 들어, 부모에 단일 축복 해시에 대한 두 개의 참조가있는 경우 자식에는 정의되지 않은 단일 스칼라 값에 대한 두 개의 참조가 대신 있습니다. 이것은 모듈을 스레드 세이프하게 만드는 간단한 메커니즘을 제공합니다. 클래스 맨 위에 &lt;code&gt;sub CLONE_SKIP { 1 }&lt;/code&gt; 을 추가 하고 &lt;code&gt;DESTROY()&lt;/code&gt; 이제 개체 당 한 번만 호출됩니다. 물론 자식 스레드가 개체를 사용해야한다면보다 정교한 접근 방식이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="c3994bbd1bc4bb2e8469e1a722d815312e8adf0c" translate="yes" xml:space="preserve">
          <source>Perl allows multiple inheritance, which means that a class can inherit from multiple parents. While this is possible, we strongly recommend against it. Generally, you can use &lt;b&gt;roles&lt;/b&gt; to do everything you can do with multiple inheritance, but in a cleaner way.</source>
          <target state="translated">Perl은 다중 상속을 허용합니다. 즉, 클래스는 여러 부모로부터 상속받을 수 있습니다. 이것이 가능하지만 반대하는 것이 좋습니다. 일반적으로 &lt;b&gt;역할&lt;/b&gt; 을 사용 하여 다중 상속으로 할 수있는 모든 작업을보다 깔끔하게 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6599623983e18eb4fc0786b977835cf73837499f" translate="yes" xml:space="preserve">
          <source>Perl allows strings to contain a superset of Unicode code points, but these may not be accepted by other languages/systems. Further, even if these languages/systems accept these large code points, they may have chosen a different representation for them than the UTF-8-like one that Perl has, which would mean files are not exchangeable between them and Perl.</source>
          <target state="translated">Perl은 문자열에 유니 코드 코드 포인트의 상위 집합을 포함 할 수 있지만 다른 언어 / 시스템에서는 허용되지 않을 수 있습니다. 또한 이러한 언어 / 시스템이 이러한 큰 코드 포인트를 허용하더라도 Perl이 가지고있는 UTF-8과 유사한 것과 다른 표현을 선택했을 수 있습니다. 즉, 파일을 Perl과 교환 할 수 없음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="1876b83bb7cab17e23b16333856308b07e0072a3" translate="yes" xml:space="preserve">
          <source>Perl allows strings to contain a superset of Unicode code points, up to the limit of what is storable in an unsigned integer on your system, but these may not be accepted by other languages/systems. At one time, it was legal in some standards to have code points up to 0x7FFF_FFFF, but not higher. Code points above 0xFFFF_FFFF require larger than a 32 bit word.</source>
          <target state="translated">Perl은 문자열이 시스템의 부호없는 정수로 저장 가능한 것의 한계까지 유니 코드 코드 포인트의 수퍼 세트를 포함 할 수 있지만 다른 언어 / 시스템에서는 허용되지 않을 수 있습니다. 한 번에, 일부 표준에서는 최대 0x7FFF_FFFF까지의 코드 포인트를 갖는 것이 합법적이지만 높지는 않았습니다. 0xFFFF_FFFF보다 큰 코드 포인트에는 32 비트 워드보다 큰 코드가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="da9001288df945c437097ff6bd5fee062555f6d6" translate="yes" xml:space="preserve">
          <source>Perl allows you to call methods using their fully qualified name (the package and method name):</source>
          <target state="translated">Perl을 사용하면 정규화 된 이름 (패키지 및 메서드 이름)을 사용하여 메서드를 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2ac9734d0ed22e02e26ee85745c9780f4e398059" translate="yes" xml:space="preserve">
          <source>Perl already</source>
          <target state="translated">펄은 이미</target>
        </trans-unit>
        <trans-unit id="15634b8ec3adda1649ae8821b358664ffd34a247" translate="yes" xml:space="preserve">
          <source>Perl also defines a consistent extension syntax for features not found in standard tools like &lt;b&gt;awk&lt;/b&gt; and &lt;b&gt;lex&lt;/b&gt;. The syntax for most of these is a pair of parentheses with a question mark as the first thing within the parentheses. The character after the question mark indicates the extension.</source>
          <target state="translated">Perl은 &lt;b&gt;awk&lt;/b&gt; 및 &lt;b&gt;lex&lt;/b&gt; 와 같은 표준 도구에는없는 기능에 대해 일관된 확장 구문을 정의합니다 . 대부분의 구문은 괄호 안에 첫 번째로 물음표가있는 괄호 쌍입니다. 물음표 뒤의 문자는 확장명을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="555f11f2e27ae1e8bf2d2bd41f29991c6d6def35" translate="yes" xml:space="preserve">
          <source>Perl also defines single form synonyms for the block property in cases where these do not conflict with something else. But don't use any of these, because they are unstable. Since these are Perl extensions, they are subordinate to official Unicode property names; Unicode doesn't know nor care about Perl's extensions. It may happen that a name that currently means the Perl extension will later be changed without warning to mean a different Unicode property in a future version of the perl interpreter that uses a later Unicode release, and your code would no longer work. The extensions are mentioned here for completeness: Take the block name and prefix it with one of: &lt;code&gt;In&lt;/code&gt; (for example &lt;code&gt;\p{Blk=Arrows}&lt;/code&gt; can currently be written as &lt;code&gt;\p{In_Arrows}&lt;/code&gt;); or sometimes &lt;code&gt;Is&lt;/code&gt; (like &lt;code&gt;\p{Is_Arrows}&lt;/code&gt;); or sometimes no prefix at all (&lt;code&gt;\p{Arrows}&lt;/code&gt;). As of this writing (Unicode 9.0) there are no conflicts with using the &lt;code&gt;In_&lt;/code&gt; prefix, but there are plenty with the other two forms. For example, &lt;code&gt;\p{Is_Hebrew}&lt;/code&gt; and &lt;code&gt;\p{Hebrew}&lt;/code&gt; mean &lt;code&gt;\p{Script_Extensions=Hebrew}&lt;/code&gt; which is NOT the same thing as &lt;code&gt;\p{Blk=Hebrew}&lt;/code&gt;. Our advice used to be to use the &lt;code&gt;In_&lt;/code&gt; prefix as a single form way of specifying a block. But Unicode 8.0 added properties whose names begin with &lt;code&gt;In&lt;/code&gt;, and it's now clear that it's only luck that's so far prevented a conflict. Using &lt;code&gt;In&lt;/code&gt; is only marginally less typing than &lt;code&gt;Blk:&lt;/code&gt;, and the latter's meaning is clearer anyway, and guaranteed to never conflict. So don't take chances. Use &lt;code&gt;\p{Blk=foo}&lt;/code&gt; for new code. And be sure that block is what you really really want to do. In most cases scripts are what you want instead.</source>
          <target state="translated">Perl은 또한 다른 것과 충돌하지 않는 경우 블록 속성에 대한 단일 형식 동의어를 정의합니다. 그러나 그것들은 불안정하기 때문에 사용하지 마십시오. 이들은 Perl 확장이므로 공식 유니 코드 속성 이름에 종속됩니다. 유니 코드는 Perl의 확장을 모르고 신경 쓰지 않습니다. 현재 Perl 확장을 의미하는 이름이 이후의 유니 코드 릴리스를 사용하는 향후 버전의 perl 인터프리터에서 다른 유니 코드 속성을 의미하도록 경고없이 나중에 변경 될 수 있으며 코드가 더 이상 작동하지 않을 수 있습니다. 완전성을 위해 여기에 확장이 언급됩니다. 블록 이름을 가져 와서 다음 중 하나를 접두사로 붙입니다. &lt;code&gt;In&lt;/code&gt; (예 : &lt;code&gt;\p{Blk=Arrows}&lt;/code&gt; 는 현재 &lt;code&gt;\p{In_Arrows}&lt;/code&gt; 로 쓸 수 있습니다 .) 또는 때때로 &lt;code&gt;Is&lt;/code&gt; (예 : &lt;code&gt;\p{Is_Arrows}&lt;/code&gt; ); 또는 접두어가 전혀없는 경우도 있습니다 ( &lt;code&gt;\p{Arrows}&lt;/code&gt; ). 이 글을 쓰는 시점 (Unicode 9.0)에서는 &lt;code&gt;In_&lt;/code&gt; 접두사 를 사용하는 것과 충돌이 없지만 다른 두 가지 형식에는 많은 문제가 있습니다. 예를 들어, &lt;code&gt;\p{Is_Hebrew}&lt;/code&gt; 와 &lt;code&gt;\p{Hebrew}&lt;/code&gt; 평균 &lt;code&gt;\p{Script_Extensions=Hebrew}&lt;/code&gt; 같은 일하지 않는 &lt;code&gt;\p{Blk=Hebrew}&lt;/code&gt; . 우리의 조언 은 블록을 지정하는 단일 양식 방법으로 &lt;code&gt;In_&lt;/code&gt; 접두사 를 사용하는 것입니다. 그러나 유니 코드 8.0은 이름이 &lt;code&gt;In&lt;/code&gt; 으로 시작하는 속성을 추가 했으며 지금까지 충돌을 방지 한 것이 행운이라는 것이 분명해졌습니다. 사용 &lt;code&gt;In&lt;/code&gt; &lt;code&gt;Blk:&lt;/code&gt; 보다 타이핑이 약간 적고 후자의 의미는 어쨌든 더 명확하며 충돌하지 않습니다. 그러니 기회를 잡지 마십시오. 새 코드 에는 &lt;code&gt;\p{Blk=foo}&lt;/code&gt; 를 사용하십시오 . 그리고 그 블록이 당신이 정말로하고 싶은 일인지 확인하십시오. 대부분의 경우 스크립트가 대신 원하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="a619d021759a90d753880bfe4b40f68e2b5378ff" translate="yes" xml:space="preserve">
          <source>Perl also guarantees that the ranges &lt;code&gt;A-Z&lt;/code&gt; , &lt;code&gt;a-z&lt;/code&gt; , &lt;code&gt;0-9&lt;/code&gt; , and any subranges of these match what an English-only speaker would expect them to match on any platform. That is, &lt;code&gt;[A-Z]&lt;/code&gt; matches the 26 ASCII uppercase letters; &lt;code&gt;[a-z]&lt;/code&gt; matches the 26 lowercase letters; and &lt;code&gt;[0-9]&lt;/code&gt; matches the 10 digits. Subranges, like &lt;code&gt;[h-k]&lt;/code&gt; , match correspondingly, in this case just the four letters &lt;code&gt;&quot;h&quot;&lt;/code&gt; , &lt;code&gt;&quot;i&quot;&lt;/code&gt; , &lt;code&gt;&quot;j&quot;&lt;/code&gt; , and &lt;code&gt;&quot;k&quot;&lt;/code&gt; . This is the natural behavior on ASCII platforms where the code points (ordinal values) for &lt;code&gt;&quot;h&quot;&lt;/code&gt; through &lt;code&gt;&quot;k&quot;&lt;/code&gt; are consecutive integers (0x68 through 0x6B). But special handling to achieve this may be needed on platforms with a non-ASCII native character set. For example, on EBCDIC platforms, the code point for &lt;code&gt;&quot;h&quot;&lt;/code&gt; is 0x88, &lt;code&gt;&quot;i&quot;&lt;/code&gt; is 0x89, &lt;code&gt;&quot;j&quot;&lt;/code&gt; is 0x91, and &lt;code&gt;&quot;k&quot;&lt;/code&gt; is 0x92. Perl specially treats &lt;code&gt;[h-k]&lt;/code&gt; to exclude the seven code points in the gap: 0x8A through 0x90. This special handling is only invoked when the range is a subrange of one of the ASCII uppercase, lowercase, and digit ranges, AND each end of the range is expressed either as a literal, like &lt;code&gt;&quot;A&quot;&lt;/code&gt; , or as a named character (&lt;code&gt;\N{...}&lt;/code&gt; , including the &lt;code&gt;\N{U+...&lt;/code&gt; form).</source>
          <target state="translated">Perl은 또한 범위 &lt;code&gt;A-Z&lt;/code&gt; , &lt;code&gt;a-z&lt;/code&gt; , &lt;code&gt;0-9&lt;/code&gt; 및 이들의 하위 범위가 영어 전용 스피커가 모든 플랫폼에서 일치 할 것으로 예상하는 것과 일치 함을 보장합니다 . 즉, &lt;code&gt;[A-Z]&lt;/code&gt; 는 26 개의 ASCII 대문자와 일치합니다. &lt;code&gt;[a-z]&lt;/code&gt; 는 26 개의 소문자와 일치합니다. 및 &lt;code&gt;[0-9]&lt;/code&gt; 10 자리수 일치한다. &lt;code&gt;[h-k]&lt;/code&gt; 와 같은 하위 범위는 이에 상응하여 일치합니다.이 경우에는 &lt;code&gt;&quot;h&quot;&lt;/code&gt; , &lt;code&gt;&quot;i&quot;&lt;/code&gt; , &lt;code&gt;&quot;j&quot;&lt;/code&gt; 및 &lt;code&gt;&quot;k&quot;&lt;/code&gt; 네 글자 만 일치합니다 . 이것은 &lt;code&gt;&quot;h&quot;&lt;/code&gt; 부터 &lt;code&gt;&quot;k&quot;&lt;/code&gt; &quot; 까지 의 코드 포인트 (정수 값)가있는 ASCII 플랫폼에서 자연스러운 동작입니다.케이&quot;연속 정수 (0x68에서 0x6B)입니다. 그러나 비 ASCII 기본 문자 세트가있는 플랫폼에서는이를 달성하기위한 특수 처리가 필요할 수 있습니다. 예를 들어 EBCDIC 플랫폼에서 &lt;code&gt;&quot;h&quot;&lt;/code&gt; 의 코드 포인트 는 0x88이고 &lt;code&gt;&quot;i&quot;&lt;/code&gt; 는 0x89이며 &lt;code&gt;&quot;j&quot;&lt;/code&gt; 는 0x91이며 &lt;code&gt;&quot;k&quot;&lt;/code&gt; 는 0x92입니다. Perl은 특별히 &lt;code&gt;[h-k]&lt;/code&gt; 를 처리 하여 0x8A에서 0x90까지의 갭에서 7 개의 코드 포인트를 제외시킵니다. 이 특수 처리는 범위가 ASCII 대문자, 소문자 및 숫자 범위 중 하나의 하위 범위 인 경우에만 호출되며 범위의 각 끝은 &lt;code&gt;&quot;A&quot;&lt;/code&gt; 와 같은 리터럴 또는 이름 지정된 문자 ( &lt;code&gt;\N{...}&lt;/code&gt; &lt;code&gt;\N{U+...&lt;/code&gt; 형식을 포함하여 ).</target>
        </trans-unit>
        <trans-unit id="d3478992830572c2488574386b02bb13d70d568a" translate="yes" xml:space="preserve">
          <source>Perl also guarantees that the ranges &lt;code&gt;A-Z&lt;/code&gt;, &lt;code&gt;a-z&lt;/code&gt;, &lt;code&gt;0-9&lt;/code&gt;, and any subranges of these match what an English-only speaker would expect them to match on any platform. That is, &lt;code&gt;[A-Z]&lt;/code&gt; matches the 26 ASCII uppercase letters; &lt;code&gt;[a-z]&lt;/code&gt; matches the 26 lowercase letters; and &lt;code&gt;[0-9]&lt;/code&gt; matches the 10 digits. Subranges, like &lt;code&gt;[h-k]&lt;/code&gt;, match correspondingly, in this case just the four letters &lt;code&gt;&quot;h&quot;&lt;/code&gt;, &lt;code&gt;&quot;i&quot;&lt;/code&gt;, &lt;code&gt;&quot;j&quot;&lt;/code&gt;, and &lt;code&gt;&quot;k&quot;&lt;/code&gt;. This is the natural behavior on ASCII platforms where the code points (ordinal values) for &lt;code&gt;&quot;h&quot;&lt;/code&gt; through &lt;code&gt;&quot;k&quot;&lt;/code&gt; are consecutive integers (0x68 through 0x6B). But special handling to achieve this may be needed on platforms with a non-ASCII native character set. For example, on EBCDIC platforms, the code point for &lt;code&gt;&quot;h&quot;&lt;/code&gt; is 0x88, &lt;code&gt;&quot;i&quot;&lt;/code&gt; is 0x89, &lt;code&gt;&quot;j&quot;&lt;/code&gt; is 0x91, and &lt;code&gt;&quot;k&quot;&lt;/code&gt; is 0x92. Perl specially treats &lt;code&gt;[h-k]&lt;/code&gt; to exclude the seven code points in the gap: 0x8A through 0x90. This special handling is only invoked when the range is a subrange of one of the ASCII uppercase, lowercase, and digit ranges, AND each end of the range is expressed either as a literal, like &lt;code&gt;&quot;A&quot;&lt;/code&gt;, or as a named character (&lt;code&gt;\N{...}&lt;/code&gt;, including the &lt;code&gt;\N{U+...&lt;/code&gt; form).</source>
          <target state="translated">Perl은 또한 범위 &lt;code&gt;A-Z&lt;/code&gt; , &lt;code&gt;a-z&lt;/code&gt; , &lt;code&gt;0-9&lt;/code&gt; 및 이들의 모든 하위 범위가 영어 전용 사용자가 모든 플랫폼에서 일치 할 것으로 기대하는 것과 일치 함을 보장합니다 . 즉, &lt;code&gt;[A-Z]&lt;/code&gt; 는 26 개의 ASCII 대문자와 일치합니다. &lt;code&gt;[a-z]&lt;/code&gt; 는 26 개의 소문자와 일치합니다. 그리고 &lt;code&gt;[0-9]&lt;/code&gt; 는 10 자리 숫자와 일치합니다. &lt;code&gt;[h-k]&lt;/code&gt; 와 같은 하위 범위는 이에 따라 일치합니다.이 경우에는 &lt;code&gt;&quot;h&quot;&lt;/code&gt; , &lt;code&gt;&quot;i&quot;&lt;/code&gt; , &lt;code&gt;&quot;j&quot;&lt;/code&gt; 및 &lt;code&gt;&quot;k&quot;&lt;/code&gt; 네 글자 만 일치합니다 . 이것은 &lt;code&gt;&quot;h&quot;&lt;/code&gt; 에서 &lt;code&gt;&quot;k&quot;&lt;/code&gt; 까지의 코드 포인트 (순서 값)가있는 ASCII 플랫폼의 자연스러운 동작입니다.연속 정수 (0x68에서 0x6B)입니다. 그러나이를 달성하기위한 특수 처리는 비 ASCII 기본 문자 세트가있는 플랫폼에서 필요할 수 있습니다. 예를 들어, EBCDIC 플랫폼에서 &lt;code&gt;&quot;h&quot;&lt;/code&gt; 의 코드 포인트 는 0x88, &lt;code&gt;&quot;i&quot;&lt;/code&gt; 는 0x89, &lt;code&gt;&quot;j&quot;&lt;/code&gt; 는 0x91, &lt;code&gt;&quot;k&quot;&lt;/code&gt; 는 0x92입니다. Perl은 특별히 &lt;code&gt;[h-k]&lt;/code&gt; 를 처리 하여 0x8A에서 0x90까지의 7 개의 코드 포인트를 제외합니다. 이 특수 처리는 범위가 ASCII 대문자, 소문자 및 숫자 범위 중 하나의 하위 범위이고 범위의 각 끝이 &lt;code&gt;&quot;A&quot;&lt;/code&gt; 와 같은 리터럴 또는 명명 된 문자 ( &lt;code&gt;\N{...}&lt;/code&gt; , &lt;code&gt;\N{U+...&lt;/code&gt; 양식 포함).</target>
        </trans-unit>
        <trans-unit id="43ed4c36b705c801489a6eaa310a7c1790004938" translate="yes" xml:space="preserve">
          <source>Perl also has environment variables that control how Perl handles data specific to particular natural languages; see &lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt;.</source>
          <target state="translated">Perl은 또한 Perl이 특정 자연 언어에 특정한 데이터를 처리하는 방법을 제어하는 ​​환경 변수를 가지고 있습니다. &lt;a href=&quot;perllocale&quot;&gt;perllocale을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="8ec1e88310a904c3504c234668eb6f0ebab9fa04" translate="yes" xml:space="preserve">
          <source>Perl also has its own built-in variables whose names don't follow these rules. They have strange names so they don't accidentally collide with one of your normal variables. Strings that match parenthesized parts of a regular expression are saved under names containing only digits after the &lt;code&gt;$&lt;/code&gt; (see &lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt; and &lt;a href=&quot;perlre&quot;&gt;perlre&lt;/a&gt;). In addition, several special variables that provide windows into the inner working of Perl have names containing punctuation characters and control characters. These are documented in &lt;a href=&quot;perlvar&quot;&gt;perlvar&lt;/a&gt;.</source>
          <target state="translated">Perl에는 이름이 이러한 규칙을 따르지 않는 자체 내장 변수도 있습니다. 그들은 이상한 이름을 가지고 있기 때문에 실수로 일반적인 변수 중 하나와 충돌하지 않습니다. 정규 표현식의 괄호로 묶은 부분과 일치하는 문자열은 &lt;code&gt;$&lt;/code&gt; 뒤에 숫자 만 포함 된 이름으로 저장됩니다 ( &lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt; 및 &lt;a href=&quot;perlre&quot;&gt;perlre&lt;/a&gt; 참조 ). 또한 Perl의 내부 작업에 창을 제공하는 몇 가지 특수 변수에는 문장 부호 문자와 제어 문자가 포함 된 이름이 있습니다. 이것들은 &lt;a href=&quot;perlvar&quot;&gt;perlvar&lt;/a&gt; 에 문서화되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="f3713f56b650ce5c5c9a6797e5a04ca7cc768c6f" translate="yes" xml:space="preserve">
          <source>Perl also has its own built-in variables whose names don't follow these rules. They have strange names so they don't accidentally collide with one of your normal variables. Strings that match parenthesized parts of a regular expression are saved under names containing only digits after the &lt;code&gt;$&lt;/code&gt; (see &lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt; and &lt;a href=&quot;perlre&quot;&gt;perlre&lt;/a&gt;). In addition, several special variables that provide windows into the inner working of Perl have names containing punctuation characters. These are documented in &lt;a href=&quot;perlvar&quot;&gt;perlvar&lt;/a&gt;.</source>
          <target state="translated">Perl에는 또한 이름이 이러한 규칙을 따르지 않는 자체 내장 변수가 있습니다. 그들은 이상한 이름을 가지고 있으므로 실수로 정상적인 변수 중 하나와 충돌하지 않습니다. 정규식의 괄호로 묶인 부분과 일치하는 문자열은 &lt;code&gt;$&lt;/code&gt; 뒤에 숫자 만 포함 된 이름으로 저장됩니다 ( &lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt; 및 &lt;a href=&quot;perlre&quot;&gt;perlre&lt;/a&gt; 참조 ). 또한 Perl의 내부 작업에 창을 제공하는 여러 특수 변수에는 구두점 문자가 포함 된 이름이 있습니다. 이것들은 &lt;a href=&quot;perlvar&quot;&gt;perlvar&lt;/a&gt; 에 문서화되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="841c07e6d7a8a9202a2c193293298a117297f325" translate="yes" xml:space="preserve">
          <source>Perl also has single-form extensions that refer to blocks, &lt;code&gt;In_Cyrillic&lt;/code&gt; , meaning &lt;code&gt;Block=Cyrillic&lt;/code&gt; . These have always been written in the new style.</source>
          <target state="translated">Perl은 또한 블록을 참조하는 단일 형식 확장을 가지고 있습니다 &lt;code&gt;In_Cyrillic&lt;/code&gt; 은 &lt;code&gt;Block=Cyrillic&lt;/code&gt; 을 의미 합니다. 이들은 항상 새로운 스타일로 작성되었습니다.</target>
        </trans-unit>
        <trans-unit id="5bfcb9a0154768c6b22ee7b3439e847665a12d5c" translate="yes" xml:space="preserve">
          <source>Perl also has single-form extensions that refer to blocks, &lt;code&gt;In_Cyrillic&lt;/code&gt;, meaning &lt;code&gt;Block=Cyrillic&lt;/code&gt;. These have always been written in the new style.</source>
          <target state="translated">Perl에는 &lt;code&gt;Block=Cyrillic&lt;/code&gt; 을 의미하는 &lt;code&gt;In_Cyrillic&lt;/code&gt; 블록을 참조하는 단일 형식 확장도 있습니다 . 이것들은 항상 새로운 스타일로 작성되었습니다.</target>
        </trans-unit>
        <trans-unit id="137aae63637704103b28432cb70098e2ba4ae7c0" translate="yes" xml:space="preserve">
          <source>Perl also lets you open a filehandle into an external program or shell command rather than into a file. You can do this in order to pass data from your Perl program to an external command for further processing, or to receive data from another program for your own Perl program to process.</source>
          <target state="translated">Perl을 사용하면 파일이 아닌 외부 프로그램이나 셸 명령으로 파일 핸들을 열 수 있습니다. Perl 프로그램의 데이터를 추가 처리를 위해 외부 명령으로 전달하거나 사용자 고유의 Perl 프로그램이 처리 할 수 ​​있도록 다른 프로그램에서 데이터를 수신하기 위해이를 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e768cdcaf855f3ac360271eae70fa3fb2f42dd9c" translate="yes" xml:space="preserve">
          <source>Perl also lets you use a dereferenced scalar reference in a method call. That's a mouthful, so let's look at some code:</source>
          <target state="translated">Perl을 사용하면 메소드 호출에서 역 참조 된 스칼라 참조를 사용할 수도 있습니다. 그것은 한 입입니다, 그래서 몇 가지 코드를 보자 :</target>
        </trans-unit>
        <trans-unit id="bb3ab86dafec3fc1c1204665ff3d23b69370b1f7" translate="yes" xml:space="preserve">
          <source>Perl also lets you use a scalar containing a string as a class name:</source>
          <target state="translated">Perl을 사용하면 문자열을 클래스 이름으로 포함하는 스칼라를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c015ec327f8f9a3ad1518fbf18a7cfa1b7b34e78" translate="yes" xml:space="preserve">
          <source>Perl also makes no guarantees that the representation of these code points won't change at some point in the future, say when machines become available that have larger than a 64-bit word. At that time, files containing any of these, written by an older Perl might require conversion before being readable by a newer Perl.</source>
          <target state="translated">Perl은 또한 이러한 코드 포인트의 표현이 미래의 어느 시점에서 변경되지 않을 것이라고 보장하지 않습니다. 예를 들어 64 비트 단어보다 큰 시스템이 출시 될 때 말입니다. 그 당시 이전 Perl로 작성된 이러한 파일을 포함하는 파일은 최신 Perl에서 읽기 전에 변환이 필요할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="371faeea377937a5cb124120c079958efb812b1f" translate="yes" xml:space="preserve">
          <source>Perl also provides some additional extensions and short-cut synonyms for Unicode properties.</source>
          <target state="translated">Perl은 유니 코드 속성에 대한 몇 가지 추가 확장명 및 바로 가기 동의어도 제공합니다.</target>
        </trans-unit>
        <trans-unit id="bc3b136059aadb780f36682ea1b93270fac2fc5f" translate="yes" xml:space="preserve">
          <source>Perl also uses two special typedefs, I32 and I16, which will always be at least 32-bits and 16-bits long, respectively. (Again, there are U32 and U16, as well.) They will usually be exactly 32 and 16 bits long, but on Crays they will both be 64 bits.</source>
          <target state="translated">Perl은 또한 각각 32 비트와 16 비트 길이 인 두 개의 특수 typedef 인 I32와 I16을 사용합니다. (다시 말해서 U32와 U16도 있습니다.) 보통 32 비트와 16 비트 길이이지만 Cray에서는 64 비트입니다.</target>
        </trans-unit>
        <trans-unit id="d9ec80db167215866b69eb0ca3e0370b7320f73c" translate="yes" xml:space="preserve">
          <source>Perl and its various modules and components, including its test frameworks, may sometimes make use of certain other environment variables. Some of these are specific to a particular platform. Please consult the appropriate module documentation and any documentation for your platform (like &lt;a href=&quot;perlsolaris&quot;&gt;perlsolaris&lt;/a&gt;, &lt;a href=&quot;perllinux&quot;&gt;perllinux&lt;/a&gt;, &lt;a href=&quot;perlmacosx&quot;&gt;perlmacosx&lt;/a&gt;, &lt;a href=&quot;perlwin32&quot;&gt;perlwin32&lt;/a&gt;, etc) for variables peculiar to those specific situations.</source>
          <target state="translated">테스트 프레임 워크를 포함하여 Perl과 다양한 모듈 및 구성 요소는 때때로 특정 환경 변수를 사용할 수 있습니다. 이들 중 일부는 특정 플랫폼에 따라 다릅니다. 적절한 모듈 설명서와 플랫폼에 대한 설명서 (예 : &lt;a href=&quot;perlsolaris&quot;&gt;perlsolaris&lt;/a&gt; , &lt;a href=&quot;perllinux&quot;&gt;perllinux&lt;/a&gt; , &lt;a href=&quot;perlmacosx&quot;&gt;perlmacosx&lt;/a&gt; ,&lt;a href=&quot;perlwin32&quot;&gt;&lt;/a&gt;특정 상황에 고유 한 변수에 perlwin32 등)를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="d1f38ea6665b57c86a485191974a93669f79515b" translate="yes" xml:space="preserve">
          <source>Perl applications</source>
          <target state="translated">펄 어플리케이션</target>
        </trans-unit>
        <trans-unit id="4025df8be02954e082a25375011463ff96fd6a98" translate="yes" xml:space="preserve">
          <source>Perl array references become JSON arrays.</source>
          <target state="translated">Perl 배열 참조는 JSON 배열이됩니다.</target>
        </trans-unit>
        <trans-unit id="502f7e3b25466218701794ac8b146d454581203f" translate="yes" xml:space="preserve">
          <source>Perl attempts to flush all files opened for output before forking the child process, but this may not be supported on some platforms (see &lt;a href=&quot;../perlport&quot;&gt;perlport&lt;/a&gt;). To be safe, you may need to set &lt;code&gt;$|&lt;/code&gt; ($AUTOFLUSH in English) or call the &lt;code&gt;autoflush()&lt;/code&gt; method of &lt;code&gt;IO::Handle&lt;/code&gt; on any open handles to avoid duplicate output.</source>
          <target state="translated">Perl은 하위 프로세스를 분기하기 전에 출력을 위해 열린 모든 파일을 비우려고 시도하지만 일부 플랫폼에서는 지원되지 않을 수 있습니다 ( &lt;a href=&quot;../perlport&quot;&gt;perlport&lt;/a&gt; 참조 ). 안전을 위해 &lt;code&gt;$|&lt;/code&gt; 를 설정해야 할 수도 있습니다. (영어로 $ AUTOFLUSH) 또는 출력이 중복되지 않도록 열려있는 &lt;code&gt;IO::Handle&lt;/code&gt; 에서 IO :: Handle 의 &lt;code&gt;autoflush()&lt;/code&gt; 메서드를 호출하십시오 .</target>
        </trans-unit>
        <trans-unit id="9e63e6195bf1a4edf392bb3f6dbbceb58829cc90" translate="yes" xml:space="preserve">
          <source>Perl attempts to flush all files opened for output before forking the child process, but this may not be supported on some platforms (see &lt;a href=&quot;perlport&quot;&gt;perlport&lt;/a&gt;). To be safe, you may need to set &lt;a href=&quot;perlvar#%24%7C&quot;&gt;&lt;code&gt;$|&lt;/code&gt;&lt;/a&gt; (&lt;code&gt;$AUTOFLUSH&lt;/code&gt; in &lt;a href=&quot;english&quot;&gt;English&lt;/a&gt;) or call the &lt;code&gt;autoflush&lt;/code&gt; method of &lt;a href=&quot;IO::Handle#METHODS&quot;&gt;&lt;code&gt;IO::Handle&lt;/code&gt;&lt;/a&gt; on any open handles to avoid duplicate output.</source>
          <target state="translated">Perl은 자식 프로세스를 포크하기 전에 출력을 위해 열려있는 모든 파일을 플러시하려고 시도하지만 일부 플랫폼에서는 지원되지 않을 수 있습니다 ( &lt;a href=&quot;perlport&quot;&gt;perlport&lt;/a&gt; 참조 ). 안전을 위해 &lt;a href=&quot;perlvar#%24%7C&quot;&gt; &lt;code&gt;$|&lt;/code&gt; &lt;/a&gt; 를 설정해야 할 수도 있습니다. ( &lt;code&gt;$AUTOFLUSH&lt;/code&gt; in &lt;a href=&quot;english&quot;&gt;English&lt;/a&gt; ) 또는 열려있는 &lt;a href=&quot;IO::Handle#METHODS&quot;&gt; &lt;code&gt;IO::Handle&lt;/code&gt; &lt;/a&gt; 에서 IO :: Handle 의 &lt;code&gt;autoflush&lt;/code&gt; 메서드를 호출하여 중복 출력을 방지합니다.</target>
        </trans-unit>
        <trans-unit id="310c094e234f2eeac0cd6d541a4252ff1573cf15" translate="yes" xml:space="preserve">
          <source>Perl attempts to flush all files opened for output before forking the child process, but this may not be supported on some platforms (see &lt;a href=&quot;perlport&quot;&gt;perlport&lt;/a&gt;). To be safe, you may need to set &lt;code&gt;$|&lt;/code&gt; ($AUTOFLUSH in English) or call the &lt;code&gt;autoflush()&lt;/code&gt; method of &lt;code&gt;IO::Handle&lt;/code&gt; on any open handles to avoid duplicate output.</source>
          <target state="translated">Perl은 하위 프로세스를 분기하기 전에 출력을 위해 열린 모든 파일을 비우려고 시도하지만 일부 플랫폼에서는 지원되지 않을 수 있습니다 ( &lt;a href=&quot;perlport&quot;&gt;perlport&lt;/a&gt; 참조 ). 안전을 위해 &lt;code&gt;$|&lt;/code&gt; 를 설정해야 할 수도 있습니다. (영어로 $ AUTOFLUSH) 또는 출력이 중복되지 않도록 열려있는 &lt;code&gt;IO::Handle&lt;/code&gt; 에서 IO :: Handle 의 &lt;code&gt;autoflush()&lt;/code&gt; 메서드를 호출하십시오 .</target>
        </trans-unit>
        <trans-unit id="de17dd0dec4269e99ee3620228765bf8385c7342" translate="yes" xml:space="preserve">
          <source>Perl attempts to flush all files opened for output before the exec, but this may not be supported on some platforms (see &lt;a href=&quot;../perlport&quot;&gt;perlport&lt;/a&gt;). To be safe, you may need to set &lt;code&gt;$|&lt;/code&gt; ($AUTOFLUSH in English) or call the &lt;code&gt;autoflush()&lt;/code&gt; method of &lt;code&gt;IO::Handle&lt;/code&gt; on any open handles to avoid lost output.</source>
          <target state="translated">Perl은 실행 전에 출력을 위해 열린 모든 파일을 비우려고 시도하지만 일부 플랫폼에서는 지원되지 않을 수 있습니다 ( &lt;a href=&quot;../perlport&quot;&gt;perlport&lt;/a&gt; 참조 ). 안전을 위해 &lt;code&gt;$|&lt;/code&gt; 를 설정해야 할 수도 있습니다. ($ AUTOFLUSH 영어) 또는 출력 손실을 피하기 위해 열려있는 &lt;code&gt;IO::Handle&lt;/code&gt; 에서 IO :: Handle 의 &lt;code&gt;autoflush()&lt;/code&gt; 메서드를 호출하십시오 .</target>
        </trans-unit>
        <trans-unit id="051c3f058010c205bb09ec0c0f5ce04fd3e0e5c9" translate="yes" xml:space="preserve">
          <source>Perl attempts to flush all files opened for output before the exec, but this may not be supported on some platforms (see &lt;a href=&quot;perlport&quot;&gt;perlport&lt;/a&gt;). To be safe, you may need to set &lt;a href=&quot;perlvar#%24%7C&quot;&gt;&lt;code&gt;$|&lt;/code&gt;&lt;/a&gt; (&lt;code&gt;$AUTOFLUSH&lt;/code&gt; in &lt;a href=&quot;english&quot;&gt;English&lt;/a&gt;) or call the &lt;code&gt;autoflush&lt;/code&gt; method of &lt;a href=&quot;IO::Handle#METHODS&quot;&gt;&lt;code&gt;IO::Handle&lt;/code&gt;&lt;/a&gt; on any open handles to avoid lost output.</source>
          <target state="translated">Perl은 exec 이전에 출력을 위해 열린 모든 파일을 플러시하려고 시도하지만 일부 플랫폼에서는 지원되지 않을 수 있습니다 ( &lt;a href=&quot;perlport&quot;&gt;perlport&lt;/a&gt; 참조 ). 안전을 위해 &lt;a href=&quot;perlvar#%24%7C&quot;&gt; &lt;code&gt;$|&lt;/code&gt; &lt;/a&gt; 를 설정해야 할 수도 있습니다. ( &lt;code&gt;$AUTOFLUSH&lt;/code&gt; in &lt;a href=&quot;english&quot;&gt;English&lt;/a&gt; ) 또는 열려있는 &lt;a href=&quot;IO::Handle#METHODS&quot;&gt; &lt;code&gt;IO::Handle&lt;/code&gt; &lt;/a&gt; 에서 IO :: Handle 의 &lt;code&gt;autoflush&lt;/code&gt; 메서드를 호출하여 출력 손실을 방지합니다.</target>
        </trans-unit>
        <trans-unit id="003b4d9ba004fb0af8689ed0414255d30b89d115" translate="yes" xml:space="preserve">
          <source>Perl attempts to flush all files opened for output before the exec, but this may not be supported on some platforms (see &lt;a href=&quot;perlport&quot;&gt;perlport&lt;/a&gt;). To be safe, you may need to set &lt;code&gt;$|&lt;/code&gt; ($AUTOFLUSH in English) or call the &lt;code&gt;autoflush()&lt;/code&gt; method of &lt;code&gt;IO::Handle&lt;/code&gt; on any open handles to avoid lost output.</source>
          <target state="translated">Perl은 실행 전에 출력을 위해 열린 모든 파일을 비우려고 시도하지만 일부 플랫폼에서는 지원되지 않을 수 있습니다 ( &lt;a href=&quot;perlport&quot;&gt;perlport&lt;/a&gt; 참조 ). 안전을 위해 &lt;code&gt;$|&lt;/code&gt; 를 설정해야 할 수도 있습니다. ($ AUTOFLUSH 영어) 또는 출력 손실을 피하기 위해 열려있는 &lt;code&gt;IO::Handle&lt;/code&gt; 에서 IO :: Handle 의 &lt;code&gt;autoflush()&lt;/code&gt; 메서드를 호출하십시오 .</target>
        </trans-unit>
        <trans-unit id="7d4f20a9384f8bc5428825b882bff482c1a8070c" translate="yes" xml:space="preserve">
          <source>Perl automatically calls the &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; method when processing a &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; statement for a module. Modules and &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; are documented in &lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt; and &lt;a href=&quot;perlmod&quot;&gt;perlmod&lt;/a&gt;. Understanding the concept of modules and how the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; statement operates is important to understanding the Exporter.</source>
          <target state="translated">Perl 은 모듈 의 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 문을 처리 할 때 &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; 메소드를 자동으로 호출합니다 . 모듈 및 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 은 &lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt; 및 &lt;a href=&quot;perlmod&quot;&gt;perlmod에&lt;/a&gt; 문서화되어 있습니다. 내보내기 개념을 이해하려면 모듈 개념과 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 문 작동 방식 을 이해해야합니다.</target>
        </trans-unit>
        <trans-unit id="6a95697cdde6d23d6eaf67c474daab5e6a483bb6" translate="yes" xml:space="preserve">
          <source>Perl automatically calls the &lt;code&gt;import&lt;/code&gt; method when processing a &lt;code&gt;use&lt;/code&gt; statement for a module. Modules and &lt;code&gt;use&lt;/code&gt; are documented in &lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt; and &lt;a href=&quot;perlmod&quot;&gt;perlmod&lt;/a&gt;. Understanding the concept of modules and how the &lt;code&gt;use&lt;/code&gt; statement operates is important to understanding the Exporter.</source>
          <target state="translated">Perl 은 모듈에 대한 &lt;code&gt;use&lt;/code&gt; 문을 처리 할 때 자동으로 &lt;code&gt;import&lt;/code&gt; 메서드를 호출합니다 . 모듈 및 &lt;code&gt;use&lt;/code&gt; 은 &lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt; 및 &lt;a href=&quot;perlmod&quot;&gt;perlmod에&lt;/a&gt; 문서화되어 있습니다. 모듈의 개념과 &lt;code&gt;use&lt;/code&gt; 문이 작동 하는 방식 을 이해하는 것은 Exporter를 이해하는 데 중요합니다.</target>
        </trans-unit>
        <trans-unit id="f61b6a6317cfa23498f15dd9d06745532cf81070" translate="yes" xml:space="preserve">
          <source>Perl automatically enables a set of special security checks, called</source>
          <target state="translated">Perl은 자동으로 특별한 보안 검사 세트를 활성화합니다.</target>
        </trans-unit>
        <trans-unit id="fbe832a4f97c9466dde588ba9b2da8adad2850de" translate="yes" xml:space="preserve">
          <source>Perl automatically handles most of the common ways a method might be redefined. However, there are a few ways you could change a method in a stash without the cache code noticing, in which case you need to call this method afterwards:</source>
          <target state="translated">Perl은 메소드를 재정의 할 수있는 대부분의 일반적인 방법을 자동으로 처리합니다. 그러나 캐시 코드를 알리지 않고 숨김에서 메소드를 변경할 수있는 몇 가지 방법이 있습니다.이 경우 나중에이 메소드를 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="c56019acc23d2639adf6a34824d254308e6f1860" translate="yes" xml:space="preserve">
          <source>Perl automatically loads &lt;code&gt;Errno&lt;/code&gt; the first time you use &lt;code&gt;%!&lt;/code&gt;, so you don't need an explicit &lt;code&gt;use&lt;/code&gt;.</source>
          <target state="translated">Perl 은 &lt;code&gt;%!&lt;/code&gt; 처음 사용할 때 자동으로 &lt;code&gt;Errno&lt;/code&gt; 를 로드합니다 ! , 따라서 명시 적으로 &lt;code&gt;use&lt;/code&gt; 필요가 없습니다 .</target>
        </trans-unit>
        <trans-unit id="036d8f87f677f8c5718f1d28012fa559462c3777" translate="yes" xml:space="preserve">
          <source>Perl automatically provides large file support when built under 64-bit Windows.</source>
          <target state="translated">Perl은 64 비트 Windows에서 빌드 될 때 자동으로 큰 파일 지원을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="7a716c995ea81037d2661a333de648b734bf1c68" translate="yes" xml:space="preserve">
          <source>Perl believes that no machine ever has more than one of &lt;code&gt;change&lt;/code&gt; , &lt;code&gt;age&lt;/code&gt; , or &lt;code&gt;quota&lt;/code&gt; implemented, nor more than one of either &lt;code&gt;comment&lt;/code&gt; or &lt;code&gt;class&lt;/code&gt; . Some machines do not support &lt;code&gt;expire&lt;/code&gt; , &lt;code&gt;gecos&lt;/code&gt; , or allegedly, &lt;code&gt;passwd&lt;/code&gt; . You may call these methods no matter what machine you're on, but they return &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; if unimplemented.</source>
          <target state="translated">Perl은 어떤 머신도 &lt;code&gt;change&lt;/code&gt; , &lt;code&gt;age&lt;/code&gt; 또는 &lt;code&gt;quota&lt;/code&gt; 중 하나 이상을 구현하거나 &lt;code&gt;comment&lt;/code&gt; 또는 &lt;code&gt;class&lt;/code&gt; 중 하나 이상을 구현 한 적이 없다고 생각합니다 . 일부 시스템은 &lt;code&gt;expire&lt;/code&gt; , &lt;code&gt;gecos&lt;/code&gt; 또는 &lt;code&gt;passwd&lt;/code&gt; 를 지원하지 않습니다 . 어떤 컴퓨터를 사용하든 이러한 메서드를 호출 할 수 있지만 구현되지 않은 경우 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="9fd89618c3b47a0e722e09957c69ce215a51cf2c" translate="yes" xml:space="preserve">
          <source>Perl believes that no machine ever has more than one of &lt;code&gt;change&lt;/code&gt;, &lt;code&gt;age&lt;/code&gt;, or &lt;code&gt;quota&lt;/code&gt; implemented, nor more than one of either &lt;code&gt;comment&lt;/code&gt; or &lt;code&gt;class&lt;/code&gt;. Some machines do not support &lt;code&gt;expire&lt;/code&gt;, &lt;code&gt;gecos&lt;/code&gt;, or allegedly, &lt;code&gt;passwd&lt;/code&gt;. You may call these methods no matter what machine you're on, but they return &lt;code&gt;undef&lt;/code&gt; if unimplemented.</source>
          <target state="translated">Perl은 어떤 기계도 &lt;code&gt;change&lt;/code&gt; , &lt;code&gt;age&lt;/code&gt; 또는 &lt;code&gt;quota&lt;/code&gt; 중 하나 이상이 구현되지 않았고 &lt;code&gt;comment&lt;/code&gt; 또는 &lt;code&gt;class&lt;/code&gt; 중 하나 이상이 구현 되지 않았다고 믿습니다 . 일부 머신은 &lt;code&gt;expire&lt;/code&gt; , &lt;code&gt;gecos&lt;/code&gt; 또는 &lt;code&gt;passwd&lt;/code&gt; 를 지원하지 않습니다 . 어떤 시스템을 사용하든 이러한 메서드를 호출 할 수 있지만 구현되지 않은 경우 &lt;code&gt;undef&lt;/code&gt; 를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="5d0360d06e2a1778dd48425c09025dbdf8293f8e" translate="yes" xml:space="preserve">
          <source>Perl binary able to run this extension, load XS modules, etc...</source>
          <target state="translated">Perl 바이너리는이 확장을 실행할 수 있고 XS 모듈 등을로드 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cb8da21c98e2920d923d329d6f68942a153a615f" translate="yes" xml:space="preserve">
          <source>Perl binary distributions come with a</source>
          <target state="translated">펄 바이너리 배포판은</target>
        </trans-unit>
        <trans-unit id="25b8cd5db95b73c8697ce2a24fc9a3c4624497ef" translate="yes" xml:space="preserve">
          <source>Perl binary for tasks that can be done by miniperl.</source>
          <target state="translated">miniperl로 수행 할 수있는 작업을위한 Perl 바이너리.</target>
        </trans-unit>
        <trans-unit id="5c60e05f40789a6f58044b7f99b3ed4077f167aa" translate="yes" xml:space="preserve">
          <source>Perl binary for tasks that can be done by miniperl. If it contains spaces or other shell metacharacters, it needs to be quoted in a way that protects them, since this value is intended to be inserted in a shell command line in the Makefile. E.g.:</source>
          <target state="translated">miniperl로 수행 할 수있는 작업을위한 Perl 바이너리. 공백이나 기타 쉘 메타 문자가 포함 된 경우 보호하는 방식으로 인용해야합니다.이 값은 Makefile의 쉘 명령 행에 삽입하기위한 것입니다. 예 :</target>
        </trans-unit>
        <trans-unit id="b72df5c4242785794c622b22864eb9d8a2e74001" translate="yes" xml:space="preserve">
          <source>Perl builds and runs on a bewildering number of platforms. Virtually all known and current Unix derivatives are supported (perl's native platform), as are other systems like VMS, DOS, OS/2, Windows, QNX, BeOS, OS X, MPE/iX and the Amiga.</source>
          <target state="translated">Perl은 놀라 울 정도로 많은 플랫폼에서 빌드하고 실행합니다. VMS, DOS, OS / 2, Windows, QNX, BeOS, OS X, MPE / iX 및 Amiga와 같은 다른 시스템과 마찬가지로 알려진 모든 최신 Unix 파생 제품 (perl의 기본 플랫폼)이 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="20d139451b19c9903cb470dbddc56287a00a07ca" translate="yes" xml:space="preserve">
          <source>Perl by default comes with the latest supported Unicode version built-in, but the goal is to allow you to change to use any earlier one. In Perls v5.20 and v5.22, however, the earliest usable version is Unicode 5.1. Perl v5.18 and v5.24 are able to handle all earlier versions.</source>
          <target state="translated">Perl은 기본적으로 지원되는 최신 유니 코드 버전이 내장되어 있지만 목표는 이전 버전을 사용하도록 변경하는 것입니다. 그러나 Perls v5.20 및 v5.22에서 사용 가능한 가장 초기 버전은 유니 코드 5.1입니다. Perl v5.18 및 v5.24는 모든 이전 버전을 처리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="96b360f2cb263510b9740f1a358943c2a62edfbc" translate="yes" xml:space="preserve">
          <source>Perl by default comes with the latest supported Unicode version built-in, but the goal is to allow you to change to use any earlier one. In Perls v5.20 and v5.22, however, the earliest usable version is Unicode 5.1. Perl v5.18 is able to handle all earlier versions.</source>
          <target state="translated">기본적으로 Perl에는 지원되는 최신 유니 코드 버전이 기본 제공되지만 목표는 이전 버전을 사용하도록 변경하는 것입니다. 그러나 Perls v5.20 및 v5.22에서 사용 가능한 가장 초기 버전은 유니 코드 5.1입니다. Perl v5.18은 모든 이전 버전을 처리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="858924b099068580d5d02f65c2520871f9621191" translate="yes" xml:space="preserve">
          <source>Perl by default is very forgiving. In order to make it more robust it is recommended to start every program with the following lines:</source>
          <target state="translated">Perl은 기본적으로 매우 관대합니다. 보다 견고하게하기 위해 모든 프로그램을 다음 줄로 시작하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="41943c9223a2849d683a6cec44cbaf36e58b907e" translate="yes" xml:space="preserve">
          <source>Perl can be built so that it by default will try to execute</source>
          <target state="translated">Perl은 기본적으로 실행을 시도하도록 빌드 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="36ba407dbee2d6e43709ef0153d960c56996ecc9" translate="yes" xml:space="preserve">
          <source>Perl can be compiled on platforms that run any of three commonly used EBCDIC character sets, listed below.</source>
          <target state="translated">Perl은 아래에 나열된 세 가지 일반적으로 사용되는 EBCDIC 문자 세트를 실행하는 플랫폼에서 컴파일 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bea19b77ce1281f9b9bf9a47baf0d79604e6dd7a" translate="yes" xml:space="preserve">
          <source>Perl can be compiled with either HP's ANSI C compiler or with gcc. The former is recommended, as not only can it compile Perl with no difficulty, but also can take advantage of features listed later that require the use of HP compiler-specific command-line flags.</source>
          <target state="translated">Perl은 HP의 ANSI C 컴파일러 또는 gcc로 컴파일 할 수 있습니다. 전자는 Perl을 어려움없이 컴파일 할 수있을뿐만 아니라 HP 컴파일러 특정 명령 행 플래그를 사용해야하는 나중에 나열된 기능을 활용할 수도 있으므로 권장됩니다.</target>
        </trans-unit>
        <trans-unit id="f05f1e5361560b59743e9bd4f32b54cc023f431f" translate="yes" xml:space="preserve">
          <source>Perl can be compiled with either IBM's ANSI C compiler or with gcc. The former is recommended, as not only can it compile Perl with no difficulty, but also can take advantage of features listed later that require the use of IBM compiler-specific command-line flags.</source>
          <target state="translated">Perl은 IBM ANSI C 컴파일러 또는 gcc로 컴파일 할 수 있습니다. 전자는 Perl을 어려움없이 컴파일 할 수있을뿐만 아니라 IBM 컴파일러 특정 명령 행 플래그를 사용해야하는 나중에 나열된 기능을 활용할 수 있으므로 권장됩니다.</target>
        </trans-unit>
        <trans-unit id="19a69f0e2f064ea4c82b3309e77eb45ccd797a4c" translate="yes" xml:space="preserve">
          <source>Perl can be compiled with either IBM's ANSI C compiler or with gcc. The former is recommended, as not only it can compile Perl with no difficulty, but also can take advantage of features listed later that require the use of IBM compiler-specific command-line flags.</source>
          <target state="translated">Perl은 IBM ANSI C 컴파일러 또는 gcc로 컴파일 할 수 있습니다. 전자는 Perl을 어려움없이 컴파일 할 수있을뿐만 아니라 IBM 컴파일러 특정 명령 행 플래그를 사용해야하는 나중에 나열된 기능을 활용할 수 있으므로 권장됩니다.</target>
        </trans-unit>
        <trans-unit id="1eec7cebb78e4a4eae8424666c3dade6b3981bcc" translate="yes" xml:space="preserve">
          <source>Perl can be compiled with gcc from MinGW (version 3.4.5 or later) or from MinGW64 (version 4.4.3 or later). It can be downloaded here:</source>
          <target state="translated">Perl은 MinGW (버전 3.4.5 이상) 또는 MinGW64 (버전 4.4.3 이상)에서 gcc로 컴파일 할 수 있습니다. 여기에서 다운로드 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="751c036d6e62fec07bc2f5f4e73156154792a0fd" translate="yes" xml:space="preserve">
          <source>Perl can be compiled with gcc from MinGW release 3 and later (using gcc 3.4.5 and later). It can be downloaded here:</source>
          <target state="translated">Perl은 MinGW 릴리스 3 이상에서 gcc로 컴파일 할 수 있습니다 (gcc 3.4.5 이상 사용). 여기에서 다운로드 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5aad21700ba14174a334f6c9d33b139e2bf40c72" translate="yes" xml:space="preserve">
          <source>Perl can be cross-compiled using either adb or a normal ssh connection; in general, if you can connect your device to the host using a USB port, or if you don't feel like installing an sshd app on your device, you may want to use adb, although you may be forced to switch to ssh if your device is not rooted and you're unlucky -- more on that later. Alternatively, if you're cross-compiling to an emulator, you'll have to use adb.</source>
          <target state="translated">Perl은 adb 또는 일반 ssh 연결을 사용하여 크로스 컴파일 할 수 있습니다. 일반적으로 USB 포트를 사용하여 장치를 호스트에 연결할 수 있거나 장치에 sshd 앱을 설치하고 싶지 않은 경우 adb를 사용할 수 있습니다. 당신의 장치는 루팅되지 않았고 당신은 불행합니다. 또는 에뮬레이터로 크로스 컴파일하는 경우 adb를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="298c207dde281e03961c0f741436a83e917ef6d5" translate="yes" xml:space="preserve">
          <source>Perl can be run under the &quot;C&quot; locale by setting the environment variable &lt;code&gt;LC_ALL&lt;/code&gt; to &quot;C&quot;. This method is perhaps a bit more civilized than the &lt;code&gt;PERL_BADLANG&lt;/code&gt; approach, but setting &lt;code&gt;LC_ALL&lt;/code&gt; (or other locale variables) may affect other programs as well, not just Perl. In particular, external programs run from within Perl will see these changes. If you make the new settings permanent (read on), all programs you run see the changes. See &lt;a href=&quot;#ENVIRONMENT&quot;&gt;&quot;ENVIRONMENT&quot;&lt;/a&gt; for the full list of relevant environment variables and &lt;a href=&quot;#USING-LOCALES&quot;&gt;&quot;USING LOCALES&quot;&lt;/a&gt; for their effects in Perl. Effects in other programs are easily deducible. For example, the variable &lt;code&gt;LC_COLLATE&lt;/code&gt; may well affect your &lt;b&gt;sort&lt;/b&gt; program (or whatever the program that arranges &quot;records&quot; alphabetically in your system is called).</source>
          <target state="translated">Perl은 환경 변수 &lt;code&gt;LC_ALL&lt;/code&gt; 을 &quot;C&quot; 로 설정하여 &quot;C&quot;로케일에서 실행할 수 있습니다 . 이 방법은 &lt;code&gt;PERL_BADLANG&lt;/code&gt; 접근 방식 보다 조금 더 문명화되어 있지만 &lt;code&gt;LC_ALL&lt;/code&gt; (또는 다른 로케일 변수)을 설정하면 Perl뿐만 아니라 다른 프로그램에도 영향을 미칠 수 있습니다. 특히 Perl 내에서 실행되는 외부 프로그램은 이러한 변경 사항을 볼 수 있습니다. 새 설정을 영구적 (읽기)으로 지정하면 실행하는 모든 프로그램에 변경 사항이 표시됩니다. 관련 환경 변수의 전체 목록은 &lt;a href=&quot;#ENVIRONMENT&quot;&gt;&quot;ENVIRONMENT&quot;&lt;/a&gt; 를 참조 하고 Perl에서의 효과에 대해서는 &lt;a href=&quot;#USING-LOCALES&quot;&gt;&quot;USING LOCALES&quot;&lt;/a&gt; 를 참조하십시오 . 다른 프로그램의 효과는 쉽게 추론 할 수 있습니다. 예를 들어, &lt;code&gt;LC_COLLATE&lt;/code&gt; 변수 는 &lt;b&gt;정렬에&lt;/b&gt; 영향을 줄 수 있습니다.&lt;b&gt;&lt;/b&gt; 프로그램 (또는 시스템에서 &quot;레코드&quot;를 알파벳순으로 정렬하는 프로그램이 호출 됨).</target>
        </trans-unit>
        <trans-unit id="2e57623077581e01731874e47fb8c2a4b90f970b" translate="yes" xml:space="preserve">
          <source>Perl can be run under the &quot;C&quot; locale by setting the environment variable &lt;code&gt;LC_ALL&lt;/code&gt; to &quot;C&quot;. This method is perhaps a bit more civilized than the &lt;code&gt;PERL_BADLANG&lt;/code&gt; approach, but setting &lt;code&gt;LC_ALL&lt;/code&gt; (or other locale variables) may affect other programs as well, not just Perl. In particular, external programs run from within Perl will see these changes. If you make the new settings permanent (read on), all programs you run see the changes. See &lt;a href=&quot;#ENVIRONMENT&quot;&gt;ENVIRONMENT&lt;/a&gt; for the full list of relevant environment variables and &lt;a href=&quot;#USING-LOCALES&quot;&gt;USING LOCALES&lt;/a&gt; for their effects in Perl. Effects in other programs are easily deducible. For example, the variable &lt;code&gt;LC_COLLATE&lt;/code&gt; may well affect your &lt;b&gt;sort&lt;/b&gt; program (or whatever the program that arranges &quot;records&quot; alphabetically in your system is called).</source>
          <target state="translated">환경 변수 &lt;code&gt;LC_ALL&lt;/code&gt; 을 &quot;C&quot; 로 설정하여 &quot;C&quot;로케일에서 Perl을 실행할 수 있습니다 . 이 방법은 아마도 &lt;code&gt;PERL_BADLANG&lt;/code&gt; 접근법 보다 약간 문명화 되었지만 &lt;code&gt;LC_ALL&lt;/code&gt; (또는 다른 로케일 변수)을 설정하면 Perl뿐만 아니라 다른 프로그램에도 영향을 줄 수 있습니다. 특히 Perl 내에서 실행되는 외부 프로그램은 이러한 변경 사항을 보게됩니다. 새 설정을 영구적 (읽기)으로 설정하면 실행하는 모든 프로그램에 변경 사항이 표시됩니다. 참조 &lt;a href=&quot;#ENVIRONMENT&quot;&gt;환경을&lt;/a&gt; 전체 관련 환경 변수의 목록에 대한 &lt;a href=&quot;#USING-LOCALES&quot;&gt;로케일을 사용&lt;/a&gt; 펄에서의 효과. 다른 프로그램의 효과는 쉽게 추론 할 수 있습니다. 예를 들어 &lt;code&gt;LC_COLLATE&lt;/code&gt; 변수 는&lt;b&gt; 정렬에&lt;/b&gt; 프로그램 (또는 시스템에서 알파벳순으로 &quot;레코드&quot;를 정렬하는 프로그램이 호출 됨).</target>
        </trans-unit>
        <trans-unit id="afea4028a165b75f73beb84894121ff0308d01df" translate="yes" xml:space="preserve">
          <source>Perl can be used for almost any coding problem, even ones which require integrating specialist C code for extra speed. As with any tool it can be used well or badly. Perl has many strengths, and a few weaknesses, precisely which areas are good and bad is often a personal choice.</source>
          <target state="translated">Perl은 거의 모든 코딩 문제에 사용할 수 있으며 추가 속도를 위해 전문가 C 코드를 통합해야하는 경우도 있습니다. 모든 도구와 마찬가지로 잘 사용하거나 잘못 사용할 수 있습니다. 펄은 많은 강점과 약점을 가지고 있으며, 어떤 영역이 좋고 나쁜지 정확하게 개인 선택입니다.</target>
        </trans-unit>
        <trans-unit id="9f84aec4fa7ef06751c778c8e8173ffe00dcd629" translate="yes" xml:space="preserve">
          <source>Perl can compile and run under EBCDIC platforms. See &lt;a href=&quot;perlebcdic&quot;&gt;perlebcdic&lt;/a&gt;. This is transparent for the most part, but because the character sets differ, you shouldn't use numeric (decimal, octal, nor hex) constants to refer to characters. You can safely say &lt;code&gt;'A'&lt;/code&gt; , but not &lt;code&gt;0x41&lt;/code&gt; . You can safely say &lt;code&gt;'\n'&lt;/code&gt; , but not &lt;code&gt;\012&lt;/code&gt; . However, you can use macros defined in</source>
          <target state="translated">Perl은 EBCDIC 플랫폼에서 컴파일하고 실행할 수 있습니다. &lt;a href=&quot;perlebcdic&quot;&gt;perlebcdic를&lt;/a&gt; 참조하십시오 . 이것은 대부분 투명하지만 문자 집합이 다르기 때문에 숫자 (10 진, 8 진 또는 16 진) 상수를 사용하여 문자를 참조하면 안됩니다. &lt;code&gt;'A'&lt;/code&gt; 라고 안전하게 말할 수 있지만 &lt;code&gt;0x41&lt;/code&gt; 은 말할 수 없습니다 . 안전하게 &lt;code&gt;'\n'&lt;/code&gt; 말할 수 있지만 &lt;code&gt;\012&lt;/code&gt; 말할 수 없습니다 . 그러나에 정의 된 매크로를 사용할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="89da686bd0b150df7259283a72feb17be88ef847" translate="yes" xml:space="preserve">
          <source>Perl can compile and run under EBCDIC platforms. See &lt;a href=&quot;perlebcdic&quot;&gt;perlebcdic&lt;/a&gt;. This is transparent for the most part, but because the character sets differ, you shouldn't use numeric (decimal, octal, nor hex) constants to refer to characters. You can safely say &lt;code&gt;'A'&lt;/code&gt;, but not &lt;code&gt;0x41&lt;/code&gt;. You can safely say &lt;code&gt;'\n'&lt;/code&gt;, but not &lt;code&gt;\012&lt;/code&gt;. However, you can use macros defined in</source>
          <target state="translated">Perl은 EBCDIC 플랫폼에서 컴파일하고 실행할 수 있습니다. &lt;a href=&quot;perlebcdic&quot;&gt;perlebcdic을&lt;/a&gt; 참조하십시오 . 대부분의 경우 투명하지만 문자 집합이 다르기 때문에 문자를 참조하는 데 숫자 (10 진수, 8 진수 또는 16 진수) 상수를 사용해서는 안됩니다. ㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ &lt;code&gt;0x41&lt;/code&gt; 이 아닌 &lt;code&gt;'A'&lt;/code&gt; 라고 안전하게 말할 수 있습니다 . &lt;code&gt;'\n'&lt;/code&gt; 이라고 안전하게 말할 수 있지만 &lt;code&gt;\012&lt;/code&gt; 말할 수 없습니다 . 그러나 다음에 정의 된 매크로를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fa07386a80b47ab8df8b6dbe1e6a41311efb8910" translate="yes" xml:space="preserve">
          <source>Perl can internally represent numbers in 3 different ways: as native integers, as native floating point numbers, and as decimal strings. Decimal strings may have an exponential notation part, as in &lt;code&gt;&quot;12.34e-56&quot;&lt;/code&gt; .</source>
          <target state="translated">펄은 내부적으로 3 가지 방식으로 숫자를 표현할 수 있습니다 : 기본 정수, 기본 부동 소수점 숫자 및 10 진수 문자열. &lt;code&gt;&quot;12.34e-56&quot;&lt;/code&gt; 에서와 같이 십진 문자열에는 지수 표기법 부분이있을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="91d8093cdc26010bc75cbe7ac13c80dda1139d5f" translate="yes" xml:space="preserve">
          <source>Perl can internally represent numbers in 3 different ways: as native integers, as native floating point numbers, and as decimal strings. Decimal strings may have an exponential notation part, as in &lt;code&gt;&quot;12.34e-56&quot;&lt;/code&gt;.</source>
          <target state="translated">Perl은 내부적으로 기본 정수, 기본 부동 소수점 숫자 및 십진 문자열의 세 가지 방법으로 숫자를 나타낼 수 있습니다. 십진 문자열은 &lt;code&gt;&quot;12.34e-56&quot;&lt;/code&gt; 과 같이 지수 표기법 부분을 가질 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="05cb1fb37d34785f635f75844d77033b80fc24ef" translate="yes" xml:space="preserve">
          <source>Perl can process line directives, much like the C preprocessor. Using this, one can control Perl's idea of filenames and line numbers in error or warning messages (especially for strings that are processed with &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval()&lt;/a&gt;&lt;/code&gt;). The syntax for this mechanism is almost the same as for most C preprocessors: it matches the regular expression</source>
          <target state="translated">Perl은 C 프리 프로세서와 매우 유사한 라인 지시문을 처리 할 수 ​​있습니다. 이를 사용하여 오류 또는 경고 메시지 (특히 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval()&lt;/a&gt;&lt;/code&gt; 로 처리되는 문자열의 경우)에서 파일 이름 및 줄 번호에 대한 Perl의 아이디어를 제어 할 수 있습니다. . 이 메커니즘의 구문은 대부분의 C 프리 프로세서와 거의 동일합니다. 정규식과 일치합니다.</target>
        </trans-unit>
        <trans-unit id="5dbe3afd1eb59bb8a6efe4b4b5b6385c4ed178c9" translate="yes" xml:space="preserve">
          <source>Perl can process line directives, much like the C preprocessor. Using this, one can control Perl's idea of filenames and line numbers in error or warning messages (especially for strings that are processed with &lt;code&gt;eval()&lt;/code&gt;). The syntax for this mechanism is almost the same as for most C preprocessors: it matches the regular expression</source>
          <target state="translated">Perl은 C 전 처리기처럼 라인 지시문을 처리 할 수 ​​있습니다. 이를 사용하여 오류 또는 경고 메시지 (특히 &lt;code&gt;eval()&lt;/code&gt; 로 처리되는 문자열의 경우)에서 파일 이름과 줄 번호에 대한 Perl의 아이디어를 제어 할 수 있습니다 . 이 메커니즘의 구문은 대부분의 C 전처리 기와 거의 동일합니다. 정규 표현식과 일치합니다.</target>
        </trans-unit>
        <trans-unit id="0c1175d291fc9d1138f03be93ce22b47fc929ba6" translate="yes" xml:space="preserve">
          <source>Perl can provide access to all non-provisional Unicode character properties, though not all are enabled by default. The omitted ones are the Unihan properties (accessible via the CPAN module &lt;a href=&quot;Unicode::Unihan&quot;&gt;Unicode::Unihan&lt;/a&gt;) and certain deprecated or Unicode-internal properties. (An installation may choose to recompile Perl's tables to change this. See &lt;a href=&quot;#Unicode-character-properties-that-are-NOT-accepted-by-Perl&quot;&gt;&quot;Unicode character properties that are NOT accepted by Perl&quot;&lt;/a&gt;.)</source>
          <target state="translated">Perl은 모든 비 프로비저닝 유니 코드 문자 속성에 대한 액세스를 제공 할 수 있지만 기본적으로 모두 활성화되어 있지는 않습니다. 생략 된 것은 Unihan 속성 (CPAN 모듈 &lt;a href=&quot;Unicode::Unihan&quot;&gt;Unicode :: Unihan을&lt;/a&gt; 통해 액세스 할 수 있음 )과 사용되지 않는 특정 또는 유니 코드 내부 속성입니다. (설치시 Perl의 테이블을 다시 컴파일하여이를 변경할 수 있습니다. &lt;a href=&quot;#Unicode-character-properties-that-are-NOT-accepted-by-Perl&quot;&gt;&quot;Perl에서 허용하지 않는 유니 코드 문자 속성&quot;을&lt;/a&gt; 참조하십시오 .)</target>
        </trans-unit>
        <trans-unit id="87b4bc522cc9bacefe7588c2849722683c7ccc0c" translate="yes" xml:space="preserve">
          <source>Perl can provide access to all non-provisional Unicode character properties, though not all are enabled by default. The omitted ones are the Unihan properties (accessible via the CPAN module &lt;a href=&quot;http://search.cpan.org/perldoc/Unicode::Unihan&quot;&gt;Unicode::Unihan&lt;/a&gt;) and certain deprecated or Unicode-internal properties. (An installation may choose to recompile Perl's tables to change this. See &lt;a href=&quot;#Unicode-character-properties-that-are-NOT-accepted-by-Perl&quot;&gt;Unicode character properties that are NOT accepted by Perl&lt;/a&gt;.)</source>
          <target state="translated">Perl은 임시가 아닌 모든 유니 코드 문자 속성에 대한 액세스를 제공 할 수 있지만 모든 것이 기본적으로 활성화되어 있지는 않습니다. 생략 된 속성은 Unihan 속성 (CPAN 모듈 &lt;a href=&quot;http://search.cpan.org/perldoc/Unicode::Unihan&quot;&gt;Unicode :: Unihan을&lt;/a&gt; 통해 액세스 가능 )과 더 이상 사용되지 않거나 유니 코드 내부 속성입니다. (설치는이를 변경하기 위해 Perl의 테이블을 다시 컴파일하도록 선택할 수 있습니다. Perl에서 &lt;a href=&quot;#Unicode-character-properties-that-are-NOT-accepted-by-Perl&quot;&gt;허용되지 않는 유니 코드 문자 특성을&lt;/a&gt; 참조하십시오 .)</target>
        </trans-unit>
        <trans-unit id="b9d3bae2bf6cbe36ec81823e26589a3e2497f6c1" translate="yes" xml:space="preserve">
          <source>Perl cannot be compiled with threading support ATM.</source>
          <target state="translated">스레딩 지원 ATM으로 Perl을 컴파일 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="5aa9ff89c6dfca6cc410567a511ce06ca99ab635" translate="yes" xml:space="preserve">
          <source>Perl cannot protect you from all possibilities shown in the examples--there is no substitute for your own vigilance--but, when &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; is in effect, Perl uses the tainting mechanism (see &lt;a href=&quot;perlsec&quot;&gt;perlsec&lt;/a&gt;) to mark string results that become locale-dependent, and which may be untrustworthy in consequence. Here is a summary of the tainting behavior of operators and functions that may be affected by the locale:</source>
          <target state="translated">Perl은 예제에 표시된 모든 가능성으로부터 사용자를 보호 할 수 없습니다 (자신의 경계를 대신 할 수는 없지만) &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; &lt;a href=&quot;functions/use&quot;&gt;사용&lt;/a&gt; 이 유효한 경우 Perl은 오염 메커니즘 ( &lt;a href=&quot;perlsec&quot;&gt;perlsec&lt;/a&gt; 참조 )을 사용하여 로케일에 따라 달라지는 문자열 결과를 표시합니다. 신뢰할 수없는 결과 일 수 있습니다. 로케일의 영향을받을 수있는 연산자 및 함수의 오염 동작에 대한 요약은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a594f813141415e6aca23ee60e047f5b3f5ab72f" translate="yes" xml:space="preserve">
          <source>Perl cannot protect you from all possibilities shown in the examples--there is no substitute for your own vigilance--but, when &lt;code&gt;use locale&lt;/code&gt; is in effect, Perl uses the tainting mechanism (see &lt;a href=&quot;perlsec&quot;&gt;perlsec&lt;/a&gt;) to mark string results that become locale-dependent, and which may be untrustworthy in consequence. Here is a summary of the tainting behavior of operators and functions that may be affected by the locale:</source>
          <target state="translated">Perl은 예제에 표시된 모든 가능성으로부터 사용자를 보호 할 수 없습니다 (자신의 경계를 대신 할 수는 없습니다). 그러나 &lt;code&gt;use locale&lt;/code&gt; 이 적용되면 Perl은 오염 메커니즘 ( &lt;a href=&quot;perlsec&quot;&gt;perlsec&lt;/a&gt; 참조 )을 사용하여 로케일 종속이되는 문자열 결과를 표시합니다. , 그리고 결과적으로 신뢰할 수 없을 수 있습니다. 다음은 로케일의 영향을받을 수있는 연산자 및 함수의 오염 동작에 대한 요약입니다.</target>
        </trans-unit>
        <trans-unit id="d5f3aa702381872bb34697babcd6d91dd23feeed" translate="yes" xml:space="preserve">
          <source>Perl code is always compiled into an internal format before execution.</source>
          <target state="translated">Perl 코드는 실행 전에 항상 내부 형식으로 컴파일됩니다.</target>
        </trans-unit>
        <trans-unit id="cbb579bb2906840ac41b443c221a57b4ff511c5a" translate="yes" xml:space="preserve">
          <source>Perl code should convert to either call &lt;a href=&quot;perlapi#Perl_setlocale&quot;&gt;&lt;code&gt;Perl_setlocale&lt;/code&gt;&lt;/a&gt; (which is a drop-in for the system &lt;code&gt;setlocale&lt;/code&gt;) or use the methods given in &lt;a href=&quot;perlcall&quot;&gt;perlcall&lt;/a&gt; to call &lt;a href=&quot;posix#setlocale&quot;&gt;&lt;code&gt;POSIX::setlocale&lt;/code&gt;&lt;/a&gt;. Either one will transparently properly handle all cases of single- vs multi-thread, POSIX 2008-supported or not.</source>
          <target state="translated">Perl 코드는 &lt;a href=&quot;perlapi#Perl_setlocale&quot;&gt; &lt;code&gt;Perl_setlocale&lt;/code&gt; &lt;/a&gt; (시스템 &lt;code&gt;setlocale&lt;/code&gt; 의 드롭 인 ) 을 호출 하거나 &lt;a href=&quot;perlcall&quot;&gt;perlcall&lt;/a&gt; 에 제공된 메소드를 사용하여 &lt;a href=&quot;posix#setlocale&quot;&gt; &lt;code&gt;POSIX::setlocale&lt;/code&gt; &lt;/a&gt; 을 호출하도록 변환해야 합니다. 둘 중 하나는 POSIX 2008 지원 여부에 관계없이 단일 스레드 대 다중 스레드의 모든 경우를 투명하게 적절하게 처리합니다.</target>
        </trans-unit>
        <trans-unit id="c5cce9b9678a00b1fe024a9af1e795642a5bcb9c" translate="yes" xml:space="preserve">
          <source>Perl comes with a wide selection of builtin functions. Some of the ones we've already seen include &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/reverse&quot;&gt;reverse&lt;/a&gt;&lt;/code&gt;. A list of them is given at the start of &lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt; and you can easily read about any given function by using &lt;code&gt;perldoc -f &lt;i&gt;functionname&lt;/i&gt;&lt;/code&gt;.</source>
          <target state="translated">Perl은 다양한 내장 기능을 제공합니다. 우리가 이미 본 것 중 일부는 &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;functions/reverse&quot;&gt;reverse&lt;/a&gt;&lt;/code&gt; 입니다. 이들의 목록은 &lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt; 시작시 제공되며 &lt;code&gt;perldoc -f &lt;i&gt;functionname&lt;/i&gt;&lt;/code&gt; 을 사용하여 주어진 기능에 대해 쉽게 읽을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="79ae445a5a6eedaef6fa6773c44a0f926e1cd176" translate="yes" xml:space="preserve">
          <source>Perl comes with a wide selection of builtin functions. Some of the ones we've already seen include &lt;code&gt;print&lt;/code&gt;, &lt;code&gt;sort&lt;/code&gt; and &lt;code&gt;reverse&lt;/code&gt;. A list of them is given at the start of &lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt; and you can easily read about any given function by using &lt;code&gt;perldoc -f &lt;i&gt;functionname&lt;/i&gt;&lt;/code&gt;.</source>
          <target state="translated">Perl은 다양한 내장 함수를 제공합니다. 우리가 이미 본 것들 중 일부는 &lt;code&gt;print&lt;/code&gt; , &lt;code&gt;sort&lt;/code&gt; 및 &lt;code&gt;reverse&lt;/code&gt; 를 포함 합니다. 이들 목록은 &lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt; 시작 부분에 제공되며 &lt;code&gt;perldoc -f &lt;i&gt;functionname&lt;/i&gt;&lt;/code&gt; 을 사용하여 주어진 함수에 대해 쉽게 읽을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d575f0416db18e1fc564b29cf8cc390222ecf415" translate="yes" xml:space="preserve">
          <source>Perl comes with an interactive debugger, which you can start with the &lt;code&gt;-d&lt;/code&gt; switch. It's fully explained in &lt;a href=&quot;perldebug&quot;&gt;perldebug&lt;/a&gt;.</source>
          <target state="translated">Perl은 대화식 디버거와 함께 제공되며 &lt;code&gt;-d&lt;/code&gt; 스위치로 시작할 수 있습니다 . &lt;a href=&quot;perldebug&quot;&gt;perldebug에&lt;/a&gt; 자세히 설명되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="641c8779114365eacf0b514d71b892f3c88f6444" translate="yes" xml:space="preserve">
          <source>Perl compiler backend to produce perl code</source>
          <target state="translated">펄 코드를 생성하는 펄 컴파일러 백엔드</target>
        </trans-unit>
        <trans-unit id="3d5234796bebd4a0240f58d33b5d22994612e499" translate="yes" xml:space="preserve">
          <source>Perl contains internal support for reporting its own memory usage, but this is a fairly advanced concept that requires some understanding of how memory allocation works. See &lt;a href=&quot;perldebguts#Debugging-Perl-Memory-Usage&quot;&gt;&quot;Debugging Perl Memory Usage&quot; in perldebguts&lt;/a&gt; for the details.</source>
          <target state="translated">Perl에는 자체 메모리 사용량을보고하기위한 내부 지원이 포함되어 있지만 이는 메모리 할당이 작동하는 방식을 이해해야하는 상당히 진보 된 개념입니다. 자세한 내용 &lt;a href=&quot;perldebguts#Debugging-Perl-Memory-Usage&quot;&gt;은 perldebguts의 &quot;Perl 메모리 사용량 디버깅&quot;을&lt;/a&gt; 참조 하십시오.</target>
        </trans-unit>
        <trans-unit id="a425209baf3b199ee00ab768f1943ede83ed4ff4" translate="yes" xml:space="preserve">
          <source>Perl contains internal support for reporting its own memory usage, but this is a fairly advanced concept that requires some understanding of how memory allocation works. See &lt;a href=&quot;perldebguts#Debugging-Perl-Memory-Usage&quot;&gt;Debugging Perl Memory Usage in perldebguts&lt;/a&gt; for the details.</source>
          <target state="translated">Perl은 자체 메모리 사용을보고하기위한 내부 지원을 포함하지만 이것은 메모리 할당 작동 방식에 대한 이해가 필요한 상당히 고급 개념입니다. 자세한 내용 &lt;a href=&quot;perldebguts#Debugging-Perl-Memory-Usage&quot;&gt;은 perldebguts에서 Perl 메모리 사용 디버깅을&lt;/a&gt; 참조 하십시오.</target>
        </trans-unit>
        <trans-unit id="dd31498cb274469b540952840b7aa19174e08b34" translate="yes" xml:space="preserve">
          <source>Perl continues to support the old non UTF-8 locales as well. There are currently no UTF-8 locales for EBCDIC platforms.</source>
          <target state="translated">Perl은 이전 비 UTF-8 로케일도 계속 지원합니다. 현재 EBCDIC 플랫폼에 대한 UTF-8 로케일은 없습니다.</target>
        </trans-unit>
        <trans-unit id="a29ee67698d8ff496114e40d0f60aa708da987ff" translate="yes" xml:space="preserve">
          <source>Perl continues to warn (using the warning category &lt;code&gt;&quot;nonchar&quot;&lt;/code&gt; , which is a sub-category of &lt;code&gt;&quot;utf8&quot;&lt;/code&gt; ) if an attempt is made to output noncharacters.</source>
          <target state="translated">비 문자를 출력하려고 시도하는 경우 Perl은 계속 경고합니다 (경고 범주 &lt;code&gt;&quot;nonchar&quot;&lt;/code&gt; , &lt;code&gt;&quot;utf8&quot;&lt;/code&gt; 의 하위 범주 사용 ).</target>
        </trans-unit>
        <trans-unit id="9cb01f485dfc78123b0a04671230b175342a0686" translate="yes" xml:space="preserve">
          <source>Perl continues to warn (using the warning category &lt;code&gt;&quot;nonchar&quot;&lt;/code&gt;, which is a sub-category of &lt;code&gt;&quot;utf8&quot;&lt;/code&gt;) if an attempt is made to output noncharacters.</source>
          <target state="translated">Perl은 비 문자를 출력하려고 시도하는 경우 계속 경고합니다 ( &lt;code&gt;&quot;utf8&quot;&lt;/code&gt; 의 하위 범주 인 경고 범주 &lt;code&gt;&quot;nonchar&quot;&lt;/code&gt; 사용 ).</target>
        </trans-unit>
        <trans-unit id="f9d488e88c0eb0084402cd1c0721ceebc56fc521" translate="yes" xml:space="preserve">
          <source>Perl core development team.</source>
          <target state="translated">Perl 핵심 개발 팀.</target>
        </trans-unit>
        <trans-unit id="baa05b026a869001e1e5be6e67df2e5d03445c53" translate="yes" xml:space="preserve">
          <source>Perl currently only supports single-byte locales for &lt;code&gt;LC_COLLATE&lt;/code&gt; . This means that a UTF-8 locale likely will just give you machine-native ordering. Use &lt;a href=&quot;unicode/collate&quot;&gt;Unicode::Collate&lt;/a&gt; for the full implementation of the Unicode Collation Algorithm.</source>
          <target state="translated">Perl은 현재 &lt;code&gt;LC_COLLATE&lt;/code&gt; 에 대한 1 바이트 로케일 만 지원합니다 . 이것은 UTF-8 로케일이 기계 고유의 순서를 제공 할 가능성이 있음을 의미합니다. Unicode Collation Algorithm을 완전히 구현 하려면 &lt;a href=&quot;unicode/collate&quot;&gt;Unicode :: Collate&lt;/a&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="77cf5a91724851c2026eb0ed52027faf2ff9d8f3" translate="yes" xml:space="preserve">
          <source>Perl debug information is frequently required not just by debuggers, but also by modules that need some &quot;special&quot; information to do their job properly, like profilers.</source>
          <target state="translated">Perl 디버그 정보는 디버거뿐만 아니라 프로파일 러와 같이 작업을 올바르게 수행하기 위해 &quot;특별한&quot;정보가 필요한 모듈에도 필요합니다.</target>
        </trans-unit>
        <trans-unit id="edcd0b1168988fe6213df824f5ad91c7a66c6c43" translate="yes" xml:space="preserve">
          <source>Perl defines the following zero-width assertions:</source>
          <target state="translated">Perl은 다음과 같이 폭이 0 인 어설 션을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="6b26390b798af49773d52f4620dbbc3aff54133e" translate="yes" xml:space="preserve">
          <source>Perl deliberately randomizes hash order for security purposes on both ASCII and EBCDIC platforms.</source>
          <target state="translated">Perl은 ASCII 및 EBCDIC 플랫폼 모두에서 보안 목적으로 해시 순서를 의도적으로 무작위 화합니다.</target>
        </trans-unit>
        <trans-unit id="b360e4dc6087d3b16edb381fbc0c1f20ea026de5" translate="yes" xml:space="preserve">
          <source>Perl derives from the ubiquitous C programming language and to a lesser extent from sed, awk, the Unix shell, and many other tools and languages.</source>
          <target state="translated">Perl은 유비쿼터스 C 프로그래밍 언어와 sed, awk, Unix 쉘 및 기타 여러 도구 및 언어에서 파생됩니다.</target>
        </trans-unit>
        <trans-unit id="171910ec91b3b6b1e9deeb50ab9dfa78a36b3ec1" translate="yes" xml:space="preserve">
          <source>Perl does its own &lt;a href=&quot;#sprintf-FORMAT%2C-LIST&quot;&gt;&lt;code&gt;sprintf&lt;/code&gt;&lt;/a&gt; formatting: it emulates the C function &lt;a href=&quot;http://man.he.net/man3/sprintf&quot;&gt;sprintf(3)&lt;/a&gt;, but doesn't use it except for floating-point numbers, and even then only standard modifiers are allowed. Non-standard extensions in your local &lt;a href=&quot;http://man.he.net/man3/sprintf&quot;&gt;sprintf(3)&lt;/a&gt; are therefore unavailable from Perl.</source>
          <target state="translated">Perl은 자체 &lt;a href=&quot;#sprintf-FORMAT%2C-LIST&quot;&gt; &lt;code&gt;sprintf&lt;/code&gt; &lt;/a&gt; 형식화를 수행합니다. C 함수 &lt;a href=&quot;http://man.he.net/man3/sprintf&quot;&gt;sprintf (3)를&lt;/a&gt; 에뮬레이트 하지만 부동 소수점 숫자를 제외하고는 사용하지 않으며 표준 수정 자만 허용됩니다. 따라서 로컬 &lt;a href=&quot;http://man.he.net/man3/sprintf&quot;&gt;sprintf (3)의&lt;/a&gt; 비표준 확장 은 Perl에서 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="82ed6e041cbd4aae6a032a9f05ea11dde0c68044" translate="yes" xml:space="preserve">
          <source>Perl does its own &lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf&lt;/a&gt;&lt;/code&gt; formatting: it emulates the C function sprintf(3), but doesn't use it except for floating-point numbers, and even then only standard modifiers are allowed. Non-standard extensions in your local sprintf(3) are therefore unavailable from Perl.</source>
          <target state="translated">Perl은 자체 &lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf&lt;/a&gt;&lt;/code&gt; 형식을 수행합니다. C 함수 sprintf (3)를 에뮬레이트하지만 부동 소수점 숫자를 제외하고는 사용하지 않으며 표준 수정 자만 허용됩니다. 따라서 로컬 sprintf (3)의 비표준 확장은 Perl에서 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="9fd3bbafbe5f224f645e29f633eba572a0b47a6b" translate="yes" xml:space="preserve">
          <source>Perl does its own &lt;code&gt;&lt;a href=&quot;sprintf&quot;&gt;sprintf&lt;/a&gt;&lt;/code&gt; formatting: it emulates the C function sprintf(3), but doesn't use it except for floating-point numbers, and even then only standard modifiers are allowed. Non-standard extensions in your local sprintf(3) are therefore unavailable from Perl.</source>
          <target state="translated">Perl은 자체 &lt;code&gt;&lt;a href=&quot;sprintf&quot;&gt;sprintf&lt;/a&gt;&lt;/code&gt; 형식을 수행합니다. C 함수 sprintf (3)를 에뮬레이트하지만 부동 소수점 숫자를 제외하고는 사용하지 않으며 표준 수정 자만 허용됩니다. 따라서 로컬 sprintf (3)의 비표준 확장은 Perl에서 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="a4d0575e168bcb93baf91092d083b3f45edc7784" translate="yes" xml:space="preserve">
          <source>Perl does not allow overloading of ranges, so you can neither safely use ranges with bigint endpoints, nor is the iterator variable a bigint.</source>
          <target state="translated">Perl은 범위의 오버로드를 허용하지 않으므로 bigint 엔드 포인트에 범위를 안전하게 사용할 수 없으며 반복자 변수도 bigint입니다.</target>
        </trans-unit>
        <trans-unit id="c115815d6de8f54c97b95bbf1feacf608d2cdd8a" translate="yes" xml:space="preserve">
          <source>Perl does not call the shell to expand wild cards when you pass &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; explicit parameter lists instead of strings with possible shell wildcards in them. Unfortunately, the &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/glob&quot;&gt;glob&lt;/a&gt;&lt;/code&gt;, and backtick functions provide no such alternate calling convention, so more subterfuge will be required.</source>
          <target state="translated">Perl은 쉘 와일드 카드가 가능한 문자열 대신 &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; 명시 적 매개 변수 목록 을 전달할 때 와일드 카드를 확장하기 위해 쉘을 호출하지 않습니다 . 불행하게도, &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/glob&quot;&gt;glob&lt;/a&gt;&lt;/code&gt; 및 backtick 함수는 이러한 대체 호출 규칙을 제공하지 않으므로 더 많은 서브 퍼지가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="8b58eb8904f65d9a83df8472fec3b9959cc0c48d" translate="yes" xml:space="preserve">
          <source>Perl does not call the shell to expand wild cards when you pass &lt;code&gt;system&lt;/code&gt; and &lt;code&gt;exec&lt;/code&gt; explicit parameter lists instead of strings with possible shell wildcards in them. Unfortunately, the &lt;code&gt;open&lt;/code&gt;, &lt;code&gt;glob&lt;/code&gt;, and backtick functions provide no such alternate calling convention, so more subterfuge will be required.</source>
          <target state="translated">Perl은 가능한 쉘 와일드 카드가있는 문자열 대신 &lt;code&gt;system&lt;/code&gt; 및 &lt;code&gt;exec&lt;/code&gt; 명시 적 매개 변수 목록 을 전달할 때 와일드 카드를 확장하기 위해 쉘을 호출하지 않습니다 . 불행히도 &lt;code&gt;open&lt;/code&gt; , &lt;code&gt;glob&lt;/code&gt; 및 backtick 함수는 그러한 대체 호출 규칙을 제공하지 않으므로 더 많은 속임수가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="acf14eaf9fdbdb615c0b9a213270f3740bd4a2b7" translate="yes" xml:space="preserve">
          <source>Perl does not care about file systems, but the perl library contains many files with long names, so to install it intact one needs a file system which supports long file names.</source>
          <target state="translated">Perl은 파일 시스템을 신경 쓰지 않지만 perl 라이브러리에는 긴 이름을 가진 많은 파일이 포함되어 있으므로 그대로 설치하려면 긴 파일 이름을 지원하는 파일 시스템이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="5a30d3ce357d2bad0edd8f956d77f82fd680b527" translate="yes" xml:space="preserve">
          <source>Perl does not depend on the registry, but it can look up certain default values if you choose to put them there unless disabled at build time with USE_NO_REGISTRY. On Perl process start Perl checks if &lt;code&gt;HKEY_CURRENT_USER\Software\Perl&lt;/code&gt; and &lt;code&gt;HKEY_LOCAL_MACHINE\Software\Perl&lt;/code&gt; exist. If the keys exists, they will be checked for remainder of the Perl process's run life for certain entries. Entries in &lt;code&gt;HKEY_CURRENT_USER\Software\Perl&lt;/code&gt; override entries in &lt;code&gt;HKEY_LOCAL_MACHINE\Software\Perl&lt;/code&gt;. One or more of the following entries (of type REG_SZ or REG_EXPAND_SZ) may be set in the keys:</source>
          <target state="translated">Perl은 레지스트리에 의존하지 않지만 USE_NO_REGISTRY를 사용하여 빌드 할 때 비활성화하지 않는 한 특정 기본값을 배치하도록 선택하면 특정 기본값을 조회 할 수 있습니다. Perl 프로세스 시작에서 Perl은 &lt;code&gt;HKEY_CURRENT_USER\Software\Perl&lt;/code&gt; 및 &lt;code&gt;HKEY_LOCAL_MACHINE\Software\Perl&lt;/code&gt; 이 있는지 확인 합니다. 키가 있으면 특정 항목에 대한 Perl 프로세스의 나머지 실행 수명을 확인합니다. 의 항목 &lt;code&gt;HKEY_CURRENT_USER\Software\Perl&lt;/code&gt; 에서 재정의 항목 &lt;code&gt;HKEY_LOCAL_MACHINE\Software\Perl&lt;/code&gt; . 다음 항목 (REG_SZ 또는 REG_EXPAND_SZ 유형) 중 하나 이상을 키에 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5354348a14ac18fad5dfd9ae6dc9f4e8955fd5e4" translate="yes" xml:space="preserve">
          <source>Perl does not depend on the registry, but it can look up certain default values if you choose to put them there. Perl attempts to read entries from &lt;code&gt;HKEY_CURRENT_USER\Software\Perl&lt;/code&gt; and &lt;code&gt;HKEY_LOCAL_MACHINE\Software\Perl&lt;/code&gt; . Entries in the former override entries in the latter. One or more of the following entries (of type REG_SZ or REG_EXPAND_SZ) may be set:</source>
          <target state="translated">Perl은 레지스트리에 의존하지 않지만, 거기에 두도록 선택하면 특정 기본값을 찾을 수 있습니다. Perl은 &lt;code&gt;HKEY_CURRENT_USER\Software\Perl&lt;/code&gt; 및 &lt;code&gt;HKEY_LOCAL_MACHINE\Software\Perl&lt;/code&gt; 에서 항목을 읽으려고합니다 . 전자의 항목은 후자의 항목보다 우선합니다. REG_SZ 또는 REG_EXPAND_SZ 유형의 다음 항목 중 하나 이상을 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e6697dea8bad1c38bf0eecc9764ad8eaf5ace311" translate="yes" xml:space="preserve">
          <source>Perl does not enforce private and public parts of its modules as you may have been used to in other languages like C++, Ada, or Modula-17. Perl doesn't have an infatuation with enforced privacy. It would prefer that you stayed out of its living room because you weren't invited, not because it has a shotgun.</source>
          <target state="translated">C ++, Ada 또는 Modula-17과 같은 다른 언어에서 익숙해 졌을 수 있으므로 Perl은 모듈의 개인 및 공용 부분을 강요하지 않습니다. Perl은 개인 정보 보호에 열심이 없습니다. 초청이 아니기 때문에 초대받지 않았기 때문에 거실에서 나가는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="7376046122227141976ff6a43223937f5fa71800" translate="yes" xml:space="preserve">
          <source>Perl does not expand &lt;code&gt;~&lt;/code&gt; in filenames, which is good, since some folks use it for their backup files:</source>
          <target state="translated">Perl은 파일 이름에서 &lt;code&gt;~&lt;/code&gt; 를 확장하지 않습니다. 일부 사람들은 파일 이름을 백업 파일로 사용하기 때문에 좋습니다.</target>
        </trans-unit>
        <trans-unit id="5b47de2bb8098559e3bf2dcabce87f213a6eb4f0" translate="yes" xml:space="preserve">
          <source>Perl does not have any built-in way to express roles. In the past, people just bit the bullet and used multiple inheritance. Nowadays, there are several good choices on CPAN for using roles.</source>
          <target state="translated">Perl에는 역할을 표현할 수있는 기본 제공 방법이 없습니다. 과거에는 사람들이 총알을 물고 여러 상속을 사용했습니다. 요즘에는 CPAN에서 역할을 사용하기위한 몇 가지 좋은 선택이 있습니다.</target>
        </trans-unit>
        <trans-unit id="eea568e6b9c913375e5a754c242df8539876547c" translate="yes" xml:space="preserve">
          <source>Perl does not provide any special syntax for class definitions. A package is simply a namespace containing variables and subroutines. The only difference is that in a class, the subroutines may expect a reference to an object or the name of a class as the first argument. This is purely a matter of convention, so a class may contain both methods and subroutines which</source>
          <target state="translated">Perl은 클래스 정의를위한 특별한 구문을 제공하지 않습니다. 패키지는 단순히 변수와 서브 루틴을 포함하는 네임 스페이스입니다. 유일한 차이점은 클래스에서 서브 루틴이 첫 번째 인수로 오브젝트 또는 클래스 이름에 대한 참조를 예상 할 수 있다는 것입니다. 이것은 순전히 관습의 문제이므로 클래스에는 메소드와 서브 루틴이 모두 포함될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c5c3b122d3c32f38c2b6df0053286a38a52964b9" translate="yes" xml:space="preserve">
          <source>Perl does not provide any special syntax for defining a method. A method is simply a regular subroutine, and is declared with &lt;code&gt;&lt;a href=&quot;functions/sub&quot;&gt;sub&lt;/a&gt;&lt;/code&gt;. What makes a method special is that it expects to receive either an object or a class name as its first argument.</source>
          <target state="translated">Perl은 메소드 정의를위한 특별한 구문을 제공하지 않습니다. 메소드는 단순히 일반 서브 루틴이며 &lt;code&gt;&lt;a href=&quot;functions/sub&quot;&gt;sub&lt;/a&gt;&lt;/code&gt; 로 선언됩니다 . 메소드를 특별하게 만드는 것은 오브젝트 또는 클래스 이름을 첫 번째 인수로 수신해야한다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="0947ef57e8f5b7f263717d72ae86b49dba67c724" translate="yes" xml:space="preserve">
          <source>Perl does not provide any special syntax for defining a method. A method is simply a regular subroutine, and is declared with &lt;code&gt;sub&lt;/code&gt;. What makes a method special is that it expects to receive either an object or a class name as its first argument.</source>
          <target state="translated">Perl은 메소드 정의를위한 특별한 구문을 제공하지 않습니다. 메서드는 단순히 일반 서브 루틴이며 &lt;code&gt;sub&lt;/code&gt; 로 선언됩니다 . 메서드를 특별하게 만드는 것은 객체 또는 클래스 이름을 첫 번째 인수로받을 것으로 예상한다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="66c91b8b39ed83c72047110950399f56a4745108" translate="yes" xml:space="preserve">
          <source>Perl doesn't match multiple characters in a bracketed character class unless the character that maps to them is explicitly mentioned, and it doesn't match them at all if the character class is inverted, which otherwise could be highly confusing. See &lt;a href=&quot;perlrecharclass#Bracketed-Character-Classes&quot;&gt;&quot;Bracketed Character Classes&quot; in perlrecharclass&lt;/a&gt;, and &lt;a href=&quot;perlrecharclass#Negation&quot;&gt;&quot;Negation&quot; in perlrecharclass&lt;/a&gt;.</source>
          <target state="translated">Perl은 해당 문자에 매핑되는 문자가 명시 적으로 언급되지 않는 한 대괄호 문자 클래스의 여러 문자와 일치하지 않으며 문자 클래스가 반전되면 전혀 일치하지 않습니다. 그렇지 않으면 매우 혼란 스러울 수 있습니다. 참조 &lt;a href=&quot;perlrecharclass#Bracketed-Character-Classes&quot;&gt;perlrecharclass에서 &quot;괄호 문자 클래스&quot;&lt;/a&gt; , 그리고 &lt;a href=&quot;perlrecharclass#Negation&quot;&gt;perlrecharclass에서 &quot;부정&quot;을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="cedf75e55d51d5b15900a202031f864d4002fc15" translate="yes" xml:space="preserve">
          <source>Perl doesn't match multiple characters in a bracketed character class unless the character that maps to them is explicitly mentioned, and it doesn't match them at all if the character class is inverted, which otherwise could be highly confusing. See &lt;a href=&quot;perlrecharclass#Bracketed-Character-Classes&quot;&gt;Bracketed Character Classes in perlrecharclass&lt;/a&gt;, and &lt;a href=&quot;perlrecharclass#Negation&quot;&gt;Negation in perlrecharclass&lt;/a&gt;.</source>
          <target state="translated">괄호로 묶인 문자를 명시 적으로 언급하지 않으면 괄호로 묶인 문자 클래스에서 여러 문자를 일치시키지 않으며, 문자 클래스가 반전 된 경우에는 전혀 일치하지 않으므로 혼동 될 수 있습니다. 참조 &lt;a href=&quot;perlrecharclass#Bracketed-Character-Classes&quot;&gt;perlrecharclass에 괄호 문자 클래스&lt;/a&gt; 및 &lt;a href=&quot;perlrecharclass#Negation&quot;&gt;perlrecharclass에서 부정&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="160ee861b96d9abcad026bc93515a6480468d14a" translate="yes" xml:space="preserve">
          <source>Perl doesn't officially have a no-op operator, but the bare constants &lt;code&gt;0&lt;/code&gt; and &lt;code&gt;1&lt;/code&gt; are special-cased not to produce a warning in void context, so you can for example safely do</source>
          <target state="translated">Perl은 공식적으로 no-op 연산자를 가지고 있지 않지만, 베어 상수 &lt;code&gt;0&lt;/code&gt; 과 &lt;code&gt;1&lt;/code&gt; 은 빈 공간에서 경고를 생성하지 않도록 특수한 경우이므로 예를 들어 안전하게 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="ee11bfd628d5bc290b395480aaa995c735fee62a" translate="yes" xml:space="preserve">
          <source>Perl doesn't understand &lt;code&gt;Inf&lt;/code&gt; and &lt;code&gt;NaN&lt;/code&gt; as numeric literals, but you can have them as strings, and Perl will convert them as needed: &quot;Inf&quot; + 1. (You can, however, import them from the POSIX extension; &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; POSIX qw(Inf NaN);&lt;/code&gt; and then use them as literals.)</source>
          <target state="translated">Perl은 &lt;code&gt;Inf&lt;/code&gt; 와 &lt;code&gt;NaN&lt;/code&gt; 을 숫자 리터럴로 이해하지 못하지만 문자열로 사용할 수 있으며 Perl은 필요에 따라 &quot;Inf&quot;+ 1로 변환합니다. 그러나 POSIX 확장에서 가져올 수 있습니다. &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; POSIX qw(Inf NaN);&lt;/code&gt; &lt;a href=&quot;functions/use&quot;&gt;사용하십시오&lt;/a&gt; . (Inf NaN); 그런 다음 리터럴로 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="ec5da9f5482b92ac03cf293065833b5b8af6f55e" translate="yes" xml:space="preserve">
          <source>Perl doesn't understand &lt;code&gt;Inf&lt;/code&gt; and &lt;code&gt;NaN&lt;/code&gt; as numeric literals, but you can have them as strings, and Perl will convert them as needed: &quot;Inf&quot; + 1. (You can, however, import them from the POSIX extension; &lt;code&gt;use POSIX qw(Inf NaN);&lt;/code&gt; and then use them as literals.)</source>
          <target state="translated">Perl은 &lt;code&gt;Inf&lt;/code&gt; 와 &lt;code&gt;NaN&lt;/code&gt; 을 숫자 리터럴로 이해하지 못하지만 문자열로 사용할 수 있으며 Perl은 필요에 따라 &quot;Inf&quot;+ 1을 변환합니다. 그러나 POSIX 확장에서 가져올 수 있습니다. &lt;code&gt;use POSIX qw(Inf NaN);&lt;/code&gt; . (Inf NaN); 그런 다음 리터럴로 사용하십시오.)</target>
        </trans-unit>
        <trans-unit id="f06c7777ec6a9cec60c6bbba96236c8c49e10f30" translate="yes" xml:space="preserve">
          <source>Perl enables DECC$EFS_CASE_PRESERVE and DECC$ARGV_PARSE_STYLE by default. Note that the latter only takes effect when extended parse is set in the process in which Perl is running. When these features are explicitly disabled in the environment or the CRTL does not support them, Perl follows the traditional CRTL behavior of downcasing command-line arguments and returning file specifications in lower case only.</source>
          <target state="translated">Perl은 기본적으로 DECC $ EFS_CASE_PRESERVE 및 DECC $ ARGV_PARSE_STYLE을 활성화합니다. 후자는 Perl이 실행중인 프로세스에서 확장 구문 분석이 설정된 경우에만 적용됩니다. 이러한 기능이 환경에서 명시 적으로 비활성화되어 있거나 CRTL이이를 지원하지 않는 경우 Perl은 명령 행 인수를 다운 소싱하고 파일 스펙을 소문자로만 리턴하는 기존 CRTL 동작을 따릅니다.</target>
        </trans-unit>
        <trans-unit id="9a7ffa77beb4b5bfb6e9cd592ffc3d63fefd5d7f" translate="yes" xml:space="preserve">
          <source>Perl environment problems</source>
          <target state="translated">펄 환경 문제</target>
        </trans-unit>
        <trans-unit id="efd321f1d642a6164aeb6c6061ba19e8d5553328" translate="yes" xml:space="preserve">
          <source>Perl equivalent: &lt;code&gt;&lt;a href=&quot;functions/exists&quot;&gt;exists($myarray[$key])&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">펄 당량 : &lt;code&gt;&lt;a href=&quot;functions/exists&quot;&gt;exists($myarray[$key])&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1023174861c373cd70c764cd28a1ffe52c362de1" translate="yes" xml:space="preserve">
          <source>Perl equivalent: &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; @array;&lt;/code&gt; .</source>
          <target state="translated">펄 당량 : &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; @array;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a1efb4e8b7d1884210a677a24eedc3aaa4097d90" translate="yes" xml:space="preserve">
          <source>Perl equivalent: &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; @new_array = ($scalar1, $scalar2, $scalar3...);&lt;/code&gt;</source>
          <target state="translated">펄 동등 : &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; @new_array = ($scalar1, $scalar2, $scalar3...);&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="994d82ebaabf45f0326fee88481665e6c0ceb2c7" translate="yes" xml:space="preserve">
          <source>Perl equivalent: &lt;code&gt;&lt;a href=&quot;functions/pop&quot;&gt;pop(@myarray);&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">펄 당량 : &lt;code&gt;&lt;a href=&quot;functions/pop&quot;&gt;pop(@myarray);&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0c448473e835de05f1fd2f4b0a4490f988bfea19" translate="yes" xml:space="preserve">
          <source>Perl equivalent: &lt;code&gt;&lt;a href=&quot;functions/push&quot;&gt;push&lt;/a&gt; @myarray, $elem;&lt;/code&gt; .</source>
          <target state="translated">펄 당량 : &lt;code&gt;&lt;a href=&quot;functions/push&quot;&gt;push&lt;/a&gt; @myarray, $elem;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7c7b86a8f8deba930918279e3c4fc84bda790f23" translate="yes" xml:space="preserve">
          <source>Perl equivalent: &lt;code&gt;&lt;a href=&quot;functions/shift&quot;&gt;shift(@myarray);&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">펄 당량 : &lt;code&gt;&lt;a href=&quot;functions/shift&quot;&gt;shift(@myarray);&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b4b1f7bdfb013ea4679d96a3812b271f5a3c227d" translate="yes" xml:space="preserve">
          <source>Perl equivalent: &lt;code&gt;&lt;a href=&quot;functions/unshift&quot;&gt;unshift&lt;/a&gt; @myarray, ( (&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;) x $n );&lt;/code&gt;</source>
          <target state="translated">펄 당량 : &lt;code&gt;&lt;a href=&quot;functions/unshift&quot;&gt;unshift&lt;/a&gt; @myarray, ( (&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;) x $n );&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="066d54dd7f117a044b123bb5ad4d4d8cf43e8b71" translate="yes" xml:space="preserve">
          <source>Perl equivalent: &lt;code&gt;@myarray = ();&lt;/code&gt; .</source>
          <target state="translated">펄 당량 : &lt;code&gt;@myarray = ();&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cef9ffe6af51e7c258630229039bfd2bf1b03f4a" translate="yes" xml:space="preserve">
          <source>Perl equivalent: &lt;code&gt;@{&quot;$name&quot;}&lt;/code&gt; .</source>
          <target state="translated">해당 펄 : &lt;code&gt;@{&quot;$name&quot;}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fd6c0fa81ee3f8c1c8439229199c54fb18bd674d" translate="yes" xml:space="preserve">
          <source>Perl equivalent: &lt;code&gt;@{&quot;$name&quot;}&lt;/code&gt;.</source>
          <target state="translated">Perl 해당 : &lt;code&gt;@{&quot;$name&quot;}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8387ac6319e9c82075e493d979c1ad9402112db0" translate="yes" xml:space="preserve">
          <source>Perl equivalent: &lt;code&gt;exists($myarray[$key])&lt;/code&gt;.</source>
          <target state="translated">Perl 해당 항목 : &lt;code&gt;exists($myarray[$key])&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5694e8120a54857700407b986aded553056c12c9" translate="yes" xml:space="preserve">
          <source>Perl equivalent: &lt;code&gt;my @array;&lt;/code&gt;.</source>
          <target state="translated">Perl 동등 물 : &lt;code&gt;my @array;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="64388bc4ae76bac317e416b96081b0d5a0b6f31c" translate="yes" xml:space="preserve">
          <source>Perl equivalent: &lt;code&gt;my @new_array = ($scalar1, $scalar2, $scalar3...);&lt;/code&gt;</source>
          <target state="translated">Perl 동등 항목 : &lt;code&gt;my @new_array = ($scalar1, $scalar2, $scalar3...);&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c87143f1eb93d31e9b921daa9a01a7a20ad16d03" translate="yes" xml:space="preserve">
          <source>Perl equivalent: &lt;code&gt;pop(@myarray);&lt;/code&gt;</source>
          <target state="translated">Perl 해당 : &lt;code&gt;pop(@myarray);&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="697b1808fa2455d4990177e0cd7be75e6d5166eb" translate="yes" xml:space="preserve">
          <source>Perl equivalent: &lt;code&gt;push @myarray, $val;&lt;/code&gt;.</source>
          <target state="translated">Perl에 해당 : &lt;code&gt;push @myarray, $val;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fa1708a84090946a618873c3a265107ea3020eef" translate="yes" xml:space="preserve">
          <source>Perl equivalent: &lt;code&gt;shift(@myarray);&lt;/code&gt;</source>
          <target state="translated">Perl 해당 : &lt;code&gt;shift(@myarray);&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="75d39e18ca7e7f2ff2aed6b8cb0b4962580d73a5" translate="yes" xml:space="preserve">
          <source>Perl equivalent: &lt;code&gt;splice(@myarray, $key, 1, undef)&lt;/code&gt; (with the &lt;code&gt;splice&lt;/code&gt; in void context if &lt;code&gt;G_DISCARD&lt;/code&gt; is present).</source>
          <target state="translated">Perl 해당 : &lt;code&gt;splice(@myarray, $key, 1, undef)&lt;/code&gt; ( &lt;code&gt;G_DISCARD&lt;/code&gt; 가있는 경우 void 컨텍스트 의 &lt;code&gt;splice&lt;/code&gt; 포함 ).</target>
        </trans-unit>
        <trans-unit id="4a3899dd3b4004ff6e0fc8455247dbe889fc7876" translate="yes" xml:space="preserve">
          <source>Perl equivalent: &lt;code&gt;unshift @myarray, ((undef) x $num);&lt;/code&gt;</source>
          <target state="translated">Perl에 해당 : &lt;code&gt;unshift @myarray, ((undef) x $num);&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1633602744f0213cf03a917c908f3ac91926bf3d" translate="yes" xml:space="preserve">
          <source>Perl exited with active threads:</source>
          <target state="translated">Perl이 활성 스레드로 종료되었습니다.</target>
        </trans-unit>
        <trans-unit id="fa8a19dd0719175a9c848242a7e2217e48154534" translate="yes" xml:space="preserve">
          <source>Perl extension for ARexx support</source>
          <target state="translated">ARexx 지원을위한 Perl 확장</target>
        </trans-unit>
        <trans-unit id="8aec2fb1965c42df65abc2f4f5003e7dd1e44262" translate="yes" xml:space="preserve">
          <source>Perl extension for BSD glob routine</source>
          <target state="translated">BSD glob 루틴을위한 Perl 확장</target>
        </trans-unit>
        <trans-unit id="24aff9b9093549c7d05ba26875dcbd18c62f3127" translate="yes" xml:space="preserve">
          <source>Perl extension for SHA-1/224/256/384/512</source>
          <target state="translated">SHA-1 / 224 / 256 / 384 / 512 용 Perl 확장</target>
        </trans-unit>
        <trans-unit id="403524ab53fcfa65297b5c6d11da8a41e9bdf68e" translate="yes" xml:space="preserve">
          <source>Perl extension for Version Objects</source>
          <target state="translated">버전 객체의 Perl 확장</target>
        </trans-unit>
        <trans-unit id="42f2f6711b11e99ed8f45572975dad7e69bf2e53" translate="yes" xml:space="preserve">
          <source>Perl extension for low level amiga support</source>
          <target state="translated">낮은 수준의 아미가 지원을위한 Perl 확장</target>
        </trans-unit>
        <trans-unit id="c24a560ca7260d4a2d7424b6161a53890073335c" translate="yes" xml:space="preserve">
          <source>Perl extension for sharing data structures between threads</source>
          <target state="translated">스레드간에 데이터 구조를 공유하기위한 Perl 확장</target>
        </trans-unit>
        <trans-unit id="3668aadc429b1304c6228d98dc9c4677872a86f1" translate="yes" xml:space="preserve">
          <source>Perl extension to manipulate DCL symbols</source>
          <target state="translated">DCL 심볼을 조작하기위한 Perl 확장</target>
        </trans-unit>
        <trans-unit id="b4ef3d43e200cfbf35d2a7b6f42754d585642e16" translate="yes" xml:space="preserve">
          <source>Perl extensions are packages which provide both XS and Perl code to add new functionality to perl. (XS is a meta-language which simplifies writing C code which interacts with Perl, see &lt;a href=&quot;perlxs&quot;&gt;perlxs&lt;/a&gt; for more details.) The Perl code for an extension is treated like any other library module - it's made available in your script through the appropriate &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; statement, and usually defines a Perl package containing the extension.</source>
          <target state="translated">Perl 확장은 XS와 Perl 코드를 모두 제공하여 perl에 새로운 기능을 추가하는 패키지입니다. (XS는 펄과 상호 작용이 참조 C 코드 작성 단순화하는 메타 언어입니다 &lt;a href=&quot;perlxs&quot;&gt;perlxs을&lt;/a&gt; 자세한 내용을.) 확장에 대한 펄 코드가 다른 라이브러리 모듈처럼 취급 - 그것은 적절한 통해 스크립트에서 사용할 것 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; 명령문으로 구성되며 일반적으로 확장을 포함하는 Perl 패키지를 정의합니다.</target>
        </trans-unit>
        <trans-unit id="0e866b1770868c3ac8fc82a190900a1373e58cc0" translate="yes" xml:space="preserve">
          <source>Perl extensions are packages which provide both XS and Perl code to add new functionality to perl. (XS is a meta-language which simplifies writing C code which interacts with Perl, see &lt;a href=&quot;perlxs&quot;&gt;perlxs&lt;/a&gt; for more details.) The Perl code for an extension is treated like any other library module - it's made available in your script through the appropriate &lt;code&gt;use&lt;/code&gt; or &lt;code&gt;require&lt;/code&gt; statement, and usually defines a Perl package containing the extension.</source>
          <target state="translated">Perl 확장은 새로운 기능을 perl에 추가하기 위해 XS 및 Perl 코드를 모두 제공하는 패키지입니다. (XS는 펄과 상호 작용이 참조 C 코드 작성 단순화하는 메타 언어입니다 &lt;a href=&quot;perlxs&quot;&gt;perlxs을&lt;/a&gt; 자세한 내용을.) 확장에 대한 펄 코드가 다른 라이브러리 모듈처럼 취급 - 그것은 적절한 통해 스크립트에서 사용할 것 &lt;code&gt;use&lt;/code&gt; 또는 &lt;code&gt;require&lt;/code&gt; 일반적으로 확장을 포함하는 Perl 패키지를 정의합니다.</target>
        </trans-unit>
        <trans-unit id="f81d1af8c2de641461c82be3969f85e5ad3bba8c" translate="yes" xml:space="preserve">
          <source>Perl flavors</source>
          <target state="translated">펄 맛</target>
        </trans-unit>
        <trans-unit id="bd0c8e091c1809181809f92d1bef1271c7b38ca1" translate="yes" xml:space="preserve">
          <source>Perl folding rules are not up-to-date for 0x%X; please use the perlbug utility to report; in regex; marked by &amp;lt;-- HERE in m/%s/</source>
          <target state="translated">Perl 접기 규칙은 0x % X에 대해 최신이 아닙니다. 보고하려면 perlbug 유틸리티를 사용하십시오. 정규식에서; &amp;lt;-HERE (m / % s /)로 표시</target>
        </trans-unit>
        <trans-unit id="7d53205939368bef651c20e6009f95c9046101c6" translate="yes" xml:space="preserve">
          <source>Perl for VMS supports redirection of input and output on the command line, using a subset of Bourne shell syntax:</source>
          <target state="translated">Perl for VMS는 Bourne 쉘 구문의 서브 세트를 사용하여 명령 행에서 입력 및 출력의 경로 재 지정을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="903e263457faf9b024e447e13142cbcffaf64dc8" translate="yes" xml:space="preserve">
          <source>Perl functions</source>
          <target state="translated">펄 함수</target>
        </trans-unit>
        <trans-unit id="7328221f86957828b643cf959ce54c0e2d391c24" translate="yes" xml:space="preserve">
          <source>Perl functions that execute the most opcodes</source>
          <target state="translated">대부분의 opcode를 실행하는 Perl 함수</target>
        </trans-unit>
        <trans-unit id="5eab57fb6512949ddd22c0f3a298921f86d2bf10" translate="yes" xml:space="preserve">
          <source>Perl had to change internally to decouple &quot;bytes&quot; from &quot;characters&quot;. It is important that you too change your ideas, if you haven't already, so that &quot;byte&quot; and &quot;character&quot; no longer mean the same thing in your mind.</source>
          <target state="translated">Perl은 &quot;바이트&quot;를 &quot;문자&quot;에서 분리하기 위해 내부적으로 변경해야했습니다. 아직 아이디어를 바꾸지 않았다면, &quot;바이트&quot;와 &quot;캐릭터&quot;가 더 이상 같은 의미를 가지지 않도록하는 것이 중요합니다.</target>
        </trans-unit>
        <trans-unit id="eb521c7add3b7379a78d9a6b6db7917dc107bbad" translate="yes" xml:space="preserve">
          <source>Perl has a mechanism for intermixing documentation with source code. While it's expecting the beginning of a new statement, if the compiler encounters a line that begins with an equal sign and a word, like this</source>
          <target state="translated">Perl에는 문서를 소스 코드와 혼합하는 메커니즘이 있습니다. 새로운 문장의 시작을 기대하고 있지만 컴파일러가 등호와 단어로 시작하는 줄을 발견하면</target>
        </trans-unit>
        <trans-unit id="1e3d0cb76e6880e13fbb5d4447acbcbd4213008d" translate="yes" xml:space="preserve">
          <source>Perl has a mechanism to help you generate simple reports and charts. To facilitate this, Perl helps you code up your output page close to how it will look when it's printed. It can keep track of things like how many lines are on a page, what page you're on, when to print page headers, etc. Keywords are borrowed from FORTRAN: format() to declare and write() to execute; see their entries in &lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt;. Fortunately, the layout is much more legible, more like BASIC's PRINT USING statement. Think of it as a poor man's nroff(1).</source>
          <target state="translated">Perl에는 간단한 보고서 및 차트를 생성 할 수있는 메커니즘이 있습니다. 이를 용이하게하기 위해 Perl은 출력 페이지가 인쇄 될 때의 모양에 가깝게 코딩하도록 도와줍니다. 페이지에 몇 줄이 있는지, 어떤 페이지에 있는지, 언제 페이지 머리글을 인쇄 할 것인지 등을 추적 할 수 있습니다. FORTRAN에서 키워드를 빌립니다. format ()은 선언하고 write ()는 실행합니다. &lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt; 의 항목을 참조하십시오 . 다행스럽게도 레이아웃은 BASIC의 PRINT USING 문과 같이 훨씬 읽기 쉽습니다. 그것을 가난한 사람의 nroff (1)로 생각하십시오.</target>
        </trans-unit>
        <trans-unit id="a345738f3732f2f0cdf6981643487de1b3db946b" translate="yes" xml:space="preserve">
          <source>Perl has a number of C functions that allow you to call Perl subroutines. They are</source>
          <target state="translated">Perl에는 Perl 서브 루틴을 호출 할 수있는 많은 C 함수가 있습니다. 그들은</target>
        </trans-unit>
        <trans-unit id="1bddeb2bc37a6de64d61b4ee95d33bffdb149de8" translate="yes" xml:space="preserve">
          <source>Perl has a very handy construction</source>
          <target state="translated">펄은 매우 편리한 구조입니다</target>
        </trans-unit>
        <trans-unit id="782c7b78803135d7443e4bbee913a7ff13f6ef7c" translate="yes" xml:space="preserve">
          <source>Perl has allowed you to use a bare here-document terminator to have the here-document end at the first empty line. This practise was deprecated in Perl 5.000; as of Perl 5.28, using a bare here-document terminator throws a fatal error.</source>
          <target state="translated">Perl은 첫 번째 빈 줄에서 여기 문서가 끝나도록 여기 문서 종료자를 사용하도록 허용했습니다. 이 방법은 Perl 5.000에서 더 이상 사용되지 않습니다. Perl 5.28부터, 여기에 문서가없는 터미네이터를 사용하면 치명적인 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="0fe803dd8b2d3f30a3a54343a2a1b136039b1f5f" translate="yes" xml:space="preserve">
          <source>Perl has an &lt;b&gt;internal format&lt;/b&gt;, an encoding that it uses to encode text strings so it can store them in memory. All text strings are in this internal format. In fact, text strings are never in any other format!</source>
          <target state="translated">Perl은 &lt;b&gt;내부 형식을&lt;/b&gt; 가지며, 텍스트 문자열을 메모리에 저장할 수 있도록 인코딩하는 데 사용되는 인코딩입니다. 모든 텍스트 문자열은이 내부 형식입니다. 실제로 텍스트 문자열은 다른 형식이 아닙니다!</target>
        </trans-unit>
        <trans-unit id="8e77f37e525e239856b2f6dca9aacaa6be1709a8" translate="yes" xml:space="preserve">
          <source>Perl has an abstracted interface for all supported character encodings, so this is actually a generic &lt;code&gt;Encode&lt;/code&gt; tutorial and &lt;code&gt;Encode&lt;/code&gt; FAQ. But many people think that Unicode is special and magical, and I didn't want to disappoint them, so I decided to call the document a Unicode tutorial.</source>
          <target state="translated">Perl은 지원되는 모든 문자 인코딩을위한 추상화 된 인터페이스를 가지고 있으므로 실제로 일반적인 &lt;code&gt;Encode&lt;/code&gt; 자습서 및 &lt;code&gt;Encode&lt;/code&gt; FAQ입니다. 그러나 많은 사람들은 유니 코드가 특별하고 마술 적이라고 생각하고 실망시키지 않기 위해 문서를 유니 코드 자습서라고 부릅니다.</target>
        </trans-unit>
        <trans-unit id="ba0cf0d83a33c18a21a219f52e56234294b46fae" translate="yes" xml:space="preserve">
          <source>Perl has an experimental facility to allow a subroutine's formal parameters to be introduced by special syntax, separate from the procedural code of the subroutine body. The formal parameter list is known as a</source>
          <target state="translated">Perl에는 서브 루틴 본문의 절차 코드와 별도로 특수 구문으로 서브 루틴의 공식 매개 변수를 도입 할 수있는 실험 기능이 있습니다. 공식적인 매개 변수 목록은</target>
        </trans-unit>
        <trans-unit id="97abe0ed9adb57fe2fdef50f3e6441c8a80f29df" translate="yes" xml:space="preserve">
          <source>Perl has been built with &lt;code&gt;PERL_OLD_SIGNALS&lt;/code&gt; (see &lt;code&gt;perl -V&lt;/code&gt;).</source>
          <target state="translated">Perl은 &lt;code&gt;PERL_OLD_SIGNALS&lt;/code&gt; 로 빌드되었습니다 ( &lt;code&gt;perl -V&lt;/code&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="67a3b41d8b9e93c19e7c374ecedc7c37bde9bf23" translate="yes" xml:space="preserve">
          <source>Perl has been extended to support certain types of locales available in the locale system. This is controlled per application by using one pragma, one function call, and several environment variables.</source>
          <target state="translated">Perl은 로케일 시스템에서 사용 가능한 특정 유형의 로케일을 지원하도록 확장되었습니다. 이것은 하나의 pragma, 하나의 함수 호출 및 여러 환경 변수를 사용하여 응용 프로그램별로 제어됩니다.</target>
        </trans-unit>
        <trans-unit id="a1de858c46ad7947531577a6915520f75857a413" translate="yes" xml:space="preserve">
          <source>Perl has been extended to support the locale system. This is controlled per application by using one pragma, one function call, and several environment variables.</source>
          <target state="translated">Perl은 로케일 시스템을 지원하도록 확장되었습니다. 이는 하나의 pragma, 하나의 함수 호출 및 여러 환경 변수를 사용하여 애플리케이션별로 제어됩니다.</target>
        </trans-unit>
        <trans-unit id="9724b09cfb0bd9657e1b0740263fad624a62d13c" translate="yes" xml:space="preserve">
          <source>Perl has been ported to many platforms that do not fit into any of the categories listed above. Some, such as AmigaOS, QNX, Plan 9, and VOS, have been well-integrated into the standard Perl source code kit. You may need to see the</source>
          <target state="translated">Perl은 위에 나열된 범주에 맞지 않는 많은 플랫폼으로 이식되었습니다. AmigaOS, QNX, Plan 9 및 VOS와 같은 일부는 표준 Perl 소스 코드 키트에 잘 통합되었습니다. 당신은 볼 수 있습니다</target>
        </trans-unit>
        <trans-unit id="59525826d5ce7fdcf57cd21fd12177031ab869c3" translate="yes" xml:space="preserve">
          <source>Perl has its own special way of easily writing test scripts, but for this example only, we'll create our own test script. Create a file called hello that looks like this:</source>
          <target state="translated">Perl은 테스트 스크립트를 쉽게 작성할 수있는 고유 한 방법이 있지만이 예제에서는 자체 테스트 스크립트를 작성합니다. 다음과 같은 hello라는 파일을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="998bc2b1651869833ea0ac38395b9fb4d5ed44f8" translate="yes" xml:space="preserve">
          <source>Perl has long been ported to Intel-style microcomputers running under systems like PC-DOS, MS-DOS, OS/2, and most Windows platforms you can bring yourself to mention (except for Windows CE, if you count that). Users familiar with</source>
          <target state="translated">Perl은 오랫동안 PC-DOS, MS-DOS, OS / 2 및 대부분의 Windows 플랫폼과 같은 시스템에서 실행되는 Intel 스타일의 마이크로 컴퓨터로 포팅되어 왔습니다 (Windows CE 제외). 익숙한 사용자</target>
        </trans-unit>
        <trans-unit id="fe67796dc02d7b52e1f554749c03ec30b57d6bfa" translate="yes" xml:space="preserve">
          <source>Perl has most of the usual conditional and looping constructs. As of Perl 5.10, it even has a case/switch statement (spelled &lt;code&gt;given&lt;/code&gt; /&lt;code&gt;when&lt;/code&gt; ). See &lt;a href=&quot;perlsyn#Switch-Statements&quot;&gt;Switch Statements in perlsyn&lt;/a&gt; for more details.</source>
          <target state="translated">Perl은 대부분의 일반적인 조건부 및 루핑 구문을 가지고 있습니다. 펄 5.10로, 그것도 케이스 / switch 문 (철자가 &lt;code&gt;given&lt;/code&gt; / ). 자세한 내용 &lt;a href=&quot;perlsyn#Switch-Statements&quot;&gt;은 perlsyn의 스위치 문&lt;/a&gt; 을 참조하십시오. &lt;code&gt;when&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a9108e90e0b7ad511809f643c664cdbaf3b5a6fd" translate="yes" xml:space="preserve">
          <source>Perl has most of the usual conditional and looping constructs. As of Perl 5.10, it even has a case/switch statement (spelled &lt;code&gt;given&lt;/code&gt;/&lt;code&gt;when&lt;/code&gt;). See &lt;a href=&quot;perlsyn#Switch-Statements&quot;&gt;&quot;Switch Statements&quot; in perlsyn&lt;/a&gt; for more details.</source>
          <target state="translated">Perl은 대부분의 일반적인 조건부 및 반복 구조를 가지고 있습니다. Perl 5.10부터는 case / switch 문이 있습니다 ( &lt;code&gt;given&lt;/code&gt; / &lt;code&gt;when&lt;/code&gt; ). 자세한 내용 &lt;a href=&quot;perlsyn#Switch-Statements&quot;&gt;은 perlsyn의 &quot;Switch 문&quot;&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="db019a5ac1f171d008187e1d1c55e0f5d5a9b3a4" translate="yes" xml:space="preserve">
          <source>Perl has never accepted code points above 255 without them being Unicode, so their use implies Unicode for the whole string.</source>
          <target state="translated">Perl은 유니 코드가 아닌 255 이상의 코드 포인트를 허용하지 않으므로 전체 문자열에 유니 코드가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="3dbc4a73529270e867678196c4fd9545abf0346b" translate="yes" xml:space="preserve">
          <source>Perl has no special syntax for attributes. Under the hood, attributes are often stored as keys in the object's underlying hash, but don't worry about this.</source>
          <target state="translated">Perl에는 속성에 대한 특별한 구문이 없습니다. 후드 아래에서 속성은 종종 객체의 기본 해시에 키로 저장되지만 걱정하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="7a462b0d48d68775e02812c002249670e7d86d56" translate="yes" xml:space="preserve">
          <source>Perl has several abbreviations for common character classes. (These definitions are those that Perl uses in ASCII-safe mode with the &lt;code&gt;/a&lt;/code&gt; modifier. Otherwise they could match many more non-ASCII Unicode characters as well. See &lt;a href=&quot;perlrecharclass#Backslash-sequences&quot;&gt;&quot;Backslash sequences&quot; in perlrecharclass&lt;/a&gt; for details.)</source>
          <target state="translated">Perl에는 공통 문자 클래스에 대한 몇 가지 약어가 있습니다. (이러한 정의는 Perl이 &lt;code&gt;/a&lt;/code&gt; 수정 자 와 함께 ASCII 안전 모드에서 사용하는 정의 입니다. 그렇지 않으면 더 많은 비 ASCII 유니 코드 문자와도 일치 할 수 있습니다. 자세한 내용 &lt;a href=&quot;perlrecharclass#Backslash-sequences&quot;&gt;은 perlrecharclass의 &quot;백 슬래시 시퀀스&quot;&lt;/a&gt; 를 참조하십시오.)</target>
        </trans-unit>
        <trans-unit id="a2deb2a0ce121e98962483bd16f83d982606bfc5" translate="yes" xml:space="preserve">
          <source>Perl has several abbreviations for common character classes. (These definitions are those that Perl uses in ASCII-safe mode with the &lt;code&gt;/a&lt;/code&gt; modifier. Otherwise they could match many more non-ASCII Unicode characters as well. See &lt;a href=&quot;perlrecharclass#Backslash-sequences&quot;&gt;Backslash sequences in perlrecharclass&lt;/a&gt; for details.)</source>
          <target state="translated">Perl은 일반적인 문자 클래스에 대한 몇 가지 약어를 가지고 있습니다. (이러한 정의는 Perl이 &lt;code&gt;/a&lt;/code&gt; 수정 자 와 함께 ASCII 안전 모드에서 사용하는 정의 입니다. 그렇지 않으면 ASCII 이외의 다른 유니 코드 문자와도 일치 할 수 있습니다. 자세한 내용 &lt;a href=&quot;perlrecharclass#Backslash-sequences&quot;&gt;은 perlrecharclass의 백 슬래시 시퀀스&lt;/a&gt; 를 참조하십시오.)</target>
        </trans-unit>
        <trans-unit id="6e2448e5aa8e9e98f0e99e7fca74328732318a16" translate="yes" xml:space="preserve">
          <source>Perl has special debugging hooks at compile-time and run-time used to create debugging environments. These hooks are not to be confused with the</source>
          <target state="translated">Perl에는 디버깅 환경을 만드는 데 사용되는 컴파일 타임 및 런타임에 특별한 디버깅 후크가 있습니다. 이 고리는</target>
        </trans-unit>
        <trans-unit id="0380b6f875ab18989e39e87ecb537accdd5cfd4c" translate="yes" xml:space="preserve">
          <source>Perl has three built-in data types: scalars, arrays of scalars, and associative arrays of scalars, known as &quot;hashes&quot;. A scalar is a single string (of any size, limited only by the available memory), number, or a reference to something (which will be discussed in &lt;a href=&quot;perlref&quot;&gt;perlref&lt;/a&gt;). Normal arrays are ordered lists of scalars indexed by number, starting with 0. Hashes are unordered collections of scalar values indexed by their associated string key.</source>
          <target state="translated">Perl에는 세 개의 기본 제공 데이터 유형 (스칼라, 스칼라 배열 및 &quot;해시&quot;라고하는 스칼라 배열)이 있습니다. 스칼라는 단일 문자열 (사용 가능한 메모리로만 제한되는 모든 크기), 숫자 또는 무언가에 대한 참조 ( &lt;a href=&quot;perlref&quot;&gt;perlref&lt;/a&gt; 에서 설명 )입니다. 일반 배열은 0부터 시작하여 숫자로 색인화 된 스칼라 목록입니다. 해시는 연관된 문자열 키로 색인화 된 스칼라 값의 정렬되지 않은 콜렉션입니다.</target>
        </trans-unit>
        <trans-unit id="fe80e5af445506b27b416f76f8599a7353684bc2" translate="yes" xml:space="preserve">
          <source>Perl has three main variable types: scalars, arrays, and hashes.</source>
          <target state="translated">Perl에는 스칼라, 배열 및 해시의 세 가지 주요 변수 유형이 있습니다.</target>
        </trans-unit>
        <trans-unit id="5581a893a6439e102c22a8a8e459a544618d9458" translate="yes" xml:space="preserve">
          <source>Perl has three typedefs that handle Perl's three main data types:</source>
          <target state="translated">Perl에는 Perl의 세 가지 주요 데이터 유형을 처리하는 세 가지 typedef가 있습니다.</target>
        </trans-unit>
        <trans-unit id="4982bfdcb9933aa8ea045e6714352b02205f1767" translate="yes" xml:space="preserve">
          <source>Perl has two major annual conventions: The Perl Conference (now part of OSCON), put on by O'Reilly, and Yet Another Perl Conference or YAPC (pronounced yap-see), which is localized into several regional YAPCs (North America, Europe, Asia) in a stunning grassroots display by the Perl community. For more information about either conference, check out their respective web pages: OSCON &lt;a href=&quot;http://conferences.oreillynet.com/&quot;&gt;http://conferences.oreillynet.com/&lt;/a&gt;; YAPC &lt;a href=&quot;http://www.yapc.org&quot;&gt;http://www.yapc.org&lt;/a&gt;.</source>
          <target state="translated">Perl은 두 가지 주요 연례 협약을 가지고 있습니다 : O'Reilly가 주최 한 Perl Conference (현재 OSCON의 일부)와 또 다른 Perl Conference 또는 YAPC (yap-see로 발음)는 여러 지역 YAPC (북미, 유럽)로 현지화되어 있습니다. Perl 커뮤니티의 멋진 풀뿌리 전시. 각 회의에 대한 자세한 내용은 해당 웹 페이지를 확인하십시오. OSCON &lt;a href=&quot;http://conferences.oreillynet.com/&quot;&gt;http://conferences.oreillynet.com/&lt;/a&gt; ; YAPC &lt;a href=&quot;http://www.yapc.org&quot;&gt;http://www.yapc.org&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5fa0e69b9943a36c122fd92838ddb0e5f771d49b" translate="yes" xml:space="preserve">
          <source>Perl hash references become JSON objects. As there is no inherent ordering in hash keys (or JSON objects), they will usually be encoded in a pseudo-random order. JSON::PP can optionally sort the hash keys (determined by the</source>
          <target state="translated">Perl 해시 참조는 JSON 객체가됩니다. 해시 키 (또는 JSON 개체)에는 고유 한 순서가 없으므로 일반적으로 의사 임의 순서로 인코딩됩니다. JSON :: PP는 선택적으로 해시 키를 정렬 할 수 있습니다 (</target>
        </trans-unit>
        <trans-unit id="d410c5808a3d55ecb935a6972f7fdc386cde6d4b" translate="yes" xml:space="preserve">
          <source>Perl identifiers that begin with digits or punctuation characters are exempt from the effects of the &lt;code&gt;package&lt;/code&gt; declaration and are always forced to be in package &lt;code&gt;main&lt;/code&gt;; they are also exempt from &lt;code&gt;strict 'vars'&lt;/code&gt; errors. A few other names are also exempt in these ways:</source>
          <target state="translated">숫자 또는 구두점 문자로 시작하는 Perl 식별자는 &lt;code&gt;package&lt;/code&gt; 선언 의 영향에서 제외 되며 항상 패키지 &lt;code&gt;main&lt;/code&gt; 에 있어야합니다 . 또한 &lt;code&gt;strict 'vars'&lt;/code&gt; 오류 에서 제외됩니다 . 다음과 같은 몇 가지 다른 이름도 면제됩니다.</target>
        </trans-unit>
        <trans-unit id="9b6b908f8c33f304fe3c47ffea7a9a025bc30e32" translate="yes" xml:space="preserve">
          <source>Perl identifiers that begin with digits, control characters, or punctuation characters are exempt from the effects of the &lt;code&gt;&lt;a href=&quot;functions/package&quot;&gt;package&lt;/a&gt;&lt;/code&gt; declaration and are always forced to be in package &lt;code&gt;main&lt;/code&gt; ; they are also exempt from &lt;code&gt;strict 'vars'&lt;/code&gt; errors. A few other names are also exempt in these ways:</source>
          <target state="translated">숫자, 제어 문자 또는 문장 부호로 시작하는 Perl 식별자는 &lt;code&gt;&lt;a href=&quot;functions/package&quot;&gt;package&lt;/a&gt;&lt;/code&gt; 선언 의 영향을받지 않으며 항상 패키지 &lt;code&gt;main&lt;/code&gt; 에 있어야합니다 . 또한 &lt;code&gt;strict 'vars'&lt;/code&gt; 오류가 면제됩니다 . 다음과 같은 몇 가지 다른 이름도 면제됩니다.</target>
        </trans-unit>
        <trans-unit id="31969a763381ff2a4c90806f4b46526dbe2b269c" translate="yes" xml:space="preserve">
          <source>Perl implementations</source>
          <target state="translated">Perl 구현</target>
        </trans-unit>
        <trans-unit id="c8fd67f8a70f5e14b6e3a19738244712c763a3d5" translate="yes" xml:space="preserve">
          <source>Perl implements a class using a package, but the presence of a package doesn't imply the presence of a class. A package is just a namespace. A class is a package that provides subroutines that can be used as methods. A method is just a subroutine that expects, as its first argument, either the name of a package (for &quot;static&quot; methods), or a reference to something (for &quot;virtual&quot; methods).</source>
          <target state="translated">Perl은 패키지를 사용하여 클래스를 구현하지만 패키지가 있다고해서 클래스가 있다는 것을 의미하지는 않습니다. 패키지는 단지 네임 스페이스입니다. 클래스는 메소드로 사용할 수있는 서브 루틴을 제공하는 패키지입니다. 메소드는 첫 번째 인수로서 패키지 이름 ( &quot;정적&quot;메소드의 경우) 또는 무언가에 대한 참조 ( &quot;가상&quot;메소드의 경우)를 예상하는 서브 루틴입니다.</target>
        </trans-unit>
        <trans-unit id="58db3a9b91cfa56f68561f9fa6e162ac6046ad34" translate="yes" xml:space="preserve">
          <source>Perl implements a copy-on-write (COW) mechanism for scalars, in which string copies are not immediately made when requested, but are deferred until made necessary by one or the other scalar changing. This is mostly transparent, but one must take care not to modify string buffers that are shared by multiple SVs.</source>
          <target state="translated">Perl은 스칼라에 대한 COW (Copy-On-Write) 메커니즘을 구현합니다. 여기서 스칼라는 요청시 즉시 문자열 사본이 작성되지 않지만 하나 또는 다른 스칼라 변경에 의해 필요할 때까지 지연됩니다. 이것은 대부분 투명하지만 여러 SV가 공유하는 문자열 버퍼를 수정하지 않도록주의해야합니다.</target>
        </trans-unit>
        <trans-unit id="9f2e73e561af14b355b2cc7b94da012ba43ebaff" translate="yes" xml:space="preserve">
          <source>Perl in PASE may be used in the same manner as you would use Perl on AIX.</source>
          <target state="translated">PASE의 Perl은 AIX에서 Perl을 사용하는 것과 같은 방식으로 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f2a8c9dfcc6b27fc2b2bc1c4e09ed07f063fafcb" translate="yes" xml:space="preserve">
          <source>Perl inserts the contents of &lt;code&gt;$ENV{PERL5DB}&lt;/code&gt; (or &lt;code&gt;BEGIN {&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;
'perl5db.pl'}&lt;/code&gt; if not present) before the first line of your program.</source>
          <target state="translated">Perl 은 프로그램의 첫 줄 앞에 &lt;code&gt;$ENV{PERL5DB}&lt;/code&gt; (또는 존재하지 않는 경우 &lt;code&gt;BEGIN {&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt; 'perl5db.pl'}&lt;/code&gt; 의 내용을 삽입합니다 .</target>
        </trans-unit>
        <trans-unit id="5f14427130c0e5366717699f360d7e36f930c1e6" translate="yes" xml:space="preserve">
          <source>Perl inserts the contents of &lt;code&gt;$ENV{PERL5DB}&lt;/code&gt; (or &lt;code&gt;BEGIN {require 'perl5db.pl'}&lt;/code&gt; if not present) before the first line of your program.</source>
          <target state="translated">Perl 은 프로그램의 첫 줄 앞에 &lt;code&gt;$ENV{PERL5DB}&lt;/code&gt; (또는 &lt;code&gt;BEGIN {require 'perl5db.pl'}&lt;/code&gt; ) 의 내용을 삽입합니다 .</target>
        </trans-unit>
        <trans-unit id="23d0dc7556929e748dc66e21edf0645eb0e4825c" translate="yes" xml:space="preserve">
          <source>Perl installs into the SDK directory structure and expects many of the build tools present in the SDK to be available. So for the best results install the SDK first.</source>
          <target state="translated">Perl은 SDK 디렉토리 구조에 설치되며 SDK에있는 많은 빌드 도구를 사용할 수있을 것으로 예상합니다. 따라서 최상의 결과를 얻으려면 먼저 SDK를 설치하십시오.</target>
        </trans-unit>
        <trans-unit id="2a9b4ba7a506b9d41ffb5e3879cb8f3519952178" translate="yes" xml:space="preserve">
          <source>Perl interface to IEEE Std 1003.1</source>
          <target state="translated">IEEE Std 1003.1에 대한 Perl 인터페이스</target>
        </trans-unit>
        <trans-unit id="98db74e4a9950c02875b0447d97adf3fab69be22" translate="yes" xml:space="preserve">
          <source>Perl interface to the MD5 Algorithm</source>
          <target state="translated">MD5 알고리즘에 대한 Perl 인터페이스</target>
        </trans-unit>
        <trans-unit id="25640a112f893abdc0c31467980b237692e55c11" translate="yes" xml:space="preserve">
          <source>Perl interface to the UNIX syslog(3) calls</source>
          <target state="translated">UNIX syslog (3) 호출에 대한 Perl 인터페이스</target>
        </trans-unit>
        <trans-unit id="eb268cafbb2bc2d6a265535e507a93da4ace82e9" translate="yes" xml:space="preserve">
          <source>Perl interface to various &lt;code&gt;&lt;a href=&quot;functions/readline&quot;&gt;readline&lt;/a&gt;&lt;/code&gt; packages.</source>
          <target state="translated">다양한 &lt;code&gt;&lt;a href=&quot;functions/readline&quot;&gt;readline&lt;/a&gt;&lt;/code&gt; 패키지에 대한 Perl 인터페이스 .</target>
        </trans-unit>
        <trans-unit id="3c4d5afc98ae9e7a6b3b8ccc0bdaf8f20968aa0d" translate="yes" xml:space="preserve">
          <source>Perl interface to various &lt;code&gt;readline&lt;/code&gt; packages.</source>
          <target state="translated">다양한 &lt;code&gt;readline&lt;/code&gt; 패키지에 대한 Perl 인터페이스 .</target>
        </trans-unit>
        <trans-unit id="532fa58abfc3c5192e3d89ee9b20cda6099a638d" translate="yes" xml:space="preserve">
          <source>Perl interpreter-based threads</source>
          <target state="translated">Perl 인터프리터 기반 스레드</target>
        </trans-unit>
        <trans-unit id="7813b6fd0cf6ff0fcbbed68e090fa174337973c7" translate="yes" xml:space="preserve">
          <source>Perl is a &lt;b&gt;free-form&lt;/b&gt; language: you can format and indent it however you like. Whitespace serves mostly to separate tokens, unlike languages like Python where it is an important part of the syntax, or Fortran where it is immaterial.</source>
          <target state="translated">Perl은 &lt;b&gt;자유 형식의&lt;/b&gt; 언어입니다. 원하는대로 형식을 지정하고 들여 쓸 수 있습니다. 공백은 구문의 중요한 부분 인 Python이나 중요하지 않은 Fortran과 같은 언어와 달리 대부분 토큰을 분리하는 역할을합니다.</target>
        </trans-unit>
        <trans-unit id="78b17861828e1fc00762c322f49cbad21d37d4a9" translate="yes" xml:space="preserve">
          <source>Perl is a general-purpose programming language originally developed for text manipulation and now used for a wide range of tasks including system administration, web development, network programming, GUI development, and more.</source>
          <target state="translated">Perl은 원래 텍스트 조작을 위해 개발 된 범용 프로그래밍 언어로, 시스템 관리, 웹 개발, 네트워크 프로그래밍, GUI 개발 등 광범위한 작업에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="df24bdffd3ed3137e259ab273c3698d7eedca921" translate="yes" xml:space="preserve">
          <source>Perl is a high-level programming language with an eclectic heritage written by Larry Wall and a cast of thousands.</source>
          <target state="translated">Perl은 Larry Wall에 의해 작성된 다양한 유산과 수천 명의 캐스트가있는 고급 프로그래밍 언어입니다.</target>
        </trans-unit>
        <trans-unit id="8e4a5a9567dfe12d565a7fe3569da1af894be351" translate="yes" xml:space="preserve">
          <source>Perl is a profligate wastrel when it comes to memory use. There is a saying that to estimate memory usage of Perl, assume a reasonable algorithm for memory allocation, multiply that estimate by 10, and while you still may miss the mark, at least you won't be quite so astonished. This is not absolutely true, but may provide a good grasp of what happens.</source>
          <target state="translated">Perl은 메모리 사용과 관련하여 발생하는 문제입니다. Perl의 메모리 사용량을 추정하기 위해 합리적인 메모리 할당 알고리즘을 가정하고 그 추정치에 10을 곱하면 여전히 점수를 놓칠 수는 있지만 적어도 놀라지 않을 것입니다. 이것은 절대적으로 사실은 아니지만 발생하는 일을 잘 파악할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5676662b05d1f0dfe8bee99aada0c212a7cfdcd0" translate="yes" xml:space="preserve">
          <source>Perl is at the mercy of your machine's definitions of various operations such as type casting, atof(), and floating-point output with sprintf().</source>
          <target state="translated">Perl은 타입 캐스팅, atof () 및 sprintf ()를 사용한 부동 소수점 출력과 같은 다양한 작업에 대한 머신 정의에 달려 있습니다.</target>
        </trans-unit>
        <trans-unit id="cf13bfd73fd319a7fa88b1a848a7fd42bf50c10e" translate="yes" xml:space="preserve">
          <source>Perl is available for most operating systems, including virtually all Unix-like platforms. See &lt;a href=&quot;perlport#Supported-Platforms&quot;&gt;&quot;Supported Platforms&quot; in perlport&lt;/a&gt; for a listing.</source>
          <target state="translated">Perl은 거의 모든 유닉스 계열 플랫폼을 포함하여 대부분의 운영 체제에서 사용할 수 있습니다. 목록 &lt;a href=&quot;perlport#Supported-Platforms&quot;&gt;은 perlport의 &quot;지원되는 플랫폼&quot;을&lt;/a&gt; 참조 하십시오.</target>
        </trans-unit>
        <trans-unit id="1d9807bc15de484f6b43cc02362e93cc66150c42" translate="yes" xml:space="preserve">
          <source>Perl is available for most operating systems, including virtually all Unix-like platforms. See &lt;a href=&quot;perlport#Supported-Platforms&quot;&gt;Supported Platforms in perlport&lt;/a&gt; for a listing.</source>
          <target state="translated">Perl은 거의 모든 Unix 계열 플랫폼을 포함한 대부분의 운영 체제에서 사용할 수 있습니다. 목록 &lt;a href=&quot;perlport#Supported-Platforms&quot;&gt;은 perlport에서 지원되는 플랫폼을&lt;/a&gt; 참조 하십시오.</target>
        </trans-unit>
        <trans-unit id="464c9f17acbbf3521c9fe1d4bfb03f4c8f71635b" translate="yes" xml:space="preserve">
          <source>Perl is binary-clean, so it can handle binary data just fine. On Windows or DOS, however, you have to use &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; for binary files to avoid conversions for line endings. In general, you should use &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; any time you want to work with binary data.</source>
          <target state="translated">Perl은 바이너리 클린이므로 바이너리 데이터를 잘 처리 할 수 ​​있습니다. 그러나 Windows 또는 DOS에서는 줄 끝 변환을 피하기 위해 이진 파일에 &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; 를 사용해야 합니다. 일반적으로 이진 데이터로 작업하려면 언제든지 &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; 를 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="f177d6bd3fecf3c385b90d51e6e9dcdc131d2dc5" translate="yes" xml:space="preserve">
          <source>Perl is binary-clean, so it can handle binary data just fine. On Windows or DOS, however, you have to use &lt;code&gt;binmode&lt;/code&gt; for binary files to avoid conversions for line endings. In general, you should use &lt;code&gt;binmode&lt;/code&gt; any time you want to work with binary data.</source>
          <target state="translated">Perl은 바이너리 클린이므로 바이너리 데이터를 잘 처리 할 수 ​​있습니다. 그러나 Windows 또는 DOS에서는 줄 끝 변환을 방지하기 위해 바이너리 파일에 대해 &lt;code&gt;binmode&lt;/code&gt; 를 사용해야 합니다. 일반적으로 바이너리 데이터로 작업 할 때마다 &lt;code&gt;binmode&lt;/code&gt; 를 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="432dc52a3d4248eb12d8ce12a42a4bd4668bcd6d" translate="yes" xml:space="preserve">
          <source>Perl is built using PerlIO by default; Unless you've changed this (such as building Perl with &lt;code&gt;Configure -Uuseperlio&lt;/code&gt; ), you can open filehandles directly to Perl scalars via:</source>
          <target state="translated">Perl은 기본적으로 PerlIO를 사용하여 빌드됩니다. 이를 변경하지 않은 경우 (예 : &lt;code&gt;Configure -Uuseperlio&lt;/code&gt; 로 Perl 빌드 ) 다음을 통해 파일 핸들을 Perl 스칼라로 직접 열 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e2ba202ee46521f5f5b0bea93e68c6d4e90de303" translate="yes" xml:space="preserve">
          <source>Perl is built with a &lt;a href=&quot;perlvar#%24%5EO&quot;&gt;&lt;code&gt;$^O&lt;/code&gt;&lt;/a&gt; variable that indicates the operating system it was built on. This was implemented to help speed up code that would otherwise have to &lt;code&gt;use Config&lt;/code&gt; and use the value of &lt;a href=&quot;config#osname&quot;&gt;&lt;code&gt;$Config{osname}&lt;/code&gt;&lt;/a&gt;. Of course, to get more detailed information about the system, looking into &lt;a href=&quot;config#DESCRIPTION&quot;&gt;&lt;code&gt;%Config&lt;/code&gt;&lt;/a&gt; is certainly recommended.</source>
          <target state="translated">Perl은 빌드 된 운영 체제를 나타내는 &lt;a href=&quot;perlvar#%24%5EO&quot;&gt; &lt;code&gt;$^O&lt;/code&gt; &lt;/a&gt; 변수로 빌드됩니다. 이것은 &lt;code&gt;use Config&lt;/code&gt; 를 사용하고 &lt;a href=&quot;config#osname&quot;&gt; &lt;code&gt;$Config{osname}&lt;/code&gt; &lt;/a&gt; 값 을 사용해야 하는 코드의 속도를 높이기 위해 구현되었습니다 . 물론 시스템에 대한 자세한 정보를 얻으려면 &lt;a href=&quot;config#DESCRIPTION&quot;&gt; &lt;code&gt;%Config&lt;/code&gt; &lt;/a&gt; 살펴 보는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="7c5ecc6508ddab8f3c4d91e33bbc7e0f0b10c001" translate="yes" xml:space="preserve">
          <source>Perl is built with a &lt;code&gt;$^O&lt;/code&gt; variable that indicates the operating system it was built on. This was implemented to help speed up code that would otherwise have to &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; Config&lt;/code&gt; and use the value of &lt;code&gt;$Config{osname}&lt;/code&gt; . Of course, to get more detailed information about the system, looking into &lt;code&gt;%Config&lt;/code&gt; is certainly recommended.</source>
          <target state="translated">Perl은 운영 체제를 나타내는 &lt;code&gt;$^O&lt;/code&gt; 변수로 빌드됩니다. &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; Config&lt;/code&gt; 를 사용하고 &lt;code&gt;$Config{osname}&lt;/code&gt; 값 을 &lt;a href=&quot;functions/use&quot;&gt;사용해야&lt;/a&gt; 하는 코드 속도를 높이기 위해 구현되었습니다 . 물론 시스템에 대한 자세한 정보를 얻으려면 &lt;code&gt;%Config&lt;/code&gt; 살펴 보는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="b0b403c257bdd4aeec1cd64ac49b8e8696c81aad" translate="yes" xml:space="preserve">
          <source>Perl is designed to make it easy to program securely even when running with extra privileges, like setuid or setgid programs. Unlike most command line shells, which are based on multiple substitution passes on each line of the script, Perl uses a more conventional evaluation scheme with fewer hidden snags. Additionally, because the language has more builtin functionality, it can rely less upon external (and possibly untrustworthy) programs to accomplish its purposes.</source>
          <target state="translated">Perl은 setuid 또는 setgid 프로그램과 같은 추가 권한으로 실행할 때도 안전하게 프로그래밍 할 수 있도록 설계되었습니다. 스크립트의 각 줄에서 여러 개의 대체 패스를 기반으로하는 대부분의 명령 줄 셸과 달리 Perl은 숨겨진 기호가 적은보다 일반적인 평가 체계를 사용합니다. 또한 언어에는 더 많은 기능이 내장되어 있으므로 외부 (및 신뢰할 수없는) 프로그램을 사용하여 목적을 달성 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="95e020b4e0da8b6212d413773e1d9a2f7cfa598b" translate="yes" xml:space="preserve">
          <source>Perl is flexible and extensible enough for you to use on virtually any task, from one-line file-processing tasks to large, elaborate systems.</source>
          <target state="translated">Perl은 한 줄의 파일 처리 작업에서 대규모의 정교한 시스템에 이르기까지 거의 모든 작업에 사용할 수 있도록 유연하고 확장 가능합니다.</target>
        </trans-unit>
        <trans-unit id="6ca32777c65e9c1e819db2ba028d7f7c9855e9eb" translate="yes" xml:space="preserve">
          <source>Perl is generally used in the situation when all the floating-point exceptions are ignored, as is the default under EMX. If they are not ignored, some benign Perl programs would get a &lt;code&gt;SIGFPE&lt;/code&gt; and would die a horrible death.</source>
          <target state="translated">Perl은 일반적으로 EMX의 기본값과 같이 모든 부동 소수점 예외가 무시되는 상황에서 사용됩니다. 그들이 무시하지 않으면, 일부 양성 Perl 프로그램은 &lt;code&gt;SIGFPE&lt;/code&gt; 를 받고 끔찍한 죽음으로 죽을 것입니다.</target>
        </trans-unit>
        <trans-unit id="3df1fe819c8ca8623cc85794dcd13ce337949f92" translate="yes" xml:space="preserve">
          <source>Perl is invoked from the command line as described in &lt;a href=&quot;perl&quot;&gt;perl&lt;/a&gt;. Most perl scripts, however, do have a first line such as &quot;#!/usr/local/bin/perl&quot;. This is known as a shebang (shell-bang) statement and tells the OS shell where to find the perl interpreter. In Plan 9 Perl this statement should be &quot;#!/bin/perl&quot; if you wish to be able to directly invoke the script by its name. Alternatively, you may invoke perl with the command &quot;Perl&quot; instead of &quot;perl&quot;. This will produce Acme-friendly error messages of the form &quot;filename:18&quot;.</source>
          <target state="translated">Perl은 &lt;a href=&quot;perl&quot;&gt;perl에&lt;/a&gt; 설명 된대로 명령 행에서 호출됩니다 . 그러나 대부분의 perl 스크립트에는 &quot;#! / usr / local / bin / perl&quot;과 같은 첫 번째 줄이 있습니다. 이것은 shebang (shell-bang) 명령문으로 알려져 있으며 OS 쉘에 perl 인터프리터를 찾을 위치를 알려줍니다. Plan 9 Perl에서 이름으로 스크립트를 직접 호출하려면이 명령문은 &quot;#! / bin / perl&quot;이어야합니다. 또는 &quot;perl&quot;대신 &quot;Perl&quot;명령으로 perl을 호출 할 수 있습니다. &quot;filename : 18&quot;형식의 Acme 친화적 오류 메시지가 나타납니다.</target>
        </trans-unit>
        <trans-unit id="e108d57bca9b7851cac34cf12c398ccee3cee194" translate="yes" xml:space="preserve">
          <source>Perl is one of the most ported pieces of software ever. It works on operating systems I've never even heard of (see perlport for details). It needs a build tool that can work on all those platforms and with any wacky C compilers and linkers they might have.</source>
          <target state="translated">Perl은 지금까지 가장 많이 포팅 된 소프트웨어 중 하나입니다. 내가 들어 본 적이없는 운영 체제에서 작동합니다 (자세한 내용은 perlport 참조). 모든 플랫폼에서 작동하는 엉뚱한 C 컴파일러 및 링커에서 작동하는 빌드 도구가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="69310d8ba2e9aaba734a13daced6bd681b7dd539" translate="yes" xml:space="preserve">
          <source>Perl is widely renowned for excellence in text processing, and regular expressions are one of the big factors behind this fame. Perl regular expressions display an efficiency and flexibility unknown in most other computer languages. Mastering even the basics of regular expressions will allow you to manipulate text with surprising ease.</source>
          <target state="translated">Perl은 텍스트 처리의 우수성으로 널리 알려져 있으며 정규 표현식은이 명성의 가장 큰 요인 중 하나입니다. Perl 정규식은 대부분의 다른 컴퓨터 언어에서 알 수없는 효율성과 유연성을 나타냅니다. 정규 표현식의 기본 사항을 습득하면 텍스트를 매우 쉽게 조작 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9136a62ad4b5fb86c3834a4ff695ef28ba74673c" translate="yes" xml:space="preserve">
          <source>Perl isn't sure if you meant this</source>
          <target state="translated">펄은 당신이 이것을 의미하는지 확실하지 않습니다</target>
        </trans-unit>
        <trans-unit id="29e85b3cc84aac2162dbddc5c0e070c097c573e4" translate="yes" xml:space="preserve">
          <source>Perl itself (outside the &lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt; module) will not use locales unless specifically requested to (but again note that Perl may interact with code that does use them). Even if there is such a request, &lt;b&gt;all&lt;/b&gt; of the following must be true for it to work properly:</source>
          <target state="translated">Perl 자체 ( &lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt; 모듈 외부 )는 특별히 요청하지 않는 한 로케일을 사용하지 않습니다 (그러나 Perl은이를 사용하는 코드와 상호 작용할 수 있음에 유의하십시오). 그러한 요청이 있어도 제대로 작동하려면 다음 사항이 &lt;b&gt;모두&lt;/b&gt; 충족되어야합니다.</target>
        </trans-unit>
        <trans-unit id="b448d0fc5ff15548da831acf37af4494d6504c93" translate="yes" xml:space="preserve">
          <source>Perl itself never had a Y2K problem, although that never stopped people from creating Y2K problems on their own. See the documentation for &lt;code&gt;&lt;a href=&quot;functions/localtime&quot;&gt;localtime&lt;/a&gt;&lt;/code&gt; for its proper use.</source>
          <target state="translated">Perl 자체는 Y2K 문제가 없었습니다. 올바른 사용법 은 &lt;code&gt;&lt;a href=&quot;functions/localtime&quot;&gt;localtime&lt;/a&gt;&lt;/code&gt; 설명서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f2cc4a6fccf4fd64e021bb2b5f362d3715f43b3f" translate="yes" xml:space="preserve">
          <source>Perl itself never had a Y2K problem, although that never stopped people from creating Y2K problems on their own. See the documentation for &lt;code&gt;localtime&lt;/code&gt; for its proper use.</source>
          <target state="translated">Perl 자체에는 Y2K 문제가 없었지만, 그것이 사람들이 스스로 Y2K 문제를 만드는 것을 막지는 못했습니다. 적절한 사용에 대해서는 &lt;code&gt;localtime&lt;/code&gt; 대한 문서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="44b05ec97c9cd0cd0a392295c641d71beeda8b2c" translate="yes" xml:space="preserve">
          <source>Perl keeps the actual data in a linked list of structures with a typedef of HE. These contain the actual key and value pointers (plus extra administrative overhead). The key is a string pointer; the value is an &lt;code&gt;SV*&lt;/code&gt; . However, once you have an &lt;code&gt;HE*&lt;/code&gt; , to get the actual key and value, use the routines specified below.</source>
          <target state="translated">Perl은 실제 데이터를 typedef가 HE 인 링크 된 구조 목록으로 유지합니다. 여기에는 실제 키 및 값 포인터와 추가 관리 오버 헤드가 포함됩니다. 키는 문자열 포인터입니다. 값은 &lt;code&gt;SV*&lt;/code&gt; 입니다. 그러나 &lt;code&gt;HE*&lt;/code&gt; 가 있으면 실제 키와 값을 얻으려면 아래 지정된 루틴을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="fb449bcf7d8ee7c61f13e13d363e2fbfa90f9e62" translate="yes" xml:space="preserve">
          <source>Perl keeps the actual data in a linked list of structures with a typedef of HE. These contain the actual key and value pointers (plus extra administrative overhead). The key is a string pointer; the value is an &lt;code&gt;SV*&lt;/code&gt;. However, once you have an &lt;code&gt;HE*&lt;/code&gt;, to get the actual key and value, use the routines specified below.</source>
          <target state="translated">Perl은 유형 정의가 HE 인 구조의 링크 된 목록에 실제 데이터를 유지합니다. 여기에는 실제 키 및 값 포인터 (추가 관리 오버 헤드 포함)가 포함됩니다. 키는 문자열 포인터입니다. 값은 &lt;code&gt;SV*&lt;/code&gt; 입니다. 그러나 &lt;code&gt;HE*&lt;/code&gt; 가 있으면 실제 키와 값을 얻으려면 아래에 지정된 루틴을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="b5143bb91f08dc1c6dfd63a718e07f8c7c54d1b4" translate="yes" xml:space="preserve">
          <source>Perl knows how it stored the string internally, and will use that knowledge when you &lt;code&gt;encode&lt;/code&gt; . In other words: don't try to find out what the internal encoding for a certain string is, but instead just encode it into the encoding that you want.</source>
          <target state="translated">Perl은 어떻게 문자열을 내부에 저장했는지 알고 있으며 &lt;code&gt;encode&lt;/code&gt; 할 때 그 지식을 사용합니다 . 즉, 특정 문자열의 내부 인코딩이 무엇인지 알아 내지 말고 원하는 인코딩으로 인코딩하십시오.</target>
        </trans-unit>
        <trans-unit id="c655bf7234ceeb2dde7bb0db4fba269b70d380f3" translate="yes" xml:space="preserve">
          <source>Perl knows how it stored the string internally, and will use that knowledge when you &lt;code&gt;encode&lt;/code&gt;. In other words: don't try to find out what the internal encoding for a certain string is, but instead just encode it into the encoding that you want.</source>
          <target state="translated">펄은 내부적으로 문자열을 저장하고이 때 그 지식을 사용하는 방법을 알고 &lt;code&gt;encode&lt;/code&gt; . 즉, 특정 문자열의 내부 인코딩이 무엇인지 알아 내려고하지 말고 원하는 인코딩으로 인코딩하십시오.</target>
        </trans-unit>
        <trans-unit id="28c0b3b1efe64d6536aefbbd7df5f013304f845e" translate="yes" xml:space="preserve">
          <source>Perl knows what package the method is in by looking at the left side of the arrow. If the left hand side is a package name, it looks for the method in that package. If the left hand side is an object, then Perl looks for the method in the package that the object has been blessed into.</source>
          <target state="translated">Perl은 화살표의 왼쪽을보고 방법이 어떤 패키지인지 알고 있습니다. 왼쪽이 패키지 이름 인 경우 해당 패키지의 메소드를 찾습니다. 왼쪽이 객체이면 Perl은 패키지에서 객체가 축복받은 방법을 찾습니다.</target>
        </trans-unit>
        <trans-unit id="5816a72e8edbf2978259af959564532c0158a768" translate="yes" xml:space="preserve">
          <source>Perl lets us have complex data structures. You can write something like this and all of a sudden, you'd have an array with three dimensions!</source>
          <target state="translated">Perl은 복잡한 데이터 구조를 가질 수있게합니다. 이런 식으로 쓸 수 있고 갑자기 3 차원 배열이 생깁니다!</target>
        </trans-unit>
        <trans-unit id="c792eeb72bf7222c26382dcf2643ff8d2431a9b2" translate="yes" xml:space="preserve">
          <source>Perl lets you use a scalar variable containing a string as a method name:</source>
          <target state="translated">Perl에서는 문자열을 메소드 이름으로 포함하는 스칼라 변수를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cbe2b90e37525ab41be0459f402495dfeae82682" translate="yes" xml:space="preserve">
          <source>Perl maintains environment variables in a special hash named &lt;code&gt;%ENV&lt;/code&gt; . For when this access method is inconvenient, the Perl module &lt;code&gt;Env&lt;/code&gt; allows environment variables to be treated as scalar or array variables.</source>
          <target state="translated">Perl은 &lt;code&gt;%ENV&lt;/code&gt; 라는 특수 해시로 환경 변수를 유지합니다 . 이 액세스 방법이 불편한 경우 Perl 모듈 &lt;code&gt;Env&lt;/code&gt; 를 사용하면 환경 변수를 스칼라 또는 배열 변수로 처리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="2f4c9c62b19928dbcce3428ee1199a16ecae0aed" translate="yes" xml:space="preserve">
          <source>Perl maintains environment variables in a special hash named &lt;code&gt;%ENV&lt;/code&gt;. For when this access method is inconvenient, the Perl module &lt;code&gt;Env&lt;/code&gt; allows environment variables to be treated as scalar or array variables.</source>
          <target state="translated">Perl은 &lt;code&gt;%ENV&lt;/code&gt; 라는 특수 해시에서 환경 변수를 유지합니다 . 이 액세스 방법이 불편할 때 Perl 모듈 &lt;code&gt;Env&lt;/code&gt; 를 사용하면 환경 변수를 스칼라 또는 배열 변수로 처리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="adff6cd758f5a3032ba367b5b7627b9df7afebcc" translate="yes" xml:space="preserve">
          <source>Perl makes all environment variables available to the program being executed, and passes these along to any child processes it starts. However, programs running setuid would do well to execute the following lines before doing anything else, just to keep people honest:</source>
          <target state="translated">Perl은 실행중인 프로그램에 모든 환경 변수를 사용할 수있게하고이를 시작하는 모든 하위 프로세스에 전달합니다. 그러나 setuid를 실행하는 프로그램은 사람들을 정직하게 유지하기 위해 다른 작업을 수행하기 전에 다음 행을 실행하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="162c022ef155f35d9a828d8883301923c1130fa3" translate="yes" xml:space="preserve">
          <source>Perl manual in</source>
          <target state="translated">Perl 매뉴얼</target>
        </trans-unit>
        <trans-unit id="dbb37d4ff4d4f8d3c98e670fbe144d6ded8ac9e4" translate="yes" xml:space="preserve">
          <source>Perl may also use &lt;code&gt;minus()&lt;/code&gt; to implement other operators which have not been specified in the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; overload&lt;/code&gt; directive, according to the rules for &lt;a href=&quot;#Magic-Autogeneration&quot;&gt;Magic Autogeneration&lt;/a&gt; described later. For example, the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; overload&lt;/code&gt; above declared no subroutine for any of the operators &lt;code&gt;--&lt;/code&gt; , &lt;code&gt;neg&lt;/code&gt; (the overload key for unary minus), or &lt;code&gt;-=&lt;/code&gt; . Thus</source>
          <target state="translated">Perl은 &lt;code&gt;minus()&lt;/code&gt; 를 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; overload&lt;/code&gt; 하여 나중에 설명 된 &lt;a href=&quot;#Magic-Autogeneration&quot;&gt;Magic Autogeneration&lt;/a&gt; 규칙에 따라 use overload 지시문 에 지정되지 않은 다른 연산자를 구현할 수도 있습니다 . 예를 들어, 위의 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; overload&lt;/code&gt; &lt;a href=&quot;functions/use&quot;&gt;사용&lt;/a&gt; 은 연산자 &lt;code&gt;--&lt;/code&gt; , &lt;code&gt;neg&lt;/code&gt; (단항 마이너스의 과부하 키) 또는 &lt;code&gt;-=&lt;/code&gt; 에 대해 서브 루틴 없음을 선언했습니다 . 그러므로</target>
        </trans-unit>
        <trans-unit id="386fe189f1039aa3ac9a068a2d2a8d19e7ef0b9d" translate="yes" xml:space="preserve">
          <source>Perl may also use &lt;code&gt;minus()&lt;/code&gt; to implement other operators which have not been specified in the &lt;code&gt;use overload&lt;/code&gt; directive, according to the rules for &lt;a href=&quot;#Magic-Autogeneration&quot;&gt;&quot;Magic Autogeneration&quot;&lt;/a&gt; described later. For example, the &lt;code&gt;use overload&lt;/code&gt; above declared no subroutine for any of the operators &lt;code&gt;--&lt;/code&gt;, &lt;code&gt;neg&lt;/code&gt; (the overload key for unary minus), or &lt;code&gt;-=&lt;/code&gt;. Thus</source>
          <target state="translated">Perl은 또한 &lt;code&gt;minus()&lt;/code&gt; 를 &lt;code&gt;use overload&lt;/code&gt; 하여 나중에 설명 하는 &lt;a href=&quot;#Magic-Autogeneration&quot;&gt;&quot;Magic Autogeneration&quot;&lt;/a&gt; 규칙에 따라 use 오버로드 지시문 에 지정되지 않은 다른 연산자를 구현할 수 있습니다 . 예를 들어, 위 의 &lt;code&gt;use overload&lt;/code&gt; 는 연산자 &lt;code&gt;--&lt;/code&gt; , &lt;code&gt;neg&lt;/code&gt; (단항 빼기의 오버로드 키) 또는 &lt;code&gt;-=&lt;/code&gt; 에 대해 서브 루틴을 선언하지 않았습니다 . 그러므로</target>
        </trans-unit>
        <trans-unit id="4c8da87cabae75ef4041db61733575500f2f5c87" translate="yes" xml:space="preserve">
          <source>Perl may be built to ignore this variable.</source>
          <target state="translated">Perl은이 변수를 무시하도록 빌드 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fc722e05604a8e2215a16848c1b1749c16faaf82" translate="yes" xml:space="preserve">
          <source>Perl may be run from the AmigaOS shell but for best results should be run under abc-shell. (abc-shell handles file globbing, pattern expansion, and sets up environment variables in the UN*Xy way that Perl expects.)</source>
          <target state="translated">Perl은 AmigaOS 셸에서 실행할 수 있지만 최상의 결과를 얻으려면 abc-shell에서 실행해야합니다. (abc-shell은 파일 globbing, 패턴 확장을 처리하고 Perl이 예상하는 UN * Xy 방식으로 환경 변수를 설정합니다.)</target>
        </trans-unit>
        <trans-unit id="d02d1a8d8ad8ebaf66f5ae1fae9a8be6973bfe68" translate="yes" xml:space="preserve">
          <source>Perl modifies some standard C library calls in the following ways:</source>
          <target state="translated">Perl은 다음과 같은 방식으로 일부 표준 C 라이브러리 호출을 수정합니다.</target>
        </trans-unit>
        <trans-unit id="ae2b30d9e1d501c616a9183c5e463ad869566bb9" translate="yes" xml:space="preserve">
          <source>Perl module that imports environment variables as scalars or arrays</source>
          <target state="translated">환경 변수를 스칼라 또는 배열로 가져 오는 Perl 모듈</target>
        </trans-unit>
        <trans-unit id="8ba6990d9c4bf6e673e08de2996db458f738f918" translate="yes" xml:space="preserve">
          <source>Perl modules &lt;a href=&quot;BSD::Resource&quot;&gt;BSD::Resource&lt;/a&gt;, &lt;a href=&quot;Time::TAI64&quot;&gt;Time::TAI64&lt;/a&gt;.</source>
          <target state="translated">Perl 모듈 &lt;a href=&quot;BSD::Resource&quot;&gt;BSD :: Resource&lt;/a&gt; , &lt;a href=&quot;Time::TAI64&quot;&gt;Time :: TAI64&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5bf20acb7bc71507889f12ba0d9ef4ff255fd169" translate="yes" xml:space="preserve">
          <source>Perl modules &lt;a href=&quot;http://search.cpan.org/perldoc/BSD::Resource&quot;&gt;BSD::Resource&lt;/a&gt;, &lt;a href=&quot;http://search.cpan.org/perldoc/Time::TAI64&quot;&gt;Time::TAI64&lt;/a&gt;.</source>
          <target state="translated">Perl 모듈 &lt;a href=&quot;http://search.cpan.org/perldoc/BSD::Resource&quot;&gt;BSD :: Resource&lt;/a&gt; , &lt;a href=&quot;http://search.cpan.org/perldoc/Time::TAI64&quot;&gt;Time :: TAI64&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9426f05ffd49561244dd50c76b095078d755129d" translate="yes" xml:space="preserve">
          <source>Perl modules always have a</source>
          <target state="translated">펄 모듈은 항상</target>
        </trans-unit>
        <trans-unit id="51c59ce0ac574ea7f8b9de507be10bf4487a787f" translate="yes" xml:space="preserve">
          <source>Perl modules are included into your program by saying</source>
          <target state="translated">펄 모듈은 다음과 같이 말함으로써 프로그램에 포함됩니다</target>
        </trans-unit>
        <trans-unit id="aefb322d2fca2dbb6f88aa84174a1e5c7a427c0e" translate="yes" xml:space="preserve">
          <source>Perl modules are not the only tools a performance analyst has at their disposal, system tools like &lt;code&gt;&lt;a href=&quot;functions/time&quot;&gt;time&lt;/a&gt;&lt;/code&gt; should not be overlooked as the next example shows, where we take a quick look at sorting. Many books, theses and articles, have been written about efficient sorting algorithms, and this is not the place to repeat such work, there's several good sorting modules which deserve taking a look at too: &lt;code&gt;Sort::Maker&lt;/code&gt; , &lt;code&gt;Sort::Key&lt;/code&gt; spring to mind. However, it's still possible to make some observations on certain Perl specific interpretations on issues relating to sorting data sets and give an example or two with regard to how sorting large data volumes can effect performance. Firstly, an often overlooked point when sorting large amounts of data, one can attempt to reduce the data set to be dealt with and in many cases &lt;code&gt;&lt;a href=&quot;functions/grep&quot;&gt;grep()&lt;/a&gt;&lt;/code&gt; can be quite useful as a simple filter:</source>
          <target state="translated">Perl 모듈은 성능 분석가가 사용할 수있는 유일한 도구 가 아니라 다음 예제에서 볼 수 있듯이 &lt;code&gt;&lt;a href=&quot;functions/time&quot;&gt;time&lt;/a&gt;&lt;/code&gt; 과 같은 시스템 도구를 간과해서는 안됩니다. 효율적인 정렬 알고리즘에 대해 많은 책, 논문 및 기사가 작성되었으며, 이러한 작업을 반복 할 수있는 곳이 아닙니다. &lt;code&gt;Sort::Maker&lt;/code&gt; , &lt;code&gt;Sort::Key&lt;/code&gt; 마음에 봄. 그러나 데이터 세트 정렬과 관련된 문제에 대한 특정 Perl 특정 해석에 대해 일부 관찰을 수행하고 대용량 데이터를 정렬하는 것이 성능에 미치는 영향에 대한 예를 하나 또는 두 개 제공 할 수 있습니다. 첫째, 많은 양의 데이터를 정렬 할 때 간과되는 점은 처리 할 데이터 세트를 줄이려고 시도 할 수 있으며 대부분의 경우 &lt;code&gt;&lt;a href=&quot;functions/grep&quot;&gt;grep()&lt;/a&gt;&lt;/code&gt; 은 간단한 필터로 매우 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c620f5ed9b475e8a05d4bd8c8511a64bdd8fb857" translate="yes" xml:space="preserve">
          <source>Perl modules are not the only tools a performance analyst has at their disposal, system tools like &lt;code&gt;time&lt;/code&gt; should not be overlooked as the next example shows, where we take a quick look at sorting. Many books, theses and articles, have been written about efficient sorting algorithms, and this is not the place to repeat such work, there's several good sorting modules which deserve taking a look at too: &lt;code&gt;Sort::Maker&lt;/code&gt;, &lt;code&gt;Sort::Key&lt;/code&gt; spring to mind. However, it's still possible to make some observations on certain Perl specific interpretations on issues relating to sorting data sets and give an example or two with regard to how sorting large data volumes can effect performance. Firstly, an often overlooked point when sorting large amounts of data, one can attempt to reduce the data set to be dealt with and in many cases &lt;code&gt;grep()&lt;/code&gt; can be quite useful as a simple filter:</source>
          <target state="translated">Perl 모듈은 성능 분석가가 사용할 수있는 유일한 도구 가 아닙니다. 정렬에 대해 간략히 살펴 보는 다음 예제에서 볼 수 있듯이 &lt;code&gt;time&lt;/code&gt; 과 같은 시스템 도구를 간과해서는 안됩니다. 효율적인 정렬 알고리즘에 대해 많은 책, 논문 및 기사가 작성되었으며 여기는 이러한 작업을 반복 할 수있는 곳이 아닙니다. &lt;code&gt;Sort::Maker&lt;/code&gt; , &lt;code&gt;Sort::Key&lt;/code&gt; 마음에 봄. 그러나 데이터 세트 정렬과 관련된 문제에 대한 특정 Perl 특정 해석에 대한 일부 관찰을 수행하고 대용량 데이터 볼륨 정렬이 성능에 미치는 영향과 관련하여 한두 가지 예를 제공하는 것은 여전히 ​​가능합니다. 첫째, 많은 양의 데이터를 정렬 할 때 종종 간과되는 점입니다. 처리 할 데이터 세트를 줄이려고 시도 할 수 있으며 많은 경우 &lt;code&gt;grep()&lt;/code&gt; 은 간단한 필터로 매우 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c8ed366b21e1c4b28e58fe8a9ca47a44e9e81f0c" translate="yes" xml:space="preserve">
          <source>Perl modules included on CPAN have a naming hierarchy you should try to fit in with. See &lt;a href=&quot;perlmodlib&quot;&gt;perlmodlib&lt;/a&gt; for more details on how this works, and browse around CPAN and the modules list to get a feel of it. At the very least, remember this: modules should be title capitalised, (This::Thing) fit in with a category, and explain their purpose succinctly.</source>
          <target state="translated">CPAN에 포함 된 Perl 모듈에는 적합한 이름 지정 계층이 있습니다. 이것이 작동하는 방법에 대한 자세한 내용 은 &lt;a href=&quot;perlmodlib&quot;&gt;perlmodlib&lt;/a&gt; 를 참조 하고 CPAN 및 모듈 목록을 탐색하여 느낌을 얻으십시오. 최소한 다음 사항을 기억하십시오. 모듈은 제목에 대문자를 사용해야하며 (This :: Thing) 범주에 적합해야하며 간결하게 목적을 설명해야합니다.</target>
        </trans-unit>
        <trans-unit id="16a1215b63adeb8dd991dd695ae42ffb9a1eb457" translate="yes" xml:space="preserve">
          <source>Perl modules provide a range of features to help you avoid reinventing the wheel, and can be downloaded from CPAN ( &lt;a href=&quot;http://www.cpan.org/&quot;&gt;http://www.cpan.org/&lt;/a&gt; ). A number of popular modules are included with the Perl distribution itself.</source>
          <target state="translated">Perl 모듈은 휠 재발견을 피하는 데 도움이되는 다양한 기능을 제공하며 CPAN ( &lt;a href=&quot;http://www.cpan.org/&quot;&gt;http://www.cpan.org/&lt;/a&gt; ) 에서 다운로드 할 수 있습니다 . 많은 인기있는 모듈이 Perl 배포판 자체에 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="4baa5fc19e15bb718240e4d275bac1fb00891783" translate="yes" xml:space="preserve">
          <source>Perl mongers</source>
          <target state="translated">Perl 상인</target>
        </trans-unit>
        <trans-unit id="d1cd3ab508bb28b102f16c9bbb53b67e972c7a2d" translate="yes" xml:space="preserve">
          <source>Perl must be compiled with the &lt;code&gt;-Dusedtrace&lt;/code&gt; option in order to make use of the provided probes. While DTrace aims to have no overhead when its instrumentation is not active, Perl's support itself cannot uphold that guarantee, so it is built without DTrace probes under most systems. One notable exception is that Mac OS X ships a</source>
          <target state="translated">제공된 프로브를 사용하려면 Perl을 &lt;code&gt;-Dusedtrace&lt;/code&gt; 옵션 으로 컴파일해야합니다 . DTrace는 계측이 활성화되지 않은 경우 오버 헤드가없는 것을 목표로하지만 Perl의 지원 자체는 그러한 보증을지지 할 수 없으므로 대부분의 시스템에서 DTrace 프로브없이 구축됩니다. 주목할만한 예외는 Mac OS X이</target>
        </trans-unit>
        <trans-unit id="4f0521c787f7204ca515e6ab4a24e34133e68740" translate="yes" xml:space="preserve">
          <source>Perl never issued a deprecation warning for this; the deprecation was by documentation policy only. But this deprecation has been lifted as of Perl 5.26.</source>
          <target state="translated">Perl은 이에 대한 사용 중단 경고를 발행 한 적이 없습니다. 지원 중단은 문서 정책에 의한 것입니다. 그러나이 지원 중단은 Perl 5.26부터 해제되었습니다.</target>
        </trans-unit>
        <trans-unit id="7959a78b422ac56c4b5d4bc26bed7e5e49a45d2d" translate="yes" xml:space="preserve">
          <source>Perl normally assumes character semantics in the presence of character data (i.e. data that has come from a source that has been marked as being of a particular character encoding). When &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; bytes&lt;/code&gt; is in effect, the encoding is temporarily ignored, and each string is treated as a series of bytes.</source>
          <target state="translated">Perl은 일반적으로 문자 데이터 (즉, 특정 문자 인코딩으로 표시된 소스에서 가져온 데이터)가있는 경우 문자 의미를 가정합니다. 경우 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; bytes&lt;/code&gt; 적용하고, 인코딩 일시적 무시되고, 각 스트링은 일련의 바이트로 간주한다.</target>
        </trans-unit>
        <trans-unit id="1b90be8b391bd63ee34d9c789dadd260ffcc448a" translate="yes" xml:space="preserve">
          <source>Perl normally buffers output so it doesn't make a system call for every bit of output. By saving up output, it makes fewer expensive system calls. For instance, in this little bit of code, you want to print a dot to the screen for every line you process to watch the progress of your program. Instead of seeing a dot for every line, Perl buffers the output and you have a long wait before you see a row of 50 dots all at once:</source>
          <target state="translated">Perl은 일반적으로 출력을 버퍼링하므로 모든 출력 비트에 대해 시스템 호출을하지는 않습니다. 출력을 절약하면 시스템 호출 비용이 줄어 듭니다. 예를 들어,이 작은 코드에서는 처리하는 모든 줄에 대해 화면에 점을 인쇄하여 프로그램의 진행 상황을보고자합니다. 모든 줄에 점을 표시하는 대신 Perl은 출력을 버퍼링하고 한 번에 50 개의 점이 모두 표시되기까지 오래 기다립니다.</target>
        </trans-unit>
        <trans-unit id="431e8ad9293b07f5bdc791f87a08a93d077e2bfe" translate="yes" xml:space="preserve">
          <source>Perl now builds with FreeMiNT/Atari. It fails a few tests, that needs some investigation.</source>
          <target state="translated">Perl은 이제 FreeMiNT / Atari로 빌드합니다. 몇 가지 테스트에 실패하여 조사가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="a3e768752fac3a285306cd9e651f17f9a775de00" translate="yes" xml:space="preserve">
          <source>Perl officially stands for Practical Extraction and Report Language, except when it doesn't.</source>
          <target state="translated">Perl은 공식적으로 실용 추출 및 보고서 언어를 나타내며, 그렇지 않은 경우를 제외하고는</target>
        </trans-unit>
        <trans-unit id="b0646278b43c189bd46c39a69a1dddf12d2a1a29" translate="yes" xml:space="preserve">
          <source>Perl on ILE</source>
          <target state="translated">ILE의 펄</target>
        </trans-unit>
        <trans-unit id="880fc5c1aef63a3507fd91075a126effdad077b7" translate="yes" xml:space="preserve">
          <source>Perl on VMS can accept either VMS- or Unix-style file specifications as in either of the following:</source>
          <target state="translated">VMS의 Perl은 다음 중 하나와 같이 VMS 또는 Unix 스타일 파일 스펙을 승인 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4e6cb5edd48ea8ec698a9fa2e92cd3f38a3692ce" translate="yes" xml:space="preserve">
          <source>Perl on VMS is discussed in &lt;a href=&quot;perlvms&quot;&gt;perlvms&lt;/a&gt; in the Perl distribution.</source>
          <target state="translated">VMS 의 Perl은 Perl 배포의 &lt;a href=&quot;perlvms&quot;&gt;perlvms&lt;/a&gt; 에서 설명 합니다.</target>
        </trans-unit>
        <trans-unit id="d5aebe7d6ab79a49ac64f2ccd625e787536b0d61" translate="yes" xml:space="preserve">
          <source>Perl on VMS supports an emulation of the forked debugger when Perl is run on a VMS system that has X11 support installed.</source>
          <target state="translated">VMS의 Perl은 X11 지원이 설치된 VMS 시스템에서 Perl을 실행할 때 분기 된 디버거의 에뮬레이션을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="e4268b27ba1ef13a83b583c860e24d2f36fbf4ec" translate="yes" xml:space="preserve">
          <source>Perl on VOS (also known as OpenVOS) is discussed in</source>
          <target state="translated">VOS (OpenVOS라고도 함)에 대한 Perl은</target>
        </trans-unit>
        <trans-unit id="30b19fafc5c58735f6b1d4a22aac29cb87b533e0" translate="yes" xml:space="preserve">
          <source>Perl only implements the full form of casefolding, but you can access the simple folds using &lt;a href=&quot;../unicode/ucd#casefold()&quot;&gt;casefold() in Unicode::UCD&lt;/a&gt; and &lt;a href=&quot;../unicode/ucd#prop_invmap()&quot;&gt;prop_invmap() in Unicode::UCD&lt;/a&gt;. For further information on casefolding, refer to the Unicode Standard, specifically sections 3.13 &lt;code&gt;Default Case Operations&lt;/code&gt; , 4.2 &lt;code&gt;Case-Normative&lt;/code&gt; , and 5.18 &lt;code&gt;Case Mappings&lt;/code&gt; , available at &lt;a href=&quot;http://www.unicode.org/versions/latest/&quot;&gt;http://www.unicode.org/versions/latest/&lt;/a&gt;, as well as the Case Charts available at &lt;a href=&quot;http://www.unicode.org/charts/case/&quot;&gt;http://www.unicode.org/charts/case/&lt;/a&gt;.</source>
          <target state="translated">Perl은 전체 형식의 casefolding 만 구현하지만 &lt;a href=&quot;../unicode/ucd#casefold()&quot;&gt;Unicode :: UCD의 &lt;/a&gt;&lt;a href=&quot;../unicode/ucd#prop_invmap()&quot;&gt;casefold ()&lt;/a&gt; 및 Unicode :: UCD의 prop_invmap ()을 사용하여 간단한 접기에 액세스 할 수 있습니다 . 케이스 폴딩에 대한 자세한 내용은 유니 코드 표준, 특히 &lt;a href=&quot;http://www.unicode.org/versions/latest/&quot;&gt;http://www.unicode.org/versions/latest/&lt;/a&gt; 에서 제공되는 3.13 &lt;code&gt;Default Case Operations&lt;/code&gt; , 4.2 &lt;code&gt;Case-Normative&lt;/code&gt; 및 5.18 &lt;code&gt;Case Mappings&lt;/code&gt; 섹션 을 참조하십시오 . 사례 차트는 &lt;a href=&quot;http://www.unicode.org/charts/case/&quot;&gt;http://www.unicode.org/charts/case/&lt;/a&gt; 에서 볼 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ec15f965c51c1ac480bfbe6c5c4b87645989a486" translate="yes" xml:space="preserve">
          <source>Perl only implements the full form of casefolding, but you can access the simple folds using &lt;a href=&quot;Unicode::UCD#casefold%28%29&quot;&gt;&quot;&lt;b&gt;casefold()&lt;/b&gt;&quot; in Unicode::UCD&lt;/a&gt; and &lt;a href=&quot;Unicode::UCD#prop_invmap%28%29&quot;&gt;&quot;&lt;b&gt;prop_invmap()&lt;/b&gt;&quot; in Unicode::UCD&lt;/a&gt;. For further information on casefolding, refer to the Unicode Standard, specifically sections 3.13 &lt;code&gt;Default Case Operations&lt;/code&gt;, 4.2 &lt;code&gt;Case-Normative&lt;/code&gt;, and 5.18 &lt;code&gt;Case Mappings&lt;/code&gt;, available at &lt;a href=&quot;https://www.unicode.org/versions/latest/&quot;&gt;https://www.unicode.org/versions/latest/&lt;/a&gt;, as well as the Case Charts available at &lt;a href=&quot;https://www.unicode.org/charts/case/&quot;&gt;https://www.unicode.org/charts/case/&lt;/a&gt;.</source>
          <target state="translated">펄은 casefolding의 전체 형태를 구현,하지만 당신은 간단한 사용 주름이 액세스 할 수 있습니다 &lt;a href=&quot;Unicode::UCD#casefold%28%29&quot;&gt;&quot; &lt;b&gt;) casefold을 (&lt;/b&gt; 유니 코드 : UCD에서&quot;&lt;/a&gt; 및 &lt;a href=&quot;Unicode::UCD#prop_invmap%28%29&quot;&gt;&quot; &lt;b&gt;() prop_invmap을&lt;/b&gt; 유니 코드 : UCD에&quot;&lt;/a&gt; . casefolding에 대한 자세한 내용은 유니 코드 표준, 특히 섹션 3.13 &lt;code&gt;Default Case Operations&lt;/code&gt; , 4.2 &lt;code&gt;Case-Normative&lt;/code&gt; 및 5.18 &lt;code&gt;Case Mappings&lt;/code&gt; , &lt;a href=&quot;https://www.unicode.org/versions/latest/&quot;&gt;https://www.unicode.org/versions/latest/&lt;/a&gt; 및 &lt;a href=&quot;https://www.unicode.org/charts/case/&quot;&gt;https://www.unicode.org/charts/case/&lt;/a&gt; 에서 사례 차트를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="03ce9ffc7efddb5ffb70fe53243d42ea4fbb733a" translate="yes" xml:space="preserve">
          <source>Perl only implements the full form of casefolding, but you can access the simple folds using &lt;a href=&quot;unicode/ucd#casefold()&quot;&gt;casefold() in Unicode::UCD&lt;/a&gt; and &lt;a href=&quot;unicode/ucd#prop_invmap()&quot;&gt;prop_invmap() in Unicode::UCD&lt;/a&gt;. For further information on casefolding, refer to the Unicode Standard, specifically sections 3.13 &lt;code&gt;Default Case Operations&lt;/code&gt; , 4.2 &lt;code&gt;Case-Normative&lt;/code&gt; , and 5.18 &lt;code&gt;Case Mappings&lt;/code&gt; , available at &lt;a href=&quot;http://www.unicode.org/versions/latest/&quot;&gt;http://www.unicode.org/versions/latest/&lt;/a&gt;, as well as the Case Charts available at &lt;a href=&quot;http://www.unicode.org/charts/case/&quot;&gt;http://www.unicode.org/charts/case/&lt;/a&gt;.</source>
          <target state="translated">Perl은 전체 형식의 casefolding 만 구현하지만 &lt;a href=&quot;unicode/ucd#casefold()&quot;&gt;Unicode :: UCD의 &lt;/a&gt;&lt;a href=&quot;unicode/ucd#prop_invmap()&quot;&gt;casefold ()&lt;/a&gt; 및 Unicode :: UCD의 prop_invmap ()을 사용하여 간단한 접기에 액세스 할 수 있습니다 . 케이스 폴딩에 대한 자세한 내용은 유니 코드 표준, 특히 &lt;a href=&quot;http://www.unicode.org/versions/latest/&quot;&gt;http://www.unicode.org/versions/latest/&lt;/a&gt; 에서 제공되는 3.13 &lt;code&gt;Default Case Operations&lt;/code&gt; , 4.2 &lt;code&gt;Case-Normative&lt;/code&gt; 및 5.18 &lt;code&gt;Case Mappings&lt;/code&gt; 섹션 을 참조하십시오 . 사례 차트는 &lt;a href=&quot;http://www.unicode.org/charts/case/&quot;&gt;http://www.unicode.org/charts/case/&lt;/a&gt; 에서 볼 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="afa3b7b0cef4f08dacda3735ba0561143481e189" translate="yes" xml:space="preserve">
          <source>Perl operations which take a numeric argument treat that argument in one of four different ways: they may force it to one of the integer/floating/ string formats, or they may behave differently depending on the format of the operand. Forcing a numeric value to a particular format does not change the number stored in the value.</source>
          <target state="translated">숫자 인수를 사용하는 Perl 연산은 해당 인수를 네 가지 방법 중 하나로 처리합니다. 인수를 정수 / 부동 / 문자열 형식 중 하나로 강제하거나 피연산자의 형식에 따라 다르게 동작 할 수 있습니다. 숫자 값을 특정 형식으로 설정해도 값에 저장된 숫자는 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2e266081b45b4d898d18421d1048baf2bfd24b32" translate="yes" xml:space="preserve">
          <source>Perl operators are documented in full in &lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt;, but here are a few of the most common ones:</source>
          <target state="translated">Perl 연산자는 &lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt; 로 완전히 문서화되어 있지만 가장 일반적인 연산자는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f67a6a1b456cb0e8982256ff29539f81c3619324" translate="yes" xml:space="preserve">
          <source>Perl operators have the following associativity and precedence, listed from highest precedence to lowest. Operators borrowed from C keep the same precedence relationship with each other, even where C's precedence is slightly screwy. (This makes learning Perl easier for C folks.) With very few exceptions, these all operate on scalar values only, not array values.</source>
          <target state="translated">Perl 연산자는 다음과 같은 연관성 및 우선 순위를 갖습니다. C에서 빌린 연산자는 C의 우선 순위가 약간 까다로운 경우에도 서로 동일한 우선 순위 관계를 유지합니다. (이것은 C 사람들에게 Perl을 쉽게 배울 수있게한다.) 예외는 거의 없지만, 이것들은 모두 배열 값이 아닌 스칼라 값에서만 작동한다.</target>
        </trans-unit>
        <trans-unit id="979c77e2112ac6d101931348fcf8adccee72ed6b" translate="yes" xml:space="preserve">
          <source>Perl operators that return true or false generally return values that can be safely used as numbers. For example, the relational operators in this section and the equality operators in the next one return &lt;code&gt;1&lt;/code&gt; for true and a special version of the defined empty string, &lt;code&gt;&quot;&quot;&lt;/code&gt; , which counts as a zero but is exempt from warnings about improper numeric conversions, just as &lt;code&gt;&quot;0 but true&quot;&lt;/code&gt; is.</source>
          <target state="translated">true 또는 false를 반환하는 Perl 연산자는 일반적으로 숫자로 안전하게 사용할 수있는 값을 반환합니다. 예를 들어,이 섹션의 관계 연산자와 다음 연산자의 항등 연산자는 true 및 정의 된 빈 문자열 &lt;code&gt;&quot;&quot;&lt;/code&gt; 의 특수 버전에 대해 &lt;code&gt;1&lt;/code&gt; 을 반환 하며, 0으로 계산되지만 부적절한 숫자 변환에 대한 경고는 제외됩니다. 로 &lt;code&gt;&quot;0 but true&quot;&lt;/code&gt; 이다.</target>
        </trans-unit>
        <trans-unit id="677a0f4b34098e3ab8a940f648ce50dea2fe1b35" translate="yes" xml:space="preserve">
          <source>Perl operators that return true or false generally return values that can be safely used as numbers. For example, the relational operators in this section and the equality operators in the next one return &lt;code&gt;1&lt;/code&gt; for true and a special version of the defined empty string, &lt;code&gt;&quot;&quot;&lt;/code&gt;, which counts as a zero but is exempt from warnings about improper numeric conversions, just as &lt;code&gt;&quot;0 but true&quot;&lt;/code&gt; is.</source>
          <target state="translated">true 또는 false를 반환하는 Perl 연산자는 일반적으로 숫자로 안전하게 사용할 수있는 값을 반환합니다. 예를 들어이 섹션의 관계 연산자와 다음 섹션의 같음 연산자는 true에 대해 &lt;code&gt;1&lt;/code&gt; 을 반환 하고 정의 된 빈 문자열 &lt;code&gt;&quot;&quot;&lt;/code&gt; 의 특수 버전은 0으로 계산되지만 부적절한 숫자 변환에 대한 경고에서 제외됩니다. 로 &lt;code&gt;&quot;0 but true&quot;&lt;/code&gt; 이다.</target>
        </trans-unit>
        <trans-unit id="93117613e1464552c05f74263a894f716b02c8a7" translate="yes" xml:space="preserve">
          <source>Perl packages may be nested inside other package names, so we can have package names containing &lt;code&gt;::&lt;/code&gt; . But if we used that package name directly as a filename it would make for unwieldy or impossible filenames on some systems. Therefore, if a module's name is, say, &lt;code&gt;Text::Soundex&lt;/code&gt; , then its definition is actually found in the library file</source>
          <target state="translated">Perl 패키지는 다른 패키지 이름 안에 중첩 될 수 있으므로 &lt;code&gt;::&lt;/code&gt; 를 포함하는 패키지 이름을 가질 수 있습니다 . 그러나 해당 패키지 이름을 파일 이름으로 직접 사용하면 일부 시스템에서 다루기 어렵거나 불가능한 파일 이름을 만들 수 있습니다. 따라서 모듈 이름이 &lt;code&gt;Text::Soundex&lt;/code&gt; 인 경우 해당 정의는 실제로 라이브러리 파일에 있습니다.</target>
        </trans-unit>
        <trans-unit id="216db03ab75c4e916969b56dae5407299d192ab7" translate="yes" xml:space="preserve">
          <source>Perl packages may be nested inside other package names, so we can have package names containing &lt;code&gt;::&lt;/code&gt;. But if we used that package name directly as a filename it would make for unwieldy or impossible filenames on some systems. Therefore, if a module's name is, say, &lt;code&gt;Text::Soundex&lt;/code&gt;, then its definition is actually found in the library file</source>
          <target state="translated">Perl 패키지는 다른 패키지 이름 안에 중첩 될 수 있으므로 &lt;code&gt;::&lt;/code&gt; 를 포함하는 패키지 이름을 가질 수 있습니다 . 그러나 패키지 이름을 파일 이름으로 직접 사용하면 일부 시스템에서 다루기 어렵거나 불가능한 파일 이름을 만들 수 있습니다. 따라서 모듈의 이름이 &lt;code&gt;Text::Soundex&lt;/code&gt; 이면 해당 정의는 실제로 라이브러리 파일에서 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="07d7fb295d5657e201671476cb88a17b37a54746" translate="yes" xml:space="preserve">
          <source>Perl pragma for deprecating the core version of a module</source>
          <target state="translated">모듈의 핵심 버전을 더 이상 사용하지 않기위한 Perl pragma</target>
        </trans-unit>
        <trans-unit id="b96fac04186779fda96ab3e9ac74bb9de167238d" translate="yes" xml:space="preserve">
          <source>Perl pragma for deprecating the inclusion of a module in core</source>
          <target state="translated">코어에 모듈을 포함하지 않기위한 Perl pragma</target>
        </trans-unit>
        <trans-unit id="4ff2d9baf63466a443978236f7b7cb1cc8bd8db5" translate="yes" xml:space="preserve">
          <source>Perl prefers to &lt;code&gt;dup&lt;/code&gt; the new low-level descriptor to the descriptor used by the existing PerlIO. This may become the behaviour of this function in the future.</source>
          <target state="translated">Perl은 새로운 저수준 디스크립터를 기존 PerlIO가 사용하는 디스크립터 로 &lt;code&gt;dup&lt;/code&gt; 하는 것을 선호합니다 . 이것은 향후이 기능의 동작이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c2ad17b9a58ab83af39d92dc2a0f734f0896297e" translate="yes" xml:space="preserve">
          <source>Perl programs are just plain text, so any editor will do.</source>
          <target state="translated">펄 프로그램은 평범한 텍스트이므로 모든 편집자가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="14cf61d2a257794aa1f24ba3ebb61b26c9fd6acc" translate="yes" xml:space="preserve">
          <source>Perl promises, that if we ever add regular expression pattern metacharacters to the dozen already defined (&lt;code&gt;\ | ( ) [ { ^ $ * + ? .&lt;/code&gt; ), that we will only use ones that have the Pattern_Syntax property. Perl also promises, that if we ever add characters that are considered to be white space in regular expressions (currently mostly affected by &lt;code&gt;/x&lt;/code&gt;), they will all have the Pattern_White_Space property.</source>
          <target state="translated">펄은 정규 표현식 패턴 메타 문자를 이미 정의 된 12 개 ( &lt;code&gt;\ | ( ) [ { ^ $ * + ? .&lt;/code&gt; ?.)에 추가하면 Pattern_Syntax 속성을 가진 문자 만 사용할 것이라고 약속했다. 또한 Perl은 정규 표현식에서 공백으로 간주되는 문자 (현재는 주로 &lt;code&gt;/x&lt;/code&gt; 의 영향을받는 문자)를 추가 하면 모두 Pattern_White_Space 특성을 갖게 된다고 약속 합니다.</target>
        </trans-unit>
        <trans-unit id="327076e1125cbcba12ce50958edba776f9d04697" translate="yes" xml:space="preserve">
          <source>Perl promises, that if we ever add regular expression pattern metacharacters to the dozen already defined (&lt;code&gt;\ | ( ) [ { ^ $ * + ? .&lt;/code&gt;), that we will only use ones that have the Pattern_Syntax property. Perl also promises, that if we ever add characters that are considered to be white space in regular expressions (currently mostly affected by &lt;code&gt;/x&lt;/code&gt;), they will all have the Pattern_White_Space property.</source>
          <target state="translated">Perl은 이미 정의 된 12 개 ( &lt;code&gt;\ | ( ) [ { ^ $ * + ? .&lt;/code&gt; ?.)에 정규식 패턴 메타 문자를 추가 하면 Pattern_Syntax 속성이있는 항목 만 사용할 것임을 약속합니다. Perl은 또한 정규 표현식에서 공백으로 간주되는 문자 (현재 대부분 &lt;code&gt;/x&lt;/code&gt; 의 영향을 받음 )를 추가하면 모두 Pattern_White_Space 속성을 갖게 될 것이라고 약속합니다.</target>
        </trans-unit>
        <trans-unit id="67b6495ec04782f446ea386cb264b80a6975aeb6" translate="yes" xml:space="preserve">
          <source>Perl provides a centralized management of these resources:</source>
          <target state="translated">Perl은 다음 리소스를 중앙 집중식으로 관리합니다.</target>
        </trans-unit>
        <trans-unit id="d5560f27b86924c423060a2b1fc2c1981aafcb97" translate="yes" xml:space="preserve">
          <source>Perl provides a fork() keyword that corresponds to the Unix system call of the same name. On most Unix-like platforms where the fork() system call is available, Perl's fork() simply calls it.</source>
          <target state="translated">Perl은 같은 이름의 Unix 시스템 호출에 해당하는 fork () 키워드를 제공합니다. fork () 시스템 호출이 가능한 대부분의 유닉스 계열 플랫폼에서 Perl의 fork ()는 간단히 호출합니다.</target>
        </trans-unit>
        <trans-unit id="de3af496d08feb146e6538a70938f9e1c88a9d41" translate="yes" xml:space="preserve">
          <source>Perl provides a mechanism for alternative namespaces to protect packages from stomping on each other's variables. In fact, there's really no such thing as a global variable in Perl. The package statement declares the compilation unit as being in the given namespace. The scope of the package declaration is from the declaration itself through the end of the enclosing block, &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;, or file, whichever comes first (the same scope as the my() and local() operators). Unqualified dynamic identifiers will be in this namespace, except for those few identifiers that if unqualified, default to the main package instead of the current one as described below. A package statement affects only dynamic variables--including those you've used local() on--but</source>
          <target state="translated">Perl은 대체 네임 스페이스가 패키지가 서로의 변수에 스톰 핑되는 것을 방지하기위한 메커니즘을 제공합니다. 실제로 Perl에는 전역 변수와 같은 것이 없습니다. package 문은 컴파일 단위를 지정된 네임 스페이스에있는 것으로 선언합니다. 패키지 선언의 범위는 선언 자체에서 둘러싸는 블록, &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 또는 파일 의 끝까지 (my () 및 local () 연산자와 동일한 범위) 중 하나입니다. 규정되지 않은 동적 식별자는 규정되지 않은 경우 아래 설명 된 현재 패키지 대신 기본 패키지로 기본 설정되는 식별자를 제외하고이 네임 스페이스에 있습니다. package 문은 local ()을 사용한 변수를 포함하여 동적 변수에만 영향을 주지만</target>
        </trans-unit>
        <trans-unit id="73112f265f6b41c74dc1c4f6ba58a9aa61493def" translate="yes" xml:space="preserve">
          <source>Perl provides a number of mechanisms to coordinate the interactions between themselves and their data, to avoid race conditions and the like. Some of these are designed to resemble the common techniques used in thread libraries such as &lt;code&gt;pthreads&lt;/code&gt; ; others are Perl-specific. Often, the standard techniques are clumsy and difficult to get right (such as condition waits). Where possible, it is usually easier to use Perlish techniques such as queues, which remove some of the hard work involved.</source>
          <target state="translated">Perl은 경쟁 조건 등을 피하기 위해 자신과 데이터 간의 상호 작용을 조정하는 여러 메커니즘을 제공합니다. 이들 중 일부는 &lt;code&gt;pthreads&lt;/code&gt; 와 같은 스레드 라이브러리에서 사용되는 일반적인 기술과 유사하게 설계되었습니다 . 다른 것은 Perl에 특정한 것입니다. 종종 표준 기술이 서투르고 제대로 이해하기가 어렵습니다 (조건 대기 등). 가능하면 일반적으로 대기열과 같은 Perlish 기술을 사용하는 것이 더 쉬워 관련 작업을 일부 제거합니다.</target>
        </trans-unit>
        <trans-unit id="2033b0d4b88c366862ed2f9bb35924fa40e4eea4" translate="yes" xml:space="preserve">
          <source>Perl provides a number of mechanisms to coordinate the interactions between themselves and their data, to avoid race conditions and the like. Some of these are designed to resemble the common techniques used in thread libraries such as &lt;code&gt;pthreads&lt;/code&gt;; others are Perl-specific. Often, the standard techniques are clumsy and difficult to get right (such as condition waits). Where possible, it is usually easier to use Perlish techniques such as queues, which remove some of the hard work involved.</source>
          <target state="translated">Perl은 경쟁 조건 등을 피하기 위해 자신과 데이터 간의 상호 작용을 조정하는 여러 메커니즘을 제공합니다. 이들 중 일부는 &lt;code&gt;pthreads&lt;/code&gt; 와 같은 스레드 라이브러리에서 사용되는 일반적인 기술과 유사하도록 설계되었습니다 . 다른 것들은 Perl 전용입니다. 종종 표준 기술은 서투르고 제대로하기가 어렵습니다 (예 : 조건 대기). 가능한 경우 일반적으로 대기열과 같은 Perlish 기술을 사용하는 것이 더 쉽습니다.이 기술은 관련된 일부 힘든 작업을 제거합니다.</target>
        </trans-unit>
        <trans-unit id="36e7e1ce7a021b749d35bdf6f3b510a2bf8dd56c" translate="yes" xml:space="preserve">
          <source>Perl provides a reasonably safe way to open a file or pipe from a setuid or setgid program: just create a child process with reduced privilege who does the dirty work for you. First, fork a child using the special &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; syntax that connects the parent and child by a pipe. Now the child resets its ID set and any other per-process attributes, like environment variables, umasks, current working directories, back to the originals or known safe values. Then the child process, which no longer has any special permissions, does the &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; or other system call. Finally, the child passes the data it managed to access back to the parent. Because the file or pipe was opened in the child while running under less privilege than the parent, it's not apt to be tricked into doing something it shouldn't.</source>
          <target state="translated">Perl은 setuid 또는 setgid 프로그램에서 파일 또는 파이프를 열 수있는 안전한 방법을 제공합니다. 더티 작업을 수행하는 권한이 감소 된 하위 프로세스 만 작성하면됩니다. 먼저 파이프로 부모와 자식을 연결하는 특수한 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; 구문을 사용하여 자식을 포크합니다 . 이제 자식은 ID 세트와 환경 변수, umask, 현재 작업 디렉토리와 같은 프로세스 별 속성을 원래 값 또는 알려진 안전한 값으로 다시 설정합니다. 그런 다음 더 이상 특별한 권한이없는 하위 프로세스는 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; 또는 다른 시스템 호출을 수행합니다. 마지막으로, 하위 항목은 액세스 한 데이터를 상위 항목으로 다시 전달합니다. 부모보다 적은 권한으로 실행되는 동안 파일이나 파이프가 자식에서 열렸으므로 원하지 않는 일을하도록 속이지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="6e7a421d4f41bbc8f45292eb6fb0c23e47fd47d6" translate="yes" xml:space="preserve">
          <source>Perl provides a reasonably safe way to open a file or pipe from a setuid or setgid program: just create a child process with reduced privilege who does the dirty work for you. First, fork a child using the special &lt;code&gt;open&lt;/code&gt; syntax that connects the parent and child by a pipe. Now the child resets its ID set and any other per-process attributes, like environment variables, umasks, current working directories, back to the originals or known safe values. Then the child process, which no longer has any special permissions, does the &lt;code&gt;open&lt;/code&gt; or other system call. Finally, the child passes the data it managed to access back to the parent. Because the file or pipe was opened in the child while running under less privilege than the parent, it's not apt to be tricked into doing something it shouldn't.</source>
          <target state="translated">Perl은 setuid 또는 setgid 프로그램에서 파일이나 파이프를 여는 합리적으로 안전한 방법을 제공합니다. 사용자를 위해 더러운 작업을 수행하는 권한이 감소 된 자식 프로세스를 생성하기 만하면됩니다. 먼저, 파이프로 부모와 자식을 연결하는 특별한 &lt;code&gt;open&lt;/code&gt; 구문을 사용하여 자식을 포크합니다 . 이제 자식은 ID 세트와 환경 변수, umasks, 현재 작업 디렉토리와 같은 기타 프로세스 별 속성을 원래 값이나 알려진 안전한 값으로 다시 설정합니다. 그런 다음 더 이상 특별한 권한이없는 자식 프로세스가 &lt;code&gt;open&lt;/code&gt; 또는 다른 시스템 호출을 수행합니다. 마지막으로 자식은 액세스 할 수있는 데이터를 부모에게 다시 전달합니다. 파일이나 파이프가 부모보다 낮은 권한으로 실행되는 동안 자식에서 열렸 기 때문에,해서는 안되는 일을하도록 속이는 경향이 없습니다.</target>
        </trans-unit>
        <trans-unit id="01b6956704a1caccc5f1a829b2f6df16370a9f29" translate="yes" xml:space="preserve">
          <source>Perl provides many macros to assist in accessing the Perl stack. Wherever possible, these macros should always be used when interfacing to Perl internals. We hope this should make the code less vulnerable to any changes made to Perl in the future.</source>
          <target state="translated">Perl은 Perl 스택에 액세스하는 데 도움이되는 많은 매크로를 제공합니다. 가능하면이 매크로는 Perl 내부와 인터페이스 할 때 항상 사용해야합니다. 앞으로이 코드가 Perl의 변경 사항에 덜 취약 해지기를 바랍니다.</target>
        </trans-unit>
        <trans-unit id="8d83d3e4ff54e649960458ab09222a8186178865" translate="yes" xml:space="preserve">
          <source>Perl provides the function &lt;code&gt;sv_chop&lt;/code&gt; to efficiently remove characters from the beginning of a string; you give it an SV and a pointer to somewhere inside the PV, and it discards everything before the pointer. The efficiency comes by means of a little hack: instead of actually removing the characters, &lt;code&gt;sv_chop&lt;/code&gt; sets the flag &lt;code&gt;OOK&lt;/code&gt; (offset OK) to signal to other functions that the offset hack is in effect, and it moves the PV pointer (called &lt;code&gt;SvPVX&lt;/code&gt; ) forward by the number of bytes chopped off, and adjusts &lt;code&gt;SvCUR&lt;/code&gt; and &lt;code&gt;SvLEN&lt;/code&gt; accordingly. (A portion of the space between the old and new PV pointers is used to store the count of chopped bytes.)</source>
          <target state="translated">Perl은 &lt;code&gt;sv_chop&lt;/code&gt; 함수를 제공하여 문자열의 시작 부분에서 문자를 효율적으로 제거합니다. SV와 PV 내부 어딘가에 대한 포인터를 제공하고 포인터 앞의 모든 것을 버립니다. 효율성은 약간의 해킹을 통해 발생합니다. 실제로 문자를 제거하는 대신 &lt;code&gt;sv_chop&lt;/code&gt; 은 오프셋 해킹이 유효한 다른 기능에 신호를 보내 도록 플래그 &lt;code&gt;OOK&lt;/code&gt; (offset OK)를 설정하고 PV 포인터 ( &lt;code&gt;SvPVX&lt;/code&gt; )를 앞으로 이동시킵니다. 잘린 바이트 수만큼 &lt;code&gt;SvCUR&lt;/code&gt; 및 &lt;code&gt;SvLEN&lt;/code&gt; 을 조정합니다 . (이전 PV 포인터와 새 PV 포인터 사이의 공간 부분은 다진 바이트 수를 저장하는 데 사용됩니다.)</target>
        </trans-unit>
        <trans-unit id="6f5d51550851e99636a22add4af85faee83cebcf" translate="yes" xml:space="preserve">
          <source>Perl provides the function &lt;code&gt;sv_chop&lt;/code&gt; to efficiently remove characters from the beginning of a string; you give it an SV and a pointer to somewhere inside the PV, and it discards everything before the pointer. The efficiency comes by means of a little hack: instead of actually removing the characters, &lt;code&gt;sv_chop&lt;/code&gt; sets the flag &lt;code&gt;OOK&lt;/code&gt; (offset OK) to signal to other functions that the offset hack is in effect, and it moves the PV pointer (called &lt;code&gt;SvPVX&lt;/code&gt;) forward by the number of bytes chopped off, and adjusts &lt;code&gt;SvCUR&lt;/code&gt; and &lt;code&gt;SvLEN&lt;/code&gt; accordingly. (A portion of the space between the old and new PV pointers is used to store the count of chopped bytes.)</source>
          <target state="translated">Perl은 &lt;code&gt;sv_chop&lt;/code&gt; 함수를 제공하여 문자열 시작 부분에서 문자를 효율적으로 제거합니다. SV와 PV 내부 어딘가에 대한 포인터를 제공하면 포인터 앞의 모든 것을 버립니다. 효율성은 약간의 해킹을 통해 제공됩니다. 실제로 문자를 제거하는 대신 &lt;code&gt;sv_chop&lt;/code&gt; 는 오프셋 해킹이 적용되고 있음을 다른 기능에 알리기 위해 플래그 &lt;code&gt;OOK&lt;/code&gt; (오프셋 OK)을 설정하고 PV 포인터 ( &lt;code&gt;SvPVX&lt;/code&gt; 라고 함 )를 앞으로 이동합니다. &lt;code&gt;SvCUR&lt;/code&gt; 바이트 수에 따라 SvCUR 및 &lt;code&gt;SvLEN&lt;/code&gt; 을 조정합니다 . (이전 PV 포인터와 새 PV 포인터 사이의 공간 일부는 잘린 바이트 수를 저장하는 데 사용됩니다.)</target>
        </trans-unit>
        <trans-unit id="5b8c268aa39a037e84e8a60b81c199fef5923af6" translate="yes" xml:space="preserve">
          <source>Perl provides two API functions to evaluate pieces of Perl code. These are &lt;a href=&quot;perlapi#eval_sv&quot;&gt;&quot;eval_sv&quot; in perlapi&lt;/a&gt; and &lt;a href=&quot;perlapi#eval_pv&quot;&gt;&quot;eval_pv&quot; in perlapi&lt;/a&gt;.</source>
          <target state="translated">Perl은 Perl 코드 조각을 평가하기 위해 두 가지 API 함수를 제공합니다. 이들은 &lt;a href=&quot;perlapi#eval_sv&quot;&gt;perlapi에서 &quot;eval_sv&quot;&lt;/a&gt; 와 &lt;a href=&quot;perlapi#eval_pv&quot;&gt;perlapi에서 &quot;eval_pv&quot;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9513d1ec6023b878e1b94840b432efff780b52df" translate="yes" xml:space="preserve">
          <source>Perl provides two API functions to evaluate pieces of Perl code. These are &lt;a href=&quot;perlapi#eval_sv&quot;&gt;eval_sv in perlapi&lt;/a&gt; and &lt;a href=&quot;perlapi#eval_pv&quot;&gt;eval_pv in perlapi&lt;/a&gt;.</source>
          <target state="translated">Perl은 Perl 코드를 평가하는 두 가지 API 함수를 제공합니다. 이들은 &lt;a href=&quot;perlapi#eval_sv&quot;&gt;perlapi의 eval_sv&lt;/a&gt; 이고 &lt;a href=&quot;perlapi#eval_pv&quot;&gt;perlapi의 eval_pv&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="ffb39ca049ef57e14f57d4751c1d1ac0f78a02d5" translate="yes" xml:space="preserve">
          <source>Perl recognizes the POSIX character classes &lt;code&gt;[=class=]&lt;/code&gt; and &lt;code&gt;[.class.]&lt;/code&gt;, but does not (yet?) support them. Any attempt to use either construct raises an exception.</source>
          <target state="translated">Perl은 POSIX 문자 클래스 &lt;code&gt;[=class=]&lt;/code&gt; 및 &lt;code&gt;[.class.]&lt;/code&gt; 를 인식하지만 (아직?) 지원하지 않습니다. 두 구문 중 하나를 사용하려고하면 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="07f5219960a6f7bb8d18294a65d8b9d67281a7a2" translate="yes" xml:space="preserve">
          <source>Perl recognizes the following POSIX character classes:</source>
          <target state="translated">Perl은 다음 POSIX 문자 클래스를 인식합니다.</target>
        </trans-unit>
        <trans-unit id="d60612137eda4aa3ff39ca1a5e535cbfedf6b435" translate="yes" xml:space="preserve">
          <source>Perl regexps also support backreferences, lookaheads, and all kinds of other complex details. Read all about them in &lt;a href=&quot;perlrequick&quot;&gt;perlrequick&lt;/a&gt;, &lt;a href=&quot;perlretut&quot;&gt;perlretut&lt;/a&gt;, and &lt;a href=&quot;perlre&quot;&gt;perlre&lt;/a&gt;.</source>
          <target state="translated">Perl 정규 표현식은 역 참조, 미리보기 및 모든 종류의 복잡한 세부 사항도 지원합니다. &lt;a href=&quot;perlrequick&quot;&gt;perlrequick&lt;/a&gt; , &lt;a href=&quot;perlretut&quot;&gt;perlretut&lt;/a&gt; 및 &lt;a href=&quot;perlre&quot;&gt;perlre&lt;/a&gt; 에서 이들에 대한 모든 내용을 읽으십시오 .</target>
        </trans-unit>
        <trans-unit id="aa3e77c17de568fb7fabddc21617e1e18fce47ab" translate="yes" xml:space="preserve">
          <source>Perl regexps can handle more than just the standard ASCII character set. Perl supports</source>
          <target state="translated">Perl regexp는 표준 ASCII 문자 세트 이상을 처리 할 수 ​​있습니다. 펄 지원</target>
        </trans-unit>
        <trans-unit id="d440475b129d32904159fb94e727dbef0d4e25d9" translate="yes" xml:space="preserve">
          <source>Perl regular expressions have a large range of character classes. Some of the character classes are written as a backslash sequence. We will briefly discuss those here; full details of character classes can be found in &lt;a href=&quot;perlrecharclass&quot;&gt;perlrecharclass&lt;/a&gt;.</source>
          <target state="translated">Perl 정규 표현식에는 다양한 문자 클래스가 있습니다. 문자 클래스 중 일부는 백 슬래시 시퀀스로 작성됩니다. 우리는 여기서 그것들에 대해 간단히 논의 할 것입니다. 문자 클래스의 전체 세부 사항은 &lt;a href=&quot;perlrecharclass&quot;&gt;perlrecharclass&lt;/a&gt; 에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8ae626456b6ab696d8a1f8c512b2605f948687bc" translate="yes" xml:space="preserve">
          <source>Perl relies on the underlying system for the implementation of &lt;code&gt;&lt;a href=&quot;functions/rand&quot;&gt;rand&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/srand&quot;&gt;srand&lt;/a&gt;&lt;/code&gt;; on some systems, the generated numbers are not random enough (especially on Windows : see &lt;a href=&quot;http://www.perlmonks.org/?node_id=803632&quot;&gt;http://www.perlmonks.org/?node_id=803632&lt;/a&gt;). Several CPAN modules in the &lt;code&gt;Math&lt;/code&gt; namespace implement better pseudorandom generators; see for example &lt;a href=&quot;http://search.cpan.org/perldoc/Math::Random::MT&quot;&gt;Math::Random::MT&lt;/a&gt; (&quot;Mersenne Twister&quot;, fast), or &lt;a href=&quot;http://search.cpan.org/perldoc/Math::TrulyRandom&quot;&gt;Math::TrulyRandom&lt;/a&gt; (uses the imperfections in the system's timer to generate random numbers, which is rather slow). More algorithms for random numbers are described in &quot;Numerical Recipes in C&quot; at &lt;a href=&quot;http://www.nr.com/&quot;&gt;http://www.nr.com/&lt;/a&gt;</source>
          <target state="translated">Perl은 &lt;code&gt;&lt;a href=&quot;functions/rand&quot;&gt;rand&lt;/a&gt;&lt;/code&gt; 와 &lt;code&gt;&lt;a href=&quot;functions/srand&quot;&gt;srand&lt;/a&gt;&lt;/code&gt; 의 구현을 위해 기본 시스템에 의존합니다 . 일부 시스템에서는 생성 된 숫자가 충분히 임의적이지 않습니다 (특히 Windows : &lt;a href=&quot;http://www.perlmonks.org/?node_id=803632&quot;&gt;http://www.perlmonks.org/?node_id=803632 참조&lt;/a&gt; ). &lt;code&gt;Math&lt;/code&gt; 네임 스페이스 의 여러 CPAN 모듈은 더 나은 의사 난수 생성기를 구현합니다. 예를 들어 &lt;a href=&quot;http://search.cpan.org/perldoc/Math::Random::MT&quot;&gt;Math :: Random :: MT&lt;/a&gt; ( &quot;Mersenne Twister&quot;, fast) 또는 &lt;a href=&quot;http://search.cpan.org/perldoc/Math::TrulyRandom&quot;&gt;Math :: TrulyRandom&lt;/a&gt; (시스템 타이머의 결함을 사용하여 임의의 숫자를 생성하므로 다소 느림)을 참조하십시오. 난수에 대한 더 많은 알고리즘은 &lt;a href=&quot;http://www.nr.com/&quot;&gt;http://www.nr.com/의&lt;/a&gt; &quot;C의 수치 레시피&quot;에 설명되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3f12ff9832e26034f1b71096dd8784c68818bdcd" translate="yes" xml:space="preserve">
          <source>Perl relies on the underlying system for the implementation of &lt;code&gt;rand&lt;/code&gt; and &lt;code&gt;srand&lt;/code&gt;; on some systems, the generated numbers are not random enough (especially on Windows : see &lt;a href=&quot;http://www.perlmonks.org/?node_id=803632&quot;&gt;http://www.perlmonks.org/?node_id=803632&lt;/a&gt;). Several CPAN modules in the &lt;code&gt;Math&lt;/code&gt; namespace implement better pseudorandom generators; see for example &lt;a href=&quot;Math::Random::MT&quot;&gt;Math::Random::MT&lt;/a&gt; (&quot;Mersenne Twister&quot;, fast), or &lt;a href=&quot;Math::TrulyRandom&quot;&gt;Math::TrulyRandom&lt;/a&gt; (uses the imperfections in the system's timer to generate random numbers, which is rather slow). More algorithms for random numbers are described in &quot;Numerical Recipes in C&quot; at &lt;a href=&quot;http://www.nr.com/&quot;&gt;http://www.nr.com/&lt;/a&gt;</source>
          <target state="translated">Perl은 &lt;code&gt;rand&lt;/code&gt; 및 &lt;code&gt;srand&lt;/code&gt; 구현을 위해 기본 시스템에 의존합니다 . 일부 시스템에서는 생성 된 숫자가 충분히 무작위가 아닙니다 (특히 Windows의 경우 : &lt;a href=&quot;http://www.perlmonks.org/?node_id=803632&quot;&gt;http://www.perlmonks.org/?node_id=803632 참조&lt;/a&gt; ). &lt;code&gt;Math&lt;/code&gt; 네임 스페이스 의 여러 CPAN 모듈은 더 나은 의사 난수 생성기를 구현합니다. 예를 들어 &lt;a href=&quot;Math::Random::MT&quot;&gt;Math :: Random :: MT&lt;/a&gt; ( &quot;Mersenne Twister&quot;, fast) 또는 &lt;a href=&quot;Math::TrulyRandom&quot;&gt;Math :: TrulyRandom&lt;/a&gt; (시스템 타이머의 결함을 사용하여 난수를 생성하므로 다소 느림)을 참조하십시오. 난수에 대한 더 많은 알고리즘은 &lt;a href=&quot;http://www.nr.com/&quot;&gt;http://www.nr.com/의&lt;/a&gt; &quot;Numerical Recipes in C&quot;에 설명되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5e8b101afd4e3699b22d8dd044a2afe59a2e5739" translate="yes" xml:space="preserve">
          <source>Perl requires braces following &lt;code&gt;if&lt;/code&gt; , &lt;code&gt;while&lt;/code&gt; , &lt;code&gt;foreach&lt;/code&gt; , etc.</source>
          <target state="translated">Perl은 &lt;code&gt;if&lt;/code&gt; , &lt;code&gt;while&lt;/code&gt; , &lt;code&gt;foreach&lt;/code&gt; 등 을 따르는 중괄호가 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="da6e3123b7e4ffb6fc9eae18f7c7e43c09ee3028" translate="yes" xml:space="preserve">
          <source>Perl requires braces following &lt;code&gt;if&lt;/code&gt;, &lt;code&gt;while&lt;/code&gt;, &lt;code&gt;foreach&lt;/code&gt;, etc.</source>
          <target state="translated">Perl은 &lt;code&gt;if&lt;/code&gt; , &lt;code&gt;while&lt;/code&gt; , &lt;code&gt;foreach&lt;/code&gt; 등의 뒤에 중괄호가 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="baeb92759bd60617241bdfef388270964c6488e2" translate="yes" xml:space="preserve">
          <source>Perl requires semicolons to separate statements.</source>
          <target state="translated">펄은 문장을 분리하기 위해 세미콜론이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="e643a23b551f0082edc8c39f350e57fa7da27bfb" translate="yes" xml:space="preserve">
          <source>Perl resolves this dilemma by transparently calling a copy constructor before calling a method defined to implement a mutator (&lt;code&gt;--&lt;/code&gt; , &lt;code&gt;+=&lt;/code&gt; , and so on.). In the above example, when Perl reaches the decrement statement, it makes a copy of the object data in &lt;code&gt;$a&lt;/code&gt; and assigns to &lt;code&gt;$a&lt;/code&gt; a reference to the copied data. Only then does it call &lt;code&gt;decr()&lt;/code&gt; , which alters the copied data, leaving &lt;code&gt;$b&lt;/code&gt; unchanged. Thus the object metaphor is preserved as far as possible, while mathemagical operations still work according to the arithmetic metaphor.</source>
          <target state="translated">Perl은 뮤 테이터 ( &lt;code&gt;--&lt;/code&gt; , &lt;code&gt;+=&lt;/code&gt; 등) 를 구현하도록 정의 된 메소드를 호출하기 전에 복사 생성자를 투명하게 호출하여이 딜레마를 해결합니다 . 위의 예에서 Perl이 decrement 문에 도달하면 &lt;code&gt;$a&lt;/code&gt; 의 오브젝트 데이터 사본을 작성하고 &lt;code&gt;$a&lt;/code&gt; 에 복사 된 데이터에 대한 참조를 지정합니다 . 그런 다음에 만 &lt;code&gt;decr()&lt;/code&gt; 호출 하여 복사 된 데이터를 변경하고 &lt;code&gt;$b&lt;/code&gt; 변경하지 않습니다. 따라서 수학 은유는 산술 은유에 따라 여전히 작동하면서 객체 은유는 가능한 한 보존됩니다.</target>
        </trans-unit>
        <trans-unit id="1602dd24bebfca9ce4871cb5fb94135e37cae349" translate="yes" xml:space="preserve">
          <source>Perl resolves this dilemma by transparently calling a copy constructor before calling a method defined to implement a mutator (&lt;code&gt;--&lt;/code&gt;, &lt;code&gt;+=&lt;/code&gt;, and so on.). In the above example, when Perl reaches the decrement statement, it makes a copy of the object data in &lt;code&gt;$a&lt;/code&gt; and assigns to &lt;code&gt;$a&lt;/code&gt; a reference to the copied data. Only then does it call &lt;code&gt;decr()&lt;/code&gt;, which alters the copied data, leaving &lt;code&gt;$b&lt;/code&gt; unchanged. Thus the object metaphor is preserved as far as possible, while mathemagical operations still work according to the arithmetic metaphor.</source>
          <target state="translated">Perl은 뮤 테이터 ( &lt;code&gt;--&lt;/code&gt; , &lt;code&gt;+=&lt;/code&gt; 등) 를 구현하도록 정의 된 메서드를 호출하기 전에 복사 생성자를 투명하게 호출하여이 딜레마를 해결합니다 . 위의 예에서 Perl이 decrement 문에 도달하면 &lt;code&gt;$a&lt;/code&gt; 에있는 개체 데이터의 복사본 을 만들고 복사 된 데이터에 대한 참조를 &lt;code&gt;$a&lt;/code&gt; 할당합니다 . 그런 다음에 만 &lt;code&gt;decr()&lt;/code&gt; 호출 하여 복사 된 데이터를 변경하고 &lt;code&gt;$b&lt;/code&gt; 변경하지 않습니다. 따라서 대상 은유는 가능한 한 보존되지만 수학 연산은 여전히 ​​산술 은유에 따라 작동합니다.</target>
        </trans-unit>
        <trans-unit id="e718ff2371b8bf00697a05f6ee1339b450bff042" translate="yes" xml:space="preserve">
          <source>Perl runs &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; statement at run-time. Once Perl loads, compiles, and runs the file, it doesn't do anything else. The &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; statement is the same as a &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; run at compile-time, but Perl also calls the &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; method for the loaded package. These two are the same:</source>
          <target state="translated">Perl 실행 &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; 런타임시 명령문 이 필요 합니다. Perl이 파일을로드, 컴파일 및 실행 한 후에는 다른 작업을 수행하지 않습니다. &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 문은 동일하다 &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; 컴파일 시간에 실행하지만, 펄도 호출 &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; 로드 패키지에 대한 방법을. 이 두 가지는 동일합니다.</target>
        </trans-unit>
        <trans-unit id="98f089278b6995b15f2d41746ee27d2688f96f52" translate="yes" xml:space="preserve">
          <source>Perl runs &lt;code&gt;require&lt;/code&gt; statement at run-time. Once Perl loads, compiles, and runs the file, it doesn't do anything else. The &lt;code&gt;use&lt;/code&gt; statement is the same as a &lt;code&gt;require&lt;/code&gt; run at compile-time, but Perl also calls the &lt;code&gt;import&lt;/code&gt; method for the loaded package. These two are the same:</source>
          <target state="translated">Perl 실행 &lt;code&gt;require&lt;/code&gt; 런타임에 문 이 필요 합니다. Perl이 파일을로드, 컴파일 및 실행하면 다른 작업을 수행하지 않습니다. &lt;code&gt;use&lt;/code&gt; 문은 동일하다 &lt;code&gt;require&lt;/code&gt; 컴파일 시간에 실행하지만, 펄도 호출 &lt;code&gt;import&lt;/code&gt; 로드 패키지에 대한 방법을. 이 두 가지는 동일합니다.</target>
        </trans-unit>
        <trans-unit id="49c228222cbce8f7e3a32ff65352e2b7ebaf362f" translate="yes" xml:space="preserve">
          <source>Perl runs on e-mail; there is no doubt about it. The Camel book was originally written mostly over e-mail and today Perl's development is co-ordinated through mailing lists. The largest repository of Perl mailing lists is located at &lt;a href=&quot;http://lists.perl.org&quot;&gt;http://lists.perl.org&lt;/a&gt;.</source>
          <target state="translated">Perl은 전자 메일로 실행됩니다. 의심의 여지가 없습니다. Camel 책은 원래 전자 우편으로 작성되었으며 오늘날 Perl의 개발은 메일 링리스트를 통해 조정됩니다. Perl 메일 링리스트의 가장 큰 저장소는 &lt;a href=&quot;http://lists.perl.org&quot;&gt;http://lists.perl.org에&lt;/a&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="61dbd8b3aa941e2fad4e470525c952ecca2fe9ad" translate="yes" xml:space="preserve">
          <source>Perl runs on numerous operating systems. While most of them share much in common, they also have their own unique features.</source>
          <target state="translated">Perl은 수많은 운영 체제에서 실행됩니다. 대부분은 공통점이 많지만 고유 한 기능도 있습니다.</target>
        </trans-unit>
        <trans-unit id="421935f6afff0e32fa7e44f720a70058704e68f6" translate="yes" xml:space="preserve">
          <source>Perl runs under Unix Systems Services or USS.</source>
          <target state="translated">Perl은 Unix Systems Services 또는 USS에서 운영됩니다.</target>
        </trans-unit>
        <trans-unit id="e81d373d15ca40f4e59a6d6a3f7cafb56ab9ed4a" translate="yes" xml:space="preserve">
          <source>Perl scripts on UNIX use the &quot;#!&quot; (a.k.a &quot;shebang&quot;) line to indicate to the OS that it should execute the file using perl. Windows has no comparable means to indicate arbitrary files are executables.</source>
          <target state="translated">UNIX의 Perl 스크립트는 &quot;#!&quot;를 사용합니다. (일명 &quot;shebang&quot;) 행은 OS에 perl을 사용하여 파일을 실행해야 함을 나타냅니다. Windows는 임의의 파일이 실행 가능하다는 것을 나타내는 비슷한 수단이 없습니다.</target>
        </trans-unit>
        <trans-unit id="c4939ec259a60d684db202bce3bcf1de4f358448" translate="yes" xml:space="preserve">
          <source>Perl seems to allow out-of-range values (greater than 0x10FFFF). By default, out-of-range values are replaced with &lt;code&gt;U+FFFD&lt;/code&gt; (REPLACEMENT CHARACTER) when &lt;code&gt;UCA_Version&lt;/code&gt; &amp;gt;= 22, or ignored when &lt;code&gt;UCA_Version&lt;/code&gt; &amp;lt;= 20.</source>
          <target state="translated">Perl은 범위를 벗어난 값 (0x10FFFF보다 큼)을 허용하는 것 같습니다. 기본적으로 범위를 벗어난 값은 &lt;code&gt;UCA_Version&lt;/code&gt; &amp;gt; = 22 인 경우 &lt;code&gt;U+FFFD&lt;/code&gt; (REPLACEMENT CHARACTER) 로 대체 되거나 &lt;code&gt;UCA_Version&lt;/code&gt; &amp;lt;= 20 인 경우 무시됩니다 .</target>
        </trans-unit>
        <trans-unit id="f744319952a7a0f61ea238f46c893e99d13a8174" translate="yes" xml:space="preserve">
          <source>Perl should now build using the win32/Makefile. You will need to edit that file to set</source>
          <target state="translated">Perl은 이제 win32 / Makefile을 사용하여 빌드해야합니다. 설정하려면 해당 파일을 편집해야합니다</target>
        </trans-unit>
        <trans-unit id="a14edbe542c4c995c5b37c95f6789009c27399cc" translate="yes" xml:space="preserve">
          <source>Perl should now build using the win32/Makefile. You will need to edit that file to set CCTYPE to one of MSVC90-MSVC142 first.</source>
          <target state="translated">Perl은 이제 win32 / Makefile을 사용하여 빌드해야합니다. 먼저 해당 파일을 편집하여 CCTYPE을 MSVC90-MSVC142 중 하나로 설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="cb621d78e2af41af5785030c0b682152fd53b938" translate="yes" xml:space="preserve">
          <source>Perl should now build using the win32/Makefile. You will need to edit that file to set CCTYPE to one of MSVC90FREE-MSVC120FREE first.</source>
          <target state="translated">Perl은 이제 win32 / Makefile을 사용하여 빌드해야합니다. CCTYPE을 MSVC90FREE-MSVC120FREE 중 하나로 설정하려면 해당 파일을 편집해야합니다.</target>
        </trans-unit>
        <trans-unit id="0ddc1cc89c294f8f7ab11f0687f3217bbc182d09" translate="yes" xml:space="preserve">
          <source>Perl should remain one language, rather than forking into a byte-oriented Perl and a character-oriented Perl.</source>
          <target state="translated">Perl은 바이트 지향 Perl과 문자 지향 Perl로 분기하지 않고 하나의 언어로 남아 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="c5c49b8b94391dce923175d25bc4e1e360818232" translate="yes" xml:space="preserve">
          <source>Perl source plays by ANSI C89 rules: no C99 (or C++) extensions. In some cases we have to take pre-ANSI requirements into consideration. You don't care about some particular platform having broken Perl? I hear there is still a strong demand for J2EE programmers.</source>
          <target state="translated">Perl 소스는 ANSI C89 규칙에 따라 재생됩니다. C99 (또는 C ++) 확장은 없습니다. 경우에 따라 ANSI 이전의 요구 사항을 고려해야합니다. 펄이 고장난 특정 플랫폼에 신경 쓰지 않습니까? J2EE 프로그래머에 대한 수요가 여전히 높다고 들었습니다.</target>
        </trans-unit>
        <trans-unit id="50695da7bf648a9c3f976331e85b8f6be17c044c" translate="yes" xml:space="preserve">
          <source>Perl source plays by ANSI C89 rules: no C99 (or C++) extensions. You don't care about some particular platform having broken Perl? I hear there is still a strong demand for J2EE programmers.</source>
          <target state="translated">Perl 소스는 ANSI C89 규칙에 따라 재생됩니다. C99 (또는 C ++) 확장은 없습니다. Perl을 망가 뜨린 특정 플랫폼에 신경 쓰지 않습니까? J2EE 프로그래머에 대한 수요가 여전히 높다고 들었습니다.</target>
        </trans-unit>
        <trans-unit id="912bb016153409bf0daae81d17c059280f97296b" translate="yes" xml:space="preserve">
          <source>Perl stack pointer), and in the handling of data on the stack when returning from an XSUB. In CODE: sections SP preserves the value which was on entry to the XSUB: SP is on the function pointer (which follows the last parameter). In PPCODE: sections SP is moved backward to the beginning of the parameter list, which allows &lt;code&gt;PUSH*()&lt;/code&gt; macros to place output values in the place Perl expects them to be when the XSUB returns back to Perl.</source>
          <target state="translated">Perl 스택 포인터) 및 XSUB에서 돌아올 때 스택의 데이터 처리 CODE : 섹션에서 SP는 XSUB에 입력 된 값을 유지합니다. SP는 함수 포인터에 있습니다 (마지막 매개 변수 뒤에옵니다). PPCODE에서 : 섹션 SP는 매개 변수 목록의 시작 부분으로 뒤로 이동하여 &lt;code&gt;PUSH*()&lt;/code&gt; 매크로가 XSUB가 다시 Perl로 돌아올 때 예상되는 위치에 Perl이 출력 값을 배치 할 수 있도록합니다.</target>
        </trans-unit>
        <trans-unit id="c5c35727bb235feb64e08f5a4e4d865a3344d69d" translate="yes" xml:space="preserve">
          <source>Perl starts scripts which begin with cookies &lt;code&gt;extproc&lt;/code&gt; or &lt;code&gt;#!&lt;/code&gt; directly, without an intervention of shell. Perl uses the same algorithm to find the executable as</source>
          <target state="translated">Perl은 쿠키 &lt;code&gt;extproc&lt;/code&gt; 또는 &lt;code&gt;#!&lt;/code&gt; 으로 시작하는 스크립트를 시작합니다 . 쉘의 개입없이 직접. Perl은 동일한 알고리즘을 사용하여 실행 파일을 찾습니다.</target>
        </trans-unit>
        <trans-unit id="311066088c9b05b3123661ea7b3305044bcd0edf" translate="yes" xml:space="preserve">
          <source>Perl statements end in a semi-colon:</source>
          <target state="translated">펄 문장은 세미콜론으로 끝납니다 :</target>
        </trans-unit>
        <trans-unit id="085142f041ce2e9d800b457019222a09cb16a58b" translate="yes" xml:space="preserve">
          <source>Perl strings are NOT the same as C strings: They may contain &lt;code&gt;NUL&lt;/code&gt; characters, whereas a C string is terminated by the first &lt;code&gt;NUL&lt;/code&gt;. That is why Perl API functions that deal with strings generally take a pointer to the first byte and either a length or a pointer to the byte just beyond the final one.</source>
          <target state="translated">Perl 문자열은 C 문자열과 동일하지 않습니다. &lt;code&gt;NUL&lt;/code&gt; 문자를 포함 할 수있는 반면 C 문자열은 첫 번째 &lt;code&gt;NUL&lt;/code&gt; 로 종료됩니다 . 그렇기 때문에 문자열을 처리하는 Perl API 함수는 일반적으로 첫 번째 바이트에 대한 포인터와 최종 바이트 바로 너머의 바이트에 대한 길이 또는 포인터를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="a3110ac0fdedcb6602950b25f9e6691154e84e0e" translate="yes" xml:space="preserve">
          <source>Perl supports Unicode strings as of version 5.6. Such strings may contain wide characters, namely, characters whose ordinal values are greater than 255. This can cause problems for digest algorithms such as SHA that are specified to operate on sequences of bytes.</source>
          <target state="translated">Perl은 버전 5.6부터 유니 코드 문자열을 지원합니다. 이러한 문자열에는 넓은 문자, 즉 서수 값이 255보다 큰 문자가 포함될 수 있습니다. 이로 인해 바이트 시퀀스에서 작동하도록 지정된 SHA와 같은 다이제스트 알고리즘에 문제가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a81cbe4ac67faced842394ca9c16af6e77feb312" translate="yes" xml:space="preserve">
          <source>Perl supports a type of threads called interpreter threads (ithreads). These threads can be used explicitly and implicitly.</source>
          <target state="translated">Perl은 인터프리터 스레드 (ithread)라고하는 스레드 유형을 지원합니다. 이 스레드는 명시 적 및 암시 적으로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b3ddd3f5c1d03839d509e6149edea808fc6cb5cb" translate="yes" xml:space="preserve">
          <source>Perl supports a very limited kind of compile-time argument checking using function prototyping. This can be declared in either the PROTO section or with a &lt;a href=&quot;attributes#Built-in-Attributes&quot;&gt;prototype attribute&lt;/a&gt;. If you declare either of</source>
          <target state="translated">Perl은 함수 프로토 타이핑을 사용하여 매우 제한된 종류의 컴파일 타임 인수 검사를 지원합니다. 이것은 PROTO 섹션 또는 &lt;a href=&quot;attributes#Built-in-Attributes&quot;&gt;프로토 타입 속성&lt;/a&gt; 으로 선언 될 수 있습니다 . 다음 중 하나를 선언하면</target>
        </trans-unit>
        <trans-unit id="4e581f21aad5ef67a96d247b183e3193eac70dc7" translate="yes" xml:space="preserve">
          <source>Perl supports another method invocation syntax called &quot;indirect object&quot; notation. This syntax is called &quot;indirect&quot; because the method comes before the object it is being invoked on.</source>
          <target state="translated">Perl은 &quot;간접 객체&quot;표기법이라는 다른 메소드 호출 구문을 지원합니다. 이 구문은 &quot;간접&quot;이라고합니다. 메소드가 호출되는 오브젝트보다 먼저 나오기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="455d7ce007e3563f3b515c14c6a68c715a128b3e" translate="yes" xml:space="preserve">
          <source>Perl supports both pre-5.6 strings of eight-bit native bytes, and strings of Unicode characters. The general principle is that Perl tries to keep its data as eight-bit bytes for as long as possible, but as soon as Unicodeness cannot be avoided, the data is transparently upgraded to Unicode. Prior to Perl v5.14.0, the upgrade was not completely transparent (see &lt;a href=&quot;perlunicode#The-%22Unicode-Bug%22&quot;&gt;&quot;The &quot;Unicode Bug&quot;&quot; in perlunicode&lt;/a&gt;), and for backwards compatibility, full transparency is not gained unless &lt;code&gt;use feature 'unicode_strings'&lt;/code&gt; (see &lt;a href=&quot;feature&quot;&gt;feature&lt;/a&gt;) or &lt;code&gt;use 5.012&lt;/code&gt; (or higher) is selected.</source>
          <target state="translated">Perl은 8 비트 네이티브 바이트의 5.6 이전 문자열과 유니 코드 문자의 문자열을 모두 지원합니다. 일반적인 원칙은 Perl이 데이터를 가능한 한 8 비트 바이트로 유지하려고하지만 유니 코드 성을 피할 수없는 즉시 데이터가 유니 코드로 투명하게 업그레이드된다는 것입니다. Perl v5.14.0 이전에는 업그레이드가 완전히 투명하지 않았으며 (perlunicode의 &lt;a href=&quot;perlunicode#The-%22Unicode-Bug%22&quot;&gt;&quot;The&quot;Unicode Bug &quot;&quot;참조&lt;/a&gt; ) 이전 버전과의 호환성을 위해 &lt;code&gt;use feature 'unicode_strings'&lt;/code&gt; &lt;a href=&quot;feature&quot;&gt;기능&lt;/a&gt; ( feature 참조 )을 &lt;code&gt;use 5.012&lt;/code&gt; 하거나 5.012 ( 이상)이 선택됩니다.</target>
        </trans-unit>
        <trans-unit id="265dfd10b5f2d39d276f9f524b9c6e80cdea3f6c" translate="yes" xml:space="preserve">
          <source>Perl supports both pre-5.6 strings of eight-bit native bytes, and strings of Unicode characters. The general principle is that Perl tries to keep its data as eight-bit bytes for as long as possible, but as soon as Unicodeness cannot be avoided, the data is transparently upgraded to Unicode. Prior to Perl v5.14.0, the upgrade was not completely transparent (see &lt;a href=&quot;perlunicode#The-%22Unicode-Bug%22&quot;&gt;The Unicode Bug in perlunicode&lt;/a&gt;), and for backwards compatibility, full transparency is not gained unless &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature
'unicode_strings'&lt;/code&gt; (see &lt;a href=&quot;feature&quot;&gt;feature&lt;/a&gt;) or &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; 5.012&lt;/code&gt; (or higher) is selected.</source>
          <target state="translated">Perl은 5.6 이전의 8 비트 원시 바이트 문자열과 유니 코드 문자 문자열을 모두 지원합니다. 일반적인 원칙은 Perl이 가능한 한 오랫동안 데이터를 8 비트 바이트로 유지하려고하지만 유니 코드를 피할 수 없게되면 데이터는 투명하게 유니 코드로 업그레이드됩니다. Perl v5.14.0 이전에는 업그레이드가 완전히 투명하지 않았으며 ( &lt;a href=&quot;perlunicode#The-%22Unicode-Bug%22&quot;&gt;perlunicode의 유니 코드 버그&lt;/a&gt; 참조 ) 이전 버전과의 호환성을 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature 'unicode_strings'&lt;/code&gt; ( &lt;a href=&quot;feature&quot;&gt;기능&lt;/a&gt; 참조 ) 또는 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; 5.012&lt;/code&gt; (이상)를 &lt;a href=&quot;functions/use&quot;&gt;사용&lt;/a&gt; 하지 않으면 전체 투명성이 확보되지 않습니다. 선택된.</target>
        </trans-unit>
        <trans-unit id="e2d84ca8811712997a8e9f3ad7161c9e75151f4e" translate="yes" xml:space="preserve">
          <source>Perl supports cross-compiling to QNX NTO through the Native Development Kit (NDK) for the Blackberry 10. This means that you can cross-compile for both ARM and x86 versions of the platform.</source>
          <target state="translated">Perl은 Blackberry 10 용 NDK (Native Development Kit)를 통해 QNX NTO에 대한 크로스 컴파일을 지원합니다. 이는 플랫폼의 ARM 및 x86 버전 모두에 대해 크로스 컴파일 할 수 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="61c6178993abcdebf49b240f9190abe5238c4bb9" translate="yes" xml:space="preserve">
          <source>Perl supports several other ways to call methods besides the &lt;code&gt;$object-&amp;gt;method()&lt;/code&gt; usage we've seen so far.</source>
          <target state="translated">펄은 지금까지 보았던 &lt;code&gt;$object-&amp;gt;method()&lt;/code&gt; 사용법 외에 메소드를 호출하는 다른 여러 가지 방법을 지원합니다 .</target>
        </trans-unit>
        <trans-unit id="51aafa2b4885796ac3ebbd5ae9ad8631e2f17f44" translate="yes" xml:space="preserve">
          <source>Perl supports single-byte locales that are supersets of ASCII, such as the ISO 8859 ones, and one multi-byte-type locale, UTF-8 ones, described in the next paragraph. Perl doesn't support any other multi-byte locales, such as the ones for East Asian languages.</source>
          <target state="translated">Perl은 ISO 8859와 같은 ASCII의 상위 세트 인 단일 바이트 로케일과 다음 단락에서 설명하는 하나의 다중 바이트 유형 로케일 인 UTF-8 로케일을 지원합니다. Perl은 동아시아 언어와 같은 다른 멀티 바이트 로케일을 지원하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b921bede497b8f7b569d6ab7232a231253948127" translate="yes" xml:space="preserve">
          <source>Perl tends to add NULs, as an insurance policy, after the end of strings in SV's, so it is likely that using this macro will prevent inadvertent reading beyond the end of the input buffer, even if it is malformed UTF-8.</source>
          <target state="translated">Perl은 SV의 문자열 끝에 보험 정책으로 NUL을 추가하는 경향이 있으므로이 매크로를 사용하면 UTF-8 형식이 잘못된 경우에도 입력 버퍼의 끝을 넘어서 실수로 읽는 것을 방지 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="39eb141cb70a235796d1c9a3b86085a1c03895dd" translate="yes" xml:space="preserve">
          <source>Perl termcap interface</source>
          <target state="translated">Perl termcap 인터페이스</target>
        </trans-unit>
        <trans-unit id="29dca9ab8b1d3b8377101aae3e9cbe3e4fbc8b16" translate="yes" xml:space="preserve">
          <source>Perl threading is going to work only in Tru64 4.0 and newer releases, older operating releases like 3.2 aren't probably going to work properly with threads.</source>
          <target state="translated">Perl 스레딩은 Tru64 4.0 및 최신 릴리스에서만 작동하며 3.2와 같은 이전 운영 릴리스는 스레드에서 제대로 작동하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="711f6c74d0066ee853703c933b2128a03d5d8197" translate="yes" xml:space="preserve">
          <source>Perl threads mailing list: &lt;a href=&quot;http://lists.perl.org/list/ithreads.html&quot;&gt;http://lists.perl.org/list/ithreads.html&lt;/a&gt;</source>
          <target state="translated">펄 스레드 메일 링리스트 : &lt;a href=&quot;http://lists.perl.org/list/ithreads.html&quot;&gt;http://lists.perl.org/list/ithreads.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="cba34b4e3f85c4f737c5ed55db9967c713391cb7" translate="yes" xml:space="preserve">
          <source>Perl threads mailing list: &lt;a href=&quot;https://lists.perl.org/list/ithreads.html&quot;&gt;https://lists.perl.org/list/ithreads.html&lt;/a&gt;</source>
          <target state="translated">Perl 스레드 메일 링리스트 : &lt;a href=&quot;https://lists.perl.org/list/ithreads.html&quot;&gt;https://lists.perl.org/list/ithreads.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d2559db124cb4f86fc6327b39cc58f5d846e3791" translate="yes" xml:space="preserve">
          <source>Perl tips, autodie</source>
          <target state="translated">펄 팁, 오토 디</target>
        </trans-unit>
        <trans-unit id="eaf5bf8a496158d3f80504dd4ad1d919275e7f1f" translate="yes" xml:space="preserve">
          <source>Perl tracks the dynamic scope by a data structure called the context stack, which is an array of &lt;code&gt;PERL_CONTEXT&lt;/code&gt; structures, and which is itself a big union for all the types of context. Whenever a new scope is entered (such as a block, a &lt;code&gt;for&lt;/code&gt; loop, or a subroutine call), a new context entry is pushed onto the stack. Similarly when leaving a block or returning from a subroutine call etc. a context is popped. Since the context stack represents the current dynamic scope, it can be searched. For example, &lt;code&gt;next LABEL&lt;/code&gt; searches back through the stack looking for a loop context that matches the label; &lt;code&gt;return&lt;/code&gt; pops contexts until it finds a sub or eval context or similar; &lt;code&gt;caller&lt;/code&gt; examines sub contexts on the stack.</source>
          <target state="translated">Perl은 &lt;code&gt;PERL_CONTEXT&lt;/code&gt; 구조 의 배열 인 컨텍스트 스택이라는 데이터 구조에 의해 동적 범위를 추적하며, 이는 그 자체로 모든 유형의 컨텍스트에 대한 큰 통합입니다. 새 범위 (예 : 블록, &lt;code&gt;for&lt;/code&gt; 루프 또는 서브 루틴 호출) 가 입력 될 때마다 새 컨텍스트 항목이 스택으로 푸시됩니다. 마찬가지로 블록을 떠나거나 서브 루틴 호출 등에서 돌아올 때 컨텍스트가 팝됩니다. 컨텍스트 스택은 현재 동적 범위를 나타내므로 검색 할 수 있습니다. 예를 들어, &lt;code&gt;next LABEL&lt;/code&gt; 은 레이블과 일치하는 루프 컨텍스트를 찾기 위해 스택을 다시 검색합니다. 하위 또는 평가 컨텍스트 또는 이와 유사한 것을 찾을 때까지 팝 컨텍스트를 &lt;code&gt;return&lt;/code&gt; 합니다. &lt;code&gt;caller&lt;/code&gt; 는 스택의 하위 컨텍스트를 검사합니다.</target>
        </trans-unit>
        <trans-unit id="417a3338dad2fe5b9c31529d81335ca36b2c6619" translate="yes" xml:space="preserve">
          <source>Perl under AmigaOS lacks some features of perl under UNIX because of deficiencies in the UNIX-emulation, most notably:</source>
          <target state="translated">AmigaOS의 Perl은 UNIX 에뮬레이션의 결함으로 인해 UNIX에서 perl의 일부 기능이 부족합니다.</target>
        </trans-unit>
        <trans-unit id="6de1733b62296869d712e2db6939eb5aa3e92225" translate="yes" xml:space="preserve">
          <source>Perl under DOS lacks some features of perl under UNIX because of deficiencies in the UNIX-emulation, most notably:</source>
          <target state="translated">DOS에서 Perl은 UNIX 에뮬레이션의 결함으로 인해 UNIX에서 perl의 일부 기능이 부족합니다.</target>
        </trans-unit>
        <trans-unit id="fed7e4c0f6346d8e97d2349cf02d579f8a312bef" translate="yes" xml:space="preserve">
          <source>Perl under Mac OS Classic has not been supported since before Perl 5.10 (April 2004).</source>
          <target state="translated">Mac OS Classic에서 Perl은 Perl 5.10 (2004 년 4 월) 이전부터 지원되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="fe29a7a8cb01db791e95920fcdb336a6f5bf1bcb" translate="yes" xml:space="preserve">
          <source>Perl uses &quot;full&quot; Unicode case mappings. This means that converting a single character to another case may result in a sequence of more than one character. For example, the uppercase of &lt;code&gt;&amp;szlig;&lt;/code&gt; (LATIN SMALL LETTER SHARP S) is the two character sequence &lt;code&gt;SS&lt;/code&gt;. This presents some complications The lowercase of all characters in the range 0..255 is a single character, and thus &lt;code&gt;&lt;a href=&quot;#toLOWER_L1&quot;&gt;&quot;toLOWER_L1&quot;&lt;/a&gt;&lt;/code&gt; is furnished. But, &lt;code&gt;toUPPER_L1&lt;/code&gt; can't exist, as it couldn't return a valid result for all legal inputs. Instead &lt;code&gt;&lt;a href=&quot;#toUPPER_uvchr&quot;&gt;&quot;toUPPER_uvchr&quot;&lt;/a&gt;&lt;/code&gt; has an API that does allow every possible legal result to be returned.) Likewise no other function that is crippled by not being able to give the correct results for the full range of possible inputs has been implemented here.</source>
          <target state="translated">Perl은 &quot;전체&quot;유니 코드 대소 문자 매핑을 사용합니다. 즉, 단일 문자를 다른 대소 문자로 변환하면 두 개 이상의 문자 시퀀스가 ​​생성 될 수 있습니다. 예를 들어, &lt;code&gt;&amp;szlig;&lt;/code&gt; (LATIN SMALL LETTER SHARP S) 의 대문자 는 두 문자 시퀀스 &lt;code&gt;SS&lt;/code&gt; 입니다. 이것은 몇 가지 복잡함을 나타냅니다. 0..255 범위에있는 모든 문자의 소문자는 단일 문자이므로 &lt;code&gt;&lt;a href=&quot;#toLOWER_L1&quot;&gt;&quot;toLOWER_L1&quot;&lt;/a&gt;&lt;/code&gt; 이 제공됩니다. 그러나 &lt;code&gt;toUPPER_L1&lt;/code&gt; 은 모든 합법적 인 입력에 대해 유효한 결과를 반환 할 수 없기 때문에 존재할 수 없습니다. 대신 &lt;code&gt;&lt;a href=&quot;#toUPPER_uvchr&quot;&gt;&quot;toUPPER_uvchr&quot;&lt;/a&gt;&lt;/code&gt; 가능한 모든 합법적 결과를 반환 할 수있는 API가 있습니다.) 마찬가지로 가능한 입력의 전체 범위에 대해 올바른 결과를 제공 할 수 없어서 불구가되는 다른 기능은 여기에서 구현되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="0c71cd98e9f081d421a495772db91702ad362132" translate="yes" xml:space="preserve">
          <source>Perl uses &lt;code&gt;\n&lt;/code&gt; to represent the &quot;logical&quot; newline, where what is logical may depend on the platform in use. In MacPerl, &lt;code&gt;\n&lt;/code&gt; always means &lt;code&gt;\015&lt;/code&gt; . On EBCDIC platforms, &lt;code&gt;\n&lt;/code&gt; could be &lt;code&gt;\025&lt;/code&gt; or &lt;code&gt;\045&lt;/code&gt; . In DOSish perls, &lt;code&gt;\n&lt;/code&gt; usually means &lt;code&gt;\012&lt;/code&gt; , but when accessing a file in &quot;text&quot; mode, perl uses the &lt;code&gt;:crlf&lt;/code&gt; layer that translates it to (or from) &lt;code&gt;\015\012&lt;/code&gt; , depending on whether you're reading or writing. Unix does the same thing on ttys in canonical mode. &lt;code&gt;\015\012&lt;/code&gt; is commonly referred to as CRLF.</source>
          <target state="translated">Perl은 &lt;code&gt;\n&lt;/code&gt; 을 사용 하여 &quot;논리적&quot;줄 바꿈을 나타내며, 논리적 인 내용은 사용중인 플랫폼에 따라 달라질 수 있습니다. MacPerl에서 &lt;code&gt;\n&lt;/code&gt; 항상 &lt;code&gt;\015&lt;/code&gt; 의미 합니다. EBCDIC 플랫폼에서 &lt;code&gt;\n&lt;/code&gt; 은 &lt;code&gt;\025&lt;/code&gt; 또는 &lt;code&gt;\045&lt;/code&gt; 수 있습니다 . DOSish perls에서 &lt;code&gt;\n&lt;/code&gt; 보통 &lt;code&gt;\012&lt;/code&gt; 의미 하지만 &quot;text&quot;모드에서 파일에 액세스 할 때 perl 은 읽기 또는 쓰기 여부에 따라 파일을 &lt;code&gt;\015\012&lt;/code&gt; 변환 하는 &lt;code&gt;:crlf&lt;/code&gt; 레이어를 사용합니다 . . 유닉스는 표준 모드에서 ttys에 대해 동일한 작업을 수행합니다. &lt;code&gt;\015\012&lt;/code&gt; 는 일반적으로 CRLF라고합니다.</target>
        </trans-unit>
        <trans-unit id="890fade91864c028d9bdef8ccb2172dd937cfe65" translate="yes" xml:space="preserve">
          <source>Perl uses &lt;code&gt;\n&lt;/code&gt; to represent the &quot;logical&quot; newline, where what is logical may depend on the platform in use. In MacPerl, &lt;code&gt;\n&lt;/code&gt; always means &lt;code&gt;\015&lt;/code&gt;. On EBCDIC platforms, &lt;code&gt;\n&lt;/code&gt; could be &lt;code&gt;\025&lt;/code&gt; or &lt;code&gt;\045&lt;/code&gt;. In DOSish perls, &lt;code&gt;\n&lt;/code&gt; usually means &lt;code&gt;\012&lt;/code&gt;, but when accessing a file in &quot;text&quot; mode, perl uses the &lt;code&gt;:crlf&lt;/code&gt; layer that translates it to (or from) &lt;code&gt;\015\012&lt;/code&gt;, depending on whether you're reading or writing. Unix does the same thing on ttys in canonical mode. &lt;code&gt;\015\012&lt;/code&gt; is commonly referred to as CRLF.</source>
          <target state="translated">Perl은 &lt;code&gt;\n&lt;/code&gt; 을 사용 하여 &quot;논리적&quot;줄 바꿈을 나타내며, 논리적 인 것은 사용중인 플랫폼에 따라 달라질 수 있습니다. MacPerl에서 &lt;code&gt;\n&lt;/code&gt; 항상 &lt;code&gt;\015&lt;/code&gt; 의미 합니다. EBCDIC 플랫폼에서 &lt;code&gt;\n&lt;/code&gt; 은 &lt;code&gt;\025&lt;/code&gt; 또는 &lt;code&gt;\045&lt;/code&gt; 수 있습니다 . DOSish perls에서 &lt;code&gt;\n&lt;/code&gt; 일반적으로 &lt;code&gt;\012&lt;/code&gt; 의미 하지만 &quot;text&quot;모드에서 파일에 액세스 할 때 perl 은 읽기 또는 쓰기 여부에 따라 파일을 &lt;code&gt;\015\012&lt;/code&gt; 로 (또는 그로부터) 변환 하는 &lt;code&gt;:crlf&lt;/code&gt; 레이어를 사용합니다 . . Unix는 표준 모드의 tty에서 동일한 작업을 수행합니다. &lt;code&gt;\015\012&lt;/code&gt; 는 일반적으로 CRLF라고합니다.</target>
        </trans-unit>
        <trans-unit id="ef2489d6cf6b9a1519765ae5403d21cedb84ac6c" translate="yes" xml:space="preserve">
          <source>Perl uses UTF-8, internally, for most Unicode strings.</source>
          <target state="translated">Perl은 대부분의 유니 코드 문자열에 UTF-8을 내부적으로 사용합니다.</target>
        </trans-unit>
        <trans-unit id="a32f78ca0221220c37e8fdc6e6abb5de92126da7" translate="yes" xml:space="preserve">
          <source>Perl uses a reference count-driven garbage collection mechanism. SVs, AVs, or HVs (xV for short in the following) start their life with a reference count of 1. If the reference count of an xV ever drops to 0, then it will be destroyed and its memory made available for reuse.</source>
          <target state="translated">Perl은 참조 횟수 중심 가비지 수집 메커니즘을 사용합니다. SV, AV 또는 HV (다음에서 짧게는 xV)는 1의 기준 카운트로 수명을 시작합니다. xV의 기준 카운트가 0으로 떨어지면 해당 셀이 소멸되고 메모리를 재사용 할 수있게됩니다.</target>
        </trans-unit>
        <trans-unit id="687866e44b38320b5ab4b8c364c0ba7321b47747" translate="yes" xml:space="preserve">
          <source>Perl uses a reference count-driven garbage collection mechanism. SVs, AVs, or HVs (xV for short in the following) start their life with a reference count of 1. If the reference count of an xV ever drops to 0, then it will be destroyed and its memory made available for reuse. At the most basic internal level, reference counts can be manipulated with the following macros:</source>
          <target state="translated">Perl은 참조 횟수 기반 가비지 수집 메커니즘을 사용합니다. SV, AV 또는 HV (다음에서 줄여서 xV)는 참조 카운트 1로 수명을 시작합니다. xV의 참조 카운트가 0으로 떨어지면 삭제되고 메모리를 재사용 할 수 있습니다. 가장 기본적인 내부 수준에서 참조 횟수는 다음 매크로를 사용하여 조작 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ffa78748c6c02aeaa5f6c0aa0037a286831d36b3" translate="yes" xml:space="preserve">
          <source>Perl uses a simple signal handling model: the %SIG hash contains names or references of user-installed signal handlers. These handlers will be called with an argument which is the name of the signal that triggered it. A signal may be generated intentionally from a particular keyboard sequence like control-C or control-Z, sent to you from another process, or triggered automatically by the kernel when special events transpire, like a child process exiting, your own process running out of stack space, or hitting a process file-size limit.</source>
          <target state="translated">Perl은 간단한 신호 처리 모델을 사용합니다. % SIG 해시는 사용자가 설치 한 신호 처리기의 이름 또는 참조를 포함합니다. 이 핸들러는 트리거 한 신호의 이름 인 인수와 함께 호출됩니다. 신호는 control-C 또는 control-Z와 같은 특정 키보드 시퀀스에서 의도적으로 생성되거나 다른 프로세스에서 전송되거나 자식 프로세스가 종료되거나 자체 프로세스가 부족한 특수 이벤트가 발생하면 커널에 의해 자동으로 트리거 될 수 있습니다 스택 공간 또는 프로세스 파일 크기 제한에 도달했습니다.</target>
        </trans-unit>
        <trans-unit id="697496faa8f310204a7d494fa53a2d354c2af264" translate="yes" xml:space="preserve">
          <source>Perl uses a special typedef IV which is a simple signed integer type that is guaranteed to be large enough to hold a pointer (as well as an integer). Additionally, there is the UV, which is simply an unsigned IV.</source>
          <target state="translated">Perl은 포인터를 보유하기에 충분히 큰 (정수뿐만 아니라) 보장되는 단순 부호있는 정수 유형 인 특수 typedef IV를 사용합니다. 또한 UV는 서명되지 않은 IV입니다.</target>
        </trans-unit>
        <trans-unit id="77447e8f55a3fbc6e220b03acaf3a045c7382163" translate="yes" xml:space="preserve">
          <source>Perl uses an internal type called a</source>
          <target state="translated">펄은</target>
        </trans-unit>
        <trans-unit id="dcd23c3b2c97cdf3da72f0a14a98128b56138f99" translate="yes" xml:space="preserve">
          <source>Perl uses its own malloc() under OS/2 - interpreters are usually malloc-bound for speed, but perl is not, since its malloc is lightning-fast. Perl-memory-usage-tuned benchmarks show that Perl's malloc is 5 times quicker than EMX one. I do not have convincing data about memory footprint, but a (pretty random) benchmark showed that Perl's one is 5% better.</source>
          <target state="translated">Perl은 OS / 2에서 자체 malloc ()을 사용합니다. 인터프리터는 일반적으로 속도에 따라 malloc에 ​​바인딩되어 있지만 malloc은 매우 빠릅니다. Perl-memory-usage-tuned 벤치 마크는 Perl의 malloc이 EMX보다 5 배 빠르다는 것을 보여줍니다. 메모리 풋 프린트에 대한 설득력있는 데이터는 없지만 (임의의) 벤치 마크에 따르면 Perl의 것이 5 % 더 우수합니다.</target>
        </trans-unit>
        <trans-unit id="1739ec403c50a46c8549e731f4fbc63bb7b3c7ac" translate="yes" xml:space="preserve">
          <source>Perl uses the hardwired-or-customized shell (see &lt;a href=&quot;#PERL_SH_DIR&quot;&gt;&quot;&lt;code&gt;PERL_SH_DIR&lt;/code&gt;&quot;&lt;/a&gt;).</source>
          <target state="translated">Perl은 하드 와이어 또는 사용자 정의 된 셸을 사용합니다 ( &lt;a href=&quot;#PERL_SH_DIR&quot;&gt;&quot; &lt;code&gt;PERL_SH_DIR&lt;/code&gt; &quot;&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="aaeb3f63a0dee2460eba26dc00ff361a3a2b8977" translate="yes" xml:space="preserve">
          <source>Perl uses the hardwired-or-customized shell (see &lt;code&gt;&lt;a href=&quot;#PERL_SH_DIR&quot;&gt;PERL_SH_DIR&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">Perl은 하드 와이어 또는 사용자 정의 쉘을 사용합니다 ( &lt;code&gt;&lt;a href=&quot;#PERL_SH_DIR&quot;&gt;PERL_SH_DIR&lt;/a&gt;&lt;/code&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="7ae85ddbb739ce30e8dfb43f3f02245520739733" translate="yes" xml:space="preserve">
          <source>Perl uses the platform's C library collation functions &lt;code&gt;strcoll()&lt;/code&gt; and &lt;code&gt;strxfrm()&lt;/code&gt;. That means you get whatever they give. On some platforms, these functions work well on UTF-8 locales, giving a reasonable default collation for the code points that are important in that locale. (And if they aren't working well, the problem may only be that the locale definition is deficient, so can be fixed by using a better definition file. Unicode's definitions (see &lt;a href=&quot;#Freely-available-locale-definitions&quot;&gt;&quot;Freely available locale definitions&quot;&lt;/a&gt;) provide reasonable UTF-8 locale collation definitions.) Starting in Perl v5.26, Perl's use of these functions has been made more seamless. This may be sufficient for your needs. For more control, and to make sure strings containing any code point (not just the ones important in the locale) collate properly, the &lt;a href=&quot;Unicode::Collate&quot;&gt;Unicode::Collate&lt;/a&gt; module is suggested.</source>
          <target state="translated">Perl은 플랫폼의 C 라이브러리 조합 함수 &lt;code&gt;strcoll()&lt;/code&gt; 및 &lt;code&gt;strxfrm()&lt;/code&gt; 합니다. 그것은 당신이 그들이주는 것을 얻는다는 것을 의미합니다. 일부 플랫폼에서 이러한 함수는 UTF-8 로케일에서 잘 작동하여 해당 로케일에서 중요한 코드 포인트에 대해 합리적인 기본 데이터 정렬을 제공합니다. (잘 작동하지 않는 경우 문제는 로케일 정의가 부족하다는 것뿐이므로 더 나은 정의 파일을 사용하여 수정할 수 있습니다. 유니 코드 정의 ( &lt;a href=&quot;#Freely-available-locale-definitions&quot;&gt;&quot;자유로 사용할 수있는 로케일 정의&quot;참조)&lt;/a&gt;) 합리적인 UTF-8 로케일 데이터 정렬 정의를 제공합니다.) Perl v5.26부터 Perl의 이러한 함수 사용이 더욱 원활 해졌습니다. 이것은 귀하의 필요에 충분할 수 있습니다. 더 많은 제어를 위해 그리고 (로케일에서 중요한 것뿐만 아니라) 코드 포인트를 포함하는 문자열이 적절하게 대조되도록하려면 &lt;a href=&quot;Unicode::Collate&quot;&gt;Unicode :: Collate&lt;/a&gt; 모듈이 제안됩니다.</target>
        </trans-unit>
        <trans-unit id="f56985ba618cbe018e4fc2adbd42f3a731d5d38f" translate="yes" xml:space="preserve">
          <source>Perl uses the same mechanism to produce &lt;code&gt;$1&lt;/code&gt; , &lt;code&gt;$2&lt;/code&gt; , etc, so you also pay a price for each pattern that contains capturing parentheses. (To avoid this cost while retaining the grouping behaviour, use the extended regular expression &lt;code&gt;(?: ... )&lt;/code&gt; instead.) But if you never use &lt;code&gt;$&amp;amp;&lt;/code&gt; , &lt;code&gt;$`&lt;/code&gt; or &lt;code&gt;$'&lt;/code&gt; , then patterns</source>
          <target state="translated">Perl은 동일한 메커니즘을 사용하여 &lt;code&gt;$1&lt;/code&gt; , &lt;code&gt;$2&lt;/code&gt; 등 을 생성 하므로 캡처 괄호가 포함 된 각 패턴에 대해 가격을 지불합니다. (그룹화 동작을 유지하면서이 비용을 피하려면 대신 확장 정규식 &lt;code&gt;(?: ... )&lt;/code&gt; 사용하십시오.) &lt;code&gt;$&amp;amp;&lt;/code&gt; , &lt;code&gt;$`&lt;/code&gt; 또는 &lt;code&gt;$'&lt;/code&gt; 사용하지 않으면 패턴</target>
        </trans-unit>
        <trans-unit id="fd3d29794e28820446964a33391fd6afd6169a0d" translate="yes" xml:space="preserve">
          <source>Perl uses the same mechanism to produce &lt;code&gt;$1&lt;/code&gt;, &lt;code&gt;$2&lt;/code&gt;,</source>
          <target state="translated">Perl은 동일한 메커니즘을 사용하여 &lt;code&gt;$1&lt;/code&gt; , &lt;code&gt;$2&lt;/code&gt; ,</target>
        </trans-unit>
        <trans-unit id="729ae7be2e299ed898ba24317c3f470da4a89862" translate="yes" xml:space="preserve">
          <source>Perl v5.6.0 introduced lexical control over the handling of warnings by category. The &lt;code&gt;warnings&lt;/code&gt; pragma generally replaces the command line flag &lt;b&gt;-w&lt;/b&gt;. Documentation on the use of lexical warnings, once partly found in this document, is now found in the &lt;a href=&quot;warnings&quot;&gt;warnings&lt;/a&gt; documentation.</source>
          <target state="translated">Perl v5.6.0에서는 범주 별 경고 처리에 대한 어휘 제어를 도입했습니다. &lt;code&gt;warnings&lt;/code&gt; pragma는 일반적으로 명령 줄 플래그 대체 &lt;b&gt;-w를&lt;/b&gt; . 이 문서에서 부분적으로 발견 된 어휘 경고 사용에 대한 문서는 이제 &lt;a href=&quot;warnings&quot;&gt;경고&lt;/a&gt; 문서 에서 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ed16c3492238f59d6acc4b17eee61789dc827788" translate="yes" xml:space="preserve">
          <source>Perl v5.8 and better allow extended Unicode characters in strings. Such strings cannot be encoded directly, as the base64 encoding is only defined for single-byte characters. The solution is to use the Encode module to select the byte encoding you want. For example:</source>
          <target state="translated">Perl v5.8 이상은 문자열에서 확장 유니 코드 문자를 허용합니다. base64 인코딩은 1 바이트 문자에 대해서만 정의되므로 이러한 문자열은 직접 인코딩 할 수 없습니다. 해결책은 Encode 모듈을 사용하여 원하는 바이트 인코딩을 선택하는 것입니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="fac662f37a6502961fed43d288ed81deaf631ca7" translate="yes" xml:space="preserve">
          <source>Perl v5.8 and better allow extended Unicode characters in strings. Such strings cannot be encoded directly, as the quoted-printable encoding is only defined for single-byte characters. The solution is to use the Encode module to select the byte encoding you want. For example:</source>
          <target state="translated">Perl v5.8 이상은 문자열에서 확장 유니 코드 문자를 허용합니다. 인용 된 인쇄 가능 인코딩은 1 바이트 문자에 대해서만 정의되므로 이러한 문자열은 직접 인코딩 할 수 없습니다. 해결책은 Encode 모듈을 사용하여 원하는 바이트 인코딩을 선택하는 것입니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ca07f22517f53e73e435cde9502974d6bc1e648d" translate="yes" xml:space="preserve">
          <source>Perl variable names may also be a sequence of digits or a single punctuation or control character (with the literal control character form deprecated). These names are all reserved for special uses by Perl; for example, the all-digits names are used to hold data captured by backreferences after a regular expression match. Perl has a special syntax for the single-control-character names: It understands &lt;code&gt;^X&lt;/code&gt; (caret &lt;code&gt;X&lt;/code&gt; ) to mean the control-&lt;code&gt;X&lt;/code&gt; character. For example, the notation &lt;code&gt;$^W&lt;/code&gt; (dollar-sign caret &lt;code&gt;W&lt;/code&gt; ) is the scalar variable whose name is the single character control-&lt;code&gt;W&lt;/code&gt; . This is better than typing a literal control-&lt;code&gt;W&lt;/code&gt; into your program.</source>
          <target state="translated">Perl 변수 이름은 일련의 숫자 또는 단일 구두점 또는 제어 문자 (리터럴 제어 문자 형식은 더 이상 사용되지 않음) 일 수 있습니다. 이 이름은 모두 Perl의 특수 용도로 사용됩니다. 예를 들어, 모든 숫자 이름은 정규식 일치 후 역 참조로 캡처 된 데이터를 보유하는 데 사용됩니다. Perl은 단일 제어 문자 이름에 대한 특수 구문을 가지고 있습니다. 제어 &lt;code&gt;X&lt;/code&gt; 문자 를 의미하는 &lt;code&gt;^X&lt;/code&gt; (캐럿 &lt;code&gt;X&lt;/code&gt; )를 이해 합니다. 예를 들어, &lt;code&gt;$^W&lt;/code&gt; 표기법 (달러 기호 캐럿 &lt;code&gt;W&lt;/code&gt; )은 이름이 단일 문자 제어 &lt;code&gt;W&lt;/code&gt; 인 스칼라 변수입니다 . 이것은 프로그램에 리터럴 제어 &lt;code&gt;W&lt;/code&gt; 를 입력하는 것보다 낫습니다 .</target>
        </trans-unit>
        <trans-unit id="939e5e17b46e5bec2f5d706c2937023945ced9ed" translate="yes" xml:space="preserve">
          <source>Perl variable names may also be a sequence of digits, a single punctuation character, or the two-character sequence: &lt;code&gt;^&lt;/code&gt; (caret or CIRCUMFLEX ACCENT) followed by any one of the characters &lt;code&gt;[][A-Z^_?\]&lt;/code&gt;. These names are all reserved for special uses by Perl; for example, the all-digits names are used to hold data captured by backreferences after a regular expression match.</source>
          <target state="translated">Perl 변수 이름은 숫자 시퀀스, 단일 구두점 문자 또는 두 문자 시퀀스 일 수도 있습니다. &lt;code&gt;^&lt;/code&gt; (캐럿 또는 CIRCUMFLEX ACCENT) 뒤에 &lt;code&gt;[][A-Z^_?\]&lt;/code&gt; 문자 중 하나가 올 수 있습니다. 이 이름은 모두 Perl의 특수 용도로 예약되어 있습니다. 예를 들어 모든 숫자 이름은 정규식 일치 후 역 참조에 의해 캡처 된 데이터를 보유하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="ed35d8a6334fde91537a85bc31a0ea827797100e" translate="yes" xml:space="preserve">
          <source>Perl variable types</source>
          <target state="translated">펄 변수 타입</target>
        </trans-unit>
        <trans-unit id="4045947434895b417a6c84aaed4fd5f8d36c865a" translate="yes" xml:space="preserve">
          <source>Perl variables</source>
          <target state="translated">펄 변수</target>
        </trans-unit>
        <trans-unit id="c155457483cd87781fd4429cf68e8cc70eecc55b" translate="yes" xml:space="preserve">
          <source>Perl versions before 5.8 had in its C source code signal handlers which would catch the signal and possibly run a Perl function that you had set in &lt;code&gt;%SIG&lt;/code&gt; . This violated the rules of signal handling at that level causing perl to dump core. Since version 5.8.0, perl looks at &lt;code&gt;%SIG&lt;/code&gt;&lt;b&gt;after&lt;/b&gt; the signal has been caught, rather than while it is being caught. Previous versions of this answer were incorrect.</source>
          <target state="translated">5.8 이전의 Perl 버전은 C 소스 코드 신호 핸들러를 사용하여 신호를 포착하고 &lt;code&gt;%SIG&lt;/code&gt; 에서 설정 한 Perl 함수를 실행할 수있었습니다 . 이는 펄이 코어를 덤프하게하는 해당 레벨의 신호 처리 규칙을 위반 한 것입니다. 버전 5.8.0부터 perl은 신호가 잡히는 것이 아니라 신호가 잡힌 &lt;b&gt;후에 &lt;/b&gt; &lt;code&gt;%SIG&lt;/code&gt; &lt;b&gt;를 확인&lt;/b&gt; 합니다. 이 답변의 이전 버전이 잘못되었습니다.</target>
        </trans-unit>
        <trans-unit id="89a169d5ba146feda33d133d78a5e42e73c7c504" translate="yes" xml:space="preserve">
          <source>Perl versions before 5.8 had in its C source code signal handlers which would catch the signal and possibly run a Perl function that you had set in &lt;code&gt;%SIG&lt;/code&gt;. This violated the rules of signal handling at that level causing perl to dump core. Since version 5.8.0, perl looks at &lt;code&gt;%SIG&lt;/code&gt;&lt;b&gt;after&lt;/b&gt; the signal has been caught, rather than while it is being caught. Previous versions of this answer were incorrect.</source>
          <target state="translated">5.8 이전의 Perl 버전에는 신호를 포착하고 &lt;code&gt;%SIG&lt;/code&gt; 에서 설정 한 Perl 함수를 실행할 수있는 C 소스 코드 신호 처리기가있었습니다 . 이는 해당 레벨에서 신호 처리 규칙을 위반하여 perl이 코어를 덤프하도록했습니다. 버전 5.8.0부터 perl은 신호가 포착되는 동안이 아니라 포착 된 &lt;b&gt;후 &lt;/b&gt; &lt;code&gt;%SIG&lt;/code&gt; &lt;b&gt;를 확인&lt;/b&gt; 합니다. 이 답변의 이전 버전은 잘못되었습니다.</target>
        </trans-unit>
        <trans-unit id="8eacc0652f9a68bdddb6fbf37bd76bc666b4e50b" translate="yes" xml:space="preserve">
          <source>Perl waits for the subprocess to complete before continuing execution in the current process. As described in &lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt;, the return value of &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; is a fake &quot;status&quot; which follows POSIX semantics unless the pragma &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; vmsish 'status'&lt;/code&gt; is in effect; see the description of &lt;code&gt;$?&lt;/code&gt; in this document for more detail.</source>
          <target state="translated">Perl은 현재 프로세스에서 실행을 계속하기 전에 서브 프로세스가 완료되기를 기다립니다. &lt;a href=&quot;perlfunc&quot;&gt;perlfunc에&lt;/a&gt; 설명 된대로 , &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; 의 반환 값은 pragma &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; vmsish 'status'&lt;/code&gt; 가 적용 되지 않는 한 POSIX 의미 체계를 따르는 가짜 &quot;상태&quot;입니다 . &lt;code&gt;$?&lt;/code&gt; 의 설명을 참조하십시오 ? 자세한 내용은이 문서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="76b6739e84bfe97e715bfa0d21f10031957c9f2e" translate="yes" xml:space="preserve">
          <source>Perl waits for the subprocess to complete before continuing execution in the current process. As described in &lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt;, the return value of &lt;code&gt;system&lt;/code&gt; is a fake &quot;status&quot; which follows POSIX semantics unless the pragma &lt;code&gt;use vmsish 'status'&lt;/code&gt; is in effect; see the description of &lt;code&gt;$?&lt;/code&gt; in this document for more detail.</source>
          <target state="translated">Perl은 현재 프로세스에서 실행을 계속하기 전에 하위 프로세스가 완료되기를 기다립니다. &lt;a href=&quot;perlfunc&quot;&gt;perlfunc에&lt;/a&gt; 설명 된대로 &lt;code&gt;system&lt;/code&gt; 의 반환 값은 pragma가 &lt;code&gt;use vmsish 'status'&lt;/code&gt; 하지 않는 한 POSIX 의미 체계를 따르는 가짜 &quot;상태&quot;입니다 . &lt;code&gt;$?&lt;/code&gt; 대한 설명을 참조하십시오 . 자세한 내용은이 문서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="77bc7bc2d999572b3218f851bcc9845dccf95ea0" translate="yes" xml:space="preserve">
          <source>Perl was born in Unix and can therefore access all common Unix system calls. In non-Unix environments, the functionality of some Unix system calls may not be available or details of the available functionality may differ slightly. The Perl functions affected by this are:</source>
          <target state="translated">Perl은 Unix에서 태어 났으므로 모든 일반적인 Unix 시스템 호출에 액세스 할 수 있습니다. Unix 이외의 환경에서는 일부 Unix 시스템 호출 기능을 사용할 수 없거나 사용 가능한 기능의 세부 사항이 약간 다를 수 있습니다. 이에 의해 영향을받는 Perl 기능은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="749163e214f8798aa3cc386d45ba1c2b25237249" translate="yes" xml:space="preserve">
          <source>Perl was originally a language optimized for scanning arbitrary text files, extracting information from those text files, and printing reports based on that information. It quickly became a good language for many system management tasks. Over the years, Perl has grown into a general-purpose programming language. It's widely used for everything from quick &quot;one-liners&quot; to full-scale application development.</source>
          <target state="translated">Perl은 원래 임의의 텍스트 파일을 스캔하고 해당 텍스트 파일에서 정보를 추출하며 해당 정보를 기반으로 보고서를 인쇄하는 데 최적화 된 언어였습니다. 많은 시스템 관리 작업에 빠르게 유용한 언어가되었습니다. 수년에 걸쳐 Perl은 범용 프로그래밍 언어로 성장했습니다. 빠른 &quot;한 줄짜리&quot;부터 전체 규모의 응용 프로그램 개발에 이르기까지 모든 용도로 널리 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="97d7a9a879c5c36fd28bdf27f2f4d6a7f1d3b405" translate="yes" xml:space="preserve">
          <source>Perl was originally written to handle US-ASCII only (that is characters whose ordinal numbers are in the range 0 - 127). And documentation and comments may still use the term ASCII, when sometimes in fact the entire range from 0 - 255 is meant.</source>
          <target state="translated">Perl은 원래 US-ASCII 만 처리하도록 작성되었습니다 (즉 서 수가 0-127 범위 인 문자). 그리고 때로는 0-255의 전체 범위를 의미하는 경우에도 문서와 주석은 여전히 ​​ASCII라는 용어를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bb45aa3bdb1623dc3032bd795cae4fbe7d4a4df0" translate="yes" xml:space="preserve">
          <source>Perl was ported to Mac OS by Matthias Neeracher &amp;lt;neeracher@mac.com&amp;gt;. Chris Nandor &amp;lt;pudge@pobox.com&amp;gt; continued development and maintenance for the duration of the port's life.</source>
          <target state="translated">Perl은 Matthias Neeracher &amp;lt;neeracher@mac.com&amp;gt;에 의해 Mac OS로 이식되었습니다. Chris Nandor &amp;lt;pudge@pobox.com&amp;gt;은 항구의 수명 기간 동안 개발 및 유지 관리를 계속했습니다.</target>
        </trans-unit>
        <trans-unit id="5ead554bbd070f695e13f79404f4e374bc4948d2" translate="yes" xml:space="preserve">
          <source>Perl websites come in a variety of forms, but they fit into two large categories: forums and news websites. There are many Perl-related websites, so only a few of the community's largest are mentioned here.</source>
          <target state="translated">Perl 웹 사이트는 다양한 형태로 제공되지만 포럼과 뉴스 웹 사이트의 두 가지 큰 범주에 속합니다. Perl 관련 웹 사이트는 많으므로 여기에서 커뮤니티 최대 규모의 웹 사이트 중 일부만 언급됩니다.</target>
        </trans-unit>
        <trans-unit id="96b1e3be8ed57ad80c83e18b4ef34638cdbe949f" translate="yes" xml:space="preserve">
          <source>Perl will always interpret this as a method call.</source>
          <target state="translated">펄은 이것을 항상 메소드 호출로 해석합니다.</target>
        </trans-unit>
        <trans-unit id="108590eaf1947f78469e9a64442a6238023bfc97" translate="yes" xml:space="preserve">
          <source>Perl will always match at the earliest possible point in the string:</source>
          <target state="translated">펄은 항상 문자열의 가장 빠른 지점에서 일치합니다 :</target>
        </trans-unit>
        <trans-unit id="dab60b10c40a3d1c155299bacd4f38f02082cabc" translate="yes" xml:space="preserve">
          <source>Perl will attempt to flush all files opened for output before any operation that may do a fork, but this may not be supported on some platforms (see &lt;a href=&quot;../perlport&quot;&gt;perlport&lt;/a&gt;). To be safe, you may need to set &lt;code&gt;$|&lt;/code&gt; ($AUTOFLUSH in English) or call the &lt;code&gt;autoflush()&lt;/code&gt; method of &lt;code&gt;IO::Handle&lt;/code&gt; on any open handles.</source>
          <target state="translated">Perl은 포크를 수행 할 수있는 조작 전에 출력을 위해 열린 모든 파일을 비우려고 시도하지만 일부 플랫폼에서는 지원되지 않을 수 있습니다 ( &lt;a href=&quot;../perlport&quot;&gt;perlport&lt;/a&gt; 참조 ). 안전을 위해 &lt;code&gt;$|&lt;/code&gt; 를 설정해야 할 수도 있습니다. 열려있는 &lt;code&gt;IO::Handle&lt;/code&gt; 에서 IO :: Handle 의 &lt;code&gt;autoflush()&lt;/code&gt; 메소드를 호출하십시오 ( 영어로 $ AUTOFLUSH) .</target>
        </trans-unit>
        <trans-unit id="cbb77319c3caa8ab8afaeca5e241bd4affc14078" translate="yes" xml:space="preserve">
          <source>Perl will attempt to flush all files opened for output before any operation that may do a fork, but this may not be supported on some platforms (see &lt;a href=&quot;perlport&quot;&gt;perlport&lt;/a&gt;). To be safe, you may need to set &lt;a href=&quot;perlvar#%24%7C&quot;&gt;&lt;code&gt;$|&lt;/code&gt;&lt;/a&gt; (&lt;code&gt;$AUTOFLUSH&lt;/code&gt; in &lt;a href=&quot;english&quot;&gt;English&lt;/a&gt;) or call the &lt;code&gt;autoflush&lt;/code&gt; method of &lt;a href=&quot;IO::Handle#METHODS&quot;&gt;&lt;code&gt;IO::Handle&lt;/code&gt;&lt;/a&gt; on any open handles.</source>
          <target state="translated">Perl은 포크를 수행 할 수있는 작업 전에 출력을 위해 열려있는 모든 파일을 플러시하려고 시도하지만 일부 플랫폼에서는 지원되지 않을 수 있습니다 ( &lt;a href=&quot;perlport&quot;&gt;perlport&lt;/a&gt; 참조 ). 안전을 위해 &lt;a href=&quot;perlvar#%24%7C&quot;&gt; &lt;code&gt;$|&lt;/code&gt; &lt;/a&gt; 를 설정해야 할 수도 있습니다. ( &lt;code&gt;$AUTOFLUSH&lt;/code&gt; 에서 &lt;a href=&quot;english&quot;&gt;영어&lt;/a&gt; ) 또는 전화 &lt;code&gt;autoflush&lt;/code&gt; 방법 &lt;a href=&quot;IO::Handle#METHODS&quot;&gt; &lt;code&gt;IO::Handle&lt;/code&gt; &lt;/a&gt; 열려있는 모든 핸들에 있습니다.</target>
        </trans-unit>
        <trans-unit id="43b0e0c3bc56ba7ca3959a0f5e022566b0153f54" translate="yes" xml:space="preserve">
          <source>Perl will attempt to flush all files opened for output before any operation that may do a fork, but this may not be supported on some platforms (see &lt;a href=&quot;perlport&quot;&gt;perlport&lt;/a&gt;). To be safe, you may need to set &lt;code&gt;$|&lt;/code&gt; ($AUTOFLUSH in English) or call the &lt;code&gt;autoflush()&lt;/code&gt; method of &lt;code&gt;IO::Handle&lt;/code&gt; on any open handles.</source>
          <target state="translated">Perl은 포크를 수행 할 수있는 조작 전에 출력을 위해 열린 모든 파일을 비우려고 시도하지만 일부 플랫폼에서는 지원되지 않을 수 있습니다 ( &lt;a href=&quot;perlport&quot;&gt;perlport&lt;/a&gt; 참조 ). 안전을 위해 &lt;code&gt;$|&lt;/code&gt; 를 설정해야 할 수도 있습니다. 열려있는 &lt;code&gt;IO::Handle&lt;/code&gt; 에서 IO :: Handle 의 &lt;code&gt;autoflush()&lt;/code&gt; 메소드를 호출하십시오 ( 영어로 $ AUTOFLUSH) .</target>
        </trans-unit>
        <trans-unit id="2d8b585d320f38f1a30c6c32f686d7f733f4dca8" translate="yes" xml:space="preserve">
          <source>Perl will attempt to flush all files opened for output before starting the child process, but this may not be supported on some platforms (see &lt;a href=&quot;perlport&quot;&gt;perlport&lt;/a&gt;). To be safe, you may need to set &lt;code&gt;$|&lt;/code&gt; (&lt;code&gt;$AUTOFLUSH&lt;/code&gt; in &lt;code&gt;&lt;a href=&quot;english&quot;&gt;English&lt;/a&gt;&lt;/code&gt;) or call the &lt;code&gt;autoflush()&lt;/code&gt; method of &lt;code&gt;&lt;a href=&quot;IO::Handle&quot;&gt;IO::Handle&lt;/a&gt;&lt;/code&gt; on any open handles.</source>
          <target state="translated">Perl은 자식 프로세스를 시작하기 전에 출력을 위해 열려있는 모든 파일을 플러시하려고 시도하지만 일부 플랫폼에서는 지원되지 않을 수 있습니다 ( &lt;a href=&quot;perlport&quot;&gt;perlport&lt;/a&gt; 참조 ). 안전을 위해 &lt;code&gt;$|&lt;/code&gt; 를 설정해야 할 수도 있습니다. ( &lt;code&gt;$AUTOFLUSH&lt;/code&gt; in &lt;code&gt;&lt;a href=&quot;english&quot;&gt;English&lt;/a&gt;&lt;/code&gt; ) 또는 열려있는 &lt;code&gt;&lt;a href=&quot;IO::Handle&quot;&gt;IO::Handle&lt;/a&gt;&lt;/code&gt; 에서 IO :: Handle 의 &lt;code&gt;autoflush()&lt;/code&gt; 메서드를 호출 합니다.</target>
        </trans-unit>
        <trans-unit id="6bea16b3be61058b5cb516538e14480b80e24dcc" translate="yes" xml:space="preserve">
          <source>Perl will attempt to flush all files opened for output before starting the child process, but this may not be supported on some platforms (see &lt;a href=&quot;perlport&quot;&gt;perlport&lt;/a&gt;). To be safe, you may need to set &lt;code&gt;$|&lt;/code&gt; (&lt;code&gt;$AUTOFLUSH&lt;/code&gt; in &lt;code&gt;&lt;a href=&quot;english&quot;&gt;English&lt;/a&gt;&lt;/code&gt;) or call the &lt;code&gt;autoflush()&lt;/code&gt; method of &lt;code&gt;&lt;a href=&quot;io/handle&quot;&gt;IO::Handle&lt;/a&gt;&lt;/code&gt; on any open handles.</source>
          <target state="translated">Perl은 하위 프로세스를 시작하기 전에 출력을 위해 열린 모든 파일을 비우려고 시도하지만 일부 플랫폼에서는 지원되지 않을 수 있습니다 ( &lt;a href=&quot;perlport&quot;&gt;perlport&lt;/a&gt; 참조 ). 안전을 위해 &lt;code&gt;$|&lt;/code&gt; 를 설정해야합니다. ( &lt;code&gt;$AUTOFLUSH&lt;/code&gt; 에서 &lt;code&gt;&lt;a href=&quot;english&quot;&gt;English&lt;/a&gt;&lt;/code&gt; ) 또는 전화 &lt;code&gt;autoflush()&lt;/code&gt; 방법 &lt;code&gt;&lt;a href=&quot;io/handle&quot;&gt;IO::Handle&lt;/a&gt;&lt;/code&gt; 열려있는 모든 핸들에 있습니다.</target>
        </trans-unit>
        <trans-unit id="69e6c1ab664ef4d480c4cc1af41e9e1fb158cde3" translate="yes" xml:space="preserve">
          <source>Perl will completely read from all open directory handles until they reach the end of the stream. It will then seekdir() back to the original location and all future readdir() requests will be fulfilled from the cache buffer. That means that neither the directory handle held by the parent process nor the one held by the child process will see any changes made to the directory after the fork() call.</source>
          <target state="translated">Perl은 스트림의 끝에 도달 할 때까지 열려있는 모든 디렉토리 핸들에서 완전히 읽습니다. 그런 다음 seekdir ()을 원래 위치로 되돌리고 이후의 모든 readdir () 요청이 캐시 버퍼에서 이행됩니다. 즉, 부모 프로세스가 보유한 디렉토리 핸들이나 자식 프로세스가 보유한 디렉토리 핸들은 fork () 호출 후 디렉토리에 대한 변경 사항을 볼 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="ae724785888abcc4558016f3ec47b4f4e63fe38a" translate="yes" xml:space="preserve">
          <source>Perl will generate an error for a few character properties in Unicode when used in a regular expression. The non-Unihan ones are listed below, with the reasons they are not accepted, perhaps with work-arounds. The short names for the properties are listed enclosed in (parentheses). As described after the list, an installation can change the defaults and choose to accept any of these. The list is machine generated based on the choices made for the installation that generated this document.</source>
          <target state="translated">Perl은 정규식에 사용될 때 유니 코드로 몇 문자 특성에 대한 오류를 생성합니다. Unihan 이외의 제품은 아래에 나열되어 있으며 허용되지 않는 이유, 아마도 해결 방법이 있습니다. 속성의 짧은 이름은 괄호 안에 표시됩니다. 목록 다음에 설명 된대로 설치는 기본값을 변경하고 이들 중 하나를 채택하도록 선택할 수 있습니다. 이 목록은이 문서를 생성 한 설치에 대한 선택 사항을 기반으로 생성 된 시스템입니다.</target>
        </trans-unit>
        <trans-unit id="8b82b63566b58bfbfd5f88517a9ea3598fc70e2d" translate="yes" xml:space="preserve">
          <source>Perl will not guarantee what the result of the above statements is.</source>
          <target state="translated">Perl은 위 진술의 결과가 무엇인지 보증하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ad11d6c2aaa2cf9eed67c4c4a37abbefb094f00c" translate="yes" xml:space="preserve">
          <source>Perl will print</source>
          <target state="translated">펄이 인쇄합니다</target>
        </trans-unit>
        <trans-unit id="bf866573cd4df8609484c1bf4b87543aa847fff1" translate="yes" xml:space="preserve">
          <source>Perl will print &lt;code&gt;ONCE UPON A TIME THERE WAS&lt;/code&gt; , assuming, of course, that</source>
          <target state="translated">물론 펄은 한 &lt;code&gt;ONCE UPON A TIME THERE WAS&lt;/code&gt; 인쇄 할 것 입니다.</target>
        </trans-unit>
        <trans-unit id="c9125a8fdf67019b69d1e6b1d55295e266cee711" translate="yes" xml:space="preserve">
          <source>Perl will print &lt;code&gt;ONCE UPON A TIME THERE WAS&lt;/code&gt;, assuming, of course, that</source>
          <target state="translated">Perl은 당연히 다음과 같이 가정하여 &lt;code&gt;ONCE UPON A TIME THERE WAS&lt;/code&gt; 인쇄 합니다.</target>
        </trans-unit>
        <trans-unit id="ef9a0a9d3a3fd7fe149a4004c226420f095952a0" translate="yes" xml:space="preserve">
          <source>Perl will start PM programs from VIO (=text-mode) Perl process in a separate PM session; the opposite is not true: when you start a non-PM program from a PM Perl process, Perl would not run it in a separate session. If a separate session is desired, either ensure that shell will be used, as in &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt; 'cmd /c myprog'&lt;/code&gt; , or start it using optional arguments to system() documented in &lt;code&gt;OS2::Process&lt;/code&gt; module. This is considered to be a feature.</source>
          <target state="translated">Perl은 별도의 PM 세션에서 VIO (= 텍스트 모드) Perl 프로세스에서 PM 프로그램을 시작합니다. PM Perl 프로세스에서 비 PM 프로그램을 시작할 때 Perl은 별도의 세션에서 실행하지 않습니다. 별도의 세션이 필요한 경우, &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt; 'cmd /c myprog'&lt;/code&gt; 에서와 같이 쉘이 사용되는지 확인 하거나 &lt;code&gt;OS2::Process&lt;/code&gt; 모듈에 문서화 된 system ()에 대한 선택적 인수를 사용하여 쉘을 시작하십시오 . 이것은 기능으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="78588e527fc97bd83af2c6a428985bc498ac231c" translate="yes" xml:space="preserve">
          <source>Perl will start PM programs from VIO (=text-mode) Perl process in a separate PM session; the opposite is not true: when you start a non-PM program from a PM Perl process, Perl would not run it in a separate session. If a separate session is desired, either ensure that shell will be used, as in &lt;code&gt;system 'cmd /c myprog'&lt;/code&gt;, or start it using optional arguments to system() documented in &lt;code&gt;OS2::Process&lt;/code&gt; module. This is considered to be a feature.</source>
          <target state="translated">Perl은 별도의 PM 세션에서 VIO (= 텍스트 모드) Perl 프로세스에서 PM 프로그램을 시작합니다. 그 반대는 사실이 아닙니다. PM Perl 프로세스에서 PM이 아닌 프로그램을 시작할 때 Perl은이를 별도의 세션에서 실행하지 않습니다. 별도의 세션이 필요한 경우 &lt;code&gt;system 'cmd /c myprog'&lt;/code&gt; 에서와 같이 셸이 사용되는지 확인 하거나 &lt;code&gt;OS2::Process&lt;/code&gt; 모듈에 문서화 된 system ()에 대한 선택적 인수를 사용하여 시작합니다 . 이것은 기능으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="79467cc317c9e9a63f21c7fa1de773705edf809c" translate="yes" xml:space="preserve">
          <source>Perl word completion module</source>
          <target state="translated">펄 단어 완성 모듈</target>
        </trans-unit>
        <trans-unit id="5a1baab191c5a4cbb8bc8a1bc0cd6292ba8ea600" translate="yes" xml:space="preserve">
          <source>Perl works on a bewildering variety of Unix and Unix-like platforms (see e.g. most of the files in the</source>
          <target state="translated">Perl은 놀랍도록 다양한 Unix 및 Unix와 유사한 플랫폼에서 작동합니다 (예 :</target>
        </trans-unit>
        <trans-unit id="5f937e1c9658905a769f6858da3294349601c8d9" translate="yes" xml:space="preserve">
          <source>Perl works with UTF-EBCDIC, a multi-byte encoding. In Perls earlier than v5.22, there may be various bugs in this regard.</source>
          <target state="translated">Perl은 멀티 바이트 인코딩 인 UTF-EBCDIC과 함께 작동합니다. v5.22 이전의 Perls에서는 이와 관련하여 다양한 버그가있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="42414ebda9bd8b337ff75ba9b25023988eae655b" translate="yes" xml:space="preserve">
          <source>Perl workshops are, as the name might suggest, workshops where Perl is taught in a variety of ways. At the workshops, subjects range from a beginner's introduction (such as the Pittsburgh Perl Workshop's &quot;Zero To Perl&quot;) to much more advanced subjects.</source>
          <target state="translated">펄 워크샵은 이름에서 알 수 있듯이 펄이 다양한 방식으로 가르치는 워크샵입니다. 워크샵에서는 피츠버그 펄 워크샵의 &quot;제로 투 펄 (Zero To Perl)&quot;과 같은 초보자 소개부터 고급 과목까지 다양한 과목이 있습니다.</target>
        </trans-unit>
        <trans-unit id="7e6b25cba02b7a0948e7b911d7360593ba8a4f62" translate="yes" xml:space="preserve">
          <source>Perl&amp;rsquo;s &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;functions/format&quot;&gt;format&lt;/a&gt;&lt;/code&gt; think all codepoints take up 1 print column, but many take 0 or 2. Here to show that normalization makes no difference, we print out both forms:</source>
          <target state="translated">Perl의 &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;functions/format&quot;&gt;format&lt;/a&gt;&lt;/code&gt; 은 모든 코드 포인트가 1 개의 인쇄 열을 차지하지만 많은 코드가 0 또는 2를 차지한다고 생각합니다.</target>
        </trans-unit>
        <trans-unit id="df2feb6f1ec6c5fcfce646b1caa76de773ce0f59" translate="yes" xml:space="preserve">
          <source>Perl&amp;rsquo;s &lt;code&gt;printf&lt;/code&gt;, &lt;code&gt;sprintf&lt;/code&gt;, and &lt;code&gt;format&lt;/code&gt; think all codepoints take up 1 print column, but many take 0 or 2. Here to show that normalization makes no difference, we print out both forms:</source>
          <target state="translated">Perl의 &lt;code&gt;printf&lt;/code&gt; , &lt;code&gt;sprintf&lt;/code&gt; 및 &lt;code&gt;format&lt;/code&gt; 은 모든 코드 포인트가 1 개의 인쇄 열을 차지한다고 생각하지만 많은 코드 포인트가 0 또는 2를 차지한다고 생각합니다. 여기서 정규화가 차이가 없음을 보여주기 위해 두 가지 형식을 모두 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="609b12c8bffe220b74d5c614b906ddd9f420fc60" translate="yes" xml:space="preserve">
          <source>Perl's</source>
          <target state="translated">Perl's</target>
        </trans-unit>
        <trans-unit id="e5e5cc8de2d6897fcdb211dcd0cc9ecba9c81faf" translate="yes" xml:space="preserve">
          <source>Perl's &quot;use integer&quot; might change the behaviour of % and / for scalars. This is because under 'use integer' Perl does what the underlying C library thinks is right, and this varies. However, &quot;use integer&quot; does not change the way things are done with Math::BigInt objects.</source>
          <target state="translated">Perl의 &quot;정수 사용&quot;은 스칼라에 대한 % 및 /의 동작을 변경할 수 있습니다. 이것은 '정수 사용'에서 Perl이 기본 C 라이브러리가 옳다고 생각하는 작업을 수행하기 때문이며 이는 다양합니다. 그러나 &quot;정수 사용&quot;은 Math :: BigInt 객체로 작업이 수행되는 방식을 변경하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c4304adeb0f8bf2fdb8cb6a0ee28ba6a82fef1c9" translate="yes" xml:space="preserve">
          <source>Perl's 'use integer;' changes the behaviour of % and / for scalars, but will not change BigInt's way to do things. This is because under 'use integer' Perl will do what the underlying C thinks is right and this is different for each system. If you need BigInt's behaving exactly like Perl's 'use integer', bug the author to implement it ;)</source>
          <target state="translated">펄의 '정수 사용'; 스칼라에 대한 % 및 /의 동작을 변경하지만 BigInt의 작업 방식은 변경하지 않습니다. 이는 '정수 사용'에서 Perl이 기본 C가 옳다고 생각하는 것을 수행하기 때문에 각 시스템마다 다릅니다. BigInt가 Perl의 '정수 사용'과 똑같이 작동 해야하는 경우 작성자에게 버그를 적용하여 구현하십시오.)</target>
        </trans-unit>
        <trans-unit id="064e821c3cc7d30b6bfa1d90af859d75eba797c0" translate="yes" xml:space="preserve">
          <source>Perl's &lt;a href=&quot;#sprintf-FORMAT%2C-LIST&quot;&gt;&lt;code&gt;sprintf&lt;/code&gt;&lt;/a&gt; permits the following universally-known conversions:</source>
          <target state="translated">Perl의 &lt;a href=&quot;#sprintf-FORMAT%2C-LIST&quot;&gt; &lt;code&gt;sprintf&lt;/code&gt; &lt;/a&gt; 는 다음과 같은 보편적으로 알려진 변환을 허용합니다.</target>
        </trans-unit>
        <trans-unit id="78408db0ece90050f47f78be2d21f98042f5d6be" translate="yes" xml:space="preserve">
          <source>Perl's &lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf&lt;/a&gt;&lt;/code&gt; permits the following universally-known conversions:</source>
          <target state="translated">Perl의 &lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf&lt;/a&gt;&lt;/code&gt; 는 다음과 같이 널리 알려진 변환을 허용합니다.</target>
        </trans-unit>
        <trans-unit id="679bce65e9c564373f478362e333d0a68acc42d5" translate="yes" xml:space="preserve">
          <source>Perl's &lt;code&gt;&lt;a href=&quot;sprintf&quot;&gt;sprintf&lt;/a&gt;&lt;/code&gt; permits the following universally-known conversions:</source>
          <target state="translated">Perl의 &lt;code&gt;&lt;a href=&quot;sprintf&quot;&gt;sprintf&lt;/a&gt;&lt;/code&gt; 는 다음과 같이 널리 알려진 변환을 허용합니다.</target>
        </trans-unit>
        <trans-unit id="53cad962b7a83e25af2f6bf67e501730e16fa363" translate="yes" xml:space="preserve">
          <source>Perl's &lt;code&gt;pprivate&lt;/code&gt; structure</source>
          <target state="translated">펄의 &lt;code&gt;pprivate&lt;/code&gt; 구조</target>
        </trans-unit>
        <trans-unit id="50b7e56f45ec7b1f922cb2ef554212efaf347a1d" translate="yes" xml:space="preserve">
          <source>Perl's API has changed over time, gaining new features, new functions, increasing its flexibility, and reducing the impact on the C namespace environment (reduced pollution). The header file written by this module, typically</source>
          <target state="translated">Perl의 API는 시간이 지남에 따라 변경되어 새로운 기능, 새로운 기능을 얻고 유연성을 높이고 C 네임 스페이스 환경에 미치는 영향을 줄입니다 (오염 감소). 이 모듈에 의해 작성된 헤더 파일</target>
        </trans-unit>
        <trans-unit id="e05aa87f748ad78da85fa4d39c89ae07ccce030e" translate="yes" xml:space="preserve">
          <source>Perl's C-style &lt;code&gt;for&lt;/code&gt; loop works like the corresponding &lt;code&gt;while&lt;/code&gt; loop; that means that this:</source>
          <target state="translated">Perl의 C 스타일 &lt;code&gt;for&lt;/code&gt; 루프는 해당 &lt;code&gt;while&lt;/code&gt; 루프 와 유사하게 작동 합니다. 이는 다음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="5db9c37ab5f7f0381d150d83940e69ede28d72bd" translate="yes" xml:space="preserve">
          <source>Perl's IO. Consequently only built-in layers can appear in this list, as external layers (such as &lt;code&gt;:encoding()&lt;/code&gt; ) need IO in order to load them! See &lt;a href=&quot;open&quot;&gt;open pragma&lt;/a&gt; for how to add external encodings as defaults.</source>
          <target state="translated">펄의 IO. 따라서 외부 레이어 (예 &lt;code&gt;:encoding()&lt;/code&gt; )를로드하려면 IO가 필요하므로 내장 레이어 만이 목록에 나타날 수 있습니다! 외부 인코딩을 기본값으로 추가하는 방법 은 &lt;a href=&quot;open&quot;&gt;open pragma&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b76c3fa97974625df89eb014ff16153ff4616729" translate="yes" xml:space="preserve">
          <source>Perl's IO. Consequently only built-in layers can appear in this list, as external layers (such as &lt;code&gt;:encoding()&lt;/code&gt;) need IO in order to load them! See &lt;a href=&quot;open&quot;&gt;&quot;open pragma&quot;&lt;/a&gt; for how to add external encodings as defaults.</source>
          <target state="translated">Perl의 IO. 결과적으로 내장 레이어 만이 목록에 나타날 수 있습니다. 외부 레이어 (예 &lt;code&gt;:encoding()&lt;/code&gt; )를로드하려면 IO가 필요하기 때문입니다! 외부 인코딩을 기본값으로 추가하는 방법 은 &lt;a href=&quot;open&quot;&gt;&quot;open pragma&quot;&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="4a012002430e5ec63e7214212c95e7a6c13798d5" translate="yes" xml:space="preserve">
          <source>Perl's OO system is class-based. Class-based OO is fairly common. It's used by Java, C++, C#, Python, Ruby, and many other languages. There are other object orientation paradigms as well. JavaScript is the most popular language to use another paradigm. JavaScript's OO system is prototype-based.</source>
          <target state="translated">Perl의 OO 시스템은 클래스 기반입니다. 클래스 기반 OO는 상당히 일반적입니다. Java, C ++, C #, Python, Ruby 및 기타 여러 언어에서 사용됩니다. 다른 객체 지향 패러다임도 있습니다. JavaScript는 다른 패러다임을 사용하는 가장 인기있는 언어입니다. JavaScript의 OO 시스템은 프로토 타입 기반입니다.</target>
        </trans-unit>
        <trans-unit id="9806e03898721874442226704be9b61686d35f9b" translate="yes" xml:space="preserve">
          <source>Perl's TIEHANDLE spec was incomplete prior to 5.005_57; it was missing support for &lt;code&gt;seek()&lt;/code&gt;, &lt;code&gt;tell()&lt;/code&gt;, and &lt;code&gt;eof()&lt;/code&gt;. Attempting to use these functions with an IO::Scalar will not work prior to 5.005_57. IO::Scalar will not have the relevant methods invoked; and even worse, this kind of bug can lie dormant for a while. If you turn warnings on (via &lt;code&gt;$^W&lt;/code&gt; or &lt;code&gt;perl -w&lt;/code&gt;), and you see something like this...</source>
          <target state="translated">Perl의 TIEHANDLE 사양은 5.005_57 이전에는 불완전했습니다. &lt;code&gt;seek()&lt;/code&gt; , &lt;code&gt;tell()&lt;/code&gt; 및 &lt;code&gt;eof()&lt;/code&gt; 대한 지원이 누락되었습니다 . IO :: Scalar와 함께 이러한 기능을 사용하려고하면 5.005_57 이전에는 작동하지 않습니다. IO :: Scalar는 관련 메서드를 호출하지 않습니다. 더 나쁜 것은 이런 종류의 버그가 잠시 동안 휴면 상태로있을 수 있다는 것입니다. 경고를 켜면 ( &lt;code&gt;$^W&lt;/code&gt; 또는 &lt;code&gt;perl -w&lt;/code&gt; 를 통해 ) 다음과 같은 내용이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="f14833bc12320cc5b22e2f7f5922dcba8b20a6ea" translate="yes" xml:space="preserve">
          <source>Perl's Unicode Model</source>
          <target state="translated">Perl의 유니 코드 모델</target>
        </trans-unit>
        <trans-unit id="78c1f3e5a87cf4bde2cfaf198cd9b736e054adc6" translate="yes" xml:space="preserve">
          <source>Perl's Unicode Support</source>
          <target state="translated">Perl의 유니 코드 지원</target>
        </trans-unit>
        <trans-unit id="2f4e8610ccf72680ce428d05cdb3a44400f56202" translate="yes" xml:space="preserve">
          <source>Perl's arrays do not have a fixed size, so you don't need linked lists if you just want to add or remove items. You can use array operations such as &lt;code&gt;&lt;a href=&quot;functions/push&quot;&gt;push&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/pop&quot;&gt;pop&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/shift&quot;&gt;shift&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/unshift&quot;&gt;unshift&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;functions/splice&quot;&gt;splice&lt;/a&gt;&lt;/code&gt; to do that.</source>
          <target state="translated">Perl의 배열은 크기가 고정되어 있지 않으므로 항목을 추가하거나 제거하려는 경우 링크 된 목록이 필요하지 않습니다. &lt;code&gt;&lt;a href=&quot;functions/push&quot;&gt;push&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/pop&quot;&gt;pop&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/shift&quot;&gt;shift&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/unshift&quot;&gt;unshift&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;functions/splice&quot;&gt;splice&lt;/a&gt;&lt;/code&gt; 와 같은 배열 작업을 사용 하여이를 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="180c125ddac8494f8c8cf2f82ef0744802e2f7e3" translate="yes" xml:space="preserve">
          <source>Perl's arrays do not have a fixed size, so you don't need linked lists if you just want to add or remove items. You can use array operations such as &lt;code&gt;push&lt;/code&gt;, &lt;code&gt;pop&lt;/code&gt;, &lt;code&gt;shift&lt;/code&gt;, &lt;code&gt;unshift&lt;/code&gt;, or &lt;code&gt;splice&lt;/code&gt; to do that.</source>
          <target state="translated">Perl의 배열은 고정 된 크기가 아니므로 항목을 추가하거나 제거하려는 경우 연결 목록이 필요하지 않습니다. &lt;code&gt;push&lt;/code&gt; , &lt;code&gt;pop&lt;/code&gt; , &lt;code&gt;shift&lt;/code&gt; , &lt;code&gt;unshift&lt;/code&gt; 또는 &lt;code&gt;splice&lt;/code&gt; 와 같은 배열 작업을 사용 하여이를 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f0829cd34f91158f6d50d3501d1729557f626943" translate="yes" xml:space="preserve">
          <source>Perl's basic open() statement can also be used for unidirectional interprocess communication by either appending or prepending a pipe symbol to the second argument to open(). Here's how to start something up in a child process you intend to write to:</source>
          <target state="translated">Perl의 기본 open () 문은 파이프 기호를 open ()의 두 번째 인수에 추가하거나 추가하여 단방향 프로세스 간 통신에 사용할 수도 있습니다. 작성하려는 하위 프로세스에서 무언가를 시작하는 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d1c613eb863cbd84885db8255f46385590e7af47" translate="yes" xml:space="preserve">
          <source>Perl's basic open() statement can also be used for unidirectional interprocess communication by specifying the open mode as &lt;code&gt;|-&lt;/code&gt; or &lt;code&gt;-|&lt;/code&gt;. Here's how to start something up in a child process you intend to write to:</source>
          <target state="translated">Perl의 기본 open () 문은 개방 모드를 &lt;code&gt;|-&lt;/code&gt; 또는 &lt;code&gt;-|&lt;/code&gt; 로 지정하여 단방향 프로세스 간 통신에도 사용할 수 있습니다. . 작성하려는 자식 프로세스에서 무언가를 시작하는 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f7f15224970f30bbd8cc0d913eabc8b8733adcd9" translate="yes" xml:space="preserve">
          <source>Perl's built-in introspection features are fairly minimal. &lt;code&gt;Moose&lt;/code&gt; builds on top of them and creates a full introspection layer for your classes. This lets you ask questions like &quot;what methods does the File class implement?&quot; It also lets you modify your classes programmatically.</source>
          <target state="translated">Perl의 내장 검사 기능은 매우 작습니다. &lt;code&gt;Moose&lt;/code&gt; 는 그 위에 빌드하고 클래스에 대한 전체 내성 레이어를 만듭니다. &quot;File 클래스는 어떤 메소드를 구현합니까?&quot;와 같은 질문을 할 수 있습니다. 또한 프로그래밍 방식으로 클래스를 수정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="45287a14757d133ee14640bcf6c328a91774bc92" translate="yes" xml:space="preserve">
          <source>Perl's builtin flock() function (see &lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt; for details) will call flock(2) if that exists, fcntl(2) if it doesn't (on perl version 5.004 and later), and lockf(3) if neither of the two previous system calls exists. On some systems, it may even use a different form of native locking. Here are some gotchas with Perl's flock():</source>
          <target state="translated">Perl의 내장 flock () 함수 (자세한 내용은 &lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt; 참조)는 flock (2) (존재하는 경우), fcntl (2) (존재하지 않는 경우 (perl 버전 5.004 이상) 및 f2 (3)) 이전 시스템 호출이 존재합니다. 일부 시스템에서는 다른 형식의 기본 잠금을 사용할 수도 있습니다. 다음은 Perl의 flock ()과 관련된 몇 가지 문제입니다.</target>
        </trans-unit>
        <trans-unit id="4e23292bcea30aa529b568a400bba32042a7e37e" translate="yes" xml:space="preserve">
          <source>Perl's characters are stored internally as sequences of one or more bytes. This pragma allows for the examination of the individual bytes that together comprise a character.</source>
          <target state="translated">Perl의 문자는 내부적으로 하나 이상의 바이트 시퀀스로 저장됩니다. 이 pragma를 사용하면 문자를 함께 구성하는 개별 바이트를 검사 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f507c173df4e9952b98c777db1766156932095e8" translate="yes" xml:space="preserve">
          <source>Perl's documentation is an important resource for our users. It's incredibly important for Perl's documentation to be reasonably coherent and to accurately reflect the current implementation.</source>
          <target state="translated">Perl의 문서는 사용자에게 중요한 자료입니다. Perl의 문서가 합리적으로 일관성 있고 현재 구현을 정확하게 반영하는 것이 매우 중요합니다.</target>
        </trans-unit>
        <trans-unit id="8e7bbfdbc61f02638ca2efad632597e1e0cf6bad" translate="yes" xml:space="preserve">
          <source>Perl's engine sets this flag if the pattern is &lt;code&gt;\s+&lt;/code&gt;.</source>
          <target state="translated">패턴이 &lt;code&gt;\s+&lt;/code&gt; 경우 Perl 엔진은이 플래그를 설정합니다 .</target>
        </trans-unit>
        <trans-unit id="c7dfeaf28529f5593bf2febfb63757ff3cbe501b" translate="yes" xml:space="preserve">
          <source>Perl's engine sets this flag on empty patterns, this optimization makes &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt; //&lt;/code&gt; much faster than it would otherwise be. It's even faster than &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Perl의 엔진은이 플래그를 빈 패턴으로 설정하는데,이 최적화는 &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt; //&lt;/code&gt; 다른 방법보다 훨씬 빠르게 &lt;a href=&quot;functions/split&quot;&gt;분할&lt;/a&gt; 됩니다. &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; 보다 빠릅니다 .</target>
        </trans-unit>
        <trans-unit id="a12b92b4349d16b75893487c4da574782b294666" translate="yes" xml:space="preserve">
          <source>Perl's engine sets this flag on empty patterns, this optimization makes &lt;code&gt;split //&lt;/code&gt; much faster than it would otherwise be. It's even faster than &lt;code&gt;unpack&lt;/code&gt;.</source>
          <target state="translated">Perl의 엔진은 빈 패턴에이 플래그를 설정합니다.이 최적화는 &lt;code&gt;split //&lt;/code&gt; 그렇지 않은 경우보다 훨씬 빠르게 만듭니다 . &lt;code&gt;unpack&lt;/code&gt; 것보다 훨씬 빠릅니다 .</target>
        </trans-unit>
        <trans-unit id="ae0e4b0c5f9f6cc7920bb5bbdeff06433a976d20" translate="yes" xml:space="preserve">
          <source>Perl's engine sets this if the pattern is &lt;code&gt;/^/&lt;/code&gt; (&lt;code&gt;plen == 1 &amp;amp;&amp;amp; *exp
== '^'&lt;/code&gt; ), even under &lt;code&gt;/^/s&lt;/code&gt; ; see &lt;a href=&quot;perlfunc&quot;&gt;split&lt;/a&gt;. Of course a different regex engine might want to use the same optimizations with a different syntax.</source>
          <target state="translated">패턴이 &lt;code&gt;/^/&lt;/code&gt; ( &lt;code&gt;plen == 1 &amp;amp;&amp;amp; *exp == '^'&lt;/code&gt; ), &lt;code&gt;/^/s&lt;/code&gt; 아래 인 경우 Perl의 엔진이이를 설정합니다 . &lt;a href=&quot;perlfunc&quot;&gt;split&lt;/a&gt; 참조하십시오 . 물론 다른 정규식 엔진은 다른 구문으로 동일한 최적화를 사용하려고 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="491c64f9a6d1d02d83e18cbec69820885ad456fd" translate="yes" xml:space="preserve">
          <source>Perl's engine sets this if the pattern is &lt;code&gt;/^/&lt;/code&gt; (&lt;code&gt;plen == 1 &amp;amp;&amp;amp; *exp == '^'&lt;/code&gt;), even under &lt;code&gt;/^/s&lt;/code&gt;; see &lt;a href=&quot;perlfunc&quot;&gt;split&lt;/a&gt;. Of course a different regex engine might want to use the same optimizations with a different syntax.</source>
          <target state="translated">Perl의 엔진은 패턴이 &lt;code&gt;/^/&lt;/code&gt; ( &lt;code&gt;plen == 1 &amp;amp;&amp;amp; *exp == '^'&lt;/code&gt; ) 인 경우이를 설정합니다. &lt;code&gt;/^/s&lt;/code&gt; ; &lt;a href=&quot;perlfunc&quot;&gt;분할&lt;/a&gt; 참조 . 물론 다른 정규식 엔진은 다른 구문으로 동일한 최적화를 사용하려고 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7f1c7280d32070c89f6f598972838907640e2c7c" translate="yes" xml:space="preserve">
          <source>Perl's exception handing (i.e. &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; etc.) is built on top of the low-level &lt;code&gt;setjmp()&lt;/code&gt; /&lt;code&gt;longjmp()&lt;/code&gt; C-library functions. These basically provide a way to capture the current PC and SP registers and later restore them; i.e. a &lt;code&gt;longjmp()&lt;/code&gt; continues at the point in code where a previous &lt;code&gt;setjmp()&lt;/code&gt; was done, with anything further up on the C stack being lost. This is why code should always save values using &lt;code&gt;SAVE_FOO&lt;/code&gt; rather than in auto variables.</source>
          <target state="translated">Perl의 예외 처리 (예 : &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; 등)는 저수준 &lt;code&gt;setjmp()&lt;/code&gt; / &lt;code&gt;longjmp()&lt;/code&gt; C 라이브러리 함수 위에 구축됩니다. 기본적으로 현재 PC 및 SP 레지스터를 캡처하고 나중에 복원 할 수있는 방법을 제공합니다. 즉, &lt;code&gt;longjmp()&lt;/code&gt; 는 코드에서 이전 &lt;code&gt;setjmp()&lt;/code&gt; 가 수행 된 지점에서 계속되며 C 스택에서 더 많은 항목이 손실됩니다. 이것이 바로 코드가 자동 변수가 아닌 &lt;code&gt;SAVE_FOO&lt;/code&gt; 를 사용하여 항상 값을 저장해야하는 이유 입니다.</target>
        </trans-unit>
        <trans-unit id="624ef0dffdfa023577d4ff52307fa87cfe9d9de6" translate="yes" xml:space="preserve">
          <source>Perl's exception handing (i.e. &lt;code&gt;die&lt;/code&gt; etc.) is built on top of the low-level &lt;code&gt;setjmp()&lt;/code&gt;/&lt;code&gt;longjmp()&lt;/code&gt; C-library functions. These basically provide a way to capture the current PC and SP registers and later restore them; i.e. a &lt;code&gt;longjmp()&lt;/code&gt; continues at the point in code where a previous &lt;code&gt;setjmp()&lt;/code&gt; was done, with anything further up on the C stack being lost. This is why code should always save values using &lt;code&gt;SAVE_FOO&lt;/code&gt; rather than in auto variables.</source>
          <target state="translated">Perl의 예외 처리 (예 : &lt;code&gt;die&lt;/code&gt; 등)는 저수준 &lt;code&gt;setjmp()&lt;/code&gt; / &lt;code&gt;longjmp()&lt;/code&gt; C 라이브러리 함수 위에 구축됩니다. 기본적으로 현재 PC 및 SP 레지스터를 캡처하고 나중에 복원하는 방법을 제공합니다. 즉, &lt;code&gt;longjmp()&lt;/code&gt; 는 이전 &lt;code&gt;setjmp()&lt;/code&gt; 가 수행 된 코드의 지점에서 계속되며 C 스택의 더 높은 항목은 손실됩니다. 이것이 코드가 항상 자동 변수가 아닌 &lt;code&gt;SAVE_FOO&lt;/code&gt; 를 사용하여 값을 저장해야하는 이유 입니다.</target>
        </trans-unit>
        <trans-unit id="e91c40c4e8331eb78a3c6f0cd54f4782d65eb5ae" translate="yes" xml:space="preserve">
          <source>Perl's exception-handling mechanism is its &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval()&lt;/a&gt;&lt;/code&gt; operator. You can use &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval()&lt;/a&gt;&lt;/code&gt; as &lt;code&gt;setjmp&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die()&lt;/a&gt;&lt;/code&gt; as &lt;code&gt;longjmp&lt;/code&gt; . For details of this, see the section on signals, especially the time-out handler for a blocking &lt;code&gt;&lt;a href=&quot;functions/flock&quot;&gt;flock()&lt;/a&gt;&lt;/code&gt; in &lt;a href=&quot;perlipc#Signals&quot;&gt;Signals in perlipc&lt;/a&gt; or the section on &quot;Signals&quot; in</source>
          <target state="translated">Perl의 예외 처리 메커니즘은 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval()&lt;/a&gt;&lt;/code&gt; 연산자입니다. &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval()&lt;/a&gt;&lt;/code&gt; 을 &lt;code&gt;setjmp&lt;/code&gt; 로 , &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die()&lt;/a&gt;&lt;/code&gt; 를 &lt;code&gt;longjmp&lt;/code&gt; 로 사용할 수 있습니다 . 이에 대한 자세한 내용은 신호 섹션, 특히 &lt;a href=&quot;perlipc#Signals&quot;&gt;perlipc의 신호에서&lt;/a&gt; 블록킹 &lt;code&gt;&lt;a href=&quot;functions/flock&quot;&gt;flock()&lt;/a&gt;&lt;/code&gt; 에 대한 시간 종료 핸들러 또는 섹션의 &quot;신호&quot;섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="9cac2f4c55e81f4acfeedcd4627b6c31b378f1bc" translate="yes" xml:space="preserve">
          <source>Perl's exception-handling mechanism is its &lt;code&gt;eval()&lt;/code&gt; operator. You can use &lt;code&gt;eval()&lt;/code&gt; as &lt;code&gt;setjmp&lt;/code&gt; and &lt;code&gt;die()&lt;/code&gt; as &lt;code&gt;longjmp&lt;/code&gt;. For details of this, see the section on signals, especially the time-out handler for a blocking &lt;code&gt;flock()&lt;/code&gt; in &lt;a href=&quot;perlipc#Signals&quot;&gt;&quot;Signals&quot; in perlipc&lt;/a&gt; or the section on &quot;Signals&quot; in</source>
          <target state="translated">Perl의 예외 처리 메커니즘은 &lt;code&gt;eval()&lt;/code&gt; 연산자입니다. &lt;code&gt;eval()&lt;/code&gt; 을 &lt;code&gt;setjmp&lt;/code&gt; 로 사용 하고 &lt;code&gt;die()&lt;/code&gt; 를 &lt;code&gt;longjmp&lt;/code&gt; 로 사용할 수 있습니다 . 이에 대한 자세한 내용은 신호 섹션, 특히 &lt;a href=&quot;perlipc#Signals&quot;&gt;perlipc의 &quot;Signals&quot;에서&lt;/a&gt; 블로킹 &lt;code&gt;flock()&lt;/code&gt; 에 대한 타임 아웃 핸들러 또는 &quot;Signals&quot;섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="7495373aa18cedc70045dae42e442c9fd6b35bbc" translate="yes" xml:space="preserve">
          <source>Perl's initial DTrace support was added, providing &lt;code&gt;&lt;a href=&quot;functions/sub&quot;&gt;sub-entry&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/sub&quot;&gt;sub-return&lt;/a&gt;&lt;/code&gt; probes.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/sub&quot;&gt;sub-entry&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;functions/sub&quot;&gt;sub-return&lt;/a&gt;&lt;/code&gt; 프로브를 제공하는 Perl의 초기 DTrace 지원이 추가되었습니다 .</target>
        </trans-unit>
        <trans-unit id="3b6888971fb1fbb4f3722d29940392de31cd3dc2" translate="yes" xml:space="preserve">
          <source>Perl's initial DTrace support was added, providing &lt;code&gt;sub-entry&lt;/code&gt; and &lt;code&gt;sub-return&lt;/code&gt; probes.</source>
          <target state="translated">Perl의 초기 DTrace 지원이 추가 되어 &lt;code&gt;sub-return&lt;/code&gt; &lt;code&gt;sub-entry&lt;/code&gt; 및 하위 반환 프로브를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="de9d9a267eecc4785713b5ac86a07e677cc17c7d" translate="yes" xml:space="preserve">
          <source>Perl's internal UTF8 flag is called &quot;UTF8&quot;, without a hyphen. It indicates whether a string is internally encoded as &quot;utf8&quot;, also without a hyphen.</source>
          <target state="translated">Perl의 내부 UTF8 플래그는 하이픈없이 &quot;UTF8&quot;이라고합니다. 문자열이 하이픈없이 내부적으로 &quot;utf8&quot;로 인코딩되는지 여부를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="964109bdae72322c39e19dfb06177d03a380e828" translate="yes" xml:space="preserve">
          <source>Perl's internal error-handling mechanisms implement &lt;code&gt;die&lt;/code&gt; (and its internal equivalents) using longjmp. If this occurs during lexing, parsing or compilation, we must ensure that any ops allocated as part of the compilation process are freed. (Older Perl versions did not adequately handle this situation: when failing a parse, they would leak ops that were stored in C &lt;code&gt;auto&lt;/code&gt; variables and not linked anywhere else.)</source>
          <target state="translated">Perl의 내부 오류 처리 메커니즘은 longjmp를 사용하여 &lt;code&gt;die&lt;/code&gt; (및 내부 등가물)를 구현 합니다. 이것이 렉싱, 구문 분석 또는 컴파일 중에 발생하는 경우 컴파일 프로세스의 일부로 할당 된 모든 작업이 해제되었는지 확인해야합니다. (이전 Perl 버전은이 상황을 적절하게 처리하지 못했습니다. 구문 분석에 실패하면 C &lt;code&gt;auto&lt;/code&gt; 변수에 저장되고 다른 곳에 연결되지 않은 작업이 유출됩니다 .)</target>
        </trans-unit>
        <trans-unit id="0c96604288539e03d84ef021ff0e6c92aef63b6c" translate="yes" xml:space="preserve">
          <source>Perl's malloc() uses bucketed allocations. Every request is rounded up to the closest bucket size available, and a bucket is taken from the pool of buckets of that size.</source>
          <target state="translated">Perl의 malloc ()은 버킷 할당을 사용합니다. 모든 요청은 사용 가능한 가장 가까운 버킷 크기로 반올림되고 해당 크기의 버킷 풀에서 버킷을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="b579bfa5793ff016b56c6d7d86928d92232797da" translate="yes" xml:space="preserve">
          <source>Perl's moaning about locale problems can be silenced by setting the environment variable &lt;code&gt;PERL_BADLANG&lt;/code&gt; to &quot;0&quot; or &quot;&quot;. This method really just sweeps the problem under the carpet: you tell Perl to shut up even when Perl sees that something is wrong. Do not be surprised if later something locale-dependent misbehaves.</source>
          <target state="translated">환경 변수 &lt;code&gt;PERL_BADLANG&lt;/code&gt; 을 &quot;0&quot;또는 &quot;&quot; 로 설정하여 로케일 문제에 대한 Perl의 신음 소리를 끌 수 있습니다 . 이 방법은 실제로 카펫 아래에서 문제를 해결합니다. Perl에게 무언가 잘못되었다고 판단 될 때도 종료하도록 지시합니다. 나중에 로케일 종속적 인 무언가가 잘못 작동하더라도 놀라지 마십시오.</target>
        </trans-unit>
        <trans-unit id="1f69de9b9e78267eea8d1d7d32a8294de0865cf8" translate="yes" xml:space="preserve">
          <source>Perl's operator overloading facility is completely ignored here. Operator overloading allows user-defined behaviors for numbers, such as operations over arbitrarily large integers, floating points numbers with arbitrary precision, operations over &quot;exotic&quot; numbers such as modular arithmetic or p-adic arithmetic, and so on. See &lt;a href=&quot;overload&quot;&gt;overload&lt;/a&gt; for details.</source>
          <target state="translated">Perl의 연산자 과부하 기능은 여기서 완전히 무시됩니다. 연산자 오버로딩은 임의의 큰 정수에 대한 연산, 임의의 정밀도를 갖는 부동 소수점 수, 모듈 식 산술 또는 p- 아 디드 산술과 같은 &quot;이국적인&quot;숫자에 대한 연산 등과 같은 숫자에 대한 사용자 정의 동작을 허용합니다. 자세한 내용은 &lt;a href=&quot;overload&quot;&gt;과부하&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="669d7e9913d51876345768dad50e148946b6d1f0" translate="yes" xml:space="preserve">
          <source>Perl's own engine will croak on any attempt to modify the capture variables, to do this in another engine use the following callback (copied from &lt;code&gt;Perl_reg_numbered_buff_store&lt;/code&gt; ):</source>
          <target state="translated">Perl의 자체 엔진은 캡처 변수를 수정하려고 시도 할 때 &lt;code&gt;Perl_reg_numbered_buff_store&lt;/code&gt; 다음 엔진에서이를 수행하려면 다음 콜백 ( Perl_reg_numbered_buff_store 에서 복사 )을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="532111a8d37e622ace362d3c82b8583e84a70c42" translate="yes" xml:space="preserve">
          <source>Perl's own engine will croak on any attempt to modify the capture variables, to do this in another engine use the following callback (copied from &lt;code&gt;Perl_reg_numbered_buff_store&lt;/code&gt;):</source>
          <target state="translated">Perl의 자체 엔진은 캡처 변수를 수정하려는 시도에 대해 &lt;code&gt;Perl_reg_numbered_buff_store&lt;/code&gt; 다른 엔진에서이를 수행하기 위해 다음 콜백을 사용합니다 ( Perl_reg_numbered_buff_store 에서 복사 됨 ).</target>
        </trans-unit>
        <trans-unit id="6c9f49d7c7e821b89479c1f1cbb325917aa3145b" translate="yes" xml:space="preserve">
          <source>Perl's packages, namespaces, and some info on classes.</source>
          <target state="translated">Perl의 패키지, 네임 스페이스 및 클래스에 대한 일부 정보</target>
        </trans-unit>
        <trans-unit id="89f3a57557f87a2d78c866238eabb4d6f9e4ed76" translate="yes" xml:space="preserve">
          <source>Perl's pprivate structure</source>
          <target state="translated">Perl의 pprivate 구조</target>
        </trans-unit>
        <trans-unit id="4588c5311e33f989f4525ce1f0cd16204a00ea04" translate="yes" xml:space="preserve">
          <source>Perl's process, file, and text manipulation facilities make it particularly well-suited for tasks involving quick prototyping, system utilities, software tools, system management tasks, database access, graphical programming, networking, and web programming.</source>
          <target state="translated">Perl의 프로세스, 파일 및 텍스트 조작 기능은 빠른 프로토 타이핑, 시스템 유틸리티, 소프트웨어 도구, 시스템 관리 작업, 데이터베이스 액세스, 그래픽 프로그래밍, 네트워킹 및 웹 프로그래밍과 관련된 작업에 특히 적합합니다.</target>
        </trans-unit>
        <trans-unit id="93c38b6a66fe842db97ccbef348de209e8c19b5f" translate="yes" xml:space="preserve">
          <source>Perl's regular expression support is both broad and deep, and is the subject of lengthy documentation in &lt;a href=&quot;perlrequick&quot;&gt;perlrequick&lt;/a&gt;, &lt;a href=&quot;perlretut&quot;&gt;perlretut&lt;/a&gt;, and elsewhere. However, in short:</source>
          <target state="translated">Perl의 정규 표현식 지원은 광범위하고 깊으며 &lt;a href=&quot;perlrequick&quot;&gt;perlrequick&lt;/a&gt; , &lt;a href=&quot;perlretut&quot;&gt;perlretut&lt;/a&gt; 및 다른 곳 에서 긴 문서화의 주제입니다 . 그러나 간단히 말해서 :</target>
        </trans-unit>
        <trans-unit id="ff94ebb325d8b09e3a30e14e5986ca64a175f3eb" translate="yes" xml:space="preserve">
          <source>Perl's roots in text processing haven't been forgotten over the years. It still boasts some of the most powerful regular expressions to be found anywhere, and its support for Unicode text is world-class. It handles all kinds of structured text, too, through an extensive collection of extensions. Those libraries, collected in the CPAN, provide ready-made solutions to an astounding array of problems. When they haven't set the standard themselves, they steal from the best -- just like Perl itself.</source>
          <target state="translated">텍스트 처리에있어 Perl의 뿌리는 오랫동안 잊혀지지 않았습니다. 여전히 가장 강력한 정규 표현식 중 일부를 어디에서나 찾을 수 있으며 유니 코드 텍스트에 대한 지원은 세계적 수준입니다. 광범위한 확장 모음을 통해 모든 종류의 구조화 된 텍스트도 처리합니다. CPAN에서 수집 된 이러한 라이브러리는 다양한 문제에 대한 기성 솔루션을 제공합니다. 표준 자체를 설정하지 않으면 Perl과 마찬가지로 최고 수준에서 도용합니다.</target>
        </trans-unit>
        <trans-unit id="e5126fad405ea6c1a0317bc1b96e0b7052710e86" translate="yes" xml:space="preserve">
          <source>Perl's source code is stored in a Git repository.</source>
          <target state="translated">Perl의 소스 코드는 Git 저장소에 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="770b04c9b25881d8dba46acccf2294a181b06ea5" translate="yes" xml:space="preserve">
          <source>Perl's source code, and extensions that want maximum portability, should use the above functions instead of those defined in ANSI C's</source>
          <target state="translated">Perl의 소스 코드 및 최대 이식성을 원하는 확장 프로그램은 ANSI C에 정의 된 기능 대신 위의 기능을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="c91e012015b18438a085bd4240921bd7bbe55b97" translate="yes" xml:space="preserve">
          <source>Perl's threading package provides the &lt;code&gt;yield()&lt;/code&gt; function that does this. &lt;code&gt;yield()&lt;/code&gt; is pretty straightforward, and works like this:</source>
          <target state="translated">Perl의 스레딩 패키지는이를 수행하는 &lt;code&gt;yield()&lt;/code&gt; 함수를 제공합니다 . &lt;code&gt;yield()&lt;/code&gt; 는 매우 간단하며 다음과 같이 작동합니다.</target>
        </trans-unit>
        <trans-unit id="0d178a4e92aee7a478bcdc3786f5d6c00e61333c" translate="yes" xml:space="preserve">
          <source>Perl's version of &lt;code&gt;strdup()&lt;/code&gt; . Returns a pointer to a newly allocated string which is a duplicate of &lt;code&gt;pv&lt;/code&gt; . The size of the string is determined by &lt;code&gt;strlen()&lt;/code&gt; , which means it may not contain embedded &lt;code&gt;NUL&lt;/code&gt; characters and must have a trailing &lt;code&gt;NUL&lt;/code&gt; . The memory allocated for the new string can be freed with the &lt;code&gt;Safefree()&lt;/code&gt; function.</source>
          <target state="translated">펄의 &lt;code&gt;strdup()&lt;/code&gt; 버전 . &lt;code&gt;pv&lt;/code&gt; 의 복제 본인 새로 할당 된 문자열에 대한 포인터를 반환합니다 . 문자열의 크기는 &lt;code&gt;strlen()&lt;/code&gt; 의해 결정됩니다. 즉, 포함 된 &lt;code&gt;NUL&lt;/code&gt; 문자를 포함하지 않을 수 있으며 후미 &lt;code&gt;NUL&lt;/code&gt; 이 있어야합니다 . 새 문자열에 할당 된 메모리는 &lt;code&gt;Safefree()&lt;/code&gt; 함수를 사용하여 해제 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="cb7ece6ff69cf5a8948099da499efb5b6df6d0fa" translate="yes" xml:space="preserve">
          <source>Perl's version of &lt;code&gt;strdup()&lt;/code&gt;. Returns a pointer to a newly allocated string which is a duplicate of &lt;code&gt;pv&lt;/code&gt;. The size of the string is determined by &lt;code&gt;strlen()&lt;/code&gt;, which means it may not contain embedded &lt;code&gt;NUL&lt;/code&gt; characters and must have a trailing &lt;code&gt;NUL&lt;/code&gt;. To prevent memory leaks, the memory allocated for the new string needs to be freed when no longer needed. This can be done with the &lt;a href=&quot;#Safefree&quot;&gt;&quot;&lt;code&gt;Safefree&lt;/code&gt;&quot;&lt;/a&gt; function, or &lt;a href=&quot;perlguts#SAVEFREEPV%28p%29&quot;&gt;&lt;code&gt;SAVEFREEPV&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Perl 버전의 &lt;code&gt;strdup()&lt;/code&gt; . &lt;code&gt;pv&lt;/code&gt; 의 복제 본인 새로 할당 된 문자열에 대한 포인터를 반환합니다 . 문자열의 크기는 &lt;code&gt;strlen()&lt;/code&gt; 의해 결정됩니다. 즉, 포함 된 &lt;code&gt;NUL&lt;/code&gt; 문자를 포함 할 수 없으며 뒤에 &lt;code&gt;NUL&lt;/code&gt; 이 있어야합니다 . 메모리 누수를 방지하려면 더 이상 필요하지 않을 때 새 문자열에 할당 된 메모리를 해제해야합니다. 이것은 &lt;a href=&quot;#Safefree&quot;&gt;&quot; &lt;code&gt;Safefree&lt;/code&gt; &quot;&lt;/a&gt; 기능 또는 &lt;a href=&quot;perlguts#SAVEFREEPV%28p%29&quot;&gt; &lt;code&gt;SAVEFREEPV&lt;/code&gt; 를&lt;/a&gt; 사용하여 수행 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="25b683a4b535a4d7cfe41ce26d997bfe703e18cc" translate="yes" xml:space="preserve">
          <source>Perl's version of what &lt;code&gt;strndup()&lt;/code&gt; would be if it existed. Returns a pointer to a newly allocated string which is a duplicate of the first &lt;code&gt;len&lt;/code&gt; bytes from &lt;code&gt;pv&lt;/code&gt; , plus a trailing &lt;code&gt;NUL&lt;/code&gt; byte. The memory allocated for the new string can be freed with the &lt;code&gt;Safefree()&lt;/code&gt; function.</source>
          <target state="translated">&lt;code&gt;strndup()&lt;/code&gt; 이 존재하는 경우 Perl의 버전 . &lt;code&gt;pv&lt;/code&gt; 의 첫 번째 &lt;code&gt;len&lt;/code&gt; 바이트 와 후행 &lt;code&gt;NUL&lt;/code&gt; 바이트 의 복제 본인 새로 할당 된 문자열에 대한 포인터를 반환합니다 . 새 문자열에 할당 된 메모리는 &lt;code&gt;Safefree()&lt;/code&gt; 함수를 사용하여 해제 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="dcb73b72031ec0067bbb619275e109d78350c312" translate="yes" xml:space="preserve">
          <source>Perl's version of what &lt;code&gt;strndup()&lt;/code&gt; would be if it existed. Returns a pointer to a newly allocated string which is a duplicate of the first &lt;code&gt;len&lt;/code&gt; bytes from &lt;code&gt;pv&lt;/code&gt;, plus a trailing &lt;code&gt;NUL&lt;/code&gt; byte. The memory allocated for the new string can be freed with the &lt;code&gt;Safefree()&lt;/code&gt; function.</source>
          <target state="translated">존재한다면 &lt;code&gt;strndup()&lt;/code&gt; 이 무엇인지에 대한 Perl의 버전 . &lt;code&gt;pv&lt;/code&gt; 의 첫 번째 &lt;code&gt;len&lt;/code&gt; 바이트 와 후행 &lt;code&gt;NUL&lt;/code&gt; 바이트 의 중복 인 새로 할당 된 문자열에 대한 포인터를 반환합니다 . 새 문자열에 할당 된 메모리는 &lt;code&gt;Safefree()&lt;/code&gt; 함수 로 해제 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f5a6f57c5b6a74291061b990e5d20daa26fe09bb" translate="yes" xml:space="preserve">
          <source>Perl's version vs. Unicode version</source>
          <target state="translated">Perl의 버전과 유니 코드 버전</target>
        </trans-unit>
        <trans-unit id="7a524db45cae5747e45efc8dd0850e8e606106b1" translate="yes" xml:space="preserve">
          <source>Perl, for example, is supplied with two types of licence: The GNU GPL and The Artistic Licence (see the files README, Copying, and Artistic, or &lt;a href=&quot;https://perldoc.perl.org/5.26.0/perlgpl.html&quot;&gt;perlgpl&lt;/a&gt; and &lt;a href=&quot;https://perldoc.perl.org/5.26.0/perlartistic.html&quot;&gt;perlartistic&lt;/a&gt;). Larry has good reasons for NOT just using the GNU GPL.</source>
          <target state="translated">예를 들어, Perl에는 GNU GPL과 Artistic License의 두 가지 유형의 라이센스가 제공됩니다 (README, Copying 및 Artistic 파일 또는 &lt;a href=&quot;https://perldoc.perl.org/5.26.0/perlgpl.html&quot;&gt;perlgpl&lt;/a&gt; 및 &lt;a href=&quot;https://perldoc.perl.org/5.26.0/perlartistic.html&quot;&gt;perlartistic&lt;/a&gt; 파일 참조 ). 래리는 GNU GPL 만 사용하는 것이 아니라는 충분한 이유가 있습니다.</target>
        </trans-unit>
        <trans-unit id="564aee985156bf1f7e4d6943ab0b96e9d1591dee" translate="yes" xml:space="preserve">
          <source>Perl, for example, is supplied with two types of licence: The GNU GPL and The Artistic Licence (see the files README, Copying, and Artistic, or &lt;a href=&quot;https://perldoc.perl.org/5.32.0/perlgpl&quot;&gt;perlgpl&lt;/a&gt; and &lt;a href=&quot;https://perldoc.perl.org/5.32.0/perlartistic&quot;&gt;perlartistic&lt;/a&gt;). Larry has good reasons for NOT just using the GNU GPL.</source>
          <target state="translated">예를 들어 Perl에는 GNU GPL과 Artistic License (파일 README, Copying 및 Artistic 또는 &lt;a href=&quot;https://perldoc.perl.org/5.32.0/perlgpl&quot;&gt;perlgpl&lt;/a&gt; 및 &lt;a href=&quot;https://perldoc.perl.org/5.32.0/perlartistic&quot;&gt;perlartistic&lt;/a&gt; 파일 참조)의 두 가지 유형의 라이센스가 제공됩니다 . Larry는 GNU GPL을 사용하는 것이 아니라 좋은 이유가 있습니다.</target>
        </trans-unit>
        <trans-unit id="7fb2ce1409b2c38c39e7006d8b4053a16eb3cd6a" translate="yes" xml:space="preserve">
          <source>Perl, in most cases, will raise a warning when matching an above-Unicode code point against a Unicode property when the result is &lt;code&gt;TRUE&lt;/code&gt; for &lt;code&gt;\p{}&lt;/code&gt; , and &lt;code&gt;FALSE&lt;/code&gt; for &lt;code&gt;\P{}&lt;/code&gt; . For example:</source>
          <target state="translated">결과 때 유니 속성에 대해 상기 유니 코드 코드 포인트와 일치하는 경우 펄, 대부분의 경우에, 경고를 발생한다 &lt;code&gt;TRUE&lt;/code&gt; 위한 &lt;code&gt;\p{}&lt;/code&gt; 및 &lt;code&gt;FALSE&lt;/code&gt; 위한 &lt;code&gt;\P{}&lt;/code&gt; . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4e8a529ad62929cfec8c575ae762a6bdd257a323" translate="yes" xml:space="preserve">
          <source>Perl, in most cases, will raise a warning when matching an above-Unicode code point against a Unicode property when the result is &lt;code&gt;TRUE&lt;/code&gt; for &lt;code&gt;\p{}&lt;/code&gt;, and &lt;code&gt;FALSE&lt;/code&gt; for &lt;code&gt;\P{}&lt;/code&gt;. For example:</source>
          <target state="translated">결과 때 유니 속성에 대해 상기 유니 코드 코드 포인트와 일치하는 경우 펄, 대부분의 경우에, 경고를 발생한다 &lt;code&gt;TRUE&lt;/code&gt; 위한 &lt;code&gt;\p{}&lt;/code&gt; 및 &lt;code&gt;FALSE&lt;/code&gt; 위한 &lt;code&gt;\P{}&lt;/code&gt; . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ca608dbd89f51d5e2692a9f1c25c1e965290836e" translate="yes" xml:space="preserve">
          <source>Perl-Zeitung</source>
          <target state="translated">Perl-Zeitung</target>
        </trans-unit>
        <trans-unit id="ad6b525b8d5c1fb1d32da22f33d9e131f0326e0b" translate="yes" xml:space="preserve">
          <source>Perl.Exe</source>
          <target state="translated">Perl.Exe</target>
        </trans-unit>
        <trans-unit id="9a9aafaa9f4d06797b1c23d69746010b54bd3e53" translate="yes" xml:space="preserve">
          <source>Perl.com has two interesting articles on profiling: &quot;Profiling Perl&quot;, by Simon Cozens, &lt;a href=&quot;http://www.perl.com/lpt/a/850&quot;&gt;http://www.perl.com/lpt/a/850&lt;/a&gt; and &quot;Debugging and Profiling mod_perl Applications&quot;, by Frank Wiles, &lt;a href=&quot;http://www.perl.com/pub/a/2006/02/09/debug_mod_perl.html&quot;&gt;http://www.perl.com/pub/a/2006/02/09/debug_mod_perl.html&lt;/a&gt; .</source>
          <target state="translated">Perl.com에는 프로파일 링에 관한 흥미로운 기사가 ​​2 개 있습니다 : Simon Cozens의 &quot;Profiling Perl&quot;, &lt;a href=&quot;http://www.perl.com/lpt/a/850&quot;&gt;http://www.perl.com/lpt/a/850&lt;/a&gt; 및 Frank Wiles의 &quot;Debugging and Profiling mod_perl Applications&quot;, &lt;a href=&quot;http://www.perl.com/pub/a/2006/02/09/debug_mod_perl.html&quot;&gt;http : / /www.perl.com/pub/a/2006/02/09/debug_mod_perl.html&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4578b93cb1f77ba5f7e19625dc5d7f4767458f2f" translate="yes" xml:space="preserve">
          <source>Perl.com has two interesting articles on profiling: &quot;Profiling Perl&quot;, by Simon Cozens, &lt;a href=&quot;https://www.perl.com/pub/2004/06/25/profiling.html/&quot;&gt;https://www.perl.com/pub/2004/06/25/profiling.html/&lt;/a&gt; and &quot;Debugging and Profiling mod_perl Applications&quot;, by Frank Wiles, &lt;a href=&quot;http://www.perl.com/pub/a/2006/02/09/debug_mod_perl.html&quot;&gt;http://www.perl.com/pub/a/2006/02/09/debug_mod_perl.html&lt;/a&gt; .</source>
          <target state="translated">Perl.com에는 프로파일 링에 대한 두 가지 흥미로운 기사가 ​​있습니다. Simon Cozens의 &quot;Profiling Perl&quot;, &lt;a href=&quot;https://www.perl.com/pub/2004/06/25/profiling.html/&quot;&gt;https://www.perl.com/pub/2004/06/25/profiling.html/&lt;/a&gt; 및 &quot;mod_perl 응용 프로그램 디버깅 및 프로파일 링&quot;, 작성자 : Frank Wiles, &lt;a href=&quot;http://www.perl.com/pub/a/2006/02/09/debug_mod_perl.html&quot;&gt;http://www.perl.com/pub/a/2006/02/09/debug_mod_perl.html&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="59ecc62b49475d2cb5cb7295258de980e7bb9d53" translate="yes" xml:space="preserve">
          <source>Perl.pkg</source>
          <target state="translated">Perl.pkg</target>
        </trans-unit>
        <trans-unit id="047f2fc576481bb11cc4caee3ec1941467bc112a" translate="yes" xml:space="preserve">
          <source>Perl/Pollution/Portability</source>
          <target state="translated">Perl/Pollution/Portability</target>
        </trans-unit>
        <trans-unit id="0fabd9b0cbed286f085c386669bbb624b6ae0be5" translate="yes" xml:space="preserve">
          <source>Perl2Exe ( &lt;a href=&quot;http://www.indigostar.com/perl2exe.htm&quot;&gt;http://www.indigostar.com/perl2exe.htm&lt;/a&gt; ) is a command line program for converting perl scripts to executable files. It targets both Windows and Unix platforms.</source>
          <target state="translated">Perl2Exe ( &lt;a href=&quot;http://www.indigostar.com/perl2exe.htm&quot;&gt;http://www.indigostar.com/perl2exe.htm&lt;/a&gt; )는 perl 스크립트를 실행 파일로 변환하기위한 명령 행 프로그램입니다. Windows 및 Unix 플랫폼을 모두 대상으로합니다.</target>
        </trans-unit>
        <trans-unit id="a58d113e289a5dca1b713eadc28920196d35302a" translate="yes" xml:space="preserve">
          <source>Perl5 Functions not currently supported in Plan 9 Perl</source>
          <target state="translated">Plan 9 Perl에서 현재 지원되지 않는 Perl5 기능</target>
        </trans-unit>
        <trans-unit id="7cf03298e4568d40fe4a8c254cdea9aeaf4618e7" translate="yes" xml:space="preserve">
          <source>Perl5 access to Berkeley DB version 1.x</source>
          <target state="translated">Berkeley DB 버전 1.x에 대한 Perl5 액세스</target>
        </trans-unit>
        <trans-unit id="a6b97c33f7f10f0b285f97ea17573e6970b9aabb" translate="yes" xml:space="preserve">
          <source>Perl5 access to the gdbm library.</source>
          <target state="translated">gdbm 라이브러리에 대한 Perl5 액세스.</target>
        </trans-unit>
        <trans-unit id="03941ae667c96e0e93e4d324251c39d314452658" translate="yes" xml:space="preserve">
          <source>Perl::OSType</source>
          <target state="translated">Perl::OSType</target>
        </trans-unit>
        <trans-unit id="b6aec8ca037613e9d0fce40c6e0f1816ba73a700" translate="yes" xml:space="preserve">
          <source>Perl::OSType - Map Perl operating system names to generic types</source>
          <target state="translated">Perl :: OSType-Perl 운영 체제 이름을 일반 유형에 맵핑</target>
        </trans-unit>
        <trans-unit id="0f928d45134ea1b82a2f4001e977a9ca5021266a" translate="yes" xml:space="preserve">
          <source>PerlApp</source>
          <target state="translated">PerlApp</target>
        </trans-unit>
        <trans-unit id="35c6d70e8ca70c86c34afe75094fe416cee5049d" translate="yes" xml:space="preserve">
          <source>PerlBuilder</source>
          <target state="translated">PerlBuilder</target>
        </trans-unit>
        <trans-unit id="1fdc87c61ab4b84ad3bb7770857151e78dcb1fd1" translate="yes" xml:space="preserve">
          <source>PerlBuilder is an integrated development environment for Windows that supports Perl development.</source>
          <target state="translated">PerlBuilder는 Perl 개발을 지원하는 Windows 용 통합 개발 환경입니다.</target>
        </trans-unit>
        <trans-unit id="6649c958c30583d092dd8452f695dfb9e308dc26" translate="yes" xml:space="preserve">
          <source>PerlCE is currently linked with a simple console window, so it also works on non-hpc devices.</source>
          <target state="translated">PerlCE는 현재 간단한 콘솔 창과 연결되어 있기 때문에 비 hpc 장치에서도 작동합니다.</target>
        </trans-unit>
        <trans-unit id="7aa73f69917f5eded1a42950facbce7317ea38d8" translate="yes" xml:space="preserve">
          <source>PerlIDE is handy to deal with perlce.</source>
          <target state="translated">PerlIDE는 perlce를 다루기에 편리합니다.</target>
        </trans-unit>
        <trans-unit id="579ddb2e63a9c9da8567b958430ce3a45a513b30" translate="yes" xml:space="preserve">
          <source>PerlIO</source>
          <target state="translated">PerlIO</target>
        </trans-unit>
        <trans-unit id="2bc2886f7622b1210de6b2d1553751fdf04796f5" translate="yes" xml:space="preserve">
          <source>PerlIO * is a FILE *. This has been the default implementation since the abstraction was introduced in perl5.003_02.</source>
          <target state="translated">PerlIO *는 파일 *입니다. 이것은 추상화가 perl5.003_02에 도입 된 이후의 기본 구현이었습니다.</target>
        </trans-unit>
        <trans-unit id="71eb144823195b4440065066f28d18b5ab87828c" translate="yes" xml:space="preserve">
          <source>PerlIO - On demand loader for PerlIO layers and root of PerlIO::* name space</source>
          <target state="translated">PerlIO-PerlIO 레이어 및 PerlIO의 루트 :: * 네임 스페이스에 대한 주문형 로더</target>
        </trans-unit>
        <trans-unit id="d16207b42b045b160714ba5de2f5ff0e6ff0943e" translate="yes" xml:space="preserve">
          <source>PerlIO ALWAYS calls this method to make sure it has its own private encoding object.</source>
          <target state="translated">PerlIO는 항상이 메서드를 호출하여 자체 개인 인코딩 개체가 있는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="197c942bd2c3920a8495cda350b62bc73882bf34" translate="yes" xml:space="preserve">
          <source>PerlIO is a stack of layers.</source>
          <target state="translated">PerlIO는 계층 스택입니다.</target>
        </trans-unit>
        <trans-unit id="44ba71a577701dc77528a1c3cec83d223013c700" translate="yes" xml:space="preserve">
          <source>PerlIO layer ':win32' is experimental</source>
          <target state="translated">PerlIO 계층 ': win32'는 실험적입니다.</target>
        </trans-unit>
        <trans-unit id="439a0e2b9ec37cb15accbd0aa170c3040534253a" translate="yes" xml:space="preserve">
          <source>PerlIO layer for quoted-printable strings</source>
          <target state="translated">인용 인쇄 가능한 문자열을위한 PerlIO 레이어</target>
        </trans-unit>
        <trans-unit id="4ee79df7d6409c5fdbae86adeadf23592d153d40" translate="yes" xml:space="preserve">
          <source>PerlIO layers for &lt;b&gt;STDIN&lt;/b&gt; and &lt;b&gt;STDOUT&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;STDIN&lt;/b&gt; 및 &lt;b&gt;STDOUT&lt;/b&gt; 용 PerlIO 계층&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="6870089453c5b7ff02d4f86fa5b13e128f37bf93" translate="yes" xml:space="preserve">
          <source>PerlIO material contributed by Lupe Christoph, with some clarification by Nick Ing-Simmons.</source>
          <target state="translated">Nick Ing-Simmons의 설명과 함께 Lupe Christoph가 PerlIO 자료를 제공했습니다.</target>
        </trans-unit>
        <trans-unit id="820323203cd8f8b2a76e01512d15f3f0590e6729" translate="yes" xml:space="preserve">
          <source>PerlIO overrides the default Cygwin Text/Binary behaviour. A file will always be treated as binary, regardless of the mode of the mount it lives on, just like it is in UNIX. So CR/LF translation needs to be requested in either the &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; call like this:</source>
          <target state="translated">PerlIO는 기본 Cygwin 텍스트 / 바이너리 동작을 재정의합니다. 파일은 UNIX에서와 마찬가지로 파일이있는 마운트 모드에 관계없이 항상 이진 파일로 취급됩니다. 따라서 다음과 같이 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; 호출 에서 CR / LF 변환을 요청해야합니다 .</target>
        </trans-unit>
        <trans-unit id="9cc5889d76cbd97257ac5d37c17d569437b80e5c" translate="yes" xml:space="preserve">
          <source>PerlIO overrides the default Cygwin Text/Binary behaviour. A file will always be treated as binary, regardless of the mode of the mount it lives on, just like it is in UNIX. So CR/LF translation needs to be requested in either the &lt;code&gt;open()&lt;/code&gt; call like this:</source>
          <target state="translated">PerlIO는 기본 Cygwin Text / Binary 동작을 재정의합니다. 파일은 UNIX 에서처럼 파일이 존재하는 마운트 모드에 관계없이 항상 바이너리로 처리됩니다. 따라서 다음과 같이 &lt;code&gt;open()&lt;/code&gt; 호출 에서 CR / LF 변환을 요청해야합니다 .</target>
        </trans-unit>
        <trans-unit id="d4261eaed3053779b6ac602dc0094ca271817116" translate="yes" xml:space="preserve">
          <source>PerlIO.pm</source>
          <target state="translated">PerlIO.pm</target>
        </trans-unit>
        <trans-unit id="1154ad98b215ecf5df7b1e7ad79cee31862d0eaf" translate="yes" xml:space="preserve">
          <source>PerlIO::encoding</source>
          <target state="translated">PerlIO::encoding</target>
        </trans-unit>
        <trans-unit id="0bd3d0c97f8a1994a38840e4b2078cd8c7618564" translate="yes" xml:space="preserve">
          <source>PerlIO::encoding - encoding layer</source>
          <target state="translated">PerlIO :: encoding-인코딩 레이어</target>
        </trans-unit>
        <trans-unit id="1ed740d1e5082e67b34e9a633e9e92164f2f7b46" translate="yes" xml:space="preserve">
          <source>PerlIO::encoding, PerlIO::scalar, PerlIO::via in the Perl core.</source>
          <target state="translated">PerlIO의 PerlIO :: encoding, PerlIO :: scalar, PerlIO :: via.</target>
        </trans-unit>
        <trans-unit id="c62625c5db5d75cf0d983910b623b95f9bd27b6e" translate="yes" xml:space="preserve">
          <source>PerlIO::gzip and APR::PerlIO (mod_perl 2.0) on CPAN.</source>
          <target state="translated">CPAN의 PerlIO :: gzip 및 APR :: PerlIO (mod_perl 2.0)</target>
        </trans-unit>
        <trans-unit id="304331cfad71f1b33cdb168da072d68db60896f0" translate="yes" xml:space="preserve">
          <source>PerlIO::mmap</source>
          <target state="translated">PerlIO::mmap</target>
        </trans-unit>
        <trans-unit id="a72b9d3b9fb038f07c1da369e861e7afab553215" translate="yes" xml:space="preserve">
          <source>PerlIO::mmap - Memory mapped IO</source>
          <target state="translated">PerlIO :: mmap-메모리 매핑 IO</target>
        </trans-unit>
        <trans-unit id="b76466d411ce33a97489bbc61bc858849f23c2d6" translate="yes" xml:space="preserve">
          <source>PerlIO::scalar</source>
          <target state="translated">PerlIO::scalar</target>
        </trans-unit>
        <trans-unit id="68b32bd3bc2551440298bb2d6347e307a14d02ff" translate="yes" xml:space="preserve">
          <source>PerlIO::scalar - in-memory IO, scalar IO</source>
          <target state="translated">PerlIO :: scalar-메모리 내 IO, 스칼라 IO</target>
        </trans-unit>
        <trans-unit id="6f4147b27883b678d3b28400a2747841090cc49c" translate="yes" xml:space="preserve">
          <source>PerlIO::via</source>
          <target state="translated">PerlIO::via</target>
        </trans-unit>
        <trans-unit id="d69e5b0660da6ada8428bd96b3dfa15197a8ec90" translate="yes" xml:space="preserve">
          <source>PerlIO::via - Helper class for PerlIO layers implemented in perl</source>
          <target state="translated">PerlIO :: via-perl에서 구현 된 PerlIO 레이어를위한 헬퍼 클래스</target>
        </trans-unit>
        <trans-unit id="c1ddecb6a7a6597042738bddffe28139074d4d7b" translate="yes" xml:space="preserve">
          <source>PerlIO::via::QuotedPrint</source>
          <target state="translated">PerlIO::via::QuotedPrint</target>
        </trans-unit>
        <trans-unit id="82ccb99b92622bcc0fc58d955a6b7496cc1351ac" translate="yes" xml:space="preserve">
          <source>PerlIO::via::QuotedPrint - PerlIO layer for quoted-printable strings</source>
          <target state="translated">PerlIO :: via :: QuotedPrint-인용 인쇄 가능한 문자열을위한 PerlIO 레이어</target>
        </trans-unit>
        <trans-unit id="60e19b81fad8ebbf88c9ee26060f85ab35b8d0b9" translate="yes" xml:space="preserve">
          <source>PerlIO::via::QuotedPrint in the Perl core and PerlIO::via::* on CPAN.</source>
          <target state="translated">PerlIO :: via :: QuotedPerl 코어에서 인쇄하고 CPl에서 PerlIO :: via :: *.</target>
        </trans-unit>
        <trans-unit id="031a53d77ac71ec3ef46da5f59553f918d566426" translate="yes" xml:space="preserve">
          <source>PerlIOBase(PerlIO *f) returns the &quot;Base&quot; pointer, or in other words, the &lt;code&gt;PerlIOl*&lt;/code&gt; pointer.</source>
          <target state="translated">PerlIOBase (PerlIO * f)는 &quot;Base&quot;포인터, 즉 &lt;code&gt;PerlIOl*&lt;/code&gt; 포인터를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="b34114bdf01a0e654170651a1a2e3dc55613845c" translate="yes" xml:space="preserve">
          <source>PerlIOSelf(PerlIO* f, type) return the PerlIOBase cast to a type.</source>
          <target state="translated">PerlIOSelf (PerlIO * f, type)는 PerlIOBase 캐스트를 유형으로 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d57d00fa34f5c798b1a3aa08845fb7d0cb59fd01" translate="yes" xml:space="preserve">
          <source>PerlIO_apply_layers(f,mode,layers)</source>
          <target state="translated">PerlIO_apply_layers(f,mode,layers)</target>
        </trans-unit>
        <trans-unit id="571d6043e2ec872d7cb6f9099f8b8245ff464e37" translate="yes" xml:space="preserve">
          <source>PerlIO_binmode(f,ptype,imode,layers)</source>
          <target state="translated">PerlIO_binmode(f,ptype,imode,layers)</target>
        </trans-unit>
        <trans-unit id="3d8d78d3151e28ab17b88db0695455690dcd0493" translate="yes" xml:space="preserve">
          <source>PerlIO_close</source>
          <target state="translated">PerlIO_close</target>
        </trans-unit>
        <trans-unit id="3be650734ae821da60ceb0f946fbc1e419f8206f" translate="yes" xml:space="preserve">
          <source>PerlIO_context_layers</source>
          <target state="translated">PerlIO_context_layers</target>
        </trans-unit>
        <trans-unit id="0255e27b57dfc3265eea6731c6b0c7839e9ab42d" translate="yes" xml:space="preserve">
          <source>PerlIO_debug is a printf()-like function which can be used for debugging. No return value. Its main use is inside PerlIO where using real printf, warn() etc. would recursively call PerlIO and be a problem.</source>
          <target state="translated">PerlIO_debug는 디버깅에 사용할 수있는 printf ()와 유사한 함수입니다. 반환 값이 없습니다. 실제 printf, warn () 등을 사용하면 PerlIO를 재귀 적으로 호출하여 문제가되는 PerlIO 내부에서 주로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="89d032ee35b94a317d1e11679408a01d0f02011d" translate="yes" xml:space="preserve">
          <source>PerlIO_debug writes to the file named by $ENV{'PERLIO_DEBUG'} or defaults to stderr if the environment variable is not defined. Typical use might be</source>
          <target state="translated">PerlIO_debug는 $ ENV { 'PERLIO_DEBUG'}에 의해 명명 된 파일에 쓰거나 환경 변수가 정의되지 않은 경우 기본적으로 stderr로 설정됩니다. 일반적인 용도는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8a0fff3fc1334ecf07d826a061819bfc08e3aaea" translate="yes" xml:space="preserve">
          <source>PerlIO_debug writes to the file named by $ENV{'PERLIO_DEBUG'} typical use might be</source>
          <target state="translated">PerlIO_debug는 $ ENV { 'PERLIO_DEBUG'}에 의해 명명 된 파일에 기록합니다. 일반적인 용도는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7a73888154ab95ec9d3189d67cc64d8a26900457" translate="yes" xml:space="preserve">
          <source>PerlIO_debug(fmt,...)</source>
          <target state="translated">PerlIO_debug(fmt,...)</target>
        </trans-unit>
        <trans-unit id="100b7f7c057785e0afeda1c6eecdad5e89f91daa" translate="yes" xml:space="preserve">
          <source>PerlIO_error</source>
          <target state="translated">PerlIO_error</target>
        </trans-unit>
        <trans-unit id="9e246fb113c359325db7b695c42623371987cfe5" translate="yes" xml:space="preserve">
          <source>PerlIO_fill</source>
          <target state="translated">PerlIO_fill</target>
        </trans-unit>
        <trans-unit id="13b27853883b92af97538fe15f7fe52484d7c534" translate="yes" xml:space="preserve">
          <source>PerlIO_flush</source>
          <target state="translated">PerlIO_flush</target>
        </trans-unit>
        <trans-unit id="efbc7a55cb5fc7dbd487f7b3df5582d0c9c5b4ab" translate="yes" xml:space="preserve">
          <source>PerlIO_get_bufsiz</source>
          <target state="translated">PerlIO_get_bufsiz</target>
        </trans-unit>
        <trans-unit id="c10b5fb9db4780628505f2900df4a076d31c1d81" translate="yes" xml:space="preserve">
          <source>PerlIO_get_ptr</source>
          <target state="translated">PerlIO_get_ptr</target>
        </trans-unit>
        <trans-unit id="7178d99df96dc1b4506cce98992701276d9c239e" translate="yes" xml:space="preserve">
          <source>PerlIO_read</source>
          <target state="translated">PerlIO_read</target>
        </trans-unit>
        <trans-unit id="c9db204115f2772dfe73d45d977a7ab26c3db174" translate="yes" xml:space="preserve">
          <source>PerlIO_restore_errno</source>
          <target state="translated">PerlIO_restore_errno</target>
        </trans-unit>
        <trans-unit id="4ea99c1a1f0e14060bbf9890b956ec2732fc7963" translate="yes" xml:space="preserve">
          <source>PerlIO_save_errno</source>
          <target state="translated">PerlIO_save_errno</target>
        </trans-unit>
        <trans-unit id="3448e5bfc541fa5c1c6f7d0c567036327a6d1b1d" translate="yes" xml:space="preserve">
          <source>PerlIO_seek</source>
          <target state="translated">PerlIO_seek</target>
        </trans-unit>
        <trans-unit id="c3494517fbb2fd9ae4140e2f05e92ed232d54343" translate="yes" xml:space="preserve">
          <source>PerlIO_set_cnt</source>
          <target state="translated">PerlIO_set_cnt</target>
        </trans-unit>
        <trans-unit id="28b9d60a7d7cdedf7f8eab9fbfb1586a5e74e162" translate="yes" xml:space="preserve">
          <source>PerlIO_setlinebuf</source>
          <target state="translated">PerlIO_setlinebuf</target>
        </trans-unit>
        <trans-unit id="d03e37a9fec4395065d7268bae0c026fec23c250" translate="yes" xml:space="preserve">
          <source>PerlIO_stdout</source>
          <target state="translated">PerlIO_stdout</target>
        </trans-unit>
        <trans-unit id="d0cbd7701c5904432f5b089a12f15c43e18b06f2" translate="yes" xml:space="preserve">
          <source>PerlIO_unread</source>
          <target state="translated">PerlIO_unread</target>
        </trans-unit>
        <trans-unit id="3557c0fab3f26cfdec99b940ea71520d75ea2ee0" translate="yes" xml:space="preserve">
          <source>PerlInterpreter</source>
          <target state="translated">PerlInterpreter</target>
        </trans-unit>
        <trans-unit id="38a6b25b1659011ae61cace35aeff9baee4a13cd" translate="yes" xml:space="preserve">
          <source>PerlLIO_dup2_cloexec</source>
          <target state="translated">PerlLIO_dup2_cloexec</target>
        </trans-unit>
        <trans-unit id="f6ea8eebfba4a8ab959f7002d307625e66933740" translate="yes" xml:space="preserve">
          <source>PerlLIO_dup_cloexec</source>
          <target state="translated">PerlLIO_dup_cloexec</target>
        </trans-unit>
        <trans-unit id="73de2727af3d3234d0781998f683251a2002d497" translate="yes" xml:space="preserve">
          <source>PerlLIO_open3_cloexec</source>
          <target state="translated">PerlLIO_open3_cloexec</target>
        </trans-unit>
        <trans-unit id="f2fae1f35dbb5d09391fca46f2a80c2f8e50cc8b" translate="yes" xml:space="preserve">
          <source>PerlLIO_open_cloexec</source>
          <target state="translated">PerlLIO_open_cloexec</target>
        </trans-unit>
        <trans-unit id="6feba0dc339a322bf408c0ef0a0d56e7e1816aa9" translate="yes" xml:space="preserve">
          <source>PerlMonks is one of the largest Perl forums, and describes itself as &quot;A place for individuals to polish, improve, and showcase their Perl skills.&quot; and &quot;A community which allows everyone to grow and learn from each other.&quot;</source>
          <target state="translated">PerlMonks는 가장 큰 Perl 포럼 중 하나이며 &quot;개인이 Perl 기술을 연마, 개선 및 전시 할 수있는 장소&quot;라고 설명합니다. &quot;모든 사람이 서로 성장하고 배울 수있는 커뮤니티&quot;</target>
        </trans-unit>
        <trans-unit id="96118a64fd38dbd81e3cb0e3744963bd1d54ba7a" translate="yes" xml:space="preserve">
          <source>PerlPower()</source>
          <target state="translated">PerlPower()</target>
        </trans-unit>
        <trans-unit id="f128e221d24537d88adf37c1080c58489584bc08" translate="yes" xml:space="preserve">
          <source>PerlProc_pipe_cloexec</source>
          <target state="translated">PerlProc_pipe_cloexec</target>
        </trans-unit>
        <trans-unit id="db63ab2940f098200e4ac58afc78b248f4d2fcb2" translate="yes" xml:space="preserve">
          <source>PerlShr.Exe</source>
          <target state="translated">PerlShr.Exe</target>
        </trans-unit>
        <trans-unit id="75aee309a8d63b5243b0d02f20422961a0ea87e9" translate="yes" xml:space="preserve">
          <source>PerlSock_accept_cloexec</source>
          <target state="translated">PerlSock_accept_cloexec</target>
        </trans-unit>
        <trans-unit id="24add7e2c5d5abdc4daafea395e2344696ac59c8" translate="yes" xml:space="preserve">
          <source>PerlSock_socket_cloexec</source>
          <target state="translated">PerlSock_socket_cloexec</target>
        </trans-unit>
        <trans-unit id="223a980cfc2b88529bd63e96b16d41c5cc62261a" translate="yes" xml:space="preserve">
          <source>PerlSock_socketpair_cloexec</source>
          <target state="translated">PerlSock_socketpair_cloexec</target>
        </trans-unit>
        <trans-unit id="097886f8ad6be4d2da4b42cedab0b39cdf7f9b1c" translate="yes" xml:space="preserve">
          <source>Perl_ VIO executable (statically linked)</source>
          <target state="translated">Perl_ VIO 실행 파일 (정적으로 링크 됨)</target>
        </trans-unit>
        <trans-unit id="07121cdb0e428e6add9cbaefd2f84414e43aa38b" translate="yes" xml:space="preserve">
          <source>Perl_PerlIO_or_Base(PerlIO* f, callback, base, failure, args) either calls the</source>
          <target state="translated">Perl_PerlIO_or_Base (PerlIO * f, 콜백, 기본, 실패, args)는</target>
        </trans-unit>
        <trans-unit id="2f0f41f617e9b822c0919fb0f159f1a51c8bb029" translate="yes" xml:space="preserve">
          <source>Perl_PerlIO_or_Base_void(PerlIO* f, callback, base, args) either calls the</source>
          <target state="translated">Perl_PerlIO_or_Base_void (PerlIO * f, 콜백, 기본, args)는</target>
        </trans-unit>
        <trans-unit id="81a3f26af0ca1bd5eb03eba445b883c96fd6bebb" translate="yes" xml:space="preserve">
          <source>Perl_PerlIO_or_fail(PerlIO* f, callback, failure, args) either calls the</source>
          <target state="translated">Perl_PerlIO_or_fail (PerlIO * f, 콜백, 실패, args)</target>
        </trans-unit>
        <trans-unit id="e4851451f4653d2e45acca412261ea7befab27cf" translate="yes" xml:space="preserve">
          <source>Perl_PerlIO_or_fail_void(PerlIO* f, callback, args) either calls the</source>
          <target state="translated">Perl_PerlIO_or_fail_void (PerlIO * f, 콜백, args)는</target>
        </trans-unit>
        <trans-unit id="2ed83c745e785ffa5b094c3edf1bccccffccea32" translate="yes" xml:space="preserve">
          <source>Perl_custom_op_xop</source>
          <target state="translated">Perl_custom_op_xop</target>
        </trans-unit>
        <trans-unit id="2bd7ba33bc197c1cac645c3fa7496edd8205233d" translate="yes" xml:space="preserve">
          <source>Perl_isinfnan() is utility function that returns true if the NV argument is either an infinity or a NaN, false otherwise. To test in more detail, use Perl_isinf() and Perl_isnan().</source>
          <target state="translated">Perl_isinfnan ()은 NV 인수가 무한대이거나 NaN이면 true를, 그렇지 않으면 false를 반환하는 유틸리티 함수입니다. 보다 자세히 테스트하려면 Perl_isinf () 및 Perl_isnan ()을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="9632627677c9064aca08da1e222aaa10c0c1893b" translate="yes" xml:space="preserve">
          <source>Perl_langinfo</source>
          <target state="translated">Perl_langinfo</target>
        </trans-unit>
        <trans-unit id="9ddad3a0f4e11c02b4e6bd2fa655acf548001837" translate="yes" xml:space="preserve">
          <source>Perl_my_%s() not available</source>
          <target state="translated">Perl_my_ % s ()를 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="b3f50fc46743d6c022f3455d5dab2d3097bb717c" translate="yes" xml:space="preserve">
          <source>Perl_setlocale</source>
          <target state="translated">Perl_setlocale</target>
        </trans-unit>
        <trans-unit id="d5a2a12addea9810bccfcba9c388e5aa60aaf3d9" translate="yes" xml:space="preserve">
          <source>Perl_signbit</source>
          <target state="translated">Perl_signbit</target>
        </trans-unit>
        <trans-unit id="c68adda4177619ceaf594bde89a717be1213ecd6" translate="yes" xml:space="preserve">
          <source>Perls since %s too modern--this is %s, stopped</source>
          <target state="translated">% s이 (가) 너무 현대적이므로 Perls가 % s입니다. 중지되었습니다.</target>
        </trans-unit>
        <trans-unit id="435a6fd71f06655224907356e4d56d72c377a1bd" translate="yes" xml:space="preserve">
          <source>Perls starting in 5.8 have a different Unicode model from 5.6. In 5.6 the programmer was required to use the &lt;code&gt;utf8&lt;/code&gt; pragma to declare that a given scope expected to deal with Unicode data and had to make sure that only Unicode data were reaching that scope. If you have code that is working with 5.6, you will need some of the following adjustments to your code. The examples are written such that the code will continue to work under 5.6, so you should be safe to try them out.</source>
          <target state="translated">5.8로 시작하는 Perls는 5.6과 다른 유니 코드 모델이 있습니다. 5.6에서 프로그래머는 &lt;code&gt;utf8&lt;/code&gt; pragma 를 사용하여 주어진 범위가 유니 코드 데이터를 처리해야하고 유니 코드 데이터 만 해당 범위에 도달했는지 확인해야한다고 선언해야했습니다. 5.6에서 작동하는 코드가있는 경우 코드를 다음과 같이 조정해야합니다. 예제는 코드가 5.6에서 계속 작동하도록 작성되었으므로 안전하게 사용해 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b95bc9c4bdba73fd23a6e99cb0cb35ee28a07aa3" translate="yes" xml:space="preserve">
          <source>Permanently attach to the shared memory segment. When a &lt;code&gt;IPC::SharedMem&lt;/code&gt; object is attached, it will use &lt;a href=&quot;http://search.cpan.org/perldoc/memread&quot;&gt;memread&lt;/a&gt; and &lt;a href=&quot;http://search.cpan.org/perldoc/memwrite&quot;&gt;memwrite&lt;/a&gt; instead of &lt;a href=&quot;../functions/shmread&quot;&gt;shmread&lt;/a&gt; and &lt;a href=&quot;../functions/shmwrite&quot;&gt;shmwrite&lt;/a&gt; for accessing the shared memory segment. Returns true if successful, or false on error. See &lt;a href=&quot;http://search.cpan.org/perldoc/shmat&quot;&gt;shmat&lt;/a&gt;.</source>
          <target state="translated">공유 메모리 세그먼트에 영구적으로 연결하십시오. 때 &lt;code&gt;IPC::SharedMem&lt;/code&gt; 객체가 부착되어, 그것을 사용 &lt;a href=&quot;http://search.cpan.org/perldoc/memread&quot;&gt;memread을&lt;/a&gt; 하고 &lt;a href=&quot;http://search.cpan.org/perldoc/memwrite&quot;&gt;memwrite&lt;/a&gt; 대신 &lt;a href=&quot;../functions/shmread&quot;&gt;shmread&lt;/a&gt; 및 &lt;a href=&quot;../functions/shmwrite&quot;&gt;shmwrite&lt;/a&gt; 공유 메모리 세그먼트에 액세스. 성공하면 true를, 오류이면 false를 반환합니다. &lt;a href=&quot;http://search.cpan.org/perldoc/shmat&quot;&gt;shmat를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c26d4aa620dca99b812bc4a79254d9e74d407fd7" translate="yes" xml:space="preserve">
          <source>Permanently attach to the shared memory segment. When a &lt;code&gt;IPC::SharedMem&lt;/code&gt; object is attached, it will use &lt;a href=&quot;memread&quot;&gt;memread&lt;/a&gt; and &lt;a href=&quot;memwrite&quot;&gt;memwrite&lt;/a&gt; instead of &lt;a href=&quot;shmread&quot;&gt;shmread&lt;/a&gt; and &lt;a href=&quot;shmwrite&quot;&gt;shmwrite&lt;/a&gt; for accessing the shared memory segment. Returns true if successful, or false on error. See &lt;a href=&quot;http://man.he.net/man2/shmat&quot;&gt;shmat(2)&lt;/a&gt;.</source>
          <target state="translated">공유 메모리 세그먼트에 영구적으로 연결합니다. 때 &lt;code&gt;IPC::SharedMem&lt;/code&gt; 객체가 부착되어, 그것을 사용 &lt;a href=&quot;memread&quot;&gt;memread을&lt;/a&gt; 하고 &lt;a href=&quot;memwrite&quot;&gt;memwrite&lt;/a&gt; 대신 &lt;a href=&quot;shmread&quot;&gt;shmread&lt;/a&gt; 및 &lt;a href=&quot;shmwrite&quot;&gt;shmwrite&lt;/a&gt; 공유 메모리 세그먼트에 액세스. 성공하면 true를, 오류가 발생하면 false를 반환합니다. &lt;a href=&quot;http://man.he.net/man2/shmat&quot;&gt;shmat (2)를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="17c52fa4da091dd586a97843497807bc0e23a069" translate="yes" xml:space="preserve">
          <source>Permanently fixing locale problems</source>
          <target state="translated">로케일 문제를 영구적으로 수정</target>
        </trans-unit>
        <trans-unit id="2cf2947e5f569b9ea7e16800990428360247021e" translate="yes" xml:space="preserve">
          <source>Permanently fixing your system's locale configuration</source>
          <target state="translated">시스템의 로케일 구성을 영구적으로 수정</target>
        </trans-unit>
        <trans-unit id="9ab7f14d670c62039e207778bc0fed042486426a" translate="yes" xml:space="preserve">
          <source>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the &quot;Software&quot;), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</source>
          <target state="translated">이 소프트웨어 및 관련 문서 파일 (이하 &quot;소프트웨어&quot;)의 사본을 사용하는 사람에게는 사용, 복사, 수정, 병합 권한을 포함하여 제한없이 소프트웨어를 처리 할 수있는 권한이 무료로 부여됩니다. 다음 조건에 따라 소프트웨어의 사본을 게시, 배포, 하위 사용권 허가 및 / 또는 판매하고 소프트웨어를 제공받은 사람에게 허용합니다.</target>
        </trans-unit>
        <trans-unit id="78d9cc4b4fc45291ef4d268d18882d87b86fac76" translate="yes" xml:space="preserve">
          <source>Permit</source>
          <target state="translated">Permit</target>
        </trans-unit>
        <trans-unit id="0f8250826e3e169df1c1ab3f1a4991fb276b498f" translate="yes" xml:space="preserve">
          <source>Permit the listed operators to be used when compiling code in the compartment (in</source>
          <target state="translated">구획에서 코드를 컴파일 할 때 나열된 연산자를 사용할 수 있도록 허용</target>
        </trans-unit>
        <trans-unit id="d4efe59e4dc596d83fe507198172c79c563d3297" translate="yes" xml:space="preserve">
          <source>Pern</source>
          <target state="translated">Pern</target>
        </trans-unit>
        <trans-unit id="b7871f509f5f98e4d602975abaec93401e8fa9c5" translate="yes" xml:space="preserve">
          <source>Persistence for Perl data structures</source>
          <target state="translated">Perl 데이터 구조에 대한 지속성</target>
        </trans-unit>
        <trans-unit id="f887bea11bbedab00d763b35a7c513eee8986177" translate="yes" xml:space="preserve">
          <source>Persistent Private Variables</source>
          <target state="translated">영구적 인 개인 변수</target>
        </trans-unit>
        <trans-unit id="37fcb2b67d89818ceecfdb67f2459b636da00b36" translate="yes" xml:space="preserve">
          <source>Persistent variables via state()</source>
          <target state="translated">state ()를 통한 영구 변수</target>
        </trans-unit>
        <trans-unit id="2e14d0f6039c4bed4f250852e11a5960cec217cc" translate="yes" xml:space="preserve">
          <source>Persistent variables with closures</source>
          <target state="translated">클로저가있는 영구 변수</target>
        </trans-unit>
        <trans-unit id="297062bf4f638f4e5a1559e426d9dca1019c35bc" translate="yes" xml:space="preserve">
          <source>Peter J. Farley III</source>
          <target state="translated">피터 제이 팔리 III</target>
        </trans-unit>
        <trans-unit id="2443526b197b82e6711ce47499d4a744b2d3caac" translate="yes" xml:space="preserve">
          <source>Peter John Acklam</source>
          <target state="translated">피터 존 아 클람</target>
        </trans-unit>
        <trans-unit id="9619c2ff06f7bbbafb0d5e9160ae26df77e91db0" translate="yes" xml:space="preserve">
          <source>Peter John Acklam &amp;lt;pjacklam@gmail.com&amp;lt;gt&amp;gt;, 2014-.</source>
          <target state="translated">Peter John Acklam &amp;lt;pjacklam@gmail.com&amp;lt;gt&amp;gt;, 2014-.</target>
        </trans-unit>
        <trans-unit id="0e9567258b003fa101683db10492bc177b3b183a" translate="yes" xml:space="preserve">
          <source>Peter John Acklam &amp;lt;pjacklam@online.no&amp;gt;</source>
          <target state="translated">Peter John Acklam &amp;lt;pjacklam@online.no&amp;gt;</target>
        </trans-unit>
        <trans-unit id="587cf83d47912d48cff152ba5703ff6e1be6461d" translate="yes" xml:space="preserve">
          <source>Peter John Acklam &amp;lt;pjacklam@online.no&amp;gt;, 2011-.</source>
          <target state="translated">Peter John Acklam &amp;lt;pjacklam@online.no&amp;gt;, 2011-.</target>
        </trans-unit>
        <trans-unit id="9ad3ffe64617bfe15d4f21e7a60a9ca00647098f" translate="yes" xml:space="preserve">
          <source>Peter John Acklam, &amp;lt;pjacklam@online.no&amp;gt;</source>
          <target state="translated">Peter John Acklam, &amp;lt;pjacklam@online.no&amp;gt;</target>
        </trans-unit>
        <trans-unit id="a32278777d03ff2e6b6ad59e9b3657ba9315fcef" translate="yes" xml:space="preserve">
          <source>Peter Prymmer</source>
          <target state="translated">피터 프라이머</target>
        </trans-unit>
        <trans-unit id="c3032976541bf9515b50f93b039ec87133fcbe77" translate="yes" xml:space="preserve">
          <source>Peter Prymmer pvhp@best.com wrote this in 1999 and 2000 with CCSID 0819 and 0037 help from Chris Leach and Andr&amp;eacute; Pirard A.Pirard@ulg.ac.be as well as POSIX-BC help from Thomas Dorner Thomas.Dorner@start.de. Thanks also to Vickie Cooper, Philip Newton, William Raffloer, and Joe Smith. Trademarks, registered trademarks, service marks and registered service marks used in this document are the property of their respective owners.</source>
          <target state="translated">Peter Prymmer pvhp@best.com은 1999 년과 2000 년에 Chris Leach와 Andr&amp;eacute; Pirard A.Pirard@ulg.ac.be의 CCSID 0819 및 0037의 도움과 Thomas Dorner Thomas의 POSIX-BC의 도움으로 이것을 작성했습니다 .Dorner @ start. de. Vickie Cooper, Philip Newton, William Raffloer 및 Joe Smith에게도 감사합니다. 이 문서에 사용 된 상표, 등록 상표, 서비스 마크 및 등록 서비스 마크는 해당 소유자의 재산입니다.</target>
        </trans-unit>
        <trans-unit id="b678d41f58da447298d919f29043393443d0cb8b" translate="yes" xml:space="preserve">
          <source>Peter Rabbitson</source>
          <target state="translated">피터 래빗 슨</target>
        </trans-unit>
        <trans-unit id="898a609b1123bee03d0fba96ca647e344dd3c879" translate="yes" xml:space="preserve">
          <source>Peter Rabbitson &amp;lt;ribasushi@cpan.org&amp;gt;</source>
          <target state="translated">피터 래빗 슨 &amp;lt;ribasushi@cpan.org&amp;gt;</target>
        </trans-unit>
        <trans-unit id="9a6caa883001f8951928abc18a49fa0996873b1e" translate="yes" xml:space="preserve">
          <source>Peter Scott &amp;lt;Peter@PSDT.com&amp;gt;</source>
          <target state="translated">피터 스콧 &amp;lt;Peter@PSDT.com&amp;gt;</target>
        </trans-unit>
        <trans-unit id="6bf5b1ffed5896f2003c72c19a4b2211605af373" translate="yes" xml:space="preserve">
          <source>Petr P&amp;iacute;sař &amp;lt;ppisar@redhat.com&amp;gt;</source>
          <target state="translated">Petr P&amp;iacute;sař &amp;lt;ppisar@redhat.com&amp;gt;</target>
        </trans-unit>
        <trans-unit id="9bab0d91a1e342ed2899a60bb0fd7fbb5d908345" translate="yes" xml:space="preserve">
          <source>Phase-specific attribute handlers</source>
          <target state="translated">단계별 속성 핸들러</target>
        </trans-unit>
        <trans-unit id="1299c5da4d36f7c6543acebafdc41ccf1b565939" translate="yes" xml:space="preserve">
          <source>Phases</source>
          <target state="translated">Phases</target>
        </trans-unit>
        <trans-unit id="11224e45779f711f0ecc038e4dc550b38b44febf" translate="yes" xml:space="preserve">
          <source>Philippe Bruhat &amp;lt;book@cpan.org&amp;gt;</source>
          <target state="translated">필립 브루 하트 &amp;lt;book@cpan.org&amp;gt;</target>
        </trans-unit>
        <trans-unit id="8067364d44f5e37baba7e13ba124e934df410e2a" translate="yes" xml:space="preserve">
          <source>Philippines</source>
          <target state="translated">Philippines</target>
        </trans-unit>
        <trans-unit id="b7b6129ef396633c6d7fbf8b5ba6a676cf84b685" translate="yes" xml:space="preserve">
          <source>Philosophy and History</source>
          <target state="translated">철학과 역사</target>
        </trans-unit>
        <trans-unit id="a7ca65a16231d5ab21bb882a874c4184071b79df" translate="yes" xml:space="preserve">
          <source>Pick one style or another of &quot;TODO&quot; to be on the safe side.</source>
          <target state="translated">&quot;TODO&quot;중 하나 또는 다른 스타일을 선택하여 안전한쪽에 배치하십시오.</target>
        </trans-unit>
        <trans-unit id="d9e68904cd8d62a6bd9853c94a5ff5af64e98135" translate="yes" xml:space="preserve">
          <source>Picture lines contain output field definitions, intermingled with literal text. These lines do not undergo any kind of variable interpolation. Field definitions are made up from a set of characters, for starting and extending a field to its desired width. This is the complete set of characters for field definitions:</source>
          <target state="translated">그림 라인은 리터럴 텍스트와 혼합 된 출력 필드 정의를 포함합니다. 이 선들은 어떤 종류의 변수 보간법도 거치지 않습니다. 필드 정의는 필드를 시작하고 원하는 너비로 확장하기 위해 문자 집합으로 구성됩니다. 이것은 필드 정의를위한 완전한 문자 세트입니다.</target>
        </trans-unit>
        <trans-unit id="2ce99d2159f85cc771804ecbd9dda841764e190d" translate="yes" xml:space="preserve">
          <source>Pictures help... Here's the &lt;code&gt;%hash&lt;/code&gt; table:</source>
          <target state="translated">그림 도움말 ... &lt;code&gt;%hash&lt;/code&gt; 테이블 은 다음과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="c65c8c71a5372d959508dd740dbc1277950d7e03" translate="yes" xml:space="preserve">
          <source>Pictures of the characters in</source>
          <target state="translated">캐릭터의 사진</target>
        </trans-unit>
        <trans-unit id="576c308de400973ac0e3b490eedf5eb2dfd16554" translate="yes" xml:space="preserve">
          <source>Ping the configured mirrors and print a report</source>
          <target state="translated">구성된 미러를 핑하고 보고서를 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="f0a9c866fde7f49d0c8287047fc7266c3fcf3448" translate="yes" xml:space="preserve">
          <source>Ping the remote host and wait for a response. $host can be either the hostname or the IP number of the remote host. The optional timeout must be greater than 0 seconds and defaults to whatever was specified when the ping object was created. Returns a success flag. If the hostname cannot be found or there is a problem with the IP number, the success flag returned will be undef. Otherwise, the success flag will be 1 if the host is reachable and 0 if it is not. For most practical purposes, undef and 0 and can be treated as the same case. In array context, the elapsed time as well as the string form of the ip the host resolved to are also returned. The elapsed time value will be a float, as returned by the Time::HiRes::time() function, if hires() has been previously called, otherwise it is returned as an integer.</source>
          <target state="translated">원격 호스트를 Ping하고 응답을 기다립니다. $ host는 원격 호스트의 호스트 이름 또는 IP 번호 일 수 있습니다. 선택적 시간 제한은 0 초보다 커야하며 핑 개체를 만들 때 지정한 값으로 기본 설정됩니다. 성공 플래그를 반환합니다. 호스트 이름을 찾을 수 없거나 IP 번호에 문제가있는 경우 반환 된 성공 플래그는 undef입니다. 그렇지 않으면 호스트에 도달 할 수있는 경우 성공 플래그는 1이되고 그렇지 않으면 0이됩니다. 대부분의 실제적인 목적으로 undef와 0은 같은 경우로 취급 될 수 있습니다. 배열 컨텍스트에서 경과 시간과 호스트가 확인한 IP의 문자열 형식도 반환됩니다. hires ()가 이전에 호출 된 경우 Time :: HiRes :: time () 함수에 의해 리턴 된 경과 시간 값은 부동 소수점이됩니다. 그렇지 않으면 정수로 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="07ec367a9d37985bd6dc081364fe2955df9103f5" translate="yes" xml:space="preserve">
          <source>Piotr Roszatycki &amp;lt;piotr.roszatycki@gmail.com&amp;gt;</source>
          <target state="translated">Piotr Roszatycki &amp;lt;piotr.roszatycki@gmail.com&amp;gt;</target>
        </trans-unit>
        <trans-unit id="bbc0c839f8f40b7cdba9f85501b6142c7594b73f" translate="yes" xml:space="preserve">
          <source>Pipe-open (see &lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;) with the command which contains redirection or shell meta-characters;</source>
          <target state="translated">파이프 오픈합니다 ( &lt;a href=&quot;functions/open&quot;&gt;개방&lt;/a&gt; ) 리디렉션 또는 쉘 메타 문자를 포함하는 명령;</target>
        </trans-unit>
        <trans-unit id="5e4c7a898c7f3c0a7c60e0a1f604f62469eeccef" translate="yes" xml:space="preserve">
          <source>Pipe-open (see &lt;a href=&quot;perlfunc#open&quot;&gt;&quot;open&quot; in perlfunc&lt;/a&gt;) with the command which contains redirection or shell meta-characters;</source>
          <target state="translated">리디렉션 또는 쉘 메타 문자를 포함하는 명령으로 파이프 열기 ( &lt;a href=&quot;perlfunc#open&quot;&gt;perlfunc의 &quot;open&quot;&lt;/a&gt; 참조 )</target>
        </trans-unit>
        <trans-unit id="32b1d5a78493496dd5152fd2d504f7e21009e3f2" translate="yes" xml:space="preserve">
          <source>Pipeline</source>
          <target state="translated">Pipeline</target>
        </trans-unit>
        <trans-unit id="785af2a4ad3c4ee912623c6e0b6d4299ea305bf6" translate="yes" xml:space="preserve">
          <source>Pipes</source>
          <target state="translated">Pipes</target>
        </trans-unit>
        <trans-unit id="86638d4dd1bfeebd306bf371ebd586c8fe132936" translate="yes" xml:space="preserve">
          <source>Place &lt;code&gt;&amp;amp;PL_sv_no&lt;/code&gt; into the specified position &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos&lt;/a&gt;&lt;/code&gt; on the stack.</source>
          <target state="translated">장소 &lt;code&gt;&amp;amp;PL_sv_no&lt;/code&gt; 지정된 위치에 &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos&lt;/a&gt;&lt;/code&gt; 스택.</target>
        </trans-unit>
        <trans-unit id="667a33361c3428c4b6aa60ad95cf789c3ab5ca45" translate="yes" xml:space="preserve">
          <source>Place &lt;code&gt;&amp;amp;PL_sv_no&lt;/code&gt; into the specified position &lt;code&gt;pos&lt;/code&gt; on the stack.</source>
          <target state="translated">장소 &lt;code&gt;&amp;amp;PL_sv_no&lt;/code&gt; 지정된 위치에 &lt;code&gt;pos&lt;/code&gt; 스택.</target>
        </trans-unit>
        <trans-unit id="dfd0139035f77f7f1b17632082240cf0b36e9af1" translate="yes" xml:space="preserve">
          <source>Place &lt;code&gt;&amp;amp;PL_sv_undef&lt;/code&gt; into the specified position &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos&lt;/a&gt;&lt;/code&gt; on the stack.</source>
          <target state="translated">장소 &lt;code&gt;&amp;amp;PL_sv_undef&lt;/code&gt; 지정된 위치에 &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos&lt;/a&gt;&lt;/code&gt; 스택.</target>
        </trans-unit>
        <trans-unit id="1bb0eaf6fb6e81489445c95594e8a4006384093d" translate="yes" xml:space="preserve">
          <source>Place &lt;code&gt;&amp;amp;PL_sv_undef&lt;/code&gt; into the specified position &lt;code&gt;pos&lt;/code&gt; on the stack.</source>
          <target state="translated">장소 &lt;code&gt;&amp;amp;PL_sv_undef&lt;/code&gt; 지정된 위치에 &lt;code&gt;pos&lt;/code&gt; 스택.</target>
        </trans-unit>
        <trans-unit id="916f413ffd5622b866aac763ff8940f66e4a31b9" translate="yes" xml:space="preserve">
          <source>Place &lt;code&gt;&amp;amp;PL_sv_yes&lt;/code&gt; into the specified position &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos&lt;/a&gt;&lt;/code&gt; on the stack.</source>
          <target state="translated">장소 &lt;code&gt;&amp;amp;PL_sv_yes&lt;/code&gt; 지정된 위치에 &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos&lt;/a&gt;&lt;/code&gt; 스택.</target>
        </trans-unit>
        <trans-unit id="9e6b770ad9c900ebf8f52e20c4972e42b76ef551" translate="yes" xml:space="preserve">
          <source>Place &lt;code&gt;&amp;amp;PL_sv_yes&lt;/code&gt; into the specified position &lt;code&gt;pos&lt;/code&gt; on the stack.</source>
          <target state="translated">장소 &lt;code&gt;&amp;amp;PL_sv_yes&lt;/code&gt; 지정된 위치에 &lt;code&gt;pos&lt;/code&gt; 스택.</target>
        </trans-unit>
        <trans-unit id="9b6d516f55eff9b2bccabbdde7685a4b4a9da03f" translate="yes" xml:space="preserve">
          <source>Place a copy of a string into the specified position &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos&lt;/a&gt;&lt;/code&gt; on the stack. The value is stored in a new mortal SV.</source>
          <target state="translated">문자열의 사본을 스택 의 지정된 위치 &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos&lt;/a&gt;&lt;/code&gt; 에 넣습니다 . 값은 새로운 필사 SV에 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="0280f1983669ea3d48307e5d81450dc6030237bb" translate="yes" xml:space="preserve">
          <source>Place a copy of a string into the specified position &lt;code&gt;pos&lt;/code&gt; on the stack. The value is stored in a new mortal SV.</source>
          <target state="translated">스택 의 지정된 위치 &lt;code&gt;pos&lt;/code&gt; 에 문자열 사본을 배치 합니다. 값은 새로운 필사자 SV에 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="4e9ab6d8d695d32843b4420d43d220a9cd88325d" translate="yes" xml:space="preserve">
          <source>Place a double into the specified position &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos&lt;/a&gt;&lt;/code&gt; on the stack. The value is stored in a new mortal SV.</source>
          <target state="translated">스택 의 지정된 위치 &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos&lt;/a&gt;&lt;/code&gt; 에 double을 놓습니다 . 값은 새로운 필사 SV에 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="acaa37c824afdb131865b7892e6a4b9ea9e6bb6f" translate="yes" xml:space="preserve">
          <source>Place a double into the specified position &lt;code&gt;pos&lt;/code&gt; on the stack. The value is stored in a new mortal SV.</source>
          <target state="translated">스택 의 지정된 위치 &lt;code&gt;pos&lt;/code&gt; 에 double을 배치합니다 . 값은 새로운 필사자 SV에 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="cfd0007151ad5655c9cbf9340c82d4632eb28b7a" translate="yes" xml:space="preserve">
          <source>Place a message on the queue with the data from &lt;code&gt;MSG&lt;/code&gt; and with type &lt;code&gt;TYPE&lt;/code&gt; . See &lt;a href=&quot;../functions/msgsnd&quot;&gt;msgsnd&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;MSG&lt;/code&gt; 의 데이터 와 &lt;code&gt;TYPE&lt;/code&gt; 유형 의 메시지를 큐에 배치하십시오 . &lt;a href=&quot;../functions/msgsnd&quot;&gt;msgsnd를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0e44c92ac9de84e3be1e9794c9e8e47af2229079" translate="yes" xml:space="preserve">
          <source>Place a message on the queue with the data from &lt;code&gt;MSG&lt;/code&gt; and with type &lt;code&gt;TYPE&lt;/code&gt;. See &lt;a href=&quot;http://man.he.net/man2/msgsnd&quot;&gt;msgsnd(2)&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;MSG&lt;/code&gt; 의 데이터 와 &lt;code&gt;TYPE&lt;/code&gt; 유형으로 큐에 메시지를 배치하십시오 . &lt;a href=&quot;http://man.he.net/man2/msgsnd&quot;&gt;msgsnd (2)를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="25d30c30326aad079b79429ee5676ce31987795b" translate="yes" xml:space="preserve">
          <source>Place an integer into the specified position &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos&lt;/a&gt;&lt;/code&gt; on the stack. The value is stored in a new mortal SV.</source>
          <target state="translated">스택 의 지정된 위치 &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos&lt;/a&gt;&lt;/code&gt; 에 정수를 넣습니다 . 값은 새로운 필사 SV에 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="710e9af5bbb2e9924ef8178acb3d4818fea16e1d" translate="yes" xml:space="preserve">
          <source>Place an integer into the specified position &lt;code&gt;pos&lt;/code&gt; on the stack. The value is stored in a new mortal SV.</source>
          <target state="translated">스택 의 지정된 위치 &lt;code&gt;pos&lt;/code&gt; 에 정수를 배치합니다 . 값은 새로운 필사자 SV에 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="751296589ec0d0f52635e93df3addb6811063c1f" translate="yes" xml:space="preserve">
          <source>Place an unsigned integer into the specified position &lt;code&gt;pos&lt;/code&gt; on the stack. The value is stored in a new mortal SV.</source>
          <target state="translated">부호없는 정수를 스택 의 지정된 위치 &lt;code&gt;pos&lt;/code&gt; 에 배치합니다. 값은 새로운 필사자 SV에 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="7ab3cd1c8c731f94b45abaa6c37498e8157e7f50" translate="yes" xml:space="preserve">
          <source>Placeholder for a, w, t, T</source>
          <target state="translated">a, w, t, T의 자리 표시 자</target>
        </trans-unit>
        <trans-unit id="51c02f2095250dc21f9cbdf7822d894accd922c2" translate="yes" xml:space="preserve">
          <source>Plain &lt;code&gt;eval&lt;/code&gt; with no argument is just &lt;code&gt;eval EXPR&lt;/code&gt;, where the expression is understood to be contained in &lt;a href=&quot;perlvar#%24_&quot;&gt;&lt;code&gt;$_&lt;/code&gt;&lt;/a&gt;. Thus there are only two real &lt;code&gt;eval&lt;/code&gt; forms; the one with an EXPR is often called &quot;string eval&quot;. In a string eval, the value of the expression (which is itself determined within scalar context) is first parsed, and if there were no errors, executed as a block within the lexical context of the current Perl program. This form is typically used to delay parsing and subsequent execution of the text of EXPR until run time. Note that the value is parsed every time the &lt;code&gt;eval&lt;/code&gt; executes.</source>
          <target state="translated">인수가없는 일반 &lt;code&gt;eval&lt;/code&gt; 은 &lt;code&gt;eval EXPR&lt;/code&gt; 이며 표현식이 &lt;a href=&quot;perlvar#%24_&quot;&gt; &lt;code&gt;$_&lt;/code&gt; &lt;/a&gt; 포함 된 것으로 이해됩니다 . 따라서 실제 &lt;code&gt;eval&lt;/code&gt; 형식 은 두 가지뿐입니다 . EXPR이있는 것은 종종 &quot;문자열 평가&quot;라고합니다. 문자열 평가에서 표현식의 값 (스칼라 컨텍스트 내에서 자체적으로 결정됨)이 먼저 구문 분석되고 오류가없는 경우 현재 Perl 프로그램의 어휘 컨텍스트 내에서 블록으로 실행됩니다. 이 형식은 일반적으로 런타임까지 EXPR 텍스트의 구문 분석 및 후속 실행을 지연하는 데 사용됩니다. 값은 &lt;code&gt;eval&lt;/code&gt; 실행될 때마다 구문 분석됩니다 .</target>
        </trans-unit>
        <trans-unit id="054293d76d1e13ea0985d27d43a20139eff0cdfe" translate="yes" xml:space="preserve">
          <source>Plain Old Comments (Not!)</source>
          <target state="translated">평범한 오래된 댓글 (not!)</target>
        </trans-unit>
        <trans-unit id="9580fcbce0c31ceaa47eb583e5f7ce637fdc8a0a" translate="yes" xml:space="preserve">
          <source>Plain text</source>
          <target state="translated">일반 텍스트</target>
        </trans-unit>
        <trans-unit id="ae2f98a099fe5855c31126233e9c13641ee7fdba" translate="yes" xml:space="preserve">
          <source>Plan</source>
          <target state="translated">Plan</target>
        </trans-unit>
        <trans-unit id="253c3601a5c1772632a58221b654c54c8e50d5ad" translate="yes" xml:space="preserve">
          <source>Plan 9,</source>
          <target state="translated">계획 9,</target>
        </trans-unit>
        <trans-unit id="385e0a23397d52d755976c0e7320a1e9bbbbf5ea" translate="yes" xml:space="preserve">
          <source>Plan events are fired off whenever a plan is declared, done testing is called, or a subtext completes.</source>
          <target state="translated">계획이 선언되거나 테스트 완료가 호출되거나 하위 텍스트가 완료 될 때마다 계획 이벤트가 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="24aa0fed2f1fce379a116b32ca6b7911453a9150" translate="yes" xml:space="preserve">
          <source>Plan handling lifted from Test::More. written by Michael G Schwern &amp;lt;schwern@pobox.com&amp;gt;.</source>
          <target state="translated">Test :: More에서 계획 처리가 해제되었습니다. Michael G Schwern &amp;lt;schwern@pobox.com&amp;gt; 작성.</target>
        </trans-unit>
        <trans-unit id="4b2cf4211ed36a7b6ec3c0f885611d65d2982aae" translate="yes" xml:space="preserve">
          <source>Plan result token.</source>
          <target state="translated">결과 토큰을 계획하십시오.</target>
        </trans-unit>
        <trans-unit id="89a27c59b357dc17fcf14a17fcc79f90df885094" translate="yes" xml:space="preserve">
          <source>Plane 0</source>
          <target state="translated">비행기 0</target>
        </trans-unit>
        <trans-unit id="8be58825425054cbd0b59342becdd853b8548be0" translate="yes" xml:space="preserve">
          <source>Platform Specific</source>
          <target state="translated">플랫폼 별</target>
        </trans-unit>
        <trans-unit id="e0bdb4c07f2772a4a54cf92695aa356c9a6579b0" translate="yes" xml:space="preserve">
          <source>Platform abstraction over &lt;code&gt;inet_ntop()&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;inet_ntop()&lt;/code&gt; 통한 플랫폼 추상화</target>
        </trans-unit>
        <trans-unit id="96c39100db86a74639c0232bfd97c1daf53f3255" translate="yes" xml:space="preserve">
          <source>Platform and configuration independent &lt;code&gt;strtol&lt;/code&gt;. This expands to the appropriate &lt;code&gt;strotol&lt;/code&gt;-like function based on the platform and</source>
          <target state="translated">플랫폼 및 구성 독립적 인 &lt;code&gt;strtol&lt;/code&gt; . 이것은 플랫폼에 따라 적절한 &lt;code&gt;strotol&lt;/code&gt; 과 같은 기능으로 확장 되고</target>
        </trans-unit>
        <trans-unit id="8fbe98f422743bc7e2a75d7c1f99951eb4321f74" translate="yes" xml:space="preserve">
          <source>Platform and configuration independent &lt;code&gt;strtoul&lt;/code&gt;. This expands to the appropriate &lt;code&gt;strotoul&lt;/code&gt;-like function based on the platform and</source>
          <target state="translated">플랫폼 및 구성 독립적 인 &lt;code&gt;strtoul&lt;/code&gt; . 이것은 플랫폼에 따라 적절한 &lt;code&gt;strotoul&lt;/code&gt; 과 같은 기능으로 확장 되고</target>
        </trans-unit>
        <trans-unit id="eb666bc9b27013cda41fa8a2da0d844236374b6f" translate="yes" xml:space="preserve">
          <source>Platform-Specific</source>
          <target state="translated">Platform-Specific</target>
        </trans-unit>
        <trans-unit id="eef47a635b38ce4bb5160d8fbf43c327f07918d8" translate="yes" xml:space="preserve">
          <source>Platform-agnostic MM methods</source>
          <target state="translated">플랫폼에 구애받지 않는 MM 방법</target>
        </trans-unit>
        <trans-unit id="efc0c78db0c6b708dec802259186b13ee8606a83" translate="yes" xml:space="preserve">
          <source>Platform-specific pieces of the build system also live in platform-specific directories like</source>
          <target state="translated">빌드 시스템의 플랫폼 특정 부분은 다음과 같은 플랫폼 특정 디렉토리에 있습니다.</target>
        </trans-unit>
        <trans-unit id="67155fe2d558d3be96473a78ebaa5f39e1acf3d8" translate="yes" xml:space="preserve">
          <source>Platforms that do not have &lt;code&gt;rdev&lt;/code&gt;, &lt;code&gt;blksize&lt;/code&gt;, or &lt;code&gt;blocks&lt;/code&gt; will return these as &lt;code&gt;''&lt;/code&gt;, so numeric comparison or manipulation of these fields may cause 'not numeric' warnings.</source>
          <target state="translated">&lt;code&gt;rdev&lt;/code&gt; , &lt;code&gt;blksize&lt;/code&gt; 또는 &lt;code&gt;blocks&lt;/code&gt; 이 없는 플랫폼은 이를 &lt;code&gt;''&lt;/code&gt; 로 반환 하므로 이러한 필드의 숫자 비교 또는 조작으로 인해 '숫자가 아님'경고가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2151168060825531d644ad2c9ef307ad23d45dd1" translate="yes" xml:space="preserve">
          <source>Platforms that do not have rdev, blksize, or blocks will return these as '', so numeric comparison or manipulation of these fields may cause 'not numeric' warnings.</source>
          <target state="translated">rdev, blksize 또는 block이없는 플랫폼은이를 ''로 반환하므로 이러한 필드를 숫자로 비교하거나 조작하면 '숫자가 아님'경고가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cb78dc6caa9da43d8d82895592406c2fb238b4d0" translate="yes" xml:space="preserve">
          <source>Playing Safe</source>
          <target state="translated">안전한 연주</target>
        </trans-unit>
        <trans-unit id="f5f50c6b28a2dbf428734248274d14fcc946d37a" translate="yes" xml:space="preserve">
          <source>Please add examples to what follows!</source>
          <target state="translated">다음에 예를 추가하십시오!</target>
        </trans-unit>
        <trans-unit id="90db41980a6ddf9879d54f849f2452dacbc9ddd8" translate="yes" xml:space="preserve">
          <source>Please be aware that code in debugger listings may not look the same as your original source code. Line directives and external source filters can alter the code before Perl sees it, causing code to move from its original positions or take on entirely different forms.</source>
          <target state="translated">디버거 목록의 코드는 원래 소스 코드와 동일하지 않을 수 있습니다. 라인 지시문과 외부 소스 필터는 Perl에서 코드를보기 전에 코드를 변경하여 코드가 원래 위치에서 이동하거나 완전히 다른 형태를 취할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6e35b70405206d942352bd9cec349bc8a7f2d0ac" translate="yes" xml:space="preserve">
          <source>Please check individual plugin documentation for more details.</source>
          <target state="translated">자세한 내용은 개별 플러그인 설명서를 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="46a88c30ac9775bf9675292bcf8883102c284165" translate="yes" xml:space="preserve">
          <source>Please check the archive of the perl5-porters list (see below) and/or the bug tracking system before submitting a bug report. Often, you'll find that the bug has been reported already.</source>
          <target state="translated">버그 보고서를 제출하기 전에 perl5-porters 목록 (아래 참조) 및 / 또는 버그 추적 시스템의 아카이브를 확인하십시오. 버그가 이미보고 된 경우가 종종 있습니다.</target>
        </trans-unit>
        <trans-unit id="30d084e470b1305e613cce5c8a8f760ce12b4e60" translate="yes" xml:space="preserve">
          <source>Please e-mail us with problems, bug fixes, comments and complaints, although if you have compliments you should send them to Raphael. Please don't e-mail Raphael with problems, as he no longer works on Storable, and your message will be delayed while he forwards it to us.</source>
          <target state="translated">문제, 버그 수정, 의견 및 불만 사항이 있으면 이메일을 보내주십시오. 칭찬이 있으면 Raphael에 보내십시오. Raphael에게 더 이상 Storable에 대해 작업하지 않으므로 전자 메일을 보내지 마십시오. 메시지가 우리에게 전달되는 동안 지연됩니다.</target>
        </trans-unit>
        <trans-unit id="c431b3a19986ac53c575f9800468af7f81b46d87" translate="yes" xml:space="preserve">
          <source>Please feedback what is wrong</source>
          <target state="translated">무엇이 잘못되었는지 의견을 보내주세요.</target>
        </trans-unit>
        <trans-unit id="30c152b00259545a7771c21e247f5c5553ad4a6f" translate="yes" xml:space="preserve">
          <source>Please inform the module author if this is necessary to successfully install a module under 5.6 or later.</source>
          <target state="translated">5.6 이상에서 모듈을 성공적으로 설치하는 데 필요한 경우 모듈 작성자에게 알려주십시오.</target>
        </trans-unit>
        <trans-unit id="8b79f33567ebd39e312df677117f1f02c643059b" translate="yes" xml:space="preserve">
          <source>Please keep this list up-to-date by informing me about other items.</source>
          <target state="translated">다른 항목에 대해 알려 주면이 목록을 최신 상태로 유지하십시오.</target>
        </trans-unit>
        <trans-unit id="d8e4357df6c51adf400f25dbaa777916223b07af" translate="yes" xml:space="preserve">
          <source>Please make sure the SDK version (i.e. the numbers right before '.sdk') matches your system's (in this case, Mac OS X 10.8 &quot;Mountain Lion&quot;), as it is possible to have more than one SDK installed. Also make sure the path exists in your system, and if it doesn't please make sure the SDK is properly installed, as it should come with the 'Command Line Tools' bundle mentioned above. Finally, if you have an older Mac OS X (10.6 &quot;Snow Leopard&quot; and below) running Xcode 4.2 or lower, the SDK path might be something like &lt;code&gt;'/Developer/SDKs/MacOSX10.3.9.sdk'&lt;/code&gt; .</source>
          <target state="translated">SDK를 여러 개 설치할 수 있으므로 SDK 버전 (예 : '.sdk'바로 앞의 숫자)이 시스템의 시스템 (이 경우 Mac OS X 10.8 &quot;Mountain Lion&quot;)과 일치하는지 확인하십시오. 또한 시스템에 경로가 있는지 확인하고, 그렇지 않은 경우 위에 언급 된 '명령 줄 도구'번들과 함께 제공되는 SDK가 제대로 설치되어 있는지 확인하십시오. 마지막으로 Xcode 4.2 이하를 실행하는 이전 Mac OS X (10.6 &quot;Snow Leopard&quot;이하)가있는 경우 SDK 경로는 &lt;code&gt;'/Developer/SDKs/MacOSX10.3.9.sdk'&lt;/code&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="83b8ae2c8755481b5060b9d197a3f14fa03b0c26" translate="yes" xml:space="preserve">
          <source>Please make sure the SDK version (i.e. the numbers right before '.sdk') matches your system's (in this case, Mac OS X 10.8 &quot;Mountain Lion&quot;), as it is possible to have more than one SDK installed. Also make sure the path exists in your system, and if it doesn't please make sure the SDK is properly installed, as it should come with the 'Command Line Tools' bundle mentioned above. Finally, if you have an older Mac OS X (10.6 &quot;Snow Leopard&quot; and below) running Xcode 4.2 or lower, the SDK path might be something like &lt;code&gt;'/Developer/SDKs/MacOSX10.3.9.sdk'&lt;/code&gt;.</source>
          <target state="translated">둘 이상의 SDK를 설치할 수 있으므로 SDK 버전 (예 : '.sdk'바로 앞의 숫자)이 시스템 (이 경우 Mac OS X 10.8 &quot;Mountain Lion&quot;)과 일치하는지 확인하십시오. 또한 시스템에 경로가 있는지 확인하고, 그렇지 않은 경우 위에서 언급 한 '명령 줄 도구'번들과 함께 제공되어야하므로 SDK가 제대로 설치되었는지 확인하십시오. 마지막으로 Xcode 4.2 이하를 실행하는 구형 Mac OS X (10.6 &quot;Snow Leopard&quot;이하)를 사용하는 경우 SDK 경로는 &lt;code&gt;'/Developer/SDKs/MacOSX10.3.9.sdk'&lt;/code&gt; 와 같은 형식 일 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="93b9716fcd4491544e9d39d5e1bcaaba2e6587ef" translate="yes" xml:space="preserve">
          <source>Please make sure you add the perldelta entry to the right section within</source>
          <target state="translated">perldelta 항목을 오른쪽 섹션에 추가하십시오</target>
        </trans-unit>
        <trans-unit id="4af848fa0de6bb5d98f95a63ab5b33868a64d534" translate="yes" xml:space="preserve">
          <source>Please make your issue title informative. &quot;a bug&quot; is not informative. Neither is &quot;perl crashes&quot; nor is &quot;HELP!!!&quot;. These don't help. A compact description of what's wrong is fine.</source>
          <target state="translated">문제 제목을 유익하게 만드십시오. &quot;버그&quot;는 유익하지 않습니다. &quot;perl crash&quot;도 &quot;HELP !!!&quot;도 아닙니다. 이것들은 도움이되지 않습니다. 무엇이 잘못되었는지에 대한 간략한 설명은 괜찮습니다.</target>
        </trans-unit>
        <trans-unit id="23a323093ed3237613762e5f23d911eb5beeb543" translate="yes" xml:space="preserve">
          <source>Please note a significant difference in the behavior of &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; in the &lt;code&gt;PERL_VMS_POSIX_EXIT&lt;/code&gt; mode is that it does not force a VMS SEVERE_ERROR status on exit. The Unix exit values of 2 through 255 will be encoded in VMS status values with severity levels of SUCCESS. The Unix exit value of 1 will be encoded in a VMS status value with a severity level of ERROR. This is to be compatible with how the VMS C library encodes these values.</source>
          <target state="translated">&lt;code&gt;PERL_VMS_POSIX_EXIT&lt;/code&gt; 모드 에서 &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; 동작의 중요한 차이점 은 종료시 VMS SEVERE_ERROR 상태를 강요하지 않는다는 것입니다. 2-255의 Unix 종료 값은 심각도 SUCCESS의 VMS 상태 값으로 인코딩됩니다. Unix 종료 값 1은 심각도 수준이 ERROR 인 VMS 상태 값으로 인코딩됩니다. 이는 VMS C 라이브러리가 이러한 값을 인코딩하는 방법과 호환됩니다.</target>
        </trans-unit>
        <trans-unit id="6c177938660fc8c8c17b75bc3c856520fd266ed0" translate="yes" xml:space="preserve">
          <source>Please note a significant difference in the behavior of &lt;code&gt;die&lt;/code&gt; in the &lt;code&gt;PERL_VMS_POSIX_EXIT&lt;/code&gt; mode is that it does not force a VMS SEVERE_ERROR status on exit. The Unix exit values of 2 through 255 will be encoded in VMS status values with severity levels of SUCCESS. The Unix exit value of 1 will be encoded in a VMS status value with a severity level of ERROR. This is to be compatible with how the VMS C library encodes these values.</source>
          <target state="translated">&lt;code&gt;PERL_VMS_POSIX_EXIT&lt;/code&gt; 모드 에서 &lt;code&gt;die&lt;/code&gt; 동작의 중요한 차이점 은 종료시 VMS SEVERE_ERROR 상태를 강제하지 않는다는 것입니다. 2에서 255까지의 Unix 종료 값은 심각도 수준이 SUCCESS 인 VMS 상태 값으로 인코딩됩니다. Unix 종료 값 1은 심각도 수준이 ERROR 인 VMS 상태 값으로 인코딩됩니다. 이것은 VMS C 라이브러리가 이러한 값을 인코딩하는 방법과 호환됩니다.</target>
        </trans-unit>
        <trans-unit id="acb93428fa7988b6bd9d3d5b914c777174b9e347" translate="yes" xml:space="preserve">
          <source>Please note that ':constant' does not affect integer constants, nor binary nor hexadecimal constants. Use &lt;a href=&quot;../bignum&quot;&gt;bignum&lt;/a&gt; or &lt;a href=&quot;bigint&quot;&gt;Math::BigInt&lt;/a&gt; to get this to work.</source>
          <target state="translated">': constant'는 정수 상수 나 2 진 또는 16 진 상수에 영향을 미치지 않습니다. &lt;a href=&quot;../bignum&quot;&gt;bignum&lt;/a&gt; 또는 &lt;a href=&quot;bigint&quot;&gt;Math :: BigInt&lt;/a&gt; 를 사용 하여 작동 시키십시오.</target>
        </trans-unit>
        <trans-unit id="06ca6df37fb7aa8ce55441f1d546847190fefd39" translate="yes" xml:space="preserve">
          <source>Please note that ':constant' does not affect integer constants, nor binary nor hexadecimal constants. Use &lt;a href=&quot;bignum&quot;&gt;bignum&lt;/a&gt; or &lt;a href=&quot;Math::BigInt&quot;&gt;Math::BigInt&lt;/a&gt; to get this to work.</source>
          <target state="translated">': constant'는 정수 상수, 바이너리 또는 16 진수 상수에 영향을주지 않습니다. 이 작업을 수행 하려면 &lt;a href=&quot;bignum&quot;&gt;bignum&lt;/a&gt; 또는 &lt;a href=&quot;Math::BigInt&quot;&gt;Math :: BigInt&lt;/a&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="2d144a30f04447f4891231cca52898c1f409adce" translate="yes" xml:space="preserve">
          <source>Please note that &lt;code&gt;&lt;a href=&quot;../functions/local&quot;&gt;local($tabstop)&lt;/a&gt;&lt;/code&gt; doesn't do the right thing and if you want to use &lt;code&gt;&lt;a href=&quot;../functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; to override &lt;code&gt;$tabstop&lt;/code&gt; , you need to use &lt;code&gt;&lt;a href=&quot;../functions/local&quot;&gt;local($Text::Tabs::tabstop)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">노트는 것을 바랍니다 &lt;code&gt;&lt;a href=&quot;../functions/local&quot;&gt;local($tabstop)&lt;/a&gt;&lt;/code&gt; 올바른 일을하지 않고 사용할 경우 &lt;code&gt;&lt;a href=&quot;../functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; 재정의 &lt;code&gt;$tabstop&lt;/code&gt; , 당신은 사용할 필요가 &lt;code&gt;&lt;a href=&quot;../functions/local&quot;&gt;local($Text::Tabs::tabstop)&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9aa5bbfabef472a29774dca149c4460b4d54f432" translate="yes" xml:space="preserve">
          <source>Please note that &lt;code&gt;local($tabstop)&lt;/code&gt; doesn't do the right thing and if you want to use &lt;code&gt;local&lt;/code&gt; to override &lt;code&gt;$tabstop&lt;/code&gt;, you need to use &lt;code&gt;local($Text::Tabs::tabstop)&lt;/code&gt;.</source>
          <target state="translated">노트는 것을 바랍니다 &lt;code&gt;local($tabstop)&lt;/code&gt; 올바른 일을하지 않고 사용할 경우 &lt;code&gt;local&lt;/code&gt; 재정의 &lt;code&gt;$tabstop&lt;/code&gt; , 당신은 사용할 필요가 &lt;code&gt;local($Text::Tabs::tabstop)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="633a4db7a1c782ae1b6e824e0fc9e69a016269b6" translate="yes" xml:space="preserve">
          <source>Please note that Math::BigFloat does &lt;b&gt;not&lt;/b&gt; use the denoted library itself, but it merely passes the lib argument to Math::BigInt. So, instead of the need to do:</source>
          <target state="translated">Math :: BigFloat는 표시된 라이브러리 자체를 사용 하지 &lt;b&gt;않지만&lt;/b&gt; lib 인수를 Math :: BigInt에 전달합니다. 따라서 할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="a54801dfc85b8f9fc3dbd94457ccfddcfab12f10" translate="yes" xml:space="preserve">
          <source>Please note that POD has the notion of &quot;paragraphs&quot;: this is something starting</source>
          <target state="translated">POD에는 &quot;문단&quot;이라는 개념이 있습니다.</target>
        </trans-unit>
        <trans-unit id="72307c57d87a56e5608808a2107363696283fed6" translate="yes" xml:space="preserve">
          <source>Please note that if multiple files are parsed for a single POD document (perhaps the result of some kind of &lt;code&gt;=include&lt;/code&gt; directive) this method is invoked for every file that is parsed. If you wish to perform certain cleanup actions once per document, then you should use &lt;b&gt;end_pod()&lt;/b&gt;.</source>
          <target state="translated">단일 POD 문서 (아마도 일종의 &lt;code&gt;=include&lt;/code&gt; 지시문 의 결과)에 대해 여러 파일이 구문 분석되는 경우 구문 분석 되는 모든 파일에 대해이 메소드가 호출됩니다. 문서 당 특정 정리 작업을 수행하려면 &lt;b&gt;end_pod ()&lt;/b&gt; 를 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="10f71534786c6e41d011fbc9deff5549daf1fe0b" translate="yes" xml:space="preserve">
          <source>Please note that if the layer is created in the PerlIO::via:: namespace, it does &lt;b&gt;not&lt;/b&gt; have to be fully qualified. The PerlIO::via module will prefix the PerlIO::via:: namespace if the specified modulename does not exist as a fully qualified module name.</source>
          <target state="translated">PerlIO :: via :: 네임 스페이스에서 계층을 생성 한 경우 정규화 할 필요 는 &lt;b&gt;없습니다&lt;/b&gt; . 지정된 모듈 이름이 정규화 된 모듈 이름으로 존재하지 않으면 PerlIO :: via 모듈이 PerlIO :: via :: 네임 스페이스 앞에 붙습니다.</target>
        </trans-unit>
        <trans-unit id="713c4ec8dda734601e7b059dd41a997e18f77cd8" translate="yes" xml:space="preserve">
          <source>Please note that on Windows platforms colorized output also requires the Win32::Console::ANSI module.</source>
          <target state="translated">Windows 플랫폼에서 색상 화 된 출력에는 Win32 :: Console :: ANSI 모듈도 필요합니다.</target>
        </trans-unit>
        <trans-unit id="b414f05f7085ad8d048ca6abb13a1f7ce979a37b" translate="yes" xml:space="preserve">
          <source>Please note that some of the trigonometric functions can break out from the &lt;b&gt;real axis&lt;/b&gt; into the &lt;b&gt;complex plane&lt;/b&gt;. For example &lt;code&gt;asin(2)&lt;/code&gt; has no definition for plain real numbers but it has definition for complex numbers.</source>
          <target state="translated">삼각 함수 중 일부는 &lt;b&gt;실제 축&lt;/b&gt; 에서 &lt;b&gt;복잡한 평면&lt;/b&gt; 으로 나올 수 있습니다 . 예를 들어 &lt;code&gt;asin(2)&lt;/code&gt; 에는 일반 실수에 대한 정의가 없지만 복소수에 대한 정의가 있습니다.</target>
        </trans-unit>
        <trans-unit id="2b7c92535c70d75e42791f8ddb48d4ce9ec51fc0" translate="yes" xml:space="preserve">
          <source>Please note that strings and floating point constants are not affected, so that</source>
          <target state="translated">문자열과 부동 소수점 상수는 영향을받지 않으므로</target>
        </trans-unit>
        <trans-unit id="c7e396ad592125eb642ceacdd629f60983df2bdf" translate="yes" xml:space="preserve">
          <source>Please note that the &lt;b&gt;preprocess_line()&lt;/b&gt; method is invoked</source>
          <target state="translated">있습니다 &lt;b&gt;preprocess_line ()&lt;/b&gt; 메소드가 호출</target>
        </trans-unit>
        <trans-unit id="5653094baeaeebceed5e5c79fc61bfba84826926" translate="yes" xml:space="preserve">
          <source>Please note that the first &lt;code&gt;good&lt;/code&gt; state must be an ancestor of the first &lt;code&gt;bad&lt;/code&gt; state. If you want to search for the commit that</source>
          <target state="translated">첫 번째 &lt;code&gt;good&lt;/code&gt; 상태는 첫 번째 &lt;code&gt;bad&lt;/code&gt; 상태 의 조상이어야합니다 . 커밋을 검색하려면</target>
        </trans-unit>
        <trans-unit id="865709c0c581d8169eede3efc9f220dad69fc01d" translate="yes" xml:space="preserve">
          <source>Please note that this is an area of recent development in Perl and that the interface described here is therefore still subject to change (and hopefully will have better documentation and more examples).</source>
          <target state="translated">이것은 Perl에서 최근 개발 된 영역이므로 여기에 설명 된 인터페이스는 여전히 변경 될 수 있습니다 (그리고 더 나은 문서와 더 많은 예제가 있기를 바랍니다).</target>
        </trans-unit>
        <trans-unit id="9d1dda7d4ff18b02aa0b290b258576653be091e9" translate="yes" xml:space="preserve">
          <source>Please note that this layer is implied when calling open() thus:</source>
          <target state="translated">이 레이어는 open ()을 호출 할 때 내포됩니다.</target>
        </trans-unit>
        <trans-unit id="14bd27e9d494565b2545ea76d64ba9560ebda982" translate="yes" xml:space="preserve">
          <source>Please note that while this module works on Perl 5.6, it is no longer being routinely tested on 5.6 - the earliest Perl version being routinely tested, and expressly supported, is 5.8.1. However, patches to repair any breakage on 5.6 are still being accepted.</source>
          <target state="translated">이 모듈은 Perl 5.6에서 작동하지만 더 이상 5.6에서 일상적으로 테스트되지 않습니다. 일상적으로 테스트되고 명시 적으로 지원되는 최초의 Perl 버전은 5.8.1입니다. 그러나 5.6에서 손상된 부분을 복구하기위한 패치는 여전히 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="538443df0be8abcb2c7740f09bb5b4b6d88ac69f" translate="yes" xml:space="preserve">
          <source>Please note the following does not work as expected (prints nothing), since overloading of '..' is not yet possible in Perl (as of v5.8.0):</source>
          <target state="translated">Perl에서는 '..'의 오버로드가 아직 가능하지 않기 때문에 (v5.8.0 기준) 다음과 같이 예상대로 작동하지 않습니다 (아무것도 인쇄하지 않음).</target>
        </trans-unit>
        <trans-unit id="81118967e42641b9c6eb5f04cdbe62abe7740600" translate="yes" xml:space="preserve">
          <source>Please note: This mode of operation is no longer supported as of Perl v5.26.</source>
          <target state="translated">참고 :이 작동 모드는 Perl v5.26부터 더 이상 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="fdc3f6a4a31c88f4e79077f99064bd4223a68148" translate="yes" xml:space="preserve">
          <source>Please note: in the general case, you're better off using &lt;a href=&quot;encode#decode&quot;&gt;&lt;code&gt;Encode::decode('UTF-8', $utf)&lt;/code&gt;&lt;/a&gt; to decode a UTF-8 encoded byte string to a Perl Unicode string, and &lt;a href=&quot;encode#encode&quot;&gt;&lt;code&gt;Encode::encode('UTF-8', $str)&lt;/code&gt;&lt;/a&gt; to encode a Perl Unicode string to UTF-8 bytes. These functions provide means of handling invalid byte sequences and generally have a friendlier interface.</source>
          <target state="translated">참고 : 일반적으로 &lt;a href=&quot;encode#decode&quot;&gt; &lt;code&gt;Encode::decode('UTF-8', $utf)&lt;/code&gt; &lt;/a&gt; 를 사용하여 UTF-8로 인코딩 된 바이트 문자열을 Perl 유니 코드 문자열로 디코딩하고 &lt;a href=&quot;encode#encode&quot;&gt; &lt;code&gt;Encode::encode('UTF-8', $str)&lt;/code&gt; &lt;/a&gt; 을 사용하여 Perl 유니 코드 문자열을 UTF-8 바이트로 인코딩합니다. 이러한 함수는 유효하지 않은 바이트 시퀀스를 처리하는 수단을 제공하며 일반적으로 더 친숙한 인터페이스를 가지고 있습니다.</target>
        </trans-unit>
        <trans-unit id="a240f0a420b088c6642d6eafb7c3deb2f9e741be" translate="yes" xml:space="preserve">
          <source>Please note: in the general case, you're better off using Encode::decode_utf8 to decode a UTF-8 encoded byte string to a Perl Unicode string, and Encode::encode_utf8 to encode a Perl Unicode string to UTF-8 bytes. These functions provide means of handling invalid byte sequences and generally have a friendlier interface.</source>
          <target state="translated">참고 : 일반적으로 Encode :: decode_utf8을 사용하여 UTF-8로 인코딩 된 바이트 문자열을 Perl 유니 코드 문자열로 디코딩하고 Encode :: encode_utf8을 사용하여 Perl 유니 코드 문자열을 UTF-8 바이트로 인코딩하는 것이 좋습니다. 이 함수는 유효하지 않은 바이트 시퀀스를 처리하는 수단을 제공하며 일반적으로 친숙한 인터페이스를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="a968cbb027497bb1dd61f62478bee1c4fb7295eb" translate="yes" xml:space="preserve">
          <source>Please note: the two functions defined above are</source>
          <target state="translated">참고 : 위에서 정의한 두 가지 기능은</target>
        </trans-unit>
        <trans-unit id="59a34246a11ef1f18ccb92fad013882849039fa3" translate="yes" xml:space="preserve">
          <source>Please read &lt;a href=&quot;#COPYRIGHT&quot;&gt;&quot;COPYRIGHT&quot;&lt;/a&gt; before using version 2.x or greater of Berkeley DB with DB_File.</source>
          <target state="translated">Berkeley DB 버전 2.x 이상을 DB_File과 함께 사용하기 전에 &lt;a href=&quot;#COPYRIGHT&quot;&gt;&quot;저작권&quot;을&lt;/a&gt; 읽어보십시오 .</target>
        </trans-unit>
        <trans-unit id="e14b19aff89c4aad18c1b1f461b6bc9f9f18afb0" translate="yes" xml:space="preserve">
          <source>Please read &lt;a href=&quot;#COPYRIGHT&quot;&gt;COPYRIGHT&lt;/a&gt; before using version 2.x or greater of Berkeley DB with DB_File.</source>
          <target state="translated">Ber_ley DB 버전 2.x 이상을 DB_File과 함께 사용하기 전에 &lt;a href=&quot;#COPYRIGHT&quot;&gt;COPYRIGHT&lt;/a&gt; 를 읽으십시오 .</target>
        </trans-unit>
        <trans-unit id="a49d7388a9b16b3144a078e3b5020dee8701b8c5" translate="yes" xml:space="preserve">
          <source>Please refer to the &lt;code&gt;Archive::Tar::File&lt;/code&gt; documentation on how to handle these objects.</source>
          <target state="translated">이러한 객체를 처리하는 방법에 대해서는 &lt;code&gt;Archive::Tar::File&lt;/code&gt; 문서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="63dd61b82f101f26826b0ee19baaf07fb1de5b36" translate="yes" xml:space="preserve">
          <source>Please refer to the MSDN documentation of the CSIDL constants, currently available at:</source>
          <target state="translated">현재 사용 가능한 CSIDL 상수에 대한 MSDN 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="9ba05ea79d06558fc847ddce39fd58ed9e3603b4" translate="yes" xml:space="preserve">
          <source>Please refer to your native fcntl(2), open(2), fseek(3), lseek(2) (equal to Perl's seek() and sysseek(), respectively), and chmod(2) documentation to see what constants are implemented in your system.</source>
          <target state="translated">어떤 상수가 있는지 보려면 네이티브 fcntl (2), open (2), fseek (3), lseek (2) (각각 Perl의 seek () 및 sysseek ()와 동일) 및 chmod (2) 설명서를 참조하십시오. 시스템에서 구현됩니다.</target>
        </trans-unit>
        <trans-unit id="c84d853900a8b1e8461d42ec22c7bb0bc4e4555b" translate="yes" xml:space="preserve">
          <source>Please remember to send me an updated entry for the Module list!</source>
          <target state="translated">모듈 목록에 대한 업데이트 된 항목을 보내주십시오.</target>
        </trans-unit>
        <trans-unit id="9d4f61b83a34e9d17810bf3a6beba8149a3099ab" translate="yes" xml:space="preserve">
          <source>Please report all bugs on the RT queue, either via the web interface:</source>
          <target state="translated">웹 인터페이스를 통해 RT 대기열에있는 모든 버그를보고하십시오.</target>
        </trans-unit>
        <trans-unit id="fc5ac378228cc627e576428f688749bb3cf44169" translate="yes" xml:space="preserve">
          <source>Please report all bugs on the RT queue:</source>
          <target state="translated">RT 큐에있는 모든 버그를보고하십시오 :</target>
        </trans-unit>
        <trans-unit id="cd1826396d92eaf26d7671cebd0646515ababb89" translate="yes" xml:space="preserve">
          <source>Please report any bugs or feature requests through the issue tracker at &lt;a href=&quot;http://rt.cpan.org/Public/Dist/Display.html?Name=Parse-CPAN-Meta&quot;&gt;http://rt.cpan.org/Public/Dist/Display.html?Name=Parse-CPAN-Meta&lt;/a&gt;. You will be notified automatically of any progress on your issue.</source>
          <target state="translated">&lt;a href=&quot;http://rt.cpan.org/Public/Dist/Display.html?Name=Parse-CPAN-Meta&quot;&gt;http://rt.cpan.org/Public/Dist/Display.html?Name=Parse-CPAN-Meta&lt;/a&gt; 에서 이슈 트래커를 통해 버그 나 기능 요청을보고하십시오 . 문제 진행 상황을 자동으로 알려줍니다.</target>
        </trans-unit>
        <trans-unit id="f29e539c9949d7fd976fcf0ef31e3d520dfef64c" translate="yes" xml:space="preserve">
          <source>Please report any bugs or feature requests through the issue tracker at &lt;a href=&quot;https://github.com/Perl-Toolchain-Gang/CPAN-Meta-Requirements/issues&quot;&gt;https://github.com/Perl-Toolchain-Gang/CPAN-Meta-Requirements/issues&lt;/a&gt;. You will be notified automatically of any progress on your issue.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/Perl-Toolchain-Gang/CPAN-Meta-Requirements/issues&quot;&gt;https://github.com/Perl-Toolchain-Gang/CPAN-Meta-Requirements/issues&lt;/a&gt; 의 문제 추적기를 통해 버그 또는 기능 요청을보고 하십시오 . 문제에 대한 진행 상황을 자동으로 알려드립니다.</target>
        </trans-unit>
        <trans-unit id="e10dad34d98d968a9e79abbac903596e6421800b" translate="yes" xml:space="preserve">
          <source>Please report any bugs or feature requests through the issue tracker at &lt;a href=&quot;https://github.com/Perl-Toolchain-Gang/CPAN-Meta/issues&quot;&gt;https://github.com/Perl-Toolchain-Gang/CPAN-Meta/issues&lt;/a&gt;. You will be notified automatically of any progress on your issue.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/Perl-Toolchain-Gang/CPAN-Meta/issues&quot;&gt;https://github.com/Perl-Toolchain-Gang/CPAN-Meta/issues&lt;/a&gt; 의 이슈 트래커를 통해 버그 또는 기능 요청을보고 하십시오 . 문제에 대한 진행 상황을 자동으로 알려드립니다.</target>
        </trans-unit>
        <trans-unit id="95a04dfd4c1fc483cefbbd64e9cf7d0f5a2a01dc" translate="yes" xml:space="preserve">
          <source>Please report any bugs or feature requests through the issue tracker at &lt;a href=&quot;https://github.com/Perl-Toolchain-Gang/Perl-OSType/issues&quot;&gt;https://github.com/Perl-Toolchain-Gang/Perl-OSType/issues&lt;/a&gt;. You will be notified automatically of any progress on your issue.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/Perl-Toolchain-Gang/Perl-OSType/issues&quot;&gt;https://github.com/Perl-Toolchain-Gang/Perl-OSType/issues&lt;/a&gt; 의 문제 추적기를 통해 버그 또는 기능 요청을보고 하십시오 . 문제에 대한 진행 상황을 자동으로 알려드립니다.</target>
        </trans-unit>
        <trans-unit id="2b3e9326f48a70cd35e62a3e7c3c1b10a005c4e2" translate="yes" xml:space="preserve">
          <source>Please report any bugs or feature requests through the issue tracker at &lt;a href=&quot;https://github.com/chansen/p5-http-tiny/issues&quot;&gt;https://github.com/chansen/p5-http-tiny/issues&lt;/a&gt;. You will be notified automatically of any progress on your issue.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/chansen/p5-http-tiny/issues&quot;&gt;https://github.com/chansen/p5-http-tiny/issues&lt;/a&gt; 의 이슈 트래커를 통해 버그 또는 기능 요청을보고 하십시오 . 문제에 대한 진행 상황을 자동으로 알려드립니다.</target>
        </trans-unit>
        <trans-unit id="54e910ef38da12f1e82d477c66613f898afde850" translate="yes" xml:space="preserve">
          <source>Please report any bugs or feature requests through the issue tracker at L</source>
          <target state="translated">L의 이슈 트래커를 통해 버그 또는 기능 요청을보고하십시오.</target>
        </trans-unit>
        <trans-unit id="bb7ffcd32fde8fcb70ebf33b96ca410b8c21fd4d" translate="yes" xml:space="preserve">
          <source>Please report any bugs or feature requests to &lt;code&gt;bug-math-bigint at rt.cpan.org&lt;/code&gt; , or through the web interface at &lt;a href=&quot;https://rt.cpan.org/Ticket/Create.html?Queue=Math-BigInt&quot;&gt;https://rt.cpan.org/Ticket/Create.html?Queue=Math-BigInt&lt;/a&gt; (requires login). We will be notified, and then you'll automatically be notified of progress on your bug as I make changes.</source>
          <target state="translated">&lt;code&gt;bug-math-bigint at rt.cpan.org&lt;/code&gt; 또는 &lt;a href=&quot;https://rt.cpan.org/Ticket/Create.html?Queue=Math-BigInt&quot;&gt;https://rt.cpan.org/Ticket/Create.html?Queue=Math-BigInt&lt;/a&gt; 의 웹 인터페이스를 통해 bug-math-bigint에 버그 또는 기능 요청을 보고 하십시오 (로그인 필요). ). 알림을 받으면 변경 사항에 따라 버그 진행 상황을 자동으로 알립니다.</target>
        </trans-unit>
        <trans-unit id="7c1ec7a85f06c97f5ca00ceba49cd056337d425f" translate="yes" xml:space="preserve">
          <source>Please report any bugs or feature requests to &lt;code&gt;bug-math-bigint at rt.cpan.org&lt;/code&gt;, or through the web interface at &lt;a href=&quot;https://rt.cpan.org/Ticket/Create.html?Queue=Math-BigInt&quot;&gt;https://rt.cpan.org/Ticket/Create.html?Queue=Math-BigInt&lt;/a&gt; (requires login). We will be notified, and then you'll automatically be notified of progress on your bug as I make changes.</source>
          <target state="translated">&lt;code&gt;bug-math-bigint at rt.cpan.org&lt;/code&gt; 또는 &lt;a href=&quot;https://rt.cpan.org/Ticket/Create.html?Queue=Math-BigInt&quot;&gt;https://rt.cpan.org/Ticket/Create.html?Queue=Math-BigInt&lt;/a&gt; 의 웹 인터페이스를 통해 버그 또는 기능 요청을 보고 하십시오 (로그인 필요 ). 알림을받은 다음 변경하는 동안 버그에 대한 진행 상황을 자동으로 알림을 받게 될 것입니다. ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ</target>
        </trans-unit>
        <trans-unit id="4855ec4202fef3ce386c7a181d6e6a5bd1e45ec3" translate="yes" xml:space="preserve">
          <source>Please report any bugs or feature requests to &lt;code&gt;bug-math-bigint at rt.cpan.org&lt;/code&gt;, or through the web interface at &lt;a href=&quot;https://rt.cpan.org/Ticket/Create.html?Queue=bignum&quot;&gt;https://rt.cpan.org/Ticket/Create.html?Queue=bignum&lt;/a&gt; (requires login). We will be notified, and then you'll automatically be notified of progress on your bug as I make changes.</source>
          <target state="translated">버그 또는 기능 요청 &lt;code&gt;bug-math-bigint at rt.cpan.org&lt;/code&gt; 또는 &lt;a href=&quot;https://rt.cpan.org/Ticket/Create.html?Queue=bignum&quot;&gt;https://rt.cpan.org/Ticket/Create.html?Queue=bignum&lt;/a&gt; 의 웹 인터페이스를 통해보고 하십시오 (로그인 필요). 알림을받은 다음 변경하는 동안 버그에 대한 진행 상황을 자동으로 알림을 받게 될 것입니다. ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ</target>
        </trans-unit>
        <trans-unit id="4f1e163ae4819860c0befb05416f4880530b21f6" translate="yes" xml:space="preserve">
          <source>Please report any bugs or feature requests to &lt;code&gt;bug-math-bigint-fastcalc at rt.cpan.org&lt;/code&gt;, or through the web interface at &lt;a href=&quot;https://rt.cpan.org/Ticket/Create.html?Queue=Math-BigInt-FastCalc&quot;&gt;https://rt.cpan.org/Ticket/Create.html?Queue=Math-BigInt-FastCalc&lt;/a&gt; (requires login). We will be notified, and then you'll automatically be notified of progress on your bug as I make changes.</source>
          <target state="translated">버그 또는 기능 요청 &lt;code&gt;bug-math-bigint-fastcalc at rt.cpan.org&lt;/code&gt; 또는 &lt;a href=&quot;https://rt.cpan.org/Ticket/Create.html?Queue=Math-BigInt-FastCalc&quot;&gt;https://rt.cpan.org/Ticket/Create.html?Queue=Math-BigInt-&lt;/a&gt; 의 웹 인터페이스를 통해보고 하십시오. FastCalc (로그인 필요). 알림을받은 다음 변경하는 동안 버그에 대한 진행 상황을 자동으로 알림을 받게 될 것입니다. ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ</target>
        </trans-unit>
        <trans-unit id="fedca4eaf22650d4f30ff44ea5ea07caadc39831" translate="yes" xml:space="preserve">
          <source>Please report any bugs or feature requests to &lt;code&gt;bug-math-bigrat at rt.cpan.org&lt;/code&gt; , or through the web interface at &lt;a href=&quot;https://rt.cpan.org/Ticket/Create.html?Queue=Math-BigRat&quot;&gt;https://rt.cpan.org/Ticket/Create.html?Queue=Math-BigRat&lt;/a&gt; (requires login). We will be notified, and then you'll automatically be notified of progress on your bug as I make changes.</source>
          <target state="translated">&lt;code&gt;bug-math-bigrat at rt.cpan.org&lt;/code&gt; 또는 &lt;a href=&quot;https://rt.cpan.org/Ticket/Create.html?Queue=Math-BigRat&quot;&gt;https://rt.cpan.org/Ticket/Create.html?Queue=Math-BigRat&lt;/a&gt; 의 웹 인터페이스를 통해 bug-math-bigrat에 버그 또는 기능 요청을 보고 하십시오 (로그인 필요). ). 알림을 받으면 변경 사항에 따라 버그 진행 상황을 자동으로 알립니다.</target>
        </trans-unit>
        <trans-unit id="44b2b1389efa7dcc1194b0bee5209d80e2cd9879" translate="yes" xml:space="preserve">
          <source>Please report any bugs or feature requests to &lt;code&gt;bug-math-bigrat at rt.cpan.org&lt;/code&gt;, or through the web interface at &lt;a href=&quot;https://rt.cpan.org/Ticket/Create.html?Queue=Math-BigRat&quot;&gt;https://rt.cpan.org/Ticket/Create.html?Queue=Math-BigRat&lt;/a&gt; (requires login). We will be notified, and then you'll automatically be notified of progress on your bug as I make changes.</source>
          <target state="translated">&lt;code&gt;bug-math-bigrat at rt.cpan.org&lt;/code&gt; 또는 &lt;a href=&quot;https://rt.cpan.org/Ticket/Create.html?Queue=Math-BigRat&quot;&gt;https://rt.cpan.org/Ticket/Create.html?Queue=Math-BigRat&lt;/a&gt; 의 웹 인터페이스를 통해 버그 또는 기능 요청을 보고 하십시오 (로그인 필요 ). 알림을받은 다음 변경하는 동안 버그에 대한 진행 상황을 자동으로 알림을 받게 될 것입니다. ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ</target>
        </trans-unit>
        <trans-unit id="9e63d77d099b0075753f056790cc8a0a16061cd4" translate="yes" xml:space="preserve">
          <source>Please report any bugs or feature requests to &lt;code&gt;bug-sys-syslog (at) rt.cpan.org&lt;/code&gt;, or through the web interface at &lt;a href=&quot;http://rt.cpan.org/Public/Dist/Display.html?Name=Sys-Syslog&quot;&gt;http://rt.cpan.org/Public/Dist/Display.html?Name=Sys-Syslog&lt;/a&gt;. I will be notified, and then you'll automatically be notified of progress on your bug as I make changes.</source>
          <target state="translated">&lt;code&gt;bug-sys-syslog (at) rt.cpan.org&lt;/code&gt; 또는 &lt;a href=&quot;http://rt.cpan.org/Public/Dist/Display.html?Name=Sys-Syslog&quot;&gt;http://rt.cpan.org/Public/Dist/Display.html?Name=Sys-&lt;/a&gt; 의 웹 인터페이스를 통해 버그 또는 기능 요청을 bug-sys-syslog (at) rt에보고하십시오 . 시스템 로그 . 알림을 받으면 변경 사항에 따라 버그 진행 상황을 자동으로 알립니다.</target>
        </trans-unit>
        <trans-unit id="ae680a8d27e7e30eaabedd56fcc07aec11c11d49" translate="yes" xml:space="preserve">
          <source>Please report any bugs or feature requests to &lt;code&gt;bug-test-harness at rt.cpan.org&lt;/code&gt; , or through the web interface at &lt;a href=&quot;http://rt.cpan.org/NoAuth/ReportBug.html?Queue=Test-Harness&quot;&gt;http://rt.cpan.org/NoAuth/ReportBug.html?Queue=Test-Harness&lt;/a&gt;. I will be notified, and then you'll automatically be notified of progress on your bug as I make changes.</source>
          <target state="translated">&lt;code&gt;bug-test-harness at rt.cpan.org&lt;/code&gt; 또는 &lt;a href=&quot;http://rt.cpan.org/NoAuth/ReportBug.html?Queue=Test-Harness&quot;&gt;http://rt.cpan.org/NoAuth/ReportBug.html?Queue=Test-Harness&lt;/a&gt; 의 웹 인터페이스를 통해 버그 또는 기능 요청을 bug-test-harness에보고 하십시오 . 알림을 받으면 변경 사항에 따라 버그 진행 상황을 자동으로 알립니다.</target>
        </trans-unit>
        <trans-unit id="341b6e60f3036ad2f760be88739c597fd2cbae0b" translate="yes" xml:space="preserve">
          <source>Please report any bugs or feature requests to &lt;code&gt;bug-test-harness at rt.cpan.org&lt;/code&gt;, or through the web interface at &lt;a href=&quot;http://rt.cpan.org/NoAuth/ReportBug.html?Queue=Test-Harness&quot;&gt;http://rt.cpan.org/NoAuth/ReportBug.html?Queue=Test-Harness&lt;/a&gt;. I will be notified, and then you'll automatically be notified of progress on your bug as I make changes.</source>
          <target state="translated">버그 또는 기능 요청 &lt;code&gt;bug-test-harness at rt.cpan.org&lt;/code&gt; 또는 &lt;a href=&quot;http://rt.cpan.org/NoAuth/ReportBug.html?Queue=Test-Harness&quot;&gt;http://rt.cpan.org/NoAuth/ReportBug.html?Queue=Test-Harness&lt;/a&gt; 의 웹 인터페이스를 통해보고하십시오 . 알림을 받고 변경하면 버그에 대한 진행 상황을 자동으로 알려드립니다.</target>
        </trans-unit>
        <trans-unit id="667d7074054f4f754df9eeb8e155a22d30cbaad3" translate="yes" xml:space="preserve">
          <source>Please report any bugs or feature requests to &lt;code&gt;bug-test-harness@rt.cpan.org&lt;/code&gt; , or through the web interface at &lt;a href=&quot;http://rt.cpan.org/NoAuth/ReportBug.html?Queue=Test-Harness&quot;&gt;http://rt.cpan.org/NoAuth/ReportBug.html?Queue=Test-Harness&lt;/a&gt;. We will be notified, and then you'll automatically be notified of progress on your bug as we make changes.</source>
          <target state="translated">버그 나 기능 요청은 &lt;code&gt;bug-test-harness@rt.cpan.org&lt;/code&gt; 또는 웹 인터페이스 ( &lt;a href=&quot;http://rt.cpan.org/NoAuth/ReportBug.html?Queue=Test-Harness&quot;&gt;http://rt.cpan.org/NoAuth/ReportBug.html?Queue=Test-Harness)를&lt;/a&gt; 통해보고하십시오 . 알림을 받으면 변경 사항에 따라 버그 진행 상황을 자동으로 알립니다.</target>
        </trans-unit>
        <trans-unit id="f074316234c4859a301df22686a28d5f2ff92bd3" translate="yes" xml:space="preserve">
          <source>Please report any bugs or feature requests to &lt;code&gt;bug-test-harness@rt.cpan.org&lt;/code&gt;, or through the web interface at &lt;a href=&quot;http://rt.cpan.org/NoAuth/ReportBug.html?Queue=Test-Harness&quot;&gt;http://rt.cpan.org/NoAuth/ReportBug.html?Queue=Test-Harness&lt;/a&gt;. We will be notified, and then you'll automatically be notified of progress on your bug as we make changes.</source>
          <target state="translated">버그 또는 기능 요청은 &lt;code&gt;bug-test-harness@rt.cpan.org&lt;/code&gt; 또는 &lt;a href=&quot;http://rt.cpan.org/NoAuth/ReportBug.html?Queue=Test-Harness&quot;&gt;http://rt.cpan.org/NoAuth/ReportBug.html?Queue=Test-Harness&lt;/a&gt; 의 웹 인터페이스를 통해보고하십시오 . 알림을받은 다음 변경하는 동안 버그에 대한 진행 상황을 자동으로 알려드립니다.</target>
        </trans-unit>
        <trans-unit id="9c61f91a0c5559a90a0233170a166239a41b69c9" translate="yes" xml:space="preserve">
          <source>Please report any bugs or feature requests via the perlbug(1) utility.</source>
          <target state="translated">perlbug (1) 유틸리티를 통해 버그 나 기능 요청을보고하십시오.</target>
        </trans-unit>
        <trans-unit id="da1690d7c5d6c84d4dfa27a5c4d0acb738c84780" translate="yes" xml:space="preserve">
          <source>Please report any bugs or feature using the CPAN Request Tracker. Bugs can be submitted through the web interface at &lt;a href=&quot;http://rt.cpan.org/Dist/Display.html?Queue=CPAN-Meta&quot;&gt;http://rt.cpan.org/Dist/Display.html?Queue=CPAN-Meta&lt;/a&gt;</source>
          <target state="translated">CPAN 요청 추적기를 사용하여 버그 나 기능을보고하십시오. &lt;a href=&quot;http://rt.cpan.org/Dist/Display.html?Queue=CPAN-Meta&quot;&gt;http://rt.cpan.org/Dist/Display.html?Queue=CPAN-Meta&lt;/a&gt; 의 웹 인터페이스를 통해 버그를 제출할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="538631f2230a63e6ce1111d15fa806e9dbfb590c" translate="yes" xml:space="preserve">
          <source>Please report any errors, updates, or suggestions to</source>
          <target state="translated">오류, 업데이트 또는 제안 사항이 있으면</target>
        </trans-unit>
        <trans-unit id="b2fed3d97135253678acd7ef66f99b903e366619" translate="yes" xml:space="preserve">
          <source>Please report any errors, updates, or suggestions to &lt;a href=&quot;https://github.com/Perl/perl5/issues&quot;&gt;https://github.com/Perl/perl5/issues&lt;/a&gt;.</source>
          <target state="translated">오류, 업데이트 또는 제안 사항이 있으면 &lt;a href=&quot;https://github.com/Perl/perl5/issues&quot;&gt;https://github.com/Perl/perl5/issues에보고하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7fdf7d53b3d96ceb75d6b632d2b4d517d6b8a6a5" translate="yes" xml:space="preserve">
          <source>Please report any other failures as described under &lt;a href=&quot;#BUGS-AND-CAVEATS&quot;&gt;&quot;BUGS AND CAVEATS&quot;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#BUGS-AND-CAVEATS&quot;&gt;&quot;버그 및주의 사항&quot;에&lt;/a&gt; 설명 된대로 기타 실패를보고하십시오 .</target>
        </trans-unit>
        <trans-unit id="535c1e5f2236649cfc5cd24875aa7a7f5d8bb2dc" translate="yes" xml:space="preserve">
          <source>Please report any other failures as described under &lt;a href=&quot;#BUGS-AND-CAVEATS&quot;&gt;BUGS AND CAVEATS&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#BUGS-AND-CAVEATS&quot;&gt;버그 및주의 사항에&lt;/a&gt; 설명 된대로 다른 오류를보고하십시오 .</target>
        </trans-unit>
        <trans-unit id="5ecba84d92ce32aa62a862b9a6870d59796672d9" translate="yes" xml:space="preserve">
          <source>Please report bugs in this version of perl to andy@broad.ology.org.uk in the first instance.</source>
          <target state="translated">이 버전의 펄에있는 버그를 먼저 andy@broad.ology.org.uk에보고하십시오.</target>
        </trans-unit>
        <trans-unit id="588e8512c3a527a86acc4f15dfb514051940faad" translate="yes" xml:space="preserve">
          <source>Please report bugs on a specific behavior of this module to RT or GitHub issues (preferred):</source>
          <target state="translated">이 모듈의 특정 동작에 대한 버그를 RT 또는 GitHub 문제에보고하십시오 (권장) :</target>
        </trans-unit>
        <trans-unit id="76aa5507d30b205fb08850d3924328ca2edc4fec" translate="yes" xml:space="preserve">
          <source>Please report bugs or other issues to &amp;lt;bug-file-fetch@rt.cpan.org&amp;lt;gt&amp;gt;.</source>
          <target state="translated">버그 또는 기타 문제는 &amp;lt;bug-file-fetch@rt.cpan.org &amp;lt;gt&amp;gt;로 신고하십시오.</target>
        </trans-unit>
        <trans-unit id="5af156ec0cb2830a387a464db78f0177138c46c7" translate="yes" xml:space="preserve">
          <source>Please report bugs or other issues to &amp;lt;bug-ipc-cmd@rt.cpan.org&amp;gt;.</source>
          <target state="translated">버그 또는 기타 문제는 &amp;lt;bug-ipc-cmd@rt.cpan.org&amp;gt;로보고하십시오.</target>
        </trans-unit>
        <trans-unit id="89fa61346f2ac4a97f3b1820d45a05f5cf6df3b4" translate="yes" xml:space="preserve">
          <source>Please report bugs or other issues to &amp;lt;bug-module-load-conditional@rt.cpan.org&amp;gt;.</source>
          <target state="translated">버그 또는 기타 문제는 &amp;lt;bug-module-load-conditional@rt.cpan.org&amp;gt;로보고하십시오.</target>
        </trans-unit>
        <trans-unit id="74e57493a005451600337c2cd20b19335784389b" translate="yes" xml:space="preserve">
          <source>Please report bugs or other issues to &amp;lt;bug-module-load@rt.cpan.org&amp;lt;gt&amp;gt;.</source>
          <target state="translated">버그 또는 기타 문제는 &amp;lt;bug-module-load@rt.cpan.org &amp;lt;gt&amp;gt;로 신고하십시오.</target>
        </trans-unit>
        <trans-unit id="aa48dcb88c79a4bb30f628a4e59b5790599238be" translate="yes" xml:space="preserve">
          <source>Please report bugs or other issues to &amp;lt;bug-module-loaded@rt.cpan.org&amp;lt;gt&amp;gt;.</source>
          <target state="translated">버그 또는 기타 문제는 &amp;lt;bug-module-loaded@rt.cpan.org &amp;lt;gt&amp;gt;로 신고하십시오.</target>
        </trans-unit>
        <trans-unit id="ea6595769a4f7e77e760cd27c4315806767a46e6" translate="yes" xml:space="preserve">
          <source>Please report bugs or other issues to &amp;lt;bug-params-check@rt.cpan.org&amp;gt;.</source>
          <target state="translated">버그 또는 기타 문제는 &amp;lt;bug-params-check@rt.cpan.org&amp;gt;로보고하십시오.</target>
        </trans-unit>
        <trans-unit id="e2b012cfb62b0833f158983eb6a125eb9f62cad3" translate="yes" xml:space="preserve">
          <source>Please report bugs using &lt;a href=&quot;http://rt.cpan.org&quot;&gt;http://rt.cpan.org&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://rt.cpan.org&quot;&gt;http://rt.cpan.org를&lt;/a&gt; 사용하여 버그를보고하십시오 .</target>
        </trans-unit>
        <trans-unit id="9b0a18ec15ee7f8f9cfa33de7bf50e0926919e26" translate="yes" xml:space="preserve">
          <source>Please report bugs via &lt;a href=&quot;http://rt.cpan.org/&quot;&gt;http://rt.cpan.org/&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;http://rt.cpan.org/&quot;&gt;http://rt.cpan.org/&lt;/a&gt; 를 통해 버그를보고하십시오</target>
        </trans-unit>
        <trans-unit id="e4417cf7026fd3b1d558ce74b166a72450fc9e3b" translate="yes" xml:space="preserve">
          <source>Please report bugs via the GitHub Issue Tracker at &lt;a href=&quot;https://github.com/pjf/autodie/issues&quot;&gt;https://github.com/pjf/autodie/issues&lt;/a&gt; or via the CPAN Request Tracker at &lt;a href=&quot;https://rt.cpan.org/NoAuth/Bugs.html?Dist=autodie&quot;&gt;https://rt.cpan.org/NoAuth/Bugs.html?Dist=autodie&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/pjf/autodie/issues&quot;&gt;https://github.com/pjf/autodie/issues&lt;/a&gt; 의 GitHub 이슈 트래커 또는 https://rt.cpan.org/NoAuth/Bugs.html?Dist=autodie 의 CPAN 요청 트래커를 통해 버그를보고 &lt;a href=&quot;https://rt.cpan.org/NoAuth/Bugs.html?Dist=autodie&quot;&gt;하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8aab4e1e45b67fc9f30850be9456ba3f03a04a5a" translate="yes" xml:space="preserve">
          <source>Please report detailed descriptions of any problems and solutions that you may find at &amp;lt;&lt;a href=&quot;https://github.com/Perl/perl5/issues&quot;&gt;https://github.com/Perl/perl5/issues&lt;/a&gt;&amp;gt;, along with the output produced by &lt;code&gt;perl -V&lt;/code&gt;.</source>
          <target state="translated">&amp;lt; &lt;a href=&quot;https://github.com/Perl/perl5/issues&quot;&gt;https://github.com/Perl/perl5/issues&lt;/a&gt; &amp;gt; 에서 찾을 수있는 문제 및 솔루션에 대한 자세한 설명과 &lt;code&gt;perl -V&lt;/code&gt; 에서 생성 된 출력을보고하십시오 .</target>
        </trans-unit>
        <trans-unit id="d79a854cdb114b54082c119689356c304d2fefdd" translate="yes" xml:space="preserve">
          <source>Please reports bugs to &amp;lt;bug-archive-tar@rt.cpan.org&amp;gt;.</source>
          <target state="translated">&amp;lt;bug-archive-tar@rt.cpan.org&amp;gt;에 버그를보고하십시오.</target>
        </trans-unit>
        <trans-unit id="d4341b4d3e627a1778c8a45b586f98e9adc4ce3b" translate="yes" xml:space="preserve">
          <source>Please see &lt;a href=&quot;#parseopts()&quot;&gt;parseopts()&lt;/a&gt; for a complete description of the interface for the setting and unsetting of parse-options.</source>
          <target state="translated">구문 분석 옵션 설정 및 설정 해제에 대한 인터페이스에 대한 자세한 설명 은 &lt;a href=&quot;#parseopts()&quot;&gt;parseopts ()&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e7f51c19c32ff7fa52bd5ea5cccc3312c8f093f3" translate="yes" xml:space="preserve">
          <source>Please see &lt;a href=&quot;../parser#SUBCLASSING&quot;&gt;SUBCLASSING in TAP::Parser&lt;/a&gt; for a subclassing overview.</source>
          <target state="translated">서브 클래 싱 개요 &lt;a href=&quot;../parser#SUBCLASSING&quot;&gt;는 TAP :: Parser&lt;/a&gt; 의 서브 클래 싱을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c86f144c936b547d1a8fcab0618c4dcef4646042" translate="yes" xml:space="preserve">
          <source>Please see &lt;a href=&quot;App::Prove#PLUGINS&quot;&gt;&quot;PLUGINS&quot; in App::Prove&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;App::Prove#PLUGINS&quot;&gt;App :: Prove의 &quot;PLUGINS&quot;를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="4e91d7e19846bba266909a5e73288f2011d3c67a" translate="yes" xml:space="preserve">
          <source>Please see &lt;a href=&quot;TAP::Parser#SUBCLASSING&quot;&gt;&quot;SUBCLASSING&quot; in TAP::Parser&lt;/a&gt; for a subclassing overview, and any of the subclasses that ship with this module as an example. What follows is a quick overview.</source>
          <target state="translated">서브 클래 싱 개요 및이 모듈과 함께 제공되는 모든 서브 클래스에 대한 예 &lt;a href=&quot;TAP::Parser#SUBCLASSING&quot;&gt;는 TAP :: Parser의 &quot;SUBCLASSING&quot;을&lt;/a&gt; 참조하십시오 . 다음은 간략한 개요입니다.</target>
        </trans-unit>
        <trans-unit id="26bbee5cc38dd221caeb15c8d0b9944048cfb0e3" translate="yes" xml:space="preserve">
          <source>Please see &lt;a href=&quot;TAP::Parser#SUBCLASSING&quot;&gt;&quot;SUBCLASSING&quot; in TAP::Parser&lt;/a&gt; for a subclassing overview.</source>
          <target state="translated">서브 클래 싱 개요 &lt;a href=&quot;TAP::Parser#SUBCLASSING&quot;&gt;는 TAP :: Parser의 &quot;SUBCLASSING&quot;을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c6c46841005cacd4d19b8897f62c9bcdf00ba021" translate="yes" xml:space="preserve">
          <source>Please see &lt;a href=&quot;Test2::API::Context#CRITICAL-DETAILS&quot;&gt;&quot;CRITICAL DETAILS&quot; in Test2::API::Context&lt;/a&gt; for important rules about what you can and cannot do with a context once it is obtained.</source>
          <target state="translated">&lt;a href=&quot;Test2::API::Context#CRITICAL-DETAILS&quot;&gt;컨텍스트&lt;/a&gt; 를 획득 한 후 수행 할 수있는 작업과 수행 할 수없는 작업에 대한 중요한 규칙은 Test2 :: API :: Context의 &quot;중요한 세부 사항&quot;을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="5b0d65ae346953461c6709072b8e34d6894faf9a" translate="yes" xml:space="preserve">
          <source>Please see &lt;a href=&quot;Test::use::ok&quot;&gt;Test::use::ok&lt;/a&gt; for the full description.</source>
          <target state="translated">전체 설명 은 &lt;a href=&quot;Test::use::ok&quot;&gt;Test :: use :: ok&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d2e0a1481bb7e7875074f0faee7691f33bd29319" translate="yes" xml:space="preserve">
          <source>Please see &lt;a href=&quot;app/prove#PLUGINS&quot;&gt;PLUGINS in App::Prove&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;app/prove#PLUGINS&quot;&gt;App :: Prove의 PLUGINS를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="989a39f3d25282b53431795da6fd8624c0e76184" translate="yes" xml:space="preserve">
          <source>Please see respective module documentation for further details.</source>
          <target state="translated">자세한 내용은 해당 모듈 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="a30c68c43e99e52ddbaa4a59fdceb1dd51800da4" translate="yes" xml:space="preserve">
          <source>Please see the &quot;See Also&quot; references for a thorough explanation of how to correctly use language tags.</source>
          <target state="translated">언어 태그를 올바르게 사용하는 방법에 대한 자세한 설명은 &quot;참조&quot;참조를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="5eb0ce8841e107e9f0e205e51d26edff17acc24e" translate="yes" xml:space="preserve">
          <source>Please see the &lt;a href=&quot;ExtUtils::Mksymlists&quot;&gt;ExtUtils::Mksymlists&lt;/a&gt; documentation for more information about the DL_FUNCS, DL_VARS and FUNCLIST attributes.</source>
          <target state="translated">DL_FUNCS, DL_VARS 및 FUNCLIST 속성에 대한 자세한 정보 는 &lt;a href=&quot;ExtUtils::Mksymlists&quot;&gt;ExtUtils :: Mksymlists&lt;/a&gt; 문서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="81fd05bcd06561fbf4acc7c17c9823d8c0d4b322" translate="yes" xml:space="preserve">
          <source>Please see the &lt;a href=&quot;mksymlists&quot;&gt;ExtUtils::Mksymlists&lt;/a&gt; documentation for more information about the DL_FUNCS, DL_VARS and FUNCLIST attributes.</source>
          <target state="translated">참조하십시오 &lt;a href=&quot;mksymlists&quot;&gt;위한 ExtUtils을 :: Mksymlists&lt;/a&gt; 문서를 DL_FUNCS, DL_VARS 및 FUNCLIST 속성에 대한 자세한 내용은.</target>
        </trans-unit>
        <trans-unit id="2c2e515c2102fd49c64f216a02d32d621813ef11" translate="yes" xml:space="preserve">
          <source>Please see the README file in distribution.</source>
          <target state="translated">배포판의 README 파일을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="628ecfdf942d40232f5db37e81fc0010f48d3a4b" translate="yes" xml:space="preserve">
          <source>Please see the documentation for &lt;code&gt;ExtUtils::Mksymlists&lt;/code&gt; for the details of what these parameters do.</source>
          <target state="translated">이러한 매개 변수의 &lt;code&gt;ExtUtils::Mksymlists&lt;/code&gt; 에 대한 자세한 내용은 ExtUtils :: Mksymlists 설명서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f40ec33c90f01c635cb2192f1f99978f9b263bcc" translate="yes" xml:space="preserve">
          <source>Please see the documentation in &lt;a href=&quot;Math::BigInt&quot;&gt;Math::BigInt&lt;/a&gt; for further details.</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;Math::BigInt&quot;&gt;Math :: BigInt&lt;/a&gt; 의 설명서를 참조 하십시오.</target>
        </trans-unit>
        <trans-unit id="5a5dc2d5751ee8cce246c66908a7b4ec4c62daf7" translate="yes" xml:space="preserve">
          <source>Please see the documentation in &lt;a href=&quot;bigint&quot;&gt;Math::BigInt&lt;/a&gt; for further details.</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;bigint&quot;&gt;Math :: BigInt&lt;/a&gt; 의 설명서를 참조 하십시오.</target>
        </trans-unit>
        <trans-unit id="05004fbce196a7e0bf2a95059afe8e5ce82a91f3" translate="yes" xml:space="preserve">
          <source>Please see the documentation in &lt;a href=&quot;bigint&quot;&gt;Math::BigInt&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;bigint&quot;&gt;Math :: BigInt&lt;/a&gt; 의 문서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e4b33a5a89e332b7c7e9bac36dcb4a5524d98fc6" translate="yes" xml:space="preserve">
          <source>Please see the file README in the Perl source distribution for details of the Perl license.</source>
          <target state="translated">Perl 라이센스에 대한 자세한 내용은 Perl 소스 배포의 README 파일을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="e0151ca432ab861ca7ca145a28b62d6ba2feb6f2" translate="yes" xml:space="preserve">
          <source>Please see the git repository for revision history.</source>
          <target state="translated">개정 내역은 git 저장소를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="8996e7dee5730a1986500bc16557a0d869c75480" translate="yes" xml:space="preserve">
          <source>Please see the section about &lt;a href=&quot;#ACCURACY-and-PRECISION&quot;&gt;&quot;ACCURACY and PRECISION&quot;&lt;/a&gt; for further details.</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;#ACCURACY-and-PRECISION&quot;&gt;&quot;정확성 및 정밀도&quot;&lt;/a&gt; 섹션을 참조 하십시오.</target>
        </trans-unit>
        <trans-unit id="3073b87722e3ef7fb20a17229c346b64eb30ea5d" translate="yes" xml:space="preserve">
          <source>Please see the section about &lt;a href=&quot;#ACCURACY-and-PRECISION&quot;&gt;ACCURACY and PRECISION&lt;/a&gt; for further details.</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;#ACCURACY-and-PRECISION&quot;&gt;정확성 및 정밀성&lt;/a&gt; 섹션을 참조 하십시오.</target>
        </trans-unit>
        <trans-unit id="221b6d6c2e3933bcc937bf432e64ccb1ebb6a488" translate="yes" xml:space="preserve">
          <source>Please send detailed descriptions of any problems and solutions that you may find to &amp;lt;</source>
          <target state="translated">문제 및 해결책에 대한 자세한 설명을 보내 주시기 바랍니다 &amp;lt;</target>
        </trans-unit>
        <trans-unit id="ef68d6f3b0d5f9f183ddfa8c1c49597c47fc04d3" translate="yes" xml:space="preserve">
          <source>Please set your policy to one of the three values.</source>
          <target state="translated">정책을 세 가지 값 중 하나로 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="e5456a0ea6c8660091c6463eca153f6f42857178" translate="yes" xml:space="preserve">
          <source>Please submit bug reports and patches to perlbug@perl.org.</source>
          <target state="translated">perlbug@perl.org에 버그 보고서 및 패치를 제출하십시오.</target>
        </trans-unit>
        <trans-unit id="1670aa48b29f76eeff5e31510ce8161f83f94922" translate="yes" xml:space="preserve">
          <source>Please submit bugs to the CPAN RT system at &lt;a href=&quot;http://rt.cpan.org/NoAuth/ReportBug.html?Queue=Time-Local&quot;&gt;http://rt.cpan.org/NoAuth/ReportBug.html?Queue=Time-Local&lt;/a&gt; or via email at bug-time-local@rt.cpan.org.</source>
          <target state="translated">&lt;a href=&quot;http://rt.cpan.org/NoAuth/ReportBug.html?Queue=Time-Local&quot;&gt;http://rt.cpan.org/NoAuth/ReportBug.html?Queue=Time-Local&lt;/a&gt; 또는 이메일 (bug-time-local@rt.cpan.org)을 통해 CPAN RT 시스템에 버그를 제출하십시오 .</target>
        </trans-unit>
        <trans-unit id="027daf21662ca08eda2a7bd48d5158b216706744" translate="yes" xml:space="preserve">
          <source>Please try and supply some documentation if you add functions to the Perl core.</source>
          <target state="translated">Perl 코어에 기능을 추가 할 경우 몇 가지 문서를 제공하십시오.</target>
        </trans-unit>
        <trans-unit id="f0a1af1032147376b66464947571d72cef968e98" translate="yes" xml:space="preserve">
          <source>Please use &lt;a href=&quot;https://github.com/perl-pod/pod-simple/issues/new&quot;&gt;https://github.com/perl-pod/pod-simple/issues/new&lt;/a&gt; to file a bug report.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/perl-pod/pod-simple/issues/new&quot;&gt;https://github.com/perl-pod/pod-simple/issues/new&lt;/a&gt; 를 사용 하여 버그 보고서를 제출하세요.</target>
        </trans-unit>
        <trans-unit id="f714e6d31a681125e28768dfea867640b126ff8d" translate="yes" xml:space="preserve">
          <source>Please, unless you're hacking the internals, or debugging weirdness, don't think about the UTF8 flag at all. That means that you very probably shouldn't use &lt;code&gt;is_utf8&lt;/code&gt; , &lt;code&gt;_utf8_on&lt;/code&gt; or &lt;code&gt;_utf8_off&lt;/code&gt; at all.</source>
          <target state="translated">내부를 해킹하거나 이상한 점을 디버깅하지 않는 한 UTF8 플래그를 전혀 생각하지 마십시오. 즉 , 아마도 &lt;code&gt;is_utf8&lt;/code&gt; , &lt;code&gt;_utf8_on&lt;/code&gt; 또는 &lt;code&gt;_utf8_off&lt;/code&gt; 를 전혀 사용해서는 안됩니다 .</target>
        </trans-unit>
        <trans-unit id="1202c034ad5e532f9a82495be81ce4863a3e9945" translate="yes" xml:space="preserve">
          <source>Please, unless you're hacking the internals, or debugging weirdness, don't think about the UTF8 flag at all. That means that you very probably shouldn't use &lt;code&gt;is_utf8&lt;/code&gt;, &lt;code&gt;_utf8_on&lt;/code&gt; or &lt;code&gt;_utf8_off&lt;/code&gt; at all.</source>
          <target state="translated">내부를 해킹하거나 이상한 점을 디버깅하지 않는 한 UTF8 플래그에 대해 전혀 생각하지 마십시오. 당신은 매우 아마 사용해서는 안 것을 의미 &lt;code&gt;is_utf8&lt;/code&gt; , &lt;code&gt;_utf8_on&lt;/code&gt; 또는 &lt;code&gt;_utf8_off&lt;/code&gt; 을 전혀.</target>
        </trans-unit>
        <trans-unit id="34f29d232cd4bc7b00f36ebc0732290db154e722" translate="yes" xml:space="preserve">
          <source>Plug-in module for automatic expiration of memoized values</source>
          <target state="translated">메모 된 값의 자동 만료를위한 플러그인 모듈</target>
        </trans-unit>
        <trans-unit id="9edf1040d2bfeaaf802cb8b27a5c7e4a201ff06a" translate="yes" xml:space="preserve">
          <source>Pluggable runops</source>
          <target state="translated">플러그 형 런</target>
        </trans-unit>
        <trans-unit id="5697803d10d7bf281aadc37a72c18ea36adecd64" translate="yes" xml:space="preserve">
          <source>Plugin support ***EXPERIMENTAL***</source>
          <target state="translated">플러그인 지원 *** EXPERIMENTAL ***</target>
        </trans-unit>
        <trans-unit id="ab2e26dd8b8868a3969cb3321e0c983c0d9d67d4" translate="yes" xml:space="preserve">
          <source>Plugins</source>
          <target state="translated">Plugins</target>
        </trans-unit>
        <trans-unit id="76ccce846df3b4c3ab1a6f65fc358f4fc11db43e" translate="yes" xml:space="preserve">
          <source>Plugins are objects that implement any of currently eight methods:</source>
          <target state="translated">플러그인은 현재 8 가지 방법 중 하나를 구현하는 객체입니다.</target>
        </trans-unit>
        <trans-unit id="1de58880797e013d954730b62488aa821afcb4c8" translate="yes" xml:space="preserve">
          <source>Plugins can be loaded using the &lt;code&gt;-P&lt;i&gt;plugin&lt;/i&gt;&lt;/code&gt; syntax, eg:</source>
          <target state="translated">플러그인은 &lt;code&gt;-P&lt;i&gt;plugin&lt;/i&gt;&lt;/code&gt; 구문을 사용하여로드 할 수 있습니다 . 예 :</target>
        </trans-unit>
        <trans-unit id="71494d8d1e8a55e1a56d948d21ff0111c0e58ab0" translate="yes" xml:space="preserve">
          <source>Pod Commands</source>
          <target state="translated">포드 명령</target>
        </trans-unit>
        <trans-unit id="3d5386faff713ed9d1073c9258ceccd049f3d049" translate="yes" xml:space="preserve">
          <source>Pod Definitions</source>
          <target state="translated">포드 정의</target>
        </trans-unit>
        <trans-unit id="4ae454b70ee2c5e321bfbc301f9d36222768b986" translate="yes" xml:space="preserve">
          <source>Pod Formatting Codes</source>
          <target state="translated">포드 포맷 코드</target>
        </trans-unit>
        <trans-unit id="47918185382f833db1e30bfcfbc001132c7cba90" translate="yes" xml:space="preserve">
          <source>Pod content is contained in &lt;b&gt;Pod blocks&lt;/b&gt;. A Pod block starts with a line that matches &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m/\A=[a-zA-Z]/&lt;/a&gt;&lt;/code&gt;, and continues up to the next line that matches &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m/\A=cut/&lt;/a&gt;&lt;/code&gt; or up to the end of the file if there is no &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m/\A=cut/&lt;/a&gt;&lt;/code&gt; line.</source>
          <target state="translated">포드 컨텐츠는 &lt;b&gt;포드 블록에&lt;/b&gt; 포함됩니다 . Pod 블록은 &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m/\A=[a-zA-Z]/&lt;/a&gt;&lt;/code&gt; 와 일치하는 줄로 시작하고 &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m/\A=cut/&lt;/a&gt;&lt;/code&gt; 와 일치하는 다음 줄 까지 또는 파일의 끝까지 계속됩니다 아니오 &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m/\A=cut/&lt;/a&gt;&lt;/code&gt; 라인.</target>
        </trans-unit>
        <trans-unit id="02c2e8126c233f706e9cd59a2533c9f50c98bc10" translate="yes" xml:space="preserve">
          <source>Pod content is contained in &lt;b&gt;Pod blocks&lt;/b&gt;. A Pod block starts with a line that matches &lt;code&gt;m/\A=[a-zA-Z]/&lt;/code&gt;, and continues up to the next line that matches &lt;code&gt;m/\A=cut/&lt;/code&gt; or up to the end of the file if there is no &lt;code&gt;m/\A=cut/&lt;/code&gt; line.</source>
          <target state="translated">포드 콘텐츠는 &lt;b&gt;포드 블록에&lt;/b&gt; 포함됩니다 . Pod 블록은 &lt;code&gt;m/\A=[a-zA-Z]/&lt;/code&gt; 와 일치하는 행으로 시작하고 &lt;code&gt;m/\A=cut/&lt;/code&gt; 와 일치하는 다음 행까지 계속 되거나 파일이있는 경우 파일 끝까지 계속됩니다. 아니오 &lt;code&gt;m/\A=cut/&lt;/code&gt; 라인.</target>
        </trans-unit>
        <trans-unit id="d6ddb3d03f7f589056100b138c86215515b2e453" translate="yes" xml:space="preserve">
          <source>Pod formatters</source>
          <target state="translated">포드 포맷터</target>
        </trans-unit>
        <trans-unit id="d66a0d27d4c73edcb27d25e097424b0951626f0c" translate="yes" xml:space="preserve">
          <source>Pod formatters can use Pod::Simple to parse Pod documents and render them into plain text, HTML, or any number of other formats. Typically, such formatters will be subclasses of Pod::Simple, and so they will inherit its methods, like &lt;code&gt;parse_file&lt;/code&gt; .</source>
          <target state="translated">포드 포맷터는 Pod :: Simple을 사용하여 포드 문서를 구문 분석하고 일반 텍스트, HTML 또는 기타 여러 형식으로 렌더링 할 수 있습니다. 일반적으로 이러한 포맷터는 Pod :: Simple의 서브 클래스가되므로 &lt;code&gt;parse_file&lt;/code&gt; 과 같은 메소드를 상속합니다 .</target>
        </trans-unit>
        <trans-unit id="746daa555fbd186d7d4c6882e67f7c32f9c561ea" translate="yes" xml:space="preserve">
          <source>Pod formatters can use Pod::Simple to parse Pod documents and render them into plain text, HTML, or any number of other formats. Typically, such formatters will be subclasses of Pod::Simple, and so they will inherit its methods, like &lt;code&gt;parse_file&lt;/code&gt;. But note that Pod::Simple doesn't understand and properly parse Perl itself, so if you have a file which contains a Perl program that has a multi-line quoted string which has lines that look like pod, Pod::Simple will treat them as pod. This can be avoided if the file makes these into indented here documents instead.</source>
          <target state="translated">Pod 포맷터는 Pod :: Simple을 사용하여 Pod 문서를 파싱하고 일반 텍스트, HTML 또는 기타 여러 형식으로 렌더링 할 수 있습니다. 일반적으로 이러한 포맷터는 Pod :: Simple의 하위 클래스이므로 &lt;code&gt;parse_file&lt;/code&gt; 과 같은 메서드를 상속합니다 . 그러나 Pod :: Simple은 Perl 자체를 이해하고 제대로 구문 분석하지 못하므로 pod처럼 보이는 줄이있는 여러 줄 따옴표로 묶인 문자열이있는 Perl 프로그램이 포함 된 파일이있는 경우 Pod :: Simple이 처리합니다. 포드로. 파일이 대신 여기에 들여 쓰기 된 문서로 만들면이 문제를 피할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="44803dfacbed653092718af27817d667ae913774" translate="yes" xml:space="preserve">
          <source>Pod formatters should make reasonable efforts to keep words of Perl code from being broken across lines. For example, &quot;Foo::Bar&quot; in some formatting systems is seen as eligible for being broken across lines as &quot;Foo::&quot; newline &quot;Bar&quot; or even &quot;Foo::-&quot; newline &quot;Bar&quot;. This should be avoided where possible, either by disabling all line-breaking in mid-word, or by wrapping particular words with internal punctuation in &quot;don't break this across lines&quot; codes (which in some formats may not be a single code, but might be a matter of inserting non-breaking zero-width spaces between every pair of characters in a word.)</source>
          <target state="translated">포드 포맷터는 Perl 코드의 단어가 여러 줄로 나뉘 지 않도록 합리적인 노력을 기울여야합니다. 예를 들어, 일부 형식 지정 시스템에서 &quot;Foo :: Bar&quot;는 &quot;Foo ::&quot;줄 바꿈 &quot;Bar&quot;또는 &quot;Foo ::-&quot;줄 바꿈 &quot;Bar&quot;와 같이 여러 줄로 나눌 수 있습니다. 가능한 경우 중간 단어에서 모든 줄 바꿈을 비활성화하거나 &quot;줄을 가로 질러 나누지 마십시오&quot;코드 (일부 형식에서는 단일 코드가 아닐 수 있음)에서 내부 구두점으로 특정 단어를 줄임으로써 가능하면 피해야합니다. 그러나 단어의 모든 문자 쌍 사이에 끊김없는 0 너비 공백을 삽입해야 할 수도 있습니다.)</target>
        </trans-unit>
        <trans-unit id="d30f3aa798097994ab967bc039b02fb5704336d9" translate="yes" xml:space="preserve">
          <source>Pod formatters should tolerate lines in verbatim blocks that are of any length, even if that means having to break them (possibly several times, for very long lines) to avoid text running off the side of the page. Pod formatters may warn of such line-breaking. Such warnings are particularly appropriate for lines are over 100 characters long, which are usually not intentional.</source>
          <target state="translated">팟 포맷터는 텍스트가 페이지의 측면에서 벗어나는 것을 피하기 위해 (길이가 긴 경우) 여러 줄을 끊어야하는 경우에도 길이에 상관없이 완전한 블록의 행을 허용해야합니다. 포드 포맷터는 이러한 줄 바꿈을 경고 할 수 있습니다. 이러한 경고는 줄이 100자를 넘을 때 특히 적합하며 일반적으로 의도하지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="9e45409759a4a45d8ec12bca70ef02e438fd2271" translate="yes" xml:space="preserve">
          <source>Pod formatters, where feasible, are advised to avoid splitting short verbatim paragraphs (under twelve lines, say) across pages.</source>
          <target state="translated">가능한 경우, 포드 포맷터는 짧은 문장 단락 (예 : 12 줄 아래)이 페이지에 분할되는 것을 피하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="6b57013c8fdcb737d69c938a9f663099a631cacb" translate="yes" xml:space="preserve">
          <source>Pod is a simple-to-use markup language used for writing documentation for Perl, Perl programs, and Perl modules.</source>
          <target state="translated">Pod는 Perl, Perl 프로그램 및 Perl 모듈에 대한 문서를 작성하는 데 사용되는 사용하기 쉬운 마크 업 언어입니다.</target>
        </trans-unit>
        <trans-unit id="0f6434053591d377adc29bce6462c4e2195b1c17" translate="yes" xml:space="preserve">
          <source>Pod is embedded in files, typically Perl source files, although you can write a file that's nothing but Pod.</source>
          <target state="translated">포드는 파일, 일반적으로 Perl 소스 파일에 포함되어 있지만 포드 이외의 파일은 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a317c10bc80719752bdbc59669224f21caf94cb6" translate="yes" xml:space="preserve">
          <source>Pod markup consists of three basic kinds of paragraphs: &lt;a href=&quot;#Ordinary-Paragraph&quot;&gt;ordinary&lt;/a&gt;, &lt;a href=&quot;#Verbatim-Paragraph&quot;&gt;verbatim&lt;/a&gt;, and &lt;a href=&quot;#Command-Paragraph&quot;&gt;command&lt;/a&gt;.</source>
          <target state="translated">포드 마크 업은 세 가지 기본 단락 유형으로 구성됩니다 : &lt;a href=&quot;#Ordinary-Paragraph&quot;&gt;일반&lt;/a&gt; , &lt;a href=&quot;#Verbatim-Paragraph&quot;&gt;축어&lt;/a&gt; 및 &lt;a href=&quot;#Command-Paragraph&quot;&gt;명령&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3729d4ffa4c690e28dd8755c4c73a027d3ed32e0" translate="yes" xml:space="preserve">
          <source>Pod now defaults to text.</source>
          <target state="translated">이제 포드가 텍스트로 기본 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="e4100fa00f1a6ff1bc2589ecc13660c9f209d6e8" translate="yes" xml:space="preserve">
          <source>Pod parsers</source>
          <target state="translated">포드 파서</target>
        </trans-unit>
        <trans-unit id="826ed58998f5bc33125341c4f36a3a43574102c1" translate="yes" xml:space="preserve">
          <source>Pod parsers may also note additional attributes including:</source>
          <target state="translated">포드 파서는 다음과 같은 추가 속성을 참고할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="78ce92125382b9b17f3f27b241298cd0d948dfa7" translate="yes" xml:space="preserve">
          <source>Pod parsers must also support the XHTML codes &quot;E&amp;lt;quot&amp;gt;&quot; for character 34 (doublequote, &quot;), &quot;E&amp;lt;amp&amp;gt;&quot; for character 38 (ampersand, &amp;amp;), and &quot;E&amp;lt;apos&amp;gt;&quot; for character 39 (apostrophe, ').</source>
          <target state="translated">포드 파서는 또한 문자 34 (큰 따옴표, &quot;)에 대해서는&quot;E &amp;lt;quot&amp;gt; &quot;, 문자 38 (앰퍼샌드, &amp;amp;)에 대해서는&quot;E &amp;lt;amp&amp;gt; &quot;, 문자 39에 대해서는&quot;E &amp;lt;apos&amp;gt; &quot;(아포스트로피)를 지원해야합니다. , ').</target>
        </trans-unit>
        <trans-unit id="d16107ce92c757a467355de94f2c9937bd3ef851" translate="yes" xml:space="preserve">
          <source>Pod parsers must recognize</source>
          <target state="translated">포드 파서는 인식해야합니다</target>
        </trans-unit>
        <trans-unit id="6e60f4cd73d8a373a60400a3a94686dfb7543ae7" translate="yes" xml:space="preserve">
          <source>Pod parsers must treat a line with only spaces and/or tabs on it as a &quot;blank line&quot; such as separates paragraphs. (Some older parsers recognized only two adjacent newlines as a &quot;blank line&quot; but would not recognize a newline, a space, and a newline, as a blank line. This is noncompliant behavior.)</source>
          <target state="translated">포드 파서는 공백 및 / 또는 탭만있는 행을 별도의 단락과 같은 &quot;빈 줄&quot;로 취급해야합니다. 일부 오래된 파서는 인접한 두 줄 바꿈 만 &quot;빈 줄&quot;로 인식하지만 줄 바꿈, 공백 및 줄 바꿈을 빈 줄로 인식하지 않습니다. 이는 비준수 동작입니다.</target>
        </trans-unit>
        <trans-unit id="0c42bd4ec3460b4dc34871ff713c3f41e0e29ace" translate="yes" xml:space="preserve">
          <source>Pod parsers should accept input lines that are of any length.</source>
          <target state="translated">포드 파서는 길이가 긴 입력 라인을 수용해야합니다.</target>
        </trans-unit>
        <trans-unit id="1bf89edbc56bd1aa97ad7cab04b88498a0a483ec" translate="yes" xml:space="preserve">
          <source>Pod parsers should not, by default, try to coerce apostrophe (') and quote (&quot;) into smart quotes (little 9's, 66's, 99's, etc), nor try to turn backtick (`) into anything else but a single backtick character (distinct from an open quote character!), nor &quot;--&quot; into anything but two minus signs. They</source>
          <target state="translated">포드 파서는 기본적으로 아포스트로피 ( ')와 따옴표 ( &quot;)를 똑똑한 따옴표 (작은 9, 66, 99 등)로 강요하거나 백틱 (`)을 단일 백틱 문자 이외의 다른 것으로 바꾸려고 시도해서는 안됩니다. (공개 인용 문자와 구별됨) 또는 &quot;-&quot;는 두 개의 빼기 부호를 제외한 다른 문자로도 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="6e79c8f8c8738ed0d3f21bff581d4bef63a3b7d3" translate="yes" xml:space="preserve">
          <source>Pod parsers should understand all &quot;E&amp;lt;html&amp;gt;&quot; codes as defined in the entity declarations in the most recent XHTML specification at &lt;code&gt;www.W3.org&lt;/code&gt; . Pod parsers must understand at least the entities that define characters in the range 160-255 (Latin-1). Pod parsers, when faced with some unknown &quot;E&amp;lt;</source>
          <target state="translated">포드 파서는 &lt;code&gt;www.W3.org&lt;/code&gt; 의 최신 XHTML 사양에서 엔티티 선언에 정의 된 모든 &quot;E &amp;lt;html&amp;gt;&quot;코드를 이해해야 합니다. 포드 파서는 160-255 (Latin-1) 범위의 문자를 정의하는 엔터티를 이해해야합니다. 알 수없는 &quot;E &amp;lt;</target>
        </trans-unit>
        <trans-unit id="16758347dcd3bd561280b8ac6b5b799804590e6a" translate="yes" xml:space="preserve">
          <source>Pod parsers should understand all &quot;E&amp;lt;html&amp;gt;&quot; codes as defined in the entity declarations in the most recent XHTML specification at &lt;code&gt;www.W3.org&lt;/code&gt;. Pod parsers must understand at least the entities that define characters in the range 160-255 (Latin-1). Pod parsers, when faced with some unknown &quot;E&amp;lt;</source>
          <target state="translated">포드 파서는 &lt;code&gt;www.W3.org&lt;/code&gt; 의 최신 XHTML 사양의 엔티티 선언에 정의 된 모든 &quot;E &amp;lt;html&amp;gt;&quot;코드를 이해해야 합니다. 포드 파서는 최소한 160 ~ 255 (Latin-1) 범위의 문자를 정의하는 항목을 이해해야합니다. 알 수없는 &quot;E &amp;lt;에 직면했을 때 포드 파서</target>
        </trans-unit>
        <trans-unit id="435533c0da449df0b3756321a9e1ae46d36e29f8" translate="yes" xml:space="preserve">
          <source>Pod parsers should, by default, expand tabs in verbatim paragraphs as they are processed, before passing them to the formatter or other processor. Parsers may also allow an option for overriding this.</source>
          <target state="translated">포드 파서는 기본적으로 포맷터 나 다른 프로세서로 전달하기 전에 처리 될 때 그대로의 단락에서 탭을 확장해야합니다. 파서는이를 재정의하는 옵션을 허용 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="3ca8470501fde76fe0175878b3907601deeb185a" translate="yes" xml:space="preserve">
          <source>Pod parsers should, by default, remove newlines from the end of ordinary and verbatim paragraphs before passing them to the formatter. For example, while the paragraph you're reading now could be considered, in Pod source, to end with (and contain) the newline(s) that end it, it should be processed as ending with (and containing) the period character that ends this sentence.</source>
          <target state="translated">포드 파서는 기본적으로 포맷터로 전달하기 전에 일반 및 완전 단락의 끝에서 줄 바꿈을 제거해야합니다. 예를 들어, 지금 읽고있는 단락을 포드 소스에서 줄 바꿈으로 끝나고 포함하는 것으로 간주 할 수 있지만 마침표 문자로 끝나는 것으로 처리해야합니다. 이 문장을 끝냅니다.</target>
        </trans-unit>
        <trans-unit id="ed20dd657439280794de2dd1f166cc37caab82bd" translate="yes" xml:space="preserve">
          <source>Pod parsers, when processing a series of data paragraphs one after another (within a single region), should consider them to be one large data paragraph that happens to contain blank lines. So the content of the above &quot;=begin html&quot;...&quot;=end html&quot;</source>
          <target state="translated">포드 파서는 일련의 데이터 단락을 단일 영역 내에서 하나씩 처리 할 때 빈 행을 포함하는 하나의 큰 데이터 단락으로 간주해야합니다. 따라서 위의 &quot;= begin html&quot;... &quot;= end html&quot;의 내용</target>
        </trans-unit>
        <trans-unit id="f0083162b22d1c665e8c416af71fd03dff278ffc" translate="yes" xml:space="preserve">
          <source>Pod parsers, when processing a series of verbatim paragraphs one after another, should consider them to be one large verbatim paragraph that happens to contain blank lines. I.e., these two lines, which have a blank line between them:</source>
          <target state="translated">포드 파서는 일련의 연속 된 단락을 차례로 처리 할 때 빈 줄을 포함하는 하나의 큰 그대로의 단락으로 간주해야합니다. 즉,이 두 줄 사이에는 빈 줄이 있습니다.</target>
        </trans-unit>
        <trans-unit id="b5f64a484d29376d6815265a1e55624e33ac0e03" translate="yes" xml:space="preserve">
          <source>Pod parsers, when reporting errors, should make some effort to report an approximate line number (&quot;Nested E&amp;lt;&amp;gt;'s in Paragraph #52, near line 633 of Thing/Foo.pm!&quot;), instead of merely noting the paragraph number (&quot;Nested E&amp;lt;&amp;gt;'s in Paragraph #52 of Thing/Foo.pm!&quot;). Where this is problematic, the paragraph number should at least be accompanied by an excerpt from the paragraph (&quot;Nested E&amp;lt;&amp;gt;'s in Paragraph #52 of Thing/Foo.pm, which begins 'Read/write accessor for the C&amp;lt;interest rate&amp;gt; attribute...'&quot;).</source>
          <target state="translated">오류를보고 할 때 포드 파서는 단락 번호를 표시하는 대신 대략적인 라인 번호 ( &quot;52 번 문단, Thing / Foo.pm의 633 라인 근처에 있습니다!&quot;)를보고하기 위해 약간의 노력을 기울여야합니다. ( &quot;Thing / Foo.pm의 단락 # 52에 E &amp;lt;&amp;gt;가 필요합니다!&quot;). 이것이 문제가되는 경우, 단락 번호는 적어도 단락에서 발췌해야합니다 ( &quot;Thing / Foo.pm 단락 # 52에서&quot;Ested E &amp;lt;&amp;gt; '는'C &amp;lt;interest에 대한 읽기 / 쓰기 접근 자 '를 시작 함) rate&amp;gt; 속성 ... ' &quot;).</target>
        </trans-unit>
        <trans-unit id="668dc3898e0866dd2110d298d9f0248ce827b86d" translate="yes" xml:space="preserve">
          <source>Pod processors must now treat &quot;text|&quot;-less links as follows:</source>
          <target state="translated">포드 프로세서는 이제 &quot;text |&quot;-less 링크를 다음과 같이 처리해야합니다.</target>
        </trans-unit>
        <trans-unit id="594a4383ca99a25d0a62e673cd217ea7d9ae8dcd" translate="yes" xml:space="preserve">
          <source>Pod processors must treat a &quot;=for [label] [content...]&quot; paragraph as meaning the same thing as a &quot;=begin [label]&quot; paragraph, content, and an &quot;=end [label]&quot; paragraph. (The parser may conflate these two constructs, or may leave them distinct, in the expectation that the formatter will nevertheless treat them the same.)</source>
          <target state="translated">포드 프로세서는 &quot;= for [label] [content ...]&quot;단락을 &quot;= begin [label]&quot;단락, 내용 및 &quot;= end [label]&quot;단락과 동일한 것을 의미하는 것으로 간주해야합니다. 그럼에도 불구하고 파서는 포맷터가 그것들을 동일하게 취급 할 것이라는 기대로이 두 구성을 혼동하거나 구별 할 수있다.</target>
        </trans-unit>
        <trans-unit id="6de2f56b65b8b60daa7959cb94ce9eb7617c07e8" translate="yes" xml:space="preserve">
          <source>Pod processors seeing such a contentless &quot;=over&quot; ... &quot;=back&quot; region, may ignore it, or may report it as an error.</source>
          <target state="translated">컨텐츠가없는 &quot;= over&quot;... &quot;= back&quot;영역을 보는 포드 프로세서는이를 무시하거나 오류로보고 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3a61b4f9c5145d423bbf4e3510d246b1bb3674c7" translate="yes" xml:space="preserve">
          <source>Pod processors should tolerate &quot;=item *&quot; / &quot;=item</source>
          <target state="translated">포드 프로세서는 &quot;= item *&quot;/ &quot;= item을 허용해야합니다.</target>
        </trans-unit>
        <trans-unit id="9adfdecd54c38e1ba53caaf5b50318f5e88b69d6" translate="yes" xml:space="preserve">
          <source>Pod processors should tolerate empty &quot;=begin</source>
          <target state="translated">포드 프로세서는 비어있는 &quot;= 시작을 허용해야합니다.</target>
        </trans-unit>
        <trans-unit id="6ba827650f169b32c9dafe5b41a25b33124521f2" translate="yes" xml:space="preserve">
          <source>Pod text (i.e., possibly containing formatting codes) that's just not for normal formatting (e.g., may not be a normal-use paragraph, but might be for formatting as a footnote).</source>
          <target state="translated">일반 서식이 아닌 포드 텍스트 (예 : 서식 코드가 포함되어있을 수 있음) (예 : 일반적인 사용 단락이 아니라 각주 형식 일 수 있음)</target>
        </trans-unit>
        <trans-unit id="2783a719cd65c4f57c6fddc4f5f579afb17e9719" translate="yes" xml:space="preserve">
          <source>Pod-Parser is free software; you can redistribute it and/or modify it under the terms of the Artistic License distributed with Perl version 5.000 or (at your option) any later version. Please refer to the Artistic License that came with your Perl distribution for more details. If your version of Perl was not distributed under the terms of the Artistic License, than you may distribute PodParser under the same terms as Perl itself.</source>
          <target state="translated">포드 파서는 무료 소프트웨어입니다. Perl 버전 5.000 또는 그 이후 버전으로 배포 된 Artistic License의 조건에 따라 재배포 및 / 또는 수정할 수 있습니다. 자세한 내용은 Perl 배포판과 함께 제공된 Artistic License를 참조하십시오. Perl 버전이 Artistic License의 조항에 따라 배포되지 않은 경우, Perl과 동일한 조건으로 PodParser를 배포 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1e0d75b84c30c843c8bfda065ca1ea8379066bee" translate="yes" xml:space="preserve">
          <source>Pod::Cache</source>
          <target state="translated">Pod::Cache</target>
        </trans-unit>
        <trans-unit id="b1da253840554c380163f270f69e5e71950e910f" translate="yes" xml:space="preserve">
          <source>Pod::Cache::Item</source>
          <target state="translated">Pod::Cache::Item</target>
        </trans-unit>
        <trans-unit id="4309bafc5148041a8cbecb4efa7c1ba20ab29cfb" translate="yes" xml:space="preserve">
          <source>Pod::Checker</source>
          <target state="translated">Pod::Checker</target>
        </trans-unit>
        <trans-unit id="27cda8ded60e07a80496a98d87fc154efc44a085" translate="yes" xml:space="preserve">
          <source>Pod::Checker - check pod documents for syntax errors</source>
          <target state="translated">Pod :: Checker-구문 오류에 대한 pod 문서 확인</target>
        </trans-unit>
        <trans-unit id="a5093f45c4b5aaed940c739c6d883bfba267a005" translate="yes" xml:space="preserve">
          <source>Pod::Checker, podchecker() - check pod documents for syntax errors</source>
          <target state="translated">Pod :: Checker, podchecker ()-구문 오류에 대한 포드 문서 확인</target>
        </trans-unit>
        <trans-unit id="b66220cfac7078b071d64dbaadef5e2df1a1682d" translate="yes" xml:space="preserve">
          <source>Pod::Escapes</source>
          <target state="translated">Pod::Escapes</target>
        </trans-unit>
        <trans-unit id="70a96b22865c78bae1b86e98f32189c8aaa2bb49" translate="yes" xml:space="preserve">
          <source>Pod::Escapes - for resolving Pod E&amp;lt;...&amp;gt; sequences</source>
          <target state="translated">Pod :: Escapes-Pod E &amp;lt;...&amp;gt; 시퀀스 해결</target>
        </trans-unit>
        <trans-unit id="6defdf29847160bf19d64c9df0b01a83e7104754" translate="yes" xml:space="preserve">
          <source>Pod::Find</source>
          <target state="translated">Pod::Find</target>
        </trans-unit>
        <trans-unit id="808564a4fa3f783ef4d67e5d6df9a8f115d31c52" translate="yes" xml:space="preserve">
          <source>Pod::Find - find POD documents in directory trees</source>
          <target state="translated">포드 :: 찾기-디렉토리 트리에서 POD 문서 찾기</target>
        </trans-unit>
        <trans-unit id="dad87a793e174e3498e4bb970a27f08fc37c4ec4" translate="yes" xml:space="preserve">
          <source>Pod::Functions</source>
          <target state="translated">Pod::Functions</target>
        </trans-unit>
        <trans-unit id="5ae2aa0e6801f18d083fa71458d5eb312ff91cd1" translate="yes" xml:space="preserve">
          <source>Pod::Functions - Group Perl's functions a la perlfunc.pod</source>
          <target state="translated">포드 :: 함수-그룹 Perl의 기능은 la perlfunc.pod</target>
        </trans-unit>
        <trans-unit id="155d59dfdac80d383af24b34deb797773121193e" translate="yes" xml:space="preserve">
          <source>Pod::Html</source>
          <target state="translated">Pod::Html</target>
        </trans-unit>
        <trans-unit id="6ce65cf1b1b1d8e5982cc14bc857d4e459129be4" translate="yes" xml:space="preserve">
          <source>Pod::Html - module to convert pod files to HTML</source>
          <target state="translated">포드 :: Html-포드 파일을 HTML로 변환하는 모듈</target>
        </trans-unit>
        <trans-unit id="5ed5257c3f06b8fdcae25020648334294f4275b0" translate="yes" xml:space="preserve">
          <source>Pod::Hyperlink</source>
          <target state="translated">Pod::Hyperlink</target>
        </trans-unit>
        <trans-unit id="dd2479ef40c118023069cffd4b8d4af17078456b" translate="yes" xml:space="preserve">
          <source>Pod::InputObjects</source>
          <target state="translated">Pod::InputObjects</target>
        </trans-unit>
        <trans-unit id="bfd22e221bc5d9239254ba01ea54c7e2a5450505" translate="yes" xml:space="preserve">
          <source>Pod::InputObjects - objects representing POD input paragraphs, commands, etc.</source>
          <target state="translated">Pod :: InputObjects-POD 입력 단락, 명령 등을 나타내는 객체</target>
        </trans-unit>
        <trans-unit id="1fd87a3ff91f7bce73657a26c6061dd462442c15" translate="yes" xml:space="preserve">
          <source>Pod::InteriorSequence-&amp;gt;*new()*</source>
          <target state="translated">Pod::InteriorSequence-&amp;gt;*new()*</target>
        </trans-unit>
        <trans-unit id="aa9152899b6499f1f28c2040e96614e6bafb5e59" translate="yes" xml:space="preserve">
          <source>Pod::InteriorSequence-&amp;gt;&lt;b&gt;new()&lt;/b&gt;</source>
          <target state="translated">Pod::InteriorSequence-&amp;gt;&lt;b&gt;new()&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="910131799392bc52cef82e99a388fd9c65b4ae23" translate="yes" xml:space="preserve">
          <source>Pod::InteriorSequence::*DESTROY()*</source>
          <target state="translated">Pod::InteriorSequence::*DESTROY()*</target>
        </trans-unit>
        <trans-unit id="1f1f3b74ed98a3dd9e45e5bf6a582d0ed682382c" translate="yes" xml:space="preserve">
          <source>Pod::InteriorSequence::&lt;b&gt;DESTROY()&lt;/b&gt;</source>
          <target state="translated">Pod::InteriorSequence::&lt;b&gt;DESTROY()&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="7583826bf22698054ad129c59e6b413946e80949" translate="yes" xml:space="preserve">
          <source>Pod::List</source>
          <target state="translated">Pod::List</target>
        </trans-unit>
        <trans-unit id="399a822bdd33d5589ccd5adac65bb8bcadff8e2b" translate="yes" xml:space="preserve">
          <source>Pod::Man</source>
          <target state="translated">Pod::Man</target>
        </trans-unit>
        <trans-unit id="5e62c421e1876f6d3d9c493879772552cb121e98" translate="yes" xml:space="preserve">
          <source>Pod::Man - Convert POD data to formatted *roff input</source>
          <target state="translated">Pod :: Man-POD 데이터를 형식화 된 * roff 입력으로 변환</target>
        </trans-unit>
        <trans-unit id="b90fbc49b7a05d49287613663bd77efed96454b2" translate="yes" xml:space="preserve">
          <source>Pod::Man assumes that your *roff formatters have a fixed-width font named &lt;code&gt;CW&lt;/code&gt; . If yours is called something else (like &lt;code&gt;CR&lt;/code&gt; ), use the &lt;code&gt;fixed&lt;/code&gt; option to specify it. This generally only matters for troff output for printing. Similarly, you can set the fonts used for bold, italic, and bold italic fixed-width output.</source>
          <target state="translated">Pod :: Man은 * roff 포맷터에 &lt;code&gt;CW&lt;/code&gt; 라는 고정 너비 글꼴이 있다고 가정합니다 . &lt;code&gt;CR&lt;/code&gt; 과 같은 다른 것을 호출 하면 &lt;code&gt;fixed&lt;/code&gt; 옵션을 사용하여 지정하십시오. 이것은 일반적으로 인쇄용 troff 출력에만 중요합니다. 마찬가지로 굵게, 기울임 꼴 및 굵게 기울임 꼴 고정 너비 출력에 사용되는 글꼴을 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cb9d1748a81808e728009b92b1162054aaa06911" translate="yes" xml:space="preserve">
          <source>Pod::Man assumes that your *roff formatters have a fixed-width font named &lt;code&gt;CW&lt;/code&gt;. If yours is called something else (like &lt;code&gt;CR&lt;/code&gt;), use the &lt;code&gt;fixed&lt;/code&gt; option to specify it. This generally only matters for troff output for printing. Similarly, you can set the fonts used for bold, italic, and bold italic fixed-width output.</source>
          <target state="translated">Pod :: Man은 * roff 포맷터에 &lt;code&gt;CW&lt;/code&gt; 라는 고정 너비 글꼴이 있다고 가정합니다 . 귀하의 것이 &lt;code&gt;CR&lt;/code&gt; 과 같은 다른 것으로 불려 지면 &lt;code&gt;fixed&lt;/code&gt; 옵션을 사용하여 지정하십시오. 이것은 일반적으로 인쇄용 troff 출력에만 중요합니다. 마찬가지로 굵게, 기울임 꼴 및 굵게 기울임 꼴 고정 너비 출력에 사용되는 글꼴을 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="87a26f0879ac57b4dc74e16802d7a975443066e4" translate="yes" xml:space="preserve">
          <source>Pod::Man doesn't handle font names longer than two characters. Neither do most &lt;b&gt;troff&lt;/b&gt; implementations, but GNU troff does as an extension. It would be nice to support as an option for those who want to use it.</source>
          <target state="translated">Pod :: Man은 두 문자보다 긴 글꼴 이름을 처리하지 않습니다. 대부분의 &lt;b&gt;troff&lt;/b&gt; 구현은 아니지만 GNU troff는 확장으로 사용됩니다. 그것을 사용하려는 사람들을위한 옵션으로 지원하는 것이 좋을 것입니다.</target>
        </trans-unit>
        <trans-unit id="ac7f587bee7ab6accabf7dabad0c45ac456a4a26" translate="yes" xml:space="preserve">
          <source>Pod::Man is a module to convert documentation in the POD format (the preferred language for documenting Perl) into *roff input using the man macro set. The resulting *roff code is suitable for display on a terminal using</source>
          <target state="translated">Pod :: Man은 man 매크로 세트를 사용하여 POD 형식의 문서 (Perl을 문서화하기 위해 선호하는 언어)를 * roff 입력으로 변환하는 모듈입니다. 결과 * roff 코드는 다음을 사용하여 터미널에 표시하는 데 적합합니다</target>
        </trans-unit>
        <trans-unit id="3d124211073212f4a2d9f14b6de074e349d8b73d" translate="yes" xml:space="preserve">
          <source>Pod::Man is a module to convert documentation in the POD format (the preferred language for documenting Perl) into *roff input using the man macro set. The resulting *roff code is suitable for display on a terminal using &lt;a href=&quot;http://man.he.net/man1/nroff&quot;&gt;nroff(1)&lt;/a&gt;, normally via &lt;a href=&quot;http://man.he.net/man1/man&quot;&gt;man(1)&lt;/a&gt;, or printing using &lt;a href=&quot;http://man.he.net/man1/troff&quot;&gt;troff(1)&lt;/a&gt;. It is conventionally invoked using the driver script &lt;b&gt;pod2man&lt;/b&gt;, but it can also be used directly.</source>
          <target state="translated">Pod :: Man은 man 매크로 세트를 사용하여 POD 형식 (Perl을 문서화하는 데 선호되는 언어)의 문서를 * roff 입력으로 변환하는 모듈입니다. 결과 * roff 코드는 일반적으로 &lt;a href=&quot;http://man.he.net/man1/man&quot;&gt;man (1)을&lt;/a&gt; 통해 &lt;a href=&quot;http://man.he.net/man1/nroff&quot;&gt;nroff (1)를&lt;/a&gt; 사용하여 터미널에 표시 하거나 &lt;a href=&quot;http://man.he.net/man1/troff&quot;&gt;troff (1)를&lt;/a&gt; 사용하여 인쇄하는 데 적합 합니다. 일반적으로 드라이버 스크립트 &lt;b&gt;pod2man을&lt;/b&gt; 사용하여 호출 되지만 직접 사용할 수도 있습니다.&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="ad3445f4f79ce9259a8628ec68bc720cda5d5e62" translate="yes" xml:space="preserve">
          <source>Pod::Man is excessively slow.</source>
          <target state="translated">Pod :: Man이 너무 느립니다.</target>
        </trans-unit>
        <trans-unit id="51823c2a78f4399e5665a442ee35e9c5bca035b6" translate="yes" xml:space="preserve">
          <source>Pod::Paragraph-&amp;gt;*new()*</source>
          <target state="translated">Pod::Paragraph-&amp;gt;*new()*</target>
        </trans-unit>
        <trans-unit id="7d19eb9c0ae5cf759f818151ef1964f55c63cf45" translate="yes" xml:space="preserve">
          <source>Pod::Paragraph-&amp;gt;&lt;b&gt;new()&lt;/b&gt;</source>
          <target state="translated">Pod::Paragraph-&amp;gt;&lt;b&gt;new()&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="74702680baaf5527f7457048b890cf998a0bb577" translate="yes" xml:space="preserve">
          <source>Pod::ParseLink</source>
          <target state="translated">Pod::ParseLink</target>
        </trans-unit>
        <trans-unit id="cb542aa99fa734c9712efd42aa4abd5626202cf7" translate="yes" xml:space="preserve">
          <source>Pod::ParseLink - Parse an L&amp;lt;&amp;gt; formatting code in POD text</source>
          <target state="translated">Pod :: ParseLink-POD 텍스트에서 L &amp;lt;&amp;gt; 형식화 코드 구문 분석</target>
        </trans-unit>
        <trans-unit id="40d45d7153ea7fd47a061f54ddf8f05276e6b0a8" translate="yes" xml:space="preserve">
          <source>Pod::ParseTree-&amp;gt;*new()*</source>
          <target state="translated">Pod::ParseTree-&amp;gt;*new()*</target>
        </trans-unit>
        <trans-unit id="c5b3a2fe463766f0c50d1925513a960e96c11a70" translate="yes" xml:space="preserve">
          <source>Pod::ParseTree-&amp;gt;&lt;b&gt;new()&lt;/b&gt;</source>
          <target state="translated">Pod::ParseTree-&amp;gt;&lt;b&gt;new()&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="58e28f5f7a4d5a5122148dd16c2d1e71ce7bc46b" translate="yes" xml:space="preserve">
          <source>Pod::ParseTree::*DESTROY()*</source>
          <target state="translated">Pod::ParseTree::*DESTROY()*</target>
        </trans-unit>
        <trans-unit id="81662ddf3d094b6a72fa9f04c80b756682be36f9" translate="yes" xml:space="preserve">
          <source>Pod::ParseTree::&lt;b&gt;DESTROY()&lt;/b&gt;</source>
          <target state="translated">Pod::ParseTree::&lt;b&gt;DESTROY()&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="ee80a8df78f91720393a41e76f1774b357695e04" translate="yes" xml:space="preserve">
          <source>Pod::ParseUtils</source>
          <target state="translated">Pod::ParseUtils</target>
        </trans-unit>
        <trans-unit id="bbc14d0ac8be47a43775571a03e2b17ca30027af" translate="yes" xml:space="preserve">
          <source>Pod::ParseUtils - helpers for POD parsing and conversion</source>
          <target state="translated">포드 :: ParseUtils-POD 구문 분석 및 변환을위한 도우미</target>
        </trans-unit>
        <trans-unit id="0f85b7c22f11f515805110a0d85c8bbe81e1d272" translate="yes" xml:space="preserve">
          <source>Pod::Parser</source>
          <target state="translated">Pod::Parser</target>
        </trans-unit>
        <trans-unit id="e349932a04d5644a45ac3d6d00713d29777c5bd0" translate="yes" xml:space="preserve">
          <source>Pod::Parser - base class for creating POD filters and translators</source>
          <target state="translated">포드 :: 파서-POD 필터 및 번역기를 만들기위한 기본 클래스</target>
        </trans-unit>
        <trans-unit id="87e59733686c14028fb5b5ae16afd20f13d498de" translate="yes" xml:space="preserve">
          <source>Pod::Perldoc</source>
          <target state="translated">Pod::Perldoc</target>
        </trans-unit>
        <trans-unit id="9d3a2f1ea446fa05938de94bfd8b37f662112ca1" translate="yes" xml:space="preserve">
          <source>Pod::Perldoc - Look up Perl documentation in Pod format.</source>
          <target state="translated">Pod :: Perldoc-Pod 형식의 Perl 설명서를 찾습니다.</target>
        </trans-unit>
        <trans-unit id="952ca16414e36da5649f023d81973c25e340d6f9" translate="yes" xml:space="preserve">
          <source>Pod::Perldoc::BaseTo</source>
          <target state="translated">Pod::Perldoc::BaseTo</target>
        </trans-unit>
        <trans-unit id="35bfe0dc1cd61b9db99276bb0f43f2c0c5ad18a2" translate="yes" xml:space="preserve">
          <source>Pod::Perldoc::BaseTo - Base for Pod::Perldoc formatters</source>
          <target state="translated">포드 :: Perldoc :: BaseTo-포드 :: Perldoc 포맷터의 기본</target>
        </trans-unit>
        <trans-unit id="b4063f396bd36a75310fe477b3233942b1f8e567" translate="yes" xml:space="preserve">
          <source>Pod::Perldoc::GetOptsOO</source>
          <target state="translated">Pod::Perldoc::GetOptsOO</target>
        </trans-unit>
        <trans-unit id="a32860ca9b02758a905681124e46d01c0cb1afa0" translate="yes" xml:space="preserve">
          <source>Pod::Perldoc::GetOptsOO - Customized option parser for Pod::Perldoc</source>
          <target state="translated">포드 :: Perldoc :: GetOptsOO-포드 :: Perldoc에 대한 사용자 정의 옵션 파서</target>
        </trans-unit>
        <trans-unit id="9cd9c7c8bf140c8ef70c8bdc93de0b50d1c033a5" translate="yes" xml:space="preserve">
          <source>Pod::Perldoc::ToANSI</source>
          <target state="translated">Pod::Perldoc::ToANSI</target>
        </trans-unit>
        <trans-unit id="7657ee714db57c17e93a20e9955a2fbbbe328e50" translate="yes" xml:space="preserve">
          <source>Pod::Perldoc::ToANSI - render Pod with ANSI color escapes</source>
          <target state="translated">Pod :: Perldoc :: ToANSI-ANSI 색상 이스케이프를 사용하여 포드 렌더링</target>
        </trans-unit>
        <trans-unit id="4db2d3912d225b5fb9794a822706dc8ac6dd251e" translate="yes" xml:space="preserve">
          <source>Pod::Perldoc::ToChecker</source>
          <target state="translated">Pod::Perldoc::ToChecker</target>
        </trans-unit>
        <trans-unit id="fb1bc67a07a358017c46696594ab3bb46f1cb4a2" translate="yes" xml:space="preserve">
          <source>Pod::Perldoc::ToChecker - let Perldoc check Pod for errors</source>
          <target state="translated">포드 :: Perldoc :: ToChecker-Perldoc에서 포드에 오류가 있는지 확인</target>
        </trans-unit>
        <trans-unit id="a1574ea07e4ca7da944a178adab1f198c77bb9c4" translate="yes" xml:space="preserve">
          <source>Pod::Perldoc::ToMan</source>
          <target state="translated">Pod::Perldoc::ToMan</target>
        </trans-unit>
        <trans-unit id="30ccb6b13c861e844f65ca3477dee08e5031e04b" translate="yes" xml:space="preserve">
          <source>Pod::Perldoc::ToMan - let Perldoc render Pod as man pages</source>
          <target state="translated">Pod :: Perldoc :: ToMan-Perldoc이 포드를 맨 페이지로 렌더링하도록 허용</target>
        </trans-unit>
        <trans-unit id="e4528b7a26cc2f22afcb70063b8c90bfcec139cb" translate="yes" xml:space="preserve">
          <source>Pod::Perldoc::ToNroff</source>
          <target state="translated">Pod::Perldoc::ToNroff</target>
        </trans-unit>
        <trans-unit id="aad347f7e727638ba9cf62fde0284182ed3e5499" translate="yes" xml:space="preserve">
          <source>Pod::Perldoc::ToNroff - let Perldoc convert Pod to nroff</source>
          <target state="translated">Pod :: Perldoc :: ToNroff-Perldoc이 포드를 nroff로 변환하도록합니다.</target>
        </trans-unit>
        <trans-unit id="c74cfee58278b9d7e2d985e281b40bac7cf67fe1" translate="yes" xml:space="preserve">
          <source>Pod::Perldoc::ToPod</source>
          <target state="translated">Pod::Perldoc::ToPod</target>
        </trans-unit>
        <trans-unit id="d74169b37abf471a8016b67eb6b64f1d9c9504cb" translate="yes" xml:space="preserve">
          <source>Pod::Perldoc::ToPod - let Perldoc render Pod as ... Pod!</source>
          <target state="translated">포드 :: Perldoc :: ToPod-Perldoc가 포드를 다음과 같이 렌더링하도록합니다. 포드!</target>
        </trans-unit>
        <trans-unit id="f92919a3efdae5160bab598ae79998a12eaeb9d9" translate="yes" xml:space="preserve">
          <source>Pod::Perldoc::ToRtf</source>
          <target state="translated">Pod::Perldoc::ToRtf</target>
        </trans-unit>
        <trans-unit id="0397b052f308b568ed8ea3c3f278e9880b59064b" translate="yes" xml:space="preserve">
          <source>Pod::Perldoc::ToRtf - let Perldoc render Pod as RTF</source>
          <target state="translated">Pod :: Perldoc :: ToRtf-Perldoc이 포드를 RTF로 렌더링하도록합니다.</target>
        </trans-unit>
        <trans-unit id="fd1e41f569b50e20cb00459a2e024d1d48daa4ae" translate="yes" xml:space="preserve">
          <source>Pod::Perldoc::ToTerm</source>
          <target state="translated">Pod::Perldoc::ToTerm</target>
        </trans-unit>
        <trans-unit id="9fd6d1a0399a01712bf45f2452104d56dd37b0b7" translate="yes" xml:space="preserve">
          <source>Pod::Perldoc::ToTerm - render Pod with terminal escapes</source>
          <target state="translated">Pod :: Perldoc :: ToTerm-터미널 이스케이프를 사용하여 포드 렌더링</target>
        </trans-unit>
        <trans-unit id="c1c7e677057bffb1949a495159f761c28d093073" translate="yes" xml:space="preserve">
          <source>Pod::Perldoc::ToText</source>
          <target state="translated">Pod::Perldoc::ToText</target>
        </trans-unit>
        <trans-unit id="1b76ad0504a574b95327f3837e47de7fc1023f81" translate="yes" xml:space="preserve">
          <source>Pod::Perldoc::ToText - let Perldoc render Pod as plaintext</source>
          <target state="translated">Pod :: Perldoc :: ToText-Perldoc이 포드를 일반 텍스트로 렌더링하도록합니다.</target>
        </trans-unit>
        <trans-unit id="44a2311f8a968a637bebf75641a7ba7c7bea0e77" translate="yes" xml:space="preserve">
          <source>Pod::Perldoc::ToTk</source>
          <target state="translated">Pod::Perldoc::ToTk</target>
        </trans-unit>
        <trans-unit id="ce6206e971d4052af6b94fba7e16c592c58263c8" translate="yes" xml:space="preserve">
          <source>Pod::Perldoc::ToTk - let Perldoc use Tk::Pod to render Pod</source>
          <target state="translated">포드 :: Perldoc :: ToTk-Perldoc이 Tk :: Pod를 사용하여 포드를 렌더링하게합니다.</target>
        </trans-unit>
        <trans-unit id="cd1e43a8f3efd6bddd767fd169879bd7e8783197" translate="yes" xml:space="preserve">
          <source>Pod::Perldoc::ToXml</source>
          <target state="translated">Pod::Perldoc::ToXml</target>
        </trans-unit>
        <trans-unit id="eb2c349f8bc3477a2154a9f78f20889a0cd5e99e" translate="yes" xml:space="preserve">
          <source>Pod::Perldoc::ToXml - let Perldoc render Pod as XML</source>
          <target state="translated">Pod :: Perldoc :: ToXml-Perldoc이 포드를 XML로 렌더링하도록 허용</target>
        </trans-unit>
        <trans-unit id="944eb1a064749ff64ccfc3ec1500e3e6fc76949a" translate="yes" xml:space="preserve">
          <source>Pod::PlainText</source>
          <target state="translated">Pod::PlainText</target>
        </trans-unit>
        <trans-unit id="5cc69f416528304166ca8b06a7aa0165df6da3fc" translate="yes" xml:space="preserve">
          <source>Pod::PlainText - Convert POD data to formatted ASCII text</source>
          <target state="translated">Pod :: PlainText-POD 데이터를 형식이 지정된 ASCII 텍스트로 변환</target>
        </trans-unit>
        <trans-unit id="946a0512ab5f99c773ae3db3dc5b34c4ce07ed9b" translate="yes" xml:space="preserve">
          <source>Pod::PlainText is a module that can convert documentation in the POD format (the preferred language for documenting Perl) into formatted ASCII. It uses no special formatting controls or codes whatsoever, and its output is therefore suitable for nearly any device.</source>
          <target state="translated">Pod :: PlainText는 POD 형식의 문서 (Perl을 문서화하는 데 선호되는 언어)를 형식이 지정된 ASCII로 변환 할 수있는 모듈입니다. 특별한 형식 지정 컨트롤이나 코드를 사용하지 않으므로 출력은 거의 모든 장치에 적합합니다.</target>
        </trans-unit>
        <trans-unit id="8ed6eb484633051ee80e6a561ff9dcdff2c845ec" translate="yes" xml:space="preserve">
          <source>Pod::Select</source>
          <target state="translated">Pod::Select</target>
        </trans-unit>
        <trans-unit id="14904b6c97faa949c076532da064781f2d55c6b6" translate="yes" xml:space="preserve">
          <source>Pod::Select, podselect() - extract selected sections of POD from input</source>
          <target state="translated">Pod :: Select, podselect ()-입력에서 선택한 POD 섹션을 추출합니다.</target>
        </trans-unit>
        <trans-unit id="661be2b89917f8caa0e44c582550ee749e115412" translate="yes" xml:space="preserve">
          <source>Pod::Simpele::XHTML was created by Allison Randal &amp;lt;allison@perl.org&amp;gt;.</source>
          <target state="translated">Pod :: Simpele :: XHTML은 Allison Randal &amp;lt;allison@perl.org&amp;gt;에 의해 작성되었습니다.</target>
        </trans-unit>
        <trans-unit id="d6a12e7ef9128476299731ac0108ac1f784f3a4d" translate="yes" xml:space="preserve">
          <source>Pod::Simple</source>
          <target state="translated">Pod::Simple</target>
        </trans-unit>
        <trans-unit id="5996780debc4d561a6d61c26d2810b23db42afb5" translate="yes" xml:space="preserve">
          <source>Pod::Simple - framework for parsing Pod</source>
          <target state="translated">Pod :: Simple-Pod 구문 분석을위한 프레임 워크</target>
        </trans-unit>
        <trans-unit id="6d11b0239af7ff1a19852fc395f1f5f5a3a35c0c" translate="yes" xml:space="preserve">
          <source>Pod::Simple is a Perl library for parsing text in the Pod (&quot;plain old documentation&quot;) markup language that is typically used for writing documentation for Perl and for Perl modules. The Pod format is explained &lt;a href=&quot;../perlpod&quot;&gt;perlpod&lt;/a&gt;; the most common formatter is called &lt;code&gt;perldoc&lt;/code&gt; .</source>
          <target state="translated">Pod :: Simple은 일반적으로 Perl 및 Perl 모듈 용 문서를 작성하는 데 사용되는 Pod ( &quot;일반 문서&quot;) 마크 업 언어로 텍스트를 구문 분석하기위한 Perl 라이브러리입니다. 포드 형식은 &lt;a href=&quot;../perlpod&quot;&gt;perlpod&lt;/a&gt; 에 설명 되어 있습니다 . 가장 일반적인 포맷터는 &lt;code&gt;perldoc&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="d5137b4a66b1a3ab70161fd3fed20b8efa15f0b7" translate="yes" xml:space="preserve">
          <source>Pod::Simple is a Perl library for parsing text in the Pod (&quot;plain old documentation&quot;) markup language that is typically used for writing documentation for Perl and for Perl modules. The Pod format is explained in &lt;a href=&quot;perlpod&quot;&gt;perlpod&lt;/a&gt;; the most common formatter is called &lt;code&gt;perldoc&lt;/code&gt;.</source>
          <target state="translated">Pod :: Simple은 일반적으로 Perl 및 Perl 모듈에 대한 문서를 작성하는 데 사용되는 Pod ( &quot;일반 문서&quot;) 마크 업 언어의 텍스트를 파싱하기위한 Perl 라이브러리입니다. 포드 형식은 &lt;a href=&quot;perlpod&quot;&gt;perlpod에&lt;/a&gt; 설명되어 있습니다 . 가장 일반적인 포맷터는 &lt;code&gt;perldoc&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="540c209eeff967303f473e2a9f8cc439bebb7a9a" translate="yes" xml:space="preserve">
          <source>Pod::Simple is maintained by:</source>
          <target state="translated">포드 :: 간단한 유지 관리 :</target>
        </trans-unit>
        <trans-unit id="bb05ccf22951145f967d6e477a3802aa35df7d1b" translate="yes" xml:space="preserve">
          <source>Pod::Simple provides a lot of methods that aren't generally interesting to the end user of an existing Pod formatter, but some of which you might find useful in writing a Pod formatter. They are listed below. The first several methods (the accept_* methods) are for declaring the capabilities of your parser, notably what &lt;code&gt;=for &lt;i&gt;targetname&lt;/i&gt;&lt;/code&gt; sections it's interested in, what extra N&amp;lt;...&amp;gt; codes it accepts beyond the ones described in the</source>
          <target state="translated">Pod :: Simple은 기존 Pod 포맷터의 최종 사용자에게 일반적으로 흥미롭지 않은 많은 메서드를 제공하지만 그중 일부는 Pod 포맷터를 작성하는 데 유용 할 수 있습니다. 아래에 나열되어 있습니다. 첫 번째 여러 가지 방법합니다 (accept_ * 방법) 파서의 기능을 선언위한, 특히 무엇 &lt;code&gt;=for &lt;i&gt;targetname&lt;/i&gt;&lt;/code&gt; 이에 관심있는 부분은, 여분의 것 N &amp;lt;...&amp;gt; 코드는 사람이 설명을 넘어 받아</target>
        </trans-unit>
        <trans-unit id="1804f7888eed7ad55ddcaa1547cb97407e48d6c0" translate="yes" xml:space="preserve">
          <source>Pod::Simple uses this class for representing the value of the &quot;section&quot; attribute of &quot;L&quot; start-element events. Most applications can just use the normal stringification of objects of this class; they stringify to just the text content of the section, such as &quot;foo&quot; for &lt;code&gt;L&amp;lt;Stuff/foo&amp;gt;&lt;/code&gt; , and &quot;bar&quot; for &lt;code&gt;L&amp;lt;Stuff/bI&amp;lt;ar&amp;gt;&amp;gt;&lt;/code&gt; .</source>
          <target state="translated">Pod :: Simple은이 클래스를 사용하여 &quot;L&quot;시작 요소 이벤트의 &quot;section&quot;속성 값을 나타냅니다. 대부분의 응용 프로그램은이 클래스의 객체에 대한 일반 문자열을 사용할 수 있습니다. &lt;code&gt;L&amp;lt;Stuff/foo&amp;gt;&lt;/code&gt; 경우 &quot;foo&quot; 및 &lt;code&gt;L&amp;lt;Stuff/bI&amp;lt;ar&amp;gt;&amp;gt;&lt;/code&gt; &quot;bar&quot; 와 같이 섹션의 텍스트 내용으로 만 문자열 화합니다. 됩니다.</target>
        </trans-unit>
        <trans-unit id="3042d36d43941ed5b64500dc2cd178778f09f598" translate="yes" xml:space="preserve">
          <source>Pod::Simple uses this class for representing the value of the &quot;section&quot; attribute of &quot;L&quot; start-element events. Most applications can just use the normal stringification of objects of this class; they stringify to just the text content of the section, such as &quot;foo&quot; for &lt;code&gt;L&amp;lt;Stuff/foo&amp;gt;&lt;/code&gt;, and &quot;bar&quot; for &lt;code&gt;L&amp;lt;Stuff/bI&amp;lt;ar&amp;gt;&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Pod :: Simple은 &quot;L&quot;시작 요소 이벤트의 &quot;섹션&quot;속성 값을 나타내는 데이 클래스를 사용합니다. 대부분의 응용 프로그램은이 클래스의 객체에 대한 일반적인 문자열 화를 사용할 수 있습니다. &lt;code&gt;L&amp;lt;Stuff/foo&amp;gt;&lt;/code&gt; 경우 &quot;foo&quot; , &lt;code&gt;L&amp;lt;Stuff/bI&amp;lt;ar&amp;gt;&amp;gt;&lt;/code&gt; &quot;bar&quot; 와 같이 섹션의 텍스트 내용으로 만 문자열 화됩니다 .</target>
        </trans-unit>
        <trans-unit id="dc75eedd949380ed057546f8903efcf7ffa0476d" translate="yes" xml:space="preserve">
          <source>Pod::Simple was created by Sean M. Burke &amp;lt;sburke@cpan.org&amp;gt; with code borrowed from Marek Rouchal's &lt;a href=&quot;../find&quot;&gt;Pod::Find&lt;/a&gt;, which in turn heavily borrowed code from Nick Ing-Simmons' &lt;code&gt;PodToHtml&lt;/code&gt; .</source>
          <target state="translated">Pod :: Simple은 Sean M. Burke &amp;lt;sburke@cpan.org&amp;gt;에 의해 Marek Rouchal의 &lt;a href=&quot;../find&quot;&gt;Pod :: Find&lt;/a&gt; 에서 빌린 코드로 만들어졌습니다.이 코드는 Nick Ing-Simmons의 &lt;code&gt;PodToHtml&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="046013a100ec04c3c2d20b96d7505ecd3be590e8" translate="yes" xml:space="preserve">
          <source>Pod::Simple was created by Sean M. Burke &amp;lt;sburke@cpan.org&amp;gt; with code borrowed from Marek Rouchal's &lt;a href=&quot;Pod::Find&quot;&gt;Pod::Find&lt;/a&gt;, which in turn heavily borrowed code from Nick Ing-Simmons' &lt;code&gt;PodToHtml&lt;/code&gt;.</source>
          <target state="translated">Pod :: Simple은 Sean M. Burke &amp;lt;sburke@cpan.org&amp;gt;가 Marek Rouchal의 &lt;a href=&quot;Pod::Find&quot;&gt;Pod :: Find&lt;/a&gt; 에서 차용 한 코드로 &lt;code&gt;PodToHtml&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8185c68a0339f127d3dbf1b4ad4adf9a512efe5f" translate="yes" xml:space="preserve">
          <source>Pod::Simple was created by Sean M. Burke &amp;lt;sburke@cpan.org&amp;gt;. But don't bother him, he's retired.</source>
          <target state="translated">포드 :: 단순은 Sean M. Burke &amp;lt;sburke@cpan.org&amp;gt;에 의해 만들어졌습니다. 그러나 그를 귀찮게하지 마십시오, 그는 은퇴했다.</target>
        </trans-unit>
        <trans-unit id="d80b5e8d9939c2b2cdcf8caadd6b9ea76e6a4a21" translate="yes" xml:space="preserve">
          <source>Pod::Simple::Checker</source>
          <target state="translated">Pod::Simple::Checker</target>
        </trans-unit>
        <trans-unit id="55590025c27353d8a373860de047b5dce37dba23" translate="yes" xml:space="preserve">
          <source>Pod::Simple::Checker -- check the Pod syntax of a document</source>
          <target state="translated">Pod :: Simple :: Checker-문서의 Pod 구문을 확인합니다</target>
        </trans-unit>
        <trans-unit id="b74f1729aad6ae1a22d920544a38e42cdf81b6d7" translate="yes" xml:space="preserve">
          <source>Pod::Simple::Debug</source>
          <target state="translated">Pod::Simple::Debug</target>
        </trans-unit>
        <trans-unit id="fa67e2158a0a94760ae209d78cc2c60c328cfd2a" translate="yes" xml:space="preserve">
          <source>Pod::Simple::Debug -- put Pod::Simple into trace/debug mode</source>
          <target state="translated">포드 :: 단순 :: 디버그-포드 :: 단순을 추적 / 디버그 모드로 전환</target>
        </trans-unit>
        <trans-unit id="c186101b5cf38096df66f1dfcd5544f7e2c30c6c" translate="yes" xml:space="preserve">
          <source>Pod::Simple::DumpAsText</source>
          <target state="translated">Pod::Simple::DumpAsText</target>
        </trans-unit>
        <trans-unit id="c3c292397a980ed71b52c2ff0898634dee25e619" translate="yes" xml:space="preserve">
          <source>Pod::Simple::DumpAsText -- dump Pod-parsing events as text</source>
          <target state="translated">포드 :: Simple :: DumpAsText-포드 파싱 이벤트를 텍스트로 덤프</target>
        </trans-unit>
        <trans-unit id="cc35fcc6b860e53e9fba03174336a15b24d3e20e" translate="yes" xml:space="preserve">
          <source>Pod::Simple::DumpAsXML</source>
          <target state="translated">Pod::Simple::DumpAsXML</target>
        </trans-unit>
        <trans-unit id="373b728991f6282ba763bd2a10793d147d39c8ce" translate="yes" xml:space="preserve">
          <source>Pod::Simple::DumpAsXML -- turn Pod into XML</source>
          <target state="translated">Pod :: Simple :: DumpAsXML-포드를 XML로 변환</target>
        </trans-unit>
        <trans-unit id="9f6b85c1362b8bcf343570ad01e881211977b269" translate="yes" xml:space="preserve">
          <source>Pod::Simple::DumpAsXML inherits methods from &lt;a href=&quot;../simple&quot;&gt;Pod::Simple&lt;/a&gt;.</source>
          <target state="translated">Pod :: Simple :: DumpAsXML은 &lt;a href=&quot;../simple&quot;&gt;Pod :: Simple의&lt;/a&gt; 메소드를 상속합니다 .</target>
        </trans-unit>
        <trans-unit id="02b3f87b1932c51400c8b115e4f1ba0a1b176a04" translate="yes" xml:space="preserve">
          <source>Pod::Simple::DumpAsXML inherits methods from &lt;a href=&quot;Pod::Simple&quot;&gt;Pod::Simple&lt;/a&gt;.</source>
          <target state="translated">Pod :: Simple :: DumpAsXML은 &lt;a href=&quot;Pod::Simple&quot;&gt;Pod :: Simple&lt;/a&gt; 에서 메서드를 상속합니다 .</target>
        </trans-unit>
        <trans-unit id="a26787ab4cbd9b5d37d67ecda1faa021db04bcda" translate="yes" xml:space="preserve">
          <source>Pod::Simple::DumpAsXML is a subclass of &lt;a href=&quot;../simple&quot;&gt;Pod::Simple&lt;/a&gt; that parses Pod and turns it into indented and wrapped XML. This class is of interest to people writing Pod formatters based on Pod::Simple.</source>
          <target state="translated">Pod :: Simple :: DumpAsXML은 Pod :: Simple의 하위 클래스로 &lt;a href=&quot;../simple&quot;&gt;Pod&lt;/a&gt; 를 구문 분석하여 들여 쓰기 및 래핑 된 XML로 변환합니다. 이 클래스는 Pod :: Simple을 기반으로 Pod 포맷터를 작성하는 사람들에게 관심이 있습니다.</target>
        </trans-unit>
        <trans-unit id="3bc6aef0753a906554fe52605727fcd96d63c2f8" translate="yes" xml:space="preserve">
          <source>Pod::Simple::DumpAsXML is a subclass of &lt;a href=&quot;Pod::Simple&quot;&gt;Pod::Simple&lt;/a&gt; that parses Pod and turns it into indented and wrapped XML. This class is of interest to people writing Pod formatters based on Pod::Simple.</source>
          <target state="translated">Pod :: Simple :: DumpAsXML은 &lt;a href=&quot;Pod::Simple&quot;&gt;Pod&lt;/a&gt; 를 파싱하고 들여 쓰기 및 래핑 된 XML로 변환하는 Pod :: Simple 의 하위 클래스입니다 . 이 클래스는 Pod :: Simple을 기반으로 Pod 포맷터를 작성하는 사람들에게 유용합니다.</target>
        </trans-unit>
        <trans-unit id="18e3cad548b1d58d72a35d1b97df012592abca6a" translate="yes" xml:space="preserve">
          <source>Pod::Simple::HTML</source>
          <target state="translated">Pod::Simple::HTML</target>
        </trans-unit>
        <trans-unit id="9ba84d76002e656d6a841be7c0fa1ddaf7a15278" translate="yes" xml:space="preserve">
          <source>Pod::Simple::HTML - convert Pod to HTML</source>
          <target state="translated">포드 : : 단순 : : HTML-포드를 HTML로 변환</target>
        </trans-unit>
        <trans-unit id="4f616c51b55e2caed067f512efd6be765988729c" translate="yes" xml:space="preserve">
          <source>Pod::Simple::HTMLBatch</source>
          <target state="translated">Pod::Simple::HTMLBatch</target>
        </trans-unit>
        <trans-unit id="b714f30d97375e99cc3dc025fe21efb3928ffb30" translate="yes" xml:space="preserve">
          <source>Pod::Simple::HTMLBatch - convert several Pod files to several HTML files</source>
          <target state="translated">포드 : : 단순 : : HTMLBatch-여러 포드 파일을 여러 HTML 파일로 변환</target>
        </trans-unit>
        <trans-unit id="ffc09ddc7418e3e9cf3efb9e134eaaaeff9f17d4" translate="yes" xml:space="preserve">
          <source>Pod::Simple::JustPod</source>
          <target state="translated">Pod::Simple::JustPod</target>
        </trans-unit>
        <trans-unit id="b431e9b8673f61ccfc1e9efe125ce7dfc3efc755" translate="yes" xml:space="preserve">
          <source>Pod::Simple::JustPod -- just the Pod, the whole Pod, and nothing but the Pod</source>
          <target state="translated">Pod :: Simple :: JustPod-Pod 만, 전체 Pod, Pod 만</target>
        </trans-unit>
        <trans-unit id="eddaf844c75beb11321838c4f34da6339343ef39" translate="yes" xml:space="preserve">
          <source>Pod::Simple::JustPod was developed by John SJ Anderson &lt;code&gt;genehack@genehack.org&lt;/code&gt;, with contributions from Karl Williamson &lt;code&gt;khw@cpan.org&lt;/code&gt;.</source>
          <target state="translated">Pod :: Simple :: JustPod는 Karl Williamson &lt;code&gt;khw@cpan.org&lt;/code&gt; 의 기여와 함께 John SJ Anderson &lt;code&gt;genehack@genehack.org&lt;/code&gt; 에 의해 개발되었습니다 .</target>
        </trans-unit>
        <trans-unit id="c7d427af968fe5b5f7cabfdd1b7609d966dc62cc" translate="yes" xml:space="preserve">
          <source>Pod::Simple::LinkSection</source>
          <target state="translated">Pod::Simple::LinkSection</target>
        </trans-unit>
        <trans-unit id="565e4c6e11a593b50f5257b1a4aee37099620372" translate="yes" xml:space="preserve">
          <source>Pod::Simple::LinkSection -- represent &quot;section&quot; attributes of L codes</source>
          <target state="translated">Pod :: Simple :: LinkSection-L 코드의 &quot;섹션&quot;속성을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="04192c711189c3d3745e9766bf472b32950a1f73" translate="yes" xml:space="preserve">
          <source>Pod::Simple::Methody</source>
          <target state="translated">Pod::Simple::Methody</target>
        </trans-unit>
        <trans-unit id="0ca575b26347f441076a6fd1a824c79b25cf2619" translate="yes" xml:space="preserve">
          <source>Pod::Simple::Methody -- turn Pod::Simple events into method calls</source>
          <target state="translated">Pod :: Simple :: Methody-Pod :: Simple 이벤트를 메서드 호출로 전환</target>
        </trans-unit>
        <trans-unit id="7aa02a3f7b5768f2a6ec877904dc7ab387a3061a" translate="yes" xml:space="preserve">
          <source>Pod::Simple::PullParser</source>
          <target state="translated">Pod::Simple::PullParser</target>
        </trans-unit>
        <trans-unit id="ea0c112c9214628c826e97034dffc164b33f6a82" translate="yes" xml:space="preserve">
          <source>Pod::Simple::PullParser -- a pull-parser interface to parsing Pod</source>
          <target state="translated">Pod :: Simple :: PullParser-포드 파싱을위한 풀 파서 인터페이스</target>
        </trans-unit>
        <trans-unit id="070ea3cf235fa0c5ea455a6107c6b1c28503ff41" translate="yes" xml:space="preserve">
          <source>Pod::Simple::PullParserEndToken</source>
          <target state="translated">Pod::Simple::PullParserEndToken</target>
        </trans-unit>
        <trans-unit id="0e20ea7a70dab49b1f0f66e63f1a06a2f448b097" translate="yes" xml:space="preserve">
          <source>Pod::Simple::PullParserEndToken -- end-tokens from Pod::Simple::PullParser</source>
          <target state="translated">Pod :: Simple :: PullParserEndToken-Pod :: Simple :: PullParser의 엔드 토큰</target>
        </trans-unit>
        <trans-unit id="11aea837de023672a7a9d2518ea0e8e11a95f00a" translate="yes" xml:space="preserve">
          <source>Pod::Simple::PullParserStartToken</source>
          <target state="translated">Pod::Simple::PullParserStartToken</target>
        </trans-unit>
        <trans-unit id="d6244e584441e2b0f907fb0ffecde2defcc17cae" translate="yes" xml:space="preserve">
          <source>Pod::Simple::PullParserStartToken -- start-tokens from Pod::Simple::PullParser</source>
          <target state="translated">Pod :: Simple :: PullParserStartToken-Pod :: Simple :: PullParser의 시작 토큰</target>
        </trans-unit>
        <trans-unit id="41b32f7393c26878ea6e6764691f6ab8d4cfed16" translate="yes" xml:space="preserve">
          <source>Pod::Simple::PullParserTextToken</source>
          <target state="translated">Pod::Simple::PullParserTextToken</target>
        </trans-unit>
        <trans-unit id="85a00c2aa32007d196ff05d09a358b591b60a9d7" translate="yes" xml:space="preserve">
          <source>Pod::Simple::PullParserTextToken -- text-tokens from Pod::Simple::PullParser</source>
          <target state="translated">Pod :: Simple :: PullParserTextToken-Pod :: Simple :: PullParser의 텍스트 토큰</target>
        </trans-unit>
        <trans-unit id="af99c7c32db60fbc39ffa01aa36158222378886f" translate="yes" xml:space="preserve">
          <source>Pod::Simple::PullParserToken</source>
          <target state="translated">Pod::Simple::PullParserToken</target>
        </trans-unit>
        <trans-unit id="83ed709c868d2cc4eff657e59deb01ec607246dd" translate="yes" xml:space="preserve">
          <source>Pod::Simple::PullParserToken -- tokens from Pod::Simple::PullParser</source>
          <target state="translated">Pod :: Simple :: PullParserToken-Pod :: Simple :: PullParser의 토큰</target>
        </trans-unit>
        <trans-unit id="cd8b2814ae13bcab0bbe442896010091755dc3df" translate="yes" xml:space="preserve">
          <source>Pod::Simple::RTF</source>
          <target state="translated">Pod::Simple::RTF</target>
        </trans-unit>
        <trans-unit id="b3241001e4eb1949e4d0740b263d2fb59490fadf" translate="yes" xml:space="preserve">
          <source>Pod::Simple::RTF -- format Pod as RTF</source>
          <target state="translated">포드 :: 간단한 :: RTF-RTF 형식의 포드</target>
        </trans-unit>
        <trans-unit id="7cec88f41732497c431990231ff60d0d97239c5a" translate="yes" xml:space="preserve">
          <source>Pod::Simple::Search</source>
          <target state="translated">Pod::Simple::Search</target>
        </trans-unit>
        <trans-unit id="e1ea8fdb67de63159764e718db4fbefbb27c467f" translate="yes" xml:space="preserve">
          <source>Pod::Simple::Search - find POD documents in directory trees</source>
          <target state="translated">Pod :: Simple :: Search-디렉토리 트리에서 POD 문서 찾기</target>
        </trans-unit>
        <trans-unit id="62021a054d37a5d7fcf8c80130c7b291785a01cf" translate="yes" xml:space="preserve">
          <source>Pod::Simple::Search will by default internally make an assumption based on the underlying filesystem where the class file is found whether it is case insensitive or not.</source>
          <target state="translated">Pod :: Simple :: Search는 기본적으로 대소 문자 구분 여부에 관계없이 클래스 파일이있는 기본 파일 시스템을 기반으로 내부적으로 가정합니다.</target>
        </trans-unit>
        <trans-unit id="4bec063b1fe4a8b7088da5083ba7437146419ca6" translate="yes" xml:space="preserve">
          <source>Pod::Simple::SimpleTree</source>
          <target state="translated">Pod::Simple::SimpleTree</target>
        </trans-unit>
        <trans-unit id="eea909e0d762cb819c8aa8330fdb9ba6a9be4d16" translate="yes" xml:space="preserve">
          <source>Pod::Simple::SimpleTree -- parse Pod into a simple parse tree</source>
          <target state="translated">포드 :: Simple :: SimpleTree-포드를 간단한 구문 분석 트리로 파싱</target>
        </trans-unit>
        <trans-unit id="5da91d8d6431a8c01e6c864a85dab3bf9cec1f3e" translate="yes" xml:space="preserve">
          <source>Pod::Simple::Subclassing</source>
          <target state="translated">Pod::Simple::Subclassing</target>
        </trans-unit>
        <trans-unit id="7f952b92af53e1429b73f0a13edd27e756189634" translate="yes" xml:space="preserve">
          <source>Pod::Simple::Subclassing -- write a formatter as a Pod::Simple subclass</source>
          <target state="translated">Pod :: Simple :: Subclassing-포맷터를 Pod :: Simple 하위 클래스로 작성</target>
        </trans-unit>
        <trans-unit id="b18ba6877611e38d5ebeca357ca45de50b3d8f5a" translate="yes" xml:space="preserve">
          <source>Pod::Simple::Text</source>
          <target state="translated">Pod::Simple::Text</target>
        </trans-unit>
        <trans-unit id="753e56ce7ac1a58ad889fddf470a50b96539c6da" translate="yes" xml:space="preserve">
          <source>Pod::Simple::Text -- format Pod as plaintext</source>
          <target state="translated">포드 :: 간단한 :: 텍스트-일반 텍스트로 포드 형식</target>
        </trans-unit>
        <trans-unit id="8d8c6d10cf65bae9e13056ddeb8c6d2c2a890ff6" translate="yes" xml:space="preserve">
          <source>Pod::Simple::TextContent</source>
          <target state="translated">Pod::Simple::TextContent</target>
        </trans-unit>
        <trans-unit id="7e136e15cf39e6850f0880e93ca8c30b3d62e90f" translate="yes" xml:space="preserve">
          <source>Pod::Simple::TextContent -- get the text content of Pod</source>
          <target state="translated">Pod :: Simple :: TextContent-Pod의 텍스트 내용을 얻습니다.</target>
        </trans-unit>
        <trans-unit id="c87067a51be41176018a7a02a831c44466936f6a" translate="yes" xml:space="preserve">
          <source>Pod::Simple::XHTML</source>
          <target state="translated">Pod::Simple::XHTML</target>
        </trans-unit>
        <trans-unit id="259f074470a9013b0eea26649d0b91cffcd63426" translate="yes" xml:space="preserve">
          <source>Pod::Simple::XHTML -- format Pod as validating XHTML</source>
          <target state="translated">포드 :: 간단한 :: XHTML-XHTML을 검증하는 형식의 포드</target>
        </trans-unit>
        <trans-unit id="fcd3e6ec8f3899adef753786dbd1ab596eb81dbe" translate="yes" xml:space="preserve">
          <source>Pod::Simple::XHTML offers a number of methods that modify the format of the HTML output. Call these after creating the parser object, but before the call to &lt;code&gt;parse_file&lt;/code&gt; :</source>
          <target state="translated">Pod :: Simple :: XHTML은 HTML 출력 형식을 수정하는 여러 가지 방법을 제공합니다. 파서 객체를 생성 한 후 &lt;code&gt;parse_file&lt;/code&gt; 을 호출하기 전에 다음을 호출 하십시오 .</target>
        </trans-unit>
        <trans-unit id="3e5485140fcfa8d3ea4729639fdcbb80ddfb24e3" translate="yes" xml:space="preserve">
          <source>Pod::Simple::XHTML offers a number of methods that modify the format of the HTML output. Call these after creating the parser object, but before the call to &lt;code&gt;parse_file&lt;/code&gt;:</source>
          <target state="translated">Pod :: Simple :: XHTML은 HTML 출력의 형식을 수정하는 여러 메서드를 제공합니다. 파서 객체를 만든 후 &lt;code&gt;parse_file&lt;/code&gt; 을 호출하기 전에 다음을 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="951593ce225e4b7953c95143c2dd0fc68256192b" translate="yes" xml:space="preserve">
          <source>Pod::Simple::XMLOutStream</source>
          <target state="translated">Pod::Simple::XMLOutStream</target>
        </trans-unit>
        <trans-unit id="2c8ebe8007a83f6db16cd28e4028774e22050e1e" translate="yes" xml:space="preserve">
          <source>Pod::Simple::XMLOutStream -- turn Pod into XML</source>
          <target state="translated">포드 :: 간단한 :: XMLOutStream-포드를 XML로 변환</target>
        </trans-unit>
        <trans-unit id="5a6dda8cf65a6f2f753c09f42fcc82ca0f054678" translate="yes" xml:space="preserve">
          <source>Pod::Simple::XMLOutStream inherits methods from &lt;a href=&quot;../simple&quot;&gt;Pod::Simple&lt;/a&gt;.</source>
          <target state="translated">Pod :: Simple :: XMLOutStream은 &lt;a href=&quot;../simple&quot;&gt;Pod :: Simple&lt;/a&gt; 에서 메소드를 상속합니다. .</target>
        </trans-unit>
        <trans-unit id="d5fe61554e18ee37710a20ddffd872e1657ed8e9" translate="yes" xml:space="preserve">
          <source>Pod::Simple::XMLOutStream inherits methods from &lt;a href=&quot;Pod::Simple&quot;&gt;Pod::Simple&lt;/a&gt;.</source>
          <target state="translated">Pod :: Simple :: XMLOutStream은 &lt;a href=&quot;Pod::Simple&quot;&gt;Pod :: Simple&lt;/a&gt; 에서 메서드를 상속합니다 .</target>
        </trans-unit>
        <trans-unit id="b5393b17d53eb5cd3e02f552010cdbdc23dd6294" translate="yes" xml:space="preserve">
          <source>Pod::Simple::XMLOutStream is a subclass of &lt;a href=&quot;../simple&quot;&gt;Pod::Simple&lt;/a&gt; that parses Pod and turns it into XML.</source>
          <target state="translated">Pod :: Simple :: XMLOutStream은 &lt;a href=&quot;../simple&quot;&gt;Pod&lt;/a&gt; 를 구문 분석하여 XML로 변환하는 Pod :: Simple 의 하위 클래스입니다 .</target>
        </trans-unit>
        <trans-unit id="6afeca633f44df878f3c6c4af1eb0dc5fc515050" translate="yes" xml:space="preserve">
          <source>Pod::Simple::XMLOutStream is a subclass of &lt;a href=&quot;Pod::Simple&quot;&gt;Pod::Simple&lt;/a&gt; that parses Pod and turns it into XML.</source>
          <target state="translated">Pod :: Simple :: XMLOutStream은 &lt;a href=&quot;Pod::Simple&quot;&gt;Pod&lt;/a&gt; 를 파싱하고 XML로 변환하는 Pod :: Simple 의 하위 클래스입니다 .</target>
        </trans-unit>
        <trans-unit id="4c7f94950bba4ec35927384f3ba52a47b2d388e7" translate="yes" xml:space="preserve">
          <source>Pod::Text</source>
          <target state="translated">Pod::Text</target>
        </trans-unit>
        <trans-unit id="e6e584d20fd5725d4428861f69402acfdd834bf0" translate="yes" xml:space="preserve">
          <source>Pod::Text - Convert POD data to formatted ASCII text</source>
          <target state="translated">Pod :: Text-POD 데이터를 형식이 지정된 ASCII 텍스트로 변환</target>
        </trans-unit>
        <trans-unit id="ab9108e9dff7e6acb11c45245829f8db58a22933" translate="yes" xml:space="preserve">
          <source>Pod::Text - Convert POD data to formatted text</source>
          <target state="translated">Pod :: Text-POD 데이터를 서식있는 텍스트로 변환</target>
        </trans-unit>
        <trans-unit id="519614764ccb1ff38de936b78f067c16eca0fe48" translate="yes" xml:space="preserve">
          <source>Pod::Text is a module that can convert documentation in the POD format (the preferred language for documenting Perl) into formatted ASCII. It uses no special formatting controls or codes whatsoever, and its output is therefore suitable for nearly any device.</source>
          <target state="translated">Pod :: Text는 POD 형식 (Perl 문서화에 선호되는 언어)의 문서를 형식이 지정된 ASCII로 변환 할 수있는 모듈입니다. 특별한 형식 지정 컨트롤이나 코드를 사용하지 않으므로 출력은 거의 모든 장치에 적합합니다.</target>
        </trans-unit>
        <trans-unit id="d7ae0431b95823c9cdaef0a1a00879b188191692" translate="yes" xml:space="preserve">
          <source>Pod::Text is a module that can convert documentation in the POD format (the preferred language for documenting Perl) into formatted text. It uses no special formatting controls or codes whatsoever, and its output is therefore suitable for nearly any device.</source>
          <target state="translated">Pod :: Text는 POD 형식 (Perl을 문서화하는 데 선호되는 언어)의 문서를 형식화 된 텍스트로 변환 할 수있는 모듈입니다. 특별한 포맷팅 컨트롤이나 코드를 전혀 사용하지 않기 때문에 출력은 거의 모든 장치에 적합합니다.</target>
        </trans-unit>
        <trans-unit id="3b000e1532343476a2f005325a7e1d5a7cc21c94" translate="yes" xml:space="preserve">
          <source>Pod::Text::Color</source>
          <target state="translated">Pod::Text::Color</target>
        </trans-unit>
        <trans-unit id="481fceb7f0a093b935ebdf609b3ea4b2ecf12680" translate="yes" xml:space="preserve">
          <source>Pod::Text::Color - Convert POD data to formatted color ASCII text</source>
          <target state="translated">Pod :: Text :: Color-POD 데이터를 형식이 지정된 색상 ASCII 텍스트로 변환</target>
        </trans-unit>
        <trans-unit id="77f334b564bfb0176f5034dad3905349c4003fa8" translate="yes" xml:space="preserve">
          <source>Pod::Text::Color is a simple subclass of Pod::Text that highlights output text using ANSI color escape sequences. Apart from the color, it in all ways functions like Pod::Text. See &lt;a href=&quot;../text&quot;&gt;Pod::Text&lt;/a&gt; for details and available options.</source>
          <target state="translated">Pod :: Text :: Color는 ANSI 색상 이스케이프 시퀀스를 사용하여 출력 텍스트를 강조 표시하는 Pod :: Text의 간단한 하위 클래스입니다. 색상 외에도 모든 방식으로 Pod :: Text와 같은 기능을 수행합니다. 자세한 내용과 사용 가능한 옵션 은 &lt;a href=&quot;../text&quot;&gt;포드 :: 텍스트&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="efbe00bb611152db236e4b619961328e4de0f95f" translate="yes" xml:space="preserve">
          <source>Pod::Text::Color is a simple subclass of Pod::Text that highlights output text using ANSI color escape sequences. Apart from the color, it in all ways functions like Pod::Text. See &lt;a href=&quot;Pod::Text&quot;&gt;Pod::Text&lt;/a&gt; for details and available options.</source>
          <target state="translated">Pod :: Text :: Color는 ANSI 색상 이스케이프 시퀀스를 사용하여 출력 텍스트를 강조 표시하는 Pod :: Text의 간단한 하위 클래스입니다. 색상 외에도 모든면에서 Pod :: Text와 같은 기능을합니다. 자세한 내용과 사용 가능한 옵션 은 &lt;a href=&quot;Pod::Text&quot;&gt;Pod :: Text&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="1bbee340278a2ff3fc6d6d87793be1b3326a3164" translate="yes" xml:space="preserve">
          <source>Pod::Text::Overstrike</source>
          <target state="translated">Pod::Text::Overstrike</target>
        </trans-unit>
        <trans-unit id="6f979e30783784683adf1aac75e360359ed243cf" translate="yes" xml:space="preserve">
          <source>Pod::Text::Overstrike - Convert POD data to formatted overstrike text</source>
          <target state="translated">Pod :: Text :: Overstrike-POD 데이터를 형식화 된 오버 스트라이크 텍스트로 변환</target>
        </trans-unit>
        <trans-unit id="29be1312d16601e968f895f7174874218cfa222e" translate="yes" xml:space="preserve">
          <source>Pod::Text::Overstrike is a simple subclass of Pod::Text that highlights output text using overstrike sequences, in a manner similar to nroff. Characters in bold text are overstruck (character, backspace, character) and characters in underlined text are converted to overstruck underscores (underscore, backspace, character). This format was originally designed for hard-copy terminals and/or line printers, yet is readable on soft-copy (CRT) terminals.</source>
          <target state="translated">Pod :: Text :: Overstrike는 Pod :: Text의 간단한 하위 클래스로 nroff와 비슷한 방식으로 오버 스트라이크 시퀀스를 사용하여 출력 텍스트를 강조 표시합니다. 굵은 체 텍스트의 문자는 과도하게 표시되고 (문자, 백 스페이스, 문자) 밑줄이있는 텍스트의 문자는 과도하게 강조된 밑줄 (밑줄, 백 스페이스, 문자)로 변환됩니다. 이 형식은 원래 하드 카피 터미널 및 / 또는 라인 프린터 용으로 설계되었지만 CRT (소프트 카피) 터미널에서 읽을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7195453df8fc7b6eab0965ce075c75610190c6a6" translate="yes" xml:space="preserve">
          <source>Pod::Text::Termcap</source>
          <target state="translated">Pod::Text::Termcap</target>
        </trans-unit>
        <trans-unit id="22f155581256a8a1fab5e33d67ab86301d7bc4cd" translate="yes" xml:space="preserve">
          <source>Pod::Text::Termcap - Convert POD data to ASCII text with format escapes</source>
          <target state="translated">Pod :: Text :: Termcap-형식 이스케이프를 사용하여 POD 데이터를 ASCII 텍스트로 변환</target>
        </trans-unit>
        <trans-unit id="4aec2a63ef082d360b91e6eb0afca126e8b2efc0" translate="yes" xml:space="preserve">
          <source>Pod::Text::Termcap is a simple subclass of Pod::Text that highlights output text using the correct termcap escape sequences for the current terminal. Apart from the format codes, it in all ways functions like Pod::Text. See &lt;a href=&quot;../text&quot;&gt;Pod::Text&lt;/a&gt; for details and available options.</source>
          <target state="translated">Pod :: Text :: Termcap은 현재 터미널에 대한 올바른 termcap 이스케이프 시퀀스를 사용하여 출력 텍스트를 강조 표시하는 Pod :: Text의 간단한 하위 클래스입니다. 형식 코드 외에도 모든 방법으로 Pod :: Text와 같은 기능을 수행합니다. 자세한 내용과 사용 가능한 옵션 은 &lt;a href=&quot;../text&quot;&gt;포드 :: 텍스트&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d2858aa68e07f4dd145d3fcb814f559d00a90436" translate="yes" xml:space="preserve">
          <source>Pod::Text::Termcap is a simple subclass of Pod::Text that highlights output text using the correct termcap escape sequences for the current terminal. Apart from the format codes, it in all ways functions like Pod::Text. See &lt;a href=&quot;Pod::Text&quot;&gt;Pod::Text&lt;/a&gt; for details and available options.</source>
          <target state="translated">Pod :: Text :: Termcap은 현재 터미널에 대한 올바른 termcap 이스케이프 시퀀스를 사용하여 출력 텍스트를 강조 표시하는 Pod :: Text의 간단한 하위 클래스입니다. 형식 코드를 제외하고는 모든면에서 Pod :: Text와 같은 기능을합니다. 자세한 내용과 사용 가능한 옵션 은 &lt;a href=&quot;Pod::Text&quot;&gt;Pod :: Text&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="01ead75c44533a688798cad50ab41fa8f303554d" translate="yes" xml:space="preserve">
          <source>Pod::Usage</source>
          <target state="translated">Pod::Usage</target>
        </trans-unit>
        <trans-unit id="b4dc8d5361b7e455072cf29ee34ca11a59abca9a" translate="yes" xml:space="preserve">
          <source>Pod::Usage - print a usage message from embedded pod documentation</source>
          <target state="translated">포드 :: 사용-내장 포드 설명서에서 사용 메시지 인쇄</target>
        </trans-unit>
        <trans-unit id="ce218f4b64ca779219ccdd981ed413ca8b202fdc" translate="yes" xml:space="preserve">
          <source>Pod::Usage uses &lt;a href=&quot;Pod::Simple&quot;&gt;Pod::Simple&lt;/a&gt;'s _handle_element_end() method to implement the section selection, and in case of verbosity &amp;lt; 2 it down-cases the all-caps headings to first capital letter and rest lowercase, and adds a colon/newline at the end of the headings, for better readability. Same for verbosity = 99.</source>
          <target state="translated">Pod :: Usage는 &lt;a href=&quot;Pod::Simple&quot;&gt;Pod :: Simple&lt;/a&gt; 의 _handle_element_end () 메서드를 사용하여 섹션 선택을 구현하고, verbosity &amp;lt;2 인 경우 모두 대문자 머리글을 첫 번째 대문자와 나머지 소문자로 다운 케이스하고 콜론 /을 추가합니다. 더 나은 가독성을 위해 제목 끝에 줄 바꿈을 추가하십시오. 상세도 = 99와 동일합니다.</target>
        </trans-unit>
        <trans-unit id="7ad7eae188bc449da645418942520b12991444b2" translate="yes" xml:space="preserve">
          <source>Pointer to a structure encapsulating the state of the parsing operation currently in progress. The pointer can be locally changed to perform a nested parse without interfering with the state of an outer parse. Individual members of &lt;code&gt;PL_parser&lt;/code&gt; have their own documentation.</source>
          <target state="translated">현재 진행중인 구문 분석 작업의 상태를 캡슐화하는 구조의 포인터. 외부 구문 분석 상태를 방해하지 않고 중첩 구문 분석을 수행하도록 포인터를 로컬로 변경할 수 있습니다. &lt;code&gt;PL_parser&lt;/code&gt; 의 개별 멤버는 자체 문서를 가지고 있습니다.</target>
        </trans-unit>
        <trans-unit id="569cfd3e6d40d0f45b19803b2cef265e9a1d1cb3" translate="yes" xml:space="preserve">
          <source>Pointer to the character following the physical end of the string (i.e. the &lt;code&gt;\0&lt;/code&gt; , if any).</source>
          <target state="translated">문자열의 물리적 끝을 따르는 문자를 가리 킵니다 (예 : &lt;code&gt;\0&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="f26443a6f326aa8e35a57bd9708b38b493031f37" translate="yes" xml:space="preserve">
          <source>Pointer to the character following the physical end of the string (i.e. the &lt;code&gt;\0&lt;/code&gt;, if any).</source>
          <target state="translated">문자열의 물리적 끝 다음에 오는 문자를 가리키는 포인터 (즉, &lt;code&gt;\0&lt;/code&gt; ,있는 경우).</target>
        </trans-unit>
        <trans-unit id="c7efb8f2f5c41fc448cd25b9357a4b637d7c3c35" translate="yes" xml:space="preserve">
          <source>Pointer to the linearisation function, described below.</source>
          <target state="translated">아래 설명 된 선형화 함수를 가리키는 포인터.</target>
        </trans-unit>
        <trans-unit id="93e37c8eb5980406ef58242eae9fe75acd07201b" translate="yes" xml:space="preserve">
          <source>Pointer to the per-subroutine peephole optimiser. This is a function that gets called at the end of compilation of a Perl subroutine (or equivalently independent piece of Perl code) to perform fixups of some ops and to perform small-scale optimisations. The function is called once for each subroutine that is compiled, and is passed, as sole parameter, a pointer to the op that is the entry point to the subroutine. It modifies the op tree in place.</source>
          <target state="translated">서브 루틴 별 틈 구멍 최적화 프로그램의 포인터. 이것은 일부 운영 체제의 수정을 수행하고 소규모 최적화를 수행하기 위해 Perl 서브 루틴 (또는 동등하게 독립적 인 Perl 코드) 컴파일 종료시 호출되는 함수입니다. 이 함수는 컴파일 된 각 서브 루틴마다 한 번씩 호출되며 서브 루틴의 진입 점 인 op에 대한 포인터를 단독 매개 변수로 전달합니다. op 트리를 제자리에서 수정합니다.</target>
        </trans-unit>
        <trans-unit id="d2e62507cb5b989fbd3aba1b8f6ac801e56c7fb1" translate="yes" xml:space="preserve">
          <source>Pointer to the physical start of the string.</source>
          <target state="translated">문자열의 물리적 시작을 가리키는 포인터.</target>
        </trans-unit>
        <trans-unit id="24a8aad8d082073a41e895d4c5a7e7f9947568de" translate="yes" xml:space="preserve">
          <source>Pointer to the position in the string where matching should start; it might not be equal to &lt;code&gt;strbeg&lt;/code&gt; (for example in a later iteration of &lt;code&gt;/.../g&lt;/code&gt; ).</source>
          <target state="translated">일치가 시작되어야하는 문자열의 위치를 ​​가리키는 포인터. 그와 동일 할 수도 있고 그렇지 않을 수도 &lt;code&gt;strbeg&lt;/code&gt; (이후 반복에서 예 &lt;code&gt;/.../g&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="fc9305ad14128dd61fc34d5fec4f93e8c59716ad" translate="yes" xml:space="preserve">
          <source>Pointer to the position in the string where matching should start; it might not be equal to &lt;code&gt;strbeg&lt;/code&gt; (for example in a later iteration of &lt;code&gt;/.../g&lt;/code&gt;).</source>
          <target state="translated">문자열에서 일치가 시작되어야하는 위치를 가리키는 포인터. 그와 동일 할 수도 있고 그렇지 않을 수도 &lt;code&gt;strbeg&lt;/code&gt; (이후 반복에서 예 &lt;code&gt;/.../g&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="5f83ff7c09e64b6014d200a49cf4d57b3fe2a3b7" translate="yes" xml:space="preserve">
          <source>Pointer to the recursive peephole optimiser. This is a function that gets called at the end of compilation of a Perl subroutine (or equivalently independent piece of Perl code) to perform fixups of some ops and to perform small-scale optimisations. The function is called once for each chain of ops linked through their &lt;code&gt;op_next&lt;/code&gt; fields; it is recursively called to handle each side chain. It is passed, as sole parameter, a pointer to the op that is at the head of the chain. It modifies the op tree in place.</source>
          <target state="translated">재귀 구멍 구멍 옵티 마이저를 가리키는 포인터. 이것은 일부 운영 체제의 수정을 수행하고 소규모 최적화를 수행하기 위해 Perl 서브 루틴 (또는 동등하게 독립적 인 Perl 코드) 컴파일 종료시 호출되는 함수입니다. 이 함수는 &lt;code&gt;op_next&lt;/code&gt; 필드를 통해 연결된 각 op 체인에 대해 한 번 호출 됩니다. 각 사이드 체인을 처리하기 위해 재귀 적으로 호출됩니다. 체인의 헤드에있는 op에 대한 포인터를 유일한 매개 변수로 전달합니다. op 트리를 제자리에서 수정합니다.</target>
        </trans-unit>
        <trans-unit id="1b15de7f05dc81e7a10d8422ae41b092aa35ff88" translate="yes" xml:space="preserve">
          <source>Pointer-To-Integer and Integer-To-Pointer</source>
          <target state="translated">포인터 대 정수 및 정수 대 포인터</target>
        </trans-unit>
        <trans-unit id="8db4543231fbc881b475cb920918beb06e6957b1" translate="yes" xml:space="preserve">
          <source>Pointers for How to Use Them</source>
          <target state="translated">그것들을 사용하는 방법에 대한 포인터</target>
        </trans-unit>
        <trans-unit id="d2230d33a0d37bef7c5428bbaebaf857455229dd" translate="yes" xml:space="preserve">
          <source>Points directly to the body of the &lt;a href=&quot;#PL_comppad&quot;&gt;&quot;PL_comppad&quot;&lt;/a&gt; array. (I.e., this is &lt;code&gt;PadARRAY(PL_comppad)&lt;/code&gt;.)</source>
          <target state="translated">&lt;a href=&quot;#PL_comppad&quot;&gt;&quot;PL_comppad&quot;&lt;/a&gt; 배열 의 본문을 직접 가리 킵니다 . (즉, &lt;code&gt;PadARRAY(PL_comppad)&lt;/code&gt; 입니다.)</target>
        </trans-unit>
        <trans-unit id="9d0e53b7caa90905a98f7bada48b61cffae6dfc0" translate="yes" xml:space="preserve">
          <source>Points directly to the body of the &lt;a href=&quot;#PL_comppad&quot;&gt;PL_comppad&lt;/a&gt; array. (I.e., this is &lt;code&gt;PAD_ARRAY(PL_comppad)&lt;/code&gt; .)</source>
          <target state="translated">&lt;a href=&quot;#PL_comppad&quot;&gt;PL_comppad&lt;/a&gt; 배열 의 본문을 직접 가리 킵니다 . (즉, 이것은 &lt;code&gt;PAD_ARRAY(PL_comppad)&lt;/code&gt; 입니다.)</target>
        </trans-unit>
        <trans-unit id="cd50ccbc12c1ecc8379096a1e5a3ea405480427c" translate="yes" xml:space="preserve">
          <source>Points to note this time are</source>
          <target state="translated">이번 주목할 점은</target>
        </trans-unit>
        <trans-unit id="a1ba2b16bcbd7c4705abb0e0545c7340c416117e" translate="yes" xml:space="preserve">
          <source>Points to note this time:</source>
          <target state="translated">이번주의 사항 :</target>
        </trans-unit>
        <trans-unit id="7f6158e808f6832883a61fff6f7473e7ffa8d937" translate="yes" xml:space="preserve">
          <source>Points to note:</source>
          <target state="translated">참고 사항 :</target>
        </trans-unit>
        <trans-unit id="1bbd752ae8b2d8dd16a7b7697a38f3cb2e507749" translate="yes" xml:space="preserve">
          <source>Points to the current position of lexing inside the lexer buffer. Characters around this point may be freely examined, within the range delimited by &lt;code&gt;SvPVX(&lt;a href=&quot;#PL_parser-%3Elinestr&quot;&gt;&quot;PL_parser-&amp;gt;linestr&quot;&lt;/a&gt;)&lt;/code&gt; and &lt;a href=&quot;#PL_parser-%3Ebufend&quot;&gt;&quot;PL_parser-&amp;gt;bufend&quot;&lt;/a&gt;. The octets of the buffer may be intended to be interpreted as either UTF-8 or Latin-1, as indicated by &lt;a href=&quot;#lex_bufutf8&quot;&gt;&quot;lex_bufutf8&quot;&lt;/a&gt;.</source>
          <target state="translated">렉서 버퍼 내 렉싱의 현재 위치를 가리 킵니다. 이 지점 주변의 문자는 &lt;code&gt;SvPVX(&lt;a href=&quot;#PL_parser-%3Elinestr&quot;&gt;&quot;PL_parser-&amp;gt;linestr&quot;&lt;/a&gt;)&lt;/code&gt; 및 &lt;a href=&quot;#PL_parser-%3Ebufend&quot;&gt;&quot;PL_parser-&amp;gt; bufend&quot;로&lt;/a&gt; 구분 된 범위 내에서 자유롭게 검사 할 수 있습니다 . 버퍼의 옥텟은 &lt;a href=&quot;#lex_bufutf8&quot;&gt;&quot;lex_bufutf8&quot;&lt;/a&gt; 로 표시된대로 UTF-8 또는 Latin-1로 해석되도록 의도 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="cd6843c94f87c938da300ec96118788e1ddfc762" translate="yes" xml:space="preserve">
          <source>Points to the current position of lexing inside the lexer buffer. Characters around this point may be freely examined, within the range delimited by &lt;code&gt;SvPVX(&lt;a href=&quot;#PL_parser-%3elinestr&quot;&gt;PL_parser-&amp;gt;linestr&lt;/a&gt;)&lt;/code&gt; and &lt;a href=&quot;#PL_parser-%3ebufend&quot;&gt;PL_parser-&amp;gt;bufend&lt;/a&gt;. The octets of the buffer may be intended to be interpreted as either UTF-8 or Latin-1, as indicated by &lt;a href=&quot;#lex_bufutf8&quot;&gt;lex_bufutf8&lt;/a&gt;.</source>
          <target state="translated">렉서 버퍼 내에서 렉싱의 현재 위치를 가리 킵니다. 이 지점 주변의 문자는 &lt;code&gt;SvPVX(&lt;a href=&quot;#PL_parser-%3elinestr&quot;&gt;PL_parser-&amp;gt;linestr&lt;/a&gt;)&lt;/code&gt; 및 &lt;a href=&quot;#PL_parser-%3ebufend&quot;&gt;PL_parser-&amp;gt; bufend로&lt;/a&gt; 구분 된 범위 내에서 자유롭게 검사 할 수 있습니다 . 버퍼의 옥텟은 &lt;a href=&quot;#lex_bufutf8&quot;&gt;lex_bufutf8&lt;/a&gt; 로 표시되는 UTF-8 또는 Latin-1로 해석되도록 의도 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1bb0820f4a550e8794d4bb990433e5c6f6edc648" translate="yes" xml:space="preserve">
          <source>Points to the start of the current line inside the lexer buffer. This is useful for indicating at which column an error occurred, and not much else. This must be updated by any lexing code that consumes a newline; the function &lt;a href=&quot;#lex_read_to&quot;&gt;&quot;lex_read_to&quot;&lt;/a&gt; handles this detail.</source>
          <target state="translated">렉서 버퍼 내에서 현재 줄의 시작을 가리 킵니다. 이는 오류가 발생한 열을 나타내는 데 유용합니다. 이것은 개행 문자를 사용하는 어휘 코드로 업데이트되어야합니다. &lt;a href=&quot;#lex_read_to&quot;&gt;&quot;lex_read_to&quot;&lt;/a&gt; 함수 가이 세부 사항을 처리합니다.</target>
        </trans-unit>
        <trans-unit id="466e9eed69ae31dedb4b4028316ec9e7f9681d76" translate="yes" xml:space="preserve">
          <source>Points to the start of the current line inside the lexer buffer. This is useful for indicating at which column an error occurred, and not much else. This must be updated by any lexing code that consumes a newline; the function &lt;a href=&quot;#lex_read_to&quot;&gt;lex_read_to&lt;/a&gt; handles this detail.</source>
          <target state="translated">렉서 버퍼 내에서 현재 줄의 시작을 가리 킵니다. 이것은 오류가 발생한 열을 나타내는 데 유용합니다. 이것은 개행을 소비하는 어휘 코드에 의해 갱신되어야합니다. &lt;a href=&quot;#lex_read_to&quot;&gt;lex_read_to&lt;/a&gt; 함수 는이 세부 사항을 처리합니다.</target>
        </trans-unit>
        <trans-unit id="6de0b0c656444c55bac48c2e467aa0f841083cdc" translate="yes" xml:space="preserve">
          <source>Poison</source>
          <target state="translated">Poison</target>
        </trans-unit>
        <trans-unit id="60326c7bc618b42717ee02bd88c572c7975b5c05" translate="yes" xml:space="preserve">
          <source>PoisonFree</source>
          <target state="translated">PoisonFree</target>
        </trans-unit>
        <trans-unit id="213cead1d3c3d191853846b8f588306499713f3d" translate="yes" xml:space="preserve">
          <source>PoisonNew</source>
          <target state="translated">PoisonNew</target>
        </trans-unit>
        <trans-unit id="921ff8ca38465c5b1707bafca4e8d140614024bb" translate="yes" xml:space="preserve">
          <source>PoisonWith</source>
          <target state="translated">PoisonWith</target>
        </trans-unit>
        <trans-unit id="7cba271b13a59766b27ccda79d87f5f8e1106365" translate="yes" xml:space="preserve">
          <source>PoisonWith(0xAB) for catching access to allocated but uninitialized memory.</source>
          <target state="translated">할당되었지만 초기화되지 않은 메모리에 대한 액세스를 포착하기위한 PoisonWith (0xAB).</target>
        </trans-unit>
        <trans-unit id="a5b29691b9f8fe361aff7b2c944f86e8960b1c90" translate="yes" xml:space="preserve">
          <source>PoisonWith(0xEF) for catching access to freed memory.</source>
          <target state="translated">사용 가능한 메모리에 액세스하기위한 PoisonWith (0xEF).</target>
        </trans-unit>
        <trans-unit id="50978bfdc443a56d15758e582ae96263dec24405" translate="yes" xml:space="preserve">
          <source>Poking around in the existing &lt;a href=&quot;Date::ICal&quot;&gt;Date::ICal&lt;/a&gt; tests, I found this in</source>
          <target state="translated">기존 &lt;a href=&quot;Date::ICal&quot;&gt;Date :: ICal&lt;/a&gt; 테스트를 살펴보면 다음에서 발견했습니다.</target>
        </trans-unit>
        <trans-unit id="a5f252f9719bb4092eedbac8a2fb53fbb1039f3c" translate="yes" xml:space="preserve">
          <source>Poking at Perl</source>
          <target state="translated">Perl에서 파고 들기</target>
        </trans-unit>
        <trans-unit id="5ff03b7273b1808e5ba852e230991bbf07da703c" translate="yes" xml:space="preserve">
          <source>Poland</source>
          <target state="translated">Poland</target>
        </trans-unit>
        <trans-unit id="1ebd3f7855634092b44032651f78d5bfb891f918" translate="yes" xml:space="preserve">
          <source>Policy on building prerequisites (follow, ask or ignore)?</source>
          <target state="translated">전제 조건 구축에 대한 정책 (팔로우, 요청 또는 무시)?</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
