<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="perl">
    <body>
      <group id="perl">
        <trans-unit id="9aa02419484468b5c8da416f7649906d690c9a05" translate="yes" xml:space="preserve">
          <source>There is the &quot;regnext&quot; from a given regop. This is the regop which is reached by jumping forward by the value of &lt;code&gt;NEXT_OFF()&lt;/code&gt;, or in a few cases for longer jumps by the &lt;code&gt;arg1&lt;/code&gt; field of the &lt;code&gt;regnode_1&lt;/code&gt; structure. The subroutine &lt;code&gt;regnext()&lt;/code&gt; handles this transparently. This is the logical successor of the node, which in some cases, like that of the &lt;code&gt;BRANCH&lt;/code&gt; regop, has special meaning.</source>
          <target state="translated">주어진 regop에서 &quot;regnext&quot;가 있습니다. 이것은 &lt;code&gt;NEXT_OFF()&lt;/code&gt; 값으로 앞으로 점프 하거나, 몇 가지 경우 &lt;code&gt;regnode_1&lt;/code&gt; 구조 의 &lt;code&gt;arg1&lt;/code&gt; 필드에 의해 더 긴 점프 를 통해 도달 하는 regop 입니다. 서브 루틴 &lt;code&gt;regnext()&lt;/code&gt; 는 이것을 투명하게 처리합니다. 이것은 &lt;code&gt;BRANCH&lt;/code&gt; regop 과 같은 경우에 특별한 의미를 갖는 노드의 논리적 후속 작업입니다 .</target>
        </trans-unit>
        <trans-unit id="d7e93b59e1cec82fb52bcc021241febda0271114" translate="yes" xml:space="preserve">
          <source>There is unfortunately no way to know whether the current emulator supports more than eight colors, which makes the choice of colors difficult. The most conservative choice is to use only the regular colors, which are at least displayed on all emulators. However, they will appear dark in sixteen-color terminal emulators, including most common emulators in UNIX X environments. If you know the display is one of those emulators, you may wish to use the bright variants instead. Even better, offer the user a way to configure the colors for a given application to fit their terminal emulator.</source>
          <target state="translated">불행히도 현재 에뮬레이터가 8 개 이상의 색상을 지원하는지 여부를 알 수있는 방법이 없으므로 색상 선택이 어렵습니다. 가장 보수적 인 선택은 최소한 모든 에뮬레이터에 표시되는 일반 색상 만 사용하는 것입니다. 그러나 UNIX X 환경에서 가장 일반적인 에뮬레이터를 포함하여 16 색 터미널 에뮬레이터에서는 어둡게 나타납니다. 디스플레이가 해당 에뮬레이터 중 하나 인 경우 밝은 변형을 대신 사용할 수 있습니다. 더 나은 방법은 사용자에게 터미널 에뮬레이터에 맞게 주어진 응용 프로그램의 색상을 구성 할 수있는 방법을 제공하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="695fd95569c58aad4ef775aef68eb765f2b01d11" translate="yes" xml:space="preserve">
          <source>There is whitespace at the beginning or the end of the contents of L&amp;lt;...&amp;gt;.</source>
          <target state="translated">L &amp;lt;...&amp;gt;의 내용의 시작 또는 끝에 공백이 있습니다.</target>
        </trans-unit>
        <trans-unit id="95a3b67169b42d8576a9c6b1e3142c83d233d818" translate="yes" xml:space="preserve">
          <source>There is/was a minor twist which makes this scheme fragile: what to do with DLLs loaded from</source>
          <target state="translated">이 구성표를 취약하게 만드는 약간의 왜곡이 있습니다 :에서로드 된 DLL로 수행 할 작업</target>
        </trans-unit>
        <trans-unit id="3224e59e3b76dce8e510a893a97e615a7718acdb" translate="yes" xml:space="preserve">
          <source>There may be a few system-dependent issues of concern to EBCDIC Perl programmers.</source>
          <target state="translated">EBCDIC Perl 프로그래머에게는 몇 가지 시스템 종속 문제가있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="74512965a00a9ef27998a0f76a590e7ca4e44a5a" translate="yes" xml:space="preserve">
          <source>There may be a slight performance decrease in the filetest operations when the filetest pragma is in effect, because checking bits is very cheap.</source>
          <target state="translated">비트 검사가 매우 저렴하기 때문에 filetest pragma가 적용되는 경우 filetest 작업의 성능이 약간 저하 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e5aefd712f7c17e18d56a8092421c803470327d8" translate="yes" xml:space="preserve">
          <source>There may be several other functions that have undefined behavior so this list shouldn't be considered complete.</source>
          <target state="translated">동작이 정의되지 않은 다른 함수가 여러 개있을 수 있으므로이 목록을 완전한 것으로 간주해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="8f2ee1e9e100e424daf008c17d87249cb596b7da" translate="yes" xml:space="preserve">
          <source>There might be padding bytes between the fields to align the fields - the bytes can be anything</source>
          <target state="translated">필드를 정렬하기 위해 필드 사이에 패딩 바이트가있을 수 있습니다. 바이트는 무엇이든 가능합니다.</target>
        </trans-unit>
        <trans-unit id="79bbf613c601df02685a1a8cf9fe8bf41a315d78" translate="yes" xml:space="preserve">
          <source>There must be no space after the &amp;lt;&amp;lt; part.</source>
          <target state="translated">&amp;lt;&amp;lt; 부분 뒤에 공백이 없어야합니다.</target>
        </trans-unit>
        <trans-unit id="0027f08c80bd3f13ec2adbb5ed6335850c27dec0" translate="yes" xml:space="preserve">
          <source>There needs to be at least a line separator after the end token.</source>
          <target state="translated">종료 토큰 뒤에 최소한 줄 구분 기호가 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="3c0e690d4d9216e705dc85028ebd1bac807095e9" translate="yes" xml:space="preserve">
          <source>There needs to be content inside E, L, and X formatting codes.</source>
          <target state="translated">E, L 및 X 형식 코드 내에 콘텐츠가 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="04957b7e4885516ed63d7f8370637e85be797dcc" translate="yes" xml:space="preserve">
          <source>There seem to be various problems in this long double implementation. If Configure detects this brokenness, it will disable the long double support. This can be overridden with explicit &lt;code&gt;-Duselongdouble&lt;/code&gt; (or &lt;code&gt;-Dusemorebits&lt;/code&gt;, which enables both long doubles and 64 bit integers). If you decide to enable long doubles, for most of the broken things Perl has implemented workarounds, but the handling of the special values infinity and NaN remains badly broken: for example infinity plus zero results in NaN.</source>
          <target state="translated">이 긴 이중 구현에는 여러 가지 문제가있는 것 같습니다. Configure에서 이러한 손상을 감지하면 긴 이중 지원이 비활성화됩니다. 이것은 명시 적 &lt;code&gt;-Duselongdouble&lt;/code&gt; (또는 long double과 64 비트 정수를 모두 활성화하는 &lt;code&gt;-Dusemorebits&lt;/code&gt; ) 으로 재정의 할 수 있습니다 . long double을 사용하기로 결정한 경우 Perl은 대부분의 깨진 항목에 대해 해결 방법을 구현했지만 특수 값 infinity 및 NaN의 처리는 심하게 깨져 있습니다. 예를 들어 infinity plus 0은 NaN이됩니다.</target>
        </trans-unit>
        <trans-unit id="8da2d0d0ae5db5c30555083a00bfa8e94e394bba" translate="yes" xml:space="preserve">
          <source>There seem to be various problems in this long double implementation. If Configure detects this brokenness, it will disable the long double support. This can be overriden with explicit &lt;code&gt;-Duselongdouble&lt;/code&gt; (or &lt;code&gt;-Dusemorebits&lt;/code&gt; , which enables both long doubles and 64 bit integers). If you decide to enable long doubles, for most of the broken things Perl has implemented workarounds, but the handling of the special values infinity and NaN remains badly broken: for example infinity plus zero results in NaN.</source>
          <target state="translated">이 긴 이중 구현에는 다양한 문제가있는 것 같습니다. Configure가이 끊어짐을 감지하면 긴 이중 지원이 비활성화됩니다. 이는 명시 적으로 오버라이드 (override) 할 수 있습니다 &lt;code&gt;-Duselongdouble&lt;/code&gt; (또는 &lt;code&gt;-Dusemorebits&lt;/code&gt; 모두 긴 두 배 및 64 개 비트 정수를 할 수 있습니다). Long doubles를 활성화하기로 결정한 경우, Perl이 대부분의 깨진 것들에 대해 해결 방법을 구현했지만 특수 값 무한대와 NaN의 처리는 나쁘게 유지됩니다. 예를 들어 무한대 + 0은 NaN을 초래합니다.</target>
        </trans-unit>
        <trans-unit id="0335b463034771ce67a8d72b65b51f2c22f06a51" translate="yes" xml:space="preserve">
          <source>There seems to be a broken system header file in HP-UX 11.00 that breaks perl building in 32bit mode with GNU gcc-4.x causing this error. The same file for HP-UX 11.11 (even though the file is older) does not show this failure, and has the correct definition, so the best fix is to patch the header to match:</source>
          <target state="translated">HP-UX 11.00의 시스템 헤더 파일이 손상되어 GNU gcc-4.x로 32 비트 모드에서 perl 빌드를 중단하면이 오류가 발생합니다. HP-UX 11.11의 동일한 파일 (이전 파일 임에도 불구하고)은이 실패를 표시하지 않으며 올바른 정의를 가지고 있으므로 일치하는 헤더를 패치하는 것이 가장 좋습니다.</target>
        </trans-unit>
        <trans-unit id="06ff19d7cd54ce39cc7fc4ec7d77ca64eb5bbd76" translate="yes" xml:space="preserve">
          <source>There should be a second &lt;code&gt;&quot;:&quot;&lt;/code&gt; , like this:</source>
          <target state="translated">다음 과 같이 두 번째 &lt;code&gt;&quot;:&quot;&lt;/code&gt; 가 있어야합니다 .</target>
        </trans-unit>
        <trans-unit id="f721ea1c84751a36c3521319fb047aa7a307e4e5" translate="yes" xml:space="preserve">
          <source>There should be an operator before the &lt;code&gt;&quot;(&quot;&lt;/code&gt; , as there's no indication as to how the digits are to be combined with the characters in the Lao and Thai scripts.</source>
          <target state="translated">라오스와 태국어 스크립트의 문자와 숫자를 조합하는 방법에 대한 표시가 없으므로 &lt;code&gt;&quot;(&quot;&lt;/code&gt; 앞에 연산자가 있어야합니다 .</target>
        </trans-unit>
        <trans-unit id="b71e898307cc5bb054200f4c984f66181569531c" translate="yes" xml:space="preserve">
          <source>There should be an operator before the &lt;code&gt;&quot;(&quot;&lt;/code&gt;, as there's no indication as to how the digits are to be combined with the characters in the Lao and Thai scripts.</source>
          <target state="translated">&lt;code&gt;&quot;(&quot;&lt;/code&gt; 앞에 연산자가 있어야합니다 . 라오스 어 및 태국어 문자와 숫자를 결합하는 방법에 대한 표시가 없기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="b4b586b7cb9ac2ab75263a6f83deec69bb4720e3" translate="yes" xml:space="preserve">
          <source>There should be no test failures.</source>
          <target state="translated">테스트 실패가 없어야합니다.</target>
        </trans-unit>
        <trans-unit id="b05734899e6eb6dfc62f93644e8cdfe0e3686a6c" translate="yes" xml:space="preserve">
          <source>There used to be two main passes involved in parsing, the first to calculate the size of the compiled program, and the second to actually compile it. But now there is only one main pass, with an initial crude guess based on the length of the input pattern, which is increased if necessary as parsing proceeds, and afterwards, trimmed to the actual amount used.</source>
          <target state="translated">파싱과 관련된 두 가지 주요 패스가 있었는데, 첫 번째는 컴파일 된 프로그램의 크기를 계산하는 것이고 두 번째는 실제로 컴파일하는 것입니다. 그러나 이제는 입력 패턴의 길이를 기반으로 한 초기 추측을 가진 단 하나의 주 패스 만 있으며, 파싱이 진행됨에 따라 필요한 경우 증가하고 나중에 실제 사용 된 양으로 트리밍됩니다.</target>
        </trans-unit>
        <trans-unit id="6e7e045068e59967e564a49c6f93bb7b24be5931" translate="yes" xml:space="preserve">
          <source>There we're using the %USER_VARS hash instead of symbolic references. Sometimes this comes up in reading strings from the user with variable references and wanting to expand them to the values of your perl program's variables. This is also a bad idea because it conflates the program-addressable namespace and the user-addressable one. Instead of reading a string and expanding it to the actual contents of your program's own variables:</source>
          <target state="translated">거기에서 기호 참조 대신 % USER_VARS 해시를 사용하고 있습니다. 때로는 변수 참조가있는 사용자로부터 문자열을 읽고 펄 프로그램 변수의 값으로 확장하려고 할 때가 있습니다. 또한 프로그램 주소 지정 가능 네임 스페이스와 사용자 주소 지정 가능 네임 스페이스를 혼동시키기 때문에 나쁜 생각입니다. 문자열을 읽고 프로그램 자체 변수의 실제 내용으로 확장하는 대신 :</target>
        </trans-unit>
        <trans-unit id="42ff6f078c663dbcc013a189f161b1005798db67" translate="yes" xml:space="preserve">
          <source>There were at least two consecutive &lt;code&gt;=begin&lt;/code&gt; commands without the corresponding &lt;code&gt;=end&lt;/code&gt; . Only one &lt;code&gt;=begin&lt;/code&gt; may be active at a time.</source>
          <target state="translated">해당 &lt;code&gt;=end&lt;/code&gt; 없이 두 개 이상의 연속 &lt;code&gt;=begin&lt;/code&gt; 명령 이있었습니다 . 한 번에 하나의 &lt;code&gt;=begin&lt;/code&gt; 만 활성화 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f453a9d5941f2f68e4cfdb1b1ca5576cad8a3040" translate="yes" xml:space="preserve">
          <source>There were race conditions 1.x implementations of File::Path's &lt;code&gt;rmtree&lt;/code&gt; function (although sometimes patched depending on the OS distribution or platform). The 2.0 version contains code to avoid the problem mentioned in CVE-2002-0435.</source>
          <target state="translated">File :: Path의 &lt;code&gt;rmtree&lt;/code&gt; 함수 의 경쟁 조건 1.x 구현이있었습니다 (OS 배포 또는 플랫폼에 따라 때때로 패치되기도 함). 2.0 버전에는 CVE-2002-0435에 언급 된 문제를 피하기위한 코드가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="3380503a8405cff6d76d7964b6fbca011946199a" translate="yes" xml:space="preserve">
          <source>There were race conditions in the 1.x implementations of File::Path's &lt;code&gt;rmtree&lt;/code&gt; function (although sometimes patched depending on the OS distribution or platform). The 2.0 version contains code to avoid the problem mentioned in CVE-2002-0435.</source>
          <target state="translated">File :: Path의 &lt;code&gt;rmtree&lt;/code&gt; 함수 의 1.x 구현에는 경쟁 조건이있었습니다 (때로는 OS 배포 또는 플랫폼에 따라 패치 됨). 2.0 버전에는 CVE-2002-0435에 언급 된 문제를 방지하기위한 코드가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="78c41744f80fbb19ebe5f5b692cb01709180e04c" translate="yes" xml:space="preserve">
          <source>There were two things you could do, knowing this: be paranoid or be pragmatic. The paranoid approach was to do as little as possible in your signal handler. Set an existing integer variable that already has a value, and return. This doesn't help you if you're in a slow system call, which will just restart. That means you have to &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; to longjmp(3) out of the handler. Even this is a little cavalier for the true paranoiac, who avoids &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; in a handler because the system</source>
          <target state="translated">이것을 아는 것은 두 가지가 있습니다 : 편집증 또는 실용적. 편집증 접근법은 신호 처리기에서 가능한 한 적은 작업을 수행하는 것이 었습니다. 이미 값이있는 기존 정수 변수를 설정하고 반환합니다. 시스템 호출이 느리면 다시 시작하는 데 도움이되지 않습니다. 즉 , 처리기에서 longjmp (3) 로 &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; 합니다. 이 시스템조차도 처리기에서 &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; 것을 피하는 진정한 편집증 환자에게는 조금 무심 합니다.</target>
        </trans-unit>
        <trans-unit id="be42f956d21114ebe79af50776e96bfca65bd05b" translate="yes" xml:space="preserve">
          <source>There were two things you could do, knowing this: be paranoid or be pragmatic. The paranoid approach was to do as little as possible in your signal handler. Set an existing integer variable that already has a value, and return. This doesn't help you if you're in a slow system call, which will just restart. That means you have to &lt;code&gt;die&lt;/code&gt; to longjmp(3) out of the handler. Even this is a little cavalier for the true paranoiac, who avoids &lt;code&gt;die&lt;/code&gt; in a handler because the system</source>
          <target state="translated">당신이 할 수있는 일이 두 가지 있었는데, 이것을 아는 것 : 편집증 적이거나 실용적이어야합니다. 편집증적인 접근 방식은 신호 처리기에서 가능한 한 적은 작업을 수행하는 것입니다. 이미 값이있는 기존 정수 변수를 설정하고 반환합니다. 시스템 호출이 느린 경우에는 도움이되지 않으며 다시 시작됩니다. 즉 , 핸들러에서 longjmp (3) 로 &lt;code&gt;die&lt;/code&gt; 합니다. 이것은 시스템이 처리기에서 &lt;code&gt;die&lt;/code&gt; 것을 피하는 진정한 편집증 환자에게는 조금 무심 합니다.</target>
        </trans-unit>
        <trans-unit id="73d8966c11e67db894b509268c4964e23520f68e" translate="yes" xml:space="preserve">
          <source>There will be less network overhead (and some efficiency in your program) if you specify either the udp or the icmp protocol. The tcp protocol will generate 2.5 times or more traffic for each ping than either udp or icmp. If many hosts are pinged frequently, you may wish to implement a small wait (e.g. 25ms or more) between each ping to avoid flooding your network with packets.</source>
          <target state="translated">udp 또는 icmp 프로토콜을 지정하면 네트워크 오버 헤드 (및 프로그램의 효율성)가 줄어 듭니다. tcp 프로토콜은 uping 또는 icmp보다 각 핑에 대해 2.5 배 이상의 트래픽을 생성합니다. 많은 호스트가 ping을 자주하는 경우 네트워크에 패킷이 넘치지 않도록 각 핑 사이에 작은 대기 (예 : 25ms 이상)를 구현할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6b418e4f885e0ed1944b1a75c443618ba49e064f" translate="yes" xml:space="preserve">
          <source>There&amp;rsquo;s More Than One Way To Do It, the Perl Motto. The notion that there can be more than one valid path to solving a programming problem in context. (This doesn&amp;rsquo;t mean that more ways are always better or that all possible paths are equally desirable&amp;mdash;just that there need not be One True Way.)</source>
          <target state="translated">펄 좌우명은 여러 가지 방법이 있습니다. 문맥에서 프로그래밍 문제를 해결하기위한 하나 이상의 유효한 경로가있을 수 있다는 개념. (그렇다고해서 더 많은 방법이 항상 더 낫거나 모든 가능한 경로가 똑같이 바람직하다는 것을 의미하지는 않습니다. 단 하나의 진정한 방법이 필요하지 않습니다.)</target>
        </trans-unit>
        <trans-unit id="f28bb8331230709c36ed738881be6c54310d8343" translate="yes" xml:space="preserve">
          <source>There's More Than One Way to Do It</source>
          <target state="translated">여러 가지 방법이 있습니다</target>
        </trans-unit>
        <trans-unit id="4490df2ff2d12a716aa36bd30350a041386f672a" translate="yes" xml:space="preserve">
          <source>There's a corresponding &lt;a href=&quot;#no-MODULE-VERSION-LIST&quot;&gt;&lt;code&gt;no&lt;/code&gt;&lt;/a&gt; declaration that unimports meanings imported by &lt;a href=&quot;#use-Module-VERSION-LIST&quot;&gt;&lt;code&gt;use&lt;/code&gt;&lt;/a&gt;, i.e., it calls &lt;code&gt;Module-&amp;gt;unimport(LIST)&lt;/code&gt; instead of &lt;a href=&quot;#import-LIST&quot;&gt;&lt;code&gt;import&lt;/code&gt;&lt;/a&gt;. It behaves just as &lt;a href=&quot;#import-LIST&quot;&gt;&lt;code&gt;import&lt;/code&gt;&lt;/a&gt; does with VERSION, an omitted or empty LIST, or no unimport method being found.</source>
          <target state="translated">&lt;a href=&quot;#use-Module-VERSION-LIST&quot;&gt; &lt;code&gt;use&lt;/code&gt; 를 통해&lt;/a&gt; 가져온 의미를 가져 &lt;a href=&quot;#no-MODULE-VERSION-LIST&quot;&gt; &lt;code&gt;no&lt;/code&gt; &lt;/a&gt; 해당 no 선언이 있습니다 . 즉, &lt;a href=&quot;#import-LIST&quot;&gt; &lt;code&gt;import&lt;/code&gt; &lt;/a&gt; 대신 &lt;code&gt;Module-&amp;gt;unimport(LIST)&lt;/code&gt; 를 호출합니다 . &lt;a href=&quot;#import-LIST&quot;&gt; &lt;code&gt;import&lt;/code&gt; &lt;/a&gt; 가 VERSION, 생략되었거나 비어있는 LIST 또는 가져 오기 해제 메소드가 발견되지 않는 것처럼 작동 합니다.</target>
        </trans-unit>
        <trans-unit id="2d73bf3d5d8029a31c5c535e944915e019e3d9d2" translate="yes" xml:space="preserve">
          <source>There's a corresponding &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt;&lt;/code&gt; declaration that unimports meanings imported by &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt;, i.e., it calls &lt;code&gt;unimport Module LIST&lt;/code&gt; instead of &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt;. It behaves just as &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; does with VERSION, an omitted or empty LIST, or no unimport method being found.</source>
          <target state="translated">해당 없습니다 &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt;&lt;/code&gt; unimports의 의미가 가져온 것을 선언 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 즉, 그것은 호출 &lt;code&gt;unimport Module LIST&lt;/code&gt; 대신 &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; . &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; 는 VERSION, 생략되거나 비어있는 LIST를 사용하거나 임포트 메소드를 찾을 수없는 것처럼 작동 합니다.</target>
        </trans-unit>
        <trans-unit id="899206f410877415c07b1eae00900c686b6ba014" translate="yes" xml:space="preserve">
          <source>There's a corresponding &lt;code&gt;&lt;a href=&quot;no&quot;&gt;no&lt;/a&gt;&lt;/code&gt; declaration that unimports meanings imported by &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt;&lt;/code&gt;, i.e., it calls &lt;code&gt;unimport Module LIST&lt;/code&gt; instead of &lt;code&gt;&lt;a href=&quot;import&quot;&gt;import&lt;/a&gt;&lt;/code&gt;. It behaves just as &lt;code&gt;&lt;a href=&quot;import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; does with VERSION, an omitted or empty LIST, or no unimport method being found.</source>
          <target state="translated">해당 없습니다 &lt;code&gt;&lt;a href=&quot;no&quot;&gt;no&lt;/a&gt;&lt;/code&gt; unimports의 의미가 가져온 것을 선언 &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 즉, 그것은 호출 &lt;code&gt;unimport Module LIST&lt;/code&gt; 대신 &lt;code&gt;&lt;a href=&quot;import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; . &lt;code&gt;&lt;a href=&quot;import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; 는 VERSION, 생략되거나 비어있는 LIST를 사용하거나 임포트 메소드를 찾을 수없는 것처럼 작동 합니다.</target>
        </trans-unit>
        <trans-unit id="5182f679e917b06933e3121044c80451fb98d666" translate="yes" xml:space="preserve">
          <source>There's a couple of useful ones to know about straight away. You wouldn't think we're using any libraries at all at the moment, but '&lt;b&gt;M&lt;/b&gt;' will show which modules are currently loaded, and their version number, while '&lt;b&gt;m&lt;/b&gt;' will show the methods, and '&lt;b&gt;S&lt;/b&gt;' shows all subroutines (by pattern) as shown below. '&lt;b&gt;V&lt;/b&gt;' and '&lt;b&gt;X&lt;/b&gt;' show variables in the program by package scope and can be constrained by pattern.</source>
          <target state="translated">바로 알아야 할 유용한 정보가 몇 가지 있습니다. 우리는 현재 라이브러리를 전혀 사용하지 않을 것이라고 생각하지만 ' &lt;b&gt;M&lt;/b&gt; '은 현재로드 된 모듈과 버전 번호 를 표시하고 ' &lt;b&gt;m&lt;/b&gt; '은 메소드를 표시하고 ' &lt;b&gt;S&lt;/b&gt; '는 모든 서브 루틴을 표시합니다 (아래 그림과 같이) ' &lt;b&gt;V&lt;/b&gt; '및 ' &lt;b&gt;X&lt;/b&gt; '는 프로그램의 변수를 패키지 범위별로 표시하며 패턴으로 제한 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4a1ef6c094aa8fbf90f65e6711f095cef82e3a69" translate="yes" xml:space="preserve">
          <source>There's a great deal of reuse possible for sharing of phrases between modules for related dialects, or for sharing of auxiliary functions between related languages. (By &quot;auxiliary functions&quot;, I mean functions that don't produce phrase-text, but which, say, return an answer to &quot;does this number require a plural noun after it?&quot;. Such auxiliary functions would be used in the internal logic of functions that actually do produce phrase-text.)</source>
          <target state="translated">관련 방언에 대한 모듈간에 구문을 공유하거나 관련 언어간에 보조 기능을 공유하기 위해 많은 재사용이 가능합니다. ( &quot;보조 함수&quot;란 구문 텍스트를 생성하지 않지만 &quot;이 숫자 뒤에 복수 명사가 필요합니까?&quot;라는 대답을 반환하는 함수를 의미합니다. 이러한 보조 함수는 내부에서 사용됩니다. 실제로 구문 텍스트를 생성하는 함수의 논리.)</target>
        </trans-unit>
        <trans-unit id="18ae2cf96b3321649a9e67b52ce3c6b5c29a8066" translate="yes" xml:space="preserve">
          <source>There's a lot more to networking than this, but this should get you started.</source>
          <target state="translated">이것보다 네트워킹에 더 많은 것이 있지만, 시작해야합니다.</target>
        </trans-unit>
        <trans-unit id="7dfd5539590f938c8db0768ae08c09cb62cf9574" translate="yes" xml:space="preserve">
          <source>There's a lot to know about character sets, and text encodings. It's probably best to spend a full day learning all this, but the basics can be learned in minutes.</source>
          <target state="translated">문자 집합과 텍스트 인코딩에 대해 알아야 할 것이 많습니다. 하루 종일이 모든 것을 배우는 것이 가장 좋지만 기본 사항은 몇 분 안에 배울 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="99ae85d03f4b582c99ff96216db7d59e44f17f54" translate="yes" xml:space="preserve">
          <source>There's a problem with &lt;code&gt;&lt;a href=&quot;functions/syscall&quot;&gt;syscall(&amp;amp;SYS_pipe)&lt;/a&gt;&lt;/code&gt;: it returns the file number of the read end of the pipe it creates, but there is no way to retrieve the file number of the other end. You can avoid this problem by using &lt;code&gt;&lt;a href=&quot;functions/pipe&quot;&gt;pipe&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/syscall&quot;&gt;syscall(&amp;amp;SYS_pipe)&lt;/a&gt;&lt;/code&gt; 문제가 있습니다. 생성 한 파이프의 읽기 끝 파일 번호를 반환하지만 다른 쪽 끝의 파일 번호를 검색 할 방법은 없습니다. 대신 &lt;code&gt;&lt;a href=&quot;functions/pipe&quot;&gt;pipe&lt;/a&gt;&lt;/code&gt; 를 사용하여이 문제를 피할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="66cd02292a787335ff912b7d35685e3ae9e8fbc4" translate="yes" xml:space="preserve">
          <source>There's a problem with &lt;code&gt;&lt;a href=&quot;syscall&quot;&gt;syscall(&amp;amp;SYS_pipe)&lt;/a&gt;&lt;/code&gt;: it returns the file number of the read end of the pipe it creates, but there is no way to retrieve the file number of the other end. You can avoid this problem by using &lt;code&gt;&lt;a href=&quot;pipe&quot;&gt;pipe&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;syscall&quot;&gt;syscall(&amp;amp;SYS_pipe)&lt;/a&gt;&lt;/code&gt; 문제가 있습니다. 생성 한 파이프의 읽기 끝 파일 번호를 반환하지만 다른 쪽 끝의 파일 번호를 검색 할 방법은 없습니다. 대신 &lt;code&gt;&lt;a href=&quot;pipe&quot;&gt;pipe&lt;/a&gt;&lt;/code&gt; 를 사용하여이 문제를 피할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="124833fbba9a90584d7cbbd8c3f21d0d1ed7374a" translate="yes" xml:space="preserve">
          <source>There's a problem with &lt;code&gt;syscall(SYS_pipe())&lt;/code&gt;: it returns the file number of the read end of the pipe it creates, but there is no way to retrieve the file number of the other end. You can avoid this problem by using &lt;a href=&quot;#pipe-READHANDLE%2CWRITEHANDLE&quot;&gt;&lt;code&gt;pipe&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">&lt;code&gt;syscall(SYS_pipe())&lt;/code&gt; 문제가 있습니다. 생성 한 파이프의 읽기 끝의 파일 번호를 반환하지만 다른 끝의 파일 번호를 검색 할 방법이 없습니다. 대신 &lt;a href=&quot;#pipe-READHANDLE%2CWRITEHANDLE&quot;&gt; &lt;code&gt;pipe&lt;/code&gt; &lt;/a&gt; 를 사용하여이 문제를 피할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e41e3a2378d95f98d33fb21414c6067f31a384cf" translate="yes" xml:space="preserve">
          <source>There's a slight complication under the hood of &lt;code&gt;Memoize&lt;/code&gt; : There are actually</source>
          <target state="translated">&lt;code&gt;Memoize&lt;/code&gt; 의 후드에는 약간의 합병증 이 있습니다. 실제로</target>
        </trans-unit>
        <trans-unit id="e606f3dfb543a0539ef72dd37726579bac1b16a8" translate="yes" xml:space="preserve">
          <source>There's a slight complication under the hood of &lt;code&gt;Memoize&lt;/code&gt;: There are actually</source>
          <target state="translated">&lt;code&gt;Memoize&lt;/code&gt; 의 후드 아래에 약간의 복잡함 이 있습니다.</target>
        </trans-unit>
        <trans-unit id="5de903209b03670bb7672de0c3e9635cd117f5ca" translate="yes" xml:space="preserve">
          <source>There's a subtle trap lurking in the offing: Adding another field after the Short Message (in variable &lt;code&gt;$sm&lt;/code&gt; ) is all right when packing, but this cannot be unpacked naively:</source>
          <target state="translated">포장에 미묘한 함정이 숨어 있습니다. 단문 메시지 (변수 &lt;code&gt;$sm&lt;/code&gt; ) 뒤에 다른 필드를 추가하는 것은 괜찮습니다. 그러나 포장을 풀 수는 없습니다.</target>
        </trans-unit>
        <trans-unit id="f66d2e86f53d8e9dfa87109acbd15cc3b1bb44aa" translate="yes" xml:space="preserve">
          <source>There's a subtle trap lurking in the offing: Adding another field after the Short Message (in variable &lt;code&gt;$sm&lt;/code&gt;) is all right when packing, but this cannot be unpacked naively:</source>
          <target state="translated">앞바다에는 미묘한 함정이 숨어 있습니다. 짧은 메시지 (변수 &lt;code&gt;$sm&lt;/code&gt; ) 뒤에 다른 필드를 추가하는 것은 패킹 할 때 괜찮지 만 순진하게 풀 수는 없습니다.</target>
        </trans-unit>
        <trans-unit id="5136f0522d5206778ac4f88d48f4c827076f1a46" translate="yes" xml:space="preserve">
          <source>There's a wiki dedicated to the Test Anything Protocol:</source>
          <target state="translated">Test Anything Protocol 전용 Wiki가 있습니다.</target>
        </trans-unit>
        <trans-unit id="3b112374a474f8a64038b7df632984baece37394" translate="yes" xml:space="preserve">
          <source>There's also</source>
          <target state="translated">또한있다</target>
        </trans-unit>
        <trans-unit id="40aa0d88671271215389ee01ca5270e38fa18dab" translate="yes" xml:space="preserve">
          <source>There's also a &lt;a href=&quot;File::Tail&quot;&gt;File::Tail&lt;/a&gt; module from CPAN.</source>
          <target state="translated">CPAN 의 &lt;a href=&quot;File::Tail&quot;&gt;File :: Tail&lt;/a&gt; 모듈도 있습니다.</target>
        </trans-unit>
        <trans-unit id="58a726895b66eba4d8724a2292f078a4d2648322" translate="yes" xml:space="preserve">
          <source>There's also a &lt;a href=&quot;http://search.cpan.org/perldoc/File::Tail&quot;&gt;File::Tail&lt;/a&gt; module from CPAN.</source>
          <target state="translated">CPAN 의 &lt;a href=&quot;http://search.cpan.org/perldoc/File::Tail&quot;&gt;File :: Tail&lt;/a&gt; 모듈도 있습니다.</target>
        </trans-unit>
        <trans-unit id="035e86078ae3280a54d8fc426b353c9ce230b2ad" translate="yes" xml:space="preserve">
          <source>There's also a negated version of it:</source>
          <target state="translated">그것의 부정 버전도 있습니다 :</target>
        </trans-unit>
        <trans-unit id="194f92c1842e4ee102fc7a284b9e315ab368c04c" translate="yes" xml:space="preserve">
          <source>There's also a negated version, for the same reason we have &lt;code&gt;unless&lt;/code&gt; :</source>
          <target state="translated">다음과 같은 &lt;code&gt;unless&lt;/code&gt; 하고 부정한 버전도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e0601768e9aaa457e7e7ef47834fc2f32a22f940" translate="yes" xml:space="preserve">
          <source>There's also a negated version, for the same reason we have &lt;code&gt;unless&lt;/code&gt;:</source>
          <target state="translated">다음과 같은 &lt;code&gt;unless&lt;/code&gt; 하고는 동일한 이유로 부정 된 버전도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ce23f5592e874ac51b717997ee3d4abcaf17d1eb" translate="yes" xml:space="preserve">
          <source>There's an &lt;code&gt;unmemoize&lt;/code&gt; function that you can import if you want to. Why would you want to? Here's an example: Suppose you have your cache tied to a DBM file, and you want to make sure that the cache is written out to disk if someone interrupts the program. If the program exits normally, this will happen anyway, but if someone types control-C or something then the program will terminate immediately without synchronizing the database. So what you can do instead is</source>
          <target state="translated">원하는 경우 가져올 수 있는 &lt;code&gt;unmemoize&lt;/code&gt; 기능이 있습니다. 왜 하시겠습니까? 예를 들면 다음과 같습니다. 캐시가 DBM 파일에 연결되어 있고 누군가 프로그램을 중단 할 경우 캐시가 디스크에 기록되도록하려고한다고 가정하십시오. 프로그램이 정상적으로 종료되면 어쨌든 이런 일이 발생하지만 누군가 control-C 또는 무언가를 입력하면 데이터베이스를 동기화하지 않고 프로그램이 즉시 종료됩니다. 대신에 할 수있는 것은</target>
        </trans-unit>
        <trans-unit id="08ec3c4ec2591dd761c5a485e08fcf45d215a5be" translate="yes" xml:space="preserve">
          <source>There's an effort going on to document the internal functions and automatically produce reference manuals from them -- &lt;a href=&quot;perlapi&quot;&gt;perlapi&lt;/a&gt; is one such manual which details all the functions which are available to XS writers. &lt;a href=&quot;perlintern&quot;&gt;perlintern&lt;/a&gt; is the autogenerated manual for the functions which are not part of the API and are supposedly for internal use only.</source>
          <target state="translated">내부 기능을 문서화하고 이들로부터 참조 매뉴얼을 자동으로 작성하려고 노력하고 있습니다. &lt;a href=&quot;perlapi&quot;&gt;perlapi&lt;/a&gt; 는 XS 작성자가 사용할 수있는 모든 기능을 자세히 설명하는 매뉴얼입니다. &lt;a href=&quot;perlintern&quot;&gt;perlintern&lt;/a&gt; 은 API의 일부가 아니며 내부 용으로 만 사용되는 기능에 대한 자동 생성 매뉴얼입니다.</target>
        </trans-unit>
        <trans-unit id="b109c22c8125d5fbc051e5882994774c0628f7aa" translate="yes" xml:space="preserve">
          <source>There's an example of this in &lt;a href=&quot;functions/crypt&quot;&gt;crypt&lt;/a&gt;). First, you put the terminal into &quot;no echo&quot; mode, then just read the password normally. You may do this with an old-style &lt;code&gt;&lt;a href=&quot;functions/ioctl&quot;&gt;ioctl()&lt;/a&gt;&lt;/code&gt; function, POSIX terminal control (see &lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt; or its documentation the Camel Book), or a call to the &lt;b&gt;stty&lt;/b&gt; program, with varying degrees of portability.</source>
          <target state="translated">&lt;a href=&quot;functions/crypt&quot;&gt;crypt&lt;/a&gt; 에 이에 대한 예가 있습니다 . 먼저, 터미널을 &quot;에코 없음&quot;모드로 설정 한 다음 비밀번호를 정상적으로 읽으십시오. 이전 스타일의 &lt;code&gt;&lt;a href=&quot;functions/ioctl&quot;&gt;ioctl()&lt;/a&gt;&lt;/code&gt; 함수, POSIX 터미널 제어 ( &lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt; 또는 해당 설명서 Camel Book 참조) 또는 &lt;b&gt;stty&lt;/b&gt; 프로그램을 호출하여 다양한 수준의 이식성을 통해이를 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e33a4a8215c89473473d7891ce0340be047dd1e2" translate="yes" xml:space="preserve">
          <source>There's an example of this in &lt;a href=&quot;perlfunc#crypt&quot;&gt;&quot;crypt&quot; in perlfunc&lt;/a&gt;. First, you put the terminal into &quot;no echo&quot; mode, then just read the password normally. You may do this with an old-style &lt;code&gt;ioctl()&lt;/code&gt; function, POSIX terminal control (see &lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt; or its documentation the Camel Book), or a call to the &lt;b&gt;stty&lt;/b&gt; program, with varying degrees of portability.</source>
          <target state="translated">&lt;a href=&quot;perlfunc#crypt&quot;&gt;perlfunc의 &quot;crypt&quot;에&lt;/a&gt; 이에 대한 예가 있습니다 . 먼저 터미널을 &quot;에코 없음&quot;모드로 설정 한 다음 정상적으로 암호를 읽습니다. 이전 스타일의 &lt;code&gt;ioctl()&lt;/code&gt; 함수, POSIX 터미널 제어 ( &lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt; 또는 해당 문서의 Camel Book 참조) 또는 다양한 수준의 이식성으로 &lt;b&gt;stty&lt;/b&gt; 프로그램에 대한 호출을 사용하여이를 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1ee734c8b4d4a5b72b07450e993a31efdfcc81d2" translate="yes" xml:space="preserve">
          <source>There's an extraordinary number of people out there who don't appear to know anything about using the perl debugger, though they use the language every day. This is for them.</source>
          <target state="translated">perl 디버거 사용에 대해서는 아무것도 모르지만 매일 언어를 사용하는 사람은 많지 않습니다. 이것은 그들을위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="36e675dcb566e351efbc0e3f85ec7104c90a083d" translate="yes" xml:space="preserve">
          <source>There's currently only one class that has a stable interface - CPAN::Shell. All commands that are available in the CPAN shell are methods of the class CPAN::Shell. The arguments on the commandline are passed as arguments to the method.</source>
          <target state="translated">CPAN :: Shell이라는 안정적인 인터페이스를 가진 클래스는 현재 하나뿐입니다. CPAN 쉘에서 사용 가능한 모든 명령은 CPAN :: Shell 클래스의 메소드입니다. 명령 행의 인수는 메소드에 인수로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="f60d62cdc295d6cbdfb5f2a35e55c4e958719c10" translate="yes" xml:space="preserve">
          <source>There's even less need to distinguish between EBCDIC code pages, but to do so try looking at one or more of the characters that differ between them.</source>
          <target state="translated">EBCDIC 코드 페이지를 구별 할 필요는 없지만, 서로 다른 하나 이상의 문자를 찾아보십시오.</target>
        </trans-unit>
        <trans-unit id="241fd51f25450a5ab0b7ec2c19699d2410027de0" translate="yes" xml:space="preserve">
          <source>There's no builtin way to do this, but &lt;a href=&quot;perlform&quot;&gt;perlform&lt;/a&gt; has a couple of techniques to make it possible for the intrepid hacker.</source>
          <target state="translated">이 작업을 수행하는 기본 방법은 없지만 &lt;a href=&quot;perlform&quot;&gt;perlform&lt;/a&gt; 은 에는 대담한 해커가이를 가능하게하는 몇 가지 기술이 있습니다.</target>
        </trans-unit>
        <trans-unit id="5ace2a9bc7f6a90948438c072e0ce5f8cdc2b9bc" translate="yes" xml:space="preserve">
          <source>There's no feedback from this, but you can see what breakpoints are set by using the list 'L' command:</source>
          <target state="translated">이것에 대한 피드백은 없지만 list 'L'명령을 사용하여 어떤 중단 점을 설정했는지 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f521ff0638ee964aa0ea31d64e9248f45119c41c" translate="yes" xml:space="preserve">
          <source>There's no solution for this problem other than making the custom engine understand a construct like &lt;code&gt;(?:)&lt;/code&gt;.</source>
          <target state="translated">커스텀 엔진이 &lt;code&gt;(?:)&lt;/code&gt; 와 같은 구문을 이해하게하는 것 외에는이 문제에 대한 해결책이 없습니다. .</target>
        </trans-unit>
        <trans-unit id="f42438ddafc8a1bac998273822622081c6567570" translate="yes" xml:space="preserve">
          <source>There's no strong security layer in CPAN.pm. CPAN.pm helps you to install foreign, unmasked, unsigned code on your machine. We compare to a checksum that comes from the net just as the distribution file itself. But we try to make it easy to add security on demand:</source>
          <target state="translated">CPAN.pm에는 강력한 보안 계층이 없습니다. CPAN.pm을 사용하면 시스템에 마스크되지 않은 서명되지 않은 외부 코드를 설치할 수 있습니다. 우리는 배포 파일 자체와 같이 그물에서 나오는 체크섬과 비교합니다. 그러나 요청시 보안을 쉽게 추가 할 수 있도록 노력합니다.</target>
        </trans-unit>
        <trans-unit id="794fc83a38998696363c5b95bfbda5c120c0de13" translate="yes" xml:space="preserve">
          <source>There's no way to tell if a &lt;code&gt;char *&lt;/code&gt; or &lt;code&gt;U8 *&lt;/code&gt; string is UTF-8 or not. But you can tell if an SV is to be treated as UTF-8 by calling &lt;code&gt;DO_UTF8&lt;/code&gt; on it, after stringifying it with &lt;code&gt;SvPV&lt;/code&gt; or a similar macro. And, you can tell if SV is actually UTF-8 (even if it is not to be treated as such) by looking at its &lt;code&gt;SvUTF8&lt;/code&gt; flag (again after stringifying it). Don't forget to set the flag if something should be UTF-8. Treat the flag as part of the PV, even though it's not -- if you pass on the PV to somewhere, pass on the flag too.</source>
          <target state="translated">&lt;code&gt;char *&lt;/code&gt; 또는 &lt;code&gt;U8 *&lt;/code&gt; 문자열이 UTF-8 인지 여부를 알 수있는 방법이 없습니다. 그러나 &lt;code&gt;SvPV&lt;/code&gt; 또는 유사한 매크로를 사용 하여 SV_UTF8 을 문자열 화 한 후 &lt;code&gt;DO_UTF8&lt;/code&gt; 을 호출하여 SV를 UTF-8로 처리할지 여부를 알 수 있습니다 . 그리고 &lt;code&gt;SvUTF8&lt;/code&gt; 을 보면 SV가 실제로 UTF-8인지 (그렇게 취급되지 않더라도) 알 수 있습니다. 플래그를 ( 플래그를 후 . UTF-8이어야하는 경우 플래그를 설정하는 것을 잊지 마십시오. PV가 아닌 경우에도 플래그를 PV의 일부로 취급하십시오. PV를 다른 곳으로 전달하는 경우 플래그도 전달하십시오.</target>
        </trans-unit>
        <trans-unit id="dcc25cfc8a3ec732d1d2283e554b506992b75eb5" translate="yes" xml:space="preserve">
          <source>There's not a single way to run code in the background so you don't have to wait for it to finish before your program moves on to other tasks. Process management depends on your particular operating system, and many of the techniques are covered in &lt;a href=&quot;perlipc&quot;&gt;perlipc&lt;/a&gt;.</source>
          <target state="translated">백그라운드에서 코드를 실행하는 단일 방법은 없으므로 프로그램이 다른 작업으로 이동하기 전에 코드가 끝날 때까지 기다릴 필요가 없습니다. 프로세스 관리는 특정 운영 체제에 따라 다르며 많은 기술이 &lt;a href=&quot;perlipc&quot;&gt;perlipc&lt;/a&gt; 에서 다루고 있습니다.</target>
        </trans-unit>
        <trans-unit id="d2aa5e3dbb927bd52349be7be623e623e64f5bf0" translate="yes" xml:space="preserve">
          <source>There's now some new C code that's been added to the .xs file. The purpose of the &lt;code&gt;constant&lt;/code&gt; routine is to make the values that are #define'd in the header file accessible by the Perl script (by calling either &lt;code&gt;TESTVAL&lt;/code&gt; or &lt;code&gt;&amp;amp;Mytest2::TESTVAL&lt;/code&gt; ). There's also some XS code to allow calls to the &lt;code&gt;constant&lt;/code&gt; routine.</source>
          <target state="translated">이제 .xs 파일에 추가 된 몇 가지 새로운 C 코드가 있습니다. &lt;code&gt;constant&lt;/code&gt; 루틴 의 목적은 헤더 파일에서 # define 's 값을 Perl 스크립트가 액세스 할 수있게하는 것입니다 ( &lt;code&gt;TESTVAL&lt;/code&gt; 또는 &lt;code&gt;&amp;amp;Mytest2::TESTVAL&lt;/code&gt; 을 호출하여 ). &lt;code&gt;constant&lt;/code&gt; 루틴 에 대한 호출을 허용하는 XS 코드도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="31087344a4d97cb3b80b7f78b63485fff944c0b5" translate="yes" xml:space="preserve">
          <source>There's now some new C code that's been added to the .xs file. The purpose of the &lt;code&gt;constant&lt;/code&gt; routine is to make the values that are #define'd in the header file accessible by the Perl script (by calling either &lt;code&gt;TESTVAL&lt;/code&gt; or &lt;code&gt;&amp;amp;Mytest2::TESTVAL&lt;/code&gt;). There's also some XS code to allow calls to the &lt;code&gt;constant&lt;/code&gt; routine.</source>
          <target state="translated">이제 .xs 파일에 추가 된 몇 가지 새로운 C 코드가 있습니다. &lt;code&gt;constant&lt;/code&gt; 루틴 의 목적은 헤더 파일에 # 정의 된 값을 Perl 스크립트에서 액세스 할 수 있도록하는 것입니다 ( &lt;code&gt;TESTVAL&lt;/code&gt; 또는 &lt;code&gt;&amp;amp;Mytest2::TESTVAL&lt;/code&gt; 을 호출하여 ). &lt;code&gt;constant&lt;/code&gt; 루틴 에 대한 호출을 허용하는 XS 코드도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e3ac8386164e4284b824a87f18c211196212c066" translate="yes" xml:space="preserve">
          <source>There's one fine point I skipped. Line 5 is unnecessary, and we can get rid of it.</source>
          <target state="translated">건너 뛴 좋은 점이 하나 있습니다. 5 호선은 불필요하며 제거 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f039a4fa9d9f10c8752271acf6c5252496665e47" translate="yes" xml:space="preserve">
          <source>There's one more item to add to this list. Do &lt;b&gt;not&lt;/b&gt; export variable names. Just because &lt;code&gt;Exporter&lt;/code&gt; lets you do that, it does not mean you should.</source>
          <target state="translated">이 목록에 추가 할 항목이 하나 더 있습니다. 마십시오 &lt;b&gt;하지&lt;/b&gt; 변수 이름을 내보낼 수 있습니다. 그냥 있기 때문에 &lt;code&gt;Exporter&lt;/code&gt; 당신이 작업을 수행 할 수 있습니다, 당신이해야 의미하지 않는다.</target>
        </trans-unit>
        <trans-unit id="ae8f51d8071cfe43c76f4dc0a54e230b2757479f" translate="yes" xml:space="preserve">
          <source>There's plenty more to Maketext than described above -- for example, there's the details of how language tags (&quot;en-US&quot;, &quot;i-pwn&quot;, &quot;fi&quot;, etc.) or locale IDs (&quot;en_US&quot;) interact with actual module naming (&quot;BogoQuery/Locale/en_us.pm&quot;), and what magic can ensue; there's the details of how to record (and possibly negotiate) what character encoding Maketext will return text in (UTF8? Latin-1? KOI8?). There's the interesting fact that Maketext is for localization, but nowhere actually has a &quot;&lt;code&gt;use locale;&lt;/code&gt;&quot; anywhere in it. For the curious, there's the somewhat frightening details of how I actually implement something like data inheritance so that searches across modules' %Lexicon hashes can parallel how Perl implements method inheritance.</source>
          <target state="translated">Maketext에는 위에서 설명한 것보다 더 많은 것이 있습니다. 예를 들어 언어 태그 ( &quot;en-US&quot;, &quot;i-pwn&quot;, &quot;fi&quot;등) 또는 로케일 ID ( &quot;en_US&quot;)가 상호 작용하는 방법에 대한 세부 정보가 있습니다. 실제 모듈 이름 지정 ( &quot;BogoQuery / Locale / en_us.pm&quot;), 그리고 어떤 마법이 뒤따를 수 있는지; Maketext가 (UTF8? Latin-1? KOI8?)에서 텍스트를 반환 할 문자 인코딩을 기록 (및 협상 가능)하는 방법에 대한 세부 정보가 있습니다. Maketext가 현지화 용이라는 흥미로운 사실이 있지만 실제로는 어디에도 &quot; &lt;code&gt;use locale;&lt;/code&gt; &quot;이 없습니다. 호기심이 많으면 모듈의 % Lexicon 해시 검색이 Perl이 메서드 상속을 구현하는 방식과 평행을 이룰 수 있도록 데이터 상속과 같은 것을 실제로 구현하는 방법에 대한 다소 무서운 세부 사항이 있습니다.</target>
        </trans-unit>
        <trans-unit id="3157833531a4041a2d11a3ede90a818b20eec8a5" translate="yes" xml:space="preserve">
          <source>There's three possible options: arm-linux-androideabi for ARM, mipsel-linux-android for MIPS, and simply x86 for x86. As of 2014, most Android devices run on ARM, so that is generally a safe bet.</source>
          <target state="translated">가능한 옵션은 ARM 용 arm-linux-androideabi, MIPS 용 mipsel-linux-android, x86 용 x86입니다. 2014 년 현재 대부분의 Android 기기는 ARM에서 실행되므로 일반적으로 안전한 방법입니다.</target>
        </trans-unit>
        <trans-unit id="23be60d3d8e40781087cd39d472decaae39f70d3" translate="yes" xml:space="preserve">
          <source>There, &quot;=shazbot&quot; will be parsed as a Pod command &quot;shazbot&quot;, not as a data paragraph &quot;=shazbot\n&quot;. However, you can express a data paragraph consisting of &quot;=shazbot\n&quot; using this code:</source>
          <target state="translated">여기서 &quot;= shazbot&quot;은 데이터 단락 &quot;= shazbot \ n&quot;이 아닌 포드 명령 &quot;shazbot&quot;으로 구문 분석됩니다. 그러나이 코드를 사용하여 &quot;= shazbot \ n&quot;으로 구성된 데이터 단락을 표현할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d934ecae0b30d1837eb15a99e36faf1a189e093b" translate="yes" xml:space="preserve">
          <source>There, the &quot;=begin html&quot;...&quot;=end html&quot; region is nested inside the larger &quot;=begin :biblio&quot;...&quot;=end :biblio&quot; region. Note that the content of the &quot;=begin html&quot;...&quot;=end html&quot; region is data paragraph(s), because the immediately containing region's identifier (&quot;html&quot;)</source>
          <target state="translated">&quot;= begin html&quot;... &quot;= end html&quot;영역은 더 큰 &quot;= begin : biblio&quot;... &quot;= end : biblio&quot;영역 안에 중첩됩니다. &quot;= begin html&quot;... &quot;= end html&quot;영역의 내용은 데이터 단락입니다. 왜냐하면 바로 영역의 식별자 ( &quot;html&quot;)를 포함하기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="4c11e16e3b4c4d1c6c6291b739425f3d103ebc32" translate="yes" xml:space="preserve">
          <source>Therefor, we recommend to only use &lt;code&gt;lynx&lt;/code&gt; as a last resort. This is why it is at the back of our list of methods to try as well.</source>
          <target state="translated">따라서 마지막 수단으로 &lt;code&gt;lynx&lt;/code&gt; 만 사용하는 것이 좋습니다 . 이것이 우리가 시도하는 방법 목록의 뒷면에있는 이유입니다.</target>
        </trans-unit>
        <trans-unit id="22f5648477726ba3de08027c1e14282ca2d62678" translate="yes" xml:space="preserve">
          <source>Therefore it is best to avoid &lt;code&gt;$Carp::CarpLevel&lt;/code&gt; . Instead use &lt;code&gt;@CARP_NOT&lt;/code&gt; , &lt;code&gt;%Carp::Internal&lt;/code&gt; and &lt;code&gt;%Carp::CarpInternal&lt;/code&gt; .</source>
          <target state="translated">따라서 &lt;code&gt;$Carp::CarpLevel&lt;/code&gt; 을 피하는 것이 가장 좋습니다 . 대신 &lt;code&gt;@CARP_NOT&lt;/code&gt; , &lt;code&gt;%Carp::Internal&lt;/code&gt; 및 &lt;code&gt;%Carp::CarpInternal&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="51f60bccfa776ffe69d8f053cbc128c1c25657ab" translate="yes" xml:space="preserve">
          <source>Therefore it is best to avoid &lt;code&gt;$Carp::CarpLevel&lt;/code&gt;. Instead use &lt;code&gt;@CARP_NOT&lt;/code&gt;, &lt;code&gt;%Carp::Internal&lt;/code&gt; and &lt;code&gt;%Carp::CarpInternal&lt;/code&gt;.</source>
          <target state="translated">따라서 &lt;code&gt;$Carp::CarpLevel&lt;/code&gt; 을 피하는 것이 가장 좋습니다 . 대신 &lt;code&gt;@CARP_NOT&lt;/code&gt; , &lt;code&gt;%Carp::Internal&lt;/code&gt; 및 &lt;code&gt;%Carp::CarpInternal&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ee230bfa80dc9a35487630711b69781b4de0480c" translate="yes" xml:space="preserve">
          <source>Therefore modules that can install from CPAN to the core library must make sure not to call this pragma when they have done so. Generally this means that the exact logic from the installer must be mirrored inside the module. E.g.:</source>
          <target state="translated">따라서 CPAN에서 코어 라이브러리로 설치할 수있는 모듈은 그렇게했을 때이 pragma를 호출하지 않도록해야합니다. 일반적으로 이는 설치 프로그램의 정확한 로직이 모듈 내부에서 미러링되어야 함을 의미합니다. 예 :</target>
        </trans-unit>
        <trans-unit id="6d0e80030071251142bc856e7654aae9ae473e69" translate="yes" xml:space="preserve">
          <source>Therefore we can use the &lt;code&gt;O_FILES&lt;/code&gt; variable to tell MakeMaker to use these objects into the shared library.</source>
          <target state="translated">따라서 &lt;code&gt;O_FILES&lt;/code&gt; 변수를 사용하여 MakeMaker 에게 이러한 객체를 공유 라이브러리로 사용하도록 지시 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="bc549460f9ec0f5ba049505f7c5226ae9e2f8140" translate="yes" xml:space="preserve">
          <source>Therefore, if you make changes to $ENV{TZ} from inside a thread other than the main thread then those changes will not be seen by strftime if you subsequently call that with the %Z formatting code. You must change $ENV{TZ} in the main thread to have the desired effect in this case (and you must also call _tzset() in the main thread to register the environment change).</source>
          <target state="translated">따라서 주 스레드 이외의 스레드 내부에서 $ ENV {TZ}를 변경하면 이후에 % Z 형식화 코드를 사용하여 호출하면 해당 변경 사항이 strftime에 표시되지 않습니다. 이 경우 원하는 효과를 주려면 주 스레드에서 $ ENV {TZ}를 변경해야합니다 (그리고 환경 변경을 등록하려면 주 스레드에서 _tzset ()을 호출해야합니다).</target>
        </trans-unit>
        <trans-unit id="a9f8fba915c890e8c346b81a259121ea682217ff" translate="yes" xml:space="preserve">
          <source>Therefore, if you want your scripts to be able to run on all versions of Perl, you should call &lt;code&gt;&lt;a href=&quot;../../functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; explicitly and not rely on automatic closing.</source>
          <target state="translated">따라서 모든 버전의 Perl에서 스크립트를 실행할 수있게하려면 자동 닫기에 의존하지 말고 &lt;code&gt;&lt;a href=&quot;../../functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; 를 명시 적으로 호출해야합니다 .</target>
        </trans-unit>
        <trans-unit id="954446d1274139a67133d250b76f105e02594120" translate="yes" xml:space="preserve">
          <source>Therefore, if you want your scripts to be able to run on all versions of Perl, you should call &lt;code&gt;close&lt;/code&gt; explicitly and not rely on automatic closing.</source>
          <target state="translated">따라서 스크립트가 모든 버전의 Perl에서 실행되도록하려면 자동 닫기에 의존하지 말고 명시 적으로 &lt;code&gt;close&lt;/code&gt; 를 호출해야합니다 .</target>
        </trans-unit>
        <trans-unit id="b60bd02288d8270eaef5b4fd58dd4835333cea91" translate="yes" xml:space="preserve">
          <source>Therefore, populate such variables &lt;b&gt;after&lt;/b&gt; declaring them as shared. (Scalar and scalar refs are not affected by this problem.)</source>
          <target state="translated">따라서 이러한 변수 를 공유 &lt;b&gt;된 것으로&lt;/b&gt; 선언 &lt;b&gt;한 후 채&lt;/b&gt; 웁니다 . 스칼라 및 스칼라 참조는이 문제의 영향을받지 않습니다.</target>
        </trans-unit>
        <trans-unit id="fd4c5f1975f02e1f013464b5926b49a349d976cd" translate="yes" xml:space="preserve">
          <source>Therefore, recursion should normally be avoided, but is nonetheless supported.</source>
          <target state="translated">따라서 재귀는 일반적으로 피해야하지만 그럼에도 불구하고 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="db068f38c67a6942c06b6242bd31cfce066e66c2" translate="yes" xml:space="preserve">
          <source>Therefore, when both -f and -t are omitted, &lt;b&gt;piconv&lt;/b&gt; just acts like &lt;b&gt;cat&lt;/b&gt;.</source>
          <target state="translated">따라서 -f와 -t를 모두 생략하면 &lt;b&gt;piconv&lt;/b&gt; 는 &lt;b&gt;cat&lt;/b&gt; 처럼 작동 합니다.</target>
        </trans-unit>
        <trans-unit id="2f61899aa2182fe38363f4a728d368f7dbd80080" translate="yes" xml:space="preserve">
          <source>Therefore, when serializing hooks are involved,</source>
          <target state="translated">따라서 직렬화 후크가 관련된 경우</target>
        </trans-unit>
        <trans-unit id="083d92ff42dd743db0e3ca76319637c407df0e2d" translate="yes" xml:space="preserve">
          <source>Therefore, you should bless objects before sharing them.</source>
          <target state="translated">따라서 사물을 공유하기 전에 축복해야합니다.</target>
        </trans-unit>
        <trans-unit id="c563bb79b9bbcc9436e0f964c49bd1fc0638d285" translate="yes" xml:space="preserve">
          <source>These #vars represent opcode properties that you may want as part of your rendering. The '#' is intended as a private sigil; a #var's value is interpolated into the style-line, much like &quot;read $this&quot;.</source>
          <target state="translated">이러한 #var은 렌더링의 일부로 원하는 opcode 속성을 나타냅니다. '#'은 개인시길로 사용됩니다. #var의 값은 &quot;read $ this&quot;와 같이 스타일 라인에 보간됩니다.</target>
        </trans-unit>
        <trans-unit id="0e7355ac11ba52ff51227da22556bcbc5b08758c" translate="yes" xml:space="preserve">
          <source>These ID's are unique enough for most purposes. For identical ids to be generated you must have 2 processes with the same PID generate IDs at the same time with the same current state of the incrementing integer. This is a perfectly reasonable thing to expect to happen across multiple machines, but is quite unlikely to happen on one machine.</source>
          <target state="translated">이 ID는 대부분의 목적에 대해 충분히 고유합니다. 동일한 ID가 생성 되려면 증가하는 정수의 동일한 현재 상태와 동일한 PID 생성 ID를 가진 2 개의 프로세스가 동시에 있어야합니다. 이것은 여러 시스템에서 발생할 것으로 예상되는 완벽하게 합리적이지만 한 시스템에서 발생할 가능성은 거의 없습니다.</target>
        </trans-unit>
        <trans-unit id="4fb65d165e3bae5f5ca82f785cf62dfbdc24692e" translate="yes" xml:space="preserve">
          <source>These JSON atoms become &lt;code&gt;JSON::PP::true&lt;/code&gt; and &lt;code&gt;JSON::PP::false&lt;/code&gt;, respectively. They are overloaded to act almost exactly like the numbers &lt;code&gt;1&lt;/code&gt; and &lt;code&gt;0&lt;/code&gt;. You can check whether a scalar is a JSON boolean by using the &lt;code&gt;JSON::PP::is_bool&lt;/code&gt; function.</source>
          <target state="translated">이러한 JSON 원자는 각각 &lt;code&gt;JSON::PP::true&lt;/code&gt; 및 &lt;code&gt;JSON::PP::false&lt;/code&gt; 가됩니다. 숫자 &lt;code&gt;1&lt;/code&gt; 과 &lt;code&gt;0&lt;/code&gt; 과 거의 똑같이 작동하도록 오버로드됩니다 . &lt;code&gt;JSON::PP::is_bool&lt;/code&gt; 함수 를 사용하여 스칼라가 JSON 부울인지 확인할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8f188e4230a9960392a0f6434bcd9cdb687b2105" translate="yes" xml:space="preserve">
          <source>These actually run the tests, analogous to the functions in Test::More.</source>
          <target state="translated">실제로 Test :: More의 기능과 유사한 테스트를 실행합니다.</target>
        </trans-unit>
        <trans-unit id="47b609b8bdbe47393836decca9fbf56107eb37fe" translate="yes" xml:space="preserve">
          <source>These all match a single codepoint with the given property. Use &lt;code&gt;\P&lt;/code&gt; in place of &lt;code&gt;\p&lt;/code&gt; to match one codepoint lacking that property.</source>
          <target state="translated">이것들은 모두 주어진 속성과 단일 코드 포인트와 일치합니다. 해당 속성이없는 하나의 코드 포인트와 일치 시키려면 &lt;code&gt;\p&lt;/code&gt; 대신 &lt;code&gt;\P&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="14b0e821748bdb374700b2c0b377f04dafebe4c2" translate="yes" xml:space="preserve">
          <source>These all might have problems handling infinity right.</source>
          <target state="translated">이 모든 것들은 무한대로 처리하는 데 문제가있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f193401280223b6d90ef40113a3483800172634b" translate="yes" xml:space="preserve">
          <source>These are Locale::Maketext's assumptions about the class hierarchy formed by all your language classes:</source>
          <target state="translated">다음은 모든 언어 클래스에 의해 형성된 클래스 계층 구조에 대한 Locale :: Maketext의 가정입니다.</target>
        </trans-unit>
        <trans-unit id="7d93f149b189abdf70833601535a585584795222" translate="yes" xml:space="preserve">
          <source>These are Perl bindings for the Gtk toolkit ( &lt;a href=&quot;http://www.gtk.org&quot;&gt;http://www.gtk.org&lt;/a&gt; ). The interface changed significantly between versions 1 and 2 so they have separate Perl modules. It runs under Unix, Win32 and Mac OS X (currently it requires an X server on Mac OS, but a 'native' port is underway), and the widgets look the same on every platform: i.e., they don't match the native widgets. As with Wx, the Perl bindings follow the C API closely, and the documentation requires you to read the C documentation to understand it.</source>
          <target state="translated">Gtk 툴킷 ( &lt;a href=&quot;http://www.gtk.org&quot;&gt;http://www.gtk.org&lt;/a&gt; )에 대한 Perl 바인딩입니다 . 인터페이스는 버전 1과 2 사이에서 크게 변경되었으므로 별도의 Perl 모듈이 있습니다. Unix, Win32 및 Mac OS X에서 실행되며 (현재 Mac OS에서 X 서버가 필요하지만 '기본'포트가 진행 중입니다) 위젯은 모든 플랫폼에서 동일하게 보입니다. 즉, 기본 플랫폼과 일치하지 않습니다. 위젯. Wx와 마찬가지로 Perl 바인딩은 C API를 밀접하게 따르므로 설명서를 이해하려면 C 설명서를 읽어야합니다.</target>
        </trans-unit>
        <trans-unit id="06cca08d46609adb849cad691c3d195ff57274e9" translate="yes" xml:space="preserve">
          <source>These are a few notes describing features peculiar to Plan 9 Perl. As such, it is not intended to be a replacement for the rest of the Perl 5 documentation (which is both copious and excellent). If you have any questions to which you can't find answers in these man pages, contact Luther Huffman at lutherh@stratcom.com and we'll try to answer them.</source>
          <target state="translated">다음은 Plan 9 Perl 특유의 기능을 설명하는 몇 가지 참고 사항입니다. 따라서이 문서는 나머지 Perl 5 문서를 대체하기위한 것이 아닙니다 (이 문서는 풍부하고 훌륭합니다). 이 매뉴얼 페이지에서 답변을 찾을 수없는 질문이있는 경우 lutherhuffman (lutherh@stratcom.com)에 문의하면 답변을 드리겠습니다.</target>
        </trans-unit>
        <trans-unit id="035e487505e2bd7d2a574e14eebe3b30a69fa1a9" translate="yes" xml:space="preserve">
          <source>These are a hotchpotch of opcodes still waiting to be considered</source>
          <target state="translated">이것들은 여전히 ​​고려되기를 기다리는 opcode의 핫치 포치입니다.</target>
        </trans-unit>
        <trans-unit id="7deedf4836f35aa67f0c08100f5d4987addf81e4" translate="yes" xml:space="preserve">
          <source>These are a record of the hubs an event passes through. Most recent hub is the first one in the list.</source>
          <target state="translated">이벤트가 통과하는 허브의 기록입니다. 가장 최근의 허브가 목록의 첫 번째 허브입니다.</target>
        </trans-unit>
        <trans-unit id="ab597ea19704a4092bef6ea8610d0145fc3acd27" translate="yes" xml:space="preserve">
          <source>These are all &quot;getters&quot; which return the data set for these attributes during object construction.</source>
          <target state="translated">이들은 모두 &quot;게터 (getter)&quot;로, 객체 구성 중 이러한 속성에 대한 데이터 세트를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="99670b79a346a2bf9e4cb33dd6b8ba8a01dd0f06" translate="yes" xml:space="preserve">
          <source>These are all imported from &lt;a href=&quot;Test2::Util::Facets2Legacy&quot;&gt;Test2::Util::Facets2Legacy&lt;/a&gt;, see that module or &lt;a href=&quot;Test2::Event&quot;&gt;Test2::Event&lt;/a&gt; for documentation on what they do.</source>
          <target state="translated">이들은 모두 &lt;a href=&quot;Test2::Util::Facets2Legacy&quot;&gt;Test2 :: Util :: Facets2Legacy&lt;/a&gt; 에서 가져옵니다. 해당 모듈 또는 &lt;a href=&quot;Test2::Event&quot;&gt;Test2 :: Event&lt;/a&gt; 에서 수행하는 작업에 대한 문서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c6ad141ea95625d5f83dc60a511981417685e463" translate="yes" xml:space="preserve">
          <source>These are also the typical steps involved in writing a computer program. This makes perfect sense, because regular expressions are essentially programs written in a little computer language that specifies patterns.</source>
          <target state="translated">컴퓨터 프로그램 작성과 관련된 일반적인 단계이기도합니다. 정규 표현식은 본질적으로 패턴을 지정하는 작은 컴퓨터 언어로 작성된 프로그램이기 때문에 이것은 완벽하게 이해됩니다.</target>
        </trans-unit>
        <trans-unit id="c614a56da53c8268e03927a0382855aa589c9ffe" translate="yes" xml:space="preserve">
          <source>These are alternate syntaxes for &lt;code&gt;decode('utf8', ...)&lt;/code&gt; and &lt;code&gt;encode('utf8',
...)&lt;/code&gt; .</source>
          <target state="translated">이것은 &lt;code&gt;decode('utf8', ...)&lt;/code&gt; 및 &lt;code&gt;encode('utf8', ...)&lt;/code&gt; 대체 구문입니다 .</target>
        </trans-unit>
        <trans-unit id="1c836f0954439914f97915361085c611a4a6522e" translate="yes" xml:space="preserve">
          <source>These are alternate syntaxes for &lt;code&gt;decode('utf8', ...)&lt;/code&gt; and &lt;code&gt;encode('utf8', ...)&lt;/code&gt;. Do not use these functions for data exchange. Instead use &lt;code&gt;decode('UTF-8', ...)&lt;/code&gt; and &lt;code&gt;encode('UTF-8', ...)&lt;/code&gt;; see &lt;a href=&quot;#What%27s-the-difference-between-UTF-8-and-utf8%3F&quot;&gt;&quot;What's the difference between UTF-8 and utf8?&quot;&lt;/a&gt; below.</source>
          <target state="translated">이들은 &lt;code&gt;decode('utf8', ...)&lt;/code&gt; 및 &lt;code&gt;encode('utf8', ...)&lt;/code&gt; 대한 대체 구문입니다 . 이러한 기능을 데이터 교환에 사용하지 마십시오. 대신 &lt;code&gt;decode('UTF-8', ...)&lt;/code&gt; 및 &lt;code&gt;encode('UTF-8', ...)&lt;/code&gt; ; 참조 &lt;a href=&quot;#What%27s-the-difference-between-UTF-8-and-utf8%3F&quot;&gt;&quot;UTF-8과 UTF-8의 차이점은 무엇입니까?&quot; &lt;/a&gt;이하.</target>
        </trans-unit>
        <trans-unit id="a504c2130962ba4555e63c517df7cfb6c3415a56" translate="yes" xml:space="preserve">
          <source>These are based on what command.com does on Win98. They may be wrong for other Windows shells, I don't know.</source>
          <target state="translated">Win98에서 command.com이 수행하는 작업을 기반으로합니다. 다른 Windows 셸에서는 잘못되었을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2c07d55f7a2a925e22fec82104bd39d3cabc4301" translate="yes" xml:space="preserve">
          <source>These are called mid-endian, middle-endian, mixed-endian, or just weird.</source>
          <target state="translated">이들은 중간 엔디안, 중간 엔디안, 혼합 엔디안 또는 이상하게 불립니다.</target>
        </trans-unit>
        <trans-unit id="e533ef7489d17854e05259c84118c5f3b5f226af" translate="yes" xml:space="preserve">
          <source>These are called whenever a context is initialized. That means when a new instance is created. These hooks are &lt;b&gt;NOT&lt;/b&gt; called every time something requests a context, just when a new one is created.</source>
          <target state="translated">컨텍스트가 초기화 될 때마다 호출됩니다. 즉, 새 인스턴스가 생성 될 때를 의미합니다. 이러한 후크는 새 컨텍스트가 생성 될 때 컨텍스트를 요청할 때마다 호출 &lt;b&gt;되지 않습니다&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="c0e21c37ef5bc936dc62910a2c3001a6fca894bc" translate="yes" xml:space="preserve">
          <source>These are called whenever a context is released. That means when the last reference to the instance is about to be destroyed. These hooks are &lt;b&gt;NOT&lt;/b&gt; called every time &lt;code&gt;$ctx-&amp;gt;release&lt;/code&gt; is called.</source>
          <target state="translated">컨텍스트가 해제 될 때마다 호출됩니다. 즉, 인스턴스에 대한 마지막 참조가 파괴 될 때를 의미합니다. 이러한 후크는 &lt;code&gt;$ctx-&amp;gt;release&lt;/code&gt; 가 호출 될 때마다 호출 &lt;b&gt;되지 않습니다&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="3a9105b34a20a7fdd4e6d997e3a1e1ad31f3f321" translate="yes" xml:space="preserve">
          <source>These are covered in the following section.</source>
          <target state="translated">이것들은 다음 섹션에서 다룹니다.</target>
        </trans-unit>
        <trans-unit id="7333c3db6eebc965b9acc79a29ea8b8aa13ff1d3" translate="yes" xml:space="preserve">
          <source>These are derived by using &lt;code&gt;strftime()&lt;/code&gt;, and not all versions of that function know about them. &lt;code&gt;&quot;&quot;&lt;/code&gt; is returned for these on such systems.</source>
          <target state="translated">이들은 &lt;code&gt;strftime()&lt;/code&gt; 을 사용하여 파생되며 해당 함수의 모든 버전이 이에 대해 알고있는 것은 아닙니다. 이러한 시스템에서는 &lt;code&gt;&quot;&quot;&lt;/code&gt; 가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="543fcf9df34b75f159b226a9706c32a67f612f3d" translate="yes" xml:space="preserve">
          <source>These are effectively no-ops.</source>
          <target state="translated">이들은 사실상 아무런 문제가 없습니다.</target>
        </trans-unit>
        <trans-unit id="f6dbfbbee534ca87c61eabe600b034f42390dde5" translate="yes" xml:space="preserve">
          <source>These are equivalent</source>
          <target state="translated">이것들은 동등합니다</target>
        </trans-unit>
        <trans-unit id="2c34193d065093cc77699a0d9ca713a7565b5a4e" translate="yes" xml:space="preserve">
          <source>These are fetched from one or more mirrored CPAN (Comprehensive Perl Archive Network) sites and unpacked in a dedicated directory.</source>
          <target state="translated">이들은 하나 이상의 미러링 된 CPAN (Comprehensive Perl Archive Network) 사이트에서 가져 와서 전용 디렉토리에서 압축을 풉니 다.</target>
        </trans-unit>
        <trans-unit id="1218c4eafb2ac24b7f5a6bfc47e38d53cda6dbb8" translate="yes" xml:space="preserve">
          <source>These are fprintf()/vfprintf() equivalents.</source>
          <target state="translated">이들은 fprintf () / vfprintf ()에 해당합니다.</target>
        </trans-unit>
        <trans-unit id="c9080846b04ed2aaef61ea34f53f7101d2c5f347" translate="yes" xml:space="preserve">
          <source>These are functions for searching through directory trees doing work on each file found similar to the Unix</source>
          <target state="translated">유닉스와 비슷한 것으로 보이는 각 파일에 대한 작업을 수행하는 디렉토리 트리를 검색하는 기능입니다</target>
        </trans-unit>
        <trans-unit id="82d3c39fd0ecabf1c8dc2de9284d7be1c98f1d46" translate="yes" xml:space="preserve">
          <source>These are general guidelines for how to write POD documentation for Perl scripts and modules, based on general guidelines for writing good UNIX man pages. All of these guidelines are, of course, optional, but following them will make your documentation more consistent with other documentation on the system.</source>
          <target state="translated">다음은 좋은 UNIX 매뉴얼 페이지 작성을위한 일반 지침을 기반으로 Perl 스크립트 및 모듈에 대한 POD 문서를 작성하는 방법에 대한 일반적인 지침입니다. 이 모든 지침은 물론 선택 사항이지만 지침을 따르면 시스템의 다른 문서와보다 일관성있게 문서를 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a253bda8befb626a9c36c82d1823fdc871bc54a9" translate="yes" xml:space="preserve">
          <source>These are hooks that allow you to add custom behavior to actions taken by Test2 and tools built on top of it.</source>
          <target state="translated">Test2에서 수행 한 작업과 그 위에 빌드 된 도구에 사용자 지정 동작을 추가 할 수있는 후크입니다.</target>
        </trans-unit>
        <trans-unit id="dad0e81d2d1dfbeb7b354f138de6b73ae95d9158" translate="yes" xml:space="preserve">
          <source>These are instructions for building Perl from source. This version of Perl requires the dynamic linking support that is found in OpenVOS Release 17.1 and thus is not supported on OpenVOS Release 17.0 or earlier releases.</source>
          <target state="translated">다음은 소스에서 Perl을 빌드하기위한 지시 사항입니다. 이 버전의 Perl에는 OpenVOS 릴리스 17.1에있는 동적 링크 지원이 필요하므로 OpenVOS 릴리스 17.0 또는 이전 릴리스에서는 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c8591b5e35cdacaa99ac7aebf4d9655f41e44d08" translate="yes" xml:space="preserve">
          <source>These are instructions for building Perl under DOS (or w??), using DJGPP v2.03 or later. Under w95 long filenames are supported.</source>
          <target state="translated">다음은 DJGPP v2.03 이상을 사용하여 DOS (또는 w ??)에서 Perl을 빌드하기위한 지시 사항입니다. w95에서 긴 파일 이름이 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="1ebba6a1db0c9a0e274e92574c949eaf7a4b8fb7" translate="yes" xml:space="preserve">
          <source>These are instructions for building Perl under Windows 2000 and later.</source>
          <target state="translated">다음은 Windows 2000 이상에서 Perl을 빌드하기위한 지시 사항입니다.</target>
        </trans-unit>
        <trans-unit id="56039c5fbea93b2739212ecaf27c30cc3edfb9c5" translate="yes" xml:space="preserve">
          <source>These are intended to be services performed by the clients of this API.</source>
          <target state="translated">이것들은이 API의 클라이언트가 수행하는 서비스입니다.</target>
        </trans-unit>
        <trans-unit id="6d5e58ad94dd8e12f40343c4fe00cb855a20e455" translate="yes" xml:space="preserve">
          <source>These are just the most common definitions of &lt;code&gt;\n&lt;/code&gt; and &lt;code&gt;\r&lt;/code&gt; in Perl. There may well be others. For example, on an EBCDIC implementation such as z/OS (OS/390) or OS/400 (using the ILE, the PASE is ASCII-based) the above material is similar to &quot;Unix&quot; but the code numbers change:</source>
          <target state="translated">이것은 Perl에서 가장 일반적인 &lt;code&gt;\n&lt;/code&gt; 및 &lt;code&gt;\r&lt;/code&gt; 정의입니다 . 다른 사람들도있을 수 있습니다. 예를 들어, z / OS (OS / 390) 또는 OS / 400과 같은 EBCDIC 구현 (ILE를 사용하여 PASE는 ASCII 기반 임)에서 위 자료는 &quot;Unix&quot;와 유사하지만 코드 번호가 변경됩니다.</target>
        </trans-unit>
        <trans-unit id="e2a1ebead9f267c39fe9da94bb4791dac090d0bc" translate="yes" xml:space="preserve">
          <source>These are low-level functions to extract and use capabilities from a terminal capability (termcap) database.</source>
          <target state="translated">이들은 터미널 기능 (termcap) 데이터베이스에서 기능을 추출하고 사용하기위한 저수준 기능입니다.</target>
        </trans-unit>
        <trans-unit id="6e1b104453fcd9be9aa03bca5a6390babe809d8b" translate="yes" xml:space="preserve">
          <source>These are methods that you may find it handy to use, generally from %Lexicon routines of yours (whether expressed as Bracket Notation or not).</source>
          <target state="translated">이것들은 일반적으로 당신의 % Lexicon 루틴 (브래킷 표기법으로 표현 되든 아니든)에서 사용하기 편리한 방법입니다.</target>
        </trans-unit>
        <trans-unit id="9a95859137ef50d66689fe259453639b6dce722a" translate="yes" xml:space="preserve">
          <source>These are methods which are used in the course of writing a test but are not themselves tests.</source>
          <target state="translated">이것들은 테스트 작성 과정에서 사용되는 방법이지만 자체 테스트는 아닙니다.</target>
        </trans-unit>
        <trans-unit id="14859e3783966bf81d1767be73584f0ff1e6b683" translate="yes" xml:space="preserve">
          <source>These are methods which help writing cross-platform code.</source>
          <target state="translated">크로스 플랫폼 코드 작성에 도움이되는 메소드입니다.</target>
        </trans-unit>
        <trans-unit id="10fcdff63f0636b8e542860baaf4e1184f58638e" translate="yes" xml:space="preserve">
          <source>These are methods which produce make targets.</source>
          <target state="translated">이것들은 make target을 만드는 방법입니다.</target>
        </trans-unit>
        <trans-unit id="10849203134f1b9b6877d6c9803884e2fb3562a9" translate="yes" xml:space="preserve">
          <source>These are modules that did not break, but had broken test suites that have since been fixed.</source>
          <target state="translated">이는 중단되지 않았지만 이후 수정 된 테스트 스위트가 중단 된 모듈입니다.</target>
        </trans-unit>
        <trans-unit id="5242bfa15c97f14acba2cd2d00dbeca39084930f" translate="yes" xml:space="preserve">
          <source>These are most easily explained from the bottom up.</source>
          <target state="translated">이것들은 아래에서 가장 쉽게 설명됩니다.</target>
        </trans-unit>
        <trans-unit id="97c6eb63dac1e7db10f1e2e9276ff1ad9b5b7b24" translate="yes" xml:space="preserve">
          <source>These are not supplied by default, but must be explicitly imported. They are lexically scoped.</source>
          <target state="translated">기본적으로 제공되지 않지만 명시 적으로 가져와야합니다. 어휘 적으로 범위가 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="eff3d42df745b107b6d797477e3d4e7f8d24cab3" translate="yes" xml:space="preserve">
          <source>These are not the very basics, though. It is assumed that you already know the difference between bytes and characters, and realise (and accept!) that there are many different character sets and encodings, and that your program has to be explicit about them. Recommended reading is &quot;The Absolute Minimum Every Software Developer Absolutely, Positively Must Know About Unicode and Character Sets (No Excuses!)&quot; by Joel Spolsky, at &lt;a href=&quot;http://joelonsoftware.com/articles/Unicode.html&quot;&gt;http://joelonsoftware.com/articles/Unicode.html&lt;/a&gt;.</source>
          <target state="translated">그러나 이것들은 기본적인 것이 아닙니다. 바이트와 ​​문자의 차이점을 이미 알고 있으며 문자 세트와 인코딩이 많이 있으며 프로그램에 명시해야한다는 것을 알고 있습니다. 권장 사항은 Joel Spolsky ( &lt;a href=&quot;http://joelonsoftware.com/articles/Unicode.html&quot;&gt;http://joelonsoftware.com/articles/Unicode.html&lt;/a&gt; )의 &quot;절대적으로 모든 소프트웨어 개발자는 절대적으로 유니 코드 및 문자 집합에 대해 알아야합니다 (변명 없음!)&quot; 입니다.</target>
        </trans-unit>
        <trans-unit id="cd6ee1d320e203631c0d3d164abcb5a87fff3dcb" translate="yes" xml:space="preserve">
          <source>These are often used in macro definitions. Note that you can't return a value out of them.</source>
          <target state="translated">이들은 종종 매크로 정의에 사용됩니다. 값을 반환 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="3cbc1741b6d34271e2ec1a26ca7d6418baa0ebb4" translate="yes" xml:space="preserve">
          <source>These are only present when &lt;code&gt;netorder&lt;/code&gt; is FALSE. These are the sizes of various C datatypes of the perl that created this image. These must match the current perl for the image to be readable by Storable.</source>
          <target state="translated">&lt;code&gt;netorder&lt;/code&gt; 가 FALSE 인 경우에만 존재 합니다. 이들은이 이미지를 생성 한 perl의 다양한 C 데이터 유형의 크기입니다. Storable이 이미지를 읽을 수 있으려면 현재 perl과 일치해야합니다.</target>
        </trans-unit>
        <trans-unit id="920887e803f6cf14e09050db36f20df3c6ead9d1" translate="yes" xml:space="preserve">
          <source>These are only supported if your system has &amp;lt;</source>
          <target state="translated">시스템에 &amp;lt;</target>
        </trans-unit>
        <trans-unit id="140e31bd5bffd898fd2913825a2d2d23dcf95138" translate="yes" xml:space="preserve">
          <source>These are pairwise exclusive, i.e. compact or loose, vt or ascii.</source>
          <target state="translated">이것들은 쌍으로 배타적입니다.</target>
        </trans-unit>
        <trans-unit id="ee44bfea63f0502e44e3769d9962bf8126742be7" translate="yes" xml:space="preserve">
          <source>These are passed in to your plugin's &lt;code&gt;load()&lt;/code&gt; class method (if it has one), along with a reference to the &lt;code&gt;App::Prove&lt;/code&gt; object that is invoking your plugin:</source>
          <target state="translated">이들은 플러그인을 호출 하는 &lt;code&gt;App::Prove&lt;/code&gt; 객체에 대한 참조와 함께 플러그인의 &lt;code&gt;load()&lt;/code&gt; 클래스 메소드 (있는 경우 )에 전달됩니다 .</target>
        </trans-unit>
        <trans-unit id="0a54cca37ec252d12e0edbfcecfc7fffff46a74a" translate="yes" xml:space="preserve">
          <source>These are probematic. The C standard says that these should be considered punctuation in the C locale (and the POSIX standard defers to the C standard), and Unicode is generally considered a superset of the C locale. But Unicode has added an extra category, &quot;Symbol&quot;, and classifies these particular characters as being symbols. Most UTF-8 locales have them treated as punctuation, so that &lt;a href=&quot;http://man.he.net/man2/ispunct&quot;&gt;ispunct(2)&lt;/a&gt; returns non-zero for them. But a few locales have it return 0. Perl takes the first approach, not using &lt;code&gt;ispunct()&lt;/code&gt; at all (see &lt;a href=&quot;perlrecharclass#%5B5%5D&quot;&gt;Note [5] in perlrecharclass&lt;/a&gt;), and this message is raised to notify you that you are getting Perl's approach, not the locale's.</source>
          <target state="translated">이것들은 탐침입니다. C 표준은 C 로케일에서 구두점으로 간주되어야한다고 말하고 있으며 (POSIX 표준은 C 표준을 따릅니다) 유니 코드는 일반적으로 C 로케일의 상위 세트로 간주됩니다. 그러나 유니 코드는 &quot;기호&quot;라는 추가 범주를 추가하고 이러한 특정 문자를 기호로 분류합니다. 대부분의 UTF-8 로케일은 구두점으로 처리되므로 &lt;a href=&quot;http://man.he.net/man2/ispunct&quot;&gt;ispunct (2)&lt;/a&gt; 는 0이 아닌 값을 리턴합니다. 그러나 몇몇 로케일에서는 0을 반환합니다. Perl은 &lt;code&gt;ispunct()&lt;/code&gt; 를 전혀 사용하지 않고 첫 번째 접근 방식을 취하고 ( &lt;a href=&quot;perlrecharclass#%5B5%5D&quot;&gt;perlrecharclass의 Note [5]&lt;/a&gt; 참조 )이 메시지는 로케일이 아닌 Perl의 접근 방식을 얻고 있음을 알리기 위해 발생합니다. .</target>
        </trans-unit>
        <trans-unit id="87db38161fab9301a6c38e350a75487ce9dba0c7" translate="yes" xml:space="preserve">
          <source>These are readline issues and can only be fixed by studying readline configuration on your architecture and adjusting the referenced file accordingly. Please make a backup of the &lt;code&gt;/etc/inputrc&lt;/code&gt; or &lt;code&gt;~/.inputrc&lt;/code&gt; and edit them. Quite often harmless changes like uppercasing or lowercasing some arguments solves the problem.</source>
          <target state="translated">이러한 문제는 readline 문제이며 아키텍처에서 readline 구성을 연구하고 이에 따라 참조 된 파일을 조정해야만 해결할 수 있습니다. &lt;code&gt;/etc/inputrc&lt;/code&gt; 또는 &lt;code&gt;~/.inputrc&lt;/code&gt; 를 백업 하고 편집하십시오. 어떤 주장을 대문자로 바꾸거나 소문자로 바꾸는 것과 같이 무해한 변화는 종종 문제를 해결합니다.</target>
        </trans-unit>
        <trans-unit id="b38ff2c237d2189cfc8068063c988ad558800625" translate="yes" xml:space="preserve">
          <source>These are scripts which will check the source things like ANSI C violations, POD encoding issues, etc.</source>
          <target state="translated">이것은 ANSI C 위반, POD 인코딩 문제 등과 같은 소스를 확인하는 스크립트입니다.</target>
        </trans-unit>
        <trans-unit id="08a1e3d5222d26c7ad00377b2f49dd3e19a69282" translate="yes" xml:space="preserve">
          <source>These are shortcuts for &lt;code&gt;$token-&amp;gt;tag() eq &lt;i&gt;somestring&lt;/i&gt;&lt;/code&gt;</source>
          <target state="translated">이것들은 &lt;code&gt;$token-&amp;gt;tag() eq &lt;i&gt;somestring&lt;/i&gt;&lt;/code&gt; &lt;i&gt;somestring에&lt;/i&gt; 대한 지름길입니다&lt;i&gt;&lt;/i&gt;</target>
        </trans-unit>
        <trans-unit id="34937e959a1c366f5128e5b9fde3a8ddb4bd5e6f" translate="yes" xml:space="preserve">
          <source>These are similar to article(), body() and head(), but rather than returning the requested data directly, they return a tied filehandle from which to read the article.</source>
          <target state="translated">이들은 article (), body () 및 head ()와 유사하지만 요청 된 데이터를 직접 반환하지 않고 기사를 읽을 수있는 묶인 파일 핸들을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="992979db9b32df20ed312f9df292c8122981c5bf" translate="yes" xml:space="preserve">
          <source>These are the files in the Perl release that contain references to Cygwin. These very brief notes attempt to explain the reason for all conditional code. Hopefully, keeping this up to date will allow the Cygwin port to be kept as clean as possible.</source>
          <target state="translated">Cygwin에 대한 참조가 포함 된 Perl 릴리스의 파일입니다. 이 간단한 노트는 모든 조건부 코드의 이유를 설명하려고 시도합니다. 이 업데이트를 최신 상태로 유지하면 Cygwin 포트를 최대한 깨끗하게 유지할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="75ac46c3e2da8e520c552d106b13b25422f4ae84" translate="yes" xml:space="preserve">
          <source>These are the functions that are available, they may either be called as functions or class methods:</source>
          <target state="translated">사용 가능한 함수는 함수 또는 클래스 메소드로 호출 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="da1f03a776fe8bedafea0b23935ca2ad13f5c2fe" translate="yes" xml:space="preserve">
          <source>These are the hash data structures that are available:</source>
          <target state="translated">사용 가능한 해시 데이터 구조는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="cf5f4459a98cf4ec50466a764ec50e3aa2bdb1de" translate="yes" xml:space="preserve">
          <source>These are the newest form of versions, and correspond to Perl's own version style beginning with 5.6.0. Starting with Perl 5.10.0, and most likely Perl 6, this is likely to be the preferred form. This method normally requires that the input parameter be quoted, although Perl's after 5.8.1 can use v-strings as a special form of quoting, but this is highly discouraged.</source>
          <target state="translated">이것은 최신 버전의 버전이며 5.6.0으로 시작하는 Perl의 자체 버전 스타일에 해당합니다. Perl 5.10.0부터 시작하여 Perl 6 일 가능성이 가장 높으며 이것이 선호되는 형식입니다. 이 방법은 일반적으로 입력 매개 변수를 인용해야하지만, 5.8.1 이후의 Perl은 v- 문자열을 특수한 인용 형식으로 사용할 수 있지만 이는 매우 권장되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="321abf696e1ac3f1c7e8ae4631a3e0352eed8069" translate="yes" xml:space="preserve">
          <source>These are the same as color('attribute') and can be used if you prefer typing:</source>
          <target state="translated">이들은 color ( 'attribute')와 동일하며 입력을 선호하는 경우 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4187810dcd65ec8ff13d408cac42774a760ce9e6" translate="yes" xml:space="preserve">
          <source>These are the signals which a program might normally expect to encounter and which by default cause it to terminate. They are HUP, INT, PIPE and TERM.</source>
          <target state="translated">이들은 일반적으로 프로그램에서 발생할 것으로 예상되는 신호이며 기본적으로 프로그램을 종료시킵니다. 그들은 HUP, INT, PIPE 및 TERM입니다.</target>
        </trans-unit>
        <trans-unit id="50c4067312fedca516066cb81563c6787bf50478" translate="yes" xml:space="preserve">
          <source>These are the signals which were trapped by default by the old &lt;b&gt;sigtrap&lt;/b&gt; interface, they are ABRT, BUS, EMT, FPE, ILL, PIPE, QUIT, SEGV, SYS, TERM, and TRAP. If no signals or signals lists are passed to &lt;b&gt;sigtrap&lt;/b&gt;, this list is used.</source>
          <target state="translated">이들은 이전 &lt;b&gt;sigtrap&lt;/b&gt; 인터페이스에 의해 기본적으로 트랩 된 신호이며 ABRT, BUS, EMT, FPE, ILL, PIPE, QUIT, SEGV, SYS, TERM 및 TRAP입니다. 신호 또는 신호 목록이 &lt;b&gt;sigtrap&lt;/b&gt; 으로 전달되지 않은 경우&lt;b&gt;&lt;/b&gt; 이 목록이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="cea91aaa564fccd3f4852969e3ebc12f20249663" translate="yes" xml:space="preserve">
          <source>These are the six methods that are exported as default.</source>
          <target state="translated">기본적으로 내보내는 6 가지 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="107044185540681260f831f30270844d122d9842" translate="yes" xml:space="preserve">
          <source>These are the things that you can put in the parameters to plan:</source>
          <target state="translated">다음은 계획 할 매개 변수에 넣을 수있는 것입니다.</target>
        </trans-unit>
        <trans-unit id="cae5aa495786f78d7786c67162eeac298ded8720" translate="yes" xml:space="preserve">
          <source>These are to do with constructing a language handle:</source>
          <target state="translated">언어 핸들 구성과 관련이 있습니다.</target>
        </trans-unit>
        <trans-unit id="922c34b791a974e411c2469dcdbd7774f0e10924" translate="yes" xml:space="preserve">
          <source>These are used to get/set the 'active' attribute. When true this attribute will force &lt;code&gt;hub-&amp;gt;finalize()&lt;/code&gt; to take action even if there is no plan, and no tests have been run. This flag is useful for plugins that add follow-up behaviors that need to run even if no events are seen.</source>
          <target state="translated">이들은 '활성'속성을 가져 오거나 설정하는 데 사용됩니다. true 인 경우이 속성은 계획이없고 테스트가 실행되지 않은 경우에도 &lt;code&gt;hub-&amp;gt;finalize()&lt;/code&gt; 가 조치를 취하도록합니다. 이 플래그는 이벤트가 표시되지 않더라도 실행해야하는 후속 동작을 추가하는 플러그인에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="25e9dcb05d530b0eaaf353a6122269805fd5136a" translate="yes" xml:space="preserve">
          <source>These are useful shortcuts to save on the typing.</source>
          <target state="translated">입력시 저장하는 유용한 바로 가기입니다.</target>
        </trans-unit>
        <trans-unit id="20957167192887677e71195c4861c8a5596fbdd0" translate="yes" xml:space="preserve">
          <source>These are valid only on ASCII platforms. Starting in Perl v5.22, simply changing the octal constants to equivalent &lt;code&gt;\N{U+...}&lt;/code&gt; values makes them portable:</source>
          <target state="translated">이들은 ASCII 플랫폼에서만 유효합니다. Perl v5.22부터는 8 진 상수를 &lt;code&gt;\N{U+...}&lt;/code&gt; 변경하면됩니다 . 값으로 변경하면 이식성이 향상됩니다.</target>
        </trans-unit>
        <trans-unit id="121235b5fae01f0300690949bf870a51f4a735f5" translate="yes" xml:space="preserve">
          <source>These are various utility functions for manipulating UTF8-encoded strings. For the uninitiated, this is a method of representing arbitrary Unicode characters as a variable number of bytes, in such a way that characters in the ASCII range are unmodified, and a zero byte never appears within non-zero characters.</source>
          <target state="translated">UTF8로 인코딩 된 문자열을 조작하기위한 다양한 유틸리티 함수입니다. 시작되지 않은 경우 이것은 ASCII 범위의 문자가 수정되지 않고 0이 아닌 문자 내에 0 바이트가 나타나지 않는 방식으로 임의의 유니 코드 문자를 가변 바이트 수로 나타내는 방법입니다.</target>
        </trans-unit>
        <trans-unit id="a8c3820acf49b8050b73972a9c61ce1cf6f1d9df" translate="yes" xml:space="preserve">
          <source>These are versions of the macros which take an explicit interpreter as an argument.</source>
          <target state="translated">이들은 명시 적 인터프리터를 인수로 취하는 매크로 버전입니다.</target>
        </trans-unit>
        <trans-unit id="b056cc5f487123530dc637016a4d1c22c28e035c" translate="yes" xml:space="preserve">
          <source>These are:</source>
          <target state="translated">이것들은:</target>
        </trans-unit>
        <trans-unit id="16d16f3cffc4ac9689654ee5a738c8ecadd74b82" translate="yes" xml:space="preserve">
          <source>These can all be disabled with</source>
          <target state="translated">이것들은 모두 비활성화 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="e41fb2d0ecca05f4e2a4a44f51aab35f28ed5c33" translate="yes" xml:space="preserve">
          <source>These can be combined into a single regexp with a three-way alternation:</source>
          <target state="translated">이들은 3 방향 교대로 단일 정규식으로 결합 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="172164005a20965708fb5481ccabdedd39caefb5" translate="yes" xml:space="preserve">
          <source>These can be imported, or called as methods on the class.</source>
          <target state="translated">이들은 가져 오거나 클래스의 메서드로 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="299d50e1fb824778d0759c0f08b0488ba008e1c8" translate="yes" xml:space="preserve">
          <source>These can be used to add filters. Filters can modify, replace, or remove events before anything else can see them.</source>
          <target state="translated">필터를 추가하는 데 사용할 수 있습니다. 필터는 다른 사람이 이벤트를보기 전에 이벤트를 수정, 교체 또는 제거 할 수 있습니다. ㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ</target>
        </trans-unit>
        <trans-unit id="4eeb7ad8186044a1f9cb1af61a0f21c3ae49622d" translate="yes" xml:space="preserve">
          <source>These can be used to remove filters and pre_filters. The &lt;code&gt;$sub&lt;/code&gt; argument is the reference returned by &lt;code&gt;filter()&lt;/code&gt; or &lt;code&gt;pre_filter()&lt;/code&gt;.</source>
          <target state="translated">필터 및 pre_filter를 제거하는 데 사용할 수 있습니다. &lt;code&gt;$sub&lt;/code&gt; 인수에 의해 반환 된 참조가 &lt;code&gt;filter()&lt;/code&gt; 또는 &lt;code&gt;pre_filter()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3356ead5e79e95f8cf87a7aefe66f6dc48400c35" translate="yes" xml:space="preserve">
          <source>These can be used to turn IPC waiting on and off, or check the current value of the flag.</source>
          <target state="translated">IPC 대기를 켜고 끄거나 플래그의 현재 값을 확인하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="70b66993a553be0939fc1c087fcb0c54c5cdbbb0" translate="yes" xml:space="preserve">
          <source>These cases below violate the &quot;remainder has the sign of the second of the two arguments&quot;, since they wouldn't match up otherwise.</source>
          <target state="translated">아래의 이러한 경우는 &quot;리마인더가 두 개의 인수 중 두 번째 인수의 부호를 갖습니다&quot;를 위반하는 것입니다. 그렇지 않으면 일치하지 않기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="1fd6f63888a958514d8ebfc5074b3f479f8a49f9" translate="yes" xml:space="preserve">
          <source>These classes correspond in the obvious way to the underlying C structures of similar names. The inheritance hierarchy mimics the underlying C &quot;inheritance&quot;:</source>
          <target state="translated">이러한 클래스는 명백한 방식으로 유사한 이름의 기본 C 구조에 해당합니다. 상속 계층은 기본 C &quot;상속&quot;을 모방합니다.</target>
        </trans-unit>
        <trans-unit id="5f11a03556aad53a0a7bc63133f793375ad1dc66" translate="yes" xml:space="preserve">
          <source>These code blocks can be prefixed with &lt;code&gt;&lt;a href=&quot;functions/sub&quot;&gt;sub&lt;/a&gt;&lt;/code&gt; to give the appearance of a subroutine (although this is not considered good style). One should note that these code blocks don't really exist as named subroutines (despite their appearance). The thing that gives this away is the fact that you can have &lt;b&gt;more than one&lt;/b&gt; of these code blocks in a program, and they will get &lt;b&gt;all&lt;/b&gt; executed at the appropriate moment. So you can't execute any of these code blocks by name.</source>
          <target state="translated">이 코드 블록은 &lt;code&gt;&lt;a href=&quot;functions/sub&quot;&gt;sub&lt;/a&gt;&lt;/code&gt; 로 접두어를 붙여서 서브 루틴의 모양을 만들 수 있습니다 (이것은 좋은 스타일로 간주되지는 않습니다). 이 코드 블록은 실제로 이름이 지정된 서브 루틴으로 존재하지 않습니다 (모양에도 불구하고). 이것을 제공하는 것은 프로그램에서 &lt;b&gt;하나 이상의&lt;/b&gt; 코드 블록을 가질 수 있으며 적절한 순간에 &lt;b&gt;모두&lt;/b&gt; 실행될 것 입니다. 따라서 이름으로 이러한 코드 블록을 실행할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="135b8ae6adb863f81a824e0e084d6f888cb7a313" translate="yes" xml:space="preserve">
          <source>These code blocks can be prefixed with &lt;code&gt;sub&lt;/code&gt; to give the appearance of a subroutine (although this is not considered good style). One should note that these code blocks don't really exist as named subroutines (despite their appearance). The thing that gives this away is the fact that you can have &lt;b&gt;more than one&lt;/b&gt; of these code blocks in a program, and they will get &lt;b&gt;all&lt;/b&gt; executed at the appropriate moment. So you can't execute any of these code blocks by name.</source>
          <target state="translated">이 코드 블록은 서브 루틴의 모양을 제공하기 위해 &lt;code&gt;sub&lt;/code&gt; 를 접두사로 붙일 수 있습니다 (좋은 스타일로 간주되지는 않지만). 이러한 코드 블록은 실제로 이름이 지정된 서브 루틴으로 존재하지 않는다는 점에 유의해야합니다 (모양에도 불구하고). 이를 제공하는 것은 프로그램에 이러한 코드 블록 &lt;b&gt;중 하나 이상을&lt;/b&gt; 가질 수 있으며 적절한 순간에 &lt;b&gt;모두&lt;/b&gt; 실행 된다는 사실입니다 . 따라서 이러한 코드 블록을 이름으로 실행할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="97b3b7dd37ba8a222332eb2984faedc72082d594" translate="yes" xml:space="preserve">
          <source>These commands take any number of arguments and investigate what is necessary to perform the action. Argument processing is as follows:</source>
          <target state="translated">이 명령은 여러 인수를 사용하여 조치를 수행하는 데 필요한 사항을 조사합니다. 인수 처리는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1935b5d017d485fb4c9165c42281556d84b0d309" translate="yes" xml:space="preserve">
          <source>These compile phase keywords are documented in &lt;a href=&quot;../perlmod#BEGIN%2c-UNITCHECK%2c-CHECK%2c-INIT-and-END&quot;&gt;BEGIN, UNITCHECK, CHECK, INIT and END in perlmod&lt;/a&gt;.</source>
          <target state="translated">이 컴파일 단계 키워드는 &lt;a href=&quot;../perlmod#BEGIN%2c-UNITCHECK%2c-CHECK%2c-INIT-and-END&quot;&gt;perlmod의 BEGIN, UNITCHECK, CHECK, INIT 및 END에&lt;/a&gt; 문서화되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="cfb52f790e80f5471de59b15936b8e64b57f38e3" translate="yes" xml:space="preserve">
          <source>These compile phase keywords are documented in &lt;a href=&quot;perlmod#BEGIN%2C-UNITCHECK%2C-CHECK%2C-INIT-and-END&quot;&gt;&quot;BEGIN, UNITCHECK, CHECK, INIT and END&quot; in perlmod&lt;/a&gt;.</source>
          <target state="translated">이러한 컴파일 단계 키워드는 &lt;a href=&quot;perlmod#BEGIN%2C-UNITCHECK%2C-CHECK%2C-INIT-and-END&quot;&gt;perlmod의 &quot;BEGIN, UNITCHECK, CHECK, INIT 및 END&quot;에&lt;/a&gt; 문서화되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="d7f96e99d050cd5ba24ce3555c69d5626ea1ddfe" translate="yes" xml:space="preserve">
          <source>These compile phase keywords are documented in &lt;a href=&quot;perlmod#BEGIN%2c-UNITCHECK%2c-CHECK%2c-INIT-and-END&quot;&gt;BEGIN, UNITCHECK, CHECK, INIT and END in perlmod&lt;/a&gt;.</source>
          <target state="translated">이 컴파일 단계 키워드는 &lt;a href=&quot;perlmod#BEGIN%2c-UNITCHECK%2c-CHECK%2c-INIT-and-END&quot;&gt;perlmod의 BEGIN, UNITCHECK, CHECK, INIT 및 END에&lt;/a&gt; 문서화되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="97251eb9b01071889514a18b4c3f732daa85a7b2" translate="yes" xml:space="preserve">
          <source>These constants are not imported by &lt;code&gt;IO::Compress::Zip&lt;/code&gt; by default.</source>
          <target state="translated">이 상수는 &lt;code&gt;IO::Compress::Zip&lt;/code&gt; 가져 오지 않습니다. 기본적 .</target>
        </trans-unit>
        <trans-unit id="4a9cdeb250fa9e2cb61227f4240cb75a90c2a763" translate="yes" xml:space="preserve">
          <source>These constants can also be used with fully qualified names, eg. &lt;code&gt;SDBM_File::PAGFEXT&lt;/code&gt; .</source>
          <target state="translated">이 상수는 정규화 된 이름과 함께 사용할 수도 있습니다. &lt;code&gt;SDBM_File::PAGFEXT&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="38e4d9e8ffca41ef0f0b08e38acc59353b323e18" translate="yes" xml:space="preserve">
          <source>These constants can also be used with fully qualified names, eg. &lt;code&gt;SDBM_File::PAGFEXT&lt;/code&gt;.</source>
          <target state="translated">이러한 상수는 정규화 된 이름 (예 : &lt;code&gt;SDBM_File::PAGFEXT&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b24ced089c50142be624d4fe7279d5e7e8267bf6" translate="yes" xml:space="preserve">
          <source>These conversions are governed by the following general rules:</source>
          <target state="translated">이러한 변환에는 다음과 같은 일반적인 규칙이 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="8ebb9f4990eefbf7af18e7f37f2d673045cd0b59" translate="yes" xml:space="preserve">
          <source>These conversions are invoked according to context as necessary. For example, the subroutine for &lt;code&gt;'&quot;&quot;'&lt;/code&gt; (stringify) may be used where the overloaded object is passed as an argument to &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt;, and that for &lt;code&gt;'bool'&lt;/code&gt; where it is tested in the condition of a flow control statement (like &lt;code&gt;while&lt;/code&gt; ) or the ternary &lt;code&gt;?:&lt;/code&gt; operation.</source>
          <target state="translated">이러한 변환은 필요에 따라 상황에 따라 호출됩니다. 예를 들어, 오버로드 된 객체가 &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; 인수로 전달되는 경우 &lt;code&gt;'&quot;&quot;'&lt;/code&gt; (stringify) 의 서브 루틴 과 흐름 제어 명령문의 조건에서 테스트되는 &lt;code&gt;'bool'&lt;/code&gt; 의 서브 루틴 (예 : &lt;code&gt;while&lt;/code&gt; ) 또는 삼항 &lt;code&gt;?:&lt;/code&gt; 연산.</target>
        </trans-unit>
        <trans-unit id="380117f70d82e15acd1450b3ca50a68f2d64bbe1" translate="yes" xml:space="preserve">
          <source>These conversions are invoked according to context as necessary. For example, the subroutine for &lt;code&gt;'&quot;&quot;'&lt;/code&gt; (stringify) may be used where the overloaded object is passed as an argument to &lt;code&gt;print&lt;/code&gt;, and that for &lt;code&gt;'bool'&lt;/code&gt; where it is tested in the condition of a flow control statement (like &lt;code&gt;while&lt;/code&gt;) or the ternary &lt;code&gt;?:&lt;/code&gt; operation.</source>
          <target state="translated">이러한 변환은 필요에 따라 컨텍스트에 따라 호출됩니다. 예를 들어 &lt;code&gt;'&quot;&quot;'&lt;/code&gt; (stringify)에 대한 서브 루틴 은 오버로드 된 객체가 &lt;code&gt;print&lt;/code&gt; 에 대한 인수로 전달되는 곳에서 사용될 수 있고 , &lt;code&gt;'bool'&lt;/code&gt; 에 대한 것은 흐름 제어 명령문의 조건 (예 : &lt;code&gt;while&lt;/code&gt; ) 에서 테스트되는 경우에 사용될 수 있습니다. 또는 삼항 &lt;code&gt;?:&lt;/code&gt; 연산.</target>
        </trans-unit>
        <trans-unit id="a40ed2255002784d89744404c25a8dfb75189849" translate="yes" xml:space="preserve">
          <source>These correspond (loosely) to fgetpos() and fsetpos(). Rather than stdio's Fpos_t they expect a &quot;Perl Scalar Value&quot; to be passed. What is stored there should be considered opaque. The layout of the data may vary from handle to handle. When not using stdio or if platform does not have the stdio calls then they are implemented in terms of PerlIO_tell() and PerlIO_seek().</source>
          <target state="translated">이들은 fgetpos () 및 fsetpos ()에 대응합니다. stdio의 Fpos_t 대신 &quot;Perl Scalar Value&quot;가 전달 될 것으로 예상합니다. 저장된 것은 불투명 한 것으로 간주해야합니다. 데이터의 레이아웃은 핸들마다 다를 수 있습니다. stdio를 사용하지 않거나 플랫폼에 stdio 호출이 없으면 PerlIO_tell () 및 PerlIO_seek ()로 구현됩니다.</target>
        </trans-unit>
        <trans-unit id="3ab9bc2795a0ea30e5174b44302c5f3390695af2" translate="yes" xml:space="preserve">
          <source>These correspond functionally to fread() and fwrite() but the arguments and return values are different. The PerlIO_read() and PerlIO_write() signatures have been modeled on the more sane low level read() and write() functions instead: The &quot;file&quot; argument is passed first, there is only one &quot;count&quot;, and the return value can distinguish between error and &lt;code&gt;EOF&lt;/code&gt; .</source>
          <target state="translated">이들은 기능적으로 fread () 및 fwrite ()에 해당하지만 인수와 반환 값이 다릅니다. PerlIO_read () 및 PerlIO_write () 시그니처는보다 낮은 수준의 read () 및 write () 함수에서 대신 모델링되었습니다. &quot;file&quot;인수가 먼저 전달되고 하나의 &quot;count&quot;만 있으며 리턴 값은 오류와 &lt;code&gt;EOF&lt;/code&gt; 를 구별 .</target>
        </trans-unit>
        <trans-unit id="6709bb996b1b03a70d9886cbb196b8cf31182557" translate="yes" xml:space="preserve">
          <source>These correspond functionally to fread() and fwrite() but the arguments and return values are different. The PerlIO_read() and PerlIO_write() signatures have been modeled on the more sane low level read() and write() functions instead: The &quot;file&quot; argument is passed first, there is only one &quot;count&quot;, and the return value can distinguish between error and &lt;code&gt;EOF&lt;/code&gt;.</source>
          <target state="translated">이들은 기능적으로 fread () 및 fwrite ()에 해당하지만 인수와 반환 값이 다릅니다. PerlIO_read () 및 PerlIO_write () 시그니처는 대신보다 건전한 저수준 read () 및 write () 함수를 기반으로 모델링되었습니다. &quot;file&quot;인수가 먼저 전달되고 &quot;count&quot;가 하나만 있으며 반환 값은 다음과 같습니다. error와 &lt;code&gt;EOF&lt;/code&gt; 를 구분합니다 .</target>
        </trans-unit>
        <trans-unit id="6faed5a4522cd8b94dc864e27b779abb63c4ce78" translate="yes" xml:space="preserve">
          <source>These correspond to fopen()/fdopen() and the arguments are the same. Return &lt;code&gt;NULL&lt;/code&gt; and set &lt;code&gt;errno&lt;/code&gt; if there is an error. There may be an implementation limit on the number of open handles, which may be lower than the limit on the number of open files - &lt;code&gt;errno&lt;/code&gt; may not be set when &lt;code&gt;NULL&lt;/code&gt; is returned if this limit is exceeded.</source>
          <target state="translated">이들은 fopen () / fdopen ()에 해당하며 인수는 동일합니다. 반환 &lt;code&gt;NULL&lt;/code&gt; 과 세트 &lt;code&gt;errno&lt;/code&gt; 오류가있는 경우. 열린 핸들 수에 대한 구현 제한이있을 수 있습니다. 열린 핸들 수에 대한 제한보다 낮을 수 있습니다. &lt;code&gt;NULL&lt;/code&gt; 인 경우 &lt;code&gt;errno&lt;/code&gt; 가 설정되지 않을 수 있습니다. .이 한계를 초과 이 리턴 .</target>
        </trans-unit>
        <trans-unit id="85c39d61ce18e7b09b1791e93aa8066eeef62084" translate="yes" xml:space="preserve">
          <source>These correspond to fputs() and fputc(). Note that arguments have been revised to have &quot;file&quot; first.</source>
          <target state="translated">이들은 fputs () 및 fputc ()에 해당합니다. 인수는 &quot;파일&quot;을 먼저 갖도록 수정되었습니다.</target>
        </trans-unit>
        <trans-unit id="544fd46c0b10a4444296cac7b81bb5f9a1983a0b" translate="yes" xml:space="preserve">
          <source>These correspond to historical versions of Perl itself prior to 5.6.0, as well as all other modules which follow the Camel rules for the $VERSION scalar. A Decimal version is initialized with what looks like a floating point number. Leading zeros &lt;b&gt;are&lt;/b&gt; significant and trailing zeros are implied so that a minimum of three places is maintained between subversions. What this means is that any subversion (digits to the right of the decimal place) that contains less than three digits will have trailing zeros added to make up the difference, but only for purposes of comparison with other version objects. For example:</source>
          <target state="translated">이것들은 5.6.0 이전의 Perl 자체 버전과 $ VERSION 스칼라에 대한 Camel 규칙을 따르는 다른 모든 모듈에 해당합니다. Decimal 버전은 부동 소수점 숫자처럼 보이는 것으로 초기화됩니다. 선행 0 &lt;b&gt;이&lt;/b&gt; 중요하고 후행 0이 암시되므로 Subversion 사이에 최소 3 자리가 유지됩니다. 이것이 의미하는 바는 세 자리 미만의 하위 버전 (소수점 오른쪽에있는 숫자)이 차이를 보완하기 위해 추가 된 후행 0을 가지지 만 다른 버전 객체와의 비교 목적으로 만 사용된다는 것입니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8e90caae28ef06f86a5a7c45f8c354bdfbb310ff" translate="yes" xml:space="preserve">
          <source>These defaults may change once perlio has been better tested and tuned.</source>
          <target state="translated">perlio를 더 잘 테스트하고 조정하면 이러한 기본값이 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7839c4fa6c5e549c45dd9f01f832d15a81b4f89c" translate="yes" xml:space="preserve">
          <source>These dependencies &lt;b&gt;must&lt;/b&gt; be installed for proper completion of the phase.</source>
          <target state="translated">단계를 올바르게 완료 &lt;b&gt;하려면&lt;/b&gt; 이러한 종속성 &lt;b&gt;을&lt;/b&gt; 설치 &lt;b&gt;해야합니다&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="a282aac2b58f5229db8cb0a3f6d43227938378cc" translate="yes" xml:space="preserve">
          <source>These dependencies are optional, but are suggested for enhanced operation of the described distribution.</source>
          <target state="translated">이러한 종속성은 선택 사항이지만 설명 된 배포의 향상된 작동을 위해 제안됩니다.</target>
        </trans-unit>
        <trans-unit id="4b42ed96c36dd8480d16597a1b739ba48b433615" translate="yes" xml:space="preserve">
          <source>These directories get the man pages at 'make install' time if INSTALLDIRS=perl. Defaults to $Config{installman*dir}.</source>
          <target state="translated">이 디렉토리는 INSTALLDIRS = perl 인 경우 'make install'시간에 매뉴얼 페이지를 가져옵니다. 기본값은 $ Config {installman * dir}입니다.</target>
        </trans-unit>
        <trans-unit id="80d2a82fca268aa8c538c7ef08b93ac2b88facef" translate="yes" xml:space="preserve">
          <source>These directories get the man pages at 'make install' time if INSTALLDIRS=site (default). Defaults to $(SITEPREFIX)/man/man$(MAN*EXT).</source>
          <target state="translated">이 디렉토리는 INSTALLDIRS = site (기본값) 인 경우 'make install'시간에 매뉴얼 페이지를 가져옵니다. 기본값은 $ (SITEPREFIX) / man / man $ (MAN * EXT)입니다.</target>
        </trans-unit>
        <trans-unit id="68e3f1b03dd4e2ce3d50494f40f9bb4bc33a9ff9" translate="yes" xml:space="preserve">
          <source>These directories get the man pages at 'make install' time if INSTALLDIRS=vendor. Defaults to $(VENDORPREFIX)/man/man$(MAN*EXT).</source>
          <target state="translated">이 디렉토리는 INSTALLDIRS = vendor 인 경우 'make install'시간에 매뉴얼 페이지를 가져옵니다. 기본값은 $ (VENDORPREFIX) / man / man $ (MAN * EXT)입니다.</target>
        </trans-unit>
        <trans-unit id="826d28206d7a0a00e581093b89d5458113f88ed8" translate="yes" xml:space="preserve">
          <source>These events are somewhat unlike the other over-* structures, as far as what their contents are. When an &quot;=over ... =back&quot; block is parsed where the items are a list of text &quot;subheadings&quot;, it will produce this event structure:</source>
          <target state="translated">이러한 이벤트는 내용이 무엇인지에 관한 한 다른 over- * 구조와 다소 다릅니다. 항목이 텍스트 &quot;부제목&quot;목록 인 &quot;= over ... = back&quot;블록이 구문 분석되면 다음 이벤트 구조가 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="e1cc2ff1be108f9b3225e238afe683fc7768cc47" translate="yes" xml:space="preserve">
          <source>These events are somewhat unlike the other over-* structures, as far as what their contents are. When an &quot;=over ... =back&quot; block is parsed where there are no items, it will produce this event structure:</source>
          <target state="translated">이러한 이벤트는 내용이 무엇인지에 관한 한 다른 over- * 구조와 다소 다릅니다. 항목이없는 &quot;= over ... = back&quot;블록이 구문 분석되면 다음 이벤트 구조가 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="059d0be95b4f0a24081b715eea5d71b4a7804c63" translate="yes" xml:space="preserve">
          <source>These events are somewhat unlike the other over-* structures, as far as what their contents are. When an &quot;=over ... =back&quot; block is parsed where there is no content, it will produce this event structure:</source>
          <target state="translated">이러한 이벤트는 내용이 무엇인지에 관한 한 다른 over- * 구조와 다소 다릅니다. 내용이없는 곳에서 &quot;= over ... = back&quot;블록이 구문 분석되면 다음 이벤트 구조가 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="697b26f4c2f86a2a70b8343c157814214e1b6619" translate="yes" xml:space="preserve">
          <source>These examples apply for use in the &lt;code&gt;AUTODIE_HINTS&lt;/code&gt; subroutine and when calling &lt;code&gt;autodie::hints-&amp;gt;set_hints_for()&lt;/code&gt;.</source>
          <target state="translated">이 예제는 &lt;code&gt;AUTODIE_HINTS&lt;/code&gt; 서브 루틴 에서 사용하고 &lt;code&gt;autodie::hints-&amp;gt;set_hints_for()&lt;/code&gt; 호출 할 때 적용됩니다 .</target>
        </trans-unit>
        <trans-unit id="40c3a72856e79ae11ef7788be093b884c47b09d5" translate="yes" xml:space="preserve">
          <source>These examples are realized in the code below, which could be copied to a file</source>
          <target state="translated">이 예제는 아래 코드에서 실현되며 파일로 복사 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="ea1d8aa8b62f74ea36ff39b0b63b9774953aaca0" translate="yes" xml:space="preserve">
          <source>These examples of attempts to use an ellipsis are syntax errors:</source>
          <target state="translated">줄임표를 사용하려는 시도의 예는 구문 오류입니다.</target>
        </trans-unit>
        <trans-unit id="ad269ea05e73affc724a0326dc3ecea88836b454" translate="yes" xml:space="preserve">
          <source>These examples often reflect the style and preference of the author of that piece of the documentation, and may be briefer than a corresponding line of code in a real program. Except where otherwise noted, you should assume that &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings&lt;/code&gt; statements appear earlier in the &quot;program&quot;, and that any variables used have already been declared, even if those declarations have been omitted to make the example easier to read.</source>
          <target state="translated">이러한 예제는 종종 해당 문서의 작성자 스타일과 선호도를 반영하며 실제 프로그램의 해당 코드 줄보다 짧을 수 있습니다. 특별한 법적 고지가없는 한, 해당 가정해야 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings&lt;/code&gt; 문 앞에서 &quot;프로그램&quot;에 표시를하고, 이미 그 선언이 생략 된 경우에도, 선언 된 사용되는 모든 변수를 읽을 수 예를 쉽게하기 위해있다.</target>
        </trans-unit>
        <trans-unit id="d4e7b3ca44c221b3e7c212675f6429495503147e" translate="yes" xml:space="preserve">
          <source>These examples often reflect the style and preference of the author of that piece of the documentation, and may be briefer than a corresponding line of code in a real program. Except where otherwise noted, you should assume that &lt;code&gt;use strict&lt;/code&gt; and &lt;code&gt;use warnings&lt;/code&gt; statements appear earlier in the &quot;program&quot;, and that any variables used have already been declared, even if those declarations have been omitted to make the example easier to read.</source>
          <target state="translated">이러한 예제는 종종 해당 문서의 작성자의 스타일과 선호도를 반영하며 실제 프로그램의 해당 코드 줄보다 짧을 수 있습니다. 달리 언급 된 경우를 제외하고는 &lt;code&gt;use strict&lt;/code&gt; 및 &lt;code&gt;use warnings&lt;/code&gt; 문이 &quot;프로그램&quot;의 앞부분에 나타나고 사용 된 변수가 이미 선언되었다고 가정해야합니다. 예를 더 쉽게 읽을 수 있도록 이러한 선언이 생략 된 경우에도 마찬가지입니다.</target>
        </trans-unit>
        <trans-unit id="da4181b23484c1b0366a0256854a440c5eed9952" translate="yes" xml:space="preserve">
          <source>These examples show how to make references to variables with names. Sometimes you want to make an array or a hash that doesn't have a name. This is analogous to the way you like to be able to use the string &lt;code&gt;&quot;\n&quot;&lt;/code&gt; or the number 80 without having to store it in a named variable first.</source>
          <target state="translated">이 예제는 이름을 가진 변수를 참조하는 방법을 보여줍니다. 때로는 이름이없는 배열이나 해시를 만들고 싶을 때가 있습니다. 이것은 명명 된 변수를 먼저 저장하지 않고 문자열 &lt;code&gt;&quot;\n&quot;&lt;/code&gt; 또는 숫자 80 을 사용할 수있는 방식과 유사합니다 .</target>
        </trans-unit>
        <trans-unit id="20a65f5d703ea411ed23607c52479559427bdd1b" translate="yes" xml:space="preserve">
          <source>These examples show standard binary, octal, and hexadecimal conversion. All cases return 250.</source>
          <target state="translated">이 예제는 표준 2 진, 8 진 및 16 진 변환을 보여줍니다. 모든 케이스는 250을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="3275ce9b816da8fb07d0b0ce58c3254f177b415d" translate="yes" xml:space="preserve">
          <source>These exercise the C calls of the same names. Everything after the flags arg is passed as the args to the called function. They return whatever the C function itself pushed onto the stack, plus the return value from the function; for example</source>
          <target state="translated">이들은 같은 이름의 C 호출을 실행합니다. 플래그 arg 이후의 모든 것은 호출 된 함수에 args로 전달됩니다. C 함수 자체가 스택에 푸시 한 모든 값과 함수의 반환 값을 반환합니다. 예를 들면</target>
        </trans-unit>
        <trans-unit id="8154f7f4551172387a5e006af7a44b0eb2db652a" translate="yes" xml:space="preserve">
          <source>These exports lack the 'test2_' prefix because of how important/common they are. Exports in the &lt;a href=&quot;#OTHER-API-EXPORTS&quot;&gt;&quot;OTHER API EXPORTS&quot;&lt;/a&gt; section have the 'test2_' prefix to ensure they stand out.</source>
          <target state="translated">이러한 내보내기는 중요 / 공통적이므로 'test2_'접두사가 없습니다. 에 수출 &lt;a href=&quot;#OTHER-API-EXPORTS&quot;&gt;&quot;기타 API 수출&quot;&lt;/a&gt; 섹션은 눈에 띄는 보장하기 위해 'test2_'접두사가 있습니다.</target>
        </trans-unit>
        <trans-unit id="7900d790c497c44a25852d75caed60efb96bb183" translate="yes" xml:space="preserve">
          <source>These features are no longer considered experimental and their functionality has disappeared. It's your own fault if you wrote production programs using these features after we explicitly told you not to (see &lt;a href=&quot;perlpolicy&quot;&gt;perlpolicy&lt;/a&gt;).</source>
          <target state="translated">이러한 기능은 더 이상 실험적인 것으로 간주되지 않으며 기능이 사라졌습니다. 우리가 명시 적으로 지시하지 않은 후에 이러한 기능을 사용하여 프로덕션 프로그램을 작성했다면 그것은 당신 자신의 잘못입니다 ( &lt;a href=&quot;perlpolicy&quot;&gt;perlpolicy&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="ecdbc29b6059151fd36541ed2cea90e388fc6071" translate="yes" xml:space="preserve">
          <source>These features were so wildly successful and played so well with others that we decided to remove their experimental status and admit them as full, stable features in the world of Perl, lavishing all the benefits and luxuries thereof. They are also awarded +5 Stability and +3 Charisma.</source>
          <target state="translated">이 기능은 매우 성공적이었고 다른 사람들과 잘 어울려 실험 상태를 제거하고 Perl 세계에서 완전하고 안정적인 기능으로 인정하여 모든 이점과 사치가 사라졌습니다. 또한 +5의 안정성과 +3의 카리스마가 부여됩니다.</target>
        </trans-unit>
        <trans-unit id="23bca6002a132d6b029d6fafa0db7395943b6806" translate="yes" xml:space="preserve">
          <source>These fields are documented in &lt;a href=&quot;Test::Builder&quot;&gt;Test::Builder&lt;/a&gt; in the details() function</source>
          <target state="translated">이 필드는 details () 함수의 &lt;a href=&quot;Test::Builder&quot;&gt;Test :: Builder&lt;/a&gt; 에 문서화되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="63e6036965bbf4c4737a51a1417b34175db545ac" translate="yes" xml:space="preserve">
          <source>These fields are exclusive to Test::Tester.</source>
          <target state="translated">이 필드는 Test :: Tester 전용입니다.</target>
        </trans-unit>
        <trans-unit id="436079f5f30dfc97a1a6d7f8ea9906fefeca2983" translate="yes" xml:space="preserve">
          <source>These fields are used to keep track of how many paren groups could be matched in the pattern, which was the last open paren to be entered, and which was the last close paren to be entered.</source>
          <target state="translated">이 필드는 패턴에 일치 할 수있는 Paren 그룹 수, 마지막으로 입력 한 마지막 Paren 및 마지막으로 입력 한 마지막 Paren을 추적하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="364e8607b9d0b5e1133548655910099e7ea2800f" translate="yes" xml:space="preserve">
          <source>These fields are used to keep track of: how many paren capture groups there are in the pattern; which was the highest paren to be closed (see &lt;a href=&quot;perlvar#%24%2B&quot;&gt;&quot;$+&quot; in perlvar&lt;/a&gt;); and which was the most recent paren to be closed (see &lt;a href=&quot;perlvar#%24%5EN&quot;&gt;&quot;$^N&quot; in perlvar&lt;/a&gt;).</source>
          <target state="translated">이 필드는 다음을 추적하는 데 사용됩니다. 패턴에있는 괄호 캡처 그룹 수; 닫힐 수있는 가장 높은 괄호 ( &lt;a href=&quot;perlvar#%24%2B&quot;&gt;perlvar의 &quot;$ +&quot;&lt;/a&gt; 참조 ); 가장 최근에 닫은 괄호 &lt;a href=&quot;perlvar#%24%5EN&quot;&gt;입니다 (perlvar의 &quot;$ ^ N&quot;&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="55f6d64891a439ddc08d9e9a7c82712ad5e53094" translate="yes" xml:space="preserve">
          <source>These fields were not always set properly by tools. These are &lt;b&gt;MOSTLY&lt;/b&gt; deprecated by the &lt;a href=&quot;Test2::EventFacet::Hub&quot;&gt;Test2::EventFacet::Hub&lt;/a&gt; facets. These fields are not required, and may only reflect the hub that was current when the event was created, which is not necessarily the same as the hub the event was sent through.</source>
          <target state="translated">이러한 필드는 항상 도구에 의해 올바르게 설정되지 않았습니다. 이는 &lt;a href=&quot;Test2::EventFacet::Hub&quot;&gt;Test2 :: EventFacet :: Hub&lt;/a&gt; 패싯 에서 &lt;b&gt;대부분&lt;/b&gt; 사용되지 않습니다 . 이러한 필드는 필수가 아니며 이벤트가 생성 될 때 현재의 허브 만 반영 할 수 있습니다. 이는 이벤트가 전송 된 허브와 반드시 동일 할 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="4c8e2d7aa479f62270f36bb981c83130e3ea21ce" translate="yes" xml:space="preserve">
          <source>These files contain information on who maintains which modules. Run &lt;code&gt;perl Porting/Maintainers -M Module::Name&lt;/code&gt; to find out more information about a dual-life module.</source>
          <target state="translated">이 파일에는 누가 어떤 모듈을 유지 보수하는지에 대한 정보가 들어 있습니다. 이중 수명 모듈에 대한 자세한 정보를 보려면 &lt;code&gt;perl Porting/Maintainers -M Module::Name&lt;/code&gt; 을 실행하십시오 .</target>
        </trans-unit>
        <trans-unit id="7c3add026b4eccbc256b7dbac98ef5e6ce0ff8a8" translate="yes" xml:space="preserve">
          <source>These flags can be set during compilation to enable optimizations in the &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; operator.</source>
          <target state="translated">이 플래그는 컴파일 중에 설정되어 &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; 연산자 에서 최적화를 활성화 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ba4786ce1716e79f3dd44cdde2b9934a0474166a" translate="yes" xml:space="preserve">
          <source>These flags can be set during compilation to enable optimizations in the &lt;code&gt;split&lt;/code&gt; operator.</source>
          <target state="translated">&lt;code&gt;split&lt;/code&gt; 연산자 에서 최적화를 활성화하기 위해 컴파일 중에 이러한 플래그를 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e37fe8b518dd14c6463f65c8f4e797fa6141aaa5" translate="yes" xml:space="preserve">
          <source>These flags will be combined with &lt;code&gt;AI_PASSIVE&lt;/code&gt; if the &lt;code&gt;Listen&lt;/code&gt; argument is given. For more information see the documentation about &lt;code&gt;getaddrinfo()&lt;/code&gt; in the &lt;a href=&quot;socket&quot;&gt;Socket&lt;/a&gt; module.</source>
          <target state="translated">이 플래그와 결합됩니다 &lt;code&gt;AI_PASSIVE&lt;/code&gt; 경우 생성 &lt;code&gt;Listen&lt;/code&gt; 인수가 주어진다. 자세한 내용 은 &lt;a href=&quot;socket&quot;&gt;Socket&lt;/a&gt; 모듈 의 &lt;code&gt;getaddrinfo()&lt;/code&gt; 에 대한 설명서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="5ad448cfc75702b92a6132746a47d8bee944a550" translate="yes" xml:space="preserve">
          <source>These flow-control keywords are documented in &lt;a href=&quot;../perlsyn#Compound-Statements&quot;&gt;Compound Statements in perlsyn&lt;/a&gt;.</source>
          <target state="translated">이러한 흐름 제어 키워드는 &lt;a href=&quot;../perlsyn#Compound-Statements&quot;&gt;perlsyn의 복합 명령문에&lt;/a&gt; 문서화되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="c20b24e4fbc48221510b4bcf4dcbd023da2f2f48" translate="yes" xml:space="preserve">
          <source>These flow-control keywords are documented in &lt;a href=&quot;perlsyn#Compound-Statements&quot;&gt;&quot;Compound Statements&quot; in perlsyn&lt;/a&gt;.</source>
          <target state="translated">이러한 흐름 제어 키워드는 &lt;a href=&quot;perlsyn#Compound-Statements&quot;&gt;perlsyn의 &quot;Compound Statements&quot;에 설명되어&lt;/a&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="4f149ae07a8478e188c52361aad3ec711ed1026a" translate="yes" xml:space="preserve">
          <source>These flow-control keywords are documented in &lt;a href=&quot;perlsyn#Compound-Statements&quot;&gt;Compound Statements in perlsyn&lt;/a&gt;.</source>
          <target state="translated">이러한 흐름 제어 키워드는 &lt;a href=&quot;perlsyn#Compound-Statements&quot;&gt;perlsyn의 복합 명령문에&lt;/a&gt; 문서화되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="309e08bc8a3175c38d05ead911b510e18b559b99" translate="yes" xml:space="preserve">
          <source>These flow-control keywords related to the experimental switch feature are documented in &lt;a href=&quot;../perlsyn#Switch-Statements&quot;&gt;Switch Statements in perlsyn&lt;/a&gt;.</source>
          <target state="translated">실험적인 스위치 기능과 관련된 이러한 흐름 제어 키워드 &lt;a href=&quot;../perlsyn#Switch-Statements&quot;&gt;는 perlsyn의 Switch Statements에&lt;/a&gt; 문서화되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="c6ea531d00fc508a3823794aa1be9e23af84e702" translate="yes" xml:space="preserve">
          <source>These flow-control keywords related to the experimental switch feature are documented in &lt;a href=&quot;perlsyn#Switch-Statements&quot;&gt;&quot;Switch Statements&quot; in perlsyn&lt;/a&gt;.</source>
          <target state="translated">실험적 스위치 기능과 관련된 이러한 흐름 제어 키워드 &lt;a href=&quot;perlsyn#Switch-Statements&quot;&gt;는 perlsyn의 &quot;Switch Statements&quot;에&lt;/a&gt; 문서화되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="a272370ad05edf250f2041efdee62784d465ad39" translate="yes" xml:space="preserve">
          <source>These flow-control keywords related to the experimental switch feature are documented in &lt;a href=&quot;perlsyn#Switch-Statements&quot;&gt;Switch Statements in perlsyn&lt;/a&gt;.</source>
          <target state="translated">실험적인 스위치 기능과 관련된 이러한 흐름 제어 키워드 &lt;a href=&quot;perlsyn#Switch-Statements&quot;&gt;는 perlsyn의 Switch Statements에&lt;/a&gt; 문서화되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="bc4036739b5240858c0bf581399bd57e7b5e9c9e" translate="yes" xml:space="preserve">
          <source>These forms may be assigned to, and cause the right-hand side to be evaluated in scalar context:</source>
          <target state="translated">이 형식은 다음에 할당 될 수 있으며 오른쪽이 스칼라 컨텍스트에서 평가되도록 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b6a87abeab3fa4b07145fb59b22ed97519f70773" translate="yes" xml:space="preserve">
          <source>These free versions of Visual C++ 2008-2013 Professional contain the same compilers and linkers that ship with the full versions, and also contain everything necessary to build Perl, rather than requiring a separate download of the Windows SDK like previous versions did.</source>
          <target state="translated">이 무료 버전의 Visual C ++ 2008-2013 Professional에는 정식 버전과 함께 제공되는 동일한 컴파일러 및 링커가 포함되어 있으며 이전 버전과 달리 Windows SDK를 별도로 다운로드하지 않고 Perl을 빌드하는 데 필요한 모든 것이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="dd071ab048c765a21e6eb3e509d63da5f9264cc6" translate="yes" xml:space="preserve">
          <source>These free versions of Visual C++ 2008-2019 Professional contain the same compilers and linkers that ship with the full versions, and also contain everything necessary to build Perl, rather than requiring a separate download of the Windows SDK like previous versions did.</source>
          <target state="translated">이러한 무료 버전의 Visual C ++ 2008-2019 Professional에는 정식 버전과 함께 제공되는 동일한 컴파일러 및 링커가 포함되어 있으며 이전 버전과 같이 Windows SDK를 별도로 다운로드 할 필요없이 Perl을 빌드하는 데 필요한 모든 것이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="efdfa79cbeb17377a5124b29f2fd31a6e8d98c48" translate="yes" xml:space="preserve">
          <source>These functions allow checksums to be merged. Refer to the</source>
          <target state="translated">이러한 기능을 통해 체크섬을 병합 할 수 있습니다. 참조</target>
        </trans-unit>
        <trans-unit id="ba57dd2ab74f37811d43a497242362420e4296f0" translate="yes" xml:space="preserve">
          <source>These functions are exported only on request. They each take a single argument and return the absolute pathname for it. If no argument is given they'll use the current working directory.</source>
          <target state="translated">이러한 기능은 요청시에만 내보낼 수 있습니다. 그들은 각각 하나의 인수를 취하고 그것에 대한 절대 경로 이름을 반환합니다. 인수가 없으면 현재 작업 디렉토리를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="11a75a016614f3f6a49b489f2532217d2dc9b130" translate="yes" xml:space="preserve">
          <source>These functions are interface of character data used internally. If you want only to get Unicode normalization forms, you don't need call them yourself.</source>
          <target state="translated">이러한 기능은 내부적으로 사용되는 문자 데이터의 인터페이스입니다. 유니 코드 정규화 양식 만 얻으려면 직접 호출 할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="a5805d5b7ed6958150825f5cb6f923e00d36788d" translate="yes" xml:space="preserve">
          <source>These functions are provided for backwards compatibility with common tempfile generation C library functions.</source>
          <target state="translated">이러한 함수는 일반적인 임시 파일 생성 C 라이브러리 함수와의 호환성을 위해 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="4c85d18231511b3dd1840594c64b0cd5dd02c4fd" translate="yes" xml:space="preserve">
          <source>These functions are related to the method resolution order of perl classes</source>
          <target state="translated">이 함수는 perl 클래스의 메소드 분석 순서와 관련이 있습니다.</target>
        </trans-unit>
        <trans-unit id="f5dc09684122720f5aa9541567e929d09cbfcab9" translate="yes" xml:space="preserve">
          <source>These functions are related to the method resolution order of perl classes Also see &lt;a href=&quot;perlmroapi&quot;&gt;perlmroapi&lt;/a&gt;.</source>
          <target state="translated">이러한 함수는 perl 클래스의 메서드 확인 순서와 관련이 있습니다 . &lt;a href=&quot;perlmroapi&quot;&gt;perlmroapi&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="565eacfa6d391bb1e8f9b310d413202832f4d770" translate="yes" xml:space="preserve">
          <source>These functions are used by the filter to obtain either a line or block from the next filter in the chain or the actual source file if there aren't any other filters.</source>
          <target state="translated">이러한 함수는 필터에서 다른 필터가없는 경우 체인의 다음 필터 또는 실제 소스 파일에서 라인 또는 블록을 얻는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="b40856071384296779ffb96483ca0013c6d7f3df" translate="yes" xml:space="preserve">
          <source>These functions are usually used inside an &lt;code&gt;ok()&lt;/code&gt; .</source>
          <target state="translated">이 함수는 보통 &lt;code&gt;ok()&lt;/code&gt; 내부에서 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="e41468bdd006d27480bb97d817c9ffa27e30a0b5" translate="yes" xml:space="preserve">
          <source>These functions are usually used inside an &lt;code&gt;ok()&lt;/code&gt;.</source>
          <target state="translated">이러한 함수는 일반적으로 &lt;code&gt;ok()&lt;/code&gt; 내부에서 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="ad9ddd863a33c4087b2128f800b2bb735b670e0b" translate="yes" xml:space="preserve">
          <source>These functions control the global state of the package.</source>
          <target state="translated">이러한 기능은 패키지의 전역 상태를 제어합니다.</target>
        </trans-unit>
        <trans-unit id="524d44a200305a1bdc5134c684c7bc58ebf331b8" translate="yes" xml:space="preserve">
          <source>These functions grant &lt;code&gt;&quot;SUPER&quot;&lt;/code&gt; token as a prefix of the method name. Note that if you want to keep the returned glob for a long time, you need to check for it being &quot;AUTOLOAD&quot;, since at the later time the call may load a different subroutine due to $AUTOLOAD changing its value. Use the glob created as a side effect to do this.</source>
          <target state="translated">이 함수는 &lt;code&gt;&quot;SUPER&quot;&lt;/code&gt; 토큰을 메소드 이름의 접두어로 부여 합니다. 리턴 된 glob을 오랫동안 유지하려면 &quot;AUTOLOAD&quot;인지 확인해야합니다. 나중에 $ AUTOLOAD가 값을 변경하여 호출이 다른 서브 루틴을로드 할 수 있기 때문입니다. 이를 위해 부작용으로 생성 된 글로브를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="46e538c266b73e137dc14a5dc62eb4e35a0dc1d7" translate="yes" xml:space="preserve">
          <source>These functions grant &lt;code&gt;&quot;SUPER&quot;&lt;/code&gt; token as a prefix of the method name. Note that if you want to keep the returned glob for a long time, you need to check for it being &quot;AUTOLOAD&quot;, since at the later time the call may load a different subroutine due to &lt;code&gt;$AUTOLOAD&lt;/code&gt; changing its value. Use the glob created as a side effect to do this.</source>
          <target state="translated">이러한 함수 는 메서드 이름의 접두사로 &lt;code&gt;&quot;SUPER&quot;&lt;/code&gt; 토큰을 부여 합니다. 반환 된 glob을 오랫동안 유지하려면 &quot;AUTOLOAD&quot;인지 확인해야합니다. 나중에 &lt;code&gt;$AUTOLOAD&lt;/code&gt; 의 값 변경 으로 인해 호출이 다른 서브 루틴을로드 할 수 있기 때문 입니다. 이를 위해 부작용으로 생성 된 glob을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="e3b1137b52cacd1fbff911e830d8d14363d490cb" translate="yes" xml:space="preserve">
          <source>These functions have the same side-effects as &lt;code&gt;gv_fetchmeth&lt;/code&gt; with &lt;code&gt;level==0&lt;/code&gt; . The warning against passing the GV returned by &lt;code&gt;gv_fetchmeth&lt;/code&gt; to &lt;code&gt;call_sv&lt;/code&gt; applies equally to these functions.</source>
          <target state="translated">이러한 함수는 &lt;code&gt;level==0&lt;/code&gt; &lt;code&gt;gv_fetchmeth&lt;/code&gt; 와 동일한 부작용을 갖 습니다 . 에 의해 반환되는 GV 통과에 대한 경고 &lt;code&gt;gv_fetchmeth&lt;/code&gt; 에 &lt;code&gt;call_sv&lt;/code&gt; 는 이러한 기능에도 동일하게 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="2b56f3bac64bb21a82acf1501da762f0c2c856f4" translate="yes" xml:space="preserve">
          <source>These functions have the same side-effects as &lt;code&gt;gv_fetchmeth&lt;/code&gt; with &lt;code&gt;level==0&lt;/code&gt;. The warning against passing the GV returned by &lt;code&gt;gv_fetchmeth&lt;/code&gt; to &lt;code&gt;call_sv&lt;/code&gt; applies equally to these functions.</source>
          <target state="translated">이러한 함수는 &lt;code&gt;level==0&lt;/code&gt; &lt;code&gt;gv_fetchmeth&lt;/code&gt; 와 동일한 부작용이 있습니다 . 에 의해 반환되는 GV 통과에 대한 경고 &lt;code&gt;gv_fetchmeth&lt;/code&gt; 에 &lt;code&gt;call_sv&lt;/code&gt; 는 이러한 기능에도 동일하게 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="98d4aef8dd151e8462fbb3063b8efcb68e0d87b2" translate="yes" xml:space="preserve">
          <source>These functions provide convenient and thread-safe means of manipulating hook variables.</source>
          <target state="translated">이 함수는 후크 변수를 조작하는 편리한 스레드 안전 수단을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="a1aa255500a4b04da2dc6b5da9157c66c2e72423" translate="yes" xml:space="preserve">
          <source>These functions return the filehandles that test output should be written to. They are primarily useful when writing a custom formatter and code that turns events into actual output (TAP, etc.). They will return a dupe of the original filehandles that formatted output can be sent to regardless of whatever state the currently running test may have left STDOUT and STDERR in.</source>
          <target state="translated">이러한 함수는 테스트 출력을 작성해야하는 파일 핸들을 반환합니다. 이벤트를 실제 출력 (TAP 등)으로 바꾸는 사용자 지정 포맷터 및 코드를 작성할 때 주로 유용합니다. 현재 실행중인 테스트가 STDOUT 및 STDERR을 남겼을 수있는 상태에 관계없이 형식화 된 출력을 보낼 수있는 원본 파일 핸들의 복제를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="f738338a9dbfbee4b5a909220a80f41318a9f381" translate="yes" xml:space="preserve">
          <source>These functions simply print $Config{ccflags} and $Config{ccdlflags}</source>
          <target state="translated">이 함수는 단순히 $ Config {ccflags} 및 $ Config {ccdlflags}를 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="6cd020ca0f66b00dde6a2341717a3dae0fc7c828" translate="yes" xml:space="preserve">
          <source>These functions take a hash as an argument. The recognized keys of this hash are:</source>
          <target state="translated">이러한 함수는 해시를 인수로 사용합니다. 이 해시의 인식 키는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d6359c7691ac9172680cb301b6768d6c5620c165" translate="yes" xml:space="preserve">
          <source>These functions take an input numeric code point in one encoding and return what its equivalent value is in the other.</source>
          <target state="translated">이 함수는 한 인코딩에서 입력 숫자 코드 포인트를 가져 와서 다른 값에 해당하는 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="7ebb5ef7a942f7d31cebfd11f8de6228de926c64" translate="yes" xml:space="preserve">
          <source>These hooks are also permitted to set the %INC entry corresponding to the files they have loaded. See &lt;a href=&quot;../perlvar#%25INC&quot;&gt;%INC in perlvar&lt;/a&gt;.</source>
          <target state="translated">이러한 후크는로드 된 파일에 해당하는 % INC 항목을 설정할 수도 있습니다. &lt;a href=&quot;../perlvar#%25INC&quot;&gt;perlvar의 % INC를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="dcbca2e2db6c0375d3253e7898e5f5abc5deaab1" translate="yes" xml:space="preserve">
          <source>These hooks are also permitted to set the %INC entry corresponding to the files they have loaded. See &lt;a href=&quot;perlvar#%25INC&quot;&gt;%INC in perlvar&lt;/a&gt;.</source>
          <target state="translated">이러한 후크는로드 된 파일에 해당하는 % INC 항목을 설정할 수도 있습니다. &lt;a href=&quot;perlvar#%25INC&quot;&gt;perlvar의 % INC를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="5503b912c616b1c1dc8b62e0e994ce6da27034d1" translate="yes" xml:space="preserve">
          <source>These hooks are also permitted to set the &lt;a href=&quot;perlvar#%25INC&quot;&gt;&lt;code&gt;%INC&lt;/code&gt;&lt;/a&gt; entry corresponding to the files they have loaded. See &lt;a href=&quot;perlvar#%25INC&quot;&gt;&quot;%INC&quot; in perlvar&lt;/a&gt;.</source>
          <target state="translated">이러한 후크는 로드 한 파일에 해당하는 &lt;a href=&quot;perlvar#%25INC&quot;&gt; &lt;code&gt;%INC&lt;/code&gt; &lt;/a&gt; 항목 을 설정할 수도 있습니다 . &lt;a href=&quot;perlvar#%25INC&quot;&gt;perlvar의 &quot;% INC&quot;를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="78a1c65d2979db94163456cbe8161d55f284997f" translate="yes" xml:space="preserve">
          <source>These instructions almost certainly won't work with older Symbian releases or other SDKs. Patches to get this port running in other releases, SDKs, compilers, platforms, or devices are naturally welcome.</source>
          <target state="translated">이 지침은 이전 Symbian 릴리스 또는 기타 SDK에서는 거의 작동하지 않습니다. 다른 릴리스, SDK, 컴파일러, 플랫폼 또는 장치에서이 포트를 실행하기위한 패치는 당연히 환영합니다.</target>
        </trans-unit>
        <trans-unit id="70f079e2e8fde2b1b9c52a64a204e00b961420ae" translate="yes" xml:space="preserve">
          <source>These instructions assume an Unixish build environment on your host system; they've been tested on Linux and OS X, and may work on Cygwin and MSYS. While Google also provides an NDK for Windows, these steps won't work native there, although it may be possible to cross-compile through different means.</source>
          <target state="translated">이 지침은 호스트 시스템의 Unixish 빌드 환경을 가정합니다. Linux 및 OS X에서 테스트되었으며 Cygwin 및 MSYS에서 작동 할 수 있습니다. Google은 Windows 용 NDK도 제공하지만 다른 수단을 통해 교차 컴파일 할 수는 있지만이 단계는 기본적으로 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7b41cc6de55339f50e9dff758782b5feb169269e" translate="yes" xml:space="preserve">
          <source>These instructions have been tested under various Nokia Series 60 Symbian SDKs (1.2 to 2.6, 2.8 should also work, 1.2 compiles but does not work), Series 80 2.0, and Nokia 7710 (Series 90) SDK. You can get the SDKs from Forum Nokia (&lt;a href=&quot;http://www.forum.nokia.com/&quot;&gt;http://www.forum.nokia.com/&lt;/a&gt;). A very rough port (&quot;it compiles&quot;) to UIQ 2.1 has also been made.</source>
          <target state="translated">이러한 지침은 다양한 Nokia Series 60 Symbian SDK (1.2 ~ 2.6, 2.8도 작동해야 함, 1.2 컴파일은 작동하지만 작동하지 않음), Series 80 2.0 및 Nokia 7710 (Series 90) SDK에서 테스트되었습니다. SDK는 Forum Nokia ( &lt;a href=&quot;http://www.forum.nokia.com/&quot;&gt;http://www.forum.nokia.com/&lt;/a&gt; ) 에서 구할 수 있습니다 . UIQ 2.1에 대한 매우 거친 포트 ( &quot;컴파일&quot;)도 만들어졌습니다.</target>
        </trans-unit>
        <trans-unit id="8243bb38a9870ed902e40da582837671b3b2a2f6" translate="yes" xml:space="preserve">
          <source>These interfaces are only available in Perl 5.9.5 and higher. See &lt;a href=&quot;MRO::Compat&quot;&gt;MRO::Compat&lt;/a&gt; on CPAN for a mostly forwards compatible implementation for older Perls.</source>
          <target state="translated">이러한 인터페이스는 Perl 5.9.5 이상에서만 사용할 수 있습니다. 이전 Perls에 대한 대부분의 포워드 호환 구현은 CPAN의 &lt;a href=&quot;MRO::Compat&quot;&gt;MRO :: Compat&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="2ab8134e6c8ea614a58bbf4cba85fe875f47ac40" translate="yes" xml:space="preserve">
          <source>These interfaces are only available in Perl 5.9.5 and higher. See &lt;a href=&quot;http://search.cpan.org/perldoc/MRO::Compat&quot;&gt;MRO::Compat&lt;/a&gt; on CPAN for a mostly forwards compatible implementation for older Perls.</source>
          <target state="translated">이 인터페이스는 Perl 5.9.5 이상에서만 사용 가능합니다. 이전 Perls에 대한 대부분의 순방향 호환 구현은 CPAN의 &lt;a href=&quot;http://search.cpan.org/perldoc/MRO::Compat&quot;&gt;MRO :: Compat&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="800024eb93ec8e2e1c9e19ed6e58201379d4f5ea" translate="yes" xml:space="preserve">
          <source>These items are the primitives used to perform indenting, and to select text from amongst alternatives.</source>
          <target state="translated">이 항목은 들여 쓰기를 수행하고 다른 텍스트 중에서 텍스트를 선택하는 데 사용되는 기본 요소입니다.</target>
        </trans-unit>
        <trans-unit id="3dfe7afbcdb97590e1c6c0085eefd647c7035d88" translate="yes" xml:space="preserve">
          <source>These keys will be populated before any exceptions are thrown should there be an error.</source>
          <target state="translated">이 키는 오류가있을 경우 예외가 발생하기 전에 채워집니다.</target>
        </trans-unit>
        <trans-unit id="a901d1a803d1f1e84cb86c073bdbaefe49dcbe0f" translate="yes" xml:space="preserve">
          <source>These keywords are documented in &lt;a href=&quot;../perldata#Special-Literals&quot;&gt;Special Literals in perldata&lt;/a&gt;.</source>
          <target state="translated">이 키워드는 &lt;a href=&quot;../perldata#Special-Literals&quot;&gt;perldata의 특수 리터럴에&lt;/a&gt; 문서화되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="1d6b25a409414e2ca5afbdfa8033c35fbcccb54b" translate="yes" xml:space="preserve">
          <source>These keywords are documented in &lt;a href=&quot;perldata#Special-Literals&quot;&gt;&quot;Special Literals&quot; in perldata&lt;/a&gt;.</source>
          <target state="translated">이러한 키워드는 &lt;a href=&quot;perldata#Special-Literals&quot;&gt;perldata의 &quot;Special Literals&quot;에 설명되어&lt;/a&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="1500951fb5f2dd9eeebd6c439509f1ad3f36d4ce" translate="yes" xml:space="preserve">
          <source>These keywords are documented in &lt;a href=&quot;perldata#Special-Literals&quot;&gt;Special Literals in perldata&lt;/a&gt;.</source>
          <target state="translated">이 키워드는 &lt;a href=&quot;perldata#Special-Literals&quot;&gt;perldata의 특수 리터럴에&lt;/a&gt; 문서화되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="017f89666b16c462ff4b71931d55ca635d0ecaed" translate="yes" xml:space="preserve">
          <source>These last two are only valid for pad name SVs. They only existed in the B::NV class before Perl 5.22. In 5.22 they were moved to the B::PADNAME class.</source>
          <target state="translated">이 마지막 두 개는 패드 이름 SV에만 유효합니다. Perl 5.22 이전의 B :: NV 클래스에만 존재했습니다. 5.22에서 그들은 B :: PADNAME 수업으로 옮겨졌습니다.</target>
        </trans-unit>
        <trans-unit id="298686bf6c6c117c0e1d2a3856c264e7ccaf286f" translate="yes" xml:space="preserve">
          <source>These let you access, or specify, the IPC system internals.</source>
          <target state="translated">이를 통해 IPC 시스템 내부에 액세스하거나 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a9833d67dc0abefa0216f41f8ee8eb9cce74882f" translate="yes" xml:space="preserve">
          <source>These let you access, or specify, the formatters that can/should be used.</source>
          <target state="translated">이를 통해 사용할 수 있거나 사용해야하는 포맷터에 액세스하거나 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c5bcc5490ceb9d124e54596118346ed571b24dc1" translate="yes" xml:space="preserve">
          <source>These libraries cannot be installed when the phase is in operation. This is a very rare situation, and the &lt;code&gt;conflicts&lt;/code&gt; relationship should be used with great caution, or not at all.</source>
          <target state="translated">단계가 작동 중일 때는 이러한 라이브러리를 설치할 수 없습니다. 이것은 매우 드문 상황이며 &lt;code&gt;conflicts&lt;/code&gt; 관계는 매우주의해서 사용하거나 전혀 사용하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="ee3476aee9a9c9d8b18c6d57ac8c385c0348f0d4" translate="yes" xml:space="preserve">
          <source>These look just like character names but return multiple codepoints. Notice the &lt;code&gt;%vx&lt;/code&gt; vector-print functionality in &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이것들은 문자 이름과 비슷하지만 여러 코드 포인트를 반환합니다. &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; 의 &lt;code&gt;%vx&lt;/code&gt; 벡터 인쇄 기능에 주목하십시오 .</target>
        </trans-unit>
        <trans-unit id="3391fc814f15e6deaf725b432b00af48ee0dd251" translate="yes" xml:space="preserve">
          <source>These look just like character names but return multiple codepoints. Notice the &lt;code&gt;%vx&lt;/code&gt; vector-print functionality in &lt;code&gt;printf&lt;/code&gt;.</source>
          <target state="translated">이들은 문자 이름과 비슷하지만 여러 코드 포인트를 반환합니다. &lt;code&gt;printf&lt;/code&gt; 의 &lt;code&gt;%vx&lt;/code&gt; 벡터 인쇄 기능에 주목하십시오 .</target>
        </trans-unit>
        <trans-unit id="e76a83f91dda3c78158f07c2bcf605e73e782739" translate="yes" xml:space="preserve">
          <source>These loop ops are not included in :base_core because they can easily be used to implement a resource attack (e.g., consume all available CPU time).</source>
          <target state="translated">이러한 루프 op는 리소스 공격을 구현하는 데 쉽게 사용할 수 있으므로 (예 : 사용 가능한 모든 CPU 시간 사용) : base_core에 포함되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a843eb74986a4e9f839472d2d8d150ea39980b05" translate="yes" xml:space="preserve">
          <source>These macros arrange things to restore the value of integer variable &lt;code&gt;i&lt;/code&gt; at the end of enclosing</source>
          <target state="translated">이 매크로 는 엔 클로징이 끝날 때 정수 변수 &lt;code&gt;i&lt;/code&gt; 의 값을 복원하도록 정렬합니다.</target>
        </trans-unit>
        <trans-unit id="f7a2a9aebcff3586f69f55801776cb23fd4e90a9" translate="yes" xml:space="preserve">
          <source>These macros arrange things to restore the value of pointers &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;p&lt;/code&gt; . &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; must be a pointer of a type which survives conversion to &lt;code&gt;SV*&lt;/code&gt; and back, &lt;code&gt;p&lt;/code&gt; should be able to survive conversion to &lt;code&gt;char*&lt;/code&gt; and back.</source>
          <target state="translated">이 매크로는 포인터 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;p&lt;/code&gt; 의 값을 복원하기 위해 사물을 배열 합니다. &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; 는 &lt;code&gt;SV*&lt;/code&gt; 변환 된 후에도 존속하는 유형의 포인터 여야 하고, &lt;code&gt;p&lt;/code&gt; 는 &lt;code&gt;char*&lt;/code&gt; 변환 한 후에도 존속 할 수 있어야합니다 .</target>
        </trans-unit>
        <trans-unit id="abe6df67a459b0e2e30bde61ddbbfa6e1689636a" translate="yes" xml:space="preserve">
          <source>These macros arrange things to restore the value of pointers &lt;code&gt;s&lt;/code&gt; and &lt;code&gt;p&lt;/code&gt;. &lt;code&gt;s&lt;/code&gt; must be a pointer of a type which survives conversion to &lt;code&gt;SV*&lt;/code&gt; and back, &lt;code&gt;p&lt;/code&gt; should be able to survive conversion to &lt;code&gt;char*&lt;/code&gt; and back.</source>
          <target state="translated">이 매크로는 포인터 &lt;code&gt;s&lt;/code&gt; 및 &lt;code&gt;p&lt;/code&gt; 의 값을 복원하기 위해 항목을 정렬 합니다. &lt;code&gt;s&lt;/code&gt; 는 &lt;code&gt;SV*&lt;/code&gt; 로의 변환에서 살아남는 유형의 포인터 여야하며 , &lt;code&gt;p&lt;/code&gt; 는 &lt;code&gt;char*&lt;/code&gt; 로의 변환에서 살아남을 수 있어야합니다 .</target>
        </trans-unit>
        <trans-unit id="593dfba1d3d328349b77f1588cf82c2aaffa0443" translate="yes" xml:space="preserve">
          <source>These may not necessarily cause trouble, but indicate mediocre style.</source>
          <target state="translated">반드시 문제를 일으킬 수는 없지만 평범한 스타일을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="e22b64582fc85ac43b9e96c24337a10a450121a5" translate="yes" xml:space="preserve">
          <source>These memory related ops are not included in :base_core because they can easily be used to implement a resource attack (e.g., consume all available memory).</source>
          <target state="translated">이러한 메모리 관련 ops는 : base_core에 포함되지 않습니다. 리소스 공격을 쉽게 구현하는 데 사용할 수 있기 때문입니다 (예 : 사용 가능한 모든 메모리 사용).</target>
        </trans-unit>
        <trans-unit id="77c1bb576863e90102788a1b3ffe564db0c5c144" translate="yes" xml:space="preserve">
          <source>These messages are classified as follows (listed in increasing order of desperation):</source>
          <target state="translated">이러한 메시지는 다음과 같이 분류됩니다 (절망적 인 순서로 나열 됨).</target>
        </trans-unit>
        <trans-unit id="b0bb74426f2aa2733dbc5c5a86f08523cab5f25f" translate="yes" xml:space="preserve">
          <source>These messages may safely be ignored. (Note that for a SunOS4 system, you must use -B/bin/ instead.)</source>
          <target state="translated">이러한 메시지는 무시해도됩니다. (SunOS4 시스템의 경우 -B / bin /을 대신 사용해야합니다.)</target>
        </trans-unit>
        <trans-unit id="5b9f0b892cf28755d89fe7944f868ad5bf940e68" translate="yes" xml:space="preserve">
          <source>These methods all apply to the Ptr type for the structure; additionally two methods are constructed for the structure type itself, &lt;code&gt;_to_ptr&lt;/code&gt; which returns a Ptr type pointing to the same structure, and a &lt;code&gt;new&lt;/code&gt; method to construct and return a new structure, initialised to zeroes.</source>
          <target state="translated">이러한 방법은 모두 구조의 Ptr 유형에 적용됩니다. 추가적으로 방법은 두 구조 유형 자체를 위해 구성된다 &lt;code&gt;_to_ptr&lt;/code&gt; 동일한 구조로의 PTR 식 포인팅을 리턴하고, &lt;code&gt;new&lt;/code&gt; 구조와 방법을 제로로 초기화 된 새로운 구조를 리턴한다.</target>
        </trans-unit>
        <trans-unit id="833ac724c3c333f81488114a18e12c4a9e975d1a" translate="yes" xml:space="preserve">
          <source>These methods all test the BigInt for being one specific value and return true or false depending on the input. These are faster than doing something like:</source>
          <target state="translated">이 메소드는 모두 BigInt가 하나의 특정 값인지 테스트하고 입력에 따라 true 또는 false를 리턴합니다. 이것들은 다음과 같은 것보다 빠릅니다.</target>
        </trans-unit>
        <trans-unit id="44e7eefb77f18d6db25c4aade77e34563622be4e" translate="yes" xml:space="preserve">
          <source>These methods are called when Math::BigInt encounters an object it doesn't know how to handle. For instance, assume $x is a Math::BigInt, or subclass thereof, and $y is defined, but not a Math::BigInt, or subclass thereof. If you do</source>
          <target state="translated">이러한 메서드는 Math :: BigInt가 처리 방법을 모르는 객체를 발견 할 때 호출됩니다. 예를 들어, $ x가 Math :: BigInt 또는 그 하위 클래스이고 $ y가 정의되었지만 Math :: BigInt 또는 그 하위 클래스가 아니라고 가정합니다. 만약 당신이</target>
        </trans-unit>
        <trans-unit id="2e0a252991a786c320bc1feeb73f0f20e3e9795f" translate="yes" xml:space="preserve">
          <source>These methods are discussed in the section &quot;Bracket Notation Security&quot;.</source>
          <target state="translated">이러한 방법은 &quot;대괄호 표기법 보안&quot;섹션에서 설명합니다.</target>
        </trans-unit>
        <trans-unit id="92da9e899f4e8b0a6a719a6370a299d62ec6b1c8" translate="yes" xml:space="preserve">
          <source>These methods are for setting up tests and declaring how many there are. You usually only want to call one of these methods.</source>
          <target state="translated">이 방법들은 테스트를 설정하고 몇 개가 있는지 선언하기위한 것입니다. 일반적으로 이러한 방법 중 하나만 호출하려고합니다.</target>
        </trans-unit>
        <trans-unit id="98d7c4cb78ffffaf07a8efc77ee2a4a9356ea4d1" translate="yes" xml:space="preserve">
          <source>These methods are intended to be used in the everyday dealing of exceptions.</source>
          <target state="translated">이러한 방법은 일상적인 예외 처리에 사용하기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="9725043aadb2020c60801a841d8cbbe42a310c40" translate="yes" xml:space="preserve">
          <source>These methods are not intended to be called by the user, but used or over-ridden by a sub-class of &lt;code&gt;Net::Cmd&lt;/code&gt;</source>
          <target state="translated">이러한 메소드는 사용자가 호출하도록 의도 된 것이 아니라 &lt;code&gt;Net::Cmd&lt;/code&gt; 의 서브 클래스에 의해 사용되거나 대체됩니다.</target>
        </trans-unit>
        <trans-unit id="c96be7d81aefe7494626f31fbf2d601d47ed4e3e" translate="yes" xml:space="preserve">
          <source>These methods are only testing the sign, and not the value.</source>
          <target state="translated">이러한 방법은 부호 만 테스트하고 값은 테스트하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1d5446ceaa2f31e572217b447d4bad05a2bfe863" translate="yes" xml:space="preserve">
          <source>These methods are shorthand for calling &lt;code&gt;request()&lt;/code&gt; for the given method. The URL must have unsafe characters escaped and international domain names encoded. See &lt;code&gt;request()&lt;/code&gt; for valid options and a description of the response.</source>
          <target state="translated">이 메서드는 주어진 메서드에 대해 &lt;code&gt;request()&lt;/code&gt; 를 호출하는 약어입니다 . URL에는 안전하지 않은 문자가 이스케이프되고 국제 도메인 이름이 인코딩되어야합니다. 유효한 옵션과 응답에 대한 설명은 &lt;code&gt;request()&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f55156f755c79786d47317ca2de0a12228b5b4b7" translate="yes" xml:space="preserve">
          <source>These methods are useful when writing your own test methods.</source>
          <target state="translated">이 방법은 자체 테스트 방법을 작성할 때 유용합니다.</target>
        </trans-unit>
        <trans-unit id="1371312bc20ca6b06acc065c53943c266c38f79b" translate="yes" xml:space="preserve">
          <source>These methods control where Test::Builder will print its output. They take either an open &lt;code&gt;$filehandle&lt;/code&gt; , a &lt;code&gt;$filename&lt;/code&gt; to open and write to or a &lt;code&gt;$scalar&lt;/code&gt; reference to append to. It will always return a &lt;code&gt;$filehandle&lt;/code&gt; .</source>
          <target state="translated">이 메소드는 Test :: Builder가 출력을 인쇄 할 위치를 제어합니다. 열린 &lt;code&gt;$filehandle&lt;/code&gt; , 열고 쓸 &lt;code&gt;$filename&lt;/code&gt; 또는 추가 할 &lt;code&gt;$scalar&lt;/code&gt; 참조 중 하나를 사용합니다. 항상 &lt;code&gt;$filehandle&lt;/code&gt; 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="c6256a8c8405e7801b12616fc7588a653b02503a" translate="yes" xml:space="preserve">
          <source>These methods control where Test::Builder will print its output. They take either an open &lt;code&gt;$filehandle&lt;/code&gt;, a &lt;code&gt;$filename&lt;/code&gt; to open and write to or a &lt;code&gt;$scalar&lt;/code&gt; reference to append to. It will always return a &lt;code&gt;$filehandle&lt;/code&gt;.</source>
          <target state="translated">이 메서드는 Test :: Builder가 출력을 인쇄 할 위치를 제어합니다. 열린 &lt;code&gt;$filehandle&lt;/code&gt; , 열고 쓸 &lt;code&gt;$filename&lt;/code&gt; 또는 추가 할 &lt;code&gt;$scalar&lt;/code&gt; 참조를 사용합니다. 항상 &lt;code&gt;$filehandle&lt;/code&gt; 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="4dabfc6c3e23d636029050966dc499c5c862fee9" translate="yes" xml:space="preserve">
          <source>These methods get the values of similarly named fields within the OP data structure. See top of &lt;code&gt;op.h&lt;/code&gt; for more info.</source>
          <target state="translated">이러한 메소드는 OP 데이터 구조 내에서 유사한 이름의 필드 값을 가져옵니다. 자세한 내용은 &lt;code&gt;op.h&lt;/code&gt; 의 상단을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="eac0ba268e5d0e742f5c1a8121218a2683f22449" translate="yes" xml:space="preserve">
          <source>These methods guarantee fast individual tests but require a re-organization of the original list or array. They only pay off if you have to test multiple values against the same array.</source>
          <target state="translated">이러한 방법은 빠른 개별 테스트를 보장하지만 원래 목록 또는 배열을 재구성해야합니다. 동일한 배열에 대해 여러 값을 테스트 해야하는 경우에만 보상합니다.</target>
        </trans-unit>
        <trans-unit id="f57ba0d1f35f964a5a1c34d55f9aeead1f7ad788" translate="yes" xml:space="preserve">
          <source>These methods have cycle detection and will throw an exception early if a cycle is detected. &lt;code&gt;uuid()&lt;/code&gt; is currently the only subroutine in this library that has a fallback behavior when cycles are detected.</source>
          <target state="translated">이러한 메서드에는주기 감지 기능이 있으며주기가 감지되면 조기에 예외가 발생합니다. &lt;code&gt;uuid()&lt;/code&gt; 는 현재이 라이브러리에서주기가 감지 될 때 폴백 동작이있는 유일한 서브 루틴입니다.</target>
        </trans-unit>
        <trans-unit id="7cb3b559e380c719f80028fb428c3eb720e12704" translate="yes" xml:space="preserve">
          <source>These methods install a transparent filter on the I/O stream that converts data from the specified encoding when it is read in from the stream. The result is always Unicode.</source>
          <target state="translated">이러한 메소드는 I / O 스트림에 투명한 필터를 설치하여 스트림에서 읽을 때 지정된 인코딩의 데이터를 변환합니다. 결과는 항상 유니 코드입니다.</target>
        </trans-unit>
        <trans-unit id="f58c6a34e5787c6cc0d22a8ee189b8d36dae62d5" translate="yes" xml:space="preserve">
          <source>These methods modify the invocand object and returns it.</source>
          <target state="translated">이러한 메서드는 invocand 개체를 수정하고 반환합니다.</target>
        </trans-unit>
        <trans-unit id="2d0828193002db36233bc401e0a0e9c0dbb462a1" translate="yes" xml:space="preserve">
          <source>These methods provide a user interface to the &lt;code&gt;Net::Cmd&lt;/code&gt; object.</source>
          <target state="translated">이 메소드는 &lt;code&gt;Net::Cmd&lt;/code&gt; 오브젝트에 대한 사용자 인터페이스를 제공 합니다.</target>
        </trans-unit>
        <trans-unit id="e225e7aa23799f06f35cd0332e8b4cde6a695883" translate="yes" xml:space="preserve">
          <source>These methods return lists of string values, which might be represented in the distmeta structure as arrayrefs or scalars:</source>
          <target state="translated">이러한 메서드는 distmeta 구조에서 arrayref 또는 스칼라로 표시 될 수있는 문자열 값 목록을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="ff435d938391d9561763fbcab2d9f747b7f84a93" translate="yes" xml:space="preserve">
          <source>These methods set the size (in half-points, like 52 for 26-point) that these heading levels will appear as.</source>
          <target state="translated">이러한 방법을 사용하면 이러한 표제 수준이 표시 될 크기 (26 포인트의 경우 52와 같은 반 포인트)를 설정합니다.</target>
        </trans-unit>
        <trans-unit id="abcc7bd5fdde6b4a0c109a19d7071ed04915f8b9" translate="yes" xml:space="preserve">
          <source>These methods use commands that are not part of the RFC977 documentation. Some servers may not support all of them.</source>
          <target state="translated">이러한 방법은 RFC977 설명서에 포함되지 않은 명령을 사용합니다. 일부 서버는 모든 서버를 지원하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="31ccd9bd046a9504a4b8ad4115c9067507a8e143" translate="yes" xml:space="preserve">
          <source>These modes are all actually set via a bitmask. Here is how the &lt;code&gt;FB_&lt;i&gt;XXX&lt;/i&gt;&lt;/code&gt; constants are laid out. You can import the &lt;code&gt;FB_&lt;i&gt;XXX&lt;/i&gt;&lt;/code&gt; constants via &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; Encode qw(:fallbacks)&lt;/code&gt; , and you can import the generic bitmask constants via &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; Encode qw(:fallback_all)&lt;/code&gt; .</source>
          <target state="translated">이러한 모드는 모두 비트 마스크를 통해 실제로 설정됩니다. &lt;code&gt;FB_&lt;i&gt;XXX&lt;/i&gt;&lt;/code&gt; 상수를 배치 하는 방법은 다음과 같습니다 . 당신은 가져올 수 있습니다 &lt;code&gt;FB_&lt;i&gt;XXX&lt;/i&gt;&lt;/code&gt; 의 를 통해 상수 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; Encode qw(:fallbacks)&lt;/code&gt; , 당신은을 통해 일반 비트 마스크 상수 가져올 수 있습니다 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; Encode qw(:fallback_all)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1e33c5a40e1debe70ee0e42cb3c084926947443d" translate="yes" xml:space="preserve">
          <source>These modes are all actually set via a bitmask. Here is how the &lt;code&gt;FB_&lt;i&gt;XXX&lt;/i&gt;&lt;/code&gt; constants are laid out. You can import the &lt;code&gt;FB_&lt;i&gt;XXX&lt;/i&gt;&lt;/code&gt; constants via &lt;code&gt;use Encode qw(:fallbacks)&lt;/code&gt;, and you can import the generic bitmask constants via &lt;code&gt;use Encode qw(:fallback_all)&lt;/code&gt;.</source>
          <target state="translated">이러한 모드는 모두 실제로 비트 마스크를 통해 설정됩니다. 다음은 &lt;code&gt;FB_&lt;i&gt;XXX&lt;/i&gt;&lt;/code&gt; 상수가 배치되는 방법입니다. &lt;code&gt;use Encode qw(:fallbacks)&lt;/code&gt; 를 통해 &lt;code&gt;FB_&lt;i&gt;XXX&lt;/i&gt;&lt;/code&gt; 상수를 가져올 수 있으며, Encode qw (: fallback_all) 을 &lt;code&gt;use Encode qw(:fallback_all)&lt;/code&gt; 하여 일반 비트 마스크 상수를 가져올 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d789a994adbfeec56de6cff1edba3230c60ae5bf" translate="yes" xml:space="preserve">
          <source>These modifiers are restored at the end of the enclosing group. For example,</source>
          <target state="translated">이 수정자는 엔 클로징 그룹의 끝에서 복원됩니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="36a2832964ad1656c58b1143307f7ac9e06be52f" translate="yes" xml:space="preserve">
          <source>These modifiers do not carry over into named subpatterns called in the enclosing group. In other words, a pattern such as &lt;code&gt;((?i)(?&amp;amp;&lt;i&gt;NAME&lt;/i&gt;))&lt;/code&gt; does not change the case-sensitivity of the</source>
          <target state="translated">이러한 수정자는 둘러싸는 그룹에서 호출 된 명명 된 하위 패턴으로 전달되지 않습니다. 즉, &lt;code&gt;((?i)(?&amp;amp;&lt;i&gt;NAME&lt;/i&gt;))&lt;/code&gt; 과 같은 패턴 은 대소 문자 구분을 변경하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4b50f0d55e6d3bcc6eb1ad193029b6cf71ad0ceb" translate="yes" xml:space="preserve">
          <source>These modifiers do not carry over into named subpatterns called in the enclosing group. In other words, a pattern such as &lt;code&gt;((?i)(?&amp;amp;NAME))&lt;/code&gt; does not change the case-sensitivity of the &quot;NAME&quot; pattern.</source>
          <target state="translated">이러한 수정자는 묶음 그룹에서 호출 된 명명 된 하위 패턴으로 이어지지 않습니다. 즉, &lt;code&gt;((?i)(?&amp;amp;NAME))&lt;/code&gt; 과 같은 패턴 은 &quot;NAME&quot;패턴의 대소 문자 구분을 변경하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="333ce465cc885bdd43387f970476181f3973f86d" translate="yes" xml:space="preserve">
          <source>These modifiers, all new in 5.14, affect which character-set rules (Unicode,</source>
          <target state="translated">5.14에 새로 추가 된 이러한 수정자는 문자 집합 규칙 (유니 코드,</target>
        </trans-unit>
        <trans-unit id="f5fbd761faf543e63a6416a5e28a730d54795855" translate="yes" xml:space="preserve">
          <source>These modifiers, all new in 5.14, affect which character-set rules (Unicode, etc.) are used, as described below in &lt;a href=&quot;#Character-set-modifiers&quot;&gt;Character set modifiers&lt;/a&gt;.</source>
          <target state="translated">5.14의 새로운 기능인 이러한 수정자는 아래의 &lt;a href=&quot;#Character-set-modifiers&quot;&gt;문자 집합 수정 자&lt;/a&gt; 에 설명 된대로 사용되는 문자 집합 규칙 (유니 코드 등)에 영향을줍니다 .</target>
        </trans-unit>
        <trans-unit id="2face06edd17affb51aa3f3b2560aa4d1613d318" translate="yes" xml:space="preserve">
          <source>These modules still function correctly, but their test suites will not pass. If you already have these modules installed then you can continue to use them. If you are trying to install them after upgrading Test::Builder you will need to force installation, or bypass the broken tests.</source>
          <target state="translated">이러한 모듈은 여전히 ​​올바르게 작동하지만 테스트 스위트는 통과하지 못합니다. 이러한 모듈이 이미 설치되어있는 경우 계속해서 사용할 수 있습니다. Test :: Builder를 업그레이드 한 후 설치하려는 경우 강제로 설치하거나 손상된 테스트를 우회해야합니다.</target>
        </trans-unit>
        <trans-unit id="bb9708d2ade8d02334095230804c31cb6c6f062f" translate="yes" xml:space="preserve">
          <source>These names are case-insensitive. By default (if specification is omitted), 'shifted' is adopted.</source>
          <target state="translated">이 이름은 대소 문자를 구분하지 않습니다. 기본적으로 (사양을 생략 한 경우) 'shifted'가 채택됩니다.</target>
        </trans-unit>
        <trans-unit id="a2a7bae57c0b7e47324c6368dda30c35ad91dca7" translate="yes" xml:space="preserve">
          <source>These notices must be retained in any copies of any part of this documentation and/or software.</source>
          <target state="translated">이 고지 사항은이 설명서 및 / 또는 소프트웨어의 일부 사본에 보관해야합니다.</target>
        </trans-unit>
        <trans-unit id="efbc4f1ae4d272c0d4681905f6fb23798e4783eb" translate="yes" xml:space="preserve">
          <source>These numbers was achieved Apr 2004 with ActivePerl-5.8.3 running under Linux on a P4 2.8 GHz CPU. The last 5 entries differ by being pure perl implementations of the algorithms, which explains why they are so slow.</source>
          <target state="translated">이 수치는 2004 년 4 월 P4 2.8GHz CPU의 Linux에서 실행되는 ActivePerl-5.8.3으로 달성되었습니다. 마지막 5 개 항목은 알고리즘의 순수한 펄 구현 방식에 따라 다르며 왜 느린 지 설명합니다.</target>
        </trans-unit>
        <trans-unit id="397e9a46a749c3f6612fa5900c82fbeb3d54197f" translate="yes" xml:space="preserve">
          <source>These old, perl3-era utilities have been deprecated in favour of &lt;code&gt;h2xs&lt;/code&gt; for a long time. As of Perl 5.26, they have been removed.</source>
          <target state="translated">이러한 오래된 perl3-era 유틸리티는 오랫동안 &lt;code&gt;h2xs&lt;/code&gt; 를 위해 사용되지 않습니다 . Perl 5.26부터 제거되었습니다.</target>
        </trans-unit>
        <trans-unit id="b16394db34a86c1309e6f32038763254bbfec1e7" translate="yes" xml:space="preserve">
          <source>These operators are documented in &lt;a href=&quot;../perlop&quot;&gt;perlop&lt;/a&gt;.</source>
          <target state="translated">이 연산자는 &lt;a href=&quot;../perlop&quot;&gt;perlop&lt;/a&gt; 에 문서화되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="902ffcf3ea51513d56fbec3ce0266f1b87291429" translate="yes" xml:space="preserve">
          <source>These operators are documented in &lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt;.</source>
          <target state="translated">이 연산자는 &lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt; 에 문서화되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="23835ab35bd3941ef690822a20797ba91ee28d2e" translate="yes" xml:space="preserve">
          <source>These operators are exempt from the &quot;looks like a function rule&quot; described above. That is, an opening parenthesis after the operator does not affect how much of the following code constitutes the argument. Put the opening parentheses before the operator to separate it from code that follows (this applies only to operators with higher precedence than unary operators, of course):</source>
          <target state="translated">이러한 연산자는 위에서 설명한 &quot;함수 규칙처럼 보임&quot;에서 제외됩니다. 즉, 연산자 뒤의 여는 괄호는 다음 코드 중 어느 것이 인수를 구성하는지에 영향을 미치지 않습니다. 여는 괄호를 연산자 앞에 두어 다음 코드와 분리하십시오 (물론 단항 연산자보다 우선 순위가 높은 연산자에만 적용됨).</target>
        </trans-unit>
        <trans-unit id="6b54b9bb627d1cf1404f3b5dab668ec8269f4aa6" translate="yes" xml:space="preserve">
          <source>These operators obtain the information described in &lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt;, if you have the privileges necessary to retrieve the named user's UAF information via &lt;code&gt;sys$getuai&lt;/code&gt; . If not, then only the &lt;code&gt;$name&lt;/code&gt; , &lt;code&gt;$uid&lt;/code&gt; , and &lt;code&gt;$gid&lt;/code&gt; items are returned. The &lt;code&gt;$dir&lt;/code&gt; item contains the login directory in VMS syntax, while the &lt;code&gt;$comment&lt;/code&gt; item contains the login directory in Unix syntax. The &lt;code&gt;$gcos&lt;/code&gt; item contains the owner field from the UAF record. The &lt;code&gt;$quota&lt;/code&gt; item is not used.</source>
          <target state="translated">&lt;code&gt;sys$getuai&lt;/code&gt; 를 통해 명명 된 사용자의 UAF 정보를 검색하는 데 필요한 권한이있는 경우 이러한 연산자는 &lt;a href=&quot;perlfunc&quot;&gt;perlfunc에&lt;/a&gt; 설명 된 정보를 얻습니다 . 그렇지 않으면 &lt;code&gt;$name&lt;/code&gt; , &lt;code&gt;$uid&lt;/code&gt; 및 &lt;code&gt;$gid&lt;/code&gt; 항목 만 반환됩니다. &lt;code&gt;$dir&lt;/code&gt; 항목은 동안, VMS 구문의 로그인 디렉토리를 포함 &lt;code&gt;$comment&lt;/code&gt; 항목이 유닉스 구문의 로그인 디렉토리가 포함되어 있습니다. &lt;code&gt;$gcos&lt;/code&gt; 항목은 UAF 레코드에서 소유자 필드가 포함되어 있습니다. &lt;code&gt;$quota&lt;/code&gt; 항목은 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="67e9c8225d78cd00aa38baba429b7de497a323bb" translate="yes" xml:space="preserve">
          <source>These operators obtain the information described in &lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt;, if you have the privileges necessary to retrieve the named user's UAF information via &lt;code&gt;sys$getuai&lt;/code&gt;. If not, then only the &lt;code&gt;$name&lt;/code&gt;, &lt;code&gt;$uid&lt;/code&gt;, and &lt;code&gt;$gid&lt;/code&gt; items are returned. The &lt;code&gt;$dir&lt;/code&gt; item contains the login directory in VMS syntax, while the &lt;code&gt;$comment&lt;/code&gt; item contains the login directory in Unix syntax. The &lt;code&gt;$gcos&lt;/code&gt; item contains the owner field from the UAF record. The &lt;code&gt;$quota&lt;/code&gt; item is not used.</source>
          <target state="translated">이러한 연산자 는 &lt;code&gt;sys$getuai&lt;/code&gt; 를 통해 명명 된 사용자의 UAF 정보를 검색하는 데 필요한 권한이있는 경우 &lt;a href=&quot;perlfunc&quot;&gt;perlfunc에&lt;/a&gt; 설명 된 정보를 얻습니다 . 그렇지 않은 경우 &lt;code&gt;$name&lt;/code&gt; , &lt;code&gt;$uid&lt;/code&gt; 및 &lt;code&gt;$gid&lt;/code&gt; 항목 만 반환됩니다. &lt;code&gt;$dir&lt;/code&gt; 그동안 항목, VMS 구문의 로그인 디렉토리를 포함 &lt;code&gt;$comment&lt;/code&gt; 항목이 유닉스 구문의 로그인 디렉토리가 포함되어 있습니다. &lt;code&gt;$gcos&lt;/code&gt; 항목은 UAF 레코드에서 소유자 필드가 포함되어 있습니다. &lt;code&gt;$quota&lt;/code&gt; 항목은 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e7e657656c9789c3619d255f79ac9b3a6c835215" translate="yes" xml:space="preserve">
          <source>These ops are not included in :base_core because of the risk of them being used to generate floating point exceptions (which would have to be caught using a $SIG{FPE} handler).</source>
          <target state="translated">이러한 연산은 부동 소수점 예외 ($ SIG {FPE} 핸들러를 사용하여 포착해야 함)를 생성하는 데 사용될 위험 때문에 : base_core에는 포함되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d5ea0da5f8ce978d8d492f686d44331bb4fc3946" translate="yes" xml:space="preserve">
          <source>These ops are not included in :base_core because they have an effect beyond the scope of the compartment.</source>
          <target state="translated">이 op는 구획의 범위를 넘어서 영향을 미치기 때문에 : base_core에는 포함되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="dc4dfb8577c0955249e95ba26e17b894dbf4b7a2" translate="yes" xml:space="preserve">
          <source>These ops are related to multi-threading.</source>
          <target state="translated">이 op는 멀티 스레딩과 관련이 있습니다.</target>
        </trans-unit>
        <trans-unit id="2901e27ec7bca28af121ed51d6417c782431820f" translate="yes" xml:space="preserve">
          <source>These ops enable</source>
          <target state="translated">이 작전은</target>
        </trans-unit>
        <trans-unit id="e55c6aacfd2933ba2a5d8d99593dbebe1787988f" translate="yes" xml:space="preserve">
          <source>These options affect which handler will be used for subsequently installed signals.</source>
          <target state="translated">이 옵션은 이후에 설치된 신호에 사용할 핸들러에 영향을줍니다.</target>
        </trans-unit>
        <trans-unit id="29c586cad3979b967f1d8c83a031669d4e85f7d5" translate="yes" xml:space="preserve">
          <source>These options control the 'vertical display' of opcodes. The display 'order' is also called 'mode' elsewhere in this document.</source>
          <target state="translated">이 옵션은 opcode의 '수직 디스플레이'를 제어합니다. 디스플레이 '순서'는이 문서의 다른 곳에서 '모드'라고도합니다.</target>
        </trans-unit>
        <trans-unit id="b5693ca212dce09ab36fc48e6272f7336e49446b" translate="yes" xml:space="preserve">
          <source>These options select the line-style (or just style) used to render each opcode, and dictates what info is actually printed into each line.</source>
          <target state="translated">이 옵션은 각 opcode를 렌더링하는 데 사용되는 선 스타일 (또는 스타일)을 선택하고 실제로 각 행에 인쇄되는 정보를 지정합니다.</target>
        </trans-unit>
        <trans-unit id="822ae20d8832a94dbc806795384f0c1cb46d5024" translate="yes" xml:space="preserve">
          <source>These packages can all be downloaded by searching in the Download Center at &lt;a href=&quot;http://www.microsoft.com/downloads/search.aspx?displaylang=en&quot;&gt;http://www.microsoft.com/downloads/search.aspx?displaylang=en&lt;/a&gt;. (Providing exact links to these packages has proven a pointless task because the links keep on changing so often.)</source>
          <target state="translated">이러한 패키지는 모두 다운로드 센터 ( &lt;a href=&quot;http://www.microsoft.com/downloads/search.aspx?displaylang=en&quot;&gt;http://www.microsoft.com/downloads/search.aspx?displaylang=en)&lt;/a&gt; 에서 검색하여 다운로드 할 수 있습니다 . (이러한 패키지에 대한 정확한 링크를 제공하는 것은 링크가 자주 변경되기 때문에 무의미한 작업으로 입증되었습니다.)</target>
        </trans-unit>
        <trans-unit id="a96b412b0738a7917698193862d504e1b28178d5" translate="yes" xml:space="preserve">
          <source>These packages can all be downloaded by searching in the Download Center at &lt;a href=&quot;https://www.microsoft.com/downloads/search.aspx?displaylang=en&quot;&gt;https://www.microsoft.com/downloads/search.aspx?displaylang=en&lt;/a&gt;. (Providing exact links to these packages has proven a pointless task because the links keep on changing so often.)</source>
          <target state="translated">이러한 패키지는 모두 다운로드 센터 ( &lt;a href=&quot;https://www.microsoft.com/downloads/search.aspx?displaylang=en&quot;&gt;https://www.microsoft.com/downloads/search.aspx?displaylang=en)&lt;/a&gt; 에서 검색하여 다운로드 할 수 있습니다 . (이러한 패키지에 대한 정확한 링크를 제공하는 것은 링크가 자주 변경되기 때문에 무의미한 작업으로 입증되었습니다.)</target>
        </trans-unit>
        <trans-unit id="e00985d023d49949f9c18d4b6917b5fcc1fe8b04" translate="yes" xml:space="preserve">
          <source>These packages can be downloaded by searching in the Download Center at &lt;a href=&quot;http://www.microsoft.com/downloads/search.aspx?displaylang=en&quot;&gt;http://www.microsoft.com/downloads/search.aspx?displaylang=en&lt;/a&gt;. (Providing exact links to these packages has proven a pointless task because the links keep on changing so often.)</source>
          <target state="translated">이러한 패키지는 다운로드 센터 ( &lt;a href=&quot;http://www.microsoft.com/downloads/search.aspx?displaylang=en&quot;&gt;http://www.microsoft.com/downloads/search.aspx?displaylang=en)&lt;/a&gt; 에서 검색하여 다운로드 할 수 있습니다 . (이러한 패키지에 대한 정확한 링크를 제공하는 것은 링크가 자주 변경되기 때문에 무의미한 작업으로 입증되었습니다.)</target>
        </trans-unit>
        <trans-unit id="768a190e5a4a6b2a5a78de898be2b0088fa40b69" translate="yes" xml:space="preserve">
          <source>These packages can be downloaded by searching in the Download Center at &lt;a href=&quot;https://www.microsoft.com/downloads/search.aspx?displaylang=en&quot;&gt;https://www.microsoft.com/downloads/search.aspx?displaylang=en&lt;/a&gt;. (Providing exact links to these packages has proven a pointless task because the links keep on changing so often.)</source>
          <target state="translated">이러한 패키지는 다운로드 센터 ( &lt;a href=&quot;https://www.microsoft.com/downloads/search.aspx?displaylang=en&quot;&gt;https://www.microsoft.com/downloads/search.aspx?displaylang=en)&lt;/a&gt; 에서 검색하여 다운로드 할 수 있습니다 . (이러한 패키지에 대한 정확한 링크를 제공하는 것은 링크가 자주 변경되기 때문에 무의미한 작업으로 입증되었습니다.)</target>
        </trans-unit>
        <trans-unit id="ee6b901a4b16ea8fd5c1a17b0f5f523262d0ae63" translate="yes" xml:space="preserve">
          <source>These packages can both be downloaded by searching in the Download Center at &lt;a href=&quot;http://www.microsoft.com/downloads/search.aspx?displaylang=en&quot;&gt;http://www.microsoft.com/downloads/search.aspx?displaylang=en&lt;/a&gt;. (Providing exact links to these packages has proven a pointless task because the links keep on changing so often.)</source>
          <target state="translated">이 패키지는 모두 다운로드 센터 ( &lt;a href=&quot;http://www.microsoft.com/downloads/search.aspx?displaylang=en&quot;&gt;http://www.microsoft.com/downloads/search.aspx?displaylang=en)&lt;/a&gt; 에서 검색하여 다운로드 할 수 있습니다 . (이러한 패키지에 대한 정확한 링크를 제공하는 것은 링크가 자주 변경되기 때문에 무의미한 작업으로 입증되었습니다.)</target>
        </trans-unit>
        <trans-unit id="b0b087e3db9d0ec8ccf2941b80cf3aaf473d4556" translate="yes" xml:space="preserve">
          <source>These perl routines currently (as of Perl v.5.8.6) cannot handle passed inf.</source>
          <target state="translated">현재 이러한 Perl 루틴 (Perl v.5.8.6 현재)은 전달 된 inf를 처리 할 수 ​​없습니다.</target>
        </trans-unit>
        <trans-unit id="5ee158f8c062eca4d28a3ec2d9f8d880c70ecea2" translate="yes" xml:space="preserve">
          <source>These possessive quantifiers represent a special case of a more general concept, the</source>
          <target state="translated">이러한 소유 수량자는보다 일반적인 개념의 특별한 경우를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="bfd6c7d2c77daf624f0f4dda10d349c1b00557da" translate="yes" xml:space="preserve">
          <source>These properties are &lt;code&gt;\b&lt;/code&gt; (without braces), &lt;code&gt;\B&lt;/code&gt; (without braces), &lt;code&gt;\s&lt;/code&gt;, &lt;code&gt;\S&lt;/code&gt; , &lt;code&gt;\w&lt;/code&gt; , &lt;code&gt;\W&lt;/code&gt; , and all the Posix character classes</source>
          <target state="translated">이러한 속성은 &lt;code&gt;\b&lt;/code&gt; (중괄호 없음), &lt;code&gt;\B&lt;/code&gt; (중괄호 없음), &lt;code&gt;\s&lt;/code&gt; , &lt;code&gt;\S&lt;/code&gt; , &lt;code&gt;\w&lt;/code&gt; , &lt;code&gt;\W&lt;/code&gt; 및 모든 Posix 문자 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="75c6e853336d06e89c7d24890512216ff9df496b" translate="yes" xml:space="preserve">
          <source>These properties are &lt;code&gt;\b&lt;/code&gt; (without braces), &lt;code&gt;\B&lt;/code&gt; (without braces), &lt;code&gt;\s&lt;/code&gt;, &lt;code&gt;\S&lt;/code&gt;, &lt;code&gt;\w&lt;/code&gt;, &lt;code&gt;\W&lt;/code&gt;, and all the Posix character classes</source>
          <target state="translated">이러한 속성은 &lt;code&gt;\b&lt;/code&gt; (중괄호 없음), &lt;code&gt;\B&lt;/code&gt; (중괄호 없음), &lt;code&gt;\s&lt;/code&gt; , &lt;code&gt;\S&lt;/code&gt; , &lt;code&gt;\w&lt;/code&gt; , &lt;code&gt;\W&lt;/code&gt; 및 모든 Posix 문자 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="ac0cd3dd6b0da7da2a477124699c51a8786143da" translate="yes" xml:space="preserve">
          <source>These provide access to internal state and object instances.</source>
          <target state="translated">내부 상태 및 개체 인스턴스에 대한 액세스를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="49d4c7299af6c451da747abf6a31ed43bc6d224c" translate="yes" xml:space="preserve">
          <source>These quantifiers will try to match as much of the string as possible, while still allowing the regex to match. So we have</source>
          <target state="translated">이러한 수량자는 가능한 한 많은 문자열을 일치 시키면서도 정규 표현식이 일치하도록 시도합니다. 그래서 우리는</target>
        </trans-unit>
        <trans-unit id="b9b2f742b1b0fcfd6307ec607f8aee70bbd6ff21" translate="yes" xml:space="preserve">
          <source>These readers return hashrefs of arbitrary unblessed data structures, each described more fully in the specification:</source>
          <target state="translated">이러한 판독기는 임의의 비 축복 데이터 구조의 해시 참조를 반환하며, 각각은 사양에 자세히 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="26153a279914ed6ae972bab9be5035c10687695d" translate="yes" xml:space="preserve">
          <source>These results are &quot;meta&quot; information about the total results of an individual test program.</source>
          <target state="translated">이 결과는 개별 테스트 프로그램의 총 결과에 대한 &quot;메타&quot;정보입니다.</target>
        </trans-unit>
        <trans-unit id="2bea10980ed9e4e8701806a5267309dec8b36b3d" translate="yes" xml:space="preserve">
          <source>These results refer to individual tests which are run.</source>
          <target state="translated">이 결과는 실행되는 개별 테스트를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="8893a5b7811d1faa2be1d81844c471e18cd604f6" translate="yes" xml:space="preserve">
          <source>These round modes always round in the same direction.</source>
          <target state="translated">이러한 라운드 모드는 항상 같은 방향으로 라운드됩니다.</target>
        </trans-unit>
        <trans-unit id="d39fb8588e2e03cf43f722c60791932347b9ede7" translate="yes" xml:space="preserve">
          <source>These rounding modes round to the nearest digit. They differ in how they determine which way to round in the ambiguous case when there is a tie.</source>
          <target state="translated">이러한 반올림 모드는 가장 가까운 숫자로 반올림됩니다. 동점이있을 때 모호한 경우에 반올림 할 방법을 결정하는 방법이 다릅니다.</target>
        </trans-unit>
        <trans-unit id="f99e408a46643ae41ce4a2a5b658c331ee2d8a0f" translate="yes" xml:space="preserve">
          <source>These routines all create system-specific portability problems. As noted elsewhere, Perl is at the mercy of your C libraries for much of its system behavior. It's probably safest to assume broken SysV semantics for signals and to stick with simple TCP and UDP socket operations; e.g., don't try to pass open file descriptors over a local UDP datagram socket if you want your code to stand a chance of being portable.</source>
          <target state="translated">이러한 루틴은 모두 시스템 별 이식성 문제를 발생시킵니다. 다른 곳에서 언급 한 바와 같이, Perl은 C 시스템의 많은 시스템 동작에 대한 자비에 있습니다. 신호에 대해 깨진 SysV 시맨틱을 가정하고 간단한 TCP 및 UDP 소켓 조작을 사용하는 것이 가장 안전합니다. 예를 들어, 코드를 이식 가능하게 만들려면 로컬 UDP 데이터 그램 소켓을 통해 열린 파일 디스크립터를 전달하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="7accb91a83a147e188cfdb7ea0bdeddeb0f7f3a7" translate="yes" xml:space="preserve">
          <source>These routines allow you to parse file paths into their directory, filename and suffix.</source>
          <target state="translated">이 루틴을 사용하면 파일 경로를 해당 디렉토리, 파일 이름 및 접미사로 구문 분석 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b2c49f2650fd89670405ec1fbc536b94e9ae8bdf" translate="yes" xml:space="preserve">
          <source>These routines are all documented in the Locale::Codes::API man page.</source>
          <target state="translated">이 루틴은 모두 Locale :: Codes :: API 매뉴얼 페이지에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="5bd965d62212a6eeb3c7fb76c8f854332dc29f76" translate="yes" xml:space="preserve">
          <source>These routines are quite efficient and yet are always guaranteed to agree with &lt;code&gt;&lt;a href=&quot;../functions/localtime&quot;&gt;localtime()&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../functions/gmtime&quot;&gt;gmtime()&lt;/a&gt;&lt;/code&gt;. We manage this by caching the start times of any months we've seen before. If we know the start time of the month, we can always calculate any time within the month. The start times are calculated using a mathematical formula. Unlike other algorithms that do multiple calls to &lt;code&gt;&lt;a href=&quot;../functions/gmtime&quot;&gt;gmtime()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 루틴은 매우 효율적이지만 항상 &lt;code&gt;&lt;a href=&quot;../functions/localtime&quot;&gt;localtime()&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../functions/gmtime&quot;&gt;gmtime()&lt;/a&gt;&lt;/code&gt; 에 동의하도록 보장됩니다 . 우리는 이전에 본 달의 시작 시간을 캐싱하여이를 관리합니다. 해당 월의 시작 시간을 알고 있으면 해당 월의 시간을 언제든지 계산할 수 있습니다. 시작 시간은 수학 공식을 사용하여 계산됩니다. &lt;code&gt;&lt;a href=&quot;../functions/gmtime&quot;&gt;gmtime()&lt;/a&gt;&lt;/code&gt; 을 여러 번 호출하는 다른 알고리즘과 달리 .</target>
        </trans-unit>
        <trans-unit id="54b6203ba949c1c3d7c2acb41e2e6e57811ab704" translate="yes" xml:space="preserve">
          <source>These routines are quite efficient and yet are always guaranteed to agree with &lt;code&gt;localtime()&lt;/code&gt; and &lt;code&gt;gmtime()&lt;/code&gt;. We manage this by caching the start times of any months we've seen before. If we know the start time of the month, we can always calculate any time within the month. The start times are calculated using a mathematical formula. Unlike other algorithms that do multiple calls to &lt;code&gt;gmtime()&lt;/code&gt;.</source>
          <target state="translated">이러한 루틴은 매우 효율적이지만 항상 &lt;code&gt;localtime()&lt;/code&gt; 및 &lt;code&gt;gmtime()&lt;/code&gt; 과 일치하는 것이 보장됩니다 . 우리는 이전에 보았던 달의 시작 시간을 캐싱하여이를 관리합니다. 월의 시작 시간을 알고 있으면 언제든지 해당 월의 시간을 계산할 수 있습니다. 시작 시간은 수학 공식을 사용하여 계산됩니다. &lt;code&gt;gmtime()&lt;/code&gt; 을 여러 번 호출하는 다른 알고리즘과는 다릅니다 .</target>
        </trans-unit>
        <trans-unit id="e296b7f9a5e96b639ca1839fa4442d3f45e92709" translate="yes" xml:space="preserve">
          <source>These routines are the same as their counterparts in the system C library. In list context, the return values from the various get routines are as follows:</source>
          <target state="translated">이 루틴은 시스템 C 라이브러리의 해당 루틴과 동일합니다. 리스트 컨텍스트에서 다양한 get 루틴의 리턴 값은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="cc1ea3e493711677c93d92be2ec1c6ec9a5ee909" translate="yes" xml:space="preserve">
          <source>These routines used to be called &lt;code&gt;perl_call_sv&lt;/code&gt; , etc., before Perl v5.6.0, but those names are now deprecated; macros of the same name are provided for compatibility.</source>
          <target state="translated">이 루틴 호출하는 데 사용 &lt;code&gt;perl_call_sv&lt;/code&gt; 펄 v5.6.0 전에, 등,하지만 그 이름은 이제 사용되지 않습니다; 호환성을 위해 동일한 이름의 매크로가 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="93e20f0b82d868c177a926520e899384ae0d6b0f" translate="yes" xml:space="preserve">
          <source>These routines used to be called &lt;code&gt;perl_call_sv&lt;/code&gt;, etc., before Perl v5.6.0, but those names are now deprecated; macros of the same name are provided for compatibility.</source>
          <target state="translated">이러한 루틴은 Perl v5.6.0 이전 에는 &lt;code&gt;perl_call_sv&lt;/code&gt; 등으로 불렸지만 이제는 해당 이름이 더 이상 사용되지 않습니다. 호환성을 위해 동일한 이름의 매크로가 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="1fb1fb969b6c77a6565b33ce0e7b7cbfccc95cfb" translate="yes" xml:space="preserve">
          <source>These rules are complicated, but the goal is for them to do what you want (even if you don't quite understand why they are doing it). For example:</source>
          <target state="translated">이러한 규칙은 복잡하지만 목표는 원하는 방식으로 수행하는 것입니다 (이유를 수행하는 이유를 잘 모르더라도). 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c63bc3c15060a430def6be9fa36745fbd5e2304e" translate="yes" xml:space="preserve">
          <source>These rules were designed for compactness of expression, rather than legibility and maintainability. The &lt;a href=&quot;#%2Fx-and-%2Fxx&quot;&gt;&quot;/x and /xx&quot;&lt;/a&gt; pattern modifiers allow you to insert white space to improve readability. And use of &lt;code&gt;&lt;a href=&quot;re#%27strict%27-mode&quot;&gt;re 'strict'&lt;/a&gt;&lt;/code&gt; adds extra checking to catch some typos that might silently compile into something unintended.</source>
          <target state="translated">이러한 규칙은 가독성과 유지 관리가 아닌 표현의 간결함을 위해 설계되었습니다. &lt;a href=&quot;#%2Fx-and-%2Fxx&quot;&gt;&quot;/ X 및 / XX&quot;&lt;/a&gt; 패턴 수정은 가독성을 개선하기 위해 공백을 삽입 할 수 있습니다. 그리고 &lt;code&gt;&lt;a href=&quot;re#%27strict%27-mode&quot;&gt;re 'strict'&lt;/a&gt;&lt;/code&gt; 를 사용하면 의도하지 않은 것으로 자동 컴파일 될 수있는 오타를 포착하기위한 추가 검사가 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="1c39d28608973eadb707da3830a9f4611c69ff29" translate="yes" xml:space="preserve">
          <source>These select Unicode rules. That means that in double-quotish strings, the string is always converted to UTF-8 to force a Unicode interpretation (you can &lt;code&gt;utf8::downgrade()&lt;/code&gt; afterwards to convert back to non-UTF8, if possible). In regular expression patterns, the conversion isn't done, but if the character set modifier would otherwise be &lt;code&gt;/d&lt;/code&gt;, it is changed to &lt;code&gt;/u&lt;/code&gt; .</source>
          <target state="translated">이들은 선택된 유니 코드 규칙입니다. 즉, 큰 따옴표로 묶인 문자열에서 문자열은 항상 UTF-8로 변환되어 유니 코드 해석을 강제합니다 (가능한 경우 &lt;code&gt;utf8::downgrade()&lt;/code&gt; 를 사용하여 비 UTF8로 다시 변환 할 수 있음). 정규 표현식 패턴에서는 변환이 수행되지 않지만 문자 세트 수정자가 &lt;code&gt;/d&lt;/code&gt; 이면 &lt;code&gt;/u&lt;/code&gt; 로 변경됩니다 .</target>
        </trans-unit>
        <trans-unit id="b576853b18c74e3e57c9d5a616cf25646efde147" translate="yes" xml:space="preserve">
          <source>These select Unicode rules. That means that in double-quotish strings, the string is always converted to UTF-8 to force a Unicode interpretation (you can &lt;code&gt;utf8::downgrade()&lt;/code&gt; afterwards to convert back to non-UTF8, if possible). In regular expression patterns, the conversion isn't done, but if the character set modifier would otherwise be &lt;code&gt;/d&lt;/code&gt;, it is changed to &lt;code&gt;/u&lt;/code&gt;.</source>
          <target state="translated">이들은 유니 코드 규칙을 선택합니다. 즉, 큰 따옴표 문자열에서 문자열은 유니 코드 해석을 강제하기 위해 항상 UTF-8 로 변환됩니다 (가능한 경우 나중에 &lt;code&gt;utf8::downgrade()&lt;/code&gt; 하여 비 UTF8로 다시 변환 할 수 있음). 정규식 패턴에서는 변환이 수행되지 않지만 문자 집합 수정자가 &lt;code&gt;/d&lt;/code&gt; 이면 &lt;code&gt;/u&lt;/code&gt; 로 변경됩니다 .</target>
        </trans-unit>
        <trans-unit id="c33be304d6b7f8ebe4e43f5c0dfa6aefb4009eb4" translate="yes" xml:space="preserve">
          <source>These sets of one-liners are equivalent:</source>
          <target state="translated">이 한 줄짜리 라이너 세트는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="52c95446c9ca7d3ffaa7ed7da6e1f21bf02cdc2e" translate="yes" xml:space="preserve">
          <source>These settings can be overridden globally too:</source>
          <target state="translated">이러한 설정은 전체적으로 재정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cbc91f3641f463359dfc31290abbc3a64d30454a" translate="yes" xml:space="preserve">
          <source>These should be familiar operations, with the exception of &lt;code&gt;av_unshift&lt;/code&gt; . This routine adds &lt;code&gt;num&lt;/code&gt; elements at the front of the array with the &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; value. You must then use &lt;code&gt;av_store&lt;/code&gt; (described below) to assign values to these new elements.</source>
          <target state="translated">&lt;code&gt;av_unshift&lt;/code&gt; 를 제외하고 익숙한 작업이어야합니다 . 이 루틴 은 배열 앞에 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 값으로 &lt;code&gt;num&lt;/code&gt; 요소를 추가 합니다. 그런 다음 &lt;code&gt;av_store&lt;/code&gt; (아래 설명)를 사용 하여 이러한 새 요소에 값을 지정 해야합니다 .</target>
        </trans-unit>
        <trans-unit id="e729774b9950231de8aa37e9ccc295a6e06651f9" translate="yes" xml:space="preserve">
          <source>These should be familiar operations, with the exception of &lt;code&gt;av_unshift&lt;/code&gt;. This routine adds &lt;code&gt;num&lt;/code&gt; elements at the front of the array with the &lt;code&gt;undef&lt;/code&gt; value. You must then use &lt;code&gt;av_store&lt;/code&gt; (described below) to assign values to these new elements.</source>
          <target state="translated">&lt;code&gt;av_unshift&lt;/code&gt; 를 제외하고는 익숙한 작업이어야합니다 . 이 루틴 은 &lt;code&gt;undef&lt;/code&gt; 값으로 배열 앞에 &lt;code&gt;num&lt;/code&gt; 개의 요소를 추가 합니다. 그런 다음 &lt;code&gt;av_store&lt;/code&gt; (아래 설명)를 사용 하여 이러한 새 요소에 값을 할당 해야합니다 .</target>
        </trans-unit>
        <trans-unit id="8f249c892c517536f796cbacefae284ca0ae8032" translate="yes" xml:space="preserve">
          <source>These should give you an overall feel for how modules are laid out and written.</source>
          <target state="translated">이것들은 모듈 배치 및 작성 방법에 대한 전반적인 느낌을 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="9a888f57551ca71c1272e83f90d05d460b30fbf3" translate="yes" xml:space="preserve">
          <source>These signal to a formatter that if it is to hyphenate &quot;sigaction&quot; or &quot;manuscript&quot;, then it should be done as &quot;sig-</source>
          <target state="translated">&quot;서명&quot;또는 &quot;원고&quot;를 하이픈으로 묶으려면 &quot;sig-</target>
        </trans-unit>
        <trans-unit id="a76776d9b84dd64fcd8c2f12ffb416173943a78e" translate="yes" xml:space="preserve">
          <source>These signals usually indicate a serious problem with the Perl interpreter or with your script. They are ABRT, BUS, EMT, FPE, ILL, QUIT, SEGV, SYS and TRAP.</source>
          <target state="translated">이러한 신호는 일반적으로 Perl 인터프리터 또는 스크립트에 심각한 문제가 있음을 나타냅니다. ABRT, BUS, EMT, FPE, ILL, QUIT, SEGV, SYS 및 TRAP입니다.</target>
        </trans-unit>
        <trans-unit id="7ee071669b1efa68f9a3156de49d5e707921d24a" translate="yes" xml:space="preserve">
          <source>These solutions can have far-reaching effects on your system and on the way you write your CGI programs, so investigate them with care.</source>
          <target state="translated">이러한 솔루션은 시스템 및 CGI 프로그램 작성 방식에 광범위한 영향을 줄 수 있으므로주의해서 조사하십시오.</target>
        </trans-unit>
        <trans-unit id="b7b244316194399450de143deaa053b425f44f52" translate="yes" xml:space="preserve">
          <source>These special patterns are generally of the form &lt;code&gt;(*&lt;i&gt;VERB&lt;/i&gt;:&lt;i&gt;arg&lt;/i&gt;)&lt;/code&gt;. Unless otherwise stated the</source>
          <target state="translated">이러한 특수 패턴은 일반적으로 &lt;code&gt;(*&lt;i&gt;VERB&lt;/i&gt;:&lt;i&gt;arg&lt;/i&gt;)&lt;/code&gt; 형식 입니다. 달리 명시되지 않는 한</target>
        </trans-unit>
        <trans-unit id="af1c9d3db11663506b814ed4474ccb898e81f0dd" translate="yes" xml:space="preserve">
          <source>These special patterns are generally of the form &lt;code&gt;(*VERB:ARG)&lt;/code&gt;. Unless otherwise stated the ARG argument is optional; in some cases, it is forbidden.</source>
          <target state="translated">이러한 특수 패턴은 일반적으로 &lt;code&gt;(*VERB:ARG)&lt;/code&gt; 형식 입니다. 달리 명시되지 않는 한 ARG 인수는 선택 사항입니다. 어떤 경우에는 금지되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="44f08bb0d22471168dee4b6292fc949cf275107b" translate="yes" xml:space="preserve">
          <source>These special values become JSON true and JSON false values, respectively. You can also use &lt;code&gt;\1&lt;/code&gt; and &lt;code&gt;\0&lt;/code&gt; directly if you want.</source>
          <target state="translated">이러한 특수 값은 각각 JSON true 및 JSON false 값이됩니다. 원하는 경우 &lt;code&gt;\1&lt;/code&gt; 및 &lt;code&gt;\0&lt;/code&gt; 직접 사용할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ae6fd84e089df12e602215034c3af5ac8fb7e11a" translate="yes" xml:space="preserve">
          <source>These special variables, like the &lt;code&gt;%+&lt;/code&gt; hash and the numbered match variables (&lt;code&gt;$1&lt;/code&gt; , &lt;code&gt;$2&lt;/code&gt; , &lt;code&gt;$3&lt;/code&gt; , etc.) are dynamically scoped until the end of the enclosing block or until the next successful match, whichever comes first. (See &lt;a href=&quot;perlsyn#Compound-Statements&quot;&gt;Compound Statements in perlsyn&lt;/a&gt;.)</source>
          <target state="translated">&lt;code&gt;%+&lt;/code&gt; 해시 및 번호 일치 변수 ( &lt;code&gt;$1&lt;/code&gt; , &lt;code&gt;$2&lt;/code&gt; , &lt;code&gt;$3&lt;/code&gt; 등) 와 같은 이러한 특수 변수 는 둘러싸는 블록의 끝까지 또는 다음 성공적인 일치 (둘 중 먼저 오는 것)까지 동적으로 범위가 지정됩니다. ( &lt;a href=&quot;perlsyn#Compound-Statements&quot;&gt;perlsyn의 복합 문장&lt;/a&gt; 참조 .)</target>
        </trans-unit>
        <trans-unit id="f99b2f0c65b0d18630113afe2aefcc29ab8a0144" translate="yes" xml:space="preserve">
          <source>These special variables, like the &lt;code&gt;%+&lt;/code&gt; hash and the numbered match variables (&lt;code&gt;$1&lt;/code&gt;, &lt;code&gt;$2&lt;/code&gt;, &lt;code&gt;$3&lt;/code&gt;,</source>
          <target state="translated">등이 특별한 변수 &lt;code&gt;%+&lt;/code&gt; 해시와 번호가 일치 변수 ( &lt;code&gt;$1&lt;/code&gt; , &lt;code&gt;$2&lt;/code&gt; , &lt;code&gt;$3&lt;/code&gt; ,</target>
        </trans-unit>
        <trans-unit id="ba4f20c17b5b03a6a3deb3a04503955765039642" translate="yes" xml:space="preserve">
          <source>These strengths make it especially popular with web developers and system administrators. Mathematicians, geneticists, journalists, managers and many other people also use Perl.</source>
          <target state="translated">이러한 장점으로 인해 웹 개발자 및 시스템 관리자에게 특히 인기가 있습니다. 수학자, 유전 학자, 언론인, 관리자 및 다른 많은 사람들도 Perl을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="a952f4bd002dc5bdafb796a94c6eaa4765c9b45b" translate="yes" xml:space="preserve">
          <source>These strings do not match /\Bam\B/</source>
          <target state="translated">이 문자열은 / \ Bam \ B /와 일치하지 않습니다</target>
        </trans-unit>
        <trans-unit id="2125a4453223ddc6316d0fee4d859469467def9f" translate="yes" xml:space="preserve">
          <source>These strings do not match /\b'\b/.</source>
          <target state="translated">이 문자열은 / \ b '\ b /와 일치하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8aa64b62307f4ac9360d6b96b7d4a2888dc9ba0f" translate="yes" xml:space="preserve">
          <source>These strings do not match /\bPerl\b/.</source>
          <target state="translated">이 문자열은 / \ bPerl \ b /와 일치하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1ece96fea144561ec8d240482b56438a3b8cd021" translate="yes" xml:space="preserve">
          <source>These subroutines are only visible within the block in which they are declared, and only after that declaration:</source>
          <target state="translated">이 서브 루틴은 선언 된 블록 내에서만 그리고 그 선언 후에 만 ​​볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5002f9badee48e82e2e716cfadae24bcbea4d597" translate="yes" xml:space="preserve">
          <source>These symbolic constants are used by the &lt;code&gt;Level&lt;/code&gt; option in the constructor.</source>
          <target state="translated">이 기호 상수는 생성자 의 &lt;code&gt;Level&lt;/code&gt; 옵션에 의해 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="de652943440f246885efed6bc50624dc94d59ab4" translate="yes" xml:space="preserve">
          <source>These symbolic constants are used by the &lt;code&gt;Method&lt;/code&gt; option in the constructor.</source>
          <target state="translated">이 기호 상수는 생성자 의 &lt;code&gt;Method&lt;/code&gt; 옵션에 의해 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="4ec9419fff6178cfe016f55595d7a90364f97f63" translate="yes" xml:space="preserve">
          <source>These symbolic constants are used by the &lt;code&gt;Strategy&lt;/code&gt; option in the constructor.</source>
          <target state="translated">이 기호 상수는 생성자 의 &lt;code&gt;Strategy&lt;/code&gt; 옵션에서 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="09599ebf73a41d7f3fd327344d88fceb70681aab" translate="yes" xml:space="preserve">
          <source>These symbolic constants are used by the &lt;code&gt;flush&lt;/code&gt; method.</source>
          <target state="translated">이러한 기호 상수는 &lt;code&gt;flush&lt;/code&gt; 메소드에 의해 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="430e03746fb928435d7aa08e0e3eea945da77d4a" translate="yes" xml:space="preserve">
          <source>These symbols appear before the op-name, and indicate the B:: namespace that represents the ops in your Perl code.</source>
          <target state="translated">이 기호는 op- 이름 앞에 표시되며 Perl 코드에서 op를 나타내는 B :: 네임 스페이스를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="aded896deefbdaf418ca756d53862b007b01f8b9" translate="yes" xml:space="preserve">
          <source>These terms are interpreted as described in IETF RFC 2119.</source>
          <target state="translated">이러한 용어는 IETF RFC 2119에 설명 된대로 해석됩니다.</target>
        </trans-unit>
        <trans-unit id="2dbd7a997bbaaa84741a5e1fbd14e323c239d540" translate="yes" xml:space="preserve">
          <source>These terms are your choice of any of (1) the Perl Artistic Licence, or (2) version 2 of the GNU General Public License as published by the Free Software Foundation, or (3) any later version of the GNU General Public License.</source>
          <target state="translated">본 조건은 (1) Perl Artistic Licence 또는 (2) Free Software Foundation에서 게시 한 GNU General Public License 버전 2 또는 (3) 이후 버전의 GNU General Public License 중 하나를 선택하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="5c298e17caacd4174da139fecae9a62cf22ed5cc" translate="yes" xml:space="preserve">
          <source>These tests are expected to succeed. Usually, most or all of your tests are in this category. If a normal test doesn't succeed, then that means that something is</source>
          <target state="translated">이러한 테스트는 성공할 것으로 예상됩니다. 일반적으로 대부분 또는 모든 테스트는이 범주에 속합니다. 정상적인 테스트가 성공하지 못하면</target>
        </trans-unit>
        <trans-unit id="07325952f04a521e228140b025365f61c44af25f" translate="yes" xml:space="preserve">
          <source>These three macros are used to change a memory buffer size or to free a piece of memory no longer needed. The arguments to &lt;code&gt;Renew&lt;/code&gt; and &lt;code&gt;Renewc&lt;/code&gt; match those of &lt;code&gt;New&lt;/code&gt; and &lt;code&gt;Newc&lt;/code&gt; with the exception of not needing the &quot;magic cookie&quot; argument.</source>
          <target state="translated">이 세 가지 매크로는 메모리 버퍼 크기를 변경하거나 더 이상 필요없는 메모리를 비우는 데 사용됩니다. 인수는하는 &lt;code&gt;Renew&lt;/code&gt; 및 &lt;code&gt;Renewc&lt;/code&gt; 은 의 그와 일치하는 &lt;code&gt;New&lt;/code&gt; 및 &lt;code&gt;Newc&lt;/code&gt; 은 &quot;마법 쿠키&quot;인수를 필요로하지 않은 것 이외에는.</target>
        </trans-unit>
        <trans-unit id="3b6ba4dd1926405bd4af1077435f09d7c0a86a11" translate="yes" xml:space="preserve">
          <source>These three macros are used to move, copy, or zero out previously allocated memory. The &lt;code&gt;source&lt;/code&gt; and &lt;code&gt;dest&lt;/code&gt; arguments point to the source and destination starting points. Perl will move, copy, or zero out &lt;code&gt;number&lt;/code&gt; instances of the size of the &lt;code&gt;type&lt;/code&gt; data structure (using the &lt;code&gt;sizeof&lt;/code&gt; function).</source>
          <target state="translated">이 세 매크로는 이전에 할당 된 메모리를 이동, 복사 또는 제로화하는 데 사용됩니다. &lt;code&gt;source&lt;/code&gt; 및 &lt;code&gt;dest&lt;/code&gt; 인수는 소스 및 대상 시작 지점을 가리 킵니다. Perl은 &lt;code&gt;sizeof&lt;/code&gt; 함수를 사용하여 &lt;code&gt;type&lt;/code&gt; 데이터 구조 크기의 &lt;code&gt;number&lt;/code&gt; 인스턴스를 이동, 복사 또는 제로 아웃 합니다.</target>
        </trans-unit>
        <trans-unit id="335c760b89ccd866bd4e5cd7ec4e5ef4c599cbd4" translate="yes" xml:space="preserve">
          <source>These two export tags globally modify the default flags that bsd_glob() and, except on VMS, Perl's built-in &lt;code&gt;&lt;a href=&quot;../functions/glob&quot;&gt;glob&lt;/a&gt;&lt;/code&gt; operator use. &lt;code&gt;GLOB_NOCASE&lt;/code&gt; is turned on or off, respectively.</source>
          <target state="translated">이 두 개의 내보내기 태그는 bsd_glob () 및 Perl의 내장 &lt;code&gt;&lt;a href=&quot;../functions/glob&quot;&gt;glob&lt;/a&gt;&lt;/code&gt; 연산자 사용을 제외한 VMS를 제외하고 기본 플래그를 전체적으로 수정합니다 . &lt;code&gt;GLOB_NOCASE&lt;/code&gt; 가 각각 켜져 있거나 꺼져 있습니다.</target>
        </trans-unit>
        <trans-unit id="2f0953e19b1283bac80bee4d4c7b6b45f4e0bf61" translate="yes" xml:space="preserve">
          <source>These two export tags globally modify the default flags that bsd_glob() and, except on VMS, Perl's built-in &lt;code&gt;glob&lt;/code&gt; operator use. &lt;code&gt;GLOB_NOCASE&lt;/code&gt; is turned on or off, respectively.</source>
          <target state="translated">이 두 내보내기 태그는 bsd_glob () 및 VMS를 제외하고 Perl의 기본 제공 &lt;code&gt;glob&lt;/code&gt; 연산자가 사용 하는 기본 플래그를 전역 적으로 수정합니다 . &lt;code&gt;GLOB_NOCASE&lt;/code&gt; 는 각각 설정 또는 해제됩니다.</target>
        </trans-unit>
        <trans-unit id="9660fc7e9efd93a7abe465c81de57e11a5045a23" translate="yes" xml:space="preserve">
          <source>These two features are available starting with Perl 5.16.</source>
          <target state="translated">이 두 기능은 Perl 5.16부터 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fa5480402538907c3c246c95ce18885b4ae5225b" translate="yes" xml:space="preserve">
          <source>These two handles are held in the array part of the GLOB until either &lt;code&gt;reader&lt;/code&gt; or &lt;code&gt;writer&lt;/code&gt; is called.</source>
          <target state="translated">이 두 핸들은 &lt;code&gt;reader&lt;/code&gt; 또는 &lt;code&gt;writer&lt;/code&gt; 가 호출 될 때까지 GLOB의 배열 부분에 보유됩니다 .</target>
        </trans-unit>
        <trans-unit id="b0f87921e5dc8828d5a6d9ea360bbab6bf450027" translate="yes" xml:space="preserve">
          <source>These two lower level macros are defined, but must only be used when dealing with keys that are not &lt;code&gt;SV*&lt;/code&gt; s:</source>
          <target state="translated">이 두 개의 하위 수준 매크로는 정의되어 있지만 &lt;code&gt;SV*&lt;/code&gt; 가 아닌 키를 처리 할 때만 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="b2d573ca29281a8113cbc1782d1b335ee12feb43" translate="yes" xml:space="preserve">
          <source>These two lower level macros are defined, but must only be used when dealing with keys that are not &lt;code&gt;SV*&lt;/code&gt;s:</source>
          <target state="translated">이 두 개의 하위 수준 매크로가 정의되어 있지만 &lt;code&gt;SV*&lt;/code&gt; 가 아닌 키를 처리 할 때만 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="4ca39330e5c20e1239e2de6584e211ecc882f376" translate="yes" xml:space="preserve">
          <source>These two methods are discussed in the section &quot;Controlling Lookup Failure&quot;.</source>
          <target state="translated">이 두 가지 방법은 &quot;조회 실패 제어&quot;섹션에서 설명합니다.</target>
        </trans-unit>
        <trans-unit id="0b5a74bc9d562e1d07daa7fdb3ddf9da715c3433" translate="yes" xml:space="preserve">
          <source>These two methods return the pad names, using B::SPECIAL objects for null pointers and B::PADNAME objects otherwise.</source>
          <target state="translated">이 두 메소드는 널 포인터에 B :: SPECIAL 오브젝트를 사용하고 그렇지 않으면 B :: PADNAME 오브젝트를 사용하여 패드 이름을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="74ded97cfff6de6cbb1491c5e4159e3babfbcd36" translate="yes" xml:space="preserve">
          <source>These two parameters are used to specify the ambient pragmas in the format used by the special variables $^H and ${^WARNING_BITS}.</source>
          <target state="translated">이 두 매개 변수는 특수 변수 $ ^ H 및 $ {^ WARNING_BITS}에서 사용되는 형식으로 주변 pragma를 지정하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="668c2e486db55d10e5d748ec32a4297d24e80364" translate="yes" xml:space="preserve">
          <source>These two values for</source>
          <target state="translated">이 두 값은</target>
        </trans-unit>
        <trans-unit id="fded399d428f7e457d56603aa714f9152134fea1" translate="yes" xml:space="preserve">
          <source>These utilities help manage extra Perl modules that don't come with the perl distribution.</source>
          <target state="translated">이 유틸리티는 perl 배포와 함께 제공되지 않는 추가 Perl 모듈을 관리하는 데 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="25a3a72bd29e8059a94921c647bd6ce419cc4377" translate="yes" xml:space="preserve">
          <source>These values will not change for the duration of the tied hash</source>
          <target state="translated">이 값은 연결된 해시 기간 동안 변경되지 않습니다</target>
        </trans-unit>
        <trans-unit id="32b1d023c49a0c39aa9dd2f2164ec0cee979dc1b" translate="yes" xml:space="preserve">
          <source>These variables are global to an entire process. They are shared between all interpreters and all threads in a process.</source>
          <target state="translated">이러한 변수는 전체 프로세스에 대해 전역 적입니다. 프로세스의 모든 인터프리터와 모든 스레드간에 공유됩니다.</target>
        </trans-unit>
        <trans-unit id="c34e796e9875a610406c8f84f6c6846160af7938" translate="yes" xml:space="preserve">
          <source>These variables are global to an entire process. They are shared between all interpreters and all threads in a process. Any variables not documented here may be changed or removed without notice, so don't use them! If you feel you really do need to use an unlisted variable, first send email to &lt;a href=&quot;mailto:perl5-porters@perl.org&quot;&gt;perl5-porters@perl.org&lt;/a&gt;. It may be that someone there will point out a way to accomplish what you need without using an internal variable. But if not, you should get a go-ahead to document and then use the variable.</source>
          <target state="translated">이러한 변수는 전체 프로세스에 전역 적입니다. 프로세스의 모든 인터프리터와 모든 스레드간에 공유됩니다. 여기에 설명되지 않은 변수는 예고없이 변경되거나 제거 될 수 있으므로 사용하지 마십시오! 목록에없는 변수를 사용해야한다고 생각되면 먼저 &lt;a href=&quot;mailto:perl5-porters@perl.org&quot;&gt;perl5-porters@perl.org&lt;/a&gt; 로 이메일을 보내 십시오 . 누군가가 내부 변수를 사용하지 않고 필요한 것을 달성하는 방법을 지적 할 수 있습니다. 그러나 그렇지 않은 경우 문서화를 진행 한 다음 변수를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="53f5ad69f1f855f312a7f31903221b231e10b532" translate="yes" xml:space="preserve">
          <source>These variables are read-only and dynamically-scoped, unless we note otherwise.</source>
          <target state="translated">달리 언급하지 않는 한 이러한 변수는 읽기 전용이며 동적 범위입니다.</target>
        </trans-unit>
        <trans-unit id="2a1de91c215bb3911b0f9767ad8cb63c7c66902f" translate="yes" xml:space="preserve">
          <source>These variables are read-only and dynamically-scoped.</source>
          <target state="translated">이러한 변수는 읽기 전용이며 동적 범위입니다.</target>
        </trans-unit>
        <trans-unit id="c7b31baa2b679d0f632af8871cff4bfcc11fe664" translate="yes" xml:space="preserve">
          <source>These variables are used not only to represent Perl-space variables, but also any constants in the code, as well as some structures completely internal to Perl. The symbol table, for instance, is an ordinary Perl hash. Your code is represented by an SV as it's read into the parser; any program files you call are opened via ordinary Perl filehandles, and so on.</source>
          <target state="translated">이러한 변수는 Perl 공간 변수뿐만 아니라 코드의 상수 및 Perl 내부의 일부 구조를 나타내는 데 사용됩니다. 예를 들어, 심볼 테이블은 일반적인 Perl 해시입니다. 코드는 파서에서 읽을 때 SV로 표시됩니다. 호출하는 모든 프로그램 파일은 일반 Perl 파일 핸들 등을 통해 열립니다.</target>
        </trans-unit>
        <trans-unit id="82a728707d8b23d45f027d3109e809864b998b05" translate="yes" xml:space="preserve">
          <source>These variables determine the default state of the object created by calling the &lt;code&gt;new&lt;/code&gt; method, but cannot be used to alter the state of the object thereafter. The equivalent method names should be used instead to query or set the internal state of the object.</source>
          <target state="translated">이러한 변수는 &lt;code&gt;new&lt;/code&gt; 메소드 를 호출하여 작성된 오브젝트의 기본 상태를 판별 하지만 이후 오브젝트의 상태를 변경하는 데 사용할 수 없습니다. 대신 객체의 내부 상태를 쿼리하거나 설정하기 위해 동등한 메소드 이름을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="21d06b0dd7e2966bcc2949ad21cc8cf11e259059" translate="yes" xml:space="preserve">
          <source>These variables provide information about the current interpreter state.</source>
          <target state="translated">이 변수는 현재 인터프리터 상태에 대한 정보를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="44c61b22b7df4c04e51047feabc1fcdef03de656" translate="yes" xml:space="preserve">
          <source>These various prefixes correspond to the &lt;a href=&quot;http://man.he.net/man3/fopen&quot;&gt;fopen(3)&lt;/a&gt; modes of &lt;code&gt;r&lt;/code&gt;, &lt;code&gt;r+&lt;/code&gt;, &lt;code&gt;w&lt;/code&gt;, &lt;code&gt;w+&lt;/code&gt;, &lt;code&gt;a&lt;/code&gt;, and &lt;code&gt;a+&lt;/code&gt;.</source>
          <target state="translated">이러한 다양한 접두사 는 &lt;code&gt;r&lt;/code&gt; , &lt;code&gt;r+&lt;/code&gt; , &lt;code&gt;w&lt;/code&gt; , &lt;code&gt;w+&lt;/code&gt; , &lt;code&gt;a&lt;/code&gt; 및 &lt;code&gt;a+&lt;/code&gt; 의 &lt;a href=&quot;http://man.he.net/man3/fopen&quot;&gt;fopen (3)&lt;/a&gt; 모드에 해당합니다 .</target>
        </trans-unit>
        <trans-unit id="3ee1fe032de721a344cba89480c67e716abbee89" translate="yes" xml:space="preserve">
          <source>These various prefixes correspond to the fopen(3) modes of &lt;code&gt;r&lt;/code&gt; , &lt;code&gt;r+&lt;/code&gt; , &lt;code&gt;w&lt;/code&gt; , &lt;code&gt;w+&lt;/code&gt; , &lt;code&gt;a&lt;/code&gt; , and &lt;code&gt;a+&lt;/code&gt; .</source>
          <target state="translated">이러한 다양한 접두사는 &lt;code&gt;r&lt;/code&gt; , &lt;code&gt;r+&lt;/code&gt; , &lt;code&gt;w&lt;/code&gt; , &lt;code&gt;w+&lt;/code&gt; , &lt;code&gt;a&lt;/code&gt; 및 &lt;code&gt;a+&lt;/code&gt; 의 fopen (3) 모드에 해당합니다 .</target>
        </trans-unit>
        <trans-unit id="ab874a84fee8b167d507adabcea364962ee19104" translate="yes" xml:space="preserve">
          <source>These vars take 3 forms:</source>
          <target state="translated">이 변수는 3 가지 형태를 취합니다.</target>
        </trans-unit>
        <trans-unit id="b607e9f6b449fd1b8f047ca8c774e440f540bc1c" translate="yes" xml:space="preserve">
          <source>These were was released in Test::More 0.82, and first shipped with Perl in 5.10.1 as part of Test::More 0.92.</source>
          <target state="translated">이것들은 Test :: More 0.82에서 출시되었으며, Test :: More 0.92의 일부로 5.10.1에서 Perl과 함께 처음 제공되었습니다.</target>
        </trans-unit>
        <trans-unit id="dbff7e2745b850ca42a72fcb2a24d874bb4460d2" translate="yes" xml:space="preserve">
          <source>These will take care of 64-bit integers and long doubles. For example:</source>
          <target state="translated">이것들은 64 비트 정수와 long double을 처리합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ac19dfbee94adc36e2c9732558c6cd8eefc750a8" translate="yes" xml:space="preserve">
          <source>These will tell you if you truly have an integer, double, or string pointer stored in your SV. The &quot;p&quot; stands for private.</source>
          <target state="translated">SV에 실제로 정수, 이중 또는 문자열 포인터가 저장되어 있는지 알려줍니다. &quot;p&quot;는 개인을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="01c10ede2ffed1b0b1b81928ac4993a2913e0a5d" translate="yes" xml:space="preserve">
          <source>These work as in normal strings.</source>
          <target state="translated">이것들은 일반 문자열에서와 같이 작동합니다.</target>
        </trans-unit>
        <trans-unit id="187ee14d57ea8ada7fd976b56339ad22b9d5a13e" translate="yes" xml:space="preserve">
          <source>These would be split and each converted to a prerequisite with a minimum version of zero.</source>
          <target state="translated">이들은 분할되고 각각 최소 버전이 0 인 전제 조건으로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="38675552ee022f79a520bb1f28a37d1e98aa3227" translate="yes" xml:space="preserve">
          <source>They all return true if the test passed, false if the test failed.</source>
          <target state="translated">테스트가 통과되면 모두 true를, 테스트가 실패하면 false를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="8c3cf570334019dd16b6da35836503ad0b730443" translate="yes" xml:space="preserve">
          <source>They also return and accept whole hash entries (&lt;code&gt;HE*&lt;/code&gt; ), making their use more efficient (since the hash number for a particular string doesn't have to be recomputed every time). See &lt;a href=&quot;perlapi&quot;&gt;perlapi&lt;/a&gt; for detailed descriptions.</source>
          <target state="translated">또한 전체 해시 항목 ( &lt;code&gt;HE*&lt;/code&gt; )을 반환하고 수락 하므로보다 효율적으로 사용할 수 있습니다 (특정 문자열의 해시 번호가 매번 다시 계산 될 필요가 없기 때문에). 자세한 설명 은 &lt;a href=&quot;perlapi&quot;&gt;perlapi&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="48ac4e95d836a1020bf0ae83cd70b2eeacf64b7e" translate="yes" xml:space="preserve">
          <source>They also return and accept whole hash entries (&lt;code&gt;HE*&lt;/code&gt;), making their use more efficient (since the hash number for a particular string doesn't have to be recomputed every time). See &lt;a href=&quot;perlapi&quot;&gt;perlapi&lt;/a&gt; for detailed descriptions.</source>
          <target state="translated">또한 전체 해시 항목 ( &lt;code&gt;HE*&lt;/code&gt; )을 반환하고 허용 하므로보다 효율적으로 사용할 수 있습니다 (특정 문자열의 해시 번호를 매번 다시 계산할 필요가 없기 때문입니다). 자세한 설명 은 &lt;a href=&quot;perlapi&quot;&gt;perlapi&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a25c349a57769dbafa1bf807ae04ad1d22921bb7" translate="yes" xml:space="preserve">
          <source>They are not exported and must be addressed using the full package name.</source>
          <target state="translated">이들은 내 보내지 않으며 전체 패키지 이름을 사용하여 해결해야합니다.</target>
        </trans-unit>
        <trans-unit id="82e0433b7d59191ca9d6b5b4f7f2c32e84b80d15" translate="yes" xml:space="preserve">
          <source>They are suspected to be compiler errors (at least the shuffle.t failure is known from some IRIX 6 setups) and math library errors (the Trig.t failure), but since IRIX 5 is long since end-of-lifed, further fixes for the IRIX are unlikely. If you can get gcc for 5.3, you could try that, too, since gcc in IRIX 6 is a known workaround for at least the shuffle.t and sort.t failures.</source>
          <target state="translated">컴파일러 오류 (적어도 shuffle.t 오류는 일부 IRIX 6 설정에서 알려짐) 및 수학 라이브러리 오류 (Trig.t 실패)로 의심되지만 IRIX 5는 수명이 다한 이후 오랫동안 수정되었으므로 추가 수정 IRIX는 거의 없습니다. 5.3의 gcc를 얻을 수 있다면 IRIX 6의 gcc는 적어도 shuffle.t 및 sort.t 오류에 대한 알려진 해결 방법이므로 시도해 볼 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="69688ab534f08d7044475644301b479b2c0aa07a" translate="yes" xml:space="preserve">
          <source>They are type specifiers, as detailed in &lt;a href=&quot;perldata&quot;&gt;perldata&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;perldata&quot;&gt;perldata에&lt;/a&gt; 자세히 설명 된대로 유형 지정자입니다 .</target>
        </trans-unit>
        <trans-unit id="e0af70f00dfa3e42a5613047a29fed35339f3d84" translate="yes" xml:space="preserve">
          <source>They come in handy when you want to print or find the size of data.</source>
          <target state="translated">인쇄하거나 데이터 크기를 찾을 때 유용합니다.</target>
        </trans-unit>
        <trans-unit id="af45a4b37483f2a06205c7d3d09277fb7f496321" translate="yes" xml:space="preserve">
          <source>They differ in how they behave if they have the same key as the default metadata. META_ADD will override the default value with its own. META_MERGE will merge its value with the default.</source>
          <target state="translated">기본 메타 데이터와 동일한 키가있는 경우 동작 방식이 다릅니다. META_ADD는 기본값을 기본값으로 무시합니다. META_MERGE는 해당 값을 기본값과 병합합니다.</target>
        </trans-unit>
        <trans-unit id="38d5f7d4e163392c98f5f93a608be715596d63d6" translate="yes" xml:space="preserve">
          <source>They exist principally so that you can write code like:</source>
          <target state="translated">기본적으로 존재하므로 다음과 같은 코드를 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1d5b76cad965b54d55da4f5003ea6633c3207e12" translate="yes" xml:space="preserve">
          <source>They look like they might have been meant to be the POSIX classes &lt;code&gt;[:alnum:]&lt;/code&gt; or &lt;code&gt;[:digit:]&lt;/code&gt;. If so, they should be written:</source>
          <target state="translated">POSIX 클래스 &lt;code&gt;[:alnum:]&lt;/code&gt; 또는 &lt;code&gt;[:digit:]&lt;/code&gt; 것처럼 보입니다 . 그렇다면 다음과 같이 작성해야합니다.</target>
        </trans-unit>
        <trans-unit id="7317b86bbf49f550672235cb05f34f1bf614569a" translate="yes" xml:space="preserve">
          <source>They may be deprecated in future versions.</source>
          <target state="translated">이후 버전에서는 더 이상 사용되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9d9f866ec06430c109794c0b11daa6f4be4c1816" translate="yes" xml:space="preserve">
          <source>They may be expecting something completely different.</source>
          <target state="translated">그들은 완전히 다른 것을 기대할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="330c7e5216d53f5b33c24e5c7f8fd3d4ead54c44" translate="yes" xml:space="preserve">
          <source>They seem to be caused by broken system header files, and also other open source projects are seeing them. The following HP-UX patches should make the warnings go away:</source>
          <target state="translated">시스템 헤더 파일이 손상되어 발생하는 것으로 보이며 다른 오픈 소스 프로젝트에서도 볼 수 있습니다. 다음 HP-UX 패치는 경고를 사라지게합니다.</target>
        </trans-unit>
        <trans-unit id="b797d5622b1d1393375da6062407cd69c0ce1eae" translate="yes" xml:space="preserve">
          <source>They work somewhat like compiler directives (pragmata) in that they tend to affect the compilation of your program, and thus will usually work well only when used within a &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt;&lt;/code&gt;. Most of these are lexically scoped, so an inner BLOCK may countermand them by saying:</source>
          <target state="translated">그것들은 프로그램의 컴파일에 영향을 미치는 경향이 있다는 점에서 컴파일러 지시문 (pragmata)과 다소 유사하므로 일반적으로 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt;&lt;/code&gt; 내에 사용될 때만 잘 작동합니다 . 이것들의 대부분은 어휘 범위가 있으므로 내부 블록은 다음과 같이 말함으로써 그들을 반박 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0fbe1e3187d25099c55738d9668bd711bb597a03" translate="yes" xml:space="preserve">
          <source>They work somewhat like compiler directives (pragmata) in that they tend to affect the compilation of your program, and thus will usually work well only when used within a &lt;code&gt;use&lt;/code&gt;, or &lt;code&gt;no&lt;/code&gt;. Most of these are lexically scoped, so an inner BLOCK may countermand them by saying:</source>
          <target state="translated">그들은 프로그램의 컴파일에 영향을 미치는 경향이 있다는 점에서 컴파일러 지시문 (pragmata)과 비슷하게 작동하므로 일반적으로 &lt;code&gt;use&lt;/code&gt; 내에서 사용될 때만 잘 작동 하거나 &lt;code&gt;no&lt;/code&gt; . 이들 중 대부분은 어휘 범위가 지정되어 있으므로 내부 BLOCK은 다음과 같이 말하여 대응 명령을 내릴 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6abf5248bc6675a47a3988cb21c2af942a4be9d1" translate="yes" xml:space="preserve">
          <source>They works like the same name operators as theirs.</source>
          <target state="translated">그들은 그들과 같은 이름 연산자처럼 작동합니다.</target>
        </trans-unit>
        <trans-unit id="dd7133f0a4178555cc80821515a5b2265342ef9d" translate="yes" xml:space="preserve">
          <source>They're opcode specific, and occur less often than the public ones, so they're represented by short mnemonics instead of single-chars; see B::Op_private and</source>
          <target state="translated">그것들은 오피 코드에 따라 다르며 공개 코드보다 덜 자주 발생하므로 단일 문자 대신 짧은 니모닉으로 표현됩니다. B :: Op_private 및</target>
        </trans-unit>
        <trans-unit id="0131651c3742a3954926cbf8ce6d20cf77a6751b" translate="yes" xml:space="preserve">
          <source>Things not effected by this flag</source>
          <target state="translated">이 플래그에 의해 영향을받지 않는 것</target>
        </trans-unit>
        <trans-unit id="c1537a4a381e27d6bdd2214d8f21c4c16bc119e0" translate="yes" xml:space="preserve">
          <source>Things that are broken or just don't work quite right.</source>
          <target state="translated">깨지거나 제대로 작동하지 않는 것들.</target>
        </trans-unit>
        <trans-unit id="a528372aced54ab7da812bd13e4c896f3899419e" translate="yes" xml:space="preserve">
          <source>Things that are effected by this flag</source>
          <target state="translated">이 플래그에 의해 영향을받는 것들</target>
        </trans-unit>
        <trans-unit id="1e84de00a451ba7e5c811ee4e926df7205dd8b28" translate="yes" xml:space="preserve">
          <source>Things that are formatter dependant</source>
          <target state="translated">포맷터에 따라 달라지는 것</target>
        </trans-unit>
        <trans-unit id="731699b64ef1b2479598864f867653535a2b0bbe" translate="yes" xml:space="preserve">
          <source>Things that make Perl easier to learn: Unix experience, almost any kind of programming experience, an understanding of regular expressions, and the ability to understand other people's code. If there's something you need to do, then it's probably already been done, and a working example is usually available for free. Don't forget Perl modules, either. They're discussed in Part 3 of this FAQ, along with &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fwww.cpan.org%2f&quot;&gt;CPAN&lt;/a&gt;, which is discussed in Part 2.</source>
          <target state="translated">Perl을 더 쉽게 배울 수있는 것 : 유닉스 경험, 거의 모든 종류의 프로그래밍 경험, 정규 표현식에 대한 이해 및 다른 사람들의 코드를 이해하는 능력. 당신이해야 할 일이 있다면, 이미 완료되었을 것입니다. 작업 예제는 일반적으로 무료로 제공됩니다. Perl 모듈도 잊지 마십시오. 이 FAQ의 Part 3과 Part 2에서 논의 된 &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fwww.cpan.org%2f&quot;&gt;CPAN&lt;/a&gt; 과 함께 논의되었다.</target>
        </trans-unit>
        <trans-unit id="6bcc1ca5e0a5ecd67da294c2c8f1e99255fb0dfb" translate="yes" xml:space="preserve">
          <source>Things that make Perl easier to learn: Unix experience, almost any kind of programming experience, an understanding of regular expressions, and the ability to understand other people's code. If there's something you need to do, then it's probably already been done, and a working example is usually available for free. Don't forget Perl modules, either. They're discussed in Part 3 of this FAQ, along with &lt;a href=&quot;http://www.cpan.org/&quot;&gt;CPAN&lt;/a&gt;, which is discussed in Part 2.</source>
          <target state="translated">Perl을 더 쉽게 배울 수있는 요소 : Unix 경험, 거의 모든 종류의 프로그래밍 경험, 정규식에 대한 이해, 다른 사람의 코드를 이해하는 능력. 당신이해야 할 일이 있다면, 아마 이미 완료되었을 것입니다. 그리고 작동하는 예제는 일반적으로 무료로 제공됩니다. Perl 모듈도 잊지 마십시오. 2 부에서 논의되는 &lt;a href=&quot;http://www.cpan.org/&quot;&gt;CPAN&lt;/a&gt; 과 함께이 FAQ의 3 부에서 논의됩니다.</target>
        </trans-unit>
        <trans-unit id="d9717c58dca00ca4e0fdd51bb342bee53c9f4f98" translate="yes" xml:space="preserve">
          <source>Things that need to be done to improve this document.</source>
          <target state="translated">이 문서를 개선하기 위해 수행해야 할 사항.</target>
        </trans-unit>
        <trans-unit id="8bbe6bf4aeb5dea432e939ae88abe2437f8000be" translate="yes" xml:space="preserve">
          <source>Things to take special care with, sometimes called WARNINGS.</source>
          <target state="translated">경고라고도하는 특별한주의 사항.</target>
        </trans-unit>
        <trans-unit id="f330d2b9426f91894c132eec7839a297e7c3f2bb" translate="yes" xml:space="preserve">
          <source>Think about reusability. Why waste brainpower on a one-shot when you might want to do something like it again? Consider generalizing your code. Consider writing a module or object class. Consider making your code run cleanly with &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings&lt;/code&gt; (or &lt;b&gt;-w&lt;/b&gt;) in effect. Consider giving away your code. Consider changing your whole world view. Consider... oh, never mind.</source>
          <target state="translated">재사용 가능성에 대해 생각하십시오. 다시 같은 일을하고 싶을 때 왜 원샷에서 두뇌를 낭비 하는가? 코드를 일반화하십시오. 모듈 또는 객체 클래스 작성을 고려하십시오. 코드를 깔끔하게 실행하십시오 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings&lt;/code&gt; (또는&lt;b&gt; -w&lt;/b&gt; 효과). 코드를 제공하는 것을 고려하십시오. 전체 세계관을 바꾸는 것을 고려하십시오. 생각 해봐 ... 오, 괜찮아</target>
        </trans-unit>
        <trans-unit id="c82b5076931a791a0eeb9910a5bd8e3a5422353a" translate="yes" xml:space="preserve">
          <source>Think about reusability. Why waste brainpower on a one-shot when you might want to do something like it again? Consider generalizing your code. Consider writing a module or object class. Consider making your code run cleanly with &lt;code&gt;use strict&lt;/code&gt; and &lt;code&gt;use warnings&lt;/code&gt; in effect. Consider giving away your code. Consider changing your whole world view. Consider... oh, never mind.</source>
          <target state="translated">재사용 가능성에 대해 생각하십시오. 그런 일을 다시하고 싶을 때 원샷에 왜 두뇌 능력을 낭비할까요? 코드 일반화를 고려하십시오. 모듈 또는 객체 클래스 작성을 고려하십시오. 깨끗하게 코드 실행을 고려해 &lt;code&gt;use strict&lt;/code&gt; 및 &lt;code&gt;use warnings&lt;/code&gt; 효과가있다. 코드를 제공하는 것을 고려하십시오. 전체 세계관을 바꾸는 것을 고려하십시오. 생각 해봐 ... 오, 신경 쓰지 마.</target>
        </trans-unit>
        <trans-unit id="369cf00ca2016a53c53652dbdfad94b27946d096" translate="yes" xml:space="preserve">
          <source>Think carefully about whether OO is appropriate for your module. Gratuitous object orientation results in complex APIs which are difficult for the average module user to understand or use.</source>
          <target state="translated">OO가 모듈에 적합한 지 신중하게 생각하십시오. 과도한 객체 지향은 복잡한 API를 생성하여 일반 모듈 사용자가 이해하거나 사용하기 어렵습니다.</target>
        </trans-unit>
        <trans-unit id="d05ca6e0d80ee8bcc4977d0ae97da44f7a9ad4e9" translate="yes" xml:space="preserve">
          <source>Think of these macros as working a bit like &lt;code&gt;{&lt;/code&gt; and &lt;code&gt;}&lt;/code&gt; in Perl to limit the scope of local variables.</source>
          <target state="translated">이 매크로 를 로컬 변수의 범위를 제한하기 위해 Perl에서 &lt;code&gt;{&lt;/code&gt; 및 &lt;code&gt;}&lt;/code&gt; 와 같이 작동하는 것으로 생각하십시오 .</target>
        </trans-unit>
        <trans-unit id="b798a2f7f99599171fc59b43924703f9a2be020d" translate="yes" xml:space="preserve">
          <source>Thinking of mixing &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork()&lt;/a&gt;&lt;/code&gt; and threads? Please lie down and wait until the feeling passes. Be aware that the semantics of &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork()&lt;/a&gt;&lt;/code&gt; vary between platforms. For example, some Unix systems copy all the current threads into the child process, while others only copy the thread that called &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork()&lt;/a&gt;&lt;/code&gt;. You have been warned!</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork()&lt;/a&gt;&lt;/code&gt; 와 스레드 를 혼합 할 생각 입니까? 누워서 느낌이 지나갈 때까지 기다리십시오. 의 의미가 &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork()&lt;/a&gt;&lt;/code&gt; 플랫폼마다 다릅니다. 예를 들어, 일부 유닉스 시스템은 모든 현재 스레드를 하위 프로세스로 복사하고 다른 유닉스 시스템은 &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork()&lt;/a&gt;&lt;/code&gt; 라는 스레드 만 복사합니다. 경고를 받았습니다!</target>
        </trans-unit>
        <trans-unit id="d855fc6f4fe4cadf88e9af157138a372400d46cf" translate="yes" xml:space="preserve">
          <source>Thinking of mixing &lt;code&gt;fork()&lt;/code&gt; and threads? Please lie down and wait until the feeling passes. Be aware that the semantics of &lt;code&gt;fork()&lt;/code&gt; vary between platforms. For example, some Unix systems copy all the current threads into the child process, while others only copy the thread that called &lt;code&gt;fork()&lt;/code&gt;. You have been warned!</source>
          <target state="translated">&lt;code&gt;fork()&lt;/code&gt; 와 쓰레드 를 섞는 것을 생각 하고 계십니까? 누워서 기분이 지나갈 때까지 기다려주세요. &lt;code&gt;fork()&lt;/code&gt; 의 의미는 플랫폼마다 다릅니다. 예를 들어, 일부 Unix 시스템은 모든 현재 스레드를 자식 프로세스에 복사하는 반면 다른 시스템은 &lt;code&gt;fork()&lt;/code&gt; 를 호출 한 스레드 만 복사합니다 . 경고를 받았습니다!</target>
        </trans-unit>
        <trans-unit id="55ee5f16e1e054ccf1ec34b584008166d240354f" translate="yes" xml:space="preserve">
          <source>Third Edition, revised by J. C. Dumbreck. Oxford University Press.</source>
          <target state="translated">JC Dumbreck에 의해 개정 된 Third Edition. 옥스포드 대학 출판부.</target>
        </trans-unit>
        <trans-unit id="b2cb87c02d6ed6f908d60b7b75a5f67020a27ac2" translate="yes" xml:space="preserve">
          <source>Third:</source>
          <target state="translated">Third:</target>
        </trans-unit>
        <trans-unit id="7971e6a051104074fdae0f02322417b6eb5695a2" translate="yes" xml:space="preserve">
          <source>This</source>
          <target state="translated">This</target>
        </trans-unit>
        <trans-unit id="b2ba5f429f54422412e8d8cc932f13b88c985b41" translate="yes" xml:space="preserve">
          <source>This &quot;in all contexts&quot; construction is very common, and can be abbreviated, using the 'fail' key. This sets both the &lt;code&gt;scalar&lt;/code&gt; and &lt;code&gt;list&lt;/code&gt; hints to the same value:</source>
          <target state="translated">이 &quot;모든 상황에서&quot;구성은 매우 일반적이며 '실패'키를 사용하여 축약 할 수 있습니다. 이렇게하면 &lt;code&gt;scalar&lt;/code&gt; 및 &lt;code&gt;list&lt;/code&gt; 힌트가 모두 동일한 값으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="3b8ab74e7f407ff0613b1e22c57e79a02a3a70ca" translate="yes" xml:space="preserve">
          <source>This 'cheat sheet' is a handy reference, meant for beginning Perl programmers. Not everything is mentioned, but 195 features may already be overwhelming.</source>
          <target state="translated">이 '치트 시트'는 Perl 프로그래머를 시작하기위한 편리한 참고 자료입니다. 모든 것이 언급되어 있지는 않지만 195 개의 기능이 이미 압도적 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b87ead78f18a2a4de0a885f72703b5402a2fe039" translate="yes" xml:space="preserve">
          <source>This &lt;b&gt;DOES NOT&lt;/b&gt; affect context on other hubs, only the hub used by the context will be affected.</source>
          <target state="translated">이것은 &lt;b&gt;하지 않습니다&lt;/b&gt; 다른 허브에 상황에 영향을 문맥에서 사용하는 전용 허브에 영향을 미칠 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="70790687de96ba2a981057f320692cde5f07c030" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;$coderef&lt;/code&gt; is called before the one specified via &lt;code&gt;filter_json_object&lt;/code&gt;, if any. It gets passed the single value in the JSON object. If it returns a single value, it will be inserted into the data structure. If it returns nothing (not even &lt;code&gt;undef&lt;/code&gt; but the empty list), the callback from &lt;code&gt;filter_json_object&lt;/code&gt; will be called next, as if no single-key callback were specified.</source>
          <target state="translated">이 &lt;code&gt;$coderef&lt;/code&gt; &lt;code&gt;filter_json_object&lt;/code&gt; (있는 경우) 를 통해 지정된 것보다 먼저 호출 됩니다. JSON 개체의 단일 값이 전달됩니다. 단일 값을 반환하면 데이터 구조에 삽입됩니다. 아무 것도 반환하지 않으면 ( &lt;code&gt;undef&lt;/code&gt; 가 아니라 빈 목록), 단일 키 콜백이 지정되지 않은 것처럼 &lt;code&gt;filter_json_object&lt;/code&gt; 의 콜백 이 다음에 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="449deebd32ed5eaf74d8aec8711aa290af1210b0" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;&lt;a href=&quot;../functions/write&quot;&gt;write&lt;/a&gt;&lt;/code&gt; is somewhat like &lt;code&gt;&lt;a href=&quot;../functions/write&quot;&gt;write&lt;/a&gt;&lt;/code&gt; found in C, in that it is the opposite of read. The wrapper for the perl &lt;code&gt;&lt;a href=&quot;../functions/write&quot;&gt;write&lt;/a&gt;&lt;/code&gt; function is called &lt;code&gt;format_write&lt;/code&gt; . However, whilst the C &lt;code&gt;&lt;a href=&quot;../functions/write&quot;&gt;write&lt;/a&gt;&lt;/code&gt; function returns the number of bytes written, this &lt;code&gt;&lt;a href=&quot;../functions/write&quot;&gt;write&lt;/a&gt;&lt;/code&gt; function simply returns true if successful (like &lt;code&gt;&lt;a href=&quot;../functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt;). A more C-like &lt;code&gt;&lt;a href=&quot;../functions/write&quot;&gt;write&lt;/a&gt;&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../functions/syswrite&quot;&gt;syswrite&lt;/a&gt;&lt;/code&gt; (see above).</source>
          <target state="translated">이 &lt;code&gt;&lt;a href=&quot;../functions/write&quot;&gt;write&lt;/a&gt;&lt;/code&gt; 는 읽기와 반대되는 점에서 C에서 발견 된 &lt;code&gt;&lt;a href=&quot;../functions/write&quot;&gt;write&lt;/a&gt;&lt;/code&gt; 와 다소 비슷 합니다. perl &lt;code&gt;&lt;a href=&quot;../functions/write&quot;&gt;write&lt;/a&gt;&lt;/code&gt; 함수 의 랩퍼 는 &lt;code&gt;format_write&lt;/code&gt; 라고 합니다 . 그러나 C &lt;code&gt;&lt;a href=&quot;../functions/write&quot;&gt;write&lt;/a&gt;&lt;/code&gt; 함수는 쓴 바이트 수를 반환 하지만 이 &lt;code&gt;&lt;a href=&quot;../functions/write&quot;&gt;write&lt;/a&gt;&lt;/code&gt; 함수는 성공하면 (예 : &lt;code&gt;&lt;a href=&quot;../functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; ) 참을 반환합니다 . 더 C와 같은 &lt;code&gt;&lt;a href=&quot;../functions/write&quot;&gt;write&lt;/a&gt;&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;../functions/syswrite&quot;&gt;syswrite&lt;/a&gt;&lt;/code&gt; 입니다 (위 참조).</target>
        </trans-unit>
        <trans-unit id="7f5f153f1937141026057a558986308f5230af60" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;IO::Socket::INET&lt;/code&gt;-style argument is ignored, except if it is defined but false. See the &lt;code&gt;IO::Socket::INET&lt;/code&gt; INCOMPATIBILITES section below.</source>
          <target state="translated">이 &lt;code&gt;IO::Socket::INET&lt;/code&gt; 스타일 인수는 정의되었지만 false 인 경우를 제외하고 무시됩니다. 아래의 &lt;code&gt;IO::Socket::INET&lt;/code&gt; INCOMPATIBILITES 섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="809a4dea69e66cbb56a6927382a1c7747ff2b245" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;POSIX::SigAction&lt;/code&gt; object is intended for use with the &lt;code&gt;POSIX::sigaction()&lt;/code&gt; function.</source>
          <target state="translated">이 &lt;code&gt;POSIX::SigAction&lt;/code&gt; 객체는 &lt;code&gt;POSIX::sigaction()&lt;/code&gt; 함수 와 함께 사용하기위한 것입니다 .</target>
        </trans-unit>
        <trans-unit id="4dae482e8849607cb08d3169246c6cbb9eb47f40" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;write&lt;/code&gt; is somewhat like &lt;code&gt;write&lt;/code&gt; found in C, in that it is the opposite of read. The wrapper for the perl &lt;code&gt;write&lt;/code&gt; function is called &lt;code&gt;format_write&lt;/code&gt;. However, whilst the C &lt;code&gt;write&lt;/code&gt; function returns the number of bytes written, this &lt;code&gt;write&lt;/code&gt; function simply returns true if successful (like &lt;code&gt;print&lt;/code&gt;). A more C-like &lt;code&gt;write&lt;/code&gt; is &lt;code&gt;syswrite&lt;/code&gt; (see above).</source>
          <target state="translated">이 &lt;code&gt;write&lt;/code&gt; 는 읽기와 반대라는 점에서 C에서 발견 된 &lt;code&gt;write&lt;/code&gt; 와 다소 비슷 합니다. perl &lt;code&gt;write&lt;/code&gt; 함수 의 래퍼 는 &lt;code&gt;format_write&lt;/code&gt; 라고 합니다 . 그러나 C &lt;code&gt;write&lt;/code&gt; 함수는 쓴 바이트 수를 반환 하지만 이 &lt;code&gt;write&lt;/code&gt; 함수는 성공하면 단순히 true를 반환합니다 (예 : &lt;code&gt;print&lt;/code&gt; ). C와 유사한 &lt;code&gt;write&lt;/code&gt; 는 &lt;code&gt;syswrite&lt;/code&gt; 입니다 (위 참조).</target>
        </trans-unit>
        <trans-unit id="8a5e4636d7ee396c2538c58facc6d68cb4eb415b" translate="yes" xml:space="preserve">
          <source>This CPAN module lets you create application-level DTrace probes written in Perl.</source>
          <target state="translated">이 CPAN 모듈을 사용하면 Perl로 작성된 애플리케이션 레벨 DTrace 프로브를 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="511e2864753cd52a1ebcc75d7881ce1d9fb8ec6b" translate="yes" xml:space="preserve">
          <source>This DBM filter allows you to choose the character encoding will be store in the DBM file. The usage is</source>
          <target state="translated">이 DBM 필터를 사용하면 DBM 파일에 저장 될 문자 인코딩을 선택할 수 있습니다. 사용법은</target>
        </trans-unit>
        <trans-unit id="8d6cf7bbaf015be1842a3503d362b5db206d9719" translate="yes" xml:space="preserve">
          <source>This DBM filter is used when interoperating with a C/C++ application that uses a C int as either the key and/or value in the DBM file.</source>
          <target state="translated">이 DBM 필터는 C int를 DBM 파일의 키 및 / 또는 값으로 사용하는 C / C ++ 애플리케이션과 상호 운용 할 때 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="b9afd96c4f0113b4f4a0ca24ef6b7ce1c1eceace" translate="yes" xml:space="preserve">
          <source>This DBM filter will compress all data before it is written to the database and uncompressed it on reading.</source>
          <target state="translated">이 DBM 필터는 데이터베이스에 기록되기 전에 모든 데이터를 압축하고 읽을 때 압축 해제합니다.</target>
        </trans-unit>
        <trans-unit id="b3c940c7a493363dfcc2ec46854ae2f8bf461ebc" translate="yes" xml:space="preserve">
          <source>This Filter will ensure that all data written to the DBM will be encoded in UTF-8.</source>
          <target state="translated">이 필터는 DBM에 기록 된 모든 데이터가 UTF-8로 인코딩되도록합니다.</target>
        </trans-unit>
        <trans-unit id="fc3e8623db78291ea4659afa55c27a0af1b2fdc1" translate="yes" xml:space="preserve">
          <source>This IPv4-only function is provided largely for legacy reasons. Newly-written code should use getaddrinfo() or inet_pton() instead for IPv6 support.</source>
          <target state="translated">이 IPv4 전용 기능은 대부분 레거시 이유로 제공됩니다. 새로 작성된 코드는 IPv6 지원 대신 getaddrinfo () 또는 inet_pton ()을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="a1b8940a7dbf27c2770dc1f730a7a76eb668b365" translate="yes" xml:space="preserve">
          <source>This IPv4-only function is provided largely for legacy reasons. Newly-written code should use getnameinfo() or inet_ntop() instead for IPv6 support.</source>
          <target state="translated">이 IPv4 전용 기능은 대부분 레거시 이유로 제공됩니다. 새로 작성된 코드는 IPv6 지원 대신 getnameinfo () 또는 inet_ntop ()을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="86d1fee384e2c64930f89930b421f43ee54e6dc6" translate="yes" xml:space="preserve">
          <source>This List indicates the person(s) to contact concerning the distribution. The preferred form of the contact string is:</source>
          <target state="translated">이 목록은 배포와 관련하여 연락 할 사람 (들)을 나타냅니다. 선호하는 연락처 문자열 형식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="722a81c183f099f4bcdf928fea77c08691faed91" translate="yes" xml:space="preserve">
          <source>This MGVTBL structure is set at compile-time in</source>
          <target state="translated">이 MGVTBL 구조는 컴파일 타임에</target>
        </trans-unit>
        <trans-unit id="1eec4cedd7f076095ac2a0ca9a9e96a3c88c0b97" translate="yes" xml:space="preserve">
          <source>This Map describes any files, directories, packages, and namespaces that are private to the packaging or implementation of the distribution and should be ignored by indexing or search tools. Note that this is a list of exclusions, and the spec does not define what to</source>
          <target state="translated">이 맵은 배포의 패키징 또는 구현에 전용이며 인덱싱 또는 검색 도구에서 무시해야하는 모든 파일, 디렉토리, 패키지 및 네임 스페이스를 설명합니다. 이것은 제외 목록이며 사양은 수행 할 작업을 정의하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7caefbceb3b0366d47f8a2872ed9d7c71305e207" translate="yes" xml:space="preserve">
          <source>This Map describes optional features with incremental prerequisites. Each key of the &lt;code&gt;optional_features&lt;/code&gt; Map is a String used to identify the feature and each value is a Map with additional information about the feature. Valid subkeys include:</source>
          <target state="translated">이 맵은 증분 필수 구성 요소가있는 선택적 기능을 설명합니다. &lt;code&gt;optional_features&lt;/code&gt; 맵 의 각 키는 기능을 식별하는 데 사용되는 문자열이며 각 값은 기능에 대한 추가 정보가있는 맵입니다. 유효한 하위 키는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="afdaa79397a40333f189bcdc4086a9d759ea82a0" translate="yes" xml:space="preserve">
          <source>This Perl can't reset CRTL environ elements (%s)</source>
          <target state="translated">이 Perl은 CRTL 환경 요소 (% s)를 재설정 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="bb183f03494180e283020e26b8860c5c80cf5dab" translate="yes" xml:space="preserve">
          <source>This Perl can't set CRTL environ elements (%s=%s)</source>
          <target state="translated">이 Perl은 CRTL 환경 요소를 설정할 수 없습니다 (% s = % s).</target>
        </trans-unit>
        <trans-unit id="b39321835728914af608511ebd3abfb95683e78c" translate="yes" xml:space="preserve">
          <source>This Perl has not been built with support for randomized hash key traversal but something called Perl_hv_rand_set().</source>
          <target state="translated">이 Perl은 무작위 해시 키 순회를 지원하는 것이 아니라 Perl_hv_rand_set ()이라는 이름으로 빌드되었습니다.</target>
        </trans-unit>
        <trans-unit id="705edfac9681ecc4ad006397ee2bb051d4e6ffce" translate="yes" xml:space="preserve">
          <source>This Perl not built to support threads</source>
          <target state="translated">이 Perl은 스레드를 지원하도록 구축되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="d239471597c0b244a6c849bc4b21df8bfaf5b7db" translate="yes" xml:space="preserve">
          <source>This PerlIO layer opens a filehandle with a transparent encoding filter.</source>
          <target state="translated">이 PerlIO 레이어는 투명한 인코딩 필터로 파일 핸들을 엽니 다.</target>
        </trans-unit>
        <trans-unit id="a75ec57aa7be5f3e457676aa78fd87835feef6b5" translate="yes" xml:space="preserve">
          <source>This README was written by Sherm Pendley &amp;lt;sherm@dot-app.org&amp;gt;, and subsequently updated by Dominic Dunlop &amp;lt;domo@computer.org&amp;gt; and Breno G. de Oliveira &amp;lt;garu@cpan.org&amp;gt;. The &quot;Starting From Scratch&quot; recipe was contributed by John Montbriand &amp;lt;montbriand@apple.com&amp;gt;.</source>
          <target state="translated">이 읽어보기는 Sherm Pendley &amp;lt;sherm@dot-app.org&amp;gt;에 의해 작성되었으며 이후 Dominic Dunlop &amp;lt;domo@computer.org&amp;gt; 및 Breno G. de Oliveira &amp;lt;garu@cpan.org&amp;gt;에 의해 업데이트되었습니다. &quot;스크래치에서 시작&quot;레시피는 John Montbriand &amp;lt;montbriand@apple.com&amp;gt;에서 제공했습니다.</target>
        </trans-unit>
        <trans-unit id="ebd95c4f5ef4e4618995d165e48685abb75f4895" translate="yes" xml:space="preserve">
          <source>This TODO</source>
          <target state="translated">이 TODO</target>
        </trans-unit>
        <trans-unit id="65401762a1d1713b0f2418936baae5413a27fffb" translate="yes" xml:space="preserve">
          <source>This UTF8 flag is not visible in Perl scripts, exactly for the same reason you cannot (or rather, you</source>
          <target state="translated">이 UTF8 플래그는 Perl 스크립트에서 보이지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4052f785cdabbfe61b3039b9711ade7bde52e516" translate="yes" xml:space="preserve">
          <source>This a copy of the $md5 object. It is useful when you do not want to destroy the digests state, but need an intermediate value of the digest, e.g. when calculating digests iteratively on a continuous data stream. Example:</source>
          <target state="translated">이것은 $ md5 객체의 복사본입니다. 다이제스트 상태를 제거하고 싶지 않지만 다이제스트의 중간 값이 필요한 경우 (예 : 연속 데이터 스트림에서 다이제스트를 반복적으로 계산할 때) 유용합니다. 예:</target>
        </trans-unit>
        <trans-unit id="1a5e99b1d24a191f2d8182b7f2daff87d3990749" translate="yes" xml:space="preserve">
          <source>This a perl class / module to enable you to use ARexx with your perlscript. Creating a function host or executing scripts in other hosts. The API is loosley modeled on the python arexx module supplied by with AmigaOS4.1</source>
          <target state="translated">이것은 perlscript와 함께 ARexx를 사용할 수 있도록하는 perl 클래스 / 모듈입니다. 함수 호스트를 만들거나 다른 호스트에서 스크립트를 실행합니다. API는 AmigaOS4.1과 함께 제공되는 python arexx 모듈에서 모델링 된 loosley입니다.</target>
        </trans-unit>
        <trans-unit id="a160f7af224910b6019387f0709ad781bada6850" translate="yes" xml:space="preserve">
          <source>This a perl class / module to enables you to use various low level Amiga features such as waiting on an Exec signal</source>
          <target state="translated">이 perl 클래스 / 모듈은 Exec 신호 대기와 같은 다양한 저수준 Amiga 기능을 사용할 수 있도록합니다.</target>
        </trans-unit>
        <trans-unit id="93d41ee6bf8db4bf77abd4b3d67925380ae0e1a1" translate="yes" xml:space="preserve">
          <source>This aborts parsing of the current document, by switching on the flag that indicates that EOF has been seen. In particularly drastic cases, you might want to do this. It's rather nicer than just calling &lt;code&gt;die&lt;/code&gt;!</source>
          <target state="translated">이렇게하면 EOF가 표시되었음을 나타내는 플래그를 켜서 현재 문서의 구문 분석을 중단합니다. 특히 과감한 경우에는이 작업을 수행 할 수 있습니다. ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ 단순히 &lt;code&gt;die&lt;/code&gt; 라고 부르는 것보다 오히려 더 좋습니다 !</target>
        </trans-unit>
        <trans-unit id="80e3860a781a3958ead624c7605f67461e6feac0" translate="yes" xml:space="preserve">
          <source>This action at a distance can be confusing, so you should be careful with your use of weaken. You should weaken the reference in the variable that will go out of scope</source>
          <target state="translated">멀리서이 동작은 혼동 될 수 있으므로 약화 사용에주의해야합니다. 범위를 벗어날 변수의 참조를 약화시켜야합니다.</target>
        </trans-unit>
        <trans-unit id="6a24d0142f914abb864cc53bd42fb39ecd311c30" translate="yes" xml:space="preserve">
          <source>This action at a distance, perhaps a large distance, can lead to Perl silently misinterpreting what you meant, so when you specify that you want extra checking by &lt;code&gt;use re 'strict'&lt;/code&gt;, this warning is generated. If you meant the character as a literal, simply confirm that to Perl by preceding the character with a backslash, or make it into a bracketed character class (like &lt;code&gt;[}]&lt;/code&gt;). If you meant it as closing a corresponding &lt;code&gt;[&lt;/code&gt; or &lt;code&gt;{&lt;/code&gt;, you'll need to look back through the pattern to find out why that isn't happening.</source>
          <target state="translated">먼 거리 (아마도 먼 거리)에서이 작업을 수행하면 Perl이 사용자가 의미하는 바를 조용히 잘못 해석 할 수 있으므로 &lt;code&gt;use re 'strict'&lt;/code&gt; 를 사용하여 추가 검사를 원한다고 지정하면 이 경고가 생성됩니다. 문자를 리터럴로 의미했다면 문자 앞에 백 슬래시를 붙여 Perl에 확인하거나 대괄호 문자 클래스 (예 : &lt;code&gt;[}]&lt;/code&gt; ) 로 만드십시오 . 해당하는 &lt;code&gt;[&lt;/code&gt; 또는 &lt;code&gt;{&lt;/code&gt; 를 닫는 것을 의미했다면 패턴을 다시 살펴보고 왜 발생하지 않는지 알아 내야합니다.</target>
        </trans-unit>
        <trans-unit id="bddc211ce6f51988dd46dcc142aadb4340b590dc" translate="yes" xml:space="preserve">
          <source>This adds a new excluded version. For example, you might use these three method calls:</source>
          <target state="translated">이렇게하면 새 제외 된 버전이 추가됩니다. 예를 들어 다음 세 가지 메서드 호출을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9b2561f6cd7d300e2bc3c36c86f010a9c3614953" translate="yes" xml:space="preserve">
          <source>This adds a new maximum version requirement. If the new requirement is redundant to the existing specification, this has no effect.</source>
          <target state="translated">이것은 새로운 최대 버전 요구 사항을 추가합니다. 새 요구 사항이 기존 사양에 중복되는 경우 아무 효과가 없습니다.</target>
        </trans-unit>
        <trans-unit id="8012fe61f20e1a816c0a4a7242f87aff7c9fa563" translate="yes" xml:space="preserve">
          <source>This adds a new minimum version requirement. If the new requirement is redundant to the existing specification, this has no effect.</source>
          <target state="translated">이것은 새로운 최소 버전 요구 사항을 추가합니다. 새 요구 사항이 기존 사양에 중복되는 경우 아무 효과가 없습니다.</target>
        </trans-unit>
        <trans-unit id="885dd09085650ee6eee0bbc42fb708bdc29aeb18" translate="yes" xml:space="preserve">
          <source>This adds your coderef as a follow-up to the root hub after Test2 is finished loading.</source>
          <target state="translated">이렇게하면 Test2가로드를 마친 후 루트 허브에 대한 후속 조치로 coderef가 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="31854231243bab283e1b65fbafa450794c35d551" translate="yes" xml:space="preserve">
          <source>This affects the &quot;udp&quot;, &quot;tcp&quot;, and &quot;syn&quot; protocols.</source>
          <target state="translated">이는 &quot;udp&quot;, &quot;tcp&quot;및 &quot;syn&quot;프로토콜에 영향을줍니다.</target>
        </trans-unit>
        <trans-unit id="c5505e253bfc6bced2ca4d4a2dc1f5c2494aeece" translate="yes" xml:space="preserve">
          <source>This affects the &lt;code&gt;CreateFile&lt;/code&gt; and &lt;code&gt;GetVolumeInformation&lt;/code&gt; calls.</source>
          <target state="translated">이는 &lt;code&gt;CreateFile&lt;/code&gt; 및 &lt;code&gt;GetVolumeInformation&lt;/code&gt; 호출에 영향을줍니다 .</target>
        </trans-unit>
        <trans-unit id="cddee3439343bde4e7f7a86c9eebcbe6c66c9384" translate="yes" xml:space="preserve">
          <source>This affects the &lt;code&gt;ReadFile&lt;/code&gt; and &lt;code&gt;WriteFile&lt;/code&gt; calls.</source>
          <target state="translated">이것은 &lt;code&gt;ReadFile&lt;/code&gt; 및 &lt;code&gt;WriteFile&lt;/code&gt; 호출에 영향을줍니다 .</target>
        </trans-unit>
        <trans-unit id="873bbf87a172d66b10ad3b61904a0d639ca9b860" translate="yes" xml:space="preserve">
          <source>This allows Math::BigInt to correctly retrieve package globals from the subclass, like &lt;code&gt;$SubClass::precision&lt;/code&gt; . See t/Math/BigInt/Subclass.pm or t/Math/BigFloat/SubClass.pm completely functional subclass examples.</source>
          <target state="translated">이를 통해 Math :: BigInt는 &lt;code&gt;$SubClass::precision&lt;/code&gt; 과 같은 서브 클래스에서 패키지 글로벌을 올바르게 검색 할 수 있습니다 . t / Math / BigInt / Subclass.pm 또는 t / Math / BigFloat / SubClass.pm 완전 기능 서브 클래스 예제를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="fa3309366ca565335ff8288304c30cc7b99e923e" translate="yes" xml:space="preserve">
          <source>This allows Math::BigInt to correctly retrieve package globals from the subclass, like &lt;code&gt;$SubClass::precision&lt;/code&gt;. See t/Math/BigInt/Subclass.pm or t/Math/BigFloat/SubClass.pm completely functional subclass examples.</source>
          <target state="translated">이렇게하면 Math :: BigInt가 &lt;code&gt;$SubClass::precision&lt;/code&gt; 과 같은 하위 클래스에서 패키지 전역을 올바르게 검색 할 수 있습니다 . t / Math / BigInt / Subclass.pm 또는 t / Math / BigFloat / SubClass.pm 완전히 기능하는 하위 클래스 예제를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="55b11d71facfcee62095e950521946dac7a2b9c8" translate="yes" xml:space="preserve">
          <source>This allows a reference to a variable to be declared with &lt;code&gt;my&lt;/code&gt;, &lt;code&gt;state&lt;/code&gt;, our &lt;code&gt;our&lt;/code&gt;, or localized with &lt;code&gt;local&lt;/code&gt;. It is intended mainly for use in conjunction with the &quot;refaliasing&quot; feature. See &lt;a href=&quot;perlref#Declaring-a-Reference-to-a-Variable&quot;&gt;&quot;Declaring a Reference to a Variable&quot; in perlref&lt;/a&gt; for examples.</source>
          <target state="translated">이 변수에 대한 참조로 선언 할 수 있습니다 &lt;code&gt;my&lt;/code&gt; , &lt;code&gt;state&lt;/code&gt; 우리의, &lt;code&gt;our&lt;/code&gt; , 또는으로 지역화 된 &lt;code&gt;local&lt;/code&gt; . 주로 &quot;재 앨리어싱&quot;기능과 함께 사용하기위한 것입니다. 예제 &lt;a href=&quot;perlref#Declaring-a-Reference-to-a-Variable&quot;&gt;는 perlref의 &quot;변수에 대한 참조 선언&quot;을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="1d5501a126d7bcccb962537b6328418e9a9cd85d" translate="yes" xml:space="preserve">
          <source>This allows a user to setup a directory tree for some software with directories &lt;code&gt;&amp;lt;root&amp;gt;/bin&lt;/code&gt; and &lt;code&gt;&amp;lt;root&amp;gt;/lib&lt;/code&gt; , and then the above example will allow the use of modules in the lib directory without knowing where the software tree is installed.</source>
          <target state="translated">이를 통해 사용자는 &lt;code&gt;&amp;lt;root&amp;gt;/bin&lt;/code&gt; 및 &lt;code&gt;&amp;lt;root&amp;gt;/lib&lt;/code&gt; 디렉토리를 사용하여 일부 소프트웨어의 디렉토리 트리를 설정할 수 있으며 , 위의 예에서는 소프트웨어 트리의 설치 위치를 모르고 lib 디렉토리에서 모듈을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="27816f401d954ec072345f1b707e0f267b956d02" translate="yes" xml:space="preserve">
          <source>This allows a user to setup a directory tree for some software with directories &lt;code&gt;&amp;lt;root&amp;gt;/bin&lt;/code&gt; and &lt;code&gt;&amp;lt;root&amp;gt;/lib&lt;/code&gt;, and then the above example will allow the use of modules in the lib directory without knowing where the software tree is installed.</source>
          <target state="translated">이를 통해 사용자는 &lt;code&gt;&amp;lt;root&amp;gt;/bin&lt;/code&gt; 및 &lt;code&gt;&amp;lt;root&amp;gt;/lib&lt;/code&gt; 디렉토리가있는 일부 소프트웨어에 대한 디렉토리 트리를 설정할 수 있으며 , 위의 예에서는 소프트웨어 트리가 설치된 위치를 알지 못해도 lib 디렉토리의 모듈을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f2d1ac05408a326c089b0ec60746ba54464b2076" translate="yes" xml:space="preserve">
          <source>This allows for a more traditional use of sockatmark() as a procedural socket function. If your system does not support sockatmark(), the &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; declaration will fail at compile time.</source>
          <target state="translated">이렇게하면 절차 소켓 함수로 sockatmark ()를보다 전통적인 방식으로 사용할 수 있습니다. 시스템이 sockatmark ()를 지원하지 않으면 컴파일시 &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 선언이 실패합니다.</target>
        </trans-unit>
        <trans-unit id="5c4bf55b527390af875f220a6a455b96b2cc2be5" translate="yes" xml:space="preserve">
          <source>This allows one to specify the</source>
          <target state="translated">이것은 하나를 지정할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="dd0d07d0d3a6167b29dae996bfd8a33bb4d04031" translate="yes" xml:space="preserve">
          <source>This allows the ability to provide an extra pointer (called the &quot;host&quot; environment) for all the system calls. This makes it possible for all the system stuff to maintain their own state, broken down into seven C structures. These are thin wrappers around the usual system calls (see</source>
          <target state="translated">이를 통해 모든 시스템 호출에 대해 추가 포인터 ( &quot;호스트&quot;환경이라고 함)를 제공 할 수 있습니다. 이를 통해 모든 시스템 요소가 7 개의 C 구조로 분류 된 자체 상태를 유지할 수 있습니다. 이것들은 일반적인 시스템 호출을 둘러싼 얇은 래퍼입니다 (참조</target>
        </trans-unit>
        <trans-unit id="f2d9de12c87f7e2eb33ce435c5af882982d468fe" translate="yes" xml:space="preserve">
          <source>This allows the engine to dupe its private data but also if necessary modify the final structure if it really must.</source>
          <target state="translated">이를 통해 엔진은 개인 데이터를 제거 할 수 있지만 필요한 경우 최종 구조를 수정해야합니다.</target>
        </trans-unit>
        <trans-unit id="afb3f86b59b2eab9a83b014b190ee8244b9d77c6" translate="yes" xml:space="preserve">
          <source>This allows the programmer to look at the execution stack and variables to find out the cause of the exception. As the debugger is being invoked as the Perl interpreter is about to do a fatal exit, continuing the execution in debug mode is usually not practical.</source>
          <target state="translated">이를 통해 프로그래머는 예외의 원인을 찾기 위해 실행 스택과 변수를 볼 수 있습니다. Perl 인터프리터가 치명적인 종료를 수행하려고 할 때 디버거가 호출되므로 디버그 모드에서 실행을 계속하는 것은 일반적으로 실용적이지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0db2b07707171b33eaecb29767724fb7ef4d27b3" translate="yes" xml:space="preserve">
          <source>This allows the use of the &lt;code&gt;isa&lt;/code&gt; infix operator, which tests whether the scalar given by the left operand is an object of the class given by the right operand. See &lt;a href=&quot;perlop#Class-Instance-Operator&quot;&gt;&quot;Class Instance Operator&quot; in perlop&lt;/a&gt; for more details.</source>
          <target state="translated">이렇게하면 &lt;code&gt;isa&lt;/code&gt; 중위 연산자를 사용할 수 있습니다.이 연산자는 왼쪽 피연산자가 제공하는 스칼라가 오른쪽 피연산자가 제공하는 클래스의 객체인지 여부를 테스트합니다. 자세한 내용 &lt;a href=&quot;perlop#Class-Instance-Operator&quot;&gt;은 perlop의 &quot;클래스 인스턴스 연산자&quot;&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="1baefaa51fc7ed599ce445dad500d37cb72bf43c" translate="yes" xml:space="preserve">
          <source>This allows you to add a prefix to the backup file, instead of (or in addition to) a suffix:</source>
          <target state="translated">이를 통해 접미사 대신에 접미사를 백업 파일에 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="08c156e263d5342084a6b014f45a9a0f0a51e994" translate="yes" xml:space="preserve">
          <source>This allows you to add callbacks that will trigger every time a context for this hub is released. The only argument to the sub will be the &lt;a href=&quot;Test2::API::Context&quot;&gt;Test2::API::Context&lt;/a&gt; instance that was released. These will run in reverse order.</source>
          <target state="translated">이를 통해이 허브에 대한 컨텍스트가 해제 될 때마다 트리거되는 콜백을 추가 할 수 있습니다. 서브에 대한 유일한 인수 는 릴리스 된 &lt;a href=&quot;Test2::API::Context&quot;&gt;Test2 :: API :: Context&lt;/a&gt; 인스턴스입니다. 이는 역순으로 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="c13b99696d30cbc25087da7c60f284a4111dd701" translate="yes" xml:space="preserve">
          <source>This allows you to add callbacks that will trigger every time a new context is created for the hub. The only argument to the sub will be the &lt;a href=&quot;Test2::API::Context&quot;&gt;Test2::API::Context&lt;/a&gt; instance that was created.</source>
          <target state="translated">이를 통해 허브에 대한 새 컨텍스트가 생성 될 때마다 트리거되는 콜백을 추가 할 수 있습니다. 하위에 대한 유일한 인수는 &lt;a href=&quot;Test2::API::Context&quot;&gt;생성 된 Test2 :: API :: Context&lt;/a&gt; 인스턴스입니다.</target>
        </trans-unit>
        <trans-unit id="8c9c79134ff2ae5aa3b781af2dbc70121d4e03bb" translate="yes" xml:space="preserve">
          <source>This allows you to check that your test module is setting the correct value for $Test::Builder::Level and thus giving the correct file and line number when a test fails. It is calculated by looking at caller() and $Test::Builder::Level. It should count how many subroutines there are before jumping into the function you are testing. So for example in</source>
          <target state="translated">이를 통해 테스트 모듈이 $ Test :: Builder :: Level에 올바른 값을 설정하고 있는지 확인하여 테스트가 실패 할 때 올바른 파일과 줄 번호를 제공하는지 확인할 수 있습니다. caller () 및 $ Test :: Builder :: Level을보고 계산됩니다. 테스트중인 함수로 이동하기 전에 얼마나 많은 서브 루틴이 있는지 계산해야합니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="3e47154414d862007ad5f643f15fef0b3978ca2c" translate="yes" xml:space="preserve">
          <source>This allows you to intermix your source code and your documentation text freely, as in</source>
          <target state="translated">따라서 소스 코드와 문서 텍스트를 자유롭게 혼합 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="56e637a731a56d0d223f91be743e436a188835e3" translate="yes" xml:space="preserve">
          <source>This allows you to pass a reference to a scalar, in which the data will be stored:</source>
          <target state="translated">이를 통해 데이터가 저장 될 스칼라에 대한 참조를 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="56546e50a57dfe022838ff689d536d5a9d34e4c4" translate="yes" xml:space="preserve">
          <source>This allows you to provide a UUID generator. If provided UUIDs will be attached to all events, hubs, and contexts. This is useful for storing, tracking, and linking these objects.</source>
          <target state="translated">이를 통해 UUID 생성기를 제공 할 수 있습니다. 제공된 경우 UUID는 모든 이벤트, 허브 및 컨텍스트에 첨부됩니다. 이는 이러한 개체를 저장, 추적 및 연결하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="ae11cd12869687833116af8fabb9e16d79564d09" translate="yes" xml:space="preserve">
          <source>This allows you to specify &lt;code&gt;constants&lt;/code&gt; in your template. ie, they keys that are not allowed to be altered by the user. It pretty much allows you to keep all your &lt;code&gt;configurable&lt;/code&gt; data in one place; the &lt;code&gt;Params::Check&lt;/code&gt; template.</source>
          <target state="translated">이를 통해 템플릿에서 &lt;code&gt;constants&lt;/code&gt; 를 지정할 수 있습니다 . 즉, 사용자가 변경할 수없는 키입니다. &lt;code&gt;configurable&lt;/code&gt; 모든 데이터를 한 곳에 보관할 수 있습니다 . &lt;code&gt;Params::Check&lt;/code&gt; 템플릿입니다.</target>
        </trans-unit>
        <trans-unit id="02527ae1bd59af5a043ac93acd05be3d0f9bb884" translate="yes" xml:space="preserve">
          <source>This allows you to update your local repository by pulling from &lt;code&gt;origin&lt;/code&gt;, which is faster and doesn't require you to authenticate, and to push your changes back with the &lt;code&gt;camel&lt;/code&gt; remote:</source>
          <target state="translated">이를 통해 더 빠르고 인증이 필요하지 않은 &lt;code&gt;origin&lt;/code&gt; 에서 가져와 로컬 저장소를 업데이트 하고 &lt;code&gt;camel&lt;/code&gt; remote로 변경 사항을 다시 푸시 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fb3de596529e48bc02f1d5b4c0a477a1da824e62" translate="yes" xml:space="preserve">
          <source>This allows your code to set hints without relying on &lt;code&gt;autodie&lt;/code&gt; and &lt;code&gt;autodie::hints&lt;/code&gt; being loaded, or even installed. In this way your code can do the right thing when &lt;code&gt;autodie&lt;/code&gt; is installed, but does not need to depend upon it to function.</source>
          <target state="translated">이렇게하면 &lt;code&gt;autodie&lt;/code&gt; 및 &lt;code&gt;autodie::hints&lt;/code&gt; 드되거나 설치 되지 않고도 코드에서 힌트를 설정할 수 있습니다 . 이런 식으로 코드는 &lt;code&gt;autodie&lt;/code&gt; 가 설치 되었을 때 올바른 일을 할 수 있지만 작동하기 위해 의존 할 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="ec9cd2ea84115168b54e6b0797c0f572af954da0" translate="yes" xml:space="preserve">
          <source>This almost definitely doesn't do what you expect:</source>
          <target state="translated">이것은 거의 당신이 기대하는 것을하지 않습니다 :</target>
        </trans-unit>
        <trans-unit id="5ba2015dbd8b7d90bb6da319e60421ccbe89f224" translate="yes" xml:space="preserve">
          <source>This also applies to integers that look like floating point constants:</source>
          <target state="translated">부동 소수점 상수처럼 보이는 정수에도 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="636185aa1476a4214e4b7454bccd1f721aa5d7e5" translate="yes" xml:space="preserve">
          <source>This also behaves similarly, but assigns to a lexical variable instead of to &lt;code&gt;$_&lt;/code&gt; :</source>
          <target state="translated">이것도 비슷하게 동작하지만 &lt;code&gt;$_&lt;/code&gt; 대신 어휘 변수에 할당합니다 :</target>
        </trans-unit>
        <trans-unit id="40e97092dc934ec326d1ea3e202dbbdcd5300d45" translate="yes" xml:space="preserve">
          <source>This also behaves similarly, but assigns to a lexical variable instead of to &lt;code&gt;$_&lt;/code&gt;:</source>
          <target state="translated">이것도 비슷하게 작동하지만 &lt;code&gt;$_&lt;/code&gt; 대신 어휘 변수에 할당됩니다 .</target>
        </trans-unit>
        <trans-unit id="cd00f9f641aead2aa10c5260267b8df1c16f1dcf" translate="yes" xml:space="preserve">
          <source>This also has a special use with XS AUTOLOAD subs. See &lt;a href=&quot;perlguts#Autoloading-with-XSUBs&quot;&gt;&quot;Autoloading with XSUBs&quot; in perlguts&lt;/a&gt;.</source>
          <target state="translated">이것은 또한 XS AUTOLOAD 서브와 함께 특별한 용도로 사용됩니다. &lt;a href=&quot;perlguts#Autoloading-with-XSUBs&quot;&gt;perlguts의 &quot;XSUB로 자동로드&quot;를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="77df2183cb5ed8fa6c016243494c2444f23d3c09" translate="yes" xml:space="preserve">
          <source>This also has a special use with XS AUTOLOAD subs. See &lt;a href=&quot;perlguts#Autoloading-with-XSUBs&quot;&gt;Autoloading with XSUBs in perlguts&lt;/a&gt;.</source>
          <target state="translated">또한 XS AUTOLOAD 하위 시스템과 함께 특수하게 사용됩니다. &lt;a href=&quot;perlguts#Autoloading-with-XSUBs&quot;&gt;perlguts에서 XSUB로 자동로드를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d3d548e6c0ea6757b5bd736b5e0dc177ac6e6019" translate="yes" xml:space="preserve">
          <source>This also has implications for the use of the SUPER:: qualifier (see &lt;a href=&quot;perlobj&quot;&gt;perlobj&lt;/a&gt;).</source>
          <target state="translated">이것은 또한 SUPER :: 한정자를 사용하는 것과 관련이 있습니다 ( &lt;a href=&quot;perlobj&quot;&gt;perlobj&lt;/a&gt; 참조). ).</target>
        </trans-unit>
        <trans-unit id="f8da07f35c437fa97e844be13f7f26224b7e80d0" translate="yes" xml:space="preserve">
          <source>This also means it is a bad idea to check for some specific package, since the actual contents of $x might be something unexpected. Due to the transparent way of bignum &lt;code&gt;&lt;a href=&quot;functions/ref&quot;&gt;ref()&lt;/a&gt;&lt;/code&gt; should not be necessary, anyway.</source>
          <target state="translated">이것은 또한 $ x의 실제 내용이 예상치 못한 것일 수 있기 때문에 특정 패키지를 확인하는 것은 나쁜 생각임을 의미합니다. bignum의 투명한 방식으로 인해 &lt;code&gt;&lt;a href=&quot;functions/ref&quot;&gt;ref()&lt;/a&gt;&lt;/code&gt; 는 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="49deec483222c26dba8014be17034c32d563f691" translate="yes" xml:space="preserve">
          <source>This also means it is a bad idea to check for some specific package, since the actual contents of $x might be something unexpected. Due to the transparent way of bignum &lt;code&gt;ref()&lt;/code&gt; should not be necessary, anyway.</source>
          <target state="translated">이것은 또한 $ x의 실제 내용이 예상치 못한 것일 수 있기 때문에 특정 패키지를 확인하는 것은 좋지 않다는 것을 의미합니다. 어쨌든 bignum &lt;code&gt;ref()&lt;/code&gt; 의 투명한 방법으로 인해 필요하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="9f046ba2ed5c45f32bb7d779ddd434216adcb9e9" translate="yes" xml:space="preserve">
          <source>This also means that a first argument hash reference now becomes the second argument:</source>
          <target state="translated">이것은 또한 첫 번째 인수 해시 참조가 이제 두 번째 인수가됨을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="53e0f20ff4a10e2905e391319be8b9814ea5ca78" translate="yes" xml:space="preserve">
          <source>This also returns the file format version. If the version is &quot;2.7&quot; then major would be 2 and minor would be 7. The minor element is missing for when major is less than 2.</source>
          <target state="translated">파일 형식 버전도 반환합니다. 버전이 &quot;2.7&quot;이면 major는 2이고 minor는 7입니다. major가 2보다 작 으면 minor 요소가 누락됩니다.</target>
        </trans-unit>
        <trans-unit id="61c52be3ac150c6eed66b2a1ead6f0d851e682d3" translate="yes" xml:space="preserve">
          <source>This also works for other subclasses, like Math::String.</source>
          <target state="translated">Math :: String과 같은 다른 하위 클래스에서도 작동합니다.</target>
        </trans-unit>
        <trans-unit id="8203581310d6a334ec8562f54f521a19e2fc01d8" translate="yes" xml:space="preserve">
          <source>This also works for ranges in &lt;code&gt;tr///&lt;/code&gt; starting in Perl v5.24.</source>
          <target state="translated">이것은 Perl v5.24부터 &lt;code&gt;tr///&lt;/code&gt; 범위에서도 작동합니다 .</target>
        </trans-unit>
        <trans-unit id="8468a87cfa0204ff52a567b1eaf4b66d1ee547eb" translate="yes" xml:space="preserve">
          <source>This always means your main memory, not your disk. Clouding the issue is the fact that your machine may implement &lt;b&gt;virtual&lt;/b&gt; memory; that is, it will pretend that it has more memory than it really does, and it&amp;rsquo;ll use disk space to hold inactive bits. This can make it seem like you have a little more memory than you really do, but it&amp;rsquo;s not a substitute for real memory. The best thing that can be said about virtual memory is that it lets your performance degrade gradually rather than suddenly when you run out of real memory. But your program can die when you run out of virtual memory, too&amp;mdash;if you haven&amp;rsquo;t thrashed your disk to death first.</source>
          <target state="translated">이것은 항상 디스크가 아닌 기본 메모리를 의미합니다. 문제를 흐리게하면 시스템이 &lt;b&gt;가상&lt;/b&gt; 메모리를 구현할 수 있다는 사실입니다 . 즉, 실제보다 많은 메모리가있는 것으로 가장하고 디스크 공간을 사용하여 비활성 비트를 보유합니다. 이렇게하면 실제 메모리보다 약간 더 많은 메모리가있는 것처럼 보일 수 있지만 실제 메모리를 대신 할 수는 없습니다. 가상 메모리에 대해 말할 수있는 가장 좋은 점은 실제 메모리가 부족할 때 갑자기 성능이 떨어지지 않고 점차적으로 성능이 저하된다는 것입니다. 그러나 가상 메모리가 부족할 때 디스크를 먼저 쓰러 뜨리지 않으면 프로그램이 죽을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="295dde8c4391c2b969f714a71c16980aac7c0b67" translate="yes" xml:space="preserve">
          <source>This and &lt;code&gt;PERL_INT_MIN&lt;/code&gt;, &lt;code&gt;PERL_LONG_MAX&lt;/code&gt;, &lt;code&gt;PERL_LONG_MIN&lt;/code&gt;, &lt;code&gt;PERL_QUAD_MAX&lt;/code&gt;, &lt;code&gt;PERL_SHORT_MAX&lt;/code&gt;, &lt;code&gt;PERL_SHORT_MIN&lt;/code&gt;, &lt;code&gt;PERL_UCHAR_MAX&lt;/code&gt;, &lt;code&gt;PERL_UCHAR_MIN&lt;/code&gt;, &lt;code&gt;PERL_UINT_MAX&lt;/code&gt;, &lt;code&gt;PERL_ULONG_MAX&lt;/code&gt;, &lt;code&gt;PERL_ULONG_MIN&lt;/code&gt;, &lt;code&gt;PERL_UQUAD_MAX&lt;/code&gt;, &lt;code&gt;PERL_UQUAD_MIN&lt;/code&gt;, &lt;code&gt;PERL_USHORT_MAX&lt;/code&gt;, &lt;code&gt;PERL_USHORT_MIN&lt;/code&gt;, &lt;code&gt;PERL_QUAD_MIN&lt;/code&gt; give the largest and smallest number representable in the current platform in variables of the corresponding types.</source>
          <target state="translated">이것과는 &lt;code&gt;PERL_INT_MIN&lt;/code&gt; , &lt;code&gt;PERL_LONG_MAX&lt;/code&gt; , &lt;code&gt;PERL_LONG_MIN&lt;/code&gt; , &lt;code&gt;PERL_QUAD_MAX&lt;/code&gt; , &lt;code&gt;PERL_SHORT_MAX&lt;/code&gt; , &lt;code&gt;PERL_SHORT_MIN&lt;/code&gt; , &lt;code&gt;PERL_UCHAR_MAX&lt;/code&gt; , &lt;code&gt;PERL_UCHAR_MIN&lt;/code&gt; , &lt;code&gt;PERL_UINT_MAX&lt;/code&gt; , &lt;code&gt;PERL_ULONG_MAX&lt;/code&gt; , &lt;code&gt;PERL_ULONG_MIN&lt;/code&gt; , &lt;code&gt;PERL_UQUAD_MAX&lt;/code&gt; , &lt;code&gt;PERL_UQUAD_MIN&lt;/code&gt; 는 , &lt;code&gt;PERL_USHORT_MAX&lt;/code&gt; 는 , &lt;code&gt;PERL_USHORT_MIN&lt;/code&gt; 는 , &lt;code&gt;PERL_QUAD_MIN&lt;/code&gt; 는 해당 유형의 변수의 현재 플랫폼 최대 및 최소 개수 표현할 줄 .</target>
        </trans-unit>
        <trans-unit id="165f78228b9bb880f61927fda978ad6714cce456" translate="yes" xml:space="preserve">
          <source>This anomaly stems from Perl's attempt to not disturb older programs that didn't use Unicode, along with Perl's desire to add Unicode support seamlessly. But the result turned out to not be seamless. (By the way, you can choose to be warned when things like this happen. See &lt;code&gt;&lt;a href=&quot;encoding/warnings&quot;&gt;encoding::warnings&lt;/a&gt;&lt;/code&gt;.)</source>
          <target state="translated">이 예외는 Perl의 유니 코드 지원을 완벽하게 추가하려는 Perl의 요구와 함께, 유니 코드를 사용하지 않은 오래된 프로그램을 방해하지 않으려는 시도에서 비롯됩니다. 그러나 결과는 완벽하지 않은 것으로 판명되었습니다. (이러한 상황이 발생하면 경고를 받도록 선택할 수 있습니다. &lt;code&gt;&lt;a href=&quot;encoding/warnings&quot;&gt;encoding::warnings&lt;/a&gt;&lt;/code&gt; 참조 )</target>
        </trans-unit>
        <trans-unit id="a34b4613636352dc25268cf3fddbf1e4e87cbb09" translate="yes" xml:space="preserve">
          <source>This anomaly stems from Perl's attempt to not disturb older programs that didn't use Unicode, along with Perl's desire to add Unicode support seamlessly. But the result turned out to not be seamless. (By the way, you can choose to be warned when things like this happen. See &lt;code&gt;&lt;a href=&quot;encoding::warnings&quot;&gt;encoding::warnings&lt;/a&gt;&lt;/code&gt;.)</source>
          <target state="translated">이 이상 현상은 유니 코드 지원을 원활하게 추가하려는 Perl의 열망과 함께 유니 코드를 사용하지 않는 이전 프로그램을 방해하지 않으려는 Perl의 시도에서 비롯됩니다. 그러나 결과는 매끄럽지 않은 것으로 판명되었습니다. (참고로 이와 같은 일이 발생하면 경고를 받도록 선택할 수 있습니다. &lt;code&gt;&lt;a href=&quot;encoding::warnings&quot;&gt;encoding::warnings&lt;/a&gt;&lt;/code&gt; 참조하세요 .)</target>
        </trans-unit>
        <trans-unit id="8c246570729105a65f6bd289985b0b62d1e1f94f" translate="yes" xml:space="preserve">
          <source>This appeared in perl 5.10.0. Anything matched left of &lt;code&gt;\K&lt;/code&gt; is not included in &lt;code&gt;$&amp;amp;&lt;/code&gt; , and will not be replaced if the pattern is used in a substitution. This lets you write &lt;code&gt;s/PAT1 \K PAT2/REPL/x&lt;/code&gt; instead of &lt;code&gt;s/(PAT1) PAT2/${1}REPL/x&lt;/code&gt; or &lt;code&gt;s/(?&amp;lt;=PAT1) PAT2/REPL/x&lt;/code&gt; .</source>
          <target state="translated">이것은 perl 5.10.0에 나타났습니다. &lt;code&gt;\K&lt;/code&gt; 왼쪽에 일치하는 것은 &lt;code&gt;$&amp;amp;&lt;/code&gt; 포함 되지 않으며 패턴이 대체에 사용되는 경우 대체되지 않습니다. 이를 통해 &lt;code&gt;s/(PAT1) PAT2/${1}REPL/x&lt;/code&gt; 또는 &lt;code&gt;s/(?&amp;lt;=PAT1) PAT2/REPL/x&lt;/code&gt; 대신 &lt;code&gt;s/PAT1 \K PAT2/REPL/x&lt;/code&gt; 를 쓸 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="bbd3493b1232a9c4de7dc8bb2c9b05a2159dd5ec" translate="yes" xml:space="preserve">
          <source>This appeared in perl 5.10.0. Anything matched left of &lt;code&gt;\K&lt;/code&gt; is not included in &lt;code&gt;$&amp;amp;&lt;/code&gt;, and will not be replaced if the pattern is used in a substitution. This lets you write &lt;code&gt;s/PAT1 \K PAT2/REPL/x&lt;/code&gt; instead of &lt;code&gt;s/(PAT1) PAT2/${1}REPL/x&lt;/code&gt; or &lt;code&gt;s/(?&amp;lt;=PAT1) PAT2/REPL/x&lt;/code&gt;.</source>
          <target state="translated">이것은 perl 5.10.0에서 나타났습니다. &lt;code&gt;\K&lt;/code&gt; 왼쪽과 일치하는 것은 &lt;code&gt;$&amp;amp;&lt;/code&gt; 포함 되지 않으며 패턴이 대체에 사용되는 경우 대체되지 않습니다. 이렇게하면 &lt;code&gt;s/(PAT1) PAT2/${1}REPL/x&lt;/code&gt; 또는 &lt;code&gt;s/(?&amp;lt;=PAT1) PAT2/REPL/x&lt;/code&gt; 대신 &lt;code&gt;s/PAT1 \K PAT2/REPL/x&lt;/code&gt; 를 쓸 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7cbb4716327acfc3309af9888218e1b2879b1c27" translate="yes" xml:space="preserve">
          <source>This applies as well to &lt;a href=&quot;I18N::Langinfo&quot;&gt;I18N::Langinfo&lt;/a&gt;.</source>
          <target state="translated">이것은 &lt;a href=&quot;I18N::Langinfo&quot;&gt;I18N :: Langinfo&lt;/a&gt; 에도 적용됩니다 .</target>
        </trans-unit>
        <trans-unit id="a9e79001ab117c0cf333336e9232ddbb9a00de3d" translate="yes" xml:space="preserve">
          <source>This applies equally to method names, parameter names, and anything else which is visible to the user (and most things that aren't!)</source>
          <target state="translated">이것은 메서드 이름, 매개 변수 이름 및 사용자에게 표시되는 모든 항목 (및 보이지 않는 대부분의 항목)에 동일하게 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="70dd8476567c22ea231857d01ff4db7f81b73be8" translate="yes" xml:space="preserve">
          <source>This applies only to lexical variables, by the way. Dynamic variables continue to work as they have always worked. Closure is not something that most Perl programmers need trouble themselves about to begin with.</source>
          <target state="translated">이것은 어휘 변수에만 적용됩니다. 동적 변수는 항상 작동 한대로 계속 작동합니다. 클로저는 대부분의 Perl 프로그래머가 처음부터 어려움을 겪어야하는 것이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="4e13602141364999d0474f62de688119ccaf7274" translate="yes" xml:space="preserve">
          <source>This applies to the perlio system only. For versions before 5.7, &lt;code&gt;PerlIO_exportFILE()&lt;/code&gt; is equivalent to &lt;code&gt;PerlIO_findFILE()&lt;/code&gt; .</source>
          <target state="translated">이것은 perlio 시스템에만 적용됩니다. 5.7 이전 버전의 경우, &lt;code&gt;PerlIO_exportFILE()&lt;/code&gt; 에 해당 &lt;code&gt;PerlIO_findFILE()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e11371aac7dd3f528873ed555dfe591da9dcfa07" translate="yes" xml:space="preserve">
          <source>This applies to the perlio system only. For versions before 5.7, &lt;code&gt;PerlIO_exportFILE()&lt;/code&gt; is equivalent to &lt;code&gt;PerlIO_findFILE()&lt;/code&gt;.</source>
          <target state="translated">이것은 Perlio 시스템에만 적용됩니다. 5.7 이전 버전의 경우, &lt;code&gt;PerlIO_exportFILE()&lt;/code&gt; 에 해당 &lt;code&gt;PerlIO_findFILE()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="88ab6b9c73082204ae0542a65f9bf2f5c23ef207" translate="yes" xml:space="preserve">
          <source>This approach also works for comparing hashes. Here we'll demonstrate two different answers:</source>
          <target state="translated">이 방법은 해시를 비교할 때도 효과적입니다. 다음은 두 가지 다른 답변을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="e5cff3b77039edbd80551481c46e471aeea07633" translate="yes" xml:space="preserve">
          <source>This approach is useful if I need to convert my TAP based test results into some other representation. See TAP::Convert::TET (http://search.cpan.org/dist/TAP-Convert-TET/) for an example of this approach.</source>
          <target state="translated">이 접근 방식은 TAP 기반 테스트 결과를 다른 표현으로 변환해야하는 경우 유용합니다. 이 접근 방식의 예는 TAP :: Convert :: TET (http://search.cpan.org/dist/TAP-Convert-TET/)를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="684f52e2ad132a8d50a850505a18c8cf67adca2e" translate="yes" xml:space="preserve">
          <source>This approach makes it comparatively easy to write code preprocessors without worrying about the form or contents of strings, regexes, etc.</source>
          <target state="translated">이 방법을 사용하면 문자열, 정규식 등의 형식이나 내용에 대해 걱정하지 않고 코드 전처리기를 비교적 쉽게 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="21941c4a2190129983b70fab8729b6e9162dfa7f" translate="yes" xml:space="preserve">
          <source>This approach of treating &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; like object methods calls doesn't work for the diamond operator. That's because it's a real operator, not just a function with a comma-less argument. Assuming you've been storing typeglobs in your structure as we did above, you can use the built-in function named &lt;code&gt;&lt;a href=&quot;functions/readline&quot;&gt;readline&lt;/a&gt;&lt;/code&gt; to read a record just as &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; does. Given the initialization shown above for @fd, this would work, but only because readline() requires a typeglob. It doesn't work with objects or strings, which might be a bug we haven't fixed yet.</source>
          <target state="translated">객체 연산자 호출과 같은 &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; 처리 방식은 다이아몬드 연산자에는 적용되지 않습니다. 쉼표가없는 인수 만있는 함수가 아니라 실제 연산자이기 때문입니다. 위에서와 같이 구조에 typeglob를 저장했다고 가정하면 &lt;code&gt;&lt;a href=&quot;functions/readline&quot;&gt;readline&lt;/a&gt;&lt;/code&gt; 이라는 내장 함수를 사용하여 &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; 처럼 레코드를 읽을 수 있습니다. 위의 @fd에 대한 초기화가 주어지면 readline ()에 typeglob가 필요하기 때문에 작동합니다. 객체 또는 문자열에는 작동하지 않습니다. 아직 수정하지 않은 버그 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8f83a93621698a2bcf6c863d26ca6660360038ba" translate="yes" xml:space="preserve">
          <source>This approach of treating &lt;code&gt;print&lt;/code&gt; and &lt;code&gt;printf&lt;/code&gt; like object methods calls doesn't work for the diamond operator. That's because it's a real operator, not just a function with a comma-less argument. Assuming you've been storing typeglobs in your structure as we did above, you can use the built-in function named &lt;code&gt;readline&lt;/code&gt; to read a record just as &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; does. Given the initialization shown above for @fd, this would work, but only because readline() requires a typeglob. It doesn't work with objects or strings, which might be a bug we haven't fixed yet.</source>
          <target state="translated">&lt;code&gt;print&lt;/code&gt; 및 &lt;code&gt;printf&lt;/code&gt; 를 개체 메서드 호출과 같이 처리하는 이러한 접근 방식은 다이아몬드 연산자에 대해 작동하지 않습니다. 쉼표없는 인수가있는 함수가 아니라 실제 연산자이기 때문입니다. 위에서했던 것처럼 구조체에 typeglobs를 저장했다고 가정하면 &lt;code&gt;readline&lt;/code&gt; 이라는 내장 함수를 사용하여 &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; 처럼 레코드를 읽을 수 있습니다. @fd에 대해 위에 표시된 초기화가 주어지면 이것은 작동하지만 readline ()에 typeglob이 필요하기 때문입니다. 아직 수정하지 않은 버그 일 수있는 객체 나 문자열에서는 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5d9254d4c73a18d06483f51c6d39891d7febc4dc" translate="yes" xml:space="preserve">
          <source>This approach will preserve links in the installation without creating duplicate binaries.</source>
          <target state="translated">이 접근 방식은 중복 바이너리를 생성하지 않고 설치의 링크를 보존합니다. ㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ</target>
        </trans-unit>
        <trans-unit id="8edd7ed16ccf46b65b081f4b967d5eb2691395f1" translate="yes" xml:space="preserve">
          <source>This argument is &lt;b&gt;required&lt;/b&gt;. All other arguments are optional.</source>
          <target state="translated">이 인수는 &lt;b&gt;필수&lt;/b&gt; 입니다. 다른 모든 인수는 선택 사항입니다.</target>
        </trans-unit>
        <trans-unit id="f95f50481ff3516b07bb9d7865830ab6c1ff5648" translate="yes" xml:space="preserve">
          <source>This array holds the offsets of the beginnings of the last successful submatches in the currently active dynamic scope. &lt;code&gt;$-[0]&lt;/code&gt; is the offset into the string of the beginning of the entire match. The</source>
          <target state="translated">이 배열은 현재 활성화 된 동적 범위에서 마지막으로 성공한 부분 일치의 시작 오프셋을 유지합니다. &lt;code&gt;$-[0]&lt;/code&gt; 은 전체 일치의 시작 부분에 대한 오프셋입니다. 그만큼</target>
        </trans-unit>
        <trans-unit id="e96381bdcc284e80585b7b54b1e289040c1f9efb" translate="yes" xml:space="preserve">
          <source>This array holds the offsets of the ends of the last successful submatches in the currently active dynamic scope. &lt;code&gt;$+[0]&lt;/code&gt; is the offset into the string of the end of the entire match. This is the same value as what the &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos&lt;/a&gt;&lt;/code&gt; function returns when called on the variable that was matched against. The</source>
          <target state="translated">이 배열은 현재 활성화 된 동적 범위에서 마지막으로 성공한 부분 일치의 끝 오프셋을 유지합니다. &lt;code&gt;$+[0]&lt;/code&gt; 은 전체 일치의 끝 문자열에 대한 오프셋입니다. 이는 일치하는 변수에서 호출 될 때 &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos&lt;/a&gt;&lt;/code&gt; 함수가 리턴 하는 것과 동일한 값 입니다. 그만큼</target>
        </trans-unit>
        <trans-unit id="7e3b87670db2d70a8b725b5f6afad0e3488c0499" translate="yes" xml:space="preserve">
          <source>This array holds the offsets of the ends of the last successful submatches in the currently active dynamic scope. &lt;code&gt;$+[0]&lt;/code&gt; is the offset into the string of the end of the entire match. This is the same value as what the &lt;code&gt;pos&lt;/code&gt; function returns when called on the variable that was matched against. The</source>
          <target state="translated">이 배열은 현재 활성 동적 범위에서 마지막으로 성공한 부분 일치 끝의 오프셋을 보유합니다. &lt;code&gt;$+[0]&lt;/code&gt; 은 전체 일치의 끝 문자열에 대한 오프셋입니다. 이것은 일치 된 변수에 대해 호출 될 때 &lt;code&gt;pos&lt;/code&gt; 함수가 반환 하는 것과 동일한 값 입니다. 그만큼</target>
        </trans-unit>
        <trans-unit id="de9df0444460b118bc16cc7a6647d43831c503da" translate="yes" xml:space="preserve">
          <source>This array of function pointers is a convenient place to hook into the compilation process. An XS module can put its own custom check function in place of any of the standard ones, to influence the compilation of a particular type of op. However, a custom check function must never fully replace a standard check function (or even a custom check function from another module). A module modifying checking must instead &lt;b&gt;wrap&lt;/b&gt; the preexisting check function. A custom check function must be selective about when to apply its custom behaviour. In the usual case where it decides not to do anything special with an op, it must chain the preexisting op function. Check functions are thus linked in a chain, with the core's base checker at the end.</source>
          <target state="translated">이 함수 포인터 배열은 컴파일 프로세스에 연결하기 편리한 위치입니다. XS 모듈은 표준 유형 대신 고유 한 사용자 정의 검사 기능을 배치하여 특정 유형의 op 컴파일에 영향을 줄 수 있습니다. 그러나 사용자 정의 검사 기능은 표준 검사 기능 (또는 다른 모듈의 사용자 정의 검사 기능)을 완전히 대체해서는 안됩니다. 모듈 수정 검사는 기존 검사 기능을 대신 &lt;b&gt;래핑&lt;/b&gt; 해야합니다 . 사용자 정의 검사 기능은 사용자 정의 동작을 적용 할시기에 대해 선택적이어야합니다. op와 관련하여 특별한 작업을 수행하지 않기로 결정한 일반적인 경우에는 기존 op 기능을 연결해야합니다. 따라서 체크 기능은 체인의 기본베이스 체커와 끝에 연결됩니다.</target>
        </trans-unit>
        <trans-unit id="b8dc273368b99545f08bf93846a0eeb46f2d8f07" translate="yes" xml:space="preserve">
          <source>This article is about a little-known feature of Perl called</source>
          <target state="translated">이 기사는 Perl의 작은 알려진 기능에 관한 것입니다.</target>
        </trans-unit>
        <trans-unit id="31e9f3bedf523d7ebb982ebf37f1569db684a386" translate="yes" xml:space="preserve">
          <source>This article originally appeared in</source>
          <target state="translated">이 기사는 원래</target>
        </trans-unit>
        <trans-unit id="290ae5b40be8703f5e688eadedc6451a7fcb95b4" translate="yes" xml:space="preserve">
          <source>This article originally appeared in The Perl Journal #11, and is copyright 1998 The Perl Journal. It appears courtesy of Jon Orwant and The Perl Journal. This document may be distributed under the same terms as Perl itself.</source>
          <target state="translated">이 기사는 원래 Perl Journal # 11에 실 렸으며 1998 년 저작권 Perl Journal에 저작권이 있습니다. Jon Orwant와 The Perl Journal이 제공 한 것으로 보입니다. 이 문서는 Perl 자체와 동일한 용어로 배포 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8c193374e77ca7493defa36cbb4f120e07e0e033" translate="yes" xml:space="preserve">
          <source>This article points out cases where gettext (a common system for localizing software interfaces -- i.e., making them work in the user's language of choice) fails because of basic differences between human languages. This article then describes Maketext, a new system capable of correctly treating these differences.</source>
          <target state="translated">이 기사에서는 인간 언어 간의 기본적인 차이로 인해 gettext (소프트웨어 인터페이스 지역화를위한 공통 시스템, 즉 사용자가 선택한 언어로 작동하도록 만드는 공통 시스템)가 실패하는 경우를 설명합니다. 이 기사에서는 이러한 차이점을 올바르게 처리 할 수있는 새로운 시스템 인 Maketext에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="f5ced083e00b961f0ed9ea00cb4d87f96f2e0533" translate="yes" xml:space="preserve">
          <source>This assertion may be used as the condition in a</source>
          <target state="translated">이 주장은 다음 조건에서 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0000b51c42222ffe097e200394d62769ca419cbc" translate="yes" xml:space="preserve">
          <source>This assumes that we saw the locale &quot;en_US.ISO8859-1&quot; using the commands discussed above. We decided to try that instead of the above faulty locale &quot;En_US&quot;--and in Cshish shells (&lt;b&gt;csh&lt;/b&gt;, &lt;b&gt;tcsh&lt;/b&gt;)</source>
          <target state="translated">위에서 설명한 명령을 사용하여 로캘 &quot;en_US.ISO8859-1&quot;을 본 것으로 가정합니다. 위의 잘못된 로케일 &quot;En_US&quot;대신 Cshish 쉘 ( &lt;b&gt;csh&lt;/b&gt; , &lt;b&gt;tcsh&lt;/b&gt; ) 에서 시도하기로 결정했습니다.</target>
        </trans-unit>
        <trans-unit id="c0dee2f933f09058dd9bf3765b7f846ec57f52d7" translate="yes" xml:space="preserve">
          <source>This attribute is not a search parameter, but is used to report the result of &lt;code&gt;survey&lt;/code&gt; method, as discussed in the next section.</source>
          <target state="translated">이 속성은 검색 매개 변수는 아니지만 다음 섹션에서 설명하는 것처럼 &lt;code&gt;survey&lt;/code&gt; 방법 의 결과를보고하는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="9c687ced37405f8cf67c894463cfe3d86f5b0e65" translate="yes" xml:space="preserve">
          <source>This attribute is used to specify names to be imported into the extension. It is currently only used by OS/2 and Win32.</source>
          <target state="translated">이 속성은 확장으로 가져올 이름을 지정하는 데 사용됩니다. 현재 OS / 2 및 Win32에서만 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="a3e8362900ead72447d5c4ebf2182285972d3847" translate="yes" xml:space="preserve">
          <source>This attribute is used to specify names to be imported into the extension. Takes a hash ref.</source>
          <target state="translated">이 속성은 확장으로 가져올 이름을 지정하는 데 사용됩니다. 해시 참조를받습니다.</target>
        </trans-unit>
        <trans-unit id="1878c97024e58d679f418b8cab0863e53682e594" translate="yes" xml:space="preserve">
          <source>This attribute isn't overridden from &lt;a href=&quot;IO::Handle&quot;&gt;IO::Handle&lt;/a&gt;'s implementation. However, since we turn it on by default, it's worth mentioning here.</source>
          <target state="translated">이 속성은 &lt;a href=&quot;IO::Handle&quot;&gt;IO :: Handle&lt;/a&gt; 의 구현 에서 재정의되지 않습니다 . 그러나 기본적으로 설정되어 있으므로 여기서 언급 할 가치가 있습니다.</target>
        </trans-unit>
        <trans-unit id="767e4d21fb47d7f73037ece0977c12a97d29d46d" translate="yes" xml:space="preserve">
          <source>This attribute may be most useful when specified as a string on the command line: perl Makefile.PL EXCLUDE_EXT='Socket Safe'</source>
          <target state="translated">이 속성은 명령 행에 문자열로 지정 될 때 가장 유용합니다. perl Makefile.PL EXCLUDE_EXT = 'Socket Safe'</target>
        </trans-unit>
        <trans-unit id="79f89eca0caacc11c08af6c151f34570659a105e" translate="yes" xml:space="preserve">
          <source>This attribute may be most useful when specified as a string on the command line: perl Makefile.PL INCLUDE_EXT='POSIX Socket Devel::Peek'</source>
          <target state="translated">이 속성은 명령 행에서 문자열로 지정 될 때 가장 유용 할 수 있습니다. perl Makefile.PL INCLUDE_EXT = 'POSIX Socket Devel :: Peek'</target>
        </trans-unit>
        <trans-unit id="f063de8522828eff3b84027f3f1f4329111a6d6f" translate="yes" xml:space="preserve">
          <source>This attribute means that every time this search sees a matching Pod file, it should call this callback routine. The routine is called with two parameters: the current file's filespec, and its pod name. (For example: &lt;code&gt;(&quot;/etc/perljunk/File/Crunk.pm&quot;, &quot;File::Crunk&quot;)&lt;/code&gt; would be in &lt;code&gt;@_&lt;/code&gt; .)</source>
          <target state="translated">이 속성은이 검색에서 일치하는 포드 파일을 볼 때마다이 콜백 루틴을 호출해야 함을 의미합니다. 루틴은 현재 파일의 파일 스펙과 포드 이름이라는 두 개의 매개 변수로 호출됩니다. (예 : &lt;code&gt;(&quot;/etc/perljunk/File/Crunk.pm&quot;, &quot;File::Crunk&quot;)&lt;/code&gt; 는 &lt;code&gt;@_&lt;/code&gt; 에 있습니다.)</target>
        </trans-unit>
        <trans-unit id="b18ca20df7bd3e30c21736b41cee34c8a2b8e2a6" translate="yes" xml:space="preserve">
          <source>This attribute means that every time this search sees a matching Pod file, it should call this callback routine. The routine is called with two parameters: the current file's filespec, and its pod name. (For example: &lt;code&gt;(&quot;/etc/perljunk/File/Crunk.pm&quot;, &quot;File::Crunk&quot;)&lt;/code&gt; would be in &lt;code&gt;@_&lt;/code&gt;.)</source>
          <target state="translated">이 속성은이 검색에서 일치하는 Pod 파일을 찾을 때마다이 콜백 루틴을 호출해야 함을 의미합니다. 루틴은 현재 파일의 파일 사양과 포드 이름이라는 두 개의 매개 변수를 사용하여 호출됩니다. (예 : &lt;code&gt;(&quot;/etc/perljunk/File/Crunk.pm&quot;, &quot;File::Crunk&quot;)&lt;/code&gt; 는 &lt;code&gt;@_&lt;/code&gt; 입니다.)</target>
        </trans-unit>
        <trans-unit id="d1d55a165f99ccc6289583795c82aceb24ceabae" translate="yes" xml:space="preserve">
          <source>This attribute's default value is false, meaning that no callback is called.</source>
          <target state="translated">이 속성의 기본값은 false이며 콜백이 호출되지 않음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="bcee703f93ae24f2cb5be27baf6a28edef44800c" translate="yes" xml:space="preserve">
          <source>This attribute's default value is false; and normally you won't need to turn it on.</source>
          <target state="translated">이 속성의 기본값은 false입니다. 일반적으로 전원을 켤 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="56b03f0333e5f7d53de3d13aaa7c296581e96eb6" translate="yes" xml:space="preserve">
          <source>This attribute, if set to a nonzero positive value, will make searches output (via &lt;code&gt;&lt;a href=&quot;../../functions/warn&quot;&gt;warn&lt;/a&gt;&lt;/code&gt;) notes about what they're doing as they do it. This option may be useful for debugging a pod-related module. This attribute's default value is zero, meaning that no &lt;code&gt;&lt;a href=&quot;../../functions/warn&quot;&gt;warn&lt;/a&gt;&lt;/code&gt; messages are produced. (Setting verbose to 1 turns on some messages, and setting it to 2 turns on even more messages, i.e., makes the following search(es) even more verbose than 1 would make them.)</source>
          <target state="translated">이 속성이 0이 아닌 양수 값으로 설정되면 &lt;code&gt;&lt;a href=&quot;../../functions/warn&quot;&gt;warn&lt;/a&gt;&lt;/code&gt; 를 통해 검색 결과에 수행 한 작업에 대한 메모를 표시합니다. 이 옵션은 포드 관련 모듈을 디버깅하는 데 유용 할 수 있습니다. 이 속성의 기본값은 0이며, &lt;code&gt;&lt;a href=&quot;../../functions/warn&quot;&gt;warn&lt;/a&gt;&lt;/code&gt; 메시지가 생성 되지 않음을 의미합니다 . (자세한 내용을 1로 설정하면 일부 메시지가 켜지고 2로 설정하면 더 많은 메시지가 켜집니다. 즉, 다음 검색이 1보다 더 자세한 정보가됩니다.)</target>
        </trans-unit>
        <trans-unit id="0c5539e5a1f8b4ae98bcf6660273088727acad03" translate="yes" xml:space="preserve">
          <source>This attribute, if set to a nonzero positive value, will make searches output (via &lt;code&gt;warn&lt;/code&gt;) notes about what they're doing as they do it. This option may be useful for debugging a pod-related module. This attribute's default value is zero, meaning that no &lt;code&gt;warn&lt;/code&gt; messages are produced. (Setting verbose to 1 turns on some messages, and setting it to 2 turns on even more messages, i.e., makes the following search(es) even more verbose than 1 would make them.)</source>
          <target state="translated">이 속성이 0이 아닌 양수 값으로 설정되면 검색 결과 ( &lt;code&gt;warn&lt;/code&gt; 를 통해 )가 수행하는 작업에 대한 메모를 작성합니다. 이 옵션은 포드 관련 모듈을 디버깅하는 데 유용 할 수 있습니다. 이 속성의 기본값은 0이며 &lt;code&gt;warn&lt;/code&gt; 메시지가 생성 되지 않음을 의미합니다 . (verbose를 1로 설정하면 일부 메시지가 활성화되고 2로 설정하면 더 많은 메시지가 활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="9a5ab376fb5b92c88b226665b3b3189f69774bb5" translate="yes" xml:space="preserve">
          <source>This attribute, if set to a true value, means that searches should implicitly add perl's</source>
          <target state="translated">이 속성이 true 값으로 설정되면 검색에서 암시 적으로 perl을 추가해야합니다.</target>
        </trans-unit>
        <trans-unit id="cb9b1d7b2cb6a7fd551e138029c10c2929f9890c" translate="yes" xml:space="preserve">
          <source>This attribute, if set to true will send complaints to STDERR. The default value is false -- i.e., complaints do not go to STDERR.</source>
          <target state="translated">이 속성을 true로 설정하면 불만 사항이 STDERR로 전송됩니다. 기본값은 false입니다. 즉, 불만이 STDERR로 이동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b61204e83fba97c2ca8def6dbf1ab66670d89867" translate="yes" xml:space="preserve">
          <source>This attribute, if set to true, will suppress generation of an errata section. The default value is false -- i.e., an errata section will be generated.</source>
          <target state="translated">이 속성을 true로 설정하면 에라타 섹션이 생성되지 않습니다. 기본값은 false입니다. 즉, 에라타 섹션이 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="571c6c575be741c0ccb3900f5d3e71326d82d454" translate="yes" xml:space="preserve">
          <source>This attribute, if set to true, will suppress reports of non-fatal error messages. The default value is false, meaning that complaints</source>
          <target state="translated">이 속성을 true로 설정하면 치명적이지 않은 오류 메시지에 대한보고가 표시되지 않습니다. 기본값은 false입니다.</target>
        </trans-unit>
        <trans-unit id="a182f040f9812e41854866431a64ba79744c6637" translate="yes" xml:space="preserve">
          <source>This attribute, when set to a true value (and it is false by default) ignores any &quot;X&amp;lt;...&amp;gt;&quot; sequences in the document being parsed. Many formats don't actually use the content of these codes, so have no reason to process them.</source>
          <target state="translated">이 속성은 true 값 (기본적으로 false)으로 설정되면 구문 분석중인 문서의 모든 &quot;X &amp;lt;...&amp;gt;&quot;시퀀스를 무시합니다. 많은 형식이 실제로 이러한 코드의 내용을 사용하지 않으므로 처리 할 이유가 없습니다.</target>
        </trans-unit>
        <trans-unit id="b434a6b0cc83e10e398b4286a85f3e17ab1066b8" translate="yes" xml:space="preserve">
          <source>This attribute, when set to a true value (and it is false by default) makes sure that only one event (or token, or node) will be created for any single contiguous sequence of text. For example, consider this somewhat contrived example:</source>
          <target state="translated">이 속성을 true 값 (기본적으로 false)으로 설정하면 연속 된 단일 텍스트 시퀀스에 대해 하나의 이벤트 (또는 토큰 또는 노드) 만 생성됩니다. 예를 들어, 다음과 같은 다소 인위적인 예를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="2a15dcae492825f898078cd25d1654376a0c6156" translate="yes" xml:space="preserve">
          <source>This attribute, when set to a true value (it is false by default) will keep &lt;code&gt;=encoding&lt;/code&gt; and its content in the event structure. Most formats don't actually need to process the content of an &lt;code&gt;=encoding&lt;/code&gt; directive, even when this directive sets the encoding and the processor makes use of the encoding information. Indeed, it is possible to know the encoding without processing the directive content.</source>
          <target state="translated">이 속성은 true 값 (기본적으로 false)으로 설정되면 &lt;code&gt;=encoding&lt;/code&gt; 및 해당 컨텐츠를 이벤트 구조에 유지합니다. 대부분의 형식은 이 지시문이 인코딩을 설정하고 프로세서가 인코딩 정보를 사용하는 경우에도 &lt;code&gt;=encoding&lt;/code&gt; 지시문 의 내용을 실제로 처리 할 필요가 없습니다 . 실제로 지시어 내용을 처리하지 않고도 인코딩을 알 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="696114490e2efba39fd9f36eac6a38a5d07a8aca" translate="yes" xml:space="preserve">
          <source>This became fatal in Perl 5.32.</source>
          <target state="translated">이것은 Perl 5.32에서 치명적이었습니다.</target>
        </trans-unit>
        <trans-unit id="b39a84ee1b444ad72be8b273ce2aa43be2362f55" translate="yes" xml:space="preserve">
          <source>This behavior can be overridden by supplying your own set of files to search. PL_FILES accepts a hash ref, the key being the file to run and the value is passed in as the first argument when the PL file is run.</source>
          <target state="translated">검색 할 파일 세트를 제공하여이 동작을 무시할 수 있습니다. PL_FILES는 해시 참조를 허용하며, 키는 실행할 파일이며 PL 파일이 실행될 때 값이 첫 번째 인수로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="fa4bb1602ab15283bd3eccd436e14ac034642f38" translate="yes" xml:space="preserve">
          <source>This behavior is convenient, because we usually want to ignore newlines when we count and match characters in a line. Sometimes, however, we want to keep track of newlines. We might even want &lt;code&gt;'^'&lt;/code&gt; and &lt;code&gt;'$'&lt;/code&gt; to anchor at the beginning and end of lines within the string, rather than just the beginning and end of the string. Perl allows us to choose between ignoring and paying attention to newlines by using the &lt;code&gt;/s&lt;/code&gt; and &lt;code&gt;/m&lt;/code&gt; modifiers. &lt;code&gt;/s&lt;/code&gt; and &lt;code&gt;/m&lt;/code&gt; stand for single line and multi-line and they determine whether a string is to be treated as one continuous string, or as a set of lines. The two modifiers affect two aspects of how the regexp is interpreted: 1) how the &lt;code&gt;'.'&lt;/code&gt; character class is defined, and 2) where the anchors &lt;code&gt;'^'&lt;/code&gt; and &lt;code&gt;'$'&lt;/code&gt; are able to match. Here are the four possible combinations:</source>
          <target state="translated">이 동작은 한 줄의 문자를 계산하고 일치시킬 때 일반적으로 줄 바꿈을 무시하기를 원하기 때문에 편리합니다. 그러나 때때로 우리는 줄 바꿈을 추적하고 싶습니다. &lt;code&gt;'^'&lt;/code&gt; 및 &lt;code&gt;'$'&lt;/code&gt; 가 문자열의 시작과 끝이 아닌 문자열의 시작과 끝 부분에 고정 되기를 원할 수도 있습니다 . Perl을 사용하면 &lt;code&gt;/s&lt;/code&gt; 및 &lt;code&gt;/m&lt;/code&gt; 수정자를 사용하여 개행 문자를 무시하고주의를 기울일 수 있습니다. &lt;code&gt;/s&lt;/code&gt; 및 &lt;code&gt;/m&lt;/code&gt; 은 한 줄과 여러 줄을 나타내며 문자열을 하나의 연속 문자열로 처리할지 아니면 일련의 줄로 처리 할지를 결정합니다. 두 수정자는 regexp가 해석되는 방법의 두 가지 측면에 영향을줍니다. 1) &lt;code&gt;'.'&lt;/code&gt; 문자 클래스가 정의되고 2) 앵커 &lt;code&gt;'^'&lt;/code&gt; 및 &lt;code&gt;'$'&lt;/code&gt; 가 일치 할 수있는 위치. 가능한 네 가지 조합은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="31de598976c4af9df58fa731498e0e725fcefe91" translate="yes" xml:space="preserve">
          <source>This behavior is convenient, because we usually want to ignore newlines when we count and match characters in a line. Sometimes, however, we want to keep track of newlines. We might even want &lt;code&gt;^&lt;/code&gt; and &lt;code&gt;$&lt;/code&gt; to anchor at the beginning and end of lines within the string, rather than just the beginning and end of the string. Perl allows us to choose between ignoring and paying attention to newlines by using the &lt;code&gt;//s&lt;/code&gt; and &lt;code&gt;//m&lt;/code&gt; modifiers. &lt;code&gt;//s&lt;/code&gt; and &lt;code&gt;//m&lt;/code&gt; stand for single line and multi-line and they determine whether a string is to be treated as one continuous string, or as a set of lines. The two modifiers affect two aspects of how the regexp is interpreted: 1) how the &lt;code&gt;'.'&lt;/code&gt; character class is defined, and 2) where the anchors &lt;code&gt;^&lt;/code&gt; and &lt;code&gt;$&lt;/code&gt; are able to match. Here are the four possible combinations:</source>
          <target state="translated">이 동작은 편리합니다. 일반적으로 한 줄의 문자를 세고 일치시킬 때 줄 바꿈을 무시하려고합니다. 그러나 때때로 우리는 줄 바꿈을 추적하려고합니다. 심지어 문자열의 시작과 끝이 아니라 문자열 내에서 줄의 시작과 끝에 &lt;code&gt;^&lt;/code&gt; 와 &lt;code&gt;$&lt;/code&gt; 가 고정 되기를 원할 수도 있습니다 . Perl을 사용하면 &lt;code&gt;//s&lt;/code&gt; 및 &lt;code&gt;//m&lt;/code&gt; 수정자를 사용하여 개행을 무시하고주의를 기울일 수 있습니다. &lt;code&gt;//s&lt;/code&gt; 및 &lt;code&gt;//m&lt;/code&gt; 은 한 줄과 여러 줄을 나타내며 문자열을 하나의 연속 문자열로 취급할지 또는 줄 집합으로 취급할지 결정합니다. 두 수정자는 정규 표현식이 해석되는 방식의 두 가지 측면에 영향을 미칩니다. 1) &lt;code&gt;'.'&lt;/code&gt; 문자 클래스가 정의되며 2) 앵커 &lt;code&gt;^&lt;/code&gt; 와 &lt;code&gt;$&lt;/code&gt; 가 일치 할 수있는 위치입니다. 가능한 네 가지 조합은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3d6ebadd3063ef053971debc9b4e78f1e936126e" translate="yes" xml:space="preserve">
          <source>This behavior is more &quot;Do what I mean&quot; than in earlier Perls for most applications. But it catches fewer issues for code that needs to be strictly Unicode compliant. Therefore there is an additional mode of operation available to accommodate such code. This mode is enabled if a regular expression pattern is compiled within the lexical scope where the &lt;code&gt;&quot;non_unicode&quot;&lt;/code&gt; warning class has been made fatal, say by:</source>
          <target state="translated">이 동작은 대부분의 응용 프로그램에서 이전 Perls보다 &quot;의미있는 것&quot;입니다. 그러나 엄격하게 유니 코드를 준수 해야하는 코드의 문제는 적습니다. 따라서 이러한 코드를 수용 할 수있는 추가 작동 모드가 있습니다. &lt;code&gt;&quot;non_unicode&quot;&lt;/code&gt; 경고 클래스가 치명적인 어휘 범위 내에서 정규식 패턴이 컴파일 된 경우이 모드가 사용 가능합니다 .</target>
        </trans-unit>
        <trans-unit id="092eaaecfde2fe8092e286b99e012b8ea81cec11" translate="yes" xml:space="preserve">
          <source>This behavior of &lt;code&gt;&lt;a href=&quot;functions/unlink&quot;&gt;unlink&lt;/a&gt;&lt;/code&gt; is to be compatible with POSIX behavior and not traditional VMS behavior.</source>
          <target state="translated">이 &lt;code&gt;&lt;a href=&quot;functions/unlink&quot;&gt;unlink&lt;/a&gt;&lt;/code&gt; 동작은 기존 VMS 동작이 아닌 POSIX 동작과 호환되어야합니다.</target>
        </trans-unit>
        <trans-unit id="76845e7cfd2a36561cb45a7adf71017bb1774b07" translate="yes" xml:space="preserve">
          <source>This behavior of &lt;code&gt;unlink&lt;/code&gt; is to be compatible with POSIX behavior and not traditional VMS behavior.</source>
          <target state="translated">이러한 &lt;code&gt;unlink&lt;/code&gt; 동작은 기존 VMS 동작이 아닌 POSIX 동작과 호환됩니다.</target>
        </trans-unit>
        <trans-unit id="353b3ac3017572fed965aadb9e085377b2c9e20d" translate="yes" xml:space="preserve">
          <source>This behavior provides the semantic of lexical scoping, and is used in, for instance, the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict&lt;/code&gt; pragma.</source>
          <target state="translated">이 동작은 어휘 범위 지정의 의미를 제공하며, 예를 들어 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict&lt;/code&gt; pragma에 사용 됩니다.</target>
        </trans-unit>
        <trans-unit id="96dcd6333752f9f98479a9189f9fc8dc00af90ba" translate="yes" xml:space="preserve">
          <source>This behavior provides the semantic of lexical scoping, and is used in, for instance, the &lt;code&gt;use strict&lt;/code&gt; pragma.</source>
          <target state="translated">이 동작은 어휘 범위 지정의 의미를 제공하며 예를 들어 &lt;code&gt;use strict&lt;/code&gt; pragma 사용에 사용 됩니다.</target>
        </trans-unit>
        <trans-unit id="902d9db5da6a9d0d90bec88dd7435e3d3036822b" translate="yes" xml:space="preserve">
          <source>This behaviour is identical to that of the actual compiler.</source>
          <target state="translated">이 동작은 실제 컴파일러와 동일합니다.</target>
        </trans-unit>
        <trans-unit id="6e8dc928034c49a32a9b32094d6524d49150a39e" translate="yes" xml:space="preserve">
          <source>This behviour is copied inspired by &lt;code&gt;IO::Socket::INET&lt;/code&gt;; for more fine grained control over connection timeouts, consider performing a nonblocking connect directly.</source>
          <target state="translated">이 동작은 &lt;code&gt;IO::Socket::INET&lt;/code&gt; 영감을 받아 복사되었습니다 . 연결 시간 초과를보다 세밀하게 제어하려면 비 차단 연결을 직접 수행하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="6aea6026d60fc1fd0c7a4849c08ac16e1e32fc6e" translate="yes" xml:space="preserve">
          <source>This binds a &lt;a href=&quot;http://man.he.net/man3/dbm&quot;&gt;dbm(3)&lt;/a&gt;, &lt;a href=&quot;http://man.he.net/man3/ndbm&quot;&gt;ndbm(3)&lt;/a&gt;, &lt;a href=&quot;http://man.he.net/man3/sdbm&quot;&gt;sdbm(3)&lt;/a&gt;, &lt;a href=&quot;http://man.he.net/man3/gdbm&quot;&gt;gdbm(3)&lt;/a&gt;, or Berkeley DB file to a hash. HASH is the name of the hash. (Unlike normal &lt;a href=&quot;#open-FILEHANDLE%2CMODE%2CEXPR&quot;&gt;&lt;code&gt;open&lt;/code&gt;&lt;/a&gt;, the first argument is</source>
          <target state="translated">이것은 &lt;a href=&quot;http://man.he.net/man3/dbm&quot;&gt;dbm (3)&lt;/a&gt; , &lt;a href=&quot;http://man.he.net/man3/ndbm&quot;&gt;ndbm (3)&lt;/a&gt; , &lt;a href=&quot;http://man.he.net/man3/sdbm&quot;&gt;sdbm (3)&lt;/a&gt; , &lt;a href=&quot;http://man.he.net/man3/gdbm&quot;&gt;gdbm (3)&lt;/a&gt; 또는 Berkeley DB 파일을 해시에 바인딩합니다 . HASH는 해시의 이름입니다. (normal &lt;a href=&quot;#open-FILEHANDLE%2CMODE%2CEXPR&quot;&gt; &lt;code&gt;open&lt;/code&gt; &lt;/a&gt; 과 달리 첫 번째 인수는</target>
        </trans-unit>
        <trans-unit id="fd9ffc9da0934423cf7a8b2a8167c734225e00ac" translate="yes" xml:space="preserve">
          <source>This binds a dbm(3), ndbm(3), sdbm(3), gdbm(3), or Berkeley DB file to a hash. HASH is the name of the hash. (Unlike normal &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt;, the first argument is</source>
          <target state="translated">dbm (3), ndbm (3), sdbm (3), gdbm (3) 또는 Berkeley DB 파일을 해시에 바인딩합니다. 해시는 해시의 이름입니다. (일반적인 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; 과 달리 첫 번째 인수는</target>
        </trans-unit>
        <trans-unit id="2616a24dba48e4df35dec143fa3cabdfd81fd386" translate="yes" xml:space="preserve">
          <source>This binds a dbm(3), ndbm(3), sdbm(3), gdbm(3), or Berkeley DB file to a hash. HASH is the name of the hash. (Unlike normal &lt;code&gt;&lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;&lt;/code&gt;, the first argument is</source>
          <target state="translated">dbm (3), ndbm (3), sdbm (3), gdbm (3) 또는 Berkeley DB 파일을 해시에 바인딩합니다. 해시는 해시의 이름입니다. (일반적인 &lt;code&gt;&lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; 과 달리 첫 번째 인수는</target>
        </trans-unit>
        <trans-unit id="a6324526e82c2b2028f79347525bf2bc78810ebd" translate="yes" xml:space="preserve">
          <source>This block modifies all the &lt;code&gt;.c&lt;/code&gt; files in the current directory, leaving a backup of the original data from each file in a new &lt;code&gt;.c.orig&lt;/code&gt; file.</source>
          <target state="translated">이 블록 은 현재 디렉토리의 모든 &lt;code&gt;.c&lt;/code&gt; 파일을 수정 하여 각 파일의 원본 데이터를 새 &lt;code&gt;.c.orig&lt;/code&gt; 파일로 백업 합니다.</target>
        </trans-unit>
        <trans-unit id="ba453fd403a510bef4a413f0d9ec2dc3165244e0" translate="yes" xml:space="preserve">
          <source>This boilerplate uses the low-overhead &lt;code&gt;XSLoader&lt;/code&gt; if present; if used with an antique Perl which has no &lt;code&gt;XSLoader&lt;/code&gt; , it falls back to using &lt;code&gt;DynaLoader&lt;/code&gt; .</source>
          <target state="translated">이 상용구는 로우 오버 헤드 &lt;code&gt;XSLoader&lt;/code&gt; 가있는 경우 이를 사용합니다 . &lt;code&gt;XSLoader&lt;/code&gt; 가없는 앤티크 Perl과 함께 사용하면 &lt;code&gt;DynaLoader&lt;/code&gt; 를 사용 하게 됩니다.</target>
        </trans-unit>
        <trans-unit id="ed948443998fb2b43bd30eac485b18baa935c1f0" translate="yes" xml:space="preserve">
          <source>This boilerplate uses the low-overhead &lt;code&gt;XSLoader&lt;/code&gt; if present; if used with an antique Perl which has no &lt;code&gt;XSLoader&lt;/code&gt;, it falls back to using &lt;code&gt;DynaLoader&lt;/code&gt;.</source>
          <target state="translated">이 상용구는 오버 헤드가 낮은 &lt;code&gt;XSLoader&lt;/code&gt; 가있는 경우 사용합니다 . &lt;code&gt;XSLoader&lt;/code&gt; 가없는 골동품 Perl과 함께 사용하면 &lt;code&gt;DynaLoader&lt;/code&gt; 를 사용하는 것으로 대체 됩니다.</target>
        </trans-unit>
        <trans-unit id="6ac1b6bd4290dbb1a12be2a600f9520d51970c2a" translate="yes" xml:space="preserve">
          <source>This breaks tests that do string comparison of TAP output.</source>
          <target state="translated">이것은 TAP 출력의 문자열 비교를 수행하는 테스트를 중단합니다.</target>
        </trans-unit>
        <trans-unit id="1469fe949bc40a4de2b7dea78ef9ae09eb5856f4" translate="yes" xml:space="preserve">
          <source>This brings up a very important lesson. Code has bugs. Tests are code. Ergo, tests have bugs. A failing test could mean a bug in the code, but don't discount the possibility that the test is wrong.</source>
          <target state="translated">이것은 매우 중요한 교훈을 제공합니다. 코드에 버그가 있습니다. 테스트는 코드입니다. Ergo, 테스트에는 버그가 있습니다. 실패한 테스트는 코드의 버그를 의미 할 수 있지만 테스트가 잘못되었을 가능성을 무시해서는 안됩니다. ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ</target>
        </trans-unit>
        <trans-unit id="090e5f02457ce14eed85483c0b931f07be2bd405" translate="yes" xml:space="preserve">
          <source>This bug only affects closures that are generated by the block but used afterwards. Lexical variables that are only used during the lifetime of the block's execution will take their individual values for each invocation, as normal.</source>
          <target state="translated">이 버그는 블록에 의해 생성되었지만 나중에 사용되는 클로저에만 영향을줍니다. 블록의 실행 수명 동안에 만 사용되는 어휘 변수는 정상적으로 각 호출에 대해 개별 값을 갖습니다.</target>
        </trans-unit>
        <trans-unit id="68e1e1f3b09649c408f4196cd0038c9420b69124" translate="yes" xml:space="preserve">
          <source>This bug was deprecated in Perl 5.004, has been rectified in Perl 5.28 by using method lookup only for methods' &lt;code&gt;AUTOLOAD&lt;/code&gt;s.</source>
          <target state="translated">이 버그는 Perl 5.004에서 폐기되었으며 Perl 5.28에서는 메소드의 &lt;code&gt;AUTOLOAD&lt;/code&gt; 에만 메소드 조회를 사용하여 수정되었습니다 .</target>
        </trans-unit>
        <trans-unit id="3fb23a96de018295d436dfc71b478c2f496e60be" translate="yes" xml:space="preserve">
          <source>This bug was fixed in Perl 5.18, but may still trip you up if you are using older versions:</source>
          <target state="translated">이 버그는 Perl 5.18에서 수정되었지만 이전 버전을 사용하는 경우 여전히 문제가 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ca44502c3ed83912a6b5db8a967d8fd6b852bc6b" translate="yes" xml:space="preserve">
          <source>This bug will be rectified in future by using method lookup only for methods' &lt;code&gt;AUTOLOAD&lt;/code&gt; s. However, there is a significant base of existing code that may be using the old behavior. So, as an interim step, Perl currently issues an optional warning when non-methods use inherited &lt;code&gt;AUTOLOAD&lt;/code&gt; s.</source>
          <target state="translated">이 버그는 메소드의 &lt;code&gt;AUTOLOAD&lt;/code&gt; 에 대해서만 메소드 검색을 사용하여 수정 될 것 입니다. 그러나 이전 동작을 사용하고있을 수있는 기존 코드의 중요한 기반이 있습니다. 따라서 임시 단계로서 Perl은 메소드가 아닌 상속 된 &lt;code&gt;AUTOLOAD&lt;/code&gt; 를 사용할 때 현재 선택적 경고를 발행합니다 .</target>
        </trans-unit>
        <trans-unit id="3151c00be9f916508bc5bf705b67d1e4b35d8229" translate="yes" xml:space="preserve">
          <source>This call extracts the next single substring that is a valid Perl quotelike operator (and removes it from $text):</source>
          <target state="translated">이 호출은 유효한 Perl 따옴표와 같은 연산자 인 다음 단일 하위 문자열을 추출하여 $ text에서 제거합니다.</target>
        </trans-unit>
        <trans-unit id="ced21c2bd0a49aeaa42731431a2edf3632b44a97" translate="yes" xml:space="preserve">
          <source>This call will allow &lt;code&gt;--l&lt;/code&gt; and &lt;code&gt;--L&lt;/code&gt; for the length option, but requires a least &lt;code&gt;--hea&lt;/code&gt; and &lt;code&gt;--hei&lt;/code&gt; for the head and height options.</source>
          <target state="translated">이 호출은 길이 옵션에 &lt;code&gt;--l&lt;/code&gt; 및 &lt;code&gt;--L&lt;/code&gt; 을 허용 하지만 head 및 height 옵션 에는 최소 &lt;code&gt;--hea&lt;/code&gt; 및 &lt;code&gt;--hei&lt;/code&gt; 가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="cc74026b11403dd05d9d70bf8ec94212f671778f" translate="yes" xml:space="preserve">
          <source>This callback is where Perl untaints its own capture variables under taint mode (see &lt;a href=&quot;perlsec&quot;&gt;perlsec&lt;/a&gt;). See the &lt;code&gt;Perl_reg_numbered_buff_fetch&lt;/code&gt; function in</source>
          <target state="translated">이 콜백은 Perl이 오염 모드에서 자체 캡처 변수를 유지하지 않는 곳입니다 ( &lt;a href=&quot;perlsec&quot;&gt;perlsec&lt;/a&gt; 참조 ). &lt;code&gt;Perl_reg_numbered_buff_fetch&lt;/code&gt; 함수를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="34608b82ee2af981743bfaea1702ca89b064619d" translate="yes" xml:space="preserve">
          <source>This callback will always be invoked and this will happen for each result after one of the above callbacks is invoked. For example, if &lt;a href=&quot;../term/ansicolor&quot;&gt;Term::ANSIColor&lt;/a&gt; is loaded, you could use the following to color your test output:</source>
          <target state="translated">이 콜백은 항상 호출되며 위의 콜백 중 하나가 호출 된 후 각 결과에 대해 발생합니다. 예를 들어 &lt;a href=&quot;../term/ansicolor&quot;&gt;Term :: ANSIColor가로&lt;/a&gt; 드 된 경우 다음을 사용하여 테스트 출력을 채색 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f9cffd244aaaaeed6cac7d9924c6db108cbddbfb" translate="yes" xml:space="preserve">
          <source>This callback will always be invoked and this will happen for each result after one of the above callbacks is invoked. For example, if &lt;a href=&quot;Term::ANSIColor&quot;&gt;Term::ANSIColor&lt;/a&gt; is loaded, you could use the following to color your test output:</source>
          <target state="translated">이 콜백은 항상 호출되며 위의 콜백 중 하나가 호출 된 후 각 결과에 대해 발생합니다. 예를 들어 &lt;a href=&quot;Term::ANSIColor&quot;&gt;Term :: ANSIColor가로&lt;/a&gt; 드 된 경우 다음을 사용하여 테스트 출력의 색상을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="367b3e398988397a700bd743e801d4bc7d9d9445" translate="yes" xml:space="preserve">
          <source>This calls &lt;code&gt;sv_collxfrm_flags&lt;/code&gt; with the SV_GMAGIC flag. See &lt;code&gt;&lt;a href=&quot;#sv_collxfrm_flags&quot;&gt;&quot;sv_collxfrm_flags&quot;&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이것은 SV_GMAGIC 플래그와 함께 &lt;code&gt;sv_collxfrm_flags&lt;/code&gt; 를 호출합니다 . &lt;code&gt;&lt;a href=&quot;#sv_collxfrm_flags&quot;&gt;&quot;sv_collxfrm_flags&quot;&lt;/a&gt;&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a84240a7c3c6fb058597f6d953d7900c399c1c57" translate="yes" xml:space="preserve">
          <source>This calls &lt;code&gt;sv_collxfrm_flags&lt;/code&gt; with the SV_GMAGIC flag. See &lt;code&gt;sv_collxfrm_flags&lt;/code&gt; .</source>
          <target state="translated">SV_GMAGIC 플래그와 함께 &lt;code&gt;sv_collxfrm_flags&lt;/code&gt; 를 호출합니다 . &lt;code&gt;sv_collxfrm_flags&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e3061d1429b373972a7ca085f04de1fcdc079ed5" translate="yes" xml:space="preserve">
          <source>This calls the &lt;a href=&quot;http://man.he.net/man2/select&quot;&gt;select(2)&lt;/a&gt; syscall with the bit masks specified, which can be constructed using &lt;a href=&quot;#fileno-FILEHANDLE&quot;&gt;&lt;code&gt;fileno&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#vec-EXPR%2COFFSET%2CBITS&quot;&gt;&lt;code&gt;vec&lt;/code&gt;&lt;/a&gt;, along these lines:</source>
          <target state="translated">이것은 비트 마스크가 지정된 &lt;a href=&quot;http://man.he.net/man2/select&quot;&gt;select (2)&lt;/a&gt; syscall을 호출합니다. 이것은 다음 줄을 따라 &lt;a href=&quot;#fileno-FILEHANDLE&quot;&gt; &lt;code&gt;fileno&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#vec-EXPR%2COFFSET%2CBITS&quot;&gt; &lt;code&gt;vec&lt;/code&gt; 를&lt;/a&gt; 사용하여 구성 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5732bf6668134ab56787956038f1ef3e84c0d62a" translate="yes" xml:space="preserve">
          <source>This calls the &lt;code&gt;bark&lt;/code&gt; method from class &lt;code&gt;Dog&lt;/code&gt; on an object of class &lt;code&gt;Tree&lt;/code&gt;, even if the two classes are completely unrelated. Use this with great care.</source>
          <target state="translated">이것은 두 클래스가 완전히 관련이 없더라도 &lt;code&gt;Tree&lt;/code&gt; 클래스의 객체에서 &lt;code&gt;Dog&lt;/code&gt; 클래스 의 &lt;code&gt;bark&lt;/code&gt; 메서드를 호출합니다 . 주의해서 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="86657828dc4b39c2a031e8feb96e30aa836f7063" translate="yes" xml:space="preserve">
          <source>This calls the select(2) syscall with the bit masks specified, which can be constructed using &lt;code&gt;&lt;a href=&quot;fileno&quot;&gt;fileno&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;vec&quot;&gt;vec&lt;/a&gt;&lt;/code&gt;, along these lines:</source>
          <target state="translated">그러면 지정된 비트 마스크를 사용하여 select (2) syscall을 호출합니다.이 마스크는 &lt;code&gt;&lt;a href=&quot;fileno&quot;&gt;fileno&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;vec&quot;&gt;vec&lt;/a&gt;&lt;/code&gt; 를 사용하여 다음 행을 따라 구성 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6030aab04889f87b188edddb787660db9b1b144a" translate="yes" xml:space="preserve">
          <source>This calls the select(2) syscall with the bit masks specified, which can be constructed using &lt;code&gt;&lt;a href=&quot;functions/fileno&quot;&gt;fileno&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/vec&quot;&gt;vec&lt;/a&gt;&lt;/code&gt;, along these lines:</source>
          <target state="translated">그러면 지정된 비트 마스크를 사용하여 select (2) syscall을 호출합니다.이 마스크는 &lt;code&gt;&lt;a href=&quot;functions/fileno&quot;&gt;fileno&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;functions/vec&quot;&gt;vec&lt;/a&gt;&lt;/code&gt; 를 사용하여 다음 행을 따라 구성 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9bc12c1e6a592155ae29365e5d2b2a31283e6dd9" translate="yes" xml:space="preserve">
          <source>This can also be a problem with intermediate subprocesses in more complicated code, which will call waitpid() on all open filehandles during global destruction--in no predictable order.</source>
          <target state="translated">이것은 더 복잡한 코드의 중간 서브 프로세스에서도 문제가 될 수 있으며, 전역 파괴 중에 열려있는 모든 파일 핸들에서 waitpid ()를 호출 할 수 있으며 예상 할 수있는 순서는 없습니다.</target>
        </trans-unit>
        <trans-unit id="62869b1f9b57cb9d79e8730408b0c95ddf4b16ac" translate="yes" xml:space="preserve">
          <source>This can also be called with a null first argument to indicate that &lt;code&gt;oldstash&lt;/code&gt; has been deleted.</source>
          <target state="translated">&lt;code&gt;oldstash&lt;/code&gt; 가 삭제 되었음을 표시하기 위해 널 (null) 첫 번째 인수와 함께 호출 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d43bae30188acac82d7e357353fabe7bc6c40a81" translate="yes" xml:space="preserve">
          <source>This can be accomplished by adding a repeat specifier to the option specification. Repeat specifiers are very similar to the &lt;code&gt;{...}&lt;/code&gt; repeat specifiers that can be used with regular expression patterns. For example, the above command line would be handled as follows:</source>
          <target state="translated">옵션 스펙에 반복 지정자를 추가하여이를 수행 할 수 있습니다. 반복 지정자는 정규식 패턴과 함께 사용할 수있는 &lt;code&gt;{...}&lt;/code&gt; 반복 지정자 와 매우 유사합니다 . 예를 들어 위의 명령 줄은 다음과 같이 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="372e8345a480f344b8fa12b55e0c07a688e7200f" translate="yes" xml:space="preserve">
          <source>This can be accomplished with a destination routine:</source>
          <target state="translated">이는 대상 루틴으로 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="464c830ff985dea25fcd843d007b91d51ce2d2e9" translate="yes" xml:space="preserve">
          <source>This can be called as an object method with no arguments, in which case the &lt;code&gt;facet_data()&lt;/code&gt; method will be called to get the facet data to be validated.</source>
          <target state="translated">인수가없는 객체 메서드로 호출 할 수 있습니다.이 경우 &lt;code&gt;facet_data()&lt;/code&gt; 메서드가 호출되어 유효성을 검사 할 패싯 데이터를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="c3e3779b19d94c38ed3503cfda1db4bf067d5a3d" translate="yes" xml:space="preserve">
          <source>This can be conveniently combined with precalculation of keys as given above.</source>
          <target state="translated">이것은 위에서 주어진 바와 같이 키의 사전 계산과 편리하게 결합 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9aa85730df925d52e0fdb1ee3b214c2aec4f3fb3" translate="yes" xml:space="preserve">
          <source>This can be especially useful when combined with the &lt;code&gt;sockhost_service&lt;/code&gt; or &lt;code&gt;peerhost_service&lt;/code&gt; methods.</source>
          <target state="translated">이는 &lt;code&gt;sockhost_service&lt;/code&gt; 또는 &lt;code&gt;peerhost_service&lt;/code&gt; 메소드 와 결합 할 때 특히 유용 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7cf76472161d915f784b473af79b1bc9fd8e3268" translate="yes" xml:space="preserve">
          <source>This can be used by subclasses to generate a starting facet data hashref. This will populate the hashref with the trace, meta, amnesty, and about facets. These facets are nearly always produced the same way for all events.</source>
          <target state="translated">이는 하위 클래스에서 시작 패싯 데이터 해시 참조를 생성하는 데 사용할 수 있습니다. 이렇게하면 추적, 메타, 사면 및 정보 패싯으로 해시 참조가 채워집니다. 이러한 패싯은 거의 항상 모든 이벤트에 대해 동일한 방식으로 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="e45e565a182719c4b0dabf0a12cdb967109b4b28" translate="yes" xml:space="preserve">
          <source>This can be used even on systems that do not support forking, but this possibly allows code intended to read files to unexpectedly execute programs. If one can be sure that a particular program is a Perl script expecting filenames in @ARGV using the two-argument form of open() or the &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; operator, the clever programmer can write something like this:</source>
          <target state="translated">이는 분기를 지원하지 않는 시스템에서도 사용할 수 있지만 파일을 읽으려는 코드가 예기치 않게 프로그램을 실행하도록 할 수 있습니다. 특정 프로그램이 open () 또는 &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; 연산자 의 두 인수 형식을 사용하여 @ARGV에서 파일 이름을 예상하는 Perl 스크립트임을 확신 할 수 있다면 영리한 프로그래머는 다음과 같이 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a0b4de28313d2cd5bd8f3c8a3bcc24922ad427d0" translate="yes" xml:space="preserve">
          <source>This can be used to add a callback that is called after all testing is done. This is too late to add additional results, the main use of this callback is to set the exit code.</source>
          <target state="translated">모든 테스트가 완료된 후 호출되는 콜백을 추가하는 데 사용할 수 있습니다. 결과를 추가하기에는 너무 늦었습니다.이 콜백의 주요 용도는 종료 코드를 설정하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="f3ad3a6dca3eb7d856d39662d5cd0dcb078d6c2d" translate="yes" xml:space="preserve">
          <source>This can be used to add amnesty to this event. Amnesty only effects failing assertions in most cases, but some formatters may display them for passing assertions, or even non-assertions as well.</source>
          <target state="translated">이 이벤트에 사면을 추가하는 데 사용할 수 있습니다. 앰네스티는 대부분의 경우 실패한 주장에만 영향을 미치지 만 일부 포맷터는 주장을 전달하거나 심지어 주장이 아닌 경우에도이를 표시 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dee9c9bfb944617270087476daa04080c698fb3a" translate="yes" xml:space="preserve">
          <source>This can be used to change the</source>
          <target state="translated">이것은 변경하는 데 사용할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="748558e1f1395a2c9a926433d579682f2842ae42" translate="yes" xml:space="preserve">
          <source>This can be used to change the encoding from this event onward.</source>
          <target state="translated">이 이벤트부터 인코딩을 변경하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d06a37a2d3a4148b6ee21e32af3a875ef2d651aa" translate="yes" xml:space="preserve">
          <source>This can be used to determine which branch of a pattern was matched without using a separate capture group for each branch, which in turn can result in a performance improvement, as perl cannot optimize &lt;code&gt;/(?:(x)|(y)|(z))/&lt;/code&gt; as efficiently as something like &lt;code&gt;/(?:x(*MARK:x)|y(*MARK:y)|z(*MARK:z))/&lt;/code&gt; .</source>
          <target state="translated">이를 통해 각 분기에 대해 별도의 캡처 그룹을 사용하지 않고 패턴 분기를 일치시킬 수 있습니다. 이는 perl이 &lt;code&gt;/(?:(x)|(y)|(z))/&lt;/code&gt; &lt;code&gt;/(?:x(*MARK:x)|y(*MARK:y)|z(*MARK:z))/&lt;/code&gt; 처럼 효율적 입니다.</target>
        </trans-unit>
        <trans-unit id="0743ccbc8c558ff3b1e6409093d7b93b4731ff66" translate="yes" xml:space="preserve">
          <source>This can be used to determine which branch of a pattern was matched without using a separate capture group for each branch, which in turn can result in a performance improvement, as perl cannot optimize &lt;code&gt;/(?:(x)|(y)|(z))/&lt;/code&gt; as efficiently as something like &lt;code&gt;/(?:x(*MARK:x)|y(*MARK:y)|z(*MARK:z))/&lt;/code&gt;.</source>
          <target state="translated">이것은 perl이 &lt;code&gt;/(?:(x)|(y)|(z))/&lt;/code&gt; 최적화 할 수 없기 때문에 각 분기에 대해 별도의 캡처 그룹을 사용하지 않고 패턴의 어떤 분기가 일치하는지 확인하는 데 사용할 수 있습니다. 그러면 성능이 향상 될 수 있습니다. z)) / &lt;code&gt;/(?:x(*MARK:x)|y(*MARK:y)|z(*MARK:z))/&lt;/code&gt; 처럼 효율적 입니다.</target>
        </trans-unit>
        <trans-unit id="346fd0e78230a9b57890db54a4f1c29bc084f4d0" translate="yes" xml:space="preserve">
          <source>This can be used to disable auto-ending behavior for a hub. The auto-ending behavior is triggered by an end block and is used to cull IPC events, and output the final plan if the plan was 'NO PLAN'.</source>
          <target state="translated">허브에 대한 자동 종료 동작을 비활성화하는 데 사용할 수 있습니다. 자동 종료 동작은 종료 블록에 의해 트리거되며 IPC 이벤트를 컬링하고 계획이 'NO PLAN'인 경우 최종 계획을 출력하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="866129af074a2494eb93f1a1e7f5ceba61d1bdd7" translate="yes" xml:space="preserve">
          <source>This can be used to get/set the no_wait status. Waiting is turned on by default. Waiting will cause the parent process/thread to wait until all child processes and threads are finished before exiting. You will almost never want to turn this off.</source>
          <target state="translated">이것은 no_wait 상태를 가져 오거나 설정하는 데 사용할 수 있습니다. 대기는 기본적으로 켜져 있습니다. 대기는 종료하기 전에 모든 자식 프로세스와 스레드가 완료 될 때까지 부모 프로세스 / 스레드가 대기하게합니다. 이 기능을 끄고 싶지는 않을 것입니다.</target>
        </trans-unit>
        <trans-unit id="c6b6a0827f222037bfd74f5afc449218b3d32dc4" translate="yes" xml:space="preserve">
          <source>This can be used to provide overridable configuration defaults:</source>
          <target state="translated">재정의 가능한 구성 기본값을 제공하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4da1a803fb62b25b77cf251408452655ad68be2a" translate="yes" xml:space="preserve">
          <source>This can be used to reliably link multiple events created by the same tool. For instance a failing test like &lt;code&gt;ok(0, &quot;fail&quot;&lt;/code&gt; will generate 2 events, one being a &lt;a href=&quot;Test2::Event::Ok&quot;&gt;Test2::Event::Ok&lt;/a&gt;, the other being a &lt;a href=&quot;Test2::Event::Diag&quot;&gt;Test2::Event::Diag&lt;/a&gt;, both of these events are related having been created under the same context and by the same initial tool (though multiple tools may have been nested under the initial one).</source>
          <target state="translated">이는 동일한 도구로 생성 된 여러 이벤트를 안정적으로 연결하는 데 사용할 수 있습니다. 예를 들어 &lt;code&gt;ok(0, &quot;fail&quot;&lt;/code&gt; 과 같은 실패한 테스트 는 2 개의 이벤트를 생성합니다. 하나는 &lt;a href=&quot;Test2::Event::Ok&quot;&gt;Test2 :: Event :: Ok&lt;/a&gt; 이고 다른 하나는 &lt;a href=&quot;Test2::Event::Diag&quot;&gt;Test2 :: Event :: Diag&lt;/a&gt; 입니다.이 두 이벤트는 모두 생성 된 것과 관련이 있습니다. 동일한 컨텍스트 및 동일한 초기 도구에 의해 (여러 도구가 초기 도구 아래에 중첩되었을 수 있음).</target>
        </trans-unit>
        <trans-unit id="6d94a2783d9c9eae4add9e504e9f74c8f2268eac" translate="yes" xml:space="preserve">
          <source>This can be used to remove a context acquire hook.</source>
          <target state="translated">컨텍스트 획득 후크를 제거하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="78bcfb4fcf149daa8d598288ab8cfd7c250fe9bc" translate="yes" xml:space="preserve">
          <source>This can be used to remove a context init hook.</source>
          <target state="translated">컨텍스트 초기화 후크를 제거하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="576301f79d31775925cb858d92533113a213c854" translate="yes" xml:space="preserve">
          <source>This can be used to remove a context release hook.</source>
          <target state="translated">컨텍스트 해제 후크를 제거하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7302fe67fb868f202093521caa858978f0b6a28c" translate="yes" xml:space="preserve">
          <source>This can be used to see the effect of/bugs in the various layers e.g.</source>
          <target state="translated">이것은 다양한 레이어에서 버그의 효과를 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="574eac6f70577b288bd89928d8641a1fc45055d3" translate="yes" xml:space="preserve">
          <source>This can be used to send an &lt;a href=&quot;Test2::Event::Plan&quot;&gt;Test2::Event::Plan&lt;/a&gt; event. This event usually takes either a number of tests you expect to run. Optionally you can set the expected count to 0 and give the 'SKIP' directive with a reason to cause all tests to be skipped.</source>
          <target state="translated">&lt;a href=&quot;Test2::Event::Plan&quot;&gt;Test2 :: Event :: Plan&lt;/a&gt; 이벤트 를 보내는 데 사용할 수 있습니다 . 이 이벤트는 일반적으로 실행할 것으로 예상되는 여러 테스트를 수행합니다. 선택적으로 예상 개수를 0으로 설정하고 모든 테스트를 건너 뛰도록하는 이유와 함께 'SKIP'지시문을 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5bfa5c255aef0fa01c834c7ba10a888fee1030c4" translate="yes" xml:space="preserve">
          <source>This can be used to set the template for the IPC temp dir. The template should follow template specifications from &lt;a href=&quot;File::Temp&quot;&gt;File::Temp&lt;/a&gt;.</source>
          <target state="translated">IPC 임시 디렉토리에 대한 템플릿을 설정하는 데 사용할 수 있습니다. 템플릿은 &lt;a href=&quot;File::Temp&quot;&gt;File :: Temp의&lt;/a&gt; 템플릿 사양을 따라야 합니다.</target>
        </trans-unit>
        <trans-unit id="20e14da8dfc2bfdf2f71fc590d8fe2a63e1000ea" translate="yes" xml:space="preserve">
          <source>This can be used to store bytes in the string component of the SV. Here the representation of the data is irrelevant to perl and the bytes themselves are just stored in the SV. It is assumed that the C variable is a pointer (the bytes are copied from that memory location). If the pointer is pointing to something that is represented by 8 bytes then those 8 bytes are stored in the SV (and length() will report a value of 8). This entry is similar to T_OPAQUE.</source>
          <target state="translated">이것은 SV의 문자열 구성 요소에 바이트를 저장하는 데 사용될 수 있습니다. 여기서 데이터 표현은 perl과 관련이 없으며 바이트 자체는 SV에 저장됩니다. C 변수가 포인터 인 것으로 가정합니다 (바이트는 해당 메모리 위치에서 복사 됨). 포인터가 8 바이트로 표시되는 것을 가리키는 경우 해당 8 바이트는 SV에 저장되며 length ()는 8의 값을보고합니다. 이 항목은 T_OPAQUE와 유사합니다.</target>
        </trans-unit>
        <trans-unit id="0410f2327d86bdf0fdae05f37687269ec62b9fe1" translate="yes" xml:space="preserve">
          <source>This can be used to store data from non-pointer types in the string part of an SV. It is similar to T_OPAQUEPTR except that the typemap retrieves the pointer directly rather than assuming it is being supplied. For example, if an integer is imported into Perl using T_OPAQUE rather than T_IV the underlying bytes representing the integer will be stored in the SV but the actual integer value will not be available. i.e. The data is opaque to perl.</source>
          <target state="translated">이것은 포인터가 아닌 유형의 데이터를 SV의 문자열 부분에 저장하는 데 사용할 수 있습니다. typemap이 포인터를 제공한다고 가정하지 않고 직접 포인터를 검색한다는 점을 제외하면 T_OPAQUEPTR과 유사합니다. 예를 들어, T_IV 대신 T_OPAQUE를 사용하여 정수를 Perl로 가져 오면 정수를 나타내는 기본 바이트는 SV에 저장되지만 실제 정수 값은 사용할 수 없습니다. 즉, 데이터는 펄에 불투명하다.</target>
        </trans-unit>
        <trans-unit id="89bc9efe11bbc18be53fe6f2369d301f92011919" translate="yes" xml:space="preserve">
          <source>This can be useful when carrying out batch operations on multiple files that have both an input filename and output filename and the output file can be derived from the input filename. Examples of operations where this can be useful include, file renaming, file copying and file compression.</source>
          <target state="translated">입력 파일 이름과 출력 파일 이름이 모두있는 여러 파일에 대해 일괄 작업을 수행 할 때 유용 할 수 있으며 출력 파일은 입력 파일 이름에서 파생 될 수 있습니다. 이것이 유용한 작업의 예로는 파일 이름 바꾸기, 파일 복사 및 파일 압축이 있습니다.</target>
        </trans-unit>
        <trans-unit id="7ee5530e46592bdd5b18c5d4e4adf9c1e149be67" translate="yes" xml:space="preserve">
          <source>This can easily be demonstrated by using a module, such as the Socket module, which uses eval &quot;...&quot; as part of an AUTOLOAD function. You can 'use' the module outside the compartment and share an (autoloaded) function with the compartment. If an autoload is triggered by code in the compartment, or by any code anywhere that is called by any means from the compartment, then the eval in the Socket module's AUTOLOAD function happens in the namespace of the compartment. Any variables created or used by the eval'd code are now under the control of the code in the compartment.</source>
          <target state="translated">이는 AUTOLOAD 기능의 일부로 eval &quot;...&quot;을 사용하는 소켓 모듈과 같은 모듈을 사용하여 쉽게 설명 할 수 있습니다. 컴 파트먼트 외부에서 모듈을 '사용'하고 컴 파트먼트와 (자동로드 된) 기능을 공유 할 수 있습니다. 컴 파트먼트의 코드 또는 컴 파트먼트에서 호출 된 코드에 의해 자동로드가 트리거되는 경우 소켓 모듈의 AUTOLOAD 함수의 평가는 컴 파트먼트의 네임 스페이스에서 발생합니다. 평가 된 코드에 의해 생성되거나 사용 된 모든 변수는 이제 구획의 코드에 의해 제어됩니다.</target>
        </trans-unit>
        <trans-unit id="aaf34cf4f37f54a5f64557a3e90c8cf5a33d7a99" translate="yes" xml:space="preserve">
          <source>This can fail to be unique if a process generates an id, calls exec, and does it again after the exec and it all happens in less than a second. It can also happen if the systems process id's cycle in less than a second allowing 2 different programs that use this generator to run with the same PID in less than a second. Both these cases are sufficiently unlikely. If you need universally unique ids, or ids that are unique in these conditions, look at &lt;a href=&quot;Data::UUID&quot;&gt;Data::UUID&lt;/a&gt;.</source>
          <target state="translated">프로세스가 id를 생성하고 exec를 호출하고 exec 후에 다시 수행하고 모든 작업이 1 초 이내에 발생하는 경우 이는 고유하지 않을 수 있습니다. 시스템이 1 초 이내에 id의주기를 처리하여이 생성기를 사용하는 2 개의 서로 다른 프로그램이 1 초 이내에 동일한 PID로 실행되도록 허용하는 경우에도 발생할 수 있습니다. 이 두 경우 모두 가능성이 거의 없습니다. 보편적으로 고유 한 ID 또는 이러한 조건에서 고유 한 ID가 필요한 경우 &lt;a href=&quot;Data::UUID&quot;&gt;Data :: UUID를 참조하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="33eb1b5384e732b374fa6a2eb81b539c4ef372da" translate="yes" xml:space="preserve">
          <source>This can give a serious performance boost to your threaded program, since more than one thread will be executing at the same time. As a tradeoff, though, any of those nagging synchronization issues that might not have shown with basic kernel threads will appear with a vengeance.</source>
          <target state="translated">둘 이상의 스레드가 동시에 실행되므로 스레드 된 프로그램의 성능이 크게 향상 될 수 있습니다. 그러나 기본 커널 스레드에서 표시되지 않았을 수있는 잔소리 동기화 문제는 복수로 나타납니다.</target>
        </trans-unit>
        <trans-unit id="56f625d37a903c20859d631591a0773b6d672cf7" translate="yes" xml:space="preserve">
          <source>This can lead to some ambiguities. When &lt;code&gt;\N&lt;/code&gt; is not followed immediately by a left brace, Perl assumes the &lt;code&gt;[^\n]&lt;/code&gt; meaning. Also, if the braces form a valid quantifier such as &lt;code&gt;\N{3}&lt;/code&gt; or &lt;code&gt;\N{5,}&lt;/code&gt; , Perl assumes that this means to match the given quantity of non-newlines (in these examples, 3; and 5 or more, respectively). In all other case, where there is a &lt;code&gt;\N{&lt;/code&gt; and a matching &lt;code&gt;}&lt;/code&gt;, Perl assumes that a character name is desired.</source>
          <target state="translated">이로 인해 일부 모호성이 생길 수 있습니다. 경우 &lt;code&gt;\N&lt;/code&gt; 좌 괄호 바로 뒤에 있지 않은 펄은 가정 &lt;code&gt;[^\n]&lt;/code&gt; 의미한다. 또한 중괄호가 &lt;code&gt;\N{3}&lt;/code&gt; 또는 &lt;code&gt;\N{5,}&lt;/code&gt; 와 같은 유효한 수량 자를 구성하는 경우 Perl은 주어진 줄 바꿈이없는 수량 (이 예에서는 3; 5 이상)과 일치한다고 가정합니다. 각기). 다른 모든 경우, &lt;code&gt;\N{&lt;/code&gt; 및 일치하는 &lt;code&gt;}&lt;/code&gt; 가 있으면 Perl은 문자 이름이 필요하다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="723464c11a99a5463e5bccf086f2c836d4ccab19" translate="yes" xml:space="preserve">
          <source>This can lead to some ambiguities. When &lt;code&gt;\N&lt;/code&gt; is not followed immediately by a left brace, Perl assumes the &lt;code&gt;[^\n]&lt;/code&gt; meaning. Also, if the braces form a valid quantifier such as &lt;code&gt;\N{3}&lt;/code&gt; or &lt;code&gt;\N{5,}&lt;/code&gt;, Perl assumes that this means to match the given quantity of non-newlines (in these examples, 3; and 5 or more, respectively). In all other case, where there is a &lt;code&gt;\N{&lt;/code&gt; and a matching &lt;code&gt;}&lt;/code&gt;, Perl assumes that a character name is desired.</source>
          <target state="translated">이로 인해 일부 모호성이 발생할 수 있습니다. 경우 &lt;code&gt;\N&lt;/code&gt; 좌 괄호 바로 뒤에 있지 않은 펄은 가정 &lt;code&gt;[^\n]&lt;/code&gt; 의미한다. 또한 중괄호가 &lt;code&gt;\N{3}&lt;/code&gt; 또는 &lt;code&gt;\N{5,}&lt;/code&gt; 와 같은 유효한 수량 자를 형성하는 경우 Perl은 이것이 주어진 양의 줄 바꿈이 아닌 (이 예에서는 3, 5 이상, 각기). 다른 모든 경우에 &lt;code&gt;\N{&lt;/code&gt; 및 일치하는 &lt;code&gt;}&lt;/code&gt; 이있는 경우 Perl은 문자 이름이 필요하다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="959b6fc0ff47607dd43aa724268206e3f29dd78b" translate="yes" xml:space="preserve">
          <source>This can lead to unexpected results. For example, a string's semantics can suddenly change if a code point above 255 is appended to it, which changes the rules from ASCII to Unicode. As an example, consider the following program and its output:</source>
          <target state="translated">예기치 않은 결과가 발생할 수 있습니다. 예를 들어 255보다 큰 코드 포인트가 추가되면 규칙의 의미가 ASCII에서 유니 코드로 변경되면 문자열의 의미가 갑자기 변경 될 수 있습니다. 예를 들어, 다음 프로그램 및 해당 출력을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="85608589698ca117deecc9b9804cdf91bb5ea3e0" translate="yes" xml:space="preserve">
          <source>This can result from a bug in emx sprintf which was fixed in 0.9d fix 03.</source>
          <target state="translated">0.9d 수정 03에서 수정 된 emx sprintf의 버그로 인해 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a0068e1ff0325fa89c18995ccdfd4bec0d4d0e1c" translate="yes" xml:space="preserve">
          <source>This can set either by hints files or by Configure. If using a (non-gcc) vendor cc, this variable may contain a version for the compiler.</source>
          <target state="translated">힌트 파일 또는 구성으로 설정할 수 있습니다. gcc가 아닌 벤더 cc를 사용하는 경우이 변수에 컴파일러 버전이 포함될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b497dc3b646a186b11a326e1c1c02e389336f453" translate="yes" xml:space="preserve">
          <source>This can set either by hints files or by Configure. If using gcc, this is gcc, and if not, usually equal to cc, unimpressive, no? Some platforms, however, make good use of this by storing the flavor of the C compiler being used here. For example if using the Sun WorkShop suite, ccname will be &lt;code&gt;workshop&lt;/code&gt; .</source>
          <target state="translated">힌트 파일 또는 구성으로 설정할 수 있습니다. gcc를 사용하는 경우 이것은 gcc이며 그렇지 않은 경우 일반적으로 cc와 같고 인상적이지 않습니까? 그러나 일부 플랫폼은 여기서 사용되는 C 컴파일러의 특징을 저장하여이를 잘 활용합니다. 예를 들어 Sun WorkShop 제품군을 사용하는 경우 ccname은 &lt;code&gt;workshop&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="69cabf4ea065c9fd2da62cddd5444eb3ffe5f2f7" translate="yes" xml:space="preserve">
          <source>This can set either by hints files or by Configure. If using gcc, this is gcc, and if not, usually equal to cc, unimpressive, no? Some platforms, however, make good use of this by storing the flavor of the C compiler being used here. For example if using the Sun WorkShop suite, ccname will be &lt;code&gt;workshop&lt;/code&gt;.</source>
          <target state="translated">힌트 파일 또는 구성으로 설정할 수 있습니다. gcc를 사용하는 경우 이것은 gcc이고 그렇지 않은 경우 일반적으로 cc와 같고 인상적이지 않습니다. 그러나 일부 플랫폼은 여기에 사용되는 C 컴파일러의 특징을 저장하여이를 잘 활용합니다. 예를 들어 Sun WorkShop 제품군을 사용하는 경우 ccname은 &lt;code&gt;workshop&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="5a6e8fb26d6f44c6d09abe16fd5950ff26dfa1ef" translate="yes" xml:space="preserve">
          <source>This category includes</source>
          <target state="translated">이 범주에는 다음이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="268887449daa89d9e6e6591c09f61433e4f65428" translate="yes" xml:space="preserve">
          <source>This causes Attribute::Handlers to define the &lt;code&gt;Roo&lt;/code&gt; attribute in the package that imports the Tie::Me::Kangaroo:Down::Sport module.</source>
          <target state="translated">이로 인해 Attribute :: Handlers 는 Tie :: Me :: Kangaroo : Down :: Sport 모듈을 가져 오는 패키지에 &lt;code&gt;Roo&lt;/code&gt; 속성 을 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="102ace81a524208492f6e027d89b5645163151f6" translate="yes" xml:space="preserve">
          <source>This causes perl to load your module but does not import any symbols.</source>
          <target state="translated">이로 인해 펄은 모듈을로드하지만 심볼은 가져 오지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c30feda4a3a3684c859a87888367dce95a5f76b5" translate="yes" xml:space="preserve">
          <source>This causes the redispatcher to only visit each distinct &lt;code&gt;method&lt;/code&gt; method once. That is, to skip any classes in the hierarchy that it has already visited during redispatch. So, for example, if the previous example were rewritten:</source>
          <target state="translated">이로 인해 redispatcher는 각 고유 한 &lt;code&gt;method&lt;/code&gt; 메소드를 한 번만 방문합니다 . 즉, redispatch 중에 이미 방문한 계층 구조의 클래스를 건너 뛰는 것입니다. 예를 들어 이전 예제를 다시 쓴 경우 :</target>
        </trans-unit>
        <trans-unit id="592a0947cedbbcf96e6c431161a1536bd9ea5fd0" translate="yes" xml:space="preserve">
          <source>This certainly works on Android 8.1 (Oreo) at least...</source>
          <target state="translated">이것은 적어도 Android 8.1 (Oreo)에서 확실히 작동합니다 ...</target>
        </trans-unit>
        <trans-unit id="582cc40cbf8b3547920ee86c914be4717f134b16" translate="yes" xml:space="preserve">
          <source>This change was made because it was found that various commercial tools like editors, or for things like source code control, had been written so that they would not handle program files that used these code points, effectively precluding their use almost entirely! And that was never the intent. They've always been meant to be usable within an application, or cooperating set of applications, at will.</source>
          <target state="translated">이러한 변경은 편집기 나 소스 코드 제어와 같은 다양한 상용 도구가 작성되어 이러한 코드 포인트를 사용하는 프로그램 파일을 처리하지 않아서 거의 전적으로 사용을 배제하는 것으로 밝혀졌습니다! 그리고 그것은 결코 의도가 아니 었습니다. 이들은 항상 응용 프로그램 내에서 또는 협력적인 응용 프로그램 내에서 자유롭게 사용할 수 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="70a94d66ba03d51816f1be0f440a820bbe8643da" translate="yes" xml:space="preserve">
          <source>This change was originally scheduled for 5.30, but was delayed until 5.32.</source>
          <target state="translated">이 변경은 원래 5.30으로 예정되었지만 5.32까지 연기되었습니다.</target>
        </trans-unit>
        <trans-unit id="c679de889cc139bb514d15d08372653b38479f14" translate="yes" xml:space="preserve">
          <source>This changes the sentence to &quot;this is a SUcCess case.&quot;</source>
          <target state="translated">문장이 &quot;이것은 SUCCess 사례&quot;로 변경됩니다.</target>
        </trans-unit>
        <trans-unit id="806d9541617fb633252bc021124ba56dfb002ae1" translate="yes" xml:space="preserve">
          <source>This changes the string that this token holds. You probably won't need to do this.</source>
          <target state="translated">이 토큰이 보유한 문자열을 변경합니다. 아마 이것을 할 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="1b4ce31991e674e8d238b692a9312c922759283b" translate="yes" xml:space="preserve">
          <source>This changes the tagname for this end-token object. You probably won't need to do this.</source>
          <target state="translated">이 엔드 토큰 객체의 태그 이름이 변경됩니다. 아마 이것을 할 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="05c1f4e6ea1fd867b5212d7916e4ce924dd15d97" translate="yes" xml:space="preserve">
          <source>This changes the tagname for this start-token object. You probably won't need to do this.</source>
          <target state="translated">시작 토큰 객체의 태그 이름이 변경됩니다. 아마 이것을 할 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="642eb07575d1344323a97b06a777777ad1321fc4" translate="yes" xml:space="preserve">
          <source>This chart is sorted from slowest to fastest, and shows the percent speed difference between each pair of tests.</source>
          <target state="translated">이 차트는 가장 느린 것부터 가장 빠른 것까지 정렬되며 각 테스트 쌍 간의 속도 차이 백분율을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="7da28c0924cf2fc297ae57e942274584c8adbeb4" translate="yes" xml:space="preserve">
          <source>This checks that every file listed in the .packlist actually exists. If an argument which evaluates to true is given, any missing files will be removed from the internal hash. The return value is a list of the missing files, which will be empty if they all exist.</source>
          <target state="translated">이렇게하면 .packlist에 나열된 모든 파일이 실제로 존재하는지 확인합니다. true로 평가되는 인수가 제공되면 누락 된 파일이 내부 해시에서 제거됩니다. 리턴 값은 누락 된 파일의 목록이며 모두 존재하면 비어 있습니다.</target>
        </trans-unit>
        <trans-unit id="f55eba663917d253b044988b2b6ee903ef6a93dc" translate="yes" xml:space="preserve">
          <source>This class (which is very small -- read the source) overrides Pod::Simple's _handle_element_start, _handle_text, and _handle_element_end methods so that parser events are turned into method calls. (Otherwise, this is a subclass of &lt;a href=&quot;../simple&quot;&gt;Pod::Simple&lt;/a&gt; and inherits all its methods.)</source>
          <target state="translated">이 클래스 (매우 작음-소스 읽기)는 파서 이벤트가 메소드 호출로 변환되도록 Pod :: Simple의 _handle_element_start, _handle_text 및 _handle_element_end 메소드를 대체합니다. (그렇지 않으면 이것은 &lt;a href=&quot;../simple&quot;&gt;Pod :: Simple&lt;/a&gt; 의 서브 클래스이며 모든 메소드를 상속합니다.)</target>
        </trans-unit>
        <trans-unit id="b03d667c22f13241e3a139f207cffaeb024c8e82" translate="yes" xml:space="preserve">
          <source>This class (which is very small -- read the source) overrides Pod::Simple's _handle_element_start, _handle_text, and _handle_element_end methods so that parser events are turned into method calls. (Otherwise, this is a subclass of &lt;a href=&quot;Pod::Simple&quot;&gt;Pod::Simple&lt;/a&gt; and inherits all its methods.)</source>
          <target state="translated">이 클래스 (매우 작은-소스 읽기)는 Pod :: Simple의 _handle_element_start, _handle_text 및 _handle_element_end 메서드를 재정 의하여 파서 이벤트가 메서드 호출로 전환되도록합니다. (그렇지 않으면 &lt;a href=&quot;Pod::Simple&quot;&gt;Pod :: Simple&lt;/a&gt; 의 하위 클래스이며 모든 메서드를 상속합니다.)</target>
        </trans-unit>
        <trans-unit id="494e46870d49e2dc3a5f9a64f75952ec99423e9a" translate="yes" xml:space="preserve">
          <source>This class defines several methods for setting (and, occasionally, reading) the contents of an object. With two exceptions (discussed at the end of this section), these attributes are just for controlling the way searches are carried out.</source>
          <target state="translated">이 클래스는 객체의 내용을 설정 (때로는 읽기)하기위한 몇 가지 메소드를 정의합니다. 이 섹션의 끝에서 논의 된 두 가지 예외를 제외하고 이러한 속성은 검색 수행 방식을 제어하기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="10596a84cc3ac1cc04ef71cd92099faf5ee0b3a2" translate="yes" xml:space="preserve">
          <source>This class inherits from &lt;a href=&quot;Test2::Event&quot;&gt;Test2::Event&lt;/a&gt;.</source>
          <target state="translated">이 클래스는 &lt;a href=&quot;Test2::Event&quot;&gt;Test2 :: Event&lt;/a&gt; 에서 상속됩니다 .</target>
        </trans-unit>
        <trans-unit id="2163bae8bf6b5d5c2d8787321d0be16cd6ab8a00" translate="yes" xml:space="preserve">
          <source>This class inherits from &lt;a href=&quot;Test2::Event::Ok&quot;&gt;Test2::Event::Ok&lt;/a&gt;.</source>
          <target state="translated">이 클래스는 &lt;a href=&quot;Test2::Event::Ok&quot;&gt;Test2 :: Event :: Ok&lt;/a&gt; 에서 상속됩니다 .</target>
        </trans-unit>
        <trans-unit id="1d32aad8f8251ef1db7bcc4b8f3feb324d9d1213" translate="yes" xml:space="preserve">
          <source>This class is NOT a subclass of Pod::Simple::HTML (nor of bad old Pod::Html) -- although it uses Pod::Simple::HTML for doing the conversion of each document.</source>
          <target state="translated">이 클래스는 Pod :: Simple :: HTML (나머지 포드 :: Html도 아님)의 하위 클래스가 아닙니다. 비록 각 문서를 변환하기 위해 Pod :: Simple :: HTML을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="b711767b4a974da1a1509d38f153220b0d62949c" translate="yes" xml:space="preserve">
          <source>This class is a formatter that takes Pod and renders it as RTF, good for viewing/printing in MSWord, WordPad/write.exe, TextEdit, etc.</source>
          <target state="translated">이 클래스는 포드를 가져와 RTF로 렌더링하는 포맷터로 MSWord, WordPad / write.exe, TextEdit 등에서 보거나 인쇄하기에 좋습니다.</target>
        </trans-unit>
        <trans-unit id="138981ec5228a60a4f53dbf829b51f5efd9f8a75" translate="yes" xml:space="preserve">
          <source>This class is a formatter that takes Pod and renders it as XHTML validating HTML.</source>
          <target state="translated">이 클래스는 Pod를 가져 와서 XHTML 유효성 검사 HTML로 렌더링하는 포맷터입니다.</target>
        </trans-unit>
        <trans-unit id="3d4c24315ad07b2a992c0858db0b7be768d0cc0b" translate="yes" xml:space="preserve">
          <source>This class is a formatter that takes Pod and renders it as wrapped plaintext.</source>
          <target state="translated">이 클래스는 포드를 가져 와서 랩핑 된 일반 텍스트로 렌더링하는 포맷터입니다.</target>
        </trans-unit>
        <trans-unit id="abf165bcb49a87540f63e8d80594894213b097e7" translate="yes" xml:space="preserve">
          <source>This class is a stack of hooks to be called in the right order as scopes go away. The stack is only useful when inserted into &lt;code&gt;%^H&lt;/code&gt; and will pop hooks as their &quot;scope&quot; is popped. This is useful for uninstalling or reinstalling subs in a namespace as a pragma goes out of scope.</source>
          <target state="translated">이 클래스는 범위가 사라질 때 올바른 순서로 호출되는 후크 스택입니다. 스택은 &lt;code&gt;%^H&lt;/code&gt; 삽입 할 때만 유용 하며 &quot;범위&quot;가 표시되면 후크가 표시됩니다. 이것은 pragma가 범위를 벗어날 때 네임 스페이스에서 subs를 제거하거나 다시 설치하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="62abaee97c33098880e266351ef2fc532bf53875" translate="yes" xml:space="preserve">
          <source>This class is an internal interface only.</source>
          <target state="translated">이 클래스는 내부 인터페이스입니다.</target>
        </trans-unit>
        <trans-unit id="a096fe03bdd3c99f0e3aefd253d422021e7447e7" translate="yes" xml:space="preserve">
          <source>This class is for checking the syntactic validity of Pod. It works by basically acting like a simple-minded version of &lt;a href=&quot;Pod::Simple::Text&quot;&gt;Pod::Simple::Text&lt;/a&gt; that formats only the &quot;Pod Errors&quot; section (if Pod::Simple even generates one for the given document).</source>
          <target state="translated">이 클래스는 Pod의 구문 유효성을 확인하기위한 것입니다. 기본적으로 &quot;Pod 오류&quot;섹션 만 형식화하는 &lt;a href=&quot;Pod::Simple::Text&quot;&gt;Pod :: Simple :: Text의 단순한&lt;/a&gt; 버전처럼 작동합니다 (Pod :: Simple이 주어진 문서에 대해 하나를 생성하는 경우).</target>
        </trans-unit>
        <trans-unit id="5e43c4bd22a6b18d8bc78626e236eaa142e2b822" translate="yes" xml:space="preserve">
          <source>This class is for checking the syntactic validity of Pod. It works by basically acting like a simple-minded version of &lt;a href=&quot;text&quot;&gt;Pod::Simple::Text&lt;/a&gt; that formats only the &quot;Pod Errors&quot; section (if Pod::Simple even generates one for the given document).</source>
          <target state="translated">이 클래스는 포드의 구문 유효성을 검사하기위한 것입니다. 기본적으로 &quot;Pod Errors&quot;섹션 만 형식화하는 &lt;a href=&quot;text&quot;&gt;Pod :: Simple :: Text의 간단한&lt;/a&gt; 버전으로 작동 합니다 (Pod :: Simple이 지정된 문서에 대해 하나를 생성하는 경우).</target>
        </trans-unit>
        <trans-unit id="9b791e36572b7d483165e52086de0aff10cad7ba" translate="yes" xml:space="preserve">
          <source>This class is for dumping, as text, the events gotten from parsing a Pod document. This class is of interest to people writing Pod formatters based on Pod::Simple. It is useful for seeing exactly what events you get out of some Pod that you feed in.</source>
          <target state="translated">이 클래스는 Pod 문서를 구문 분석하여 얻은 이벤트를 텍스트로 덤프하기위한 것입니다. 이 클래스는 Pod :: Simple을 기반으로 Pod 포맷터를 작성하는 사람들에게 관심이 있습니다. 피드 한 일부 포드에서 어떤 이벤트가 발생했는지 정확하게 확인할 때 유용합니다.</target>
        </trans-unit>
        <trans-unit id="a18cdad26fb8d235532c57fb43aa60327d80a50a" translate="yes" xml:space="preserve">
          <source>This class is for making an HTML rendering of a Pod document.</source>
          <target state="translated">이 클래스는 포드 문서의 HTML 렌더링을 만들기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="fd75675624091c3742f49bbeb8bbfb0c06a37c0a" translate="yes" xml:space="preserve">
          <source>This class is for using Pod::Simple to build a Pod processor -- but one that uses an interface based on a stream of token objects, instead of based on events.</source>
          <target state="translated">이 클래스는 Pod :: Simple을 사용하여 포드 프로세서를 빌드하기위한 것입니다. 그러나 이벤트 대신 토큰 객체 스트림을 기반으로 인터페이스를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="44761047bfaa4c6cc438e77b4bb92131ad714c01" translate="yes" xml:space="preserve">
          <source>This class is inspired by XML::Parser's &quot;Tree&quot; parsing-style, although it doesn't use exactly the same LoL format.</source>
          <target state="translated">이 클래스는 XML :: Parser의 &quot;Tree&quot;구문 분석 스타일에서 영감을 얻었지만 정확히 동일한 LoL 형식을 사용하지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="a9698adab813e0c4fae21452c7598015f3935b3d" translate="yes" xml:space="preserve">
          <source>This class is not of interest to general users.</source>
          <target state="translated">이 클래스는 일반 사용자에게는 관심이 없습니다.</target>
        </trans-unit>
        <trans-unit id="2f2f6048d2f61aa8645bcc5ebd42e19fc8c8aea4" translate="yes" xml:space="preserve">
          <source>This class is of interest to people writing Pod formatters based on Pod::Simple.</source>
          <target state="translated">이 클래스는 Pod :: Simple을 기반으로 Pod 포맷터를 작성하는 사람들에게 관심이 있습니다.</target>
        </trans-unit>
        <trans-unit id="f63f889f338653b4ee33eb44dc0ee1133ee852ae" translate="yes" xml:space="preserve">
          <source>This class is of interest to people writing a Pod processor/formatter.</source>
          <target state="translated">이 수업은 포드 프로세서 / 포매터를 작성하는 사람들에게 관심이 있습니다.</target>
        </trans-unit>
        <trans-unit id="6dca4f8907e7dbb28751ea149d9af37422c91f32" translate="yes" xml:space="preserve">
          <source>This class is that parses Pod and dumps just the text content. It is mainly meant for use by the Pod::Simple test suite, but you may find some other use for it.</source>
          <target state="translated">이 클래스는 포드를 구문 분석하고 텍스트 내용 만 덤프합니다. 주로 Pod :: Simple 테스트 스위트에서 사용하기위한 것이지만 다른 용도로 사용할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="5a51d38f10e103a9903a5853a79eae683ff646eb" translate="yes" xml:space="preserve">
          <source>This class is the workhorse of the &lt;a href=&quot;../../parser&quot;&gt;TAP::Parser&lt;/a&gt; system. Most TAP lines will be test lines and if &lt;code&gt;$result-&amp;gt;is_test&lt;/code&gt; , then you have a bunch of methods at your disposal.</source>
          <target state="translated">이 클래스는 &lt;a href=&quot;../../parser&quot;&gt;TAP :: Parser&lt;/a&gt; 시스템 의 핵심입니다 . 대부분의 TAP 라인은 테스트 라인이 될 것이며 &lt;code&gt;$result-&amp;gt;is_test&lt;/code&gt; 이면 여러 가지 방법을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="77ad00f96e4fc79112ecce425a98459f96769eb3" translate="yes" xml:space="preserve">
          <source>This class is the workhorse of the &lt;a href=&quot;TAP::Parser&quot;&gt;TAP::Parser&lt;/a&gt; system. Most TAP lines will be test lines and if &lt;code&gt;$result-&amp;gt;is_test&lt;/code&gt;, then you have a bunch of methods at your disposal.</source>
          <target state="translated">이 클래스는 &lt;a href=&quot;TAP::Parser&quot;&gt;TAP :: Parser&lt;/a&gt; 시스템 의 핵심입니다 . 대부분의 TAP 라인은 테스트 라인이며 &lt;code&gt;$result-&amp;gt;is_test&lt;/code&gt; 이면 여러 가지 방법을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cb2f9188e79ee28d20f325b48fe2bf4717272a64" translate="yes" xml:space="preserve">
          <source>This class is used to bless perl subs so that they are invoked when they are destroyed. This is mostly useful for ensuring the code is invoked at end of scope. This module is not a part of autodie's public API.</source>
          <target state="translated">이 클래스는 삭제 될 때 호출되도록 펄 서브를 축복하는 데 사용됩니다. 이는 코드가 범위 끝에서 호출되도록하는 데 주로 유용합니다. 이 모듈은 autodie의 공개 API의 일부가 아닙니다.</target>
        </trans-unit>
        <trans-unit id="6f581c5cd9d5c7598c0dcb3ca6436c9bd821c2c4" translate="yes" xml:space="preserve">
          <source>This class might turn out to be a temporary solution, but MM won't go away.</source>
          <target state="translated">이 클래스는 임시 솔루션으로 판명되었지만 MM은 사라지지 않을 것입니다.</target>
        </trans-unit>
        <trans-unit id="24195eb4cea8857a411b60273a35c873f422dbe0" translate="yes" xml:space="preserve">
          <source>This class provides the one constructor, called &lt;code&gt;new&lt;/code&gt; . It takes no parameters:</source>
          <target state="translated">이 클래스는 &lt;code&gt;new&lt;/code&gt; 라는 하나의 생성자를 제공합니다 . 매개 변수가 없습니다.</target>
        </trans-unit>
        <trans-unit id="3cdd607371055ba28bceb9607eba0f99a8092ae1" translate="yes" xml:space="preserve">
          <source>This class provides the one constructor, called &lt;code&gt;new&lt;/code&gt;. It takes no parameters:</source>
          <target state="translated">이 클래스는 &lt;code&gt;new&lt;/code&gt; 라는 하나의 생성자를 제공합니다 . 매개 변수가 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3b0678c7cdb712a22e1337039fd311842e231f0c" translate="yes" xml:space="preserve">
          <source>This class represents a subtest. This class is a subclass of &lt;a href=&quot;Test2::Event::Ok&quot;&gt;Test2::Event::Ok&lt;/a&gt;.</source>
          <target state="translated">이 클래스는 하위 테스트를 나타냅니다. 이 클래스는 &lt;a href=&quot;Test2::Event::Ok&quot;&gt;Test2 :: Event :: Ok&lt;/a&gt; 의 하위 클래스입니다 .</target>
        </trans-unit>
        <trans-unit id="548ad953daf93abd12a978fa239d01a039bfc535" translate="yes" xml:space="preserve">
          <source>This class returns a copy of its input, translated into Perl's internal encoding (UTF-8), and with all the non-Pod lines removed.</source>
          <target state="translated">이 클래스는 Perl의 내부 인코딩 (UTF-8)으로 변환되고 포드가 아닌 모든 행이 제거 된 입력 사본을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="0460fe0f3a1a52c6921164fb6520b6ae745aaf17" translate="yes" xml:space="preserve">
          <source>This class strives to return the Pod lines of the input completely unchanged, except for any necessary translation into Perl's internal encoding, and it makes no effort to return trailing spaces on lines; these likely will be stripped. If the input pod is well-formed with no warnings nor errors generated, the extracted pod should generate the same documentation when formatted by a Pod formatter as the original file does.</source>
          <target state="translated">이 클래스는 Perl의 내부 인코딩으로 필요한 모든 변환을 제외하고는 입력의 Pod 행을 완전히 변경하지 않고 반환하려고 노력하며 행의 후행 공백을 반환하려고 노력하지 않습니다. 이들은 아마도 제거 될 것입니다. 입력 포드가 경고 나 오류가 생성되지 않고 제대로 구성된 경우 추출 된 포드는 원본 파일과 마찬가지로 포드 포맷터로 형식을 지정할 때 동일한 문서를 생성해야합니다.</target>
        </trans-unit>
        <trans-unit id="f30e23715125a3d5360cef7bf3e4022849622110" translate="yes" xml:space="preserve">
          <source>This class takes Pod and parses it, returning a parse tree made just of arrayrefs, and hashrefs, and strings.</source>
          <target state="translated">이 클래스는 Pod를 가져와 구문 분석하여 arrayrefs와 hashrefs 및 string으로 만 구성된 구문 분석 트리를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="9dbee182dfa76d92a94c69cd0858c1622ac2f770" translate="yes" xml:space="preserve">
          <source>This client is more complicated than the two we've done so far, but if you're on a system that supports the powerful &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork&lt;/a&gt;&lt;/code&gt; call, the solution isn't that rough. Once you've made the connection to whatever service you'd like to chat with, call &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork&lt;/a&gt;&lt;/code&gt; to clone your process. Each of these two identical process has a very simple job to do: the parent copies everything from the socket to standard output, while the child simultaneously copies everything from standard input to the socket. To accomplish the same thing using just one process would be</source>
          <target state="translated">이 클라이언트는 지금까지 해왔 던 것보다 더 복잡하지만 강력한 &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork&lt;/a&gt;&lt;/code&gt; 호출 을 지원하는 시스템을 사용하는 경우 솔루션이 그렇게 거칠지 않습니다. 채팅하려는 서비스에 연결되면 &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork&lt;/a&gt;&lt;/code&gt; 를 호출 하여 프로세스를 복제하십시오. 이 두 가지 동일한 프로세스는 매우 간단한 작업을 수행합니다. 부모는 소켓에서 표준 출력으로 모든 것을 복사하고 자식은 표준 입력에서 소켓으로 모든 것을 동시에 복사합니다. 하나의 프로세스 만 사용하여 동일한 작업을 수행하려면</target>
        </trans-unit>
        <trans-unit id="bb7d2aab86d534bfc6e56a8de0ba001be898cbe5" translate="yes" xml:space="preserve">
          <source>This client is more complicated than the two we've done so far, but if you're on a system that supports the powerful &lt;code&gt;fork&lt;/code&gt; call, the solution isn't that rough. Once you've made the connection to whatever service you'd like to chat with, call &lt;code&gt;fork&lt;/code&gt; to clone your process. Each of these two identical process has a very simple job to do: the parent copies everything from the socket to standard output, while the child simultaneously copies everything from standard input to the socket. To accomplish the same thing using just one process would be</source>
          <target state="translated">이 클라이언트는 지금까지 수행 한 두 클라이언트보다 더 복잡하지만 강력한 &lt;code&gt;fork&lt;/code&gt; 호출 을 지원하는 시스템을 사용하는 경우 솔루션은 그렇게 거칠지 않습니다. 채팅하려는 서비스에 연결 한 후에는 &lt;code&gt;fork&lt;/code&gt; 를 호출 하여 프로세스를 복제하십시오. 이 두 가지 동일한 프로세스는 각각 수행 할 작업이 매우 간단합니다. 부모는 소켓에서 표준 출력으로 모든 것을 복사하고 자식은 동시에 표준 입력에서 소켓으로 모든 것을 복사합니다. 하나의 프로세스 만 사용하여 동일한 작업을 수행하려면</target>
        </trans-unit>
        <trans-unit id="ceec53b2ebb7603eb9ee71d9bde01119b83707cb" translate="yes" xml:space="preserve">
          <source>This clones the repository and makes a local copy in the</source>
          <target state="translated">그러면 리포지토리가 복제되고</target>
        </trans-unit>
        <trans-unit id="53ac61605ac32344cb2fde8cb4e762d87b323ee2" translate="yes" xml:space="preserve">
          <source>This code has to jump through a few hoops to achieve this because</source>
          <target state="translated">이 코드는이를 달성하기 위해 몇 가지 후프를 거쳐야합니다.</target>
        </trans-unit>
        <trans-unit id="5330da17cfc7cfcf64aab224d5b574c934e7ac2c" translate="yes" xml:space="preserve">
          <source>This code heavily adapted from an early version of perl5db.pl attributable to Larry Wall and the Perl Porters.</source>
          <target state="translated">이 코드는 Larry Wall 및 Perl Porters에 기인 한 perl5db.pl의 초기 버전에서 크게 수정되었습니다.</target>
        </trans-unit>
        <trans-unit id="20e0786f01d076b98983216819824cb18ece543e" translate="yes" xml:space="preserve">
          <source>This code is derived from software contributed to Berkeley by Guido van Rossum.</source>
          <target state="translated">이 코드는 Guido van Rossum이 Berkeley에 기고 한 소프트웨어에서 파생되었습니다.</target>
        </trans-unit>
        <trans-unit id="847d9232033c7120d3555ace79f29fd71ad7ef18" translate="yes" xml:space="preserve">
          <source>This code is in Github in the CPAN.pm repository:</source>
          <target state="translated">이 코드는 CPAN.pm 저장소의 Github에 있습니다.</target>
        </trans-unit>
        <trans-unit id="11c4fc183eca8652881b1cb5b12c6ea249b79ebe" translate="yes" xml:space="preserve">
          <source>This code is intended for development only, and may not be portable even to all Unix variants. Also, it is an 80% solution, in that it isn't able to make all ops read only. Specifically it does not apply to op slabs belonging to &lt;code&gt;BEGIN&lt;/code&gt; blocks.</source>
          <target state="translated">이 코드는 개발만을 목적으로하며 모든 유닉스 변종에도 이식 가능하지 않을 수 있습니다. 또한 모든 op를 읽기 전용으로 만들 수 없다는 점에서 80 % 솔루션입니다. 특히 &lt;code&gt;BEGIN&lt;/code&gt; 블록에 속하는 연산 슬래브에는 적용되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="4a8e4db5444d8620ae9620bb90f970a958584613" translate="yes" xml:space="preserve">
          <source>This code is unusual in that it should have no content. That is, a processor may complain if it sees &lt;code&gt;Z&amp;lt;potatoes&amp;gt;&lt;/code&gt;. Whether or not it complains, the</source>
          <target state="translated">이 코드는 내용이 없어야한다는 점에서 특이합니다. 즉, 프로세서가 &lt;code&gt;Z&amp;lt;potatoes&amp;gt;&lt;/code&gt; 보면 불평 할 수 있습니다 . 불평하든 안하든</target>
        </trans-unit>
        <trans-unit id="443071b2d9d382ee44392d30a6c9cc6944390654" translate="yes" xml:space="preserve">
          <source>This code is unusual in that most formatters completely discard this code and its content. Other formatters will render it with invisible codes that can be used in building an index of the current document.</source>
          <target state="translated">이 코드는 대부분의 포맷터가이 코드와 그 내용을 완전히 버린다는 점에서 특이합니다. 다른 포맷터는 현재 문서의 색인을 작성하는 데 사용할 수있는 보이지 않는 코드로 렌더링합니다.</target>
        </trans-unit>
        <trans-unit id="ed77ac1105bfebc895982f70abdb5f07d0f61471" translate="yes" xml:space="preserve">
          <source>This code is unusual is that it should have no content. That is, a processor may complain if it sees &lt;code&gt;Z&amp;lt;potatoes&amp;gt;&lt;/code&gt; . Whether or not it complains, the</source>
          <target state="translated">이 코드는 내용이 없어야한다는 것이 일반적입니다. 즉, 프로세서가 &lt;code&gt;Z&amp;lt;potatoes&amp;gt;&lt;/code&gt; 보게되면 불만을 제기 할 수 있습니다 . 불평 여부에 관계없이</target>
        </trans-unit>
        <trans-unit id="9f748555f0c218e80f371f8622c90719bdf4c3e1" translate="yes" xml:space="preserve">
          <source>This code resides primarily in</source>
          <target state="translated">이 코드는 주로</target>
        </trans-unit>
        <trans-unit id="b4ca79218fad07abe234bb2cecfbf2b9daaa8186" translate="yes" xml:space="preserve">
          <source>This code tries to return a new SV (which contains the value 42) if it should return a real value, or undef otherwise. Instead it has returned a NULL pointer which, somewhere down the line, will cause a segmentation violation, bus error, or just weird results. Change the zero to &lt;code&gt;&amp;amp;PL_sv_undef&lt;/code&gt; in the first line and all will be well.</source>
          <target state="translated">이 코드는 실제 값을 반환해야하는 경우 새 SV (값 42 포함)를 반환하거나 그렇지 않으면 undef를 시도합니다. 대신 널 어딘가에서 NULL 위반을 반환하여 세그먼트 위반, 버스 오류 또는 이상한 결과를 초래할 수 있습니다. 0을 &lt;code&gt;&amp;amp;PL_sv_undef&lt;/code&gt; 변경하십시오.첫 번째 줄에서 로 모두 입니다.</target>
        </trans-unit>
        <trans-unit id="706270f16eed93ab30bcb6ac5dad9c206e0d53d4" translate="yes" xml:space="preserve">
          <source>This code will behave identically under both &lt;code&gt;IO::Socket::INET&lt;/code&gt; and &lt;code&gt;IO::Socket::IP&lt;/code&gt;.</source>
          <target state="translated">이 코드는 &lt;code&gt;IO::Socket::INET&lt;/code&gt; 및 &lt;code&gt;IO::Socket::IP&lt;/code&gt; 모두에서 동일하게 작동합니다 .</target>
        </trans-unit>
        <trans-unit id="6b0496da28a3ec6a32260558d3028edcf275c0a4" translate="yes" xml:space="preserve">
          <source>This combination of options may also be specified thus</source>
          <target state="translated">이러한 옵션 조합은 다음과 같이 지정할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="738a4e0887c40771b0a61f4f0df6d45e56b8d5cf" translate="yes" xml:space="preserve">
          <source>This combination performs the work of the legacy functions gethostbyname() and inet_ntoa().</source>
          <target state="translated">이 조합은 레거시 함수 gethostbyname () 및 inet_ntoa ()의 작업을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="72e5e8c3a2d9fab681c4b573c92998cd66dd340c" translate="yes" xml:space="preserve">
          <source>This command indicates that an item in a list begins here. Formatting codes are processed. The semantics of the (optional) text in the remainder of this paragraph are explained in the &lt;a href=&quot;#About-%3Dover...%3Dback-Regions&quot;&gt;&quot;About =over...=back Regions&quot;&lt;/a&gt; section, further below. Examples:</source>
          <target state="translated">이 명령은 목록의 항목이 여기에서 시작 함을 나타냅니다. 형식화 코드가 처리됩니다. 이 단락의 나머지 부분에있는 (선택 사항) 텍스트의 의미는 아래의 &lt;a href=&quot;#About-%3Dover...%3Dback-Regions&quot;&gt;&quot;= over ... = back 영역 정보&quot;&lt;/a&gt; 섹션에 설명되어 있습니다. 예 :</target>
        </trans-unit>
        <trans-unit id="d728ee6330c55e20ceb083fe7c0710810e2932ca" translate="yes" xml:space="preserve">
          <source>This command indicates that an item in a list begins here. Formatting codes are processed. The semantics of the (optional) text in the remainder of this paragraph are explained in the &lt;a href=&quot;#About-%3dover...%3dback-Regions&quot;&gt;About =over...=back Regions&lt;/a&gt; section, further below. Examples:</source>
          <target state="translated">이 명령은 목록의 항목이 여기에서 시작됨을 나타냅니다. 포맷팅 코드가 처리됩니다. 이 단락의 나머지 부분에서 (선택적) 텍스트의 의미는 아래에 대한 &lt;a href=&quot;#About-%3dover...%3dback-Regions&quot;&gt;About = over ... = back Regions&lt;/a&gt; 섹션에 설명되어 있습니다. 예 :</target>
        </trans-unit>
        <trans-unit id="4a355ff290cc8d5e2710e8069a06d654602bb061" translate="yes" xml:space="preserve">
          <source>This command indicates that the text in the remainder of the paragraph is a heading. That text may contain formatting codes. Examples:</source>
          <target state="translated">이 명령은 나머지 단락의 텍스트가 제목임을 나타냅니다. 해당 텍스트에는 서식 코드가 포함될 수 있습니다. 예 :</target>
        </trans-unit>
        <trans-unit id="c6da60e4854fba0e9da1ba094a38fc435654e60e" translate="yes" xml:space="preserve">
          <source>This command indicates that this is the end of the region begun by the most recent &quot;=over&quot; command. It permits no text after the &quot;=back&quot; command.</source>
          <target state="translated">이 명령은 이것이 가장 최근의 &quot;= over&quot;명령으로 시작된 영역의 끝임을 나타냅니다. &quot;= back&quot;명령 뒤에 텍스트를 허용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="91bf180a009e30184b54f49645009694bbe3b151" translate="yes" xml:space="preserve">
          <source>This command indicates that this is the start of a list/indent region. If there is any text following the &quot;=over&quot;, it must consist of only a nonzero positive numeral. The semantics of this numeral is explained in the &lt;a href=&quot;#About-%3Dover...%3Dback-Regions&quot;&gt;&quot;About =over...=back Regions&quot;&lt;/a&gt; section, further below. Formatting codes are not expanded. Examples:</source>
          <target state="translated">이 명령은 이것이 목록 / 들여 쓰기 영역의 시작임을 나타냅니다. &quot;= over&quot;뒤에 텍스트가 있으면 0이 아닌 양수로만 구성되어야합니다. 이 숫자의 의미는 아래의 &lt;a href=&quot;#About-%3Dover...%3Dback-Regions&quot;&gt;&quot;= over ... = back 영역 정보&quot;&lt;/a&gt; 섹션에 설명되어 있습니다. 서식 코드는 확장되지 않습니다. 예 :</target>
        </trans-unit>
        <trans-unit id="19be29c945bbd16c098b73b780bb343e863492ff" translate="yes" xml:space="preserve">
          <source>This command indicates that this is the start of a list/indent region. If there is any text following the &quot;=over&quot;, it must consist of only a nonzero positive numeral. The semantics of this numeral is explained in the &lt;a href=&quot;#About-%3dover...%3dback-Regions&quot;&gt;About =over...=back Regions&lt;/a&gt; section, further below. Formatting codes are not expanded. Examples:</source>
          <target state="translated">이 명령은 이것이 목록 / 들여 쓰기 영역의 시작임을 나타냅니다. &quot;= over&quot;뒤에 텍스트가 있으면 0이 아닌 양수로만 구성되어야합니다. 이 숫자의 의미는 아래 의 &lt;a href=&quot;#About-%3dover...%3dback-Regions&quot;&gt;About = over ... = back Regions&lt;/a&gt; 섹션에 설명되어 있습니다. 서식 코드가 확장되지 않습니다. 예 :</target>
        </trans-unit>
        <trans-unit id="7ff4d3408bd7bdb5ab335d1f0aa8564e21d93c8d" translate="yes" xml:space="preserve">
          <source>This command indicates that this line is the end of this previously started Pod block. If there is any text after &quot;=cut&quot; on the line, it must be ignored. Examples:</source>
          <target state="translated">이 명령은이 줄이 이전에 시작된 포드 블록의 끝임을 나타냅니다. 줄에 &quot;= cut&quot;다음에 텍스트가 있으면 무시해야합니다. 예 :</target>
        </trans-unit>
        <trans-unit id="3f41d49fdd2a10822f19964c9959582847611ffe" translate="yes" xml:space="preserve">
          <source>This command indicates that this paragraph begins a Pod block. (If we are already in the middle of a Pod block, this command has no effect at all.) If there is any text in this command paragraph after &quot;=pod&quot;, it must be ignored. Examples:</source>
          <target state="translated">이 명령은이 단락이 Pod 블록을 시작 함을 나타냅니다. (이미 Pod 블록의 중간에 있다면이 명령은 전혀 효과가 없습니다.) &quot;= pod&quot;다음에이 명령 단락에 텍스트가 있으면 무시해야합니다. 예 :</target>
        </trans-unit>
        <trans-unit id="8a99ea1513aed41e6edc9e12797ae7dfeaac42f6" translate="yes" xml:space="preserve">
          <source>This command is used for declaring the encoding of a document. Most users won't need this; but if your encoding isn't US-ASCII, then put a &lt;code&gt;=encoding &lt;i&gt;encodingname&lt;/i&gt;&lt;/code&gt; command very early in the document so that pod formatters will know how to decode the document. For</source>
          <target state="translated">이 명령은 문서의 인코딩을 선언하는 데 사용됩니다. 대부분의 사용자는 이것을 필요로하지 않습니다. 그러나 인코딩이 US-ASCII가 아닌 경우 문서의 초기에 &lt;code&gt;=encoding &lt;i&gt;encodingname&lt;/i&gt;&lt;/code&gt; 명령 을 입력하면 포드 포맷터가 문서를 디코딩하는 방법을 알 수 있습니다. 에 대한</target>
        </trans-unit>
        <trans-unit id="57e6471f2b7a0cc0bc2732ccfe6cc2a1d67b9a5e" translate="yes" xml:space="preserve">
          <source>This command will fail only if you pass it an address in a domain the server directly delivers for, and that address does not exist.</source>
          <target state="translated">이 명령은 서버가 직접 전달하는 도메인의 주소를 전달하고 해당 주소가 존재하지 않는 경우에만 실패합니다.</target>
        </trans-unit>
        <trans-unit id="2f65eb1b23b31e9c4fc56a4656f09eda25784a44" translate="yes" xml:space="preserve">
          <source>This command will produce as output a description of the current state of the repository, including modified files and unignored untracked files, and in addition it will show things like what files have been staged for the next commit, and usually some useful information about how to change things. For instance the following:</source>
          <target state="translated">이 명령은 수정 된 파일 및 추적되지 않은 추적되지 않은 파일을 포함하여 저장소의 현재 상태에 대한 설명을 출력으로 생성하고, 추가로 다음 커밋을 위해 준비된 파일과 일반적으로 방법에 대한 유용한 정보를 보여줍니다. 물건을 바꾸십시오. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="cc900c104077e4a6a7ca5f06e5d70661d00910f9" translate="yes" xml:space="preserve">
          <source>This command, which should occur early in the document (at least before any non-US-ASCII data!), declares that this document is encoded in the encoding</source>
          <target state="translated">문서의 초기 (최소한 US-ASCII 이외의 데이터 이전)에서 발생해야하는이 명령은이 문서가 인코딩으로 인코딩되었음을 선언합니다.</target>
        </trans-unit>
        <trans-unit id="a044d113549cfc62bab49938c5d884a6268cf948" translate="yes" xml:space="preserve">
          <source>This commands provides a statistical overview over recent download activities. The data for this is collected in the YAML file &lt;code&gt;FTPstats.yml&lt;/code&gt; in your &lt;code&gt;cpan_home&lt;/code&gt; directory. If no YAML module is configured or YAML not installed, no stats are provided.</source>
          <target state="translated">이 명령은 최근 다운로드 활동에 대한 통계 개요를 제공합니다. 이에 대한 데이터는 &lt;code&gt;cpan_home&lt;/code&gt; 디렉토리 의 YAML 파일 &lt;code&gt;FTPstats.yml&lt;/code&gt; 에 수집됩니다 . YAML 모듈이 구성되어 있지 않거나 YAML이 설치되지 않은 경우 통계가 제공되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8ea20acdc8121360e07a3ca6ca2abb72ed9a4374" translate="yes" xml:space="preserve">
          <source>This compiler backend prints the internal OPs of a Perl program's syntax tree in one of several space-efficient text formats suitable for debugging the inner workings of perl or other compiler backends. It can print OPs in the order they appear in the OP tree, in the order they will execute, or in a text approximation to their tree structure, and the format of the information displayed is customizable. Its function is similar to that of perl's &lt;b&gt;-Dx&lt;/b&gt; debugging flag or the &lt;b&gt;B::Terse&lt;/b&gt; module, but it is more sophisticated and flexible.</source>
          <target state="translated">이 컴파일러 백엔드는 Perl 또는 다른 컴파일러 백엔드의 내부 작업을 디버깅하는 데 적합한 몇 가지 공간 효율적인 텍스트 형식 중 하나로 Perl 프로그램 구문 트리의 내부 OP를 인쇄합니다. OP 트리에 표시되는 순서, 실행 순서 또는 트리 구조와 유사한 텍스트로 OP를 인쇄 할 수 있으며 표시되는 정보의 형식을 사용자 정의 할 수 있습니다. 이 기능은 perl의 &lt;b&gt;-Dx&lt;/b&gt; 디버깅 플래그 또는 &lt;b&gt;B :: Terse&lt;/b&gt; 모듈과 유사하지만보다 정교하고 유연합니다.</target>
        </trans-unit>
        <trans-unit id="66cedc315e88b39d6383c0d5ddbb722e7566fdc1" translate="yes" xml:space="preserve">
          <source>This compiler is typically run by the makefiles created by &lt;a href=&quot;ExtUtils::MakeMaker&quot;&gt;ExtUtils::MakeMaker&lt;/a&gt; or by &lt;a href=&quot;Module::Build&quot;&gt;Module::Build&lt;/a&gt; or other Perl module build tools.</source>
          <target state="translated">이 컴파일러는 일반적으로 &lt;a href=&quot;ExtUtils::MakeMaker&quot;&gt;ExtUtils :: MakeMaker&lt;/a&gt; 또는 &lt;a href=&quot;Module::Build&quot;&gt;Module :: Build&lt;/a&gt; 또는 기타 Perl 모듈 빌드 도구에 의해 생성 된 메이크 파일에 의해 실행됩니다 .</target>
        </trans-unit>
        <trans-unit id="49048e5c36c04df148e3cdcc3f896c82e8922e40" translate="yes" xml:space="preserve">
          <source>This compiler is typically run by the makefiles created by &lt;a href=&quot;extutils/makemaker&quot;&gt;ExtUtils::MakeMaker&lt;/a&gt; or by &lt;a href=&quot;http://search.cpan.org/perldoc/Module::Build&quot;&gt;Module::Build&lt;/a&gt; or other Perl module build tools.</source>
          <target state="translated">이 컴파일러는 일반적으로 &lt;a href=&quot;extutils/makemaker&quot;&gt;ExtUtils :: MakeMaker&lt;/a&gt; 또는 &lt;a href=&quot;http://search.cpan.org/perldoc/Module::Build&quot;&gt;Module :: Build&lt;/a&gt; 또는 기타 Perl 모듈 빌드 도구로 작성된 makefile에 의해 실행됩니다 .</target>
        </trans-unit>
        <trans-unit id="bcbcc146e176c69e94f98d46491b2b165f6959c5" translate="yes" xml:space="preserve">
          <source>This completely resets the incremental parser, that is, after this call, it will be as if the parser had never parsed anything.</source>
          <target state="translated">이렇게하면 증분 구문 분석기가 완전히 재설정됩니다. 즉,이 호출 후에는 구문 분석기가 아무 것도 구문 분석하지 않은 것처럼 보입니다.</target>
        </trans-unit>
        <trans-unit id="811fc2387a18f3ccb2c99535bb74afa37f5a7e14" translate="yes" xml:space="preserve">
          <source>This condition is called a deadlock, and it occurs whenever two or more threads are trying to get locks on resources that the others own. Each thread will block, waiting for the other to release a lock on a resource. That never happens, though, since the thread with the resource is itself waiting for a lock to be released.</source>
          <target state="translated">이 상태를 교착 상태라고하며 둘 이상의 스레드가 다른 스레드가 소유 한 자원에 대한 잠금을 얻으려고 할 때마다 발생합니다. 각 스레드는 차단되어 다른 스레드가 리소스에 대한 잠금을 해제 할 때까지 기다립니다. 그러나 리소스가있는 스레드 자체가 잠금이 해제되기를 기다리고 있기 때문에 결코 발생하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="faa53aa7f128fff59cd7dcb34623ce5e613b1979" translate="yes" xml:space="preserve">
          <source>This conditionally defines &lt;code&gt;HAS_BUILTIN_CHOOSE_EXPR&lt;/code&gt; , which indicates that the compiler supports __builtin_choose_expr(x,y,z). This built-in function is analogous to the &lt;code&gt;x?y:z&lt;/code&gt; operator in C, except that the expression returned has its type unaltered by promotion rules. Also, the built-in function does not evaluate the expression that was not chosen.</source>
          <target state="translated">이것은 조건부로 &lt;code&gt;HAS_BUILTIN_CHOOSE_EXPR&lt;/code&gt; 을 정의합니다 . 이는 컴파일러가 __builtin_choose_expr (x, y, z)를 지원함을 나타냅니다. 이 내장 함수는 C 의 &lt;code&gt;x?y:z&lt;/code&gt; 연산자와 유사하지만 반환 된 표현식의 유형은 승격 규칙에 따라 변경되지 않습니다. 또한 내장 함수는 선택되지 않은 표현식을 평가하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="32d20e57f63d06cdf92bb912dada7350665e3c8b" translate="yes" xml:space="preserve">
          <source>This conditionally defines &lt;code&gt;HAS_BUILTIN_CHOOSE_EXPR&lt;/code&gt;, which indicates that the compiler supports __builtin_choose_expr(x,y,z). This built-in function is analogous to the &lt;code&gt;x?y:z&lt;/code&gt; operator in C, except that the expression returned has its type unaltered by promotion rules. Also, the built-in function does not evaluate the expression that was not chosen.</source>
          <target state="translated">이는 컴파일러가 __builtin_choose_expr (x, y, z)를 지원함을 나타내는 &lt;code&gt;HAS_BUILTIN_CHOOSE_EXPR&lt;/code&gt; 을 조건부로 정의합니다 . 이 내장 함수는 리턴 된 표현식에 승격 규칙에 의해 변경되지 않은 유형이 있다는 점을 제외하면 C 의 &lt;code&gt;x?y:z&lt;/code&gt; 연산자와 유사합니다 . 또한 내장 함수는 선택되지 않은 표현식을 평가하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8177d32c94f6808dc1bba5e1e003e2e654d1454a" translate="yes" xml:space="preserve">
          <source>This conditionally defines &lt;code&gt;HAS_BUILTIN_EXPECT&lt;/code&gt; , which indicates that the compiler supports __builtin_expect(exp,c). You may use __builtin_expect to provide the compiler with branch prediction information.</source>
          <target state="translated">이것은 조건부로 &lt;code&gt;HAS_BUILTIN_EXPECT&lt;/code&gt; 를 정의 하는데 , 이는 컴파일러가 __builtin_expect (exp, c)를 지원함을 나타냅니다. __builtin_expect를 사용하여 분기 예측 정보를 컴파일러에 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="18781d872ee7a71c6a67e62943c1d602bc39dcb9" translate="yes" xml:space="preserve">
          <source>This conditionally defines &lt;code&gt;HAS_BUILTIN_EXPECT&lt;/code&gt;, which indicates that the compiler supports __builtin_expect(exp,c). You may use __builtin_expect to provide the compiler with branch prediction information.</source>
          <target state="translated">이는 컴파일러가 __builtin_expect (exp, c)를 지원함을 나타내는 &lt;code&gt;HAS_BUILTIN_EXPECT&lt;/code&gt; 를 조건부로 정의합니다 . __builtin_expect를 사용하여 컴파일러에 분기 예측 정보를 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3e85ff206a230f535cdc1e1b660d9e31b004675c" translate="yes" xml:space="preserve">
          <source>This construct cannot be used within the scope of &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; (or the &lt;code&gt;/l&lt;/code&gt; regex modifier).</source>
          <target state="translated">이 구조는 범위 내에서 사용할 수없는 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; (또는 &lt;code&gt;/l&lt;/code&gt; 의 정규식 개질제).</target>
        </trans-unit>
        <trans-unit id="7feaf5d14c2affa83679ada3f6337ec8bf394406" translate="yes" xml:space="preserve">
          <source>This construct is a Perl expression.</source>
          <target state="translated">이 구조는 Perl 표현식입니다.</target>
        </trans-unit>
        <trans-unit id="f54050082dcc8b4fbf44ab08f61165f7a87bfb06" translate="yes" xml:space="preserve">
          <source>This construct is a complete Perl statement. (No semicolon should follow the closing brace.)</source>
          <target state="translated">이 구조는 완전한 Perl 문입니다. (세미콜론은 닫는 중괄호 뒤에 올 수 없습니다.)</target>
        </trans-unit>
        <trans-unit id="9f08b82a682504266e85cc2574b23244cf7a9af7" translate="yes" xml:space="preserve">
          <source>This construct is non-capturing. You can add parentheses to</source>
          <target state="translated">이 구조는 캡처되지 않습니다. 괄호를 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f8fed69726a17c92a263e748b2d7fa3336a3e37f" translate="yes" xml:space="preserve">
          <source>This construct is useful when you want to capture one of a number of alternative matches.</source>
          <target state="translated">이 구성은 여러 대체 일치 중 하나를 캡처하려는 경우에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="89cfaa9b31ac24d949cb1a2ef0db748a527694e4" translate="yes" xml:space="preserve">
          <source>This construction is</source>
          <target state="translated">이 건축은</target>
        </trans-unit>
        <trans-unit id="78c7683a763192abf9645014c7b058753006e735" translate="yes" xml:space="preserve">
          <source>This constructor lets its parent class do the actual object construction.</source>
          <target state="translated">이 생성자는 부모 클래스가 실제 객체 구성을 수행하도록합니다.</target>
        </trans-unit>
        <trans-unit id="221e3f3f658bcd2c65eb9bb5043326230edb5f59" translate="yes" xml:space="preserve">
          <source>This constructor returns a new HTTP::Tiny object. Valid attributes include:</source>
          <target state="translated">이 생성자는 새로운 HTTP :: Tiny 객체를 반환합니다. 유효한 속성은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4bf27879428ff426e547cd9ab897b5c2de43f4ae" translate="yes" xml:space="preserve">
          <source>This constructs a language handle. You usually &lt;b&gt;don't&lt;/b&gt; call this directly, but instead let &lt;code&gt;get_handle&lt;/code&gt; find a language class to &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; and to then call -&amp;gt;new on.</source>
          <target state="translated">이것은 언어 핸들을 구성합니다. 일반적으로 이것을 직접 호출 &lt;b&gt;하지는 않지만 &lt;/b&gt; &lt;code&gt;get_handle&lt;/code&gt; 이 &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 언어 클래스 를 찾은 다음-&amp;gt; new on을 호출하게하십시오.</target>
        </trans-unit>
        <trans-unit id="7de3cef882fe04932a0a01ad2c579e42f49a5693" translate="yes" xml:space="preserve">
          <source>This constructs a language handle. You usually &lt;b&gt;don't&lt;/b&gt; call this directly, but instead let &lt;code&gt;get_handle&lt;/code&gt; find a language class to &lt;code&gt;use&lt;/code&gt; and to then call -&amp;gt;new on.</source>
          <target state="translated">이것은 언어 핸들을 구성합니다. 일반적으로 이것을 직접 호출 &lt;b&gt;하지 않고&lt;/b&gt; 대신 &lt;code&gt;get_handle&lt;/code&gt; 이 &lt;code&gt;use&lt;/code&gt; 언어 클래스 를 찾은 다음-&amp;gt; new on을 호출하도록합니다.</target>
        </trans-unit>
        <trans-unit id="753e5c4d4e4edeead3be592de94817a6410aff17" translate="yes" xml:space="preserve">
          <source>This contains a list of directories, separated by colons. The entire list is prepended to &lt;code&gt;@INC&lt;/code&gt; in one go. This:</source>
          <target state="translated">여기에는 콜론으로 구분 된 디렉토리 목록이 포함됩니다. 전체 목록은 한 번 에 &lt;code&gt;@INC&lt;/code&gt; 앞에 추가됩니다 . 이:</target>
        </trans-unit>
        <trans-unit id="81b45e36338257a29107f2604a1399d771205b40" translate="yes" xml:space="preserve">
          <source>This contains a space separated list of switches. We only consider the effects of &lt;code&gt;-M&lt;/code&gt; and &lt;code&gt;-I&lt;/code&gt; in this section.</source>
          <target state="translated">여기에는 공백으로 구분 된 스위치 목록이 포함됩니다. 이 섹션에서는 &lt;code&gt;-M&lt;/code&gt; 및 &lt;code&gt;-I&lt;/code&gt; 의 효과 만 고려합니다 .</target>
        </trans-unit>
        <trans-unit id="a3f30289e8821786015ec39ecff118638d73ac1e" translate="yes" xml:space="preserve">
          <source>This contains a textual description of the field.</source>
          <target state="translated">여기에는 필드에 대한 텍스트 설명이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="df9999edc7b466975d9df29327a002bca6f3a58f" translate="yes" xml:space="preserve">
          <source>This contains information about the event itself such as the event package name. The &lt;code&gt;details&lt;/code&gt; field for this facet is an overall summary of the event.</source>
          <target state="translated">여기에는 이벤트 패키지 이름과 같은 이벤트 자체에 대한 정보가 포함됩니다. 이 패싯 의 &lt;code&gt;details&lt;/code&gt; 필드는 이벤트의 전체 요약입니다.</target>
        </trans-unit>
        <trans-unit id="5e5ca9139234bfdd98010f7db0884779bff191ff" translate="yes" xml:space="preserve">
          <source>This contains the offset from the start of the file in hex.</source>
          <target state="translated">여기에는 16 진수로 된 파일 시작부터의 오프셋이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="3edc7f7dd753392a74ab3c329050e0ec08dcdba9" translate="yes" xml:space="preserve">
          <source>This controls how verbose to be during batch conversion, as far as notes to STDOUT (or whatever is &lt;code&gt;&lt;a href=&quot;../../functions/select&quot;&gt;select&lt;/a&gt;&lt;/code&gt;'d) about how the conversion is going. If 0, no progress information is printed. If 1 (the default value), some progress information is printed. Higher values print more information.</source>
          <target state="translated">이것은 변환이 진행되는 방법에 대한 STDOUT (또는 &lt;code&gt;&lt;a href=&quot;../../functions/select&quot;&gt;select&lt;/a&gt;&lt;/code&gt; 'd)에 대한 메모까지 배치 변환 중 자세한 표시 방법을 제어합니다 . 0이면 진행 정보가 인쇄되지 않습니다. 1 (기본값)이면 일부 진행 정보가 인쇄됩니다. 값이 클수록 더 많은 정보가 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="e9775b2b0eddb211aedfd45019b3edf6207e64a9" translate="yes" xml:space="preserve">
          <source>This controls how verbose to be during batch conversion, as far as notes to STDOUT (or whatever is &lt;code&gt;select&lt;/code&gt;'d) about how the conversion is going. If 0, no progress information is printed. If 1 (the default value), some progress information is printed. Higher values print more information.</source>
          <target state="translated">이것은 변환이 어떻게 진행되는지에 대해 STDOUT (또는 'd를 &lt;code&gt;select&lt;/code&gt; 하는 것)에 대한 메모까지 일괄 변환 중에 얼마나 장황한 지 제어합니다 . 0이면 진행 정보가 인쇄되지 않습니다. 1 (기본값)이면 일부 진행 정보가 인쇄됩니다. 값이 높을수록 더 많은 정보가 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="ff7a4f63a01fbc1cdd9d161f843ad25c0052f17f" translate="yes" xml:space="preserve">
          <source>This controls whether &lt;code&gt;Module::Load::Conditional&lt;/code&gt; checks if a dual-life core module has been deprecated. If this is set to true &lt;code&gt;check_install&lt;/code&gt; will return false to &lt;code&gt;uptodate&lt;/code&gt; , if a dual-life module is found to be loaded from &lt;code&gt;$Config{privlibexp}&lt;/code&gt;</source>
          <target state="translated">이는 &lt;code&gt;Module::Load::Conditional&lt;/code&gt; 이 이중 수명 코어 모듈이 더 이상 사용되지 않는지 여부를 제어합니다 . 이 true로 설정되어있는 경우 &lt;code&gt;check_install&lt;/code&gt; 에 false를 돌려줍니다 &lt;code&gt;uptodate&lt;/code&gt; 이중 생활 모듈에서로드 발견되면, &lt;code&gt;$Config{privlibexp}&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f473e55e3f05fdf8b7207839e3e128669c6830a4" translate="yes" xml:space="preserve">
          <source>This controls whether &lt;code&gt;Module::Load::Conditional&lt;/code&gt; checks if a dual-life core module has been deprecated. If this is set to true &lt;code&gt;check_install&lt;/code&gt; will return false to &lt;code&gt;uptodate&lt;/code&gt;, if a dual-life module is found to be loaded from &lt;code&gt;$Config{privlibexp}&lt;/code&gt;</source>
          <target state="translated">이것은 &lt;code&gt;Module::Load::Conditional&lt;/code&gt; 이 이중 수명 코어 모듈이 더 이상 사용되지 않는지 확인하는지 여부를 제어합니다 . 이 true로 설정되어있는 경우 &lt;code&gt;check_install&lt;/code&gt; 에 false를 돌려줍니다 &lt;code&gt;uptodate&lt;/code&gt; 이중 생활 모듈에서로드 발견되면, &lt;code&gt;$Config{privlibexp}&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8b4114328d4769af34ebf3741b18df472503df04" translate="yes" xml:space="preserve">
          <source>This controls whether &lt;code&gt;Module::Load::Conditional&lt;/code&gt; checks your &lt;code&gt;%INC&lt;/code&gt; hash to see if a module is available. By default, only &lt;code&gt;@INC&lt;/code&gt; is scanned to see if a module is physically on your filesystem, or available via an &lt;code&gt;@INC-hook&lt;/code&gt; . Setting this variable to &lt;code&gt;true&lt;/code&gt; will trust any entries in &lt;code&gt;%INC&lt;/code&gt; and return them for you.</source>
          <target state="translated">이것은 &lt;code&gt;Module::Load::Conditional&lt;/code&gt; 이 &lt;code&gt;%INC&lt;/code&gt; 해시를 검사하여 모듈을 사용할 수 있는지 여부를 제어합니다 . 기본적으로 &lt;code&gt;@INC&lt;/code&gt; 만 검사하여 모듈이 실제로 파일 시스템에 있는지 또는 &lt;code&gt;@INC-hook&lt;/code&gt; 통해 사용할 수 있는지 확인합니다 . 이 변수를 &lt;code&gt;true&lt;/code&gt; 로 설정하면 &lt;code&gt;%INC&lt;/code&gt; 모든 항목을 신뢰 하고 대신 반환합니다.</target>
        </trans-unit>
        <trans-unit id="f4a2bb6249279fc9e40ac723ad2544e4cf6f2b93" translate="yes" xml:space="preserve">
          <source>This controls whether &lt;code&gt;Module::Load::Conditional&lt;/code&gt; checks your &lt;code&gt;%INC&lt;/code&gt; hash to see if a module is available. By default, only &lt;code&gt;@INC&lt;/code&gt; is scanned to see if a module is physically on your filesystem, or available via an &lt;code&gt;@INC-hook&lt;/code&gt;. Setting this variable to &lt;code&gt;true&lt;/code&gt; will trust any entries in &lt;code&gt;%INC&lt;/code&gt; and return them for you.</source>
          <target state="translated">이것은 &lt;code&gt;Module::Load::Conditional&lt;/code&gt; 이 &lt;code&gt;%INC&lt;/code&gt; 해시를 검사하여 모듈을 사용할 수 있는지 여부를 제어합니다 . 기본적 으로 모듈이 물리적으로 파일 시스템에 있는지 또는 &lt;code&gt;@INC-hook&lt;/code&gt; 통해 사용 가능한지 확인하기 위해 &lt;code&gt;@INC&lt;/code&gt; 만 스캔됩니다 . 이 변수를 &lt;code&gt;true&lt;/code&gt; 로 설정하면 &lt;code&gt;%INC&lt;/code&gt; 모든 항목을 신뢰 하고 반환합니다.</target>
        </trans-unit>
        <trans-unit id="9c3ce0db041dad858d8e24ff2601618761d3793d" translate="yes" xml:space="preserve">
          <source>This controls whether &lt;code&gt;Module::Load::Conditional&lt;/code&gt; sanitises &lt;code&gt;@INC&lt;/code&gt; by removing &quot;&lt;code&gt;.&lt;/code&gt;&quot;. The current default setting is &lt;code&gt;0&lt;/code&gt;, but this may change in a future release.</source>
          <target state="translated">여부를이 컨트롤 &lt;code&gt;Module::Load::Conditional&lt;/code&gt; sanitises &lt;code&gt;@INC&lt;/code&gt; 제거 &quot;에 의해 &lt;code&gt;.&lt;/code&gt; &quot;. 현재 기본 설정은 &lt;code&gt;0&lt;/code&gt; 이지만 향후 릴리스에서 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9c4381fad7d89f422c37ccba3ee1b2f92eba8443" translate="yes" xml:space="preserve">
          <source>This controls whether IPC::Cmd will print any output from the commands to the screen or not. The default is 0.</source>
          <target state="translated">이것은 IPC :: Cmd가 명령의 출력을 화면에 인쇄할지 여부를 제어합니다. 기본값은 0입니다.</target>
        </trans-unit>
        <trans-unit id="c156076360b54f8a8977c57dc77de47486be1ac3" translate="yes" xml:space="preserve">
          <source>This controls whether Module::Load::Conditional will issue warnings and explanations as to why certain things may have failed. If you set it to 0, Module::Load::Conditional will not output any warnings. The default is 0;</source>
          <target state="translated">이것은 Module :: Load :: Conditional이 특정 문제가 발생한 이유에 대한 경고 및 설명을 발행할지 여부를 제어합니다. 0으로 설정하면 Module :: Load :: Conditional은 경고를 출력하지 않습니다. 기본값은 0입니다.</target>
        </trans-unit>
        <trans-unit id="b49fb12849ceb3c435af21ba21b9e8d24214fd70" translate="yes" xml:space="preserve">
          <source>This controls whether Module::Load::Conditional will try to parse (and eval) the version from the module you're trying to load.</source>
          <target state="translated">이것은 Module :: Load :: Conditional이로드하려는 모듈에서 버전을 구문 분석 (및 평가)할지 여부를 제어합니다.</target>
        </trans-unit>
        <trans-unit id="d9aae25fb78fe9990ffb44145098a21f55aa720e" translate="yes" xml:space="preserve">
          <source>This controls whether Params::Check will issue warnings and explanations as to why certain things may have failed. If you set it to 0, Params::Check will not output any warnings.</source>
          <target state="translated">이는 Params :: Check가 특정 문제가 발생한 이유에 대한 경고 및 설명을 발행할지 여부를 제어합니다. 0으로 설정하면 Params :: Check가 경고를 출력하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a6e244d9b4c4b3e3b7164ac6b7f4cae7e7da9c75" translate="yes" xml:space="preserve">
          <source>This controls whether all output of a command should also be printed to STDOUT/STDERR or should only be trapped in buffers (NOTE: buffers require &lt;a href=&quot;IPC::Run&quot;&gt;IPC::Run&lt;/a&gt; to be installed, or your system able to work with &lt;a href=&quot;IPC::Open3&quot;&gt;IPC::Open3&lt;/a&gt;).</source>
          <target state="translated">이는 명령의 모든 출력이 STDOUT / STDERR에도 인쇄되어야하는지 아니면 버퍼에만 트랩되어야하는지 여부를 제어합니다 (참고 : 버퍼를 설치하려면 &lt;a href=&quot;IPC::Run&quot;&gt;IPC :: Run&lt;/a&gt; 을 설치해야하거나 시스템에서 &lt;a href=&quot;IPC::Open3&quot;&gt;IPC :: Open3을 사용할&lt;/a&gt; 수 있어야 함 ).</target>
        </trans-unit>
        <trans-unit id="8aa3d4d74657a46a0b2bcece8a25683b9b4d5103" translate="yes" xml:space="preserve">
          <source>This controls whether all output of a command should also be printed to STDOUT/STDERR or should only be trapped in buffers (NOTE: buffers require &lt;a href=&quot;http://search.cpan.org/perldoc/IPC::Run&quot;&gt;IPC::Run&lt;/a&gt; to be installed, or your system able to work with &lt;a href=&quot;open3&quot;&gt;IPC::Open3&lt;/a&gt;).</source>
          <target state="translated">이는 명령의 모든 출력을 STDOUT / STDERR로 인쇄해야하는지 또는 버퍼에만 트랩해야하는지 여부를 제어합니다 (참고 : 버퍼를 설치하려면 &lt;a href=&quot;http://search.cpan.org/perldoc/IPC::Run&quot;&gt;IPC :: Run&lt;/a&gt; 이 필요 하거나 시스템이 &lt;a href=&quot;open3&quot;&gt;IPC :: Open3&lt;/a&gt; 과 작동 할 수 있음 ).</target>
        </trans-unit>
        <trans-unit id="732d2e4b2658c0a2ec91db3c054e26236d0390f1" translate="yes" xml:space="preserve">
          <source>This controls whether imports the functions of a loaded modules to the caller package. The default is no importing any functions.</source>
          <target state="translated">로드 된 모듈의 기능을 호출자 패키지로 가져올 지 여부를 제어합니다. 기본적으로 함수를 가져 오지 않습니다.</target>
        </trans-unit>
        <trans-unit id="eb78f49655da0a3543996010fb5198aba12c2274" translate="yes" xml:space="preserve">
          <source>This controls whether or not each HTML page is liable to have a little table of contents at the top (which we call an &quot;index&quot; for historical reasons). This is true by default.</source>
          <target state="translated">이것은 각 HTML 페이지가 맨 위에 약간의 목차를 가질 수 있는지 여부를 제어합니다 (이력상의 이유로 &quot;인덱스&quot;라고 함). 기본적으로 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="d18f8fcaf7759aa328d11a1f1e92e835b3d9557f" translate="yes" xml:space="preserve">
          <source>This controls whether warnings should be printed if a module failed to load. The default is to use the value of $Module::Load::Conditional::VERBOSE.</source>
          <target state="translated">모듈을로드하지 못한 경우 경고를 인쇄해야하는지 여부를 제어합니다. 기본값은 $ Module :: Load :: Conditional :: VERBOSE 값을 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="4ff7f0c70685518180af334112b2fe58a44a4fdd" translate="yes" xml:space="preserve">
          <source>This copyright does not prohibit distribution of any version of Perl containing this extension under the terms of the GNU or Artistic licenses.</source>
          <target state="translated">이 저작권은 GNU 또는 Artistic 라이센스의 조건에 따라이 확장을 포함하는 Perl 버전의 배포를 금지하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e07ca9a36ef5f49f5e95795b2568b38574fd37e2" translate="yes" xml:space="preserve">
          <source>This corresponds to clearerr(), i.e., clears 'error' and (usually) 'eof' flags for the &quot;stream&quot;. Does not return a value.</source>
          <target state="translated">이는 clearerr ()에 해당합니다. 즉, &quot;stream&quot;에 대한 'error'및 (보통) 'eof'플래그를 지 웁니다. 값을 반환하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a832f3c37512b00bc489449027088839617ff5af" translate="yes" xml:space="preserve">
          <source>This corresponds to feof(). Returns a true/false indication of whether the handle is at end of file. For terminal devices this may or may not be &quot;sticky&quot; depending on the implementation. The flag is cleared by PerlIO_seek(), or PerlIO_rewind().</source>
          <target state="translated">이것은 feof ()에 해당합니다. 핸들이 파일 끝에 있는지 여부에 대한 참 / 거짓 표시를 반환합니다. 터미널 장치의 경우 이는 구현에 따라 &quot;고정적&quot;일 수도 있고 아닐 수도 있습니다. PerlIO_seek () 또는 PerlIO_rewind ()에 의해 플래그가 지워집니다.</target>
        </trans-unit>
        <trans-unit id="baeb66e5af4f3d77be2f1ed10348f03a4ed016a5" translate="yes" xml:space="preserve">
          <source>This corresponds to ferror(). Returns a true/false indication of whether there has been an IO error on the handle.</source>
          <target state="translated">이것은 ferror ()에 해당합니다. 핸들에 IO 오류가 있는지 여부에 대한 참 / 거짓 표시를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="bb12a0ca3665432e7ae210e2f30b098e3c60f423" translate="yes" xml:space="preserve">
          <source>This corresponds to fflush(). Sends any buffered write data to the underlying file. If called with &lt;code&gt;NULL&lt;/code&gt; this may flush all open streams (or core dump with some USE_STDIO implementations). Calling on a handle open for read only, or on which last operation was a read of some kind may lead to undefined behaviour on some USE_STDIO implementations. The USE_PERLIO (layers) implementation tries to behave better: it flushes all open streams when passed &lt;code&gt;NULL&lt;/code&gt; , and attempts to retain data on read streams either in the buffer or by seeking the handle to the current logical position.</source>
          <target state="translated">이것은 fflush ()에 해당합니다. 버퍼링 된 쓰기 데이터를 기본 파일로 보냅니다. &lt;code&gt;NULL&lt;/code&gt; 로 호출하면 모든 열린 스트림 (또는 일부 USE_STDIO 구현의 코어 덤프)을 플러시 할 수 있습니다. 읽기 전용으로 열려 있거나 마지막 작업이 어떤 종류의 읽기 인 핸들을 호출하면 일부 USE_STDIO 구현에서 정의되지 않은 동작이 발생할 수 있습니다. USE_PERLIO (계층) 구현은 더 나은 동작을 시도합니다. &lt;code&gt;NULL&lt;/code&gt; 을 전달하면 열려있는 모든 스트림을 플러시 하고 버퍼에서 또는 현재 논리 위치에 대한 핸들을 검색하여 읽기 스트림에서 데이터를 유지하려고합니다.</target>
        </trans-unit>
        <trans-unit id="4d9dcb6de62439562f514cb79a1863a8cc7b8b20" translate="yes" xml:space="preserve">
          <source>This corresponds to fflush(). Sends any buffered write data to the underlying file. If called with &lt;code&gt;NULL&lt;/code&gt; this may flush all open streams (or core dump with some USE_STDIO implementations). Calling on a handle open for read only, or on which last operation was a read of some kind may lead to undefined behaviour on some USE_STDIO implementations. The USE_PERLIO (layers) implementation tries to behave better: it flushes all open streams when passed &lt;code&gt;NULL&lt;/code&gt;, and attempts to retain data on read streams either in the buffer or by seeking the handle to the current logical position.</source>
          <target state="translated">이것은 fflush ()에 해당합니다. 버퍼링 된 쓰기 데이터를 기본 파일로 보냅니다. &lt;code&gt;NULL&lt;/code&gt; 로 호출하면 모든 열린 스트림 (또는 일부 USE_STDIO 구현의 코어 덤프)을 플러시 할 수 있습니다. 읽기 전용으로 열린 핸들 또는 어떤 종류의 마지막 작업이 어떤 종류의 읽기 인 핸들을 호출하면 일부 USE_STDIO 구현에서 정의되지 않은 동작이 발생할 수 있습니다. USE_PERLIO (레이어) 구현은 더 나은 동작을 시도합니다. &lt;code&gt;NULL&lt;/code&gt; 을 전달하면 모든 열린 스트림을 플러시 하고 버퍼에서 또는 현재 논리적 위치에 대한 핸들을 검색하여 읽기 스트림에 데이터를 유지하려고합니다.</target>
        </trans-unit>
        <trans-unit id="9e414890b7f22b1b4083f4007de6555d9d071db1" translate="yes" xml:space="preserve">
          <source>This corresponds to fileno(), note that on some platforms, the meaning of &quot;fileno&quot; may not match Unix. Returns -1 if the handle has no open descriptor associated with it.</source>
          <target state="translated">이는 fileno ()에 해당합니다. 일부 플랫폼에서는 &quot;fileno&quot;의 의미가 Unix와 일치하지 않을 수 있습니다. 핸들에 열려있는 설명자가 없으면 -1을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="5f4554adde4cea2591eaa99c7438bd7a745a0b3f" translate="yes" xml:space="preserve">
          <source>This corresponds to fseek(). Sends buffered write data to the underlying file, or discards any buffered read data, then positions the file descriptor as specified by &lt;b&gt;offset&lt;/b&gt; and &lt;b&gt;whence&lt;/b&gt; (sic). This is the correct thing to do when switching between read and write on the same handle (see issues with PerlIO_flush() above). Offset is of type &lt;code&gt;Off_t&lt;/code&gt; which is a perl Configure value which may not be same as stdio's &lt;code&gt;off_t&lt;/code&gt; .</source>
          <target state="translated">이것은 fseek ()에 해당합니다. 버퍼링 된 쓰기 데이터를 기본 파일로 보내거나 버퍼링 된 읽기 데이터를 버린 다음 &lt;b&gt;오프셋&lt;/b&gt; 및 &lt;b&gt;whence&lt;/b&gt; (sic)에 지정된대로 파일 디스크립터를 배치합니다 . 동일한 핸들에서 읽기와 쓰기를 전환 할 때 수행해야 할 올바른 작업입니다 (위의 PerlIO_flush () 관련 문제 참조). 오프셋은 &lt;code&gt;Off_t&lt;/code&gt; 유형 이며 이는 stdio의 &lt;code&gt;off_t&lt;/code&gt; 와 같지 않을 수있는 perl 구성 값입니다 .</target>
        </trans-unit>
        <trans-unit id="9bd7cfe67b5d59fef2229cadd453ea0901b8f7eb" translate="yes" xml:space="preserve">
          <source>This corresponds to fseek(). Sends buffered write data to the underlying file, or discards any buffered read data, then positions the file descriptor as specified by &lt;b&gt;offset&lt;/b&gt; and &lt;b&gt;whence&lt;/b&gt; (sic). This is the correct thing to do when switching between read and write on the same handle (see issues with PerlIO_flush() above). Offset is of type &lt;code&gt;Off_t&lt;/code&gt; which is a perl Configure value which may not be same as stdio's &lt;code&gt;off_t&lt;/code&gt;.</source>
          <target state="translated">이것은 fseek ()에 해당합니다. 기본 파일 또는 폐기, 버퍼에 판독 된 데이터를 기록 데이터로 버퍼링 된 전송하고 파일에 지정된대로 배치 서술자 &lt;b&gt;오프셋&lt;/b&gt; 과 &lt;b&gt;어디서&lt;/b&gt; (SiC)를. 이것은 동일한 핸들에서 읽기와 쓰기 사이를 전환 할 때 수행 할 올바른 작업입니다 (위의 PerlIO_flush () 관련 문제 참조). 오프셋은 stdio의 &lt;code&gt;off_t&lt;/code&gt; 와 같지 않을 수있는 perl 구성 값인 &lt;code&gt;Off_t&lt;/code&gt; 유형 입니다.</target>
        </trans-unit>
        <trans-unit id="dd9bee6b04c387fd0085a9f7aa8ff48a5f034283" translate="yes" xml:space="preserve">
          <source>This corresponds to ftell(). Returns the current file position, or (Off_t) -1 on error. May just return value system &quot;knows&quot; without making a system call or checking the underlying file descriptor (so use on shared file descriptors is not safe without a PerlIO_seek()). Return value is of type &lt;code&gt;Off_t&lt;/code&gt; which is a perl Configure value which may not be same as stdio's &lt;code&gt;off_t&lt;/code&gt; .</source>
          <target state="translated">이것은 ftell ()에 해당합니다. 현재 파일 위치를 반환하거나 오류 발생시 (Off_t) -1을 반환합니다. 시스템을 호출하거나 기본 파일 디스크립터를 확인하지 않고 값 &quot;시스템&quot;을 리턴 할 수 있습니다 (따라서 공유 파일 디스크립터에서의 사용은 PerlIO_seek () 없이는 안전하지 않습니다). 리턴 값은 &lt;code&gt;Off_t&lt;/code&gt; 유형 이며 이는 stdio의 &lt;code&gt;off_t&lt;/code&gt; 와 같지 않을 수있는 perl 구성 값입니다 .</target>
        </trans-unit>
        <trans-unit id="7e3cecdb4fa297b5ce6bf2a831e2cb59bd3601f2" translate="yes" xml:space="preserve">
          <source>This corresponds to ftell(). Returns the current file position, or (Off_t) -1 on error. May just return value system &quot;knows&quot; without making a system call or checking the underlying file descriptor (so use on shared file descriptors is not safe without a PerlIO_seek()). Return value is of type &lt;code&gt;Off_t&lt;/code&gt; which is a perl Configure value which may not be same as stdio's &lt;code&gt;off_t&lt;/code&gt;.</source>
          <target state="translated">이것은 ftell ()에 해당합니다. 현재 파일 위치를 반환하거나 오류시 (Off_t) -1을 반환합니다. 시스템 호출을하거나 기본 파일 설명자를 확인하지 않고 시스템이 &quot;알고있는&quot;값을 반환 할 수 있습니다 (따라서 공유 파일 설명자에서 사용하는 것은 PerlIO_seek () 없이는 안전하지 않습니다). 반환 값은 stdio의 &lt;code&gt;off_t&lt;/code&gt; 와 같지 않을 수있는 perl 구성 값인 &lt;code&gt;Off_t&lt;/code&gt; 유형 입니다.</target>
        </trans-unit>
        <trans-unit id="a3583e8644f865d149cd4eb31d670f437a6e26eb" translate="yes" xml:space="preserve">
          <source>This corresponds to getc(). Despite the c in the name only byte range 0..0xFF is supported. Returns the character read or -1 (&lt;code&gt;EOF&lt;/code&gt; ) on error.</source>
          <target state="translated">이것은 getc ()에 해당합니다. 이름의 c에도 불구하고 바이트 범위 0..0xFF 만 지원됩니다. 문자 읽기 또는 오류시 -1 ( &lt;code&gt;EOF&lt;/code&gt; )을 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="95c0f809b22c7c0dae9af22f03c13f59aaa59bfb" translate="yes" xml:space="preserve">
          <source>This corresponds to getc(). Despite the c in the name only byte range 0..0xFF is supported. Returns the character read or -1 (&lt;code&gt;EOF&lt;/code&gt;) on error.</source>
          <target state="translated">이것은 getc ()에 해당합니다. 이름의 c에도 불구하고 바이트 범위 0..0xFF 만 지원됩니다. 읽은 문자 또는 오류시 -1 ( &lt;code&gt;EOF&lt;/code&gt; )을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="e1cbd65b62177115f422eaf8fe4754328fbc6b9b" translate="yes" xml:space="preserve">
          <source>This corresponds to rewind(). It is usually defined as being</source>
          <target state="translated">이것은 rewind ()에 해당합니다. 일반적으로</target>
        </trans-unit>
        <trans-unit id="93c7ee35566034261e1234fcee65abc1e334abb8" translate="yes" xml:space="preserve">
          <source>This corresponds to setlinebuf(). Does not return a value. What constitutes a &quot;line&quot; is implementation dependent but usually means that writing &quot;\n&quot; flushes the buffer. What happens with things like &quot;this\nthat&quot; is uncertain. (Perl core uses it</source>
          <target state="translated">이것은 setlinebuf ()에 해당합니다. 값을 반환하지 않습니다. &quot;라인&quot;을 구성하는 것은 구현에 따라 다르지만 일반적으로 &quot;\ n&quot;을 쓰면 버퍼가 플러시됨을 의미합니다. &quot;this \ nthat&quot;과 같은 일이 어떻게되는지 불확실합니다. (펄 코어가 사용</target>
        </trans-unit>
        <trans-unit id="c130282a86007cfef5f589b0d598e97fc7e10899" translate="yes" xml:space="preserve">
          <source>This corresponds to tmpfile(), i.e., returns an anonymous PerlIO or NULL on error. The system will attempt to automatically delete the file when closed. On Unix the file is usually &lt;code&gt;&lt;a href=&quot;functions/unlink&quot;&gt;unlink&lt;/a&gt;&lt;/code&gt;-ed just after it is created so it does not matter how it gets closed. On other systems the file may only be deleted if closed via PerlIO_close() and/or the program exits via &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit&lt;/a&gt;&lt;/code&gt;. Depending on the implementation there may be &quot;race conditions&quot; which allow other processes access to the file, though in general it will be safer in this regard than ad. hoc. schemes.</source>
          <target state="translated">이것은 tmpfile ()에 해당합니다. 즉 오류가 발생하면 익명 PerlIO 또는 NULL을 반환합니다. 시스템은 파일을 닫을 때 자동으로 파일 삭제를 시도합니다. 유닉스에서 파일은 일반적으로 파일을 만든 직후 &lt;code&gt;&lt;a href=&quot;functions/unlink&quot;&gt;unlink&lt;/a&gt;&lt;/code&gt; 되므로 파일을 닫는 방법은 중요하지 않습니다. 다른 시스템에서는 파일이 PerlIO_close ()를 통해 닫히거나 프로그램이 exit를 통해 &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit&lt;/a&gt;&lt;/code&gt; 된 경우에만 파일을 삭제할 수 있습니다 . 구현에 따라 다른 프로세스가 파일에 액세스 할 수있게하는 &quot;경주 조건&quot;이있을 수 있지만 일반적으로 광고보다 안전합니다. 혹시 계획.</target>
        </trans-unit>
        <trans-unit id="0510a97fbd4cfa5a066aad9bda9c89da0469e9d9" translate="yes" xml:space="preserve">
          <source>This corresponds to tmpfile(), i.e., returns an anonymous PerlIO or NULL on error. The system will attempt to automatically delete the file when closed. On Unix the file is usually &lt;code&gt;unlink&lt;/code&gt;-ed just after it is created so it does not matter how it gets closed. On other systems the file may only be deleted if closed via PerlIO_close() and/or the program exits via &lt;code&gt;exit&lt;/code&gt;. Depending on the implementation there may be &quot;race conditions&quot; which allow other processes access to the file, though in general it will be safer in this regard than ad. hoc. schemes.</source>
          <target state="translated">이것은 tmpfile ()에 해당합니다. 즉, 익명의 PerlIO 또는 오류시 NULL을 반환합니다. 시스템이 닫히면 자동으로 파일 삭제를 시도합니다. Unix에서 파일은 일반적으로 생성 된 직후에 링크 &lt;code&gt;unlink&lt;/code&gt; 되므로 어떻게 닫히는지는 중요하지 않습니다. 다른 시스템에서는 PerlIO_close ()를 통해 닫히거나 프로그램이 exit를 통해 &lt;code&gt;exit&lt;/code&gt; 된 경우에만 파일이 삭제 될 수 있습니다 . 구현에 따라 다른 프로세스가 파일에 액세스 할 수있는 &quot;경쟁 조건&quot;이있을 수 있지만 일반적으로 이와 관련하여 광고보다 안전합니다. hoc. 계획.</target>
        </trans-unit>
        <trans-unit id="327b626f972edcc8578bc2302697191125c0290f" translate="yes" xml:space="preserve">
          <source>This corresponds to ungetc(). Note that arguments have been revised to have &quot;file&quot; first. Arranges that next read operation will return the byte &lt;b&gt;c&lt;/b&gt;. Despite the implied &quot;character&quot; in the name only values in the range 0..0xFF are defined. Returns the byte &lt;b&gt;c&lt;/b&gt; on success or -1 (&lt;code&gt;EOF&lt;/code&gt; ) on error. The number of bytes that can be &quot;pushed back&quot; may vary, only 1 character is certain, and then only if it is the last character that was read from the handle.</source>
          <target state="translated">이것은 ungetc ()에 해당합니다. 인수는 &quot;파일&quot;을 먼저 갖도록 수정되었습니다. 다음 읽기 작업이 바이트 &lt;b&gt;c를&lt;/b&gt; 반환하도록 정렬합니다 . 이름에 &quot;암호&quot;가 내포되어 있음에도 불구하고 0..0xFF 범위의 값만 정의됩니다. 성공 하면 바이트 &lt;b&gt;c&lt;/b&gt; 를 , 에러 이면 -1 ( &lt;code&gt;EOF&lt;/code&gt; )을 반환합니다 . &quot;푸시 백 (push back)&quot;될 수있는 바이트 수는 다양 할 수 있으며, 한 문자 만 확실하며 핸들에서 읽은 마지막 문자 인 경우에만 가능합니다.</target>
        </trans-unit>
        <trans-unit id="c9249d1b24ff827efbf0b09c581b3316583a595e" translate="yes" xml:space="preserve">
          <source>This corresponds to ungetc(). Note that arguments have been revised to have &quot;file&quot; first. Arranges that next read operation will return the byte &lt;b&gt;c&lt;/b&gt;. Despite the implied &quot;character&quot; in the name only values in the range 0..0xFF are defined. Returns the byte &lt;b&gt;c&lt;/b&gt; on success or -1 (&lt;code&gt;EOF&lt;/code&gt;) on error. The number of bytes that can be &quot;pushed back&quot; may vary, only 1 character is certain, and then only if it is the last character that was read from the handle.</source>
          <target state="translated">이것은 ungetc ()에 해당합니다. 인수는 먼저 &quot;파일&quot;을 갖도록 수정되었습니다. 다음 읽기 작업이 바이트 &lt;b&gt;c를&lt;/b&gt; 반환하도록 정렬합니다 . 이름에 &quot;문자&quot;가 내포되어 있음에도 불구하고 0..0xFF 범위의 값만 정의됩니다. 성공시 바이트 &lt;b&gt;c&lt;/b&gt; 를 반환하고 오류시 -1 ( &lt;code&gt;EOF&lt;/code&gt; )을 반환합니다 . &quot;푸시 백&quot;할 수있는 바이트 수는 다양 할 수 있으며 한 문자 만 확실하며 핸들에서 읽은 마지막 문자 인 경우에만 가능합니다.</target>
        </trans-unit>
        <trans-unit id="d8f57342ffddc378f45e967d08a4b40a9028441d" translate="yes" xml:space="preserve">
          <source>This could, of course, be more legibly written with the &lt;code&gt;/x&lt;/code&gt; modifier, adding whitespace and comments. Here it is expanded, courtesy of Fred Curtis.</source>
          <target state="translated">물론 이것은 공백과 주석을 추가 하여 &lt;code&gt;/x&lt;/code&gt; 수정 자로 더 읽기 쉽게 작성 될 수 있습니다 . 여기에서 Fred Curtis가 제공 한 확장입니다.</target>
        </trans-unit>
        <trans-unit id="ac65bf824b65194ff0a99fd92e3e036111f8e8a9" translate="yes" xml:space="preserve">
          <source>This counterintuitive behavior has been fixed in perl v5.8.1.</source>
          <target state="translated">이 반 직관적 인 동작은 perl v5.8.1에서 수정되었습니다.</target>
        </trans-unit>
        <trans-unit id="ee88470233c1da8717b5bd9acaba39e40089d0b6" translate="yes" xml:space="preserve">
          <source>This creates a &lt;code&gt;VMS::DCLsym&lt;/code&gt; object which can be used as a handle for later method calls. The single optional argument specifies the symbol table used by default in future method calls, in the same way as the optional argument to &lt;code&gt;tie&lt;/code&gt; described above.</source>
          <target state="translated">그러면 나중에 메서드 호출을위한 핸들로 사용할 수 있는 &lt;code&gt;VMS::DCLsym&lt;/code&gt; 개체가 생성 됩니다. 단일 선택적 인수 는 위에서 설명한 &lt;code&gt;tie&lt;/code&gt; 옵션 인수와 동일한 방식으로 향후 메서드 호출에서 기본적으로 사용되는 기호 테이블을 지정합니다 .</target>
        </trans-unit>
        <trans-unit id="1645aaa3f3c32e20d8c02b43f04eac07a2fcc5a3" translate="yes" xml:space="preserve">
          <source>This creates a CPAN::Meta::Merge object. It takes one mandatory named argument, &lt;code&gt;version&lt;/code&gt;, declaring the version of the meta-spec that must be used for the merge. It can optionally take an &lt;code&gt;extra_mappings&lt;/code&gt; argument that allows one to add additional merging functions for specific elements.</source>
          <target state="translated">그러면 CPAN :: Meta :: Merge 객체가 생성됩니다. 병합에 사용해야하는 메타 스펙의 버전을 선언하는 필수 명명 된 인수 &lt;code&gt;version&lt;/code&gt; 하나를 사용합니다. 특정 요소에 대한 추가 병합 함수를 추가 할 수 있는 &lt;code&gt;extra_mappings&lt;/code&gt; 인수를 선택적으로 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4d26884badcfad89a2f88ee752f4bee54862ec7a" translate="yes" xml:space="preserve">
          <source>This creates a handler for the attribute &lt;code&gt;:Loud&lt;/code&gt; in the class LoudDecl. Thereafter, any subroutine declared with a &lt;code&gt;:Loud&lt;/code&gt; attribute in the class LoudDecl:</source>
          <target state="translated">LoudDecl 클래스에서 &lt;code&gt;:Loud&lt;/code&gt; 속성에 대한 핸들러를 작성합니다 . 그런 &lt;code&gt;:Loud&lt;/code&gt; LoudDecl 클래스에서 : Loud 속성으로 선언 된 모든 서브 루틴 :</target>
        </trans-unit>
        <trans-unit id="8263a46fdb04b7977692de514f9404e4c18b81b5" translate="yes" xml:space="preserve">
          <source>This creates a local branch named &lt;code&gt;maint-5.005&lt;/code&gt;, which tracks the remote branch &lt;code&gt;origin/maint-5.005&lt;/code&gt;. Then you can pull, commit, merge and push as before.</source>
          <target state="translated">이렇게하면 원격 분기 &lt;code&gt;origin/maint-5.005&lt;/code&gt; 를 추적하는 &lt;code&gt;maint-5.005&lt;/code&gt; 라는 로컬 분기가 생성 됩니다. 그런 다음 이전과 같이 당기고, 커밋하고, 병합하고, 푸시 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9bc82066bd7f21b4bcc5fd329fc91ce1111d9d09" translate="yes" xml:space="preserve">
          <source>This creates a new batch converter. The method doesn't take parameters. To change the converter's attributes, use the &quot;ACCESSOR METHODS&quot;&quot; in &quot; below.</source>
          <target state="translated">이렇게하면 새 배치 변환기가 생성됩니다. 이 메서드는 매개 변수를 사용하지 않습니다. 변환기의 속성을 변경하려면 아래 &quot;의&quot;ACCESSOR METHODS &quot;&quot;를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="87fa03371108789e3d1ff265f81c30f8fb7e2b16" translate="yes" xml:space="preserve">
          <source>This creates a new thread (&lt;code&gt;$thr2&lt;/code&gt; ) that inherits the stack size from an existing thread (&lt;code&gt;$thr1&lt;/code&gt; ). This is shorthand for the following:</source>
          <target state="translated">기존 스레드 ( &lt;code&gt;$thr1&lt;/code&gt; ) 에서 스택 크기를 상속 하는 새 스레드 ( &lt;code&gt;$thr2&lt;/code&gt; )가 작성 됩니다. 다음과 같은 약어입니다.</target>
        </trans-unit>
        <trans-unit id="47788aa7839e22479a971854bcf1abe7b0acfb25" translate="yes" xml:space="preserve">
          <source>This creates a new thread (&lt;code&gt;$thr2&lt;/code&gt;) that inherits the stack size from an existing thread (&lt;code&gt;$thr1&lt;/code&gt;). This is shorthand for the following:</source>
          <target state="translated">이렇게하면 기존 스레드 ( &lt;code&gt;$thr1&lt;/code&gt; ) 에서 스택 크기를 상속 하는 새 스레드 ( &lt;code&gt;$thr2&lt;/code&gt; )가 생성 됩니다. 이것은 다음에 대한 속기입니다.</target>
        </trans-unit>
        <trans-unit id="c13be50d55b544b4c8283f535832e9b6392a885b" translate="yes" xml:space="preserve">
          <source>This creates a working sysroot that we can feed to Configure later.</source>
          <target state="translated">그러면 나중에 Configure에 공급할 수있는 작동하는 sysroot가 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="0d5e9ac144b79f7c4865c5f4daf815fdb24b2e3d" translate="yes" xml:space="preserve">
          <source>This currently means that all code points in the sequence have been assigned by Unicode to be characters that aren't private use nor surrogate code points.</source>
          <target state="translated">이것은 현재 시퀀스의 모든 코드 포인트가 유니 코드에 의해 개인 용도 나 대리 코드 포인트가 아닌 문자로 할당되었음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="0ee76e6a741e92139c43f1e221ed11b509991786" translate="yes" xml:space="preserve">
          <source>This database type allows arbitrary key/value pairs to be stored in data files. This is equivalent to the functionality provided by other hashing packages like DBM, NDBM, ODBM, GDBM, and SDBM. Remember though, the files created using DB_HASH are not compatible with any of the other packages mentioned.</source>
          <target state="translated">이 데이터베이스 유형을 사용하면 임의의 키 / 값 쌍을 데이터 파일에 저장할 수 있습니다. 이는 DBM, NDBM, ODBM, GDBM 및 SDBM과 같은 다른 해싱 패키지에서 제공하는 기능과 동일합니다. 그러나 DB_HASH를 사용하여 작성된 파일은 언급 된 다른 패키지와 호환되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3807b81d9c773a6c5335f9e71e920114a654bcff" translate="yes" xml:space="preserve">
          <source>This debugger prints a number which increments for each statement encountered and waits for you to hit a newline before continuing to the next statement.</source>
          <target state="translated">이 디버거는 발생한 각 명령문마다 증가하는 숫자를 인쇄하고 다음 명령문을 계속하기 전에 줄 바꿈을 할 때까지 기다립니다.</target>
        </trans-unit>
        <trans-unit id="67c09da3f20ea7878643178c10aa0a6e33cc924b" translate="yes" xml:space="preserve">
          <source>This declares a block of tests that might be skipped, $how_many tests there are, $why and under what $condition to skip them. An example is the easiest way to illustrate:</source>
          <target state="translated">이것은 건너 뛸 수있는 테스트 블록, $ how_many 테스트, $ why 및 어떤 $ 조건에서 건너 뛸 테스트를 선언합니다. 예를 들어 가장 쉬운 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9e3fa8a7f8cc69e16dc88141cf1567bb93e3d7ad" translate="yes" xml:space="preserve">
          <source>This decomposition may be an intermediate one whose components are also decomposable. Use &lt;a href=&quot;Unicode::Normalize&quot;&gt;Unicode::Normalize&lt;/a&gt; to get the final decomposition in one step.</source>
          <target state="translated">이 분해는 구성 요소도 분해 가능한 중간 분해 일 수 있습니다. &lt;a href=&quot;Unicode::Normalize&quot;&gt;Unicode :: Normalize&lt;/a&gt; 를 사용 하여 한 번에 최종 분해를 얻습니다.</target>
        </trans-unit>
        <trans-unit id="44521e30f7e690cd5dc65c30814c4cee699cd60e" translate="yes" xml:space="preserve">
          <source>This decomposition may be an intermediate one whose components are also decomposable. Use &lt;a href=&quot;normalize&quot;&gt;Unicode::Normalize&lt;/a&gt; to get the final decomposition in one step.</source>
          <target state="translated">이러한 분해는 구성 요소가 분해 가능한 중간체 일 수있다. 한 번에 최종 분해를 얻으려면 &lt;a href=&quot;normalize&quot;&gt;Unicode :: Normalize&lt;/a&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="97bd528541645ff3d464e572f5a4805e2ee9bc4c" translate="yes" xml:space="preserve">
          <source>This default can be overridden on a per-number basis by calling the &lt;code&gt;display_format&lt;/code&gt; method instead. As before, not supplying any argument returns the current display style for this number. Otherwise whatever you specify will be the new display style for</source>
          <target state="translated">&lt;code&gt;display_format&lt;/code&gt; 메소드를 대신 호출 하여이 기본값을 번호별로 대체 할 수 있습니다 . 이전과 같이 인수를 제공하지 않으면이 숫자의 현재 표시 스타일이 반환됩니다. 그렇지 않으면 당신이 지정한 것은 새로운 디스플레이 스타일이 될 것입니다</target>
        </trans-unit>
        <trans-unit id="b13fed4037708b058149d6d54239c3578805f852" translate="yes" xml:space="preserve">
          <source>This demonstrates how &lt;code&gt;SUPER&lt;/code&gt; is resolved. Even though the object is blessed into the &lt;code&gt;C&lt;/code&gt; class, the &lt;code&gt;speak()&lt;/code&gt; method in the &lt;code&gt;B&lt;/code&gt; class can still call &lt;code&gt;SUPER::speak()&lt;/code&gt; and expect it to correctly look in the parent class of &lt;code&gt;B&lt;/code&gt; (i.e the class the method call is in), not in the parent class of &lt;code&gt;C&lt;/code&gt; (i.e. the class the object belongs to).</source>
          <target state="translated">&lt;code&gt;SUPER&lt;/code&gt; 가 어떻게 해결 되는지 보여줍니다 . 개체가에 축복하더라도 &lt;code&gt;C&lt;/code&gt; 의 클래스의 &lt;code&gt;speak()&lt;/code&gt; 의 방법 &lt;code&gt;B&lt;/code&gt; 의 클래스는 여전히 호출 할 수 있습니다 &lt;code&gt;SUPER::speak()&lt;/code&gt; 하고 올바르게의 부모 클래스에서 볼 기대 &lt;code&gt;B&lt;/code&gt; (즉, 메서드 호출에있는 클래스 ), &lt;code&gt;C&lt;/code&gt; 의 상위 클래스 (예 : 객체가 속한 클래스 )가 아닙니다 .</target>
        </trans-unit>
        <trans-unit id="5a18b47e8bc86d748a4aab67a43edef686b92a3f" translate="yes" xml:space="preserve">
          <source>This depends on the tied hash's implementation of EXISTS(). For example, there isn't the concept of undef with hashes that are tied to DBM* files. It also means that exists() and defined() do the same thing with a DBM* file, and what they end up doing is not what they do with ordinary hashes.</source>
          <target state="translated">이는 묶인 해시의 EXISTS () 구현에 따라 다릅니다. 예를 들어, DBM * 파일에 묶인 해시가있는 undef의 개념은 없습니다. 또한 exist () 및 defined ()가 DBM * 파일로 동일한 작업을 수행하고 결국 해시로 수행하는 작업이 아니라는 것을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="9d4bc0de5af18f612ccd2a5cae826c99487fcbf8" translate="yes" xml:space="preserve">
          <source>This depends on which operating system your program is running on. In the case of Unix, the serial ports will be accessible through files in &lt;code&gt;/dev&lt;/code&gt; ; on other systems, device names will doubtless differ. Several problem areas common to all device interaction are the following:</source>
          <target state="translated">프로그램이 실행중인 운영 체제에 따라 다릅니다. 유닉스의 경우, 직렬 포트는 &lt;code&gt;/dev&lt;/code&gt; 의 파일을 통해 액세스 할 수 있습니다 . 다른 시스템에서는 장치 이름이 틀림없이 다릅니다. 모든 장치 상호 작용에 공통적 인 몇 가지 문제 영역은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="03ee5b714e2ad9827ab9f706d0156780edac87fe" translate="yes" xml:space="preserve">
          <source>This depends on which operating system your program is running on. In the case of Unix, the serial ports will be accessible through files in &lt;code&gt;/dev&lt;/code&gt;; on other systems, device names will doubtless differ. Several problem areas common to all device interaction are the following:</source>
          <target state="translated">이것은 프로그램이 실행되는 운영 체제에 따라 다릅니다. Unix의 경우 직렬 포트는 &lt;code&gt;/dev&lt;/code&gt; 에있는 파일을 통해 액세스 할 수 있습니다 . 다른 시스템에서는 의심 할 여지없이 장치 이름이 다를 것입니다. 모든 장치 상호 작용에 공통적 인 몇 가지 문제 영역은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5becff50f569cb27ece95ac48841bd7838bbbdf8" translate="yes" xml:space="preserve">
          <source>This describes all packages provided by this distribution. This information is used by distribution and automation mechanisms like PAUSE, CPAN, metacpan.org and search.cpan.org to build indexes saying in which distribution various packages can be found.</source>
          <target state="translated">이 배포에서 제공하는 모든 패키지를 설명합니다. 이 정보는 PAUSE, CPAN, metacpan.org 및 search.cpan.org와 같은 배포 및 자동화 메커니즘에서 다양한 패키지를 찾을 수있는 배포판을 나타내는 인덱스를 작성하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="a20078d60a6a97424e04254a5fa4e6e526ad17dd" translate="yes" xml:space="preserve">
          <source>This describes the namespace layout for the Test2 ecosystem. Not all the namespaces listed here are part of the Test2 distribution, some are implemented in &lt;a href=&quot;Test2::Suite&quot;&gt;Test2::Suite&lt;/a&gt;.</source>
          <target state="translated">이것은 Test2 생태계의 네임 스페이스 레이아웃을 설명합니다. 여기에 나열된 모든 네임 스페이스가 Test2 배포의 일부는 아니며 일부는 &lt;a href=&quot;Test2::Suite&quot;&gt;Test2 :: Suite&lt;/a&gt; 에서 구현됩니다 .</target>
        </trans-unit>
        <trans-unit id="d5829cc9fcaba21dee6f9d7f5a98f9ac945f1487" translate="yes" xml:space="preserve">
          <source>This description is not updated often (since 5.6.1?), see</source>
          <target state="translated">이 설명은 자주 업데이트되지 않습니다 (5.6.1부터?).</target>
        </trans-unit>
        <trans-unit id="d6d22f28f156ae5e9b48e8de5b3d3fde4d59d03e" translate="yes" xml:space="preserve">
          <source>This differs slightly from the &lt;code&gt;accept&lt;/code&gt; function in &lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt;.</source>
          <target state="translated">이것은 &lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt; 의 &lt;code&gt;accept&lt;/code&gt; 함수 와 약간 다릅니다 .</target>
        </trans-unit>
        <trans-unit id="20322d80a32c4020d9ededc57d341d0284daf471" translate="yes" xml:space="preserve">
          <source>This directive is supported with ANSI-type function declarations only.</source>
          <target state="translated">이 지시문은 ANSI 유형 함수 선언에서만 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="0bdb96acaa7aac7424045042159548f85c9ab53b" translate="yes" xml:space="preserve">
          <source>This directly modifies the stored filehandles, it does not create new ones.</source>
          <target state="translated">이것은 저장된 파일 핸들을 직접 수정하며 새 파일 핸들을 생성하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a18a04a1fb981c46cc90618271edcb18e99ed305" translate="yes" xml:space="preserve">
          <source>This directory contains dual-life modules where the CPAN module is canonical. Do not patch these modules directly! Changes to these modules should be submitted to the maintainer of the CPAN module. Once those changes are applied and released, the new version of the module will be incorporated into the core.</source>
          <target state="translated">이 디렉토리에는 CPAN 모듈이 표준 인 이중 수명 모듈이 있습니다. 이 모듈을 직접 패치하지 마십시오! 이 모듈에 대한 변경 사항은 CPAN 모듈의 관리자에게 제출해야합니다. 이러한 변경 사항이 적용 및 릴리스되면 새 버전의 모듈이 코어에 통합됩니다.</target>
        </trans-unit>
        <trans-unit id="8f5f151207fd145f47cd0f164782d7d714aa8988" translate="yes" xml:space="preserve">
          <source>This directory contains pure-Perl modules which are only released as part of the core. This directory contains</source>
          <target state="translated">이 디렉토리에는 코어의 일부로 만 릴리스 된 pure-Perl 모듈이 있습니다. 이 디렉토리에는</target>
        </trans-unit>
        <trans-unit id="ff88cb5fa00bc50f7151a1d4596e477618c8bcec" translate="yes" xml:space="preserve">
          <source>This directory is for dual-life modules where the blead source is canonical. Note that some modules in this directory may not yet have been released separately on CPAN. Modules under</source>
          <target state="translated">이 디렉토리는 블리드 소스가 표준 인 이중 수명 모듈 용입니다. 이 디렉토리의 일부 모듈은 아직 CPAN에서 별도로 릴리스되지 않았을 수 있습니다. 아래 모듈</target>
        </trans-unit>
        <trans-unit id="62002fdbbc82dfdecab897397921252b1a422691" translate="yes" xml:space="preserve">
          <source>This directory should better be on &lt;code&gt;BOOKSHELF&lt;/code&gt; .</source>
          <target state="translated">이 디렉토리는 &lt;code&gt;BOOKSHELF&lt;/code&gt; 에 있어야합니다 .</target>
        </trans-unit>
        <trans-unit id="53f8085abd01c50ea807b424c7fb70d06b9d9336" translate="yes" xml:space="preserve">
          <source>This directory should better be on &lt;code&gt;BOOKSHELF&lt;/code&gt;.</source>
          <target state="translated">이 디렉토리는 &lt;code&gt;BOOKSHELF&lt;/code&gt; 에 있어야합니다 .</target>
        </trans-unit>
        <trans-unit id="333fd828a086a8d956340a5925aba972db5faa95" translate="yes" xml:space="preserve">
          <source>This directory should better be on &lt;code&gt;MANPATH&lt;/code&gt; . You need to have a working</source>
          <target state="translated">이 디렉토리는 &lt;code&gt;MANPATH&lt;/code&gt; 에 있어야합니다 . 당신은 일을해야합니다</target>
        </trans-unit>
        <trans-unit id="7a7d8abb15dd5ddcab335f051e15e631ee76c9a7" translate="yes" xml:space="preserve">
          <source>This directory should better be on &lt;code&gt;MANPATH&lt;/code&gt; . You need to have a working man to access these files.</source>
          <target state="translated">이 디렉토리는 &lt;code&gt;MANPATH&lt;/code&gt; 에 있어야합니다 . 이 파일에 액세스하려면 작업중인 사람이 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="3bfbc8178767aed118a078c916238d08187f8c32" translate="yes" xml:space="preserve">
          <source>This directory should better be on &lt;code&gt;MANPATH&lt;/code&gt;. You need to have a working</source>
          <target state="translated">이 디렉토리는 &lt;code&gt;MANPATH&lt;/code&gt; 에 있어야합니다 . 당신은 일이 필요합니다</target>
        </trans-unit>
        <trans-unit id="7f768384fb45192f416d43b226b88f4f7ac434db" translate="yes" xml:space="preserve">
          <source>This directory should better be on &lt;code&gt;MANPATH&lt;/code&gt;. You need to have a working man to access these files.</source>
          <target state="translated">이 디렉토리는 &lt;code&gt;MANPATH&lt;/code&gt; 에 있어야합니다 . 이 파일에 액세스하려면 일하는 사람이 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="efd449ffe16a462d28e76469ef21ea9f7d571513" translate="yes" xml:space="preserve">
          <source>This disables &lt;a href=&quot;#Magic-Autogeneration&quot;&gt;&quot;Magic Autogeneration&quot;&lt;/a&gt;.</source>
          <target state="translated">이렇게하면 &lt;a href=&quot;#Magic-Autogeneration&quot;&gt;&quot;Magic Autogeneration&quot;&lt;/a&gt; 이 비활성화 됩니다.</target>
        </trans-unit>
        <trans-unit id="170ad9fea04adcf28e5b84faabd5cf2954a187d9" translate="yes" xml:space="preserve">
          <source>This disables &lt;a href=&quot;#Magic-Autogeneration&quot;&gt;Magic Autogeneration&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#Magic-Autogeneration&quot;&gt;Magic Autogeneration을&lt;/a&gt; 비활성화합니다 .</target>
        </trans-unit>
        <trans-unit id="3b3a0993d47177782fe70afdd82bfb741c3d7395" translate="yes" xml:space="preserve">
          <source>This disables the poetry optimization, generating a compile-time error if you try to use a bareword identifier that's not a subroutine, unless it is a simple identifier (no colons) and that it appears in curly braces or on the left hand side of the &lt;code&gt;=&amp;gt;&lt;/code&gt; symbol.</source>
          <target state="translated">이는 간단한 식별자 (콜론 없음)이고 중괄호 또는 왼쪽에 표시되지 않는 한 서브 루틴이 아닌 베어 워드 식별자를 사용하려고하면시 최적화를 비활성화하고 컴파일 타임 오류를 생성합니다. &lt;code&gt;=&amp;gt;&lt;/code&gt; 기호.</target>
        </trans-unit>
        <trans-unit id="bbfb3ce32af84903cf3730d9cf51595fc0554060" translate="yes" xml:space="preserve">
          <source>This distribution directly accesses the hash keys in the &lt;a href=&quot;Test::Builder&quot;&gt;Test::Builder&lt;/a&gt; singleton. It also approaches the problem from the wrong angle, please consider using &lt;a href=&quot;Test2::Aggregate&quot;&gt;Test2::Aggregate&lt;/a&gt; for similar functionality and &lt;a href=&quot;Test2::Harness&quot;&gt;Test2::Harness&lt;/a&gt; which allows module preloading at the harness level.</source>
          <target state="translated">이 배포는 &lt;a href=&quot;Test::Builder&quot;&gt;Test :: Builder&lt;/a&gt; 싱글 톤 의 해시 키에 직접 액세스합니다 . 또한 잘못된 각도에서 문제에 접근합니다. 유사한 기능에는 &lt;a href=&quot;Test2::Aggregate&quot;&gt;Test2 :: Aggregate&lt;/a&gt; 를 사용 하고 하네스 수준에서 모듈을 미리로드 할 수있는 &lt;a href=&quot;Test2::Harness&quot;&gt;Test2 :: Harness&lt;/a&gt; 를 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="a5b7ba8215c0f4757732a3f14c729963fc274aea" translate="yes" xml:space="preserve">
          <source>This doc</source>
          <target state="translated">이 문서</target>
        </trans-unit>
        <trans-unit id="34ff219b627159fe6cfa93920427dc7e601e7134" translate="yes" xml:space="preserve">
          <source>This document aims to provide an overview of the vast perl community, which is far too large and diverse to provide a detailed listing. If any specific niche has been forgotten, it is not meant as an insult but an omission for the sake of brevity.</source>
          <target state="translated">이 문서는 광대 한 펄 커뮤니티에 대한 개요를 제공하는 데 그 목적이 있습니다. 특정 틈새를 잊어 버린 경우 모욕이 아니라 간결성을 위해 생략 된 것입니다.</target>
        </trans-unit>
        <trans-unit id="1ba7340d966579fbb753302864000cf7b2972014" translate="yes" xml:space="preserve">
          <source>This document assumes that the executable named &quot;perl&quot; is Perl version 5. Some systems may have installed Perl version 5 as &quot;perl5&quot;.</source>
          <target state="translated">이 문서에서는 &quot;perl&quot;이라는 실행 파일이 Perl 버전 5라고 가정합니다. 일부 시스템은 Perl 버전 5를 &quot;perl5&quot;로 설치했을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3a2742d9b73b97368bfc5521e9515184f408ef85" translate="yes" xml:space="preserve">
          <source>This document assumes that you already understand the basics of Perl syntax, variable types, operators, and subroutine calls. If you don't understand these concepts yet, please read &lt;a href=&quot;perlintro&quot;&gt;perlintro&lt;/a&gt; first. You should also read the &lt;a href=&quot;perlsyn&quot;&gt;perlsyn&lt;/a&gt;, &lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt;, and &lt;a href=&quot;perlsub&quot;&gt;perlsub&lt;/a&gt; documents.</source>
          <target state="translated">이 문서는 사용자가 Perl 구문, 변수 유형, 연산자 및 서브 루틴 호출의 기본 사항을 이미 이해하고 있다고 가정합니다. 이러한 개념을 아직 이해하지 &lt;a href=&quot;perlintro&quot;&gt;못하면&lt;/a&gt; 먼저 perlintro 를 읽으 십시오 . &lt;a href=&quot;perlsyn&quot;&gt;perlsyn&lt;/a&gt; , &lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt; 및 &lt;a href=&quot;perlsub&quot;&gt;perlsub&lt;/a&gt; 문서 도 읽어야합니다 .</target>
        </trans-unit>
        <trans-unit id="8f596bd16fedee538f262d0de64e96d996439fb3" translate="yes" xml:space="preserve">
          <source>This document attempts to describe how to use the Perl API, as well as to provide some info on the basic workings of the Perl core. It is far from complete and probably contains many errors. Please refer any questions or comments to the author below.</source>
          <target state="translated">이 문서는 Perl API 사용법과 Perl 코어의 기본 작동에 대한 정보를 제공하는 방법을 설명합니다. 완료되지 않았으며 많은 오류가있을 수 있습니다. 질문이나 의견은 아래 저자에게 문의하십시오.</target>
        </trans-unit>
        <trans-unit id="7e01fbc0bc773f9d24734cb30bab33bda7d5f6af" translate="yes" xml:space="preserve">
          <source>This document attempts to describe the Perl Community's &quot;best practice&quot; for writing Perl modules. It extends the recommendations found in &lt;a href=&quot;perlstyle&quot;&gt;perlstyle&lt;/a&gt; , which should be considered required reading before reading this document.</source>
          <target state="translated">이 문서는 Perl 모듈 작성에 대한 Perl 커뮤니티의 &quot;모범 사례&quot;를 설명하려고합니다. 이 문서를 읽기 전에 반드시 읽어야 할 &lt;a href=&quot;perlstyle&quot;&gt;perlstyle&lt;/a&gt; 의 권장 사항을 확장합니다 .</target>
        </trans-unit>
        <trans-unit id="bab11f45369409b96d7bf2180484dc0f685d2683" translate="yes" xml:space="preserve">
          <source>This document briefly describes Perl under Mac OS X.</source>
          <target state="translated">이 문서는 Mac OS X에서 Perl을 간략하게 설명합니다.</target>
        </trans-unit>
        <trans-unit id="083d82552ef9adb2b16dbbdc73ee6cb2d3adb7be" translate="yes" xml:space="preserve">
          <source>This document codifies the support and maintenance commitments that the Perl community should expect from Perl's developers:</source>
          <target state="translated">이 문서는 Perl 커뮤니티가 Perl 개발자에게 기대할 수있는 지원 및 유지 보수 약속을 체계화합니다.</target>
        </trans-unit>
        <trans-unit id="ee4356257bf892096131087eff39fae084e3b0fb" translate="yes" xml:space="preserve">
          <source>This document covers features supported by &lt;code&gt;ExtUtils::ParseXS&lt;/code&gt; (also known as &lt;code&gt;xsubpp&lt;/code&gt; ) 3.13_01.</source>
          <target state="translated">이 문서는 &lt;code&gt;ExtUtils::ParseXS&lt;/code&gt; ( &lt;code&gt;xsubpp&lt;/code&gt; 라고도 함 ) 3.13_01에서 지원하는 기능을 다룹니다 .</target>
        </trans-unit>
        <trans-unit id="6622e622368097560175e65713355ba452a435bc" translate="yes" xml:space="preserve">
          <source>This document covers features supported by &lt;code&gt;ExtUtils::ParseXS&lt;/code&gt; (also known as &lt;code&gt;xsubpp&lt;/code&gt;) 3.13_01.</source>
          <target state="translated">이 문서는 &lt;code&gt;ExtUtils::ParseXS&lt;/code&gt; ( &lt;code&gt;xsubpp&lt;/code&gt; 라고도 함 ) 3.13_01에서 지원하는 기능을 다룹니다 .</target>
        </trans-unit>
        <trans-unit id="5d19d436c676e82c5de62fa2d93b31ad146ee5c7" translate="yes" xml:space="preserve">
          <source>This document defines a standard generic interface to the dynamic linking mechanisms available on many platforms. Its primary purpose is to implement automatic dynamic loading of Perl modules.</source>
          <target state="translated">이 문서는 많은 플랫폼에서 사용 가능한 동적 연결 메커니즘에 대한 표준 일반 인터페이스를 정의합니다. 주요 목적은 Perl 모듈의 자동 동적 로딩을 구현하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="f9a30c0ae237ad22360e4681ed6256da44062757" translate="yes" xml:space="preserve">
          <source>This document describes Thread::Queue version 3.05</source>
          <target state="translated">이 문서에서는 Thread :: Queue 버전 3.05에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="672f477a960d9d97a53477316665e103fc6bcb55" translate="yes" xml:space="preserve">
          <source>This document describes Thread::Queue version 3.14</source>
          <target state="translated">이 문서는 Thread :: Queue 버전 3.14에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="c32625e21916315b56d3d555dca5fa14529f5283" translate="yes" xml:space="preserve">
          <source>This document describes Thread::Semaphore version 2.12</source>
          <target state="translated">이 문서는 Thread :: Semaphore 버전 2.12에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="5e19eb2d41d244928aeeec5e1174bef98f47a6c8" translate="yes" xml:space="preserve">
          <source>This document describes Thread::Semaphore version 2.13</source>
          <target state="translated">이 문서는 Thread :: Semaphore 버전 2.13을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="0a25c4c9828d0f58970f77b7ac6aa566b68c27f1" translate="yes" xml:space="preserve">
          <source>This document describes all backslash and escape sequences. After explaining the role of the backslash, it lists all the sequences that have a special meaning in Perl regular expressions (in alphabetical order), then describes each of them.</source>
          <target state="translated">이 문서는 모든 백 슬래시 및 이스케이프 시퀀스에 대해 설명합니다. 백 슬래시의 역할을 설명하고 나면 Perl 정규 표현식에서 특별한 의미를 갖는 모든 시퀀스 (알파벳순)를 나열한 다음 각각을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="76ff3a8588f27b8cdd8cc7d51db810e080d05732" translate="yes" xml:space="preserve">
          <source>This document describes all of Perl's object-oriented (OO) features from the ground up. If you're just looking to write some object-oriented code of your own, you are probably better served by using one of the object systems from CPAN described in &lt;a href=&quot;perlootut&quot;&gt;perlootut&lt;/a&gt;.</source>
          <target state="translated">이 문서는 모든 Perl의 객체 지향 (OO) 기능을 처음부터 설명합니다. 자신 만의 객체 지향 코드를 작성하려는 경우 &lt;a href=&quot;perlootut&quot;&gt;perlootut에&lt;/a&gt; 설명 된 CPAN의 객체 시스템 중 하나를 사용하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="50f134817136be6999dd57e5d22bbefe3d37d2f5" translate="yes" xml:space="preserve">
          <source>This document describes how Perl internally handles numeric values.</source>
          <target state="translated">이 문서는 Perl이 내부적으로 숫자 값을 처리하는 방법을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="013bbee9fd51be8302723130fd1f7000b8b03cb8" translate="yes" xml:space="preserve">
          <source>This document describes how to set up your host environment when attempting to build Perl for Android.</source>
          <target state="translated">이 문서는 Android 용 Perl 빌드를 시도 할 때 호스트 환경을 설정하는 방법을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="8453dae2d904ec94b51a4ae275d589cad1fe0302" translate="yes" xml:space="preserve">
          <source>This document describes the behavior and implementation of the PerlIO abstraction described in &lt;a href=&quot;perlapio&quot;&gt;perlapio&lt;/a&gt; when &lt;code&gt;USE_PERLIO&lt;/code&gt; is defined.</source>
          <target state="translated">이 문서는 행동에서 설명은 PerlIO 추상화 구현 설명 &lt;a href=&quot;perlapio&quot;&gt;perlapio&lt;/a&gt; 때 &lt;code&gt;USE_PERLIO&lt;/code&gt; 가 정의된다.</target>
        </trans-unit>
        <trans-unit id="a866d5af85544e7e4f21ddcd952a6d5892f7ea0f" translate="yes" xml:space="preserve">
          <source>This document describes the layout of the Perl source tree. If you're hacking on the Perl core, this will help you find what you're looking for.</source>
          <target state="translated">이 문서는 Perl 소스 트리의 레이아웃을 설명합니다. Perl 코어를 해킹하는 경우 원하는 것을 찾는 데 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="327aacce5b60fcb7f0492805932fe1dec841e5bb" translate="yes" xml:space="preserve">
          <source>This document describes threads version 2.01</source>
          <target state="translated">이 문서는 스레드 버전 2.01을 설명합니다</target>
        </trans-unit>
        <trans-unit id="fa650f02e8b505bbf05cadb48d318189989235e1" translate="yes" xml:space="preserve">
          <source>This document describes threads version 2.25</source>
          <target state="translated">이 문서는 스레드 버전 2.25를 설명합니다.</target>
        </trans-unit>
        <trans-unit id="469ac48c0f559cb018049645e8c6431b0895b43b" translate="yes" xml:space="preserve">
          <source>This document describes threads::shared version 1.48</source>
          <target state="translated">이 문서는 threads :: shared 버전 1.48에 대해 설명합니다</target>
        </trans-unit>
        <trans-unit id="6bdb3bba8e288e79f3b2d24456bd5e0dd45bb944" translate="yes" xml:space="preserve">
          <source>This document describes threads::shared version 1.61</source>
          <target state="translated">이 문서는 스레드를 설명합니다 :: 공유 버전 1.61</target>
        </trans-unit>
        <trans-unit id="645bafb8d9dd20a3e1fad46cb6f3fa997de6c937" translate="yes" xml:space="preserve">
          <source>This document describes various features of FreeBSD that will affect how Perl version 5 (hereafter just Perl) is compiled and/or runs.</source>
          <target state="translated">이 문서는 Perl 버전 5 (이하 Perl)의 컴파일 및 / 또는 실행 방법에 영향을주는 FreeBSD의 다양한 기능을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="321b1b1331ddd1b908bf07373d4048f86b3fa9c7" translate="yes" xml:space="preserve">
          <source>This document describes various features of HP's (formerly Compaq's, formerly Digital's) Unix operating system (Tru64) that will affect how Perl version 5 (hereafter just Perl) is configured, compiled and/or runs.</source>
          <target state="translated">이 문서는 Perl 버전 5 (이하 Perl)의 구성, 컴파일 및 / 또는 실행에 영향을주는 HP (이전 Compaq (이전의 Digital)) Unix 운영 체제 (Tru64)의 다양한 기능에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="d268ac5a2d19120ce76c77eb58b90ecc6824f4a2" translate="yes" xml:space="preserve">
          <source>This document describes various features of HP's Unix operating system (HP-UX) that will affect how Perl version 5 (hereafter just Perl) is compiled and/or runs.</source>
          <target state="translated">이 문서는 Perl 버전 5 (이하 Perl)의 컴파일 및 / 또는 실행 방법에 영향을주는 HP Unix 운영 체제 (HP-UX)의 다양한 기능을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="2eba298a6bc6800370faf3fd81957d6c988953ae" translate="yes" xml:space="preserve">
          <source>This document describes various features of IBM's OS/400 operating system that will affect how Perl version 5 (hereafter just Perl) is compiled and/or runs.</source>
          <target state="translated">이 문서는 Perl 버전 5 (이하 Perl)의 컴파일 및 / 또는 실행 방법에 영향을주는 IBM OS / 400 운영 체제의 다양한 기능에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="1043854dc3d305d1c7397cad00b2c0693b02060a" translate="yes" xml:space="preserve">
          <source>This document describes various features of IBM's UNIX operating system AIX that will affect how Perl version 5 (hereafter just Perl) is compiled and/or runs.</source>
          <target state="translated">이 문서는 Perl 버전 5 (이하 Perl)의 컴파일 및 / 또는 실행 방법에 영향을주는 IBM UNIX 운영 체제 AIX의 다양한 기능에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="0e732732feb0181fd46f9c9188d35cc9910b00cf" translate="yes" xml:space="preserve">
          <source>This document describes various features of Irix that will affect how Perl version 5 (hereafter just Perl) is compiled and/or runs.</source>
          <target state="translated">이 문서는 Perl 버전 5 (이하 Perl)를 컴파일 및 / 또는 실행하는 방법에 영향을주는 Irix의 다양한 기능을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="180f34cce99d47d99da56406605f0fb9ba8ddd90" translate="yes" xml:space="preserve">
          <source>This document describes various features of Linux that will affect how Perl version 5 (hereafter just Perl) is compiled and/or runs.</source>
          <target state="translated">이 문서는 Perl 버전 5 (이하 Perl)의 컴파일 및 / 또는 실행 방법에 영향을주는 Linux의 다양한 기능을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="cd165af2963c8b766b7c027487cbd05b923f2018" translate="yes" xml:space="preserve">
          <source>This document describes various features of OpenBSD that will affect how Perl version 5 (hereafter just Perl) is compiled and/or runs.</source>
          <target state="translated">이 문서는 Perl 버전 5 (이하 Perl)의 컴파일 및 / 또는 실행 방법에 영향을주는 OpenBSD의 다양한 기능을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="bc5bdb1f6483dddcfcf934a3487da7243a97f3cc" translate="yes" xml:space="preserve">
          <source>This document describes various features of Sun's Solaris operating system that will affect how Perl version 5 (hereafter just perl) is compiled and/or runs. Some issues relating to the older SunOS 4.x are also discussed, though they may be out of date.</source>
          <target state="translated">이 문서는 Perl 버전 5 (이하 perl)가 컴파일 및 / 또는 실행되는 방식에 영향을주는 Sun Solaris 운영 체제의 다양한 기능을 설명합니다. 오래된 SunOS 4.x와 관련된 일부 문제에 대해서도 설명합니다.</target>
        </trans-unit>
        <trans-unit id="fedada57f7519909ad611f81430777abe7e58861" translate="yes" xml:space="preserve">
          <source>This document describes various features of Synology DSM operating system that will affect how Perl 5 (hereafter just Perl) is configured, compiled and/or runs. It has been compiled and verified by Johan Vromans for the Synology DS413 (QorIQ), with feedback from H.Merijn Brand (DS213, ARMv5tel and RS815, Intel Atom x64).</source>
          <target state="translated">이 문서에서는 Perl 5 (이하 Perl)의 구성, 컴파일 및 / 또는 실행 방식에 영향을 미치는 Synology DSM 운영 체제의 다양한 기능에 대해 설명합니다. H.Merijn Brand (DS213, ARMv5tel 및 RS815, Intel Atom x64)의 피드백과 함께 Johan Vromans가 Synology DS413 (QorIQ) 용으로 컴파일 및 검증했습니다.</target>
        </trans-unit>
        <trans-unit id="757712086ab3b4685f19333593ba82a0d48290a1" translate="yes" xml:space="preserve">
          <source>This document describes various features of the Symbian operating system that will affect how Perl version 5 (hereafter just Perl) is compiled and/or runs.</source>
          <target state="translated">이 문서는 Perl 버전 5 (이하 Perl)의 컴파일 및 / 또는 실행 방법에 영향을주는 Symbian 운영 체제의 다양한 기능을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="fc69a8a87860da299a32df2a5c45e5d6bec2f8df" translate="yes" xml:space="preserve">
          <source>This document describes version 0.13 of encoding::warnings, released June 20, 2016.</source>
          <target state="translated">이 문서는 2016 년 6 월 20 일에 출시 된 encoding :: warnings 버전 0.13에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="a4d121d0bfe8a3c1aa6015bd2c8760d53592dff9" translate="yes" xml:space="preserve">
          <source>This document describes version 0.18 of Locale::Maketext::Simple, released Septermber 8, 2006.</source>
          <target state="translated">이 문서는 2006 년 9 월 8 일에 릴리스 된 Locale :: Maketext :: Simple 버전 0.18에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="5e0659e04f3d9f2056b337b0739a67684597732b" translate="yes" xml:space="preserve">
          <source>This document describes version 0.97 of Attribute::Handlers.</source>
          <target state="translated">이 문서는 Attribute :: Handlers 버전 0.97에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="1605f5eccb40dc73f78c393c35eb29bd098cfb8f" translate="yes" xml:space="preserve">
          <source>This document describes version 1.0 of the</source>
          <target state="translated">이 문서는 버전 1.0에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="2bf780daf1c016bbf9b8bf7bcea84f2fe69f237a" translate="yes" xml:space="preserve">
          <source>This document describes version 1.01 of Attribute::Handlers.</source>
          <target state="translated">이 문서는 Attribute :: Handlers 버전 1.01을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="f171b9809b51bd5f94dba6d702fe833dee48017f" translate="yes" xml:space="preserve">
          <source>This document describes version 1.1 of the</source>
          <target state="translated">이 문서는 버전 1.1에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="11f0cf5695cdecc42b0a56163e7c761e8f4e34ac" translate="yes" xml:space="preserve">
          <source>This document describes version 1.2 of the</source>
          <target state="translated">이 문서는 버전 1.2에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="3fcccd87344b9b0105f05a1d3b78e62bdfe07a5e" translate="yes" xml:space="preserve">
          <source>This document describes version 1.3 of the</source>
          <target state="translated">이 문서는 버전 1.3에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="06ad1cd2f74484f836eb1d92be8f1677db4c49d0" translate="yes" xml:space="preserve">
          <source>This document describes version 1.4 of the</source>
          <target state="translated">이 문서는 버전 1.4에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="d70b159fef5698128cc2ba778d3b9f8c4402065a" translate="yes" xml:space="preserve">
          <source>This document describes version 2 of the CPAN distribution metadata specification, also known as the &quot;CPAN Meta Spec&quot;.</source>
          <target state="translated">이 문서는 &quot;CPAN 메타 사양&quot;이라고도하는 CPAN 배포 메타 데이터 사양의 버전 2를 설명합니다.</target>
        </trans-unit>
        <trans-unit id="00291624b11a3514d125571e1eabaca275507a74" translate="yes" xml:space="preserve">
          <source>This document describes version 2.09 of File::Path, released 2013-01-17.</source>
          <target state="translated">이 문서는 2013 년 1 월 17 일에 릴리스 된 File :: Path 버전 2.09에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="e958fa3bffae7851375960acacad749b89480be8" translate="yes" xml:space="preserve">
          <source>This document differs from &lt;a href=&quot;perlnewmod&quot;&gt;perlnewmod&lt;/a&gt; in that it is a style guide rather than a tutorial on creating CPAN modules. It provides a checklist against which modules can be compared to determine whether they conform to best practice, without necessarily describing in detail how to achieve this.</source>
          <target state="translated">이 문서는 CPAN 모듈 작성에 대한 학습서가 아니라 스타일 안내서라는 점에서 &lt;a href=&quot;perlnewmod&quot;&gt;perlnewmod&lt;/a&gt; 와 다릅니다 . 이를 달성하는 방법을 자세히 설명하지 않고 모듈이 모범 사례를 준수하는지 여부를 판별하기 위해 비교할 수있는 체크리스트를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="f6d0bfb69bb5025df2e411b7c26b2866134bc607" translate="yes" xml:space="preserve">
          <source>This document explains how Perl development works. It includes details about the Perl 5 Porters email list, the Perl repository, the Perl bug tracker, patch guidelines, and commentary on Perl development philosophy.</source>
          <target state="translated">이 문서는 Perl 개발이 작동하는 방법을 설명합니다. 여기에는 Perl 5 Porters 이메일 목록, Perl 저장소, Perl 버그 추적기, 패치 지침 및 Perl 개발 철학에 대한 설명이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="1c365d03a0d07def2d5f697a7dff266e86bfcaee" translate="yes" xml:space="preserve">
          <source>This document explains how Perl development works. It includes details about the Perl 5 Porters email list, the Perl repository, the Perlbug bug tracker, patch guidelines, and commentary on Perl development philosophy.</source>
          <target state="translated">이 문서는 Perl 개발 작동 방식을 설명합니다. 여기에는 Perl 5 Porters 이메일 목록, Perl 저장소, Perlbug 버그 추적기, 패치 지침 및 Perl 개발 철학에 대한 설명이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="1a4e728f85569353c5be0c8060d949669e83dbf4" translate="yes" xml:space="preserve">
          <source>This document gives a condensed list of the features available in the POSIX module. Consult your operating system's manpages for general information on most features. Consult &lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt; for functions which are noted as being identical or almost identical to Perl's builtin functions.</source>
          <target state="translated">이 문서는 POSIX 모듈에서 사용할 수있는 기능의 요약 목록을 제공합니다. 대부분의 기능에 대한 일반 정보는 운영 체제의 맨 페이지를 참조하십시오. Perl의 내장 함수와 동일하거나 거의 동일한 것으로 표시된 함수에 대해서는 &lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="448289ec7a46caaf1d68d5b7cd3ab508bea55402" translate="yes" xml:space="preserve">
          <source>This document gives a condensed list of the features available in the POSIX module. Consult your operating system's manpages for general information on most features. Consult &lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt; for functions which are noted as being identical to Perl's builtin functions.</source>
          <target state="translated">이 문서는 POSIX 모듈에서 사용 가능한 기능의 요약 목록을 제공합니다. 대부분의 기능에 대한 일반적인 정보는 운영 체제 맨 페이지를 참조하십시오. Perl의 내장 기능과 동일한 것으로 표시된 기능에 대해서는 &lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt; 에 문의하십시오 .</target>
        </trans-unit>
        <trans-unit id="b3a9755b0632840622eb25f31414e4542c2feca7" translate="yes" xml:space="preserve">
          <source>This document gives a general idea of Unicode and how to use Unicode in Perl. See &lt;a href=&quot;#Further-Resources&quot;&gt;&quot;Further Resources&quot;&lt;/a&gt; for references to more in-depth treatments of Unicode.</source>
          <target state="translated">이 문서는 유니 코드에 대한 일반적인 개념과 Perl에서 유니 코드를 사용하는 방법을 제공합니다. 유니 코드에 대한보다 심층적 인 처리에 대한 참조는 &lt;a href=&quot;#Further-Resources&quot;&gt;&quot;추가 리소스&quot;&lt;/a&gt; 를 참조 하십시오 .</target>
        </trans-unit>
        <trans-unit id="2fce74951001e7bfa538197dd8bb5ec9f0e07bc5" translate="yes" xml:space="preserve">
          <source>This document gives a general idea of Unicode and how to use Unicode in Perl. See &lt;a href=&quot;#Further-Resources&quot;&gt;Further Resources&lt;/a&gt; for references to more in-depth treatments of Unicode.</source>
          <target state="translated">이 문서는 유니 코드에 대한 일반적인 아이디어와 Perl에서 유니 코드를 사용하는 방법을 제공합니다. 유니 코드에 대한 심층적 인 처리에 대한 참조는 &lt;a href=&quot;#Further-Resources&quot;&gt;추가 자료&lt;/a&gt; 를 참조 하십시오 .</target>
        </trans-unit>
        <trans-unit id="3a55afa937d8de565fbacea117f04c55c4f3d03c" translate="yes" xml:space="preserve">
          <source>This document gives instructions for building Perl for RISC OS. It is complicated by the need to cross compile. There is a binary version of perl available from &lt;a href=&quot;http://www.cp15.org/perl/&quot;&gt;http://www.cp15.org/perl/&lt;/a&gt; which you may wish to use instead of trying to compile it yourself.</source>
          <target state="translated">이 문서는 RISC OS 용 Perl 작성에 대한 지시 사항을 제공합니다. 크로스 컴파일이 필요하기 때문에 복잡합니다. &lt;a href=&quot;http://www.cp15.org/perl/&quot;&gt;http://www.cp15.org/perl/&lt;/a&gt; 에서 사용 가능한 바이너리 버전의 perl이 있으며 , 직접 컴파일하려고하지 않고 사용할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="15f232a362787f4ceadbadf19dad93be195a4a8a" translate="yes" xml:space="preserve">
          <source>This document gives you some suggestions about how to go about writing Perl modules, preparing them for distribution, and making them available via CPAN.</source>
          <target state="translated">이 문서는 Perl 모듈 작성, 배포 준비 및 CPAN을 통해 사용 가능하게하는 방법에 대한 제안을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="132f8081c1f83d30c54e1dd1f8a6c29026e0459f" translate="yes" xml:space="preserve">
          <source>This document has provided several way to go about identifying hot-spots, and checking whether any modifications have improved the runtime of the code.</source>
          <target state="translated">이 문서는 핫스팟을 식별하고 수정 사항으로 인해 코드의 런타임이 향상되었는지 확인하는 여러 가지 방법을 제공했습니다.</target>
        </trans-unit>
        <trans-unit id="1d1186d2059259c57e212c2e5f26480c6a04dbbf" translate="yes" xml:space="preserve">
          <source>This document is about using Pod::Simple to write a Pod processor, generally a Pod formatter. If you just want to know about using an existing Pod formatter, instead see its documentation and see also the docs in &lt;a href=&quot;Pod::Simple&quot;&gt;Pod::Simple&lt;/a&gt;.</source>
          <target state="translated">이 문서는 Pod :: 간단하게 Pod 프로세서 (일반적으로 Pod 포맷터)를 작성하는 방법에 관한 것입니다. 기존 Pod 포맷터 사용에 대해 알고 싶다면 해당 문서를 참조하고 &lt;a href=&quot;Pod::Simple&quot;&gt;Pod :: Simple&lt;/a&gt; 의 문서도 참조하세요 .</target>
        </trans-unit>
        <trans-unit id="2f9e9ade072c3d9b2906bfd078f37006fde1b348" translate="yes" xml:space="preserve">
          <source>This document is an attempt to shine some light on the guts of the regex engine and how it works. The regex engine represents a significant chunk of the perl codebase, but is relatively poorly understood. This document is a meagre attempt at addressing this situation. It is derived from the author's experience, comments in the source code, other papers on the regex engine, feedback on the perl5-porters mail list, and no doubt other places as well.</source>
          <target state="translated">이 문서는 정규식 엔진의 내장과 작동 방식에 대해 간략히 설명하기위한 것입니다. 정규식 엔진은 perl 코드베이스의 상당한 부분을 나타내지 만 비교적 잘 이해되지 않습니다. 이 문서는 이러한 상황을 해결하기위한 빈약 한 시도입니다. 그것은 저자의 경험, 소스 코드의 주석, 정규식 엔진에 대한 다른 논문, perl5-porters 메일 목록에 대한 피드백 및 다른 곳에서도 의심의 여지가 있습니다.</target>
        </trans-unit>
        <trans-unit id="e2f799b102440b11497f30f8301310792802f29f" translate="yes" xml:space="preserve">
          <source>This document is authored and maintained by Gurusamy Sarathy &amp;lt;gsar@activestate.com&amp;gt;.</source>
          <target state="translated">이 문서는 Gurusamy Sarathy &amp;lt;gsar@activestate.com&amp;gt;이 작성하고 관리합니다.</target>
        </trans-unit>
        <trans-unit id="deb0c7f47e4494d30a1aab35b9ec321b01a2ec44" translate="yes" xml:space="preserve">
          <source>This document is available under the same terms as Perl itself. Code examples in all the perlfaq documents are in the public domain. Use them as you see fit (and at your own risk with no warranty from anyone).</source>
          <target state="translated">이 문서는 Perl과 동일한 용어로 사용 가능합니다. 모든 perlfaq 문서의 코드 예제는 공개 도메인에 있습니다. 적합하다고 생각되는대로 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="3ad8de5a753a60df1918818ee7a3cda366409476" translate="yes" xml:space="preserve">
          <source>This document is broken into two sections; those methods that are most useful to the end-developer, and those methods for anyone wishing to subclass or get very familiar with &lt;code&gt;autodie::exception&lt;/code&gt;.</source>
          <target state="translated">이 문서는 두 부분으로 나뉩니다. 최종 개발자에게 가장 유용한 메서드와 &lt;code&gt;autodie::exception&lt;/code&gt; 매우 익숙해 지거나 하위 클래스를 만들고자 하는 모든 사람을위한 메서드입니다 .</target>
        </trans-unit>
        <trans-unit id="931cd9f92a3e4b725c73c5f241d6c52b01e63f35" translate="yes" xml:space="preserve">
          <source>This document is detailed notes on the Pod markup language. Most people will only have to read &lt;a href=&quot;perlpod&quot;&gt;perlpod&lt;/a&gt; to know how to write in Pod, but this document may answer some incidental questions to do with parsing and rendering Pod.</source>
          <target state="translated">이 문서는 포드 마크 업 언어에 대한 자세한 정보입니다. 대부분의 사람들은 포드를 작성하는 방법을 알기 위해 &lt;a href=&quot;perlpod&quot;&gt;perlpod&lt;/a&gt; 만 읽으면 되지만,이 문서는 포드 구문 분석 및 렌더링과 관련하여 부수적 인 질문에 대답 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="030bf2a8075ca167ab3cef3833507c2f42453664" translate="yes" xml:space="preserve">
          <source>This document is distributed with the libnet distribution, and is also available on the libnet web page at</source>
          <target state="translated">이 문서는 libnet 배포와 함께 배포되며 다음의 libnet 웹 페이지에서도 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bf5499e713f269332b5a031b1d5ec104878d26d5" translate="yes" xml:space="preserve">
          <source>This document is intended to give you a quick overview of the Perl programming language, along with pointers to further documentation. It is intended as a &quot;bootstrap&quot; guide for those who are new to the language, and provides just enough information for you to be able to read other peoples' Perl and understand roughly what it's doing, or write your own simple scripts.</source>
          <target state="translated">이 문서는 추가 문서에 대한 포인터와 함께 Perl 프로그래밍 언어에 대한 간략한 개요를 제공합니다. 이 언어는 언어를 처음 접하는 사람들을위한 &quot;부트 스트랩&quot;안내서로, 다른 사람들의 Perl을 읽고 그 내용을 대략 이해하거나 간단한 스크립트를 작성할 수있는 충분한 정보를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="04d450fbf5761325924f000d871533277846798f" translate="yes" xml:space="preserve">
          <source>This document is maintained by Jan Dubois.</source>
          <target state="translated">이 문서는 Jan Dubois가 관리합니다.</target>
        </trans-unit>
        <trans-unit id="6ad1ca1a9c1e0e6df1be4b460cdb832dc533d65a" translate="yes" xml:space="preserve">
          <source>This document is meant to be a detailed but understandable treatment of the many different sorts of data structures you might want to develop. It should also serve as a cookbook of examples. That way, when you need to create one of these complex data structures, you can just pinch, pilfer, or purloin a drop-in example from here.</source>
          <target state="translated">이 문서는 개발하고자하는 다양한 종류의 데이터 구조에 대한 상세하지만 이해하기 쉬운 처리를 목적으로합니다. 또한 예제 요리 책으로도 사용되어야합니다. 이런 식으로 복잡한 데이터 구조 중 하나를 생성해야 할 경우 여기에서 드롭 인 예제를 집어 내거나 모으거나 흘릴 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9bf997dd7f7e98ee160d1fffa9d041813ac9f4bb" translate="yes" xml:space="preserve">
          <source>This document is meant to help you to find out what constitutes portable Perl code. That way once you make a decision to write portably, you know where the lines are drawn, and you can stay within them.</source>
          <target state="translated">이 문서는 휴대용 Perl 코드를 구성하는 요소를 찾는 데 도움이됩니다. 그렇게하면 이식성있는 글을 쓰기로 결정하면 선이 그려지는 곳을 알 수 있으며 그 안에 머물 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9d9f3d95216c84aa89657f351bb6eefc71ea99a0" translate="yes" xml:space="preserve">
          <source>This document is provided in the hope that it will be useful, but without any warranty; without even the implied warranty of accuracy, authoritativeness, completeness, merchantability, or fitness for a particular purpose.</source>
          <target state="translated">이 문서는 도움이 되길 바라지 만 보증없이 제공됩니다. 정확성, 권위, 완전성, 상품성 또는 특정 목적에의 적합성에 대한 묵시적 보증 없이도.</target>
        </trans-unit>
        <trans-unit id="c3a1d5c913f755b58160ddd4ac8b4f8158d38b0a" translate="yes" xml:space="preserve">
          <source>This document is the master document which records all written policies about how the Perl 5 Porters collectively develop and maintain the Perl core.</source>
          <target state="translated">이 문서는 Perl 5 포터가 Perl 코어를 공동으로 개발하고 유지하는 방법에 대한 모든 서면 정책을 기록한 마스터 문서입니다.</target>
        </trans-unit>
        <trans-unit id="6445b4e91fdc1237d3a1bc4a31d98919bdef331e" translate="yes" xml:space="preserve">
          <source>This document lists the current and past experimental features in the perl core. Although all of these are documented with their appropriate topics, this succinct listing gives you an overview and basic facts about their status.</source>
          <target state="translated">이 문서는 펄 코어의 현재 및 과거 실험 기능을 나열합니다. 이들 모두가 적절한 주제와 함께 문서화되어 있지만이 간결한 목록은 해당 상태에 대한 개요 및 기본 사실을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="e04379014fdbc8385dc766fdec2dc2ab609657d0" translate="yes" xml:space="preserve">
          <source>This document may be distributed under the same terms as Perl itself.</source>
          <target state="translated">이 문서는 Perl 자체와 동일한 용어로 배포 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="68809e455146d4d0b2eb575625c0befbf01b3e91" translate="yes" xml:space="preserve">
          <source>This document may be incomplete in some respects.</source>
          <target state="translated">이 문서는 일부 측면에서 불완전 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0888583782e9e5c64acf12be9464dec48a946068" translate="yes" xml:space="preserve">
          <source>This document merely lists all available properties and does not attempt to explain what each property really means. There is a brief description of each Perl extension; see &lt;a href=&quot;perlunicode#Other-Properties&quot;&gt;&quot;Other Properties&quot; in perlunicode&lt;/a&gt; for more information on these. There is some detail about Blocks, Scripts, General_Category, and Bidi_Class in &lt;a href=&quot;perlunicode&quot;&gt;perlunicode&lt;/a&gt;, but to find out about the intricacies of the official Unicode properties, refer to the Unicode standard. A good starting place is &lt;a href=&quot;http://www.unicode.org/reports/tr44/&quot;&gt;http://www.unicode.org/reports/tr44/&lt;/a&gt;.</source>
          <target state="translated">이 문서는 사용 가능한 모든 속성을 나열하고 각 속성이 실제로 무엇을 의미하는지 설명하지 않습니다. 각 Perl 확장에 대한 간략한 설명이 있습니다. &lt;a href=&quot;perlunicode#Other-Properties&quot;&gt;이에&lt;/a&gt; 대한 자세한 내용 은 perlunicode의 &quot;기타 속성&quot;을 참조하십시오 . 거기에서 블록, 스크립트, General_Category 및 Bidi_Class에 대한 몇 가지 세부 사항입니다 &lt;a href=&quot;perlunicode&quot;&gt;perlunicode는&lt;/a&gt; 하지만, 유니 코드 표준을 참조, 공식 유니 코드 속성의 복잡한에 대해 알아. 좋은 출발점은 &lt;a href=&quot;http://www.unicode.org/reports/tr44/&quot;&gt;http://www.unicode.org/reports/tr44/&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="d40e2bd179554762718d2c8f40e4558baafd8315" translate="yes" xml:space="preserve">
          <source>This document merely lists all available properties and does not attempt to explain what each property really means. There is a brief description of each Perl extension; see &lt;a href=&quot;perlunicode#Other-Properties&quot;&gt;Other Properties in perlunicode&lt;/a&gt; for more information on these. There is some detail about Blocks, Scripts, General_Category, and Bidi_Class in &lt;a href=&quot;perlunicode&quot;&gt;perlunicode&lt;/a&gt;, but to find out about the intricacies of the official Unicode properties, refer to the Unicode standard. A good starting place is &lt;a href=&quot;http://www.unicode.org/reports/tr44/&quot;&gt;http://www.unicode.org/reports/tr44/&lt;/a&gt;.</source>
          <target state="translated">이 문서에는 사용 가능한 모든 속성이 나열되어 있으며 각 속성이 실제로 무엇을 의미하는지 설명하지는 않습니다. 각 Perl 확장에 대한 간단한 설명이 있습니다. &lt;a href=&quot;perlunicode#Other-Properties&quot;&gt;이에&lt;/a&gt; 대한 자세한 정보 는 perlunicode의 기타 특성을 참조하십시오 . 거기에서 블록, 스크립트, General_Category 및 Bidi_Class에 대한 몇 가지 세부 사항입니다 &lt;a href=&quot;perlunicode&quot;&gt;perlunicode는&lt;/a&gt; 하지만, 유니 코드 표준을 참조, 공식 유니 코드 속성의 복잡한에 대해 알아. 시작 위치는 &lt;a href=&quot;http://www.unicode.org/reports/tr44/&quot;&gt;http://www.unicode.org/reports/tr44/&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="69e6772a5d46653631303f536faddc78ecd15c3a" translate="yes" xml:space="preserve">
          <source>This document mostly explains the</source>
          <target state="translated">이 문서는 주로</target>
        </trans-unit>
        <trans-unit id="a7ddd5955e611e8402df676dc922c52fe96687d9" translate="yes" xml:space="preserve">
          <source>This document needs a rewrite that separates the tutorial content from the reference content.</source>
          <target state="translated">이 문서는 튜토리얼 컨텐츠를 참조 컨텐츠와 분리하는 재 작성이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="c5434f0b9e2b7cf484cc38556a1c3be222c03edd" translate="yes" xml:space="preserve">
          <source>This document provides a general overview of the capabilities and limitations of the fork() emulation. Note that the issues discussed here are not applicable to platforms where a real fork() is available and Perl has been configured to use it.</source>
          <target state="translated">이 문서는 fork () 에뮬레이션의 기능과 한계에 대한 일반적인 개요를 제공합니다. 여기서 논의 된 문제는 실제 fork ()를 사용할 수 있고 Perl이이를 사용하도록 구성된 플랫폼에는 적용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="93c5711ad21bddf8f27384e848494d1a512f01be" translate="yes" xml:space="preserve">
          <source>This document provides a reference for Perl's object orientation features. If you're looking for an introduction to object-oriented programming in Perl, please see &lt;a href=&quot;perlootut&quot;&gt;perlootut&lt;/a&gt;.</source>
          <target state="translated">이 문서는 Perl의 객체 방향 기능에 대한 참조를 제공합니다. Perl에서 객체 지향 프로그래밍에 대한 소개를 찾고 있다면 &lt;a href=&quot;perlootut&quot;&gt;perlootut&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="46a94276417126d2ba57635546eac62791e072d3" translate="yes" xml:space="preserve">
          <source>This document provides an introduction to object-oriented programming in Perl. It begins with a brief overview of the concepts behind object oriented design. Then it introduces several different OO systems from &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fsearch.cpan.org&quot;&gt;CPAN&lt;/a&gt; which build on top of what Perl provides.</source>
          <target state="translated">이 문서는 Perl의 객체 지향 프로그래밍에 대한 소개를 제공합니다. 객체 지향 디자인의 개념에 대한 간략한 개요로 시작합니다. 그런 다음 Perl이 제공하는 것 위에 구축 된 &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fsearch.cpan.org&quot;&gt;CPAN의&lt;/a&gt; 여러 가지 OO 시스템을 소개 합니다.</target>
        </trans-unit>
        <trans-unit id="32fbffb9ed2f7371e868fa4e9fc51a003e559b60" translate="yes" xml:space="preserve">
          <source>This document provides an introduction to object-oriented programming in Perl. It begins with a brief overview of the concepts behind object oriented design. Then it introduces several different OO systems from &lt;a href=&quot;https://www.cpan.org&quot;&gt;CPAN&lt;/a&gt; which build on top of what Perl provides.</source>
          <target state="translated">이 문서는 Perl의 객체 지향 프로그래밍에 대한 소개를 제공합니다. 객체 지향 디자인의 개념에 대한 간략한 개요로 시작합니다. 그런 다음 Perl이 제공하는 것 위에 구축 된 &lt;a href=&quot;https://www.cpan.org&quot;&gt;CPAN의&lt;/a&gt; 여러 다른 OO 시스템을 소개 합니다.</target>
        </trans-unit>
        <trans-unit id="6876a82e12e5ab947f419b2c224d987985e1ad19" translate="yes" xml:space="preserve">
          <source>This document provides an overview of how the Perl interpreter works at the level of C code, along with pointers to the relevant C source code files.</source>
          <target state="translated">이 문서는 Perl 인터프리터가 관련 C 소스 코드 파일에 대한 포인터와 함께 C 코드 레벨에서 작동하는 방식에 대한 개요를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="37c6cecf4b6aa297d30eab95a37418764fe60217" translate="yes" xml:space="preserve">
          <source>This document provides details on using git to develop Perl. If you are just interested in working on a quick patch, see &lt;a href=&quot;perlhack&quot;&gt;perlhack&lt;/a&gt; first. This document is intended for people who are regular contributors to Perl, including those with write access to the git repository.</source>
          <target state="translated">이 문서에서는 git을 사용하여 Perl을 개발하는 방법에 대해 자세히 설명합니다. 빠른 패치 작업에 관심이 있다면 먼저 &lt;a href=&quot;perlhack&quot;&gt;perlhack을&lt;/a&gt; 참조하십시오 . 이 문서는 git 저장소에 대한 쓰기 권한이있는 사람들을 포함하여 Perl에 정기적으로 기여하는 사람들을위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="7278c04f4b33c2701db9eb4b58232b8395cf3c28" translate="yes" xml:space="preserve">
          <source>This document provides information about the portion of the Unicode database that deals with character properties, that is the portion that is defined on single code points. (&lt;a href=&quot;#Other-information-in-the-Unicode-data-base&quot;&gt;&quot;Other information in the Unicode data base&quot;&lt;/a&gt; below briefly mentions other data that Unicode provides.)</source>
          <target state="translated">이 문서는 문자 속성을 다루는 유니 코드 데이터베이스 부분, 즉 단일 코드 포인트에 정의 된 부분에 대한 정보를 제공합니다. ( 아래의 &lt;a href=&quot;#Other-information-in-the-Unicode-data-base&quot;&gt;&quot;유니 코드 데이터베이스의 기타 정보&quot;&lt;/a&gt; 는 유니 코드가 제공하는 다른 데이터를 간략하게 언급합니다.)</target>
        </trans-unit>
        <trans-unit id="98ef42b4ebd0391f6b1eb2c007891c9540cce7bb" translate="yes" xml:space="preserve">
          <source>This document provides information about the portion of the Unicode database that deals with character properties, that is the portion that is defined on single code points. (&lt;a href=&quot;#Other-information-in-the-Unicode-data-base&quot;&gt;Other information in the Unicode data base&lt;/a&gt; below briefly mentions other data that Unicode provides.)</source>
          <target state="translated">이 문서는 문자 속성을 처리하는 유니 코드 데이터베이스 부분, 즉 단일 코드 포인트에 정의 된 부분에 대한 정보를 제공합니다. ( 아래 &lt;a href=&quot;#Other-information-in-the-Unicode-data-base&quot;&gt;유니 코드 데이터베이스의&lt;/a&gt; 다른 정보는 유니 코드가 제공하는 다른 데이터를 간단히 언급합니다.)</target>
        </trans-unit>
        <trans-unit id="e7cfd37a5d8539271a047f292c9b12d8fd7d71db" translate="yes" xml:space="preserve">
          <source>This document reconstructs the history of the CPAN Meta Spec based on change logs, repository commit messages and the published HTML files. In some cases, particularly prior to version 1.2, the exact version when certain fields were introduced or changed is inconsistent between sources. When in doubt, the published HTML files for versions 1.0 to 1.4 as they existed when version 2 was developed are used as the definitive source.</source>
          <target state="translated">이 문서는 변경 로그, 저장소 커밋 메시지 및 게시 된 HTML 파일을 기반으로 CPAN 메타 사양의 기록을 재구성합니다. 일부 경우, 특히 1.2 이전 버전에서는 특정 필드가 도입되거나 변경된 정확한 버전이 소스간에 일치하지 않습니다. 확실하지 않은 경우 버전 2가 개발 될 때 존재했던 버전 1.0 ~ 1.4 용으로 게시 된 HTML 파일이 최종 소스로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="b2a79746685de57fddf566ba23eb18f1694b69ba" translate="yes" xml:space="preserve">
          <source>This document serves as both a specification for anyone wishing to implement the DynaLoader for a new platform and as a guide for anyone wishing to use the DynaLoader directly in an application.</source>
          <target state="translated">이 문서는 새로운 플랫폼을 위해 DynaLoader를 구현하려는 모든 사람을위한 사양과 애플리케이션에서 직접 DynaLoader를 사용하려는 모든 사람을위한 안내서 역할을합니다.</target>
        </trans-unit>
        <trans-unit id="4c2fd7fb88b1605d6c1c01cd882956329e66498d" translate="yes" xml:space="preserve">
          <source>This document takes you through a simple patch example.</source>
          <target state="translated">이 문서는 간단한 패치 예제를 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="482b84044bf12cbb74ce5534dc67232a2bb4bcd3" translate="yes" xml:space="preserve">
          <source>This document varies from difficult to understand to completely and utterly opaque. The wandering prose riddled with jargon is hard to fathom in several places.</source>
          <target state="translated">이 문서는 이해하기 어려운 것에서부터 완전히 그리고 완전히 불투명 한 것까지 다양합니다. 전문 용어로 가득 찬 방황하는 산문은 여러 곳에서 사기가 어렵습니다.</target>
        </trans-unit>
        <trans-unit id="e494f5a4ef902fd5cb4de9dfa1a90e73e0fc46e2" translate="yes" xml:space="preserve">
          <source>This document walks through the creation of a small patch to Perl's C code. If you're just getting started with Perl core hacking, this will help you understand how it works.</source>
          <target state="translated">이 문서는 Perl의 C 코드에 대한 작은 패치 작성을 안내합니다. Perl 코어 해킹을 시작한 경우 이것이 어떻게 작동하는지 이해하는 데 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="6e368b4b82da174b5c34f4ad74472953966358bf" translate="yes" xml:space="preserve">
          <source>This document was created in February, 2011, and the last major revision was in February, 2013.</source>
          <target state="translated">이 문서는 2011 년 2 월에 작성되었으며 마지막 주요 개정판은 2013 년 2 월에 작성되었습니다.</target>
        </trans-unit>
        <trans-unit id="8a3b26fb452c67444e8240d5b8d2d39b95224d76" translate="yes" xml:space="preserve">
          <source>This document was last revised 8-DEC-2007, for Perl 5.10.0</source>
          <target state="translated">이 문서는 Perl 5.10.0 용으로 2007 년 12 월 8 일 마지막으로 개정되었습니다.</target>
        </trans-unit>
        <trans-unit id="2e05bb5aa5ec020b9cd05ba44bd1e5b7d8efd585" translate="yes" xml:space="preserve">
          <source>This document was last revised on 13-Oct-1998, for Perl 5.004, 5.005, and 5.6.0.</source>
          <target state="translated">이 문서는 Perl 5.004, 5.005 및 5.6.0 용으로 1998 년 10 월 13 일에 마지막으로 개정되었습니다.</target>
        </trans-unit>
        <trans-unit id="e89c4ac20e63934f15f4f06f3bdf35dc35e9054b" translate="yes" xml:space="preserve">
          <source>This document was originally written by David Fiander for the 5.005 release of Perl.</source>
          <target state="translated">이 문서는 원래 David Fiander가 5.005 Perl 릴리스 용으로 작성했습니다.</target>
        </trans-unit>
        <trans-unit id="44116b950aea8406dc1d009e3e7e8df16d0f1901" translate="yes" xml:space="preserve">
          <source>This document was originally written by Nathan Torkington, and is maintained by the perl5-porters mailing list.</source>
          <target state="translated">이 문서는 원래 Nathan Torkington이 작성했으며 perl5-porters 메일 링리스트에 의해 관리됩니다.</target>
        </trans-unit>
        <trans-unit id="cb57f1783ae5d9d11a07aa4ee9a4142c141dd869" translate="yes" xml:space="preserve">
          <source>This document was originally written by Thomas Dorner for the 5.005 release of Perl.</source>
          <target state="translated">이 문서는 원래 Thomas Dorner가 Perl 5.005 릴리스 용으로 작성했습니다.</target>
        </trans-unit>
        <trans-unit id="8245e0ace1fc709b9c52b2d684fbab4d872b4b6b" translate="yes" xml:space="preserve">
          <source>This document was podified for the 5.005_03 release of Perl 11 March 1999.</source>
          <target state="translated">이 문서는 1999 년 3 월 11 일 Perl의 5.005_03 릴리스로 수정되었습니다.</target>
        </trans-unit>
        <trans-unit id="01c73c6cbc6ea7a7507692f73f286583700f23f4" translate="yes" xml:space="preserve">
          <source>This document was podified for the 5.6 release of perl 11 July 2000.</source>
          <target state="translated">이 문서는 2000 년 7 월 11 일 perl의 5.6 릴리스에 맞게 개정되었습니다.</target>
        </trans-unit>
        <trans-unit id="e3d3763f0de441b0bf953c53b8f14562b8c6d91b" translate="yes" xml:space="preserve">
          <source>This document was revised 09-October-1996 for Perl 5.003_7.</source>
          <target state="translated">이 문서는 Perl 5.003_7에 대해 1996 년 10 월 9 일에 개정되었습니다.</target>
        </trans-unit>
        <trans-unit id="1ae9aedfb6e910ab590ab6a48004a6cd92829aac" translate="yes" xml:space="preserve">
          <source>This document will help you Configure, build, test and install Perl on BS2000 in the POSIX subsystem.</source>
          <target state="translated">이 문서는 POSIX 서브 시스템의 BS2000에서 Perl을 구성, 빌드, 테스트 및 설치하는 데 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="ecb2db0bdd80184dad93c70d1f7773c61d926757" translate="yes" xml:space="preserve">
          <source>This document will help you Configure, build, test and install Perl on OS/390 (aka z/OS) Unix System Services.</source>
          <target state="translated">이 문서는 OS / 390 (일명 z / OS) Unix 시스템 서비스에서 Perl을 구성, 빌드, 테스트 및 설치하는 데 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="b14dd21b17eb4778756f16a28286f3080a5b52fc" translate="yes" xml:space="preserve">
          <source>This document will help you configure, make, test and install Perl on Cygwin. This document also describes features of Cygwin that will affect how Perl behaves at runtime.</source>
          <target state="translated">이 문서는 Cygwin에서 Perl을 구성, 작성, 테스트 및 설치하는 데 도움이됩니다. 이 문서는 런타임에 Perl의 작동 방식에 영향을주는 Cygwin의 기능에 대해서도 설명합니다.</target>
        </trans-unit>
        <trans-unit id="4b25a8a1d43deec5996faad1ce1066a1b7f65307" translate="yes" xml:space="preserve">
          <source>This document will help you learn the best way to go about hacking on the Perl core C code. It covers common problems, debugging, profiling, and more.</source>
          <target state="translated">이 문서는 Perl 코어 C 코드를 해킹하는 가장 좋은 방법을 배우는 데 도움이됩니다. 일반적인 문제, 디버깅, 프로파일 링 등을 다룹니다.</target>
        </trans-unit>
        <trans-unit id="bb8154762cb7fc1e9eea1d2d14aa355d5fb6add7" translate="yes" xml:space="preserve">
          <source>This document will try to discuss what alternatives for the deprecated features are available.</source>
          <target state="translated">이 문서에서는 더 이상 사용되지 않는 기능에 대해 사용할 수있는 대안에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="7b1ceac6a2e862b1ba010e29c7ba5c554256d9b3" translate="yes" xml:space="preserve">
          <source>This documentation describes version 0.08.</source>
          <target state="translated">이 문서는 버전 0.08을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="bb13bb5cc25da0a84b0ee6fe56550c8fa997e8a4" translate="yes" xml:space="preserve">
          <source>This documentation is for people who want to download CPAN modules and install them on their own computer.</source>
          <target state="translated">이 문서는 CPAN 모듈을 다운로드하여 자신의 컴퓨터에 설치하려는 사람들을위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="f9807e2f281735ce8b4db75a087a60d39d5eaabb" translate="yes" xml:space="preserve">
          <source>This documentation is free software; you may redistribute it and/or modify it under the same terms as Perl itself.</source>
          <target state="translated">이 문서는 무료 소프트웨어입니다. Perl 자체와 동일한 용어로 재배포 및 / 또는 수정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4e1e03b9948de51dc9fc37899fb9224e953fca3a" translate="yes" xml:space="preserve">
          <source>This documentation is free; you can redistribute it and/or modify it under the same terms as Perl itself.</source>
          <target state="translated">이 문서는 무료입니다. Perl과 동일한 용어로 재배포 및 / 또는 수정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cceba8951b48c0df6a7d7a78ae98404b2be1a5f6" translate="yes" xml:space="preserve">
          <source>This documentation is maintained as part of the podlators distribution. The current version is always available from its web site at &amp;lt;&lt;a href=&quot;http://www.eyrie.org/~eagle/software/podlators/&quot;&gt;http://www.eyrie.org/~eagle/software/podlators/&lt;/a&gt;&amp;gt;.</source>
          <target state="translated">이 문서는 podlators 배포의 일부로 유지됩니다. 현재 버전은 항상 웹 사이트 &amp;lt; &lt;a href=&quot;http://www.eyrie.org/~eagle/software/podlators/&quot;&gt;http://www.eyrie.org/~eagle/software/podlators/&lt;/a&gt; &amp;gt; 에서 구할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="14f1ce292bd49cd739fa4dcd484fe158f74b2d38" translate="yes" xml:space="preserve">
          <source>This documentation is maintained as part of the podlators distribution. The current version is always available from its web site at &lt;a href=&quot;https://www.eyrie.org/~eagle/software/podlators/&quot;&gt;https://www.eyrie.org/~eagle/software/podlators/&lt;/a&gt;.</source>
          <target state="translated">이 문서는 podlators 배포의 일부로 유지됩니다. 현재 버전은 웹 사이트 &lt;a href=&quot;https://www.eyrie.org/~eagle/software/podlators/&quot;&gt;https://www.eyrie.org/~eagle/software/podlators/&lt;/a&gt; 에서 항상 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ee59b544a64dcf3a8c36474bf7a745c77abd72ed" translate="yes" xml:space="preserve">
          <source>This documentation provided by Tels &amp;lt;nospam-abuse@bloodgate.com&amp;gt; 2007.</source>
          <target state="translated">이 문서는 Tels &amp;lt;nospam-abuse@bloodgate.com&amp;gt; 2007에서 제공합니다.</target>
        </trans-unit>
        <trans-unit id="d579dc02247e710bddf4fd80263160b958f95883" translate="yes" xml:space="preserve">
          <source>This does a &lt;code&gt;&lt;a href=&quot;../functions/ref&quot;&gt;ref()&lt;/a&gt;&lt;/code&gt; check on the argument provided. The &lt;code&gt;&lt;a href=&quot;../functions/ref&quot;&gt;ref&lt;/a&gt;&lt;/code&gt; of the argument must be the same as the &lt;code&gt;&lt;a href=&quot;../functions/ref&quot;&gt;ref&lt;/a&gt;&lt;/code&gt; of the default value for this check to pass.</source>
          <target state="translated">제공된 인수에 대해 &lt;code&gt;&lt;a href=&quot;../functions/ref&quot;&gt;ref()&lt;/a&gt;&lt;/code&gt; 검사를 수행합니다. &lt;code&gt;&lt;a href=&quot;../functions/ref&quot;&gt;ref&lt;/a&gt;&lt;/code&gt; 인수의은과 동일해야합니다 &lt;code&gt;&lt;a href=&quot;../functions/ref&quot;&gt;ref&lt;/a&gt;&lt;/code&gt; 이 검사 통과에 대한 기본 값.</target>
        </trans-unit>
        <trans-unit id="4b5cd3d183133e44d31dceabaeef24f14bc16309" translate="yes" xml:space="preserve">
          <source>This does a &lt;code&gt;ref()&lt;/code&gt; check on the argument provided. The &lt;code&gt;ref&lt;/code&gt; of the argument must be the same as the &lt;code&gt;ref&lt;/code&gt; of the default value for this check to pass.</source>
          <target state="translated">제공된 인수에 대한 &lt;code&gt;ref()&lt;/code&gt; 검사를 수행합니다. &lt;code&gt;ref&lt;/code&gt; 인수의은과 동일해야합니다 &lt;code&gt;ref&lt;/code&gt; 이 검사 통과에 대한 기본 값.</target>
        </trans-unit>
        <trans-unit id="dd3d5cb2973c8eb59f68a70871cc8bd14d30329a" translate="yes" xml:space="preserve">
          <source>This does not check for subtypes or method overloading. Use &lt;code&gt;sv_isa_sv&lt;/code&gt; to verify an inheritance relationship in the same way as the &lt;code&gt;isa&lt;/code&gt; operator by respecting any &lt;code&gt;isa()&lt;/code&gt; method overloading; or &lt;code&gt;sv_derived_from_sv&lt;/code&gt; to test directly on the actual object type.</source>
          <target state="translated">하위 유형 또는 메서드 오버로딩을 확인하지 않습니다. 사용 &lt;code&gt;sv_isa_sv&lt;/code&gt; 는 와 동일한 방법으로 상속 관계를 확인하는 &lt;code&gt;isa&lt;/code&gt; 임의 존중 연산자 &lt;code&gt;isa()&lt;/code&gt; 메소드를 오버로드하는 단계; 또는 &lt;code&gt;sv_derived_from_sv&lt;/code&gt; 를 사용하여 실제 개체 유형을 직접 테스트합니다.</target>
        </trans-unit>
        <trans-unit id="fe9382125ff2c139dab5a2974252e8c96e13c1f7" translate="yes" xml:space="preserve">
          <source>This does not check if &lt;code&gt;&lt;a href=&quot;../functions/exists&quot;&gt;exists&lt;/a&gt; $brooklyn{tree}&lt;/code&gt; is true, it checks if it returns 1. Very different. Similar caveats exist for false and 0. In these cases, use &lt;code&gt;ok()&lt;/code&gt; .</source>
          <target state="translated">경우에 확인하지 않는 &lt;code&gt;&lt;a href=&quot;../functions/exists&quot;&gt;exists&lt;/a&gt; $brooklyn{tree}&lt;/code&gt; 사실은 매우 다른 1을 반환하는 경우가 확인. false 및 0에 대해서도 비슷한 경고가 있습니다.이 경우 &lt;code&gt;ok()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="df9ee01c5bea640b9da990c541197d0b2c4c126f" translate="yes" xml:space="preserve">
          <source>This does not check if &lt;code&gt;exists $brooklyn{tree}&lt;/code&gt; is true, it checks if it returns 1. Very different. Similar caveats exist for false and 0. In these cases, use &lt;code&gt;ok()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;exists $brooklyn{tree}&lt;/code&gt; 가 true 인지 확인하지 않고 1을 반환하는지 확인합니다. 매우 다릅니다. false와 0에 대해서도 유사한 경고가 있습니다.이 경우 &lt;code&gt;ok()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dd20b2062f4585400f385fca7062f2de8bbcc3c0" translate="yes" xml:space="preserve">
          <source>This does not consult the local filesystem on Unix, Win32, OS/2 or Mac OS (Classic). It does consult the working environment for VMS (see &lt;a href=&quot;File::Spec::VMS#file_name_is_absolute&quot;&gt;&quot;file_name_is_absolute&quot; in File::Spec::VMS&lt;/a&gt;).</source>
          <target state="translated">이것은 Unix, Win32, OS / 2 또는 Mac OS (Classic)의 로컬 파일 시스템을 참조하지 않습니다. VMS의 작업 환경을 참조합니다 ( &lt;a href=&quot;File::Spec::VMS#file_name_is_absolute&quot;&gt;File :: Spec :: VMS의 &quot;file_name_is_absolute&quot;&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="98a4bb476f64546166599da65496591b48105011" translate="yes" xml:space="preserve">
          <source>This does not consult the local filesystem on Unix, Win32, OS/2 or Mac OS (Classic). It does consult the working environment for VMS (see &lt;a href=&quot;vms#file_name_is_absolute&quot;&gt;file_name_is_absolute in File::Spec::VMS&lt;/a&gt;).</source>
          <target state="translated">Unix, Win32, OS / 2 또는 Mac OS (Classic)의 로컬 파일 시스템은 참조하지 않습니다. VMS의 작업 환경을 참조합니다 ( &lt;a href=&quot;vms#file_name_is_absolute&quot;&gt;File :: Spec :: VMS의 file_name_is_absolute&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="05ba9e904da127ea409d891d030eef9da471aef5" translate="yes" xml:space="preserve">
          <source>This does not consult the local filesystem on Unix, Win32, OS/2, or Mac OS (Classic). It does consult the working environment for VMS (see &lt;a href=&quot;File::Spec::VMS#file_name_is_absolute&quot;&gt;&quot;file_name_is_absolute&quot; in File::Spec::VMS&lt;/a&gt;).</source>
          <target state="translated">이것은 Unix, Win32, OS / 2 또는 Mac OS (Classic)의 로컬 파일 시스템을 참조하지 않습니다. VMS의 작업 환경을 참조합니다 ( &lt;a href=&quot;File::Spec::VMS#file_name_is_absolute&quot;&gt;File :: Spec :: VMS의 &quot;file_name_is_absolute&quot;&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="5567db63aec81d4f2bb7d5785e7a6d2074129096" translate="yes" xml:space="preserve">
          <source>This does not consult the local filesystem on Unix, Win32, OS/2, or Mac OS (Classic). It does consult the working environment for VMS (see &lt;a href=&quot;spec/vms#file_name_is_absolute&quot;&gt;file_name_is_absolute in File::Spec::VMS&lt;/a&gt;).</source>
          <target state="translated">Unix, Win32, OS / 2 또는 Mac OS (Classic)의 로컬 파일 시스템은 참조하지 않습니다. VMS의 작업 환경을 참조합니다 ( &lt;a href=&quot;spec/vms#file_name_is_absolute&quot;&gt;File :: Spec :: VMS의 file_name_is_absolute&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="c944650291e0fb3160694a6ec50737cfb06a9680" translate="yes" xml:space="preserve">
          <source>This does not create any methods for you, it just adds the &lt;code&gt;FOO&lt;/code&gt; constant.</source>
          <target state="translated">이것은 당신을 위해 어떤 메소드도 생성하지 않으며 단지 &lt;code&gt;FOO&lt;/code&gt; 상수를 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="0a35bcc864cbc531874ff7b69a1ed16eb2d6e952" translate="yes" xml:space="preserve">
          <source>This does not need an interpreter context, so the definition has no &lt;code&gt;pTHX&lt;/code&gt; , and it follows that callers don't use &lt;code&gt;aTHX&lt;/code&gt; . (See &lt;a href=&quot;#Background-and-PERL_IMPLICIT_CONTEXT&quot;&gt;Background and PERL_IMPLICIT_CONTEXT&lt;/a&gt;.)</source>
          <target state="translated">인터프리터 컨텍스트가 필요하지 않으므로 정의에는 &lt;code&gt;pTHX&lt;/code&gt; 가 없으며 호출자가 &lt;code&gt;aTHX&lt;/code&gt; 를 사용하지 않습니다 . ( &lt;a href=&quot;#Background-and-PERL_IMPLICIT_CONTEXT&quot;&gt;배경 및 PERL_IMPLICIT_CONTEXT&lt;/a&gt; 참조 )</target>
        </trans-unit>
        <trans-unit id="c9d579d4202051060b7b7bc5b1e8166efc37986d" translate="yes" xml:space="preserve">
          <source>This does not work with object methods, however; all object methods have to be in the symbol table of some package to be found. See &lt;a href=&quot;perlref#Function-Templates&quot;&gt;&quot;Function Templates&quot; in perlref&lt;/a&gt; for something of a work-around to this.</source>
          <target state="translated">그러나 이것은 객체 메소드에서는 작동하지 않습니다. 모든 개체 메서드는 찾을 수있는 일부 패키지의 기호 테이블에 있어야합니다. 이에 대한 해결 방법 &lt;a href=&quot;perlref#Function-Templates&quot;&gt;은 perlref의 &quot;함수 템플릿&quot;을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="7d5400494835955231d73bab6efd7d27c959f429" translate="yes" xml:space="preserve">
          <source>This does not work with object methods, however; all object methods have to be in the symbol table of some package to be found. See &lt;a href=&quot;perlref#Function-Templates&quot;&gt;Function Templates in perlref&lt;/a&gt; for something of a work-around to this.</source>
          <target state="translated">그러나 객체 메소드에서는 작동하지 않습니다. 모든 객체 메소드는 발견 할 패키지의 심볼 테이블에 있어야합니다. 이에 대한 해결 방법 &lt;a href=&quot;perlref#Function-Templates&quot;&gt;은 perlref의 함수 템플리트를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0d2225ec395dc726d6f789db247181b8752831a9" translate="yes" xml:space="preserve">
          <source>This does require you to read the entire archive in to memory first, since otherwise we wouldn't know what data to fill the copy with. (This means that you cannot use the class methods, including &lt;code&gt;iter&lt;/code&gt; on archives that have incompatible filetypes and still expect things to work).</source>
          <target state="translated">이를 위해서는 먼저 전체 아카이브를 메모리로 읽어야합니다. 그렇지 않으면 복사본을 채울 데이터를 알 수 없기 때문입니다. (이것은 호환되지 않는 파일 형식이 있고 여전히 작동하는 아카이브의 &lt;code&gt;iter&lt;/code&gt; 를 포함한 클래스 메소드를 사용할 수 없음을 의미합니다 ).</target>
        </trans-unit>
        <trans-unit id="d695e6a31e5a4eec6a56e77d637d17eb575265f8" translate="yes" xml:space="preserve">
          <source>This does the same:</source>
          <target state="translated">이것은 동일합니다 :</target>
        </trans-unit>
        <trans-unit id="dc02dd18bd8bcc4ec6d08efce5d8f98b8592ad09" translate="yes" xml:space="preserve">
          <source>This doesn't copy the underlying array:</source>
          <target state="translated">이것은 기본 배열을 복사하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6a45cffcf59adcdd497d8553e6a4ac8aa27d7fd9" translate="yes" xml:space="preserve">
          <source>This doesn't do anything to your input, or to your output. It only influences the way your sources are read. You can use Unicode in string literals, in identifiers (but they still have to be &quot;word characters&quot; according to &lt;code&gt;\w&lt;/code&gt; ), and even in custom delimiters.</source>
          <target state="translated">이것은 입력이나 출력에 아무런 영향을 미치지 않습니다. 소스를 읽는 방식에만 영향을 미칩니다. 문자열 리터럴, 식별자 ( &lt;code&gt;\w&lt;/code&gt; 에 따라 &quot;단어 문자&quot;여야 함 ) 및 사용자 지정 구분 기호로 유니 코드를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="12b7a18a1b05ee982fef7d28da1abc2f543dc36e" translate="yes" xml:space="preserve">
          <source>This doesn't do anything to your input, or to your output. It only influences the way your sources are read. You can use Unicode in string literals, in identifiers (but they still have to be &quot;word characters&quot; according to &lt;code&gt;\w&lt;/code&gt;), and even in custom delimiters.</source>
          <target state="translated">이것은 입력이나 출력에 아무런 영향을 미치지 않습니다. 소스를 읽는 방식에만 영향을 미칩니다. 문자열 리터럴, 식별자 ( &lt;code&gt;\w&lt;/code&gt; 에 따라 &quot;단어 문자&quot;여야 함 ) 및 사용자 지정 구분 기호에서도 유니 코드를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c08d4d18717ad728adb161ebb6ace72d574c3c92" translate="yes" xml:space="preserve">
          <source>This doesn't mean that a &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; variable declared in a statically enclosing lexical scope would be invisible. Only dynamic scopes are cut off. For example, the &lt;code&gt;bumpx()&lt;/code&gt; function below has access to the lexical $x variable because both the &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; and the &lt;code&gt;&lt;a href=&quot;functions/sub&quot;&gt;sub&lt;/a&gt;&lt;/code&gt; occurred at the same scope, presumably file scope.</source>
          <target state="translated">이것은 정적으로 둘러싸는 어휘 범위에서 선언 된 &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; 변수 가 보이지 않음을 의미하지는 않습니다 . 동적 범위 만 잘립니다. 예를 들어, 아래 의 &lt;code&gt;bumpx()&lt;/code&gt; 함수는 &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; 와 &lt;code&gt;&lt;a href=&quot;functions/sub&quot;&gt;sub&lt;/a&gt;&lt;/code&gt; 가 모두 같은 범위, 아마도 파일 범위에서 발생 했기 때문에 어휘 $ x 변수에 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e3b62eb82fdb946fa7043b5f1daf9c10f822dc0f" translate="yes" xml:space="preserve">
          <source>This doesn't mean that a &lt;code&gt;my&lt;/code&gt; variable declared in a statically enclosing lexical scope would be invisible. Only dynamic scopes are cut off. For example, the &lt;code&gt;bumpx()&lt;/code&gt; function below has access to the lexical $x variable because both the &lt;code&gt;my&lt;/code&gt; and the &lt;code&gt;sub&lt;/code&gt; occurred at the same scope, presumably file scope.</source>
          <target state="translated">이것은 정적으로 둘러싸는 어휘 범위에서 선언 된 &lt;code&gt;my&lt;/code&gt; 변수 가 보이지 않는다는 것을 의미하지는 않습니다 . 동적 범위 만 잘립니다. 예를 들어 아래 의 &lt;code&gt;bumpx()&lt;/code&gt; 함수는 &lt;code&gt;my&lt;/code&gt; 와 &lt;code&gt;sub&lt;/code&gt; 가 동일한 범위, 아마도 파일 범위에서 발생 했기 때문에 어휘 $ x 변수에 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f510646e09469823e3fdbdaaa6f4bdb12a95ec4e" translate="yes" xml:space="preserve">
          <source>This doesn't really improve the legibility of this example, but it's available in case you want it. Squashing the pattern down to the compact form, we have</source>
          <target state="translated">이것은이 예제의 가독성을 실제로 향상 시키지는 않지만 원하는 경우에 사용할 수 있습니다. 패턴을 콤팩트 한 형태로 스 쿼싱하면</target>
        </trans-unit>
        <trans-unit id="e40a26e5ea83812803ea5b81ef047b1db82eff02" translate="yes" xml:space="preserve">
          <source>This doesn't work if you explicitly specify a loop variable, as in &lt;code&gt;for $item (@array)&lt;/code&gt; . You have to use the default variable &lt;code&gt;$_&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;for $item (@array)&lt;/code&gt; 에서와 같이 루프 변수를 명시 적으로 지정하면 작동하지 않습니다 . 기본 변수 &lt;code&gt;$_&lt;/code&gt; 를 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="95e51f60aa318824f02d1eda227d14c25f989db1" translate="yes" xml:space="preserve">
          <source>This doesn't work if you explicitly specify a loop variable, as in &lt;code&gt;for $item (@array)&lt;/code&gt;. You have to use the default variable &lt;code&gt;$_&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;for $item (@array)&lt;/code&gt; 와 같이 루프 변수를 명시 적으로 지정하면 작동하지 않습니다 . 기본 변수 &lt;code&gt;$_&lt;/code&gt; 를 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="a2c583421317d67ae6f6464366487994f4149ea1" translate="yes" xml:space="preserve">
          <source>This doesn't work so cleanly for varargs functions, though, as macros imply that the number of arguments is known in advance. Instead we either need to spell them out fully, passing &lt;code&gt;aTHX_&lt;/code&gt; as the first argument (the Perl core tends to do this with functions like Perl_warner), or use a context-free version.</source>
          <target state="translated">매크로가 인수의 수를 미리 알고 있음을 암시하므로 varargs 함수에는 그렇게 작동하지 않습니다. 대신 &lt;code&gt;aTHX_&lt;/code&gt; 를 첫 번째 인수로 전달 하거나 (Perl 코어가 Perl_warner와 같은 기능을 사용하는 경향이 있음) 컨텍스트없이 버전을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="e02629217bd3e65d041e0afd10431e9bff745dcf" translate="yes" xml:space="preserve">
          <source>This dummy class exists to signal that the class inheriting it should be skipped when reporting exceptions from autodie. This is useful for utility classes like &lt;a href=&quot;Path::Tiny&quot;&gt;Path::Tiny&lt;/a&gt; that wish to report the location of where they were called on failure.</source>
          <target state="translated">이 더미 클래스는 autodie에서 예외를보고 할 때이를 상속하는 클래스를 건너 뛰어야 함을 알리기 위해 존재합니다. 이것은 실패시 호출 된 위치를보고하려는 &lt;a href=&quot;Path::Tiny&quot;&gt;Path :: Tiny&lt;/a&gt; 와 같은 유틸리티 클래스에 유용합니다 .</target>
        </trans-unit>
        <trans-unit id="dd35b5e520e91c0129daf21db3448c07f88b99cf" translate="yes" xml:space="preserve">
          <source>This effect can be demonstrated by setting up a test script with both forms, including a &lt;code&gt;debug()&lt;/code&gt; subroutine to emulate typical &lt;code&gt;logger()&lt;/code&gt; functionality.</source>
          <target state="translated">이 효과는 다음을 포함하여 두 가지 형식으로 테스트 스크립트를 설정하여 설명 할 수 있습니다. &lt;code&gt;debug()&lt;/code&gt; 일반적인 &lt;code&gt;logger()&lt;/code&gt; 기능 을 에뮬레이트하기 위해 debug () 서브 루틴을 .</target>
        </trans-unit>
        <trans-unit id="fbe2310a8ff7d61c27678f186cd1f8d32e53b8ee" translate="yes" xml:space="preserve">
          <source>This effectively means that your source code behaves as if it were written in UTF-8 with &lt;code&gt;'use utf8&lt;/code&gt; ' in effect. So even if your editor only supports Shift_JIS, for example, you can still try examples in Chapter 15 of &lt;code&gt;Programming Perl, 3rd Ed.&lt;/code&gt;.</source>
          <target state="translated">이는 소스 코드가 마치 UTF-8로 작성된 것처럼 동작 함을 의미합니다. &lt;code&gt;'use utf8&lt;/code&gt; '을 사용 . 예를 들어 편집기가 Shift_JIS 만 지원하더라도 &lt;code&gt;Programming Perl, 3rd Ed.&lt;/code&gt; 15 장에서 예제를 시도 할 수 있습니다 . .</target>
        </trans-unit>
        <trans-unit id="2dec00720dbccd0f2c23e14f01bf267bdc96f79b" translate="yes" xml:space="preserve">
          <source>This effectively means that your source code behaves as if it were written in UTF-8 with &lt;code&gt;'use utf8&lt;/code&gt;' in effect. So even if your editor only supports Shift_JIS, for example, you can still try examples in Chapter 15 of &lt;code&gt;Programming Perl, 3rd Ed.&lt;/code&gt;.</source>
          <target state="translated">이는 소스 코드가 마치 &lt;code&gt;'use utf8&lt;/code&gt; '이 적용된 UTF-8로 작성된 것처럼 작동한다는 것을 의미합니다 . 따라서 예를 들어 편집기가 Shift_JIS 만 지원하더라도 &lt;code&gt;Programming Perl, 3rd Ed.&lt;/code&gt; 15 장에서 예제를 시도해 볼 수 있습니다 . .</target>
        </trans-unit>
        <trans-unit id="cdd4da3883eaa1f4535d75812114c437bcce2b57" translate="yes" xml:space="preserve">
          <source>This empty set of prereqs is useful for accumulating new prereqs before finally dumping the whole set into a structure or string.</source>
          <target state="translated">이 빈 전제 조건 세트는 최종적으로 전체 세트를 구조 또는 문자열로 덤프하기 전에 새 전제 조건을 누적하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="19bf4c61bc03e7bbdfa7f772178436c7814ff1bf" translate="yes" xml:space="preserve">
          <source>This enables (or disables) all of the &lt;code&gt;indent&lt;/code&gt;, &lt;code&gt;space_before&lt;/code&gt; and &lt;code&gt;space_after&lt;/code&gt; (and in the future possibly more) flags in one call to generate the most readable (or most compact) form possible.</source>
          <target state="translated">이렇게하면 한 번의 호출에서 모든 &lt;code&gt;indent&lt;/code&gt; , &lt;code&gt;space_before&lt;/code&gt; 및 &lt;code&gt;space_after&lt;/code&gt; (그리고 앞으로는 더 많은) 플래그를 활성화 (또는 비활성화) 하여 가능한 가장 읽기 쉬운 (또는 가장 압축 된) 형식을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="f3a80c354b71b0daaada6c4b42d328f1e3ab3798" translate="yes" xml:space="preserve">
          <source>This enables a trace mode and is primarily for debugging bigint or Math::BigInt.</source>
          <target state="translated">이것은 추적 모드를 가능하게하며 주로 bigint 또는 Math :: BigInt를 디버깅하기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="9c02cc31d70507771fd57c515a75adc482efe06a" translate="yes" xml:space="preserve">
          <source>This enables a trace mode and is primarily for debugging bignum or Math::BigInt/Math::BigFloat.</source>
          <target state="translated">이는 추적 모드를 가능하게하며 주로 bignum 또는 Math :: BigInt / Math :: BigFloat를 디버깅하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="cec63c166c07d8ad2b6a0564923160e4e6afd3a9" translate="yes" xml:space="preserve">
          <source>This enables aliasing via assignment to references:</source>
          <target state="translated">이를 통해 참조 할당을 통해 앨리어싱을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f0c59e41b4a3df893d1d884cf9253595b11ba6fc" translate="yes" xml:space="preserve">
          <source>This enables debugging output when calling commandline utilities to fetch files. This also enables &lt;code&gt;Carp::longmess&lt;/code&gt; errors, instead of the regular &lt;code&gt;carp&lt;/code&gt; errors.</source>
          <target state="translated">파일을 가져 오기 위해 명령 줄 유틸리티를 호출 할 때 출력을 디버깅 할 수 있습니다. 또한 일반 &lt;code&gt;carp&lt;/code&gt; 대신 &lt;code&gt;Carp::longmess&lt;/code&gt; 오류를 활성화 합니다 오류 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="79613693422bd25bf48f5f8810aa0da8bd572cf9" translate="yes" xml:space="preserve">
          <source>This enables declaration of subroutines via &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; sub foo&lt;/code&gt; , &lt;code&gt;state sub foo&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt; sub foo&lt;/code&gt; syntax. See &lt;a href=&quot;perlsub#Lexical-Subroutines&quot;&gt;Lexical Subroutines in perlsub&lt;/a&gt; for details.</source>
          <target state="translated">이를 통해 서브 루틴의 선언을 할 수 있습니다 &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; sub foo&lt;/code&gt; , &lt;code&gt;state sub foo&lt;/code&gt; 와 &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt; sub foo&lt;/code&gt; 구문. 자세한 내용 &lt;a href=&quot;perlsub#Lexical-Subroutines&quot;&gt;은 perlsub의 어휘 서브 루틴을&lt;/a&gt; 참조 하십시오.</target>
        </trans-unit>
        <trans-unit id="80e1dcd9c198904d910331965aa69cd1ca8bccf4" translate="yes" xml:space="preserve">
          <source>This enables the programmer to do operations that combine functionalities that are available in the shell.</source>
          <target state="translated">이를 통해 프로그래머는 쉘에서 사용 가능한 기능을 결합하는 조작을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e90120b49b0763003fb5ddee58d3021476d96c8e" translate="yes" xml:space="preserve">
          <source>This enables unpacking of subroutine arguments into lexical variables by syntax such as</source>
          <target state="translated">이를 통해 다음과 같은 구문으로 서브 루틴 인수를 어휘 변수에 풀 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b1b55e253e92ad7341b5b1784881c341c542cf5a" translate="yes" xml:space="preserve">
          <source>This entry can be used to store a C structure (the number of bytes to be copied is calculated using the C &lt;code&gt;sizeof&lt;/code&gt; function) and can be used as an alternative to T_PTRREF without having to worry about a memory leak (since Perl will clean up the SV).</source>
          <target state="translated">이 항목은 C 구조를 저장하는 데 사용할 수 있습니다 (복사 할 바이트 수는 C &lt;code&gt;sizeof&lt;/code&gt; 를 사용하여 계산 됨) 함수를 ) 메모리 누출에 대해 걱정할 필요없이 T_PTRREF의 대안으로 사용할 수 있습니다 (Perl은 SV).</target>
        </trans-unit>
        <trans-unit id="a7bcaf8e2d3812b33c786936976ed8fae77f4ec3" translate="yes" xml:space="preserve">
          <source>This entry describes the bug tracking system for this distribution. It is a Map with the following valid keys:</source>
          <target state="translated">이 항목은이 배포에 대한 버그 추적 시스템을 설명합니다. 다음과 같은 유효한 키가있는 맵입니다.</target>
        </trans-unit>
        <trans-unit id="f61acce6a24046d03b3ed1b4333f40651db8171b" translate="yes" xml:space="preserve">
          <source>This entry describes the source control repository for this distribution. It is a Map with the following valid keys:</source>
          <target state="translated">이 항목은이 배포에 대한 소스 제어 저장소를 설명합니다. 다음과 같은 유효한 키가있는 맵입니다.</target>
        </trans-unit>
        <trans-unit id="8661dce79cd9938b29ab6189f268d624e4b465ea" translate="yes" xml:space="preserve">
          <source>This entry is required and has the same structure as that of the &lt;code&gt;&lt;a href=&quot;#prereqs&quot;&gt;&quot;prereqs&quot;&lt;/a&gt;&lt;/code&gt; key. It provides a list of package requirements that must be satisfied for the feature to be supported or enabled.</source>
          <target state="translated">이 항목은 필수이며 &lt;code&gt;&lt;a href=&quot;#prereqs&quot;&gt;&quot;prereqs&quot;&lt;/a&gt;&lt;/code&gt; 키 의 구조와 동일 합니다. 기능을 지원하거나 활성화하기 위해 충족해야하는 패키지 요구 사항 목록을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="2f3300c27110c85898913011cf397618813e91ac" translate="yes" xml:space="preserve">
          <source>This environment variable allows the user to specify custom color aliases that will be understood by color(), colored(), and colorvalid(). None of the other functions will be affected, and no new color constants will be created. The custom colors are aliases for existing color names; no new escape sequences can be introduced. Only alphanumerics, &lt;code&gt;.&lt;/code&gt;, &lt;code&gt;_&lt;/code&gt; , and &lt;code&gt;-&lt;/code&gt; are allowed in alias names.</source>
          <target state="translated">이 환경 변수를 사용하면 color (), colored () 및 colorvalid ()로 이해할 수있는 사용자 정의 색상 별명을 지정할 수 있습니다. 다른 기능은 영향을받지 않으며 새로운 색 상수가 생성되지 않습니다. 사용자 정의 색상은 기존 색상 이름의 별명입니다. 새로운 이스케이프 시퀀스를 도입 할 수 없습니다. 영숫자 만 &lt;code&gt;.&lt;/code&gt; 별명에는 , &lt;code&gt;_&lt;/code&gt; 및 &lt;code&gt;-&lt;/code&gt; 가 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="fe4e2bcc9ac8969fe47b9592f17295a43be470a9" translate="yes" xml:space="preserve">
          <source>This environment variable allows the user to specify custom color aliases that will be understood by color(), colored(), and colorvalid(). None of the other functions will be affected, and no new color constants will be created. The custom colors are aliases for existing color names; no new escape sequences can be introduced. Only alphanumerics, &lt;code&gt;.&lt;/code&gt;, &lt;code&gt;_&lt;/code&gt;, and &lt;code&gt;-&lt;/code&gt; are allowed in alias names.</source>
          <target state="translated">이 환경 변수를 통해 사용자는 color (), colors () 및 colorvalid ()에서 이해할 수있는 사용자 정의 색상 별칭을 지정할 수 있습니다. 다른 기능은 영향을받지 않으며 새로운 색상 상수가 생성되지 않습니다. 사용자 정의 색상은 기존 색상 이름의 별칭입니다. 새로운 이스케이프 시퀀스를 도입 할 수 없습니다. 영숫자 만, &lt;code&gt;.&lt;/code&gt; , &lt;code&gt;_&lt;/code&gt; 및 &lt;code&gt;-&lt;/code&gt; 는 별칭 이름에 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="eeb4dcf1cb6c13fe396a4c4857e58d83a3e881a1" translate="yes" xml:space="preserve">
          <source>This environment variable is read and applied when the Term::ANSIColor module is loaded and is then subsequently ignored. Changes to ANSI_COLORS_ALIASES after the module is loaded will have no effect. See coloralias() for an equivalent facility that can be used at runtime.</source>
          <target state="translated">이 환경 변수는 Term :: ANSIColor 모듈을로드 한 다음 무시할 때 읽고 적용됩니다. 모듈이로드 된 후 ANSI_COLORS_ALIASES를 변경해도 아무런 영향이 없습니다. 런타임에 사용할 수있는 동등한 기능에 대해서는 coloralias ()를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="a56aa6c0940d68ef241fe55a79ac7479a8552c55" translate="yes" xml:space="preserve">
          <source>This environment variable, available starting in Perl v5.20, if set (to any value), tells Perl to not use the rest of the environment variables to initialize with. Instead, Perl uses whatever the current locale settings are. This is particularly useful in embedded environments, see &lt;a href=&quot;perlembed#Using-embedded-Perl-with-POSIX-locales&quot;&gt;&quot;Using embedded Perl with POSIX locales&quot; in perlembed&lt;/a&gt;.</source>
          <target state="translated">Perl v5.20부터 사용할 수있는이 환경 변수는 설정된 경우 (임의의 값으로) Perl에게 나머지 환경 변수를 사용하여 초기화하지 않도록 지시합니다. 대신 Perl은 현재 로케일 설정이 무엇이든 사용합니다. 이것은 임베디드 환경에서 특히 유용합니다 . &lt;a href=&quot;perlembed#Using-embedded-Perl-with-POSIX-locales&quot;&gt;perlembed의 &quot;POSIX 로케일과 함께 임베디드 Perl 사용&quot;을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="08e7401d917dc7c04b41058352f2e564e79feab2" translate="yes" xml:space="preserve">
          <source>This environment variable, available starting in Perl v5.20, if set (to any value), tells Perl to not use the rest of the environment variables to initialize with. Instead, Perl uses whatever the current locale settings are. This is particularly useful in embedded environments, see &lt;a href=&quot;perlembed#Using-embedded-Perl-with-POSIX-locales&quot;&gt;Using embedded Perl with POSIX locales in perlembed&lt;/a&gt;.</source>
          <target state="translated">Perl v5.20부터 사용할 수있는이 환경 변수는 값이 설정되어 있으면 Perl에게 나머지 환경 변수를 사용하여 초기화하지 않도록 지시합니다. 대신, Perl은 현재 로케일 설정을 사용합니다. 이는 임베디드 환경에서 특히 유용 &lt;a href=&quot;perlembed#Using-embedded-Perl-with-POSIX-locales&quot;&gt;합니다. perlembed에서 POSIX 로케일로 임베디드 Perl 사용을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="3d75c6a399680a576578e1b3ba02163c5eecb504" translate="yes" xml:space="preserve">
          <source>This error is generated when it is not possible to find the local definitions for error codes, due to the uncommon structure of the Synology file system.</source>
          <target state="translated">이 오류는 Synology 파일 시스템의 일반적이지 않은 구조로 인해 오류 코드에 대한 로컬 정의를 찾을 수 없을 때 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="6ace5510a8ff1a4d0b9f61bb6ded0bf5e3670db9" translate="yes" xml:space="preserve">
          <source>This error was fixed in the Perl development git for version 5.19, commit 7a8f1212e5482613c8a5b0402528e3105b26ff24.</source>
          <target state="translated">이 오류는 버전 5.19 용 Perl 개발 git에서 수정되었으며 7a8f1212e5482613c8a5b0402528e3105b26ff24를 커밋했습니다.</target>
        </trans-unit>
        <trans-unit id="01f9c0ecaa03744be9ea320c0c4f588e6b9faad8" translate="yes" xml:space="preserve">
          <source>This evaluates STRING as perl code inside the compartment.</source>
          <target state="translated">이것은 STRING을 구획 내부의 펄 코드로 평가합니다.</target>
        </trans-unit>
        <trans-unit id="8e88fee13fdd53ae93ae82bca131dd3e051006da" translate="yes" xml:space="preserve">
          <source>This evaluates the contents of file FILENAME inside the compartment. It uses the same rules as perl's built-in &lt;code&gt;do&lt;/code&gt; to locate the file, poossibly using &lt;code&gt;@INC&lt;/code&gt;.</source>
          <target state="translated">구획 내부에있는 FILENAME 파일의 내용을 평가합니다. perl의 내장 &lt;code&gt;do&lt;/code&gt; 와 동일한 규칙을 사용하여 파일을 찾습니다 . 아마도 &lt;code&gt;@INC&lt;/code&gt; 를 사용 합니다.</target>
        </trans-unit>
        <trans-unit id="85da3ed8e7eeed1d7664ca9b45804ed926dd64a7" translate="yes" xml:space="preserve">
          <source>This evaluates the contents of file FILENAME inside the compartment. See above documentation on the &lt;b&gt;reval&lt;/b&gt; method for further details.</source>
          <target state="translated">구획 내 파일 FILENAME의 내용을 평가합니다. 자세한 내용은 위의 &lt;b&gt;평가&lt;/b&gt; 방법 문서를 참조 하십시오.</target>
        </trans-unit>
        <trans-unit id="668473c118073b55874da4472c5e05758203ab13" translate="yes" xml:space="preserve">
          <source>This evaluates to true if and only if the string in the variable &lt;code&gt;$foo&lt;/code&gt; contains somewhere in it, the sequence of characters &quot;a&quot;, &quot;b&quot;, then &quot;c&quot;. (The &lt;code&gt;=~ m&lt;/code&gt;, or match operator, is described in &lt;a href=&quot;perlop#m%2FPATTERN%2Fmsixpodualngc&quot;&gt;&quot;m/PATTERN/msixpodualngc&quot; in perlop&lt;/a&gt;.)</source>
          <target state="translated">&lt;code&gt;$foo&lt;/code&gt; 변수의 문자열에 &quot;a&quot;, &quot;b&quot;, &quot;c&quot;문자 시퀀스가 ​​포함되어있는 경우에만 참으로 평가됩니다 . ( &lt;code&gt;=~ m&lt;/code&gt; 또는 일치 연산자 &lt;a href=&quot;perlop#m%2FPATTERN%2Fmsixpodualngc&quot;&gt;는 perlop의 &quot;m / PATTERN / msixpodualngc&quot;에&lt;/a&gt; 설명되어 있습니다.)</target>
        </trans-unit>
        <trans-unit id="eaa45a050a297698330cfd197242d66b5bc5b90b" translate="yes" xml:space="preserve">
          <source>This event has no data of its own. This event is sent out by the IPC system when the main process/thread is ready to end.</source>
          <target state="translated">이 이벤트에는 자체 데이터가 없습니다. 이 이벤트는 주 프로세스 / 스레드가 종료 될 준비가되면 IPC 시스템에 의해 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="8fc04382ecbdf81e4f5caf52797a69b83c13dd83" translate="yes" xml:space="preserve">
          <source>This event is used if a TAP formatter wishes to set a version.</source>
          <target state="translated">이 이벤트는 TAP 포맷터가 버전을 설정하려는 경우 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="c4d1039eeddc372ecb07a9ed65ed3a51b6d6ae64" translate="yes" xml:space="preserve">
          <source>This example added quite a few new concepts. We'll take them one at a time.</source>
          <target state="translated">이 예제는 몇 가지 새로운 개념을 추가했습니다. 한 번에 하나씩 가져갑니다.</target>
        </trans-unit>
        <trans-unit id="b69f2ecf80918f850deb9506044c7c7d1e270ee4" translate="yes" xml:space="preserve">
          <source>This example does not include any retries and may consequently fail to contact a reachable host. The most prominent reason for this is congestion of the queues on the sending host if the number of hosts to contact is sufficiently large.</source>
          <target state="translated">이 예에는 재 시도가 포함되지 않으므로 연결 가능한 호스트에 연결하지 못할 수도 있습니다. 가장 두드러진 이유는 접속할 호스트 수가 충분히 많으면 송신 호스트에서 큐가 정체되기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="45c8019ae57e341f2cf51b697b11f926ebc66d79" translate="yes" xml:space="preserve">
          <source>This example fails because &lt;code&gt;baz()&lt;/code&gt; refers to the package/global subroutine &lt;code&gt;baz&lt;/code&gt;, not the lexical subroutine currently being defined.</source>
          <target state="translated">이 예 는 &lt;code&gt;baz()&lt;/code&gt; 현재 정의중인 어휘 서브 루틴이 아니라 패키지 / 글로벌 서브 루틴 &lt;code&gt;baz&lt;/code&gt; 를 참조하기 때문에 실패합니다 .</target>
        </trans-unit>
        <trans-unit id="90a572c629dcfb44919f712f7d6b779f25e5dfe2" translate="yes" xml:space="preserve">
          <source>This example is aborted at compile time as we use the attribute &quot;Test&quot; which isn't allowed. &lt;code&gt;MODIFY_CODE_ATTRIBUTES&lt;/code&gt; returns a list that contains a single element ('Test').</source>
          <target state="translated">허용되지 않는 &quot;Test&quot;속성을 사용하므로이 예제는 컴파일 타임에 중단됩니다. &lt;code&gt;MODIFY_CODE_ATTRIBUTES&lt;/code&gt; 는 단일 요소 ( 'Test')가 포함 된 목록을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="c0449bb1daa75d27783722f69c76968c08c60f04" translate="yes" xml:space="preserve">
          <source>This example is fairly trivial; for more complex cases and a deeper explanation, see the links in the &lt;a href=&quot;#SEE-ALSO&quot;&gt;&quot;SEE ALSO&quot;&lt;/a&gt; section.</source>
          <target state="translated">이 예는 매우 사소합니다. 더 복잡한 케이스와 더 자세한 설명은 &lt;a href=&quot;#SEE-ALSO&quot;&gt;&quot;SEE ALSO&quot;&lt;/a&gt; 섹션 의 링크를 참조 하십시오.</target>
        </trans-unit>
        <trans-unit id="f90369b8f8beb64315ed6181cebf6923dd367b56" translate="yes" xml:space="preserve">
          <source>This example is fairly trivial; for more complex cases and a deeper explanation, see the links in the &lt;a href=&quot;#SEE-ALSO&quot;&gt;SEE ALSO&lt;/a&gt; section.</source>
          <target state="translated">이 예는 매우 사소한 것입니다. 보다 복잡한 경우와 자세한 설명은 다음 섹션 의 링크를 &lt;a href=&quot;#SEE-ALSO&quot;&gt;참조&lt;/a&gt; 하십시오.</target>
        </trans-unit>
        <trans-unit id="1253f47712d1828f7f774117d0efa3abf09df500" translate="yes" xml:space="preserve">
          <source>This example is fully equivalent with:</source>
          <target state="translated">이 예제는 다음과 완전히 동일합니다.</target>
        </trans-unit>
        <trans-unit id="4cd1eae4be0b88a312be5ff0a3c94c909b4f359b" translate="yes" xml:space="preserve">
          <source>This example is preferred over the previous one--even for Unix platforms--because now any &lt;code&gt;\015&lt;/code&gt; 's (&lt;code&gt;\cM&lt;/code&gt; 's) are stripped out (and there was much rejoicing).</source>
          <target state="translated">이 예제는 이제 유닉스 플랫폼에서도 이전의 것보다 선호됩니다. 이제 &lt;code&gt;\015&lt;/code&gt; ( &lt;code&gt;\cM&lt;/code&gt; 's)가 제거 되었기 때문에 (기뻐하는 것이 많았습니다).</target>
        </trans-unit>
        <trans-unit id="d2e7d74c2002e413e58575bcfceff5a6cc8e62bb" translate="yes" xml:space="preserve">
          <source>This example is preferred over the previous one--even for Unix platforms--because now any &lt;code&gt;\015&lt;/code&gt;'s (&lt;code&gt;\cM&lt;/code&gt;'s) are stripped out (and there was much rejoicing).</source>
          <target state="translated">이 예제는 유닉스 플랫폼에서도 이전 예제보다 선호됩니다. 왜냐하면 이제 모든 &lt;code&gt;\015&lt;/code&gt; ( &lt;code&gt;\cM&lt;/code&gt; )가 제거 되었기 때문입니다 (그리고 많은 기쁨이있었습니다).</target>
        </trans-unit>
        <trans-unit id="2155785b4684f8ca5810fa768aca5a675651e726" translate="yes" xml:space="preserve">
          <source>This example prints the mail domain name of the SMTP server known as mailhost:</source>
          <target state="translated">이 예는 mailhost로 알려진 SMTP 서버의 메일 도메인 이름을 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="5df3c7e69cf9c030621b9397e847c01645ddee17" translate="yes" xml:space="preserve">
          <source>This example requires the following typemap entry. Consult &lt;a href=&quot;perlxstypemap&quot;&gt;perlxstypemap&lt;/a&gt; for more information about adding new typemaps for an extension.</source>
          <target state="translated">이 예에는 다음 유형 맵 항목이 필요합니다. 확장을위한 새 유형 맵 추가에 대한 자세한 정보는 &lt;a href=&quot;perlxstypemap&quot;&gt;perlxstypemap&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="41a9b74b00161dd5b470ab9ac8171979158c1d90" translate="yes" xml:space="preserve">
          <source>This example runs. At compile time &lt;code&gt;MODIFY_CODE_ATTRIBUTES&lt;/code&gt; is called. In that subroutine, we check if any attribute is disallowed and we return a list of these &quot;bad attributes&quot;.</source>
          <target state="translated">이 예제가 실행됩니다. 컴파일 타임에 &lt;code&gt;MODIFY_CODE_ATTRIBUTES&lt;/code&gt; 가 호출됩니다. 이 서브 루틴에서 속성이 허용되지 않는지 확인하고 이러한 &quot;잘못된 속성&quot;목록을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="f2a9ee1d0bad2acdbedd9aa3ec0be4c6a6a132f5" translate="yes" xml:space="preserve">
          <source>This example sends a single assertion, a note (comment for stdout in Test::Builder talk) and sets the plan to 1.</source>
          <target state="translated">이 예제는 단일 어설 션, 메모 (Test :: Builder talk에서 stdout에 대한 주석)를 보내고 계획을 1로 설정합니다.</target>
        </trans-unit>
        <trans-unit id="8ff407d302a1d7afb3f758e29e8d54e23989741b" translate="yes" xml:space="preserve">
          <source>This example sends a small message to the postmaster at the SMTP server known as mailhost:</source>
          <target state="translated">이 예에서는 SMTP 서버의 mailhost라는 포스트 마스터에게 작은 메시지를 보냅니다.</target>
        </trans-unit>
        <trans-unit id="78b434a9f3a15806251887966899fdd84de7d2e2" translate="yes" xml:space="preserve">
          <source>This example separates a text into fields which are quote delimited, curly bracketed, and anything else. The delimited and bracketed parts are also blessed to identify them (the &quot;anything else&quot; is unblessed):</source>
          <target state="translated">이 예제는 텍스트를 따옴표로 구분하고 중괄호로 묶고 그 밖의 다른 필드로 구분합니다. 구분되고 괄호로 묶인 부분은 또한 그것을 식별 할 수있는 축복을받습니다 ( &quot;다른 것&quot;은 축복되지 않음).</target>
        </trans-unit>
        <trans-unit id="9dff0d51281eb7bf5e0a018b6b24fe9e35070941" translate="yes" xml:space="preserve">
          <source>This example shows how to create a database, add key/value pairs to the database, delete keys/value pairs and finally how to enumerate the contents of the database.</source>
          <target state="translated">이 예제는 데이터베이스를 작성하고, 키 / 값 쌍을 데이터베이스에 추가하고, 키 / 값 쌍을 삭제하고, 마지막으로 데이터베이스 컨텐츠를 열거하는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="880ede3f528ae25983090ec0e0156cb403c63af8" translate="yes" xml:space="preserve">
          <source>This example shows rewriting weights. &lt;code&gt;rewrite&lt;/code&gt; is allowed to affect code points, weights, and the name.</source>
          <target state="translated">이 예제는 가중치 재 작성을 보여줍니다. &lt;code&gt;rewrite&lt;/code&gt; 는 코드 포인트, 가중치 및 이름에 영향을 줄 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="780bd69540d0ebaeb9c9ed4a226f52e8bf4d6c92" translate="yes" xml:space="preserve">
          <source>This example shows two calls that should have the same effect:</source>
          <target state="translated">이 예는 동일한 효과를 가져야하는 두 개의 호출을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="84ff60fe8d031f55c9709b2299fa816e68248930" translate="yes" xml:space="preserve">
          <source>This example takes a regular expression from the argument list and prints the lines of input that match it:</source>
          <target state="translated">이 예제는 인수 목록에서 정규식을 가져와 일치하는 입력 행을 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="078e5feeaf68f01a2929c0090cee690d8ca945ea" translate="yes" xml:space="preserve">
          <source>This example treats the slightly modified contents of $directory as a hash. The modifications are that the keys</source>
          <target state="translated">이 예에서는 $ directory의 약간 수정 된 내용을 해시로 취급합니다. 수정은 열쇠입니다</target>
        </trans-unit>
        <trans-unit id="98e05dd997bb9813bf387c2523a2ee3778ba728f" translate="yes" xml:space="preserve">
          <source>This example uses a code expression in a conditional to match a definite article, either 'the' in English or 'der|die|das' in German:</source>
          <target state="translated">이 예에서는 조건부에서 코드 표현식을 사용하여 영어의 'the'또는 독일어의 'der | die | das'와 같은 명확한 기사를 찾습니다.</target>
        </trans-unit>
        <trans-unit id="3182dc73190402ea11b0ccf6d157df088acea2cb" translate="yes" xml:space="preserve">
          <source>This example uses a code expression in a conditional to match a definite article, either &lt;code&gt;'the'&lt;/code&gt; in English or &lt;code&gt;'der|die|das'&lt;/code&gt; in German:</source>
          <target state="translated">이 예에서는 조건부에서 코드 표현식을 사용하여 영어로 &lt;code&gt;'the'&lt;/code&gt; , 독일어로 &lt;code&gt;'der|die|das'&lt;/code&gt; 를 정관사와 일치 시킵니다 .</target>
        </trans-unit>
        <trans-unit id="c87cae12f1868f49317dcbc2ec2e9d5385ba1820" translate="yes" xml:space="preserve">
          <source>This example will be used with the following Perl statements.</source>
          <target state="translated">이 예제는 다음 Perl 문과 함께 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="f8787b73d75916a7f7029d06b65a57928067677b" translate="yes" xml:space="preserve">
          <source>This example will fail to recognize that an error occurred inside the &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; {}&lt;/code&gt; . Here's why: the call_Subtract code got executed while perl was cleaning up temporaries when exiting the outer braced block, and because call_Subtract is implemented with</source>
          <target state="translated">이 예제는 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; {}&lt;/code&gt; 내에서 오류가 발생했음을 인식하지 못합니다 . 이유는 다음과 같습니다. 외부 괄호 블록을 종료 할 때 perl이 임시를 정리하는 동안 call_Subtract 코드가 실행되었으며 call_Subtract가</target>
        </trans-unit>
        <trans-unit id="72a47805dd0a8f6fcbe1140876fe6c6fdf98a8e4" translate="yes" xml:space="preserve">
          <source>This example will fail to recognize that an error occurred inside the &lt;code&gt;eval {}&lt;/code&gt;. Here's why: the call_Subtract code got executed while perl was cleaning up temporaries when exiting the outer braced block, and because call_Subtract is implemented with</source>
          <target state="translated">이 예제는 &lt;code&gt;eval {}&lt;/code&gt; 내부에서 오류가 발생했음을 인식하지 못합니다 . 이유는 다음과 같습니다. perl이 외부 중괄호 블록을 종료 할 때 임시를 정리하는 동안 call_Subtract 코드가 실행되었으며 call_Subtract가 다음과 같이 구현 되었기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="3e706dc3b3a7c56333befa9c2c2082dd86f8994b" translate="yes" xml:space="preserve">
          <source>This example will set the time to midnight on the same date which &lt;code&gt;$t&lt;/code&gt; had previously. Allowed values for the &quot;to&quot; parameter are: &quot;year&quot;, &quot;quarter&quot;, &quot;month&quot;, &quot;day&quot;, &quot;hour&quot;, &quot;minute&quot; and &quot;second&quot;.</source>
          <target state="translated">이 예제는 &lt;code&gt;$t&lt;/code&gt; 가 이전에 가졌던 동일한 날짜의 자정으로 시간을 설정합니다 . &quot;to&quot;매개 변수에 허용되는 값은 &quot;year&quot;, &quot;quarter&quot;, &quot;month&quot;, &quot;day&quot;, &quot;hour&quot;, &quot;minute&quot;및 &quot;second&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="3f78c3b59ae95350e4323c3cb4c7f0dc6fda1338" translate="yes" xml:space="preserve">
          <source>This example works on many platforms that have a shell compatible with Bourne shell:</source>
          <target state="translated">이 예제는 Bourne 쉘과 호환되는 쉘이있는 많은 플랫폼에서 작동합니다.</target>
        </trans-unit>
        <trans-unit id="15d5f8da3c8eb09a121cb765eeca738ccef36a74" translate="yes" xml:space="preserve">
          <source>This experimental attribute, introduced in Perl 5.22, only applies to anonymous subroutines. It causes the subroutine to be called as soon as the &lt;code&gt;&lt;a href=&quot;functions/sub&quot;&gt;sub&lt;/a&gt;&lt;/code&gt; expression is evaluated. The return value is captured and turned into a constant subroutine.</source>
          <target state="translated">Perl 5.22에 도입 된이 실험 속성은 익명 서브 루틴에만 적용됩니다. &lt;code&gt;&lt;a href=&quot;functions/sub&quot;&gt;sub&lt;/a&gt;&lt;/code&gt; 표현식이 평가 되 자마자 서브 루틴이 호출되도록 합니다. 리턴 값이 캡처되어 일정한 서브 루틴으로 바뀝니다.</target>
        </trans-unit>
        <trans-unit id="0326081879c6e23ef99277efab3cb0743f765db7" translate="yes" xml:space="preserve">
          <source>This experimental attribute, introduced in Perl 5.22, only applies to anonymous subroutines. It causes the subroutine to be called as soon as the &lt;code&gt;sub&lt;/code&gt; expression is evaluated. The return value is captured and turned into a constant subroutine.</source>
          <target state="translated">Perl 5.22에 도입 된이 실험적 속성은 익명 서브 루틴에만 적용됩니다. &lt;code&gt;sub&lt;/code&gt; 표현식이 평가 되 자마자 서브 루틴이 호출되도록 합니다. 반환 값이 캡처되어 상수 서브 루틴으로 바뀝니다.</target>
        </trans-unit>
        <trans-unit id="b23c339cf7e806a89bf6a85ce94fd3c5b9e88336" translate="yes" xml:space="preserve">
          <source>This experimental feature has been added to begin to implement &lt;a href=&quot;https://www.unicode.org/reports/tr18/#Wildcard_Properties&quot;&gt;https://www.unicode.org/reports/tr18/#Wildcard_Properties&lt;/a&gt;. Using it will raise a (default-on) warning in the &lt;code&gt;experimental::uniprop_wildcards&lt;/code&gt; category. We reserve the right to change its operation as we gain experience.</source>
          <target state="translated">이 실험 기능은 &lt;a href=&quot;https://www.unicode.org/reports/tr18/#Wildcard_Properties&quot;&gt;https://www.unicode.org/reports/tr18/#Wildcard_Properties&lt;/a&gt; 구현을 시작하기 위해 추가되었습니다 . 이것을 사용하면 &lt;code&gt;experimental::uniprop_wildcards&lt;/code&gt; 카테고리 에서 (기본 설정) 경고가 발생합니다 . 우리는 경험을 쌓으면 운영을 변경할 권리가 있습니다.</target>
        </trans-unit>
        <trans-unit id="6660b28f752ff2775e494cee3716861f7ebee6fd" translate="yes" xml:space="preserve">
          <source>This exposes the VMS C library &lt;code&gt;realpath&lt;/code&gt; function where available. It will always return a Unix format specification.</source>
          <target state="translated">이것은 가능한 경우 VMS C 라이브러리 &lt;code&gt;realpath&lt;/code&gt; 함수를 노출합니다 . 항상 Unix 형식 사양을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="c659fee685d6111f5eef41a4fc47f104c94d024f" translate="yes" xml:space="preserve">
          <source>This expression is actually equivalent to &lt;code&gt;$x &amp;amp; ($y == 0)&lt;/code&gt; , due to the higher precedence of &lt;code&gt;==&lt;/code&gt; . This is probably not what you want. (If you really meant to write this, disable the warning, or, better, put the parentheses explicitly and write &lt;code&gt;$x &amp;amp; ($y == 0)&lt;/code&gt; ).</source>
          <target state="translated">이 표현은 실제로 동일하다 &lt;code&gt;$x &amp;amp; ($y == 0)&lt;/code&gt; 기인의 높은 우선 순위로 &lt;code&gt;==&lt;/code&gt; . 이것은 아마도 당신이 원하는 것이 아닙니다. (실제로 이것을 쓰려면 경고를 비활성화하거나 괄호를 명시 적으로 넣고 &lt;code&gt;$x &amp;amp; ($y == 0)&lt;/code&gt; )하십시오.</target>
        </trans-unit>
        <trans-unit id="2d1c58a809013f74370c233986b702d73e647e16" translate="yes" xml:space="preserve">
          <source>This expression is actually equivalent to &lt;code&gt;$x &amp;amp; ($y == 0)&lt;/code&gt;, due to the higher precedence of &lt;code&gt;==&lt;/code&gt;. This is probably not what you want. (If you really meant to write this, disable the warning, or, better, put the parentheses explicitly and write &lt;code&gt;$x &amp;amp; ($y == 0)&lt;/code&gt;).</source>
          <target state="translated">이 표현은 실제로 동일하다 &lt;code&gt;$x &amp;amp; ($y == 0)&lt;/code&gt; 기인의 높은 우선 순위로 &lt;code&gt;==&lt;/code&gt; . 이것은 아마도 당신이 원하는 것이 아닐 것입니다. (정말로 이것을 작성하려는 경우 경고를 비활성화하거나 괄호를 명시 적으로 넣고 &lt;code&gt;$x &amp;amp; ($y == 0)&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="3d95c2dd6bdf3facfce8eb7c29c42e8682159b3f" translate="yes" xml:space="preserve">
          <source>This extension is somewhat contrived. It is based on the code in the previous example. It calls the statfs function multiple times, accepting a reference to an array of filenames as input, and returning a reference to an array of hashes containing the data for each of the filesystems.</source>
          <target state="translated">이 확장은 다소 고안되었습니다. 이전 예제의 코드를 기반으로합니다. statfs 함수를 여러 번 호출하여 파일 이름 배열에 대한 참조를 입력으로 허용하고 각 파일 시스템에 대한 데이터를 포함하는 해시 배열에 대한 참조를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="443c1ad31c99bd2962c1e14f9f6e565d7abce59c" translate="yes" xml:space="preserve">
          <source>This extension is very Unix-oriented (struct statfs and the statfs system call). If you are not running on a Unix system, you can substitute for statfs any other function that returns multiple values, you can hard-code values to be returned to the caller (although this will be a bit harder to test the error case), or you can simply not do this example. If you change the XSUB, be sure to fix the test cases to match the changes.</source>
          <target state="translated">이 확장은 매우 유닉스 지향적입니다 (struct statfs 및 statfs 시스템 호출). Unix 시스템에서 실행하지 않는 경우 여러 값을 반환하는 다른 함수를 statfs 대신 사용할 수 있으며, 호출자에게 반환 할 값을 하드 코딩 할 수 있습니다 (오류 사례를 테스트하기는 조금 더 어렵지만), 또는이 예제를 수행 할 수 없습니다. XSUB를 변경하는 경우 변경 사항에 맞게 테스트 케이스를 수정하십시오.</target>
        </trans-unit>
        <trans-unit id="2a17a99eab781fe118715bddd6eafc465e544bac" translate="yes" xml:space="preserve">
          <source>This facet appears in a list instead of being a single item.</source>
          <target state="translated">이 패싯은 단일 항목이 아닌 목록에 나타납니다.</target>
        </trans-unit>
        <trans-unit id="7adb2f888cd1ff1460814af89b1a8925569507cc" translate="yes" xml:space="preserve">
          <source>This facet can contain any random meta-data that has been attached to the event.</source>
          <target state="translated">이 패싯은 이벤트에 첨부 된 임의의 메타 데이터를 포함 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5f39ea5539b92284678be2bccf399a87e784a440" translate="yes" xml:space="preserve">
          <source>This facet contains information related to when and where the event was generated. This is how the test file and line number of a failure is known. This facet can also help you to tell if tests are related.</source>
          <target state="translated">이 패싯에는 이벤트가 생성 된시기 및 위치와 관련된 정보가 포함됩니다. 이것이 테스트 파일과 실패의 줄 번호를 아는 방법입니다. 이 패싯은 테스트가 관련되어 있는지 확인하는데도 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="ea5933de4fce257c57230d3c2048dd56d25f8eec" translate="yes" xml:space="preserve">
          <source>This facet contains nested events and similar details for subtests. In this facet the &lt;code&gt;details&lt;/code&gt; field will typically be the name of the subtest.</source>
          <target state="translated">이 패싯에는 하위 테스트에 대한 중첩 된 이벤트 및 유사한 세부 정보가 포함됩니다. 이 패싯에서 &lt;code&gt;details&lt;/code&gt; 필드는 일반적으로 하위 테스트의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="228901b4b4fd688562c63a9bfc644b29832273c3" translate="yes" xml:space="preserve">
          <source>This facet has information about the event, such as event package.</source>
          <target state="translated">이 패싯에는 이벤트 패키지와 같은 이벤트에 대한 정보가 있습니다.</target>
        </trans-unit>
        <trans-unit id="261eefb058d9b8f210edf7e8b66786488a61cb53" translate="yes" xml:space="preserve">
          <source>This facet has the hash key &lt;code&gt;'errors'&lt;/code&gt;, and is a list of facets instead of a single item.</source>
          <target state="translated">이 패싯에는 해시 키 &lt;code&gt;'errors'&lt;/code&gt; 가 있으며 단일 항목이 아닌 패싯 목록입니다.</target>
        </trans-unit>
        <trans-unit id="6d6b311bf3037d57366a4f7b75cd51fe95ab4943" translate="yes" xml:space="preserve">
          <source>This facet is a list type, you can add as many items as needed.</source>
          <target state="translated">이 패싯은 목록 유형이며 필요한만큼 항목을 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9038beb7c2b76255669cf565bb956421b6792189" translate="yes" xml:space="preserve">
          <source>This facet is used if an assertion was made. The &lt;code&gt;details&lt;/code&gt; field of this facet is the description of the assertion.</source>
          <target state="translated">이 패싯은 어설 션이 작성된 경우 사용됩니다. 이 패싯 의 &lt;code&gt;details&lt;/code&gt; 필드는 어설 션에 대한 설명입니다.</target>
        </trans-unit>
        <trans-unit id="de3db551858fe84100e4783720b6439f9bd8929d" translate="yes" xml:space="preserve">
          <source>This facet is used to dictate how the event should be rendered by the standard test2 rendering tools. If this facet is present then ONLY what is specified by it will be rendered. It is assumed that anything important or note-worthy will be present here, no other facets will be considered for rendering/display.</source>
          <target state="translated">이 패싯은 표준 test2 렌더링 도구에서 이벤트를 렌더링하는 방법을 지정하는 데 사용됩니다. 이 패싯이있는 경우 지정된 항목 만 렌더링됩니다. 여기에는 중요하거나 주목할만한 것이있는 것으로 간주되며 렌더링 / 디스플레이에 다른 측면은 고려되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5cf535cec4856d555110dfbc5a3f81213306c039" translate="yes" xml:space="preserve">
          <source>This facet is used to tell the &lt;a href=&quot;Test2::Event::Hub&quot;&gt;Test2::Event::Hub&lt;/a&gt; about special actions the event causes. Things like halting all testing, terminating the current test, etc. In this facet the &lt;code&gt;details&lt;/code&gt; field explains why any special action was taken.</source>
          <target state="translated">이 패싯은 이벤트로 인해 발생하는 특수 작업에 대해 &lt;a href=&quot;Test2::Event::Hub&quot;&gt;Test2 :: Event :: Hub&lt;/a&gt; 에 알리는 데 사용됩니다 . 모든 테스트 중지, 현재 테스트 종료 등과 같은 것들이 있습니다.이 패싯의 &lt;code&gt;details&lt;/code&gt; 필드는 특수 조치가 취해진 이유를 설명합니다.</target>
        </trans-unit>
        <trans-unit id="0fddc25c4dbd645a45a85fc8433a6f59b647f1be" translate="yes" xml:space="preserve">
          <source>This facet is used when an event contains other events, such as a subtest.</source>
          <target state="translated">이 패싯은 이벤트에 하위 테스트와 같은 다른 이벤트가 포함 된 경우 사용됩니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
