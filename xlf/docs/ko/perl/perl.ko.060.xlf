<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="perl">
    <body>
      <group id="perl">
        <trans-unit id="d57dd39f43cd00fc9fcf08a3e6ef2330c6e56ff0" translate="yes" xml:space="preserve">
          <source>The following will determine the maximum length of the longest allowable pathname on the filesystem which holds &lt;code&gt;/var&lt;/code&gt;.</source>
          <target state="translated">다음은 &lt;code&gt;/var&lt;/code&gt; 를 보유하는 파일 시스템에서 허용되는 가장 긴 경로 이름의 최대 길이를 결정합니다 .</target>
        </trans-unit>
        <trans-unit id="5cbb13ad67db7840db7c7d12b58ddc55ef0ed900" translate="yes" xml:space="preserve">
          <source>The following will get the machine's clock speed.</source>
          <target state="translated">다음은 기계의 클럭 속도를 얻습니다.</target>
        </trans-unit>
        <trans-unit id="577c472e2dc0fc4d87aa88d05e48ae7e476e2971" translate="yes" xml:space="preserve">
          <source>The following will probably not do what you expect:</source>
          <target state="translated">다음은 아마 당신이 기대하는 것을하지 않을 것입니다 :</target>
        </trans-unit>
        <trans-unit id="5c8bd82fe901dea332f23983ad9e29577c0fed4c" translate="yes" xml:space="preserve">
          <source>The following will probably not print what you expect:</source>
          <target state="translated">다음은 예상대로 인쇄되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="119de64c9692dd9e013f0596370be8f29169b856" translate="yes" xml:space="preserve">
          <source>The following will query the current &lt;code&gt;LC_CTYPE&lt;/code&gt; category. (No second argument means 'query'.)</source>
          <target state="translated">다음은 현재 &lt;code&gt;LC_CTYPE&lt;/code&gt; 범주를 쿼리합니다 . (두 번째 인수는 'query'를 의미하지 않습니다.)</target>
        </trans-unit>
        <trans-unit id="5966453b4cde6268559966748dc7d8bf8fdd0ec2" translate="yes" xml:space="preserve">
          <source>The following will set the &lt;code&gt;LC_COLLATE&lt;/code&gt; behaviour to Argentinian Spanish. &lt;b&gt;NOTE&lt;/b&gt;: The naming and availability of locales depends on your operating system. Please consult &lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt; for how to find out which locales are available in your system.</source>
          <target state="translated">다음은 &lt;code&gt;LC_COLLATE&lt;/code&gt; 동작을 아르헨티나 스페인어로 설정합니다 . &lt;b&gt;참고&lt;/b&gt; : 로캘의 이름과 사용 가능성은 운영 체제에 따라 다릅니다. 시스템에서 사용 가능한 로케일을 찾는 방법은 &lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="5abcdbfe7d0b6ac6ed18a19f7b6cc537b1839b5d" translate="yes" xml:space="preserve">
          <source>The following will set the &lt;code&gt;LC_CTYPE&lt;/code&gt; behaviour according to the locale environment variables (the second argument &lt;code&gt;&quot;&quot;&lt;/code&gt; ). Please see your system's &lt;code&gt;setlocale(3)&lt;/code&gt; documentation for the locale environment variables' meaning or consult &lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt;.</source>
          <target state="translated">다음은 로케일 환경 변수 (두 번째 인수 &lt;code&gt;&quot;&quot;&lt;/code&gt; ) 에 따라 &lt;code&gt;LC_CTYPE&lt;/code&gt; 동작 을 설정합니다 . 로케일 환경 변수의 의미에 대해서는 시스템의 &lt;code&gt;setlocale(3)&lt;/code&gt; 문서를 참조하거나 &lt;a href=&quot;perllocale&quot;&gt;perllocale을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="216ff7e1b32a193101b360016063f1dbe17b7ec9" translate="yes" xml:space="preserve">
          <source>The following will set the &lt;code&gt;LC_CTYPE&lt;/code&gt; behaviour according to the locale environment variables (the second argument &lt;code&gt;&quot;&quot;&lt;/code&gt;). Please see your system's &lt;code&gt;setlocale(3)&lt;/code&gt; documentation for the locale environment variables' meaning or consult &lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ecbd57a3195c4519fb09fab198f3facf1b32479f" translate="yes" xml:space="preserve">
          <source>The following will set the traditional UNIX system locale behavior (the second argument &lt;code&gt;&quot;C&quot;&lt;/code&gt; ).</source>
          <target state="translated">다음은 일반적인 UNIX 시스템 로케일 동작 (두 번째 인수 &lt;code&gt;&quot;C&quot;&lt;/code&gt; )을 설정합니다.</target>
        </trans-unit>
        <trans-unit id="9d989bfd17f8da94563bcb6ebfdcbf583a757e87" translate="yes" xml:space="preserve">
          <source>The following will set the traditional UNIX system locale behavior (the second argument &lt;code&gt;&quot;C&quot;&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d394598bfc021311cf0f2bb824273bc318b5797a" translate="yes" xml:space="preserve">
          <source>The following would first try to find Math::BigInt::Foo, then Math::BigInt::Bar, and when this also fails, revert to Math::BigInt::Calc:</source>
          <target state="translated">다음은 먼저 Math :: BigInt :: Foo를 찾은 다음 Math :: BigInt :: Bar를 찾으려고 시도하는데 실패하면 Math :: BigInt :: Calc로 돌아갑니다.</target>
        </trans-unit>
        <trans-unit id="9ce20518f56534bcc1118c0bf986d78eef528c90" translate="yes" xml:space="preserve">
          <source>The following:</source>
          <target state="translated">다음과 같은:</target>
        </trans-unit>
        <trans-unit id="678f5358c7187caa2da5eff48aaaa0b704fbae9c" translate="yes" xml:space="preserve">
          <source>The followings items are mostly for reference and general Unicode knowledge, Perl doesn't use these constructs internally.</source>
          <target state="translated">다음 항목은 주로 참조 및 일반적인 유니 코드 지식을위한 것으로 Perl은 이러한 구성을 내부적으로 사용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0e4f79728d04ec0471d6bf96e407b112aa0cabf3" translate="yes" xml:space="preserve">
          <source>The foregoing mechanism for overriding built-in is restricted, quite deliberately, to the package that requests the import. There is a second method that is sometimes applicable when you wish to override a built-in everywhere, without regard to namespace boundaries. This is achieved by importing a sub into the special namespace &lt;code&gt;CORE::GLOBAL::&lt;/code&gt; . Here is an example that quite brazenly replaces the &lt;code&gt;&lt;a href=&quot;functions/glob&quot;&gt;glob&lt;/a&gt;&lt;/code&gt; operator with something that understands regular expressions.</source>
          <target state="translated">내장 기능을 재정의하는 전술 한 메커니즘은 가져 오기를 요청하는 패키지로 제한되어 있습니다. 네임 스페이스 경계에 관계없이 모든 곳에서 내장을 재정의하려는 경우에 적용 할 수있는 두 번째 방법이 있습니다. 서브 우퍼를 특수 네임 스페이스 &lt;code&gt;CORE::GLOBAL::&lt;/code&gt; 로 가져 와서 달성됩니다 . 다음은 &lt;code&gt;&lt;a href=&quot;functions/glob&quot;&gt;glob&lt;/a&gt;&lt;/code&gt; 연산자를 정규 표현식을 이해하는 것으로 대담하게 대체하는 예입니다 .</target>
        </trans-unit>
        <trans-unit id="ef8b42b5ef636a805f830b90ca5398d8a3c613f1" translate="yes" xml:space="preserve">
          <source>The foregoing mechanism for overriding built-in is restricted, quite deliberately, to the package that requests the import. There is a second method that is sometimes applicable when you wish to override a built-in everywhere, without regard to namespace boundaries. This is achieved by importing a sub into the special namespace &lt;code&gt;CORE::GLOBAL::&lt;/code&gt;. Here is an example that quite brazenly replaces the &lt;code&gt;glob&lt;/code&gt; operator with something that understands regular expressions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b85c90a6a43ec9e5bf7a5a11ec769ca8bd55e119" translate="yes" xml:space="preserve">
          <source>The fork() emulation is implemented at the level of the Perl interpreter. What this means in general is that running fork() will actually clone the running interpreter and all its state, and run the cloned interpreter in a separate thread, beginning execution in the new thread just after the point where the fork() was called in the parent. We will refer to the thread that implements this child &quot;process&quot; as the pseudo-process.</source>
          <target state="translated">fork () 에뮬레이션은 Perl 인터프리터 수준에서 구현됩니다. 이것은 일반적으로 실행중인 fork ()가 실행중인 인터프리터와 모든 상태를 복제하고, 복제 된 인터프리터를 별도의 스레드에서 실행하여 fork ()가 호출 된 직후의 새 스레드에서 실행을 시작한다는 것을 의미합니다 부모. 이 자식 &quot;프로세스&quot;를 구현하는 스레드를 의사 프로세스라고합니다.</target>
        </trans-unit>
        <trans-unit id="e04f09879ad602b86af95f9f6d5d371e6757eda4" translate="yes" xml:space="preserve">
          <source>The fork() emulation may not behave as expected when it is executed in an application which embeds a Perl interpreter and calls Perl APIs that can evaluate bits of Perl code. This stems from the fact that the emulation only has knowledge about the Perl interpreter's own data structures and knows nothing about the containing application's state. For example, any state carried on the application's own call stack is out of reach.</source>
          <target state="translated">fork () 에뮬레이션은 Perl 인터프리터를 포함하고 Perl 코드의 비트를 평가할 수있는 Perl API를 호출하는 응용 프로그램에서 실행될 때 예상대로 작동하지 않을 수 있습니다. 이것은 에뮬레이션이 Perl 인터프리터 자신의 데이터 구조에 대한 지식 만 가지고 있고 포함하는 응용 프로그램의 상태에 대해서는 아무것도 모르기 때문입니다. 예를 들어, 응용 프로그램 자체의 호출 스택에서 수행 된 모든 상태에 도달하지 못합니다.</target>
        </trans-unit>
        <trans-unit id="0708717756f902c5ff59069bd45289469d28d91c" translate="yes" xml:space="preserve">
          <source>The fork() emulation will not work entirely correctly when called from within a BEGIN block. The forked copy will run the contents of the BEGIN block, but will not continue parsing the source stream after the BEGIN block. For example, consider the following code:</source>
          <target state="translated">BEGIN 블록 내에서 호출 될 때 fork () 에뮬레이션이 완전히 작동하지 않습니다. 분기 된 사본은 BEGIN 블록의 내용을 실행하지만 BEGIN 블록 이후 소스 스트림 구문 분석을 계속하지 않습니다. 예를 들어 다음 코드를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="15be1c6ce9042f03bee94913baeb82a3ff565ee8" translate="yes" xml:space="preserve">
          <source>The fork() has to come before the setsid() to ensure you aren't a process group leader; the setsid() will fail if you are. If your system doesn't have the setsid() function, open</source>
          <target state="translated">프로세스 그룹 리더가되지 않도록하려면 fork ()가 setsid () 앞에 와야합니다. 그렇다면 setsid ()가 실패합니다. 시스템에 setsid () 함수가없는 경우</target>
        </trans-unit>
        <trans-unit id="9d31d094967d18a344cd7885a66ada91947ca8a3" translate="yes" xml:space="preserve">
          <source>The forked debugger requires the environment variable &lt;code&gt;TERM&lt;/code&gt; to be &lt;code&gt;xterm&lt;/code&gt; , and the environment variable &lt;code&gt;DISPLAY&lt;/code&gt; to exist. &lt;code&gt;xterm&lt;/code&gt; must be in lower case.</source>
          <target state="translated">분기 된 디버거에서는 환경 변수 &lt;code&gt;TERM&lt;/code&gt; 이 &lt;code&gt;xterm&lt;/code&gt; 이고 환경 변수 &lt;code&gt;DISPLAY&lt;/code&gt; 가 있어야합니다. &lt;code&gt;xterm&lt;/code&gt; 은 소문자 여야합니다.</target>
        </trans-unit>
        <trans-unit id="80ddbda74fdf5f4c1a0f7f135f152cdae53aae97" translate="yes" xml:space="preserve">
          <source>The forked debugger requires the environment variable &lt;code&gt;TERM&lt;/code&gt; to be &lt;code&gt;xterm&lt;/code&gt;, and the environment variable &lt;code&gt;DISPLAY&lt;/code&gt; to exist. &lt;code&gt;xterm&lt;/code&gt; must be in lower case.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90a1b936aa7515813dbe100195592b08e94ebcb1" translate="yes" xml:space="preserve">
          <source>The form &lt;code&gt;$x **= $y&lt;/code&gt; is faster than &lt;code&gt;$x = $x ** $y;&lt;/code&gt; , though.</source>
          <target state="translated">폼 &lt;code&gt;$x **= $y&lt;/code&gt; 빠르다보다 &lt;code&gt;$x = $x ** $y;&lt;/code&gt; , 그러나.</target>
        </trans-unit>
        <trans-unit id="6d60b9b98398cc175682fc83afb5cb2a3d960481" translate="yes" xml:space="preserve">
          <source>The form &lt;code&gt;$x **= $y&lt;/code&gt; is faster than &lt;code&gt;$x = $x ** $y;&lt;/code&gt;, though.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea29df8f31e738f8731934d29265ffb8df1b05f7" translate="yes" xml:space="preserve">
          <source>The form &lt;code&gt;while/if BLOCK BLOCK&lt;/code&gt;, available in Perl 4, is no longer available. Replace any occurrence of &lt;code&gt;if BLOCK&lt;/code&gt; by &lt;code&gt;if (&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt; BLOCK)&lt;/code&gt; .</source>
          <target state="translated">Perl 4에서 사용 가능한 &lt;code&gt;while/if BLOCK BLOCK&lt;/code&gt; 양식 은 더 이상 사용할 수 없습니다. 의 발생을 교체 &lt;code&gt;if BLOCK&lt;/code&gt; 가 &lt;code&gt;if (&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt; BLOCK)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3ab550c0e5d5dbe7a57264f4fc68930ea27ef872" translate="yes" xml:space="preserve">
          <source>The form &lt;code&gt;while/if BLOCK BLOCK&lt;/code&gt;, available in Perl 4, is no longer available. Replace any occurrence of &lt;code&gt;if BLOCK&lt;/code&gt; by &lt;code&gt;if (do BLOCK)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0d89d2ce75f6dd9a5b033644a202a3e0573863e" translate="yes" xml:space="preserve">
          <source>The formal syntax of a section specification is:</source>
          <target state="translated">섹션 스펙의 공식 구문은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="feafac52c2f0bb1c62c34d80f1ccae00a8b7bff5" translate="yes" xml:space="preserve">
          <source>The format is roughly the same as a header section except for the fallback flag: | followed by 0..3. The meaning of the possible values is as follows:</source>
          <target state="translated">대체 플래그를 제외하고 형식은 헤더 섹션과 거의 동일합니다. | 뒤에 0..3. 가능한 값의 의미는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7de51818a43a9eeabc5f149d791bcd953969e5ec" translate="yes" xml:space="preserve">
          <source>The format is the same as PREREQ_PM.</source>
          <target state="translated">형식은 PREREQ_PM과 동일합니다.</target>
        </trans-unit>
        <trans-unit id="4a91025674068746c104cf678dff09a87e09a62d" translate="yes" xml:space="preserve">
          <source>The format is:</source>
          <target state="translated">형식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="cab7930ea8f9bb0b5e8551406e705f9d6d55872a" translate="yes" xml:space="preserve">
          <source>The format of the constructor for &lt;code&gt;IO::Compress::Bzip2&lt;/code&gt; is shown below</source>
          <target state="translated">&lt;code&gt;IO::Compress::Bzip2&lt;/code&gt; 의 생성자 형식 은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2b7f4c6f10c021d585a52efc7c38f1f01339227d" translate="yes" xml:space="preserve">
          <source>The format of the constructor for &lt;code&gt;IO::Compress::Deflate&lt;/code&gt; is shown below</source>
          <target state="translated">&lt;code&gt;IO::Compress::Deflate&lt;/code&gt; 의 생성자 형식 은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e03dc6c86b8958f9b62ec7a6a483ad0e4753decb" translate="yes" xml:space="preserve">
          <source>The format of the constructor for &lt;code&gt;IO::Compress::Gzip&lt;/code&gt; is shown below</source>
          <target state="translated">&lt;code&gt;IO::Compress::Gzip&lt;/code&gt; 의 생성자 형식 은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2cd916282c4e6b36ecc3a6af27b028bb638d27b9" translate="yes" xml:space="preserve">
          <source>The format of the constructor for &lt;code&gt;IO::Compress::RawDeflate&lt;/code&gt; is shown below</source>
          <target state="translated">&lt;code&gt;IO::Compress::RawDeflate&lt;/code&gt; 의 생성자 형식 은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="96cf103266184d2ab7c512526262f24222f5b3fa" translate="yes" xml:space="preserve">
          <source>The format of the constructor for &lt;code&gt;IO::Compress::Zip&lt;/code&gt; is shown below</source>
          <target state="translated">&lt;code&gt;IO::Compress::Zip&lt;/code&gt; 의 생성자 형식 은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7cddd4e7224584228dd40d8278ce06df26d30be6" translate="yes" xml:space="preserve">
          <source>The format of the constructor for IO::Uncompress::AnyInflate is shown below</source>
          <target state="translated">IO :: Uncompress :: AnyInflate의 생성자 형식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f335334476f7fdad7a158077eda96d1e77d620ba" translate="yes" xml:space="preserve">
          <source>The format of the constructor for IO::Uncompress::AnyUncompress is shown below</source>
          <target state="translated">IO :: Uncompress :: AnyUncompress의 생성자 형식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d8f9f10c69da3c0a902ce3d0bf3a43a4fe3d0d99" translate="yes" xml:space="preserve">
          <source>The format of the constructor for IO::Uncompress::Bunzip2 is shown below</source>
          <target state="translated">IO :: Uncompress :: Bunzip2의 생성자 형식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1aee64e705754fe9513f8b1c5a275541fbf25126" translate="yes" xml:space="preserve">
          <source>The format of the constructor for IO::Uncompress::Gunzip is shown below</source>
          <target state="translated">IO :: Uncompress :: Gunzip의 생성자 형식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e0479ea0c00c6dbc0391fab896f56792a7f58abf" translate="yes" xml:space="preserve">
          <source>The format of the constructor for IO::Uncompress::Inflate is shown below</source>
          <target state="translated">IO :: Uncompress :: Inflate의 생성자 형식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="abbcd988c20a7a7af1b1b62b62f212c0f098a642" translate="yes" xml:space="preserve">
          <source>The format of the constructor for IO::Uncompress::RawInflate is shown below</source>
          <target state="translated">IO :: Uncompress :: RawInflate 생성자의 형식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="266217c42524ecb82328e7bc0e8f8cf67f30e119" translate="yes" xml:space="preserve">
          <source>The format of the constructor for IO::Uncompress::Unzip is shown below</source>
          <target state="translated">IO :: Uncompress :: Unzip의 생성자 형식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6ce17f5dc7d5e6006e0ab81d86bb016be0d29f0f" translate="yes" xml:space="preserve">
          <source>The format of this scalar value is &lt;b&gt;not&lt;/b&gt; locale-dependent but built into Perl. For GMT instead of local time use the &lt;a href=&quot;#gmtime&quot;&gt;gmtime&lt;/a&gt; builtin. See also the &lt;code&gt;Time::Local&lt;/code&gt; module (for converting seconds, minutes, hours, and such back to the integer value returned by time()), and the &lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt; module's strftime(3) and mktime(3) functions.</source>
          <target state="translated">이 스칼라 값의 형식은 &lt;b&gt;없습니다&lt;/b&gt; 로케일에 의존하지만 펄에 내장. 현지 시간 대신 GMT의 경우 &lt;a href=&quot;#gmtime&quot;&gt;gmtime&lt;/a&gt; 내장을 사용하십시오 . 또한 참조 &lt;code&gt;Time::Local&lt;/code&gt; 모듈 (변환 초, 분, 시간, 시간에 의해 반환되는 정수 값 ()에 같은 다시를 들어), 그리고 &lt;a href=&quot;posix&quot;&gt;POSIX의&lt;/a&gt; 모듈의의 strftime (3)에서는 mktime (3) 기능.</target>
        </trans-unit>
        <trans-unit id="2c7d4e187b4ee40d7ac4cdd3dd9c17ff06ab82de" translate="yes" xml:space="preserve">
          <source>The format of this scalar value is &lt;b&gt;not&lt;/b&gt; locale-dependent but built into Perl. For GMT instead of local time use the &lt;a href=&quot;#gmtime-EXPR&quot;&gt;&lt;code&gt;gmtime&lt;/code&gt;&lt;/a&gt; builtin. See also the &lt;a href=&quot;Time::Local&quot;&gt;&lt;code&gt;Time::Local&lt;/code&gt;&lt;/a&gt; module (for converting seconds, minutes, hours, and such back to the integer value returned by &lt;a href=&quot;#time&quot;&gt;&lt;code&gt;time&lt;/code&gt;&lt;/a&gt;), and the &lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt; module's &lt;a href=&quot;posix#strftime&quot;&gt;&lt;code&gt;strftime&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;posix#mktime&quot;&gt;&lt;code&gt;mktime&lt;/code&gt;&lt;/a&gt; functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2da41af1cf680b6887d63dd253c6e01471391c6" translate="yes" xml:space="preserve">
          <source>The format of this scalar value is &lt;b&gt;not&lt;/b&gt; locale-dependent but built into Perl. For GMT instead of local time use the &lt;a href=&quot;gmtime&quot;&gt;gmtime&lt;/a&gt; builtin. See also the &lt;code&gt;Time::Local&lt;/code&gt; module (for converting seconds, minutes, hours, and such back to the integer value returned by time()), and the &lt;a href=&quot;../posix&quot;&gt;POSIX&lt;/a&gt; module's strftime(3) and mktime(3) functions.</source>
          <target state="translated">이 스칼라 값의 형식은 &lt;b&gt;없습니다&lt;/b&gt; 로케일에 의존하지만 펄에 내장. 현지 시간 대신 GMT의 경우 &lt;a href=&quot;gmtime&quot;&gt;gmtime&lt;/a&gt; 내장을 사용하십시오 . 또한 참조 &lt;code&gt;Time::Local&lt;/code&gt; 모듈 (변환 초, 분, 시간, 시간에 의해 반환되는 정수 값 ()에 같은 다시를 들어), 그리고 &lt;a href=&quot;../posix&quot;&gt;POSIX의&lt;/a&gt; 모듈의의 strftime (3)에서는 mktime (3) 기능.</target>
        </trans-unit>
        <trans-unit id="7fb9dcbdf87a920318a01eb480379e8f7c7c3de2" translate="yes" xml:space="preserve">
          <source>The format specifier detection is not complete printf-syntax detection, but it should catch most common cases.</source>
          <target state="translated">형식 지정자 감지는 완전한 printf 구문 감지가 아니지만 가장 일반적인 경우를 포착해야합니다.</target>
        </trans-unit>
        <trans-unit id="256ecd9d04a27fc1ec23dd2c77863e67bcf5ad16" translate="yes" xml:space="preserve">
          <source>The formats supported are</source>
          <target state="translated">지원되는 형식은</target>
        </trans-unit>
        <trans-unit id="0577a9efbbb4297e7d5cf847fb8e2a9cc4cdfef4" translate="yes" xml:space="preserve">
          <source>The formats supported are:</source>
          <target state="translated">지원되는 형식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f7762b6266ff516b0fab73ac7af6d025adc1f538" translate="yes" xml:space="preserve">
          <source>The formats that can convert characters to numbers and vice versa will be different from their ASCII counterparts when executed on an EBCDIC platform. Examples include:</source>
          <target state="translated">문자를 숫자로 변환하거나 그 반대로 변환 할 수있는 형식은 EBCDIC 플랫폼에서 실행될 때 ASCII 형식과 다릅니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5f27c48c4d04704c74b0b5d7d716d5ed43b40c07" translate="yes" xml:space="preserve">
          <source>The former default in which Perl would always use a loose interpretation of UTF-8 has now been overruled:</source>
          <target state="translated">Perl이 항상 UTF-8의 느슨한 해석을 사용하는 이전 기본값은 이제 무시되었습니다.</target>
        </trans-unit>
        <trans-unit id="bacc21ee4934a43e7cffae5409abb3139d8d7444" translate="yes" xml:space="preserve">
          <source>The former is defined to imply Unicode handling; and the latter indicates a Unicode locale, hence a Unicode interpretation of all strings within it.</source>
          <target state="translated">전자는 유니 코드 처리를 의미합니다. 후자는 유니 코드 로케일을 나타내므로 그 안에있는 모든 문자열의 유니 코드 해석입니다.</target>
        </trans-unit>
        <trans-unit id="abc8578e218b1958e7644bd43d9d008d1386b618" translate="yes" xml:space="preserve">
          <source>The formerly undocumented STRICT argument sets strictness: if true 'use strict;' is used, otherwise it uses 'no strict;'. &lt;b&gt;Note&lt;/b&gt;: if STRICT is omitted 'no strict;' is the default.</source>
          <target state="translated">이전에 문서화되지 않은 STRICT 인수는 엄격 성을 설정합니다. if true 'use strict;' 그렇지 않으면 '엄격하지 않음'을 사용합니다. &lt;b&gt;노트&lt;/b&gt; : STRICT를 생략하면 '엄격하지 않습니다.' 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="18a3596eca3e6e803312bc68b427ff1f1eeb325a" translate="yes" xml:space="preserve">
          <source>The forms &lt;code&gt;(?'&lt;i&gt;NAME&lt;/i&gt;'&lt;i&gt;pattern&lt;/i&gt;)&lt;/code&gt; and &lt;code&gt;(?&amp;lt;&lt;i&gt;NAME&lt;/i&gt;&amp;gt;&lt;i&gt;pattern&lt;/i&gt;)&lt;/code&gt; are equivalent.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8c48d78ca541fb734f8a681b44e6478f12be1be" translate="yes" xml:space="preserve">
          <source>The forms &lt;code&gt;(?'NAME'pattern)&lt;/code&gt; and &lt;code&gt;(?&amp;lt;NAME&amp;gt;pattern)&lt;/code&gt; are equivalent.</source>
          <target state="translated">양식 &lt;code&gt;(?'NAME'pattern)&lt;/code&gt; 및 &lt;code&gt;(?&amp;lt;NAME&amp;gt;pattern)&lt;/code&gt; 은 동일합니다.</target>
        </trans-unit>
        <trans-unit id="3165776bcfd76f28e0c24205090accd64be6f1e3" translate="yes" xml:space="preserve">
          <source>The formula is from the Red Dragon book (reformulated to use the data available) and is documented at &lt;a href=&quot;http://www.strchr.com/hash_functions&quot;&gt;http://www.strchr.com/hash_functions&lt;/a&gt;</source>
          <target state="translated">공식은 Red Dragon 서적 (사용 가능한 데이터를 사용하도록 재구성 됨)에 있으며 &lt;a href=&quot;http://www.strchr.com/hash_functions&quot;&gt;http://www.strchr.com/hash_functions에&lt;/a&gt; 문서화되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ea332d524efecd12f52e313e0715e604daa7345f" translate="yes" xml:space="preserve">
          <source>The four &lt;code&gt;CPAN::*&lt;/code&gt; Classes: Author, Bundle, Module, Distribution</source>
          <target state="translated">네 &lt;code&gt;CPAN::*&lt;/code&gt; 클래스 : 작성자, 번들, 모듈, 배포</target>
        </trans-unit>
        <trans-unit id="4ebe0eef114ce361363114266a5b30d9fc215c2f" translate="yes" xml:space="preserve">
          <source>The four &lt;code&gt;filter_*&lt;/code&gt; methods shown above are available in all the DBM modules that ship with Perl, namely DB_File, GDBM_File, NDBM_File, ODBM_File and SDBM_File.</source>
          <target state="translated">네 개의 &lt;code&gt;filter_*&lt;/code&gt; 위에 표시된 메소드는 Perl과 함께 제공되는 모든 DBM 모듈, 즉 DB_File, GDBM_File, NDBM_File, ODBM_File 및 SDBM_File에서 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a87cd62b5e4a547576560e5204e87547d60f9cfe" translate="yes" xml:space="preserve">
          <source>The four CPAN::* Classes: Author, Bundle, Module, Distribution</source>
          <target state="translated">4 가지 CPAN :: * 클래스 : 작성자, 번들, 모듈, 배포</target>
        </trans-unit>
        <trans-unit id="fe1fb546f60704c6d1d156b3f6fadf776528094a" translate="yes" xml:space="preserve">
          <source>The four element types -- scalar, array, hash, and class -- are represented by strings -- &lt;code&gt;'$'&lt;/code&gt; , &lt;code&gt;'@'&lt;/code&gt; , &lt;code&gt;'%'&lt;/code&gt; , and a class name -- optionally preceded by a &lt;code&gt;'*'&lt;/code&gt; .</source>
          <target state="translated">스칼라, 배열, 해시 및 클래스의 네 가지 요소 유형은 문자열 ( &lt;code&gt;'$'&lt;/code&gt; , &lt;code&gt;'@'&lt;/code&gt; , &lt;code&gt;'%'&lt;/code&gt; 및 클래스 이름) (선택적으로 &lt;code&gt;'*'&lt;/code&gt; 이 앞에옵니다) .</target>
        </trans-unit>
        <trans-unit id="92b64884f8f61e4bda03f0b1b810258bc7d0365f" translate="yes" xml:space="preserve">
          <source>The four element types -- scalar, array, hash, and class -- are represented by strings -- &lt;code&gt;'$'&lt;/code&gt;, &lt;code&gt;'@'&lt;/code&gt;, &lt;code&gt;'%'&lt;/code&gt;, and a class name -- optionally preceded by a &lt;code&gt;'*'&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="010d48814dc6637936a58a714f4a5b8ac2c0e5b8" translate="yes" xml:space="preserve">
          <source>The fourth (index [3]) element (&lt;code&gt;$default&lt;/code&gt; ) in the list returned for this format is 0.</source>
          <target state="translated">이 형식에 대해 리턴 된 목록 의 네 번째 (index [3]) 요소 ( &lt;code&gt;$default&lt;/code&gt; )는 0입니다.</target>
        </trans-unit>
        <trans-unit id="2e817fac52edc4c5e0caee985a6afb86c7862868" translate="yes" xml:space="preserve">
          <source>The fourth (index [3]) element (&lt;code&gt;$default&lt;/code&gt; ) in the list returned for this format is &lt;code&gt;&quot;NaN&quot;&lt;/code&gt; .</source>
          <target state="translated">이 형식에 대해 리턴 된 목록에서 네 번째 (index [3]) 요소 ( &lt;code&gt;$default&lt;/code&gt; )는 &lt;code&gt;&quot;NaN&quot;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="d015fffd23c241225267b70dd79dfdb0ced38265" translate="yes" xml:space="preserve">
          <source>The fourth (index [3]) element (&lt;code&gt;$default&lt;/code&gt; ) in the list returned for this format is the empty string.</source>
          <target state="translated">이 형식에 대해 리턴 된 목록에서 네 번째 (index [3]) 요소 ( &lt;code&gt;$default&lt;/code&gt; )는 빈 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="dbf8c5de03271df9c0ea8fd5c41bcc753a3e2e78" translate="yes" xml:space="preserve">
          <source>The fourth (index [3]) element (&lt;code&gt;$default&lt;/code&gt;) in the list returned for this format is 0.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49a31746958b0c54f45a9490ade3495335e57ef5" translate="yes" xml:space="preserve">
          <source>The fourth (index [3]) element (&lt;code&gt;$default&lt;/code&gt;) in the list returned for this format is &lt;code&gt;&quot;NaN&quot;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="28ce6cb48f2a76c182227b4de66778e078fb3c5c" translate="yes" xml:space="preserve">
          <source>The fourth (index [3]) element (&lt;code&gt;$default&lt;/code&gt;) in the list returned for this format is the empty string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ee5dc54dca610abdb335a6016c33fad310b745e" translate="yes" xml:space="preserve">
          <source>The fourth argument,</source>
          <target state="translated">네 번째 논쟁은</target>
        </trans-unit>
        <trans-unit id="d46f45156438266dbc454cfdd5c8500aa9cf2dd2" translate="yes" xml:space="preserve">
          <source>The fourth operation is the same as the logical not of the third operation and is specified the same way as the third with the addition of a caret character &lt;code&gt;^&lt;/code&gt; at the beginning of the test string just inside the open square bracket.</source>
          <target state="translated">네 번째 작업은 세 번째 작업이 아닌 논리와 동일 하며 열린 대괄호 안에 테스트 문자열의 시작 부분에 캐럿 문자 &lt;code&gt;^&lt;/code&gt; 를 추가하여 세 번째 작업과 같은 방식으로 지정됩니다 .</target>
        </trans-unit>
        <trans-unit id="bc43b69f9d12ff24c27cb6addf7ed86730581d51" translate="yes" xml:space="preserve">
          <source>The fourth through ninth highest priorities are to look in the corresponding grandparent, great-grandparent and great-great-grandparent directories.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="517bbe0d839ce687e5bde7b590dd68865b524c37" translate="yes" xml:space="preserve">
          <source>The friends locked into &lt;code&gt;M$&lt;/code&gt; world would appreciate the fact that this executable runs under DOS, Win0.3*, Win0.95 and WinNT with an appropriate extender. See &lt;a href=&quot;#Other-OSes&quot;&gt;&quot;Other OSes&quot;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c67d6a9240f3ec0e157e3e0a648b8e35a0a7ab23" translate="yes" xml:space="preserve">
          <source>The friends locked into &lt;code&gt;M$&lt;/code&gt; world would appreciate the fact that this executable runs under DOS, Win0.3*, Win0.95 and WinNT with an appropriate extender. See &lt;a href=&quot;#Other-OSes&quot;&gt;Other OSes&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;M$&lt;/code&gt; 세계에 빠진 친구들 은이 실행 파일이 적절한 익스텐더와 함께 DOS, Win0.3 *, Win0.95 및 WinNT에서 실행된다는 사실에 감사 할 것입니다. &lt;a href=&quot;#Other-OSes&quot;&gt;다른 OS를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="043867751e64107d60b95a69e8badcc29251fb84" translate="yes" xml:space="preserve">
          <source>The full circle is 2</source>
          <target state="translated">전체 원은 2</target>
        </trans-unit>
        <trans-unit id="d29a10ef910506015d780ee21ef968e5b95cf038" translate="yes" xml:space="preserve">
          <source>The full definition for this field is given in the &lt;a href=&quot;#Prereq-Spec&quot;&gt;&quot;Prereq Spec&quot;&lt;/a&gt; section.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37765aa0855e93aba1c1cfea3d54b9c2c469bca1" translate="yes" xml:space="preserve">
          <source>The full documentation for &lt;a href=&quot;perlfunc#open-FILEHANDLE%2CMODE%2CEXPR&quot;&gt;&lt;code&gt;open&lt;/code&gt;&lt;/a&gt; provides a thorough reference to this function, beyond the best-practice basics covered here.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e66fe9d715897deb9cd4770d030e58e58ff7af5a" translate="yes" xml:space="preserve">
          <source>The full list of alternatives is:</source>
          <target state="translated">대안의 전체 목록은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e2b044fa3549d52ee2f4f118ecc7f64b424bcc29" translate="yes" xml:space="preserve">
          <source>The full set of contributors always includes the folks mentioned in &lt;a href=&quot;IO::Stringy#CHANGE-LOG&quot;&gt;&quot;CHANGE LOG&quot; in IO::Stringy&lt;/a&gt;. But just the same, special thanks to the following individuals for their invaluable contributions (if I've forgotten or misspelled your name, please email me!):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="baccc1ffc22a33efb39b1687159250f28dc423fa" translate="yes" xml:space="preserve">
          <source>The full text of the license can be found in the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80a153a5f23194fa493b49953e70a37ba58abfd1" translate="yes" xml:space="preserve">
          <source>The full text of the license can be found in the LICENSE file included with this module.</source>
          <target state="translated">라이센스의 전체 텍스트는이 모듈에 포함 된 LICENSE 파일에서 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c54557502ca6f64ebd0cff3c9dbc11ca01487c1f" translate="yes" xml:space="preserve">
          <source>The full version number of this package, such as 5.6.1 (or 5_6_1). This combines revision, patchlevel, and subversion to get the full version number, including any possible subversions. This is suitable for use as a directory name, and hence is filesystem dependent.</source>
          <target state="translated">이 패키지의 전체 버전 번호 (예 : 5.6.1 (또는 5_6_1)) 수정 버전, 패치 수준 및 하위 버전을 결합하여 가능한 하위 버전을 포함한 전체 버전 번호를 얻습니다. 이것은 디렉토리 이름으로 사용하기에 적합하므로 파일 시스템에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="5bc944c87864f3d28f9f02ec1b783a4a9aacca33" translate="yes" xml:space="preserve">
          <source>The fully qualified method name that was called is available in the &lt;code&gt;$AUTOLOAD&lt;/code&gt; package global for your class. Since this is a global, if you want to refer to do it without a package name prefix under &lt;code&gt;strict
'vars'&lt;/code&gt; , you need to declare it.</source>
          <target state="translated">호출 된 완전한 메소드 이름은 클래스 의 &lt;code&gt;$AUTOLOAD&lt;/code&gt; 패키지 전역에서 사용 가능합니다. 이것이 전역 &lt;code&gt;strict 'vars'&lt;/code&gt; 아래에 패키지 이름 접두어없이 참조 하려면 선언해야합니다.</target>
        </trans-unit>
        <trans-unit id="46868bf85da4047d1fd48569f16bb118135bfc66" translate="yes" xml:space="preserve">
          <source>The fully qualified method name that was called is available in the &lt;code&gt;$AUTOLOAD&lt;/code&gt; package global for your class. Since this is a global, if you want to refer to do it without a package name prefix under &lt;code&gt;strict 'vars'&lt;/code&gt;, you need to declare it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7c7ff8a6b152356b1c3b87a4fa36cf4002b4367" translate="yes" xml:space="preserve">
          <source>The function</source>
          <target state="translated">함수</target>
        </trans-unit>
        <trans-unit id="d66346d1633c0f93998400fd3d2d89ef6dd2f1f1" translate="yes" xml:space="preserve">
          <source>The function &lt;a href=&quot;utf8#Utility-functions&quot;&gt;&lt;code&gt;utf8::utf8_upgrade()&lt;/code&gt;&lt;/a&gt; can be explicitly used to permanently (unless a subsequent &lt;code&gt;utf8::utf8_downgrade()&lt;/code&gt; is called) cause a string to be treated as Unicode.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1263ec90688607ca3bc3ec7bfb0fe38e6efd4c6" translate="yes" xml:space="preserve">
          <source>The function &lt;a href=&quot;utf8#Utility-functions&quot;&gt;utf8::utf8_upgrade() &lt;/a&gt; can be explicitly used to permanently (unless a subsequent &lt;code&gt;utf8::utf8_downgrade()&lt;/code&gt; is called) cause a string to be treated as Unicode.</source>
          <target state="translated">&lt;a href=&quot;utf8#Utility-functions&quot;&gt;utf8 :: utf8_upgrade ()&lt;/a&gt; 함수를 명시 적으로 사용하여 (이후 &lt;code&gt;utf8::utf8_downgrade()&lt;/code&gt; 가 호출 되지 않는 한 ) 문자열을 유니 코드로 처리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="0110ffd54f081ff34d7394303d2f5fa900a42f45" translate="yes" xml:space="preserve">
          <source>The function &lt;b&gt;pod_find&lt;/b&gt; searches for POD documents in a given set of files and/or directories. It returns a hash with the file names as keys and the POD name as value. The POD name is derived from the file name and its position in the directory tree.</source>
          <target state="translated">&lt;b&gt;pod_find&lt;/b&gt; 함수 는 주어진 파일 및 / 또는 디렉토리 세트에서 POD 문서를 검색합니다. 파일 이름을 키로, POD 이름을 값으로 사용하여 해시를 리턴합니다. POD 이름은 파일 이름과 디렉토리 트리에서의 위치에서 파생됩니다.</target>
        </trans-unit>
        <trans-unit id="48cfcd3ef7cb24df407c69f7ab8cfb221b006395" translate="yes" xml:space="preserve">
          <source>The function &lt;b&gt;simplify_name&lt;/b&gt; is equivalent to &lt;b&gt;basename&lt;/b&gt;, but also strips Perl-like extensions (.pm, .pl, .pod) and extensions like</source>
          <target state="translated">&lt;b&gt;단순화&lt;/b&gt; _ 이름 함수 는 &lt;b&gt;basename&lt;/b&gt; 과 동일 하지만 Perl과 유사한 확장자 (.pm, .pl, .pod)와 같은 확장자를 제거합니다.</target>
        </trans-unit>
        <trans-unit id="977e84004739e29fbaa341106fb1e524db41e10d" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; has been deprecated, so code has been included to display a warning message whenever the calling module has (at least) the &quot;deprecated&quot; warnings category enabled. Something like this, say.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; 함수 는 더 이상 사용되지 않으므로 호출 모듈에서 &quot;사용되지 않는&quot;경고 범주를 활성화 할 때마다 경고 메시지를 표시하는 코드가 포함되었습니다. 이런 식으로 말합니다.</target>
        </trans-unit>
        <trans-unit id="509f0d861d7a99d6a484f51f2a9188a5713a5b35" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;filter_read&lt;/code&gt; takes two forms:</source>
          <target state="translated">&lt;code&gt;filter_read&lt;/code&gt; 함수 는 두 가지 형식을 취합니다.</target>
        </trans-unit>
        <trans-unit id="5c27f77e8d833b52d6b699513cb75e12cfb41e38" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;hostname()&lt;/code&gt; in the &lt;a href=&quot;Sys::Hostname&quot;&gt;Sys::Hostname&lt;/a&gt; module has always been documented to be called with no arguments. Historically it has not enforced this, and has actually accepted and ignored any arguments. As a result, some users have got the mistaken impression that an argument does something useful. To avoid these bugs, the function is being made strict. Passing arguments was deprecated in Perl 5.28 and became fatal in Perl 5.32.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f2b0d9ecb1c14fb1e59a3fd0192de217a46316b" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;open&lt;/code&gt; has been deprecated, so code has been included to display a warning message whenever the calling module has (at least) the &quot;deprecated&quot; warnings category enabled. Something like this, say.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ecd4d38aee306d70f6097ade577ca383b52839ef" translate="yes" xml:space="preserve">
          <source>The function I18N::LangTags::List::name(...) is not exported.</source>
          <target state="translated">I18N :: LangTags :: List :: name (...) 함수는 내 보내지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5583893e9ddd698662f18f40b85c6a69394dd032" translate="yes" xml:space="preserve">
          <source>The function accepts a list of directories to be created. Its behaviour may be tuned by an optional hashref appearing as the last parameter on the call.</source>
          <target state="translated">이 함수는 작성할 디렉토리 목록을 승인합니다. 호출의 마지막 매개 변수로 나타나는 선택적 hashref에 의해 동작이 조정될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1ccfd3fbf49c44a49b4970d5b4592c2961b06827" translate="yes" xml:space="preserve">
          <source>The function accepts a list of directories to be removed. (In point of fact, it will also accept filesystem entries which are not directories, such as regular files and symlinks. But, as its name suggests, its intent is to remove trees rather than individual files.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c25ffe36bf18f7f44be765fa3c82188ddbc3925" translate="yes" xml:space="preserve">
          <source>The function accepts a list of directories to be removed. Its behaviour may be tuned by an optional hashref appearing as the last parameter on the call.</source>
          <target state="translated">이 함수는 제거 할 디렉토리 목록을 승인합니다. 호출의 마지막 매개 변수로 나타나는 선택적 hashref에 의해 동작이 조정될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3ef41ec1c0dbf85f3bcd0cef90f173dc6b18dec6" translate="yes" xml:space="preserve">
          <source>The function call &lt;code&gt;shell&lt;/code&gt; takes two optional arguments: one the prompt, the second the default initial command line (the latter only works if a real ReadLine interface module is installed).</source>
          <target state="translated">함수 호출 &lt;code&gt;shell&lt;/code&gt; 은 두 개의 선택적 인수를 취합니다. 하나는 프롬프트이고, 두 번째는 기본 초기 명령 행입니다 (후자는 실제 ReadLine 인터페이스 모듈이 설치된 경우에만 작동 함).</target>
        </trans-unit>
        <trans-unit id="f64674aceb9b0908fa74a739ca7fbade2ac2ee6e" translate="yes" xml:space="preserve">
          <source>The function declaration must be visible at compile time. The prototype affects only interpretation of new-style calls to the function, where new-style is defined as not using the &lt;code&gt;&amp;amp;&lt;/code&gt; character. In other words, if you call it like a built-in function, then it behaves like a built-in function. If you call it like an old-fashioned subroutine, then it behaves like an old-fashioned subroutine. It naturally falls out from this rule that prototypes have no influence on subroutine references like &lt;code&gt;\&amp;amp;foo&lt;/code&gt; or on indirect subroutine calls like &lt;code&gt;&amp;amp;{$subref}&lt;/code&gt; or &lt;code&gt;$subref-&amp;gt;()&lt;/code&gt; .</source>
          <target state="translated">함수 선언은 컴파일 타임에 보여야합니다. 프로토 타입은 함수에 대한 새 스타일 호출 해석에만 영향을 미치며, 새 스타일은 &lt;code&gt;&amp;amp;&lt;/code&gt; 문자를 사용하지 않는 것으로 정의됩니다 . 즉, 내장 함수처럼 호출하면 내장 함수처럼 동작합니다. 구식 서브 루틴처럼 호출하면 구식 서브 루틴처럼 작동합니다. 프로토 타입이 &lt;code&gt;\&amp;amp;foo&lt;/code&gt; 와 같은 서브 루틴 참조 또는 &lt;code&gt;&amp;amp;{$subref}&lt;/code&gt; 또는 &lt;code&gt;$subref-&amp;gt;()&lt;/code&gt; 와 같은 간접 서브 루틴 호출에 영향을 미치지 않는다는 것은 당연히이 규칙에서 벗어납니다 .</target>
        </trans-unit>
        <trans-unit id="a54076d47c791003b92c3959d64c01e6039e0bd6" translate="yes" xml:space="preserve">
          <source>The function declaration must be visible at compile time. The prototype affects only interpretation of new-style calls to the function, where new-style is defined as not using the &lt;code&gt;&amp;amp;&lt;/code&gt; character. In other words, if you call it like a built-in function, then it behaves like a built-in function. If you call it like an old-fashioned subroutine, then it behaves like an old-fashioned subroutine. It naturally falls out from this rule that prototypes have no influence on subroutine references like &lt;code&gt;\&amp;amp;foo&lt;/code&gt; or on indirect subroutine calls like &lt;code&gt;&amp;amp;{$subref}&lt;/code&gt; or &lt;code&gt;$subref-&amp;gt;()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46a4f089237c0dd0b61fdd70575a337b465e2308" translate="yes" xml:space="preserve">
          <source>The function extracts the entry of the specified terminal type</source>
          <target state="translated">이 함수는 지정된 터미널 유형의 항목을 추출합니다.</target>
        </trans-unit>
        <trans-unit id="dbacf36c4d8a578101fa6d12242c4841f7204b60" translate="yes" xml:space="preserve">
          <source>The function interface uses attribute strings to describe the colors and text attributes to assign to text. The recognized non-color attributes are clear, reset, bold, dark, faint, italic, underline, underscore, blink, reverse, and concealed. Clear and reset (reset to default attributes), dark and faint (dim and saturated), and underline and underscore are equivalent, so use whichever is the most intuitive to you.</source>
          <target state="translated">함수 인터페이스는 속성 문자열을 사용하여 텍스트에 지정할 색상 및 텍스트 속성을 설명합니다. 인식 된 비 색상 속성은 선명하고 재설정되며 굵게 표시되고 어둡고 희미하고 기울임 꼴, 밑줄, 밑줄, 깜박임, 반전 및 은폐됩니다. 지우기 및 재설정 (기본 속성으로 재설정), 어둡고 희미한 (흐리게 및 채도), 밑줄 및 밑줄은 동일하므로 가장 직관적 인 것을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="6f3bb6ac191764523c9d934c739e063f3ecbe7de" translate="yes" xml:space="preserve">
          <source>The function is called from the tokeniser, whenever a possible keyword is seen. &lt;code&gt;keyword_ptr&lt;/code&gt; points at the word in the parser's input buffer, and &lt;code&gt;keyword_len&lt;/code&gt; gives its length; it is not null-terminated. The function is expected to examine the word, and possibly other state such as &lt;a href=&quot;perlvar#%25%5EH&quot;&gt;%^H&lt;/a&gt;, to decide whether it wants to handle it as an extended keyword. If it does not, the function should return &lt;code&gt;KEYWORD_PLUGIN_DECLINE&lt;/code&gt;, and the normal parser process will continue.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55694c97e9ceb329d9698a51681bd4944db4ba6e" translate="yes" xml:space="preserve">
          <source>The function is called from the tokeniser, whenever a possible keyword is seen. &lt;code&gt;keyword_ptr&lt;/code&gt; points at the word in the parser's input buffer, and &lt;code&gt;keyword_len&lt;/code&gt; gives its length; it is not null-terminated. The function is expected to examine the word, and possibly other state such as &lt;a href=&quot;perlvar#%25%5eH&quot;&gt;%^H&lt;/a&gt;, to decide whether it wants to handle it as an extended keyword. If it does not, the function should return &lt;code&gt;KEYWORD_PLUGIN_DECLINE&lt;/code&gt; , and the normal parser process will continue.</source>
          <target state="translated">가능한 키워드가 표시 될 때마다 토큰 화기에서 함수가 호출됩니다. &lt;code&gt;keyword_ptr&lt;/code&gt; 은 구문 분석기의 입력 버퍼에서 단어를 가리키고 &lt;code&gt;keyword_len&lt;/code&gt; 은 길이를 제공합니다. null로 끝나지 않습니다. 이 함수는 단어를 확장 키워드로 처리할지 여부를 결정 하기 위해 단어 및 &lt;a href=&quot;perlvar#%25%5eH&quot;&gt;% ^ H&lt;/a&gt; 와 같은 다른 상태를 검사해야합니다 . 그렇지 않은 경우 함수는 &lt;code&gt;KEYWORD_PLUGIN_DECLINE&lt;/code&gt; 을 반환해야 하며 정상적인 파서 프로세스가 계속됩니다.</target>
        </trans-unit>
        <trans-unit id="9306c5da74b3095d5bd155bcdf129a71eee56339" translate="yes" xml:space="preserve">
          <source>The function looks in the symbol table of &lt;code&gt;$package&lt;/code&gt; for the typeglob for &lt;code&gt;$referent&lt;/code&gt; , which is a reference to a variable or subroutine (SCALAR, ARRAY, HASH, or CODE). If it finds the typeglob, it returns it. Otherwise, it returns undef. Note that &lt;code&gt;findsym&lt;/code&gt; memoizes the typeglobs it has previously successfully found, so subsequent calls with the same arguments should be much faster.</source>
          <target state="translated">이 함수는 변수 또는 서브 루틴 (SCALAR, ARRAY, HASH 또는 CODE)에 대한 &lt;code&gt;$referent&lt;/code&gt; 인 $ referent 의 typeglob에 대한 &lt;code&gt;$package&lt;/code&gt; 의 기호 테이블을 찾습니다 . typeglob을 찾으면 반환합니다. 그렇지 않으면 undef를 반환합니다. 참고 것을 &lt;code&gt;findsym&lt;/code&gt; 가 이전에 성공적으로 발견 한 typeglobs을 memoizes, 같은 인수를 너무 후속 호출은 훨씬 더 빨리해야한다.</target>
        </trans-unit>
        <trans-unit id="4cae2e767271065d7f78fa3e9c794bcd99ab2963" translate="yes" xml:space="preserve">
          <source>The function looks in the symbol table of &lt;code&gt;$package&lt;/code&gt; for the typeglob for &lt;code&gt;$referent&lt;/code&gt;, which is a reference to a variable or subroutine (SCALAR, ARRAY, HASH, or CODE). If it finds the typeglob, it returns it. Otherwise, it returns undef. Note that &lt;code&gt;findsym&lt;/code&gt; memoizes the typeglobs it has previously successfully found, so subsequent calls with the same arguments should be much faster.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="228b62ac93f3c97adf4846ab7a229490257f21f2" translate="yes" xml:space="preserve">
          <source>The function name and the return type must be placed on separate lines and should be flush left-adjusted.</source>
          <target state="translated">함수 이름과 반환 유형은 별도의 줄에 배치해야하며 왼쪽으로 플러시되어야합니다.</target>
        </trans-unit>
        <trans-unit id="497e4c985232c356046790edf3b0a4494724ab06" translate="yes" xml:space="preserve">
          <source>The function optionally takes a number of named options specified as &lt;code&gt;-Name =&amp;gt; value&lt;/code&gt; pairs. This allows individual options to be tailored without having to specify them all in the parameter list.</source>
          <target state="translated">이 함수는 선택적으로 &lt;code&gt;-Name =&amp;gt; value&lt;/code&gt; 쌍 으로 지정된 여러 명명 된 옵션을 사용합니다 . 이를 통해 개별 옵션을 매개 변수 목록에서 모두 지정할 필요없이 조정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c334e8eba917e7f07e2743dd2e109fa8bab331b7" translate="yes" xml:space="preserve">
          <source>The function optionally takes a number of named options specified as &lt;code&gt;-Name=&amp;gt;value&lt;/code&gt; pairs. This allows individual options to be tailored without having to specify them all in the parameter list.</source>
          <target state="translated">이 함수는 선택적으로 &lt;code&gt;-Name=&amp;gt;value&lt;/code&gt; 쌍 으로 지정된 여러 명명 된 옵션을 사용합니다 . 이를 통해 개별 옵션을 매개 변수 목록에서 모두 지정할 필요없이 조정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="24c3d21a118e57cb0a792d18dd4aca22a45547ff" translate="yes" xml:space="preserve">
          <source>The function optionally takes a number of named options specified as &lt;code&gt;Name =&amp;gt; value&lt;/code&gt; pairs. This allows individual options to be tailored without having to specify them all in the parameter list.</source>
          <target state="translated">이 함수는 선택적으로 &lt;code&gt;Name =&amp;gt; value&lt;/code&gt; 쌍 으로 지정된 여러 명명 된 옵션을 사용합니다 . 이를 통해 개별 옵션을 매개 변수 목록에서 모두 지정할 필요없이 조정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="91502bdfeb749a40030a89a237be0405bf938f7b" translate="yes" xml:space="preserve">
          <source>The function returns &lt;code&gt;NULL&lt;/code&gt; if there is no occurrence of &lt;code&gt;little&lt;/code&gt; within &lt;code&gt;big&lt;/code&gt;. If &lt;code&gt;little&lt;/code&gt; is the empty string, &lt;code&gt;big&lt;/code&gt; is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="efd7c1c2cc7bcbc10e2084326d92993267a12ffd" translate="yes" xml:space="preserve">
          <source>The function returns &lt;code&gt;TRUE&lt;/code&gt; if the input string is empty, or if the corresponding C function returns &lt;code&gt;TRUE&lt;/code&gt; for every byte in the string.</source>
          <target state="translated">함수 반환 &lt;code&gt;TRUE&lt;/code&gt; 입력 문자열이 비어있는 경우, 또는 대응하는 C 함수 돌아 가면 &lt;code&gt;TRUE&lt;/code&gt; 스트링의 모든 바이트.</target>
        </trans-unit>
        <trans-unit id="d8c35a5a4f8d066f0d21fe352b171cb7a12a9b6f" translate="yes" xml:space="preserve">
          <source>The function returns a packed string representing the requested socket option, or &lt;a href=&quot;#undef-EXPR&quot;&gt;&lt;code&gt;undef&lt;/code&gt;&lt;/a&gt; on error, with the reason for the error placed in &lt;a href=&quot;perlvar#%24%21&quot;&gt;&lt;code&gt;$!&lt;/code&gt;&lt;/a&gt;. Just what is in the packed string depends on LEVEL and OPTNAME; consult &lt;a href=&quot;http://man.he.net/man2/getsockopt&quot;&gt;getsockopt(2)&lt;/a&gt; for details. A common case is that the option is an integer, in which case the result is a packed integer, which you can decode using &lt;a href=&quot;#unpack-TEMPLATE%2CEXPR&quot;&gt;&lt;code&gt;unpack&lt;/code&gt;&lt;/a&gt; with the &lt;code&gt;i&lt;/code&gt; (or &lt;code&gt;I&lt;/code&gt;) format.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18bb210a9d041841ab7e7d3f647d6ee1d366da33" translate="yes" xml:space="preserve">
          <source>The function returns a packed string representing the requested socket option, or &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; on error, with the reason for the error placed in &lt;code&gt;$!&lt;/code&gt; . Just what is in the packed string depends on LEVEL and OPTNAME; consult getsockopt(2) for details. A common case is that the option is an integer, in which case the result is a packed integer, which you can decode using &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; with the &lt;code&gt;i&lt;/code&gt; (or &lt;code&gt;I&lt;/code&gt; ) format.</source>
          <target state="translated">이 기능은 또는, 요청 된 소켓 옵션을 나타내는 포장 된 문자열을 반환 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 에 배치 오류의 원인과 오류에 &lt;code&gt;$!&lt;/code&gt; . 압축 문자열에있는 것은 LEVEL 및 OPTNAME에 따라 다릅니다. 자세한 내용은 getsockopt (2)를 참조하십시오. 일반적인 경우는 옵션이 정수이고,이 경우 결과는 팩형 정수이며, &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; 을 사용하여 &lt;code&gt;i&lt;/code&gt; (또는 &lt;code&gt;I&lt;/code&gt; ) 형식으로 디코딩 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f3bdd5d171fe014406932479dff47095d4169b23" translate="yes" xml:space="preserve">
          <source>The function returns a packed string representing the requested socket option, or &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; on error, with the reason for the error placed in &lt;code&gt;$!&lt;/code&gt; . Just what is in the packed string depends on LEVEL and OPTNAME; consult getsockopt(2) for details. A common case is that the option is an integer, in which case the result is a packed integer, which you can decode using &lt;code&gt;&lt;a href=&quot;unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; with the &lt;code&gt;i&lt;/code&gt; (or &lt;code&gt;I&lt;/code&gt; ) format.</source>
          <target state="translated">이 기능은 또는, 요청 된 소켓 옵션을 나타내는 포장 된 문자열을 반환 &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 에 배치 오류의 원인과 오류에 &lt;code&gt;$!&lt;/code&gt; . 압축 문자열에있는 것은 LEVEL 및 OPTNAME에 따라 다릅니다. 자세한 내용은 getsockopt (2)를 참조하십시오. 일반적인 경우는 옵션이 정수이고,이 경우 결과는 팩형 정수이며, &lt;code&gt;&lt;a href=&quot;unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; 을 사용하여 &lt;code&gt;i&lt;/code&gt; (또는 &lt;code&gt;I&lt;/code&gt; ) 형식으로 디코딩 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e9c09e2f85dbb39e869f16bb5dde4b83ed886b56" translate="yes" xml:space="preserve">
          <source>The function returns a pointer to the constructed subroutine. If the sub is anonymous then ownership of one counted reference to the subroutine is transferred to the caller. If the sub is named then the caller does not get ownership of a reference. In most such cases, where the sub has a non-phase name, the sub will be alive at the point it is returned by virtue of being contained in the glob that names it. A phase-named subroutine will usually be alive by virtue of the reference owned by the phase's automatic run queue. A &lt;code&gt;BEGIN&lt;/code&gt; subroutine may have been destroyed already by the time this function returns, but currently bugs occur in that case before the caller gets control. It is the caller's responsibility to ensure that it knows which of these situations applies.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9011070fbeb03f4af4eed5e55fde28d9eee21f2e" translate="yes" xml:space="preserve">
          <source>The function returns a pointer to the constructed subroutine. If the sub is anonymous then ownership of one counted reference to the subroutine is transferred to the caller. If the sub is named then the caller does not get ownership of a reference. In most such cases, where the sub has a non-phase name, the sub will be alive at the point it is returned by virtue of being contained in the glob that names it. A phase-named subroutine will usually be alive by virtue of the reference owned by the phase's automatic run queue. But a &lt;code&gt;BEGIN&lt;/code&gt; subroutine, having already been executed, will quite likely have been destroyed already by the time this function returns, making it erroneous for the caller to make any use of the returned pointer. It is the caller's responsibility to ensure that it knows which of these situations applies.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c416a15314ff142b876195908cf3e0998cacb0b" translate="yes" xml:space="preserve">
          <source>The function returns a true value if the file was written successfully. Otherwise it returns a false value.</source>
          <target state="translated">파일이 성공적으로 작성되면 함수는 true 값을 리턴합니다. 그렇지 않으면 거짓 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="96868ec2f844938f055b367738ce668b3149cb6e" translate="yes" xml:space="preserve">
          <source>The function returns the list of directories actually created during the call; in scalar context the number of directories created.</source>
          <target state="translated">이 함수는 호출 중에 실제로 작성된 디렉토리 목록을 리턴합니다. 스칼라 컨텍스트에서 작성된 디렉토리 수.</target>
        </trans-unit>
        <trans-unit id="74e8f0415f195a35d73e8c99a877efa398a5fbfc" translate="yes" xml:space="preserve">
          <source>The function returns the menu id of the selected push button:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30520da28728f4bcd1c4695681153ff43915f3de" translate="yes" xml:space="preserve">
          <source>The function returns the number of files successfully deleted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b560ee48a1c4113ae4a064c91e40e3ebfc92205" translate="yes" xml:space="preserve">
          <source>The function should be defined like this:</source>
          <target state="translated">함수는 다음과 같이 정의되어야합니다.</target>
        </trans-unit>
        <trans-unit id="af1dfdcedd7b6d95c274f658ea41922443e248ed" translate="yes" xml:space="preserve">
          <source>The function should return a reference to an array containing the parent classes in order. The names of the classes should be the result of calling &lt;code&gt;HvENAME()&lt;/code&gt; on the stash. In those cases where &lt;code&gt;HvENAME()&lt;/code&gt; returns null, &lt;code&gt;HvNAME()&lt;/code&gt; should be used instead.</source>
          <target state="translated">이 함수는 부모 클래스를 포함하는 배열에 대한 참조를 순서대로 반환해야합니다. 클래스 이름은 숨김에서 &lt;code&gt;HvENAME()&lt;/code&gt; 을 호출 한 결과 여야합니다 . 이러한 경우 &lt;code&gt;HvENAME()&lt;/code&gt; 반환, 널 (null) &lt;code&gt;HvNAME()&lt;/code&gt; 대신 사용한다.</target>
        </trans-unit>
        <trans-unit id="df40ff756f018edab3521eb313090bdefa039e32" translate="yes" xml:space="preserve">
          <source>The function takes as first argument a key to test against, and as second argument any form of criteria that are also allowed by the &lt;code&gt;allow&lt;/code&gt; key in the template.</source>
          <target state="translated">이 함수는 테스트 할 키를 첫 번째 인수로 &lt;code&gt;allow&lt;/code&gt; 하고 템플리트 의 allow 키에 의해 허용되는 모든 형태의 기준을 두 번째 인수로 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="f1378c8817cc1e710b51660b130f3baf8dd96ee6" translate="yes" xml:space="preserve">
          <source>The function takes one optional parameter, a reference to a hash. The contents of the hash allow the deflation interface to be tailored.</source>
          <target state="translated">이 함수는 해시에 대한 참조 인 하나의 선택적 매개 변수를 사용합니다. 해시의 내용을 통해 수축 인터페이스를 조정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="deea19e69043d11a7254610da5a869b1f9452180" translate="yes" xml:space="preserve">
          <source>The function that handles the &lt;code&gt;allow&lt;/code&gt; key in the template is also available for independent use.</source>
          <target state="translated">템플릿에서 &lt;code&gt;allow&lt;/code&gt; 키 를 처리하는 기능 도 독립적으로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="efcf392cc09771ca25c0652559e59fca2e7a7c50" translate="yes" xml:space="preserve">
          <source>The function visit() scans the SV arenas list, and calls a specified function for each SV it finds which is still live - ie which has an SvTYPE other than all 1's, and a non-zero SvREFCNT. visit() is used by the following functions (specified as [function that calls visit()] / [function called by visit() for each SV]):</source>
          <target state="translated">visit () 함수는 SV 아레나 목록을 스캔하고 각 SV에 대해 지정된 함수를 호출합니다. 즉, 여전히 존재하는 즉, 1 이외의 SvTYPE을 갖고 0이 아닌 SvREFCNT가 있습니다. visit ()는 다음 함수에서 사용됩니다 ([visit ()를 호출하는 함수] / [각 SV에 대해 visit ()에 의해 호출되는 함수]).</target>
        </trans-unit>
        <trans-unit id="8032aad3c9c6371a7328397cdc751815bd8235bd" translate="yes" xml:space="preserve">
          <source>The function will by default replace characters that can't be decoded by &quot;\x{FFFD}&quot;, the Unicode replacement character.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19570f411b75d35372886127cc2a69449d9a4b6b" translate="yes" xml:space="preserve">
          <source>The function will croak with &quot;Wide character in subroutine entry&quot; if $bytes contains characters with code above 255. The base64 encoding is only defined for single-byte characters. Use the Encode module to select the byte encoding you want.</source>
          <target state="translated">$ bytes에 코드가 255보다 큰 문자가 포함 된 경우 함수는 &quot;서브 루틴 항목의 넓은 문자&quot;로 표시됩니다. base64 인코딩은 1 바이트 문자에 대해서만 정의됩니다. 인코딩 모듈을 사용하여 원하는 바이트 인코딩을 선택하십시오.</target>
        </trans-unit>
        <trans-unit id="b2a6bb6e55b46f9d735e2cbaab0b636efd193e6e" translate="yes" xml:space="preserve">
          <source>The function,</source>
          <target state="translated">함수,</target>
        </trans-unit>
        <trans-unit id="56c2336779d3eb8fad6f134e1b3afd4055cf95fc" translate="yes" xml:space="preserve">
          <source>The function, &lt;code&gt;filter_add&lt;/code&gt; , actually installs the filter. It takes one parameter which should be a reference. The kind of reference used will dictate which of the two filter types will be used.</source>
          <target state="translated">&lt;code&gt;filter_add&lt;/code&gt; 함수 는 실제로 필터를 설치합니다. 하나의 매개 변수를 가져야하며 참조해야합니다. 사용되는 기준의 종류에 따라 두 가지 필터 유형 중 어느 것이 사용 될지가 결정됩니다.</target>
        </trans-unit>
        <trans-unit id="953ee510269653d7250cb2c022a3b5e06178a57a" translate="yes" xml:space="preserve">
          <source>The function, &lt;code&gt;filter_add&lt;/code&gt;, actually installs the filter. It takes one parameter which should be a reference. The kind of reference used will dictate which of the two filter types will be used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd8317ff780b8620fb08e8151dfdbf3a52d2d611" translate="yes" xml:space="preserve">
          <source>The function, &lt;code&gt;filter_del&lt;/code&gt; , is used to disable the current filter. It does not affect the running of the filter. All it does is tell Perl not to call filter any more.</source>
          <target state="translated">&lt;code&gt;filter_del&lt;/code&gt; 함수 는 현재 필터를 비활성화하는 데 사용됩니다. 필터 작동에는 영향을 미치지 않습니다. 필터를 더 이상 호출하지 않도록 Perl에 지시하면됩니다.</target>
        </trans-unit>
        <trans-unit id="5390ee2005fc8c59e72212b433101c76ad550f15" translate="yes" xml:space="preserve">
          <source>The function, &lt;code&gt;filter_del&lt;/code&gt;, is used to disable the current filter. It does not affect the running of the filter. All it does is tell Perl not to call filter any more.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e85467ff647b7ea9bd91bc8fa0103d9ae4aadb9f" translate="yes" xml:space="preserve">
          <source>The functional interface is simply importable functions with the same name as the algorithm. The functions take the message as argument and return the digest. Example:</source>
          <target state="translated">기능 인터페이스는 알고리즘과 동일한 이름을 가진 가져 오기 가능한 함수입니다. 함수는 메시지를 인수로 사용하고 요약을 리턴합니다. 예:</target>
        </trans-unit>
        <trans-unit id="bf5b597fcbc2815c78fabe6a0ba67f38e49a2b3d" translate="yes" xml:space="preserve">
          <source>The functional interface needs Perl5.005 or better.</source>
          <target state="translated">기능적 인터페이스에는 Perl5.005 이상이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="4bdd9d3e5903e6dd1f8e73f664d773008086b093" translate="yes" xml:space="preserve">
          <source>The functions</source>
          <target state="translated">기능</target>
        </trans-unit>
        <trans-unit id="856ff8ad4698542f2d294ec36a49315416bf6990" translate="yes" xml:space="preserve">
          <source>The functions &lt;a href=&quot;http://man.he.net/man3/recvmsg&quot;&gt;recvmsg(3)&lt;/a&gt;, &lt;a href=&quot;http://man.he.net/man3/sendmsg&quot;&gt;sendmsg(3)&lt;/a&gt;, and &lt;a href=&quot;http://man.he.net/man3/socketpair&quot;&gt;socketpair(3)&lt;/a&gt; are not implemented.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9afae1770d87c27f0936f76c113b3734ec61024b" translate="yes" xml:space="preserve">
          <source>The functions &lt;code&gt;accept()&lt;/code&gt;, &lt;code&gt;open()&lt;/code&gt;, &lt;code&gt;pipe()&lt;/code&gt;, &lt;code&gt;readpipe()&lt;/code&gt; (as well as the related &lt;code&gt;qx&lt;/code&gt; and &lt;code&gt;`STRING`&lt;/code&gt; operators), &lt;code&gt;socket()&lt;/code&gt;, &lt;code&gt;socketpair()&lt;/code&gt;, and &lt;code&gt;sysopen()&lt;/code&gt; are affected by the lexical value of this variable. The implicit &lt;a href=&quot;#ARGV&quot;&gt;&quot;ARGV&quot;&lt;/a&gt; handle opened by &lt;code&gt;readline()&lt;/code&gt; (or the related &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;&amp;lt;&amp;gt;&amp;gt;&lt;/code&gt; operators) on passed filenames is also affected (but not if it opens &lt;code&gt;STDIN&lt;/code&gt;). If this variable is not set, these functions will set the default layers as described in &lt;a href=&quot;perlio#Defaults-and-how-to-override-them&quot;&gt;&quot;Defaults and how to override them&quot; in PerlIO&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="68ff03911b440c28f50688f4c9ab7665ef4a1c34" translate="yes" xml:space="preserve">
          <source>The functions &lt;code&gt;cond_wait()&lt;/code&gt; and &lt;code&gt;cond_signal()&lt;/code&gt; can be used in conjunction with locks to notify co-operating threads that a resource has become available. They are very similar in use to the functions found in &lt;code&gt;pthreads&lt;/code&gt; . However for most purposes, queues are simpler to use and more intuitive. See &lt;a href=&quot;threads/shared&quot;&gt;threads::shared&lt;/a&gt; for more details.</source>
          <target state="translated">&lt;code&gt;cond_wait()&lt;/code&gt; 및 &lt;code&gt;cond_signal()&lt;/code&gt; 함수 를 잠금과 함께 사용하여 자원을 사용할 수 있음을 협력 스레드에 알릴 수 있습니다. 그것들은 &lt;code&gt;pthreads&lt;/code&gt; 에있는 함수들과 매우 유사 합니다 . 그러나 대부분의 경우 대기열은 사용하기 쉽고 직관적입니다. 자세한 내용은 &lt;a href=&quot;threads/shared&quot;&gt;threads :: shared&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="fdd336a11c2e07577ac0c13e1a2f33bcdcefa052" translate="yes" xml:space="preserve">
          <source>The functions &lt;code&gt;cond_wait()&lt;/code&gt; and &lt;code&gt;cond_signal()&lt;/code&gt; can be used in conjunction with locks to notify co-operating threads that a resource has become available. They are very similar in use to the functions found in &lt;code&gt;pthreads&lt;/code&gt;. However for most purposes, queues are simpler to use and more intuitive. See &lt;a href=&quot;threads::shared&quot;&gt;threads::shared&lt;/a&gt; for more details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29b4904f96b85af2bf6cf4659323a42dfc8558db" translate="yes" xml:space="preserve">
          <source>The functions and attributes are accessed via the &quot;tab&quot; (for table) member of &lt;code&gt;PerlIOl&lt;/code&gt; . The functions (methods of the layer &quot;class&quot;) are fixed, and are defined by the &lt;code&gt;PerlIO_funcs&lt;/code&gt; type. They are broadly the same as the public &lt;code&gt;PerlIO_xxxxx&lt;/code&gt; functions:</source>
          <target state="translated">함수와 속성은 &lt;code&gt;PerlIOl&lt;/code&gt; 의 &quot;테이블&quot;(테이블 용) 멤버를 통해 액세스합니다 . 기능 (계층 &quot;클래스&quot;의 방법)은 고정되어 있으며 &lt;code&gt;PerlIO_funcs&lt;/code&gt; 유형으로 정의됩니다 . 그것들은 공개 &lt;code&gt;PerlIO_xxxxx&lt;/code&gt; 함수 와 대체로 동일 합니다 :</target>
        </trans-unit>
        <trans-unit id="da42f49a5d951340d77c54e3152012268bbac221" translate="yes" xml:space="preserve">
          <source>The functions and attributes are accessed via the &quot;tab&quot; (for table) member of &lt;code&gt;PerlIOl&lt;/code&gt;. The functions (methods of the layer &quot;class&quot;) are fixed, and are defined by the &lt;code&gt;PerlIO_funcs&lt;/code&gt; type. They are broadly the same as the public &lt;code&gt;PerlIO_xxxxx&lt;/code&gt; functions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="641685ab6429ec4eade93850f03823bb632c2710" translate="yes" xml:space="preserve">
          <source>The functions and attributes of the &quot;layer class&quot;.</source>
          <target state="translated">&quot;계층 클래스&quot;의 기능 및 속성</target>
        </trans-unit>
        <trans-unit id="04a02ab73237464478de303a6921e51a12145bbd" translate="yes" xml:space="preserve">
          <source>The functions are modeled on those in</source>
          <target state="translated">기능은</target>
        </trans-unit>
        <trans-unit id="58e04ab7b2e7ccd7568d030e0e66721438c5c1d0" translate="yes" xml:space="preserve">
          <source>The functions in this module work as well as can be expected when used on earlier Unicode versions. But, obviously, they use the available data from that Unicode version. For example, if the Unicode version predates the definition of the script property (Unicode 3.1), then any function that deals with scripts is going to return &lt;code&gt;undef&lt;/code&gt; for the script portion of the return value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="529009dfac752f5a2536ceedfad4fb1e6f70b3ed" translate="yes" xml:space="preserve">
          <source>The functions in this section can serve as terms in an expression. They fall into two major categories: list operators and named unary operators. These differ in their precedence relationship with a following comma. (See the precedence table in &lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt;.) List operators take more than one argument, while unary operators can never take more than one argument. Thus, a comma terminates the argument of a unary operator, but merely separates the arguments of a list operator. A unary operator generally provides scalar context to its argument, while a list operator may provide either scalar or list contexts for its arguments. If it does both, scalar arguments come first and list argument follow, and there can only ever be one such list argument. For instance, &lt;a href=&quot;#splice-ARRAY%2COFFSET%2CLENGTH%2CLIST&quot;&gt;&lt;code&gt;splice&lt;/code&gt;&lt;/a&gt; has three scalar arguments followed by a list, whereas &lt;a href=&quot;#gethostbyname-NAME&quot;&gt;&lt;code&gt;gethostbyname&lt;/code&gt;&lt;/a&gt; has four scalar arguments.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de8f908f8a6f8cbbe7a5d22657a37b7e7e24b80c" translate="yes" xml:space="preserve">
          <source>The functions in this section can serve as terms in an expression. They fall into two major categories: list operators and named unary operators. These differ in their precedence relationship with a following comma. (See the precedence table in &lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt;.) List operators take more than one argument, while unary operators can never take more than one argument. Thus, a comma terminates the argument of a unary operator, but merely separates the arguments of a list operator. A unary operator generally provides scalar context to its argument, while a list operator may provide either scalar or list contexts for its arguments. If it does both, scalar arguments come first and list argument follow, and there can only ever be one such list argument. For instance, splice() has three scalar arguments followed by a list, whereas gethostbyname() has four scalar arguments.</source>
          <target state="translated">이 섹션의 함수는 표현식에서 용어로 사용될 수 있습니다. 이들은 목록 연산자와 명명 된 단항 연산자라는 두 가지 주요 범주로 분류됩니다. 이들은 다음 쉼표와의 우선 순위 관계가 다릅니다. (우선 순위표의&lt;a href=&quot;perlop&quot;&gt; 퍼롭&lt;/a&gt;.)리스트 연산자는 하나 이상의 인수를 취하는 반면 단항 연산자는 하나 이상의 인수를 가질 수 없습니다. 따라서 쉼표는 단항 연산자의 인수를 종료하지만 목록 연산자의 인수 만 분리합니다. 단항 연산자는 일반적으로 인수에 스칼라 컨텍스트를 제공하는 반면 목록 연산자는 인수에 스칼라 또는 목록 컨텍스트를 제공 할 수 있습니다. 둘 다 수행하면 스칼라 인수가 먼저 나오고 목록 인수가 뒤 따르며 그러한 목록 인수는 하나만있을 수 있습니다. 예를 들어 splice ()에는 3 개의 스칼라 인수와리스트가 있고 gethostbyname ()에는 4 개의 스칼라 인수가 있습니다.</target>
        </trans-unit>
        <trans-unit id="db44e2533a11b8e3bb17098404db4eb4f6f38bb9" translate="yes" xml:space="preserve">
          <source>The functions not currently implemented include:</source>
          <target state="translated">현재 구현되지 않은 기능은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c91d15f478afdf6edcd21180f278e6de93659c87" translate="yes" xml:space="preserve">
          <source>The functions returns the number of files successfully deleted.</source>
          <target state="translated">이 함수는 성공적으로 삭제 된 파일 수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="f6bd4366287856a0db88fc6b5b6a7d5f623cdf54" translate="yes" xml:space="preserve">
          <source>The functions that create ops, which have names like &lt;code&gt;newUNOP&lt;/code&gt; and &lt;code&gt;newBINOP&lt;/code&gt;, call a &quot;check&quot; function associated with each op type, before returning the op. The check functions can mangle the op as they see fit, and even replace it with an entirely new one. These functions are defined in</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2856f3e4382d9f450458c2b6360a3461fef80e3f" translate="yes" xml:space="preserve">
          <source>The functions were deprecated in Perl 5.20, and removed in Perl 5.24.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96c725eeff7e9a331143580354d26ee52b59f30b" translate="yes" xml:space="preserve">
          <source>The gb2312han ordering includes 5 code points in private use area (E2D8..E2DC), that can't utilize &lt;code&gt;weightGB2312()&lt;/code&gt; for collation. For them, use &lt;code&gt;entry&lt;/code&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25c6db468e398f8e94d67db3b6a47dc8ea853c6f" translate="yes" xml:space="preserve">
          <source>The gcc option &lt;code&gt;-Wdeclaration-after-statement&lt;/code&gt; scans for such problems (by default on starting from Perl 5.9.4).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8f00447c143aee7d5d5fe37917ea4e13f05bb95" translate="yes" xml:space="preserve">
          <source>The gcc option &lt;code&gt;-Wdeclaration-after-statements&lt;/code&gt; scans for such problems (by default on starting from Perl 5.9.4).</source>
          <target state="translated">gcc 옵션 &lt;code&gt;-Wdeclaration-after-statements&lt;/code&gt; 는 이러한 문제점을 스캔합니다 (기본적으로 Perl 5.9.4부터 시작).</target>
        </trans-unit>
        <trans-unit id="5ee3a23159a200898de862e7d5879870227625eb" translate="yes" xml:space="preserve">
          <source>The gcc option &lt;code&gt;-Wendif-labels&lt;/code&gt; warns about the bad variant (by default on starting from Perl 5.9.4).</source>
          <target state="translated">gcc 옵션 &lt;code&gt;-Wendif-labels&lt;/code&gt; 는 잘못된 변형에 대해 경고합니다 (기본적으로 Perl 5.9.4부터 시작).</target>
        </trans-unit>
        <trans-unit id="4d2d0d644a6adc7963542dd47a318273c10c274d" translate="yes" xml:space="preserve">
          <source>The gcc option &lt;code&gt;-Wformat&lt;/code&gt; scans for such problems.</source>
          <target state="translated">gcc 옵션 &lt;code&gt;-Wformat&lt;/code&gt; 은 이러한 문제를 스캔합니다.</target>
        </trans-unit>
        <trans-unit id="e2a941e3cdebbe41caee4c09c99b319335c33a51" translate="yes" xml:space="preserve">
          <source>The general answer is to use a CPAN module such as &lt;a href=&quot;Switch::Plain&quot;&gt;Switch::Plain&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af02f4de16ebe9571db6e3223402235667685fe3" translate="yes" xml:space="preserve">
          <source>The general format of this hash ref is</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b02921462c864d8e6c2a3ae360252bde69882166" translate="yes" xml:space="preserve">
          <source>The general structure of this module was written by Paul Evans &amp;lt;leonerd@leonerd.org.uk&amp;gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db3325d45be5f27fbb2d4ff677421100e7fd8bb0" translate="yes" xml:space="preserve">
          <source>The generated C++ code will call &lt;code&gt;new&lt;/code&gt; .</source>
          <target state="translated">생성 된 C ++ 코드는 &lt;code&gt;new&lt;/code&gt; 를 호출 합니다.</target>
        </trans-unit>
        <trans-unit id="2c6b61d936feb406f72b49e0c15b50e08be699f5" translate="yes" xml:space="preserve">
          <source>The generated C++ code will call &lt;code&gt;new&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d40f7df8e8a0ceca1fdf5c8cc98299f799cdbb11" translate="yes" xml:space="preserve">
          <source>The generated Makefile enables the user of the extension to invoke</source>
          <target state="translated">생성 된 Makefile을 사용하면 확장 사용자가 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ddf93e71778e5593e96208d788b15d2297c9188f" translate="yes" xml:space="preserve">
          <source>The generated singletons are kept around from instantiation until the end of the shell session. &amp;lt;plugin_list&amp;gt; can be reconfigured at any time at run time. While the cpan shell is running, it checks all activated plugins at each of the 8 reference points listed above and runs the respective method if it is implemented for that object. The method is called with the active CPAN::Distribution object passed in as an argument.</source>
          <target state="translated">생성 된 싱글 톤은 인스턴스화에서 셸 세션이 끝날 때까지 유지됩니다. &amp;lt;plugin_list&amp;gt;는 런타임에 언제든지 재구성 할 수 있습니다. cpan 쉘이 실행되는 동안 위에 나열된 8 개의 참조 지점 각각에서 활성화 된 모든 플러그인을 확인하고 해당 오브젝트에 대해 구현 된 경우 해당 메소드를 실행합니다. 메소드는 인수로 전달 된 활성 CPAN :: Distribution 오브젝트와 함께 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="04c9e6d408a35a88cbae891becfacfd45984120c" translate="yes" xml:space="preserve">
          <source>The generated trailer for a CODE: section ensures that the number of return values Perl will see is either 0 or 1 (depending on the &lt;code&gt;void&lt;/code&gt; ness of the return value of the C function, and heuristics mentioned in &lt;a href=&quot;#The-RETVAL-Variable&quot;&gt;The RETVAL Variable&lt;/a&gt;). The trailer generated for a PPCODE: section is based on the number of return values and on the number of times &lt;code&gt;SP&lt;/code&gt; was updated by &lt;code&gt;[X]PUSH*()&lt;/code&gt; macros.</source>
          <target state="translated">CODE : 섹션에 대해 생성 된 트레일러는 Perl에 표시되는 반환 값의 수가 0 또는 1임을 보장합니다 ( C 함수의 반환 값의 &lt;code&gt;void&lt;/code&gt; 및 &lt;a href=&quot;#The-RETVAL-Variable&quot;&gt;RETVAL 변수에&lt;/a&gt; 언급 된 휴리스틱 에 따라 다름 ). PPCODE : 섹션에 대해 생성 된 트레일러는 반환 값의 수와 &lt;code&gt;SP&lt;/code&gt; 가 &lt;code&gt;[X]PUSH*()&lt;/code&gt; 매크로에 의해 업데이트 된 횟수를 기반으로 합니다.</target>
        </trans-unit>
        <trans-unit id="7153904b949c21e4b5069542df02f96114b91ebc" translate="yes" xml:space="preserve">
          <source>The generated trailer for a CODE: section ensures that the number of return values Perl will see is either 0 or 1 (depending on the &lt;code&gt;void&lt;/code&gt;ness of the return value of the C function, and heuristics mentioned in &lt;a href=&quot;#The-RETVAL-Variable&quot;&gt;&quot;The RETVAL Variable&quot;&lt;/a&gt;). The trailer generated for a PPCODE: section is based on the number of return values and on the number of times &lt;code&gt;SP&lt;/code&gt; was updated by &lt;code&gt;[X]PUSH*()&lt;/code&gt; macros.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78ff48f0e128b0a15571a8a0caa4b35598c3501a" translate="yes" xml:space="preserve">
          <source>The generation number of the name at offset &lt;code&gt;po&lt;/code&gt; in the current compiling pad (lvalue).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="147459e5132af1acc303407a971ff312e870e58e" translate="yes" xml:space="preserve">
          <source>The generation number of the name at offset &lt;code&gt;po&lt;/code&gt; in the current compiling pad (lvalue). Note that &lt;code&gt;SvUVX&lt;/code&gt; is hijacked for this purpose.</source>
          <target state="translated">현재 컴파일 패드의 오프셋 &lt;code&gt;po&lt;/code&gt; 에서 이름의 생성 번호 (lvalue). 참고 &lt;code&gt;SvUVX&lt;/code&gt; 는 이 목적을 위해 납치된다.</target>
        </trans-unit>
        <trans-unit id="65beebb121c6a44259be26715db186e4a704f7cf" translate="yes" xml:space="preserve">
          <source>The generic flag bits are a hybrid of &lt;code&gt;O_XXXXX&lt;/code&gt; style flags deduced from the mode string passed to &lt;code&gt;PerlIO_open()&lt;/code&gt; , and state bits for typical buffer layers.</source>
          <target state="translated">일반 플래그 비트는 &lt;code&gt;PerlIO_open()&lt;/code&gt; 전달 된 모드 문자열에서 추론 된 &lt;code&gt;O_XXXXX&lt;/code&gt; 스타일 플래그 와 일반적인 버퍼 계층의 상태 비트 의 하이브리드입니다 .</target>
        </trans-unit>
        <trans-unit id="7439e63d8439f40f7da5afff81864b98adf5ed8e" translate="yes" xml:space="preserve">
          <source>The generic flag bits are a hybrid of &lt;code&gt;O_XXXXX&lt;/code&gt; style flags deduced from the mode string passed to &lt;code&gt;PerlIO_open()&lt;/code&gt;, and state bits for typical buffer layers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9373f74aec3f2b814c36a72b32de7c1df8cce7e8" translate="yes" xml:space="preserve">
          <source>The generic names by which a &lt;b&gt;subroutine&lt;/b&gt; knows its &lt;b&gt;arguments&lt;/b&gt;. In many languages, formal arguments are always given individual names; in Perl, the formal arguments are just the elements of an array. The formal arguments to a Perl program are &lt;code&gt;$ARGV[0]&lt;/code&gt; , &lt;code&gt;$ARGV[1]&lt;/code&gt; , and so on. Similarly, the formal arguments to a Perl subroutine are &lt;code&gt;$_[0]&lt;/code&gt; , &lt;code&gt;$_[1]&lt;/code&gt; , and so on. You may give the arguments individual names by assigning the values to a &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; list. See also &lt;b&gt;actual arguments&lt;/b&gt;.</source>
          <target state="translated">&lt;b&gt;서브 루틴&lt;/b&gt; 이 &lt;b&gt;인수를&lt;/b&gt; 알고 있는 일반 이름 . 많은 언어에서 공식적인 논쟁은 항상 개별적인 이름으로 주어집니다. Perl에서 형식 인수는 배열의 요소 일뿐입니다. Perl 프로그램에 대한 공식 인수는 &lt;code&gt;$ARGV[0]&lt;/code&gt; , &lt;code&gt;$ARGV[1]&lt;/code&gt; 등입니다. 마찬가지로 Perl 서브 루틴에 대한 공식 인수는 &lt;code&gt;$_[0]&lt;/code&gt; , &lt;code&gt;$_[1]&lt;/code&gt; 등입니다. 값을 &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; 목록 에 지정하여 인수에 개별 이름을 지정할 수 있습니다 . &lt;b&gt;실제 인수&lt;/b&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f91ba75da27279a516590191fc599f042d12a39a" translate="yes" xml:space="preserve">
          <source>The generic names by which a &lt;b&gt;subroutine&lt;/b&gt; knows its &lt;b&gt;arguments&lt;/b&gt;. In many languages, formal arguments are always given individual names; in Perl, the formal arguments are just the elements of an array. The formal arguments to a Perl program are &lt;code&gt;$ARGV[0]&lt;/code&gt;, &lt;code&gt;$ARGV[1]&lt;/code&gt;, and so on. Similarly, the formal arguments to a Perl subroutine are &lt;code&gt;$_[0]&lt;/code&gt;, &lt;code&gt;$_[1]&lt;/code&gt;, and so on. You may give the arguments individual names by assigning the values to a &lt;code&gt;my&lt;/code&gt; list. See also &lt;b&gt;actual arguments&lt;/b&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e34968429c314c796b06ef13d6256c2eed375227" translate="yes" xml:space="preserve">
          <source>The get_dup() Method</source>
          <target state="translated">get_dup () 메소드</target>
        </trans-unit>
        <trans-unit id="777933c68edb9f2b520827371d959a89885f825a" translate="yes" xml:space="preserve">
          <source>The getaddrinfo() function converts a hostname and a service name into a list of structures, each containing a potential way to connect() to the named service on the named host.</source>
          <target state="translated">getaddrinfo () 함수는 호스트 이름과 서비스 이름을 구조 목록으로 변환합니다. 각 목록에는 명명 된 호스트의 명명 된 서비스에 연결할 수있는 방법이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="b2567e2f657f48e5ffd91f457d438d649766ac8c" translate="yes" xml:space="preserve">
          <source>The getdcwd() function is also provided on Win32 to get the current working directory on the specified drive, since Windows maintains a separate current working directory for each drive. If no drive is specified then the current drive is assumed.</source>
          <target state="translated">getdcwd () 함수는 Windows가 각 드라이브에 대해 별도의 현재 작업 디렉토리를 유지 보수하므로 지정된 드라이브에서 현재 작업 디렉토리를 얻기 위해 Win32에 제공됩니다. 드라이브를 지정하지 않으면 현재 드라이브가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="7ef18c4cc3726de3de6ec3372bc632ef914a89f5" translate="yes" xml:space="preserve">
          <source>The getgr() function is a simple front-end that forwards a numeric argument to getgrgid() and the rest to getgrnam().</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60ed783ab1755c8923c2106affd806182a9b2682" translate="yes" xml:space="preserve">
          <source>The gethost() function is a simple front-end that forwards a numeric argument to gethostbyaddr() by way of Socket::inet_aton, and the rest to gethostbyname().</source>
          <target state="translated">gethost () 함수는 Socket :: inet_aton을 통해 숫자 인수를 gethostbyaddr ()에 전달하고 나머지는 gethostbyname ()에 전달하는 간단한 프론트 엔드입니다.</target>
        </trans-unit>
        <trans-unit id="91be5f2becab7f44b4c2d8e8646f84ed2e15605f" translate="yes" xml:space="preserve">
          <source>The gethost() functions do this in the Perl core:</source>
          <target state="translated">gethost () 함수는 Perl 코어에서이를 수행합니다.</target>
        </trans-unit>
        <trans-unit id="3d809f6317a210fb06b8763a59c516ccb0250c8f" translate="yes" xml:space="preserve">
          <source>The getnameinfo() function converts a socket address, such as returned by getsockname() or getpeername(), into a pair of human-readable strings representing the address and service name.</source>
          <target state="translated">getnameinfo () 함수는 getsockname () 또는 getpeername ()에 의해 리턴 된 소켓 주소를 주소와 서비스 이름을 나타내는 사람이 읽을 수있는 문자열 쌍으로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="c7341d184608dfa3d666b4de167cfb9267a092b7" translate="yes" xml:space="preserve">
          <source>The getnet() function is a simple front-end that forwards a numeric argument to getnetbyaddr(), and the rest to getnetbyname().</source>
          <target state="translated">getnet () 함수는 숫자 인수를 getnetbyaddr ()에 전달하고 나머지는 getnetbyname ()에 전달하는 간단한 프론트 엔드입니다.</target>
        </trans-unit>
        <trans-unit id="a2bc6ce1fe12be1b0104870e6335dfcba678d52a" translate="yes" xml:space="preserve">
          <source>The getnet() functions do this in the Perl core:</source>
          <target state="translated">getnet () 함수는 Perl 코어에서이를 수행합니다.</target>
        </trans-unit>
        <trans-unit id="723d74402111c283b1693c27eac4e9e45b8e6ed9" translate="yes" xml:space="preserve">
          <source>The getproto() function is a simple front-end that forwards a numeric argument to getprotobyport(), and the rest to getprotobyname().</source>
          <target state="translated">getproto () 함수는 숫자 인수를 getprotobyport ()로 전달하고 나머지는 getprotobyname ()으로 전달하는 간단한 프론트 엔드입니다.</target>
        </trans-unit>
        <trans-unit id="7135ce934ee6874d87ad890231c34f496a98c1a0" translate="yes" xml:space="preserve">
          <source>The getpw() function is a simple front-end that forwards a numeric argument to getpwuid() and the rest to getpwnam().</source>
          <target state="translated">getpw () 함수는 숫자 인수를 getpwuid ()로 전달하고 나머지는 getpwnam ()으로 전달하는 간단한 프론트 엔드입니다.</target>
        </trans-unit>
        <trans-unit id="0d0b8e4657c6706a0314a90d140b3591ebd5a9bb" translate="yes" xml:space="preserve">
          <source>The getserv() function is a simple front-end that forwards a numeric argument to getservbyport(), and the rest to getservbyname().</source>
          <target state="translated">getserv () 함수는 숫자 인수를 getservbyport ()로 전달하고 나머지는 getservbyname ()으로 전달하는 간단한 프론트 엔드입니다.</target>
        </trans-unit>
        <trans-unit id="7b3093ca7aacbd788d18481992e739fec224cedd" translate="yes" xml:space="preserve">
          <source>The given arguments are made consistent as though by calling &lt;code&gt;mktime()&lt;/code&gt; before calling your system's &lt;code&gt;strftime()&lt;/code&gt; function, except that the &lt;code&gt;isdst&lt;/code&gt; value is not affected.</source>
          <target state="translated">주어진 인수는 &lt;code&gt;isdst&lt;/code&gt; 값이 영향을받지 않는 것을 제외하고 시스템의 &lt;code&gt;strftime()&lt;/code&gt; 함수 를 호출하기 전에 &lt;code&gt;mktime()&lt;/code&gt; 을 호출 하는 것처럼 일관성 이 있습니다.</target>
        </trans-unit>
        <trans-unit id="a46f0a3dc0d7705f81eb9d2736f8d38ab0c36cf3" translate="yes" xml:space="preserve">
          <source>The given link to</source>
          <target state="translated">에 주어진 링크</target>
        </trans-unit>
        <trans-unit id="1b7e0113518a74a9ca8cd3adb44721180fc0bb94" translate="yes" xml:space="preserve">
          <source>The glob angle-bracket operator &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; is a pathname generator that implements the rules for file name pattern matching used by Unix-like shells such as the Bourne shell or C shell.</source>
          <target state="translated">glob 꺾쇠 괄호 연산자 &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; 는 Bourne 쉘 또는 C 쉘과 같은 Unix와 유사한 쉘에서 사용하는 파일 이름 패턴 일치 규칙을 구현하는 경로 이름 생성기입니다.</target>
        </trans-unit>
        <trans-unit id="5e215c589947f616aa94dd5242e9494420cfca28" translate="yes" xml:space="preserve">
          <source>The glob containing the output field separator - &lt;code&gt;*,&lt;/code&gt; in Perl space.</source>
          <target state="translated">Perl 공간에서 출력 필드 구분 기호- &lt;code&gt;*,&lt;/code&gt; 포함하는 glob .</target>
        </trans-unit>
        <trans-unit id="72ac12b62c28c3baeece5702a243d181ecdda5a0" translate="yes" xml:space="preserve">
          <source>The glob was stopped because an error was encountered.</source>
          <target state="translated">오류가 발생하여 글로브가 중지되었습니다.</target>
        </trans-unit>
        <trans-unit id="f628027fc4ac19b3e64d6b57171d06712a0f4de2" translate="yes" xml:space="preserve">
          <source>The global &lt;code&gt;debug&lt;/code&gt; and &lt;code&gt;debugcolor&lt;/code&gt; pragmas allow one to get detailed debugging info about regexp compilation and execution. &lt;code&gt;debugcolor&lt;/code&gt; is the same as debug, except the debugging information is displayed in color on terminals that can display termcap color sequences. Here is example output:</source>
          <target state="translated">전역 &lt;code&gt;debug&lt;/code&gt; 및 디버그 &lt;code&gt;debugcolor&lt;/code&gt; pragma를 사용하면 정규 표현식 컴파일 및 실행에 대한 자세한 디버깅 정보를 얻을 수 있습니다. &lt;code&gt;debugcolor&lt;/code&gt; 은 디버깅 정보 TERMCAP 컬러 시퀀스를 표시 할 수있는 단말기에 색으로 표시되는 것을 제외하고, 디버그와 동일하다. 다음은 예제 출력입니다.</target>
        </trans-unit>
        <trans-unit id="2364252b351b212be51c3b8e4ec104f73d0c11a2" translate="yes" xml:space="preserve">
          <source>The global variable $Devel::Peek::pv_limit can be set to limit the number of character printed in various string values. Setting it to 0 means no limit.</source>
          <target state="translated">글로벌 변수 $ Devel :: Peek :: pv_limit는 다양한 문자열 값으로 인쇄되는 문자 수를 제한하도록 설정할 수 있습니다. 0으로 설정하면 제한이 없습니다.</target>
        </trans-unit>
        <trans-unit id="8c46d35ee4a0a86a8c41ca71ad737aa7e8fc9118" translate="yes" xml:space="preserve">
          <source>The global variables, like &lt;code&gt;@ARGV&lt;/code&gt; or the punctuation variables, must be &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt;ized with &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local()&lt;/a&gt;&lt;/code&gt;. This block reads in</source>
          <target state="translated">같은 글로벌 변수, &lt;code&gt;@ARGV&lt;/code&gt; 또는 구두점 변수가되어야 &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; 으로화된 &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local()&lt;/a&gt;&lt;/code&gt; . 이 블록은</target>
        </trans-unit>
        <trans-unit id="8eb2db16d327a3b3a5febe18528925e67ce48750" translate="yes" xml:space="preserve">
          <source>The global variables, like &lt;code&gt;@ARGV&lt;/code&gt; or the punctuation variables, must be &lt;code&gt;local&lt;/code&gt;ized with &lt;code&gt;local()&lt;/code&gt;. This block reads in</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9fffe8d3b97109dc55047625158598478b942552" translate="yes" xml:space="preserve">
          <source>The glossary of this document is based upon this site.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="968cbdca6785865baa2b963e00c7cf59fd1ce4f6" translate="yes" xml:space="preserve">
          <source>The glue code pulls the arguments from the Perl stack, converts these Perl values to the formats expected by a C function, call this C function, transfers the return values of the C function back to Perl. Return values here may be a conventional C return value or any C function arguments that may serve as output parameters. These return values may be passed back to Perl either by putting them on the Perl stack, or by modifying the arguments supplied from the Perl side.</source>
          <target state="translated">글루 코드는 Perl 스택에서 인수를 가져 와서이 Perl 값을 C 함수에 의해 예상되는 형식으로 변환하고이 C 함수를 호출하며 C 함수의 반환 값을 Perl로 다시 전송합니다. 여기서 리턴 값은 일반적인 C 리턴 값이거나 출력 매개 변수로 사용될 수있는 C 함수 인수 일 수 있습니다. 이러한 리턴 값은 Perl 스택에 놓거나 Perl 측에서 제공된 인수를 수정하여 Perl로 다시 전달 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cfb79bdb1e9bdcf50c5258db72c30cb6aeb1e3e1" translate="yes" xml:space="preserve">
          <source>The gmctime() function provides a way of getting at the scalar sense of the original CORE::gmtime() function.</source>
          <target state="translated">gmctime () 함수는 원래 CORE :: gmtime () 함수의 스칼라 감지 방법을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="15e78ea46607c2d827f12212191bcd40dffea850" translate="yes" xml:space="preserve">
          <source>The goal here is to have a testing utility that's simple to learn, quick to use and difficult to trip yourself up with while still providing more flexibility than the existing Test.pm. As such, the names of the most common routines are kept tiny, special cases and magic side-effects are kept to a minimum. WYSIWYG.</source>
          <target state="translated">여기서 목표는 기존의 Test.pm보다 더 많은 유연성을 제공하면서도 배우기 쉽고, 사용하기 쉽고, 스스로 학습하기 어려운 테스트 유틸리티를 사용하는 것입니다. 따라서 가장 일반적인 루틴의 이름은 작게 유지되고 특별한 경우와 마법의 부작용은 최소화됩니다. 위지 위그</target>
        </trans-unit>
        <trans-unit id="a352895328c4895bdf1e088252c7cfc98a73fd07" translate="yes" xml:space="preserve">
          <source>The goal of the CPAN Testers project (&lt;a href=&quot;http://testers.cpan.org/&quot;&gt;http://testers.cpan.org/&lt;/a&gt;) is to test as many CPAN packages as possible on as many platforms as possible. This provides valuable feedback to module authors and potential users to identify bugs or platform compatibility issues and improves the overall quality and value of CPAN.</source>
          <target state="translated">CPAN 테스터 프로젝트 ( &lt;a href=&quot;http://testers.cpan.org/&quot;&gt;http://testers.cpan.org/&lt;/a&gt; ) 의 목표는 가능한 많은 플랫폼에서 가능한 많은 CPAN 패키지를 테스트하는 것입니다. 이는 모듈 작성자와 잠재적 사용자에게 버그 나 플랫폼 호환성 문제를 식별하고 CPAN의 전반적인 품질과 가치를 향상시키는 귀중한 피드백을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="dc55056f0c4ea6c7742a56f2eaefd841cb6edeb2" translate="yes" xml:space="preserve">
          <source>The goal of the CPAN Testers project (http://testers.cpan.org/) is to test as many CPAN packages as possible on as many platforms as possible. This provides valuable feedback to module authors and potential users to identify bugs or platform compatibility issues and improves the overall quality and value of CPAN.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="373cfbe1fa7d52d17deaf7ae1d8864f358d08a8b" translate="yes" xml:space="preserve">
          <source>The good news is that at least some DBM module should be available, and &lt;a href=&quot;anydbm_file&quot;&gt;&lt;code&gt;AnyDBM_File&lt;/code&gt;&lt;/a&gt; will use whichever module it can find. Of course, then the code needs to be fairly strict, dropping to the greatest common factor (e.g., not exceeding 1K for each record), so that it will work with any DBM module. See &lt;a href=&quot;anydbm_file&quot;&gt;AnyDBM_File&lt;/a&gt; for more details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c4f9c804c591c85f4c73346c685fe6b75566956" translate="yes" xml:space="preserve">
          <source>The good news is that at least some DBM module should be available, and &lt;code&gt;AnyDBM_File&lt;/code&gt; will use whichever module it can find. Of course, then the code needs to be fairly strict, dropping to the greatest common factor (e.g., not exceeding 1K for each record), so that it will work with any DBM module. See &lt;a href=&quot;anydbm_file&quot;&gt;AnyDBM_File&lt;/a&gt; for more details.</source>
          <target state="translated">좋은 소식은 최소한 일부 DBM 모듈을 사용할 수 있어야하며 &lt;code&gt;AnyDBM_File&lt;/code&gt; 은 찾을 수있는 모듈을 사용 한다는 것입니다. 물론 코드는 매우 엄격해야하며 가장 큰 공통 요소 (예 : 각 레코드 당 1K를 초과하지 않음)로 떨어 지므로 모든 DBM 모듈에서 작동합니다. 자세한 내용은 &lt;a href=&quot;anydbm_file&quot;&gt;AnyDBM_File&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="0b5a1d8ce58ba1e38f16f3a0f1eb5ac058c6d368" translate="yes" xml:space="preserve">
          <source>The good old C code quality inspector, &lt;code&gt;lint&lt;/code&gt; , is available in several platforms, but please be aware that there are several different implementations of it by different vendors, which means that the flags are not identical across different platforms.</source>
          <target state="translated">오래된 C 코드 품질 검사기 인 &lt;code&gt;lint&lt;/code&gt; 는 여러 플랫폼에서 사용할 수 있지만 여러 공급 업체에서 구현 한 여러 가지 구현이 있으므로 플래그가 다른 플랫폼에서 동일하지 않다는 점에 유의하십시오.</target>
        </trans-unit>
        <trans-unit id="339c076fdfc281a53eef98387e350ea8944bc3d1" translate="yes" xml:space="preserve">
          <source>The good old C code quality inspector, &lt;code&gt;lint&lt;/code&gt;, is available in several platforms, but please be aware that there are several different implementations of it by different vendors, which means that the flags are not identical across different platforms.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64a4aa574c2f36a349fb65698d1079a80c8716e6" translate="yes" xml:space="preserve">
          <source>The grammar gives you the following rule: you can make the thing on the left of the colon if you see all the things on the right in sequence. This is called a &quot;reduction&quot;, and the aim of parsing is to completely reduce the input. There are several different ways you can perform a reduction, separated by vertical bars: so, &lt;code&gt;term&lt;/code&gt; followed by &lt;code&gt;=&lt;/code&gt; followed by &lt;code&gt;term&lt;/code&gt; makes a &lt;code&gt;term&lt;/code&gt; , and &lt;code&gt;term&lt;/code&gt; followed by &lt;code&gt;+&lt;/code&gt; followed by &lt;code&gt;term&lt;/code&gt; can also make a &lt;code&gt;term&lt;/code&gt; .</source>
          <target state="translated">문법은 다음과 같은 규칙을 제공합니다. 오른쪽에있는 모든 것을 순서대로 보면 콜론 왼쪽에있는 것을 만들 수 있습니다. 이것을 &quot;감소&quot;라고하며 구문 분석의 목적은 입력을 완전히 줄이는 것입니다. 수직 막대로 구분 당신이 감소를 수행 할 수있는 여러 가지 방법이 있습니다 : 그래서, &lt;code&gt;term&lt;/code&gt; 다음 &lt;code&gt;=&lt;/code&gt; 다음 &lt;code&gt;term&lt;/code&gt; 하게 &lt;code&gt;term&lt;/code&gt; 및 &lt;code&gt;term&lt;/code&gt; 다음 &lt;code&gt;+&lt;/code&gt; 는 다음 &lt;code&gt;term&lt;/code&gt; 도 할 수 있습니다 &lt;code&gt;term&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="99ddf81d340c9da6ddca44ef926625a7b314c62b" translate="yes" xml:space="preserve">
          <source>The grammar gives you the following rule: you can make the thing on the left of the colon if you see all the things on the right in sequence. This is called a &quot;reduction&quot;, and the aim of parsing is to completely reduce the input. There are several different ways you can perform a reduction, separated by vertical bars: so, &lt;code&gt;term&lt;/code&gt; followed by &lt;code&gt;=&lt;/code&gt; followed by &lt;code&gt;term&lt;/code&gt; makes a &lt;code&gt;term&lt;/code&gt;, and &lt;code&gt;term&lt;/code&gt; followed by &lt;code&gt;+&lt;/code&gt; followed by &lt;code&gt;term&lt;/code&gt; can also make a &lt;code&gt;term&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f689a3c521cea873db9ec7a159a154a44941fb63" translate="yes" xml:space="preserve">
          <source>The grammar, lines one and three of the snippet above, tells you how to build up more complex forms. These complex forms, &quot;non-terminal symbols&quot; are generally placed in lower case. &lt;code&gt;term&lt;/code&gt; here is a non-terminal symbol, representing a single expression.</source>
          <target state="translated">위의 스 니펫의 1 ~ 3 행에있는 문법은 더 복잡한 양식을 작성하는 방법을 알려줍니다. 이러한 복잡한 형태 &quot;비 터미널 기호&quot;는 일반적으로 소문자로 표시됩니다. 여기에서 사용 된 &lt;code&gt;term&lt;/code&gt; 는 단일 표현식을 나타내는 비 터미널 기호입니다.</target>
        </trans-unit>
        <trans-unit id="d748b942ca422b33db3c9c207b20fcf5e35fbf06" translate="yes" xml:space="preserve">
          <source>The great_circle_midpoint() is just a special case of</source>
          <target state="translated">great_circle_midpoint ()는 특별한 경우입니다</target>
        </trans-unit>
        <trans-unit id="65a277526deeb0c81c0a5dcd559529318f7f89a5" translate="yes" xml:space="preserve">
          <source>The group as a whole is interpreted as follows:</source>
          <target state="translated">그룹 전체는 다음과 같이 해석됩니다.</target>
        </trans-unit>
        <trans-unit id="fc9b7c0745af45eb8fd74cee86dd53c561106e37" translate="yes" xml:space="preserve">
          <source>The group id owning the file</source>
          <target state="translated">파일을 소유 한 그룹 ID</target>
        </trans-unit>
        <trans-unit id="163b6e7222a22b065c1007b2d5c671945f219faa" translate="yes" xml:space="preserve">
          <source>The group name that owns the file</source>
          <target state="translated">파일을 소유 한 그룹 이름</target>
        </trans-unit>
        <trans-unit id="89fddac9a52f335bd6aece8163a19a7049c17f30" translate="yes" xml:space="preserve">
          <source>The grouping assigns a value to &lt;code&gt;\g1&lt;/code&gt;, so that the same 3-letter sequence is used for both parts.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5464b947891c7dfe478004d22eea99e392c2554b" translate="yes" xml:space="preserve">
          <source>The grouping assigns a value to \g1, so that the same 3-letter sequence is used for both parts.</source>
          <target state="translated">그룹화는 \ g1에 값을 할당하므로 두 부분에 동일한 3 문자 시퀀스가 ​​사용됩니다.</target>
        </trans-unit>
        <trans-unit id="28563bfc58252e6ce5590c38ddeee29b7156bffa" translate="yes" xml:space="preserve">
          <source>The grouping construct &lt;code&gt;( ... )&lt;/code&gt; creates capture groups (also referred to as capture buffers). To refer to the current contents of a group later on, within the same pattern, use &lt;code&gt;\g1&lt;/code&gt; (or &lt;code&gt;\g{1}&lt;/code&gt;) for the first, &lt;code&gt;\g2&lt;/code&gt; (or &lt;code&gt;\g{2}&lt;/code&gt;) for the second, and so on. This is called a</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a808380dda4fa48a019446ad652d6dc63c38be3d" translate="yes" xml:space="preserve">
          <source>The grouping metacharacters &lt;code&gt;()&lt;/code&gt; also allow the extraction of the parts of a string that matched. For each grouping, the part that matched inside goes into the special variables &lt;code&gt;$1&lt;/code&gt; , &lt;code&gt;$2&lt;/code&gt; , etc. They can be used just as ordinary variables:</source>
          <target state="translated">그룹화 메타 문자 &lt;code&gt;()&lt;/code&gt; 를 사용하면 일치하는 문자열 부분을 추출 할 수도 있습니다. 각 그룹화에서 내부와 일치하는 부분은 특수 변수 &lt;code&gt;$1&lt;/code&gt; , &lt;code&gt;$2&lt;/code&gt; 등 으로 들어갑니다 . 일반 변수처럼 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c2b66b10db32d7f5b9d549c39f4a96523e13167f" translate="yes" xml:space="preserve">
          <source>The grouping metacharacters &lt;code&gt;()&lt;/code&gt; also allow the extraction of the parts of a string that matched. For each grouping, the part that matched inside goes into the special variables &lt;code&gt;$1&lt;/code&gt;, &lt;code&gt;$2&lt;/code&gt;, etc. They can be used just as ordinary variables:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7778e0ad49a7501b63144277c49609f424265cc5" translate="yes" xml:space="preserve">
          <source>The grouping metacharacters &lt;code&gt;()&lt;/code&gt; also serve another completely different function: they allow the extraction of the parts of a string that matched. This is very useful to find out what matched and for text processing in general. For each grouping, the part that matched inside goes into the special variables &lt;code&gt;$1&lt;/code&gt; , &lt;code&gt;$2&lt;/code&gt; , etc. They can be used just as ordinary variables:</source>
          <target state="translated">그룹화 메타 문자 &lt;code&gt;()&lt;/code&gt; 는 완전히 다른 기능을 제공합니다. 일치하는 문자열 부분을 추출 할 수 있습니다. 이것은 텍스트 처리와 일치하는 항목을 찾는 데 매우 유용합니다. 각 그룹화에서 내부와 일치하는 부분은 특수 변수 &lt;code&gt;$1&lt;/code&gt; , &lt;code&gt;$2&lt;/code&gt; 등 으로 들어갑니다 . 일반 변수처럼 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f7d8e07f21ecf7c9b89414eb2748089fabb93562" translate="yes" xml:space="preserve">
          <source>The grouping metacharacters &lt;code&gt;()&lt;/code&gt; also serve another completely different function: they allow the extraction of the parts of a string that matched. This is very useful to find out what matched and for text processing in general. For each grouping, the part that matched inside goes into the special variables &lt;code&gt;$1&lt;/code&gt;, &lt;code&gt;$2&lt;/code&gt;,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1eece9645dd47cfb0899002c6d7925c002a7646e" translate="yes" xml:space="preserve">
          <source>The guts of &lt;a href=&quot;../perldoc&quot;&gt;perldoc&lt;/a&gt; utility.</source>
          <target state="translated">&lt;a href=&quot;../perldoc&quot;&gt;perldoc&lt;/a&gt; 유틸리티 의 내장</target>
        </trans-unit>
        <trans-unit id="4573f027ad2a701c6d9118677a3e8b776808d62d" translate="yes" xml:space="preserve">
          <source>The guts of &lt;a href=&quot;perldoc&quot;&gt;perldoc&lt;/a&gt; utility.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f1a967bf7f342dcba1f488528612191eac5ba1e" translate="yes" xml:space="preserve">
          <source>The gzip support in &lt;code&gt;Compress::Zlib&lt;/code&gt; version 1.x can only work with a real filesystem filehandle. The filehandles used by Apache modules are not associated with the filesystem.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a2c643a66e3a499a113b39d3630e9b4f6beb5ae" translate="yes" xml:space="preserve">
          <source>The handle identifies a directory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31680a03b79cf90dad61ef90684e16f85b576d96" translate="yes" xml:space="preserve">
          <source>The handler names are based on the underlying type of the variable being declared or of the reference passed. Because these attributes are associated with subroutine or variable declarations, this deliberately ignores any possibility of being blessed into some package. Thus, a subroutine declaration uses &quot;CODE&quot; as its</source>
          <target state="translated">핸들러 이름은 선언 된 변수의 기본 유형 또는 전달 된 참조를 기반으로합니다. 이러한 속성은 서브 루틴 또는 변수 선언과 연관되어 있기 때문에 일부 패키지에 축복이있을 가능성을 의도적으로 무시합니다. 따라서 서브 루틴 선언은 &quot;CODE&quot;를</target>
        </trans-unit>
        <trans-unit id="a4c1e3467d4145540134804fd2549f602b627fdd" translate="yes" xml:space="preserve">
          <source>The handler used for subsequently installed signals calls &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; (actually &lt;code&gt;croak&lt;/code&gt; ) with a message indicating which signal was caught.</source>
          <target state="translated">이후에 설치된 신호에 사용 된 핸들러 는 어떤 신호가 포착되었는지를 나타내는 메시지와 함께 &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; (실제로 &lt;code&gt;croak&lt;/code&gt; )를 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="00d58947b3aad48761af600208c9e3fd41356ea5" translate="yes" xml:space="preserve">
          <source>The handler used for subsequently installed signals calls &lt;code&gt;die&lt;/code&gt; (actually &lt;code&gt;croak&lt;/code&gt;) with a message indicating which signal was caught.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f12af1084926ed2ac194950a97f332b400e2448" translate="yes" xml:space="preserve">
          <source>The handler used for subsequently installed signals outputs a Perl stack trace to STDERR and then tries to dump core. This is the default signal handler.</source>
          <target state="translated">이후에 설치된 신호에 사용 된 핸들러는 Perl 스택 추적을 STDERR에 출력 한 다음 코어 덤프를 시도합니다. 이것이 기본 신호 처리기입니다.</target>
        </trans-unit>
        <trans-unit id="d5126c9fee7d8a5338a4248383236dc9ecb51986" translate="yes" xml:space="preserve">
          <source>The handling of A &amp;amp; P in MBI/MBF (the old core code shipped with Perl versions &amp;lt;= 5.7.2) is like this:</source>
          <target state="translated">MBI / MBF (Perl 버전 &amp;lt;= 5.7.2와 함께 제공되는 이전 코어 코드)에서 A &amp;amp; P를 처리하는 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="fc9357967428b2793ab9d519118dce3147a43e76" translate="yes" xml:space="preserve">
          <source>The handling of errors by the layer is not specified. e.g. when $! should be set explicitly, when the error handling should be just delegated to the top layer.</source>
          <target state="translated">계층 별 오류 처리가 지정되지 않았습니다. 예를 들어 $! 오류 처리를 최상위 계층에 위임해야하는 경우 명시 적으로 설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="3b8d0bb90f4b079a36f72ce61ffbf0db337af8a2" translate="yes" xml:space="preserve">
          <source>The handling of hyphens and em dashes is somewhat fragile, and one may get the wrong one under some circumstances. This should only matter for &lt;b&gt;troff&lt;/b&gt; output.</source>
          <target state="translated">하이픈과 엠 대시를 처리하는 것은 다소 취약하며 일부 상황에서는 잘못된 것을 얻을 수 있습니다. 이것은 &lt;b&gt;troff&lt;/b&gt; 출력 에만 중요합니다 .</target>
        </trans-unit>
        <trans-unit id="de0cf92f651484ad4efbe5f702009188bf5e94e3" translate="yes" xml:space="preserve">
          <source>The hash &lt;code&gt;%ENV&lt;/code&gt; contains your current environment. Setting a value in &lt;code&gt;ENV&lt;/code&gt; changes the environment for any child processes you subsequently &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork()&lt;/a&gt;&lt;/code&gt; off.</source>
          <target state="translated">해시 &lt;code&gt;%ENV&lt;/code&gt; 에는 현재 환경이 포함되어 있습니다. &lt;code&gt;ENV&lt;/code&gt; 에 값을 설정 하면 이후에 &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork()&lt;/a&gt;&lt;/code&gt; 해제 하는 모든 하위 프로세스의 환경이 변경 됩니다.</target>
        </trans-unit>
        <trans-unit id="195033ec6c0348a9a8c6b6c6ac70c90873828bda" translate="yes" xml:space="preserve">
          <source>The hash &lt;code&gt;%ENV&lt;/code&gt; contains your current environment. Setting a value in &lt;code&gt;ENV&lt;/code&gt; changes the environment for any child processes you subsequently &lt;code&gt;fork()&lt;/code&gt; off.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3342ea08441abded27300d3bc9cbf7a4f36851e5" translate="yes" xml:space="preserve">
          <source>The hash &lt;code&gt;%INC&lt;/code&gt; contains entries for each filename included via the &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; operators. The key is the filename you specified (with module names converted to pathnames), and the value is the location of the file found. The &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; operator uses this hash to determine whether a particular file has already been included.</source>
          <target state="translated">해시 &lt;code&gt;%INC&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 를 통해 포함 된 각 파일 이름에 대한 항목을 포함합니다 연산자 . 키는 지정한 파일 이름 (모듈 이름이 경로 이름으로 변환 됨)이며 값은 찾은 파일의 위치입니다. 이 &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; 운영자가 특정 파일이 이미 포함되었는지 여부를 확인하기 위해 해시를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="266d3cf7610b8376c6c9862a0efb7aafe1dd7d00" translate="yes" xml:space="preserve">
          <source>The hash &lt;code&gt;%INC&lt;/code&gt; contains entries for each filename included via the &lt;code&gt;do&lt;/code&gt;, &lt;code&gt;require&lt;/code&gt;, or &lt;code&gt;use&lt;/code&gt; operators. The key is the filename you specified (with module names converted to pathnames), and the value is the location of the file found. The &lt;code&gt;require&lt;/code&gt; operator uses this hash to determine whether a particular file has already been included.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae0c946c442c59fafdf0cc03f5925a7d6a67576e" translate="yes" xml:space="preserve">
          <source>The hash &lt;code&gt;%SIG&lt;/code&gt; contains signal handlers for signals. For example:</source>
          <target state="translated">해시 &lt;code&gt;%SIG&lt;/code&gt; 에는 신호에 대한 신호 처리기가 포함되어 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2b378e4f482e4b01f36a8f2a09efa90c92e18352" translate="yes" xml:space="preserve">
          <source>The hash algorithm is defined in the &lt;code&gt;PERL_HASH&lt;/code&gt; macro:</source>
          <target state="translated">해시 알고리즘은 &lt;code&gt;PERL_HASH&lt;/code&gt; 매크로에 .</target>
        </trans-unit>
        <trans-unit id="9dd8951a5e30b83106f470f819a5f4eb8b3cc146" translate="yes" xml:space="preserve">
          <source>The hash contains a &quot;version&quot; key</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eea3de2cc53cbdd71b8b1d8903e357859f8beec1" translate="yes" xml:space="preserve">
          <source>The hash described above is returned for locale-independent casing, where at least one of the mappings has length longer than one. If &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; is returned, the code point may have mappings, but if so, all are length one, and are returned by &lt;a href=&quot;#charinfo()&quot;&gt;charinfo()&lt;/a&gt;. Note that when this function does return a value, it will be for the complete set of mappings for a code point, even those whose length is one.</source>
          <target state="translated">위에서 설명한 해시는 로케일 독립적 인 케이스에 대해 리턴되며, 여기서 맵핑 중 하나 이상이 길이보다 깁니다. &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 인 경우 반환되는 코드 포인트는 매핑을 가질 수 있지만, 그래서 모든 길이 하나, 그리고에 의해 반환되는 경우 &lt;a href=&quot;#charinfo()&quot;&gt;charinfo ()&lt;/a&gt; . 이 함수가 값을 반환하면 길이가 1 인 코드 포인트에 대한 전체 매핑 집합에 대한 것입니다.</target>
        </trans-unit>
        <trans-unit id="711d74daff085b3047aba5916127a254ddfd4772" translate="yes" xml:space="preserve">
          <source>The hash described above is returned for locale-independent casing, where at least one of the mappings has length longer than one. If &lt;code&gt;undef&lt;/code&gt; is returned, the code point may have mappings, but if so, all are length one, and are returned by &lt;a href=&quot;#charinfo%28%29&quot;&gt;&quot;charinfo()&quot;&lt;/a&gt;. Note that when this function does return a value, it will be for the complete set of mappings for a code point, even those whose length is one.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c18c1acf75672457070b2eb9996c5075b3edce2" translate="yes" xml:space="preserve">
          <source>The hash does not support exists().</source>
          <target state="translated">해시는 exist ()를 지원하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8ead17751b61a27f00737722511d4f0a6b122f2d" translate="yes" xml:space="preserve">
          <source>The hash has the same structure as the one returned by Storable::file_magic(). The &lt;code&gt;file&lt;/code&gt; element is true if the image is a file image.</source>
          <target state="translated">해시는 Storable :: file_magic ()에 의해 반환 된 것과 같은 구조를 가지고 있습니다. &lt;code&gt;file&lt;/code&gt; 이미지 파일 이미지의 경우 요소는 사실이다.</target>
        </trans-unit>
        <trans-unit id="5130b4f9ca4de414c6b75c63b4b5de1f1cac05d9" translate="yes" xml:space="preserve">
          <source>The hash reference returned by the new() function can be used to examine and modify the contents of the .packlist. Items may be added/deleted from the .packlist by modifying the hash. If the value associated with a hash key is a scalar, the entry written to the .packlist by any subsequent write() will be a simple filename. If the value is a hash, the entry written will be the filename followed by the key=value pairs from the hash. Reading back the .packlist will recreate the original entries.</source>
          <target state="translated">new () 함수가 반환 한 해시 참조를 사용하여 .packlist의 내용을 검사하고 수정할 수 있습니다. 해시를 수정하여 .packlist에서 항목을 추가 / 삭제할 수 있습니다. 해시 키와 연관된 값이 스칼라이면 후속 write ()에 의해 .packlist에 기록 된 항목은 간단한 파일 이름이됩니다. 값이 해시 인 경우 파일 이름 뒤에 해시의 key = value 쌍이 기록됩니다. .packlist를 다시 읽으면 원래 항목이 다시 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="7516ee71ac16390106261a6b0bbe1da56c817eef" translate="yes" xml:space="preserve">
          <source>The hash returned has the following elements:</source>
          <target state="translated">반환 된 해시는 다음과 같은 요소를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="5e040a1ccea7ca71c3bad7dc1e4a1dfbebdc6ad0" translate="yes" xml:space="preserve">
          <source>The hash structure</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43a906eb4ff4eda3db678faefd07c14f14845797" translate="yes" xml:space="preserve">
          <source>The hash variable you want to tie.</source>
          <target state="translated">묶고 싶은 해시 변수.</target>
        </trans-unit>
        <trans-unit id="1e40f9760b2e7d5577d2825dfdedf13a7e442c00" translate="yes" xml:space="preserve">
          <source>The head of the chain of deleted ops is returned, or &lt;code&gt;NULL&lt;/code&gt; if no ops were deleted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ab4ffe148d6038400649049035912b11305e989" translate="yes" xml:space="preserve">
          <source>The head of the chain of deleted ops is returned, or NULL if no ops were deleted.</source>
          <target state="translated">삭제 된 작업 체인의 헤드가 반환되거나 작업이 삭제되지 않은 경우 NULL이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="fb8198ac36c0383db875a5b5488218cc0db38e42" translate="yes" xml:space="preserve">
          <source>The head of the stack is &lt;code&gt;PL_markstack_ptr&lt;/code&gt;, and points to the most recently-pushed item.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="387a371cfd5487134922ec368d5a02aa122c9278" translate="yes" xml:space="preserve">
          <source>The head of the stack is &lt;code&gt;PL_stack_sp&lt;/code&gt;, and points to the most recently-pushed item.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa9e497fb69d1c1631afd8e4e7265382a3e02b69" translate="yes" xml:space="preserve">
          <source>The head of the stack is indexed by &lt;code&gt;PL_savestack_ix&lt;/code&gt;, an integer which stores the index in the array at which the next item should be pushed. (Note that this is different to most other stacks, which reference the most recently-pushed item).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eaff0f01d94e655d09c1c9c0abff908c801c87d2" translate="yes" xml:space="preserve">
          <source>The head of the stack is indexed by &lt;code&gt;PL_scopestack_ix&lt;/code&gt;, an integer which stores the index of the array or arrays at which the next item should be pushed. (Note that this is different to most other stacks, which reference the most recently-pushed item).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf516ef8c50debb6627d05e33ce24dc47fb581a2" translate="yes" xml:space="preserve">
          <source>The head of the stack is indexed by &lt;code&gt;PL_tmps_ix&lt;/code&gt;, an integer which stores the index in the array of the most recently-pushed item.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c336f0d4ef1d936490e8c7b4819c090f6400cf2" translate="yes" xml:space="preserve">
          <source>The header file written by this module, typically</source>
          <target state="translated">이 모듈에 의해 작성된 헤더 파일</target>
        </trans-unit>
        <trans-unit id="4c85c6655d7d1206831fdc527a34ff595586e985" translate="yes" xml:space="preserve">
          <source>The header section continues until a line containing the word CHARMAP. This section has a form of</source>
          <target state="translated">헤더 섹션은 단어 CHARMAP를 포함하는 행까지 계속됩니다. 이 섹션은</target>
        </trans-unit>
        <trans-unit id="a528e0d6eaf7b88f88a4f152246f56b029cd4490" translate="yes" xml:space="preserve">
          <source>The heart of Storable is written in C for decent speed. Extra low-level optimizations have been made when manipulating perl internals, to sacrifice encapsulation for the benefit of greater speed.</source>
          <target state="translated">Storable의 핵심은 적절한 속도로 C로 작성되었습니다. 더 빠른 속도를 위해 캡슐화를 희생하기 위해 perl 내부를 조작 할 때 추가적인 저수준 최적화가 이루어졌습니다.</target>
        </trans-unit>
        <trans-unit id="a8fcb5ed9aadb57481c4a4c9eabfd488f403dcd6" translate="yes" xml:space="preserve">
          <source>The here-doc modifier &lt;code&gt;~&lt;/code&gt; allows you to indent your here-docs to make the code more readable:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6afbf6cabde867bd59953ce46fc882087b1bd27" translate="yes" xml:space="preserve">
          <source>The hex number may optionally be prefixed with &quot;0x&quot; or &quot;x&quot; unless &lt;code&gt;PERL_SCAN_DISALLOW_PREFIX&lt;/code&gt; is set in</source>
          <target state="translated">&lt;code&gt;PERL_SCAN_DISALLOW_PREFIX&lt;/code&gt; 가 아니라면 16 진수에 &quot;0x&quot;또는 &quot;x&quot;를 접두사로 지정할 수 있습니다. 가 설정되어 .</target>
        </trans-unit>
        <trans-unit id="13723a6864537beca2cddb32c984b567fe87e40b" translate="yes" xml:space="preserve">
          <source>The hex number may optionally be prefixed with &lt;code&gt;&quot;0x&quot;&lt;/code&gt; or &lt;code&gt;&quot;x&quot;&lt;/code&gt; unless &lt;code&gt;PERL_SCAN_DISALLOW_PREFIX&lt;/code&gt; is set in &lt;code&gt;*flags&lt;/code&gt; on entry.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e84dec921d35d3ee6755f09b85656ef3201e9eb" translate="yes" xml:space="preserve">
          <source>The high-order 4 bytes of the total number of cylinders.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70cee26392a760c84fafaebf12b0f84ec8e67796" translate="yes" xml:space="preserve">
          <source>The higher-level loops preserve an additional state between iterations: whether the last match was zero-length. To break the loop, the following match after a zero-length match is prohibited to have a length of zero. This prohibition interacts with backtracking (see &lt;a href=&quot;#Backtracking&quot;&gt;&quot;Backtracking&quot;&lt;/a&gt;), and so the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e478860a296847f9fc713c230a9fb9343e5f150e" translate="yes" xml:space="preserve">
          <source>The higher-level loops preserve an additional state between iterations: whether the last match was zero-length. To break the loop, the following match after a zero-length match is prohibited to have a length of zero. This prohibition interacts with backtracking (see &lt;a href=&quot;#Backtracking&quot;&gt;Backtracking&lt;/a&gt;), and so the</source>
          <target state="translated">상위 레벨 루프는 반복 사이에 추가 상태 (마지막 일치가 길이가 0인지 여부)를 유지합니다. 루프를 끊기 위해 길이가 0 인 일치 후 다음 일치는 길이가 0이되도록 금지됩니다. 되돌아와이 금지 상호 작용은 (참조 &lt;a href=&quot;#Backtracking&quot;&gt;역행을&lt;/a&gt; 하고 있으므로)</target>
        </trans-unit>
        <trans-unit id="5d5a041b27e5325dac6f1b79cae3bff7a7552bef" translate="yes" xml:space="preserve">
          <source>The highest priority is to look in the current directory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59406d517ca12a7bf5809c9dbfccd1e683e04f9f" translate="yes" xml:space="preserve">
          <source>The hinting interface allows</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a2214ecae9d593eb49cab164240c89849da3aae" translate="yes" xml:space="preserve">
          <source>The hintsfile is eval()ed immediately after the arguments given to WriteMakefile are stuffed into a hash reference $self but before this reference becomes blessed. So if you want to do the equivalent to override or create an attribute you would say something like</source>
          <target state="translated">힌트 파일은 WriteMakefile에 주어진 인수가 해시 참조 $ self에 채워지지만이 참조가 축복되기 전에 eval ()됩니다. 따라서 속성을 재정의하거나 만들 때 동등한 작업을 수행하려면 다음과 같이 말하십시오.</target>
        </trans-unit>
        <trans-unit id="c6b34cade6e81d89b062f256b78cf0c9f72eec68" translate="yes" xml:space="preserve">
          <source>The hook used by perl's &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; operator. &lt;b&gt;ptype&lt;/b&gt; is perl's character for the kind of IO:</source>
          <target state="translated">Perl의 &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; 연산자가 사용하는 후크 . &lt;b&gt;ptype&lt;/b&gt; 은 IO의 종류에 대한 perl의 문자입니다.</target>
        </trans-unit>
        <trans-unit id="1add1ef58ecb7c35c4f838c64caf5db36bdf795e" translate="yes" xml:space="preserve">
          <source>The hook used by perl's &lt;code&gt;binmode&lt;/code&gt; operator. &lt;b&gt;ptype&lt;/b&gt; is perl's character for the kind of IO:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f349975f67add93f8850a9eaf9c6c17fd6d7655e" translate="yes" xml:space="preserve">
          <source>The host name supplied to getaddrinfo() did not provide any usable address data.</source>
          <target state="translated">getaddrinfo ()에 제공된 호스트 이름에 사용 가능한 주소 데이터가 없습니다.</target>
        </trans-unit>
        <trans-unit id="26f0f0653cc389e36c588050d688c99bccaa9d07" translate="yes" xml:space="preserve">
          <source>The host name supplied to getaddrinfo() does not exist, or the address supplied to getnameinfo() is not associated with a host name and the &lt;code&gt;NI_NAMEREQD&lt;/code&gt; flag was supplied.</source>
          <target state="translated">getaddrinfo ()에 제공된 호스트 이름이 없거나 getnameinfo ()에 제공된 주소가 호스트 이름과 연관되어 있지 않으며 &lt;code&gt;NI_NAMEREQD&lt;/code&gt; 플래그가 제공되었습니다.</target>
        </trans-unit>
        <trans-unit id="a5eeccb55ae3d60bff3752f2dd5a946e36daa986" translate="yes" xml:space="preserve">
          <source>The hostname in the uri. Will be empty if host was originally 'localhost' for a 'file://' url.</source>
          <target state="translated">URI의 호스트 이름입니다. 호스트가 원래 'file : //'URL에 대해 'localhost'인 경우 비어 있습니다.</target>
        </trans-unit>
        <trans-unit id="c156a44c9f3418b797d3bba0a0c3707b47fb0ac1" translate="yes" xml:space="preserve">
          <source>The hub class or subclass</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="77b8df6ac6b4142b5235e5c136ec2dc940fbfdbc" translate="yes" xml:space="preserve">
          <source>The hub is the place where all events get processed and handed off to the formatter. The hub also tracks test state, and provides several hooks into the event pipeline.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2bcd00b585852692b974ea751e079b51540b5b54" translate="yes" xml:space="preserve">
          <source>The hyperbolic sine, cosine, and tangent</source>
          <target state="translated">쌍곡 사인, 코사인 및 탄젠트</target>
        </trans-unit>
        <trans-unit id="ff901843574864f25cda07a5ab8922dd36a5d5b7" translate="yes" xml:space="preserve">
          <source>The icmp and icmpv6 protocols requires that the program be run as root or that it be setuid to root. The other protocols do not require special privileges, but not all network devices implement tcp or udp echo.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a67744a35db2bbac17aada3b55cebfdff3c8d58f" translate="yes" xml:space="preserve">
          <source>The icmp protocol requires that the program be run as root or that it be setuid to root. The other protocols do not require special privileges, but not all network devices implement tcp or udp echo.</source>
          <target state="translated">icmp 프로토콜을 사용하려면 프로그램을 루트로 실행하거나 루트로 설정해야합니다. 다른 프로토콜에는 특별한 권한이 필요하지 않지만 모든 네트워크 장치가 tcp 또는 udp echo를 구현하는 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="0eb904ac9079537474ee2cc5638a1c5ecde2814c" translate="yes" xml:space="preserve">
          <source>The id must start with a letter (a-z or A-Z)</source>
          <target state="translated">ID는 문자 (az 또는 AZ)로 시작해야합니다.</target>
        </trans-unit>
        <trans-unit id="28d56a775fecdcfc9d3c448ae0628addf0163100" translate="yes" xml:space="preserve">
          <source>The ideal (but a bit ugly) way to never have to think about that is to use &lt;code&gt;BEGIN&lt;/code&gt; blocks. So the first part of the &lt;a href=&quot;#SYNOPSIS&quot;&gt;&quot;SYNOPSIS&quot;&lt;/a&gt; code could be rewritten as:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="28df5f4390b3a084c824acbbd266525edf8be51a" translate="yes" xml:space="preserve">
          <source>The ideal (but a bit ugly) way to never have to think about that is to use &lt;code&gt;BEGIN&lt;/code&gt; blocks. So the first part of the &lt;a href=&quot;#SYNOPSIS&quot;&gt;SYNOPSIS&lt;/a&gt; code could be rewritten as:</source>
          <target state="translated">그것에 대해 생각할 필요가없는 이상적인 (그러나 조금 추한) 방법은 &lt;code&gt;BEGIN&lt;/code&gt; 블록 을 사용하는 것입니다 . 따라서 &lt;a href=&quot;#SYNOPSIS&quot;&gt;SYNOPSIS&lt;/a&gt; 코드 의 첫 부분은 다음 과 같이 다시 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3e76ae6d87db97d0c1319c6311b06f1b4140b992" translate="yes" xml:space="preserve">
          <source>The immediate, in addition to the current stable release, the previous stable release is maintained. See &lt;a href=&quot;perlpolicy#MAINTENANCE-AND-SUPPORT&quot;&gt;&quot;MAINTENANCE AND SUPPORT&quot; in perlpolicy&lt;/a&gt; for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4b5bd1f2c1aa12d8d86dc87b94e48313e6fd68a" translate="yes" xml:space="preserve">
          <source>The immediate, previous releases (i.e. perl5.14.x ) are usually maintained for a while, although not at the same level as the current releases.</source>
          <target state="translated">즉각적인 이전 릴리스 (즉, perl5.14.x)는 일반적으로 현재 릴리스와 동일한 레벨이 아니지만 한동안 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="805f5e34bdac09e91b618eb56a2ba5ac7b88cd61" translate="yes" xml:space="preserve">
          <source>The implementation of &lt;code&gt;:raw&lt;/code&gt; is as a pseudo-layer which when &quot;pushed&quot; pops itself and then any layers which do not declare themselves as suitable for binary data. (Undoing :utf8 and :crlf are implemented by clearing flags rather than popping layers but that is an implementation detail.)</source>
          <target state="translated">&lt;code&gt;:raw&lt;/code&gt; 의 구현은 &quot;푸시 (pushed)&quot;될 때 자체적으로 이진 데이터에 적합하다고 선언하지 않는 모든 계층 인 의사 계층입니다. (Unuting : utf8 및 : crlf는 레이어를 팝하는 대신 플래그를 지우는 방식으로 구현되지만 구현 세부 사항입니다.)</target>
        </trans-unit>
        <trans-unit id="74166820cac25a2e66888d5644d8d2715e58984a" translate="yes" xml:space="preserve">
          <source>The implementation of &lt;code&gt;:raw&lt;/code&gt; is as a pseudo-layer which when &quot;pushed&quot; pops itself and then any layers which would modify the binary data stream. (Undoing &lt;code&gt;:utf8&lt;/code&gt; and &lt;code&gt;:crlf&lt;/code&gt; may be implemented by clearing flags rather than popping layers but that is an implementation detail.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1868b2d1d8d2925ab9482699d09a63b0f1af9f3c" translate="yes" xml:space="preserve">
          <source>The implementation of individual components of the system is likely to change over time.</source>
          <target state="translated">시스템의 개별 구성 요소 구현은 시간이 지남에 따라 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6075b5ee16206eda7e75f744a66591ab7ff6ad34" translate="yes" xml:space="preserve">
          <source>The implementation of the C3 MRO and switchable MROs within the perl core was written by Brandon L Black. Nicholas Clark created the pluggable interface, refactored Brandon's implementation to work with it, and wrote this document.</source>
          <target state="translated">Perl 코어 내에서 C3 MRO 및 전환 가능한 MRO의 구현은 Brandon L Black에 의해 작성되었습니다. Nicholas Clark은 플러그 형 인터페이스를 만들고 Brandon의 구현을 리팩토링하여이 문서를 작성했습니다.</target>
        </trans-unit>
        <trans-unit id="0af6409c892c8fe954ef686ac149074100758771" translate="yes" xml:space="preserve">
          <source>The implementation that surfaces this limitation will not be changed. See the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f92ca5378313f5f6ef2629dcf71bf80c645c279f" translate="yes" xml:space="preserve">
          <source>The implication of the above description is that a pattern containing nested parentheses will result in a call graph which cycles through &lt;code&gt;reg()&lt;/code&gt; , &lt;code&gt;regbranch()&lt;/code&gt; , &lt;code&gt;regpiece()&lt;/code&gt; , &lt;code&gt;regatom()&lt;/code&gt; , &lt;code&gt;reg()&lt;/code&gt; , &lt;code&gt;regbranch()&lt;/code&gt;</source>
          <target state="translated">위의 설명의 의미는 중첩 괄호를 포함하는 패턴이 &lt;code&gt;reg()&lt;/code&gt; , &lt;code&gt;regbranch()&lt;/code&gt; , &lt;code&gt;regpiece()&lt;/code&gt; , &lt;code&gt;regatom()&lt;/code&gt; , &lt;code&gt;reg()&lt;/code&gt; , &lt;code&gt;regbranch()&lt;/code&gt; 를 순환하는 호출 그래프를 생성한다는 것입니다</target>
        </trans-unit>
        <trans-unit id="a5213d8ec5be4ed3cc0fcaff5c663e1f7ec79164" translate="yes" xml:space="preserve">
          <source>The implication of the above description is that a pattern containing nested parentheses will result in a call graph which cycles through &lt;code&gt;reg()&lt;/code&gt;, &lt;code&gt;regbranch()&lt;/code&gt;, &lt;code&gt;regpiece()&lt;/code&gt;, &lt;code&gt;regatom()&lt;/code&gt;, &lt;code&gt;reg()&lt;/code&gt;, &lt;code&gt;regbranch()&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61ca45a7499fa655d95fb3a1c14575987ee3c0c2" translate="yes" xml:space="preserve">
          <source>The implicit iterator variable in the &lt;code&gt;&lt;a href=&quot;functions/grep&quot;&gt;grep()&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/map&quot;&gt;map()&lt;/a&gt;&lt;/code&gt; functions.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/grep&quot;&gt;grep()&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;functions/map&quot;&gt;map()&lt;/a&gt;&lt;/code&gt; 함수 의 암시 적 반복자 변수</target>
        </trans-unit>
        <trans-unit id="d0c861ae3d9b69a61149562b6cbed085fb5fa583" translate="yes" xml:space="preserve">
          <source>The implicit iterator variable in the &lt;code&gt;grep()&lt;/code&gt; and &lt;code&gt;map()&lt;/code&gt; functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49df36702f6a3c6192de102a29688dbe9fd4061b" translate="yes" xml:space="preserve">
          <source>The implicit variable of &lt;code&gt;given()&lt;/code&gt; .</source>
          <target state="translated">암시 적 변수 &lt;code&gt;given()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d7bb5561c43ecc998d31a66fa1460eabbf5c497c" translate="yes" xml:space="preserve">
          <source>The implicit variable of &lt;code&gt;given()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04c82ff9343f818ba122f89e2a74fb9d1d0fecda" translate="yes" xml:space="preserve">
          <source>The importance of these tests is proportional to the alleged stability of a module. A module which purports to be stable or which hopes to achieve wide use should adhere to as strict a testing regime as possible.</source>
          <target state="translated">이 테스트의 중요성은 모듈의 안정성에 비례합니다. 안정적으로 사용되거나 광범위하게 사용되기를 희망하는 모듈은 가능한 한 엄격한 테스트 체제를 준수해야합니다.</target>
        </trans-unit>
        <trans-unit id="09af00710c80d3dd70ebd96fd4367e42313c5d25" translate="yes" xml:space="preserve">
          <source>The importance of writing good test scripts cannot be over-emphasized. You should closely follow the &quot;ok/not ok&quot; style that Perl itself uses, so that it is very easy and unambiguous to determine the outcome of each test case. When you find and fix a bug, make sure you add a test case for it.</source>
          <target state="translated">좋은 테스트 스크립트 작성의 중요성은 아무리 강조해도 지나치지 않습니다. Perl 자체가 사용하는 &quot;ok / not ok&quot;스타일을 밀접하게 따라야하므로 각 테스트 사례의 결과를 매우 쉽고 명확하게 파악할 수 있습니다. 버그를 찾아 수정하면 테스트 케이스를 추가해야합니다.</target>
        </trans-unit>
        <trans-unit id="a4561daf93366d570e71e9394fec54f9d31846e6" translate="yes" xml:space="preserve">
          <source>The important and distinguishing feature of run_forked is execution timeout which at first seems to be quite a simple task but if you think that the program which you're spawning might spawn some children itself (which in their turn could do the same and so on) it turns out to be not a simple issue.</source>
          <target state="translated">run_forked의 중요하고 구별되는 기능은 처음에는 꽤 간단한 작업 인 것처럼 보이는 실행 시간 초과입니다. 그러나 생성하는 프로그램이 일부 자식 자체를 생성 할 수 있다고 생각하면 (그러면 차례로 동일하게 할 수 있음) 그것은 단순한 문제가 아닌 것으로 밝혀졌습니다.</target>
        </trans-unit>
        <trans-unit id="4973662d6822686f7aa087396e5cfac037bf9b09" translate="yes" xml:space="preserve">
          <source>The important parts of that are the second argument (the increment) to HEAP, and allowing the stack to be &quot;Above the (16M) line&quot;. If the heap increment is too small then when perl (for example loading unicode/Name.pl) tries to create a &quot;big&quot; (400K+) string it cannot fit in a single segment and you get &quot;Out of Memory!&quot; - even if there is still plenty of memory available.</source>
          <target state="translated">이것의 중요한 부분은 HEAP에 대한 두 번째 인수 (증분)이며 스택이 &quot;(16M) 라인 이상&quot;이되도록합니다. 힙 증분이 너무 작 으면 perl (예 : unicode / Name.pl로드)이 &quot;큰&quot;(400K +) 문자열을 만들려고 할 때 단일 세그먼트에 맞지 않고 &quot;메모리 부족!&quot; -여전히 사용 가능한 메모리가 충분하더라도.</target>
        </trans-unit>
        <trans-unit id="3f69c866bd6b570c0ad67a5d6dcc4f47abb90206" translate="yes" xml:space="preserve">
          <source>The included contents will be inserted into the MANIFEST.SKIP file in between</source>
          <target state="translated">포함 된 내용은 MANIFEST.SKIP 파일 사이에 삽입됩니다.</target>
        </trans-unit>
        <trans-unit id="321a9d8c0c3e343e922f69286afb469449a8323c" translate="yes" xml:space="preserve">
          <source>The independent subexpression &lt;code&gt;(?&amp;gt;a*)&lt;/code&gt; doesn't care about the rest of the regexp, so it sees an &lt;code&gt;'a'&lt;/code&gt; and grabs it. Then the rest of the regexp &lt;code&gt;ab&lt;/code&gt; cannot match. Because &lt;code&gt;(?&amp;gt;a*)&lt;/code&gt; is independent, there is no backtracking and the independent subexpression does not give up its &lt;code&gt;'a'&lt;/code&gt;. Thus the match of the regexp as a whole fails. A similar behavior occurs with completely independent regexps:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="02e5563a36b89e14fcbd689f1595a21037cddaee" translate="yes" xml:space="preserve">
          <source>The independent subexpression &lt;code&gt;(?&amp;gt;a*)&lt;/code&gt; doesn't care about the rest of the regexp, so it sees an &lt;code&gt;a&lt;/code&gt; and grabs it. Then the rest of the regexp &lt;code&gt;ab&lt;/code&gt; cannot match. Because &lt;code&gt;(?&amp;gt;a*)&lt;/code&gt; is independent, there is no backtracking and the independent subexpression does not give up its &lt;code&gt;a&lt;/code&gt; . Thus the match of the regexp as a whole fails. A similar behavior occurs with completely independent regexps:</source>
          <target state="translated">독립 하위 표현식 &lt;code&gt;(?&amp;gt;a*)&lt;/code&gt; 은 나머지 정규 표현식에 신경 쓰지 않으므로 &lt;code&gt;a&lt;/code&gt; 를 보고 가져 옵니다. 그런 다음 나머지 정규 표현식 &lt;code&gt;ab&lt;/code&gt; 는 일치 할 수 없습니다. 때문에 &lt;code&gt;(?&amp;gt;a*)&lt;/code&gt; 독립적 인,이 더 되돌아없고 독립적 인 표현식은 포기하지 않는 &lt;code&gt;a&lt;/code&gt; . 따라서 정규 표현식의 전체 일치가 실패합니다. 완전히 독립적 인 정규 표현식에서도 비슷한 동작이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="d8911df7ecc3a80cd7cb7748b8608afa2215b297" translate="yes" xml:space="preserve">
          <source>The index entry specified contains nothing but whitespace.</source>
          <target state="translated">지정된 색인 항목에는 공백 만 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="8993f68ea89e04e52354fc3b53dacbbf01363016" translate="yes" xml:space="preserve">
          <source>The index function searches for one string within another, but without the wildcard-like behavior of a full regular-expression pattern match. It returns the position of the first occurrence of SUBSTR in STR at or after POSITION. If POSITION is omitted, starts searching from the beginning of the string. POSITION before the beginning of the string or after its end is treated as if it were the beginning or the end, respectively. POSITION and the return value are based at zero. If the substring is not found, &lt;a href=&quot;#index-STR%2CSUBSTR%2CPOSITION&quot;&gt;&lt;code&gt;index&lt;/code&gt;&lt;/a&gt; returns -1.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed2b9d5332f95abb7e28bc54e5124d59c88ac74f" translate="yes" xml:space="preserve">
          <source>The index function searches for one string within another, but without the wildcard-like behavior of a full regular-expression pattern match. It returns the position of the first occurrence of SUBSTR in STR at or after POSITION. If POSITION is omitted, starts searching from the beginning of the string. POSITION before the beginning of the string or after its end is treated as if it were the beginning or the end, respectively. POSITION and the return value are based at zero. If the substring is not found, &lt;code&gt;&lt;a href=&quot;functions/index&quot;&gt;index&lt;/a&gt;&lt;/code&gt; returns -1.</source>
          <target state="translated">인덱스 함수는 다른 문자열 내에서 하나의 문자열을 검색하지만 완전한 정규식 패턴 일치의 와일드 카드와 유사한 동작은 없습니다. POSITION 또는 그 이후에 STR에서 SUBSTR이 처음 나타나는 위치를 리턴합니다. POSITION을 생략하면 문자열의 처음부터 검색을 시작합니다. 문자열의 시작 전 또는 끝의 POSITION은 각각 시작 또는 끝인 것처럼 처리됩니다. POSITION과 반환 값은 0을 기준으로합니다. 부분 문자열이 없으면 &lt;code&gt;&lt;a href=&quot;functions/index&quot;&gt;index&lt;/a&gt;&lt;/code&gt; 는 -1을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="052a5a20374b32a9d318c8e657a3fc6d2c067a62" translate="yes" xml:space="preserve">
          <source>The index function searches for one string within another, but without the wildcard-like behavior of a full regular-expression pattern match. It returns the position of the first occurrence of SUBSTR in STR at or after POSITION. If POSITION is omitted, starts searching from the beginning of the string. POSITION before the beginning of the string or after its end is treated as if it were the beginning or the end, respectively. POSITION and the return value are based at zero. If the substring is not found, &lt;code&gt;&lt;a href=&quot;index&quot;&gt;index&lt;/a&gt;&lt;/code&gt; returns -1.</source>
          <target state="translated">인덱스 함수는 다른 문자열 내에서 하나의 문자열을 검색하지만 완전한 정규식 패턴 일치의 와일드 카드와 유사한 동작은 없습니다. POSITION 또는 그 이후에 STR에서 SUBSTR이 처음 나타나는 위치를 리턴합니다. POSITION을 생략하면 문자열의 처음부터 검색을 시작합니다. 문자열의 시작 전 또는 끝의 POSITION은 각각 시작 또는 끝인 것처럼 처리됩니다. POSITION과 반환 값은 0을 기준으로합니다. 부분 문자열이 없으면 &lt;code&gt;&lt;a href=&quot;index&quot;&gt;index&lt;/a&gt;&lt;/code&gt; 는 -1을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="1deb1e733742d1b9b4e186c9d57759d15dd95d6b" translate="yes" xml:space="preserve">
          <source>The index of the last allocated space in the padlist. Note that the last pad may be in an earlier slot. Any entries following it will be &lt;code&gt;NULL&lt;/code&gt; in that case.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9d12f86f44aac2e21ecbe7b61cc95b95675209f" translate="yes" xml:space="preserve">
          <source>The index of the last allocated space in the padlist. Note that the last pad may be in an earlier slot. Any entries following it will be NULL in that case.</source>
          <target state="translated">padlist에서 마지막으로 할당 된 공간의 색인입니다. 마지막 패드는 이전 슬롯에있을 수 있습니다. 이 경우 뒤에 오는 모든 항목은 NULL이됩니다.</target>
        </trans-unit>
        <trans-unit id="e58a7f8912fdbd8eaa97b22ef4d5d356a40471d5" translate="yes" xml:space="preserve">
          <source>The index of the last pad entry.</source>
          <target state="translated">마지막 패드 항목의 색인입니다.</target>
        </trans-unit>
        <trans-unit id="9c1326f686e664ef67aae2567ac4696fd6d57b00" translate="yes" xml:space="preserve">
          <source>The index of the last pad name.</source>
          <target state="translated">마지막 패드 이름의 색인입니다.</target>
        </trans-unit>
        <trans-unit id="6e35b0206297becebb26c609423d65b1dfe24dd3" translate="yes" xml:space="preserve">
          <source>The indexing merely outputs messages via &lt;code&gt;.tm&lt;/code&gt; for each major page, section, subsection, item, and any &lt;code&gt;X&amp;lt;&amp;gt;&lt;/code&gt; directives. See &lt;a href=&quot;Pod::Man&quot;&gt;Pod::Man&lt;/a&gt; for more details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cda2671ac9e05ad8e30450bd5f169c0ab42ddce2" translate="yes" xml:space="preserve">
          <source>The indexing merely outputs messages via &lt;code&gt;.tm&lt;/code&gt; for each major page, section, subsection, item, and any &lt;code&gt;X&amp;lt;&amp;gt;&lt;/code&gt; directives. See &lt;a href=&quot;pod/man&quot;&gt;Pod::Man&lt;/a&gt; for more details.</source>
          <target state="translated">인덱싱 은 각 주요 페이지, 섹션, 하위 섹션, 항목 및 &lt;code&gt;X&amp;lt;&amp;gt;&lt;/code&gt; 지시문 에 대해 &lt;code&gt;.tm&lt;/code&gt; 을 통해 메시지를 출력하기 만합니다 . 자세한 내용은 &lt;a href=&quot;pod/man&quot;&gt;Pod :: Man&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="c99d2cd33e1325afbec2e3f58c4236d44c82d895" translate="yes" xml:space="preserve">
          <source>The inferred anchor text is implemented per &lt;a href=&quot;../perlpodspec&quot;&gt;perlpodspec&lt;/a&gt;:</source>
          <target state="translated">유추 된 앵커 텍스트는 &lt;a href=&quot;../perlpodspec&quot;&gt;perlpodspec에&lt;/a&gt; 따라 구현됩니다 .</target>
        </trans-unit>
        <trans-unit id="f2d5d2272835d0eeff1fcb72d6fc348f5deff4fa" translate="yes" xml:space="preserve">
          <source>The inferred anchor text is implemented per &lt;a href=&quot;perlpodspec&quot;&gt;perlpodspec&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9dfbacdda04f65b21a64f3fbe8dd597fa30ae2f5" translate="yes" xml:space="preserve">
          <source>The infinity and not-a-number have their own special arithmetic rules. The general rule is that they are &quot;contagious&quot;: &lt;code&gt;Inf&lt;/code&gt; plus one is &lt;code&gt;Inf&lt;/code&gt; , and &lt;code&gt;NaN&lt;/code&gt; plus one is &lt;code&gt;NaN&lt;/code&gt; . Where things get interesting is when you combine infinities and not-a-numbers: &lt;code&gt;Inf&lt;/code&gt; minus &lt;code&gt;Inf&lt;/code&gt; and &lt;code&gt;Inf&lt;/code&gt; divided by &lt;code&gt;INf&lt;/code&gt; are &lt;code&gt;NaN&lt;/code&gt; (while &lt;code&gt;Inf&lt;/code&gt; plus &lt;code&gt;Inf&lt;/code&gt; is &lt;code&gt;Inf&lt;/code&gt; and &lt;code&gt;Inf&lt;/code&gt; times &lt;code&gt;Inf&lt;/code&gt; is &lt;code&gt;Inf&lt;/code&gt; ). &lt;code&gt;NaN&lt;/code&gt; is also curious in that it does not equal any number,</source>
          <target state="translated">무한대와 숫자가 아닌 숫자에는 고유 한 산술 규칙이 있습니다. 일반적인 규칙은 &quot;전염성&quot;이라는 것입니다. &lt;code&gt;Inf&lt;/code&gt; plus one은 &lt;code&gt;Inf&lt;/code&gt; 이고 &lt;code&gt;NaN&lt;/code&gt; plus one은 &lt;code&gt;NaN&lt;/code&gt; 입니다. 당신이 무한하지-A-번호를 결합 할 때 어디에서 일이 흥미로워하는 것은 : &lt;code&gt;Inf&lt;/code&gt; 를 뺀 &lt;code&gt;Inf&lt;/code&gt; 를 하고 &lt;code&gt;Inf&lt;/code&gt; 를 나눈 &lt;code&gt;INf&lt;/code&gt; 하다 &lt;code&gt;NaN&lt;/code&gt; 이을 (동안 &lt;code&gt;Inf&lt;/code&gt; 를 플러스 &lt;code&gt;Inf&lt;/code&gt; 를가 한다 &lt;code&gt;Inf&lt;/code&gt; 를 하고 &lt;code&gt;Inf&lt;/code&gt; 를 배 &lt;code&gt;Inf&lt;/code&gt; 를이 입니다 &lt;code&gt;Inf&lt;/code&gt; 를 ). &lt;code&gt;NaN&lt;/code&gt; 은 또한 숫자와 같지 않다는 점에서 궁금합니다.</target>
        </trans-unit>
        <trans-unit id="b82803e1dc2591f87a6c585b7453fcb7c5b2d49b" translate="yes" xml:space="preserve">
          <source>The infinity and not-a-number have their own special arithmetic rules. The general rule is that they are &quot;contagious&quot;: &lt;code&gt;Inf&lt;/code&gt; plus one is &lt;code&gt;Inf&lt;/code&gt;, and &lt;code&gt;NaN&lt;/code&gt; plus one is &lt;code&gt;NaN&lt;/code&gt;. Where things get interesting is when you combine infinities and not-a-numbers: &lt;code&gt;Inf&lt;/code&gt; minus &lt;code&gt;Inf&lt;/code&gt; and &lt;code&gt;Inf&lt;/code&gt; divided by &lt;code&gt;Inf&lt;/code&gt; are &lt;code&gt;NaN&lt;/code&gt; (while &lt;code&gt;Inf&lt;/code&gt; plus &lt;code&gt;Inf&lt;/code&gt; is &lt;code&gt;Inf&lt;/code&gt; and &lt;code&gt;Inf&lt;/code&gt; times &lt;code&gt;Inf&lt;/code&gt; is &lt;code&gt;Inf&lt;/code&gt;). &lt;code&gt;NaN&lt;/code&gt; is also curious in that it does not equal any number,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc7be9da06f66cb02df4f43ae1ea9430b4a4ec21" translate="yes" xml:space="preserve">
          <source>The infinity as a constant:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47e5e47a18eb5768545b57a7c2da190e8c801676" translate="yes" xml:space="preserve">
          <source>The infinity is the result of certain math operations that overflow the floating point range, like 9**9**9. The not-a-number is the result when the result is undefined or unrepresentable. Though note that you cannot get &lt;code&gt;NaN&lt;/code&gt; from some common &quot;undefined&quot; or &quot;out-of-range&quot; operations like dividing by zero, or square root of a negative number, since Perl generates fatal errors for those.</source>
          <target state="translated">무한대는 9 ** 9 ** 9와 같이 부동 소수점 범위를 오버플로하는 특정 수학 연산의 결과입니다. 숫자가 아님은 결과가 정의되지 않았거나 표현할 수없는 경우의 결과입니다. Perl은 치명적인 오류를 생성하기 때문에 0으로 나누기 또는 음수의 제곱근과 같은 일반적인 &quot;정의되지 않은&quot;또는 &quot;범위를 벗어난&quot;작업에서 &lt;code&gt;NaN&lt;/code&gt; 을 얻을 수는 없습니다 .</target>
        </trans-unit>
        <trans-unit id="00c49c340cf01a0ad0057e1d1a4eb69e30e225ff" translate="yes" xml:space="preserve">
          <source>The information in</source>
          <target state="translated">정보</target>
        </trans-unit>
        <trans-unit id="477d4eda55a2d3f9993a8441da0761392c6f4bde" translate="yes" xml:space="preserve">
          <source>The init routine asks a few questions and writes a CPAN/Config.pm or CPAN/MyConfig.pm file (depending on what it is currently using).</source>
          <target state="translated">init 루틴은 몇 가지 질문을하고 CPAN / Config.pm 또는 CPAN / MyConfig.pm 파일을 작성합니다 (현재 사용중인 파일에 따라 다름).</target>
        </trans-unit>
        <trans-unit id="46a6f162dfe4fd1932efaab095f3ad6c7065353c" translate="yes" xml:space="preserve">
          <source>The initial Haiku port was done by Ingo Weinhold &amp;lt;ingo_weinhold@gmx.de&amp;gt;.</source>
          <target state="translated">초기 Haiku 포트는 Ingo Weinhold &amp;lt;ingo_weinhold@gmx.de&amp;gt;에 의해 수행되었습니다.</target>
        </trans-unit>
        <trans-unit id="98cc24e951f63d830750ae3c1189e0eb891874c8" translate="yes" xml:space="preserve">
          <source>The initial call must supply the root of the tree as both top and o.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30baee764016e0fd1d74fa20302dc7f15e17366e" translate="yes" xml:space="preserve">
          <source>The initial comment shows a contrived, even dangerous example. By overriding &lt;code&gt;&lt;a href=&quot;functions/glob&quot;&gt;glob&lt;/a&gt;&lt;/code&gt; globally, you would be forcing the new (and subversive) behavior for the &lt;code&gt;&lt;a href=&quot;functions/glob&quot;&gt;glob&lt;/a&gt;&lt;/code&gt; operator for</source>
          <target state="translated">초기 의견은 생각 나고 위험한 예를 보여줍니다. &lt;code&gt;&lt;a href=&quot;functions/glob&quot;&gt;glob&lt;/a&gt;&lt;/code&gt; 를 전역 적으로 재정의 하면 &lt;code&gt;&lt;a href=&quot;functions/glob&quot;&gt;glob&lt;/a&gt;&lt;/code&gt; 연산자에 대해 새로운 (그리고 파괴적인) 동작을 강제 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="60355db9cd866fe1c7fe0bda38b193d6a4e848c8" translate="yes" xml:space="preserve">
          <source>The initial comment shows a contrived, even dangerous example. By overriding &lt;code&gt;glob&lt;/code&gt; globally, you would be forcing the new (and subversive) behavior for the &lt;code&gt;glob&lt;/code&gt; operator for</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="825ce23847c0393ed93e8d89640392b4a5b33a5c" translate="yes" xml:space="preserve">
          <source>The initial program is started up using the locale specified from the environment, as currently, described in &lt;a href=&quot;#ENVIRONMENT&quot;&gt;&quot;ENVIRONMENT&quot;&lt;/a&gt;. All newly created threads start with &lt;code&gt;LC_ALL&lt;/code&gt; set to &lt;code&gt;&quot;C&quot;&lt;/code&gt;&amp;gt;. Each thread may use &lt;code&gt;POSIX::setlocale()&lt;/code&gt; to query or switch its locale at any time, without affecting any other thread. All locale-dependent operations automatically use their thread's locale.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9bd35ba0a15f59402bf69541a0c2a672b5245bb7" translate="yes" xml:space="preserve">
          <source>The initializer for a class element is an object of the corresponding class, or of one of it's subclasses, or a reference to a hash containing named arguments to be passed to the element's constructor.</source>
          <target state="translated">클래스 요소의 이니셜 라이저는 해당 클래스 또는 해당 서브 클래스 중 하나의 객체이거나 요소의 생성자에 전달할 명명 된 인수가 포함 된 해시에 대한 참조입니다.</target>
        </trans-unit>
        <trans-unit id="12094a548e09c78cbb33f308cc132c5c3175cfa2" translate="yes" xml:space="preserve">
          <source>The input &lt;code&gt;curlen&lt;/code&gt; parameter was 0.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7270a1d75b517033df50fe18fd9734207c302454" translate="yes" xml:space="preserve">
          <source>The input character at &lt;code&gt;p&lt;/code&gt; is assumed to be well-formed.</source>
          <target state="translated">&lt;code&gt;p&lt;/code&gt; 의 입력 문자 가 올바른 것으로 가정합니다.</target>
        </trans-unit>
        <trans-unit id="5b4da48b1525c95aa66984d855f728baeff9dd23" translate="yes" xml:space="preserve">
          <source>The input data will be read from each file in turn.</source>
          <target state="translated">입력 데이터는 각 파일에서 차례로 읽 힙니다.</target>
        </trans-unit>
        <trans-unit id="6a300bdc55cb2694c445f5d77189a272f405a2c8" translate="yes" xml:space="preserve">
          <source>The input number must be a non-negative integer, or a string beginning with &lt;code&gt;&quot;U+&quot;&lt;/code&gt; or &lt;code&gt;&quot;0x&quot;&lt;/code&gt; with the remainder considered to be a hexadecimal integer. A literal numeric constant must be unsigned; it will be interpreted as hex if it has a leading zero or contains non-decimal hex digits; otherwise it will be interpreted as decimal. If it begins with &lt;code&gt;&quot;U+&quot;&lt;/code&gt; , it is interpreted as the Unicode code point; otherwise it is interpreted as native. (Only code points below 256 can differ between Unicode and native.) Thus &lt;code&gt;U+41&lt;/code&gt; is always the Latin letter &quot;A&quot;; but &lt;code&gt;0x41&lt;/code&gt; can be &quot;NO-BREAK SPACE&quot; on EBCDIC platforms.</source>
          <target state="translated">입력 번호는 음이 아닌 정수이거나 &lt;code&gt;&quot;U+&quot;&lt;/code&gt; 또는 &lt;code&gt;&quot;0x&quot;&lt;/code&gt; 로 시작하는 문자열 이어야하며 나머지는 16 진수 정수로 간주됩니다. 리터럴 숫자 상수는 부호가 없어야합니다. 앞에 0이 있거나 16 진이 아닌 16 진수가 포함 된 경우 16 진으로 해석됩니다. 그렇지 않으면 십진수로 해석됩니다. &lt;code&gt;&quot;U+&quot;&lt;/code&gt; 시작 하면 유니 코드 코드 포인트로 해석됩니다. 그렇지 않으면 기본으로 해석됩니다. (256 미만의 코드 포인트 만 유니 코드와 네이티브간에 다를 수 있습니다.) 따라서 &lt;code&gt;U+41&lt;/code&gt; 은 항상 라틴 문자 &quot;A&quot;입니다. EBCDIC 플랫폼 에서는 &lt;code&gt;0x41&lt;/code&gt; 이 &quot;NO-BREAK SPACE&quot;가 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3bfc355d9523e05f661ba51d39053e5f158eac0d" translate="yes" xml:space="preserve">
          <source>The input number must be a non-negative integer, or a string beginning with &lt;code&gt;&quot;U+&quot;&lt;/code&gt; or &lt;code&gt;&quot;0x&quot;&lt;/code&gt; with the remainder considered to be a hexadecimal integer. A literal numeric constant must be unsigned; it will be interpreted as hex if it has a leading zero or contains non-decimal hex digits; otherwise it will be interpreted as decimal. If it begins with &lt;code&gt;&quot;U+&quot;&lt;/code&gt;, it is interpreted as the Unicode code point; otherwise it is interpreted as native. (Only code points below 256 can differ between Unicode and native.) Thus &lt;code&gt;U+41&lt;/code&gt; is always the Latin letter &quot;A&quot;; but &lt;code&gt;0x41&lt;/code&gt; can be &quot;NO-BREAK SPACE&quot; on EBCDIC platforms.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74af33c799ba9469f42a06ffc1422c08fe76ab11" translate="yes" xml:space="preserve">
          <source>The input parameter name is loosely matched, which means that white space, hyphens, and underscores are ignored (except for the trailing underscore in the old_form grandfathered-in &lt;code&gt;&quot;L_&quot;&lt;/code&gt; , which is better written as &lt;code&gt;&quot;LC&quot;&lt;/code&gt; , and both of which mean &lt;code&gt;General_Category=Cased Letter&lt;/code&gt; ).</source>
          <target state="translated">입력 매개 변수 이름이 느슨하게 일치합니다. 즉, 공백, 하이픈 및 밑줄은 무시됩니다 (old_form grandfathered-in &lt;code&gt;&quot;L_&quot;&lt;/code&gt; 의 후행 밑줄은 제외하고 &lt;code&gt;&quot;LC&quot;&lt;/code&gt; 로 더 잘 작성되며 둘 다 의미 함) &lt;code&gt;General_Category=Cased Letter&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="50a387d524817a7fe881c13a9828020ec107aa28" translate="yes" xml:space="preserve">
          <source>The input parameter name is loosely matched, which means that white space, hyphens, and underscores are ignored (except for the trailing underscore in the old_form grandfathered-in &lt;code&gt;&quot;L_&quot;&lt;/code&gt;, which is better written as &lt;code&gt;&quot;LC&quot;&lt;/code&gt;, and both of which mean &lt;code&gt;General_Category=Cased Letter&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e74e0d2d8b749838155344b24b616732216f51a" translate="yes" xml:space="preserve">
          <source>The input record separator - &lt;code&gt;$/&lt;/code&gt; in Perl space.</source>
          <target state="translated">입력 레코드 구분 기호 -Perl 공간에서 &lt;code&gt;$/&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7fa23e4762b9d73d4eaf4fe4ff40a6345a28b068" translate="yes" xml:space="preserve">
          <source>The input record separator, newline by default. This influences Perl's idea of what a &quot;line&quot; is. Works like &lt;b&gt;awk&lt;/b&gt;'s RS variable, including treating empty lines as a terminator if set to the null string (an empty line cannot contain any spaces or tabs). You may set it to a multi-character string to match a multi-character terminator, or to &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; to read through the end of file. Setting it to &lt;code&gt;&quot;\n\n&quot;&lt;/code&gt; means something slightly different than setting to &lt;code&gt;&quot;&quot;&lt;/code&gt; , if the file contains consecutive empty lines. Setting to &lt;code&gt;&quot;&quot;&lt;/code&gt; will treat two or more consecutive empty lines as a single empty line. Setting to &lt;code&gt;&quot;\n\n&quot;&lt;/code&gt; will blindly assume that the next input character belongs to the next paragraph, even if it's a newline.</source>
          <target state="translated">입력 레코드 구분 기호 (기본적으로 줄 바꾸기). 이것은 &quot;선&quot;이 무엇인지에 대한 Perl의 아이디어에 영향을 미칩니다. null 문자열로 설정된 경우 빈 줄을 종료 자로 처리하는 것을 포함하여 &lt;b&gt;awk&lt;/b&gt; 의 RS 변수 처럼 작동 합니다 (빈 줄은 공백이나 탭을 포함 할 수 없음). 다중 문자 터미네이터와 일치 시키거나 파일 끝을 읽 도록 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 하도록 다중 문자 문자열로 설정할 수 있습니다 . 로 설정 &lt;code&gt;&quot;\n\n&quot;&lt;/code&gt; 로 설정하는 것보다 약간 다른 의미 뭔가 &lt;code&gt;&quot;&quot;&lt;/code&gt; 파일이 연속 빈 줄이 포함 된 경우. &lt;code&gt;&quot;&quot;&lt;/code&gt; 로 설정하면 연속 된 두 개 이상의 빈 줄이 하나의 빈 줄로 취급됩니다. 로 설정 &lt;code&gt;&quot;\n\n&quot;&lt;/code&gt; 다음 입력 문자가 개행 문자 인 경우에도 다음 입력 문자가 다음 단락에 속한다고 맹목적으로 가정합니다.</target>
        </trans-unit>
        <trans-unit id="e85a2d63aac48888c217e5fc29fb75b0836651b1" translate="yes" xml:space="preserve">
          <source>The input record separator, newline by default. This influences Perl's idea of what a &quot;line&quot; is. Works like &lt;b&gt;awk&lt;/b&gt;'s RS variable, including treating empty lines as a terminator if set to the null string (an empty line cannot contain any spaces or tabs). You may set it to a multi-character string to match a multi-character terminator, or to &lt;code&gt;undef&lt;/code&gt; to read through the end of file. Setting it to &lt;code&gt;&quot;\n\n&quot;&lt;/code&gt; means something slightly different than setting to &lt;code&gt;&quot;&quot;&lt;/code&gt;, if the file contains consecutive empty lines. Setting to &lt;code&gt;&quot;&quot;&lt;/code&gt; will treat two or more consecutive empty lines as a single empty line. Setting to &lt;code&gt;&quot;\n\n&quot;&lt;/code&gt; will blindly assume that the next input character belongs to the next paragraph, even if it's a newline.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a207c3a9402edc134f0e1308be59f0ea92cbf62" translate="yes" xml:space="preserve">
          <source>The input sequence is not standard UTF-8, but a Perl extension. This bit is set only if the input &lt;code&gt;flags&lt;/code&gt; parameter contains either the &lt;code&gt;UTF8_DISALLOW_PERL_EXTENDED&lt;/code&gt; or the &lt;code&gt;UTF8_WARN_PERL_EXTENDED&lt;/code&gt; flags.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c1ce589ec1298c83c9efa29e1da93e2c83adb1f" translate="yes" xml:space="preserve">
          <source>The input sequence was malformed in that &lt;code&gt;curlen&lt;/code&gt; is smaller than required for a complete sequence. In other words, the input is for a partial character sequence.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da71ee8003bfe3e8ec2c57918f6f663af8a1ae47" translate="yes" xml:space="preserve">
          <source>The input sequence was malformed in that a non-continuation type byte was found in a position where only a continuation type one should be. See also &lt;a href=&quot;#UTF8_GOT_SHORT&quot;&gt;&quot;&lt;code&gt;UTF8_GOT_SHORT&lt;/code&gt;&quot;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da4e094d6ddae88fabdfbba8b8e5241b863d54f9" translate="yes" xml:space="preserve">
          <source>The input sequence was malformed in that it is for a -Unicode UTF-16 surrogate code point. This bit is set only if the input &lt;code&gt;flags&lt;/code&gt; parameter contains either the &lt;code&gt;UTF8_DISALLOW_SURROGATE&lt;/code&gt; or the &lt;code&gt;UTF8_WARN_SURROGATE&lt;/code&gt; flags.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff44b5ee5ee25243c0818e9bac3059eeea96ab14" translate="yes" xml:space="preserve">
          <source>The input sequence was malformed in that it is for a code point that is not representable in the number of bits available in an IV on the current platform.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="903db38b58d5e3ef05b722cc2b0b61f1d172318a" translate="yes" xml:space="preserve">
          <source>The input sequence was malformed in that it is for a non-Unicode code point; that is, one above the legal Unicode maximum. This bit is set only if the input &lt;code&gt;flags&lt;/code&gt; parameter contains either the &lt;code&gt;UTF8_DISALLOW_SUPER&lt;/code&gt; or the &lt;code&gt;UTF8_WARN_SUPER&lt;/code&gt; flags.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c430a74085221ab38d297957bbc930788c28aae9" translate="yes" xml:space="preserve">
          <source>The input sequence was malformed in that the first byte was a UTF-8 continuation byte.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7003ec3d60fe29e1076b40608f946cd82019d546" translate="yes" xml:space="preserve">
          <source>The input sequence was malformed in that there is some other sequence that evaluates to the same code point, but that sequence is shorter than this one.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32e2a05c675d83b32cdc798d03f4bd19670bf464" translate="yes" xml:space="preserve">
          <source>The insertion of a scalar or list value somewhere in the middle of another value, such that it appears to have been there all along. In Perl, variable interpolation happens in double-quoted strings and patterns, and list interpolation occurs when constructing the list of values to pass to a list operator or other such construct that takes a</source>
          <target state="translated">다른 값의 중간에 스칼라 또는 목록 값을 삽입하여 모든 값이있는 것처럼 보입니다. Perl에서 변수 보간은 큰 따옴표로 묶인 문자열과 패턴에서 발생하며, 목록 보간은 목록 연산자 또는 다음과 같은 다른 구문에 전달할 값 목록을 구성 할 때 발생합니다.</target>
        </trans-unit>
        <trans-unit id="4d21a2b8d717cbebbeaee5c37e1b249a9b6f4299" translate="yes" xml:space="preserve">
          <source>The inspiration for the stop codon DNA example came from the ZIP code example in chapter 7 of</source>
          <target state="translated">코돈 DNA 중지 예제에 대한 영감은 7 장의 우편 번호 예제에서 나왔습니다.</target>
        </trans-unit>
        <trans-unit id="4a97f9d9b06cf863773b30ca4503b6a95be51b13" translate="yes" xml:space="preserve">
          <source>The installation paths that you set during the build get compiled into perl, so you don't have to do anything additional to start using that perl (except add its location to your PATH variable).</source>
          <target state="translated">빌드 중에 설정 한 설치 경로가 perl로 컴파일되므로 해당 perl을 사용하기 위해 추가 경로를 수행 할 필요가 없습니다 (PATH 변수에 위치 추가 제외).</target>
        </trans-unit>
        <trans-unit id="ed7ec50305347f54da6bfda8296e9515a40cfdd4" translate="yes" xml:space="preserve">
          <source>The installer is ancient and has a few bugs on the paths it uses. You will have to fix them later. Basically, some things go into &quot;C:/Program Files/Windows CE Tools&quot;, others go into &quot;C:/Windows CE Tools&quot; regardless of the path you gave to the installer (the default will be &quot;C:/Windows CE Tools&quot;). Reboots will be required for the installer to proceed. Also .c and .h associations with Visual Studio might get overridden when installing EVC4. You have been warned.</source>
          <target state="translated">설치 프로그램은 고대 버전이며 사용 경로에 몇 가지 버그가 있습니다. 나중에 수정해야합니다. 기본적으로 일부는 &quot;C : / Program Files / Windows CE Tools&quot;로, 다른 것은 &quot;설치 프로그램에 제공 한 경로에 관계없이&quot;C : / Windows CE Tools &quot;로 이동합니다 (기본값은&quot;C : / Windows CE Tools &quot;입니다). &quot;). 설치 프로그램을 계속 진행하려면 재부팅이 필요합니다. 또한 EVC4를 설치할 때 Visual Studio와의 .c 및 .h 연결이 무시 될 수 있습니다. 경고를 받았습니다.</target>
        </trans-unit>
        <trans-unit id="5b7ef7bcb453733f9ef12df7a7d461832dbe120b" translate="yes" xml:space="preserve">
          <source>The installman script will try to run on OS/390. There will be fewer errors if you have a roff utility installed. You can obtain GNU groff from the Redbook SG24-5944-00 ftp site.</source>
          <target state="translated">installman 스크립트는 OS / 390에서 실행을 시도합니다. roff 유틸리티가 설치되어 있으면 오류가 줄어 듭니다. Redbook SG24-5944-00 ftp 사이트에서 GNU groff를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="85593ec8ae8efa2e0dca43eb532734290d86abb5" translate="yes" xml:space="preserve">
          <source>The integer a computer uses to represent a given character. ASCII codepoints are in the range 0 to 127; Unicode codepoints are in the range 0 to 0x1F_FFFF; and Perl codepoints are in the range 0 to 2&amp;sup3;&amp;sup2;&amp;minus;1 or 0 to 2⁶⁴&amp;minus;1, depending on your native integer size. In Perl Culture, sometimes called &lt;b&gt;ordinals&lt;/b&gt;.</source>
          <target state="translated">컴퓨터가 주어진 문자를 나타내는 데 사용하는 정수. ASCII 코드 포인트의 범위는 0 ~ 127입니다. 유니 코드 코드 포인트의 범위는 0 ~ 0x1F_FFFF입니다. Perl 코드 포인트는 기본 정수 크기에 따라 0 ~ 2&amp;sup3;&amp;sup2;-1 또는 0 ~ 2⁶⁴-1 범위입니다. Perl Culture에서 &lt;b&gt;서수&lt;/b&gt; 라고도 합니다.</target>
        </trans-unit>
        <trans-unit id="fffacf90cdbd65b0d80477a60f2e9ed117d5e990" translate="yes" xml:space="preserve">
          <source>The integer formats &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;S&lt;/code&gt; , &lt;code&gt;i&lt;/code&gt; , &lt;code&gt;I&lt;/code&gt; , &lt;code&gt;l&lt;/code&gt; , &lt;code&gt;L&lt;/code&gt; , &lt;code&gt;j&lt;/code&gt; , and &lt;code&gt;J&lt;/code&gt; are inherently non-portable between processors and operating systems because they obey native byteorder and endianness. For example, a 4-byte integer 0x12345678 (305419896 decimal) would be ordered natively (arranged in and handled by the CPU registers) into bytes as</source>
          <target state="translated">정수 형식 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;S&lt;/code&gt; , &lt;code&gt;i&lt;/code&gt; , &lt;code&gt;I&lt;/code&gt; , &lt;code&gt;l&lt;/code&gt; , &lt;code&gt;L&lt;/code&gt; , &lt;code&gt;j&lt;/code&gt; 및 &lt;code&gt;J&lt;/code&gt; 는 기본 바이트 순서 및 엔디안을 준수하기 때문에 프로세서와 운영 체제간에 본질적으로 이식성이 없습니다. 예를 들어, 4 바이트 정수 0x12345678 (10 진수 305419896)은 기본적으로 (CPU 레지스터에서 정렬 및 처리) 바이트 단위로 정렬됩니다.</target>
        </trans-unit>
        <trans-unit id="c85dc9716f98ce9d26e0b8a1181441b82dd671db" translate="yes" xml:space="preserve">
          <source>The integer formats &lt;code&gt;&lt;a href=&quot;s&quot;&gt;s&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;S&lt;/code&gt; , &lt;code&gt;i&lt;/code&gt; , &lt;code&gt;I&lt;/code&gt; , &lt;code&gt;l&lt;/code&gt; , &lt;code&gt;L&lt;/code&gt; , &lt;code&gt;j&lt;/code&gt; , and &lt;code&gt;J&lt;/code&gt; are inherently non-portable between processors and operating systems because they obey native byteorder and endianness. For example, a 4-byte integer 0x12345678 (305419896 decimal) would be ordered natively (arranged in and handled by the CPU registers) into bytes as</source>
          <target state="translated">정수 형식 &lt;code&gt;&lt;a href=&quot;s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;S&lt;/code&gt; , &lt;code&gt;i&lt;/code&gt; , &lt;code&gt;I&lt;/code&gt; , &lt;code&gt;l&lt;/code&gt; , &lt;code&gt;L&lt;/code&gt; , &lt;code&gt;j&lt;/code&gt; 및 &lt;code&gt;J&lt;/code&gt; 는 기본 바이트 순서 및 엔디안을 준수하기 때문에 프로세서와 운영 체제간에 본질적으로 이식성이 없습니다. 예를 들어, 4 바이트 정수 0x12345678 (10 진수 305419896)은 기본적으로 (CPU 레지스터에서 정렬 및 처리) 바이트 단위로 정렬됩니다.</target>
        </trans-unit>
        <trans-unit id="8d253eb6809a9562624388d35993ef60096f96e8" translate="yes" xml:space="preserve">
          <source>The integer formats &lt;code&gt;s&lt;/code&gt;, &lt;code&gt;S&lt;/code&gt;, &lt;code&gt;i&lt;/code&gt;, &lt;code&gt;I&lt;/code&gt;, &lt;code&gt;l&lt;/code&gt;, &lt;code&gt;L&lt;/code&gt;, &lt;code&gt;j&lt;/code&gt;, and &lt;code&gt;J&lt;/code&gt; are inherently non-portable between processors and operating systems because they obey native byteorder and endianness. For example, a 4-byte integer 0x12345678 (305419896 decimal) would be ordered natively (arranged in and handled by the CPU registers) into bytes as</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1696e5627c4e618d6b57f471d56db53f3261ebc8" translate="yes" xml:space="preserve">
          <source>The integer four, not to be confused with six, Tom&amp;rsquo;s favorite editor. IV also means an internal Integer Value of the type a &lt;b&gt;scalar&lt;/b&gt; can hold, not to be confused with an &lt;b&gt;NV&lt;/b&gt;.</source>
          <target state="translated">Tom이 가장 좋아하는 편집기 6과 혼동하지 않는 정수 4입니다. IV는 또한 &lt;b&gt;스칼라&lt;/b&gt; 가 보유 할 수 있는 유형의 내부 정수 값을 의미 하며 &lt;b&gt;NV&lt;/b&gt; 와 혼동하지 않아야합니다 .</target>
        </trans-unit>
        <trans-unit id="38f7f88bfbbfc7fbb6565adc2a9af0982c4ebbc9" translate="yes" xml:space="preserve">
          <source>The integer or name form of the &lt;code&gt;condition&lt;/code&gt; allows us to choose, with more flexibility, what to match based on what matched earlier in the regexp. This searches for words of the form &lt;code&gt;&quot;$x$x&quot;&lt;/code&gt; or &lt;code&gt;&quot;$x$y$y$x&quot;&lt;/code&gt; :</source>
          <target state="translated">의 정수 또는 이름 형식 &lt;code&gt;condition&lt;/code&gt; 우리가 더 유연하게 선택할 수 있으며, 정규 표현식에서 이전의 일치 내용을 기반으로 일치하는 것. &lt;code&gt;&quot;$x$x&quot;&lt;/code&gt; 또는 &lt;code&gt;&quot;$x$y$y$x&quot;&lt;/code&gt; 형식의 단어를 검색합니다 .</target>
        </trans-unit>
        <trans-unit id="fa48e81451f89adaf419b03b6f56f3e3cdc6501d" translate="yes" xml:space="preserve">
          <source>The integer or name form of the &lt;code&gt;condition&lt;/code&gt; allows us to choose, with more flexibility, what to match based on what matched earlier in the regexp. This searches for words of the form &lt;code&gt;&quot;$x$x&quot;&lt;/code&gt; or &lt;code&gt;&quot;$x$y$y$x&quot;&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e05de89837820906430d66857198677bee870304" translate="yes" xml:space="preserve">
          <source>The integer types &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;S&lt;/code&gt; , &lt;code&gt;l&lt;/code&gt; , and &lt;code&gt;L&lt;/code&gt; may be followed by a &lt;code&gt;!&lt;/code&gt; modifier to specify native shorts or longs. As shown in the example above, a bare &lt;code&gt;l&lt;/code&gt; means exactly 32 bits, although the native &lt;code&gt;long&lt;/code&gt; as seen by the local C compiler may be larger. This is mainly an issue on 64-bit platforms. You can see whether using &lt;code&gt;!&lt;/code&gt; makes any difference this way:</source>
          <target state="translated">정수 유형 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;S&lt;/code&gt; , &lt;code&gt;l&lt;/code&gt; 및 &lt;code&gt;L&lt;/code&gt; 뒤에는 &lt;code&gt;!&lt;/code&gt; 기본 반바지 또는 길이를 지정하는 수정 자입니다. 위의 예에서 볼 수 있듯이 , 베어 &lt;code&gt;l&lt;/code&gt; 은 정확히 32 비트를 의미하지만 로컬 C 컴파일러에서 볼 수 있는 기본 &lt;code&gt;long&lt;/code&gt; 가 더 클 수도 있습니다. 이것은 주로 64 비트 플랫폼에서 발생하는 문제입니다. 당신은 사용 여부를 볼 수 있습니다 &lt;code&gt;!&lt;/code&gt; 이런 식으로 차이를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="e28530f74a983b5b7c88ba8ea81f426cbf7efd7c" translate="yes" xml:space="preserve">
          <source>The integer types &lt;code&gt;&lt;a href=&quot;s&quot;&gt;s&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;S&lt;/code&gt; , &lt;code&gt;l&lt;/code&gt; , and &lt;code&gt;L&lt;/code&gt; may be followed by a &lt;code&gt;!&lt;/code&gt; modifier to specify native shorts or longs. As shown in the example above, a bare &lt;code&gt;l&lt;/code&gt; means exactly 32 bits, although the native &lt;code&gt;long&lt;/code&gt; as seen by the local C compiler may be larger. This is mainly an issue on 64-bit platforms. You can see whether using &lt;code&gt;!&lt;/code&gt; makes any difference this way:</source>
          <target state="translated">정수 유형 &lt;code&gt;&lt;a href=&quot;s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;S&lt;/code&gt; , &lt;code&gt;l&lt;/code&gt; 및 &lt;code&gt;L&lt;/code&gt; 뒤에는 &lt;code&gt;!&lt;/code&gt; 기본 반바지 또는 길이를 지정하는 수정 자입니다. 위의 예에서 볼 수 있듯이 , 베어 &lt;code&gt;l&lt;/code&gt; 은 정확히 32 비트를 의미하지만 로컬 C 컴파일러에서 볼 수 있는 기본 &lt;code&gt;long&lt;/code&gt; 가 더 클 수도 있습니다. 이것은 주로 64 비트 플랫폼에서 발생하는 문제입니다. 당신은 사용 여부를 볼 수 있습니다 &lt;code&gt;!&lt;/code&gt; 이런 식으로 차이를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="b9395373d953b00358ac2a4a8b3d6e5305da7861" translate="yes" xml:space="preserve">
          <source>The integer types &lt;code&gt;s&lt;/code&gt;, &lt;code&gt;S&lt;/code&gt;, &lt;code&gt;l&lt;/code&gt;, and &lt;code&gt;L&lt;/code&gt; may be followed by a &lt;code&gt;!&lt;/code&gt; modifier to specify native shorts or longs. As shown in the example above, a bare &lt;code&gt;l&lt;/code&gt; means exactly 32 bits, although the native &lt;code&gt;long&lt;/code&gt; as seen by the local C compiler may be larger. This is mainly an issue on 64-bit platforms. You can see whether using &lt;code&gt;!&lt;/code&gt; makes any difference this way:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec5708b037f56278734976c0deaf7b452666b9a4" translate="yes" xml:space="preserve">
          <source>The intended purpose of this routine is to concatenate</source>
          <target state="translated">이 루틴의 목적은 연결하는 것입니다</target>
        </trans-unit>
        <trans-unit id="35499217c3dc076a80a3d7b854f65596514d0493" translate="yes" xml:space="preserve">
          <source>The intent is simplicity of use, not power of expression. Paragraphs look like paragraphs (block format), so that they stand out visually, and so that I could run them through &lt;code&gt;fmt&lt;/code&gt; easily to reformat them (that's F7 in my version of &lt;b&gt;vi&lt;/b&gt;, or Esc Q in my version of &lt;b&gt;emacs&lt;/b&gt;). I wanted the translator to always leave the &lt;code&gt;'&lt;/code&gt; and &lt;code&gt;`&lt;/code&gt; and &lt;code&gt;&quot;&lt;/code&gt; quotes alone, in verbatim mode, so I could slurp in a working program, shift it over four spaces, and have it print out, er, verbatim. And presumably in a monospace font.</source>
          <target state="translated">의도는 표현력이 아니라 사용의 단순성입니다. 단락은 시각적으로 눈에 띄는 그래서, 단락 (블록 형식)처럼, 그래서 나는 통해 실행할 수 &lt;code&gt;fmt&lt;/code&gt; (내 버전에서 F7을의 저를 다시 포맷 쉽게 &lt;b&gt;VI&lt;/b&gt; 의 내 버전, 또는 Esc Q &lt;b&gt;이맥스&lt;/b&gt; ). 난 항상에 번역자가 떠날 원 &lt;code&gt;'&lt;/code&gt; 및 &lt;code&gt;`&lt;/code&gt; 와 &lt;code&gt;&quot;&lt;/code&gt; 나는 모노 스페이스에 그대로. 그리고 아마도, 어, 작업 프로그램에 후루룩 소리 내며 먹기 네 개의 공간에 그것을 이동, 그리고 그것을 인쇄 할 수 있도록, 그대로 모드, 혼자 따옴표 폰트.</target>
        </trans-unit>
        <trans-unit id="0fe331c074ca976ebd60519539ebf547e9a5979f" translate="yes" xml:space="preserve">
          <source>The intent is to squeeze as much possible information about the likely cause into the limited space of the system exit code. However, as &lt;a href=&quot;perlvar#%24%21&quot;&gt;&lt;code&gt;$!&lt;/code&gt;&lt;/a&gt; is the value of C's &lt;code&gt;errno&lt;/code&gt;, which can be set by any system call, this means that the value of the exit code used by &lt;a href=&quot;#die-LIST&quot;&gt;&lt;code&gt;die&lt;/code&gt;&lt;/a&gt; can be non-predictable, so should not be relied upon, other than to be non-zero.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e5ab1ae02bd72d53207c68855ddd39b0273ee3a8" translate="yes" xml:space="preserve">
          <source>The intent is to squeeze as much possible information about the likely cause into the limited space of the system exit code. However, as &lt;code&gt;$!&lt;/code&gt; is the value of C's &lt;code&gt;errno&lt;/code&gt; , which can be set by any system call, this means that the value of the exit code used by &lt;code&gt;&lt;a href=&quot;die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; can be non-predictable, so should not be relied upon, other than to be non-zero.</source>
          <target state="translated">시스템 종료 코드의 제한된 공간에 가능한 원인에 대한 가능한 많은 정보를 압축하는 것이 목적입니다. 그러나 &lt;code&gt;$!&lt;/code&gt; 는 시스템 호출에 의해 설정 될 수있는 C의 &lt;code&gt;errno&lt;/code&gt; 값입니다 . 이는 &lt;code&gt;&lt;a href=&quot;die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; 에서 사용하는 종료 코드의 값을 예측할 수 없으므로 0이 아닌 값에 의존해서는 안됨을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="0547c3f088cded7d6e36027ba3384ed9126a4a35" translate="yes" xml:space="preserve">
          <source>The intent is to squeeze as much possible information about the likely cause into the limited space of the system exit code. However, as &lt;code&gt;$!&lt;/code&gt; is the value of C's &lt;code&gt;errno&lt;/code&gt; , which can be set by any system call, this means that the value of the exit code used by &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; can be non-predictable, so should not be relied upon, other than to be non-zero.</source>
          <target state="translated">시스템 종료 코드의 제한된 공간에 가능한 원인에 대한 가능한 많은 정보를 압축하는 것이 목적입니다. 그러나 &lt;code&gt;$!&lt;/code&gt; 는 시스템 호출에 의해 설정 될 수있는 C의 &lt;code&gt;errno&lt;/code&gt; 값입니다 . 이는 &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; 에서 사용하는 종료 코드의 값을 예측할 수 없으므로 0이 아닌 값에 의존해서는 안됨을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="2e91002a8407b92abe1904ddf5c320e2e26254c0" translate="yes" xml:space="preserve">
          <source>The interaction with the Perl compilation happens inside package &lt;code&gt;myint&lt;/code&gt; :</source>
          <target state="translated">Perl 컴파일과의 상호 작용은 &lt;code&gt;myint&lt;/code&gt; 패키지 내에서 발생합니다 .</target>
        </trans-unit>
        <trans-unit id="aadf28bb5828714b5bb46305e38581c5103da604" translate="yes" xml:space="preserve">
          <source>The interaction with the Perl compilation happens inside package &lt;code&gt;myint&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa4116edd722cc9f90eb68f17a977fcbd1367d5c" translate="yes" xml:space="preserve">
          <source>The interactive debugger understands the following commands:</source>
          <target state="translated">대화식 디버거는 다음 명령을 이해합니다.</target>
        </trans-unit>
        <trans-unit id="99a3cf2098e457c2b3c584e37ad9ed7869d1340e" translate="yes" xml:space="preserve">
          <source>The interested reader might have seen a number of flags that signify encodings or codesets - &lt;code&gt;utf8&lt;/code&gt;, &lt;code&gt;latin1&lt;/code&gt; and &lt;code&gt;ascii&lt;/code&gt;. There seems to be some confusion on what these do, so here is a short comparison:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e70d776f0381bce09991021b76dd2d122db7ce29" translate="yes" xml:space="preserve">
          <source>The interesting thing about &lt;code&gt;&amp;amp;&lt;/code&gt; is that you can generate new syntax with it, provided it's in the initial position:</source>
          <target state="translated">&lt;code&gt;&amp;amp;&lt;/code&gt; 의 흥미로운 점은 초기 위치에있는 경우 새 구문을 생성 할 수 있다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="2354b426f3be078a3ef57dbce0f8523b4f89323f" translate="yes" xml:space="preserve">
          <source>The interface defined by this module is missing some of the later additions to perl's debugging functionality. As such, this interface should be considered highly experimental and subject to change.</source>
          <target state="translated">이 모듈에 의해 정의 된 인터페이스에 나중에 perl의 디버깅 기능에 추가 된 일부가 누락되었습니다. 따라서이 인터페이스는 고도로 실험적이며 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6bc76db195856b77ae9c9e32f58ddf5271ff9965" translate="yes" xml:space="preserve">
          <source>The interface exposed by this module is very close to the current implementation of restricted hashes. Over time it is expected that this behavior will be extended and the interface abstracted further.</source>
          <target state="translated">이 모듈에 의해 노출되는 인터페이스는 현재 제한된 해시 구현과 매우 유사합니다. 시간이 지남에 따라이 동작이 확장되고 인터페이스가 더 추상화 될 것으로 예상됩니다.</target>
        </trans-unit>
        <trans-unit id="25ed6271fa2a1e00048e3f70c7ae05b81e869ba4" translate="yes" xml:space="preserve">
          <source>The interface is a bit odd because this is the result of a quick refactoring. Don't rely on it.</source>
          <target state="translated">인터페이스는 빠른 리팩토링의 결과이기 때문에 조금 이상합니다. 그것에 의존하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="4f992c0404449ac096de07bc9c29b6b99091aebe" translate="yes" xml:space="preserve">
          <source>The interface provided by version 2 of this module should be 100% backward compatible with version 1. If you find a difference in the expected behaviour please contact the author (See &lt;a href=&quot;#AUTHOR&quot;&gt;&quot;AUTHOR&quot;&lt;/a&gt;). See &lt;a href=&quot;#GZIP-INTERFACE&quot;&gt;&quot;GZIP INTERFACE&quot;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="86fb605133e4937943b1ba063015c9eb55c6a1c4" translate="yes" xml:space="preserve">
          <source>The interface provided by version 2 of this module should be 100% backward compatible with version 1. If you find a difference in the expected behaviour please contact the author (See &lt;a href=&quot;#AUTHOR&quot;&gt;AUTHOR&lt;/a&gt;). See &lt;a href=&quot;#GZIP-INTERFACE&quot;&gt;GZIP INTERFACE&lt;/a&gt;</source>
          <target state="translated">이 모듈의 버전 2에서 제공하는 인터페이스는 버전 1과 100 % 역 호환되어야합니다. 예상되는 동작에 차이가있는 경우 작성자에게 문의하십시오 ( &lt;a href=&quot;#AUTHOR&quot;&gt;AUTHOR&lt;/a&gt; 참조 ). &lt;a href=&quot;#GZIP-INTERFACE&quot;&gt;GZIP 인터페이스&lt;/a&gt; 참조</target>
        </trans-unit>
        <trans-unit id="869b0eb21cd8ea8a7cd6e0d3a06abffd6a4f3e9a" translate="yes" xml:space="preserve">
          <source>The interface provides two ways to calculate digests: all-at-once, or in stages. To illustrate, the following short program computes the SHA-256 digest of &quot;hello world&quot; using each approach:</source>
          <target state="translated">이 인터페이스는 다이제스트를 계산하는 두 가지 방법, 즉 한 번에 또는 단계로 제공합니다. 다음 짧은 프로그램은 각 방법을 사용하여 &quot;hello world&quot;의 SHA-256 다이제스트를 계산합니다.</target>
        </trans-unit>
        <trans-unit id="fb22cb5dbe02d4f126e70eb38eba99f572c134f7" translate="yes" xml:space="preserve">
          <source>The interface to Exec in entirely encapsulated within the perl class, there is no need to access the low level methods directly and they are not exported by default.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="506d079f3d8576c485b8b85a9995943fec82c8f8" translate="yes" xml:space="preserve">
          <source>The interface to the arexx.class in entirely encapsulated within the perl class, there is no need to access the low level methods directly and they are not exported by default.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8dedf705c01e5c3576fd3717e147541ecb372f63" translate="yes" xml:space="preserve">
          <source>The internal advisory locking is implemented using Perl's flock() routine. If your system does not support any form of flock(), or if you share your files across NFS, you might wish to use other forms of locking by using modules such as LockFile::Simple which lock a file using a filesystem entry, instead of locking the file descriptor.</source>
          <target state="translated">내부 권고 잠금은 Perl의 flock () 루틴을 사용하여 구현됩니다. 시스템이 flock () 형식을 지원하지 않거나 NFS를 통해 파일을 공유하는 경우 파일 시스템 항목을 사용하여 파일을 잠그는 LockFile :: Simple과 같은 모듈을 사용하여 다른 형식의 잠금을 사용할 수 있습니다. 파일 디스크립터 잠금</target>
        </trans-unit>
        <trans-unit id="b695712dbfa2556923ae8104354e307b6dd7d107" translate="yes" xml:space="preserve">
          <source>The internal structure of version objects is a blessed hash with several components:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="798a90f8fceb3237e533c15e8087d7887afcfeb7" translate="yes" xml:space="preserve">
          <source>The internal variable for debugging support. The meanings of the various bits are subject to change, but currently indicate:</source>
          <target state="translated">디버깅 지원을위한 내부 변수입니다. 다양한 비트의 의미는 변경 될 수 있지만 현재 다음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="85c386c4c074fc2a85f669eb89082305e3dd4f12" translate="yes" xml:space="preserve">
          <source>The internals automatically clone any name with characters 128-255 but none 256+ (ie one that could be either in bytes or utf8) into a second entry which is utf8 encoded.</source>
          <target state="translated">내부는 문자 128-255이지만 256+ (예 : 바이트 또는 utf8 일 수 없음)의 이름은 utf8로 인코딩 된 두 번째 항목에 자동으로 복제합니다.</target>
        </trans-unit>
        <trans-unit id="68038f581434d0080618601485190514733606bb" translate="yes" xml:space="preserve">
          <source>The interpretation of operations and values in Perl sometimes depends on the requirements of the context around the operation or value. There are two major contexts: list and scalar. Certain operations return list values in contexts wanting a list, and scalar values otherwise. If this is true of an operation it will be mentioned in the documentation for that operation. In other words, Perl overloads certain operations based on whether the expected return value is singular or plural. Some words in English work this way, like &quot;fish&quot; and &quot;sheep&quot;.</source>
          <target state="translated">Perl에서 조작 및 값의 해석은 때때로 조작 또는 값에 대한 컨텍스트의 요구 사항에 따라 다릅니다. 리스트와 스칼라라는 두 가지 주요 컨텍스트가 있습니다. 특정 연산은 목록을 원하는 컨텍스트에서 목록 값을 반환하고 그렇지 않으면 스칼라 값을 반환합니다. 이것이 조작에 해당되는 경우 해당 조작에 대한 문서에서 언급됩니다. 다시 말해, Perl은 예상 반환 값이 단수인지 또는 복수인지에 따라 특정 연산에 과부하를가합니다. 영어로 된 일부 단어는 &quot;물고기&quot;및 &quot;양&quot;과 같이 작동합니다.</target>
        </trans-unit>
        <trans-unit id="061664239d0f872c4965463ddd59f598a09d06f0" translate="yes" xml:space="preserve">
          <source>The interpretation of the file permission operators &lt;code&gt;-r&lt;/code&gt; , &lt;code&gt;-R&lt;/code&gt; , &lt;code&gt;-w&lt;/code&gt; , &lt;code&gt;-W&lt;/code&gt; , &lt;code&gt;-x&lt;/code&gt; , and &lt;code&gt;&lt;a href=&quot;-x&quot;&gt;-X&lt;/a&gt;&lt;/code&gt; is by default based solely on the mode of the file and the uids and gids of the user. There may be other reasons you can't actually read, write, or execute the file: for example network filesystem access controls, ACLs (access control lists), read-only filesystems, and unrecognized executable formats. Note that the use of these six specific operators to verify if some operation is possible is usually a mistake, because it may be open to race conditions.</source>
          <target state="translated">파일 권한 연산자 &lt;code&gt;-r&lt;/code&gt; , &lt;code&gt;-R&lt;/code&gt; , &lt;code&gt;-w&lt;/code&gt; , &lt;code&gt;-W&lt;/code&gt; , &lt;code&gt;-x&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;-x&quot;&gt;-X&lt;/a&gt;&lt;/code&gt; 의 해석은 기본적으로 파일 모드와 사용자의 uid 및 gid에만 기반합니다. 실제로 파일을 읽거나 쓰거나 실행할 수없는 다른 이유가있을 수 있습니다 (예 : 네트워크 파일 시스템 액세스 제어, ACL (액세스 제어 목록), 읽기 전용 파일 시스템 및 인식 할 수없는 실행 파일 형식). 이 6 개의 특정 연산자를 사용하여 일부 작업이 가능한지 확인하는 것은 경쟁 조건에 개방적 일 수 있으므로 일반적으로 실수입니다.</target>
        </trans-unit>
        <trans-unit id="de2595dbfaf95d22e9019632865663f297c76092" translate="yes" xml:space="preserve">
          <source>The interpretation of the file permission operators &lt;code&gt;-r&lt;/code&gt; , &lt;code&gt;-R&lt;/code&gt; , &lt;code&gt;-w&lt;/code&gt; , &lt;code&gt;-W&lt;/code&gt; , &lt;code&gt;-x&lt;/code&gt; , and &lt;code&gt;&lt;a href=&quot;functions/-x&quot;&gt;-X&lt;/a&gt;&lt;/code&gt; is by default based solely on the mode of the file and the uids and gids of the user. There may be other reasons you can't actually read, write, or execute the file: for example network filesystem access controls, ACLs (access control lists), read-only filesystems, and unrecognized executable formats. Note that the use of these six specific operators to verify if some operation is possible is usually a mistake, because it may be open to race conditions.</source>
          <target state="translated">파일 권한 연산자 &lt;code&gt;-r&lt;/code&gt; , &lt;code&gt;-R&lt;/code&gt; , &lt;code&gt;-w&lt;/code&gt; , &lt;code&gt;-W&lt;/code&gt; , &lt;code&gt;-x&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;functions/-x&quot;&gt;-X&lt;/a&gt;&lt;/code&gt; 의 해석은 기본적으로 파일 모드와 사용자의 uid 및 gid에만 기반합니다. 실제로 파일을 읽거나 쓰거나 실행할 수없는 다른 이유가있을 수 있습니다 (예 : 네트워크 파일 시스템 액세스 제어, ACL (액세스 제어 목록), 읽기 전용 파일 시스템 및 인식 할 수없는 실행 파일 형식). 이 6 개의 특정 연산자를 사용하여 일부 작업이 가능한지 확인하는 것은 경쟁 조건에 개방적 일 수 있으므로 일반적으로 실수입니다.</target>
        </trans-unit>
        <trans-unit id="488736b34ccb462579468e7b97e0ddad7de84d1d" translate="yes" xml:space="preserve">
          <source>The interpretation of the file permission operators &lt;code&gt;-r&lt;/code&gt;, &lt;code&gt;-R&lt;/code&gt;, &lt;code&gt;-w&lt;/code&gt;, &lt;code&gt;-W&lt;/code&gt;, &lt;code&gt;-x&lt;/code&gt;, and &lt;code&gt;-X&lt;/code&gt; is by default based solely on the mode of the file and the uids and gids of the user. There may be other reasons you can't actually read, write, or execute the file: for example network filesystem access controls, ACLs (access control lists), read-only filesystems, and unrecognized executable formats. Note that the use of these six specific operators to verify if some operation is possible is usually a mistake, because it may be open to race conditions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19e2e01e4adc3fb9225914fc17730078576e41c6" translate="yes" xml:space="preserve">
          <source>The inverse function to &lt;code&gt;pairs&lt;/code&gt;; this function takes a list of &lt;code&gt;ARRAY&lt;/code&gt; references containing two elements each, and returns a flattened list of the two values from each of the pairs, in order. This is notionally equivalent to</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c54a39a0dd2a9db45fcc8606c6b9dc540f8d071d" translate="yes" xml:space="preserve">
          <source>The inverse operation - packing byte contents from a string of hexadecimal digits - is just as easily written. For instance:</source>
          <target state="translated">16 진수 문자열에서 바이트 내용을 패킹하는 역 연산도 쉽게 작성할 수 있습니다. 예를 들어 :</target>
        </trans-unit>
        <trans-unit id="8aacdda2a613fe684f7ff0ec49be15c7f7bad342" translate="yes" xml:space="preserve">
          <source>The is the number of bytes that the Storable header occupies.</source>
          <target state="translated">Storable 헤더가 차지하는 바이트 수입니다.</target>
        </trans-unit>
        <trans-unit id="e08f7fe6dcc4a4ede748bb6d3fcab7c9e89b331c" translate="yes" xml:space="preserve">
          <source>The issue of whether to pass the arguments in a hash or a hashref is largely a matter of personal style.</source>
          <target state="translated">해시 또는 해시 참조에서 인수를 전달할지 여부는 주로 개인 스타일의 문제입니다.</target>
        </trans-unit>
        <trans-unit id="1270f1d87441c40c65f184813fb9549f6a05140e" translate="yes" xml:space="preserve">
          <source>The item you want to look up. Nested modules (such as &lt;code&gt;File::Basename&lt;/code&gt; ) are specified either as &lt;code&gt;File::Basename&lt;/code&gt; or &lt;code&gt;File/Basename&lt;/code&gt; . You may also give a descriptive name of a page, such as &lt;code&gt;perlfunc&lt;/code&gt; . For URLs, HTTP and HTTPS are the only kind currently supported.</source>
          <target state="translated">조회 할 항목입니다. 중첩 모듈 (예 : &lt;code&gt;File::Basename&lt;/code&gt; )은 &lt;code&gt;File::Basename&lt;/code&gt; 또는 &lt;code&gt;File/Basename&lt;/code&gt; 으로 지정 됩니다. &lt;code&gt;perlfunc&lt;/code&gt; 와 같이 페이지의 설명 이름을 제공 할 수도 있습니다 . URL의 경우 현재 지원되는 유일한 종류는 HTTP 및 HTTPS입니다.</target>
        </trans-unit>
        <trans-unit id="4344e301a9e97fdf3fc9733e6ebe72949a9af633" translate="yes" xml:space="preserve">
          <source>The item you want to look up. Nested modules (such as &lt;code&gt;File::Basename&lt;/code&gt;) are specified either as &lt;code&gt;File::Basename&lt;/code&gt; or &lt;code&gt;File/Basename&lt;/code&gt;. You may also give a descriptive name of a page, such as &lt;code&gt;perlfunc&lt;/code&gt;. For URLs, HTTP and HTTPS are the only kind currently supported.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2fbe0de2b65f06cfcea380e50cf6bef09ae06281" translate="yes" xml:space="preserve">
          <source>The iterator used by &lt;code&gt;each&lt;/code&gt; is attached to the hash or array, and is shared between all iteration operations applied to the same hash or array. Thus all uses of &lt;code&gt;each&lt;/code&gt; on a single hash or array advance the same iterator location. All uses of &lt;code&gt;each&lt;/code&gt; are also subject to having the iterator reset by any use of &lt;code&gt;keys&lt;/code&gt; or &lt;code&gt;values&lt;/code&gt; on the same hash or array, or by the hash (but not array) being referenced in list context. This makes &lt;code&gt;each&lt;/code&gt;-based loops quite fragile: it is easy to arrive at such a loop with the iterator already part way through the object, or to accidentally clobber the iterator state during execution of the loop body. It's easy enough to explicitly reset the iterator before starting a loop, but there is no way to insulate the iterator state used by a loop from the iterator state used by anything else that might execute during the loop body. To avoid these problems, use a &lt;code&gt;foreach&lt;/code&gt; loop rather than &lt;code&gt;while&lt;/code&gt;-&lt;code&gt;each&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b950b023ee8eee0b58c44c704206373f4189c22c" translate="yes" xml:space="preserve">
          <source>The key &lt;code&gt;&quot;~~&quot;&lt;/code&gt; allows you to override the smart matching logic used by the &lt;code&gt;~~&lt;/code&gt; operator and the switch construct (&lt;code&gt;given&lt;/code&gt; /&lt;code&gt;when&lt;/code&gt; ). See &lt;a href=&quot;perlsyn#Switch-Statements&quot;&gt;Switch Statements in perlsyn&lt;/a&gt; and &lt;a href=&quot;feature&quot;&gt;feature&lt;/a&gt;.</source>
          <target state="translated">핵심은 &lt;code&gt;&quot;~~&quot;&lt;/code&gt; 당신이 사용하는 스마트 매칭 논리를 대체 할 수 있습니다 &lt;code&gt;~~&lt;/code&gt; (연산자와 스위치 구조를 &lt;code&gt;given&lt;/code&gt; / &lt;code&gt;when&lt;/code&gt; ). &lt;a href=&quot;perlsyn#Switch-Statements&quot;&gt;perlsyn&lt;/a&gt; 및 &lt;a href=&quot;feature&quot;&gt;feature의 &lt;/a&gt;스위치 명령문을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="8a2c34ae8224e419d58656178fbc2e7d6c0054d2" translate="yes" xml:space="preserve">
          <source>The key &lt;code&gt;&quot;~~&quot;&lt;/code&gt; allows you to override the smart matching logic used by the &lt;code&gt;~~&lt;/code&gt; operator and the switch construct (&lt;code&gt;given&lt;/code&gt;/&lt;code&gt;when&lt;/code&gt;). See &lt;a href=&quot;perlsyn#Switch-Statements&quot;&gt;&quot;Switch Statements&quot; in perlsyn&lt;/a&gt; and &lt;a href=&quot;feature&quot;&gt;feature&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c40c6befa9e830eefbf95715d61be0cceba411db" translate="yes" xml:space="preserve">
          <source>The key &lt;code&gt;'-X'&lt;/code&gt; is used to specify a subroutine to handle all the filetest operators (&lt;code&gt;-f&lt;/code&gt; , &lt;code&gt;-x&lt;/code&gt; , and so on: see &lt;a href=&quot;functions/-x&quot;&gt;-X&lt;/a&gt; for the full list); it is not possible to overload any filetest operator individually. To distinguish them, the letter following the '-' is passed as the second argument (that is, in the slot that for binary operators is used to pass the second operand).</source>
          <target state="translated">키 &lt;code&gt;'-X'&lt;/code&gt; 는 모든 파일 테스트 연산자를 처리하기위한 서브 루틴을 지정하는 데 사용됩니다 ( &lt;code&gt;-f&lt;/code&gt; , &lt;code&gt;-x&lt;/code&gt; 등 : 전체 목록 은 &lt;a href=&quot;functions/-x&quot;&gt;-X&lt;/a&gt; 참조 ). 파일 테스트 연산자를 개별적으로 오버로드 할 수 없습니다. 구분하기 위해 '-'뒤에 오는 문자가 두 번째 인수로 전달됩니다 (즉, 2 진 연산자의 경우 두 번째 피연산자를 전달하는 데 사용되는 슬롯에서).</target>
        </trans-unit>
        <trans-unit id="d619e5f63abc98b8cfd8901f2a523fddccb94536" translate="yes" xml:space="preserve">
          <source>The key &lt;code&gt;'-X'&lt;/code&gt; is used to specify a subroutine to handle all the filetest operators (&lt;code&gt;-f&lt;/code&gt;, &lt;code&gt;-x&lt;/code&gt;, and so on: see &lt;a href=&quot;perlfunc#-X&quot;&gt;&quot;-X&quot; in perlfunc&lt;/a&gt; for the full list); it is not possible to overload any filetest operator individually. To distinguish them, the letter following the '-' is passed as the second argument (that is, in the slot that for binary operators is used to pass the second operand).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e57e8aa67b22950a3905dc0aca0c46d976bdaa4" translate="yes" xml:space="preserve">
          <source>The key &lt;code&gt;key&lt;/code&gt; of &lt;code&gt;hv&lt;/code&gt; is deleted at the end of</source>
          <target state="translated">핵심 &lt;code&gt;key&lt;/code&gt; 의 &lt;code&gt;hv&lt;/code&gt; 말에 삭제</target>
        </trans-unit>
        <trans-unit id="39231120b3a0f9f7321946d1dcf4e67b7cbb06d0" translate="yes" xml:space="preserve">
          <source>The key &lt;code&gt;neg&lt;/code&gt; is used for unary minus to disambiguate it from binary &lt;code&gt;-&lt;/code&gt; .</source>
          <target state="translated">주요 &lt;code&gt;neg&lt;/code&gt; 바이너리에서 그것을 명확하게하기 위해 단항 마이너스에 사용됩니다 &lt;code&gt;-&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8014230ab511707fdf318f6f60f165829ac3a885" translate="yes" xml:space="preserve">
          <source>The key &lt;code&gt;neg&lt;/code&gt; is used for unary minus to disambiguate it from binary &lt;code&gt;-&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9af0ef3d95080a656a5a0ae273ae380c9667ee38" translate="yes" xml:space="preserve">
          <source>The key function is</source>
          <target state="translated">핵심 기능은</target>
        </trans-unit>
        <trans-unit id="890e53c79df507f41db3dd4d31cb915a4367afdd" translate="yes" xml:space="preserve">
          <source>The key here is the &lt;code&gt;nss_delete&lt;/code&gt; call. One workaround for this bug seems to be to create add to the file</source>
          <target state="translated">여기서 핵심은 &lt;code&gt;nss_delete&lt;/code&gt; 호출입니다. 이 버그에 대한 한 가지 해결 방법은 파일에 add를 만드는 것 같습니다.</target>
        </trans-unit>
        <trans-unit id="f07d5f582b98b9cdfa2323f91d8c44e6ee01e73a" translate="yes" xml:space="preserve">
          <source>The key is specified by</source>
          <target state="translated">키는</target>
        </trans-unit>
        <trans-unit id="dbf499b463a1d246f5657c7bd10575193916c7a6" translate="yes" xml:space="preserve">
          <source>The key is specified by &lt;code&gt;keypv&lt;/code&gt; and &lt;code&gt;keylen&lt;/code&gt;. If &lt;code&gt;flags&lt;/code&gt; has the &lt;code&gt;COPHH_KEY_UTF8&lt;/code&gt; bit set, the key octets are interpreted as UTF-8, otherwise they are interpreted as Latin-1. &lt;code&gt;hash&lt;/code&gt; is a precomputed hash of the key string, or zero if it has not been precomputed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a4574cc32e125230b635f70eb51279af8024135" translate="yes" xml:space="preserve">
          <source>The keys allowed in each of these pre-defined references is limited to the names used in the equivalent C structure. So, for example, the $DB_HASH reference will only allow keys called &lt;code&gt;bsize&lt;/code&gt; , &lt;code&gt;cachesize&lt;/code&gt; , &lt;code&gt;ffactor&lt;/code&gt; , &lt;code&gt;hash&lt;/code&gt; , &lt;code&gt;lorder&lt;/code&gt; and &lt;code&gt;nelem&lt;/code&gt; .</source>
          <target state="translated">이러한 사전 정의 된 각 참조에서 허용되는 키는 동등한 C 구조에서 사용되는 이름으로 제한됩니다. 예를 들어 $ DB_HASH 참조는 &lt;code&gt;bsize&lt;/code&gt; , &lt;code&gt;cachesize&lt;/code&gt; , &lt;code&gt;ffactor&lt;/code&gt; , &lt;code&gt;hash&lt;/code&gt; , &lt;code&gt;lorder&lt;/code&gt; 및 &lt;code&gt;nelem&lt;/code&gt; 이라는 키만 허용합니다 .</target>
        </trans-unit>
        <trans-unit id="b2b4b1e7a4b07bed8f5dd49d279e3a199199b7a2" translate="yes" xml:space="preserve">
          <source>The keys allowed in each of these pre-defined references is limited to the names used in the equivalent C structure. So, for example, the $DB_HASH reference will only allow keys called &lt;code&gt;bsize&lt;/code&gt;, &lt;code&gt;cachesize&lt;/code&gt;, &lt;code&gt;ffactor&lt;/code&gt;, &lt;code&gt;hash&lt;/code&gt;, &lt;code&gt;lorder&lt;/code&gt; and &lt;code&gt;nelem&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6ed2e67811ac5de5639075023acf0cc2ec381bf" translate="yes" xml:space="preserve">
          <source>The keys in the bottom layer hash with the meanings of their values are:</source>
          <target state="translated">하단 레이어 해시의 키 값은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7d244bc64e243794d6821e1a0dcab4a24a9f05ad" translate="yes" xml:space="preserve">
          <source>The keys in the hash with the meanings of their values are:</source>
          <target state="translated">해시의 키 값은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b936421bf8217d2a23b78502c20a19e381f28f92" translate="yes" xml:space="preserve">
          <source>The keys of &lt;code&gt;%-&lt;/code&gt; -like hashes correspond to all buffer names found in the regular expression; the keys of &lt;code&gt;%+&lt;/code&gt; -like hashes list only the names of buffers that have captured (and that are thus associated to defined values).</source>
          <target state="translated">&lt;code&gt;%-&lt;/code&gt; -like 해시 의 키 는 정규식에서 찾은 모든 버퍼 이름에 해당합니다. &lt;code&gt;%+&lt;/code&gt; 와 유사한 해시 의 키 는 캡처 된 버퍼 이름 만 정의하므로 정의 된 값과 연결됩니다.</target>
        </trans-unit>
        <trans-unit id="997d8f5f7d84196f7ef0d41e7b97b099b732ef37" translate="yes" xml:space="preserve">
          <source>The keys of &lt;code&gt;%-&lt;/code&gt;-like hashes correspond to all buffer names found in the regular expression; the keys of &lt;code&gt;%+&lt;/code&gt;-like hashes list only the names of buffers that have captured (and that are thus associated to defined values).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="780fac85dedcdee4447dcad5c8a8d6b15a9a2af1" translate="yes" xml:space="preserve">
          <source>The keys of &lt;code&gt;provides&lt;/code&gt; are package names that can be found within the distribution. If a package name key is provided, it must have a Map with the following valid subkeys:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="108fc2066c755818e3590f4d9c35e36d3cb855db" translate="yes" xml:space="preserve">
          <source>The keys of the &lt;code&gt;%+&lt;/code&gt; hash list only the names of buffers that have captured (and that are thus associated to defined values).</source>
          <target state="translated">&lt;code&gt;%+&lt;/code&gt; 해시 의 키 는 캡처 된 (및 정의 된 값과 연관된) 버퍼 이름 만 나열합니다.</target>
        </trans-unit>
        <trans-unit id="c4094ef8d037d1a4f33eb2e2deddaec00fa1265e" translate="yes" xml:space="preserve">
          <source>The keys of the &lt;code&gt;%-&lt;/code&gt; hash correspond to all buffer names found in the regular expression.</source>
          <target state="translated">&lt;code&gt;%-&lt;/code&gt; 해시 의 키 는 정규식에서 찾은 모든 버퍼 이름에 해당합니다.</target>
        </trans-unit>
        <trans-unit id="cfdae1829d96426970bd25497a8e45b42e9a79f4" translate="yes" xml:space="preserve">
          <source>The keys of the hash will be the names of the entries in the directory. Reading a value from the hash will be the result of calling &lt;code&gt;File::stat::lstat&lt;/code&gt; . Deleting an element from the hash will delete the corresponding file or subdirectory, provided that &lt;code&gt;DIR_UNLINK&lt;/code&gt; is included in the &lt;code&gt;OPTIONS&lt;/code&gt; .</source>
          <target state="translated">해시의 키는 디렉토리의 항목 이름입니다. 해시에서 값을 읽으면 &lt;code&gt;File::stat::lstat&lt;/code&gt; 를 호출 한 결과입니다 . &lt;code&gt;DIR_UNLINK&lt;/code&gt; 가 &lt;code&gt;OPTIONS&lt;/code&gt; 에 포함되어 있으면 해시에서 요소를 삭제하면 해당 파일 또는 서브 디렉토리가 삭제됩니다 .</target>
        </trans-unit>
        <trans-unit id="7764c6575d016ad4721493c64443d8e32ddb0474" translate="yes" xml:space="preserve">
          <source>The keys of the hash will be the names of the entries in the directory. Reading a value from the hash will be the result of calling &lt;code&gt;File::stat::lstat&lt;/code&gt;. Deleting an element from the hash will delete the corresponding file or subdirectory, provided that &lt;code&gt;DIR_UNLINK&lt;/code&gt; is included in the &lt;code&gt;OPTIONS&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="055987f11411d4374756daa33a787f39e5c8e2e5" translate="yes" xml:space="preserve">
          <source>The keys of this hash are the names of all the known subroutines. Each value is an encoded string that has the sprintf(3) format &lt;code&gt;(&quot;%s:%d-%d&quot;, filename, fromline, toline)&lt;/code&gt; .</source>
          <target state="translated">이 해시의 키는 알려진 모든 서브 루틴의 이름입니다. 각 값은 sprintf (3) 형식 &lt;code&gt;(&quot;%s:%d-%d&quot;, filename, fromline, toline)&lt;/code&gt; 을 갖는 인코딩 된 문자열입니다 .</target>
        </trans-unit>
        <trans-unit id="99eed0ed09082d94a43f5eb252bf07930e49246a" translate="yes" xml:space="preserve">
          <source>The keys of this hash are the names of all the known subroutines. Each value is an encoded string that has the sprintf(3) format &lt;code&gt;(&quot;%s:%d-%d&quot;, filename, fromline, toline)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3904530800da7eda131d2f33bddbe47a09140ae0" translate="yes" xml:space="preserve">
          <source>The kind of computer you&amp;rsquo;re working on, where one &amp;ldquo;kind of computer&amp;rdquo; means all those computers sharing a compatible machine language. Since Perl programs are (typically) simple text files, not executable images, a Perl program is much less sensitive to the architecture it&amp;rsquo;s running on than programs in other languages, such as C, that are &lt;b&gt;compiled&lt;/b&gt; into machine code. See also &lt;b&gt;platform&lt;/b&gt; and &lt;b&gt;operating system&lt;/b&gt;.</source>
          <target state="translated">&quot;컴퓨터 종류&quot;중 하나는 호환되는 컴퓨터 언어를 공유하는 모든 컴퓨터를 의미합니다. Perl 프로그램은 실행 가능한 이미지가 아닌 (일반적으로) 간단한 텍스트 파일이기 때문에 Perl 프로그램은 머신 코드로 &lt;b&gt;컴파일 된&lt;/b&gt; C와 같은 다른 언어의 프로그램보다 실행중인 아키텍처에 훨씬 덜 민감 합니다. &lt;b&gt;플랫폼&lt;/b&gt; 및 &lt;b&gt;운영 체제를&lt;/b&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="af5d08a24c9445659f44e97ac90d397b8dd843c2" translate="yes" xml:space="preserve">
          <source>The known import symbols are the &lt;code&gt;:gzip_external&lt;/code&gt; , &lt;code&gt;:gzip_read_open&lt;/code&gt; , and &lt;code&gt;:gzip_write_open&lt;/code&gt; . Anything else is not recognized.</source>
          <target state="translated">알려진 가져 오기 기호는 &lt;code&gt;:gzip_external&lt;/code&gt; , &lt;code&gt;:gzip_read_open&lt;/code&gt; 및 &lt;code&gt;:gzip_write_open&lt;/code&gt; 입니다. 다른 것은 인식되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f60d39e599c1ed70fbcd2d9685b7a2c305ef74b7" translate="yes" xml:space="preserve">
          <source>The known import symbols are the &lt;code&gt;:gzip_external&lt;/code&gt;, &lt;code&gt;:gzip_read_open&lt;/code&gt;, and &lt;code&gt;:gzip_write_open&lt;/code&gt;. Anything else is not recognized.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ad665994ad3405e05efc579c556de49d4423595" translate="yes" xml:space="preserve">
          <source>The label of the statement or block the OP is the start of, if any.</source>
          <target state="translated">명세서의 레이블 또는 OP가 시작되는 블록을 차단합니다.</target>
        </trans-unit>
        <trans-unit id="147bc8ea909cecad4fb730859bb2907f9623910d" translate="yes" xml:space="preserve">
          <source>The lack of processing of &lt;code&gt;\\&lt;/code&gt; creates specific restrictions on the post-processed text. If the delimiter is &lt;code&gt;/&lt;/code&gt;, one cannot get the combination &lt;code&gt;\/&lt;/code&gt; into the result of this step. &lt;code&gt;/&lt;/code&gt; will finish the regular expression, &lt;code&gt;\/&lt;/code&gt; will be stripped to &lt;code&gt;/&lt;/code&gt; on the previous step, and &lt;code&gt;\\/&lt;/code&gt; will be left as is. Because &lt;code&gt;/&lt;/code&gt; is equivalent to &lt;code&gt;\/&lt;/code&gt; inside a regular expression, this does not matter unless the delimiter happens to be character special to the RE engine, such as in &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s*foo*bar*&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m[foo]&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;?foo?&lt;/code&gt; ; or an alphanumeric char, as in:</source>
          <target state="translated">&lt;code&gt;\\&lt;/code&gt; 처리가 부족 하면 사후 처리 된 텍스트에 특정 제한이 생깁니다. 분리 문자가 &lt;code&gt;/&lt;/code&gt; 이면 이 단계의 결과로 &lt;code&gt;\/&lt;/code&gt; 조합을 얻을 수 없습니다 . &lt;code&gt;/&lt;/code&gt; 는 정규식을 끝내고 &lt;code&gt;\/&lt;/code&gt; 는 이전 단계에서 &lt;code&gt;/&lt;/code&gt; 로 제거 되고 &lt;code&gt;\\/&lt;/code&gt; 는 그대로 남아 있습니다. 때문에 &lt;code&gt;/&lt;/code&gt; 이 동등에 &lt;code&gt;\/&lt;/code&gt; 구분 기호는에서와 같이, RE 엔진에 문자 특별 될 일이없는 한 정규 표현식 내에서,이 문제가되지 않습니다 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s*foo*bar*&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m[foo]&lt;/a&gt;&lt;/code&gt; , 또는 &lt;code&gt;?foo?&lt;/code&gt; ; 또는 다음과 같이 영숫자 문자</target>
        </trans-unit>
        <trans-unit id="552da7166581dad2c401fcf7fae959ad601a8345" translate="yes" xml:space="preserve">
          <source>The lack of processing of &lt;code&gt;\\&lt;/code&gt; creates specific restrictions on the post-processed text. If the delimiter is &lt;code&gt;/&lt;/code&gt;, one cannot get the combination &lt;code&gt;\/&lt;/code&gt; into the result of this step. &lt;code&gt;/&lt;/code&gt; will finish the regular expression, &lt;code&gt;\/&lt;/code&gt; will be stripped to &lt;code&gt;/&lt;/code&gt; on the previous step, and &lt;code&gt;\\/&lt;/code&gt; will be left as is. Because &lt;code&gt;/&lt;/code&gt; is equivalent to &lt;code&gt;\/&lt;/code&gt; inside a regular expression, this does not matter unless the delimiter happens to be character special to the RE engine, such as in &lt;code&gt;s*foo*bar*&lt;/code&gt;, &lt;code&gt;m[foo]&lt;/code&gt;, or &lt;code&gt;m?foo?&lt;/code&gt;; or an alphanumeric char, as in:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6cc7f7d746e559a86f68b3adb7a4d97f4b51af95" translate="yes" xml:space="preserve">
          <source>The langinfo() function is just a wrapper for the C nl_langinfo() interface.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d11a57a26c23b0ae665c99897a59d6791986dbc2" translate="yes" xml:space="preserve">
          <source>The langinfo() function queries various locale information that can be used to localize output and user interfaces. It uses the current underlying locale, regardless of whether or not it was called from within the scope of &lt;code&gt;use locale&lt;/code&gt;. The langinfo() function requires one numeric argument that identifies the locale constant to query: if no argument is supplied, &lt;code&gt;$_&lt;/code&gt; is used. The numeric constants appropriate to be used as arguments are exportable from I18N::Langinfo.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="329bfa336d3d2c69ff7cf1363d051c82b14482d1" translate="yes" xml:space="preserve">
          <source>The langinfo() function queries various locale information that can be used to localize output and user interfaces. The langinfo() requires one numeric argument that identifies the locale constant to query: if no argument is supplied, &lt;code&gt;$_&lt;/code&gt; is used. The numeric constants appropriate to be used as arguments are exportable from I18N::Langinfo.</source>
          <target state="translated">langinfo () 함수는 출력 및 사용자 인터페이스를 지역화하는 데 사용할 수있는 다양한 로케일 정보를 조회합니다. langinfo ()에는 쿼리 할 로캘 상수를 식별하는 하나의 숫자 인수가 필요합니다. 인수가 제공되지 않으면 &lt;code&gt;$_&lt;/code&gt; 가 사용됩니다. 인수로 사용하기에 적합한 숫자 상수는 I18N :: Langinfo에서 내보낼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4ed86afb0e8b9f19c52713fc505ca8e2e35f2532" translate="yes" xml:space="preserve">
          <source>The langinfo() is just a wrapper for the C nl_langinfo() interface.</source>
          <target state="translated">langinfo ()는 C nl_langinfo () 인터페이스의 래퍼 일뿐입니다.</target>
        </trans-unit>
        <trans-unit id="5d6f822e607c368c541adb8e9be9fa017016c7dd" translate="yes" xml:space="preserve">
          <source>The language is intended to be practical (easy to use, efficient, complete) rather than beautiful (tiny, elegant, minimal). It combines (in the author's opinion, anyway) some of the best features of &lt;b&gt;sed&lt;/b&gt;, &lt;b&gt;awk&lt;/b&gt;, and &lt;b&gt;sh&lt;/b&gt;, making it familiar and easy to use for Unix users to whip up quick solutions to annoying problems. Its general-purpose programming facilities support procedural, functional, and object-oriented programming paradigms, making Perl a comfortable language for the long haul on major projects, whatever your bent.</source>
          <target state="translated">이 언어는 아름답고 (작고, 우아하며, 최소한) 실제적이지 않고 (사용하기 쉽고, 효율적이며, 완전하게) 사용됩니다. 어쨌든 &lt;b&gt;sed&lt;/b&gt; , &lt;b&gt;awk&lt;/b&gt; 및 &lt;b&gt;sh&lt;/b&gt; 의 최고의 기능 중 일부를 작성하여 (유익한 의견으로) Unix 사용자가 성가신 문제에 대한 빠른 해결책을 쉽게 익힐 수 있습니다. 범용 프로그래밍 기능은 절차 적, 기능적, 객체 지향 프로그래밍 패러다임을 지원하므로 Perl은 구부러진 주요 프로젝트에서 장거리 여행을위한 편안한 언어가됩니다.</target>
        </trans-unit>
        <trans-unit id="80a9351ce80597f624479310f1723e625f630d11" translate="yes" xml:space="preserve">
          <source>The language is intended to be practical (easy to use, efficient, complete) rather than beautiful (tiny, elegant, minimal). Its major features are that it's easy to use, supports both procedural and object-oriented (OO) programming, has powerful built-in support for text processing, and has one of the world's most impressive collections of third-party modules.</source>
          <target state="translated">이 언어는 아름답고 (작고, 우아하며, 최소한) 실제적이지 않고 (사용하기 쉽고, 효율적이며, 완전하게) 사용됩니다. 주요 기능은 사용하기 쉽고 절차 적 및 객체 지향 (OO) 프로그래밍을 모두 지원하며 텍스트 처리를위한 강력한 내장 지원 기능을 갖추고 있으며 세계에서 가장 인상적인 타사 모듈 모음 중 하나입니다.</target>
        </trans-unit>
        <trans-unit id="80efcc67009b4f458fbcd0e166207fe80337c34a" translate="yes" xml:space="preserve">
          <source>The language used is chosen from the loc_lang call. If a lookup is not possible, the i-default language will be used. If the lookup is not in the i-default language, then the key will be returned.</source>
          <target state="translated">사용 된 언어는 loc_lang 호출에서 선택됩니다. 조회가 불가능하면 i- 기본 언어가 사용됩니다. 조회가 i- 기본 언어가 아닌 경우 키가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="fba6e11da7ba55d0215680ecc246683e4db3e510" translate="yes" xml:space="preserve">
          <source>The large file compilation environment is obtained with</source>
          <target state="translated">큰 파일 컴파일 환경은</target>
        </trans-unit>
        <trans-unit id="9d7ccfee30c3456085edda4007d3ffab9032209b" translate="yes" xml:space="preserve">
          <source>The largest acceptable code point is the Unicode maximum 0x10FFFF, and must not be a surrogate nor a non-character code point. Thus this excludes any code point from Perl's extended UTF-8.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b0842cd9650e7d459b2b787beb02fa153564ea6" translate="yes" xml:space="preserve">
          <source>The largest acceptable code point is the Unicode maximum 0x10FFFF. This differs from &lt;code&gt;&lt;a href=&quot;#isSTRICT_UTF8_CHAR&quot;&gt;&quot;isSTRICT_UTF8_CHAR&quot;&lt;/a&gt;&lt;/code&gt; only in that it accepts non-character code points. This corresponds to &lt;a href=&quot;http://www.unicode.org/versions/corrigendum9.html&quot;&gt;Unicode Corrigendum #9&lt;/a&gt;. which said that non-character code points are merely discouraged rather than completely forbidden in open interchange. See &lt;a href=&quot;perlunicode#Noncharacter-code-points&quot;&gt;&quot;Noncharacter code points&quot; in perlunicode&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c14ad6f7057f3647ab0ef224e2d72569a519808" translate="yes" xml:space="preserve">
          <source>The largest code point that is representable in UTF-EBCDIC is U+7FFF_FFFF. If you do &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr()&lt;/a&gt;&lt;/code&gt; on a larger value, a runtime error (similar to division by 0) will happen.</source>
          <target state="translated">UTF-EBCDIC에서 표시 할 수있는 가장 큰 코드 포인트는 U + 7FFF_FFFF입니다. 더 큰 값에서 &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr()&lt;/a&gt;&lt;/code&gt; 을 수행 하면 런타임 오류 (0으로 나누기와 유사한)가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="81c48ef57866e1c8154c2bdc64ad152dcbc81938" translate="yes" xml:space="preserve">
          <source>The largest code point that is representable in UTF-EBCDIC is U+7FFF_FFFF. If you try to pack a larger value into a character, a runtime error (similar to division by 0) will happen.</source>
          <target state="translated">UTF-EBCDIC에서 표시 할 수있는 가장 큰 코드 포인트는 U + 7FFF_FFFF입니다. 더 큰 값을 문자로 묶으려고하면 런타임 오류 (0으로 나누기와 비슷한)가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="e2cfb7719205bc05d873fbbc8977b16754d06f9e" translate="yes" xml:space="preserve">
          <source>The last &lt;b&gt;filehandle&lt;/b&gt; that was designated with &lt;code&gt;&lt;a href=&quot;functions/select&quot;&gt;select(FILEHANDLE)&lt;/a&gt;&lt;/code&gt;; &lt;code&gt;STDOUT&lt;/code&gt; , if no filehandle has been selected.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/select&quot;&gt;select(FILEHANDLE)&lt;/a&gt;&lt;/code&gt; ; 로 지정된 마지막 &lt;b&gt;파일 핸들&lt;/b&gt; ; 파일 핸들이 선택되지 않은 경우 &lt;code&gt;STDOUT&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3778b44d76009b0ef5e1852751bc0831ec54a4e5" translate="yes" xml:space="preserve">
          <source>The last &lt;b&gt;filehandle&lt;/b&gt; that was designated with &lt;code&gt;select(FILEHANDLE)&lt;/code&gt;; &lt;code&gt;STDOUT&lt;/code&gt;, if no filehandle has been selected.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b37441ece1fc3c98a0c6e1bb548dacae86d8fdd9" translate="yes" xml:space="preserve">
          <source>The last and final version of PA-RISC is 2.0, HP no longer sells any system with these CPU's.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="544feb1340389177d3430ba94574fe7a8a59484b" translate="yes" xml:space="preserve">
          <source>The last argument is always considered to be the file portion. Since &lt;code&gt;catfile()&lt;/code&gt; uses &lt;code&gt;catdir()&lt;/code&gt; (see above) for the concatenation of the directory portions (if any), the following with regard to relative and absolute paths is true:</source>
          <target state="translated">마지막 인수는 항상 파일 부분으로 간주됩니다. 이후 &lt;code&gt;catfile()&lt;/code&gt; 사용 &lt;code&gt;catdir()&lt;/code&gt; 디렉토리 부의 연접 (있는 경우), 상대 및 절대 경로와 관련하여 다음에 해당하는 경우 (상기 참조) :</target>
        </trans-unit>
        <trans-unit id="3d5ec4d10744144f22c4f4ea812b28436c8dedd9" translate="yes" xml:space="preserve">
          <source>The last example illustrates another feature of threads. You can spawn off several threads using the same subroutine. Each thread executes the same subroutine, but in a separate thread with a separate environment and potentially separate arguments.</source>
          <target state="translated">마지막 예는 스레드의 다른 기능을 보여줍니다. 동일한 서브 루틴을 사용하여 여러 스레드를 생성 할 수 있습니다. 각 스레드는 동일한 서브 루틴을 실행하지만 별도의 환경과 잠재적으로 별도의 인수가있는 별도의 스레드에서 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="3a9ec3805e1d8d03ada9f35c7b038f53ba566eb8" translate="yes" xml:space="preserve">
          <source>The last example is very slow and outputs extra progress indicators that break the alignment of the result.</source>
          <target state="translated">마지막 예제는 매우 느리고 결과의 정렬을 깨뜨리는 추가 진행 표시기를 출력합니다.</target>
        </trans-unit>
        <trans-unit id="d7140144abdabb3a340f6e7a9626f45a3f6e90a9" translate="yes" xml:space="preserve">
          <source>The last example points out that character classes are like alternations of characters. At a given character position, the first alternative that allows the regexp match to succeed will be the one that matches.</source>
          <target state="translated">마지막 예는 문자 클래스가 문자의 교대와 유사하다는 것을 나타냅니다. 주어진 문자 위치에서 정규 표현식 일치를 허용하는 첫 번째 대안은 일치하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="8ff092050a74224fa6cfcc69192829226bfd39ef" translate="yes" xml:space="preserve">
          <source>The last example should print:</source>
          <target state="translated">마지막 예는 다음을 인쇄해야합니다.</target>
        </trans-unit>
        <trans-unit id="d1b1f35817845b0ebf71ac4a0203b5b76bf2839d" translate="yes" xml:space="preserve">
          <source>The last example shows a match with an &lt;code&gt;'i'&lt;/code&gt;&lt;b&gt;modifier&lt;/b&gt;, which makes the match case-insensitive.</source>
          <target state="translated">마지막 예는 &lt;code&gt;'i'&lt;/code&gt; &lt;b&gt;수정 자&lt;/b&gt; 와의 일치를 보여 주므로 대소 문자를 구분하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e71d02e5faff1a1d5185411ef0df70f32d8f6d20" translate="yes" xml:space="preserve">
          <source>The last example shows that &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt; can use other delimiters, such as &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s!!!&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s{}{}&lt;/a&gt;&lt;/code&gt;, and even &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s{}//&lt;/a&gt;&lt;/code&gt;. If single quotes are used &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s'''&lt;/a&gt;&lt;/code&gt;, then the regex and replacement are treated as single-quoted strings.</source>
          <target state="translated">마지막 예를 보여줍니다 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt; 같은 다른 구분 기호를 사용할 수 있습니다 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s!!!&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s{}{}&lt;/a&gt;&lt;/code&gt; 및 심지어 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s{}//&lt;/a&gt;&lt;/code&gt; . 작은 따옴표가 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s'''&lt;/a&gt;&lt;/code&gt; 인 경우 정규 표현식과 대체는 작은 따옴표로 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="1c93c3433d587d711bbae225f518d07bf79a7bfc" translate="yes" xml:space="preserve">
          <source>The last example shows that &lt;code&gt;s///&lt;/code&gt; can use other delimiters, such as &lt;code&gt;s!!!&lt;/code&gt; and &lt;code&gt;s{}{}&lt;/code&gt;, and even &lt;code&gt;s{}//&lt;/code&gt;. If single quotes are used &lt;code&gt;s'''&lt;/code&gt;, then the regex and replacement are treated as single-quoted strings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="301cab1c29ad0c90c0fe8b5c51d14a74f03d135a" translate="yes" xml:space="preserve">
          <source>The last form sets the error returned by future calls to &lt;code&gt;fileLastError()&lt;/code&gt; and should not be used often. &lt;code&gt;$uError&lt;/code&gt; must be a numeric error code. Also returns the dual-valued version of &lt;code&gt;$uError&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38175234fbd8da1fcb9cc33577b554c9cf1a8cdf" translate="yes" xml:space="preserve">
          <source>The last four modifiers listed above, added in Perl 5.14, control the character set rules, but &lt;code&gt;/a&lt;/code&gt; is the only one you are likely to want to specify explicitly; the other three are selected automatically by various pragmas.</source>
          <target state="translated">Perl 5.14에 추가 된 위에 나열된 마지막 네 개의 수정자는 문자 세트 규칙을 제어하지만 &lt;code&gt;/a&lt;/code&gt; 는 명시 적으로 지정하려는 유일한 것입니다. 다른 세 개는 다양한 pragma에 의해 자동으로 선택됩니다.</target>
        </trans-unit>
        <trans-unit id="5b14495e6536f39321b81d2ad45a9b35a4c183b7" translate="yes" xml:space="preserve">
          <source>The last is particularly useful because it knows about machine-dependent architectures. The &lt;code&gt;lib.pm&lt;/code&gt; pragmatic module was first included with the 5.002 release of Perl.</source>
          <target state="translated">마지막은 머신 ​​종속 아키텍처에 대해 알고 있기 때문에 특히 유용합니다. &lt;code&gt;lib.pm&lt;/code&gt; 실용적인 모듈은 첫번째 펄의 5.002 릴리스에 포함되었다.</target>
        </trans-unit>
        <trans-unit id="dee33a8bbee7fed8c390da45a40b2881511f80ec" translate="yes" xml:space="preserve">
          <source>The last item listed (SUNWhea in this example) is the package you need.</source>
          <target state="translated">나열된 마지막 항목 (이 예에서는 SUNWhea)이 필요한 패키지입니다.</target>
        </trans-unit>
        <trans-unit id="249e46d8e31e329b6f35d0380e06e9e88206bbb4" translate="yes" xml:space="preserve">
          <source>The last order date for HP 9000 systems was December 31, 2008.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01f01afddbe80c4c268f0bac95652fd735743f86" translate="yes" xml:space="preserve">
          <source>The last rites performed by a parent &lt;b&gt;process&lt;/b&gt; on behalf of a deceased child process so that it doesn&amp;rsquo;t remain a &lt;b&gt;zombie&lt;/b&gt;. See the &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/waitpid&quot;&gt;waitpid&lt;/a&gt;&lt;/code&gt; function calls.</source>
          <target state="translated">죽은 자식 프로세스를 대신하여 부모 &lt;b&gt;프로세스가&lt;/b&gt; 수행 한 마지막 의식 은 &lt;b&gt;좀비로&lt;/b&gt; 남아 있지 않습니다 . &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;functions/waitpid&quot;&gt;waitpid&lt;/a&gt;&lt;/code&gt; 함수 호출을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="57c0ac80818903e3f90bc72e811a2effb575b793" translate="yes" xml:space="preserve">
          <source>The last rites performed by a parent &lt;b&gt;process&lt;/b&gt; on behalf of a deceased child process so that it doesn&amp;rsquo;t remain a &lt;b&gt;zombie&lt;/b&gt;. See the &lt;code&gt;wait&lt;/code&gt; and &lt;code&gt;waitpid&lt;/code&gt; function calls.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6fc5a9dc56cbe77d2375a5e43361dd33676d7edc" translate="yes" xml:space="preserve">
          <source>The last three slots are a recent addition, and for source code compatibility they are only checked for if one of the three flags MGf_COPY, MGf_DUP or MGf_LOCAL is set in mg_flags. This means that most code can continue declaring a vtable as a 5-element value. These three are currently used exclusively by the threading code, and are highly subject to change.</source>
          <target state="translated">마지막 3 개의 슬롯은 최근에 추가 된 것이므로 소스 코드 호환성을 위해 3 개의 플래그 MGf_COPY, MGf_DUP 또는 MGf_LOCAL 중 하나가 mg_flags에 설정된 경우에만 확인됩니다. 이것은 대부분의 코드가 vtable을 5 요소 값으로 계속 선언 할 수 있음을 의미합니다. 이 세 가지는 현재 스레딩 코드에서만 사용되며 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0f2130944a7df2b125d5d6b5739b2f67242c3907" translate="yes" xml:space="preserve">
          <source>The last time the test program passed, in seconds from the epoch.</source>
          <target state="translated">테스트 프로그램이 마지막으로 경과 한 시간 (초).</target>
        </trans-unit>
        <trans-unit id="21878c9b3f2934bab56f2ab1ab4a5f355bfffef3" translate="yes" xml:space="preserve">
          <source>The last time the test suite failed, in seconds from the epoch.</source>
          <target state="translated">신기원에서 초 단위로 테스트 스위트가 실패한 시간.</target>
        </trans-unit>
        <trans-unit id="c8d2323b355b183370e8260c625d724458199602" translate="yes" xml:space="preserve">
          <source>The last topic of Part 1 briefly covers how regexps are used in Perl programs. Where do they fit into Perl syntax?</source>
          <target state="translated">Part 1의 마지막 주제는 정규 표현식이 Perl 프로그램에서 사용되는 방법을 간략하게 설명합니다. 그것들은 어디에 Perl 문법에 맞습니까?</target>
        </trans-unit>
        <trans-unit id="b9c1bf499a546862f7d3dd462a65d36e8e01021a" translate="yes" xml:space="preserve">
          <source>The last two are a little tricky. In &lt;code&gt;[\$x]&lt;/code&gt; , the backslash protects the dollar sign, so the character class has two members &lt;code&gt;$&lt;/code&gt; and &lt;code&gt;x&lt;/code&gt; . In &lt;code&gt;[\\$x]&lt;/code&gt; , the backslash is protected, so &lt;code&gt;$x&lt;/code&gt; is treated as a variable and substituted in double quote fashion.</source>
          <target state="translated">마지막 두 개는 조금 까다 롭습니다. 에서 &lt;code&gt;[\$x]&lt;/code&gt; 문자 클래스는 두 멤버가 있으므로, 백 슬래시, 달러 기호를 보호 &lt;code&gt;$&lt;/code&gt; 와 &lt;code&gt;x&lt;/code&gt; . 에서는 &lt;code&gt;[\\$x]&lt;/code&gt; , 백 슬래시가 보호되므로 &lt;code&gt;$x&lt;/code&gt; 변수로서 취급되고, 따옴표 방식으로 치환.</target>
        </trans-unit>
        <trans-unit id="8da4297e9e11b0bed733e96e0a5ce5a0d837c05e" translate="yes" xml:space="preserve">
          <source>The last two are a little tricky. In &lt;code&gt;[\$x]&lt;/code&gt;, the backslash protects the dollar sign, so the character class has two members &lt;code&gt;'$'&lt;/code&gt; and &lt;code&gt;'x'&lt;/code&gt;. In &lt;code&gt;[\\$x]&lt;/code&gt;, the backslash is protected, so &lt;code&gt;$x&lt;/code&gt; is treated as a variable and substituted in double quote fashion.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a00c9f7ecacbf4d6fa87dfc5eecfd61397b17fd" translate="yes" xml:space="preserve">
          <source>The last two constructs may appear unintuitive to most people. The first repeatedly grows a string, whereas the second allocates a large chunk of memory in one go. On some systems, the second is more efficient than the first.</source>
          <target state="translated">마지막 두 구성은 대부분의 사람들에게 직관적이지 않은 것처럼 보일 수 있습니다. 첫 번째는 문자열을 반복적으로 증가시키는 반면, 두 번째는 한 번에 많은 양의 메모리를 할당합니다. 일부 시스템에서는 두 번째 시스템이 첫 번째 시스템보다 효율적입니다.</target>
        </trans-unit>
        <trans-unit id="701c321a0a2054ebe884423f3ddbe3fca4e7d084" translate="yes" xml:space="preserve">
          <source>The last two examples in each block show the pipe as &quot;list form&quot;, which is not yet supported on all platforms. (If your platform has a real &lt;a href=&quot;#fork&quot;&gt;&lt;code&gt;fork&lt;/code&gt;&lt;/a&gt;, such as Linux and macOS, you can use the list form; it also works on Windows with Perl 5.22 or later.) You would want to use the list form of the pipe so you can pass literal arguments to the command without risk of the shell interpreting any shell metacharacters in them. However, this also bars you from opening pipes to commands that intentionally contain shell metacharacters, such as:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a3180c758450e8b48f9775fac7e74a8e6da633b" translate="yes" xml:space="preserve">
          <source>The last two examples in each block show the pipe as &quot;list form&quot;, which is not yet supported on all platforms. A good rule of thumb is that if your platform has a real &lt;code&gt;&lt;a href=&quot;fork&quot;&gt;fork()&lt;/a&gt;&lt;/code&gt; (in other words, if your platform is Unix, including Linux and MacOS X), you can use the list form. You would want to use the list form of the pipe so you can pass literal arguments to the command without risk of the shell interpreting any shell metacharacters in them. However, this also bars you from opening pipes to commands that intentionally contain shell metacharacters, such as:</source>
          <target state="translated">각 블록의 마지막 두 예는 파이프를 &quot;목록 형식&quot;으로 표시하며 일부 플랫폼에서는 아직 지원되지 않습니다. 일반적으로 플랫폼에 실제 &lt;code&gt;&lt;a href=&quot;fork&quot;&gt;fork()&lt;/a&gt;&lt;/code&gt; 가있는 경우 (즉, 플랫폼이 Linux 및 MacOS X를 포함하여 Unix 인 경우) 목록 양식을 사용할 수 있습니다. 파이프의 목록 형식을 사용하여 쉘에서 쉘 메타 문자를 해석하지 않고 리터럴 인수를 명령에 전달할 수 있습니다. 그러나 이것은 파이프 열기에서 의도적으로 쉘 메타 문자를 포함하는 명령으로 바뀝니다.</target>
        </trans-unit>
        <trans-unit id="224277da0631dd2948d98eac0e58b508ae236071" translate="yes" xml:space="preserve">
          <source>The last two examples in each block show the pipe as &quot;list form&quot;, which is not yet supported on all platforms. A good rule of thumb is that if your platform has a real &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork()&lt;/a&gt;&lt;/code&gt; (in other words, if your platform is Unix, including Linux and MacOS X), you can use the list form. You would want to use the list form of the pipe so you can pass literal arguments to the command without risk of the shell interpreting any shell metacharacters in them. However, this also bars you from opening pipes to commands that intentionally contain shell metacharacters, such as:</source>
          <target state="translated">각 블록의 마지막 두 예는 파이프를 &quot;목록 형식&quot;으로 표시하며 일부 플랫폼에서는 아직 지원되지 않습니다. 일반적으로 플랫폼에 실제 &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork()&lt;/a&gt;&lt;/code&gt; 가있는 경우 (즉, 플랫폼이 Linux 및 MacOS X를 포함하여 Unix 인 경우) 목록 양식을 사용할 수 있습니다. 파이프의 목록 형식을 사용하여 쉘에서 쉘 메타 문자를 해석하지 않고 리터럴 인수를 명령에 전달할 수 있습니다. 그러나 이것은 파이프 열기에서 의도적으로 쉘 메타 문자를 포함하는 명령으로 바뀝니다.</target>
        </trans-unit>
        <trans-unit id="bb538ba5316dfdb33cebda21455c3214d556eb70" translate="yes" xml:space="preserve">
          <source>The last two were added in Perl 5.22.</source>
          <target state="translated">마지막 두 개는 Perl 5.22에 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="631d7a78fc9992a33bb8f42345d827210e402509" translate="yes" xml:space="preserve">
          <source>The last type of L structure is for links to/within Pod documents. It is the most complex because it can have a</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea40dd6a00c5982372bccbdaaeeb63948e0cf1b4" translate="yes" xml:space="preserve">
          <source>The later gives you some idea of what failed. It also makes it easier to find the test in your script, simply search for &quot;simple exponential&quot;.</source>
          <target state="translated">후자는 실패한 것에 대한 아이디어를 제공합니다. 또한 스크립트에서 테스트를보다 쉽게 ​​찾을 수 있도록 &quot;간단 지수&quot;를 검색하기 만하면됩니다.</target>
        </trans-unit>
        <trans-unit id="263e6dbf8c2da6cc4831ea57d73cd01c49808e34" translate="yes" xml:space="preserve">
          <source>The latest</source>
          <target state="translated">최신</target>
        </trans-unit>
        <trans-unit id="d3a60275112428b3ca0987c2c55a45bca5bde073" translate="yes" xml:space="preserve">
          <source>The latest Net::Ping release can be found at CPAN:</source>
          <target state="translated">최신 Net :: Ping 릴리스는 CPAN에서 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7b2e54c1e5a52bb047587bf92489f8f96027d992" translate="yes" xml:space="preserve">
          <source>The latest Net::Ping releases are included in cperl and perl5.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="874b36774125604150e5f59fd5253e7e8be8da9e" translate="yes" xml:space="preserve">
          <source>The latest Perl release (5.22.0 as of this writing) builds without changes under all versions of Mac OS X from 10.3 &quot;Panther&quot; onwards.</source>
          <target state="translated">최신 Perl 릴리즈 (이 글을 쓰는 시점에서 5.22.0)는 10.3 &quot;Panther&quot;이후의 모든 Mac OS X 버전에서 변경없이 빌드됩니다.</target>
        </trans-unit>
        <trans-unit id="064e946234db5ecc10d952d435ad39de892add96" translate="yes" xml:space="preserve">
          <source>The latest Perl release (5.32.0 as of this writing) builds without changes under all versions of Mac OS X from 10.3 &quot;Panther&quot; onwards.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="adfa4e030032052fa74752414fc7476dcdaf2c76" translate="yes" xml:space="preserve">
          <source>The latest libnet release is always on CPAN, you will find it in</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="abc4f25838809cd7645317e2cc9e7753babbc628" translate="yes" xml:space="preserve">
          <source>The latest source tree is available via cvs:</source>
          <target state="translated">최신 소스 트리는 cvs를 통해 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3373e831da21b443a04c03079b0c28bf4785000a" translate="yes" xml:space="preserve">
          <source>The latest source tree is available via git:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf89850a166f6a4ee0978de00ea5e89c74558d84" translate="yes" xml:space="preserve">
          <source>The latest versions are probably the least deployed and widely tested, so you may want to wait a few months after their release and see what problems others have if you are risk averse.</source>
          <target state="translated">최신 버전은 배포가 가장 적고 널리 테스트 된 것일 수 있으므로 릴리스 후 몇 개월을 기다렸다가 위험에 처한 경우 다른 문제가 있는지 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="283b07d7f4b68277645e0b52df897e2c505c20d3" translate="yes" xml:space="preserve">
          <source>The latest versions of perl have more bug fixes.</source>
          <target state="translated">최신 버전의 perl에는 더 많은 버그 수정이 있습니다.</target>
        </trans-unit>
        <trans-unit id="5c3562f1019a54d151d180b0074eac428ec1b539" translate="yes" xml:space="preserve">
          <source>The latest versions of perl may contain performance improvements and features not present in older versions. There have been many changes in perl since perl5 was first introduced.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1651bfa501667c3bfa8d542631578218de1ab189" translate="yes" xml:space="preserve">
          <source>The latter is equivalent to</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d373e425dea350cf42b44329f2372765cae74bb5" translate="yes" xml:space="preserve">
          <source>The latter pattern would be a character class consisting of a colon, and the letters &lt;code&gt;a&lt;/code&gt; , &lt;code&gt;l&lt;/code&gt; , &lt;code&gt;p&lt;/code&gt; and &lt;code&gt;h&lt;/code&gt; .</source>
          <target state="translated">후자의 패턴은 콜론과 문자 &lt;code&gt;a&lt;/code&gt; , &lt;code&gt;l&lt;/code&gt; , &lt;code&gt;p&lt;/code&gt; 및 &lt;code&gt;h&lt;/code&gt; 로 구성된 문자 클래스 입니다.</target>
        </trans-unit>
        <trans-unit id="9695d45b272c946f52b02905e21523ca5bea55db" translate="yes" xml:space="preserve">
          <source>The latter pattern would be a character class consisting of a colon, and the letters &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;l&lt;/code&gt;, &lt;code&gt;p&lt;/code&gt; and &lt;code&gt;h&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44e4aff4d2758e888da3bc5afffc2587abdc395f" translate="yes" xml:space="preserve">
          <source>The lax criteria corresponds to what is currently allowed by the version parser. All of the following formats are acceptable for dotted-decimal formats strings:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a94f6519fd2ea2b5da884bb4c80f8058226b090" translate="yes" xml:space="preserve">
          <source>The layer is acceptable to have in a binmode(FH) stack - i.e. it does not (or will configure itself not to) transform bytes passing through it.</source>
          <target state="translated">이 계층은 binmode (FH) 스택에 포함 할 수 있습니다. 즉,이를 통과하는 바이트를 변환하지 않습니다 (또는 자체적으로 구성하지 않음).</target>
        </trans-unit>
        <trans-unit id="1281105f1d2923419cef70eff9c7bbaca9c31ca4" translate="yes" xml:space="preserve">
          <source>The layer is buffered.</source>
          <target state="translated">레이어가 버퍼링됩니다.</target>
        </trans-unit>
        <trans-unit id="aa6e981b462c3b07834414b5da8720376a618be1" translate="yes" xml:space="preserve">
          <source>The layers are returned in the order an open() or binmode() call would use them, and without colons.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2977795d28c25d6eee9e0faa6c0a67b12612914" translate="yes" xml:space="preserve">
          <source>The layers are returned in the order an open() or binmode() call would use them. Note that the &quot;default stack&quot; depends on the operating system and on the Perl version, and both the compile-time and runtime configurations of Perl.</source>
          <target state="translated">레이어는 open () 또는 binmode () 호출에서 사용하는 순서대로 반환됩니다. &quot;기본 스택&quot;은 운영 체제 및 Perl 버전 및 Perl의 컴파일 타임 및 런타임 구성에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="b3e7d5b78b27ea298f2a1cae1408ae86359ba800" translate="yes" xml:space="preserve">
          <source>The lddlflags addition is the only abnormal bit.</source>
          <target state="translated">lddlflags 덧셈은 유일한 비정상 비트입니다.</target>
        </trans-unit>
        <trans-unit id="7eced80f21a0420b25c8520fadd19d07b97b6f61" translate="yes" xml:space="preserve">
          <source>The leading 'v' is optional if two or more decimals appear. If only a single decimal is included, then the leading 'v' is required to trigger the dotted-decimal parsing. A leading zero is permitted, though not recommended except when quoted, because of the risk that Perl will treat the number as octal. A trailing underscore plus one or more digits denotes an alpha or development release (and must be quoted to be parsed properly).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eff5a5e9eacb7b6806eb625ddd8923ff29d2efc5" translate="yes" xml:space="preserve">
          <source>The leading &lt;code&gt;+{&lt;/code&gt; and &lt;code&gt;{;&lt;/code&gt; always serve to disambiguate the expression to mean either the HASH reference, or the BLOCK.</source>
          <target state="translated">최고의 &lt;code&gt;+{&lt;/code&gt; 와 &lt;code&gt;{;&lt;/code&gt; 항상 해시 참조 또는 블록을 의미하도록 표현을 명확하게하는 역할을합니다.</target>
        </trans-unit>
        <trans-unit id="d4369969cfc835357a0f9f590f26252ba7f58c0e" translate="yes" xml:space="preserve">
          <source>The left hand side of the method invocation (or arrow) operator is the object (or class name), and the right hand side is the method name.</source>
          <target state="translated">메소드 호출 (또는 화살표) 연산자의 왼쪽은 오브젝트 (또는 클래스 이름)이고 오른쪽은 메소드 이름입니다.</target>
        </trans-unit>
        <trans-unit id="2a9cac37843dad5a4ff70fbd9f8ea25d75266dcb" translate="yes" xml:space="preserve">
          <source>The left side of the arrow can be any expression returning a reference, including a previous dereference. Note that &lt;code&gt;$array[$x]&lt;/code&gt; is</source>
          <target state="translated">화살표의 왼쪽은 이전 역 참조를 포함하여 참조를 리턴하는 표현식 일 수 있습니다. 참고 &lt;code&gt;$array[$x]&lt;/code&gt; 있다</target>
        </trans-unit>
        <trans-unit id="eb221cc92a9038eecac3c016886c94b3bdd80217" translate="yes" xml:space="preserve">
          <source>The left-hand character up there indicates the context in which the function was called, with &lt;code&gt;$&lt;/code&gt; and &lt;code&gt;@&lt;/code&gt; meaning scalar or list contexts respectively, and &lt;code&gt;.&lt;/code&gt; meaning void context (which is actually a sort of scalar context). The display above says that you were in the function &lt;code&gt;main::infested&lt;/code&gt; when you ran the stack dump, and that it was called in scalar context from line 10 of the file</source>
          <target state="translated">왼쪽의 문자는 함수가 호출 된 컨텍스트를 나타내며, &lt;code&gt;$&lt;/code&gt; 및 &lt;code&gt;@&lt;/code&gt; 는 각각 스칼라 또는 목록 컨텍스트를 의미하고 및를 나타냅니다 &lt;code&gt;.&lt;/code&gt; void context (실제로 스칼라 컨텍스트의 일종)를 의미합니다. 위의 디스플레이 는 스택 덤프를 실행할 때 &lt;code&gt;main::infested&lt;/code&gt; 함수에 있었고 파일의 10 행에서 스칼라 컨텍스트로 호출되었다고 말합니다.</target>
        </trans-unit>
        <trans-unit id="d8cc674eda9906f58ae8371f8d5de07f046d9b51" translate="yes" xml:space="preserve">
          <source>The leftmost delimiter beginning the argument text to the interior sequence (should be &quot;&amp;lt;&quot;).</source>
          <target state="translated">내부 텍스트에서 인수 텍스트를 시작하는 가장 왼쪽 구분 기호 ( &quot;&amp;lt;&quot;여야 함)</target>
        </trans-unit>
        <trans-unit id="fbadd9b1973b1ad2d4e5362cd034946bff294cd7" translate="yes" xml:space="preserve">
          <source>The length [in bytes] of the section to be formatted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2f9e2e6c56a351b6a88108f75341c9d329b9f6c" translate="yes" xml:space="preserve">
          <source>The length at which the argument list is truncated is governed by the next option:</source>
          <target state="translated">인수 목록이 잘리는 길이는 다음 옵션에 의해 결정됩니다.</target>
        </trans-unit>
        <trans-unit id="0c237bc1e8c7da08e4bc9cf58175d51b2735fd6c" translate="yes" xml:space="preserve">
          <source>The length of an array is a scalar value. You may find the length of array @days by evaluating &lt;code&gt;$#days&lt;/code&gt; , as in &lt;b&gt;csh&lt;/b&gt;. However, this isn't the length of the array; it's the subscript of the last element, which is a different value since there is ordinarily a 0th element. Assigning to &lt;code&gt;$#days&lt;/code&gt; actually changes the length of the array. Shortening an array this way destroys intervening values. Lengthening an array that was previously shortened does not recover values that were in those elements.</source>
          <target state="translated">배열의 길이는 스칼라 값입니다. &lt;b&gt;csh&lt;/b&gt; 에서처럼 &lt;code&gt;$#days&lt;/code&gt; days를 평가하여 @days 배열의 길이를 찾을 수 있습니다 . 그러나 이것은 배열의 길이가 아닙니다. 마지막 요소의 첨자입니다. 일반적으로 0 번째 요소가 있기 때문에 다른 값입니다. &lt;code&gt;$#days&lt;/code&gt; 에 할당하면 실제로 배열의 길이가 변경됩니다. 이런 식으로 배열을 줄이면 값이 잘리지 않습니다. 이전에 단축 된 배열을 늘려도 해당 요소에 있던 값은 복구되지 않습니다.&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="f563a4457c7ea4c783229c274409e5e0accbf6ff" translate="yes" xml:space="preserve">
          <source>The length of an array is a scalar value. You may find the length of array @days by evaluating &lt;code&gt;$#days&lt;/code&gt;, as in &lt;b&gt;csh&lt;/b&gt;. However, this isn't the length of the array; it's the subscript of the last element, which is a different value since there is ordinarily a 0th element. Assigning to &lt;code&gt;$#days&lt;/code&gt; actually changes the length of the array. Shortening an array this way destroys intervening values. Lengthening an array that was previously shortened does not recover values that were in those elements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4741e016ab3bf497ce5ef4aff13131c47a360d63" translate="yes" xml:space="preserve">
          <source>The length of the field is supplied by padding out the field with multiple &quot;&amp;lt;&quot;, &quot;&amp;gt;&quot;, or &quot;|&quot; characters to specify a non-numeric field with, respectively, left justification, right justification, or centering. For a regular field, the value (up to the first newline) is taken and printed according to the selected justification, truncating excess characters. If you terminate a text field with &quot;...&quot;, three dots will be shown if the value is truncated. A special text field may be used to do rudimentary multi-line text block filling; see &lt;a href=&quot;#Using-Fill-Mode&quot;&gt;&quot;Using Fill Mode&quot;&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1ef5c234e3b75bc352e3b032ce59b9fa1929612" translate="yes" xml:space="preserve">
          <source>The length of the field is supplied by padding out the field with multiple &quot;&amp;lt;&quot;, &quot;&amp;gt;&quot;, or &quot;|&quot; characters to specify a non-numeric field with, respectively, left justification, right justification, or centering. For a regular field, the value (up to the first newline) is taken and printed according to the selected justification, truncating excess characters. If you terminate a text field with &quot;...&quot;, three dots will be shown if the value is truncated. A special text field may be used to do rudimentary multi-line text block filling; see &lt;a href=&quot;#Using-Fill-Mode&quot;&gt;Using Fill Mode&lt;/a&gt; for details.</source>
          <target state="translated">필드의 길이는 여러 개의 &quot;&amp;lt;&quot;, &quot;&amp;gt;&quot;또는 &quot;|&quot;로 필드를 채워서 제공됩니다. 왼쪽 자리 맞추기, 오른쪽 자리 맞추기 또는 가운데 맞춤을 사용하여 숫자가 아닌 필드를 지정하는 문자 일반 필드의 경우 값 (첫 번째 줄 바꿈까지)이 선택한 자리 맞추기에 따라 값을 가져와 인쇄하여 초과 문자를 자릅니다. &quot;...&quot;로 텍스트 필드를 종료하면 값이 잘 리면 3 개의 점이 표시됩니다. 초보적인 여러 줄로 된 텍스트 블록 채우기를 위해 특수 텍스트 필드를 사용할 수 있습니다. 자세한 내용은 &lt;a href=&quot;#Using-Fill-Mode&quot;&gt;채우기 모드 사용&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="531fdf3344d9288341eaab36c6e742e75614f35e" translate="yes" xml:space="preserve">
          <source>The length of the filed in hex.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01b66a1a14f6dce4bff1a210ef4e586716a5899b" translate="yes" xml:space="preserve">
          <source>The length of the name.</source>
          <target state="translated">이름의 길이입니다.</target>
        </trans-unit>
        <trans-unit id="696a9e70beeee9b566eace1cd87208a1d5c5089e" translate="yes" xml:space="preserve">
          <source>The length(NAME) Keyword</source>
          <target state="translated">길이 (NAME) 키워드</target>
        </trans-unit>
        <trans-unit id="b958bd03a02b517c3d184dfcfbefe403cc86c37f" translate="yes" xml:space="preserve">
          <source>The level can be changed as follows:</source>
          <target state="translated">레벨은 다음과 같이 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="64e6e89b4814ce7405192ddfc665d5e521c03538" translate="yes" xml:space="preserve">
          <source>The level constants are not exported by the module.</source>
          <target state="translated">레벨 상수는 모듈에서 내 보내지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b4c1d901146534759d309f43fe1b8efda46ffa76" translate="yes" xml:space="preserve">
          <source>The level of detail in Perl module documentation generally goes from less detailed to more detailed. Your SYNOPSIS section should contain a minimal example of use (perhaps as little as one line of code; skip the unusual use cases or anything not needed by most users); the DESCRIPTION should describe your module in broad terms, generally in just a few paragraphs; more detail of the module's routines or methods, lengthy code examples, or other in-depth material should be given in subsequent sections.</source>
          <target state="translated">Perl 모듈 문서의 세부 사항 레벨은 일반적으로 덜 자세하고 더 자세합니다. SYNOPSIS 섹션에는 최소한의 사용 예가 포함되어 있어야합니다 (한 줄의 코드만으로도 가능합니다. 비정상적인 사용 사례 나 대부분의 사용자에게 필요하지 않은 것은 생략). DESCRIPTION은 일반적으로 몇 단락으로 모듈을 광범위한 용어로 설명해야합니다. 모듈의 루틴이나 방법, 긴 코드 예제 또는 기타 심층 자료에 대한 자세한 내용은 다음 섹션에서 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="0ce002d9483143d05cc2ba45ea1b81cd48bfc336" translate="yes" xml:space="preserve">
          <source>The lexer can be bypassed as well by creating the pattern from smaller components:</source>
          <target state="translated">더 작은 구성 요소에서 패턴을 작성하여 어휘 분석기를 우회 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="dcb697055788c2e7dd63bc610ab1eb6ac51eb7cf" translate="yes" xml:space="preserve">
          <source>The lexer maintains various &lt;code&gt;char*&lt;/code&gt; pointers to things in the &lt;code&gt;PL_parser-&amp;gt;linestr&lt;/code&gt; buffer. If &lt;code&gt;PL_parser-&amp;gt;linestr&lt;/code&gt; is ever reallocated, all of these pointers must be updated. Don't attempt to do this manually, but rather use &lt;a href=&quot;#lex_grow_linestr&quot;&gt;&quot;lex_grow_linestr&quot;&lt;/a&gt; if you need to reallocate the buffer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23265d5a0661d902031b21a8d3925278347efe2b" translate="yes" xml:space="preserve">
          <source>The lexer maintains various &lt;code&gt;char*&lt;/code&gt; pointers to things in the &lt;code&gt;PL_parser-&amp;gt;linestr&lt;/code&gt; buffer. If &lt;code&gt;PL_parser-&amp;gt;linestr&lt;/code&gt; is ever reallocated, all of these pointers must be updated. Don't attempt to do this manually, but rather use &lt;a href=&quot;#lex_grow_linestr&quot;&gt;lex_grow_linestr&lt;/a&gt; if you need to reallocate the buffer.</source>
          <target state="translated">어휘 분석기 는 &lt;code&gt;PL_parser-&amp;gt;linestr&lt;/code&gt; 버퍼 에있는 것들에 대한 다양한 &lt;code&gt;char*&lt;/code&gt; 포인터를 유지 합니다. 경우 &lt;code&gt;PL_parser-&amp;gt;linestr&lt;/code&gt; 가 적 재 할당되고,이 포인터의 모든 업데이트해야합니다. 이 작업을 수동으로 시도하지 말고 버퍼를 재 할당해야하는 경우 &lt;a href=&quot;#lex_grow_linestr&quot;&gt;lex_grow_linestr을&lt;/a&gt; 사용 하십시오.</target>
        </trans-unit>
        <trans-unit id="1ed189d83743aeda186a080785030258aac3dd09" translate="yes" xml:space="preserve">
          <source>The libnetcfg utility can be used to configure the libnet. Starting from perl 5.8 libnet is part of the standard Perl distribution, but the libnetcfg can be used for any libnet installation.</source>
          <target state="translated">libnetcfg 유틸리티를 사용하여 libnet을 구성 할 수 있습니다. perl 5.8부터 libnet은 표준 Perl 배포의 일부이지만 libnetcfg는 모든 libnet 설치에 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b7cb7266f690af0bb383573e50d303e552d377e1" translate="yes" xml:space="preserve">
          <source>The libraries specified may be a mixture of static libraries and import libraries (to link with DLLs). Since both kinds are used pretty transparently on the Win32 platform, we do not attempt to distinguish between them.</source>
          <target state="translated">지정된 라이브러리는 정적 라이브러리와 가져 오기 라이브러리 (DLL과 링크하기 위해)를 혼합 한 것일 수 있습니다. 두 종류 모두 Win32 플랫폼에서 매우 투명하게 사용되기 때문에 두 종류를 구별하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="df259280ce53fd256ff55110ddf21cb58f64ee0c" translate="yes" xml:space="preserve">
          <source>The library that is loaded last is used. Note that this can be overwritten at any time by loading a different library, and numbers constructed with different libraries cannot be used in math operations together.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c99e76c717b720c6c49420484756d2dfcd410c40" translate="yes" xml:space="preserve">
          <source>The library that is loaded last will be used. Note that this can be overwritten at any time by loading a different library, and numbers constructed with different libraries cannot be used in math operations together.</source>
          <target state="translated">마지막으로로드 된 라이브러리가 사용됩니다. 다른 라이브러리를로드하여 언제든지 덮어 쓸 수 있으며 다른 라이브러리로 구성된 숫자는 수학 연산에서 함께 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="f52597109e4fab2376043609905f67d9e1da90d1" translate="yes" xml:space="preserve">
          <source>The license under which this distribution may be used and redistributed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7be37c25dc5d34ce7bba6cfdf56923967183a419" translate="yes" xml:space="preserve">
          <source>The licensing terms of your distribution. Generally it's &quot;perl_5&quot; for the same license as Perl itself.</source>
          <target state="translated">배포 라이센스 조건. 일반적으로 Perl과 동일한 라이센스의 경우 &quot;perl_5&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="ee54e36e284ff26a979d2076f6ca4023c3d73825" translate="yes" xml:space="preserve">
          <source>The line above describes the limits of buckets currently in use. Each bucket has two sizes: memory footprint and the maximal size of user data that can fit into this bucket. Suppose in the above example that the smallest bucket were size 4. The biggest bucket would have usable size 8188, and the memory footprint would be 8192.</source>
          <target state="translated">위의 줄은 현재 사용중인 버킷의 제한을 설명합니다. 각 버킷에는 메모리 공간과이 버킷에 맞는 최대 사용자 데이터 크기라는 두 가지 크기가 있습니다. 위의 예에서 가장 작은 버킷의 크기는 4라고 가정합니다. 가장 큰 버킷의 크기는 8188이고 메모리 사용량은 8192입니다.</target>
        </trans-unit>
        <trans-unit id="391452165da7e2f812078f7c3a4920d3947a871e" translate="yes" xml:space="preserve">
          <source>The line in &lt;code&gt;$E-&amp;gt;file&lt;/code&gt; where the exceptional code was called.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac97bcd51055b69e1b4470987fa154b899ce651a" translate="yes" xml:space="preserve">
          <source>The line number the error occurred in.</source>
          <target state="translated">오류가 발생한 줄 번호</target>
        </trans-unit>
        <trans-unit id="cc23ac8e14569b4b19694084670492ce2aa4a0c6" translate="yes" xml:space="preserve">
          <source>The line shown is the one that is about to be executed &lt;b&gt;next&lt;/b&gt;, it hasn't happened yet. So while we can print a variable with the letter '&lt;b&gt;p&lt;/b&gt;', at this point all we'd get is an empty (undefined) value back. What we need to do is to step through the next executable statement with an '&lt;b&gt;s&lt;/b&gt;':</source>
          <target state="translated">표시된 행은 &lt;b&gt;다음&lt;/b&gt; 에 실행될 &lt;b&gt;예정&lt;/b&gt; 이며 아직 발생하지 않았습니다. 따라서 문자 ' &lt;b&gt;p&lt;/b&gt; '를 사용하여 변수를 인쇄 할 수 있지만 이 시점에서 얻을 수있는 것은 빈 (정의되지 않은) 값입니다. 우리가해야 할 일은 ' &lt;b&gt;s&lt;/b&gt; '로 다음 실행 문을 단계별로 실행하는 것입니다 .</target>
        </trans-unit>
        <trans-unit id="e54713c2cd710c76f4d69536879402921ef82d04" translate="yes" xml:space="preserve">
          <source>The linearized MRO of a class is an ordered array of all of the classes one would search when resolving a method on that class, starting with the class itself.</source>
          <target state="translated">클래스의 선형화 된 MRO는 클래스 자체에서 시작하여 해당 클래스의 메소드를 해석 할 때 검색 할 모든 클래스의 정렬 된 배열입니다.</target>
        </trans-unit>
        <trans-unit id="f96ce0004635ab8058e21a997ff0fdcac4680ebd" translate="yes" xml:space="preserve">
          <source>The link found cannot be parsed because it does not conform to the syntax described in &lt;a href=&quot;../perlpod&quot;&gt;perlpod&lt;/a&gt;.</source>
          <target state="translated">발견 된 링크는 &lt;a href=&quot;../perlpod&quot;&gt;perlpod에&lt;/a&gt; 설명 된 구문을 따르지 않으므로 구문 분석 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="365c0989adb3aa2936b9a9b37c715ae0175f622e" translate="yes" xml:space="preserve">
          <source>The link-text. If there is none, this must be &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;. (E.g., in &quot;L&amp;lt;Perl Functions|perlfunc&amp;gt;&quot;, the link-text is &quot;Perl Functions&quot;. In &quot;L&amp;lt;Time::HiRes&amp;gt;&quot; and even &quot;L&amp;lt;|Time::HiRes&amp;gt;&quot;, there is no link text. Note that link text may contain formatting.)</source>
          <target state="translated">링크 텍스트 없는 경우 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 이어야합니다 . (예 : &quot;L &amp;lt;Perl Functions | perlfunc&amp;gt;&quot;에서 링크 텍스트는 &quot;Perl Functions&quot;입니다. &quot;L &amp;lt;Time :: HiRes&amp;gt;&quot;및 &quot;L &amp;lt;| Time :: HiRes&amp;gt;&quot;에는 없습니다. 링크 텍스트에는 서식이 포함될 수 있습니다.)</target>
        </trans-unit>
        <trans-unit id="02b503d2f0eeb8483755cc493aa85b3fc0ad66ce" translate="yes" xml:space="preserve">
          <source>The link-text. If there is none, this must be &lt;code&gt;undef&lt;/code&gt;. (E.g., in &quot;L&amp;lt;Perl Functions|perlfunc&amp;gt;&quot;, the link-text is &quot;Perl Functions&quot;. In &quot;L&amp;lt;Time::HiRes&amp;gt;&quot; and even &quot;L&amp;lt;|Time::HiRes&amp;gt;&quot;, there is no link text. Note that link text may contain formatting.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d43c6585f184d3f50d1ee9b3f3e7c9226f529c8c" translate="yes" xml:space="preserve">
          <source>The list becomes the default for</source>
          <target state="translated">목록이 기본값이됩니다.</target>
        </trans-unit>
        <trans-unit id="3deb5bdbb77dae94d3dcc1cd91998f32e0e38f14" translate="yes" xml:space="preserve">
          <source>The list in the second argument means:</source>
          <target state="translated">두 번째 인수의 목록은 다음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="e1406e4b9186eac7ca74cdee5b539fc3d6f09c6c" translate="yes" xml:space="preserve">
          <source>The list may well be incomplete, or even wrong in some places. When in doubt, consult the platform-specific README files in the Perl source distribution, and any other documentation resources accompanying a given port.</source>
          <target state="translated">일부 장소에서는 목록이 불완전하거나 잘못되었을 수 있습니다. 확실하지 않은 경우 Perl 소스 배포판의 플랫폼 별 README 파일 및 지정된 포트와 함께 제공되는 기타 설명서 리소스를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="47c47cf18ff1538b7e1e7d5d97838485842b3427" translate="yes" xml:space="preserve">
          <source>The list of &lt;b&gt;directories&lt;/b&gt; the system searches to find a program you want to &lt;b&gt;execute&lt;/b&gt;. The list is stored as one of your &lt;b&gt;environment variables&lt;/b&gt;, accessible in Perl as &lt;code&gt;$ENV{PATH}&lt;/code&gt; .</source>
          <target state="translated">시스템이 &lt;b&gt;실행&lt;/b&gt; 하려는 프로그램을 찾기 위해 검색하는 &lt;b&gt;디렉토리&lt;/b&gt; 목록 . 이 목록은 Perl에서 &lt;code&gt;$ENV{PATH}&lt;/code&gt; 로 액세스 할 수있는 &lt;b&gt;환경 변수&lt;/b&gt; 중 하나로 저장됩니다 .&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="38740fd91fca4080ce68cbb1a2be0d91acbe5b88" translate="yes" xml:space="preserve">
          <source>The list of &lt;b&gt;directories&lt;/b&gt; the system searches to find a program you want to &lt;b&gt;execute&lt;/b&gt;. The list is stored as one of your &lt;b&gt;environment variables&lt;/b&gt;, accessible in Perl as &lt;code&gt;$ENV{PATH}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b24d146d5dbad44a8c4fe5e7cb3811111eac143" translate="yes" xml:space="preserve">
          <source>The list of characters within the character class gives the set of characters matched by the class. &lt;code&gt;&quot;[abc]&quot;&lt;/code&gt; matches a single &quot;a&quot; or &quot;b&quot; or &quot;c&quot;. But if the first character after the &lt;code&gt;&quot;[&quot;&lt;/code&gt; is &lt;code&gt;&quot;^&quot;&lt;/code&gt;, the class instead matches any character not in the list. Within a list, the &lt;code&gt;&quot;-&quot;&lt;/code&gt; character specifies a range of characters, so that &lt;code&gt;a-z&lt;/code&gt; represents all characters between &quot;a&quot; and &quot;z&quot;, inclusive. If you want either &lt;code&gt;&quot;-&quot;&lt;/code&gt; or &lt;code&gt;&quot;]&quot;&lt;/code&gt; itself to be a member of a class, put it at the start of the list (possibly after a &lt;code&gt;&quot;^&quot;&lt;/code&gt;), or escape it with a backslash. &lt;code&gt;&quot;-&quot;&lt;/code&gt; is also taken literally when it is at the end of the list, just before the closing &lt;code&gt;&quot;]&quot;&lt;/code&gt;. (The following all specify the same class of three characters: &lt;code&gt;[-az]&lt;/code&gt;, &lt;code&gt;[az-]&lt;/code&gt;, and &lt;code&gt;[a\-z]&lt;/code&gt;. All are different from &lt;code&gt;[a-z]&lt;/code&gt;, which specifies a class containing twenty-six characters, even on EBCDIC-based character sets.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="880294bb5af5ca3525238395f901655f64c2020a" translate="yes" xml:space="preserve">
          <source>The list of functions supported by this module.</source>
          <target state="translated">이 모듈이 지원하는 기능 목록.</target>
        </trans-unit>
        <trans-unit id="77160ea4e8b3bcdfb5681dd2b39ffff26dc948b8" translate="yes" xml:space="preserve">
          <source>The list of functions that will need to recompiled is: creat, fgetpos, fopen, freopen, fsetpos, fstat, fstatvfs, fstatvfsdev, ftruncate, ftw, lockf, lseek, lstat, mmap, nftw, open, prealloc, stat, statvfs, statvfsdev, tmpfile, truncate, getrlimit, setrlimit</source>
          <target state="translated">다시 컴파일해야 할 함수 목록은 creat, fgetpos, fopen, freopen, fsetpos, fstat, fstatvfs, fstatvfsdev, ftruncate, ftw, lockf, lseek, lstat, mmap, nftw, open, prealloc, stat, statvfs, statvfsdev입니다. , tmpfile, 잘라 내기, getrlimit, setrlimit</target>
        </trans-unit>
        <trans-unit id="0ece79552d7d2f7d04e0b952118b609964429027" translate="yes" xml:space="preserve">
          <source>The list of libraries needed by Perl only (any libraries needed by extensions only will by dropped, if using dynamic loading).</source>
          <target state="translated">Perl 만 필요한 라이브러리 목록 (동적 로딩을 사용하는 경우 확장에 필요한 모든 라이브러리 만 삭제됨).</target>
        </trans-unit>
        <trans-unit id="8a88dc253dbf62089f3cd58a095e24a1f2508bc5" translate="yes" xml:space="preserve">
          <source>The list of macro definitions to be passed through must be specified using the /MACRO qualifier and must not add another /DEFINE qualifier. We prepend our own comma here to the contents of $(PASTHRU_DEFINE) because it is often empty and a comma always present in CCFLAGS would generate a missing qualifier value error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e64ca6ece649f2cd25525c8ae9c0d312fa7bfc44" translate="yes" xml:space="preserve">
          <source>The list of moderators will be public knowledge. At present, it is: Aaron Crane, Andy Dougherty, Ricardo Signes, Steffen M&amp;uuml;ller.</source>
          <target state="translated">중재자 목록은 공개 지식이됩니다. 현재는 Aaron Crane, Andy Dougherty, Ricardo Signes, Steffen M&amp;uuml;ller입니다.</target>
        </trans-unit>
        <trans-unit id="78f6263b45ee82cd9e1bdb24d318e0dddc31338c" translate="yes" xml:space="preserve">
          <source>The list of moderators will be public knowledge. At present, it is: Andy Dougherty, Karen Etheridge, Ricardo Signes, Sawyer X, Steffen M&amp;uuml;ller, Todd Rinaldo, Aaron Crane.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1addfaddfdb521f7b3277e8c72cb79cc08f13e02" translate="yes" xml:space="preserve">
          <source>The list of output parameters occurs at the very end of the function, just after the OUTPUT: directive. The use of RETVAL tells Perl that you wish to send this value back as the return value of the XSUB function. In Example 3, we wanted the &quot;return value&quot; placed in the original variable which we passed in, so we listed it (and not RETVAL) in the OUTPUT: section.</source>
          <target state="translated">출력 매개 변수 목록은 함수의 마지막에서 OUTPUT : 지시문 바로 다음에 발생합니다. RETVAL을 사용하면 Perl에게이 값을 XSUB 함수의 리턴 값으로 다시 보내려고합니다. 예제 3에서는 전달한 원래 변수에 &quot;반환 값&quot;을 배치하려고하므로 OUTPUT : 섹션에 RETVAL이 아닌 RETVAL이 나열되었습니다.</target>
        </trans-unit>
        <trans-unit id="2539fe270e83e959d35fc853744365007ae544d9" translate="yes" xml:space="preserve">
          <source>The list of subfields can be supplied in any of the following formats</source>
          <target state="translated">서브 필드 목록은 다음 형식 중 하나로 제공 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e16fd393ccc48ed4253b4ef65eb2fcd167d75fd6" translate="yes" xml:space="preserve">
          <source>The list of symbols for the iterator is assembled by spawning off a subprocess, which can be slow. Ideally, we should just traverse the process' symbol table directly from C.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cbcba41fba02d24fea6ac236d8112cd5b98ebb87" translate="yes" xml:space="preserve">
          <source>The list of the registered CPAN sites follows. Please note that the sorting order is alphabetical on fields:</source>
          <target state="translated">등록 된 CPAN 사이트 목록은 다음과 같습니다. 정렬 순서는 필드에서 알파벳순입니다.</target>
        </trans-unit>
        <trans-unit id="e411ef2006039baaa3efb0aa87f085a254587fe2" translate="yes" xml:space="preserve">
          <source>The list of the valid options is shown below. Options not specified will remain unchanged.</source>
          <target state="translated">유효한 옵션 목록은 다음과 같습니다. 지정되지 않은 옵션은 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="cca90ac8d52c301adc0df9b517c693dc0133a8b6" translate="yes" xml:space="preserve">
          <source>The list opened with &lt;code&gt;=over&lt;/code&gt; does not contain any items.</source>
          <target state="translated">&lt;code&gt;=over&lt;/code&gt; 로 열린 목록 에는 항목이 없습니다.</target>
        </trans-unit>
        <trans-unit id="4d086b1f033b01df712b5de461a87fac4f3a292c" translate="yes" xml:space="preserve">
          <source>The list opened with &lt;code&gt;=over&lt;/code&gt; does not contain anything.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37870cad335f71a8db1ccbfc9f539b9f8492c3a2" translate="yes" xml:space="preserve">
          <source>The list reference contains one or more strings specifying patterns that are</source>
          <target state="translated">리스트 참조는 다음과 같은 패턴을 지정하는 하나 이상의 문자열을 포함합니다.</target>
        </trans-unit>
        <trans-unit id="7ecd93d98b44cbb94ca7891c2599a20dc8e75287" translate="yes" xml:space="preserve">
          <source>The list reference contains one or more strings specifying patterns that must</source>
          <target state="translated">목록 참조는 반드시 패턴을 지정하는 하나 이상의 문자열을 포함합니다.</target>
        </trans-unit>
        <trans-unit id="0da38439f7a00ec9abb7cd8b98624a8251f6fb80" translate="yes" xml:space="preserve">
          <source>The listing below is alphabetical, case insensitive.</source>
          <target state="translated">아래 목록은 알파벳 순서이며 대소 문자를 구분하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="768abd184089ae969a2334570319327e5afad505" translate="yes" xml:space="preserve">
          <source>The listing looks something like this:</source>
          <target state="translated">목록은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a6fd74766ba848460935d167a256b131af8e02ea" translate="yes" xml:space="preserve">
          <source>The lists are ordered (roughly) so the most preferred names come before less preferred ones.</source>
          <target state="translated">목록은 (거의) 순서가 정해 지므로 가장 선호되는 이름이 덜 선호되는 이름 앞에옵니다.</target>
        </trans-unit>
        <trans-unit id="c3448e4c57076d015f65b6c72251baf22ba5950b" translate="yes" xml:space="preserve">
          <source>The literal string in the regex can be replaced by a variable:</source>
          <target state="translated">정규식의 리터럴 문자열은 변수로 대체 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9605e010408c59883a845d8cc68911d04aa028cd" translate="yes" xml:space="preserve">
          <source>The literal string in the regexp can be replaced by a variable:</source>
          <target state="translated">regexp의 리터럴 문자열은 변수로 대체 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cc87d2f061afcaaa2771f59160c4bc3540da65d9" translate="yes" xml:space="preserve">
          <source>The literal string to be output. If it starts with a number and an optional '*' then the padding will be increased by an amount relative to this number, if the '*' is present then this amount will be multiplied by $cnt. This part of $string is removed before output/</source>
          <target state="translated">출력 할 리터럴 문자열. 숫자로 시작하고 선택적인 '*'로 시작하면 패딩에이 숫자에 비해 금액이 증가합니다. '*'가 있으면이 금액에 $ cnt가 곱해집니다. $ string의이 부분은 출력 /</target>
        </trans-unit>
        <trans-unit id="67b8f203dc692021f65103823771254ae8d76d5b" translate="yes" xml:space="preserve">
          <source>The literals that are converted are &lt;code&gt;q//, qq//, qr//, qw///, qx//&lt;/code&gt; , and starting in v5.8.1, &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr///&lt;/a&gt;&lt;/code&gt;. Operations that do conversions include &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/ord&quot;&gt;ord&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;utf8::upgrade&lt;/code&gt; (but not &lt;code&gt;utf8::downgrade&lt;/code&gt; ), and &lt;code&gt;&lt;a href=&quot;functions/chomp&quot;&gt;chomp&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">변환되는 리터럴은 &lt;code&gt;q//, qq//, qr//, qw///, qx//&lt;/code&gt; 이며 v5.8.1, &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr///&lt;/a&gt;&lt;/code&gt; 시작 합니다. 변환을 수행하는 연산에는 &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/ord&quot;&gt;ord&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;utf8::upgrade&lt;/code&gt; ( &lt;code&gt;utf8::downgrade&lt;/code&gt; 아님) 및 &lt;code&gt;&lt;a href=&quot;functions/chomp&quot;&gt;chomp&lt;/a&gt;&lt;/code&gt; 가 포함 됩니다.</target>
        </trans-unit>
        <trans-unit id="116243fae422285ef1d7be17ca7bca8fa87732c6" translate="yes" xml:space="preserve">
          <source>The literals that are converted are &lt;code&gt;q//, qq//, qr//, qw///, qx//&lt;/code&gt;, and starting in v5.8.1, &lt;code&gt;tr///&lt;/code&gt;. Operations that do conversions include &lt;code&gt;chr&lt;/code&gt;, &lt;code&gt;ord&lt;/code&gt;, &lt;code&gt;utf8::upgrade&lt;/code&gt; (but not &lt;code&gt;utf8::downgrade&lt;/code&gt;), and &lt;code&gt;chomp&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dba36a88aebe7e92337b13757f05491149d1212d" translate="yes" xml:space="preserve">
          <source>The little number the &lt;b&gt;operating system&lt;/b&gt; uses to keep track of which opened &lt;b&gt;file&lt;/b&gt; you&amp;rsquo;re talking about. Perl hides the file descriptor inside a &lt;b&gt;standard I/O&lt;/b&gt; stream and then attaches the stream to a &lt;b&gt;filehandle&lt;/b&gt;.</source>
          <target state="translated">&lt;b&gt;운영 체제에서&lt;/b&gt; 말하는 열린 &lt;b&gt;파일&lt;/b&gt; 을 추적하는 데 사용하는 작은 숫자 입니다. Perl은 &lt;b&gt;표준 I / O&lt;/b&gt; 스트림 내부에서 파일 디스크립터를 숨기고 스트림을&lt;b&gt; 파일 핸들에&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="c45e18376e8b086f8c631b86953dc61fd730ab6e" translate="yes" xml:space="preserve">
          <source>The load function that dl_load_file() calls may require an absolute pathname. The dl_findfile() function and @dl_library_path can be used to search for and return the absolute pathname for the library/object that you wish to load.</source>
          <target state="translated">dl_load_file ()이 호출하는로드 함수에는 절대 경로 이름이 필요할 수 있습니다. dl_findfile () 함수 및 @dl_library_path를 사용하여로드하려는 라이브러리 / 객체의 절대 경로 이름을 검색하고 반환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8c46c2259b1d6fa0f7f68fad81b43f4cfbd94e4d" translate="yes" xml:space="preserve">
          <source>The loaded modules are IO::Handle, IO::Seekable, IO::File, IO::Pipe, IO::Socket, IO::Dir. You should instead explicitly import the IO modules you want.</source>
          <target state="translated">로드 된 모듈은 IO :: Handle, IO :: Seekable, IO :: File, IO :: Pipe, IO :: Socket, IO :: Dir입니다. 대신 원하는 IO 모듈을 명시 적으로 가져와야합니다.</target>
        </trans-unit>
        <trans-unit id="0917a1903587e2d522edafea1a2d6e66a9118a13" translate="yes" xml:space="preserve">
          <source>The local() generated a compile-time error because you just touched a global name without fully qualifying it.</source>
          <target state="translated">전역 이름을 완전히 규정하지 않고 만지므로 local ()에서 컴파일 타임 오류를 생성했습니다.</target>
        </trans-unit>
        <trans-unit id="0cf7efcc5129f771b3d1f0dd51149aa0de4647fc" translate="yes" xml:space="preserve">
          <source>The localeconv function</source>
          <target state="translated">localeconv 기능</target>
        </trans-unit>
        <trans-unit id="ba0cd5497a3f02564f53cc5f3cb0a7c74904a185" translate="yes" xml:space="preserve">
          <source>The locking technique went like this.</source>
          <target state="translated">잠금 기술은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6e5d8b4586e8d6172f220183afe910608a1d8583" translate="yes" xml:space="preserve">
          <source>The log level to use, with either the embedded, minimal logger or &lt;a href=&quot;Log::Log4perl&quot;&gt;Log::Log4perl&lt;/a&gt; if it is installed. Possible values are the same as the &lt;code&gt;Log::Log4perl&lt;/code&gt; levels: &lt;code&gt;TRACE&lt;/code&gt;, &lt;code&gt;DEBUG&lt;/code&gt;, &lt;code&gt;INFO&lt;/code&gt;, &lt;code&gt;WARN&lt;/code&gt;, &lt;code&gt;ERROR&lt;/code&gt;, and &lt;code&gt;FATAL&lt;/code&gt;. The default is &lt;code&gt;INFO&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb02723b6a87664f1d9c172d5d68ee624445a8a4" translate="yes" xml:space="preserve">
          <source>The logarithm of the Gamma function [C99].</source>
          <target state="translated">감마 함수의 로그 [C99].</target>
        </trans-unit>
        <trans-unit id="12f81008559a10138f818056ec245c593a6400e5" translate="yes" xml:space="preserve">
          <source>The logic of &lt;code&gt;:locale&lt;/code&gt; is described in full in &lt;a href=&quot;encoding&quot;&gt;encoding&lt;/a&gt;, but in short it is first trying nl_langinfo(CODESET) and then guessing from the LC_ALL and LANG locale environment variables.</source>
          <target state="translated">&lt;code&gt;:locale&lt;/code&gt; 의 논리는 다음 에 자세히 설명되어 있습니다.&lt;a href=&quot;encoding&quot;&gt; encoding에&lt;/a&gt; 있지만 간단히 nl_langinfo (CODESET)를 시도한 다음 LC_ALL 및 LANG 로케일 환경 변수를 추측합니다.</target>
        </trans-unit>
        <trans-unit id="788028f7f75ce2d23138d44a065abd859dafb9ea" translate="yes" xml:space="preserve">
          <source>The logic of &lt;code&gt;:locale&lt;/code&gt; is described in full in &lt;a href=&quot;encoding#The-%3Alocale-sub-pragma&quot;&gt;&quot;The &lt;code&gt;:locale&lt;/code&gt; sub-pragma&quot; in encoding&lt;/a&gt;, but in short it is first trying nl_langinfo(CODESET) and then guessing from the LC_ALL and LANG locale environment variables. &lt;code&gt;:locale&lt;/code&gt; also implicitly turns on &lt;code&gt;:std&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf878ca097d48d543ea19885a2629244c15e1017" translate="yes" xml:space="preserve">
          <source>The logic of finding which locale &lt;code&gt;:locale&lt;/code&gt; uses is as follows:</source>
          <target state="translated">어떤 로케일을 찾는 논리 &lt;code&gt;:locale&lt;/code&gt; 사용 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="49964803a05917808abe031a83a5e6119fc9d862" translate="yes" xml:space="preserve">
          <source>The lone dot that ends a format can also prematurely end a mail message passing through a misconfigured Internet mailer (and based on experience, such misconfiguration is the rule, not the exception). So when sending format code through mail, you should indent it so that the format-ending dot is not on the left margin; this will prevent SMTP cutoff.</source>
          <target state="translated">형식을 끝내는 고독한 점은 잘못 구성된 인터넷 메일러를 통과하는 메일 메시지를 조기에 종료 할 수도 있습니다 (경험에 따라 이러한 잘못된 구성은 예외가 아닌 규칙입니다). 따라서 메일을 통해 형식 코드를 보낼 때는 형식 끝 점이 왼쪽 여백에 있지 않도록 들여 쓰기를해야합니다. 이렇게하면 SMTP 차단이 방지됩니다.</target>
        </trans-unit>
        <trans-unit id="23ac1b0fabb60338fc7595b94617767f0048e6fc" translate="yes" xml:space="preserve">
          <source>The lonesome dash</source>
          <target state="translated">외로운 대쉬</target>
        </trans-unit>
        <trans-unit id="58b8d17fbed51ef506dcc5bc2dfad68f8e405d89" translate="yes" xml:space="preserve">
          <source>The long answer is that &quot;it depends&quot;, and a good answer cannot be given without knowing (at the very least) the language context. See &lt;a href=&quot;Unicode::Collate&quot;&gt;Unicode::Collate&lt;/a&gt;, and</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8acab1ed969d76981aca60d63a3ad2f6189741fb" translate="yes" xml:space="preserve">
          <source>The long answer is that &quot;it depends&quot;, and a good answer cannot be given without knowing (at the very least) the language context. See &lt;a href=&quot;unicode/collate&quot;&gt;Unicode::Collate&lt;/a&gt;, and</source>
          <target state="translated">긴 대답은 &quot;그것에 달려있다&quot;는 것이며, (적어도) 언어 문맥을 알지 못하면 좋은 대답을 할 수 없습니다. 참조 &lt;a href=&quot;unicode/collate&quot;&gt;유니 코드 :: 부씩 인쇄를&lt;/a&gt; 하고,</target>
        </trans-unit>
        <trans-unit id="12b46ea21e617b9bac57234d9626d778dcbba94b" translate="yes" xml:space="preserve">
          <source>The long answer is that you need to consider character normalization and casing issues: see &lt;a href=&quot;Unicode::Normalize&quot;&gt;Unicode::Normalize&lt;/a&gt;, Unicode Technical Report #15, &lt;a href=&quot;https://www.unicode.org/unicode/reports/tr15&quot;&gt;Unicode Normalization Forms&lt;/a&gt; and sections on case mapping in the &lt;a href=&quot;https://www.unicode.org&quot;&gt;Unicode Standard&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b351929b2c368a051a670eae8fde3b6788ce75f" translate="yes" xml:space="preserve">
          <source>The long answer is that you need to consider character normalization and casing issues: see &lt;a href=&quot;unicode/normalize&quot;&gt;Unicode::Normalize&lt;/a&gt;, Unicode Technical Report #15, &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fwww.unicode.org%2funicode%2freports%2ftr15&quot;&gt;Unicode Normalization Forms&lt;/a&gt; and sections on case mapping in the &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fwww.unicode.org&quot;&gt;Unicode Standard&lt;/a&gt;.</source>
          <target state="translated">긴 대답은 문자 정규화 및 대소 문자 문제를 고려해야한다는 것입니다. &lt;a href=&quot;unicode/normalize&quot;&gt;Unicode :: Normalize&lt;/a&gt; , 유니 코드 기술 보고서 ​​# 15, &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fwww.unicode.org%2funicode%2freports%2ftr15&quot;&gt;유니 코드 표준화 양식&lt;/a&gt; 및 &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fwww.unicode.org&quot;&gt;유니 코드 표준의&lt;/a&gt; 사례 매핑 섹션을 참조하십시오. .</target>
        </trans-unit>
        <trans-unit id="b13e585010c555d0e300d8fe834b6f46a4ae81c6" translate="yes" xml:space="preserve">
          <source>The long answer is the rest of the manpage :-)</source>
          <target state="translated">긴 대답은 나머지 맨 페이지입니다 :-)</target>
        </trans-unit>
        <trans-unit id="31adae3a57b090c57ee3c7e6d1bf3e97b3bf17d2" translate="yes" xml:space="preserve">
          <source>The long name is returned in a form nicely capitalized, suitable for printing.</source>
          <target state="translated">긴 이름은 대문자로 잘 인쇄 된 형태로 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="3088cd686b7b7b0dbd27c6c1543c10f8e12363eb" translate="yes" xml:space="preserve">
          <source>The lookahead and lookbehind assertions are generalizations of the anchor concept. Lookahead and lookbehind are zero-width assertions that let us specify which characters we want to test for. The lookahead assertion is denoted by &lt;code&gt;(?=regexp)&lt;/code&gt; and the lookbehind assertion is denoted by &lt;code&gt;(?&amp;lt;=fixed-regexp)&lt;/code&gt;. Some examples are</source>
          <target state="translated">lookahead 및 lookbehind 어설 션은 앵커 개념의 일반화입니다. Lookahead와 Lookbehind는 테스트 할 문자를 지정할 수있는 폭이 0 인 어설 션입니다. 미리보기 어설 션은 &lt;code&gt;(?=regexp)&lt;/code&gt; 로 표시되고, 미리보기 어설 션은 &lt;code&gt;(?&amp;lt;=fixed-regexp)&lt;/code&gt; 로 표시됩니다. . 몇 가지 예는</target>
        </trans-unit>
        <trans-unit id="5683ae6515c38a0cd77c7a977d476fd0513aeaf5" translate="yes" xml:space="preserve">
          <source>The lookahead and lookbehind assertions are generalizations of the anchor concept. Lookahead and lookbehind are zero-width assertions that let us specify which characters we want to test for. The lookahead assertion is denoted by &lt;code&gt;(?=regexp)&lt;/code&gt; or (starting in 5.32, experimentally in 5.28) &lt;code&gt;(*pla:regexp)&lt;/code&gt; or &lt;code&gt;(*positive_lookahead:regexp)&lt;/code&gt;; and the lookbehind assertion is denoted by &lt;code&gt;(?&amp;lt;=fixed-regexp)&lt;/code&gt; or (starting in 5.32, experimentally in 5.28) &lt;code&gt;(*plb:fixed-regexp)&lt;/code&gt; or &lt;code&gt;(*positive_lookbehind:fixed-regexp)&lt;/code&gt;. Some examples are</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6f75c5b0c19aae838064eb95c9b0bb2969329be" translate="yes" xml:space="preserve">
          <source>The lookbehind &lt;code&gt;condition&lt;/code&gt; allows, along with backreferences, an earlier part of the match to influence a later part of the match. For instance,</source>
          <target state="translated">뒤돌아보기 &lt;code&gt;condition&lt;/code&gt; 은 역 참조와 함께 매치의 초기 부분이 매치의 후반부에 영향을 줄 수 있도록합니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="81e7a5f6a959e62bd2ce3d55576db8abdefeae7e" translate="yes" xml:space="preserve">
          <source>The loop will do the right thing for a while, but it will unexpectedly fail.</source>
          <target state="translated">루프는 잠시 동안 옳은 일을하지만 예기치 않게 실패합니다.</target>
        </trans-unit>
        <trans-unit id="45575ec17d57b6c0181a285166eef0dbc45075e3" translate="yes" xml:space="preserve">
          <source>The loop will never terminate.</source>
          <target state="translated">루프는 종료되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ef06996a2f846d6797b75f13080961cc1d5fe17b" translate="yes" xml:space="preserve">
          <source>The low levels of the stack work with the low-level operating system calls (file descriptors in C) getting bytes in and out, the higher layers of the stack buffer, filter, and otherwise manipulate the I/O, and return characters (or bytes) to Perl. Terms</source>
          <target state="translated">낮은 수준의 스택은 낮은 수준의 운영 체제 호출 (C의 파일 디스크립터)이 바이트를 가져오고 나가고, 스택 버퍼의 높은 계층은 I / O를 필터링 및 조작하고, 문자를 반환하고 (또는 바이트) 펄에. 자귀</target>
        </trans-unit>
        <trans-unit id="af589ba8a2b7e981d742f8a3045bf5151d26273f" translate="yes" xml:space="preserve">
          <source>The low-order 4 bytes of the total number of cylinders.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7dcd393353514c923ef3599ddd24840670260ada" translate="yes" xml:space="preserve">
          <source>The low-order and high-order [respectively] 4 bytes of the offset [in bytes] where the formatting should begin.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ebbaa8b5bbc22fc30de9a07ab039a1fa2504ddd5" translate="yes" xml:space="preserve">
          <source>The low-order and high-order [respectively] 4 bytes of the starting offset of the partition, measured in bytes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e618b44ecefc43c73cbcbb761a0be8756b4a11d0" translate="yes" xml:space="preserve">
          <source>The lower-level loops are</source>
          <target state="translated">하위 루프는</target>
        </trans-unit>
        <trans-unit id="d49e301cfdcfd0dc30c1292d8446531a39bb2c8d" translate="yes" xml:space="preserve">
          <source>The lvalue &lt;code&gt;$ref&lt;/code&gt; will be turned into a weak reference. This means that it will not hold a reference count on the object it references. Also when the reference count on that object reaches zero, the reference will be set to undef. This function mutates the lvalue passed as its argument and returns no value.</source>
          <target state="translated">lvalue &lt;code&gt;$ref&lt;/code&gt; 는 약한 참조로 바뀝니다 . 이는 참조하는 객체에 대한 참조 횟수를 보유하지 않음을 의미합니다. 또한 해당 객체의 참조 횟수가 0에 도달하면 참조가 undef로 설정됩니다. 이 함수는 인수로 전달 된 lvalue를 변경하고 값을 반환하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="24ee888b5b6764355f1443fa7075b59310751e36" translate="yes" xml:space="preserve">
          <source>The lvalue &lt;code&gt;$ref&lt;/code&gt; will be turned into a weak reference. This means that it will not hold a reference count on the object it references. Also, when the reference count on that object reaches zero, the reference will be set to undef. This function mutates the lvalue passed as its argument and returns no value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72b929552916e7407c841dad6560b9f648df9456" translate="yes" xml:space="preserve">
          <source>The lvalue &lt;code&gt;REF&lt;/code&gt; will be turned from a weak reference back into a normal (strong) reference again. This function mutates the lvalue passed as its argument and returns no value. This undoes the action performed by &lt;a href=&quot;#weaken&quot;&gt;&quot;weaken&quot;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b3f15897ac19338676b9cf56d55755a66f779f6" translate="yes" xml:space="preserve">
          <source>The lvalue &lt;code&gt;REF&lt;/code&gt; will be turned from a weak reference back into a normal (strong) reference again. This function mutates the lvalue passed as its argument and returns no value. This undoes the action performed by &lt;a href=&quot;#weaken&quot;&gt;weaken&lt;/a&gt;.</source>
          <target state="translated">lvalue &lt;code&gt;REF&lt;/code&gt; 는 약한 참조에서 다시 정상 (강한) 참조로 바뀝니다. 이 함수는 인수로 전달 된 lvalue를 변경하고 값을 반환하지 않습니다. &lt;a href=&quot;#weaken&quot;&gt;약화로&lt;/a&gt; 수행 된 작업을 취소합니다 .</target>
        </trans-unit>
        <trans-unit id="c832abcca8e03b1175991e252a63bb6082afdd89" translate="yes" xml:space="preserve">
          <source>The macro &lt;code&gt;cxstack&lt;/code&gt; returns the base of the current context stack, while &lt;code&gt;cxstack_ix&lt;/code&gt; is the index of the current frame within that stack.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b79adf8cca5ef25d3cb23e673042840fb0ff857" translate="yes" xml:space="preserve">
          <source>The macro to put this target on stack is &lt;code&gt;PUSHTARG&lt;/code&gt; , and it is directly used in some opcodes, as well as indirectly in zillions of others, which use it via &lt;code&gt;(X)PUSH[iunp]&lt;/code&gt;.</source>
          <target state="translated">이 대상을 스택에 배치하는 매크로는 &lt;code&gt;PUSHTARG&lt;/code&gt; 이며 일부 opcode에서 직접 사용되며 다른 일부에서는 간접적으로 사용되며 &lt;code&gt;(X)PUSH[iunp]&lt;/code&gt; 를 통해이를 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="693b2cae8dc15e395df0cd8e5b72f3d52fadcead" translate="yes" xml:space="preserve">
          <source>The macro to put this target on stack is &lt;code&gt;PUSHTARG&lt;/code&gt;, and it is directly used in some opcodes, as well as indirectly in zillions of others, which use it via &lt;code&gt;(X)PUSH[iunp]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bde4ff87d6048995f18afa79c7d92547dd919bf7" translate="yes" xml:space="preserve">
          <source>The macros PERL_SYS_INIT3() and PERL_SYS_TERM() provide system-specific tune up of the C runtime environment necessary to run Perl interpreters; they should only be called once regardless of how many interpreters you create or destroy. Call PERL_SYS_INIT3() before you create your first interpreter, and PERL_SYS_TERM() after you free your last interpreter.</source>
          <target state="translated">PERL_SYS_INIT3 () 및 PERL_SYS_TERM () 매크로는 Perl 인터프리터를 실행하는 데 필요한 C 런타임 환경의 시스템 특정 조정을 제공합니다. 얼마나 많은 통역사를 만들거나 파괴하든 관계없이 한 번만 호출해야합니다. 첫 번째 인터프리터를 작성하기 전에 PERL_SYS_INIT3 ()을 호출하고 마지막 인터프리터를 해제 한 후 PERL_SYS_TERM ()을 호출하십시오.</target>
        </trans-unit>
        <trans-unit id="b34be3b84eadf2e475f94c5862ce6783466cbe33" translate="yes" xml:space="preserve">
          <source>The macros below now require an extra parameter than in versions prior to Perl 5.32. The final parameter in each one is a pointer into the string supplied by the first parameter beyond which the input will not be read. This prevents potential reading beyond the end of the buffer. &lt;code&gt;isALPHANUMERIC_utf8&lt;/code&gt;, &lt;code&gt;isASCII_utf8&lt;/code&gt;, &lt;code&gt;isBLANK_utf8&lt;/code&gt;, &lt;code&gt;isCNTRL_utf8&lt;/code&gt;, &lt;code&gt;isDIGIT_utf8&lt;/code&gt;, &lt;code&gt;isIDFIRST_utf8&lt;/code&gt;, &lt;code&gt;isPSXSPC_utf8&lt;/code&gt;, &lt;code&gt;isSPACE_utf8&lt;/code&gt;, &lt;code&gt;isVERTWS_utf8&lt;/code&gt;, &lt;code&gt;isWORDCHAR_utf8&lt;/code&gt;, &lt;code&gt;isXDIGIT_utf8&lt;/code&gt;, &lt;code&gt;isALPHANUMERIC_LC_utf8&lt;/code&gt;, &lt;code&gt;isALPHA_LC_utf8&lt;/code&gt;, &lt;code&gt;isASCII_LC_utf8&lt;/code&gt;, &lt;code&gt;isBLANK_LC_utf8&lt;/code&gt;, &lt;code&gt;isCNTRL_LC_utf8&lt;/code&gt;, &lt;code&gt;isDIGIT_LC_utf8&lt;/code&gt;, &lt;code&gt;isGRAPH_LC_utf8&lt;/code&gt;, &lt;code&gt;isIDCONT_LC_utf8&lt;/code&gt;, &lt;code&gt;isIDFIRST_LC_utf8&lt;/code&gt;, &lt;code&gt;isLOWER_LC_utf8&lt;/code&gt;, &lt;code&gt;isPRINT_LC_utf8&lt;/code&gt;, &lt;code&gt;isPSXSPC_LC_utf8&lt;/code&gt;, &lt;code&gt;isPUNCT_LC_utf8&lt;/code&gt;, &lt;code&gt;isSPACE_LC_utf8&lt;/code&gt;, &lt;code&gt;isUPPER_LC_utf8&lt;/code&gt;, &lt;code&gt;isWORDCHAR_LC_utf8&lt;/code&gt;, &lt;code&gt;isXDIGIT_LC_utf8&lt;/code&gt;, &lt;code&gt;toFOLD_utf8&lt;/code&gt;, &lt;code&gt;toLOWER_utf8&lt;/code&gt;, &lt;code&gt;toTITLE_utf8&lt;/code&gt;, and &lt;code&gt;toUPPER_utf8&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1139ce181f4f4cad2c7f324461583f5984431bd" translate="yes" xml:space="preserve">
          <source>The macros to simplify this type of error propagation are</source>
          <target state="translated">이러한 유형의 오류 전파를 단순화하는 매크로는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c70f4757860a22dec9e7cd7195f5c976eb6e087f" translate="yes" xml:space="preserve">
          <source>The mailbox (MBX) that perl can create to communicate with a pipe defaults to a buffer size of 8192 on 64-bit systems, 512 on VAX. The default buffer size is adjustable via the logical name PERL_MBX_SIZE provided that the value falls between 128 and the SYSGEN parameter MAXBUF inclusive. For example, to set the mailbox size to 32767 use &lt;code&gt;$ENV{'PERL_MBX_SIZE'} = 32767;&lt;/code&gt; and then open and use pipe constructs. An alternative would be to issue the command:</source>
          <target state="translated">파이프와 통신하기 위해 perl이 작성할 수있는 메일 함 (MBX)은 기본적으로 64 비트 시스템에서 버퍼 크기는 8192, VAX에서는 512입니다. 기본 버퍼 크기는 논리 이름 PERL_MBX_SIZE를 통해 조정 가능하며 값이 128과 SYSGEN 매개 변수 MAXBUF를 포함하는 경우. 예를 들어, 사서함 크기를 32767으로 설정하려면 &lt;code&gt;$ENV{'PERL_MBX_SIZE'} = 32767;&lt;/code&gt; 파이프 구조를 열고 사용하십시오. 대안은 다음 명령을 발행하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="08ec92a415b0c7db1f570cc5fe1a3d90ed229b88" translate="yes" xml:space="preserve">
          <source>The main advantage of &lt;code&gt;$]&lt;/code&gt; over &lt;code&gt;$^V&lt;/code&gt; is that it works the same on any version of Perl. The disadvantages are that it can't easily be compared to versions in other formats (e.g. literal v-strings, &quot;v1.2.3&quot; or version objects) and numeric comparisons are subject to the binary floating point representation; it's good for numeric literal version checks and bad for comparing to a variable that hasn't been sanity-checked.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c5ef5a84eaac465306135c82a819527f916862a" translate="yes" xml:space="preserve">
          <source>The main advantage of &lt;code&gt;$]&lt;/code&gt; over &lt;code&gt;$^V&lt;/code&gt; is that it works the same on any version of Perl. The disadvantages are that it can't easily be compared to versions in other formats (e.g. literal v-strings, &quot;v1.2.3&quot; or version objects) and numeric comparisons can occasionally fail; it's good for string literal version checks and bad for comparing to a variable that hasn't been sanity-checked.</source>
          <target state="translated">&lt;code&gt;$^V&lt;/code&gt; 비해 &lt;code&gt;$]&lt;/code&gt; 의 주요 장점은 모든 버전의 Perl에서 동일하게 작동한다는 것입니다. 단점은 다른 형식의 버전 (예 : 리터럴 v- 문자열, &quot;v1.2.3&quot;또는 버전 객체)과 쉽게 비교할 수없고 숫자 비교가 때때로 실패 할 수 있다는 것입니다. 문자열 리터럴 버전 검사에 적합하며 온 전성 검사되지 않은 변수와 비교하기에는 좋지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4dbfa08a8a6c8cbfafaef8a1a762c3513a39fb28" translate="yes" xml:space="preserve">
          <source>The main advantage of &lt;code&gt;$^V&lt;/code&gt; over &lt;code&gt;$]&lt;/code&gt; is that, for Perl v5.10.0 or later, it overloads operators, allowing easy comparison against other version representations (e.g. decimal, literal v-string, &quot;v1.2.3&quot;, or objects). The disadvantage is that prior to v5.10.0, it was only a literal v-string, which can't be easily printed or compared, whereas the behavior of &lt;code&gt;$]&lt;/code&gt; is unchanged on all versions of Perl.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb52b8877c2d456ae00a93e532373fbd1c4c24a5" translate="yes" xml:space="preserve">
          <source>The main advantage of &lt;code&gt;$^V&lt;/code&gt; over &lt;code&gt;$]&lt;/code&gt; is that, for Perl v5.10.0 or later, it overloads operators, allowing easy comparison against other version representations (e.g. decimal, literal v-string, &quot;v1.2.3&quot;, or objects). The disadvantage is that prior to v5.10.0, it was only a literal v-string, which can't be easily printed or compared.</source>
          <target state="translated">의 가장 큰 장점 &lt;code&gt;$^V&lt;/code&gt; 이상 &lt;code&gt;$]&lt;/code&gt; 는 펄 v5.10.0에 대한, 즉 이상, 다른 버전의 표현에 대하여 쉽게 비교할 수 있도록, 연산자를 오버로드 (예를 들어 진수, 문자 V-문자열, &quot;v1.2.3&quot;를, 또는 객체) . 단점은 v5.10.0 이전에는 문자 그대로의 v- 문자열이므로 쉽게 인쇄하거나 비교할 수 없다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="101d1c6f485f1984d68802df9d96ca30aed70d37" translate="yes" xml:space="preserve">
          <source>The main change in &lt;code&gt;Compress::Zlib&lt;/code&gt; version 2.x is that it does not now interface directly to the zlib library. Instead it uses the &lt;code&gt;IO::Compress::Gzip&lt;/code&gt; and &lt;code&gt;IO::Uncompress::Gunzip&lt;/code&gt; modules for reading/writing gzip files, and the &lt;code&gt;Compress::Raw::Zlib&lt;/code&gt; module for some low-level zlib access.</source>
          <target state="translated">&lt;code&gt;Compress::Zlib&lt;/code&gt; 버전 2.x 의 주요 변경 사항은 이제 zlib 라이브러리에 직접 인터페이스되지 않는다는 것입니다. 대신 gzip 파일 읽기 / 쓰기를 위해 &lt;code&gt;IO::Compress::Gzip&lt;/code&gt; 및 &lt;code&gt;IO::Uncompress::Gunzip&lt;/code&gt; 모듈을 사용 하고 일부 저수준 zlib 액세스를 위해 &lt;code&gt;Compress::Raw::Zlib&lt;/code&gt; 모듈을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="372171de4da878145ca85489d35a3856b5f753b3" translate="yes" xml:space="preserve">
          <source>The main difference between this form of the &lt;code&gt;&lt;a href=&quot;../../functions/read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; method and the previous one, is that this one will attempt to return</source>
          <target state="translated">이 형식의 &lt;code&gt;&lt;a href=&quot;../../functions/read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; 메소드와 이전 메소드 의 주요 차이점은이 메소드가 리턴하려고 시도한다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="208796ee71984ca1960f03809fd6acd6ef109429" translate="yes" xml:space="preserve">
          <source>The main difference between this form of the &lt;code&gt;read&lt;/code&gt; method and the previous one, is that this one will attempt to return</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="506249c3cb5dbdd1518162463cf96d2d3b772f7e" translate="yes" xml:space="preserve">
          <source>The main difference in your code when using &lt;code&gt;LimitOutput&lt;/code&gt; is having to deal with cases where the &lt;code&gt;$input&lt;/code&gt; parameter still contains some uncompressed data that &lt;code&gt;inflate&lt;/code&gt; hasn't processed yet. The status code returned from &lt;code&gt;inflate&lt;/code&gt; will be &lt;code&gt;Z_OK&lt;/code&gt; if uncompression took place and &lt;code&gt;Z_BUF_ERROR&lt;/code&gt; if the output buffer is full.</source>
          <target state="translated">사용하여 코드의 주요 차이점 &lt;code&gt;LimitOutput&lt;/code&gt; 이 를 Where 경우 처리하는 데 &lt;code&gt;$input&lt;/code&gt; 매개 변수가 여전히 몇 가지 압축되지 않은 데이터를 포함 &lt;code&gt;inflate&lt;/code&gt; 아직 처리되지 않았습니다. 에서 반환 된 상태 코드 &lt;code&gt;inflate&lt;/code&gt; 될 것입니다 &lt;code&gt;Z_OK&lt;/code&gt; 을 압축 해지가 장소와했다 경우 &lt;code&gt;Z_BUF_ERROR&lt;/code&gt; 를 출력 버퍼가 가득합니다.</target>
        </trans-unit>
        <trans-unit id="92b5e72aa08b04ddc99309d77bb3cb7a3bd1fb12" translate="yes" xml:space="preserve">
          <source>The main division in the context struct is between a substitution scope (&lt;code&gt;CXt_SUBST&lt;/code&gt;) and block scopes, which are everything else. The former is just used while executing &lt;code&gt;s///e&lt;/code&gt;, and won't be discussed further here.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05152f518d0f3656c0688ee9cee29d35fcced80c" translate="yes" xml:space="preserve">
          <source>The main enhancements over the standard DBM Filter hooks are:</source>
          <target state="translated">표준 DBM 필터 후크에 대한 주요 개선 사항은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e1f5b26355b7b70560c834756cb61711542dab38" translate="yes" xml:space="preserve">
          <source>The main interface to Perl's documentation is &lt;code&gt;perldoc&lt;/code&gt; , although if you're reading this, it's more than likely that you've already found it.</source>
          <target state="translated">Perl의 문서에 대한 주요 인터페이스는 &lt;code&gt;perldoc&lt;/code&gt; 입니다 .이 글을 읽고 있다면 이미 찾은 것보다 큽니다.</target>
        </trans-unit>
        <trans-unit id="d4c0d9f985e6490addfa7c9bcf66885ac7eb6fd4" translate="yes" xml:space="preserve">
          <source>The main interface to Perl's documentation is &lt;code&gt;perldoc&lt;/code&gt;, although if you're reading this, it's more than likely that you've already found it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d35e12fdba0e51aa394bd8618a43431bb51d2f3" translate="yes" xml:space="preserve">
          <source>The main processing loop in the code handles reading of compressed data from STDIN.</source>
          <target state="translated">코드의 기본 처리 루프는 STDIN에서 압축 된 데이터 읽기를 처리합니다.</target>
        </trans-unit>
        <trans-unit id="10be13178c7ed17eb7ff58045f81aad5069fb2a4" translate="yes" xml:space="preserve">
          <source>The main reason for using these constants is to help avoid spelling mistakes and similar typos. It will not help you if you forget to prefix the '+' though.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46fda3610207ec49730bec59c6f9f9a606bd23ef" translate="yes" xml:space="preserve">
          <source>The main restriction is that everything is a metacharacter. Thus, you cannot refer to single characters by doing something like this:</source>
          <target state="translated">주요 제한 사항은 모든 것이 메타 문자라는 것입니다. 따라서 다음과 같은 방법으로 단일 문자를 참조 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="5f01e11115c777ec013558e25689beffe8389e6e" translate="yes" xml:space="preserve">
          <source>The main run-time, i.e. the execution of &lt;code&gt;PL_main_root&lt;/code&gt; .</source>
          <target state="translated">주요 실행 시간, 실행, 즉 &lt;code&gt;PL_main_root&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="d7fd0d727cdc1e3c76c39fb195a6b8c660cb66d4" translate="yes" xml:space="preserve">
          <source>The main run-time, i.e. the execution of &lt;code&gt;PL_main_root&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37fc4f091ec88a6495b33730022421e8180365bf" translate="yes" xml:space="preserve">
          <source>The main thing to bear in mind when comparing Perl's</source>
          <target state="translated">Perl을 비교할 때 명심해야 할 주요 사항</target>
        </trans-unit>
        <trans-unit id="c06e6958bf7f6e1def3af629026b1de09d93eea1" translate="yes" xml:space="preserve">
          <source>The main two standard installer modules are the old and well established ExtUtils::MakeMaker (for short: EUMM) which uses the Makefile.PL. And the next generation installer Module::Build (MB) which works with the Build.PL (and often comes with a Makefile.PL too). If a module comes only with one of the two we will use that one but if both are supplied then a decision must be made between EUMM and MB. See also &lt;a href=&quot;http://rt.cpan.org/Ticket/Display.html?id=29235&quot;&gt;http://rt.cpan.org/Ticket/Display.html?id=29235&lt;/a&gt; for a discussion about the right default.</source>
          <target state="translated">주요 두 표준 설치 프로그램 모듈은 Makefile.PL을 사용하는 오래되고 잘 확립 된 ExtUtils :: MakeMaker (약칭 : EUMM)입니다. 그리고 Build.PL과 함께 작동하는 차세대 설치 프로그램 Module :: Build (MB) (그리고 종종 Makefile.PL도 함께 제공됨). 모듈에 둘 중 하나만 제공되는 경우 해당 모듈을 사용하지만 둘 다 제공되는 경우 EUMM과 MB간에 결정을 내려야합니다. 올바른 기본값에 대한 설명은 &lt;a href=&quot;http://rt.cpan.org/Ticket/Display.html?id=29235&quot;&gt;http://rt.cpan.org/Ticket/Display.html?id=29235&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="4a4d251a87e0958567984c04589a931c90f147e2" translate="yes" xml:space="preserve">
          <source>The main two standard installer modules are the old and well established ExtUtils::MakeMaker (for short: EUMM) which uses the Makefile.PL. And the next generation installer Module::Build (MB) which works with the Build.PL (and often comes with a Makefile.PL too). If a module comes only with one of the two we will use that one but if both are supplied then a decision must be made between EUMM and MB. See also http://rt.cpan.org/Ticket/Display.html?id=29235 for a discussion about the right default.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05599914a88c35566cdc46d5be82351b5056b7bb" translate="yes" xml:space="preserve">
          <source>The main use for &lt;code&gt;ascii&lt;/code&gt; is to force the output to not contain characters with values &amp;gt; 127, which means you can interpret the resulting string as UTF-8, ISO-8859-1, ASCII, KOI8-R or most about any character set and 8-bit-encoding, and still get the same data structure back. This is useful when your channel for JSON transfer is not 8-bit clean or the encoding might be mangled in between (e.g. in mail), and works because ASCII is a proper subset of most 8-bit and multibyte encodings in use in the world.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa39b18861e8c0d0fbd241aca023fce2a33049ad" translate="yes" xml:space="preserve">
          <source>The main use for &lt;code&gt;latin1&lt;/code&gt; is to relatively efficiently store binary data as JSON, at the expense of breaking compatibility with most JSON decoders.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="866c41ef1cd5e3c514447a1eb0c0a78fc5c432a8" translate="yes" xml:space="preserve">
          <source>The main use for this flag is efficiently encoding binary data as JSON text, as most octets will not be escaped, resulting in a smaller encoded size. The disadvantage is that the resulting JSON text is encoded in latin1 (and must correctly be treated as such when storing and transferring), a rare encoding for JSON. It is therefore most useful when you want to store data structures known to contain binary data efficiently in files or databases, not when talking to other JSON encoders/decoders.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06fa4e1ba42a335acb6388e4bce2e76ff0904fc1" translate="yes" xml:space="preserve">
          <source>The main use for this flag is to produce JSON texts that can be transmitted over a 7-bit channel, as the encoded JSON texts will not contain any 8 bit characters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2f8fe511450837b8803ee63b84fd8df2352eb1f" translate="yes" xml:space="preserve">
          <source>The main use of the &lt;code&gt;@_&lt;/code&gt; pass-through feature is to write subroutines whose main job it is to call other subroutines for you. For further details, see &lt;a href=&quot;perlsub&quot;&gt;perlsub&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;@_&lt;/code&gt; pass-through 기능 의 주된 용도는 다른 서브 루틴을 호출하는 것이 주요한 서브 루틴을 작성하는 것입니다. 자세한 내용은 &lt;a href=&quot;perlsub&quot;&gt;perlsub를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="53e4e2133c40d29e72103e441a447d5a4a38fc75" translate="yes" xml:space="preserve">
          <source>The main use of typeglobs in modern Perl is create symbol table aliases. This assignment:</source>
          <target state="translated">현대 Perl에서 typeglob의 주요 용도는 심볼 테이블 별칭을 만드는 것입니다. 이 과제 :</target>
        </trans-unit>
        <trans-unit id="69b1898f468b9694e16716e650f4f44f6641ba6b" translate="yes" xml:space="preserve">
          <source>The main way they do this is by abstracting the solution into a Perl module. If you don't know what one of these is, the rest of this document isn't going to be much use to you. You're also missing out on an awful lot of useful code; consider having a look at &lt;a href=&quot;perlmod&quot;&gt;perlmod&lt;/a&gt;, &lt;a href=&quot;perlmodlib&quot;&gt;perlmodlib&lt;/a&gt; and &lt;a href=&quot;perlmodinstall&quot;&gt;perlmodinstall&lt;/a&gt; before coming back here.</source>
          <target state="translated">이 작업을 수행하는 주요 방법은 솔루션을 Perl 모듈로 추상화하는 것입니다. 이 중 하나가 무엇인지 모른다면이 문서의 나머지 부분은 그다지 유용하지 않을 것입니다. 또한 유용한 코드가 많이 빠져 있습니다. 살펴 고려해 &lt;a href=&quot;perlmod&quot;&gt;perlmod를&lt;/a&gt; , &lt;a href=&quot;perlmodlib&quot;&gt;perlmodlib&lt;/a&gt; 및 &lt;a href=&quot;perlmodinstall&quot;&gt;perlmodinstall을&lt;/a&gt; 여기로 오기 전에.</target>
        </trans-unit>
        <trans-unit id="0f1c38b1c10cfb3cbb67b1b10b401ccad6c0863c" translate="yes" xml:space="preserve">
          <source>The main workhorse. This is a chimera executable: it is compiled as an &lt;code&gt;a.out&lt;/code&gt; -style executable, but is linked with &lt;code&gt;omf&lt;/code&gt; -style dynamic library</source>
          <target state="translated">주된 일꾼. 이것은 키메라 실행 파일입니다. &lt;code&gt;a.out&lt;/code&gt; 스타일 실행 파일 로 컴파일 되지만 &lt;code&gt;omf&lt;/code&gt; 스타일 동적 라이브러리 와 연결됩니다</target>
        </trans-unit>
        <trans-unit id="545144eca602ef4173887f0da06edec85e29ecc4" translate="yes" xml:space="preserve">
          <source>The main workhorse. This is a chimera executable: it is compiled as an &lt;code&gt;a.out&lt;/code&gt;-style executable, but is linked with &lt;code&gt;omf&lt;/code&gt;-style dynamic library</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3956c803121907ff5d6974bf9c432a88f1cf833c" translate="yes" xml:space="preserve">
          <source>The major headers should be set out using a &lt;code&gt;=head1&lt;/code&gt; directive, and are historically written in the rather startling ALL UPPER CASE format; this is not mandatory, but it's strongly recommended so that sections have consistent naming across different software packages. Minor headers may be included using &lt;code&gt;=head2&lt;/code&gt; , and are typically in mixed case.</source>
          <target state="translated">주요 헤더는 &lt;code&gt;=head1&lt;/code&gt; 지시문을 사용하여 설정해야하며 역사적으로 다소 놀라운 ALL UPPER CASE 형식으로 작성되었습니다. 이것은 필수 사항은 아니지만 섹션이 다른 소프트웨어 패키지에서 일관된 이름을 갖도록하는 것이 좋습니다. 마이너 헤더는 &lt;code&gt;=head2&lt;/code&gt; 를 사용하여 포함될 수 있으며 일반적으로 대소 문자를 혼합합니다.</target>
        </trans-unit>
        <trans-unit id="00d415a583ddacb7562640a4ed5cbc374d3a4aac" translate="yes" xml:space="preserve">
          <source>The major headers should be set out using a &lt;code&gt;=head1&lt;/code&gt; directive, and are historically written in the rather startling ALL UPPER CASE format; this is not mandatory, but it's strongly recommended so that sections have consistent naming across different software packages. Minor headers may be included using &lt;code&gt;=head2&lt;/code&gt;, and are typically in mixed case.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01d78be692306962b0b26bf44b44f51f19191990" translate="yes" xml:space="preserve">
          <source>The major reference book on Perl, written by the creator of Perl, is</source>
          <target state="translated">Perl의 작성자가 작성한 Perl에 대한 주요 참조서는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="13680a9d6e9227284375bc26da8c5530041e38fc" translate="yes" xml:space="preserve">
          <source>The majority of messages from the first three classifications above (W, D &amp;amp; S) can be controlled using the &lt;code&gt;warnings&lt;/code&gt; pragma.</source>
          <target state="translated">위의 첫 세 분류 (W, D &amp;amp; S)에서 온 대부분의 메시지는 &lt;code&gt;warnings&lt;/code&gt; pragma를 사용하여 제어 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="47a0713a7794ab11956a543900cb0615be7d2460" translate="yes" xml:space="preserve">
          <source>The majority of the code above is concerned with reading the zip local header data. The code that I want to focus on is at the bottom.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd369e1f787ef0292f11539410c5f0156585f6b5" translate="yes" xml:space="preserve">
          <source>The make process also creates the Perl extensions as</source>
          <target state="translated">make 프로세스는 Perl 확장을 다음과 같이 작성합니다.</target>
        </trans-unit>
        <trans-unit id="6834c3d08e7b64ac9a3d75579db624c6bb6535ce" translate="yes" xml:space="preserve">
          <source>The make process runs only under WinNT shell. The NetWare makefile is located under the NetWare folder. This makes use of miniperl.exe to run some of the Perl scripts. To create miniperl.exe, first set the required paths for Visual c++ compiler (specify vcvars32 location) at the command prompt. Then run nmake from win32 folder through WinNT command prompt. The build process can be stopped after miniperl.exe is created. Then run nmake from NetWare folder through WinNT command prompt.</source>
          <target state="translated">make 프로세스는 WinNT 셸에서만 실행됩니다. NetWare makefile은 NetWare 폴더 아래에 있습니다. 이것은 miniperl.exe를 사용하여 일부 Perl 스크립트를 실행합니다. miniperl.exe를 만들려면 먼저 명령 프롬프트에서 Visual c ++ 컴파일러의 필수 경로 (vcvars32 위치 지정)를 설정하십시오. 그런 다음 WinNT 명령 프롬프트를 통해 win32 폴더에서 nmake를 실행하십시오. miniperl.exe를 만든 후에 빌드 프로세스를 중지 할 수 있습니다. 그런 다음 WinNT 명령 프롬프트를 통해 NetWare 폴더에서 nmake를 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="6f3be1c564860e93ed0610de17db5187711f88d0" translate="yes" xml:space="preserve">
          <source>The make target 'allsis' combines all the above SIS targets.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="050ece2e16daad9919f83779717a0433d9f5277b" translate="yes" xml:space="preserve">
          <source>The make under /usr/ccs/bin works fine for building perl. If you have the Sun C compilers, you will also have a parallel version of make (dmake). This works fine to build perl, but can sometimes cause problems when running 'make test' due to underspecified dependencies between the different test harness files. The same problem can also affect the building of some add-on modules, so in those cases either specify '-m serial' on the dmake command line, or use /usr/ccs/bin/make instead. If you wish to use GNU make, be sure that the set-group-id bit is not set. If it is, then arrange your PATH so that /usr/ccs/bin/make is before GNU make or else have the system administrator disable the set-group-id bit on GNU make.</source>
          <target state="translated">/ usr / ccs / bin 아래의 make는 perl을 빌드하는 데 적합합니다. Sun C 컴파일러가있는 경우 병렬 버전의 make (dmake)도 있습니다. 이것은 perl을 빌드하는 데 잘 작동하지만 다른 테스트 하네스 파일 사이의 종속성이 지정되지 않아 'make test'를 실행할 때 문제가 발생할 수 있습니다. 같은 문제가 일부 애드온 모듈의 빌드에도 영향을 줄 수 있으므로 이러한 경우 dmake 명령 줄에 '-m serial'을 지정하거나 / usr / ccs / bin / make를 대신 사용하십시오. GNU make를 사용하려면 set-group-id 비트가 설정되어 있지 않은지 확인하십시오. 그렇다면 / usr / ccs / bin / make가 GNU make 앞에 오거나 시스템 관리자가 GNU make에서 set-group-id 비트를 비활성화하도록 PATH를 정렬하십시오.</target>
        </trans-unit>
        <trans-unit id="093c5a0fa4f10414f0bded11d9711f892cf8d016" translate="yes" xml:space="preserve">
          <source>The makefile for Win32 is used as a reference to create the makefile for NetWare. Also, the make process for NetWare port uses miniperl.exe to run scripts during the make and installation process.</source>
          <target state="translated">Win32 용 makefile은 NetWare 용 makefile을 작성하기위한 참조로 사용됩니다. 또한 NetWare 포트의 작성 프로세스는 miniperl.exe를 사용하여 작성 및 설치 프로세스 중에 스크립트를 실행합니다.</target>
        </trans-unit>
        <trans-unit id="27e98181ad3a79924d7fd39b526549233ec76d6a" translate="yes" xml:space="preserve">
          <source>The man page documenting the an macro set may be</source>
          <target state="translated">매크로 세트를 문서화하는 매뉴얼 페이지는</target>
        </trans-unit>
        <trans-unit id="623ee701bbcdbe97eed930b9efd8035f1a031aee" translate="yes" xml:space="preserve">
          <source>The man page documenting the an macro set may be &lt;a href=&quot;http://man.he.net/man5/man&quot;&gt;man(5)&lt;/a&gt; instead of &lt;a href=&quot;http://man.he.net/man7/man&quot;&gt;man(7)&lt;/a&gt; on your system.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1b2bfc99455c361765a64ae36b53dd690daec7f" translate="yes" xml:space="preserve">
          <source>The man page documenting the man macro set may be</source>
          <target state="translated">man 매크로 세트를 문서화하는 man 페이지는</target>
        </trans-unit>
        <trans-unit id="7f7916f4586e4282d358ae1052455bb329b90846" translate="yes" xml:space="preserve">
          <source>The man page documenting the man macro set may be &lt;a href=&quot;http://man.he.net/man5/man&quot;&gt;man(5)&lt;/a&gt; instead of &lt;a href=&quot;http://man.he.net/man7/man&quot;&gt;man(7)&lt;/a&gt; on your system. Also, please see &lt;a href=&quot;http://man.he.net/man1/pod2man&quot;&gt;pod2man(1)&lt;/a&gt; for extensive documentation on writing manual pages if you've not done it before and aren't familiar with the conventions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="284a6c5b883e0ac48b839ca370726900339633bc" translate="yes" xml:space="preserve">
          <source>The mandatory parameter &lt;code&gt;$input&lt;/code&gt; is used to determine the source of the compressed data. This parameter can take one of three forms.</source>
          <target state="translated">필수 매개 변수 &lt;code&gt;$input&lt;/code&gt; 은 압축 된 데이터의 소스를 판별하는 데 사용됩니다. 이 매개 변수는 세 가지 형식 중 하나를 취할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c485ab3d22837e3f8be3f1796e0e79d8c8f06f1f" translate="yes" xml:space="preserve">
          <source>The mandatory parameter &lt;code&gt;$output&lt;/code&gt; is used to control the destination of the compressed data. This parameter can take one of these forms.</source>
          <target state="translated">필수 매개 변수 &lt;code&gt;$output&lt;/code&gt; 은 압축 된 데이터의 대상을 제어하는 ​​데 사용됩니다. 이 매개 변수는 다음 양식 중 하나를 취할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="de616d536d8ef10cc9a3f654a8c90f376abf8093" translate="yes" xml:space="preserve">
          <source>The manual for GNU &lt;code&gt;gettext&lt;/code&gt; . The gettext dist is available in &lt;code&gt;&lt;a href=&quot;ftp://prep.ai.mit.edu/pub/gnu/&quot;&gt;ftp://prep.ai.mit.edu/pub/gnu/&lt;/a&gt;&lt;/code&gt; -- get a recent gettext tarball and look in its &quot;doc/&quot; directory, there's an easily browsable HTML version in there. The gettext documentation asks lots of questions worth thinking about, even if some of their answers are sometimes wonky, particularly where they start talking about pluralization.</source>
          <target state="translated">GNU &lt;code&gt;gettext&lt;/code&gt; 매뉴얼 . gettext dist는 &lt;code&gt;&lt;a href=&quot;ftp://prep.ai.mit.edu/pub/gnu/&quot;&gt;ftp://prep.ai.mit.edu/pub/gnu/&lt;/a&gt;&lt;/code&gt; 에서 사용할 수 있습니다 . 최근 gettext tarball을 가져 와서 &quot;doc /&quot;디렉토리를 보면 쉽게 찾아 볼 수있는 HTML 버전이 있습니다. gettext 문서는 일부 답변이 때로는 기발한 경우에도, 특히 복수화에 대해 이야기하기 시작할 때 생각할 가치가있는 많은 질문을합니다.</target>
        </trans-unit>
        <trans-unit id="b1839a690d37e18249310936fdff387ca895bbd5" translate="yes" xml:space="preserve">
          <source>The manual for GNU &lt;code&gt;gettext&lt;/code&gt;. The gettext dist is available in &lt;code&gt;&lt;a href=&quot;ftp://prep.ai.mit.edu/pub/gnu/&quot;&gt;ftp://prep.ai.mit.edu/pub/gnu/&lt;/a&gt;&lt;/code&gt; -- get a recent gettext tarball and look in its &quot;doc/&quot; directory, there's an easily browsable HTML version in there. The gettext documentation asks lots of questions worth thinking about, even if some of their answers are sometimes wonky, particularly where they start talking about pluralization.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="154ce4660707f31f1810dc0e3b48188806eef41c" translate="yes" xml:space="preserve">
          <source>The many &lt;code&gt;SO_*&lt;/code&gt; and other constants provide the socket option names for getsockopt() and setsockopt().</source>
          <target state="translated">많은 &lt;code&gt;SO_*&lt;/code&gt; 및 기타 상수는 getsockopt () 및 setsockopt ()에 대한 소켓 옵션 이름을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="55aaa52fca491aa374cc9b313f0827cacbb95ed1" translate="yes" xml:space="preserve">
          <source>The map of tags-to-names that it uses is accessible as %I18N::LangTags::List::Name, and it's the same as the list that follows in this documentation, which should be useful to you even if you don't use this module.</source>
          <target state="translated">사용하는 태그 대 이름의 맵은 % I18N :: LangTags :: List :: Name으로 액세스 할 수 있으며이 문서의 다음에 나오는 목록과 동일합니다. 이 모듈을 사용하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="4ec748c6f374bea6dd407e2a2206dd66cc0ef16e" translate="yes" xml:space="preserve">
          <source>The mapping between the C callback and Perl is stored in the global hash &lt;code&gt;Mapping&lt;/code&gt; this time. Using a hash has the distinct advantage that it allows an unlimited number of callbacks to be registered.</source>
          <target state="translated">이번에는 C 콜백과 Perl 간의 &lt;code&gt;Mapping&lt;/code&gt; 이 전역 해시 매핑에 저장됩니다 . 해시를 사용하면 무제한의 콜백을 등록 할 수 있다는 장점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="3b99545de853bbada80b111bce027d144c0231ba" translate="yes" xml:space="preserve">
          <source>The mapping between the C callback and the Perl equivalent is stored in the global variable &lt;code&gt;callback&lt;/code&gt; .</source>
          <target state="translated">C 콜백과 Perl에 상응하는 매핑은 전역 변수 &lt;code&gt;callback&lt;/code&gt; 저장됩니다 .</target>
        </trans-unit>
        <trans-unit id="8e93b95ea6fe70dd3da986ffb8fe9a8d23395a81" translate="yes" xml:space="preserve">
          <source>The mapping between the C callback and the Perl equivalent is stored in the global variable &lt;code&gt;callback&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc01e02bb3d7483c767fb0c7888218cdd8db8748" translate="yes" xml:space="preserve">
          <source>The mapping from Perl to JSON is slightly more difficult, as Perl is a truly typeless language, so we can only guess which JSON type is meant by a Perl value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a662bfcb14335a42ef03f81101790bf366195df" translate="yes" xml:space="preserve">
          <source>The mapping of &lt;code&gt;U+FFFD&lt;/code&gt; is corrected in Unicode 6.3.0. see &lt;a href=&quot;http://www.unicode.org/reports/tr10/tr10-28.html#Trailing_Weights&quot;&gt;http://www.unicode.org/reports/tr10/tr10-28.html#Trailing_Weights&lt;/a&gt; (7.1.4 Trailing Weights). Such a correction is reproduced by this.</source>
          <target state="translated">&lt;code&gt;U+FFFD&lt;/code&gt; 의 매핑은 유니 코드 6.3.0에서 수정되었습니다. &lt;a href=&quot;http://www.unicode.org/reports/tr10/tr10-28.html#Trailing_Weights&quot;&gt;http://www.unicode.org/reports/tr10/tr10-28.html#Trailing_Weights(7.1.4&lt;/a&gt; 트레일 웨이트)를 참조 하십시오 . 이러한 수정은 이것에 의해 재현됩니다.</target>
        </trans-unit>
        <trans-unit id="bff19693156a4d3c9d0ae54fb777710debdba865" translate="yes" xml:space="preserve">
          <source>The maps for almost all properties are simple scalars that should be interpreted as-is. These values are those given in the Unicode-supplied data files, which may be inconsistent as to capitalization and as to which synonym for a property-value is given. The results may be normalized by using the &lt;a href=&quot;#prop_value_aliases%28%29&quot;&gt;&quot;prop_value_aliases()&quot;&lt;/a&gt; function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1b1175bc8b4e9784f2300c93388884be8f7673f" translate="yes" xml:space="preserve">
          <source>The maps for almost all properties are simple scalars that should be interpreted as-is. These values are those given in the Unicode-supplied data files, which may be inconsistent as to capitalization and as to which synonym for a property-value is given. The results may be normalized by using the &lt;a href=&quot;#prop_value_aliases()&quot;&gt;prop_value_aliases()&lt;/a&gt; function.</source>
          <target state="translated">거의 모든 속성에 대한 맵은 그대로 해석해야하는 간단한 스칼라입니다. 이러한 값은 유니 코드 제공 데이터 파일에 제공된 값으로, 대문자와 속성 값의 동의어가 일치하지 않을 수 있습니다. 를 사용하여 결과를 정규화 할 수 있습니다.&lt;a href=&quot;#prop_value_aliases()&quot;&gt;prop_value_aliases ()&lt;/a&gt; 함수를 .</target>
        </trans-unit>
        <trans-unit id="d366a92e1e29300af2573c9ebee67dbf16243194" translate="yes" xml:space="preserve">
          <source>The maps for the following are available at &lt;a href=&quot;http://www.unicode.org/&quot;&gt;http://www.unicode.org/&lt;/a&gt; but remain unsupported because those encodings need an algorithmical approach, currently unsupported by</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd2864353a5c8a1c71a51a027ee705129966bd16" translate="yes" xml:space="preserve">
          <source>The mark stack stores integers as I32 values, which are the height of the value stack at the time before the list began; thus the mark itself actually points to the value stack entry one before the list. The list itself starts at &lt;code&gt;mark + 1&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e4bf89cabbc9315682f2b81d303b6aa4fa34849" translate="yes" xml:space="preserve">
          <source>The markup used to embed documentation into your Perl code. Pod stands for &amp;ldquo;Plain old documentation&amp;rdquo;. See Camel chapter 23, &amp;ldquo;Plain Old Documentation&amp;rdquo;.</source>
          <target state="translated">Perl 코드에 문서를 포함시키는 데 사용되는 마크 업입니다. 포드는 &quot;일반 문서화&quot;를 나타냅니다. 낙타 23 장 &quot;일반 문서&quot;를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="34cc83ddfdc06a0bade5acdcde84b75e2705b198" translate="yes" xml:space="preserve">
          <source>The master web site for CPAN is &lt;a href=&quot;http://www.cpan.org/&quot;&gt;http://www.cpan.org/&lt;/a&gt;, &lt;a href=&quot;http://www.cpan.org/SITES.html&quot;&gt;http://www.cpan.org/SITES.html&lt;/a&gt; lists all mirrors.</source>
          <target state="translated">CPAN의 마스터 웹 사이트는 &lt;a href=&quot;http://www.cpan.org/&quot;&gt;http://www.cpan.org/&lt;/a&gt; , &lt;a href=&quot;http://www.cpan.org/SITES.html&quot;&gt;http://www.cpan.org/SITES.html입니다.&lt;/a&gt; 은 모든 미러를 나열합니다.</target>
        </trans-unit>
        <trans-unit id="3c45f7edc42ff58b499f5e637a319d744b7420b9" translate="yes" xml:space="preserve">
          <source>The match is greedy and non-backtracking, so that the cluster is never broken up into smaller components.</source>
          <target state="translated">경기는 욕심 많고 역 추적이 아니므로 클러스터가 더 작은 구성 요소로 나뉘 지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c68736af7f30812a5478f14010c89b4ae65386b0" translate="yes" xml:space="preserve">
          <source>The match operator is &quot;=~&quot;, not &quot;~&quot;. (&quot;~&quot; is the one's complement operator, as in C.)</source>
          <target state="translated">일치 연산자는 &quot;~&quot;가 아니라 &quot;= ~&quot;입니다. ( &quot;~&quot;는 C에서와 같이 보수 연산자입니다.)</target>
        </trans-unit>
        <trans-unit id="5795a85f98b64dffbf8aba9e904fb2bc93749e98" translate="yes" xml:space="preserve">
          <source>The match operator is a double quote context, so you can interpolate your variable just like a double quoted string. In this case, you read the regular expression as user input and store it in &lt;code&gt;$regex&lt;/code&gt; . Once you have the pattern in &lt;code&gt;$regex&lt;/code&gt; , you use that variable in the match operator.</source>
          <target state="translated">일치 연산자는 큰 따옴표 컨텍스트이므로 큰 따옴표로 묶은 문자열처럼 변수를 보간 할 수 있습니다. 이 경우 정규식을 사용자 입력으로 읽고 &lt;code&gt;$regex&lt;/code&gt; 저장합니다 . &lt;code&gt;$regex&lt;/code&gt; 패턴이 있으면 일치 연산자에서 해당 변수를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="fc14d244fbe8a0161a49513d59d3516c03861ccd" translate="yes" xml:space="preserve">
          <source>The match operator is a double quote context, so you can interpolate your variable just like a double quoted string. In this case, you read the regular expression as user input and store it in &lt;code&gt;$regex&lt;/code&gt;. Once you have the pattern in &lt;code&gt;$regex&lt;/code&gt;, you use that variable in the match operator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ab1da87cbb5d0fd800bfa0309cbbc3c397f76b8" translate="yes" xml:space="preserve">
          <source>The match operator. See &lt;a href=&quot;../perlop#Regexp-Quote-Like-Operators&quot;&gt;Regexp Quote-Like Operators in perlop&lt;/a&gt;.</source>
          <target state="translated">일치 연산자 &lt;a href=&quot;../perlop#Regexp-Quote-Like-Operators&quot;&gt;perlop의 정규 표현식 인용 유사 연산자를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f2d946e2bfb34dd4f7ba8364971084f9045ae306" translate="yes" xml:space="preserve">
          <source>The match operator. See &lt;a href=&quot;perlop#Regexp-Quote-Like-Operators&quot;&gt;&quot;Regexp Quote-Like Operators&quot; in perlop&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23da9f3c77f641f40df01068ee8c7ee0a479ea6c" translate="yes" xml:space="preserve">
          <source>The match operator. See &lt;a href=&quot;perlop#Regexp-Quote-Like-Operators&quot;&gt;Regexp Quote-Like Operators in perlop&lt;/a&gt;.</source>
          <target state="translated">일치 연산자 &lt;a href=&quot;perlop#Regexp-Quote-Like-Operators&quot;&gt;perlop의 정규 표현식 인용 유사 연산자를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f542541549a1bc6970c3286cf46be7af8b4f2d05" translate="yes" xml:space="preserve">
          <source>The match-once behavior is controlled by the match delimiter being &lt;code&gt;?&lt;/code&gt;; with any other delimiter this is the normal &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m//&lt;/a&gt;&lt;/code&gt; operator.</source>
          <target state="translated">한 번만 일치하는 동작은 일치 구분 기호가 &lt;code&gt;?&lt;/code&gt; ; 다른 구분 기호를 사용하면 이것은 정상적인 &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m//&lt;/a&gt;&lt;/code&gt; 연산자입니다.</target>
        </trans-unit>
        <trans-unit id="9eb42805d07d25374f7b5e9e6773ad7d57c9e1fb" translate="yes" xml:space="preserve">
          <source>The match-once behavior is controlled by the match delimiter being &lt;code&gt;?&lt;/code&gt;; with any other delimiter this is the normal &lt;code&gt;m//&lt;/code&gt; operator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eeba81f62bbef449f5b856ee7d56cb86c716867d" translate="yes" xml:space="preserve">
          <source>The matched-pattern variables, &lt;code&gt;$&amp;amp;&lt;/code&gt; , &lt;code&gt;$`&lt;/code&gt; (pre-match), &lt;code&gt;$'&lt;/code&gt; (post-match), and &lt;code&gt;$+&lt;/code&gt; (last match) also are tainted.</source>
          <target state="translated">일치 패턴 변수 &lt;code&gt;$&amp;amp;&lt;/code&gt; , &lt;code&gt;$`&lt;/code&gt; (사전 일치), &lt;code&gt;$'&lt;/code&gt; (사후 일치) 및 &lt;code&gt;$+&lt;/code&gt; (마지막 일치)도 오염됩니다.</target>
        </trans-unit>
        <trans-unit id="22ab92cf81444e038908ef762ce8e093bd1b736d" translate="yes" xml:space="preserve">
          <source>The matched-pattern variables, &lt;code&gt;$&amp;amp;&lt;/code&gt;, &lt;code&gt;$`&lt;/code&gt; (pre-match), &lt;code&gt;$'&lt;/code&gt; (post-match), and &lt;code&gt;$+&lt;/code&gt; (last match) also are tainted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eef4278a734cc2ba9814c78fdf30442bf1892ae1" translate="yes" xml:space="preserve">
          <source>The matching of encoding names is loose: case does not matter, and many encodings have several aliases. Note that the &lt;code&gt;:utf8&lt;/code&gt; layer must always be specified exactly like that; it is</source>
          <target state="translated">인코딩 이름의 일치가 느슨합니다. 대소 문자는 중요하지 않으며 많은 인코딩에는 여러 개의 별칭이 있습니다. 있습니다 &lt;code&gt;:utf8&lt;/code&gt; 층이 항상 똑같이 지정해야합니다; 그것은</target>
        </trans-unit>
        <trans-unit id="906f4ce57c5894760cba731d333a52399d7a0c38" translate="yes" xml:space="preserve">
          <source>The matching of encoding names is loose: case does not matter, and many encodings have several aliases. See &lt;a href=&quot;encode/supported&quot;&gt;Encode::Supported&lt;/a&gt; for details and the list of supported locales.</source>
          <target state="translated">인코딩 이름의 일치가 느슨합니다. 대소 문자는 중요하지 않으며 많은 인코딩에는 여러 개의 별칭이 있습니다. 자세한 내용과 지원되는 로캘 목록은 &lt;a href=&quot;encode/supported&quot;&gt;Encode :: Supported&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="4f9b61e44ff3edc932c4eb7e36f1dd657aefd954" translate="yes" xml:space="preserve">
          <source>The material below is separated into three main sections: main issues of portability (&lt;a href=&quot;#ISSUES&quot;&gt;&quot;ISSUES&quot;&lt;/a&gt;), platform-specific issues (&lt;a href=&quot;#PLATFORMS&quot;&gt;&quot;PLATFORMS&quot;&lt;/a&gt;), and built-in Perl functions that behave differently on various ports (&lt;a href=&quot;#FUNCTION-IMPLEMENTATIONS&quot;&gt;&quot;FUNCTION IMPLEMENTATIONS&quot;&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5401e94f4440b62a9a27d03fcc9d30b1169f66e8" translate="yes" xml:space="preserve">
          <source>The material below is separated into three main sections: main issues of portability (&lt;a href=&quot;#ISSUES&quot;&gt;ISSUES&lt;/a&gt;), platform-specific issues (&lt;a href=&quot;#PLATFORMS&quot;&gt;PLATFORMS&lt;/a&gt;), and built-in Perl functions that behave differently on various ports (&lt;a href=&quot;#FUNCTION-IMPLEMENTATIONS&quot;&gt;FUNCTION IMPLEMENTATIONS&lt;/a&gt;).</source>
          <target state="translated">아래 자료는 세 가지 주요 섹션으로 나뉩니다. 주요 이식성 &lt;a href=&quot;#ISSUES&quot;&gt;문제&lt;/a&gt; ( ISSUES ), 플랫폼 별 문제 ( &lt;a href=&quot;#PLATFORMS&quot;&gt;PLATFORMS&lt;/a&gt; ) 및 다양한 포트에서 다르게 동작하는 내장 된 Perl 기능 ( &lt;a href=&quot;#FUNCTION-IMPLEMENTATIONS&quot;&gt;기능 구현)&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="6fb16dd0911e0291e015ca052ebafe0545c2d31f" translate="yes" xml:space="preserve">
          <source>The mathematically logical behavior for what matches when inverting is very different from what people expect, so we have decided to forbid it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8bdf4570ce948d9dc30acbc885de4c23118fcd9" translate="yes" xml:space="preserve">
          <source>The maximal stack recursion limit for your system is returned by &lt;code&gt;stack_depth()&lt;/code&gt; and &lt;code&gt;stack_depth_hash()&lt;/code&gt;. The hash limit is usually half the size of the array and ref limit, as the Perl hash API is not optimal.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42a757bded9f533a67a5134eccc21794fdd0b6bd" translate="yes" xml:space="preserve">
          <source>The maximum Unicode code point is &lt;code&gt;U+10FFFF&lt;/code&gt; , and Unicode only defines operations on code points up through that. But Perl works on code points up to the maximum permissible unsigned number available on the platform. However, Perl will not accept these from input streams unless lax rules are being used, and will warn (using the warning category &lt;code&gt;&quot;non_unicode&quot;&lt;/code&gt; , which is a sub-category of &lt;code&gt;&quot;utf8&quot;&lt;/code&gt; ) if any are output.</source>
          <target state="translated">최대 유니 코드 코드 포인트는 &lt;code&gt;U+10FFFF&lt;/code&gt; 이며 유니 코드는이를 통해 코드 포인트에 대한 작업 만 정의합니다. 그러나 Perl은 플랫폼에서 사용 가능한 최대 허용 부호없는 수까지 코드 포인트에서 작동합니다. 그러나 Perl은 lax 규칙을 사용하지 않는 한 입력 스트림에서 이들을 허용하지 않으며 출력되는 경우 경고 범주 ( &lt;code&gt;&quot;non_unicode&quot;&lt;/code&gt; ( &lt;code&gt;&quot;utf8&quot;&lt;/code&gt; 의 하위 범주 ) 사용)를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="b742e9c8b7767f6a214c8234694eb3d1179ce880" translate="yes" xml:space="preserve">
          <source>The maximum Unicode code point is &lt;code&gt;U+10FFFF&lt;/code&gt;, and Unicode only defines operations on code points up through that. But Perl works on code points up to the maximum permissible signed number available on the platform. However, Perl will not accept these from input streams unless lax rules are being used, and will warn (using the warning category &lt;code&gt;&quot;non_unicode&quot;&lt;/code&gt;, which is a sub-category of &lt;code&gt;&quot;utf8&quot;&lt;/code&gt;) if any are output.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ddf34b110c57827c6b09abffd19d7c17fb58a109" translate="yes" xml:space="preserve">
          <source>The maximum number of UTF-8 bytes a single Unicode character can uppercase/lowercase/titlecase/fold into.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6cc1808d3e3fb6de5739d08162d085e4fb2b2c51" translate="yes" xml:space="preserve">
          <source>The maximum number of parallel tests to run at any time. Which tests can be run in parallel is controlled by &lt;code&gt;rules&lt;/code&gt; . The default is to run only one test at a time.</source>
          <target state="translated">언제든지 실행할 최대 병렬 테스트 수입니다. 병렬로 실행할 수있는 테스트는 &lt;code&gt;rules&lt;/code&gt; 의해 제어됩니다 . 기본값은 한 번에 하나의 테스트 만 실행하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="406651585ee02adfd4eadd3dc163e4004c7e7bf5" translate="yes" xml:space="preserve">
          <source>The maximum number of parallel tests to run at any time. Which tests can be run in parallel is controlled by &lt;code&gt;rules&lt;/code&gt;. The default is to run only one test at a time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ec24717c6af4893fa65de730b8ddea405e13134" translate="yes" xml:space="preserve">
          <source>The maximum number this construct can express is &lt;code&gt;\777&lt;/code&gt; . If you need a larger one, you need to use &lt;a href=&quot;perlrebackslash#Octal-escapes&quot;&gt;\o{}&lt;/a&gt; instead. If you meant two separate things, you need to separate them:</source>
          <target state="translated">이 구문이 표현할 수있는 최대 개수는 &lt;code&gt;\777&lt;/code&gt; 입니다. 더 큰 것이 필요하면 대신 &lt;a href=&quot;perlrebackslash#Octal-escapes&quot;&gt;\ o {}&lt;/a&gt; 를 사용해야 합니다. 별개의 두 가지를 의미하는 경우 두 가지를 분리해야합니다.</target>
        </trans-unit>
        <trans-unit id="7227c386d0e30465e8c341c159e2afa8f961c0f3" translate="yes" xml:space="preserve">
          <source>The maximum number this construct can express is &lt;code&gt;\777&lt;/code&gt;. If you need a larger one, you need to use &lt;a href=&quot;perlrebackslash#Octal-escapes&quot;&gt;\o{}&lt;/a&gt; instead. If you meant two separate things, you need to separate them:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="823e727fb7ce51ed0c50f11b0b5dce6f9f8c6422" translate="yes" xml:space="preserve">
          <source>The maximum size of a Storable header is currently 21 bytes. If the provided $buffer is only the first part of a Storable image it should at least be this long to ensure that read_magic() will recognize it as such.</source>
          <target state="translated">Storable 헤더의 최대 크기는 현재 21 바이트입니다. 제공된 $ buffer가 Storable 이미지의 첫 번째 부분 일 경우 read_magic ()이이를 인식 할 수 있도록 최소한이 길이 여야합니다.</target>
        </trans-unit>
        <trans-unit id="54655c72af2839e9f037d863fc7638dac7966cf0" translate="yes" xml:space="preserve">
          <source>The maximum size of an extra field 65535 bytes.</source>
          <target state="translated">추가 필드의 최대 크기는 65535 바이트입니다.</target>
        </trans-unit>
        <trans-unit id="60da8f51a4ded24731bf101a405dc42107509236" translate="yes" xml:space="preserve">
          <source>The maximum size of the Extra Field 65535 bytes.</source>
          <target state="translated">추가 필드 65535 바이트의 최대 크기입니다.</target>
        </trans-unit>
        <trans-unit id="51d29e4ee16b1b5f77f1b62a7cfc84201aec0810" translate="yes" xml:space="preserve">
          <source>The maximum system file descriptor, ordinarily 2. System file descriptors are passed to &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec()&lt;/a&gt;&lt;/code&gt;ed processes, while higher file descriptors are not. Also, during an &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt;, system file descriptors are preserved even if the &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; fails (ordinary file descriptors are closed before the &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; is attempted). The close-on-exec status of a file descriptor will be decided according to the value of &lt;code&gt;$^F&lt;/code&gt; when the corresponding file, pipe, or socket was opened, not the time of the &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">최대 시스템 파일 디스크립터, 일반적으로 2입니다. 시스템 파일 디스크립터는 &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec()&lt;/a&gt;&lt;/code&gt; 프로세스 로 전달 되지만 더 높은 파일 디스크립터는 전달되지 않습니다. 또한 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; 동안 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; 이 실패 하더라도 시스템 파일 디스크립터는 유지됩니다 (일반 파일 디스크립터는 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; 을 시도). 파일 디스크립터의 close-on-exec 상태는 &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec()&lt;/a&gt;&lt;/code&gt; 의 시간이 아니라 해당 파일, 파이프 또는 소켓이 열렸을 때 &lt;code&gt;$^F&lt;/code&gt; 값에 따라 결정됩니다. .</target>
        </trans-unit>
        <trans-unit id="255fcbaa29e8f59e394f504d9d5b97b78390691f" translate="yes" xml:space="preserve">
          <source>The maximum system file descriptor, ordinarily 2. System file descriptors are passed to &lt;code&gt;exec()&lt;/code&gt;ed processes, while higher file descriptors are not. Also, during an &lt;code&gt;open()&lt;/code&gt;, system file descriptors are preserved even if the &lt;code&gt;open()&lt;/code&gt; fails (ordinary file descriptors are closed before the &lt;code&gt;open()&lt;/code&gt; is attempted). The close-on-exec status of a file descriptor will be decided according to the value of &lt;code&gt;$^F&lt;/code&gt; when the corresponding file, pipe, or socket was opened, not the time of the &lt;code&gt;exec()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51e89770735afbf4b1f68a8769fe96140987a421" translate="yes" xml:space="preserve">
          <source>The maximum width of a single UTF-8 encoded character, in bytes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db9125f66ae949d81694c6e6210bfeb871e3d64e" translate="yes" xml:space="preserve">
          <source>The mechanism of translation of &lt;code&gt;\N{...}&lt;/code&gt; escapes is general and not hardwired into</source>
          <target state="translated">&lt;code&gt;\N{...}&lt;/code&gt; 의 번역 메커니즘 이스케이프 은 일반적이며</target>
        </trans-unit>
        <trans-unit id="15610051fc12501695115ef5aed4c6968c7a9267" translate="yes" xml:space="preserve">
          <source>The members whose names begin with &lt;code&gt;int_p_&lt;/code&gt; and &lt;code&gt;int_n_&lt;/code&gt; were added by POSIX.1-2008 and are only available on systems that support them.</source>
          <target state="translated">이름이 &lt;code&gt;int_p_&lt;/code&gt; 및 &lt;code&gt;int_n_&lt;/code&gt; 로 시작하는 멤버 으로 POSIX.1-2008에 의해 추가되었으며 를 지원하는 시스템에서만 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4d5d40b7966fb62c912a4471f016e0810caccade" translate="yes" xml:space="preserve">
          <source>The message attempts to include the name of the called subroutine. If the subroutine has been aliased, the subroutine's original name will be shown, regardless of what name the caller used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="003de5e9e6baa363e9c030caff26155e591e361d" translate="yes" xml:space="preserve">
          <source>The message for the diag.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="09a832ceb4e1a37f34e093f08ce43b0057c15482" translate="yes" xml:space="preserve">
          <source>The message for the note.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e0974f2e5536c89d5a7aa01e203cfd55eb3c162" translate="yes" xml:space="preserve">
          <source>The message will be taken from whatever locale would be used by &lt;code&gt;$!&lt;/code&gt;, and will be encoded in the SV in whatever manner would be used by &lt;code&gt;$!&lt;/code&gt;. The details of this process are subject to future change. Currently, the message is taken from the C locale by default (usually producing an English message), and from the currently selected locale when in the scope of the &lt;code&gt;use locale&lt;/code&gt; pragma. A heuristic attempt is made to decode the message from the locale's character encoding, but it will only be decoded as either UTF-8 or ISO-8859-1. It is always correctly decoded in a UTF-8 locale, usually in an ISO-8859-1 locale, and never in any other locale.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36545165ac282d6d6bbbc3b54b056ad82f2d5183" translate="yes" xml:space="preserve">
          <source>The message, either sent via &lt;code&gt;datasend&lt;/code&gt; or as the &lt;code&gt;MESSAGE&lt;/code&gt; parameter, must be in the format as described by RFC822 and must contain From:, Newsgroups: and Subject: headers.</source>
          <target state="translated">메시지를 통해 전송 &lt;code&gt;datasend&lt;/code&gt; 또는 &lt;code&gt;MESSAGE&lt;/code&gt; 매개 변수 로 는 RFC822에 설명 된 형식이어야하며 From :, Newsgroups : 및 Subject : 헤더를 포함해야합니다.</target>
        </trans-unit>
        <trans-unit id="ee89b7499807e434bb5f68dbb5e73957271240a3" translate="yes" xml:space="preserve">
          <source>The messages are in alphabetical order, without regard to upper or lower-case. Some of these messages are generic. Spots that vary are denoted with a %s or other printf-style escape. These escapes are ignored by the alphabetical order, as are all characters other than letters. To look up your message, just ignore anything that is not a letter.</source>
          <target state="translated">메시지는 대문자 또는 소문자와 상관없이 알파벳 순서로되어 있습니다. 이러한 메시지 중 일부는 일반적인 것입니다. 다양한 스팟은 % s 또는 다른 printf 스타일 이스케이프로 표시됩니다. 이스케이프는 문자 이외의 모든 문자와 마찬가지로 알파벳 순서로 무시됩니다. 메시지를 찾으려면 글자가 아닌 것을 무시하십시오.</target>
        </trans-unit>
        <trans-unit id="e3b332cdd50b0075e2980a517442567c35047868" translate="yes" xml:space="preserve">
          <source>The messages from error exits from inside the Perl core are generally more serious, and are not suppressed.</source>
          <target state="translated">Perl 코어 내부의 오류 엑시트 메시지는 일반적으로 더 심각하며 억제되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f4b9735187b885f7dd604f43a0be8de295177167" translate="yes" xml:space="preserve">
          <source>The meta facet contains all the meta-data attached to the event. In this case the &lt;code&gt;details&lt;/code&gt; field has no special meaning, but may be present if something sets the 'details' meta-key on the event.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af14bb7cef38c681cd522700a18f3c2e85c4645f" translate="yes" xml:space="preserve">
          <source>The metacharacter &lt;code&gt;&quot;|&quot;&lt;/code&gt; is used to match one thing or another. Thus</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1808948aa8eaa300120a3b2e59e72e75d61ea383" translate="yes" xml:space="preserve">
          <source>The metaconfig system has its own git repository. Please see its README file in &lt;a href=&quot;http://perl5.git.perl.org/metaconfig.git/&quot;&gt;http://perl5.git.perl.org/metaconfig.git/&lt;/a&gt; for more details.</source>
          <target state="translated">메타 설정 시스템에는 자체 자식 저장소가 있습니다. &lt;a href=&quot;http://perl5.git.perl.org/metaconfig.git/&quot;&gt;http://perl5.git.perl.org/metaconfig.git/&lt;/a&gt; 의 README 파일을 참조 하십시오 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="bc1a65f602d496a5d44a6f0eb65c069b2917da93" translate="yes" xml:space="preserve">
          <source>The metaconfig system has its own git repository. Please see its README file in &lt;a href=&quot;https://github.com/Perl/metaconfig&quot;&gt;https://github.com/Perl/metaconfig&lt;/a&gt; for more details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef4d1d7707c31f137e3be5c9c3439a6616b37606" translate="yes" xml:space="preserve">
          <source>The metadata structure is a data element of type Map. This section describes valid keys within the Map.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57044926f6935330105dc7655b75810e4319d78e" translate="yes" xml:space="preserve">
          <source>The metanotation &lt;code&gt;a{b,c,d}e&lt;/code&gt; is a shorthand for &lt;code&gt;abe ace ade&lt;/code&gt; . Left to right order is preserved, with results of matches being sorted separately at a low level to preserve this order. As a special case &lt;code&gt;{&lt;/code&gt;, &lt;code&gt;}&lt;/code&gt;, and &lt;code&gt;{}&lt;/code&gt; are passed undisturbed.</source>
          <target state="translated">메타 노테이션 &lt;code&gt;a{b,c,d}e&lt;/code&gt; 는 &lt;code&gt;abe ace ade&lt;/code&gt; 의 약자입니다 . 왼쪽에서 오른쪽 순서는 유지되며 일치하는 결과는이 순서를 유지하기 위해 낮은 수준에서 개별적으로 정렬됩니다. 특별한 경우로 &lt;code&gt;{&lt;/code&gt; , &lt;code&gt;}&lt;/code&gt; 및 &lt;code&gt;{}&lt;/code&gt; 은 그대로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="9487974ec391513333e9625acd21a3a26e0c7e56" translate="yes" xml:space="preserve">
          <source>The metanotation &lt;code&gt;a{b,c,d}e&lt;/code&gt; is a shorthand for &lt;code&gt;abe ace ade&lt;/code&gt;. Left to right order is preserved, with results of matches being sorted separately at a low level to preserve this order. As a special case &lt;code&gt;{&lt;/code&gt;, &lt;code&gt;}&lt;/code&gt;, and &lt;code&gt;{}&lt;/code&gt; are passed undisturbed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3047e3773833dff832f2198e8a9edf5e427dcdc4" translate="yes" xml:space="preserve">
          <source>The method &lt;b&gt;simplify_name&lt;/b&gt; is equivalent to &lt;b&gt;basename&lt;/b&gt;, but also strips Perl-like extensions (.pm, .pl, .pod) and extensions like</source>
          <target state="translated">&lt;b&gt;단순화&lt;/b&gt; _ 이름 방법 은 &lt;b&gt;basename&lt;/b&gt; 과 동일 하지만 Perl과 유사한 확장자 (.pm, .pl, .pod)와 같은 확장자를 제거합니다.</target>
        </trans-unit>
        <trans-unit id="81b66f93d3069f9e60e8cef6e91ea8cf83a141d7" translate="yes" xml:space="preserve">
          <source>The method &lt;code&gt;pretty&lt;/code&gt; is doing object-to-string conversion, so it is natural to overload the operator &lt;code&gt;&quot;&quot;&lt;/code&gt; using this method. However, inside such a method it is not necessary to pretty-print the</source>
          <target state="translated">방법은 &lt;code&gt;pretty&lt;/code&gt; 는 연산자를 오버로드 자연하므로, 객체를 문자열로 변환하고있다 &lt;code&gt;&quot;&quot;&lt;/code&gt; 이 방법을 사용. 그러나 그러한 방법 내에서 예쁘게 인쇄 할 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="a6763bc5ce44c1cfaff83e339121fc03fa4b9167" translate="yes" xml:space="preserve">
          <source>The method &lt;code&gt;survey&lt;/code&gt; searches for POD documents in a given set of files and/or directories. This runs the search according to the various options set by the accessors above. (For example, if the &lt;code&gt;inc&lt;/code&gt; attribute is on, as it is by default, then the perl @INC directories are implicitly added to the list of directories (if any) that you specify.)</source>
          <target state="translated">방법 &lt;code&gt;survey&lt;/code&gt; 는 주어진 파일 및 / 또는 디렉토리 세트에서 POD 문서를 검색합니다. 위의 접근자가 설정 한 다양한 옵션에 따라 검색을 실행합니다. 예를 들어, &lt;code&gt;inc&lt;/code&gt; 속성이 켜져있는 경우 기본적으로 perl @INC 디렉토리는 사용자가 지정한 디렉토리 목록 (있는 경우)에 내재적으로 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="c2594fdbf7af0dec9dd0b0469d5ba6b9ac83d4b7" translate="yes" xml:space="preserve">
          <source>The method forms return the object itself when called with arguments, so that they can be chained together nicely.</source>
          <target state="translated">메소드 폼은 인자와 함께 호출 될 때 객체 자체를 반환하므로 서로 잘 연결될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2dce83e2cc72bad00d236d5c3647c5845395811f" translate="yes" xml:space="preserve">
          <source>The method invoked by the command &lt;code&gt;&lt;a href=&quot;../functions/tie&quot;&gt;tie&lt;/a&gt; $scalar, classname&lt;/code&gt; . Associates a new scalar instance with the specified class. &lt;code&gt;LIST&lt;/code&gt; would represent additional arguments (along the lines of &lt;a href=&quot;../anydbm_file&quot;&gt;AnyDBM_File&lt;/a&gt; and compatriots) needed to complete the association.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../functions/tie&quot;&gt;tie&lt;/a&gt; $scalar, classname&lt;/code&gt; 명령으로 호출 된 메소드 . 새 스칼라 인스턴스를 지정된 클래스와 연관시킵니다. &lt;code&gt;LIST&lt;/code&gt; 는 추가 인수를 나타냅니다 ( &lt;a href=&quot;../anydbm_file&quot;&gt;AnyDBM_File&lt;/a&gt; 행과 함께 연결을 완료하는 데 필요한 및 compatriots .</target>
        </trans-unit>
        <trans-unit id="1329855cb3bc4e49bb5ad4447529605d17972380" translate="yes" xml:space="preserve">
          <source>The method invoked by the command &lt;code&gt;&lt;a href=&quot;../functions/tie&quot;&gt;tie&lt;/a&gt; %hash, classname&lt;/code&gt; . Associates a new hash instance with the specified class. &lt;code&gt;LIST&lt;/code&gt; would represent additional arguments (along the lines of &lt;a href=&quot;../anydbm_file&quot;&gt;AnyDBM_File&lt;/a&gt; and compatriots) needed to complete the association.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../functions/tie&quot;&gt;tie&lt;/a&gt; %hash, classname&lt;/code&gt; 명령으로 호출 된 메소드 . 새 해시 인스턴스를 지정된 클래스와 연결합니다. &lt;code&gt;LIST&lt;/code&gt; 는 연결을 완료하는 데 필요한 추가 인수 ( &lt;a href=&quot;../anydbm_file&quot;&gt;AnyDBM_File&lt;/a&gt; 및 compatriots 행)를 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="f4e115efd5b349da6e5daf0e7907f6b8a0251fea" translate="yes" xml:space="preserve">
          <source>The method invoked by the command &lt;code&gt;&lt;a href=&quot;../functions/tie&quot;&gt;tie&lt;/a&gt; *glob, classname&lt;/code&gt; . Associates a new glob instance with the specified class. &lt;code&gt;LIST&lt;/code&gt; would represent additional arguments (along the lines of &lt;a href=&quot;../anydbm_file&quot;&gt;AnyDBM_File&lt;/a&gt; and compatriots) needed to complete the association.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../functions/tie&quot;&gt;tie&lt;/a&gt; *glob, classname&lt;/code&gt; 명령으로 호출 된 메소드 . 새 glob 인스턴스를 지정된 클래스와 연관시킵니다. &lt;code&gt;LIST&lt;/code&gt; 는 추가 인수를 나타냅니다 ( &lt;a href=&quot;../anydbm_file&quot;&gt;AnyDBM_File&lt;/a&gt; 행과 함께 연결을 완료하는 데 필요한 및 compatriots .</target>
        </trans-unit>
        <trans-unit id="3c64476d97600b750453bf420a9f4075f0306d1d" translate="yes" xml:space="preserve">
          <source>The method invoked by the command &lt;code&gt;tie $scalar, classname&lt;/code&gt;. Associates a new scalar instance with the specified class. &lt;code&gt;LIST&lt;/code&gt; would represent additional arguments (along the lines of &lt;a href=&quot;anydbm_file&quot;&gt;AnyDBM_File&lt;/a&gt; and compatriots) needed to complete the association.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="faf56df28d8dc9b4d15467c9f598303b09011b2d" translate="yes" xml:space="preserve">
          <source>The method invoked by the command &lt;code&gt;tie %hash, classname&lt;/code&gt;. Associates a new hash instance with the specified class. &lt;code&gt;LIST&lt;/code&gt; would represent additional arguments (along the lines of &lt;a href=&quot;anydbm_file&quot;&gt;AnyDBM_File&lt;/a&gt; and compatriots) needed to complete the association.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ef7e6fea27b8c9527a2ee7d3c51ad487105105d" translate="yes" xml:space="preserve">
          <source>The method invoked by the command &lt;code&gt;tie *glob, classname&lt;/code&gt;. Associates a new glob instance with the specified class. &lt;code&gt;LIST&lt;/code&gt; would represent additional arguments (along the lines of &lt;a href=&quot;anydbm_file&quot;&gt;AnyDBM_File&lt;/a&gt; and compatriots) needed to complete the association.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf5b5c7ccd1b01e888481ba1e2326ba23ba62558" translate="yes" xml:space="preserve">
          <source>The method may be called as a function (this is the legacy interface) and will then use a singleton as invocant.</source>
          <target state="translated">이 메소드는 함수 (이것은 레거시 인터페이스 임)로 호출 될 수 있으며 단일 톤을 호출자로 사용합니다.</target>
        </trans-unit>
        <trans-unit id="a347cbeea5ef9dc7aa2915d6eb1498ed186d3546" translate="yes" xml:space="preserve">
          <source>The method must then return the object. While technically you can return any Perl scalar, you might have to enable the &lt;code&gt;allow_nonref&lt;/code&gt; setting to make that work in all cases, so better return an actual blessed reference.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="219560b3e009187526f9cca6647b331f9670e08d" translate="yes" xml:space="preserve">
          <source>The method takes care not to use a HERE-doc end marker that appears in the typemap string itself.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e8494bae7398a8984704473fee4ce9cba1c67c3" translate="yes" xml:space="preserve">
          <source>The methods &lt;code&gt;UNTIE&lt;/code&gt; and &lt;code&gt;DESTROY&lt;/code&gt; are not defined in &lt;b&gt;Tie::Hash&lt;/b&gt;, &lt;b&gt;Tie::StdHash&lt;/b&gt;, or &lt;b&gt;Tie::ExtraHash&lt;/b&gt;. Tied hashes do not require presence of these methods, but if defined, the methods will be called in proper time, see &lt;a href=&quot;../perltie&quot;&gt;perltie&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;UNTIE&lt;/code&gt; 및 &lt;code&gt;DESTROY&lt;/code&gt; 메소드 는 &lt;b&gt;Tie :: Hash&lt;/b&gt; , &lt;b&gt;Tie :: StdHash&lt;/b&gt; 또는 &lt;b&gt;Tie :: ExtraHash에&lt;/b&gt; 정의되어 있지 않습니다 . 묶음 해시는 이러한 메소드가 필요하지 않지만 정의 된 경우 적절한 시간에 메소드가 호출됩니다 ( &lt;a href=&quot;../perltie&quot;&gt;perltie&lt;/a&gt; 참조) .</target>
        </trans-unit>
        <trans-unit id="ef8892a6c7e1ed9417668a258714fa58aaa9de51" translate="yes" xml:space="preserve">
          <source>The methods &lt;code&gt;UNTIE&lt;/code&gt; and &lt;code&gt;DESTROY&lt;/code&gt; are not defined in &lt;b&gt;Tie::Hash&lt;/b&gt;, &lt;b&gt;Tie::StdHash&lt;/b&gt;, or &lt;b&gt;Tie::ExtraHash&lt;/b&gt;. Tied hashes do not require presence of these methods, but if defined, the methods will be called in proper time, see &lt;a href=&quot;perltie&quot;&gt;perltie&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb0efdfb2d42a690264f248f711dbbf09fd69f9a" translate="yes" xml:space="preserve">
          <source>The methods POP, PUSH, SHIFT, UNSHIFT, SPLICE, DELETE, and EXISTS are required if the perl operator with the corresponding (but lowercase) name is to operate on the tied array. The &lt;b&gt;Tie::Array&lt;/b&gt; class can be used as a base class to implement the first five of these in terms of the basic methods above. The default implementations of DELETE and EXISTS in &lt;b&gt;Tie::Array&lt;/b&gt; simply &lt;code&gt;croak&lt;/code&gt; .</source>
          <target state="translated">해당 (그러나 소문자) 이름을 가진 perl 연산자가 연결된 배열에서 작동하려면 POP, PUSH, SHIFT, UNSHIFT, SPLICE, DELETE 및 EXISTS 방법이 필요합니다. &lt;b&gt;타이 :: 배열&lt;/b&gt; 클래스는 위의 기본적인 방법의 측면에서 이들의 처음 다섯을 구현하는 기본 클래스로 사용할 수 있습니다. &lt;b&gt;Tie :: Array&lt;/b&gt; 에서 DELETE 및 EXISTS의 기본 구현은 간단하게 &lt;code&gt;croak&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="c4a5e54d75cc63679c6ace9898dabb0095727d66" translate="yes" xml:space="preserve">
          <source>The methods POP, PUSH, SHIFT, UNSHIFT, SPLICE, DELETE, and EXISTS are required if the perl operator with the corresponding (but lowercase) name is to operate on the tied array. The &lt;b&gt;Tie::Array&lt;/b&gt; class can be used as a base class to implement the first five of these in terms of the basic methods above. The default implementations of DELETE and EXISTS in &lt;b&gt;Tie::Array&lt;/b&gt; simply &lt;code&gt;croak&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ca020c3e2bd3840f09ecda9c60cedd92ab50da2" translate="yes" xml:space="preserve">
          <source>The methods associated with a file might include &lt;code&gt;&lt;a href=&quot;functions/rename&quot;&gt;rename()&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/write&quot;&gt;write()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">파일과 관련된 메소드에는 &lt;code&gt;&lt;a href=&quot;functions/rename&quot;&gt;rename()&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;functions/write&quot;&gt;write()&lt;/a&gt;&lt;/code&gt; 가 포함될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9038e299e83dde3b869fda0661c2f473ffe7af89" translate="yes" xml:space="preserve">
          <source>The methods associated with a file might include &lt;code&gt;rename()&lt;/code&gt; and &lt;code&gt;write()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5263ae238fdcff040734aa4eb38a1f937d29acc1" translate="yes" xml:space="preserve">
          <source>The methods make the assumption that there are 24 hours in a day, 7 days in a week, 365.24225 days in a year and 12 months in a year. (from The Calendar FAQ at &lt;a href=&quot;http://www.tondering.dk/claus/calendar.html&quot;&gt;http://www.tondering.dk/claus/calendar.html&lt;/a&gt;)</source>
          <target state="translated">이 방법은 하루 24 시간, 주 7 일, 1 년 365.24225 일, 1 년에 12 개월이 있다고 가정합니다. ( &lt;a href=&quot;http://www.tondering.dk/claus/calendar.html&quot;&gt;http://www.tondering.dk/claus/calendar.html&lt;/a&gt; 의 캘린더 FAQ에서 )</target>
        </trans-unit>
        <trans-unit id="f3937d8a57bcf6a9fc84c7bb1157e33f7b1b81bb" translate="yes" xml:space="preserve">
          <source>The methods make the assumption that there are 24 hours in a day, 7 days in a week, 365.24225 days in a year and 12 months in a year. (from The Calendar FAQ at http://www.tondering.dk/claus/calendar.html)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59cd0464641ff6280d0d7597be80f4d79435c372" translate="yes" xml:space="preserve">
          <source>The methods provided by this package are designed to be used in conjunction with &lt;a href=&quot;ExtUtils::MakeMaker&quot;&gt;ExtUtils::MakeMaker&lt;/a&gt;. When MakeMaker writes a Makefile, it creates one or more objects that inherit their methods from a package &lt;a href=&quot;ExtUtils::MM&quot;&gt;MM&lt;/a&gt;. MM itself doesn't provide any methods, but it ISA ExtUtils::MM_Unix class. The inheritance tree of MM lets operating specific packages take the responsibility for all the methods provided by MM_Unix. We are trying to reduce the number of the necessary overrides by defining rather primitive operations within ExtUtils::MM_Unix.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04b489e4d842d7bd01e6f982c6cbb73f631b2bc2" translate="yes" xml:space="preserve">
          <source>The methods provided by this package are designed to be used in conjunction with ExtUtils::MakeMaker. When MakeMaker writes a Makefile, it creates one or more objects that inherit their methods from a package &lt;code&gt;MM&lt;/code&gt; . MM itself doesn't provide any methods, but it ISA ExtUtils::MM_Unix class. The inheritance tree of MM lets operating specific packages take the responsibility for all the methods provided by MM_Unix. We are trying to reduce the number of the necessary overrides by defining rather primitive operations within ExtUtils::MM_Unix.</source>
          <target state="translated">이 패키지에서 제공하는 방법은 ExtUtils :: MakeMaker와 함께 사용하도록 설계되었습니다. MakeMaker가 Makefile을 작성할 때 패키지 &lt;code&gt;MM&lt;/code&gt; 에서 메소드를 상속하는 하나 이상의 오브젝트를 작성합니다. . MM 자체는 메서드를 제공하지 않지만 ISA ExtUtils :: MM_Unix 클래스입니다. MM의 상속 트리를 사용하면 특정 패키지를 운영 할 때 MM_Unix에서 제공하는 모든 방법을 책임집니다. ExtUtils :: MM_Unix 내에서 다소 원시적 인 작업을 정의하여 필요한 재정의 횟수를 줄이려고합니다.</target>
        </trans-unit>
        <trans-unit id="8c66ae4f45a17e24ec4e91baabbe3addbe06fe69" translate="yes" xml:space="preserve">
          <source>The methods return a status value. All return 0 on success. All return -1 to signify an error and set &lt;code&gt;$!&lt;/code&gt; to the exact error code. The return code 1 generally (but not always) means that the key specified did not exist in the database.</source>
          <target state="translated">메소드는 상태 값을 리턴합니다. 성공하면 모두 0을 반환합니다. 모두 -1을 반환하여 오류를 나타내고 &lt;code&gt;$!&lt;/code&gt; 를 설정합니다 . 정확한 오류 코드. 리턴 코드 1은 일반적으로 (항상 그런 것은 아님) 지정된 키가 데이터베이스에 존재하지 않았 음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="fbd4260de22fedf44d365a30940fb70d70e7661e" translate="yes" xml:space="preserve">
          <source>The methods return true if the argument is positive or negative, respectively. &lt;code&gt;NaN&lt;/code&gt; is neither positive nor negative, while &lt;code&gt;+inf&lt;/code&gt; counts as positive, and &lt;code&gt;-inf&lt;/code&gt; is negative. A &lt;code&gt;zero&lt;/code&gt; is neither positive nor negative.</source>
          <target state="translated">인수가 각각 양수 또는 음수이면 메소드는 true를 리턴합니다. &lt;code&gt;NaN&lt;/code&gt; 은 양수도 음수도 아닌 반면 &lt;code&gt;+inf&lt;/code&gt; 는 양수로 계산되며 &lt;code&gt;-inf&lt;/code&gt; 는 음수입니다. &lt;code&gt;zero&lt;/code&gt; 도 긍정적이나 부정적이다.</target>
        </trans-unit>
        <trans-unit id="6c2ef40bc1a0b74efb3bfbccd9cee9239eba6f64" translate="yes" xml:space="preserve">
          <source>The midpoint between London and Tokyo being</source>
          <target state="translated">런던과 도쿄의 중간 점</target>
        </trans-unit>
        <trans-unit id="bbcb1c9041fb73d5b33a27311e97c3d17c5b0e33" translate="yes" xml:space="preserve">
          <source>The minimal implementation of the package &lt;code&gt;MyMaths&lt;/code&gt; would be something like this:</source>
          <target state="translated">&lt;code&gt;MyMaths&lt;/code&gt; 패키지의 최소 구현은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3d4726f2195d659bbd07fd552c77e45ca0215cb6" translate="yes" xml:space="preserve">
          <source>The minimal length of the match.</source>
          <target state="translated">경기의 최소 길이입니다.</target>
        </trans-unit>
        <trans-unit id="4d621dfdcd896d4c7f5ef5df72bf41823f001388" translate="yes" xml:space="preserve">
          <source>The minimal string that will allow both the start of the string &lt;code&gt;'^'&lt;/code&gt; and the alternation to match is &lt;code&gt;Th&lt;/code&gt;, with the alternation &lt;code&gt;e|r&lt;/code&gt; matching &lt;code&gt;'e'&lt;/code&gt;. The second quantifier &lt;code&gt;.*&lt;/code&gt; is free to gobble up the rest of the string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a86715e4677adbc552d12f74a0aff8aa19f9b9f" translate="yes" xml:space="preserve">
          <source>The minimal string that will allow both the start of the string &lt;code&gt;^&lt;/code&gt; and the alternation to match is &lt;code&gt;Th&lt;/code&gt; , with the alternation &lt;code&gt;e|r&lt;/code&gt; matching &lt;code&gt;e&lt;/code&gt; . The second quantifier &lt;code&gt;.*&lt;/code&gt; is free to gobble up the rest of the string.</source>
          <target state="translated">문자열의 시작을 모두 수행 할 최소한의 문자열 &lt;code&gt;^&lt;/code&gt; 매치에 교대는 &lt;code&gt;Th&lt;/code&gt; 배타로, &lt;code&gt;e|r&lt;/code&gt; 일치하는 &lt;code&gt;e&lt;/code&gt; . 두 번째 수량 자 &lt;code&gt;.*&lt;/code&gt; 는 나머지 문자열을 자유롭게 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="42ee81d06f4fac118ea52fe7a6d4f7afb844e686" translate="yes" xml:space="preserve">
          <source>The minimum prerequisites for the distribution, to which dynamic configuration will only add items</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e954716b49cb8b56dd5f1434ce35c364bc034cbd" translate="yes" xml:space="preserve">
          <source>The minimum required version of Perl for this distribution.</source>
          <target state="translated">이 배포에 필요한 Perl의 최소 필수 버전입니다.</target>
        </trans-unit>
        <trans-unit id="8f285323eacf0d3787ce2842089aae064f612899" translate="yes" xml:space="preserve">
          <source>The minimum severity level set by &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; in &lt;code&gt;PERL_VMS_POSIX_EXIT&lt;/code&gt; mode may be changed to be ERROR or higher in the future depending on the results of testing and further review.</source>
          <target state="translated">&lt;code&gt;PERL_VMS_POSIX_EXIT&lt;/code&gt; 모드 에서 &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; 로 설정 한 최소 심각도 수준 은 테스트 결과 및 추가 검토 결과에 따라 향후 ERROR 이상으로 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a1189f16cd283f7a0c83693c3d814114bd713075" translate="yes" xml:space="preserve">
          <source>The minimum severity level set by &lt;code&gt;die&lt;/code&gt; in &lt;code&gt;PERL_VMS_POSIX_EXIT&lt;/code&gt; mode may be changed to be ERROR or higher in the future depending on the results of testing and further review.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0eb7e9cbc117a074d8972fb43eb29ea9f494777" translate="yes" xml:space="preserve">
          <source>The minimum string length (in characters) required for the pattern to match. This is used to prune the search space by not bothering to match any closer to the end of a string than would allow a match. For instance there is no point in even starting the regex engine if the minlen is 10 but the string is only 5 characters long. There is no way that the pattern can match.</source>
          <target state="translated">패턴이 일치하는 데 필요한 최소 문자열 길이 (문자)입니다. 일치하는 것을 허용하는 것보다 문자열의 끝에 더 가깝게 일치시키지 않고 검색 공간을 제거하는 데 사용됩니다. 예를 들어 minlen이 10이지만 문자열 길이가 5자인 경우 정규식 엔진을 시작할 때조차 아무런 의미가 없습니다. 패턴이 일치 할 방법이 없습니다.</target>
        </trans-unit>
        <trans-unit id="210162554d25993f24361ef0d0eb6d7705ae9f1e" translate="yes" xml:space="preserve">
          <source>The mkpath() function provide the legacy interface of make_path() with a different interpretation of the arguments passed. The behaviour and return value of the function is otherwise identical to make_path().</source>
          <target state="translated">mkpath () 함수는 make_path ()의 레거시 인터페이스에 전달 된 인수에 대한 다른 해석을 제공합니다. 함수의 동작 및 반환 값은 그렇지 않으면 make_path ()와 동일합니다.</target>
        </trans-unit>
        <trans-unit id="06ad56158c8fa5ced75a1aebddb172710774c3d6" translate="yes" xml:space="preserve">
          <source>The mode argument should be a string as would be passed to fopen/PerlIO_open. If it is NULL then - for legacy support - the code will (depending upon the platform and the implementation) either attempt to empirically determine the mode in which</source>
          <target state="translated">모드 인수는 fopen / PerlIO_open에 전달 될 문자열이어야합니다. NULL 인 경우-레거시 지원의 경우-플랫폼 및 구현에 따라 코드는 경험적으로 모드를 결정하려고 시도합니다.</target>
        </trans-unit>
        <trans-unit id="a3c9e181407a3d8dbcbede503e296bb6515c64a6" translate="yes" xml:space="preserve">
          <source>The modern convention for OO modules is to always use &lt;code&gt;new&lt;/code&gt; as the name for the constructor, but there is no requirement to do so. Any subroutine that blesses a data structure into a class is a valid constructor in Perl.</source>
          <target state="translated">OO 모듈에 대한 최신 규칙은 항상 &lt;code&gt;new&lt;/code&gt; 를 생성자의 이름으로 사용하는 것이지만 그렇게 할 필요는 없습니다. 데이터 구조를 클래스로 축복하는 모든 서브 루틴은 Perl의 유효한 생성자입니다.</target>
        </trans-unit>
        <trans-unit id="3447af7744c6d54de16c62d9254e4d7db34879e8" translate="yes" xml:space="preserve">
          <source>The modern successor of &lt;code&gt;CJK.inf&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a53357f11465725d38d814ff941d393401ed024" translate="yes" xml:space="preserve">
          <source>The module</source>
          <target state="translated">모듈</target>
        </trans-unit>
        <trans-unit id="73f13a2108211624409b0cfacd9ef18c01b16a7a" translate="yes" xml:space="preserve">
          <source>The module &lt;a href=&quot;Perl::Unsafe::Signals&quot;&gt;Perl::Unsafe::Signals&lt;/a&gt; is used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39e5705c3d4c65fd8c41a20a40b57ad45ad89ac2" translate="yes" xml:space="preserve">
          <source>The module actually implements most of an interface described by Larry Wall on the perl5-porters mailing list here: &lt;a href=&quot;http://www.xray.mpe.mpg.de/mailing-lists/perl5-porters/2000-01/msg00241.html&quot;&gt;http://www.xray.mpe.mpg.de/mailing-lists/perl5-porters/2000-01/msg00241.html&lt;/a&gt;</source>
          <target state="translated">이 모듈은 실제로 perl5-porters 메일 링리스트에서 Larry Wall이 설명하는 대부분의 인터페이스를 구현합니다. &lt;a href=&quot;http://www.xray.mpe.mpg.de/mailing-lists/perl5-porters/2000-01/msg00241.html&quot;&gt;http://www.xray.mpe.mpg.de/mailing-lists/perl5-porters/2000-01/msg00241.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="cbe2b6eee3b2ebdf5395a20e5b4843961160d7fa" translate="yes" xml:space="preserve">
          <source>The module actually implements most of an interface described by Larry Wall on the perl5-porters mailing list here: &lt;a href=&quot;https://www.nntp.perl.org/group/perl.perl5.porters/2000/01/msg5283.html&quot;&gt;https://www.nntp.perl.org/group/perl.perl5.porters/2000/01/msg5283.html&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4eac150fbe415255f3cdb34d1744497bc9492853" translate="yes" xml:space="preserve">
          <source>The module also lets you save intermediate SHA states to a string. The</source>
          <target state="translated">이 모듈을 사용하면 중간 SHA 상태를 문자열에 저장할 수도 있습니다. 그만큼</target>
        </trans-unit>
        <trans-unit id="ee711fa1cc9e23459ad1dea67a4bc2640b9361b2" translate="yes" xml:space="preserve">
          <source>The module and its user have a contract, part of which is common law, and part of which is &quot;written&quot;. Part of the common law contract is that a module doesn't pollute any namespace it wasn't asked to. The written contract for the module (A.K.A. documentation) may make other provisions. But then you know when you &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; RedefineTheWorld&lt;/code&gt; that you're redefining the world and willing to take the consequences.</source>
          <target state="translated">모듈과 그 사용자는 계약을 가지고 있으며, 그 중 일부는 관습법이며 일부는 &quot;작성&quot;되어 있습니다. 관습법 계약의 일부는 모듈이 요청하지 않은 네임 스페이스를 오염시키지 않는다는 것입니다. 모듈에 대한 서면 계약 (AKA 문서)은 다른 조항을 만들 수 있습니다. 그러나 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; RedefineTheWorld&lt;/code&gt; 를 &lt;a href=&quot;functions/use&quot;&gt;사용할&lt;/a&gt; 때 세상을 재정의하고 결과를 기꺼이 감수한다는 것을 알고 있습니다.</target>
        </trans-unit>
        <trans-unit id="9372253e447b67364ad520e524aa1e247f7dc577" translate="yes" xml:space="preserve">
          <source>The module and its user have a contract, part of which is common law, and part of which is &quot;written&quot;. Part of the common law contract is that a module doesn't pollute any namespace it wasn't asked to. The written contract for the module (A.K.A. documentation) may make other provisions. But then you know when you &lt;code&gt;use RedefineTheWorld&lt;/code&gt; that you're redefining the world and willing to take the consequences.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0f631dbc58be0710de0b64e0128de801aadc778" translate="yes" xml:space="preserve">
          <source>The module appropriate for the current OS is automatically loaded by File::Spec. Since some modules (like VMS) make use of facilities available only under that OS, it may not be possible to load all modules under all operating systems.</source>
          <target state="translated">현재 OS에 적합한 모듈은 File :: Spec에 의해 자동으로로드됩니다. VMS와 같은 일부 모듈은 해당 OS에서만 사용 가능한 기능을 사용하므로 모든 운영 체제에서 모든 모듈을로드하지 못할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f14f53ac2830f28434b0714747d843bf7a9d032c" translate="yes" xml:space="preserve">
          <source>The module author loves to hear how &lt;code&gt;autodie&lt;/code&gt; has made your life better (or worse). Feedback can be sent to &amp;lt;pjf@perltraining.com.au&amp;gt;.</source>
          <target state="translated">모듈 작성자는 &lt;code&gt;autodie&lt;/code&gt; 가 어떻게 당신의 인생을 더 좋게 (또는 더 나쁘게) 만들 었는지 듣고 싶어 합니다. 피드백은 &amp;lt;pjf@perltraining.com.au&amp;gt;로 보낼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="64e716d94d3201717e95856fa71dba02b691c1e4" translate="yes" xml:space="preserve">
          <source>The module functionality relies on symbolic references, so things will break under 'use strict' unless 'no strict &quot;refs&quot;' is also specified.</source>
          <target state="translated">모듈 기능은 기호 참조를 사용하므로 '엄격한 &quot;참조&quot;도 지정하지 않으면'엄격한 사용 '에서 문제가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="0003d7a83a288e163c978c48b4832ab6428ef2d5" translate="yes" xml:space="preserve">
          <source>The module is not entirely round-trip safe: For example it currently simply strips all comments. The order of entries in the maps is, however, preserved.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34dfe6e94b964deab3088dd9f024d26797644959" translate="yes" xml:space="preserve">
          <source>The module is used to replace common UNIX commands. In all cases the functions work from @ARGV rather than taking arguments. This makes them easier to deal with in Makefiles. Call them like this:</source>
          <target state="translated">이 모듈은 일반적인 UNIX 명령을 대체하는 데 사용됩니다. 모든 경우에 함수는 인수를 취하는 것이 아니라 @ARGV에서 작동합니다. 이렇게하면 Makefile에서 다루기가 더 쉬워집니다. 다음과 같이 호출하십시오.</target>
        </trans-unit>
        <trans-unit id="7b2c2d003f5a465317ebb185dd8468c1c69f2ab8" translate="yes" xml:space="preserve">
          <source>The module itself never broke, you do not need to upgrade.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a785d24a660af5bf727090a58cdad6783dbc670b" translate="yes" xml:space="preserve">
          <source>The module itself works fine, there is no need to upgrade.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c671baea2f821aba32cfc72c5c947bba8fda15dc" translate="yes" xml:space="preserve">
          <source>The module might issue the following warnings:</source>
          <target state="translated">모듈은 다음 경고를 발행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="06580747828c7d751b4066d4d4c51e0e99e3ed97" translate="yes" xml:space="preserve">
          <source>The module that implements the canned filter can take one of two forms. Here is a template for the first</source>
          <target state="translated">캔 필터를 구현하는 모듈은 두 가지 형식 중 하나를 취할 수 있습니다. 첫 번째 템플릿은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="aa3f15cb2c51087f06437c33aa4d5adadaa3850c" translate="yes" xml:space="preserve">
          <source>The module will auto-detect which, if any, of the supported compression formats is being used.</source>
          <target state="translated">모듈은 지원되는 압축 형식 중 어떤 것이 사용되는지 자동 감지합니다.</target>
        </trans-unit>
        <trans-unit id="f166adc5fd8c563e508f523c65a82ae50be2d86f" translate="yes" xml:space="preserve">
          <source>The month (&lt;code&gt;mon&lt;/code&gt; ), weekday (&lt;code&gt;wday&lt;/code&gt; ), and yearday (&lt;code&gt;yday&lt;/code&gt; ) begin at zero,</source>
          <target state="translated">월 ( &lt;code&gt;mon&lt;/code&gt; ), 요일 ( &lt;code&gt;wday&lt;/code&gt; ) 및 연도 ( &lt;code&gt;yday&lt;/code&gt; )는 0에서 시작합니다.</target>
        </trans-unit>
        <trans-unit id="716f3ac895408852fbfe14ab4075855f3cc5828e" translate="yes" xml:space="preserve">
          <source>The month (&lt;code&gt;mon&lt;/code&gt;), weekday (&lt;code&gt;wday&lt;/code&gt;), and yearday (&lt;code&gt;yday&lt;/code&gt;) begin at zero,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7976bab032857556f1afeeb5486bc37536242264" translate="yes" xml:space="preserve">
          <source>The months and years can be negative for subtractions. Note that there is some &quot;strange&quot; behaviour when adding and subtracting months at the ends of months. Generally when the resulting month is shorter than the starting month then the number of overlap days is added. For example subtracting a month from 2008-03-31 will not result in 2008-02-31 as this is an impossible date. Instead you will get 2008-03-02. This appears to be consistent with other date manipulation tools.</source>
          <target state="translated">빼기에는 월과 년이 음수 일 수 있습니다. 월말에 월을 더하거나 뺄 때 &quot;이상한&quot;동작이 있습니다. 일반적으로 결과 월이 시작 월보다 짧으면 겹치는 일 수가 추가됩니다. 예를 들어 2008-03-31에서 월을 빼면 불가능한 날짜이므로 2008-02-31이되지 않습니다. 대신 2008-03-02가 나옵니다. 이것은 다른 날짜 조작 도구와 일치하는 것으로 보입니다.</target>
        </trans-unit>
        <trans-unit id="467ee849edeaf9f54792730271f84d84084b5500" translate="yes" xml:space="preserve">
          <source>The more modern form of version assignment, with 3 (or potentially more) integers separated by decimal points (e.g. v1.2.3). This is the form that Perl itself has used since 5.6.0 was released. The leading 'v' is now strongly recommended for clarity, and will throw a warning in a future release if omitted. A leading 'v' character is required to pass the &lt;a href=&quot;#is_strict%28%29&quot;&gt;&quot;is_strict()&quot;&lt;/a&gt; test.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b9450d19149fb47c1c53f97698b4be633a15d56" translate="yes" xml:space="preserve">
          <source>The more you think about interfacing between two languages, the more you'll realize that the majority of programmer effort has to go into converting between the data structures that are native to either of the languages involved. This trumps other matter such as differing calling conventions because the problem space is so much greater. There are simply more ways to shove data into memory than there are ways to implement a function call.</source>
          <target state="translated">두 언어 사이의 인터페이스에 대해 더 많이 생각할수록 대부분의 프로그래머 노력은 관련된 언어 중 하나에 고유 한 데이터 구조 사이를 변환해야한다는 사실을 더 많이 깨닫게됩니다. 이것은 문제 공간이 훨씬 크기 때문에 다른 호출 규칙과 같은 다른 문제보다 우선합니다. 함수 호출을 구현하는 방법보다 데이터를 메모리에 저장하는 방법이 더 많습니다.</target>
        </trans-unit>
        <trans-unit id="8176a4ffeb356c4a7a23ddcef37f49bf2bb9d8e2" translate="yes" xml:space="preserve">
          <source>The mortal routines are not just for SVs; AVs and HVs can be made mortal by passing their address (type-casted to &lt;code&gt;SV*&lt;/code&gt; ) to the &lt;code&gt;sv_2mortal&lt;/code&gt; or &lt;code&gt;sv_mortalcopy&lt;/code&gt; routines.</source>
          <target state="translated">필멸의 일상은 단지 SV를위한 것이 아닙니다. AV 및 HV는 주소 ( &lt;code&gt;SV*&lt;/code&gt; 유형 캐스트 ​​됨 )를 &lt;code&gt;sv_2mortal&lt;/code&gt; 또는 &lt;code&gt;sv_mortalcopy&lt;/code&gt; 루틴 으로 전달하여 치명적일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="caf6b1916b41e472c1ad4cc38efc1ebb428fd15c" translate="yes" xml:space="preserve">
          <source>The mortal routines are not just for SVs; AVs and HVs can be made mortal by passing their address (type-casted to &lt;code&gt;SV*&lt;/code&gt;) to the &lt;code&gt;sv_2mortal&lt;/code&gt; or &lt;code&gt;sv_mortalcopy&lt;/code&gt; routines.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a1cfa37e915685db47ff38f6021965013b98c8b" translate="yes" xml:space="preserve">
          <source>The most common CPAN version numbering scheme looks like this:</source>
          <target state="translated">가장 일반적인 CPAN 버전 번호 체계는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d13f6c55db0d43d578a52888c54a47f93bad3e7e" translate="yes" xml:space="preserve">
          <source>The most common context-specific hints are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c4361ab99106fa73a1bb41dd2c636e6a27fcbec" translate="yes" xml:space="preserve">
          <source>The most common example of this is changing the current working directory using &lt;code&gt;&lt;a href=&quot;functions/chdir&quot;&gt;chdir()&lt;/a&gt;&lt;/code&gt;. One thread calls &lt;code&gt;&lt;a href=&quot;functions/chdir&quot;&gt;chdir()&lt;/a&gt;&lt;/code&gt;, and the working directory of all the threads changes.</source>
          <target state="translated">가장 일반적인 예는 &lt;code&gt;&lt;a href=&quot;functions/chdir&quot;&gt;chdir()&lt;/a&gt;&lt;/code&gt; 사용하여 현재 작업 디렉토리를 변경하는 것 입니다. 하나의 스레드는 &lt;code&gt;&lt;a href=&quot;functions/chdir&quot;&gt;chdir()&lt;/a&gt;&lt;/code&gt; 호출 하고 모든 스레드의 작업 디렉토리가 변경됩니다.</target>
        </trans-unit>
        <trans-unit id="c1920ebe5b8490b9051b66a85a68049c7044d116" translate="yes" xml:space="preserve">
          <source>The most common example of this is changing the current working directory using &lt;code&gt;chdir()&lt;/code&gt;. One thread calls &lt;code&gt;chdir()&lt;/code&gt;, and the working directory of all the threads changes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3d1fc7a0fdb4e15b4bc8d9defba4491def9b679" translate="yes" xml:space="preserve">
          <source>The most common git command you will use will probably be</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b7e55ecc01719c5e313506a020593317cb7d856" translate="yes" xml:space="preserve">
          <source>The most common such DOS devices include:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f63cc6de2a2448196e1a86a35300d77fbd9cdf9" translate="yes" xml:space="preserve">
          <source>The most common uses of the interactive modes are</source>
          <target state="translated">대화식 모드의 가장 일반적인 용도는</target>
        </trans-unit>
        <trans-unit id="3f3dfdc5e3f12eaa9aae95ba108f269ad1f91764" translate="yes" xml:space="preserve">
          <source>The most common way to create an object is to pass in key/value pairs where each key is an attribute and each value is what you want assigned to that attribute. No checking is done to verify the attributes or values are valid, you may do that in &lt;code&gt;init()&lt;/code&gt; if desired.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3870e4765effd8ab5e5da52360ab236ece22162c" translate="yes" xml:space="preserve">
          <source>The most commonly used of these functions is &lt;code&gt;Perl_sv_dump&lt;/code&gt; ; it's used for dumping SVs, AVs, HVs, and CVs. The &lt;code&gt;Devel::Peek&lt;/code&gt; module calls &lt;code&gt;sv_dump&lt;/code&gt; to produce debugging output from Perl-space, so users of that module should already be familiar with its format.</source>
          <target state="translated">이러한 기능 중 가장 일반적으로 사용되는 것은 &lt;code&gt;Perl_sv_dump&lt;/code&gt; 입니다 . SV, AV, HV 및 CV를 덤프하는 데 사용됩니다. &lt;code&gt;Devel::Peek&lt;/code&gt; 모듈 호출 &lt;code&gt;sv_dump&lt;/code&gt; 해당 모듈의 사용자가 이미 포맷에 대해 잘 알고 있어야하므로, 펄 공간에서 디버깅 출력을 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="40e2d355a29a78e1dd4f49324b9dbebe996e6a33" translate="yes" xml:space="preserve">
          <source>The most commonly used of these functions is &lt;code&gt;Perl_sv_dump&lt;/code&gt;; it's used for dumping SVs, AVs, HVs, and CVs. The &lt;code&gt;Devel::Peek&lt;/code&gt; module calls &lt;code&gt;sv_dump&lt;/code&gt; to produce debugging output from Perl-space, so users of that module should already be familiar with its format.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3104b20dd3af96ae7f833de8c6d7e1e79108b35" translate="yes" xml:space="preserve">
          <source>The most convenient way of installing a binary distribution of perl is via perl installer</source>
          <target state="translated">펄의 바이너리 배포판을 설치하는 가장 편리한 방법은 펄 설치 프로그램을 이용하는 것입니다</target>
        </trans-unit>
        <trans-unit id="8449f9a2d2191f3c7392f9226647d2910704473a" translate="yes" xml:space="preserve">
          <source>The most efficient way is using &lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt; and &lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;. This is faster than using &lt;a href=&quot;functions/substr&quot;&gt;substr&lt;/a&gt; when taking many, many strings. It is slower for just a few.</source>
          <target state="translated">가장 효율적인 방법은 &lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt; 및 &lt;a href=&quot;functions/unpack&quot;&gt;unpack을 사용하는 것&lt;/a&gt; 입니다. 많은 문자열을 사용할 때 &lt;a href=&quot;functions/substr&quot;&gt;substr을&lt;/a&gt; 사용하는 것보다 빠릅니다 . 몇 분만 더 느립니다.</target>
        </trans-unit>
        <trans-unit id="e62c7de4b0c0c77c458201d125462fa3d57ea6f5" translate="yes" xml:space="preserve">
          <source>The most efficient way is using &lt;a href=&quot;perlfunc#pack&quot;&gt;pack()&lt;/a&gt; and &lt;a href=&quot;perlfunc#unpack&quot;&gt;unpack()&lt;/a&gt;. This is faster than using &lt;a href=&quot;perlfunc#substr&quot;&gt;substr()&lt;/a&gt; when taking many, many strings. It is slower for just a few.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ee8f017f47cf02290cdcd6ac5e270d04e302d38" translate="yes" xml:space="preserve">
          <source>The most general way to do this is to cast them to a UV or IV, and print as in the &lt;a href=&quot;#Formatted-Printing-of-IVs%2C-UVs%2C-and-NVs&quot;&gt;previous section&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22c40808afd7fc4cc79463965386f4682ff94dfa" translate="yes" xml:space="preserve">
          <source>The most hairy case</source>
          <target state="translated">가장 털이 많은 경우</target>
        </trans-unit>
        <trans-unit id="51dfbd93c1252c67b5797f63c0a32f35baffd72d" translate="yes" xml:space="preserve">
          <source>The most important Perl parsing rule is the first one discussed below: when processing a quoted construct, Perl first finds the end of that construct, then interprets its contents. If you understand this rule, you may skip the rest of this section on the first reading. The other rules are likely to contradict the user's expectations much less frequently than this first one.</source>
          <target state="translated">가장 중요한 Perl 구문 분석 규칙은 아래에 논의 된 첫 번째 규칙입니다. 인용 된 구문을 처리 할 때 Perl은 먼저 해당 구문의 끝을 찾은 다음 그 내용을 해석합니다. 이 규칙을 이해하면 첫 번째 읽을 때이 섹션의 나머지 부분을 건너 뛸 수 있습니다. 다른 규칙은 첫 번째 규칙보다 사용자의 기대와 훨씬 덜 모순 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="aef7d8dbf9d828ab96b855e0061e1f04b9541021" translate="yes" xml:space="preserve">
          <source>The most important attribute of a socket, like your telephone&amp;rsquo;s telephone number. Typically an IP address. See also &lt;b&gt;port&lt;/b&gt;.</source>
          <target state="translated">전화의 전화 번호와 같은 소켓의 가장 중요한 속성입니다. 일반적으로 IP 주소입니다. &lt;b&gt;port&lt;/b&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="10d61cb4054b3dd458a76a9b2241b8875252cd6d" translate="yes" xml:space="preserve">
          <source>The most important of which are probably &lt;code&gt;GV_ADD&lt;/code&gt; and &lt;code&gt;SVf_UTF8&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a25c59d901462fca0083edfc964d9c8bf518a04" translate="yes" xml:space="preserve">
          <source>The most important of which are probably GV_ADD and SVf_UTF8.</source>
          <target state="translated">가장 중요한 것은 아마도 GV_ADD와 SVf_UTF8 일 것입니다.</target>
        </trans-unit>
        <trans-unit id="0626c5878256026e37d6cadc7a0a5c68ea6109bd" translate="yes" xml:space="preserve">
          <source>The most important of which is:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1aae52fef16fc25bcc3b6593dc3391e48196f1ad" translate="yes" xml:space="preserve">
          <source>The most important thing is to run your programs under the &lt;b&gt;-w&lt;/b&gt; flag at all times. You may turn it off explicitly for particular portions of code via the &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; warnings&lt;/code&gt; pragma or the &lt;code&gt;$^W&lt;/code&gt; variable if you must. You should also always run under &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict&lt;/code&gt; or know the reason why not. The &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; sigtrap&lt;/code&gt; and even &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; diagnostics&lt;/code&gt; pragmas may also prove useful.</source>
          <target state="translated">가장 중요한 것은 항상 &lt;b&gt;-w&lt;/b&gt; 플래그로 프로그램을 실행하는 것입니다 . &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; warnings&lt;/code&gt; pragma 또는 &lt;code&gt;$^W&lt;/code&gt; 변수 를 통해 코드의 특정 부분에 대해 명시 적으로 끌 수 있습니다 ( 필요한 경우). 또한 항상 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict&lt;/code&gt; &lt;a href=&quot;functions/use&quot;&gt;사용&lt;/a&gt; 하거나 그 이유를 알아야합니다. &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; sigtrap&lt;/code&gt; , 심지어 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; diagnostics&lt;/code&gt; 프라그 마를도 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8c3b2954acd0c4fdd7e8575f6e05f126659f29cc" translate="yes" xml:space="preserve">
          <source>The most important thing is to use &lt;a href=&quot;strict&quot;&gt;strict&lt;/a&gt; and &lt;a href=&quot;warnings&quot;&gt;warnings&lt;/a&gt; in all your code or know the reason why not to. You may turn them off explicitly for particular portions of code via &lt;code&gt;no warnings&lt;/code&gt; or &lt;code&gt;no strict&lt;/code&gt;, and this can be limited to the specific warnings or strict features you wish to disable. The &lt;b&gt;-w&lt;/b&gt; flag and &lt;code&gt;$^W&lt;/code&gt; variable should not be used for this purpose since they can affect code you use but did not write, such as modules from core or CPAN.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6be7df730b69bf2abfbfef25c9c73eef66cdf79" translate="yes" xml:space="preserve">
          <source>The most important thing to understand about all data structures in Perl--including multidimensional arrays--is that even though they might appear otherwise, Perl &lt;code&gt;@ARRAY&lt;/code&gt; s and &lt;code&gt;%HASH&lt;/code&gt; es are all internally one-dimensional. They can hold only scalar values (meaning a string, number, or a reference). They cannot directly contain other arrays or hashes, but instead contain</source>
          <target state="translated">다차원 배열을 포함하여 Perl의 모든 데이터 구조에 대해 이해해야 할 가장 중요한 것은 비록 다르게 나타날 수 있지만 Perl &lt;code&gt;@ARRAY&lt;/code&gt; 및 &lt;code&gt;%HASH&lt;/code&gt; 는 모두 내부적으로 1 차원이라는 것입니다. 스칼라 값만 보유 할 수 있습니다 (문자열, 숫자 또는 참조를 의미). 다른 배열이나 해시를 직접 포함 할 수는 없지만 대신</target>
        </trans-unit>
        <trans-unit id="787b225130f60b5479ecb7c71a8dc7b419116101" translate="yes" xml:space="preserve">
          <source>The most important thing to understand about all data structures in Perl--including multidimensional arrays--is that even though they might appear otherwise, Perl &lt;code&gt;@ARRAY&lt;/code&gt;s and &lt;code&gt;%HASH&lt;/code&gt;es are all internally one-dimensional. They can hold only scalar values (meaning a string, number, or a reference). They cannot directly contain other arrays or hashes, but instead contain</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae5f029eca08711d302dd8f17b7e7f9e635b1ec8" translate="yes" xml:space="preserve">
          <source>The most popular books</source>
          <target state="translated">가장 인기있는 책</target>
        </trans-unit>
        <trans-unit id="c77ae4b23596713f5e5db719e4b12df8a45dd104" translate="yes" xml:space="preserve">
          <source>The most practical use is likely to specify that some tests are not &quot;parallel-ready&quot;. Since mentioning a file with --rules doesn't cause it to be selected to run as a test, you can &quot;set and forget&quot; some rules preferences in your .proverc file. Then you'll be able to take maximum advantage of the performance benefits of parallel testing, while some exceptions are still run in parallel.</source>
          <target state="translated">가장 실용적인 용도는 일부 테스트가 &quot;병렬-준비&quot;되지 않았 음을 지정할 수 있습니다. --rules가있는 파일을 언급해도 테스트로 실행되도록 선택되지 않으므로 .proverc 파일에서 일부 규칙 기본 설정을 &quot;설정하고 잊어 버릴 수&quot;있습니다. 그런 다음 병렬 테스트의 성능 이점을 최대한 활용할 수 있지만 일부 예외는 여전히 병렬로 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="6f276b3b1a0cf0e0ed49a901109064669a604004" translate="yes" xml:space="preserve">
          <source>The most preferable one is &quot;The Default Unicode Collation Element Table&quot; (aka DUCET), available from the Unicode Consortium's website:</source>
          <target state="translated">가장 바람직한 것은 유니 코드 컨소시엄 웹 사이트에서 제공하는 &quot;기본 유니 코드 데이터 정렬 요소 테이블&quot;(일명 DUCET)입니다.</target>
        </trans-unit>
        <trans-unit id="1a2b184063d0bc0a35feb7fb346e45c3d6648eb5" translate="yes" xml:space="preserve">
          <source>The most recent development releases of Perl have been experimenting with removing Perl's dependency on the &quot;normal&quot; standard I/O suite and allowing other stdio implementations to be used. This involves creating a new abstraction layer that then calls whichever implementation of stdio Perl was compiled with. All XSUBs should now use the functions in the PerlIO abstraction layer and not make any assumptions about what kind of stdio is being used.</source>
          <target state="translated">Perl의 최신 개발 릴리스는 &quot;정상&quot;표준 I / O 제품군에 대한 Perl의 종속성을 제거하고 다른 stdio 구현을 사용할 수 있도록 실험하고 있습니다. 여기에는 새로운 추상화 계층을 생성 한 다음 stdio Perl의 구현이 컴파일 된 것을 호출합니다. 모든 XSUB는 이제 PerlIO 추상화 계층의 기능을 사용해야하며 어떤 종류의 stdio가 사용되는지에 대한 가정을하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="d790d27d68eef3be56d3d5afa1a5d1f30d794f18" translate="yes" xml:space="preserve">
          <source>The most recent upgrade to the PA-RISC design, it added support for 64-bit integer data.</source>
          <target state="translated">PA-RISC 설계의 최신 업그레이드로 64 비트 정수 데이터에 대한 지원이 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="0603f466834b0d6d823bdd46c3606b7ca755f71a" translate="yes" xml:space="preserve">
          <source>The most recent version of this module, including documentation and any news of importance, will be available at</source>
          <target state="translated">설명서 및 중요 뉴스를 포함하여이 모듈의 최신 버전은</target>
        </trans-unit>
        <trans-unit id="f4a085ad231e217eed37777279430f48e1cf87a2" translate="yes" xml:space="preserve">
          <source>The most significant information in the output is about the particular</source>
          <target state="translated">출력에서 가장 중요한 정보는</target>
        </trans-unit>
        <trans-unit id="9de43c038dc457f71dc272efc26e8a4eb0e6b17e" translate="yes" xml:space="preserve">
          <source>The most simple options are the ones that take no values. Their mere presence on the command line enables the option. Popular examples are:</source>
          <target state="translated">가장 간단한 옵션은 가치가없는 옵션입니다. 명령 행에 존재하는 것만으로도 옵션이 가능합니다. 인기있는 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="fe61ded48d4439fb9787ec0d115995f08935a048" translate="yes" xml:space="preserve">
          <source>The most useful option the cross referencer has is to save the report to a separate file. For instance, to save the report on</source>
          <target state="translated">상호 참조자가 갖는 가장 유용한 옵션은 보고서를 별도의 파일로 저장하는 것입니다. 예를 들어 보고서를</target>
        </trans-unit>
        <trans-unit id="762e20af8acff77775848b01e093c2cac3013ec4" translate="yes" xml:space="preserve">
          <source>The most useful types that will be returned are:</source>
          <target state="translated">반환되는 가장 유용한 유형은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a4f13e9fd0d66b114f604fe2129d7ad6d576d1c5" translate="yes" xml:space="preserve">
          <source>The movement of bits left or right in a computer word, which has the effect of multiplying or dividing by a power of 2.</source>
          <target state="translated">컴퓨터 단어에서 비트의 왼쪽 또는 오른쪽 이동으로 2의 거듭 제곱으로 곱하거나 나누는 효과가 있습니다.</target>
        </trans-unit>
        <trans-unit id="811ee2e71fefd4dbb8ec994c3d2df771d4653871" translate="yes" xml:space="preserve">
          <source>The multiple-bracket form does not affect the interpretation of the contents of the formatting code, only how it must end. That means that the examples above are also exactly the same as this:</source>
          <target state="translated">다중 대괄호 형식은 형식화 코드 내용 해석에 영향을 미치지 않으며 종료 방법에만 영향을줍니다. 즉, 위의 예는 다음과 정확히 동일합니다.</target>
        </trans-unit>
        <trans-unit id="b62777fe39744a74b7fc65bfce887b1ed7aeecd0" translate="yes" xml:space="preserve">
          <source>The mutators for flags all return the JSON::PP object again and thus calls can be chained:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2632e91c7e1b901a77d044556dbd4ff9d5c87be" translate="yes" xml:space="preserve">
          <source>The name</source>
          <target state="translated">이름</target>
        </trans-unit>
        <trans-unit id="db6539b7ba93a9d46c820cb8d93cf44ff14b7c45" translate="yes" xml:space="preserve">
          <source>The name &quot;WinXP/.Net&quot; is used for historical reasons only, to maintain backwards compatibility of the Win32 module. Windows .NET Server has been renamed as Windows 2003 Server before final release and uses a different major/minor version number than Windows XP.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f32c3c3ac333fcf1879195759e18947b403def2d" translate="yes" xml:space="preserve">
          <source>The name &lt;code&gt;new&lt;/code&gt; isn't special. We could name our constructor something else:</source>
          <target state="translated">&lt;code&gt;new&lt;/code&gt; 이름 은 특별하지 않습니다. 생성자의 이름을 다른 것으로 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="381ffb5c7c9337af9dd775ed33da7e16dd88d27a" translate="yes" xml:space="preserve">
          <source>The name in the IANA registry.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="316e7deb3997f109974511d20499a1d93aa6493c" translate="yes" xml:space="preserve">
          <source>The name is returned as a mortal SV.</source>
          <target state="translated">이름은 필사자 SV로 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="e84fcc4ee47e1e1b5639888428e055c00959431a" translate="yes" xml:space="preserve">
          <source>The name may contain embedded E&amp;lt;&amp;gt; and Z&amp;lt;&amp;gt; formatting codes, and the section, anchor text, and inferred anchor text may contain any formatting codes. Any double quotes around the section are removed as part of the parsing, as is any leading or trailing whitespace.</source>
          <target state="translated">이름에는 E &amp;lt;&amp;gt; 및 Z &amp;lt;&amp;gt; 형식 코드가 포함되어있을 수 있으며 섹션, 앵커 텍스트 및 유추 된 앵커 텍스트에는 모든 형식 코드가 포함될 수 있습니다. 앞뒤 공백과 마찬가지로 섹션 주위의 큰 따옴표는 구문 분석의 일부로 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="8ada838033f411154fe022f162bc95bf1ac56e8a" translate="yes" xml:space="preserve">
          <source>The name of the &lt;code&gt;(*SKIP:&lt;i&gt;NAME&lt;/i&gt;)&lt;/code&gt; pattern has special significance. If a &lt;code&gt;(*MARK:&lt;i&gt;NAME&lt;/i&gt;)&lt;/code&gt; was encountered while matching, then it is that position which is used as the &quot;skip point&quot;. If no &lt;code&gt;(*MARK)&lt;/code&gt; of that name was encountered, then the &lt;code&gt;(*SKIP)&lt;/code&gt; operator has no effect. When used without a name the &quot;skip point&quot; is where the match point was when executing the &lt;code&gt;(*SKIP)&lt;/code&gt; pattern.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f683b00c5db230ebae95056480292ae0fa37d30" translate="yes" xml:space="preserve">
          <source>The name of the &lt;code&gt;(*SKIP:NAME)&lt;/code&gt; pattern has special significance. If a &lt;code&gt;(*MARK:NAME)&lt;/code&gt; was encountered while matching, then it is that position which is used as the &quot;skip point&quot;. If no &lt;code&gt;(*MARK)&lt;/code&gt; of that name was encountered, then the &lt;code&gt;(*SKIP)&lt;/code&gt; operator has no effect. When used without a name the &quot;skip point&quot; is where the match point was when executing the (*SKIP) pattern.</source>
          <target state="translated">의 이름 &lt;code&gt;(*SKIP:NAME)&lt;/code&gt; 패턴은 특별한 의미가있다. 경우 &lt;code&gt;(*MARK:NAME)&lt;/code&gt; 이 일치하는 상태가 발생하고, 그런 다음 &quot;지점을 이동&quot;으로 사용되는 위치이다. 어떤 경우 &lt;code&gt;(*MARK)&lt;/code&gt; 그 이름이 발견되지 않은 후 &lt;code&gt;(*SKIP)&lt;/code&gt; 연산자은 효과가 없다. 이름없이 사용될 때 &quot;건너 뛰기 지점&quot;은 (* SKIP) 패턴을 실행할 때의 일치 지점입니다.</target>
        </trans-unit>
        <trans-unit id="4ffbfa835ecb6cb544ad106cd35f35360cfc377b" translate="yes" xml:space="preserve">
          <source>The name of the &lt;code&gt;result_class&lt;/code&gt; . Defaults to &lt;code&gt;App::Prove::State::Result&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;result_class&lt;/code&gt; 의 이름입니다 . 기본값은 &lt;code&gt;App::Prove::State::Result&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="7b922baa1630e5f6c97eeff342a7feb7ab689a79" translate="yes" xml:space="preserve">
          <source>The name of the &lt;code&gt;result_class&lt;/code&gt;. Defaults to &lt;code&gt;App::Prove::State::Result&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="689345a6c608b08f0da8c40d1de1f0d6ad537fb4" translate="yes" xml:space="preserve">
          <source>The name of the C subroutine generated which will return the constants. The default is</source>
          <target state="translated">상수를 리턴 할 생성 된 C 서브 루틴의 이름. 디폴트는</target>
        </trans-unit>
        <trans-unit id="24928164de71defca77ef40b5800aabbee56b274" translate="yes" xml:space="preserve">
          <source>The name of the Makefile to be produced. This is used for the second Makefile that will be produced for the MAP_TARGET.</source>
          <target state="translated">생성 할 Makefile의 이름입니다. 이것은 MAP_TARGET에 대해 생성 될 두 번째 Makefile에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="586bd0a2b6cddbba1d51a20c05e33d4e435a88ba" translate="yes" xml:space="preserve">
          <source>The name of the OP, or 'ex-foo' if the OP is a null that used to be a foo.</source>
          <target state="translated">OP의 이름이거나 OP가 foo 인 null 인 경우 'ex-foo'입니다.</target>
        </trans-unit>
        <trans-unit id="5c8f940ac3ab77f3cca6bf5d7c2332906bee0772" translate="yes" xml:space="preserve">
          <source>The name of the array containing the &lt;b&gt;argument&lt;/b&gt;&lt;b&gt;vector&lt;/b&gt; from the command line. If you use the empty &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; operator, &lt;code&gt;ARGV&lt;/code&gt; is the name of both the &lt;b&gt;filehandle&lt;/b&gt; used to traverse the arguments and the &lt;b&gt;scalar&lt;/b&gt; containing the name of the current input file.</source>
          <target state="translated">명령 행 의 &lt;b&gt;인수 &lt;/b&gt;&lt;b&gt;벡터&lt;/b&gt; 를 포함하는 배열의 이름입니다 . 빈 &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; 연산자 를 사용하는 경우 &lt;code&gt;ARGV&lt;/code&gt; 는 인수를 순회하는 데 사용되는 &lt;b&gt;파일 핸들&lt;/b&gt; 과 현재 입력 파일의 이름을 포함하는 &lt;b&gt;스칼라&lt;/b&gt; 의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="c0ef9637fb40c44d741c359416d9acc461c4754b" translate="yes" xml:space="preserve">
          <source>The name of the capability to be output.</source>
          <target state="translated">출력 할 기능의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="25678c01479ff57e49b16538b63d4932cacd981b" translate="yes" xml:space="preserve">
          <source>The name of the class to use to aggregate test results. The default is &lt;a href=&quot;TAP::Parser::Aggregator&quot;&gt;TAP::Parser::Aggregator&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65cd22adf72a74a4b456151c3e1d9f81b33d09a6" translate="yes" xml:space="preserve">
          <source>The name of the class to use to aggregate test results. The default is &lt;a href=&quot;parser/aggregator&quot;&gt;TAP::Parser::Aggregator&lt;/a&gt;.</source>
          <target state="translated">테스트 결과를 집계하는 데 사용할 클래스 이름입니다. 기본값은 &lt;a href=&quot;parser/aggregator&quot;&gt;TAP :: Parser :: Aggregator&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="5f598b6f749ef712a68f14ac426c778ed4bbb049" translate="yes" xml:space="preserve">
          <source>The name of the class to use to format output. The default is &lt;a href=&quot;TAP::Formatter::Console&quot;&gt;TAP::Formatter::Console&lt;/a&gt;, or &lt;a href=&quot;TAP::Formatter::File&quot;&gt;TAP::Formatter::File&lt;/a&gt; if the output isn't a TTY.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eaad217bdc2e240c2b5911f874d90cf603ae7ab9" translate="yes" xml:space="preserve">
          <source>The name of the class to use to format output. The default is &lt;a href=&quot;formatter/console&quot;&gt;TAP::Formatter::Console&lt;/a&gt;, or &lt;a href=&quot;formatter/file&quot;&gt;TAP::Formatter::File&lt;/a&gt; if the output isn't a TTY.</source>
          <target state="translated">출력을 형식화하는 데 사용할 클래스 이름입니다. 출력이 TTY가 아닌 경우 기본값은 &lt;a href=&quot;formatter/console&quot;&gt;TAP :: Formatter :: Console&lt;/a&gt; 또는 &lt;a href=&quot;formatter/file&quot;&gt;TAP :: Formatter :: File&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="2938c30f6481c7209480e330f5d2558def4c79e1" translate="yes" xml:space="preserve">
          <source>The name of the class to use to multiplex tests during parallel testing. The default is &lt;a href=&quot;TAP::Parser::Multiplexer&quot;&gt;TAP::Parser::Multiplexer&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72da2c41641715361491c5ff4abc5e20b2230add" translate="yes" xml:space="preserve">
          <source>The name of the class to use to multiplex tests during parallel testing. The default is &lt;a href=&quot;parser/multiplexer&quot;&gt;TAP::Parser::Multiplexer&lt;/a&gt;.</source>
          <target state="translated">병렬 테스트 중에 멀티 플렉스 테스트에 사용할 클래스 이름입니다. 기본값은 &lt;a href=&quot;parser/multiplexer&quot;&gt;TAP :: Parser :: Multiplexer&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="3d2b438590e86cedd0b4ce69e5a89edf3f57ce2f" translate="yes" xml:space="preserve">
          <source>The name of the class to use to parse TAP. The default is &lt;a href=&quot;TAP::Parser&quot;&gt;TAP::Parser&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf5c1530a58c08454895ba69cebd216b2fda858b" translate="yes" xml:space="preserve">
          <source>The name of the class to use to parse TAP. The default is &lt;a href=&quot;parser&quot;&gt;TAP::Parser&lt;/a&gt;.</source>
          <target state="translated">TAP를 구문 분석하는 데 사용할 클래스 이름입니다. 기본값은 &lt;a href=&quot;parser&quot;&gt;TAP :: Parser&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="6353269469768546ffd890653f96373f13d0ecd8" translate="yes" xml:space="preserve">
          <source>The name of the class to use to schedule test execution. The default is &lt;a href=&quot;TAP::Parser::Scheduler&quot;&gt;TAP::Parser::Scheduler&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c363903c8b428e2f92b68d74a94f7359ac65693" translate="yes" xml:space="preserve">
          <source>The name of the class to use to schedule test execution. The default is &lt;a href=&quot;parser/scheduler&quot;&gt;TAP::Parser::Scheduler&lt;/a&gt;.</source>
          <target state="translated">테스트 실행을 예약하는 데 사용할 클래스 이름입니다. 기본값은 &lt;a href=&quot;parser/scheduler&quot;&gt;TAP :: Parser :: Scheduler&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="be46c0fe1db34418e8697bff77cb46ef2046a9fa" translate="yes" xml:space="preserve">
          <source>The name of the constant, as seen by the perl code.</source>
          <target state="translated">Perl 코드에서 볼 수있는 상수의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="4720e470b7493414aa6c88cde788462359384401" translate="yes" xml:space="preserve">
          <source>The name of the current report format for the currently selected output channel. The default format name is the same as the filehandle name. For example, the default format name for the &lt;code&gt;STDOUT&lt;/code&gt; filehandle is just &lt;code&gt;STDOUT&lt;/code&gt; .</source>
          <target state="translated">현재 선택된 출력 채널에 대한 현재 보고서 형식의 이름입니다. 기본 형식 이름은 파일 핸들 이름과 동일합니다. 예를 들어, &lt;code&gt;STDOUT&lt;/code&gt; 파일 핸들 의 기본 형식 이름 은 &lt;code&gt;STDOUT&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="f308d321f719413a7daef45e5b751142a5169847" translate="yes" xml:space="preserve">
          <source>The name of the current report format for the currently selected output channel. The default format name is the same as the filehandle name. For example, the default format name for the &lt;code&gt;STDOUT&lt;/code&gt; filehandle is just &lt;code&gt;STDOUT&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6e5170077c0838d812432a43efc57d6e9e83c1c" translate="yes" xml:space="preserve">
          <source>The name of the current top-of-page format for the currently selected output channel. The default is the name of the filehandle with &lt;code&gt;_TOP&lt;/code&gt; appended. For example, the default format top name for the &lt;code&gt;STDOUT&lt;/code&gt; filehandle is &lt;code&gt;STDOUT_TOP&lt;/code&gt; .</source>
          <target state="translated">현재 선택된 출력 채널에 대한 현재 페이지 상단 형식의 이름입니다. 기본값은 &lt;code&gt;_TOP&lt;/code&gt; 이 추가 된 파일 핸들의 이름입니다 . 예를 들어, &lt;code&gt;STDOUT&lt;/code&gt; 파일 핸들 의 기본 형식 최상위 이름 은 &lt;code&gt;STDOUT_TOP&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="a0743a6b94bb8bebfeea265e55206e1f27d87193" translate="yes" xml:space="preserve">
          <source>The name of the current top-of-page format for the currently selected output channel. The default is the name of the filehandle with &lt;code&gt;_TOP&lt;/code&gt; appended. For example, the default format top name for the &lt;code&gt;STDOUT&lt;/code&gt; filehandle is &lt;code&gt;STDOUT_TOP&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6379fb4c9e525f705c12afeef2d60c9f65c93af3" translate="yes" xml:space="preserve">
          <source>The name of the default local file, that $ff-&amp;gt;output_file falls back to if it would otherwise return no filename. For example when fetching a URI like &lt;a href=&quot;http://www.abc.net.au/&quot;&gt;http://www.abc.net.au/&lt;/a&gt; the contents retrieved may be from a remote file called 'index.html'. The default value of this attribute is literally 'file_default'.</source>
          <target state="translated">기본 로컬 파일의 이름으로 $ ff-&amp;gt; output_file은 파일 이름을 반환하지 않으면 대체됩니다. 예를 들어 &lt;a href=&quot;http://www.abc.net.au/&quot;&gt;http://www.abc.net.au/&lt;/a&gt; 와 같은 URI를 가져올 때 검색된 내용은 'index.html'이라는 원격 파일에서 가져온 것일 수 있습니다. 이 속성의 기본값은 말 그대로 'file_default'입니다.</target>
        </trans-unit>
        <trans-unit id="724f86ff11ab9d4f954a655139b3c95fbd6d6b99" translate="yes" xml:space="preserve">
          <source>The name of the default local file, that $ff-&amp;gt;output_file falls back to if it would otherwise return no filename. For example when fetching a URI like http://www.abc.net.au/ the contents retrieved may be from a remote file called 'index.html'. The default value of this attribute is literally 'file_default'.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17ff7c2b3c1b5f1d9d21717655a465440b8c3a51" translate="yes" xml:space="preserve">
          <source>The name of the distribution. Often created by taking the &quot;main module&quot; in the distribution and changing &quot;::&quot; to &quot;-&quot;. Sometimes it's completely different, however, as in the case of the &lt;a href=&quot;http://search.cpan.org/author/GAAS/libwww-perl/&quot;&gt;libwww-perl&lt;/a&gt; distribution.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ec9b1148eb41355676951fe5003b4832073d292" translate="yes" xml:space="preserve">
          <source>The name of the file to write containing the C code. The default is &lt;code&gt;const-c.inc&lt;/code&gt; . The &lt;code&gt;-&lt;/code&gt; in the name ensures that the file can't be mistaken for anything related to a legitimate perl package name, and not naming the file &lt;code&gt;.c&lt;/code&gt; avoids having to override Makefile.PL's &lt;code&gt;.xs&lt;/code&gt; to &lt;code&gt;.c&lt;/code&gt; rules.</source>
          <target state="translated">C 코드를 포함하여 쓸 파일의 이름입니다. 기본값은 &lt;code&gt;const-c.inc&lt;/code&gt; 입니다. &lt;code&gt;-&lt;/code&gt; 이름 보장하지만에있는 파일은 합법적 인 펄 패키지 이름과 관련된 어떤 착각하지, 파일 명명 할 수없는 &lt;code&gt;.c&lt;/code&gt; Makefile.PL의 오버라이드 (override)하는 것을 피합니다 &lt;code&gt;.xs&lt;/code&gt; 을 에 &lt;code&gt;.c&lt;/code&gt; 규칙을.</target>
        </trans-unit>
        <trans-unit id="cd1ff7ef642391e787d3298e4e4d4178df728894" translate="yes" xml:space="preserve">
          <source>The name of the file to write containing the C code. The default is &lt;code&gt;const-c.inc&lt;/code&gt;. The &lt;code&gt;-&lt;/code&gt; in the name ensures that the file can't be mistaken for anything related to a legitimate perl package name, and not naming the file &lt;code&gt;.c&lt;/code&gt; avoids having to override Makefile.PL's &lt;code&gt;.xs&lt;/code&gt; to &lt;code&gt;.c&lt;/code&gt; rules.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2bed22db2d9895f574b197dc49845a9793eb5ff4" translate="yes" xml:space="preserve">
          <source>The name of the file to write containing the XS code. The default is &lt;code&gt;const-xs.inc&lt;/code&gt; .</source>
          <target state="translated">XS 코드를 포함하여 쓸 파일의 이름입니다. 기본값은 &lt;code&gt;const-xs.inc&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="ff977189b5dca37639aa340e96771f65419bc6de" translate="yes" xml:space="preserve">
          <source>The name of the file to write containing the XS code. The default is &lt;code&gt;const-xs.inc&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6d500a8c6262466b93b5ca84e3fdd9132c3d42c" translate="yes" xml:space="preserve">
          <source>The name of the file you want to tie to the hash.</source>
          <target state="translated">해시에 연결하려는 파일의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="264313247d929c3123a9e7fe3982f9c4d6734ea2" translate="yes" xml:space="preserve">
          <source>The name of the file.</source>
          <target state="translated">파일 이름</target>
        </trans-unit>
        <trans-unit id="2fed9b5e3d1ecfa444bc4bf0c0867e79f9d251bc" translate="yes" xml:space="preserve">
          <source>The name of the interior sequence command.</source>
          <target state="translated">내부 시퀀스 명령의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="850e998443ed95a332bbac695731c9e48b93fd64" translate="yes" xml:space="preserve">
          <source>The name of the label is returned in the form of a fresh scalar. If an optional label is absent, a null pointer is returned.</source>
          <target state="translated">레이블 이름은 새로운 스칼라 형식으로 반환됩니다. 선택적 레이블이 없으면 널 포인터가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="73fad9a569b3c6f7964969b809a10335f9888518" translate="yes" xml:space="preserve">
          <source>The name of the layer whose open() method Perl should invoke on open(). For example if the layer is called APR, you will call:</source>
          <target state="translated">open () 메소드 Perl이 open ()에서 호출해야하는 레이어의 이름입니다. 예를 들어 레이어 이름이 APR 인 경우 다음을 호출합니다.</target>
        </trans-unit>
        <trans-unit id="72863e084ba8d90c496ae5c6484f120959926659" translate="yes" xml:space="preserve">
          <source>The name of the method</source>
          <target state="translated">방법의 이름</target>
        </trans-unit>
        <trans-unit id="e4c23f5fa4cbd2a24c92f584213f4e01a597f939" translate="yes" xml:space="preserve">
          <source>The name of the module you wish to verify -- this is a required key</source>
          <target state="translated">확인하려는 모듈의 이름-필수 키입니다</target>
        </trans-unit>
        <trans-unit id="8baabdd6359e36f0075679bff6c64a42d5070771" translate="yes" xml:space="preserve">
          <source>The name of the operating system under which this copy of Perl was built, as determined during the configuration process. For examples see &lt;a href=&quot;perlport#PLATFORMS&quot;&gt;&quot;PLATFORMS&quot; in perlport&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="917bce2995f64faec20b4096ae916c3c8efb0bec" translate="yes" xml:space="preserve">
          <source>The name of the operating system under which this copy of Perl was built, as determined during the configuration process. For examples see &lt;a href=&quot;perlport#PLATFORMS&quot;&gt;PLATFORMS in perlport&lt;/a&gt;.</source>
          <target state="translated">구성 프로세스 중에 판별 된대로이 Perl 사본이 빌드 된 운영 체제의 이름입니다. 예를 들어 &lt;a href=&quot;perlport#PLATFORMS&quot;&gt;perlport의 PLATFORMS를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="2040df0b9281e990b52b6ffee0618e248f91a919" translate="yes" xml:space="preserve">
          <source>The name of the output file. This is the same as $ff-&amp;gt;file, but any query parameters are stripped off. For example:</source>
          <target state="translated">출력 파일의 이름입니다. 이것은 $ ff-&amp;gt; file과 동일하지만 모든 쿼리 매개 변수가 제거됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="cbe18d7ad69e81d6c826df352db92d6f22fccd8c" translate="yes" xml:space="preserve">
          <source>The name of the program being documented is conventionally written in bold (using B&amp;lt;&amp;gt;) wherever it occurs, as are all program options. Arguments should be written in italics (I&amp;lt;&amp;gt;). Function names are traditionally written in italics; if you write a function as function(), Pod::Man will take care of this for you. Literal code or commands should be in C&amp;lt;&amp;gt;. References to other man pages should be in the form &lt;code&gt;manpage(section)&lt;/code&gt; or &lt;code&gt;L&amp;lt;manpage(section)&amp;gt;&lt;/code&gt; , and Pod::Man will automatically format those appropriately. The second form, with L&amp;lt;&amp;gt;, is used to request that a POD formatter make a link to the man page if possible. As an exception, one normally omits the section when referring to module documentation since it's not clear what section module documentation will be in; use &lt;code&gt;L&amp;lt;Module::Name&amp;gt;&lt;/code&gt; for module references instead.</source>
          <target state="translated">문서화되는 프로그램의 이름은 모든 프로그램 옵션과 마찬가지로 일반적으로 B &amp;lt;&amp;gt;를 사용하여 굵게 표시됩니다. 인수는 이탤릭체로 작성해야합니다 (I &amp;lt;&amp;gt;). 함수 이름은 전통적으로 이탤릭체로 작성됩니다. function ()으로 함수를 작성하면 Pod :: Man이이를 처리합니다. 리터럴 코드 또는 명령은 C &amp;lt;&amp;gt;에 있어야합니다. 다른 매뉴얼 페이지에 대한 참조는 &lt;code&gt;manpage(section)&lt;/code&gt; 또는 &lt;code&gt;L&amp;lt;manpage(section)&amp;gt;&lt;/code&gt; 형식이어야하며 Pod :: Man은 자동으로 적절하게 형식을 지정합니다. L &amp;lt;&amp;gt;이있는 두 번째 양식은 POD 포맷터가 가능하면 매뉴얼 페이지에 링크하도록 요청하는 데 사용됩니다. 예외적으로, 모듈 문서를 참조 할 때 일반적으로 해당 섹션을 생략하여 어떤 모듈 설명서가 포함될 것인지 명확하지 않기 때문에;사용하다 &lt;code&gt;L&amp;lt;Module::Name&amp;gt;&lt;/code&gt; 대신 모듈 참조를위한 L &amp;lt;Module :: Name&amp;gt; .</target>
        </trans-unit>
        <trans-unit id="1b18709c27f5d88461bdcb14ca9e036ab15a9e4c" translate="yes" xml:space="preserve">
          <source>The name of the program being documented is conventionally written in bold (using B&amp;lt;&amp;gt;) wherever it occurs, as are all program options. Arguments should be written in italics (I&amp;lt;&amp;gt;). Function names are traditionally written in italics; if you write a function as function(), Pod::Man will take care of this for you. Literal code or commands should be in C&amp;lt;&amp;gt;. References to other man pages should be in the form &lt;code&gt;manpage(section)&lt;/code&gt; or &lt;code&gt;L&amp;lt;manpage(section)&amp;gt;&lt;/code&gt;, and Pod::Man will automatically format those appropriately. The second form, with L&amp;lt;&amp;gt;, is used to request that a POD formatter make a link to the man page if possible. As an exception, one normally omits the section when referring to module documentation since it's not clear what section module documentation will be in; use &lt;code&gt;L&amp;lt;Module::Name&amp;gt;&lt;/code&gt; for module references instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d1dece7f57632e56f321f082b4b7487de40077a" translate="yes" xml:space="preserve">
          <source>The name of the program currently executing, as typed on the command line. In C, the &lt;b&gt;command&lt;/b&gt; name is passed to the program as the first command-line argument. In Perl, it comes in separately as &lt;code&gt;$0&lt;/code&gt; .</source>
          <target state="translated">명령 행에 입력 된대로 현재 실행중인 프로그램의 이름입니다. C에서 &lt;b&gt;명령&lt;/b&gt; 이름은 첫 번째 명령 행 인수로 프로그램에 전달됩니다. Perl에서는 &lt;code&gt;$0&lt;/code&gt; 으로 별도로 제공됩니다 .</target>
        </trans-unit>
        <trans-unit id="24e0c1ed3bcd878bf180116a18e90c254b00991c" translate="yes" xml:space="preserve">
          <source>The name of the program currently executing, as typed on the command line. In C, the &lt;b&gt;command&lt;/b&gt; name is passed to the program as the first command-line argument. In Perl, it comes in separately as &lt;code&gt;$0&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a87ba5fd11240d3846b6402630cc4fc5a1bb692a" translate="yes" xml:space="preserve">
          <source>The name of the remote file. For the local file name, the result of $ff-&amp;gt;output_file will be used.</source>
          <target state="translated">원격 파일의 이름입니다. 로컬 파일 이름의 경우 $ ff-&amp;gt; output_file의 결과가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="7b5484f9bbb8c882de4857813fc18405c14f1941" translate="yes" xml:space="preserve">
          <source>The name of the subtest.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54a547e6d045957f910163d7d9750610edbb9f85" translate="yes" xml:space="preserve">
          <source>The name of the test that will be displayed after the &lt;code&gt;ok&lt;/code&gt; or &lt;code&gt;not
ok&lt;/code&gt; .</source>
          <target state="translated">애프터 표시됩니다 테스트의 이름 &lt;code&gt;ok&lt;/code&gt; 또는 &lt;code&gt;not ok&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0319d70ade81e70a5ad5c9b04019b6a6a650fd8c" translate="yes" xml:space="preserve">
          <source>The name of the test that will be displayed after the &lt;code&gt;ok&lt;/code&gt; or &lt;code&gt;not ok&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fed54953d3ed163e618a466d003f5bcd630ecc77" translate="yes" xml:space="preserve">
          <source>The name of the test. Usually a filename.</source>
          <target state="translated">시험 명. 일반적으로 파일 이름입니다.</target>
        </trans-unit>
        <trans-unit id="bddd22d202ef6bbfb07440852aa85decd3f86741" translate="yes" xml:space="preserve">
          <source>The name of the variable the OP's targ refers to, if any, otherwise the letter t followed by the OP's targ in decimal.</source>
          <target state="translated">OP의 targ가있는 변수의 이름 (있는 경우), 그렇지 않으면 문자 t 뒤에 OP의 targ가 10 진수로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="57d8fd0b0612e473ba409ed332506df9547952e4" translate="yes" xml:space="preserve">
          <source>The name of this target is the name of the tarball generated by tardist. This target does the actual work of turning the distdir into a tarball.</source>
          <target state="translated">이 대상의 이름은 tardist에 의해 생성 된 tarball의 이름입니다. 이 목표는 distdir을 tarball로 바꾸는 실제 작업을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="7f384abee623b7aefa3eee77d6cf325a89576f28" translate="yes" xml:space="preserve">
          <source>The name of this target is the name of the zip file generated by zipdist. This target does the actual work of turning the distdir into a zip file.</source>
          <target state="translated">이 대상의 이름은 zipdist에 의해 생성 된 zip 파일의 이름입니다. 이 대상은 distdir을 zip 파일로 변환하는 실제 작업을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="40fffdd6d8d082596e0b6d7269c4fc2ab2372dd8" translate="yes" xml:space="preserve">
          <source>The name or URL, or &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; if none. (E.g., in &quot;L&amp;lt;Perl Functions|perlfunc&amp;gt;&quot;, the name (also sometimes called the page) is &quot;perlfunc&quot;. In &quot;L&amp;lt;/CAVEATS&amp;gt;&quot;, the name is &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;.)</source>
          <target state="translated">이름 또는 URL 또는 없으면 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 입니다. 예를 들어 &quot;L &amp;lt;Perl Functions | perlfunc&amp;gt;&quot;에서 이름 (페이지라고도 함)은 &quot;perlfunc&quot;입니다. &quot;L &amp;lt;/ CAVEATS&amp;gt;&quot;에서 이름은 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="db1774b0bd337a6db893379927df425f03f56870" translate="yes" xml:space="preserve">
          <source>The name or URL, or &lt;code&gt;undef&lt;/code&gt; if none. (E.g., in &quot;L&amp;lt;Perl Functions|perlfunc&amp;gt;&quot;, the name (also sometimes called the page) is &quot;perlfunc&quot;. In &quot;L&amp;lt;/CAVEATS&amp;gt;&quot;, the name is &lt;code&gt;undef&lt;/code&gt;.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="032b79c8986bca0bbbc3c31a86f48e2e4e0d3085" translate="yes" xml:space="preserve">
          <source>The name returned is the &quot;best&quot; (defined below) official name or alias for the code point, if available; otherwise your custom alias for it, if defined; otherwise &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;. This means that your alias will only be returned for code points that don't have an official Unicode name (nor alias) such as private use code points.</source>
          <target state="translated">반환 된 이름은 가능한 경우 코드 포인트의 &quot;최고&quot;(아래에 정의 된) 공식 이름 또는 별명입니다. 그렇지 않으면 정의 된 경우 사용자 정의 별명; 그렇지 않으면 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; . 즉, 개인용 사용 코드 포인트와 같이 공식 유니 코드 이름 (또는 별명)이없는 코드 포인트에 대해서만 별명이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="6ccf456e05fb0bbcace6b6fbae7f69f4f9acbb13" translate="yes" xml:space="preserve">
          <source>The name returned is the &quot;best&quot; (defined below) official name or alias for the code point, if available; otherwise your custom alias for it, if defined; otherwise &lt;code&gt;undef&lt;/code&gt;. This means that your alias will only be returned for code points that don't have an official Unicode name (nor alias) such as private use code points.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45c859e03c561ae7900b19a5195289cf330fd686" translate="yes" xml:space="preserve">
          <source>The name specification contains the name of the option, optionally followed by a list of alternative names separated by vertical bar characters.</source>
          <target state="translated">이름 사양에는 옵션 이름이 포함되며 선택적으로 세로 막대 문자로 구분 된 대체 이름 목록이옵니다.</target>
        </trans-unit>
        <trans-unit id="c00824bf96e3af72974b0dc7167ce50b9784a97a" translate="yes" xml:space="preserve">
          <source>The name stored in the pad name struct. This returns &lt;code&gt;NULL&lt;/code&gt; for a target slot.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74ea5f2153ac354bb676ac855da5204a1c4f0887" translate="yes" xml:space="preserve">
          <source>The name stored in the pad name struct. This returns NULL for a target slot.</source>
          <target state="translated">패드 이름 구조체에 저장된 이름입니다. 대상 슬롯에 대해 NULL을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="8d08870c9ada1df075e2fe0edf360d9170cd33f2" translate="yes" xml:space="preserve">
          <source>The name supplied for the test.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c9c5d421e8490b0fb44df42960273145ec017c2" translate="yes" xml:space="preserve">
          <source>The name that &lt;code&gt;gv_stash*v&lt;/code&gt; wants is the name of the package whose symbol table you want. The default package is called &lt;code&gt;main&lt;/code&gt; . If you have multiply nested packages, pass their names to &lt;code&gt;gv_stash*v&lt;/code&gt; , separated by &lt;code&gt;::&lt;/code&gt; as in the Perl language itself.</source>
          <target state="translated">이라는 이름 &lt;code&gt;gv_stash*v&lt;/code&gt; 원하는 심볼 테이블에 원하는 패키지의 이름입니다. 기본 패키지는 &lt;code&gt;main&lt;/code&gt; 입니다. 중첩 된 패키지가 여러 개인 경우, 이름을 Perl 언어 자체에서와 같이 &lt;code&gt;::&lt;/code&gt; 로 구분 하여 &lt;code&gt;gv_stash*v&lt;/code&gt; 로 전달 하십시오.</target>
        </trans-unit>
        <trans-unit id="3ac1dff6b7360564b5ef0a6823013e115cd6dc89" translate="yes" xml:space="preserve">
          <source>The name that &lt;code&gt;gv_stash*v&lt;/code&gt; wants is the name of the package whose symbol table you want. The default package is called &lt;code&gt;main&lt;/code&gt;. If you have multiply nested packages, pass their names to &lt;code&gt;gv_stash*v&lt;/code&gt;, separated by &lt;code&gt;::&lt;/code&gt; as in the Perl language itself.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5602fbc4cb262cfe30268630c826bf892b1b3d53" translate="yes" xml:space="preserve">
          <source>The name used by the Perl community. That includes 'utf8' and 'ascii'. Unlike aliases, canonical names directly reach the method so such frequently used words like 'utf8' don't need to do alias lookups.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44f8223ba7b643b349f360058fbf26b1973aa5a7" translate="yes" xml:space="preserve">
          <source>The name used by the organization that defined it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ea1c9f71e1742c14f7e274aadd24083453f785c" translate="yes" xml:space="preserve">
          <source>The name used to execute the current copy of Perl, from C's &lt;code&gt;argv[0]&lt;/code&gt; or (where supported)</source>
          <target state="translated">C의 &lt;code&gt;argv[0]&lt;/code&gt; 또는 (지원되는 경우) 에서 현재 Perl 사본을 실행하는 데 사용되는 이름</target>
        </trans-unit>
        <trans-unit id="7d5e4108cb484849f5cc23fa9d5c378793d57fcf" translate="yes" xml:space="preserve">
          <source>The names</source>
          <target state="translated">이름</target>
        </trans-unit>
        <trans-unit id="e163bed624ffb39e2435b88e57776aaac39a8121" translate="yes" xml:space="preserve">
          <source>The names are in the old-style (see &lt;a href=&quot;#Old-style-versus-new-style-block-names&quot;&gt;&quot;Old-style versus new-style block names&quot;&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="618e9ec6e6fd129b3719b6fed50188e89fd59442" translate="yes" xml:space="preserve">
          <source>The names are in the old-style (see &lt;a href=&quot;#Old-style-versus-new-style-block-names&quot;&gt;Old-style versus new-style block names&lt;/a&gt;).</source>
          <target state="translated">이름은 이전 스타일입니다 ( &lt;a href=&quot;#Old-style-versus-new-style-block-names&quot;&gt;이전 스타일 대 새 스타일 블록 이름 참조&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="07ca386df79309f7e041c206d3183ef66c0ddbc4" translate="yes" xml:space="preserve">
          <source>The names associated with pad entries.</source>
          <target state="translated">패드 항목과 관련된 이름입니다.</target>
        </trans-unit>
        <trans-unit id="9b163a7bfc6ff4bff1595ddcc9e4a9a73a9a9a05" translate="yes" xml:space="preserve">
          <source>The names have been chosen by analogy with &lt;a href=&quot;Tie::Scalar&quot;&gt;Tie::Scalar&lt;/a&gt; methods names with an additional &lt;b&gt;LENGTH&lt;/b&gt; callback for efficiency. However named capture variables are currently not tied internally but implemented via magic.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="284af84a82eacc68e4acdb3ccfa2e6b8438eb902" translate="yes" xml:space="preserve">
          <source>The names have been chosen by analogy with &lt;a href=&quot;tie/scalar&quot;&gt;Tie::Scalar&lt;/a&gt; methods names with an additional &lt;b&gt;LENGTH&lt;/b&gt; callback for efficiency. However named capture variables are currently not tied internally but implemented via magic.</source>
          <target state="translated">이름은 효율성을 위해 추가 &lt;b&gt;LENGTH&lt;/b&gt; 콜백 이있는 &lt;a href=&quot;tie/scalar&quot;&gt;Tie :: Scalar&lt;/a&gt; 메소드 이름과 유사하게 선택되었습니다 . 그러나 명명 된 캡처 변수는 현재 내부적으로 연결되어 있지 않지만 마술을 통해 구현됩니다.&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="6f2021e99e612abfa74ac94b1f6cbd3e729a273e" translate="yes" xml:space="preserve">
          <source>The names of any symbols that cannot be exported should be listed in the &lt;code&gt;@EXPORT_FAIL&lt;/code&gt; array.</source>
          <target state="translated">내보낼 수없는 기호 이름은 &lt;code&gt;@EXPORT_FAIL&lt;/code&gt; 배열에 나열되어야합니다 .</target>
        </trans-unit>
        <trans-unit id="ce28b5edeebefe670a07dac363032a7c7d1c8c78" translate="yes" xml:space="preserve">
          <source>The names of one or more patch files or other text attachments to be included with the report. Multiple files must be separated with commas.</source>
          <target state="translated">보고서에 포함 할 하나 이상의 패치 파일 또는 기타 텍스트 첨부 파일의 이름입니다. 여러 파일은 쉼표로 구분해야합니다.</target>
        </trans-unit>
        <trans-unit id="8f857c3b3defbce0780a8f039ec3e39d992aed2b" translate="yes" xml:space="preserve">
          <source>The names of the constants are grouped by length. Generate child subroutines for each group with this number or more names in.</source>
          <target state="translated">상수의 이름은 길이별로 그룹화됩니다. 이 번호 이상의 이름을 가진 각 그룹에 대한 하위 서브 루틴을 생성하십시오.</target>
        </trans-unit>
        <trans-unit id="014e7ffcf388c955244e207841832a805e1b764b" translate="yes" xml:space="preserve">
          <source>The names of the fields can be obtained by calling &lt;code&gt;overview_fmt&lt;/code&gt; .</source>
          <target state="translated">필드의 이름은 &lt;code&gt;overview_fmt&lt;/code&gt; 를 호출하여 얻을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e645b67ba06f3c61734454bcb81a97d709157227" translate="yes" xml:space="preserve">
          <source>The names of the fields can be obtained by calling &lt;code&gt;overview_fmt&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4fc313d5aefbc7e8f27ebb1be72375df1f65ec2" translate="yes" xml:space="preserve">
          <source>The names of the signals are the ones listed out by &lt;code&gt;&lt;a href=&quot;functions/kill&quot;&gt;kill&lt;/a&gt; -l&lt;/code&gt; on your system, or you can retrieve them using the CPAN module &lt;a href=&quot;http://search.cpan.org/perldoc/IPC::Signal&quot;&gt;IPC::Signal&lt;/a&gt;.</source>
          <target state="translated">신호의 이름은 시스템에서 &lt;code&gt;&lt;a href=&quot;functions/kill&quot;&gt;kill&lt;/a&gt; -l&lt;/code&gt; 로 표시되거나 CPAN 모듈 &lt;a href=&quot;http://search.cpan.org/perldoc/IPC::Signal&quot;&gt;IPC :: Signal을&lt;/a&gt; 사용하여 검색 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6e02e2136011dc08d1ab7910eb739f830a21ebe7" translate="yes" xml:space="preserve">
          <source>The names of the signals are the ones listed out by &lt;code&gt;kill -l&lt;/code&gt; on your system, or you can retrieve them using the CPAN module &lt;a href=&quot;IPC::Signal&quot;&gt;IPC::Signal&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e5a87a1d013fec4fa7021ebe1fad71eb5dada0f" translate="yes" xml:space="preserve">
          <source>The naming of encodings, both by the &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; and by the &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; pragma allows for flexible names: &lt;code&gt;koi8-r&lt;/code&gt; and &lt;code&gt;KOI8R&lt;/code&gt; will both be understood.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; pragma에 의한 인코딩 이름 지정은 유연한 이름을 허용합니다. &lt;code&gt;koi8-r&lt;/code&gt; 및 &lt;code&gt;KOI8R&lt;/code&gt; 은 모두 이해됩니다.</target>
        </trans-unit>
        <trans-unit id="854c8ac2d9120b67c893ac9dc1ee0ecda32433aa" translate="yes" xml:space="preserve">
          <source>The naming of encodings, both by the &lt;code&gt;open()&lt;/code&gt; and by the &lt;code&gt;open&lt;/code&gt; pragma allows for flexible names: &lt;code&gt;koi8-r&lt;/code&gt; and &lt;code&gt;KOI8R&lt;/code&gt; will both be understood.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8afc81fb7787a63e6fa9bc963817cbc2add1c18f" translate="yes" xml:space="preserve">
          <source>The native Win32 version of &lt;code&gt;seek()&lt;/code&gt;. &lt;code&gt;SetFilePointer&lt;/code&gt; sets the position within a file where the next read or write operation will start from.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb26ebee327534f7eadec1f76baa31ad090fef00" translate="yes" xml:space="preserve">
          <source>The native status returned by the last pipe close, backtick (&lt;code&gt;``&lt;/code&gt; ) command, successful call to &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait()&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/waitpid&quot;&gt;waitpid()&lt;/a&gt;&lt;/code&gt;, or from the &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system()&lt;/a&gt;&lt;/code&gt; operator. On POSIX-like systems this value can be decoded with the WIFEXITED, WEXITSTATUS, WIFSIGNALED, WTERMSIG, WIFSTOPPED, WSTOPSIG and WIFCONTINUED functions provided by the &lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt; module.</source>
          <target state="translated">마지막 파이프 닫기, 백틱 ( &lt;code&gt;``&lt;/code&gt; ) 명령, &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait()&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;functions/waitpid&quot;&gt;waitpid()&lt;/a&gt;&lt;/code&gt; 호출 성공 또는 &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system()&lt;/a&gt;&lt;/code&gt; 연산자 에서 리턴 된 기본 상태 입니다. POSIX 유사 시스템에서이 값은 &lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt; 모듈에서 제공하는 WIFEXITED, WEXITSTATUS, WIFSIGNALED, WTERMSIG, WIFSTOPPED, WSTOPSIG 및 WIFCONTINUED 함수를 사용하여 디코딩 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="bbaba3e2cc788e3f7da9b6f38cb2688cde834f68" translate="yes" xml:space="preserve">
          <source>The native status returned by the last pipe close, backtick (&lt;code&gt;``&lt;/code&gt;) command, successful call to &lt;code&gt;wait()&lt;/code&gt; or &lt;code&gt;waitpid()&lt;/code&gt;, or from the &lt;code&gt;system()&lt;/code&gt; operator. On POSIX-like systems this value can be decoded with the WIFEXITED, WEXITSTATUS, WIFSIGNALED, WTERMSIG, WIFSTOPPED, WSTOPSIG and WIFCONTINUED functions provided by the &lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt; module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f679d50295d2d00d85ba280df81111988684878" translate="yes" xml:space="preserve">
          <source>The natural question: &quot;Why can't Perl compensate for the gaps?&quot; warrants an answer. One good reason is that C compilers might provide (non-ANSI) extensions permitting all sorts of fancy control over the way structures are aligned, even at the level of an individual structure field. And, if this were not enough, there is an insidious thing called &lt;code&gt;union&lt;/code&gt; where the amount of fill bytes cannot be derived from the alignment of the next item alone.</source>
          <target state="translated">당연한 질문 : &quot;펄은 왜 그 차이를 보상 할 수 없습니까?&quot; 답을 보증합니다. 좋은 이유 중 하나는 C 컴파일러가 (ANSI가 아닌) 확장을 제공하여 개별 구조 필드 수준에서도 구조가 정렬되는 방식에 대한 모든 종류의 멋진 제어를 허용 할 수 있기 때문입니다. 그리고 이것이 충분 하지 않으면 다음 항목의 정렬에서만 채우기 바이트의 양을 도출 할 수없는 &lt;code&gt;union&lt;/code&gt; 이라는 교활한 것이 있습니다.</target>
        </trans-unit>
        <trans-unit id="73304f2bc3720cbdf5bbe3a347ce1a6a6606cb3e" translate="yes" xml:space="preserve">
          <source>The natural way to do this is to have a hash whose keys are country names. Associated with each country name key is a list of the cities in that country. Each time you read a line of input, split it into a country and a city, look up the list of cities already known to be in that country, and append the new city to the list. When you're done reading the input, iterate over the hash as usual, sorting each list of cities before you print it out.</source>
          <target state="translated">이를 수행하는 자연적인 방법은 키가 국가 이름 인 해시를 갖는 것입니다. 각 국가 이름 키와 관련된 것은 해당 국가의 도시 목록입니다. 입력 줄을 읽을 때마다 국가와 도시로 나누고 해당 국가에 이미 알려진 도시 목록을 찾은 다음 새 도시를 목록에 추가하십시오. 입력을 읽었 으면 평소처럼 해시를 반복하여 인쇄하기 전에 각 도시 목록을 정렬합니다.</target>
        </trans-unit>
        <trans-unit id="47d44728d6d28aac48e384cc30fefc76b5a26c28" translate="yes" xml:space="preserve">
          <source>The negated versions of the lookahead and lookbehind assertions are denoted by &lt;code&gt;(?!regexp)&lt;/code&gt; and &lt;code&gt;(?&amp;lt;!fixed-regexp)&lt;/code&gt; respectively. Or, starting in 5.32 (experimentally in 5.28), &lt;code&gt;(*nla:regexp)&lt;/code&gt;, &lt;code&gt;(*negative_lookahead:regexp)&lt;/code&gt;, &lt;code&gt;(*nlb:regexp)&lt;/code&gt;, or &lt;code&gt;(*negative_lookbehind:regexp)&lt;/code&gt;. They evaluate true if the regexps do</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ba13cfae515a220e252c3e1157af722de7da0aa" translate="yes" xml:space="preserve">
          <source>The negation is useful for defining (surprise!) negated classes.</source>
          <target state="translated">부정은 부정 클래스를 정의하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="db0ad6bd4816ce652496b94f2f1d7976b92ada0c" translate="yes" xml:space="preserve">
          <source>The negation of this macro, &lt;code&gt;OP_TYPE_ISNT&lt;/code&gt; is also available as well as &lt;code&gt;OP_TYPE_IS_NN&lt;/code&gt; and &lt;code&gt;OP_TYPE_ISNT_NN&lt;/code&gt; which elide the NULL pointer check.</source>
          <target state="translated">이 매크로의 부정, &lt;code&gt;OP_TYPE_ISNT&lt;/code&gt; 는 뿐만 아니라도 사용할 수 있습니다 &lt;code&gt;OP_TYPE_IS_NN&lt;/code&gt; 및 &lt;code&gt;OP_TYPE_ISNT_NN&lt;/code&gt; 널 (NULL) 포인터 검사를 생략하다.</target>
        </trans-unit>
        <trans-unit id="34a8b60e3a36600480a60cec2deec17ff174ebef" translate="yes" xml:space="preserve">
          <source>The negation of this macro, &lt;code&gt;OP_TYPE_ISNT_AND_WASNT&lt;/code&gt; is also available as well as &lt;code&gt;OP_TYPE_IS_OR_WAS_NN&lt;/code&gt; and &lt;code&gt;OP_TYPE_ISNT_AND_WASNT_NN&lt;/code&gt; which elide the &lt;code&gt;NULL&lt;/code&gt; pointer check.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="691f70fa29f72e49de97eccc12c05c1f840f1b46" translate="yes" xml:space="preserve">
          <source>The negation of this macro, &lt;code&gt;OP_TYPE_ISNT_AND_WASNT&lt;/code&gt; is also available as well as &lt;code&gt;OP_TYPE_IS_OR_WAS_NN&lt;/code&gt; and &lt;code&gt;OP_TYPE_ISNT_AND_WASNT_NN&lt;/code&gt; which elide the NULL pointer check.</source>
          <target state="translated">이 매크로의 부정 인 &lt;code&gt;OP_TYPE_ISNT_AND_WASNT&lt;/code&gt; 는 NULL 포인터 검사를 필요 로하지 &lt;code&gt;OP_TYPE_IS_OR_WAS_NN&lt;/code&gt; 및 &lt;code&gt;OP_TYPE_ISNT_AND_WASNT_NN&lt;/code&gt; 뿐만 아니라 사용 가능 합니다.</target>
        </trans-unit>
        <trans-unit id="528d5b378ab36165946632706d39fa6c9839837e" translate="yes" xml:space="preserve">
          <source>The new behavior provides a much more robust solution for checking Winsock errors in portable software without accidentally matching POSIX tests that were intended for other OSes and may have different meanings for Winsock.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a68f1f4d38ce035e2e238de529bbc7313afe802e" translate="yes" xml:space="preserve">
          <source>The new class is given a constructor method, &lt;code&gt;new&lt;/code&gt; , for creating struct objects.</source>
          <target state="translated">새 클래스에는 구조체 객체를 생성하기위한 &lt;code&gt;new&lt;/code&gt; 생성자 메서드가 제공 됩니다.</target>
        </trans-unit>
        <trans-unit id="9d80888ad8b596747bf8185a9ccf7eb36f05c472" translate="yes" xml:space="preserve">
          <source>The new class is given a constructor method, &lt;code&gt;new&lt;/code&gt;, for creating struct objects.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="133a286ef1fa797920ffbacb6d543c092bbb9c81" translate="yes" xml:space="preserve">
          <source>The new compare function must be specified when you create the database.</source>
          <target state="translated">데이터베이스를 작성할 때 새 비교 기능을 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="6ca5133e85084fb8ccd654bdee5f648c6a7925f9" translate="yes" xml:space="preserve">
          <source>The new interface to the USE_PERLIO implementation. The layers &quot;:crlf&quot; and &quot;:raw&quot; are only ones allowed for other implementations and those are silently ignored. (As of perl5.8 &quot;:raw&quot; is deprecated.) Use PerlIO_binmode() below for the portable case.</source>
          <target state="translated">USE_PERLIO 구현에 대한 새로운 인터페이스. &quot;: crlf&quot;및 &quot;: raw&quot;레이어는 다른 구현에 허용되는 레이어 일 뿐이며 자동 무시됩니다. (perl5.8부터 &quot;: raw&quot;는 더 이상 사용되지 않습니다.) 휴대용 케이스의 경우 아래 PerlIO_binmode ()를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="ef605716ebbaada258955508adf61e07c343c95f" translate="yes" xml:space="preserve">
          <source>The new key is specified by</source>
          <target state="translated">새로운 키는</target>
        </trans-unit>
        <trans-unit id="93da98420a9bfc76d18ae79d8876182fff5c85c5" translate="yes" xml:space="preserve">
          <source>The new key is specified by &lt;code&gt;keypv&lt;/code&gt; and &lt;code&gt;keylen&lt;/code&gt;. If &lt;code&gt;flags&lt;/code&gt; has the &lt;code&gt;REFCOUNTED_HE_KEY_UTF8&lt;/code&gt; bit set, the key octets are interpreted as UTF-8, otherwise they are interpreted as Latin-1. &lt;code&gt;hash&lt;/code&gt; is a precomputed hash of the key string, or zero if it has not been precomputed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="853b1cad8315c050b3031642990285f3b3f61796" translate="yes" xml:space="preserve">
          <source>The new perlIO layer is used. NI-S' favorite.</source>
          <target state="translated">새로운 perlIO 레이어가 사용됩니다. NI-S가 가장 좋아합니다.</target>
        </trans-unit>
        <trans-unit id="437054ab8086dcb8d5230b53692e92ce8976728d" translate="yes" xml:space="preserve">
          <source>The new prereqs object has no ties to the originals, and altering it further will not alter them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f44fc740bd8115fd48ea2f3dccbe8d30383620f" translate="yes" xml:space="preserve">
          <source>The new routine will be called whenever a built-in function is called without a qualifying package:</source>
          <target state="translated">적격 패키지없이 내장 함수가 호출 될 때마다 새 루틴이 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="69fd8169a1c03a87b9cb7323668ea2985b78ca39" translate="yes" xml:space="preserve">
          <source>The new semantics are now only available with &lt;code&gt;make_path&lt;/code&gt; and &lt;code&gt;remove_tree&lt;/code&gt; . The old semantics are only available through &lt;code&gt;mkpath&lt;/code&gt; and &lt;code&gt;rmtree&lt;/code&gt; . Users are strongly encouraged to upgrade to at least 2.08 in order to avoid surprises.</source>
          <target state="translated">새 시맨틱은 이제 &lt;code&gt;make_path&lt;/code&gt; 및 &lt;code&gt;remove_tree&lt;/code&gt; 에서만 사용할 수 있습니다 . 구 시맨틱은 &lt;code&gt;mkpath&lt;/code&gt; 와 &lt;code&gt;rmtree&lt;/code&gt; 를 통해서만 사용할 수 있습니다 . 놀라움을 피하기 위해 최소한 2.08로 업그레이드하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="e786b3ec60d0d79422f9596d38dfebba203b53ce" translate="yes" xml:space="preserve">
          <source>The new semantics are now only available with &lt;code&gt;make_path&lt;/code&gt; and &lt;code&gt;remove_tree&lt;/code&gt;. The old semantics are only available through &lt;code&gt;mkpath&lt;/code&gt; and &lt;code&gt;rmtree&lt;/code&gt;. Users are strongly encouraged to upgrade to at least 2.08 in order to avoid surprises.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dcb00043758d6e48f38e06be5dcd0156fe97d078" translate="yes" xml:space="preserve">
          <source>The new shiny result of either genuine new functionality or your arduous refactoring is now ready and correctly exported. So what could possibly go wrong?</source>
          <target state="translated">진정한 새로운 기능 또는 까다로운 리팩토링의 새로운 결과는 이제 준비되어 올바르게 내보내집니다. 그렇다면 무엇이 잘못 될 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="c231cf25130a94dd10bb860a955a6b6ad30c18f8" translate="yes" xml:space="preserve">
          <source>The new simpler way to call &lt;code&gt;XSLoader::load()&lt;/code&gt; with no arguments at all does not work on Perl 5.8.4 and 5.8.5.</source>
          <target state="translated">인수없이 &lt;code&gt;XSLoader::load()&lt;/code&gt; 를 호출하는 새로운 간단한 방법 은 Perl 5.8.4 및 5.8.5에서 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="80d8983154af8008f3d7e48dfd488df835186d04" translate="yes" xml:space="preserve">
          <source>The new thread creation is line 20. We pass on to it a reference to the queue we've created, and the prime number we've found. In lines 21 through 24, we check to make sure that our new thread got created, and if not, we stop checking any remaining numbers in the queue.</source>
          <target state="translated">새로운 스레드 생성은 20 행입니다. 생성 한 대기열과 찾은 소수에 대한 참조를 전달합니다. 21 행부터 24 행까지, 우리는 새로운 쓰레드가 생성되었는지 확인하고, 그렇지 않으면 큐에 남아있는 숫자의 체크를 중단합니다.</target>
        </trans-unit>
        <trans-unit id="9044c695c3da968e5a2ea15d51b8b1e2dbc7cbb0" translate="yes" xml:space="preserve">
          <source>The new() function searches for all the installed .packlists on the system, and stores their contents. The .packlists can be queried with the functions described below. Where it searches by default is determined by the settings found in &lt;code&gt;%Config::Config&lt;/code&gt; , and what the value is of the PERL5LIB environment variable.</source>
          <target state="translated">new () 함수는 시스템에 설치된 모든 .packlist를 검색하고 내용을 저장합니다. .packlist는 아래 설명 된 기능으로 쿼리 할 수 ​​있습니다. 기본적으로 검색되는 위치는 &lt;code&gt;%Config::Config&lt;/code&gt; 에있는 설정 및 PERL5LIB 환경 변수의 값 에 따라 결정됩니다 .</target>
        </trans-unit>
        <trans-unit id="e6b22aa358acbe55c29900d7f62b40d0edc02821" translate="yes" xml:space="preserve">
          <source>The new() function searches for all the installed .packlists on the system, and stores their contents. The .packlists can be queried with the functions described below. Where it searches by default is determined by the settings found in &lt;code&gt;%Config::Config&lt;/code&gt;, and what the value is of the PERL5LIB environment variable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e76ad120503fe22fb2abd0288095a443b471d16" translate="yes" xml:space="preserve">
          <source>The newer style replaces these with underscores, like this:</source>
          <target state="translated">최신 스타일은 다음과 같이 밑줄로 대체합니다.</target>
        </trans-unit>
        <trans-unit id="0249c11220739d961eab9d8efdfb827caa468595" translate="yes" xml:space="preserve">
          <source>The newly created subroutine takes ownership of a reference to the passed in SV.</source>
          <target state="translated">새로 작성된 서브 루틴은 전달 된 SV에 대한 참조의 소유권을 갖습니다.</target>
        </trans-unit>
        <trans-unit id="c36ff1fb86ca87ccc2385388c9e1be809de8496c" translate="yes" xml:space="preserve">
          <source>The next 8 bits contain the termination status of the program.</source>
          <target state="translated">다음 8 비트는 프로그램의 종료 상태를 포함합니다.</target>
        </trans-unit>
        <trans-unit id="429ca09b18f928ad50edc605bbb88976cae30220" translate="yes" xml:space="preserve">
          <source>The next example demonstrates how one would place an explicit undef in the return value, should the need arise.</source>
          <target state="translated">다음 예제는 필요한 경우 반환 값에 명시 적 undef를 배치하는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="abdb50fe44b0e7ab1495a77ca76309d394c16e26" translate="yes" xml:space="preserve">
          <source>The next example show how to use the &lt;code&gt;LimitOutput&lt;/code&gt; option. Notice the use of two nested loops in this case. The outer loop reads the data from the input source - STDIN and the inner loop repeatedly calls &lt;code&gt;inflate&lt;/code&gt; until &lt;code&gt;$input&lt;/code&gt; is exhausted, we get an error, or the end of the stream is reached. One point worth remembering is by using the &lt;code&gt;LimitOutput&lt;/code&gt; option you also get &lt;code&gt;ConsumeInput&lt;/code&gt; set as well - this makes the code below much simpler.</source>
          <target state="translated">다음 예제는 &lt;code&gt;LimitOutput&lt;/code&gt; 옵션 을 사용하는 방법을 보여줍니다 . 이 경우 두 개의 중첩 루프가 사용됩니다. 외부 루프는 입력 소스에서 데이터를 읽습니다-STDIN 및 내부 루프 는 &lt;code&gt;$input&lt;/code&gt; 이 소진되거나 오류가 발생하거나 스트림의 끝에 도달 할 때까지 &lt;code&gt;inflate&lt;/code&gt; 반복적으로 호출합니다 . 원 포인트 가치가 기억하는이 사용하는 것입니다 &lt;code&gt;LimitOutput&lt;/code&gt; 의 당신은 또한 얻을 옵션을 &lt;code&gt;ConsumeInput&lt;/code&gt; 의 이 훨씬 간단 아래의 코드를 만들어 - 잘으로 설정합니다.</target>
        </trans-unit>
        <trans-unit id="a73f1f7691d7497b711d0f4bac2e881b3c885873" translate="yes" xml:space="preserve">
          <source>The next example shows each input parameter evaluated late.</source>
          <target state="translated">다음 예는 늦게 평가 된 각 입력 매개 변수를 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="def9f1245a38d3c5116ce761f9376e6f2078f597" translate="yes" xml:space="preserve">
          <source>The next examples will use the following C++ class.</source>
          <target state="translated">다음 예제는 다음 C ++ 클래스를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="6c82e2eba4791c1303c10eb37d70a72bf59badcd" translate="yes" xml:space="preserve">
          <source>The next option deals with the charset (a.k.a. character set) your terminal supports. In general, CPAN is English speaking territory, so the charset does not matter much but some CPAN have names that are outside the ASCII range. If your terminal supports UTF-8, you should say no to the next question. If it expects ISO-8859-1 (also known as LATIN1) then you should say yes. If it supports neither, your answer does not matter because you will not be able to read the names of some authors anyway. If you answer no, names will be output in UTF-8.</source>
          <target state="translated">다음 옵션은 터미널이 지원하는 문자 세트 (일명 문자 세트)를 처리합니다. 일반적으로 CPAN은 영어를 사용하는 영역이므로 문자 집합은 중요하지 않지만 일부 CPAN의 이름은 ASCII 범위를 벗어납니다. 터미널이 UTF-8을 지원하는 경우 다음 질문에 '아니요'라고 말해야합니다. ISO-8859-1 (LATIN1이라고도 함)이 필요한 경우 예라고 말해야합니다. 두 가지 모두를 지원하지 않으면 일부 저자의 이름을 읽을 수 없으므로 답이 중요하지 않습니다. no로 대답하면 이름이 UTF-8로 출력됩니다.</target>
        </trans-unit>
        <trans-unit id="128477608ba084f3baead065e12f71790ccb5def" translate="yes" xml:space="preserve">
          <source>The next pointer for &lt;code&gt;BRANCH&lt;/code&gt; es is interesting in that it points at where execution should go if the branch fails. When executing, if the engine tries to traverse from a branch to a &lt;code&gt;regnext&lt;/code&gt; that isn't a branch then the engine will know that the entire set of branches has failed.</source>
          <target state="translated">&lt;code&gt;BRANCH&lt;/code&gt; es에 대한 다음 포인터 는 분기가 실패 할 경우 실행이 어디로 가야하는지에 대한 점입니다. 실행할 때 엔진이에 지점에서 통과하려고하면, &lt;code&gt;regnext&lt;/code&gt; 지점 아니다 후 엔진이 지점의 전체 세트가 실패했음을 알 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="49d098f677fc7d28016366882913ea295f0ea710" translate="yes" xml:space="preserve">
          <source>The next pointer for &lt;code&gt;BRANCH&lt;/code&gt;es is interesting in that it points at where execution should go if the branch fails. When executing, if the engine tries to traverse from a branch to a &lt;code&gt;regnext&lt;/code&gt; that isn't a branch then the engine will know that the entire set of branches has failed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b56244f1caeaf0b5b4e0b479de80d44c501b35d" translate="yes" xml:space="preserve">
          <source>The next step is interpolation in the text obtained, which is now delimiter-independent. There are multiple cases.</source>
          <target state="translated">다음 단계는 얻은 텍스트의 보간이며, 이제 구분 기호와 무관합니다. 여러 경우가 있습니다.</target>
        </trans-unit>
        <trans-unit id="2e9d420a49c5570abf7ae9f3e075e9465afea859" translate="yes" xml:space="preserve">
          <source>The next step is the type-specific context processing; in this case &lt;code&gt;cx_popsub&lt;/code&gt;. In part, this looks like:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b245543afec9985d508833acde280bdb2e09df89" translate="yes" xml:space="preserve">
          <source>The next step is to add some symlinks to system libraries. For example, the development software expect a library &lt;code&gt;libm.so&lt;/code&gt; that normally is a symlink to &lt;code&gt;libm.so.6&lt;/code&gt;. Synology only provides the latter and not the symlink.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0e87f516f02471787ab2f018e28d7851e0ac5f9" translate="yes" xml:space="preserve">
          <source>The next step is to pop savestack entries: &lt;code&gt;CX_LEAVE_SCOPE(cx)&lt;/code&gt; is just defined as &lt;code&gt;LEAVE_SCOPE(cx-&amp;gt;blk_oldsaveix)&lt;/code&gt;. Note that during the popping, it's possible for perl to call destructors, call &lt;code&gt;STORE&lt;/code&gt; to undo localisations of tied vars, and so on. Any of these can die or call &lt;code&gt;exit()&lt;/code&gt;. In this case, &lt;code&gt;dounwind()&lt;/code&gt; will be called, and the current context stack frame will be re-processed. Thus it is vital that all steps in popping a context are done in such a way to support reentrancy. The other alternative, of decrementing &lt;code&gt;cxstack_ix&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99d612978700e6928f957643eba3d0d61622b6ed" translate="yes" xml:space="preserve">
          <source>The next step is to submit your patch to the Perl core ticket system via email.</source>
          <target state="translated">다음 단계는 이메일을 통해 패치를 Perl 코어 티켓 시스템에 제출하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="c53212a853da747bb753ac0eb206bd02a60002ca" translate="yes" xml:space="preserve">
          <source>The next step is to submit your patch to the Perl core ticket system.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82a6f456a2c90d50e2abfb7f37ee6f9a4299445f" translate="yes" xml:space="preserve">
          <source>The next task is to break the problem down into smaller problems that are easily converted into a regexp.</source>
          <target state="translated">다음 작업은 문제를 정규식으로 쉽게 변환되는 작은 문제로 나누는 것입니다.</target>
        </trans-unit>
        <trans-unit id="c9e21bae9fb5eef63978dcfa71c7a0d3cb21ec24" translate="yes" xml:space="preserve">
          <source>The next time you wish to make a patch, you need to start from the latest perl in a pristine state. Check you don't have any local changes or added files in your perl check-out which you wish to keep, then run these commands:</source>
          <target state="translated">다음에 패치를 만들려면 깨끗한 상태에서 최신 펄에서 시작해야합니다. 펄 체크 아웃에 유지하려는 로컬 변경 사항이나 추가 된 파일이 없는지 확인한 후 다음 명령을 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="79f58ceb3f799f52310d0fb9160eed5d3d3eaba7" translate="yes" xml:space="preserve">
          <source>The nice part about todo tests, as opposed to simply commenting out a block of tests, is it's like having a programmatic todo list. You know how much work is left to be done, you're aware of what bugs there are, and you'll know immediately when they're fixed.</source>
          <target state="translated">단순히 테스트 블록을 주석 처리하는 것과 달리, 할 일 테스트에 대한 좋은 부분은 프로그래밍 방식의 할 일 목록을 갖는 것과 같습니다. 수행해야 할 작업량을 알고 버그가 무엇인지 알고 있으며 수정 된 시점을 즉시 알 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="93f6c477375802df02f9578f889b424f60ac9928" translate="yes" xml:space="preserve">
          <source>The nice part about todo tests, as opposed to simply commenting out a block of tests, is that it is like having a programmatic todo list. You know how much work is left to be done, you're aware of what bugs there are, and you'll know immediately when they're fixed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92737be37077b1e4ee6685cd7da7d12b0a775c27" translate="yes" xml:space="preserve">
          <source>The nmake that comes with Visual C++ will suffice for building. Visual C requires that certain things be set up in the console before Visual C will sucessfully run. To make a console box be able to run the C compiler, you will need to beforehand, run the &lt;code&gt;vcvars32.bat&lt;/code&gt; file to compile for x86-32 and for x86-64 &lt;code&gt;vcvarsall.bat x64&lt;/code&gt; or &lt;code&gt;vcvarsamd64.bat&lt;/code&gt; . On a typical install of a Microsoft C compiler product, these batch files will already be in your &lt;code&gt;PATH&lt;/code&gt; environment variable so you may just type them without an absolute path into your console. If you need to find the absolute path to the batch file, it is usually found somewhere like C:\Program Files\Microsoft Visual Studio\VC98\Bin. With some newer Micrsoft C products (released after ~2004), the installer will put a shortcut in the start menu to launch a new console window with the console already set up for your target architecture (x86-32 or x86-64 or IA64). With the newer compilers, you may also use the older batch files if you choose so.</source>
          <target state="translated">Visual C ++와 함께 제공되는 nmake는 작성하기에 충분합니다. Visual C에서는 Visual C가 성공적으로 실행되기 전에 콘솔에 특정 항목을 설정해야합니다. 콘솔 박스가 C 컴파일러를 실행할 수있게하려면 미리 &lt;code&gt;vcvars32.bat&lt;/code&gt; 파일을 실행하여 x86-32 및 x86-64 및 &lt;code&gt;vcvarsall.bat x64&lt;/code&gt; 또는 &lt;code&gt;vcvarsamd64.bat&lt;/code&gt; 에 대해 컴파일 해야 합니다. Microsoft C 컴파일러 제품의 일반 설치에서 이러한 배치 파일은 이미 &lt;code&gt;PATH&lt;/code&gt; 에 있습니다.환경 변수이므로 콘솔에 절대 경로없이 입력 할 수 있습니다. 배치 파일의 절대 경로를 찾아야하는 경우 일반적으로 C : \ Program Files \ Microsoft Visual Studio \ VC98 \ Bin과 같습니다. 일부 최신 Micrsoft C 제품 (~ 2004 이후 출시)에서는 설치 프로그램이 시작 메뉴에 바로 가기를 추가하여 대상 아키텍처 (x86-32 또는 x86-64 또는 IA64)에 대해 콘솔이 이미 설정된 새 콘솔 창을 시작합니다. . 최신 컴파일러에서는 원하는 경우 이전 배치 파일을 사용할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="74b0871cc8ecf5b8ec07f0886c93ea7f99f29900" translate="yes" xml:space="preserve">
          <source>The nmake that comes with Visual C++ will suffice for building. Visual C++ requires that certain things be set up in the console before Visual C++ will sucessfully run. To make a console box be able to run the C compiler, you will need to beforehand, run &lt;code&gt;vcvarsall.bat x86&lt;/code&gt; to compile for x86-32 and for x86-64 &lt;code&gt;vcvarsall.bat amd64&lt;/code&gt;. On a typical install of a Microsoft C++ compiler product, these batch files will already be in your &lt;code&gt;PATH&lt;/code&gt; environment variable so you may just type them without an absolute path into your console. If you need to find the absolute path to the batch file, it is usually found somewhere like C:\Program Files (x86)\Microsoft Visual Studio 14.0\VC. With some newer Micrsoft C products (released after ~2004), the installer will put a shortcut in the start menu to launch a new console window with the console already set up for your target architecture (x86-32 or x86-64 or IA64). With the newer compilers, you may also use the older batch files if you choose so.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d92d9609b16a9236c6b0750e878097cebaf141fa" translate="yes" xml:space="preserve">
          <source>The nmake that comes with the Platform SDK will suffice for building Perl. Make sure you are building within one of the &quot;Build Environment&quot; shells available after you install the Platform SDK from the Start Menu.</source>
          <target state="translated">Platform SDK와 함께 제공되는 nmake는 Perl을 빌드하기에 충분합니다. 시작 메뉴에서 플랫폼 SDK를 설치 한 후 사용 가능한 &quot;빌드 환경&quot;쉘 중 하나에 빌드하고 있는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="4cf437af831d898cd280f5f9fa16e3b19f38db9a" translate="yes" xml:space="preserve">
          <source>The node type, either &lt;code&gt;section&lt;/code&gt; or &lt;code&gt;item&lt;/code&gt; . As an unofficial type, there is also &lt;code&gt;hyperlink&lt;/code&gt; , derived from e.g. &lt;code&gt;L&amp;lt;&lt;a href=&quot;http://perl.com&quot;&gt;http://perl.com&lt;/a&gt;&amp;gt;&lt;/code&gt;</source>
          <target state="translated">노드 유형 중 하나를 &lt;code&gt;section&lt;/code&gt; 또는 &lt;code&gt;item&lt;/code&gt; . 비공식 유형으로, 예를 들어 &lt;code&gt;L&amp;lt;&lt;a href=&quot;http://perl.com&quot;&gt;http://perl.com&lt;/a&gt;&amp;gt;&lt;/code&gt; &lt;a href=&quot;http://perl.com&quot;&gt;http://perl.com&lt;/a&gt; &amp;gt; 에서 파생 된 &lt;code&gt;hyperlink&lt;/code&gt; 도 있습니다</target>
        </trans-unit>
        <trans-unit id="9d0e0bd31f6a31a67e6263a3a5396fe920511c99" translate="yes" xml:space="preserve">
          <source>The non-ASCII characters below 256 can have various meanings, depending on various things. (See, most notably, &lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt;.) But usually the whole range can be referred to as ISO-8859-1. Often, the term &quot;Latin-1&quot; (or &quot;Latin1&quot;) is used as an equivalent for ISO-8859-1. But some people treat &quot;Latin1&quot; as referring just to the characters in the range 128 through 255, or somethimes from 160 through 255. This documentation uses &quot;Latin1&quot; and &quot;Latin-1&quot; to refer to all 256 characters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6361a2e3097d12a5b1db2175b6f9b22e2b4e005e" translate="yes" xml:space="preserve">
          <source>The non-blocking behaviour is an extension of the &lt;code&gt;IO::Socket::INET&lt;/code&gt; API, unique to &lt;code&gt;IO::Socket::IP&lt;/code&gt;, because the former does not support multi-homed non-blocking connect.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8827c5b69a11959983a358ee79f064e14c978f0c" translate="yes" xml:space="preserve">
          <source>The non-destructive modifier &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///r&lt;/a&gt;&lt;/code&gt; causes the result of the substitution to be returned instead of modifying &lt;code&gt;$_&lt;/code&gt; (or whatever variable the substitute was bound to with &lt;code&gt;=~&lt;/code&gt; ):</source>
          <target state="translated">비파괴 수정 자 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///r&lt;/a&gt;&lt;/code&gt; 은 &lt;code&gt;$_&lt;/code&gt; (또는 대체가 &lt;code&gt;=~&lt;/code&gt; 로 바인딩 된 변수) 를 수정하는 대신 대체 결과를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="33ea7bc6a1364954efde1784eb70e926a46ab789" translate="yes" xml:space="preserve">
          <source>The non-destructive modifier &lt;code&gt;s///r&lt;/code&gt; causes the result of the substitution to be returned instead of modifying &lt;code&gt;$_&lt;/code&gt; (or whatever variable the substitute was bound to with &lt;code&gt;=~&lt;/code&gt;):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3e24c19053882dd3539c4f0f017c48b302d8630" translate="yes" xml:space="preserve">
          <source>The non-zero numeric</source>
          <target state="translated">0이 아닌 숫자</target>
        </trans-unit>
        <trans-unit id="ed0d308e2d36922ca367c5db784707665a50eda8" translate="yes" xml:space="preserve">
          <source>The normal Makefile.PL that h2xs generates doesn't know about the mylib directory. We need to tell it that there is a subdirectory and that we will be generating a library in it. Let's add the argument MYEXTLIB to the WriteMakefile call so that it looks like this:</source>
          <target state="translated">h2xs가 생성하는 일반적인 Makefile.PL은 mylib 디렉토리에 대해 알지 못합니다. 하위 디렉토리가 있고 그 안에 라이브러리를 생성 할 것임을 알려야합니다. 다음과 같이 MYEXTLIB 인수를 WriteMakefile 호출에 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="b1469f4963ec233a67445e77b1dc5adf4ccf9ab7" translate="yes" xml:space="preserve">
          <source>The normal course of action is to call:</source>
          <target state="translated">정상적인 행동 과정은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="32723b8237682738b9e39db42e26b25a535a8b05" translate="yes" xml:space="preserve">
          <source>The normal return provided by &lt;code&gt;scalar(%hash)&lt;/code&gt; is not available. What this means is that using %tied_hash in boolean context doesn't work right (currently this always tests false, regardless of whether the hash is empty or hash elements). [ This paragraph needs review in light of changes in 5.25 ]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ecf683f52c0f42f564cf7e0ed381f4bb97cc8438" translate="yes" xml:space="preserve">
          <source>The normal use of this class is like so:</source>
          <target state="translated">이 클래스의 일반적인 사용법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1ac2010e9cf7828bd4211d3176636428b6a9a255" translate="yes" xml:space="preserve">
          <source>The normal way to run a Perl program is by making it directly executable, or else by passing the name of the source file as an argument on the command line. (An interactive Perl environment is also possible--see &lt;a href=&quot;perldebug&quot;&gt;perldebug&lt;/a&gt; for details on how to do that.) Upon startup, Perl looks for your program in one of the following places:</source>
          <target state="translated">Perl 프로그램을 실행하는 일반적인 방법은 프로그램을 직접 실행 가능하게하거나 소스 파일 이름을 명령 행에 인수로 전달하는 것입니다. (대화식 Perl 환경도 가능 합니다. 자세한 방법 은 &lt;a href=&quot;perldebug&quot;&gt;perldebug&lt;/a&gt; 를 참조하십시오 .) 시작할 때 Perl은 다음 위치 중 하나에서 프로그램을 찾습니다.</target>
        </trans-unit>
        <trans-unit id="42b613b12f582e26d7e800d066ea1eb52e714a90" translate="yes" xml:space="preserve">
          <source>The not-a-number as a constant:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46672cb58512b6dfcf1bfa852b6fb1012267b6a3" translate="yes" xml:space="preserve">
          <source>The notation still looks a little cumbersome, so there's one more abbreviation:</source>
          <target state="translated">이 표기법은 여전히 ​​약간 성가신 것처럼 보이므로 약어가 하나 더 있습니다.</target>
        </trans-unit>
        <trans-unit id="faf2109c5b26dde1813deee78331f15408acfe4a" translate="yes" xml:space="preserve">
          <source>The notion that an empty &lt;b&gt;derived class&lt;/b&gt; should behave exactly like its &lt;b&gt;base class&lt;/b&gt;.</source>
          <target state="translated">빈 &lt;b&gt;파생 클래스&lt;/b&gt; 는 &lt;b&gt;기본 클래스&lt;/b&gt; 와 정확히 동일하게 동작해야 한다는 개념입니다 .</target>
        </trans-unit>
        <trans-unit id="d26e84b13c8c8748080fe4085da63e6e9ef520f9" translate="yes" xml:space="preserve">
          <source>The notion that you can tell an &lt;b&gt;object&lt;/b&gt; to do something generic, and the object will interpret the command in different ways depending on its type. [&amp;lt; Greek &amp;pi;&amp;omicron;&amp;lambda;&amp;upsilon;- + &amp;mu;&amp;omicron;&amp;rho;ϕή, many forms.]</source>
          <target state="translated">&lt;b&gt;객체&lt;/b&gt; 에게 일반적인 무언가를하도록 지시 할 수 있으며 객체는 유형에 따라 다른 방식으로 명령을 해석합니다. [&amp;lt;그리스어 &amp;pi;&amp;omicron;&amp;lambda;&amp;upsilon;- + &amp;mu;&amp;omicron;&amp;rho;ϕή, 여러 형태.]</target>
        </trans-unit>
        <trans-unit id="ad272f88bed19c2e6cec366907b96e0baf112d7c" translate="yes" xml:space="preserve">
          <source>The notion that, with a complete set of simple tools that work well together, you can build almost anything you want. Which is fine if you&amp;rsquo;re assembling a tricycle, but if you&amp;rsquo;re building a defranishizing comboflux regurgalator, you really want your own machine shop in which to build special tools. Perl is sort of a machine shop.</source>
          <target state="translated">잘 작동하는 완전한 간단한 도구 세트를 사용하면 원하는 거의 모든 것을 만들 수 있습니다. 세발 자전거를 조립하는 경우에는 문제가 없지만, 디 프랜차이징 (defranishizing) comboflux regurgalator를 만드는 경우에는 특수 공구를 제작할 수있는 자체 기계 공장이 필요합니다. 펄은 일종의 기계 공장입니다.</target>
        </trans-unit>
        <trans-unit id="d8cd6888cbc4c56537079a3ca6af05881fde2aca" translate="yes" xml:space="preserve">
          <source>The null filehandle &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; is special: it can be used to emulate the behavior of &lt;b&gt;sed&lt;/b&gt; and &lt;b&gt;awk&lt;/b&gt;, and any other Unix filter program that takes a list of filenames, doing the same to each line of input from all of them. Input from &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; comes either from standard input, or from each file listed on the command line. Here's how it works: the first time &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; is evaluated, the &lt;code&gt;@ARGV&lt;/code&gt; array is checked, and if it is empty, &lt;code&gt;$ARGV[0]&lt;/code&gt; is set to &lt;code&gt;&quot;-&quot;&lt;/code&gt; , which when opened gives you standard input. The &lt;code&gt;@ARGV&lt;/code&gt; array is then processed as a list of filenames. The loop</source>
          <target state="translated">널 파일 핸들 &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; 은 특별합니다. &lt;b&gt;sed&lt;/b&gt; 및 &lt;b&gt;awk&lt;/b&gt; 의 동작 과 파일 이름 목록을 가져 오는 다른 모든 유닉스 필터 프로그램 을 에뮬레이션하는 데 사용할 수 있습니다 . 에서 입력 &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; 중 하나를 표준 입력에서 또는 명령 행에 나열된 각 파일에서 비롯됩니다. 작동 방식은 다음과 같습니다. &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; 이 처음 평가되고 &lt;code&gt;@ARGV&lt;/code&gt; 배열이 검사되며 비어 있으면 &lt;code&gt;$ARGV[0]&lt;/code&gt; 이 &lt;code&gt;&quot;-&quot;&lt;/code&gt; 로 설정되어 열릴 때 표준 입력을 제공합니다. &lt;code&gt;@ARGV&lt;/code&gt; 의 배열은 파일명의리스트로서 처리된다. 루프</target>
        </trans-unit>
        <trans-unit id="2eb5648c665e9498b1d4e1c662b451796e069c6c" translate="yes" xml:space="preserve">
          <source>The null filehandle &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; is special: it can be used to emulate the behavior of &lt;b&gt;sed&lt;/b&gt; and &lt;b&gt;awk&lt;/b&gt;, and any other Unix filter program that takes a list of filenames, doing the same to each line of input from all of them. Input from &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; comes either from standard input, or from each file listed on the command line. Here's how it works: the first time &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; is evaluated, the &lt;code&gt;@ARGV&lt;/code&gt; array is checked, and if it is empty, &lt;code&gt;$ARGV[0]&lt;/code&gt; is set to &lt;code&gt;&quot;-&quot;&lt;/code&gt;, which when opened gives you standard input. The &lt;code&gt;@ARGV&lt;/code&gt; array is then processed as a list of filenames. The loop</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d22af8d2b7cf7cf2c570f3f335ab2a750c99b68" translate="yes" xml:space="preserve">
          <source>The null list is represented by (). Interpolating it in a list has no effect. Thus ((),(),()) is equivalent to (). Similarly, interpolating an array with no elements is the same as if no array had been interpolated at that point.</source>
          <target state="translated">널리스트는 ()로 표시됩니다. 목록에서 보간해도 효과가 없습니다. 따라서 ((), (), ())는 ()와 같습니다. 마찬가지로 요소가없는 배열을 보간하는 것은 해당 시점에 배열이 보간되지 않은 것과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1797c45a73a5a87e1dcbfe3ceafa93cc5c4f9d01" translate="yes" xml:space="preserve">
          <source>The null loop times can be cached, the key being the number of rounds. The caching can be controlled using calls like these:</source>
          <target state="translated">널 (null) 루프 시간은 캐시 될 수 있으며 키는 라운드 수입니다. 다음과 같은 호출을 사용하여 캐싱을 제어 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c43d1fda274f03a112b4082e8056292b9c40d862" translate="yes" xml:space="preserve">
          <source>The number 0, the strings &lt;code&gt;'0'&lt;/code&gt; and &lt;code&gt;&quot;&quot;&lt;/code&gt; , the empty list &lt;code&gt;()&lt;/code&gt; , and &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; are all false in a boolean context. All other values are true. Negation of a true value by &lt;code&gt;!&lt;/code&gt; or &lt;code&gt;not&lt;/code&gt; returns a special false value. When evaluated as a string it is treated as &lt;code&gt;&quot;&quot;&lt;/code&gt; , but as a number, it is treated as 0. Most Perl operators that return true or false behave this way.</source>
          <target state="translated">부울 컨텍스트에서 숫자 0, 문자열 &lt;code&gt;'0'&lt;/code&gt; 및 &lt;code&gt;&quot;&quot;&lt;/code&gt; , 빈 목록 &lt;code&gt;()&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 는 모두 false입니다. 다른 모든 값은 true입니다. 에 의한 진정한 가치의 부정 &lt;code&gt;!&lt;/code&gt; 또는 &lt;code&gt;not&lt;/code&gt; 은 특별한 거짓 값을 반환합니다. 문자열로 평가 될 때 &lt;code&gt;&quot;&quot;&lt;/code&gt; 로 처리 되지만 숫자로 처리됩니다. 0으로 처리됩니다. true 또는 false를 리턴하는 대부분의 Perl 연산자는이 방식으로 작동합니다.</target>
        </trans-unit>
        <trans-unit id="692f2a5740e6be2f2f4c50b1195b7318b218c93b" translate="yes" xml:space="preserve">
          <source>The number after Perl (i.e. the 5 after Perl 5) is the major release of the perl interpreter as well as the version of the language. Each major version has significant differences that earlier versions cannot support.</source>
          <target state="translated">Perl 이후의 숫자 (즉, Perl 5 이후의 5)는 언어 버전뿐만 아니라 perl 인터프리터의 주요 릴리스입니다. 각 주요 버전에는 이전 버전에서 지원할 수없는 중요한 차이점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="3191b134cb3717b47b8c71b05a1d940752bad987" translate="yes" xml:space="preserve">
          <source>The number for the &quot;generation&quot; of the test run. The first generation is 1 (one) and subsequent generations are 2, 3, etc.</source>
          <target state="translated">테스트 실행의 &quot;세대&quot;수입니다. 1 세대는 1 (일)이고 다음 세대는 2, 3 등입니다.</target>
        </trans-unit>
        <trans-unit id="2535d279c5200f7be07d31d15ce44068cdb20ffd" translate="yes" xml:space="preserve">
          <source>The number of &quot;hidden&quot; sectors for this partition. Actually this is the number of sectors found prior to this partition, that is, the starting offset [as found in &lt;code&gt;$uStartLow&lt;/code&gt; and &lt;code&gt;$ivStartHigh&lt;/code&gt;] divided by the number of bytes per sector.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0a9d7413ce0d5ac2d4144491992bf44868224aa" translate="yes" xml:space="preserve">
          <source>The number of bytes in each sector.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa99ba7fda4b251af40087fa9ad0d33252bbd195" translate="yes" xml:space="preserve">
          <source>The number of concurrent jobs this formatter will handle.</source>
          <target state="translated">이 포맷터가 처리 할 동시 작업 수</target>
        </trans-unit>
        <trans-unit id="36ffefa76cdb58a51fa74dc31caa513844b361e2" translate="yes" xml:space="preserve">
          <source>The number of elements in the array will be &lt;code&gt;fill + 1&lt;/code&gt; after &lt;code&gt;av_fill()&lt;/code&gt; returns. If the array was previously shorter, then the additional elements appended are set to NULL. If the array was longer, then the excess elements are freed. &lt;code&gt;av_fill(av, -1)&lt;/code&gt; is the same as &lt;code&gt;av_clear(av)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d2ba45a48d3868e33de1ec7e956df019e81e42a" translate="yes" xml:space="preserve">
          <source>The number of elements in the array will be &lt;code&gt;fill + 1&lt;/code&gt; after av_fill() returns. If the array was previously shorter, then the additional elements appended are set to NULL. If the array was longer, then the excess elements are freed. &lt;code&gt;av_fill(av, -1)&lt;/code&gt; is the same as &lt;code&gt;av_clear(av)&lt;/code&gt; .</source>
          <target state="translated">av_fill ()이 반환 된 후 배열의 요소 수는 &lt;code&gt;fill + 1&lt;/code&gt; 입니다. 배열이 이전에 더 짧은 경우 추가 된 추가 요소가 NULL로 설정됩니다. 배열이 더 길면 초과 요소가 해제됩니다. &lt;code&gt;av_fill(av, -1)&lt;/code&gt; 은 &lt;code&gt;av_clear(av)&lt;/code&gt; 와 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="b9161f7d8230483ece3123e0d04957cb7a945f72" translate="yes" xml:space="preserve">
          <source>The number of items in a hash can be obtained by doing:</source>
          <target state="translated">해시의 항목 수는 다음을 수행하여 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e4c9a33204f057eb951c01e0df7449caf0e7389f" translate="yes" xml:space="preserve">
          <source>The number of lines left on the page of the currently selected output channel.</source>
          <target state="translated">현재 선택된 출력 채널의 페이지에 남은 줄 수입니다.</target>
        </trans-unit>
        <trans-unit id="8b661ef45c3e83256fc7a63d23f91b2343af29ac" translate="yes" xml:space="preserve">
          <source>The number of lines read previous to this one, plus 1. Perl keeps a separate line number for each source or input file it opens. The current source file&amp;rsquo;s line number is represented by &lt;code&gt;__LINE__&lt;/code&gt; . The current input line number (for the file that was most recently read via &lt;code&gt;&amp;lt;FH&amp;gt;&lt;/code&gt; ) is represented by the &lt;code&gt;$.&lt;/code&gt; (&lt;code&gt;$INPUT_LINE_NUMBER&lt;/code&gt; ) variable. Many error messages report both values, if available.</source>
          <target state="translated">이 줄 이전에 읽은 줄 수에 1을 더한 값. 1 Perl은 열린 각 소스 또는 입력 파일에 대해 별도의 줄 번호를 유지합니다. 현재 소스 파일의 행 번호는 &lt;code&gt;__LINE__&lt;/code&gt; 로 표시됩니다 . 현재 입력 라인 번호 ( &lt;code&gt;&amp;lt;FH&amp;gt;&lt;/code&gt; 를 통해 가장 최근에 읽은 파일의 경우 )는 &lt;code&gt;$.&lt;/code&gt; 로 표시됩니다 . ( &lt;code&gt;$INPUT_LINE_NUMBER&lt;/code&gt; ) 변수 사용 가능한 경우 많은 오류 메시지가 두 값을 모두보고합니다.</target>
        </trans-unit>
        <trans-unit id="2c32dc65a0983301d8b932b2ff7d13fbe8041de2" translate="yes" xml:space="preserve">
          <source>The number of lines read previous to this one, plus 1. Perl keeps a separate line number for each source or input file it opens. The current source file&amp;rsquo;s line number is represented by &lt;code&gt;__LINE__&lt;/code&gt;. The current input line number (for the file that was most recently read via &lt;code&gt;&amp;lt;FH&amp;gt;&lt;/code&gt;) is represented by the &lt;code&gt;$.&lt;/code&gt; (&lt;code&gt;$INPUT_LINE_NUMBER&lt;/code&gt;) variable. Many error messages report both values, if available.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c26ea7021e22061094b1160120712623c26587e" translate="yes" xml:space="preserve">
          <source>The number of retrieval pointers that RMS has to maintain (0 to 127255)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7adfc7b3eafb7c58d678ada0cc8dfa22b0798638" translate="yes" xml:space="preserve">
          <source>The number of seconds the program ran for before being terminated, or 0 if no timeout occurred.</source>
          <target state="translated">프로그램이 종료되기 전에 실행 된 시간 (초) 또는 시간 종료가 발생하지 않은 경우 0</target>
        </trans-unit>
        <trans-unit id="3f0ee453c0514a141454bf624811de74f7121fbc" translate="yes" xml:space="preserve">
          <source>The number of sectors in each track.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="701c3dee8ddb529dd17cdf0b20bfe4db85c06698" translate="yes" xml:space="preserve">
          <source>The number of spaces to indent regular text, and the default indentation for &lt;code&gt;=over&lt;/code&gt; blocks. Defaults to 4.</source>
          <target state="translated">일반 텍스트를 들여 쓰기 할 공백 수와 &lt;code&gt;=over&lt;/code&gt; 블록에 대한 기본 들여 쓰기 기본값은 4입니다.</target>
        </trans-unit>
        <trans-unit id="e68baf88a8ecb32bf1315047769f8d0e186bb5f6" translate="yes" xml:space="preserve">
          <source>The number of tests actually seen</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65eb3487d858db8bd02f6c81679897d6d005441b" translate="yes" xml:space="preserve">
          <source>The number of tests in your script. This means all ok() and skip() calls.</source>
          <target state="translated">스크립트의 테스트 수 이것은 모든 ok () 및 skip () 호출을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="7a3c79429902da3d2d3d81b8c529fe97388165ba" translate="yes" xml:space="preserve">
          <source>The number of tests that were planned</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34e2b7e50e91d743cd4a7b27aa45939dc1c6581f" translate="yes" xml:space="preserve">
          <source>The number of tests which failed</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2e318858e274a3b2d56e4e8546a3453a590b339" translate="yes" xml:space="preserve">
          <source>The number of tests with TODO directives.</source>
          <target state="translated">TODO 지시문이있는 테스트 수입니다.</target>
        </trans-unit>
        <trans-unit id="134bbf3c12ccdb3b17c2429c883dacdca5457a57" translate="yes" xml:space="preserve">
          <source>The number of times the structure is referenced. When this falls to 0, the regexp is automatically freed by a call to pregfree. This should be set to 1 in each engine's &lt;a href=&quot;#comp&quot;&gt;&quot;comp&quot;&lt;/a&gt; routine.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c43b06bec0238ed7c22fd0d6e38144c2bb8f0d70" translate="yes" xml:space="preserve">
          <source>The number of times the structure is referenced. When this falls to 0, the regexp is automatically freed by a call to pregfree. This should be set to 1 in each engine's &lt;a href=&quot;#comp&quot;&gt;comp&lt;/a&gt; routine.</source>
          <target state="translated">구조가 참조 된 횟수입니다. 이것이 0으로 떨어지면 정규 표현식은 pregfree 호출에 의해 자동으로 해제됩니다. 각 엔진의 &lt;a href=&quot;#comp&quot;&gt;comp&lt;/a&gt; 루틴 에서 1로 설정해야합니다 .</target>
        </trans-unit>
        <trans-unit id="c7aa069edb979af7f298ec7da8f6245a682e62f6" translate="yes" xml:space="preserve">
          <source>The number of times the test has failed.</source>
          <target state="translated">테스트가 실패한 횟수입니다.</target>
        </trans-unit>
        <trans-unit id="f294a946b3a2f3d15985548e48a89b85b334300e" translate="yes" xml:space="preserve">
          <source>The number of times the test has passed.</source>
          <target state="translated">테스트가 통과 한 횟수입니다.</target>
        </trans-unit>
        <trans-unit id="1ea0b9d7d53aa08d0e622974bcb543d8e9e34567" translate="yes" xml:space="preserve">
          <source>The number of tracks in each cylinder.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ecf3312d862847aadfe59c31f3bcfa85cc3016b" translate="yes" xml:space="preserve">
          <source>The numbering within each branch will be as normal, and any groups following this construct will be numbered as though the construct contained only one branch, that being the one with the most capture groups in it.</source>
          <target state="translated">각 브랜치 내의 번호는 평상시와 같으며,이 구문 다음에 오는 그룹은 하나의 브랜치 만 포함 된 것처럼 번호가 매겨지며, 가장 많은 캡처 그룹이있는 것입니다.</target>
        </trans-unit>
        <trans-unit id="d3f5b7856c836d8ae15bae5d2911f695737356ba" translate="yes" xml:space="preserve">
          <source>The numbers are stored as objects, and their internals might change at anytime, especially between math operations. The objects also might belong to different classes, like Math::BigInt, or Math::BigFloat. Mixing them together, even with normal scalars is not extraordinary, but normal and expected.</source>
          <target state="translated">숫자는 객체로 저장되며, 특히 수학 연산 사이에 내부가 언제든지 변경 될 수 있습니다. 개체는 Math :: BigInt 또는 Math :: BigFloat와 같은 다른 클래스에 속할 수도 있습니다. 일반 스칼라로도 함께 혼합하는 것은 특별하지는 않지만 정상이며 예상됩니다.</target>
        </trans-unit>
        <trans-unit id="0d52076285e4f235f1d8532711b46d3578467720" translate="yes" xml:space="preserve">
          <source>The numbers are stored as objects, and their internals might change at anytime, especially between math operations. The objects also might belong to different classes, like Math::BigInt, or Math::BigInt::Lite. Mixing them together, even with normal scalars is not extraordinary, but normal and expected.</source>
          <target state="translated">숫자는 객체로 저장되며, 특히 수학 연산 사이에 내부가 언제든지 변경 될 수 있습니다. 개체는 Math :: BigInt 또는 Math :: BigInt :: Lite와 같은 다른 클래스에 속할 수도 있습니다. 일반 스칼라로도 함께 혼합하는 것은 특별하지는 않지만 정상이며 예상됩니다.</target>
        </trans-unit>
        <trans-unit id="d62316f7524c3cde4e634f1fd21e7ac49fd46233" translate="yes" xml:space="preserve">
          <source>The numeric permissions mode to apply to each created directory (defaults to 0777), to be modified by the current &lt;code&gt;&lt;a href=&quot;../functions/umask&quot;&gt;umask&lt;/a&gt;&lt;/code&gt;. If the directory already exists (and thus does not need to be created), the permissions will not be modified.</source>
          <target state="translated">현재 &lt;code&gt;&lt;a href=&quot;../functions/umask&quot;&gt;umask&lt;/a&gt;&lt;/code&gt; 에 의해 수정 될 각 작성된 디렉토리 (기본값은 0777)에 적용 할 숫자 권한 모드 입니다. 디렉토리가 이미 존재하여 작성 될 필요가없는 경우 권한이 수정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5dffd7d41fb958bc0c87e558861a514e1606e35f" translate="yes" xml:space="preserve">
          <source>The numeric permissions mode to apply to each created directory (defaults to &lt;code&gt;0777&lt;/code&gt;), to be modified by the current &lt;code&gt;umask&lt;/code&gt;. If the directory already exists (and thus does not need to be created), the permissions will not be modified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41e019f9571f72909dc6712d8ba72dd87f1a9db6" translate="yes" xml:space="preserve">
          <source>The numeric value of the COP's hint flags, or an empty string if this is not a COP.</source>
          <target state="translated">COP 힌트 플래그의 숫자 값이거나 COP가 아닌 경우 빈 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="419fea734cd75b36bfd625f906eafadf3594cbdf" translate="yes" xml:space="preserve">
          <source>The numeric value of the OP's flags.</source>
          <target state="translated">OP 플래그의 숫자 값입니다.</target>
        </trans-unit>
        <trans-unit id="e13f8ed0a121e4b7f2050aa9d7bd9bd36bdb9772" translate="yes" xml:space="preserve">
          <source>The numeric value of the OP's private flags.</source>
          <target state="translated">OP 개인 플래그의 숫자 값입니다.</target>
        </trans-unit>
        <trans-unit id="afdb5b0bce9be5274063464faba90d66849c8cbe" translate="yes" xml:space="preserve">
          <source>The numeric value of the OP's targ.</source>
          <target state="translated">OP 대상의 숫자 값입니다.</target>
        </trans-unit>
        <trans-unit id="e4bd78ffa7c276231e5c09572ec79b0007d54b06" translate="yes" xml:space="preserve">
          <source>The numeric value of the OP's type, in decimal.</source>
          <target state="translated">OP 유형의 숫자 ​​값 (10 진수)입니다.</target>
        </trans-unit>
        <trans-unit id="38a4063b54e70e2579ef41b45391d9edbcb80e9f" translate="yes" xml:space="preserve">
          <source>The object actually used is of the class &lt;a href=&quot;ExtUtils::MY&quot;&gt;MY&lt;/a&gt; which allows you to override bits of MakeMaker inside your Makefile.PL by declaring MY::foo() methods.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a6a6fda3b81e72660dadfe40e0c6cbbf8b62d9b" translate="yes" xml:space="preserve">
          <source>The object is re-blessed into a sub-class of &lt;code&gt;IO::Handle&lt;/code&gt; , and becomes a handle at the reading end of the pipe. If &lt;code&gt;ARGS&lt;/code&gt; are given then &lt;code&gt;&lt;a href=&quot;../functions/fork&quot;&gt;fork&lt;/a&gt;&lt;/code&gt; is called and &lt;code&gt;ARGS&lt;/code&gt; are passed to exec.</source>
          <target state="translated">객체는 &lt;code&gt;IO::Handle&lt;/code&gt; 의 하위 클래스로 다시 축복되며 파이프의 읽기 끝에서 핸들이됩니다. 경우 &lt;code&gt;ARGS&lt;/code&gt; 가 다음 주어진 &lt;code&gt;&lt;a href=&quot;../functions/fork&quot;&gt;fork&lt;/a&gt;&lt;/code&gt; 라고하며 &lt;code&gt;ARGS&lt;/code&gt; 은 간부로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="7b25df29627971e66202a04141c07ea01261d426" translate="yes" xml:space="preserve">
          <source>The object is re-blessed into a sub-class of &lt;code&gt;IO::Handle&lt;/code&gt; , and becomes a handle at the writing end of the pipe. If &lt;code&gt;ARGS&lt;/code&gt; are given then &lt;code&gt;&lt;a href=&quot;../functions/fork&quot;&gt;fork&lt;/a&gt;&lt;/code&gt; is called and &lt;code&gt;ARGS&lt;/code&gt; are passed to exec.</source>
          <target state="translated">객체는 &lt;code&gt;IO::Handle&lt;/code&gt; 의 하위 클래스로 다시 축복되며 파이프의 쓰기 끝에서 핸들이됩니다. 경우 &lt;code&gt;ARGS&lt;/code&gt; 가 다음 주어진 &lt;code&gt;&lt;a href=&quot;../functions/fork&quot;&gt;fork&lt;/a&gt;&lt;/code&gt; 라고하며 &lt;code&gt;ARGS&lt;/code&gt; 은 간부로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="fc8e459a67162585ed649c073732c1f153656661" translate="yes" xml:space="preserve">
          <source>The object is re-blessed into a sub-class of &lt;code&gt;IO::Handle&lt;/code&gt;, and becomes a handle at the reading end of the pipe. If &lt;code&gt;ARGS&lt;/code&gt; are given then &lt;code&gt;fork&lt;/code&gt; is called and &lt;code&gt;ARGS&lt;/code&gt; are passed to exec.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="960d4697beb3f7754f165a72fa86b9e206ef71bf" translate="yes" xml:space="preserve">
          <source>The object is re-blessed into a sub-class of &lt;code&gt;IO::Handle&lt;/code&gt;, and becomes a handle at the writing end of the pipe. If &lt;code&gt;ARGS&lt;/code&gt; are given then &lt;code&gt;fork&lt;/code&gt; is called and &lt;code&gt;ARGS&lt;/code&gt; are passed to exec.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40e63c161da60788dfbf25012eced379198e6461" translate="yes" xml:space="preserve">
          <source>The object or class on which a method is called is passed as one of the method's arguments, not as a separate &lt;code&gt;this&lt;/code&gt; value.</source>
          <target state="translated">메소드가 호출되는 객체 또는 클래스는 별도 &lt;code&gt;this&lt;/code&gt; 값 이 아니라 메소드의 인수 중 하나로 전달됩니다 .</target>
        </trans-unit>
        <trans-unit id="ac2428a9234f597f267cadbd7f0f16da4708e348" translate="yes" xml:space="preserve">
          <source>The object oriented interface lets you configure your own encoding or decoding style, within the limits of supported formats.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15b98c3fd23a1ef70ae8197a79094d62be1e4c5c" translate="yes" xml:space="preserve">
          <source>The object oriented interface to &lt;code&gt;Digest::MD5&lt;/code&gt; is described in this section. After a &lt;code&gt;Digest::MD5&lt;/code&gt; object has been created, you will add data to it and finally ask for the digest in a suitable format. A single object can be used to calculate multiple digests.</source>
          <target state="translated">이 섹션에서는 &lt;code&gt;Digest::MD5&lt;/code&gt; 대한 객체 지향 인터페이스에 대해 설명합니다. 후 &lt;code&gt;Digest::MD5&lt;/code&gt; 객체가 생성되어, 당신은 데이터를 추가하고 마지막으로 적절한 형식으로 다이제스트를 요청합니다. 단일 개체를 사용하여 여러 다이제스트를 계산할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e33be9a872157d87d04d9ab372ad71b851a50cce" translate="yes" xml:space="preserve">
          <source>The object registry is also used to repair a field hash after thread cloning. Here, the entire object registry is processed. For every reference found there, the field hashes it has used are visited and the entry is updated.</source>
          <target state="translated">객체 레지스트리는 스레드 복제 후 필드 해시를 복구하는 데에도 사용됩니다. 여기서 전체 오브젝트 레지스트리가 처리됩니다. 거기에서 찾은 모든 참조에 대해, 사용 된 필드 해시가 방문되고 항목이 업데이트됩니다.</target>
        </trans-unit>
        <trans-unit id="90c880f65630ae33e5e929b9f5badc61ea20d016" translate="yes" xml:space="preserve">
          <source>The object registry keeps track of references that have been used as field hash keys. The keys are generated from the reference address like in a field hash (though the registry isn't a field hash). Each value is a weak copy of the original reference, stored in an &lt;code&gt;SV&lt;/code&gt; that is itself magical (&lt;code&gt;PERL_MAGIC_uvar&lt;/code&gt; again). The magical structure holds a list (another hash, really) of field hashes that the reference has been used with. When the weakref becomes stale, the magic is activated and uses the list to delete the reference from all field hashes it has been used with. After that, the entry is removed from the object registry itself. Implicitly, that frees the magic structure and the storage it has been using.</source>
          <target state="translated">객체 레지스트리는 필드 해시 키로 사용 된 참조를 추적합니다. 키는 필드 해시와 같이 참조 주소에서 생성됩니다 (레지스트리가 필드 해시가 아님). 각 값은 원래 참조의 약한 사본 이며 자체적으로 마법 인 &lt;code&gt;SV&lt;/code&gt; 에 저장됩니다 ( &lt;code&gt;PERL_MAGIC_uvar&lt;/code&gt; ). 마법 구조에는 참조와 함께 사용 된 필드 해시 목록 (실제로 또 다른 해시)이 있습니다. weakref가 오래되면 마법이 활성화되고이 목록을 사용하여 사용 된 모든 필드 해시에서 참조를 삭제합니다. 그런 다음 항목이 객체 레지스트리 자체에서 제거됩니다. 암시 적으로, 그것은 마술 구조와 그것이 사용하고있는 스토리지를 해제합니다.</target>
        </trans-unit>
        <trans-unit id="d72391ab64988da73b0a894ff996ef426650aa27" translate="yes" xml:space="preserve">
          <source>The object returned by &lt;code&gt;builder()&lt;/code&gt; may change at runtime so you should call &lt;code&gt;builder()&lt;/code&gt; inside each function rather than store it in a global.</source>
          <target state="translated">&lt;code&gt;builder()&lt;/code&gt; 의해 리턴 된 오브젝트는 런타임에 변경 될 수 있으므로 전역에 저장하지 않고 각 함수 내에서 &lt;code&gt;builder()&lt;/code&gt; 호출해야합니다 .</target>
        </trans-unit>
        <trans-unit id="0c2931896c0ae38a7dcf1ceb36dc3228043fb889" translate="yes" xml:space="preserve">
          <source>The object will be serialised as a JSON null value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dce4a435aaab3b8ce3beeeab8876d2f9007b9517" translate="yes" xml:space="preserve">
          <source>The object will be serialised as a JSON number value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="afec221431749f399e52c9677871688987dfbb46" translate="yes" xml:space="preserve">
          <source>The oct() function is commonly used when a string such as &lt;code&gt;644&lt;/code&gt; needs to be converted into a file mode, for example. Although Perl automatically converts strings into numbers as needed, this automatic conversion assumes base 10.</source>
          <target state="translated">oct () 함수는 일반적으로 &lt;code&gt;644&lt;/code&gt; 와 같은 문자열을 파일 모드로 변환해야 할 때 사용됩니다 . Perl은 문자열을 필요에 따라 자동으로 숫자로 변환하지만이 자동 변환은 밑이 10 인 것으로 가정합니다.</target>
        </trans-unit>
        <trans-unit id="09c9c348da6207c41e75d17f6b539e26d9c4cd1f" translate="yes" xml:space="preserve">
          <source>The official (threaded) builds from HP, as they are shipped on the Application DVD/CD's are available on &lt;a href=&quot;http://www.software.hp.com/portal/swdepot/displayProductInfo.do?productNumber=PERL&quot;&gt;http://www.software.hp.com/portal/swdepot/displayProductInfo.do?productNumber=PERL&lt;/a&gt; for both PA-RISC and IPF (Itanium Processor Family). They are built with the HP ANSI-C compiler. Up till 5.8.8 that was done by ActiveState.</source>
          <target state="translated">Application DVD / CD에 제공되는 HP의 공식 (스레드) 빌드는 &lt;a href=&quot;http://www.software.hp.com/portal/swdepot/displayProductInfo.do?productNumber=PERL&quot;&gt;http://www.software.hp.com/portal/swdepot/displayProductInfo.do?productNumber=PERL(PA-RISC&lt;/a&gt; 용) 에 있습니다 . 및 IPF (이타 늄 프로세서 제품군). HP ANSI-C 컴파일러로 빌드됩니다. ActiveState가 수행 한 5.8.8까지.</target>
        </trans-unit>
        <trans-unit id="94afd3df7a7936cd7021df875b7cc881f99b3a21" translate="yes" xml:space="preserve">
          <source>The official forum for the development of perl is the perl5-porters mailing list, mentioned above, and its bugtracker at GitHub. Posting to the list and the bugtracker is not a right: all participants in discussion are expected to adhere to a standard of conduct.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="122c2a7e4876853c52ff4c6bbc23491cac5b2166" translate="yes" xml:space="preserve">
          <source>The official forum for the development of perl is the perl5-porters mailing list, mentioned above, and its bugtracker at rt.perl.org. All participants in discussion there are expected to adhere to a standard of conduct.</source>
          <target state="translated">perl 개발을위한 공식 포럼은 위에서 언급 한 perl5-porters 메일 링리스트와 rt.perl.org의 버그 추적기입니다. 토론에 참여한 모든 참가자는 표준 행동 기준을 준수해야합니다.</target>
        </trans-unit>
        <trans-unit id="206093c38ad914ff8435f60fe865bef14dbff945" translate="yes" xml:space="preserve">
          <source>The official home of this project on the web.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="318a2a25e89f6df5d0fee0930895c69196eba39a" translate="yes" xml:space="preserve">
          <source>The official name of VMS as of this writing is OpenVMS.</source>
          <target state="translated">이 글을 쓰는 시점에서 VMS의 공식 명칭은 OpenVMS입니다.</target>
        </trans-unit>
        <trans-unit id="9e04119b1083995ffa8b809847e51388388f1606" translate="yes" xml:space="preserve">
          <source>The official web site for Berkeley DB is</source>
          <target state="translated">버클리 DB의 공식 웹 사이트는</target>
        </trans-unit>
        <trans-unit id="9ae89a7a7356b47202ed85668f00ace437b2ed69" translate="yes" xml:space="preserve">
          <source>The official web site for Berkeley DB is &lt;a href=&quot;http://www.oracle.com/technology/products/berkeley-db/db/index.html&quot;&gt;http://www.oracle.com/technology/products/berkeley-db/db/index.html&lt;/a&gt;. All versions of Berkeley DB are available there.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b569f6bcadd4a6fd7badb484a162b25dd85b5b2" translate="yes" xml:space="preserve">
          <source>The offset from the start of the file in hex.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d8ba5881483f263a1268bc8d8cd7d41b8c76ce28" translate="yes" xml:space="preserve">
          <source>The old behavior is currently retained, warts and all, for backwards compatibility, but users are encouraged to change any code that tests &lt;code&gt;$!&lt;/code&gt; against &lt;code&gt;E*&lt;/code&gt; constants for Winsock errors to instead test &lt;code&gt;$^E&lt;/code&gt; against &lt;code&gt;WSAE*&lt;/code&gt; constants. After a suitable deprecation period, which started with Perl 5.24, the old behavior may be removed, leaving &lt;code&gt;$!&lt;/code&gt; unchanged after Winsock function calls, to avoid any possible confusion over which error variable to check.</source>
          <target state="new"/>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
