<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="perl">
    <body>
      <group id="perl">
        <trans-unit id="b01d04c5af24a4340d0f912c2ccf886a5fc1edcb" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#exit-EXPR&quot;&gt;&lt;code&gt;exit&lt;/code&gt;&lt;/a&gt; function does not always exit immediately. It calls any defined &lt;code&gt;END&lt;/code&gt; routines first, but these &lt;code&gt;END&lt;/code&gt; routines may not themselves abort the exit. Likewise any object destructors that need to be called are called before the real exit. &lt;code&gt;END&lt;/code&gt; routines and destructors can change the exit status by modifying &lt;a href=&quot;perlvar#%24%3F&quot;&gt;&lt;code&gt;$?&lt;/code&gt;&lt;/a&gt;. If this is a problem, you can call &lt;a href=&quot;posix#_exit&quot;&gt;&lt;code&gt;POSIX::_exit($status)&lt;/code&gt;&lt;/a&gt; to avoid &lt;code&gt;END&lt;/code&gt; and destructor processing. See &lt;a href=&quot;perlmod&quot;&gt;perlmod&lt;/a&gt; for details.</source>
          <target state="translated">&lt;a href=&quot;#exit-EXPR&quot;&gt; &lt;code&gt;exit&lt;/code&gt; &lt;/a&gt; 함수는 항상 바로 종료되지 않습니다. 정의 된 모든 &lt;code&gt;END&lt;/code&gt; 루틴을 먼저 호출 하지만 이러한 &lt;code&gt;END&lt;/code&gt; 루틴 자체가 종료를 중단하지 않을 수 있습니다. 마찬가지로 호출해야하는 모든 개체 소멸자는 실제 종료 전에 호출됩니다. &lt;code&gt;END&lt;/code&gt; 루틴과 소멸자는 &lt;a href=&quot;perlvar#%24%3F&quot;&gt; &lt;code&gt;$?&lt;/code&gt; &lt;/a&gt; 를 수정하여 종료 상태를 변경할 수 있습니다 . . 이것이 문제인 경우 &lt;a href=&quot;posix#_exit&quot;&gt; &lt;code&gt;POSIX::_exit($status)&lt;/code&gt; &lt;/a&gt; 를 호출 하여 &lt;code&gt;END&lt;/code&gt; 및 소멸자 처리 를 피할 수 있습니다. 자세한 내용은 &lt;a href=&quot;perlmod&quot;&gt;perlmod&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="ee540728eb307530289af963d36689ec3a1444d7" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#getprotobynumber-NUMBER&quot;&gt;&lt;code&gt;getprotobynumber&lt;/code&gt;&lt;/a&gt; function, even though it only takes one argument, has the precedence of a list operator, so beware:</source>
          <target state="translated">&lt;a href=&quot;#getprotobynumber-NUMBER&quot;&gt; &lt;code&gt;getprotobynumber&lt;/code&gt; 의의&lt;/a&gt; 기능은, 단지 하나 개의 인자를, 비록 목록 연산자의 우선 순위가 있으므로주의 :</target>
        </trans-unit>
        <trans-unit id="9a1f9e63055c82c44f33e919de1bfed56733c2d3" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#last-LABEL&quot;&gt;&lt;code&gt;last&lt;/code&gt;&lt;/a&gt; command is like the &lt;code&gt;break&lt;/code&gt; statement in C (as used in loops); it immediately exits the loop in question. If the LABEL is omitted, the command refers to the innermost enclosing loop. The &lt;code&gt;last EXPR&lt;/code&gt; form, available starting in Perl 5.18.0, allows a label name to be computed at run time, and is otherwise identical to &lt;code&gt;last LABEL&lt;/code&gt;. The &lt;a href=&quot;#continue-BLOCK&quot;&gt;&lt;code&gt;continue&lt;/code&gt;&lt;/a&gt; block, if any, is not executed:</source>
          <target state="translated">&lt;a href=&quot;#last-LABEL&quot;&gt; &lt;code&gt;last&lt;/code&gt; &lt;/a&gt; 명령은 같다 &lt;code&gt;break&lt;/code&gt; C (루프에 사용)의 문; 문제의 루프를 즉시 종료합니다. LABEL이 생략되면 명령은 가장 안쪽에있는 루프를 참조합니다. &lt;code&gt;last EXPR&lt;/code&gt; 형태, 펄 5.18.0에서 사용할 수있는 시작은 레이블 이름이 런타임에 계산 될 수 있으며,에, 그렇지 않으면 동일 &lt;code&gt;last LABEL&lt;/code&gt; . 는 &lt;a href=&quot;#continue-BLOCK&quot;&gt; &lt;code&gt;continue&lt;/code&gt; &lt;/a&gt; 어떤이 실행되지 않을 경우, 블록 :</target>
        </trans-unit>
        <trans-unit id="889dc5e06ef6b79bfd7037342382aa88c842b099" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#next-LABEL&quot;&gt;&lt;code&gt;next&lt;/code&gt;&lt;/a&gt; command is like the &lt;code&gt;continue&lt;/code&gt; statement in C; it starts the next iteration of the loop:</source>
          <target state="translated">&lt;a href=&quot;#next-LABEL&quot;&gt; &lt;code&gt;next&lt;/code&gt; &lt;/a&gt; (가)와 같은 명령은 &lt;code&gt;continue&lt;/code&gt; C에 문을; 루프의 다음 반복을 시작합니다.</target>
        </trans-unit>
        <trans-unit id="f6c37dbdd3d3faf157e953bebef6eeac7f43fa10" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#oct-EXPR&quot;&gt;&lt;code&gt;oct&lt;/code&gt;&lt;/a&gt; function is commonly used when a string such as &lt;code&gt;644&lt;/code&gt; needs to be converted into a file mode, for example. Although Perl automatically converts strings into numbers as needed, this automatic conversion assumes base 10.</source>
          <target state="translated">&lt;a href=&quot;#oct-EXPR&quot;&gt; &lt;code&gt;oct&lt;/code&gt; &lt;/a&gt; 문자열 등 때 함수는 일반적으로 사용된다 &lt;code&gt;644&lt;/code&gt; 의 요구가 예를 들면, 파일 모드로 전환한다. Perl은 필요에 따라 문자열을 숫자로 자동 변환하지만이 자동 변환은 10 진법을 가정합니다.</target>
        </trans-unit>
        <trans-unit id="d2173488a74d711836ae18ee727857a8643388af" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#ping&quot;&gt;&quot;ping&quot;&lt;/a&gt; method used with the external protocol. Uses &lt;a href=&quot;Net::Ping::External&quot;&gt;Net::Ping::External&lt;/a&gt; to do an external ping.</source>
          <target state="translated">&lt;a href=&quot;#ping&quot;&gt;&quot;핑&quot;&lt;/a&gt; 외부 프로토콜을 사용하는 방법. &lt;a href=&quot;Net::Ping::External&quot;&gt;Net :: Ping :: External&lt;/a&gt; 을 사용 하여 외부 핑을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="cc7c9b7850979e6e7def2184badf7bf1bc4a1d3d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#ping&quot;&gt;&quot;ping&quot;&lt;/a&gt; method used with the forking syn protocol.</source>
          <target state="translated">&lt;a href=&quot;#ping&quot;&gt;&quot;핑&quot;&lt;/a&gt; 프로세스 복제가 SYN 프로토콜을 사용하는 방법.</target>
        </trans-unit>
        <trans-unit id="641eb29f28723359d8e506ee9152e1f38204dfa6" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#ping&quot;&gt;&quot;ping&quot;&lt;/a&gt; method used with the icmp protocol.</source>
          <target state="translated">&lt;a href=&quot;#ping&quot;&gt;&quot;핑 (ping)&quot;&lt;/a&gt; ICMP 프로토콜과 함께 사용하는 방법.</target>
        </trans-unit>
        <trans-unit id="1957ff6c7452234943290c79fb5d121b6e83c5a4" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#ping&quot;&gt;&quot;ping&quot;&lt;/a&gt; method used with the icmpv6 protocol.</source>
          <target state="translated">&lt;a href=&quot;#ping&quot;&gt;&quot;핑 (ping)&quot;&lt;/a&gt; 된 ICMPv6 프로토콜을 사용하는 방법.</target>
        </trans-unit>
        <trans-unit id="acd013c64eb2eb70a4842cac8e8d68d7939687f1" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#ping&quot;&gt;&quot;ping&quot;&lt;/a&gt; method used with the stream protocol.</source>
          <target state="translated">&lt;a href=&quot;#ping&quot;&gt;&quot;핑 (ping)&quot;&lt;/a&gt; 스트림 프로토콜을 사용하는 방법.</target>
        </trans-unit>
        <trans-unit id="cbf91af075e5c18933e470cdffacd91d45bab2cc" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#ping&quot;&gt;&quot;ping&quot;&lt;/a&gt; method used with the syn protocol. Sends a TCP SYN packet to host specified.</source>
          <target state="translated">&lt;a href=&quot;#ping&quot;&gt;&quot;핑 (ping)&quot;&lt;/a&gt; 가 SYN 프로토콜을 사용하는 방법. 지정된 호스트에 TCP SYN 패킷을 보냅니다.</target>
        </trans-unit>
        <trans-unit id="e289226b6ef91e47994450b9dc7ca74494856a25" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#ping&quot;&gt;&quot;ping&quot;&lt;/a&gt; method used with the tcp protocol.</source>
          <target state="translated">&lt;a href=&quot;#ping&quot;&gt;&quot;핑&quot;&lt;/a&gt; TCP 프로토콜과 함께 사용하는 방법.</target>
        </trans-unit>
        <trans-unit id="8bacd7d416bf9eb142f724a00d7ab4625004301a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#ping&quot;&gt;&quot;ping&quot;&lt;/a&gt; method used with the udp protocol.</source>
          <target state="translated">&lt;a href=&quot;#ping&quot;&gt;&quot;핑 (ping)&quot;&lt;/a&gt; UDP 프로토콜로 사용되는 방법.</target>
        </trans-unit>
        <trans-unit id="be711bbef7a00d2eb13cc8d85cfba9b425e71aaf" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#prop_value_aliases%28%29&quot;&gt;&quot;prop_value_aliases()&quot;&lt;/a&gt; function can be used to get all the synonyms of the bidi type name.</source>
          <target state="translated">&lt;a href=&quot;#prop_value_aliases%28%29&quot;&gt;&quot;prop_value_aliases ()&quot;&lt;/a&gt; 기능은 쌍방향 형식 이름의 모든 동의어를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4486da16fa0f4a006b57a0a44a17953ec38fd8dc" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#prop_value_aliases%28%29&quot;&gt;&quot;prop_value_aliases()&quot;&lt;/a&gt; function can be used to get all the synonyms of the category name.</source>
          <target state="translated">&lt;a href=&quot;#prop_value_aliases%28%29&quot;&gt;&quot;prop_value_aliases ()&quot;&lt;/a&gt; 기능은 카테고리 이름의 모든 동의어를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1ce0427217e7e69e6e5a80f1afd684e23957d161" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#prop_value_aliases%28%29&quot;&gt;&quot;prop_value_aliases()&quot;&lt;/a&gt; function can be used to get all the synonyms of the combining class number.</source>
          <target state="translated">&lt;a href=&quot;#prop_value_aliases%28%29&quot;&gt;&quot;prop_value_aliases ()&quot;&lt;/a&gt; 기능은 결합 클래스 번호의 모든 동의어를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8854fb6583fec2754cd3983ea80d85f9b0022749" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#prop_value_aliases()&quot;&gt;prop_value_aliases()&lt;/a&gt; function can be used to get all the synonyms of the bidi type name.</source>
          <target state="translated">&lt;a href=&quot;#prop_value_aliases()&quot;&gt;prop_value_aliases ()&lt;/a&gt; 함수는 쌍방향 형식 이름의 모든 동의어를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="76a16bb68fd364d030e4901c8f1d916862b53339" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#prop_value_aliases()&quot;&gt;prop_value_aliases()&lt;/a&gt; function can be used to get all the synonyms of the category name.</source>
          <target state="translated">&lt;a href=&quot;#prop_value_aliases()&quot;&gt;prop_value_aliases ()&lt;/a&gt; 함수는 카테고리 이름의 모든 동의어를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2277466bc19ae0c38a8069cd1ac99be48d5794e6" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#prop_value_aliases()&quot;&gt;prop_value_aliases()&lt;/a&gt; function can be used to get all the synonyms of the combining class number.</source>
          <target state="translated">&lt;a href=&quot;#prop_value_aliases()&quot;&gt;prop_value_aliases ()&lt;/a&gt; 함수는 결합 클래스 번호의 모든 동의어를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4904f3373dd8be370b7583b9b3b50ffe1a1a4b51" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#prop_values%28%29&quot;&gt;&quot;prop_values()&quot;&lt;/a&gt; and &lt;a href=&quot;#prop_value_aliases%28%29&quot;&gt;&quot;prop_value_aliases()&quot;&lt;/a&gt; functions can be used as an alternative to this function; the first returning a simple list of the short bidi type names; and the second gets all the synonyms of a given bidi type name.</source>
          <target state="translated">&lt;a href=&quot;#prop_values%28%29&quot;&gt;&quot;prop_values ()&quot;&lt;/a&gt; 및 &lt;a href=&quot;#prop_value_aliases%28%29&quot;&gt;&quot;prop_value_aliases ()&quot;&lt;/a&gt; 기능이 기능의 대안으로 사용될 수있다; 첫 번째는 짧은 bidi 유형 이름의 간단한 목록을 리턴합니다. 두 번째는 주어진 bidi 유형 이름의 모든 동의어를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="b1feb25bb50a467b88daf8d606e828a649203e2c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#prop_values%28%29&quot;&gt;&quot;prop_values()&quot;&lt;/a&gt; and &lt;a href=&quot;#prop_value_aliases%28%29&quot;&gt;&quot;prop_value_aliases()&quot;&lt;/a&gt; functions can be used as an alternative to this function; the first returning a simple list of the short category names; and the second gets all the synonyms of a given category name.</source>
          <target state="translated">&lt;a href=&quot;#prop_values%28%29&quot;&gt;&quot;prop_values ()&quot;&lt;/a&gt; 및 &lt;a href=&quot;#prop_value_aliases%28%29&quot;&gt;&quot;prop_value_aliases ()&quot;&lt;/a&gt; 기능이 기능의 대안으로 사용될 수있다; 첫 번째는 짧은 카테고리 이름의 간단한 목록을 반환합니다. 두 번째는 주어진 카테고리 이름의 모든 동의어를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="d0d02ad47d23ca3616a65821c3a3e94a1c4a3210" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#prop_values()&quot;&gt;prop_values()&lt;/a&gt; and &lt;a href=&quot;#prop_value_aliases()&quot;&gt;prop_value_aliases()&lt;/a&gt; functions can be used as an alternative to this function; the first returning a simple list of the short bidi type names; and the second gets all the synonyms of a given bidi type name.</source>
          <target state="translated">&lt;a href=&quot;#prop_values()&quot;&gt;prop_values ()&lt;/a&gt; 및 &lt;a href=&quot;#prop_value_aliases()&quot;&gt;prop_value_aliases ()&lt;/a&gt; 기능이 기능의 대안으로 사용될 수있다; 첫 번째는 짧은 bidi 유형 이름의 간단한 목록을 리턴합니다. 두 번째는 주어진 bidi 유형 이름의 모든 동의어를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="ff1836f9843147fc775222ff3469395bcf43b303" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#prop_values()&quot;&gt;prop_values()&lt;/a&gt; and &lt;a href=&quot;#prop_value_aliases()&quot;&gt;prop_value_aliases()&lt;/a&gt; functions can be used as an alternative to this function; the first returning a simple list of the short category names; and the second gets all the synonyms of a given category name.</source>
          <target state="translated">&lt;a href=&quot;#prop_values()&quot;&gt;prop_values ()&lt;/a&gt; 및 &lt;a href=&quot;#prop_value_aliases()&quot;&gt;prop_value_aliases ()&lt;/a&gt; 기능이 기능의 대안으로 사용될 수있다; 첫 번째는 간단한 카테고리 이름의 간단한 목록을 반환합니다. 두 번째는 주어진 카테고리 이름의 모든 동의어를 얻습니다.</target>
        </trans-unit>
        <trans-unit id="234f248bda745adf52767c8afed6c1179ce0b206" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#redo-LABEL&quot;&gt;&lt;code&gt;redo&lt;/code&gt;&lt;/a&gt; command restarts the loop block without evaluating the conditional again. The &lt;a href=&quot;#continue-BLOCK&quot;&gt;&lt;code&gt;continue&lt;/code&gt;&lt;/a&gt; block, if any, is not executed. If the LABEL is omitted, the command refers to the innermost enclosing loop. The &lt;code&gt;redo EXPR&lt;/code&gt; form, available starting in Perl 5.18.0, allows a label name to be computed at run time, and is otherwise identical to &lt;code&gt;redo LABEL&lt;/code&gt;. Programs that want to lie to themselves about what was just input normally use this command:</source>
          <target state="translated">&lt;a href=&quot;#redo-LABEL&quot;&gt; &lt;code&gt;redo&lt;/code&gt; &lt;/a&gt; 명령 다시 조건을 평가하지 않고 루프를 재시작 블록. 는 &lt;a href=&quot;#continue-BLOCK&quot;&gt; &lt;code&gt;continue&lt;/code&gt; &lt;/a&gt; 실행되지 않은 경우, 블록을. LABEL이 생략되면 명령은 가장 안쪽에있는 루프를 참조합니다. Perl 5.18.0부터 사용할 수 있는 &lt;code&gt;redo EXPR&lt;/code&gt; 양식은 레이블 이름을 런타임에 계산할 수 있도록하며, 그렇지 않으면 &lt;code&gt;redo LABEL&lt;/code&gt; 과 동일합니다 . 방금 입력 한 내용에 대해 거짓말을하려는 프로그램은 일반적으로 다음 명령을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="0a519b9af5d08ee020d0e49465d3e607833a7248" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#search_invlist%28%29&quot;&gt;&quot;search_invlist()&quot;&lt;/a&gt; function is provided for finding a code point within an inversion list.</source>
          <target state="translated">&lt;a href=&quot;#search_invlist%28%29&quot;&gt;&quot;search_invlist ()&quot;&lt;/a&gt; 함수는 반전 목록 내에서 코드 포인트를 찾기 위해 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="8295b9c404465c68e21720ae88623e9c9b91d667" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#search_invlist()&quot;&gt;search_invlist()&lt;/a&gt; function is provided for finding a code point within an inversion list.</source>
          <target state="translated">&lt;a href=&quot;#search_invlist()&quot;&gt;search_invlist ()&lt;/a&gt; 함수는 반전리스트 내의 코드 포인트를 찾기 위해 제공된다.</target>
        </trans-unit>
        <trans-unit id="a99fc3c1e89a0b4e840a4661bca0de0880d27694" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../file/stat&quot;&gt;File::stat&lt;/a&gt; module provides a convenient, by-name access mechanism:</source>
          <target state="translated">&lt;a href=&quot;../file/stat&quot;&gt;파일 :: 합계&lt;/a&gt; 모듈은 편리에 의해 이름 액세스 메커니즘을 제공합니다 :</target>
        </trans-unit>
        <trans-unit id="f74e082436b86f6a01a3f1c31662df75f43fb323" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../parser&quot;&gt;TAP::Parser&lt;/a&gt; does not use a formal grammar because TAP is essentially a stream-based protocol. In fact, it's quite legal to have an infinite stream. For the same reason that we don't apply regexes to streams, we're not using a formal grammar here. Instead, we parse the TAP in lines.</source>
          <target state="translated">&lt;a href=&quot;../parser&quot;&gt;TAP :: 파서는&lt;/a&gt; TAP는 본질적으로 스트림 기반 프로토콜이기 때문에 공식적인 문법을 사용하지 않습니다. 사실, 무한한 흐름을 갖는 것은 합법적입니다. 스트림에 정규식을 적용하지 않는 것과 같은 이유로, 여기서는 공식 문법을 사용하지 않습니다. 대신 TAP를 줄 단위로 구문 분석합니다.</target>
        </trans-unit>
        <trans-unit id="9b27238d4d5342b8376d19c0241b7f8feab19452" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../perltie&quot;&gt;perltie&lt;/a&gt; section contains an example of tying handles.</source>
          <target state="translated">&lt;a href=&quot;../perltie&quot;&gt;perltie의&lt;/a&gt; 섹션 매 핸들의 예를 포함한다.</target>
        </trans-unit>
        <trans-unit id="6d31ab6a810582c2c717e2c46d057f9872d7ae58" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../perltie&quot;&gt;perltie&lt;/a&gt; section uses a good example of tying scalars by associating process IDs with priority.</source>
          <target state="translated">&lt;a href=&quot;../perltie&quot;&gt;perltie의&lt;/a&gt; 섹션은 우선적으로 프로세스 ID를 대응하여 스칼라 매의 좋은 예를 사용한다.</target>
        </trans-unit>
        <trans-unit id="ef794a4d4eb5de692a3463fa7a1780b4cded7598" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../time/gmtime&quot;&gt;Time::gmtime&lt;/a&gt; and &lt;a href=&quot;../time/localtime&quot;&gt;Time::localtime&lt;/a&gt; modules provide a convenient, by-name access mechanism to the gmtime() and localtime() functions, respectively.</source>
          <target state="translated">&lt;a href=&quot;../time/gmtime&quot;&gt;시간 : gmtime&lt;/a&gt; 과 &lt;a href=&quot;../time/localtime&quot;&gt;시간 ::의 현지&lt;/a&gt; 모듈은 각각 gmtime ()과의 현지 () 함수에 편리한, 이름 별 액세스 메커니즘을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="7f59d8b64082e6585a0f86dcd5c37ba82d09b8aa" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;Algorithm::Loops&quot;&gt;Algorithm::Loops&lt;/a&gt; module also provides the &lt;code&gt;NextPermute&lt;/code&gt; and &lt;code&gt;NextPermuteNum&lt;/code&gt; functions which efficiently find all unique permutations of an array, even if it contains duplicate values, modifying it in-place: if its elements are in reverse-sorted order then the array is reversed, making it sorted, and it returns false; otherwise the next permutation is returned.</source>
          <target state="translated">&lt;a href=&quot;Algorithm::Loops&quot;&gt;알고리즘 :: 루프&lt;/a&gt; 모듈도 제공 &lt;code&gt;NextPermute&lt;/code&gt; 및 &lt;code&gt;NextPermuteNum&lt;/code&gt; 에서 장소를 변경, 효율적 중복 값이 포함되어 있더라도, 어레이의 모든 고유 순열을 찾을 기능 : 요소는 역방향 정렬 된 순서 인 경우 그 배열이 역전 , 정렬하고 false를 반환합니다. 그렇지 않으면 다음 순열이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="d9f0381e14460ccca0ae56322db0a7c83995df5b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;Array::Iterator::Circular&quot;&gt;Array::Iterator::Circular&lt;/a&gt; creates an iterator object for circular arrays:</source>
          <target state="translated">&lt;a href=&quot;Array::Iterator::Circular&quot;&gt;배열 :: 반복자 :: 원형은&lt;/a&gt; 원형 배열하는 반복자 객체를 생성합니다 :</target>
        </trans-unit>
        <trans-unit id="bdf4aaa34018ae1ca4bf41f4b79cdbb9a0cff285" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;B::Xref&quot;&gt;B::Xref&lt;/a&gt; module can be used to generate cross-reference reports for Perl programs.</source>
          <target state="translated">&lt;a href=&quot;B::Xref&quot;&gt;B : 외부 참조&lt;/a&gt; 모듈은 펄 프로그램에 대한 상호 참조 보고서를 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f196a1609183db140dea47e36f3fc23cd9f51305" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;Data::Diver&quot;&gt;Data::Diver&lt;/a&gt; module on CPAN can do it for you too. Its &lt;code&gt;Dive&lt;/code&gt; subroutine can tell you not only if the keys exist but also get the value:</source>
          <target state="translated">CPAN 의 &lt;a href=&quot;Data::Diver&quot;&gt;Data :: Diver&lt;/a&gt; 모듈도이를 수행 할 수 있습니다. 그것의 &lt;code&gt;Dive&lt;/code&gt; 서브 루틴은 키가 존재하지만 값을 얻을 경우에만 알 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="94925a2d828e44c2072ac8bf9e5922e018a8e287" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;Data::Dumper&quot;&gt;Data::Dumper&lt;/a&gt; module can pretty-print Perl data structures:</source>
          <target state="translated">&lt;a href=&quot;Data::Dumper&quot;&gt;데이터 : 온보드&lt;/a&gt; 모듈은 펄 데이터 구조를 꽤 - 인쇄 할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="f5057256958429150491aec28876109720171696" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;Data::Dumper&quot;&gt;Data::Dumper&lt;/a&gt; module on CPAN (or the 5.005 release of Perl) is great for printing out data structures. The &lt;a href=&quot;storable&quot;&gt;Storable&lt;/a&gt; module on CPAN (or the 5.8 release of Perl), provides a function called &lt;code&gt;dclone&lt;/code&gt; that recursively copies its argument.</source>
          <target state="translated">CPAN (또는 Perl 5.005 릴리스) 의 &lt;a href=&quot;Data::Dumper&quot;&gt;Data :: Dumper&lt;/a&gt; 모듈은 데이터 구조를 인쇄하는 데 적합합니다. &lt;a href=&quot;storable&quot;&gt;저장 가능&lt;/a&gt; CPAN에 접속 (또는 펄 5.8 릴리스)라는 함수 제공 &lt;code&gt;dclone&lt;/code&gt; 그 재귀 복사를 인수.</target>
        </trans-unit>
        <trans-unit id="061063093e9b457e789ea7dfaed817ebef3e8fa9" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;Date::Calc&quot;&gt;Date::Calc&lt;/a&gt; module provides two functions to calculate these, too:</source>
          <target state="translated">&lt;a href=&quot;Date::Calc&quot;&gt;날짜 : 캘크&lt;/a&gt; 모듈도 다음을 계산하는 두 가지 기능을 제공합니다 :</target>
        </trans-unit>
        <trans-unit id="414fad6d87355758dbe61a47fbcaa678d06818a4" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;Devel::NYTProf&quot;&gt;Devel::NYTProf&lt;/a&gt; (New York Times Profiler) does both statement and subroutine profiling. It's available from CPAN and you also invoke it with the &lt;code&gt;-d&lt;/code&gt; switch:</source>
          <target state="translated">&lt;a href=&quot;Devel::NYTProf&quot;&gt;(STABLE) : NYTProf&lt;/a&gt; (뉴욕 타임즈 프로파일 러) 모두 문 및 서브 루틴 프로파일 링을 수행합니다. CPAN에서 사용할 수 있으며 &lt;code&gt;-d&lt;/code&gt; 스위치를 사용하여 호출 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="dad6fcc6ed17db5c607714adee78b91a0147dac4" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;Email::MIME&quot;&gt;Email::MIME&lt;/a&gt; module can decode base 64-encoded email message parts transparently so the developer doesn't need to worry about it.</source>
          <target state="translated">&lt;a href=&quot;Email::MIME&quot;&gt;이메일 : MIME의&lt;/a&gt; 모듈은 투명하므로 개발자가 걱정할 필요가 없다 기본 64로 인코딩 된 이메일 메시지 부분을 디코딩 할 수있다.</target>
        </trans-unit>
        <trans-unit id="63fa62cd04b5ec9ae734d2f288b28465a83825b7" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;ExtUtils::MakeMaker&quot;&gt;ExtUtils::MakeMaker&lt;/a&gt; module, better known simply as &quot;MakeMaker&quot;, turns a Perl script, typically called &lt;code&gt;Makefile.PL&lt;/code&gt;, into a Makefile. The Unix tool &lt;code&gt;make&lt;/code&gt; uses this file to manage dependencies and actions to process and install a Perl distribution.</source>
          <target state="translated">&lt;a href=&quot;ExtUtils::MakeMaker&quot;&gt;위한 ExtUtils :: MakeMaker의&lt;/a&gt; 모듈이 더 간단하게 &quot;MakeMaker&quot;로 알려진, 일반적이라는 펄 스크립트, 회전 &lt;code&gt;Makefile.PL&lt;/code&gt; 메이크으로는. Unix 도구 &lt;code&gt;make&lt;/code&gt; 는이 파일을 사용하여 Perl 배포를 처리하고 설치하기위한 종속성 및 작업을 관리합니다.</target>
        </trans-unit>
        <trans-unit id="2a2f33574a7da40336507f2c618ec329b05bfc03" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;File::Find&quot;&gt;File::Find&lt;/a&gt; module, which comes with Perl, does all of the hard work to traverse a directory structure. It comes with Perl. You simply call the &lt;code&gt;find&lt;/code&gt; subroutine with a callback subroutine and the directories you want to traverse:</source>
          <target state="translated">&lt;a href=&quot;File::Find&quot;&gt;파일 :: 찾기&lt;/a&gt; 펄과 함께 제공 모듈은, 디렉토리 구조를 통과하는 모든 일은. Perl과 함께 제공됩니다. 콜백 서브 루틴과 순회 할 디렉토리를 사용 하여 &lt;code&gt;find&lt;/code&gt; 서브 루틴을 호출하기 만하면 됩니다.</target>
        </trans-unit>
        <trans-unit id="06f493ee4e3ed13a3c3c25372d0b8e47b8faa82e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;File::Find::Closures&quot;&gt;File::Find::Closures&lt;/a&gt;, which you can download from CPAN, provides many ready-to-use subroutines that you can use with &lt;a href=&quot;File::Find&quot;&gt;File::Find&lt;/a&gt;.</source>
          <target state="translated">CPAN에서 다운로드 할 수 있는 &lt;a href=&quot;File::Find::Closures&quot;&gt;File :: Find :: Closures&lt;/a&gt; 는 &lt;a href=&quot;File::Find&quot;&gt;File :: Find&lt;/a&gt; 와 함께 사용할 수있는 즉시 사용할 수있는 많은 서브 루틴을 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="41be3e08eb17eb5dab7c9db97b667db51319891c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;File::Find::Rule&quot;&gt;File::Find::Rule&lt;/a&gt; module, which you can download from CPAN, has a similar interface, but does the traversal for you too:</source>
          <target state="translated">CPAN에서 다운로드 할 수 있는 &lt;a href=&quot;File::Find::Rule&quot;&gt;File :: Find :: Rule&lt;/a&gt; 모듈은 유사한 인터페이스를 가지고 있지만 순회도 수행합니다.</target>
        </trans-unit>
        <trans-unit id="6c7bd1eef5bd53ddee501c6b8d48384c043b208a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;File::Finder&quot;&gt;File::Finder&lt;/a&gt;, which you can download from CPAN, can help you create the callback subroutine using something closer to the syntax of the &lt;code&gt;find&lt;/code&gt; command-line utility:</source>
          <target state="translated">&lt;a href=&quot;File::Finder&quot;&gt;파일 :: 찾기&lt;/a&gt; 당신이 CPAN에서 다운로드 할 수 있습니다, 당신은 가까이의 구문 뭔가를 사용하여 콜백 서브 루틴을 만들 수 있습니다 &lt;code&gt;find&lt;/code&gt; 명령 줄 유틸리티 :</target>
        </trans-unit>
        <trans-unit id="1c8b4aba1c450fd5e83e76f37c3b27a8ef91aa4e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;File::Path&quot;&gt;File::Path&lt;/a&gt; module also has a legacy interface to the older &lt;code&gt;rmtree&lt;/code&gt; subroutine.</source>
          <target state="translated">&lt;a href=&quot;File::Path&quot;&gt;파일 : 경로&lt;/a&gt; 모듈은 또한 이전에 레거시 인터페이스가 &lt;code&gt;rmtree&lt;/code&gt; 의 서브 루틴을.</target>
        </trans-unit>
        <trans-unit id="c6eb5ba6674a28ab9cde2b0f4fa3385630b28d43" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;File::Path&quot;&gt;File::Path&lt;/a&gt; module, which comes with Perl, has a &lt;code&gt;remove_tree&lt;/code&gt; which can take care of all of the hard work for you:</source>
          <target state="translated">&lt;a href=&quot;File::Path&quot;&gt;파일 : 경로&lt;/a&gt; 펄과 함께 제공 모듈은하는이 &lt;code&gt;remove_tree&lt;/code&gt; 당신을위한 노력을 모두 돌볼 수 :</target>
        </trans-unit>
        <trans-unit id="785624fefaf011b1c3c4e26dff67213b765e81c8" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;File::ReadBackwards&quot;&gt;File::ReadBackwards&lt;/a&gt; module also has the advantage of setting the input record separator to a regular expression.</source>
          <target state="translated">&lt;a href=&quot;File::ReadBackwards&quot;&gt;파일 :: ReadBackwards은&lt;/a&gt; 또한 일반 식에 입력 레코드 구분자를 설정하는 장점을 갖는다 모듈.</target>
        </trans-unit>
        <trans-unit id="2e7daf70cf70f962093675df7cd3c0bff0a54c56" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;File::Spec&quot;&gt;&lt;code&gt;File::Spec&lt;/code&gt;&lt;/a&gt; modules provide methods to manipulate path specifications and return the results in native format for each platform. This is often unnecessary as Unix-style paths are understood by Perl on every supported platform, but if you need to produce native paths for a native utility that does not understand Unix syntax, or if you are operating on paths or path components in unknown (and thus possibly native) syntax, &lt;a href=&quot;File::Spec&quot;&gt;&lt;code&gt;File::Spec&lt;/code&gt;&lt;/a&gt; is your friend. Here are two brief examples:</source>
          <target state="translated">&lt;a href=&quot;File::Spec&quot;&gt; &lt;code&gt;File::Spec&lt;/code&gt; &lt;/a&gt; 모듈 경로 사양을 조작하고 각 플랫폼에 네이티브 형식으로 결과를 반환하는 방법을 제공합니다. 지원되는 모든 플랫폼에서 Perl이 Unix 스타일 경로를 이해하기 때문에 이는 종종 불필요하지만 Unix 구문을 이해하지 못하는 기본 유틸리티에 대한 기본 경로를 생성해야하거나 unknown ( 따라서 가능한 네이티브) 구문, &lt;a href=&quot;File::Spec&quot;&gt; &lt;code&gt;File::Spec&lt;/code&gt; &lt;/a&gt; 은 당신의 친구입니다. 다음은 두 가지 간단한 예입니다.</target>
        </trans-unit>
        <trans-unit id="2b19e201b91274dc82f186817a1d33cf7babd619" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;File::stat&quot;&gt;File::stat&lt;/a&gt; module provides a convenient, by-name access mechanism:</source>
          <target state="translated">&lt;a href=&quot;File::stat&quot;&gt;파일 :: 합계&lt;/a&gt; 모듈은 편리에 의해 이름 액세스 메커니즘을 제공합니다 :</target>
        </trans-unit>
        <trans-unit id="16818dfffaaf61b6c966f79b42c1f8e2b7feb79d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;IO::Handle&quot;&gt;IO::Handle&lt;/a&gt; objects also have a &lt;code&gt;flush&lt;/code&gt; method. You can flush the buffer any time you want without auto-buffering</source>
          <target state="translated">&lt;a href=&quot;IO::Handle&quot;&gt;IO :: 핸들은&lt;/a&gt; 또한이 객체 &lt;code&gt;flush&lt;/code&gt; 방법. 자동 버퍼링없이 원하는 시간에 버퍼를 플러시 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bba763c04be417f13a8a4419a2a27f106dcca680" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;IO::Interactive&quot;&gt;IO::Interactive&lt;/a&gt; module does the best it can to give you an answer. Its &lt;code&gt;is_interactive&lt;/code&gt; function returns an output filehandle; that filehandle points to standard output if the module thinks the session is interactive. Otherwise, the filehandle is a null handle that simply discards the output:</source>
          <target state="translated">&lt;a href=&quot;IO::Interactive&quot;&gt;IO :: 대화 형&lt;/a&gt; 모듈은 당신에게 대답을 할 수있는 최선을 수행합니다. 그 &lt;code&gt;is_interactive&lt;/code&gt; 기능은 출력 파일 핸들을 반환 모듈이 세션이 대화 형이라고 생각하는 경우 해당 파일 핸들은 표준 출력을 가리 킵니다. 그렇지 않으면 파일 핸들은 단순히 출력을 버리는 널 핸들입니다.</target>
        </trans-unit>
        <trans-unit id="5994860ba25215b560ca2d61fa7577cd91572e65" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;IO::Pty&quot;&gt;IO::Pty&lt;/a&gt; and &lt;a href=&quot;expect&quot;&gt;Expect&lt;/a&gt; modules from CPAN can help with this, as they provide a real tty (well, a pseudo-tty, actually), which gets you back to line buffering in the invoked command again.</source>
          <target state="translated">CPAN 의 &lt;a href=&quot;IO::Pty&quot;&gt;IO :: Pty&lt;/a&gt; 및 &lt;a href=&quot;expect&quot;&gt;Expect&lt;/a&gt; 모듈은 호출 된 명령에서 다시 라인 버퍼링으로 돌아가는 실제 tty (실제로는 의사 tty)를 제공하므로이를 지원할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="57ff19b2be9bd948571db368af45b45f30d772d1" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;IPC::Open2&quot;&gt;IPC::Open2&lt;/a&gt; module (part of the standard perl distribution) is an easy-to-use approach that internally uses &lt;code&gt;pipe()&lt;/code&gt;, &lt;code&gt;fork()&lt;/code&gt;, and &lt;code&gt;exec()&lt;/code&gt; to do the job. Make sure you read the deadlock warnings in its documentation, though (see &lt;a href=&quot;IPC::Open2&quot;&gt;IPC::Open2&lt;/a&gt;). See &lt;a href=&quot;perlipc#Bidirectional-Communication-with-Another-Process&quot;&gt;&quot;Bidirectional Communication with Another Process&quot; in perlipc&lt;/a&gt; and &lt;a href=&quot;perlipc#Bidirectional-Communication-with-Yourself&quot;&gt;&quot;Bidirectional Communication with Yourself&quot; in perlipc&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;IPC::Open2&quot;&gt;IPC :: Open2의&lt;/a&gt; 모듈 (표준 펄 배포판의 일부는) 내부적으로 사용하는 사용하기 쉬운 방법입니다 &lt;code&gt;pipe()&lt;/code&gt; , &lt;code&gt;fork()&lt;/code&gt; , 및 &lt;code&gt;exec()&lt;/code&gt; 일을 할 수 있습니다. 하지만 문서에서 교착 상태 경고를 읽어야합니다 ( &lt;a href=&quot;IPC::Open2&quot;&gt;IPC :: Open2&lt;/a&gt; 참조 ). 참조 &lt;a href=&quot;perlipc#Bidirectional-Communication-with-Another-Process&quot;&gt;perlipc에서 &quot;다른 프로세스와 양방향 통신&quot;&lt;/a&gt; 과 &lt;a href=&quot;perlipc#Bidirectional-Communication-with-Yourself&quot;&gt;perlipc에서 &quot;자신과 양방향 통신&quot;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="0bfdae92972068b982647ca50573a173382b253e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;MIME::Base64&quot;&gt;MIME::Base64&lt;/a&gt; package handles this as well as the MIME/QP encoding. Decoding base 64 becomes as simple as:</source>
          <target state="translated">&lt;a href=&quot;MIME::Base64&quot;&gt;MIME :: Base64로&lt;/a&gt; 패키지 핸들이뿐만 아니라 MIME / QP 인코딩. 기본 64 디코딩은 다음과 같이 간단 해집니다.</target>
        </trans-unit>
        <trans-unit id="c81136d6431fd17ef0e4aa23b6bb0cdcdd4be5ab" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;Net::Domain&quot;&gt;Net::Domain&lt;/a&gt; module, which is part of the Standard Library starting in Perl 5.7.3, can get you the fully qualified domain name (FQDN), the host name, or the domain name.</source>
          <target state="translated">&lt;a href=&quot;Net::Domain&quot;&gt;순 :: 도메인&lt;/a&gt; 펄 5.7.3부터 표준 라이브러리의 일부 모듈은 당신에게 정규화 된 도메인 이름 (FQDN), 호스트 이름 또는 도메인 이름을 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2e94a57c84c2082998da5d9e3718fef9c662bb23" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;Pod::Simple::Methody&quot;&gt;Pod::Simple::Methody&lt;/a&gt; interface is event-based, similar to that of &lt;a href=&quot;HTML::Parser&quot;&gt;HTML::Parser&lt;/a&gt; or &lt;a href=&quot;XML::Parser&quot;&gt;XML::Parser&lt;/a&gt;'s &quot;Handlers&quot;.</source>
          <target state="translated">&lt;a href=&quot;Pod::Simple::Methody&quot;&gt;포드 :: 간단한 :: Methody&lt;/a&gt; 인터페이스는 이벤트 기반의 것과 유사 &lt;a href=&quot;HTML::Parser&quot;&gt;HTML :: 파서&lt;/a&gt; 또는 &lt;a href=&quot;XML::Parser&quot;&gt;XML :: 파서&lt;/a&gt; 의 &quot;핸들러&quot;.</target>
        </trans-unit>
        <trans-unit id="3225637b7a30ef3b9b4ead58416b060ae1216f73" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;Proc::Daemon&quot;&gt;Proc::Daemon&lt;/a&gt; module, available from CPAN, provides a function to perform these actions for you.</source>
          <target state="translated">CPAN에서 사용할 수 있는 &lt;a href=&quot;Proc::Daemon&quot;&gt;Proc :: Daemon&lt;/a&gt; 모듈은 이러한 작업을 수행하는 기능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="570fbc1b333b95e1cacbc6d622c051543a52e083" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;Sys::Hostname&quot;&gt;Sys::Hostname&lt;/a&gt; module, part of the Standard Library, can also get the hostname:</source>
          <target state="translated">&lt;a href=&quot;Sys::Hostname&quot;&gt;sys 인 :: 호스트 이름&lt;/a&gt; 모듈, 표준 라이브러리의 일부는 또한 호스트 이름을 얻을 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="83438d62ddac1d3b0024cb20543586b81f4a2ed4" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;Sys::Hostname::Long&quot;&gt;Sys::Hostname::Long&lt;/a&gt; module takes a different approach and tries harder to return the fully qualified hostname:</source>
          <target state="translated">&lt;a href=&quot;Sys::Hostname::Long&quot;&gt;sys 인 :: 호스트 :: 긴&lt;/a&gt; 모듈은 다른 접근 방식을 취하고 완전한 호스트 이름을 반환하기 위해 더 열심히하려고합니다 :</target>
        </trans-unit>
        <trans-unit id="360df13e9e42398d87ddf7c87ae270331934433d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;TAP::Parser&quot;&gt;TAP::Parser&lt;/a&gt; does not use a formal grammar because TAP is essentially a stream-based protocol. In fact, it's quite legal to have an infinite stream. For the same reason that we don't apply regexes to streams, we're not using a formal grammar here. Instead, we parse the TAP in lines.</source>
          <target state="translated">&lt;a href=&quot;TAP::Parser&quot;&gt;TAP :: 파서는&lt;/a&gt; TAP는 본질적으로 스트림 기반 프로토콜이기 때문에 공식적인 문법을 사용하지 않습니다. 사실, 무한 스트림을 갖는 것은 매우 합법적입니다. 정규식을 스트림에 적용하지 않는 것과 같은 이유로 여기서는 공식적인 문법을 사용하지 않습니다. 대신 TAP를 줄 단위로 구문 분석합니다.</target>
        </trans-unit>
        <trans-unit id="da5808fca337034f35682036721a9427ccd81f04" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;Task::Kensho&quot;&gt;Task::Kensho&lt;/a&gt; module has a list of recommended modules which you should review as a good starting point.</source>
          <target state="translated">&lt;a href=&quot;Task::Kensho&quot;&gt;작업 :: Kensho의&lt;/a&gt; 모듈은 당신이 좋은 시작 지점으로 검토해야 권장 모듈의 목록이 있습니다.</target>
        </trans-unit>
        <trans-unit id="aafbf1ee7c517c584849dcba00f2431a29c861d9" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;Term::Cap&quot;&gt;Term::Cap&lt;/a&gt; module can also get the special sequence if you want to deal with the low-level details of terminal control. The &lt;code&gt;Tputs&lt;/code&gt; method returns the string for the given capability:</source>
          <target state="translated">&lt;a href=&quot;Term::Cap&quot;&gt;기간 : 캡&lt;/a&gt; 터미널 제어의 낮은 수준의 세부 정보를 처리 할 경우 모듈은 특별한 순서를 얻을 수 있습니다. &lt;code&gt;Tputs&lt;/code&gt; 방법은 주어진 기능에 대한 문자열을 반환합니다 :</target>
        </trans-unit>
        <trans-unit id="000a3fd43d21166c2b39d6546fdf69078cc7d878" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;Term::ReadKey&quot;&gt;Term::ReadKey&lt;/a&gt; module from CPAN offers an easy-to-use interface that should be more efficient than shelling out to &lt;b&gt;stty&lt;/b&gt; for each key. It even includes limited support for Windows.</source>
          <target state="translated">CPAN 의 &lt;a href=&quot;Term::ReadKey&quot;&gt;Term :: ReadKey&lt;/a&gt; 모듈은 각 키에 대해 &lt;b&gt;stty&lt;/b&gt; 를 사용하는 것보다 더 효율적이어야하는 사용하기 쉬운 인터페이스를 제공합니다 . Windows에 대한 제한된 지원도 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="e513d6d25a35bd468fa6dfadf342f7abd0a9398b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;Test2::API::Context&quot;&gt;Test2::API::Context&lt;/a&gt; object, as well as all &lt;a href=&quot;Test2::Event&quot;&gt;Test2::Event&lt;/a&gt; types need to have access to information about where they were created. This object represents that information.</source>
          <target state="translated">&lt;a href=&quot;Test2::API::Context&quot;&gt;Test2를 :: API :: 컨텍스트&lt;/a&gt; 객체뿐만 아니라 모든 &lt;a href=&quot;Test2::Event&quot;&gt;Test2를 :: 이벤트&lt;/a&gt; 유형은 생성 된 위치에 대한 정보에 액세스 할 수 있어야합니다. 이 개체는 해당 정보를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="25e3f2d15c3d0ceb7fdd915ea6fc508fa38a5afa" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;Test2::Event::Pass&quot;&gt;Test2::Event::Pass&lt;/a&gt; is a specially crafted and optimized event, using this will help the performance of passing tests.</source>
          <target state="translated">&lt;a href=&quot;Test2::Event::Pass&quot;&gt;Test2를 :: 이벤트 :: 패스&lt;/a&gt; 테스트를 통과의 성능에 도움이 될 것를 사용하여 특수하게 조작 된 최적화 된 이벤트입니다.</target>
        </trans-unit>
        <trans-unit id="64e3ab29916cf475d197cf70cfb13cb08a0c4ba1" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;Time::HiRes&quot;&gt;Time::HiRes&lt;/a&gt; module (part of the standard distribution as of Perl 5.8) measures time with the &lt;code&gt;gettimeofday()&lt;/code&gt; system call, which returns the time in microseconds since the epoch. If you can't install &lt;a href=&quot;Time::HiRes&quot;&gt;Time::HiRes&lt;/a&gt; for older Perls and you are on a Unixish system, you may be able to call &lt;code&gt;gettimeofday(2)&lt;/code&gt; directly. See &lt;a href=&quot;perlfunc#syscall&quot;&gt;&quot;syscall&quot; in perlfunc&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;Time::HiRes&quot;&gt;시간 :시 HiRes의&lt;/a&gt; 모듈과 측정 시간 (펄 5.8 등의 표준 배포판의 일부) &lt;code&gt;gettimeofday()&lt;/code&gt; 신기원 이후 마이크로 시간을 반환 시스템 호출. 이전 Perls 용 &lt;a href=&quot;Time::HiRes&quot;&gt;Time :: HiRes&lt;/a&gt; 를 설치할 수없고 Unixish 시스템을 사용하는 경우 &lt;code&gt;gettimeofday(2)&lt;/code&gt; 직접 호출 할 수 있습니다. &lt;a href=&quot;perlfunc#syscall&quot;&gt;perlfunc의 &quot;syscall&quot;을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="7e6f85e54060d65479b4d06b632210eb849f1f0e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;Time::Piece&quot;&gt;Time::Piece&lt;/a&gt; module exports a new &lt;code&gt;localtime&lt;/code&gt; that returns an object, and &lt;a href=&quot;Time::Seconds&quot;&gt;Time::Seconds&lt;/a&gt; exports the &lt;code&gt;ONE_DAY&lt;/code&gt; constant that is a set number of seconds. This means that it always gives the time 24 hours ago, which is not always yesterday. This can cause problems around the end of daylight saving time when there's one day that is 25 hours long.</source>
          <target state="translated">&lt;a href=&quot;Time::Piece&quot;&gt;시간 : 조각&lt;/a&gt; 모듈은 새로운 수출 &lt;code&gt;localtime&lt;/code&gt; 가 반환 객체를, 및 &lt;a href=&quot;Time::Seconds&quot;&gt;시간 : 초&lt;/a&gt; 보냅니다 &lt;code&gt;ONE_DAY&lt;/code&gt; 의 초 일련 번호는 정수입니다. 이는 항상 어제가 아닌 24 시간 전의 시간을 제공함을 의미합니다. 이로 인해 하루가 25 시간 인 일광 절약 시간이 끝날 무렵 문제가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ae8d644c0f0739788e0fe94553d172a549be62ef" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;Time::Piece&quot;&gt;Time::Piece&lt;/a&gt; module, which comes with Perl, replaces &lt;a href=&quot;localtime&quot;&gt;localtime&lt;/a&gt; with a version that returns an object. It also overloads the comparison operators so you can compare them directly:</source>
          <target state="translated">&lt;a href=&quot;Time::Piece&quot;&gt;시간 : 조각&lt;/a&gt; 펄과 함께 제공 모듈은, 대체는 &lt;a href=&quot;localtime&quot;&gt;localtime과&lt;/a&gt; 객체를 반환하는 버전. 또한 비교 연산자를 오버로드하므로 직접 비교할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8cc9a688570f19df6de24c492632ed7647b5575b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;Time::gmtime&quot;&gt;Time::gmtime&lt;/a&gt; and &lt;a href=&quot;Time::localtime&quot;&gt;Time::localtime&lt;/a&gt; modules provide a convenient, by-name access mechanism to the &lt;a href=&quot;#gmtime-EXPR&quot;&gt;&lt;code&gt;gmtime&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#localtime-EXPR&quot;&gt;&lt;code&gt;localtime&lt;/code&gt;&lt;/a&gt; functions, respectively.</source>
          <target state="translated">&lt;a href=&quot;Time::gmtime&quot;&gt;시간 : gmtime&lt;/a&gt; 과 &lt;a href=&quot;Time::localtime&quot;&gt;시간 ::의 현지&lt;/a&gt; 모듈은에 편리하고, 이름 별 액세스 메커니즘을 제공 &lt;a href=&quot;#gmtime-EXPR&quot;&gt; &lt;code&gt;gmtime&lt;/code&gt; &lt;/a&gt; 과 &lt;a href=&quot;#localtime-EXPR&quot;&gt; &lt;code&gt;localtime&lt;/code&gt; &lt;/a&gt; 각각의 기능을.</target>
        </trans-unit>
        <trans-unit id="2b9edd1164f7fd428ef66d1f77bb74482f07ecc4" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;Unicode::Tussle&quot;&gt;Unicode::Tussle&lt;/a&gt; CPAN module includes many programs to help with working with Unicode, including these programs to fully or partly replace standard utilities:</source>
          <target state="translated">&lt;a href=&quot;Unicode::Tussle&quot;&gt;유니 코드 :: 싸움&lt;/a&gt; CPAN 모듈은 완전히 또는 부분적으로 표준 유틸리티를 대체하기 위해이 프로그램을 포함, 유니 코드 작업을 돕기 위해 많은 프로그램을 포함한다 :</target>
        </trans-unit>
        <trans-unit id="4148a12496e441ea4f3ef8053e86029175f36271" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;autodie&quot;&gt;autodie&lt;/a&gt; pragma is very smart when it comes to working with Perl's built-in functions. The behaviour for these functions are fixed, and &lt;code&gt;autodie&lt;/code&gt; knows exactly how they try to signal failure.</source>
          <target state="translated">&lt;a href=&quot;autodie&quot;&gt;autodie의&lt;/a&gt; 는 펄의 내장 함수 작업에 올 때 pragma는 매우 똑똑하다. 이러한 함수의 동작은 고정되어 있으며 &lt;code&gt;autodie&lt;/code&gt; 는 실패 신호를 보내는 방법을 정확히 알고 있습니다. ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ</target>
        </trans-unit>
        <trans-unit id="1b61ff031aeab44addeeb9ed990fdd03cf707db7" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;b/xref&quot;&gt;B::Xref&lt;/a&gt; module can be used to generate cross-reference reports for Perl programs.</source>
          <target state="translated">&lt;a href=&quot;b/xref&quot;&gt;B : 외부 참조&lt;/a&gt; 모듈은 펄 프로그램에 대한 상호 참조 보고서를 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1c782dc05843dae452f5fa426b35990195e14641" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;carp&quot;&gt;Carp&lt;/a&gt; module allows you to present your error messages from the caller's perspective; this gives you a way to signal a problem with the caller and not your module. For instance, if you say this:</source>
          <target state="translated">&lt;a href=&quot;carp&quot;&gt;잉어&lt;/a&gt; 모듈은 호출자의 관점에서 오류 메시지를 제공 할 수 있습니다; 이를 통해 모듈이 아닌 호출자에게 문제를 알릴 수 있습니다. 예를 들어, 다음과 같이 말하면 :</target>
        </trans-unit>
        <trans-unit id="99917712f2804784fe8d984e9caf76b36fd4b3a3" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;crypt&quot;&gt;crypt&lt;/a&gt; function is unsuitable for hashing large quantities of data, not least of all because you can't get the information back. Look at the &lt;a href=&quot;../digest&quot;&gt;Digest&lt;/a&gt; module for more robust algorithms.</source>
          <target state="translated">&lt;a href=&quot;crypt&quot;&gt;토굴&lt;/a&gt; 기능을 사용하면 정보 등을 얻을 수 없기 때문에없는 이상 모든 대량의 데이터를 해싱에 적합하다. 보다 강력한 알고리즘 은 &lt;a href=&quot;../digest&quot;&gt;다이제스트&lt;/a&gt; 모듈을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="5477977d65c206b7b8a0bfb0ffcfed2d08e7d436" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;data/dumper&quot;&gt;Data::Dumper&lt;/a&gt; module can pretty-print Perl data structures:</source>
          <target state="translated">&lt;a href=&quot;data/dumper&quot;&gt;데이터 : 온보드&lt;/a&gt; 모듈은 펄 데이터 구조를 꽤 - 인쇄 할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="c389b29dcc18d72eca5cc18bef171945489bed86" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;data/dumper&quot;&gt;Data::Dumper&lt;/a&gt; module on CPAN (or the 5.005 release of Perl) is great for printing out data structures. The &lt;a href=&quot;storable&quot;&gt;Storable&lt;/a&gt; module on CPAN (or the 5.8 release of Perl), provides a function called &lt;code&gt;dclone&lt;/code&gt; that recursively copies its argument.</source>
          <target state="translated">CPAN 의 &lt;a href=&quot;data/dumper&quot;&gt;Data :: Dumper&lt;/a&gt; 모듈 (또는 Perl 5.005 릴리스)은 데이터 구조를 인쇄하는 데 유용합니다. &lt;a href=&quot;storable&quot;&gt;저장 가능&lt;/a&gt; CPAN에 접속 (또는 펄 5.8 릴리스)라는 함수 제공 &lt;code&gt;dclone&lt;/code&gt; 그 재귀 복사를 인수.</target>
        </trans-unit>
        <trans-unit id="3a7849edfc0302d7fe31cbb60d0e88c8f3db830b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;dbi&quot;&gt;DBI&lt;/a&gt; module provides an abstract interface to most database servers and types, including Oracle, DB2, Sybase, mysql, Postgresql, ODBC, and flat files. The DBI module accesses each database type through a database driver, or DBD. You can see a complete list of available drivers on CPAN: &lt;a href=&quot;http://www.cpan.org/modules/by-module/DBD/&quot;&gt;http://www.cpan.org/modules/by-module/DBD/&lt;/a&gt; . You can read more about DBI on &lt;a href=&quot;http://dbi.perl.org/&quot;&gt;http://dbi.perl.org/&lt;/a&gt; .</source>
          <target state="translated">&lt;a href=&quot;dbi&quot;&gt;DBI의&lt;/a&gt; 모듈은 오라클, DB2, 사이베이스, MySQL은, 포스트 그리 SQL, ODBC, 플랫 파일을 포함하여 대부분의 데이터베이스 서버 및 유형에 대한 추상적 인 인터페이스를 제공합니다. DBI 모듈은 데이터베이스 드라이버 또는 DBD를 통해 각 데이터베이스 유형에 액세스합니다. CPAN에서 사용 가능한 전체 드라이버 목록을 볼 수 있습니다. &lt;a href=&quot;http://www.cpan.org/modules/by-module/DBD/&quot;&gt;http://www.cpan.org/modules/by-module/DBD/&lt;/a&gt; . &lt;a href=&quot;http://dbi.perl.org/&quot;&gt;http://dbi.perl.org/에서&lt;/a&gt; DBI에 대한 자세한 내용을 읽을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0fb29e7cd4504f7ca3895f71c6eb9fad7707159a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;encoding&quot;&gt;encoding&lt;/a&gt; module has been deprecated since perl 5.18 and the perl internals it requires have been removed with perl 5.26.</source>
          <target state="translated">&lt;a href=&quot;encoding&quot;&gt;인코딩&lt;/a&gt; 모듈은 5.18 펄 때문에되지 않으며 그 요구 펄 내부 5.26 펄 제거되었다.</target>
        </trans-unit>
        <trans-unit id="f90e864f3a759969a519520835fc4b34320f5652" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;extutils/makemaker&quot;&gt;ExtUtils::MakeMaker&lt;/a&gt; module, better known simply as &quot;MakeMaker&quot;, turns a Perl script, typically called &lt;code&gt;Makefile.PL&lt;/code&gt; , into a Makefile. The Unix tool &lt;code&gt;make&lt;/code&gt; uses this file to manage dependencies and actions to process and install a Perl distribution.</source>
          <target state="translated">&lt;a href=&quot;extutils/makemaker&quot;&gt;위한 ExtUtils :: MakeMaker의&lt;/a&gt; 모듈이 더 간단하게 &quot;MakeMaker&quot;로 알려진, 일반적이라는 펄 스크립트, 회전 &lt;code&gt;Makefile.PL&lt;/code&gt; 메이크으로는. 유닉스 도구 &lt;code&gt;make&lt;/code&gt; 프로세스에 의존하고 작업을 관리하고 펄 배포판을 설치하려면이 파일을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="b36a8fb9e123f79842afcd307b1051443b42499f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;file/find&quot;&gt;File::Find&lt;/a&gt; module, which comes with Perl, does all of the hard work to traverse a directory structure. It comes with Perl. You simply call the &lt;code&gt;find&lt;/code&gt; subroutine with a callback subroutine and the directories you want to traverse:</source>
          <target state="translated">&lt;a href=&quot;file/find&quot;&gt;파일 :: 찾기&lt;/a&gt; 펄과 함께 제공 모듈은, 디렉토리 구조를 통과하는 모든 일은. 펄과 함께 제공됩니다. 콜백 서브 루틴과 탐색하려는 디렉토리를 사용 하여 &lt;code&gt;find&lt;/code&gt; 서브 루틴을 호출하면 됩니다.</target>
        </trans-unit>
        <trans-unit id="c85303530151e0f7d4bf77f032f56bce0f2d433a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;file/path&quot;&gt;File::Path&lt;/a&gt; module also has a legacy interface to the older &lt;code&gt;rmtree&lt;/code&gt; subroutine.</source>
          <target state="translated">&lt;a href=&quot;file/path&quot;&gt;파일 : 경로&lt;/a&gt; 모듈은 또한 이전에 레거시 인터페이스가 &lt;code&gt;rmtree&lt;/code&gt; 의 서브 루틴을.</target>
        </trans-unit>
        <trans-unit id="2e3abc4db13d619062f522429a3b20e4ff646e91" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;file/path&quot;&gt;File::Path&lt;/a&gt; module, which comes with Perl, has a &lt;code&gt;remove_tree&lt;/code&gt; which can take care of all of the hard work for you:</source>
          <target state="translated">&lt;a href=&quot;file/path&quot;&gt;파일 : 경로&lt;/a&gt; 펄과 함께 제공 모듈은하는이 &lt;code&gt;remove_tree&lt;/code&gt; 당신을위한 노력을 모두 돌볼 수 :</target>
        </trans-unit>
        <trans-unit id="e423ba5fb093092e153154cd61200bfa0809ecf8" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;file/stat&quot;&gt;File::stat&lt;/a&gt; module provides a convenient, by-name access mechanism:</source>
          <target state="translated">&lt;a href=&quot;file/stat&quot;&gt;파일 :: 합계&lt;/a&gt; 모듈은 편리에 의해 이름 액세스 메커니즘을 제공합니다 :</target>
        </trans-unit>
        <trans-unit id="147153b8beaaff8771aea84e885cb82d17734d7a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;findbin&quot;&gt;FindBin&lt;/a&gt; module, which comes with Perl, might work. It finds the directory of the currently running script and puts it in &lt;code&gt;$Bin&lt;/code&gt; , which you can then use to construct the right library path:</source>
          <target state="translated">&lt;a href=&quot;findbin&quot;&gt;FindBin의&lt;/a&gt; 펄과 함께 제공 모듈은 작동 할 수 있습니다. 현재 실행중인 스크립트의 디렉토리를 찾아 &lt;code&gt;$Bin&lt;/code&gt; 넣고 올바른 라이브러리 경로를 구성하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="177b530c271fe1dca56344e28974f18250fe298e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;findbin&quot;&gt;FindBin&lt;/a&gt; module, which comes with Perl, might work. It finds the directory of the currently running script and puts it in &lt;code&gt;$Bin&lt;/code&gt;, which you can then use to construct the right library path:</source>
          <target state="translated">&lt;a href=&quot;findbin&quot;&gt;FindBin의&lt;/a&gt; 펄과 함께 제공 모듈은 작동 할 수 있습니다. 현재 실행중인 스크립트의 디렉토리를 찾아 &lt;code&gt;$Bin&lt;/code&gt; 넣습니다. 그러면 올바른 라이브러리 경로를 구성하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6627242b752186d85aed5b69d9aaec46b0dd05af" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://search.cpan.org/perldoc/Algorithm::Loops&quot;&gt;Algorithm::Loops&lt;/a&gt; module also provides the &lt;code&gt;NextPermute&lt;/code&gt; and &lt;code&gt;NextPermuteNum&lt;/code&gt; functions which efficiently find all unique permutations of an array, even if it contains duplicate values, modifying it in-place: if its elements are in reverse-sorted order then the array is reversed, making it sorted, and it returns false; otherwise the next permutation is returned.</source>
          <target state="translated">&lt;a href=&quot;http://search.cpan.org/perldoc/Algorithm::Loops&quot;&gt;알고리즘 :: 루프&lt;/a&gt; 모듈도 제공 &lt;code&gt;NextPermute&lt;/code&gt; 및 &lt;code&gt;NextPermuteNum&lt;/code&gt; 에서 장소를 변경, 효율적 중복 값이 포함되어 있더라도, 어레이의 모든 고유 순열을 찾을 기능 : 요소는 역방향 정렬 된 순서 인 경우 그 배열이 역전 정렬하여 false를 리턴합니다. 그렇지 않으면 다음 순열이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="7f004cbac628e9968204a02264b31a3bb1043a19" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://search.cpan.org/perldoc/Array::Iterator::Circular&quot;&gt;Array::Iterator::Circular&lt;/a&gt; creates an iterator object for circular arrays:</source>
          <target state="translated">&lt;a href=&quot;http://search.cpan.org/perldoc/Array::Iterator::Circular&quot;&gt;배열 :: 반복자 :: 원형은&lt;/a&gt; 원형 배열하는 반복자 객체를 생성합니다 :</target>
        </trans-unit>
        <trans-unit id="a8c05beafd26231c80f038931300ac0e459427b6" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://search.cpan.org/perldoc/DBI&quot;&gt;DBI&lt;/a&gt; module provides an abstract interface to most database servers and types, including Oracle, DB2, Sybase, mysql, Postgresql, ODBC, and flat files. The DBI module accesses each database type through a database driver, or DBD. You can see a complete list of available drivers on CPAN: &lt;a href=&quot;http://www.cpan.org/modules/by-module/DBD/&quot;&gt;http://www.cpan.org/modules/by-module/DBD/&lt;/a&gt; . You can read more about DBI on &lt;a href=&quot;http://dbi.perl.org/&quot;&gt;http://dbi.perl.org/&lt;/a&gt; .</source>
          <target state="translated">&lt;a href=&quot;http://search.cpan.org/perldoc/DBI&quot;&gt;DBI의&lt;/a&gt; 모듈은 오라클, DB2, 사이베이스, MySQL은, 포스트 그리 SQL, ODBC, 플랫 파일을 포함하여 대부분의 데이터베이스 서버 및 유형에 대한 추상적 인 인터페이스를 제공합니다. DBI 모듈은 데이터베이스 드라이버 또는 DBD를 통해 각 데이터베이스 유형에 액세스합니다. : 당신은 CPAN에서 사용 가능한 드라이버의 전체 목록을 볼 수 있습니다 &lt;a href=&quot;http://www.cpan.org/modules/by-module/DBD/&quot;&gt;http://www.cpan.org/modules/by-module/DBD/을&lt;/a&gt; . DBI에 대한 자세한 내용은 &lt;a href=&quot;http://dbi.perl.org/&quot;&gt;http://dbi.perl.org/&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d99e17e2d810ab06df1befd3ba4deffe8e1f4100" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://search.cpan.org/perldoc/Data::Diver&quot;&gt;Data::Diver&lt;/a&gt; module on CPAN can do it for you too. Its &lt;code&gt;Dive&lt;/code&gt; subroutine can tell you not only if the keys exist but also get the value:</source>
          <target state="translated">CPAN 의 &lt;a href=&quot;http://search.cpan.org/perldoc/Data::Diver&quot;&gt;Data :: Diver&lt;/a&gt; 모듈에서도이를 수행 할 수 있습니다. 그것의 &lt;code&gt;Dive&lt;/code&gt; 서브 루틴은 키가 존재하는지뿐만 아니라 값을 얻는 지 알려줄 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="2f20a46404ea5d10e8ff52857742923d6a8c636c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://search.cpan.org/perldoc/Date::Calc&quot;&gt;Date::Calc&lt;/a&gt; module provides two functions to calculate these, too:</source>
          <target state="translated">&lt;a href=&quot;http://search.cpan.org/perldoc/Date::Calc&quot;&gt;날짜 : 캘크&lt;/a&gt; 모듈도 다음을 계산하는 두 가지 기능을 제공합니다 :</target>
        </trans-unit>
        <trans-unit id="cffc0b8a618b23964a5ae541c5cad5a91da659e3" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://search.cpan.org/perldoc/Devel::NYTProf&quot;&gt;Devel::NYTProf&lt;/a&gt; (New York Times Profiler) does both statement and subroutine profiling. It's available from CPAN and you also invoke it with the &lt;code&gt;-d&lt;/code&gt; switch:</source>
          <target state="translated">&lt;a href=&quot;http://search.cpan.org/perldoc/Devel::NYTProf&quot;&gt;(STABLE) : NYTProf&lt;/a&gt; (뉴욕 타임즈 프로파일 러) 모두 문 및 서브 루틴 프로파일 링을 수행합니다. CPAN에서 사용할 수 있으며 &lt;code&gt;-d&lt;/code&gt; 스위치를 사용하여 호출 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="36fe1514538dca6b4e14625a53ea351dc45f0bbb" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://search.cpan.org/perldoc/Email::MIME&quot;&gt;Email::MIME&lt;/a&gt; module can decode base 64-encoded email message parts transparently so the developer doesn't need to worry about it.</source>
          <target state="translated">&lt;a href=&quot;http://search.cpan.org/perldoc/Email::MIME&quot;&gt;이메일 : MIME의&lt;/a&gt; 모듈은 투명하므로 개발자가 걱정할 필요가 없다 기본 64로 인코딩 된 이메일 메시지 부분을 디코딩 할 수있다.</target>
        </trans-unit>
        <trans-unit id="5544c90428de4242a1010e3b0f0f5fbfd72933f8" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://search.cpan.org/perldoc/File::Find::Closures&quot;&gt;File::Find::Closures&lt;/a&gt;, which you can download from CPAN, provides many ready-to-use subroutines that you can use with &lt;a href=&quot;file/find&quot;&gt;File::Find&lt;/a&gt;.</source>
          <target state="translated">CPAN에서 다운로드 할 수 있는 &lt;a href=&quot;http://search.cpan.org/perldoc/File::Find::Closures&quot;&gt;File :: Find :: Closures&lt;/a&gt; 는 &lt;a href=&quot;file/find&quot;&gt;File :: Find&lt;/a&gt; 와 함께 사용할 수있는 많은 즉시 사용 가능한 서브 루틴을 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="56af297ba8a5f6d4fadfc00398e4a75a93e0389e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://search.cpan.org/perldoc/File::Find::Rule&quot;&gt;File::Find::Rule&lt;/a&gt; module, which you can download from CPAN, has a similar interface, but does the traversal for you too:</source>
          <target state="translated">CPAN에서 다운로드 할 수 있는 &lt;a href=&quot;http://search.cpan.org/perldoc/File::Find::Rule&quot;&gt;File :: Find :: Rule&lt;/a&gt; 모듈은 비슷한 인터페이스를 가지고 있지만 순회도 수행합니다.</target>
        </trans-unit>
        <trans-unit id="b152dc512307ef4ac58f7c9208c20855dec936d6" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://search.cpan.org/perldoc/File::Finder&quot;&gt;File::Finder&lt;/a&gt;, which you can download from CPAN, can help you create the callback subroutine using something closer to the syntax of the &lt;code&gt;find&lt;/code&gt; command-line utility:</source>
          <target state="translated">&lt;a href=&quot;http://search.cpan.org/perldoc/File::Finder&quot;&gt;파일 :: 찾기&lt;/a&gt; 당신이 CPAN에서 다운로드 할 수 있습니다, 당신은 가까이의 구문 뭔가를 사용하여 콜백 서브 루틴을 만들 수 있습니다 &lt;code&gt;find&lt;/code&gt; 명령 줄 유틸리티 :</target>
        </trans-unit>
        <trans-unit id="1598869d41d1eca117a3416dff8d5309f0c6cfec" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://search.cpan.org/perldoc/File::ReadBackwards&quot;&gt;File::ReadBackwards&lt;/a&gt; module also has the advantage of setting the input record separator to a regular expression.</source>
          <target state="translated">&lt;a href=&quot;http://search.cpan.org/perldoc/File::ReadBackwards&quot;&gt;파일 :: ReadBackwards은&lt;/a&gt; 또한 일반 식에 입력 레코드 구분자를 설정하는 장점을 갖는다 모듈.</target>
        </trans-unit>
        <trans-unit id="91110246c66bf6d661128beb45e4417253ba4c01" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://search.cpan.org/perldoc/IO::Interactive&quot;&gt;IO::Interactive&lt;/a&gt; module does the best it can to give you an answer. Its &lt;code&gt;is_interactive&lt;/code&gt; function returns an output filehandle; that filehandle points to standard output if the module thinks the session is interactive. Otherwise, the filehandle is a null handle that simply discards the output:</source>
          <target state="translated">&lt;a href=&quot;http://search.cpan.org/perldoc/IO::Interactive&quot;&gt;IO :: 대화 형&lt;/a&gt; 모듈은 당신에게 대답을 할 수있는 최선을 수행합니다. 그 &lt;code&gt;is_interactive&lt;/code&gt; 기능은 출력 파일 핸들을 반환 모듈이 세션이 대화식이라고 생각하면 해당 파일 핸들은 표준 출력을 가리 킵니다. 그렇지 않으면, 파일 핸들은 단순히 출력을 버리는 널 핸들입니다.</target>
        </trans-unit>
        <trans-unit id="6b13cf53c66e0915c0e8281e749fbd4b759e7ba2" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://search.cpan.org/perldoc/Proc::Daemon&quot;&gt;Proc::Daemon&lt;/a&gt; module, available from CPAN, provides a function to perform these actions for you.</source>
          <target state="translated">&lt;a href=&quot;http://search.cpan.org/perldoc/Proc::Daemon&quot;&gt;PROC : 데몬&lt;/a&gt; CPAN에서 사용할 모듈은 당신을 위해 이러한 작업을 수행 할 수있는 기능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="078338e81125883115260ece46dd352b4457327c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://search.cpan.org/perldoc/Sys::Hostname::Long&quot;&gt;Sys::Hostname::Long&lt;/a&gt; module takes a different approach and tries harder to return the fully qualified hostname:</source>
          <target state="translated">&lt;a href=&quot;http://search.cpan.org/perldoc/Sys::Hostname::Long&quot;&gt;sys 인 :: 호스트 :: 긴&lt;/a&gt; 모듈은 다른 접근 방식을 취하고 완전한 호스트 이름을 반환하기 위해 더 열심히하려고합니다 :</target>
        </trans-unit>
        <trans-unit id="d7d7335f50cc47451871f0f97f15916c1b4287d7" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://search.cpan.org/perldoc/Task::Kensho&quot;&gt;Task::Kensho&lt;/a&gt; module has a list of recommended modules which you should review as a good starting point.</source>
          <target state="translated">&lt;a href=&quot;http://search.cpan.org/perldoc/Task::Kensho&quot;&gt;작업 :: Kensho의&lt;/a&gt; 모듈은 당신이 좋은 시작 지점으로 검토해야 권장 모듈의 목록이 있습니다.</target>
        </trans-unit>
        <trans-unit id="96f2822c5bca6e995fc1a0007a9363af6e5934b2" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://search.cpan.org/perldoc/Term::ReadKey&quot;&gt;Term::ReadKey&lt;/a&gt; module from CPAN offers an easy-to-use interface that should be more efficient than shelling out to &lt;b&gt;stty&lt;/b&gt; for each key. It even includes limited support for Windows.</source>
          <target state="translated">CPAN 의 &lt;a href=&quot;http://search.cpan.org/perldoc/Term::ReadKey&quot;&gt;Term :: ReadKey&lt;/a&gt; 모듈은 사용하기 쉬운 인터페이스를 제공하여 각 키에 대해 &lt;b&gt;stty&lt;/b&gt; 로 쉘하는 것보다 더 효율적 입니다. Windows에 대한 제한된 지원도 포함합니다.</target>
        </trans-unit>
        <trans-unit id="32118c4d7f9e3bede84a1a66430b5426071bf4d3" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://search.cpan.org/perldoc/Unicode::Tussle&quot;&gt;Unicode::Tussle&lt;/a&gt; CPAN module includes many programs to help with working with Unicode, including these programs to fully or partly replace standard utilities:</source>
          <target state="translated">&lt;a href=&quot;http://search.cpan.org/perldoc/Unicode::Tussle&quot;&gt;유니 코드 :: 싸움&lt;/a&gt; CPAN 모듈은 완전히 또는 부분적으로 표준 유틸리티를 대체하기 위해이 프로그램을 포함, 유니 코드 작업을 돕기 위해 많은 프로그램을 포함한다 :</target>
        </trans-unit>
        <trans-unit id="919f72853738df881eb6e91400681adc998b688b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://search.cpan.org/perldoc/strictures#VERSION-2&quot;&gt;strictures&lt;/a&gt; module on CPAN offers one example of a warnings subset that the module's authors believe is relatively safe to fatalize.</source>
          <target state="translated">&lt;a href=&quot;http://search.cpan.org/perldoc/strictures#VERSION-2&quot;&gt;협착은&lt;/a&gt; 경고 한 예는 모듈의 저자는 fatalize 상대적으로 안전 믿는다 부분 집합 CPAN 제공에 모듈.</target>
        </trans-unit>
        <trans-unit id="843917bc0f80fad466bd923d5aab8d1c0906f90e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;io/handle&quot;&gt;IO::Handle&lt;/a&gt; objects also have a &lt;code&gt;flush&lt;/code&gt; method. You can flush the buffer any time you want without auto-buffering</source>
          <target state="translated">&lt;a href=&quot;io/handle&quot;&gt;IO :: 핸들은&lt;/a&gt; 또한이 객체 &lt;code&gt;flush&lt;/code&gt; 방법. 자동 버퍼링없이 언제든지 언제든지 버퍼를 플러시 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="5839e7279588dcb1c4433f17b527ae9a9d772eed" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;ipc/open2&quot;&gt;IPC::Open2&lt;/a&gt; module (part of the standard perl distribution) is an easy-to-use approach that internally uses &lt;code&gt;&lt;a href=&quot;functions/pipe&quot;&gt;pipe()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork()&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec()&lt;/a&gt;&lt;/code&gt; to do the job. Make sure you read the deadlock warnings in its documentation, though (see &lt;a href=&quot;ipc/open2&quot;&gt;IPC::Open2&lt;/a&gt;). See &lt;a href=&quot;perlipc#Bidirectional-Communication-with-Another-Process&quot;&gt;Bidirectional Communication with Another Process in perlipc&lt;/a&gt; and &lt;a href=&quot;perlipc#Bidirectional-Communication-with-Yourself&quot;&gt;Bidirectional Communication with Yourself in perlipc&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;ipc/open2&quot;&gt;IPC :: Open2의&lt;/a&gt; 모듈 (표준 펄 배포판의 일부는) 내부적으로 사용하는 사용하기 쉬운 방법입니다 &lt;code&gt;&lt;a href=&quot;functions/pipe&quot;&gt;pipe()&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork()&lt;/a&gt;&lt;/code&gt; , 및 &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec()&lt;/a&gt;&lt;/code&gt; 일을 할 수 있습니다. 그래도 문서에서 교착 상태 경고를 읽으십시오 ( &lt;a href=&quot;ipc/open2&quot;&gt;IPC :: Open2&lt;/a&gt; 참조 ). 참조 &lt;a href=&quot;perlipc#Bidirectional-Communication-with-Another-Process&quot;&gt;perlipc의 또 다른 프로세스와 양방향 통신&lt;/a&gt; 및 &lt;a href=&quot;perlipc#Bidirectional-Communication-with-Yourself&quot;&gt;perlipc에서 자신과 양방향 통신&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="09e04b4b58ffa26e2662b854208dafbdb133126a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;mime/base64&quot;&gt;MIME::Base64&lt;/a&gt; package handles this as well as the MIME/QP encoding. Decoding base 64 becomes as simple as:</source>
          <target state="translated">&lt;a href=&quot;mime/base64&quot;&gt;MIME :: Base64로&lt;/a&gt; 패키지 핸들이뿐만 아니라 MIME / QP 인코딩. 베이스 64 디코딩은 다음과 같이 간단 해집니다.</target>
        </trans-unit>
        <trans-unit id="0b7108620b7e75ec5ba066fc83c0e7f6113d802f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;mro&quot;&gt;mro&lt;/a&gt; pragma provides some functions for manipulating the method cache directly.</source>
          <target state="translated">&lt;a href=&quot;mro&quot;&gt;MRO의&lt;/a&gt; pragma는 직접 방법 캐시를 조작하기위한 몇 가지 기능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="f076d77a637b12522b1379f81df9ca81640a9292" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;net/domain&quot;&gt;Net::Domain&lt;/a&gt; module, which is part of the Standard Library starting in Perl 5.7.3, can get you the fully qualified domain name (FQDN), the host name, or the domain name.</source>
          <target state="translated">&lt;a href=&quot;net/domain&quot;&gt;순 :: 도메인&lt;/a&gt; 펄 5.7.3부터 표준 라이브러리의 일부 모듈은 당신에게 정규화 된 도메인 이름 (FQDN), 호스트 이름 또는 도메인 이름을 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="76dc71fd851bfecf3d4eefc768e03ef389a05460" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;open&quot;&gt;open&lt;/a&gt; pragma affects all the &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; calls after the pragma by setting default layers. If you want to affect only certain streams, use explicit layers directly in the &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; call.</source>
          <target state="translated">&lt;a href=&quot;open&quot;&gt;개방&lt;/a&gt; pragma는 모든 영향을 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; 디폴트의 층을 설정하여 프라그 후 전화를. 특정 스트림에만 영향을 주려면 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; 호출 에서 직접 명시 적 레이어를 사용 하십시오.</target>
        </trans-unit>
        <trans-unit id="3b5f1dd446b40bac39fbf56bdb1eee6bbfa27f8d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;open&quot;&gt;open&lt;/a&gt; pragma affects all the &lt;code&gt;open()&lt;/code&gt; calls after the pragma by setting default layers. If you want to affect only certain streams, use explicit layers directly in the &lt;code&gt;open()&lt;/code&gt; call.</source>
          <target state="translated">&lt;a href=&quot;open&quot;&gt;개방&lt;/a&gt; pragma는 모든 영향을 &lt;code&gt;open()&lt;/code&gt; 디폴트의 층을 설정하여 프라그 후 전화를. 특정 스트림에만 영향을 미치 &lt;code&gt;open()&lt;/code&gt; 호출 에서 직접 명시 적 레이어를 사용 하십시오.</target>
        </trans-unit>
        <trans-unit id="2cf8373e5ee8839618cf4f3d8412574499af0964" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;parent&quot;&gt;parent&lt;/a&gt; module is one of several ways that Perl lets you define inheritance relationships.</source>
          <target state="translated">&lt;a href=&quot;parent&quot;&gt;부모&lt;/a&gt; 모듈은 펄이 상속 관계를 정의 할 수 있음을 여러 가지 방법 중 하나입니다.</target>
        </trans-unit>
        <trans-unit id="4ba42fed843fbbf72076d217b81b8e5c3f052f2f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;perlrun#-C-%5Bnumber%2Flist%5D&quot;&gt;&lt;code&gt;-C&lt;/code&gt;&lt;/a&gt; command line option can specify that certain inputs to the program are Unicode, and the values of this can be read by your Perl code, see &lt;a href=&quot;perlvar#%24%7B%5EUNICODE%7D&quot;&gt;&quot;${^UNICODE}&quot; in perlvar&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;perlrun#-C-%5Bnumber%2Flist%5D&quot;&gt; &lt;code&gt;-C&lt;/code&gt; &lt;/a&gt; 명령 줄 옵션을 참조 유니 코드이며,이 값이 펄 코드를 읽을 수있는 프로그램이 특정 입력을 지정할 수 있습니다 &lt;a href=&quot;perlvar#%24%7B%5EUNICODE%7D&quot;&gt;&quot;$ {^ 유니 코드}&quot;perlvar에서&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6b0fe01583804e7c24edcd36bf4d1dc86edd7004" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;perlrun#-C-%5bnumber%2flist%5d&quot;&gt;-C &lt;/a&gt; command line option can specify that certain inputs to the program are Unicode, and the values of this can be read by your Perl code, see &lt;a href=&quot;perlvar#%24%7b%5eUNICODE%7d&quot;&gt;${^UNICODE} in perlvar&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;perlrun#-C-%5bnumber%2flist%5d&quot;&gt;-C&lt;/a&gt; 명령 행 옵션은 프로그램에 특정 입력이 유니 코드이며,이 값이 펄 코드를 읽을 수 있도록 지정할 수 있습니다 참조 &lt;a href=&quot;perlvar#%24%7b%5eUNICODE%7d&quot;&gt;perlvar에서 $ {^ 유니 코드}&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="bc877ff3004436e21e412f3d7536c1241e3ab1bd" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;perlsec&quot;&gt;perlsec&lt;/a&gt; documentation has general advice about data security. If you are using the &lt;a href=&quot;dbi&quot;&gt;DBI&lt;/a&gt; module, use placeholder to fill in data. If you are running external programs with &lt;code&gt;system&lt;/code&gt; or &lt;code&gt;exec&lt;/code&gt;, use the list forms. There are many other precautions that you should take, too many to list here, and most of them fall under the category of not using any data that you don't intend to use. Trust no one.</source>
          <target state="translated">&lt;a href=&quot;perlsec&quot;&gt;perlsec&lt;/a&gt; 문서는 데이터 보안에 대한 일반적인 조언이있다. 당신이 사용하는 경우 &lt;a href=&quot;dbi&quot;&gt;DBI의&lt;/a&gt; 모듈을 사용하는 자리 데이터를 입력합니다. &lt;code&gt;system&lt;/code&gt; 또는 &lt;code&gt;exec&lt;/code&gt; 로 외부 프로그램을 실행 하는 경우 목록 양식을 사용하십시오. 취해야 할 다른 예방 조치가 너무 많고 여기에 나열하기에는 너무 많으며 대부분 사용하지 않으려는 데이터를 사용하지 않는 범주에 속합니다. 아무도 믿지 마십시오.</target>
        </trans-unit>
        <trans-unit id="1dd5f1da5843d43e215f1c5605c7bd2602ba3c8d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;perlsec&quot;&gt;perlsec&lt;/a&gt; documentation has general advice about data security. If you are using the &lt;a href=&quot;http://search.cpan.org/perldoc/DBI&quot;&gt;DBI&lt;/a&gt; module, use placeholder to fill in data. If you are running external programs with &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt;, use the list forms. There are many other precautions that you should take, too many to list here, and most of them fall under the category of not using any data that you don't intend to use. Trust no one.</source>
          <target state="translated">&lt;a href=&quot;perlsec&quot;&gt;perlsec&lt;/a&gt; 문서는 데이터 보안에 대한 일반적인 조언이있다. 당신이 사용하는 경우 &lt;a href=&quot;http://search.cpan.org/perldoc/DBI&quot;&gt;DBI의&lt;/a&gt; 모듈을 사용하는 자리 데이터를 입력합니다. &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; 로 외부 프로그램을 실행중인 경우 목록 양식을 사용하십시오. 여기에 나열하기에는 너무주의해야 할 사항이 많으며 대부분 사용하지 않을 데이터를 사용하지 않는 범주에 속합니다. 아무도 믿지 마십시오.</target>
        </trans-unit>
        <trans-unit id="a18edb94d1038cfdd671ad02ef0a771da5913e80" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;perltie&quot;&gt;perltie&lt;/a&gt; section contains an example of tying handles.</source>
          <target state="translated">&lt;a href=&quot;perltie&quot;&gt;perltie의&lt;/a&gt; 섹션 매 핸들의 예를 포함한다.</target>
        </trans-unit>
        <trans-unit id="8d872a7f80e3dcd2bcfe4f77e0ab218cfcf5f3d9" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;perltie&quot;&gt;perltie&lt;/a&gt; section uses a good example of tying scalars by associating process IDs with priority.</source>
          <target state="translated">&lt;a href=&quot;perltie&quot;&gt;perltie의&lt;/a&gt; 섹션은 우선적으로 프로세스 ID를 대응하여 스칼라 매의 좋은 예를 사용한다.</target>
        </trans-unit>
        <trans-unit id="e969c75d9a86d34240a9b4b0c3bacd72a35586a9" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;perlvar#%24%5EO&quot;&gt;&lt;code&gt;$^O&lt;/code&gt;&lt;/a&gt; variable and the &lt;a href=&quot;config#archname&quot;&gt;&lt;code&gt;$Config{archname}&lt;/code&gt;&lt;/a&gt; values for various DOSish perls are as follows:</source>
          <target state="translated">&lt;a href=&quot;perlvar#%24%5EO&quot;&gt; &lt;code&gt;$^O&lt;/code&gt; &lt;/a&gt; 변수와 &lt;a href=&quot;config#archname&quot;&gt; &lt;code&gt;$Config{archname}&lt;/code&gt; &lt;/a&gt; 다양한 DOSish perls의 값은 다음이다 :</target>
        </trans-unit>
        <trans-unit id="d3dddc8cefb2df3a4b2f380a117370ecb94e0324" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt; module (part of the standard Perl distribution) implements &lt;code&gt;ceil()&lt;/code&gt; , &lt;code&gt;floor()&lt;/code&gt; , and a number of other mathematical and trigonometric functions.</source>
          <target state="translated">&lt;a href=&quot;posix&quot;&gt;POSIX의&lt;/a&gt; 모듈을 구현한다 (표준 펄 분포의 일부) &lt;code&gt;ceil()&lt;/code&gt; , &lt;code&gt;floor()&lt;/code&gt; , 및 다른 수학적 삼각 함수의 개수.</target>
        </trans-unit>
        <trans-unit id="3cfd8963d803d863b1baabc1a6fb32761a10e916" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt; module (part of the standard Perl distribution) implements &lt;code&gt;ceil()&lt;/code&gt;, &lt;code&gt;floor()&lt;/code&gt;, and a number of other mathematical and trigonometric functions.</source>
          <target state="translated">&lt;a href=&quot;posix&quot;&gt;POSIX의&lt;/a&gt; 모듈을 구현한다 (표준 펄 분포의 일부) &lt;code&gt;ceil()&lt;/code&gt; , &lt;code&gt;floor()&lt;/code&gt; , 및 다른 수학적 삼각 함수의 개수.</target>
        </trans-unit>
        <trans-unit id="eb81881ffc1ffa7659057b3aad0d531c1c255d43" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt; module can also format a date as the day of the year or week of the year.</source>
          <target state="translated">&lt;a href=&quot;posix&quot;&gt;POSIX의&lt;/a&gt; 모듈은 올해의 년 요일로 날짜를 포맷 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f19febd4ca12ddc4d78578d816e9ed0531d16d0b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt; module makes extensive use of this type.</source>
          <target state="translated">&lt;a href=&quot;posix&quot;&gt;POSIX의&lt;/a&gt; 모듈은 이러한 유형의 광범위하게 사용합니다.</target>
        </trans-unit>
        <trans-unit id="dda44e28f3e372b46a40263a9e3342beb0a11995" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;posix#getattr&quot;&gt;&lt;code&gt;POSIX::getattr&lt;/code&gt;&lt;/a&gt; function can do this more portably on systems purporting POSIX compliance. See also the &lt;a href=&quot;Term::ReadKey&quot;&gt;&lt;code&gt;Term::ReadKey&lt;/code&gt;&lt;/a&gt; module on CPAN.</source>
          <target state="translated">&lt;a href=&quot;posix#getattr&quot;&gt; &lt;code&gt;POSIX::getattr&lt;/code&gt; &lt;/a&gt; 기능은 POSIX 준수를 사칭 시스템에 대한 자세한 이식이 작업을 수행 할 수 있습니다. CPAN 의 &lt;a href=&quot;Term::ReadKey&quot;&gt; &lt;code&gt;Term::ReadKey&lt;/code&gt; &lt;/a&gt; 모듈 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e9379f8868c28dae16be3be866b6601876aaeaba" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;provide&quot;&gt;provide&lt;/a&gt; module from CPAN can be used to select one of several possible modules to load based on the version of Perl that is running.</source>
          <target state="translated">CPAN 의 &lt;a href=&quot;provide&quot;&gt;제공&lt;/a&gt; 모듈을 사용하여 실행중인 Perl 버전에 따라로드 할 여러 모듈 중 하나를 선택할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2b0fd33e8403b054935aab9d8ee0ab65dd34b689" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;re&quot;&gt;re&lt;/a&gt; module to alter behaviour and aid debugging.</source>
          <target state="translated">&lt;a href=&quot;re&quot;&gt;재&lt;/a&gt; ALTER 행동과 원조 디버깅 모듈.</target>
        </trans-unit>
        <trans-unit id="82ec47dd24e184de112e4cf2a9605a038adc3316" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;strictures#VERSION-2&quot;&gt;strictures&lt;/a&gt; module on CPAN offers one example of a warnings subset that the module's authors believe is relatively safe to fatalize.</source>
          <target state="translated">&lt;a href=&quot;strictures#VERSION-2&quot;&gt;협착은&lt;/a&gt; 경고 한 예는 모듈의 저자는 fatalize 상대적으로 안전 믿는다 부분 집합 CPAN 제공에 모듈.</target>
        </trans-unit>
        <trans-unit id="cb49b0f767217eaf2addd5f51c9329970eca01df" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;sys/hostname&quot;&gt;Sys::Hostname&lt;/a&gt; module, part of the Standard Library, can also get the hostname:</source>
          <target state="translated">&lt;a href=&quot;sys/hostname&quot;&gt;sys 인 :: 호스트 이름&lt;/a&gt; 모듈, 표준 라이브러리의 일부는 또한 호스트 이름을 얻을 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="220edf79ba9ff4834b00c1168d4289b47c73eb1c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;term/cap&quot;&gt;Term::Cap&lt;/a&gt; module can also get the special sequence if you want to deal with the low-level details of terminal control. The &lt;code&gt;Tputs&lt;/code&gt; method returns the string for the given capability:</source>
          <target state="translated">&lt;a href=&quot;term/cap&quot;&gt;기간 : 캡&lt;/a&gt; 터미널 제어의 낮은 수준의 세부 정보를 처리 할 경우 모듈은 특별한 순서를 얻을 수 있습니다. &lt;code&gt;Tputs&lt;/code&gt; 방법은 주어진 기능에 대한 문자열을 반환합니다 :</target>
        </trans-unit>
        <trans-unit id="e87c5439cafd856838e66bb969aac3bccda2430c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;threads&quot;&gt;threads&lt;/a&gt; and &lt;a href=&quot;threads/shared&quot;&gt;threads::shared&lt;/a&gt; modules are included in the core Perl distribution. Additionally, they are maintained as a separate modules on CPAN, so you can check there for any updates.</source>
          <target state="translated">&lt;a href=&quot;threads&quot;&gt;스레드&lt;/a&gt; 와 &lt;a href=&quot;threads/shared&quot;&gt;스레드 :: 공유&lt;/a&gt; 모듈은 핵심 펄 배포판에 포함되어 있습니다. 또한 CPAN에서 별도의 모듈로 유지되므로 업데이트가 있는지 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f6686ccb369690f0486ecaf90ca58010d28981b5" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;threads&quot;&gt;threads&lt;/a&gt; and &lt;a href=&quot;threads::shared&quot;&gt;threads::shared&lt;/a&gt; modules are included in the core Perl distribution. Additionally, they are maintained as a separate modules on CPAN, so you can check there for any updates.</source>
          <target state="translated">&lt;a href=&quot;threads&quot;&gt;스레드&lt;/a&gt; 와 &lt;a href=&quot;threads::shared&quot;&gt;스레드 :: 공유&lt;/a&gt; 모듈은 핵심 펄 배포판에 포함되어 있습니다. 또한 CPAN에서 별도의 모듈로 유지 관리되므로 업데이트를 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2a9bb0674257a5140b5151993d5c3d3a37202400" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;threads&quot;&gt;threads&lt;/a&gt; module provides the basic functions you need to write threaded programs. In the following sections, we'll cover the basics, showing you what you need to do to create a threaded program. After that, we'll go over some of the features of the &lt;a href=&quot;threads&quot;&gt;threads&lt;/a&gt; module that make threaded programming easier.</source>
          <target state="translated">&lt;a href=&quot;threads&quot;&gt;스레드&lt;/a&gt; 모듈은 스레드 프로그램을 작성하는 데 필요한 기본 기능을 제공합니다. 다음 섹션에서는 스레드 프로그램을 작성하기 위해 수행해야 할 작업을 보여주는 기본 사항을 설명합니다. 그런 다음, 스레드 프로그래밍을보다 쉽게 ​​만드는 &lt;a href=&quot;threads&quot;&gt;스레드&lt;/a&gt; 모듈 의 일부 기능을 살펴 보겠습니다 .</target>
        </trans-unit>
        <trans-unit id="2a739a40945ec3475dfa2806df561fe8eb1d910a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;threads&quot;&gt;threads&lt;/a&gt; module provides the tools you need to create new threads. Like any other module, you need to tell Perl that you want to use it; &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; threads;&lt;/code&gt; imports all the pieces you need to create basic threads.</source>
          <target state="translated">&lt;a href=&quot;threads&quot;&gt;스레드&lt;/a&gt; 모듈은 새로운 스레드를 생성하는 데 필요한 도구를 제공합니다. 다른 모듈과 마찬가지로 Perl에 사용하고 싶다고 알려 주어야합니다. &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; threads;&lt;/code&gt; &lt;a href=&quot;functions/use&quot;&gt;사용하십시오&lt;/a&gt; . 기본 스레드를 만드는 데 필요한 모든 부분을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="5c7c73d979dc1bd0fbebb065f801ce33de931673" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;threads&quot;&gt;threads&lt;/a&gt; module provides the tools you need to create new threads. Like any other module, you need to tell Perl that you want to use it; &lt;code&gt;use threads;&lt;/code&gt; imports all the pieces you need to create basic threads.</source>
          <target state="translated">&lt;a href=&quot;threads&quot;&gt;스레드&lt;/a&gt; 모듈은 새로운 스레드를 생성하는 데 필요한 도구를 제공합니다. 다른 모듈과 마찬가지로 Perl에게 사용하고 싶다고 말해야합니다. &lt;code&gt;use threads;&lt;/code&gt; 기본 스레드를 만드는 데 필요한 모든 조각을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="ac95afd4b80a6c32d7d4b6fc126fc11993d69484" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;time/gmtime&quot;&gt;Time::gmtime&lt;/a&gt; and &lt;a href=&quot;time/localtime&quot;&gt;Time::localtime&lt;/a&gt; modules provide a convenient, by-name access mechanism to the gmtime() and localtime() functions, respectively.</source>
          <target state="translated">&lt;a href=&quot;time/gmtime&quot;&gt;시간 : gmtime&lt;/a&gt; 과 &lt;a href=&quot;time/localtime&quot;&gt;시간 ::의 현지&lt;/a&gt; 모듈은 각각 gmtime ()과의 현지 () 함수에 편리한, 이름 별 액세스 메커니즘을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="27e7660ba02616c82b0460251677001be2bab8d2" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;time/hires&quot;&gt;Time::HiRes&lt;/a&gt; module (part of the standard distribution as of Perl 5.8) measures time with the &lt;code&gt;gettimeofday()&lt;/code&gt; system call, which returns the time in microseconds since the epoch. If you can't install &lt;a href=&quot;time/hires&quot;&gt;Time::HiRes&lt;/a&gt; for older Perls and you are on a Unixish system, you may be able to call &lt;code&gt;gettimeofday(2)&lt;/code&gt; directly. See &lt;a href=&quot;functions/syscall&quot;&gt;syscall&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;time/hires&quot;&gt;시간 :시 HiRes의&lt;/a&gt; 모듈과 측정 시간 (펄 5.8 등의 표준 배포판의 일부) &lt;code&gt;gettimeofday()&lt;/code&gt; 신기원 이후 마이크로 시간을 반환 시스템 호출. 이전 Perls 용 &lt;a href=&quot;time/hires&quot;&gt;Time :: HiRes&lt;/a&gt; 를 설치할 수없고 Unixish 시스템에있는 경우 &lt;code&gt;gettimeofday(2)&lt;/code&gt; 직접 호출 할 수 있습니다. &lt;a href=&quot;functions/syscall&quot;&gt;syscall을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="70cd112c1d983694e459a2b5affce0b2c176b5e1" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;time/piece&quot;&gt;Time::Piece&lt;/a&gt; module exports a new &lt;code&gt;&lt;a href=&quot;functions/localtime&quot;&gt;localtime&lt;/a&gt;&lt;/code&gt; that returns an object, and &lt;a href=&quot;time/seconds&quot;&gt;Time::Seconds&lt;/a&gt; exports the &lt;code&gt;ONE_DAY&lt;/code&gt; constant that is a set number of seconds. This means that it always gives the time 24 hours ago, which is not always yesterday. This can cause problems around the end of daylight saving time when there's one day that is 25 hours long.</source>
          <target state="translated">&lt;a href=&quot;time/piece&quot;&gt;시간 : 조각&lt;/a&gt; 모듈은 새로운 수출 &lt;code&gt;&lt;a href=&quot;functions/localtime&quot;&gt;localtime&lt;/a&gt;&lt;/code&gt; 가 반환 객체를, 및 &lt;a href=&quot;time/seconds&quot;&gt;시간 : 초&lt;/a&gt; 보냅니다 &lt;code&gt;ONE_DAY&lt;/code&gt; 의 초 일련 번호는 정수입니다. 이것은 항상 24 시간 전에 시간을 제공한다는 것을 의미합니다. 어제 항상 그런 것은 아닙니다. 이로 인해 하루가 25 시간 인 일광 절약 시간이 끝나는 시점에서 문제가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ad7b96811e1e0447b346c7c68b0b6f49a0e303ce" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;time/piece&quot;&gt;Time::Piece&lt;/a&gt; module, which comes with Perl, replaces &lt;a href=&quot;functions/localtime&quot;&gt;localtime&lt;/a&gt; with a version that returns an object. It also overloads the comparison operators so you can compare them directly:</source>
          <target state="translated">&lt;a href=&quot;time/piece&quot;&gt;시간 : 조각&lt;/a&gt; 펄과 함께 제공 모듈은, 대체는 &lt;a href=&quot;functions/localtime&quot;&gt;localtime과&lt;/a&gt; 객체를 반환하는 버전. 또한 비교 연산자를 오버로드하여 직접 비교할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3b4c77d08ed357c92167918b7693fcf1d9ab7f90" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;universal#VERSION-%28-%5B-REQUIRE-%5D-%29&quot;&gt;default &lt;code&gt;VERSION&lt;/code&gt; method&lt;/a&gt;, inherited from the &lt;a href=&quot;universal&quot;&gt;&lt;code&gt;UNIVERSAL&lt;/code&gt;&lt;/a&gt; class, croaks if the given version is larger than the value of the variable &lt;code&gt;$Module::VERSION&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;universal#VERSION-%28-%5B-REQUIRE-%5D-%29&quot;&gt;기본 &lt;code&gt;VERSION&lt;/code&gt; 방법&lt;/a&gt; 으로부터 상속, &lt;a href=&quot;universal&quot;&gt; &lt;code&gt;UNIVERSAL&lt;/code&gt; 의&lt;/a&gt; 클래스는, 주어진 버전은 변수의 값보다 큰 croaks 경우 &lt;code&gt;$Module::VERSION&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9b06bcf860d30364b7b86c5e727206450a5e8ad8" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;version&quot;&gt;version&lt;/a&gt; module provides the most reliable way to compare version numbers in all the various ways they might be provided or might exist within modules. Given two strings containing version numbers, &lt;code&gt;$v1&lt;/code&gt; and &lt;code&gt;$v2&lt;/code&gt;, they should be converted to &lt;code&gt;version&lt;/code&gt; objects before using ordinary comparison operators. For example:</source>
          <target state="translated">&lt;a href=&quot;version&quot;&gt;버전&lt;/a&gt; 모듈은 제공 될 수 또는 모듈 내에 존재 할 수있는 모든 다양한 방법으로 버전 번호를 비교하는 가장 신뢰할 수있는 방법을 제공합니다. 버전 번호 &lt;code&gt;$v1&lt;/code&gt; 및 &lt;code&gt;$v2&lt;/code&gt; 포함하는 두 개의 문자열이 주어지면 일반 비교 연산자를 사용하기 전에 &lt;code&gt;version&lt;/code&gt; 객체 로 변환해야합니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7624d8ccf09fad70c6649ad6b1aa4fa701ecfb1c" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;-C&lt;/b&gt; flag controls some of the Perl Unicode features.</source>
          <target state="translated">&lt;b&gt;-C&lt;/b&gt; 플래그는 펄 유니 코드의 일부 기능을 제어합니다.</target>
        </trans-unit>
        <trans-unit id="eeee1b2385aaa3798bce91466fcda51762a843eb" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;-C&lt;/b&gt; option only works if it is specified on the command line as well (with the same sequence of letters or numbers following). Either specify this option on the command line, or, if your system supports it, make your script executable and run it directly instead of passing it to perl.</source>
          <target state="translated">&lt;b&gt;-C&lt;/b&gt; 가 (문자 또는 숫자 다음과 같은 순서로)뿐만 아니라 명령 행에 지정된 경우 옵션은 작동합니다. 명령 행에서이 옵션을 지정하거나 시스템에서 지원하는 경우 스크립트를 실행 가능하게하고 perl에 전달하는 대신 직접 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="adbe88919d7c337e67d217e417ae52c5e78e86cc" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;-DL&lt;/b&gt; command-line switch is obsolete since circa Perl 5.6.0 (it was available only if Perl was built with &lt;code&gt;-DDEBUGGING&lt;/code&gt; ). The switch was used to track Perl's memory allocations and possible memory leaks. These days the use of malloc debugging tools like</source>
          <target state="translated">&lt;b&gt;-DL&lt;/b&gt; 명령 줄 스위치는 펄 5.6.0 년경 (이것은 펄이 함께 내장 된 경우에만 사용할 수 있습니다 때부터 사용되지 않습니다 &lt;code&gt;-DDEBUGGING&lt;/code&gt; ). 이 스위치는 Perl의 메모리 할당 및 가능한 메모리 누수를 추적하는 데 사용되었습니다. 요즘 malloc 디버깅 도구를 사용하면</target>
        </trans-unit>
        <trans-unit id="10ff88d6a964ef244acd1861f020528cdc0021d6" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;-DL&lt;/b&gt; command-line switch is obsolete since circa Perl 5.6.0 (it was available only if Perl was built with &lt;code&gt;-DDEBUGGING&lt;/code&gt;). The switch was used to track Perl's memory allocations and possible memory leaks. These days the use of malloc debugging tools like</source>
          <target state="translated">&lt;b&gt;-DL&lt;/b&gt; 명령 줄 스위치는 펄 5.6.0 년경 (이것은 펄이 함께 내장 된 경우에만 사용할 수 있습니다 때부터 사용되지 않습니다 &lt;code&gt;-DDEBUGGING&lt;/code&gt; ). 스위치는 Perl의 메모리 할당과 가능한 메모리 누수를 추적하는 데 사용되었습니다. 요즘 같은 malloc 디버깅 도구를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="7a02c2d05901d298065bac05eaefdaf89b098f1d" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;-a&lt;/b&gt; option followed by the name of a perl api function will extract the documentation of this function from &lt;a href=&quot;perlapi&quot;&gt;perlapi&lt;/a&gt;.</source>
          <target state="translated">&lt;b&gt;-a&lt;/b&gt; 펄 API 함수의 이름 다음에 옵션에서이 기능의 문서를 추출합니다 &lt;a href=&quot;perlapi&quot;&gt;perlapi을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b7458f799f2d3bc9e0821f8f30b793deae5a843f" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;-f&lt;/b&gt; option followed by the name of a perl built-in function will extract the documentation of this function from &lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt;.</source>
          <target state="translated">&lt;b&gt;-f&lt;/b&gt; 내장 기능 펄의 이름 다음에 옵션에서이 기능의 문서를 추출합니다 &lt;a href=&quot;perlfunc&quot;&gt;을 perlfunc를&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1902e94f8bb188d5617c0fc133e4af994267a619" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;-q&lt;/b&gt; option takes a regular expression as an argument. It will search the &lt;b&gt;q&lt;/b&gt;uestion headings in perlfaq[1-9] and print the entries matching the regular expression.</source>
          <target state="translated">&lt;b&gt;-q&lt;/b&gt; 옵션은 인수로 정규 표현식을합니다. 이 검색 할 &lt;b&gt;q 개의&lt;/b&gt; perlfaq [1-9]에서 uestion 제목 및 정규 표현 매칭 엔트리를 출력한다.</target>
        </trans-unit>
        <trans-unit id="5344e76d29fb1384ca26893a56599519b1faad07" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;-v&lt;/b&gt; option followed by the name of a Perl predefined variable will extract the documentation of this variable from &lt;a href=&quot;perlvar&quot;&gt;perlvar&lt;/a&gt;.</source>
          <target state="translated">&lt;b&gt;-v&lt;/b&gt; 펄의 이름 뒤에 옵션은 변수에서이 변수의 문서를 추출합니다 미리 정의 &lt;a href=&quot;perlvar&quot;&gt;perlvar를&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c5ae0073660f495c2b0b0a5aff71edb22c20f2cb" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;-verbose&lt;/b&gt; flag first prints out the &lt;a href=&quot;perldiag&quot;&gt;perldiag&lt;/a&gt; introduction before any other diagnostics. The $diagnostics::PRETTY variable can generate nicer escape sequences for pagers.</source>
          <target state="translated">&lt;b&gt;-verbose&lt;/b&gt; 플래그는 먼저 출력합니다 &lt;a href=&quot;perldiag&quot;&gt;것은 perldiag&lt;/a&gt; 다른 진단 전에 소개. $ diagnostics :: PRETTY 변수는 호출기에 더 좋은 이스케이프 시퀀스를 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ceb38ecccfec93207c00c9dee183b84b32a5f056" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;-w&lt;/b&gt; flag just sets the global &lt;code&gt;$^W&lt;/code&gt; variable as in 5.005. This means that any legacy code that currently relies on manipulating &lt;code&gt;$^W&lt;/code&gt; to control warning behavior will still work as is.</source>
          <target state="translated">&lt;b&gt;-w&lt;/b&gt; 플래그는 글로벌 설정 &lt;code&gt;$^W&lt;/code&gt; 5.005에서와 같이 변수를. 이것은 현재 경고 동작을 제어하기 위해 &lt;code&gt;$^W&lt;/code&gt; 조작에 의존하는 레거시 코드 는 그대로 작동 한다는 것을 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="72bbdbcc137e1ec7edde830d8069bcdc7d47c4dc" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;AutoLoader&lt;/b&gt; is similar in purpose to &lt;b&gt;SelfLoader&lt;/b&gt;: both delay the loading of subroutines.</source>
          <target state="translated">&lt;b&gt;자동로드는&lt;/b&gt; 에 목적이 유사 &lt;b&gt;SelfLoader&lt;/b&gt; : 모두 지연 서브 루틴의 로딩.</target>
        </trans-unit>
        <trans-unit id="0f53ec7201e8a617c94e28662bed3af80a664f4d" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;AutoLoader&lt;/b&gt; module works with the &lt;b&gt;AutoSplit&lt;/b&gt; module and the &lt;code&gt;__END__&lt;/code&gt; token to defer the loading of some subroutines until they are used rather than loading them all at once.</source>
          <target state="translated">&lt;b&gt;자동로드&lt;/b&gt; 와 모듈 작품 &lt;b&gt;자동 구분의&lt;/b&gt; 모듈과 &lt;code&gt;__END__&lt;/code&gt; 일부 서브 루틴의 토큰 연기 로딩들은 한 번에 모두를로드하는 것보다 사용 때까지.</target>
        </trans-unit>
        <trans-unit id="93865b59868e970114227e97ec05c9ea3f594f39" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;ExtUtils::Embed&lt;/b&gt; kit on CPAN also contains all source code for the examples in this document, tests, additional examples and other information you may find useful.</source>
          <target state="translated">CPAN 의 &lt;b&gt;ExtUtils :: Embed&lt;/b&gt; 키트에는이 문서의 예제, 테스트, 추가 예제 및 유용한 기타 정보에 대한 모든 소스 코드가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="78c68d8eddf3cc79f99821ef8cc24a0430101c54" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;IO&lt;/b&gt; extension, &lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt;, &lt;a href=&quot;perlop#I%2FO-Operators&quot;&gt;&quot;I/O Operators&quot; in perlop&lt;/a&gt;.</source>
          <target state="translated">&lt;b&gt;IO의&lt;/b&gt; 확장 &lt;a href=&quot;perlfunc&quot;&gt;을 perlfunc&lt;/a&gt; , &lt;a href=&quot;perlop#I%2FO-Operators&quot;&gt;&quot;I / O 연산자&quot;perlop에서&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d362af90dceed3d87816d0dcbc3d699668f7c9c9" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;IO&lt;/b&gt; extension, &lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt;, &lt;a href=&quot;perlop#I%2fO-Operators&quot;&gt;I/O Operators in perlop&lt;/a&gt;.</source>
          <target state="translated">&lt;b&gt;IO의&lt;/b&gt; 확장 &lt;a href=&quot;perlfunc&quot;&gt;을 perlfunc&lt;/a&gt; , &lt;a href=&quot;perlop#I%2fO-Operators&quot;&gt;I / perlop에서 O 연산자&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f4ddb503abc843b9ef214b377226c71b441a111a" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;Pod::Hyperlink&lt;/b&gt; class is mainly designed to parse the contents of the &lt;code&gt;L&amp;lt;...&amp;gt;&lt;/code&gt; sequence, providing a simple interface for accessing the different parts of a POD hyperlink for further processing. It can also be used to construct hyperlinks.</source>
          <target state="translated">&lt;b&gt;포드 :: 하이퍼&lt;/b&gt; 클래스는 주로 내용 분석하도록 설계되어 &lt;code&gt;L&amp;lt;...&amp;gt;&lt;/code&gt; 추가 처리하는 POD 하이퍼 링크의 다른 부분에 액세스하는 간단한 인터페이스를 제공하는 시퀀스. 하이퍼 링크를 구성하는 데에도 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="159cbd250976e52bd0b54f9fbb2c920f60501cf2" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;SelfLoader&lt;/b&gt; can replace the AutoLoader - just change 'use AutoLoader' to 'use SelfLoader' (though note that the &lt;b&gt;SelfLoader&lt;/b&gt; exports the AUTOLOAD function - but if you have your own AUTOLOAD and are using the AutoLoader too, you probably know what you're doing), and the &lt;code&gt;__END__&lt;/code&gt; token to &lt;code&gt;__DATA__&lt;/code&gt; . You will need perl version 5.001m or later to use this (version 5.001 with all patches up to patch m).</source>
          <target state="translated">&lt;b&gt;SelfLoader이&lt;/b&gt; 자동로드 대체 할 수 - '를 사용 SelfLoader'에 불과 변화 '를 사용 오토로더를'(주 불구하고 있다는 &lt;b&gt;SelfLoader의&lt;/b&gt; 수출 자동로드 기능 - 당신이 당신의 자신의 AUTOLOAD가 너무 오토로더를 사용하는 경우, 당신은 아마 무엇을 알고있는 거 하고 &lt;code&gt;__END__&lt;/code&gt; 토큰을 &lt;code&gt;__DATA__&lt;/code&gt; 합니다. 이것을 사용하려면 perl 버전 5.001m 이상이 필요합니다 (버전 5.001은 모든 패치와 패치 m까지).</target>
        </trans-unit>
        <trans-unit id="b4c86354fde60d804671cf8056d3c10e6c5b0099" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;SelfLoader&lt;/b&gt; can replace the AutoLoader - just change 'use AutoLoader' to 'use SelfLoader' (though note that the &lt;b&gt;SelfLoader&lt;/b&gt; exports the AUTOLOAD function - but if you have your own AUTOLOAD and are using the AutoLoader too, you probably know what you're doing), and the &lt;code&gt;__END__&lt;/code&gt; token to &lt;code&gt;__DATA__&lt;/code&gt;. You will need perl version 5.001m or later to use this (version 5.001 with all patches up to patch m).</source>
          <target state="translated">&lt;b&gt;SelfLoader이&lt;/b&gt; 자동로드 대체 할 수 - '를 사용 SelfLoader'에 불과 변화 '를 사용 오토로더를'(주 불구하고 있다는 &lt;b&gt;SelfLoader의&lt;/b&gt; 수출 자동로드 기능 - 당신이 당신의 자신의 AUTOLOAD가 너무 오토로더를 사용하는 경우, 당신은 아마 무엇을 알고있는 거 하고), &lt;code&gt;__END__&lt;/code&gt; 토큰을 &lt;code&gt;__DATA__&lt;/code&gt; 에 추가 합니다. 이것을 사용하려면 perl 버전 5.001m 이상이 필요합니다 (패치 m까지의 모든 패치와 함께 버전 5.001).</target>
        </trans-unit>
        <trans-unit id="9cc1e94494f4935e31dcd4aca4dd8097e05b3034" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;SelfLoader&lt;/b&gt; exports the &lt;code&gt;AUTOLOAD&lt;/code&gt; subroutine to the package using the &lt;b&gt;SelfLoader&lt;/b&gt;, and this loads the called subroutine when it is first called.</source>
          <target state="translated">&lt;b&gt;SelfLoader는&lt;/b&gt; 수출 &lt;code&gt;AUTOLOAD&lt;/code&gt; 사용하여 패키지에 서브 루틴을 &lt;b&gt;SelfLoader를&lt;/b&gt; 하고, 먼저이로드라는 서브 루틴을 호출 할 때.</target>
        </trans-unit>
        <trans-unit id="be3fad23fb52579393cf97f6d16c823542fd3d2f" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;SelfLoader&lt;/b&gt; reads from wherever the current position of the &lt;code&gt;FOOBAR::DATA&lt;/code&gt; filehandle is, until the EOF or &lt;code&gt;__END__&lt;/code&gt; . This means that if you want to use that filehandle (and ONLY if you want to), you should either</source>
          <target state="translated">&lt;b&gt;SelfLoader는&lt;/b&gt; 의 현재 위치 어디에서 읽어 &lt;code&gt;FOOBAR::DATA&lt;/code&gt; EOF 때까지 또는, 파일 핸들이 &lt;code&gt;__END__&lt;/code&gt; . 즉, 해당 파일 핸들을 사용하려는 경우 (원하는 경우에만) 다음 중 하나를 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="11f27c5dcec516e53a8a4d6fd79ba993403bc153" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;SelfLoader&lt;/b&gt; reads from wherever the current position of the &lt;code&gt;FOOBAR::DATA&lt;/code&gt; filehandle is, until the EOF or &lt;code&gt;__END__&lt;/code&gt;. This means that if you want to use that filehandle (and ONLY if you want to), you should either</source>
          <target state="translated">&lt;b&gt;SelfLoader는&lt;/b&gt; 의 현재 위치 어디에서 읽어 &lt;code&gt;FOOBAR::DATA&lt;/code&gt; EOF 때까지 또는, 파일 핸들이 &lt;code&gt;__END__&lt;/code&gt; . 즉, 해당 파일 핸들을 사용하려면 (원하는 경우에만) 다음 중 하나를 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="0f59147d20cbbd96eaf3ce69c4654c447143a93e" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;SelfLoader&lt;/b&gt; will read from the FOOBAR::DATA filehandle to load in the data after &lt;code&gt;__DATA__&lt;/code&gt; , and load in any subroutine when it is called. The costs are the one-time parsing of the data after &lt;code&gt;__DATA__&lt;/code&gt; , and a load delay for the _first_ call of any autoloaded function. The benefits (hopefully) are a speeded up compilation phase, with no need to load functions which are never used.</source>
          <target state="translated">&lt;b&gt;SelfLoader는&lt;/b&gt; FOOBAR에서 읽을 :: 데이터 이후의 데이터 부하 핸들 &lt;code&gt;__DATA__&lt;/code&gt; ,로드를 어떤 서브 루틴이 호출 될 때. 비용은 &lt;code&gt;__DATA__&lt;/code&gt; 이후의 데이터를 한 번 구문 분석 하고 자동로드 된 함수의 _first_ 호출에 대한로드 지연입니다. 이점은 컴파일 단계가 빨라져 결코 사용하지 않는 함수를로드 할 필요가 없다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="661b13cb881f0c177baa79d2f9cc5c08efa1139f" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;SelfLoader&lt;/b&gt; will read from the FOOBAR::DATA filehandle to load in the data after &lt;code&gt;__DATA__&lt;/code&gt;, and load in any subroutine when it is called. The costs are the one-time parsing of the data after &lt;code&gt;__DATA__&lt;/code&gt;, and a load delay for the _first_ call of any autoloaded function. The benefits (hopefully) are a speeded up compilation phase, with no need to load functions which are never used.</source>
          <target state="translated">&lt;b&gt;SelfLoader는&lt;/b&gt; FOOBAR에서 읽을 :: 데이터 이후의 데이터 부하 핸들 &lt;code&gt;__DATA__&lt;/code&gt; ,로드를 어떤 서브 루틴이 호출 될 때. 비용은 &lt;code&gt;__DATA__&lt;/code&gt; 이후 데이터의 일회성 구문 분석 과 자동로드 된 함수의 _first_ 호출에 대한로드 지연입니다. 이점은 (희망대로) 컴파일 단계가 빨라지고 사용되지 않는 함수를로드 할 필요가 없다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="b9076a846b441722c5113e39b9bcd0673ac55d99" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;SelfLoader&lt;/b&gt; will stop reading from &lt;code&gt;__DATA__&lt;/code&gt; if it encounters the &lt;code&gt;__END__&lt;/code&gt; token - just as you would expect. If the &lt;code&gt;__END__&lt;/code&gt; token is present, and is followed by the token DATA, then the &lt;b&gt;SelfLoader&lt;/b&gt; leaves the FOOBAR::DATA filehandle open on the line after that token.</source>
          <target state="translated">&lt;b&gt;SelfLoader는&lt;/b&gt; 읽는 중지됩니다 &lt;code&gt;__DATA__&lt;/code&gt; 가 발생하면 &lt;code&gt;__END__&lt;/code&gt; 당신이 기대하는 것처럼 - 토큰을. 는 IF &lt;code&gt;__END__&lt;/code&gt; 의 토큰이 존재하고, 토큰 DATA 뒤에, 다음 &lt;b&gt;SelfLoader의&lt;/b&gt; 나뭇잎 FOOBAR :: 그 토큰 다음 줄에 데이터 파일 핸들을 엽니 다.</target>
        </trans-unit>
        <trans-unit id="ae4ca9e2af773bc53d6ebfbbbcbbb68e0e663b29" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;SelfLoader&lt;/b&gt; works by the user placing the &lt;code&gt;__DATA__&lt;/code&gt; token</source>
          <target state="translated">&lt;b&gt;SelfLoader는&lt;/b&gt; 재치 사용자에 의해 작동 &lt;code&gt;__DATA__&lt;/code&gt; 의 토큰을</target>
        </trans-unit>
        <trans-unit id="b8a45570c1acb4c43b6a7805f6337844a9606503" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;SelfLoader&lt;/b&gt; works similarly to the AutoLoader, but picks up the subs from after the &lt;code&gt;__DATA__&lt;/code&gt; instead of in the 'lib/auto' directory. There is a maintenance gain in not needing to run AutoSplit on the module at installation, and a runtime gain in not needing to keep opening and closing files to load subs. There is a runtime loss in needing to parse the code after the &lt;code&gt;__DATA__&lt;/code&gt; . Details of the &lt;b&gt;AutoLoader&lt;/b&gt; and another view of these distinctions can be found in that module's documentation.</source>
          <target state="translated">&lt;b&gt;SelfLoader는&lt;/b&gt; 자동로드 비슷하게 작동하지만, 이후의 서브 집어 &lt;code&gt;__DATA__&lt;/code&gt; 대신 'lib 디렉토리 / 자동차'디렉토리입니다. 설치시 모듈에서 AutoSplit을 실행할 필요가 없어 유지 보수 이점이 있으며, 서브를로드하기 위해 파일을 계속 열고 닫을 필요가없는 런타임 이점이 있습니다. &lt;code&gt;__DATA__&lt;/code&gt; 다음에 코드를 구문 분석해야하는 런타임 손실이 있습니다 . &lt;b&gt;오토로더&lt;/b&gt; 에 대한 세부 사항과 이러한 차이점에 대한 다른 관점은 해당 모듈의 문서에서 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7dcbf6c27d3fbecf0a1da02dbc8cbd5d7c319816" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;SelfLoader&lt;/b&gt; works similarly to the AutoLoader, but picks up the subs from after the &lt;code&gt;__DATA__&lt;/code&gt; instead of in the 'lib/auto' directory. There is a maintenance gain in not needing to run AutoSplit on the module at installation, and a runtime gain in not needing to keep opening and closing files to load subs. There is a runtime loss in needing to parse the code after the &lt;code&gt;__DATA__&lt;/code&gt;. Details of the &lt;b&gt;AutoLoader&lt;/b&gt; and another view of these distinctions can be found in that module's documentation.</source>
          <target state="translated">&lt;b&gt;SelfLoader는&lt;/b&gt; 자동로드 비슷하게 작동하지만, 이후의 서브 집어 &lt;code&gt;__DATA__&lt;/code&gt; 대신 'lib 디렉토리 / 자동차'디렉토리입니다. 설치시 모듈에서 AutoSplit을 실행할 필요가 없다는 유지 보수 이점이 있으며 서브를로드하기 위해 파일을 계속 열고 닫을 필요가없는 런타임 이점이 있습니다. &lt;code&gt;__DATA__&lt;/code&gt; 다음에 코드를 구문 분석해야하는 런타임 손실이 있습니다 . &lt;b&gt;AutoLoader&lt;/b&gt; 에 대한 자세한 내용과 이러한 차이점에 대한 또 다른보기는 해당 모듈의 설명서에서 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="94dafc36f54a138d4c7c8beed77372c0b7d94298" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;Tie::Array&lt;/b&gt; implementation is a stub that simply croaks.</source>
          <target state="translated">&lt;b&gt;타이 :: 배열의&lt;/b&gt; 구현은 croaks 그루터기입니다.</target>
        </trans-unit>
        <trans-unit id="6b199766c781a0ae9ebeafd1ad9efb33847e8a69" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;Tie::Hash&lt;/b&gt; implementation is a stub that simply croaks.</source>
          <target state="translated">&lt;b&gt;타이 :: 해시&lt;/b&gt; 구현은 croaks 그루터기입니다.</target>
        </trans-unit>
        <trans-unit id="4134fa729bc36043c1bbc4226f0d69bd4bd166dc" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;Tie::StdArray&lt;/b&gt; package provides efficient methods required for tied arrays which are implemented as blessed references to an &quot;inner&quot; perl array. It inherits from &lt;b&gt;Tie::Array&lt;/b&gt;, and should cause tied arrays to behave exactly like standard arrays, allowing for selective overloading of methods.</source>
          <target state="translated">&lt;b&gt;타이 :: StdArray의&lt;/b&gt; 패키지는 &quot;내부&quot;펄 배열에 축복을 참조로 구현 묶여 배열에 필요한 효율적인 방법을 제공합니다. &lt;b&gt;Tie :: Array을&lt;/b&gt; 상속 &lt;b&gt;받으며&lt;/b&gt; 연결된 배열이 표준 배열과 똑같이 동작하도록하여 선택적인 오버로드 방법을 허용해야합니다.</target>
        </trans-unit>
        <trans-unit id="61ae2de46d00875a51e425357ad71e5ccdd2ad38" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;Tie::StdHandle&lt;/b&gt; package provide most methods for file handles described in &lt;a href=&quot;../perltie&quot;&gt;perltie&lt;/a&gt; (the exceptions are &lt;code&gt;UNTIE&lt;/code&gt; and &lt;code&gt;DESTROY&lt;/code&gt; ). It causes tied file handles to behave exactly like standard file handles and allow for selective overwriting of methods.</source>
          <target state="translated">&lt;b&gt;타이 :: StdHandle의&lt;/b&gt; 패키지에 설명 된 파일 핸들에 가장 방법을 제공 &lt;a href=&quot;../perltie&quot;&gt;perltie를&lt;/a&gt; (예외가 &lt;code&gt;UNTIE&lt;/code&gt; 과 &lt;code&gt;DESTROY&lt;/code&gt; ). 묶인 파일 핸들이 표준 파일 핸들과 똑같이 동작하고 선택적인 메소드 덮어 쓰기를 허용합니다.</target>
        </trans-unit>
        <trans-unit id="4245a18625b67300aa61449aa8288d150f2262ee" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;Tie::StdHandle&lt;/b&gt; package provide most methods for file handles described in &lt;a href=&quot;perltie&quot;&gt;perltie&lt;/a&gt; (the exceptions are &lt;code&gt;UNTIE&lt;/code&gt; and &lt;code&gt;DESTROY&lt;/code&gt;). It causes tied file handles to behave exactly like standard file handles and allow for selective overwriting of methods.</source>
          <target state="translated">&lt;b&gt;타이 :: StdHandle의&lt;/b&gt; 패키지에 설명 된 파일 핸들에 가장 방법을 제공 &lt;a href=&quot;perltie&quot;&gt;perltie를&lt;/a&gt; (예외가 &lt;code&gt;UNTIE&lt;/code&gt; 과 &lt;code&gt;DESTROY&lt;/code&gt; ). 이로 인해 연결된 파일 핸들이 표준 파일 핸들과 똑같이 작동하고 메서드를 선택적으로 덮어 쓸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="eacf0e41a2a5258a61ae34656b72764dd7acc141" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;Tie::SubstrHash&lt;/b&gt; package provides a hash-table-like interface to an array of determinate size, with constant key size and record size.</source>
          <target state="translated">&lt;b&gt;타이 :: SubstrHash의&lt;/b&gt; 패키지는 일정 키 크기와 기록 크기, 한정된 크기의 배열에 해시 테이블과 같은 인터페이스를 제공한다.</target>
        </trans-unit>
        <trans-unit id="a8a3a1e60f743e1378ee92d392f9857036d4b3d2" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;begincheck&lt;/b&gt; program makes it all clear, eventually:</source>
          <target state="translated">&lt;b&gt;begincheck의&lt;/b&gt; 프로그램은 모두 명확 결국 그것을합니다 :</target>
        </trans-unit>
        <trans-unit id="1112db1b82f4fc99681fd70d53f56d13ced227cf" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;encoding&lt;/b&gt; pragma changes this to use the specified encoding instead. For example:</source>
          <target state="translated">&lt;b&gt;인코딩&lt;/b&gt; pragma는이가 대신 인코딩 지정된 사용하도록 변경합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b7162377ab2247a065b27f7ed4e48c5d078da511" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;encoding&lt;/b&gt; pragma works by decoding string literals in &lt;code&gt;q//,qq//,qr//,qw///, qx//&lt;/code&gt; and so forth. In perl v5.8.0, this does not apply to &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr///&lt;/a&gt;&lt;/code&gt;. Therefore,</source>
          <target state="translated">&lt;b&gt;인코딩&lt;/b&gt; pragma는에 문자열 리터럴을 디코딩하여 작동합니다 &lt;code&gt;q//,qq//,qr//,qw///, qx//&lt;/code&gt; 등. perl v5.8.0에서는 &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr///&lt;/a&gt;&lt;/code&gt; 에는 적용되지 않습니다 . 따라서,</target>
        </trans-unit>
        <trans-unit id="0567b6469c4f0ce811f82d15382d41c3cb9254e1" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;encoding&lt;/b&gt; pragma works by decoding string literals in &lt;code&gt;q//,qq//,qr//,qw///, qx//&lt;/code&gt; and so forth. In perl v5.8.0, this does not apply to &lt;code&gt;tr///&lt;/code&gt;. Therefore,</source>
          <target state="translated">&lt;b&gt;인코딩&lt;/b&gt; pragma는에 문자열 리터럴을 디코딩하여 작동합니다 &lt;code&gt;q//,qq//,qr//,qw///, qx//&lt;/code&gt; 등. perl v5.8.0에서는 &lt;code&gt;tr///&lt;/code&gt; 에는 적용되지 않습니다 . 따라서,</target>
        </trans-unit>
        <trans-unit id="80faef413c7207aab71b9f1d03988df6331ef791" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;file&lt;/b&gt; (or &lt;b&gt;string&lt;/b&gt;, in the case of &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;) that is currently being &lt;b&gt;compiled&lt;/b&gt;.</source>
          <target state="translated">&lt;b&gt;파일&lt;/b&gt; (또는 &lt;b&gt;문자열&lt;/b&gt; 의 경우, &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 현재 중입니다) &lt;b&gt;컴파일&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="b93fec3ba5d429ebcf5cae82011aef3ec4a01036" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;file&lt;/b&gt; (or &lt;b&gt;string&lt;/b&gt;, in the case of &lt;code&gt;eval&lt;/code&gt;) that is currently being &lt;b&gt;compiled&lt;/b&gt;.</source>
          <target state="translated">&lt;b&gt;파일&lt;/b&gt; (또는 &lt;b&gt;문자열&lt;/b&gt; 의 경우, &lt;code&gt;eval&lt;/code&gt; 현재 중입니다) &lt;b&gt;컴파일&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="bb5cf33051195df3d457e45e85209f2138dc4a05" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;first time&lt;/b&gt; the hook is hit in a serialization flow, you may have it return an empty list. That will signal the Storable engine to further discard that hook for this class and to therefore revert to the default serialization of the underlying Perl data. The hook will again be normally processed in the next serialization.</source>
          <target state="translated">&lt;b&gt;처음&lt;/b&gt; 후크가 직렬화 흐름에 명중, 당신은 빈 목록을 반환 할 수 있습니다. 이는 Storable 엔진에이 클래스의 해당 후크를 추가로 버리고 기본 Perl 데이터의 기본 직렬화로 되돌 리도록 신호를 보냅니다. 후크는 다시 다음 직렬화에서 정상적으로 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="31b896e0d53803b62960180dd945e43dfa7f81e7" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;garbage collection&lt;/b&gt; of globals (and the running of any associated object destructors) that takes place when a Perl &lt;b&gt;interpreter&lt;/b&gt; is being shut down. Global destruction should not be confused with the Apocalypse, except perhaps when it should.</source>
          <target state="translated">Perl &lt;b&gt;인터프리터&lt;/b&gt; 가 종료 될 때 발생하는 전역 의 &lt;b&gt;가비지 콜렉션&lt;/b&gt; (및 연관된 오브젝트 소멸자 실행) 세계 파괴는 아마도 필요할 때를 제외하고는 묵시와 혼동되어서는 안됩니다.&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="987526f88e29534e7fb822b3987e499066378921" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;grouping&lt;/b&gt; metacharacters &lt;code&gt;()&lt;/code&gt; allow a part of a regex to be treated as a single unit. Parts of a regex are grouped by enclosing them in parentheses. The regex &lt;code&gt;house(cat|keeper)&lt;/code&gt; means match &lt;code&gt;house&lt;/code&gt; followed by either &lt;code&gt;cat&lt;/code&gt; or &lt;code&gt;keeper&lt;/code&gt; . Some more examples are</source>
          <target state="translated">&lt;b&gt;그룹화&lt;/b&gt; 메타은 &lt;code&gt;()&lt;/code&gt; 정규식의 일부가 하나의 단위로 취급 할 수있다. 정규식의 일부는 괄호로 묶어 그룹화됩니다. 정규식 &lt;code&gt;house(cat|keeper)&lt;/code&gt; 은 성냥 &lt;code&gt;house&lt;/code&gt; 다음에 &lt;code&gt;cat&lt;/code&gt; 또는 &lt;code&gt;keeper&lt;/code&gt; 합니다. 더 많은 예는</target>
        </trans-unit>
        <trans-unit id="8b06519ab9371f66acf34ade00457226ccfb28ee" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;grouping&lt;/b&gt; metacharacters &lt;code&gt;()&lt;/code&gt; allow a part of a regex to be treated as a single unit. Parts of a regex are grouped by enclosing them in parentheses. The regex &lt;code&gt;house(cat|keeper)&lt;/code&gt; means match &lt;code&gt;house&lt;/code&gt; followed by either &lt;code&gt;cat&lt;/code&gt; or &lt;code&gt;keeper&lt;/code&gt;. Some more examples are</source>
          <target state="translated">&lt;b&gt;그룹화&lt;/b&gt; 메타은 &lt;code&gt;()&lt;/code&gt; 정규식의 일부가 하나의 단위로 취급 할 수있다. 정규식의 일부는 괄호로 묶어 그룹화됩니다. 정규식 &lt;code&gt;house(cat|keeper)&lt;/code&gt; 은 &lt;code&gt;house&lt;/code&gt; 뒤에 &lt;code&gt;cat&lt;/code&gt; 또는 &lt;code&gt;keeper&lt;/code&gt; 가 오는 매치 하우스를 의미 합니다. 더 많은 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ba87bd98015a685039202791b8b4c178941ed0ba" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;interpolation&lt;/b&gt; of a scalar or array variable into a string.</source>
          <target state="translated">&lt;b&gt;보간&lt;/b&gt; 문자열로 스칼라 또는 배열 변수.</target>
        </trans-unit>
        <trans-unit id="fd9fd954815d11416f915389911ed3472be1a48a" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;new()&lt;/b&gt; method can either be passed a set of key/value pairs or a single scalar value, namely the contents of a &lt;code&gt;L&amp;lt;...&amp;gt;&lt;/code&gt; sequence. An object of the class &lt;code&gt;Pod::Hyperlink&lt;/code&gt; is returned. The value &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; indicates a failure, the error message is stored in &lt;code&gt;$@&lt;/code&gt; .</source>
          <target state="translated">&lt;b&gt;새로운 ()&lt;/b&gt; 메소드는 어느 키 / 값 쌍 또는 단일 스칼라 값, 즉 콘텐츠의 집합 전달할 수 &lt;code&gt;L&amp;lt;...&amp;gt;&lt;/code&gt; 시퀀스. &lt;code&gt;Pod::Hyperlink&lt;/code&gt; 클래스의 객체 가 반환됩니다. &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 값 은 실패를 나타내며 오류 메시지는 &lt;code&gt;$@&lt;/code&gt; 저장됩니다 .</target>
        </trans-unit>
        <trans-unit id="22dcd0ec3aed7a2c1842ef98e2374e061c59b868" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;package&lt;/b&gt; in which the current statement is &lt;b&gt;compiled&lt;/b&gt;. Scan backward in the text of your program through the current &lt;b&gt;lexical scope&lt;/b&gt; or any enclosing lexical scopes until you find a package declaration. That&amp;rsquo;s your current package name.</source>
          <target state="translated">&lt;b&gt;패키지&lt;/b&gt; 현재 문이되는 &lt;b&gt;컴파일&lt;/b&gt; . 패키지 선언을 찾을 때까지 현재 &lt;b&gt;어휘 범위&lt;/b&gt; 또는 둘러싸는 어휘 범위를 통해 프로그램 텍스트에서 뒤로 스캔하십시오 . 이것이 현재 패키지 이름입니다.</target>
        </trans-unit>
        <trans-unit id="837534d7853b1df8d6be64303da76d4fb655fe6c" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;parse_text()&lt;/b&gt; method takes a given paragraph of text, and returns a parse-tree that contains one or more children, each of which may be a text-string, or an InteriorSequence object. There are also callback-options that may be passed to &lt;b&gt;parse_text()&lt;/b&gt; to customize the way it expands or transforms interior-sequences, as well as the returned result. These callbacks can be used to create a parse-tree with custom-made objects (which may or may not support the parse-tree interface, depending on how you choose to do it).</source>
          <target state="translated">&lt;b&gt;parse_text ()&lt;/b&gt; 메서드는 텍스트의 주어진 단락을 받아, 텍스트 문자열, 또는 InteriorSequence 객체가 될 수 있습니다 각각의 하나 또는 그 이상의 어린이가 포함 된 구문 분석 트리를 반환합니다. &lt;b&gt;parse_text ()&lt;/b&gt; 에 전달되어 콜백 옵션이있어 내부 시퀀스를 확장 또는 변환하는 방법과 반환 된 결과를 사용자 정의 할 수 있습니다. 이 콜백을 사용하여 사용자 정의 객체로 구문 분석 트리를 만들 수 있습니다 (선택한 방법에 따라 구문 분석 트리 인터페이스를 지원하거나 지원하지 않을 수 있음).</target>
        </trans-unit>
        <trans-unit id="b2fcda0a32417727cdd721f28d0c908b93bc1f19" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;perlivp&lt;/b&gt; program is set up at Perl source code build time to test the Perl version it was built under. It can be used after running:</source>
          <target state="translated">&lt;b&gt;perlivp의&lt;/b&gt; 프로그램은 아래에 내장 된 펄 버전을 테스트하기 위해 펄 소스 코드를 빌드시에 설정됩니다. 실행 후 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dc37ad02e0c6923bebd0d4430ccd02307461404f" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;podchecker&lt;/b&gt; command is provided for checking Pod syntax for errors and warnings. For example, it checks for completely blank lines in Pod blocks and for unknown commands and formatting codes. You should still also pass your document through one or more translators and proofread the result, or print out the result and proofread that. Some of the problems found may be bugs in the translators, which you may or may not wish to work around.</source>
          <target state="translated">&lt;b&gt;podchecker의&lt;/b&gt; 명령 오류 및 경고 용 포드 구문을 확인하기 위해 제공된다. 예를 들어, 포드 블록에서 완전히 빈 줄과 알 수없는 명령 및 서식 코드가 있는지 확인합니다. 또한 하나 이상의 번역자를 통해 문서를 전달하고 결과를 교정하거나 결과를 인쇄하여 교정해야합니다. 발견 된 일부 문제는 번역가의 버그 일 수 있으며이 문제를 해결하기 원하거나하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0a20174d8e3b5a76e2734d6eb6a0cf7707e14ad1" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;podchecker&lt;/b&gt; script that comes with this distribution is a lean wrapper around this module. See the online manual with</source>
          <target state="translated">이 배포판과 함께 제공 되는 &lt;b&gt;podchecker&lt;/b&gt; 스크립트는이 모듈을 둘러싼 간결한 래퍼입니다. 온라인 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="d299b97d8bab37b1330370eb9473b8a413d005a5" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;quantifier&lt;/b&gt; metacharacters &lt;code&gt;?&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt; , &lt;code&gt;+&lt;/code&gt; , and &lt;code&gt;{}&lt;/code&gt; allow us to determine the number of repeats of a portion of a regex we consider to be a match. Quantifiers are put immediately after the character, character class, or grouping that we want to specify. They have the following meanings:</source>
          <target state="translated">&lt;b&gt;정량의&lt;/b&gt; 메타 문자 &lt;code&gt;?&lt;/code&gt; , &lt;code&gt;*&lt;/code&gt; , &lt;code&gt;+&lt;/code&gt; 및 &lt;code&gt;{}&lt;/code&gt; 을 사용하면 일치하는 것으로 간주되는 정규 표현식의 일부 반복 횟수를 결정할 수 있습니다. 수량자는 지정하려는 문자, 문자 클래스 또는 그룹 바로 뒤에 놓입니다. 다음과 같은 의미가 있습니다.</target>
        </trans-unit>
        <trans-unit id="eaae51c09e62ae41b20067864a8beaa2340f2425" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;quantifier&lt;/b&gt; metacharacters &lt;code&gt;?&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt;, &lt;code&gt;+&lt;/code&gt;, and &lt;code&gt;{}&lt;/code&gt; allow us to determine the number of repeats of a portion of a regex we consider to be a match. Quantifiers are put immediately after the character, character class, or grouping that we want to specify. They have the following meanings:</source>
          <target state="translated">&lt;b&gt;정량의&lt;/b&gt; 메타 문자 &lt;code&gt;?&lt;/code&gt; , &lt;code&gt;*&lt;/code&gt; , &lt;code&gt;+&lt;/code&gt; 및 &lt;code&gt;{}&lt;/code&gt; 를 사용하면 일치하는 것으로 간주되는 정규식 부분의 반복 횟수를 결정할 수 있습니다. 한정자는 지정하려는 문자, 문자 클래스 또는 그룹화 바로 뒤에 배치됩니다. 의미는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9b54e7f659f70ec7a4f3708e917b8834ab10ef21" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;scalar values&lt;/b&gt; that you supply to a &lt;b&gt;function&lt;/b&gt; or &lt;b&gt;subroutine&lt;/b&gt; when you call it. For instance, when you call &lt;code&gt;power(&quot;puff&quot;)&lt;/code&gt; , the string &lt;code&gt;&quot;puff&quot;&lt;/code&gt; is the actual argument. See also &lt;b&gt;argument&lt;/b&gt; and &lt;b&gt;formal arguments&lt;/b&gt;.</source>
          <target state="translated">&lt;b&gt;스칼라 값은&lt;/b&gt; 당신이에 공급하는 것이 &lt;b&gt;기능&lt;/b&gt; 이나 &lt;b&gt;서브 루틴&lt;/b&gt; 당신이 그것을 호출 할 때. 예를 들어 &lt;code&gt;power(&quot;puff&quot;)&lt;/code&gt; 를 호출 하면 문자열 &lt;code&gt;&quot;puff&quot;&lt;/code&gt; 가 실제 인수입니다. &lt;b&gt;인수&lt;/b&gt; 및 &lt;b&gt;형식 인수&lt;/b&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="322845e84e15f9ba6a6f987f2f0f5a926b87542a" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;scalar values&lt;/b&gt; that you supply to a &lt;b&gt;function&lt;/b&gt; or &lt;b&gt;subroutine&lt;/b&gt; when you call it. For instance, when you call &lt;code&gt;power(&quot;puff&quot;)&lt;/code&gt;, the string &lt;code&gt;&quot;puff&quot;&lt;/code&gt; is the actual argument. See also &lt;b&gt;argument&lt;/b&gt; and &lt;b&gt;formal arguments&lt;/b&gt;.</source>
          <target state="translated">&lt;b&gt;스칼라 값은&lt;/b&gt; 당신이에 공급하는 것이 &lt;b&gt;기능&lt;/b&gt; 이나 &lt;b&gt;서브 루틴&lt;/b&gt; 당신이 그것을 호출 할 때. 예를 들어, 당신이 호출 할 때 &lt;code&gt;power(&quot;puff&quot;)&lt;/code&gt; 문자열 &lt;code&gt;&quot;puff&quot;&lt;/code&gt; 실제 인수입니다. &lt;b&gt;인수&lt;/b&gt; 및 &lt;b&gt;형식 인수를&lt;/b&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="4a023f0632e523744570838f6670cc7a9e367c0e" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;sigtrap&lt;/b&gt; pragma is a simple interface to installing signal handlers. You can have it install one of two handlers supplied by &lt;b&gt;sigtrap&lt;/b&gt; itself (one which provides a Perl stack trace and one which simply &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die()&lt;/a&gt;&lt;/code&gt;s), or alternately you can supply your own handler for it to install. It can be told only to install a handler for signals which are either untrapped or ignored. It has a couple of lists of signals to trap, plus you can supply your own list of signals.</source>
          <target state="translated">&lt;b&gt;SIGTRAP의&lt;/b&gt; 프라그는 신호 처리기를 설치하는 간단한 인터페이스이다. &lt;b&gt;sigtrap&lt;/b&gt; 자체에서 제공하는 두 개의 핸들러 중 하나 (Perl 스택 추적을 제공하는 하나와 단순히 &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die()&lt;/a&gt;&lt;/code&gt; 를 제공하는 핸들러) 중 하나를 설치하도록 하거나, 또는 설치하기 위해 고유 한 핸들러를 제공 할 수 있습니다. 트랩되지 않았거나 무시 된 신호에 대한 핸들러 만 설치하도록 지시 할 수 있습니다. 트랩 할 신호 목록이 몇 개 있으며, 자신 만의 신호 목록을 제공 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="9bf9f6bd9139c0d963b36b36175d399537dfc4fb" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;sigtrap&lt;/b&gt; pragma is a simple interface to installing signal handlers. You can have it install one of two handlers supplied by &lt;b&gt;sigtrap&lt;/b&gt; itself (one which provides a Perl stack trace and one which simply &lt;code&gt;die()&lt;/code&gt;s), or alternately you can supply your own handler for it to install. It can be told only to install a handler for signals which are either untrapped or ignored. It has a couple of lists of signals to trap, plus you can supply your own list of signals.</source>
          <target state="translated">&lt;b&gt;SIGTRAP의&lt;/b&gt; 프라그는 신호 처리기를 설치하는 간단한 인터페이스이다. &lt;b&gt;sigtrap&lt;/b&gt; 자체에서 제공하는 두 개의 핸들러 중 하나 (하나는 Perl 스택 추적을 제공하고 다른 하나는 단순히 &lt;code&gt;die()&lt;/code&gt; s)를 설치하도록하거나 또는 설치를위한 자체 핸들러를 제공 할 수 있습니다. 트랩되지 않거나 무시되는 신호에 대한 핸들러 만 설치하도록 지시 할 수 있습니다. 트랩 할 신호 목록이 몇 개 있으며 자체 신호 목록을 제공 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="d7c162ba3d4340b1ed67afae232423e0f505fd2b" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;value&lt;/b&gt; produced by a &lt;b&gt;subroutine&lt;/b&gt; or &lt;b&gt;expression&lt;/b&gt; when evaluated. In Perl, a return value may be either a &lt;b&gt;list&lt;/b&gt; or a &lt;b&gt;scalar&lt;/b&gt;.</source>
          <target state="translated">&lt;b&gt;값은&lt;/b&gt; a로 제조 된 &lt;b&gt;서브 루틴&lt;/b&gt; 또는 &lt;b&gt;식&lt;/b&gt; 검사시. Perl에서 리턴 값은 &lt;b&gt;목록&lt;/b&gt; 또는 &lt;b&gt;스칼라 일 수&lt;/b&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="7487920171bd7708f5f44fcbcd3a51b3cd669ff9" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;value&lt;/b&gt; returned to the parent &lt;b&gt;process&lt;/b&gt; when one of its child processes dies. This value is placed in the special variable &lt;code&gt;$?&lt;/code&gt; . Its upper eight &lt;b&gt;bits&lt;/b&gt; are the exit status of the defunct process, and its lower eight bits identify the signal (if any) that the process died from. On Unix systems, this status value is the same as the status word returned by</source>
          <target state="translated">자식 프로세스 중 하나가 죽으면 부모 &lt;b&gt;프로세스&lt;/b&gt; 로 반환 되는 &lt;b&gt;값&lt;/b&gt; 입니다. 이 값은 특수 변수 &lt;code&gt;$?&lt;/code&gt; . 상위 8 &lt;b&gt;비트&lt;/b&gt; 는 폐기 프로세스의 종료 상태이며 하위 8 비트는 프로세스가 종료 된 신호 (있는 경우)를 식별합니다. Unix 시스템에서이 상태 값은 다음에 의해 반환되는 상태 단어와 같습니다.&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="92fc59668896181422dc0c709aa06976d25a8bdd" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;value&lt;/b&gt; returned to the parent &lt;b&gt;process&lt;/b&gt; when one of its child processes dies. This value is placed in the special variable &lt;code&gt;$?&lt;/code&gt;. Its upper eight &lt;b&gt;bits&lt;/b&gt; are the exit status of the defunct process, and its lower eight bits identify the signal (if any) that the process died from. On Unix systems, this status value is the same as the status word returned by</source>
          <target state="translated">자식 프로세스 중 하나가 죽을 때 부모 &lt;b&gt;프로세스에&lt;/b&gt; 반환 되는 &lt;b&gt;값&lt;/b&gt; 입니다. 이 값은 특수 변수 &lt;code&gt;$?&lt;/code&gt; . 상위 8 &lt;b&gt;비트&lt;/b&gt; 는 소멸 된 프로세스의 종료 상태이고 하위 8 비트는 프로세스가 종료 된 신호 (있는 경우)를 식별합니다. Unix 시스템에서이 상태 값은&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="f75f87bdfa0eb35c4f5fe0a1642de1f3532d7289" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;values&lt;/b&gt; you supply along with a program name when you tell a &lt;b&gt;shell&lt;/b&gt; to execute a &lt;b&gt;command&lt;/b&gt;. These values are passed to a Perl program through &lt;code&gt;@ARGV&lt;/code&gt; .</source>
          <target state="translated">&lt;b&gt;쉘&lt;/b&gt; 에게 &lt;b&gt;명령&lt;/b&gt; 을 실행하도록 지시 할 때 프로그램 이름과 함께 제공 하는 &lt;b&gt;값&lt;/b&gt; . 이 값은 &lt;code&gt;@ARGV&lt;/code&gt; 를 통해 Perl 프로그램으로 전달됩니다 .&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="41ad86c2a0eef157efad4b1818e0188a3bba4d01" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;values&lt;/b&gt; you supply along with a program name when you tell a &lt;b&gt;shell&lt;/b&gt; to execute a &lt;b&gt;command&lt;/b&gt;. These values are passed to a Perl program through &lt;code&gt;@ARGV&lt;/code&gt;.</source>
          <target state="translated">&lt;b&gt;명령&lt;/b&gt; 을 실행하도록 &lt;b&gt;쉘에&lt;/b&gt; 지시 할 때 프로그램 이름과 함께 제공 하는 &lt;b&gt;값&lt;/b&gt; . 이러한 값은 &lt;code&gt;@ARGV&lt;/code&gt; 를 통해 Perl 프로그램에 전달됩니다 .&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="8215a7b783f151c4ff06cfd84ff859eb48442e77" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;word anchor&lt;/b&gt;&lt;code&gt;\b&lt;/code&gt; matches a boundary between a word character and a non-word character &lt;code&gt;\w\W&lt;/code&gt; or &lt;code&gt;\W\w&lt;/code&gt; :</source>
          <target state="translated">&lt;b&gt;워드 앵커 &lt;/b&gt; &lt;code&gt;\b&lt;/code&gt; 단어의 문자와 비 문자 단어의 경계와 일치 &lt;code&gt;\w\W&lt;/code&gt; 또는 &lt;code&gt;\W\w&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="e0d33c43c6614d46185d88549fdc18a2c8537ffc" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;word anchor&lt;/b&gt;&lt;code&gt;\b&lt;/code&gt; matches a boundary between a word character and a non-word character &lt;code&gt;\w\W&lt;/code&gt; or &lt;code&gt;\W\w&lt;/code&gt;:</source>
          <target state="translated">&lt;b&gt;워드 앵커 &lt;/b&gt; &lt;code&gt;\b&lt;/code&gt; 단어의 문자와 비 문자 단어의 경계와 일치 &lt;code&gt;\w\W&lt;/code&gt; 또는 &lt;code&gt;\W\w&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="98df2a206a33c61c05323edbf28b990dfe8bb9b6" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;xsubpp&lt;/b&gt; program takes the XS code in the .xs file and translates it into C code, placing it in a file whose suffix is .c. The C code created makes heavy use of the C functions within Perl.</source>
          <target state="translated">&lt;b&gt;은 xsubpp&lt;/b&gt; 프로그램 .xs 파일의 XS 코드를 취하고, 그 접미어가 .c 인 파일에 배치하는, C 코드로 변환한다. 작성된 C 코드는 Perl 내에서 C 함수를 많이 사용합니다.</target>
        </trans-unit>
        <trans-unit id="e9db711485ba959f3d0b453c931365b6638809a5" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;xsubpp&lt;/b&gt; program uses rules to convert from Perl's data types (scalar, array, etc.) to C's data types (int, char, etc.). These rules are stored in the typemap file ($PERLLIB/ExtUtils/typemap). There's a brief discussion below, but all the nitty-gritty details can be found in &lt;a href=&quot;perlxstypemap&quot;&gt;perlxstypemap&lt;/a&gt;. If you have a new-enough version of perl (5.16 and up) or an upgraded XS compiler (&lt;code&gt;ExtUtils::ParseXS&lt;/code&gt; 3.13_01 or better), then you can inline typemaps in your XS instead of writing separate files. Either way, this typemap thing is split into three parts:</source>
          <target state="translated">&lt;b&gt;은 xsubpp&lt;/b&gt; 펄의 데이터 타입 C의 데이터 유형 (INT, 문자 등) (스칼라, 배열 등)로 변환하는 프로그램을 사용하는 규칙. 이 규칙은 타입 맵 파일 ($ PERLLIB / ExtUtils / typemap)에 저장됩니다. 아래에 간단한 설명이 있지만, 모든 세부 사항은 &lt;a href=&quot;perlxstypemap&quot;&gt;perlxstypemap&lt;/a&gt; 에서 찾을 수 있습니다 . 충분히 새로운 버전의 perl (5.16 이상) 또는 업그레이드 된 XS 컴파일러 ( &lt;code&gt;ExtUtils::ParseXS&lt;/code&gt; 3.13_01 이상)가있는 경우 별도의 파일을 작성하는 대신 XS에서 유형 맵을 인라인 할 수 있습니다. 어느 쪽이든,이 유형 맵은 세 부분으로 나뉩니다.</target>
        </trans-unit>
        <trans-unit id="1082cc04157e373604ca98ab1606eeb58e2bd5d9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt; $output &lt;/code&gt; argument may be:</source>
          <target state="translated">&lt;code&gt; $output &lt;/code&gt; 인수는있을 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="fe02d79593918e0f0b57f9efa92b9388e3573b1e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&quot;)&quot;&lt;/code&gt; is out-of-place. Something apparently was supposed to be combined with the digits, or the &lt;code&gt;&quot;+&quot;&lt;/code&gt; shouldn't be there, or something like that. Perl can't figure out what was intended.</source>
          <target state="translated">은 &lt;code&gt;&quot;)&quot;&lt;/code&gt; 밖으로의 장소입니다. 분명히 숫자와 숫자가 결합되어 있거나 &lt;code&gt;&quot;+&quot;&lt;/code&gt; 가 없어야합니다. 펄은 의도 한 것을 알 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="b82e89101d474c0486e6c08a915553c14b105df6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&quot;*&quot;&lt;/code&gt; quantifier is equivalent to &lt;code&gt;{0,}&lt;/code&gt;, the &lt;code&gt;&quot;+&quot;&lt;/code&gt; quantifier to &lt;code&gt;{1,}&lt;/code&gt;, and the &lt;code&gt;&quot;?&quot;&lt;/code&gt; quantifier to &lt;code&gt;{0,1}&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&quot;*&quot;&lt;/code&gt; 에 해당 정량 &lt;code&gt;{0,}&lt;/code&gt; 는 &lt;code&gt;&quot;+&quot;&lt;/code&gt; 로 정량 &lt;code&gt;{1,}&lt;/code&gt; 과 &lt;code&gt;&quot;?&quot;&lt;/code&gt; 수량자를 &lt;code&gt;{0,1}&lt;/code&gt; 로 변경 합니다.</target>
        </trans-unit>
        <trans-unit id="74bbd851b5114dd4dbacbd6abc257c5bbd630765" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&quot;+&quot;&lt;/code&gt; is valid only when followed by digits, indicating a capturing group. See &lt;a href=&quot;perlre#%28%3FPARNO%29-%28%3F-PARNO%29-%28%3F%2BPARNO%29-%28%3FR%29-%28%3F0%29&quot;&gt;&lt;code&gt;(?&lt;i&gt;PARNO&lt;/i&gt;)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">는 &lt;code&gt;&quot;+&quot;&lt;/code&gt; 는 캡처 그룹을 나타내는 숫자 뒤에 때만 유효하다. &lt;a href=&quot;perlre#%28%3FPARNO%29-%28%3F-PARNO%29-%28%3F%2BPARNO%29-%28%3FR%29-%28%3F0%29&quot;&gt; &lt;code&gt;(?&lt;i&gt;PARNO&lt;/i&gt;)&lt;/code&gt; &lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="54034a923125cadab60eef06f26fcb91d4e7c351" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&quot;+&quot;&lt;/code&gt; is valid only when followed by digits, indicating a capturing group. See &lt;a href=&quot;perlre#(%3fPARNO)-(%3f-PARNO)-(%3f%2bPARNO)-(%3fR)-(%3f0)&quot;&gt;(?PARNO)&lt;/a&gt;.</source>
          <target state="translated">는 &lt;code&gt;&quot;+&quot;&lt;/code&gt; 는 캡처 그룹을 나타내는 숫자 뒤에 때만 유효하다. &lt;a href=&quot;perlre#(%3fPARNO)-(%3f-PARNO)-(%3f%2bPARNO)-(%3fR)-(%3f0)&quot;&gt;(? PARNO)를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="07bb712ac114a7fe219229eb5a67b484b3ca58ea" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&quot;?&quot;&lt;/code&gt; and &lt;code&gt;&quot;+&quot;&lt;/code&gt; don't have any effect, as they modify whether to match more or fewer when there is a choice, and by specifying to match exactly a given numer, there is no room left for a choice.</source>
          <target state="translated">&lt;code&gt;&quot;?&quot;&lt;/code&gt; 그리고 &lt;code&gt;&quot;+&quot;&lt;/code&gt; 가 더 많거나 적은 선택의 여지가있을 때, 정확하게 주어진 numer에 맞게 지정하여 일치 여부를 수정하면, 어떤 영향이없는, 선택의 여지 떠났다 여지가 없다.</target>
        </trans-unit>
        <trans-unit id="622f5262d7227133a18718033006d1fe595c3150" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&quot;U&quot;&lt;/code&gt; template has been ported to mean &quot;Unicode&quot; on all platforms so that</source>
          <target state="translated">&lt;code&gt;&quot;U&quot;&lt;/code&gt; 템플릿은 그래서 모든 플랫폼에서 &quot;유니 코드&quot;를 의미하는 포팅되었다</target>
        </trans-unit>
        <trans-unit id="d9a4c62629e10d33b540e16fc1ce8f7a3f41635f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&quot;\x&quot;&lt;/code&gt; construct without curly braces should be followed by exactly two hex digits; this one is followed by three. This currently evaluates as equivalent to</source>
          <target state="translated">&lt;code&gt;&quot;\x&quot;&lt;/code&gt; 괄호가없는 구조는 정확히 두 개의 16 진수 와야; 이 뒤에는 세 개가 있습니다. 이것은 현재</target>
        </trans-unit>
        <trans-unit id="18a8e19a030c3c8f53e48396122990cc28295c5e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&quot;a&quot;&lt;/code&gt; is a valid modifier flag, but the &lt;code&gt;&quot;n&quot;&lt;/code&gt; is not, and raises this error. Likely what was meant instead was:</source>
          <target state="translated">는 &lt;code&gt;&quot;a&quot;&lt;/code&gt; 는 유효한 수정 플래그이지만, &lt;code&gt;&quot;n&quot;&lt;/code&gt; 아니며,이 오류를 발생시킵니다. 아마도 그 의미는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="14e2e8dae7c922be26733e3e660b25612cc5ce26" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&quot;c&quot;&lt;/code&gt; and &lt;code&gt;&quot;C&quot;&lt;/code&gt; templates for &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack()&lt;/a&gt;&lt;/code&gt; are dependent upon character set encoding. Examples of usage on EBCDIC include:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack()&lt;/a&gt;&lt;/code&gt; 의 &lt;code&gt;&quot;c&quot;&lt;/code&gt; 및 &lt;code&gt;&quot;C&quot;&lt;/code&gt; 템플릿은 문자 집합 인코딩에 따라 다릅니다. EBCDIC에서의 사용 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3a90b3cf3b7660a315d348d508a144827f3fa53e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&quot;c&quot;&lt;/code&gt; and &lt;code&gt;&quot;C&quot;&lt;/code&gt; templates for &lt;code&gt;pack()&lt;/code&gt; are dependent upon character set encoding. Examples of usage on EBCDIC include:</source>
          <target state="translated">&lt;code&gt;pack()&lt;/code&gt; 의 &lt;code&gt;&quot;c&quot;&lt;/code&gt; 및 &lt;code&gt;&quot;C&quot;&lt;/code&gt; 템플릿은 문자 집합 인코딩에 따라 다릅니다. EBCDIC에서의 사용 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5c8f5308cfb898e8f57b9a7b021b28f517778138" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&quot;code&quot;&lt;/code&gt; subroutine will only be used to filter parts of the source code that are not quotelikes, POD, or &lt;code&gt;__DATA__&lt;/code&gt; . The &lt;code&gt;quotelike&lt;/code&gt; subroutine only filters Perl quotelikes (including here documents).</source>
          <target state="translated">&lt;code&gt;&quot;code&quot;&lt;/code&gt; 서브 루틴은 quotelikes, POD 또는없는 소스 코드의 필터 부에 사용될 &lt;code&gt;__DATA__&lt;/code&gt; . &lt;code&gt;quotelike&lt;/code&gt; 의 서브 루틴은 (여기 문서를 포함) 펄 quotelikes를 필터링합니다.</target>
        </trans-unit>
        <trans-unit id="00d33c98d86ed179e5a669f2bc40830325b6bdf3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&quot;code&quot;&lt;/code&gt; subroutine will only be used to filter parts of the source code that are not quotelikes, POD, or &lt;code&gt;__DATA__&lt;/code&gt;. The &lt;code&gt;quotelike&lt;/code&gt; subroutine only filters Perl quotelikes (including here documents).</source>
          <target state="translated">&lt;code&gt;&quot;code&quot;&lt;/code&gt; 서브 루틴은 quotelikes, POD 또는없는 소스 코드의 필터 부에 사용될 &lt;code&gt;__DATA__&lt;/code&gt; . &lt;code&gt;quotelike&lt;/code&gt; 의 서브 루틴은 (여기 문서를 포함) 펄 quotelikes를 필터링합니다.</target>
        </trans-unit>
        <trans-unit id="de5cb8ed1d57c1871e5453eb580a0076b635dfd4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&quot;use locale&quot;&lt;/code&gt; pragma</source>
          <target state="translated">&lt;code&gt;&quot;use locale&quot;&lt;/code&gt; 프라 그마</target>
        </trans-unit>
        <trans-unit id="9e55a545076df6df5f2e5f8da5ca2fba9b8a556b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;#!&lt;/code&gt; line is always examined for switches as the line is being parsed. Thus, if you're on a machine that allows only one argument with the &lt;code&gt;#!&lt;/code&gt; line, or worse, doesn't even recognize the &lt;code&gt;#!&lt;/code&gt; line, you still can get consistent switch behaviour regardless of how Perl was invoked, even if &lt;a href=&quot;#-x&quot;&gt;&quot;-x&quot;&lt;/a&gt; was used to find the beginning of the program.</source>
          <target state="translated">&lt;code&gt;#!&lt;/code&gt; 라인이 구문 분석 될 때 항상 스위치가 있는지 라인을 검사합니다. 따라서 &lt;code&gt;#!&lt;/code&gt; 라인 또는 더 나쁜 것은 &lt;code&gt;#!&lt;/code&gt; 행에서 &lt;a href=&quot;#-x&quot;&gt;&quot;-x&quot;&lt;/a&gt; 를 사용하여 프로그램의 시작을 찾는 경우에도 Perl이 호출 된 방법에 관계없이 일관된 스위치 동작을 얻을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5361c21bc61e8999f4b7544ffeef33e12b0b1a2e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;#!&lt;/code&gt; line is always examined for switches as the line is being parsed. Thus, if you're on a machine that allows only one argument with the &lt;code&gt;#!&lt;/code&gt; line, or worse, doesn't even recognize the &lt;code&gt;#!&lt;/code&gt; line, you still can get consistent switch behaviour regardless of how Perl was invoked, even if &lt;b&gt;-x&lt;/b&gt; was used to find the beginning of the program.</source>
          <target state="translated">&lt;code&gt;#!&lt;/code&gt; 라인을 구문 분석 할 때 스위치는 항상 라인을 검사합니다. 따라서 컴퓨터에서 &lt;code&gt;#!&lt;/code&gt; 으로 하나의 인수 만 허용하는 경우 ! 줄 또는 더 나쁜 것은 &lt;code&gt;#!&lt;/code&gt; 조차 인식하지 못합니다 ! &lt;b&gt;-x&lt;/b&gt; 를 사용하여 프로그램의 시작 부분을 찾 더라도 Perl의 호출 방식에 관계없이 일관된 스위치 동작을 얻을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="108405af164a595d0a02e5242d4aac5c7a9939f2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$OLD_PERL_VERSION&lt;/code&gt; form was added in Perl v5.20.0 for historical reasons but its use is discouraged. (If your reason to use &lt;code&gt;$]&lt;/code&gt; is to run code on old perls then referring to it as &lt;code&gt;$OLD_PERL_VERSION&lt;/code&gt; would be self-defeating.)</source>
          <target state="translated">&lt;code&gt;$OLD_PERL_VERSION&lt;/code&gt; 형태는 역사적 이유 펄 v5.20.0에서 추가되었다 그러나 그것의 사용은 권장되지 않습니다. ( &lt;code&gt;$]&lt;/code&gt; 을 사용하는 이유가 이전 &lt;code&gt;$OLD_PERL_VERSION&lt;/code&gt; 에서 코드를 실행하는 것이라면 $ OLD_PERL_VERSION 으로 참조하면 자멸 할 수 있습니다.)</target>
        </trans-unit>
        <trans-unit id="9a8b854056feda55458ac395207c0edacf4109d4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$SIG{__DIE__}&lt;/code&gt; doesn't support &lt;code&gt;'IGNORE'&lt;/code&gt;; it has the same effect as &lt;code&gt;'DEFAULT'&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;$SIG{__DIE__}&lt;/code&gt; 지원하지 않습니다는 &lt;code&gt;'IGNORE'&lt;/code&gt; ; &lt;code&gt;'DEFAULT'&lt;/code&gt; 와 동일한 효과가 있습니다.</target>
        </trans-unit>
        <trans-unit id="06cfb8f268bdf180a533e3982943c594a32d2955" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$SIG{__DIE__}&lt;/code&gt; hook is called even inside an &lt;code&gt;eval()&lt;/code&gt;. It was never intended to happen this way, but an implementation glitch made this possible. This used to be deprecated, as it allowed strange action at a distance like rewriting a pending exception in &lt;code&gt;$@&lt;/code&gt;. Plans to rectify this have been scrapped, as users found that rewriting a pending exception is actually a useful feature, and not a bug.</source>
          <target state="translated">&lt;code&gt;$SIG{__DIE__}&lt;/code&gt; 후크는 심지어 내부이라고 &lt;code&gt;eval()&lt;/code&gt; . 이런 식으로 발생하도록 의도 된 것은 아니지만 구현 결함으로 인해 가능해졌습니다. 이것은 &lt;code&gt;$@&lt;/code&gt; 에서 보류중인 예외를 다시 작성하는 것과 같은 거리에서 이상한 동작을 허용했기 때문에 더 이상 사용되지 않았습니다 . 사용자가 보류중인 예외를 다시 작성하는 것이 실제로 버그가 아니라 유용한 기능이라는 사실을 알게되면서이를 수정하려는 계획은 폐기되었습니다.</target>
        </trans-unit>
        <trans-unit id="4fb2868e39025eacf0d00ec1478ba8ee01a99e7d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$VERSION&lt;/code&gt; variable is used to ensure that the .pm file and the shared library are &quot;in sync&quot; with each other. Any time you make changes to the .pm or .xs files, you should increment the value of this variable.</source>
          <target state="translated">&lt;code&gt;$VERSION&lt;/code&gt; 변수는가 .pm 파일과 공유 라이브러리가 서로 &quot;동기화&quot;되어 있는지 확인하는 데 사용됩니다. .pm 또는 .xs 파일을 변경할 때마다이 변수의 값을 증가시켜야합니다.</target>
        </trans-unit>
        <trans-unit id="2ee72eb90ddce6bbc0931d4e233b1341c5327087" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$^O&lt;/code&gt; variable (&lt;code&gt;$OSNAME&lt;/code&gt; if you use &lt;code&gt;English&lt;/code&gt; ) contains an indication of the name of the operating system (not its release number) that your perl binary was built for.</source>
          <target state="translated">&lt;code&gt;$^O&lt;/code&gt; 변수 ( &lt;code&gt;$OSNAME&lt;/code&gt; 당신이 사용하는 경우 &lt;code&gt;English&lt;/code&gt; ) 펄 바이너리을 위해 만들어진하는 운영 체제 (하지의 릴리스 번호)의 이름의 표시를 포함하고 있습니다.</target>
        </trans-unit>
        <trans-unit id="3c4fecf66108e7576d4b50d6bd4010c1a13f5ea1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$^O&lt;/code&gt; variable (&lt;code&gt;$OSNAME&lt;/code&gt; if you use &lt;code&gt;English&lt;/code&gt;) contains an indication of the name of the operating system (not its release number) that your perl binary was built for.</source>
          <target state="translated">&lt;code&gt;$^O&lt;/code&gt; 변수 ( &lt;code&gt;$OSNAME&lt;/code&gt; 당신이 사용하는 경우 &lt;code&gt;English&lt;/code&gt; ) 펄 바이너리을 위해 만들어진하는 운영 체제 (하지의 릴리스 번호)의 이름의 표시를 포함하고 있습니다.</target>
        </trans-unit>
        <trans-unit id="d2aab00569329bab82f1ebc14faa8b668168dc31" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$^O&lt;/code&gt; variable and the &lt;code&gt;$Config{archname}&lt;/code&gt; values for various DOSish perls are as follows:</source>
          <target state="translated">&lt;code&gt;$^O&lt;/code&gt; 변수와 &lt;code&gt;$Config{archname}&lt;/code&gt; 다양한 DOSish perls의 값은 다음이다 :</target>
        </trans-unit>
        <trans-unit id="eba7fdbb831c55f9a441c12e1806775b9e1de0a0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$array[1]&lt;/code&gt; is a single-element access to the array. It's going to return the item in index 1 (or undef if there is no item there). If you intend to get exactly one element from the array, this is the form you should use.</source>
          <target state="translated">&lt;code&gt;$array[1]&lt;/code&gt; 배열에 단일 요소의 액세스이다. 인덱스 1의 항목을 반환합니다 (또는 항목이 없으면 undef). 배열에서 정확히 하나의 요소를 가져 오려면 사용해야하는 형식입니다.</target>
        </trans-unit>
        <trans-unit id="2844c7d661123084d4f84dec0ab13e6bfc03da52" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$buffer&lt;/code&gt; parameter can either be a scalar or a scalar reference.</source>
          <target state="translated">&lt;code&gt;$buffer&lt;/code&gt; 파라미터 중 스칼라 또는 스칼라 참조 할 수있다.</target>
        </trans-unit>
        <trans-unit id="27274181277155f678e99b9a2b287e41860c82ca" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$buffer&lt;/code&gt; parameter can either be a scalar or a scalar reference. The contents of the &lt;code&gt;$buffer&lt;/code&gt; parameter are destroyed after calling this function.</source>
          <target state="translated">&lt;code&gt;$buffer&lt;/code&gt; 파라미터 중 스칼라 또는 스칼라 참조 할 수있다. 이 함수를 호출 하면 &lt;code&gt;$buffer&lt;/code&gt; 매개 변수 의 내용 이 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="8c4fb1959a7d1bef1019739dc5a4ea212bbc1a3d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$buffer&lt;/code&gt; parameter is modified by &lt;code&gt;inflate&lt;/code&gt; . On completion it will contain what remains of the input buffer after inflation. This means that &lt;code&gt;$buffer&lt;/code&gt; will be an empty string when the return status is &lt;code&gt;Z_OK&lt;/code&gt; . When the return status is &lt;code&gt;Z_STREAM_END&lt;/code&gt; the &lt;code&gt;$buffer&lt;/code&gt; parameter will contains what (if anything) was stored in the input buffer after the deflated data stream.</source>
          <target state="translated">&lt;code&gt;$buffer&lt;/code&gt; 파라미터에 의해 수정된다 &lt;code&gt;inflate&lt;/code&gt; . 완료되면 인플레이션 후 입력 버퍼에 남아있는 내용이 포함됩니다. 이것은 반환 상태가 &lt;code&gt;Z_OK&lt;/code&gt; 일 때 &lt;code&gt;$buffer&lt;/code&gt; 가 빈 문자열 이됨을 의미합니다 . 리턴 상태가 &lt;code&gt;Z_STREAM_END&lt;/code&gt; 인 경우 &lt;code&gt;$buffer&lt;/code&gt; 매개 변수는 수축 된 데이터 스트림 후 입력 버퍼에 저장된 것이 무엇이든 포함합니다.</target>
        </trans-unit>
        <trans-unit id="735065db643a224d7abc76057afb08424a7f97a0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$buffer&lt;/code&gt; parameter is modified by &lt;code&gt;inflate&lt;/code&gt;. On completion it will contain what remains of the input buffer after inflation. This means that &lt;code&gt;$buffer&lt;/code&gt; will be an empty string when the return status is &lt;code&gt;Z_OK&lt;/code&gt;. When the return status is &lt;code&gt;Z_STREAM_END&lt;/code&gt; the &lt;code&gt;$buffer&lt;/code&gt; parameter will contains what (if anything) was stored in the input buffer after the deflated data stream.</source>
          <target state="translated">&lt;code&gt;$buffer&lt;/code&gt; 파라미터에 의해 수정된다 &lt;code&gt;inflate&lt;/code&gt; . 완료되면 인플레이션 후 입력 버퍼의 나머지 부분이 포함됩니다. 이것은 반환 상태가 &lt;code&gt;Z_OK&lt;/code&gt; 일 때 &lt;code&gt;$buffer&lt;/code&gt; 가 빈 문자열 이됨을 의미합니다 . 반환 상태가 &lt;code&gt;Z_STREAM_END&lt;/code&gt; 일 때 &lt;code&gt;$buffer&lt;/code&gt; 매개 변수는 수축 된 데이터 스트림 이후에 입력 버퍼에 저장된 내용 (있는 경우)을 포함합니다.</target>
        </trans-unit>
        <trans-unit id="4dd78ddf95d786af083e0413cd47b10ceef529f1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$context&lt;/code&gt; passed in will be an instance of &lt;a href=&quot;Test2::API::Context&quot;&gt;Test2::API::Context&lt;/a&gt;. The &lt;code&gt;$exit&lt;/code&gt; argument will be the original exit code before anything modified it. &lt;code&gt;$$new_exit&lt;/code&gt; is a reference to the new exit code. You may modify this to change the exit code. Please note that &lt;code&gt;$$new_exit&lt;/code&gt; may already be different from &lt;code&gt;$exit&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;$context&lt;/code&gt; 전달은의 인스턴스가 될 것입니다 &lt;a href=&quot;Test2::API::Context&quot;&gt;Test2를 :: API :: 문맥&lt;/a&gt; . &lt;code&gt;$exit&lt;/code&gt; 아무것도를 수정하기 전에 인수는 원래의 종료 코드가 될 것입니다. &lt;code&gt;$$new_exit&lt;/code&gt; 는 새 종료 코드에 대한 참조입니다. 이를 수정하여 종료 코드를 변경할 수 있습니다. 참고하시기 바랍니다 &lt;code&gt;$$new_exit&lt;/code&gt; 이미 다를 수 있습니다 &lt;code&gt;$exit&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d1f084c43da0252a420f089c62656f2a4438958f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$description&lt;/code&gt; is usually a test file name (but only by convention.) It is used as a unique identifier (see e.g. &lt;a href=&quot;#parsers&quot;&gt;&quot;parsers&quot;&lt;/a&gt;.) Reusing a description is a fatal error.</source>
          <target state="translated">&lt;code&gt;$description&lt;/code&gt; (하지만 관례.) 그것은 (예를 들어, 참조 고유 식별자로 사용되는 보통 테스트 파일 이름입니다 &lt;a href=&quot;#parsers&quot;&gt;&quot;파서를&quot;&lt;/a&gt; 설명을 재사용하는 것은 치명적인 오류입니다.).</target>
        </trans-unit>
        <trans-unit id="4deaa69228d0bed93aa2331246fd160457f98868" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$description&lt;/code&gt; is usually a test file name (but only by convention.) It is used as a unique identifier (see e.g. &lt;a href=&quot;#parsers&quot;&gt;parsers&lt;/a&gt;.) Reusing a description is a fatal error.</source>
          <target state="translated">&lt;code&gt;$description&lt;/code&gt; (하지만 관례.) 그것은 (예를 들어, 참조 고유 식별자로 사용되는 보통 테스트 파일 이름 &lt;a href=&quot;#parsers&quot;&gt;파서를&lt;/a&gt; 설명을 재사용하는 것은 치명적인 오류입니다.).</target>
        </trans-unit>
        <trans-unit id="04558cf60bc9c7167d85368eb6635a2473770d4f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$eof&lt;/code&gt; parameter needs a bit of explanation.</source>
          <target state="translated">&lt;code&gt;$eof&lt;/code&gt; 매개 변수는 약간의 설명이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="65f92aaac6b66cd674844396e8d45e3f370fce50" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$eof&lt;/code&gt; parameter only needs to be used if &lt;b&gt;all&lt;/b&gt; of the following conditions apply</source>
          <target state="translated">&lt;code&gt;$eof&lt;/code&gt; 매개 변수는 경우에만 사용 할 필요가 &lt;b&gt;모든&lt;/b&gt; 다음과 같은 조건이 적용</target>
        </trans-unit>
        <trans-unit id="8a410599f21ede34ce0c4e99388bf1aa3ff8199e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$gzerrno&lt;/code&gt; scalar holds the error code associated with the most recent</source>
          <target state="translated">&lt;code&gt;$gzerrno&lt;/code&gt; 스칼라는 가장 최근에 관련된 에러 코드를 보유하고</target>
        </trans-unit>
        <trans-unit id="6264c4349310ae2e82ed9dccab08bd7526a285d2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$in_fh&lt;/code&gt; parameter may be any object that provides a &lt;b&gt;getline()&lt;/b&gt; method to retrieve a single line of input text (hence, an appropriate wrapper object could be used to parse PODs from a single string or an array of strings).</source>
          <target state="translated">&lt;code&gt;$in_fh&lt;/code&gt; 파라미터가 제공하는 임의의 개체 일 수있다 &lt;b&gt;의 getline ()&lt;/b&gt; 입력 한 줄의 텍스트를 검색하는 방법 (따라서, 적절한 래퍼 객체는 단일 문자열 또는 문자열 배열로 해석 포드에 사용될 수있다).</target>
        </trans-unit>
        <trans-unit id="e89b34e9c40c9e18afebc88c2be1c3150fecd52e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$input&lt;/code&gt; and &lt;code&gt;$output&lt;/code&gt; parameters can be either scalars or scalar references.</source>
          <target state="translated">&lt;code&gt;$input&lt;/code&gt; 및 &lt;code&gt;$output&lt;/code&gt; 매개 변수는 스칼라 또는 스칼라 참조 중 하나가 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d5ad245702c5052688f1d153e2fbd703e2f8f301" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$input_filename_or_reference&lt;/code&gt; parameter</source>
          <target state="translated">&lt;code&gt;$input_filename_or_reference&lt;/code&gt; 매개 변수</target>
        </trans-unit>
        <trans-unit id="daa9f5f9a1ef279c49e625124d1e76146ad5e7d8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$level&lt;/code&gt; parameter defines the compression level. Valid values are 0 through 9, &lt;code&gt;Z_NO_COMPRESSION&lt;/code&gt; , &lt;code&gt;Z_BEST_SPEED&lt;/code&gt; , &lt;code&gt;Z_BEST_COMPRESSION&lt;/code&gt; , and &lt;code&gt;Z_DEFAULT_COMPRESSION&lt;/code&gt; . If &lt;code&gt;$level&lt;/code&gt; is not specified &lt;code&gt;Z_DEFAULT_COMPRESSION&lt;/code&gt; will be used.</source>
          <target state="translated">&lt;code&gt;$level&lt;/code&gt; 매개 변수는 압축 수준을 정의합니다. 유효한 값은 0-9, &lt;code&gt;Z_NO_COMPRESSION&lt;/code&gt; , &lt;code&gt;Z_BEST_SPEED&lt;/code&gt; , &lt;code&gt;Z_BEST_COMPRESSION&lt;/code&gt; 및 &lt;code&gt;Z_DEFAULT_COMPRESSION&lt;/code&gt; 입니다. 경우 &lt;code&gt;$level&lt;/code&gt; 지정되지 않은 &lt;code&gt;Z_DEFAULT_COMPRESSION&lt;/code&gt; 이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="898131faa0f3e8f99a6d077f4bd62a3c78ce8ae9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$level&lt;/code&gt; parameter defines the compression level. Valid values are 0 through 9, &lt;code&gt;Z_NO_COMPRESSION&lt;/code&gt;, &lt;code&gt;Z_BEST_SPEED&lt;/code&gt;, &lt;code&gt;Z_BEST_COMPRESSION&lt;/code&gt;, and &lt;code&gt;Z_DEFAULT_COMPRESSION&lt;/code&gt;. If &lt;code&gt;$level&lt;/code&gt; is not specified &lt;code&gt;Z_DEFAULT_COMPRESSION&lt;/code&gt; will be used.</source>
          <target state="translated">&lt;code&gt;$level&lt;/code&gt; 매개 변수는 압축 수준을 정의합니다. 유효한 값은 0-9, &lt;code&gt;Z_NO_COMPRESSION&lt;/code&gt; , &lt;code&gt;Z_BEST_SPEED&lt;/code&gt; , &lt;code&gt;Z_BEST_COMPRESSION&lt;/code&gt; 및 &lt;code&gt;Z_DEFAULT_COMPRESSION&lt;/code&gt; 입니다. 경우 &lt;code&gt;$level&lt;/code&gt; 지정되지 않은 &lt;code&gt;Z_DEFAULT_COMPRESSION&lt;/code&gt; 이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="cb33cd5cc665b9c3bd624d64f0ec40381e42cbac" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$mon&lt;/code&gt; is zero-based: January equals &lt;code&gt;0&lt;/code&gt; . The &lt;code&gt;$year&lt;/code&gt; is 1900-based: 2001 equals &lt;code&gt;101&lt;/code&gt; . &lt;code&gt;$wday&lt;/code&gt; and &lt;code&gt;$yday&lt;/code&gt; default to zero (and are usually ignored anyway), and &lt;code&gt;$isdst&lt;/code&gt; defaults to -1.</source>
          <target state="translated">&lt;code&gt;$mon&lt;/code&gt; 0을 기준으로 1 월 같음 &lt;code&gt;0&lt;/code&gt; . &lt;code&gt;$year&lt;/code&gt; 1900 기반 : 2001과 동일 &lt;code&gt;101&lt;/code&gt; . &lt;code&gt;$wday&lt;/code&gt; 및 &lt;code&gt;$yday&lt;/code&gt; 기본값은 0이며 일반적으로 무시 됩니다. &lt;code&gt;$isdst&lt;/code&gt; 기본값은 -1입니다.</target>
        </trans-unit>
        <trans-unit id="7421dc164fd8281f20128cde64ce3b745047d3c0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$mon&lt;/code&gt; is zero-based: January equals &lt;code&gt;0&lt;/code&gt;. The &lt;code&gt;$year&lt;/code&gt; is 1900-based: 2001 equals &lt;code&gt;101&lt;/code&gt;. &lt;code&gt;$wday&lt;/code&gt; and &lt;code&gt;$yday&lt;/code&gt; default to zero (and are usually ignored anyway), and &lt;code&gt;$isdst&lt;/code&gt; defaults to -1.</source>
          <target state="translated">&lt;code&gt;$mon&lt;/code&gt; 0을 기준으로 1 월 같음 &lt;code&gt;0&lt;/code&gt; . &lt;code&gt;$year&lt;/code&gt; 1900 기반 : 2001과 동일 &lt;code&gt;101&lt;/code&gt; . &lt;code&gt;$wday&lt;/code&gt; 및 &lt;code&gt;$yday&lt;/code&gt; 기본값은 0 (일반적으로 무시 됨)이며 &lt;code&gt;$isdst&lt;/code&gt; 기본값은 -1입니다.</target>
        </trans-unit>
        <trans-unit id="23cd0f7ae4d6af5b92c0f4a1db509d798cb0ac59" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$name&lt;/code&gt; variable should be the key used to access the facet in a facets hashref. For instance the assertion facet has the key 'assert', the information facet has the 'info' key, and the error facet has the key 'errors'. You may include or omit the 's' at the end of the name, the method is smart enough to try both the 's' and no-'s' forms, it will check what you provided first, and if that is not found it will add or strip the 's and try again.</source>
          <target state="translated">&lt;code&gt;$name&lt;/code&gt; 변수는면의 hashref의면에 액세스하는 데 사용되는 키이어야한다. 예를 들어 어설 션 패싯에는 'assert'키가 있고 정보 패싯에는 'info'키가 있으며 오류 패싯에는 'errors'키가 있습니다. 이름 끝에 's'를 포함하거나 생략 할 수 있습니다.이 방법은 's'및 no-'s 양식을 모두 시도 할 수있을만큼 똑똑하며 먼저 제공 한 내용을 확인하고 찾을 수없는 경우 를 추가하거나 제거하고 다시 시도합니다.</target>
        </trans-unit>
        <trans-unit id="d866868676edf3ef0ef337619cbb9d7d463b060f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$output_filename_or_reference&lt;/code&gt; parameter</source>
          <target state="translated">&lt;code&gt;$output_filename_or_reference&lt;/code&gt; 매개 변수</target>
        </trans-unit>
        <trans-unit id="c96d672905fea90a5656f24eb9f7936742884276" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$parser&lt;/code&gt; is a &lt;a href=&quot;../parser&quot;&gt;TAP::Parser&lt;/a&gt; object.</source>
          <target state="translated">&lt;code&gt;$parser&lt;/code&gt; A는 &lt;a href=&quot;../parser&quot;&gt;TAP :: 파서&lt;/a&gt; 객체입니다.</target>
        </trans-unit>
        <trans-unit id="6143cd77ebc527cea165f0db3248c326b91b9c6e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$parser&lt;/code&gt; is a &lt;a href=&quot;TAP::Parser&quot;&gt;TAP::Parser&lt;/a&gt; object.</source>
          <target state="translated">&lt;code&gt;$parser&lt;/code&gt; A는 &lt;a href=&quot;TAP::Parser&quot;&gt;TAP :: 파서&lt;/a&gt; 객체입니다.</target>
        </trans-unit>
        <trans-unit id="0cde3685cee91824cf2720ce6f47ce3c1655541a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$tabstop&lt;/code&gt; variable controls how many column positions apart each tabstop is. The default is 8.</source>
          <target state="translated">&lt;code&gt;$tabstop&lt;/code&gt; 변수 컨트롤 각 탭 위치는 얼마나 많은 열 위치입니다 따로 따로. 기본값은 8입니다.</target>
        </trans-unit>
        <trans-unit id="07507ab596d7a55a579157466578b8c289c17f57" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$whence&lt;/code&gt; parameter should be one of SEEK_SET, SEEK_CUR or SEEK_END.</source>
          <target state="translated">&lt;code&gt;$whence&lt;/code&gt; 매개 변수는 SEEK_SET, SEEK_CUR 또는 SEEK_END 중 하나 여야합니다.</target>
        </trans-unit>
        <trans-unit id="78200cc1ea59e994c5d2418e77df8c6e8fa8185d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$whence&lt;/code&gt; parameter takes one the usual values, namely SEEK_SET, SEEK_CUR or SEEK_END.</source>
          <target state="translated">&lt;code&gt;$whence&lt;/code&gt; 매개 변수는 하나 개의 일반적인 값, 즉 SEEK_SET, SEEK_CUR 또는 SEEK_END 걸립니다.</target>
        </trans-unit>
        <trans-unit id="d36c42de8f17d5532305a2dae875ef12d3135188" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$|&lt;/code&gt; is one of the per-filehandle special variables, so each filehandle has its own copy of its value. If you want to merge standard output and standard error for instance, you have to unbuffer each (although STDERR might be unbuffered by default):</source>
          <target state="translated">&lt;code&gt;$|&lt;/code&gt; 파일 당 특수 변수 중 하나이므로 각 파일 핸들에는 고유 한 값의 사본이 있습니다. 예를 들어 표준 출력과 표준 오류를 병합하려면 각 버퍼를 버퍼링 해제해야합니다 (STDERR은 기본적으로 버퍼링 해제 될 수 있음).</target>
        </trans-unit>
        <trans-unit id="697d0e02c23a6252ba73964b72ba7fef06e6718b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;%^H&lt;/code&gt; hash provides the same scoping semantic as &lt;code&gt;$^H&lt;/code&gt; . This makes it useful for implementation of lexically scoped pragmas. See &lt;a href=&quot;perlpragma&quot;&gt;perlpragma&lt;/a&gt;. All the entries are stringified when accessed at runtime, so only simple values can be accommodated. This means no pointers to objects, for example.</source>
          <target state="translated">&lt;code&gt;%^H&lt;/code&gt; 해시는 동일한 의미 스코핑 제공 &lt;code&gt;$^H&lt;/code&gt; . 이는 어휘 범위가있는 pragma를 구현하는 데 유용합니다. &lt;a href=&quot;perlpragma&quot;&gt;perlpragma를&lt;/a&gt; 참조하십시오 . 런타임시 액세스 할 때 모든 항목이 문자열 화되므로 간단한 값만 수용 할 수 있습니다. 예를 들어 객체에 대한 포인터가 없다는 의미입니다.</target>
        </trans-unit>
        <trans-unit id="1c509249d339b2febfc4d2738ff085bd8d0cc7d9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;%^H&lt;/code&gt; hash provides the same scoping semantic as &lt;code&gt;$^H&lt;/code&gt;. This makes it useful for implementation of lexically scoped pragmas. See &lt;a href=&quot;perlpragma&quot;&gt;perlpragma&lt;/a&gt;. All the entries are stringified when accessed at runtime, so only simple values can be accommodated. This means no pointers to objects, for example.</source>
          <target state="translated">&lt;code&gt;%^H&lt;/code&gt; 해시는 동일한 의미 스코핑 제공 &lt;code&gt;$^H&lt;/code&gt; . 이것은 어휘 범위의 pragma를 구현하는 데 유용합니다. &lt;a href=&quot;perlpragma&quot;&gt;perlpragma를&lt;/a&gt; 참조하십시오 . 모든 항목은 런타임에 액세스 할 때 문자열 화되므로 단순한 값만 수용 할 수 있습니다. 이것은 예를 들어 객체에 대한 포인터가 없음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="0c6228356b1a9a18f543cd58f3d14ae5ed0885fe" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;%s&lt;/code&gt; is expanded to be the filename (&lt;code&gt;&lt;a href=&quot;../functions/sprintf&quot;&gt;sprintf&lt;/a&gt;&lt;/code&gt; is used, so be careful to escape any other &lt;code&gt;%&lt;/code&gt; signs). The 'commands' are checked for sanity - they must contain the &lt;code&gt;%s&lt;/code&gt; , and the read open must end with the pipe sign, and the write open must begin with the pipe sign.</source>
          <target state="translated">&lt;code&gt;%s&lt;/code&gt; (파일 이름으로 확장 &lt;code&gt;&lt;a href=&quot;../functions/sprintf&quot;&gt;sprintf&lt;/a&gt;&lt;/code&gt; 사용되므로 다른 탈출 조심 &lt;code&gt;%&lt;/code&gt; 의 징후). '명령'은 온전한 지 검사합니다. &lt;code&gt;%s&lt;/code&gt; 포함해야 하며 읽기 열기는 파이프 부호로 끝나야하며 쓰기 열기는 파이프 부호로 시작해야합니다.</target>
        </trans-unit>
        <trans-unit id="2719188c4cf371193166be19d0cfafdbeb67f360" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;%s&lt;/code&gt; is expanded to be the filename (&lt;code&gt;sprintf&lt;/code&gt; is used, so be careful to escape any other &lt;code&gt;%&lt;/code&gt; signs). The 'commands' are checked for sanity - they must contain the &lt;code&gt;%s&lt;/code&gt;, and the read open must end with the pipe sign, and the write open must begin with the pipe sign.</source>
          <target state="translated">&lt;code&gt;%s&lt;/code&gt; (파일 이름으로 확장 &lt;code&gt;sprintf&lt;/code&gt; 사용되므로 다른 탈출 조심 &lt;code&gt;%&lt;/code&gt; 의 징후). '명령'은 온전한 지 확인합니다. &lt;code&gt;%s&lt;/code&gt; 포함해야 하며 읽기 열기는 파이프 기호로 끝나야하며 쓰기 열기는 파이프 기호로 시작해야합니다.</target>
        </trans-unit>
        <trans-unit id="cf6ebcc90a0416e4d456de5b17214b9e0b4a29e3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&amp;amp;&lt;/code&gt; unary operator in the INPUT: section is used to tell &lt;b&gt;xsubpp&lt;/b&gt; that it should convert a Perl value to/from C using the C type to the left of &lt;code&gt;&amp;amp;&lt;/code&gt; , but provide a pointer to this value when the C function is called.</source>
          <target state="translated">INPUT : 섹션 의 &lt;code&gt;&amp;amp;&lt;/code&gt; 단항 연산자는 &lt;b&gt;xsubpp&lt;/b&gt; 에게 C 유형을 사용하여 &lt;code&gt;&amp;amp;&lt;/code&gt; 의 왼쪽에있는 Perl 값을 C로 /에서 변환해야한다고 알려주는 데 사용 되지만 C 함수가 호출 될 때이 값에 대한 포인터를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="f377db487fb9db0d6201d5c112d20cdac0c1ec99" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&amp;amp;&lt;/code&gt; unary operator in the INPUT: section is used to tell &lt;b&gt;xsubpp&lt;/b&gt; that it should convert a Perl value to/from C using the C type to the left of &lt;code&gt;&amp;amp;&lt;/code&gt;, but provide a pointer to this value when the C function is called.</source>
          <target state="translated">INPUT : 섹션 의 &lt;code&gt;&amp;amp;&lt;/code&gt; 단항 연산자는 &lt;b&gt;xsubpp&lt;/b&gt; 에게 &lt;code&gt;&amp;amp;&lt;/code&gt; 왼쪽에있는 C 유형을 사용하여 Perl 값을 C로 /에서 변환해야한다고 알리는 데 사용 되지만 C 함수가 호출 될 때이 값에 대한 포인터를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="0b29d8efcd6e9fd3b54226af4554626aa17bc6d2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;&lt;/code&gt; modifiers can also be used on &lt;code&gt;()&lt;/code&gt; groups to force a particular byte-order on all components in that group, including all its subgroups.</source>
          <target state="translated">&lt;code&gt;&amp;gt;&lt;/code&gt; 과 &lt;code&gt;&amp;lt;&lt;/code&gt; 수식도에 사용될 수있다 &lt;code&gt;()&lt;/code&gt; 모든 하위 그룹을 포함하는 그룹의 모든 구성 요소의 특정 바이트 순서를 강제 기.</target>
        </trans-unit>
        <trans-unit id="46a36b2037ff10a0c2a8e03718578280ecd8883f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&amp;gt;&lt;/code&gt; or &lt;code&gt;&amp;lt;&lt;/code&gt; modifiers can only be used on floating-point formats on big- or little-endian machines. Otherwise, attempting to use them raises an exception.</source>
          <target state="translated">&lt;code&gt;&amp;gt;&lt;/code&gt; 또는 &lt;code&gt;&amp;lt;&lt;/code&gt; 수정은 BIG-또는 작은 엔디안 컴퓨터에서 부동 소수점 형식에서 사용할 수 있습니다. 그렇지 않으면 사용하려고하면 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="99da10732816cfac1a93d49f7cb24d6856262342" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; operator is most often seen in a &lt;code&gt;while&lt;/code&gt; loop:</source>
          <target state="translated">이 &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; 운영자는 가장 흔히 볼되는 &lt;code&gt;while&lt;/code&gt; 루프 :</target>
        </trans-unit>
        <trans-unit id="afce8c3936870dcddae71b2f62bcc6619bb65ebe" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; operator performs a globbing operation (see above). In Perl versions earlier than v5.6.0, the internal glob() operator forks csh(1) to do the actual glob expansion, but csh can't handle more than 127 items and so gives the error message &lt;code&gt;Argument list too long&lt;/code&gt; . People who installed tcsh as csh won't have this problem, but their users may be surprised by it.</source>
          <target state="translated">&lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; 운영자가 행하는 동작 로빙 (상기 참조). v5.6.0 이전의 Perl 버전에서 내부 glob () 연산자는 실제 glob 확장을 수행하기 위해 csh (1)를 fork하지만 csh는 127 개 이상의 항목을 처리 할 수 ​​없으므로 &lt;code&gt;Argument list too long&lt;/code&gt; 오류 메시지가 너무 깁니다 . tcsh를 csh로 설치 한 사람에게는이 문제가 없지만 사용자가 놀라게 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="83ef73a269b83405910162deabaede06a6badff3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; operator performs a globbing operation (see above). In Perl versions earlier than v5.6.0, the internal glob() operator forks csh(1) to do the actual glob expansion, but csh can't handle more than 127 items and so gives the error message &lt;code&gt;Argument list too long&lt;/code&gt;. People who installed tcsh as csh won't have this problem, but their users may be surprised by it.</source>
          <target state="translated">&lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; 운영자가 행하는 동작 로빙 (상기 참조). v5.6.0 이전의 Perl 버전에서 내부 glob () 연산자는 실제 glob 확장을 수행하기 위해 csh (1)을 포크하지만 csh는 127 개 이상의 항목을 처리 할 수 ​​없으므로 오류 메시지 &lt;code&gt;Argument list too long&lt;/code&gt; 을 제공 합니다. tcsh를 csh로 설치 한 사람들은이 문제가 발생하지 않을 것입니다. 그러나 사용자들은 이에 놀라게 될 것입니다.</target>
        </trans-unit>
        <trans-unit id="6640438652752fb93dc538db26332c2e258075d0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; symbol will return &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; for end-of-file only once. If you call it again after this, it will assume you are processing another &lt;code&gt;@ARGV&lt;/code&gt; list, and if you haven't set &lt;code&gt;@ARGV&lt;/code&gt; , will read input from STDIN.</source>
          <target state="translated">&lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; 기호는 반환 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 를 한 번만 파일의 끝을 위해. 이 후에 다시 호출하면 다른 &lt;code&gt;@ARGV&lt;/code&gt; 목록을 처리한다고 가정 하고 &lt;code&gt;@ARGV&lt;/code&gt; 를 설정하지 않으면 STDIN에서 입력을 읽습니다.</target>
        </trans-unit>
        <trans-unit id="3dc916b5527d8e3b6254129215dab620bcd909c8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; symbol will return &lt;code&gt;undef&lt;/code&gt; for end-of-file only once. If you call it again after this, it will assume you are processing another &lt;code&gt;@ARGV&lt;/code&gt; list, and if you haven't set &lt;code&gt;@ARGV&lt;/code&gt;, will read input from STDIN.</source>
          <target state="translated">&lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; 기호는 반환 &lt;code&gt;undef&lt;/code&gt; 를 한 번만 파일의 끝을 위해. 이 후에 다시 호출하면 다른 &lt;code&gt;@ARGV&lt;/code&gt; 목록을 처리하고 있다고 가정 하고 &lt;code&gt;@ARGV&lt;/code&gt; 를 설정하지 않은 경우 STDIN에서 입력을 읽습니다.</target>
        </trans-unit>
        <trans-unit id="eb62b601a884f58c8064f8b862089ac2459b0228" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;'I'&lt;/code&gt; prefix is used during creation of &lt;code&gt;stdin&lt;/code&gt; ..&lt;code&gt;stderr&lt;/code&gt; via special &lt;code&gt;PerlIO_fdopen&lt;/code&gt; calls; the &lt;code&gt;'#'&lt;/code&gt; prefix means that this is &lt;code&gt;&lt;a href=&quot;functions/sysopen&quot;&gt;sysopen&lt;/a&gt;&lt;/code&gt; and that</source>
          <target state="translated">&lt;code&gt;'I'&lt;/code&gt; 프리픽스의 작성시 사용되는 &lt;code&gt;stdin&lt;/code&gt; ... &lt;code&gt;stderr&lt;/code&gt; 를 통해 특별한 &lt;code&gt;PerlIO_fdopen&lt;/code&gt; 의 호출; &lt;code&gt;'#'&lt;/code&gt; 이되는 접두사 수단 &lt;code&gt;&lt;a href=&quot;functions/sysopen&quot;&gt;sysopen&lt;/a&gt;&lt;/code&gt; 그</target>
        </trans-unit>
        <trans-unit id="e4a1e4127c99792fcfccb34fc1ce371d9c5cbbcc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;'I'&lt;/code&gt; prefix is used during creation of &lt;code&gt;stdin&lt;/code&gt;..&lt;code&gt;stderr&lt;/code&gt; via special &lt;code&gt;PerlIO_fdopen&lt;/code&gt; calls; the &lt;code&gt;'#'&lt;/code&gt; prefix means that this is &lt;code&gt;sysopen&lt;/code&gt; and that</source>
          <target state="translated">&lt;code&gt;'I'&lt;/code&gt; 프리픽스의 작성시 사용되는 &lt;code&gt;stdin&lt;/code&gt; ... &lt;code&gt;stderr&lt;/code&gt; 를 통해 특별한 &lt;code&gt;PerlIO_fdopen&lt;/code&gt; 의 호출; &lt;code&gt;'#'&lt;/code&gt; 이되는 접두사 수단 &lt;code&gt;sysopen&lt;/code&gt; 그</target>
        </trans-unit>
        <trans-unit id="039ae207dd483bda31bf76d897310e5b8ac60fad" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;'nomethod'&lt;/code&gt; key is used to specify a catch-all function to be called for any operator that is not individually overloaded. The specified function will be passed four parameters. The first three arguments coincide with those that would have been passed to the corresponding method if it had been defined. The fourth argument is the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; overload&lt;/code&gt; key for that missing method. If the experimental &quot;bitwise&quot; feature is enabled (see &lt;a href=&quot;feature&quot;&gt;feature&lt;/a&gt;), a fifth TRUE argument is passed to subroutines handling &lt;code&gt;&amp;amp;&lt;/code&gt; , &lt;code&gt;|&lt;/code&gt;, &lt;code&gt;^&lt;/code&gt; and &lt;code&gt;~&lt;/code&gt; to indicate that the caller is expecting numeric behaviour.</source>
          <target state="translated">&lt;code&gt;'nomethod'&lt;/code&gt; 키를 개별적으로 오버로드되지 않은 운영자 호출 할 수있는 포괄 기능을 지정하는 데 사용됩니다. 지정된 기능에는 네 개의 매개 변수가 전달됩니다. 처음 세 개의 인수는 해당 메소드가 정의 된 경우 해당 메소드에 전달 된 인수와 일치합니다. 네 번째 인수는 누락 된 메소드에 대한 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; overload&lt;/code&gt; 키 &lt;a href=&quot;functions/use&quot;&gt;사용&lt;/a&gt; 입니다. 실험적인 &quot;비트 단위&quot;기능이 활성화 된 경우 ( &lt;a href=&quot;feature&quot;&gt;기능&lt;/a&gt; 참조 ), 다섯 번째 TRUE 인수는 &lt;code&gt;&amp;amp;&lt;/code&gt; , &lt;code&gt;|&lt;/code&gt; , &lt;code&gt;^&lt;/code&gt; 및 &lt;code&gt;~&lt;/code&gt; 는 발신자가 숫자 동작을 예상하고 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="7a25ce7c1bcfa6d33e234b18065c7c24fe6b0cdb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;'nomethod'&lt;/code&gt; key is used to specify a catch-all function to be called for any operator that is not individually overloaded. The specified function will be passed four parameters. The first three arguments coincide with those that would have been passed to the corresponding method if it had been defined. The fourth argument is the &lt;code&gt;use overload&lt;/code&gt; key for that missing method. If the &quot;bitwise&quot; feature is enabled (see &lt;a href=&quot;feature&quot;&gt;feature&lt;/a&gt;), a fifth TRUE argument is passed to subroutines handling &lt;code&gt;&amp;amp;&lt;/code&gt;, &lt;code&gt;|&lt;/code&gt;, &lt;code&gt;^&lt;/code&gt; and &lt;code&gt;~&lt;/code&gt; to indicate that the caller is expecting numeric behaviour.</source>
          <target state="translated">&lt;code&gt;'nomethod'&lt;/code&gt; 키를 개별적으로 오버로드되지 않은 운영자 호출 할 수있는 포괄 기능을 지정하는 데 사용됩니다. 지정된 함수에는 4 개의 매개 변수가 전달됩니다. 처음 세 개의 인수는 정의 된 경우 해당 메서드에 전달되었을 인수와 일치합니다. 네 번째 인수는 누락 된 메서드에 대한 &lt;code&gt;use overload&lt;/code&gt; 키 사용 입니다. &quot;비트&quot;기능이 활성화 된 경우 ( &lt;a href=&quot;feature&quot;&gt;feature&lt;/a&gt; 참조 ), 다섯 번째 TRUE 인수가 &lt;code&gt;&amp;amp;&lt;/code&gt; , &lt;code&gt;|&lt;/code&gt; , &lt;code&gt;^&lt;/code&gt; 및 &lt;code&gt;~&lt;/code&gt; 는 호출자가 숫자 동작을 예상하고 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="a56ee7f30e7bca1dfc3e81783dadbc2bc19f727f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;(a|b)*&lt;/code&gt; part can match at every char in the string, and then fail every time because there is no &lt;code&gt;z&lt;/code&gt; in the string. So obviously we can avoid using the regex engine unless there is a &lt;code&gt;z&lt;/code&gt; in the string. Likewise in a pattern like:</source>
          <target state="translated">&lt;code&gt;(a|b)*&lt;/code&gt; 부분이 문자열의 모든 문자에 일치하고, 어떤이 없기 때문에 다음마다 실패 할 수 &lt;code&gt;z&lt;/code&gt; 문자열이. 따라서 문자열에 &lt;code&gt;z&lt;/code&gt; 가 없으면 정규식 엔진 사용을 피할 수 있습니다 . 마찬가지로 다음과 같은 패턴으로 :</target>
        </trans-unit>
        <trans-unit id="13f6771d5d5f30a227731a56b375d2b66657907c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;*_BS&lt;/code&gt; file can put some code into the generated &lt;code&gt;*.bs&lt;/code&gt; file by placing it in &lt;code&gt;$bscode&lt;/code&gt; . This is a handy 'escape' mechanism that may prove useful in complex situations.</source>
          <target state="translated">&lt;code&gt;*_BS&lt;/code&gt; 파일 생성에 일부 코드를 넣을 수 있습니다 &lt;code&gt;*.bs&lt;/code&gt; 에 배치하여 파일을 &lt;code&gt;$bscode&lt;/code&gt; . 이것은 복잡한 상황에서 유용 할 수있는 편리한 '탈출'메커니즘입니다.</target>
        </trans-unit>
        <trans-unit id="b4a8908910386e1e7fa8ea911939f668d427bb11" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;*_BS&lt;/code&gt; file can put some code into the generated &lt;code&gt;*.bs&lt;/code&gt; file by placing it in &lt;code&gt;$bscode&lt;/code&gt;. This is a handy 'escape' mechanism that may prove useful in complex situations.</source>
          <target state="translated">&lt;code&gt;*_BS&lt;/code&gt; 파일 생성에 일부 코드를 넣을 수 있습니다 &lt;code&gt;*.bs&lt;/code&gt; 에 배치하여 파일을 &lt;code&gt;$bscode&lt;/code&gt; . 이것은 복잡한 상황에서 유용 할 수있는 편리한 '탈출'메커니즘입니다.</target>
        </trans-unit>
        <trans-unit id="2ecae669ab5e752a1da7ac780070c852f9269859" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;*foo{THING}&lt;/code&gt; notation can also be used to obtain references to the individual elements of *foo. See &lt;a href=&quot;perlref&quot;&gt;perlref&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;*foo{THING}&lt;/code&gt; 표기는 *의 foo 개별 요소에 대한 참조를 획득하기 위해 사용될 수있다. &lt;a href=&quot;perlref&quot;&gt;perlref를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="255645a7c66228ebcb1a14a341007dcfb97aeb51" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;*x = \$y&lt;/code&gt; mechanism may be used to pass and return cheap references into or from subroutines if you don't want to copy the whole thing. It only works when assigning to dynamic variables, not lexicals.</source>
          <target state="translated">&lt;code&gt;*x = \$y&lt;/code&gt; 메커니즘은 사용자가 전체를 복사하지 않으려는 경우 통과로 또는 서브 루틴에서 싼 참조를 반환하는 데 사용 할 수있다. 어휘가 아닌 동적 변수에 할당 할 때만 작동합니다.</target>
        </trans-unit>
        <trans-unit id="fa1621299f61dcb4d1993cf9ac21afe7e26870e3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;+&lt;/code&gt; form is now obsolete and strongly deprecated.</source>
          <target state="translated">&lt;code&gt;+&lt;/code&gt; 의 형태는 이제 사용되지 강하게되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6cc8f120eca26410795cc27186ae2b363ac834f3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;+&lt;/code&gt; prototype is a special alternative to &lt;code&gt;$&lt;/code&gt; that will act like &lt;code&gt;\[@%]&lt;/code&gt; when given a literal array or hash variable, but will otherwise force scalar context on the argument. This is useful for functions which should accept either a literal array or an array reference as the argument:</source>
          <target state="translated">&lt;code&gt;+&lt;/code&gt; 의 프로토 타입에 대한 특별한 대안입니다 &lt;code&gt;$&lt;/code&gt; 와 같은 역할을합니다 &lt;code&gt;\[@%]&lt;/code&gt; 리터럴 배열이나 해쉬 변수를 제공하지만, 그 인수에 스칼라 문맥을 강제 할 때. 이것은 리터럴 배열이나 배열 참조를 인수로 받아 들여야하는 함수에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="bb2105637115aa748fce8bf2036dcef89f13282b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;+&lt;/code&gt; specifier is ignored if the option destination is not a scalar.</source>
          <target state="translated">&lt;code&gt;+&lt;/code&gt; 의 옵션 대상이 스칼라가 아닌 경우 지정은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="6806c6a2e8d1792a36b6bbc8a8afc151b341b78f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;+&lt;/code&gt; unary operator doesn't do anything in Perl. It exists to avoid syntactic ambiguities.</source>
          <target state="translated">&lt;code&gt;+&lt;/code&gt; 단항 연산자는 펄에서 아무것도하지 않습니다. 구문상의 모호성을 피하기 위해 존재합니다.</target>
        </trans-unit>
        <trans-unit id="37675ebea1632ec83c2cb0e9f47bb19d76dac534" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-&amp;gt;&lt;/code&gt; syntax is also used when dereferencing a reference. It looks like the same operator, but these are two different operations.</source>
          <target state="translated">는 &lt;code&gt;-&amp;gt;&lt;/code&gt; 참조 역 참조 할 때 문법도 사용된다. 동일한 연산자처럼 보이지만 서로 다른 두 가지 작업입니다.</target>
        </trans-unit>
        <trans-unit id="d4b0e534108246bac541ccb7068bc25380ccc720" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-&amp;gt;new()&lt;/code&gt; method is an alias for &lt;code&gt;-&amp;gt;create()&lt;/code&gt; .</source>
          <target state="translated">(가) &lt;code&gt;-&amp;gt;new()&lt;/code&gt; 메소드가의 별칭입니다 &lt;code&gt;-&amp;gt;create()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7955495872f4b4ea374a5a73bb5908daadd88feb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-&amp;gt;new()&lt;/code&gt; method is an alias for &lt;code&gt;-&amp;gt;create()&lt;/code&gt;.</source>
          <target state="translated">(가) &lt;code&gt;-&amp;gt;new()&lt;/code&gt; 메소드가의 별칭입니다 &lt;code&gt;-&amp;gt;create()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8192632e359d95a2b8b1baa2f14ef188f64fb3bf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--libpods&lt;/code&gt; option is no longer recognized as of Perl 5.26.</source>
          <target state="translated">&lt;code&gt;--libpods&lt;/code&gt; 옵션은 더 이상 펄 5.26로 인정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="127cc52ec86933168c2c1aece6f9b232d7cd7b7c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--rules&lt;/code&gt; option is used to control which tests are run sequentially and which are run in parallel, if the &lt;code&gt;--jobs&lt;/code&gt; option is specified. The option may be specified multiple times, and the order matters.</source>
          <target state="translated">&lt;code&gt;--rules&lt;/code&gt; (가) 경우 옵션은, 테스트를 순차적으로 실행되고, 이는 병렬로 실행되는 제어에 사용되는 &lt;code&gt;--jobs&lt;/code&gt; 옵션들이 특정된다. 옵션은 여러 번 지정할 수 있으며 순서는 중요합니다.</target>
        </trans-unit>
        <trans-unit id="608a757f76e2d49976d1abe026a19ab9cb45d134" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--state&lt;/code&gt; switch may be used more than once.</source>
          <target state="translated">&lt;code&gt;--state&lt;/code&gt; 스위치는 두 번 이상 사용할 수있다.</target>
        </trans-unit>
        <trans-unit id="cc3c8ce0b0c852fbdda4091c52f36592afcdc410" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--state&lt;/code&gt; switch requires an argument which must be a comma separated list of one or more of the following options.</source>
          <target state="translated">&lt;code&gt;--state&lt;/code&gt; 스위치는 쉼표해야 인수는 하나 이상의 다음과 같은 옵션의 목록을 분리해야합니다.</target>
        </trans-unit>
        <trans-unit id="377dc2d9444ba53f1e07b9f9c8ed4eb80a1854c9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--trap&lt;/code&gt; option will attempt to trap SIGINT (Ctrl-C) during a test run and display the test summary even if the run is interrupted</source>
          <target state="translated">&lt;code&gt;--trap&lt;/code&gt; 옵션은 테스트 실행 중에 트랩 SIGINT (Ctrl-C를)를 시도하고 실행이 중단되는 경우에도 시험 요약을 표시합니다</target>
        </trans-unit>
        <trans-unit id="e392f25b1c4fe3943f476468712579d620408f6a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-A&lt;/code&gt; command line switch</source>
          <target state="translated">&lt;code&gt;-A&lt;/code&gt; 의 명령 줄 스위치</target>
        </trans-unit>
        <trans-unit id="eb91ceec65f320f24de6ea1ba97059dfa04bc1be" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-A&lt;/code&gt; omits the Autoloader code, &lt;code&gt;-X&lt;/code&gt; omits XS elements, &lt;code&gt;--skip-exporter&lt;/code&gt; omits the Exporter code, &lt;code&gt;--use-new-tests&lt;/code&gt; sets up a modern testing environment, and &lt;code&gt;-n&lt;/code&gt; specifies the name of the module.</source>
          <target state="translated">&lt;code&gt;-A&lt;/code&gt; 는 , 오토로더 코드를 생략 &lt;code&gt;-X&lt;/code&gt; 를 생략 요소, XS &lt;code&gt;--skip-exporter&lt;/code&gt; 를 생략를 수출 코드, &lt;code&gt;--use-new-tests&lt;/code&gt; 현대적인 테스트 환경 및 설정 &lt;code&gt;-n&lt;/code&gt; 지정 모듈의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="597b9a9c8e6ccba33470cbc78977519edc52f8e9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-A&lt;/code&gt; omits the Autoloader code, &lt;code&gt;&lt;a href=&quot;functions/-x&quot;&gt;-X&lt;/a&gt;&lt;/code&gt; omits XS elements, &lt;code&gt;--skip-exporter&lt;/code&gt; omits the Exporter code, &lt;code&gt;--&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;-new-tests&lt;/code&gt; sets up a modern testing environment, and &lt;code&gt;-n&lt;/code&gt; specifies the name of the module.</source>
          <target state="translated">&lt;code&gt;-A&lt;/code&gt; 를 생략 오토로더 코드, &lt;code&gt;&lt;a href=&quot;functions/-x&quot;&gt;-X&lt;/a&gt;&lt;/code&gt; 를 생략 XS 요소, &lt;code&gt;--skip-exporter&lt;/code&gt; 를 생략 내보내기 코드는 &lt;code&gt;--&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;-new-tests&lt;/code&gt; 현대적인 테스트 환경 설정하고 &lt;code&gt;-n&lt;/code&gt; 지정 모듈의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="c623c1943d0dabf76760d7670756f1a93a94f39a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-Dusecbacktrace&lt;/code&gt; also enables keeping the debug information when compiling/linking (often: &lt;code&gt;-g&lt;/code&gt; ). Many compilers/linkers do support having both optimization and keeping the debug information. The debug information is needed for the symbol names and the source locations.</source>
          <target state="translated">&lt;code&gt;-Dusecbacktrace&lt;/code&gt; 는 (: 종종 링크 / 컴파일 할 때 디버그 정보를 유지 할 수 &lt;code&gt;-g&lt;/code&gt; ). 많은 컴파일러 / 링커는 최적화 및 디버그 정보 유지를 모두 지원합니다. 심볼 이름과 소스 위치에 디버그 정보가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="82d0f491a8ddd8c808b16ec9be7ca117f4caf1b7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-Dusecbacktrace&lt;/code&gt; also enables keeping the debug information when compiling/linking (often: &lt;code&gt;-g&lt;/code&gt;). Many compilers/linkers do support having both optimization and keeping the debug information. The debug information is needed for the symbol names and the source locations.</source>
          <target state="translated">&lt;code&gt;-Dusecbacktrace&lt;/code&gt; 는 (: 종종 링크 / 컴파일 할 때 디버그 정보를 유지 할 수 &lt;code&gt;-g&lt;/code&gt; ). 많은 컴파일러 / 링커는 최적화와 디버그 정보 유지를 모두 지원합니다. 기호 이름 및 소스 위치에 대한 디버그 정보가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="63378b07c96f9b709eea4a8451598ec112926512" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-T&lt;/code&gt; and &lt;code&gt;-B&lt;/code&gt; switches work as follows. The first block or so of the file is examined to see if it is valid UTF-8 that includes non-ASCII characters. If, so it's a &lt;code&gt;-T&lt;/code&gt; file. Otherwise, that same portion of the file is examined for odd characters such as strange control codes or characters with the high bit set. If more than a third of the characters are strange, it's a &lt;code&gt;-B&lt;/code&gt; file; otherwise it's a &lt;code&gt;-T&lt;/code&gt; file. Also, any file containing a zero byte in the examined portion is considered a binary file. (If executed within the scope of a &lt;a href=&quot;../perllocale&quot;&gt;use locale&lt;/a&gt; which includes &lt;code&gt;LC_CTYPE&lt;/code&gt; , odd characters are anything that isn't a printable nor space in the current locale.) If &lt;code&gt;-T&lt;/code&gt; or &lt;code&gt;-B&lt;/code&gt; is used on a filehandle, the current IO buffer is examined rather than the first block. Both &lt;code&gt;-T&lt;/code&gt; and &lt;code&gt;-B&lt;/code&gt; return true on an empty file, or a file at EOF when testing a filehandle. Because you have to read a file to do the &lt;code&gt;-T&lt;/code&gt; test, on most occasions you want to use a &lt;code&gt;-f&lt;/code&gt; against the file first, as in &lt;code&gt;&lt;a href=&quot;next&quot;&gt;next&lt;/a&gt; unless -f $file &amp;amp;&amp;amp; -T $file&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;-T&lt;/code&gt; 와 &lt;code&gt;-B&lt;/code&gt; 는 다음과 같이 작업을 전환합니다. 파일의 첫 번째 블록 등이 ASCII가 아닌 문자를 포함하는 유효한 UTF-8인지 확인하기 위해 검사됩니다. 그렇다면 &lt;code&gt;-T&lt;/code&gt; 파일입니다. 그렇지 않으면 파일의 동일한 부분에서 이상한 제어 코드 또는 높은 비트 세트의 문자와 같은 이상한 문자가 있는지 검사합니다. 문자의 3 ​​분의 1 이상이 이상하면 &lt;code&gt;-B&lt;/code&gt; 파일입니다. 그렇지 않으면 &lt;code&gt;-T&lt;/code&gt; 파일입니다. 또한 검사 된 부분에 0 바이트를 포함하는 파일은 이진 파일로 간주됩니다. &lt;code&gt;LC_CTYPE&lt;/code&gt; 을 포함 하는 &lt;a href=&quot;../perllocale&quot;&gt;사용 로케일&lt;/a&gt; 범위 내에서 실행되는 경우 홀수 문자는 현재 로케일에서 인쇄 가능하지 않거나 공백이 아닌 것입니다. &lt;code&gt;-T&lt;/code&gt; 또는 &lt;code&gt;-B&lt;/code&gt; 는 파일 핸들에서 사용되며 첫 번째 블록이 아닌 현재 IO 버퍼가 검사됩니다. &lt;code&gt;-T&lt;/code&gt; 와 &lt;code&gt;-B&lt;/code&gt; 는 모두 빈 파일에서 또는 파일 핸들을 테스트 할 때 EOF의 파일에서 true를 리턴합니다. &lt;code&gt;-T&lt;/code&gt; 테스트 를 수행하려면 파일을 읽어야하므로 대부분의 경우 &lt;code&gt;&lt;a href=&quot;next&quot;&gt;next&lt;/a&gt; unless -f $file &amp;amp;&amp;amp; -T $file&lt;/code&gt; &lt;a href=&quot;next&quot;&gt;다음&lt;/a&gt; 과 같이 파일에 대해 &lt;code&gt;-f&lt;/code&gt; 를 먼저 사용하려고 합니다 .</target>
        </trans-unit>
        <trans-unit id="c91ca83f347b61a13eb65089f07047ddb67d9622" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-T&lt;/code&gt; and &lt;code&gt;-B&lt;/code&gt; switches work as follows. The first block or so of the file is examined to see if it is valid UTF-8 that includes non-ASCII characters. If, so it's a &lt;code&gt;-T&lt;/code&gt; file. Otherwise, that same portion of the file is examined for odd characters such as strange control codes or characters with the high bit set. If more than a third of the characters are strange, it's a &lt;code&gt;-B&lt;/code&gt; file; otherwise it's a &lt;code&gt;-T&lt;/code&gt; file. Also, any file containing a zero byte in the examined portion is considered a binary file. (If executed within the scope of a &lt;a href=&quot;perllocale&quot;&gt;use locale&lt;/a&gt; which includes &lt;code&gt;LC_CTYPE&lt;/code&gt; , odd characters are anything that isn't a printable nor space in the current locale.) If &lt;code&gt;-T&lt;/code&gt; or &lt;code&gt;-B&lt;/code&gt; is used on a filehandle, the current IO buffer is examined rather than the first block. Both &lt;code&gt;-T&lt;/code&gt; and &lt;code&gt;-B&lt;/code&gt; return true on an empty file, or a file at EOF when testing a filehandle. Because you have to read a file to do the &lt;code&gt;-T&lt;/code&gt; test, on most occasions you want to use a &lt;code&gt;-f&lt;/code&gt; against the file first, as in &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt; unless -f $file &amp;amp;&amp;amp; -T $file&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;-T&lt;/code&gt; 와 &lt;code&gt;-B&lt;/code&gt; 는 다음과 같이 작업을 전환합니다. 파일의 첫 번째 블록 등이 ASCII가 아닌 문자를 포함하는 유효한 UTF-8인지 확인하기 위해 검사됩니다. 그렇다면 &lt;code&gt;-T&lt;/code&gt; 파일입니다. 그렇지 않으면 파일의 동일한 부분에서 이상한 제어 코드 또는 높은 비트 세트의 문자와 같은 이상한 문자가 있는지 검사합니다. 3 분의 1 이상의 문자가 이상 하면 파일 핸들에 &lt;code&gt;-B&lt;/code&gt; 파일입니다. 그렇지 않으면 &lt;code&gt;-T&lt;/code&gt; 파일입니다. 또한 검사 된 부분에 0 바이트를 포함하는 파일은 이진 파일로 간주됩니다. &lt;code&gt;LC_CTYPE&lt;/code&gt; 을 포함 하는 &lt;a href=&quot;perllocale&quot;&gt;사용 로케일&lt;/a&gt; 범위 내에서 실행되는 경우 홀수 문자는 현재 로케일에서 인쇄 가능하지 않거나 공백이 아닌 것입니다. &lt;code&gt;-T&lt;/code&gt; 또는 &lt;code&gt;-B&lt;/code&gt; 가 사용되고 첫 번째 블록이 아닌 현재 IO 버퍼가 검사됩니다. &lt;code&gt;-T&lt;/code&gt; 와 &lt;code&gt;-B&lt;/code&gt; 는 모두 빈 파일에서 또는 파일 핸들을 테스트 할 때 EOF의 파일에서 true를 리턴합니다. &lt;code&gt;-T&lt;/code&gt; 를 수행하려면 파일을 읽어야하기 때문에 대부분의 경우 테스트를 사용하려는 경우 &lt;code&gt;-f&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt; unless -f $file &amp;amp;&amp;amp; -T $file&lt;/code&gt; &lt;a href=&quot;functions/next&quot;&gt;다음&lt;/a&gt; 과 같이 파일에 대해 -f 를 먼저 합니다 .</target>
        </trans-unit>
        <trans-unit id="7d03161bfdc601bdcaa9b51890ed40d35154d9a2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-T&lt;/code&gt; and &lt;code&gt;-B&lt;/code&gt; tests work as follows. The first block or so of the file is examined to see if it is valid UTF-8 that includes non-ASCII characters. If so, it's a &lt;code&gt;-T&lt;/code&gt; file. Otherwise, that same portion of the file is examined for odd characters such as strange control codes or characters with the high bit set. If more than a third of the characters are strange, it's a &lt;code&gt;-B&lt;/code&gt; file; otherwise it's a &lt;code&gt;-T&lt;/code&gt; file. Also, any file containing a zero byte in the examined portion is considered a binary file. (If executed within the scope of a &lt;a href=&quot;perllocale&quot;&gt;use locale&lt;/a&gt; which includes &lt;code&gt;LC_CTYPE&lt;/code&gt;, odd characters are anything that isn't a printable nor space in the current locale.) If &lt;code&gt;-T&lt;/code&gt; or &lt;code&gt;-B&lt;/code&gt; is used on a filehandle, the current IO buffer is examined rather than the first block. Both &lt;code&gt;-T&lt;/code&gt; and &lt;code&gt;-B&lt;/code&gt; return true on an empty file, or a file at EOF when testing a filehandle. Because you have to read a file to do the &lt;code&gt;-T&lt;/code&gt; test, on most occasions you want to use a &lt;code&gt;-f&lt;/code&gt; against the file first, as in &lt;code&gt;next unless -f $file &amp;amp;&amp;amp; -T $file&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;-T&lt;/code&gt; 와 &lt;code&gt;-B&lt;/code&gt; 테스트는 다음과 작동합니다. 파일의 첫 번째 블록 정도를 검사하여 ASCII가 아닌 문자를 포함하는 유효한 UTF-8인지 확인합니다. 그렇다면 &lt;code&gt;-T&lt;/code&gt; 파일입니다. 그렇지 않으면 파일의 동일한 부분에서 이상한 제어 코드 또는 높은 비트 세트를 가진 문자와 같은 이상한 문자가 있는지 검사합니다. 문자의 1/3 이상이 이상하면 &lt;code&gt;-B&lt;/code&gt; 파일입니다. 그렇지 않으면 &lt;code&gt;-T&lt;/code&gt; 파일입니다. 또한 검사 된 부분에 0 바이트가 포함 된 파일은 이진 파일로 간주됩니다. ( &lt;code&gt;LC_CTYPE&lt;/code&gt; 을 포함 하는 &lt;a href=&quot;perllocale&quot;&gt;사용 로케일&lt;/a&gt; 의 범위 내에서 실행되는 경우 홀수 문자는 현재 로케일에서 인쇄 가능하지 않거나 공백이 아닌 모든 것입니다.) If &lt;code&gt;-T&lt;/code&gt; 또는 &lt;code&gt;-B&lt;/code&gt; 는 파일 핸들에서 사용되며 첫 번째 블록이 아닌 현재 IO 버퍼를 검사합니다. &lt;code&gt;-T&lt;/code&gt; 와 &lt;code&gt;-B&lt;/code&gt; 는 모두 빈 파일에 대해 true를 반환하거나 파일 핸들을 테스트 할 때 EOF에있는 파일을 반환합니다. &lt;code&gt;-T&lt;/code&gt; 테스트 를 수행하기 위해 파일을 읽어야하기 때문에 대부분의 경우 &lt;code&gt;next unless -f $file &amp;amp;&amp;amp; -T $file&lt;/code&gt; 하고 다음 에서와 같이 먼저 파일에 대해 &lt;code&gt;-f&lt;/code&gt; 를 사용하려고 합니다 .</target>
        </trans-unit>
        <trans-unit id="9bc0f3fa215c39800076a942f11672815853d1f5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-Wall&lt;/code&gt; is by default on.</source>
          <target state="translated">&lt;code&gt;-Wall&lt;/code&gt; 은 기본적입니다.</target>
        </trans-unit>
        <trans-unit id="6dfbaa82d695de76db5a43cbdf063e4ffac5d9ab" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-Wtraditional&lt;/code&gt; is another example of the annoying tendency of gcc to bundle a lot of warnings under one switch (it would be impossible to deploy in practice because it would complain a lot) but it does contain some warnings that would be beneficial to have available on their own, such as the warning about string constants inside macros containing the macro arguments: this behaved differently pre-ANSI than it does in ANSI, and some C compilers are still in transition, AIX being an example.</source>
          <target state="translated">- &lt;code&gt;-Wtraditional&lt;/code&gt; 은 gcc가 하나의 스위치 아래에 많은 경고를 묶는 성가신 경향의 또 다른 예입니다 (실제로 불평하기 때문에 실제로 배포하는 것은 불가능합니다).하지만 유용한 경고가 포함되어 있습니다. 매크로 인수를 포함하는 매크로 내부의 문자열 상수에 대한 경고와 같이 자체적으로는 ANSI와는 다르게 ANSI 이전과 다르게 동작했으며 일부 C 컴파일러는 여전히 전환 중이며 AIX는 예제입니다.</target>
        </trans-unit>
        <trans-unit id="29f275b0f904c074e809dc11f6813898aaca641a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-a&lt;/code&gt; option is used to include all files that git tracks that you have changed. If at this time, you only want to commit some of the files you have worked on, you can omit the &lt;code&gt;-a&lt;/code&gt; and use the command &lt;code&gt;git add &lt;i&gt;FILE ...&lt;/i&gt;&lt;/code&gt; before doing the commit. &lt;code&gt;git add --interactive&lt;/code&gt; allows you to even just commit portions of files instead of all the changes in them.</source>
          <target state="translated">&lt;code&gt;-a&lt;/code&gt; 옵션을 변경 한 것을 자식 추적하는 모든 파일을 포함하는 데 사용됩니다. 현재 작업 한 파일 중 일부만 커밋하려면 &lt;code&gt;-a&lt;/code&gt; 를 생략 하고 커밋을 수행하기 전에 &lt;code&gt;git add &lt;i&gt;FILE ...&lt;/i&gt;&lt;/code&gt; 명령을 사용할 수 있습니다 . &lt;code&gt;git add --interactive&lt;/code&gt; 를 사용하면 파일의 모든 변경 사항 대신 파일의 일부만 커밋 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="dea68b3a7d6bdc421299da6629ccc22d6bd7b572" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-ansi&lt;/code&gt; (and its sidekick, &lt;code&gt;-pedantic&lt;/code&gt; ) would be nice to be on always, but unfortunately they are not safe on all platforms, they can for example cause fatal conflicts with the system headers (Solaris being a prime example). If Configure &lt;code&gt;-Dgccansipedantic&lt;/code&gt; is used, the &lt;code&gt;cflags&lt;/code&gt; frontend selects &lt;code&gt;-ansi -pedantic&lt;/code&gt; for the platforms where they are known to be safe.</source>
          <target state="translated">&lt;code&gt;-ansi&lt;/code&gt; (및 친구, &lt;code&gt;-pedantic&lt;/code&gt; 는 ) 항상있을 좋은 것입니다,하지만 불행히도 그들은 모든 플랫폼에 안전하지 않습니다 그들이 할 수있는 시스템 헤더 (Solaris는 좋은 예이다)와 치명적인 충돌 원인, 예를 들어. Configure &lt;code&gt;-Dgccansipedantic&lt;/code&gt; 을 사용하는 경우 &lt;code&gt;cflags&lt;/code&gt; 프론트 엔드는 안전한 것으로 알려진 플랫폼에 대해 &lt;code&gt;-ansi -pedantic&lt;/code&gt; 을 선택 합니다.</target>
        </trans-unit>
        <trans-unit id="3c0974d53dc0e4835c4ef757f3690c3874414b6a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-ansi&lt;/code&gt; (and its sidekick, &lt;code&gt;-pedantic&lt;/code&gt;) would be nice to be on always, but unfortunately they are not safe on all platforms, they can for example cause fatal conflicts with the system headers (Solaris being a prime example). If Configure &lt;code&gt;-Dgccansipedantic&lt;/code&gt; is used, the &lt;code&gt;cflags&lt;/code&gt; frontend selects &lt;code&gt;-ansi -pedantic&lt;/code&gt; for the platforms where they are known to be safe.</source>
          <target state="translated">&lt;code&gt;-ansi&lt;/code&gt; (및 친구, &lt;code&gt;-pedantic&lt;/code&gt; 는 ) 항상있을 좋은 것입니다,하지만 불행히도 그들은 모든 플랫폼에 안전하지 않습니다 그들이 할 수있는 시스템 헤더 (Solaris는 좋은 예이다)와 치명적인 충돌 원인, 예를 들어. Configure &lt;code&gt;-Dgccansipedantic&lt;/code&gt; 을 사용하는 경우 &lt;code&gt;cflags&lt;/code&gt; 프런트 엔드는 안전한 것으로 알려진 플랫폼에 대해 &lt;code&gt;-ansi -pedantic&lt;/code&gt; 을 선택 합니다.</target>
        </trans-unit>
        <trans-unit id="cb94d9f2c59455332a30530ef3be81c2f437b975" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-h&lt;/code&gt; option will show a usage message.</source>
          <target state="translated">그만큼 &lt;code&gt;-h&lt;/code&gt; 옵션은 사용 메시지가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="2bf6b5a2450e550c35673777465af352e8fad7fc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-m&lt;/code&gt; option is used to specify the commit message. If you omit it, git will open a text editor for you to compose the message interactively. This is useful when the changes are more complex than the sample given here, and, depending on the editor, to know that the first line of the commit message doesn't exceed the 50 character legal maximum. See &lt;a href=&quot;perlhack#Commit-message&quot;&gt;&quot;Commit message&quot; in perlhack&lt;/a&gt; for more information about what makes a good commit message.</source>
          <target state="translated">&lt;code&gt;-m&lt;/code&gt; 옵션은이 커밋 메시지를 지정하는 데 사용됩니다. 생략하면 git은 메시지를 대화식으로 작성할 수있는 텍스트 편집기를 엽니 다. 이것은 여기에 제공된 샘플보다 변경 사항이 더 복잡 할 때 유용하며 편집기에 따라 커밋 메시지의 첫 번째 줄이 50 자 법적 최대 값을 초과하지 않는다는 것을 알 수 있습니다. 좋은 커밋 메시지를 만드는 방법에 대한 자세한 내용은 &lt;a href=&quot;perlhack#Commit-message&quot;&gt;perlhack의 &quot;커밋 메시지&quot;를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="02d034bd54a852b799ddb0bca00601006bc9ad62" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-newlex&lt;/code&gt; option produces a more readable &lt;code&gt;name =&amp;gt; value&lt;/code&gt; format, and is shown in the second example above.</source>
          <target state="translated">그만큼 &lt;code&gt;-newlex&lt;/code&gt; 옵션은 가독성 생성 &lt;code&gt;name =&amp;gt; value&lt;/code&gt; 포맷, 및 상기 두 번째 실시 예에서 도시된다.</target>
        </trans-unit>
        <trans-unit id="3ed7e26de1fd10b827d09512227b49a4f8d06d08" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-nosp&lt;/code&gt; option eliminates reporting of SPECIALs, such as &lt;code&gt;0: SPECIAL
#1 &amp;amp;PL_sv_undef&lt;/code&gt; above. Reporting of SPECIALs can sometimes overwhelm your declared lexicals.</source>
          <target state="translated">그만큼 &lt;code&gt;-nosp&lt;/code&gt; 같은 특별보고 옵션을 제거해, &lt;code&gt;0: SPECIAL #1 &amp;amp;PL_sv_undef&lt;/code&gt; 위. 스페셜을보고하면 선언 된 어휘를 압도 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="063586d44811e787a3acc7fa9925ec22a0e1ef32" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-pretty&lt;/code&gt; directive is called too late to affect matters. You have to do this instead, and</source>
          <target state="translated">그만큼 &lt;code&gt;-pretty&lt;/code&gt; 지시어는 문제에 영향을 너무 늦게라고합니다. 대신이 작업을 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="64b5e1fcc02dcf849bd221c8c257f81fb47b92a5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-q&lt;/code&gt; and &lt;code&gt;-qq&lt;/code&gt; options don't work correctly if perl isn't compiled with PerlIO support : STDOUT will be closed instead of being redirected to &lt;code&gt;$O::BEGIN_output&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;-q&lt;/code&gt; 및 &lt;code&gt;-qq&lt;/code&gt; 펄이은 PerlIO을 지원하도록 컴파일되어 있지 않은 경우 옵션은 제대로 작동하지 않습니다 : STDOUT 대신에 리디렉션의 종료됩니다 &lt;code&gt;$O::BEGIN_output&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="29496d6f7bd6b984673c9ef63d5a96a39bc5fbb3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-q&lt;/code&gt; and &lt;code&gt;-qq&lt;/code&gt; options don't work correctly if perl isn't compiled with PerlIO support : STDOUT will be closed instead of being redirected to &lt;code&gt;$O::BEGIN_output&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;-q&lt;/code&gt; 와 &lt;code&gt;-qq&lt;/code&gt; 펄이은 PerlIO을 지원하도록 컴파일되어 있지 않은 경우 옵션은 제대로 작동하지 않습니다 : STDOUT 대신에 리디렉션의 종료됩니다 &lt;code&gt;$O::BEGIN_output&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6261ab8564541d33e35c7ac1e97aa8a5e571dd14" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-qq&lt;/code&gt; option behaves like &lt;code&gt;-q&lt;/code&gt;, except that it also closes STDERR after deparsing has finished. This suppresses the &quot;Syntax OK&quot; message normally produced by perl.</source>
          <target state="translated">&lt;code&gt;-qq&lt;/code&gt; 같은 옵션 동작합니다 &lt;code&gt;-q&lt;/code&gt; 그것은 또한 완료 deparsing 후 STDERR을 닫 것을 제외하고. 이것은 일반적으로 perl에 의해 생성 된 &quot;Syntax OK&quot;메시지를 억제합니다.</target>
        </trans-unit>
        <trans-unit id="cb173d8eff47f06c7e37f7374c7227453a2ad4d4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-u&lt;/code&gt; switch causes the VMS debugger to be invoked after the Perl program is compiled, but before it has run. It does not create a core dump file.</source>
          <target state="translated">그만큼 &lt;code&gt;-u&lt;/code&gt; 스위치는 펄 프로그램을 컴파일 후 VMS 디버거가 호출되도록하지만 실행하기 전에. 코어 덤프 파일을 작성하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1e542d84460c8b59074b5a3d74792d84cf2329fa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;..&lt;/code&gt; and &lt;code&gt;...&lt;/code&gt; flip-flop operators. Note that the &lt;code&gt;...&lt;/code&gt; flip-flop operator is completely different from the &lt;code&gt;...&lt;/code&gt; elliptical statement just described.</source>
          <target state="translated">&lt;code&gt;..&lt;/code&gt; 그리고 &lt;code&gt;...&lt;/code&gt; 플립 플롭 연산자. 점을 유의 &lt;code&gt;...&lt;/code&gt; 플립 플롭 조작자가 전혀 다른 &lt;code&gt;...&lt;/code&gt; 단지 설명 타원형 문.</target>
        </trans-unit>
        <trans-unit id="8189082aec1c35ce34b10a2a482272d1f9442cdd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;..&lt;/code&gt; range operator treats certain character ranges with care on EBCDIC platforms. For example the following array will have twenty six elements on either an EBCDIC platform or an ASCII platform:</source>
          <target state="translated">그만큼 &lt;code&gt;..&lt;/code&gt; EBCDIC 플랫폼에서주의 범위 연산자 취급 특정 문자 범위를. 예를 들어 다음 배열은 EBCDIC 플랫폼 또는 ASCII 플랫폼에 24 개의 요소가 있습니다.</target>
        </trans-unit>
        <trans-unit id="1bfc1b4066699d36e1a1c96b8bf42e5d376ee7e9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;//&lt;/code&gt; matching operator is documented in &lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt;. It operates on &lt;code&gt;$_&lt;/code&gt; by default, or can be bound to another variable using the &lt;code&gt;=~&lt;/code&gt; binding operator (also documented in &lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;//&lt;/code&gt; 의 매칭 연산자에서 설명 &lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt; . 기본적 으로 &lt;code&gt;$_&lt;/code&gt; 에서 작동 하거나 &lt;code&gt;=~&lt;/code&gt; 바인딩 연산자를 사용하여 다른 변수에 바인딩 할 수 있습니다 (&lt;a href=&quot;perlop&quot;&gt; perlop에&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="32ef826cb43c384876c66cdfd8ef3d6094273ed3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;//a&lt;/code&gt; modifier, available starting in Perl 5.14, is used to restrict the matches of \d, \s, and \w to just those in the ASCII range. It is useful to keep your program from being needlessly exposed to full Unicode (and its accompanying security considerations) when all you want is to process English-like text. (The &quot;a&quot; may be doubled, &lt;code&gt;//aa&lt;/code&gt; , to provide even more restrictions, preventing case-insensitive matching of ASCII with non-ASCII characters; otherwise a Unicode &quot;Kelvin Sign&quot; would caselessly match a &quot;k&quot; or &quot;K&quot;.)</source>
          <target state="translated">&lt;code&gt;//a&lt;/code&gt; 수정, 펄 5.14에서 사용할 수있는 시작은 ASCII 범위에서 그 단지에 승 \ \ D의 일치, \ S를 제한하기 위해 사용된다. 영어와 유사한 텍스트를 처리하기 만하면 프로그램이 불필요하게 완전한 유니 코드 (및 관련 보안 고려 사항)에 노출되지 않도록하는 것이 좋습니다. ( &quot;a&quot;는 두 배가 될 수 있습니다. &lt;code&gt;//aa&lt;/code&gt; ASCII가 아닌 문자와 ASCII를 대소 문자를 구분하지 않는 일치를 막기 위해 더 많은 제한을 제공하기 위해 // aa . 그렇지 않으면 유니 코드 &quot;Kelvin Sign&quot;은 대소 문자가 &quot;k&quot;또는 &quot;K&quot;와 일치합니다. .)</target>
        </trans-unit>
        <trans-unit id="4d28a339cbae1f464fa994976dfeef2db93a1d7d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;/&lt;/code&gt; template character allows packing and unpacking of a sequence of items where the packed structure contains a packed item count followed by the packed items themselves. This is useful when the structure you're unpacking has encoded the sizes or repeat counts for some of its fields within the structure itself as separate fields.</source>
          <target state="translated">&lt;code&gt;/&lt;/code&gt; 템플릿 문자는 포장과 포장 된 구조가 포장 된 상품 자체의 다음에 포장 된 항목 수를 포함 항목의 일련의 포장을 풀 수 있습니다. 이것은 압축을 풀고있는 구조가 구조 자체 내의 일부 필드에 대한 크기 나 반복 횟수를 별도의 필드로 인코딩 한 경우에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="11f550725d5f2471c6ff447b2d5f1594f1eb63d2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;/a&lt;/code&gt; modifier, available starting in Perl 5.14, is used to restrict the matches of &lt;code&gt;\d&lt;/code&gt;, &lt;code&gt;\s&lt;/code&gt;, and &lt;code&gt;\w&lt;/code&gt; to just those in the ASCII range. It is useful to keep your program from being needlessly exposed to full Unicode (and its accompanying security considerations) when all you want is to process English-like text. (The &quot;a&quot; may be doubled, &lt;code&gt;/aa&lt;/code&gt;, to provide even more restrictions, preventing case-insensitive matching of ASCII with non-ASCII characters; otherwise a Unicode &quot;Kelvin Sign&quot; would caselessly match a &quot;k&quot; or &quot;K&quot;.)</source>
          <target state="translated">Perl 5.14부터 사용할 수 있는 &lt;code&gt;/a&lt;/code&gt; 수정자는 &lt;code&gt;\d&lt;/code&gt; , &lt;code&gt;\s&lt;/code&gt; 및 &lt;code&gt;\w&lt;/code&gt; 의 일치를 ASCII 범위에있는 항목으로 만 제한하는 데 사용됩니다 . 영어와 유사한 텍스트를 처리하기 만하면 프로그램이 전체 유니 코드 (및 이에 수반되는 보안 고려 사항)에 불필요하게 노출되지 않도록하는 것이 유용합니다. ( &quot;a&quot;는 더 많은 제한을 제공하기 위해 두 배가 될 수 있습니다. &lt;code&gt;/aa&lt;/code&gt; 는 ASCII가 아닌 ASCII 문자와 대소 문자를 구분하지 않는 일치를 방지합니다. 그렇지 않으면 유니 코드 &quot;Kelvin Sign&quot;이 대소 문자없이 &quot;k&quot;또는 &quot;K&quot;와 일치합니다. )</target>
        </trans-unit>
        <trans-unit id="8377a1a6991c29f230dc12ce290846f6b362ebc8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;/a&lt;/code&gt; modifier, on the other hand, may be useful. Its purpose is to allow code that is to work mostly on ASCII data to not have to concern itself with Unicode.</source>
          <target state="translated">반면에 &lt;code&gt;/a&lt;/code&gt; 수정자는 유용 할 수 있습니다. 그 목적은 ASCII 데이터에서 주로 작동하는 코드가 유니 코드와 관련 될 필요가 없도록하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="4128278fcab003f758fd62a9e37cfc1e76abe115" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;/a&lt;/code&gt;, &lt;code&gt;/d&lt;/code&gt;, &lt;code&gt;/l&lt;/code&gt;, and &lt;code&gt;/u&lt;/code&gt; modifiers (added in Perl 5.14) control the character set rules, but &lt;code&gt;/a&lt;/code&gt; is the only one you are likely to want to specify explicitly; the other three are selected automatically by various pragmas.</source>
          <target state="translated">&lt;code&gt;/a&lt;/code&gt; , &lt;code&gt;/d&lt;/code&gt; 를 , &lt;code&gt;/l&lt;/code&gt; 및 &lt;code&gt;/u&lt;/code&gt; 수정은 문자 집합 규칙을 제어 (펄 5.14에서 추가)하지만, &lt;code&gt;/a&lt;/code&gt; 당신은 가능성이 명시 적으로 지정하려면 할 수있는 단 하나입니다; 나머지 세 개는 다양한 pragma에 의해 자동으로 선택됩니다.</target>
        </trans-unit>
        <trans-unit id="9d46362c6dee371fc1e41d5a94fbe9c509a82363" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;/d&lt;/code&gt;, &lt;code&gt;/u&lt;/code&gt; , and &lt;code&gt;/l&lt;/code&gt; modifiers are not likely to be of much use to you, and so you need not worry about them very much. They exist for Perl's internal use, so that complex regular expression data structures can be automatically serialized and later exactly reconstituted, including all their nuances. But, since Perl can't keep a secret, and there may be rare instances where they are useful, they are documented here.</source>
          <target state="translated">&lt;code&gt;/d&lt;/code&gt; , &lt;code&gt;/u&lt;/code&gt; , 및 &lt;code&gt;/l&lt;/code&gt; 수정 가능성이 당신에게 매우 유용 할, 당신은 매우 그들에 대해 걱정할 필요가 없습니다 그래서는 안된다. 그것들은 Perl의 내부 사용을 위해 존재하므로 복잡한 정규 표현식 데이터 구조를 자동으로 직렬화하고 나중에 모든 뉘앙스를 포함하여 정확하게 재구성 할 수 있습니다. 그러나 Perl은 비밀을 유지할 수 없으며 유용한 경우가 드물기 때문에 여기에 문서화되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="12ab225e2a1f0826b5de7058218cdd1f025dae16" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;/d&lt;/code&gt;, &lt;code&gt;/u&lt;/code&gt;, and &lt;code&gt;/l&lt;/code&gt; modifiers are not likely to be of much use to you, and so you need not worry about them very much. They exist for Perl's internal use, so that complex regular expression data structures can be automatically serialized and later exactly reconstituted, including all their nuances. But, since Perl can't keep a secret, and there may be rare instances where they are useful, they are documented here.</source>
          <target state="translated">&lt;code&gt;/d&lt;/code&gt; 를 , &lt;code&gt;/u&lt;/code&gt; , 및 &lt;code&gt;/l&lt;/code&gt; 수정 가능성이 당신에게 매우 유용 할, 당신은 매우 그들에 대해 걱정할 필요가 없습니다 그래서는 안된다. Perl의 내부 사용을 위해 존재하므로 복잡한 정규식 데이터 구조를 자동으로 직렬화하고 나중에 모든 뉘앙스를 포함하여 정확하게 재구성 할 수 있습니다. 그러나 Perl은 비밀을 유지할 수 없으며 유용한 경우가 드물기 때문에 여기에 문서화되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="7a635bd3deb5f6d1f8ced7e30d0ca4af436ee119" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;/e&lt;/code&gt; will also silently ignore violations of strict, replacing undefined variable names with the empty string. Since I'm using the &lt;code&gt;/e&lt;/code&gt; flag (twice even!), I have all of the same security problems I have with &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; in its string form. If there's something odd in &lt;code&gt;$foo&lt;/code&gt; , perhaps something like &lt;code&gt;@{[ &lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt; &quot;rm -rf /&quot; ]}&lt;/code&gt; , then I could get myself in trouble.</source>
          <target state="translated">&lt;code&gt;/e&lt;/code&gt; 또한 자동으로 빈 문자열로 정의되지 않은 변수 이름을 대체 엄격한 위반을 무시합니다. &lt;code&gt;/e&lt;/code&gt; 플래그를 사용하고 있기 때문에 (두 번이라도!) &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 과 동일한 보안 문제가 모두 문자열 형식입니다. &lt;code&gt;@{[ &lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt; &quot;rm -rf /&quot; ]}&lt;/code&gt; [@ &quot; [ &lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt; &quot;rm -rf / &quot;]} 와 같이 &lt;code&gt;$foo&lt;/code&gt; 이상한 것이 있으면 문제가 생길 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b81362cf7da8bf9fa9ba69433decc106d6e660e6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;/e&lt;/code&gt; will also silently ignore violations of strict, replacing undefined variable names with the empty string. Since I'm using the &lt;code&gt;/e&lt;/code&gt; flag (twice even!), I have all of the same security problems I have with &lt;code&gt;eval&lt;/code&gt; in its string form. If there's something odd in &lt;code&gt;$foo&lt;/code&gt;, perhaps something like &lt;code&gt;@{[ system &quot;rm -rf /&quot; ]}&lt;/code&gt;, then I could get myself in trouble.</source>
          <target state="translated">&lt;code&gt;/e&lt;/code&gt; 또한 자동으로 빈 문자열로 정의되지 않은 변수 이름을 대체 엄격한 위반을 무시합니다. 내가 사용하고 있기 때문에 &lt;code&gt;/e&lt;/code&gt; 플래그 (2 회도!), 내가 함께이 같은 보안 문제 모두가 &lt;code&gt;eval&lt;/code&gt; 의 문자열 형태를. &lt;code&gt;$foo&lt;/code&gt; 뭔가 이상한 것이 있다면 , 아마도 &lt;code&gt;@{[ system &quot;rm -rf /&quot; ]}&lt;/code&gt; 같은 것이라면 문제가 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="613bcc3a2284ecc4926054a5b934f30e880d5007" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;/g&lt;/code&gt; modifier specifies global pattern matching--that is, matching as many times as possible within the string. How it behaves depends on the context. In list context, it returns a list of the substrings matched by any capturing parentheses in the regular expression. If there are no parentheses, it returns a list of all the matched strings, as if there were parentheses around the whole pattern.</source>
          <target state="translated">&lt;code&gt;/g&lt;/code&gt; 개질제 지정 글로벌 패턴 매칭 - 스트링 내의 가능한 횟수만큼 매칭된다. 동작 방식은 상황에 따라 다릅니다. 리스트 컨텍스트에서, 정규 표현식에서 캡처 괄호와 일치하는 서브 스트링 목록을 리턴합니다. 괄호가 없으면 전체 패턴 주위에 괄호가있는 것처럼 일치하는 모든 문자열의 목록을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="987314591903795033c1fec25347d7b594aec577" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;/l&lt;/code&gt; and &lt;code&gt;/u&lt;/code&gt; modifiers are automatically selected for regular expressions compiled within the scope of various pragmas, and we recommend that in general, you use those pragmas instead of specifying these modifiers explicitly. For one thing, the modifiers affect only pattern matching, and do not extend to even any replacement done, whereas using the pragmas give consistent results for all appropriate operations within their scopes. For example,</source>
          <target state="translated">&lt;code&gt;/l&lt;/code&gt; 및 &lt;code&gt;/u&lt;/code&gt; 수식이 자동으로 각종 프라 그마의 범위 내에서 컴파일 된 정규 표현식으로 선택, 우리가 일반적으로 대신 명시 적으로 이러한 수정을 지정하는 그 프라그 마를 사용하는 것이 좋습니다된다. 우선 수정자는 패턴 일치에만 영향을 미치며 대체 작업으로 확장되지는 않지만 pragma를 사용하면 해당 범위 내의 모든 적절한 작업에 대해 일관된 결과를 얻을 수 있습니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="2a3e23c2d6681fc3d86e431f129513cbcb6ae252" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;/l&lt;/code&gt; and &lt;code&gt;/u&lt;/code&gt; modifiers are automatically selected for regular expressions compiled within the scope of various pragmas, and we recommend that in general, you use those pragmas instead of specifying these modifiers explicitly. For one thing, the modifiers affect only pattern matching, and do not extend to even any replacement done, whereas using the pragmas gives consistent results for all appropriate operations within their scopes. For example,</source>
          <target state="translated">&lt;code&gt;/l&lt;/code&gt; 및 &lt;code&gt;/u&lt;/code&gt; 수식이 자동으로 각종 프라 그마의 범위 내에서 컴파일 된 정규 표현식으로 선택, 우리가 일반적으로 대신 명시 적으로 이러한 수정을 지정하는 그 프라그 마를 사용하는 것이 좋습니다된다. 한 가지로, 수정자는 패턴 일치에만 영향을 미치고, 대체가 수행 된 경우에도 확장되지 않는 반면, pragma를 사용하면 해당 범위 내의 모든 적절한 작업에 대해 일관된 결과를 얻을 수 있습니다. 예를 들면</target>
        </trans-unit>
        <trans-unit id="9a222e38b5a40a1bf140094ce44f5b0c1b82a0ec" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;/o&lt;/code&gt; option for regular expressions (documented in &lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt; and &lt;a href=&quot;perlreref&quot;&gt;perlreref&lt;/a&gt;) tells Perl to compile the regular expression only once. This is only useful when the pattern contains a variable. Perls 5.6 and later handle this automatically if the pattern does not change.</source>
          <target state="translated">&lt;code&gt;/o&lt;/code&gt; 정규 표현식 옵션 (에 설명 &lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt; 와 &lt;a href=&quot;perlreref&quot;&gt;perlreref는&lt;/a&gt; ) 한 번만 정규 표현식을 컴파일 펄을 알려줍니다. 패턴에 변수가 포함 된 경우에만 유용합니다. 패턴이 변경되지 않으면 Perls 5.6 이상에서이를 자동으로 처리합니다.</target>
        </trans-unit>
        <trans-unit id="02f1967b4475720a962bf35cfc3049c63165e0f6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;/x&lt;/code&gt; modifier causes whitespace to be ignored in a regex pattern (except in a character class and a few other places), and also allows you to use normal comments there, too. As you can imagine, whitespace and comments help a lot.</source>
          <target state="translated">&lt;code&gt;/x&lt;/code&gt; (문자 클래스와 몇 가지 다른 장소에서 제외) 정규식 패턴을 무시하고, 또한 당신도이 일반 의견을 사용할 수 있도록 할 공백 수정됩니다. 상상할 수 있듯이 공백과 주석은 많은 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="26a965e97d532904de76cbb5ec7fa62c78040c70" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;0x&lt;/code&gt; prefix means a hexadecimal number, the digits are 0-9</source>
          <target state="translated">&lt;code&gt;0x&lt;/code&gt; 프리픽스는 16 진수를 의미하며, 숫자는 0-9</target>
        </trans-unit>
        <trans-unit id="c084ffd08879b68d48b86f14b0edd6d007fd471f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:&lt;a href=&quot;../functions/glob&quot;&gt;glob&lt;/a&gt;&lt;/code&gt; tag, now discouraged, is the old version of &lt;code&gt;:bsd_glob&lt;/code&gt; . It exports the same constants and functions, but its glob() override does not support iteration; it returns the last file name in scalar context. That means this will loop forever:</source>
          <target state="translated">&lt;code&gt;:&lt;a href=&quot;../functions/glob&quot;&gt;glob&lt;/a&gt;&lt;/code&gt; 태그, 지금 낙심은 이전 버전입니다 &lt;code&gt;:bsd_glob&lt;/code&gt; . 동일한 상수와 함수를 내보내지만 glob () 재정의는 반복을 지원하지 않습니다. 스칼라 컨텍스트에서 마지막 파일 이름을 반환합니다. 이것은 이것이 영원히 반복된다는 것을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="4231c54d461bf5e25a3f991c3ecf987daad7c115" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:ALL&lt;/code&gt; tag will get all of the above exports.</source>
          <target state="translated">&lt;code&gt;:ALL&lt;/code&gt; 의 태그는 위의 수출을 모두 얻을 것이다.</target>
        </trans-unit>
        <trans-unit id="f4ffb1e41b5af144e1e66d6009daba34fcfe78d8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:bsd_glob&lt;/code&gt; export tag exports bsd_glob() and the constants listed below. It also overrides glob() in the calling package with one that behaves like bsd_glob() with regard to spaces (the space is treated as part of a file name), but supports iteration in scalar context; i.e., it preserves the core function's feature of returning the next item each time it is called.</source>
          <target state="translated">&lt;code&gt;:bsd_glob&lt;/code&gt; 수출 태그 수출 bsd_glob () 아래에 나열된 상수. 또한 호출 패키지의 glob ()를 공백 (파일 이름의 일부로 처리)과 관련하여 bsd_glob ()처럼 동작하지만 스칼라 컨텍스트에서 반복을 지원하는 glob ()를 대체합니다. 즉, 호출 될 때마다 다음 항목을 반환하는 핵심 기능의 기능을 유지합니다.</target>
        </trans-unit>
        <trans-unit id="e5933b7ecdff0d26d0d1ee137373273e087ab3ea" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:bytes&lt;/code&gt; , &lt;code&gt;:crlf&lt;/code&gt; , &lt;code&gt;:utf8&lt;/code&gt; , and any other directives of the form &lt;code&gt;:...&lt;/code&gt; , are called I/O</source>
          <target state="translated">&lt;code&gt;:bytes&lt;/code&gt; , &lt;code&gt;:crlf&lt;/code&gt; , &lt;code&gt;:utf8&lt;/code&gt; , 양식의 다른 지시가 &lt;code&gt;:...&lt;/code&gt; , I / O라고</target>
        </trans-unit>
        <trans-unit id="586c160f0002e3dc300faf81c49d6dc770a315b9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:bytes&lt;/code&gt; layer corresponds to &quot;binary mode&quot; and the &lt;code&gt;:crlf&lt;/code&gt; layer corresponds to &quot;text mode&quot; on platforms that distinguish between the two modes when opening files (which is many DOS-like platforms, including Windows). These two layers are no-ops on platforms where binmode() is a no-op, but perform their functions everywhere if PerlIO is enabled.</source>
          <target state="translated">는 &lt;code&gt;:bytes&lt;/code&gt; &quot;바이너리 모드&quot;및에 레이어 대응을 &lt;code&gt;:crlf&lt;/code&gt; (윈도우 등 많은 DOS와 같은 플랫폼 인) 파일을 열 때 두 모드 사이를 구별 플랫폼에서 &quot;텍스트 모드&quot;로 레이어에 해당합니다. binmode ()가 no-op 인 플랫폼에서이 두 계층은 no-op이지만 PerlIO가 활성화 된 경우 어디서나 기능을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="11a84ca57962b97df10238d25c4ab7c8ca38ba9d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:bytes&lt;/code&gt;, &lt;code&gt;:crlf&lt;/code&gt;, &lt;code&gt;:utf8&lt;/code&gt;, and any other directives of the form &lt;code&gt;:...&lt;/code&gt;, are called I/O</source>
          <target state="translated">&lt;code&gt;:bytes&lt;/code&gt; , &lt;code&gt;:crlf&lt;/code&gt; , &lt;code&gt;:utf8&lt;/code&gt; , 양식의 다른 지시가 &lt;code&gt;:...&lt;/code&gt; , I / O라고</target>
        </trans-unit>
        <trans-unit id="ec6da40dddc20e97c2aa930b3dff507bcb27589f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:default&lt;/code&gt; bundle represents the feature set that is enabled before any &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; feature&lt;/code&gt; declaration.</source>
          <target state="translated">&lt;code&gt;:default&lt;/code&gt; 번들은 이전에 활성화 된 기능 세트를 나타냅니다 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; feature&lt;/code&gt; 선언.</target>
        </trans-unit>
        <trans-unit id="09364c3e01a418de2009247f52456634c275c2f2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:default&lt;/code&gt; bundle represents the feature set that is enabled before any &lt;code&gt;use feature&lt;/code&gt; or &lt;code&gt;no feature&lt;/code&gt; declaration.</source>
          <target state="translated">&lt;code&gt;:default&lt;/code&gt; 번들은 이전에 활성화 된 기능 세트를 나타냅니다 &lt;code&gt;use feature&lt;/code&gt; 또는 &lt;code&gt;no feature&lt;/code&gt; 선언.</target>
        </trans-unit>
        <trans-unit id="229b3ff64bd12a209b4e991d14388add7cc976a2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:glob&lt;/code&gt; tag, now discouraged, is the old version of &lt;code&gt;:bsd_glob&lt;/code&gt;. It exports the same constants and functions, but its glob() override does not support iteration; it returns the last file name in scalar context. That means this will loop forever:</source>
          <target state="translated">&lt;code&gt;:glob&lt;/code&gt; 태그, 지금 낙심은 이전 버전입니다 &lt;code&gt;:bsd_glob&lt;/code&gt; . 동일한 상수와 함수를 내보내지만 glob () 재정의는 반복을 지원하지 않습니다. 스칼라 컨텍스트에서 마지막 파일 이름을 반환합니다. 이는 이것이 영원히 반복된다는 것을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="a790449d8cd7160d313e0f6fd7d2b5f5cd711410" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:gzip_external&lt;/code&gt; requires one boolean argument.</source>
          <target state="translated">&lt;code&gt;:gzip_external&lt;/code&gt; 는 하나 개 부울 인수가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="bc95aee8e2b941e818640ac51c8f3c3052958780" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:gzip_external&lt;/code&gt; requires one string argument.</source>
          <target state="translated">&lt;code&gt;:gzip_external&lt;/code&gt; 는 하나 개의 문자열 인수가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="d6ef1d12b23a99b06dce59bf86591d40b628073e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:gzip_read_open&lt;/code&gt; argument must end with the pipe sign (|) and have the &lt;code&gt;%s&lt;/code&gt; for the filename. See &lt;a href=&quot;#USING-THE-EXTERNAL-GZIP&quot;&gt;&quot;USING THE EXTERNAL GZIP&quot;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;:gzip_read_open&lt;/code&gt; (|)를하고,이 인수는 파이프 기호로 끝나야 &lt;code&gt;%s&lt;/code&gt; 파일 이름에 대해. &lt;a href=&quot;#USING-THE-EXTERNAL-GZIP&quot;&gt;&quot;외부 GZIP 사용&quot;을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="20c0f5f557ffbe0666f0dfcd916d2b61a638ef52" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:gzip_read_open&lt;/code&gt; argument must end with the pipe sign (|) and have the &lt;code&gt;%s&lt;/code&gt; for the filename. See &lt;a href=&quot;#USING-THE-EXTERNAL-GZIP&quot;&gt;USING THE EXTERNAL GZIP&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;:gzip_read_open&lt;/code&gt; (|)를하고,이 인수는 파이프 기호로 끝나야 &lt;code&gt;%s&lt;/code&gt; 파일 이름에 대해. &lt;a href=&quot;#USING-THE-EXTERNAL-GZIP&quot;&gt;외부 GZIP 사용을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c09f18a82aa110a317c88049c0e7c4128399d22c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:gzip_write_open&lt;/code&gt; argument must begin with the pipe sign (|) and have the &lt;code&gt;%s&lt;/code&gt; for the filename. An output redirect (&amp;gt;) is also often a good idea, depending on your operating system shell syntax. See &lt;a href=&quot;#USING-THE-EXTERNAL-GZIP&quot;&gt;&quot;USING THE EXTERNAL GZIP&quot;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;:gzip_write_open&lt;/code&gt; (|)를하고,이 인수는 파이프 기호로 시작해야합니다 &lt;code&gt;%s&lt;/code&gt; 파일 이름에 대해. 운영 체제 셸 구문에 따라 출력 리디렉션 (&amp;gt;)도 종종 좋은 생각입니다. &lt;a href=&quot;#USING-THE-EXTERNAL-GZIP&quot;&gt;&quot;외부 GZIP 사용&quot;을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="740fe127c4ced02d559ebb2a859c745ac796eb7c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:gzip_write_open&lt;/code&gt; argument must begin with the pipe sign (|) and have the &lt;code&gt;%s&lt;/code&gt; for the filename. An output redirect (&amp;gt;) is also often a good idea, depending on your operating system shell syntax. See &lt;a href=&quot;#USING-THE-EXTERNAL-GZIP&quot;&gt;USING THE EXTERNAL GZIP&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;:gzip_write_open&lt;/code&gt; (|)를하고,이 인수는 파이프 기호로 시작해야합니다 &lt;code&gt;%s&lt;/code&gt; 파일 이름에 대해. 운영 체제 셸 구문에 따라 출력 리디렉션 (&amp;gt;)도 종종 좋은 생각입니다. &lt;a href=&quot;#USING-THE-EXTERNAL-GZIP&quot;&gt;외부 GZIP 사용을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="244205effe1c86456dd4171100ec82efbb0324f4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:locale&lt;/code&gt; does not currently work with &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode()&lt;/a&gt;&lt;/code&gt;, only with the &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; pragma. The &lt;code&gt;:utf8&lt;/code&gt; and &lt;code&gt;:encoding(...)&lt;/code&gt; methods do work with all of &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode()&lt;/a&gt;&lt;/code&gt;, and the &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; pragma.</source>
          <target state="translated">&lt;code&gt;:locale&lt;/code&gt; 현재 작동하지 않습니다 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; 와 &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode()&lt;/a&gt;&lt;/code&gt; 단지로, &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; 프라그. &lt;code&gt;:utf8&lt;/code&gt; 과 &lt;code&gt;:encoding(...)&lt;/code&gt; 방법이 모두와 함께 일을 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode()&lt;/a&gt;&lt;/code&gt; , 그리고 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; 프라 그마.</target>
        </trans-unit>
        <trans-unit id="868d235ace169d2c7fa342c5a97f5b35d506dd95" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:locale&lt;/code&gt; does not currently work with &lt;code&gt;open()&lt;/code&gt; and &lt;code&gt;binmode()&lt;/code&gt;, only with the &lt;code&gt;open&lt;/code&gt; pragma. The &lt;code&gt;:utf8&lt;/code&gt; and &lt;code&gt;:encoding(...)&lt;/code&gt; methods do work with all of &lt;code&gt;open()&lt;/code&gt;, &lt;code&gt;binmode()&lt;/code&gt;, and the &lt;code&gt;open&lt;/code&gt; pragma.</source>
          <target state="translated">&lt;code&gt;:locale&lt;/code&gt; 현재 작동하지 않습니다 &lt;code&gt;open()&lt;/code&gt; 와 &lt;code&gt;binmode()&lt;/code&gt; 단지로, &lt;code&gt;open&lt;/code&gt; 프라그. &lt;code&gt;:utf8&lt;/code&gt; 과 &lt;code&gt;:encoding(...)&lt;/code&gt; 방법이 모두와 함께 일을 &lt;code&gt;open()&lt;/code&gt; , &lt;code&gt;binmode()&lt;/code&gt; , 그리고 &lt;code&gt;open&lt;/code&gt; 프라 그마.</target>
        </trans-unit>
        <trans-unit id="b0a7c262fbc0be9a9844fe48c62a845c0f4528fd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:locale&lt;/code&gt; sub-pragma</source>
          <target state="translated">&lt;code&gt;:locale&lt;/code&gt; 의 서브 프라 그마</target>
        </trans-unit>
        <trans-unit id="90148b6fce0bbabdeb9d2a0e71e782bdff20ba4b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:mmap&lt;/code&gt; layer will not exist if the platform does not support &lt;code&gt;mmap()&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;:mmap&lt;/code&gt; 에의 플랫폼이 지원하지 않는 경우 레이어가 존재하지 않습니다 &lt;code&gt;mmap()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="81e4222eb657623bdd73dc5a2ea005b2d704479c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:mmap&lt;/code&gt; layer will not exist if the platform does not support &lt;code&gt;mmap()&lt;/code&gt;. See &lt;a href=&quot;PerlIO::mmap&quot;&gt;PerlIO::mmap&lt;/a&gt; for more information.</source>
          <target state="translated">&lt;code&gt;:mmap&lt;/code&gt; 에의 플랫폼이 지원하지 않는 경우 레이어가 존재하지 않습니다 &lt;code&gt;mmap()&lt;/code&gt; . 자세한 내용은 &lt;a href=&quot;PerlIO::mmap&quot;&gt;PerlIO :: mmap&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="fd944a87b4f64134b2d5190fde7ca74a27bd05a6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:raw&lt;/code&gt; layer is</source>
          <target state="translated">&lt;code&gt;:raw&lt;/code&gt; 층은</target>
        </trans-unit>
        <trans-unit id="9474a45f1b69ac0f4649940b34d53df78423a114" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:raw&lt;/code&gt; pseudo-layer is</source>
          <target state="translated">&lt;code&gt;:raw&lt;/code&gt; 유사 층이다</target>
        </trans-unit>
        <trans-unit id="eb8af45fe08808536fe0e78893d59ec120f251eb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:std&lt;/code&gt; subpragma on its own has no effect, but if combined with the &lt;code&gt;:utf8&lt;/code&gt; or &lt;code&gt;:encoding&lt;/code&gt; subpragmas, it converts the standard filehandles (STDIN, STDOUT, STDERR) to comply with encoding selected for input/output handles. For example, if both input and out are chosen to be &lt;code&gt;:encoding(utf8)&lt;/code&gt; , a &lt;code&gt;:std&lt;/code&gt; will mean that STDIN, STDOUT, and STDERR are also in &lt;code&gt;:encoding(utf8)&lt;/code&gt; . On the other hand, if only output is chosen to be in &lt;code&gt;:encoding(koi8r)&lt;/code&gt; , a &lt;code&gt;:std&lt;/code&gt; will cause only the STDOUT and STDERR to be in &lt;code&gt;koi8r&lt;/code&gt; . The &lt;code&gt;:locale&lt;/code&gt; subpragma implicitly turns on &lt;code&gt;:std&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;:std&lt;/code&gt; 자체 subpragma 아무 효과가 없지만, 결합하는 경우 &lt;code&gt;:utf8&lt;/code&gt; 또는 &lt;code&gt;:encoding&lt;/code&gt; subpragmas를 그 입력 / 출력 핸들 선정 인코딩 준수하는 표준 파일 핸들 (STDIN, STDOUT, STDERR)를 변환한다. 예를 들어, 입력과 출력이 모두 &lt;code&gt;:encoding(utf8)&lt;/code&gt; 으로 선택된 경우 &lt;code&gt;:std&lt;/code&gt; 는 STDIN, STDOUT 및 STDERR도 &lt;code&gt;:encoding(utf8)&lt;/code&gt; 합니다. 반면, 출력 만 &lt;code&gt;:encoding(koi8r)&lt;/code&gt; 에 있도록 선택하면 &lt;code&gt;:std&lt;/code&gt; 는 STDOUT 및 STDERR 만 &lt;code&gt;koi8r&lt;/code&gt; 에있게 합니다. &lt;code&gt;:locale&lt;/code&gt; subpragma 암시 적으로 켜집니다 &lt;code&gt;:std&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2743b792818bf7f895d0f0b22baae763060aa81f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:void&lt;/code&gt; option is supported in &lt;a href=&quot;fatal&quot;&gt;Fatal&lt;/a&gt;, but not &lt;code&gt;autodie&lt;/code&gt; . To workaround this, &lt;code&gt;autodie&lt;/code&gt; may be explicitly disabled until the end of the current block with &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; autodie&lt;/code&gt; . To disable autodie for only a single function (eg, open) use &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; autodie qw(open)&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;:void&lt;/code&gt; 옵션이 지원됩니다 &lt;a href=&quot;fatal&quot;&gt;치명적인&lt;/a&gt; 있지만 &lt;code&gt;autodie&lt;/code&gt; . 이 문제를 해결하려면, &lt;code&gt;autodie&lt;/code&gt; 은 명시 적으로 현재 블록이 끝날 때까지 해제 할 수 &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; autodie&lt;/code&gt; . 단일 기능 (예 : 열기)에 대해서만 자동 die를 비활성화하려면 &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; autodie qw(open)&lt;/code&gt; 사용 &lt;a href=&quot;functions/no&quot;&gt;하지&lt;/a&gt; 마십시오 .</target>
        </trans-unit>
        <trans-unit id="0969ef951925275c4d8bd4c9c51662e300f9c641" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:void&lt;/code&gt; option is supported in &lt;a href=&quot;fatal&quot;&gt;Fatal&lt;/a&gt;, but not &lt;code&gt;autodie&lt;/code&gt;. To workaround this, &lt;code&gt;autodie&lt;/code&gt; may be explicitly disabled until the end of the current block with &lt;code&gt;no autodie&lt;/code&gt;. To disable autodie for only a single function (eg, open) use &lt;code&gt;no autodie qw(open)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;:void&lt;/code&gt; 옵션이 지원됩니다 &lt;a href=&quot;fatal&quot;&gt;치명적인&lt;/a&gt; 있지만 &lt;code&gt;autodie&lt;/code&gt; . 이 문제를 해결하기 위해 &lt;code&gt;autodie&lt;/code&gt; 가 &lt;code&gt;no autodie&lt;/code&gt; 현재 블록이 끝날 때까지 autodie를 명시 적으로 비활성화 할 수 있습니다 . 단일 기능 (예 : open)에 대해서만 autodie를 비활성화하려면 &lt;code&gt;no autodie qw(open)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="67318be992f4377bb68fbe49ed99f910c657a047" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../../functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; method is used to create an instance of the filter. It is called indirectly by Perl when it encounters the &lt;code&gt;&lt;a href=&quot;../../functions/use&quot;&gt;use&lt;/a&gt; MyFilter&lt;/code&gt; line in a source file (See &lt;a href=&quot;../../functions/import&quot;&gt;import&lt;/a&gt; for more details on &lt;code&gt;&lt;a href=&quot;../../functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../../functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; 방법은 필터의 인스턴스를 생성하기 위해 사용된다. 가 발생할 때 그것은 펄에 의해 간접적으로 호출되어 &lt;code&gt;&lt;a href=&quot;../../functions/use&quot;&gt;use&lt;/a&gt; MyFilter&lt;/code&gt; 소스 파일의 라인 (참조 &lt;a href=&quot;../../functions/import&quot;&gt;가져 오기&lt;/a&gt; 에 대한 자세한 내용은 &lt;code&gt;&lt;a href=&quot;../../functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="69849addd7818fee9c7e8c167a05d6c0d2986859" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../functions/read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; will</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../functions/read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; 의지</target>
        </trans-unit>
        <trans-unit id="0eafa6355d483056647b2819a7f67215461c3497" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; call returns an object, say &lt;code&gt;$o&lt;/code&gt; . You may call</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; 호출이 반환 객체는 말할 &lt;code&gt;$o&lt;/code&gt; . 전화 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="51ffe3fc21c6601c2932126d4f4eca5123604eda" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;delete&quot;&gt;delete&lt;/a&gt; &lt;a href=&quot;local&quot;&gt;local&lt;/a&gt; EXPR&lt;/code&gt; construct can also be used to localize the deletion of array/hash elements to the current block. See &lt;a href=&quot;../perlsub#Localized-deletion-of-elements-of-composite-types&quot;&gt;Localized deletion of elements of composite types in perlsub&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;delete&quot;&gt;delete&lt;/a&gt; &lt;a href=&quot;local&quot;&gt;local&lt;/a&gt; EXPR&lt;/code&gt; 구조체는 상기 현재 블록에 배열 / 해시 요소의 삭제를 로컬 화하는데 사용될 수있다. &lt;a href=&quot;../perlsub#Localized-deletion-of-elements-of-composite-types&quot;&gt;perlsub에서 복합 유형 요소의 현지화 된 삭제를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b1621ad946434d6c08e6becea5950298e8d654de" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;delete&quot;&gt;delete&lt;/a&gt; &lt;a href=&quot;local&quot;&gt;local&lt;/a&gt; EXPR&lt;/code&gt; construct localizes the deletion to the current block at run time. Until the block exits, elements locally deleted temporarily no longer exist. See &lt;a href=&quot;../perlsub#Localized-deletion-of-elements-of-composite-types&quot;&gt;Localized deletion of elements of composite types in perlsub&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;delete&quot;&gt;delete&lt;/a&gt; &lt;a href=&quot;local&quot;&gt;local&lt;/a&gt; EXPR&lt;/code&gt; 구조는 실행시 현재 블록 삭제를 지역화. 블록이 종료 될 때까지 로컬에서 로컬로 삭제 된 요소는 더 이상 존재하지 않습니다. &lt;a href=&quot;../perlsub#Localized-deletion-of-elements-of-composite-types&quot;&gt;perlsub에서 복합 유형 요소의 현지화 된 삭제를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="413b32076323a1b9dc32ef8307740eba59479274" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; function executes a system command</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; 함수는 시스템 명령을 실행</target>
        </trans-unit>
        <trans-unit id="2195a8cff19304cef2dc99fbcce68cf6dbdaf4fc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/alarm&quot;&gt;alarm()&lt;/a&gt;&lt;/code&gt; function is not implemented on all versions of Windows. Check the documentation for your specific version of Perl.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/alarm&quot;&gt;alarm()&lt;/a&gt;&lt;/code&gt; 함수는 윈도우의 모든 버전에서 구현되지 않습니다. 특정 버전의 Perl에 대한 설명서를 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="1cc7a7cd989d44101ffb59063ba0d9ec90f901e1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; operator will attempt to insure that no translation of carriage control occurs on input from or output to this filehandle. Since this involves reopening the file and then restoring its file position indicator, if this function returns FALSE, the underlying filehandle may no longer point to an open file, or may point to a different position in the file than before &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; was called.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; 운영자는 캐리지 제어의 번역문이 핸들에의 입력 또는 출력을 발생하지 않도록 보장하기 위해 시도 할 것이다. 여기에는 파일을 다시 연 다음 파일 위치 표시기를 복원하는 것이 포함되므로이 함수가 FALSE를 반환하면 기본 파일 핸들이 더 이상 열린 파일을 가리 키지 않거나 파일에서 &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; 가 호출 되기 전과 다른 위치를 가리킬 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d7b9155394683e2730126a87d41bdd8b7ec8ee0f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr()&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/ord&quot;&gt;ord()&lt;/a&gt;&lt;/code&gt; functions work on whole characters.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr()&lt;/a&gt;&lt;/code&gt; 와 &lt;code&gt;&lt;a href=&quot;functions/ord&quot;&gt;ord()&lt;/a&gt;&lt;/code&gt; 전체 문자의 기능이 작동합니다.</target>
        </trans-unit>
        <trans-unit id="b8d018fd592275cef4c6f8f9148b669393d46ef8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/crypt&quot;&gt;crypt&lt;/a&gt;&lt;/code&gt; operator uses the &lt;code&gt;sys$hash_password&lt;/code&gt; system service to generate the hashed representation of PLAINTEXT. If USER is a valid username, the algorithm and salt values are taken from that user's UAF record. If it is not, then the preferred algorithm and a salt of 0 are used. The quadword encrypted value is returned as an 8-character string.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/crypt&quot;&gt;crypt&lt;/a&gt;&lt;/code&gt; 운영자는 사용 &lt;code&gt;sys$hash_password&lt;/code&gt; PLAINTEXT의 해시 표현을 생성하는 시스템 서비스입니다. USER가 유효한 사용자 이름 인 경우 알고리즘 및 솔트 값은 해당 사용자의 UAF 레코드에서 가져옵니다. 그렇지 않은 경우 선호하는 알고리즘과 0의 소금이 사용됩니다. 쿼드 워드 암호화 값은 8 자 문자열로 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="51567ba352ff0d9256d32ae3d4a4cc5e55c3b1bc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/delete&quot;&gt;delete&lt;/a&gt; &lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt; EXPR&lt;/code&gt; construct can also be used to localize the deletion of array/hash elements to the current block. See &lt;a href=&quot;perlsub#Localized-deletion-of-elements-of-composite-types&quot;&gt;Localized deletion of elements of composite types in perlsub&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/delete&quot;&gt;delete&lt;/a&gt; &lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt; EXPR&lt;/code&gt; 구조체는 상기 현재 블록에 배열 / 해시 요소의 삭제를 로컬 화하는데 사용될 수있다. &lt;a href=&quot;perlsub#Localized-deletion-of-elements-of-composite-types&quot;&gt;perlsub에서 복합 유형 요소의 현지화 된 삭제를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="205f4f4c053e1354b5fd41e9a973041210cd6cb4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/delete&quot;&gt;delete&lt;/a&gt; &lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt; EXPR&lt;/code&gt; construct localizes the deletion to the current block at run time. Until the block exits, elements locally deleted temporarily no longer exist. See &lt;a href=&quot;perlsub#Localized-deletion-of-elements-of-composite-types&quot;&gt;Localized deletion of elements of composite types in perlsub&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/delete&quot;&gt;delete&lt;/a&gt; &lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt; EXPR&lt;/code&gt; 구조는 실행시 현재 블록 삭제를 지역화. 블록이 종료 될 때까지 로컬에서 로컬로 삭제 된 요소는 더 이상 존재하지 않습니다. &lt;a href=&quot;perlsub#Localized-deletion-of-elements-of-composite-types&quot;&gt;perlsub에서 복합 유형 요소의 현지화 된 삭제를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="7c330ed0d1614413aef6482d1172074b901ca8ba" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt; {}&lt;/code&gt; construct isn't a real loop that you can use loop control on.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt; {}&lt;/code&gt; 구조는에 루프 제어를 사용할 수있는 진짜 루프가 아닙니다.</target>
        </trans-unit>
        <trans-unit id="bf5bbfe9093c8abccc03e7c7efe8dbe3d8e0233d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each()&lt;/a&gt;&lt;/code&gt; operator can be a bit tricky though. You can't add or delete keys of the hash while you're using it without possibly skipping or re-processing some pairs after Perl internally rehashes all of the elements. Additionally, a hash has only one iterator, so if you mix &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/values&quot;&gt;values&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; on the same hash, you risk resetting the iterator and messing up your processing. See the &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; entry in &lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt; for more details.</source>
          <target state="translated">하지만 &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each()&lt;/a&gt;&lt;/code&gt; 연산자는 약간 까다로울 수 있습니다. Perl이 내부적으로 모든 요소를 ​​다시 해시 한 후 일부 쌍을 건너 뛰거나 다시 처리하지 않고 사용하는 동안 해시 키를 추가하거나 삭제할 수 없습니다. 또한 해시에는 반복자가 하나만 있으므로 &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/values&quot;&gt;values&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; 을 동일한 해시에 혼합 하면 반복기를 재설정하고 처리를 망칠 위험이 있습니다. 자세한 내용은 &lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt; 의 &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; 항목 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="6a7ce17abb69e82a8250b438247bf503d68963f6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; operator returns the pairs in apparently random order, so if ordering matters to you, you'll have to stick with the &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt; method.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; 당신에게 주문 사항, 당신은 고수해야합니다 그렇다면 운영자는 분명히 임의의 순서로 쌍을 반환 &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt; 방법.</target>
        </trans-unit>
        <trans-unit id="1d704aced95cc8764eb35404aac65f2304fbf2d9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; method wrapped an &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; around a &lt;code&gt;&lt;a href=&quot;functions/join&quot;&gt;join&lt;/a&gt;&lt;/code&gt;, and so waited for a thread to exit, passing along any values the thread might have returned and placing any errors into &lt;code&gt;$@&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 방법은 포장 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; A는 주위 &lt;code&gt;&lt;a href=&quot;functions/join&quot;&gt;join&lt;/a&gt;&lt;/code&gt; 스레드가 돌아왔다 수있는 값을 함께 전달하고에 오류를 배치, 그래서 출구 스레드 기다렸다 &lt;code&gt;$@&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="80c53083069f05797eef5848d626cca139bde071" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/evalbytes&quot;&gt;evalbytes&lt;/a&gt;&lt;/code&gt; feature enables the &lt;code&gt;&lt;a href=&quot;functions/evalbytes&quot;&gt;evalbytes&lt;/a&gt;&lt;/code&gt; keyword, which evaluates the argument passed to it as a string of bytes. It dies if the string contains any characters outside the 8-bit range. Source filters work within &lt;code&gt;&lt;a href=&quot;functions/evalbytes&quot;&gt;evalbytes&lt;/a&gt;&lt;/code&gt;: they apply to the contents of the string being evaluated.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/evalbytes&quot;&gt;evalbytes&lt;/a&gt;&lt;/code&gt; 의 기능은 수 &lt;code&gt;&lt;a href=&quot;functions/evalbytes&quot;&gt;evalbytes&lt;/a&gt;&lt;/code&gt; 를 바이트의 문자열로 전달 된 인수를 평가하는 키워드. 문자열에 8 비트 범위 밖의 문자가 포함되어 있으면 죽습니다. 소스 필터는 &lt;code&gt;&lt;a href=&quot;functions/evalbytes&quot;&gt;evalbytes&lt;/a&gt;&lt;/code&gt; 내에서 작동 합니다. 평가되는 문자열의 내용에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="013c20c8a39c1e9d213753c8f42aa60136c4133a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; function executes a system command</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; 함수는 시스템 명령을 실행</target>
        </trans-unit>
        <trans-unit id="cc6b445e37f9fe0173dc131ac1ed2864194322f0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; function's job is to turn your process into another command and never to return. If that's not what you want to do, don't use &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt;. :)</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; 함수의 작업은 다른 명령에 결코 반환에 프로세스를 설정하는 것입니다. 그것이 원하는 것이 아니라면 &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; 를 사용하지 마십시오 . :)</target>
        </trans-unit>
        <trans-unit id="c64c8f5547bb2a6573770267608423f5c2aa4dc2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/for&quot;&gt;for(each)&lt;/a&gt;&lt;/code&gt; modifier is an iterator: it executes the statement once for each item in the LIST (with &lt;code&gt;$_&lt;/code&gt; aliased to each item in turn).</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/for&quot;&gt;for(each)&lt;/a&gt;&lt;/code&gt; 수정은 반복자이다 : 그것은 한 번 (과 목록의 각 항목에 대한 문을 실행 &lt;code&gt;$_&lt;/code&gt; 차례로 각 항목에 별칭).</target>
        </trans-unit>
        <trans-unit id="fcbb7f06dac39b4543299760a90086a0717180ff" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/getprotobynumber&quot;&gt;getprotobynumber&lt;/a&gt;&lt;/code&gt; function, even though it only takes one argument, has the precedence of a list operator, so beware:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/getprotobynumber&quot;&gt;getprotobynumber&lt;/a&gt;&lt;/code&gt; 의의 기능은, 단지 하나 개의 인자를, 비록 목록 연산자의 우선 순위가 있으므로주의 :</target>
        </trans-unit>
        <trans-unit id="d7025a8a8790fde9485d755f6c425f01c04b8467" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/gmtime&quot;&gt;gmtime&lt;/a&gt;&lt;/code&gt; operator will function properly if you have a working CRTL &lt;code&gt;&lt;a href=&quot;functions/gmtime&quot;&gt;gmtime()&lt;/a&gt;&lt;/code&gt; routine, or if the logical name SYS$TIMEZONE_DIFFERENTIAL is defined as the number of seconds which must be added to UTC to yield local time. (This logical name is defined automatically if you are running a version of VMS with built-in UTC support.) If neither of these cases is true, a warning message is printed, and &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; is returned.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/gmtime&quot;&gt;gmtime&lt;/a&gt;&lt;/code&gt; 연산자를 사용하면 작업 CRTL의 경우 제대로 작동 &lt;code&gt;&lt;a href=&quot;functions/gmtime&quot;&gt;gmtime()&lt;/a&gt;&lt;/code&gt; 루틴을, 또는 논리 이름 SYS $ TIMEZONE_DIFFERENTIAL는 현지 시간을 산출하기 위해 UTC에 추가해야합니다 (초)로 정의합니다. 이 논리 이름은 기본 제공 UTC 지원으로 VMS 버전을 실행하는 경우 자동으로 정의됩니다. 이러한 경우가 모두 해당되지 않으면 경고 메시지가 인쇄되고 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="5a3ff2f4c2a7967681e4811d9bc792e927dbfcbd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt; &amp;amp;NAME&lt;/code&gt; form is quite different from the other forms of &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt;. In fact, it isn't a goto in the normal sense at all, and doesn't have the stigma associated with other gotos. Instead, it exits the current subroutine (losing any changes set by local()) and immediately calls in its place the named subroutine using the current value of @_. This is used by &lt;code&gt;AUTOLOAD&lt;/code&gt; subroutines that wish to load another subroutine and then pretend that the other subroutine had been called in the first place (except that any modifications to &lt;code&gt;@_&lt;/code&gt; in the current subroutine are propagated to the other subroutine.) After the &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt;, not even &lt;code&gt;&lt;a href=&quot;functions/caller&quot;&gt;caller&lt;/a&gt;&lt;/code&gt; will be able to tell that this routine was called first.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt; &amp;amp;NAME&lt;/code&gt; 형태의 다른 형태는 매우 다르다 &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; . 사실, 그것은 정상적인 의미로 가지 않으며 다른 고토와 관련된 낙인이 없습니다. 대신, 현재 서브 루틴을 종료하고 (local ()에 의해 설정된 변경 사항을 잃음) 즉시 현재 값인 @_을 사용하여 명명 된 서브 루틴을 대신 호출합니다. 이것은 &lt;code&gt;AUTOLOAD&lt;/code&gt; 에 의해 사용됩니다 소원 다른 서브 루틴을로드 한 다음, 다른 서브 루틴 (모든 변형하는 것을 제외하고는 처음에 호출되었던 척 것을 루틴 &lt;code&gt;@_&lt;/code&gt; 애프터 현재 서브 루틴은 다른 서브 루틴에 전달된다.) &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/caller&quot;&gt;caller&lt;/a&gt;&lt;/code&gt; 조차도 이 루틴이 먼저 호출되었다는 것을 알 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8c6cdb8b9140a3413b924a1be37defd8094c23ff" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt; EXPR&lt;/code&gt; form expects to evaluate &lt;code&gt;EXPR&lt;/code&gt; to a code reference or a label name. If it evaluates to a code reference, it will be handled like &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt; &amp;amp;NAME&lt;/code&gt; , below. This is especially useful for implementing tail recursion via &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt; __SUB__&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt; EXPR&lt;/code&gt; 형태는 평가를 기대 &lt;code&gt;EXPR&lt;/code&gt; 을 코드 참조 또는 레이블 이름. 이 코드 기준으로 평가되면, 그것은 같이 처리됩니다 &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt; &amp;amp;NAME&lt;/code&gt; 되면 아래의 됩니다. 이것은 &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt; __SUB__&lt;/code&gt; 를 통해 꼬리 재귀를 구현할 때 특히 유용합니다 .</target>
        </trans-unit>
        <trans-unit id="f9a08aec53b4872b20c38601dfe1ff47bb7271a2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt; LABEL&lt;/code&gt; form finds the statement labeled with LABEL and resumes execution there. It can't be used to get out of a block or subroutine given to &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt;. It can be used to go almost anywhere else within the dynamic scope, including out of subroutines, but it's usually better to use some other construct such as &lt;code&gt;&lt;a href=&quot;functions/last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt;. The author of Perl has never felt the need to use this form of &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; (in Perl, that is; C is another matter). (The difference is that C does not offer named loops combined with loop control. Perl does, and this replaces most structured uses of &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; in other languages.)</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt; LABEL&lt;/code&gt; 형태는 LABEL이 표시된 문을 발견하고 거기에 실행을 다시 시작합니다. &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt; 에 주어진 블록이나 서브 루틴에서 빠져 나오기 위해 사용될 수 없습니다 . 서브 루틴을 포함하여 동적 범위 내 다른 곳으로 이동하는 데 사용할 수 있지만 일반적으로 &lt;code&gt;&lt;a href=&quot;functions/last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; 와 같은 다른 구성을 사용하는 것이 좋습니다 . Perl의 저자는 이런 형태의 &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; 를 사용해야 할 필요성을 느끼지 못했습니다. (Perl에서, 즉 C는 또 다른 문제입니다). 차이점은 C는 루프 제어와 결합 된 명명 된 루프를 제공하지 않는다는 것입니다. Perl은 다른 언어에서 구조화 된 대부분의 &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; 를 대체합니다 .</target>
        </trans-unit>
        <trans-unit id="fd5e7141b6809acf60b4ffb9ca0527589ab4d1fd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt;-&amp;amp;NAME form is highly magical, and substitutes a call to the named subroutine for the currently running subroutine. This is used by &lt;code&gt;AUTOLOAD()&lt;/code&gt; subroutines that wish to load another subroutine and then pretend that the other subroutine had been called in the first place (except that any modifications to &lt;code&gt;@_&lt;/code&gt; in the current subroutine are propagated to the other subroutine.) After the &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt;, not even &lt;code&gt;&lt;a href=&quot;functions/caller&quot;&gt;caller()&lt;/a&gt;&lt;/code&gt; will be able to tell that this routine was called first.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; - &amp;amp; NAME 형태는 매우 마법이며, 현재 실행중인 서브 루틴 명명 된 서브 루틴 호출을 대체합니다. 이것은 다른 서브 루틴을로드 한 다음 다른 서브 루틴이 처음에 호출 된 것처럼 가장하는 &lt;code&gt;AUTOLOAD()&lt;/code&gt; 서브 루틴에 의해 사용됩니다 ( 현재 서브 루틴에서 &lt;code&gt;@_&lt;/code&gt; 에 대한 수정 사항 이 다른 서브 루틴으로 전파되는 것을 제외하고 ). &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; , 심지어 &lt;code&gt;&lt;a href=&quot;functions/caller&quot;&gt;caller()&lt;/a&gt;&lt;/code&gt; 조차도이 루틴이 먼저 호출되었다는 것을 알 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="0f2fbb144491503128d3d631573fe99dbb58cb74" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt;-EXPR form expects a label name, whose scope will be resolved dynamically. This allows for computed &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt;s per FORTRAN, but isn't necessarily recommended if you're optimizing for maintainability:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; -EXPR 양식은 그 범위를 동적으로 해결 될 것입니다 라벨 이름을 기대하고있다. 이렇게하면 FORTRAN 당 계산 된 &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; 가 가능하지만 유지 관리 성을 최적화하는 경우 반드시 권장되는 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="747fd1051ce1561b7aad0a462ec80a7083e807f2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt;-LABEL form finds the statement labeled with LABEL and resumes execution there. It may not be used to go into any construct that requires initialization, such as a subroutine or a &lt;code&gt;foreach&lt;/code&gt; loop. It also can't be used to go into a construct that is optimized away. It can be used to go almost anywhere else within the dynamic scope, including out of subroutines, but it's usually better to use some other construct such as &lt;code&gt;&lt;a href=&quot;functions/last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt;. The author of Perl has never felt the need to use this form of &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; (in Perl, that is--C is another matter).</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; -label 양식 LABEL이 표시된 문을 발견하고 거기에 실행을 다시 시작합니다. 서브 루틴 또는 &lt;code&gt;foreach&lt;/code&gt; 루프 와 같이 초기화가 필요한 구성으로 들어가는 데 사용할 수 없습니다 . 또한 최적화 된 구문으로 들어가는 데 사용할 수 없습니다. 서브 루틴을 포함하여 동적 범위 내 다른 곳으로 이동하는 데 사용할 수 있지만 일반적으로 &lt;code&gt;&lt;a href=&quot;functions/last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; 와 같은 다른 구성을 사용하는 것이 좋습니다 . Perl의 저자는 이런 형태의 &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; 를 사용할 필요성을 결코 느끼지 못했습니다 (Perl에서, 즉 C는 또 다른 문제입니다).</target>
        </trans-unit>
        <trans-unit id="b3e30e59d91f75eda248244fb51004176883c63f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/grep&quot;&gt;grep&lt;/a&gt;&lt;/code&gt; in scalar context returns the count. If you want the list of matching items, just use it in list context instead:</source>
          <target state="translated">스칼라 컨텍스트 의 &lt;code&gt;&lt;a href=&quot;functions/grep&quot;&gt;grep&lt;/a&gt;&lt;/code&gt; 은 개수를 반환합니다. 일치하는 항목의 목록을 원하면 목록 컨텍스트에서 대신 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="612dabc89cee10beadc6c980b04dfdba8cc2e280" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys()&lt;/a&gt;&lt;/code&gt; function also resets the iterator, which means that you may see strange results if you use this between uses of other hash operators such as &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys()&lt;/a&gt;&lt;/code&gt; 함수는 또한 같은 다른 해시 사업자의 사용 사이에이를 사용하는 경우가 이상한 결과를 볼 수 있음을 의미 반복자를 재설정 &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each()&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="84a92b66f23e84ffcea0f8036601109332768c0c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/kill&quot;&gt;kill&lt;/a&gt;&lt;/code&gt; function can be used to test this functionality from within a program.</source>
          <target state="translated">그만큼 &lt;code&gt;&lt;a href=&quot;functions/kill&quot;&gt;kill&lt;/a&gt;&lt;/code&gt; 기능은 프로그램 내에서이 기능을 테스트 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8f9dd8be24cd7b207201afca586d0393221c8761" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/kill&quot;&gt;kill&lt;/a&gt;&lt;/code&gt; function in the parent's &lt;code&gt;if&lt;/code&gt; block is there to send a signal to our child process, currently running in the &lt;code&gt;else&lt;/code&gt; block, as soon as the remote server has closed its end of the connection.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/kill&quot;&gt;kill&lt;/a&gt;&lt;/code&gt; 부모의 함수의 &lt;code&gt;if&lt;/code&gt; 블록이 현재 실행, 우리의 자식 프로세스에 신호가 전송하는 것입니다 &lt;code&gt;else&lt;/code&gt; 원격 서버 연결의 끝을 폐쇄했다 자마자, 블록.</target>
        </trans-unit>
        <trans-unit id="8bfb3b07d45ff01232bb221af626a6a5fb4ea5a7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; command immediately exits the loop in question. The &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; block, if any, is not executed:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; 명령은 즉시 문제의 루프를 종료합니다. 는 &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; 어떤이 실행되지 않을 경우, 블록 :</target>
        </trans-unit>
        <trans-unit id="ac302bdab0f919a07174f63d0969bebc85f1b892" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; command is like the &lt;code&gt;break&lt;/code&gt; statement in C (as used in loops); it immediately exits the loop in question. If the LABEL is omitted, the command refers to the innermost enclosing loop. The &lt;code&gt;&lt;a href=&quot;functions/last&quot;&gt;last&lt;/a&gt; EXPR&lt;/code&gt; form, available starting in Perl 5.18.0, allows a label name to be computed at run time, and is otherwise identical to &lt;code&gt;&lt;a href=&quot;functions/last&quot;&gt;last&lt;/a&gt; LABEL&lt;/code&gt; . The &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; block, if any, is not executed:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; 명령은 같다 &lt;code&gt;break&lt;/code&gt; C (루프에 사용)의 문; 문제의 루프를 즉시 종료합니다. LABEL을 생략하면 명령은 가장 안쪽의 루프를 나타냅니다. &lt;code&gt;&lt;a href=&quot;functions/last&quot;&gt;last&lt;/a&gt; EXPR&lt;/code&gt; 형태, 펄 5.18.0에서 사용할 수있는 시작은 레이블 이름이 런타임에 계산 될 수 있으며,에, 그렇지 않으면 동일 &lt;code&gt;&lt;a href=&quot;functions/last&quot;&gt;last&lt;/a&gt; LABEL&lt;/code&gt; . 그만큼 &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; 어떤이 실행되지 않을 경우, 블록 :</target>
        </trans-unit>
        <trans-unit id="506963259280dc353e83831a1d7243717b046918" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/length&quot;&gt;length(NAME)&lt;/a&gt;&lt;/code&gt; Keyword</source>
          <target state="translated">그만큼 &lt;code&gt;&lt;a href=&quot;functions/length&quot;&gt;length(NAME)&lt;/a&gt;&lt;/code&gt; 키워드</target>
        </trans-unit>
        <trans-unit id="249bfee98e5c2e5ddbdeda77c1a70bb97c684fdb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/lock&quot;&gt;lock()&lt;/a&gt;&lt;/code&gt; function takes a shared variable and puts a lock on it. No other thread may lock the variable until the variable is unlocked by the thread holding the lock. Unlocking happens automatically when the locking thread exits the block that contains the call to the &lt;code&gt;&lt;a href=&quot;functions/lock&quot;&gt;lock()&lt;/a&gt;&lt;/code&gt; function. Using &lt;code&gt;&lt;a href=&quot;functions/lock&quot;&gt;lock()&lt;/a&gt;&lt;/code&gt; is straightforward: This example has several threads doing some calculations in parallel, and occasionally updating a running total:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/lock&quot;&gt;lock()&lt;/a&gt;&lt;/code&gt; 함수는 공유 변수를 받아 그것을 잠금을 둔다. 잠금을 유지하는 스레드가 변수를 잠금 해제 할 때까지 다른 스레드는 변수를 잠글 수 없습니다. 잠금 스레드가 &lt;code&gt;&lt;a href=&quot;functions/lock&quot;&gt;lock()&lt;/a&gt;&lt;/code&gt; 함수에 대한 호출을 포함하는 블록을 종료하면 잠금이 자동으로 발생 합니다. 사용 &lt;code&gt;&lt;a href=&quot;functions/lock&quot;&gt;lock()&lt;/a&gt;&lt;/code&gt; 간단하다 :이 예는 여러 스레드 병렬로 몇 가지 계산을하고, 때때로 실행중인 총 업데이트가 있습니다 :</target>
        </trans-unit>
        <trans-unit id="844dd628839d69aa91981cfdf9d35b8aa941b210" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; is actually not required; you could just use:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; IS 실제로 필요하지 않습니다; 당신은 단지 사용할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="15c7027f68a72fedc245e7d612cf00a82d9df24d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; is simply a modifier on something you might assign to. So when you do assign to variables in its argument list, &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; doesn't change whether those variables are viewed as a scalar or an array. So</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; 단순히 할당하려하는 것에 관한 단순한 수정합니다. 그래서 당신은 인수 목록의 변수에 할당 할 때, &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; 이러한 변수들이 스칼라 나 배열로 간주되는지 여부를 변경하지 않습니다. 그래서</target>
        </trans-unit>
        <trans-unit id="82cb7d6fd4d7d98853ace6ba4000362cdc7fa762" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; operator declares the listed variables to be lexically confined to the enclosing block, conditional (&lt;code&gt;if/unless/elsif/else&lt;/code&gt;), loop (&lt;code&gt;for/foreach/while/until/continue&lt;/code&gt;), subroutine, &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do/require/use&lt;/a&gt;&lt;/code&gt;'d file. If more than one value is listed, the list must be placed in parentheses. All listed elements must be legal lvalues. Only alphanumeric identifiers may be lexically scoped--magical built-ins like &lt;code&gt;$/&lt;/code&gt; must currently be &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt;ized with &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; 연산자 나열된 변수가 어휘 적으로 바깥 쪽 블록에 국한되는 선언 조건 ( &lt;code&gt;if/unless/elsif/else&lt;/code&gt; ), 루프 ( &lt;code&gt;for/foreach/while/until/continue&lt;/code&gt; ), 서브 루틴, &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; , 또는 &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do/require/use&lt;/a&gt;&lt;/code&gt; 'd 파일. 둘 이상의 값이 나열되면 목록을 괄호 안에 넣어야합니다. 나열된 모든 요소는 유효한 lvalue 여야합니다. 영숫자 식별자는 어휘 적 범위가 될 수 있습니다 - 같은 마법의 내장 인 &lt;code&gt;$/&lt;/code&gt; 현재해야 &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; 으로화된 &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; 대신.</target>
        </trans-unit>
        <trans-unit id="598c24981891ed39a33542154be0ea54335c8268" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; command is like the &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; statement in C; it starts the next iteration of the loop:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; (가)와 같은 명령은 &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; C에 문을; 루프의 다음 반복을 시작합니다.</target>
        </trans-unit>
        <trans-unit id="4ac987f577bf457aa0aa7edd6027d43957e00541" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; command starts the next iteration of the loop:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; 명령은 루프의 다음 반복을 시작합니다 :</target>
        </trans-unit>
        <trans-unit id="90d027781b9d30c834bc3f75976b8010ac44b08a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; keywords work differently.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit&lt;/a&gt;&lt;/code&gt; , 그리고 &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; 키워드가 다르게 작동합니다.</target>
        </trans-unit>
        <trans-unit id="5eeb76addad99da0bbdd65d75ec9e60f2b34827f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; &lt;a href=&quot;functions/sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt; pragma doesn't</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; &lt;a href=&quot;functions/sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt; pragma는하지 않습니다</target>
        </trans-unit>
        <trans-unit id="7bf3b5adc84fde6d734586f4bec0209359aa5187" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; lib&lt;/code&gt; statement deletes all instances of each named directory from @INC.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; lib&lt;/code&gt; 문 @ INC 각 지정된 디렉토리의 모든 인스턴스를 삭제합니다.</target>
        </trans-unit>
        <trans-unit id="1aa289805fbc7ad3a1863fbfa81d350e063c7221" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;(FOO, &quot;|-&quot;)&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;(BAR, &quot;-|&quot;)&lt;/code&gt; constructs are not yet implemented. This limitation can be easily worked around in new code by creating a pipe explicitly. The following example shows how to write to a forked child:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;(FOO, &quot;|-&quot;)&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;(BAR, &quot;-|&quot;)&lt;/code&gt; 구조는 아직 구현되지 않습니다. 파이프를 명시 적으로 작성하여 새 코드에서이 제한 사항을 쉽게 해결할 수 있습니다. 다음 예는 갈래의 아이에게 쓰는 법을 보여줍니다 :</target>
        </trans-unit>
        <trans-unit id="91b6442686235ec3446ecfbcfcc1b68ae5f717df" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; pragma serves as one of the interfaces to declare default &quot;layers&quot; (also known as &quot;disciplines&quot;) for all I/O. Any two-argument open(), readpipe() (aka qx//) and similar operators found within the lexical scope of this pragma will use the declared defaults. Even three-argument opens may be affected by this pragma when they don't specify IO layers in MODE.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; 프라그 모든 I / O를위한 (또한 &quot;훈련&quot;라고도 함)의 기본 &quot;층&quot;을 선언하는 인터페이스 중 하나로서 기능한다. 이 pragma의 어휘 범위 내에있는 두 개의 인수 open (), readpipe () (일명 qx //) 및 유사한 연산자는 선언 된 기본값을 사용합니다. MODE에서 IO 레이어를 지정하지 않으면 3 개의 인수 열기도이 pragma의 영향을받을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d568cb2b48539b711386365d8e03258e04c0c727" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/ord&quot;&gt;ord&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr&lt;/a&gt;&lt;/code&gt; functions work transparently on all codepoints, not just on ASCII alone &amp;mdash; nor in fact, not even just on Unicode alone.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/ord&quot;&gt;ord&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr&lt;/a&gt;&lt;/code&gt; 함수는 혼자가 아니라 ASCII에 모든 코드 포인트에 투명하게 작동 -도 사실조차 혼자 유니 코드에.</target>
        </trans-unit>
        <trans-unit id="48c955c71d75929afac22e8dfa9aad63b2004a10" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt; operator showed up in perl 5.005. It compiles a regular expression, but doesn't apply it. When you use the pre-compiled version of the regex, perl does less work. In this example, I inserted a &lt;code&gt;&lt;a href=&quot;functions/map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; to turn each pattern into its pre-compiled form. The rest of the script is the same, but faster:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt; 연산자는 펄 5.005로 나타났다. 정규 표현식을 컴파일하지만 적용하지는 않습니다. 미리 컴파일 된 버전의 정규식을 사용하면 perl의 작업이 줄어 듭니다. 이 예에서는 &lt;code&gt;&lt;a href=&quot;functions/map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; 삽입했습니다 을 각 패턴을 사전 컴파일 된 형식으로 바꿉니다. 나머지 스크립트는 동일하지만 더 빠릅니다.</target>
        </trans-unit>
        <trans-unit id="6086a140e1b37399f10a989a119aa2028d369c83" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/redo&quot;&gt;redo&lt;/a&gt;&lt;/code&gt; command restarts the loop block without evaluating the conditional again. The &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; block, if any, is</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/redo&quot;&gt;redo&lt;/a&gt;&lt;/code&gt; 명령 다시 조건을 평가하지 않고 루프를 재시작 블록. 은 &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; , 어떤 경우, 블록을</target>
        </trans-unit>
        <trans-unit id="362e8253628830d9a4d5614fd639fe79bc546984" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/redo&quot;&gt;redo&lt;/a&gt;&lt;/code&gt; command restarts the loop block without evaluating the conditional again. The &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; block, if any, is not executed. If the LABEL is omitted, the command refers to the innermost enclosing loop. The &lt;code&gt;&lt;a href=&quot;functions/redo&quot;&gt;redo&lt;/a&gt; EXPR&lt;/code&gt; form, available starting in Perl 5.18.0, allows a label name to be computed at run time, and is otherwise identical to &lt;code&gt;&lt;a href=&quot;functions/redo&quot;&gt;redo&lt;/a&gt;
LABEL&lt;/code&gt; . Programs that want to lie to themselves about what was just input normally use this command:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/redo&quot;&gt;redo&lt;/a&gt;&lt;/code&gt; 명령 다시 조건을 평가하지 않고 루프를 재시작 블록. 는 &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; 실행되지 않은 경우, 블록을. LABEL을 생략하면 명령은 가장 안쪽의 루프를 나타냅니다. &lt;code&gt;&lt;a href=&quot;functions/redo&quot;&gt;redo&lt;/a&gt; EXPR&lt;/code&gt; 형태, 펄 5.18.0에서 사용할 수있는 시작은 레이블 이름이 런타임에 계산 될 수 있으며,에, 그렇지 않으면 동일 &lt;code&gt;&lt;a href=&quot;functions/redo&quot;&gt;redo&lt;/a&gt; LABEL&lt;/code&gt; . 방금 입력 한 내용에 대해 스스로 거짓말하려는 프로그램은 일반적으로 다음 명령을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="f9c130f1621f9ce97dabd985717a6055d0d6afd0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt; substitution operator is documented in &lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt; 교체 연산자에서 설명 &lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="121511ae0b5d1fbb23eba64b638e8a05d463c939" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split()&lt;/a&gt;&lt;/code&gt; function is another place where a regexp is used. &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt; /regexp/, string, limit&lt;/code&gt; separates the &lt;code&gt;string&lt;/code&gt; operand into a list of substrings and returns that list. The regexp must be designed to match whatever constitutes the separators for the desired substrings. The &lt;code&gt;limit&lt;/code&gt; , if present, constrains splitting into no more than &lt;code&gt;limit&lt;/code&gt; number of strings. For example, to split a string into words, use</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split()&lt;/a&gt;&lt;/code&gt; 함수는 정규 표현식을 사용하는 또 다른 장소이다. &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt; /regexp/, string, limit&lt;/code&gt; 는 &lt;code&gt;string&lt;/code&gt; 피연산자를 하위 문자열 목록으로 분리하고 해당 목록을 반환합니다. 정규 표현식은 원하는 부분 문자열의 구분 기호를 구성하는 모든 항목과 일치하도록 설계되어야합니다. &lt;code&gt;limit&lt;/code&gt; , 만약 더 이상으로 존재하는 제약을 분할 &lt;code&gt;limit&lt;/code&gt; 문자열의 개수. 예를 들어 문자열을 단어로 나누려면</target>
        </trans-unit>
        <trans-unit id="7f7da5ebd320780203ed7d5e0028f1f486db3bfd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/state&quot;&gt;state&lt;/a&gt;&lt;/code&gt; keyword creates a lexical variable (following the same scoping rules as &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt;) that persists from one subroutine call to the next. If a state variable resides inside an anonymous subroutine, then each copy of the subroutine has its own copy of the state variable. However, the value of the state variable will still persist between calls to the same copy of the anonymous subroutine. (Don't forget that &lt;code&gt;&lt;a href=&quot;functions/sub&quot;&gt;sub&lt;/a&gt; { ... }&lt;/code&gt; creates a new subroutine each time it is executed.)</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/state&quot;&gt;state&lt;/a&gt;&lt;/code&gt; 키워드는 (같은 범위 지정 규칙에 따라 어휘 변수를 만들어 &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; 그이 지속 한 서브 루틴 호출에서 다음을 참조). 상태 변수가 익명 서브 루틴 내에 상주하는 경우 서브 루틴의 각 사본에는 고유 한 상태 변수 사본이 있습니다. 그러나 상태 변수의 값은 익명 서브 루틴의 동일한 사본에 대한 호출간에 계속 유지됩니다. ( &lt;code&gt;&lt;a href=&quot;functions/sub&quot;&gt;sub&lt;/a&gt; { ... }&lt;/code&gt; 는 실행될 때마다 새로운 서브 루틴을 작성 한다는 것을 잊지 마십시오 .)</target>
        </trans-unit>
        <trans-unit id="87a4764ce311581074e8327a658c6ee1ed914b66" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/sub&quot;&gt;sub-entry&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/sub&quot;&gt;sub-return&lt;/a&gt;&lt;/code&gt; probes gain a fourth argument: the package name of the function.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/sub&quot;&gt;sub-entry&lt;/a&gt;&lt;/code&gt; 과 &lt;code&gt;&lt;a href=&quot;functions/sub&quot;&gt;sub-return&lt;/a&gt;&lt;/code&gt; 프로브는 네 번째 인수를 얻을 : 함수의 패키지 이름.</target>
        </trans-unit>
        <trans-unit id="fa495b532decb2c8f20d40c7506dd35df2aff6f1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; built-in is considered to have failed in the following circumstances:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; 내장 다음과 같은 경우에 실패한 것으로 간주된다 :</target>
        </trans-unit>
        <trans-unit id="007bfa453d22a010bcc25f103e9e741d0e19770d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; operator creates a subprocess, and passes its arguments to the subprocess for execution as a DCL command. Since the subprocess is created directly via &lt;code&gt;lib$spawn()&lt;/code&gt; , any valid DCL command string may be specified. If the string begins with '@', it is treated as a DCL command unconditionally. Otherwise, if the first token contains a character used as a delimiter in file specification (e.g. &lt;code&gt;:&lt;/code&gt; or &lt;code&gt;]&lt;/code&gt;), an attempt is made to expand it using a default type of</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; 오퍼레이터가 구성 프로세스를 생성하고, DCL 명령과 실행을위한 하위 프로세스를 인수를 전달한다. 서브 프로세스는 &lt;code&gt;lib$spawn()&lt;/code&gt; 통해 직접 작성되므로 유효한 DCL 명령 문자열을 지정할 수 있습니다. 문자열이 '@'로 시작하면 무조건 DCL 명령으로 처리됩니다. 그렇지 않으면, 첫 번째 토큰에 파일 스펙에서 분리 문자로 사용 된 문자가 포함 된 경우 (예 &lt;code&gt;:&lt;/code&gt; 또는 &lt;code&gt;]&lt;/code&gt; ) 기본 유형 인</target>
        </trans-unit>
        <trans-unit id="c442498b077f35c1d517c581c1d1aa5d5b6d170c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/times&quot;&gt;times()&lt;/a&gt;&lt;/code&gt; function returns elapsed realtime since some point in the past (such as system startup), user and system times for this process, and user and system times used by child processes. All times are returned in clock ticks.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/times&quot;&gt;times()&lt;/a&gt;&lt;/code&gt; 함수가 반환은 자식 프로세스에 의해 사용되는 과거의 어느 시점 (예 : 시스템 시작 등)이 프로세스에 대한 사용자와 시스템 시간, 사용자 및 시스템 시대부터 실시간 경과. 모든 시간은 시계 틱으로 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="80b97318408e6d656bf28c96d67c4dfdc24c2653" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr///&lt;/a&gt;&lt;/code&gt; operator translates whole characters. (Note that the &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr///CU&lt;/a&gt;&lt;/code&gt; functionality has been removed. For similar functionality to that, see &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;('U0', ...)&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;('C0', ...)&lt;/code&gt; ).</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr///&lt;/a&gt;&lt;/code&gt; 연산자는 전체 문자를 변환합니다. 합니다 (참고 &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr///CU&lt;/a&gt;&lt;/code&gt; 기능이 제거되었다. 유사한 기능성을 참조 &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;('U0', ...)&lt;/code&gt; 과 &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;('C0', ...)&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="11a568ea0ae08ef300d37d167d740832b4c2b16f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr&lt;/a&gt;&lt;/code&gt; alternative might look like this:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr&lt;/a&gt;&lt;/code&gt; 대안은 다음과 같습니다</target>
        </trans-unit>
        <trans-unit id="42f87c254ee8d81cee26e792f60cacaefbfbe36a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr&lt;/a&gt;&lt;/code&gt; counts the null bytes. The &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; call returns a list of name-value pairs each of which is taken apart in the &lt;code&gt;&lt;a href=&quot;functions/map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; block.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr&lt;/a&gt;&lt;/code&gt; 널 바이트를 계산합니다. &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; 호출은에서 떨어져 촬영, 각각의 이름 - 값 쌍의 목록을 반환 &lt;code&gt;&lt;a href=&quot;functions/map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; 블록을.</target>
        </trans-unit>
        <trans-unit id="a53ff006297297281156ad4ddc8aef0830e3811c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr&lt;/a&gt;&lt;/code&gt; version is a clear winner. One solution is flexible, the other is fast - and it's appropriately the programmer's choice which to use.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr&lt;/a&gt;&lt;/code&gt; 버전은 확실한 승자입니다. 하나의 솔루션은 유연하고 다른 솔루션은 빠르며 적절하게 사용할 프로그래머의 선택입니다.</target>
        </trans-unit>
        <trans-unit id="6f47b182b84a1df9e8040499b142da5e15a5a35d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/untie&quot;&gt;untie&lt;/a&gt;&lt;/code&gt; Gotcha</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/untie&quot;&gt;untie&lt;/a&gt;&lt;/code&gt; 잡았다</target>
        </trans-unit>
        <trans-unit id="5e2ca855aa217bd553e610f05dba85cf9019d5da" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; bytes&lt;/code&gt; pragma disables character semantics for the rest of the lexical scope in which it appears. &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; bytes&lt;/code&gt; can be used to reverse the effect of &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; bytes&lt;/code&gt; within the current lexical scope.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; bytes&lt;/code&gt; 가 나타나는 어휘 범위의 나머지 부분에 대한 프라그 비활성화 문자 의미. 현재 어휘 범위 내에서 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; bytes&lt;/code&gt; 바이트 의 영향을 되 돌리는 데 &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; bytes&lt;/code&gt; 사용할 수 &lt;a href=&quot;functions/no&quot;&gt;없습니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9fdef637aec2a8c40d4ef4a640873fd3daeaa545" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; filetest&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; filetest&lt;/code&gt; statements affect file tests defined in their block, up to the end of the closest enclosing block (they are lexically block-scoped).</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; filetest&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; filetest&lt;/code&gt; 문까지 가장 가까운 바깥 쪽 블록의 끝 (그들은 어휘 적 범위의 차단할있다)에, 자신의 블록에 정의 된 파일의 검사에도 영향을 미칩니다.</target>
        </trans-unit>
        <trans-unit id="8744ea2543ae1b476ba91732c622f01f08c1038b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; pragma tells the Perl parser to allow UTF-8 in the program text in the current lexical scope (allow UTF-EBCDIC on EBCDIC based platforms). The &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; utf8&lt;/code&gt; pragma tells Perl to switch back to treating the source text as literal bytes in the current lexical scope.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; 프라그 현재 어휘 범위의 프로그램 텍스트에서 UTF-8을 허용하는 펄 파서를 알려줍니다 (UTF-EBCDIC은 EBCDIC 기반 플랫폼에서 가능). &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; utf8&lt;/code&gt; pragma는 현재 어휘 범위에있는 문자 바이트로 소스 텍스트의 치료로 전환하기 위해 펄을 알려줍니다.</target>
        </trans-unit>
        <trans-unit id="43067066e43761608ec314550d1ef0009ca78c23" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings&lt;/code&gt; pragma or the &lt;b&gt;-w&lt;/b&gt; switch will warn you if it interprets a reserved word as a string. But it will no longer warn you about using lowercase words, because the string is effectively quoted.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings&lt;/code&gt; PRAGMA 또는 &lt;b&gt;-w&lt;/b&gt; 이 예약 된 단어를 문자열로 해석하는 경우 스위치는 경고합니다. 그러나 문자열이 효과적으로 인용되기 때문에 더 이상 소문자 단어 사용에 대해 경고하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="19cdd025fab18dcd164b56bb8b49804d47261c9d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings&lt;/code&gt; pragma produces some lovely diagnostics. One can also use the &lt;b&gt;-w&lt;/b&gt; flag, but its use is normally discouraged, because it gets applied to all executed Perl code, including that not under your control.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings&lt;/code&gt; pragma는 일부 사랑스러운 진단을 생산하고 있습니다. &lt;b&gt;-w&lt;/b&gt; 플래그를 사용할 수도 있지만, 일반적으로 제어하지 않는 것을 포함하여 실행 된 모든 Perl 코드에 적용되므로 사용을 권장하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="98ff32ffdb1aaec51b5964ab04fedf9b556042ee" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;getprotobynumber&quot;&gt;getprotobynumber&lt;/a&gt;&lt;/code&gt; function, even though it only takes one argument, has the precedence of a list operator, so beware:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;getprotobynumber&quot;&gt;getprotobynumber&lt;/a&gt;&lt;/code&gt; 의의 기능은, 단지 하나 개의 인자를, 비록 목록 연산자의 우선 순위가 있으므로주의 :</target>
        </trans-unit>
        <trans-unit id="57bb7a10c9bf27aba4e74945efa7f4324ecc8306" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt; &amp;amp;NAME&lt;/code&gt; form is quite different from the other forms of &lt;code&gt;&lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt;. In fact, it isn't a goto in the normal sense at all, and doesn't have the stigma associated with other gotos. Instead, it exits the current subroutine (losing any changes set by local()) and immediately calls in its place the named subroutine using the current value of @_. This is used by &lt;code&gt;AUTOLOAD&lt;/code&gt; subroutines that wish to load another subroutine and then pretend that the other subroutine had been called in the first place (except that any modifications to &lt;code&gt;@_&lt;/code&gt; in the current subroutine are propagated to the other subroutine.) After the &lt;code&gt;&lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt;, not even &lt;code&gt;&lt;a href=&quot;caller&quot;&gt;caller&lt;/a&gt;&lt;/code&gt; will be able to tell that this routine was called first.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt; &amp;amp;NAME&lt;/code&gt; 형태의 다른 형태는 매우 다르다 &lt;code&gt;&lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; . 사실, 그것은 정상적인 의미로 가지 않는 것이 아니며 다른 고토와 관련된 오명을 가지고 있지 않습니다. 대신, 현재 서브 루틴을 종료하고 (local ()에 의해 설정된 변경 사항을 잃음) 즉시 현재 값인 @_을 사용하여 명명 된 서브 루틴을 대신 호출합니다. 이것은에 의해 사용되는 &lt;code&gt;AUTOLOAD&lt;/code&gt; 소원 다른 서브 루틴을로드 한 다음, 다른 서브 루틴 (모든 변형하는 것을 제외하고는 처음에 호출되었던 척 것을 루틴 &lt;code&gt;@_&lt;/code&gt; 애프터 현재 서브 루틴은 다른 서브 루틴에 전달된다.) &lt;code&gt;&lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;caller&quot;&gt;caller&lt;/a&gt;&lt;/code&gt; 조차도 이 루틴이 먼저 호출되었다는 것을 알 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e45cfef5656ef233c1972b6e6db8f04158149f58" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt; EXPR&lt;/code&gt; form expects to evaluate &lt;code&gt;EXPR&lt;/code&gt; to a code reference or a label name. If it evaluates to a code reference, it will be handled like &lt;code&gt;&lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt; &amp;amp;NAME&lt;/code&gt; , below. This is especially useful for implementing tail recursion via &lt;code&gt;&lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt; __SUB__&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt; EXPR&lt;/code&gt; 형태는 평가를 기대 &lt;code&gt;EXPR&lt;/code&gt; 을 코드 참조 또는 레이블 이름. 코드 참조로 평가 되면 아래의 &lt;code&gt;&lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt; &amp;amp;NAME&lt;/code&gt; 과 같이 처리 됩니다. 이것은 &lt;code&gt;&lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt; __SUB__&lt;/code&gt; 를 통해 꼬리 재귀를 구현할 때 특히 유용합니다 .</target>
        </trans-unit>
        <trans-unit id="a0fba7d2ee7cbb751d9b45951b63706bcd429d8d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt; LABEL&lt;/code&gt; form finds the statement labeled with LABEL and resumes execution there. It can't be used to get out of a block or subroutine given to &lt;code&gt;&lt;a href=&quot;sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt;. It can be used to go almost anywhere else within the dynamic scope, including out of subroutines, but it's usually better to use some other construct such as &lt;code&gt;&lt;a href=&quot;last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;die&quot;&gt;die&lt;/a&gt;&lt;/code&gt;. The author of Perl has never felt the need to use this form of &lt;code&gt;&lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; (in Perl, that is; C is another matter). (The difference is that C does not offer named loops combined with loop control. Perl does, and this replaces most structured uses of &lt;code&gt;&lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; in other languages.)</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt; LABEL&lt;/code&gt; 형태는 LABEL이 표시된 문을 발견하고 거기에 실행을 다시 시작합니다. &lt;code&gt;&lt;a href=&quot;sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt; 에 주어진 블록이나 서브 루틴에서 빠져 나오기 위해 사용될 수 없습니다 . 서브 루틴을 포함하여 동적 범위 내 다른 곳으로 이동하는 데 사용할 수 있지만 일반적으로 &lt;code&gt;&lt;a href=&quot;last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; 와 같은 다른 구성을 사용하는 것이 좋습니다 . Perl의 저자는 이런 형태의 &lt;code&gt;&lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; 를 사용할 필요성을 결코 느끼지 못했습니다 (Perl에서, 즉 C는 또 다른 문제입니다). 차이점은 C는 루프 제어와 결합 된 명명 된 루프를 제공하지 않는다는 것입니다. Perl은 다른 언어에서 구조화 된 대부분의 &lt;code&gt;&lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; 를 대체합니다 .</target>
        </trans-unit>
        <trans-unit id="0ec2144df4bcb647e47e9a3fffb037716e0ff735" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; command is like the &lt;code&gt;break&lt;/code&gt; statement in C (as used in loops); it immediately exits the loop in question. If the LABEL is omitted, the command refers to the innermost enclosing loop. The &lt;code&gt;&lt;a href=&quot;last&quot;&gt;last&lt;/a&gt; EXPR&lt;/code&gt; form, available starting in Perl 5.18.0, allows a label name to be computed at run time, and is otherwise identical to &lt;code&gt;&lt;a href=&quot;last&quot;&gt;last&lt;/a&gt; LABEL&lt;/code&gt; . The &lt;code&gt;&lt;a href=&quot;continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; block, if any, is not executed:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; 명령은 같다 &lt;code&gt;break&lt;/code&gt; C (루프에 사용)의 문; 문제의 루프를 즉시 종료합니다. LABEL을 생략하면 명령은 가장 안쪽의 루프를 나타냅니다. &lt;code&gt;&lt;a href=&quot;last&quot;&gt;last&lt;/a&gt; EXPR&lt;/code&gt; 형태, 펄 5.18.0에서 사용할 수있는 시작은 레이블 이름이 런타임에 계산 될 수 있으며,에, 그렇지 않으면 동일 &lt;code&gt;&lt;a href=&quot;last&quot;&gt;last&lt;/a&gt; LABEL&lt;/code&gt; . 는 &lt;code&gt;&lt;a href=&quot;continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; 어떤이 실행되지 않을 경우, 블록 :</target>
        </trans-unit>
        <trans-unit id="0dc04adeb5f33f6be3e55c3b75049d3460dd5faf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; command is like the &lt;code&gt;&lt;a href=&quot;continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; statement in C; it starts the next iteration of the loop:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; (가)와 같은 명령은 &lt;code&gt;&lt;a href=&quot;continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; C에 문을; 루프의 다음 반복을 시작합니다.</target>
        </trans-unit>
        <trans-unit id="d03baace3369995824b0971e1012da68e7afe6a5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;re#%27%2Fflags%27-mode&quot;&gt;use re '/foo'&lt;/a&gt;&lt;/code&gt; pragma can be used to set default modifiers (including these) for regular expressions compiled within its scope. This pragma has precedence over the other pragmas listed below that also change the defaults.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;re#%27%2Fflags%27-mode&quot;&gt;use re '/foo'&lt;/a&gt;&lt;/code&gt; 프라 그마의 범위 내에서 컴파일 된 정규 표현식 (다음 포함) 기본값 설정 수정에 사용할 수 있습니다. 이 pragma는 기본값을 변경하는 아래 나열된 다른 pragma보다 우선합니다.</target>
        </trans-unit>
        <trans-unit id="d90f5477a728439ae001b7de4028bc5063fe8048" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;re#'%2fflags'-mode&quot;&gt;use re '/foo'&lt;/a&gt;&lt;/code&gt; pragma can be used to set default modifiers (including these) for regular expressions compiled within its scope. This pragma has precedence over the other pragmas listed below that also change the defaults.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;re#'%2fflags'-mode&quot;&gt;use re '/foo'&lt;/a&gt;&lt;/code&gt; 프라 그마의 범위 내에서 컴파일 된 정규 표현식 (다음 포함) 기본값 설정 수정에 사용할 수 있습니다. 이 pragma는 기본값을 변경하는 아래 나열된 다른 pragma보다 우선합니다.</target>
        </trans-unit>
        <trans-unit id="00f56e4e287b4dad7bb9b00175cad4e28ccf4f49" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;redo&quot;&gt;redo&lt;/a&gt;&lt;/code&gt; command restarts the loop block without evaluating the conditional again. The &lt;code&gt;&lt;a href=&quot;continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; block, if any, is not executed. If the LABEL is omitted, the command refers to the innermost enclosing loop. The &lt;code&gt;&lt;a href=&quot;redo&quot;&gt;redo&lt;/a&gt; EXPR&lt;/code&gt; form, available starting in Perl 5.18.0, allows a label name to be computed at run time, and is otherwise identical to &lt;code&gt;&lt;a href=&quot;redo&quot;&gt;redo&lt;/a&gt;
LABEL&lt;/code&gt; . Programs that want to lie to themselves about what was just input normally use this command:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;redo&quot;&gt;redo&lt;/a&gt;&lt;/code&gt; 명령 다시 조건을 평가하지 않고 루프를 재시작 블록. 는 &lt;code&gt;&lt;a href=&quot;continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; 실행되지 않은 경우, 블록을. LABEL을 생략하면 명령은 가장 안쪽의 루프를 나타냅니다. &lt;code&gt;&lt;a href=&quot;redo&quot;&gt;redo&lt;/a&gt; EXPR&lt;/code&gt; 형태, 펄 5.18.0에서 사용할 수있는 시작은 레이블 이름이 런타임에 계산 될 수 있으며,에, 그렇지 않으면 동일 &lt;code&gt;&lt;a href=&quot;redo&quot;&gt;redo&lt;/a&gt; LABEL&lt;/code&gt; . 방금 입력 한 내용에 대해 스스로 거짓말하려는 프로그램은 일반적으로 다음 명령을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="98d8fed67bad4314d20d9f4fe777fa7ab53123e6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;=&amp;gt;&lt;/code&gt; operator (sometimes pronounced &quot;fat comma&quot;) is a synonym for the comma except that it causes a word on its left to be interpreted as a string if it begins with a letter or underscore and is composed only of letters, digits and underscores. This includes operands that might otherwise be interpreted as operators, constants, single number v-strings or function calls. If in doubt about this behavior, the left operand can be quoted explicitly.</source>
          <target state="translated">&lt;code&gt;=&amp;gt;&lt;/code&gt; 그것은 문자 나 밑줄로 시작하는 경우 문자열로 해석 왼쪽의에 단어를 원인과 문자, 숫자로 구성되며 것을 제외 연산자 (때로는 발음 &quot;지방 쉼표&quot;) 쉼표 동의어입니다 밑줄. 여기에는 연산자, 상수, 단일 숫자 v- 문자열 또는 함수 호출로 해석 될 수있는 피연산자가 포함됩니다. 이 동작에 대해 의문이 있으면 왼쪽 피연산자를 명시 적으로 인용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8399dbf8e2e784c4274bc7b091a4f7216970d51b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;=&amp;gt;&lt;/code&gt; operator is helpful in documenting the correspondence between keys and values in hashes, and other paired elements in lists.</source>
          <target state="translated">&lt;code&gt;=&amp;gt;&lt;/code&gt; 연산자에서 해시 키 값 사이의 대응 관계, 및리스트에있는 다른 한 쌍의 요소를 문서화하는데 도움이된다.</target>
        </trans-unit>
        <trans-unit id="efd3e2bb957eaa0ff2ef103df55bdfaea8225389" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;=back&lt;/code&gt; command does not take any arguments.</source>
          <target state="translated">&lt;code&gt;=back&lt;/code&gt; 명령은 인수를 가지고 있지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2748bc14f635bff7b4cada98a19718c4d6f31834" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;=begin&lt;/code&gt; directive can mark a section for a particular purpose. If the Pod parser doesn't want to handle it, it just ignores it. Label the comments with &lt;code&gt;comment&lt;/code&gt; . End the comment using &lt;code&gt;=end&lt;/code&gt; with the same label. You still need the &lt;code&gt;=cut&lt;/code&gt; to go back to Perl code from the Pod comment:</source>
          <target state="translated">&lt;code&gt;=begin&lt;/code&gt; 특정 목적에 대한 섹션을 표시 할 수 있습니다 지시자. 포드 파서가이를 처리하지 않으려면 무시합니다. 주석에 &lt;code&gt;comment&lt;/code&gt; 레이블을 지정하십시오 . 동일한 레이블로 &lt;code&gt;=end&lt;/code&gt; 를 사용하여 주석을 종료하십시오 . 포드 의견에서 Perl 코드로 돌아가려면 여전히 &lt;code&gt;=cut&lt;/code&gt; 이 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="f59fd3ccb5e9b7feba1f1fe25b7136044c1d07fe" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;=begin&lt;/code&gt; directive can mark a section for a particular purpose. If the Pod parser doesn't want to handle it, it just ignores it. Label the comments with &lt;code&gt;comment&lt;/code&gt;. End the comment using &lt;code&gt;=end&lt;/code&gt; with the same label. You still need the &lt;code&gt;=cut&lt;/code&gt; to go back to Perl code from the Pod comment:</source>
          <target state="translated">&lt;code&gt;=begin&lt;/code&gt; 특정 목적에 대한 섹션을 표시 할 수 있습니다 지시자. Pod 파서가 처리하지 않으려면 무시합니다. 주석으로 &lt;code&gt;comment&lt;/code&gt; 레이블을 지정합니다 . 동일한 레이블로 &lt;code&gt;=end&lt;/code&gt; 를 사용하여 주석을 끝 냅니다. 포드 주석에서 Perl 코드로 돌아가려면 여전히 &lt;code&gt;=cut&lt;/code&gt; 이 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="ef8064ce24f5339d152aec47e53a990ce73ae1e4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;=over&lt;/code&gt; command does not have a corresponding &lt;code&gt;=back&lt;/code&gt; before the next heading (&lt;code&gt;=head1&lt;/code&gt; or &lt;code&gt;=head2&lt;/code&gt; ) or the end of the file.</source>
          <target state="translated">&lt;code&gt;=over&lt;/code&gt; 명령은 해당이없는 &lt;code&gt;=back&lt;/code&gt; 다음 제목 앞에 ( &lt;code&gt;=head1&lt;/code&gt; 또는 &lt;code&gt;=head2&lt;/code&gt; ) 또는 파일의 끝을.</target>
        </trans-unit>
        <trans-unit id="e8028d211e346b9053331798c8e936f0c3ebfac6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;=over&lt;/code&gt; command does not have a corresponding &lt;code&gt;=back&lt;/code&gt; before the next heading (&lt;code&gt;=head1&lt;/code&gt; or &lt;code&gt;=head2&lt;/code&gt;) or the end of the file.</source>
          <target state="translated">&lt;code&gt;=over&lt;/code&gt; 명령은 해당이없는 &lt;code&gt;=back&lt;/code&gt; 다음 제목 앞에 ( &lt;code&gt;=head1&lt;/code&gt; 또는 &lt;code&gt;=head2&lt;/code&gt; ) 또는 파일의 끝을.</target>
        </trans-unit>
        <trans-unit id="8153dbca699722108378e052ce04788e510ab3df" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@EXPORT&lt;/code&gt; array tells Perl which of the extension's variables and subroutines should be placed into the calling package's namespace. Because you don't know if the user has already used your variable and subroutine names, it's vitally important to carefully select what to export. Do</source>
          <target state="translated">&lt;code&gt;@EXPORT&lt;/code&gt; 의 배열은 호출 패키지의 이름 공간에 배치해야 확장의 변수와 서브 루틴의 어떤 펄을 알려줍니다. 사용자가 변수 및 서브 루틴 이름을 이미 사용했는지 알 수 없으므로 내보낼 항목을 신중하게 선택하는 것이 매우 중요합니다. 하다</target>
        </trans-unit>
        <trans-unit id="59c8e98631ebe2ad43446558b18c0e9a67b97b20" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@array[1]&lt;/code&gt; is an array slice, although it has only one index. You can pull out multiple elements simultaneously by specifying additional indices as a list, like &lt;code&gt;@array[1,4,3,0]&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;@array[1]&lt;/code&gt; 는 단지 하나의 인덱스를 가지고 있지만, 어레이 슬라이스이다. &lt;code&gt;@array[1,4,3,0]&lt;/code&gt; 과 같은 추가 인덱스를 목록으로 지정하여 여러 요소를 동시에 끌어낼 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="acd3d23d5c24e2e27f46834d267601cebe9f5684" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@array[1]&lt;/code&gt; is an array slice, although it has only one index. You can pull out multiple elements simultaneously by specifying additional indices as a list, like &lt;code&gt;@array[1,4,3,0]&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;@array[1]&lt;/code&gt; 는 단지 하나의 인덱스를 가지고 있지만, 어레이 슬라이스이다. &lt;code&gt;@array[1,4,3,0]&lt;/code&gt; 과 같이 추가 인덱스를 목록으로 지정하여 여러 요소를 동시에 가져올 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="651c155493f8eecba5929c58d7483ab06d1863f4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ACTUAL&lt;/code&gt; tells &lt;code&gt;NEXT&lt;/code&gt; that there must actually be a next method to call, or it should throw an exception.</source>
          <target state="translated">&lt;code&gt;ACTUAL&lt;/code&gt; 말한다 &lt;code&gt;NEXT&lt;/code&gt; 를 가 실제로 호출에 다음 방법으로해야합니다, 또는 예외를 던질 것을.</target>
        </trans-unit>
        <trans-unit id="8e537d261fb0eb0877ceb1c6331c23797b3540cf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Alias&lt;/code&gt; module implements localization of the basic types within the</source>
          <target state="translated">&lt;code&gt;Alias&lt;/code&gt; 모듈 구현은 내 기본 유형의 현지화</target>
        </trans-unit>
        <trans-unit id="2c6a8f1a286c25be4929a3d652924543120a4cba" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Archive::Tar&lt;/code&gt; module can optionally use &lt;code&gt;Compress::Zlib&lt;/code&gt; (via the &lt;code&gt;IO::Zlib&lt;/code&gt; module) to access tar files that have been compressed with &lt;code&gt;gzip&lt;/code&gt; . Unfortunately tar files compressed with the Unix &lt;code&gt;compress&lt;/code&gt; utility cannot be read by &lt;code&gt;Compress::Zlib&lt;/code&gt; and so cannot be directly accesses by &lt;code&gt;Archive::Tar&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;Archive::Tar&lt;/code&gt; 모듈을 선택적으로 사용할 수있는 &lt;code&gt;Compress::Zlib&lt;/code&gt; (비아 &lt;code&gt;IO::Zlib&lt;/code&gt; 로 압축 한 액세스 tar 파일에 모듈을) &lt;code&gt;gzip&lt;/code&gt; . 불행히도 Unix &lt;code&gt;compress&lt;/code&gt; 유틸리티로 압축 된 tar 파일 은 &lt;code&gt;Compress::Zlib&lt;/code&gt; 읽을 수 없으므로 &lt;code&gt;Archive::Tar&lt;/code&gt; 직접 액세스 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="c846109c9cdb2321e2be7662c4588cdc7ec88db7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Archive::Tar&lt;/code&gt; module can optionally use &lt;code&gt;Compress::Zlib&lt;/code&gt; (via the &lt;code&gt;IO::Zlib&lt;/code&gt; module) to access tar files that have been compressed with &lt;code&gt;gzip&lt;/code&gt;. Unfortunately tar files compressed with the Unix &lt;code&gt;compress&lt;/code&gt; utility cannot be read by &lt;code&gt;Compress::Zlib&lt;/code&gt; and so cannot be directly accessed by &lt;code&gt;Archive::Tar&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Archive::Tar&lt;/code&gt; 모듈을 선택적으로 사용할 수있는 &lt;code&gt;Compress::Zlib&lt;/code&gt; (비아 &lt;code&gt;IO::Zlib&lt;/code&gt; 로 압축 한 액세스 tar 파일에 모듈을) &lt;code&gt;gzip&lt;/code&gt; . 불행히도 Unix &lt;code&gt;compress&lt;/code&gt; 유틸리티로 압축 된 tar 파일 은 &lt;code&gt;Compress::Zlib&lt;/code&gt; 읽을 수 없으므로 &lt;code&gt;Archive::Tar&lt;/code&gt; 직접 액세스 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="9b17fdbcd746a9f7c286b280ba85ada7dc1cad7d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Archive::Tar&lt;/code&gt; module can optionally use &lt;code&gt;Compress::Zlib&lt;/code&gt; (via the &lt;code&gt;IO::Zlib&lt;/code&gt; module) to access tar files that have been compressed with &lt;code&gt;gzip&lt;/code&gt;. Unfortunately tar files compressed with the Unix &lt;code&gt;compress&lt;/code&gt; utility cannot be read by &lt;code&gt;Compress::Zlib&lt;/code&gt; and so cannot be directly accesses by &lt;code&gt;Archive::Tar&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Archive::Tar&lt;/code&gt; 모듈을 선택적으로 사용할 수있는 &lt;code&gt;Compress::Zlib&lt;/code&gt; (비아 &lt;code&gt;IO::Zlib&lt;/code&gt; 로 압축 한 액세스 tar 파일에 모듈을) &lt;code&gt;gzip&lt;/code&gt; . 불행히도 Unix &lt;code&gt;compress&lt;/code&gt; 유틸리티로 압축 된 tar 파일 은 &lt;code&gt;Compress::Zlib&lt;/code&gt; 읽을 수 없으므로 &lt;code&gt;Archive::Tar&lt;/code&gt; 직접 액세스 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="43769b61441be000184345132a2a54dc3708064b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;B::COP&lt;/code&gt; class is used for &quot;nextstate&quot; and &quot;dbstate&quot; ops. As of Perl 5.22, it is also used for &quot;null&quot; ops that started out as COPs.</source>
          <target state="translated">&lt;code&gt;B::COP&lt;/code&gt; 클래스는 &quot;nextstate&quot;와 &quot;dbstate&quot;작전에 사용됩니다. Perl 5.22부터는 COP로 시작된 &quot;널&quot;연산에도 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="1a2938ca3d630d110b73048269c361ea78fb5cb1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;B&lt;/code&gt; module contains a set of utility functions for querying the current state of the Perl interpreter; typically these functions return objects from the B::SV and B::OP classes, or their derived classes. These classes in turn define methods for querying the resulting objects about their own internal state.</source>
          <target state="translated">&lt;code&gt;B&lt;/code&gt; 의 모듈은 펄 통역자의 현재 상태를 조회하는 유틸리티 함수의 세트를 포함한다; 일반적으로 이러한 함수는 B :: SV 및 B :: OP 클래스 또는 파생 클래스에서 객체를 반환합니다. 이러한 클래스는 결과 개체에 자체 내부 상태를 쿼리하는 메서드를 정의합니다.</target>
        </trans-unit>
        <trans-unit id="40f9413962f128106cd0802b4a2c73013cd7ed0c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;B&lt;/code&gt; module exports a variety of functions: some are simple utility functions, others provide a Perl program with a way to get an initial &quot;handle&quot; on an internal object.</source>
          <target state="translated">&lt;code&gt;B&lt;/code&gt; 의 모듈 수출 다양한 기능 : 일부는 간단한 유틸리티 기능이다가, 다른 내부 개체에 대한 초기 &quot;핸들&quot;을 얻을 수있는 방법이있는 펄 프로그램을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="5c92116836eedf111e1da108ac269b10e9e38e79" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;B&lt;/code&gt; module supplies classes which allow a Perl program to delve into its own innards. It is the module used to implement the &quot;backends&quot; of the Perl compiler. Usage of the compiler does not require knowledge of this module: see the</source>
          <target state="translated">&lt;code&gt;B&lt;/code&gt; 의 모듈 자체에 내장 파고 펄 프로그램 허용 클래스를 제공한다. Perl 컴파일러의 &quot;백엔드&quot;를 구현하는 데 사용되는 모듈입니다. 컴파일러 사용에는이 모듈에 대한 지식이 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="36e744ee541a84c63162e7b4ffbdc783bc6d5f1d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;BEGIN&lt;/code&gt; , &lt;code&gt;UNITCHECK&lt;/code&gt; , &lt;code&gt;CHECK&lt;/code&gt; , &lt;code&gt;INIT&lt;/code&gt; and &lt;code&gt;END&lt;/code&gt; subroutines are not so much subroutines as named special code blocks, of which you can have more than one in a package, and which you can &lt;b&gt;not&lt;/b&gt; call explicitly. See &lt;a href=&quot;perlmod#BEGIN%2c-UNITCHECK%2c-CHECK%2c-INIT-and-END&quot;&gt;BEGIN, UNITCHECK, CHECK, INIT and END in perlmod&lt;/a&gt;</source>
          <target state="translated">는 &lt;code&gt;BEGIN&lt;/code&gt; , &lt;code&gt;UNITCHECK&lt;/code&gt; , &lt;code&gt;CHECK&lt;/code&gt; , &lt;code&gt;INIT&lt;/code&gt; 및 &lt;code&gt;END&lt;/code&gt; 의 서브 루틴 당신이 패키지에 하나 이상을 가질 수있는 명명 된 특수 코드 블록으로 너무 많은 서브 루틴이 아니며, 어떤을 수행 할 수 &lt;b&gt;없습니다&lt;/b&gt; 명시 적으로 호출합니다. &lt;a href=&quot;perlmod#BEGIN%2c-UNITCHECK%2c-CHECK%2c-INIT-and-END&quot;&gt;perlmod에서 BEGIN, UNITCHECK, CHECK, INIT 및 END&lt;/a&gt; 참조</target>
        </trans-unit>
        <trans-unit id="b8aea840d46b0e93fbdf7c5fc764686c8f3b8c58" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;BEGIN&lt;/code&gt; forces the &lt;a href=&quot;#require-VERSION&quot;&gt;&lt;code&gt;require&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#import-LIST&quot;&gt;&lt;code&gt;import&lt;/code&gt;&lt;/a&gt; to happen at compile time. The &lt;a href=&quot;#require-VERSION&quot;&gt;&lt;code&gt;require&lt;/code&gt;&lt;/a&gt; makes sure the module is loaded into memory if it hasn't been yet. The &lt;a href=&quot;#import-LIST&quot;&gt;&lt;code&gt;import&lt;/code&gt;&lt;/a&gt; is not a builtin; it's just an ordinary static method call into the &lt;code&gt;Module&lt;/code&gt; package to tell the module to import the list of features back into the current package. The module can implement its &lt;a href=&quot;#import-LIST&quot;&gt;&lt;code&gt;import&lt;/code&gt;&lt;/a&gt; method any way it likes, though most modules just choose to derive their &lt;a href=&quot;#import-LIST&quot;&gt;&lt;code&gt;import&lt;/code&gt;&lt;/a&gt; method via inheritance from the &lt;code&gt;Exporter&lt;/code&gt; class that is defined in the &lt;a href=&quot;exporter&quot;&gt;&lt;code&gt;Exporter&lt;/code&gt;&lt;/a&gt; module. See &lt;a href=&quot;exporter&quot;&gt;Exporter&lt;/a&gt;. If no &lt;a href=&quot;#import-LIST&quot;&gt;&lt;code&gt;import&lt;/code&gt;&lt;/a&gt; method can be found, then the call is skipped, even if there is an AUTOLOAD method.</source>
          <target state="translated">는 &lt;code&gt;BEGIN&lt;/code&gt; (가) 힘 &lt;a href=&quot;#require-VERSION&quot;&gt; &lt;code&gt;require&lt;/code&gt; &lt;/a&gt; 하고 &lt;a href=&quot;#import-LIST&quot;&gt; &lt;code&gt;import&lt;/code&gt; &lt;/a&gt; 컴파일시에 발생 할 수 있습니다. 이 &lt;a href=&quot;#require-VERSION&quot;&gt; &lt;code&gt;require&lt;/code&gt; &lt;/a&gt; 은 모듈이 아직 메모리에로드되지 않은 경우로드되었는지 확인합니다. &lt;a href=&quot;#import-LIST&quot;&gt; &lt;code&gt;import&lt;/code&gt; &lt;/a&gt; 내장 명령 아니다; 기능 목록을 현재 패키지로 다시 가져 오도록 모듈에 지시 하는 &lt;code&gt;Module&lt;/code&gt; 패키지에 대한 일반적인 정적 메서드 호출 입니다. 모듈은 원하는 방식으로 &lt;a href=&quot;#import-LIST&quot;&gt; &lt;code&gt;import&lt;/code&gt; &lt;/a&gt; 메서드를 구현할 수 있지만 대부분의 모듈 은 &lt;a href=&quot;exporter&quot;&gt; &lt;code&gt;Exporter&lt;/code&gt; &lt;/a&gt; 모듈에 정의 된 &lt;code&gt;Exporter&lt;/code&gt; 클래스 에서 상속을 통해 &lt;a href=&quot;#import-LIST&quot;&gt; &lt;code&gt;import&lt;/code&gt; &lt;/a&gt; 메서드를 파생하도록 선택 합니다. &lt;a href=&quot;exporter&quot;&gt;내보내기를&lt;/a&gt; 참조하십시오 . 아니라면&lt;a href=&quot;#import-LIST&quot;&gt; &lt;code&gt;import&lt;/code&gt; &lt;/a&gt; 메서드를 찾을 수 있으면 AUTOLOAD 메서드가 있더라도 호출을 건너 뜁니다.</target>
        </trans-unit>
        <trans-unit id="38a9cf1f5e3f21b86fcbb8df98f12cbc38b145e5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;BEGIN&lt;/code&gt; forces the &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; to happen at compile time. The &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; makes sure the module is loaded into memory if it hasn't been yet. The &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; is not a builtin; it's just an ordinary static method call into the &lt;code&gt;Module&lt;/code&gt; package to tell the module to import the list of features back into the current package. The module can implement its &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; method any way it likes, though most modules just choose to derive their &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; method via inheritance from the &lt;code&gt;Exporter&lt;/code&gt; class that is defined in the &lt;code&gt;Exporter&lt;/code&gt; module. See &lt;a href=&quot;exporter&quot;&gt;Exporter&lt;/a&gt;. If no &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; method can be found then the call is skipped, even if there is an AUTOLOAD method.</source>
          <target state="translated">는 &lt;code&gt;BEGIN&lt;/code&gt; (가) 힘 &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; 하고 &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; 컴파일시에 발생 할 수 있습니다. 이 &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; 아직하지 않은 경우 확인 모듈이 메모리에로드 차종을. &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; 내장 명령 아니다; &lt;code&gt;Module&lt;/code&gt; 패키지에 기능 목록을 다시 현재 패키지로 가져 오도록 지시 하는 것은 일반적인 정적 메소드 호출 입니다. 모듈은 원하는 방식으로 &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; 메소드를 구현할 수 있지만 대부분의 모듈 은 &lt;code&gt;Exporter&lt;/code&gt; 모듈에 정의 된 &lt;code&gt;Exporter&lt;/code&gt; 클래스 에서 상속을 통해 &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; 메소드를 파생하도록 선택 합니다. &lt;a href=&quot;exporter&quot;&gt;내보내기를&lt;/a&gt; 참조하십시오 . 그렇지 않다면 &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; 메소드를 찾은 다음 AUTOLOAD 메소드가 있어도 호출을 건너 뜁니다.</target>
        </trans-unit>
        <trans-unit id="a9fa3a73043129ebc13296822d30d370f57d9e72" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;BEGIN&lt;/code&gt; forces the &lt;code&gt;&lt;a href=&quot;require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; to happen at compile time. The &lt;code&gt;&lt;a href=&quot;require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; makes sure the module is loaded into memory if it hasn't been yet. The &lt;code&gt;&lt;a href=&quot;import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; is not a builtin; it's just an ordinary static method call into the &lt;code&gt;Module&lt;/code&gt; package to tell the module to import the list of features back into the current package. The module can implement its &lt;code&gt;&lt;a href=&quot;import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; method any way it likes, though most modules just choose to derive their &lt;code&gt;&lt;a href=&quot;import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; method via inheritance from the &lt;code&gt;Exporter&lt;/code&gt; class that is defined in the &lt;code&gt;Exporter&lt;/code&gt; module. See &lt;a href=&quot;../exporter&quot;&gt;Exporter&lt;/a&gt;. If no &lt;code&gt;&lt;a href=&quot;import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; method can be found then the call is skipped, even if there is an AUTOLOAD method.</source>
          <target state="translated">는 &lt;code&gt;BEGIN&lt;/code&gt; (가) 힘 &lt;code&gt;&lt;a href=&quot;require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; 하고 &lt;code&gt;&lt;a href=&quot;import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; 컴파일시에 발생 할 수 있습니다. 이 &lt;code&gt;&lt;a href=&quot;require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; 아직하지 않은 경우 확인 모듈이 메모리에로드 차종을. &lt;code&gt;&lt;a href=&quot;import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; 내장 명령 아니다; &lt;code&gt;Module&lt;/code&gt; 패키지에 기능 목록을 다시 현재 패키지로 가져 오도록 지시 하는 것은 일반적인 정적 메소드 호출 입니다. 모듈은 원하는 방식으로 &lt;code&gt;&lt;a href=&quot;import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; 메소드를 구현할 수 있지만 대부분의 모듈 은 &lt;code&gt;Exporter&lt;/code&gt; 모듈에 정의 된 &lt;code&gt;Exporter&lt;/code&gt; 클래스 에서 상속을 통해 &lt;code&gt;&lt;a href=&quot;import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; 메소드를 파생하도록 선택 합니다. &lt;a href=&quot;../exporter&quot;&gt;내보내기를&lt;/a&gt; 참조하십시오 . 그렇지 않다면 &lt;code&gt;&lt;a href=&quot;import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; 메소드를 찾은 다음 AUTOLOAD 메소드가 있어도 호출을 건너 뜁니다.</target>
        </trans-unit>
        <trans-unit id="9201471b5261b8b4c37aca6c270b666c4082753d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;BEGIN&lt;/code&gt; will assure that the loading of</source>
          <target state="translated">는 &lt;code&gt;BEGIN&lt;/code&gt; 의 로딩 것을 보장합니다</target>
        </trans-unit>
        <trans-unit id="1df83aa021f2d25a04664c457983f82d52813309" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;BEGIN&lt;/code&gt;, &lt;code&gt;UNITCHECK&lt;/code&gt;, &lt;code&gt;CHECK&lt;/code&gt;, &lt;code&gt;INIT&lt;/code&gt; and &lt;code&gt;END&lt;/code&gt; subroutines are not so much subroutines as named special code blocks, of which you can have more than one in a package, and which you can &lt;b&gt;not&lt;/b&gt; call explicitly. See &lt;a href=&quot;perlmod#BEGIN%2C-UNITCHECK%2C-CHECK%2C-INIT-and-END&quot;&gt;&quot;BEGIN, UNITCHECK, CHECK, INIT and END&quot; in perlmod&lt;/a&gt;</source>
          <target state="translated">는 &lt;code&gt;BEGIN&lt;/code&gt; , &lt;code&gt;UNITCHECK&lt;/code&gt; , &lt;code&gt;CHECK&lt;/code&gt; , &lt;code&gt;INIT&lt;/code&gt; 및 &lt;code&gt;END&lt;/code&gt; 의 서브 루틴 당신이 패키지에 하나 이상을 가질 수있는 명명 된 특수 코드 블록으로 너무 많은 서브 루틴이 아니며, 어떤을 수행 할 수 &lt;b&gt;없습니다&lt;/b&gt; 명시 적으로 호출합니다. &lt;a href=&quot;perlmod#BEGIN%2C-UNITCHECK%2C-CHECK%2C-INIT-and-END&quot;&gt;perlmod의 &quot;BEGIN, UNITCHECK, CHECK, INIT 및 END&quot;를&lt;/a&gt; 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="08a5cc1adfa77075f0adc752b299d298837ebeee" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;CHECK&lt;/code&gt; and &lt;code&gt;INIT&lt;/code&gt; blocks in code compiled by &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt;, string &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt;&lt;/code&gt;, or string &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; will not be executed if they occur after the end of the main compilation phase; that can be a problem in mod_perl and other persistent environments which use those functions to load code at runtime.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; , string &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt;&lt;/code&gt; 또는 string &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 에 의해 컴파일 된 코드 의 &lt;code&gt;CHECK&lt;/code&gt; 및 &lt;code&gt;INIT&lt;/code&gt; 블록 은 기본 컴파일 단계가 끝난 후에 발생하면 실행되지 않습니다. 이는 mod_perl 및 런타임시 코드를로드하기 위해 해당 함수를 사용하는 기타 영구 환경에서 문제가 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b104eb26cbd94be033237435dd68c95041e8eb25" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;CHECK&lt;/code&gt; and &lt;code&gt;INIT&lt;/code&gt; blocks in code compiled by &lt;code&gt;require&lt;/code&gt;, string &lt;code&gt;do&lt;/code&gt;, or string &lt;code&gt;eval&lt;/code&gt; will not be executed if they occur after the end of the main compilation phase; that can be a problem in mod_perl and other persistent environments which use those functions to load code at runtime.</source>
          <target state="translated">&lt;code&gt;require&lt;/code&gt; , string &lt;code&gt;do&lt;/code&gt; 또는 string &lt;code&gt;eval&lt;/code&gt; 에 의해 컴파일 된 코드 의 &lt;code&gt;CHECK&lt;/code&gt; 및 &lt;code&gt;INIT&lt;/code&gt; 블록 은 기본 컴파일 단계가 끝난 후에 발생하는 경우 실행되지 않습니다. 이는 mod_perl 및 이러한 함수를 사용하여 런타임에 코드를로드하는 기타 영구 환경에서 문제가 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="981efa7d62f736b9f150f24425de3b13fd11e4dc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;CNS11643&lt;/code&gt; encoding files are not complete. For common &lt;code&gt;CNS11643&lt;/code&gt; manipulation, please use &lt;code&gt;EUC-TW&lt;/code&gt; in &lt;a href=&quot;Encode::HanExtra&quot;&gt;Encode::HanExtra&lt;/a&gt;, which contains planes 1-7.</source>
          <target state="translated">&lt;code&gt;CNS11643&lt;/code&gt; 인코딩 파일이 완료되지 않습니다. 일반적인 &lt;code&gt;CNS11643&lt;/code&gt; 조작의 경우 1-7 평면을 포함하는 &lt;a href=&quot;Encode::HanExtra&quot;&gt;Encode :: HanExtra&lt;/a&gt; 에서 &lt;code&gt;EUC-TW&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="9d8f4372f9a2ba513ea1d0d1264224c42f7ba97c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;CNS11643&lt;/code&gt; encoding files are not complete. For common &lt;code&gt;CNS11643&lt;/code&gt; manipulation, please use &lt;code&gt;EUC-TW&lt;/code&gt; in &lt;a href=&quot;http://search.cpan.org/perldoc/Encode::HanExtra&quot;&gt;Encode::HanExtra&lt;/a&gt;, which contains planes 1-7.</source>
          <target state="translated">&lt;code&gt;CNS11643&lt;/code&gt; 인코딩 파일이 완료되지 않습니다. 일반적인 &lt;code&gt;CNS11643&lt;/code&gt; 조작의 경우 평면 1-7이 포함 된 &lt;a href=&quot;http://search.cpan.org/perldoc/Encode::HanExtra&quot;&gt;Encode :: HanExtra&lt;/a&gt; 에서 &lt;code&gt;EUC-TW&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="82651f5375f4780d1c104db566c2ac41e7d83b9e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;CORE&lt;/code&gt; namespace gives access to the original built-in functions of Perl. The &lt;code&gt;CORE&lt;/code&gt; package is built into Perl, and therefore you do not need to use or require a hypothetical &quot;CORE&quot; module prior to accessing routines in this namespace.</source>
          <target state="translated">&lt;code&gt;CORE&lt;/code&gt; 의 네임 스페이스는 내장 된 펄의 기능 원본에 액세스 할 수 있습니다. &lt;code&gt;CORE&lt;/code&gt; 의 패키지는 펄에 내장되어, 따라서 당신은 사용할 필요가 없습니다 또는이 네임 스페이스에서 루틴을 접근하기 전에 가상의 &quot;핵심&quot;모듈이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="8ae42d583657def46159ee7ad1318ba4bd6a3fc1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Compress::Zlib&lt;/code&gt; module can be split into two general areas of functionality, namely a simple read/write interface to</source>
          <target state="translated">&lt;code&gt;Compress::Zlib&lt;/code&gt; 모듈 기능의 일반적인 두 영역으로 분할 될 수있다, 즉, 단순 / 쓰기 인터페이스에 판독</target>
        </trans-unit>
        <trans-unit id="46e8d3223a09166ecaf398dcfdae3710dcb3dcb7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;DATA&lt;/code&gt; file handle by default has whatever PerlIO layers were in place when Perl read the file to parse the source. Normally that means that the file is being read bytewise, as if it were encoded in Latin-1, but there are two major ways for it to be otherwise. Firstly, if the &lt;code&gt;__END__&lt;/code&gt;/&lt;code&gt;__DATA__&lt;/code&gt; token is in the scope of a &lt;code&gt;use utf8&lt;/code&gt; pragma then the &lt;code&gt;DATA&lt;/code&gt; handle will be in UTF-8 mode. And secondly, if the source is being read from perl's standard input then the &lt;code&gt;DATA&lt;/code&gt; file handle is actually aliased to the &lt;code&gt;STDIN&lt;/code&gt; file handle, and may be in UTF-8 mode because of the &lt;code&gt;PERL_UNICODE&lt;/code&gt; environment variable or perl's command-line switches.</source>
          <target state="translated">&lt;code&gt;DATA&lt;/code&gt; 기본적으로 파일 핸들은 펄 소스를 구문 분석 할 파일을 읽을 때은 PerlIO 레이어 자리에 있던 어떤있다. 일반적으로 이는 마치 Latin-1로 인코딩 된 것처럼 파일이 바이트 단위로 읽혀지는 것을 의미하지만 그렇지 않은 두 가지 주요 방법이 있습니다. 첫째, &lt;code&gt;__END__&lt;/code&gt; / &lt;code&gt;__DATA__&lt;/code&gt; 토큰이 &lt;code&gt;use utf8&lt;/code&gt; pragma 사용 범위에 있으면 &lt;code&gt;DATA&lt;/code&gt; 핸들은 UTF-8 모드가됩니다. 둘째, 소스가 perl의 표준 입력에서 읽혀지면 &lt;code&gt;DATA&lt;/code&gt; 파일 핸들은 실제로 &lt;code&gt;STDIN&lt;/code&gt; 파일 핸들로 별칭이 지정되며 &lt;code&gt;PERL_UNICODE&lt;/code&gt; 환경 변수 또는 perl의 명령 줄 스위치 로 인해 UTF-8 모드에있을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b6db4ade377c3bdb345b712f7106420996bb7261" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;DB::OUT&lt;/code&gt; filehandle is opened to</source>
          <target state="translated">&lt;code&gt;DB::OUT&lt;/code&gt; 핸들이에 열립니다</target>
        </trans-unit>
        <trans-unit id="3f0a37f63cf06fefd13078baff9b2ef8733fd16b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;DB&lt;/code&gt; and &lt;code&gt;main&lt;/code&gt; packages are always omitted, as are any &quot;private&quot; packages that have leading underscores in the namespace (e.g. &lt;code&gt;Foo::_private&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;DB&lt;/code&gt; 및 &lt;code&gt;main&lt;/code&gt; 패키지는 항상 네임 스페이스에서 최고의 밑줄을 가지고있는 &quot;개인&quot;패키지는, 생략 (예 : &lt;code&gt;Foo::_private&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="b7ced3778c80b0e6ddceec7627220df1317342e2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;DEBUG&lt;/code&gt; constant wipes the floor with even the &lt;code&gt;$debug&lt;/code&gt; variable, clocking in at minus zero seconds, and generates a &quot;warning: too few iterations for a reliable count&quot; message into the bargain. To see what is really going on, and why we had too few iterations when we thought we asked for 100000, we can use the very useful &lt;code&gt;B::Deparse&lt;/code&gt; to inspect the new code:</source>
          <target state="translated">&lt;code&gt;DEBUG&lt;/code&gt; 상수는 심지어 바닥을 쳐 &lt;code&gt;$debug&lt;/code&gt; 마이너스 제로 초에 클러킹, 변수 및 발생 &quot;경고 : 믿을 수가 너무 몇 반복&quot;매매에 메시지. 우리가 실제로 무슨 일이 일어나고 있는지, 그리고 왜 우리가 100000을 요구한다고 생각했을 때 반복 횟수가 너무 &lt;code&gt;B::Deparse&lt;/code&gt; 매우 유용한 B :: Deparse 를 사용하여 새 코드를 검사 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c9d4dcbece0076153dceb385297ea42930b3d2ab" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;DOES&lt;/code&gt; method returns</source>
          <target state="translated">는 &lt;code&gt;DOES&lt;/code&gt; 방법 반환</target>
        </trans-unit>
        <trans-unit id="13b108bacf05fadc1d57d69518e2671634247ba4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Deparse&lt;/code&gt; flag makes Dump() run slower, since the XSUB implementation does not support it.</source>
          <target state="translated">&lt;code&gt;Deparse&lt;/code&gt; XSUB 구현을 지원하지 않기 때문에 플래그는, 느리게 실행 덤프를 ()합니다.</target>
        </trans-unit>
        <trans-unit id="1afec46de9e3c4185e7d2feb3396554e349575f1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Devel::NYTProf&lt;/code&gt; and &lt;code&gt;Devel::FindAmpersand&lt;/code&gt; modules can help you find uses of these problematic match variables in your code.</source>
          <target state="translated">&lt;code&gt;Devel::NYTProf&lt;/code&gt; 과 &lt;code&gt;Devel::FindAmpersand&lt;/code&gt; 모듈은 코드에서 이러한 문제가 일치하는 변수의 용도를 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7a6b56d230ad8470a46e41fa3a6181ade20a4909" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Devel::SmallProf&lt;/code&gt; profiler examines the runtime of your Perl program and produces a line-by-line listing to show how many times each line was called, and how long each line took to execute. It is called by supplying the familiar &lt;code&gt;-d&lt;/code&gt; flag to Perl at runtime.</source>
          <target state="translated">&lt;code&gt;Devel::SmallProf&lt;/code&gt; 프로파일 러는 펄 프로그램의 실행을 검사하고 라인 별 각 라인 호출 된 횟수를 표시하는 목록을 생성하고, 얼마나 각 라인은 실행했다. 익숙한 &lt;code&gt;-d&lt;/code&gt; 플래그를 런타임에 Perl 에 제공하여 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="e3e899b88f5d9c103f9957a381fb75493e4ca219" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Devel&lt;/code&gt; namespace has several modules which you can use to profile your Perl programs.</source>
          <target state="translated">&lt;code&gt;Devel&lt;/code&gt; 네임 스페이스는 당신이 당신의 펄 프로그램을 프로파일 링하는 데 사용할 수있는 여러 모듈이있다.</target>
        </trans-unit>
        <trans-unit id="f7b3b4bbb4e3a91049c3f2bf1c1599a52a4bab75" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Digest::&lt;/code&gt; interface is based on the interface originally developed by Neil Winton for his &lt;code&gt;MD5&lt;/code&gt; module.</source>
          <target state="translated">&lt;code&gt;Digest::&lt;/code&gt; 인터페이스는 원래 자신의 닐 윈튼에 의해 개발 된 인터페이스를 기반으로 &lt;code&gt;MD5&lt;/code&gt; 의 모듈.</target>
        </trans-unit>
        <trans-unit id="359f33360a7a83f14790bf4d659bef0945120eaf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Digest::&lt;/code&gt; modules calculate digests, also called &quot;fingerprints&quot; or &quot;hashes&quot;, of some data, called a message. The digest is (usually) some small/fixed size string. The actual size of the digest depend of the algorithm used. The message is simply a sequence of arbitrary bytes or bits.</source>
          <target state="translated">&lt;code&gt;Digest::&lt;/code&gt; 모듈은 메시지라는 일부 데이터,의, 또한 &quot;지문&quot;또는 &quot;해시&quot;라는 다이제스트를 계산합니다. 다이제스트는 (보통) 작고 고정 된 크기의 문자열입니다. 다이제스트의 실제 크기는 사용 된 알고리즘에 따라 다릅니다. 메시지는 단순히 임의의 바이트 또는 비트 시퀀스입니다.</target>
        </trans-unit>
        <trans-unit id="5112b49f2609b19e911cd2f6a34cb7ffa7088cff" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Digest::MD5&lt;/code&gt; module allows you to use the RSA Data Security Inc. MD5 Message Digest algorithm from within Perl programs. The algorithm takes as input a message of arbitrary length and produces as output a 128-bit &quot;fingerprint&quot; or &quot;message digest&quot; of the input.</source>
          <target state="translated">&lt;code&gt;Digest::MD5&lt;/code&gt; 모듈은 펄 프로그램 내에서 RSA 데이터 보안 Inc.의 MD5 메시지 다이제스트 알고리즘을 사용할 수 있습니다. 이 알고리즘은 임의 길이의 메시지를 입력으로 사용하고 입력의 128 비트 &quot;지문&quot;또는 &quot;메시지 요약&quot;을 출력으로 생성합니다.</target>
        </trans-unit>
        <trans-unit id="2adafeb0e9eb580775e9922353cdda9ed2fef18a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Digest::MD5&lt;/code&gt; module is written by Gisle Aas &amp;lt;gisle@ActiveState.com&amp;gt;.</source>
          <target state="translated">&lt;code&gt;Digest::MD5&lt;/code&gt; 모듈은 Gisle Aas에 &amp;lt;gisle@ActiveState.com&amp;gt;에 의해 작성되었습니다.</target>
        </trans-unit>
        <trans-unit id="048cfda097524929fcf424f6794f7c010276767b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Digest::MD5&lt;/code&gt; module provide a procedural interface for simple use, as well as an object oriented interface that can handle messages of arbitrary length and which can read files directly.</source>
          <target state="translated">&lt;code&gt;Digest::MD5&lt;/code&gt; 간단한 사용하기위한 절차 인터페이스뿐만 아니라, 직접 파일을 읽을 수있는 임의의 길이의 메시지를 처리 할 수있는 객체 지향 인터페이스를 제공하는 모듈.</target>
        </trans-unit>
        <trans-unit id="417545c4adfbc434083e36d20bccbfb0f99aa98e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Digest::base&lt;/code&gt; class provide implementations of the methods &lt;code&gt;addfile&lt;/code&gt; and &lt;code&gt;add_bits&lt;/code&gt; in terms of &lt;code&gt;add&lt;/code&gt; , and of the methods &lt;code&gt;hexdigest&lt;/code&gt; and &lt;code&gt;b64digest&lt;/code&gt; in terms of &lt;code&gt;digest&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;Digest::base&lt;/code&gt; 클래스 메소드의 구현을 제공 &lt;code&gt;addfile&lt;/code&gt; 및 &lt;code&gt;add_bits&lt;/code&gt; 을 측면에서 &lt;code&gt;add&lt;/code&gt; 및 방법의 &lt;code&gt;hexdigest&lt;/code&gt; 및 &lt;code&gt;b64digest&lt;/code&gt; 의 측면에서 &lt;code&gt;digest&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1c6996a284acc9e86940a92ab690a3ac4f18b4dc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Digest::base&lt;/code&gt; class provide implementations of the methods &lt;code&gt;addfile&lt;/code&gt; and &lt;code&gt;add_bits&lt;/code&gt; in terms of &lt;code&gt;add&lt;/code&gt;, and of the methods &lt;code&gt;hexdigest&lt;/code&gt; and &lt;code&gt;b64digest&lt;/code&gt; in terms of &lt;code&gt;digest&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Digest::base&lt;/code&gt; 클래스 메소드의 구현을 제공 &lt;code&gt;addfile&lt;/code&gt; 및 &lt;code&gt;add_bits&lt;/code&gt; 을 측면에서 &lt;code&gt;add&lt;/code&gt; 및 방법의 &lt;code&gt;hexdigest&lt;/code&gt; 및 &lt;code&gt;b64digest&lt;/code&gt; 의 측면에서 &lt;code&gt;digest&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="628d5f24b15638f2c6ff193717192cc425ae4155" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;DirHandle&lt;/code&gt; method provide an alternative interface to the opendir(), closedir(), readdir(), and rewinddir() functions.</source>
          <target state="translated">&lt;code&gt;DirHandle&lt;/code&gt; 방법)이했던 opendir (), closedir ()가 readdir (대안 인터페이스를 제공하고, rewinddir () 함수.</target>
        </trans-unit>
        <trans-unit id="358ca39e53232388840862f052183678f86697cd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Dump()&lt;/code&gt; function takes one or two arguments: something to dump, and an optional limit for recursion and array elements (default is 4). The first argument is evaluted in rvalue scalar context, with exceptions for @array and %hash, which dump the array or hash itself. So &lt;code&gt;Dump @array&lt;/code&gt; works, as does &lt;code&gt;Dump $foo&lt;/code&gt; . And &lt;code&gt;Dump &lt;a href=&quot;../functions/pos&quot;&gt;pos&lt;/a&gt;&lt;/code&gt; will call &lt;code&gt;&lt;a href=&quot;../functions/pos&quot;&gt;pos&lt;/a&gt;&lt;/code&gt; in rvalue context, whereas &lt;code&gt;Dump ${\&lt;a href=&quot;../functions/pos&quot;&gt;pos&lt;/a&gt;}&lt;/code&gt; will call it in lvalue context.</source>
          <target state="translated">&lt;code&gt;Dump()&lt;/code&gt; 덤프 뭔가 및 재귀 및 배열 요소의 선택적 제한 (기본값 4) : 기능은 하나 개 또는 두 개의 인수를 사용합니다. 배열이나 해시 자체를 덤프하는 @array 및 % hash를 제외하고 rvalue 스칼라 컨텍스트에서 첫 번째 인수가 제거됩니다. 따라서 &lt;code&gt;Dump @array&lt;/code&gt; 는 &lt;code&gt;Dump $foo&lt;/code&gt; 와 같이 작동합니다 . 그리고 &lt;code&gt;Dump &lt;a href=&quot;../functions/pos&quot;&gt;pos&lt;/a&gt;&lt;/code&gt; 호출 &lt;code&gt;&lt;a href=&quot;../functions/pos&quot;&gt;pos&lt;/a&gt;&lt;/code&gt; 반면를 rvalue 맥락에서 &lt;code&gt;Dump ${\&lt;a href=&quot;../functions/pos&quot;&gt;pos&lt;/a&gt;}&lt;/code&gt; 좌변 맥락에서 그것을 호출합니다.</target>
        </trans-unit>
        <trans-unit id="a13938ff22176b323e1b3258e2271152d9209b89" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Dump()&lt;/code&gt; function takes one or two arguments: something to dump, and an optional limit for recursion and array elements (default is 4). The first argument is evaluted in rvalue scalar context, with exceptions for @array and %hash, which dump the array or hash itself. So &lt;code&gt;Dump @array&lt;/code&gt; works, as does &lt;code&gt;Dump $foo&lt;/code&gt;. And &lt;code&gt;Dump pos&lt;/code&gt; will call &lt;code&gt;pos&lt;/code&gt; in rvalue context, whereas &lt;code&gt;Dump ${\pos}&lt;/code&gt; will call it in lvalue context.</source>
          <target state="translated">&lt;code&gt;Dump()&lt;/code&gt; 덤프 뭔가 및 재귀 및 배열 요소의 선택적 제한 (기본값 4) : 기능은 하나 개 또는 두 개의 인수를 사용합니다. 첫 번째 인수는 배열 또는 해시 자체를 덤프하는 @array 및 % hash에 대한 예외를 제외하고 rvalue 스칼라 컨텍스트에서 평가됩니다. 그래서 &lt;code&gt;Dump @array&lt;/code&gt; 는 &lt;code&gt;Dump $foo&lt;/code&gt; 처럼 작동합니다 . 그리고 &lt;code&gt;Dump pos&lt;/code&gt; 호출 &lt;code&gt;pos&lt;/code&gt; 반면를 rvalue 맥락에서 &lt;code&gt;Dump ${\pos}&lt;/code&gt; 좌변 맥락에서 그것을 호출합니다.</target>
        </trans-unit>
        <trans-unit id="cdbf79b7555598c068ba8d9743bee2fb95392923" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Dump()&lt;/code&gt; function, by default, dumps up to 4 elements from a toplevel array or hash. This number can be increased by supplying a second argument to the function.</source>
          <target state="translated">&lt;code&gt;Dump()&lt;/code&gt; 함수는, 기본적으로 최상위 배열 또는 해시 4 개 요소까지 덤프. 이 숫자는 함수에 두 번째 인수를 제공하여 증가시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c95778d99c76e8e03e061209f2b6b5768436be5a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;END&lt;/code&gt; block isn't called when untrapped signals kill the program, though, so if you use &lt;code&gt;END&lt;/code&gt; blocks you should also use</source>
          <target state="translated">&lt;code&gt;END&lt;/code&gt; 포착되지 않은 신호는하지만, 프로그램을 죽일 때 블록은 사용 그렇다면, 호출되지 않습니다 &lt;code&gt;END&lt;/code&gt; 사용자는 사용도해야 블록을</target>
        </trans-unit>
        <trans-unit id="f434d74067f98a36c01cbe9c20f7d7cf7b02ed54" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;EXPR&lt;/code&gt; following the modifier is referred to as the &quot;condition&quot;. Its truth or falsehood determines how the modifier will behave.</source>
          <target state="translated">수정 자 뒤 의 &lt;code&gt;EXPR&lt;/code&gt; 을 &quot;조건&quot;이라고합니다. 그것의 진실 또는 거짓은 수정자가 동작하는 방법을 결정합니다.</target>
        </trans-unit>
        <trans-unit id="0be035a23dc6f5f75a5bb7fdc10fe00056028240" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Encode&lt;/code&gt; module knows about many encodings and has interfaces for doing conversions between those encodings:</source>
          <target state="translated">&lt;code&gt;Encode&lt;/code&gt; 모듈은 여러 인코딩에 대해 알고 그 인코딩 사이의 변환을 수행하기위한 인터페이스를 가지고 :</target>
        </trans-unit>
        <trans-unit id="5cdf933f51543c5ce4713919bd68bbd3f797378f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Encode&lt;/code&gt; module provides the interface between Perl strings and the rest of the system. Perl strings are sequences of</source>
          <target state="translated">&lt;code&gt;Encode&lt;/code&gt; 모듈 펄 문자열 및 시스템의 나머지 사이의 인터페이스를 제공한다. 펄 문자열은</target>
        </trans-unit>
        <trans-unit id="4968644a1dddd78111692e0824f91d81d4b5fde6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Env::import()&lt;/code&gt; function ties environment variables with suitable names to global Perl variables with the same names. By default it ties all existing environment variables (&lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt; %ENV&lt;/code&gt; ) to scalars. If the &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; function receives arguments, it takes them to be a list of variables to tie; it's okay if they don't yet exist. The scalar type prefix '$' is inferred for any element of this list not prefixed by '$' or '@'. Arrays are implemented in terms of &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/join&quot;&gt;join&lt;/a&gt;&lt;/code&gt;, using &lt;code&gt;$Config::Config{path_sep}&lt;/code&gt; as the delimiter.</source>
          <target state="translated">&lt;code&gt;Env::import()&lt;/code&gt; 과 동일한 이름을 가진 펄 글로벌 변수에 대한 적절한 이름과 함수 관계 환경 변수. 기본적으로 모든 기존 환경 변수 ( &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt; %ENV&lt;/code&gt; )를 스칼라에 연결합니다. 경우] &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; 기능 인자를 수신하고, 그 넥타이 변수 목록으로 그들을 얻어; 아직 존재하지 않으면 괜찮습니다. 스칼라 유형 접두어 '$'는이 목록의 모든 요소에 대해 '$'또는 '@'이 앞에 붙지 않습니다. 배열은 &lt;code&gt;$Config::Config{path_sep}&lt;/code&gt; 를 구분자로 사용하여 &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;functions/join&quot;&gt;join&lt;/a&gt;&lt;/code&gt; 측면에서 구현됩니다 .</target>
        </trans-unit>
        <trans-unit id="5d5e15ad1a58fa2627594efcd21d9bd55ca58029" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Env::import()&lt;/code&gt; function ties environment variables with suitable names to global Perl variables with the same names. By default it ties all existing environment variables (&lt;code&gt;keys %ENV&lt;/code&gt;) to scalars. If the &lt;code&gt;import&lt;/code&gt; function receives arguments, it takes them to be a list of variables to tie; it's okay if they don't yet exist. The scalar type prefix '$' is inferred for any element of this list not prefixed by '$' or '@'. Arrays are implemented in terms of &lt;code&gt;split&lt;/code&gt; and &lt;code&gt;join&lt;/code&gt;, using &lt;code&gt;$Config::Config{path_sep}&lt;/code&gt; as the delimiter.</source>
          <target state="translated">&lt;code&gt;Env::import()&lt;/code&gt; 과 동일한 이름을 가진 펄 글로벌 변수에 대한 적절한 이름과 함수 관계 환경 변수. 기본적으로 모든 기존 환경 변수 ( &lt;code&gt;keys %ENV&lt;/code&gt; )를 스칼라에 연결합니다. 경우] &lt;code&gt;import&lt;/code&gt; 기능 인자를 수신하고, 그 넥타이 변수 목록으로 그들을 얻어; 아직 존재하지 않아도 괜찮습니다. 스칼라 형식 접두사 '$'는 '$'또는 '@'접두사가없는이 목록의 모든 요소에 대해 유추됩니다. 배열은 구분 기호로 &lt;code&gt;$Config::Config{path_sep}&lt;/code&gt; 를 사용하여 &lt;code&gt;split&lt;/code&gt; 및 &lt;code&gt;join&lt;/code&gt; 측면에서 구현됩니다 .</target>
        </trans-unit>
        <trans-unit id="2cb5e18a95e482684c2bead13158da2042ed8e01" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ExtUtils::ParseXS&lt;/code&gt; object.</source>
          <target state="translated">&lt;code&gt;ExtUtils::ParseXS&lt;/code&gt; 객체.</target>
        </trans-unit>
        <trans-unit id="04fe8159aef76b700007013f5b9be387367b2a84" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ExtraFieldLocal&lt;/code&gt; option is used to store additional metadata in the local header for the zip file/buffer. The &lt;code&gt;ExtraFieldCentral&lt;/code&gt; does the same for the matching central header.</source>
          <target state="translated">&lt;code&gt;ExtraFieldLocal&lt;/code&gt; 옵션 zip 파일 / 버퍼 로컬 헤더에 추가적인 메타 데이터를 저장하는데 사용된다. &lt;code&gt;ExtraFieldCentral&lt;/code&gt; 가 일치하는 중앙 헤더 동일한다.</target>
        </trans-unit>
        <trans-unit id="7dceaf4fc99f40b45472fc6396adb3cf093b19ff" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;FREETMPS&lt;/code&gt; /&lt;code&gt;LEAVE&lt;/code&gt; pair will get rid of any values returned by the Perl subroutine (see next example), plus it will also dump the mortal SVs we have created. Having &lt;code&gt;ENTER&lt;/code&gt; /&lt;code&gt;SAVETMPS&lt;/code&gt; at the beginning of the code makes sure that no other mortals are destroyed.</source>
          <target state="translated">&lt;code&gt;FREETMPS&lt;/code&gt; / &lt;code&gt;LEAVE&lt;/code&gt; 의 쌍은 펄 서브 루틴 (다음 예 참조)에 의해 반환되는 모든 값을 제거 얻을 것이다 플러스, 그것은 또한 우리가 만든 인간의 SV를 덤프합니다. 코드 시작 부분에 &lt;code&gt;ENTER&lt;/code&gt; / &lt;code&gt;SAVETMPS&lt;/code&gt; 가 있으면 다른 필사자가 파괴되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="140fe01c0b7ba42e4663eeef8254f0e842ecf849" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;FREETMPS&lt;/code&gt;/&lt;code&gt;LEAVE&lt;/code&gt; pair will get rid of any values returned by the Perl subroutine (see next example), plus it will also dump the mortal SVs we have created. Having &lt;code&gt;ENTER&lt;/code&gt;/&lt;code&gt;SAVETMPS&lt;/code&gt; at the beginning of the code makes sure that no other mortals are destroyed.</source>
          <target state="translated">&lt;code&gt;FREETMPS&lt;/code&gt; / &lt;code&gt;LEAVE&lt;/code&gt; 의 쌍은 펄 서브 루틴 (다음 예 참조)에 의해 반환되는 모든 값을 제거 얻을 것이다 플러스, 그것은 또한 우리가 만든 인간의 SV를 덤프합니다. 코드 시작 부분에 &lt;code&gt;ENTER&lt;/code&gt; / &lt;code&gt;SAVETMPS&lt;/code&gt; 가 있으면 다른 필사자가 파괴되지 않도록합니다.</target>
        </trans-unit>
        <trans-unit id="a6ea08916fc715ad11c85a7aa69540693ba076ee" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;FREEZE&lt;/code&gt; method can return any number of values (i.e. zero or more). These values and the paclkage/classname of the object will then be encoded as a tagged JSON value in the following format:</source>
          <target state="translated">&lt;code&gt;FREEZE&lt;/code&gt; 메서드는 원하는 수의 값 (즉, 0 개 이상)을 반환 할 수 있습니다 . ㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ 이러한 값과 객체의 패키지 / 클래스 이름은 다음 형식의 태그가 지정된 JSON 값으로 인코딩됩니다.</target>
        </trans-unit>
        <trans-unit id="577b209cddb0e754330f4709ee24d502c593af10" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;G_RETHROW&lt;/code&gt; flag can be used if you only need eval_sv() to execute code specified by a string, but not catch any errors.</source>
          <target state="translated">&lt;code&gt;G_RETHROW&lt;/code&gt; 의 플래그 만 문자열로 지정 eval_sv ()을 실행하는 코드를 필요로하는 경우에 사용하지만 오류를 잡을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="94e4c30b0dc82b24659a532f35106fc4afecb721" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Host&lt;/code&gt; header is generated from the URL in accordance with RFC 2616. It is a fatal error to specify &lt;code&gt;Host&lt;/code&gt; in the &lt;code&gt;headers&lt;/code&gt; option. Other headers may be ignored or overwritten if necessary for transport compliance.</source>
          <target state="translated">&lt;code&gt;Host&lt;/code&gt; 헤더 지정하는 치명적인 오류가 RFC 2616에 따라 URL에서 생성되는 &lt;code&gt;Host&lt;/code&gt; 의 &lt;code&gt;headers&lt;/code&gt; 옵션을 선택합니다. 전송 규정 준수를 위해 필요한 경우 다른 헤더를 무시하거나 덮어 쓸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e1e824605b84cee8c0b954423f3ab5ef2eb2758b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;IN&lt;/code&gt; /&lt;code&gt;OUTLIST&lt;/code&gt; /&lt;code&gt;IN_OUTLIST&lt;/code&gt; /&lt;code&gt;IN_OUT&lt;/code&gt; /&lt;code&gt;OUT&lt;/code&gt; keywords can be mixed with ANSI-style declarations, as in</source>
          <target state="translated">&lt;code&gt;IN&lt;/code&gt; / &lt;code&gt;OUTLIST&lt;/code&gt; / &lt;code&gt;IN_OUTLIST&lt;/code&gt; / &lt;code&gt;IN_OUT&lt;/code&gt; / &lt;code&gt;OUT&lt;/code&gt; 의 키워드는 같이 ANSI 스타일 선언과 혼합 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="9f81634b914a660a9d16e3716c6017257055b0e8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;IN&lt;/code&gt;/&lt;code&gt;OUTLIST&lt;/code&gt;/&lt;code&gt;IN_OUTLIST&lt;/code&gt;/&lt;code&gt;IN_OUT&lt;/code&gt;/&lt;code&gt;OUT&lt;/code&gt; keywords can be mixed with ANSI-style declarations, as in</source>
          <target state="translated">&lt;code&gt;IN&lt;/code&gt; / &lt;code&gt;OUTLIST&lt;/code&gt; / &lt;code&gt;IN_OUTLIST&lt;/code&gt; / &lt;code&gt;IN_OUT&lt;/code&gt; / &lt;code&gt;OUT&lt;/code&gt; 의 키워드는 같이 ANSI 스타일 선언과 혼합 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="2291d3950c0f7a1274711a429d0d47b0e9604c3c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;INPUT&lt;/code&gt; and &lt;code&gt;OUTPUT&lt;/code&gt; sections have identical formats, that is, each unindented line starts a new in- or output map respectively. A new in- or output map must start with the name of the XS type to map on a line by itself, followed by the code that implements it indented on the following lines. Example:</source>
          <target state="translated">&lt;code&gt;INPUT&lt;/code&gt; 과 &lt;code&gt;OUTPUT&lt;/code&gt; 섹션 즉, 각 라인은 각각 들여 쓰기되지 않은 새로운 IN- 또는 출력 맵을 시작하고, 동일한 포맷을 가지고있다. 새로운 입력 또는 출력 맵은 XS 유형의 이름으로 시작하여 한 행에 직접 맵핑 한 후 다음 행에 들여 쓰기 된 코드를 구현해야합니다. 예:</target>
        </trans-unit>
        <trans-unit id="0839ebfa51c8f90f143d226a6a7f33a7ff311878" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;INT2PTR&lt;/code&gt; macro (defined in perl.h) casts an integer to a pointer of a given type, taking care of the possible different size of integers and pointers. There are also &lt;code&gt;PTR2IV&lt;/code&gt; , &lt;code&gt;PTR2UV&lt;/code&gt; , &lt;code&gt;PTR2NV&lt;/code&gt; macros, to map the other way, which may be useful in OUTPUT sections.</source>
          <target state="translated">&lt;code&gt;INT2PTR&lt;/code&gt; 의 (perl.h에 정의) 매크로는 정수와 포인터의 가능한 다른 크기의주의하면서 주어진 타입의 포인터에 정수를 캐스팅합니다. 도 있습니다 &lt;code&gt;PTR2IV&lt;/code&gt; , &lt;code&gt;PTR2UV&lt;/code&gt; , &lt;code&gt;PTR2NV&lt;/code&gt; 의 매크로는 OUTPUT 섹션에 유용 할 수있는 다른 방법을 매핑.</target>
        </trans-unit>
        <trans-unit id="8dee4e81117d0288fc40b8cb09d886277f261bfe" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;INT2PTR&lt;/code&gt; macro (defined in perl.h) casts an integer to a pointer of a given type, taking care of the possible different size of integers and pointers. There are also &lt;code&gt;PTR2IV&lt;/code&gt;, &lt;code&gt;PTR2UV&lt;/code&gt;, &lt;code&gt;PTR2NV&lt;/code&gt; macros, to map the other way, which may be useful in OUTPUT sections.</source>
          <target state="translated">&lt;code&gt;INT2PTR&lt;/code&gt; 의 (perl.h에 정의) 매크로는 정수와 포인터의 가능한 다른 크기의주의하면서 주어진 타입의 포인터에 정수를 캐스팅합니다. 도 있습니다 &lt;code&gt;PTR2IV&lt;/code&gt; , &lt;code&gt;PTR2UV&lt;/code&gt; , &lt;code&gt;PTR2NV&lt;/code&gt; 의 매크로는 OUTPUT 섹션에 유용 할 수있는 다른 방법을 매핑.</target>
        </trans-unit>
        <trans-unit id="7466a438605e61935ae6328f4fe2d9214ef781c1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;IN_OUT&lt;/code&gt; parameters are identical with parameters introduced with &lt;a href=&quot;#The-%26-Unary-Operator&quot;&gt;&quot;The &amp;amp; Unary Operator&quot;&lt;/a&gt; and put into the &lt;code&gt;OUTPUT:&lt;/code&gt; section (see &lt;a href=&quot;#The-OUTPUT%3A-Keyword&quot;&gt;&quot;The OUTPUT: Keyword&quot;&lt;/a&gt;). The &lt;code&gt;IN_OUTLIST&lt;/code&gt; parameters are very similar, the only difference being that the value C function writes through the pointer would not modify the Perl parameter, but is put in the output list.</source>
          <target state="translated">&lt;code&gt;IN_OUT&lt;/code&gt; 의 매개 변수에 도입 된 매개 변수와 동일 &lt;a href=&quot;#The-%26-Unary-Operator&quot;&gt;는 &quot;&amp;amp; 단항 연산자&quot;&lt;/a&gt; 와에 넣어 &lt;code&gt;OUTPUT:&lt;/code&gt; (섹션 &lt;a href=&quot;#The-OUTPUT%3A-Keyword&quot;&gt;&quot;출력 : 키워드&quot;&lt;/a&gt; ). &lt;code&gt;IN_OUTLIST&lt;/code&gt; 의 파라미터와 매우 유사하며, 유일한 차이점은 값 C 함수 펄 파라미터를 수정할 것이다 포인터를 통해 기록하지만, 출력리스트에 배치되는 것을.</target>
        </trans-unit>
        <trans-unit id="61f85903ef5f9040c0ff99931c044e8d15426a65" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;IN_OUT&lt;/code&gt; parameters are identical with parameters introduced with &lt;a href=&quot;#The-%26-Unary-Operator&quot;&gt;The &amp;amp; Unary Operator&lt;/a&gt; and put into the &lt;code&gt;OUTPUT:&lt;/code&gt; section (see &lt;a href=&quot;#The-OUTPUT%3a-Keyword&quot;&gt;The OUTPUT: Keyword&lt;/a&gt;). The &lt;code&gt;IN_OUTLIST&lt;/code&gt; parameters are very similar, the only difference being that the value C function writes through the pointer would not modify the Perl parameter, but is put in the output list.</source>
          <target state="translated">&lt;code&gt;IN_OUT&lt;/code&gt; 의 파라미터는 파라미터 도입과 동일 &lt;a href=&quot;#The-%26-Unary-Operator&quot;&gt;및 단항 연산자&lt;/a&gt; 및 투입 &lt;code&gt;OUTPUT:&lt;/code&gt; 부 (참조 &lt;a href=&quot;#The-OUTPUT%3a-Keyword&quot;&gt;출력 : 키워드&lt;/a&gt; ). &lt;code&gt;IN_OUTLIST&lt;/code&gt; 의 파라미터와 매우 유사하며, 유일한 차이점은 값 C 함수 펄 파라미터를 수정할 것이다 포인터를 통해 기록하지만, 출력리스트에 배치되는 것을.</target>
        </trans-unit>
        <trans-unit id="e01d4a34408ea1bec61899bb0715159c8fcfc543" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;IO::Dir&lt;/code&gt; package provides two interfaces to perl's directory reading routines.</source>
          <target state="translated">&lt;code&gt;IO::Dir&lt;/code&gt; 패키지는 펄의 디렉토리 읽기 루틴에 두 개의 인터페이스를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="2e8c3db24464dee992cbd4fb5389ee4e7af6c03b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;IO::Select&lt;/code&gt; package implements an object approach to the system &lt;code&gt;&lt;a href=&quot;../functions/select&quot;&gt;select&lt;/a&gt;&lt;/code&gt; function call. It allows the user to see what IO handles, see &lt;a href=&quot;handle&quot;&gt;IO::Handle&lt;/a&gt;, are ready for reading, writing or have an exception pending.</source>
          <target state="translated">&lt;code&gt;IO::Select&lt;/code&gt; 패키지 구현 시스템에 대한 객체 접근 방식 &lt;code&gt;&lt;a href=&quot;../functions/select&quot;&gt;select&lt;/a&gt;&lt;/code&gt; 함수 호출. 사용자가 IO 핸들을보고 &lt;a href=&quot;handle&quot;&gt;IO :: Handle&lt;/a&gt; 참조 , 읽기, 쓰기 준비 또는 예외 보류 중을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d4a23c694ba8531eb134632f2092cafc7861a78d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;IO::Select&lt;/code&gt; package implements an object approach to the system &lt;code&gt;select&lt;/code&gt; function call. It allows the user to see what IO handles, see &lt;a href=&quot;IO::Handle&quot;&gt;IO::Handle&lt;/a&gt;, are ready for reading, writing or have an exception pending.</source>
          <target state="translated">&lt;code&gt;IO::Select&lt;/code&gt; 패키지 구현 시스템에 대한 객체 접근 방식 &lt;code&gt;select&lt;/code&gt; 함수 호출. 이를 통해 사용자는 IO가 처리하는 것을 볼 수 있습니다 ( &lt;a href=&quot;IO::Handle&quot;&gt;IO :: Handle&lt;/a&gt; 참조). 읽기, 쓰기 준비가되었거나 예외가 보류 중입니다.</target>
        </trans-unit>
        <trans-unit id="b5b99267c0bd0ea1d7a95c4de6c3170224a12616" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;IVdf&lt;/code&gt; will expand to whatever is the correct format for the IVs. Note that the spaces are required around the format in case the code is compiled with C++, to maintain compliance with its standard.</source>
          <target state="translated">&lt;code&gt;IVdf&lt;/code&gt; 는 IV를위한 올바른 형식이 무엇이든되는 확장됩니다. 코드가 C ++로 컴파일 된 경우 표준 준수를 유지하기 위해 형식 주위에 공백이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="93e9868cf44653a0a473010fe2cd91001e0a676d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Interpolation&lt;/code&gt; module can also do a lot of magic for you. You can specify a variable name, in this case &lt;code&gt;E&lt;/code&gt; , to set up a tied hash that does the interpolation for you. It has several other methods to do this as well.</source>
          <target state="translated">&lt;code&gt;Interpolation&lt;/code&gt; 모듈은 당신을 위해 마술을 많이 할 수 있습니다. 보간을 수행하는 연결 해시를 설정하기 위해 변수 이름 (이 경우 &lt;code&gt;E&lt;/code&gt; )을 지정할 수 있습니다 . 이 작업을 수행하는 다른 방법도 있습니다.</target>
        </trans-unit>
        <trans-unit id="329ab637f04429657f9fe6aaf5dca20594f33c89" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Interpolation&lt;/code&gt; module can also do a lot of magic for you. You can specify a variable name, in this case &lt;code&gt;E&lt;/code&gt;, to set up a tied hash that does the interpolation for you. It has several other methods to do this as well.</source>
          <target state="translated">&lt;code&gt;Interpolation&lt;/code&gt; 모듈은 당신을 위해 마술을 많이 할 수 있습니다. 변수 이름 (이 경우 &lt;code&gt;E&lt;/code&gt; )을 지정하여 보간을 수행하는 연결 해시를 설정할 수 있습니다. 이 작업을 수행하는 몇 가지 다른 방법도 있습니다.</target>
        </trans-unit>
        <trans-unit id="d3bc590cafc9b13c0e888463643b3750cf44fd73" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;LC_CTYPE&lt;/code&gt; locale also provides the map used in transliterating characters between lower and uppercase. This affects the case-mapping functions--&lt;code&gt;&lt;a href=&quot;functions/fc&quot;&gt;fc()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/lc&quot;&gt;lc()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/lcfirst&quot;&gt;lcfirst()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/uc&quot;&gt;uc()&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;functions/ucfirst&quot;&gt;ucfirst()&lt;/a&gt;&lt;/code&gt;; case-mapping interpolation with &lt;code&gt;\F&lt;/code&gt; , &lt;code&gt;\l&lt;/code&gt; , &lt;code&gt;\L&lt;/code&gt; , &lt;code&gt;\u&lt;/code&gt; , or &lt;code&gt;\U&lt;/code&gt; in double-quoted strings and &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt; substitutions; and case-independent regular expression pattern matching using the &lt;code&gt;i&lt;/code&gt; modifier.</source>
          <target state="translated">&lt;code&gt;LC_CTYPE&lt;/code&gt; 의 로케일은 낮은 대문자 사이에 문자를 음역에 사용 된 맵을 제공합니다. 이는 &lt;code&gt;&lt;a href=&quot;functions/fc&quot;&gt;fc()&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/lc&quot;&gt;lc()&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/lcfirst&quot;&gt;lcfirst()&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/uc&quot;&gt;uc()&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;functions/ucfirst&quot;&gt;ucfirst()&lt;/a&gt;&lt;/code&gt; 와 같이 대소 문자를 구분하는 함수에 영향을줍니다 . 큰 따옴표로 묶인 문자열과 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt; 치환 에서 &lt;code&gt;\F&lt;/code&gt; , &lt;code&gt;\l&lt;/code&gt; , &lt;code&gt;\L&lt;/code&gt; , &lt;code&gt;\u&lt;/code&gt; 또는 &lt;code&gt;\U&lt;/code&gt; 를 사용한 대소 문자 매핑 보간법 ; 및 &lt;code&gt;i&lt;/code&gt; 수정자를 사용하여 대소 문자를 구분하지 않는 정규식 패턴 매칭 .</target>
        </trans-unit>
        <trans-unit id="bc3c541f503e52e8ac4f6d3ffd90d52fc4128eb9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;LC_CTYPE&lt;/code&gt; locale also provides the map used in transliterating characters between lower and uppercase. This affects the case-mapping functions--&lt;code&gt;fc()&lt;/code&gt;, &lt;code&gt;lc()&lt;/code&gt;, &lt;code&gt;lcfirst()&lt;/code&gt;, &lt;code&gt;uc()&lt;/code&gt;, and &lt;code&gt;ucfirst()&lt;/code&gt;; case-mapping interpolation with &lt;code&gt;\F&lt;/code&gt;, &lt;code&gt;\l&lt;/code&gt;, &lt;code&gt;\L&lt;/code&gt;, &lt;code&gt;\u&lt;/code&gt;, or &lt;code&gt;\U&lt;/code&gt; in double-quoted strings and &lt;code&gt;s///&lt;/code&gt; substitutions; and case-insensitive regular expression pattern matching using the &lt;code&gt;i&lt;/code&gt; modifier.</source>
          <target state="translated">&lt;code&gt;LC_CTYPE&lt;/code&gt; 의 로케일은 낮은 대문자 사이에 문자를 음역에 사용 된 맵을 제공합니다. 이것은 대소 문자 매핑 함수에 영향을 미칩니다. &lt;code&gt;fc()&lt;/code&gt; , &lt;code&gt;lc()&lt;/code&gt; , &lt;code&gt;lcfirst()&lt;/code&gt; , &lt;code&gt;uc()&lt;/code&gt; , &lt;code&gt;ucfirst()&lt;/code&gt; ; 큰 따옴표로 묶인 문자열 및 &lt;code&gt;s///&lt;/code&gt; 대체 에서 &lt;code&gt;\F&lt;/code&gt; , &lt;code&gt;\l&lt;/code&gt; , &lt;code&gt;\L&lt;/code&gt; , &lt;code&gt;\u&lt;/code&gt; 또는 &lt;code&gt;\U&lt;/code&gt; 를 사용한 대소 문자 매핑 보간 ; &lt;code&gt;i&lt;/code&gt; 수정자를 사용하여 대소 문자를 구분하지 않는 정규식 패턴 일치 .</target>
        </trans-unit>
        <trans-unit id="941219cd505be61ac26ba8728d69370c60e37046" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;LC_NUMERIC&lt;/code&gt; controls the numeric output:</source>
          <target state="translated">&lt;code&gt;LC_NUMERIC&lt;/code&gt; 은 숫자 출력을 제어합니다 :</target>
        </trans-unit>
        <trans-unit id="412121500ef04a2233556ed3ed8bb5c784494003" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;LimitOutput&lt;/code&gt; option changes the behavior of the &lt;code&gt;$i-&amp;gt;bzinflate&lt;/code&gt; method so that the amount of memory used by the output buffer can be limited.</source>
          <target state="translated">&lt;code&gt;LimitOutput&lt;/code&gt; 의 옵션은 동작 변경 &lt;code&gt;$i-&amp;gt;bzinflate&lt;/code&gt; 출력 버퍼를 사용하는 메모리 양이 제한 될 수 있도록 방법.</target>
        </trans-unit>
        <trans-unit id="1b18a1d213993f63112fefb5d5804b6552cbf33b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;LimitOutput&lt;/code&gt; option changes the behavior of the &lt;code&gt;$i-&amp;gt;inflate&lt;/code&gt; method so that the amount of memory used by the output buffer can be limited.</source>
          <target state="translated">&lt;code&gt;LimitOutput&lt;/code&gt; 의 옵션은 동작 변경 &lt;code&gt;$i-&amp;gt;inflate&lt;/code&gt; 출력 버퍼를 사용하는 메모리 양이 제한 될 수 있도록 방법.</target>
        </trans-unit>
        <trans-unit id="3600b0d3775b442853dade84e908851ee6d60512" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;LimitOutput&lt;/code&gt; option is designed to help with this use-case.</source>
          <target state="translated">&lt;code&gt;LimitOutput&lt;/code&gt; 의 옵션이 사용 사례와 수 있도록 설계되었습니다.</target>
        </trans-unit>
        <trans-unit id="4e39cafde8d7c8f339d79044ffb14c41f2b59abf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Listen&lt;/code&gt; parameter is set to the maximum number of pending connections we can accept until we turn away incoming clients. Think of it as a call-waiting queue for your telephone. The low-level Socket module has a special symbol for the system maximum, which is SOMAXCONN.</source>
          <target state="translated">&lt;code&gt;Listen&lt;/code&gt; 매개 변수는 우리가 멀리 들어오는 클라이언트를 설정할 때까지 우리가 받아 들일 수 계류중인 연결의 최대 수로 설정됩니다. 전화기의 통화 대기 대기열로 생각하십시오. 저수준 소켓 모듈에는 시스템 최대 값에 대한 특수 기호 인 SOMAXCONN이 있습니다.</target>
        </trans-unit>
        <trans-unit id="39d8f8a92949aebb617dd074e69f347a559dd1fc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Locale::Country&lt;/code&gt; module provides access to several code sets that can be used for identifying countries, such as those defined in ISO 3166-1.</source>
          <target state="translated">&lt;code&gt;Locale::Country&lt;/code&gt; 모듈은 ISO 3166-1에 정의 된 것과 같은 식별 국가에서 사용할 수있는 몇 가지 코드 세트에 대한 액세스를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="7ce570b70dc3b1217c7829eb357747faae317306" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Locale::Currency&lt;/code&gt; module provides access to standard codes used for identifying currencies and funds, such as those defined in ISO 4217.</source>
          <target state="translated">&lt;code&gt;Locale::Currency&lt;/code&gt; 모듈은 ISO 4217에 정의 된 것과 같은 통화 및 자금을 식별하기 위해 사용되는 표준 코드에 대한 액세스를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="e1ffcce2675347ee9e15ffb62b7a866fc9499f7b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Locale::Language&lt;/code&gt; module provides access to standard codes used for identifying languages, such as those as defined in ISO 639.</source>
          <target state="translated">&lt;code&gt;Locale::Language&lt;/code&gt; 모듈은 다음과 같은 ISO 639에 정의 된 것과 같은 언어를 식별하기 위해 사용되는 표준 코드에 대한 액세스를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="aa76c519ff8997e91915d966da6aed9450ba1a90" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Locale::Script&lt;/code&gt; module provides access to standards codes used for identifying scripts, such as those defined in ISO 15924.</source>
          <target state="translated">&lt;code&gt;Locale::Script&lt;/code&gt; 모듈은 ISO 15924에 정의 된 것과 같은 스크립트를 식별하기 위해 사용되는 표준 코드에 대한 액세스를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="e8120d017d19784f5ec18621659dfbf762367c0d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;MGVTBL&lt;/code&gt; has five (or sometimes eight) pointers to the following routine types:</source>
          <target state="translated">&lt;code&gt;MGVTBL&lt;/code&gt; 는 다음과 같은 루틴 유형 오 (또는 때때로 팔) 포인터가 있습니다 :</target>
        </trans-unit>
        <trans-unit id="cb0939f4e09d7100879a1f0cd7a45d518f685d85" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Math::Trig&lt;/code&gt; handles this by using the &lt;code&gt;Math::Complex&lt;/code&gt; package which knows how to handle complex numbers, please see &lt;a href=&quot;Math::Complex&quot;&gt;Math::Complex&lt;/a&gt; for more information. In practice you need not to worry about getting complex numbers as results because the &lt;code&gt;Math::Complex&lt;/code&gt; takes care of details like for example how to display complex numbers. For example:</source>
          <target state="translated">&lt;code&gt;Math::Trig&lt;/code&gt; 사용하여이 작업을 처리 &lt;code&gt;Math::Complex&lt;/code&gt; 복잡한 숫자를 처리하는 방법을 알고 패키지를 참조하십시오 &lt;a href=&quot;Math::Complex&quot;&gt;수학 :: 단지&lt;/a&gt; 더 많은 정보를 얻을 수 있습니다. 실제로 &lt;code&gt;Math::Complex&lt;/code&gt; 는 예를 들어 복소수를 표시하는 방법과 같은 세부 사항을 처리 하므로 결과로 복소수를 얻는 것에 대해 걱정할 필요가 없습니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="62960d717ea2191ee6cb352f5b362492a57f4b7e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Math::Trig&lt;/code&gt; handles this by using the &lt;code&gt;Math::Complex&lt;/code&gt; package which knows how to handle complex numbers, please see &lt;a href=&quot;complex&quot;&gt;Math::Complex&lt;/a&gt; for more information. In practice you need not to worry about getting complex numbers as results because the &lt;code&gt;Math::Complex&lt;/code&gt; takes care of details like for example how to display complex numbers. For example:</source>
          <target state="translated">&lt;code&gt;Math::Trig&lt;/code&gt; 사용하여이 작업을 처리 &lt;code&gt;Math::Complex&lt;/code&gt; 복잡한 숫자를 처리하는 방법을 알고 패키지를 참조하십시오 &lt;a href=&quot;complex&quot;&gt;수학 :: 단지&lt;/a&gt; 더 많은 정보를 얻을 수 있습니다. 실제로 &lt;code&gt;Math::Complex&lt;/code&gt; 는 복잡한 숫자를 표시하는 방법과 같은 세부 사항을 처리 하므로 복잡한 숫자를 결과로 얻는 것에 대해 걱정할 필요가 없습니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="59d3e5116a50776a62b5e7307aca3591f0689480" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Moose&lt;/code&gt; authors hope that one day &lt;code&gt;Moo&lt;/code&gt; can be made obsolete by improving &lt;code&gt;Moose&lt;/code&gt; enough, but for now it provides a worthwhile alternative to &lt;code&gt;Moose&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;Moose&lt;/code&gt; 저자는 일일 희망 &lt;code&gt;Moo&lt;/code&gt; 개선되지 않는 만들 수 있습니다 &lt;code&gt;Moose&lt;/code&gt; 충분히,하지만 지금은에 가치있는 대안 제공 &lt;code&gt;Moose&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cd61d23b6e3309b14f23bde3328a9b1cfdb75d47" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Moose&lt;/code&gt; authors hope that one day &lt;code&gt;Moo&lt;/code&gt; can be made obsolete by improving &lt;code&gt;Moose&lt;/code&gt; enough, but for now it provides a worthwhile alternative to &lt;code&gt;Moose&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Moose&lt;/code&gt; 저자는 일일 희망 &lt;code&gt;Moo&lt;/code&gt; 개선되지 않는 만들 수 있습니다 &lt;code&gt;Moose&lt;/code&gt; 충분히,하지만 지금은에 가치있는 대안 제공 &lt;code&gt;Moose&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bc9a3a0a2d0497d18f72b7ad30f16ed602816e32" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;NEXT&lt;/code&gt; module adds a pseudoclass named &lt;code&gt;NEXT&lt;/code&gt; to any program that uses it. If a method &lt;code&gt;m&lt;/code&gt; calls &lt;code&gt;$self-&amp;gt;NEXT::m()&lt;/code&gt;, the call to &lt;code&gt;m&lt;/code&gt; is redispatched as if the calling method had not originally been found.</source>
          <target state="translated">&lt;code&gt;NEXT&lt;/code&gt; 모듈라는 pseudoclass 추가 &lt;code&gt;NEXT&lt;/code&gt; 을 사용하는 모든 프로그램을. &lt;code&gt;m&lt;/code&gt; 메서드 가 &lt;code&gt;$self-&amp;gt;NEXT::m()&lt;/code&gt; 호출하면 &lt;code&gt;m&lt;/code&gt; 에 대한 호출은 호출하는 메서드가 원래 발견되지 않은 것처럼 다시 배포됩니다.</target>
        </trans-unit>
        <trans-unit id="5cda22c66d7ae69cf0c1a687755ef0ea97e644b2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;NNTP&lt;/code&gt; protocol uses the &lt;code&gt;WILDMAT&lt;/code&gt; format for patterns. The WILDMAT format was first developed by Rich Salz based on the format used in the UNIX &quot;find&quot; command to articulate file names. It was developed to provide a uniform mechanism for matching patterns in the same manner that the UNIX shell matches filenames.</source>
          <target state="translated">&lt;code&gt;NNTP&lt;/code&gt; 의 프로토콜은 사용 &lt;code&gt;WILDMAT&lt;/code&gt; 의 패턴 형식을. WILDMAT 형식은 파일 이름을 명확하게하기 위해 UNIX &quot;find&quot;명령에 사용 된 형식을 기반으로 Rich Salz에 의해 처음 개발되었습니다. UNIX 쉘이 파일 이름과 일치하는 것과 동일한 방식으로 패턴 일치를위한 균일 한 메커니즘을 제공하기 위해 개발되었습니다.</target>
        </trans-unit>
        <trans-unit id="8856a9c3b92894fbca75a7c6a84e03f49c7d82b9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Net::FTP&lt;/code&gt; module provides two low-level methods called &lt;code&gt;stor&lt;/code&gt; and &lt;code&gt;retr&lt;/code&gt; that both return filehandles. These filehandles can used with the &lt;code&gt;IO::Compress/Uncompress&lt;/code&gt; modules to compress or uncompress files read from or written to an FTP Server on the fly, without having to create a temporary file.</source>
          <target state="translated">&lt;code&gt;Net::FTP&lt;/code&gt; 모듈라는 두 개의 낮은 수준의 방법을 제공 &lt;code&gt;stor&lt;/code&gt; 및 &lt;code&gt;retr&lt;/code&gt; 모두 반환 파일 핸들이 있습니다. 이러한 파일 핸들은 &lt;code&gt;IO::Compress/Uncompress&lt;/code&gt; 모듈 과 함께 사용하여 임시 파일을 만들지 않고도 즉시 FTP 서버에서 읽거나 FTP 서버에 쓴 파일을 압축하거나 압축 해제 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="812543816e7e36906e0a41744e1b881bd6061a33" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;O::import&lt;/code&gt; function loads the appropriate &lt;code&gt;B::Backend&lt;/code&gt; module and calls its &lt;code&gt;compile&lt;/code&gt; function, passing it OPTIONS. That function is expected to return a sub reference which we'll call CALLBACK. Next, the &quot;compile-only&quot; flag is switched on (equivalent to the command-line option &lt;code&gt;-c&lt;/code&gt; ) and a CHECK block is registered which calls CALLBACK. Thus the main Perl program mentioned on the command-line is read in, parsed and compiled into internal syntax tree form. Since the &lt;code&gt;-c&lt;/code&gt; flag is set, the program does not start running (excepting BEGIN blocks of course) but the CALLBACK function registered by the compiler backend is called.</source>
          <target state="translated">&lt;code&gt;O::import&lt;/code&gt; 기능로드 적절한 &lt;code&gt;B::Backend&lt;/code&gt; 모듈은 호출 &lt;code&gt;compile&lt;/code&gt; 그것을 옵션을 전달하는 기능. 이 함수는 CALLBACK이라고하는 하위 참조를 반환 할 것으로 예상됩니다. 다음으로, &quot;컴파일 전용&quot;플래그가 켜지고 (명령 행 옵션 &lt;code&gt;-c&lt;/code&gt; 와 동일 ) CALLBACK을 호출하는 CHECK 블록이 등록됩니다. 따라서 명령 행에 언급 된 주요 Perl 프로그램은 내부 구문 트리 형식으로 읽고 구문 분석되고 컴파일됩니다. 이후 &lt;code&gt;-c&lt;/code&gt; 플래그가 설정되어, 프로그램은 (물론 블록 BEGIN 제외) 실행을 시작하지 않고 컴파일러 백엔드에 의해 등록 된 콜백 함수가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="d7e78f61b2ef3885efb7f8bb2d5b2723a7d2f5bc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;O::import&lt;/code&gt; function loads the appropriate &lt;code&gt;B::Backend&lt;/code&gt; module and calls its &lt;code&gt;compile&lt;/code&gt; function, passing it OPTIONS. That function is expected to return a sub reference which we'll call CALLBACK. Next, the &quot;compile-only&quot; flag is switched on (equivalent to the command-line option &lt;code&gt;-c&lt;/code&gt;) and a CHECK block is registered which calls CALLBACK. Thus the main Perl program mentioned on the command-line is read in, parsed and compiled into internal syntax tree form. Since the &lt;code&gt;-c&lt;/code&gt; flag is set, the program does not start running (excepting BEGIN blocks of course) but the CALLBACK function registered by the compiler backend is called.</source>
          <target state="translated">&lt;code&gt;O::import&lt;/code&gt; 기능로드 적절한 &lt;code&gt;B::Backend&lt;/code&gt; 모듈은 호출 &lt;code&gt;compile&lt;/code&gt; 그것을 옵션을 전달하는 기능. 이 함수는 우리가 CALLBACK이라고 부르는 하위 ​​참조를 반환 할 것으로 예상됩니다. 다음으로 &quot;컴파일 전용&quot;플래그가 켜지고 (명령 줄 옵션 &lt;code&gt;-c&lt;/code&gt; 와 동일 ) CALLBACK을 호출하는 CHECK 블록이 등록됩니다. 따라서 명령 줄에 언급 된 주요 Perl 프로그램은 내부 구문 트리 형식으로 읽어 들여 파싱되고 컴파일됩니다. 이후 &lt;code&gt;-c&lt;/code&gt; 플래그가 설정되어, 프로그램은 (물론 블록 BEGIN 제외) 실행을 시작하지 않고 컴파일러 백엔드에 의해 등록 된 콜백 함수가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="3d373b71890ff94863d227c7cfce5d1d697b7746" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;OP *&lt;/code&gt; is op_free()ed at the end of</source>
          <target state="translated">&lt;code&gt;OP *&lt;/code&gt; 를 끝에 op_free () 에드</target>
        </trans-unit>
        <trans-unit id="998cf5d3020bb78a9ba1d3cad328d90e354a7767" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;OUTLIST&lt;/code&gt; /&lt;code&gt;OUT&lt;/code&gt; parameter differ from &lt;code&gt;IN_OUTLIST&lt;/code&gt; /&lt;code&gt;IN_OUT&lt;/code&gt; parameters only by the initial value of the Perl parameter not being read (and not being given to the C function - which gets some garbage instead). For example, the same C function as above can be interfaced with as</source>
          <target state="translated">&lt;code&gt;OUTLIST&lt;/code&gt; / &lt;code&gt;OUT&lt;/code&gt; 다를 매개 &lt;code&gt;IN_OUTLIST&lt;/code&gt; / &lt;code&gt;IN_OUT&lt;/code&gt; 의 전용 판독되는 펄 파라미터의 초기 값에 의해 파라미터 (- 일부 대신 쓰레기를 가져와 C 함수에 제공되지 않는). 예를 들어, 위와 동일한 C 함수는</target>
        </trans-unit>
        <trans-unit id="77d530437d7fdd465ebf5f4d28d1ba3ab2ce9989" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;OUTLIST&lt;/code&gt;/&lt;code&gt;OUT&lt;/code&gt; parameter differ from &lt;code&gt;IN_OUTLIST&lt;/code&gt;/&lt;code&gt;IN_OUT&lt;/code&gt; parameters only by the initial value of the Perl parameter not being read (and not being given to the C function - which gets some garbage instead). For example, the same C function as above can be interfaced with as</source>
          <target state="translated">&lt;code&gt;OUTLIST&lt;/code&gt; / &lt;code&gt;OUT&lt;/code&gt; 다를 매개 &lt;code&gt;IN_OUTLIST&lt;/code&gt; / &lt;code&gt;IN_OUT&lt;/code&gt; 의 전용 판독되는 펄 파라미터의 초기 값에 의해 파라미터 (- 일부 대신 쓰레기를 가져와 C 함수에 제공되지 않는). 예를 들어, 위와 동일한 C 함수를 다음과 같이 인터페이스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0628c399d26c3378a27108a14e1ac2344b8aefb0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Open()&lt;/code&gt; method has lots of arguments because it combines the functions of perl's &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;PerlIO_open&lt;/code&gt; , perl's &lt;code&gt;&lt;a href=&quot;functions/sysopen&quot;&gt;sysopen&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;PerlIO_fdopen&lt;/code&gt; and &lt;code&gt;PerlIO_reopen&lt;/code&gt; . The full prototype is as follows:</source>
          <target state="translated">&lt;code&gt;Open()&lt;/code&gt; 는 펄의의 기능을 결합하기 때문에 방법은 인자를 많이 가지고 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;PerlIO_open&lt;/code&gt; , 펄의 &lt;code&gt;&lt;a href=&quot;functions/sysopen&quot;&gt;sysopen&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;PerlIO_fdopen&lt;/code&gt; 및 &lt;code&gt;PerlIO_reopen&lt;/code&gt; 을 . 전체 프로토 타입은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a364ca34d8039b509a216c6b70daa6a333bd164c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Open()&lt;/code&gt; method has lots of arguments because it combines the functions of perl's &lt;code&gt;open&lt;/code&gt;, &lt;code&gt;PerlIO_open&lt;/code&gt;, perl's &lt;code&gt;sysopen&lt;/code&gt;, &lt;code&gt;PerlIO_fdopen&lt;/code&gt; and &lt;code&gt;PerlIO_reopen&lt;/code&gt;. The full prototype is as follows:</source>
          <target state="translated">&lt;code&gt;Open()&lt;/code&gt; 는 펄의의 기능을 결합하기 때문에 방법은 인자를 많이 가지고 &lt;code&gt;open&lt;/code&gt; , &lt;code&gt;PerlIO_open&lt;/code&gt; , 펄의 &lt;code&gt;sysopen&lt;/code&gt; , &lt;code&gt;PerlIO_fdopen&lt;/code&gt; 및 &lt;code&gt;PerlIO_reopen&lt;/code&gt; 을 . 전체 프로토 타입은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9b50db457121e66e0a351ce78b3a957dc8ab0fb3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;PERL5DB&lt;/code&gt; environment variable can be used to define a debugger. For example, the minimal &quot;working&quot; debugger (it actually doesn't do anything) consists of one line:</source>
          <target state="translated">&lt;code&gt;PERL5DB&lt;/code&gt; 의 환경 변수 디버거를 정의하기 위해 사용될 수있다. 예를 들어, 최소한의 &quot;작동하는&quot;디버거 (실제로는 아무것도하지 않음)는 한 줄로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="d2bc99a442d5c0b29501891792cdc1fff80da05a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;PERL_MAGIC_ext&lt;/code&gt; and &lt;code&gt;PERL_MAGIC_uvar&lt;/code&gt; magic types are defined specifically for use by extensions and will not be used by perl itself. Extensions can use &lt;code&gt;PERL_MAGIC_ext&lt;/code&gt; magic to 'attach' private information to variables (typically objects). This is especially useful because there is no way for normal perl code to corrupt this private information (unlike using extra elements of a hash object).</source>
          <target state="translated">&lt;code&gt;PERL_MAGIC_ext&lt;/code&gt; 및 &lt;code&gt;PERL_MAGIC_uvar&lt;/code&gt; 마법 유형은 확장에 의해 사용을 위해 특별히 정의와 펄 자체에 의해 사용되지 않습니다. 확장은 &lt;code&gt;PERL_MAGIC_ext&lt;/code&gt; 매직을 사용 하여 개인 정보를 변수 (일반적으로 객체)에 '첨부' 할 수 있습니다 . 이는 해시 객체의 추가 요소를 사용하는 것과 달리 일반적인 펄 코드가이 개인 정보를 손상시킬 수있는 방법이 없기 때문에 특히 유용합니다.</target>
        </trans-unit>
        <trans-unit id="8a6e94721b04748465ec2688a94fd6f249730156" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;PERL_MAGIC_uvar&lt;/code&gt; interface for hashes</source>
          <target state="translated">&lt;code&gt;PERL_MAGIC_uvar&lt;/code&gt; 의 해시에 대한 인터페이스</target>
        </trans-unit>
        <trans-unit id="bda510e29f461a0c3d4c9c5037a48e14d8e62436" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;PERL_SCAN_DISALLOW_PREFIX&lt;/code&gt; flag is always treated as being set for this function.</source>
          <target state="translated">&lt;code&gt;PERL_SCAN_DISALLOW_PREFIX&lt;/code&gt; 의 플래그는 항상이 기능에 대해 설정된 것으로 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="ebc956792cc9e74cf6710a9899c98dc65f9e9723" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;POPi&lt;/code&gt; macro is used here to pop the return value from the stack. In this case we wanted an integer, so &lt;code&gt;POPi&lt;/code&gt; was used.</source>
          <target state="translated">&lt;code&gt;POPi&lt;/code&gt; 매크로는 스택에서 반환 값을 팝업 여기에 사용됩니다. 이 경우 정수를 원했기 때문에 &lt;code&gt;POPi&lt;/code&gt; 가 사용되었습니다.</target>
        </trans-unit>
        <trans-unit id="441004a0b6f6f50d94cdd26e8efdb4418e11d7d7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;POSIX::getattr&lt;/code&gt; function can do this more portably on systems purporting POSIX compliance. See also the &lt;code&gt;Term::ReadKey&lt;/code&gt; module from your nearest &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fwww.cpan.org&quot;&gt;CPAN&lt;/a&gt; site.</source>
          <target state="translated">&lt;code&gt;POSIX::getattr&lt;/code&gt; 기능은 POSIX 준수를 사칭 시스템에 대한 자세한 이식이 작업을 수행 할 수 있습니다. 가까운 &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fwww.cpan.org&quot;&gt;CPAN&lt;/a&gt; 사이트 의 &lt;code&gt;Term::ReadKey&lt;/code&gt; 모듈 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="30a4c7c0312ad4ebafbfc4ecde82010a30e5b1d4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;POSIX::localeconv()&lt;/code&gt; function allows you to get particulars of the locale-dependent numeric formatting information specified by the current underlying &lt;code&gt;LC_NUMERIC&lt;/code&gt; and &lt;code&gt;LC_MONETARY&lt;/code&gt; locales (regardless of whether called from within the scope of &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; or not). (If you just want the name of the current locale for a particular category, use &lt;code&gt;POSIX::setlocale()&lt;/code&gt; with a single parameter--see &lt;a href=&quot;#The-setlocale-function&quot;&gt;The setlocale function&lt;/a&gt;.)</source>
          <target state="translated">&lt;code&gt;POSIX::localeconv()&lt;/code&gt; 함수는 현재 기본으로 지정된 로케일에 의존하는 숫자 서식 정보의 내역 얻을 수 &lt;code&gt;LC_NUMERIC&lt;/code&gt; 및 &lt;code&gt;LC_MONETARY&lt;/code&gt; (관계의 범위 내에서 호출 여부에 로케일을 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; 여부). (특정 범주에 대한 현재 로케일의 이름 만 원하면 &lt;code&gt;POSIX::setlocale()&lt;/code&gt; 을 단일 매개 변수와 함께 사용 하십시오 &lt;a href=&quot;#The-setlocale-function&quot;&gt;. setlocale 함수를&lt;/a&gt; 참조하십시오 .)</target>
        </trans-unit>
        <trans-unit id="2b43e9db384d2d0a57a2a9c77f122fdc5d00196d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;POSIX::localeconv()&lt;/code&gt; function allows you to get particulars of the locale-dependent numeric formatting information specified by the current underlying &lt;code&gt;LC_NUMERIC&lt;/code&gt; and &lt;code&gt;LC_MONETARY&lt;/code&gt; locales (regardless of whether called from within the scope of &lt;code&gt;use locale&lt;/code&gt; or not). (If you just want the name of the current locale for a particular category, use &lt;code&gt;POSIX::setlocale()&lt;/code&gt; with a single parameter--see &lt;a href=&quot;#The-setlocale-function&quot;&gt;&quot;The setlocale function&quot;&lt;/a&gt;.)</source>
          <target state="translated">&lt;code&gt;POSIX::localeconv()&lt;/code&gt; 함수는 현재 기본으로 지정된 로케일에 의존하는 숫자 서식 정보의 내역 얻을 수 &lt;code&gt;LC_NUMERIC&lt;/code&gt; 및 &lt;code&gt;LC_MONETARY&lt;/code&gt; (관계의 범위 내에서 호출 여부에 로케일을 &lt;code&gt;use locale&lt;/code&gt; 여부). (특정 범주에 대한 현재 로케일의 이름 만 원하면 단일 매개 변수와 함께 &lt;code&gt;POSIX::setlocale()&lt;/code&gt; 사용하십시오. &lt;a href=&quot;#The-setlocale-function&quot;&gt;&quot;setlocale 함수&quot;를&lt;/a&gt; 참조하십시오 .)</target>
        </trans-unit>
        <trans-unit id="1f685f77eea7b515d4045c7a67182dbbc7755a25" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;PUSHMARK&lt;/code&gt; macro tells Perl to make a mental note of the current stack pointer. Even if you aren't passing any parameters (like the example shown in the section</source>
          <target state="translated">&lt;code&gt;PUSHMARK&lt;/code&gt; 매크로는 현재 스택 포인터의 정신 메모를 만들기 위해 펄을 알려줍니다. 매개 변수를 전달하지 않더라도 (섹션에 표시된 예와 같이)</target>
        </trans-unit>
        <trans-unit id="163850ef5b169ef12088a9930a0f3972d7c61a0f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;PUSHMARK&lt;/code&gt; macro tells Perl to make a mental note of the current stack pointer. Even if you aren't passing any parameters (like the example shown in the section &lt;a href=&quot;#No-Parameters%2C-Nothing-Returned&quot;&gt;&quot;No Parameters, Nothing Returned&quot;&lt;/a&gt;) you must still call the &lt;code&gt;PUSHMARK&lt;/code&gt; macro before you can call any of the</source>
          <target state="translated">&lt;code&gt;PUSHMARK&lt;/code&gt; 매크로는 현재 스택 포인터의 정신 메모를 만들기 위해 펄을 알려줍니다. 매개 변수를 전달하지 않더라도 ( &lt;a href=&quot;#No-Parameters%2C-Nothing-Returned&quot;&gt;&quot;No Parameters, Nothing Returned&quot;&lt;/a&gt; 섹션에 표시된 예와 같이 ) &lt;code&gt;PUSHMARK&lt;/code&gt; 매크로를 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="07465ad7c738ebeee81550400552ecd67a850bce" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;PUTBACK&lt;/code&gt; macro sets the global copy of the stack pointer to be the same as our local copy. If we didn't do this,</source>
          <target state="translated">&lt;code&gt;PUTBACK&lt;/code&gt; 스택 포인터의 매크로 세트 글로벌 사본은 우리의 로컬 복사본과 동일합니다. 우리가 이것을하지 않으면</target>
        </trans-unit>
        <trans-unit id="8baae86fdb4cb4e701226e31c2071774be7ff5cf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;PeerAddr&lt;/code&gt; can be a hostname or the IP-address on the &quot;xx.xx.xx.xx&quot; form. The &lt;code&gt;PeerPort&lt;/code&gt; can be a number or a symbolic service name. The service name might be followed by a number in parenthesis which is used if the service is not known by the system. The &lt;code&gt;PeerPort&lt;/code&gt; specification can also be embedded in the &lt;code&gt;PeerAddr&lt;/code&gt; by preceding it with a &quot;:&quot;.</source>
          <target state="translated">&lt;code&gt;PeerAddr&lt;/code&gt; 은 은 &quot;xx.xx.xx.xx '폼의 호스트 이름이나 IP 주소를 할 수 있습니다. &lt;code&gt;PeerPort&lt;/code&gt; 는 숫자 나 기호 서비스 이름이 될 수 있습니다. 서비스 이름 뒤에는 괄호 안의 숫자가 올 수 있으며 시스템에서 서비스를 알 수없는 경우 사용됩니다. &lt;code&gt;PeerPort&lt;/code&gt; 의 사양도에 포함 할 수 &lt;code&gt;PeerAddr&lt;/code&gt; &quot;의&quot;로 이전하여.</target>
        </trans-unit>
        <trans-unit id="354584d7434f3b3042f7e803f86eee0735ecb30f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;PerlInterpreter*&lt;/code&gt; is being constructed via &lt;code&gt;perl_construct&lt;/code&gt; . This value is mostly there for completeness and for use via the underlying C variable &lt;code&gt;PL_phase&lt;/code&gt; . It's not really possible for Perl code to be executed unless construction of the interpreter is finished.</source>
          <target state="translated">&lt;code&gt;PerlInterpreter*&lt;/code&gt; 로 구성되는 &lt;code&gt;perl_construct&lt;/code&gt; . 이 값은 대부분 완전성과 기본 C 변수 &lt;code&gt;PL_phase&lt;/code&gt; 를 통해 사용하기위한 것 입니다. 인터프리터 구성이 완료되지 않으면 Perl 코드를 실행할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="98058838817e528c0fbf9fe55b4c498c1c669b4e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;PerlInterpreter*&lt;/code&gt; is being constructed via &lt;code&gt;perl_construct&lt;/code&gt;. This value is mostly there for completeness and for use via the underlying C variable &lt;code&gt;PL_phase&lt;/code&gt;. It's not really possible for Perl code to be executed unless construction of the interpreter is finished.</source>
          <target state="translated">&lt;code&gt;PerlInterpreter*&lt;/code&gt; 로 구성되는 &lt;code&gt;perl_construct&lt;/code&gt; . 이 값은 대부분 완전성과 기본 C 변수 &lt;code&gt;PL_phase&lt;/code&gt; 를 통해 사용하기 위해 존재합니다 . 인터프리터 구성이 완료되지 않으면 Perl 코드를 실행할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="619b9e421badf230488baf0eee0a8b4f64f3d92d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;REGlob&lt;/code&gt; example above does not implement all the support needed to cleanly override perl's &lt;code&gt;&lt;a href=&quot;functions/glob&quot;&gt;glob&lt;/a&gt;&lt;/code&gt; operator. The built-in &lt;code&gt;&lt;a href=&quot;functions/glob&quot;&gt;glob&lt;/a&gt;&lt;/code&gt; has different behaviors depending on whether it appears in a scalar or list context, but our &lt;code&gt;REGlob&lt;/code&gt; doesn't. Indeed, many perl built-in have such context sensitive behaviors, and these must be adequately supported by a properly written override. For a fully functional example of overriding &lt;code&gt;&lt;a href=&quot;functions/glob&quot;&gt;glob&lt;/a&gt;&lt;/code&gt;, study the implementation of &lt;code&gt;File::DosGlob&lt;/code&gt; in the standard library.</source>
          <target state="translated">위 의 &lt;code&gt;REGlob&lt;/code&gt; 예제는 perl의 &lt;code&gt;&lt;a href=&quot;functions/glob&quot;&gt;glob&lt;/a&gt;&lt;/code&gt; 연산자 를 완전히 재정의하는 데 필요한 모든 지원을 구현하지 않습니다 . 내장 &lt;code&gt;&lt;a href=&quot;functions/glob&quot;&gt;glob&lt;/a&gt;&lt;/code&gt; 는 스칼라 또는 목록 컨텍스트에 나타나는지 여부에 따라 다른 동작을 &lt;code&gt;REGlob&lt;/code&gt; 은 그렇지 않습니다. 실제로, 많은 perl 내장에는 이러한 상황에 맞는 동작이 있으며 올바르게 작성된 재정의를 통해 적절하게 지원되어야합니다. &lt;code&gt;&lt;a href=&quot;functions/glob&quot;&gt;glob&lt;/a&gt;&lt;/code&gt; 재정의의 전체 기능 예제를 &lt;code&gt;File::DosGlob&lt;/code&gt; 표준 라이브러리에서 File :: DosGlob 의 구현을 연구하십시오 .</target>
        </trans-unit>
        <trans-unit id="2793461193bbb08faabc42ded2214d9447a84314" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;REGlob&lt;/code&gt; example above does not implement all the support needed to cleanly override perl's &lt;code&gt;glob&lt;/code&gt; operator. The built-in &lt;code&gt;glob&lt;/code&gt; has different behaviors depending on whether it appears in a scalar or list context, but our &lt;code&gt;REGlob&lt;/code&gt; doesn't. Indeed, many perl built-in have such context sensitive behaviors, and these must be adequately supported by a properly written override. For a fully functional example of overriding &lt;code&gt;glob&lt;/code&gt;, study the implementation of &lt;code&gt;File::DosGlob&lt;/code&gt; in the standard library.</source>
          <target state="translated">위 의 &lt;code&gt;REGlob&lt;/code&gt; 예제는 perl의 &lt;code&gt;glob&lt;/code&gt; 연산자 를 완전히 재정의하는 데 필요한 모든 지원을 구현하지 않습니다 . 기본 제공 &lt;code&gt;glob&lt;/code&gt; 은 스칼라 또는 목록 컨텍스트에 나타나는지 여부에 따라 다른 동작을 &lt;code&gt;REGlob&lt;/code&gt; 은 그렇지 않습니다. 사실, 많은 perl 빌트인은 상황에 맞는 동작을 가지고 있으며 적절하게 작성된 재정의에 의해 적절하게 지원되어야합니다. &lt;code&gt;glob&lt;/code&gt; 재정의에 대한 완전한 기능의 예를 &lt;code&gt;File::DosGlob&lt;/code&gt; 표준 라이브러리에서 File :: DosGlob 구현을 연구하십시오 .</target>
        </trans-unit>
        <trans-unit id="541482224c51c4cb7a6cd08e437f820560b203ea" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Return&lt;/code&gt; and &lt;code&gt;Envelope&lt;/code&gt; parameters are used for DSN (Delivery Status Notification).</source>
          <target state="translated">&lt;code&gt;Return&lt;/code&gt; 및 &lt;code&gt;Envelope&lt;/code&gt; 매개 변수는 DSN (배달 상태 알림)에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="0fb74752f70cdbcc4b24e6fe1a79d1c71cc57bd4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Reuse&lt;/code&gt; parameter is needed so that we restart our server manually without waiting a few minutes to allow system buffers to clear out.</source>
          <target state="translated">&lt;code&gt;Reuse&lt;/code&gt; 우리는 시스템 버퍼를 지울 수 있도록 몇 분을 기다리지 않고 수동으로 우리의 서버를 다시 시작할 수 있도록 매개 변수가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="6ef497f2f64147d9fc11b64ad7836f6a54270b55" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;SIGALRM&lt;/code&gt; signal is sent after the specified number of seconds. Implemented using &lt;code&gt;setitimer()&lt;/code&gt; if available, &lt;code&gt;ualarm()&lt;/code&gt; if not. The &lt;code&gt;$interval_floating_seconds&lt;/code&gt; argument is optional and will be zero if unspecified, resulting in &lt;code&gt;&lt;a href=&quot;../functions/alarm&quot;&gt;alarm()&lt;/a&gt;&lt;/code&gt;-like behaviour. This function can be imported, resulting in a nice drop-in replacement for the &lt;code&gt;&lt;a href=&quot;../functions/alarm&quot;&gt;alarm&lt;/a&gt;&lt;/code&gt; provided with perl, see the &lt;a href=&quot;#EXAMPLES&quot;&gt;EXAMPLES&lt;/a&gt; below.</source>
          <target state="translated">&lt;code&gt;SIGALRM&lt;/code&gt; 의 신호는 지정된 초 후에 전송된다. 사용 가능한 경우 &lt;code&gt;setitimer()&lt;/code&gt; 사용하고 구현 되지 않은 경우 &lt;code&gt;ualarm()&lt;/code&gt; 사용하여 구현했습니다 . &lt;code&gt;$interval_floating_seconds&lt;/code&gt; 인수는 선택 사항이며 제로 경우 지정되지 않은, 결과있을 것 &lt;code&gt;&lt;a href=&quot;../functions/alarm&quot;&gt;alarm()&lt;/a&gt;&lt;/code&gt; -처럼 행동. 이 기능을 가져 와서 perl과 함께 제공 되는 &lt;code&gt;&lt;a href=&quot;../functions/alarm&quot;&gt;alarm&lt;/a&gt;&lt;/code&gt; 을 대체 할 수 있습니다. 아래 &lt;a href=&quot;#EXAMPLES&quot;&gt;예를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="9c45565a357a5307165173264e504c30b567da1a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;SIGALRM&lt;/code&gt; signal is sent after the specified number of seconds. Implemented using &lt;code&gt;setitimer()&lt;/code&gt; if available, &lt;code&gt;ualarm()&lt;/code&gt; if not. The &lt;code&gt;$interval_floating_seconds&lt;/code&gt; argument is optional and will be zero if unspecified, resulting in &lt;code&gt;alarm()&lt;/code&gt;-like behaviour. This function can be imported, resulting in a nice drop-in replacement for the &lt;code&gt;alarm&lt;/code&gt; provided with perl, see the &lt;a href=&quot;#EXAMPLES&quot;&gt;&quot;EXAMPLES&quot;&lt;/a&gt; below.</source>
          <target state="translated">&lt;code&gt;SIGALRM&lt;/code&gt; 의 신호는 지정된 초 후에 전송된다. 가능한 경우 &lt;code&gt;setitimer()&lt;/code&gt; , 그렇지 않은 경우 &lt;code&gt;ualarm()&lt;/code&gt; 사용하여 구현됩니다 . &lt;code&gt;$interval_floating_seconds&lt;/code&gt; 인수는 선택 사항이며 제로 경우 지정되지 않은, 결과있을 것 &lt;code&gt;alarm()&lt;/code&gt; -처럼 행동. 이 함수를 가져올 수 있으므로 perl과 함께 제공 되는 &lt;code&gt;alarm&lt;/code&gt; 을 드롭 인으로 대체 할 수 있습니다. 아래 &lt;a href=&quot;#EXAMPLES&quot;&gt;&quot;예제&quot;를&lt;/a&gt; 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="739f23e9e223585aacd76fc17b10f95586c4f592" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;SSL_options&lt;/code&gt; attribute could also be used for such things as providing a client certificate for authentication to a server or controlling the choice of cipher used for the SSL connection. See &lt;a href=&quot;IO::Socket::SSL&quot;&gt;IO::Socket::SSL&lt;/a&gt; documentation for details.</source>
          <target state="translated">&lt;code&gt;SSL_options&lt;/code&gt; 의 속성은 서버에 인증을위한 클라이언트 인증서를 제공하거나 SSL 연결에 사용되는 암호의 선택을 제어하는 등의 일에 사용될 수 있습니다. 자세한 내용은 &lt;a href=&quot;IO::Socket::SSL&quot;&gt;IO :: Socket :: SSL&lt;/a&gt; 문서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="bcb26b9a2abefa95e1228823d5039552d2541e20" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;SUPER::&lt;/code&gt; bit tells Perl to look for the &lt;code&gt;print_info()&lt;/code&gt; in the &lt;code&gt;File::MP3&lt;/code&gt; class's inheritance chain. When it finds the parent class that implements this method, the method is called.</source>
          <target state="translated">&lt;code&gt;SUPER::&lt;/code&gt; 비트는 찾기 위해 펄을 알려줍니다 &lt;code&gt;print_info()&lt;/code&gt; 에서 &lt;code&gt;File::MP3&lt;/code&gt; 클래스의 상속 체인. 이 메소드를 구현하는 상위 클래스를 찾으면 메소드가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="3f5b4cff6fbfe1c281604ef06c021cd92e1eaa6d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;SUPER&lt;/code&gt; modifier can</source>
          <target state="translated">&lt;code&gt;SUPER&lt;/code&gt; 의 수정 캔</target>
        </trans-unit>
        <trans-unit id="371b5ebfc9cdf0db9a0a55eae240989e954cb726" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;SUPER&lt;/code&gt; pseudo-class is resolved from the package where the call is made. It is</source>
          <target state="translated">&lt;code&gt;SUPER&lt;/code&gt; 의 의사 클래스는 호출이 패키지에서 해결됩니다. 그것은</target>
        </trans-unit>
        <trans-unit id="00f36328e65732130767ca69dab4491f0365d24c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;SUPER&lt;/code&gt; pseudo-class that was described earlier is</source>
          <target state="translated">&lt;code&gt;SUPER&lt;/code&gt; 앞에서 설명한 의사 클래스입니다</target>
        </trans-unit>
        <trans-unit id="1a7a3a508d1d6570aa1ef0df5ea57827a95bbfc6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;SV_FORCE_UTF8_UPGRADE&lt;/code&gt; flag is now ignored.</source>
          <target state="translated">이제 &lt;code&gt;SV_FORCE_UTF8_UPGRADE&lt;/code&gt; 플래그가 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="ce9315ac1b0e03b32c4d0f032e1290883c21a935" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Script&lt;/code&gt; or &lt;code&gt;Script_Extensions&lt;/code&gt; properties are likely to be the ones you want to use when processing natural language; the &lt;code&gt;Block&lt;/code&gt; property may occasionally be useful in working with the nuts and bolts of Unicode.</source>
          <target state="translated">&lt;code&gt;Script&lt;/code&gt; 또는 &lt;code&gt;Script_Extensions&lt;/code&gt; 속성은 자연 언어를 처리 할 때 사용하려는 사람이 될 가능성이있다; &lt;code&gt;Block&lt;/code&gt; 속성은 가끔 유니 코드의 볼트와 너트 작업에 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0c768e6f5d4be03a1a932a1028083efcf53f3ba5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Script_Extensions&lt;/code&gt; or &lt;code&gt;Script&lt;/code&gt; properties are likely to be the ones you want to use when processing natural language; the &lt;code&gt;Block&lt;/code&gt; property may occasionally be useful in working with the nuts and bolts of Unicode.</source>
          <target state="translated">&lt;code&gt;Script_Extensions&lt;/code&gt; 또는 &lt;code&gt;Script&lt;/code&gt; 특성은 자연 언어를 처리 할 때 사용하려는 사람이 될 가능성이있다; &lt;code&gt;Block&lt;/code&gt; 속성은 가끔 유니 코드의 볼트와 너트 작업에 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9e2c75703b39600771c0a8ce5df27de06d22689b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Script_Extensions&lt;/code&gt; property as modified by UTS 39 (&lt;a href=&quot;https://unicode.org/reports/tr39/&quot;&gt;https://unicode.org/reports/tr39/&lt;/a&gt;) is used as the basis for this feature.</source>
          <target state="translated">&lt;code&gt;Script_Extensions&lt;/code&gt; 의 UTS (39)에 의해 수정 된 속성 ( &lt;a href=&quot;https://unicode.org/reports/tr39/&quot;&gt;https://unicode.org/reports/tr39/&lt;/a&gt; )이 기능을위한 기초로서 사용된다.</target>
        </trans-unit>
        <trans-unit id="0daac5f890ff04f28fabf32094505977d698c4f0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Storable::last_op_in_netorder()&lt;/code&gt; predicate will tell you whether network order was used in the last store or retrieve operation. If you don't know how to use this, just forget about it.</source>
          <target state="translated">&lt;code&gt;Storable::last_op_in_netorder()&lt;/code&gt; 술어는 네트워크 순서가 마지막으로 상점에서 사용 또는 작동을 검색 한 여부를 알려줍니다. 이것을 사용하는 방법을 모른다면 잊어 버리십시오.</target>
        </trans-unit>
        <trans-unit id="4f2453d7aa3fb23473e60b4a26a3d26672cf6341" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;TODO:&lt;/code&gt; and &lt;code&gt;$TODO&lt;/code&gt; syntax is generally pretty good about figuring out whether or not we're in a TODO test. However, often we find that this is not possible to determine (such as when we want to use &lt;code&gt;$TODO&lt;/code&gt; but the tests are being executed in other packages which can't be inferred beforehand).</source>
          <target state="translated">&lt;code&gt;TODO:&lt;/code&gt; 와 &lt;code&gt;$TODO&lt;/code&gt; 구문은 일반적으로 우리가 TODO 테스트에있어 여부 파악에 대한 아주 좋은 것입니다. 그러나 종종 우리는 이것이 결정하기가 불가능하다는 것을 알게됩니다 (예 : &lt;code&gt;$TODO&lt;/code&gt; 를 사용하고 싶지만 사전에 추론 할 수없는 다른 패키지에서 테스트가 실행되는 경우).</target>
        </trans-unit>
        <trans-unit id="316a59c6c105ba5a65d5de6abf6871022622f157" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;TO_JSON&lt;/code&gt; method may safely call die if it wants. If &lt;code&gt;TO_JSON&lt;/code&gt; returns other blessed objects, those will be handled in the same way. &lt;code&gt;TO_JSON&lt;/code&gt; must take care of not causing an endless recursion cycle (== crash) in this case. The name of &lt;code&gt;TO_JSON&lt;/code&gt; was chosen because other methods called by the Perl core (== not by the user of the object) are usually in upper case letters and to avoid collisions with any &lt;code&gt;to_json&lt;/code&gt; function or method.</source>
          <target state="translated">&lt;code&gt;TO_JSON&lt;/code&gt; 의 이 원한다면 방법은 안전하게 다이를 호출 할 수 있습니다. 경우 &lt;code&gt;TO_JSON&lt;/code&gt; 이 다른 축복 객체를 반환하는이 같은 방식으로 처리됩니다. &lt;code&gt;TO_JSON&lt;/code&gt; 은 무한 재귀주기 (== 크래시)를 일으키지 않도록주의해야합니다. &lt;code&gt;TO_JSON&lt;/code&gt; 의 이름은 Perl 코어 (== 개체 사용자가 아님)에서 호출하는 다른 메서드가 일반적으로 대문자로되어 있고 &lt;code&gt;to_json&lt;/code&gt; 함수 또는 메서드 와의 충돌을 피하기 위해 선택되었습니다 .</target>
        </trans-unit>
        <trans-unit id="94063ef306bbe0bc69a744042850751f57d8165a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;TRUE&lt;/code&gt; and &lt;code&gt;FALSE&lt;/code&gt; macros are available for situations where using them would clarify intent. (But they always just mean the same as the integers 1 and 0 regardless, so using them isn't compulsory.)</source>
          <target state="translated">&lt;code&gt;TRUE&lt;/code&gt; 및 &lt;code&gt;FALSE&lt;/code&gt; 의도를 명확히 것을 사용하여 어디 매크로 상황에 사용할 수 있습니다. (그러나 그들은 항상 정수 1과 0과 같은 의미이므로 반드시 사용하는 것은 아닙니다.)</target>
        </trans-unit>
        <trans-unit id="ca16843b685fa84c8313aca285e376c5597ef322" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;TYPEMAP&lt;/code&gt; section should contain one pair of C type and XS type per line as follows. An example from the core typemap file:</source>
          <target state="translated">&lt;code&gt;TYPEMAP&lt;/code&gt; 의 섹션 C 형 다음과 같이 라인 당 XS 형식의 한 쌍을 함유한다. 핵심 유형 맵 파일의 예 :</target>
        </trans-unit>
        <trans-unit id="ea8183d7125676dfc1989dcabf04b34c38b4f669" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Thread-&amp;gt;self&lt;/code&gt; function returns a thread object that represents the thread making the &lt;code&gt;Thread-&amp;gt;self&lt;/code&gt; call.</source>
          <target state="translated">&lt;code&gt;Thread-&amp;gt;self&lt;/code&gt; 기능은 만들기 스레드 나타내는 스레드 객체 반환 &lt;code&gt;Thread-&amp;gt;self&lt;/code&gt; 전화를.</target>
        </trans-unit>
        <trans-unit id="5f72cf2b372d3d426c2948d6098fd6cd1afad651" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Thread&lt;/code&gt; module provides multithreading support for Perl.</source>
          <target state="translated">&lt;code&gt;Thread&lt;/code&gt; 모듈은 펄에 대한 멀티 스레딩 지원을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="7fe8315550458ad4289f70c4a27bed2792ae2d78" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Thread&lt;/code&gt; module served as the frontend to the old-style thread model, called</source>
          <target state="translated">&lt;code&gt;Thread&lt;/code&gt; 라는 이전 스타일의 스레드 모델에 대한 프론트 엔드로 봉사 모듈,</target>
        </trans-unit>
        <trans-unit id="ab5cb47a9617fcafbcf6221a375828cf9de09e24" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Time::HiRes&lt;/code&gt; module implements a Perl interface to the &lt;code&gt;usleep&lt;/code&gt; , &lt;code&gt;nanosleep&lt;/code&gt; , &lt;code&gt;ualarm&lt;/code&gt; , &lt;code&gt;gettimeofday&lt;/code&gt; , and &lt;code&gt;setitimer&lt;/code&gt; /&lt;code&gt;getitimer&lt;/code&gt; system calls, in other words, high resolution time and timers. See the &lt;a href=&quot;#EXAMPLES&quot;&gt;EXAMPLES&lt;/a&gt; section below and the test scripts for usage; see your system documentation for the description of the underlying &lt;code&gt;nanosleep&lt;/code&gt; or &lt;code&gt;usleep&lt;/code&gt; , &lt;code&gt;ualarm&lt;/code&gt; , &lt;code&gt;gettimeofday&lt;/code&gt; , and &lt;code&gt;setitimer&lt;/code&gt; /&lt;code&gt;getitimer&lt;/code&gt; calls.</source>
          <target state="translated">&lt;code&gt;Time::HiRes&lt;/code&gt; 구현하는 모듈에 펄 인터페이스 &lt;code&gt;usleep&lt;/code&gt; , &lt;code&gt;nanosleep&lt;/code&gt; 를 , &lt;code&gt;ualarm&lt;/code&gt; , &lt;code&gt;gettimeofday&lt;/code&gt; 를 하고, &lt;code&gt;setitimer&lt;/code&gt; 은 / &lt;code&gt;getitimer&lt;/code&gt; 시스템 호출, 즉, 고해상도 시간과 타이머한다. 아래의 &lt;a href=&quot;#EXAMPLES&quot;&gt;예제&lt;/a&gt; 섹션과 테스트 스크립트를 참조하십시오 . 기본 &lt;code&gt;nanosleep&lt;/code&gt; 또는 &lt;code&gt;usleep&lt;/code&gt; , &lt;code&gt;ualarm&lt;/code&gt; , &lt;code&gt;gettimeofday&lt;/code&gt; 및 &lt;code&gt;setitimer&lt;/code&gt; / &lt;code&gt;getitimer&lt;/code&gt; 호출 에 대한 설명은 시스템 설명서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="840bb1616acfc5f4c8448fa1adbdaac8f85745ff" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Time::HiRes&lt;/code&gt; module implements a Perl interface to the &lt;code&gt;usleep&lt;/code&gt;, &lt;code&gt;nanosleep&lt;/code&gt;, &lt;code&gt;ualarm&lt;/code&gt;, &lt;code&gt;gettimeofday&lt;/code&gt;, and &lt;code&gt;setitimer&lt;/code&gt;/&lt;code&gt;getitimer&lt;/code&gt; system calls, in other words, high resolution time and timers. See the &lt;a href=&quot;#EXAMPLES&quot;&gt;&quot;EXAMPLES&quot;&lt;/a&gt; section below and the test scripts for usage; see your system documentation for the description of the underlying &lt;code&gt;nanosleep&lt;/code&gt; or &lt;code&gt;usleep&lt;/code&gt;, &lt;code&gt;ualarm&lt;/code&gt;, &lt;code&gt;gettimeofday&lt;/code&gt;, and &lt;code&gt;setitimer&lt;/code&gt;/&lt;code&gt;getitimer&lt;/code&gt; calls.</source>
          <target state="translated">&lt;code&gt;Time::HiRes&lt;/code&gt; 구현하는 모듈에 펄 인터페이스 &lt;code&gt;usleep&lt;/code&gt; , &lt;code&gt;nanosleep&lt;/code&gt; 를 , &lt;code&gt;ualarm&lt;/code&gt; , &lt;code&gt;gettimeofday&lt;/code&gt; 를 하고, &lt;code&gt;setitimer&lt;/code&gt; 은 / &lt;code&gt;getitimer&lt;/code&gt; 시스템 호출, 즉, 고해상도 시간과 타이머한다. 아래의 &lt;a href=&quot;#EXAMPLES&quot;&gt;&quot;예제&quot;&lt;/a&gt; 섹션과 사용에 대한 테스트 스크립트를 참조하십시오 . 기본 &lt;code&gt;nanosleep&lt;/code&gt; 또는 &lt;code&gt;usleep&lt;/code&gt; , &lt;code&gt;ualarm&lt;/code&gt; , &lt;code&gt;gettimeofday&lt;/code&gt; 및 &lt;code&gt;setitimer&lt;/code&gt; / &lt;code&gt;getitimer&lt;/code&gt; 호출 에 대한 설명은 시스템 문서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="db031bd2869c09fc69e58469a4b3b15d15dfaaa1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;UTF8_CHECK_ONLY&lt;/code&gt; flag overrides the behavior when a non-allowed (by other flags) malformation is found. If this flag is set, the routine assumes that the caller will raise a warning, and this function will silently just set &lt;code&gt;retlen&lt;/code&gt; to &lt;code&gt;-1&lt;/code&gt; (cast to &lt;code&gt;STRLEN&lt;/code&gt;) and return zero.</source>
          <target state="translated">&lt;code&gt;UTF8_CHECK_ONLY&lt;/code&gt; 의 비 허용 기형 (다른 플래그에 의해)이 발견되면 플래그는 동작을 재정의합니다. 이 플래그가 설정되면 루틴은 호출자가 경고를 발생시키는 것으로 가정하고이 함수는 조용히 &lt;code&gt;retlen&lt;/code&gt; 을 &lt;code&gt;-1&lt;/code&gt; ( &lt;code&gt;STRLEN&lt;/code&gt; 으로 캐스트 )로 설정하고 0을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="adde2e15da0476d4564064bbc384c4ca957b8d40" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;VERSION&lt;/code&gt; method returns the version number of the class (package).</source>
          <target state="translated">&lt;code&gt;VERSION&lt;/code&gt; 방법은 클래스 (패키지)의 버전 번호를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d8baa2e2f7c0fd0a2f0c9455f11a42eb910290cd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Win32::*&lt;/code&gt; modules in &lt;a href=&quot;http://search.cpan.org/perldoc/Win32&quot;&gt;Win32&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;Win32::*&lt;/code&gt; 모듈 &lt;a href=&quot;http://search.cpan.org/perldoc/Win32&quot;&gt;에서 Win32&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="365cfe3394d31517ee04bbcb7fdcf61281c556f0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Win32::*&lt;/code&gt; modules in &lt;a href=&quot;win32&quot;&gt;Win32&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;Win32::*&lt;/code&gt; 모듈 &lt;a href=&quot;win32&quot;&gt;에서 Win32&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c6c47ba9b1855f9e0e157ed96c1dac4112ef8de3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Z&amp;lt;&amp;gt;&lt;/code&gt; sequence is supposed to be empty.</source>
          <target state="translated">&lt;code&gt;Z&amp;lt;&amp;gt;&lt;/code&gt; 시퀀스가 비어 있어야한다.</target>
        </trans-unit>
        <trans-unit id="4f3af2152fe286b612ed068b47a818a0a9d55853" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;\&lt;i&gt;digit&lt;/i&gt;&lt;/code&gt; notation also works in certain circumstances outside the pattern. See &lt;a href=&quot;#Warning-on-%5C1-Instead-of-%241&quot;&gt;&quot;Warning on \1 Instead of $1&quot;&lt;/a&gt; below for details.</source>
          <target state="translated">&lt;code&gt;\&lt;i&gt;digit&lt;/i&gt;&lt;/code&gt; 표기는 패턴 외부의 특정 상황에서 작동합니다. 자세한 내용은 아래의 &lt;a href=&quot;#Warning-on-%5C1-Instead-of-%241&quot;&gt;&quot;$ 1 대신 \ 1에 대한 경고&quot;&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="f3c164b87544e368a57522144bf31b4093cb008b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;\&lt;i&gt;digit&lt;/i&gt;&lt;/code&gt; notation also works in certain circumstances outside the pattern. See &lt;a href=&quot;#Warning-on-%5c1-Instead-of-%241&quot;&gt;Warning on \1 Instead of $1&lt;/a&gt; below for details.</source>
          <target state="translated">&lt;code&gt;\&lt;i&gt;digit&lt;/i&gt;&lt;/code&gt; 표기는 패턴 외부의 특정 상황에서 작동합니다. 자세한 내용은 아래 &lt;a href=&quot;#Warning-on-%5c1-Instead-of-%241&quot;&gt;$ 1 대신 \ 1에 대한 경고를&lt;/a&gt; 참조 하십시오.</target>
        </trans-unit>
        <trans-unit id="c49d42a1bfbc0b22f583d2817d2ce107934b83b0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;\C&lt;/code&gt; is unsupported in lookbehind, because the already treacherous definition of &lt;code&gt;\C&lt;/code&gt; would become even more so when going backwards.</source>
          <target state="translated">&lt;code&gt;\C&lt;/code&gt; 의 이미 위험한 정의하기 때문에, lookbehind에서 지원되지 않는 &lt;code&gt;\C&lt;/code&gt; 뒤로 갈 때 더욱 그렇게 될 것입니다.</target>
        </trans-unit>
        <trans-unit id="b97997ed1726a2dd70e1e88046ee54105827a12b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;\G&lt;/code&gt; assertion can be used to chain global matches (using &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m//g&lt;/a&gt;&lt;/code&gt;), as described in &lt;a href=&quot;perlop#Regexp-Quote-Like-Operators&quot;&gt;Regexp Quote-Like Operators in perlop&lt;/a&gt;. It is also useful when writing &lt;code&gt;lex&lt;/code&gt; -like scanners, when you have several patterns that you want to match against consequent substrings of your string; see the previous reference. The actual location where &lt;code&gt;\G&lt;/code&gt; will match can also be influenced by using &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos()&lt;/a&gt;&lt;/code&gt; as an lvalue: see &lt;a href=&quot;functions/pos&quot;&gt;pos&lt;/a&gt;. Note that the rule for zero-length matches (see &lt;a href=&quot;#Repeated-Patterns-Matching-a-Zero-length-Substring&quot;&gt;Repeated Patterns Matching a Zero-length Substring&lt;/a&gt;) is modified somewhat, in that contents to the left of &lt;code&gt;\G&lt;/code&gt; are not counted when determining the length of the match. Thus the following will not match forever:</source>
          <target state="translated">&lt;code&gt;\G&lt;/code&gt; 어설 체인 글로벌 매치 (사용에 이용 될 수 &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m//g&lt;/a&gt;&lt;/code&gt; 설명대로) &lt;a href=&quot;perlop#Regexp-Quote-Like-Operators&quot;&gt;perlop 정규식에 견적 같은 연산자&lt;/a&gt; . 문자열의 하위 문자열과 비교할 패턴이 여러 개인 경우 &lt;code&gt;lex&lt;/code&gt; 유사 스캐너를 작성할 때도 유용 합니다. 이전 참조를 참조하십시오. &lt;code&gt;\G&lt;/code&gt; 가 일치 하는 실제 위치는 &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos()&lt;/a&gt;&lt;/code&gt; 를 lvalue로 사용하여 영향을받을 수 있습니다 . &lt;a href=&quot;functions/pos&quot;&gt;pos를&lt;/a&gt; 참조하십시오 . 길이가 0 인 일치 규칙 (길이 &lt;a href=&quot;#Repeated-Patterns-Matching-a-Zero-length-Substring&quot;&gt;가 0 인 하위 문자열과 일치하는 반복 패턴&lt;/a&gt; 참조 )은 &lt;code&gt;\G&lt;/code&gt; 의 왼쪽에있는 내용에서 약간 수정됩니다.일치하는 길이를 결정할 때는 계산되지 않습니다. 따라서 다음은 영원히 일치하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e1ff47fb2c42daca3a8b3c8a3d0395f0593d6c3c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;\G&lt;/code&gt; assertion can be used to chain global matches (using &lt;code&gt;m//g&lt;/code&gt;), as described in &lt;a href=&quot;perlop#Regexp-Quote-Like-Operators&quot;&gt;&quot;Regexp Quote-Like Operators&quot; in perlop&lt;/a&gt;. It is also useful when writing &lt;code&gt;lex&lt;/code&gt;-like scanners, when you have several patterns that you want to match against consequent substrings of your string; see the previous reference. The actual location where &lt;code&gt;\G&lt;/code&gt; will match can also be influenced by using &lt;code&gt;pos()&lt;/code&gt; as an lvalue: see &lt;a href=&quot;perlfunc#pos&quot;&gt;&quot;pos&quot; in perlfunc&lt;/a&gt;. Note that the rule for zero-length matches (see &lt;a href=&quot;#Repeated-Patterns-Matching-a-Zero-length-Substring&quot;&gt;&quot;Repeated Patterns Matching a Zero-length Substring&quot;&lt;/a&gt;) is modified somewhat, in that contents to the left of &lt;code&gt;\G&lt;/code&gt; are not counted when determining the length of the match. Thus the following will not match forever:</source>
          <target state="translated">&lt;code&gt;\G&lt;/code&gt; 어설 체인 글로벌 매치 (사용에 이용 될 수 &lt;code&gt;m//g&lt;/code&gt; 설명대로) &lt;a href=&quot;perlop#Regexp-Quote-Like-Operators&quot;&gt;perlop에서 &quot;정규식 견적 같은 연산자&quot;&lt;/a&gt; . 또한 문자열의 결과적인 하위 문자열에 대해 일치시키려는 여러 패턴이있을 때 &lt;code&gt;lex&lt;/code&gt; 와 유사한 스캐너를 작성할 때 유용 합니다. 이전 참조를 참조하십시오. &lt;code&gt;\G&lt;/code&gt; 가 일치 하는 실제 위치는 &lt;code&gt;pos()&lt;/code&gt; 를 lvalue로 사용하여 영향을받을 수도 있습니다 . &lt;a href=&quot;perlfunc#pos&quot;&gt;perlfunc의 &quot;pos&quot;를&lt;/a&gt; 참조하십시오 . 길이가 0 인 일치에 대한 규칙 ( &lt;a href=&quot;#Repeated-Patterns-Matching-a-Zero-length-Substring&quot;&gt;&quot;길이가 0 인 하위 문자열과 일치하는 반복 패턴&quot;&lt;/a&gt; 참조 )은 &lt;code&gt;\G&lt;/code&gt; 의 왼쪽에있는 내용에서 다소 수정되었습니다.경기 길이를 결정할 때 계산되지 않습니다. 따라서 다음은 영원히 일치하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9300fc0425608314652e19b5173bc5fd7efd18c9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;\N&lt;/code&gt; character class, not to be confused with the named character sequence &lt;code&gt;\N{NAME}&lt;/code&gt; , denotes any non-newline character in a regular expression.</source>
          <target state="translated">&lt;code&gt;\N&lt;/code&gt; 하지라는 문자 시퀀스와 혼동 문자 클래스 &lt;code&gt;\N{NAME}&lt;/code&gt; , 일반 식 비 개행 문자를 나타낸다.</target>
        </trans-unit>
        <trans-unit id="6fc55e5a124a8f9ba1fb9b74d5a25063c2e050b8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;\N{...}&lt;/code&gt; construct explicitly refers to a Unicode code point, even if it is one that is also in ASCII. Therefore the string containing it must be Unicode.</source>
          <target state="translated">&lt;code&gt;\N{...}&lt;/code&gt; 구조가 명시 적으로 ASCII에 또한 한 경우에도, 유니 코드 코드 포인트를 의미합니다. 따라서이를 포함하는 문자열은 유니 코드 여야합니다.</target>
        </trans-unit>
        <trans-unit id="7f0273d79d748bac786c369cab505ed24fe2cfda" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;\d&lt;/code&gt; gets rid of needing to anchor the pattern, since it forces the result to only match &lt;code&gt;[0-9]&lt;/code&gt;, and the &lt;code&gt;[0-5]&lt;/code&gt; further restricts it.</source>
          <target state="translated">&lt;code&gt;\d&lt;/code&gt; 단지 검색 결과로 강제하기 때문에, 고정 패턴을 필요를 제거한다 &lt;code&gt;[0-9]&lt;/code&gt; 및 &lt;code&gt;[0-5]&lt;/code&gt; 추가를 제한 그것.</target>
        </trans-unit>
        <trans-unit id="52316cb23d6228b5040f834369875ce8a00e4e55" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;\d\s\w\D\S\W&lt;/code&gt; abbreviations can be used both inside and outside of bracketed character classes. Here are some in use:</source>
          <target state="translated">&lt;code&gt;\d\s\w\D\S\W&lt;/code&gt; 약어 괄호 문자 클래스의 내부와 외부 모두에서 사용될 수있다. 사용중인 일부는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="dc3bb1079451a53e38a66554502d10e12737dc82" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;\d\s\w\D\S\W&lt;/code&gt; abbreviations can be used both inside and outside of character classes. Here are some in use:</source>
          <target state="translated">&lt;code&gt;\d\s\w\D\S\W&lt;/code&gt; 약어 문자 클래스의 내부와 외부 모두에서 사용될 수있다. 사용중인 일부는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0f2c8f2ff00b285673d694a7e44211cdef772f8e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;\g&lt;/code&gt; and &lt;code&gt;\k&lt;/code&gt; notations were introduced in Perl 5.10.0. Prior to that there were no named nor relative numbered capture groups. Absolute numbered groups were referred to using &lt;code&gt;\1&lt;/code&gt; , &lt;code&gt;\2&lt;/code&gt; , etc., and this notation is still accepted (and likely always will be). But it leads to some ambiguities if there are more than 9 capture groups, as &lt;code&gt;\10&lt;/code&gt; could mean either the tenth capture group, or the character whose ordinal in octal is 010 (a backspace in ASCII). Perl resolves this ambiguity by interpreting &lt;code&gt;\10&lt;/code&gt; as a backreference only if at least 10 left parentheses have opened before it. Likewise &lt;code&gt;\11&lt;/code&gt; is a backreference only if at least 11 left parentheses have opened before it. And so on. &lt;code&gt;\1&lt;/code&gt; through &lt;code&gt;\9&lt;/code&gt; are always interpreted as backreferences. There are several examples below that illustrate these perils. You can avoid the ambiguity by always using &lt;code&gt;\g{}&lt;/code&gt; or &lt;code&gt;\g&lt;/code&gt; if you mean capturing groups; and for octal constants always using &lt;code&gt;\o{}&lt;/code&gt; , or for &lt;code&gt;\077&lt;/code&gt; and below, using 3 digits padded with leading zeros, since a leading zero implies an octal constant.</source>
          <target state="translated">&lt;code&gt;\g&lt;/code&gt; 및 &lt;code&gt;\k&lt;/code&gt; 표시법 펄 5.10.0에 도입 하였다. 그 이전에는 명명 된 또는 상대 번호가 매겨진 캡처 그룹이 없었습니다. 절대 번호 그룹은 &lt;code&gt;\1&lt;/code&gt; , &lt;code&gt;\2&lt;/code&gt; 등 을 사용하여 참조 되었으며이 표기법은 여전히 ​​허용됩니다 (항상 가능할 것입니다). 그러나 9 개 이상의 캡처 그룹이있는 경우 &lt;code&gt;\10&lt;/code&gt; 은 10 번째 캡처 그룹 또는 8 진수의 서 수가 010 (ASCII의 백 스페이스) 인 문자를 의미 할 수 있으므로 약간의 모호함이 생깁니다 . Perl 은 적어도 10 개의 왼쪽 괄호가 열리면 &lt;code&gt;\10&lt;/code&gt; 을 역 참조로 해석하여이 모호성을 해결합니다 . 마찬가지로 &lt;code&gt;\11&lt;/code&gt; 11 개 이상의 왼쪽 괄호가 열리기 전에 만 역 참조입니다. 등등. &lt;code&gt;\1&lt;/code&gt; 에서 &lt;code&gt;\9&lt;/code&gt; 는 항상 역 참조로 해석됩니다. 이러한 위험을 보여주는 몇 가지 예가 아래에 있습니다. 그룹을 캡처하려는 경우 항상 &lt;code&gt;\g{}&lt;/code&gt; 또는 &lt;code&gt;\g&lt;/code&gt; 사용하여 모호성을 피할 수 있습니다 . 선행 0은 8 진 상수를 의미하기 때문에 항상 &lt;code&gt;\o{}&lt;/code&gt; 사용하는 8 진 상수 또는 &lt;code&gt;\077&lt;/code&gt; 이하를 사용하는 경우 선행 0으로 채워진 3 자리 숫자를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="15b6b1b5929104c2b72fb96a6e633ae2051f4ffd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;\g&lt;/code&gt; and &lt;code&gt;\k&lt;/code&gt; notations were introduced in Perl 5.10.0. Prior to that there were no named nor relative numbered capture groups. Absolute numbered groups were referred to using &lt;code&gt;\1&lt;/code&gt;, &lt;code&gt;\2&lt;/code&gt;,</source>
          <target state="translated">&lt;code&gt;\g&lt;/code&gt; 및 &lt;code&gt;\k&lt;/code&gt; 표시법 펄 5.10.0에 도입 하였다. 그 이전에는 이름이 붙거나 상대적으로 번호가 매겨진 캡처 그룹이 없었습니다. 절대 번호가 매겨진 그룹은 &lt;code&gt;\1&lt;/code&gt; , &lt;code&gt;\2&lt;/code&gt; ,</target>
        </trans-unit>
        <trans-unit id="517d2abbf8670e3eaf5c272713d99b8bf67cd7d0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;\g&lt;i&gt;N&lt;/i&gt;&lt;/code&gt; form can be equivalently written as &lt;code&gt;\g{&lt;i&gt;N&lt;/i&gt;}&lt;/code&gt; which avoids ambiguity when building a regex by concatenating shorter strings. Otherwise if you had a regex &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr/$a$b/&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;$a&lt;/code&gt; contained &lt;code&gt;&quot;\g1&quot;&lt;/code&gt; , and &lt;code&gt;$b&lt;/code&gt; contained &lt;code&gt;&quot;37&quot;&lt;/code&gt; , you would get &lt;code&gt;/\g137/&lt;/code&gt; which is probably not what you intended.</source>
          <target state="translated">&lt;code&gt;\g&lt;i&gt;N&lt;/i&gt;&lt;/code&gt; 형태는 등가 적으로 기록 될 수있다 &lt;code&gt;\g{&lt;i&gt;N&lt;/i&gt;}&lt;/code&gt; 짧은 문자열을 연결함으로써 정규식 구축시 모호성을 방지한다. 그렇지 않으면 정규식 &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr/$a$b/&lt;/a&gt;&lt;/code&gt; 가 있고 &lt;code&gt;$a&lt;/code&gt; 에 &lt;code&gt;&quot;\g1&quot;&lt;/code&gt; 이 있고 &lt;code&gt;$b&lt;/code&gt; 에 &lt;code&gt;&quot;37&quot;&lt;/code&gt; 이 있으면 &lt;code&gt;/\g137/&lt;/code&gt; 을 얻습니다 .</target>
        </trans-unit>
        <trans-unit id="03256d4028754b69d229d57c7593954c93901408" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;\g&lt;i&gt;N&lt;/i&gt;&lt;/code&gt; form can be equivalently written as &lt;code&gt;\g{&lt;i&gt;N&lt;/i&gt;}&lt;/code&gt; which avoids ambiguity when building a regex by concatenating shorter strings. Otherwise if you had a regex &lt;code&gt;qr/$a$b/&lt;/code&gt;, and &lt;code&gt;$a&lt;/code&gt; contained &lt;code&gt;&quot;\g1&quot;&lt;/code&gt;, and &lt;code&gt;$b&lt;/code&gt; contained &lt;code&gt;&quot;37&quot;&lt;/code&gt;, you would get &lt;code&gt;/\g137/&lt;/code&gt; which is probably not what you intended.</source>
          <target state="translated">&lt;code&gt;\g&lt;i&gt;N&lt;/i&gt;&lt;/code&gt; 형태는 등가 적으로 기록 될 수있다 &lt;code&gt;\g{&lt;i&gt;N&lt;/i&gt;}&lt;/code&gt; 짧은 문자열을 연결함으로써 정규식 구축시 모호성을 방지한다. 그렇지 않으면 정규식 &lt;code&gt;qr/$a$b/&lt;/code&gt; 가 있고 &lt;code&gt;$a&lt;/code&gt; 가 &lt;code&gt;&quot;\g1&quot;&lt;/code&gt; 을 포함하고 &lt;code&gt;$b&lt;/code&gt; 가 &lt;code&gt;&quot;37&quot;&lt;/code&gt; 을 포함 하면 &lt;code&gt;/\g137/&lt;/code&gt; 을 얻습니다. 이는 아마도 의도 한 바가 아닐 것입니다.</target>
        </trans-unit>
        <trans-unit id="1162dcf378fe4b180c42e9c8606223aea754f52f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;__DATA__&lt;/code&gt; token tells the perl compiler that the perl code for compilation is finished. Everything after the &lt;code&gt;__DATA__&lt;/code&gt; token is available for reading via the filehandle FOOBAR::DATA, where FOOBAR is the name of the current package when the &lt;code&gt;__DATA__&lt;/code&gt; token is reached. This works just the same as &lt;code&gt;__END__&lt;/code&gt; does in package 'main', but for other modules data after &lt;code&gt;__END__&lt;/code&gt; is not automatically retrievable, whereas data after &lt;code&gt;__DATA__&lt;/code&gt; is. The &lt;code&gt;__DATA__&lt;/code&gt; token is not recognized in versions of perl prior to 5.001m.</source>
          <target state="translated">&lt;code&gt;__DATA__&lt;/code&gt; 의 토큰은 컴파일을위한 펄 코드가 완료되는 펄 컴파일러를 알려줍니다. &lt;code&gt;__DATA__&lt;/code&gt; 토큰 이후의 모든 것은 파일 핸들 FOOBAR :: DATA를 통해 읽을 수 있습니다. 여기서 FOOBAR은 &lt;code&gt;__DATA__&lt;/code&gt; 토큰에 도달 할 때 현재 패키지의 이름입니다 . 이것은 패키지 'main'에서 &lt;code&gt;__END__&lt;/code&gt; 와 동일하게 작동 하지만 &lt;code&gt;__END__&lt;/code&gt; 이후의 데이터 는 자동으로 검색 할 수 없지만 &lt;code&gt;__DATA__&lt;/code&gt; 이후의 데이터는 자동으로 검색 할 수 없습니다 . &lt;code&gt;__DATA__&lt;/code&gt; 의 토큰은 펄 이전에 5.001m의 버전에서 인식되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="aaae759fadc0ccc32d523d9d6a0dc772ae2d9269" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;_r&lt;/code&gt; forms are automatically used, starting in Perl 5.28, if you compile your code, with</source>
          <target state="translated">&lt;code&gt;_r&lt;/code&gt; 의 양식은 자동으로, 당신은 당신의 코드를 컴파일하면, 펄 5.28 년부터 사용</target>
        </trans-unit>
        <trans-unit id="e8e846812293eaeddc68b23ea744d79168534a2d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;a&lt;/code&gt; , &lt;code&gt;A&lt;/code&gt; , and &lt;code&gt;Z&lt;/code&gt; types gobble just one value, but pack it as a string of length count, padding with nulls or spaces as needed. When unpacking, &lt;code&gt;A&lt;/code&gt; strips trailing whitespace and nulls, &lt;code&gt;Z&lt;/code&gt; strips everything after the first null, and &lt;code&gt;a&lt;/code&gt; returns data with no stripping at all.</source>
          <target state="translated">, 및 &lt;code&gt;Z&lt;/code&gt; 의 종류는 하나 개의 값을 중얼 있지만, 필요에 따라 널 (null) 또는 공백 길이 카운트 패딩 문자열로 팩. 포장을 풀 때, &lt;code&gt;A&lt;/code&gt; 는 공백 및 널 (null), 후행 냄니다 &lt;code&gt;Z&lt;/code&gt; 의 첫 널 후 스트립의 모든 것을, 그리고 없는 전혀 제거와 데이터를 반환합니다. &lt;code&gt;a&lt;/code&gt; &lt;code&gt;A&lt;/code&gt; &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1a1b3cf59097aca7e4188f4992a603a0b5d6ae0f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;A&lt;/code&gt;, and &lt;code&gt;Z&lt;/code&gt; types gobble just one value, but pack it as a string of length count, padding with nulls or spaces as needed. When unpacking, &lt;code&gt;A&lt;/code&gt; strips trailing whitespace and nulls, &lt;code&gt;Z&lt;/code&gt; strips everything after the first null, and &lt;code&gt;a&lt;/code&gt; returns data with no stripping at all.</source>
          <target state="translated">, 및 &lt;code&gt;Z&lt;/code&gt; 의 종류는 하나 개의 값을 중얼 있지만, 필요에 따라 널 (null) 또는 공백 길이 카운트 패딩 문자열로 팩. 압축을 풀 때 &lt;code&gt;A&lt;/code&gt; 는 후행 공백과 널을 제거 하고 &lt;code&gt;Z&lt;/code&gt; 는 첫 번째 널 이후의 모든 것을 제거하며 &lt;code&gt;a&lt;/code&gt; 는 전혀 제거하지 않고 데이터를 반환합니다. &lt;code&gt;a&lt;/code&gt; &lt;code&gt;A&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="893b37c14397452b4b42e37cd794a8b9b2d1eb65" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;alarm()&lt;/code&gt; function is not implemented on all versions of Windows. Check the documentation for your specific version of Perl.</source>
          <target state="translated">&lt;code&gt;alarm()&lt;/code&gt; 함수는 윈도우의 모든 버전에서 구현되지 않습니다. 특정 버전의 Perl에 대한 문서를 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="d5cca45db774b8d4bbc26743f5dae5512cca0753" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;antlers&lt;/code&gt; import flag tells &lt;code&gt;Class::Accessor&lt;/code&gt; that you want to define your attributes using &lt;code&gt;Moose&lt;/code&gt; -like syntax. The only parameter that you can pass to &lt;code&gt;has&lt;/code&gt; is &lt;code&gt;is&lt;/code&gt; . We recommend that you use this Moose-like syntax if you choose &lt;code&gt;Class::Accessor&lt;/code&gt; since it means you will have a smoother upgrade path if you later decide to move to &lt;code&gt;Moose&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;antlers&lt;/code&gt; 수입 플래그는 말한다 &lt;code&gt;Class::Accessor&lt;/code&gt; 사용하여 속성을 정의하도록 &lt;code&gt;Moose&lt;/code&gt; 구문 -like을. 당신이 통과 할 수있는 유일한 매개 변수 &lt;code&gt;has&lt;/code&gt; 되고 &lt;code&gt;is&lt;/code&gt; . &lt;code&gt;Class::Accessor&lt;/code&gt; 를 선택하면이 Moose와 유사한 구문을 사용하는 것이 좋습니다. 나중에 &lt;code&gt;Moose&lt;/code&gt; 로 이동하기로 결정하면 더 부드러운 업그레이드 경로를 갖기 때문 입니다.</target>
        </trans-unit>
        <trans-unit id="96ee1d0dc9d201f79ce6ef0d53eb7c5448972089" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;antlers&lt;/code&gt; import flag tells &lt;code&gt;Class::Accessor&lt;/code&gt; that you want to define your attributes using &lt;code&gt;Moose&lt;/code&gt;-like syntax. The only parameter that you can pass to &lt;code&gt;has&lt;/code&gt; is &lt;code&gt;is&lt;/code&gt;. We recommend that you use this Moose-like syntax if you choose &lt;code&gt;Class::Accessor&lt;/code&gt; since it means you will have a smoother upgrade path if you later decide to move to &lt;code&gt;Moose&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;antlers&lt;/code&gt; 수입 플래그는 말한다 &lt;code&gt;Class::Accessor&lt;/code&gt; 사용하여 속성을 정의하도록 &lt;code&gt;Moose&lt;/code&gt; 구문 -like을. 당신이 통과 할 수있는 유일한 매개 변수 &lt;code&gt;has&lt;/code&gt; 되고 &lt;code&gt;is&lt;/code&gt; . &lt;code&gt;Class::Accessor&lt;/code&gt; 를 선택한 경우이 Moose와 유사한 구문을 사용하는 것이 좋습니다. 이는 나중에 &lt;code&gt;Moose&lt;/code&gt; 로 이동하기로 결정한 경우 더 원활한 업그레이드 경로를 갖게 될 것임을 의미하기 때문 입니다.</target>
        </trans-unit>
        <trans-unit id="30d4c5418acb92744951617bccd4c2bb4e907086" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;as_number()&lt;/code&gt; function returns a BigInt from a Math::BigFloat. It uses 'trunc' as rounding mode to make it equivalent to:</source>
          <target state="translated">&lt;code&gt;as_number()&lt;/code&gt; 함수는 수학 :: BigFloat에서에서 BigInt을 반환합니다. 'trunc'를 반올림 모드로 사용하여 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a93f0f0ee3776b1d1340911a8e79d371cb0d5ce7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;authors&lt;/code&gt; and &lt;code&gt;licenses&lt;/code&gt; methods may also be called as &lt;code&gt;author&lt;/code&gt; and &lt;code&gt;license&lt;/code&gt;, respectively, to match the field name in the distmeta structure.</source>
          <target state="translated">&lt;code&gt;authors&lt;/code&gt; 및 &lt;code&gt;licenses&lt;/code&gt; 방법으로도 호출 할 수 있습니다 &lt;code&gt;author&lt;/code&gt; 및 &lt;code&gt;license&lt;/code&gt; distmeta 구조의 필드 이름과 일치하도록 각각.</target>
        </trans-unit>
        <trans-unit id="3e4be85862bcecd6790751ef47534ab240cde4eb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;autodie&lt;/code&gt; pragma has</source>
          <target state="translated">&lt;code&gt;autodie&lt;/code&gt; 의 pragma는있다</target>
        </trans-unit>
        <trans-unit id="92907be6274b88924410c3eb7108af17c084f529" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;autodie&lt;/code&gt; pragma provides a convenient way to replace functions that normally return false on failure with equivalents that throw an exception on failure.</source>
          <target state="translated">&lt;code&gt;autodie&lt;/code&gt; pragma는 일반적으로 실패에 대한 예외를 발생 등가물과 실패에 거짓을 반환하는 함수를 대체 할 수있는 편리한 방법을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="3ccf77f6494c4bb94f71a5890c3e377c22247ef4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;autosplit&lt;/code&gt; interface splits the specified file into a hierarchy rooted at the directory &lt;code&gt;$dir&lt;/code&gt; . It creates directories as needed to reflect class hierarchy, and creates the file</source>
          <target state="translated">&lt;code&gt;autosplit&lt;/code&gt; 인터페이스는 디렉토리를 루트로 계층 구조로 지정된 파일을 분할 &lt;code&gt;$dir&lt;/code&gt; . 클래스 계층 구조를 반영하는 데 필요한 디렉토리를 작성하고 파일을 작성합니다.</target>
        </trans-unit>
        <trans-unit id="9ec1a56ade0e6bb491c622b2d56bc77a622eb46d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;autosplit&lt;/code&gt; interface splits the specified file into a hierarchy rooted at the directory &lt;code&gt;$dir&lt;/code&gt;. It creates directories as needed to reflect class hierarchy, and creates the file</source>
          <target state="translated">&lt;code&gt;autosplit&lt;/code&gt; 인터페이스는 디렉토리를 루트로 계층 구조로 지정된 파일을 분할 &lt;code&gt;$dir&lt;/code&gt; . 클래스 계층 구조를 반영하기 위해 필요에 따라 디렉토리를 생성하고 파일을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="cc73dbc80868b5e2537b36abd82d968f2ba4c751" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;autosplit_lib_modules&lt;/code&gt; form is used in the building of perl. It takes as input a list of files (modules) that are assumed to reside in a directory &lt;b&gt;lib&lt;/b&gt; relative to the current directory. Each file is sent to the autosplitter one at a time, to be split into the directory &lt;b&gt;lib/auto&lt;/b&gt;.</source>
          <target state="translated">&lt;code&gt;autosplit_lib_modules&lt;/code&gt; 의 형태는 펄의 건물에 사용됩니다. 현재 디렉토리를 기준으로 &lt;b&gt;lib&lt;/b&gt; 디렉토리에 상주한다고 가정되는 파일 (모듈) 목록을 입력으로 사용합니다 . 각 파일은 한 번에 하나씩 &lt;b&gt;자동&lt;/b&gt; 스플리터로 전송되어 &lt;b&gt;lib / auto&lt;/b&gt; 디렉토리로 분할됩니다 .</target>
        </trans-unit>
        <trans-unit id="423004d21ce960dd9509db30e9f26d66964e12d2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;autotie&lt;/code&gt; mechanism supports this too. The following code:</source>
          <target state="translated">&lt;code&gt;autotie&lt;/code&gt; 의 메커니즘도이를 지원합니다. 다음 코드 :</target>
        </trans-unit>
        <trans-unit id="eadb034339c34e003fe891167b8ebaef4be23657" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;av_clear&lt;/code&gt; function deletes all the elements in the AV* array, but does not actually delete the array itself. The &lt;code&gt;av_undef&lt;/code&gt; function will delete all the elements in the array plus the array itself. The &lt;code&gt;av_extend&lt;/code&gt; function extends the array so that it contains at least &lt;code&gt;key+1&lt;/code&gt; elements. If &lt;code&gt;key+1&lt;/code&gt; is less than the currently allocated length of the array, then nothing is done.</source>
          <target state="translated">&lt;code&gt;av_clear&lt;/code&gt; 기능은 AV * 배열의 모든 요소를 삭제하지만, 실제로 배열 자체를 삭제하지 않습니다. &lt;code&gt;av_undef&lt;/code&gt; 기능은 배열 플러스 배열 자체에있는 모든 요소를 삭제합니다. &lt;code&gt;av_extend&lt;/code&gt; 의 것이 적어도 포함하도록 기능 어레이를 확장 &lt;code&gt;key+1&lt;/code&gt; 요소. 경우 &lt;code&gt;key+1&lt;/code&gt; 배열의 현재 할당 된 길이보다 짧은 다음, 아무것도 수행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d6bd36bbe209d0e332f324c88cb8fab5da451e26" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;av_store&lt;/code&gt; function, when given a tied array argument, merely copies the magic of the array onto the value to be &quot;stored&quot;, using &lt;code&gt;mg_copy&lt;/code&gt; . It may also return NULL, indicating that the value did not actually need to be stored in the array. [MAYCHANGE] After a call to &lt;code&gt;av_store&lt;/code&gt; on a tied array, the caller will usually need to call &lt;code&gt;mg_set(val)&lt;/code&gt; to actually invoke the perl level &quot;STORE&quot; method on the TIEARRAY object. If &lt;code&gt;av_store&lt;/code&gt; did return NULL, a call to &lt;code&gt;SvREFCNT_dec(val)&lt;/code&gt; will also be usually necessary to avoid a memory leak. [/MAYCHANGE]</source>
          <target state="translated">&lt;code&gt;av_store&lt;/code&gt; 의 기능, 묶여 배열 인수, 단순히 카피하여 값 위에 배열의 마법이 &quot;저장&quot;으로 주어진 경우 &lt;code&gt;mg_copy&lt;/code&gt; 를 . 또한 값을 실제로 배열에 저장할 필요가 없음을 나타내는 NULL을 반환 할 수도 있습니다. [MAYCHANGE] 연결된 배열에서 &lt;code&gt;av_store&lt;/code&gt; 를 호출 한 후 호출자는 일반적으로 TIEARRAY 객체에서 펄 수준 &quot;STORE&quot;메소드를 실제로 호출하려면 &lt;code&gt;mg_set(val)&lt;/code&gt; 을 호출해야합니다. &lt;code&gt;av_store&lt;/code&gt; 가 NULL을 반환 한 경우 일반적으로 메모리 누수를 피하기 위해 &lt;code&gt;SvREFCNT_dec(val)&lt;/code&gt; 호출 해야합니다. [/ MAYCHANGE]</target>
        </trans-unit>
        <trans-unit id="e12306e741c00686916bfa82246266097410a872" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;av_store&lt;/code&gt; function, when given a tied array argument, merely copies the magic of the array onto the value to be &quot;stored&quot;, using &lt;code&gt;mg_copy&lt;/code&gt;. It may also return NULL, indicating that the value did not actually need to be stored in the array. [MAYCHANGE] After a call to &lt;code&gt;av_store&lt;/code&gt; on a tied array, the caller will usually need to call &lt;code&gt;mg_set(val)&lt;/code&gt; to actually invoke the perl level &quot;STORE&quot; method on the TIEARRAY object. If &lt;code&gt;av_store&lt;/code&gt; did return NULL, a call to &lt;code&gt;SvREFCNT_dec(val)&lt;/code&gt; will also be usually necessary to avoid a memory leak. [/MAYCHANGE]</source>
          <target state="translated">&lt;code&gt;av_store&lt;/code&gt; 의 기능, 묶여 배열 인수, 단순히 카피하여 값 위에 배열의 마법이 &quot;저장&quot;으로 주어진 경우 &lt;code&gt;mg_copy&lt;/code&gt; 를 . 또한 값이 실제로 배열에 저장 될 필요가 없음을 나타내는 NULL을 반환 할 수도 있습니다. [MAYCHANGE] 연결된 배열에서 &lt;code&gt;av_store&lt;/code&gt; 를 호출 한 후 호출자는 일반적으로 &lt;code&gt;mg_set(val)&lt;/code&gt; 을 호출하여 TIEARRAY 개체에서 실제로 펄 레벨 &quot;STORE&quot;메서드를 호출해야합니다. &lt;code&gt;av_store&lt;/code&gt; 가 NULL을 반환 한 경우 일반적으로 메모리 누수를 방지하기 위해 &lt;code&gt;SvREFCNT_dec(val)&lt;/code&gt; 대한 호출 도 필요합니다. [/ MAYCHANGE]</target>
        </trans-unit>
        <trans-unit id="b0bf6421125301461c635d2914e7cd34219ce4cc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;av_top_index&lt;/code&gt; function returns the highest index value in an array (just like $#array in Perl). If the array is empty, -1 is returned. The &lt;code&gt;av_fetch&lt;/code&gt; function returns the value at index &lt;code&gt;key&lt;/code&gt; , but if &lt;code&gt;lval&lt;/code&gt; is non-zero, then &lt;code&gt;av_fetch&lt;/code&gt; will store an undef value at that index. The &lt;code&gt;av_store&lt;/code&gt; function stores the value &lt;code&gt;val&lt;/code&gt; at index &lt;code&gt;key&lt;/code&gt; , and does not increment the reference count of &lt;code&gt;val&lt;/code&gt; . Thus the caller is responsible for taking care of that, and if &lt;code&gt;av_store&lt;/code&gt; returns NULL, the caller will have to decrement the reference count to avoid a memory leak. Note that &lt;code&gt;av_fetch&lt;/code&gt; and &lt;code&gt;av_store&lt;/code&gt; both return &lt;code&gt;SV**&lt;/code&gt; 's, not &lt;code&gt;SV*&lt;/code&gt; 's as their return value.</source>
          <target state="translated">&lt;code&gt;av_top_index&lt;/code&gt; 함수는 배열 (펄 단지처럼 $ # 배열)에서 가장 높은 인덱스 값을 반환합니다. 배열이 비어 있으면 -1이 반환됩니다. &lt;code&gt;av_fetch&lt;/code&gt; 기능은 인덱스의 값 리턴 &lt;code&gt;key&lt;/code&gt; 하지만, 경우 &lt;code&gt;lval&lt;/code&gt; 아닌 제로이며, 다음 &lt;code&gt;av_fetch&lt;/code&gt; 는 해당 인덱스에서 미확정 값을 저장합니다. &lt;code&gt;av_store&lt;/code&gt; 의 함수 저장 값 &lt;code&gt;val&lt;/code&gt; 인덱스에 &lt;code&gt;key&lt;/code&gt; , 및 기준 카운트가 증가하지 않는 &lt;code&gt;val&lt;/code&gt; . 따라서 호출자는이를 처리 할 책임이 있으며 &lt;code&gt;av_store&lt;/code&gt; 가 NULL을 반환하면 호출자는 메모리 누수를 피하기 위해 참조 횟수를 줄여야합니다. 참고 &lt;code&gt;av_fetch&lt;/code&gt; 을및 &lt;code&gt;av_store&lt;/code&gt; 모두 반환 &lt;code&gt;SV**&lt;/code&gt; 의하지 &lt;code&gt;SV*&lt;/code&gt; '자신의 반환 값으로이야.</target>
        </trans-unit>
        <trans-unit id="b720f9a7cf39478f335b0b67c7ecec4e7dd453ba" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;av_top_index&lt;/code&gt; function returns the highest index value in an array (just like $#array in Perl). If the array is empty, -1 is returned. The &lt;code&gt;av_fetch&lt;/code&gt; function returns the value at index &lt;code&gt;key&lt;/code&gt;, but if &lt;code&gt;lval&lt;/code&gt; is non-zero, then &lt;code&gt;av_fetch&lt;/code&gt; will store an undef value at that index. The &lt;code&gt;av_store&lt;/code&gt; function stores the value &lt;code&gt;val&lt;/code&gt; at index &lt;code&gt;key&lt;/code&gt;, and does not increment the reference count of &lt;code&gt;val&lt;/code&gt;. Thus the caller is responsible for taking care of that, and if &lt;code&gt;av_store&lt;/code&gt; returns NULL, the caller will have to decrement the reference count to avoid a memory leak. Note that &lt;code&gt;av_fetch&lt;/code&gt; and &lt;code&gt;av_store&lt;/code&gt; both return &lt;code&gt;SV**&lt;/code&gt;'s, not &lt;code&gt;SV*&lt;/code&gt;'s as their return value.</source>
          <target state="translated">&lt;code&gt;av_top_index&lt;/code&gt; 함수는 배열 (펄 단지처럼 $ # 배열)에서 가장 높은 인덱스 값을 반환합니다. 배열이 비어 있으면 -1이 반환됩니다. &lt;code&gt;av_fetch&lt;/code&gt; 기능은 인덱스의 값 리턴 &lt;code&gt;key&lt;/code&gt; 하지만, 경우 &lt;code&gt;lval&lt;/code&gt; 아닌 제로이며, 다음 &lt;code&gt;av_fetch&lt;/code&gt; 는 해당 인덱스에서 미확정 값을 저장합니다. &lt;code&gt;av_store&lt;/code&gt; 의 함수 저장 값 &lt;code&gt;val&lt;/code&gt; 인덱스에 &lt;code&gt;key&lt;/code&gt; , 및 기준 카운트가 증가하지 않는 &lt;code&gt;val&lt;/code&gt; . 따라서 호출자는이를 처리 할 책임이 있으며 &lt;code&gt;av_store&lt;/code&gt; 가 NULL을 반환하면 호출자는 메모리 누수를 방지하기 위해 참조 횟수를 줄여야합니다. 참고 &lt;code&gt;av_fetch&lt;/code&gt; 을 &lt;code&gt;av_store&lt;/code&gt; 는 모두 &lt;code&gt;SV**&lt;/code&gt; 반환 하고 &lt;code&gt;SV*&lt;/code&gt; 는 반환 값으로 반환 하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="78b7a8fbb40ab78219d70980fb393c043d50ef45" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;bind&lt;/code&gt; argument specifies the local_addr to bind to. By specifying a bind argument you don't need the bind method.</source>
          <target state="translated">&lt;code&gt;bind&lt;/code&gt; 인수 는 바인딩 할 local_addr을 지정합니다. bind 인수를 지정하면 bind 메서드가 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0be24d4311997148f32f98999c298c4120e52577" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;binmode&lt;/code&gt; function can be called on an opened handle to push additional layers onto the stack, which may also modify the existing layers. &lt;code&gt;binmode&lt;/code&gt; called with no layers will remove or unset any existing layers which transform the byte stream, making the handle suitable for binary data.</source>
          <target state="translated">&lt;code&gt;binmode&lt;/code&gt; 기능은 기존의 계층을 변경할 수있다 스택 상에 부가적인 층을 밀어 개방 손잡이를 호출 할 수있다. 레이어없이 호출 된 &lt;code&gt;binmode&lt;/code&gt; 는 바이트 스트림을 변환하는 기존 레이어를 제거하거나 설정 해제하여 이진 데이터에 적합한 핸들을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="185e8e007341d198fca87c48c9798b7fe0dfa929" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;binmode&lt;/code&gt; operator will attempt to insure that no translation of carriage control occurs on input from or output to this filehandle. Since this involves reopening the file and then restoring its file position indicator, if this function returns FALSE, the underlying filehandle may no longer point to an open file, or may point to a different position in the file than before &lt;code&gt;binmode&lt;/code&gt; was called.</source>
          <target state="translated">&lt;code&gt;binmode&lt;/code&gt; 운영자는 캐리지 제어의 번역문이 핸들에의 입력 또는 출력을 발생하지 않도록 보장하기 위해 시도 할 것이다. 여기에는 파일을 다시 연 다음 파일 위치 표시기를 복원하는 것이 포함되기 때문에이 함수가 FALSE를 반환하면 기본 파일 핸들이 더 이상 열린 파일을 가리 키지 않거나 &lt;code&gt;binmode&lt;/code&gt; 가 호출 되기 전과는 다른 파일 위치를 가리킬 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ca3e501abc26cf1405f0402c343ec30915264f88" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;break&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; keywords from C become in Perl &lt;code&gt;&lt;a href=&quot;functions/last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt;, respectively. Unlike in C, these do</source>
          <target state="translated">C 의 &lt;code&gt;break&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; 키워드는 각각 Perl에서 &lt;code&gt;&lt;a href=&quot;functions/last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; 가됩니다. C와 달리 이것들은</target>
        </trans-unit>
        <trans-unit id="cf097e70ce7b8cc145798b0019e84f65b1044b49" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;break&lt;/code&gt; and &lt;code&gt;continue&lt;/code&gt; keywords from C become in Perl &lt;code&gt;last&lt;/code&gt; and &lt;code&gt;next&lt;/code&gt;, respectively. Unlike in C, these do</source>
          <target state="translated">C 의 &lt;code&gt;break&lt;/code&gt; 및 &lt;code&gt;continue&lt;/code&gt; 키워드는 각각 Perl &lt;code&gt;last&lt;/code&gt; 및 &lt;code&gt;next&lt;/code&gt; 가됩니다. C와 달리</target>
        </trans-unit>
        <trans-unit id="787c128b8b97671abe15918465f291ec006979e4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;buffered&lt;/code&gt; attribute of the &lt;a href=&quot;Test2::Event::Subtest&quot;&gt;Test2::Event::Subtest&lt;/a&gt; event will be set to the value of this flag. This means any formatter, listener, etc which looks at the event will know if it was buffered.</source>
          <target state="translated">&lt;a href=&quot;Test2::Event::Subtest&quot;&gt;Test2 :: Event :: Subtest&lt;/a&gt; 이벤트 의 &lt;code&gt;buffered&lt;/code&gt; 속성 은이 플래그의 값으로 설정됩니다. 이는 이벤트를 보는 포맷터, 리스너 등이 버퍼링되었는지 알 수 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="1750aab93908ada1ee29e1880f7061b67617e505" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cacheout&lt;/code&gt; function will make sure that there's a filehandle open for reading or writing available as the pathname you give it. It automatically closes and re-opens files if you exceed your system's maximum number of file descriptors, or the suggested maximum</source>
          <target state="translated">&lt;code&gt;cacheout&lt;/code&gt; 의 기능은 반드시 읽거나 당신이 그것을주는 경로로 사용할 수 기입하기위한 파일 핸들 개방이 있다고 할 것입니다. 시스템의 최대 파일 설명자 수 또는 제안 된 최대 수를 초과하면 자동으로 파일을 닫았다가 다시 엽니 다</target>
        </trans-unit>
        <trans-unit id="2c5778ca552de672cec71f94fb24332cb951e6b8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;can&lt;/code&gt; method checks to see if the class or object it was called on has a method named &lt;code&gt;$method&lt;/code&gt; . This checks for the method in the class and all of its parents. If the method exists, then a reference to the subroutine is returned. If it does not then &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; is returned.</source>
          <target state="translated">&lt;code&gt;can&lt;/code&gt; 방법의 검사 클래스 있는지 또는 그것이라는 메서드가 호출 된 객체하기 &lt;code&gt;$method&lt;/code&gt; . 클래스와 모든 부모의 메소드를 확인합니다. 메소드가 존재하면 서브 루틴에 대한 참조가 리턴됩니다. 그렇지 않으면 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="b581c43bfa8c63ce0337f8cf0f51834457cb5241" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;can&lt;/code&gt; method checks to see if the class or object it was called on has a method named &lt;code&gt;$method&lt;/code&gt;. This checks for the method in the class and all of its parents. If the method exists, then a reference to the subroutine is returned. If it does not then &lt;code&gt;undef&lt;/code&gt; is returned.</source>
          <target state="translated">&lt;code&gt;can&lt;/code&gt; 방법의 검사 클래스 있는지 또는 그것이라는 메서드가 호출 된 객체하기 &lt;code&gt;$method&lt;/code&gt; . 이것은 클래스와 모든 부모의 메서드를 확인합니다. 메소드가 존재하면 서브 루틴에 대한 참조가 리턴됩니다. 그렇지 않으면 &lt;code&gt;undef&lt;/code&gt; 가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="a231f00f91910adc2ab3862d9199fc8f2fdda4f5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;can_run&lt;/code&gt; function can tell you if a certain binary is installed and if so where, whereas the &lt;code&gt;run&lt;/code&gt; function can actually execute any of the commands you give it and give you a clear return value, as well as adhere to your verbosity settings.</source>
          <target state="translated">&lt;code&gt;can_run&lt;/code&gt; 의 기능은 특정 바이너리가 설치되어있는 경우 당신에게 말할 수 그렇다면 경우, 반면 &lt;code&gt;run&lt;/code&gt; 기능은 실제로 당신이 그것을 포기하고 당신에게 당신의 상세 설정에 대한 명확한 반환 값뿐만 아니라 부착합니다을주는 명령을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ae669119c46135f428f552580c056d83e94ae6fd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;char*&lt;/code&gt; string does not tell you the whole story, and you can't copy or reconstruct an SV just by copying the string value. Check if the old SV has the UTF8 flag set (</source>
          <target state="translated">&lt;code&gt;char*&lt;/code&gt; 캐릭터는 당신에게 전체 이야기를하지 않습니다, 당신은 복사 할 수 없습니다하거나 문자열 값을 복사하여 SV를 재구성. 이전 SV에 UTF8 플래그가 설정되어 있는지 확인하십시오 (</target>
        </trans-unit>
        <trans-unit id="3b094d933bb88b4ae1f6722063975d6ce16a864f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;charnames&lt;/code&gt; pragma supports arguments &lt;code&gt;:full&lt;/code&gt; , &lt;code&gt;:loose&lt;/code&gt; , &lt;code&gt;:short&lt;/code&gt; , script names and &lt;a href=&quot;#CUSTOM-ALIASES&quot;&gt;customized aliases&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;charnames&lt;/code&gt; 의 프라그 지원 인수 &lt;code&gt;:full&lt;/code&gt; , &lt;code&gt;:loose&lt;/code&gt; , &lt;code&gt;:short&lt;/code&gt; , 스크립트 이름 및 &lt;a href=&quot;#CUSTOM-ALIASES&quot;&gt;사용자 정의 별칭&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3385057bdbf70e4b65ad1d11db30e12395abd68a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;charnames&lt;/code&gt; pragma supports arguments &lt;code&gt;:full&lt;/code&gt;, &lt;code&gt;:loose&lt;/code&gt;, &lt;code&gt;:short&lt;/code&gt;, script names and &lt;a href=&quot;#CUSTOM-ALIASES&quot;&gt;customized aliases&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;charnames&lt;/code&gt; 의 프라그 지원 인수 &lt;code&gt;:full&lt;/code&gt; , &lt;code&gt;:loose&lt;/code&gt; , &lt;code&gt;:short&lt;/code&gt; , 스크립트 이름 및 &lt;a href=&quot;#CUSTOM-ALIASES&quot;&gt;사용자 정의 별칭&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9f351acbd57d2d1102a02f0ad7f0071439704163" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;chr()&lt;/code&gt; and &lt;code&gt;ord()&lt;/code&gt; functions work on whole characters.</source>
          <target state="translated">&lt;code&gt;chr()&lt;/code&gt; 와 &lt;code&gt;ord()&lt;/code&gt; 전체 문자의 기능이 작동합니다.</target>
        </trans-unit>
        <trans-unit id="7bf018bbe36ec38be15a617cdd0dc65af5cb382c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cmp&lt;/code&gt; (and hence &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt;) operators do not necessarily give the correct results when both operands are UTF-EBCDIC encoded strings and there is a mixture of ASCII and/or control characters, along with other characters.</source>
          <target state="translated">&lt;code&gt;cmp&lt;/code&gt; (따라서 &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt; ) 피연산자가 모두 UTF-EBCDIC 인코딩 및 ASCII 문자열 및 / 또는 제어 문자 혼합물 다른 문자와 함께있을 때 운영자가 반드시 정확한 결과를 제공하지 않는다.</target>
        </trans-unit>
        <trans-unit id="ec09ece4b13035db3b64ac6559a812694d130f2a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;color&lt;/code&gt; function determines if colouring should occur or not. Passing it a true or false value will enable or disable colouring respectively, and the function called with no argument will return the current setting.</source>
          <target state="translated">&lt;code&gt;color&lt;/code&gt; 기능 은 색상 발생 여부를 결정합니다. true 또는 false 값을 전달하면 각각 색상이 활성화 또는 비활성화되며 인수없이 호출 된 함수는 현재 설정을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="fcc832a2467057f7acfd689fa1bb07925f149ce1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;complicated&lt;/code&gt; function will return the same numeric &lt;code&gt;$result&lt;/code&gt; regardless of whether it is called in list or in scalar context.</source>
          <target state="translated">&lt;code&gt;complicated&lt;/code&gt; 기능은 동일한 숫자 돌아갑니다 &lt;code&gt;$result&lt;/code&gt; 관계없이 목록에 또는 스칼라 컨텍스트에서 호출 여부.</target>
        </trans-unit>
        <trans-unit id="f67952b359119ecd8ea38089ffb10eb7987a4172" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cond_broadcast&lt;/code&gt; function works similarly to &lt;code&gt;cond_signal&lt;/code&gt; . &lt;code&gt;cond_broadcast&lt;/code&gt; , though, will unblock &lt;b&gt;all&lt;/b&gt; the threads that are blocked in a &lt;code&gt;cond_wait&lt;/code&gt; on the locked variable, rather than only one.</source>
          <target state="translated">&lt;code&gt;cond_broadcast&lt;/code&gt; 기능은 비슷하게 작동 &lt;code&gt;cond_signal&lt;/code&gt; . &lt;code&gt;cond_broadcast&lt;/code&gt; 는 하지만, 차단을 해제합니다 &lt;b&gt;모든&lt;/b&gt; A의 차단 된 스레드 &lt;code&gt;cond_wait&lt;/code&gt; 오히려 하나보다, 잠금 변수를.</target>
        </trans-unit>
        <trans-unit id="2c18198f3431b0af0518f8194180bdd1d59f0718" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cond_broadcast&lt;/code&gt; function works similarly to &lt;code&gt;cond_signal&lt;/code&gt;. &lt;code&gt;cond_broadcast&lt;/code&gt;, though, will unblock &lt;b&gt;all&lt;/b&gt; the threads that are blocked in a &lt;code&gt;cond_wait&lt;/code&gt; on the locked variable, rather than only one.</source>
          <target state="translated">&lt;code&gt;cond_broadcast&lt;/code&gt; 기능은 비슷하게 작동 &lt;code&gt;cond_signal&lt;/code&gt; . &lt;code&gt;cond_broadcast&lt;/code&gt; 는 하지만, 차단을 해제합니다 &lt;b&gt;모든&lt;/b&gt; A의 차단 된 스레드 &lt;code&gt;cond_wait&lt;/code&gt; 오히려 하나보다, 잠금 변수를.</target>
        </trans-unit>
        <trans-unit id="a85c76c4fd238a57c5f21f762fcaeb20729d17df" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cond_signal&lt;/code&gt; function takes a &lt;b&gt;locked&lt;/b&gt; variable as a parameter and unblocks one thread that's &lt;code&gt;cond_wait&lt;/code&gt; ing on that variable. If more than one thread is blocked in a &lt;code&gt;cond_wait&lt;/code&gt; on that variable, only one (and which one is indeterminate) will be unblocked.</source>
          <target state="translated">&lt;code&gt;cond_signal&lt;/code&gt; 함수 얻어 &lt;b&gt;고정&lt;/b&gt; 파라미터로 변수의 하나 개의 스레드 및 해제한다 &lt;code&gt;cond_wait&lt;/code&gt; 해당 변수에 보내고있다. 해당 변수 의 &lt;code&gt;cond_wait&lt;/code&gt; 에서 둘 이상의 스레드가 차단 된 경우 하나 (및 결정되지 않은 스레드) 만 차단 해제됩니다.</target>
        </trans-unit>
        <trans-unit id="17177c8bfdab5cbbef640ed5fdbe840af84bd3e1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cond_signal&lt;/code&gt; function takes a &lt;b&gt;locked&lt;/b&gt; variable as a parameter and unblocks one thread that's &lt;code&gt;cond_wait&lt;/code&gt;ing on that variable. If more than one thread is blocked in a &lt;code&gt;cond_wait&lt;/code&gt; on that variable, only one (and which one is indeterminate) will be unblocked.</source>
          <target state="translated">&lt;code&gt;cond_signal&lt;/code&gt; 함수 얻어 &lt;b&gt;고정&lt;/b&gt; 파라미터로 변수의 하나 개의 스레드 및 해제한다 &lt;code&gt;cond_wait&lt;/code&gt; 해당 변수에 보내고있다. 해당 변수 의 &lt;code&gt;cond_wait&lt;/code&gt; 에서 둘 이상의 스레드가 차단 된 경우 하나 (그리고 어느 하나가 결정되지 않음) 만 차단 해제됩니다.</target>
        </trans-unit>
        <trans-unit id="c5be06c4673c5f0381dc64821a424c5ce57dffbf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cond_signal&lt;/code&gt; function takes a locked variable as a parameter and unblocks one thread that's &lt;code&gt;cond_wait&lt;/code&gt; ing on that variable. If more than one thread is blocked in a &lt;code&gt;cond_wait&lt;/code&gt; on that variable, only one (and which one is indeterminate) will be unblocked.</source>
          <target state="translated">&lt;code&gt;cond_signal&lt;/code&gt; 함수 파라미터로 로크 변수를 취하고있어 하나 개의 스레드 해제한다 &lt;code&gt;cond_wait&lt;/code&gt; 해당 변수에 보내고있다. 해당 변수 의 &lt;code&gt;cond_wait&lt;/code&gt; 에서 둘 이상의 스레드가 차단 된 경우 하나 (및 결정되지 않은 스레드) 만 차단 해제됩니다.</target>
        </trans-unit>
        <trans-unit id="90834b3f231b489213b8a6d3ee5e7273db92badc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cond_signal&lt;/code&gt; function takes a locked variable as a parameter and unblocks one thread that's &lt;code&gt;cond_wait&lt;/code&gt;ing on that variable. If more than one thread is blocked in a &lt;code&gt;cond_wait&lt;/code&gt; on that variable, only one (and which one is indeterminate) will be unblocked.</source>
          <target state="translated">&lt;code&gt;cond_signal&lt;/code&gt; 함수 파라미터로 로크 변수를 취하고있어 하나 개의 스레드 해제한다 &lt;code&gt;cond_wait&lt;/code&gt; 해당 변수에 보내고있다. 해당 변수 의 &lt;code&gt;cond_wait&lt;/code&gt; 에서 둘 이상의 스레드가 차단 된 경우 하나 (그리고 어느 하나가 결정되지 않음) 만 차단 해제됩니다.</target>
        </trans-unit>
        <trans-unit id="076e7dbb91376a2a5dc565f0cafe6a8c9c90bfab" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cond_wait&lt;/code&gt; function takes a &lt;b&gt;locked&lt;/b&gt; variable as a parameter, unlocks the variable, and blocks until another thread does a &lt;code&gt;cond_signal&lt;/code&gt; or &lt;code&gt;cond_broadcast&lt;/code&gt; for that same locked variable. The variable that &lt;code&gt;cond_wait&lt;/code&gt; blocked on is re-locked after the &lt;code&gt;cond_wait&lt;/code&gt; is satisfied. If there are multiple threads &lt;code&gt;cond_wait&lt;/code&gt; ing on the same variable, all but one will re-block waiting to reacquire the lock on the variable. (So if you're only using &lt;code&gt;cond_wait&lt;/code&gt; for synchronization, give up the lock as soon as possible). The two actions of unlocking the variable and entering the blocked wait state are atomic, the two actions of exiting from the blocked wait state and re-locking the variable are not.</source>
          <target state="translated">&lt;code&gt;cond_wait&lt;/code&gt; 기능은 얻어 &lt;b&gt;잠긴&lt;/b&gt; 다른 스레드가 수행 될 때까지 매개 변수로 변수가 변수의 잠금을 해제하고, 블록 &lt;code&gt;cond_signal&lt;/code&gt; 또는 &lt;code&gt;cond_broadcast&lt;/code&gt; 같은 변수를 잠긴. &lt;code&gt;cond_wait&lt;/code&gt; 가 차단 된 변수 는 &lt;code&gt;cond_wait&lt;/code&gt; 가 충족 된 후 다시 잠 깁니다 . 동일한 변수에 여러 스레드 &lt;code&gt;cond_wait&lt;/code&gt; 가있는 경우 하나를 제외한 모든 스레드 가 변수에 대한 잠금을 다시 얻기 위해 대기하는 것을 다시 차단합니다. (따라서 &lt;code&gt;cond_wait&lt;/code&gt; 만 사용하는 경우동기화를 위해 가능한 빨리 잠금을 해제하십시오). 변수 잠금을 해제하고 차단 된 대기 상태로 들어가는 두 가지 동작은 원 자성이며, 차단 된 대기 상태를 종료하고 변수를 다시 잠그는 두 가지 동작은 원자 적이 지 않습니다.</target>
        </trans-unit>
        <trans-unit id="439f35352dbf1d510415ebca01133fb2e86790ef" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cond_wait&lt;/code&gt; function takes a &lt;b&gt;locked&lt;/b&gt; variable as a parameter, unlocks the variable, and blocks until another thread does a &lt;code&gt;cond_signal&lt;/code&gt; or &lt;code&gt;cond_broadcast&lt;/code&gt; for that same locked variable. The variable that &lt;code&gt;cond_wait&lt;/code&gt; blocked on is re-locked after the &lt;code&gt;cond_wait&lt;/code&gt; is satisfied. If there are multiple threads &lt;code&gt;cond_wait&lt;/code&gt;ing on the same variable, all but one will re-block waiting to reacquire the lock on the variable. (So if you're only using &lt;code&gt;cond_wait&lt;/code&gt; for synchronization, give up the lock as soon as possible). The two actions of unlocking the variable and entering the blocked wait state are atomic, the two actions of exiting from the blocked wait state and re-locking the variable are not.</source>
          <target state="translated">&lt;code&gt;cond_wait&lt;/code&gt; 기능은 얻어 &lt;b&gt;잠긴&lt;/b&gt; 다른 스레드가 수행 될 때까지 매개 변수로 변수가 변수의 잠금을 해제하고, 블록 &lt;code&gt;cond_signal&lt;/code&gt; 또는 &lt;code&gt;cond_broadcast&lt;/code&gt; 같은 변수를 잠긴. &lt;code&gt;cond_wait&lt;/code&gt; 가 차단 된 변수 는 &lt;code&gt;cond_wait&lt;/code&gt; 가 충족 된 후 다시 잠 깁니다 . 동일한 변수에 &lt;code&gt;cond_wait&lt;/code&gt; ing 하는 여러 스레드가있는 경우 하나를 제외한 모든 스레드 가 변수에 대한 잠금을 다시 획득하기 위해 대기하는 것을 다시 차단합니다. (따라서 &lt;code&gt;cond_wait&lt;/code&gt; 만 사용하는 경우동기화를 위해 가능한 한 빨리 잠금을 해제하십시오). 변수를 잠금 해제하고 차단 된 대기 상태로 들어가는 두 가지 동작은 원자 적이며, 차단 된 대기 상태에서 빠져 나가고 변수를 다시 잠그는 두 가지 동작은 그렇지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0fa04a005ef5fee3bbdeb8f830aca63065ce2e7e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cond_wait&lt;/code&gt; function takes a &lt;b&gt;locked&lt;/b&gt; variable as a parameter, unlocks the variable, and blocks until another thread does a &lt;code&gt;cond_signal&lt;/code&gt; or &lt;code&gt;cond_broadcast&lt;/code&gt; for that same locked variable. The variable that &lt;code&gt;cond_wait&lt;/code&gt; blocked on is relocked after the &lt;code&gt;cond_wait&lt;/code&gt; is satisfied. If there are multiple threads &lt;code&gt;cond_wait&lt;/code&gt; ing on the same variable, all but one will reblock waiting to re-acquire the lock on the variable. (So if you're only using &lt;code&gt;cond_wait&lt;/code&gt; for synchronization, give up the lock as soon as possible.)</source>
          <target state="translated">&lt;code&gt;cond_wait&lt;/code&gt; 기능은 얻어 &lt;b&gt;잠긴&lt;/b&gt; 다른 스레드가 수행 될 때까지 매개 변수로 변수가 변수의 잠금을 해제하고, 블록 &lt;code&gt;cond_signal&lt;/code&gt; 또는 &lt;code&gt;cond_broadcast&lt;/code&gt; 같은 변수를 잠긴. &lt;code&gt;cond_wait&lt;/code&gt; 가 차단 된 변수 는 &lt;code&gt;cond_wait&lt;/code&gt; 가 충족 된 후 다시 잠 깁니다 . 동일한 변수에 여러 스레드 &lt;code&gt;cond_wait&lt;/code&gt; 가있는 경우 하나를 제외한 모든 스레드 가 변수에 대한 잠금을 다시 얻기 위해 대기 중을 다시 차단합니다. (따라서 동기화에 &lt;code&gt;cond_wait&lt;/code&gt; 만 사용하는 경우 가능한 빨리 잠금을 해제하십시오.)</target>
        </trans-unit>
        <trans-unit id="ad78498a67881045948d88db7f3bfb4f745feb3d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cond_wait&lt;/code&gt; function takes a &lt;b&gt;locked&lt;/b&gt; variable as a parameter, unlocks the variable, and blocks until another thread does a &lt;code&gt;cond_signal&lt;/code&gt; or &lt;code&gt;cond_broadcast&lt;/code&gt; for that same locked variable. The variable that &lt;code&gt;cond_wait&lt;/code&gt; blocked on is relocked after the &lt;code&gt;cond_wait&lt;/code&gt; is satisfied. If there are multiple threads &lt;code&gt;cond_wait&lt;/code&gt;ing on the same variable, all but one will reblock waiting to re-acquire the lock on the variable. (So if you're only using &lt;code&gt;cond_wait&lt;/code&gt; for synchronization, give up the lock as soon as possible.)</source>
          <target state="translated">&lt;code&gt;cond_wait&lt;/code&gt; 기능은 얻어 &lt;b&gt;잠긴&lt;/b&gt; 다른 스레드가 수행 될 때까지 매개 변수로 변수가 변수의 잠금을 해제하고, 블록 &lt;code&gt;cond_signal&lt;/code&gt; 또는 &lt;code&gt;cond_broadcast&lt;/code&gt; 같은 변수를 잠긴. &lt;code&gt;cond_wait&lt;/code&gt; 가 차단 된 변수 는 &lt;code&gt;cond_wait&lt;/code&gt; 가 충족 된 후 다시 잠 깁니다 . 동일한 변수에 &lt;code&gt;cond_wait&lt;/code&gt; ing 하는 여러 스레드가있는 경우 하나를 제외한 모든 스레드 가 변수에 대한 잠금을 다시 획득하기 위해 대기하는 것을 다시 차단합니다. (따라서 동기화를 위해 &lt;code&gt;cond_wait&lt;/code&gt; 만 사용하는 경우 가능한 한 빨리 잠금을 해제하십시오.)</target>
        </trans-unit>
        <trans-unit id="c05e65092ed5c30b3ec99766dc7198ef2d697366" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;condition&lt;/code&gt; can have several forms. The first form is simply an integer in parentheses &lt;code&gt;(integer)&lt;/code&gt; . It is true if the corresponding backreference &lt;code&gt;\integer&lt;/code&gt; matched earlier in the regexp. The same thing can be done with a name associated with a capture group, written as &lt;code&gt;(&amp;lt;name&amp;gt;)&lt;/code&gt; or &lt;code&gt;('name')&lt;/code&gt; . The second form is a bare zero-width assertion &lt;code&gt;(?...)&lt;/code&gt;, either a lookahead, a lookbehind, or a code assertion (discussed in the next section). The third set of forms provides tests that return true if the expression is executed within a recursion (&lt;code&gt;(R)&lt;/code&gt; ) or is being called from some capturing group, referenced either by number (&lt;code&gt;(R1)&lt;/code&gt; , &lt;code&gt;(R2)&lt;/code&gt; ,...) or by name (&lt;code&gt;(R&amp;amp;name)&lt;/code&gt; ).</source>
          <target state="translated">&lt;code&gt;condition&lt;/code&gt; 여러 가지 형태를 가질 수있다. 첫 번째 형식은 단순히 괄호 &lt;code&gt;(integer)&lt;/code&gt; 입니다. 해당 역 참조 &lt;code&gt;\integer&lt;/code&gt; 가 정규 표현식의 앞부분과 일치 하면 사실 입니다. 캡처 그룹과 연관된 이름으로 &lt;code&gt;(&amp;lt;name&amp;gt;)&lt;/code&gt; 또는 &lt;code&gt;('name')&lt;/code&gt; 으로 동일한 작업을 수행 할 수 있습니다 . 두 번째 형태는 0 너비의 단정 &lt;code&gt;(?...)&lt;/code&gt; 이며, 미리보기, 뒤쳐보기 또는 코드 주장 (다음 섹션에서 설명)입니다. 세 번째 양식 세트는 표현식이 재귀 ( &lt;code&gt;(R)&lt;/code&gt; ) 내에서 실행 되거나 일부 캡처 그룹에서 호출 된 경우 ( &lt;code&gt;(R1)&lt;/code&gt; , &lt;code&gt;(R2)&lt;/code&gt; , ...) 또는 이름으로 ( &lt;code&gt;(R&amp;amp;name)&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="ad47d7c085885e724ad5ee56f7fe5e436f8b9c0c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;context()&lt;/code&gt; function will always return the current context. If there is already a context active, it will be returned. If there is not an active context, one will be generated. When a context is generated it will default to using the file and line number where the currently running sub was called from.</source>
          <target state="translated">&lt;code&gt;context()&lt;/code&gt; 함수는 항상 현재 컨텍스트를 반환합니다. 이미 활성화 된 컨텍스트가 있으면 반환됩니다. 활성 컨텍스트가 없으면 생성됩니다. 컨텍스트가 생성되면 기본적으로 현재 실행중인 하위가 호출 된 파일 및 줄 번호를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="4ec10fe3aaaca1b55ef86de9fafc8bbe404ebad2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;context()&lt;/code&gt; method is your primary interface into the Test2 framework.</source>
          <target state="translated">&lt;code&gt;context()&lt;/code&gt; 메소드는 Test2를 프레임 워크에 기본 인터페이스입니다.</target>
        </trans-unit>
        <trans-unit id="bf42e706aa15e3b9613116ccaae1bce3997d5965" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;copy&lt;/code&gt; function takes two parameters: a file to copy from and a file to copy to. Either argument may be a string, a FileHandle reference or a FileHandle glob. Obviously, if the first argument is a filehandle of some sort, it will be read from, and if it is a file</source>
          <target state="translated">&lt;code&gt;copy&lt;/code&gt; 에서 복사 할 파일에 복사 할 파일 : 함수는 두 개의 매개 변수를 사용합니다. 인수는 문자열, FileHandle 참조 또는 FileHandle glob 일 수 있습니다. 분명히, 첫 번째 인수가 일종의 파일 핸들 인 경우, 읽을 수 있고 파일 인 경우</target>
        </trans-unit>
        <trans-unit id="bb585d66ac9e0baf39acd70331ff3f0f5eef7b95" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cpp&lt;/code&gt; filter does not apply to the text of the Fred module, only to the text of the file that used it (&lt;code&gt;cpp_test&lt;/code&gt; ). Although the use statement on line 3 will pass through the cpp filter, the module that gets included (&lt;code&gt;Fred&lt;/code&gt; ) will not. The source streams look like this after line 3 has been parsed and before line 4 is parsed:</source>
          <target state="translated">&lt;code&gt;cpp&lt;/code&gt; 필터는 그것을 사용하는 파일 (의 텍스트, 프레드 모듈의 텍스트에 적용되지 않습니다 &lt;code&gt;cpp_test&lt;/code&gt; ). 3 행의 use 문은 cpp 필터를 통과하지만 포함 된 모듈 ( &lt;code&gt;Fred&lt;/code&gt; )은 통과 하지 않습니다. 소스 스트림은 3 행을 구문 분석 한 후 4 행을 구문 분석하기 전에 다음과 같이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="cb5beac8049360b845cf124791fe07ff9a12d34c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cpp&lt;/code&gt; filter does not apply to the text of the Fred module, only to the text of the file that used it (&lt;code&gt;cpp_test&lt;/code&gt;). Although the use statement on line 3 will pass through the cpp filter, the module that gets included (&lt;code&gt;Fred&lt;/code&gt;) will not. The source streams look like this after line 3 has been parsed and before line 4 is parsed:</source>
          <target state="translated">&lt;code&gt;cpp&lt;/code&gt; 필터는 그것을 사용하는 파일 (의 텍스트, 프레드 모듈의 텍스트에 적용되지 않습니다 &lt;code&gt;cpp_test&lt;/code&gt; ). 3 행의 use 문은 cpp 필터를 통과하지만 포함되는 모듈 ( &lt;code&gt;Fred&lt;/code&gt; )은 통과 하지 않습니다. 소스 스트림은 3 행이 구문 분석 된 후 4 행이 구문 분석되기 전에 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3a0e889b0f475939308ccb8373e116461d3751c9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;create()&lt;/code&gt; method takes a reference to a subroutine and creates a new thread that starts executing in the referenced subroutine. Control then passes both to the subroutine and the caller.</source>
          <target state="translated">&lt;code&gt;create()&lt;/code&gt; 메소드는 서브 루틴에 대한 참조를 취하고 참조 서브 루틴의 실행을 시작하기 새로운 쓰레드를 생성한다. 그런 다음 제어는 서브 루틴과 호출자 모두에게 전달합니다.</target>
        </trans-unit>
        <trans-unit id="4daee3058488514b062a77504cbed0c79eee6390" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;crypt&lt;/code&gt; operator uses the &lt;code&gt;sys$hash_password&lt;/code&gt; system service to generate the hashed representation of PLAINTEXT. If USER is a valid username, the algorithm and salt values are taken from that user's UAF record. If it is not, then the preferred algorithm and a salt of 0 are used. The quadword encrypted value is returned as an 8-character string.</source>
          <target state="translated">&lt;code&gt;crypt&lt;/code&gt; 운영자는 사용 &lt;code&gt;sys$hash_password&lt;/code&gt; PLAINTEXT의 해시 표현을 생성하는 시스템 서비스입니다. USER가 유효한 사용자 이름이면 해당 사용자의 UAF 레코드에서 알고리즘 및 솔트 값을 가져옵니다. 그렇지 않은 경우 선호하는 알고리즘과 0의 솔트가 사용됩니다. 쿼드 워드로 암호화 된 값은 8 자 문자열로 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="b3224bd5303e6f5ddff9eaa9e8454f4b95ad9fcd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;curlen&lt;/code&gt; length parameter passed in was too small, and the function was prevented from examining all the necessary bytes.</source>
          <target state="translated">&lt;code&gt;curlen&lt;/code&gt; 전달 길이 매개 변수가 너무 작고, 상기 함수는 모든 필요한 바이트를 검사하는 것을 방지 하였다.</target>
        </trans-unit>
        <trans-unit id="39b2e5dabf98fd166f3cc23d1829d0ea566d66df" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;declare()&lt;/code&gt; method always creates dotted-decimal version objects. When used in a module, you &lt;b&gt;must&lt;/b&gt; put it on the same line as &quot;use version&quot; to ensure that $VERSION is read correctly by PAUSE and installer tools. You should also add 'version' to the 'configure_requires' section of your module metadata file. See instructions in &lt;a href=&quot;ExtUtils::MakeMaker&quot;&gt;ExtUtils::MakeMaker&lt;/a&gt; or &lt;a href=&quot;Module::Build&quot;&gt;Module::Build&lt;/a&gt; for details.</source>
          <target state="translated">&lt;code&gt;declare()&lt;/code&gt; 메소드는 항상 점으로 구분 된 십진수 버전의 개체를 만듭니다. 모듈에서 사용하는 경우, 당신은 &lt;b&gt;해야한다&lt;/b&gt; $ VERSION이 일시 정지 및 설치 도구를 제대로 읽을 수 있도록 &quot;버전을 사용하십시오&quot;와 같은 줄에 넣어. 또한 모듈 메타 데이터 파일의 'configure_requires'섹션에 'version'을 추가해야합니다. 자세한 내용은 &lt;a href=&quot;ExtUtils::MakeMaker&quot;&gt;ExtUtils :: MakeMaker&lt;/a&gt; 또는 &lt;a href=&quot;Module::Build&quot;&gt;Module :: Build의&lt;/a&gt; 지침을 참조 하십시오.</target>
        </trans-unit>
        <trans-unit id="1af1cb7eb6b21f006259e64b150fa56903267e60" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;delete local EXPR&lt;/code&gt; construct can also be used to localize the deletion of array/hash elements to the current block. See &lt;a href=&quot;perlsub#Localized-deletion-of-elements-of-composite-types&quot;&gt;&quot;Localized deletion of elements of composite types&quot; in perlsub&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;delete local EXPR&lt;/code&gt; 구조체는 상기 현재 블록에 배열 / 해시 요소의 삭제를 로컬 화하는데 사용될 수있다. &lt;a href=&quot;perlsub#Localized-deletion-of-elements-of-composite-types&quot;&gt;perlsub의 &quot;복합 유형 요소의 현지화 된 삭제&quot;를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="69524f53f96840e72cc2460d82457b60c364f5a2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;delete local EXPR&lt;/code&gt; construct localizes the deletion to the current block at run time. Until the block exits, elements locally deleted temporarily no longer exist. See &lt;a href=&quot;perlsub#Localized-deletion-of-elements-of-composite-types&quot;&gt;&quot;Localized deletion of elements of composite types&quot; in perlsub&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;delete local EXPR&lt;/code&gt; 구조는 실행시 현재 블록 삭제를 지역화. 블록이 종료 될 때까지 로컬에서 일시적으로 삭제 된 요소는 더 이상 존재하지 않습니다. &lt;a href=&quot;perlsub#Localized-deletion-of-elements-of-composite-types&quot;&gt;perlsub의 &quot;복합 유형 요소의 현지화 된 삭제&quot;를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="30b3d6c14b075946962dafa1dc3a2886740f908a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;diagnostics&lt;/code&gt; Pragma</source>
          <target state="translated">&lt;code&gt;diagnostics&lt;/code&gt; 에서 Pragma</target>
        </trans-unit>
        <trans-unit id="086b0e345be46fb23c5d4022bc1b3516ac49d7c2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;display_format&lt;/code&gt; class method and the corresponding &lt;code&gt;display_format&lt;/code&gt; object method can now be called using a parameter hash instead of just a one parameter.</source>
          <target state="translated">&lt;code&gt;display_format&lt;/code&gt; 의 클래스 메소드와 해당 &lt;code&gt;display_format&lt;/code&gt; 의 객체 메소드는 이제 매개 변수 해시 대신 하나의 매개 변수를 사용하여 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a9abe66ed186f7fcb344af8814b57766600779f0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;do {}&lt;/code&gt; construct isn't a real loop that you can use loop control on.</source>
          <target state="translated">&lt;code&gt;do {}&lt;/code&gt; 구조는에 루프 제어를 사용할 수있는 진짜 루프가 아닙니다.</target>
        </trans-unit>
        <trans-unit id="85937d63d0c2a7155254307de5c15a8dc64cc7fd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;done&lt;/code&gt; method returns true if the thread you're checking has finished, and false otherwise.</source>
          <target state="translated">&lt;code&gt;done&lt;/code&gt; 진정한 메소드가 리턴는 스레드가 당신이있는 거 검사는 그렇지 완료, 거짓 경우.</target>
        </trans-unit>
        <trans-unit id="322d30ea9fcb9b2fb4107fa041a490d3eef3fbe8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;dontfrag&lt;/code&gt; argument sets the IP_DONTFRAG bit, but note that IP_DONTFRAG is not yet defined by Socket, and not available on many systems. Then it is ignored. On linux it also sets IP_MTU_DISCOVER to IP_PMTUDISC_DO but need we don't chunk oversized packets. You need to set $data_size manually.</source>
          <target state="translated">&lt;code&gt;dontfrag&lt;/code&gt; 의 인수는 IP_DONTFRAG 아직 소켓에 의해 정의되지 않은 많은 시스템에서 사용할 수 없습니다 있다는 IP_DONTFRAG 비트,하지만 메모를 설정합니다. 그런 다음 무시됩니다. Linux에서는 IP_MTU_DISCOVER를 IP_PMTUDISC_DO로 설정하지만 크기가 큰 패킷을 청크하지 않아도됩니다. $ data_size를 수동으로 설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="5c42a2b150a081cef9d9a1db39370eb144f13339" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;down&lt;/code&gt; method decreases the semaphore's count by the specified number (which must be an integer &amp;gt;= 1), or by one if no number is specified.</source>
          <target state="translated">&lt;code&gt;down&lt;/code&gt; 있어서 수가 지정되지 않은 경우, 또는 하나 (정수&amp;gt; = 1이어야 함)에 의해 지정된 세마포어의 카운트를 감소한다.</target>
        </trans-unit>
        <trans-unit id="1d986e9044d0332c0e0b20d1b476092f758b1763" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;down_force&lt;/code&gt; method decreases the semaphore's count by the specified number (which must be an integer &amp;gt;= 1), or by one if no number is specified. This method does not block, and may cause the semaphore's count to drop below zero.</source>
          <target state="translated">&lt;code&gt;down_force&lt;/code&gt; 에 있어서 수가 지정되지 않은 경우, 또는 하나 (정수&amp;gt; = 1이어야 함)에 의해 지정된 세마포어의 카운트를 감소한다. 이 방법은 차단되지 않으며 세마포어 수가 0 미만으로 떨어질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="59032671c2f862c61987094dab4187139af577bf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;down_nb&lt;/code&gt; method attempts to decrease the semaphore's count by the specified number (which must be an integer &amp;gt;= 1), or by one if no number is specified.</source>
          <target state="translated">&lt;code&gt;down_nb&lt;/code&gt; 의 방법 시도 수가 지정되지 않은 경우, 또는 하나 (정수&amp;gt; = 1이어야 함)에 의해 지정된 세마포어의 카운트를 감소한다.</target>
        </trans-unit>
        <trans-unit id="ad817bd0c55a8a17c45e80be5bfb80185a6f0a13" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;down_timed&lt;/code&gt; method attempts to decrease the semaphore's count by 1 or by the specified number within the specified timeout period given in seconds (which must be an integer &amp;gt;= 0).</source>
          <target state="translated">&lt;code&gt;down_timed&lt;/code&gt; 방법 시도 (정수&amp;gt; = 0이어야 함) 초 단위로 지정된 타임 아웃 기간 내에 1 또는 지정된 수 세마포어의 카운트를 감소한다.</target>
        </trans-unit>
        <trans-unit id="81b4509e2a48be8cd2c584657729b851defbc375" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;each()&lt;/code&gt; operator can be a bit tricky though. You can't add or delete keys of the hash while you're using it without possibly skipping or re-processing some pairs after Perl internally rehashes all of the elements. Additionally, a hash has only one iterator, so if you mix &lt;code&gt;keys&lt;/code&gt;, &lt;code&gt;values&lt;/code&gt;, or &lt;code&gt;each&lt;/code&gt; on the same hash, you risk resetting the iterator and messing up your processing. See the &lt;code&gt;each&lt;/code&gt; entry in &lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt; for more details.</source>
          <target state="translated">&lt;code&gt;each()&lt;/code&gt; 연산자는 비록 까다로울 수있다. Perl이 내부적으로 모든 요소를 ​​다시 해시 한 후 일부 쌍을 건너 뛰거나 다시 처리하지 않고는 사용하는 동안 해시의 키를 추가하거나 삭제할 수 없습니다. 또한 해시에는 반복기가 하나만 있으므로 동일한 해시에서 &lt;code&gt;keys&lt;/code&gt; , &lt;code&gt;values&lt;/code&gt; 또는 &lt;code&gt;each&lt;/code&gt; 을 혼합 하면 반복기를 재설정하고 처리를 엉망으로 만들 위험이 있습니다. 자세한 내용은 &lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt; 의 &lt;code&gt;each&lt;/code&gt; 항목 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="9eb0881abe1e42d6f6890023e371e6cf04aeaeaa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;each&lt;/code&gt; operator returns the pairs in apparently random order, so if ordering matters to you, you'll have to stick with the &lt;code&gt;keys&lt;/code&gt; method.</source>
          <target state="translated">&lt;code&gt;each&lt;/code&gt; 당신에게 주문 사항, 당신은 고수해야합니다 그렇다면 운영자는 분명히 임의의 순서로 쌍을 반환 &lt;code&gt;keys&lt;/code&gt; 방법.</target>
        </trans-unit>
        <trans-unit id="ac628ac906a6e8c64ae1a2404030120f69cfb8c8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;else&lt;/code&gt; branch should be used for the really ultimate fallback, not for code specific to some platform.</source>
          <target state="translated">&lt;code&gt;else&lt;/code&gt; 지점은하지 어떤 플랫폼 코드의 특정을 위해, 정말 궁극적 인 대체를 위해 사용되어야한다.</target>
        </trans-unit>
        <trans-unit id="48ce45b8c5dc5a90ffb8cc26e428eb8e7134ca2e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;eogc&lt;/code&gt; flags are stripped out before being passed to the comp routine. The regex engine does not need to know if any of these are set, as those flags should only affect what Perl does with the pattern and its match variables, not how it gets compiled and executed.</source>
          <target state="translated">&lt;code&gt;eogc&lt;/code&gt; 플래그는 완 루틴에 전달되기 전에 제거됩니다. 정규식 엔진은 이러한 플래그가 설정되어 있는지 알 필요가 없습니다. 이러한 플래그는 Perl이 패턴 및 해당 일치 변수로 수행하는 작업에만 영향을 미치며 컴파일 및 실행 방법에는 영향을 미치지 않기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="5dcaf0131993c2fe373ceb68066111b75397ce84" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;equal()&lt;/code&gt; method takes two thread objects and returns true if the objects represent the same thread, and false if they don't.</source>
          <target state="translated">&lt;code&gt;equal()&lt;/code&gt; 메소드는, 그렇지 않은 경우 오브젝트가 같은 스레드를 나타내며, 거짓 경우는 true, 두 개의 스레드 객체 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="49890ceef3269a9849305b4a6f9b549bc3f0c714" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;errno&lt;/code&gt; value is optional. In versions of &lt;code&gt;autodie::exception&lt;/code&gt; 1.99 and earlier the code would try to automatically use the current value of &lt;code&gt;$!&lt;/code&gt;, but this was unreliable and is no longer supported.</source>
          <target state="translated">&lt;code&gt;errno&lt;/code&gt; 값은 선택 사항입니다. 버전에서는 &lt;code&gt;autodie::exception&lt;/code&gt; 1.99 및 이전 버전의 코드 자동의 현재 값을 사용하려고 할 것입니다 &lt;code&gt;$!&lt;/code&gt; , 그러나 이것은 신뢰할 수 없으며 더 이상 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="bd5c1caef84073c78e4b57183c72209f1a463dd1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;eval&lt;/code&gt; method wrapped an &lt;code&gt;eval&lt;/code&gt; around a &lt;code&gt;join&lt;/code&gt;, and so waited for a thread to exit, passing along any values the thread might have returned and placing any errors into &lt;code&gt;$@&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;eval&lt;/code&gt; 방법은 포장 &lt;code&gt;eval&lt;/code&gt; A는 주위 &lt;code&gt;join&lt;/code&gt; 스레드가 돌아왔다 수있는 값을 함께 전달하고에 오류를 배치, 그래서 출구 스레드 기다렸다 &lt;code&gt;$@&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d80af1149bc4ce69fb624da74e40c6a5dafd9409" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;examples&lt;/code&gt; sub-directory has copies of all these filters implemented both as</source>
          <target state="translated">&lt;code&gt;examples&lt;/code&gt; 하위 디렉토리는 모든 필터의 사본으로 모두 구현이</target>
        </trans-unit>
        <trans-unit id="1c3c6e01b0d3bd33a4ed4055dd31b80304ebc9d8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;exec&lt;/code&gt; function's job is to turn your process into another command and never to return. If that's not what you want to do, don't use &lt;code&gt;exec&lt;/code&gt;. :)</source>
          <target state="translated">&lt;code&gt;exec&lt;/code&gt; 함수의 작업은 다른 명령에 결코 반환에 프로세스를 설정하는 것입니다. 그것이 당신이 원하는 것이 아니라면 &lt;code&gt;exec&lt;/code&gt; 를 사용하지 마십시오 . :)</target>
        </trans-unit>
        <trans-unit id="cc84f2c59070bf508814fa3ebed34092fe0cca71" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;experimental&lt;/code&gt; pragma exists to combine the required incantations into a single interface stable across releases of perl. For every experimental feature, this should enable the feature and silence warnings for the enclosing lexical scope:</source>
          <target state="translated">&lt;code&gt;experimental&lt;/code&gt; pragma는 펄의 릴리스에 따라 단일 인터페이스 안정에 필요한 주술을 결합하기 위해 존재한다. 모든 실험적 기능에 대해 포함하는 어휘 범위에 대한 기능 및 무음 경고를 활성화해야합니다.</target>
        </trans-unit>
        <trans-unit id="472a34a62dd6bdcf8df5e53d452c5f9dca79546f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;extra_mappings&lt;/code&gt; arguments takes a hash ref with the same type of structure as described in &lt;a href=&quot;CPAN::Meta::Spec&quot;&gt;CPAN::Meta::Spec&lt;/a&gt;, except with its values as one of the &lt;a href=&quot;#MERGE-STRATEGIES&quot;&gt;defined merge strategies&lt;/a&gt; or a code ref to a merging function.</source>
          <target state="translated">&lt;code&gt;extra_mappings&lt;/code&gt; 에서 의 설명대로 인수 구조의 동일한 유형의 해시 REF 소요 &lt;a href=&quot;CPAN::Meta::Spec&quot;&gt;CPAN :: 메타 :: 규격&lt;/a&gt; 의 하나의 값을 갖는 것을 제외하고, &lt;a href=&quot;#MERGE-STRATEGIES&quot;&gt;정의 병합 전략&lt;/a&gt; 또는 병합 기능 코드 (REF).</target>
        </trans-unit>
        <trans-unit id="a371087f59ef9684a3303b0318405ae011e9ec34" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;extract_delimited&lt;/code&gt; function formalizes the common idiom of extracting a single-character-delimited substring from the start of a string. For example, to extract a single-quote delimited string, the following code is typically used:</source>
          <target state="translated">&lt;code&gt;extract_delimited&lt;/code&gt; 함수는 문자열의 시작에서 단일 문자로 구분 된 문자열을 추출하는 일반적인 관용구 공식화. 예를 들어, 작은 따옴표로 구분 된 문자열을 추출하려면 일반적으로 다음 코드가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="01013bd276b6d8fe2331fe338d632601823957b8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;extract_multiple&lt;/code&gt; subroutine takes a string to be processed and a list of extractors (subroutines or regular expressions) to apply to that string.</source>
          <target state="translated">&lt;code&gt;extract_multiple&lt;/code&gt; 루틴은 스트링에 적용 처리 될 문자열 및 추출기 (서브 루틴 또는 일반 식)의 목록이 걸린다.</target>
        </trans-unit>
        <trans-unit id="0234e9715d2d58dfe4e40eada785cc5d3ba85e48" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;fail&lt;/code&gt; option indicates the action to be taken if a matching end tag is not encountered (i.e. before the end of the string or some &lt;code&gt;reject&lt;/code&gt; pattern matches). By default, a failure to match a closing tag causes &lt;code&gt;extract_tagged&lt;/code&gt; to immediately fail.</source>
          <target state="translated">&lt;code&gt;fail&lt;/code&gt; 옵션은 일치하는 종료 태그가 발견되지 않는 경우 수행 할 작업을 나타냅니다 (즉, 문자열의 끝 또는 일부 이전에 &lt;code&gt;reject&lt;/code&gt; 패턴 일치). 기본적으로 닫는 태그와 일치 하지 않으면 &lt;code&gt;extract_tagged&lt;/code&gt; 가 즉시 실패합니다.</target>
        </trans-unit>
        <trans-unit id="7fdb136937ca0405fd0e09f20f2a40c4f858261d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;failed&lt;/code&gt; command reports all distributions that failed on one of &lt;code&gt;make&lt;/code&gt; , &lt;code&gt;test&lt;/code&gt; or &lt;code&gt;install&lt;/code&gt; for some reason in the currently running shell session.</source>
          <target state="translated">&lt;code&gt;failed&lt;/code&gt; 명령 중 하나에 실패하는 모든 배포판보고 &lt;code&gt;make&lt;/code&gt; , &lt;code&gt;test&lt;/code&gt; 또는 &lt;code&gt;install&lt;/code&gt; 현재 실행중인 쉘 세션에서 어떤 이유를.</target>
        </trans-unit>
        <trans-unit id="5ad80da9f3017cad820985c782b83967ca308a28" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;family&lt;/code&gt; hint to getaddrinfo(), or the family of the socket address passed to getnameinfo() is not supported.</source>
          <target state="translated">getaddrinfo ()에 대한 &lt;code&gt;family&lt;/code&gt; 힌트 또는 getnameinfo ()에 전달 된 소켓 주소 계열은 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="acd804f7e1462316c1795d1b040a724ba816aee2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;fetch&lt;/code&gt; command just updates the &lt;code&gt;camel&lt;/code&gt; refs, as the objects themselves should have been fetched when pulling from &lt;code&gt;origin&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;fetch&lt;/code&gt; 명령은 바로 업데이트 &lt;code&gt;camel&lt;/code&gt; (가)에서 당겨 때 자신이 가져온 했어야 객체로, 심판을 &lt;code&gt;origin&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="aaa028e0e10b907654ea97ca6e2e56dbd54cf34e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;fetch&lt;/code&gt; utility is available on FreeBSD. NetBSD and Dragonfly BSD may also have it from &lt;code&gt;pkgsrc&lt;/code&gt; . We only check for &lt;code&gt;fetch&lt;/code&gt; on those three platforms.</source>
          <target state="translated">&lt;code&gt;fetch&lt;/code&gt; 유틸리티는 FreeBSD를 사용할 수 있습니다. NetBSD와 Dragonfly BSD는 &lt;code&gt;pkgsrc&lt;/code&gt; 에서도 사용할 수 있습니다 . 이 세 가지 플랫폼 에서만 &lt;code&gt;fetch&lt;/code&gt; 를 확인 합니다.</target>
        </trans-unit>
        <trans-unit id="88909127a630a0e568460e4ef567fdf6cebea70a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;fetch&lt;/code&gt; utility is available on FreeBSD. NetBSD and Dragonfly BSD may also have it from &lt;code&gt;pkgsrc&lt;/code&gt;. We only check for &lt;code&gt;fetch&lt;/code&gt; on those three platforms.</source>
          <target state="translated">&lt;code&gt;fetch&lt;/code&gt; 유틸리티는 FreeBSD를 사용할 수 있습니다. NetBSD와 Dragonfly BSD는 &lt;code&gt;pkgsrc&lt;/code&gt; 에서 가져올 수도 있습니다 . 우리는 이 세 가지 플랫폼 에서만 &lt;code&gt;fetch&lt;/code&gt; 를 확인 합니다.</target>
        </trans-unit>
        <trans-unit id="9e227d5e7190288807dd09d5662a48f3b24c6088" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;fforce&lt;/code&gt; pragma is a variant that emulates a &lt;code&gt;force get&lt;/code&gt; which erases the entire memory followed by the action specified, effectively restarting the whole get/make/test/install procedure from scratch.</source>
          <target state="translated">&lt;code&gt;fforce&lt;/code&gt; 프라그는 에뮬레이트하는 변종 &lt;code&gt;force get&lt;/code&gt; 전체 메모리가 효과적으로 처음부터 절차를 설치 / 전체 GET / 메이크업 / 테스트를 다시 시작 지정한 작업 다음에 삭제합니다.</target>
        </trans-unit>
        <trans-unit id="67136aec5c09887a5fbdbeaf79603ace225d72fb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;fields&lt;/code&gt; pragma enables compile-time and run-time verified class fields.</source>
          <target state="translated">&lt;code&gt;fields&lt;/code&gt; pragma는 컴파일 시간과 런타임 클래스 필드를 확인 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1da25c8608c050c137eec0fcb8b96dfa9d530dcf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;filename&lt;/code&gt; , &lt;code&gt;flags&lt;/code&gt; and &lt;code&gt;mode&lt;/code&gt; parameters are the direct equivalent of their dbopen() counterparts. The final parameter $DB_HASH performs the function of both the &lt;code&gt;type&lt;/code&gt; and &lt;code&gt;openinfo&lt;/code&gt; parameters in dbopen().</source>
          <target state="translated">&lt;code&gt;filename&lt;/code&gt; , &lt;code&gt;flags&lt;/code&gt; 및 &lt;code&gt;mode&lt;/code&gt; 매개 변수는 dbopen () 대응의 직접적인 동일합니다. 최종 매개 변수 $ DB_HASH 는 dbopen ()에서 &lt;code&gt;type&lt;/code&gt; 및 &lt;code&gt;openinfo&lt;/code&gt; 매개 변수 의 기능을 수행합니다 .</target>
        </trans-unit>
        <trans-unit id="d57b7b57482f3e0bdad4f727d65fbd7d3f8d08ef" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;filename&lt;/code&gt;, &lt;code&gt;flags&lt;/code&gt; and &lt;code&gt;mode&lt;/code&gt; parameters are the direct equivalent of their dbopen() counterparts. The final parameter $DB_HASH performs the function of both the &lt;code&gt;type&lt;/code&gt; and &lt;code&gt;openinfo&lt;/code&gt; parameters in dbopen().</source>
          <target state="translated">&lt;code&gt;filename&lt;/code&gt; , &lt;code&gt;flags&lt;/code&gt; 및 &lt;code&gt;mode&lt;/code&gt; 매개 변수는 dbopen () 대응의 직접적인 동일합니다. 마지막 매개 변수 $ DB_HASH 는 dbopen ()에서 &lt;code&gt;type&lt;/code&gt; 및 &lt;code&gt;openinfo&lt;/code&gt; 매개 변수 의 기능을 수행합니다 .</target>
        </trans-unit>
        <trans-unit id="711049b66f21cfb21f8abf404e302b9cb973606c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;fileparse()&lt;/code&gt; routine divides a file path into its $dirs, $filename and (optionally) the filename $suffix.</source>
          <target state="translated">&lt;code&gt;fileparse()&lt;/code&gt; 루틴 분할의 $의 DIRS에 파일 경로, $ 파일 이름 (선택 사항) 파일 이름 $ 접미사.</target>
        </trans-unit>
        <trans-unit id="2894a076625213bf8472ba18a1068c216ff2972b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;finalize&lt;/code&gt; method is always the last thing called on the formatter,</source>
          <target state="translated">&lt;code&gt;finalize&lt;/code&gt; 방법은 항상 포맷에 마지막으로 호출 일</target>
        </trans-unit>
        <trans-unit id="2c20640b93e6e1928bfa39a7352c6c3efb0f1519" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;flags&lt;/code&gt; argument can have &lt;code&gt;UNI_DISPLAY_ISPRINT&lt;/code&gt; set to display &lt;code&gt;isPRINT()&lt;/code&gt;able characters as themselves, &lt;code&gt;UNI_DISPLAY_BACKSLASH&lt;/code&gt; to display the &lt;code&gt;\\[nrfta\\]&lt;/code&gt; as the backslashed versions (like &lt;code&gt;&quot;\n&quot;&lt;/code&gt;) (&lt;code&gt;UNI_DISPLAY_BACKSLASH&lt;/code&gt; is preferred over &lt;code&gt;UNI_DISPLAY_ISPRINT&lt;/code&gt; for &lt;code&gt;&quot;\\&quot;&lt;/code&gt;). &lt;code&gt;UNI_DISPLAY_QQ&lt;/code&gt; (and its alias &lt;code&gt;UNI_DISPLAY_REGEX&lt;/code&gt;) have both &lt;code&gt;UNI_DISPLAY_BACKSLASH&lt;/code&gt; and &lt;code&gt;UNI_DISPLAY_ISPRINT&lt;/code&gt; turned on.</source>
          <target state="translated">&lt;code&gt;flags&lt;/code&gt; 인수가 가질 수있는 &lt;code&gt;UNI_DISPLAY_ISPRINT&lt;/code&gt; 가 표시되도록 설정 &lt;code&gt;isPRINT()&lt;/code&gt; , 그 자체로 할 문자를 &lt;code&gt;UNI_DISPLAY_BACKSLASH&lt;/code&gt; 를 디스플레이에 &lt;code&gt;\\[nrfta\\]&lt;/code&gt; 백 슬래쉬 버전으로 (같은 &lt;code&gt;&quot;\n&quot;&lt;/code&gt; ) ( &lt;code&gt;UNI_DISPLAY_BACKSLASH&lt;/code&gt; 이 선호된다 &lt;code&gt;UNI_DISPLAY_ISPRINT&lt;/code&gt; 에 대해 &lt;code&gt;&quot;\\&quot;&lt;/code&gt; ). &lt;code&gt;UNI_DISPLAY_QQ&lt;/code&gt; (및 별칭 &lt;code&gt;UNI_DISPLAY_REGEX&lt;/code&gt; )에는 &lt;code&gt;UNI_DISPLAY_BACKSLASH&lt;/code&gt; 및 &lt;code&gt;UNI_DISPLAY_ISPRINT&lt;/code&gt; 가 모두 설정 되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="602708ab2289d55123d1e5cfa483278e5dc2b095" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;flags&lt;/code&gt; argument can have UNI_DISPLAY_ISPRINT set to display isPRINT()able characters as themselves, UNI_DISPLAY_BACKSLASH to display the \\[nrfta\\] as the backslashed versions (like '\n') (UNI_DISPLAY_BACKSLASH is preferred over UNI_DISPLAY_ISPRINT for \\). UNI_DISPLAY_QQ (and its alias UNI_DISPLAY_REGEX) have both UNI_DISPLAY_BACKSLASH and UNI_DISPLAY_ISPRINT turned on.</source>
          <target state="translated">&lt;code&gt;flags&lt;/code&gt; 인수 (UNI_DISPLAY_BACKSLASH는 \\에 대한 UNI_DISPLAY_ISPRINT 선호한다) ( '\ n'을 같은) 백 슬래쉬 버전으로 \\ [nrfta \\]을 표시 자체로 UNI_DISPLAY_BACKSLASH을 isPRINT () 수있는 문자를 표시 할 수 UNI_DISPLAY_ISPRINT 세트를 가질 수 있습니다. UNI_DISPLAY_QQ (및 별명 UNI_DISPLAY_REGEX)에는 UNI_DISPLAY_BACKSLASH 및 UNI_DISPLAY_ISPRINT가 설정되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="45b476535dde9c4df2a5ce21abd7562e13744b06" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;flags&lt;/code&gt; argument is as in &lt;a href=&quot;#pv_uni_display&quot;&gt;&quot;pv_uni_display&quot;&lt;/a&gt;().</source>
          <target state="translated">&lt;code&gt;flags&lt;/code&gt; 인수가 같이있다 &lt;a href=&quot;#pv_uni_display&quot;&gt;&quot;pv_uni_display&quot;&lt;/a&gt; ().</target>
        </trans-unit>
        <trans-unit id="db2dfe02c9ae062f42652141438a9f9714c71cea" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;flags&lt;/code&gt; argument is as in &lt;a href=&quot;#pv_uni_display&quot;&gt;pv_uni_display&lt;/a&gt;().</source>
          <target state="translated">&lt;code&gt;flags&lt;/code&gt; 인수가 같이있다 &lt;a href=&quot;#pv_uni_display&quot;&gt;pv_uni_display&lt;/a&gt; ().</target>
        </trans-unit>
        <trans-unit id="99738c77e0f1da5722068673963c4a8f215d0b31" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;flags&lt;/code&gt; can be:</source>
          <target state="translated">&lt;code&gt;flags&lt;/code&gt; 할 수있다 :</target>
        </trans-unit>
        <trans-unit id="cefd6d4dfafa940aea51a92bdcb195eed2de69a7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;flags&lt;/code&gt; method returned the flags for the thread - an integer value corresponding to the internal flags for the thread.</source>
          <target state="translated">&lt;code&gt;flags&lt;/code&gt; 에있어서, 상기 스레드에 대한 플래그를 리턴 - 정수 값은 스레드에 대한 내부 플래그에 대응.</target>
        </trans-unit>
        <trans-unit id="8425d60192539121edf35ab62976eb395bc2a704" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;flags&lt;/code&gt; option is optional and defaults to &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;flags&lt;/code&gt; 옵션을 선택하고 기본값 인 &lt;code&gt;0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6cca4f06215bca47eddea026c40afe1b9a43be1d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;flags&lt;/code&gt; parameter can be used to determine which of these operations the callbacks should respond to. The following flags are currently defined:</source>
          <target state="translated">&lt;code&gt;flags&lt;/code&gt; 매개 변수는 이러한 작업의 콜백에 응답해야 결정하는 데 사용할 수 있습니다. 다음 플래그가 현재 정의되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="459faaa5e3280fee22284d6b094987c77fa7de30" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;flags&lt;/code&gt; parameter in all the</source>
          <target state="translated">&lt;code&gt;flags&lt;/code&gt; 모두의 매개 변수</target>
        </trans-unit>
        <trans-unit id="bfe1865df397f3698f54ec1b600413c38607abed" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;flags&lt;/code&gt; parameter is a bitfield which indicates which of the &lt;code&gt;msixpn&lt;/code&gt; flags the regex was compiled with. It also contains additional info, such as if &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; is in effect.</source>
          <target state="translated">&lt;code&gt;flags&lt;/code&gt; 파라미터의 지시하는 비트 필드이다 &lt;code&gt;msixpn&lt;/code&gt; 의 정규식 컴파일 된 플래그. 또한 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; 이 적용 되는 경우와 같은 추가 정보도 포함 합니다.</target>
        </trans-unit>
        <trans-unit id="6fd73fe1f5c776efd0dba4ac9a66a7649c62b563" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;flags&lt;/code&gt; parameter is a bitfield which indicates which of the &lt;code&gt;msixpn&lt;/code&gt; flags the regex was compiled with. It also contains additional info, such as if &lt;code&gt;use locale&lt;/code&gt; is in effect.</source>
          <target state="translated">&lt;code&gt;flags&lt;/code&gt; 파라미터의 지시하는 비트 필드이다 &lt;code&gt;msixpn&lt;/code&gt; 의 정규식 컴파일 된 플래그. 또한 &lt;code&gt;use locale&lt;/code&gt; 이 유효 한지 여부와 같은 추가 정보도 포함 합니다.</target>
        </trans-unit>
        <trans-unit id="600009146ad8caeb28aa4266bb11bcc93c6081be" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;flags&lt;/code&gt; parameter is reserved for future use, and must always be zero.</source>
          <target state="translated">&lt;code&gt;flags&lt;/code&gt; 매개 변수는 향후 사용을 위해 예약하고, 항상 0이어야합니다.</target>
        </trans-unit>
        <trans-unit id="41b4f74a7487e51319a762323a60ac4f87b549c7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;flags&lt;/code&gt; parameter is reserved for future use. Currently it is only used by perl internally, so extensions should always pass zero.</source>
          <target state="translated">&lt;code&gt;flags&lt;/code&gt; 매개 변수는 향후 사용을 위해 예약되어 있습니다. 현재는 내부적으로 펄에서만 사용되므로 확장은 항상 0을 전달해야합니다.</target>
        </trans-unit>
        <trans-unit id="b886ddfa56e0b9ebfe8f2070d41589a1086768dd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;flush_cache()&lt;/code&gt; function will raise a run-time error unless the tied package provides a &lt;code&gt;CLEAR&lt;/code&gt; method.</source>
          <target state="translated">&lt;code&gt;flush_cache()&lt;/code&gt; 동점 패키지가 제공하지 않는 기능은 런타임 오류가 발생합니다 &lt;code&gt;CLEAR&lt;/code&gt; 의 방법을.</target>
        </trans-unit>
        <trans-unit id="124f73ccb9aad8a6d48616fcbcb3b56af5616b10" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;for(each)&lt;/code&gt; modifier is an iterator: it executes the statement once for each item in the LIST (with &lt;code&gt;$_&lt;/code&gt; aliased to each item in turn). There is no syntax to specify a C-style for loop or a lexically scoped iteration variable in this form.</source>
          <target state="translated">&lt;code&gt;for(each)&lt;/code&gt; 수정은 반복자이다 : 그것은 한 번 (과 목록의 각 항목에 대한 문을 실행 &lt;code&gt;$_&lt;/code&gt; 차례로 각 항목에 별칭). 이 형식에는 C 스타일 for 루프 또는 어휘 범위 반복 변수를 지정하는 구문이 없습니다.</target>
        </trans-unit>
        <trans-unit id="8ee8bf6c49cb0d370b573c84b81eeff22daa626c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;force&lt;/code&gt; pragma may precede another command (currently: &lt;code&gt;get&lt;/code&gt; , &lt;code&gt;make&lt;/code&gt; , &lt;code&gt;test&lt;/code&gt; , or &lt;code&gt;install&lt;/code&gt; ) to execute the command from scratch and attempt to continue past certain errors. See the section below on the &lt;code&gt;force&lt;/code&gt; and the &lt;code&gt;fforce&lt;/code&gt; pragma.</source>
          <target state="translated">&lt;code&gt;force&lt;/code&gt; 다른 명령에 선행 할 수있다 pragma는 (현재 : &lt;code&gt;get&lt;/code&gt; , &lt;code&gt;make&lt;/code&gt; , &lt;code&gt;test&lt;/code&gt; 또는 &lt;code&gt;install&lt;/code&gt; ) 처음부터 명령을 실행하고 과거의 특정 오류를 계속 시도 할 수 있습니다. &lt;code&gt;force&lt;/code&gt; 과 &lt;code&gt;fforce&lt;/code&gt; pragma 에 대해서는 아래 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="34f4026c135fb9c9e701839369f22ab72881f9e4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;foreach&lt;/code&gt; is the non-experimental way to set a topicalizer. If you wish to use the highly experimental &lt;code&gt;given&lt;/code&gt; , that could be written like this:</source>
          <target state="translated">&lt;code&gt;foreach&lt;/code&gt; topicalizer을 설정하는 비 실험 방법입니다. &lt;code&gt;given&lt;/code&gt; 높은 실험을 사용하려면 다음과 같이 쓸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8adf50b4a12807b9b440b3e9dd59f76950784e30" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;foreach&lt;/code&gt; is the non-experimental way to set a topicalizer. If you wish to use the highly experimental &lt;code&gt;given&lt;/code&gt;, that could be written like this:</source>
          <target state="translated">&lt;code&gt;foreach&lt;/code&gt; topicalizer을 설정하는 비 실험 방법입니다. 매우 실험적인 &lt;code&gt;given&lt;/code&gt; 을 사용하려면 다음과 같이 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="de226564415ab69d6441fa2857763cf2ce5fdae3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;foreach&lt;/code&gt; keyword is actually a synonym for the &lt;code&gt;for&lt;/code&gt; keyword, so you can use either. If VAR is omitted, &lt;code&gt;$_&lt;/code&gt; is set to each value.</source>
          <target state="translated">&lt;code&gt;foreach&lt;/code&gt; 는 키워드는 실제로 동의어입니다 &lt;code&gt;for&lt;/code&gt; 당신도 사용할 수 있도록, 키워드. VAR을 생략하면 &lt;code&gt;$_&lt;/code&gt; 가 각 값으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="eb1c9008000e928d5125162497dd929b484cbedf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;foreach&lt;/code&gt; keyword is actually a synonym for the &lt;code&gt;for&lt;/code&gt; keyword. See &lt;code&gt;&lt;a href=&quot;perlsyn#Foreach-Loops&quot;&gt;&quot;Foreach Loops&quot; in perlsyn&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;foreach&lt;/code&gt; 는 키워드는 실제로 동의어입니다 &lt;code&gt;for&lt;/code&gt; 키워드. &lt;code&gt;&lt;a href=&quot;perlsyn#Foreach-Loops&quot;&gt;&quot;Foreach Loops&quot; in perlsyn&lt;/a&gt;&lt;/code&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="375dcc1d1d2f6f42cca4896811ca8fdfa2d3b491" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;foreach&lt;/code&gt; keyword is actually a synonym for the &lt;code&gt;for&lt;/code&gt; keyword. See &lt;code&gt;&lt;a href=&quot;perlsyn#Foreach-Loops&quot;&gt;Foreach Loops in perlsyn&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;foreach&lt;/code&gt; 는 키워드는 실제로 동의어입니다 &lt;code&gt;for&lt;/code&gt; 키워드. &lt;code&gt;&lt;a href=&quot;perlsyn#Foreach-Loops&quot;&gt;Foreach Loops in perlsyn&lt;/a&gt;&lt;/code&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b86bb402e5da8037aee4e69efe060f892f194612" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;foreach&lt;/code&gt; loop can also take a reference constructor for its loop variable, though the syntax is limited to one of the following, with an optional &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/state&quot;&gt;state&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; after the backslash:</source>
          <target state="translated">&lt;code&gt;foreach&lt;/code&gt; 구문은 다음 중 하나에 국한되어 있지만 루프가 선택 사양으로, 그 루프 변수에 대한 참조 생성자를 취할 수 &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/state&quot;&gt;state&lt;/a&gt;&lt;/code&gt; , 또는 &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; 백 슬래시 후 :</target>
        </trans-unit>
        <trans-unit id="21bbc47a2581808651eb8a89a9f603b84e2a2657" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;foreach&lt;/code&gt; loop can also take a reference constructor for its loop variable, though the syntax is limited to one of the following, with an optional &lt;code&gt;my&lt;/code&gt;, &lt;code&gt;state&lt;/code&gt;, or &lt;code&gt;our&lt;/code&gt; after the backslash:</source>
          <target state="translated">&lt;code&gt;foreach&lt;/code&gt; 구문은 다음 중 하나에 국한되어 있지만 루프가 선택 사양으로, 그 루프 변수에 대한 참조 생성자를 취할 수 &lt;code&gt;my&lt;/code&gt; , &lt;code&gt;state&lt;/code&gt; , 또는 &lt;code&gt;our&lt;/code&gt; 백 슬래시 후 :</target>
        </trans-unit>
        <trans-unit id="d9c367bfb9bb4dab65fff1b13521d38572d69dfe" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;foreach&lt;/code&gt; loop defaults to scoping its index variable dynamically in the manner of &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt;. However, if the index variable is prefixed with the keyword &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt;, or if there is already a lexical by that name in scope, then a new lexical is created instead. Thus in the loop</source>
          <target state="translated">&lt;code&gt;foreach&lt;/code&gt; 는 루프 디폴트의 방식으로 동적으로 인덱스 변수 범위를 지정하는 &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; . 그러나 색인 변수 앞에 &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; 키워드가 있거나 범위 내에 해당 이름의 어휘가 있으면 새 어휘가 대신 작성됩니다. 따라서 루프에서</target>
        </trans-unit>
        <trans-unit id="fc6d0492eecb0b7b77ecb47ab19f74f65e2c9439" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;foreach&lt;/code&gt; loop defaults to scoping its index variable dynamically in the manner of &lt;code&gt;local&lt;/code&gt;. However, if the index variable is prefixed with the keyword &lt;code&gt;my&lt;/code&gt;, or if there is already a lexical by that name in scope, then a new lexical is created instead. Thus in the loop</source>
          <target state="translated">&lt;code&gt;foreach&lt;/code&gt; 는 루프 디폴트의 방식으로 동적으로 인덱스 변수 범위를 지정하는 &lt;code&gt;local&lt;/code&gt; . 그러나 인덱스 변수에 &lt;code&gt;my&lt;/code&gt; 키워드가 접두사로 붙 거나 범위에 해당 이름의 어휘가 이미있는 경우 새 어휘가 대신 생성됩니다. 따라서 루프에서</target>
        </trans-unit>
        <trans-unit id="a4c4603cb509242d80999a110064359f577c21d6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;foreach&lt;/code&gt; loop iterates over a normal list value and sets the scalar variable VAR to be each element of the list in turn. If the variable is preceded with the keyword &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt;, then it is lexically scoped, and is therefore visible only within the loop. Otherwise, the variable is implicitly local to the loop and regains its former value upon exiting the loop. If the variable was previously declared with &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt;, it uses that variable instead of the global one, but it's still localized to the loop. This implicit localization occurs</source>
          <target state="translated">&lt;code&gt;foreach&lt;/code&gt; 는 루프 정상 값리스트로 반복 스칼라 변수 VAR 설정 차례로리스트의 각 요소한다. 변수 앞에 &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; 키워드가 있으면 변수 범위가 어휘 범위이므로 루프 내에서만 볼 수 있습니다. 그렇지 않으면 변수는 내재적으로 루프에 로컬이며 루프를 종료 할 때 이전 값을 다시 얻습니다. 변수가 이전에 &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; 로 선언 된 경우 전역 변수 대신 해당 변수를 사용하지만 여전히 루프에 지역화되어 있습니다. 이 암시 적 현지화가 발생합니다</target>
        </trans-unit>
        <trans-unit id="d0916d837b24f716ed6d234f4dd39fce8bf3c636" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;foreach&lt;/code&gt; loop iterates over a normal list value and sets the scalar variable VAR to be each element of the list in turn. If the variable is preceded with the keyword &lt;code&gt;my&lt;/code&gt;, then it is lexically scoped, and is therefore visible only within the loop. Otherwise, the variable is implicitly local to the loop and regains its former value upon exiting the loop. If the variable was previously declared with &lt;code&gt;my&lt;/code&gt;, it uses that variable instead of the global one, but it's still localized to the loop. This implicit localization occurs</source>
          <target state="translated">&lt;code&gt;foreach&lt;/code&gt; 는 루프 정상 값리스트로 반복 스칼라 변수 VAR 설정 차례로리스트의 각 요소한다. 변수 앞에 &lt;code&gt;my&lt;/code&gt; 키워드 가 있으면 어휘 범위가 지정되므로 루프 내에서만 볼 수 있습니다. 그렇지 않으면 변수는 루프에 대해 암시 적으로 로컬이고 루프를 종료 할 때 이전 값을 다시 얻습니다. 변수가 이전에 &lt;code&gt;my&lt;/code&gt; 로 선언 된 경우 전역 변수 대신 해당 변수를 사용하지만 여전히 루프로 지역화됩니다. 이 암시 적 지역화가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="bb381f2681e84a2954e18395a958e606ca6cba3a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;frame&lt;/code&gt; option can be used to control the output of frame information. For example, contrast this expression trace:</source>
          <target state="translated">&lt;code&gt;frame&lt;/code&gt; 옵션 프레임 정보의 출력을 제어하는데 이용 될 수있다. 예를 들어,이 표현식 추적을 대조하십시오.</target>
        </trans-unit>
        <trans-unit id="591f72361e30bcbf229773b985f4b81bad64b394" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;gateway&lt;/code&gt; argument is only valid for IPv6, and requires a IPv6 address.</source>
          <target state="translated">&lt;code&gt;gateway&lt;/code&gt; 인수는 IPv6에 대한에만 유효하고, IPv6 주소가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="01af8f56de621025abc07dc645713da63a5fe927" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;gen_delimited_pat&lt;/code&gt; subroutine takes a single (string) argument and &amp;gt; builds a Friedl-style optimized regex that matches a string delimited by any one of the characters in the single argument. For example:</source>
          <target state="translated">&lt;code&gt;gen_delimited_pat&lt;/code&gt; 서브 루틴은 하나의 (문자열) 인수를 받아&amp;gt; 단일 인수의 문자 중 하나에 의해 구분 된 문자열과 일치하는 Friedl의 스타일에 최적화 정규식을 구축합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="617ccfb027c1e5d2773071a87cbcedc95dc112aa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;get_dup&lt;/code&gt; method assists in reading duplicate values from BTREE databases. The method can take the following forms:</source>
          <target state="translated">&lt;code&gt;get_dup&lt;/code&gt; BTREE 데이터베이스에서 중복 값을 읽기의 방법을 도와줍니다. 이 방법은 다음과 같은 형식을 취할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="38757d13de90c9736c762577e50e5a7475bfa2f5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;getname&lt;/code&gt; function returns the file specification associated with a Perl I/O handle. If an error occurs, it returns &lt;code&gt;undef&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;getname&lt;/code&gt; 의 기능은 펄 I / O 핸들과 관련된 파일 스펙을 반환합니다. 오류가 발생하면 &lt;code&gt;undef&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="7ea986ecd3305b94f4546f1c6e3ce692488dd0fb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;getopt()&lt;/code&gt; function is similar, but its argument is a string containing all switches that take an argument. If no argument is provided for a switch, say, &lt;code&gt;&lt;a href=&quot;../functions/y&quot;&gt;y&lt;/a&gt;&lt;/code&gt;, the corresponding &lt;code&gt;$opt_y&lt;/code&gt; will be set to an undefined value. Unspecified switches are silently accepted. Use of &lt;code&gt;getopt()&lt;/code&gt; is not recommended.</source>
          <target state="translated">&lt;code&gt;getopt()&lt;/code&gt; 함수와 유사하지만, 그 인수는 인수를 모든 스위치를 포함하는 문자열이다. 스위치에 인수가 제공되지 않으면 (예 : &lt;code&gt;&lt;a href=&quot;../functions/y&quot;&gt;y&lt;/a&gt;&lt;/code&gt; ) 해당 &lt;code&gt;$opt_y&lt;/code&gt; 가 정의되지 않은 값으로 설정됩니다. 지정되지 않은 스위치는 자동으로 승인됩니다. &lt;code&gt;getopt()&lt;/code&gt; 사용은 권장되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d8dad5d808a96d01abfb75223a15354d771a92d8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;getopt()&lt;/code&gt; function is similar, but its argument is a string containing all switches that take an argument. If no argument is provided for a switch, say, &lt;code&gt;y&lt;/code&gt;, the corresponding &lt;code&gt;$opt_y&lt;/code&gt; will be set to an undefined value. Unspecified switches are silently accepted. Use of &lt;code&gt;getopt()&lt;/code&gt; is not recommended.</source>
          <target state="translated">&lt;code&gt;getopt()&lt;/code&gt; 함수와 유사하지만, 그 인수는 인수를 모든 스위치를 포함하는 문자열이다. 스위치에 대한 인수 (예 : &lt;code&gt;y&lt;/code&gt; ) 가 제공되지 않으면 해당 &lt;code&gt;$opt_y&lt;/code&gt; 가 정의되지 않은 값으로 설정됩니다. 지정되지 않은 스위치는 자동으로 허용됩니다. &lt;code&gt;getopt()&lt;/code&gt; 사용은 권장되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c037451f79364fbd043155e0ffbbe91d2a70fbad" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;getopts()&lt;/code&gt; function processes single-character switches with switch clustering. Pass one argument which is a string containing all switches to be recognized. For each switch found, if an argument is expected and provided, &lt;code&gt;getopts()&lt;/code&gt; sets &lt;code&gt;$opt_x&lt;/code&gt; (where &lt;code&gt;x&lt;/code&gt; is the switch name) to the value of the argument. If an argument is expected but none is provided, &lt;code&gt;$opt_x&lt;/code&gt; is set to an undefined value. If a switch does not take an argument, &lt;code&gt;$opt_x&lt;/code&gt; is set to &lt;code&gt;1&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;getopts()&lt;/code&gt; 함수는 단일 문자를 처리하여 스위치 클러스터링 스위치. 인식 할 모든 스위치를 포함하는 문자열 인 하나의 인수를 전달하십시오. 발견 된 각 스위치에 대해 인수가 예상되어 제공되면 &lt;code&gt;getopts()&lt;/code&gt; 는 &lt;code&gt;$opt_x&lt;/code&gt; (여기서 &lt;code&gt;x&lt;/code&gt; 는 스위치 이름)를 인수 값으로 설정합니다. 인수가 필요하지만 아무것도 제공되지 않으면 &lt;code&gt;$opt_x&lt;/code&gt; 는 정의되지 않은 값으로 설정됩니다. 스위치가 인수를 취하지 않으면 &lt;code&gt;$opt_x&lt;/code&gt; 는 &lt;code&gt;1&lt;/code&gt; 로 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="91aef3725c2efdb205ada4f0830cb2c2f0326f3e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;getopts()&lt;/code&gt; function processes single-character switches with switch clustering. Pass one argument which is a string containing all switches to be recognized. For each switch found, if an argument is expected and provided, &lt;code&gt;getopts()&lt;/code&gt; sets &lt;code&gt;$opt_x&lt;/code&gt; (where &lt;code&gt;x&lt;/code&gt; is the switch name) to the value of the argument. If an argument is expected but none is provided, &lt;code&gt;$opt_x&lt;/code&gt; is set to an undefined value. If a switch does not take an argument, &lt;code&gt;$opt_x&lt;/code&gt; is set to &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;getopts()&lt;/code&gt; 함수는 단일 문자를 처리하여 스위치 클러스터링 스위치. 인식 할 모든 스위치를 포함하는 문자열 인 하나의 인수를 전달하십시오. 발견 된 각 스위치에 대해 인수가 예상되고 제공된 경우 &lt;code&gt;getopts()&lt;/code&gt; 는 &lt;code&gt;$opt_x&lt;/code&gt; ( &lt;code&gt;x&lt;/code&gt; 는 스위치 이름)를 인수 값으로 설정합니다. 인수가 예상되지만 제공 되지 않은 경우 &lt;code&gt;$opt_x&lt;/code&gt; 는 정의되지 않은 값으로 설정됩니다. 스위치가 인수를받지 않는 경우 &lt;code&gt;$opt_x&lt;/code&gt; 는 &lt;code&gt;1&lt;/code&gt; 로 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="fe182c59e721bf2edc44a9253eded06fe11c1a8a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;getopts()&lt;/code&gt; function returns true unless an invalid option was found.</source>
          <target state="translated">&lt;code&gt;getopts()&lt;/code&gt; 잘못된 옵션이 발견되지 않는 한 함수는 true를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="a7db78679ac7caa25a3af4ac6eb9b08a0ab0fc92" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;gmtime&lt;/code&gt; operator will function properly if you have a working CRTL &lt;code&gt;gmtime()&lt;/code&gt; routine, or if the logical name SYS$TIMEZONE_DIFFERENTIAL is defined as the number of seconds which must be added to UTC to yield local time. (This logical name is defined automatically if you are running a version of VMS with built-in UTC support.) If neither of these cases is true, a warning message is printed, and &lt;code&gt;undef&lt;/code&gt; is returned.</source>
          <target state="translated">&lt;code&gt;gmtime&lt;/code&gt; 의 연산자를 사용하면 작업 CRTL의 경우 제대로 작동 &lt;code&gt;gmtime()&lt;/code&gt; 루틴을, 또는 논리 이름 SYS $ TIMEZONE_DIFFERENTIAL는 현지 시간을 산출하기 위해 UTC에 추가해야합니다 (초)로 정의합니다. (이 논리 이름은 UTC 지원이 내장 된 VMS 버전을 실행하는 경우 자동으로 정의됩니다.) 이러한 경우가 모두 참이 아니면 경고 메시지가 인쇄되고 &lt;code&gt;undef&lt;/code&gt; 가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="ddf55542a974db500db0203f6bd0350de0ee8029" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;goto &amp;amp;NAME&lt;/code&gt; form is quite different from the other forms of &lt;a href=&quot;#goto-LABEL&quot;&gt;&lt;code&gt;goto&lt;/code&gt;&lt;/a&gt;. In fact, it isn't a goto in the normal sense at all, and doesn't have the stigma associated with other gotos. Instead, it exits the current subroutine (losing any changes set by &lt;a href=&quot;#local-EXPR&quot;&gt;&lt;code&gt;local&lt;/code&gt;&lt;/a&gt;) and immediately calls in its place the named subroutine using the current value of &lt;a href=&quot;perlvar#%40_&quot;&gt;&lt;code&gt;@_&lt;/code&gt;&lt;/a&gt;. This is used by &lt;code&gt;AUTOLOAD&lt;/code&gt; subroutines that wish to load another subroutine and then pretend that the other subroutine had been called in the first place (except that any modifications to &lt;a href=&quot;perlvar#%40_&quot;&gt;&lt;code&gt;@_&lt;/code&gt;&lt;/a&gt; in the current subroutine are propagated to the other subroutine.) After the &lt;a href=&quot;#goto-LABEL&quot;&gt;&lt;code&gt;goto&lt;/code&gt;&lt;/a&gt;, not even &lt;a href=&quot;#caller-EXPR&quot;&gt;&lt;code&gt;caller&lt;/code&gt;&lt;/a&gt; will be able to tell that this routine was called first.</source>
          <target state="translated">&lt;code&gt;goto &amp;amp;NAME&lt;/code&gt; 형태의 다른 형태는 매우 다르다 &lt;a href=&quot;#goto-LABEL&quot;&gt; &lt;code&gt;goto&lt;/code&gt; &lt;/a&gt; . 사실, 그것은 정상적인 의미에서 고토가 아니며 다른 고토와 관련된 오명도 없습니다. 대신 현재 서브 루틴을 종료하고 ( &lt;a href=&quot;#local-EXPR&quot;&gt; &lt;code&gt;local&lt;/code&gt; 에서&lt;/a&gt; 설정 한 모든 변경 사항을 잃음 ) 현재 값 &lt;a href=&quot;perlvar#%40_&quot;&gt; &lt;code&gt;@_&lt;/code&gt; 를&lt;/a&gt; 사용하여 명명 된 서브 루틴을 즉시 호출합니다 . 이것은에 의해 사용되는 &lt;code&gt;AUTOLOAD&lt;/code&gt; 소원 다른 서브 루틴을로드 한 다음, 다른 서브 루틴 (모든 변형하는 것을 제외하고는 처음에 호출되었던 척 것을 루틴 &lt;a href=&quot;perlvar#%40_&quot;&gt; &lt;code&gt;@_&lt;/code&gt; &lt;/a&gt; 애프터 현재 서브 루틴은 다른 서브 루틴에 전달된다.) &lt;a href=&quot;#goto-LABEL&quot;&gt; &lt;code&gt;goto&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#caller-EXPR&quot;&gt; &lt;code&gt;caller&lt;/code&gt; &lt;/a&gt; 도 아니야 이 루틴이 먼저 호출되었음을 알 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b87b19f1c73c949cde9da8170870a148c4211b7d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;goto EXPR&lt;/code&gt; form expects to evaluate &lt;code&gt;EXPR&lt;/code&gt; to a code reference or a label name. If it evaluates to a code reference, it will be handled like &lt;code&gt;goto &amp;amp;NAME&lt;/code&gt;, below. This is especially useful for implementing tail recursion via &lt;code&gt;goto __SUB__&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;goto EXPR&lt;/code&gt; 형태는 평가를 기대 &lt;code&gt;EXPR&lt;/code&gt; 을 코드 참조 또는 레이블 이름. 코드 참조로 평가 되면 아래의 &lt;code&gt;goto &amp;amp;NAME&lt;/code&gt; 처럼 처리 됩니다. 이것은 &lt;code&gt;goto __SUB__&lt;/code&gt; 를 통해 꼬리 재귀를 구현하는 데 특히 유용합니다 .</target>
        </trans-unit>
        <trans-unit id="5712e372b5c3349bd4c5753ceb08d65a1f34e0e2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;goto LABEL&lt;/code&gt; form finds the statement labeled with LABEL and resumes execution there. It can't be used to get out of a block or subroutine given to &lt;a href=&quot;#sort-SUBNAME-LIST&quot;&gt;&lt;code&gt;sort&lt;/code&gt;&lt;/a&gt;. It can be used to go almost anywhere else within the dynamic scope, including out of subroutines, but it's usually better to use some other construct such as &lt;a href=&quot;#last-LABEL&quot;&gt;&lt;code&gt;last&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#die-LIST&quot;&gt;&lt;code&gt;die&lt;/code&gt;&lt;/a&gt;. The author of Perl has never felt the need to use this form of &lt;a href=&quot;#goto-LABEL&quot;&gt;&lt;code&gt;goto&lt;/code&gt;&lt;/a&gt; (in Perl, that is; C is another matter). (The difference is that C does not offer named loops combined with loop control. Perl does, and this replaces most structured uses of &lt;a href=&quot;#goto-LABEL&quot;&gt;&lt;code&gt;goto&lt;/code&gt;&lt;/a&gt; in other languages.)</source>
          <target state="translated">&lt;code&gt;goto LABEL&lt;/code&gt; 형태는 LABEL이 표시된 문을 발견하고 거기에 실행을 다시 시작합니다. &lt;a href=&quot;#sort-SUBNAME-LIST&quot;&gt; &lt;code&gt;sort&lt;/code&gt; 에&lt;/a&gt; 주어진 블록이나 서브 루틴을 벗어나는 데 사용할 수 없습니다 . 서브 루틴 외부를 포함하여 동적 범위 내의 거의 모든 곳으로 이동하는 데 사용할 수 있지만 일반적으로 &lt;a href=&quot;#last-LABEL&quot;&gt; &lt;code&gt;last&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#die-LIST&quot;&gt; &lt;code&gt;die&lt;/code&gt; &lt;/a&gt; 와 같은 다른 구성을 사용하는 것이 좋습니다 . Perl의 작성자는 이러한 형태의 &lt;a href=&quot;#goto-LABEL&quot;&gt; &lt;code&gt;goto&lt;/code&gt; &lt;/a&gt; 를 사용할 필요성을 전혀 느끼지 못했습니다 (Perl에서 C는 또 다른 문제입니다). (차이점은 C가 루프 제어와 결합 된 명명 된 루프를 제공하지 않는다는 것입니다. Perl은 다른 언어에서 대부분의 구조화 된 &lt;a href=&quot;#goto-LABEL&quot;&gt; &lt;code&gt;goto&lt;/code&gt; &lt;/a&gt; 사용을 대체합니다 .)</target>
        </trans-unit>
        <trans-unit id="60a01fb6d408173d3e22945b3c56ff55146388d1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;goto&lt;/code&gt;-&amp;amp;NAME form is highly magical, and substitutes a call to the named subroutine for the currently running subroutine. This is used by &lt;code&gt;AUTOLOAD()&lt;/code&gt; subroutines that wish to load another subroutine and then pretend that the other subroutine had been called in the first place (except that any modifications to &lt;code&gt;@_&lt;/code&gt; in the current subroutine are propagated to the other subroutine.) After the &lt;code&gt;goto&lt;/code&gt;, not even &lt;code&gt;caller()&lt;/code&gt; will be able to tell that this routine was called first.</source>
          <target state="translated">&lt;code&gt;goto&lt;/code&gt; - &amp;amp; NAME 형태는 매우 마법이며, 현재 실행중인 서브 루틴 명명 된 서브 루틴 호출을 대체합니다. 이것은 다른 서브 루틴을로드하려는 &lt;code&gt;AUTOLOAD()&lt;/code&gt; 서브 루틴에 의해 사용되며 다른 서브 루틴이 처음에 호출 된 것처럼 가장합니다 ( 현재 서브 루틴의 &lt;code&gt;@_&lt;/code&gt; 에 대한 수정 사항 이 다른 서브 루틴으로 전파 된다는 점 제외 ). &lt;code&gt;goto&lt;/code&gt; , &lt;code&gt;caller()&lt;/code&gt; 조차도이 루틴이 먼저 호출되었음을 알 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="445db83ca6a37cdb271d1da44d8e4a2e039ee781" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;goto&lt;/code&gt;-EXPR form expects a label name, whose scope will be resolved dynamically. This allows for computed &lt;code&gt;goto&lt;/code&gt;s per FORTRAN, but isn't necessarily recommended if you're optimizing for maintainability:</source>
          <target state="translated">&lt;code&gt;goto&lt;/code&gt; -EXPR 양식은 그 범위를 동적으로 해결 될 것입니다 라벨 이름을 기대하고있다. 이렇게하면 FORTRAN 당 계산 된 &lt;code&gt;goto&lt;/code&gt; 가 허용 되지만 유지 관리를 위해 최적화하는 경우 반드시 권장되는 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="3604bc760ddc7f229653ccec982fbb33374f75b3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;goto&lt;/code&gt;-LABEL form finds the statement labeled with LABEL and resumes execution there. It may not be used to go into any construct that requires initialization, such as a subroutine or a &lt;code&gt;foreach&lt;/code&gt; loop. It also can't be used to go into a construct that is optimized away. It can be used to go almost anywhere else within the dynamic scope, including out of subroutines, but it's usually better to use some other construct such as &lt;code&gt;last&lt;/code&gt; or &lt;code&gt;die&lt;/code&gt;. The author of Perl has never felt the need to use this form of &lt;code&gt;goto&lt;/code&gt; (in Perl, that is--C is another matter).</source>
          <target state="translated">&lt;code&gt;goto&lt;/code&gt; -label 양식 LABEL이 표시된 문을 발견하고 거기에 실행을 다시 시작합니다. 서브 루틴 또는 &lt;code&gt;foreach&lt;/code&gt; 루프 와 같이 초기화가 필요한 구조로 이동하는 데 사용할 수 없습니다 . 또한 최적화 된 구조로 이동하는 데 사용할 수 없습니다. 서브 루틴 외부를 포함하여 동적 범위 내의 거의 모든 곳으로 이동하는 데 사용할 수 있지만 일반적으로 &lt;code&gt;last&lt;/code&gt; 또는 &lt;code&gt;die&lt;/code&gt; 와 같은 다른 구성을 사용하는 것이 좋습니다 . Perl의 작성자는 이러한 형태의 &lt;code&gt;goto&lt;/code&gt; 를 사용할 필요성을 전혀 느끼지 못했습니다 (Perl에서 C는 또 다른 문제입니다).</target>
        </trans-unit>
        <trans-unit id="c2fadcd77a199834658c813ed1ecacfc31717619" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;grammar_class&lt;/code&gt; can be customized, as described in &lt;a href=&quot;#new&quot;&gt;&quot;new&quot;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;grammar_class&lt;/code&gt; 은 에 설명 된대로 사용자 정의 할 수 있습니다 &lt;a href=&quot;#new&quot;&gt;&quot;새로운&quot;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="688985f64d8825090cd98452194bcbd67a98423b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;grammar_class&lt;/code&gt; can be customized, as described in &lt;a href=&quot;#new&quot;&gt;new&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;grammar_class&lt;/code&gt; 는 설명대로 정의 될 수있는 &lt;a href=&quot;#new&quot;&gt;새로운&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="777e123af8a17b58624e4e03631072776b99c240" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;grep&lt;/code&gt; in scalar context returns the count. If you want the list of matching items, just use it in list context instead:</source>
          <target state="translated">스칼라 컨텍스트 의 &lt;code&gt;grep&lt;/code&gt; 은 개수를 반환합니다. 일치하는 항목의 목록을 원하면 목록 컨텍스트에서 대신 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="361db5e35a8a030899f4185a6ca897ccf88b2984" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;h&lt;/code&gt; and &lt;code&gt;H&lt;/code&gt; formats pack a string that many nybbles (4-bit groups, representable as hexadecimal digits, &lt;code&gt;&quot;0&quot;..&quot;9&quot;&lt;/code&gt;&lt;code&gt;&quot;a&quot;..&quot;f&quot;&lt;/code&gt; ) long.</source>
          <target state="translated">&lt;code&gt;h&lt;/code&gt; 및 &lt;code&gt;H&lt;/code&gt; 포맷 문자열 팩 많은 nybbles (16 진수로서 표현할 4 비트 그룹, &lt;code&gt;&quot;0&quot;..&quot;9&quot;&lt;/code&gt; &lt;code&gt;&quot;a&quot;..&quot;f&quot;&lt;/code&gt; ) 길이.</target>
        </trans-unit>
        <trans-unit id="282363bb17be47a4571b65bee183b55491c1858f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;h&lt;/code&gt; and &lt;code&gt;H&lt;/code&gt; formats pack a string that many nybbles (4-bit groups, representable as hexadecimal digits, &lt;code&gt;&quot;0&quot;..&quot;9&quot;&lt;/code&gt;&lt;code&gt;&quot;a&quot;..&quot;f&quot;&lt;/code&gt;) long.</source>
          <target state="translated">&lt;code&gt;h&lt;/code&gt; 및 &lt;code&gt;H&lt;/code&gt; 포맷 문자열 팩 많은 nybbles (16 진수로서 표현할 4 비트 그룹, &lt;code&gt;&quot;0&quot;..&quot;9&quot;&lt;/code&gt; &lt;code&gt;&quot;a&quot;..&quot;f&quot;&lt;/code&gt; ) 길이.</target>
        </trans-unit>
        <trans-unit id="52b0ba82d51f8c56aed17fcdac89e94cd7a38305" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;has()&lt;/code&gt; subroutine declares an attribute, and &lt;code&gt;Moose&lt;/code&gt; automatically creates accessors for these attributes. It also takes care of creating a &lt;code&gt;new()&lt;/code&gt; method for you. This constructor knows about the attributes you declared, so you can set them when creating a new &lt;code&gt;File&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;has()&lt;/code&gt; 서브 루틴 속성을 선언하고 &lt;code&gt;Moose&lt;/code&gt; 자동으로 이러한 속성에 대한 접근을 만듭니다. 또한 &lt;code&gt;new()&lt;/code&gt; 메소드 작성을 처리합니다. 이 생성자는 선언 한 속성에 대해 알고 있으므로 새 &lt;code&gt;File&lt;/code&gt; 생성시 속성을 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0b9970d46e3cdb5c6bbb0a61789e35dad5828ae7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;has()&lt;/code&gt; subroutine declares an attribute, and &lt;code&gt;Moose&lt;/code&gt; automatically creates accessors for these attributes. It also takes care of creating a &lt;code&gt;new()&lt;/code&gt; method for you. This constructor knows about the attributes you declared, so you can set them when creating a new &lt;code&gt;File&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;has()&lt;/code&gt; 서브 루틴 속성을 선언하고 &lt;code&gt;Moose&lt;/code&gt; 자동으로 이러한 속성에 대한 접근을 만듭니다. 또한 &lt;code&gt;new()&lt;/code&gt; 메서드를 생성합니다. 이 생성자는 선언 한 속성에 대해 알고 있으므로 새 &lt;code&gt;File&lt;/code&gt; 을 만들 때 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="76a592c009139dada36763e63a154e69a7ae21aa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;hide_buffered()&lt;/code&gt; method must return a boolean. This is used to tell buffered subtests whether or not to send it events as they are being buffered. See &lt;a href=&quot;Test2::API#run_subtest%28...%29&quot;&gt;&quot;run_subtest(...)&quot; in Test2::API&lt;/a&gt; for more information.</source>
          <target state="translated">&lt;code&gt;hide_buffered()&lt;/code&gt; 메소드는 부울을 반환해야합니다. 버퍼링 된 하위 테스트에 이벤트를 보낼지 여부를 알려주는 데 사용됩니다. 자세한 내용 &lt;a href=&quot;Test2::API#run_subtest%28...%29&quot;&gt;은 Test2 :: API의 &quot;run_subtest (...)&quot;&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="cfb4b1270d7a6c1577ddc7dc43612517ef56c1fb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;host&lt;/code&gt; argument implicitly specifies the family if the family argument is not given.</source>
          <target state="translated">&lt;code&gt;host&lt;/code&gt; 가족의 인수가 지정되지 않는 경우는, 인수는 암시 적으로 가족을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="5a9683174ca55dfc5709630b38ddbf4013af69ca" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;i!&lt;/code&gt; and &lt;code&gt;I!&lt;/code&gt; codes aren't different from &lt;code&gt;i&lt;/code&gt; and &lt;code&gt;I&lt;/code&gt; ; they are tolerated for completeness' sake.</source>
          <target state="translated">&lt;code&gt;i!&lt;/code&gt; 그리고 &lt;code&gt;I!&lt;/code&gt; 코드는 &lt;code&gt;i&lt;/code&gt; 와 &lt;code&gt;I&lt;/code&gt; 과 다르지 않습니다 . 그들은 완전성을 위해 용납됩니다.</target>
        </trans-unit>
        <trans-unit id="788c747d1d57898e8c459685e81e82083e2bc64a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;i!&lt;/code&gt; and &lt;code&gt;I!&lt;/code&gt; codes aren't different from &lt;code&gt;i&lt;/code&gt; and &lt;code&gt;I&lt;/code&gt;; they are tolerated for completeness' sake.</source>
          <target state="translated">&lt;code&gt;i!&lt;/code&gt; 그리고 &lt;code&gt;I!&lt;/code&gt; 코드는 &lt;code&gt;i&lt;/code&gt; 및 &lt;code&gt;I&lt;/code&gt; 와 다르지 않습니다 . 완전성을 위해 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="441288d51b032bd9af407d3a9d7124153bae7480" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;id()&lt;/code&gt; function is incorporated in</source>
          <target state="translated">&lt;code&gt;id()&lt;/code&gt; 함수에 포함되고</target>
        </trans-unit>
        <trans-unit id="5b77bbf33fef07ab4b901464b3d1fbf57256a9cb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;id()&lt;/code&gt; function is provided in addition to the existing &lt;code&gt;Scalar::Util::refaddr()&lt;/code&gt; . Besides its short name it can be a little faster under some circumstances (and a bit slower under others). Benchmark if it matters. The working of &lt;code&gt;id()&lt;/code&gt; also allows the use of the class name as a</source>
          <target state="translated">&lt;code&gt;id()&lt;/code&gt; 함수 외에도 기존에 제공되는 &lt;code&gt;Scalar::Util::refaddr()&lt;/code&gt; . 짧은 이름 외에도 일부 환경에서는 약간 더 빠를 수 있습니다 (다른 환경에서는 약간 느려질 수 있음). 중요한 경우 벤치 마크. 의 작업 &lt;code&gt;id()&lt;/code&gt; 도 같은 클래스 이름의 사용을 허용</target>
        </trans-unit>
        <trans-unit id="b2d4a03cd0e504b918c77f964222c03e6f8204c2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;id()&lt;/code&gt; function is provided in addition to the existing &lt;code&gt;Scalar::Util::refaddr()&lt;/code&gt;. Besides its short name it can be a little faster under some circumstances (and a bit slower under others). Benchmark if it matters. The working of &lt;code&gt;id()&lt;/code&gt; also allows the use of the class name as a</source>
          <target state="translated">&lt;code&gt;id()&lt;/code&gt; 함수 외에도 기존에 제공되는 &lt;code&gt;Scalar::Util::refaddr()&lt;/code&gt; . 짧은 이름 외에도 어떤 상황에서는 조금 더 빠를 수 있습니다 (다른 상황에서는 조금 더 느릴 수 있습니다). 중요한 경우 벤치마킹하십시오. &lt;code&gt;id()&lt;/code&gt; 의 작업은 또한 클래스 이름을</target>
        </trans-unit>
        <trans-unit id="1766324c2122418c9321a7a3323084287c423699" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;if&lt;/code&gt; module is used to conditionally load another module. The construct:</source>
          <target state="translated">&lt;code&gt;if&lt;/code&gt; 모듈은 조건부 다른 모듈을로드하는 데 사용됩니다. 구성 :</target>
        </trans-unit>
        <trans-unit id="1d508e8165fd2906f6e1a4da8eddef354ad1b2c9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;if&lt;/code&gt; module is used to conditionally load or unload another module. The construct</source>
          <target state="translated">&lt;code&gt;if&lt;/code&gt; 모듈은 조건부 부하에 사용하거나 다른 모듈을 언로드합니다. 구조</target>
        </trans-unit>
        <trans-unit id="4b048e8a441fb17f85efa08c37a67df6bc5d9c00" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;if&lt;/code&gt; statement is straightforward. Because BLOCKs are always bounded by curly brackets, there is never any ambiguity about which &lt;code&gt;if&lt;/code&gt; an &lt;code&gt;else&lt;/code&gt; goes with. If you use &lt;code&gt;unless&lt;/code&gt; in place of &lt;code&gt;if&lt;/code&gt; , the sense of the test is reversed. Like &lt;code&gt;if&lt;/code&gt; , &lt;code&gt;unless&lt;/code&gt; can be followed by &lt;code&gt;else&lt;/code&gt; . &lt;code&gt;unless&lt;/code&gt; can even be followed by one or more &lt;code&gt;elsif&lt;/code&gt; statements, though you may want to think twice before using that particular language construct, as everyone reading your code will have to think at least twice before they can understand what's going on.</source>
          <target state="translated">&lt;code&gt;if&lt;/code&gt; 문은 간단하다. BLOCK은 항상 중괄호로 묶여 있기 때문에 &lt;code&gt;else&lt;/code&gt; 와 함께 사용 하는 &lt;code&gt;if&lt;/code&gt; 대한 모호성이 없습니다 . 당신이 사용하는 경우 &lt;code&gt;unless&lt;/code&gt; 대신 &lt;code&gt;if&lt;/code&gt; , 테스트의 의미는 반대입니다. 같은 &lt;code&gt;if&lt;/code&gt; , &lt;code&gt;unless&lt;/code&gt; 다음에 할 수 &lt;code&gt;else&lt;/code&gt; . 하나 이상의 &lt;code&gt;elsif&lt;/code&gt; 문 이 뒤따를 수 &lt;code&gt;unless&lt;/code&gt; , 특정 언어 구조를 사용하기 전에 두 번 생각하고 싶을 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="a3f74430f10fb167c78fb2a5e2886ee696f50106" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;if&lt;/code&gt; statement is straightforward. Because BLOCKs are always bounded by curly brackets, there is never any ambiguity about which &lt;code&gt;if&lt;/code&gt; an &lt;code&gt;else&lt;/code&gt; goes with. If you use &lt;code&gt;unless&lt;/code&gt; in place of &lt;code&gt;if&lt;/code&gt;, the sense of the test is reversed. Like &lt;code&gt;if&lt;/code&gt;, &lt;code&gt;unless&lt;/code&gt; can be followed by &lt;code&gt;else&lt;/code&gt;. &lt;code&gt;unless&lt;/code&gt; can even be followed by one or more &lt;code&gt;elsif&lt;/code&gt; statements, though you may want to think twice before using that particular language construct, as everyone reading your code will have to think at least twice before they can understand what's going on.</source>
          <target state="translated">&lt;code&gt;if&lt;/code&gt; 문은 간단하다. 블록이 항상 중괄호에 의해 제한되어 있기 때문에, 어떤에 대한 모호함이 결코 &lt;code&gt;if&lt;/code&gt; &lt;code&gt;else&lt;/code&gt; 와 함께 간다. &lt;code&gt;if&lt;/code&gt; 대신에 사용 &lt;code&gt;unless&lt;/code&gt; 테스트의 의미가 반전됩니다. &lt;code&gt;if&lt;/code&gt; 와 같이 , &lt;code&gt;unless&lt;/code&gt; 뒤에 &lt;code&gt;else&lt;/code&gt; 가 올 수 있습니다 . 하나 이상의 &lt;code&gt;elsif&lt;/code&gt; 문 이 뒤따를 수 &lt;code&gt;unless&lt;/code&gt; 가 아니면 특정 언어 구조를 사용하기 전에 두 번 생각하고 싶을 수 있습니다. 코드를 읽는 모든 사람이 무슨 일이 일어나고 있는지 이해하기 전에 적어도 두 번 생각해야하기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="e9f3b671cb1eeb07ae7f1604035f9acb4eeee7c0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ihave&lt;/code&gt; command informs the server that the client has an article whose id is &lt;code&gt;MSGID&lt;/code&gt; . If the server desires a copy of that article, and &lt;code&gt;MESSAGE&lt;/code&gt; has been given the it will be sent.</source>
          <target state="translated">&lt;code&gt;ihave&lt;/code&gt; 명령은 클라이언트 ID입니다 기사가있는 서버 알려 &lt;code&gt;MSGID&lt;/code&gt; 를 . 서버가 해당 기사의 사본을 원하고 &lt;code&gt;MESSAGE&lt;/code&gt; 가 제공된 경우 발송됩니다.</target>
        </trans-unit>
        <trans-unit id="31b23815f5a49e656771e950c98aed03ec7f0fc3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ihave&lt;/code&gt; command informs the server that the client has an article whose id is &lt;code&gt;MSGID&lt;/code&gt;. If the server desires a copy of that article and &lt;code&gt;MESSAGE&lt;/code&gt; has been given then it will be sent.</source>
          <target state="translated">&lt;code&gt;ihave&lt;/code&gt; 명령은 클라이언트 ID입니다 기사가있는 서버 알려 &lt;code&gt;MSGID&lt;/code&gt; 를 . 서버가 해당 기사의 사본을 원하고 &lt;code&gt;MESSAGE&lt;/code&gt; 가 제공된 경우 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="9aeda9f25872f01fa1451e80b809c2f965a34d18" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;import&lt;/code&gt; method is used to create an instance of the filter. It is called indirectly by Perl when it encounters the &lt;code&gt;use MyFilter&lt;/code&gt; line in a source file (See &lt;a href=&quot;perlfunc#import&quot;&gt;&quot;import&quot; in perlfunc&lt;/a&gt; for more details on &lt;code&gt;import&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;import&lt;/code&gt; 방법은 필터의 인스턴스를 생성하기 위해 사용된다. 가 발생할 때 펄에 의해 간접적으로 호출되어 &lt;code&gt;use MyFilter&lt;/code&gt; 소스 파일에서 라인을 (보기 &lt;a href=&quot;perlfunc#import&quot;&gt;을 perlfunc에서 &quot;수입&quot;&lt;/a&gt; 에 대한 자세한 내용은 &lt;code&gt;import&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="2a41824798980582f7eebe5a9af3082e01f3a340" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;intercept { ... }&lt;/code&gt; tool lets you temporarily intercept all events generated by the test system:</source>
          <target state="translated">&lt;code&gt;intercept { ... }&lt;/code&gt; 도구는 테스트 시스템에 의해 생성 된 모든 이벤트 인터셉트 일시적으로 다음을 수행 할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="be9e48c7280cc08e3dbfd771c25dd8dc760ce4df" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;io&lt;/code&gt; options mean that any subsequent open() (or similar I/O operations) in main program scope will have the &lt;code&gt;:utf8&lt;/code&gt; PerlIO layer implicitly applied to them, in other words, UTF-8 is expected from any input stream, and UTF-8 is produced to any output stream. This is just the default set via &lt;a href=&quot;perlvar#%24%7B%5EOPEN%7D&quot;&gt;&lt;code&gt;${^OPEN}&lt;/code&gt;&lt;/a&gt;, with explicit layers in open() and with binmode() one can manipulate streams as usual. This has no effect on code run in modules.</source>
          <target state="translated">&lt;code&gt;io&lt;/code&gt; 옵션은 주 프로그램 범위에있는) (이후 개방 (또는 유사한 I / O 동작)을 가질 것이라는 것을 의미 &lt;code&gt;:utf8&lt;/code&gt; 은 PerlIO의 내재적 즉 적용된 층, UTF-8은 임의의 입력 스트림에서 예상되며, UTF을 -8은 모든 출력 스트림에 생성됩니다. 이것은 &lt;a href=&quot;perlvar#%24%7B%5EOPEN%7D&quot;&gt; &lt;code&gt;${^OPEN}&lt;/code&gt; &lt;/a&gt; 통해 설정된 기본값 이며 open ()에 명시 적 레이어가 있고 binmode ()를 사용하면 평소와 같이 스트림을 조작 할 수 있습니다. 이것은 모듈에서 실행되는 코드에는 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="31aa9addcda21b8978ff9bf041daba569f826e41" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;io&lt;/code&gt; options mean that any subsequent open() (or similar I/O operations) in the current file scope will have the &lt;code&gt;:utf8&lt;/code&gt; PerlIO layer implicitly applied to them, in other words, UTF-8 is expected from any input stream, and UTF-8 is produced to any output stream. This is just the default, with explicit layers in open() and with binmode() one can manipulate streams as usual.</source>
          <target state="translated">&lt;code&gt;io&lt;/code&gt; 옵션은 현재 파일 범위에있는) (이후 개방 (또는 유사한 I / O 동작)을 가질 것이라는 것을 의미 &lt;code&gt;:utf8&lt;/code&gt; UTF-8은 임의의 입력 스트림에서 예상되는 내재적 즉 적용된은 PerlIO 층, 및 UTF-8은 모든 출력 스트림으로 생성됩니다. 이것은 기본값이며 open ()에 명시 적 레이어가 있고 binmode ()가 있으면 평상시처럼 스트림을 조작 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ea8cc24a093a2a51529b8db29000183dfdfc585d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;isa&lt;/code&gt; method returns</source>
          <target state="translated">&lt;code&gt;isa&lt;/code&gt; 메소드가 리턴</target>
        </trans-unit>
        <trans-unit id="d80df4437426b10544ca2a3550913f7483c70900" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;keep_alive&lt;/code&gt; parameter enables a persistent connection, but only to a single destination scheme, host and port. Also, if any connection-relevant attributes are modified, or if the process ID or thread ID change, the persistent connection will be dropped. If you want persistent connections across multiple destinations, use multiple HTTP::Tiny objects.</source>
          <target state="translated">&lt;code&gt;keep_alive&lt;/code&gt; 매개 변수는 오직 하나의 목적지 방식, 호스트 및 포트, 영구 연결을 할 수 있습니다. 또한 연결 관련 속성이 수정되거나 프로세스 ID 또는 스레드 ID가 변경되면 영구 연결이 삭제됩니다. 여러 대상에서 지속적으로 연결하려면 여러 HTTP :: Tiny 개체를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="82e537c44915ef2c8c7d2ba733eb7ee50f9fc357" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;keys()&lt;/code&gt; function also resets the iterator, which means that you may see strange results if you use this between uses of other hash operators such as &lt;code&gt;each()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;keys()&lt;/code&gt; 함수는 또한 같은 다른 해시 연산자의 사용 사이에이를 사용하는 경우 이상한 결과를 볼 수 있다는 것을 의미 반복기, 리셋 &lt;code&gt;each()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="59f328cf1649c302313e1693d9d3ed492ede670c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;kill&lt;/code&gt; function can be used to test this functionality from within a program.</source>
          <target state="translated">&lt;code&gt;kill&lt;/code&gt; 기능은 프로그램 내에서이 기능을 테스트 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8b31ef1c90508af7c0b307ce12a58574a2fffa8e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;kill&lt;/code&gt; function in the parent's &lt;code&gt;if&lt;/code&gt; block is there to send a signal to our child process, currently running in the &lt;code&gt;else&lt;/code&gt; block, as soon as the remote server has closed its end of the connection.</source>
          <target state="translated">&lt;code&gt;kill&lt;/code&gt; 부모의 함수의 &lt;code&gt;if&lt;/code&gt; 블록이 현재 실행, 우리의 자식 프로세스에 신호가 전송하는 것입니다 &lt;code&gt;else&lt;/code&gt; 원격 서버 연결의 끝을 폐쇄했다 자마자, 블록.</target>
        </trans-unit>
        <trans-unit id="40b75cea7c9c256a2c7f367ec1f2a28305318646" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;klen&lt;/code&gt; parameter is the length of the key being passed in (Note that you cannot pass 0 in as a value of &lt;code&gt;klen&lt;/code&gt; to tell Perl to measure the length of the key). The &lt;code&gt;val&lt;/code&gt; argument contains the SV pointer to the scalar being stored, and &lt;code&gt;hash&lt;/code&gt; is the precomputed hash value (zero if you want &lt;code&gt;hv_store&lt;/code&gt; to calculate it for you). The &lt;code&gt;lval&lt;/code&gt; parameter indicates whether this fetch is actually a part of a store operation, in which case a new undefined value will be added to the HV with the supplied key and &lt;code&gt;hv_fetch&lt;/code&gt; will return as if the value had already existed.</source>
          <target state="translated">&lt;code&gt;klen&lt;/code&gt; 매개 변수 (당신의 값으로 0을 통과 할 수 없습니다 전달 된 키 존재의 길이 &lt;code&gt;klen&lt;/code&gt; 키의 길이를 측정하기 위해 펄을 이야기하기). &lt;code&gt;val&lt;/code&gt; 인수는 스칼라에 SV 포인터가 저장되는 포함하고, &lt;code&gt;hash&lt;/code&gt; (당신이 원하는 경우 제로 미리 계산 된 해시 값입니다 &lt;code&gt;hv_store&lt;/code&gt; 는 당신을 위해 그것을 계산). &lt;code&gt;lval&lt;/code&gt; 매개 변수는 실제 새로운 부정 값 제공된 키와 HV 첨가 될 경우에 저장 동작의 일부 인출 여부를 나타내는 &lt;code&gt;hv_fetch&lt;/code&gt; 값이 이미 존재하는 것처럼 리턴한다.</target>
        </trans-unit>
        <trans-unit id="ce7404a130e41b36d0d6586ea9856d3d751bce9d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;last&lt;/code&gt; command immediately exits the loop in question. The &lt;code&gt;continue&lt;/code&gt; block, if any, is not executed:</source>
          <target state="translated">&lt;code&gt;last&lt;/code&gt; 명령은 즉시 문제의 루프를 종료합니다. 는 &lt;code&gt;continue&lt;/code&gt; 어떤이 실행되지 않을 경우, 블록 :</target>
        </trans-unit>
        <trans-unit id="55c1db6e5ea234d6a6e740b669d07b2f2f87de01" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;length(NAME)&lt;/code&gt; Keyword</source>
          <target state="translated">&lt;code&gt;length(NAME)&lt;/code&gt; 키워드</target>
        </trans-unit>
        <trans-unit id="d1b3be6dbaf0292e629ff79d5077e6e86e950020" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;line numbers&lt;/code&gt; are a comma separated list of line numbers (some preceded by code letters) where that object is used in some way. Simple uses aren't preceded by a code letter. Introductions (such as where a lexical is first defined with &lt;code&gt;&lt;a href=&quot;../functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt;) are indicated with the letter &quot;i&quot;. Subroutine and method calls are indicated by the character &quot;&amp;amp;&quot;. Subroutine definitions are indicated by &quot;s&quot; and format definitions by &quot;f&quot;.</source>
          <target state="translated">&lt;code&gt;line numbers&lt;/code&gt; 해당 객체가 어떠한 방법으로 사용되는 라인 번호 (일부 코드 문자 앞에) 콤마로 구분된다. 간단한 용도 앞에는 코드 문자가 없습니다. 소개 (예 : 어휘가 &lt;code&gt;&lt;a href=&quot;../functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; 로 처음 정의되는 위치) )는 문자 &quot;i&quot;로 표시됩니다. 서브 루틴 및 메소드 호출은 문자 &quot;&amp;amp;&quot;로 표시됩니다. 서브 루틴 정의는 &quot;s&quot;로 표시되고 형식 정의는 &quot;f&quot;로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="236b6ae4af5c95ab170ad24f4ae0aa38234165ed" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;line numbers&lt;/code&gt; are a comma separated list of line numbers (some preceded by code letters) where that object is used in some way. Simple uses aren't preceded by a code letter. Introductions (such as where a lexical is first defined with &lt;code&gt;my&lt;/code&gt;) are indicated with the letter &quot;i&quot;. Subroutine and method calls are indicated by the character &quot;&amp;amp;&quot;. Subroutine definitions are indicated by &quot;s&quot; and format definitions by &quot;f&quot;.</source>
          <target state="translated">&lt;code&gt;line numbers&lt;/code&gt; 해당 객체가 어떠한 방법으로 사용되는 라인 번호 (일부 코드 문자 앞에) 콤마로 구분된다. 간단한 사용은 코드 문자가 앞에 나오지 않습니다. 소개 (예 : 어휘가 &lt;code&gt;my&lt;/code&gt; 로 처음 정의되는 경우 )는 문자 &quot;i&quot;로 표시됩니다. 서브 루틴 및 메소드 호출은 문자 &quot;&amp;amp;&quot;로 표시됩니다. 서브 루틴 정의는 &quot;s&quot;로 표시되고 형식 정의는 &quot;f&quot;로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="1df1ad78d22b500a60841a63c43cbb5af0dd2c94" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;lock()&lt;/code&gt; function takes a shared variable and puts a lock on it. No other thread may lock the variable until the variable is unlocked by the thread holding the lock. Unlocking happens automatically when the locking thread exits the block that contains the call to the &lt;code&gt;lock()&lt;/code&gt; function. Using &lt;code&gt;lock()&lt;/code&gt; is straightforward: This example has several threads doing some calculations in parallel, and occasionally updating a running total:</source>
          <target state="translated">&lt;code&gt;lock()&lt;/code&gt; 함수는 공유 변수를 받아 그것을 잠금을 둔다. 잠금을 유지하는 스레드에 의해 변수가 잠금 해제 될 때까지 다른 스레드는 변수를 잠글 수 없습니다. 잠금 스레드가 &lt;code&gt;lock()&lt;/code&gt; 함수에 대한 호출이 포함 된 블록을 종료하면 잠금 해제가 자동으로 발생 합니다. &lt;code&gt;lock()&lt;/code&gt; 사용하는 것은 간단합니다.이 예제에는 몇 가지 계산을 병렬로 수행하고 때때로 누계를 업데이트하는 여러 스레드가 있습니다.</target>
        </trans-unit>
        <trans-unit id="ed26c2274a611c42add606638c2955102446922f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;lock_store&lt;/code&gt; and &lt;code&gt;lock_nstore&lt;/code&gt; routine are equivalent to &lt;code&gt;store&lt;/code&gt; and &lt;code&gt;nstore&lt;/code&gt; , except that they get an exclusive lock on the file before writing. Likewise, &lt;code&gt;lock_retrieve&lt;/code&gt; does the same as &lt;code&gt;retrieve&lt;/code&gt; , but also gets a shared lock on the file before reading.</source>
          <target state="translated">&lt;code&gt;lock_store&lt;/code&gt; 및 &lt;code&gt;lock_nstore&lt;/code&gt; 의 루틴에 해당합니다 &lt;code&gt;store&lt;/code&gt; 및 &lt;code&gt;nstore&lt;/code&gt; 그들이 쓰기 전에 파일에 대한 단독 잠금을 얻을 것을 제외하고. 마찬가지로 &lt;code&gt;lock_retrieve&lt;/code&gt; 는 &lt;code&gt;retrieve&lt;/code&gt; 와 동일 합니다. 하지만 읽기 전에 파일에 대한 공유 잠금을 얻습니다.</target>
        </trans-unit>
        <trans-unit id="c09918116ac6368cc484da6987f7bb75bbaec828" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;lock_store&lt;/code&gt; and &lt;code&gt;lock_nstore&lt;/code&gt; routine are equivalent to &lt;code&gt;store&lt;/code&gt; and &lt;code&gt;nstore&lt;/code&gt;, except that they get an exclusive lock on the file before writing. Likewise, &lt;code&gt;lock_retrieve&lt;/code&gt; does the same as &lt;code&gt;retrieve&lt;/code&gt;, but also gets a shared lock on the file before reading.</source>
          <target state="translated">&lt;code&gt;lock_store&lt;/code&gt; 및 &lt;code&gt;lock_nstore&lt;/code&gt; 의 루틴에 해당합니다 &lt;code&gt;store&lt;/code&gt; 및 &lt;code&gt;nstore&lt;/code&gt; 그들이 쓰기 전에 파일에 대한 단독 잠금을 얻을 것을 제외하고. 마찬가지로 &lt;code&gt;lock_retrieve&lt;/code&gt; 는 &lt;code&gt;retrieve&lt;/code&gt; 와 동일한 작업을 수행 하지만 읽기 전에 파일에 대한 공유 잠금도 가져 옵니다 .</target>
        </trans-unit>
        <trans-unit id="931b71dd87fea82969167ed5b3226571750cd592" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;mail&lt;/code&gt; method can some additional ESMTP OPTIONS which is passed in hash like fashion, using key and value pairs. Possible options are:</source>
          <target state="translated">&lt;code&gt;mail&lt;/code&gt; 방법은 몇 가지 추가 ESMTP의 옵션 키와 값 쌍을 사용하여, 패션과 같은 해시에 전달 할 수있다. 가능한 옵션은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1672385883542a7bfdb246cc1c07640a71a68feb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;make&lt;/code&gt; and &lt;code&gt;emake&lt;/code&gt; accept both real and complex arguments. When they cannot recognize the arguments they will die with error messages like the following</source>
          <target state="translated">&lt;code&gt;make&lt;/code&gt; 과 &lt;code&gt;emake&lt;/code&gt; 는 모두 실수와 복소수 인수를 받아들입니다. 인수를 인식 할 수 없으면 다음과 같은 오류 메시지가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="c85fa07be63e0e0f2104a7ea90d6fd3b867aea55" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;make_path&lt;/code&gt; function creates the given directories if they don't exist before, much like the Unix command &lt;code&gt;mkdir -p&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;make_path&lt;/code&gt; 의 그들이 많은 유닉스 명령처럼, 이전에 존재하지 않는 경우, 함수는 주어진 디렉토리를 생성 &lt;code&gt;mkdir -p&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="36df2e300d21e511804bebffd14eb9e7ae60ac30" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;make_path&lt;/code&gt; function creates the given directories if they don't exists before, much like the Unix command &lt;code&gt;&lt;a href=&quot;../functions/mkdir&quot;&gt;mkdir&lt;/a&gt; -p&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;make_path&lt;/code&gt; 의 그들이 많은 유닉스 명령처럼, 이전에 존재하지 않으면 함수는 주어진 디렉토리를 생성 &lt;code&gt;&lt;a href=&quot;../functions/mkdir&quot;&gt;mkdir&lt;/a&gt; -p&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="072d415ade3aa9a1737c770e2e53b08afe60d304" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;match&lt;/code&gt; , &lt;code&gt;gmatch&lt;/code&gt; , &lt;code&gt;subst&lt;/code&gt; , &lt;code&gt;gsubst&lt;/code&gt; methods work like &lt;code&gt;&lt;a href=&quot;../functions/m&quot;&gt;m//&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../functions/m&quot;&gt;m//g&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../functions/s&quot;&gt;s///g&lt;/a&gt;&lt;/code&gt;, respectively, but they are not aware of any pattern, but only a literal substring.</source>
          <target state="translated">&lt;code&gt;match&lt;/code&gt; , &lt;code&gt;gmatch&lt;/code&gt; , &lt;code&gt;subst&lt;/code&gt; , &lt;code&gt;gsubst&lt;/code&gt; 방법처럼 작동 &lt;code&gt;&lt;a href=&quot;../functions/m&quot;&gt;m//&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../functions/m&quot;&gt;m//g&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../functions/s&quot;&gt;s///g&lt;/a&gt;&lt;/code&gt; , 각각,하지만 그들은 어떤 패턴을 알고 있지만 리터럴 문자열이 아니다.</target>
        </trans-unit>
        <trans-unit id="3e1a1e48900b4f1b87b0c10e8e5f854b940363da" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;match&lt;/code&gt;, &lt;code&gt;gmatch&lt;/code&gt;, &lt;code&gt;subst&lt;/code&gt;, &lt;code&gt;gsubst&lt;/code&gt; methods work like &lt;code&gt;m//&lt;/code&gt;, &lt;code&gt;m//g&lt;/code&gt;, &lt;code&gt;s///&lt;/code&gt;, &lt;code&gt;s///g&lt;/code&gt;, respectively, but they are not aware of any pattern, but only a literal substring.</source>
          <target state="translated">&lt;code&gt;match&lt;/code&gt; , &lt;code&gt;gmatch&lt;/code&gt; , &lt;code&gt;subst&lt;/code&gt; , &lt;code&gt;gsubst&lt;/code&gt; 방법처럼 작동 &lt;code&gt;m//&lt;/code&gt; , &lt;code&gt;m//g&lt;/code&gt; , &lt;code&gt;s///&lt;/code&gt; , &lt;code&gt;s///g&lt;/code&gt; , 각각,하지만 그들은 어떤 패턴을 알고 있지만 리터럴 문자열이 아니다.</target>
        </trans-unit>
        <trans-unit id="ece173d4e6c78d6e5935815075ac81cc7c62a227" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;memory&lt;/code&gt; value is not an absolute or exact limit on the memory used. &lt;code&gt;Tie::File&lt;/code&gt; objects contains some structures besides the read cache and the deferred write buffer, whose sizes are not charged against &lt;code&gt;memory&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;memory&lt;/code&gt; 값은 사용 된 메모리 의 절대 또는 정확한 제한이 아닙니다. &lt;code&gt;Tie::File&lt;/code&gt; 객체에는 읽기 캐시 및 지연된 쓰기 버퍼 외에 &lt;code&gt;memory&lt;/code&gt; 에 대해 크기가 청구되지 않는 일부 구조가 포함 됩니다 .</target>
        </trans-unit>
        <trans-unit id="e86eeea566744434422bb67f1ca33c0f448174c0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;memory&lt;/code&gt; value is not an absolute or exact limit on the memory used. &lt;code&gt;Tie::File&lt;/code&gt; objects contains some structures besides the read cache and the deferred write buffer, whose sizes are not charged against &lt;code&gt;memory&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;memory&lt;/code&gt; 값은 사용 된 메모리의 절대 또는 일치으로 없다. &lt;code&gt;Tie::File&lt;/code&gt; 객체는 읽기 캐시 및 지연된 쓰기 버퍼 외에 일부 구조를 포함하며, 크기는 &lt;code&gt;memory&lt;/code&gt; 에 대해 청구되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="19d121e9a361d9d72576c01fa16affeece8189c9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;mg_virtual&lt;/code&gt; field in the &lt;code&gt;MAGIC&lt;/code&gt; structure is a pointer to an &lt;code&gt;MGVTBL&lt;/code&gt; , which is a structure of function pointers and stands for &quot;Magic Virtual Table&quot; to handle the various operations that might be applied to that variable.</source>
          <target state="translated">&lt;code&gt;mg_virtual&lt;/code&gt; 필드 &lt;code&gt;MAGIC&lt;/code&gt; 의 구조는 포인터이다 &lt;code&gt;MGVTBL&lt;/code&gt; 에 대한 포인터이며 함수 포인터의 구조이며 해당 변수에 적용될 수있는 다양한 조작을 처리하기위한 &quot;Magic Virtual Table&quot;을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="7a8acc1e771fdb8b24c87ae131045c8c79a6a526" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;mg_virtual&lt;/code&gt; field in the &lt;code&gt;MAGIC&lt;/code&gt; structure is a pointer to an &lt;code&gt;MGVTBL&lt;/code&gt;, which is a structure of function pointers and stands for &quot;Magic Virtual Table&quot; to handle the various operations that might be applied to that variable.</source>
          <target state="translated">&lt;code&gt;MAGIC&lt;/code&gt; 구조 의 &lt;code&gt;mg_virtual&lt;/code&gt; 필드 는 함수 포인터의 구조 인 &lt;code&gt;MGVTBL&lt;/code&gt; 에 대한 포인터이며 해당 변수에 적용될 수있는 다양한 작업을 처리하는 &quot;Magic Virtual Table&quot;을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="2676c3bd8442c2414026f369d263715f307f12fa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;mkpath()&lt;/code&gt; function provide the legacy interface of &lt;code&gt;make_path()&lt;/code&gt; with a different interpretation of the arguments passed. The behaviour and return value of the function is otherwise identical to &lt;code&gt;make_path()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;mkpath()&lt;/code&gt; 함수의 기존 인터페이스를 제공 &lt;code&gt;make_path()&lt;/code&gt; 전달 된 인수의 다른 해석. 함수의 동작과 반환 값은 그렇지 않으면 &lt;code&gt;make_path()&lt;/code&gt; 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="a5023c90eb5f90ef422233e2dd5d44f7824eab24" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;module&lt;/code&gt; related one will be matched against</source>
          <target state="translated">&lt;code&gt;module&lt;/code&gt; 과 관련된 하나에 대해 일치한다</target>
        </trans-unit>
        <trans-unit id="47efd6577f009e8c4308e174f5b14a11ddfaec14" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;move&lt;/code&gt; function also takes two parameters: the current name and the intended name of the file to be moved. If the destination already exists and is a directory, and the source is not a directory, then the source file will be renamed into the directory specified by the destination.</source>
          <target state="translated">&lt;code&gt;move&lt;/code&gt; 기능은 두 개의 매개 변수 : 현재의 이름 및 파일 이름 의도가 이동한다. 대상이 이미 존재하고 디렉토리이고 소스가 디렉토리가 아닌 경우 소스 파일의 이름이 대상이 지정한 디렉토리로 바뀝니다.</target>
        </trans-unit>
        <trans-unit id="f9ad05dfff8b94ab9a9d935cf92a180ec9ff2c2a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;my&lt;/code&gt; is actually not required; you could just use:</source>
          <target state="translated">&lt;code&gt;my&lt;/code&gt; IS 실제로 필요하지 않습니다; 다음을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="38fd69505c43bd3a6104acf78cba741dff69018d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;my&lt;/code&gt; is simply a modifier on something you might assign to. So when you do assign to variables in its argument list, &lt;code&gt;my&lt;/code&gt; doesn't change whether those variables are viewed as a scalar or an array. So</source>
          <target state="translated">&lt;code&gt;my&lt;/code&gt; 단순히 할당하려하는 것에 관한 단순한 수정합니다. 당신이 인수 목록에 변수에 할당 할 때, &lt;code&gt;my&lt;/code&gt; 이러한 변수들이 스칼라 나 배열로 간주되는지 여부를 변경하지 않습니다. 그래서</target>
        </trans-unit>
        <trans-unit id="19231a9a0cfdbf1775816cb2ae3551e57856cb0c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;my&lt;/code&gt; operator declares the listed variables to be lexically confined to the enclosing block, conditional (&lt;code&gt;if&lt;/code&gt;/&lt;code&gt;unless&lt;/code&gt;/&lt;code&gt;elsif&lt;/code&gt;/&lt;code&gt;else&lt;/code&gt;), loop (&lt;code&gt;for&lt;/code&gt;/&lt;code&gt;foreach&lt;/code&gt;/&lt;code&gt;while&lt;/code&gt;/&lt;code&gt;until&lt;/code&gt;/&lt;code&gt;continue&lt;/code&gt;), subroutine, &lt;code&gt;eval&lt;/code&gt;, or &lt;code&gt;do&lt;/code&gt;/&lt;code&gt;require&lt;/code&gt;/&lt;code&gt;use&lt;/code&gt;'d file. If more than one value is listed, the list must be placed in parentheses. All listed elements must be legal lvalues. Only alphanumeric identifiers may be lexically scoped--magical built-ins like &lt;code&gt;$/&lt;/code&gt; must currently be &lt;code&gt;local&lt;/code&gt;ized with &lt;code&gt;local&lt;/code&gt; instead.</source>
          <target state="translated">&lt;code&gt;my&lt;/code&gt; 연산자 나열된 변수가 어휘 적으로 바깥 쪽 블록에 국한되는 선언 조건 ( &lt;code&gt;if&lt;/code&gt; / &lt;code&gt;unless&lt;/code&gt; / &lt;code&gt;elsif&lt;/code&gt; / &lt;code&gt;else&lt;/code&gt; ), 루프 ( &lt;code&gt;for&lt;/code&gt; / &lt;code&gt;foreach&lt;/code&gt; 는 / &lt;code&gt;while&lt;/code&gt; / &lt;code&gt;until&lt;/code&gt; / &lt;code&gt;continue&lt;/code&gt; ), 서브 루틴, &lt;code&gt;eval&lt;/code&gt; , 또는 &lt;code&gt;do&lt;/code&gt; / &lt;code&gt;require&lt;/code&gt; / &lt;code&gt;use&lt;/code&gt; 'd 파일. 둘 이상의 값이 나열되면 목록을 괄호로 묶어야합니다. 나열된 모든 요소는 유효한 lvalue 여야합니다. 영숫자 식별자 만 어휘 범위가 지정 될 수 있습니다. &lt;code&gt;$/&lt;/code&gt; 와 같은 마법의 내장 기능 은 현재 &lt;code&gt;local&lt;/code&gt; 이어야합니다.와화된 &lt;code&gt;local&lt;/code&gt; 대신.</target>
        </trans-unit>
        <trans-unit id="82300ffe8ea8c4a83935f63ac88aba05d079a68e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;name&lt;/code&gt; and &lt;code&gt;namlen&lt;/code&gt; arguments are used to associate a string with the magic, typically the name of a variable. &lt;code&gt;namlen&lt;/code&gt; is stored in the &lt;code&gt;mg_len&lt;/code&gt; field and if &lt;code&gt;name&lt;/code&gt; is non-null then either a &lt;code&gt;savepvn&lt;/code&gt; copy of &lt;code&gt;name&lt;/code&gt; or &lt;code&gt;name&lt;/code&gt; itself is stored in the &lt;code&gt;mg_ptr&lt;/code&gt; field, depending on whether &lt;code&gt;namlen&lt;/code&gt; is greater than zero or equal to zero respectively. As a special case, if &lt;code&gt;(name &amp;amp;&amp;amp; namlen == HEf_SVKEY)&lt;/code&gt; then &lt;code&gt;name&lt;/code&gt; is assumed to contain an &lt;code&gt;SV*&lt;/code&gt; and is stored as-is with its REFCNT incremented.</source>
          <target state="translated">&lt;code&gt;name&lt;/code&gt; 과 &lt;code&gt;namlen&lt;/code&gt; 인수는 마법 변수의 일반적 이름으로 문자열을 연결하는 데 사용됩니다. &lt;code&gt;namlen&lt;/code&gt; 는 에 기억되어 &lt;code&gt;mg_len&lt;/code&gt; 필드 만약 &lt;code&gt;name&lt;/code&gt; 중 다음 비 - 널 &lt;code&gt;savepvn&lt;/code&gt; 복사본 &lt;code&gt;name&lt;/code&gt; 이나 &lt;code&gt;name&lt;/code&gt; 자체에 저장된 &lt;code&gt;mg_ptr&lt;/code&gt; 의 여부에 따라, 필드 &lt;code&gt;namlen&lt;/code&gt; 가 제로보다 큰 또는 각각 제로인. 특별한 경우 &lt;code&gt;(name &amp;amp;&amp;amp; namlen == HEf_SVKEY)&lt;/code&gt; 경우 &lt;code&gt;name&lt;/code&gt; 은 &lt;code&gt;SV*&lt;/code&gt; 를 포함하는 것으로 간주되고 REFCNT가 증가 된 그대로 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="30007f38d6317a12ba00ec6e0a7e1a8a5a903fc2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;new&lt;/code&gt; , &lt;code&gt;make&lt;/code&gt; , &lt;code&gt;emake&lt;/code&gt; , &lt;code&gt;cplx&lt;/code&gt; , and &lt;code&gt;cplxe&lt;/code&gt; will also understand a single (string) argument of the forms</source>
          <target state="translated">는 &lt;code&gt;new&lt;/code&gt; , &lt;code&gt;make&lt;/code&gt; , &lt;code&gt;emake&lt;/code&gt; 는 , &lt;code&gt;cplx&lt;/code&gt; , 그리고 &lt;code&gt;cplxe&lt;/code&gt; 은 또한 형태의 단일 (문자열) 인수를 이해한다</target>
        </trans-unit>
        <trans-unit id="ed69370147fad222f299ba19e375b2bf7b98be5b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;new&lt;/code&gt; , &lt;code&gt;make&lt;/code&gt; , &lt;code&gt;emake&lt;/code&gt; , &lt;code&gt;cplx&lt;/code&gt; , and &lt;code&gt;cplxe&lt;/code&gt; will also understand the case of no arguments: this means plain zero or (0, 0).</source>
          <target state="translated">&lt;code&gt;new&lt;/code&gt; , &lt;code&gt;make&lt;/code&gt; , &lt;code&gt;emake&lt;/code&gt; 는 , &lt;code&gt;cplx&lt;/code&gt; 및 &lt;code&gt;cplxe&lt;/code&gt; 는 이 수단 일반 없거나 (0, 0) : 또한 인수의 경우를 이해할 것이다.</target>
        </trans-unit>
        <trans-unit id="6c65b03e7c38b210fdc728780536955dda01e185" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;new&lt;/code&gt; method returns a collator object.</source>
          <target state="translated">&lt;code&gt;new&lt;/code&gt; 방법은 Collator 객체를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="99af811bc283e732950a12fee28684ae132d20bc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;new&lt;/code&gt; method returns a collator object. If new() is called with no parameters, the collator should do the default collation.</source>
          <target state="translated">&lt;code&gt;new&lt;/code&gt; 방법은 Collator 객체를 반환합니다. 매개 변수없이 new ()를 호출하면 콜 레이터가 기본 콜 레이션을 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="ae0f663693f54f75cfb0a197fa36ce7749539dce" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;new&lt;/code&gt;, &lt;code&gt;make&lt;/code&gt;, &lt;code&gt;emake&lt;/code&gt;, &lt;code&gt;cplx&lt;/code&gt;, and &lt;code&gt;cplxe&lt;/code&gt; will also understand a single (string) argument of the forms</source>
          <target state="translated">는 &lt;code&gt;new&lt;/code&gt; , &lt;code&gt;make&lt;/code&gt; , &lt;code&gt;emake&lt;/code&gt; 는 , &lt;code&gt;cplx&lt;/code&gt; , 그리고 &lt;code&gt;cplxe&lt;/code&gt; 은 또한 형태의 단일 (문자열) 인수를 이해한다</target>
        </trans-unit>
        <trans-unit id="b5852a1533162d9c64ba81a3a508d931f75c8fc6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;new&lt;/code&gt;, &lt;code&gt;make&lt;/code&gt;, &lt;code&gt;emake&lt;/code&gt;, &lt;code&gt;cplx&lt;/code&gt;, and &lt;code&gt;cplxe&lt;/code&gt; will also understand the case of no arguments: this means plain zero or (0, 0).</source>
          <target state="translated">&lt;code&gt;new&lt;/code&gt; , &lt;code&gt;make&lt;/code&gt; , &lt;code&gt;emake&lt;/code&gt; 는 , &lt;code&gt;cplx&lt;/code&gt; 및 &lt;code&gt;cplxe&lt;/code&gt; 는 이 수단 일반 없거나 (0, 0) : 또한 인수의 경우를 이해할 것이다.</target>
        </trans-unit>
        <trans-unit id="66998427833c37a6112ac1501f01bdbb2d3aed3e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;new_root&lt;/code&gt; method is called when &lt;code&gt;Test2::API::Stack&lt;/code&gt; Initializes the root hub for the first time. Most formatters will simply have this call &lt;code&gt;$class-&amp;gt;new&lt;/code&gt;, which is the default behavior. Some formatters however may want to take extra action during construction of the root formatter, this is where they can do that.</source>
          <target state="translated">&lt;code&gt;new_root&lt;/code&gt; 를의 메소드가 호출 될 때 &lt;code&gt;Test2::API::Stack&lt;/code&gt; 을 초기화 처음으로 루트 허브. 대부분의 포맷터는 기본 동작 인 &lt;code&gt;$class-&amp;gt;new&lt;/code&gt; 호출 합니다. 그러나 일부 포맷터는 루트 포맷터를 구성하는 동안 추가 작업을 수행 할 수 있습니다. 여기서 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4c9d718f2247f950a12fdfc4b79710e6bdd5032a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;new_root&lt;/code&gt; method is used when constructing a root formatter. The default is to just delegate to the regular &lt;code&gt;new()&lt;/code&gt; method, most formatters can ignore this.</source>
          <target state="translated">&lt;code&gt;new_root&lt;/code&gt; 를의 루트 포매터를 구성 할 때 방법이 사용됩니다. 기본값은 일반 &lt;code&gt;new()&lt;/code&gt; 메서드에 위임하는 것 입니다. 대부분의 포맷터는이 메서드를 무시할 수 있습니다. ㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ</target>
        </trans-unit>
        <trans-unit id="aeb14c874127fdd24641fa3165f1f47f1c0c5962" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;next&lt;/code&gt; command starts the next iteration of the loop:</source>
          <target state="translated">&lt;code&gt;next&lt;/code&gt; 명령은 루프의 다음 반복을 시작합니다 :</target>
        </trans-unit>
        <trans-unit id="9b10b638a2af4c10544e1d329f2b109151bd6354" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;next&lt;/code&gt;, &lt;code&gt;exit&lt;/code&gt;, and &lt;code&gt;continue&lt;/code&gt; keywords work differently.</source>
          <target state="translated">&lt;code&gt;next&lt;/code&gt; , &lt;code&gt;exit&lt;/code&gt; , 그리고 &lt;code&gt;continue&lt;/code&gt; 키워드가 다르게 작동합니다.</target>
        </trans-unit>
        <trans-unit id="ebe7378b188460d4f95907a0bf8fffd8170aa799" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;nntpstat&lt;/code&gt; command is similar to the &lt;code&gt;article&lt;/code&gt; command except that no text is returned. When selecting by message number within a group, the &lt;code&gt;nntpstat&lt;/code&gt; command serves to set the &quot;current article pointer&quot; without sending text.</source>
          <target state="translated">&lt;code&gt;nntpstat&lt;/code&gt; 명령과 유사 &lt;code&gt;article&lt;/code&gt; 텍스트가 반환되는 것을 제외 명령. 그룹 내에서 메시지 번호로 선택할 때 &lt;code&gt;nntpstat&lt;/code&gt; 명령은 텍스트를 보내지 않고 &quot;현재 기사 포인터&quot;를 설정하는 역할을합니다.</target>
        </trans-unit>
        <trans-unit id="fef6e564421c89438d32761ce9e7776b6464e92d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;no if&lt;/code&gt; construct assumes that a module or pragma has correctly implemented an &lt;code&gt;unimport()&lt;/code&gt; method -- but most modules and pragmata have not. That explains why the &lt;code&gt;no if&lt;/code&gt; construct is of limited applicability.</source>
          <target state="translated">&lt;code&gt;no if&lt;/code&gt; 구조는 모듈 또는 프라 그마이 제대로 구현 된 것으로 가정 &lt;code&gt;unimport()&lt;/code&gt; 메소드를 -하지만 대부분의 모듈 및 pragmata하지 않았습니다. 그것은 왜 &lt;code&gt;no if&lt;/code&gt; 구조가 제한된 적용 성을 가지고 있는지를 설명합니다 .</target>
        </trans-unit>
        <trans-unit id="a4f0c6076233a4be0a02d3164def9d1f31e4b673" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;no if&lt;/code&gt; construct is mainly used to deactivate categories of warnings when those categories would produce superfluous output under specified versions of</source>
          <target state="translated">&lt;code&gt;no if&lt;/code&gt; 해당 카테고리 중 지정된 버전에 따라 불필요한 출력을 생성 할 때, 구조체는 주로 경고 비활성화 카테고리 사용</target>
        </trans-unit>
        <trans-unit id="696981a277bda71ab876e23444c84e4c429ec79c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;no lib&lt;/code&gt; statement deletes all instances of each named directory from @INC.</source>
          <target state="translated">&lt;code&gt;no lib&lt;/code&gt; 문 @ INC 각 지정된 디렉토리의 모든 인스턴스를 삭제합니다.</target>
        </trans-unit>
        <trans-unit id="acc82aa3e704adf455ebd4a8a84e684b82c4c216" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;no sort&lt;/code&gt; pragma doesn't</source>
          <target state="translated">&lt;code&gt;no sort&lt;/code&gt; pragma는하지 않습니다</target>
        </trans-unit>
        <trans-unit id="44265817f41c8d93c79e5cd86bbcac999ebebf51" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;no_proxy&lt;/code&gt; environment variable is supported in the format of a comma-separated list of domain extensions proxy should not be used for.</source>
          <target state="translated">&lt;code&gt;no_proxy&lt;/code&gt; 환경 변수 도메인 정보 프록시 쉼표로 구분 된리스트의 형식으로 지원을 위해 사용되지 않아야한다.</target>
        </trans-unit>
        <trans-unit id="9a9f846f976939c6373f157aacddb5340df46521" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;notest&lt;/code&gt; pragma skips the test part in the build process.</source>
          <target state="translated">&lt;code&gt;notest&lt;/code&gt; pragma는 빌드 프로세스에서 테스트 부분을 건너 뜁니다.</target>
        </trans-unit>
        <trans-unit id="402cbf532fb5078e8455cec160e9e8dbd08504b1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;nvsize&lt;/code&gt; element is only present for file format v2.2 and higher.</source>
          <target state="translated">&lt;code&gt;nvsize&lt;/code&gt; 의 요소는 파일 형식 버전 2.2 이상에만 존재합니다.</target>
        </trans-unit>
        <trans-unit id="c6ccaa6545aa4fe6352eb7229eabe18e5414aa4b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;o conf&lt;/code&gt; command has various bells and whistles:</source>
          <target state="translated">&lt;code&gt;o conf&lt;/code&gt; 명령은 다양한 종과 경적을 가지고 :</target>
        </trans-unit>
        <trans-unit id="20b61e97734fd2f3d96ceb929809c05aaac0cfef" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;o?&lt;/code&gt; matches at the beginning of &quot;&lt;code&gt;foo&lt;/code&gt;&quot;, and since the position in the string is not moved by the match, &lt;code&gt;o?&lt;/code&gt; would match again and again because of the &lt;code&gt;&quot;*&quot;&lt;/code&gt; quantifier. Another common way to create a similar cycle is with the looping modifier &lt;code&gt;/g&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;o?&lt;/code&gt; &quot; &lt;code&gt;foo&lt;/code&gt; &quot; 의 시작 부분과 일치 하고 문자열의 위치가 일치 항목에 의해 이동되지 않으므로 &lt;code&gt;o?&lt;/code&gt; &lt;code&gt;&quot;*&quot;&lt;/code&gt; 수량 자 때문에 몇 번이고 일치합니다 . 비슷한주기를 만드는 또 다른 일반적인 방법은 루핑 수정 자 &lt;code&gt;/g&lt;/code&gt; 를 사용하는 것입니다 .</target>
        </trans-unit>
        <trans-unit id="e1d6fb5846e3f0194a9a7d71677ca6c483145c33" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;o?&lt;/code&gt; matches at the beginning of &lt;code&gt;'foo'&lt;/code&gt; , and since the position in the string is not moved by the match, &lt;code&gt;o?&lt;/code&gt; would match again and again because of the &lt;code&gt;*&lt;/code&gt; quantifier. Another common way to create a similar cycle is with the looping modifier &lt;code&gt;//g&lt;/code&gt; :</source>
          <target state="translated">&lt;code&gt;o?&lt;/code&gt; &lt;code&gt;'foo'&lt;/code&gt; 의 시작 부분에서 일치하며 문자열의 위치가 일치하는 위치로 이동하지 않으므로 &lt;code&gt;o?&lt;/code&gt; &lt;code&gt;*&lt;/code&gt; 수량 자 때문에 반복해서 일치합니다 . 비슷한 사이클을 만드는 또 다른 일반적인 방법은 루핑 수정 자 &lt;code&gt;//g&lt;/code&gt; 를 사용하는 것입니다 .</target>
        </trans-unit>
        <trans-unit id="8add6c5a9ee20cf8238a46e09a0cd46fe0b061c5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;obj&lt;/code&gt; argument is stored in the &lt;code&gt;mg_obj&lt;/code&gt; field of the &lt;code&gt;MAGIC&lt;/code&gt; structure. If it is not the same as the &lt;code&gt;sv&lt;/code&gt; argument, the reference count of the &lt;code&gt;obj&lt;/code&gt; object is incremented. If it is the same, or if the &lt;code&gt;how&lt;/code&gt; argument is &lt;code&gt;PERL_MAGIC_arylen&lt;/code&gt; , or if it is a NULL pointer, then &lt;code&gt;obj&lt;/code&gt; is merely stored, without the reference count being incremented.</source>
          <target state="translated">&lt;code&gt;obj&lt;/code&gt; 인수가 저장된다 &lt;code&gt;mg_obj&lt;/code&gt; 에서 의 필드 &lt;code&gt;MAGIC&lt;/code&gt; 의 구조. &lt;code&gt;sv&lt;/code&gt; 인수 와 동일하지 않으면 &lt;code&gt;obj&lt;/code&gt; 객체 의 참조 횟수 가 증가합니다. 동일하거나 &lt;code&gt;how&lt;/code&gt; 인수가 &lt;code&gt;PERL_MAGIC_arylen&lt;/code&gt; 또는 NULL 포인터 인 경우 참조 카운트가 증가하지 않고 &lt;code&gt;obj&lt;/code&gt; 가 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="dca84bbcee637e6ee5a3f3b53c079982ba47b456" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;obj&lt;/code&gt; argument is stored in the &lt;code&gt;mg_obj&lt;/code&gt; field of the &lt;code&gt;MAGIC&lt;/code&gt; structure. If it is not the same as the &lt;code&gt;sv&lt;/code&gt; argument, the reference count of the &lt;code&gt;obj&lt;/code&gt; object is incremented. If it is the same, or if the &lt;code&gt;how&lt;/code&gt; argument is &lt;code&gt;PERL_MAGIC_arylen&lt;/code&gt;, &lt;code&gt;PERL_MAGIC_regdatum&lt;/code&gt;, &lt;code&gt;PERL_MAGIC_regdata&lt;/code&gt;, or if it is a NULL pointer, then &lt;code&gt;obj&lt;/code&gt; is merely stored, without the reference count being incremented.</source>
          <target state="translated">&lt;code&gt;obj&lt;/code&gt; 인수가 저장된다 &lt;code&gt;mg_obj&lt;/code&gt; 에서 의 필드 &lt;code&gt;MAGIC&lt;/code&gt; 의 구조. &lt;code&gt;sv&lt;/code&gt; 인수 와 같지 않으면 &lt;code&gt;obj&lt;/code&gt; 객체 의 참조 횟수 가 증가합니다. 동일하거나 &lt;code&gt;how&lt;/code&gt; 인수가 &lt;code&gt;PERL_MAGIC_arylen&lt;/code&gt; , &lt;code&gt;PERL_MAGIC_regdatum&lt;/code&gt; , &lt;code&gt;PERL_MAGIC_regdata&lt;/code&gt; 이거나 NULL 포인터 인 경우 &lt;code&gt;obj&lt;/code&gt; 는 참조 횟수가 증가하지 않고 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="d80e9ad5ac5b4640a379da6ded2e4e7da8ef85d9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;op-entry&lt;/code&gt; , &lt;code&gt;loading-file&lt;/code&gt; , and &lt;code&gt;loaded-file&lt;/code&gt; probes were added.</source>
          <target state="translated">&lt;code&gt;op-entry&lt;/code&gt; , &lt;code&gt;loading-file&lt;/code&gt; 및 &lt;code&gt;loaded-file&lt;/code&gt; 프로브가 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="f888b5670cd3a579164b6986631d6a361f670ffe" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;op-entry&lt;/code&gt;, &lt;code&gt;loading-file&lt;/code&gt;, and &lt;code&gt;loaded-file&lt;/code&gt; probes were added.</source>
          <target state="translated">&lt;code&gt;op-entry&lt;/code&gt; , &lt;code&gt;loading-file&lt;/code&gt; 및 &lt;code&gt;loaded-file&lt;/code&gt; 프로브가 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="8a6cb40ac71f3af050d6baa8551cc82228d3a4f0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;open(FOO, &quot;|-&quot;)&lt;/code&gt; and &lt;code&gt;open(BAR, &quot;-|&quot;)&lt;/code&gt; constructs are not yet implemented. This limitation can be easily worked around in new code by creating a pipe explicitly. The following example shows how to write to a forked child:</source>
          <target state="translated">&lt;code&gt;open(FOO, &quot;|-&quot;)&lt;/code&gt; 및 &lt;code&gt;open(BAR, &quot;-|&quot;)&lt;/code&gt; 구조는 아직 구현되지 않습니다. 이 제한은 파이프를 명시 적으로 생성하여 새 코드에서 쉽게 해결할 수 있습니다. 다음 예제는 분기 된 자식에게 쓰는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="fd1d994756f4894d537087cc5686928a7d382dd8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;open&lt;/code&gt; pragma serves as one of the interfaces to declare default &quot;layers&quot; (previously known as &quot;disciplines&quot;) for all I/O. Any open(), readpipe() (aka qx//) and similar operators found within the lexical scope of this pragma will use the declared defaults via the &lt;a href=&quot;perlvar#%24%7B%5EOPEN%7D&quot;&gt;&lt;code&gt;${^OPEN}&lt;/code&gt;&lt;/a&gt; variable.</source>
          <target state="translated">&lt;code&gt;open&lt;/code&gt; 프라그 모든 I / O를위한 (이전 &quot;훈련&quot;라고도 함)의 기본 &quot;층&quot;을 선언하는 인터페이스 중 하나로서 기능한다. 이 pragma의 어휘 범위 내에있는 모든 open (), readpipe () (일명 qx //) 및 유사한 연산자는 &lt;a href=&quot;perlvar#%24%7B%5EOPEN%7D&quot;&gt; &lt;code&gt;${^OPEN}&lt;/code&gt; &lt;/a&gt; 변수 를 통해 선언 된 기본값을 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="5eb381293ba1d62c6bb1f8b641a8f8c1b0afc8bf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ord&lt;/code&gt; and &lt;code&gt;chr&lt;/code&gt; functions work transparently on all codepoints, not just on ASCII alone &amp;mdash; nor in fact, not even just on Unicode alone.</source>
          <target state="translated">&lt;code&gt;ord&lt;/code&gt; 및 &lt;code&gt;chr&lt;/code&gt; 함수는 혼자가 아니라 ASCII에 모든 코드 포인트에 투명하게 작동 -도 사실조차 혼자 유니 코드에.</target>
        </trans-unit>
        <trans-unit id="df48f02864fb5733b7bb66ec5f70b228889d68c2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;os_unsupported()&lt;/code&gt; function provides a way to correctly exit your &lt;code&gt;Makefile.PL&lt;/code&gt; before calling &lt;code&gt;WriteMakefile&lt;/code&gt;. It is essentially a &lt;code&gt;die&lt;/code&gt; with the message &quot;OS unsupported&quot;.</source>
          <target state="translated">&lt;code&gt;os_unsupported()&lt;/code&gt; 함수를 올바르게 종료 할 수있는 방법 제공 &lt;code&gt;Makefile.PL&lt;/code&gt; 을 호출하기 전에 &lt;code&gt;WriteMakefile&lt;/code&gt; 을 . 본질적으로 &quot;OS unsupported&quot;라는 메시지가 있는 &lt;code&gt;die&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="2f6e73c286e870319f1bf5046f6a37ff92d8c6ee" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;overloading&lt;/code&gt; pragma can be used to enable or disable overloaded operations within a lexical scope - see &lt;a href=&quot;overloading&quot;&gt;overloading&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;overloading&lt;/code&gt; 를 참조하십시오 - 프라그를 사용하거나 어휘 범위 내에서 비활성화 오버로드 작업이 사용할 수있는 &lt;a href=&quot;overloading&quot;&gt;오버로드&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="20efdbd26d83eb3c5a0a6712c2d992c599e01133" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;p&lt;/code&gt; and &lt;code&gt;P&lt;/code&gt; formats should be used with care. Since Perl has no way of checking whether the value passed to &lt;a href=&quot;#unpack-TEMPLATE%2CEXPR&quot;&gt;&lt;code&gt;unpack&lt;/code&gt;&lt;/a&gt; corresponds to a valid memory location, passing a pointer value that's not known to be valid is likely to have disastrous consequences.</source>
          <target state="translated">&lt;code&gt;p&lt;/code&gt; 및 &lt;code&gt;P&lt;/code&gt; 형식은주의해서 사용해야합니다. Perl은 &lt;a href=&quot;#unpack-TEMPLATE%2CEXPR&quot;&gt; &lt;code&gt;unpack&lt;/code&gt; 에&lt;/a&gt; 전달 된 값 이 유효한 메모리 위치에 해당 하는지 확인할 방법이 없기 때문에 유효하지 않은 포인터 값을 전달하면 재앙을 초래할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="22d5bf30a5d50f38a10cfc2d7578244917da917c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;p&lt;/code&gt; and &lt;code&gt;P&lt;/code&gt; formats should be used with care. Since Perl has no way of checking whether the value passed to &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack()&lt;/a&gt;&lt;/code&gt; corresponds to a valid memory location, passing a pointer value that's not known to be valid is likely to have disastrous consequences.</source>
          <target state="translated">&lt;code&gt;p&lt;/code&gt; 및 &lt;code&gt;P&lt;/code&gt; 형식은주의해서 사용해야합니다. Perl은 &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack()&lt;/a&gt;&lt;/code&gt; 전달 된 값 이 유효한 메모리 위치에 해당 하는지 여부를 확인할 수있는 방법이 없으므로 유효하지 않은 포인터 값을 전달하면 치명적인 결과가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="edad35170db1a049ca495222b3c0b5b8c415db1c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;p&lt;/code&gt; and &lt;code&gt;P&lt;/code&gt; formats should be used with care. Since Perl has no way of checking whether the value passed to &lt;code&gt;&lt;a href=&quot;unpack&quot;&gt;unpack()&lt;/a&gt;&lt;/code&gt; corresponds to a valid memory location, passing a pointer value that's not known to be valid is likely to have disastrous consequences.</source>
          <target state="translated">&lt;code&gt;p&lt;/code&gt; 및 &lt;code&gt;P&lt;/code&gt; 형식은주의해서 사용해야합니다. Perl은 &lt;code&gt;&lt;a href=&quot;unpack&quot;&gt;unpack()&lt;/a&gt;&lt;/code&gt; 전달 된 값 이 유효한 메모리 위치에 해당 하는지 여부를 확인할 수있는 방법이 없으므로 유효하지 않은 포인터 값을 전달하면 치명적인 결과가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bc14cc8e3b01ab283787dc8c289608a88dca9ea7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;p&lt;/code&gt; format packs a pointer to a null-terminated string. You are responsible for ensuring that the string is not a temporary value, as that could potentially get deallocated before you got around to using the packed result. The &lt;code&gt;P&lt;/code&gt; format packs a pointer to a structure of the size indicated by the length. A null pointer is created if the corresponding value for &lt;code&gt;p&lt;/code&gt; or &lt;code&gt;P&lt;/code&gt; is &lt;a href=&quot;#undef-EXPR&quot;&gt;&lt;code&gt;undef&lt;/code&gt;&lt;/a&gt;; similarly with &lt;a href=&quot;#unpack-TEMPLATE%2CEXPR&quot;&gt;&lt;code&gt;unpack&lt;/code&gt;&lt;/a&gt;, where a null pointer unpacks into &lt;a href=&quot;#undef-EXPR&quot;&gt;&lt;code&gt;undef&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;p&lt;/code&gt; 형식은 null로 종료 된 문자열에 대한 포인터를 팩. 패킹 된 결과를 사용하기 전에 잠재적으로 할당 해제 될 수 있으므로 문자열이 임시 값이 아닌지 확인해야합니다. &lt;code&gt;P&lt;/code&gt; 의 형태가 길이에 의해 지시 된 크기의 구조에 대한 포인터를 팩. &lt;code&gt;p&lt;/code&gt; 또는 &lt;code&gt;P&lt;/code&gt; 에 해당하는 값 이 &lt;a href=&quot;#undef-EXPR&quot;&gt; &lt;code&gt;undef&lt;/code&gt; &lt;/a&gt; 이면 널 포인터가 생성됩니다 . &lt;a href=&quot;#unpack-TEMPLATE%2CEXPR&quot;&gt; &lt;code&gt;unpack&lt;/code&gt; &lt;/a&gt; 과 마찬가지로 null 포인터가 &lt;a href=&quot;#undef-EXPR&quot;&gt; &lt;code&gt;undef&lt;/code&gt; &lt;/a&gt; 로 압축 해제됩니다 .</target>
        </trans-unit>
        <trans-unit id="a342dbe90eb2666a6875f71f1fa1cb3e6e7241a5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;p&lt;/code&gt; format packs a pointer to a null-terminated string. You are responsible for ensuring that the string is not a temporary value, as that could potentially get deallocated before you got around to using the packed result. The &lt;code&gt;P&lt;/code&gt; format packs a pointer to a structure of the size indicated by the length. A null pointer is created if the corresponding value for &lt;code&gt;p&lt;/code&gt; or &lt;code&gt;P&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;; similarly with unpack(), where a null pointer unpacks into &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;p&lt;/code&gt; 형식은 null로 종료 된 문자열에 대한 포인터를 팩. 압축 된 결과를 사용하기 전에 할당 해제 될 수 있으므로 문자열이 임시 값이 아닌지 확인해야합니다. &lt;code&gt;P&lt;/code&gt; 의 형태가 길이에 의해 지시 된 크기의 구조에 대한 포인터를 팩. &lt;code&gt;p&lt;/code&gt; 또는 &lt;code&gt;P&lt;/code&gt; 의 해당 값 이 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 인 경우 널 포인터가 작성됩니다 . null 포인터가 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 로 압축 해제되는 unpack ()과 유사 합니다.</target>
        </trans-unit>
        <trans-unit id="e2e0e3d979b5c34967b7ced67a74a5510cb236cc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;p&lt;/code&gt; format packs a pointer to a null-terminated string. You are responsible for ensuring that the string is not a temporary value, as that could potentially get deallocated before you got around to using the packed result. The &lt;code&gt;P&lt;/code&gt; format packs a pointer to a structure of the size indicated by the length. A null pointer is created if the corresponding value for &lt;code&gt;p&lt;/code&gt; or &lt;code&gt;P&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;; similarly with unpack(), where a null pointer unpacks into &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;p&lt;/code&gt; 형식은 null로 종료 된 문자열에 대한 포인터를 팩. 압축 된 결과를 사용하기 전에 할당 해제 될 수 있으므로 문자열이 임시 값이 아닌지 확인해야합니다. &lt;code&gt;P&lt;/code&gt; 의 형태가 길이에 의해 지시 된 크기의 구조에 대한 포인터를 팩. &lt;code&gt;p&lt;/code&gt; 또는 &lt;code&gt;P&lt;/code&gt; 의 해당 값 이 &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 인 경우 널 포인터가 작성됩니다 . null 포인터가 &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 로 압축 해제되는 unpack ()과 유사 합니다.</target>
        </trans-unit>
        <trans-unit id="6cd57772719120a4cc44e7170b8984f064c5142a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;paren&lt;/code&gt; parameter will be &lt;code&gt;1&lt;/code&gt; for &lt;code&gt;$1&lt;/code&gt; , &lt;code&gt;2&lt;/code&gt; for &lt;code&gt;$2&lt;/code&gt; and so forth, and have these symbolic values for the special variables:</source>
          <target state="translated">&lt;code&gt;paren&lt;/code&gt; 매개 변수는있을 것이다 &lt;code&gt;1&lt;/code&gt; 위해 &lt;code&gt;$1&lt;/code&gt; , &lt;code&gt;2&lt;/code&gt; 에 대한 &lt;code&gt;$2&lt;/code&gt; 등을하고, 그리고 특수 변수에 대한 이러한 상징적 값이 :</target>
        </trans-unit>
        <trans-unit id="02d079f599dacaf5683c95e116afdd6471bd3c7f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;paren&lt;/code&gt; parameter will be &lt;code&gt;1&lt;/code&gt; for &lt;code&gt;$1&lt;/code&gt;, &lt;code&gt;2&lt;/code&gt; for &lt;code&gt;$2&lt;/code&gt; and so forth, and have these symbolic values for the special variables:</source>
          <target state="translated">&lt;code&gt;paren&lt;/code&gt; 매개 변수는있을 것이다 &lt;code&gt;1&lt;/code&gt; 위해 &lt;code&gt;$1&lt;/code&gt; , &lt;code&gt;2&lt;/code&gt; 에 대한 &lt;code&gt;$2&lt;/code&gt; 등을하고, 그리고 특수 변수에 대한 이러한 상징적 값이 :</target>
        </trans-unit>
        <trans-unit id="3d81fd54d838a03f6a557d9a972a797c3d53d12e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;parse()&lt;/code&gt; method takes in anything that might be a version and returns a corresponding version object, doing any necessary conversion along the way.</source>
          <target state="translated">&lt;code&gt;parse()&lt;/code&gt; 메소드는 버전이 길을 따라 필요한 변환을하고, 해당 버전의 객체를 반환 할 수 아무것도합니다.</target>
        </trans-unit>
        <trans-unit id="dc153b0fac70aafae4ce7fa649dc1cbd578affc8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pass*&lt;/code&gt; and &lt;code&gt;fail*&lt;/code&gt; are optimal if they meet your situation, using one of them will always be the most optimal. That said they are optimal by eliminating many features.</source>
          <target state="translated">&lt;code&gt;pass*&lt;/code&gt; 와 &lt;code&gt;fail*&lt;/code&gt; 그들은 항상 최적의 것 중 하나를 사용하여 상황을 충족하는 경우 최적입니다. 즉, 많은 기능을 제거하여 최적이라고 말했습니다.</target>
        </trans-unit>
        <trans-unit id="49927bc872809a6862bb2b73a995c90fcc3d0b9a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pattern&lt;/code&gt; parameter is the scalar that was used as the pattern. Previous versions of Perl would pass two &lt;code&gt;char*&lt;/code&gt; indicating the start and end of the stringified pattern; the following snippet can be used to get the old parameters:</source>
          <target state="translated">&lt;code&gt;pattern&lt;/code&gt; 파라미터는 패턴으로 사용 된 스칼라이다. 이전 버전의 Perl은 문자열 화 된 패턴의 시작과 끝을 나타내는 두 개의 &lt;code&gt;char*&lt;/code&gt; 를 전달합니다 . 다음 스 니펫을 사용하여 이전 매개 변수를 가져올 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="db17bf3bf687b24a2fdb5945dac7eff0732c46a0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;perl&lt;/code&gt; related one will be matched against &lt;code&gt;$^X&lt;/code&gt; (but with the absolute path).</source>
          <target state="translated">&lt;code&gt;perl&lt;/code&gt; 관련된 하나에 대해 일치한다 &lt;code&gt;$^X&lt;/code&gt; (그러나 절대 경로).</target>
        </trans-unit>
        <trans-unit id="5f5ee6756d1fcb64032b91cf7b890baca1e81e1a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;perl_alloc&lt;/code&gt; and &lt;code&gt;perl_clone&lt;/code&gt; API functions will automatically set the TLS slot to the interpreter they created, so that there is no need to do anything special if the interpreter is always accessed in the same thread that created it, and that thread did not create or call any other interpreters afterwards. If that is not the case, you have to set the TLS slot of the thread before calling any functions in the Perl API on that particular interpreter. This is done by calling the &lt;code&gt;PERL_SET_CONTEXT&lt;/code&gt; macro in that thread as the first thing you do:</source>
          <target state="translated">&lt;code&gt;perl_alloc&lt;/code&gt; 및 &lt;code&gt;perl_clone&lt;/code&gt; API 함수를 자동으로 통역이 항상 그것을 만든 동일한 스레드에서 액세스 할 경우 아무것도 특별 할 필요가 없도록, 자신이 만든 인터프리터에 TLS 슬롯을 설정하며, 해당 스레드를 만들거나 전화하지 않았다 그 후 다른 통역사들. 그렇지 않은 경우 특정 인터프리터에서 Perl API의 함수를 호출하기 전에 스레드의 TLS 슬롯을 설정해야합니다. 이 작업 은 해당 스레드에서 &lt;code&gt;PERL_SET_CONTEXT&lt;/code&gt; 매크로를 가장 먼저 수행하여 수행됩니다 .</target>
        </trans-unit>
        <trans-unit id="97a02a3c258cf1103ffa6170e07625f674c4d40e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;perldoc&lt;/code&gt; command line tool is part of the standard Perl distribution. To read the perlfaq:</source>
          <target state="translated">&lt;code&gt;perldoc&lt;/code&gt; 을의 명령 줄 도구는 표준 펄 배포판의 일부입니다. perlfaq를 읽으려면 :</target>
        </trans-unit>
        <trans-unit id="50ad124de63dc48f75c0f2545fa281fab8aa3db8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;phase-change&lt;/code&gt; probe was added.</source>
          <target state="translated">&lt;code&gt;phase-change&lt;/code&gt; 프로브를 첨가 하였다.</target>
        </trans-unit>
        <trans-unit id="04bb003d93ac0037aab6a2f453c58a6ac0c41912" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;plugin_list&lt;/code&gt; configuration parameter holds a list of strings of the form</source>
          <target state="translated">&lt;code&gt;plugin_list&lt;/code&gt; 의 구성 파라미터 형태의 스트링의리스트를 보유</target>
        </trans-unit>
        <trans-unit id="a0b743645c5c1c48eeb64bb89437f58e73a4be52" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;port&lt;/code&gt; argument is only valid for a udp, tcp or stream ping, and will not do what you think it does. ping returns true when we get a &quot;Connection refused&quot;! The default is the echo port.</source>
          <target state="translated">&lt;code&gt;port&lt;/code&gt; 인수는 UDP, TCP 또는 스트림 핑 (ping)에 대해서만 유효하고, 당신이하지 생각하지 않습니다. ping은 &quot;연결이 거부 됨&quot;을 받으면 참을 반환합니다! 기본값은 에코 포트입니다.</target>
        </trans-unit>
        <trans-unit id="a63eacc1cc33a9d0218e84fb4e04a60cb849a989" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pp_tie&lt;/code&gt; does a &lt;code&gt;CATCH_SET(TRUE)&lt;/code&gt; , then starts a second runops loop to execute the body of &lt;code&gt;TIEARRAY&lt;/code&gt; . When it executes the entertry op on line 3, &lt;code&gt;CATCH_GET&lt;/code&gt; is true, so &lt;code&gt;pp_entertry&lt;/code&gt; calls &lt;code&gt;docatch&lt;/code&gt; which does a &lt;code&gt;JMPENV_PUSH&lt;/code&gt; and starts a third runops loop, which then executes the die op. At this point the C call stack looks like this:</source>
          <target state="translated">&lt;code&gt;pp_tie&lt;/code&gt; 는 수행 &lt;code&gt;CATCH_SET(TRUE)&lt;/code&gt; , 다음의 본문 실행할 제 runops 루프 시작 &lt;code&gt;TIEARRAY&lt;/code&gt; 를 . 그것은 라인 (3)에 entertry 연산을 실행하면, &lt;code&gt;CATCH_GET&lt;/code&gt; 가 되도록 참 &lt;code&gt;pp_entertry&lt;/code&gt; 가 호출 &lt;code&gt;docatch&lt;/code&gt; 수행 &lt;code&gt;JMPENV_PUSH&lt;/code&gt; 을 하고 상기 다이 연산을 실행하는 제 runops 루프를 시작한다. 이 시점에서 C 호출 스택은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="158d812c1686b0935b414c31c5100461991aaa3b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pp_tie&lt;/code&gt; does a &lt;code&gt;CATCH_SET(TRUE)&lt;/code&gt;, then starts a second runops loop to execute the body of &lt;code&gt;TIEARRAY&lt;/code&gt;. When it executes the entertry op on line 3, &lt;code&gt;CATCH_GET&lt;/code&gt; is true, so &lt;code&gt;pp_entertry&lt;/code&gt; calls &lt;code&gt;docatch&lt;/code&gt; which does a &lt;code&gt;JMPENV_PUSH&lt;/code&gt; and starts a third runops loop, which then executes the die op. At this point the C call stack looks like this:</source>
          <target state="translated">&lt;code&gt;pp_tie&lt;/code&gt; 는 수행 &lt;code&gt;CATCH_SET(TRUE)&lt;/code&gt; , 다음의 본문 실행할 제 runops 루프 시작 &lt;code&gt;TIEARRAY&lt;/code&gt; 를 . 그것은 라인 (3)에 entertry 연산을 실행하면, &lt;code&gt;CATCH_GET&lt;/code&gt; 가 되도록 참 &lt;code&gt;pp_entertry&lt;/code&gt; 가 호출 &lt;code&gt;docatch&lt;/code&gt; 수행 &lt;code&gt;JMPENV_PUSH&lt;/code&gt; 을 하고 상기 다이 연산을 실행하는 제 runops 루프를 시작한다. 이 시점에서 C 호출 스택은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="bdfe7fb594151a128519964cf51c5b075b56f64a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;prereqs&lt;/code&gt; key in the top-level metadata and within &lt;code&gt;optional_features&lt;/code&gt; define the relationship between a distribution and other packages. The prereq spec structure is a hierarchical data structure which divides prerequisites into</source>
          <target state="translated">&lt;code&gt;prereqs&lt;/code&gt; 최상위 메타 데이터와 내부 키 &lt;code&gt;optional_features&lt;/code&gt; 가 분포하고 다른 패키지 사이의 관계를 정의한다. 전제 조건 스펙 구조는 전제 조건을 다음으로 나누는 계층 적 데이터 구조입니다.</target>
        </trans-unit>
        <trans-unit id="6f6012284b93fc2045dcbcea769da43a4a9d853f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;prompt()&lt;/code&gt; function provides an easy way to request user input used to write a makefile. It displays the $message as a prompt for input. If a $default is provided it will be used as a default. The function returns the $value selected by the user.</source>
          <target state="translated">&lt;code&gt;prompt()&lt;/code&gt; 함수는 메이크를 작성하는 데 요구 사용자 입력하는 쉬운 방법을 제공한다. 입력 메시지로 $ message를 표시합니다. $ default가 제공되면 기본값으로 사용됩니다. 이 함수는 사용자가 선택한 $ 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="251a318ac7ae399ceb208b84bc39666205a2a077" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;prove&lt;/code&gt; command supports a &lt;code&gt;--state&lt;/code&gt; option that instructs it to store persistent state across runs. This module encapsulates the results for a single test suite run.</source>
          <target state="translated">는 &lt;code&gt;prove&lt;/code&gt; 명령 지원에게 &lt;code&gt;--state&lt;/code&gt; 가 실행시 영구적 인 상태를 저장하도록 지시한다는 옵션을 선택합니다. 이 모듈은 단일 테스트 스위트 실행에 대한 결과를 캡슐화합니다.</target>
        </trans-unit>
        <trans-unit id="225b0b123ca124089a53e65a14a10e06fffd421b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;prove&lt;/code&gt; command supports a &lt;code&gt;--state&lt;/code&gt; option that instructs it to store persistent state across runs. This module encapsulates the results for a single test.</source>
          <target state="translated">는 &lt;code&gt;prove&lt;/code&gt; 명령 지원에게 &lt;code&gt;--state&lt;/code&gt; 가 실행시 영구적 인 상태를 저장하도록 지시한다는 옵션을 선택합니다. 이 모듈은 단일 테스트 결과를 요약합니다.</target>
        </trans-unit>
        <trans-unit id="630214733172c835a26947747354eba32ad3911c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;prove&lt;/code&gt; command supports a &lt;code&gt;--state&lt;/code&gt; option that instructs it to store persistent state across runs. This module implements that state and the operations that may be performed on it.</source>
          <target state="translated">는 &lt;code&gt;prove&lt;/code&gt; 명령 지원에게 &lt;code&gt;--state&lt;/code&gt; 가 실행시 영구적 인 상태를 저장하도록 지시한다는 옵션을 선택합니다. 이 모듈은 해당 상태 및 수행 될 수있는 작업을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="ebc7b6c659bfd339fe90d4f36223bdf0f00d2207" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;qr//&lt;/code&gt; operator showed up in perl 5.005. It compiles a regular expression, but doesn't apply it. When you use the pre-compiled version of the regex, perl does less work. In this example, I inserted a &lt;code&gt;map&lt;/code&gt; to turn each pattern into its pre-compiled form. The rest of the script is the same, but faster:</source>
          <target state="translated">&lt;code&gt;qr//&lt;/code&gt; 연산자는 펄 5.005로 나타났다. 정규식을 컴파일하지만 적용하지는 않습니다. 미리 컴파일 된 정규식 버전을 사용하면 perl이 작동하지 않습니다. 이 예에서는 각 패턴을 미리 컴파일 된 형식으로 변환 하는 &lt;code&gt;map&lt;/code&gt; 을 삽입했습니다 . 나머지 스크립트는 동일하지만 더 빠릅니다.</target>
        </trans-unit>
        <trans-unit id="89a8c0b3ff5aa42089f6c9d44d37572f7b89a880" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;re '/flags'&lt;/code&gt; pragma (introduced in Perl 5.14) turns on the given regular expression flags until the end of the lexical scope. See &lt;a href=&quot;re#%27%2Fflags%27-mode&quot;&gt;&quot;'/flags' mode&quot; in re&lt;/a&gt; for more detail.</source>
          <target state="translated">&lt;code&gt;re '/flags'&lt;/code&gt; (5.14 펄 도입) 프라그는 어휘 범위의 끝까지 지정된 정규 표현 플래그를 온. 자세한 내용 &lt;a href=&quot;re#%27%2Fflags%27-mode&quot;&gt;은 re의 &quot; '/ flags'모드&quot;를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="16ee1aae608f6953af89e472ae38b6d9068b7d8b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;re '/flags'&lt;/code&gt; pragma (introduced in Perl 5.14) turns on the given regular expression flags until the end of the lexical scope. See &lt;a href=&quot;re#'%2fflags'-mode&quot;&gt;'/flags' mode in re&lt;/a&gt; for more detail.</source>
          <target state="translated">그만큼 &lt;code&gt;re '/flags'&lt;/code&gt; (5.14 펄 도입) 프라그는 어휘 범위의 끝까지 지정된 정규 표현 플래그를 온. 자세한 내용은 &lt;a href=&quot;re#'%2fflags'-mode&quot;&gt;'/ 플래그'모드를 다시&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="8026b2e7b59b6835c618b76fac10379af835df78" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;read&lt;/code&gt; will</source>
          <target state="translated">&lt;code&gt;read&lt;/code&gt; 의지</target>
        </trans-unit>
        <trans-unit id="eabbdc8a005d2bf3f21650b9e863366189c7ced7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;recent&lt;/code&gt; command downloads a list of recent uploads to CPAN and displays them</source>
          <target state="translated">&lt;code&gt;recent&lt;/code&gt; 명령은 CPAN와 디스플레이를 최근 업로드 목록을 다운로드</target>
        </trans-unit>
        <trans-unit id="3ae27e036bb44d621cb68002f9a110e07c700371" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;recipient&lt;/code&gt; method can also pass additional case-sensitive OPTIONS as an anonymous hash using key and value pairs. Possible options are:</source>
          <target state="translated">그만큼 &lt;code&gt;recipient&lt;/code&gt; 방법은 키 및 값 쌍을 이용하여 익명 해시 추가적인 OPTIONS 대소 문자를 전달할 수있다. 가능한 옵션은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="fbfa5e6131ec26898b29be346c8692d308b580c5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;redo&lt;/code&gt; command restarts the loop block without evaluating the conditional again. The &lt;code&gt;continue&lt;/code&gt; block, if any, is</source>
          <target state="translated">&lt;code&gt;redo&lt;/code&gt; 명령 다시 조건을 평가하지 않고 루프를 재시작 블록. 은 &lt;code&gt;continue&lt;/code&gt; , 어떤 경우, 블록을</target>
        </trans-unit>
        <trans-unit id="5f6b672315250ddc806f0b1d734bf40a266a6de9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;regexp&lt;/code&gt; structure described in &lt;a href=&quot;perlreapi&quot;&gt;perlreapi&lt;/a&gt; is common to all regex engines. Two of its fields are intended for the private use of the regex engine that compiled the pattern. These are the &lt;code&gt;intflags&lt;/code&gt; and pprivate members. The &lt;code&gt;pprivate&lt;/code&gt; is a void pointer to an arbitrary structure whose use and management is the responsibility of the compiling engine. perl will never modify either of these values. In the case of the stock engine the structure pointed to by &lt;code&gt;pprivate&lt;/code&gt; is called &lt;code&gt;regexp_internal&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;regexp&lt;/code&gt; 에 기술 된 구조 &lt;a href=&quot;perlreapi&quot;&gt;perlreapi는&lt;/a&gt; 모든 정규식 엔진에 일반적입니다. 해당 필드 중 두 개는 패턴을 컴파일 한 정규식 엔진의 개인용으로 사용됩니다. 이들은 &lt;code&gt;intflags&lt;/code&gt; 및 개인 멤버입니다. &lt;code&gt;pprivate&lt;/code&gt; 는 사용 및 관리 컴파일 엔진의 책임이다 임의의 구조에 대한 무효 포인터입니다. perl은 이러한 값 중 어느 것도 수정하지 않습니다. 재고 엔진의 경우 &lt;code&gt;pprivate&lt;/code&gt; 가 가리키는 구조 가 이라고 &lt;code&gt;regexp_internal&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="43d7f5d7cf7b3bd50ec33b3f8b3d3e3e1b16ccb8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;regexp&lt;/code&gt; structure described in &lt;a href=&quot;perlreapi&quot;&gt;perlreapi&lt;/a&gt; is common to all regex engines. Two of its fields are intended for the private use of the regex engine that compiled the pattern. These are the &lt;code&gt;intflags&lt;/code&gt; and pprivate members. The &lt;code&gt;pprivate&lt;/code&gt; is a void pointer to an arbitrary structure whose use and management is the responsibility of the compiling engine. perl will never modify either of these values. In the case of the stock engine the structure pointed to by &lt;code&gt;pprivate&lt;/code&gt; is called &lt;code&gt;regexp_internal&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;regexp&lt;/code&gt; 에 기술 된 구조 &lt;a href=&quot;perlreapi&quot;&gt;perlreapi는&lt;/a&gt; 모든 정규식 엔진에 일반적입니다. 해당 필드 중 두 개는 패턴을 컴파일 한 정규식 엔진을 개인적으로 사용하기위한 것입니다. 이들은 &lt;code&gt;intflags&lt;/code&gt; 및 pprivate 구성원입니다. &lt;code&gt;pprivate&lt;/code&gt; 는 사용 및 관리 컴파일 엔진의 책임이다 임의의 구조에 대한 무효 포인터입니다. perl은 이러한 값을 수정하지 않습니다. 스톡 엔진의 경우 &lt;code&gt;pprivate&lt;/code&gt; 가 가리키는 구조를 regexp_internal 이라고 &lt;code&gt;regexp_internal&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="70e74666fabd3ef514f919b776494b74805eeb39" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;register&lt;/code&gt; method allows for the registration of a message handler for a given subroutine. The full subroutine name including the package should be used.</source>
          <target state="translated">&lt;code&gt;register&lt;/code&gt; 방법은 소정의 서브 루틴을위한 메시지 핸들러의 등록을 허용한다. 패키지를 포함한 전체 서브 루틴 이름을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="e4f7500531b634ca33f77ec64b4dcfc7b5a94686" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;release_status&lt;/code&gt; field &lt;b&gt;must&lt;/b&gt; have one of the following values:</source>
          <target state="translated">&lt;code&gt;release_status&lt;/code&gt; 의 필드가 &lt;b&gt;있어야&lt;/b&gt; 다음 값 중 하나를 가지고 :</target>
        </trans-unit>
        <trans-unit id="a2292ba9ae057df1902ceef2446c66c533b62b3a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;remove_tree&lt;/code&gt; function deletes the given directories and any files and subdirectories they might contain, much like the Unix command &lt;code&gt;rm -r&lt;/code&gt; or &lt;code&gt;del /s&lt;/code&gt; on Windows.</source>
          <target state="translated">&lt;code&gt;remove_tree&lt;/code&gt; 의 기능은 많은 유닉스 명령처럼, 주어진 포함되는 디렉토리와 수있는 모든 파일과 하위 디렉토리를 삭제 &lt;code&gt;rm -r&lt;/code&gt; 또는 &lt;code&gt;del /s&lt;/code&gt; Windows에서.</target>
        </trans-unit>
        <trans-unit id="f1fcc73f0626aba933df61d1eca5f7c5f0df238b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;remove_tree&lt;/code&gt; function deletes the given directories and any files and subdirectories they might contain, much like the Unix command &lt;code&gt;rm -rf&lt;/code&gt; or the Windows commands &lt;code&gt;rmdir /s&lt;/code&gt; and &lt;code&gt;rd /s&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;remove_tree&lt;/code&gt; 의 기능은 많은 유닉스 명령처럼, 주어진 포함되는 디렉토리와 수있는 모든 파일과 하위 디렉토리를 삭제 &lt;code&gt;rm -rf&lt;/code&gt; 나 Windows 명령 &lt;code&gt;rmdir /s&lt;/code&gt; 및 &lt;code&gt;rd /s&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f800b61fba3cbdc9dbaf2d3127156f3c10c2be33" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;report&lt;/code&gt; command temporarily turns on the &lt;code&gt;test_report&lt;/code&gt; config variable, then runs the &lt;code&gt;force test&lt;/code&gt; command with the given arguments. The &lt;code&gt;force&lt;/code&gt; pragma reruns the tests and repeats every step that might have failed before.</source>
          <target state="translated">&lt;code&gt;report&lt;/code&gt; 명령은 일시적으로 켜집니다 &lt;code&gt;test_report&lt;/code&gt; 의 다음 실행, 설정 변수 &lt;code&gt;force test&lt;/code&gt; 지정된 인수와 명령을 사용합니다. &lt;code&gt;force&lt;/code&gt; pragma는 테스트를 다시 실행하고 이전에 실패했을 수 있습니다 모든 단계를 반복합니다.</target>
        </trans-unit>
        <trans-unit id="3e0418f790bb3ba77ebbb5b8be57ce758907a81a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;request&lt;/code&gt; method returns a hashref containing the response. The hashref will have the following keys:</source>
          <target state="translated">&lt;code&gt;request&lt;/code&gt; 메소드는 응답을 포함하는 hashref를 돌려줍니다. 해시 참조에는 다음 키가 있습니다.</target>
        </trans-unit>
        <trans-unit id="bb965f28ada4d369f813e7b58370f45663a7e17c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;requires&lt;/code&gt; and &lt;code&gt;build_requires&lt;/code&gt; dependency declarations</source>
          <target state="translated">이 &lt;code&gt;requires&lt;/code&gt; 하고 &lt;code&gt;build_requires&lt;/code&gt; 는 선언을 의존성</target>
        </trans-unit>
        <trans-unit id="6825adde139cbe709d6cacc6c4ea55d8ef7cff02" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;resolve&lt;/code&gt; function is called to generate a linearised ISA for the given stash, using this MRO. It is called with a pointer to the stash, and a</source>
          <target state="translated">&lt;code&gt;resolve&lt;/code&gt; 기능이 MRO를 사용해, 지정된 마리화나에 대한 선형화 ISA를 생성하기 위해 호출됩니다. 은닉에 대한 포인터와 함께 호출되며</target>
        </trans-unit>
        <trans-unit id="20a1d55e5f69a55a8401c7bd274cec494c442203" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;result_factory_class&lt;/code&gt; can be customized, as described in &lt;a href=&quot;#new&quot;&gt;&quot;new&quot;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;result_factory_class&lt;/code&gt; 은 에 설명 된대로 사용자 정의 할 수 있습니다 &lt;a href=&quot;#new&quot;&gt;&quot;새로운&quot;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0e85b7e6554a08b089b5049ccd1a608787302c15" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;result_factory_class&lt;/code&gt; can be customized, as described in &lt;a href=&quot;#new&quot;&gt;new&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;result_factory_class&lt;/code&gt; 는 설명대로 정의 될 수있다&lt;a href=&quot;#new&quot;&gt; 새로운&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8ca2114e55ee9c4857e906508831f67273f52466" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;retrans&lt;/code&gt; argument the exponential backoff rate, default 1.2. It matches the $def_factor global.</source>
          <target state="translated">&lt;code&gt;retrans&lt;/code&gt; 가의 인수는 지수 백 오프 속도, 1.2 기본. $ def_factor 전역과 일치합니다.</target>
        </trans-unit>
        <trans-unit id="6d4f5cbea499bebe5f70cb857ce9ac77d66aaa7a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;rmtree()&lt;/code&gt; function provide the legacy interface of &lt;code&gt;remove_tree()&lt;/code&gt; with a different interpretation of the arguments passed. The behaviour and return value of the function is otherwise identical to &lt;code&gt;remove_tree()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;rmtree()&lt;/code&gt; 함수의 기존 인터페이스를 제공 &lt;code&gt;remove_tree()&lt;/code&gt; 전달 된 인수의 다른 해석. 함수의 동작과 반환 값은 그렇지 않으면 &lt;code&gt;remove_tree()&lt;/code&gt; 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="6451f829e84fc9b2a12b294243486a8357dccdcc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;roffitall&lt;/code&gt; utility is not installed on your system but lives in the</source>
          <target state="translated">&lt;code&gt;roffitall&lt;/code&gt; 유틸리티는 시스템에 설치되어 있지만에 살고 있지 않습니다</target>
        </trans-unit>
        <trans-unit id="38bb81c7279e4123eea02d7b94773b0e43184b92" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;run&lt;/code&gt; method returns 0 on success and a positive number on failure. See the section on EXIT CODES for details on the values.</source>
          <target state="translated">&lt;code&gt;run&lt;/code&gt; 방법은 성공과 실패에 긍정적 인 숫자 0을 반환합니다. 값에 대한 자세한 내용은 종료 코드 섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="ec12f7a8b2d7f40a1c42ea8d991b557d8527791c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;s///&lt;/code&gt; substitution operator is documented in &lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;s///&lt;/code&gt; 교체 연산자에서 설명 &lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1f11595235e0f9e5e74b59c34bf7ac4552157c76" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;send()&lt;/code&gt; method is used to issue an event to the hub. This method will handle thread/fork sync, filters, listeners, TAP output, etc.</source>
          <target state="translated">&lt;code&gt;send()&lt;/code&gt; 메소드는 상기 허브에 이벤트를 실행하는데 사용된다. 이 메서드는 스레드 / 포크 동기화, 필터, 리스너, TAP 출력 등을 처리합니다.</target>
        </trans-unit>
        <trans-unit id="9411561fa33dd9a0d96df4e7b49fae524226bee1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;skip(...)&lt;/code&gt; function is for tests that might or might not be possible to run, depending on the availability of platform-specific features. The first argument should evaluate to true (think &quot;yes, please skip&quot;) if the required feature is</source>
          <target state="translated">&lt;code&gt;skip(...)&lt;/code&gt; 기능은 플랫폼 별 기능의 사용 가능 여부에 따라 수도 있고 가능하지 않을 수도 있습니다 실행하는 테스트입니다. 필요한 피처가</target>
        </trans-unit>
        <trans-unit id="4dd34dc5f337a99adbdb95ed69eaa2b33a678e8f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;smoke&lt;/code&gt; command takes the list of recent uploads to CPAN as provided by the &lt;code&gt;recent&lt;/code&gt; command and tests them all. While the command is running $SIG{INT} is defined to mean that the current item shall be skipped.</source>
          <target state="translated">&lt;code&gt;smoke&lt;/code&gt; 에 의해 규정 된 명령은 CPAN에 최근 업로드 목록을 취 &lt;code&gt;recent&lt;/code&gt; 명령과 그들 모두를 테스트합니다. 명령이 실행되는 동안 $ SIG {INT}는 현재 항목을 건너 뛰도록 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="c81eca2265a8bfa89f7e2b8216b25f7468527582" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;socktype&lt;/code&gt; hint to getaddrinfo() filters the results to only include one socket type and protocol. Without this most OSes return three combinations, for &lt;code&gt;SOCK_STREAM&lt;/code&gt; , &lt;code&gt;SOCK_DGRAM&lt;/code&gt; and &lt;code&gt;SOCK_RAW&lt;/code&gt; , resulting in triplicate output of addresses. The &lt;code&gt;NI_NUMERICHOST&lt;/code&gt; flag to getnameinfo() causes it to return a string-formatted plain IP address, rather than reverse resolving it back into a hostname.</source>
          <target state="translated">getaddrinfo ()에 대한 &lt;code&gt;socktype&lt;/code&gt; 힌트는 하나의 소켓 유형과 프로토콜 만 포함하도록 결과를 필터링합니다. 이것이 없으면 대부분의 OS는 &lt;code&gt;SOCK_STREAM&lt;/code&gt; , &lt;code&gt;SOCK_DGRAM&lt;/code&gt; 및 &lt;code&gt;SOCK_RAW&lt;/code&gt; 에 대해 세 가지 조합을 반환 하여 주소의 3 배 출력을 생성합니다. &lt;code&gt;NI_NUMERICHOST&lt;/code&gt; getnameinfo ()에 플래그는 호스트 이름으로 다시 해석하지 않고 문자열 형식의 일반 IP 주소를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="96db56547c2805160963104b9881650067bc074a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;socktype&lt;/code&gt; hint to getaddrinfo() filters the results to only include one socket type and protocol. Without this most OSes return three combinations, for &lt;code&gt;SOCK_STREAM&lt;/code&gt;, &lt;code&gt;SOCK_DGRAM&lt;/code&gt; and &lt;code&gt;SOCK_RAW&lt;/code&gt;, resulting in triplicate output of addresses. The &lt;code&gt;NI_NUMERICHOST&lt;/code&gt; flag to getnameinfo() causes it to return a string-formatted plain IP address, rather than reverse resolving it back into a hostname.</source>
          <target state="translated">getaddrinfo ()에 대한 &lt;code&gt;socktype&lt;/code&gt; 힌트는 하나의 소켓 유형과 프로토콜 만 포함하도록 결과를 필터링합니다. 이것이 없으면 대부분의 OS는 &lt;code&gt;SOCK_STREAM&lt;/code&gt; , &lt;code&gt;SOCK_DGRAM&lt;/code&gt; 및 &lt;code&gt;SOCK_RAW&lt;/code&gt; 에 대해 세 가지 조합을 반환 하여 주소가 세 번 출력됩니다. getnameinfo ()에 대한 &lt;code&gt;NI_NUMERICHOST&lt;/code&gt; 플래그는 호스트 이름으로 다시 해석하는 대신 문자열 형식의 일반 IP 주소를 반환하도록합니다.</target>
        </trans-unit>
        <trans-unit id="03364b2c6aff3f77be6e48e31bc6fc170edb9637" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;source&lt;/code&gt; is used to create a &lt;a href=&quot;TAP::Parser::Source&quot;&gt;TAP::Parser::Source&lt;/a&gt; that is passed to the &lt;a href=&quot;#iterator_factory_class&quot;&gt;&quot;iterator_factory_class&quot;&lt;/a&gt; which in turn figures out how to handle the source and creates a &amp;lt;TAP::Parser::Iterator&amp;gt; for it. The iterator is used by the parser to read in the TAP stream.</source>
          <target state="translated">&lt;code&gt;source&lt;/code&gt; 만드는 데 사용됩니다 &lt;a href=&quot;TAP::Parser::Source&quot;&gt;TAP :: 파서 :: 소스&lt;/a&gt; 에 전달 &lt;a href=&quot;#iterator_factory_class&quot;&gt;&quot;iterator_factory_class&quot;&lt;/a&gt; 그것을 위해 소스를 처리하는 방법을 알아 차례 수치에있는 및 생성 &amp;lt;TAP을 :: 파서 :: Iterator를&amp;gt;. 반복기는 구문 분석기가 TAP 스트림에서 읽는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="8fb1bd48c372b36b030a4985fb7d0b8ecfff9314" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;source&lt;/code&gt; is used to create a &lt;a href=&quot;parser/source&quot;&gt;TAP::Parser::Source&lt;/a&gt; that is passed to the &lt;a href=&quot;#iterator_factory_class&quot;&gt;iterator_factory_class&lt;/a&gt; which in turn figures out how to handle the source and creates a &amp;lt;TAP::Parser::Iterator&amp;gt; for it. The iterator is used by the parser to read in the TAP stream.</source>
          <target state="translated">&lt;code&gt;source&lt;/code&gt; 만드는 데 사용됩니다 &lt;a href=&quot;parser/source&quot;&gt;TAP :: 파서 :: 소스&lt;/a&gt; 에 전달됩니다 &lt;a href=&quot;#iterator_factory_class&quot;&gt;iterator_factory_class을&lt;/a&gt; 를 처리하는 방법을 알아 내고 &amp;lt;TAP :: Parser :: Iterator&amp;gt;를 작성합니다. 이터레이터는 파서에서 TAP 스트림을 읽는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="92eb80578e9c5fa00cf858e0d3634beaaf8da658" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;sources&lt;/code&gt; parameter affects how &lt;code&gt;source&lt;/code&gt; , &lt;code&gt;tap&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; parameters are handled.</source>
          <target state="translated">&lt;code&gt;sources&lt;/code&gt; 매개 변수는 방법에 영향을 &lt;code&gt;source&lt;/code&gt; , &lt;code&gt;tap&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; 매개 변수가 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="ecf38e3d7dde64637f98a88870a2d809b9706769" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;sources&lt;/code&gt; parameter affects how &lt;code&gt;source&lt;/code&gt;, &lt;code&gt;tap&lt;/code&gt; and &lt;code&gt;exec&lt;/code&gt; parameters are handled.</source>
          <target state="translated">&lt;code&gt;sources&lt;/code&gt; 매개 변수는 방법에 영향을 &lt;code&gt;source&lt;/code&gt; , &lt;code&gt;tap&lt;/code&gt; 및 &lt;code&gt;exec&lt;/code&gt; 매개 변수가 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="8b7630407dfd17260fb141bba76fd71474e26eb1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;split()&lt;/code&gt; function is another place where a regexp is used. &lt;code&gt;split /regexp/, string, limit&lt;/code&gt; separates the &lt;code&gt;string&lt;/code&gt; operand into a list of substrings and returns that list. The regexp must be designed to match whatever constitutes the separators for the desired substrings. The &lt;code&gt;limit&lt;/code&gt;, if present, constrains splitting into no more than &lt;code&gt;limit&lt;/code&gt; number of strings. For example, to split a string into words, use</source>
          <target state="translated">&lt;code&gt;split()&lt;/code&gt; 함수는 정규 표현식을 사용하는 또 다른 장소이다. &lt;code&gt;split /regexp/, string, limit&lt;/code&gt; 는 &lt;code&gt;string&lt;/code&gt; 피연산자를 하위 문자열 목록으로 분리하고 해당 목록을 반환합니다. 정규 표현식은 원하는 하위 문자열의 구분 기호를 구성하는 모든 항목과 일치하도록 설계되어야합니다. &lt;code&gt;limit&lt;/code&gt; , 만약 더 이상으로 존재하는 제약을 분할 &lt;code&gt;limit&lt;/code&gt; 문자열의 개수. 예를 들어, 문자열을 단어로 분할하려면 다음을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="5429b24bd7773605c81ffce19b7803e3914ae70b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;state&lt;/code&gt; keyword creates a lexical variable (following the same scoping rules as &lt;code&gt;my&lt;/code&gt;) that persists from one subroutine call to the next. If a state variable resides inside an anonymous subroutine, then each copy of the subroutine has its own copy of the state variable. However, the value of the state variable will still persist between calls to the same copy of the anonymous subroutine. (Don't forget that &lt;code&gt;sub { ... }&lt;/code&gt; creates a new subroutine each time it is executed.)</source>
          <target state="translated">&lt;code&gt;state&lt;/code&gt; 키워드는 (같은 범위 지정 규칙에 따라 어휘 변수를 만들어 &lt;code&gt;my&lt;/code&gt; 그이 지속 한 서브 루틴 호출에서 다음을 참조). 상태 변수가 익명 서브 루틴 내에 있으면 서브 루틴의 각 사본에는 상태 변수의 자체 사본이 있습니다. 그러나 상태 변수의 값은 익명 서브 루틴의 동일한 복사본에 대한 호출간에 계속 유지됩니다. ( &lt;code&gt;sub { ... }&lt;/code&gt; 가 실행될 때마다 새 서브 루틴을 생성 한다는 사실을 잊지 마십시오 .)</target>
        </trans-unit>
        <trans-unit id="99a6aa9719696ddb8bff79a8c79538ca92e0d2e8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;strend&lt;/code&gt; and &lt;code&gt;patend&lt;/code&gt; pointers should point to the byte following the last character of each string.</source>
          <target state="translated">&lt;code&gt;strend&lt;/code&gt; 및 &lt;code&gt;patend&lt;/code&gt; 포인터는 각 문자열의 마지막 문자 다음 바이트를 가리켜 야합니다.</target>
        </trans-unit>
        <trans-unit id="ea6e352d41818ff4bf26ca16e10b39452c55d91f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;strict&lt;/code&gt; pragma disables certain Perl expressions that could behave unexpectedly or are difficult to debug, turning them into errors. The effect of this pragma is limited to the current file or scope block.</source>
          <target state="translated">&lt;code&gt;strict&lt;/code&gt; pragma는 예기치 않은 동작 또는 오류로 선회, 디버깅하기 어려운 수 있습니다 특정 펄 표현을 사용하지 않습니다. 이 pragma의 효과는 현재 파일 또는 범위 블록으로 제한됩니다.</target>
        </trans-unit>
        <trans-unit id="027d4af5bb9710fddfec7b10292492a3bd8321cd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;strict&lt;/code&gt; pragma is useful in avoiding such errors.</source>
          <target state="translated">&lt;code&gt;strict&lt;/code&gt; pragma는 이러한 오류를 방지하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="bda6d4349e03cdc3822accb764cf2332f0d166cc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;struct()&lt;/code&gt; function</source>
          <target state="translated">&lt;code&gt;struct()&lt;/code&gt; 함수</target>
        </trans-unit>
        <trans-unit id="7a95e760c73406947e7da7714b03782e42d5fa06" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;struct&lt;/code&gt; function has three forms of parameter-list.</source>
          <target state="translated">&lt;code&gt;struct&lt;/code&gt; 함수 파라미터리스트의 세 가지 형태를 갖는다.</target>
        </trans-unit>
        <trans-unit id="4f0312b0e41bdaef162518003e58d7dd5119b5b3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;sub-entry&lt;/code&gt; and &lt;code&gt;sub-return&lt;/code&gt; probes gain a fourth argument: the package name of the function.</source>
          <target state="translated">&lt;code&gt;sub-entry&lt;/code&gt; 과 &lt;code&gt;sub-return&lt;/code&gt; 프로브는 네 번째 인수를 얻을 : 함수의 패키지 이름.</target>
        </trans-unit>
        <trans-unit id="e032455d26f301f9311f3905ad487e2683ae6647" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;success&lt;/code&gt; field of the response will be true if the status code is 2XX or if the status code is 304 (unmodified).</source>
          <target state="translated">상태 코드가 2XX이거나 상태 코드가 304 (수정되지 않음) 인 경우 응답 의 &lt;code&gt;success&lt;/code&gt; 필드는 참이됩니다.</target>
        </trans-unit>
        <trans-unit id="76f86ba3ab4dadf0c5969933e8badc4119d9d2f7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;success&lt;/code&gt; field of the response will be true if the status code is 2XX.</source>
          <target state="translated">상태 코드가 2XX 인 경우 응답 의 &lt;code&gt;success&lt;/code&gt; 필드는 참이됩니다.</target>
        </trans-unit>
        <trans-unit id="7f8db9fbaa56d501321f36a7b37f026962feda33" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;supports_tables&lt;/code&gt; method should be true if the formatter supports directly rendering table data from the &lt;code&gt;info&lt;/code&gt; facets. This is a newer feature and many older formatters may not support it. When not supported the formatter falls back to rendering &lt;code&gt;detail&lt;/code&gt; instead of the &lt;code&gt;table&lt;/code&gt; data.</source>
          <target state="translated">&lt;code&gt;supports_tables&lt;/code&gt; 의 포맷터 지원하는 직접에서 테이블 데이터를 렌더링하는 경우 메소드는 true를해야한다 &lt;code&gt;info&lt;/code&gt; 면. 이것은 새로운 기능이며 많은 이전 포맷터가이 기능을 지원하지 않을 수 있습니다. 지원되지 않는 경우 포맷터 는 &lt;code&gt;table&lt;/code&gt; 데이터 대신 렌더링 &lt;code&gt;detail&lt;/code&gt; 대체됩니다 .</target>
        </trans-unit>
        <trans-unit id="ca2248434d315d7f4555ab09ed558fffeb25af18" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;sv&lt;/code&gt; argument is a pointer to the SV that is to acquire a new magical feature.</source>
          <target state="translated">&lt;code&gt;sv&lt;/code&gt; 인수는 새로운 마법의 기능을 확보하는 것입니다 SV에 대한 포인터입니다.</target>
        </trans-unit>
        <trans-unit id="3bd810d1cf1c18312d2c5eb1e03b023fe5ee01ae" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;sv&lt;/code&gt; argument must be a reference value. The &lt;code&gt;stash&lt;/code&gt; argument specifies which class the reference will belong to. See &lt;a href=&quot;#Stashes-and-Globs&quot;&gt;&quot;Stashes and Globs&quot;&lt;/a&gt; for information on converting class names into stashes.</source>
          <target state="translated">&lt;code&gt;sv&lt;/code&gt; 인수는 참조 값이어야합니다. &lt;code&gt;stash&lt;/code&gt; 인수 지정은 클래스 참조가 속한 것이다. 클래스 이름을 스 &lt;a href=&quot;#Stashes-and-Globs&quot;&gt;태시&lt;/a&gt; 로 변환하는 방법에 대한 정보는 &quot;Stash 및 Glob&quot; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="9d1732cdeea04b3b5302655756ff012b4b97e760" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;sv&lt;/code&gt; argument must be a reference value. The &lt;code&gt;stash&lt;/code&gt; argument specifies which class the reference will belong to. See &lt;a href=&quot;#Stashes-and-Globs&quot;&gt;Stashes and Globs&lt;/a&gt; for information on converting class names into stashes.</source>
          <target state="translated">&lt;code&gt;sv&lt;/code&gt; 인수는 참조 값이어야합니다. &lt;code&gt;stash&lt;/code&gt; 인수 지정은 클래스 참조가 속한 것이다. 클래스 이름을 &lt;a href=&quot;#Stashes-and-Globs&quot;&gt;숨김&lt;/a&gt; 으로 변환하는 방법에 대한 정보는 숨김 및 글로브 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="3c426a5175e1475eb159d7aa2bfc10b9aeb2592e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;sv_cat*()&lt;/code&gt; functions are not generic enough to operate on values that have &quot;magic&quot;. See &lt;a href=&quot;#Magic-Virtual-Tables&quot;&gt;&quot;Magic Virtual Tables&quot;&lt;/a&gt; later in this document.</source>
          <target state="translated">&lt;code&gt;sv_cat*()&lt;/code&gt; 함수는 &quot;마법&quot;이 값에서 작동하는 일반적인 충분하지 않습니다. 이 문서 뒷부분의 &lt;a href=&quot;#Magic-Virtual-Tables&quot;&gt;&quot;매직 가상 테이블&quot;을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="5aa9fb7196f50b878b4d2185150e32ef86a1a0ee" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;sv_cat*()&lt;/code&gt; functions are not generic enough to operate on values that have &quot;magic&quot;. See &lt;a href=&quot;#Magic-Virtual-Tables&quot;&gt;Magic Virtual Tables&lt;/a&gt; later in this document.</source>
          <target state="translated">&lt;code&gt;sv_cat*()&lt;/code&gt; 함수는 &quot;마법&quot;이 값에서 작동하는 일반적인 충분하지 않습니다. &lt;a href=&quot;#Magic-Virtual-Tables&quot;&gt;매직 가상 테이블&lt;/a&gt; 참조이 문서 뒷부분의 .</target>
        </trans-unit>
        <trans-unit id="2ca2c3639e16b490b555d2489361f0871018a997" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;sv_set*()&lt;/code&gt; functions are not generic enough to operate on values that have &quot;magic&quot;. See &lt;a href=&quot;#Magic-Virtual-Tables&quot;&gt;&quot;Magic Virtual Tables&quot;&lt;/a&gt; later in this document.</source>
          <target state="translated">&lt;code&gt;sv_set*()&lt;/code&gt; 함수는 &quot;마법&quot;이 값에서 작동하는 일반적인 충분하지 않습니다. 이 문서 뒷부분의 &lt;a href=&quot;#Magic-Virtual-Tables&quot;&gt;&quot;매직 가상 테이블&quot;을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="451bffe03c920b337c26d3f6c5c7b3d0a90a952c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;sv_set*()&lt;/code&gt; functions are not generic enough to operate on values that have &quot;magic&quot;. See &lt;a href=&quot;#Magic-Virtual-Tables&quot;&gt;Magic Virtual Tables&lt;/a&gt; later in this document.</source>
          <target state="translated">&lt;code&gt;sv_set*()&lt;/code&gt; 함수는 &quot;마법&quot;이 값에서 작동하는 일반적인 충분하지 않습니다. 이 문서 뒷부분의 &lt;a href=&quot;#Magic-Virtual-Tables&quot;&gt;Magic Virtual Tables를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a022ed577de5458a14b966f973f3ce2a62bb2a5b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;system&lt;/code&gt; built-in is considered to have failed in the following circumstances:</source>
          <target state="translated">&lt;code&gt;system&lt;/code&gt; 내장 다음과 같은 경우에 실패한 것으로 간주된다 :</target>
        </trans-unit>
        <trans-unit id="817c94b76b6dd84c4c7d9bb171edda3a93d8445e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;system&lt;/code&gt; operator creates a subprocess, and passes its arguments to the subprocess for execution as a DCL command. Since the subprocess is created directly via &lt;code&gt;lib$spawn()&lt;/code&gt;, any valid DCL command string may be specified. If the string begins with '@', it is treated as a DCL command unconditionally. Otherwise, if the first token contains a character used as a delimiter in file specification (e.g. &lt;code&gt;:&lt;/code&gt; or &lt;code&gt;]&lt;/code&gt;), an attempt is made to expand it using a default type of</source>
          <target state="translated">&lt;code&gt;system&lt;/code&gt; 오퍼레이터가 구성 프로세스를 생성하고, DCL 명령과 실행을위한 하위 프로세스를 인수를 전달한다. 하위 프로세스는 &lt;code&gt;lib$spawn()&lt;/code&gt; 통해 직접 생성되므로 유효한 DCL 명령 문자열을 지정할 수 있습니다. 문자열이 '@'로 시작하면 무조건 DCL 명령으로 처리됩니다. 그렇지 않으면 첫 번째 토큰에 파일 사양에서 구분 기호로 사용되는 문자 (예 &lt;code&gt;:&lt;/code&gt; 또는 &lt;code&gt;]&lt;/code&gt; )가 포함되어 있으면 기본 유형을 사용하여 확장하려고합니다.</target>
        </trans-unit>
        <trans-unit id="264e3c8ac2fdd944cc02ae92713944fc8cf6494f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;taint&lt;/code&gt; pragma causes any substrings from a match with a tainted variable to be tainted as well. This is not normally the case, as regexps are often used to extract the safe bits from a tainted variable. Use &lt;code&gt;taint&lt;/code&gt; when you are not extracting safe bits, but are performing some other processing. Both &lt;code&gt;taint&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; pragmas are lexically scoped, which means they are in effect only until the end of the block enclosing the pragmas.</source>
          <target state="translated">&lt;code&gt;taint&lt;/code&gt; pragma는 오염 된 변수와 경기에서 어떤 문자열이 아니라 오염되도록합니다. 정규 표현식은 종종 오염 된 변수에서 안전한 비트를 추출하는 데 사용되므로 일반적으로 그렇지 않습니다. 안전한 비트를 추출하지는 않지만 다른 처리를 수행 할 때는 &lt;code&gt;taint&lt;/code&gt; 사용하십시오 . 두 &lt;code&gt;taint&lt;/code&gt; 과 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 프라 그마는 어휘들은 단지 프라그 둘러싸 블록이 끝날 때까지 적용되는 의미 범위가된다.</target>
        </trans-unit>
        <trans-unit id="45b556a65806a34a0370ae702153cb4405855fa8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;taint&lt;/code&gt; pragma causes any substrings from a match with a tainted variable to be tainted as well. This is not normally the case, as regexps are often used to extract the safe bits from a tainted variable. Use &lt;code&gt;taint&lt;/code&gt; when you are not extracting safe bits, but are performing some other processing. Both &lt;code&gt;taint&lt;/code&gt; and &lt;code&gt;eval&lt;/code&gt; pragmas are lexically scoped, which means they are in effect only until the end of the block enclosing the pragmas.</source>
          <target state="translated">&lt;code&gt;taint&lt;/code&gt; pragma는 오염 된 변수와 경기에서 어떤 문자열이 아니라 오염되도록합니다. 정규 표현식은 오염 된 변수에서 안전 비트를 추출하는 데 자주 사용되기 때문에 일반적으로 그렇지 않습니다. 안전한 비트를 추출하지 않고 다른 처리를 수행하는 경우 &lt;code&gt;taint&lt;/code&gt; 를 사용하십시오 . 두 &lt;code&gt;taint&lt;/code&gt; 과 &lt;code&gt;eval&lt;/code&gt; 프라 그마는 어휘들은 단지 프라그 둘러싸 블록이 끝날 때까지 적용되는 의미 범위가된다.</target>
        </trans-unit>
        <trans-unit id="3cc9bc272d719ab5016869a769d84acd8ec8d7c2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;terminate&lt;/code&gt; and &lt;code&gt;finalize&lt;/code&gt; methods are optional methods called that you can implement if the format you're generating needs to handle these cases, for example if you are generating XML and need close open tags.</source>
          <target state="translated">는 &lt;code&gt;terminate&lt;/code&gt; 및 &lt;code&gt;finalize&lt;/code&gt; 방법은 형식이 당신있는 거 생성 요구는 개폐 태그를 XML과 필요성을 생성하는 경우, 예를 들어 이러한 경우를 처리 할 수있는 경우에 당신이 구현할 수라는 선택 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="423cad30ef0048166a8eebe3340a46a30155372e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;terminate&lt;/code&gt; method is called when an event's &lt;code&gt;terminate&lt;/code&gt; method returns true, for example when a &lt;a href=&quot;Test2::Event::Plan&quot;&gt;Test2::Event::Plan&lt;/a&gt; has a &lt;code&gt;'skip_all'&lt;/code&gt; plan, or when a &lt;a href=&quot;Test2::Event::Bail&quot;&gt;Test2::Event::Bail&lt;/a&gt; event is sent. The &lt;code&gt;terminate&lt;/code&gt; method is passed a single argument, the &lt;a href=&quot;Test2::Event&quot;&gt;Test2::Event&lt;/a&gt; object which triggered the terminate.</source>
          <target state="translated">&lt;code&gt;terminate&lt;/code&gt; 방법은 이벤트가 때 호출 &lt;code&gt;terminate&lt;/code&gt; 때, 예를 들어, 메소드가 리턴 사실 &lt;a href=&quot;Test2::Event::Plan&quot;&gt;Test2를 :: 이벤트 :: 계획&lt;/a&gt; 가 &lt;code&gt;'skip_all'&lt;/code&gt; 계획을, 또는 때 &lt;a href=&quot;Test2::Event::Bail&quot;&gt;Test2를 :: 이벤트 :: 보석의&lt;/a&gt; 이벤트가 전송됩니다. &lt;code&gt;terminate&lt;/code&gt; 방법은 단일 인수의 전달됩니다 &lt;a href=&quot;Test2::Event&quot;&gt;Test2를 :: 이벤트&lt;/a&gt; (가) 종료 트리거 객체를.</target>
        </trans-unit>
        <trans-unit id="0e22b53957ab545ec5f1fe43f2463dbb75fb5bef" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;test_diag&lt;/code&gt; function prepends comment hashes and spacing to the start and newlines to the end of the expected output passed to it and adds it to the list of expected error output. So, instead of writing</source>
          <target state="translated">&lt;code&gt;test_diag&lt;/code&gt; 의 기능은 전달 된 예상 출력의 끝에 주석 해시와 시작 간격과 줄 바꿈 앞에 추가 및 예상 오류 출력 목록에 추가합니다. 그래서 글 쓰는 대신</target>
        </trans-unit>
        <trans-unit id="9a044497bbeccf899d123e744ac60158148d66b5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;thing&lt;/code&gt; argument can be any of an &lt;code&gt;SV*&lt;/code&gt; , &lt;code&gt;AV*&lt;/code&gt; , or &lt;code&gt;HV*&lt;/code&gt; . The functions are identical except that &lt;code&gt;newRV_inc&lt;/code&gt; increments the reference count of the &lt;code&gt;thing&lt;/code&gt; , while &lt;code&gt;newRV_noinc&lt;/code&gt; does not. For historical reasons, &lt;code&gt;newRV&lt;/code&gt; is a synonym for &lt;code&gt;newRV_inc&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;thing&lt;/code&gt; 인수는 어떤 일 수있다 &lt;code&gt;SV*&lt;/code&gt; , &lt;code&gt;AV*&lt;/code&gt; , 또는 &lt;code&gt;HV*&lt;/code&gt; . 기능은 다음을 제외하고 동일합니다 &lt;code&gt;newRV_inc&lt;/code&gt; 는 &lt;code&gt;thing&lt;/code&gt; 의 참조 카운트를 증가시키는 반면 &lt;code&gt;newRV_noinc&lt;/code&gt; 는 그렇지 않은 . 역사적인 이유로, &lt;code&gt;newRV&lt;/code&gt; 는 동의어입니다 &lt;code&gt;newRV_inc&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="39f6cd9542d25aca0f6da28dc2eb900530cd2e73" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;thing&lt;/code&gt; argument can be any of an &lt;code&gt;SV*&lt;/code&gt;, &lt;code&gt;AV*&lt;/code&gt;, or &lt;code&gt;HV*&lt;/code&gt;. The functions are identical except that &lt;code&gt;newRV_inc&lt;/code&gt; increments the reference count of the &lt;code&gt;thing&lt;/code&gt;, while &lt;code&gt;newRV_noinc&lt;/code&gt; does not. For historical reasons, &lt;code&gt;newRV&lt;/code&gt; is a synonym for &lt;code&gt;newRV_inc&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;thing&lt;/code&gt; 인수는 어떤 일 수있다 &lt;code&gt;SV*&lt;/code&gt; , &lt;code&gt;AV*&lt;/code&gt; , 또는 &lt;code&gt;HV*&lt;/code&gt; . 함수는 것을 제외하고는 동일 &lt;code&gt;newRV_inc&lt;/code&gt; 가 의 레퍼런스 카운트 증가 &lt;code&gt;thing&lt;/code&gt; 하면서 &lt;code&gt;newRV_noinc&lt;/code&gt; 은 하지 않는다. 역사적인 이유로, &lt;code&gt;newRV&lt;/code&gt; 는 동의어입니다 &lt;code&gt;newRV_inc&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="764690cb5a9a1e69711deb7f1d4bd7570cd33533" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;threads-&amp;gt;self()&lt;/code&gt; class method provides your program with a way to get an object representing the thread it's currently in. You can use this object in the same way as the ones returned from thread creation.</source>
          <target state="translated">&lt;code&gt;threads-&amp;gt;self()&lt;/code&gt; 클래스 메소드는 현재의 스레드를 나타내는 개체를 얻을 수있는 방법과 프로그램을 제공합니다. 당신은 스레드 생성에서 반환 된 것과 같은 방식으로이 객체를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5cb77a0f1c56daabcc9daa1cb20e1afceca163c1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;tid&lt;/code&gt; method returns the tid of a thread. The tid is a monotonically increasing integer assigned when a thread is created. The main thread of a program will have a tid of zero, while subsequent threads will have tids assigned starting with one.</source>
          <target state="translated">&lt;code&gt;tid&lt;/code&gt; 방법은 스레드의 TID를 반환합니다. tid는 스레드가 작성 될 때 지정된 단조 증가 정수입니다. 프로그램의 메인 스레드는 tid가 0이고, 후속 스레드는 tid가 1부터 시작하여 할당됩니다.</target>
        </trans-unit>
        <trans-unit id="852bdb693d32a436b5f27ac2d4c29c14b07baed2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;tie&lt;/code&gt; call returns an object, say &lt;code&gt;$o&lt;/code&gt;. You may call</source>
          <target state="translated">&lt;code&gt;tie&lt;/code&gt; 호출이 반환 객체는 말할 &lt;code&gt;$o&lt;/code&gt; . 당신은 전화 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="9c7906336a9d98d4a1cf6a79c6964edf2df1f812" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;time*_modern()&lt;/code&gt; subs do not do this year munging and simply take the year value as provided.</source>
          <target state="translated">&lt;code&gt;time*_modern()&lt;/code&gt; 서브 우퍼는 올해 munging을하고 규정 된 바와 같이 단순히 연도 값을 고려하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="62cae6d3e02f73d7641c7861d0693bc4b08d5c81" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;timelocal()&lt;/code&gt; and &lt;code&gt;timegm()&lt;/code&gt; functions perform range checking on the input $sec, $min, $hour, $mday, and $mon values by default.</source>
          <target state="translated">&lt;code&gt;timelocal()&lt;/code&gt; 및 &lt;code&gt;timegm()&lt;/code&gt; 함수는 기본적으로 입력 $ 초, $ 분, $ 시간, $ MDAY 및 $ 월 값 범위 검사를 수행한다.</target>
        </trans-unit>
        <trans-unit id="3444ad2f99e605827ac849ba41549cb93537c5ca" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;timelocal()&lt;/code&gt; function is implemented using the same cache. We just assume that we're translating a GMT time, and then fudge it when we're done for the timezone and daylight savings arguments. Note that the timezone is evaluated for each date because countries occasionally change their official timezones. Assuming that &lt;code&gt;&lt;a href=&quot;../functions/localtime&quot;&gt;localtime()&lt;/a&gt;&lt;/code&gt; corrects for these changes, this routine will also be correct.</source>
          <target state="translated">그만큼 &lt;code&gt;timelocal()&lt;/code&gt; 함수는 동일한 캐시를 이용하여 구현된다. 우리는 GMT 시간을 번역한다고 가정하고 시간대 및 일광 절약 시간제 인수에 대한 작업이 끝나면 퍼지합니다. 국가는 때때로 공식 시간대를 변경하기 때문에 시간대는 각 날짜에 대해 평가됩니다. &lt;code&gt;&lt;a href=&quot;../functions/localtime&quot;&gt;localtime()&lt;/a&gt;&lt;/code&gt; 이 이러한 변경 사항을 수정 한다고 가정하면 이 루틴도 정확합니다.</target>
        </trans-unit>
        <trans-unit id="d6031b9f93c7f0ead71810ff0ffcc9e88c83f87c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;timelocal()&lt;/code&gt; function is implemented using the same cache. We just assume that we're translating a GMT time, and then fudge it when we're done for the timezone and daylight savings arguments. Note that the timezone is evaluated for each date because countries occasionally change their official timezones. Assuming that &lt;code&gt;localtime()&lt;/code&gt; corrects for these changes, this routine will also be correct.</source>
          <target state="translated">&lt;code&gt;timelocal()&lt;/code&gt; 함수는 동일한 캐시를 이용하여 구현된다. 우리는 GMT 시간을 번역하고 있다고 가정하고, 시간대 및 일광 절약 인수에 대한 작업이 끝나면 퍼지합니다. 국가가 때때로 공식 시간대를 변경하기 때문에 시간대는 각 날짜에 대해 평가됩니다. &lt;code&gt;localtime()&lt;/code&gt; 이 이러한 변경 사항을 수정 한다고 가정하면 이 루틴도 정확합니다.</target>
        </trans-unit>
        <trans-unit id="79e29c335d0e24d411a115fbcbdaff898b8a8cf5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;times()&lt;/code&gt; function returns elapsed realtime since some point in the past (such as system startup), user and system times for this process, and user and system times used by child processes. All times are returned in clock ticks.</source>
          <target state="translated">&lt;code&gt;times()&lt;/code&gt; 함수가 반환은 자식 프로세스에 의해 사용되는 과거의 어느 시점 (예 : 시스템 시작 등)이 프로세스에 대한 사용자와 시스템 시간, 사용자 및 시스템 시대부터 실시간 경과. 모든 시간은 시계 틱으로 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="e88ddb341d5b31f6433cf87d10fae07c89fb702d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;tmpnam&lt;/code&gt; function returns a unique string which can be used as a filename when creating temporary files. If, for some reason, it is unable to generate a name, it returns &lt;code&gt;undef&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;tmpnam&lt;/code&gt; 이의 기능은 임시 파일을 만들 때 파일 이름으로 사용할 수있는 고유 한 문자열을 반환합니다. 어떤 이유로 이름을 생성 할 수없는 경우 &lt;code&gt;undef&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="6b8678670162f30c825dc963303a8366061c0624" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;tr///&lt;/code&gt; operator translates whole characters. (Note that the &lt;code&gt;tr///CU&lt;/code&gt; functionality has been removed. For similar functionality to that, see &lt;code&gt;pack('U0', ...)&lt;/code&gt; and &lt;code&gt;pack('C0', ...)&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;tr///&lt;/code&gt; 연산자는 전체 문자를 변환합니다. ( &lt;code&gt;tr///CU&lt;/code&gt; 기능이 제거되었습니다. 이와 유사한 기능에 대해서는 &lt;code&gt;pack('U0', ...)&lt;/code&gt; 및 &lt;code&gt;pack('C0', ...)&lt;/code&gt; )을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="d1863d41e42c91ece1fce678f54e90a29e06de0d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;tr&lt;/code&gt; alternative might look like this:</source>
          <target state="translated">&lt;code&gt;tr&lt;/code&gt; 대안은 다음과 같습니다</target>
        </trans-unit>
        <trans-unit id="c010b9c38ee87dfd390ac847c9b0e002caa8d481" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;tr&lt;/code&gt; counts the null bytes. The &lt;code&gt;unpack&lt;/code&gt; call returns a list of name-value pairs each of which is taken apart in the &lt;code&gt;map&lt;/code&gt; block.</source>
          <target state="translated">&lt;code&gt;tr&lt;/code&gt; 널 바이트를 계산합니다. &lt;code&gt;unpack&lt;/code&gt; 호출은에서 떨어져 촬영, 각각의 이름 - 값 쌍의 목록을 반환 &lt;code&gt;map&lt;/code&gt; 블록을.</target>
        </trans-unit>
        <trans-unit id="accc9aa113f108f1f58344bb9d92f9dd409a973d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;tr&lt;/code&gt; version is a clear winner. One solution is flexible, the other is fast - and it's appropriately the programmer's choice which to use.</source>
          <target state="translated">&lt;code&gt;tr&lt;/code&gt; 버전은 확실한 승자입니다. 하나의 솔루션은 유연하고 다른 하나는 빠르며 어느 것을 사용할지 프로그래머가 선택하는 것이 적절합니다.</target>
        </trans-unit>
        <trans-unit id="7969d03acba8ec22322bc524970a2e67bf531eeb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;type&lt;/code&gt; argument should be equal to the &lt;code&gt;how&lt;/code&gt; value when the &lt;code&gt;SV&lt;/code&gt; was initially made magical.</source>
          <target state="translated">&lt;code&gt;type&lt;/code&gt; 인자는 같아야 &lt;code&gt;how&lt;/code&gt; 때 값 &lt;code&gt;SV&lt;/code&gt; 가 처음 마법되었다.</target>
        </trans-unit>
        <trans-unit id="45b58766c7b5bfa7d8fbeea9c00e3139b61f934f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;type=&quot;man&quot;&lt;/code&gt; attribute is always specified for this type of L code.</source>
          <target state="translated">&lt;code&gt;type=&quot;man&quot;&lt;/code&gt; 속성은 항상 L 코드이 유형의 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="51e37e784cf8826358b635a533d80412ae68521a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;type=&quot;url&quot;&lt;/code&gt; attribute is always specified for this type of L code.</source>
          <target state="translated">&lt;code&gt;type=&quot;url&quot;&lt;/code&gt; 속성은 항상 L 코드이 유형의 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="e605c3e8404b3b1569b2a8f6ee2a28bb09c8e25f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;u&lt;/code&gt; template to &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack()&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack()&lt;/a&gt;&lt;/code&gt; will render EBCDIC data in EBCDIC characters equivalent to their ASCII counterparts. For example, the following will print &quot;Yes indeed\n&quot; on either an ASCII or EBCDIC computer:</source>
          <target state="translated">&lt;code&gt;u&lt;/code&gt; 에 템플릿 &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack()&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack()&lt;/a&gt;&lt;/code&gt; 는 EBCDIC 데이터를 ASCII에 해당하는 EBCDIC 문자로 렌더링합니다. 예를 들어, 다음은 ASCII 또는 EBCDIC 컴퓨터에서 &quot;예 \ n&quot;을 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="bcdcd5bf5921d41526775a635bdda4515bcae7f3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;u&lt;/code&gt; template to &lt;code&gt;pack()&lt;/code&gt; or &lt;code&gt;unpack()&lt;/code&gt; will render EBCDIC data in EBCDIC characters equivalent to their ASCII counterparts. For example, the following will print &quot;Yes indeed\n&quot; on either an ASCII or EBCDIC computer:</source>
          <target state="translated">&lt;code&gt;pack()&lt;/code&gt; 또는 &lt;code&gt;unpack()&lt;/code&gt; 대한 &lt;code&gt;u&lt;/code&gt; 템플릿 은 ASCII 대응 문자에 해당하는 EBCDIC 문자로 EBCDIC 데이터를 렌더링합니다. 예를 들어, 다음은 ASCII 또는 EBCDIC 컴퓨터에서 &quot;Yes really \ n&quot;를 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="0998cba5f7c7355370ef1940f9de1afcbe1199eb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;undef&lt;/code&gt; value is treated by this function as distinct from the empty string, and no warning will be produced. It is left as-is in the returned list. Subsequent &lt;code&gt;undef&lt;/code&gt; values are still considered identical to the first, and will be removed.</source>
          <target state="translated">&lt;code&gt;undef&lt;/code&gt; 값은 빈 문자열에서 별개로이 기능에 의해 처리되며, 경고가 생성되지 않습니다. 반환 된 목록에있는 그대로 유지됩니다. 후속 &lt;code&gt;undef&lt;/code&gt; 값은 여전히 ​​첫 번째 값과 동일한 것으로 간주되며 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="7c83289af1a4c0f7e1129f103e79b7a1caa912f8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;untie&lt;/code&gt; Gotcha</source>
          <target state="translated">&lt;code&gt;untie&lt;/code&gt; 잡았다</target>
        </trans-unit>
        <trans-unit id="6a1909f52d28496be25968c9641232bd70a050cf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;up&lt;/code&gt; method increases the semaphore's count by the number specified (which must be an integer &amp;gt;= 1), or by one if no number is specified.</source>
          <target state="translated">그만큼 &lt;code&gt;up&lt;/code&gt; 방법 수가 지정되지 않은 경우, 또는 하나 (정수&amp;gt; = 1이어야 함)에 의해 지정된 번호 세마포어의 카운트를 증가시킨다.</target>
        </trans-unit>
        <trans-unit id="3bfafbe930277e35ea02604239f7cd015c3326fb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;upgrade&lt;/code&gt; command first runs an &lt;code&gt;r&lt;/code&gt; command with the given arguments and then installs the newest versions of all modules that were listed by that.</source>
          <target state="translated">&lt;code&gt;upgrade&lt;/code&gt; 명령을 먼저 실행 &lt;code&gt;r&lt;/code&gt; 에 지정된 인수와 명령을 한 후 해당 의해 나열된 모든 모듈의 최신 버전을 설치합니다.</target>
        </trans-unit>
        <trans-unit id="ed2a8ecd68dda5352fc1303d01e5cd582863eba1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;urllist&lt;/code&gt; parameter of the configuration table contains a list of URLs used for downloading. If the list contains any &lt;code&gt;file&lt;/code&gt; URLs, CPAN always tries there first. This feature is disabled for index files. So the recommendation for the owner of a CD-ROM with CPAN contents is: include your local, possibly outdated CD-ROM as a &lt;code&gt;file&lt;/code&gt; URL at the end of urllist, e.g.</source>
          <target state="translated">구성 테이블 의 &lt;code&gt;urllist&lt;/code&gt; 매개 변수는 다운로드에 사용되는 URL 목록을 포함합니다. 목록에 &lt;code&gt;file&lt;/code&gt; 포함 된 경우 URL이 CPAN은 항상 먼저 시도합니다. 이 기능은 인덱스 파일에서 사용할 수 없습니다. CPAN 내용이 포함 된 CD-ROM 소유자의 권장 사항은 다음과 같습니다. urllist 끝에 &lt;code&gt;file&lt;/code&gt; URL 로 로컬 또는 오래된 CD-ROM을 포함하십시오.</target>
        </trans-unit>
        <trans-unit id="52b900f042b9fdb4fefbfa11c5b63b7617ef4658" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;use &lt;a href=&quot;warnings&quot;&gt;warnings&lt;/a&gt;&lt;/code&gt; pragma produces some lovely diagnostics. One can also use the &lt;b&gt;-w&lt;/b&gt; flag, but its use is normally discouraged, because it gets applied to all executed Perl code, including that not under your control.</source>
          <target state="translated">&lt;code&gt;use &lt;a href=&quot;warnings&quot;&gt;warnings&lt;/a&gt;&lt;/code&gt; pragma는 일부 사랑스러운 진단을 생산하고 있습니다. &lt;b&gt;-w&lt;/b&gt; 플래그를 사용할 수도 있지만 일반적으로 사용하지 않는 것이 좋습니다. 이는 사용자가 제어하지 않는 코드를 포함하여 실행 된 모든 Perl 코드에 적용되기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="d475de0db7f66747e084c66e42ee75d8f3488116" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;use filetest&lt;/code&gt; or &lt;code&gt;no filetest&lt;/code&gt; statements affect file tests defined in their block, up to the end of the closest enclosing block (they are lexically block-scoped).</source>
          <target state="translated">&lt;code&gt;use filetest&lt;/code&gt; 또는 &lt;code&gt;no filetest&lt;/code&gt; 문까지 가장 가까운 바깥 쪽 블록의 끝 (그들은 어휘 적 범위의 차단할있다)에, 자신의 블록에 정의 된 파일의 검사에도 영향을 미칩니다.</target>
        </trans-unit>
        <trans-unit id="acfbde926d15ce3b3022057fc9c74ed9c253c404" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;use utf8&lt;/code&gt; pragma tells the Perl parser to allow UTF-8 in the program text in the current lexical scope. The &lt;code&gt;no utf8&lt;/code&gt; pragma tells Perl to switch back to treating the source text as literal bytes in the current lexical scope. (On EBCDIC platforms, technically it is allowing UTF-EBCDIC, and not UTF-8, but this distinction is academic, so in this document the term UTF-8 is used to mean both).</source>
          <target state="translated">&lt;code&gt;use utf8&lt;/code&gt; pragma는 현재 어휘 범위의 프로그램 텍스트에서 UTF-8을 허용하는 펄 파서를 알려줍니다. &lt;code&gt;no utf8&lt;/code&gt; pragma는 현재 어휘 범위에있는 문자 바이트로 소스 텍스트의 치료로 전환하기 위해 펄을 알려줍니다. (EBCDIC 플랫폼에서는 기술적으로 UTF-8이 아닌 UTF-EBCDIC을 허용하지만이 구별은 학문적이므로이 문서에서 UTF-8이라는 용어는 둘 다를 의미하는 데 사용됩니다).</target>
        </trans-unit>
        <trans-unit id="29c5989f0b30cb3c2f7f588b2b53bc0b52ccd653" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;use warnings&lt;/code&gt; pragma or the &lt;b&gt;-w&lt;/b&gt; switch will warn you if it interprets a reserved word as a string. But it will no longer warn you about using lowercase words, because the string is effectively quoted.</source>
          <target state="translated">&lt;code&gt;use warnings&lt;/code&gt; PRAGMA 또는 &lt;b&gt;-w&lt;/b&gt; 이 예약 된 단어를 문자열로 해석하는 경우 스위치는 경고합니다. 그러나 문자열이 효과적으로 인용되기 때문에 더 이상 소문자 사용에 대해 경고하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="468aa2690cfac4f39947fa49f9490387f38518f6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;utf8::unicode_to_native()&lt;/code&gt; and &lt;code&gt;utf8::upgrade()&lt;/code&gt; aren't needed if the argument is above 0xFF, so the above could have been written as</source>
          <target state="translated">&lt;code&gt;utf8::unicode_to_native()&lt;/code&gt; 및 &lt;code&gt;utf8::upgrade()&lt;/code&gt; 인수가 0xFF를 초과하는 경우에는 위와 같이 작성되었습니다 수 있도록, 필요하지 않습니다</target>
        </trans-unit>
        <trans-unit id="c685630771328cb31903796f4e815c9203e60a01" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;utf8&lt;/code&gt; flag therefore switches between two modes: disabled means you will get a Unicode string in Perl, enabled means you get an UTF-8 encoded octet/binary string in Perl.</source>
          <target state="translated">따라서 &lt;code&gt;utf8&lt;/code&gt; 플래그는 두 가지 모드 사이를 전환합니다. disabled는 Perl에서 유니 코드 문자열을 얻게됨을 의미하고, enabled는 Perl에서 UTF-8로 인코딩 된 8 진수 / 이진 문자열을 얻음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="14707ff227aab2f7f6198f5296b54e26eed1065e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;util.c:1716&lt;/code&gt; is the source code file and line number.</source>
          <target state="translated">&lt;code&gt;util.c:1716&lt;/code&gt; 소스 코드 파일과 줄 번호입니다.</target>
        </trans-unit>
        <trans-unit id="8b13c9e2cf58e77564c57c1639c049e04a961551" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;vars&lt;/code&gt; pragma (see &lt;a href=&quot;perlmod#vars&quot;&gt;&quot;vars&quot; in perlmod&lt;/a&gt;) may be used in such situations as an alternative to explicitly qualifying all globals with the package namespace. Variables pre-declared with this pragma will be visible to any autoloaded routines (but will not be invisible outside the package, unfortunately).</source>
          <target state="translated">는 &lt;code&gt;vars&lt;/code&gt; (참조 프라그를 &lt;a href=&quot;perlmod#vars&quot;&gt;perlmod를에서 &quot;바르&quot;&lt;/a&gt; ) 명시 적으로 패키지 네임 스페이스의 모든 전역 자격에 대한 대안과 같은 상황에서 사용할 수있다. 이 pragma로 미리 선언 된 변수는 자동로드 된 루틴에 표시됩니다 (그러나 패키지 외부에서는 표시되지 않습니다. 안타깝게도).</target>
        </trans-unit>
        <trans-unit id="0a270d12703e96872d5ec49cc2bfa5c1ab0eb455" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;vars&lt;/code&gt; pragma (see &lt;a href=&quot;perlmod#vars&quot;&gt;vars in perlmod&lt;/a&gt;) may be used in such situations as an alternative to explicitly qualifying all globals with the package namespace. Variables pre-declared with this pragma will be visible to any autoloaded routines (but will not be invisible outside the package, unfortunately).</source>
          <target state="translated">은 &lt;code&gt;vars&lt;/code&gt; 프라 그마 (참조를&lt;a href=&quot;perlmod#vars&quot;&gt; perlmod를에 바르&lt;/a&gt; ) 명시 적으로 패키지 네임 스페이스의 모든 전역 자격에 대한 대안과 같은 상황에서 사용할 수있다. 이 pragma로 미리 선언 된 변수는 모든 자동로드 루틴에 표시됩니다 (그러나 불행히도 패키지 외부에서는 보이지 않습니다).</target>
        </trans-unit>
        <trans-unit id="8a981f510b5bc1a31c1fe6f83ee184b884a41beb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;verbose&lt;/code&gt; and &lt;code&gt;inc&lt;/code&gt; attributes influence the behavior of this search; notably, &lt;code&gt;inc&lt;/code&gt; , if true, adds @INC</source>
          <target state="translated">&lt;code&gt;verbose&lt;/code&gt; 및 &lt;code&gt;inc&lt;/code&gt; 특성이 검색의 동작에 영향을 미칠; 특히 &lt;code&gt;inc&lt;/code&gt; 는 true이면 @INC를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="e2febc4d875aa8fe8fb27485c483c05158694811" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;verbose&lt;/code&gt; and &lt;code&gt;inc&lt;/code&gt; attributes influence the behavior of this search; notably, &lt;code&gt;inc&lt;/code&gt;, if true, adds @INC</source>
          <target state="translated">&lt;code&gt;verbose&lt;/code&gt; 및 &lt;code&gt;inc&lt;/code&gt; 특성이 검색의 동작에 영향을 미칠; 특히 &lt;code&gt;inc&lt;/code&gt; 는 true이면 @INC를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="543a455e6e879b54b06a46e043825bb2c5bcee1e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;version&lt;/code&gt; option is required. If it is omitted or if an unsupported version is given, then &lt;code&gt;provides&lt;/code&gt; will throw an error.</source>
          <target state="translated">&lt;code&gt;version&lt;/code&gt; 옵션이 필요합니다. 생략되거나 지원되지 않는 버전이 제공되면 &lt;code&gt;provides&lt;/code&gt; 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="647cdf74da11836aaddbacaf0e85905018d3cf1e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;vmsopen&lt;/code&gt; function enables you to specify optional RMS arguments to the VMS CRTL when opening a file. Its operation is similar to the built-in Perl &lt;code&gt;open&lt;/code&gt; function (see &lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt; for a complete description), but it will only open normal files; it cannot open pipes or duplicate existing I/O handles. Up to 8 optional arguments may follow the file name. These arguments should be strings which specify optional file characteristics as allowed by the CRTL. (See the CRTL reference manual description of creat() and fopen() for details.) If successful, &lt;code&gt;vmsopen&lt;/code&gt; returns a VMS::Stdio file handle; if an error occurs, it returns &lt;code&gt;undef&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;vmsopen&lt;/code&gt; 함수는 파일을 열 때 VMS CRTL에 대한 선택적 RMS 인수를 지정할 수 있습니다. 작동은 내장 된 Perl &lt;code&gt;open&lt;/code&gt; 기능 과 유사 하지만 (전체 설명 은 &lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt; 참조 ) 일반 파일 만 엽니 다. 파이프를 열거 나 기존 I / O 핸들을 복제 할 수 없습니다. 최대 8 개의 선택적 인수가 파일 이름 뒤에 올 수 있습니다. 이러한 인수는 CRTL에서 허용하는 선택적 파일 특성을 지정하는 문자열이어야합니다. (자세한 내용은 creat () 및 fopen ()에 대한 CRTL 참조 설명서 설명을 참조하십시오.) 성공하면 &lt;code&gt;vmsopen&lt;/code&gt; 은 VMS :: Stdio 파일 핸들을 반환합니다. 오류가 발생하면 &lt;code&gt;undef&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="42e9db15fd405837558fc69a3922cf4c07b0d66c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;void&lt;/code&gt; return type for this function tells the &lt;b&gt;xsubpp&lt;/b&gt; compiler that the RETVAL variable is not needed or used and that it should not be created. In most scenarios the void return type should be used with the PPCODE: directive.</source>
          <target state="translated">이 함수 의 &lt;code&gt;void&lt;/code&gt; 리턴 유형은 &lt;b&gt;xsubpp&lt;/b&gt; 컴파일러에게 RETVAL 변수가 필요하지 않거나 사용되지 않으며 작성되어서는 안된다고 알려줍니다 . 대부분의 시나리오에서 void 리턴 유형은 PPCODE : 지시문과 함께 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="0803129a0bffe56a31c42b951ef5b3d0fb1885a9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;wanted()&lt;/code&gt; function does whatever verifications you want on each file and directory. Note that despite its name, the &lt;code&gt;wanted()&lt;/code&gt; function is a generic callback function, and does &lt;b&gt;not&lt;/b&gt; tell File::Find if a file is &quot;wanted&quot; or not. In fact, its return value is ignored.</source>
          <target state="translated">&lt;code&gt;wanted()&lt;/code&gt; 함수는 각 파일 및 디렉토리에 원하는 검증한다. 이름에도 불구하고 &lt;code&gt;wanted()&lt;/code&gt; 함수는 일반 콜백 함수이며&lt;b&gt; 없는&lt;/b&gt; 파일 말은 : 파일이 &quot;원&quot;여부를 찾습니다. 실제로, 반환 값은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="31b1fe49028e0123810b9a17034fff70bf1be6cc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;warnings&lt;/code&gt; pragma gives control over which warnings are enabled in which parts of a Perl program. It's a more flexible alternative for both the command line flag &lt;b&gt;-w&lt;/b&gt; and the equivalent Perl variable, &lt;code&gt;$^W&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;warnings&lt;/code&gt; 프라그 경고가 펄 프로그램의 어느 부분에서 활성화되는 동안 제어를 제공한다. 명령 행 플래그 &lt;b&gt;-w&lt;/b&gt; 와 동등한 Perl 변수 &lt;code&gt;$^W&lt;/code&gt; 모두에 대한보다 유연한 대안입니다. .</target>
        </trans-unit>
        <trans-unit id="a8cf47d373c14fa99c46a7f56571b8224d41ad4d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;warnings&lt;/code&gt; pragma gives control over which warnings are enabled in which parts of a Perl program. It's a more flexible alternative for both the command line flag &lt;b&gt;-w&lt;/b&gt; and the equivalent Perl variable, &lt;code&gt;$^W&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;warnings&lt;/code&gt; 프라그 경고가 펄 프로그램의 어느 부분에서 활성화되는 동안 제어를 제공한다. 명령 줄 플래그 &lt;b&gt;-w&lt;/b&gt; 및 이에 상응하는 Perl 변수 &lt;code&gt;$^W&lt;/code&gt; 모두에 대한보다 유연한 대안입니다 .</target>
        </trans-unit>
        <trans-unit id="4d599e8a7252be8237239500a33b9cae49be5da2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;warnings&lt;/code&gt; pragma provides a number of functions that are useful for module authors. These are used when you want to report a module-specific warning to a calling module has enabled warnings via the &lt;code&gt;warnings&lt;/code&gt; pragma.</source>
          <target state="translated">&lt;code&gt;warnings&lt;/code&gt; pragma는 모듈 작성자 유용한 기능을 제공합니다. 이는 호출 모듈에 모듈 별 경고를보고하려는 경우 경고를 통해 경고를 활성화 &lt;code&gt;warnings&lt;/code&gt; pragma.</target>
        </trans-unit>
        <trans-unit id="eaaf2c2b19accccb92902e0f89453388a8136ad7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;when&lt;/code&gt; modifier is an experimental feature that first appeared in Perl 5.14. To use it, you should include a &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; v5.14&lt;/code&gt; declaration. (Technically, it requires only the &lt;code&gt;switch&lt;/code&gt; feature, but that aspect of it was not available before 5.14.) Operative only from within a &lt;code&gt;foreach&lt;/code&gt; loop or a &lt;code&gt;given&lt;/code&gt; block, it executes the statement only if the smartmatch &lt;code&gt;$_ ~~ &lt;i&gt;EXPR&lt;/i&gt;&lt;/code&gt; is true. If the statement executes, it is followed by a &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; from inside a &lt;code&gt;foreach&lt;/code&gt; and &lt;code&gt;break&lt;/code&gt; from inside a &lt;code&gt;given&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;when&lt;/code&gt; 수정 먼저 펄 5.14에 나타난 실험적인 기능입니다. 그것을 사용하려면, 당신은 포함해야 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; v5.14&lt;/code&gt; 선언. (기술적으로는 &lt;code&gt;switch&lt;/code&gt; 기능 만 필요 하지만 그 기능은 5.14 이전에는 사용할 수 없었습니다.) &lt;code&gt;foreach&lt;/code&gt; 루프 또는 &lt;code&gt;given&lt;/code&gt; 블록 내 에서만 작동 할 수 있으며 스마트 매치 &lt;code&gt;$_ ~~ &lt;i&gt;EXPR&lt;/i&gt;&lt;/code&gt; 이 참인 경우에만 명령문을 실행 합니다. 문이 실행되면, 그것은 뒤에 &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; , 안쪽에서 &lt;code&gt;foreach&lt;/code&gt; 와 &lt;code&gt;break&lt;/code&gt; 돌며에서 &lt;code&gt;given&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="01d8e0a81cc17a534c96cebc629a6872720abbea" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;when&lt;/code&gt; modifier is an experimental feature that first appeared in Perl 5.14. To use it, you should include a &lt;code&gt;use v5.14&lt;/code&gt; declaration. (Technically, it requires only the &lt;code&gt;switch&lt;/code&gt; feature, but that aspect of it was not available before 5.14.) Operative only from within a &lt;code&gt;foreach&lt;/code&gt; loop or a &lt;code&gt;given&lt;/code&gt; block, it executes the statement only if the smartmatch &lt;code&gt;$_ ~~ &lt;i&gt;EXPR&lt;/i&gt;&lt;/code&gt; is true. If the statement executes, it is followed by a &lt;code&gt;next&lt;/code&gt; from inside a &lt;code&gt;foreach&lt;/code&gt; and &lt;code&gt;break&lt;/code&gt; from inside a &lt;code&gt;given&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;when&lt;/code&gt; 수정 먼저 펄 5.14에 나타난 실험적인 기능입니다. 이를 사용하려면 use &lt;code&gt;use v5.14&lt;/code&gt; 선언을 포함해야합니다 . (기술적으로는 &lt;code&gt;switch&lt;/code&gt; 기능 만 필요 하지만 5.14 이전에는 사용할 수 없었습니다.) &lt;code&gt;foreach&lt;/code&gt; 루프 또는 &lt;code&gt;given&lt;/code&gt; 블록 내 에서만 작동하며 스마트 매치 &lt;code&gt;$_ ~~ &lt;i&gt;EXPR&lt;/i&gt;&lt;/code&gt; 이 true 인 경우에만 명령문을 실행 합니다. 문이 실행되면, 그것은 뒤에 &lt;code&gt;next&lt;/code&gt; , 안쪽에서 &lt;code&gt;foreach&lt;/code&gt; 와 &lt;code&gt;break&lt;/code&gt; 돌며에서 &lt;code&gt;given&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e19be3044d8f18bead09bab3403090b34e1156d5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;while&lt;/code&gt; and &lt;code&gt;until&lt;/code&gt; modifiers have the usual &quot;&lt;code&gt;while&lt;/code&gt; loop&quot; semantics (conditional evaluated first), except when applied to a &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt;&lt;/code&gt;-BLOCK (or to the Perl4 &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt;&lt;/code&gt;-SUBROUTINE statement), in which case the block executes once before the conditional is evaluated.</source>
          <target state="translated">&lt;code&gt;while&lt;/code&gt; 및 &lt;code&gt;until&lt;/code&gt; 개질제가 &quot;일반적인 &lt;code&gt;while&lt;/code&gt; 시맨틱 (A)에인가하는 경우를 제외하고, (조건부 제 평가) 루프&quot; &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt;&lt;/code&gt; (또는 perl4의로 - 블록 &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt;&lt;/code&gt; , -SUBROUTINE 문)이 경우, 상기 블록이 실행 회 전의 조건으로 평가 된가있는 .</target>
        </trans-unit>
        <trans-unit id="9a6cf234df302fa34cb78a16f01d3bf12b7f579c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;while&lt;/code&gt; and &lt;code&gt;until&lt;/code&gt; modifiers have the usual &quot;&lt;code&gt;while&lt;/code&gt; loop&quot; semantics (conditional evaluated first), except when applied to a &lt;code&gt;do&lt;/code&gt;-BLOCK (or to the Perl4 &lt;code&gt;do&lt;/code&gt;-SUBROUTINE statement), in which case the block executes once before the conditional is evaluated.</source>
          <target state="translated">&lt;code&gt;while&lt;/code&gt; 및 &lt;code&gt;until&lt;/code&gt; 개질제가 &quot;일반적인 &lt;code&gt;while&lt;/code&gt; 시맨틱 (A)에인가하는 경우를 제외하고, (조건부 제 평가) 루프&quot; &lt;code&gt;do&lt;/code&gt; (또는 perl4의로 - 블록 &lt;code&gt;do&lt;/code&gt; , -SUBROUTINE 문)이 경우, 상기 블록이 실행 회 전의 조건으로 평가 된가있는 .</target>
        </trans-unit>
        <trans-unit id="3d5b06f931731acb22dad061fcd52f2783c874b3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;while&lt;/code&gt; statement executes the block as long as the expression is &lt;a href=&quot;#Truth-and-Falsehood&quot;&gt;true&lt;/a&gt;. The &lt;code&gt;until&lt;/code&gt; statement executes the block as long as the expression is false. The LABEL is optional, and if present, consists of an identifier followed by a colon. The LABEL identifies the loop for the loop control statements &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/last&quot;&gt;last&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;functions/redo&quot;&gt;redo&lt;/a&gt;&lt;/code&gt;. If the LABEL is omitted, the loop control statement refers to the innermost enclosing loop. This may include dynamically looking back your call-stack at run time to find the LABEL. Such desperate behavior triggers a warning if you use the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings&lt;/code&gt; pragma or the &lt;b&gt;-w&lt;/b&gt; flag.</source>
          <target state="translated">그만큼 &lt;code&gt;while&lt;/code&gt; 문은 오랫동안 표현만큼 블록을 실행 &lt;a href=&quot;#Truth-and-Falsehood&quot;&gt;사실&lt;/a&gt; . &lt;code&gt;until&lt;/code&gt; 문은 긴 표현식이 거짓으로로 블록을 실행합니다. LABEL은 선택 사항이며 존재하는 경우 식별자와 콜론으로 구성됩니다. LABEL은 &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;functions/redo&quot;&gt;redo&lt;/a&gt;&lt;/code&gt; 루프 제어문의 루프를 식별합니다 . LABEL을 생략하면 루프 제어문이 가장 안쪽의 루프를 나타냅니다. 여기에는 LABEL을 찾기 위해 런타임에 콜 스택을 동적으로 다시 찾는 것이 포함될 수 있습니다. &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings&lt;/code&gt; pragma 또는 &lt;b&gt;-w&lt;/b&gt; 플래그 를 사용하면 이러한 절망적 인 동작으로 경고가 트리거됩니다 .</target>
        </trans-unit>
        <trans-unit id="fc7bfa0e2e102bef2e270e8846cdbd5da131def6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;while&lt;/code&gt; statement executes the block as long as the expression is true. The &lt;code&gt;until&lt;/code&gt; statement executes the block as long as the expression is false. The LABEL is optional, and if present, consists of an identifier followed by a colon. The LABEL identifies the loop for the loop control statements &lt;code&gt;next&lt;/code&gt;, &lt;code&gt;last&lt;/code&gt;, and &lt;code&gt;redo&lt;/code&gt;. If the LABEL is omitted, the loop control statement refers to the innermost enclosing loop. This may include dynamically looking back your call-stack at run time to find the LABEL. Such desperate behavior triggers a warning if you use the &lt;code&gt;use warnings&lt;/code&gt; pragma or the &lt;b&gt;-w&lt;/b&gt; flag.</source>
          <target state="translated">&lt;code&gt;while&lt;/code&gt; 문은 긴 표현식이 true 인 블록을 실행합니다. &lt;code&gt;until&lt;/code&gt; 문은 긴 표현식이 거짓으로로 블록을 실행합니다. LABEL은 선택 사항이며 존재하는 경우 콜론이 뒤 따르는 식별자로 구성됩니다. LABEL은 &lt;code&gt;next&lt;/code&gt; , &lt;code&gt;last&lt;/code&gt; 및 &lt;code&gt;redo&lt;/code&gt; 루프 제어문에 대한 루프를 식별합니다 . LABEL이 생략되면 루프 제어문은 가장 안쪽에있는 루프를 참조합니다. 여기에는 LABEL을 찾기 위해 런타임에 호출 스택을 동적으로 다시 찾는 것이 포함될 수 있습니다. 이러한 절박한 동작은 &lt;code&gt;use warnings&lt;/code&gt; pragma 또는 &lt;b&gt;-w&lt;/b&gt; 플래그 를 사용하는 경우 경고를 트리거합니다 .</target>
        </trans-unit>
        <trans-unit id="2df4bdf5b271135d9fbaa4b9e22485bd5691df53" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;write&lt;/code&gt; method is a method, so it either gets a class or instance. The two arguments are the &lt;code&gt;$event&lt;/code&gt; object it should record, and the &lt;code&gt;$assert_num&lt;/code&gt; which is the number of the current assertion (ok), or the last assertion if this event is not itself an assertion. The assertion number may be any integer 0 or greater, and may be undefined in some cases.</source>
          <target state="translated">&lt;code&gt;write&lt;/code&gt; 는 하나의 클래스 또는 인스턴스를 얻을 수 있도록 방법은 방법이다. 두 개의 인수는 기록해야하는 &lt;code&gt;$event&lt;/code&gt; 객체와 현재 주장 (ok)의 번호 인 &lt;code&gt;$assert_num&lt;/code&gt; 또는이 이벤트 자체가 주장이 아닌 경우 마지막 주장입니다. 어설 션 번호는 정수 0 이상일 수 있으며 경우에 따라 정의되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="42f557fbb89c75fd2ab740d93d25721ccbf0fda2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;yield&lt;/code&gt; function allows another thread to take control of the CPU. The exact results are implementation-dependent.</source>
          <target state="translated">&lt;code&gt;yield&lt;/code&gt; 함수는 다른 스레드가 CPU를 제어 할 수있다. 정확한 결과는 구현에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="213469077fec26be3b6b3b082204198d28c562aa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;zipinfo&lt;/code&gt; program that comes with the info-zip distribution (&lt;a href=&quot;http://www.info-zip.org/&quot;&gt;http://www.info-zip.org/&lt;/a&gt;) can also display details of the structure of a zip file.</source>
          <target state="translated">info-zip 배포 ( &lt;a href=&quot;http://www.info-zip.org/&quot;&gt;http://www.info-zip.org/&lt;/a&gt; ) 와 함께 제공 되는 &lt;code&gt;zipinfo&lt;/code&gt; 프로그램 은 zip 파일 구조의 세부 정보도 표시 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="246e63b2eb0074027eaf6b6fe6bf0995cbbb987b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;||&lt;/code&gt;, &lt;code&gt;//&lt;/code&gt; and &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; operators return the last value evaluated (unlike C's &lt;code&gt;||&lt;/code&gt; and &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;, which return 0 or 1). Thus, a reasonably portable way to find out the home directory might be:</source>
          <target state="translated">&lt;code&gt;||&lt;/code&gt; , &lt;code&gt;//&lt;/code&gt; 및 &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; 연산자는 마지막으로 평가 된 값을 반환합니다 (C의 &lt;code&gt;||&lt;/code&gt; 및 &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; 는 0 또는 1을 반환 함). 따라서 홈 디렉토리를 찾는 합리적인 이식 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="11f57b3d94eabb5c19fb9360ab6afe8316dfa0a5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;~~&lt;/code&gt; operator compares its operands &quot;polymorphically&quot;, determining how to compare them according to their actual types (numeric, string, array, hash, etc.) Like the equality operators with which it shares the same precedence, &lt;code&gt;~~&lt;/code&gt; returns 1 for true and &lt;code&gt;&quot;&quot;&lt;/code&gt; for false. It is often best read aloud as &quot;in&quot;, &quot;inside of&quot;, or &quot;is contained in&quot;, because the left operand is often looked for</source>
          <target state="translated">&lt;code&gt;~~&lt;/code&gt; 연산자는 동일한 우선 공유되는 항등 연산자 마찬가지로 실제 유형 (숫자, 스트링, 어레이, 해시 등)에 따라 이들과 비교하는 방법을 결정하는 단계 &quot;다형&quot;피연산자 비교 &lt;code&gt;~~&lt;/code&gt; 반품 1 참이고 &lt;code&gt;&quot;&quot;&lt;/code&gt; 는 거짓입니다. 왼쪽 피연산자가 종종 찾기 때문에 &quot;in&quot;, &quot;inside of&quot;또는 &quot;include in&quot;으로 큰소리로 읽는 것이 가장 좋습니다.</target>
        </trans-unit>
        <trans-unit id="9e2869673394c26d565412dbb368358875961728" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;~~&lt;/code&gt; operator compares its operands &quot;polymorphically&quot;, determining how to compare them according to their actual types (numeric, string, array, hash, etc.). Like the equality operators with which it shares the same precedence, &lt;code&gt;~~&lt;/code&gt; returns 1 for true and &lt;code&gt;&quot;&quot;&lt;/code&gt; for false. It is often best read aloud as &quot;in&quot;, &quot;inside of&quot;, or &quot;is contained in&quot;, because the left operand is often looked for</source>
          <target state="translated">&lt;code&gt;~~&lt;/code&gt; 의 운영자는 실제 유형 (숫자, 스트링, 어레이, 해시 등)에 따라서 그들을 비교하는 방법을 결정하는 단계 &quot;다형&quot;피연산자를 비교한다. 동일한 우선 순위를 공유하는 같음 연산자와 마찬가지로 &lt;code&gt;~~&lt;/code&gt; 는 true 인 경우 1을 반환 하고 false 인 경우 &lt;code&gt;&quot;&quot;&lt;/code&gt; 를 반환합니다 . 왼쪽 피연산자가 종종 검색되기 때문에 &quot;in&quot;, &quot;inside of&quot;또는 &quot;is included in&quot;으로 소리내어 읽는 것이 가장 좋습니다.</target>
        </trans-unit>
        <trans-unit id="ef321bd7088ac81817f2231db61c1174692aaac0" translate="yes" xml:space="preserve">
          <source>The ADLER32 checksum field must be present.</source>
          <target state="translated">ADLER32 체크섬 필드가 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="9c4519701849f27da68be727b95e63207f2a9abf" translate="yes" xml:space="preserve">
          <source>The AIX tar does not fill all unused space in the tar archive with 0x00. This sometimes leads to warning messages from &lt;code&gt;Archive::Tar&lt;/code&gt; .</source>
          <target state="translated">AIX tar는 tar 아카이브에서 사용되지 않은 모든 공간을 0x00으로 채우지 않습니다. 이것은 때때로 &lt;code&gt;Archive::Tar&lt;/code&gt; 경고 메시지로 이어집니다 .</target>
        </trans-unit>
        <trans-unit id="508b055d2e59a80ceed1c9bfc5a331ff6cb825bc" translate="yes" xml:space="preserve">
          <source>The AIX tar does not fill all unused space in the tar archive with 0x00. This sometimes leads to warning messages from &lt;code&gt;Archive::Tar&lt;/code&gt;.</source>
          <target state="translated">AIX tar는 tar 아카이브에서 사용되지 않은 모든 공간을 0x00으로 채우지는 않습니다. 이로 인해 &lt;code&gt;Archive::Tar&lt;/code&gt; 에서 경고 메시지가 표시되는 경우가 있습니다.</target>
        </trans-unit>
        <trans-unit id="b5549afa573e8454744ea43299cd8d8505147fcd" translate="yes" xml:space="preserve">
          <source>The ALIAS: Keyword</source>
          <target state="translated">별칭 : 키워드</target>
        </trans-unit>
        <trans-unit id="2ce9242faeeab07eef2f7afd701bea6933de8059" translate="yes" xml:space="preserve">
          <source>The ALIAS: keyword allows an XSUB to have two or more unique Perl names and to know which of those names was used when it was invoked. The Perl names may be fully-qualified with package names. Each alias is given an index. The compiler will setup a variable called &lt;code&gt;ix&lt;/code&gt; which contain the index of the alias which was used. When the XSUB is called with its declared name &lt;code&gt;ix&lt;/code&gt; will be 0.</source>
          <target state="translated">ALIAS : 키워드를 사용하면 XSUB가 고유 한 Perl 이름을 두 개 이상 가질 수 있으며 호출시 사용 된 이름을 알 수 있습니다. Perl 이름은 패키지 이름으로 정규화 될 수 있습니다. 각 별명에는 색인이 제공됩니다. 컴파일러 는 사용 된 별칭의 색인을 포함하는 &lt;code&gt;ix&lt;/code&gt; 라는 변수를 설정합니다 . 선언 된 이름으로 XSUB를 호출하면 &lt;code&gt;ix&lt;/code&gt; 는 0이됩니다.</target>
        </trans-unit>
        <trans-unit id="15fd0430aabb02304def7c36146cf671599d3942" translate="yes" xml:space="preserve">
          <source>The API</source>
          <target state="translated">API</target>
        </trans-unit>
        <trans-unit id="9ed04c99d7b2c6a9ba47b9e4b73c73bb3ccc347c" translate="yes" xml:space="preserve">
          <source>The API was changed in the 2.0 branch. For a time, &lt;code&gt;mkpath&lt;/code&gt; and &lt;code&gt;rmtree&lt;/code&gt; tried, unsuccessfully, to deal with the two different calling mechanisms. This approach was considered a failure.</source>
          <target state="translated">API는 2.0 지점에서 변경되었습니다. 한동안 &lt;code&gt;mkpath&lt;/code&gt; 와 &lt;code&gt;rmtree&lt;/code&gt; 는 두 가지 다른 호출 메커니즘을 다루지 못했습니다. 이 접근법은 실패로 간주되었습니다.</target>
        </trans-unit>
        <trans-unit id="009ead0f6ffd2c056d27d3bfda98818a54d2faea" translate="yes" xml:space="preserve">
          <source>The ASCII region (0x00-0x7f) is preserved for all encodings, even though this conflicts with mappings by the Unicode Consortium.</source>
          <target state="translated">ASCII 영역 (0x00-0x7f)은 유니 코드 컨소시엄의 매핑과 충돌하더라도 모든 인코딩에 대해 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="93fd64b40c593362e390e4e7060b0bced9f138ed" translate="yes" xml:space="preserve">
          <source>The ASCII-specific functions. Each of these is just the same as the version without the trailing &quot;A&quot;.</source>
          <target state="translated">ASCII 관련 기능. 이들 각각은 후행 &quot;A&quot;가없는 버전과 동일합니다.</target>
        </trans-unit>
        <trans-unit id="b3c4e287eeab5aae5482e7df8b6e409cada7c372" translate="yes" xml:space="preserve">
          <source>The ASCII/Latin-1/Unicode character with that number. A leading &quot;0x&quot; means that</source>
          <target state="translated">해당 번호의 ASCII / Latin-1 / Unicode 문자 선행 &quot;0x&quot;는</target>
        </trans-unit>
        <trans-unit id="b76347c5c2c07c6a471b32d6864a1a7d9b8fb48a" translate="yes" xml:space="preserve">
          <source>The AUTOLOAD method, discussed in &lt;a href=&quot;perlsub#Autoloading&quot;&gt;&quot;Autoloading&quot; in perlsub&lt;/a&gt; lets you capture calls to undefined functions and methods.</source>
          <target state="translated">&lt;a href=&quot;perlsub#Autoloading&quot;&gt;perlsub의 &quot;자동로드&quot;에서&lt;/a&gt; 설명한 AUTOLOAD 메서드를 사용하면 정의되지 않은 함수 및 메서드에 대한 호출을 캡처 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e2afefe4f37ea14f731718bb07a4d6306f1639c5" translate="yes" xml:space="preserve">
          <source>The AUTOLOAD method, discussed in &lt;a href=&quot;perlsub#Autoloading&quot;&gt;Autoloading in perlsub&lt;/a&gt; lets you capture calls to undefined functions and methods.</source>
          <target state="translated">&lt;a href=&quot;perlsub#Autoloading&quot;&gt;perlsub의 자동로드에&lt;/a&gt; 설명 된 AUTOLOAD 메소드를 사용하면 정의되지 않은 함수 및 메소드에 대한 호출을 캡처 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="31231455a0cef5b5794db63f07a47d2f6efab12c" translate="yes" xml:space="preserve">
          <source>The ActiveState Pages, &lt;a href=&quot;http://www.activestate.com/&quot;&gt;http://www.activestate.com/&lt;/a&gt;</source>
          <target state="translated">ActiveState 페이지, &lt;a href=&quot;http://www.activestate.com/&quot;&gt;http://www.activestate.com/&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="334394ca32871dfe81ad4bfaf08e575776ff3a37" translate="yes" xml:space="preserve">
          <source>The ActiveState Pages, &lt;a href=&quot;https://www.activestate.com/&quot;&gt;https://www.activestate.com/&lt;/a&gt;</source>
          <target state="translated">ActiveState 페이지, &lt;a href=&quot;https://www.activestate.com/&quot;&gt;https://www.activestate.com/&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="fbbc6fc0e5dd1ef33879bfc672f5e3e8813e4f97" translate="yes" xml:space="preserve">
          <source>The Adventures of Tom Bombadil</source>
          <target state="translated">톰 봄 바딜의 모험</target>
        </trans-unit>
        <trans-unit id="e2e0a5aea5199e87efc4db9939033262cf1e73b8" translate="yes" xml:space="preserve">
          <source>The Alignment Pit</source>
          <target state="translated">정렬 구덩이</target>
        </trans-unit>
        <trans-unit id="68a751b9c456def01d238b0c06471f4927931bb2" translate="yes" xml:space="preserve">
          <source>The American Standard Code for Information Interchange (ASCII or US-ASCII) is a set of integers running from 0 to 127 (decimal) that have standardized interpretations by the computers which use ASCII. For example, 65 means the letter &quot;A&quot;. The range 0..127 can be covered by setting the bits in a 7-bit binary digit, hence the set is sometimes referred to as &quot;7-bit ASCII&quot;. ASCII was described by the American National Standards Institute document ANSI X3.4-1986. It was also described by ISO 646:1991 (with localization for currency symbols). The full ASCII set is given in the table &lt;a href=&quot;#recipe-3&quot;&gt;below&lt;/a&gt; as the first 128 elements. Languages that can be written adequately with the characters in ASCII include English, Hawaiian, Indonesian, Swahili and some Native American languages.</source>
          <target state="translated">미국 정보 교환 표준 코드 (ASCII 또는 US-ASCII)는 ASCII를 사용하는 컴퓨터에서 표준화 된 해석을 갖는 0에서 127 (10 진수)까지 실행되는 정수 세트입니다. 예를 들어 65는 문자 &quot;A&quot;를 의미합니다. 0..127 범위는 비트를 7 비트 이진수로 설정하여 적용 할 수 있으므로 세트를 &quot;7 비트 ASCII&quot;라고도합니다. ASCII는 American National Standards Institute 문서 ANSI X3.4-1986에 의해 설명되었습니다. 또한 ISO 646 : 1991 (통화 기호 현지화)으로 설명되었습니다. 전체 ASCII 세트는 &lt;a href=&quot;#recipe-3&quot;&gt;아래&lt;/a&gt; 표에 나와 있습니다. 에서 처음 128 개 요소로 제공됩니다. ASCII 문자로 적절하게 작성할 수있는 언어에는 영어, 하 와이어, 인도네시아어, 스와힐리어 및 일부 아메리카 원주민 언어가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="4f30a3791e1ac69d9730db09043c7e01d216a23a" translate="yes" xml:space="preserve">
          <source>The American Standard Code for Information Interchange (ASCII or US-ASCII) is a set of integers running from 0 to 127 (decimal) that have standardized interpretations by the computers which use ASCII. For example, 65 means the letter &quot;A&quot;. The range 0..127 can be covered by setting various bits in a 7-bit binary digit, hence the set is sometimes referred to as &quot;7-bit ASCII&quot;. ASCII was described by the American National Standards Institute document ANSI X3.4-1986. It was also described by ISO 646:1991 (with localization for currency symbols). The full ASCII set is given in the table &lt;a href=&quot;#recipe-3&quot;&gt;below&lt;/a&gt; as the first 128 elements. Languages that can be written adequately with the characters in ASCII include English, Hawaiian, Indonesian, Swahili and some Native American languages.</source>
          <target state="translated">정보 교환을위한 미국 표준 코드 (ASCII 또는 US-ASCII)는 ASCII를 사용하는 컴퓨터에 의해 표준화 된 해석이있는 0에서 127 (10 진수) 사이의 정수 세트입니다. 예를 들어 65는 문자 &quot;A&quot;를 의미합니다. 범위 0..127은 7 비트 이진 숫자로 다양한 비트를 설정하여 커버 할 수 있으므로이 세트를 &quot;7 비트 ASCII&quot;라고도합니다. ASCII는 American National Standards Institute 문서 ANSI X3.4-1986에 설명되어 있습니다. 또한 ISO 646 : 1991 (통화 기호에 대한 현지화 포함)에 의해 설명되었습니다. 전체 ASCII 세트는 &lt;a href=&quot;#recipe-3&quot;&gt;아래&lt;/a&gt; 표 에 처음 128 개 요소로 제공됩니다. ASCII 문자로 적절하게 작성할 수있는 언어에는 영어, 하 와이어, 인도네시아어, 스와힐리어 및 일부 아메리카 원주민 언어가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="f3ff218a8809c68d0eb083f2cf66b8207142d4f0" translate="yes" xml:space="preserve">
          <source>The American Standard Code for Information Interchange (a 7-bit character set adequate only for poorly representing English text). Often used loosely to describe the lowest 128 values of the various ISO-8859-X character sets, a bunch of mutually incompatible 8-bit codes best described as half ASCII. See also &lt;b&gt;Unicode&lt;/b&gt;.</source>
          <target state="translated">미국 정보 교환 표준 코드 (영어 텍스트를 잘 표현하지 못하는 경우에만 적합한 7 비트 문자 세트). 다양한 ISO-8859-X 문자 세트의 최저 128 값을 설명하기 위해 느슨하게 사용되는 경우가 많으며, 절반 ASCII로 가장 잘 기술 된 서로 호환되지 않는 8 비트 코드입니다. &lt;b&gt;유니 코드&lt;/b&gt; 참조&lt;b&gt;&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="0269ea9ab723afb75524e043608495b84069c96f" translate="yes" xml:space="preserve">
          <source>The Amiga::ARexx module allows you to easily create a perl based ARexx host or to send ARexx commands to other programs.</source>
          <target state="translated">Amiga :: ARexx 모듈을 사용하면 펄 기반 ARexx 호스트를 쉽게 만들거나 ARexx 명령을 다른 프로그램으로 보낼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1af5792ad21fdac265ea44a70d1cb66ca1977707" translate="yes" xml:space="preserve">
          <source>The Amiga::Exec module introduces support for Wait().</source>
          <target state="translated">Amiga :: Exec 모듈은 Wait ()에 대한 지원을 도입합니다.</target>
        </trans-unit>
        <trans-unit id="fd1c7da39d90054f5c4c81dc1a1fa13bcbbe82e7" translate="yes" xml:space="preserve">
          <source>The Anatomy of an XSUB</source>
          <target state="translated">XSUB의 해부</target>
        </trans-unit>
        <trans-unit id="0746d95bfde5c5ba18bf27b5d1463ad01ffdafa1" translate="yes" xml:space="preserve">
          <source>The Argument Stack</source>
          <target state="translated">인수 스택</target>
        </trans-unit>
        <trans-unit id="59f8369b68ee932dd97b5ec57202b3f3969c4a83" translate="yes" xml:space="preserve">
          <source>The Arrow Operator</source>
          <target state="translated">화살표 연산자</target>
        </trans-unit>
        <trans-unit id="e40e5d487b331e1f7f4c2477322a84662ea1dcde" translate="yes" xml:space="preserve">
          <source>The Art of Computer Programming</source>
          <target state="translated">컴퓨터 프로그래밍의 기술</target>
        </trans-unit>
        <trans-unit id="e6a71a9e8ae70e8f61fd0c5d80d8189dbf3cf681" translate="yes" xml:space="preserve">
          <source>The AutoSplit and &lt;b&gt;AutoLoader&lt;/b&gt; modules automate the creation of forward declarations. The AutoSplit module creates an 'index' file containing forward declarations of all the AutoSplit subroutines. When the AutoLoader module is 'use'd it loads these declarations into its callers package.</source>
          <target state="translated">오토 스플릿 및 &lt;b&gt;오토로더&lt;/b&gt; 모듈은 전달 선언 작성을 자동화합니다. AutoSplit 모듈은 모든 AutoSplit 서브 루틴의 순방향 선언을 포함하는 'index'파일을 만듭니다. AutoLoader 모듈이 '사용'되면이 선언을 호출자 패키지에로드합니다.</target>
        </trans-unit>
        <trans-unit id="547ca45f60093a7fb15745aaa1976d8399cc0918" translate="yes" xml:space="preserve">
          <source>The B-determined class of the OP, in all caps.</source>
          <target state="translated">모든 한도에서 B가 결정한 OP 등급.</target>
        </trans-unit>
        <trans-unit id="fad9fed447a0e7963d894765232a4acc4b663de9" translate="yes" xml:space="preserve">
          <source>The B::Xref module is used to generate a cross reference listing of all definitions and uses of variables, subroutines and formats in a Perl program. It is implemented as a backend for the Perl compiler.</source>
          <target state="translated">B :: Xref 모듈은 Perl 프로그램에서 변수, 서브 루틴 및 형식의 모든 정의 및 사용에 대한 상호 참조 목록을 생성하는 데 사용됩니다. Perl 컴파일러의 백엔드로 구현됩니다.</target>
        </trans-unit>
        <trans-unit id="8026a52e63f99adbefc0e084618e1f479fd95572" translate="yes" xml:space="preserve">
          <source>The BITS mode (&quot;0&quot;) interprets the contents of</source>
          <target state="translated">BITS 모드 ( &quot;0&quot;)는</target>
        </trans-unit>
        <trans-unit id="ba88dd1d9005852348725927325ddcf383a69f7c" translate="yes" xml:space="preserve">
          <source>The BLOCK construct can be used to emulate case structures.</source>
          <target state="translated">BLOCK 구문을 사용하여 케이스 구조를 에뮬레이트 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6dfef44d3b22aafe27912b6966e2a486d9c0c14d" translate="yes" xml:space="preserve">
          <source>The BOOT: Keyword</source>
          <target state="translated">BOOT : 키워드</target>
        </trans-unit>
        <trans-unit id="d4a87a13d39a77a50a617134650c09dd8bdc8e3b" translate="yes" xml:space="preserve">
          <source>The BOOT: keyword is used to add code to the extension's bootstrap function. The bootstrap function is generated by the &lt;b&gt;xsubpp&lt;/b&gt; compiler and normally holds the statements necessary to register any XSUBs with Perl. With the BOOT: keyword the programmer can tell the compiler to add extra statements to the bootstrap function.</source>
          <target state="translated">BOOT : 키워드는 확장의 부트 스트랩 함수에 코드를 추가하는 데 사용됩니다. 부트 스트랩 함수는 &lt;b&gt;xsubpp&lt;/b&gt; 컴파일러에 의해 생성되며 일반적으로 Perl에 XSUB를 등록하는 데 필요한 명령문을 보유합니다. BOOT : 키워드를 사용하면 프로그래머는 컴파일러에게 부트 스트랩 함수에 추가 명령문을 추가하도록 지시 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ad4a573da9545ff1a8eab5e0d4f5f08622036178" translate="yes" xml:space="preserve">
          <source>The BTREE file type optionally allows a single key to be associated with an arbitrary number of values. This option is enabled by setting the flags element of &lt;code&gt;$DB_BTREE&lt;/code&gt; to R_DUP when creating the database.</source>
          <target state="translated">BTREE 파일 형식을 사용하면 단일 키를 임의의 수의 값과 연결할 수 있습니다. 이 옵션은 &lt;code&gt;$DB_BTREE&lt;/code&gt; 의 flags 요소를 설정하여 활성화됩니다 데이터베이스를 작성할 때 합니다.</target>
        </trans-unit>
        <trans-unit id="4a8451f6eedb6a6056c8ac828a203a8cf8bdc79c" translate="yes" xml:space="preserve">
          <source>The BTREE interface has a feature which allows partial keys to be matched. This functionality is</source>
          <target state="translated">BTREE 인터페이스에는 부분 키를 일치시킬 수있는 기능이 있습니다. 이 기능은</target>
        </trans-unit>
        <trans-unit id="19350bba9c33f125fd021dceab5ff7633dce372c" translate="yes" xml:space="preserve">
          <source>The BUILD and INSTALL steps are identical to those for Unix. Some modules generate Makefiles that work better with GNU make, which is available from &lt;a href=&quot;http://www.mks.com/s390/gnu/&quot;&gt;http://www.mks.com/s390/gnu/&lt;/a&gt;</source>
          <target state="translated">빌드 및 설치 단계는 Unix와 동일합니다. 일부 모듈은 GNU make와 더 잘 작동하는 Makefile을 생성하며, &lt;a href=&quot;http://www.mks.com/s390/gnu/&quot;&gt;http://www.mks.com/s390/gnu/&lt;/a&gt; 에서 제공됩니다 .</target>
        </trans-unit>
        <trans-unit id="06987733f8223bbe1dde5201da803a816622002c" translate="yes" xml:space="preserve">
          <source>The Basic Principle</source>
          <target state="translated">기본 원리</target>
        </trans-unit>
        <trans-unit id="a093f7952b1838c4dd6aeda28ea5e1fc38030960" translate="yes" xml:space="preserve">
          <source>The Basics</source>
          <target state="translated">기초</target>
        </trans-unit>
        <trans-unit id="afdc8705dda034aabf31fc65386bddfb61c3e95b" translate="yes" xml:space="preserve">
          <source>The Benchmark module encapsulates a number of routines to help you figure out how long it takes to execute some code.</source>
          <target state="translated">벤치 마크 모듈은 몇 가지 루틴을 캡슐화하여 일부 코드를 실행하는 데 걸리는 시간을 파악하는 데 도움을줍니다.</target>
        </trans-unit>
        <trans-unit id="869885b765935f032e1e45165248683c4d860661" translate="yes" xml:space="preserve">
          <source>The Berkeley DB 4.1.25 has been tested with Tru64 V5.1A and found to work. The latest Berkeley DB can be found from &lt;a href=&quot;http://www.sleepycat.com&quot;&gt;http://www.sleepycat.com&lt;/a&gt;.</source>
          <target state="translated">Berkeley DB 4.1.25는 Tru64 V5.1A로 테스트되었으며 작동하는 것으로 나타났습니다. 최신 Berkeley DB는 &lt;a href=&quot;http://www.sleepycat.com&quot;&gt;http://www.sleepycat.com&lt;/a&gt; 에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1425da38b0881b20e7239aedd72aa0c3d5db10c1" translate="yes" xml:space="preserve">
          <source>The Bessel function of the first kind of the order zero.</source>
          <target state="translated">첫 번째 종류의 차수 0의 베셀 함수입니다.</target>
        </trans-unit>
        <trans-unit id="2488bfae0d46b9e4a8c30cc5e6937e82c99c48ea" translate="yes" xml:space="preserve">
          <source>The Bignum mailing list</source>
          <target state="translated">Bignum 메일 링리스트</target>
        </trans-unit>
        <trans-unit id="95802efdaca31b27a14913bfe1089183b4ec8875" translate="yes" xml:space="preserve">
          <source>The C API for the backtrace is as follows:</source>
          <target state="translated">역 추적에 대한 C API는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="89f382052ffa523340ba739809ce6ebbf65c53dd" translate="yes" xml:space="preserve">
          <source>The C array of a padlist, containing the pads. Only subscript it with numbers &amp;gt;= 1, as the 0th entry is not guaranteed to remain usable.</source>
          <target state="translated">패드를 포함하는 패드리스트의 C 배열입니다. 0 번째 항목은 사용 가능한 상태로 유지되지 않으므로 숫자가 1보다 큰 첨자를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="9d9a695f29b97a18f6840062c9b13365fc424c17" translate="yes" xml:space="preserve">
          <source>The C array of pad entries.</source>
          <target state="translated">패드 엔트리의 C 배열입니다.</target>
        </trans-unit>
        <trans-unit id="82cdebaae9f3b94b2c40ce92be9ab7f40abcb4e4" translate="yes" xml:space="preserve">
          <source>The C array of pad names.</source>
          <target state="translated">패드 이름의 C 배열입니다.</target>
        </trans-unit>
        <trans-unit id="66ccfe4f23602b2282c83a4407f8d3eb55b4ce47" translate="yes" xml:space="preserve">
          <source>The C code asks for:</source>
          <target state="translated">C 코드는 다음을 요청합니다.</target>
        </trans-unit>
        <trans-unit id="1755acfd3f32daf3e3ba7fab9fbb3582e6e7bc1c" translate="yes" xml:space="preserve">
          <source>The C function required to call</source>
          <target state="translated">호출하는 데 필요한 C 함수</target>
        </trans-unit>
        <trans-unit id="593e19336c2ea1e5b6f3c47a320c97c9b260fd7c" translate="yes" xml:space="preserve">
          <source>The C library &lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf&lt;/a&gt;&lt;/code&gt;, wrapped if necessary, to ensure that it will return the length of the string written to the buffer. Only rare pre-ANSI systems need the wrapper function - usually this is a direct call to &lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">필요한 경우 랩핑 된 C 라이브러리 &lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf&lt;/a&gt;&lt;/code&gt; 는 버퍼에 기록 된 문자열의 길이를 리턴합니다. 드문 사전 ANSI 시스템에만 래퍼 기능이 필요합니다. 일반적으로 이것은 &lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf&lt;/a&gt;&lt;/code&gt; 에 대한 직접 호출 입니다.</target>
        </trans-unit>
        <trans-unit id="9f593f0f7e2f42e16decd49842d3eba832ba134e" translate="yes" xml:space="preserve">
          <source>The C library &lt;code&gt;snprintf&lt;/code&gt; functionality, if available and standards-compliant (uses &lt;code&gt;vsnprintf&lt;/code&gt; , actually). However, if the &lt;code&gt;vsnprintf&lt;/code&gt; is not available, will unfortunately use the unsafe &lt;code&gt;vsprintf&lt;/code&gt; which can overrun the buffer (there is an overrun check, but that may be too late). Consider using &lt;code&gt;sv_vcatpvf&lt;/code&gt; instead, or getting &lt;code&gt;vsnprintf&lt;/code&gt; .</source>
          <target state="translated">C 라이브러리 &lt;code&gt;snprintf&lt;/code&gt; 기능 (사용 가능한 경우 표준 준수) ( 실제로 &lt;code&gt;vsnprintf&lt;/code&gt; 사용 ) 그러나 &lt;code&gt;vsnprintf&lt;/code&gt; 를 사용할 수 없으면 불행히도 안전하지 않은 &lt;code&gt;vsprintf&lt;/code&gt; 를 사용 하여 버퍼를 오버런 할 수 있습니다 (오버런 검사가 있지만 너무 늦을 수 있음). 대신 &lt;code&gt;sv_vcatpvf&lt;/code&gt; 를 사용하거나 &lt;code&gt;vsnprintf&lt;/code&gt; 를 얻는 것을 고려하십시오 .</target>
        </trans-unit>
        <trans-unit id="a0e1b6d35f4716db28bfc47e17c382e52671433d" translate="yes" xml:space="preserve">
          <source>The C library &lt;code&gt;snprintf&lt;/code&gt; functionality, if available and standards-compliant (uses &lt;code&gt;vsnprintf&lt;/code&gt;, actually). However, if the &lt;code&gt;vsnprintf&lt;/code&gt; is not available, will unfortunately use the unsafe &lt;code&gt;vsprintf&lt;/code&gt; which can overrun the buffer (there is an overrun check, but that may be too late). Consider using &lt;code&gt;sv_vcatpvf&lt;/code&gt; instead, or getting &lt;code&gt;vsnprintf&lt;/code&gt;.</source>
          <target state="translated">C 라이브러리 &lt;code&gt;snprintf&lt;/code&gt; 기능 (사용 가능한 경우 및 표준 준수) ( 실제로 &lt;code&gt;vsnprintf&lt;/code&gt; 사용 ). 그러나 &lt;code&gt;vsnprintf&lt;/code&gt; 를 사용할 수없는 경우 불행히도 버퍼를 오버런 할 수 있는 안전하지 않은 &lt;code&gt;vsprintf&lt;/code&gt; 를 사용합니다 (오버런 검사가 있지만 너무 늦을 수 있음). 대신 &lt;code&gt;sv_vcatpvf&lt;/code&gt; 를 사용하거나 &lt;code&gt;vsnprintf&lt;/code&gt; 를 가져 오는 것을 고려하십시오 .</target>
        </trans-unit>
        <trans-unit id="661ddafc70911db04cf396a10417bb22f9c9013f" translate="yes" xml:space="preserve">
          <source>The C library &lt;code&gt;strlcat&lt;/code&gt; if available, or a Perl implementation of it. This operates on C &lt;code&gt;NUL&lt;/code&gt; -terminated strings.</source>
          <target state="translated">사용 가능한 경우 C 라이브러리 &lt;code&gt;strlcat&lt;/code&gt; 또는 Perl 구현. 이것은 C &lt;code&gt;NUL&lt;/code&gt; 종료 문자열 에서 작동합니다 .</target>
        </trans-unit>
        <trans-unit id="15d5b3af47acfb54f6e568de8eff6bc75bdb63f0" translate="yes" xml:space="preserve">
          <source>The C library &lt;code&gt;strlcat&lt;/code&gt; if available, or a Perl implementation of it. This operates on C &lt;code&gt;NUL&lt;/code&gt;-terminated strings.</source>
          <target state="translated">사용 가능한 경우 C 라이브러리 &lt;code&gt;strlcat&lt;/code&gt; 또는 Perl 구현. 이것은 C &lt;code&gt;NUL&lt;/code&gt; 로 끝나는 문자열 에서 작동합니다 .</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
