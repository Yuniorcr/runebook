<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="perl">
    <body>
      <group id="perl">
        <trans-unit id="23fce1430ee4d5e6ff2eda3c170c6c5f5f7f9889" translate="yes" xml:space="preserve">
          <source>The stability of these extensions varies widely. Some have been part of the core language for many years. Others are experimental and may change without warning or be completely removed. Check the documentation on an individual feature to verify its current status.</source>
          <target state="translated">이러한 확장의 안정성은 크게 다릅니다. 일부는 수년간 핵심 언어의 일부였습니다. 다른 실험 중이며 경고없이 변경되거나 완전히 제거 될 수 있습니다. 개별 기능에 대한 설명서를 확인하여 현재 상태를 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="1fd7c6e1c540b52e642a959640d5271791317f81" translate="yes" xml:space="preserve">
          <source>The stack arguments are accessible through the &lt;code&gt;ST(n)&lt;/code&gt; macro, which returns the &lt;code&gt;n&lt;/code&gt; 'th stack argument. Argument 0 is the first argument passed in the Perl subroutine call. These arguments are &lt;code&gt;SV*&lt;/code&gt; , and can be used anywhere an &lt;code&gt;SV*&lt;/code&gt; is used.</source>
          <target state="translated">스택 인수는 &lt;code&gt;ST(n)&lt;/code&gt; 매크로를 통해 액세스 할 수 있으며 &lt;code&gt;n&lt;/code&gt; 번째 스택 인수 를 반환합니다 . 인수 0은 Perl 서브 루틴 호출에서 전달 된 첫 번째 인수입니다. 이 인수는 &lt;code&gt;SV*&lt;/code&gt; 이며 &lt;code&gt;SV*&lt;/code&gt; 가 사용 되는 모든 곳에서 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="607b1af778b28e37b1d81fc8b926b116b2fd196e" translate="yes" xml:space="preserve">
          <source>The stack arguments are accessible through the &lt;code&gt;ST(n)&lt;/code&gt; macro, which returns the &lt;code&gt;n&lt;/code&gt;'th stack argument. Argument 0 is the first argument passed in the Perl subroutine call. These arguments are &lt;code&gt;SV*&lt;/code&gt;, and can be used anywhere an &lt;code&gt;SV*&lt;/code&gt; is used.</source>
          <target state="translated">스택 인수는 &lt;code&gt;n&lt;/code&gt; 번째 스택 인수 를 반환하는 &lt;code&gt;ST(n)&lt;/code&gt; 매크로를 통해 액세스 할 수 있습니다 . 인수 0은 Perl 서브 루틴 호출에서 전달 된 첫 번째 인수입니다. 이러한 인수는 &lt;code&gt;SV*&lt;/code&gt; 이며 &lt;code&gt;SV*&lt;/code&gt; 가 사용 되는 모든 곳에서 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="25a0b1ef2ef458b2d3cc833a6246a76631f78cfb" translate="yes" xml:space="preserve">
          <source>The stack size of currently extant threads cannot be changed, therefore, the following results in the above error:</source>
          <target state="translated">현재 존재하는 스레드의 스택 크기를 변경할 수 없으므로 다음과 같은 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="852fc28bbec79ad0af0406e767c0c9a99d1cbd8b" translate="yes" xml:space="preserve">
          <source>The standard &lt;a href=&quot;IO::Select&quot;&gt;&lt;code&gt;IO::Select&lt;/code&gt;&lt;/a&gt; module provides a user-friendlier interface to &lt;a href=&quot;#select-RBITS%2CWBITS%2CEBITS%2CTIMEOUT&quot;&gt;&lt;code&gt;select&lt;/code&gt;&lt;/a&gt;, mostly because it does all the bit-mask work for you.</source>
          <target state="translated">표준 &lt;a href=&quot;IO::Select&quot;&gt; &lt;code&gt;IO::Select&lt;/code&gt; &lt;/a&gt; 모듈은 주로 모든 비트 마스크 작업을 수행하기 때문에 를 &lt;a href=&quot;#select-RBITS%2CWBITS%2CEBITS%2CTIMEOUT&quot;&gt; &lt;code&gt;select&lt;/code&gt; &lt;/a&gt; 수있는 사용자 친화적 인 인터페이스를 제공 합니다.</target>
        </trans-unit>
        <trans-unit id="38654d44cc2a58273ab5b5792f4d5c5499881e36" translate="yes" xml:space="preserve">
          <source>The standard &lt;code&gt;&lt;a href=&quot;Math::BigInt&quot;&gt;Math::BigInt&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;Math::BigRat&quot;&gt;Math::BigRat&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;Math::BigFloat&quot;&gt;Math::BigFloat&lt;/a&gt;&lt;/code&gt; modules, along with the &lt;code&gt;bignum&lt;/code&gt;, &lt;code&gt;bigint&lt;/code&gt;, and &lt;code&gt;bigrat&lt;/code&gt; pragmas, provide variable-precision arithmetic and overloaded operators, although they're currently pretty slow. At the cost of some space and considerable speed, they avoid the normal pitfalls associated with limited-precision representations.</source>
          <target state="translated">표준 &lt;code&gt;&lt;a href=&quot;Math::BigInt&quot;&gt;Math::BigInt&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;Math::BigRat&quot;&gt;Math::BigRat&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;Math::BigFloat&quot;&gt;Math::BigFloat&lt;/a&gt;&lt;/code&gt; 모듈은 &lt;code&gt;bignum&lt;/code&gt; , &lt;code&gt;bigint&lt;/code&gt; 및 &lt;code&gt;bigrat&lt;/code&gt; pragma 와 함께 현재 매우 느리지 만 가변 정밀도 산술 및 오버로드 연산자를 제공합니다. 약간의 공간과 상당한 속도의 희생으로 제한된 정밀도 표현과 관련된 일반적인 함정을 피할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fc601a28bc12b4ada50e0942554017adba6dc50b" translate="yes" xml:space="preserve">
          <source>The standard &lt;code&gt;&lt;a href=&quot;math/bigint&quot;&gt;Math::BigInt&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;math/bigrat&quot;&gt;Math::BigRat&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;math/bigfloat&quot;&gt;Math::BigFloat&lt;/a&gt;&lt;/code&gt; modules, along with the &lt;code&gt;bignum&lt;/code&gt; , &lt;code&gt;bigint&lt;/code&gt; , and &lt;code&gt;bigrat&lt;/code&gt; pragmas, provide variable-precision arithmetic and overloaded operators, although they're currently pretty slow. At the cost of some space and considerable speed, they avoid the normal pitfalls associated with limited-precision representations.</source>
          <target state="translated">&lt;code&gt;bignum&lt;/code&gt; , &lt;code&gt;bigint&lt;/code&gt; 및 &lt;code&gt;bigrat&lt;/code&gt; 와 함께 표준 &lt;code&gt;&lt;a href=&quot;math/bigint&quot;&gt;Math::BigInt&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;math/bigrat&quot;&gt;Math::BigRat&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;math/bigfloat&quot;&gt;Math::BigFloat&lt;/a&gt;&lt;/code&gt; 모듈 pragma 가변 정밀도 산술 및 오버로드 된 연산자를 제공하지만 현재 속도는 느립니다. 일부 공간과 상당한 속도의 비용으로 제한된 정밀도 표현과 관련된 일반적인 함정을 피할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ebb34ffe368cd7aab86ce86e94cbaf4a640b2d39" translate="yes" xml:space="preserve">
          <source>The standard &lt;code&gt;IO::Select&lt;/code&gt; module provides a user-friendlier interface to &lt;code&gt;&lt;a href=&quot;functions/select&quot;&gt;select&lt;/a&gt;&lt;/code&gt;, mostly because it does all the bit-mask work for you.</source>
          <target state="translated">표준 &lt;code&gt;IO::Select&lt;/code&gt; 모듈은 대부분의 비트 마스크 작업을 수행하기 때문에 &lt;code&gt;&lt;a href=&quot;functions/select&quot;&gt;select&lt;/a&gt;&lt;/code&gt; 하기 쉬운 사용자 인터페이스를 제공 합니다.</target>
        </trans-unit>
        <trans-unit id="16315bade45df278e7f616f03ff95a3f0a8f22eb" translate="yes" xml:space="preserve">
          <source>The standard &lt;code&gt;IO::Select&lt;/code&gt; module provides a user-friendlier interface to &lt;code&gt;&lt;a href=&quot;select&quot;&gt;select&lt;/a&gt;&lt;/code&gt;, mostly because it does all the bit-mask work for you.</source>
          <target state="translated">표준 &lt;code&gt;IO::Select&lt;/code&gt; 모듈은 대부분의 비트 마스크 작업을 수행하기 때문에 &lt;code&gt;&lt;a href=&quot;select&quot;&gt;select&lt;/a&gt;&lt;/code&gt; 하기 쉬운 사용자 인터페이스를 제공 합니다.</target>
        </trans-unit>
        <trans-unit id="7c56d1d9eaa2950435f175be867488228983813f" translate="yes" xml:space="preserve">
          <source>The standard Perl 5 MRO would be (D, B, A, C). The result being that &lt;b&gt;A&lt;/b&gt; appears before &lt;b&gt;C&lt;/b&gt;, even though &lt;b&gt;C&lt;/b&gt; is the subclass of &lt;b&gt;A&lt;/b&gt;. The C3 MRO algorithm however, produces the following order: (D, B, C, A), which does not have this issue.</source>
          <target state="translated">표준 Perl 5 MRO는 (D, B, A, C)입니다. 그 결과 인 &lt;b&gt;A가&lt;/b&gt; 전에 나타나는 &lt;b&gt;C는&lt;/b&gt; , 비록 &lt;b&gt;C는&lt;/b&gt; 의 서브 클래스 . 그러나 C3 MRO 알고리즘은이 문제가없는 (D, B, C, A) 순서를 생성합니다.&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="65db7a2a2e4a32185cf7e73efd313530e97c3f64" translate="yes" xml:space="preserve">
          <source>The standard Pod::Parser method parse_from_filehandle() takes up to two arguments, the first being the file handle to read POD from and the second being the file handle to write the formatted output to. The first defaults to STDIN if not given, and the second defaults to STDOUT. The method parse_from_file() is almost identical, except that its two arguments are the input and output disk files instead. See &lt;a href=&quot;parser&quot;&gt;Pod::Parser&lt;/a&gt; for the specific details.</source>
          <target state="translated">표준 Pod :: Parser 메소드 parse_from_filehandle ()은 최대 두 개의 인수를 사용합니다. 첫 번째는 POD를 읽는 파일 핸들이고 두 번째는 형식화 된 출력을 쓸 파일 핸들입니다. 지정하지 않은 경우 첫 번째는 STDIN이고, 두 번째는 STDOUT입니다. parse_from_file () 메소드는 두 개의 인수가 대신 입력 및 출력 디스크 파일이라는 점을 제외하면 거의 동일합니다. 자세한 내용은 &lt;a href=&quot;parser&quot;&gt;Pod :: Parser&lt;/a&gt; 를 참조 하십시오.</target>
        </trans-unit>
        <trans-unit id="d459c791ef0819fa116e56f83671629a780f70ae" translate="yes" xml:space="preserve">
          <source>The standard Pod::Simple method parse_file() takes one argument naming the POD file to read from. By default, the output is sent to &lt;code&gt;STDOUT&lt;/code&gt; , but this can be changed with the output_fh() method.</source>
          <target state="translated">표준 Pod :: Simple 메소드 parse_file ()은 읽을 POD 파일을 명명하는 하나의 인수를 사용합니다. 기본적으로 출력은 &lt;code&gt;STDOUT&lt;/code&gt; 으로 전송됩니다. 되지만 output_fh () 메소드로 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3e6fd6624c64417efc3c147b58226ae1b1c796d2" translate="yes" xml:space="preserve">
          <source>The standard Pod::Simple method parse_file() takes one argument naming the POD file to read from. By default, the output is sent to &lt;code&gt;STDOUT&lt;/code&gt;, but this can be changed with the output_fh() method.</source>
          <target state="translated">표준 Pod :: Simple 메소드 parse_file ()은 읽을 POD 파일의 이름을 지정하는 하나의 인수를 사용합니다. 기본적으로 출력은 &lt;code&gt;STDOUT&lt;/code&gt; 로 보내지 지만 output_fh () 메서드로 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b669405b1331755a6517c831be989ebdf0920199" translate="yes" xml:space="preserve">
          <source>The standard Pod::Simple method parse_from_file() takes up to two arguments, the first being the input file to read POD from and the second being the file to write the formatted output to.</source>
          <target state="translated">표준 Pod :: Simple 메소드 parse_from_file ()은 최대 두 개의 인수를 사용합니다. 첫 번째는 POD를 읽을 입력 파일이고 두 번째는 형식화 된 출력을 쓸 파일입니다.</target>
        </trans-unit>
        <trans-unit id="c21871c0e5568494a7fbe46008b5f9b899656bd2" translate="yes" xml:space="preserve">
          <source>The standard Tie::RefHash module provides a convenient workaround to this.</source>
          <target state="translated">표준 Tie :: RefHash 모듈은 이에 대한 편리한 해결 방법을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="baf8b1f6a3bcf32c285c5388e646857a3e93b793" translate="yes" xml:space="preserve">
          <source>The standard Unicode properties listed below are documented in &lt;a href=&quot;http://www.unicode.org/reports/tr44/&quot;&gt;http://www.unicode.org/reports/tr44/&lt;/a&gt;; Perl_Decimal_Digit is documented in &lt;a href=&quot;Unicode::UCD#prop_invmap%28%29&quot;&gt;&quot;prop_invmap()&quot; in Unicode::UCD&lt;/a&gt;. The other Perl extensions are in &lt;a href=&quot;perlunicode#Other-Properties&quot;&gt;&quot;Other Properties&quot; in perlunicode&lt;/a&gt;;</source>
          <target state="translated">아래 나열된 표준 유니 코드 속성은 &lt;a href=&quot;http://www.unicode.org/reports/tr44/&quot;&gt;http://www.unicode.org/reports/tr44/에&lt;/a&gt; 문서화되어 있습니다 . Perl_Decimal_Digit은 &lt;a href=&quot;Unicode::UCD#prop_invmap%28%29&quot;&gt;Unicode :: UCD의 &quot;prop_invmap ()&quot;에&lt;/a&gt; 문서화되어 있습니다. 다른 Perl 확장은 &lt;a href=&quot;perlunicode#Other-Properties&quot;&gt;perlunicode의 &quot;Other Properties&quot;에 있습니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="66cc6332c8e3c57e5b8e7b4ce541f13735f1aa06" translate="yes" xml:space="preserve">
          <source>The standard Unicode properties listed below are documented in &lt;a href=&quot;http://www.unicode.org/reports/tr44/&quot;&gt;http://www.unicode.org/reports/tr44/&lt;/a&gt;; Perl_Decimal_Digit is documented in &lt;a href=&quot;unicode/ucd#prop_invmap()&quot;&gt;prop_invmap() in Unicode::UCD&lt;/a&gt;. The other Perl extensions are in &lt;a href=&quot;perlunicode#Other-Properties&quot;&gt;Other Properties in perlunicode&lt;/a&gt;;</source>
          <target state="translated">아래에 나열된 표준 유니 코드 속성은 &lt;a href=&quot;http://www.unicode.org/reports/tr44/&quot;&gt;http://www.unicode.org/reports/tr44/에&lt;/a&gt; 문서화되어 있습니다 . Perl_Decimal_Digit는 &lt;a href=&quot;unicode/ucd#prop_invmap()&quot;&gt;prop_invmap ()에 Unicode :: UCD&lt;/a&gt; 로 문서화되어 있습니다. 다른 Perl 확장자는 &lt;a href=&quot;perlunicode#Other-Properties&quot;&gt;perlunicode의 기타 특성에 있습니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="fdea898e7a6fa5187cc16e508d0249ddcaeda57c" translate="yes" xml:space="preserve">
          <source>The standard release of Perl (the one maintained by the Perl development team) is distributed only in source code form. You can find the latest releases at &lt;a href=&quot;http://www.cpan.org/src/&quot;&gt;http://www.cpan.org/src/&lt;/a&gt;.</source>
          <target state="translated">Perl의 표준 릴리스 (Perl 개발 팀이 유지 보수하는 버전)는 소스 코드 형식으로 만 배포됩니다. 최신 릴리스는 &lt;a href=&quot;http://www.cpan.org/src/&quot;&gt;http://www.cpan.org/src/&lt;/a&gt; 에서 찾을 수 있습니다 . .</target>
        </trans-unit>
        <trans-unit id="026f8e314f5a0595f026a7356cc10536cfc51440" translate="yes" xml:space="preserve">
          <source>The standard sections of a manual page are:</source>
          <target state="translated">매뉴얼 페이지의 표준 섹션은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="da6ced5233b9d24371e1284e5b4cf92ab897f075" translate="yes" xml:space="preserve">
          <source>The standard tools that deal with module distribution (PAUSE, CPAN, etc.) form an identifier for each distribution by joining the 'name' and 'version' attributes with a dash (&lt;code&gt;-&lt;/code&gt;) character. Tools who are prepared to deal with distributions that have no version numbers generally omit the dash as well.</source>
          <target state="translated">모듈 배포를 처리하는 표준 도구 (PAUSE, CPAN 등)는 'name'및 'version'속성을 대시 ( &lt;code&gt;-&lt;/code&gt; ) 문자 로 결합하여 각 배포에 대한 식별자를 형성합니다 . 버전 번호가없는 배포판을 처리 할 준비가 된 도구는 일반적으로 대시도 생략합니다.</target>
        </trans-unit>
        <trans-unit id="ebe88b6db5cc5c12b5e1ae182a8ede9bae134d07" translate="yes" xml:space="preserve">
          <source>The standard typemap does not contain PerlIO * before perl 5.7, but it has the three stream variants. Using a PerlIO * directly is not backwards compatible unless you provide your own typemap.</source>
          <target state="translated">표준 타입 맵에는 perl 5.7 이전의 PerlIO *가 포함되어 있지 않지만 세 가지 스트림 변형이 있습니다. 고유 한 유형 맵을 제공하지 않으면 PerlIO *를 직접 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="a4d40d48d96b939643d17277ad94dfc253906873" translate="yes" xml:space="preserve">
          <source>The standard typemap offers three variants of PerlIO *: &lt;code&gt;InputStream&lt;/code&gt; (T_IN), &lt;code&gt;InOutStream&lt;/code&gt; (T_INOUT) and &lt;code&gt;OutputStream&lt;/code&gt; (T_OUT). A bare &lt;code&gt;PerlIO *&lt;/code&gt; is considered a T_INOUT. If it matters in your code (see below for why it might) #define or typedef one of the specific names and use that as the argument or result type in your XS file.</source>
          <target state="translated">표준 유형 맵은 PerlIO *의 세 가지 변형 인 &lt;code&gt;InputStream&lt;/code&gt; (T_IN), &lt;code&gt;InOutStream&lt;/code&gt; (T_INOUT) 및 &lt;code&gt;OutputStream&lt;/code&gt; (T_OUT)을 제공합니다. 베어 &lt;code&gt;PerlIO *&lt;/code&gt; 는 T_INOUT으로 간주됩니다. 코드에서 중요한 경우 (아래의 이유를 참조하십시오) 특정 이름 중 하나를 #define 또는 typedef하고 XS 파일에서 인수 또는 결과 유형으로 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="3718e2c8d6baf1715fb8924869dc7062354846f5" translate="yes" xml:space="preserve">
          <source>The standard/default list of directories in which dl_findfile() will search for libraries etc. Directories are searched in order: $dl_library_path[0], [1], ... etc</source>
          <target state="translated">dl_findfile ()이 라이브러리 등을 검색 할 디렉토리의 표준 / 기본 목록입니다. $ dl_library_path [0], [1], ... 등의 디렉토리가 순서대로 검색됩니다.</target>
        </trans-unit>
        <trans-unit id="81b82092af810ac11d0e71f19aeda4997801a33d" translate="yes" xml:space="preserve">
          <source>The stash associated with a typed lexical. This returns the %Foo:: hash for &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; Foo $bar&lt;/code&gt; .</source>
          <target state="translated">유형화 된 어휘와 연관된 숨김입니다. &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; Foo $bar&lt;/code&gt; 대한 % Foo :: 해시를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="b3fb6f3b4dcfdcba93815cd0cdb0c770846f5f5f" translate="yes" xml:space="preserve">
          <source>The stash associated with a typed lexical. This returns the &lt;code&gt;%Foo::&lt;/code&gt; hash for &lt;code&gt;my Foo $bar&lt;/code&gt;.</source>
          <target state="translated">형식화 된 어휘와 관련된 숨김입니다. 이것은 &lt;code&gt;my Foo $bar&lt;/code&gt; 대한 &lt;code&gt;%Foo::&lt;/code&gt; 해시를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="d1de13e351b83e422c637b81ca7943274ca516a1" translate="yes" xml:space="preserve">
          <source>The stash for the package code will be compiled into.</source>
          <target state="translated">패키지 코드의 숨김이 컴파일됩니다.</target>
        </trans-unit>
        <trans-unit id="cc4f30ab95381b1c15dfe4d97fa8f832c168bf1d" translate="yes" xml:space="preserve">
          <source>The stash in which this &quot;our&quot; variable was declared.</source>
          <target state="translated">이 &quot;우리의&quot;변수가 선언 된 숨김</target>
        </trans-unit>
        <trans-unit id="869b087a95d93860c966339061a3c7eb5e7a6410" translate="yes" xml:space="preserve">
          <source>The stat preceding %s wasn't an lstat</source>
          <target state="translated">% s 앞의 통계는 lstat가 아닙니다.</target>
        </trans-unit>
        <trans-unit id="136e96ab03183ea4c3a7028af3545e7d9d5bc253" translate="yes" xml:space="preserve">
          <source>The stat() mode bits are probably right for most of the files and directories found on your system, because few people want to use the additional features offered by access(). But you may encounter surprises if your program runs on a system that uses ACLs, since the stat() information won't reflect the actual permissions.</source>
          <target state="translated">stat () 모드 비트는 아마도 시스템에있는 대부분의 파일과 디렉토리에 적합 할 것입니다. access ()가 제공하는 추가 기능을 사용하려는 사람은 거의 없기 때문입니다. 그러나 stat () 정보가 실제 권한을 반영하지 않기 때문에 프로그램이 ACL을 사용하는 시스템에서 실행되는 경우 놀라게 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e8e71255cf8fb3fde9520415463a7e71c11cd3c9" translate="yes" xml:space="preserve">
          <source>The statement &lt;code&gt;&lt;a href=&quot;functions/seek&quot;&gt;seek&lt;/a&gt;($gw_fh, 0, 1)&lt;/code&gt; doesn't change the current position, but it does clear the end-of-file condition on the handle, so that the next &lt;code&gt;&amp;lt;$gw_fh&amp;gt;&lt;/code&gt; makes Perl try again to read something.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/seek&quot;&gt;seek&lt;/a&gt;($gw_fh, 0, 1)&lt;/code&gt; 명령문 은 현재 위치를 변경하지 않지만 핸들의 파일 끝 조건을 지우므로 다음 &lt;code&gt;&amp;lt;$gw_fh&amp;gt;&lt;/code&gt; 는 Perl이 다시 무언가를 읽으려고합니다.</target>
        </trans-unit>
        <trans-unit id="29c5f769bcdc76ec76db73fb881f9e3de17be2e0" translate="yes" xml:space="preserve">
          <source>The statement &lt;code&gt;seek($gw_fh, 0, 1)&lt;/code&gt; doesn't change the current position, but it does clear the end-of-file condition on the handle, so that the next &lt;code&gt;&amp;lt;$gw_fh&amp;gt;&lt;/code&gt; makes Perl try again to read something.</source>
          <target state="translated">&lt;code&gt;seek($gw_fh, 0, 1)&lt;/code&gt; 문 은 현재 위치를 변경하지 않지만 핸들의 파일 끝 조건을 지우므로 다음 &lt;code&gt;&amp;lt;$gw_fh&amp;gt;&lt;/code&gt; 가 Perl이 무언가를 다시 읽으려고 시도합니다.</target>
        </trans-unit>
        <trans-unit id="707171be35bdd3b79efa241046dd3631507040a6" translate="yes" xml:space="preserve">
          <source>The status 2 indicates that at least one of the specified files does not contain</source>
          <target state="translated">상태 2는 지정된 파일 중 하나 이상에 포함되지 않았 음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="9251e77389b34b5c344d864eb779d11058b888c5" translate="yes" xml:space="preserve">
          <source>The status code returned from &lt;code&gt;inflate&lt;/code&gt; will only trigger termination of the main processing loop if it isn't &lt;code&gt;Z_OK&lt;/code&gt; . When &lt;code&gt;LimitOutput&lt;/code&gt; has not been used the &lt;code&gt;Z_OK&lt;/code&gt; status means that the end of the compressed data stream has been reached or there has been an error in uncompression.</source>
          <target state="translated">&lt;code&gt;inflate&lt;/code&gt; 에서 반환 된 상태 코드 는 &lt;code&gt;Z_OK&lt;/code&gt; 가 아닌 경우 주 처리 루프의 종료 만 트리거합니다 . 경우 &lt;code&gt;LimitOutput&lt;/code&gt; 을 사용한되지 &lt;code&gt;Z_OK&lt;/code&gt; 의 압축 데이터 스트림의 끝에 도달하거나 비 압축에서 에러가되었다는 상태 수단.</target>
        </trans-unit>
        <trans-unit id="779e93e5e5c79de152e0d904d8c2cb9d0f5d9a7f" translate="yes" xml:space="preserve">
          <source>The status code returned from &lt;code&gt;inflate&lt;/code&gt; will only trigger termination of the main processing loop if it isn't &lt;code&gt;Z_OK&lt;/code&gt;. When &lt;code&gt;LimitOutput&lt;/code&gt; has not been used the &lt;code&gt;Z_OK&lt;/code&gt; status means that the end of the compressed data stream has been reached or there has been an error in uncompression.</source>
          <target state="translated">&lt;code&gt;inflate&lt;/code&gt; 에서 반환 된 상태 코드 는 &lt;code&gt;Z_OK&lt;/code&gt; 가 아닌 경우에만 기본 처리 루프의 종료를 트리거합니다 . 경우 &lt;code&gt;LimitOutput&lt;/code&gt; 을 사용한되지 &lt;code&gt;Z_OK&lt;/code&gt; 의 압축 데이터 스트림의 끝에 도달하거나 비 압축에서 에러가되었다는 상태 수단.</target>
        </trans-unit>
        <trans-unit id="2298239a448f47305c5dbab535dd02c58c7526e3" translate="yes" xml:space="preserve">
          <source>The status of the hushed flag also affects output of VMS error messages from compilation errors. Again, you still get the Perl error message (and the code in $STATUS)</source>
          <target state="translated">hushed 플래그의 상태는 컴파일 오류의 VMS 오류 메시지 출력에도 영향을줍니다. 다시, 여전히 Perl 오류 메시지와 $ STATUS 코드가 나타납니다.</target>
        </trans-unit>
        <trans-unit id="4cb40ccf1b5efc1b553ba9f11bd2e4b83ffc7264" translate="yes" xml:space="preserve">
          <source>The status returned by the last pipe close, backtick (&lt;code&gt;``&lt;/code&gt; ) command, successful call to &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait()&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/waitpid&quot;&gt;waitpid()&lt;/a&gt;&lt;/code&gt;, or from the &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system()&lt;/a&gt;&lt;/code&gt; operator. This is just the 16-bit status word returned by the traditional Unix &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait()&lt;/a&gt;&lt;/code&gt; system call (or else is made up to look like it). Thus, the exit value of the subprocess is really (&lt;code&gt;$?&amp;gt;&amp;gt;
8&lt;/code&gt; ), and &lt;code&gt;$? &amp;amp; 127&lt;/code&gt; gives which signal, if any, the process died from, and &lt;code&gt;$? &amp;amp; 128&lt;/code&gt; reports whether there was a core dump.</source>
          <target state="translated">마지막 파이프 닫기, 백틱 ( &lt;code&gt;``&lt;/code&gt; ) 명령, &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait()&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;functions/waitpid&quot;&gt;waitpid()&lt;/a&gt;&lt;/code&gt; 호출 성공 또는 &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system()&lt;/a&gt;&lt;/code&gt; 연산자 에서 리턴 한 상태 입니다. 이것은 전통적인 Unix &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait()&lt;/a&gt;&lt;/code&gt; 시스템 호출에 의해 반환 된 16 비트 상태 단어 일뿐입니다 (또는 이와 같이 보이도록 구성되어 있습니다). 따라서 서브 프로세스의 종료 값은 실제로 ( &lt;code&gt;$?&amp;gt;&amp;gt; 8&lt;/code&gt; ) 및 &lt;code&gt;$? &amp;amp; 127&lt;/code&gt; 은 프로세스가 어느 신호에서 죽었는지, 그리고 &lt;code&gt;$? &amp;amp; 128&lt;/code&gt; 은 코어 덤프가 있는지보고합니다.</target>
        </trans-unit>
        <trans-unit id="9f58cb3cab9b9d58145034f89f71fdaeeb21297a" translate="yes" xml:space="preserve">
          <source>The status returned by the last pipe close, backtick (&lt;code&gt;``&lt;/code&gt;) command, successful call to &lt;code&gt;wait()&lt;/code&gt; or &lt;code&gt;waitpid()&lt;/code&gt;, or from the &lt;code&gt;system()&lt;/code&gt; operator. This is just the 16-bit status word returned by the traditional Unix &lt;code&gt;wait()&lt;/code&gt; system call (or else is made up to look like it). Thus, the exit value of the subprocess is really (&lt;code&gt;$? &amp;gt;&amp;gt; 8&lt;/code&gt;), and &lt;code&gt;$? &amp;amp; 127&lt;/code&gt; gives which signal, if any, the process died from, and &lt;code&gt;$? &amp;amp; 128&lt;/code&gt; reports whether there was a core dump.</source>
          <target state="translated">마지막 파이프 닫기, 백틱 ( &lt;code&gt;``&lt;/code&gt; ) 명령, &lt;code&gt;wait()&lt;/code&gt; 또는 &lt;code&gt;waitpid()&lt;/code&gt; 성공적인 호출 또는 &lt;code&gt;system()&lt;/code&gt; 연산자 에서 반환 된 상태 입니다. 이것은 전통적인 Unix &lt;code&gt;wait()&lt;/code&gt; 시스템 호출에 의해 반환 된 16 비트 상태 단어 일뿐 입니다. 따라서 하위 프로세스의 종료 값은 실제로 ( &lt;code&gt;$? &amp;gt;&amp;gt; 8&lt;/code&gt; )이고 &lt;code&gt;$? &amp;amp; 127&lt;/code&gt; 은 어떤 신호 (있는 경우)에서 프로세스가 사망했는지, 그리고 &lt;code&gt;$? &amp;amp; 128&lt;/code&gt; 은 코어 덤프가 있는지 여부를보고합니다.</target>
        </trans-unit>
        <trans-unit id="6450e7782a48b71f2dca0230b4493dd10ff37ce5" translate="yes" xml:space="preserve">
          <source>The status value that is returned by the user's &lt;code&gt;filter&lt;/code&gt; method or anonymous sub and the &lt;code&gt;filter_read&lt;/code&gt; and &lt;code&gt;read_exact&lt;/code&gt; functions take the same set of values, namely:</source>
          <target state="translated">사용자의 &lt;code&gt;filter&lt;/code&gt; 메소드 또는 익명 서브와 &lt;code&gt;filter_read&lt;/code&gt; 및 &lt;code&gt;read_exact&lt;/code&gt; 함수에 의해 리턴되는 상태 값 은 동일한 값 세트를 취합니다.</target>
        </trans-unit>
        <trans-unit id="2660ee0526b1b40a8d851a0826ec3b948b6dbdee" translate="yes" xml:space="preserve">
          <source>The stdio(3C) manpage notes that for LP32 applications, only 255 files may be opened using fopen(), and only file descriptors 0 through 255 can be used in a stream. Since perl calls open() and then fdopen(3C) with the resulting file descriptor, perl is limited to 255 simultaneous open files, even if sysopen() is used. If this proves to be an insurmountable problem, you can compile perl as a LP64 application, see &lt;a href=&quot;#Building-an-LP64-perl&quot;&gt;&quot;Building an LP64 perl&quot;&lt;/a&gt; for details. Note also that the default resource limit for open file descriptors on Solaris is 255, so you will have to modify your ulimit or rctl (Solaris 9 onwards) appropriately.</source>
          <target state="translated">stdio (3C) 맨 페이지는 LP32 응용 프로그램의 경우 fopen ()을 사용하여 255 개의 파일 만 열 수 있으며 스트림에서 0에서 255까지의 파일 설명 자만 사용할 수 있다고 설명합니다. perl은 결과 파일 설명자와 함께 open ()을 호출 한 다음 fdopen (3C)을 호출하므로 sysopen ()을 사용하더라도 perl은 255 개의 동시 열린 파일로 제한됩니다. 이것이 극복 할 수없는 문제로 판명되면 perl을 LP64 응용 프로그램으로 컴파일 할 수 있습니다 . 자세한 내용 은 &lt;a href=&quot;#Building-an-LP64-perl&quot;&gt;&quot;LP64 perl 빌드&quot;&lt;/a&gt; 를 참조하십시오. Solaris에서 열린 파일 설명자에 대한 기본 자원 제한은 255이므로 ulimit 또는 rctl (Solaris 9 이상)을 적절하게 수정해야합니다.</target>
        </trans-unit>
        <trans-unit id="3b8220a76d45ce112350b70ee4dbd73fc8b8bc74" translate="yes" xml:space="preserve">
          <source>The stdio(3C) manpage notes that for LP32 applications, only 255 files may be opened using fopen(), and only file descriptors 0 through 255 can be used in a stream. Since perl calls open() and then fdopen(3C) with the resulting file descriptor, perl is limited to 255 simultaneous open files, even if sysopen() is used. If this proves to be an insurmountable problem, you can compile perl as a LP64 application, see &lt;a href=&quot;#Building-an-LP64-perl&quot;&gt;Building an LP64 perl&lt;/a&gt; for details. Note also that the default resource limit for open file descriptors on Solaris is 255, so you will have to modify your ulimit or rctl (Solaris 9 onwards) appropriately.</source>
          <target state="translated">stdio (3C) 맨 페이지에서는 LP32 응용 프로그램의 경우 fopen ()을 사용하여 255 개의 파일 만 열 수 있으며 스트림에는 0-255의 파일 설명 자만 사용할 수 있습니다. perl은 결과 파일 설명자와 함께 open ()을 호출 한 다음 fdopen (3C)을 호출하므로 sysopen ()을 사용하더라도 perl은 255 개의 동시 열린 파일로 제한됩니다. 이것이 극복 할 수없는 문제인 경우, perl을 LP64 응용 프로그램으로 컴파일 할 수 있습니다 . 자세한 내용 &lt;a href=&quot;#Building-an-LP64-perl&quot;&gt;은 LP64 perl 빌드&lt;/a&gt; 를 참조하십시오. Solaris에서 열린 파일 디스크립터의 기본 자원 제한은 255이므로 ulimit 또는 rctl (Solaris 9 이상)을 적절하게 수정해야합니다.</target>
        </trans-unit>
        <trans-unit id="5a65b444e930fbaa9c0e870b3e72484e3ba2cfa8" translate="yes" xml:space="preserve">
          <source>The steps above are in a very specific order, designed to be the reverse order of when the context was pushed. The first thing to do is to copy and/or protect any return arguments and free any temps in the current scope. Scope exits like an rvalue sub normally return a mortal copy of their return args (as opposed to lvalue subs). It is important to make this copy before the save stack is popped or variables are restored, or bad things like the following can happen:</source>
          <target state="translated">위의 단계는 컨텍스트가 푸시 된 때의 역순으로 설계된 매우 구체적인 순서입니다. 가장 먼저 할 일은 반환 인수를 복사 및 / 또는 보호하고 현재 범위에서 임시를 해제하는 것입니다. rvalue 하위와 같은 범위 종료는 일반적으로 반환 인수의 필사 사본을 반환합니다 (lvalue 하위와 반대). 저장 스택이 팝되거나 변수가 복원되기 전에이 복사본을 만드는 것이 중요합니다. 그렇지 않으면 다음과 같은 나쁜 일이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="00bff96ca21371570b04e3ba98b01671b01481ae" translate="yes" xml:space="preserve">
          <source>The store functions will &lt;code&gt;croak&lt;/code&gt; if they run into such references unless you set &lt;code&gt;$Storable::forgive_me&lt;/code&gt; to some &lt;code&gt;TRUE&lt;/code&gt; value. In that case, the fatal message is converted to a warning and some meaningless string is stored instead.</source>
          <target state="translated">상점 기능을합니다 &lt;code&gt;croak&lt;/code&gt; 그들이 당신을 설정하지 않는 한 이러한 참조로 실행하면 &lt;code&gt;$Storable::forgive_me&lt;/code&gt; 일부 &lt;code&gt;TRUE&lt;/code&gt; 값. 이 경우 치명적인 메시지가 경고로 변환되고 의미없는 문자열이 대신 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="af1c1657bd0ce03b1ba6ae64acc2840b7f31bd40" translate="yes" xml:space="preserve">
          <source>The strend and patend pointers should point to the byte following the last character of each string.</source>
          <target state="translated">strend 및 patend 포인터는 각 문자열의 마지막 문자 다음에 오는 바이트를 가리켜 야합니다.</target>
        </trans-unit>
        <trans-unit id="ccae9ac2ba65b56262ababed8ca5ba389eb0ed32" translate="yes" xml:space="preserve">
          <source>The string &lt;code&gt;&quot;NDBM_File&quot;&lt;/code&gt; . (Ths tells Perl to use the &lt;code&gt;NDBM_File&lt;/code&gt; package to perform the functions of the hash.)</source>
          <target state="translated">문자열 &lt;code&gt;&quot;NDBM_File&quot;&lt;/code&gt; 입니다. &lt;code&gt;NDBM_File&lt;/code&gt; Perl에게 NDBM_File 패키지를 사용하여 해시의 기능을 수행하도록 지시 합니다.</target>
        </trans-unit>
        <trans-unit id="0acc3252158ec09fb79d744584bd9ec310ab3fc7" translate="yes" xml:space="preserve">
          <source>The string &lt;code&gt;&quot;NDBM_File&quot;&lt;/code&gt;. (Ths tells Perl to use the &lt;code&gt;NDBM_File&lt;/code&gt; package to perform the functions of the hash.)</source>
          <target state="translated">문자열 &lt;code&gt;&quot;NDBM_File&quot;&lt;/code&gt; . (이는 Perl에게 &lt;code&gt;NDBM_File&lt;/code&gt; 패키지를 사용하여 해시의 기능을 수행하도록 지시 합니다.)</target>
        </trans-unit>
        <trans-unit id="7bebcac85b77891a0ebb57e146c479aea7f7cca3" translate="yes" xml:space="preserve">
          <source>The string &lt;code&gt;&quot;ODBM_File&quot;&lt;/code&gt;. (Ths tells Perl to use the &lt;code&gt;ODBM_File&lt;/code&gt; package to perform the functions of the hash.)</source>
          <target state="translated">문자열 &lt;code&gt;&quot;ODBM_File&quot;&lt;/code&gt; . (이는 Perl에게 &lt;code&gt;ODBM_File&lt;/code&gt; 패키지를 사용하여 해시의 기능을 수행하도록 지시 합니다.)</target>
        </trans-unit>
        <trans-unit id="c5c77c76e1fc3205395047a2345f8ef41459d3bb" translate="yes" xml:space="preserve">
          <source>The string &lt;code&gt;$vec&lt;/code&gt; only takes up as many bits as it needs. For instance, if you had 16 entries in &lt;code&gt;@ints&lt;/code&gt; , &lt;code&gt;$vec&lt;/code&gt; only needs two bytes to store them (not counting the scalar variable overhead).</source>
          <target state="translated">문자열 &lt;code&gt;$vec&lt;/code&gt; 는 필요한만큼만 비트를 차지합니다. 예를 들어 &lt;code&gt;@ints&lt;/code&gt; 에 16 개의 항목이있는 경우 &lt;code&gt;$vec&lt;/code&gt; 에는 스칼라 변수 오버 헤드를 계산하지 않고 2 바이트 만 저장하면됩니다.</target>
        </trans-unit>
        <trans-unit id="dc49e0b476d0350280c159b76d14abbf494b1cf7" translate="yes" xml:space="preserve">
          <source>The string &lt;code&gt;$vec&lt;/code&gt; only takes up as many bits as it needs. For instance, if you had 16 entries in &lt;code&gt;@ints&lt;/code&gt;, &lt;code&gt;$vec&lt;/code&gt; only needs two bytes to store them (not counting the scalar variable overhead).</source>
          <target state="translated">&lt;code&gt;$vec&lt;/code&gt; 문자열 은 필요한만큼의 비트 만 차지합니다. 예를 들어, &lt;code&gt;@ints&lt;/code&gt; 에 16 개의 항목이있는 경우 &lt;code&gt;$vec&lt;/code&gt; 는이를 저장하는 데 2 ​​바이트 만 필요합니다 (스칼라 변수 오버 헤드는 계산하지 않음).</target>
        </trans-unit>
        <trans-unit id="ace981c506425cb8cbcfe9d653a843e517d5bdac" translate="yes" xml:space="preserve">
          <source>The string &lt;code&gt;br&amp;ucirc;l&amp;eacute;e&lt;/code&gt; has six graphemes but up to eight codepoints. This counts by grapheme, not by codepoint:</source>
          <target state="translated">문자열 &lt;code&gt;br&amp;ucirc;l&amp;eacute;e&lt;/code&gt; 에는 6 개의 그래 핀 이 있지만 최대 8 개의 코드 포인트가 있습니다. 이것은 코드 포인트가 아닌 grapheme으로 계산됩니다.</target>
        </trans-unit>
        <trans-unit id="c8568d09543e0ac94aa7c4682834b259e167d475" translate="yes" xml:space="preserve">
          <source>The string bitwise operators, &lt;code&gt;&amp;amp;&lt;/code&gt;, &lt;code&gt;|&lt;/code&gt;, &lt;code&gt;^&lt;/code&gt;, and &lt;code&gt;~&lt;/code&gt;, treat their operands as strings of bytes. As such, values above 0xFF are nonsensical. Some instances of these have been deprecated since Perl 5.24, and were made fatal in 5.28, but it turns out that in cases where the wide characters did not affect the end result, no deprecation notice was raised, and so remain legal. Now, all occurrences either are fatal or raise a deprecation warning, so that the remaining legal occurrences became fatal in 5.32.</source>
          <target state="translated">문자열 비트 연산자 &lt;code&gt;&amp;amp;&lt;/code&gt; , &lt;code&gt;|&lt;/code&gt; , &lt;code&gt;^&lt;/code&gt; 및 &lt;code&gt;~&lt;/code&gt; 는 피연산자를 바이트 문자열로 취급합니다. 따라서 0xFF 이상의 값은 의미가 없습니다. 이들의 일부 인스턴스는 Perl 5.24 이후로 사용되지 않으며 5.28에서 치명적 이었지만 와이드 문자가 최종 결과에 영향을 미치지 않는 경우 사용 중단 알림이 제기되지 않았으므로 법적으로 유지됩니다. 이제 모든 발생이 치명적이거나 지원 중단 경고를 발생 시키므로 나머지 합법적 발생은 5.32에서 치명적이되었습니다.</target>
        </trans-unit>
        <trans-unit id="5487cb3c1b5dd51f93004e758fb4f77bc307a840" translate="yes" xml:space="preserve">
          <source>The string bitwise operators, &lt;code&gt;&amp;amp;&lt;/code&gt;, &lt;code&gt;|&lt;/code&gt;, &lt;code&gt;^&lt;/code&gt;, and &lt;code&gt;~&lt;/code&gt;, treat their operands as strings of bytes. As such, values above 0xFF are nonsensical. Using such code points with these operators was deprecated in Perl 5.24, and is fatal as of Perl 5.28.</source>
          <target state="translated">문자열 비트 연산자 &lt;code&gt;&amp;amp;&lt;/code&gt; , &lt;code&gt;|&lt;/code&gt; , &lt;code&gt;^&lt;/code&gt; 및 &lt;code&gt;~&lt;/code&gt; 는 피연산자를 바이트 문자열로 취급합니다. 따라서 0xFF 이상의 값은 의미가 없습니다. 이러한 연산자와 함께 이러한 코드 포인트를 사용하는 것은 Perl 5.24에서 더 이상 사용되지 않으며 Perl 5.28부터 치명적입니다.</target>
        </trans-unit>
        <trans-unit id="e842cb2ff66d209b19263b7c79265ed68c6571d7" translate="yes" xml:space="preserve">
          <source>The string following whatever was matched by the last successful pattern match (not counting any matches hidden within a BLOCK or &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval()&lt;/a&gt;&lt;/code&gt; enclosed by the current BLOCK). Example:</source>
          <target state="translated">마지막으로 성공한 패턴 일치와 일치하는 항목 뒤에 오는 문자열 ( 현재 BLOCK으로 묶인 BLOCK 또는 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval()&lt;/a&gt;&lt;/code&gt; 내에 숨겨진 일치 항목은 제외 ) 예:</target>
        </trans-unit>
        <trans-unit id="3ba0048f660cfcd3f32cbfe2f76535c5c8d897d2" translate="yes" xml:space="preserve">
          <source>The string following whatever was matched by the last successful pattern match (not counting any matches hidden within a BLOCK or &lt;code&gt;eval()&lt;/code&gt; enclosed by the current BLOCK). Example:</source>
          <target state="translated">마지막으로 성공한 패턴 일치에 의해 일치 된 항목 뒤에 오는 문자열 ( 현재 BLOCK에 포함 된 BLOCK 또는 &lt;code&gt;eval()&lt;/code&gt; 내에 숨겨진 일치 항목은 계산하지 않음 ). 예:</target>
        </trans-unit>
        <trans-unit id="64817d2b5e56c060bf38149d53adb10efe254293" translate="yes" xml:space="preserve">
          <source>The string for Tuesday, December 12, 1995.</source>
          <target state="translated">1995 년 12 월 12 일 화요일의 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="f9abb06eb1806839c0e5b7b9bda35c81b35ae824" translate="yes" xml:space="preserve">
          <source>The string index to a &lt;b&gt;hash&lt;/b&gt;, used to look up the &lt;b&gt;value&lt;/b&gt; associated with that key.</source>
          <target state="translated">해당 키와 연관된 &lt;b&gt;값&lt;/b&gt; 을 찾는 데 사용되는 &lt;b&gt;해시&lt;/b&gt; 의 문자열 색인 입니다.&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="b6885316bc4f379b0a1d01488371bab62a2d9d85" translate="yes" xml:space="preserve">
          <source>The string is broken into chunks described by the TEMPLATE. Each chunk is converted separately to a value. Typically, either the string is a result of &lt;a href=&quot;#pack-TEMPLATE%2CLIST&quot;&gt;&lt;code&gt;pack&lt;/code&gt;&lt;/a&gt;, or the characters of the string represent a C structure of some kind.</source>
          <target state="translated">문자열은 TEMPLATE에서 설명하는 청크로 분할됩니다. 각 청크는 개별적으로 값으로 변환됩니다. 일반적으로 문자열은 &lt;a href=&quot;#pack-TEMPLATE%2CLIST&quot;&gt; &lt;code&gt;pack&lt;/code&gt; &lt;/a&gt; 의 결과 이거나 문자열의 문자는 일종의 C 구조를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="cdaff357d54d31b09acea6f6d18fd623eddeb9f1" translate="yes" xml:space="preserve">
          <source>The string is broken into chunks described by the TEMPLATE. Each chunk is converted separately to a value. Typically, either the string is a result of &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt;, or the characters of the string represent a C structure of some kind.</source>
          <target state="translated">문자열은 TEMPLATE에 의해 설명 된 덩어리로 나뉩니다. 각 청크는 개별적으로 값으로 변환됩니다. 일반적으로 문자열은 &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; 의 결과 이거나 문자열의 문자는 일종의 C 구조를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="1c49e7731d3dc172a2f14e1ee383fed675a44e84" translate="yes" xml:space="preserve">
          <source>The string is broken into chunks described by the TEMPLATE. Each chunk is converted separately to a value. Typically, either the string is a result of &lt;code&gt;&lt;a href=&quot;pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt;, or the characters of the string represent a C structure of some kind.</source>
          <target state="translated">문자열은 TEMPLATE에 의해 설명 된 덩어리로 나뉩니다. 각 청크는 개별적으로 값으로 변환됩니다. 일반적으로 문자열은 &lt;code&gt;&lt;a href=&quot;pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; 의 결과 이거나 문자열의 문자는 일종의 C 구조를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="188acb1539bbcc7515d5af86f1bf3d6e3f0bd9c0" translate="yes" xml:space="preserve">
          <source>The string matched by the last successful pattern match (not counting any matches hidden within a BLOCK or &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval()&lt;/a&gt;&lt;/code&gt; enclosed by the current BLOCK).</source>
          <target state="translated">마지막으로 성공한 패턴 일치와 일치하는 문자열 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval()&lt;/a&gt;&lt;/code&gt; 현재 BLOCK으로 묶인 BLOCK 또는 eval () 내에 숨겨진 일치 항목은 제외 )</target>
        </trans-unit>
        <trans-unit id="e9cf9b6b7809255e19e6a3b715176fe34d8d904e" translate="yes" xml:space="preserve">
          <source>The string matched by the last successful pattern match (not counting any matches hidden within a BLOCK or &lt;code&gt;eval()&lt;/code&gt; enclosed by the current BLOCK).</source>
          <target state="translated">마지막으로 성공한 패턴 일치와 일치하는 문자열입니다 &lt;code&gt;eval()&lt;/code&gt; 현재 BLOCK에 포함 된 BLOCK 또는 eval () 내에 숨겨진 일치 항목은 계산하지 않음 ).</target>
        </trans-unit>
        <trans-unit id="89c0c038ca187cf5160e57a2c61c41440d3e8e16" translate="yes" xml:space="preserve">
          <source>The string output (of floating point numbers) is padded with zeros:</source>
          <target state="translated">문자열 출력 (부동 소수점 숫자)은 0으로 채워집니다.</target>
        </trans-unit>
        <trans-unit id="3d206cfe2e19b0f3779f91c6d76bdde7d7e22deb" translate="yes" xml:space="preserve">
          <source>The string output (of floating point numbers) will be padded with zeros:</source>
          <target state="translated">부동 소수점 숫자의 문자열 출력은 0으로 채워집니다.</target>
        </trans-unit>
        <trans-unit id="baf7cbc523832c454565f07354dbdc53faf7a98a" translate="yes" xml:space="preserve">
          <source>The string output will always have leading and trailing zeros stripped and drop a plus sign. &lt;code&gt;bstr()&lt;/code&gt; will give you always the form with a decimal point, while &lt;code&gt;bsstr()&lt;/code&gt; (s for scientific) gives you the scientific notation.</source>
          <target state="translated">문자열 출력에는 항상 선행 및 후행 0이 제거되고 더하기 부호가 삭제됩니다. &lt;code&gt;bstr()&lt;/code&gt; 은 항상 소수점 형식을 제공하지만 &lt;code&gt;bsstr()&lt;/code&gt; 은 과학적 표기법을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="fe7b97aace0009c030b7f9cefcb2ca042c7263c6" translate="yes" xml:space="preserve">
          <source>The string preceding whatever was matched by the last successful pattern match, not counting any matches hidden within a BLOCK or &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; enclosed by the current BLOCK.</source>
          <target state="translated">마지막으로 성공한 패턴 일치와 일치하는 항목 앞에 오는 문자열은 BLOCK 내에 숨겨져있는 일치 항목이나 현재 BLOCK으로 둘러싸인 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 계산하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="7f5e6eea58cb9fa29a6890f23f4c2850f3c5d5cc" translate="yes" xml:space="preserve">
          <source>The string preceding whatever was matched by the last successful pattern match, not counting any matches hidden within a BLOCK or &lt;code&gt;eval&lt;/code&gt; enclosed by the current BLOCK.</source>
          <target state="translated">문자열이 아닌 BLOCK 또는 안에 숨겨진 어떤 경기 카운트, 마지막으로 성공한 패턴 일치에 의해 일치 된 선행하는 어떤 &lt;code&gt;eval&lt;/code&gt; 현재 블록에 의해 둘러싸여있다.</target>
        </trans-unit>
        <trans-unit id="339432ba64926aa8fa758ffc110e1d9819cad770" translate="yes" xml:space="preserve">
          <source>The string result of any operation that uses locale information is tainted, as it is possible for a locale to be untrustworthy. See &lt;a href=&quot;#SECURITY&quot;&gt;&quot;SECURITY&quot;&lt;/a&gt;.</source>
          <target state="translated">로케일 정보를 사용하는 작업의 문자열 결과는 로케일을 신뢰할 수 없을 수 있으므로 오염되었습니다. &lt;a href=&quot;#SECURITY&quot;&gt;&quot;보안&quot;을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="3d01fff15593695c94b4861cde9efd9b7494ec49" translate="yes" xml:space="preserve">
          <source>The string result of any operation that uses locale information is tainted, as it is possible for a locale to be untrustworthy. See &lt;a href=&quot;#SECURITY&quot;&gt;SECURITY&lt;/a&gt;.</source>
          <target state="translated">로케일을 신뢰할 수 없을 수 있으므로 로케일 정보를 사용하는 조작의 문자열 결과가 오염됩니다. &lt;a href=&quot;#SECURITY&quot;&gt;보안을&lt;/a&gt; 참조 하십시오 .</target>
        </trans-unit>
        <trans-unit id="8fe36e2f9f506bb3c17ca908f63a229076cb522b" translate="yes" xml:space="preserve">
          <source>The string returned is not always in NFD/NFKD. Reordering may be required.</source>
          <target state="translated">반환 된 문자열이 항상 NFD / NFKD 인 것은 아닙니다. 재정렬이 필요할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2d311addc77468e8c33d61dc204474a00d32a5a2" translate="yes" xml:space="preserve">
          <source>The string that represents the C type that was not found in the typemap.</source>
          <target state="translated">typemap에없는 C 유형을 나타내는 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="0906d45502ea0bd7da882f8e89531d4e1f01bc75" translate="yes" xml:space="preserve">
          <source>The string that starts options. If a constant string is not sufficient, see &lt;code&gt;prefix_pattern&lt;/code&gt; .</source>
          <target state="translated">옵션을 시작하는 문자열입니다. 상수 문자열이 충분하지 않으면 &lt;code&gt;prefix_pattern&lt;/code&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="efa5933751bfaa2a6c4eeedd57fd05169704edd2" translate="yes" xml:space="preserve">
          <source>The string that starts options. If a constant string is not sufficient, see &lt;code&gt;prefix_pattern&lt;/code&gt;.</source>
          <target state="translated">옵션을 시작하는 문자열입니다. 상수 문자열이 충분하지 않은 경우 &lt;code&gt;prefix_pattern&lt;/code&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="fcff2e1cc42c11b32cad489cc398585a2adb0338" translate="yes" xml:space="preserve">
          <source>The string to be inserted is represented by</source>
          <target state="translated">삽입 할 문자열은</target>
        </trans-unit>
        <trans-unit id="00f6f2add8143f7b5f6195521c58d01172830e33" translate="yes" xml:space="preserve">
          <source>The string to be inserted is represented by &lt;code&gt;len&lt;/code&gt; octets starting at &lt;code&gt;pv&lt;/code&gt;. These octets are interpreted as either UTF-8 or Latin-1, according to whether the &lt;code&gt;LEX_STUFF_UTF8&lt;/code&gt; flag is set in &lt;code&gt;flags&lt;/code&gt;. The characters are recoded for the lexer buffer, according to how the buffer is currently being interpreted (&lt;a href=&quot;#lex_bufutf8&quot;&gt;&quot;lex_bufutf8&quot;&lt;/a&gt;). If a string to be inserted is available as a Perl scalar, the &lt;a href=&quot;#lex_stuff_sv&quot;&gt;&quot;lex_stuff_sv&quot;&lt;/a&gt; function is more convenient.</source>
          <target state="translated">삽입 할 문자열 은 &lt;code&gt;pv&lt;/code&gt; 에서 시작 하는 &lt;code&gt;len&lt;/code&gt; 옥텟으로 표시됩니다 . 이러한 옥텟은 &lt;code&gt;LEX_STUFF_UTF8&lt;/code&gt; 플래그가 &lt;code&gt;flags&lt;/code&gt; 에 설정되어 있는지 여부에 따라 UTF-8 또는 Latin-1로 해석됩니다 . 문자는 현재 버퍼가 해석되는 방식 ( &lt;a href=&quot;#lex_bufutf8&quot;&gt;&quot;lex_bufutf8&quot;&lt;/a&gt; ) 에 따라 렉서 버퍼 용으로 다시 코딩됩니다 . 삽입 할 문자열을 Perl 스칼라로 사용할 수있는 경우 &lt;a href=&quot;#lex_stuff_sv&quot;&gt;&quot;lex_stuff_sv&quot;&lt;/a&gt; 함수가 더 편리합니다.</target>
        </trans-unit>
        <trans-unit id="e41abf45c9431728dd7313f8c098905bb3fb1c5d" translate="yes" xml:space="preserve">
          <source>The string to be inserted is represented by octets starting at</source>
          <target state="translated">삽입 할 문자열은 다음에서 시작하는 8 진수로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="c0c0bf345ccfdae0fb09cf9ab2d8e8d8ae4c0512" translate="yes" xml:space="preserve">
          <source>The string to be inserted is represented by octets starting at &lt;code&gt;pv&lt;/code&gt; and continuing to the first nul. These octets are interpreted as either UTF-8 or Latin-1, according to whether the &lt;code&gt;LEX_STUFF_UTF8&lt;/code&gt; flag is set in &lt;code&gt;flags&lt;/code&gt;. The characters are recoded for the lexer buffer, according to how the buffer is currently being interpreted (&lt;a href=&quot;#lex_bufutf8&quot;&gt;&quot;lex_bufutf8&quot;&lt;/a&gt;). If it is not convenient to nul-terminate a string to be inserted, the &lt;a href=&quot;#lex_stuff_pvn&quot;&gt;&quot;lex_stuff_pvn&quot;&lt;/a&gt; function is more appropriate.</source>
          <target state="translated">삽입 할 문자열은 &lt;code&gt;pv&lt;/code&gt; 에서 시작 하여 첫 번째 nul까지 계속되는 옥텟으로 표시됩니다 . 이러한 옥텟은 &lt;code&gt;LEX_STUFF_UTF8&lt;/code&gt; 플래그가 &lt;code&gt;flags&lt;/code&gt; 에 설정되어 있는지 여부에 따라 UTF-8 또는 Latin-1로 해석됩니다 . 문자는 현재 버퍼가 해석되는 방식 ( &lt;a href=&quot;#lex_bufutf8&quot;&gt;&quot;lex_bufutf8&quot;&lt;/a&gt; ) 에 따라 렉서 버퍼 용으로 다시 코딩됩니다 . 삽입 할 문자열을 &lt;a href=&quot;#lex_stuff_pvn&quot;&gt;널&lt;/a&gt; 종료하는 것이 편리하지 않은 경우 &quot;lex_stuff_pvn&quot; 함수가 더 적합합니다.</target>
        </trans-unit>
        <trans-unit id="afbb1230317b082fc0f64afe5f1a79c6e5661e9b" translate="yes" xml:space="preserve">
          <source>The string to be inserted is the string value of</source>
          <target state="translated">삽입 할 문자열은</target>
        </trans-unit>
        <trans-unit id="55208eb6676e3f7f6524a3ebd4f29e07cc0731fc" translate="yes" xml:space="preserve">
          <source>The string to be inserted is the string value of &lt;code&gt;sv&lt;/code&gt;. The characters are recoded for the lexer buffer, according to how the buffer is currently being interpreted (&lt;a href=&quot;#lex_bufutf8&quot;&gt;&quot;lex_bufutf8&quot;&lt;/a&gt;). If a string to be inserted is not already a Perl scalar, the &lt;a href=&quot;#lex_stuff_pvn&quot;&gt;&quot;lex_stuff_pvn&quot;&lt;/a&gt; function avoids the need to construct a scalar.</source>
          <target state="translated">삽입 할 문자열은 &lt;code&gt;sv&lt;/code&gt; 의 문자열 값입니다 . 문자는 현재 버퍼가 해석되는 방식 ( &lt;a href=&quot;#lex_bufutf8&quot;&gt;&quot;lex_bufutf8&quot;&lt;/a&gt; ) 에 따라 렉서 버퍼 용으로 다시 코딩됩니다 . 삽입 할 문자열이 Perl 스칼라가 아닌 경우 &lt;a href=&quot;#lex_stuff_pvn&quot;&gt;&quot;lex_stuff_pvn&quot;&lt;/a&gt; 함수를 사용하면 스칼라를 생성 할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="5a627ebdca058ca40f7afebaa0947770e3b19935" translate="yes" xml:space="preserve">
          <source>The string value of &lt;code&gt;$!&lt;/code&gt; is that returned by the CRTL's strerror() function, so it will include the VMS message for VMS-specific errors. The numeric value of &lt;code&gt;$!&lt;/code&gt; is the value of &lt;code&gt;errno&lt;/code&gt; , except if errno is EVMSERR, in which case &lt;code&gt;$!&lt;/code&gt; contains the value of vaxc$errno. Setting &lt;code&gt;$!&lt;/code&gt; always sets errno to the value specified. If this value is EVMSERR, it also sets vaxc$errno to 4 (NONAME-F-NOMSG), so that the string value of &lt;code&gt;$!&lt;/code&gt; won't reflect the VMS error message from before &lt;code&gt;$!&lt;/code&gt; was set.</source>
          <target state="translated">&lt;code&gt;$!&lt;/code&gt; 의 문자열 값 ! 이는 CRTL의 strerror () 함수에 의해 반환되므로 VMS 관련 오류에 대한 VMS 메시지를 포함합니다. &lt;code&gt;$!&lt;/code&gt; 의 숫자 값 errno가 EVMSERR 인 경우를 제외하고 는 &lt;code&gt;errno&lt;/code&gt; 의 값입니다 .이 경우 &lt;code&gt;$!&lt;/code&gt; vaxc $ errno의 값을 포함합니다. &lt;code&gt;$!&lt;/code&gt; 설정 중 ! 항상 errno를 지정된 값으로 설정합니다. 이 값이 EVMSERR이면 vaxc $ errno를 4 (NONAME-F-NOMSG)로 설정하여 문자열 값 &lt;code&gt;$!&lt;/code&gt; &lt;code&gt;$!&lt;/code&gt; 이전의 VMS 오류 메시지를 반영하지 않습니다 . 설정되었습니다.</target>
        </trans-unit>
        <trans-unit id="6bce1054a07cc28e1b64ace7f7b805802c74829f" translate="yes" xml:space="preserve">
          <source>The string value of &lt;code&gt;$!&lt;/code&gt; is that returned by the CRTL's strerror() function, so it will include the VMS message for VMS-specific errors. The numeric value of &lt;code&gt;$!&lt;/code&gt; is the value of &lt;code&gt;errno&lt;/code&gt;, except if errno is EVMSERR, in which case &lt;code&gt;$!&lt;/code&gt; contains the value of vaxc$errno. Setting &lt;code&gt;$!&lt;/code&gt; always sets errno to the value specified. If this value is EVMSERR, it also sets vaxc$errno to 4 (NONAME-F-NOMSG), so that the string value of &lt;code&gt;$!&lt;/code&gt; won't reflect the VMS error message from before &lt;code&gt;$!&lt;/code&gt; was set.</source>
          <target state="translated">&lt;code&gt;$!&lt;/code&gt; 의 문자열 값 CRTL의 strerror () 함수에 의해 반환되므로 VMS 관련 오류에 대한 VMS 메시지가 포함됩니다. &lt;code&gt;$!&lt;/code&gt; 의 숫자 값입니다 . errno가 EVMSERR 인 경우를 제외하고 &lt;code&gt;errno&lt;/code&gt; 의 값입니다 .이 경우 &lt;code&gt;$!&lt;/code&gt; vaxc $ errno의 값을 포함합니다. &lt;code&gt;$!&lt;/code&gt; 설정 항상 errno를 지정된 값으로 설정합니다. 이 값이 EVMSERR이면 vaxc $ errno도 4 (NONAME-F-NOMSG)로 설정되므로 &lt;code&gt;$!&lt;/code&gt; &lt;code&gt;$!&lt;/code&gt; 이전의 VMS 오류 메시지가 반영되지 않습니다 . 설정되었습니다.</target>
        </trans-unit>
        <trans-unit id="ed1f52a4cdbc897685e0ae4db35f3139cd121ffc" translate="yes" xml:space="preserve">
          <source>The string value of the $data provided as argument is appended to the message we calculate the digest for. The return value is the $ctx object itself.</source>
          <target state="translated">인수로 제공된 $ data의 문자열 값은 다이제스트를 계산하는 메시지에 추가됩니다. 반환 값은 $ ctx 객체 자체입니다.</target>
        </trans-unit>
        <trans-unit id="7a8e800596cb341c8f599d3168bdf4ec9c0dbea7" translate="yes" xml:space="preserve">
          <source>The strings returned may not be useful for 3-argument open().</source>
          <target state="translated">반환 된 문자열은 3 인수 open ()에 유용하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="eb1b5858acfdd756a7774d6480e810b1c2f37266" translate="yes" xml:space="preserve">
          <source>The stroke ordering includes some characters that are not CJK Unified Ideographs and can't utilize &lt;code&gt;weightStroke()&lt;/code&gt; for collation. For them, use &lt;code&gt;entry&lt;/code&gt; instead.</source>
          <target state="translated">스트로크 순서에는 CJK 통합 표의 문자가 아니고 데이터 정렬에 &lt;code&gt;weightStroke()&lt;/code&gt; 를 사용할 수없는 일부 문자가 포함됩니다 . 그들을 위해 대신 &lt;code&gt;entry&lt;/code&gt; 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="8d2353f63db6ded15b27f9ce53f46b40b4850e7c" translate="yes" xml:space="preserve">
          <source>The struct() function</source>
          <target state="translated">struct () 함수</target>
        </trans-unit>
        <trans-unit id="2b18f7164a2da5acc0a078abefbfdb45f1b7ed1a" translate="yes" xml:space="preserve">
          <source>The structure of the tied() data is an array reference with elements</source>
          <target state="translated">tied () 데이터의 구조는 요소를 가진 배열 참조입니다</target>
        </trans-unit>
        <trans-unit id="6772fe1a2535c049980c3763958a49b4c1d992f9" translate="yes" xml:space="preserve">
          <source>The stub package included with the perl distribution allows some additional methods:</source>
          <target state="translated">펄 배포판에 포함 된 스텁 패키지는 몇 가지 추가 방법을 허용합니다.</target>
        </trans-unit>
        <trans-unit id="69dca73bafb51f0fe392c69e65938a9183f98a5b" translate="yes" xml:space="preserve">
          <source>The sub will receive exactly 1 argument, the type of thing being tagged 'context', 'hub', or 'event'. In the future additional things may be tagged, in which case new strings will be passed in. These are purely informative, you can (and usually should) ignore them.</source>
          <target state="translated">서브는 정확히 1 개의 인수를 받게되며, 사물의 유형은 'context', 'hub'또는 'event'로 태그가 지정됩니다. 향후 추가 항목에 태그가 추가 될 수 있으며,이 경우 새 문자열이 전달됩니다. 이는 순전히 정보를 제공하기 때문에 무시할 수 있습니다 (일반적으로 무시해야 함).</target>
        </trans-unit>
        <trans-unit id="7c28ea2e9a2d4863b1fc0e89e9b8c44c6fa89947" translate="yes" xml:space="preserve">
          <source>The sub you provide should always return a unique identifier. Most things will expect a proper UUID string, however nothing in Test2::API enforces this.</source>
          <target state="translated">제공하는 서브는 항상 고유 한 식별자를 반환해야합니다. 대부분의 경우 적절한 UUID 문자열이 필요하지만 Test2 :: API에서는이를 적용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6bfcc48f6a94ab4b3e39e57492b7c1d6d2ad759d" translate="yes" xml:space="preserve">
          <source>The submitter address in &lt;code&gt;AUTH&lt;/code&gt; option is expected to be in a format as required by RFC 2554, in an RFC2821-quoted form and xtext-encoded, or &amp;lt;&amp;gt; .</source>
          <target state="translated">&lt;code&gt;AUTH&lt;/code&gt; 옵션 의 제출자 주소는 RFC 2554에서 요구하는 형식, RFC2821 인용 양식 및 xtext 인코딩 또는 &amp;lt;&amp;gt; 형식이어야합니다.</target>
        </trans-unit>
        <trans-unit id="4ac8a2878ef2e11af070ab32ec1a2e0bca8078f0" translate="yes" xml:space="preserve">
          <source>The subroutine (including package) that threw the exception.</source>
          <target state="translated">예외를 발생시킨 서브 루틴 (패키지 포함)입니다.</target>
        </trans-unit>
        <trans-unit id="99602f0147c6aaadcc127e8f752211c7da8fb282" translate="yes" xml:space="preserve">
          <source>The subroutine for &lt;code&gt;'='&lt;/code&gt; does not overload the Perl assignment operator: it is used only to allow mutators to work as described here. (See &lt;a href=&quot;#Assignments&quot;&gt;&quot;Assignments&quot;&lt;/a&gt; above.)</source>
          <target state="translated">&lt;code&gt;'='&lt;/code&gt; 에 대한 서브 루틴 은 Perl 할당 연산자를 오버로드하지 않습니다. 여기에 설명 된대로 뮤 테이터가 작동하도록 허용하는 데만 사용됩니다. ( 위의 &lt;a href=&quot;#Assignments&quot;&gt;&quot;과제&quot;를&lt;/a&gt; 참조하십시오 .)</target>
        </trans-unit>
        <trans-unit id="4fb6dff8391b18be99fd9ebb7eb204cdfa56639a" translate="yes" xml:space="preserve">
          <source>The subroutine for &lt;code&gt;'='&lt;/code&gt; does not overload the Perl assignment operator: it is used only to allow mutators to work as described here. (See &lt;a href=&quot;#Assignments&quot;&gt;Assignments&lt;/a&gt; above.)</source>
          <target state="translated">&lt;code&gt;'='&lt;/code&gt; 에 대한 서브 루틴 은 Perl 할당 연산자를 오버로드하지 않습니다. 여기에 설명 된대로 뮤 테이터가 작동하도록하는 데만 사용됩니다. ( &lt;a href=&quot;#Assignments&quot;&gt;지정&lt;/a&gt; 참조 위 )</target>
        </trans-unit>
        <trans-unit id="f6d2e2cf74b94dd2aff54191a4db818c472b013b" translate="yes" xml:space="preserve">
          <source>The subroutine for &lt;code&gt;'qr'&lt;/code&gt; is used wherever the object is interpolated into or used as a regexp, including when it appears on the RHS of a &lt;code&gt;=~&lt;/code&gt; or &lt;code&gt;!~&lt;/code&gt; operator.</source>
          <target state="translated">&lt;code&gt;'qr'&lt;/code&gt; 에 대한 서브 루틴 은 오브젝트가 &lt;code&gt;=~&lt;/code&gt; 또는 &lt;code&gt;!~&lt;/code&gt; 의 RHS에 나타날 때를 포함하여 정규 표현식으로 보간되거나 정규 표현식으로 사용되는 모든 곳에서 사용됩니다 . 연산자 .</target>
        </trans-unit>
        <trans-unit id="64e556905a1003da7539606b5717985b47db5c9d" translate="yes" xml:space="preserve">
          <source>The subroutine for the assignment variant of an operator is required only to return the result of the operation. It is permitted to change the value of its operand (this is safe because Perl calls the copy constructor first), but this is optional since Perl assigns the returned value to the left-hand operand anyway.</source>
          <target state="translated">연산자의 할당 변형에 대한 서브 루틴은 조작 결과를 리턴하기 위해서만 필요합니다. 피연산자의 값을 변경할 수 있지만 (Perl이 먼저 복사 생성자를 호출하기 때문에 안전합니다) 그러나 Perl은 반환 된 값을 왼쪽 피연산자에 할당하므로 선택 사항입니다.</target>
        </trans-unit>
        <trans-unit id="ae06f7431af42fbc790df16df23af545b2646544" translate="yes" xml:space="preserve">
          <source>The subroutine interface has the advantage over the constants interface in that only two subroutines are exported into your namespace, versus thirty-eight in the constants interface, and aliases and true color attributes are supported. On the flip side, the constants interface has the advantage of better compile time error checking, since misspelled names of colors or attributes in calls to color() and colored() won't be caught until runtime whereas misspelled names of constants will be caught at compile time. So, pollute your namespace with almost two dozen subroutines that you may not even use that often, or risk a silly bug by mistyping an attribute. Your choice, TMTOWTDI after all.</source>
          <target state="translated">서브 루틴 인터페이스는 상수 인터페이스의 38 개에 비해 두 개의 서브 루틴 만 네임 스페이스로 내보내지고 별칭 및 트루 컬러 속성이 지원된다는 점에서 상수 인터페이스에 비해 장점이 있습니다. 반대로, 상수 인터페이스는 더 나은 컴파일 시간 오류 검사의 이점이 있습니다. color () 및 colors ()에 대한 호출에서 맞춤법이 잘못된 색상 이름이나 속성은 런타임까지 포착되지 않지만 맞춤법이 잘못된 상수 이름은 포착되기 때문입니다. 컴파일 타임에. 따라서 자주 사용하지 않을 수도있는 거의 24 개의 서브 루틴으로 네임 스페이스를 오염 시키거나 속성을 잘못 입력하여 어리석은 버그를 일으킬 위험이 있습니다. 당신의 선택, 결국 TMTOWTDI.</target>
        </trans-unit>
        <trans-unit id="bf76f7497b47b7fb391cbc985e75a2ec906b200f" translate="yes" xml:space="preserve">
          <source>The subroutine interface has the advantage over the constants interface in that only two subroutines are exported into your namespace, versus thirty-eight in the constants interface. On the flip side, the constants interface has the advantage of better compile time error checking, since misspelled names of colors or attributes in calls to color() and colored() won't be caught until runtime whereas misspelled names of constants will be caught at compile time. So, pollute your namespace with almost two dozen subroutines that you may not even use that often, or risk a silly bug by mistyping an attribute. Your choice, TMTOWTDI after all.</source>
          <target state="translated">서브 루틴 인터페이스는 상수 인터페이스에 비해 32 개의 서브 루틴 만 네임 스페이스로 내보내는 점에서 상수 인터페이스에 비해 이점이 있습니다. 반대로, 상수 인터페이스는 철자가 틀린 색상 이름이나 런타임에 호출 될 때 색상의 잘못된 철자 이름이나 색상 () 및 컬러 () 호출에 대한 속성은 잡히지 않는 반면, 철자가 틀린 상수 이름은 잡히기 때문에 컴파일 시간 오류 검사의 이점이 있습니다. 컴파일 타임에. 따라서 자주 사용하지 않거나 속성을 잘못 입력하여 바보 같은 버그를 일으킬 수있는 약 24 개의 서브 루틴으로 네임 스페이스를 오염시킵니다. 선택, TMTOWTDI.</target>
        </trans-unit>
        <trans-unit id="914a52e2466ed981c0c31fa5a16b3a84e13235bf" translate="yes" xml:space="preserve">
          <source>The subroutine takes up to five optional arguments:</source>
          <target state="translated">서브 루틴은 최대 5 개의 선택적 인수를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="685ad04169c11394ad7ed60a2bfecf22cb675ffa" translate="yes" xml:space="preserve">
          <source>The subroutine takes up to four optional arguments (the same set as &lt;code&gt;extract_tagged&lt;/code&gt; except for the string to be processed). It returns a reference to a subroutine which in turn takes a single argument (the text to be extracted from).</source>
          <target state="translated">서브 루틴은 최대 4 개의 선택적 인수 ( &lt;code&gt;extract_tagged&lt;/code&gt; 와 동일한 세트)를 사용합니다. 처리 할 문자열을 제외하고 )를 사용합니다. 서브 루틴에 대한 참조를 리턴하고 서브 루틴에 단일 인수 (텍스트를 추출 할)를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="8d893978d831c7b5b97d6abcf392307452f2c4dc" translate="yes" xml:space="preserve">
          <source>The subroutine takes up to four optional arguments:</source>
          <target state="translated">서브 루틴은 최대 4 개의 선택적 인수를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="7612ae6125d2980d42108a51846f43870c13a8ab" translate="yes" xml:space="preserve">
          <source>The subroutine takes up to two optional arguments:</source>
          <target state="translated">서브 루틴은 최대 두 개의 선택적 인수를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="e4c12336d2e867ba9a727cf78cc335118965b26b" translate="yes" xml:space="preserve">
          <source>The subroutine that</source>
          <target state="translated">서브 루틴</target>
        </trans-unit>
        <trans-unit id="2fc2edb73f368d2c8247ff6673cfa64dcc7b4601" translate="yes" xml:space="preserve">
          <source>The subroutine will have &lt;code&gt;CvFILE&lt;/code&gt; set according to &lt;code&gt;PL_curcop&lt;/code&gt;. Other aspects of the subroutine will be left in their default state. The caller is free to mutate the subroutine beyond its initial state after this function has returned.</source>
          <target state="translated">서브 루틴은 &lt;code&gt;CvFILE&lt;/code&gt; 에 따라 설정된 &lt;code&gt;PL_curcop&lt;/code&gt; 을 갖습니다 . 서브 루틴의 다른 측면은 기본 상태로 유지됩니다. 호출자는이 함수가 반환 된 후 초기 상태를 넘어서 서브 루틴을 자유롭게 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="265ef174cfb1c0102c91c9689e3bcac20840f609" translate="yes" xml:space="preserve">
          <source>The subroutine will have an empty prototype and will ignore any arguments when called. Its constant behaviour is determined by &lt;code&gt;sv&lt;/code&gt;. If &lt;code&gt;sv&lt;/code&gt; is null, the subroutine will yield an empty list. If &lt;code&gt;sv&lt;/code&gt; points to a scalar, the subroutine will always yield that scalar. If &lt;code&gt;sv&lt;/code&gt; points to an array, the subroutine will always yield a list of the elements of that array in list context, or the number of elements in the array in scalar context. This function takes ownership of one counted reference to the scalar or array, and will arrange for the object to live as long as the subroutine does. If &lt;code&gt;sv&lt;/code&gt; points to a scalar then the inlining assumes that the value of the scalar will never change, so the caller must ensure that the scalar is not subsequently written to. If &lt;code&gt;sv&lt;/code&gt; points to an array then no such assumption is made, so it is ostensibly safe to mutate the array or its elements, but whether this is really supported has not been determined.</source>
          <target state="translated">서브 루틴은 빈 프로토 타입을 가지며 호출 될 때 모든 인수를 무시합니다. 지속적인 동작은 &lt;code&gt;sv&lt;/code&gt; 에 의해 결정됩니다 . 경우 &lt;code&gt;sv&lt;/code&gt; null의 경우, 서브 루틴은 빈 목록을 얻을 것입니다. 경우 &lt;code&gt;sv&lt;/code&gt; 스칼라 포인트, 서브 루틴은 항상 스칼라을 얻을 것입니다. &lt;code&gt;sv&lt;/code&gt; 가 배열을 가리키는 경우 서브 루틴은 항상 목록 컨텍스트에서 해당 배열의 요소 목록을 생성하거나 스칼라 컨텍스트에서 배열의 요소 수를 생성합니다. 이 함수는 스칼라 또는 배열에 대한 하나의 계산 된 참조의 소유권을 취하고 서브 루틴이 수행하는 한 개체가 유지되도록 정렬합니다. &lt;code&gt;sv&lt;/code&gt; 인 경우스칼라를 가리키면 인라인은 스칼라 값이 절대 변경되지 않는다고 가정하므로 호출자는 나중에 스칼라가 쓰이지 않도록해야합니다. 경우 &lt;code&gt;sv&lt;/code&gt; 배열을 포인트는 다음 그러한 가정은 이루어지지 않는다, 그래서 배열 또는 요소를 돌연변이 표면 상 안전하지만,이 있는지 정말 결정되지 않은 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="82f27fb61975933bf23afb22d7dcc89dbb6c6b52" translate="yes" xml:space="preserve">
          <source>The subroutine will have the entry point &lt;code&gt;subaddr&lt;/code&gt;. It will have the prototype specified by the nul-terminated string &lt;code&gt;proto&lt;/code&gt;, or no prototype if &lt;code&gt;proto&lt;/code&gt; is null. The prototype string is copied; the caller can mutate the supplied string afterwards. If &lt;code&gt;filename&lt;/code&gt; is non-null, it must be a nul-terminated filename, and the subroutine will have its &lt;code&gt;CvFILE&lt;/code&gt; set accordingly. By default &lt;code&gt;CvFILE&lt;/code&gt; is set to point directly to the supplied string, which must be static. If &lt;code&gt;flags&lt;/code&gt; has the &lt;code&gt;XS_DYNAMIC_FILENAME&lt;/code&gt; bit set, then a copy of the string will be taken instead.</source>
          <target state="translated">서브 루틴에는 진입 점 &lt;code&gt;subaddr&lt;/code&gt; 가 있습니다. nul로 끝나는 문자열 &lt;code&gt;proto&lt;/code&gt; 에 의해 지정된 프로토 타입을 가지거나 &lt;code&gt;proto&lt;/code&gt; 가 널인 경우 프로토 타입이 없습니다 . 프로토 타입 문자열이 복사됩니다. 호출자는 나중에 제공된 문자열을 변경할 수 있습니다. &lt;code&gt;filename&lt;/code&gt; 이 널이 아닌 경우 널로 끝나는 파일 이름이어야하며 서브 루틴은 그에 따라 &lt;code&gt;CvFILE&lt;/code&gt; 을 설정합니다. 기본적으로 &lt;code&gt;CvFILE&lt;/code&gt; 은 정적이어야하는 제공된 문자열을 직접 가리 키도록 설정됩니다. &lt;code&gt;flags&lt;/code&gt; 에 &lt;code&gt;XS_DYNAMIC_FILENAME&lt;/code&gt; 비트가 설정되어 있으면 문자열 사본이 대신 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="3a75faaa2a2f313dd76bd18e70bc1892ae4231d3" translate="yes" xml:space="preserve">
          <source>The subroutines for &lt;code&gt;'&quot;&quot;'&lt;/code&gt; , &lt;code&gt;'0+'&lt;/code&gt; , and &lt;code&gt;'bool'&lt;/code&gt; can return any arbitrary Perl value. If the corresponding operation for this value is overloaded too, the operation will be called again with this value.</source>
          <target state="translated">&lt;code&gt;'&quot;&quot;'&lt;/code&gt; , &lt;code&gt;'0+'&lt;/code&gt; 및 &lt;code&gt;'bool'&lt;/code&gt; 의 서브 루틴은 임의의 Perl 값을 리턴 할 수 있습니다. 이 값에 해당하는 조작에도 과부하가 걸리면이 값으로 조작이 다시 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="740359d4d5595e110911a4995def79d738d321f7" translate="yes" xml:space="preserve">
          <source>The subroutines for &lt;code&gt;'&quot;&quot;'&lt;/code&gt;, &lt;code&gt;'0+'&lt;/code&gt;, and &lt;code&gt;'bool'&lt;/code&gt; can return any arbitrary Perl value. If the corresponding operation for this value is overloaded too, the operation will be called again with this value.</source>
          <target state="translated">&lt;code&gt;'&quot;&quot;'&lt;/code&gt; , &lt;code&gt;'0+'&lt;/code&gt; 및 &lt;code&gt;'bool'&lt;/code&gt; 에 대한 서브 루틴은 임의의 Perl 값을 반환 할 수 있습니다. 이 값에 해당하는 연산도 오버로드되면이 값으로 연산이 다시 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="268a5bcbdfddf71f1babd661a5336aa5d10c3ae8" translate="yes" xml:space="preserve">
          <source>The subroutines must return a specially-formatted string, with one or more newline-separated lines. Each line must be one of the following:</source>
          <target state="translated">서브 루틴은 하나 이상의 줄 바꾸기로 구분 된 특수 형식 문자열을 리턴해야합니다. 각 줄은 다음 중 하나 여야합니다.</target>
        </trans-unit>
        <trans-unit id="2ba07955562198fe0f02a6cf2bc902a4d38ec5bc" translate="yes" xml:space="preserve">
          <source>The subscript separator for multidimensional array emulation. If you refer to a hash element as</source>
          <target state="translated">다차원 배열 에뮬레이션을위한 첨자 분리 자. 해시 요소를</target>
        </trans-unit>
        <trans-unit id="b5d318f376ec00a74018e4ca7dc7c929a2558708" translate="yes" xml:space="preserve">
          <source>The substitution operator. See &lt;a href=&quot;../perlop#Regexp-Quote-Like-Operators&quot;&gt;Regexp Quote-Like Operators in perlop&lt;/a&gt;.</source>
          <target state="translated">대체 연산자 &lt;a href=&quot;../perlop#Regexp-Quote-Like-Operators&quot;&gt;perlop의 정규 표현식 인용 유사 연산자를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="96c15efd757813123cfb6bdf82217c841dbb4c27" translate="yes" xml:space="preserve">
          <source>The substitution operator. See &lt;a href=&quot;perlop#Regexp-Quote-Like-Operators&quot;&gt;&quot;Regexp Quote-Like Operators&quot; in perlop&lt;/a&gt;.</source>
          <target state="translated">대체 연산자입니다. &lt;a href=&quot;perlop#Regexp-Quote-Like-Operators&quot;&gt;perlop의 &quot;Regexp Quote-Like Operators&quot;를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="cdda388fa507341e8fbaf2711ecce13a77670278" translate="yes" xml:space="preserve">
          <source>The substitution operator. See &lt;a href=&quot;perlop#Regexp-Quote-Like-Operators&quot;&gt;Regexp Quote-Like Operators in perlop&lt;/a&gt;.</source>
          <target state="translated">대체 연산자 &lt;a href=&quot;perlop#Regexp-Quote-Like-Operators&quot;&gt;perlop의 정규 표현식 인용 유사 연산자를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="43eed4ac710279951c5f21e178623c718cf97122" translate="yes" xml:space="preserve">
          <source>The substring to be extracted must appear at the current &lt;code&gt;&lt;a href=&quot;../functions/pos&quot;&gt;pos&lt;/a&gt;&lt;/code&gt; location of the string's variable (or at index zero, if no &lt;code&gt;&lt;a href=&quot;../functions/pos&quot;&gt;pos&lt;/a&gt;&lt;/code&gt; position is defined). In other words, the &lt;code&gt;extract_...&lt;/code&gt; subroutines</source>
          <target state="translated">추출 될 &lt;code&gt;&lt;a href=&quot;../functions/pos&quot;&gt;pos&lt;/a&gt;&lt;/code&gt; 스트링은 스트링 변수 의 현재 위치 (또는 &lt;code&gt;&lt;a href=&quot;../functions/pos&quot;&gt;pos&lt;/a&gt;&lt;/code&gt; 위치가 정의 되지 않은 경우 인덱스 0)에 나타나야합니다 . 다시 말해 &lt;code&gt;extract_...&lt;/code&gt; 서브 루틴</target>
        </trans-unit>
        <trans-unit id="2d860483efae722d0cafa03a2a83e556d7c44ecb" translate="yes" xml:space="preserve">
          <source>The substring to be extracted must appear at the current &lt;code&gt;pos&lt;/code&gt; location of the string's variable (or at index zero, if no &lt;code&gt;pos&lt;/code&gt; position is defined). In other words, the &lt;code&gt;extract_...&lt;/code&gt; subroutines</source>
          <target state="translated">추출 할 하위 문자열 은 문자열 변수 의 현재 &lt;code&gt;pos&lt;/code&gt; 위치 (또는 &lt;code&gt;pos&lt;/code&gt; 위치가 정의 되지 않은 경우 인덱스 0)에 나타나야합니다 . 즉, &lt;code&gt;extract_...&lt;/code&gt; 서브 루틴</target>
        </trans-unit>
        <trans-unit id="8c80d088e6c6c206a945e539d4bfb8f011c76009" translate="yes" xml:space="preserve">
          <source>The subtest event itself, with the first 2 events nested inside it as children.</source>
          <target state="translated">하위 테스트 이벤트 자체. 처음 2 개의 이벤트가 하위로 중첩됩니다.</target>
        </trans-unit>
        <trans-unit id="631c84fac439176eea77875d9cd55aac6e34bef4" translate="yes" xml:space="preserve">
          <source>The subtle but sometimes brutal art of attempting to turn your possibly malformed program into a valid &lt;b&gt;syntax tree&lt;/b&gt;.</source>
          <target state="translated">잘못된 형식의 프로그램을 유효한 &lt;b&gt;구문 트리&lt;/b&gt; 로 바꾸려는 미묘하지만 때로는 잔인한 기술입니다 .</target>
        </trans-unit>
        <trans-unit id="69b5462de54900759de9c61920b693e4e317aaf5" translate="yes" xml:space="preserve">
          <source>The subversion level of this package. The value of subversion comes from the</source>
          <target state="translated">이 패키지의 서브 버전 레벨. 파괴의 가치는</target>
        </trans-unit>
        <trans-unit id="270d4886cf1a538b0addd0c2b282f59bb7645fa0" translate="yes" xml:space="preserve">
          <source>The superuser (&lt;code&gt;UID&lt;/code&gt; == 0). Also the top-level directory of the filesystem.</source>
          <target state="translated">수퍼 유저 ( &lt;code&gt;UID&lt;/code&gt; == 0) 또한 파일 시스템의 최상위 디렉토리입니다.</target>
        </trans-unit>
        <trans-unit id="bb4d5743fc0dd23109f98c367b228edac660d539" translate="yes" xml:space="preserve">
          <source>The support of Unicode is new starting from Perl version v5.6, and more fully implemented in versions v5.8 and later. See &lt;a href=&quot;perluniintro&quot;&gt;perluniintro&lt;/a&gt;.</source>
          <target state="translated">유니 코드 지원은 Perl 버전 v5.6부터 새로 도입되었으며 버전 v5.8 이상에서 더 완벽하게 구현됩니다. &lt;a href=&quot;perluniintro&quot;&gt;perluniintro&lt;/a&gt; 참조 .</target>
        </trans-unit>
        <trans-unit id="6c60ded369392eed501121f572768a1d278a7c99" translate="yes" xml:space="preserve">
          <source>The supported features, documented further below, are:</source>
          <target state="translated">지원되는 기능은 아래에 자세히 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="a84c55afdf9f74f3a1d06dd4132c903afc0559c7" translate="yes" xml:space="preserve">
          <source>The supported platforms are Linux, and OS X (some *BSD might work at least partly, but they have not yet been tested).</source>
          <target state="translated">지원되는 플랫폼은 Linux 및 OS X입니다 (일부 * BSD는 적어도 부분적으로 작동하지만 아직 테스트되지는 않았습니다).</target>
        </trans-unit>
        <trans-unit id="c6fbcb6100de3c481ef36f607630c6994106ebd8" translate="yes" xml:space="preserve">
          <source>The surprising part is that &lt;code&gt;--a&lt;/code&gt; sets option &lt;code&gt;a&lt;/code&gt; (due to auto completion), not &lt;code&gt;all&lt;/code&gt; .</source>
          <target state="translated">놀랍게도 &lt;code&gt;--a&lt;/code&gt; 는 옵션이 &lt;code&gt;a&lt;/code&gt; (자동 완성으로 인해)가 아니라 &lt;code&gt;all&lt;/code&gt; 를 설정 한다는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="75d8922e6906461ffb1cdb138b9e2b992bbd28c0" translate="yes" xml:space="preserve">
          <source>The surprising part is that &lt;code&gt;--a&lt;/code&gt; sets option &lt;code&gt;a&lt;/code&gt; (due to auto completion), not &lt;code&gt;all&lt;/code&gt;.</source>
          <target state="translated">놀라운 부분은 &lt;code&gt;--a&lt;/code&gt; 가 &lt;code&gt;all&lt;/code&gt; 아닌 옵션 &lt;code&gt;a&lt;/code&gt; (자동 완성으로 인해)를 설정 한다는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="033617fd53c9330532a1c3d67c45fd0449d158c6" translate="yes" xml:space="preserve">
          <source>The surroundings or environment. The context given by the surrounding code determines what kind of data a particular &lt;b&gt;expression&lt;/b&gt; is expected to return. The three primary contexts are &lt;b&gt;list context&lt;/b&gt;, &lt;b&gt;scalar&lt;/b&gt;, and &lt;b&gt;void context&lt;/b&gt;. Scalar context is sometimes subdivided into &lt;b&gt;Boolean context&lt;/b&gt;, &lt;b&gt;numeric context&lt;/b&gt;, &lt;b&gt;string context&lt;/b&gt;, and &lt;b&gt;void context&lt;/b&gt;. There&amp;rsquo;s also a &amp;ldquo;don&amp;rsquo;t care&amp;rdquo; context (which is dealt with in Camel chapter 2, &amp;ldquo;Bits and Pieces&amp;rdquo;, if you care).</source>
          <target state="translated">환경이나 환경. 주변 코드에서 제공하는 컨텍스트에 따라 특정 &lt;b&gt;표현식&lt;/b&gt; 이 반환 할 데이터 종류가 결정 됩니다. 세 가지 주요 컨텍스트는 &lt;b&gt;list context&lt;/b&gt; , &lt;b&gt;스칼라&lt;/b&gt; 및 &lt;b&gt;void 컨텍스트&lt;/b&gt; 입니다. 스칼라 컨텍스트는 때때로 &lt;b&gt;부울 컨텍스트&lt;/b&gt; , &lt;b&gt;숫자 컨텍스트&lt;/b&gt; , &lt;b&gt;문자열 컨텍스트&lt;/b&gt; 및 &lt;b&gt;void 컨텍스트&lt;/b&gt; 로 세분됩니다 . 또한 &quot;무관심&quot;이라는 맥락이 있습니다 (카멜 2 장, &quot;원하는 경우 비트와 조각&quot;에서 다루어집니다).</target>
        </trans-unit>
        <trans-unit id="295e290eb0d08f2169eeef73696284f8eecaacb4" translate="yes" xml:space="preserve">
          <source>The sv_magic function uses &lt;code&gt;how&lt;/code&gt; to determine which, if any, predefined &quot;Magic Virtual Table&quot; should be assigned to the &lt;code&gt;mg_virtual&lt;/code&gt; field. See the &lt;a href=&quot;#Magic-Virtual-Tables&quot;&gt;&quot;Magic Virtual Tables&quot;&lt;/a&gt; section below. The &lt;code&gt;how&lt;/code&gt; argument is also stored in the &lt;code&gt;mg_type&lt;/code&gt; field. The value of &lt;code&gt;how&lt;/code&gt; should be chosen from the set of macros &lt;code&gt;PERL_MAGIC_foo&lt;/code&gt; found in</source>
          <target state="translated">sv_magic 함수는 &lt;code&gt;mg_virtual&lt;/code&gt; 필드에 할당되어야하는 미리 정의 된 &quot;Magic Virtual Table&quot;을 결정하는 &lt;code&gt;how&lt;/code&gt; 을 사용 합니다 . 아래의 &lt;a href=&quot;#Magic-Virtual-Tables&quot;&gt;&quot;매직 가상 테이블&quot;&lt;/a&gt; 섹션을 참조하십시오. &lt;code&gt;how&lt;/code&gt; 인수도에 저장되어 &lt;code&gt;mg_type&lt;/code&gt; 의 필드. 의 값 &lt;code&gt;how&lt;/code&gt; 매크로의 집합에서 선택해야한다는 &lt;code&gt;PERL_MAGIC_foo&lt;/code&gt; 에서 발견</target>
        </trans-unit>
        <trans-unit id="ed80b515b4081009a4556929c3f21adbe337dfc8" translate="yes" xml:space="preserve">
          <source>The sv_magic function uses &lt;code&gt;how&lt;/code&gt; to determine which, if any, predefined &quot;Magic Virtual Table&quot; should be assigned to the &lt;code&gt;mg_virtual&lt;/code&gt; field. See the &lt;a href=&quot;#Magic-Virtual-Tables&quot;&gt;Magic Virtual Tables&lt;/a&gt; section below. The &lt;code&gt;how&lt;/code&gt; argument is also stored in the &lt;code&gt;mg_type&lt;/code&gt; field. The value of &lt;code&gt;how&lt;/code&gt; should be chosen from the set of macros &lt;code&gt;PERL_MAGIC_foo&lt;/code&gt; found in</source>
          <target state="translated">sv_magic 함수는 미리 정의 된 &quot;Magic Virtual Table&quot;이 &lt;code&gt;mg_virtual&lt;/code&gt; 필드에 할당되어야 하는지를 결정하는 &lt;code&gt;how&lt;/code&gt; 을 사용 합니다 . 아래의 &lt;a href=&quot;#Magic-Virtual-Tables&quot;&gt;매직 가상 테이블&lt;/a&gt; 섹션을 참조하십시오. &lt;code&gt;how&lt;/code&gt; 인수도에 저장되어 &lt;code&gt;mg_type&lt;/code&gt; 의 필드. 의 값 &lt;code&gt;how&lt;/code&gt; 매크로의 집합에서 선택해야한다는 &lt;code&gt;PERL_MAGIC_foo&lt;/code&gt; 에서 발견</target>
        </trans-unit>
        <trans-unit id="6d632295f69a2e258303de734a1930d293a5d47a" translate="yes" xml:space="preserve">
          <source>The switch statement is called &lt;code&gt;given/when&lt;/code&gt; and only available in perl 5.10 or newer. See &lt;a href=&quot;perlsyn#Switch-Statements&quot;&gt;Switch Statements in perlsyn&lt;/a&gt;.</source>
          <target state="translated">switch 문은 &lt;code&gt;given/when&lt;/code&gt; 호출 되며 perl 5.10 이상에서만 사용할 수 있습니다. &lt;a href=&quot;perlsyn#Switch-Statements&quot;&gt;perlsyn의 스위치 명령문을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="51ab4452b7e8aefb4a20c0fd55e5ee11bfae3081" translate="yes" xml:space="preserve">
          <source>The switch statement is called &lt;code&gt;given&lt;/code&gt;/&lt;code&gt;when&lt;/code&gt; and only available in perl 5.10 or newer. See &lt;a href=&quot;perlsyn#Switch-Statements&quot;&gt;&quot;Switch Statements&quot; in perlsyn&lt;/a&gt;.</source>
          <target state="translated">switch 문은 perl 5.10 이상에서만 &lt;code&gt;given&lt;/code&gt; / &lt;code&gt;when&lt;/code&gt; 호출 됩니다 . &lt;a href=&quot;perlsyn#Switch-Statements&quot;&gt;perlsyn의 &quot;Switch 문&quot;을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="9cc5a13c9ade0909b5ffefb1aee0a9413eb8d3b5" translate="yes" xml:space="preserve">
          <source>The switches above deserve explanation. &lt;code&gt;--no-ff&lt;/code&gt; indicates that even if all your work can be applied linearly against blead, a merge commit should still be prepared. This ensures that all your work will be shown as a side branch, with all its commits merged into the mainstream blead by the merge commit.</source>
          <target state="translated">위의 스위치에 대한 설명이 필요합니다. &lt;code&gt;--no-ff&lt;/code&gt; 는 모든 작업을 blead에 대해 선형 적으로 적용 할 수 있더라도 병합 커밋을 준비해야 함을 나타냅니다. 이렇게하면 모든 작업이 사이드 브랜치로 표시되고 병합 커밋에 의해 모든 커밋이 주류 블리드에 병합됩니다.</target>
        </trans-unit>
        <trans-unit id="9b8e93cb0b51582c675d9a8aa40dc2d0d3cfccab" translate="yes" xml:space="preserve">
          <source>The switches here are -r to recurse into any directories below 't' and -b which adds ./blib/lib and ./blib/arch to Perl's include path so that the tests can find the code they will be testing. If I'm testing a module of which an earlier version is already installed I need to be careful about the include path to make sure I'm not running my tests against the installed version rather than the new one that I'm working on.</source>
          <target state="translated">여기에있는 스위치는 테스트가 테스트 할 코드를 찾을 수 있도록 ./blib/lib 및 ./blib/arch를 Perl의 포함 경로에 추가하는 't'및 -b 아래의 디렉토리로 재귀하는 -r입니다. 이전 버전이 이미 설치된 모듈을 테스트하는 경우 작업중인 새 버전이 아닌 설치된 버전에 대해 테스트를 실행하지 않도록 포함 경로에주의해야합니다.</target>
        </trans-unit>
        <trans-unit id="ea55b37c83e9242fca02717bc11a9fce7934d1e9" translate="yes" xml:space="preserve">
          <source>The symbol between angle brackets indicates the op's type, for example; &amp;lt;2&amp;gt; is a BINOP, &amp;lt;@&amp;gt; a LISTOP, and &amp;lt;#&amp;gt; is a PADOP, which is used in threaded perls. (see &lt;a href=&quot;#OP-class-abbreviations&quot;&gt;&quot;OP class abbreviations&quot;&lt;/a&gt;).</source>
          <target state="translated">꺾쇠 괄호 사이의 기호는 작업 유형을 나타냅니다. 예를 들면 다음과 같습니다. &amp;lt;2&amp;gt;는 BINOP, &amp;lt;@&amp;gt;는 LISTOP, &amp;lt;#&amp;gt;은 스레드 펄에서 사용되는 PADOP입니다. ( &lt;a href=&quot;#OP-class-abbreviations&quot;&gt;&quot;OP 클래스 약어&quot;참조&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="fd4512bd52c00d29ccebf2f597b2a43c4da8833a" translate="yes" xml:space="preserve">
          <source>The symbol between angle brackets indicates the op's type, for example; &amp;lt;2&amp;gt; is a BINOP, &amp;lt;@&amp;gt; a LISTOP, and &amp;lt;#&amp;gt; is a PADOP, which is used in threaded perls. (see &lt;a href=&quot;#OP-class-abbreviations&quot;&gt;OP class abbreviations&lt;/a&gt;).</source>
          <target state="translated">꺾쇠 괄호 사이의 기호는 예를 들어 op의 유형을 나타냅니다. &amp;lt;2&amp;gt;는 BINOP, &amp;lt;@&amp;gt; LISTOP, &amp;lt;#&amp;gt;은 스레드 perls에 사용되는 PADOP입니다. ( &lt;a href=&quot;#OP-class-abbreviations&quot;&gt;OP 클래스 약어&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="2fa8c942f2b2a058230427b77fde679fbccbc45f" translate="yes" xml:space="preserve">
          <source>The symbol table for a package happens to be stored in the hash of that name with two colons appended. The main symbol table's name is thus &lt;code&gt;%main::&lt;/code&gt; , or &lt;code&gt;%::&lt;/code&gt; for short. Likewise the symbol table for the nested package mentioned earlier is named &lt;code&gt;%OUTER::INNER::&lt;/code&gt; .</source>
          <target state="translated">패키지의 심볼 테이블은 두 개의 콜론이 추가 된 해당 이름의 해시에 저장됩니다. 따라서 기본 기호 테이블의 이름은 &lt;code&gt;%main::&lt;/code&gt; 또는 &lt;code&gt;%::&lt;/code&gt; 입니다. 마찬가지로 앞에서 언급 한 중첩 패키지의 심볼 테이블 이름은 &lt;code&gt;%OUTER::INNER::&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="309a96ca92bbc8636f854ec2354e0659976f1abe" translate="yes" xml:space="preserve">
          <source>The symbol table for a package happens to be stored in the hash of that name with two colons appended. The main symbol table's name is thus &lt;code&gt;%main::&lt;/code&gt;, or &lt;code&gt;%::&lt;/code&gt; for short. Likewise the symbol table for the nested package mentioned earlier is named &lt;code&gt;%OUTER::INNER::&lt;/code&gt;.</source>
          <target state="translated">패키지의 기호 테이블은 두 개의 콜론이 추가 된 해당 이름의 해시에 저장됩니다. 따라서 기본 기호 테이블의 이름은 &lt;code&gt;%main::&lt;/code&gt; 또는 줄여서 &lt;code&gt;%::&lt;/code&gt; 입니다. 마찬가지로 앞서 언급 한 중첩 패키지의 기호 테이블 이름은 &lt;code&gt;%OUTER::INNER::&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="d4d8237c3f2b5d66316d69a0012fa0f4c23704f9" translate="yes" xml:space="preserve">
          <source>The symbol table is filled with names looking like line-noise.</source>
          <target state="translated">심볼 테이블은 라인 노이즈처럼 보이는 이름으로 채워져 있습니다.</target>
        </trans-unit>
        <trans-unit id="9284dc458d23c8892508c2adfd2449416ee1df69" translate="yes" xml:space="preserve">
          <source>The symbolic constants for the mode argument are exported by VMS::Stdio by default, and are also exported by the Fcntl package.</source>
          <target state="translated">mode 인수에 대한 기호 상수는 기본적으로 VMS :: Stdio에 의해 내보내지며 Fcntl 패키지에서도 내보내집니다.</target>
        </trans-unit>
        <trans-unit id="c5234fa33c4424920b3b6f455994e7727a2634e0" translate="yes" xml:space="preserve">
          <source>The symbols, ZIP_CM_STORE, ZIP_CM_DEFLATE, ZIP_CM_BZIP2 and ZIP_CM_LZMA are used to select the compression method.</source>
          <target state="translated">ZIP_CM_STORE, ZIP_CM_DEFLATE, ZIP_CM_BZIP2 및 ZIP_CM_LZMA 기호는 압축 방법을 선택하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="b89d5eb1a6608598259ad58b96f51e05f4c62a8d" translate="yes" xml:space="preserve">
          <source>The synonym Strtod() may be used instead.</source>
          <target state="translated">동의어 Strtod ()를 대신 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0e5ab20507b2337eca95f7b51820364382691825" translate="yes" xml:space="preserve">
          <source>The syntactic position falling between a method call and its arguments when using the indirect object invocation syntax. (The slot is distinguished by the absence of a comma between it and the next argument.) &lt;code&gt;STDERR&lt;/code&gt; is in the indirect object slot here:</source>
          <target state="translated">간접 객체 호출 구문을 사용할 때 메소드 호출과 인수 사이의 구문 위치. (슬롯은 슬롯과 다음 인수 사이에 쉼표가없는 것으로 구별됩니다.) &lt;code&gt;STDERR&lt;/code&gt; 은 간접 오브젝트 슬롯에 있습니다.</target>
        </trans-unit>
        <trans-unit id="f8f8b505ce05315e1a17e36787d4eec3e6ea7c76" translate="yes" xml:space="preserve">
          <source>The syntax</source>
          <target state="translated">문법</target>
        </trans-unit>
        <trans-unit id="98466f6b4c50ed9b1b9be5898a44ee0da163a090" translate="yes" xml:space="preserve">
          <source>The syntax &lt;code&gt;(?[ ])&lt;/code&gt; in a regular expression yields a list of single code points, none can be a sequence.</source>
          <target state="translated">정규식 의 구문 &lt;code&gt;(?[ ])&lt;/code&gt; 은 단일 코드 포인트 목록을 생성하며 시퀀스가 ​​될 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="ba4b4939723b8e356e5354c0a4613ac1ca8c7fbd" translate="yes" xml:space="preserve">
          <source>The syntax and behavior is similar to a &lt;code&gt;SKIP: BLOCK&lt;/code&gt; except the tests will be marked as failing but todo. &lt;a href=&quot;Test::Harness&quot;&gt;Test::Harness&lt;/a&gt; will interpret them as passing.</source>
          <target state="translated">구문과 동작은 테스트가 실패하지만 할 일로 표시된다는 점을 제외하면 &lt;code&gt;SKIP: BLOCK&lt;/code&gt; 과 유사합니다 . &lt;a href=&quot;Test::Harness&quot;&gt;Test :: Harness&lt;/a&gt; 는 합격으로 해석합니다.</target>
        </trans-unit>
        <trans-unit id="b260d025f9cb3da5ac539f033e81a2ed933eaba6" translate="yes" xml:space="preserve">
          <source>The syntax and behavior is similar to a &lt;code&gt;SKIP: BLOCK&lt;/code&gt; except the tests will be marked as failing but todo. &lt;a href=&quot;harness&quot;&gt;Test::Harness&lt;/a&gt; will interpret them as passing.</source>
          <target state="translated">구문과 동작은 &lt;code&gt;SKIP: BLOCK&lt;/code&gt; 과 유사 하지만 테스트는 실패하지만 할일로 표시됩니다. &lt;a href=&quot;harness&quot;&gt;Test :: Harness&lt;/a&gt; 는 그것들을 통과 한 것으로 해석합니다.</target>
        </trans-unit>
        <trans-unit id="47cc68a8f32c23223d1563cd08d4fd0cd4cd2e20" translate="yes" xml:space="preserve">
          <source>The syntax for &lt;code&gt;skip&lt;/code&gt; is about the only way it can be, but it's still quite confusing. Just start with the above examples and you'll be okay.</source>
          <target state="translated">&lt;code&gt;skip&lt;/code&gt; 의 구문은 그것이 가능한 유일한 방법에 관한 것이지만 여전히 혼란 스럽습니다. 위의 예제로 시작하면 괜찮을 것입니다.</target>
        </trans-unit>
        <trans-unit id="ad53e9b382fc96ff2b2e55cab8f01b18f6934cd1" translate="yes" xml:space="preserve">
          <source>The syntax for an Input FileGlob is identical to &lt;code&gt;File::Glob&lt;/code&gt; , except for the following</source>
          <target state="translated">입력 FileGlob의 구문 은 다음을 제외하고 &lt;code&gt;File::Glob&lt;/code&gt; 과 동일합니다.</target>
        </trans-unit>
        <trans-unit id="91b339d4084c59a0f56840bad513aaf8cf0b9224" translate="yes" xml:space="preserve">
          <source>The syntax for an Input FileGlob is identical to &lt;code&gt;File::Glob&lt;/code&gt;, except for the following</source>
          <target state="translated">입력 FileGlob의 구문 은 다음을 제외하고 &lt;code&gt;File::Glob&lt;/code&gt; 과 동일합니다.</target>
        </trans-unit>
        <trans-unit id="d238d90126a97e645c3d07a616c57a948aa56c49" translate="yes" xml:space="preserve">
          <source>The syntax for encoding text strings to binary strings is as simple as decoding:</source>
          <target state="translated">텍스트 문자열을 이진 문자열로 인코딩하는 구문은 디코딩만큼 간단합니다.</target>
        </trans-unit>
        <trans-unit id="6de19f7b88c80bb9cdb41dbc1a8bdd69b98ff8b9" translate="yes" xml:space="preserve">
          <source>The syntax of patterns used in Perl pattern matching evolved from those supplied in the Bell Labs Research Unix 8th Edition (Version 8) regex routines. (The code is actually derived (distantly) from Henry Spencer's freely redistributable reimplementation of those V8 routines.)</source>
          <target state="translated">Perl 패턴 일치에 사용되는 패턴의 구문은 Bell Labs Research Unix 8th Edition (버전 8) 정규식 루틴에서 제공되는 구문에서 발전했습니다. (이 코드는 실제로 Henry Spencer의 V8 루틴을 자유롭게 재배포 할 수있는 재 구현에서 (멀리) 파생되었습니다.)</target>
        </trans-unit>
        <trans-unit id="0de2770d6e55eee81f76094997c8b0b61106fb04" translate="yes" xml:space="preserve">
          <source>The syntax:</source>
          <target state="translated">문법 :</target>
        </trans-unit>
        <trans-unit id="6e911200da76df16e0a83de577d8669f75cca2df" translate="yes" xml:space="preserve">
          <source>The sysread(), recv(), syswrite() and send() operators are deprecated on handles that have the &lt;code&gt;:utf8&lt;/code&gt; layer, either explicitly, or implicitly, eg., with the &lt;code&gt;:encoding(UTF-16LE)&lt;/code&gt; layer.</source>
          <target state="translated">sysread (), recv (), syswrite () 및 send () 연산자는 &lt;code&gt;:encoding(UTF-16LE)&lt;/code&gt; 계층 과 같이 명시 적 또는 암시 적으로 &lt;code&gt;:utf8&lt;/code&gt; 계층 이있는 핸들에서 더 이상 사용되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="a6f851731919e85a8b6dbd2464120f7f6baa4b5b" translate="yes" xml:space="preserve">
          <source>The system being designed is large, or is likely to become large.</source>
          <target state="translated">설계중인 시스템이 크거나 커질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a8562e11d0057f4470ed7be8cd68c00d5386166f" translate="yes" xml:space="preserve">
          <source>The system copy routine may also be called directly under VMS and OS/2 as &lt;code&gt;File::Copy::syscopy&lt;/code&gt; (or under VMS as &lt;code&gt;File::Copy::rmscopy&lt;/code&gt; , which is the routine that does the actual work for syscopy).</source>
          <target state="translated">시스템 복사 루틴도 같이 VMS 및 OS / 2에서 직접 호출 할 수 있습니다 &lt;code&gt;File::Copy::syscopy&lt;/code&gt; (또는 VMS에서 같은 &lt;code&gt;File::Copy::rmscopy&lt;/code&gt; , SYSCOPY의 실제 작업을 수행하는 루틴입니다).</target>
        </trans-unit>
        <trans-unit id="b94efe0827258f7a0df5937358145073b3689390" translate="yes" xml:space="preserve">
          <source>The system copy routine may also be called directly under VMS and OS/2 as &lt;code&gt;File::Copy::syscopy&lt;/code&gt; (or under VMS as &lt;code&gt;File::Copy::rmscopy&lt;/code&gt;, which is the routine that does the actual work for syscopy).</source>
          <target state="translated">시스템 복사 루틴은 VMS 및 OS / 2에서 &lt;code&gt;File::Copy::syscopy&lt;/code&gt; 로 직접 호출 할 수도 있습니다 (또는 VMS에서 &lt;code&gt;File::Copy::rmscopy&lt;/code&gt; 에 대한 실제 작업을 수행하는 루틴).</target>
        </trans-unit>
        <trans-unit id="3b60dcb15de0e9f8fb8f2aec0c96f53a958b30c3" translate="yes" xml:space="preserve">
          <source>The system design is already object-oriented.</source>
          <target state="translated">시스템 설계는 이미 객체 지향적입니다.</target>
        </trans-unit>
        <trans-unit id="252893c973435ea38255f9114e6c78b7c2f4935b" translate="yes" xml:space="preserve">
          <source>The system function it replaces can have its static return buffer trashed, not only by a subesequent call to that function, but by a &lt;code&gt;freelocale&lt;/code&gt;, &lt;code&gt;setlocale&lt;/code&gt;, or other locale change. The returned buffer of this function is not changed until the next call to it, so the buffer is never in a trashed state.</source>
          <target state="translated">대체하는 시스템 함수는 해당 함수에 대한 후속 호출뿐만 아니라 &lt;code&gt;freelocale&lt;/code&gt; , &lt;code&gt;setlocale&lt;/code&gt; 또는 기타 로케일 변경으로 인해 정적 리턴 버퍼가 폐기 될 수 있습니다. 이 함수의 반환 된 버퍼는 다음에 호출 할 때까지 변경되지 않으므로 버퍼는 휴지통 상태가 아닙니다.</target>
        </trans-unit>
        <trans-unit id="f2d2b02a34c5f3a2771d92387a8965fe957ed399" translate="yes" xml:space="preserve">
          <source>The system ignores the first line and feeds the program to</source>
          <target state="translated">시스템은 첫 번째 줄을 무시하고 프로그램을</target>
        </trans-unit>
        <trans-unit id="f1eb32227e059ade5c92f6015a4dd65ea3a6bc28" translate="yes" xml:space="preserve">
          <source>The system time is the amount of time the kernel itself spent executing routines, or system calls, on behalf of this process user.</source>
          <target state="translated">시스템 시간은 커널 자체가이 프로세스 사용자 대신 루틴 또는 시스템 호출을 실행하는 데 소요 된 시간입니다.</target>
        </trans-unit>
        <trans-unit id="831ee4615baf52dd07f0a014bffa561cd6b8234d" translate="yes" xml:space="preserve">
          <source>The system time of the null loop might be slightly more than the system time of the loop with the actual code and therefore the difference might end up being &amp;lt; 0.</source>
          <target state="translated">널 (null) 루프의 시스템 시간은 실제 코드와 함께 루프의 시스템 시간보다 약간 더 길 수 있으므로 차이는 &amp;lt;0이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5880c4b2f3b12a5f35ec0374b9437ee3cf2ad712" translate="yes" xml:space="preserve">
          <source>The system's notion of time of day and calendar date is controlled in widely different ways. Don't assume the timezone is stored in &lt;code&gt;$ENV{TZ}&lt;/code&gt; , and even if it is, don't assume that you can control the timezone through that variable. Don't assume anything about the three-letter timezone abbreviations (for example that MST would be the Mountain Standard Time, it's been known to stand for Moscow Standard Time). If you need to use timezones, express them in some unambiguous format like the exact number of minutes offset from UTC, or the POSIX timezone format.</source>
          <target state="translated">시스템의 시간과 달력 날짜의 개념은 크게 다른 방식으로 제어됩니다. 시간대가 &lt;code&gt;$ENV{TZ}&lt;/code&gt; 저장되어 있다고 가정하지 말고 해당 시간대를 사용 하더라도 해당 변수를 통해 시간대를 제어 할 수 있다고 가정하지 마십시오. 3 글자 시간대 약어에 대해서는 아무 것도 가정하지 마십시오 (예 : MST는 산악 표준시, 모스크바 표준시로 알려져 있음). 시간대를 사용해야하는 경우 UTC에서 정확한 분 오프셋 (분) 또는 POSIX 시간대 형식과 같은 모호하지 않은 형식으로 시간대를 표시하십시오.</target>
        </trans-unit>
        <trans-unit id="ed3226a2f2631da1a16aa62735723438d4e491ac" translate="yes" xml:space="preserve">
          <source>The system's notion of time of day and calendar date is controlled in widely different ways. Don't assume the timezone is stored in &lt;code&gt;$ENV{TZ}&lt;/code&gt;, and even if it is, don't assume that you can control the timezone through that variable. Don't assume anything about the three-letter timezone abbreviations (for example that MST would be the Mountain Standard Time, it's been known to stand for Moscow Standard Time). If you need to use timezones, express them in some unambiguous format like the exact number of minutes offset from UTC, or the POSIX timezone format.</source>
          <target state="translated">시스템의 시간 및 달력 날짜 개념은 매우 다양한 방식으로 제어됩니다. 시간대가 &lt;code&gt;$ENV{TZ}&lt;/code&gt; 저장되어 있다고 가정하지 마십시오. 그렇더라도 해당 변수를 통해 시간대를 제어 할 수 있다고 가정하지 마십시오. 세 글자로 된 시간대 약어에 대해 아무 것도 가정하지 마십시오 (예를 들어 MST가 산지 표준시라고 가정하면 모스크바 표준시를 나타내는 것으로 알려져 있습니다). 시간대를 사용해야하는 경우 UTC에서 오프셋 된 정확한 분 수 또는 POSIX 시간대 형식과 같은 명확한 형식으로 표시합니다.</target>
        </trans-unit>
        <trans-unit id="10bc5e79cfd3d40c28f5293903b887866aeb92ec" translate="yes" xml:space="preserve">
          <source>The table below has two columns. The left column contains the &lt;code&gt;\p{}&lt;/code&gt; constructs to look up, possibly preceded by the flags mentioned above; and the right column contains information about them, like a description, or synonyms. The table shows both the single and compound forms for each property that has them. If the left column is a short name for a property, the right column will give its longer, more descriptive name; and if the left column is the longest name, the right column will show any equivalent shortest name, in both single and compound forms if applicable.</source>
          <target state="translated">아래 표에는 두 개의 열이 있습니다. 왼쪽 열에는 &lt;code&gt;\p{}&lt;/code&gt; 구문이 포함되어 있으며 위에서 언급 한 플래그가 앞에 올 수 있습니다. 오른쪽 열에는 설명 또는 동의어와 같은 정보가 포함됩니다. 표에는 각 속성이있는 단일 및 복합 형식이 모두 나와 있습니다. 왼쪽 열이 속성의 짧은 이름 인 경우 오른쪽 열은 길고 설명적인 이름을 제공합니다. 왼쪽 열이 가장 긴 이름 인 경우 오른쪽 열은 해당되는 경우 단일 형식과 복합 형식으로 동등한 짧은 이름을 표시합니다.</target>
        </trans-unit>
        <trans-unit id="1666e90a958abe062ff0c13eedc4273819f1aea6" translate="yes" xml:space="preserve">
          <source>The table file should locate in the</source>
          <target state="translated">테이블 파일은</target>
        </trans-unit>
        <trans-unit id="0f20314df9f35b36eb10a691047b3cd3cf2ffd4f" translate="yes" xml:space="preserve">
          <source>The table in this section lists all the Perl API elements available, sorted by the version in which support starts. This includes all the elements that</source>
          <target state="translated">이 섹션의 표에는 지원이 시작되는 버전별로 정렬 된 사용 가능한 모든 Perl API 요소가 나열되어 있습니다. 여기에는</target>
        </trans-unit>
        <trans-unit id="b1154d069cc05928d8b59c50b5730e339b959183" translate="yes" xml:space="preserve">
          <source>The table of methods for all operations is cached in magic for the symbol table hash for the package. The cache is invalidated during processing of &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; overload&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; overload&lt;/code&gt; , new function definitions, and changes in @ISA.</source>
          <target state="translated">모든 작업에 대한 메소드 테이블은 패키지의 기호 테이블 해시에 대해 마술로 캐시됩니다. &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; overload&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; overload&lt;/code&gt; &lt;a href=&quot;functions/no&quot;&gt;없음&lt;/a&gt; , 새로운 함수 정의 및 @ISA 변경 처리 중에 캐시가 무효화됩니다 .</target>
        </trans-unit>
        <trans-unit id="2c1ebd6c35d6d5b09dedbf5b41acedd8ee971357" translate="yes" xml:space="preserve">
          <source>The table of methods for all operations is cached in magic for the symbol table hash for the package. The cache is invalidated during processing of &lt;code&gt;use overload&lt;/code&gt;, &lt;code&gt;no overload&lt;/code&gt;, new function definitions, and changes in @ISA.</source>
          <target state="translated">모든 작업에 대한 메서드 테이블은 패키지의 기호 테이블 해시를 위해 매직으로 캐시됩니다. 캐시는 &lt;code&gt;use overload&lt;/code&gt; , &lt;code&gt;no overload&lt;/code&gt; , 새 함수 정의 및 @ISA 변경을 처리하는 동안 무효화됩니다 .</target>
        </trans-unit>
        <trans-unit id="dcf2718afd051a8a2171808fbbd533fc26865cc1" translate="yes" xml:space="preserve">
          <source>The table of smartmatches in &lt;a href=&quot;perlop#Smartmatch-Operator&quot;&gt;&quot;Smartmatch Operator&quot; in perlop&lt;/a&gt; is not identical to that proposed by the Raku specification, mainly due to differences between Raku's and Perl 5's data models, but also because the Raku spec has changed since Perl 5 rushed into early adoption.</source>
          <target state="translated">&lt;a href=&quot;perlop#Smartmatch-Operator&quot;&gt;perlop의 &quot;Smartmatch Operator&quot;의 스마트&lt;/a&gt; 매치 표는 Raku 사양에서 제안한 표와 동일하지 않습니다. 주로 Raku와 Perl 5의 데이터 모델 간의 차이 때문이지만 Perl 5가 조기 채택 된 이후 Raku 사양이 변경 되었기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="b36cd501ad88aba2f3b3a0d1d67027c7a1e869d6" translate="yes" xml:space="preserve">
          <source>The table of smartmatches in &lt;a href=&quot;perlop#Smartmatch-Operator&quot;&gt;Smartmatch Operator in perlop&lt;/a&gt; is not identical to that proposed by the Perl 6 specification, mainly due to differences between Perl 6's and Perl 5's data models, but also because the Perl 6 spec has changed since Perl 5 rushed into early adoption.</source>
          <target state="translated">Perlop의 &lt;a href=&quot;perlop#Smartmatch-Operator&quot;&gt;Smartmatch Operator의 스마트&lt;/a&gt; 일치 표는 Perl 6과 Perl 5의 데이터 모델 간의 차이로 인해 Perl 6 사양에서 제안한 것과 동일하지 않지만 Perl 5가 초기 채택으로 급격히 돌진 한 이후로 Perl 6 사양이 변경 되었기 때문에 .</target>
        </trans-unit>
        <trans-unit id="744a22264ceb5e3af0d89371d88c54fa44eb074f" translate="yes" xml:space="preserve">
          <source>The table structure:</source>
          <target state="translated">테이블 구조 :</target>
        </trans-unit>
        <trans-unit id="94ad06074e14c7f30c5f734701604346041b5cbc" translate="yes" xml:space="preserve">
          <source>The tangent</source>
          <target state="translated">탄젠트</target>
        </trans-unit>
        <trans-unit id="9125938896cf0c452742065869d161bf7df834a0" translate="yes" xml:space="preserve">
          <source>The tarball can be created as follows:</source>
          <target state="translated">타르볼은 다음과 같이 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5f3864dd27cd34c2e98d0ec223d6fceecc7c957c" translate="yes" xml:space="preserve">
          <source>The target directory to store the spec files in can be set using &lt;code&gt;dir&lt;/code&gt; as in</source>
          <target state="translated">사양 파일을 저장할 대상 디렉토리는 &lt;code&gt;dir&lt;/code&gt; 을 사용하여 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b87ef1c14b4fb669d5f4570a38dcf5e22aa3e1b3" translate="yes" xml:space="preserve">
          <source>The target is to make OS/2 one of the best supported platform for using/building/developing Perl and</source>
          <target state="translated">목표는 OS / 2를 Perl을 사용 / 빌드 / 개발할 수있는 최고의 지원 플랫폼 중 하나로 만드는 것입니다.</target>
        </trans-unit>
        <trans-unit id="f704785556fc74856ecd269c550a540acda7d08d" translate="yes" xml:space="preserve">
          <source>The target of the OP, or nothing for a nulled OP.</source>
          <target state="translated">OP의 대상이거나 널 (null) 된 OP에 대해서는 없습니다.</target>
        </trans-unit>
        <trans-unit id="d551cba509e623574e29a4be73bb109e3d69062b" translate="yes" xml:space="preserve">
          <source>The template can take a different set of rules per key that is used.</source>
          <target state="translated">템플릿은 사용되는 키마다 다른 규칙 집합을 취할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7dd55749521ef7a1d8d1762bd0dfd93dc2ed7572" translate="yes" xml:space="preserve">
          <source>The template may be any filename with some number of X's appended to it, for example</source>
          <target state="translated">템플릿은 몇 개의 X가 추가 된 파일 이름 일 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="56fadcfb4c1428b721edcda3a997763e93a92ef4" translate="yes" xml:space="preserve">
          <source>The template may be any filename with some number of X's appended to it, for example F. The trailing X's are replaced with unique alphanumeric combinations.</source>
          <target state="translated">템플릿은 파일 이름에 X가 추가 된 파일 이름 (예 : F) 일 수 있습니다. 후행 X는 고유 한 영숫자 조합으로 대체됩니다.</target>
        </trans-unit>
        <trans-unit id="d2a0774e46a5ddeb6abfa59a3643d774d174d289" translate="yes" xml:space="preserve">
          <source>The temporaries stack stores pointers to xVs whose reference counts will be decremented soon.</source>
          <target state="translated">임시 스택은 참조 횟수가 곧 감소 될 xV에 대한 포인터를 저장합니다.</target>
        </trans-unit>
        <trans-unit id="b658a51743ea23f5f90b8615b574c3089e0c4bce" translate="yes" xml:space="preserve">
          <source>The tenth and subsequent priorities are to look in directories named</source>
          <target state="translated">열 번째와 그 이후의 우선 순위는 다음과 같은 이름의 디렉토리를 찾는 것입니다.</target>
        </trans-unit>
        <trans-unit id="527fc2a5f793bc1d57c90fcfdd90ce2b38cfafb9" translate="yes" xml:space="preserve">
          <source>The term &quot;native&quot; does not mean quite as much when we talk about native integers, as it does when native floating point numbers are involved. The only implication of the term &quot;native&quot; on integers is that the limits for the maximal and the minimal supported true integral quantities are close to powers of 2. However, &quot;native&quot; floats have a most fundamental restriction: they may represent only those numbers which have a relatively &quot;short&quot; representation when converted to a binary fraction. For example, 0.9 cannot be represented by a native float, since the binary fraction for 0.9 is infinite:</source>
          <target state="translated">&quot;네이티브 (native)&quot;라는 용어는 네이티브 부동 소수점 숫자가 포함될 때처럼 네이티브 정수에 대해 말할 때 그다지 의미가 없습니다. 정수에서 &quot;네이티브&quot;라는 용어의 유일한 의미는 최대 및 최소 지원되는 실제 적분 수량에 대한 제한이 2의 거듭 제곱에 가깝다는 것입니다. 그러나 &quot;네이티브&quot;플로트에는 가장 근본적인 제한이 있습니다. 이진 분수로 변환 할 때 상대적으로 &quot;짧은&quot;표현을 갖습니다. 예를 들어 0.9의 이진 분수는 무한하므로 0.9는 원시 부동 소수점으로 나타낼 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="60065770d703c59b1d8e19903d480a6c8c3d4ce7" translate="yes" xml:space="preserve">
          <source>The term &quot;railroad normal form&quot; is a bit esoteric, with &quot;syntax diagram/charts&quot;, or &quot;railroad diagram/charts&quot; being more common terms. Nevertheless it provides a useful mental image of a regex program: each node can be thought of as a unit of track, with a single entry and in most cases a single exit point (there are pieces of track that fork, but statistically not many), and the whole forms a layout with a single entry and single exit point. The matching process can be thought of as a car that moves along the track, with the particular route through the system being determined by the character read at each possible connector point. A car can fall off the track at any point but it may only proceed as long as it matches the track.</source>
          <target state="translated">&quot;철도 정규형&quot;이라는 용어는 약간 난해하며 &quot;구문 다이어그램 / 차트&quot;또는 &quot;철도 다이어그램 / 차트&quot;가 더 일반적인 용어입니다. 그럼에도 불구하고 그것은 정규식 프로그램의 유용한 정신적 이미지를 제공합니다 : 각 노드는 단일 엔트리와 대부분의 경우 단일 출구 포인트를 가진 트랙 단위로 생각할 수 있습니다 (포크가 있지만 트랙이 많은 트랙이 있습니다) 전체가 단일 항목과 단일 종료점을 가진 레이아웃을 형성합니다. 매칭 과정은 트랙을 따라 이동하는 차량으로 생각할 수 있으며, 시스템을 통한 특정 경로는 각 가능한 커넥터 지점에서 읽은 문자에 의해 결정됩니다. 자동차는 어느 시점에서나 트랙에서 떨어질 수 있지만 트랙과 일치하는 한 계속 진행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cb8cf5974b1ed2433ffc34db8b95199dcc132ecd" translate="yes" xml:space="preserve">
          <source>The term 'mathemagic' describes the overloaded implementation of mathematical operators. Mathemagical operations raise an issue. Consider the code:</source>
          <target state="translated">'mathemagic'이라는 용어는 수학 연산자의 오버로드 된 구현을 설명합니다. Mathemagical 작업이 문제를 제기합니다. 코드를 고려하십시오 :</target>
        </trans-unit>
        <trans-unit id="eaeae7045f589906beb0ab8c4692ec54095f2a80" translate="yes" xml:space="preserve">
          <source>The term, &quot;Unicode bug&quot; has been applied to an inconsistency with the code points in the &lt;code&gt;Latin-1 Supplement&lt;/code&gt; block, that is, between 128 and 255. Without a locale specified, unlike all other characters or code points, these characters can have very different semantics depending on the rules in effect. (Characters whose code points are above 255 force Unicode rules; whereas the rules for ASCII characters are the same under both ASCII and Unicode rules.)</source>
          <target state="translated">&quot;유니 코드 버그&quot;라는 용어는 &lt;code&gt;Latin-1 Supplement&lt;/code&gt; 블록 의 코드 포인트 , 즉 128과 255 사이 의 불일치에 적용되었습니다 . 로케일을 지정하지 않으면 다른 문자 나 코드 포인트와 달리이 문자는 적용되는 규칙에 따라 매우 다른 의미론. (코드 포인트가 255보다 큰 문자는 유니 코드 규칙을 강제하지만 ASCII 문자 규칙은 ASCII 및 유니 코드 규칙에서 동일합니다.)</target>
        </trans-unit>
        <trans-unit id="694ad9d197b3bccc91651d679f02271b6dd9c6f8" translate="yes" xml:space="preserve">
          <source>The terminal output bit rate (often mistakenly called the baud rate) for this terminal - if not set a warning will be generated and it will be defaulted to 9600.</source>
          <target state="translated">이 터미널에 대한 터미널 출력 비트 전송률 (보통 전송 속도라고도 함)-설정하지 않으면 경고가 생성되고 기본값은 9600입니다.</target>
        </trans-unit>
        <trans-unit id="45cdb3e3cad66807c8dfdf23c9cff4fc7bd36017" translate="yes" xml:space="preserve">
          <source>The terminal type whose termcap entry will be used - if not supplied it will default to $ENV{TERM}: if that is not set then &lt;b&gt;Tgetent&lt;/b&gt; will croak.</source>
          <target state="translated">termcap 항목이 사용될 터미널 유형-제공되지 않으면 $ ENV {TERM}으로 기본 설정 됩니다. 설정되지 않으면 &lt;b&gt;Tgetent&lt;/b&gt; 가 &lt;b&gt;삐걱 거립니다&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="a8d5f39cee7740c7c53d20d14cbf1ad8092c45e0" translate="yes" xml:space="preserve">
          <source>The terminating string may be either an identifier (a word), or some quoted text. An unquoted identifier works like double quotes. There may not be a space between the &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; and the identifier, unless the identifier is explicitly quoted. (If you put a space it will be treated as a null identifier, which is valid, and matches the first empty line.) The terminating string must appear by itself (unquoted and with no surrounding whitespace) on the terminating line.</source>
          <target state="translated">종료 문자열은 식별자 (단어)이거나 인용 된 텍스트 일 ​​수 있습니다. 따옴표없는 식별자는 큰 따옴표처럼 작동합니다. 식별자가 명시 적으로 인용되지 않는 한 &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; 와 식별자 사이에 공백이 없을 수 있습니다 . (공백을 넣으면 유효하지 않은 첫 번째 빈 줄과 일치하는 null 식별자로 처리됩니다.) 종료 문자열은 그 자체로 (따옴표없이 공백 문자없이) 끝나는 줄에 나타나야합니다.</target>
        </trans-unit>
        <trans-unit id="10b4a47dbe9b183e3332ce5dc657e06a6f7d67c1" translate="yes" xml:space="preserve">
          <source>The terminating string may be either an identifier (a word), or some quoted text. An unquoted identifier works like double quotes. There may not be a space between the &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; and the identifier, unless the identifier is explicitly quoted. The terminating string must appear by itself (unquoted and with no surrounding whitespace) on the terminating line.</source>
          <target state="translated">종료 문자열은 식별자 (단어) 또는 일부 인용 텍스트 일 ​​수 있습니다. 인용되지 않은 식별자는 큰 따옴표처럼 작동합니다. 식별자가 명시 적으로 인용되지 않는 한 &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; 와 식별자 사이에 공백이 있어서는 안됩니다 . 종료 문자열은 종료 줄에 그 자체로 표시되어야합니다 (따옴표없이 주변 공백없이).</target>
        </trans-unit>
        <trans-unit id="693f7bb103883c0a728e204ee6c0e2c1249be088" translate="yes" xml:space="preserve">
          <source>The terminator of runtime &lt;code&gt;(?{...})&lt;/code&gt; is found by temporarily switching control to the perl parser, which should stop at the point where the logically balancing terminating &lt;code&gt;}&lt;/code&gt; is found.</source>
          <target state="translated">런타임의 종결 자 &lt;code&gt;(?{...})&lt;/code&gt; 는 일시적으로 제어를 perl 파서로 전환하여 발견됩니다. 이것은 논리적으로 균형을 잡는 종료 &lt;code&gt;}&lt;/code&gt; 가 있는 지점에서 중지해야합니다 .</target>
        </trans-unit>
        <trans-unit id="45074fa74bab84b7b8642e2f2cccf8a44bd5974b" translate="yes" xml:space="preserve">
          <source>The test</source>
          <target state="translated">시험</target>
        </trans-unit>
        <trans-unit id="404700fb40de228f041c8b476423971728a238e9" translate="yes" xml:space="preserve">
          <source>The test harness leaves much to be desired. Patches welcome.</source>
          <target state="translated">테스트 하네스는 원하는만큼 많이 남습니다. 패치는 환영합니다.</target>
        </trans-unit>
        <trans-unit id="a5f877c1b13f5bd28ecef34f68e2dcb7eb31de7b" translate="yes" xml:space="preserve">
          <source>The test name extensions. Defaults to &lt;code&gt;.t&lt;/code&gt;.</source>
          <target state="translated">테스트 이름 확장명. 기본값은 &lt;code&gt;.t&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="6571e20ce9a71fb843fe89c152d8dbe08235f523" translate="yes" xml:space="preserve">
          <source>The test phase is when the distribution's automated test suite is run. Any library that is needed only for testing and not for subsequent use should be listed here.</source>
          <target state="translated">테스트 단계는 배포의 자동화 된 테스트 스위트가 실행되는시기입니다. 테스트에만 필요하고 후속 사용에는 필요하지 않은 모든 라이브러리가 여기에 나열되어야합니다.</target>
        </trans-unit>
        <trans-unit id="18b17a09a74e93fa5e780df81bc80e5b90469686" translate="yes" xml:space="preserve">
          <source>The test suite is much better, but always needs improvement.</source>
          <target state="translated">테스트 스위트는 훨씬 좋지만 항상 개선이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="710c520b5e701804e8b8991b8c559c8c70f62fc8" translate="yes" xml:space="preserve">
          <source>The test will exit with 255.</source>
          <target state="translated">테스트는 255로 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="adc50b89ec0ba50b71ee74cf410505fc2fa0bc3e" translate="yes" xml:space="preserve">
          <source>The testing system is designed to be used by performing a three step process for each test you wish to test. This process starts with using &lt;code&gt;test_out&lt;/code&gt; and &lt;code&gt;test_err&lt;/code&gt; in advance to declare what the testsuite you are testing will output with &lt;a href=&quot;../builder&quot;&gt;Test::Builder&lt;/a&gt; to stdout and stderr.</source>
          <target state="translated">테스트 시스템은 테스트하려는 각 테스트에 대해 3 단계 프로세스를 수행하여 사용하도록 설계되었습니다. 이 프로세스는 &lt;code&gt;test_out&lt;/code&gt; 및 &lt;code&gt;test_err&lt;/code&gt; 를 미리 사용 하여 테스트중인 testsuite가 &lt;a href=&quot;../builder&quot;&gt;Test :: Builder&lt;/a&gt; 를 사용하여 stdout 및 stderr에 출력 할 것을 선언합니다 .</target>
        </trans-unit>
        <trans-unit id="7d184971a14375f569314d2fb6a264dcab98a443" translate="yes" xml:space="preserve">
          <source>The testing system is designed to be used by performing a three step process for each test you wish to test. This process starts with using &lt;code&gt;test_out&lt;/code&gt; and &lt;code&gt;test_err&lt;/code&gt; in advance to declare what the testsuite you are testing will output with &lt;a href=&quot;Test::Builder&quot;&gt;Test::Builder&lt;/a&gt; to stdout and stderr.</source>
          <target state="translated">테스트 시스템은 테스트하려는 각 테스트에 대해 3 단계 프로세스를 수행하여 사용하도록 설계되었습니다. 이 프로세스는 &lt;code&gt;test_out&lt;/code&gt; 및 &lt;code&gt;test_err&lt;/code&gt; 을 미리 사용 하여 테스트중인 testsuite가 &lt;a href=&quot;Test::Builder&quot;&gt;Test :: Builder&lt;/a&gt; 를 사용하여 stdout 및 stderr에 출력 할 내용을 선언하는 것으로 시작됩니다 .</target>
        </trans-unit>
        <trans-unit id="e7d3c8b5f530bcb2e21b05b385528e49c2684bd6" translate="yes" xml:space="preserve">
          <source>The tests</source>
          <target state="translated">테스트</target>
        </trans-unit>
        <trans-unit id="a22b8fe6a3e6e46d5dd177a5cb8828e7b0955e47" translate="yes" xml:space="preserve">
          <source>The tests &lt;code&gt;-b&lt;/code&gt; , &lt;code&gt;-B&lt;/code&gt; , &lt;code&gt;-c&lt;/code&gt; , &lt;code&gt;-C&lt;/code&gt; , &lt;code&gt;-d&lt;/code&gt; , &lt;code&gt;-e&lt;/code&gt; , &lt;code&gt;-f&lt;/code&gt; , &lt;code&gt;-o&lt;/code&gt; , &lt;code&gt;-M&lt;/code&gt; , &lt;code&gt;-s&lt;/code&gt; , &lt;code&gt;-S&lt;/code&gt; , &lt;code&gt;-t&lt;/code&gt; , &lt;code&gt;-T&lt;/code&gt; , and &lt;code&gt;-z&lt;/code&gt; work as advertised. The return values for &lt;code&gt;-r&lt;/code&gt; , &lt;code&gt;-w&lt;/code&gt; , and &lt;code&gt;-x&lt;/code&gt; tell you whether you can actually access the file; this may not reflect the UIC-based file protections. Since real and effective UIC don't differ under VMS, &lt;code&gt;-O&lt;/code&gt; , &lt;code&gt;-R&lt;/code&gt; , &lt;code&gt;-W&lt;/code&gt; , and &lt;code&gt;&lt;a href=&quot;functions/-x&quot;&gt;-X&lt;/a&gt;&lt;/code&gt; are equivalent to &lt;code&gt;-o&lt;/code&gt; , &lt;code&gt;-r&lt;/code&gt; , &lt;code&gt;-w&lt;/code&gt; , and &lt;code&gt;-x&lt;/code&gt; . Similarly, several other tests, including &lt;code&gt;-A&lt;/code&gt; , &lt;code&gt;-g&lt;/code&gt; , &lt;code&gt;-k&lt;/code&gt; , &lt;code&gt;-l&lt;/code&gt; , &lt;code&gt;-p&lt;/code&gt; , and &lt;code&gt;-u&lt;/code&gt; , aren't particularly meaningful under VMS, and the values returned by these tests reflect whatever your CRTL &lt;code&gt;&lt;a href=&quot;functions/stat&quot;&gt;stat()&lt;/a&gt;&lt;/code&gt; routine does to the equivalent bits in the st_mode field. Finally, &lt;code&gt;-d&lt;/code&gt; returns true if passed a device specification without an explicit directory (e.g. &lt;code&gt;DUA1:&lt;/code&gt; ), as well as if passed a directory.</source>
          <target state="translated">테스트 &lt;code&gt;-b&lt;/code&gt; , &lt;code&gt;-B&lt;/code&gt; , &lt;code&gt;-c&lt;/code&gt; , &lt;code&gt;-C&lt;/code&gt; , &lt;code&gt;-d&lt;/code&gt; , &lt;code&gt;-e&lt;/code&gt; , &lt;code&gt;-f&lt;/code&gt; , &lt;code&gt;-o&lt;/code&gt; , &lt;code&gt;-M&lt;/code&gt; , &lt;code&gt;-s&lt;/code&gt; , &lt;code&gt;-S&lt;/code&gt; , &lt;code&gt;-t&lt;/code&gt; , &lt;code&gt;-T&lt;/code&gt; 및 &lt;code&gt;-z&lt;/code&gt; 는 알려진대로 작동합니다. &lt;code&gt;-r&lt;/code&gt; , &lt;code&gt;-w&lt;/code&gt; 및 &lt;code&gt;-x&lt;/code&gt; 의 리턴 값 은 실제로 파일에 액세스 할 수 있는지 여부를 알려줍니다. 이것은 UIC 기반 파일 보호를 반영하지 않을 수 있습니다. 실제적이고 효과적인 UIC는 VMS, &lt;code&gt;-O&lt;/code&gt; , &lt;code&gt;-R&lt;/code&gt; , &lt;code&gt;-W&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;functions/-x&quot;&gt;-X&lt;/a&gt;&lt;/code&gt; 는 &lt;code&gt;-o&lt;/code&gt; , &lt;code&gt;-r&lt;/code&gt; , &lt;code&gt;-w&lt;/code&gt; 및 &lt;code&gt;-x&lt;/code&gt; 와 같습니다. 마찬가지로 &lt;code&gt;-A&lt;/code&gt; , &lt;code&gt;-g&lt;/code&gt; , &lt;code&gt;-k&lt;/code&gt; , &lt;code&gt;-l&lt;/code&gt; , &lt;code&gt;-p&lt;/code&gt; 및 &lt;code&gt;-u&lt;/code&gt; 를 포함한 다른 여러 테스트는 VMS에서 특별히 의미가 없으며 이러한 테스트에서 반환 된 값은 CRTL &lt;code&gt;&lt;a href=&quot;functions/stat&quot;&gt;stat()&lt;/a&gt;&lt;/code&gt; 루틴이 수행하는 모든 작업을 반영합니다.st_mode 필드의 동등한 비트에. 마지막으로 &lt;code&gt;-d&lt;/code&gt; 는 디렉토리를전달한 경우와 같이명시 적 디렉토리 (예 : &lt;code&gt;DUA1:&lt;/code&gt; 없이 장치 사양을 전달한 경우 true를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="9c967d1ae062bd6388a4176bc92989ac103705dc" translate="yes" xml:space="preserve">
          <source>The tests &lt;code&gt;-b&lt;/code&gt;, &lt;code&gt;-B&lt;/code&gt;, &lt;code&gt;-c&lt;/code&gt;, &lt;code&gt;-C&lt;/code&gt;, &lt;code&gt;-d&lt;/code&gt;, &lt;code&gt;-e&lt;/code&gt;, &lt;code&gt;-f&lt;/code&gt;, &lt;code&gt;-o&lt;/code&gt;, &lt;code&gt;-M&lt;/code&gt;, &lt;code&gt;-s&lt;/code&gt;, &lt;code&gt;-S&lt;/code&gt;, &lt;code&gt;-t&lt;/code&gt;, &lt;code&gt;-T&lt;/code&gt;, and &lt;code&gt;-z&lt;/code&gt; work as advertised. The return values for &lt;code&gt;-r&lt;/code&gt;, &lt;code&gt;-w&lt;/code&gt;, and &lt;code&gt;-x&lt;/code&gt; tell you whether you can actually access the file; this may not reflect the UIC-based file protections. Since real and effective UIC don't differ under VMS, &lt;code&gt;-O&lt;/code&gt;, &lt;code&gt;-R&lt;/code&gt;, &lt;code&gt;-W&lt;/code&gt;, and &lt;code&gt;-X&lt;/code&gt; are equivalent to &lt;code&gt;-o&lt;/code&gt;, &lt;code&gt;-r&lt;/code&gt;, &lt;code&gt;-w&lt;/code&gt;, and &lt;code&gt;-x&lt;/code&gt;. Similarly, several other tests, including &lt;code&gt;-A&lt;/code&gt;, &lt;code&gt;-g&lt;/code&gt;, &lt;code&gt;-k&lt;/code&gt;, &lt;code&gt;-l&lt;/code&gt;, &lt;code&gt;-p&lt;/code&gt;, and &lt;code&gt;-u&lt;/code&gt;, aren't particularly meaningful under VMS, and the values returned by these tests reflect whatever your CRTL &lt;code&gt;stat()&lt;/code&gt; routine does to the equivalent bits in the st_mode field. Finally, &lt;code&gt;-d&lt;/code&gt; returns true if passed a device specification without an explicit directory (e.g. &lt;code&gt;DUA1:&lt;/code&gt;), as well as if passed a directory.</source>
          <target state="translated">테스트 &lt;code&gt;-b&lt;/code&gt; , &lt;code&gt;-B&lt;/code&gt; , &lt;code&gt;-c&lt;/code&gt; , &lt;code&gt;-C&lt;/code&gt; , &lt;code&gt;-d&lt;/code&gt; , &lt;code&gt;-e&lt;/code&gt; , &lt;code&gt;-f&lt;/code&gt; , &lt;code&gt;-o&lt;/code&gt; , &lt;code&gt;-M&lt;/code&gt; , &lt;code&gt;-s&lt;/code&gt; , &lt;code&gt;-S&lt;/code&gt; , &lt;code&gt;-t&lt;/code&gt; , &lt;code&gt;-T&lt;/code&gt; 및 &lt;code&gt;-z&lt;/code&gt; 는 광고 된대로 작동합니다. &lt;code&gt;-r&lt;/code&gt; , &lt;code&gt;-w&lt;/code&gt; 및 &lt;code&gt;-x&lt;/code&gt; 의 반환 값 은 실제로 파일에 액세스 할 수 있는지 여부를 알려줍니다. 이것은 UIC 기반 파일 보호를 반영하지 않을 수 있습니다. 실제적이고 효과적인 UIC는 VMS, &lt;code&gt;-O&lt;/code&gt; , &lt;code&gt;-R&lt;/code&gt; , &lt;code&gt;-W&lt;/code&gt; 및 &lt;code&gt;-X&lt;/code&gt; 에서 다르지 않기 때문에 &lt;code&gt;-o&lt;/code&gt; , &lt;code&gt;-r&lt;/code&gt; , &lt;code&gt;-w&lt;/code&gt; 및 &lt;code&gt;-x&lt;/code&gt; 와 동일합니다 . 마찬가지로 &lt;code&gt;-A&lt;/code&gt; , &lt;code&gt;-g&lt;/code&gt; , &lt;code&gt;-k&lt;/code&gt; , &lt;code&gt;-l&lt;/code&gt; , &lt;code&gt;-p&lt;/code&gt; 및 &lt;code&gt;-u&lt;/code&gt; 를 포함한 다른 여러 테스트 는 VMS에서 특별히 의미가 없으며 이러한 테스트에서 반환 된 값은 CRTL &lt;code&gt;stat()&lt;/code&gt; 루틴 이 수행하는 작업을 반영합니다. st_mode 필드의 해당 비트로 마지막으로, &lt;code&gt;-d&lt;/code&gt; 는 명시적인 디렉토리 (예 : &lt;code&gt;DUA1:&lt;/code&gt; 없이 장치 사양을 전달하고 디렉토리를 전달한 경우 true를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="cc12f2671ba906087d5eb6304768a3d9deaa9bcf" translate="yes" xml:space="preserve">
          <source>The tests are wholly and completely skipped. [10] This will work.</source>
          <target state="translated">테스트는 완전히 그리고 완전히 건너 뜁니다. [10] 작동합니다.</target>
        </trans-unit>
        <trans-unit id="d8be2ba8a0a786a9e0b622bcec19843e1f59daa7" translate="yes" xml:space="preserve">
          <source>The tests for this module directly access &lt;a href=&quot;Test::Builder&quot;&gt;Test::Builder&lt;/a&gt; hash keys. Most, if not all of these hash keys have public API methods that could be used instead to avoid the problem.</source>
          <target state="translated">이 모듈의 테스트는 &lt;a href=&quot;Test::Builder&quot;&gt;Test :: Builder&lt;/a&gt; 해시 키에 직접 액세스 합니다. 대부분의 경우 이러한 해시 키에는 문제를 방지하기 위해 대신 사용할 수있는 공용 API 메서드가 있습니다.</target>
        </trans-unit>
        <trans-unit id="4fe750878672d4fb196503a672d7f5b98d0e668b" translate="yes" xml:space="preserve">
          <source>The text &quot;Object Attributes&quot; comprises the heading there. The text in these heading commands can use formatting codes, as seen here:</source>
          <target state="translated">&quot;개체 속성&quot;이라는 텍스트는 제목으로 구성됩니다. 이 표제 명령의 텍스트는 다음과 같이 형식화 코드를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5d105df3ca2da40b603c19669d88379eb24889fa" translate="yes" xml:space="preserve">
          <source>The text content will have tabs already expanded.</source>
          <target state="translated">텍스트 콘텐츠에는 이미 확장 된 탭이 있습니다.</target>
        </trans-unit>
        <trans-unit id="6ca64065f1722f4560dea83450c678ea442c364d" translate="yes" xml:space="preserve">
          <source>The text in the above examples enclosed between the &lt;code&gt;&quot;/&quot;&lt;/code&gt; characters can be just about any regular expression. It is independent of the main pattern, so doesn't share any capturing groups,</source>
          <target state="translated">위의 예에서 &lt;code&gt;&quot;/&quot;&lt;/code&gt; 문자로 묶인 텍스트는 거의 모든 정규식이 될 수 있습니다. 메인 패턴과 독립적이므로 캡처 그룹을 공유하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5846d0e4adec8717ba9914b28f27a3deba7538bf" translate="yes" xml:space="preserve">
          <source>The text matched by the highest used capture group of the last successful search pattern. It is logically equivalent to the highest numbered capture variable (&lt;code&gt;$1&lt;/code&gt;, &lt;code&gt;$2&lt;/code&gt;, ...) which has a defined value.</source>
          <target state="translated">마지막으로 성공한 검색 패턴의 가장 많이 사용 된 캡처 그룹과 일치하는 텍스트입니다. 정의 된 값을 가진 가장 높은 번호의 캡처 변수 ( &lt;code&gt;$1&lt;/code&gt; , &lt;code&gt;$2&lt;/code&gt; , ...) 와 논리적으로 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="422420f7789cdb6ab09e238f60941fefea41ab12" translate="yes" xml:space="preserve">
          <source>The text matched by the last bracket of the last successful search pattern. This is useful if you don't know which one of a set of alternative patterns matched. For example:</source>
          <target state="translated">마지막으로 성공한 검색 패턴의 마지막 대괄호와 일치하는 텍스트입니다. 이는 대체 패턴 세트 중 어느 것이 일치하는지 모르는 경우에 유용합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8d5e558c4e38b1badcb4cca2c007e3208f52adfb" translate="yes" xml:space="preserve">
          <source>The text matched by the used group most-recently closed (i.e. the group with the rightmost closing parenthesis) of the last successful search pattern.</source>
          <target state="translated">마지막으로 성공한 검색 패턴 중 가장 최근에 닫힌 그룹 (즉 가장 오른쪽에 닫는 괄호가있는 그룹)과 일치하는 텍스트입니다.</target>
        </trans-unit>
        <trans-unit id="5e596703d1021b4590de3b141bfc6f8bfaf78ff0" translate="yes" xml:space="preserve">
          <source>The text matched by the used group most-recently closed (i.e. the group with the rightmost closing parenthesis) of the last successful search pattern. This is subtly different from &lt;code&gt;$+&lt;/code&gt;. For example in</source>
          <target state="translated">마지막으로 성공한 검색 패턴의 가장 최근에 닫은 사용 된 그룹 (즉, 가장 오른쪽 닫는 괄호가있는 그룹)과 일치하는 텍스트입니다. 이것은 &lt;code&gt;$+&lt;/code&gt; 미묘하게 다릅니다 . 예를 들어</target>
        </trans-unit>
        <trans-unit id="c1c9727d8e424808f3451a4472d65a7ff102f563" translate="yes" xml:space="preserve">
          <source>The text of a message to print immediately prior to printing the program's usage message.</source>
          <target state="translated">프로그램 사용 메시지를 인쇄하기 직전에 인쇄 할 메시지의 텍스트.</target>
        </trans-unit>
        <trans-unit id="2808389282f74befb5070bb0b9545514e48a6905" translate="yes" xml:space="preserve">
          <source>The text of the Makefile is run through this method before writing to disk. It allows systems a chance to make portability fixes to the Makefile.</source>
          <target state="translated">Makefile의 텍스트는 디스크에 쓰기 전에이 방법을 통해 실행됩니다. 시스템이 Makefile에 이식성을 수정하도록합니다.</target>
        </trans-unit>
        <trans-unit id="fe3785c2d13add392a07d1b360e255c73be9984b" translate="yes" xml:space="preserve">
          <source>The text of the message as a &lt;code&gt;SVpv&lt;/code&gt;.</source>
          <target state="translated">메시지 텍스트는 &lt;code&gt;SVpv&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="4abae05debe0661c57f27b361d90da4ccea7c4db" translate="yes" xml:space="preserve">
          <source>The text/binary issue is covered at length in the Cygwin documentation.</source>
          <target state="translated">텍스트 / 이진 문제는 Cygwin 설명서에서 자세히 다루고 있습니다.</target>
        </trans-unit>
        <trans-unit id="3155c02df4aea0a613a1c72b2a9ac5c7a7efff80" translate="yes" xml:space="preserve">
          <source>The thetas, phis, direction, and distance in the above are all in radians.</source>
          <target state="translated">위의 세타, phi, 방향 및 거리는 모두 라디안입니다.</target>
        </trans-unit>
        <trans-unit id="b1d631fb3ea4c05afea84d61f3fa4b47ab2ddcf3" translate="yes" xml:space="preserve">
          <source>The thing you&amp;rsquo;re working on. Structures like &lt;code&gt;&lt;a href=&quot;functions/while&quot;&gt;while(&amp;lt;&amp;gt;)&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;for&lt;/code&gt; , &lt;code&gt;foreach&lt;/code&gt; , and &lt;code&gt;given&lt;/code&gt; set the topic for you by assigning to &lt;code&gt;$_&lt;/code&gt; , the default (</source>
          <target state="translated">당신이 작업하고있는 것. &lt;code&gt;&lt;a href=&quot;functions/while&quot;&gt;while(&amp;lt;&amp;gt;)&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;for&lt;/code&gt; , &lt;code&gt;foreach&lt;/code&gt; 및 &lt;code&gt;given&lt;/code&gt; 과 같은 구조 는 기본값 인 &lt;code&gt;$_&lt;/code&gt; 에 할당하여 주제를 설정합니다 (</target>
        </trans-unit>
        <trans-unit id="d349e0f7ce22448af1f85ae29fc321760bdcefb3" translate="yes" xml:space="preserve">
          <source>The thing you&amp;rsquo;re working on. Structures like &lt;code&gt;while(&amp;lt;&amp;gt;)&lt;/code&gt;, &lt;code&gt;for&lt;/code&gt;, &lt;code&gt;foreach&lt;/code&gt;, and &lt;code&gt;given&lt;/code&gt; set the topic for you by assigning to &lt;code&gt;$_&lt;/code&gt;, the default (</source>
          <target state="translated">당신이 작업하고있는 것. &lt;code&gt;while(&amp;lt;&amp;gt;)&lt;/code&gt; , &lt;code&gt;for&lt;/code&gt; , &lt;code&gt;foreach&lt;/code&gt; 및 &lt;code&gt;given&lt;/code&gt; 과 같은 구조 는 기본값 인 &lt;code&gt;$_&lt;/code&gt; 에 할당하여 주제를 설정합니다.</target>
        </trans-unit>
        <trans-unit id="9b3293c9c16b6eb4008c2299c5283501a14ee373" translate="yes" xml:space="preserve">
          <source>The third argument ($binmode) will select binary mode if passed as a TRUE value. In binary mode &quot;\n&quot; will be encoded in the same way as any other non-printable character. This ensures that a decoder will end up with exactly the same string whatever line ending sequence it uses. In general it is preferable to use the base64 encoding for binary data; see &lt;a href=&quot;MIME::Base64&quot;&gt;MIME::Base64&lt;/a&gt;.</source>
          <target state="translated">세 번째 인수 ($ binmode)는 TRUE 값으로 전달되면 이진 모드를 선택합니다. 바이너리 모드에서 &quot;\ n&quot;은 인쇄 할 수없는 다른 문자와 동일한 방식으로 인코딩됩니다. 이렇게하면 디코더가 사용하는 줄 끝 시퀀스에 관계없이 정확히 동일한 문자열로 끝납니다. 일반적으로 바이너리 데이터에는 base64 인코딩을 사용하는 것이 좋습니다. &lt;a href=&quot;MIME::Base64&quot;&gt;MIME :: Base64를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d7aa255f6bad43d19c5308997ee1af4d4b4ab78c" translate="yes" xml:space="preserve">
          <source>The third argument ($binmode) will select binary mode if passed as a TRUE value. In binary mode &quot;\n&quot; will be encoded in the same way as any other non-printable character. This ensures that a decoder will end up with exactly the same string whatever line ending sequence it uses. In general it is preferable to use the base64 encoding for binary data; see &lt;a href=&quot;base64&quot;&gt;MIME::Base64&lt;/a&gt;.</source>
          <target state="translated">세 번째 인수 ($ binmode)는 TRUE 값으로 전달되면 이진 모드를 선택합니다. 이진 모드에서 &quot;\ n&quot;은 인쇄 할 수없는 다른 문자와 같은 방식으로 인코딩됩니다. 이를 통해 디코더는 사용하는 줄 끝 시퀀스에 관계없이 정확히 동일한 문자열로 끝납니다. 일반적으로 이진 데이터에는 base64 인코딩을 사용하는 것이 좋습니다. &lt;a href=&quot;base64&quot;&gt;MIME :: Base64를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="cf989e588a5ff932bae69e35a56b32b82b9fac73" translate="yes" xml:space="preserve">
          <source>The third argument &lt;code&gt;\@on_fail&lt;/code&gt;) is an optional set of diagnostics to be sent in the event of a test failure. Unlike with &lt;code&gt;fail()&lt;/code&gt; these diagnostics must be plain strings, data structures are not supported.</source>
          <target state="translated">세 번째 인수 &lt;code&gt;\@on_fail&lt;/code&gt; )은 테스트 실패시 전송되는 선택적 진단 세트입니다. &lt;code&gt;fail()&lt;/code&gt; 과 달리 이러한 진단은 일반 문자열이어야하며 데이터 구조는 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="402137bf9c592f0ce8adeea3685dbc19201507dd" translate="yes" xml:space="preserve">
          <source>The third argument can be a hash reference with options. Note that all options are case-sensitive.</source>
          <target state="translated">세 번째 인수는 옵션이있는 해시 참조 일 수 있습니다. 모든 옵션은 대소 문자를 구분합니다.</target>
        </trans-unit>
        <trans-unit id="d09df4868eb6859f97bcec11bc2fb80a75d17197" translate="yes" xml:space="preserve">
          <source>The third argument is an optional prefix. All files will be tucked away in the directory you specify as prefix. So if you have files 'a' and 'b' in your archive, and you specify 'foo' as prefix, they will be written to the archive as 'foo/a' and 'foo/b'.</source>
          <target state="translated">세 번째 인수는 선택적 접두사입니다. 모든 파일은 접두사로 지정한 디렉토리에 저장됩니다. 따라서 아카이브에 파일 'a'와 'b'가 있고 접두어로 'foo'를 지정하면 아카이브에 'foo / a'와 'foo / b'로 기록됩니다.</target>
        </trans-unit>
        <trans-unit id="f4fe54f58bf6b8a68158e2a28b4c6c3ebee0bf58" translate="yes" xml:space="preserve">
          <source>The third argument is set to TRUE if (and only if) the two operands have been swapped. Perl may do this to ensure that the first argument (&lt;code&gt;$self&lt;/code&gt; ) is an object implementing the overloaded operation, in line with general object calling conventions. For example, if &lt;code&gt;$x&lt;/code&gt; and &lt;code&gt;$y&lt;/code&gt; are &lt;code&gt;Number&lt;/code&gt; s:</source>
          <target state="translated">두 피연산자가 스왑 된 경우 세 번째 인수는 TRUE로 설정됩니다. Perl은 첫 번째 인수 ( &lt;code&gt;$self&lt;/code&gt; )가 일반 오브젝트 호출 규칙에 따라 오버로드 된 조작을 구현하는 오브젝트 인지 확인하기 위해이를 수행 할 수 있습니다 . 예를 들어, &lt;code&gt;$x&lt;/code&gt; 및 &lt;code&gt;$y&lt;/code&gt; 가 &lt;code&gt;Number&lt;/code&gt; 인 경우 :</target>
        </trans-unit>
        <trans-unit id="e0c4e0c0cbbd72e926793186b0870f3e51aaf16b" translate="yes" xml:space="preserve">
          <source>The third argument is set to TRUE if (and only if) the two operands have been swapped. Perl may do this to ensure that the first argument (&lt;code&gt;$self&lt;/code&gt;) is an object implementing the overloaded operation, in line with general object calling conventions. For example, if &lt;code&gt;$x&lt;/code&gt; and &lt;code&gt;$y&lt;/code&gt; are &lt;code&gt;Number&lt;/code&gt;s:</source>
          <target state="translated">세 번째 인수는 두 피연산자가 스왑 된 경우에만 TRUE로 설정됩니다. Perl은 첫 번째 인수 ( &lt;code&gt;$self&lt;/code&gt; )가 일반 객체 호출 규칙에 따라 오버로드 된 작업을 구현하는 객체 인지 확인하기 위해이 작업을 수행 할 수 있습니다 . 예를 들어 &lt;code&gt;$x&lt;/code&gt; 와 &lt;code&gt;$y&lt;/code&gt; 가 &lt;code&gt;Number&lt;/code&gt; s 인 경우 :</target>
        </trans-unit>
        <trans-unit id="b6927ece55a1584561056753f900c2e3751385e3" translate="yes" xml:space="preserve">
          <source>The third form of character class you can use in Perl regular expressions is the bracketed character class. In its simplest form, it lists the characters that may be matched, surrounded by square brackets, like this: &lt;code&gt;[aeiou]&lt;/code&gt; . This matches one of &lt;code&gt;a&lt;/code&gt; , &lt;code&gt;e&lt;/code&gt; , &lt;code&gt;i&lt;/code&gt; , &lt;code&gt;o&lt;/code&gt; or &lt;code&gt;u&lt;/code&gt; . Like the other character classes, exactly one character is matched.* To match a longer string consisting of characters mentioned in the character class, follow the character class with a &lt;a href=&quot;perlre#Quantifiers&quot;&gt;quantifier&lt;/a&gt;. For instance, &lt;code&gt;[aeiou]+&lt;/code&gt; matches one or more lowercase English vowels.</source>
          <target state="translated">Perl 정규식에 사용할 수있는 세 번째 문자 클래스는 대괄호 문자 클래스입니다. 가장 간단한 형식으로, 일치 할 수있는 문자를 대괄호로 묶은 다음과 같이 나열합니다 : &lt;code&gt;[aeiou]&lt;/code&gt; . 이것은 &lt;code&gt;a&lt;/code&gt; , &lt;code&gt;e&lt;/code&gt; , &lt;code&gt;i&lt;/code&gt; , &lt;code&gt;o&lt;/code&gt; 또는 &lt;code&gt;u&lt;/code&gt; 중 하나와 일치 합니다. 다른 문자 클래스와 마찬가지로 정확히 하나의 문자가 일치합니다. * 문자 클래스에서 언급 된 문자로 구성된 더 긴 문자열을 일치 시키려면 문자 클래스를 &lt;a href=&quot;perlre#Quantifiers&quot;&gt;수량&lt;/a&gt; 자로 사용하십시오 . 예를 들어, &lt;code&gt;[aeiou]+&lt;/code&gt; 는 하나 이상의 소문자 영어 모음과 일치합니다.</target>
        </trans-unit>
        <trans-unit id="da916e8511a4663908a2df2d14a8fc11695fa70c" translate="yes" xml:space="preserve">
          <source>The third form of character class you can use in Perl regular expressions is the bracketed character class. In its simplest form, it lists the characters that may be matched, surrounded by square brackets, like this: &lt;code&gt;[aeiou]&lt;/code&gt;. This matches one of &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;e&lt;/code&gt;, &lt;code&gt;i&lt;/code&gt;, &lt;code&gt;o&lt;/code&gt; or &lt;code&gt;u&lt;/code&gt;. Like the other character classes, exactly one character is matched.* To match a longer string consisting of characters mentioned in the character class, follow the character class with a &lt;a href=&quot;perlre#Quantifiers&quot;&gt;quantifier&lt;/a&gt;. For instance, &lt;code&gt;[aeiou]+&lt;/code&gt; matches one or more lowercase English vowels.</source>
          <target state="translated">Perl 정규식에서 사용할 수있는 세 번째 형식의 문자 클래스는 대괄호 문자 클래스입니다. 가장 간단한 형식으로 일치 할 수있는 문자를 나열하고 다음과 같이 대괄호로 묶습니다. &lt;code&gt;[aeiou]&lt;/code&gt; . 이것은 &lt;code&gt;a&lt;/code&gt; , &lt;code&gt;e&lt;/code&gt; , &lt;code&gt;i&lt;/code&gt; , &lt;code&gt;o&lt;/code&gt; 또는 &lt;code&gt;u&lt;/code&gt; 중 하나와 일치 합니다. 다른 문자 클래스와 마찬가지로 정확히 하나의 문자가 일치합니다. * 문자 클래스에 언급 된 문자로 구성된 더 긴 문자열을 일치 시키려면 &lt;a href=&quot;perlre#Quantifiers&quot;&gt;한정 기호를 사용&lt;/a&gt; 하여 문자 클래스를 따르십시오 . 예를 들어, &lt;code&gt;[aeiou]+&lt;/code&gt; 는 하나 이상의 소문자 영어 모음과 일치합니다.</target>
        </trans-unit>
        <trans-unit id="98c965cda02550e370a5b37b87d94e4f8f16189d" translate="yes" xml:space="preserve">
          <source>The third option is to work around the problem by disabling the DB_File completely when build Perl by specifying -Ui_db to Configure, and then using the BerkeleyDB module from CPAN instead of DB_File. The BerkeleyDB works with Berkeley DB versions 2.* or greater.</source>
          <target state="translated">세 번째 옵션은 Perl을 빌드 할 때 -Ui_db를 Configure로 지정한 다음 DB_File 대신 CPAN에서 BerkeleyDB 모듈을 사용하여 DB_File을 완전히 비활성화하여 문제를 해결하는 것입니다. BerkeleyDB는 Berkeley DB 버전 2. * 이상에서 작동합니다.</target>
        </trans-unit>
        <trans-unit id="06ac2659f5a86781c045ab0079857269ceabc456" translate="yes" xml:space="preserve">
          <source>The third parameter is an integer flag, which tells &lt;code&gt;rmscopy&lt;/code&gt; how to handle timestamps. If it is &amp;lt; 0, none of the input file's timestamps are propagated to the output file. If it is &amp;gt; 0, then it is interpreted as a bitmask: if bit 0 (the LSB) is set, then timestamps other than the revision date are propagated; if bit 1 is set, the revision date is propagated. If the third parameter to &lt;code&gt;rmscopy&lt;/code&gt; is 0, then it behaves much like the DCL COPY command: if the name or type of the output file was explicitly specified, then no timestamps are propagated, but if they were taken implicitly from the input filespec, then all timestamps other than the revision date are propagated. If this parameter is not supplied, it defaults to 0.</source>
          <target state="translated">세 번째 매개 변수는 정수 플래그이며, &lt;code&gt;rmscopy&lt;/code&gt; 에게 타임 스탬프 처리 방법을 알려줍니다 . &amp;lt;0이면 입력 파일의 타임 스탬프가 출력 파일로 전파되지 않습니다. &amp;gt; 0이면 비트 마스크로 해석됩니다. 비트 0 (LSB)이 설정되면 개정 날짜 이외의 타임 스탬프가 전파됩니다. 비트 1이 설정되면 개정 날짜가 전파됩니다. &lt;code&gt;rmscopy&lt;/code&gt; 에 대한 세 번째 매개 변수 가 0이면 DCL COPY 명령과 매우 유사하게 작동합니다. 출력 파일의 이름 또는 유형이 명시 적으로 지정된 경우 시간 소인이 전파되지 않지만 입력 파일 스펙에서 내재적으로 가져온 경우 개정 날짜 이외의 모든 타임 스탬프가 전파됩니다. 이 매개 변수가 제공되지 않으면 기본값은 0입니다.</target>
        </trans-unit>
        <trans-unit id="65eff2bc7c7605d4f858e4809838a551a55b2c9c" translate="yes" xml:space="preserve">
          <source>The third parameter of &lt;code&gt;gv_fetchmethod_autoload&lt;/code&gt; determines whether AUTOLOAD lookup is performed if the given method is not present: non-zero means yes, look for AUTOLOAD; zero means no, don't look for AUTOLOAD. Calling &lt;code&gt;gv_fetchmethod&lt;/code&gt; is equivalent to calling &lt;code&gt;gv_fetchmethod_autoload&lt;/code&gt; with a non-zero &lt;code&gt;autoload&lt;/code&gt; parameter.</source>
          <target state="translated">&lt;code&gt;gv_fetchmethod_autoload&lt;/code&gt; 의 세 번째 매개 변수는 주어진 메소드가없는 경우 AUTOLOAD 조회가 수행되는지 여부를 판별합니다. 0이 아닌 경우 예, AUTOLOAD를 찾으십시오. 0은 아니오, 자동로드를 찾지 않음을 의미합니다. &lt;code&gt;gv_fetchmethod&lt;/code&gt; 호출 은 0이 아닌 &lt;code&gt;autoload&lt;/code&gt; 매개 변수로 &lt;code&gt;gv_fetchmethod_autoload&lt;/code&gt; 를 호출하는 것과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="04bad251a051beab258a1b64e282a2e8539b9769" translate="yes" xml:space="preserve">
          <source>The third, even more efficient way is to ape how it is done within the Perl guts:</source>
          <target state="translated">세 번째로 더 효율적인 방법은 Perl 내장 내에서 수행되는 방법을 유인하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="4baba8cca2cc8406f593d4d91d751f6705e4259a" translate="yes" xml:space="preserve">
          <source>The thread ID in which the event was generated.</source>
          <target state="translated">이벤트가 생성 된 스레드 ID입니다.</target>
        </trans-unit>
        <trans-unit id="35817a67488b477301f26017a906bceb6698d6d8" translate="yes" xml:space="preserve">
          <source>The thread ID of the hub the event was sent to.</source>
          <target state="translated">이벤트가 전송 된 허브의 스레드 ID입니다.</target>
        </trans-unit>
        <trans-unit id="79c45ac3b3a9de2cee8656fb9dfb3aeb3d0a968d" translate="yes" xml:space="preserve">
          <source>The threaded Perl build works also on AIX 5.1 but the IBM Perl build (Perl v5.6.0) is not threaded on AIX 5.1.</source>
          <target state="translated">스레드 Perl 빌드는 AIX 5.1에서도 작동하지만 IBM Perl 빌드 (Perl v5.6.0)는 AIX 5.1에서 스레드되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7cda8f2369f06b63a0604a363c17ca6dadb5ab34" translate="yes" xml:space="preserve">
          <source>The three alternative macros are for the most commonly needed validations; they are likely to run somewhat faster than this more general one, as they can be inlined into your code.</source>
          <target state="translated">세 가지 대체 매크로는 가장 일반적으로 필요한 유효성 검사를위한 것입니다. 코드에 인라인 될 수 있기 때문에이보다 일반적인 것보다 다소 빠르게 실행될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5c1bbb696ed6ae965a0f7d9f707a450102369948" translate="yes" xml:space="preserve">
          <source>The three dotted bitwise assignment operators (&lt;code&gt;&amp;amp;.=&lt;/code&gt;&lt;code&gt;|.=&lt;/code&gt;&lt;code&gt;^.=&lt;/code&gt; ) are new in Perl 5.22 and experimental. See &lt;a href=&quot;#Bitwise-String-Operators&quot;&gt;Bitwise String Operators&lt;/a&gt;.</source>
          <target state="translated">세 개의 점으로 구분 된 비트 단위 할당 연산자 ( &lt;code&gt;&amp;amp;.=&lt;/code&gt; &lt;code&gt;|.=&lt;/code&gt; &lt;code&gt;^.=&lt;/code&gt; )는 Perl 5.22의 새로운 기능이며 실험적인 기능입니다. &lt;a href=&quot;#Bitwise-String-Operators&quot;&gt;비트 문자열 연산자를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c23c9e704aad4fb3e2b155575140f095b0d8c904" translate="yes" xml:space="preserve">
          <source>The three dotted bitwise assignment operators (&lt;code&gt;&amp;amp;.=&lt;/code&gt;&lt;code&gt;|.=&lt;/code&gt;&lt;code&gt;^.=&lt;/code&gt;) are new in Perl 5.22. See &lt;a href=&quot;#Bitwise-String-Operators&quot;&gt;&quot;Bitwise String Operators&quot;&lt;/a&gt;.</source>
          <target state="translated">점으로 구분 된 세 개의 비트 할당 연산자 ( &lt;code&gt;&amp;amp;.=&lt;/code&gt; &lt;code&gt;|.=&lt;/code&gt; &lt;code&gt;^.=&lt;/code&gt; )는 Perl 5.22에서 새로 추가되었습니다. &lt;a href=&quot;#Bitwise-String-Operators&quot;&gt;&quot;비트 문자열 연산자&quot;를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="608f375aebf252abe9239c4f7b8a529aa2fe8363" translate="yes" xml:space="preserve">
          <source>The three features of key hashes,</source>
          <target state="translated">키 해시의 세 가지 기능</target>
        </trans-unit>
        <trans-unit id="062af9abb2e5d348e479446852d7c0c45c4b3f85" translate="yes" xml:space="preserve">
          <source>The three invocations of the subroutine all operate in sync. The semaphore, though, makes sure that only one thread is accessing the global variable at once.</source>
          <target state="translated">서브 루틴의 세 가지 호출은 모두 동기화되어 작동합니다. 그러나 세마포어는 한 번에 하나의 스레드 만 전역 변수에 액세스하고 있는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="c211076f27a370be0b7366cd2b652219b05d68b1" translate="yes" xml:space="preserve">
          <source>The three predefined variables $DB_HASH, $DB_BTREE and $DB_RECNO are usually adequate for most applications. If you do need to create extra instances of these objects, constructors are available for each file type.</source>
          <target state="translated">3 개의 사전 정의 된 변수 $ DB_HASH, $ DB_BTREE 및 $ DB_RECNO는 일반적으로 대부분의 응용 프로그램에 적합합니다. 이러한 객체의 추가 인스턴스를 생성해야하는 경우 각 파일 유형에 대해 생성자를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e9c27515a2acd2e5fb4a7aba2f69ec1143808efd" translate="yes" xml:space="preserve">
          <source>The three principal virtues of a programmer are Laziness, Impatience, and Hubris. See the Camel Book for why.</source>
          <target state="translated">프로그래머의 세 가지 주요 미덕은 게으름, 조바심 및 Hubris입니다. 이유는 Camel Book을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="8d0972bf14f371a7ca1ef1bcaa261257cc368602" translate="yes" xml:space="preserve">
          <source>The three variables, api_revision, api_version, and api_subversion, specify the version of the oldest perl binary compatible with the present perl. In a full version string such as</source>
          <target state="translated">api_revision, api_version 및 api_subversion의 세 변수는 현재 perl과 호환되는 가장 오래된 perl 바이너리의 버전을 지정합니다. 정식 버전 문자열과 같은</target>
        </trans-unit>
        <trans-unit id="5f7adaa1232b94661eb586ac3b6e3dfed3cf89b3" translate="yes" xml:space="preserve">
          <source>The three warnings functions, &lt;code&gt;warnings::warn&lt;/code&gt; , &lt;code&gt;warnings::warnif&lt;/code&gt; and &lt;code&gt;warnings::enabled&lt;/code&gt; can optionally take an object reference in place of a category name. In this case the functions will use the class name of the object as the warnings category.</source>
          <target state="translated">세 가지 경고 기능인 &lt;code&gt;warnings::warn&lt;/code&gt; , &lt;code&gt;warnings::warnif&lt;/code&gt; 및 &lt;code&gt;warnings::enabled&lt;/code&gt; 는 선택적으로 범주 이름 대신 객체 참조를 취할 수 있습니다. 이 경우 함수는 객체의 클래스 이름을 경고 범주로 사용합니다.</target>
        </trans-unit>
        <trans-unit id="7318f95ef0833e84e87f8f8ccae92d5cf168ab78" translate="yes" xml:space="preserve">
          <source>The three warnings functions, &lt;code&gt;warnings::warn&lt;/code&gt;, &lt;code&gt;warnings::warnif&lt;/code&gt; and &lt;code&gt;warnings::enabled&lt;/code&gt; can optionally take an object reference in place of a category name. In this case the functions will use the class name of the object as the warnings category.</source>
          <target state="translated">세 가지 경고 함수 인 &lt;code&gt;warnings::warn&lt;/code&gt; , &lt;code&gt;warnings::warnif&lt;/code&gt; 및 &lt;code&gt;warnings::enabled&lt;/code&gt; 는 선택적으로 범주 이름 대신 개체 참조를 사용할 수 있습니다. 이 경우 함수는 경고 범주로 개체의 클래스 이름을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="330a38aeb545f580c0244d785039ed36ba36d545" translate="yes" xml:space="preserve">
          <source>The ticket for this feature is &lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2frt.perl.org%2fTicket%2fDisplay.html%3fid%3d121481&quot;&gt;[perl #121481]&lt;/a&gt;.</source>
          <target state="translated">이 기능에 대한 티켓은 &lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2frt.perl.org%2fTicket%2fDisplay.html%3fid%3d121481&quot;&gt;[perl # 121481]&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="b68d73ad1b59ae384323f9df247206460ebd3566" translate="yes" xml:space="preserve">
          <source>The ticket for this feature is &lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2frt.perl.org%2frt3%2fTicket%2fDisplay.html%3fid%3d116487&quot;&gt;[perl #116487]&lt;/a&gt;.</source>
          <target state="translated">이 기능에 대한 티켓은 &lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2frt.perl.org%2frt3%2fTicket%2fDisplay.html%3fid%3d116487&quot;&gt;[perl # 116487]&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="b8045076fdd60e6523f73b7c70511783c44a65e4" translate="yes" xml:space="preserve">
          <source>The ticket for this feature is &lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2frt.perl.org%2frt3%2fTicket%2fDisplay.html%3fid%3d119313&quot;&gt;[perl #119313]&lt;/a&gt;.</source>
          <target state="translated">이 기능에 대한 티켓은 &lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2frt.perl.org%2frt3%2fTicket%2fDisplay.html%3fid%3d119313&quot;&gt;[perl # 119313]&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="1a16744b674df3a293c07c2c144ffeafe30d93a5" translate="yes" xml:space="preserve">
          <source>The ticket for this feature is &lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2frt.perl.org%2frt3%2fTicket%2fDisplay.html%3fid%3d119315&quot;&gt;[perl #119315]&lt;/a&gt;.</source>
          <target state="translated">이 기능에 대한 티켓은 &lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2frt.perl.org%2frt3%2fTicket%2fDisplay.html%3fid%3d119315&quot;&gt;[perl # 119315]&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="ed1860908f3e196b681653f0d3c4015121aac114" translate="yes" xml:space="preserve">
          <source>The ticket for this feature is &lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2frt.perl.org%2frt3%2fTicket%2fDisplay.html%3fid%3d119317&quot;&gt;[perl #119317]&lt;/a&gt;.</source>
          <target state="translated">이 기능에 대한 티켓은 &lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2frt.perl.org%2frt3%2fTicket%2fDisplay.html%3fid%3d119317&quot;&gt;[perl # 119317]&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="c89e9b1dbbb9968b38d0d3719212d5f4f930d48c" translate="yes" xml:space="preserve">
          <source>The ticket for this feature is &lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2frt.perl.org%2frt3%2fTicket%2fDisplay.html%3fid%3d119437&quot;&gt;[perl #119437]&lt;/a&gt;.</source>
          <target state="translated">이 기능에 대한 티켓은 &lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2frt.perl.org%2frt3%2fTicket%2fDisplay.html%3fid%3d119437&quot;&gt;[perl # 119437]&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="4a1e967726ae4e6415ad56477887e8f2fd56977f" translate="yes" xml:space="preserve">
          <source>The ticket for this feature is &lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2frt.perl.org%2frt3%2fTicket%2fDisplay.html%3fid%3d119451&quot;&gt;[perl #119451]&lt;/a&gt;.</source>
          <target state="translated">이 기능에 대한 티켓은 &lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2frt.perl.org%2frt3%2fTicket%2fDisplay.html%3fid%3d119451&quot;&gt;[perl # 119451]&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="f14154eef095f6d5ad9ed12b7ee560090c8240df" translate="yes" xml:space="preserve">
          <source>The ticket for this feature is &lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2frt.perl.org%2frt3%2fTicket%2fDisplay.html%3fid%3d119453&quot;&gt;[perl #119453]&lt;/a&gt;.</source>
          <target state="translated">이 기능에 대한 티켓은 &lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2frt.perl.org%2frt3%2fTicket%2fDisplay.html%3fid%3d119453&quot;&gt;[perl # 119453]&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="1140c9b87fc789061a9c67b7de5921f54ea0a0a7" translate="yes" xml:space="preserve">
          <source>The ticket for this feature is &lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2frt.perl.org%2frt3%2fTicket%2fDisplay.html%3fid%3d119455&quot;&gt;[perl #119455]&lt;/a&gt;.</source>
          <target state="translated">이 기능에 대한 티켓은 &lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2frt.perl.org%2frt3%2fTicket%2fDisplay.html%3fid%3d119455&quot;&gt;[perl # 119455]&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="f6f307da7b6aa442d7423ca357f21550160d4bb6" translate="yes" xml:space="preserve">
          <source>The ticket for this feature is &lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2frt.perl.org%2frt3%2fTicket%2fDisplay.html%3fid%3d120085&quot;&gt;[perl #120085]&lt;/a&gt;.</source>
          <target state="translated">이 기능에 대한 티켓은 &lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2frt.perl.org%2frt3%2fTicket%2fDisplay.html%3fid%3d120085&quot;&gt;[perl # 120085]&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="2b73333a2d87bb4bdcdf8360f5d380f719aac7b6" translate="yes" xml:space="preserve">
          <source>The ticket for this feature is &lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2frt.perl.org%2frt3%2fTicket%2fDisplay.html%3fid%3d122947&quot;&gt;[perl #122947]&lt;/a&gt;.</source>
          <target state="translated">이 기능에 대한 티켓은 &lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2frt.perl.org%2frt3%2fTicket%2fDisplay.html%3fid%3d122947&quot;&gt;[perl # 122947]&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="25b9d0a99bd226d2ae0ff1a2acdc8ae410a969ec" translate="yes" xml:space="preserve">
          <source>The ticket for this feature is &lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2frt.perl.org%2frt3%2fTicket%2fDisplay.html%3fid%3d123630&quot;&gt;[perl #123630]&lt;/a&gt;.</source>
          <target state="translated">이 기능에 대한 티켓은 &lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2frt.perl.org%2frt3%2fTicket%2fDisplay.html%3fid%3d123630&quot;&gt;[perl # 123630]&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="0769a8451d93e389be7960f58724061e03726c33" translate="yes" xml:space="preserve">
          <source>The ticket for this feature is &lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2frt.perl.org%2frt3%2fTicket%2fDisplay.html%3fid%3d123707&quot;&gt;[perl #123707]&lt;/a&gt;.</source>
          <target state="translated">이 기능에 대한 티켓은 &lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2frt.perl.org%2frt3%2fTicket%2fDisplay.html%3fid%3d123707&quot;&gt;[perl # 123707]&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="4152408e418529cff3fa9a89a90fa02a4c71e407" translate="yes" xml:space="preserve">
          <source>The ticket for this feature is &lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2frt.perl.org%3a443%2frt3%2fTicket%2fDisplay.html%3fid%3d120162&quot;&gt;[perl #120162]&lt;/a&gt;.</source>
          <target state="translated">이 기능에 대한 티켓은 &lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2frt.perl.org%3a443%2frt3%2fTicket%2fDisplay.html%3fid%3d120162&quot;&gt;[perl # 120162]&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="896c7c2fe4064687353e3dfbb412d579a6d56aea" translate="yes" xml:space="preserve">
          <source>The tie() function binds a variable to a class (package) that will provide the implementation for access methods for that variable. Once this magic has been performed, accessing a tied variable automatically triggers method calls in the proper class. The complexity of the class is hidden behind magic methods calls. The method names are in ALL CAPS, which is a convention that Perl uses to indicate that they're called implicitly rather than explicitly--just like the BEGIN() and END() functions.</source>
          <target state="translated">tie () 함수는 변수를 클래스 (패키지)에 바인딩하여 해당 변수의 액세스 메소드에 대한 구현을 제공합니다. 이 마법이 수행되면 연결된 변수에 액세스하면 적절한 클래스에서 메서드 호출이 자동으로 트리거됩니다. 클래스의 복잡성은 마술 메서드 호출 뒤에 숨겨져 있습니다. 메소드 이름은 ALL CAPS에 있으며, 이는 Perl이 BEGIN () 및 END () 함수와 같이 명시 적으로가 아니라 내재적으로 호출되었음을 나타 내기 위해 사용하는 규칙입니다.</target>
        </trans-unit>
        <trans-unit id="0cc71f8e2650c3f7dc36c81297b9a74bd871dbac" translate="yes" xml:space="preserve">
          <source>The tighter rules given above for the single form apply to everything to the right of the colon or equals; the looser rules still apply to everything to the left.</source>
          <target state="translated">단일 형식에 대해 위에 주어진 더 엄격한 규칙은 콜론 또는 같음의 오른쪽에있는 모든 항목에 적용됩니다. 느슨한 규칙은 여전히 ​​왼쪽의 모든 것에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="2ae79bd4ddb1c94445f10f56348d3008d5501006" translate="yes" xml:space="preserve">
          <source>The time at which the program began running, in seconds since the epoch (beginning of 1970). The values returned by the &lt;b&gt;-M&lt;/b&gt;, &lt;b&gt;-A&lt;/b&gt;, and &lt;b&gt;-C&lt;/b&gt; filetests are based on this value.</source>
          <target state="translated">신기원 이후 (1970 년 초) 프로그램이 실행 된 시간 (초) &lt;b&gt;-M&lt;/b&gt; , &lt;b&gt;-A&lt;/b&gt; 및 &lt;b&gt;-C&lt;/b&gt; 파일 테스트 에서 리턴 된 값 은이 값을 기반으로합니다.</target>
        </trans-unit>
        <trans-unit id="850e579e5bd369cd341c43e0bd12ab77ec41d87f" translate="yes" xml:space="preserve">
          <source>The time has been cut in half, which is a respectable speed improvement by any standard. Naturally, it is important to check the output is consistent with the first program run, this is where the Unix system &lt;code&gt;cksum&lt;/code&gt; utility comes in.</source>
          <target state="translated">시간이 절반으로 단축되었으며 이는 표준에 따라 상당한 속도 향상입니다. 당연히, 출력이 첫 번째 프로그램 실행과 일치하는지 확인하는 것이 중요합니다. 이것은 Unix 시스템 &lt;code&gt;cksum&lt;/code&gt; 유틸리티가 들어오는 곳입니다.</target>
        </trans-unit>
        <trans-unit id="b516aafa3dbd5e537bbd8654d3807aa023edea27" translate="yes" xml:space="preserve">
          <source>The time it takes varies depending on how fast your machine is and how large your encoding is. Unless you are working on something big like euc-tw, it won't take too long.</source>
          <target state="translated">소요 시간은 시스템 속도 및 인코딩 크기에 따라 다릅니다. euc-tw와 같은 큰 작업을 수행하지 않으면 시간이 오래 걸리지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e4a773ca459be08fb127884cfab114e154432eff" translate="yes" xml:space="preserve">
          <source>The time of the null loop (a loop with the same number of rounds but empty loop body) is subtracted from the time of the real loop.</source>
          <target state="translated">널 루프의 시간 (라운드 수는 동일하지만 빈 루프 본문이있는 루프)은 실제 루프의 시간에서 뺍니다.</target>
        </trans-unit>
        <trans-unit id="b6a2ce725119cbf8ac82ed9014cf15ca7bd90e68" translate="yes" xml:space="preserve">
          <source>The time returned also includes the process times of the terminated child processes for which wait() has been executed. This value is somewhat like the second value returned by the times() of core Perl, but not necessarily identical. Note that due to backward compatibility limitations the returned value may wrap around at about 2147 seconds or at about 36 minutes.</source>
          <target state="translated">리턴 된 시간에는 또한 wait ()가 실행 된 종료 된 하위 프로세스의 프로세스 시간도 포함됩니다. 이 값은 코어 Perl의 times ()에 의해 리턴 된 두 번째 값과 다소 같지만 반드시 동일하지는 않습니다. 이전 버전과의 호환성 제한으로 인해 반환 된 값은 약 2147 초 또는 약 36 분에 줄 바꿈 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0d1626bdb98ca3cc408f22b06c2161e7fe233ac0" translate="yes" xml:space="preserve">
          <source>The time when Perl is actually doing what your code says to do, as opposed to the earlier period of time when it was trying to figure out whether what you said made any sense whatsoever, which is &lt;b&gt;compile time&lt;/b&gt;.</source>
          <target state="translated">펄이 실제로 말한 내용이 무엇인지 이해하려고 시도했던 초기의 시간과 반대로, 펄이 실제로 코드에서 말한 것을 수행하는 시간은 &lt;b&gt;컴파일 시간&lt;/b&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="84f0e5475a9de884cf21f0b5087fb4edeef00da2" translate="yes" xml:space="preserve">
          <source>The time when Perl is trying to make sense of your code, as opposed to when it thinks it knows what your code means and is merely trying to do what it thinks your code says to do, which is &lt;b&gt;runtime&lt;/b&gt;.</source>
          <target state="translated">펄이 코드의 의미를 알고 있다고 생각하는 것과 반대로 펄이 코드를 이해하려고 시도하는 시간은 단지 코드가 무엇을하는지 생각하는 것, 즉 &lt;b&gt;런타임&lt;/b&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="2e4f067abc3cb37a82d1ce3a350c4ed5ac55d47a" translate="yes" xml:space="preserve">
          <source>The timeout in the [PKG] can be specified as zero to effect a &quot;poll&quot;, but you shouldn't do that because a new IO::Select object will be created behind the scenes just to do the single poll. This is horrendously inefficient. Use rather true select() with a zero timeout on the handle, or non-blocking IO.</source>
          <target state="translated">&quot;폴 (poll)&quot;에 영향을주기 위해 [PKG]의 시간 초과를 0으로 지정할 수 있지만, 단일 폴링을 수행하기 위해 새로운 IO :: Select 객체가 씬 뒤에 생성되므로 그렇게하지 않아야합니다. 이것은 엄청나게 비효율적입니다. 핸들에서 제한 시간이 0이거나 비 차단 IO 인 경우 오히려 true select ()를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="538790731acb7259f937f6ff4a2bbf78b24054c5" translate="yes" xml:space="preserve">
          <source>The timeout may be a number of seconds relative to the current time (e.g., 5 seconds from when the call is made), or may be an absolute timeout in</source>
          <target state="translated">타임 아웃은 현재 시간에 상대적인 초 수 (예를 들어, 호출 된 시점으로부터 5 초)이거나, 또는</target>
        </trans-unit>
        <trans-unit id="ff980bdd72965b0a57183b47bf6c39d63a6adebb" translate="yes" xml:space="preserve">
          <source>The timeout value, in seconds, for this socket connection. How exactly this value is utilized is defined in the socket domain subclasses that make use of the value.</source>
          <target state="translated">이 소켓 연결에 대한 제한 시간 값 (초)입니다. 이 값이 정확히 어떻게 활용되는지는 값을 사용하는 소켓 도메인 하위 클래스에 정의되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="fd8fbd616a78a90070ef718270fee035f94b0bad" translate="yes" xml:space="preserve">
          <source>The timing is done using time(3) and times(3).</source>
          <target state="translated">타이밍은 time (3) 및 times (3)을 사용하여 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="bfc27e045cf8c436a59465851692c98d92afa4eb" translate="yes" xml:space="preserve">
          <source>The title of this section indicates the second problem you may run into sooner or later when you pack C structures. If the function you intend to call expects a, say, &lt;code&gt;void *&lt;/code&gt; value, you</source>
          <target state="translated">이 섹션의 제목은 C 구조를 포장 할 때 조만간 발생할 수있는 두 번째 문제를 나타냅니다. 호출하려는 함수에 &lt;code&gt;void *&lt;/code&gt; 값이 필요한 경우</target>
        </trans-unit>
        <trans-unit id="3aeea9af350571abf85e25c4751ee40203e9d46b" translate="yes" xml:space="preserve">
          <source>The top level documentation about Perl regular expressions is found in &lt;a href=&quot;perlre&quot;&gt;perlre&lt;/a&gt;.</source>
          <target state="translated">Perl 정규식에 대한 최상위 문서는 &lt;a href=&quot;perlre&quot;&gt;perlre에&lt;/a&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="3205e679e2f0bb1ae1342389bae87dd20bedcfd5" translate="yes" xml:space="preserve">
          <source>The top node in the tree is &lt;code&gt;[ 'Document', \%attributes,
&lt;i&gt;...subnodes...&lt;/i&gt; ]&lt;/code&gt;</source>
          <target state="translated">트리의 최상위 노드는 &lt;code&gt;[ 'Document', \%attributes, &lt;i&gt;...subnodes...&lt;/i&gt; ]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="37995bec6dd9b8643c48818f0b81e11787b543cc" translate="yes" xml:space="preserve">
          <source>The total elapsed times the test took to run, in seconds from the epoch..</source>
          <target state="translated">신기원에서 초 단위로 테스트 실행에 소요 된 총 경과 시간 ..</target>
        </trans-unit>
        <trans-unit id="1c62e4162c4c89e197d0fdd84f0911b0a91d8950" translate="yes" xml:space="preserve">
          <source>The total number of comparisons is equal to the sum of the squares of the number of entries in each bucket. For a random hash of &lt;code&gt;&amp;lt;n&lt;/code&gt; &amp;gt; keys into &lt;code&gt;&amp;lt;k&lt;/code&gt; &amp;gt; buckets, the expected value is:</source>
          <target state="translated">총 비교 수는 각 버킷에있는 항목 수의 제곱의 합과 같습니다. &lt;code&gt;&amp;lt;k&lt;/code&gt; &amp;gt; 버킷에 대한 &lt;code&gt;&amp;lt;n&lt;/code&gt; &amp;gt; 키 의 임의 해시의 예상 값은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="dd7a1cc091879ad89ef24fb0639fcf0e894d70ac" translate="yes" xml:space="preserve">
          <source>The total number of comparisons is equal to the sum of the squares of the number of entries in each bucket. For a random hash of &lt;code&gt;&amp;lt;n&lt;/code&gt;&amp;gt; keys into &lt;code&gt;&amp;lt;k&lt;/code&gt;&amp;gt; buckets, the expected value is:</source>
          <target state="translated">총 비교 수는 각 버킷의 항목 수 제곱의 합과 같습니다. &lt;code&gt;&amp;lt;n&lt;/code&gt; &amp;gt; 키를 &lt;code&gt;&amp;lt;k&lt;/code&gt; &amp;gt; 버킷 으로 무작위 해시하는 경우 예상 값은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d4c2502de58f3e2d86d4adebf37cdce84d5b9f9b" translate="yes" xml:space="preserve">
          <source>The total time it took for the test to run, in seconds. If &lt;code&gt;Time::HiRes&lt;/code&gt; is available, it will have finer granularity.</source>
          <target state="translated">테스트 실행에 소요 된 총 시간 (초)입니다. 경우 &lt;code&gt;Time::HiRes&lt;/code&gt; 가능하며, 그것은 치밀하게있을 것이다.</target>
        </trans-unit>
        <trans-unit id="1b3a565887dd69be936761de4d497f57b4dfa910" translate="yes" xml:space="preserve">
          <source>The tradeoff is that one needs to calculate the number of return values in advance (though overextending the stack will not typically hurt anything but memory consumption).</source>
          <target state="translated">트레이드 오프는 반환 값의 수를 미리 계산해야한다는 것입니다 (스택을 과도하게 확장해도 일반적으로 메모리 소비 외에 다른 것은 없습니다).</target>
        </trans-unit>
        <trans-unit id="02dc2cb0935e5c48d56deb5ed1a283c1991198d6" translate="yes" xml:space="preserve">
          <source>The traditional &quot;0&quot;, &quot;1&quot;, and &quot;2&quot; MODEs are implemented with different numeric values on some systems. The flags exported by &lt;code&gt;Fcntl&lt;/code&gt; (O_RDONLY, O_WRONLY, O_RDWR) should work everywhere though. (Mac OS, OS/390)</source>
          <target state="translated">전통적인 &quot;0&quot;, &quot;1&quot;및 &quot;2&quot;모드는 일부 시스템에서 다른 숫자 값으로 구현됩니다. &lt;code&gt;Fcntl&lt;/code&gt; (O_RDONLY, O_WRONLY, O_RDWR)에서 내 보낸 플래그 는 어디에서나 작동해야합니다. (Mac OS, OS / 390)</target>
        </trans-unit>
        <trans-unit id="edec44b15608ad1c090140c537934ec3a77ab750" translate="yes" xml:space="preserve">
          <source>The traditional one has it followed by a name enclosed in braces, meaning the character (or sequence of characters) given by that name. Thus &lt;code&gt;\N{ASTERISK}&lt;/code&gt; is another way of writing &lt;code&gt;*&lt;/code&gt; , valid in both double-quoted strings and regular expression patterns. In patterns, it doesn't have the meaning an unescaped &lt;code&gt;*&lt;/code&gt; does.</source>
          <target state="translated">전통적인 이름 뒤에는 중괄호로 묶인 이름이 붙습니다. 이는 해당 이름으로 지정된 문자 (또는 문자 시퀀스)를 의미합니다. 따라서 &lt;code&gt;\N{ASTERISK}&lt;/code&gt; 는 &lt;code&gt;*&lt;/code&gt; 를 쓰는 또 다른 방법으로 , 큰 따옴표로 묶인 문자열과 정규식 패턴 모두에 유효합니다. 패턴에서는 의미 이스케이프가없는 &lt;code&gt;*&lt;/code&gt; 는 않습니다.</target>
        </trans-unit>
        <trans-unit id="aa46fd7f5efd6b7870b67ed7954394e54344b140" translate="yes" xml:space="preserve">
          <source>The traditional one has it followed by a name enclosed in braces, meaning the character (or sequence of characters) given by that name. Thus &lt;code&gt;\N{ASTERISK}&lt;/code&gt; is another way of writing &lt;code&gt;*&lt;/code&gt;, valid in both double-quoted strings and regular expression patterns. In patterns, it doesn't have the meaning an unescaped &lt;code&gt;*&lt;/code&gt; does.</source>
          <target state="translated">전통적인 것에는 그 뒤에 중괄호로 묶인 이름이 있는데, 이는 그 이름으로 주어진 문자 (또는 일련의 문자)를 의미합니다. 따라서 &lt;code&gt;\N{ASTERISK}&lt;/code&gt; 는 &lt;code&gt;*&lt;/code&gt; 를 쓰는 또 다른 방법으로 , 큰 따옴표로 묶인 문자열과 정규식 패턴 모두에서 유효합니다. 패턴에서는 이스케이프 처리되지 않은 &lt;code&gt;*&lt;/code&gt; 가 의미하는 바가 없습니다 .</target>
        </trans-unit>
        <trans-unit id="cf50a6157f8b6c5d609d11261410355088e7eb85" translate="yes" xml:space="preserve">
          <source>The transitional compilation environment is obtained with the following compiler and linker flags:</source>
          <target state="translated">전이 컴파일 환경은 다음 컴파일러 및 링커 플래그를 사용하여 얻습니다.</target>
        </trans-unit>
        <trans-unit id="5205d19a729f5413830c865ec36ec411e1524d36" translate="yes" xml:space="preserve">
          <source>The transliteration operator. Same as &lt;a href=&quot;#tr%2F%2F%2F&quot;&gt;&lt;code&gt;tr///&lt;/code&gt;&lt;/a&gt;. See &lt;a href=&quot;perlop#Quote-Like-Operators&quot;&gt;&quot;Quote-Like Operators&quot; in perlop&lt;/a&gt;.</source>
          <target state="translated">음역 연산자입니다. &lt;a href=&quot;#tr%2F%2F%2F&quot;&gt; &lt;code&gt;tr///&lt;/code&gt; &lt;/a&gt; 와 동일합니다 . &lt;a href=&quot;perlop#Quote-Like-Operators&quot;&gt;perlop의 &quot;유사 견적 연산자&quot;를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b9a818fdcd409263a5793457d26567f24ef801cf" translate="yes" xml:space="preserve">
          <source>The transliteration operator. Same as &lt;a href=&quot;#y%2F%2F%2F&quot;&gt;&lt;code&gt;y///&lt;/code&gt;&lt;/a&gt;. See &lt;a href=&quot;perlop#Quote-Like-Operators&quot;&gt;&quot;Quote-Like Operators&quot; in perlop&lt;/a&gt;.</source>
          <target state="translated">음역 연산자입니다. &lt;a href=&quot;#y%2F%2F%2F&quot;&gt; &lt;code&gt;y///&lt;/code&gt; &lt;/a&gt; 와 동일합니다 . &lt;a href=&quot;perlop#Quote-Like-Operators&quot;&gt;perlop의 &quot;유사 견적 연산자&quot;를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="7383cd567e6253ea6210a9db604e2fa9e5e4632a" translate="yes" xml:space="preserve">
          <source>The transliteration operator. Same as &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr///&lt;/a&gt;&lt;/code&gt;. See &lt;a href=&quot;perlop#Quote-Like-Operators&quot;&gt;Quote-Like Operators in perlop&lt;/a&gt;.</source>
          <target state="translated">음역 연산자 &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr///&lt;/a&gt;&lt;/code&gt; 와 동일합니다 . &lt;a href=&quot;perlop#Quote-Like-Operators&quot;&gt;perlop의 인용 부호 연산자를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e96d614d57d8ccc80741217a9adfc3a85457d070" translate="yes" xml:space="preserve">
          <source>The transliteration operator. Same as &lt;code&gt;&lt;a href=&quot;functions/y&quot;&gt;y///&lt;/a&gt;&lt;/code&gt;. See &lt;a href=&quot;perlop#Quote-Like-Operators&quot;&gt;Quote-Like Operators in perlop&lt;/a&gt;.</source>
          <target state="translated">음역 연산자 &lt;code&gt;&lt;a href=&quot;functions/y&quot;&gt;y///&lt;/a&gt;&lt;/code&gt; 와 같습니다 . &lt;a href=&quot;perlop#Quote-Like-Operators&quot;&gt;perlop의 인용 부호 연산자를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="4178c59a00064af8220ead2c08c98e1676579390" translate="yes" xml:space="preserve">
          <source>The transliteration operator. Same as &lt;code&gt;&lt;a href=&quot;tr&quot;&gt;tr///&lt;/a&gt;&lt;/code&gt;. See &lt;a href=&quot;../perlop#Quote-Like-Operators&quot;&gt;Quote-Like Operators in perlop&lt;/a&gt;.</source>
          <target state="translated">음역 연산자 &lt;code&gt;&lt;a href=&quot;tr&quot;&gt;tr///&lt;/a&gt;&lt;/code&gt; 와 동일합니다 . &lt;a href=&quot;../perlop#Quote-Like-Operators&quot;&gt;perlop의 인용 부호 연산자를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ea9a92782ae9df97b0632f112e4b5544a1a9028b" translate="yes" xml:space="preserve">
          <source>The transliteration operator. Same as &lt;code&gt;&lt;a href=&quot;y&quot;&gt;y///&lt;/a&gt;&lt;/code&gt;. See &lt;a href=&quot;../perlop#Quote-Like-Operators&quot;&gt;Quote-Like Operators in perlop&lt;/a&gt;.</source>
          <target state="translated">음역 연산자 &lt;code&gt;&lt;a href=&quot;y&quot;&gt;y///&lt;/a&gt;&lt;/code&gt; 와 같습니다 . &lt;a href=&quot;../perlop#Quote-Like-Operators&quot;&gt;perlop의 인용 부호 연산자를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="75ab4f7335b924ba00dcfa6684ad7ab9b56afe36" translate="yes" xml:space="preserve">
          <source>The trap and untrap methods are synonyms for deny and permit respectfully.</source>
          <target state="translated">트랩 및 언 트랩 방법은 거부의 동의어이며 정중하게 허용합니다.</target>
        </trans-unit>
        <trans-unit id="79edf12630cd230667f23adf7c1c02295b7aaf31" translate="yes" xml:space="preserve">
          <source>The treatment of more than one physical &lt;b&gt;line&lt;/b&gt; as a single logical line. &lt;b&gt;Makefile&lt;/b&gt; lines are continued by putting a backslash before the &lt;b&gt;newline&lt;/b&gt;. Mail headers, as defined by RFC 822, are continued by putting a space or tab</source>
          <target state="translated">둘 이상의 물리적 &lt;b&gt;회선&lt;/b&gt; 을 단일 논리적 회선으로 처리합니다. &lt;b&gt;개행&lt;/b&gt; 앞에 백 슬래시를 넣어 &lt;b&gt;Makefile&lt;/b&gt; 행을 계속합니다 . RFC 822에 정의 된대로 메일 헤더는 공백이나 탭을 넣어 계속됩니다.&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="416e0656b5d6eca80f77db061d8df87eef2d675e" translate="yes" xml:space="preserve">
          <source>The tree is created by the compiler while</source>
          <target state="translated">트리는 컴파일러에 의해 생성됩니다</target>
        </trans-unit>
        <trans-unit id="751a409fc8b6dd72130af7dcf107013d6a066c03" translate="yes" xml:space="preserve">
          <source>The trick in this task is to find the directory. Before your script does anything else (such as a &lt;code&gt;&lt;a href=&quot;functions/chdir&quot;&gt;chdir&lt;/a&gt;&lt;/code&gt;), you can get the current working directory with the &lt;code&gt;Cwd&lt;/code&gt; module, which comes with Perl:</source>
          <target state="translated">이 작업의 요령은 디렉토리를 찾는 것입니다. 스크립트가 &lt;code&gt;&lt;a href=&quot;functions/chdir&quot;&gt;chdir&lt;/a&gt;&lt;/code&gt; 과 같은 다른 작업을 수행하기 전에 Perl과 함께 제공되는 &lt;code&gt;Cwd&lt;/code&gt; 모듈을 사용하여 현재 작업 디렉토리를 얻을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="37e82dc52d548373adee493d4ea5761e5091b906" translate="yes" xml:space="preserve">
          <source>The trick in this task is to find the directory. Before your script does anything else (such as a &lt;code&gt;chdir&lt;/code&gt;), you can get the current working directory with the &lt;code&gt;Cwd&lt;/code&gt; module, which comes with Perl:</source>
          <target state="translated">이 작업의 트릭은 디렉토리를 찾는 것입니다. 스크립트가 다른 작업 (예 : &lt;code&gt;chdir&lt;/code&gt; )을 수행하기 전에 Perl과 함께 제공되는 &lt;code&gt;Cwd&lt;/code&gt; 모듈을 사용하여 현재 작업 디렉토리를 가져올 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f5f4f31af96f44cb48b6403e792709ecc6d53b8e" translate="yes" xml:space="preserve">
          <source>The trick is that if you read a &lt;code&gt;BOM&lt;/code&gt; , you will know the byte order, since if it was written on a big-endian platform, you will read the bytes &lt;code&gt;0xFE 0xFF&lt;/code&gt;, but if it was written on a little-endian platform, you will read the bytes &lt;code&gt;0xFF 0xFE&lt;/code&gt;. (And if the originating platform was writing in ASCII platform UTF-8, you will read the bytes &lt;code&gt;0xEF 0xBB 0xBF&lt;/code&gt;.)</source>
          <target state="translated">비결은 &lt;code&gt;BOM&lt;/code&gt; 을 읽으면 바이트 순서를 알 수 있다는 것입니다. 빅 엔디안 플랫폼에서 작성된 경우 바이트 &lt;code&gt;0xFE 0xFF&lt;/code&gt; 를 읽지 만 리틀 엔디안 플랫폼에서 작성된 경우 바이트 순서를 알 수 있습니다 바이트 &lt;code&gt;0xFF 0xFE&lt;/code&gt; 를 읽습니다 . (원래 플랫폼이 ASCII 플랫폼 UTF-8로 작성중인 경우 바이트 &lt;code&gt;0xEF 0xBB 0xBF&lt;/code&gt; 를 읽습니다 .)</target>
        </trans-unit>
        <trans-unit id="d8b1136600662502a87d3bbe9f24bb9e6d532704" translate="yes" xml:space="preserve">
          <source>The trick is that if you read a &lt;code&gt;BOM&lt;/code&gt;, you will know the byte order, since if it was written on a big-endian platform, you will read the bytes &lt;code&gt;0xFE 0xFF&lt;/code&gt;, but if it was written on a little-endian platform, you will read the bytes &lt;code&gt;0xFF 0xFE&lt;/code&gt;. (And if the originating platform was writing in ASCII platform UTF-8, you will read the bytes &lt;code&gt;0xEF 0xBB 0xBF&lt;/code&gt;.)</source>
          <target state="translated">트릭은 &lt;code&gt;BOM&lt;/code&gt; 을 읽으면 바이트 순서를 알 수 있다는 것입니다. 빅 엔디안 플랫폼에서 작성된 경우 바이트 &lt;code&gt;0xFE 0xFF&lt;/code&gt; 를 읽지 만 리틀 엔디안 플랫폼에서 작성된 경우 바이트 순서를 알 수 있습니다. &lt;code&gt;0xFF 0xFE&lt;/code&gt; 바이트를 읽습니다 . (원래 플랫폼이 ASCII 플랫폼 UTF-8로 작성했다면 &lt;code&gt;0xEF 0xBB 0xBF&lt;/code&gt; 바이트를 읽습니다 .)</target>
        </trans-unit>
        <trans-unit id="98f1375fe9d48b636ba837bd6c5d9b3f6fb48c48" translate="yes" xml:space="preserve">
          <source>The trick is to give a special parameter to the Configure shell script when running it on AIX:</source>
          <target state="translated">트릭은 AIX에서 쉘 스크립트를 실행할 때 특수 매개 변수를 구성하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="0a8f7f70cdf2316a2ca5d5174affe77306a16af9" translate="yes" xml:space="preserve">
          <source>The trick to this problem is avoiding accidental autovivification. If you want to check three keys deep, you might na&amp;iuml;vely try this:</source>
          <target state="translated">이 문제의 속임수는 우발적 인 자생을 피하는 것입니다. 세 개의 키를 자세히 확인하려면 순진하게 시도하십시오.</target>
        </trans-unit>
        <trans-unit id="8f023c48c1c4fd330a5e021a4a36ff097b3f2c34" translate="yes" xml:space="preserve">
          <source>The tricky thing to remember is that the first parameter is true if you want to</source>
          <target state="translated">기억해야 할 까다로운 점은 원하는 경우 첫 번째 매개 변수가 true라는 것입니다.</target>
        </trans-unit>
        <trans-unit id="0358acd687c89e6aeedb15fd79329af2ac79f19b" translate="yes" xml:space="preserve">
          <source>The trigonometric constant &lt;b&gt;pi&lt;/b&gt; and some of handy multiples of it are also defined.</source>
          <target state="translated">삼각 상수 &lt;b&gt;pi&lt;/b&gt; 와 편리한 배수가 정의되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="46116b5afa30e36e5dfcca4ac124810d45929096" translate="yes" xml:space="preserve">
          <source>The trust in item 2 is transitive. If A trusts B, and B trusts C, then A trusts C. So if you do not override &lt;code&gt;@ISA&lt;/code&gt; with &lt;code&gt;@CARP_NOT&lt;/code&gt; , then this trust relationship is identical to, &quot;inherits from&quot;.</source>
          <target state="translated">항목 2에 대한 신뢰는 전 이적입니다. A가 B를 신뢰하고 B가 C를 신뢰하면 A는 C를 신뢰합니다. 따라서 &lt;code&gt;@ISA&lt;/code&gt; 를 &lt;code&gt;@CARP_NOT&lt;/code&gt; 로 대체하지 않으면 이 신뢰 관계는 &quot; inherits from&quot;과 동일합니다.</target>
        </trans-unit>
        <trans-unit id="5a53c9a156d74f53aad5146b2193b6c99edc7b60" translate="yes" xml:space="preserve">
          <source>The trust in item 2 is transitive. If A trusts B, and B trusts C, then A trusts C. So if you do not override &lt;code&gt;@ISA&lt;/code&gt; with &lt;code&gt;@CARP_NOT&lt;/code&gt;, then this trust relationship is identical to, &quot;inherits from&quot;.</source>
          <target state="translated">항목 2에 대한 신뢰는 전 이적입니다. A가 B를 신뢰하고 B가 C를 신뢰하면 A는 C를 신뢰합니다. 따라서 &lt;code&gt;@ISA&lt;/code&gt; 를 &lt;code&gt;@CARP_NOT&lt;/code&gt; 로 재정의하지 않으면 이 신뢰 관계는 &quot;상속 출처 &quot;와 동일합니다.</target>
        </trans-unit>
        <trans-unit id="761c5f5b8a8444418e2d9bdc4d8cca16ccc65180" translate="yes" xml:space="preserve">
          <source>The truth of the matter is that perl's regular expressions these days are much more complex than this kind of structure, but visualising it this way can help when trying to get your bearings, and it matches the current implementation pretty closely.</source>
          <target state="translated">문제의 진실은 오늘날 펄의 정규 표현은 이러한 종류의 구조보다 훨씬 복잡하지만, 이런 식으로 시각화하면 베어링을 가져올 때 도움이 될 수 있으며 현재 구현과 매우 일치합니다.</target>
        </trans-unit>
        <trans-unit id="df6a9452c74fa01c8c98846cb474f3c173568489" translate="yes" xml:space="preserve">
          <source>The tty driver is put into raw mode and restored using an operating system specific command, in UNIX-like environments &lt;code&gt;stty&lt;/code&gt; .</source>
          <target state="translated">tty 드라이버는 UNIX와 같은 환경 &lt;code&gt;stty&lt;/code&gt; 에서 운영 체제 특정 명령을 사용하여 원시 모드로 전환되고 복원됩니다 .</target>
        </trans-unit>
        <trans-unit id="cdeef98c16938c38d93335b37db574e68be16a48" translate="yes" xml:space="preserve">
          <source>The tty driver is put into raw mode and restored using an operating system specific command, in UNIX-like environments &lt;code&gt;stty&lt;/code&gt;.</source>
          <target state="translated">tty 드라이버는 원시 모드로 전환되고 UNIX와 유사한 환경에서 &lt;code&gt;stty&lt;/code&gt; 운영 체제 특정 명령을 사용하여 복원됩니다 .</target>
        </trans-unit>
        <trans-unit id="99fb31ac14610942d5eec87bdc1a87d0b036e971" translate="yes" xml:space="preserve">
          <source>The tutorial started in the Llama continues in the Alpaca, which introduces the intermediate features of references, data structures, object-oriented programming, and modules:</source>
          <target state="translated">Llama에서 시작된 튜토리얼은 Alpaca에서 계속되며 참조, 데이터 구조, 객체 지향 프로그래밍 및 모듈의 중간 기능을 소개합니다.</target>
        </trans-unit>
        <trans-unit id="6ef070521ff5826ca5eb1f98285ab64a027e2793" translate="yes" xml:space="preserve">
          <source>The two additional lines request from perl to catch various common problems in your code. They check different things so you need both. A potential problem caught by &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict;&lt;/code&gt; will cause your code to stop immediately when it is encountered, while &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings;&lt;/code&gt; will merely give a warning (like the command-line switch &lt;b&gt;-w&lt;/b&gt;) and let your code run. To read more about them check their respective manual pages at &lt;a href=&quot;strict&quot;&gt;strict&lt;/a&gt; and &lt;a href=&quot;warnings&quot;&gt;warnings&lt;/a&gt;.</source>
          <target state="translated">두 개의 추가 라인은 코드에서 다양한 일반적인 문제를 포착하기 위해 perl에 요청합니다. 그들은 다른 것을 확인하므로 둘 다 필요합니다. &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict;&lt;/code&gt; &lt;a href=&quot;functions/use&quot;&gt;사용으로&lt;/a&gt; 인해 발생할 수있는 잠재적 인 문제 . &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings;&lt;/code&gt; 를 &lt;a href=&quot;functions/use&quot;&gt;사용&lt;/a&gt; 하는 동안 코드가 발견되면 즉시 중지됩니다 . 명령 줄 스위치 &lt;b&gt;-w&lt;/b&gt; 와 같은 경고 만 표시 하고 코드를 실행하십시오. 이에 대한 자세한 내용은 해당 매뉴얼 페이지를 &lt;a href=&quot;strict&quot;&gt;엄격&lt;/a&gt; 하고 &lt;a href=&quot;warnings&quot;&gt;경고&lt;/a&gt; 하여 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="80da0e6781561e53bd7245c97926dc9ea61049b1" translate="yes" xml:space="preserve">
          <source>The two additional lines request from perl to catch various common problems in your code. They check different things so you need both. A potential problem caught by &lt;code&gt;use strict;&lt;/code&gt; will cause your code to stop immediately when it is encountered, while &lt;code&gt;use warnings;&lt;/code&gt; will merely give a warning (like the command-line switch &lt;b&gt;-w&lt;/b&gt;) and let your code run. To read more about them check their respective manual pages at &lt;a href=&quot;strict&quot;&gt;strict&lt;/a&gt; and &lt;a href=&quot;warnings&quot;&gt;warnings&lt;/a&gt;.</source>
          <target state="translated">두 개의 추가 행은 코드에서 다양한 일반적인 문제를 포착하기 위해 perl에서 요청합니다. 그들은 서로 다른 것을 확인하므로 둘 다 필요합니다. &lt;code&gt;use strict;&lt;/code&gt; 의해 포착 된 잠재적 인 문제 ; &lt;code&gt;use warnings;&lt;/code&gt; 를 사용 하는 동안 코드가 발견되면 즉시 중지됩니다 . 명령 줄 스위치 &lt;b&gt;-w&lt;/b&gt; 와 같은 경고 만 표시 하고 코드가 실행되도록합니다. 그들에 대한 자세한 내용을 보려면 &lt;a href=&quot;strict&quot;&gt;strict&lt;/a&gt; 및 &lt;a href=&quot;warnings&quot;&gt;warnings&lt;/a&gt; 에서 해당 매뉴얼 페이지를 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="ba2dc4945c85043455423fb1b5a39f8aa3d6b28f" translate="yes" xml:space="preserve">
          <source>The two argument form of add_bits() will add the first $nbits bits from $data. For the last potentially partial byte only the high order &lt;code&gt;$nbits % 8&lt;/code&gt; bits are used. If $nbits is greater than &lt;code&gt;&lt;a href=&quot;functions/length&quot;&gt;length&lt;/a&gt;($data) * 8&lt;/code&gt; , then this method would do the same as &lt;code&gt;$ctx-&amp;gt;add($data)&lt;/code&gt; .</source>
          <target state="translated">add_bits ()의 두 인수 형식은 $ data에서 첫 $ nbits 비트를 추가합니다. 마지막 잠재적 부분 바이트의 경우 상위 &lt;code&gt;$nbits % 8&lt;/code&gt; 비트 만 사용됩니다. $ nbits가 &lt;code&gt;&lt;a href=&quot;functions/length&quot;&gt;length&lt;/a&gt;($data) * 8&lt;/code&gt; 보다 큰 경우이 방법은 &lt;code&gt;$ctx-&amp;gt;add($data)&lt;/code&gt; 와 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="a487d05aa816a2a714594f695177da57d7a262a6" translate="yes" xml:space="preserve">
          <source>The two argument form of add_bits() will add the first $nbits bits from $data. For the last potentially partial byte only the high order &lt;code&gt;$nbits % 8&lt;/code&gt; bits are used. If $nbits is greater than &lt;code&gt;length($data) * 8&lt;/code&gt;, then this method would do the same as &lt;code&gt;$ctx-&amp;gt;add($data)&lt;/code&gt;.</source>
          <target state="translated">add_bits ()의 두 인수 형식은 $ data에서 처음 $ nbits 비트를 추가합니다. 잠재적으로 마지막 부분 바이트의 경우 상위 &lt;code&gt;$nbits % 8&lt;/code&gt; 비트 만 사용됩니다. $ nbits가 &lt;code&gt;length($data) * 8&lt;/code&gt; 보다 크면 이 메서드는 &lt;code&gt;$ctx-&amp;gt;add($data)&lt;/code&gt; 와 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="edfc68f9b85a8c57ac6b419328c423790a72a43e" translate="yes" xml:space="preserve">
          <source>The two arrays &lt;code&gt;@ISA&lt;/code&gt; and &lt;code&gt;@EXPORT&lt;/code&gt; are very important. The &lt;code&gt;@ISA&lt;/code&gt; array contains a list of other packages in which to search for methods (or subroutines) that do not exist in the current package. This is usually only important for object-oriented extensions (which we will talk about much later), and so usually doesn't need to be modified.</source>
          <target state="translated">&lt;code&gt;@ISA&lt;/code&gt; 와 &lt;code&gt;@EXPORT&lt;/code&gt; 의 두 배열 은 매우 중요합니다. &lt;code&gt;@ISA&lt;/code&gt; 의 배열은 현재 패키지에 존재하지 않는 방법 (또는 서브 루틴들)을 검색하여 다른 패키지의리스트를 포함한다. 이것은 일반적으로 객체 지향 확장 (나중에 이야기 할 것)에만 중요하므로 일반적으로 수정할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="1bc049a18027fa1202df37bcfed013d26326a12f" translate="yes" xml:space="preserve">
          <source>The two control characters ^D and ^Z, and the tokens __END__ and __DATA__ may be used to indicate the logical end of the script before the actual end of file. Any following text is ignored.</source>
          <target state="translated">두 개의 제어 문자 ^ D 및 ^ Z와 토큰 __END__ 및 __DATA__을 사용하여 실제 파일 끝 전에 스크립트의 논리적 끝을 나타낼 수 있습니다. 다음 텍스트는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="34dcc268df0f1b7f78c17ae23e0cef09454c6cdc" translate="yes" xml:space="preserve">
          <source>The two entry points are &lt;code&gt;re_intuit_start()&lt;/code&gt; and &lt;code&gt;pregexec()&lt;/code&gt; . These routines have a somewhat incestuous relationship with overlap between their functions, and &lt;code&gt;pregexec()&lt;/code&gt; may even call &lt;code&gt;re_intuit_start()&lt;/code&gt; on its own. Nevertheless other parts of the perl source code may call into either, or both.</source>
          <target state="translated">두 개의 진입 점은 &lt;code&gt;re_intuit_start()&lt;/code&gt; 및 &lt;code&gt;pregexec()&lt;/code&gt; 입니다. 이 루틴들은 함수간에 겹치는 부분이 다소 &lt;code&gt;pregexec()&lt;/code&gt; 관계를 가지고 있으며, pregexec () 는 &lt;code&gt;re_intuit_start()&lt;/code&gt; 를 스스로 호출 할 수도 있습니다. 그럼에도 불구하고 perl 소스 코드의 다른 부분은 둘 중 하나 또는 둘 다를 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="18c4b8288d8734c5d96fe76caf7da0dc805d1f00" translate="yes" xml:space="preserve">
          <source>The two entry points are &lt;code&gt;re_intuit_start()&lt;/code&gt; and &lt;code&gt;pregexec()&lt;/code&gt;. These routines have a somewhat incestuous relationship with overlap between their functions, and &lt;code&gt;pregexec()&lt;/code&gt; may even call &lt;code&gt;re_intuit_start()&lt;/code&gt; on its own. Nevertheless other parts of the perl source code may call into either, or both.</source>
          <target state="translated">두 진입 점은 &lt;code&gt;re_intuit_start()&lt;/code&gt; 및 &lt;code&gt;pregexec()&lt;/code&gt; 입니다. 이러한 루틴은 함수간에 겹치는 다소 근친상간 관계를 가지고 있으며 &lt;code&gt;pregexec()&lt;/code&gt; 는 자체적으로 &lt;code&gt;re_intuit_start()&lt;/code&gt; 를 호출 할 수도 있습니다. 그럼에도 불구하고 펄 소스 코드의 다른 부분은 둘 중 하나 또는 둘 다를 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8d4c95b48b6a1668825ba4572ce44483ca77dc51" translate="yes" xml:space="preserve">
          <source>The two filenames can also be given separately in full as &lt;code&gt;$dirfile&lt;/code&gt; and &lt;code&gt;$pagfilename&lt;/code&gt; . This suits for two files without &quot;.dir&quot; and &quot;.pag&quot; extensions, perhaps for example two files from &lt;a href=&quot;file/temp&quot;&gt;File::Temp&lt;/a&gt;.</source>
          <target state="translated">두 파일 이름은 &lt;code&gt;$dirfile&lt;/code&gt; 및 &lt;code&gt;$pagfilename&lt;/code&gt; 전체적으로 별도로 제공 할 수도 있습니다 . 이것은 &quot;.dir&quot;및 &quot;.pag&quot;확장자가없는 두 파일에 적합합니다 (예 &lt;a href=&quot;file/temp&quot;&gt;: File :: Temp의&lt;/a&gt; 두 파일) .</target>
        </trans-unit>
        <trans-unit id="d779d1807753d79ce6e5b3476dc2ab8ca5a48661" translate="yes" xml:space="preserve">
          <source>The two filenames can also be given separately in full as &lt;code&gt;$dirfile&lt;/code&gt; and &lt;code&gt;$pagfilename&lt;/code&gt;. This suits for two files without &quot;.dir&quot; and &quot;.pag&quot; extensions, perhaps for example two files from &lt;a href=&quot;File::Temp&quot;&gt;File::Temp&lt;/a&gt;.</source>
          <target state="translated">두 개의 파일 이름을 &lt;code&gt;$dirfile&lt;/code&gt; 및 &lt;code&gt;$pagfilename&lt;/code&gt; 으로 개별적으로 지정할 수도 있습니다 . 이것은 &quot;.dir&quot;및 &quot;.pag&quot;확장자가없는 두 파일에 적합합니다. 예를 들어 &lt;a href=&quot;File::Temp&quot;&gt;File :: Temp의&lt;/a&gt; 두 파일이 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2f1774e1f537dc56f588c1be426bca15556e7438" translate="yes" xml:space="preserve">
          <source>The two first forms are simply syntactic sugar which automatically load the right module on first use. The second form allow you to use algorithm names which contains letters which are not legal perl identifiers, e.g. &quot;SHA-1&quot;. If no implementation for the given algorithm can be found, then an exception is raised.</source>
          <target state="translated">두 가지 첫 번째 형태는 단순한 구문 설탕으로 처음 사용할 때 올바른 모듈을 자동으로로드합니다. 두 번째 형식을 사용하면 합법적 인 펄 식별자가 아닌 문자 (예 : &quot;SHA-1&quot;)가 포함 된 알고리즘 이름을 사용할 수 있습니다. 주어진 알고리즘에 대한 구현을 찾을 수 없으면 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="c95a4925ad583d0cdab2da763605ba8a5577a6cd" translate="yes" xml:space="preserve">
          <source>The two main uses for this are to switch back to using the package sub inside an inner scope:</source>
          <target state="translated">이를위한 두 가지 주요 용도는 내부 범위 내에서 패키지 하위를 사용하도록 다시 전환하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="9fdb893929b74d583f916a04691865e61a0c8195" translate="yes" xml:space="preserve">
          <source>The two most common mistakes made in constructing something like an array of arrays is either accidentally counting the number of elements or else taking a reference to the same memory location repeatedly. Here's the case where you just get the count instead of a nested array:</source>
          <target state="translated">배열 배열과 같은 것을 구성 할 때 가장 흔히 발생하는 두 가지 실수는 실수로 요소 수를 계산하거나 동일한 메모리 위치를 반복적으로 참조하는 것입니다. 중첩 배열 대신 카운트를 얻는 경우는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="bd2d45d08dbd09dca740f5cf8bff110dce877246" translate="yes" xml:space="preserve">
          <source>The two primary use cases supported by &lt;a href=&quot;TAP::Harness&quot;&gt;TAP::Harness&lt;/a&gt; for plugins are</source>
          <target state="translated">플러그인 용 &lt;a href=&quot;TAP::Harness&quot;&gt;TAP :: Harness&lt;/a&gt; 에서 지원하는 두 가지 주요 사용 사례 는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9ef613531270a3be0f714b7b0c6603ad457c5c67" translate="yes" xml:space="preserve">
          <source>The two primary use cases supported by &lt;a href=&quot;harness&quot;&gt;TAP::Harness&lt;/a&gt; for plugins are</source>
          <target state="translated">플러그인에 대한 &lt;a href=&quot;harness&quot;&gt;TAP :: Harness&lt;/a&gt; 에서 지원하는 두 가지 주요 사용 사례 는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="49899df9616cd2a3f123de74937bc969a55089e7" translate="yes" xml:space="preserve">
          <source>The two quickest fixes are either to render Perl silent about any locale inconsistencies or to run Perl under the default locale &quot;C&quot;.</source>
          <target state="translated">가장 빠른 두 가지 수정 사항은 로케일 불일치에 대해 Perl을 침묵 시키거나 기본 로케일 &quot;C&quot;로 Perl을 실행하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="1d29057aa8b200a921ab9b4c9f2a8fac7349c60a" translate="yes" xml:space="preserve">
          <source>The two sets of barcharts give stats and a visual indication of performance of the hash.</source>
          <target state="translated">두 개의 막대 차트 세트는 통계와 해시 성능을 시각적으로 표시합니다.</target>
        </trans-unit>
        <trans-unit id="ea356fe6678cb16635414403ae22dc70cf7c6eb2" translate="yes" xml:space="preserve">
          <source>The two statements:</source>
          <target state="translated">두 문장 :</target>
        </trans-unit>
        <trans-unit id="9d44f9be0143700229ab0017bf471dc2508dbc35" translate="yes" xml:space="preserve">
          <source>The two-sided ordering operators &lt;code&gt;&quot;&amp;lt;=&amp;gt;&quot;&lt;/code&gt; and &lt;code&gt;&quot;cmp&quot;&lt;/code&gt;, and the smartmatch operator &lt;code&gt;&quot;~~&quot;&lt;/code&gt;, are non-associative with respect to each other and with respect to the equality operators of the same precedence.</source>
          <target state="translated">양면 정렬 연산자 &lt;code&gt;&quot;&amp;lt;=&amp;gt;&quot;&lt;/code&gt; 및 &lt;code&gt;&quot;cmp&quot;&lt;/code&gt; 와 스마트 매치 연산자 &lt;code&gt;&quot;~~&quot;&lt;/code&gt; 는 서로에 대해 그리고 동일한 우선 순위의 같음 연산자와 관련 하여 비연 관적 입니다.</target>
        </trans-unit>
        <trans-unit id="40f9fd98a080c00fe06d27a5abbbe001334533cf" translate="yes" xml:space="preserve">
          <source>The type of partition. See the &lt;code&gt;&quot;:PARTITION_&quot;&lt;/code&gt; export class for a list of known types. See also &lt;code&gt;IsRecognizedPartition&lt;/code&gt; and &lt;code&gt;IsContainerPartition&lt;/code&gt;.</source>
          <target state="translated">파티션 유형입니다. 알려진 유형 목록은 &lt;code&gt;&quot;:PARTITION_&quot;&lt;/code&gt; 내보내기 클래스를 참조하십시오 . &lt;code&gt;IsRecognizedPartition&lt;/code&gt; 및 &lt;code&gt;IsContainerPartition&lt;/code&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="2e850f7b70f56596c655ae357f7738793fa85127" translate="yes" xml:space="preserve">
          <source>The type of the constant (</source>
          <target state="translated">상수의 유형 (</target>
        </trans-unit>
        <trans-unit id="207d3c0594c531831415850568f05351cc4335f1" translate="yes" xml:space="preserve">
          <source>The type of the third parameter is arbitrary as far as the typemap is concerned. It just has to be in line with the declared variable.</source>
          <target state="translated">세 번째 매개 변수의 유형은 유형 맵에 관한 한 임의적입니다. 선언 된 변수와 일치해야합니다.</target>
        </trans-unit>
        <trans-unit id="3a8fb2c5d9024ab64dd8a1b418b0785f1b45c2d4" translate="yes" xml:space="preserve">
          <source>The type-to-match is whitewashed (except for commas, which have no whitespace before them, and multiple &lt;code&gt;*&lt;/code&gt; which have no whitespace between them).</source>
          <target state="translated">유형 간 일치 (더 그들 앞에 공백, 다중이없는 쉼표를 제외한 백색 도료됩니다 &lt;code&gt;*&lt;/code&gt; 그들 사이에 공백이 없습니다).</target>
        </trans-unit>
        <trans-unit id="065bb709681867146d38619409b0c4858958cd7d" translate="yes" xml:space="preserve">
          <source>The typemap checks that a scalar reference is passed from perl to XS.</source>
          <target state="translated">타입 맵은 스칼라 참조가 perl에서 XS로 전달되는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="1aca61f72e9539e566a25a6f843796b117e0a616" translate="yes" xml:space="preserve">
          <source>The types are:</source>
          <target state="translated">유형은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b8218b5c6abbddadba7d9cdb24a7712b0e31ed41" translate="yes" xml:space="preserve">
          <source>The typical C compiler&amp;rsquo;s first pass, which processes lines beginning with &lt;code&gt;#&lt;/code&gt; for conditional compilation and macro definition, and does various manipulations of the program text based on the current definitions. Also known as</source>
          <target state="translated">조건부 컴파일 및 매크로 정의를 위해 &lt;code&gt;#&lt;/code&gt; 으로 시작하는 행을 처리 하고 현재 정의를 기반으로 프로그램 텍스트의 다양한 조작을 수행하는 일반적인 C 컴파일러의 첫 번째 패스 입니다. 또한 ~으로 알려진</target>
        </trans-unit>
        <trans-unit id="c3f6853138e86a46a65a1f12c8ebb77c9ad23c63" translate="yes" xml:space="preserve">
          <source>The typical approach uses the Perl debugger, described in the</source>
          <target state="translated">일반적인 접근 방식은 Perl 디버거를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="4f5664b1824b0de67fa46d923ec8d9a2b184a8da" translate="yes" xml:space="preserve">
          <source>The typical approach uses the Perl debugger, described in the &lt;a href=&quot;http://man.he.net/man1/perldebug&quot;&gt;perldebug(1)&lt;/a&gt; manpage, on an &quot;empty&quot; program, like this:</source>
          <target state="translated">일반적인 접근 방식은 다음과 같이 &quot;빈&quot;프로그램 에서 &lt;a href=&quot;http://man.he.net/man1/perldebug&quot;&gt;perldebug (1)&lt;/a&gt; 맨 페이지에 설명 된 Perl 디버거를 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="8d039cb4fff50dcf102a20e5a834fd5dcb92db29" translate="yes" xml:space="preserve">
          <source>The typical input/output flow of a program is:</source>
          <target state="translated">프로그램의 일반적인 입 / 출력 흐름은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="bb341dafe72dfd453b6e963169c19a0e3677ecc8" translate="yes" xml:space="preserve">
          <source>The typical interactions between pieces of data are best represented by operators.</source>
          <target state="translated">데이터 조각 간의 일반적인 상호 작용은 운영자가 가장 잘 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="37bcc82c39e22721104650473d90114a9246bb63" translate="yes" xml:space="preserve">
          <source>The typical usage case is for private modules or working copies of projects from remote repositories on the local disk.</source>
          <target state="translated">일반적인 사용 사례는 로컬 디스크의 원격 리포지토리에서 개인 모듈 또는 프로젝트의 작업 복사본에 대한 것입니다.</target>
        </trans-unit>
        <trans-unit id="a4e2f09da65ffeb5dd41665671b5f400f853e79b" translate="yes" xml:space="preserve">
          <source>The typical usage is from within a Makefile generated by &lt;a href=&quot;makemaker&quot;&gt;ExtUtils::MakeMaker&lt;/a&gt;. So under normal circumstances you won't have to deal with this module directly.</source>
          <target state="translated">일반적인 사용법은 &lt;a href=&quot;makemaker&quot;&gt;ExtUtils :: MakeMaker에&lt;/a&gt; 의해 생성 된 Makefile 내에서 입니다. 따라서 정상적인 상황에서는이 모듈을 직접 처리 할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="e5ea1d13fc13ac160da9f2f104ab7304934ae9cc" translate="yes" xml:space="preserve">
          <source>The typical usage is from within perl's own Makefile (to build</source>
          <target state="translated">일반적인 사용법은 Perl의 자체 Makefile (</target>
        </trans-unit>
        <trans-unit id="b839dd64fd51c7239737d976be2aaf701494cef3" translate="yes" xml:space="preserve">
          <source>The typical way to use an &lt;code&gt;EVERY&lt;/code&gt; call is to wrap it in another base method, that all classes inherit. For example, to ensure that every destructor an object inherits is actually called (as opposed to just the left-most-depth-first-est one):</source>
          <target state="translated">&lt;code&gt;EVERY&lt;/code&gt; 호출 을 사용하는 일반적인 방법 은 모든 클래스가 상속하는 다른 기본 메소드로 래핑하는 것입니다. 예를 들어, 객체가 상속하는 모든 소멸자를 실제로 호출하는지 확인하려면 (가장 왼쪽에서 가장 깊이있는 것만 반대) :</target>
        </trans-unit>
        <trans-unit id="d078360c456578fa6c56aaca3475f63295e459b1" translate="yes" xml:space="preserve">
          <source>The uncolor() function and support for ANSI_COLORS_DISABLED were added in Term::ANSIColor 1.04, included in Perl 5.8.0.</source>
          <target state="translated">uncolor () 함수 및 ANSI_COLORS_DISABLED 지원은 Perl 5.8.0에 포함 된 Term :: ANSIColor 1.04에 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="d4305b00ed1c85486a9072f02e9b2ef3f0a22224" translate="yes" xml:space="preserve">
          <source>The underlying &lt;code&gt;SetFilePointer&lt;/code&gt; returns &lt;code&gt;0xFFFFFFFF&lt;/code&gt; to indicate failure, but if &lt;code&gt;$ioivOffsetHigh&lt;/code&gt; is not &lt;code&gt;[]&lt;/code&gt;, you would also have to check &lt;code&gt;$^E&lt;/code&gt; to determine whether &lt;code&gt;0xFFFFFFFF&lt;/code&gt; indicates an error or not. &lt;code&gt;Win32API::File::SetFilePointer&lt;/code&gt; does this checking for you and returns a false value if and only if the underlying &lt;code&gt;SetFilePointer&lt;/code&gt; failed. For this reason, &lt;code&gt;$uNewPos&lt;/code&gt; is set to &lt;code&gt;&quot;0 but true&quot;&lt;/code&gt; if you set the file pointer to the beginning of the file [or any position with 0 for the low-order 4 bytes].</source>
          <target state="translated">기본 &lt;code&gt;SetFilePointer&lt;/code&gt; 는 실패를 나타 내기 위해 &lt;code&gt;0xFFFFFFFF&lt;/code&gt; 를 반환 하지만 &lt;code&gt;$ioivOffsetHigh&lt;/code&gt; 가 &lt;code&gt;[]&lt;/code&gt; 이 아닌 경우 &lt;code&gt;$^E&lt;/code&gt; 확인 하여 &lt;code&gt;0xFFFFFFFF&lt;/code&gt; 가 오류를 나타내는 지 여부를 확인해야합니다 . &lt;code&gt;Win32API::File::SetFilePointer&lt;/code&gt; 는이 검사를 수행하고 기본 &lt;code&gt;SetFilePointer&lt;/code&gt; 가 실패한 경우에만 false 값을 반환합니다 . 이러한 이유로 파일 포인터를 파일의 시작 (또는 하위 4 바이트의 경우 0 인 위치)으로 설정하면 &lt;code&gt;$uNewPos&lt;/code&gt; 가 &lt;code&gt;&quot;0 but true&quot;&lt;/code&gt; 로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="da2ba2ed494fcbfde7ff54569b0d33c7f011e269" translate="yes" xml:space="preserve">
          <source>The underlying behaviour of &lt;code&gt;%+&lt;/code&gt; is provided by the &lt;a href=&quot;Tie::Hash::NamedCapture&quot;&gt;Tie::Hash::NamedCapture&lt;/a&gt; module.</source>
          <target state="translated">의 기본 동작 &lt;code&gt;%+&lt;/code&gt; 에 의해 제공된다 &lt;a href=&quot;Tie::Hash::NamedCapture&quot;&gt;타이 :: 해시 :: NamedCapture 용&lt;/a&gt; 모듈.</target>
        </trans-unit>
        <trans-unit id="d2846292c4ece0df1cdbdb746e73838c0174b8ea" translate="yes" xml:space="preserve">
          <source>The underlying behaviour of &lt;code&gt;%+&lt;/code&gt; is provided by the &lt;a href=&quot;tie/hash/namedcapture&quot;&gt;Tie::Hash::NamedCapture&lt;/a&gt; module.</source>
          <target state="translated">의 기본 동작 &lt;code&gt;%+&lt;/code&gt; 에 의해 제공된다 &lt;a href=&quot;tie/hash/namedcapture&quot;&gt;타이 :: 해시 :: NamedCapture 용&lt;/a&gt; 모듈.</target>
        </trans-unit>
        <trans-unit id="cc10f153a716bc66afaf3456e02a5c9183a04515" translate="yes" xml:space="preserve">
          <source>The underlying parser object. This is useful if you need the full information for the test program.</source>
          <target state="translated">기본 파서 객체 테스트 프로그램에 대한 전체 정보가 필요한 경우에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="b7d8dde972f17bdda4b61ab86196bc96064679a1" translate="yes" xml:space="preserve">
          <source>The undump program was an ancient attempt to speed up Perl program by storing the already-compiled form to disk. This is no longer a viable option, as it only worked on a few architectures, and wasn't a good solution anyway.</source>
          <target state="translated">언 덤프 프로그램은 이미 컴파일 된 양식을 디스크에 저장하여 Perl 프로그램의 속도를 높이려는 고대의 시도였습니다. 이 기능은 더 이상 몇 가지 아키텍처에서만 작동했으며 더 이상 좋은 솔루션이 아니기 때문에 실행 가능한 옵션이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="be8a46bbcbbd519aa2c58d3aea183c9d8f4c685d" translate="yes" xml:space="preserve">
          <source>The unfortunate similarity of this function's name to that of Perl's &lt;code&gt;&lt;a href=&quot;functions/chop&quot;&gt;chop&lt;/a&gt;&lt;/code&gt; operator is strictly coincidental. This function works from the left; &lt;code&gt;&lt;a href=&quot;functions/chop&quot;&gt;chop&lt;/a&gt;&lt;/code&gt; works from the right.</source>
          <target state="translated">이 함수의 이름과 Perl의 &lt;code&gt;&lt;a href=&quot;functions/chop&quot;&gt;chop&lt;/a&gt;&lt;/code&gt; 조작자 와의 불행한 유사성은 우연의 일치입니다. 이 기능은 왼쪽에서 작동합니다. &lt;code&gt;&lt;a href=&quot;functions/chop&quot;&gt;chop&lt;/a&gt;&lt;/code&gt; 오른쪽에서 작동합니다.</target>
        </trans-unit>
        <trans-unit id="a30b1d50e05e4b08ed93704bd74f564e5fd07aba" translate="yes" xml:space="preserve">
          <source>The unfortunate similarity of this function's name to that of Perl's &lt;code&gt;chop&lt;/code&gt; operator is strictly coincidental. This function works from the left; &lt;code&gt;chop&lt;/code&gt; works from the right.</source>
          <target state="translated">이 함수의 이름과 Perl의 &lt;code&gt;chop&lt;/code&gt; 연산자 의 이름이 유감스럽게도 유사하다는 점은 우연의 일치입니다. 이 기능은 왼쪽에서 작동합니다. &lt;code&gt;chop&lt;/code&gt; 은 오른쪽에서 작동합니다.</target>
        </trans-unit>
        <trans-unit id="188f61d7ec87851548e9f8daeb9600a5a694a2e6" translate="yes" xml:space="preserve">
          <source>The union of two array refs</source>
          <target state="translated">두 배열 참조의 합집합</target>
        </trans-unit>
        <trans-unit id="ca3db9d0f0db6a082e0aea1f0a6be142ef87df51" translate="yes" xml:space="preserve">
          <source>The untie Gotcha</source>
          <target state="translated">Unt Gotcha</target>
        </trans-unit>
        <trans-unit id="12164923a1b041bdc762cdb62bbbc7fb759ea434" translate="yes" xml:space="preserve">
          <source>The untie() Gotcha</source>
          <target state="translated">untie () 잡았다</target>
        </trans-unit>
        <trans-unit id="50d65961a427d2a64bc08d49e4d87b52f498e907" translate="yes" xml:space="preserve">
          <source>The uppercase variants (&lt;code&gt;\W&lt;/code&gt; , &lt;code&gt;\D&lt;/code&gt; , &lt;code&gt;\S&lt;/code&gt; , &lt;code&gt;\H&lt;/code&gt; , and &lt;code&gt;\V&lt;/code&gt; ) are character classes that match, respectively, any character that isn't a word character, digit, whitespace, horizontal whitespace, or vertical whitespace.</source>
          <target state="translated">대문자 변형 ( &lt;code&gt;\W&lt;/code&gt; , &lt;code&gt;\D&lt;/code&gt; , &lt;code&gt;\S&lt;/code&gt; , &lt;code&gt;\H&lt;/code&gt; 및 &lt;code&gt;\V&lt;/code&gt; )은 각각 단어 문자, 숫자, 공백, 가로 공백 또는 세로 공백이 아닌 문자와 일치하는 문자 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="969149804a3c69f65ce9535464f4fe7c8cb52284" translate="yes" xml:space="preserve">
          <source>The uppercase variants (&lt;code&gt;\W&lt;/code&gt;, &lt;code&gt;\D&lt;/code&gt;, &lt;code&gt;\S&lt;/code&gt;, &lt;code&gt;\H&lt;/code&gt;, and &lt;code&gt;\V&lt;/code&gt;) are character classes that match, respectively, any character that isn't a word character, digit, whitespace, horizontal whitespace, or vertical whitespace.</source>
          <target state="translated">대문자 변형 ( &lt;code&gt;\W&lt;/code&gt; , &lt;code&gt;\D&lt;/code&gt; , &lt;code&gt;\S&lt;/code&gt; , &lt;code&gt;\H&lt;/code&gt; 및 &lt;code&gt;\V&lt;/code&gt; )은 각각 단어 문자, 숫자, 공백, 수평 공백 또는 수직 공백이 아닌 모든 문자와 일치하는 문자 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="6a360f037634db2d1e1b847c01d4ff39f2e82c73" translate="yes" xml:space="preserve">
          <source>The uri you passed to the constructor</source>
          <target state="translated">생성자에게 전달한 URI</target>
        </trans-unit>
        <trans-unit id="7175c322baef80b04d65002673bad08dde1a5590" translate="yes" xml:space="preserve">
          <source>The urllist parameter has CD-ROM support</source>
          <target state="translated">urllist 매개 변수는 CD-ROM을 지원합니다</target>
        </trans-unit>
        <trans-unit id="0e71ac825c7f966ddb9142eb457a1ad27b050118" translate="yes" xml:space="preserve">
          <source>The usage is for a canned filter is:</source>
          <target state="translated">통조림 필터의 사용법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="28d3b03a1f670128ac1940bc311030e5942649cb" translate="yes" xml:space="preserve">
          <source>The use of &lt;code&gt;*glob{FILEHANDLE}&lt;/code&gt; was deprecated in Perl 5.8. The intention was to use &lt;code&gt;*glob{IO}&lt;/code&gt; instead, for which &lt;code&gt;*glob{FILEHANDLE}&lt;/code&gt; is an alias.</source>
          <target state="translated">의 사용 &lt;code&gt;*glob{FILEHANDLE}&lt;/code&gt; 펄 5.8을 사용합니다. 의도는 &lt;code&gt;*glob{IO}&lt;/code&gt; 대신 사용하는 것이 었습니다. &lt;code&gt;*glob{FILEHANDLE}&lt;/code&gt; 이 별명입니다.</target>
        </trans-unit>
        <trans-unit id="826c70de8255c56bc69c42539c313e47e2f05832" translate="yes" xml:space="preserve">
          <source>The use of &lt;code&gt;//g&lt;/code&gt; is shown in the following example. Suppose we have a string that consists of words separated by spaces. If we know how many words there are in advance, we could extract the words using groupings:</source>
          <target state="translated">&lt;code&gt;//g&lt;/code&gt; 의 사용은 다음 예에 나와 있습니다. 공백으로 구분 된 단어로 구성된 문자열이 있다고 가정합니다. 사전에 단어가 몇 개인 지 알면 그룹화를 사용하여 단어를 추출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6a8f9ae899c24a9ba384007b7a56b302e1ecb384" translate="yes" xml:space="preserve">
          <source>The use of &lt;code&gt;/g&lt;/code&gt; is shown in the following example. Suppose we have a string that consists of words separated by spaces. If we know how many words there are in advance, we could extract the words using groupings:</source>
          <target state="translated">&lt;code&gt;/g&lt;/code&gt; 의 사용은 다음 예에 나와 있습니다. 공백으로 구분 된 단어로 구성된 문자열이 있다고 가정합니다. 사전에 몇 개의 단어가 있는지 알고 있다면 그룹화를 사용하여 단어를 추출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="832a5d88d8f5443e11412058babdb54340f702ac" translate="yes" xml:space="preserve">
          <source>The use of &lt;code&gt;:void&lt;/code&gt; is discouraged, as it can result in exceptions not being thrown if you</source>
          <target state="translated">의 사용 &lt;code&gt;:void&lt;/code&gt; 이 발생되지 않는 예외를 초래할 수 있으므로, 권장하지 않습니다 만약 당신이</target>
        </trans-unit>
        <trans-unit id="0ce5a82961769245d2e039e505d826cd3e904ef4" translate="yes" xml:space="preserve">
          <source>The use of &lt;code&gt;:void&lt;/code&gt; with Fatal is discouraged.</source>
          <target state="translated">Fatal과 함께 &lt;code&gt;:void&lt;/code&gt; 를 사용 하지 않는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="dac4651068bc57e4e25c4b9a7bdd7a073791862a" translate="yes" xml:space="preserve">
          <source>The use of &lt;code&gt;=&amp;gt;&lt;/code&gt; above provides necessary quoting of &lt;code&gt;MODULE&lt;/code&gt; . If you don't use the fat comma (eg you don't have any ARGUMENTS), then you'll need to quote the MODULE.</source>
          <target state="translated">위 의 &lt;code&gt;=&amp;gt;&lt;/code&gt; 사용 은 필요한 &lt;code&gt;MODULE&lt;/code&gt; 인용을 제공합니다 . 뚱뚱한 쉼표를 사용하지 않으면 (예 : 인수가없는 경우) 모듈을 인용해야합니다.</target>
        </trans-unit>
        <trans-unit id="3987152a02b0e8946670fa1ed3d0263b2379f73d" translate="yes" xml:space="preserve">
          <source>The use of &lt;code&gt;\K&lt;/code&gt; inside of another lookaround assertion is allowed, but the behaviour is currently not well defined.</source>
          <target state="translated">다른 룩 어라운드 어설 션 내 에서 &lt;code&gt;\K&lt;/code&gt; 사용할 수 있지만 현재 동작이 잘 정의되어 있지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9b512e8508712c1167d958e6e4ad448ccc7e030f" translate="yes" xml:space="preserve">
          <source>The use of &lt;code&gt;\Q&lt;/code&gt; causes the &amp;lt;.&amp;gt; in the regex to be treated as a regular character, so that &lt;code&gt;P.&lt;/code&gt; matches a &lt;code&gt;P&lt;/code&gt; followed by a dot.</source>
          <target state="translated">사용 &lt;code&gt;\Q&lt;/code&gt; (가) &amp;lt;.&amp;gt; 정규식에서 일정한 문자로 취급하기 때문에 발생한다는 &lt;code&gt;P.&lt;/code&gt; 가 일치 &lt;code&gt;P&lt;/code&gt; 점을 하였다.</target>
        </trans-unit>
        <trans-unit id="fc1eea836569752f037bcfe192ccf1fd3a1c9537" translate="yes" xml:space="preserve">
          <source>The use of &lt;code&gt;\Q&lt;/code&gt; causes the &lt;code&gt;.&lt;/code&gt; in the regex to be treated as a regular character, so that &lt;code&gt;P.&lt;/code&gt; matches a &lt;code&gt;P&lt;/code&gt; followed by a dot.</source>
          <target state="translated">사용 &lt;code&gt;\Q&lt;/code&gt; 가 발생합니다 &lt;code&gt;.&lt;/code&gt; 정규 문자로 처리 할 정규식에서 &lt;code&gt;P.&lt;/code&gt; 는 &lt;code&gt;P&lt;/code&gt; 다음에 점이 오는 것과 일치합니다 .</target>
        </trans-unit>
        <trans-unit id="6a848a8f72097323f82bf0128df3ae2506a4c5d0" translate="yes" xml:space="preserve">
          <source>The use of &lt;code&gt;my()&lt;/code&gt; in a false conditional has been deprecated in Perl 5.10, and became a fatal error in Perl 5.30.</source>
          <target state="translated">의 사용은 &lt;code&gt;my()&lt;/code&gt; 거짓 조건에서 펄 5.10에서 사용되지 않는, 펄 5.30에 치명적인 오류가되었다되었습니다.</target>
        </trans-unit>
        <trans-unit id="514e40665c7756f02fb508e8f86f86167ddf537d" translate="yes" xml:space="preserve">
          <source>The use of a camel with the topic of Perl is a trademark of O'Reilly and Associates, Inc. Used with permission.</source>
          <target state="translated">Perl 주제와 함께 낙타를 사용하는 것은 O'Reilly and Associates, Inc.의 상표입니다. 허가를 받아 사용되었습니다.</target>
        </trans-unit>
        <trans-unit id="9cb45eca9a7939753b03a1360d763d098c0e7870" translate="yes" xml:space="preserve">
          <source>The use of all caps for constant names is merely a convention, although it is recommended in order to make constants stand out and to help avoid collisions with other barewords, keywords, and subroutine names. Constant names must begin with a letter or underscore. Names beginning with a double underscore are reserved. Some poor choices for names will generate warnings, if warnings are enabled at compile time.</source>
          <target state="translated">상수 이름에 모든 대문자를 사용하는 것은 단지 관례이지만 상수를 돋보이게하고 다른 베어 워드, 키워드 및 서브 루틴 이름과의 충돌을 피하기 위해 권장됩니다. 상수 이름은 문자 나 밑줄로 시작해야합니다. 이중 밑줄로 시작하는 이름은 예약되어 있습니다. 컴파일시 경고가 활성화 된 경우 이름을 잘못 선택하면 경고가 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="58b862df75de13b5dcf2d9b0b606b5454f4112c1" translate="yes" xml:space="preserve">
          <source>The use of hash keys starting with a hyphen (&lt;code&gt;-name&lt;/code&gt; ) or entirely in upper case (&lt;code&gt;NAME&lt;/code&gt; ) is a relic of older versions of Perl in which ordinary lower case strings were not handled correctly by the &lt;code&gt;=&amp;gt;&lt;/code&gt; operator. While some modules retain uppercase or hyphenated argument keys for historical reasons or as a matter of personal style, most new modules should use simple lower case keys. Whatever you choose, be consistent!</source>
          <target state="translated">하이픈 ( &lt;code&gt;-name&lt;/code&gt; )으로 시작 하거나 완전히 대문자 ( &lt;code&gt;NAME&lt;/code&gt; )로 시작하는 해시 키 사용은 일반 소문자 문자열이 &lt;code&gt;=&amp;gt;&lt;/code&gt; 연산자로 올바르게 처리되지 않은 이전 버전의 Perl의 유물입니다 . 일부 모듈은 역사적 이유로 또는 개인 스타일 문제로 대문자 또는 하이픈이있는 인수 키를 유지하지만 대부분의 새 모듈은 간단한 소문자 키를 사용해야합니다. 무엇을 선택하든 일관성을 유지하십시오!</target>
        </trans-unit>
        <trans-unit id="42f05d562fbd6250c25a2395c7f661a4ca156a47" translate="yes" xml:space="preserve">
          <source>The use of hash keys starting with a hyphen (&lt;code&gt;-name&lt;/code&gt;) or entirely in upper case (&lt;code&gt;NAME&lt;/code&gt;) is a relic of older versions of Perl in which ordinary lower case strings were not handled correctly by the &lt;code&gt;=&amp;gt;&lt;/code&gt; operator. While some modules retain uppercase or hyphenated argument keys for historical reasons or as a matter of personal style, most new modules should use simple lower case keys. Whatever you choose, be consistent!</source>
          <target state="translated">하이픈 ( &lt;code&gt;-name&lt;/code&gt; )으로 시작 하거나 완전히 대문자 ( &lt;code&gt;NAME&lt;/code&gt; )로 시작하는 해시 키의 사용은 &lt;code&gt;=&amp;gt;&lt;/code&gt; 연산자 가 일반 소문자 문자열을 올바르게 처리하지 못한 이전 버전의 Perl 유물입니다 . 일부 모듈은 역사적 이유로 또는 개인 스타일의 문제로 대문자 또는 하이픈으로 연결된 인수 키를 유지하지만 대부분의 새 모듈은 간단한 소문자 키를 사용해야합니다. 무엇을 선택하든 일관성을 유지하십시오!</target>
        </trans-unit>
        <trans-unit id="0181fb947fb2e09fe7658e112ec2fe9418c5503f" translate="yes" xml:space="preserve">
          <source>The use of interpreter-based threads in perl is officially &lt;a href=&quot;perlpolicy#discouraged&quot;&gt;discouraged&lt;/a&gt;.</source>
          <target state="translated">perl에서 인터프리터 기반 스레드를 사용하는 것은 공식적으로 &lt;a href=&quot;perlpolicy#discouraged&quot;&gt;권장되지 않습니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="74fecb64d5ab9c5206223686d13a4c9238b9c4d9" translate="yes" xml:space="preserve">
          <source>The use of one-shot &lt;code&gt;gzip&lt;/code&gt; above just reads from &lt;code&gt;$r-&amp;gt;filename&lt;/code&gt; and writes the compressed data to standard output.</source>
          <target state="translated">위의 원샷 &lt;code&gt;gzip&lt;/code&gt; 을 사용하면 &lt;code&gt;$r-&amp;gt;filename&lt;/code&gt; 에서 읽고 압축 된 데이터를 표준 출력에 씁니다.</target>
        </trans-unit>
        <trans-unit id="aa4d1599ed2c314509e371c80e5511844a0d9d78" translate="yes" xml:space="preserve">
          <source>The use of out of range code points was deprecated in Perl 5.24, and became a fatal error in Perl 5.28.</source>
          <target state="translated">범위를 벗어난 코드 포인트의 사용은 Perl 5.24에서 더 이상 사용되지 않으며 Perl 5.28에서 치명적인 오류가되었습니다.</target>
        </trans-unit>
        <trans-unit id="f9bd1a86a4853953267a9ded9b1645e890ed750a" translate="yes" xml:space="preserve">
          <source>The use of out of range code points was deprecated in Perl 5.24; as of Perl 5.28 using a code point exceeding &lt;code&gt;IV_MAX&lt;/code&gt; throws a fatal error.</source>
          <target state="translated">범위를 벗어난 코드 포인트는 Perl 5.24에서 더 이상 사용되지 않습니다. &lt;code&gt;IV_MAX&lt;/code&gt; 를 초과하는 코드 포인트를 사용하는 Perl 5.28 부터 치명적인 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="af3aa24ab804ebe0a65aee4289caba48448e851d" translate="yes" xml:space="preserve">
          <source>The use of parentheses around a &lt;b&gt;subpattern&lt;/b&gt; in a &lt;b&gt;regular expression&lt;/b&gt; to store the matched &lt;b&gt;substring&lt;/b&gt; as a &lt;b&gt;backreference&lt;/b&gt;. (Captured strings are also returned as a list in &lt;b&gt;list context&lt;/b&gt;.) See Camel chapter 5, &amp;ldquo;Pattern Matching&amp;rdquo;.</source>
          <target state="translated">&lt;b&gt;정규 표현식&lt;/b&gt; 에서 &lt;b&gt;하위 패턴&lt;/b&gt; 주위에 괄호 를 사용하여 일치하는 &lt;b&gt;하위 문자열&lt;/b&gt; 을 &lt;b&gt;역 참조&lt;/b&gt; 로 저장합니다 . 캡처 된 문자열은 &lt;b&gt;목록 컨텍스트&lt;/b&gt; 에서 &lt;b&gt;목록&lt;/b&gt; 으로 반환됩니다 . Camel 5 장, &quot;패턴 일치&quot;를 참조하십시오.&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="ceb3a7a104da1d4a198b733387677a08ee3ca395" translate="yes" xml:space="preserve">
          <source>The use of parenthesis can be used to capture parts of the input filename.</source>
          <target state="translated">괄호를 사용하여 입력 파일 이름의 일부를 캡처 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="379fb1c054bbd3152f276aaca35f049867852f33" translate="yes" xml:space="preserve">
          <source>The use of the following functions is discouraged as they are not actually testing functions and produce no diagnostics to help figure out what went wrong. They were written before &lt;code&gt;is_deeply()&lt;/code&gt; existed because I couldn't figure out how to display a useful diff of two arbitrary data structures.</source>
          <target state="translated">다음 기능은 실제로 기능을 테스트하지 않으며 문제를 파악하는 데 도움이되는 진단을 생성하지 않으므로 사용하지 않는 것이 좋습니다. 두 개의 임의 데이터 구조의 유용한 차이점을 표시하는 방법을 알 수 없기 때문에 &lt;code&gt;is_deeply()&lt;/code&gt; 존재하기 전에 작성되었습니다 .</target>
        </trans-unit>
        <trans-unit id="5b392cf4598b7c92d87fc443e5bf63773c90811b" translate="yes" xml:space="preserve">
          <source>The usenm option</source>
          <target state="translated">usenm 옵션</target>
        </trans-unit>
        <trans-unit id="977cdd9dc7908139553c49b2609de1c2c08baff9" translate="yes" xml:space="preserve">
          <source>The user id owning the file</source>
          <target state="translated">파일을 소유 한 사용자 ID</target>
        </trans-unit>
        <trans-unit id="5d40086458e1b194df3ff27c332046fe8de9903b" translate="yes" xml:space="preserve">
          <source>The user name that owns the file</source>
          <target state="translated">파일을 소유 한 사용자 이름</target>
        </trans-unit>
        <trans-unit id="9ab82377d9d8e711c9e229f8137ce74619a6f296" translate="yes" xml:space="preserve">
          <source>The user time is the amount of time the entire process spent on behalf of the user on this system executing this program.</source>
          <target state="translated">사용자 시간은이 프로그램을 실행하는이 시스템에서 사용자를 대신하여 전체 프로세스가 소비 한 시간입니다.</target>
        </trans-unit>
        <trans-unit id="244da933c00a6b886bfc62a46ed8d2ddfb906e87" translate="yes" xml:space="preserve">
          <source>The user who wants the memoization cache to be expired according to your policy will say so by writing</source>
          <target state="translated">정책에 따라 메모 캐시가 만료되기를 원하는 사용자는 다음과 같이 말합니다.</target>
        </trans-unit>
        <trans-unit id="bb2fd16359343bc75d33118c9751a1ecbc3d3037" translate="yes" xml:space="preserve">
          <source>The usual arithmetic (+,-,+=,-=) is also available on the objects.</source>
          <target state="translated">일반적인 산술 (+,-, + =,-=)도 객체에서 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c7334043434491bfd6d25a23b05fb6d156604749" translate="yes" xml:space="preserve">
          <source>The usual calling signature is</source>
          <target state="translated">일반적인 통화 서명은</target>
        </trans-unit>
        <trans-unit id="72046882a8fdaf30c0521d766b5cf67d3d264433" translate="yes" xml:space="preserve">
          <source>The usual idiom is:</source>
          <target state="translated">일반적인 관용구는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7ac11eaf69a957a9aa5638ad8debab406436e005" translate="yes" xml:space="preserve">
          <source>The usual method for terminating a thread is to &lt;a href=&quot;functions/return&quot;&gt;return EXPR&lt;/a&gt; from the entry point function with the appropriate return value(s).</source>
          <target state="translated">스레드를 종료하는 일반적인 방법 은 진입 점 함수에서 적절한 반환 값으로 &lt;a href=&quot;functions/return&quot;&gt;EXPR&lt;/a&gt; 을 반환 하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="9019b0c3813c3cf91527f6ac86d5eb12ae5c43b5" translate="yes" xml:space="preserve">
          <source>The usual method for terminating a thread is to &lt;a href=&quot;perlfunc#return-EXPR&quot;&gt;return()&lt;/a&gt; from the entry point function with the appropriate return value(s).</source>
          <target state="translated">스레드를 종료하는 일반적인 방법 은 적절한 반환 값을 사용하여 진입 점 함수에서 &lt;a href=&quot;perlfunc#return-EXPR&quot;&gt;return ()&lt;/a&gt; 하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="189fd1d4b573f9b0c1b1794439c343e0650165ef" translate="yes" xml:space="preserve">
          <source>The usual shell redirection symbols &lt;code&gt; | &lt;/code&gt; and &lt;code&gt;&amp;gt;&lt;/code&gt; are recognized by the cpan shell &lt;b&gt;only when surrounded by whitespace&lt;/b&gt;. So piping to pager or redirecting output into a file works somewhat as in a normal shell, with the stipulation that you must type extra spaces.</source>
          <target state="translated">일반적인 쉘 재 지정 기호 &lt;code&gt; | &lt;/code&gt; 와 &lt;code&gt;&amp;gt;&lt;/code&gt; CPAN 쉘에 의해 인식 &lt;b&gt;공백으로 둘러싸인 경우에만&lt;/b&gt; . 따라서 호출기로 파이핑하거나 파일로 출력을 리디렉션하면 추가 공백을 입력해야한다는 규정과 함께 일반 셸과 약간 다르게 작동합니다.</target>
        </trans-unit>
        <trans-unit id="f5284fa656dfbed57ca832128b9046307b6a8989" translate="yes" xml:space="preserve">
          <source>The usual warnings if it can't read or write the files involved.</source>
          <target state="translated">관련된 파일을 읽거나 쓸 수없는 경우 일반적인 경고입니다.</target>
        </trans-unit>
        <trans-unit id="9c1efd4c7ee39f810e92b8d45a9ddf28889531e0" translate="yes" xml:space="preserve">
          <source>The usual warnings if it cannot read or write the files involved.</source>
          <target state="translated">관련된 파일을 읽거나 쓸 수없는 경우 일반적인 경고입니다.</target>
        </trans-unit>
        <trans-unit id="22c79ee036d08be39b9326c3b9dab69e6aa2a162" translate="yes" xml:space="preserve">
          <source>The usually available constants are</source>
          <target state="translated">일반적으로 사용 가능한 상수는</target>
        </trans-unit>
        <trans-unit id="59963cc04cd3e99323ab911f21a23f907334eab6" translate="yes" xml:space="preserve">
          <source>The usually available constants are as follows.</source>
          <target state="translated">일반적으로 사용 가능한 상수는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2efc4102646dfcf9e84b807940c146f94356608b" translate="yes" xml:space="preserve">
          <source>The util.c:1716 is the source code file and line number.</source>
          <target state="translated">util.c : 1716은 소스 코드 파일과 줄 번호입니다.</target>
        </trans-unit>
        <trans-unit id="822e481a167310eec4961d968bbe1f00f0652d77" translate="yes" xml:space="preserve">
          <source>The utilities &lt;code&gt;c2ph&lt;/code&gt; and &lt;code&gt;pstruct&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;c2ph&lt;/code&gt; 및 &lt;code&gt;pstruct&lt;/code&gt; 유틸리티</target>
        </trans-unit>
        <trans-unit id="70f118979bfd7ebb716612c147525a5086ff812a" translate="yes" xml:space="preserve">
          <source>The utilities c2ph and pstruct</source>
          <target state="translated">c2ph 및 pstruct 유틸리티</target>
        </trans-unit>
        <trans-unit id="e3d163a1d052b62f7d060607d4bf6b7f91f9aa60" translate="yes" xml:space="preserve">
          <source>The v-strings are portable only up to v2147483647 (0x7FFF_FFFF), that's how far EBCDIC, or more precisely UTF-EBCDIC will go.</source>
          <target state="translated">v- 문자열은 최대 v2147483647 (0x7FFF_FFFF)까지만 이식 할 수 있습니다. 즉, EBCDIC 또는보다 정확하게 UTF-EBCDIC의 거리입니다.</target>
        </trans-unit>
        <trans-unit id="84e2770182dc038d9b47afe7e9b08eec9556b081" translate="yes" xml:space="preserve">
          <source>The v5.16 release also supports a &lt;code&gt;:loose&lt;/code&gt; import for loose matching of character names, which works just like loose matching of property names: that is, it disregards case, whitespace, and underscores:</source>
          <target state="translated">v5.16 릴리스는 또한 문자 이름의 느슨한 일치를 위해 &lt;code&gt;:loose&lt;/code&gt; import를 지원합니다 . 이는 속성 이름의 느슨한 일치와 같이 작동합니다. 즉, 대소 문자, 공백 및 밑줄을 무시합니다.</target>
        </trans-unit>
        <trans-unit id="b193f0ebc1769a16dcfcc639a8401c8c00cf9c0e" translate="yes" xml:space="preserve">
          <source>The valgrind tool can be used to find out both memory leaks and illegal heap memory accesses. As of version 3.3.0, Valgrind only supports Linux on x86, x86-64 and PowerPC and Darwin (OS X) on x86 and x86-64). The special &quot;test.valgrind&quot; target can be used to run the tests under valgrind. Found errors and memory leaks are logged in files named</source>
          <target state="translated">valgrind 도구를 사용하여 메모리 누수와 불법 힙 메모리 액세스를 모두 찾을 수 있습니다. 버전 3.3.0부터 Valgrind는 x86, x86-64의 Linux 및 x86 및 x86-64의 PowerPC 및 Darwin (OS X) 만 지원합니다. 특수 &quot;test.valgrind&quot;대상을 사용하여 valgrind에서 테스트를 실행할 수 있습니다. 발견 된 오류 및 메모리 누수가 이름이 지정된 파일에 기록됩니다.</target>
        </trans-unit>
        <trans-unit id="d0c464474306348983509bffccc9878d55f4fc97" translate="yes" xml:space="preserve">
          <source>The valgrind tool can be used to find out both memory leaks and illegal heap memory accesses. As of version 3.3.0, Valgrind only supports Linux on x86, x86-64 and PowerPC and Darwin (OS X) on x86 and x86-64. The special &quot;test.valgrind&quot; target can be used to run the tests under valgrind. Found errors and memory leaks are logged in files named</source>
          <target state="translated">valgrind 도구를 사용하여 메모리 누수와 잘못된 힙 메모리 액세스를 모두 찾을 수 있습니다. 버전 3.3.0부터 Valgrind는 x86, x86-64에서 Linux, x86 및 x86-64에서 PowerPC 및 Darwin (OS X) 만 지원합니다. 특수 &quot;test.valgrind&quot;대상을 사용하여 valgrind에서 테스트를 실행할 수 있습니다. 발견 된 오류 및 메모리 누수는 다음과 같은 파일에 기록됩니다.</target>
        </trans-unit>
        <trans-unit id="aa3e07c88c6113557baab8df17b4983a954a8994" translate="yes" xml:space="preserve">
          <source>The value assigned to the key &lt;code&gt;'fallback'&lt;/code&gt; tells Perl how hard it should try to find an alternative way to implement a missing operator.</source>
          <target state="translated">&lt;code&gt;'fallback'&lt;/code&gt; 키에 할당 된 값 은 Perl에게 누락 된 연산자를 구현하는 다른 방법을 찾는 데 얼마나 어려운지를 알려줍니다.</target>
        </trans-unit>
        <trans-unit id="6f766eba2f1a65e15d6582321bc30fe9d0e0e26a" translate="yes" xml:space="preserve">
          <source>The value associated with &lt;code&gt;env&lt;/code&gt; is itself a hashref that is matched against corresponding values in the &lt;code&gt;%ENV&lt;/code&gt; hash. Keys prefixed with &lt;code&gt;not_&lt;/code&gt; negates the corresponding match.</source>
          <target state="translated">&lt;code&gt;env&lt;/code&gt; 와 관련된 값 은 그 자체가 &lt;code&gt;%ENV&lt;/code&gt; 해시 의 해당 값과 일치하는 해시 참조입니다. &lt;code&gt;not_&lt;/code&gt; 접두사가 붙은 키 는 해당 일치를 무효화합니다.</target>
        </trans-unit>
        <trans-unit id="aa731dffe1d7c5a02c15e427c4d55ad58928d794" translate="yes" xml:space="preserve">
          <source>The value associated with &lt;code&gt;perlconfig&lt;/code&gt; is itself a hashref that is matched against corresponding values in the &lt;code&gt;%Config::Config&lt;/code&gt; hash living in the &lt;code&gt;Config.pm&lt;/code&gt; module. Keys prefixed with &lt;code&gt;not_&lt;/code&gt; negates the corresponding match.</source>
          <target state="translated">&lt;code&gt;perlconfig&lt;/code&gt; 와 관련된 값 은 &lt;code&gt;Config.pm&lt;/code&gt; 모듈 에있는 &lt;code&gt;%Config::Config&lt;/code&gt; 해시 의 해당 값과 일치하는 해시 참조 입니다. &lt;code&gt;not_&lt;/code&gt; 접두사가 붙은 키 는 해당 일치를 무효화합니다.</target>
        </trans-unit>
        <trans-unit id="86d758b44cf7d343d2636c283000a90f2b95ec68" translate="yes" xml:space="preserve">
          <source>The value for &lt;code&gt;$offset&lt;/code&gt; in Unix will be &lt;code&gt;0&lt;/code&gt; , but in Mac OS Classic will be some large number. &lt;code&gt;$offset&lt;/code&gt; can then be added to a Unix time value to get what should be the proper value on any system.</source>
          <target state="translated">Unix의 &lt;code&gt;$offset&lt;/code&gt; 값은 &lt;code&gt;0&lt;/code&gt; 이지만 Mac OS Classic에서는 큰 숫자입니다. 그런 다음 &lt;code&gt;$offset&lt;/code&gt; 을 Unix 시간 값에 추가하여 모든 시스템에서 적절한 값을 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9f9c34760dc2837fd17b567df1f5e5a179a637d8" translate="yes" xml:space="preserve">
          <source>The value for &lt;code&gt;$offset&lt;/code&gt; in Unix will be &lt;code&gt;0&lt;/code&gt;, but in Mac OS Classic will be some large number. &lt;code&gt;$offset&lt;/code&gt; can then be added to a Unix time value to get what should be the proper value on any system.</source>
          <target state="translated">Unix에서 &lt;code&gt;$offset&lt;/code&gt; 값은 &lt;code&gt;0&lt;/code&gt; 이지만 Mac OS Classic에서는 큰 숫자입니다. 그런 다음 &lt;code&gt;$offset&lt;/code&gt; 을 Unix 시간 값에 추가하여 모든 시스템에서 적절한 값을 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6a050ff582b3cdf570af43e605e700a8d71acf02" translate="yes" xml:space="preserve">
          <source>The value in each entry of the hash is what you are referring to when you use the &lt;code&gt;*name&lt;/code&gt; typeglob notation.</source>
          <target state="translated">해시의 각 항목 값은 &lt;code&gt;*name&lt;/code&gt; typeglob 표기법 을 사용할 때 참조하는 값입니다 .</target>
        </trans-unit>
        <trans-unit id="0f707479820ff9d25dbdd6e993639c9a31b93e20" translate="yes" xml:space="preserve">
          <source>The value is identical to &lt;code&gt;$Config{'osname'}&lt;/code&gt; . See also &lt;a href=&quot;config&quot;&gt;Config&lt;/a&gt; and the &lt;b&gt;-V&lt;/b&gt; command-line switch documented in &lt;a href=&quot;perlrun&quot;&gt;perlrun&lt;/a&gt;.</source>
          <target state="translated">값은 &lt;code&gt;$Config{'osname'}&lt;/code&gt; 과 동일합니다 . &lt;a href=&quot;perlrun&quot;&gt;perlrun에&lt;/a&gt; 문서화 된 &lt;a href=&quot;config&quot;&gt;Config&lt;/a&gt; 및 &lt;b&gt;-V&lt;/b&gt; 명령 행 스위치 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="78983deb0ac0844027ede959bcbb4cd4a4216250" translate="yes" xml:space="preserve">
          <source>The value is identical to &lt;code&gt;$Config{'osname'}&lt;/code&gt;. See also &lt;a href=&quot;config&quot;&gt;Config&lt;/a&gt; and the &lt;b&gt;-V&lt;/b&gt; command-line switch documented in &lt;a href=&quot;perlrun#-V&quot;&gt;perlrun&lt;/a&gt;.</source>
          <target state="translated">값은 &lt;code&gt;$Config{'osname'}&lt;/code&gt; 과 동일합니다 . &lt;a href=&quot;perlrun#-V&quot;&gt;perlrun에&lt;/a&gt; 문서화 된 &lt;a href=&quot;config&quot;&gt;Config&lt;/a&gt; 및 &lt;b&gt;-V&lt;/b&gt; 명령 줄 스위치 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="70b8122c0413fdd3eed692b348862e9493d569f3" translate="yes" xml:space="preserve">
          <source>The value of $side is</source>
          <target state="translated">$ side의 가치는</target>
        </trans-unit>
        <trans-unit id="31a20ded01fa49bc667d71f5d635d0f8fadc7fc6" translate="yes" xml:space="preserve">
          <source>The value of &lt;a href=&quot;perlvar#%24%5EO&quot;&gt;&lt;code&gt;$^O&lt;/code&gt;&lt;/a&gt; on OpenVMS is &quot;VMS&quot;. To determine the architecture that you are running on refer to &lt;a href=&quot;config#archname&quot;&gt;&lt;code&gt;$Config{archname}&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">OpenVMS 에서 &lt;a href=&quot;perlvar#%24%5EO&quot;&gt; &lt;code&gt;$^O&lt;/code&gt; &lt;/a&gt; 의 값 은 &quot;VMS&quot;입니다. 실행중인 아키텍처를 확인하려면 &lt;a href=&quot;config#archname&quot;&gt; &lt;code&gt;$Config{archname}&lt;/code&gt; &lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="773190d7908d36ab9698d1cdc21dc993faf50e45" translate="yes" xml:space="preserve">
          <source>The value of &lt;a href=&quot;perlvar#%24%5EO&quot;&gt;&lt;code&gt;$^O&lt;/code&gt;&lt;/a&gt; on VOS is &quot;vos&quot;. To determine the architecture that you are running on refer to &lt;a href=&quot;config#archname&quot;&gt;&lt;code&gt;$Config{archname}&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">VOS 에서 &lt;a href=&quot;perlvar#%24%5EO&quot;&gt; &lt;code&gt;$^O&lt;/code&gt; &lt;/a&gt; 의 값 은 &quot;vos&quot;입니다. 실행중인 아키텍처를 확인하려면 &lt;a href=&quot;config#archname&quot;&gt; &lt;code&gt;$Config{archname}&lt;/code&gt; &lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ed978648f213fc988aacb1860e0d05dc9fcc12a7" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;$!&lt;/code&gt; at the time when the exception occurred.</source>
          <target state="translated">&lt;code&gt;$!&lt;/code&gt; 의 가치 예외가 발생했을 때.</target>
        </trans-unit>
        <trans-unit id="495d3ee61dabdfbea0b627a5268ea9c708b5aa50" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;$?&lt;/code&gt; when the context was created.</source>
          <target state="translated">&lt;code&gt;$?&lt;/code&gt; 의 가치 ? 컨텍스트가 생성되었을 때.</target>
        </trans-unit>
        <trans-unit id="64ad0b97e1d614d4823576a0d2d5c3aedd5bf44c" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;$@&lt;/code&gt; when the context was created.</source>
          <target state="translated">컨텍스트가 생성되었을 때 &lt;code&gt;$@&lt;/code&gt; 의 값입니다 .</target>
        </trans-unit>
        <trans-unit id="9f3e350bc3160e2ef2f10c200798865cfdef3abe" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;$Config{sitelib}&lt;/code&gt; is also determined in C code and not read from &lt;code&gt;Config.pm&lt;/code&gt; , which is not loaded.</source>
          <target state="translated">&lt;code&gt;$Config{sitelib}&lt;/code&gt; 의 값 도 C 코드로 결정되며 로드되지 않은 &lt;code&gt;Config.pm&lt;/code&gt; 에서 읽지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e9e93b8ce5897e26af26e26d476dcd12a339350a" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;$Config{sitelib}&lt;/code&gt; is also determined in C code and not read from &lt;code&gt;Config.pm&lt;/code&gt;, which is not loaded.</source>
          <target state="translated">&lt;code&gt;$Config{sitelib}&lt;/code&gt; 의 값은 C 코드에서도 결정되며 로드되지 않은 &lt;code&gt;Config.pm&lt;/code&gt; 에서 읽지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5ec5b14ed87db6c409cf2d38c4b2eab23f206eae" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;$^O&lt;/code&gt; on OpenVMS is &quot;VMS&quot;. To determine the architecture that you are running on refer to &lt;code&gt;$Config{'archname'}&lt;/code&gt; .</source>
          <target state="translated">OpenVMS 에서 &lt;code&gt;$^O&lt;/code&gt; 의 값 은 &quot;VMS&quot;입니다. 실행중인 아키텍처를 판별하려면 &lt;code&gt;$Config{'archname'}&lt;/code&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0a38163b3b1097c345c4ed53de76d7f29841da7e" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;$^O&lt;/code&gt; on VOS is &quot;vos&quot;. To determine the architecture that you are running on without resorting to loading all of &lt;code&gt;%Config&lt;/code&gt; you can examine the content of the &lt;code&gt;@INC&lt;/code&gt; array like so:</source>
          <target state="translated">VOS 에서 &lt;code&gt;$^O&lt;/code&gt; 의 값 은 &quot;vos&quot;입니다. 모든 &lt;code&gt;%Config&lt;/code&gt; 를로드하지 않고 실행중인 아키텍처를 확인하려면 다음 과 같이 &lt;code&gt;@INC&lt;/code&gt; 배열 의 내용을 검사 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0b11ba94deca518a1e2cfb4f0d2fd72a2e75493b" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;$_&lt;/code&gt; when the sub returns will be stored in the filename header field.</source>
          <target state="translated">하위 반환시 &lt;code&gt;$_&lt;/code&gt; 값은 파일 이름 헤더 필드에 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="623588465c88b3488f6369fa12fbc193d14ce397" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;$_&lt;/code&gt; when the sub returns will be used as the</source>
          <target state="translated">하위 반환시 &lt;code&gt;$_&lt;/code&gt; 값은</target>
        </trans-unit>
        <trans-unit id="e887b08023c56383b67ea2dd8816e1569e2d83d2" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;flags&lt;/code&gt; determines the behavior when &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; does not point to a well-formed UTF-8 character. If &lt;code&gt;flags&lt;/code&gt; is 0, when a malformation is found, zero is returned and &lt;code&gt;*retlen&lt;/code&gt; is set so that (&lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; + &lt;code&gt;*retlen&lt;/code&gt; ) is the next possible position in &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; that could begin a non-malformed character. Also, if UTF-8 warnings haven't been lexically disabled, a warning is raised.</source>
          <target state="translated">&lt;code&gt;flags&lt;/code&gt; 값은 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; 가 올바른 형식의 UTF-8 문자를 가리 키지 않을 때 의 동작을 결정합니다 . 경우 &lt;code&gt;flags&lt;/code&gt; 기형이 발견 0이고, 0이 리턴되며, &lt;code&gt;*retlen&lt;/code&gt; 그 (있도록 설정 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; + &lt;code&gt;*retlen&lt;/code&gt; 가 )의 다음 가능한 위치 인 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; 비 잘못된 문자를 시작할 수 있습니다. 또한 UTF-8 경고가 사 전적으로 비활성화되지 않은 경우 경고가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="2605ec2ff838d0693c21dd89f119bc12d32e8a67" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;flags&lt;/code&gt; determines the behavior when &lt;code&gt;s&lt;/code&gt; does not point to a well-formed UTF-8 character. If &lt;code&gt;flags&lt;/code&gt; is 0, encountering a malformation causes zero to be returned and &lt;code&gt;*retlen&lt;/code&gt; is set so that (&lt;code&gt;s&lt;/code&gt; + &lt;code&gt;*retlen&lt;/code&gt;) is the next possible position in &lt;code&gt;s&lt;/code&gt; that could begin a non-malformed character. Also, if UTF-8 warnings haven't been lexically disabled, a warning is raised. Some UTF-8 input sequences may contain multiple malformations. This function tries to find every possible one in each call, so multiple warnings can be raised for the same sequence.</source>
          <target state="translated">&lt;code&gt;flags&lt;/code&gt; 의 값은 &lt;code&gt;s&lt;/code&gt; 가 올바른 형식의 UTF-8 문자를 가리 키지 않을 때 의 동작을 결정합니다 . 경우 &lt;code&gt;flags&lt;/code&gt; 기형을 발생, 0 원인은 반환 할 제로 &lt;code&gt;*retlen&lt;/code&gt; 는 그 (있도록 설정 &lt;code&gt;s&lt;/code&gt; + &lt;code&gt;*retlen&lt;/code&gt; 가 )의 다음 가능한 위치 인 &lt;code&gt;s&lt;/code&gt; 비 잘못된 문자를 시작할 수 있습니다. 또한 UTF-8 경고가 어휘 적으로 비활성화되지 않은 경우 경고가 발생합니다. 일부 UTF-8 입력 시퀀스에는 여러 기형이 포함될 수 있습니다. 이 함수는 각 호출에서 가능한 모든 항목을 찾으려고하므로 동일한 시퀀스에 대해 여러 경고가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6c4b4f2983d220858913f6137ac2e8d4d0fdf8f5" translate="yes" xml:space="preserve">
          <source>The value of a character (&lt;code&gt;&lt;a href=&quot;functions/ord&quot;&gt;ord&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr&lt;/a&gt;&lt;/code&gt;) is the corresponding Unicode code point.</source>
          <target state="translated">문자 값 ( &lt;code&gt;&lt;a href=&quot;functions/ord&quot;&gt;ord&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr&lt;/a&gt;&lt;/code&gt; )은 해당 유니 코드 코드 포인트입니다.</target>
        </trans-unit>
        <trans-unit id="77376c07ae757b89b1359df5120af7875474ea9a" translate="yes" xml:space="preserve">
          <source>The value of a character (&lt;code&gt;ord&lt;/code&gt;, &lt;code&gt;chr&lt;/code&gt;) is the corresponding Unicode code point.</source>
          <target state="translated">문자 값 ( &lt;code&gt;ord&lt;/code&gt; , &lt;code&gt;chr&lt;/code&gt; )은 해당 유니 코드 코드 포인트입니다.</target>
        </trans-unit>
        <trans-unit id="920c1e9d793047c1281d1ee5cb5fb337f4ae7f17" translate="yes" xml:space="preserve">
          <source>The value of an attribute may itself be another object. For example, instead of returning its last mod time as a number, the &lt;code&gt;File&lt;/code&gt; class could return a &lt;a href=&quot;datetime&quot;&gt;DateTime&lt;/a&gt; object representing that value.</source>
          <target state="translated">속성의 값은 그 자체가 다른 객체 일 수 있습니다. 예를 들어, 마지막 모드 시간을 숫자로 반환하는 대신 &lt;code&gt;File&lt;/code&gt; 클래스 는 해당 값을 나타내는 &lt;a href=&quot;datetime&quot;&gt;DateTime&lt;/a&gt; 개체를 반환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4e567ba2156b576b88f1e773ff7f64942df23743" translate="yes" xml:space="preserve">
          <source>The value of an attribute may itself be another object. For example, instead of returning its last mod time as a number, the &lt;code&gt;File&lt;/code&gt; class could return a &lt;a href=&quot;http://search.cpan.org/perldoc/DateTime&quot;&gt;DateTime&lt;/a&gt; object representing that value.</source>
          <target state="translated">속성 자체의 값은 다른 객체 일 수 있습니다. 예를 들어, 마지막 모드 시간을 숫자로 반환하는 대신 &lt;code&gt;File&lt;/code&gt; 클래스 는 해당 값을 나타내는 &lt;a href=&quot;http://search.cpan.org/perldoc/DateTime&quot;&gt;DateTime&lt;/a&gt; 객체를 반환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b0e6c192bc663d6d0a358f12fd16e1e3c9bf344d" translate="yes" xml:space="preserve">
          <source>The value of any Unicode (not including Perl extensions) character property mentioned above for any single code point is available through &lt;a href=&quot;Unicode::UCD#charprop%28%29&quot;&gt;&quot;charprop()&quot; in Unicode::UCD&lt;/a&gt;. &lt;a href=&quot;Unicode::UCD#charprops_all%28%29&quot;&gt;&quot;charprops_all()&quot; in Unicode::UCD&lt;/a&gt; returns the values of all the Unicode properties for a given code point.</source>
          <target state="translated">단일 코드 포인트에 대해 위에서 언급 한 모든 유니 코드 (Perl 확장을 포함하지 않음) 문자 속성의 값은 &lt;a href=&quot;Unicode::UCD#charprop%28%29&quot;&gt;Unicode :: UCD의 &quot;charprop ()&quot;를&lt;/a&gt; 통해 사용할 수 있습니다 . &lt;a href=&quot;Unicode::UCD#charprops_all%28%29&quot;&gt;Unicode :: UCD의 &quot;charprops_all ()&quot;&lt;/a&gt; 은 주어진 코드 포인트에 대한 모든 유니 코드 속성의 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="4be98eb05f5630113ca4199a823f81cc002596a7" translate="yes" xml:space="preserve">
          <source>The value of any Unicode (not including Perl extensions) character property mentioned above for any single code point is available through &lt;a href=&quot;unicode/ucd#charprop()&quot;&gt;charprop() in Unicode::UCD&lt;/a&gt;. &lt;a href=&quot;unicode/ucd#charprops_all()&quot;&gt;charprops_all() in Unicode::UCD&lt;/a&gt; returns the values of all the Unicode properties for a given code point.</source>
          <target state="translated">단일 코드 포인트에 대해 위에서 언급 한 모든 유니 코드 (Perl 확장자를 포함하지 않음) 문자 특성의 값은 &lt;a href=&quot;unicode/ucd#charprop()&quot;&gt;Unicode :: UCD의 charprop ()를&lt;/a&gt; 통해 사용할 수 있습니다 . &lt;a href=&quot;unicode/ucd#charprops_all()&quot;&gt;Unicode :: UCD의 charprops_all ()은&lt;/a&gt; 주어진 코드 포인트에 대한 모든 유니 코드 속성의 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="81fc623a108af3428235cbe74b6771e41c797430" translate="yes" xml:space="preserve">
          <source>The value of revision comes from the</source>
          <target state="translated">개정의 가치는</target>
        </trans-unit>
        <trans-unit id="c5c1cdba3a8acef681606512f4cdff2bb03f5d89" translate="yes" xml:space="preserve">
          <source>The value of the</source>
          <target state="translated">가치</target>
        </trans-unit>
        <trans-unit id="7754c871491afddea48233869a135f618ec6e6a4" translate="yes" xml:space="preserve">
          <source>The value of the &lt;code&gt;...Host&lt;/code&gt; argument will be split to give both the hostname and port (or service name):</source>
          <target state="translated">&lt;code&gt;...Host&lt;/code&gt; 인수 의 값은 호스트 이름과 포트 (또는 서비스 이름)를 모두 제공하도록 분할됩니다.</target>
        </trans-unit>
        <trans-unit id="96cb89717e8339762098eca6a52dfe1d75c52296" translate="yes" xml:space="preserve">
          <source>The value of the &lt;code&gt;flags&lt;/code&gt; hint to getaddrinfo(), or the $flags parameter to getnameinfo() contains unrecognised flags.</source>
          <target state="translated">getaddrinfo () 에 대한 &lt;code&gt;flags&lt;/code&gt; 힌트 또는 getnameinfo ()에 대한 $ flags 매개 변수에 인식 할 수없는 플래그가 있습니다.</target>
        </trans-unit>
        <trans-unit id="de2c00bdfe45ec53f217b88f118a8da5474d909d" translate="yes" xml:space="preserve">
          <source>The value of the ADLER32 field read must match the adler32 value of the uncompressed data actually contained in the file.</source>
          <target state="translated">읽은 ADLER32 필드의 값은 실제로 파일에 포함 된 압축되지 않은 데이터의 adler32 값과 일치해야합니다.</target>
        </trans-unit>
        <trans-unit id="932cb4d9b33ea8ac456d8558a4c42d4644723cbc" translate="yes" xml:space="preserve">
          <source>The value of the CRC32 field read must match the crc32 value of the uncompressed data actually contained in the gzip file.</source>
          <target state="translated">읽은 CRC32 필드의 값은 gzip 파일에 실제로 포함 된 압축되지 않은 데이터의 crc32 값과 일치해야합니다.</target>
        </trans-unit>
        <trans-unit id="7e9f5de9a38d28729524674757f04e1cb2068248" translate="yes" xml:space="preserve">
          <source>The value of the ISIZE fields read must match the length of the uncompressed data actually read from the file.</source>
          <target state="translated">읽은 ISIZE 필드의 값은 실제로 파일에서 읽은 압축되지 않은 데이터의 길이와 일치해야합니다.</target>
        </trans-unit>
        <trans-unit id="6975eb5b4fde16e6c94a6652320983d4f157fb4c" translate="yes" xml:space="preserve">
          <source>The value of the OP's SV, if it has one, in a short human-readable format.</source>
          <target state="translated">OP의 SV 값 (있는 경우)은 사람이 읽을 수있는 짧은 형식입니다.</target>
        </trans-unit>
        <trans-unit id="335bddece83d92e99066c5c702486489e5db8aca" translate="yes" xml:space="preserve">
          <source>The value of the function is not being passed back as the function's return value, but by changing the value of the variable that was passed into the function. You might have guessed that when you saw that the return value of round is of type &quot;void&quot;.</source>
          <target state="translated">함수의 값은 함수의 반환 값으로 다시 전달되지 않고 함수에 전달 된 변수의 값을 변경하여 전달됩니다. round의 리턴 값이 &quot;void&quot;유형 인 것을 보았을 것입니다.</target>
        </trans-unit>
        <trans-unit id="332bfecdbc3324ed6709a244ef3af16edb8104ba" translate="yes" xml:space="preserve">
          <source>The value of the last evaluated expression of the &lt;code&gt;given&lt;/code&gt; block if no condition is true.</source>
          <target state="translated">조건이 참이 아닌 경우 &lt;code&gt;given&lt;/code&gt; 블록 의 마지막으로 평가 된 표현식의 값입니다 .</target>
        </trans-unit>
        <trans-unit id="77cf8495b50e92c33dbdf25b33ef15173c2d3541" translate="yes" xml:space="preserve">
          <source>The value of the last evaluated expression of the successful &lt;code&gt;when&lt;/code&gt; /&lt;code&gt;default&lt;/code&gt; clause, if there happens to be one.</source>
          <target state="translated">성공한 &lt;code&gt;when&lt;/code&gt; / &lt;code&gt;default&lt;/code&gt; 절이있는 경우 마지막으로 평가 된 표현식의 값입니다 (있는 경우).</target>
        </trans-unit>
        <trans-unit id="658f9d607f7e2f28f592626f4c387f2ebc102faa" translate="yes" xml:space="preserve">
          <source>The value of the last evaluated expression of the successful &lt;code&gt;when&lt;/code&gt;/&lt;code&gt;default&lt;/code&gt; clause, if there happens to be one.</source>
          <target state="translated">성공한 &lt;code&gt;when&lt;/code&gt; / &lt;code&gt;default&lt;/code&gt; 절의 마지막으로 평가 된 표현식의 값입니다 (있는 경우).</target>
        </trans-unit>
        <trans-unit id="f55ec6306f776bf3aa6ec09d7496286d68bd8fba" translate="yes" xml:space="preserve">
          <source>The value of this expression will be TRUE if &lt;code&gt;$var&lt;/code&gt; contains that sequence of characters, and FALSE otherwise. The portion enclosed in &lt;code&gt;'/'&lt;/code&gt; characters denotes the characteristic we are looking for. We use the term</source>
          <target state="translated">이 표현식의 값은 &lt;code&gt;$var&lt;/code&gt; 에 해당 문자 시퀀스가 ​​포함되어 있으면 TRUE가 되고 그렇지 않으면 FALSE가됩니다. &lt;code&gt;'/'&lt;/code&gt; 문자로 묶인 부분 은 우리가 찾고있는 특성을 나타냅니다. 우리는 용어를 사용합니다</target>
        </trans-unit>
        <trans-unit id="e9dbf107286e577746464279a9f4d776045ba7e1" translate="yes" xml:space="preserve">
          <source>The value returned by &lt;code&gt;&lt;a href=&quot;functions/crypt&quot;&gt;crypt&lt;/a&gt;&lt;/code&gt; may be compared against the encrypted password from the UAF returned by the &lt;code&gt;getpw*&lt;/code&gt; functions, in order to authenticate users. If you're going to do this, remember that the encrypted password in the UAF was generated using uppercase username and password strings; you'll have to upcase the arguments to &lt;code&gt;&lt;a href=&quot;functions/crypt&quot;&gt;crypt&lt;/a&gt;&lt;/code&gt; to insure that you'll get the proper value:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/crypt&quot;&gt;crypt&lt;/a&gt;&lt;/code&gt; 에 의해 리턴 된 값은 사용자를 인증하기 위해 &lt;code&gt;getpw*&lt;/code&gt; 함수에 의해 리턴 된 UAF의 암호화 된 비밀번호와 비교 될 수 있습니다 . 이 작업을 수행하려면 UAF의 암호화 된 비밀번호가 대문자 사용자 이름 및 비밀번호 문자열을 사용하여 생성되었다는 것을 기억하십시오. 적절한 가치를 얻으려면 &lt;code&gt;&lt;a href=&quot;functions/crypt&quot;&gt;crypt&lt;/a&gt;&lt;/code&gt; 하기 위해 인수를 대문자 로 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="750d57c2b28689ee366bb45cb08dd596ede16734" translate="yes" xml:space="preserve">
          <source>The value returned by &lt;code&gt;&lt;a href=&quot;functions/tell&quot;&gt;tell&lt;/a&gt;&lt;/code&gt; may be affected after the call, and the filehandle may be flushed. (Win32)</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/tell&quot;&gt;tell&lt;/a&gt;&lt;/code&gt; 에 의해 반환 된 값 은 호출 후 영향을받을 수 있으며 파일 핸들이 플러시 될 수 있습니다. (Win32)</target>
        </trans-unit>
        <trans-unit id="b9eb02fecf7e78b1a88f2675d747749b95555376" translate="yes" xml:space="preserve">
          <source>The value returned by &lt;code&gt;&lt;a href=&quot;functions/time&quot;&gt;time&lt;/a&gt;&lt;/code&gt; is the offset in seconds from 01-JAN-1970 00:00:00 (just like the CRTL's times() routine), in order to make life easier for code coming in from the POSIX/Unix world.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/time&quot;&gt;time&lt;/a&gt;&lt;/code&gt; 에 의해 반환되는 값 은 POSIX / Unix 세계에서 들어오는 코드를보다 쉽게 ​​만들기 위해 01-JAN-1970 00:00:00 (CRTL의 times () 루틴과 동일)에서 초 단위 오프셋입니다.</target>
        </trans-unit>
        <trans-unit id="d9cf508ed581e40b436f75a599821b5c9826f4e6" translate="yes" xml:space="preserve">
          <source>The value returned by &lt;code&gt;crypt&lt;/code&gt; may be compared against the encrypted password from the UAF returned by the &lt;code&gt;getpw*&lt;/code&gt; functions, in order to authenticate users. If you're going to do this, remember that the encrypted password in the UAF was generated using uppercase username and password strings; you'll have to upcase the arguments to &lt;code&gt;crypt&lt;/code&gt; to insure that you'll get the proper value:</source>
          <target state="translated">사용자를 인증하기 위해 &lt;code&gt;crypt&lt;/code&gt; 에서 반환 된 값을 &lt;code&gt;getpw*&lt;/code&gt; 함수에서 반환 한 UAF의 암호화 된 암호와 비교할 수 있습니다 . 이렇게하려면 UAF의 암호화 된 암호가 대문자 사용자 이름과 암호 문자열을 사용하여 생성되었음을 기억하십시오. 적절한 값을 얻을 수 있도록 &lt;code&gt;crypt&lt;/code&gt; 에 대한 인수를 대등 해야합니다.</target>
        </trans-unit>
        <trans-unit id="50fe607f9117d605b4d45bd6d7204d58d2fef28d" translate="yes" xml:space="preserve">
          <source>The value returned by &lt;code&gt;time&lt;/code&gt; is the offset in seconds from 01-JAN-1970 00:00:00 (just like the CRTL's times() routine), in order to make life easier for code coming in from the POSIX/Unix world.</source>
          <target state="translated">&lt;code&gt;time&lt;/code&gt; 에 의해 반환 된 값 은 POSIX / Unix 세계에서 들어오는 코드의 삶을 더 쉽게 만들기 위해 01-JAN-1970 00:00:00 (CRTL의 times () 루틴과 마찬가지로)의 오프셋 (초)입니다.</target>
        </trans-unit>
        <trans-unit id="dce33a69a270de7fcb08010c8a7a1e528d7b525f" translate="yes" xml:space="preserve">
          <source>The value returned by DELETE becomes the return value of the call to delete(). If you want to emulate the normal behavior of delete(), you should return whatever FETCH would have returned for this key. In this example, we have chosen instead to return a value which tells the caller whether the file was successfully deleted.</source>
          <target state="translated">DELETE가 리턴 한 값은 delete () 호출의 리턴 값이됩니다. delete ()의 정상적인 동작을 에뮬레이션하려면이 키에 대해 반환 된 모든 FETCH를 반환해야합니다. 이 예에서는 대신 파일이 성공적으로 삭제되었는지 여부를 호출자에게 알려주는 값을 반환하도록 선택했습니다.</target>
        </trans-unit>
        <trans-unit id="6bc17f7cca700d462e95542bbd03b318a3e0be44" translate="yes" xml:space="preserve">
          <source>The value returned by the</source>
          <target state="translated">에 의해 반환되는 값</target>
        </trans-unit>
        <trans-unit id="b1bca5853c9e5fa5adb4f19b1edc9ad3fc182540" translate="yes" xml:space="preserve">
          <source>The value returned from the</source>
          <target state="translated">에서 반환 된 값</target>
        </trans-unit>
        <trans-unit id="d7686ece8175813a2cb013172fefbbbe14b8eb04" translate="yes" xml:space="preserve">
          <source>The value returned is the new-style (see &lt;a href=&quot;#Old-style-versus-new-style-block-names&quot;&gt;&quot;Old-style versus new-style block names&quot;&lt;/a&gt;).</source>
          <target state="translated">반환 된 값은 새 스타일입니다 ( &lt;a href=&quot;#Old-style-versus-new-style-block-names&quot;&gt;&quot;이전 스타일 대 새 스타일 블록 이름&quot;참조&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="90d9e575a1b77ab1385aca4b943feac671ed7f01" translate="yes" xml:space="preserve">
          <source>The value returned is the new-style (see &lt;a href=&quot;#Old-style-versus-new-style-block-names&quot;&gt;Old-style versus new-style block names&lt;/a&gt;).</source>
          <target state="translated">리턴 된 값은 새 스타일입니다 ( &lt;a href=&quot;#Old-style-versus-new-style-block-names&quot;&gt;이전 스타일 대 새 스타일 블록 이름 참조&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="c04520f682b85fb43c817253d00adbc0066c3e0a" translate="yes" xml:space="preserve">
          <source>The value returned is the scalar itself, if the argument is a scalar, or a reference, if the argument is a hash, array or subroutine.</source>
          <target state="translated">인수가 스칼라이거나 인수가 해시, 배열 또는 서브 루틴 인 경우 참조 인 경우 리턴되는 값은 스칼라 자체입니다.</target>
        </trans-unit>
        <trans-unit id="942e5b04dedd3b9d9ca5012565213fea51195584" translate="yes" xml:space="preserve">
          <source>The value returned should correspond to the new text to use in its place If the empty string is returned or an undefined value is returned, then the given &lt;code&gt;$text&lt;/code&gt; is ignored (not processed).</source>
          <target state="translated">빈 문자열이 반환되거나 정의되지 않은 값이 반환되면 지정된 &lt;code&gt;$text&lt;/code&gt; 가 무시됩니다 (처리되지 않음).</target>
        </trans-unit>
        <trans-unit id="8dccf8bfa93428dffce75a953ae318dc76ebcb1f" translate="yes" xml:space="preserve">
          <source>The value returned should correspond to the new text to use in its place. If the empty string or an undefined value is returned then no further processing will be performed for this line.</source>
          <target state="translated">반환 된 값은 대신 사용할 새 텍스트와 일치해야합니다. 빈 문자열 또는 정의되지 않은 값이 리턴되면이 행에 대한 추가 처리가 수행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="55279d7373f25daebc72a715903f6a4795228bf8" translate="yes" xml:space="preserve">
          <source>The value returned will be true if the &lt;code&gt;$paragraph&lt;/code&gt; and the rest of the text in the same section as &lt;code&gt;$paragraph&lt;/code&gt; should be selected (included) for processing; otherwise a false value is returned.</source>
          <target state="translated">경우 생성 반환되는 값에 해당 할 것이다 &lt;code&gt;$paragraph&lt;/code&gt; 과 같은 섹션의 나머지 텍스트 &lt;code&gt;$paragraph&lt;/code&gt; 처리 선택 (포함)한다; 그렇지 않으면 거짓 값이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="10aaf64078984131d35f43803e32214eb7af6f36" translate="yes" xml:space="preserve">
          <source>The value should be a code reference. It is invoked just before leaving the currently processed directory. It is called in void context with no arguments. The name of the current directory is in &lt;code&gt;$File::Find::dir&lt;/code&gt; . This hook is handy for summarizing a directory, such as calculating its disk usage. When</source>
          <target state="translated">값은 코드 참조 여야합니다. 현재 처리 된 디렉토리를 떠나기 직전에 호출됩니다. 인수없이 void 컨텍스트에서 호출됩니다. 현재 디렉토리의 이름은 &lt;code&gt;$File::Find::dir&lt;/code&gt; 입니다. 이 후크는 디스크 사용량 계산과 같은 디렉토리를 요약하는 데 유용합니다. 언제</target>
        </trans-unit>
        <trans-unit id="704f4eb234b60fc2ba78db6c9fbae91192095f92" translate="yes" xml:space="preserve">
          <source>The value should be a code reference. It is invoked just before leaving the currently processed directory. It is called in void context with no arguments. The name of the current directory is in &lt;code&gt;$File::Find::dir&lt;/code&gt;. This hook is handy for summarizing a directory, such as calculating its disk usage. When</source>
          <target state="translated">값은 코드 참조 여야합니다. 현재 처리 된 디렉토리를 떠나기 직전에 호출됩니다. 인수없이 void 컨텍스트에서 호출됩니다. 현재 디렉토리의 이름은 &lt;code&gt;$File::Find::dir&lt;/code&gt; 있습니다. 이 후크는 디스크 사용량 계산과 같이 디렉토리를 요약하는 데 유용합니다. 언제</target>
        </trans-unit>
        <trans-unit id="f1ae9d02429326a11943298c08065d301c422900" translate="yes" xml:space="preserve">
          <source>The value should be a code reference. This code reference is described in &lt;a href=&quot;#The-wanted-function&quot;&gt;&quot;The wanted function&quot;&lt;/a&gt; below. The &lt;code&gt;&amp;amp;wanted&lt;/code&gt; subroutine is mandatory.</source>
          <target state="translated">값은 코드 참조 여야합니다. 이 코드 참조는 아래 &lt;a href=&quot;#The-wanted-function&quot;&gt;&quot;원하는 함수&quot;에&lt;/a&gt; 설명되어 있습니다. &lt;code&gt;&amp;amp;wanted&lt;/code&gt; 서브 루틴은 필수입니다.</target>
        </trans-unit>
        <trans-unit id="ddbdffc9717f2bba2ebf5303cd71401d0bf2a249" translate="yes" xml:space="preserve">
          <source>The value should be a code reference. This code reference is described in &lt;a href=&quot;#The-wanted-function&quot;&gt;The wanted function&lt;/a&gt; below. The &lt;code&gt;&amp;amp;wanted&lt;/code&gt; subroutine is mandatory.</source>
          <target state="translated">값은 코드 참조 여야합니다. 이 코드 참조는 아래 &lt;a href=&quot;#The-wanted-function&quot;&gt;의 원하는 기능에&lt;/a&gt; 설명되어 있습니다. &lt;code&gt;&amp;amp;wanted&lt;/code&gt; 서브 루틴은 필수입니다.</target>
        </trans-unit>
        <trans-unit id="444cd91bd48610204aa4348a8cd314eec59c4347" translate="yes" xml:space="preserve">
          <source>The value should be a code reference. This code reference is used to preprocess the current directory. The name of the currently processed directory is in &lt;code&gt;$File::Find::dir&lt;/code&gt; . Your preprocessing function is called after &lt;code&gt;&lt;a href=&quot;../functions/readdir&quot;&gt;readdir()&lt;/a&gt;&lt;/code&gt;, but before the loop that calls the &lt;code&gt;wanted()&lt;/code&gt; function. It is called with a list of strings (actually file/directory names) and is expected to return a list of strings. The code can be used to sort the file/directory names alphabetically, numerically, or to filter out directory entries based on their name alone. When</source>
          <target state="translated">값은 코드 참조 여야합니다. 이 코드 참조는 현재 디렉토리를 사전 처리하는 데 사용됩니다. 현재 처리 된 디렉토리의 이름은 &lt;code&gt;$File::Find::dir&lt;/code&gt; 입니다. 전처리 함수는 &lt;code&gt;&lt;a href=&quot;../functions/readdir&quot;&gt;readdir()&lt;/a&gt;&lt;/code&gt; 이후에 , &lt;code&gt;wanted()&lt;/code&gt; 함수 를 호출하는 루프 전에 호출 됩니다. 문자열 목록 (실제로는 파일 / 디렉토리 이름)과 함께 호출되며 문자열 목록을 반환해야합니다. 이 코드는 파일 / 디렉토리 이름을 알파벳순, 숫자 순으로 정렬하거나 이름 만 기준으로 디렉토리 항목을 필터링하는 데 사용할 수 있습니다. 언제</target>
        </trans-unit>
        <trans-unit id="f55a9d5538f4afdc7e60c610536ec48e43299b30" translate="yes" xml:space="preserve">
          <source>The value should be a code reference. This code reference is used to preprocess the current directory. The name of the currently processed directory is in &lt;code&gt;$File::Find::dir&lt;/code&gt;. Your preprocessing function is called after &lt;code&gt;readdir()&lt;/code&gt;, but before the loop that calls the &lt;code&gt;wanted()&lt;/code&gt; function. It is called with a list of strings (actually file/directory names) and is expected to return a list of strings. The code can be used to sort the file/directory names alphabetically, numerically, or to filter out directory entries based on their name alone. When</source>
          <target state="translated">값은 코드 참조 여야합니다. 이 코드 참조는 현재 디렉토리를 전처리하는 데 사용됩니다. 현재 처리 된 디렉토리의 이름은 &lt;code&gt;$File::Find::dir&lt;/code&gt; 있습니다. 전처리 함수는 &lt;code&gt;readdir()&lt;/code&gt; 이후에 호출 되지만 &lt;code&gt;wanted()&lt;/code&gt; 함수 를 호출하는 루프 이전에 호출 됩니다. 문자열 목록 (실제로 파일 / 디렉토리 이름)과 함께 호출되며 문자열 목록을 리턴 할 것으로 예상됩니다. 이 코드는 파일 / 디렉토리 이름을 알파벳, 숫자 순으로 정렬하거나 이름만으로 디렉토리 항목을 필터링하는 데 사용할 수 있습니다. 언제</target>
        </trans-unit>
        <trans-unit id="4b8d0d31a50d605febd9456f0c05a144d0e549cc" translate="yes" xml:space="preserve">
          <source>The value should be the complete TAP output.</source>
          <target state="translated">값은 완전한 TAP 출력이어야합니다.</target>
        </trans-unit>
        <trans-unit id="1236d86898ff88a6ba5efcf381d222ec31979c55" translate="yes" xml:space="preserve">
          <source>The value stack stores individual perl scalar values as temporaries between expressions. Some perl expressions operate on entire lists; for that purpose we need to know where on the stack each list begins. This is the purpose of the mark stack.</source>
          <target state="translated">값 스택은 개별 펄 스칼라 값을 표현식 간의 임시로 저장합니다. 일부 펄 표현식은 전체 목록에서 작동합니다. 이를 위해 스택에서 각 목록이 시작되는 위치를 알아야합니다. 이것이 마크 스택의 목적입니다.</target>
        </trans-unit>
        <trans-unit id="977d1c1fec14dab01803e1202ad5b70915c99932" translate="yes" xml:space="preserve">
          <source>The value supplied with &lt;code&gt;-Comment&lt;/code&gt; option can contain any character except NULL.</source>
          <target state="translated">&lt;code&gt;-Comment&lt;/code&gt; 옵션 과 함께 제공된 값 은 NULL을 제외한 모든 문자를 포함 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5a33beea90e0c4b3cd6d3aa1b159094d2037e800" translate="yes" xml:space="preserve">
          <source>The value supplied with &lt;code&gt;-Name&lt;/code&gt; option can contain any character except NULL.</source>
          <target state="translated">&lt;code&gt;-Name&lt;/code&gt; 옵션 과 함께 제공된 값 은 NULL을 제외한 모든 문자를 포함 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f1aeb63cc4cb0e101586c3105fecbdbf9caca8c2" translate="yes" xml:space="preserve">
          <source>The value supplied with the &lt;code&gt;Comment&lt;/code&gt; option can only contain ISO 8859-1 characters plus line-feed.</source>
          <target state="translated">&lt;code&gt;Comment&lt;/code&gt; 옵션 과 함께 제공된 값 은 ISO 8859-1 문자와 줄 바꿈 만 포함 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="56d224f65d33c0660d7f4661847cc1e8f860019d" translate="yes" xml:space="preserve">
          <source>The value supplied with the &lt;code&gt;Name&lt;/code&gt; option can only contain ISO 8859-1 characters.</source>
          <target state="translated">&lt;code&gt;Name&lt;/code&gt; 옵션 과 함께 제공된 값 은 ISO 8859-1 문자 만 포함 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="250b7ab858db3f7115ff282b675a91ac8e641be6" translate="yes" xml:space="preserve">
          <source>The value(s) returned by the failed subroutine. When the subroutine was called in a list context, this will always be a reference to an array containing the results. When the subroutine was called in a scalar context, this will be the actual scalar returned.</source>
          <target state="translated">실패한 서브 루틴에서 반환 한 값입니다. 목록 컨텍스트에서 서브 루틴이 호출되면 항상 결과를 포함하는 배열에 대한 참조가됩니다. 스칼라 컨텍스트에서 서브 루틴이 호출되면 이것은 실제 반환 된 스칼라가됩니다.</target>
        </trans-unit>
        <trans-unit id="5341e40485577e6df05a609244175f85c79fb195" translate="yes" xml:space="preserve">
          <source>The values are specified on the following format line in the same order as the picture fields. The expressions providing the values must be separated by commas. They are all evaluated in a list context before the line is processed, so a single list expression could produce multiple list elements. The expressions may be spread out to more than one line if enclosed in braces. If so, the opening brace must be the first token on the first line. If an expression evaluates to a number with a decimal part, and if the corresponding picture specifies that the decimal part should appear in the output (that is, any picture except multiple &quot;#&quot; characters &lt;b&gt;without&lt;/b&gt; an embedded &quot;.&quot;), the character used for the decimal point is determined by the current LC_NUMERIC locale if &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; is in effect. This means that, if, for example, the run-time environment happens to specify a German locale, &quot;,&quot; will be used instead of the default &quot;.&quot;. See &lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt; and &lt;a href=&quot;#WARNINGS&quot;&gt;WARNINGS&lt;/a&gt; for more information.</source>
          <target state="translated">값은 그림 필드와 동일한 순서로 다음 형식 행에 지정됩니다. 값을 제공하는 표현식은 쉼표로 구분해야합니다. 행이 처리되기 전에 목록 컨텍스트에서 모두 평가되므로 단일 목록 표현식이 여러 목록 요소를 생성 할 수 있습니다. 중괄호로 묶으면 표현식이 둘 이상의 행으로 분산 될 수 있습니다. 그렇다면 여는 중괄호는 첫 번째 줄의 첫 번째 토큰이어야합니다. 표현식이 소수 부분이있는 숫자로 평가되고 해당 그림이 소수 부분이 출력에 표시되도록 지정하는 경우 (즉, &quot;.&quot;가 포함 &lt;b&gt;되지 않은&lt;/b&gt; 여러 &quot;#&quot;문자 &lt;b&gt;를&lt;/b&gt; 제외한 모든 그림 ), 사용 된 문자 소수점의 현재 LC_NUMERIC 로케일에 의해 결정되는 경우에 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; 효과가 있습니다. 예를 들어 런타임 환경에서 독일어 로캘을 지정하면 기본 &quot;.&quot;대신 &quot;,&quot;가 사용됩니다. 자세한 내용은 &lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt; 및 &lt;a href=&quot;#WARNINGS&quot;&gt;WARNINGS&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="c72d7d9a1485bc34599e1ebeb09b10805e996267" translate="yes" xml:space="preserve">
          <source>The values are specified on the following format line in the same order as the picture fields. The expressions providing the values must be separated by commas. They are all evaluated in a list context before the line is processed, so a single list expression could produce multiple list elements. The expressions may be spread out to more than one line if enclosed in braces. If so, the opening brace must be the first token on the first line. If an expression evaluates to a number with a decimal part, and if the corresponding picture specifies that the decimal part should appear in the output (that is, any picture except multiple &quot;#&quot; characters &lt;b&gt;without&lt;/b&gt; an embedded &quot;.&quot;), the character used for the decimal point is determined by the current LC_NUMERIC locale if &lt;code&gt;use locale&lt;/code&gt; is in effect. This means that, if, for example, the run-time environment happens to specify a German locale, &quot;,&quot; will be used instead of the default &quot;.&quot;. See &lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt; and &lt;a href=&quot;#WARNINGS&quot;&gt;&quot;WARNINGS&quot;&lt;/a&gt; for more information.</source>
          <target state="translated">값은 그림 필드와 동일한 순서로 다음 형식 행에 지정됩니다. 값을 제공하는 표현식은 쉼표로 구분해야합니다. 라인이 처리되기 전에 목록 컨텍스트에서 모두 평가되므로 단일 목록 표현식이 여러 목록 요소를 생성 할 수 있습니다. 중괄호로 묶인 경우 표현식이 둘 이상의 행으로 확장 될 수 있습니다. 그렇다면 여는 중괄호는 첫 번째 줄의 첫 번째 토큰이어야합니다. 표현식이 소수 부분이있는 숫자로 평가되고 해당 그림에서 소수 부분이 출력에 나타나도록 지정하는 경우 (즉, &quot;.&quot;이 포함 &lt;b&gt;되지 않은&lt;/b&gt; 여러 &quot;#&quot;문자 &lt;b&gt;를&lt;/b&gt; 제외한 모든 그림 ) 문자가 사용됩니다. 로케일을 &lt;code&gt;use locale&lt;/code&gt; 경우 소수점은 현재 LC_NUMERIC 로케일에 의해 결정됩니다.유효합니다. 이는 예를 들어 런타임 환경에서 독일어 로케일을 지정하는 경우 기본 &quot;.&quot;대신 &quot;,&quot;가 사용됨을 의미합니다. 자세한 내용은 &lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt; 및 &lt;a href=&quot;#WARNINGS&quot;&gt;&quot;WARNINGS&quot;&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="dbf008b9072b1cecb517f8aeffecd9422e5c3c63" translate="yes" xml:space="preserve">
          <source>The values of &lt;a href=&quot;perlvar#%24%5EO&quot;&gt;&lt;code&gt;$^O&lt;/code&gt;&lt;/a&gt; on some of these platforms include:</source>
          <target state="translated">이러한 플랫폼 중 일부 에서 &lt;a href=&quot;perlvar#%24%5EO&quot;&gt; &lt;code&gt;$^O&lt;/code&gt; &lt;/a&gt; 의 값은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="bcd5bfa6286ea39c4bd9487ae2b5176bb3be48be" translate="yes" xml:space="preserve">
          <source>The values of &lt;code&gt;$^O&lt;/code&gt; on some of these platforms includes:</source>
          <target state="translated">이러한 플랫폼 중 일부 에서 &lt;code&gt;$^O&lt;/code&gt; 의 값은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="540bf16e20569214e1b31e52cdcbc4ee480d311c" translate="yes" xml:space="preserve">
          <source>The values pushed onto the return stack of the XSUB are actually mortal SV's. They are made mortal so that once the values are copied by the calling program, the SV's that held the returned values can be deallocated. If they were not mortal, then they would continue to exist after the XSUB routine returned, but would not be accessible. This is a memory leak.</source>
          <target state="translated">XSUB의 리턴 스택으로 푸시 된 값은 실제로 필사자 SV입니다. 호출 프로그램이 일단 값을 복사하면 리턴 된 값을 보유한 SV를 할당 해제 할 수 있도록 필멸자가됩니다. 이들이 필멸의 상태가 아닌 경우 XSUB 루틴이 리턴 된 후에도 계속 존재하지만 액세스 할 수 없습니다. 이것은 메모리 누수입니다.</target>
        </trans-unit>
        <trans-unit id="e474878aa7db7e96c4629326d93b845326ef064e" translate="yes" xml:space="preserve">
          <source>The values stored in config.sh may be either single-quoted or double-quoted. Double-quoted strings are handy for those cases where you need to include escape sequences in the strings. To avoid runtime variable interpolation, any &lt;code&gt;$&lt;/code&gt; and &lt;code&gt;@&lt;/code&gt; characters are replaced by &lt;code&gt;\$&lt;/code&gt; and &lt;code&gt;\@&lt;/code&gt; , respectively. This isn't foolproof, of course, so don't embed &lt;code&gt;\$&lt;/code&gt; or &lt;code&gt;\@&lt;/code&gt; in double-quoted strings unless you're willing to deal with the consequences. (The slashes will end up escaped and the &lt;code&gt;$&lt;/code&gt; or &lt;code&gt;@&lt;/code&gt; will trigger variable interpolation)</source>
          <target state="translated">config.sh에 저장된 값은 작은 따옴표 또는 큰 따옴표 일 수 있습니다. 큰 따옴표로 묶인 문자열은 문자열에 이스케이프 시퀀스를 포함해야하는 경우에 편리합니다. 런타임 변수 보간을 피하기 위해 &lt;code&gt;$&lt;/code&gt; 및 &lt;code&gt;@&lt;/code&gt; 문자는 각각 &lt;code&gt;\$&lt;/code&gt; 및 &lt;code&gt;\@&lt;/code&gt; 로 대체됩니다 . 물론 이것은 결코 쉬운 일이 아니므로 결과를 기꺼이 다루지 않는 한 &lt;code&gt;\$&lt;/code&gt; 또는 &lt;code&gt;\@&lt;/code&gt; 를 큰 따옴표로 묶은 문자열에 포함시키지 마십시오 . (슬래시는 종료되고 &lt;code&gt;$&lt;/code&gt; 또는 &lt;code&gt;@&lt;/code&gt; 는 변수 보간을 트리거합니다)</target>
        </trans-unit>
        <trans-unit id="2fb3e0a0c43753411747016bb8289e7cafa37f14" translate="yes" xml:space="preserve">
          <source>The values stored in config.sh may be either single-quoted or double-quoted. Double-quoted strings are handy for those cases where you need to include escape sequences in the strings. To avoid runtime variable interpolation, any &lt;code&gt;$&lt;/code&gt; and &lt;code&gt;@&lt;/code&gt; characters are replaced by &lt;code&gt;\$&lt;/code&gt; and &lt;code&gt;\@&lt;/code&gt;, respectively. This isn't foolproof, of course, so don't embed &lt;code&gt;\$&lt;/code&gt; or &lt;code&gt;\@&lt;/code&gt; in double-quoted strings unless you're willing to deal with the consequences. (The slashes will end up escaped and the &lt;code&gt;$&lt;/code&gt; or &lt;code&gt;@&lt;/code&gt; will trigger variable interpolation)</source>
          <target state="translated">config.sh에 저장된 값은 작은 따옴표 또는 큰 따옴표 일 수 있습니다. 큰 따옴표로 묶인 문자열은 문자열에 이스케이프 시퀀스를 포함해야하는 경우에 유용합니다. 런타임 변수 보간을 방지하기 위해 &lt;code&gt;$&lt;/code&gt; 및 &lt;code&gt;@&lt;/code&gt; 문자는 각각 &lt;code&gt;\$&lt;/code&gt; 및 &lt;code&gt;\@&lt;/code&gt; 로 대체됩니다 . 당연히 이것은 절대 안전한 것은 아니므로 결과를 처리 할 의향이 없다면 큰 따옴표로 묶인 문자열에 &lt;code&gt;\$&lt;/code&gt; 또는 &lt;code&gt;\@&lt;/code&gt; 를 삽입하지 마십시오 . (슬래시는 이스케이프 처리되고 &lt;code&gt;$&lt;/code&gt; 또는 &lt;code&gt;@&lt;/code&gt; 는 변수 보간을 트리거합니다)</target>
        </trans-unit>
        <trans-unit id="c23b5412a89e9982acfd046a606aac6df7b125a8" translate="yes" xml:space="preserve">
          <source>The values stored in the hashes above are mostly the direct equivalent of their C counterpart. Like their C counterparts, all are set to a default values - that means you don't have to set</source>
          <target state="translated">위의 해시에 저장된 값은 대부분 C에 해당하는 값입니다. C 상대방과 마찬가지로 모두 기본값으로 설정되어 있으므로 설정할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="9e6700989ab1dbf25d28d4fd1b763593cc3c720f" translate="yes" xml:space="preserve">
          <source>The values supplied with the &lt;code&gt;-Name&lt;/code&gt; and &lt;code&gt;-Comment&lt;/code&gt; options can contain multiple embedded nulls. The string written to the gzip header will consist of the characters up to, but not including, the first embedded NULL.</source>
          <target state="translated">&lt;code&gt;-Name&lt;/code&gt; 및 &lt;code&gt;-Comment&lt;/code&gt; 옵션 과 함께 제공된 값 에는 여러 개의 포함 된 널이 포함될 수 있습니다. gzip 헤더에 기록 된 문자열은 첫 번째 포함 된 NULL 이하의 문자로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="f4d39e5aa9ce36eff93868e0e7af4d9b6a02d8ec" translate="yes" xml:space="preserve">
          <source>The values supplied with the &lt;code&gt;-Name&lt;/code&gt; and &lt;code&gt;-Comment&lt;/code&gt; options cannot contain multiple embedded nulls.</source>
          <target state="translated">&lt;code&gt;-Name&lt;/code&gt; 및 &lt;code&gt;-Comment&lt;/code&gt; 옵션 과 함께 제공된 값 은 여러 개의 포함 된 널을 포함 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="6344a1b12727e711425a7cd0809233875bc47e54" translate="yes" xml:space="preserve">
          <source>The values to be compared are always passed by reference and should not be modified.</source>
          <target state="translated">비교할 값은 항상 참조로 전달되며 수정해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="0a3bdf6ba268c4d17126cd579eaa00987525d1a3" translate="yes" xml:space="preserve">
          <source>The variable $ref may have referred to the subroutine &lt;code&gt;fred&lt;/code&gt; whenever the call to &lt;code&gt;SaveSub1&lt;/code&gt; was made but by the time &lt;code&gt;CallSavedSub1&lt;/code&gt; gets called it now holds the number &lt;code&gt;47&lt;/code&gt; . Because we saved only a pointer to the original SV in &lt;code&gt;SaveSub1&lt;/code&gt; , any changes to $ref will be tracked by the pointer &lt;code&gt;rememberSub&lt;/code&gt; . This means that whenever &lt;code&gt;CallSavedSub1&lt;/code&gt; gets called, it will attempt to execute the code which is referenced by the SV* &lt;code&gt;rememberSub&lt;/code&gt; . In this case though, it now refers to the integer &lt;code&gt;47&lt;/code&gt; , so expect Perl to complain loudly.</source>
          <target state="translated">$ ref 변수 는 &lt;code&gt;SaveSub1&lt;/code&gt; 에 대한 호출이 작성 될 때마다 서브 루틴 &lt;code&gt;fred&lt;/code&gt; 를 참조했을 수 있지만 &lt;code&gt;CallSavedSub1&lt;/code&gt; 이 호출 될 때까지 이제 숫자 &lt;code&gt;47&lt;/code&gt; 을 보유합니다 . &lt;code&gt;SaveSub1&lt;/code&gt; 의 원래 SV에 대한 포인터 만 저장했기 때문에 $ ref에 대한 모든 변경 사항은 포인터 &lt;code&gt;rememberSub&lt;/code&gt; 에 의해 추적됩니다 . 이것은 &lt;code&gt;CallSavedSub1&lt;/code&gt; 이 호출 될 때마다 SV * &lt;code&gt;rememberSub&lt;/code&gt; 가 참조하는 코드를 실행하려고 시도 함을 의미합니다 . 이 경우 이제 정수 &lt;code&gt;47&lt;/code&gt; 을 참조하므로 Perl이 크게 불평 할 것으로 예상하십시오.</target>
        </trans-unit>
        <trans-unit id="b062bdbf031860e708b29efdacf136fb5d1f0b68" translate="yes" xml:space="preserve">
          <source>The variable $ref may have referred to the subroutine &lt;code&gt;fred&lt;/code&gt; whenever the call to &lt;code&gt;SaveSub1&lt;/code&gt; was made but by the time &lt;code&gt;CallSavedSub1&lt;/code&gt; gets called it now holds the number &lt;code&gt;47&lt;/code&gt;. Because we saved only a pointer to the original SV in &lt;code&gt;SaveSub1&lt;/code&gt;, any changes to $ref will be tracked by the pointer &lt;code&gt;rememberSub&lt;/code&gt;. This means that whenever &lt;code&gt;CallSavedSub1&lt;/code&gt; gets called, it will attempt to execute the code which is referenced by the SV* &lt;code&gt;rememberSub&lt;/code&gt;. In this case though, it now refers to the integer &lt;code&gt;47&lt;/code&gt;, so expect Perl to complain loudly.</source>
          <target state="translated">변수 $ ref는 &lt;code&gt;SaveSub1&lt;/code&gt; 에 대한 호출 이 이루어질 때마다 서브 루틴 &lt;code&gt;fred&lt;/code&gt; 를 참조했을 수 있지만 &lt;code&gt;CallSavedSub1&lt;/code&gt; 이 호출 될 때 현재 번호 &lt;code&gt;47&lt;/code&gt; 을 보유합니다 . &lt;code&gt;SaveSub1&lt;/code&gt; 에 원래 SV에 대한 포인터 만 저장했기 때문에 $ ref에 대한 모든 변경 사항은 포인터 &lt;code&gt;rememberSub&lt;/code&gt; 에 의해 추적됩니다 . 즉 , &lt;code&gt;CallSavedSub1&lt;/code&gt; 이 호출 될 때마다 SV * &lt;code&gt;rememberSub&lt;/code&gt; 에서 참조하는 코드를 실행하려고 시도합니다 . 이 경우에는 이제 정수 &lt;code&gt;47&lt;/code&gt; 을 참조하므로 Perl이 크게 불평 할 것으로 예상됩니다.</target>
        </trans-unit>
        <trans-unit id="ad1d8279ad869db1c2929300f40e329172cf94dc" translate="yes" xml:space="preserve">
          <source>The variable contains the symbols defined by the C compiler alone. The symbols defined by cpp or by cc when it calls cpp are not in this list, see cppsymbols and cppccsymbols. The list is a space-separated list of symbol=value tokens.</source>
          <target state="translated">변수에는 C 컴파일러만으로 정의 된 기호가 포함됩니다. cpp 또는 cc가 cpp를 호출 할 때 정의한 기호는이 목록에 없습니다. cppsymbols 및 cppccsymbols를 참조하십시오. 이 목록은 공백으로 구분 된 symbol = value 토큰 목록입니다.</target>
        </trans-unit>
        <trans-unit id="501db733d2ef38c039a965292ca77f71bc56d687" translate="yes" xml:space="preserve">
          <source>The variable contains the symbols defined by the C compiler when it calls cpp. The symbols defined by the cc alone or cpp alone are not in this list, see ccsymbols and cppsymbols. The list is a space-separated list of symbol=value tokens.</source>
          <target state="translated">변수는 cpp를 호출 할 때 C 컴파일러가 정의한 기호를 포함합니다. cc 만 또는 cpp만으로 정의 된 기호는이 목록에 없습니다. ccsymbols 및 cppsymbols를 참조하십시오. 이 목록은 공백으로 구분 된 symbol = value 토큰 목록입니다.</target>
        </trans-unit>
        <trans-unit id="00b4b60fa439030036a66d7ff80e60844c78536a" translate="yes" xml:space="preserve">
          <source>The variable contains the symbols defined by the C preprocessor alone. The symbols defined by cc or by cc when it calls cpp are not in this list, see ccsymbols and cppccsymbols. The list is a space-separated list of symbol=value tokens.</source>
          <target state="translated">변수는 C 전처리기만으로 정의 된 기호를 포함합니다. cc 또는 cc가 cpp를 호출 할 때 정의한 기호는이 목록에 없습니다. ccsymbols 및 cppccsymbols를 참조하십시오. 이 목록은 공백으로 구분 된 symbol = value 토큰 목록입니다.</target>
        </trans-unit>
        <trans-unit id="83d3f8e3698f4e666192e80e4c4c129382375649" translate="yes" xml:space="preserve">
          <source>The variables &lt;code&gt;$@&lt;/code&gt; , &lt;code&gt;$!&lt;/code&gt; , &lt;code&gt;$^E&lt;/code&gt; , and &lt;code&gt;$?&lt;/code&gt; contain information about different types of error conditions that may appear during execution of a Perl program. The variables are shown ordered by the &quot;distance&quot; between the subsystem which reported the error and the Perl process. They correspond to errors detected by the Perl interpreter, C library, operating system, or an external program, respectively.</source>
          <target state="translated">변수 &lt;code&gt;$@&lt;/code&gt; , &lt;code&gt;$!&lt;/code&gt; , &lt;code&gt;$^E&lt;/code&gt; 및 &lt;code&gt;$?&lt;/code&gt; Perl 프로그램을 실행하는 동안 나타날 수있는 다양한 유형의 오류 조건에 대한 정보가 들어 있습니다. 변수는 오류를보고 한 서브 시스템과 Perl 프로세스 사이의 &quot;거리&quot;순서로 표시됩니다. Perl 인터프리터, C 라이브러리, 운영 체제 또는 외부 프로그램에서 각각 감지 한 오류에 해당합니다.</target>
        </trans-unit>
        <trans-unit id="b727dbcbaa890861d8b1f725dd2b28a4ab07c49e" translate="yes" xml:space="preserve">
          <source>The variables &lt;code&gt;$@&lt;/code&gt;, &lt;code&gt;$!&lt;/code&gt;, &lt;code&gt;$^E&lt;/code&gt;, and &lt;code&gt;$?&lt;/code&gt; contain information about different types of error conditions that may appear during execution of a Perl program. The variables are shown ordered by the &quot;distance&quot; between the subsystem which reported the error and the Perl process. They correspond to errors detected by the Perl interpreter, C library, operating system, or an external program, respectively.</source>
          <target state="translated">변수 &lt;code&gt;$@&lt;/code&gt; , &lt;code&gt;$!&lt;/code&gt; , &lt;code&gt;$^E&lt;/code&gt; 및 &lt;code&gt;$?&lt;/code&gt; Perl 프로그램 실행 중에 나타날 수있는 다양한 유형의 오류 조건에 대한 정보를 포함합니다. 변수는 오류를보고 한 하위 시스템과 Perl 프로세스 사이의 &quot;거리&quot;에 따라 정렬되어 표시됩니다. 이들은 각각 Perl 인터프리터, C 라이브러리, 운영 체제 또는 외부 프로그램에 의해 감지 된 오류에 해당합니다.</target>
        </trans-unit>
        <trans-unit id="d61a4e2ec2fd6a9d823c4ff48f24791a3afc0a43" translate="yes" xml:space="preserve">
          <source>The variables are thousands of characters long and you know that they don't change, and you need to wring out the last little bit of speed by having Perl skip testing for that. (There is a maintenance penalty for doing this, as mentioning &lt;code&gt;/o&lt;/code&gt; constitutes a promise that you won't change the variables in the pattern. If you do change them, Perl won't even notice.)</source>
          <target state="translated">변수의 길이는 수천 자이며 변경되지 않는다는 것을 알고 있으며 Perl이 테스트를 건너 뛰도록하여 약간의 속도를 줄이십시오. ( &lt;code&gt;/o&lt;/code&gt; 를 언급 하면 패턴의 변수를 변경하지 않겠다는 약속을 구성 하므로 유지 관리에 대한 페널티 가 있습니다. 변경하면 Perl도 알지 못합니다.)</target>
        </trans-unit>
        <trans-unit id="11544c219d80b67a63dc9e0a8e442712e549045b" translate="yes" xml:space="preserve">
          <source>The variables&amp;mdash;such as &lt;code&gt;$1&lt;/code&gt; and &lt;code&gt;$2&lt;/code&gt; , and &lt;code&gt;%+&lt;/code&gt; and &lt;code&gt;%&amp;ndash; &lt;/code&gt; &amp;mdash;that hold the text remembered in a pattern match. See Camel chapter 5, &amp;ldquo;Pattern Matching&amp;rdquo;.</source>
          <target state="translated">패턴 일치로 기억 된 텍스트를 유지하는 변수 (예 : &lt;code&gt;$1&lt;/code&gt; 및 &lt;code&gt;$2&lt;/code&gt; , &lt;code&gt;%+&lt;/code&gt; 및 &lt;code&gt;%&amp;ndash; &lt;/code&gt; 낙타 5 장 &quot;패턴 일치&quot;를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="d984e8b7b660f5c99b516a5829ac59bafa50592e" translate="yes" xml:space="preserve">
          <source>The variables&amp;mdash;such as &lt;code&gt;$1&lt;/code&gt; and &lt;code&gt;$2&lt;/code&gt;, and &lt;code&gt;%+&lt;/code&gt; and &lt;code&gt;%&amp;ndash; &lt;/code&gt;&amp;mdash;that hold the text remembered in a pattern match. See Camel chapter 5, &amp;ldquo;Pattern Matching&amp;rdquo;.</source>
          <target state="translated">&lt;code&gt;$1&lt;/code&gt; 및 &lt;code&gt;$2&lt;/code&gt; 및 &lt;code&gt;%+&lt;/code&gt; 및 &lt;code&gt;%&amp;ndash; &lt;/code&gt; 와 같은 변수 는 패턴 일치에서 기억 된 텍스트를 보유합니다. Camel 5 장, &quot;패턴 일치&quot;를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="01a6309a6878656688c2b0908ac3992f68dc7d19" translate="yes" xml:space="preserve">
          <source>The variant called by &lt;a href=&quot;#ack&quot;&gt;&quot;ack&quot;&lt;/a&gt; with the &quot;syn&quot; protocol and &lt;code&gt;$syn_forking&lt;/code&gt; enabled.</source>
          <target state="translated">&quot;syn&quot;프로토콜과 &lt;code&gt;$syn_forking&lt;/code&gt; 활성화 된 &lt;a href=&quot;#ack&quot;&gt;&quot;ack&quot;에&lt;/a&gt; 의해 호출되는 변종 .</target>
        </trans-unit>
        <trans-unit id="50b54417d53e0d1cfe584f4211726c367ffae98a" translate="yes" xml:space="preserve">
          <source>The variant of OS2::_control87() with default values good for handling exception mask: if no &lt;code&gt;mask&lt;/code&gt; , uses exception mask part of &lt;code&gt;new&lt;/code&gt; only. If no &lt;code&gt;new&lt;/code&gt; , disables all the floating point exceptions.</source>
          <target state="translated">예외 마스크를 처리하기위한 기본값 좋은과 OS2 :: _ control87 ()의 변형 : 어떤 경우 &lt;code&gt;mask&lt;/code&gt; 의 예외 마스크 부분을 사용하여 &lt;code&gt;new&lt;/code&gt; 만. &lt;code&gt;new&lt;/code&gt; 가 없으면 모든 부동 소수점 예외를 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="949da3d76c7f29272d20c982b210c531dcfc20d4" translate="yes" xml:space="preserve">
          <source>The variant of OS2::_control87() with default values good for handling exception mask: if no &lt;code&gt;mask&lt;/code&gt;, uses exception mask part of &lt;code&gt;new&lt;/code&gt; only. If no &lt;code&gt;new&lt;/code&gt;, disables all the floating point exceptions.</source>
          <target state="translated">예외 마스크를 처리하기위한 기본값 좋은과 OS2 :: _ control87 ()의 변형 : 어떤 경우 &lt;code&gt;mask&lt;/code&gt; 의 예외 마스크 부분을 사용하여 &lt;code&gt;new&lt;/code&gt; 만. &lt;code&gt;new&lt;/code&gt; 가 없으면 모든 부동 소수점 예외를 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="307e90e437dd1da42b4c1389ea6c9b26886479f7" translate="yes" xml:space="preserve">
          <source>The various &lt;code&gt;extract_...&lt;/code&gt; subroutines may be used to extract a delimited substring, possibly after skipping a specified prefix string. By default, that prefix is optional whitespace (&lt;code&gt;/\s*/&lt;/code&gt; ), but you can change it to whatever you wish (see below).</source>
          <target state="translated">다양한 &lt;code&gt;extract_...&lt;/code&gt; 서브 루틴을 사용하여 지정된 접두어 문자열을 건너 뛴 후 구분 된 서브 스트링을 추출 할 수 있습니다. 기본적으로이 접두사는 선택적 공백 ( &lt;code&gt;/\s*/&lt;/code&gt; )이지만 원하는대로 변경할 수 있습니다 (아래 참조).</target>
        </trans-unit>
        <trans-unit id="53ae99cb4c2e82006930873ef81a93aa0cb472f5" translate="yes" xml:space="preserve">
          <source>The various &lt;code&gt;extract_...&lt;/code&gt; subroutines may be used to extract a delimited substring, possibly after skipping a specified prefix string. By default, that prefix is optional whitespace (&lt;code&gt;/\s*/&lt;/code&gt;), but you can change it to whatever you wish (see below).</source>
          <target state="translated">다양한 &lt;code&gt;extract_...&lt;/code&gt; 서브 루틴을 사용하여 구분 된 하위 문자열을 추출 할 수 있습니다. 지정된 접두어 문자열을 건너 뛴 후 가능합니다. 기본적으로 해당 접두사는 선택적 공백 ( &lt;code&gt;/\s*/&lt;/code&gt; )이지만 원하는대로 변경할 수 있습니다 (아래 참조).</target>
        </trans-unit>
        <trans-unit id="6c592ef06c081d09dc8157d9f5c4a05ab70da35e" translate="yes" xml:space="preserve">
          <source>The various MSWin32 Perl's can distinguish the OS they are running on via the value of the fifth element of the list returned from &lt;a href=&quot;win32#Win32%3A%3AGetOSVersion%28%29&quot;&gt;&lt;code&gt;Win32::GetOSVersion()&lt;/code&gt;&lt;/a&gt;. For example:</source>
          <target state="translated">다양한 MSWin32 Perl은 &lt;a href=&quot;win32#Win32%3A%3AGetOSVersion%28%29&quot;&gt; &lt;code&gt;Win32::GetOSVersion()&lt;/code&gt; &lt;/a&gt; 에서 반환 된 목록의 다섯 번째 요소 값을 통해 실행중인 OS를 구별 할 수 있습니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="fc16009f09e3803367ecc5c2f24dcc5baf8339c5" translate="yes" xml:space="preserve">
          <source>The various MSWin32 Perl's can distinguish the OS they are running on via the value of the fifth element of the list returned from &lt;code&gt;Win32::GetOSVersion()&lt;/code&gt; . For example:</source>
          <target state="translated">다양한 MSWin32 Perl은 &lt;code&gt;Win32::GetOSVersion()&lt;/code&gt; 에서 반환 된 목록의 다섯 번째 요소 값을 통해 실행중인 OS를 구별 할 수 있습니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b5f8a6767121d40d53463b6246a6dc21454cdfba" translate="yes" xml:space="preserve">
          <source>The various named unary operators are treated as functions with one argument, with optional parentheses.</source>
          <target state="translated">다양한 명명 된 단항 연산자는 선택적인 괄호와 함께 하나의 인수를 가진 함수로 취급됩니다.</target>
        </trans-unit>
        <trans-unit id="8d7dece5f96deb4f2078174f4b6a63435a6090e8" translate="yes" xml:space="preserve">
          <source>The various options that can be specified are:</source>
          <target state="translated">지정할 수있는 다양한 옵션은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d5834701f76b16947132d9ecda0666e7fbd30f61" translate="yes" xml:space="preserve">
          <source>The various stacks have different purposes, and operate in slightly different ways. Their differences are noted below.</source>
          <target state="translated">다양한 스택은 용도가 다르며 약간 다른 방식으로 작동합니다. 차이점은 아래에 나와 있습니다.</target>
        </trans-unit>
        <trans-unit id="8f2d3209693f371a4dffdf7b8f3fc9b9432bc2c1" translate="yes" xml:space="preserve">
          <source>The various types of data aggregate form a natural hierarchy that facilitates the use of inheritance and polymorphism.</source>
          <target state="translated">다양한 유형의 데이터 집계는 상속 및 다형성의 사용을 용이하게하는 자연스러운 계층을 형성합니다.</target>
        </trans-unit>
        <trans-unit id="579f7176cc72efc4b3e6d5cd5bbca1f7407618f4" translate="yes" xml:space="preserve">
          <source>The vast majority of problems that are reported in this area boil down to the fact that C strings are NULL terminated, whilst Perl strings are not. See &lt;a href=&quot;#DBM-FILTERS&quot;&gt;&quot;DBM FILTERS&quot;&lt;/a&gt; for a generic way to work around this problem.</source>
          <target state="translated">이 영역에서보고 된 대부분의 문제는 C 문자열이 NULL로 끝나는 반면 Perl 문자열은 그렇지 않다는 사실로 귀결됩니다. 이 문제를 해결하는 일반적인 방법 은 &lt;a href=&quot;#DBM-FILTERS&quot;&gt;&quot;DBM 필터&quot;&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="7dcabdd4901aed0767d31bd0d04d8aa2ce24975f" translate="yes" xml:space="preserve">
          <source>The vast majority of problems that are reported in this area boil down to the fact that C strings are NULL terminated, whilst Perl strings are not. See &lt;a href=&quot;#DBM-FILTERS&quot;&gt;DBM FILTERS&lt;/a&gt; for a generic way to work around this problem.</source>
          <target state="translated">이 영역에서보고 된 대부분의 문제는 Perl 문자열이 아닌 C 문자열이 NULL로 종료된다는 사실로 귀결됩니다. 이 문제를 해결하는 일반적인 방법 은 &lt;a href=&quot;#DBM-FILTERS&quot;&gt;DBM 필터&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="6c55d44dd5a799dd5be32ea5b3f1cae585e95693" translate="yes" xml:space="preserve">
          <source>The vast majority of the code was written by Kenneth Albanowski &lt;code&gt;&amp;lt;kjahds@kjahds.com&amp;gt;&lt;/code&gt; , Andy Dougherty &lt;code&gt;&amp;lt;doughera@lafayette.edu&amp;gt;&lt;/code&gt; , Andreas K&amp;ouml;nig &lt;code&gt;&amp;lt;A.Koenig@franz.ww.TU-Berlin.DE&amp;gt;&lt;/code&gt; , Tim Bunce &lt;code&gt;&amp;lt;Tim.Bunce@ig.co.uk&amp;gt;&lt;/code&gt; . VMS support by Charles Bailey &lt;code&gt;&amp;lt;bailey@newman.upenn.edu&amp;gt;&lt;/code&gt; . OS/2 support by Ilya Zakharevich &lt;code&gt;&amp;lt;ilya@math.ohio-state.edu&amp;gt;&lt;/code&gt; . Mac support by Paul Schinder &lt;code&gt;&amp;lt;schinder@pobox.com&amp;gt;&lt;/code&gt; , and Thomas Wegner &lt;code&gt;&amp;lt;wegner_thomas@yahoo.com&amp;gt;&lt;/code&gt; . abs2rel() and rel2abs() written by Shigio Yamaguchi &lt;code&gt;&amp;lt;shigio@tamacom.com&amp;gt;&lt;/code&gt; , modified by Barrie Slaymaker &lt;code&gt;&amp;lt;barries@slaysys.com&amp;gt;&lt;/code&gt; . splitpath(), splitdir(), catpath() and catdir() by Barrie Slaymaker.</source>
          <target state="translated">코드의 대부분은 Kenneth Albanowski &lt;code&gt;&amp;lt;kjahds@kjahds.com&amp;gt;&lt;/code&gt; , Andy Dougherty &lt;code&gt;&amp;lt;doughera@lafayette.edu&amp;gt;&lt;/code&gt; , Andreas K&amp;ouml;nig &lt;code&gt;&amp;lt;A.Koenig@franz.ww.TU-Berlin.DE&amp;gt;&lt;/code&gt; , Tim Bunce &lt;code&gt;&amp;lt;Tim.Bunce@ig.co.uk&amp;gt;&lt;/code&gt; . Charles Bailey &lt;code&gt;&amp;lt;bailey@newman.upenn.edu&amp;gt;&lt;/code&gt; 의 VMS 지원 . Ilya Zakharevich &lt;code&gt;&amp;lt;ilya@math.ohio-state.edu&amp;gt;&lt;/code&gt; 의 OS / 2 지원 . 폴 쉰더에 의해 맥 지원 &lt;code&gt;&amp;lt;schinder@pobox.com&amp;gt;&lt;/code&gt; , 토마스 웨 그너 &lt;code&gt;&amp;lt;wegner_thomas@yahoo.com&amp;gt;&lt;/code&gt; . abs2rel () 및 rel2abs ()는 Shigio Yamaguchi &lt;code&gt;&amp;lt;shigio@tamacom.com&amp;gt;&lt;/code&gt; , Barrie Slaymaker &lt;code&gt;&amp;lt;barries@slaysys.com&amp;gt;&lt;/code&gt; 에 의해 수정 됨. Barrie Slaymaker의 splitpath (), splitdir (), catpath () 및 catdir ().</target>
        </trans-unit>
        <trans-unit id="78e57f945db726a29f3a1812670cc08732e95ca3" translate="yes" xml:space="preserve">
          <source>The vast majority of the code was written by Kenneth Albanowski &lt;code&gt;&amp;lt;kjahds@kjahds.com&amp;gt;&lt;/code&gt;, Andy Dougherty &lt;code&gt;&amp;lt;doughera@lafayette.edu&amp;gt;&lt;/code&gt;, Andreas K&amp;ouml;nig &lt;code&gt;&amp;lt;A.Koenig@franz.ww.TU-Berlin.DE&amp;gt;&lt;/code&gt;, Tim Bunce &lt;code&gt;&amp;lt;Tim.Bunce@ig.co.uk&amp;gt;&lt;/code&gt;. VMS support by Charles Bailey &lt;code&gt;&amp;lt;bailey@newman.upenn.edu&amp;gt;&lt;/code&gt;. OS/2 support by Ilya Zakharevich &lt;code&gt;&amp;lt;ilya@math.ohio-state.edu&amp;gt;&lt;/code&gt;. Mac support by Paul Schinder &lt;code&gt;&amp;lt;schinder@pobox.com&amp;gt;&lt;/code&gt;, and Thomas Wegner &lt;code&gt;&amp;lt;wegner_thomas@yahoo.com&amp;gt;&lt;/code&gt;. abs2rel() and rel2abs() written by Shigio Yamaguchi &lt;code&gt;&amp;lt;shigio@tamacom.com&amp;gt;&lt;/code&gt;, modified by Barrie Slaymaker &lt;code&gt;&amp;lt;barries@slaysys.com&amp;gt;&lt;/code&gt;. splitpath(), splitdir(), catpath() and catdir() by Barrie Slaymaker.</source>
          <target state="translated">대부분의 코드는 Kenneth Albanowski &lt;code&gt;&amp;lt;kjahds@kjahds.com&amp;gt;&lt;/code&gt; , Andy Dougherty &lt;code&gt;&amp;lt;doughera@lafayette.edu&amp;gt;&lt;/code&gt; , Andreas K&amp;ouml;nig &lt;code&gt;&amp;lt;A.Koenig@franz.ww.TU-Berlin.DE&amp;gt;&lt;/code&gt; , Tim Bunce &lt;code&gt;&amp;lt;Tim.Bunce@ig.co.uk&amp;gt;&lt;/code&gt; . Charles Bailey의 VMS 지원 &lt;code&gt;&amp;lt;bailey@newman.upenn.edu&amp;gt;&lt;/code&gt; . Ilya Zakharevich &lt;code&gt;&amp;lt;ilya@math.ohio-state.edu&amp;gt;&lt;/code&gt; 의 OS / 2 지원 . Paul Schinder &lt;code&gt;&amp;lt;schinder@pobox.com&amp;gt;&lt;/code&gt; 및 Thomas Wegner &lt;code&gt;&amp;lt;wegner_thomas@yahoo.com&amp;gt;&lt;/code&gt; 의 Mac 지원 . abs2rel () 및 rel2abs () 작성 : Shigio Yamaguchi &lt;code&gt;&amp;lt;shigio@tamacom.com&amp;gt;&lt;/code&gt; , 수정 : Barrie Slaymaker &lt;code&gt;&amp;lt;barries@slaysys.com&amp;gt;&lt;/code&gt; . Barrie Slaymaker의 splitpath (), splitdir (), catpath () 및 catdir ().</target>
        </trans-unit>
        <trans-unit id="e1c837eb7150f7389b8a819378e52b179af4ab77" translate="yes" xml:space="preserve">
          <source>The vec() function may produce surprising results if used on strings containing characters with ordinal values above 255. In such a case, the results are consistent with the internal encoding of the characters, but not with much else. So don't do that, and starting in Perl 5.28, a deprecation message is issued if you do so, becoming illegal in Perl 5.32.</source>
          <target state="translated">vec () 함수는 서수 값이 255를 초과하는 문자를 포함하는 문자열에 사용하면 놀라운 결과를 생성 할 수 있습니다.이 경우 결과는 문자의 내부 인코딩과 일치하지만 다른 것과는 일치하지 않습니다. 그러지 마십시오. Perl 5.28부터 사용 중단 메시지가 표시되고 Perl 5.32에서는 불법이됩니다.</target>
        </trans-unit>
        <trans-unit id="d0a3f9b4fdc58bce9dc91ad1590ca608ffcca3cf" translate="yes" xml:space="preserve">
          <source>The veil of abstraction separating the &lt;b&gt;interface&lt;/b&gt; from the &lt;b&gt;implementation&lt;/b&gt; (whether enforced or not), which mandates that all access to an &lt;b&gt;object&lt;/b&gt;&amp;rsquo;s state be through &lt;b&gt;methods&lt;/b&gt; alone.</source>
          <target state="translated">&lt;b&gt;구현&lt;/b&gt; 과 &lt;b&gt;인터페이스&lt;/b&gt; 를 분리하는 추상화의 베일 (강제 여부에 관계없이)은 &lt;b&gt;객체&lt;/b&gt; 의 상태 에 대한 모든 액세스가 &lt;b&gt;메소드&lt;/b&gt; 만을 통해 이루어 지도록 요구합니다 .&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="9b9ecb3d60d103c7f5665f456eda4698f957144a" translate="yes" xml:space="preserve">
          <source>The verify method always returns true ?</source>
          <target state="translated">verify 메서드는 항상 true를 반환합니까?</target>
        </trans-unit>
        <trans-unit id="20efbe7543ae8d526c7c1a14310569f9dadb6162" translate="yes" xml:space="preserve">
          <source>The version identifier for an XS module. This is usually handled automatically by &lt;code&gt;ExtUtils::MakeMaker&lt;/code&gt; . See &lt;code&gt;XS_VERSION_BOOTCHECK&lt;/code&gt; .</source>
          <target state="translated">XS 모듈의 버전 식별자입니다. 이것은 일반적으로 &lt;code&gt;ExtUtils::MakeMaker&lt;/code&gt; 의해 자동으로 처리됩니다 . &lt;code&gt;XS_VERSION_BOOTCHECK&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="7557d13ad6548a59235452a6893c4504ed7e5952" translate="yes" xml:space="preserve">
          <source>The version identifier for an XS module. This is usually handled automatically by &lt;code&gt;ExtUtils::MakeMaker&lt;/code&gt;. See &lt;code&gt;&lt;a href=&quot;#XS_VERSION_BOOTCHECK&quot;&gt;&quot;XS_VERSION_BOOTCHECK&quot;&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">XS 모듈의 버전 식별자입니다. 이것은 일반적으로 &lt;code&gt;ExtUtils::MakeMaker&lt;/code&gt; 의해 자동으로 처리됩니다 . &lt;code&gt;&lt;a href=&quot;#XS_VERSION_BOOTCHECK&quot;&gt;&quot;XS_VERSION_BOOTCHECK&quot;&lt;/a&gt;&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e13051932ac793eddfcf7780ddfecbd50a22ea0e" translate="yes" xml:space="preserve">
          <source>The version is essentially an arbitrary string, but</source>
          <target state="translated">버전은 본질적으로 임의의 문자열이지만</target>
        </trans-unit>
        <trans-unit id="4ddac7f13e9a2dc240c79129edea2cf74e24b8cc" translate="yes" xml:space="preserve">
          <source>The version number of the installed module - this will be &lt;code&gt;&lt;a href=&quot;../../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; if the module had no (or unparsable) version number, or if the variable &lt;code&gt;$Module::Load::Conditional::FIND_VERSION&lt;/code&gt; was set to true. (See the &lt;code&gt;GLOBAL VARIABLES&lt;/code&gt; section below for details)</source>
          <target state="translated">설치된 모듈의 버전 번호 -이 될 것 &lt;code&gt;&lt;a href=&quot;../../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 모듈이없는 (또는 해석 할) 버전 번호가 없었다, 또는 변수 경우 경우 &lt;code&gt;$Module::Load::Conditional::FIND_VERSION&lt;/code&gt; true로 설정했다. (자세한 내용은 아래 &lt;code&gt;GLOBAL VARIABLES&lt;/code&gt; 섹션을 참조하십시오)</target>
        </trans-unit>
        <trans-unit id="881eef9e03334c572492df3693b2b9db2367c722" translate="yes" xml:space="preserve">
          <source>The version number of the installed module - this will be &lt;code&gt;undef&lt;/code&gt; if the module had no (or unparsable) version number, or if the variable &lt;code&gt;$Module::Load::Conditional::FIND_VERSION&lt;/code&gt; was set to true. (See the &lt;code&gt;GLOBAL VARIABLES&lt;/code&gt; section below for details)</source>
          <target state="translated">설치된 모듈의 버전 번호 -이 될 것 &lt;code&gt;undef&lt;/code&gt; 모듈이없는 (또는 해석 할) 버전 번호가 없었다, 또는 변수 경우 경우 &lt;code&gt;$Module::Load::Conditional::FIND_VERSION&lt;/code&gt; true로 설정했다. (자세한 내용은 아래 의 &lt;code&gt;GLOBAL VARIABLES&lt;/code&gt; 섹션을 참조하십시오.)</target>
        </trans-unit>
        <trans-unit id="7df3b2ff1998ec5ce67afe0561e7a92741c1659e" translate="yes" xml:space="preserve">
          <source>The version numbers for Windows 2003 and Windows Home Server are identical; the SUITEMASK field must be used to differentiate between them.</source>
          <target state="translated">Windows 2003 및 Windows Home Server의 버전 번호는 동일합니다. SUITEMASK 필드를 사용하여 구분해야합니다.</target>
        </trans-unit>
        <trans-unit id="e0209883e46d2f3d87480f57905626dfd8d2e876" translate="yes" xml:space="preserve">
          <source>The version numbers for Windows 7 and Windows Server 2008 R2 are identical; the PRODUCTTYPE field must be used to differentiate between them.</source>
          <target state="translated">Windows 7 및 Windows Server 2008 R2의 버전 번호는 동일합니다. PRODUCTTYPE 필드를 사용하여 구분해야합니다.</target>
        </trans-unit>
        <trans-unit id="d3168417cf9b56ff32b762909d40ba25ab0407e1" translate="yes" xml:space="preserve">
          <source>The version numbers for Windows 8 and Windows Server 2012 are identical; the PRODUCTTYPE field must be used to differentiate between them.</source>
          <target state="translated">Windows 8 및 Windows Server 2012의 버전 번호는 동일합니다. PRODUCTTYPE 필드를 사용하여 구분해야합니다.</target>
        </trans-unit>
        <trans-unit id="f7672ecea9c16e88589676b7a7fa4e019bcc4830" translate="yes" xml:space="preserve">
          <source>The version numbers for Windows Vista and Windows Server 2008 are identical; the PRODUCTTYPE field must be used to differentiate between them.</source>
          <target state="translated">Windows Vista 및 Windows Server 2008의 버전 번호는 동일합니다. PRODUCTTYPE 필드를 사용하여 구분해야합니다.</target>
        </trans-unit>
        <trans-unit id="c7a46a8ab62276eba4b76cf2918d64eaf428fd45" translate="yes" xml:space="preserve">
          <source>The version of PA-RISC at the time of this document's last update is 2.0, which is also the last there will be. HP PA-RISC systems are usually referred to with model description &quot;HP 9000&quot;. The last CPU in this series is the PA-8900. Support for PA-RISC architectured machines officially ends as shown in the following table:</source>
          <target state="translated">이 문서의 마지막 업데이트 시점의 PA-RISC 버전은 2.0이며 마지막 버전입니다. HP PA-RISC 시스템은 일반적으로 &quot;HP 9000&quot;모델 설명으로 참조됩니다. 이 시리즈의 마지막 CPU는 PA-8900입니다. PA-RISC 아키텍처 머신에 대한 지원은 공식적으로 다음 표와 같이 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="d9cdcafc4749e48949c53b1e0f4aeffeae610286" translate="yes" xml:space="preserve">
          <source>The version of ext() which is executed under VMS differs from the Unix-OS/2 version in several respects:</source>
          <target state="translated">VMS에서 실행되는 ext () 버전은 여러 측면에서 Unix-OS / 2 버전과 다릅니다.</target>
        </trans-unit>
        <trans-unit id="fa000c815a6c1f4aa9d1d3cce6270062ea44f5d2" translate="yes" xml:space="preserve">
          <source>The version of ext() which is executed under Win32 differs from the Unix-OS/2 version in several respects:</source>
          <target state="translated">Win32에서 실행되는 ext () 버전은 여러 측면에서 Unix-OS / 2 버전과 다릅니다.</target>
        </trans-unit>
        <trans-unit id="eea453196c9ecc4c3ad7040390519b5e41971ecc" translate="yes" xml:space="preserve">
          <source>The version of perl that you are using does not implement Vstrings, to use &lt;a href=&quot;#isvstring&quot;&gt;&quot;isvstring&quot;&lt;/a&gt; you will need to use a newer release of perl.</source>
          <target state="translated">사용중인 perl 버전은 Vstrings를 구현하지 않습니다. &lt;a href=&quot;#isvstring&quot;&gt;&quot;isvstring&quot;&lt;/a&gt; 을 사용하려면 최신 버전의 perl을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="04c1fecbb3d585e94f9621773c665e2e2cd3f97d" translate="yes" xml:space="preserve">
          <source>The version of perl that you are using does not implement Vstrings, to use &lt;a href=&quot;#isvstring&quot;&gt;isvstring&lt;/a&gt; you will need to use a newer release of perl.</source>
          <target state="translated">당신이 사용하는, Vstrings를 구현하지 않습니다 사용하고 있는지 펄의 버전 &lt;a href=&quot;#isvstring&quot;&gt;isvstring&lt;/a&gt; 는 펄의 최신 버전을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="decdd9bf0416592f2797901080148ed0ab06c7cc" translate="yes" xml:space="preserve">
          <source>The version of perl that you are using does not implement weak references, to use &lt;a href=&quot;#isweak&quot;&gt;&quot;isweak&quot;&lt;/a&gt; or &lt;a href=&quot;#weaken&quot;&gt;&quot;weaken&quot;&lt;/a&gt; you will need to use a newer release of perl.</source>
          <target state="translated">사용중인 perl 버전은 약한 참조를 구현하지 않습니다. &lt;a href=&quot;#isweak&quot;&gt;&quot;isweak&quot;&lt;/a&gt; 또는 &lt;a href=&quot;#weaken&quot;&gt;&quot; &lt;/a&gt;weaken&quot; 을 사용하려면 최신 버전의 perl을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="f8f3dd17d141437206c98482882771da9fd578da" translate="yes" xml:space="preserve">
          <source>The version of perl that you are using does not implement weak references, to use &lt;a href=&quot;#isweak&quot;&gt;isweak&lt;/a&gt; or &lt;a href=&quot;#weaken&quot;&gt;weaken&lt;/a&gt; you will need to use a newer release of perl.</source>
          <target state="translated">사용중인 perl의 버전은 약한 참조를 구현하지 않으므로 &lt;a href=&quot;#isweak&quot;&gt;iswaak&lt;/a&gt; 를 사용 하거나 &lt;a href=&quot;#weaken&quot;&gt;약화&lt;/a&gt; 하려면 새로운 perl 릴리스를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="93c33ec188f162276af3a60f34074e13ed0b75fe" translate="yes" xml:space="preserve">
          <source>The version of the distribution to which the META.yml file refers.</source>
          <target state="translated">META.yml 파일이 참조하는 배포 버전입니다.</target>
        </trans-unit>
        <trans-unit id="d68f5af181947e373672838e7416d0d6d5457c72" translate="yes" xml:space="preserve">
          <source>The version of the distribution to which the META.yml file refers. This is a mandatory field.</source>
          <target state="translated">META.yml 파일이 참조하는 배포 버전입니다. 이것은 필수 필드입니다.</target>
        </trans-unit>
        <trans-unit id="64bb3d6c21bf2a657e7026f0eee7644697eafb33" translate="yes" xml:space="preserve">
          <source>The version of the module distributed with Perl should, whenever possible, be the latest version of the module as distributed by the author (the latest non-beta version in the case of public Perl releases), although the pumpkin holder may hold off on upgrading the version of the module distributed with Perl to the latest version until the latest version has had sufficient testing.</source>
          <target state="translated">호박 홀더가 업그레이드를 보류 할 수 있지만 Perl과 함께 배포 된 모듈 버전은 가능하면 작성자가 배포 한 최신 버전의 모듈 (공개 Perl 릴리스의 경우 베타 버전이 아닌 최신 버전)이어야합니다. 최신 버전이 충분히 테스트 될 때까지 Perl과 함께 배포 된 모듈 버전이 최신 버전으로 배포됩니다.</target>
        </trans-unit>
        <trans-unit id="b21f22d5179989f705ed9d6a2a79b769acbc417d" translate="yes" xml:space="preserve">
          <source>The version of the module in the Perl core should still be considered the work of the original author. All patches, bug reports, and so forth should be fed back to them. Their development directions should be respected whenever possible.</source>
          <target state="translated">Perl 코어의 모듈 버전은 여전히 ​​원래 작성자의 작업으로 간주되어야합니다. 모든 패치, 버그 보고서 등은 그들에게 피드백되어야합니다. 개발 방향은 가능할 때마다 존중해야합니다.</target>
        </trans-unit>
        <trans-unit id="92d384762292f03ed396ad91a060564bf7d9627e" translate="yes" xml:space="preserve">
          <source>The version this module needs to be -- this is optional</source>
          <target state="translated">이 모듈이 필요한 버전-이것은 선택적입니다</target>
        </trans-unit>
        <trans-unit id="7c293dc4ef8b29552aa12216990ef31577ac2eeb" translate="yes" xml:space="preserve">
          <source>The versions of as and ld supplied with Solaris work fine for building perl. There is normally no need to install the GNU versions to compile perl.</source>
          <target state="translated">Solaris와 함께 제공된 as 및 ld 버전은 perl을 빌드하는 데 적합합니다. 일반적으로 perl을 컴파일하기 위해 GNU 버전을 설치할 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="991e6e65f67b3a36b7e485bd86d8f440ac42e72f" translate="yes" xml:space="preserve">
          <source>The very end of the document:</source>
          <target state="translated">문서의 끝 :</target>
        </trans-unit>
        <trans-unit id="c59ec45ae7f53d6bfeaac3f5d1524ea40228db75" translate="yes" xml:space="preserve">
          <source>The very first thing you should do is look into getting the Term::ReadKey extension from CPAN. As we mentioned earlier, it now even has limited support for non-portable (read: not open systems, closed, proprietary, not POSIX, not Unix, etc.) systems.</source>
          <target state="translated">가장 먼저해야 할 일은 CPAN에서 Term :: ReadKey 확장을 얻는 것입니다. 앞에서 언급했듯이 이제는 이식 불가능한 (읽기 : 개방형 시스템, 폐쇄 형, 독점 형, POSIX, 유닉스 등이 아닌) 시스템에 대한 지원이 제한적입니다.</target>
        </trans-unit>
        <trans-unit id="a54a90d3a077b2809332364bbb3b822680082301" translate="yes" xml:space="preserve">
          <source>The volume portion is always returned with a trailing &quot;:&quot;. The directory portion is always returned with a leading (to denote a relative path) and a trailing &quot;:&quot; (to denote a directory). The file portion is always returned</source>
          <target state="translated">볼륨 부분은 항상 후행 &quot;:&quot;과 함께 반환됩니다. 디렉토리 부분은 항상 선행 (상대 경로를 나타냄)과 후행 &quot;:&quot;(디렉토리를 나타냄)과 함께 리턴됩니다. 파일 부분은 항상 반환됩니다</target>
        </trans-unit>
        <trans-unit id="1ec332efc336ec299c7acc49f0d1e2fc497986e3" translate="yes" xml:space="preserve">
          <source>The wanted function</source>
          <target state="translated">원하는 기능</target>
        </trans-unit>
        <trans-unit id="6125dd5f3b647dbf86db0b504a3821e5fb95de7e" translate="yes" xml:space="preserve">
          <source>The wanted function takes no arguments but rather does its work through a collection of variables.</source>
          <target state="translated">원하는 함수는 인수를 취하지 않고 변수 모음을 통해 작동합니다.</target>
        </trans-unit>
        <trans-unit id="20d73a1883be618af881251a4f69445af19dc1a9" translate="yes" xml:space="preserve">
          <source>The warning category (or categories) packed into a &lt;code&gt;SVuv&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;SVuv&lt;/code&gt; 에 압축 된 경고 범주 (또는 범주) 입니다.</target>
        </trans-unit>
        <trans-unit id="badd12b3cb878c5659d7f27917ce9ac00752a63d" translate="yes" xml:space="preserve">
          <source>The warning is considered severe enough not to be affected by the &lt;b&gt;-w&lt;/b&gt; switch (or its absence) because previously compiled invocations of the function will still be using the old value of the function. If you need to be able to redefine the subroutine, you need to ensure that it isn't inlined, either by dropping the &lt;code&gt;()&lt;/code&gt; prototype (which changes calling semantics, so beware) or by thwarting the inlining mechanism in some other way, e.g. by adding an explicit &lt;code&gt;&lt;a href=&quot;functions/return&quot;&gt;return&lt;/a&gt;&lt;/code&gt;, as mentioned above:</source>
          <target state="translated">이전에 컴파일 된 함수 호출은 여전히 ​​함수의 이전 값을 사용하므로 경고는 &lt;b&gt;-w&lt;/b&gt; 스위치의 영향을받지 않을 정도로 심각하다고 간주 됩니다. 서브 루틴을 재정의 할 수 있어야하는 경우 &lt;code&gt;()&lt;/code&gt; 프로토 타입 을 삭제 ( 시맨틱을 호출하는 의미를 변경하므로주의해야 함)하거나 인라인 메커니즘을 다른 방식으로 차단하여 서브 루틴이 인라인되지 않도록해야합니다. 위에서 언급 한 것처럼 명시적인 &lt;code&gt;&lt;a href=&quot;functions/return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; 을 추가하여 :</target>
        </trans-unit>
        <trans-unit id="dad69db2f27b61d28a567c57b099e70158211293" translate="yes" xml:space="preserve">
          <source>The warning is considered severe enough not to be affected by the &lt;b&gt;-w&lt;/b&gt; switch (or its absence) because previously compiled invocations of the function will still be using the old value of the function. If you need to be able to redefine the subroutine, you need to ensure that it isn't inlined, either by dropping the &lt;code&gt;()&lt;/code&gt; prototype (which changes calling semantics, so beware) or by thwarting the inlining mechanism in some other way, e.g. by adding an explicit &lt;code&gt;return&lt;/code&gt;, as mentioned above:</source>
          <target state="translated">경고는 이전에 컴파일 된 함수 호출이 여전히 함수의 이전 값을 사용하기 때문에 &lt;b&gt;-w&lt;/b&gt; 스위치 (또는 그 부재)의 영향을받지 않을 정도로 심각한 것으로 간주 됩니다. 서브 루틴을 재정의 할 수 있어야하는 경우 &lt;code&gt;()&lt;/code&gt; 프로토 타입 을 삭제하거나 ( 호출 의미를 변경하므로주의해야 함) 인라인 메커니즘을 다른 방식으로 방해하여 인라인 되지 않았는지 확인해야합니다. 위에서 언급했듯이 명시적인 &lt;code&gt;return&lt;/code&gt; 을 추가하여 :</target>
        </trans-unit>
        <trans-unit id="228748e063ab0367333a5d358a372ffaa2776b68" translate="yes" xml:space="preserve">
          <source>The way I see this being used is like basically this:</source>
          <target state="translated">내가 사용되는 방식은 기본적으로 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="bf8410bbe832531f3fd9213bd8f3ba1287e55dc6" translate="yes" xml:space="preserve">
          <source>The way Perl builds up these op trees in the parsing process can be unravelled by examining</source>
          <target state="translated">펄이 파싱 과정에서 이러한 op 트리를 구축하는 방식은 다음과 같이 풀 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b9a4e5fa4cbdb6cec50f6eac70c4ad531843cef7" translate="yes" xml:space="preserve">
          <source>The way Test::More handles this is with a named block. Basically, a block of tests which can be skipped over or made todo. It's best if I just show you...</source>
          <target state="translated">Test :: More가이를 처리하는 방식은 명명 된 블록을 사용하는 것입니다. 기본적으로 건너 뛰거나 수행 할 수있는 테스트 블록입니다. 내가 보여 주면 최고야 ...</target>
        </trans-unit>
        <trans-unit id="3a44ce079c4bba6650cbd971c39500928ccb7c22" translate="yes" xml:space="preserve">
          <source>The way a program responds to an error. The exception-handling mechanism in Perl is the &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; operator.</source>
          <target state="translated">프로그램이 오류에 응답하는 방식. Perl의 예외 처리 메커니즘은 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 연산자입니다.</target>
        </trans-unit>
        <trans-unit id="485d9ec05d9e7ee1509acc95cd728f99a6dde4db" translate="yes" xml:space="preserve">
          <source>The way a program responds to an error. The exception-handling mechanism in Perl is the &lt;code&gt;eval&lt;/code&gt; operator.</source>
          <target state="translated">프로그램이 오류에 응답하는 방식. Perl의 예외 처리 메커니즘은 &lt;code&gt;eval&lt;/code&gt; 연산자입니다.</target>
        </trans-unit>
        <trans-unit id="39341ae7c243431172aa717f037dcb000913133f" translate="yes" xml:space="preserve">
          <source>The way it resolves which actual method to call is:</source>
          <target state="translated">호출 할 실제 메소드를 해결하는 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2ecf3674cf5632aa049fa7e267f9fbd82a5b7877" translate="yes" xml:space="preserve">
          <source>The way it works is that when the &lt;code&gt;@{...}&lt;/code&gt; is seen in the double-quoted string, it's evaluated as a block. The block creates a reference to an anonymous array containing the results of the call to &lt;code&gt;mysub(1,2,3)&lt;/code&gt; . So the whole block returns a reference to an array, which is then dereferenced by &lt;code&gt;@{...}&lt;/code&gt; and stuck into the double-quoted string. This chicanery is also useful for arbitrary expressions:</source>
          <target state="translated">작동 방식은 &lt;code&gt;@{...}&lt;/code&gt; 가 큰 따옴표로 묶인 문자열에 표시되면 블록으로 평가된다는 것입니다. 블록은 &lt;code&gt;mysub(1,2,3)&lt;/code&gt; 에 대한 호출 결과를 포함하는 익명 배열에 대한 참조를 작성합니다 . 따라서 전체 블록은 배열에 대한 참조를 반환하며,이 배열은 &lt;code&gt;@{...}&lt;/code&gt; 의해 역 참조되고 큰 따옴표로 묶인 문자열에 고정됩니다. 이 chicanery는 임의의 표현에도 유용합니다.</target>
        </trans-unit>
        <trans-unit id="22373b22c059855720b294750ec63ef1e1b487f7" translate="yes" xml:space="preserve">
          <source>The way it works is that when the &lt;code&gt;@{...}&lt;/code&gt; is seen in the double-quoted string, it's evaluated as a block. The block creates a reference to an anonymous array containing the results of the call to &lt;code&gt;mysub(1,2,3)&lt;/code&gt;. So the whole block returns a reference to an array, which is then dereferenced by &lt;code&gt;@{...}&lt;/code&gt; and stuck into the double-quoted string. This chicanery is also useful for arbitrary expressions:</source>
          <target state="translated">작동 방식은 &lt;code&gt;@{...}&lt;/code&gt; 가 큰 따옴표로 묶인 문자열에 표시 될 때 블록으로 평가된다는 것입니다. 이 블록은 &lt;code&gt;mysub(1,2,3)&lt;/code&gt; 에 대한 호출 결과를 포함하는 익명 배열에 대한 참조를 생성합니다 . 따라서 전체 블록은 배열에 대한 참조를 반환 한 다음 &lt;code&gt;@{...}&lt;/code&gt; 의해 역 참조되고 큰 따옴표로 묶인 문자열에 고정됩니다. 이 chicanery는 임의의 표현에도 유용합니다.</target>
        </trans-unit>
        <trans-unit id="464aa10ca9c1c0eb18ad0b5fbb41c9f2af8f5587" translate="yes" xml:space="preserve">
          <source>The way this trick works is that the character with the code point &lt;code&gt;U+FFFE&lt;/code&gt; is not supposed to be in input streams, so the sequence of bytes &lt;code&gt;0xFF 0xFE&lt;/code&gt; is unambiguously &quot;&lt;code&gt;BOM&lt;/code&gt; , represented in little-endian format&quot; and cannot be &lt;code&gt;U+FFFE&lt;/code&gt; , represented in big-endian format&quot;.</source>
          <target state="translated">이 트릭이 작동하는 방식은 코드 포인트가 &lt;code&gt;U+FFFE&lt;/code&gt; 인 문자가 입력 스트림에 있지 않아야하기 때문에 바이트 &lt;code&gt;0xFF 0xFE&lt;/code&gt; 의 시퀀스는 &quot; 작은 엔디안 형식으로 표현 된 &lt;code&gt;BOM&lt;/code&gt; &quot;이며 &lt;code&gt;U+FFFE&lt;/code&gt; 일 수 없습니다. , 빅 엔디안 형식으로 표시됩니다. &quot;</target>
        </trans-unit>
        <trans-unit id="03d93acd73703280d7e5deb9019540799404d722" translate="yes" xml:space="preserve">
          <source>The way this trick works is that the character with the code point &lt;code&gt;U+FFFE&lt;/code&gt; is not supposed to be in input streams, so the sequence of bytes &lt;code&gt;0xFF 0xFE&lt;/code&gt; is unambiguously &quot;&lt;code&gt;BOM&lt;/code&gt;, represented in little-endian format&quot; and cannot be &lt;code&gt;U+FFFE&lt;/code&gt;, represented in big-endian format&quot;.</source>
          <target state="translated">이 트릭이 작동하는 방식은 코드 포인트 &lt;code&gt;U+FFFE&lt;/code&gt; 가 있는 문자가 입력 스트림에 있어야한다는 것입니다. 따라서 바이트 &lt;code&gt;0xFF 0xFE&lt;/code&gt; 의 시퀀스 는 명확하게 &quot; &lt;code&gt;BOM&lt;/code&gt; , little-endian 형식으로 표시&quot;이며 &lt;code&gt;U+FFFE&lt;/code&gt; 가 될 수 없습니다. , 빅 엔디안 형식으로 표시 &quot;.</target>
        </trans-unit>
        <trans-unit id="3f55c636a9c9c26eb587e152e4c24ce7d11dc1f3" translate="yes" xml:space="preserve">
          <source>The way this works under-the-hood is that every thread has a choice of using a locale specific to it (this is the Windows and POSIX 2008 functionality), or the global locale that is accessible to all threads (this is the functionality that has always been there). The implementations for Windows and POSIX are completely different. On Windows, the runtime can be set up so that the standard &lt;a href=&quot;setlocale(3)&quot;&gt;&lt;code&gt;setlocale(3)&lt;/code&gt;&lt;/a&gt; function either only knows about the global locale or the locale for this thread. On POSIX, &lt;code&gt;setlocale&lt;/code&gt; always deals with the global locale, and other functions have been created to handle per-thread locales. Perl makes this transparent to perl-space code. It continues to use &lt;code&gt;POSIX::setlocale()&lt;/code&gt;, and the interpreter translates that into the per-thread functions.</source>
          <target state="translated">이것이 내부에서 작동하는 방식은 모든 스레드가 특정 로케일 (Windows 및 POSIX 2008 기능)을 사용하거나 모든 스레드에 액세스 할 수있는 전역 로케일 (이 기능은 항상 거기에 있었다). Windows 및 POSIX의 구현은 완전히 다릅니다. Windows에서는 표준 &lt;a href=&quot;setlocale(3)&quot;&gt; &lt;code&gt;setlocale(3)&lt;/code&gt; &lt;/a&gt; 함수가 전역 로케일 또는이 스레드의 로케일 만 인식 하도록 런타임을 설정할 수 있습니다 . POSIX에서 &lt;code&gt;setlocale&lt;/code&gt; 은 항상 전역 로케일을 처리하며 스레드 별 로케일을 처리하기 위해 다른 함수가 작성되었습니다. Perl은 이것을 perl-space 코드에 투명하게 만듭니다. &lt;code&gt;POSIX::setlocale()&lt;/code&gt; 계속 사용 하며 인터프리터는이를 스레드 별 함수로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="5898f48e7b39c1a379ea1247c549323ccbb46061" translate="yes" xml:space="preserve">
          <source>The way to get around this problem is to use the Berkeley DB API method called &lt;code&gt;seq&lt;/code&gt; . This method allows sequential access to key/value pairs. See &lt;a href=&quot;#THE-API-INTERFACE&quot;&gt;THE API INTERFACE&lt;/a&gt; for details of both the &lt;code&gt;seq&lt;/code&gt; method and the API in general.</source>
          <target state="translated">이 문제를 해결하는 방법은 &lt;code&gt;seq&lt;/code&gt; 라는 Berkeley DB API 메소드를 사용하는 것 입니다. 이 방법을 사용하면 키 / 값 쌍에 순차적으로 액세스 할 수 있습니다. &lt;code&gt;seq&lt;/code&gt; 메소드와 일반적으로 API에 대한 자세한 내용은 &lt;a href=&quot;#THE-API-INTERFACE&quot;&gt;API 인터페이스&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="365d9cd3356a85ac2e3ab542f36bc2743ee69357" translate="yes" xml:space="preserve">
          <source>The way to get around this problem is to use the Berkeley DB API method called &lt;code&gt;seq&lt;/code&gt;. This method allows sequential access to key/value pairs. See &lt;a href=&quot;#THE-API-INTERFACE&quot;&gt;&quot;THE API INTERFACE&quot;&lt;/a&gt; for details of both the &lt;code&gt;seq&lt;/code&gt; method and the API in general.</source>
          <target state="translated">이 문제를 해결하는 방법은 &lt;code&gt;seq&lt;/code&gt; 라는 Berkeley DB API 메서드를 사용하는 것 입니다. 이 방법을 사용하면 키 / 값 쌍에 순차적으로 액세스 할 수 있습니다. 참조 &lt;a href=&quot;#THE-API-INTERFACE&quot;&gt;는 &quot;API 인터페이스&quot;&lt;/a&gt; 양쪽의 자세한 내용은 &lt;code&gt;seq&lt;/code&gt; 방법 일반적으로 API를.</target>
        </trans-unit>
        <trans-unit id="cd500d8c20565e5f312bdd0b6574f8c8052649e9" translate="yes" xml:space="preserve">
          <source>The way to use this class is to make a new object of this class, set any options, and then call one of the search options (probably &lt;code&gt;survey&lt;/code&gt; or &lt;code&gt;find&lt;/code&gt; ). The sections below discuss the syntaxes for doing all that.</source>
          <target state="translated">이 클래스를 사용하는 방법은이 클래스의 새 객체를 만들고 옵션을 설정 한 다음 검색 옵션 중 하나를 호출하는 것입니다 ( &lt;code&gt;survey&lt;/code&gt; 또는 &lt;code&gt;find&lt;/code&gt; ). 아래 섹션에서는 모든 것을 수행하는 구문에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="70dcc819697307fd63c00ab11c88076b157ec890" translate="yes" xml:space="preserve">
          <source>The way to use this class is to make a new object of this class, set any options, and then call one of the search options (probably &lt;code&gt;survey&lt;/code&gt; or &lt;code&gt;find&lt;/code&gt;). The sections below discuss the syntaxes for doing all that.</source>
          <target state="translated">이 클래스를 사용하는 방법은이 클래스의 새 객체를 만들고 옵션을 설정 한 다음 검색 옵션 중 하나를 호출하는 것입니다 (아마도 &lt;code&gt;survey&lt;/code&gt; 또는 &lt;code&gt;find&lt;/code&gt; ). 아래 섹션에서는 모든 작업을 수행하는 구문에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="5268c05807fff3d270f4531a0cd21a77634cf686" translate="yes" xml:space="preserve">
          <source>The web server handling the HTTP service is assumed to be at its standard port, number 80. If the server you're trying to connect to is at a different port, like 1080 or 8080, you should specify it as the named-parameter pair, &lt;code&gt;PeerPort =&amp;gt; 8080&lt;/code&gt; . The &lt;code&gt;autoflush&lt;/code&gt; method is used on the socket because otherwise the system would buffer up the output we sent it. (If you're on a prehistoric Mac, you'll also need to change every &lt;code&gt;&quot;\n&quot;&lt;/code&gt; in your code that sends data over the network to be a &lt;code&gt;&quot;\015\012&quot;&lt;/code&gt; instead.)</source>
          <target state="translated">HTTP 서비스를 처리하는 웹 서버는 표준 포트 (번호 80)에있는 것으로 가정합니다. 연결하려는 서버가 1080 또는 8080과 같은 다른 포트에 있으면 이름 지정된 매개 변수 쌍으로 지정해야합니다. , &lt;code&gt;PeerPort =&amp;gt; 8080&lt;/code&gt; 입니다. 자동 &lt;code&gt;autoflush&lt;/code&gt; 메소드는 소켓에서 사용됩니다. 그렇지 않으면 시스템이 우리가 보낸 출력을 버퍼링하기 때문입니다. 선사 시대의 Mac을 사용하는 경우 네트워크를 통해 데이터를 보내는 &lt;code&gt;&quot;\n&quot;&lt;/code&gt; 코드를 &lt;code&gt;&quot;\015\012&quot;&lt;/code&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="c2c0fa4dc9353a78eef2a13048e071f4e11d6efd" translate="yes" xml:space="preserve">
          <source>The web server handling the HTTP service is assumed to be at its standard port, number 80. If the server you're trying to connect to is at a different port, like 1080 or 8080, you should specify it as the named-parameter pair, &lt;code&gt;PeerPort =&amp;gt; 8080&lt;/code&gt;. The &lt;code&gt;autoflush&lt;/code&gt; method is used on the socket because otherwise the system would buffer up the output we sent it. (If you're on a prehistoric Mac, you'll also need to change every &lt;code&gt;&quot;\n&quot;&lt;/code&gt; in your code that sends data over the network to be a &lt;code&gt;&quot;\015\012&quot;&lt;/code&gt; instead.)</source>
          <target state="translated">HTTP 서비스를 처리하는 웹 서버는 표준 포트 인 80 번에 있다고 가정합니다. 연결하려는 서버가 1080 또는 8080과 같은 다른 포트에있는 경우 이름이 지정된 매개 변수 쌍으로 지정해야합니다. , &lt;code&gt;PeerPort =&amp;gt; 8080&lt;/code&gt; . &lt;code&gt;autoflush&lt;/code&gt; 그렇지 않으면 시스템이 우리가 그것을 전송 출력을 버퍼링 때문에 방법은 소켓에 사용됩니다. (선사 시대 Mac을 사용하는 경우 네트워크를 통해 데이터를 보내는 코드의 모든 &lt;code&gt;&quot;\n&quot;&lt;/code&gt; &lt;code&gt;&quot;\015\012&quot;&lt;/code&gt; 대신 &quot;\ 015 \ 012&quot;로 변경해야 합니다.)</target>
        </trans-unit>
        <trans-unit id="b22573d6d6dbb31578b3c4fa9e8a17816a358dfc" translate="yes" xml:space="preserve">
          <source>The well known Unicode Byte Order Marks are as follows: if the file begins with the two literal byte values 0xFE 0xFF, this is the BOM for big-endian UTF-16. If the file begins with the two literal byte value 0xFF 0xFE, this is the BOM for little-endian UTF-16. On an ASCII platform, if the file begins with the three literal byte values 0xEF 0xBB 0xBF, this is the BOM for UTF-8. A mechanism portable to EBCDIC platforms is to:</source>
          <target state="translated">잘 알려진 유니 코드 바이트 순서 표시는 다음과 같습니다. 파일이 두 개의 리터럴 바이트 값 0xFE 0xFF로 시작하면 이것이 빅 엔디안 UTF-16의 BOM입니다. 파일이 2 개의 리터럴 바이트 값 0xFF 0xFE로 시작하면 리틀 엔디안 UTF-16의 BOM입니다. ASCII 플랫폼에서 파일이 3 개의 리터럴 바이트 값 0xEF 0xBB 0xBF로 시작하면 UTF-8의 BOM입니다. EBCDIC 플랫폼에 이식 가능한 메커니즘은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c25fe7dd72c3069b0e017baa01097278ab17f62e" translate="yes" xml:space="preserve">
          <source>The while loop from line 14 to line 26 grabs a scalar off the input queue and checks against the prime this thread is responsible for. Line 15 checks to see if there's a remainder when we divide the number to be checked by our prime. If there is one, the number must not be evenly divisible by our prime, so we need to either pass it on to the next thread if we've created one (line 17) or create a new thread if we haven't.</source>
          <target state="translated">라인 14에서 라인 26까지의 while 루프는 입력 큐에서 스칼라를 잡고이 스레드가 담당하는 소수를 검사합니다. 15 번 줄은 소수로 확인할 숫자를 나눌 때 나머지가 있는지 확인합니다. 하나가있는 경우 소수는 소수로 나눌 수 없어야하므로 하나를 만들면 다음 스레드로 전달하거나 (17 행) 그렇지 않으면 새 스레드를 만들어야합니다.</target>
        </trans-unit>
        <trans-unit id="a997f7e1957d2b943d666798431c61228059e247" translate="yes" xml:space="preserve">
          <source>The whole Unicode standard &lt;a href=&quot;http://www.unicode.org/unicode/uni2book/u2.html&quot;&gt;http://www.unicode.org/unicode/uni2book/u2.html&lt;/a&gt;</source>
          <target state="translated">전체 유니 코드 표준 &lt;a href=&quot;http://www.unicode.org/unicode/uni2book/u2.html&quot;&gt;http://www.unicode.org/unicode/uni2book/u2.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="52ed5e8abe2195d94e62a75cf32bf369a78b18af" translate="yes" xml:space="preserve">
          <source>The whole idea of the &quot;standard C API to start applications&quot; is that the forms &lt;code&gt;foo&lt;/code&gt; and &lt;code&gt;&quot;foo&quot;&lt;/code&gt; of program arguments are completely interchangeable.</source>
          <target state="translated">&quot;응용 프로그램을 시작하는 표준 C API&quot;의 전체 아이디어는 프로그램 인수의 &lt;code&gt;foo&lt;/code&gt; 및 &lt;code&gt;&quot;foo&quot;&lt;/code&gt; 형식 이 완전히 호환 가능 하다는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="0fe54c442e0898f0c65d2e7e96e6d557275adef9" translate="yes" xml:space="preserve">
          <source>The whole scheme for interpreting two-digit years can be considered a bug.</source>
          <target state="translated">두 자리 연도를 해석하기위한 전체 계획은 버그로 간주 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="06823ddcb564d7e0125b4ed62adb0242c15ff840" translate="yes" xml:space="preserve">
          <source>The wide character is not used in the &lt;code&gt;&amp;amp;&lt;/code&gt; operation because the left operand is shorter. This now throws an exception.</source>
          <target state="translated">왼쪽 피연산자가 더 짧기 때문에 와이드 문자는 &lt;code&gt;&amp;amp;&lt;/code&gt; 연산 에서 사용되지 않습니다 . 이제 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="a5992a1d1d14f7a847e98f6f7210198b195d54e7" translate="yes" xml:space="preserve">
          <source>The wide-character-specific (Unicode) functions. Each of these is just the same as the version without the trailing &quot;W&quot; except that strings are expected in Unicode and some lengths are measured as number of &lt;code&gt;WCHAR&lt;/code&gt;s instead of number of bytes, as indicated below.</source>
          <target state="translated">와이드 문자 별 (유니 코드) 함수입니다. 이들 각각은 문자열이 유니 코드로 예상되고 일부 길이가 아래에 표시된대로 바이트 수 대신 &lt;code&gt;WCHAR&lt;/code&gt; 수로 측정된다는 점을 제외하면 후행 &quot;W&quot;가없는 버전과 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="d301a149055986dea057eaf7f10ce99a292fd767" translate="yes" xml:space="preserve">
          <source>The width of the left margin in spaces. Defaults to 0. This is the margin for all text, including headings, not the amount by which regular text is indented; for the latter, see &lt;b&gt;-i&lt;/b&gt; option.</source>
          <target state="translated">공백에서 왼쪽 여백의 너비입니다. 기본값은 0입니다. 이것은 일반 텍스트가 들여 쓰기되는 양이 아니라 제목을 포함한 모든 텍스트의 여백입니다. 후자의 경우 &lt;b&gt;-i&lt;/b&gt; 옵션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="00b688a33a04cf250468fb3feaca19bab2ec26fc" translate="yes" xml:space="preserve">
          <source>The width of the left margin in spaces. Defaults to 0. This is the margin for all text, including headings, not the amount by which regular text is indented; for the latter, see the</source>
          <target state="translated">공백에서 왼쪽 여백의 너비입니다. 기본값은 0입니다. 이것은 일반 텍스트가 들여 쓰기되는 양이 아니라 제목을 포함한 모든 텍스트의 여백입니다. 후자에 대해서는</target>
        </trans-unit>
        <trans-unit id="9f8ba2c52e40b69413c01ffc592fe399547fc20f" translate="yes" xml:space="preserve">
          <source>The word returned by the &lt;code&gt;&lt;a href=&quot;functions/ref&quot;&gt;ref&lt;/a&gt;&lt;/code&gt; function when you apply it to a reference to a subroutine. See also &lt;b&gt;CV&lt;/b&gt;.</source>
          <target state="translated">서브 루틴에 대한 참조에 적용 할 때 &lt;code&gt;&lt;a href=&quot;functions/ref&quot;&gt;ref&lt;/a&gt;&lt;/code&gt; 함수에 의해 리턴되는 단어 . &lt;b&gt;CV&lt;/b&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="6d42ff99a16e8f67b82856c6d2b84806cf10fd36" translate="yes" xml:space="preserve">
          <source>The word returned by the &lt;code&gt;ref&lt;/code&gt; function when you apply it to a reference to a subroutine. See also &lt;b&gt;CV&lt;/b&gt;.</source>
          <target state="translated">서브 루틴에 대한 참조에 적용 할 때 &lt;code&gt;ref&lt;/code&gt; 함수에서 반환하는 단어 입니다. &lt;b&gt;CV를&lt;/b&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="28be5b370df296bc57d076e1c2849a0ebee70013" translate="yes" xml:space="preserve">
          <source>The work isn't over until the paperwork is done, and you're going to need to put in some time writing some documentation for your module. &lt;code&gt;module-starter&lt;/code&gt; or &lt;code&gt;h2xs&lt;/code&gt; will provide a stub for you to fill in; if you're not sure about the format, look at &lt;a href=&quot;perlpod&quot;&gt;perlpod&lt;/a&gt; for an introduction. Provide a good synopsis of how your module is used in code, a description, and then notes on the syntax and function of the individual subroutines or methods. Use Perl comments for developer notes and POD for end-user notes.</source>
          <target state="translated">서류 작업이 끝날 때까지 작업이 끝나지 않으며 모듈에 대한 문서를 작성하는 데 약간의 시간이 필요합니다. &lt;code&gt;module-starter&lt;/code&gt; 또는 &lt;code&gt;h2xs&lt;/code&gt; 는 작성을위한 스텁을 제공합니다. 형식에 대해 잘 &lt;a href=&quot;perlpod&quot;&gt;모르면 perlpod&lt;/a&gt; 에서 소개 를 찾으십시오 . 코드가 모듈에서 어떻게 사용되는지, 설명을 제공 한 다음 개별 서브 루틴 또는 메소드의 구문과 기능에 대한 참고 사항을 제공합니다. 개발자 노트에는 Perl 주석을 사용하고 최종 사용자 노트에는 POD를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="a31887edd2b89b26426a7d0c030500f19faef476" translate="yes" xml:space="preserve">
          <source>The work of the interpreter has two main stages: compiling the code into the internal representation, or bytecode, and then executing it. &lt;a href=&quot;perlguts#Compiled-code&quot;&gt;&quot;Compiled code&quot; in perlguts&lt;/a&gt; explains exactly how the compilation stage happens.</source>
          <target state="translated">인터프리터의 작업에는 코드를 내부 표현 또는 바이트 코드로 컴파일 한 다음 실행하는 두 가지 주요 단계가 있습니다. &lt;a href=&quot;perlguts#Compiled-code&quot;&gt;perlguts의 &quot;컴파일 된 코드&quot;&lt;/a&gt; 는 컴파일 단계가 어떻게 발생하는지 정확히 설명합니다.</target>
        </trans-unit>
        <trans-unit id="1436e107c02b49fba4e33d8aaae3115ec601983a" translate="yes" xml:space="preserve">
          <source>The work of the interpreter has two main stages: compiling the code into the internal representation, or bytecode, and then executing it. &lt;a href=&quot;perlguts#Compiled-code&quot;&gt;Compiled code in perlguts&lt;/a&gt; explains exactly how the compilation stage happens.</source>
          <target state="translated">인터프리터의 작업에는 코드를 내부 표현 또는 바이트 코드로 컴파일 한 다음 실행하는 두 가지 주요 단계가 있습니다. &lt;a href=&quot;perlguts#Compiled-code&quot;&gt;perlguts의 컴파일 된 코드&lt;/a&gt; 는 컴파일 단계가 어떻게 발생하는지 정확하게 설명합니다.</target>
        </trans-unit>
        <trans-unit id="8b1397bff51f75db954e0f3e3e1b665db01ca7e8" translate="yes" xml:space="preserve">
          <source>The world's languages are written in many different scripts. This sentence (unless you're reading it in translation) is written in Latin, while Russian is written in Cyrillic, and Greek is written in, well, Greek; Japanese mainly in Hiragana or Katakana. There are many more.</source>
          <target state="translated">세계 언어는 다양한 스크립트로 작성되었습니다. 이 문장 (번역으로 읽지 않는 한)은 라틴어로 작성되고 러시아어는 키릴 문자로 작성되며 그리스어는 그리스어로 작성됩니다. 히라가나 또는 가타카나에서 주로 일본어. 더 많은 것이 있습니다.</target>
        </trans-unit>
        <trans-unit id="85da59eaf7698f05d48c68376bdd4ba3b6dce3bd" translate="yes" xml:space="preserve">
          <source>The worst patches make use of system-specific features. It's highly unlikely that non-portable additions to the Perl language will be accepted.</source>
          <target state="translated">최악의 패치는 시스템 별 기능을 사용합니다. Perl 언어에 이식 불가능한 추가가 허용 될 가능성은 거의 없습니다.</target>
        </trans-unit>
        <trans-unit id="2affe5ea5db32cf7d355e39106992f04132aac2d" translate="yes" xml:space="preserve">
          <source>The write filehandle will have autoflush turned on.</source>
          <target state="translated">쓰기 파일 핸들에 자동 플러시가 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="f34726284c86402203e3588790fd3c449c8531b5" translate="yes" xml:space="preserve">
          <source>The yacc coming with BS2000 POSIX didn't work for us. So we had to use bison. We had to make a few changes to perl in order to use the pure (reentrant) parser of bison. We used version 1.25, but we had to add a few changes due to EBCDIC. See below for more details concerning yacc.</source>
          <target state="translated">BS2000 POSIX와 함께 제공되는 yacc는 우리에게 효과가 없었습니다. 그래서 우리는 들소를 사용해야했습니다. 순수한 bison 파서 (parent)를 사용하기 위해 perl을 약간 변경해야했습니다. 버전 1.25를 사용했지만 EBCDIC으로 인해 몇 가지 변경 사항을 추가해야했습니다. yacc에 대한 자세한 내용은 아래를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="0aff817087165151aec8e0b6db814baaf554f377" translate="yes" xml:space="preserve">
          <source>The z/OS Unix Tools and Toys list may prove helpful and contains links to ports of much of the software helpful for building Perl. &lt;a href=&quot;http://www.ibm.com/servers/eserver/zseries/zos/unix/bpxa1toy.html&quot;&gt;http://www.ibm.com/servers/eserver/zseries/zos/unix/bpxa1toy.html&lt;/a&gt;</source>
          <target state="translated">z / OS Unix 도구 및 장난감 목록이 도움이 될 수 있으며 Perl을 빌드하는 데 도움이되는 많은 소프트웨어 포트에 대한 링크를 포함합니다. &lt;a href=&quot;http://www.ibm.com/servers/eserver/zseries/zos/unix/bpxa1toy.html&quot;&gt;http://www.ibm.com/servers/eserver/zseries/zos/unix/bpxa1toy.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="26c38255249743d87d50270df89b2a9ebd2b4fd7" translate="yes" xml:space="preserve">
          <source>The zhuyin ordering includes some characters that are not CJK Unified Ideographs and can't utilize &lt;code&gt;weightZhuyin()&lt;/code&gt; for collation. For them, use &lt;code&gt;entry&lt;/code&gt; instead.</source>
          <target state="translated">zhuyin 순서에는 CJK 통합 표의 문자가 아니고 데이터 정렬에 &lt;code&gt;weightZhuyin()&lt;/code&gt; 을 사용할 수없는 일부 문자가 포함됩니다 . 그들을 위해 대신 &lt;code&gt;entry&lt;/code&gt; 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="f215722614928e4a382d634f12d1b784a861305a" translate="yes" xml:space="preserve">
          <source>Then &lt;code&gt;$reg&lt;/code&gt; can be used as a regexp:</source>
          <target state="translated">그런 다음 &lt;code&gt;$reg&lt;/code&gt; 를 정규 표현식으로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="de5ca28d4aa169910f5c4821c56dad5137cddc68" translate="yes" xml:space="preserve">
          <source>Then again, you could always use parentheses.</source>
          <target state="translated">그런 다음 다시 괄호를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8f720f0ca68279a1e213df21b730afd59a9417d5" translate="yes" xml:space="preserve">
          <source>Then along comes Unicode which has room for over a million characters (and Perl allows for even more). This means that a character may require more than a single byte to represent it, and so the two terms are no longer equivalent. What matter are the characters as whole entities, and not usually the bytes that comprise them. That's what the term &quot;Character Semantics&quot; in the title of this section refers to.</source>
          <target state="translated">그런 다음 백만 개 이상의 문자를 수용 할 수있는 유니 코드가 제공됩니다 (Perl은 더 많은 것을 허용합니다). 즉, 문자를 나타 내기 위해 문자에 단일 바이트 이상이 필요할 수 있으므로 두 용어가 더 이상 동일하지 않습니다. 중요한 것은 문자가 전체 엔티티이며 일반적으로 해당 문자를 구성하는 바이트가 아닙니다. 이것이이 섹션 제목의 &quot;문자 의미론&quot;이라는 용어입니다.</target>
        </trans-unit>
        <trans-unit id="48ff6c17f5c4132eb7b4e146224751484821d774" translate="yes" xml:space="preserve">
          <source>Then compile:</source>
          <target state="translated">그런 다음 컴파일하십시오.</target>
        </trans-unit>
        <trans-unit id="894eab3b8839b7526298878f8b7e43bb55872aae" translate="yes" xml:space="preserve">
          <source>Then copy setargv.obj to %PlatformSDKDir%\lib</source>
          <target state="translated">그런 다음 setargv.obj를 % PlatformSDKDir % \ lib에 복사하십시오.</target>
        </trans-unit>
        <trans-unit id="939d22a5767f7f1b738027999de54521a98a4c28" translate="yes" xml:space="preserve">
          <source>Then delete every .bundle file found anywhere in the folders:</source>
          <target state="translated">그런 다음 폴더의 모든 위치에있는 모든 .bundle 파일을 삭제하십시오.</target>
        </trans-unit>
        <trans-unit id="072381135845bbd0f86b6799cfa84f6d7fbff38f" translate="yes" xml:space="preserve">
          <source>Then go on to declare and use your variables in functions without any qualifications. See &lt;a href=&quot;exporter&quot;&gt;Exporter&lt;/a&gt; and the &lt;a href=&quot;perlmodlib&quot;&gt;perlmodlib&lt;/a&gt; for details on mechanics and style issues in module creation.</source>
          <target state="translated">그런 다음 자격없이 함수에서 변수를 선언하고 사용하십시오. 모듈 생성의 역학 및 스타일 문제에 대한 자세한 내용 은 &lt;a href=&quot;exporter&quot;&gt;내보내기&lt;/a&gt; 및 &lt;a href=&quot;perlmodlib&quot;&gt;perlmodlib&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="0260e987a9bcfe5e51c92652bad4a0b41e5cc334" translate="yes" xml:space="preserve">
          <source>Then increment any of the dotted-decimal components (v1.20.1 or v1.21.0).</source>
          <target state="translated">그런 다음 점으로 구분 된 10 진수 구성 요소 (v1.20.1 또는 v1.21.0)를 증가시킵니다.</target>
        </trans-unit>
        <trans-unit id="27efe9215ba97f3d69be224566771bce0e52d95d" translate="yes" xml:space="preserve">
          <source>Then make your changes. For example, if Leon Brocard changes his name to Orange Brocard, we should change his name in the AUTHORS file:</source>
          <target state="translated">그런 다음 변경하십시오. 예를 들어 Leon Brocard가 그의 이름을 Orange Brocard로 변경하면 AUTHORS 파일에서 그의 이름을 변경해야합니다.</target>
        </trans-unit>
        <trans-unit id="5bcffa804562972342cabda61bf0a405b76b432e" translate="yes" xml:space="preserve">
          <source>Then move the files (probably just the</source>
          <target state="translated">그런 다음 파일을 이동하십시오 (아마도</target>
        </trans-unit>
        <trans-unit id="16764d0cdf61fb44dac45d466795c94ebcc324fb" translate="yes" xml:space="preserve">
          <source>Then override the &lt;code&gt;start_for&lt;/code&gt; method in the subclass to check for when &quot;$flags-&amp;gt;{'target'}&quot; is equal to 'foo' and set a flag that marks that you're in a foo block (maybe &quot;$self-&amp;gt;{'in_foo'} = 1&quot;). Then override the &lt;code&gt;handle_text&lt;/code&gt; method to check for the flag, and pass $text to your custom subroutine to construct the HTML output for 'foo' elements, something like:</source>
          <target state="translated">그런 다음 서브 클래스에서 &lt;code&gt;start_for&lt;/code&gt; 메소드를 대체하여 &quot;$ flags- &amp;gt; { 'target'}&quot;이 'foo'인지 확인하고 foo 블록에 있음을 표시하는 플래그를 설정하십시오 ( &quot;$ self-&amp;gt; { 'in_foo'} = 1 &quot;). 그런 다음 &lt;code&gt;handle_text&lt;/code&gt; 메소드를 대체하여 플래그를 확인하고 $ text를 사용자 정의 서브 루틴에 전달하여 'foo'요소에 대한 HTML 출력을 구성하십시오.</target>
        </trans-unit>
        <trans-unit id="5906927423d13fecbc7d429a1e04d7524ab55ae4" translate="yes" xml:space="preserve">
          <source>Then run the following script (or something like it):</source>
          <target state="translated">그런 다음 다음 스크립트 (또는 이와 유사한 스크립트)를 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="dc813daf18229cd1ceaa147ef073875823c78936" translate="yes" xml:space="preserve">
          <source>Then that text and all remaining text up through and including a line beginning with &lt;code&gt;=cut&lt;/code&gt; will be ignored. The format of the intervening text is described in &lt;a href=&quot;perlpod&quot;&gt;perlpod&lt;/a&gt;.</source>
          <target state="translated">그런 다음 해당 텍스트와 &lt;code&gt;=cut&lt;/code&gt; 으로 시작하는 줄을 포함하여 남아있는 모든 텍스트 는 무시됩니다. 중재 텍스트의 형식은 &lt;a href=&quot;perlpod&quot;&gt;perlpod에&lt;/a&gt; 설명되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8606c2212e120ef5c1865576f0176c5b8ada5faa" translate="yes" xml:space="preserve">
          <source>Then the assignment with the indirection on the left-hand-side would use the existing reference that was already there:</source>
          <target state="translated">그런 다음 왼쪽에 간접적 인 할당은 이미 있던 기존 참조를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="8207f190aea8ef5aad0fa43cccb20c94bdffd926" translate="yes" xml:space="preserve">
          <source>Then the handler makes absolutely no attempt to interpret the data it receives and simply passes it as a string:</source>
          <target state="translated">그런 다음 핸들러는 수신하는 데이터를 해석하려고 시도하지 않고 단순히 문자열로 전달합니다.</target>
        </trans-unit>
        <trans-unit id="724e763cfec8edb999475aec0cbf98b0b938163f" translate="yes" xml:space="preserve">
          <source>Then the match is executed and the remaining lines describe the process:</source>
          <target state="translated">그런 다음 일치가 실행되고 나머지 줄은 프로세스를 설명합니다.</target>
        </trans-unit>
        <trans-unit id="41718c26f8da915843d6b183e2c76ef5e3a2e26d" translate="yes" xml:space="preserve">
          <source>Then to use it:</source>
          <target state="translated">그런 다음 사용하려면 :</target>
        </trans-unit>
        <trans-unit id="581e9b63d178af7824ad52db20f4431ce7a1a3ec" translate="yes" xml:space="preserve">
          <source>Then use any of those as you would a normal filehandle. Anywhere that Perl is expecting a filehandle, an indirect filehandle may be used instead. An indirect filehandle is just a scalar variable that contains a filehandle. Functions like &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt;, or the &lt;code&gt;&amp;lt;FH&amp;gt;&lt;/code&gt; diamond operator will accept either a named filehandle or a scalar variable containing one:</source>
          <target state="translated">그런 다음 일반적인 파일 핸들처럼 사용하십시오. Perl이 파일 핸들을 기대하는 곳이면 간접 파일 핸들을 대신 사용할 수 있습니다. 간접 파일 핸들은 파일 핸들을 포함하는 스칼라 변수 일뿐입니다. &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&amp;lt;FH&amp;gt;&lt;/code&gt; 다이아몬드 연산자 와 같은 함수 는 명명 된 filehandle 또는 하나를 포함하는 스칼라 변수를 허용합니다.</target>
        </trans-unit>
        <trans-unit id="1cf2cb2bbe0265bf12a87e03d2ba1a967297063a" translate="yes" xml:space="preserve">
          <source>Then use any of those as you would a normal filehandle. Anywhere that Perl is expecting a filehandle, an indirect filehandle may be used instead. An indirect filehandle is just a scalar variable that contains a filehandle. Functions like &lt;code&gt;print&lt;/code&gt;, &lt;code&gt;open&lt;/code&gt;, &lt;code&gt;seek&lt;/code&gt;, or the &lt;code&gt;&amp;lt;FH&amp;gt;&lt;/code&gt; diamond operator will accept either a named filehandle or a scalar variable containing one:</source>
          <target state="translated">그런 다음 일반 파일 핸들처럼 사용하십시오. Perl이 파일 핸들을 예상하는 모든 곳에서 간접 파일 핸들을 대신 사용할 수 있습니다. 간접 파일 핸들은 파일 핸들을 포함하는 스칼라 변수입니다. &lt;code&gt;print&lt;/code&gt; , &lt;code&gt;open&lt;/code&gt; , &lt;code&gt;seek&lt;/code&gt; 또는 &lt;code&gt;&amp;lt;FH&amp;gt;&lt;/code&gt; 다이아몬드 연산자 와 같은 함수 는 명명 된 파일 핸들 또는 다음을 포함하는 스칼라 변수를 허용합니다.</target>
        </trans-unit>
        <trans-unit id="be01a69ef7dc497f6d53fec0422df0742cb41c46" translate="yes" xml:space="preserve">
          <source>Then use it like:</source>
          <target state="translated">그런 다음 다음과 같이 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="ac583abd9dd0b62af4de435d7d5497c2d6ffcb6a" translate="yes" xml:space="preserve">
          <source>Then we have to give each character a unique ID so your computer can tell the difference between 'a' and 'A'. This itemized character repertoire is now a</source>
          <target state="translated">그런 다음 컴퓨터가 'a'와 'A'의 차이를 구분할 수 있도록 각 문자에 고유 한 ID를 부여해야합니다. ㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ 이 항목 별 캐릭터 레퍼토리는 이제</target>
        </trans-unit>
        <trans-unit id="3068081feb5a0d3d89b7875b7ddf972f866ffeca" translate="yes" xml:space="preserve">
          <source>Then when you call $lh-&amp;gt;maketext(</source>
          <target state="translated">그런 다음 $ lh-&amp;gt; maketext (</target>
        </trans-unit>
        <trans-unit id="ef2df7391bceda4d0a67009f959c0d587bbf6bd2" translate="yes" xml:space="preserve">
          <source>Then you can merge it into master like this:</source>
          <target state="translated">그런 다음 다음과 같이 마스터로 병합 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4174f8d83f029a8fa078cc1b0e4b602d5427b4d7" translate="yes" xml:space="preserve">
          <source>Then you can progress through any remaining notable Unicode characters in the range 0x2000-0x204D (consult the character tables at www.unicode.org), and whatever else strikes your fancy. For example, in</source>
          <target state="translated">그런 다음 0x2000-0x204D 범위 (www.unicode.org의 문자 표 참조)에 남아있는 주목할만한 유니 코드 문자를 진행할 수 있으며, 그 밖의 모든 것이 당신의 마음에들 것입니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="84a1243ca0e6b4d4a37040b980b310d461ab4076" translate="yes" xml:space="preserve">
          <source>Then you can use &lt;code&gt;FH&lt;/code&gt; as the filehandle, in &lt;code&gt;&lt;a href=&quot;close&quot;&gt;close&lt;/a&gt; FH&lt;/code&gt; and &lt;code&gt;&amp;lt;FH&amp;gt;&lt;/code&gt; and so on. Note that it's a global variable, so this form is not recommended in new code.</source>
          <target state="translated">그럼 당신은 사용할 수 &lt;code&gt;FH&lt;/code&gt; 을 에, 파일 핸들로 &lt;code&gt;&lt;a href=&quot;close&quot;&gt;close&lt;/a&gt; FH&lt;/code&gt; 와 &lt;code&gt;&amp;lt;FH&amp;gt;&lt;/code&gt; 등등합니다. 전역 변수이므로 새 코드에서는이 양식을 사용하지 않는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="c81a39d78bb4e09ef8b273b017dac3466493479a" translate="yes" xml:space="preserve">
          <source>Then you can use &lt;code&gt;FH&lt;/code&gt; as the filehandle, in &lt;code&gt;&lt;a href=&quot;functions/close&quot;&gt;close&lt;/a&gt; FH&lt;/code&gt; and &lt;code&gt;&amp;lt;FH&amp;gt;&lt;/code&gt; and so on. Note that it's a global variable, so this form is not recommended in new code.</source>
          <target state="translated">그럼 당신은 사용할 수 &lt;code&gt;FH&lt;/code&gt; 을 에, 파일 핸들로 &lt;code&gt;&lt;a href=&quot;functions/close&quot;&gt;close&lt;/a&gt; FH&lt;/code&gt; 와 &lt;code&gt;&amp;lt;FH&amp;gt;&lt;/code&gt; 등등합니다. 전역 변수이므로 새 코드에서는이 양식을 사용하지 않는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="8845af43a427cd30379b447f56ac8ef63aa6a453" translate="yes" xml:space="preserve">
          <source>Then you can use &lt;code&gt;FH&lt;/code&gt; as the filehandle, in &lt;code&gt;close FH&lt;/code&gt; and &lt;code&gt;&amp;lt;FH&amp;gt;&lt;/code&gt; and so on. Note that it's a global variable, so this form is not recommended when dealing with filehandles other than Perl's built-in ones (e.g. STDOUT and STDIN).</source>
          <target state="translated">그런 다음 &lt;code&gt;FH&lt;/code&gt; 를 &lt;code&gt;close FH&lt;/code&gt; 및 &lt;code&gt;&amp;lt;FH&amp;gt;&lt;/code&gt; 등에서 파일 핸들로 사용할 수 있습니다 . 전역 변수이므로 Perl의 내장 파일 핸들 (예 : STDOUT 및 STDIN) 이외의 파일 핸들을 다룰 때는이 형식을 권장하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="aceabb34e67cf540951bd4247eacd0dbbabee283" translate="yes" xml:space="preserve">
          <source>Then you'll need to know how to manipulate the Perl stack. That's described in &lt;a href=&quot;perlcall&quot;&gt;perlcall&lt;/a&gt;.</source>
          <target state="translated">그런 다음 Perl 스택을 조작하는 방법을 알아야합니다. 이것은 &lt;a href=&quot;perlcall&quot;&gt;perlcall에&lt;/a&gt; 설명되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a9e623e714cffb21ba3a72f8e67c6ce57fe9270e" translate="yes" xml:space="preserve">
          <source>Then you'll need to pass the &lt;code&gt;nocase&lt;/code&gt; option in order to recognize &quot;Name&quot;:</source>
          <target state="translated">그런 다음 &quot;이름&quot;을 인식하려면 &lt;code&gt;nocase&lt;/code&gt; 옵션 을 전달해야합니다 .</target>
        </trans-unit>
        <trans-unit id="5eea4f63f47d5b222c66289e4dec5701bc66810a" translate="yes" xml:space="preserve">
          <source>Then you've just supplied an automatic &lt;code&gt;&lt;a href=&quot;functions/scalar&quot;&gt;scalar&lt;/a&gt;&lt;/code&gt; in front of their argument, which can be more than a bit surprising. The old &lt;code&gt;@foo&lt;/code&gt; which used to hold one thing doesn't get passed in. Instead, &lt;code&gt;func()&lt;/code&gt; now gets passed in a &lt;code&gt;1&lt;/code&gt; ; that is, the number of elements in &lt;code&gt;@foo&lt;/code&gt; . And the &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; gets called in scalar context so it starts scribbling on your &lt;code&gt;@_&lt;/code&gt; parameter list. Ouch!</source>
          <target state="translated">그런 다음 인수 앞에 자동 &lt;code&gt;&lt;a href=&quot;functions/scalar&quot;&gt;scalar&lt;/a&gt;&lt;/code&gt; 를 제공했습니다 . 하나의 것을 유지하는 데 사용 되었던 오래된 &lt;code&gt;@foo&lt;/code&gt; 는 전달되지 않습니다. 대신 &lt;code&gt;func()&lt;/code&gt; 이제 &lt;code&gt;1&lt;/code&gt; 로 전달됩니다 . 즉, &lt;code&gt;@foo&lt;/code&gt; 의 요소 수입니다 . 그리고 &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; 은 스칼라 컨텍스트에서 호출되므로 &lt;code&gt;@_&lt;/code&gt; 매개 변수 목록 에서 낙서가 시작됩니다 . 아야!</target>
        </trans-unit>
        <trans-unit id="b0ba92bfa9d677231987d2b57b0a01cd1852383d" translate="yes" xml:space="preserve">
          <source>Then you've just supplied an automatic &lt;code&gt;scalar&lt;/code&gt; in front of their argument, which can be more than a bit surprising. The old &lt;code&gt;@foo&lt;/code&gt; which used to hold one thing doesn't get passed in. Instead, &lt;code&gt;func()&lt;/code&gt; now gets passed in a &lt;code&gt;1&lt;/code&gt;; that is, the number of elements in &lt;code&gt;@foo&lt;/code&gt;. And the &lt;code&gt;m//g&lt;/code&gt; gets called in scalar context so instead of a list of words it returns a boolean result and advances &lt;code&gt;pos($text)&lt;/code&gt;. Ouch!</source>
          <target state="translated">그런 다음 인수 앞에 자동 &lt;code&gt;scalar&lt;/code&gt; 를 제공했습니다 . 이는 다소 놀라운 일이 아닙니다. 한 가지를 &lt;code&gt;@foo&lt;/code&gt; 예전 @foo 는 전달되지 않습니다. 대신 &lt;code&gt;func()&lt;/code&gt; 이제 &lt;code&gt;1&lt;/code&gt; 로 전달됩니다 . 즉, &lt;code&gt;@foo&lt;/code&gt; 의 요소 수입니다 . 그리고 &lt;code&gt;m//g&lt;/code&gt; 는 스칼라 컨텍스트에서 호출되므로 단어 목록 대신 부울 결과를 반환하고 &lt;code&gt;pos($text)&lt;/code&gt; 앞으로 나아 갑니다 . 아야!</target>
        </trans-unit>
        <trans-unit id="1d2223d4e367bda9f7a187be5ce1bdedd21df546" translate="yes" xml:space="preserve">
          <source>Then your Russian translator calls on the phone, to</source>
          <target state="translated">그런 다음 러시아어 번역가가 전화를 걸어</target>
        </trans-unit>
        <trans-unit id="ee85b5d75e24b7f6cf7782bfc085bcfc0c87d6f5" translate="yes" xml:space="preserve">
          <source>Then, it determines the class and method name of the context it was invoked from.</source>
          <target state="translated">그런 다음 호출 된 컨텍스트의 클래스 및 메소드 이름을 판별합니다.</target>
        </trans-unit>
        <trans-unit id="6c23388be94a600da1203bed601e75b409a6b29f" translate="yes" xml:space="preserve">
          <source>Then, push your new branch to your fork.</source>
          <target state="translated">그런 다음 새 분기를 포크로 푸시하십시오.</target>
        </trans-unit>
        <trans-unit id="c5bc01ce529788e374ab9bf2dcdef9e77b7d91a8" translate="yes" xml:space="preserve">
          <source>There (probably) should be a semicolon at the end of the opening token</source>
          <target state="translated">(아마) 여는 토큰 끝에 세미콜론이 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="4d80e1f2d5ca1daef620a79f94100cd3a43dcad2" translate="yes" xml:space="preserve">
          <source>There appears to be a bug in the floating point implementation on BS2000 POSIX systems such that calling int() on the product of a number and a small magnitude number is not the same as calling int() on the quotient of that number and a large magnitude number. For example, in the following Perl code:</source>
          <target state="translated">BS2000 POSIX 시스템에서 부동 소수점 구현에 버그가있는 것 같습니다. 숫자와 소수의 곱에서 int ()를 호출하는 것이 해당 숫자의 몫에서 int ()를 호출하는 것과 같지 않습니다. 크기 숫자. 예를 들어, 다음 Perl 코드에서 :</target>
        </trans-unit>
        <trans-unit id="bb6e61aa6502fa98f73e845b088e443cab1a90e3" translate="yes" xml:space="preserve">
          <source>There appears to be a bug in the floating point implementation on S/390 systems such that calling int() on the product of a number and a small magnitude number is not the same as calling int() on the quotient of that number and a large magnitude number. For example, in the following Perl code:</source>
          <target state="translated">S / 390 시스템에서 부동 소수점 구현에 버그가있는 것 같습니다. 예를 들어 숫자와 소수의 곱에서 int ()를 호출하는 것은 해당 숫자의 몫에서 int ()를 호출하는 것과 같지 않습니다. 큰 숫자입니다. 예를 들어, 다음 Perl 코드에서 :</target>
        </trans-unit>
        <trans-unit id="4eb2187ac5dc9a4b6af234beb08ab0fae2350bcf" translate="yes" xml:space="preserve">
          <source>There are 2 types of hooks, init hooks, and release hooks. As the names suggest, these hooks are triggered when contexts are created or released.</source>
          <target state="translated">후크에는 두 가지 유형, 초기화 후크 및 릴리스 후크가 있습니다. 이름에서 알 수 있듯이 이러한 후크는 컨텍스트가 생성되거나 해제 될 때 트리거됩니다.</target>
        </trans-unit>
        <trans-unit id="de1cfe28fcf075678633050ad3a49243fab1a122" translate="yes" xml:space="preserve">
          <source>There are 3 kinds of items that may be populated; special patterns, #vars, and literal text, which is copied verbatim. (Yes, it's a set of s///g steps.)</source>
          <target state="translated">채워질 수있는 항목에는 3 가지가 있습니다. 특수 패턴, #var 및 리터럴 텍스트가 그대로 복사됩니다. (예, 일련의 s /// g 단계입니다.)</target>
        </trans-unit>
        <trans-unit id="6e9231df83ad3f347c0bf53efa7fd0781ae7adef" translate="yes" xml:space="preserve">
          <source>There are &lt;code&gt;lint&lt;/code&gt; and &amp;lt;splint&amp;gt; targets in Makefile, but you may have to diddle with the flags (see above).</source>
          <target state="translated">있습니다 &lt;code&gt;lint&lt;/code&gt; 및 &amp;lt;부목&amp;gt; 목표는 메이크에,하지만 당신은 플래그 (위 참조) 속이다 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fe9ce8188c03cc1c80382377cc03bbf3d1eefe6b" translate="yes" xml:space="preserve">
          <source>There are DECC feature logical names AND ODS-5 volume attributes that also control what values are returned for the date fields.</source>
          <target state="translated">날짜 필드에 리턴되는 값을 제어하는 ​​DECC 기능 논리 이름 및 ODS-5 볼륨 속성이 있습니다.</target>
        </trans-unit>
        <trans-unit id="153a01ed3dca851e07404e7b116e0f624fedd9d4" translate="yes" xml:space="preserve">
          <source>There are a couple of exceptions to the above rule. &lt;code&gt;\N{U+&lt;i&gt;hex number&lt;/i&gt;}&lt;/code&gt; is always interpreted as a Unicode code point, so that &lt;code&gt;\N{U+0050}&lt;/code&gt; is &lt;code&gt;&quot;P&quot;&lt;/code&gt; even on EBCDIC platforms. And if &lt;code&gt;&lt;a href=&quot;encoding&quot;&gt;use encoding&lt;/a&gt;&lt;/code&gt; is in effect, the number is considered to be in that encoding, and is translated from that into the platform's native encoding if there is a corresponding native character; otherwise to Unicode.</source>
          <target state="translated">위의 규칙에는 몇 가지 예외가 있습니다. &lt;code&gt;\N{U+&lt;i&gt;hex number&lt;/i&gt;}&lt;/code&gt; 는 항상 유니 코드 코드 포인트로 해석되므로 EBCDIC 플랫폼에서도 &lt;code&gt;\N{U+0050}&lt;/code&gt; 은 &lt;code&gt;&quot;P&quot;&lt;/code&gt; 입니다. 그리고 &lt;code&gt;&lt;a href=&quot;encoding&quot;&gt;use encoding&lt;/a&gt;&lt;/code&gt; 이 유효한 경우 숫자는 해당 인코딩에있는 것으로 간주되며 해당 기본 문자가있는 경우 숫자를 플랫폼의 기본 인코딩으로 변환합니다. 그렇지 않으면 유니 코드로.</target>
        </trans-unit>
        <trans-unit id="4e415da7b1ad793f82f6c66993b6dabfb03be0ae" translate="yes" xml:space="preserve">
          <source>There are a couple of macros to do very basic exception handling in XS modules. You have to define &lt;code&gt;NO_XSLOCKS&lt;/code&gt; before including</source>
          <target state="translated">XS 모듈에서 매우 기본적인 예외 처리를 수행하는 몇 가지 매크로가 있습니다. 포함하기 전에 &lt;code&gt;NO_XSLOCKS&lt;/code&gt; 를 정의해야합니다</target>
        </trans-unit>
        <trans-unit id="b559285d4827f1039158fa6a1c7be09bcea8695c" translate="yes" xml:space="preserve">
          <source>There are a couple of other symbols that you're likely to encounter that aren't really type specifiers:</source>
          <target state="translated">실제로 유형 지정자가 아닌 몇 가지 다른 기호가 있습니다.</target>
        </trans-unit>
        <trans-unit id="cd28f27e3e26acb88f426d59ef73cb49b8748e10" translate="yes" xml:space="preserve">
          <source>There are a couple of special arrays too, such as &lt;code&gt;@ARGV&lt;/code&gt; (the command line arguments to your script) and &lt;code&gt;@_&lt;/code&gt; (the arguments passed to a subroutine). These are documented in &lt;a href=&quot;perlvar&quot;&gt;perlvar&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;@ARGV&lt;/code&gt; (스크립트에 대한 명령 행 인수) 및 &lt;code&gt;@_&lt;/code&gt; (서브 루틴에 전달 된 인수 )와 같은 특수 배열도 있습니다. 이것들은 &lt;a href=&quot;perlvar&quot;&gt;perlvar&lt;/a&gt; 에 문서화되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="d71c568688cddeb0974cf4c64aacf00c4a7ae0fc" translate="yes" xml:space="preserve">
          <source>There are a couple of things to note about this analysis. First, the third alternative in the second group 'de' also allows a match, but we stopped before we got to it - at a given character position, leftmost wins. Second, we were able to get a match at the first character position of the string 'a'. If there were no matches at the first position, Perl would move to the second character position 'b' and attempt the match all over again. Only when all possible paths at all possible character positions have been exhausted does Perl give up and declare &lt;code&gt;$string =~ /(abd|abc)(df|d|de)/;&lt;/code&gt; to be false.</source>
          <target state="translated">이 분석에 대해 유의해야 할 사항이 몇 가지 있습니다. 첫째, 두 번째 그룹 'de'의 세 번째 대안도 일치를 허용하지만 주어진 문자 위치에서 가장 왼쪽에있는 승리를 얻었습니다. 둘째, 문자열 'a'의 첫 번째 문자 위치에서 일치시킬 수있었습니다. 첫 번째 위치에 일치하는 항목이 없으면 Perl은 두 번째 문자 위치 'b'로 이동하여 다시 일치를 시도합니다. 가능한 모든 문자 위치에서 가능한 모든 경로가 소진 된 경우에만 Perl은 &lt;code&gt;$string =~ /(abd|abc)(df|d|de)/;&lt;/code&gt; 포기하고 선언 합니다. 거짓이다.</target>
        </trans-unit>
        <trans-unit id="deb5e7398add69ec1651990d98a23a3300e8eb2d" translate="yes" xml:space="preserve">
          <source>There are a couple of things to note about this analysis. First, the third alternative in the second group &lt;code&gt;'de'&lt;/code&gt; also allows a match, but we stopped before we got to it - at a given character position, leftmost wins. Second, we were able to get a match at the first character position of the string &lt;code&gt;'a'&lt;/code&gt;. If there were no matches at the first position, Perl would move to the second character position &lt;code&gt;'b'&lt;/code&gt; and attempt the match all over again. Only when all possible paths at all possible character positions have been exhausted does Perl give up and declare &lt;code&gt;$string =~ /(abd|abc)(df|d|de)/;&lt;/code&gt; to be false.</source>
          <target state="translated">이 분석에 대해 몇 가지 유의해야 할 사항이 있습니다. 첫째, 두 번째 그룹 &lt;code&gt;'de'&lt;/code&gt; 의 세 번째 대안 도 경기를 허용하지만, 우리가 도달하기 전에 멈췄습니다. 주어진 캐릭터 위치에서 가장 왼쪽이 이깁니다. 둘째, 문자열 &lt;code&gt;'a'&lt;/code&gt; 의 첫 번째 문자 위치에서 일치 항목을 얻을 수있었습니다 . 첫 번째 위치에 일치하는 항목이 없으면 Perl은 두 번째 문자 위치 &lt;code&gt;'b'&lt;/code&gt; 로 이동하여 다시 일치를 시도합니다. 가능한 모든 문자 위치에서 가능한 모든 경로가 소진되었을 때만 Perl은 포기하고 &lt;code&gt;$string =~ /(abd|abc)(df|d|de)/;&lt;/code&gt; 거짓입니다.</target>
        </trans-unit>
        <trans-unit id="39aecaa3926975713f4a2a65afbfb40347095ccc" translate="yes" xml:space="preserve">
          <source>There are a couple of ways that you can process an entire hash. You can get a list of keys, then go through each key, or grab a one key-value pair at a time.</source>
          <target state="translated">전체 해시를 처리 할 수있는 몇 가지 방법이 있습니다. 키 목록을 얻은 다음 각 키를 살펴 보거나 한 번에 하나의 키-값 쌍을 가져올 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="af13ea056584d18f28105e6dfb4305dd6e1f93f8" translate="yes" xml:space="preserve">
          <source>There are a few basic principles which define object oriented Perl:</source>
          <target state="translated">객체 지향 Perl을 정의하는 몇 가지 기본 원칙이 있습니다.</target>
        </trans-unit>
        <trans-unit id="6ad0df8b5bb1240ec34f94939aa27ca4c87aa9d3" translate="yes" xml:space="preserve">
          <source>There are a few exceptions though: &lt;code&gt;x&lt;/code&gt; can be either string repetition or list repetition, depending on the type of the left operand, and &lt;code&gt;&amp;amp;&lt;/code&gt; , &lt;code&gt;|&lt;/code&gt;, &lt;code&gt;^&lt;/code&gt; and &lt;code&gt;~&lt;/code&gt; can be either string or numeric bit operations.</source>
          <target state="translated">그러나 몇 가지 예외 가 있습니다 . &lt;code&gt;x&lt;/code&gt; 는 왼쪽 피연산자의 유형에 따라 문자열 반복 또는 목록 반복 일 수 있으며 &lt;code&gt;&amp;amp;&lt;/code&gt; , &lt;code&gt;|&lt;/code&gt; , &lt;code&gt;^&lt;/code&gt; 및 &lt;code&gt;~&lt;/code&gt; 는 문자열 또는 숫자 비트 연산 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="90c71cfbe20f7e4576d0df45674b3d041e6521fa" translate="yes" xml:space="preserve">
          <source>There are a few exceptions though: &lt;code&gt;x&lt;/code&gt; can be either string repetition or list repetition, depending on the type of the left operand, and &lt;code&gt;&amp;amp;&lt;/code&gt;, &lt;code&gt;|&lt;/code&gt;, &lt;code&gt;^&lt;/code&gt; and &lt;code&gt;~&lt;/code&gt; can be either string or numeric bit operations.</source>
          <target state="translated">하지만 몇 가지 예외 가 있습니다 . &lt;code&gt;x&lt;/code&gt; 는 왼쪽 피연산자의 유형에 따라 문자열 반복 또는 목록 반복 일 수 있으며 &lt;code&gt;&amp;amp;&lt;/code&gt; , &lt;code&gt;|&lt;/code&gt; , &lt;code&gt;^&lt;/code&gt; 및 &lt;code&gt;~&lt;/code&gt; 는 문자열 또는 숫자 비트 연산 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5a7bb479453f1e1c0fcfea035067e079420f6246" translate="yes" xml:space="preserve">
          <source>There are a few more things you might want to know about matching operators. The global modifier &lt;code&gt;//g&lt;/code&gt; allows the matching operator to match within a string as many times as possible. In scalar context, successive matches against a string will have &lt;code&gt;//g&lt;/code&gt; jump from match to match, keeping track of position in the string as it goes along. You can get or set the position with the &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos()&lt;/a&gt;&lt;/code&gt; function. For example,</source>
          <target state="translated">일치 연산자에 대해 알아야 할 사항이 몇 가지 더 있습니다. 전역 수정 자 &lt;code&gt;//g&lt;/code&gt; 를 사용하면 일치 연산자가 문자열 내에서 가능한 한 많이 일치 할 수 있습니다. 스칼라 문맥에서 문자열에 대한 연속 일치는 일치에서 문자열로 &lt;code&gt;//g&lt;/code&gt; 점프하여 문자열의 위치를 ​​추적합니다. &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos()&lt;/a&gt;&lt;/code&gt; 함수로 위치를 얻거나 설정할 수 있습니다 . 예를 들어</target>
        </trans-unit>
        <trans-unit id="21076df5229fe033ea741a2399501b4983daa45a" translate="yes" xml:space="preserve">
          <source>There are a few more things you might want to know about matching operators. The global modifier &lt;code&gt;/g&lt;/code&gt; allows the matching operator to match within a string as many times as possible. In scalar context, successive matches against a string will have &lt;code&gt;/g&lt;/code&gt; jump from match to match, keeping track of position in the string as it goes along. You can get or set the position with the &lt;code&gt;pos()&lt;/code&gt; function. For example,</source>
          <target state="translated">일치 연산자에 대해 알고 싶은 몇 가지 사항이 더 있습니다. 전역 수정 자 &lt;code&gt;/g&lt;/code&gt; 를 사용하면 일치 연산자가 문자열 내에서 가능한 한 여러 번 일치시킬 수 있습니다. 스칼라 컨텍스트에서 문자열에 대한 연속적인 일치 는 일치하는 항목간에 &lt;code&gt;/g&lt;/code&gt; 이동하여 문자열의 위치를 ​​추적합니다. &lt;code&gt;pos()&lt;/code&gt; 함수로 위치를 얻거나 설정할 수 있습니다 . 예를 들면</target>
        </trans-unit>
        <trans-unit id="4300a240e517c8a51298a8d027c6fc76723dcec0" translate="yes" xml:space="preserve">
          <source>There are a few point to bear in mind if you want to change the ordering in a BTREE database:</source>
          <target state="translated">BTREE 데이터베이스에서 순서를 변경하려면 몇 가지 유의해야 할 사항이 있습니다.</target>
        </trans-unit>
        <trans-unit id="7b1086e8333561d2682eac30f860ad2422dfc42d" translate="yes" xml:space="preserve">
          <source>There are a few things to bear in mind when creating your own &lt;code&gt;ResultFactory&lt;/code&gt; :</source>
          <target state="translated">자신 만의 &lt;code&gt;ResultFactory&lt;/code&gt; 를 생성 할 때 명심해야 할 것이 몇 가지 있습니다 .</target>
        </trans-unit>
        <trans-unit id="de8a54b9295025b3c139573926386493cb554215" translate="yes" xml:space="preserve">
          <source>There are a few things to bear in mind when creating your own &lt;code&gt;ResultFactory&lt;/code&gt;:</source>
          <target state="translated">자신의 &lt;code&gt;ResultFactory&lt;/code&gt; 를 만들 때 염두에 두어야 할 몇 가지 사항이 있습니다 .</target>
        </trans-unit>
        <trans-unit id="378f2e66966b2788636abfdbe2bc87b5abb48ea4" translate="yes" xml:space="preserve">
          <source>There are a few things you need to know, however:</source>
          <target state="translated">그러나 몇 가지 알아야 할 사항이 있습니다.</target>
        </trans-unit>
        <trans-unit id="52b3f437a68cd4b70bf1c33277b0b324dc172b8a" translate="yes" xml:space="preserve">
          <source>There are a handful of cases where a tool author may want to create a new context by hand, which is why the &lt;code&gt;new&lt;/code&gt; method exists. Unless you really know what you are doing you should avoid this.</source>
          <target state="translated">도구 작성자가 손으로 새 컨텍스트를 작성하려는 경우가 몇 가지 있는데, 이것이 &lt;code&gt;new&lt;/code&gt; 방법이 존재하는 이유 입니다. 당신이 무엇을하고 있는지 정말로 알지 못한다면 이것을 피해야합니다.</target>
        </trans-unit>
        <trans-unit id="291c6f1e95cd386fbf1435fa808c577724438440" translate="yes" xml:space="preserve">
          <source>There are a lot of modules on CPAN, and it's easy to miss one that's similar to what you're planning on contributing. Have a good plough through &lt;a href=&quot;http://metacpan.org&quot;&gt;http://metacpan.org&lt;/a&gt; and make sure you're not the one reinventing the wheel!</source>
          <target state="translated">CPAN에는 많은 모듈이 있으며 기여할 계획과 유사한 모듈을 놓치기 쉽습니다. &lt;a href=&quot;http://metacpan.org&quot;&gt;http://metacpan.org를&lt;/a&gt; 통해 좋은 쟁기를 가지고 바퀴를 재창조하는 사람이 아닌지 확인하십시오!</target>
        </trans-unit>
        <trans-unit id="9cbfb29c30b87800b111898e71e11f4933f270fc" translate="yes" xml:space="preserve">
          <source>There are a lot of modules on CPAN, and it's easy to miss one that's similar to what you're planning on contributing. Have a good plough through the &lt;a href=&quot;http://search.cpan.org&quot;&gt;http://search.cpan.org&lt;/a&gt; and make sure you're not the one reinventing the wheel!</source>
          <target state="translated">CPAN에는 많은 모듈이 있으며, 기고하려는 것과 유사한 모듈을 놓치기 쉽습니다. &lt;a href=&quot;http://search.cpan.org&quot;&gt;http://search.cpan.org를&lt;/a&gt; 통해 쟁기질을 하고 바퀴를 재발견하는 사람이 아닌지 확인하십시오!</target>
        </trans-unit>
        <trans-unit id="8202fc94e9abdf77b0bbe8e0da596aca565bfbf9" translate="yes" xml:space="preserve">
          <source>There are a number of &quot;magic&quot; scalars with names that look like punctuation or line noise. These special variables are used for all kinds of purposes, and are documented in &lt;a href=&quot;perlvar&quot;&gt;perlvar&lt;/a&gt;. The only one you need to know about for now is &lt;code&gt;$_&lt;/code&gt; which is the &quot;default variable&quot;. It's used as the default argument to a number of functions in Perl, and it's set implicitly by certain looping constructs.</source>
          <target state="translated">문장 부호 나 라인 노이즈처럼 보이는 이름을 가진 많은 &quot;마법의&quot;스칼라가 있습니다. 이 특수 변수는 모든 종류의 목적으로 사용되며 &lt;a href=&quot;perlvar&quot;&gt;perlvar에&lt;/a&gt; 문서화되어 있습니다. 당신이 지금 알아야 할 유일한 것은 &quot;기본 변수&quot;인 &lt;code&gt;$_&lt;/code&gt; 입니다. Perl의 여러 함수에 대한 기본 인수로 사용되며 특정 루핑 구문에 의해 암시 적으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="bbba855a854345636dbf0d940dc495c0ac9b2bb4" translate="yes" xml:space="preserve">
          <source>There are a number of Unicode characters that match a sequence of multiple characters under &lt;code&gt;/i&lt;/code&gt;. For example, &lt;code&gt;LATIN SMALL LIGATURE FI&lt;/code&gt; should match the sequence &lt;code&gt;fi&lt;/code&gt;. Perl is not currently able to do this when the multiple characters are in the pattern and are split between groupings, or when one or more are quantified. Thus</source>
          <target state="translated">&lt;code&gt;/i&lt;/code&gt; 아래의 여러 문자 시퀀스와 일치하는 유니 코드 문자가 많이 있습니다. 예를 들어, &lt;code&gt;LATIN SMALL LIGATURE FI&lt;/code&gt; 는 시퀀스 &lt;code&gt;fi&lt;/code&gt; 와 일치해야합니다 . Perl은 현재 여러 문자가 패턴에 있고 그룹간에 분할되거나 하나 이상의 문자가 수량화 될 때이 작업을 수행 할 수 없습니다. 그러므로</target>
        </trans-unit>
        <trans-unit id="6fc3a0395d03ea21a961b5ccde55199ca19344c6" translate="yes" xml:space="preserve">
          <source>There are a number of Unicode characters that match multiple characters under &lt;code&gt;/i&lt;/code&gt;. For example, &lt;code&gt;LATIN SMALL LIGATURE FI&lt;/code&gt; should match the sequence &lt;code&gt;fi&lt;/code&gt; . Perl is not currently able to do this when the multiple characters are in the pattern and are split between groupings, or when one or more are quantified. Thus</source>
          <target state="translated">&lt;code&gt;/i&lt;/code&gt; 아래 여러 문자와 일치하는 여러 유니 코드 문자가 있습니다. 예를 들어, &lt;code&gt;LATIN SMALL LIGATURE FI&lt;/code&gt; 는 시퀀스 &lt;code&gt;fi&lt;/code&gt; 와 일치해야합니다 . Perl은 여러 문자가 패턴에 있고 그룹화로 분할되거나 하나 이상의 수량화 될 때 현재이를 수행 할 수 없습니다. 그러므로</target>
        </trans-unit>
        <trans-unit id="3dd2d0257d19015791fc17037d18a20e756ba477" translate="yes" xml:space="preserve">
          <source>There are a number of escape sequences and character classes that we haven't covered yet.</source>
          <target state="translated">아직 다루지 않은 많은 이스케이프 시퀀스와 문자 클래스가 있습니다.</target>
        </trans-unit>
        <trans-unit id="58e8ff088e1d138c7e62589f4caba0154e035619" translate="yes" xml:space="preserve">
          <source>There are a number of flags that can be found at the end of regular expression constructs that are</source>
          <target state="translated">정규 표현식 구조의 끝에서 찾을 수있는 많은 플래그가 있습니다.</target>
        </trans-unit>
        <trans-unit id="9c8583e91f1bbf24b33308cfc971070d355cbca1" translate="yes" xml:space="preserve">
          <source>There are a number of issues with regard to case-insensitive matching in Unicode rules. See &lt;code&gt;&quot;i&quot;&lt;/code&gt; under &lt;a href=&quot;#Modifiers&quot;&gt;&quot;Modifiers&quot;&lt;/a&gt; above.</source>
          <target state="translated">유니 코드 규칙에서 대소 문자를 구분하지 않는 일치와 관련하여 많은 문제가 있습니다. 위의 &lt;a href=&quot;#Modifiers&quot;&gt;&quot;수정 자&quot;&lt;/a&gt; 에서 &lt;code&gt;&quot;i&quot;&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="9135b7f56d303db71c9d18be0e91860f32c7ff91" translate="yes" xml:space="preserve">
          <source>There are a number of issues with regard to case-insensitive matching in Unicode rules. See &lt;code&gt;i&lt;/code&gt; under &lt;a href=&quot;#Modifiers&quot;&gt;Modifiers&lt;/a&gt; above.</source>
          <target state="translated">유니 코드 규칙에서 대소 문자를 구분하지 않는 일치와 관련하여 여러 가지 문제가 있습니다. 위 &lt;a href=&quot;#Modifiers&quot;&gt;수정 자&lt;/a&gt; 아래의 &lt;code&gt;i&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="022096dd663fb452b1d41c016ae62776dae4f673" translate="yes" xml:space="preserve">
          <source>There are a number of limits on the size of the data that you can store in the NDBM file. The most important is that the length of a key, plus the length of its associated value, may not exceed 1008 bytes.</source>
          <target state="translated">NDBM 파일에 저장할 수있는 데이터 크기에는 여러 가지 제한이 있습니다. 가장 중요한 것은 키 길이와 관련 값의 길이에 1008 바이트를 초과 할 수 없다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="98194cdd08210646c306ab64213d7decc3e2f871" translate="yes" xml:space="preserve">
          <source>There are a number of limits on the size of the data that you can store in the ODBM file. The most important is that the length of a key, plus the length of its associated value, may not exceed 1008 bytes.</source>
          <target state="translated">ODBM 파일에 저장할 수있는 데이터 크기에는 여러 제한이 있습니다. 가장 중요한 것은 키의 길이와 관련 값의 길이가 1008 바이트를 초과 할 수 없다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="72d53d5198c98896d8e7795e9a89c4a433023428" translate="yes" xml:space="preserve">
          <source>There are a number of limits on the size of the data that you can store in the SDBM file. The most important is that the length of a key, plus the length of its associated value, may not exceed 1008 bytes.</source>
          <target state="translated">SDBM 파일에 저장할 수있는 데이터 크기에는 여러 가지 제한이 있습니다. 가장 중요한 것은 키 길이와 관련 값의 길이에 1008 바이트를 초과 할 수 없다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="52efe033e2beba5914060b25e959b1d5bcc3adec" translate="yes" xml:space="preserve">
          <source>There are a number of modules which let you write GUIs in Perl. Most GUI toolkits have a perl interface: an incomplete list follows.</source>
          <target state="translated">Perl에서 GUI를 작성할 수있는 많은 모듈이 있습니다. 대부분의 GUI 툴킷에는 perl 인터페이스가 있습니다. 불완전한 목록은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7c6653dd731ed3a59a2ee9aba20887a251e28fb4" translate="yes" xml:space="preserve">
          <source>There are a number of new concepts introduced here, described below:</source>
          <target state="translated">여기에 소개 된 여러 가지 새로운 개념이 있습니다.</target>
        </trans-unit>
        <trans-unit id="5042e54e451264a1c914a632ba72877f3d1fb724" translate="yes" xml:space="preserve">
          <source>There are a number of other limitations with the &lt;code&gt;Merge&lt;/code&gt; option:</source>
          <target state="translated">&lt;code&gt;Merge&lt;/code&gt; 옵션 에는 몇 가지 다른 제한 사항이 있습니다.</target>
        </trans-unit>
        <trans-unit id="7b02972f75c4a57c97baf269f0fc3720b5f2bc53" translate="yes" xml:space="preserve">
          <source>There are a number of reasons that you might prefer &lt;code&gt;Tie::File&lt;/code&gt; . A list is available at &lt;code&gt;&lt;a href=&quot;http://perl.plover.com/TieFile/why-not-DB_File&quot;&gt;http://perl.plover.com/TieFile/why-not-DB_File&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Tie::File&lt;/code&gt; 선호하는 데는 여러 가지 이유가 있습니다 . 목록은 &lt;code&gt;&lt;a href=&quot;http://perl.plover.com/TieFile/why-not-DB_File&quot;&gt;http://perl.plover.com/TieFile/why-not-DB_File&lt;/a&gt;&lt;/code&gt; 에서 사용 가능 합니다.</target>
        </trans-unit>
        <trans-unit id="13eb2afa7bef68b0d1a21f81cf96c931809f02f6" translate="yes" xml:space="preserve">
          <source>There are a number of reasons that you might prefer &lt;code&gt;Tie::File&lt;/code&gt;. A list is available at &lt;code&gt;&lt;a href=&quot;http://perl.plover.com/TieFile/why-not-DB_File&quot;&gt;http://perl.plover.com/TieFile/why-not-DB_File&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Tie::File&lt;/code&gt; 선호하는 데는 여러 가지 이유가 있습니다 . 목록은 &lt;code&gt;&lt;a href=&quot;http://perl.plover.com/TieFile/why-not-DB_File&quot;&gt;http://perl.plover.com/TieFile/why-not-DB_File&lt;/a&gt;&lt;/code&gt; 에서 확인할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fc49fd5fe581b9df69b9289066f92c4c1dfec1b9" translate="yes" xml:space="preserve">
          <source>There are a number of security issues with the full Unicode list of word characters. See &lt;a href=&quot;http://unicode.org/reports/tr36&quot;&gt;http://unicode.org/reports/tr36&lt;/a&gt;.</source>
          <target state="translated">전체 유니 코드 단어 문자 목록에는 여러 가지 보안 문제가 있습니다. &lt;a href=&quot;http://unicode.org/reports/tr36&quot;&gt;http://unicode.org/reports/tr36을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="34fde0bc8e68f7eb8a6a5b8c75bef1c718f91f74" translate="yes" xml:space="preserve">
          <source>There are a number of ways to handle this sort of problem. The best way is to always have all threads acquire locks in the exact same order. If, for example, you lock variables &lt;code&gt;$x&lt;/code&gt; , &lt;code&gt;$y&lt;/code&gt; , and &lt;code&gt;$z&lt;/code&gt; , always lock &lt;code&gt;$x&lt;/code&gt; before &lt;code&gt;$y&lt;/code&gt; , and &lt;code&gt;$y&lt;/code&gt; before &lt;code&gt;$z&lt;/code&gt; . It's also best to hold on to locks for as short a period of time to minimize the risks of deadlock.</source>
          <target state="translated">이런 종류의 문제를 처리하는 방법에는 여러 가지가 있습니다. 가장 좋은 방법은 모든 스레드가 항상 동일한 순서로 잠금을 획득하도록하는 것입니다. 예를 들어, 변수 잠금 경우 &lt;code&gt;$x&lt;/code&gt; , &lt;code&gt;$y&lt;/code&gt; , 및 &lt;code&gt;$z&lt;/code&gt; 항상 잠금 &lt;code&gt;$x&lt;/code&gt; 전에 &lt;code&gt;$y&lt;/code&gt; , 및 &lt;code&gt;$y&lt;/code&gt; 하기 전에 &lt;code&gt;$z&lt;/code&gt; . 교착 상태의 위험을 최소화하기 위해 잠깐 동안 잠금을 유지하는 것이 가장 좋습니다.</target>
        </trans-unit>
        <trans-unit id="cb7bd877fbaa099a03520b258b73c60485273da7" translate="yes" xml:space="preserve">
          <source>There are a number of ways to handle this sort of problem. The best way is to always have all threads acquire locks in the exact same order. If, for example, you lock variables &lt;code&gt;$x&lt;/code&gt;, &lt;code&gt;$y&lt;/code&gt;, and &lt;code&gt;$z&lt;/code&gt;, always lock &lt;code&gt;$x&lt;/code&gt; before &lt;code&gt;$y&lt;/code&gt;, and &lt;code&gt;$y&lt;/code&gt; before &lt;code&gt;$z&lt;/code&gt;. It's also best to hold on to locks for as short a period of time to minimize the risks of deadlock.</source>
          <target state="translated">이러한 종류의 문제를 처리하는 방법에는 여러 가지가 있습니다. 가장 좋은 방법은 항상 모든 스레드가 똑같은 순서로 잠금을 획득하도록하는 것입니다. 예를 들어, 변수 잠금 경우 &lt;code&gt;$x&lt;/code&gt; , &lt;code&gt;$y&lt;/code&gt; , 및 &lt;code&gt;$z&lt;/code&gt; 항상 잠금 &lt;code&gt;$x&lt;/code&gt; 전에 &lt;code&gt;$y&lt;/code&gt; , 및 &lt;code&gt;$y&lt;/code&gt; 하기 전에 &lt;code&gt;$z&lt;/code&gt; . 교착 상태의 위험을 최소화하기 위해 잠깐 동안 잠금을 유지하는 것이 가장 좋습니다.</target>
        </trans-unit>
        <trans-unit id="f32c15283e2f4c6b7705b70493695500588d21f8" translate="yes" xml:space="preserve">
          <source>There are a number of ways to hide the source to your Perl programs, with varying levels of &quot;security&quot;.</source>
          <target state="translated">다양한 &quot;보안&quot;수준으로 Perl 프로그램에 소스를 숨기는 방법에는 여러 가지가 있습니다.</target>
        </trans-unit>
        <trans-unit id="47ea19cfdb1d50b8922388e83c50c4e47a818ebc" translate="yes" xml:space="preserve">
          <source>There are a number of ways, with varying efficiency. If you want a count of a certain single character (X) within a string, you can use the &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr///&lt;/a&gt;&lt;/code&gt; function like so:</source>
          <target state="translated">다양한 효율성을 가진 여러 가지 방법이 있습니다. 문자열 내에서 특정 단일 문자 (X)의 개수를 원하면 다음 과 같이 &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr///&lt;/a&gt;&lt;/code&gt; 함수를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b49ba886c3971e0e735660e0bc77176d9460c20e" translate="yes" xml:space="preserve">
          <source>There are a number of ways, with varying efficiency. If you want a count of a certain single character (X) within a string, you can use the &lt;code&gt;tr///&lt;/code&gt; function like so:</source>
          <target state="translated">효율성이 다양한 여러 가지 방법이 있습니다. 문자열 내에서 특정 단일 문자 (X)의 개수를 원하는 경우 다음 과 같이 &lt;code&gt;tr///&lt;/code&gt; 함수를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7bba5f24a6f4653ec9fc5a0573f80d18dac8d06b" translate="yes" xml:space="preserve">
          <source>There are a set of utilities which help you in developing Perl programs, and in particular, extending Perl with C.</source>
          <target state="translated">Perl 프로그램 개발, 특히 Perl을 C로 확장하는 데 도움이되는 유틸리티 세트가 있습니다.</target>
        </trans-unit>
        <trans-unit id="38b993b6e04cfcdc788f4b122babf509e8a292ac" translate="yes" xml:space="preserve">
          <source>There are a significant number of test failures in the CPAN modules shipped with Perl v5.22 and 5.24. These are only in modules not primarily maintained by Perl 5 porters. Some of these are failures in the tests only: they don't realize that it is proper to get different results on EBCDIC platforms. And some of the failures are real bugs. If you compile and do a &lt;code&gt;make test&lt;/code&gt; on Perl, all tests on the &lt;code&gt;/cpan&lt;/code&gt; directory are skipped.</source>
          <target state="translated">Perl v5.22 및 5.24와 함께 제공되는 CPAN 모듈에는 상당한 수의 테스트 실패가 있습니다. 이들은 주로 Perl 5 포터가 관리하지 않는 모듈에만 있습니다. 이들 중 일부는 테스트에서만 실패한 것입니다. 그들은 EBCDIC 플랫폼에서 다른 결과를 얻는 것이 적절하다는 것을 깨닫지 못합니다. 그리고 일부 실패는 실제 버그입니다. 컴파일하고 Perl에서 &lt;code&gt;make test&lt;/code&gt; 를 수행하면 &lt;code&gt;/cpan&lt;/code&gt; 디렉토리 의 모든 테스트를 건너 뜁니다.</target>
        </trans-unit>
        <trans-unit id="6b1252989edb8e8176f3bcfc5773893823daccc4" translate="yes" xml:space="preserve">
          <source>There are a significant number of test failures in the CPAN modules shipped with Perl v5.22. These are only in modules not primarily maintained by Perl 5 porters. Some of these are failures in the tests only: they don't realize that it is proper to get different results on EBCDIC platforms. And some of the failures are real bugs. If you compile and do a &lt;code&gt;make test&lt;/code&gt; on Perl, all tests on the &lt;code&gt;/cpan&lt;/code&gt; directory are skipped.</source>
          <target state="translated">Perl v5.22와 함께 제공되는 CPAN 모듈에는 많은 테스트 실패가 있습니다. 이들은 주로 Perl 5 포터가 유지 보수하지 않는 모듈에만 있습니다. 이 중 일부는 테스트에서만 실패한 것입니다. EBCDIC 플랫폼에서 다른 결과를 얻는 것이 적절하다는 것을 인식하지 못합니다. 그리고 일부 실패는 실제 버그입니다. Perl에서 컴파일하고 &lt;code&gt;make test&lt;/code&gt; 를 수행하면 &lt;code&gt;/cpan&lt;/code&gt; 디렉토리 의 모든 테스트를 건너 뜁니다.</target>
        </trans-unit>
        <trans-unit id="9a68ba03d821b0f9ca941d8a7348ffd6b9675672" translate="yes" xml:space="preserve">
          <source>There are a variety of ways of transforming data with an intra character set mapping that serve a variety of purposes. Sorting was discussed in the previous section and a few of the other more popular mapping techniques are discussed next.</source>
          <target state="translated">다양한 목적을 제공하는 인트라 문자 세트 맵핑으로 데이터를 변환하는 다양한 방법이 있습니다. 정렬은 이전 섹션에서 논의되었으며 다른 인기있는 몇 가지 매핑 기술은 다음에 논의됩니다.</target>
        </trans-unit>
        <trans-unit id="263ac344d4080439af54082913373a451c912861" translate="yes" xml:space="preserve">
          <source>There are actually two distinct kinds of version objects:</source>
          <target state="translated">실제로 두 가지 유형의 버전 객체가 있습니다.</target>
        </trans-unit>
        <trans-unit id="8c243ce02550d420fdebc8e85f18f50ac8e89a64" translate="yes" xml:space="preserve">
          <source>There are actually two varieties of null strings (sometimes referred to as &quot;empty&quot; strings), a defined one and an undefined one. The defined version is just a string of length zero, such as &lt;code&gt;&quot;&quot;&lt;/code&gt; . The undefined version is the value that indicates that there is no real value for something, such as when there was an error, or at end of file, or when you refer to an uninitialized variable or element of an array or hash. Although in early versions of Perl, an undefined scalar could become defined when first used in a place expecting a defined value, this no longer happens except for rare cases of autovivification as explained in &lt;a href=&quot;perlref&quot;&gt;perlref&lt;/a&gt;. You can use the defined() operator to determine whether a scalar value is defined (this has no meaning on arrays or hashes), and the undef() operator to produce an undefined value.</source>
          <target state="translated">실제로는 정의되지 않은 문자열과 정의되지 않은 문자열의 두 가지 null 문자열 (때로는 &quot;빈&quot;문자열이라고 함)이 있습니다. 정의 된 버전은 &lt;code&gt;&quot;&quot;&lt;/code&gt; 와 같이 길이가 0 인 문자열입니다 . 정의되지 않은 버전은 오류가 발생했을 때 또는 파일 끝에서 또는 초기화되지 않은 변수 또는 배열 또는 해시의 요소를 참조 할 때와 같이 무언가에 대한 실제 값이 없음을 나타내는 값입니다. 초기 버전의 Perl에서는 정의 된 값을 예상하는 장소에서 처음 사용할 때 정의되지 않은 스칼라가 정의 될 수 있지만 &lt;a href=&quot;perlref&quot;&gt;perlref에&lt;/a&gt; 설명 된 드문 경우의 자생 생존을 제외하고는 더 이상 발생하지 않습니다.. defined () 연산자를 사용하여 스칼라 값이 정의되어 있는지 (배열 또는 해시에 의미가 없는지) 확인하고 undef () 연산자를 사용하여 정의되지 않은 값을 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fe88dd9a713bfccf6064f23560d8e8bd2b27790f" translate="yes" xml:space="preserve">
          <source>There are actually two varieties of null strings (sometimes referred to as &quot;empty&quot; strings), a defined one and an undefined one. The defined version is just a string of length zero, such as &lt;code&gt;&quot;&quot;&lt;/code&gt;. The undefined version is the value that indicates that there is no real value for something, such as when there was an error, or at end of file, or when you refer to an uninitialized variable or element of an array or hash. Although in early versions of Perl, an undefined scalar could become defined when first used in a place expecting a defined value, this no longer happens except for rare cases of autovivification as explained in &lt;a href=&quot;perlref&quot;&gt;perlref&lt;/a&gt;. You can use the defined() operator to determine whether a scalar value is defined (this has no meaning on arrays or hashes), and the undef() operator to produce an undefined value.</source>
          <target state="translated">실제로 두 가지 종류의 널 문자열 ( &quot;빈&quot;문자열이라고도 함)이 있습니다. 하나는 정의 된 문자열이고 다른 하나는 정의되지 않은 문자열입니다. 정의 된 버전은 &lt;code&gt;&quot;&quot;&lt;/code&gt; 와 같이 길이가 0 인 문자열입니다 . 정의되지 않은 버전은 오류가 있거나 파일의 끝에서 또는 초기화되지 않은 변수 또는 배열 또는 해시의 요소를 참조 할 때와 같이 무언가에 대한 실제 값이 없음을 나타내는 값입니다. Perl의 초기 버전에서는 정의 된 값을 예상하는 장소에서 처음 사용될 때 정의되지 않은 스칼라가 정의 될 수 있었지만, &lt;a href=&quot;perlref&quot;&gt;perlref&lt;/a&gt; 에서 설명하는 드문 경우를 제외하고는 더 이상 발생하지 않습니다.. defined () 연산자를 사용하여 스칼라 값이 정의되었는지 (배열이나 해시에 의미가 없음) 결정하고 undef () 연산자를 사용하여 정의되지 않은 값을 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="547f74aebc059a529676c6646c9bed2946a0409e" translate="yes" xml:space="preserve">
          <source>There are additional macros whose values may be bitwise OR'ed with the &lt;code&gt;GV_ADD&lt;/code&gt; argument to enable certain extra features. Those bits are:</source>
          <target state="translated">특정 추가 기능을 사용하기 위해 &lt;code&gt;GV_ADD&lt;/code&gt; 인수로 값을 비트 단위로 OR 할 수있는 추가 매크로가 있습니다. 그 비트는 다음과 같습니다</target>
        </trans-unit>
        <trans-unit id="7a746509c86dffe25d4594a4b2c6a264d173eb5e" translate="yes" xml:space="preserve">
          <source>There are additional methods for regular expression patterns</source>
          <target state="translated">정규식 패턴에 대한 추가 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="51046d0ad7a7252d1ce87aabe4027ffe3663a57e" translate="yes" xml:space="preserve">
          <source>There are also &lt;code&gt;Win32::IsWinNT()&lt;/code&gt; and &lt;code&gt;Win32::IsWin95()&lt;/code&gt; ; try &lt;code&gt;perldoc Win32&lt;/code&gt; , and as of libwin32 0.19 (not part of the core Perl distribution) &lt;code&gt;Win32::GetOSName()&lt;/code&gt; . The very portable &lt;code&gt;POSIX::uname()&lt;/code&gt; will work too:</source>
          <target state="translated">도 있습니다 &lt;code&gt;Win32::IsWinNT()&lt;/code&gt; 과 &lt;code&gt;Win32::IsWin95()&lt;/code&gt; ; &lt;code&gt;perldoc Win32&lt;/code&gt; 를 시도 하고 libwin32 0.19 (핵심 Perl 배포의 일부는 아님) &lt;code&gt;Win32::GetOSName()&lt;/code&gt; 시도하십시오 . 이식성이 뛰어난 &lt;code&gt;POSIX::uname()&lt;/code&gt; 도 작동합니다 :</target>
        </trans-unit>
        <trans-unit id="a575561f3064d05553d9a3fbf390d2ed1e96d270" translate="yes" xml:space="preserve">
          <source>There are also &lt;code&gt;Win32::IsWinNT()|Win32/Win32::IsWinNT()&lt;/code&gt;, &lt;code&gt;Win32::IsWin95()|Win32/Win32::IsWin95()&lt;/code&gt;, and &lt;a href=&quot;win32#Win32%3A%3AGetOSName%28%29&quot;&gt;&lt;code&gt;Win32::GetOSName()&lt;/code&gt;&lt;/a&gt;; try &lt;a href=&quot;win32&quot;&gt;&lt;code&gt;perldoc Win32&lt;/code&gt;&lt;/a&gt;. The very portable &lt;a href=&quot;posix#uname&quot;&gt;&lt;code&gt;POSIX::uname()&lt;/code&gt;&lt;/a&gt; will work too:</source>
          <target state="translated">도 있습니다 &lt;code&gt;Win32::IsWinNT()|Win32/Win32::IsWinNT()&lt;/code&gt; , &lt;code&gt;Win32::IsWin95()|Win32/Win32::IsWin95()&lt;/code&gt; , 그리고 &lt;a href=&quot;win32#Win32%3A%3AGetOSName%28%29&quot;&gt; &lt;code&gt;Win32::GetOSName()&lt;/code&gt; &lt;/a&gt; ; &lt;a href=&quot;win32&quot;&gt; &lt;code&gt;perldoc Win32&lt;/code&gt; 를&lt;/a&gt; 사용해보십시오 . 이식성이 뛰어난 &lt;a href=&quot;posix#uname&quot;&gt; &lt;code&gt;POSIX::uname()&lt;/code&gt; &lt;/a&gt; 도 작동합니다.</target>
        </trans-unit>
        <trans-unit id="8e848855fa991c061ba1b0f19b935d8e48a52c00" translate="yes" xml:space="preserve">
          <source>There are also a variety of other special-purpose macros which save particular types or values of interest. &lt;code&gt;SAVETMPS&lt;/code&gt; has already been mentioned above. Others include &lt;code&gt;SAVEFREEPV&lt;/code&gt; which arranges for a PV (i.e. a string buffer) to be freed, or &lt;code&gt;SAVEDESTRUCTOR&lt;/code&gt; which arranges for a given function pointer to be invoked on scope exit. A full list of such macros can be found in</source>
          <target state="translated">특정 유형 또는 관심 값을 저장하는 다양한 기타 특수 목적 매크로도 있습니다. &lt;code&gt;SAVETMPS&lt;/code&gt; 는 이미 위에서 언급되었습니다. 다른 사람은 포함 &lt;code&gt;SAVEFREEPV&lt;/code&gt; 태양 광 발전 (즉, 문자열 버퍼) 주선가 해제 될, 또는 &lt;code&gt;SAVEDESTRUCTOR&lt;/code&gt; 주어진 함수 포인터 주선이 범위 출구에서 호출합니다. 이러한 매크로의 전체 목록은</target>
        </trans-unit>
        <trans-unit id="23127dab9bc88fbefc66139b670c575d072a34d4" translate="yes" xml:space="preserve">
          <source>There are also certain operations that are illegal. You can't nest &lt;code&gt;\p{...}&lt;/code&gt; and &lt;code&gt;\P{...}&lt;/code&gt; calls within a wildcard subpattern, and &lt;code&gt;\G&lt;/code&gt; doesn't make sense, so is also prohibited.</source>
          <target state="translated">불법적 인 특정 작업도 있습니다. 와일드 카드 하위 패턴 내에 &lt;code&gt;\p{...}&lt;/code&gt; 및 &lt;code&gt;\P{...}&lt;/code&gt; 호출을 중첩 할 수 없으며 &lt;code&gt;\G&lt;/code&gt; 도 의미가 없으므로 금지됩니다.</target>
        </trans-unit>
        <trans-unit id="68cc104cb95d94223dc9fddad7fb75cbcb044f6c" translate="yes" xml:space="preserve">
          <source>There are also endless possibilities to use</source>
          <target state="translated">사용하는 끝없는 가능성도 있습니다</target>
        </trans-unit>
        <trans-unit id="d8a2e4b90dc5ccc934f88be56fb54a760d42a1e5" translate="yes" xml:space="preserve">
          <source>There are also layers which actually just set flags on lower layers, or layers that modify the current stack but don't persist on the stack themselves; these are referred to as pseudo-layers.</source>
          <target state="translated">실제로 하위 레이어에 플래그를 설정하는 레이어 또는 현재 스택을 수정하지만 스택 자체에는 유지되지 않는 레이어도 있습니다. 이를 의사 계층이라고합니다.</target>
        </trans-unit>
        <trans-unit id="323189fd57b85b2e190ea90f3e9bb682b3b9f2e0" translate="yes" xml:space="preserve">
          <source>There are also plenty of Perl related newsgroups located under &lt;code&gt;comp.lang.perl.*&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;comp.lang.perl.*&lt;/code&gt; 아래에 Perl 관련 뉴스 그룹이 많이 있습니다 .</target>
        </trans-unit>
        <trans-unit id="527d1ab1f5f5398fbabcd044390ef4e42b5f0b60" translate="yes" xml:space="preserve">
          <source>There are also some commercial products that may work for you, although you have to buy a license for them.</source>
          <target state="translated">라이센스를 구입해야하지만 일부 상용 제품도 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8875c64205867a602cf00ce82127ede7aefa737d" translate="yes" xml:space="preserve">
          <source>There are also some commonly used modules for the task. &lt;a href=&quot;Scalar::Util&quot;&gt;Scalar::Util&lt;/a&gt; (distributed with 5.8) provides access to perl's internal function &lt;code&gt;looks_like_number&lt;/code&gt; for determining whether a variable looks like a number. &lt;a href=&quot;Data::Types&quot;&gt;Data::Types&lt;/a&gt; exports functions that validate data types using both the above and other regular expressions. Thirdly, there is &lt;a href=&quot;Regexp::Common&quot;&gt;Regexp::Common&lt;/a&gt; which has regular expressions to match various types of numbers. Those three modules are available from the CPAN.</source>
          <target state="translated">작업에 일반적으로 사용되는 모듈도 있습니다. &lt;a href=&quot;Scalar::Util&quot;&gt;Scalar :: Util&lt;/a&gt; (5.8과 함께 배포 됨)은 변수가 숫자처럼 보이는지 여부를 결정 하기 위해 perl의 내부 함수 &lt;code&gt;looks_like_number&lt;/code&gt; 에 대한 액세스를 제공합니다 . &lt;a href=&quot;Data::Types&quot;&gt;Data :: Types&lt;/a&gt; 는 위의 정규식과 다른 정규식을 모두 사용하여 데이터 유형의 유효성을 검사하는 함수를 내 보냅니다. 셋째, 다양한 유형의 숫자와 일치하는 정규 표현식 이있는 &lt;a href=&quot;Regexp::Common&quot;&gt;Regexp :: Common&lt;/a&gt; 이 있습니다. 이 세 가지 모듈은 CPAN에서 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="54ce59232e232d36fa4b243d9439f11e909759d7" translate="yes" xml:space="preserve">
          <source>There are also some commonly used modules for the task. &lt;a href=&quot;scalar/util&quot;&gt;Scalar::Util&lt;/a&gt; (distributed with 5.8) provides access to perl's internal function &lt;code&gt;looks_like_number&lt;/code&gt; for determining whether a variable looks like a number. &lt;a href=&quot;http://search.cpan.org/perldoc/Data::Types&quot;&gt;Data::Types&lt;/a&gt; exports functions that validate data types using both the above and other regular expressions. Thirdly, there is &lt;a href=&quot;http://search.cpan.org/perldoc/Regexp::Common&quot;&gt;Regexp::Common&lt;/a&gt; which has regular expressions to match various types of numbers. Those three modules are available from the CPAN.</source>
          <target state="translated">작업에 일반적으로 사용되는 몇 가지 모듈이 있습니다. &lt;a href=&quot;scalar/util&quot;&gt;Scalar :: Util&lt;/a&gt; (5.8로 배포)은 변수가 숫자처럼 보이는지 여부를 결정 하기 위해 perl의 내부 함수 &lt;code&gt;looks_like_number&lt;/code&gt; 에 액세스 할 수 있도록합니다. &lt;a href=&quot;http://search.cpan.org/perldoc/Data::Types&quot;&gt;Data :: Types&lt;/a&gt; 는 위와 다른 정규식을 모두 사용하여 데이터 형식의 유효성을 검사하는 함수를 내 보냅니다. 셋째, 다양한 유형의 숫자와 일치하는 &lt;a href=&quot;http://search.cpan.org/perldoc/Regexp::Common&quot;&gt;정규식&lt;/a&gt; 이있는 Regexp :: Common 이 있습니다. 이 세 가지 모듈은 CPAN에서 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b1ee19a63035c233ed5685ff1e3a13cd9e4a26d4" translate="yes" xml:space="preserve">
          <source>There are also some other op types: a &lt;code&gt;PMOP&lt;/code&gt; holds a regular expression, and has no children, and a &lt;code&gt;LOOP&lt;/code&gt; may or may not have children. If the &lt;code&gt;op_children&lt;/code&gt; field is non-zero, it behaves like a &lt;code&gt;LISTOP&lt;/code&gt; . To complicate matters, if a &lt;code&gt;UNOP&lt;/code&gt; is actually a &lt;code&gt;null&lt;/code&gt; op after optimization (see &lt;a href=&quot;#Compile-pass-2%3a-context-propagation&quot;&gt;Compile pass 2: context propagation&lt;/a&gt;) it will still have children in accordance with its former type.</source>
          <target state="translated">다른 op 유형도 있습니다. &lt;code&gt;PMOP&lt;/code&gt; 에는 정규식이 있고 자식이 없으며 &lt;code&gt;LOOP&lt;/code&gt; 에는 자식이 있거나 없을 수 있습니다. 는 IF &lt;code&gt;op_children&lt;/code&gt; 필드가 0이 아닌이며, 그것은처럼 동작 &lt;code&gt;LISTOP&lt;/code&gt; . 문제를 복잡하게하기 위해, 최적화 후 &lt;code&gt;UNOP&lt;/code&gt; 가 실제로 &lt;code&gt;null&lt;/code&gt; 연산 인 경우 ( &lt;a href=&quot;#Compile-pass-2%3a-context-propagation&quot;&gt;컴파일 패스 2 : 컨텍스트 전파 참조&lt;/a&gt; ) 여전히 이전 유형에 따라 하위 항목이 있습니다.</target>
        </trans-unit>
        <trans-unit id="11f74fbe23dd4e59c95a6d0f147c6383a5a62308" translate="yes" xml:space="preserve">
          <source>There are also some other op types: a &lt;code&gt;PMOP&lt;/code&gt; holds a regular expression, and has no children, and a &lt;code&gt;LOOP&lt;/code&gt; may or may not have children. If the &lt;code&gt;op_children&lt;/code&gt; field is non-zero, it behaves like a &lt;code&gt;LISTOP&lt;/code&gt;. To complicate matters, if a &lt;code&gt;UNOP&lt;/code&gt; is actually a &lt;code&gt;null&lt;/code&gt; op after optimization (see &lt;a href=&quot;#Compile-pass-2%3A-context-propagation&quot;&gt;&quot;Compile pass 2: context propagation&quot;&lt;/a&gt;) it will still have children in accordance with its former type.</source>
          <target state="translated">다른 op 유형도 있습니다. &lt;code&gt;PMOP&lt;/code&gt; 에는 정규식이 있고 자식이 없으며 &lt;code&gt;LOOP&lt;/code&gt; 에는 자식이있을 수도 있고 없을 수도 있습니다. 는 IF &lt;code&gt;op_children&lt;/code&gt; 필드가 0이 아닌이며, 그것은처럼 동작 &lt;code&gt;LISTOP&lt;/code&gt; . 문제를 복잡하게하기 위해, &lt;code&gt;UNOP&lt;/code&gt; 가 최적화 후 실제로 &lt;code&gt;null&lt;/code&gt; op 이면 ( &lt;a href=&quot;#Compile-pass-2%3A-context-propagation&quot;&gt;&quot;Compile pass 2 : context propagation&quot;참조&lt;/a&gt; ) 이전 유형에 따라 여전히 자식을 갖게됩니다.</target>
        </trans-unit>
        <trans-unit id="d74afa3e57d8bf587dddccd05e8aa225e3034ba7" translate="yes" xml:space="preserve">
          <source>There are also some tricks that you can play with &lt;code&gt;&lt;a href=&quot;functions/formline&quot;&gt;formline&lt;/a&gt;&lt;/code&gt; and the accumulator variable &lt;code&gt;$^A&lt;/code&gt; , but you lose a lot of the value of formats since &lt;code&gt;&lt;a href=&quot;functions/formline&quot;&gt;formline&lt;/a&gt;&lt;/code&gt; won't handle paging and so on. You end up reimplementing formats when you use them.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/formline&quot;&gt;formline&lt;/a&gt;&lt;/code&gt; 과 누산기 변수 &lt;code&gt;$^A&lt;/code&gt; 를 사용할 수있는 몇 가지 트릭도 있지만 &lt;code&gt;&lt;a href=&quot;functions/formline&quot;&gt;formline&lt;/a&gt;&lt;/code&gt; 이 페이징 등을 처리하지 않으므로 형식 값이 많이 손실됩니다 . 사용하면 형식을 다시 구현하게됩니다.</target>
        </trans-unit>
        <trans-unit id="4d45adb6b43e1a59ad871510a945d0116f3df08b" translate="yes" xml:space="preserve">
          <source>There are also some tricks that you can play with &lt;code&gt;formline&lt;/code&gt; and the accumulator variable &lt;code&gt;$^A&lt;/code&gt;, but you lose a lot of the value of formats since &lt;code&gt;formline&lt;/code&gt; won't handle paging and so on. You end up reimplementing formats when you use them.</source>
          <target state="translated">&lt;code&gt;formline&lt;/code&gt; 및 accumulator 변수 &lt;code&gt;$^A&lt;/code&gt; 를 사용할 수있는 몇 가지 트릭도 있지만, &lt;code&gt;formline&lt;/code&gt; 이 페이징 등을 처리하지 않기 때문에 형식의 가치를 많이 잃게됩니다 . 형식을 사용할 때 다시 구현하게됩니다.</target>
        </trans-unit>
        <trans-unit id="8a607b0a4fc3c7e1671b30a3b355e931c22fa4ed" translate="yes" xml:space="preserve">
          <source>There are also the two values &lt;code&gt;PL_sv_yes&lt;/code&gt; and &lt;code&gt;PL_sv_no&lt;/code&gt; , which contain boolean TRUE and FALSE values, respectively. Like &lt;code&gt;PL_sv_undef&lt;/code&gt; , their addresses can be used whenever an &lt;code&gt;SV*&lt;/code&gt; is needed.</source>
          <target state="translated">부울 TRUE 및 FALSE 값을 각각 포함 하는 두 개의 값 &lt;code&gt;PL_sv_yes&lt;/code&gt; 및 &lt;code&gt;PL_sv_no&lt;/code&gt; 도 있습니다. &lt;code&gt;PL_sv_undef&lt;/code&gt; 와 마찬가지로 &lt;code&gt;SV*&lt;/code&gt; 가 필요할 때마다 해당 주소를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="bada6ac2c7944b1149547067859a10dc227a309f" translate="yes" xml:space="preserve">
          <source>There are also the two values &lt;code&gt;PL_sv_yes&lt;/code&gt; and &lt;code&gt;PL_sv_no&lt;/code&gt;, which contain boolean TRUE and FALSE values, respectively. Like &lt;code&gt;PL_sv_undef&lt;/code&gt;, their addresses can be used whenever an &lt;code&gt;SV*&lt;/code&gt; is needed.</source>
          <target state="translated">또한 각각 부울 TRUE 및 FALSE 값을 포함 하는 두 개의 값 &lt;code&gt;PL_sv_yes&lt;/code&gt; 및 &lt;code&gt;PL_sv_no&lt;/code&gt; 가 있습니다. &lt;code&gt;PL_sv_undef&lt;/code&gt; 와 마찬가지로 &lt;code&gt;SV*&lt;/code&gt; 가 필요할 때마다 주소를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2a9975f54ba4b1444b192c3d8bfd7d71c13ebdbb" translate="yes" xml:space="preserve">
          <source>There are also versions of the functions with &quot;_hex&quot; or &quot;_base64&quot; appended to the name, which returns the digest in the indicated form.</source>
          <target state="translated">이름에 &quot;_hex&quot;또는 &quot;_base64&quot;가 추가 된 기능 버전도 있으며 이는 표시된 형식으로 요약을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="a5a4f4a9450ec80ee122e2031504c8884d21e28d" translate="yes" xml:space="preserve">
          <source>There are at least two instance variables stored in a hash reference, {data} and {encoding}.</source>
          <target state="translated">해시 참조에 {data} 및 {encoding}의 인스턴스 변수가 두 개 이상 저장되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="68682d3f996c5d0d4c5e2cf0ab83889b2edb3594" translate="yes" xml:space="preserve">
          <source>There are cases when you will not know beforehand how many tests your script is going to run. In this case, you can declare your tests at the end.</source>
          <target state="translated">스크립트가 몇 개의 테스트를 실행할지 미리 알 수없는 경우가 있습니다. 이 경우 마지막에 테스트를 선언 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="13a4d162b9b64ac9d632dbabef83e1cc311a2290" translate="yes" xml:space="preserve">
          <source>There are certain application spaces which are already very, very well served by CPAN. One example is templating systems, another is date and time modules, and there are many more. While it is a rite of passage to write your own version of these things, please consider carefully whether the Perl world really needs you to publish it.</source>
          <target state="translated">CPAN이 이미 제공 한 특정 애플리케이션 공간이 있습니다. 하나는 템플릿 시스템이고, 다른 하나는 날짜 및 시간 모듈이며, 더 많은 것이 있습니다. 이런 것들을 자신의 버전으로 작성하는 것은 통과 의례이지만, Perl 세계가 실제로 그것을 출판해야하는지 신중하게 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="6418df0a423a65fdef15c0f2ab1cbad9a1e3cda6" translate="yes" xml:space="preserve">
          <source>There are certain properties that wildcard subpatterns don't currently work with. These are:</source>
          <target state="translated">와일드 카드 하위 패턴이 현재 작동하지 않는 특정 속성이 있습니다. 이것들은:</target>
        </trans-unit>
        <trans-unit id="f399d82ea760be3c44c0c12193de98d98ca6c0b6" translate="yes" xml:space="preserve">
          <source>There are corresponding one-letter commands &lt;code&gt;a&lt;/code&gt; , &lt;code&gt;b&lt;/code&gt; , &lt;code&gt;d&lt;/code&gt; , and &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m&lt;/a&gt;&lt;/code&gt; for each of the four categories and another, &lt;code&gt;i&lt;/code&gt; for any of the mentioned four. Each of the four entities is implemented as a class with slightly differing methods for displaying an object.</source>
          <target state="translated">대응하는 문자 명령있다 , &lt;code&gt;b&lt;/code&gt; , &lt;code&gt;d&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m&lt;/a&gt;&lt;/code&gt; 은 상기 네 개의 카테고리들 각각에 대해 다른 &lt;code&gt;i&lt;/code&gt; (가) 네 언급 중 어떤. 4 개의 엔티티 각각은 객체를 표시하는 방법이 약간 다른 클래스로 구현됩니다. &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="61165542c376ce1515ee946fb54e0b62bf506b50" translate="yes" xml:space="preserve">
          <source>There are currently three implementations:</source>
          <target state="translated">현재 세 가지 구현이 있습니다.</target>
        </trans-unit>
        <trans-unit id="97e0702d9f24205eb392b550bdee3cc7f1886fbc" translate="yes" xml:space="preserve">
          <source>There are currently two implementations:</source>
          <target state="translated">현재 두 가지 구현이 있습니다.</target>
        </trans-unit>
        <trans-unit id="fb1fef3dafc65f2dd5f6f03815febb7cc02429e1" translate="yes" xml:space="preserve">
          <source>There are different classes in the &lt;a href=&quot;Email::Folder&quot;&gt;Email::Folder&lt;/a&gt; namespace for supporting various mailbox types. Note that these modules are generally rather limited and only support &lt;b&gt;reading&lt;/b&gt; rather than writing.</source>
          <target state="translated">&lt;a href=&quot;Email::Folder&quot;&gt;Email :: Folder&lt;/a&gt; 네임 스페이스에는 다양한 사서함 유형을 지원하기위한 다양한 클래스가 있습니다. 이러한 모듈은 일반적으로 다소 제한적이며 쓰기보다는 &lt;b&gt;읽기만&lt;/b&gt; 지원 합니다.</target>
        </trans-unit>
        <trans-unit id="7082baef78129948a9aee04418c7c10c1b4d4a87" translate="yes" xml:space="preserve">
          <source>There are different classes in the &lt;a href=&quot;http://search.cpan.org/perldoc/Email::Folder&quot;&gt;Email::Folder&lt;/a&gt; namespace for supporting various mailbox types. Note that these modules are generally rather limited and only support &lt;b&gt;reading&lt;/b&gt; rather than writing.</source>
          <target state="translated">&lt;a href=&quot;http://search.cpan.org/perldoc/Email::Folder&quot;&gt;Email :: Folder&lt;/a&gt; 네임 스페이스에는 다양한 사서함 유형을 지원하기위한 다양한 클래스가 있습니다. 이러한 모듈은 일반적으로 다소 제한적이며 쓰기보다는 &lt;b&gt;읽기만&lt;/b&gt; 지원 합니다.</target>
        </trans-unit>
        <trans-unit id="7ffae46f4361bbc29cee623ab319bb8483adbbdb" translate="yes" xml:space="preserve">
          <source>There are exceptions to the above rules for dereference operations (which, if Step 1 fails, always fall back to the normal, built-in implementations - see Dereferencing), and for &lt;code&gt;~~&lt;/code&gt; (which has its own set of rules - see &lt;code&gt;Matching&lt;/code&gt; under &lt;a href=&quot;#Overloadable-Operations&quot;&gt;&quot;Overloadable Operations&quot;&lt;/a&gt; above).</source>
          <target state="translated">등에 대한 -이 역 참조 작업에 대한 위의 규칙에 대한 예외 (역 참조를 참조 1 단계가 실패 할 경우, 항상 정상으로 돌아 가을, 내장 구현)입니다 &lt;code&gt;~~&lt;/code&gt; 규칙의 그것의 자신의 세트가있다 (- 참조 &lt;code&gt;Matching&lt;/code&gt; 아래를 &lt;a href=&quot;#Overloadable-Operations&quot;&gt;위의 &quot;오버로드 가능한 작업&quot;&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="ed85d6fa9e5690e5659a7fcf3cc7c90a6a9abc89" translate="yes" xml:space="preserve">
          <source>There are exceptions to the above rules for dereference operations (which, if Step 1 fails, always fall back to the normal, built-in implementations - see Dereferencing), and for &lt;code&gt;~~&lt;/code&gt; (which has its own set of rules - see &lt;code&gt;Matching&lt;/code&gt; under &lt;a href=&quot;#Overloadable-Operations&quot;&gt;Overloadable Operations&lt;/a&gt; above).</source>
          <target state="translated">등에 대한 -이 역 참조 작업에 대한 위의 규칙에 대한 예외 (역 참조를 참조 1 단계가 실패 할 경우, 항상 정상으로 돌아 가을, 내장 구현)입니다 &lt;code&gt;~~&lt;/code&gt; 규칙의 그것의 자신의 세트가있다 (- 참조 &lt;code&gt;Matching&lt;/code&gt; 아래를 위의 &lt;a href=&quot;#Overloadable-Operations&quot;&gt;과부하 작업&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="129afe5f5ce43c82f8dd2611661b6c6fae2152e8" translate="yes" xml:space="preserve">
          <source>There are exceptions to the simple scalar maps. Some properties have some elements in their map list that are themselves lists of scalars; and some special strings are returned that are not to be interpreted as-is. Element [2] (placed into &lt;code&gt;$format&lt;/code&gt; in the example above) of the returned four element list tells you if the map has any of these special elements or not, as follows:</source>
          <target state="translated">단순 스칼라 맵에는 예외가 있습니다. 일부 속성에는 맵 목록에 스칼라 목록 인 일부 요소가 있습니다. 그리고 그대로 해석되지 않는 일부 특수 문자열이 리턴됩니다. 반환 된 네 개의 요소 목록 중 요소 [2] (위 예에서 &lt;code&gt;$format&lt;/code&gt; 배치 )는 다음과 같이지도에 이러한 특수 요소가 있는지 여부를 알려줍니다.</target>
        </trans-unit>
        <trans-unit id="03da32e2f08e4c55ca723ef0de464a8b0fc8a37a" translate="yes" xml:space="preserve">
          <source>There are five pattern matching operations other than a strict one-to-one match between the pattern and the source to be checked for a match.</source>
          <target state="translated">패턴과 일치 여부를 검사 할 소스간에 엄격한 일대일 일치 이외의 다섯 가지 패턴 일치 작업이 있습니다.</target>
        </trans-unit>
        <trans-unit id="caaaee4619b1124c4cd083d4f94b5aeee43dd52b" translate="yes" xml:space="preserve">
          <source>There are four arguments:</source>
          <target state="translated">네 가지 주장이 있습니다.</target>
        </trans-unit>
        <trans-unit id="c30d8b75df6d6d560de84db459ba9ddeaac5bfd4" translate="yes" xml:space="preserve">
          <source>There are four methods associated with DBM Filters. All work identically, and each is used to install (or uninstall) a single DBM Filter. Each expects a single parameter, namely a reference to a sub. The only difference between them is the place that the filter is installed.</source>
          <target state="translated">DBM 필터와 관련된 네 가지 방법이 있습니다. 모두 동일하게 작동하며 각각 단일 DBM 필터를 설치 (또는 설치 제거)하는 데 사용됩니다. 각각은 단일 매개 변수, 즉 하위에 대한 참조를 필요로합니다. 그들 사이의 유일한 차이점은 필터가 설치된 장소입니다.</target>
        </trans-unit>
        <trans-unit id="2b4786fe13177802911e40046450c4aa8a6b7442" translate="yes" xml:space="preserve">
          <source>There are four routines that can be used to call a Perl subroutine from within a C program. These four are:</source>
          <target state="translated">C 프로그램 내에서 Perl 서브 루틴을 호출하는 데 사용할 수있는 네 가지 루틴이 있습니다. 이 네 가지는 :</target>
        </trans-unit>
        <trans-unit id="0b4c3b4907f361ea335c94a68bf5900b38774c4c" translate="yes" xml:space="preserve">
          <source>There are just two ways to make a reference, and just two ways to use it once you have it.</source>
          <target state="translated">참조를하는 데는 두 가지 방법이 있으며, 일단 참조를 사용하는 데는 두 가지 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="451300c3402db478bc017d97504bbf1dc7589d4f" translate="yes" xml:space="preserve">
          <source>There are literally dozens of other OO-related modules on CPAN besides those covered here, and you're likely to run across one or more of them if you work with other people's code.</source>
          <target state="translated">CPAN에는 문자 그대로 수십 개의 다른 OO 관련 모듈이 있으며 여기에서 다루는 것 외에도 다른 사람들의 코드로 작업 할 경우 하나 이상의 모듈에서 실행될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6c77d5c24285fecf2b82ebf41d5dec81876d45b0" translate="yes" xml:space="preserve">
          <source>There are lots more commands and options, but the above will do it.</source>
          <target state="translated">더 많은 명령과 옵션이 있지만 위의 작업과 옵션이 가능합니다.</target>
        </trans-unit>
        <trans-unit id="837d89ccfb96f196a244bf30256b711d40a975e1" translate="yes" xml:space="preserve">
          <source>There are many Perl &lt;a href=&quot;http://search.cpan.org/perldoc/lists.perl.org&quot;&gt;mailing lists&lt;/a&gt; for various topics, specifically the &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2flists.perl.org%2flist%2fbeginners.html&quot;&gt;beginners list&lt;/a&gt; may be of use.</source>
          <target state="translated">다양한 주제에 대한 Perl &lt;a href=&quot;http://search.cpan.org/perldoc/lists.perl.org&quot;&gt;메일 링리스트&lt;/a&gt; 가 많이 있으며 , 특히 &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2flists.perl.org%2flist%2fbeginners.html&quot;&gt;초보자리스트&lt;/a&gt; 가 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c100a4e2353b8e1e3f993e428fe4246a2ed1c1dd" translate="yes" xml:space="preserve">
          <source>There are many Perl &lt;a href=&quot;lists.perl.org&quot;&gt;mailing lists&lt;/a&gt; for various topics, specifically the &lt;a href=&quot;http://lists.perl.org/list/beginners.html&quot;&gt;beginners list&lt;/a&gt; may be of use.</source>
          <target state="translated">다양한 주제에 대한 많은 Perl &lt;a href=&quot;lists.perl.org&quot;&gt;메일 링 목록&lt;/a&gt; 이 있으며 특히 &lt;a href=&quot;http://lists.perl.org/list/beginners.html&quot;&gt;초보자 목록&lt;/a&gt; 이 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9bec5519f33a4e7bdc4a53a2313d4e1bcfcd1067" translate="yes" xml:space="preserve">
          <source>There are many books on Perl and Perl-related. A few of these are good, some are OK, but many aren't worth your money. There is a list of these books, some with extensive reviews, at &lt;a href=&quot;http://books.perl.org/&quot;&gt;http://books.perl.org/&lt;/a&gt; . We list some of the books here, and while listing a book implies our endorsement, don't think that not including a book means anything.</source>
          <target state="translated">Perl 및 Perl 관련 책이 많이 있습니다. 이것들 중 몇 가지는 좋고, 어떤 것은 괜찮지 만, 많은 사람들은 돈을 쓸 가치가 없습니다. &lt;a href=&quot;http://books.perl.org/&quot;&gt;http://books.perl.org/&lt;/a&gt; 에이 책들의 목록이 있으며 일부는 광범위한 리뷰를 가지고 있습니다. 우리는 여기에 일부 책을 나열하고, 책을 나열하는 것이 우리의 승인을 의미하지만 책을 포함하지 않는 것이 의미가 있다고 생각하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c4e51ecd675e07ca3b7be0664408ec108e37de71" translate="yes" xml:space="preserve">
          <source>There are many different ftp firewall products available. But unfortunately there is no standard for how to traverse a firewall. The list below shows the sequence of commands that Net::FTP will use</source>
          <target state="translated">사용 가능한 여러 가지 ftp 방화벽 제품이 있습니다. 그러나 불행히도 방화벽을 통과하는 방법에 대한 표준은 없습니다. 아래 목록은 Net :: FTP가 사용할 명령 순서를 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="ccca22cadfc5874b657dd6b896d963adc193de41" translate="yes" xml:space="preserve">
          <source>There are many good &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fwww.perl.org%2fbooks%2flibrary.html&quot;&gt;books on Perl&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fwww.perl.org%2fbooks%2flibrary.html&quot;&gt;Perl에 관한&lt;/a&gt; 좋은 책 들이 많이 있습니다 .</target>
        </trans-unit>
        <trans-unit id="25f8cf87f8d0d010ba0c130a03c0c733508760a7" translate="yes" xml:space="preserve">
          <source>There are many good &lt;a href=&quot;http://www.perl.org/books/library.html&quot;&gt;books on Perl&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://www.perl.org/books/library.html&quot;&gt;Perl에 대한&lt;/a&gt; 좋은 책 이 많이 있습니다 .</target>
        </trans-unit>
        <trans-unit id="18c010c4c2e46af9e1a3df8426bb24c3742b96b7" translate="yes" xml:space="preserve">
          <source>There are many more properties than the very basic ones described here. A complete list is in &lt;a href=&quot;perluniprops&quot;&gt;perluniprops&lt;/a&gt;.</source>
          <target state="translated">여기에 설명 된 가장 기본적인 것보다 더 많은 속성이 있습니다. 전체 목록은 &lt;a href=&quot;perluniprops&quot;&gt;perluniprops에&lt;/a&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="9a8e433d3ac89e153ddbae16288b146a2a506dab" translate="yes" xml:space="preserve">
          <source>There are many other functions available since FileHandle is descended from IO::File, IO::Seekable, and IO::Handle. Please see those respective pages for documentation on more functions.</source>
          <target state="translated">FileHandle이 IO :: File, IO :: Seekable 및 IO :: Handle의 하위 항목이므로 사용 가능한 다른 기능이 많이 있습니다. 더 많은 기능에 대한 설명서는 해당 페이지를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="19b014b8d66d3b187e540a67f34591fd12721782" translate="yes" xml:space="preserve">
          <source>There are many reasons, but the major one is cross-platform compatibility.</source>
          <target state="translated">여러 가지 이유가 있지만 가장 큰 이유는 크로스 플랫폼 호환성입니다.</target>
        </trans-unit>
        <trans-unit id="ec8353eb61918c8ea09b548fd2c7481452870299" translate="yes" xml:space="preserve">
          <source>There are many ways to ensure that values are what you expect or want to accept. Besides the specific examples that we cover in the perlfaq, you can also look at the modules with &quot;Assert&quot; and &quot;Validate&quot; in their names, along with other modules such as &lt;a href=&quot;Regexp::Common&quot;&gt;Regexp::Common&lt;/a&gt;.</source>
          <target state="translated">값이 기대하거나 수용하려는 값인지 확인하는 방법에는 여러 가지가 있습니다. perlfaq에서 다루는 특정 예제 외에도 이름에 &quot;Assert&quot;및 &quot;Validate&quot;가 포함 된 모듈과 &lt;a href=&quot;Regexp::Common&quot;&gt;Regexp :: Common&lt;/a&gt; 과 같은 다른 모듈도 볼 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4f22a618b10f083a38eaf97d7560bbf775ba04c7" translate="yes" xml:space="preserve">
          <source>There are many ways to ensure that values are what you expect or want to accept. Besides the specific examples that we cover in the perlfaq, you can also look at the modules with &quot;Assert&quot; and &quot;Validate&quot; in their names, along with other modules such as &lt;a href=&quot;http://search.cpan.org/perldoc/Regexp::Common&quot;&gt;Regexp::Common&lt;/a&gt;.</source>
          <target state="translated">값이 기대하거나 수용하려는 값이되도록 여러 가지 방법이 있습니다. perlfaq에서 다루는 특정 예제 외에도 &lt;a href=&quot;http://search.cpan.org/perldoc/Regexp::Common&quot;&gt;Regexp :: Common&lt;/a&gt; 과 같은 다른 모듈과 함께 이름이 &quot;Assert&quot;및 &quot;Validate&quot;인 모듈을 볼 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c508352f954b14145337f34025470ea842ef7b40" translate="yes" xml:space="preserve">
          <source>There are many ways to get multiline data into a string. If you want it to happen automatically while reading input, you'll want to set $/ (probably to '' for paragraphs or &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; for the whole file) to allow you to read more than one line at a time.</source>
          <target state="translated">여러 줄 데이터를 문자열로 가져 오는 방법에는 여러 가지가 있습니다. 입력을 읽는 동안 자동으로 발생 하게하려면 한 번에 두 줄 이상을 읽을 수 있도록 $ /를 설정하십시오 (단락의 경우 ''또는 전체 파일의 경우 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 로 설정).</target>
        </trans-unit>
        <trans-unit id="d0c13e2ae1a5d488cf21f540ff8605d82939bccd" translate="yes" xml:space="preserve">
          <source>There are many ways to get multiline data into a string. If you want it to happen automatically while reading input, you'll want to set $/ (probably to '' for paragraphs or &lt;code&gt;undef&lt;/code&gt; for the whole file) to allow you to read more than one line at a time.</source>
          <target state="translated">여러 줄 데이터를 문자열로 가져 오는 방법에는 여러 가지가 있습니다. 입력을 읽는 동안 자동으로 실행되도록하려면 $ / (아마 단락의 경우 ''로 설정하거나 전체 파일의 경우 &lt;code&gt;undef&lt;/code&gt; )를 설정하여 한 번에 한 줄 이상을 읽을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3dc3f3b5eae147e801f5f43fb6a8fbac0ae189bf" translate="yes" xml:space="preserve">
          <source>There are many, many Unicode character properties. For the full list see &lt;a href=&quot;perluniprops&quot;&gt;perluniprops&lt;/a&gt;. Most of them have synonyms with shorter names, also listed there. Some synonyms are a single character. For these, you can drop the braces. For instance, &lt;code&gt;\pM&lt;/code&gt; is the same thing as &lt;code&gt;\p{Mark}&lt;/code&gt; , meaning things like accent marks.</source>
          <target state="translated">많은 유니 코드 문자 속성이 있습니다. 전체 목록은 &lt;a href=&quot;perluniprops&quot;&gt;perluniprops를&lt;/a&gt; 참조하십시오 . 그들 중 대부분은 짧은 이름의 동의어를 가지고 있으며 거기에 나열되어 있습니다. 일부 동의어는 단일 문자입니다. 이를 위해 버팀대를 떨어 뜨릴 수 있습니다. 예를 들어, &lt;code&gt;\pM&lt;/code&gt; 은 &lt;code&gt;\p{Mark}&lt;/code&gt; 와 동일하며 악센트 표시와 같은 것을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="69da32a8fafef027c405b2092d6a66a08f07e5a2" translate="yes" xml:space="preserve">
          <source>There are many, many Unicode character properties. For the full list see &lt;a href=&quot;perluniprops&quot;&gt;perluniprops&lt;/a&gt;. Most of them have synonyms with shorter names, also listed there. Some synonyms are a single character. For these, you can drop the braces. For instance, &lt;code&gt;\pM&lt;/code&gt; is the same thing as &lt;code&gt;\p{Mark}&lt;/code&gt;, meaning things like accent marks.</source>
          <target state="translated">많은 유니 코드 문자 속성이 있습니다. 전체 목록은 &lt;a href=&quot;perluniprops&quot;&gt;perluniprops를&lt;/a&gt; 참조하십시오 . 그들 중 대부분은 더 짧은 이름을 가진 동의어를 가지고 있으며 거기에도 나열되어 있습니다. 일부 동의어는 단일 문자입니다. 이를 위해 중괄호를 삭제할 수 있습니다. 예를 들어, &lt;code&gt;\pM&lt;/code&gt; 은 &lt;code&gt;\p{Mark}&lt;/code&gt; 와 동일하며 악센트 표시와 같은 것을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="1a61fc5e0ce0e0ef09d3d9c85a06d1ddbe46e285" translate="yes" xml:space="preserve">
          <source>There are many, many code points, but computers work with bytes, and a byte has room for only 256 values. Unicode has many more characters than that, so you need a method to make these accessible.</source>
          <target state="translated">많은 코드 포인트가 있지만 컴퓨터는 바이트로 작동하며 바이트에는 256 값만 사용할 수 있습니다. 유니 코드에는 그보다 더 많은 문자가 있으므로이를 액세스 할 수있는 방법이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="88acdd96ec6d6927c08fab60ea3227280069d628" translate="yes" xml:space="preserve">
          <source>There are many, many sources for Solaris information. A few of the important ones for perl:</source>
          <target state="translated">Solaris 정보에 대한 많은 소스가 있습니다. 펄을위한 중요한 것들 :</target>
        </trans-unit>
        <trans-unit id="83467e96db886b15aa3db22c9e9e4b034057eea3" translate="yes" xml:space="preserve">
          <source>There are modules to help you through the process of writing a module: &lt;a href=&quot;ExtUtils::ModuleMaker&quot;&gt;ExtUtils::ModuleMaker&lt;/a&gt;, &lt;a href=&quot;Module::Starter&quot;&gt;Module::Starter&lt;/a&gt;, &lt;a href=&quot;Minilla::Tutorial&quot;&gt;Minilla::Tutorial&lt;/a&gt;, &lt;a href=&quot;Dist::Milla::Tutorial&quot;&gt;Dist::Milla::Tutorial&lt;/a&gt;, &lt;a href=&quot;Dist::Zilla::Starter&quot;&gt;Dist::Zilla::Starter&lt;/a&gt;</source>
          <target state="translated">모듈 작성 과정을 도와주는 모듈이 있습니다 : &lt;a href=&quot;ExtUtils::ModuleMaker&quot;&gt;ExtUtils :: ModuleMaker&lt;/a&gt; , &lt;a href=&quot;Module::Starter&quot;&gt;Module :: Starter&lt;/a&gt; , &lt;a href=&quot;Minilla::Tutorial&quot;&gt;Minilla :: Tutorial&lt;/a&gt; , &lt;a href=&quot;Dist::Milla::Tutorial&quot;&gt;Dist :: Milla :: Tutorial&lt;/a&gt; , &lt;a href=&quot;Dist::Zilla::Starter&quot;&gt;Dist :: Zilla :: Starter&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c8f4eee710987379a0f55c604a3354e69d7b2875" translate="yes" xml:space="preserve">
          <source>There are modules to help you through the process of writing a module: &lt;a href=&quot;http://search.cpan.org/perldoc/ExtUtils::ModuleMaker&quot;&gt;ExtUtils::ModuleMaker&lt;/a&gt;, &lt;a href=&quot;http://search.cpan.org/perldoc/Module::Install&quot;&gt;Module::Install&lt;/a&gt;, &lt;a href=&quot;http://search.cpan.org/perldoc/PAR&quot;&gt;PAR&lt;/a&gt;</source>
          <target state="translated">모듈 작성 과정을 도와주는 모듈이 있습니다 : &lt;a href=&quot;http://search.cpan.org/perldoc/ExtUtils::ModuleMaker&quot;&gt;ExtUtils :: ModuleMaker&lt;/a&gt; , &lt;a href=&quot;http://search.cpan.org/perldoc/Module::Install&quot;&gt;Module :: Install&lt;/a&gt; , &lt;a href=&quot;http://search.cpan.org/perldoc/PAR&quot;&gt;PAR&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="da29172199b45020f43775089b9830c405a497fb" translate="yes" xml:space="preserve">
          <source>There are no deprecations or fatalizations scheduled for Perl 5.34.</source>
          <target state="translated">Perl 5.34에 대해 예정된 지원 중단 또는 치명 화가 없습니다.</target>
        </trans-unit>
        <trans-unit id="61d4491371efc2ca44fd016e5d9139fc5fa773fa" translate="yes" xml:space="preserve">
          <source>There are no loops of references.</source>
          <target state="translated">참조 루프가 없습니다.</target>
        </trans-unit>
        <trans-unit id="476c776008d55428fe7585fbd0c3dce927c522c4" translate="yes" xml:space="preserve">
          <source>There are no unique methods for unknown results.</source>
          <target state="translated">알 수없는 결과에 대한 고유 한 방법이 없습니다.</target>
        </trans-unit>
        <trans-unit id="b571d2027807fc8b9e77b0de9129097419041bc0" translate="yes" xml:space="preserve">
          <source>There are non-obvious Unicode rules under &lt;code&gt;/i&lt;/code&gt; that can match variably, but which you might not think could. For example, the substring &lt;code&gt;&quot;ss&quot;&lt;/code&gt; can match the single character LATIN SMALL LETTER SHARP S. There are other sequences of ASCII characters that can match single ligature characters, such as LATIN SMALL LIGATURE FFI matching &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr/ffi/i&lt;/a&gt;&lt;/code&gt;. Starting in Perl v5.16, if you only care about ASCII matches, adding the &lt;code&gt;/aa&lt;/code&gt; modifier to the regex will exclude all these non-obvious matches, thus getting rid of this message. You can also say &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re qw(/aa)&lt;/code&gt; to apply &lt;code&gt;/aa&lt;/code&gt; to all regular expressions compiled within its scope. See &lt;a href=&quot;re&quot;&gt;re&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;/i&lt;/code&gt; 아래에는 명확 하게 일치 할 수 있지만 명확하지 않은 유니 코드 규칙 이 있습니다. 예를 들어, 하위 문자열 &lt;code&gt;&quot;ss&quot;&lt;/code&gt; 는 단일 문자 LATIN SMALL LETTER SHARP S와 일치 할 수 있습니다. 단일 합자 문자와 일치 할 수있는 다른 ASCII 문자 시퀀스 (예 : LATIN SMALL LIGATURE FFI matching &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr/ffi/i&lt;/a&gt;&lt;/code&gt; )가 있습니다. Perl v5.16부터 ASCII 일치 만 신경 쓰면 &lt;code&gt;/aa&lt;/code&gt; 수정자를 정규식에 추가하면 이러한 모든 명백하지 않은 일치가 제외 되어이 메시지가 제거됩니다. 당신은 또한 말할 수 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re qw(/aa)&lt;/code&gt; 적용 &lt;code&gt;/aa&lt;/code&gt; 그 범위 내에서 컴파일 된 모든 정규 표현식. &lt;a href=&quot;re&quot;&gt;다시&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e5ad264a4513834556a80639fe98434e6bc7fc63" translate="yes" xml:space="preserve">
          <source>There are now two nested loops in the code: the outer loop for reading the compressed data from STDIN, as before; and the inner loop to carry out the uncompression.</source>
          <target state="translated">코드에는 두 개의 중첩 루프가 있습니다. 이전과 같이 STDIN에서 압축 된 데이터를 읽는 외부 루프; 압축을 수행하기위한 내부 루프.</target>
        </trans-unit>
        <trans-unit id="30d7f3a596ae687e7d1a74baf88a83df7d754b06" translate="yes" xml:space="preserve">
          <source>There are only a few attributes currently handled by Perl itself (or directly by this module, depending on how you look at it.) However, package-specific attributes are allowed by an extension mechanism. (See &lt;a href=&quot;#Package-specific-Attribute-Handling&quot;&gt;&quot;Package-specific Attribute Handling&quot;&lt;/a&gt; below.)</source>
          <target state="translated">현재 Perl 자체 (또는 사용자가 보는 방식에 따라이 모듈에서 직접 처리하는 속성)는 거의 없습니다. 그러나 패키지 특정 속성은 확장 메커니즘에 의해 허용됩니다. (아래의 &lt;a href=&quot;#Package-specific-Attribute-Handling&quot;&gt;&quot;패키지 별 속성 처리&quot;를&lt;/a&gt; 참조하십시오.)</target>
        </trans-unit>
        <trans-unit id="a69e0c87595733580f5c73f14c1fdeb5543877d6" translate="yes" xml:space="preserve">
          <source>There are only a few attributes currently handled by Perl itself (or directly by this module, depending on how you look at it.) However, package-specific attributes are allowed by an extension mechanism. (See &lt;a href=&quot;#Package-specific-Attribute-Handling&quot;&gt;Package-specific Attribute Handling&lt;/a&gt; below.)</source>
          <target state="translated">현재 Perl 자체 (또는이 모듈에서 직접 보는 방식에 따라 직접 처리)에 의해 처리되는 속성은 거의 없습니다. 그러나 패키지 특정 속성은 확장 메커니즘에 의해 허용됩니다. 아래 &lt;a href=&quot;#Package-specific-Attribute-Handling&quot;&gt;패키지 별 속성 처리를&lt;/a&gt; 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="108ccf06b73794e0f286d42a6259562039de6c36" translate="yes" xml:space="preserve">
          <source>There are other documents which might contain the information that you're looking for:</source>
          <target state="translated">찾고있는 정보를 포함 할 수있는 다른 문서가 있습니다.</target>
        </trans-unit>
        <trans-unit id="ffadbd86efea8ed0c7e9318ac1bd6a93e63feaa1" translate="yes" xml:space="preserve">
          <source>There are other minor differences, particularly regarding &lt;code&gt;&lt;a href=&quot;../functions/exists&quot;&gt;exists&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../functions/delete&quot;&gt;delete&lt;/a&gt;&lt;/code&gt;, but in general, the correspondence is extremely close.</source>
          <target state="translated">특히 &lt;code&gt;&lt;a href=&quot;../functions/exists&quot;&gt;exists&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../functions/delete&quot;&gt;delete&lt;/a&gt;&lt;/code&gt; 와 관련하여 다른 사소한 차이 가 있지만 일반적으로 해당 관계는 매우 가깝습니다.</target>
        </trans-unit>
        <trans-unit id="496c73a8b66b8bb32b2aaf26def98246996ff9e4" translate="yes" xml:space="preserve">
          <source>There are other minor differences, particularly regarding &lt;code&gt;exists&lt;/code&gt; and &lt;code&gt;delete&lt;/code&gt;, but in general, the correspondence is extremely close.</source>
          <target state="translated">특히 exist 및 &lt;code&gt;delete&lt;/code&gt; 와 관련하여 다른 사소한 차이점 &lt;code&gt;exists&lt;/code&gt; 있지만 일반적으로 해당 내용은 매우 가깝습니다.</target>
        </trans-unit>
        <trans-unit id="e7bb3958077e624c5300c166b4aa5d1f00cfb6ff" translate="yes" xml:space="preserve">
          <source>There are other runtime options as well. You can use &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack()&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">다른 런타임 옵션도 있습니다. &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack()&lt;/a&gt;&lt;/code&gt; 사용할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="1c3cf0f599cf582932d460a014aeed655f3e2812" translate="yes" xml:space="preserve">
          <source>There are other runtime options as well. You can use &lt;code&gt;pack()&lt;/code&gt;:</source>
          <target state="translated">다른 런타임 옵션도 있습니다. &lt;code&gt;pack()&lt;/code&gt; 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fae6e762f25c5a7d9726dbb80f1e49251722d367" translate="yes" xml:space="preserve">
          <source>There are platforms where longs are 64 bits, and platforms where ints are 64 bits, and while we are out to shock you, even platforms where shorts are 64 bits. This is all legal according to the C standard. (In other words, &quot;long long&quot; is not a portable way to specify 64 bits, and &quot;long long&quot; is not even guaranteed to be any wider than &quot;long&quot;.)</source>
          <target state="translated">long이 64 비트 인 플랫폼과 int가 64 비트 인 플랫폼이 있으며, 쇼트가 64 비트 인 플랫폼까지 충격을 주려고합니다. 이것은 C 표준에 따라 모두 합법적입니다. 즉, &quot;long long&quot;은 64 비트를 지정하는 이식 가능한 방법이 아니며 &quot;long long&quot;은 &quot;long&quot;보다 더 넓은 것으로 보장되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a1d48b6e5e54bf5c7c0f9c8f92bbb4b843c99efe" translate="yes" xml:space="preserve">
          <source>There are probably many more bugs on non-ASCII platforms (EBCDIC).</source>
          <target state="translated">비 ASCII 플랫폼 (EBCDIC)에는 더 많은 버그가있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6034cbb411ab9fcf9d496b60426633cf7c795bb5" translate="yes" xml:space="preserve">
          <source>There are quite a few systems out there that do worse!</source>
          <target state="translated">더 나쁜 시스템이 많이 있습니다!</target>
        </trans-unit>
        <trans-unit id="1d2d754395a1d1b23e17d21c745bf8aafd6b351f" translate="yes" xml:space="preserve">
          <source>There are rare cases where this package-based resolution can be a problem. If you copy a subroutine from one package to another, &lt;code&gt;SUPER&lt;/code&gt; resolution will be done based on the original package.</source>
          <target state="translated">이 패키지 기반 해상도가 문제가되는 경우는 거의 없습니다. 한 패키지에서 다른 패키지로 서브 루틴을 복사 하면 원래 패키지를 기준으로 &lt;code&gt;SUPER&lt;/code&gt; 해결이 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="af62a9f4883bfebec9e4b48e9587f48259af1d0b" translate="yes" xml:space="preserve">
          <source>There are really two tracks of perl development: a maintenance version and an experimental version. The maintenance versions are stable, and have an even number as the minor release (i.e. perl5.18.x, where 18 is the minor release). The experimental versions may include features that don't make it into the stable versions, and have an odd number as the minor release (i.e. perl5.19.x, where 19 is the minor release).</source>
          <target state="translated">펄 개발에는 실제로 유지 보수 버전과 실험 버전의 두 가지 트랙이 있습니다. 유지 관리 버전은 안정적이며 마이너 릴리스 (예 : perl5.18.x, 여기서 18은 마이너 릴리스)로 짝수입니다. 실험 버전에는 안정적인 버전으로 만들지 않고 부 버전으로 홀수 (예 : perl5.19.x, 여기서 19는 부 버전) 인 기능이 포함될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f3f1aa2e43835efb5ebefe1c81df4f88e92a3e7e" translate="yes" xml:space="preserve">
          <source>There are really two tracks of perl development: a maintenance version and an experimental version. The maintenance versions are stable, and have an even number as the minor release (i.e. perl5.24.x, where 24 is the minor release). The experimental versions may include features that don't make it into the stable versions, and have an odd number as the minor release (i.e. perl5.25.x, where 25 is the minor release).</source>
          <target state="translated">Perl 개발에는 두 가지 트랙이 있습니다 : 유지 보수 버전과 실험 버전입니다. 유지 보수 버전은 안정적이며 부 릴리스 (즉, perl5.24.x, 여기서 24는 부 릴리스)와 같은 짝수입니다. 실험 버전에는 안정 버전으로 만들지 않는 기능이 포함될 수 있으며 부 릴리스와 홀수 (즉, perl5.25.x, 여기서 25는 부 릴리스)가있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b1bf8726c4584d2c3d7eed2a3217ca6397579941" translate="yes" xml:space="preserve">
          <source>There are several I/O operators you should know about.</source>
          <target state="translated">알아야 할 몇 가지 I / O 연산자가 있습니다.</target>
        </trans-unit>
        <trans-unit id="2fda79a606c9c0725617e5e789142491b7fdc787" translate="yes" xml:space="preserve">
          <source>There are several ambiguous cases where a conversion routine cannot determine whether an input filename is in Unix format or in VMS format, since now both VMS and Unix file specifications may have characters in them that could be mistaken for syntax delimiters of the other type. So some pathnames simply cannot be used in a mode that allows either type of pathname to be present. Perl will tend to assume that an ambiguous filename is in Unix format.</source>
          <target state="translated">변환 루틴이 입력 파일 이름이 Unix 형식인지 VMS 형식인지 확인할 수없는 몇 가지 모호한 경우가 있습니다. 이제 VMS 및 Unix 파일 스펙에 다른 유형의 구문 구분 기호로 오인 될 수있는 문자가있을 수 있기 때문입니다. 따라서 일부 경로 이름은 단순히 두 가지 유형의 경로 이름을 모두 사용할 수있는 모드에서 사용할 수 없습니다. Perl은 모호한 파일 이름이 Unix 형식이라고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="83b566d12c94cc6ef80e2c552897da25fbcd52af" translate="yes" xml:space="preserve">
          <source>There are several components in CPAN.pm that use environment variables. The build tools, &lt;a href=&quot;ExtUtils::MakeMaker&quot;&gt;ExtUtils::MakeMaker&lt;/a&gt; and &lt;a href=&quot;Module::Build&quot;&gt;Module::Build&lt;/a&gt; use some, while others matter to the levels above them. Some of these are specified by the Perl Toolchain Gang:</source>
          <target state="translated">CPAN.pm에는 환경 변수를 사용하는 여러 구성 요소가 있습니다. 빌드 도구 인 &lt;a href=&quot;ExtUtils::MakeMaker&quot;&gt;ExtUtils :: MakeMaker&lt;/a&gt; 및 &lt;a href=&quot;Module::Build&quot;&gt;Module :: Build&lt;/a&gt; 는 일부를 사용하고 나머지는 상위 레벨에 중요합니다. 이들 중 일부는 Perl Toolchain Gang에 의해 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="dc2d6ce8616f44441a994dbb2d806ba6e4997805" translate="yes" xml:space="preserve">
          <source>There are several different code sets you can use for identifying countries. A code set may be specified using either a name, or a constant that is automatically exported by this module.</source>
          <target state="translated">국가를 식별하는 데 사용할 수있는 여러 가지 코드 세트가 있습니다. 코드 세트는 이름 또는이 모듈에서 자동으로 내보내는 상수를 사용하여 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="74b369e9ecdad508287761106812f2205698bcfc" translate="yes" xml:space="preserve">
          <source>There are several different code sets you can use for identifying currencies. A code set may be specified using either a name, or a constant that is automatically exported by this module.</source>
          <target state="translated">통화를 식별하는 데 사용할 수있는 여러 가지 코드 세트가 있습니다. 코드 세트는 이름 또는이 모듈에서 자동으로 내보내는 상수를 사용하여 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c5df10a209c7b9d0bd6df6a76c15e47c845b73fd" translate="yes" xml:space="preserve">
          <source>There are several different code sets you can use for identifying languages. A code set may be specified using either a name, or a constant that is automatically exported by this module.</source>
          <target state="translated">언어를 식별하는 데 사용할 수있는 여러 가지 코드 세트가 있습니다. 코드 세트는 이름 또는이 모듈에서 자동으로 내보내는 상수를 사용하여 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="357e0be22039446c2158a4027e1ee33566fa847b" translate="yes" xml:space="preserve">
          <source>There are several different code sets you can use for identifying scripts. A code set may be specified using either a name, or a constant that is automatically exported by this module.</source>
          <target state="translated">스크립트를 식별하는 데 사용할 수있는 여러 가지 코드 세트가 있습니다. 코드 세트는 이름 또는이 모듈에서 자동으로 내보내는 상수를 사용하여 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c871d77268a0e9a3faf86ba66c7adbf672f7193a" translate="yes" xml:space="preserve">
          <source>There are several escape sequences that convert characters or strings between upper and lower case, and they are also available within patterns. &lt;code&gt;\l&lt;/code&gt; and &lt;code&gt;\u&lt;/code&gt; convert the next character to lower or upper case, respectively:</source>
          <target state="translated">대소 문자를 구분하여 문자 또는 문자열을 변환하는 이스케이프 시퀀스가 ​​여러 개 있으며 패턴 내에서도 사용할 수 있습니다. &lt;code&gt;\l&lt;/code&gt; 및 &lt;code&gt;\u&lt;/code&gt; 는 다음 문자를 각각 소문자 또는 대문자로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="8dd1b15a1dbfd18df05cd02be13096a5a0b828cf" translate="yes" xml:space="preserve">
          <source>There are several functions available to specify characters and code points portably in tests. The always-preloaded functions &lt;code&gt;utf8::unicode_to_native()&lt;/code&gt; and its inverse &lt;code&gt;utf8::native_to_unicode()&lt;/code&gt; take code points and translate appropriately. The file</source>
          <target state="translated">테스트에서 문자 및 코드 포인트를 이식 가능하게 지정하는 데 사용할 수있는 몇 가지 기능이 있습니다. 항상 사전로드 된 함수 &lt;code&gt;utf8::unicode_to_native()&lt;/code&gt; 및 그 역 &lt;code&gt;utf8::native_to_unicode()&lt;/code&gt; 는 코드 포인트를 가져와 적절하게 변환합니다. 파일</target>
        </trans-unit>
        <trans-unit id="324d2fa183413ecef672812d1ff51b1b76337a11" translate="yes" xml:space="preserve">
          <source>There are several great resources for locating workshops: the &lt;a href=&quot;#Websites&quot;&gt;websites&lt;/a&gt; mentioned above, the &lt;a href=&quot;#Calendar-of-Perl-Events&quot;&gt;calendar&lt;/a&gt; mentioned below, and the YAPC Europe website, &lt;a href=&quot;http://www.yapceurope.org/&quot;&gt;http://www.yapceurope.org/&lt;/a&gt;, which is probably the best resource for European Perl events.</source>
          <target state="translated">워크샵을 찾을 수있는 훌륭한 자료가 몇 가지 있습니다 : 위에서 언급 한 &lt;a href=&quot;#Websites&quot;&gt;웹 사이트&lt;/a&gt; , 아래에 언급 된 &lt;a href=&quot;#Calendar-of-Perl-Events&quot;&gt;캘린더&lt;/a&gt; , YAPC Europe 웹 사이트 &lt;a href=&quot;http://www.yapceurope.org/&quot;&gt;http://www.yapceurope.org/&lt;/a&gt; 는 아마도 유럽 펄 행사를위한 최고의 자료입니다.</target>
        </trans-unit>
        <trans-unit id="832a8879ea071712935214efe0cfd19085976c3b" translate="yes" xml:space="preserve">
          <source>There are several of these, which are equivalents, using the &lt;code&gt;\p{}&lt;/code&gt; notation, for Posix classes and are described in &lt;a href=&quot;perlrecharclass#POSIX-Character-Classes&quot;&gt;&quot;POSIX Character Classes&quot; in perlrecharclass&lt;/a&gt;.</source>
          <target state="translated">Posix 클래스에 대해 &lt;code&gt;\p{}&lt;/code&gt; 표기법을 사용하는 등가물 이 &lt;a href=&quot;perlrecharclass#POSIX-Character-Classes&quot;&gt;있으며 perlrecharclass의 &quot;POSIX 문자 클래스&quot;에&lt;/a&gt; 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="70817f22a3f6a9efb5f508894682105db2aa6387" translate="yes" xml:space="preserve">
          <source>There are several of these, which are equivalents, using the &lt;code&gt;\p{}&lt;/code&gt; notation, for Posix classes and are described in &lt;a href=&quot;perlrecharclass#POSIX-Character-Classes&quot;&gt;POSIX Character Classes in perlrecharclass&lt;/a&gt;.</source>
          <target state="translated">Posix 클래스에 대해 &lt;code&gt;\p{}&lt;/code&gt; 표기법을 사용하는 동등한 몇 가지가 &lt;a href=&quot;perlrecharclass#POSIX-Character-Classes&quot;&gt;있으며 perlrecharclass의 POSIX 문자 클래스에&lt;/a&gt; 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="f33ad2d3a2c17446bc61c87b03a2741b5207b2ef" translate="yes" xml:space="preserve">
          <source>There are several of these, which are the standard Posix classes extended to the full Unicode range. They are described in &lt;a href=&quot;perlrecharclass#POSIX-Character-Classes&quot;&gt;&quot;POSIX Character Classes&quot; in perlrecharclass&lt;/a&gt;.</source>
          <target state="translated">이들 중 일부는 전체 유니 코드 범위로 확장 된 표준 Posix 클래스입니다. &lt;a href=&quot;perlrecharclass#POSIX-Character-Classes&quot;&gt;perlrecharclass의 &quot;POSIX 문자 클래스&quot;에&lt;/a&gt; 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="1f83d1183ceda85cce3fcdc239963f72e745557e" translate="yes" xml:space="preserve">
          <source>There are several of these, which are the standard Posix classes extended to the full Unicode range. They are described in &lt;a href=&quot;perlrecharclass#POSIX-Character-Classes&quot;&gt;POSIX Character Classes in perlrecharclass&lt;/a&gt;.</source>
          <target state="translated">이 중 몇 가지는 표준 Posix 클래스가 전체 유니 코드 범위로 확장되어 있습니다. &lt;a href=&quot;perlrecharclass#POSIX-Character-Classes&quot;&gt;perlrecharclass의 POSIX 문자 클래스에&lt;/a&gt; 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="ff60b9f3f7c3df35d25431cc4664ba95f5cce4d6" translate="yes" xml:space="preserve">
          <source>There are several types of character class tests that Perl implements. The only ones described here are those that directly correspond to C library functions that operate on 8-bit characters, but there are equivalents that operate on wide characters, and UTF-8 encoded strings. All are more fully described in &lt;a href=&quot;perlapi#Character-classification&quot;&gt;&quot;Character classification&quot; in perlapi&lt;/a&gt; and &lt;a href=&quot;perlapi#Character-case-changing&quot;&gt;&quot;Character case changing&quot; in perlapi&lt;/a&gt;.</source>
          <target state="translated">Perl이 구현하는 몇 가지 유형의 문자 클래스 테스트가 있습니다. 여기에 설명 된 유일한 항목은 8 비트 문자에서 작동하는 C 라이브러리 함수에 직접 해당하는 항목이지만 와이드 문자 및 UTF-8 인코딩 문자열에서 작동하는 동등한 항목이 있습니다. 모두 &lt;a href=&quot;perlapi#Character-classification&quot;&gt;perlapi의 &quot;문자 분류&quot;&lt;/a&gt; 및 perlapi의 &lt;a href=&quot;perlapi#Character-case-changing&quot;&gt;&quot;문자 대소 문자 변경&quot;에 자세히 설명되어&lt;/a&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="e3db56f779a367ad8451b62021cf957e6240bc01" translate="yes" xml:space="preserve">
          <source>There are several types of character class tests that Perl implements. The only ones described here are those that directly correspond to C library functions that operate on 8-bit characters, but there are equivalents that operate on wide characters, and UTF-8 encoded strings. All are more fully described in &lt;a href=&quot;perlapi#Character-classification&quot;&gt;Character classification in perlapi&lt;/a&gt; and &lt;a href=&quot;perlapi#Character-case-changing&quot;&gt;Character case changing in perlapi&lt;/a&gt;.</source>
          <target state="translated">Perl이 구현하는 몇 가지 유형의 문자 클래스 테스트가 있습니다. 여기에 설명 된 유일한 것은 8 비트 문자에서 작동하는 C 라이브러리 함수에 직접 대응하지만 와이드 문자 및 UTF-8로 인코딩 된 문자열에서 작동하는 동등한 기능이 있습니다. 모두 &lt;a href=&quot;perlapi#Character-classification&quot;&gt;perlapi의 문자 분류&lt;/a&gt; 및 perlapi의 &lt;a href=&quot;perlapi#Character-case-changing&quot;&gt;문자 대소 문자 변경에&lt;/a&gt; 더 자세히 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="f2e0a93aaf35e3ad5cd5182c4904a3f139cb368f" translate="yes" xml:space="preserve">
          <source>There are several ways to call the debugger:</source>
          <target state="translated">디버거를 호출하는 방법에는 여러 가지가 있습니다.</target>
        </trans-unit>
        <trans-unit id="e8db18a3a166163bfb23804a9a1202e4ece1bc54" translate="yes" xml:space="preserve">
          <source>There are several ways to wrap your Perl scripts in DCL</source>
          <target state="translated">DCL에서 Perl 스크립트를 래핑하는 몇 가지 방법이 있습니다</target>
        </trans-unit>
        <trans-unit id="9d4463c6ded942fe4cd0ec81ef54653fbdb5493c" translate="yes" xml:space="preserve">
          <source>There are some bugs in the &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt;/&lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt;&lt;code&gt;&quot;U0&quot;&lt;/code&gt; template</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; / &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; &lt;code&gt;&quot;U0&quot;&lt;/code&gt; 템플릿에 버그가 있습니다</target>
        </trans-unit>
        <trans-unit id="5363960c51ded4425aac0c5e8d1bf8c47e9bafcf" translate="yes" xml:space="preserve">
          <source>There are some cases where Perl can't immediately tell the difference between an expression and a statement. For instance, the syntax for a block and an anonymous hash reference constructor look the same unless there's something in the braces to give Perl a hint. The ellipsis is a syntax error if Perl doesn't guess that the &lt;code&gt;{ ... }&lt;/code&gt; is a block. In that case, it doesn't think the &lt;code&gt;...&lt;/code&gt; is an ellipsis because it's expecting an expression instead of a statement:</source>
          <target state="translated">Perl이 표현식과 명령문의 차이점을 즉시 알 수없는 경우가 있습니다. 예를 들어 블록에 대한 구문과 익명 해시 참조 생성자는 괄호에 Perl에 힌트를 제공 할 내용이없는 한 동일하게 보입니다. Perl이 &lt;code&gt;{ ... }&lt;/code&gt; 가 블록 이라고 생각하지 않으면 생략 부호는 구문 오류 입니다. 이 경우, 문이 아닌 표현식을 기대하기 때문에 &lt;code&gt;...&lt;/code&gt; 이 줄임표 라고 생각하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="56b7755399d4ee6979402a39fa3144930c83cfee" translate="yes" xml:space="preserve">
          <source>There are some cases where Perl can't immediately tell the difference between an expression and a statement. For instance, the syntax for a block and an anonymous hash reference constructor look the same unless there's something in the braces to give Perl a hint. The ellipsis is a syntax error if Perl doesn't guess that the &lt;code&gt;{ ... }&lt;/code&gt; is a block. Inside your block, you can use a &lt;code&gt;;&lt;/code&gt; before the ellipsis to denote that the &lt;code&gt;{ ... }&lt;/code&gt; is a block and not a hash reference constructor.</source>
          <target state="translated">Perl이 표현식과 명령문의 차이를 즉시 알 수없는 경우가 있습니다. 예를 들어, 블록 및 익명 해시 참조 생성자의 구문은 중괄호 안에 Perl에 힌트를 제공하는 것이 없으면 동일하게 보입니다. Perl이 &lt;code&gt;{ ... }&lt;/code&gt; 가 블록 이라고 추측하지 않으면 생략 부호는 구문 오류 입니다. 블록 내에서 &lt;code&gt;;&lt;/code&gt; 줄임표 앞에 &lt;code&gt;{ ... }&lt;/code&gt; 가 블록이고 해시 참조 생성자가 아님 을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="83d390e2b6c3127ccfec700a0a95db3ede4e9652" translate="yes" xml:space="preserve">
          <source>There are some caveats with the use of runtime statements like &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt; Exporter&lt;/code&gt; and the assignment to package variables, which can be very subtle for the unaware programmer. This may happen for instance with mutually recursive modules, which are affected by the time the relevant constructions are executed.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt; Exporter&lt;/code&gt; 와 같은 런타임 문을 사용 하고 변수를 패키지로 할당하는 것과 같은 몇 가지주의 사항 이 있습니다. 예를 들어 상호 재귀 모듈에서 발생할 수 있으며, 이는 관련 구성이 실행되는 시간에 영향을받습니다.</target>
        </trans-unit>
        <trans-unit id="4f5521a0adc9e1424f0db1d5eef9bf6747b3a1ab" translate="yes" xml:space="preserve">
          <source>There are some caveats with the use of runtime statements like &lt;code&gt;require Exporter&lt;/code&gt; and the assignment to package variables, which can be very subtle for the unaware programmer. This may happen for instance with mutually recursive modules, which are affected by the time the relevant constructions are executed.</source>
          <target state="translated">&lt;code&gt;require Exporter&lt;/code&gt; 및 패키지 변수에 대한 할당과 같은 런타임 문 사용에 대한 몇 가지주의 사항 이 있습니다. 이는 알지 못하는 프로그래머에게는 매우 미묘 할 수 있습니다. 예를 들어, 관련 구성이 실행되는 시간에 영향을받는 상호 재귀 모듈에서 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="344f93501dc28c704b9a2e67faf75c375217d583" translate="yes" xml:space="preserve">
          <source>There are some complications that are ignored in the examples above:</source>
          <target state="translated">위의 예에서 무시되는 몇 가지 합병증이 있습니다.</target>
        </trans-unit>
        <trans-unit id="9d05d692911a48f923ff823586f7db33a368c559" translate="yes" xml:space="preserve">
          <source>There are some convenience functions available that can help with the destruction of xVs. These functions introduce the concept of &quot;mortality&quot;. An xV that is mortal has had its reference count marked to be decremented, but not actually decremented, until &quot;a short time later&quot;. Generally the term &quot;short time later&quot; means a single Perl statement, such as a call to an XSUB function. The actual determinant for when mortal xVs have their reference count decremented depends on two macros, SAVETMPS and FREETMPS. See &lt;a href=&quot;perlcall&quot;&gt;perlcall&lt;/a&gt; and &lt;a href=&quot;perlxs&quot;&gt;perlxs&lt;/a&gt; for more details on these macros.</source>
          <target state="translated">xV 파괴에 도움이되는 몇 가지 편리한 기능이 있습니다. 이러한 기능은 &quot;사망률&quot;이라는 개념을 소개합니다. 필멸의 xV는 참조 카운트가 감소한 것으로 표시되었지만 &quot;짧은 시간&quot;까지 실제로 감소하지는 않았습니다. 일반적으로 &quot;짧은 시간&quot;이라는 용어는 XSUB 함수 호출과 같은 단일 Perl 문을 의미합니다. 필사자 xV의 참조 카운트가 감소 할 때의 실제 결정 요인은 SAVETMPS 및 FREETMPS의 두 매크로에 따라 다릅니다. 이 매크로에 대한 자세한 내용 은 &lt;a href=&quot;perlcall&quot;&gt;perlcall&lt;/a&gt; 및 &lt;a href=&quot;perlxs&quot;&gt;perlxs&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="0d7095e4177705611245878da2c1cd341f565d3b" translate="yes" xml:space="preserve">
          <source>There are some convenience functions available that can help with the destruction of xVs. These functions introduce the concept of &quot;mortality&quot;. Much documentation speaks of an xV itself being mortal, but this is misleading. It is really</source>
          <target state="translated">xV의 파괴에 도움이 될 수있는 몇 가지 편의 기능이 있습니다. 이러한 기능은 &quot;사망&quot;의 개념을 소개합니다. 많은 문서에서 xV 자체가 치명적이라고 말하지만 이것은 오해의 소지가 있습니다. 정말입니다</target>
        </trans-unit>
        <trans-unit id="0aad51f0e11a34d98334dfd8a5325d2defc4e5c1" translate="yes" xml:space="preserve">
          <source>There are some different considerations for each form:</source>
          <target state="translated">각 양식에 대해 몇 가지 다른 고려 사항이 있습니다.</target>
        </trans-unit>
        <trans-unit id="34b9699f0d3b28a88deb2c4c365035a0647ae160" translate="yes" xml:space="preserve">
          <source>There are some difficulties in using the tied hash interface if you want to manipulate a BTREE database with duplicate keys. Consider this code:</source>
          <target state="translated">중복 키로 BTREE 데이터베이스를 조작하려는 경우 연결된 해시 인터페이스를 사용하는 데 약간의 어려움이 있습니다. 이 코드를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="c09cd4cd0008c42a9eb3710539a1c18a01958eae" translate="yes" xml:space="preserve">
          <source>There are some downsides here: the size economy will not stand at runtime after this &lt;code&gt;init()&lt;/code&gt; runs. But it should not be that critical, since if you don't have space for that, you won't have space for any other language besides the main one as well. You could do that too with ties, expanding the value at lookup time which should be more time expensive as an option.</source>
          <target state="translated">여기에는 몇 가지 단점이 있습니다. 크기 경제는이 &lt;code&gt;init()&lt;/code&gt; 가 실행 된 후 런타임에 유지되지 않습니다 . 하지만 그다지 중요하지 않습니다. 공간이 없다면 기본 언어 외에 다른 언어를위한 공간도 없기 때문입니다. 옵션으로 더 많은 시간이 소요되는 조회 시간에 값을 확장하여 넥타이로도 그렇게 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c652dbfd06883d908b23bc1bfea111a0463399a9" translate="yes" xml:space="preserve">
          <source>There are some drawbacks to this approach. One is that any extension which calls any file-manipulating C function will need to be recompiled (just follow the usual &quot;perl Makefile.PL; make; make test; make install&quot; procedure).</source>
          <target state="translated">이 방법에는 몇 가지 단점이 있습니다. 하나는 파일 조작 C 함수를 호출하는 확장명을 재 컴파일해야한다는 것입니다 (일반적인 &quot;perl Makefile.PL; make; 테스트; make 설치&quot;절차를 따르십시오).</target>
        </trans-unit>
        <trans-unit id="9cd4d89394373d1a964c062cbd37f2a471efcbee" translate="yes" xml:space="preserve">
          <source>There are some locale-related library calls that still aren't thread-safe because they return data in a buffer global to all threads. In the past, these didn't matter as locales weren't thread-safe at all. But now you have to be aware of them in case your module is called in a multi-threaded application. The known ones are</source>
          <target state="translated">모든 스레드에 대한 전역 버퍼의 데이터를 반환하기 때문에 여전히 스레드로부터 안전하지 않은 로케일 관련 라이브러리 호출이 있습니다. 과거에는 로케일이 스레드로부터 전혀 안전하지 않았기 때문에 이것들은 중요하지 않았습니다. 그러나 이제 모듈이 다중 스레드 응용 프로그램에서 호출되는 경우이를 알고 있어야합니다. 알려진 것들은</target>
        </trans-unit>
        <trans-unit id="0b359481d6fbdc6a6a4b31621c42bd37e3d7940e" translate="yes" xml:space="preserve">
          <source>There are some obvious disadvantages with this technique.</source>
          <target state="translated">이 기술에는 몇 가지 명백한 단점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="5ca89f8811d4cbda81105708f26c4da2bc407dd8" translate="yes" xml:space="preserve">
          <source>There are some optional options you can pass to &lt;code&gt;memoize&lt;/code&gt; to change the way it behaves a little. To supply options, invoke &lt;code&gt;memoize&lt;/code&gt; like this:</source>
          <target state="translated">동작 방식을 변경 하기 위해 &lt;code&gt;memoize&lt;/code&gt; 할 수있는 옵션 옵션이 있습니다 . 옵션을 제공하려면 다음과 같이 &lt;code&gt;memoize&lt;/code&gt; 를 호출 하십시오.</target>
        </trans-unit>
        <trans-unit id="94c539cef62e9aa25e310b57bc5c00ca12ad3ddb" translate="yes" xml:space="preserve">
          <source>There are some shortcuts for oneliners; see &lt;a href=&quot;perlrun#-C-%5Bnumber%2Flist%5D&quot;&gt;-C in perlrun&lt;/a&gt;.</source>
          <target state="translated">oneliner에 대한 몇 가지 지름길이 있습니다. &lt;a href=&quot;perlrun#-C-%5Bnumber%2Flist%5D&quot;&gt;perlrun의 -C를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="362784bb7e407303367ae06c7f4d21b101719adc" translate="yes" xml:space="preserve">
          <source>There are some shortcuts for oneliners; see &lt;a href=&quot;perlrun#-C-%5bnumber%2flist%5d&quot;&gt;-C&lt;/a&gt; in &lt;a href=&quot;perlrun&quot;&gt;perlrun&lt;/a&gt;.</source>
          <target state="translated">oneliners에 대한 몇 가지 지름길이 있습니다. &lt;a href=&quot;perlrun&quot;&gt;perlrun&lt;/a&gt; 에서 &lt;a href=&quot;perlrun#-C-%5bnumber%2flist%5d&quot;&gt;-C&lt;/a&gt; 참조 .</target>
        </trans-unit>
        <trans-unit id="242b6f00a4806779b2651b44eef8a2d396dd9333" translate="yes" xml:space="preserve">
          <source>There are some special instructions for building Perl with Sun Studio on Linux. Following the normal &lt;code&gt;Configure&lt;/code&gt;, you have to run make as follows:</source>
          <target state="translated">Linux에서 Sun Studio로 Perl을 빌드하기위한 몇 가지 특별한 지침이 있습니다. 일반적인 &lt;code&gt;Configure&lt;/code&gt; 에 따라 다음과 같이 make를 실행해야합니다.</target>
        </trans-unit>
        <trans-unit id="eb6709b6148bb02040a39a95e98f282835dfc33f" translate="yes" xml:space="preserve">
          <source>There are some warnings with respect to malformed hyperlinks:</source>
          <target state="translated">잘못된 하이퍼 링크와 관련하여 몇 가지 경고가 있습니다.</target>
        </trans-unit>
        <trans-unit id="ce8df6ad608907441859c0c720df59bd6834bb9d" translate="yes" xml:space="preserve">
          <source>There are still many places where Unicode (in some encoding or another) could be given as arguments or received as results, or both in Perl, but it is not, in spite of Perl having extensive ways to input and output in Unicode, and a few other &quot;entry points&quot; like the &lt;code&gt;@ARGV&lt;/code&gt; array (which can sometimes be interpreted as UTF-8).</source>
          <target state="translated">유니 코드 (일부 인코딩 또는 다른 인코딩)가 인수로 주어 지거나 결과로 또는 Perl 둘 다로 수신 될 수있는 곳이 여전히 많이 있지만, Perl이 유니 코드로 입력 및 출력하는 광범위한 방법에도 불구하고 그렇지는 않습니다. &lt;code&gt;@ARGV&lt;/code&gt; 와 같은 다른 &quot;진입 점&quot; 배열 (UTF-8로 해석 될 수 있음) .</target>
        </trans-unit>
        <trans-unit id="59db2905dffb1315acaf3a1dc211ceadeec4d5cb" translate="yes" xml:space="preserve">
          <source>There are three Command Line flags that can be used to control when warnings are (or aren't) produced:</source>
          <target state="translated">경고가 생성되거나 생성되지 않는시기를 제어하는 ​​데 사용할 수있는 세 가지 명령 줄 플래그가 있습니다.</target>
        </trans-unit>
        <trans-unit id="10489a4543147a152f672e9c6f67f2c24de29afb" translate="yes" xml:space="preserve">
          <source>There are three basic ways of running external commands:</source>
          <target state="translated">외부 명령을 실행하는 세 가지 기본 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="ee1484d5257f2915d554120f4ce6bfb497ce1d27" translate="yes" xml:space="preserve">
          <source>There are three basic ways that you can structure a threaded program. Which model you choose depends on what you need your program to do. For many non-trivial threaded programs, you'll need to choose different models for different pieces of your program.</source>
          <target state="translated">스레드 프로그램을 구성 할 수있는 세 가지 기본 방법이 있습니다. 어떤 모델을 선택해야하는지 프로그램에 따라 다릅니다. 사소하지 않은 많은 스레드 프로그램의 경우 프로그램의 다른 부분에 대해 다른 모델을 선택해야합니다.</target>
        </trans-unit>
        <trans-unit id="7fc3fd61896b5d12698d6fdcfdceea06c9dc86a3" translate="yes" xml:space="preserve">
          <source>There are three distinct concepts of &quot;next&quot; in the regex engine, and it is important to keep them clear.</source>
          <target state="translated">정규식 엔진에는 &quot;다음&quot;이라는 세 가지 고유 한 개념이 있으며 명확하게 유지하는 것이 중요합니다.</target>
        </trans-unit>
        <trans-unit id="95aff53d816fd931550c2a4895fd2449f30b17c2" translate="yes" xml:space="preserve">
          <source>There are three popular ways to avoid this overhead. One solution involves running the Apache HTTP server (available from &lt;a href=&quot;http://www.apache.org/&quot;&gt;http://www.apache.org/&lt;/a&gt; ) with either of the mod_perl or mod_fastcgi plugin modules.</source>
          <target state="translated">이 오버 헤드를 피하기 위해 널리 사용되는 세 가지 방법이 있습니다. 한 가지 해결책은 mod_perl 또는 mod_fastcgi 플러그인 모듈 중 하나를 사용하여 Apache HTTP 서버 ( &lt;a href=&quot;http://www.apache.org/&quot;&gt;http://www.apache.org/&lt;/a&gt; 에서 사용 가능)를 실행하는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="99df9d7a05fef99c9f9af3d138353a09ea2aa37e" translate="yes" xml:space="preserve">
          <source>There are three types of character classes in Perl regular expressions: the dot, backslash sequences, and the form enclosed in square brackets. Keep in mind, though, that often the term &quot;character class&quot; is used to mean just the bracketed form. Certainly, most Perl documentation does that.</source>
          <target state="translated">Perl 정규식에는 3 가지 유형의 문자 클래스가 있습니다 : 점, 백 슬래시 시퀀스 및 대괄호로 묶인 형식. 그러나 종종 &quot;캐릭터 클래스&quot;라는 용어는 대괄호 형식을 의미하는 데 사용됩니다. 확실히, 대부분의 Perl 문서는 그렇게합니다.</target>
        </trans-unit>
        <trans-unit id="a78a1c3edbdc828e2c5469275355a4d4c1a4e525" translate="yes" xml:space="preserve">
          <source>There are three ways to do this. First, the easy but inefficient way, which is also the default, in order to maintain source compatibility with extensions: whenever</source>
          <target state="translated">이를 수행하는 세 가지 방법이 있습니다. 첫째, 확장과의 소스 호환성을 유지하기 위해 쉽고 효율적이지 않은 방법 (기본값)</target>
        </trans-unit>
        <trans-unit id="95c05fa69dfba88648a1ac130ade8afd3e3bcc34" translate="yes" xml:space="preserve">
          <source>There are three ways to write a test in the core: &lt;a href=&quot;Test::More&quot;&gt;Test::More&lt;/a&gt;,</source>
          <target state="translated">핵심에서 테스트를 작성하는 세 가지 방법이 있습니다. &lt;a href=&quot;Test::More&quot;&gt;Test :: More&lt;/a&gt; ,</target>
        </trans-unit>
        <trans-unit id="7d88ffa178365fa0703151483456030669a9d8af" translate="yes" xml:space="preserve">
          <source>There are three ways to write a test in the core: &lt;a href=&quot;test/more&quot;&gt;Test::More&lt;/a&gt;,</source>
          <target state="translated">핵심 테스트를 작성하는 세 가지 방법이 있습니다 : &lt;a href=&quot;test/more&quot;&gt;Test :: More&lt;/a&gt; ,</target>
        </trans-unit>
        <trans-unit id="1233ca5594cc5aa5bc69145748e72c13824fb763" translate="yes" xml:space="preserve">
          <source>There are three ways to write your own source filter. You can write it in C, use an external program as a filter, or write the filter in Perl. I won't cover the first two in any great detail, so I'll get them out of the way first. Writing the filter in Perl is most convenient, so I'll devote the most space to it.</source>
          <target state="translated">자신의 소스 필터를 작성하는 세 가지 방법이 있습니다. C로 작성하거나 외부 프로그램을 필터로 사용하거나 Perl에서 필터를 작성할 수 있습니다. 처음 두 부분은 자세하게 다루지 않으므로 먼저 두 가지 방법을 알아 보겠습니다. Perl에서 필터를 작성하는 것이 가장 편리하므로 가장 많은 공간을 할당 할 것입니다.</target>
        </trans-unit>
        <trans-unit id="4d1ca307ab6382d572650b48515269fd5ebc805c" translate="yes" xml:space="preserve">
          <source>There are times when you may find it useful to have a thread explicitly give up the CPU to another thread. You may be doing something processor-intensive and want to make sure that the user-interface thread gets called frequently. Regardless, there are times that you might want a thread to give up the processor.</source>
          <target state="translated">스레드가 CPU를 다른 스레드에 명시 적으로 포기하도록하는 것이 유용한 경우가 있습니다. 프로세서를 많이 사용하고 사용자 인터페이스 스레드가 자주 호출되도록 할 수 있습니다. 어쨌든 스레드가 프로세서를 포기하기를 원할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="aabf4548dd9ce503cb7793127ff7d0d6ca4a9258" translate="yes" xml:space="preserve">
          <source>There are two basic modes of operation (plus turning if off):</source>
          <target state="translated">두 가지 기본 작동 모드가 있습니다 (플러스를 끄면 끄는 것).</target>
        </trans-unit>
        <trans-unit id="a13ac870bbe694381404312541ad897bb1c7bfff" translate="yes" xml:space="preserve">
          <source>There are two callbacks, &lt;code&gt;named_buff&lt;/code&gt; is called in all the cases the FETCH, STORE, DELETE, CLEAR, EXISTS and SCALAR &lt;a href=&quot;Tie::Hash&quot;&gt;Tie::Hash&lt;/a&gt; callbacks would be on changes to &lt;code&gt;%+&lt;/code&gt; and &lt;code&gt;%-&lt;/code&gt; and &lt;code&gt;named_buff_iter&lt;/code&gt; in the same cases as FIRSTKEY and NEXTKEY.</source>
          <target state="translated">두 개의 콜백이 있습니다. &lt;code&gt;named_buff&lt;/code&gt; 는 모든 경우에 호출됩니다. FETCH, STORE, DELETE, CLEAR, EXISTS 및 SCALAR &lt;a href=&quot;Tie::Hash&quot;&gt;Tie :: Hash&lt;/a&gt; 콜백은 FIRSTKEY 및 NEXTKEY와 동일한 경우 에 &lt;code&gt;%+&lt;/code&gt; 및 &lt;code&gt;%-&lt;/code&gt; 및 &lt;code&gt;named_buff_iter&lt;/code&gt; 로 변경됩니다 .</target>
        </trans-unit>
        <trans-unit id="53b9f0a36cbfc725453b6b4804987d2d7a53bc2c" translate="yes" xml:space="preserve">
          <source>There are two callbacks, &lt;code&gt;named_buff&lt;/code&gt; is called in all the cases the FETCH, STORE, DELETE, CLEAR, EXISTS and SCALAR &lt;a href=&quot;tie/hash&quot;&gt;Tie::Hash&lt;/a&gt; callbacks would be on changes to &lt;code&gt;%+&lt;/code&gt; and &lt;code&gt;%-&lt;/code&gt; and &lt;code&gt;named_buff_iter&lt;/code&gt; in the same cases as FIRSTKEY and NEXTKEY.</source>
          <target state="translated">두 콜백 있습니다 &lt;code&gt;named_buff&lt;/code&gt; 가 CLEAR, 삭제, 저장을 FETCH 모든 경우에 호출이 존재하고 SCALAR &lt;a href=&quot;tie/hash&quot;&gt;타이 :: 해시&lt;/a&gt; 콜백 변경에있을 것입니다 &lt;code&gt;%+&lt;/code&gt; 와 &lt;code&gt;%-&lt;/code&gt; 과 &lt;code&gt;named_buff_iter&lt;/code&gt; FIRSTKEY 및 NEXTKEY과 같은 경우이다.</target>
        </trans-unit>
        <trans-unit id="85a26ce9bc0772a2a092df698289266d1f10ecae" translate="yes" xml:space="preserve">
          <source>There are two cases, multi-byte and single-byte locales. First multi-byte:</source>
          <target state="translated">다중 바이트 및 단일 바이트 로케일의 두 가지 경우가 있습니다. 첫 멀티 바이트 :</target>
        </trans-unit>
        <trans-unit id="3f6e50ca71fb9ef8a58634080d592b643d6be431" translate="yes" xml:space="preserve">
          <source>There are two cases:</source>
          <target state="translated">두 가지 경우가 있습니다.</target>
        </trans-unit>
        <trans-unit id="c07255028b3b5bd9a90385fc5c125ed8062cb54e" translate="yes" xml:space="preserve">
          <source>There are two commonly used techniques of profiling executables:</source>
          <target state="translated">실행 파일을 프로파일 링하는 데 일반적으로 사용되는 두 가지 기술이 있습니다.</target>
        </trans-unit>
        <trans-unit id="ca79bf7ca29122cb03591230567965097d73b502" translate="yes" xml:space="preserve">
          <source>There are two different types of version objects, corresponding to the two different styles of versions in use:</source>
          <target state="translated">사용중인 두 가지 버전의 스타일에 해당하는 두 가지 유형의 버전 객체가 있습니다.</target>
        </trans-unit>
        <trans-unit id="4918f14b7918995ede690de784e45ce5b334a99c" translate="yes" xml:space="preserve">
          <source>There are two distinctive features of the dyna-linking model of OS/2: first, all the references to external functions are resolved at the compile time; second, there is no runtime fixup of the DLLs after they are loaded into memory. The first feature is an enormous advantage over other models: it avoids conflicts when several DLLs used by an application export entries with the same name. In such cases &quot;other&quot; models of dyna-linking just choose between these two entry points using some random criterion - with predictable disasters as results. But it is the second feature which requires the build of</source>
          <target state="translated">OS / 2의 dyna-linking 모델에는 두 가지 특징이 있습니다. 첫째, 외부 함수에 대한 모든 참조는 컴파일시 해결됩니다. 둘째, DLL이 메모리에로드 된 후에는 런타임의 수정이 없습니다. 첫 번째 기능은 다른 모델보다 큰 이점입니다. 응용 프로그램에서 사용하는 여러 DLL이 동일한 이름의 항목을 내보낼 때 충돌을 피합니다. 그러한 경우에, 다이너-링크의 &quot;다른&quot;모델은 예측 가능한 재난을 결과로하여 임의의 기준을 사용하여이 두 진입 점 중에서 선택합니다. 그러나 두 번째 기능은</target>
        </trans-unit>
        <trans-unit id="b851bdf3c81b8784e2dddc6e20b8e6c18978a571" translate="yes" xml:space="preserve">
          <source>There are two exit points from the inner uncompression loop.</source>
          <target state="translated">내부 비 압축 루프에는 2 개의 출구 점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="108b59b47c97316f062b5266aff655788506a06e" translate="yes" xml:space="preserve">
          <source>There are two forms of octal escapes. Each is used to specify a character by its code point specified in octal notation.</source>
          <target state="translated">두 가지 형태의 8 진 탈출이 있습니다. 각각 8 진수 표기법으로 지정된 코드 포인트로 문자를 지정하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="172fa4a9b4de533e56c4707adea17699b11d4a1b" translate="yes" xml:space="preserve">
          <source>There are two important points to remember:</source>
          <target state="translated">기억해야 할 두 가지 중요한 사항이 있습니다.</target>
        </trans-unit>
        <trans-unit id="ef6d3355d6294c0400eecec7ab06563e8c2ddc8b" translate="yes" xml:space="preserve">
          <source>There are two keys with a special meaning in the hash: &quot;read&quot; and &quot;write&quot;. These contain packlist files. After the copying is done, install() will write the list of target files to $from_to{write}. If $from_to{read} is given the contents of this file will be merged into the written file. The read and the written file may be identical, but on AFS it is quite likely that people are installing to a different directory than the one where the files later appear.</source>
          <target state="translated">해시에는 &quot;읽기&quot;와 &quot;쓰기&quot;라는 두 가지 키가 있습니다. 여기에는 팩리스트 파일이 포함됩니다. 복사가 완료되면 install ()은 대상 파일 목록을 $ from_to {write}에 기록합니다. $ from_to {read}가 제공되면이 파일의 내용이 작성된 파일로 병합됩니다. 읽은 파일과 쓴 파일은 동일 할 수 있지만 AFS에서는 사람들이 파일이 나중에 나타나는 디렉토리와 다른 디렉토리에 설치하고있을 가능성이 큽니다.</target>
        </trans-unit>
        <trans-unit id="127794821c87aa3c1561f9022c74d909b021fad3" translate="yes" xml:space="preserve">
          <source>There are two main ways that contexts are popped. During normal execution as scopes are exited, functions like &lt;code&gt;pp_leave&lt;/code&gt;, &lt;code&gt;pp_leaveloop&lt;/code&gt; and &lt;code&gt;pp_leavesub&lt;/code&gt; process and pop just one context using &lt;code&gt;cx_popfoo&lt;/code&gt; and &lt;code&gt;cx_popblock&lt;/code&gt;. On the other hand, things like &lt;code&gt;pp_return&lt;/code&gt; and &lt;code&gt;next&lt;/code&gt; may have to pop back several scopes until a sub or loop context is found, and exceptions (such as &lt;code&gt;die&lt;/code&gt;) need to pop back contexts until an eval context is found. Both of these are accomplished by &lt;code&gt;dounwind()&lt;/code&gt;, which is capable of processing and popping all contexts above the target one.</source>
          <target state="translated">컨텍스트를 표시하는 두 가지 주요 방법이 있습니다. 범위가 종료되면 정상적인 실행 중에 &lt;code&gt;pp_leave&lt;/code&gt; , &lt;code&gt;pp_leaveloop&lt;/code&gt; 및 &lt;code&gt;pp_leavesub&lt;/code&gt; 프로세스와 같은 기능을 수행하고 &lt;code&gt;cx_popfoo&lt;/code&gt; 및 &lt;code&gt;cx_popblock&lt;/code&gt; 을 사용하여 하나의 컨텍스트 만 팝 합니다. 반면에 &lt;code&gt;pp_return&lt;/code&gt; 및 &lt;code&gt;next&lt;/code&gt; 같은 것은 하위 또는 루프 컨텍스트를 찾을 때까지 여러 범위를 팝해야 할 수 있으며 예외 (예 : &lt;code&gt;die&lt;/code&gt; )는 평가 컨텍스트를 찾을 때까지 컨텍스트를 팝해야합니다. 이 두 가지 모두 &lt;code&gt;dounwind()&lt;/code&gt; 의해 수행되며 대상 컨텍스트 위의 모든 컨텍스트를 처리하고 팝할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f06480546f8f7593dd6ae9d9e44d7bf0995b966a" translate="yes" xml:space="preserve">
          <source>There are two new display parameters.</source>
          <target state="translated">두 가지 새로운 디스플레이 매개 변수가 있습니다.</target>
        </trans-unit>
        <trans-unit id="3c86f1c0ffd1daa198d3368c1af9e850c8735019" translate="yes" xml:space="preserve">
          <source>There are two operands, but no operator giving how you want to combine them.</source>
          <target state="translated">두 개의 피연산자가 있지만 결합 방법을 제공하는 연산자는 없습니다.</target>
        </trans-unit>
        <trans-unit id="24dc61084886e44e27660b4a97166077845b5c95" translate="yes" xml:space="preserve">
          <source>There are two package separators in Perl: A double colon (&lt;code&gt;::&lt;/code&gt; ) and a single quote (&lt;code&gt;'&lt;/code&gt;). Normal identifiers can start or end with a double colon, and can contain several parts delimited by double colons. Single quotes have similar rules, but with the exception that they are not legal at the end of an identifier: That is, &lt;code&gt;$'foo&lt;/code&gt; and &lt;code&gt;$foo'bar&lt;/code&gt; are legal, but &lt;code&gt;$foo'bar'&lt;/code&gt; is not.</source>
          <target state="translated">Perl에는 두 개의 패키지 구분 기호가 있습니다 : 이중 콜론 ( &lt;code&gt;::&lt;/code&gt; :) 과 작은 따옴표 ( &lt;code&gt;'&lt;/code&gt; ). 일반 식별자는 이중 콜론으로 시작하거나 끝날 수 있으며 이중 콜론으로 구분 된 여러 부분을 포함 할 수 있습니다. 작은 따옴표는 비슷한 규칙을 갖지만 식별자 끝에서 합법적이지 않다는 점을 제외하면 &lt;code&gt;$'foo&lt;/code&gt; 와 &lt;code&gt;$foo'bar&lt;/code&gt; 는 합법적이지만 &lt;code&gt;$foo'bar'&lt;/code&gt; 는 그렇지 않습니다.</target>
        </trans-unit>
        <trans-unit id="281389919696086dbd7adfd1393b788681ca075b" translate="yes" xml:space="preserve">
          <source>There are two package separators in Perl: A double colon (&lt;code&gt;::&lt;/code&gt;) and a single quote (&lt;code&gt;'&lt;/code&gt;). Normal identifiers can start or end with a double colon, and can contain several parts delimited by double colons. Single quotes have similar rules, but with the exception that they are not legal at the end of an identifier: That is, &lt;code&gt;$'foo&lt;/code&gt; and &lt;code&gt;$foo'bar&lt;/code&gt; are legal, but &lt;code&gt;$foo'bar'&lt;/code&gt; is not.</source>
          <target state="translated">Perl에는 두 개의 패키지 구분 기호가 있습니다. 이중 콜론 ( &lt;code&gt;::&lt;/code&gt; :) 과 작은 따옴표 ( &lt;code&gt;'&lt;/code&gt; )입니다. 일반 식별자는 이중 콜론으로 시작하거나 끝날 수 있으며 이중 콜론으로 구분 된 여러 부분을 포함 할 수 있습니다. 작은 따옴표는 비슷한 규칙을 가지고 있지만 식별자 끝에 합법적이지 않다는 점을 제외하면 &lt;code&gt;$'foo&lt;/code&gt; 및 &lt;code&gt;$foo'bar&lt;/code&gt; 는 합법적이지만 &lt;code&gt;$foo'bar'&lt;/code&gt; 는 합법적 이지 않습니다.</target>
        </trans-unit>
        <trans-unit id="75895a5372bf6c78e51cf652a3ae78bb3d9b2367" translate="yes" xml:space="preserve">
          <source>There are two principal conventions (it is useful to call them &lt;code&gt;Dos*&lt;/code&gt; and &lt;code&gt;Win*&lt;/code&gt; - though this part of the function signature is not always determined by the name of the API) of reporting the error conditions of OS/2 API. Most of &lt;code&gt;Dos*&lt;/code&gt; APIs report the error code as the result of the call (so 0 means success, and there are many types of errors). Most of &lt;code&gt;Win*&lt;/code&gt; API report success/fail via the result being &lt;code&gt;TRUE&lt;/code&gt; /&lt;code&gt;FALSE&lt;/code&gt; ; to find the reason for the failure one should call WinGetLastError() API.</source>
          <target state="translated">OS / 2 API의 오류 조건을보고하는 두 가지 주요 규칙 ( &lt;code&gt;Dos*&lt;/code&gt; 및 &lt;code&gt;Win*&lt;/code&gt; 을 호출하는 것이 유용 하지만 함수 서명의이 부분이 항상 API 이름으로 결정되는 것은 아님)이 있습니다. 대부분의 &lt;code&gt;Dos*&lt;/code&gt; API는 호출 결과로 오류 코드를보고합니다 (따라서 0은 성공을 의미하고 여러 유형의 오류가 있음). &lt;code&gt;TRUE&lt;/code&gt; / &lt;code&gt;FALSE&lt;/code&gt; 결과를 통한 대부분의 &lt;code&gt;Win*&lt;/code&gt; API 보고서 성공 / 실패 . 실패 원인을 찾으려면 WinGetLastError () API를 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="2eaa4513f3f865ba65175af81cc35fc35f264abc" translate="yes" xml:space="preserve">
          <source>There are two principal conventions (it is useful to call them &lt;code&gt;Dos*&lt;/code&gt; and &lt;code&gt;Win*&lt;/code&gt; - though this part of the function signature is not always determined by the name of the API) of reporting the error conditions of OS/2 API. Most of &lt;code&gt;Dos*&lt;/code&gt; APIs report the error code as the result of the call (so 0 means success, and there are many types of errors). Most of &lt;code&gt;Win*&lt;/code&gt; API report success/fail via the result being &lt;code&gt;TRUE&lt;/code&gt;/&lt;code&gt;FALSE&lt;/code&gt;; to find the reason for the failure one should call WinGetLastError() API.</source>
          <target state="translated">OS / 2 API의 오류 조건을보고하는 두 가지 주요 규칙 ( &lt;code&gt;Dos*&lt;/code&gt; 및 &lt;code&gt;Win*&lt;/code&gt; 이라고 부르는 것이 유용 합니다. 함수 서명의이 부분이 항상 API 이름에 의해 결정되는 것은 아님)이 있습니다. 대부분의 &lt;code&gt;Dos*&lt;/code&gt; API는 호출 결과로 오류 코드를보고합니다 (따라서 0은 성공을 의미하며 많은 유형의 오류가 있음). 대부분의 &lt;code&gt;Win*&lt;/code&gt; API는 &lt;code&gt;TRUE&lt;/code&gt; / &lt;code&gt;FALSE&lt;/code&gt; 결과를 통해 성공 / 실패를보고 합니다 . 실패 이유를 찾으려면 WinGetLastError () API를 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="87b7ddfa19fa0f3f3b716199a0f4db35df4687cb" translate="yes" xml:space="preserve">
          <source>There are two steps to running the test suite:</source>
          <target state="translated">테스트 스위트를 실행하는 데는 두 단계가 있습니다.</target>
        </trans-unit>
        <trans-unit id="5595b4165f441d44d1cb7724594811d46925edfc" translate="yes" xml:space="preserve">
          <source>There are two structures used to store a compiled regular expression. One, the &lt;code&gt;regexp&lt;/code&gt; structure described in &lt;a href=&quot;perlreapi&quot;&gt;perlreapi&lt;/a&gt; is populated by the engine currently being. used and some of its fields read by perl to implement things such as the stringification of &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">컴파일 된 정규식을 저장하는 데 사용되는 두 가지 구조가 있습니다. 하나는 &lt;code&gt;regexp&lt;/code&gt; 에 기재된 구조 &lt;a href=&quot;perlreapi&quot;&gt;perlreapi이&lt;/a&gt; 엔진은 됨으로써 채워. &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt; 의 문자열 화와 같은 것을 구현하기 위해 perl이 사용하고 일부 필드를 읽습니다 .</target>
        </trans-unit>
        <trans-unit id="5100abedaa25e172d048855813a77ed10197f346" translate="yes" xml:space="preserve">
          <source>There are two structures used to store a compiled regular expression. One, the &lt;code&gt;regexp&lt;/code&gt; structure described in &lt;a href=&quot;perlreapi&quot;&gt;perlreapi&lt;/a&gt; is populated by the engine currently being. used and some of its fields read by perl to implement things such as the stringification of &lt;code&gt;qr//&lt;/code&gt;.</source>
          <target state="translated">컴파일 된 정규식을 저장하는 데 사용되는 두 가지 구조가 있습니다. 하나는 &lt;code&gt;regexp&lt;/code&gt; 에 기재된 구조 &lt;a href=&quot;perlreapi&quot;&gt;perlreapi이&lt;/a&gt; 엔진은 됨으로써 채워. &lt;code&gt;qr//&lt;/code&gt; 의 문자열 화와 같은 것을 구현하기 위해 perl이 읽은 일부 필드와 일부 필드 .</target>
        </trans-unit>
        <trans-unit id="fc2fe23c780ba1b117d60c962e46037021ac3aa2" translate="yes" xml:space="preserve">
          <source>There are two syntaxes for formatting codes:</source>
          <target state="translated">코드 포맷에 대한 두 가지 구문이 있습니다.</target>
        </trans-unit>
        <trans-unit id="7371ec3e37b63adab8d04f7c4222af55c486c054" translate="yes" xml:space="preserve">
          <source>There are two that I can think off.</source>
          <target state="translated">내가 생각할 수있는 두 가지가 있습니다.</target>
        </trans-unit>
        <trans-unit id="6d886c39930696ad6e408c59f68366994aaac004" translate="yes" xml:space="preserve">
          <source>There are two ways to build persistent private variables in Perl 5.10. First, you can simply use the &lt;code&gt;&lt;a href=&quot;functions/state&quot;&gt;state&lt;/a&gt;&lt;/code&gt; feature. Or, you can use closures, if you want to stay compatible with releases older than 5.10.</source>
          <target state="translated">Perl 5.10에서 영구 개인 변수를 작성하는 방법에는 두 가지가 있습니다. 먼저 &lt;code&gt;&lt;a href=&quot;functions/state&quot;&gt;state&lt;/a&gt;&lt;/code&gt; 기능을 간단히 사용할 수 있습니다 . 또는 5.10 이전 릴리스와의 호환성을 유지하려면 클로저를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="61e69f88599a859bbb0f9c52d49cc582b32af203" translate="yes" xml:space="preserve">
          <source>There are two ways to build persistent private variables in Perl 5.10. First, you can simply use the &lt;code&gt;state&lt;/code&gt; feature. Or, you can use closures, if you want to stay compatible with releases older than 5.10.</source>
          <target state="translated">Perl 5.10에서 영구 개인 변수를 빌드하는 방법에는 두 가지가 있습니다. 첫째, 단순히 &lt;code&gt;state&lt;/code&gt; 기능을 사용할 수 있습니다 . 또는 5.10 이전 릴리스와의 호환성을 유지하려는 경우 클로저를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6c7079fb330c8f6fcf4a67d7d60f1f7e8ba9c961" translate="yes" xml:space="preserve">
          <source>There are two ways to create and load an AV. The first method creates an empty AV:</source>
          <target state="translated">AV를 만들고로드하는 방법에는 두 가지가 있습니다. 첫 번째 방법은 빈 AV를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="48bc33b0558cf40893cd4b6a9aee4a0aeea211f9" translate="yes" xml:space="preserve">
          <source>There are two ways to enable debugging output for regular expressions.</source>
          <target state="translated">정규식에 대한 디버깅 출력을 활성화하는 방법에는 두 가지가 있습니다.</target>
        </trans-unit>
        <trans-unit id="0ef643530975df52bad47239ca43b62c4abb64aa" translate="yes" xml:space="preserve">
          <source>There are two ways to enter v-strings: a bare number with two or more decimal points, or a bare number with one or more decimal points and a leading 'v' character (also bare). For example:</source>
          <target state="translated">v- 문자열을 입력하는 방법에는 두 가지가 있습니다. 소수점이 두 개 이상있는 맨 숫자 또는 하나 이상의 소수점이있는 맨 숫자와 선행 'v'문자 (또한 맨손)입니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ad6ac5b22382be34f18ee4c2a153755024871b3a" translate="yes" xml:space="preserve">
          <source>There are two ways to load the &lt;code&gt;feature&lt;/code&gt; pragma implicitly:</source>
          <target state="translated">&lt;code&gt;feature&lt;/code&gt; 을로드하는 방법에는 두 가지가 있습니다 pragma를 암시 적 .</target>
        </trans-unit>
        <trans-unit id="af911c100c71eb3b76adfb1d6d843d034d346f08" translate="yes" xml:space="preserve">
          <source>There are two ways to specify the selection. Either a string (scalar) representing a selection regexp for sections to be printed when -verbose is set to 99, e.g.</source>
          <target state="translated">선택을 지정하는 방법에는 두 가지가 있습니다. -verbose가 99로 설정 될 때 인쇄 될 섹션에 대한 선택 정규식을 나타내는 문자열 (스칼라)입니다. 예 :</target>
        </trans-unit>
        <trans-unit id="f214eee3e697782835e9e4f8a448217e9a53a985" translate="yes" xml:space="preserve">
          <source>There are two ways to use Cocoa from Perl. Apple's PerlObjCBridge module, included with Mac OS X, can be used by standalone scripts to access Foundation (i.e. non-GUI) classes and objects.</source>
          <target state="translated">Perl에서 Cocoa를 사용하는 방법은 두 가지가 있습니다. Mac OS X에 포함 된 Apple PerlObjCBridge 모듈은 독립형 스크립트에서 Foundation (즉, 비 GUI) 클래스 및 객체에 액세스하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="767f59a65489b12a4b5161b27a3a60165cdfb67b" translate="yes" xml:space="preserve">
          <source>There are two ways to use a DBM Filter.</source>
          <target state="translated">DBM 필터를 사용하는 방법에는 두 가지가 있습니다.</target>
        </trans-unit>
        <trans-unit id="409a8226f327930f82376970d0a5dd5d41e49fa0" translate="yes" xml:space="preserve">
          <source>There are undoubtedly serious bugs lurking somewhere in code this funky :-) Bug reports and other feedback are most welcome.</source>
          <target state="translated">의심 할 여지없이 코드에 어딘가에 숨어있는 심각한 버그가 있습니다 :-) 버그 보고서 및 기타 피드백은 가장 환영합니다.</target>
        </trans-unit>
        <trans-unit id="85be9b959b2e4ac88632b966dc97bb4a96c09ffb" translate="yes" xml:space="preserve">
          <source>There are undoubtedly serious bugs lurking somewhere in this code, if only because parts of it give the impression of understanding a great deal more about Perl than they really do.</source>
          <target state="translated">이 코드의 어딘가에 숨어있는 버그는 의심 할 여지없이, 실제로는 그보다 Perl에 대해 많은 것을 이해한다는 인상을주기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="04b3f04345fdb786670dce0b2cea7b0b8304663e" translate="yes" xml:space="preserve">
          <source>There are useful variations on this theme. The sense of the match can be reversed by using the &lt;code&gt;!~&lt;/code&gt; operator:</source>
          <target state="translated">이 주제에는 유용한 변형이 있습니다. &lt;code&gt;!~&lt;/code&gt; 연산자를 사용하여 일치 의미를 되돌릴 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ccb3b88b50c8aa38b3bc60c7b4f5ddbf691da924" translate="yes" xml:space="preserve">
          <source>There are usually several synonyms for each possible value. Use &lt;a href=&quot;#prop_value_aliases%28%29&quot;&gt;&quot;prop_value_aliases()&quot;&lt;/a&gt; to access those.</source>
          <target state="translated">일반적으로 가능한 각 값에 대해 여러 개의 동의어가 있습니다. 이에 액세스 하려면 &lt;a href=&quot;#prop_value_aliases%28%29&quot;&gt;&quot;prop_value_aliases ()&quot;&lt;/a&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="ae9efcf4d71ac56a124108c21d7833f5bea0582a" translate="yes" xml:space="preserve">
          <source>There are usually several synonyms for each possible value. Use &lt;a href=&quot;#prop_value_aliases()&quot;&gt;prop_value_aliases()&lt;/a&gt; to access those.</source>
          <target state="translated">가능한 각 값에 대해 일반적으로 여러 동의어가 있습니다. 사용 &lt;a href=&quot;#prop_value_aliases()&quot;&gt;) (prop_value_aliases를&lt;/a&gt; 를 하여 액세스 .</target>
        </trans-unit>
        <trans-unit id="defaf951c93d8c59c8e8c2838dbcdfdd9abafeeb" translate="yes" xml:space="preserve">
          <source>There are usually three or four interval timers (signals) available: the &lt;code&gt;$which&lt;/code&gt; can be &lt;code&gt;ITIMER_REAL&lt;/code&gt; , &lt;code&gt;ITIMER_VIRTUAL&lt;/code&gt; , &lt;code&gt;ITIMER_PROF&lt;/code&gt; , or &lt;code&gt;ITIMER_REALPROF&lt;/code&gt; . Note that which ones are available depends: true UNIX platforms usually have the first three, but only Solaris seems to have &lt;code&gt;ITIMER_REALPROF&lt;/code&gt; (which is used to profile multithreaded programs). Win32 unfortunately does not have interval timers.</source>
          <target state="translated">일반적으로 3 개 또는 4 개의 인터벌 타이머 (신호)가 있습니다 : &lt;code&gt;$which&lt;/code&gt; 할 수 있습니다 &lt;code&gt;ITIMER_REAL&lt;/code&gt; 을 , &lt;code&gt;ITIMER_VIRTUAL&lt;/code&gt; , &lt;code&gt;ITIMER_PROF&lt;/code&gt; , 또는 &lt;code&gt;ITIMER_REALPROF&lt;/code&gt; 는 . 사용 가능한 플랫폼은 다음과 같습니다. 실제 UNIX 플랫폼에는 일반적으로 처음 세 개가 있지만 Solaris에만 &lt;code&gt;ITIMER_REALPROF&lt;/code&gt; (멀티 스레드 프로그램을 프로파일 링하는 데 사용됨)가있는 것 같습니다 . 불행히도 Win32에는 간격 타이머가 없습니다.</target>
        </trans-unit>
        <trans-unit id="ed047ca7fa087626bb96ec97a8dcb6e6e48edfcd" translate="yes" xml:space="preserve">
          <source>There are usually three or four interval timers (signals) available: the &lt;code&gt;$which&lt;/code&gt; can be &lt;code&gt;ITIMER_REAL&lt;/code&gt;, &lt;code&gt;ITIMER_VIRTUAL&lt;/code&gt;, &lt;code&gt;ITIMER_PROF&lt;/code&gt;, or &lt;code&gt;ITIMER_REALPROF&lt;/code&gt;. Note that which ones are available depends: true UNIX platforms usually have the first three, but only Solaris seems to have &lt;code&gt;ITIMER_REALPROF&lt;/code&gt; (which is used to profile multithreaded programs). Win32 unfortunately does not have interval timers.</source>
          <target state="translated">일반적으로 3 개 또는 4 개의 간격 타이머 (신호)를 사용할 수 있습니다. &lt;code&gt;$which&lt;/code&gt; 는 &lt;code&gt;ITIMER_REAL&lt;/code&gt; , &lt;code&gt;ITIMER_VIRTUAL&lt;/code&gt; , &lt;code&gt;ITIMER_PROF&lt;/code&gt; 또는 &lt;code&gt;ITIMER_REALPROF&lt;/code&gt; 일 수 있습니다 . 어떤 것이 사용 가능한지에 따라 다릅니다. 진정한 UNIX 플랫폼에는 일반적으로 처음 3 개가 있지만 Solaris에만 &lt;code&gt;ITIMER_REALPROF&lt;/code&gt; (다중 스레드 프로그램을 프로파일 링하는 데 사용됨)가있는 것 같습니다 . 불행히도 Win32에는 간격 타이머가 없습니다.</target>
        </trans-unit>
        <trans-unit id="0d22a105cc916ea14dd34be71dc22f4c1bb3fd7e" translate="yes" xml:space="preserve">
          <source>There are various aspects of the pattern that can be used to facilitate optimisations along these lines:</source>
          <target state="translated">이 라인을 따라 최적화를 촉진하는 데 사용할 수있는 패턴의 다양한 측면이 있습니다.</target>
        </trans-unit>
        <trans-unit id="e3cedfe60646d2e7422ff8b2a7a07f8c037537db" translate="yes" xml:space="preserve">
          <source>There are various other failures, that as of SunOS 4.1.4 and gcc 3.2.2 look a lot like gcc bugs. Many of the failures happen in the Encode tests, where for example when the test expects &quot;0&quot; you get &quot;&amp;amp;#48;&quot; which should after a little squinting look very odd indeed. Another example is earlier in</source>
          <target state="translated">SunOS 4.1.4 및 gcc 3.2.2에서 gcc 버그와 매우 유사하게 나타나는 여러 가지 다른 오류가 있습니다. 많은 실패는 Encode 테스트에서 발생합니다. 예를 들어 테스트에서 &quot;0&quot;이 예상되면 &quot;&amp;amp; # 48;&quot;이 표시됩니다. 약간 곁눈질 후 정말 이상하게 보일 것입니다. 다른 예는 이전에</target>
        </trans-unit>
        <trans-unit id="e93c51ec114e78593d3350d4739a1d10d41d678a" translate="yes" xml:space="preserve">
          <source>There are various other synonyms that can be used besides the names listed in the table. For example, &lt;code&gt;\p{PosixAlpha}&lt;/code&gt; can be written as &lt;code&gt;\p{Alpha}&lt;/code&gt; . All are listed in &lt;a href=&quot;perluniprops#Properties-accessible-through-%5cp%7b%7d-and-%5cP%7b%7d&quot;&gt;Properties accessible through \p{} and \P{} in perluniprops&lt;/a&gt;.</source>
          <target state="translated">표에 나열된 이름 이외에도 사용할 수있는 다양한 동의어가 있습니다. 예를 들어, &lt;code&gt;\p{PosixAlpha}&lt;/code&gt; 는 &lt;code&gt;\p{Alpha}&lt;/code&gt; 로 쓸 수 있습니다 . 모두 &lt;a href=&quot;perluniprops#Properties-accessible-through-%5cp%7b%7d-and-%5cP%7b%7d&quot;&gt;perluniprops의 \ p {} 및 \ P {}를 통해 액세스 할 수&lt;/a&gt; 있는 특성 에 나열되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="bc8fcc00bcaa69a62d8c2fd3f050d67f5a95dbce" translate="yes" xml:space="preserve">
          <source>There are various other synonyms that can be used besides the names listed in the table. For example, &lt;code&gt;\p{XPosixAlpha}&lt;/code&gt; can be written as &lt;code&gt;\p{Alpha}&lt;/code&gt;. All are listed in &lt;a href=&quot;perluniprops#Properties-accessible-through-%5Cp%7B%7D-and-%5CP%7B%7D&quot;&gt;&quot;Properties accessible through \p{} and \P{}&quot; in perluniprops&lt;/a&gt;.</source>
          <target state="translated">표에 나열된 이름 외에 사용할 수있는 다양한 다른 동의어가 있습니다. 예를 들어, &lt;code&gt;\p{XPosixAlpha}&lt;/code&gt; 는 &lt;code&gt;\p{Alpha}&lt;/code&gt; 로 쓸 수 있습니다 . 모두 &lt;a href=&quot;perluniprops#Properties-accessible-through-%5Cp%7B%7D-and-%5CP%7B%7D&quot;&gt;perluniprops의 &quot;\ p {} 및 \ P {}를 통해 액세스 할 수있는 속성&quot;&lt;/a&gt; 에 나열되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="20fb423bc3be57a7bce8d37147a935d047431e3f" translate="yes" xml:space="preserve">
          <source>There are various special make targets that can be used to test Perl slightly differently than the standard &quot;test&quot; target. Not all them are expected to give a 100% success rate. Many of them have several aliases, and many of them are not available on certain operating systems.</source>
          <target state="translated">Perl을 표준 &quot;test&quot;대상과 약간 다르게 테스트하는 데 사용할 수있는 다양한 특수 make 대상이 있습니다. 그들 모두가 100 %의 성공률을 기대하지는 않습니다. 그들 중 다수는 여러 개의 별명을 가지고 있으며, 그들 중 일부는 특정 운영 체제에서 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="7a37b656849e5abe23739ebb1083bad00e7235fc" translate="yes" xml:space="preserve">
          <source>There are various syntaxes, listed below. In the syntaxes given, &lt;code&gt;text&lt;/code&gt; , &lt;code&gt;name&lt;/code&gt; , and &lt;code&gt;section&lt;/code&gt; cannot contain the characters '/' and '|'; and any '&amp;lt;' or '&amp;gt;' should be matched.</source>
          <target state="translated">아래에 나열된 다양한 구문이 있습니다. 주어진 구문에서 &lt;code&gt;text&lt;/code&gt; , &lt;code&gt;name&lt;/code&gt; 및 &lt;code&gt;section&lt;/code&gt; 은 '/'및 '|'문자를 포함 할 수 없습니다. '&amp;lt;'또는 '&amp;gt;'는 일치해야합니다.</target>
        </trans-unit>
        <trans-unit id="154dae7c2bfb8ff3e2e9f53b8d516d9eec568a2c" translate="yes" xml:space="preserve">
          <source>There are various syntaxes, listed below. In the syntaxes given, &lt;code&gt;text&lt;/code&gt;, &lt;code&gt;name&lt;/code&gt;, and &lt;code&gt;section&lt;/code&gt; cannot contain the characters '/' and '|'; and any '&amp;lt;' or '&amp;gt;' should be matched.</source>
          <target state="translated">아래에 나열된 다양한 구문이 있습니다. 주어진 구문에서 &lt;code&gt;text&lt;/code&gt; , &lt;code&gt;name&lt;/code&gt; , &lt;code&gt;section&lt;/code&gt; 은 '/'및 '|'문자를 포함 할 수 없습니다. 모든 '&amp;lt;'또는 '&amp;gt;'가 일치해야합니다.</target>
        </trans-unit>
        <trans-unit id="d37ed54ad4b4e800cd45604ce3c3818f96427db4" translate="yes" xml:space="preserve">
          <source>There are various things to note:</source>
          <target state="translated">주의해야 할 여러 가지가 있습니다.</target>
        </trans-unit>
        <trans-unit id="b76fc3582c89676c08603c7aa65b9cc5c9b6bcec" translate="yes" xml:space="preserve">
          <source>There are various ways in which the private and public flags may differ. For example, in perl 5.16 and earlier a tied SV may have a valid underlying value in the IV slot (so SvIOKp is true), but the data should be accessed via the FETCH routine rather than directly, so SvIOK is false. (In perl 5.18 onwards, tied scalars use the flags the same way as untied scalars.) Another is when numeric conversion has occurred and precision has been lost: only the private flag is set on 'lossy' values. So when an NV is converted to an IV with loss, SvIOKp, SvNOKp and SvNOK will be set, while SvIOK wont be.</source>
          <target state="translated">개인 및 공개 플래그가 다른 여러 가지 방법이 있습니다. 예를 들어 perl 5.16 및 이전 버전에서는 연결된 SV가 IV 슬롯에서 유효한 기본 값을 가질 수 있지만 (SvIOKp는 true 임) 데이터는 직접이 아닌 FETCH 루틴을 통해 액세스해야하므로 SvIOK는 false입니다. (perl 5.18 이후에는 묶인 스칼라가 묶이지 않은 스칼라와 같은 방식으로 플래그를 사용합니다.) 또 다른 방법은 숫자 변환이 발생하고 정밀도가 손실 된 경우입니다. 개인 플래그 만 '손실'값으로 설정됩니다. 따라서 NV가 손실로 IV로 변환되면 SvIOKp, SvNOKp 및 SvNOK가 설정되지만 SvIOK는 설정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="bf9b799d87e5a86957d5b5b84b03a08b714f7c53" translate="yes" xml:space="preserve">
          <source>There are web archives of the mailing list at:</source>
          <target state="translated">메일 링리스트의 웹 아카이브는 다음 위치에 있습니다.</target>
        </trans-unit>
        <trans-unit id="491c71a7d655138bb171154df9a2d69cb67f8248" translate="yes" xml:space="preserve">
          <source>There are, at first glance, three kinds of L links: URL, man, and pod.</source>
          <target state="translated">언뜻보기에 URL, man, pod의 세 종류의 L 링크가 있습니다.</target>
        </trans-unit>
        <trans-unit id="35625b0405457bfbc71b97ae568ca975b4ffb8db" translate="yes" xml:space="preserve">
          <source>There aren't currently any real UTF-8 locales, even though some locale names contain the string &quot;UTF-8&quot;.</source>
          <target state="translated">일부 로캘 이름에 &quot;UTF-8&quot;문자열이 포함되어 있어도 현재 실제 UTF-8 로캘은 없습니다.</target>
        </trans-unit>
        <trans-unit id="f18bc503764d637966b24fa60ca1825eff55d27b" translate="yes" xml:space="preserve">
          <source>There can (and in some cases, must) be whitespace between the operator and the quoting characters, except when &lt;code&gt;#&lt;/code&gt; is being used as the quoting character. &lt;code&gt;q#foo#&lt;/code&gt; is parsed as the string &lt;code&gt;foo&lt;/code&gt;, while &lt;code&gt;q #foo#&lt;/code&gt; is the operator &lt;code&gt;q&lt;/code&gt; followed by a comment. Its argument will be taken from the next line. This allows you to write:</source>
          <target state="translated">&lt;code&gt;#&lt;/code&gt; 이 인용 문자로 사용되는 경우를 제외하고 연산자와 인용 문자 사이에 공백이있을 수 있으며 경우에 따라 공백이 있어야합니다 . &lt;code&gt;q#foo#&lt;/code&gt; 문자열로 구문 분석 &lt;code&gt;foo&lt;/code&gt; 는 동안, &lt;code&gt;q #foo#&lt;/code&gt; 운영자 인 &lt;code&gt;q&lt;/code&gt; 코멘트 다음은. 그 인수는 다음 줄에서 가져옵니다. 이를 통해 다음을 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="afc581d54ed5726e14da03dd8d1af5cdf478d3d5" translate="yes" xml:space="preserve">
          <source>There can be whitespace between the operator and the quoting characters, except when &lt;code&gt;#&lt;/code&gt; is being used as the quoting character. &lt;code&gt;&lt;a href=&quot;functions/q&quot;&gt;q#foo#&lt;/a&gt;&lt;/code&gt; is parsed as the string &lt;code&gt;foo&lt;/code&gt; , while &lt;code&gt;q #foo#&lt;/code&gt; is the operator &lt;code&gt;&lt;a href=&quot;functions/q&quot;&gt;q&lt;/a&gt;&lt;/code&gt; followed by a comment. Its argument will be taken from the next line. This allows you to write:</source>
          <target state="translated">&lt;code&gt;#&lt;/code&gt; 을 인용 문자로 사용하는 경우를 제외하고 연산자와 인용 문자 사이에 공백이있을 수 있습니다 . &lt;code&gt;&lt;a href=&quot;functions/q&quot;&gt;q#foo#&lt;/a&gt;&lt;/code&gt; 문자열로 파싱 &lt;code&gt;foo&lt;/code&gt; 를 하면서, &lt;code&gt;q #foo#&lt;/code&gt; 조작이다 &lt;code&gt;&lt;a href=&quot;functions/q&quot;&gt;q&lt;/a&gt;&lt;/code&gt; 코멘트 다음은. 그 주장은 다음 줄에서 가져옵니다. 이것은 당신이 쓸 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="7f8e18aa50aec43fc98b47477339b319d9bf73e8" translate="yes" xml:space="preserve">
          <source>There does not need to be whitespace at the start of the &quot;&lt;code&gt;&lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt; input&lt;/code&gt; &quot; line, but it is useful for improving readability. Placing a semi-colon at the end of that line is also optional. Any amount and kind of whitespace may be placed between the &quot;&lt;code&gt;&lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt;&lt;/code&gt;&quot; and &quot;&lt;code&gt;input&lt;/code&gt; &quot;.</source>
          <target state="translated">&quot; &lt;code&gt;&lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt; input&lt;/code&gt; &quot;줄 의 시작 부분에 공백이 없어도 되지만 가독성을 향상시키는 데 유용합니다. 해당 줄의 끝에 세미콜론을 두는 것도 선택 사항입니다. 임의의 양과 종류의 공백은 &quot; &lt;code&gt;&lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt;&lt;/code&gt; &quot;와 &quot; &lt;code&gt;input&lt;/code&gt; 사이에 둘 수 있습니다. &quot; .</target>
        </trans-unit>
        <trans-unit id="0ed8a4a87dc8b9885199d341701749c4f7ba168d" translate="yes" xml:space="preserve">
          <source>There does not need to be whitespace at the start of the &quot;&lt;code&gt;int input&lt;/code&gt;&quot; line, but it is useful for improving readability. Placing a semi-colon at the end of that line is also optional. Any amount and kind of whitespace may be placed between the &quot;&lt;code&gt;int&lt;/code&gt;&quot; and &quot;&lt;code&gt;input&lt;/code&gt;&quot;.</source>
          <target state="translated">&quot; &lt;code&gt;int input&lt;/code&gt; &quot;줄 의 시작 부분에 공백이있을 필요 는 없지만 가독성을 높이는 데 유용합니다. 해당 줄 끝에 세미콜론을 배치하는 것도 선택 사항입니다. &quot; &lt;code&gt;int&lt;/code&gt; &quot;와 &quot; &lt;code&gt;input&lt;/code&gt; &quot; 사이에 어떤 양과 종류의 공백을 넣을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="674ce7b791aca3a84e36e5ed443e53056266d194" translate="yes" xml:space="preserve">
          <source>There exists a port of Perl to the ILE environment. This port, however, is based quite an old release of Perl, Perl 5.00502 (August 1998). (As of July 2002 the latest release of Perl is 5.8.0, and even 5.6.1 has been out since April 2001.) If you need to run Perl on ILE, though, you may need this older port: &lt;a href=&quot;http://www.cpan.org/ports/#os400&quot;&gt;http://www.cpan.org/ports/#os400&lt;/a&gt; Note that any Perl release later than 5.00502 has not been ported to ILE.</source>
          <target state="translated">ILE 환경에 대한 Perl 포트가 있습니다. 그러나이 포트는 Perl 5.00502 (1998 년 8 월)의 이전 릴리스를 기반으로합니다. (2002 년 7 월 현재, Perl의 최신 릴리스는 5.8.0이며, 심지어 5.6.1도 2001 년 4 월 이후에 나왔습니다.) ILE에서 Perl을 실행해야하는 경우,이 이전 포트가 필요할 수 있습니다. &lt;a href=&quot;http://www.cpan.org/ports/#os400&quot;&gt;http : // www.cpan.org/ports/#os400&lt;/a&gt; 이후의 Perl 릴리스는 ILE로 포팅되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="0d9d302333913269ef8b0575b5cd9f95eaae918e" translate="yes" xml:space="preserve">
          <source>There has been a long-standing bug in Perl that causes a lexical variable not to be cleared at scope exit when its declaration includes a false conditional. Some people have exploited this bug to achieve a kind of static variable. To allow us to fix this bug, people should not be relying on this behavior.</source>
          <target state="translated">Perl에는 선언에 거짓 조건이 포함 된 경우 범위 종료시 어휘 변수가 지워지지 않도록하는 오래된 버그가 있습니다. 어떤 사람들은 일종의 정적 변수를 얻기 위해이 버그를 악용했습니다. 이 버그를 수정하려면 사람들이이 동작에 의존해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="5e08bda06a78f17f34330ccdc939ea82e2b5bf49" translate="yes" xml:space="preserve">
          <source>There is Coverity setup for the perl5 project: &lt;a href=&quot;https://scan.coverity.com/projects/perl5&quot;&gt;https://scan.coverity.com/projects/perl5&lt;/a&gt;</source>
          <target state="translated">perl5 프로젝트에 대한 Coverity 설정이 있습니다 : &lt;a href=&quot;https://scan.coverity.com/projects/perl5&quot;&gt;https://scan.coverity.com/projects/perl5&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="10164fd98639a8c3044721a3ed9b1556ef825187" translate="yes" xml:space="preserve">
          <source>There is a &quot;hints&quot; file for BS2000 called hints.posix-bc (because posix-bc is the OS name given by `uname`) that specifies the correct values for most things. The major problem is (of course) the EBCDIC character set. We have german EBCDIC version.</source>
          <target state="translated">BS2000에 대한 hints.posix-bc라는 이름의 &quot;힌트&quot;파일이 있습니다 (posix-bc는`uname`에 의해 주어진 OS 이름이기 때문에). 대부분의 것들에 대한 올바른 값을 지정합니다. 가장 큰 문제는 (물론) EBCDIC 문자 세트입니다. 우리는 독일어 EBCDIC 버전이 있습니다.</target>
        </trans-unit>
        <trans-unit id="5374f2f6990509e72c419ef45603ab27e3bc80da" translate="yes" xml:space="preserve">
          <source>There is a $diagnostics::DEBUG variable you may set if you're desperately curious what sorts of things are being intercepted.</source>
          <target state="translated">어떤 종류의 물건을 가로채는 지 궁금해하는 경우 $ diagnostics :: DEBUG 변수를 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4e2dabede0ae332ec4295f1f32bf75c6726b72c4" translate="yes" xml:space="preserve">
          <source>There is a &lt;code&gt;lint&lt;/code&gt; target in Makefile, but you may have to diddle with the flags (see above).</source>
          <target state="translated">Makefile 에는 &lt;code&gt;lint&lt;/code&gt; 타겟이 있지만 플래그를 처리해야 할 수도 있습니다 (위 참조).</target>
        </trans-unit>
        <trans-unit id="85b8779e0a6e284066d3e0c5dc63c7524691a431" translate="yes" xml:space="preserve">
          <source>There is a CPAN module, &lt;code&gt;&lt;a href=&quot;Unicode::Casing&quot;&gt;Unicode::Casing&lt;/a&gt;&lt;/code&gt;, which allows you to define your own mappings to be used in &lt;code&gt;lc()&lt;/code&gt;, &lt;code&gt;lcfirst()&lt;/code&gt;, &lt;code&gt;uc()&lt;/code&gt;, &lt;code&gt;ucfirst()&lt;/code&gt;, and &lt;code&gt;fc&lt;/code&gt; (or their double-quoted string inlined versions such as &lt;code&gt;\U&lt;/code&gt;). (Prior to Perl 5.16, this functionality was partially provided in the Perl core, but suffered from a number of insurmountable drawbacks, so the CPAN module was written instead.)</source>
          <target state="translated">CPAN 모듈 인 &lt;code&gt;&lt;a href=&quot;Unicode::Casing&quot;&gt;Unicode::Casing&lt;/a&gt;&lt;/code&gt; 은 &lt;code&gt;lc()&lt;/code&gt; , &lt;code&gt;lcfirst()&lt;/code&gt; , &lt;code&gt;uc()&lt;/code&gt; , &lt;code&gt;ucfirst()&lt;/code&gt; 및 &lt;code&gt;fc&lt;/code&gt; (또는 큰 따옴표로 묶인 문자열 인라인 버전 ) 에서 사용할 고유 한 매핑을 정의 할 수 있도록합니다. 예 : &lt;code&gt;\U&lt;/code&gt; ). (Perl 5.16 이전에는이 ​​기능이 부분적으로 Perl 코어에 제공되었지만 극복 할 수없는 많은 단점이 있었기 때문에 CPAN 모듈이 대신 작성되었습니다.)</target>
        </trans-unit>
        <trans-unit id="6a13bc3171b7f184b15ada467454c70823010717" translate="yes" xml:space="preserve">
          <source>There is a CPAN module, &lt;code&gt;&lt;a href=&quot;http://search.cpan.org/perldoc/Unicode::Casing&quot;&gt;Unicode::Casing&lt;/a&gt;&lt;/code&gt;, which allows you to define your own mappings to be used in &lt;code&gt;&lt;a href=&quot;functions/lc&quot;&gt;lc()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/lcfirst&quot;&gt;lcfirst()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/uc&quot;&gt;uc()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/ucfirst&quot;&gt;ucfirst()&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;functions/fc&quot;&gt;fc&lt;/a&gt;&lt;/code&gt; (or their double-quoted string inlined versions such as &lt;code&gt;\U&lt;/code&gt; ). (Prior to Perl 5.16, this functionality was partially provided in the Perl core, but suffered from a number of insurmountable drawbacks, so the CPAN module was written instead.)</source>
          <target state="translated">CPAN 모듈 인 &lt;code&gt;&lt;a href=&quot;http://search.cpan.org/perldoc/Unicode::Casing&quot;&gt;Unicode::Casing&lt;/a&gt;&lt;/code&gt; 이 있으며, &lt;code&gt;&lt;a href=&quot;functions/lc&quot;&gt;lc()&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/lcfirst&quot;&gt;lcfirst()&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/uc&quot;&gt;uc()&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/ucfirst&quot;&gt;ucfirst()&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;functions/fc&quot;&gt;fc&lt;/a&gt;&lt;/code&gt; (또는 큰 따옴표로 묶인 문자열 인라인 버전 )에 사용할 고유 한 맵핑을 정의 할 수 있습니다. &lt;code&gt;\U&lt;/code&gt; 와 같은 ). (Perl 5.16 이전에는이 ​​기능이 Perl 코어에서 부분적으로 제공되었지만 여러 가지 극복 할 수없는 단점이 있으므로 CPAN 모듈이 대신 작성되었습니다.)</target>
        </trans-unit>
        <trans-unit id="c5d3a875427fdf261fbe25e4b0c804d418f70748" translate="yes" xml:space="preserve">
          <source>There is a Clone module available on CPAN which implements deep cloning natively, i.e. without freezing to memory and thawing the result. It is aimed to replace Storable's dclone() some day. However, it does not currently support Storable hooks to redefine the way deep cloning is performed.</source>
          <target state="translated">CPAN에는 기본적으로 딥 클로닝을 구현하는 복제 모듈이 있습니다. 즉, 메모리를 정지시키고 결과를 해동하지 않습니다. 언젠가 Storable의 dclone ()을 대체하는 것이 목표입니다. 그러나 현재 심층 복제가 수행되는 방식을 재정의하기 위해 Storable 후크를 지원하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d1abe7c402c9589925c2fd5cdd3fc7738d6e503b" translate="yes" xml:space="preserve">
          <source>There is a Perl interface to TrollTech's Qt toolkit, but it does not appear to be maintained.</source>
          <target state="translated">TrollTech의 Qt 툴킷에 대한 Perl 인터페이스가 있지만 유지되지 않는 것 같습니다.</target>
        </trans-unit>
        <trans-unit id="2368d7b8dd55271d773f21a14ae9eb87cfb16560" translate="yes" xml:space="preserve">
          <source>There is a bug in perl5.6.0 with UV's that are &amp;gt;= 1&amp;lt;&amp;lt;31. This will show up as tests 8 and 9 of dualvar.t failing</source>
          <target state="translated">perl5.6.0에는 UV가&amp;gt; = 1 &amp;lt;&amp;lt; 31 인 버그가 있습니다. 이것은 dualvar.t의 테스트 8과 9가 실패로 나타납니다.</target>
        </trans-unit>
        <trans-unit id="74ad132a2446bd3d40e9bf990b8f1b1aa2a313b3" translate="yes" xml:space="preserve">
          <source>There is a central directory for the Perl community: &lt;a href=&quot;http://perl.org&quot;&gt;http://perl.org&lt;/a&gt; maintained by the Perl Foundation (&lt;a href=&quot;http://www.perlfoundation.org/&quot;&gt;http://www.perlfoundation.org/&lt;/a&gt;), which tracks and provides services for a variety of other community sites.</source>
          <target state="translated">Perl 커뮤니티를위한 중앙 디렉토리가 있습니다 : &lt;a href=&quot;http://perl.org&quot;&gt;http://perl.org&lt;/a&gt; Perl Foundation ( &lt;a href=&quot;http://www.perlfoundation.org/&quot;&gt;http://www.perlfoundation.org/&lt;/a&gt; )은 다양한 다른 커뮤니티 사이트를위한 서비스를 추적하고 제공합니다.</target>
        </trans-unit>
        <trans-unit id="b14e35e5c9ac344a8ff5825a4050f6c40c0d0c03" translate="yes" xml:space="preserve">
          <source>There is a class method in &lt;code&gt;PerlIO::Layer&lt;/code&gt;&lt;code&gt;find&lt;/code&gt; which is implemented as XS code. It is called by &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; to validate the layers:</source>
          <target state="translated">&lt;code&gt;PerlIO::Layer&lt;/code&gt; &lt;code&gt;find&lt;/code&gt; 에는 XS 코드로 구현 된 클래스 메소드가 있습니다. &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; 으로 불린다 레이어를 확인하기 :</target>
        </trans-unit>
        <trans-unit id="ba9884f209caf6d0506a39ac341c0ea3ddd78c13" translate="yes" xml:space="preserve">
          <source>There is a class method in &lt;code&gt;PerlIO::Layer&lt;/code&gt;&lt;code&gt;find&lt;/code&gt; which is implemented as XS code. It is called by &lt;code&gt;import&lt;/code&gt; to validate the layers:</source>
          <target state="translated">&lt;code&gt;PerlIO::Layer&lt;/code&gt; &lt;code&gt;find&lt;/code&gt; 에는 XS 코드로 구현 된 클래스 메소드가 있습니다. 레이어의 유효성을 검사하기 위해 &lt;code&gt;import&lt;/code&gt; 에서 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="130b2ceadd9a5f49d4085944a7e2f2612f7d6b00" translate="yes" xml:space="preserve">
          <source>There is a facility called &quot;file extension associations&quot;. This can be manipulated via the two commands &quot;assoc&quot; and &quot;ftype&quot; that come standard with Windows. Type &quot;ftype /?&quot; for a complete example of how to set this up for perl scripts (Say what? You thought Windows wasn't perl-ready? :).</source>
          <target state="translated">&quot;파일 확장자 연결&quot;이라는 기능이 있습니다. 이것은 Windows에서 표준으로 제공되는 &quot;assoc&quot;및 &quot;ftype&quot;두 명령을 통해 조작 할 수 있습니다. &quot;ftype /?&quot;를 입력하십시오. 펄 스크립트를 위해 이것을 설정하는 방법에 대한 완전한 예를 들어 보자.</target>
        </trans-unit>
        <trans-unit id="56c8b0f7b0876f90abc844b5aa213cd2600b5f4e" translate="yes" xml:space="preserve">
          <source>There is a fairly obvious gotcha included with the line directive: Debuggers and profilers will only show the last source line to appear at a particular line number in a given file. Care should be taken not to cause line number collisions in code you'd like to debug later.</source>
          <target state="translated">line 지시어에는 상당히 분명한 문제가 있습니다. 디버거와 프로파일 러는 주어진 파일의 특정 행 번호에 표시되는 마지막 소스 행만 표시합니다. 나중에 디버깅하려는 코드에서 줄 번호 충돌이 발생하지 않도록주의해야합니다.</target>
        </trans-unit>
        <trans-unit id="bb9de8709414ce3be99387c65eb446322517dbc7" translate="yes" xml:space="preserve">
          <source>There is a full version history in the Changes file, and the Test::More versions included as core can be found using &lt;a href=&quot;../module/corelist&quot;&gt;Module::CoreList&lt;/a&gt;:</source>
          <target state="translated">Changes 파일에는 전체 버전 기록이 있으며 &lt;a href=&quot;../module/corelist&quot;&gt;Module :: CoreList를&lt;/a&gt; 사용하여 코어로 포함 된 Test :: More 버전을 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fc72621c4f74524103b116a2301e947655e4bfff" translate="yes" xml:space="preserve">
          <source>There is a full version history in the Changes file, and the Test::More versions included as core can be found using &lt;a href=&quot;Module::CoreList&quot;&gt;Module::CoreList&lt;/a&gt;:</source>
          <target state="translated">변경 파일에는 전체 버전 기록이 있으며, 핵심으로 포함 된 Test :: More 버전은 &lt;a href=&quot;Module::CoreList&quot;&gt;Module :: CoreList를&lt;/a&gt; 사용하여 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8d8d363093d476f461ae875eb02ff5a19f7dc579" translate="yes" xml:space="preserve">
          <source>There is a functional programming API available for programmers to query information.</source>
          <target state="translated">프로그래머가 정보를 조회 할 수있는 기능적 프로그래밍 API가 있습니다.</target>
        </trans-unit>
        <trans-unit id="a15e4bcad41aa0b597b5c043d274e21e152196d8" translate="yes" xml:space="preserve">
          <source>There is a further complication with non-closure anonymous subs (i.e. those that do not refer to any lexicals outside that sub). In this case, the anonymous prototype is shared rather than being cloned. This has the consequence that the parent may be freed while there are still active children,</source>
          <target state="translated">폐쇄되지 않은 익명 구독자 (즉, 해당 하위 외부의 어휘를 참조하지 않는 구독자)에는 더 복잡한 문제가 있습니다. 이 경우 익명 프로토 타입은 복제되지 않고 공유됩니다. 이것은 여전히 ​​활동적인 자식이있는 동안 부모가 해방 될 수 있다는 결과를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="2afd310e60a2687221eb36caee1877ab18ed5e49" translate="yes" xml:space="preserve">
          <source>There is a further complication with non-closure anonymous subs (i.e. those that do not refer to any lexicals outside that sub). In this case, the anonymous prototype is shared rather than being cloned. This has the consequence that the parent may be freed while there are still active children, eg</source>
          <target state="translated">비 클로저 익명 서브 (즉, 해당 서브 이외의 어휘를 참조하지 않는 서브 스크립 션)와 관련하여 더 복잡한 문제가 있습니다. 이 경우 익명 프로토 타입이 복제되지 않고 공유됩니다. 이는 여전히 활동적인 자녀가있는 동안 부모가 해방 될 수있는 결과를 초래합니다.</target>
        </trans-unit>
        <trans-unit id="6e38f9a6f0524cb60060c7ab66b100df8645a3df" translate="yes" xml:space="preserve">
          <source>There is a given/when statement in Perl, but it is experimental and likely to change in future. See &lt;a href=&quot;perlsyn&quot;&gt;perlsyn&lt;/a&gt; for more details.</source>
          <target state="translated">Perl에는 given / when 문이 있지만 실험적이며 향후 변경 될 가능성이 있습니다. 자세한 내용은 &lt;a href=&quot;perlsyn&quot;&gt;perlsyn&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="4bfd060d0feb488ff6b3d46ad13ea7e46b879b0f" translate="yes" xml:space="preserve">
          <source>There is a known bug in the</source>
          <target state="translated">에 알려진 버그가 있습니다.</target>
        </trans-unit>
        <trans-unit id="f36a7b0d4fbbd5ecb9f7c10c28ff43dbc8a0e2c1" translate="yes" xml:space="preserve">
          <source>There is a large collection of locale definitions at:</source>
          <target state="translated">로케일 정의 모음은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="164a3c40b19ffea76d12a9ba083e8f9f3b80b6e7" translate="yes" xml:space="preserve">
          <source>There is a large memory overhead for each record offset and for each cache entry: about 310 bytes per cached data record, and about 21 bytes per offset table entry.</source>
          <target state="translated">각 레코드 오프셋 및 각 캐시 항목에 대해 큰 메모리 오버 헤드가 있습니다. 캐시 된 데이터 레코드 당 약 310 바이트, 오프셋 테이블 항목 당 약 21 바이트입니다.</target>
        </trans-unit>
        <trans-unit id="6d613e26c7817a472a293f57a0848d067f1f9f1e" translate="yes" xml:space="preserve">
          <source>There is a lint variant called &lt;code&gt;splint&lt;/code&gt; (Secure Programming Lint) available from &lt;a href=&quot;http://www.splint.org/&quot;&gt;http://www.splint.org/&lt;/a&gt; that should compile on any Unix-like platform.</source>
          <target state="translated">&lt;a href=&quot;http://www.splint.org/&quot;&gt;http://www.splint.org/&lt;/a&gt; 에서 &lt;code&gt;splint&lt;/code&gt; (Secure Programming Lint) 라는 린트 변형이 있습니다 . Unix 계열 플랫폼에서 컴파일해야합니다.</target>
        </trans-unit>
        <trans-unit id="50d5366c81be8e75e037c5167a3d288dd1f93227" translate="yes" xml:space="preserve">
          <source>There is a list &lt;code&gt;=item&lt;/code&gt; right above the flagged line that has no text contents. You probably want to delete empty items.</source>
          <target state="translated">목록이 있습니다 &lt;code&gt;=item&lt;/code&gt; 텍스트가없는 플래그 된 줄 바로 위에 이 있습니다. 빈 항목을 삭제하고 싶을 것입니다.</target>
        </trans-unit>
        <trans-unit id="9491003a2d6e2370bad105f107b81a379a482390" translate="yes" xml:space="preserve">
          <source>There is a list &lt;code&gt;=item&lt;/code&gt; that has no text contents. You probably want to delete empty items.</source>
          <target state="translated">텍스트 내용이없는 list &lt;code&gt;=item&lt;/code&gt; 이 있습니다. 빈 항목을 삭제하고 싶을 것입니다.</target>
        </trans-unit>
        <trans-unit id="a1f99dfe0ca2905f67ecab8086230b0fc7ddbaec" translate="yes" xml:space="preserve">
          <source>There is a mailing list available for users of this distribution, &lt;a href=&quot;mailto:datetime@perl.org&quot;&gt;mailto:datetime@perl.org&lt;/a&gt;.</source>
          <target state="translated">이 배포판의 사용자가 사용할 수있는 메일 링리스트 인 &lt;a href=&quot;mailto:datetime@perl.org&quot;&gt;mailto : datetime@perl.org가&lt;/a&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="e52de09f7d095fa1c4329ee2a9ca8823bc2d60ff" translate="yes" xml:space="preserve">
          <source>There is a partial workaround (which can be made complete with newer OS/2 kernels): create a forwarder DLL with the same name as the DLL of the older version of Perl, which forwards the entry points to the newer Perl's DLL. Make this DLL accessible on (say) the &lt;code&gt;BEGINLIBPATH&lt;/code&gt; of the new Perl executable. When the new executable accesses old Perl's extension DLLs, they would request the old Perl's DLL by name, get the forwarder instead, so effectively will link with the currently running (new) Perl DLL.</source>
          <target state="translated">부분적인 해결 방법이 있습니다 (최신 OS / 2 커널로 완료 할 수 있음). 이전 Perl 버전의 DLL과 동일한 이름으로 전달자 DLL을 작성하여 진입 점을 새로운 Perl의 DLL로 전달합니다. 이 DLL을 새로운 Perl 실행 파일 의 &lt;code&gt;BEGINLIBPATH&lt;/code&gt; 에서 액세스 할 수있게 하십시오. 새 실행 파일이 이전 Perl의 확장 DLL에 액세스하면 이름으로 이전 Perl의 DLL을 요청하고 대신 전달자를 가져 오므로 현재 실행중인 (새) Perl DLL과 효과적으로 연결됩니다.</target>
        </trans-unit>
        <trans-unit id="d1126a23763c29c3a1bec0b9bdcdb94247472fba" translate="yes" xml:space="preserve">
          <source>There is a potential syntactic ambiguity between signatures and prototypes (see &lt;a href=&quot;#Prototypes&quot;&gt;&quot;Prototypes&quot;&lt;/a&gt;), because both start with an opening parenthesis and both can appear in some of the same places, such as just after the name in a subroutine declaration. For historical reasons, when signatures are not enabled, any opening parenthesis in such a context will trigger very forgiving prototype parsing. Most signatures will be interpreted as prototypes in those circumstances, but won't be valid prototypes. (A valid prototype cannot contain any alphabetic character.) This will lead to somewhat confusing error messages.</source>
          <target state="translated">둘 다 여는 괄호로 시작하고 둘 다 서브 루틴 선언의 이름 바로 뒤와 같은 일부 동일한 위치에 나타날 수 있기 때문에 서명과 프로토 타입 사이에 잠재적 인 구문 모호성이 있습니다 ( &lt;a href=&quot;#Prototypes&quot;&gt;&quot;Prototypes&quot;&lt;/a&gt; 참조 ). 역사적 이유로 서명이 활성화되지 않은 경우 이러한 컨텍스트의 여는 괄호는 매우 관용적 인 프로토 타입 구문 분석을 트리거합니다. 대부분의 서명은 이러한 상황에서 프로토 타입으로 해석되지만 유효한 프로토 타입은 아닙니다. (유효한 프로토 타입은 알파벳 문자를 포함 할 수 없습니다.) 이로 인해 다소 혼란스러운 오류 메시지가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="57ca9ff3bac6a75872d6256fe67ed0855ac24ebb" translate="yes" xml:space="preserve">
          <source>There is a potential syntactic ambiguity between signatures and prototypes (see &lt;a href=&quot;#Prototypes&quot;&gt;Prototypes&lt;/a&gt;), because both start with an opening parenthesis and both can appear in some of the same places, such as just after the name in a subroutine declaration. For historical reasons, when signatures are not enabled, any opening parenthesis in such a context will trigger very forgiving prototype parsing. Most signatures will be interpreted as prototypes in those circumstances, but won't be valid prototypes. (A valid prototype cannot contain any alphabetic character.) This will lead to somewhat confusing error messages.</source>
          <target state="translated">서명과 프로토 타입 사이의 잠재적 인 구문 모호성이있다 (참조 &lt;a href=&quot;#Prototypes&quot;&gt;프로토 타입을&lt;/a&gt; 여는 괄호로 시작하고 둘 모두는 단지 서브 루틴 선언의 이름 뒤에 같은 장소의 일부에 표시 할 수 있기 때문에). 역사적 이유로 서명을 사용하지 않으면 이러한 컨텍스트에서 여는 괄호는 매우 관대 한 프로토 타입 구문 분석을 트리거합니다. 이러한 상황에서는 대부분의 서명이 프로토 타입으로 해석되지만 유효한 프로토 타입은 아닙니다. 유효한 프로토 타입은 알파벳 문자를 포함 할 수 없습니다. 이로 인해 다소 혼란스러운 오류 메시지가 나타납니다.</target>
        </trans-unit>
        <trans-unit id="d27354b37f9e6840bfd23c6a2efc0450a836df2f" translate="yes" xml:space="preserve">
          <source>There is a relationship between roles and classes, as each class implies the existence of a role of the same name. There is also a relationship between inheritance and roles, in that a subclass that inherits from an ancestor class implicitly performs any roles its parent performs. Thus you can use &lt;code&gt;DOES&lt;/code&gt; in place of &lt;code&gt;isa&lt;/code&gt; safely, as it will return true in all places where &lt;code&gt;isa&lt;/code&gt; will return true (provided that any overridden &lt;code&gt;DOES&lt;/code&gt;</source>
          <target state="translated">각 클래스가 동일한 이름의 역할이 있음을 의미하므로 역할과 클래스 사이에는 관계가 있습니다. 상속 클래스와 역할 사이에는 관계가 있습니다. 상위 클래스에서 상속하는 하위 클래스는 상위 클래스가 수행하는 모든 역할을 암시 적으로 수행합니다. 따라서 당신은 사용할 수 &lt;code&gt;DOES&lt;/code&gt; 대신 &lt;code&gt;isa&lt;/code&gt; 는 모든 장소에 true를 돌려줍니다으로 안전하게 &lt;code&gt;isa&lt;/code&gt; 재정의 한 모든 것을 제공 (true를 돌려줍니다 &lt;code&gt;DOES&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d92cff32e2893123d7b11efd15dfbc88dd3973f8" translate="yes" xml:space="preserve">
          <source>There is a rich ecosystem of &lt;code&gt;Moose&lt;/code&gt; extensions on CPAN under the &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fsearch.cpan.org%2fsearch%3fquery%3dMooseX%26mode%3ddist&quot;&gt;MooseX&lt;/a&gt; namespace. In addition, many modules on CPAN already use &lt;code&gt;Moose&lt;/code&gt; , providing you with lots of examples to learn from.</source>
          <target state="translated">&lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fsearch.cpan.org%2fsearch%3fquery%3dMooseX%26mode%3ddist&quot;&gt;MooseX&lt;/a&gt; 네임 스페이스 아래 CPAN 에는 풍부한 &lt;code&gt;Moose&lt;/code&gt; 확장 에코 시스템이 있습니다. 또한 CPAN의 많은 모듈은 이미 &lt;code&gt;Moose&lt;/code&gt; 를 사용 하므로 배울 수있는 많은 예제를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="63c6a415ec649ec3fee18b8a757da8ffbc58b528" translate="yes" xml:space="preserve">
          <source>There is a rich ecosystem of &lt;code&gt;Moose&lt;/code&gt; extensions on CPAN under the &lt;a href=&quot;https://metacpan.org/search?q=MooseX&quot;&gt;MooseX&lt;/a&gt; namespace. In addition, many modules on CPAN already use &lt;code&gt;Moose&lt;/code&gt;, providing you with lots of examples to learn from.</source>
          <target state="translated">&lt;a href=&quot;https://metacpan.org/search?q=MooseX&quot;&gt;MooseX&lt;/a&gt; 네임 스페이스 아래 CPAN 에는 풍부한 &lt;code&gt;Moose&lt;/code&gt; 확장 에코 시스템이 있습니다. 또한 CPAN의 많은 모듈은 이미 &lt;code&gt;Moose&lt;/code&gt; 를 사용 하여 배울 수있는 많은 예제를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="0db652ab14c5e9efe4a7bcfa81f503ee955d3fa8" translate="yes" xml:space="preserve">
          <source>There is a section detected in the page name of L&amp;lt;...&amp;gt;, e.g. &lt;code&gt;L&amp;lt;passwd(2)&amp;gt;&lt;/code&gt; . POD hyperlinks may point to POD documents only. Please write &lt;code&gt;C&amp;lt;passwd(2)&amp;gt;&lt;/code&gt; instead. Some formatters are able to expand this to appropriate code. For links to (builtin) functions, please say &lt;code&gt;L&amp;lt;perlfunc/mkdir&amp;gt;&lt;/code&gt; , without ().</source>
          <target state="translated">L &amp;lt;...&amp;gt;의 페이지 이름에서 섹션이 발견되었습니다 &lt;code&gt;L&amp;lt;passwd(2)&amp;gt;&lt;/code&gt; 예 : L &amp;lt;passwd (2)&amp;gt;) . POD 하이퍼 링크는 POD 문서 만 가리킬 수 있습니다. 빠른 시간 내에 연락 드릴 것입니다 &lt;code&gt;C&amp;lt;passwd(2)&amp;gt;&lt;/code&gt; 대신. 일부 포맷터는이를 적절한 코드로 확장 할 수 있습니다. (내장) 함수에 대한 링크는 () 없이 &lt;code&gt;L&amp;lt;perlfunc/mkdir&amp;gt;&lt;/code&gt; 이라고 말하십시오 .</target>
        </trans-unit>
        <trans-unit id="00c1ae760ee79d8ac4a3185792db70643cfa006e" translate="yes" xml:space="preserve">
          <source>There is a single stash called &lt;code&gt;PL_defstash&lt;/code&gt; that holds the items that exist in the &lt;code&gt;main&lt;/code&gt; package. To get at the items in other packages, append the string &quot;::&quot; to the package name. The items in the &lt;code&gt;Foo&lt;/code&gt; package are in the stash &lt;code&gt;Foo::&lt;/code&gt; in PL_defstash. The items in the &lt;code&gt;Bar::Baz&lt;/code&gt; package are in the stash &lt;code&gt;Baz::&lt;/code&gt; in &lt;code&gt;Bar::&lt;/code&gt; 's stash.</source>
          <target state="translated">&lt;code&gt;main&lt;/code&gt; 패키지에 존재하는 항목을 보유하는 &lt;code&gt;PL_defstash&lt;/code&gt; 라는 단일 숨김 이 있습니다 . 다른 패키지의 항목을 얻으려면 패키지 이름에 &quot;::&quot;문자열을 추가하십시오. &lt;code&gt;Foo&lt;/code&gt; 패키지 의 항목은 PL_defstash 의 숨김 &lt;code&gt;Foo::&lt;/code&gt; 에 있습니다. &lt;code&gt;Bar::Baz&lt;/code&gt; 패키지 의 항목 은 숨김 &lt;code&gt;Baz::&lt;/code&gt; in &lt;code&gt;Bar::&lt;/code&gt; 의 숨김에 있습니다.</target>
        </trans-unit>
        <trans-unit id="da12b97e4f2d1305f926ea3b6d55a42d5c8e4baf" translate="yes" xml:space="preserve">
          <source>There is a single stash called &lt;code&gt;PL_defstash&lt;/code&gt; that holds the items that exist in the &lt;code&gt;main&lt;/code&gt; package. To get at the items in other packages, append the string &quot;::&quot; to the package name. The items in the &lt;code&gt;Foo&lt;/code&gt; package are in the stash &lt;code&gt;Foo::&lt;/code&gt; in PL_defstash. The items in the &lt;code&gt;Bar::Baz&lt;/code&gt; package are in the stash &lt;code&gt;Baz::&lt;/code&gt; in &lt;code&gt;Bar::&lt;/code&gt;'s stash.</source>
          <target state="translated">&lt;code&gt;main&lt;/code&gt; 패키지 에있는 항목을 보유하는 &lt;code&gt;PL_defstash&lt;/code&gt; 라는 단일 숨김 이 있습니다 . 다른 패키지의 항목을 가져 오려면 패키지 이름에 &quot;::&quot;문자열을 추가하십시오. &lt;code&gt;Foo&lt;/code&gt; 패키지 의 항목은 PL_defstash의 &lt;code&gt;Foo::&lt;/code&gt; 숨김 에 있습니다. &lt;code&gt;Bar::Baz&lt;/code&gt; 패키지 의 항목은 &lt;code&gt;Baz::&lt;/code&gt; in &lt;code&gt;Bar::&lt;/code&gt; 의 숨김에 있습니다.</target>
        </trans-unit>
        <trans-unit id="410d21275559c0b069f15cf1ae78b078a451978c" translate="yes" xml:space="preserve">
          <source>There is a special form of this construct, called &lt;code&gt;\K&lt;/code&gt; (available since Perl 5.10.0), which causes the regex engine to &quot;keep&quot; everything it had matched prior to the &lt;code&gt;\K&lt;/code&gt; and not include it in &lt;code&gt;$&amp;amp;&lt;/code&gt; . This effectively provides variable-length look-behind. The use of &lt;code&gt;\K&lt;/code&gt; inside of another look-around assertion is allowed, but the behaviour is currently not well defined.</source>
          <target state="translated">이 구조에는 &lt;code&gt;\K&lt;/code&gt; (Perl 5.10.0부터 사용 가능) 라는 특수한 형태가 있는데 , 이로 인해 정규식 엔진은 &lt;code&gt;\K&lt;/code&gt; 이전에 일치했던 모든 것을 &quot;유지&quot; 하고 &lt;code&gt;$&amp;amp;&lt;/code&gt; 포함시키지 않습니다 . 이것은 효과적으로 가변 길이 룩-비하인드를 제공합니다. 다른 둘러보기 어설 션 내 에서 &lt;code&gt;\K&lt;/code&gt; 사용할 수 있지만 동작은 현재 잘 정의되어 있지 않습니다.</target>
        </trans-unit>
        <trans-unit id="132434df2410147d359e3620818bc1c35f77d26b" translate="yes" xml:space="preserve">
          <source>There is a special form of this construct, called &lt;code&gt;\K&lt;/code&gt; (available since Perl 5.10.0), which causes the regex engine to &quot;keep&quot; everything it had matched prior to the &lt;code&gt;\K&lt;/code&gt; and not include it in &lt;code&gt;$&amp;amp;&lt;/code&gt;. This effectively provides non-experimental variable-length lookbehind of any length.</source>
          <target state="translated">&lt;code&gt;\K&lt;/code&gt; (Perl 5.10.0부터 사용 가능) 라고하는이 구조의 특수한 형태가 있는데 , 이는 정규식 엔진이 &lt;code&gt;\K&lt;/code&gt; 이전에 일치했던 모든 것을 &quot;유지&quot; 하고 &lt;code&gt;$&amp;amp;&lt;/code&gt; 포함시키지 않도록합니다 . 이것은 모든 길이의 실험적이지 않은 가변 길이 lookbehind를 효과적으로 제공합니다.</target>
        </trans-unit>
        <trans-unit id="0599747d66099e132ad6b9e84b12be8636f0ae4e" translate="yes" xml:space="preserve">
          <source>There is a syntax error in the /usr/include/sys/socket.h header file that IBM supplies with USS V2R7, V2R8, and possibly V2R9. The problem with the header file is that near the definition of the SO_REUSEPORT constant there is a spurious extra '/' character outside of a comment like so:</source>
          <target state="translated">/usr/include/sys/socket.h 헤더 파일에 IBM이 USS V2R7, V2R8 및 가능하면 V2R9를 제공하는 구문 오류가 있습니다. 헤더 파일의 문제점은 SO_REUSEPORT 상수의 정의 근처에 다음과 같이 주석 외부에 여분의 '/'문자가 있다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="4f5af7c338789d7b91669b50869dfdd492384f9b" translate="yes" xml:space="preserve">
          <source>There is a technique that can be used to handle variable length lookbehinds on earlier releases, and longer than 255 characters. It is described in &lt;a href=&quot;http://www.drregex.com/2019/02/variable-length-lookbehinds-actually.html&quot;&gt;http://www.drregex.com/2019/02/variable-length-lookbehinds-actually.html&lt;/a&gt;.</source>
          <target state="translated">이전 릴리스에서 255 자보다 긴 가변 길이 lookbehind를 처리하는 데 사용할 수있는 기술이 있습니다. &lt;a href=&quot;http://www.drregex.com/2019/02/variable-length-lookbehinds-actually.html&quot;&gt;http://www.drregex.com/2019/02/variable-length-lookbehinds-actually.html에&lt;/a&gt; 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="b527eadae01dab13ed85ec63c9837bc3c0c67bda" translate="yes" xml:space="preserve">
          <source>There is a tradeoff between taking full advantage of one particular type of computer and taking advantage of a full range of them. Naturally, as you broaden your range and become more diverse, the common factors drop, and you are left with an increasingly smaller area of common ground in which you can operate to accomplish a particular task. Thus, when you begin attacking a problem, it is important to consider under which part of the tradeoff curve you want to operate. Specifically, you must decide whether it is important that the task that you are coding has the full generality of being portable, or whether to just get the job done right now. This is the hardest choice to be made. The rest is easy, because Perl provides many choices, whichever way you want to approach your problem.</source>
          <target state="translated">하나의 특정 유형의 컴퓨터를 최대한 활용하는 것과 전체 범위를 활용하는 것에는 상충 관계가 있습니다. 당연히 범위를 넓히고 다양 해짐에 따라 공통 요인이 줄어들고 특정 작업을 수행하기 위해 운영 할 수있는 공통 영역이 점점 더 작아집니다. 따라서 문제를 공격하기 시작할 때, 트레이드 오프 곡선의 어느 부분을 운영 할 것인지 고려해야합니다. 특히, 코딩하는 작업이 이식 가능한 일반성을 갖도록하는 것이 중요한지 아니면 지금 당장 작업을 수행 할 것인지 결정해야합니다. 가장 어려운 선택입니다. Perl은 많은 선택을 제공하기 때문에 문제가 발생하기 쉽습니다.</target>
        </trans-unit>
        <trans-unit id="8ea25b9abfe4373f567bc9679e7275e7fb164486" translate="yes" xml:space="preserve">
          <source>There is a utility called &lt;a href=&quot;../corelist&quot;&gt;corelist&lt;/a&gt; provided with this module which is a convenient way of querying from the command-line.</source>
          <target state="translated">이 모듈에는 명령 줄에서 편리하게 쿼리 할 수있는 &lt;a href=&quot;../corelist&quot;&gt;corelist&lt;/a&gt; 라는 유틸리티가 있습니다 .</target>
        </trans-unit>
        <trans-unit id="26e6ac611235e43f07c357cfef8c6952cf104cdd" translate="yes" xml:space="preserve">
          <source>There is a utility called &lt;a href=&quot;corelist&quot;&gt;corelist&lt;/a&gt; provided with this module which is a convenient way of querying from the command-line.</source>
          <target state="translated">이 모듈과 함께 제공되는 &lt;a href=&quot;corelist&quot;&gt;corelist&lt;/a&gt; 라는 유틸리티 가있어 명령 줄에서 편리하게 쿼리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="82aef8cfd5e32e2a307fc10353cb3d2e49f98a7d" translate="yes" xml:space="preserve">
          <source>There is a variable &lt;code&gt;$File::Find::fullname&lt;/code&gt; which holds the absolute pathname of the file with all symbolic links resolved. If the link is a dangling symbolic link, then fullname will be set to &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">모든 심볼릭 링크가 해결 된 파일의 절대 경로 이름을 보유하는 &lt;code&gt;$File::Find::fullname&lt;/code&gt; 변수가 있습니다 . 링크가 매달려있는 심볼릭 링크 인 경우 fullname은 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 로 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="973df2b639c4d3b005a76e2b6bc5345ee00adfab" translate="yes" xml:space="preserve">
          <source>There is a variable &lt;code&gt;$File::Find::fullname&lt;/code&gt; which holds the absolute pathname of the file with all symbolic links resolved. If the link is a dangling symbolic link, then fullname will be set to &lt;code&gt;undef&lt;/code&gt;.</source>
          <target state="translated">모든 심볼릭 링크가 해결 된 파일의 절대 경로 이름을 보유하는 &lt;code&gt;$File::Find::fullname&lt;/code&gt; 변수가 있습니다 . 링크가 매달려있는 심볼릭 링크 인 경우 fullname이 &lt;code&gt;undef&lt;/code&gt; 로 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="3b9ea31c4237da29f14d09c3e17b0abf6058f6c2" translate="yes" xml:space="preserve">
          <source>There is a way to achieve a similar task from C via Perl API: create a</source>
          <target state="translated">Perl API를 통해 C에서 비슷한 작업을 수행하는 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="186d9ac4ec1df84f73c4528af239edb0b67d87e7" translate="yes" xml:space="preserve">
          <source>There is a way to completely hide any modifiable globals (they are all moved to heap), the compilation setting &lt;code&gt;-DPERL_GLOBAL_STRUCT_PRIVATE&lt;/code&gt; . It is not normally used, but can be used for testing, read more about it in &lt;a href=&quot;perlguts#Background-and-PERL_IMPLICIT_CONTEXT&quot;&gt;Background and PERL_IMPLICIT_CONTEXT in perlguts&lt;/a&gt;.</source>
          <target state="translated">컴파일 가능한 &lt;code&gt;-DPERL_GLOBAL_STRUCT_PRIVATE&lt;/code&gt; 수정 가능한 글로벌을 모두 숨기는 방법이 있습니다 (모두 힙으로 이동 됨) . 일반적으로 사용되지는 않지만 테스트에 사용될 수 있습니다 . &lt;a href=&quot;perlguts#Background-and-PERL_IMPLICIT_CONTEXT&quot;&gt;백그라운드&lt;/a&gt; 에서 자세한 내용을 확인 하고 perlguts에서 PERL_IMPLICIT_CONTEXT를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f6e88f7ecf4798ea1155b449543fac9f0b354b61" translate="yes" xml:space="preserve">
          <source>There is a way to completely hide any modifiable globals (they are all moved to heap), the compilation setting &lt;code&gt;-DPERL_GLOBAL_STRUCT_PRIVATE&lt;/code&gt;. It is not normally used, but can be used for testing, read more about it in &lt;a href=&quot;perlguts#Background-and-PERL_IMPLICIT_CONTEXT&quot;&gt;&quot;Background and PERL_IMPLICIT_CONTEXT&quot; in perlguts&lt;/a&gt;.</source>
          <target state="translated">수정 가능한 전역 (모두 힙으로 이동 됨)을 완전히 숨기는 방법이 있습니다 . 컴파일 설정은 &lt;code&gt;-DPERL_GLOBAL_STRUCT_PRIVATE&lt;/code&gt; 입니다. 일반적으로 사용되지는 않지만 테스트에 사용할 수 있습니다. 자세한 내용은 &lt;a href=&quot;perlguts#Background-and-PERL_IMPLICIT_CONTEXT&quot;&gt;perlguts의 &quot;Background and PERL_IMPLICIT_CONTEXT&quot;를 참조하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="887ba5df14249dda0cf87b4c4aa3777b9fca5f36" translate="yes" xml:space="preserve">
          <source>There is a way to tell perl to do complete cleanup: set the environment variable PERL_DESTRUCT_LEVEL to a non-zero value. The t/TEST wrapper does set this to 2, and this is what you need to do too, if you don't want to see the &quot;global leaks&quot;: For example, for running under valgrind</source>
          <target state="translated">펄에게 정리를 완료하도록 지시하는 방법이 있습니다 : 환경 변수 PERL_DESTRUCT_LEVEL을 0이 아닌 값으로 설정하십시오. t / TEST 래퍼는 이것을 2로 설정하고 &quot;글로벌 누출&quot;을보고 싶지 않다면 다음과 같이해야합니다. 예를 들어 valgrind에서 실행</target>
        </trans-unit>
        <trans-unit id="691cdea86f4db4ba9a2ac59e7fc6b55f031421ad" translate="yes" xml:space="preserve">
          <source>There is absolutely no excuse for not documenting your extension. Documentation belongs in the .pm file. This file will be fed to pod2man, and the embedded documentation will be converted to the manpage format, then placed in the blib directory. It will be copied to Perl's manpage directory when the extension is installed.</source>
          <target state="translated">확장명을 문서화하지 않은 것에 대한 변명은 없습니다. 문서는 .pm 파일에 속합니다. 이 파일은 pod2man에 제공되고 내장 된 설명서는 맨 페이지 형식으로 변환 된 다음 blib 디렉토리에 저장됩니다. 확장이 설치되면 Perl의 맨 페이지 디렉토리로 복사됩니다.</target>
        </trans-unit>
        <trans-unit id="d8cca778f6ffeefe438e516146882fedcff922a7" translate="yes" xml:space="preserve">
          <source>There is also &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; bigrat;&lt;/code&gt; which gives you big rationals:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; bigrat;&lt;/code&gt; 도 &lt;a href=&quot;functions/use&quot;&gt;사용&lt;/a&gt; 됩니다. 그것은 당신에게 큰 합리성을 제공합니다 :</target>
        </trans-unit>
        <trans-unit id="9cf519c73fbae0fe8c0d4ffe79764b81487dc294" translate="yes" xml:space="preserve">
          <source>There is also &lt;code&gt;use bigrat;&lt;/code&gt; which gives you big rationals:</source>
          <target state="translated">&lt;code&gt;use bigrat;&lt;/code&gt; 도 있습니다. 큰 합리성을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="43bcf99a2a57a573a071e20e50556250aa32095b" translate="yes" xml:space="preserve">
          <source>There is also a function to add magic to an &lt;code&gt;HV&lt;/code&gt; :</source>
          <target state="translated">&lt;code&gt;HV&lt;/code&gt; 에 마법을 추가하는 기능도 있습니다 :</target>
        </trans-unit>
        <trans-unit id="5e09c6821154895943bc8dd098914ffb05015157" translate="yes" xml:space="preserve">
          <source>There is also a function to add magic to an &lt;code&gt;HV&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;HV&lt;/code&gt; 에 마법을 추가하는 기능도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8f310316f81fc52692e5ac947e6e74f350603233" translate="yes" xml:space="preserve">
          <source>There is also a larger form of a char class structure used to represent POSIX char classes under &lt;code&gt;/l&lt;/code&gt; matching, called &lt;code&gt;regnode_charclass_posixl&lt;/code&gt; which has an additional 32-bit bitmap indicating which POSIX char classes have been included.</source>
          <target state="translated">&lt;code&gt;/l&lt;/code&gt; 일치하는 POSIX 문자 클래스를 나타내는 데 사용되는 더 큰 형식의 char 클래스 구조도 있습니다. &lt;code&gt;regnode_charclass_posixl&lt;/code&gt; 은 POSIX 문자 클래스가 포함되어 있음을 나타내는 추가 32 비트 비트 맵이 있습니다.</target>
        </trans-unit>
        <trans-unit id="76c5f483367def15ac8c922d54c4856b499dee91" translate="yes" xml:space="preserve">
          <source>There is also a mailing list available for users of this distribution, at &lt;a href=&quot;http://lists.perl.org/list/cpan-workers.html&quot;&gt;http://lists.perl.org/list/cpan-workers.html&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://lists.perl.org/list/cpan-workers.html&quot;&gt;http://lists.perl.org/list/cpan-workers.html&lt;/a&gt; 에서이 배포의 사용자가 사용할 수있는 메일 링 목록도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8c1a33cdb5c1f767d6b5b045c29afd70795ca96e" translate="yes" xml:space="preserve">
          <source>There is also a toyedit Text widget based editor written in Perl that is distributed with the Tk module on CPAN. The ptkdb ( &lt;a href=&quot;http://ptkdb.sourceforge.net/&quot;&gt;http://ptkdb.sourceforge.net/&lt;/a&gt; ) is a Perl/Tk-based debugger that acts as a development environment of sorts. Perl Composer ( &lt;a href=&quot;http://perlcomposer.sourceforge.net/&quot;&gt;http://perlcomposer.sourceforge.net/&lt;/a&gt; ) is an IDE for Perl/Tk GUI creation.</source>
          <target state="translated">CPAN의 Tk 모듈과 함께 배포되는 Perl로 작성된 toyedit Text 위젯 기반 편집기도 있습니다. ptkdb ( &lt;a href=&quot;http://ptkdb.sourceforge.net/&quot;&gt;http://ptkdb.sourceforge.net/&lt;/a&gt; )는 일종의 개발 환경으로 작동하는 Perl / Tk 기반 디버거입니다. Perl Composer ( &lt;a href=&quot;http://perlcomposer.sourceforge.net/&quot;&gt;http://perlcomposer.sourceforge.net/&lt;/a&gt; )는 Perl / Tk GUI 작성을위한 IDE입니다.</target>
        </trans-unit>
        <trans-unit id="d6fbaba8f9d7c369b3de63f57e236ae1dbe1ef42" translate="yes" xml:space="preserve">
          <source>There is also an irc channel available for users of this distribution, at &lt;a href=&quot;irc://irc.perl.org/#toolchain&quot;&gt;&lt;code&gt;#toolchain&lt;/code&gt; on &lt;code&gt;irc.perl.org&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">에서이 배포의 사용자가 사용할 수있는 IRC 채널도 있습니다 &lt;a href=&quot;irc://irc.perl.org/#toolchain&quot;&gt; &lt;code&gt;#toolchain&lt;/code&gt; 에 &lt;code&gt;irc.perl.org&lt;/code&gt; 은&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d533bbf93c93c54738d070099b6cc38c79c4b031" translate="yes" xml:space="preserve">
          <source>There is an active user community that provides many software packages for the Synology DSM systems; at the time of writing this document they provide Perl version 5.24.1.</source>
          <target state="translated">Synology DSM 시스템을위한 많은 소프트웨어 패키지를 제공하는 활성 사용자 커뮤니티가 있습니다. 이 문서를 작성하는 시점에서 그들은 Perl 버전 5.24.1을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="ace8b22bc48d6e6e8b62fe08966c97467280b304" translate="yes" xml:space="preserve">
          <source>There is an edge case when using &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next::method&lt;/a&gt;&lt;/code&gt; from within a subroutine which was created in a different module than the one it is called from. It sounds complicated, but it really isn't. Here is an example which will not work correctly:</source>
          <target state="translated">호출 된 것과 다른 모듈에서 작성된 서브 루틴 내에서 &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next::method&lt;/a&gt;&lt;/code&gt; 를 사용할 때 가장 중요한 경우 가 있습니다. 복잡해 보이지만 실제로는 그렇지 않습니다. 다음은 올바르게 작동하지 않는 예입니다.</target>
        </trans-unit>
        <trans-unit id="689977e776e24b93188512fdd38744344797e09f" translate="yes" xml:space="preserve">
          <source>There is an edge case when using &lt;code&gt;next::method&lt;/code&gt; from within a subroutine which was created in a different module than the one it is called from. It sounds complicated, but it really isn't. Here is an example which will not work correctly:</source>
          <target state="translated">호출 된 모듈과 다른 모듈에서 생성 된 서브 루틴 내에서 &lt;code&gt;next::method&lt;/code&gt; 를 사용하는 경우에는 예외적 인 경우 가 있습니다. 복잡하게 들리지만 실제로는 그렇지 않습니다. 다음은 올바르게 작동하지 않는 예입니다.</target>
        </trans-unit>
        <trans-unit id="407ad0e2a6f54d3dcabda775887575e4b7a50908" translate="yes" xml:space="preserve">
          <source>There is another directory ($CPAN::Config-&amp;gt;{keep_source_where}) where the original distribution files are kept. This directory is not covered by the cache manager and must be controlled by the user. If you choose to have the same directory as build_dir and as keep_source_where directory, then your sources will be deleted with the same fifo mechanism.</source>
          <target state="translated">원본 배포 파일이 보관되는 다른 디렉토리 ($ CPAN :: Config-&amp;gt; {keep_source_where})가 있습니다. 이 디렉토리는 캐쉬 관리 프로그램에서 다루지 않으며 사용자가 제어해야합니다. build_dir 및 keep_source_where 디렉토리와 동일한 디렉토리를 선택하면 동일한 fifo 메커니즘으로 소스가 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="58cdb83a1e784fb0e74fd64a5af55da9c7c710fa" translate="yes" xml:space="preserve">
          <source>There is another method which can be used, namely letting Perl do it for you automatically whenever it regains control after the callback has terminated. This is done by simply not using the</source>
          <target state="translated">콜백이 종료 된 후 제어권을 다시 확보 할 때마다 Perl이 자동으로 처리하도록하는 또 다른 방법이 있습니다. 이것은 단순히</target>
        </trans-unit>
        <trans-unit id="259d1525b7b40afbda3635dfb60885ec2065cd0c" translate="yes" xml:space="preserve">
          <source>There is another way to trade clarity for compactness: INPUT sections allow declaration of C variables which do not appear in the parameter list of a subroutine. Thus the above code for mutate() can be rewritten as</source>
          <target state="translated">간결성을 위해 명확성을 교환하는 또 다른 방법이 있습니다. INPUT 섹션에서는 서브 루틴의 매개 변수 목록에 나타나지 않는 C 변수를 선언 할 수 있습니다. 따라서 mutate ()에 대한 위의 코드는 다음과 같이 다시 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="69c800bd073688bcd19d75ca494a0e096bef464f" translate="yes" xml:space="preserve">
          <source>There is currently no method for going the other way; but I can probably provide one upon request.</source>
          <target state="translated">현재 다른 방향으로 갈 수있는 방법은 없습니다. 하지만 요청시 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6993af1c1a90a2fde20c8f99658cf4ef71df4e8c" translate="yes" xml:space="preserve">
          <source>There is currently no way to turn off the guesswork that tries to format unmarked text appropriately, and sometimes it isn't wanted (particularly when using POD to document something other than Perl). Most of the work toward fixing this has now been done, however, and all that's still needed is a user interface.</source>
          <target state="translated">현재 표시되지 않은 텍스트를 적절하게 형식화하려는 추측을 끄는 방법이 없으며 때로는 원하지 않습니다 (특히 POD를 사용하여 Perl 이외의 것을 문서화 할 때). 그러나이 문제를 해결하기위한 대부분의 작업이 완료되었지만 여전히 필요한 것은 사용자 인터페이스입니다.</target>
        </trans-unit>
        <trans-unit id="658a8d7bbc3f0f0bd3eee360c95b181c02d32e56" translate="yes" xml:space="preserve">
          <source>There is lots more to bracketed character classes; full details are in &lt;a href=&quot;perlrecharclass#Bracketed-Character-Classes&quot;&gt;&quot;Bracketed Character Classes&quot; in perlrecharclass&lt;/a&gt;.</source>
          <target state="translated">대괄호 문자 클래스에는 더 많은 것이 있습니다. 자세한 내용은 &lt;a href=&quot;perlrecharclass#Bracketed-Character-Classes&quot;&gt;perlrecharclass의 &quot;브라켓 문자 클래스&quot;에 있습니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="923e1f4510dc236d985b28a823797fd535b1836b" translate="yes" xml:space="preserve">
          <source>There is no</source>
          <target state="translated">없습니다</target>
        </trans-unit>
        <trans-unit id="4ac6b5cad845dedcdb84c876c16dd65a46ac7fff" translate="yes" xml:space="preserve">
          <source>There is no 2GB limit on process size.</source>
          <target state="translated">프로세스 크기에는 2GB 제한이 없습니다.</target>
        </trans-unit>
        <trans-unit id="4389ed97cd408884e879872fd75e0815bd058c0d" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;*.bs&lt;/code&gt; file supplied with the extension. Instead, there may be a &lt;code&gt;*_BS&lt;/code&gt; file which has code for the special cases, like posix for berkeley db on the NeXT.</source>
          <target state="translated">확장명과 함께 제공되는 &lt;code&gt;*.bs&lt;/code&gt; 파일 이 없습니다 . 대신 NeXT의 버클리 db에 대한 posix와 같은 특수한 경우에 대한 코드 가있는 &lt;code&gt;*_BS&lt;/code&gt; 파일이 있을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f9908fb44bd4986c8ec4678f0acbb2e49a902c07" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;systell&lt;/code&gt; function. Use &lt;a href=&quot;#sysseek-FILEHANDLE%2CPOSITION%2CWHENCE&quot;&gt;&lt;code&gt;sysseek($fh, 0, 1)&lt;/code&gt;&lt;/a&gt; for that.</source>
          <target state="translated">&lt;code&gt;systell&lt;/code&gt; 기능 이 없습니다 . 이를 &lt;a href=&quot;#sysseek-FILEHANDLE%2CPOSITION%2CWHENCE&quot;&gt; &lt;code&gt;sysseek($fh, 0, 1)&lt;/code&gt; &lt;/a&gt; 을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="e0b489252bb15e6f1ecbef798ed7f66f86847082" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;systell&lt;/code&gt; function. Use &lt;code&gt;&lt;a href=&quot;functions/sysseek&quot;&gt;sysseek&lt;/a&gt;(FH, 0, 1)&lt;/code&gt; for that.</source>
          <target state="translated">&lt;code&gt;systell&lt;/code&gt; 기능 이 없습니다 . 이를 &lt;code&gt;&lt;a href=&quot;functions/sysseek&quot;&gt;sysseek&lt;/a&gt;(FH, 0, 1)&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="6ea7c815b6a5bfae1bac221a98896771b7bb3184" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;systell&lt;/code&gt; function. Use &lt;code&gt;&lt;a href=&quot;sysseek&quot;&gt;sysseek&lt;/a&gt;(FH, 0, 1)&lt;/code&gt; for that.</source>
          <target state="translated">&lt;code&gt;systell&lt;/code&gt; 기능 이 없습니다 . 이를 &lt;code&gt;&lt;a href=&quot;sysseek&quot;&gt;sysseek&lt;/a&gt;(FH, 0, 1)&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="76a2f2ea0128a2c9f814d14705cbf22fee6bb330" translate="yes" xml:space="preserve">
          <source>There is no BNF, but you can paw your way through the yacc grammar in perly.y in the source distribution if you're particularly brave. The grammar relies on very smart tokenizing code, so be prepared to venture into toke.c as well.</source>
          <target state="translated">BNF는 없지만 특히 용감한 경우 소스 배포판에서 perly.y의 yacc 문법을 사용할 수 있습니다. 문법은 매우 똑똑한 토큰 화 코드에 의존하므로 toke.c로도 활용할 준비를하십시오.</target>
        </trans-unit>
        <trans-unit id="32ad1aee364e105dad5b41374df7e156cb6a43e2" translate="yes" xml:space="preserve">
          <source>There is no advantage to putting subroutines which will _always_ be called after the &lt;code&gt;__DATA__&lt;/code&gt; token.</source>
          <target state="translated">&lt;code&gt;__DATA__&lt;/code&gt; 토큰 다음에 _always_가 호출되는 서브 루틴을 배치 할 경우 이점이 없습니다 .</target>
        </trans-unit>
        <trans-unit id="a280984dba8147f4930e83be6fff5dcdd90c3af1" translate="yes" xml:space="preserve">
          <source>There is no builtin &lt;a href=&quot;#import-LIST&quot;&gt;&lt;code&gt;import&lt;/code&gt;&lt;/a&gt; function. It is just an ordinary method (subroutine) defined (or inherited) by modules that wish to export names to another module. The &lt;a href=&quot;#use-Module-VERSION-LIST&quot;&gt;&lt;code&gt;use&lt;/code&gt;&lt;/a&gt; function calls the &lt;a href=&quot;#import-LIST&quot;&gt;&lt;code&gt;import&lt;/code&gt;&lt;/a&gt; method for the package used. See also &lt;a href=&quot;#use-Module-VERSION-LIST&quot;&gt;&lt;code&gt;use&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;perlmod&quot;&gt;perlmod&lt;/a&gt;, and &lt;a href=&quot;exporter&quot;&gt;Exporter&lt;/a&gt;.</source>
          <target state="translated">내장 &lt;a href=&quot;#import-LIST&quot;&gt; &lt;code&gt;import&lt;/code&gt; &lt;/a&gt; 기능 이 없습니다 . 이름을 다른 모듈로 내보내려는 모듈에 의해 정의 된 (또는 상속 된) 일반적인 메서드 (서브 루틴)입니다. &lt;a href=&quot;#use-Module-VERSION-LIST&quot;&gt; &lt;code&gt;use&lt;/code&gt; &lt;/a&gt; 기능은 호출 &lt;a href=&quot;#import-LIST&quot;&gt; &lt;code&gt;import&lt;/code&gt; &lt;/a&gt; 사용되는 패키지 방법을. &lt;a href=&quot;#use-Module-VERSION-LIST&quot;&gt; &lt;code&gt;use&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;perlmod&quot;&gt;perlmod&lt;/a&gt; 및 &lt;a href=&quot;exporter&quot;&gt;Exporter를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e91dc6d303227194ff188b9dc751fb889211ca0d" translate="yes" xml:space="preserve">
          <source>There is no builtin &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; function. It is just an ordinary method (subroutine) defined (or inherited) by modules that wish to export names to another module. The &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; function calls the &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; method for the package used. See also &lt;a href=&quot;#use&quot;&gt;use&lt;/a&gt;, &lt;a href=&quot;perlmod&quot;&gt;perlmod&lt;/a&gt;, and &lt;a href=&quot;exporter&quot;&gt;Exporter&lt;/a&gt;.</source>
          <target state="translated">내장 된 &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; 기능 이 없습니다 . 이름을 다른 모듈로 내보내려는 모듈에 의해 정의되거나 상속되는 일반적인 방법 (서브 루틴)입니다. &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 기능은 호출 &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; 사용되는 패키지 방법을. &lt;a href=&quot;#use&quot;&gt;use&lt;/a&gt; , &lt;a href=&quot;perlmod&quot;&gt;perlmod&lt;/a&gt; 및 &lt;a href=&quot;exporter&quot;&gt;Exporter&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="fe76bcf1a7a27510fd944eef657a41eda4d72a44" translate="yes" xml:space="preserve">
          <source>There is no builtin &lt;code&gt;&lt;a href=&quot;import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; function. It is just an ordinary method (subroutine) defined (or inherited) by modules that wish to export names to another module. The &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; function calls the &lt;code&gt;&lt;a href=&quot;import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; method for the package used. See also &lt;a href=&quot;use&quot;&gt;use&lt;/a&gt;, &lt;a href=&quot;../perlmod&quot;&gt;perlmod&lt;/a&gt;, and &lt;a href=&quot;../exporter&quot;&gt;Exporter&lt;/a&gt;.</source>
          <target state="translated">내장 된 &lt;code&gt;&lt;a href=&quot;import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; 기능 이 없습니다 . 이름을 다른 모듈로 내보내려는 모듈에 의해 정의되거나 상속되는 일반적인 방법 (서브 루틴)입니다. &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 기능은 호출 &lt;code&gt;&lt;a href=&quot;import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; 사용되는 패키지 방법을. &lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; , &lt;a href=&quot;../perlmod&quot;&gt;perlmod&lt;/a&gt; 및 &lt;a href=&quot;../exporter&quot;&gt;Exporter&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="05fb5ccde6fe684391b3c4f8ff40b801e9c52e40" translate="yes" xml:space="preserve">
          <source>There is no builtin way to say &quot;float this to the right hand side of the page, however wide it is.&quot; You have to specify where it goes. The truly desperate can generate their own format on the fly, based on the current number of columns, and then eval() it:</source>
          <target state="translated">&quot;이것을 페이지 오른쪽에 띄우지 만 넓게&quot;라고 말하는 내장 된 방법은 없습니다. 어디로 가야하는지 지정해야합니다. 진정으로 절망적 인 사람들은 현재 열 수를 기반으로 즉시 자체 형식을 생성 한 다음 eval () 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5ec86a2b5c6a22a41774d9be82dd0c618a3c5c45" translate="yes" xml:space="preserve">
          <source>There is no check to assert that the filehandle passed from Perl to C was created with the right &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; mode.</source>
          <target state="translated">Perl에서 C로 전달 된 파일 핸들이 올바른 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; 모드 로 작성되었는지 확인하는 점검은 없습니다 .</target>
        </trans-unit>
        <trans-unit id="218dbdb05fa2faf351feae2d57dfa67d5a01ea2a" translate="yes" xml:space="preserve">
          <source>There is no check to assert that the filehandle passed from Perl to C was created with the right &lt;code&gt;open()&lt;/code&gt; mode.</source>
          <target state="translated">Perl에서 C로 전달 된 파일 핸들이 올바른 &lt;code&gt;open()&lt;/code&gt; 모드 로 생성되었는지 확인하는 검사는 없습니다 .</target>
        </trans-unit>
        <trans-unit id="4297cc5a425f7dacf2e1ca88cce095827acd4bc7" translate="yes" xml:space="preserve">
          <source>There is no data immediately after the compressed data stream.</source>
          <target state="translated">압축 된 데이터 스트림 바로 뒤에는 데이터가 없습니다.</target>
        </trans-unit>
        <trans-unit id="784e961111d5a1435645faa2fd65cc0510bda63f" translate="yes" xml:space="preserve">
          <source>There is no decrypt function. This function isn't all that useful for cryptography (for that, look for</source>
          <target state="translated">암호 해독 기능이 없습니다. 이 기능이 암호화에 유용한 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="7d50acdbf96ea291176f3a2d7e886b2944e1f2b9" translate="yes" xml:space="preserve">
          <source>There is no description given for most non-Perl defined properties (See &lt;a href=&quot;http://www.unicode.org/reports/tr44/&quot;&gt;http://www.unicode.org/reports/tr44/&lt;/a&gt; for that).</source>
          <target state="translated">대부분의 비 Perl 정의 속성에 대한 설명은 없습니다 ( &lt;a href=&quot;http://www.unicode.org/reports/tr44/&quot;&gt;http://www.unicode.org/reports/tr44/&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="efbf1382c6e11055de15bc7597f5ea124690d870" translate="yes" xml:space="preserve">
          <source>There is no double interpolation in Perl, so the &lt;code&gt;$100&lt;/code&gt; is left as is.</source>
          <target state="translated">Perl에는 이중 보간이 없으므로 &lt;code&gt;$100&lt;/code&gt; 은 그대로 남아 있습니다.</target>
        </trans-unit>
        <trans-unit id="455b851bfe4dcf94993aa6ab9485d19207a20655" translate="yes" xml:space="preserve">
          <source>There is no easy way to provide this functionality in &lt;code&gt;Archive::Tar&lt;/code&gt; , because a tarball can contain many files, and each of which could be encoded in a different way.</source>
          <target state="translated">tarball은 많은 파일을 포함 할 수 있고 각 파일은 다른 방식으로 인코딩 될 수 있기 때문에 &lt;code&gt;Archive::Tar&lt;/code&gt; 에서이 기능을 제공하는 쉬운 방법은 없습니다 .</target>
        </trans-unit>
        <trans-unit id="5f678f49ea0f0b1f3db41874eff418b0f56e6c16" translate="yes" xml:space="preserve">
          <source>There is no easy way to provide this functionality in &lt;code&gt;Archive::Tar&lt;/code&gt;, because a tarball can contain many files, and each of which could be encoded in a different way.</source>
          <target state="translated">이 기능을 &lt;code&gt;Archive::Tar&lt;/code&gt; 에서 제공하는 쉬운 방법은 없습니다 . 타르볼은 많은 파일을 포함 할 수 있고 각 파일은 다른 방식으로 인코딩 될 수 있기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="27f49800696d7a52910d2aa32267a02c4e742caa" translate="yes" xml:space="preserve">
          <source>There is no equivalent operator to force an expression to be interpolated in list context because in practice, this is never needed. If you really wanted to do so, however, you could use the construction &lt;code&gt;@{[ (some expression) ]}&lt;/code&gt; , but usually a simple &lt;code&gt;(some expression)&lt;/code&gt; suffices.</source>
          <target state="translated">실제로는 이것이 절대로 필요하지 않기 때문에 목록 컨텍스트에서 표현식을 보간하는 동등한 연산자가 없습니다. 그러나 실제로 그렇게하고 싶다면 &lt;code&gt;@{[ (some expression) ]}&lt;/code&gt; 구성을 사용할 수 있지만 일반적으로 간단한 &lt;code&gt;(some expression)&lt;/code&gt; 이면 충분합니다.</target>
        </trans-unit>
        <trans-unit id="7cb80803d06b14ddbd06119d95cbdefe4be98fc5" translate="yes" xml:space="preserve">
          <source>There is no equivalent operator to force an expression to be interpolated in list context because in practice, this is never needed. If you really wanted to do so, however, you could use the construction &lt;code&gt;@{[ (some expression) ]}&lt;/code&gt;, but usually a simple &lt;code&gt;(some expression)&lt;/code&gt; suffices.</source>
          <target state="translated">실제로는 필요하지 않기 때문에 목록 컨텍스트에서 식을 보간하는 것과 동일한 연산자가 없습니다. 그러나 정말로 그렇게하고 싶다면 &lt;code&gt;@{[ (some expression) ]}&lt;/code&gt; 구성을 사용할 수 있지만 일반적으로 간단한 &lt;code&gt;(some expression)&lt;/code&gt; 이면 충분합니다.</target>
        </trans-unit>
        <trans-unit id="6da385daea49ac6d957f9692c325e916978ed205" translate="yes" xml:space="preserve">
          <source>There is no equivalent to &lt;code&gt;fgets&lt;/code&gt; ; one should use &lt;code&gt;sv_gets&lt;/code&gt; instead:</source>
          <target state="translated">&lt;code&gt;fgets&lt;/code&gt; 과 동등한 것은 없습니다 . 대신 &lt;code&gt;sv_gets&lt;/code&gt; 를 사용해야 합니다.</target>
        </trans-unit>
        <trans-unit id="9c4f353571f4abb0cafbf257cbbb852b1668ac0d" translate="yes" xml:space="preserve">
          <source>There is no equivalent to &lt;code&gt;fgets&lt;/code&gt;; one should use &lt;code&gt;sv_gets&lt;/code&gt; instead:</source>
          <target state="translated">&lt;code&gt;fgets&lt;/code&gt; 에 해당하는 것은 없습니다 . 대신 &lt;code&gt;sv_gets&lt;/code&gt; 를 사용해야 합니다.</target>
        </trans-unit>
        <trans-unit id="56b2b22bb272d9529f5a7b2eeb648640b188c1f1" translate="yes" xml:space="preserve">
          <source>There is no firewall</source>
          <target state="translated">방화벽이 없습니다</target>
        </trans-unit>
        <trans-unit id="121835ac892ea37b942952f42c3ffe4014099c6d" translate="yes" xml:space="preserve">
          <source>There is no general solution to all of this. It is a mess.</source>
          <target state="translated">이 모든 것에 대한 일반적인 해결책은 없습니다. 엉망입니다.</target>
        </trans-unit>
        <trans-unit id="87f0999d25c4eb3604c738b2e0116726668320dd" translate="yes" xml:space="preserve">
          <source>There is no general solution to all of this. It's just a mess.</source>
          <target state="translated">이 모든 것에 대한 일반적인 해결책은 없습니다. 그냥 엉망입니다.</target>
        </trans-unit>
        <trans-unit id="b2b55e890caeb51d36e6b91d2ac8fcb1b35de4f5" translate="yes" xml:space="preserve">
          <source>There is no interface to request alternative CHECK behavior as for decode_argv(). If you need that you need to call encode/decode yourself. For example:</source>
          <target state="translated">decode_argv ()와 같이 대체 CHECK 동작을 요청하는 인터페이스가 없습니다. 필요한 경우 인코딩 / 디코딩을 직접 호출해야합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e2b8fcbb171cbccbd111cd2bd311ab6e6fcd1a58" translate="yes" xml:space="preserve">
          <source>There is no low precedence operator for defined-OR.</source>
          <target state="translated">정의 된 OR에 대해서는 우선 순위가 낮은 연산자가 없습니다.</target>
        </trans-unit>
        <trans-unit id="a8da251185c2a49373fb6cf76b3c29c18692d780" translate="yes" xml:space="preserve">
          <source>There is no need to inherit from the &lt;b&gt;SelfLoader&lt;/b&gt;.</source>
          <target state="translated">&lt;b&gt;SelfLoader&lt;/b&gt; 에서 상속 할 필요가 없습니다 .</target>
        </trans-unit>
        <trans-unit id="6e895b74ce6094374e60e95c58a0d18a65714b5a" translate="yes" xml:space="preserve">
          <source>There is no need to upgrade if you already have it installed.</source>
          <target state="translated">이미 설치되어있는 경우 업그레이드 할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="6f9d8d1ae5518832290b8aa40a4082b8960c7be8" translate="yes" xml:space="preserve">
          <source>There is no one DBM module available on all platforms. &lt;a href=&quot;sdbm_file&quot;&gt;&lt;code&gt;SDBM_File&lt;/code&gt;&lt;/a&gt; and the others are generally available on all Unix and DOSish ports, but not in MacPerl, where only &lt;a href=&quot;ndbm_file&quot;&gt;&lt;code&gt;NDBM_File&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;db_file&quot;&gt;&lt;code&gt;DB_File&lt;/code&gt;&lt;/a&gt; are available.</source>
          <target state="translated">모든 플랫폼에서 사용할 수있는 DBM 모듈은 없습니다. &lt;a href=&quot;sdbm_file&quot;&gt; &lt;code&gt;SDBM_File&lt;/code&gt; &lt;/a&gt; 및 기타는 일반적으로 모든 Unix 및 DOSish 포트에서 사용할 수 있지만 &lt;a href=&quot;ndbm_file&quot;&gt; &lt;code&gt;NDBM_File&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;db_file&quot;&gt; &lt;code&gt;DB_File&lt;/code&gt; &lt;/a&gt; 만 사용할 수있는 MacPerl 에서는 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="0d3cd63858e09b2c6b6ec38df40d5828e10651d9" translate="yes" xml:space="preserve">
          <source>There is no one DBM module available on all platforms. &lt;code&gt;SDBM_File&lt;/code&gt; and the others are generally available on all Unix and DOSish ports, but not in MacPerl, where only &lt;code&gt;NDBM_File&lt;/code&gt; and &lt;code&gt;DB_File&lt;/code&gt; are available.</source>
          <target state="translated">모든 플랫폼에서 사용 가능한 DBM 모듈이 하나도 없습니다. &lt;code&gt;SDBM_File&lt;/code&gt; 및 기타는 일반적으로 모든 Unix 및 DOSish 포트에서 사용할 수 있지만 &lt;code&gt;NDBM_File&lt;/code&gt; 및 &lt;code&gt;DB_File&lt;/code&gt; 만 사용할 수있는 MacPerl 에서는 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="dc935adca7e5bcb15422e7a69e6858c66da25299" translate="yes" xml:space="preserve">
          <source>There is no provision for delaying a request body using an &lt;code&gt;Expect&lt;/code&gt; header. Unexpected &lt;code&gt;1XX&lt;/code&gt; responses are silently ignored as per the specification.</source>
          <target state="translated">&lt;code&gt;Expect&lt;/code&gt; 헤더를 사용하여 요청 본문을 지연하는 규정은 없습니다 . 예상치 못한 &lt;code&gt;1XX&lt;/code&gt; 응답은 사양에 따라 자동으로 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="f93f05645168f7a6ce32010423ff327f27468e22" translate="yes" xml:space="preserve">
          <source>There is no public API for popping individual values or items from the save stack. Instead, via the scope stack, the &lt;code&gt;ENTER&lt;/code&gt; and &lt;code&gt;LEAVE&lt;/code&gt; pair form a way to start and stop nested scopes. Leaving a nested scope via &lt;code&gt;LEAVE&lt;/code&gt; will restore all of the saved values that had been pushed since the most recent &lt;code&gt;ENTER&lt;/code&gt;.</source>
          <target state="translated">저장 스택에서 개별 값 또는 항목을 팝하기위한 공용 API가 없습니다. 대신 범위 스택을 통해 &lt;code&gt;ENTER&lt;/code&gt; 및 &lt;code&gt;LEAVE&lt;/code&gt; 쌍은 중첩 된 범위를 시작하고 중지하는 방법을 형성합니다. &lt;code&gt;LEAVE&lt;/code&gt; 를 통해 중첩 된 범위를 벗어나 면 가장 최근의 &lt;code&gt;ENTER&lt;/code&gt; 이후 푸시 된 모든 저장된 값이 복원됩니다 .</target>
        </trans-unit>
        <trans-unit id="e7d4d5447e705702a110e831b9f5c50697a0ccfe" translate="yes" xml:space="preserve">
          <source>There is no public API to directly push items to the temporaries stack. Instead, the API function &lt;code&gt;sv_2mortal()&lt;/code&gt; is used to mortalize an xV, adding its address to the temporaries stack.</source>
          <target state="translated">항목을 임시 스택에 직접 푸시하는 공용 API는 없습니다. 대신 API 함수 &lt;code&gt;sv_2mortal()&lt;/code&gt; 을 사용하여 xV를 영구화하여 해당 주소를 임시 스택에 추가합니다.</target>
        </trans-unit>
        <trans-unit id="fb47afbc2311aee90586d3371f78c62b2ed90edb" translate="yes" xml:space="preserve">
          <source>There is no quantifier &lt;code&gt;{,n}&lt;/code&gt; . That's interpreted as a literal string.</source>
          <target state="translated">수량 자 &lt;code&gt;{,n}&lt;/code&gt; 이 없습니다 . 그것은 리터럴 문자열로 해석됩니다.</target>
        </trans-unit>
        <trans-unit id="4e5e1c10d207641a72418018f1f75f1613935380" translate="yes" xml:space="preserve">
          <source>There is no quantifier &lt;code&gt;{,n}&lt;/code&gt;. That's currently illegal.</source>
          <target state="translated">수량 자 &lt;code&gt;{,n}&lt;/code&gt; 이 없습니다 . 그것은 현재 불법입니다.</target>
        </trans-unit>
        <trans-unit id="b61924ba7fcca566e3d46f3a27c41097477fd32e" translate="yes" xml:space="preserve">
          <source>There is no reason to directly use this package. This package is documented for completeness. This package can change, or go away completely at any time. Directly using, or monkeypatching this package is not supported in any way shape or form.</source>
          <target state="translated">이 패키지를 직접 사용할 이유는 없습니다. 이 패키지는 완전성을 위해 문서화되었습니다. 이 패키지는 언제든지 변경되거나 완전히 사라질 수 있습니다. 이 패키지를 직접 사용하거나 몽키 패칭하는 것은 어떠한 형태 나 형태로도 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="378d1a5bc456220dab02d99326a34c6e9f3d48c2" translate="yes" xml:space="preserve">
          <source>There is no reason you should not use Perl as a language to glue Unix tools together, or to prototype a Macintosh application, or to manage the Windows registry. If it makes no sense to aim for portability for one reason or another in a given program, then don't bother.</source>
          <target state="translated">Perl을 Unix 도구를 함께 붙이거나 Macintosh 응용 프로그램을 프로토 타입하거나 Windows 레지스트리를 관리하기위한 언어로 사용해서는 안됩니다. 주어진 프로그램에서 어떤 이유로 든 이식성을 목표로하는 것이 의미가 없다면, 귀찮게하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="860dd139f43df25bd42c1af5b8706f2806229649" translate="yes" xml:space="preserve">
          <source>There is no requirement to convert anything.</source>
          <target state="translated">아무것도 변환 할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="5d190eab008c4161478c644351172b878f4f965a" translate="yes" xml:space="preserve">
          <source>There is no set_layers(), nor does get_layers() return a tied array mirroring the stack, or anything fancy like that. This is not accidental or unintentional. The PerlIO layer stack is a bit more complicated than just a stack (see for example the behaviour of &lt;code&gt;:raw&lt;/code&gt; ). You are supposed to use open() and binmode() to manipulate the stack.</source>
          <target state="translated">set_layers ()도없고 get_layers ()도 스택을 미러링하는 묶인 배열 또는 그와 비슷한 멋진 것을 반환하지 않습니다. 우발적이거나 의도적이지 않습니다. PerlIO 레이어 스택은 스택보다 조금 더 복잡합니다 (예 &lt;code&gt;:raw&lt;/code&gt; 동작 참조 ). 스택을 조작하려면 open () 및 binmode ()를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="382f006c5b68a9b9a43fcd623fca8e14332f9212" translate="yes" xml:space="preserve">
          <source>There is no set_layers(), nor does get_layers() return a tied array mirroring the stack, or anything fancy like that. This is not accidental or unintentional. The PerlIO layer stack is a bit more complicated than just a stack (see for example the behaviour of &lt;code&gt;:raw&lt;/code&gt;). You are supposed to use open() and binmode() to manipulate the stack.</source>
          <target state="translated">set_layers ()도없고 get_layers ()도 스택을 미러링하는 묶인 배열을 반환하지 않습니다. 이것은 우발적이거나 의도하지 않은 것이 아닙니다. PerlIO 계층 스택은 단순한 스택보다 약간 더 복잡합니다 (예를 들어 &lt;code&gt;:raw&lt;/code&gt; 의 동작 참조 ). 스택을 조작하려면 open () 및 binmode ()를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="fcb140242be9c5687c6a498b3df2879f2625b5b6" translate="yes" xml:space="preserve">
          <source>There is no shell to process metacharacters, and the native standard is to pass a command line terminated by &quot;\n&quot; &quot;\r&quot; or &quot;\0&quot; to the spawned program. Redirection such as &lt;code&gt;&amp;gt; foo&lt;/code&gt; is performed (if at all) by the run time library of the spawned program. &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">메타 문자를 처리 할 쉘이 없으며 기본 표준은 &quot;\ n&quot; &quot;\ r&quot;또는 &quot;\ 0&quot;으로 끝나는 명령 줄을 생성 된 프로그램에 전달하는 것입니다. &lt;code&gt;&amp;gt; foo&lt;/code&gt; 와 같은 리디렉션 은 생성 된 프로그램의 런타임 라이브러리에 의해 수행됩니다. &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="deba5b88e82775e19650d3712106c375f59f7e30" translate="yes" xml:space="preserve">
          <source>There is no significant speed gain between compile time and run time class creation, there is just a new, more standard order of events.</source>
          <target state="translated">컴파일 시간과 런타임 클래스 생성 사이에는 상당한 속도 향상이 없으며, 새로운 표준 이벤트 순서가 있습니다.</target>
        </trans-unit>
        <trans-unit id="6b7801d1cfdd5c48abee3f679e368ab10b3ad8dc" translate="yes" xml:space="preserve">
          <source>There is no simple answer to this question. Perl frameworks can run everything from basic file servers and small scale intranets to massive multinational multilingual websites that are the core to international businesses.</source>
          <target state="translated">이 질문에 대한 간단한 대답은 없습니다. Perl 프레임 워크는 기본 파일 서버 및 소규모 인트라넷에서 국제 비즈니스의 핵심 인 대규모 다국어 다국어 웹 사이트에 이르기까지 모든 것을 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="300fa34c66267d66af5fbbb27ef916d4adcee2ea" translate="yes" xml:space="preserve">
          <source>There is no simple replacement possible since a qualifier and all its subqualifiers must be considered together, so we use our own utility routine for the replacement.</source>
          <target state="translated">한정자와 모든 하위 한정자를 함께 고려해야하므로 간단한 교체가 불가능하므로 교체를 위해 자체 유틸리티 루틴을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="557d02393de130217c50453e6a017ae2fadcbc8e" translate="yes" xml:space="preserve">
          <source>There is no simple solution to this because of printf()'s limited intelligence, but for many types the right format is available as with either 'f' or '_f' suffix, for example:</source>
          <target state="translated">printf ()의 제한된 인텔리전스 때문에 이에 대한 간단한 해결책은 없지만 많은 유형의 경우 'f'또는 '_f'접미사와 같이 올바른 형식을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5540c0e13568fd5e0e7ecd528ea43dc498771d2a" translate="yes" xml:space="preserve">
          <source>There is no simple way to access WPS objects. The only way I know is via &lt;code&gt;OS2::REXX&lt;/code&gt; and &lt;code&gt;SOM&lt;/code&gt; extensions (see &lt;a href=&quot;OS2::REXX&quot;&gt;OS2::REXX&lt;/a&gt;, &lt;a href=&quot;som&quot;&gt;SOM&lt;/a&gt;). However, we do not have access to convenience methods of Object-REXX. (Is it possible at all? I know of no Object-REXX API.) The &lt;code&gt;SOM&lt;/code&gt; extension (currently in alpha-text) may eventually remove this shortcoming; however, due to the fact that DII is not supported by the &lt;code&gt;SOM&lt;/code&gt; module, using &lt;code&gt;SOM&lt;/code&gt; is not as convenient as one would like it.</source>
          <target state="translated">WPS 개체에 액세스하는 간단한 방법은 없습니다. 내가 아는 유일한 방법은 &lt;code&gt;OS2::REXX&lt;/code&gt; 및 &lt;code&gt;SOM&lt;/code&gt; 확장을 사용하는 것입니다 ( &lt;a href=&quot;OS2::REXX&quot;&gt;OS2 :: REXX&lt;/a&gt; , &lt;a href=&quot;som&quot;&gt;SOM 참조&lt;/a&gt; ). 단, Object-REXX의 편의 방법에 대한 접근 권한이 없습니다. ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ (전혀 가능합니까? Object-REXX API가 없다는 것을 알고 있습니다.) &lt;code&gt;SOM&lt;/code&gt; 확장 (현재 알파 텍스트)은 결국이 단점을 제거 할 수 있습니다. 그러나, DII가 지원되지 않는다는 사실 때문에 &lt;code&gt;SOM&lt;/code&gt; 의 사용, 모듈 &lt;code&gt;SOM&lt;/code&gt; 은 사람이 그것을 원하는만큼 편리하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8ceb0317aba48e3a3b6cabda91010f77ae7a54b9" translate="yes" xml:space="preserve">
          <source>There is no simple way to access WPS objects. The only way I know is via &lt;code&gt;OS2::REXX&lt;/code&gt; and &lt;code&gt;SOM&lt;/code&gt; extensions (see &lt;a href=&quot;http://search.cpan.org/perldoc/OS2::REXX&quot;&gt;OS2::REXX&lt;/a&gt;, &lt;a href=&quot;http://search.cpan.org/perldoc/SOM&quot;&gt;SOM&lt;/a&gt;). However, we do not have access to convenience methods of Object-REXX. (Is it possible at all? I know of no Object-REXX API.) The &lt;code&gt;SOM&lt;/code&gt; extension (currently in alpha-text) may eventually remove this shortcoming; however, due to the fact that DII is not supported by the &lt;code&gt;SOM&lt;/code&gt; module, using &lt;code&gt;SOM&lt;/code&gt; is not as convenient as one would like it.</source>
          <target state="translated">WPS 개체에 액세스하는 간단한 방법은 없습니다. 내가 아는 유일한 방법은 &lt;code&gt;OS2::REXX&lt;/code&gt; 및 &lt;code&gt;SOM&lt;/code&gt; 확장을 통하는 것입니다 ( &lt;a href=&quot;http://search.cpan.org/perldoc/OS2::REXX&quot;&gt;OS2 :: REXX&lt;/a&gt; , &lt;a href=&quot;http://search.cpan.org/perldoc/SOM&quot;&gt;SOM 참조&lt;/a&gt; ). 그러나 Object-REXX의 편리한 방법에는 액세스 할 수 없습니다. (물론 가능합니까? Object-REXX API를 아는 것은 없습니다.) &lt;code&gt;SOM&lt;/code&gt; 확장 (현재 알파 텍스트)은 결국이 단점을 제거 할 수 있습니다. 그러나, DII가 지원되지 않는다는 사실 때문에 &lt;code&gt;SOM&lt;/code&gt; 의 사용, 모듈 &lt;code&gt;SOM&lt;/code&gt; 은 사람이 그것을 원하는만큼 편리하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="06843bf4e2da3a9df3bd916b78c90fe1d32c0462" translate="yes" xml:space="preserve">
          <source>There is no special class syntax in Perl, but a package may act as a class if it provides subroutines to act as methods. Such a package may also derive some of its methods from another class (package) by listing the other package name(s) in its global @ISA array (which must be a package global, not a lexical).</source>
          <target state="translated">Perl에는 특별한 클래스 구문이 없지만 패키지가 서브 루틴을 제공하여 메소드로 작동하는 경우 패키지는 클래스로 작동 할 수 있습니다. 이러한 패키지는 또한 전역 @ISA 배열 (어휘가 아니라 패키지 전역이어야 함)에 다른 패키지 이름을 나열하여 다른 클래스 (패키지)에서 일부 메소드를 파생시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f83d3f75f9b7673dc85f27f3287a09a764999d4c" translate="yes" xml:space="preserve">
          <source>There is no specific mailing list for Perl on VOS. You can contact the Stratus Technologies Customer Assistance Center (CAC) for your region, or you can use the contact information located in the distribution files on the Stratus Anonymous FTP site.</source>
          <target state="translated">VOS의 Perl에 대한 특정 메일 링리스트는 없습니다. 해당 지역의 Stratus Technologies 고객 지원 센터 (CAC)에 문의하거나 Stratus Anonymous FTP 사이트의 배포 파일에있는 연락처 정보를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="100c2da519836111bd839e12cb2fd3dec223d870" translate="yes" xml:space="preserve">
          <source>There is no specification of the formatter after the &lt;code&gt;=for&lt;/code&gt; command.</source>
          <target state="translated">&lt;code&gt;=for&lt;/code&gt; 명령 뒤에 포매터의 스펙이 없습니다 .</target>
        </trans-unit>
        <trans-unit id="670b965fe2aed5c0a5a49c42acbad90f9fc925e9" translate="yes" xml:space="preserve">
          <source>There is no such thing as a network representation for reals, so if you want to send your real numbers across computer boundaries, you'd better stick to text representation, possibly using the hexadecimal float format (avoiding the decimal conversion loss), unless you're absolutely sure what's on the other end of the line. For the even more adventuresome, you can use the byte-order modifiers from the previous section also on floating point codes.</source>
          <target state="translated">실수에 대한 네트워크 표현과 같은 것은 없으므로 컴퓨터 경계를 통해 실수를 보내려면 16 진수 부동 소수점 형식 (10 진수 변환 손실 방지)을 사용하여 텍스트 표현을 따르는 것이 좋습니다. '라인의 다른 쪽 끝에 무엇이 있는지 절대적으로 확신하십시오. 훨씬 더 모험적인 경우 이전 섹션의 바이트 순서 수정자를 부동 소수점 코드에도 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="485f9819a36f9757672adb9a54833a7d985d4ad2" translate="yes" xml:space="preserve">
          <source>There is no support at present for tied @ISA. There is a potential conflict between magic entries needed to notice setting of @ISA, and those needed to implement 'tie'.</source>
          <target state="translated">현재 @ISA에 대한 지원은 없습니다. @ISA 설정과 'tie'를 구현하는 데 필요한 마법 항목 사이에는 잠재적 인 충돌이 있습니다.</target>
        </trans-unit>
        <trans-unit id="8ce7f675d43b056af9ee6718421eba4a7f2bb579" translate="yes" xml:space="preserve">
          <source>There is no support for a Request-URI of '*' for the 'OPTIONS' request.</source>
          <target state="translated">'OPTIONS'요청에 대한 요청 URI '*'에 대한 지원이 없습니다.</target>
        </trans-unit>
        <trans-unit id="f0d4e44dc9af068a1f923f5eebfb3439b41ed99d" translate="yes" xml:space="preserve">
          <source>There is no support for dynamically linked libraries in QNX4.</source>
          <target state="translated">QNX4에서는 동적으로 링크 된 라이브러리를 지원하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ddb797616f9cbf4b2f8a2cb06d0ccee2c08c8ad1" translate="yes" xml:space="preserve">
          <source>There is no syseof() function, which is ok, since &lt;a href=&quot;#eof-FILEHANDLE&quot;&gt;&lt;code&gt;eof&lt;/code&gt;&lt;/a&gt; doesn't work well on device files (like ttys) anyway. Use &lt;a href=&quot;#sysread-FILEHANDLE%2CSCALAR%2CLENGTH%2COFFSET&quot;&gt;&lt;code&gt;sysread&lt;/code&gt;&lt;/a&gt; and check for a return value of 0 to decide whether you're done.</source>
          <target state="translated">syseof () 함수는 없습니다. 괜찮습니다. &lt;a href=&quot;#eof-FILEHANDLE&quot;&gt; &lt;code&gt;eof&lt;/code&gt; &lt;/a&gt; 는 어쨌든 장치 파일 (ttys와 같은)에서 잘 작동하지 않기 때문입니다. &lt;a href=&quot;#sysread-FILEHANDLE%2CSCALAR%2CLENGTH%2COFFSET&quot;&gt; &lt;code&gt;sysread&lt;/code&gt; 를&lt;/a&gt; 사용 하고 반환 값이 0인지 확인하여 완료 여부를 결정하십시오.</target>
        </trans-unit>
        <trans-unit id="73a30aae9994d5aba957137545368eea0ce0f5eb" translate="yes" xml:space="preserve">
          <source>There is no syseof() function, which is ok, since eof() doesn't work well on device files (like ttys) anyway. Use sysread() and check for a return value for 0 to decide whether you're done.</source>
          <target state="translated">ese ()는 어쨌든 tty와 같은 장치 파일에서는 제대로 작동하지 않기 때문에 syseof () 함수는 없습니다. sysread ()를 사용하고 0에 대한 반환 값을 확인하여 완료 여부를 결정하십시오.</target>
        </trans-unit>
        <trans-unit id="8fc13de7d6614c5dd033dd321c9bbd82b325da63" translate="yes" xml:space="preserve">
          <source>There is no technical reason why a Berkeley DB database cannot be shared by both a Perl and a C application.</source>
          <target state="translated">Berlley DB 데이터베이스를 Perl과 C 응용 프로그램이 공유 할 수없는 기술적 이유는 없습니다.</target>
        </trans-unit>
        <trans-unit id="79f7328788708da5a0cdbfe8c102e73defe278fc" translate="yes" xml:space="preserve">
          <source>There is no way to reliably detect the encoding automatically, so if people keep sending you data without charset indication, you may have to educate them.</source>
          <target state="translated">인코딩을 자동으로 안정적으로 감지 할 수있는 방법이 없으므로 사람들이 문자셋 표시없이 데이터를 계속 보내면이를 교육해야 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="20ec9f83105615b23b9fac938fd715b5bc923fe1" translate="yes" xml:space="preserve">
          <source>There is no way to turn it back on.</source>
          <target state="translated">다시 켤 수있는 방법이 없습니다.</target>
        </trans-unit>
        <trans-unit id="9d4ba678fc087cfe3ed3657d1daba5422cdd5616" translate="yes" xml:space="preserve">
          <source>There is nothing special about Memoize::Expire. It is just an example. If you don't like the policy that it implements, you are free to write your own expiration policy module that implements whatever policy you desire. Here is how to do that. Let us suppose that your module will be named MyExpirePolicy.</source>
          <target state="translated">Memoize :: Expire에는 특별한 것이 없습니다. 단지 예일뿐입니다. 구현 한 정책이 마음에 들지 않으면 원하는 정책을 구현하는 고유 한 만료 정책 모듈을 자유롭게 작성할 수 있습니다. 방법은 다음과 같습니다. 모듈 이름이 MyExpirePolicy라고 가정하겠습니다.</target>
        </trans-unit>
        <trans-unit id="6fcd6f426861d4a9d172b0ea1e309235434fe63e" translate="yes" xml:space="preserve">
          <source>There is now a &lt;code&gt;bsstr()&lt;/code&gt; method to get the string in scientific notation aka &lt;code&gt;1e+2&lt;/code&gt; instead of &lt;code&gt;100&lt;/code&gt; . Be advised that overloaded 'eq' always uses bstr() for comparison, but Perl will represent some numbers as 100 and others as 1e+308. If in doubt, convert both arguments to Math::BigInt before comparing them as strings:</source>
          <target state="translated">이제 &lt;code&gt;100&lt;/code&gt; 대신 과학 표기법으로 일명 &lt;code&gt;1e+2&lt;/code&gt; 의 문자열을 얻는 &lt;code&gt;bsstr()&lt;/code&gt; 메소드가 있습니다. 오버로드 된 'eq'는 항상 비교를 위해 bstr ()을 사용하지만 Perl은 일부 숫자를 100으로 나타내고 다른 숫자를 1e + 308로 나타냅니다. 확실하지 않은 경우 두 인수를 모두 문자열로 비교하기 전에 Math :: BigInt로 변환하십시오.</target>
        </trans-unit>
        <trans-unit id="5ae720bb4190ab9bd815350aa7eadedcf7d8ced5" translate="yes" xml:space="preserve">
          <source>There is now a &lt;code&gt;bsstr()&lt;/code&gt; method to get the string in scientific notation aka &lt;code&gt;1e+2&lt;/code&gt; instead of &lt;code&gt;100&lt;/code&gt;. Be advised that overloaded 'eq' always uses bstr() for comparison, but Perl represents some numbers as 100 and others as 1e+308. If in doubt, convert both arguments to Math::BigInt before comparing them as strings:</source>
          <target state="translated">이제 &lt;code&gt;100&lt;/code&gt; 대신 과학적 표기법 (일명 &lt;code&gt;1e+2&lt;/code&gt; )으로 문자열을 가져 오는 &lt;code&gt;bsstr()&lt;/code&gt; 메서드가 있습니다. 오버로드 된 'eq'는 항상 비교를 위해 bstr ()을 사용하지만 Perl은 일부 숫자를 100으로, 다른 숫자는 1e + 308로 나타냅니다. 확실하지 않은 경우 두 인수를 모두 문자열로 비교하기 전에 Math :: BigInt로 변환하십시오.</target>
        </trans-unit>
        <trans-unit id="22f759aa48f981bff2eecdd8034d0137dd1c154a" translate="yes" xml:space="preserve">
          <source>There is of course lots more to find out about, this has just scratched the surface. The best way to learn more is to use perldoc to find out more about the language, to read the on-line help (&lt;a href=&quot;perldebug&quot;&gt;perldebug&lt;/a&gt; is probably the next place to go), and of course, experiment.</source>
          <target state="translated">물론 더 많은 것을 알 수 있습니다. 이것은 표면을 긁었습니다. 더 많은 것을 배우는 가장 좋은 방법은 perldoc을 사용하여 언어에 대한 자세한 내용을 찾고 온라인 도움말 ( &lt;a href=&quot;perldebug&quot;&gt;perldebug&lt;/a&gt; 가 다음에 나올 곳임 ) 을 읽고 실험하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="4c5dc52000b85d6cc8d7d71cfdf7a1cf6d094cbc" translate="yes" xml:space="preserve">
          <source>There is often a matter of opinion and taste, and there isn't any one answer that fits everyone. In general, you want to use either the current stable release, or the stable release immediately prior to that one.</source>
          <target state="translated">종종 의견과 취향의 문제가 있으며 모든 사람에게 맞는 답은 하나도 없습니다. 일반적으로 현재 안정 릴리스 또는 그 직전의 안정 릴리스를 사용하려고합니다.</target>
        </trans-unit>
        <trans-unit id="2f1fdaa6644f76210c716aac51df03a67575812a" translate="yes" xml:space="preserve">
          <source>There is often a matter of opinion and taste, and there isn't any one answer that fits everyone. In general, you want to use either the current stable release, or the stable release immediately prior to that one. Currently, those are perl5.18.x and perl5.16.x, respectively.</source>
          <target state="translated">종종 의견과 취향의 문제가 있으며 모든 사람에게 맞는 답은 없습니다. 일반적으로 현재 안정 릴리스 또는 바로 이전 릴리스를 사용하려고합니다. 현재는 각각 perl5.18.x 및 perl5.16.x입니다.</target>
        </trans-unit>
        <trans-unit id="6fddc6aff8f6804eafbdecf55f8d9d2197b85b37" translate="yes" xml:space="preserve">
          <source>There is one caveat with INSTALL_BASE, though, since it acts differently from the PREFIX and LIB settings that older versions of &lt;a href=&quot;ExtUtils::MakeMaker&quot;&gt;ExtUtils::MakeMaker&lt;/a&gt; advocated. INSTALL_BASE does not support installing modules for multiple versions of Perl or different architectures under the same directory. You should consider whether you really want that and, if you do, use the older PREFIX and LIB settings. See the &lt;a href=&quot;ExtUtils::Makemaker&quot;&gt;ExtUtils::Makemaker&lt;/a&gt; documentation for more details.</source>
          <target state="translated">그러나 INSTALL_BASE에는 이전 버전의 &lt;a href=&quot;ExtUtils::MakeMaker&quot;&gt;ExtUtils :: MakeMaker가&lt;/a&gt; 옹호 했던 PREFIX 및 LIB 설정과 다르게 작동하기 때문에 한 가지주의 할 점이 있습니다 . INSTALL_BASE는 동일한 디렉토리에 여러 버전의 Perl 또는 다른 아키텍처에 대한 모듈 설치를 지원하지 않습니다. 정말로 원하는지 여부를 고려해야하며, 원하는 경우 이전 PREFIX 및 LIB 설정을 사용해야합니다. 자세한 내용은 &lt;a href=&quot;ExtUtils::Makemaker&quot;&gt;ExtUtils :: Makemaker&lt;/a&gt; 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="5e0ec9ff71273582227d757a4501aa81fcc373f2" translate="yes" xml:space="preserve">
          <source>There is one caveat with INSTALL_BASE, though, since it acts differently from the PREFIX and LIB settings that older versions of &lt;a href=&quot;extutils/makemaker&quot;&gt;ExtUtils::MakeMaker&lt;/a&gt; advocated. INSTALL_BASE does not support installing modules for multiple versions of Perl or different architectures under the same directory. You should consider whether you really want that and, if you do, use the older PREFIX and LIB settings. See the &lt;a href=&quot;http://search.cpan.org/perldoc/ExtUtils::Makemaker&quot;&gt;ExtUtils::Makemaker&lt;/a&gt; documentation for more details.</source>
          <target state="translated">INSTALL_BASE에는 하나의 경고가 있습니다. 이전 버전의 &lt;a href=&quot;extutils/makemaker&quot;&gt;ExtUtils :: MakeMaker가&lt;/a&gt; 주장한 PREFIX 및 LIB 설정과 다르게 작동하기 때문입니다 . INSTALL_BASE는 동일한 디렉토리에서 여러 버전의 Perl 또는 다른 아키텍처에 대한 모듈 설치를 지원하지 않습니다. 실제로 원하는지 여부를 고려해야하며, 원하는 경우 이전 PREFIX 및 LIB 설정을 사용하십시오. 자세한 내용은 &lt;a href=&quot;http://search.cpan.org/perldoc/ExtUtils::Makemaker&quot;&gt;ExtUtils :: Makemaker&lt;/a&gt; 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="14196e0aaa427146743d8121cb1facbe4cf5fb5c" translate="yes" xml:space="preserve">
          <source>There is one crucial restriction: the prereqs of an optional feature &lt;b&gt;must not&lt;/b&gt; include &lt;code&gt;configure&lt;/code&gt; phase prereqs.</source>
          <target state="translated">한 가지 중요한 제한이 있습니다. 선택적 기능의 전제 조건 에는 &lt;code&gt;configure&lt;/code&gt; 단계 전제 조건이 포함 &lt;b&gt;되지 않아야합니다&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="97b4745ddf35dec712ea27023babefb7e0f47466" translate="yes" xml:space="preserve">
          <source>There is one exception to all this. &lt;code&gt;\p{All}&lt;/code&gt; looks like a Unicode property, but it is a Perl extension that is defined to be true for all possible code points, Unicode or not, so no warning is ever generated when matching this against a non-Unicode code point. (Prior to v5.20, it was an exact synonym for &lt;code&gt;\p{Any}&lt;/code&gt; , matching code points &lt;code&gt;0&lt;/code&gt; through &lt;code&gt;0x10FFFF&lt;/code&gt; .)</source>
          <target state="translated">이 모든 것에는 한 가지 예외가 있습니다. &lt;code&gt;\p{All}&lt;/code&gt; 은 유니 코드 속성처럼 보이지만 가능한 모든 코드 포인트에 대해 유니 코드의 유무에 관계없이 Perl 확장명이므로 유니 코드가 아닌 코드 포인트와 비교할 때 경고가 생성되지 않습니다. (v5.20 이전에는 &lt;code&gt;\p{Any}&lt;/code&gt; 와 동의어로 &lt;code&gt;0&lt;/code&gt; 에서 &lt;code&gt;0x10FFFF&lt;/code&gt; 까지의 코드 포인트와 일치했습니다 .)</target>
        </trans-unit>
        <trans-unit id="a280fffe45cedb42744a2a95530fed2f40145dd0" translate="yes" xml:space="preserve">
          <source>There is one exception to all this. &lt;code&gt;\p{All}&lt;/code&gt; looks like a Unicode property, but it is a Perl extension that is defined to be true for all possible code points, Unicode or not, so no warning is ever generated when matching this against a non-Unicode code point. (Prior to v5.20, it was an exact synonym for &lt;code&gt;\p{Any}&lt;/code&gt;, matching code points &lt;code&gt;0&lt;/code&gt; through &lt;code&gt;0x10FFFF&lt;/code&gt;.)</source>
          <target state="translated">이 모든 것에는 한 가지 예외가 있습니다. &lt;code&gt;\p{All}&lt;/code&gt; 은 유니 코드 속성처럼 보이지만 가능한 모든 코드 포인트 (유니 코드 여부)에 대해 true로 정의 된 Perl 확장이므로이를 비 유니 코드 코드 포인트와 일치시킬 때 경고가 생성되지 않습니다. (v5.20 이전에는 코드 포인트 &lt;code&gt;0&lt;/code&gt; 에서 &lt;code&gt;0x10FFFF&lt;/code&gt; 까지 일치하는 &lt;code&gt;\p{Any}&lt;/code&gt; 의 정확한 동의어였습니다 .)</target>
        </trans-unit>
        <trans-unit id="74416e05e81083925dbb5ceee8b9f9eabc0d1420" translate="yes" xml:space="preserve">
          <source>There is one exception to this rule:</source>
          <target state="translated">이 규칙에는 한 가지 예외가 있습니다.</target>
        </trans-unit>
        <trans-unit id="aa93104b268b1c94a90858506e09be1c5b4335fe" translate="yes" xml:space="preserve">
          <source>There is one exception, and that is base 2 with negative $x:</source>
          <target state="translated">한 가지 예외가 있으며, $ x가 음수 인 기본 2입니다.</target>
        </trans-unit>
        <trans-unit id="8cbb7256d41af14511a3636bc506131a71d8c56d" translate="yes" xml:space="preserve">
          <source>There is one exception. If you use an alphanumeric character as the delimiter of your pattern (which you probably shouldn't do for readability reasons), you have to escape the delimiter if you want to match it. Perl won't warn then. See also &lt;a href=&quot;perlop#Gory-details-of-parsing-quoted-constructs&quot;&gt;&quot;Gory details of parsing quoted constructs&quot; in perlop&lt;/a&gt;.</source>
          <target state="translated">한 가지 예외가 있습니다. 패턴의 구분 기호로 영숫자 문자를 사용하는 경우 (가독성을 위해해서는 안되는), 일치 시키려면 구분 기호를 이스케이프해야합니다. Perl은 경고하지 않습니다. &lt;a href=&quot;perlop#Gory-details-of-parsing-quoted-constructs&quot;&gt;perlop의 &quot;인용 된 구문 구문 분석에 대한 Gory 세부 사항&quot;을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="cfa0a4472a2d7ed2b714a912f015cd1d6e2a650e" translate="yes" xml:space="preserve">
          <source>There is one exception. If you use an alphanumeric character as the delimiter of your pattern (which you probably shouldn't do for readability reasons), you have to escape the delimiter if you want to match it. Perl won't warn then. See also &lt;a href=&quot;perlop#Gory-details-of-parsing-quoted-constructs&quot;&gt;Gory details of parsing quoted constructs in perlop&lt;/a&gt;.</source>
          <target state="translated">한 가지 예외가 있습니다. 영숫자 문자를 패턴의 구분자로 사용하는 경우 (가독성을 위해하지 말아야 할) 구분 기호를 일치 시키려면 구분자를 이스케이프해야합니다. 펄은 그때 경고하지 않습니다. &lt;a href=&quot;perlop#Gory-details-of-parsing-quoted-constructs&quot;&gt;인용 된 구문 구문 분석에 대한 Gory 세부 사항&lt;/a&gt; 도 perlop 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="6afd3e4f300e1185505b80a57213e90e8f05b7f4" translate="yes" xml:space="preserve">
          <source>There is one minor difference: if variables are declared with &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; in the initialization section of the &lt;code&gt;for&lt;/code&gt; , the lexical scope of those variables is exactly the &lt;code&gt;for&lt;/code&gt; loop (the body of the loop and the control sections).</source>
          <target state="translated">약간의 차이점이 있습니다. &lt;code&gt;for&lt;/code&gt; 의 초기화 섹션에서 변수를 &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; 로 선언하면 해당 변수 의 어휘 범위는 정확히 &lt;code&gt;for&lt;/code&gt; 루프 (루프 본문과 제어 섹션)입니다.</target>
        </trans-unit>
        <trans-unit id="9813dc853a6a86bf5a99b935f981b5a1ed789ab3" translate="yes" xml:space="preserve">
          <source>There is one minor difference: if variables are declared with &lt;code&gt;my&lt;/code&gt; in the initialization section of the &lt;code&gt;for&lt;/code&gt;, the lexical scope of those variables is exactly the &lt;code&gt;for&lt;/code&gt; loop (the body of the loop and the control sections).</source>
          <target state="translated">한 가지 사소한 차이점이 있습니다. &lt;code&gt;for&lt;/code&gt; 의 초기화 섹션에서 &lt;code&gt;my&lt;/code&gt; 로 변수를 선언하면 해당 변수 의 어휘 범위는 정확히 &lt;code&gt;for&lt;/code&gt; 루프 (루프 본문 및 제어 섹션)입니다.</target>
        </trans-unit>
        <trans-unit id="83ea2627da96768f4457b4c193dca3613fbaa7aa" translate="yes" xml:space="preserve">
          <source>There is one small difference between &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; integer&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; bigint&lt;/code&gt; : the former will not affect assignments to variables and the return value of some functions. &lt;code&gt;bigint&lt;/code&gt; truncates these results to integer too:</source>
          <target state="translated">사이의 작은 차이가 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; integer&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; bigint&lt;/code&gt; : 전자는 변수와 일부 기능의 반환 값을 할당에 영향을 미치지 않습니다. &lt;code&gt;bigint&lt;/code&gt; 는 이 결과도 정수로 자릅니다.</target>
        </trans-unit>
        <trans-unit id="b8649e02d1e449cfaae6e608c7b04929643e83c2" translate="yes" xml:space="preserve">
          <source>There is one small difference between &lt;code&gt;use integer&lt;/code&gt; and &lt;code&gt;use bigint&lt;/code&gt;: the former will not affect assignments to variables and the return value of some functions. &lt;code&gt;bigint&lt;/code&gt; truncates these results to integer too:</source>
          <target state="translated">&lt;code&gt;use integer&lt;/code&gt; 과 &lt;code&gt;use bigint&lt;/code&gt; 사용 에는 작은 차이가 하나 있습니다 . 전자는 변수 할당 및 일부 함수의 반환 값에 영향을주지 않습니다. &lt;code&gt;bigint&lt;/code&gt; 는 이러한 결과도 정수로 자릅니다.</target>
        </trans-unit>
        <trans-unit id="b84dd6a42f4605e651baa6c6eefa2a08f75e64c2" translate="yes" xml:space="preserve">
          <source>There is one subtle difference between the following statements:</source>
          <target state="translated">다음 진술 사이에는 미묘한 차이가 있습니다.</target>
        </trans-unit>
        <trans-unit id="577b4723acc7dc122f5a6c392fd693ead8ac6f77" translate="yes" xml:space="preserve">
          <source>There is one unary operator:</source>
          <target state="translated">단항 연산자는 하나입니다.</target>
        </trans-unit>
        <trans-unit id="d67d211508568f3ee020a0acfadaaf645e5efa24" translate="yes" xml:space="preserve">
          <source>There is only a single &lt;code&gt;%^H&lt;/code&gt; , but arbitrarily many modules that want to use its scoping semantics. To avoid stepping on each other's toes, they need to be sure to use different keys in the hash. It is therefore conventional for a module to use only keys that begin with the module's name (the name of its main package) and a &quot;/&quot; character. After this module-identifying prefix, the rest of the key is entirely up to the module: it may include any characters whatsoever. For example, a module &lt;code&gt;Foo::Bar&lt;/code&gt; should use keys such as &lt;code&gt;Foo::Bar/baz&lt;/code&gt; and &lt;code&gt;Foo::Bar/$%/_!&lt;/code&gt; . Modules following this convention all play nicely with each other.</source>
          <target state="translated">단일 &lt;code&gt;%^H&lt;/code&gt; 만 있지만 범위 지정 의미를 사용하려는 임의의 모듈이 있습니다. 서로의 발가락을 밟지 않으려면 해시에서 다른 키를 사용해야합니다. 따라서 모듈은 모듈 이름 (기본 패키지 이름)과 &quot;/&quot;문자로 시작하는 키만 사용하는 것이 일반적입니다. 이 모듈 식별 접두사 다음에 나머지 키는 전적으로 모듈에 달려 있습니다. 모든 문자를 포함 할 수 있습니다. 예를 들어, &lt;code&gt;Foo::Bar&lt;/code&gt; 모듈 은 &lt;code&gt;Foo::Bar/baz&lt;/code&gt; 및 &lt;code&gt;Foo::Bar/$%/_!&lt;/code&gt; 와 같은 키를 사용해야합니다 ! . 이 규칙을 따르는 모듈은 모두 서로 잘 작동합니다.</target>
        </trans-unit>
        <trans-unit id="3740e3b8de22c29d0f5b6e37bf6c582521c6e016" translate="yes" xml:space="preserve">
          <source>There is only a single &lt;code&gt;%^H&lt;/code&gt;, but arbitrarily many modules that want to use its scoping semantics. To avoid stepping on each other's toes, they need to be sure to use different keys in the hash. It is therefore conventional for a module to use only keys that begin with the module's name (the name of its main package) and a &quot;/&quot; character. After this module-identifying prefix, the rest of the key is entirely up to the module: it may include any characters whatsoever. For example, a module &lt;code&gt;Foo::Bar&lt;/code&gt; should use keys such as &lt;code&gt;Foo::Bar/baz&lt;/code&gt; and &lt;code&gt;Foo::Bar/$%/_!&lt;/code&gt;. Modules following this convention all play nicely with each other.</source>
          <target state="translated">하나의 &lt;code&gt;%^H&lt;/code&gt; 만 있지만 범위 지정 의미를 사용하려는 임의의 많은 모듈이 있습니다. 서로의 발가락을 밟지 않으려면 해시에서 다른 키를 사용해야합니다. 따라서 모듈이 모듈 이름 (주 패키지의 이름)과 &quot;/&quot;문자로 시작하는 키만 사용하는 것이 일반적입니다. 이 모듈 식별 접두사 뒤에 나머지 키는 전적으로 모듈에 달려 있습니다. 여기에는 모든 문자가 포함될 수 있습니다. 예를 들어 모듈 &lt;code&gt;Foo::Bar&lt;/code&gt; 는 &lt;code&gt;Foo::Bar/baz&lt;/code&gt; 및 &lt;code&gt;Foo::Bar/$%/_!&lt;/code&gt; . 이 규칙을 따르는 모듈은 모두 서로 잘 작동합니다.</target>
        </trans-unit>
        <trans-unit id="22c0c34478d863fe370e8b15b9734da447a63b38" translate="yes" xml:space="preserve">
          <source>There is outline support for co-existence of PerlIO with stdio. Obviously if PerlIO is implemented in terms of stdio there is no problem. However in other cases then mechanisms must exist to create a FILE * which can be passed to library code which is going to use stdio calls.</source>
          <target state="translated">Perdio와 stdio의 공존에 대한 개요 지원이 있습니다. 분명히 PerlIO가 stdio 측면에서 구현된다면 아무런 문제가 없습니다. 그러나 다른 경우에는 stdio 호출을 사용하는 라이브러리 코드로 전달 될 수있는 FILE *을 작성하는 메커니즘이 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="a0392addc7a656cb8a34b007fdd104d3df93294e" translate="yes" xml:space="preserve">
          <source>There is some debate as to whether to say &quot;regexp&quot; or &quot;regex&quot;. In this document we will use the term &quot;regex&quot; unless there is a special reason not to, in which case we will explain why.</source>
          <target state="translated">&quot;regexp&quot;또는 &quot;regex&quot;를 말할지에 대한 논쟁이 있습니다. 이 문서에서는 특별한 이유가없는 한 &quot;regex&quot;라는 용어를 사용합니다.이 경우 그 이유를 설명합니다.</target>
        </trans-unit>
        <trans-unit id="6f838e3edb2d3e6da973960ec694558ee6ce5470" translate="yes" xml:space="preserve">
          <source>There is some problem with the way &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt; &amp;amp;f&lt;/code&gt; works under threaded Perl, perhaps because of the lexical scoping of &lt;code&gt;@_&lt;/code&gt; . This is a bug in Perl, and until it is resolved, memoized functions will see a slightly different &lt;code&gt;&lt;a href=&quot;functions/caller&quot;&gt;caller()&lt;/a&gt;&lt;/code&gt; and will perform a little more slowly on threaded perls than unthreaded perls.</source>
          <target state="translated">스레드 펄에서 &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt; &amp;amp;f&lt;/code&gt; 작동 하는 방식에 문제가있을 수 있습니다 . 아마도 어휘 범위가 &lt;code&gt;@_&lt;/code&gt; 때문일 수 있습니다. 이것은 Perl의 버그이며, 해결 될 때까지 메모 된 함수는 약간 다른 &lt;code&gt;&lt;a href=&quot;functions/caller&quot;&gt;caller()&lt;/a&gt;&lt;/code&gt; 를 보게되고 스레드되지 않은 perls보다 스레드 된 perls에서 약간 느리게 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="2bcd1c67f3d88bee674b646d4ad741c0978c442b" translate="yes" xml:space="preserve">
          <source>There is some problem with the way &lt;code&gt;goto &amp;amp;f&lt;/code&gt; works under threaded Perl, perhaps because of the lexical scoping of &lt;code&gt;@_&lt;/code&gt;. This is a bug in Perl, and until it is resolved, memoized functions will see a slightly different &lt;code&gt;caller()&lt;/code&gt; and will perform a little more slowly on threaded perls than unthreaded perls.</source>
          <target state="translated">스레드 된 Perl에서 &lt;code&gt;goto &amp;amp;f&lt;/code&gt; 작동 하는 방식에 몇 가지 문제가 있습니다. 아마도 &lt;code&gt;@_&lt;/code&gt; 의 어휘 범위 지정 때문일 것 입니다. 이것은 Perl의 버그이며, 해결 될 때까지 메모 된 함수는 약간 다른 &lt;code&gt;caller()&lt;/code&gt; 를보고 스레드되지 않은 Perls보다 스레드 된 Perls에서 조금 더 느리게 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="25c4c8715915dd906a17ab857892228134a49607" translate="yes" xml:space="preserve">
          <source>There is some whitespace on a seemingly empty line. POD is very sensitive to such things, so this is flagged. &lt;b&gt;vi&lt;/b&gt; users switch on the &lt;b&gt;list&lt;/b&gt; option to avoid this problem.</source>
          <target state="translated">빈 줄에 공백이 있습니다. POD는 그러한 것에 매우 민감하므로 플래그가 지정되어 있습니다. &lt;b&gt;vi&lt;/b&gt; 사용자는 이 문제를 피하기 위해 &lt;b&gt;목록&lt;/b&gt; 옵션을 켭니다 .</target>
        </trans-unit>
        <trans-unit id="c71483f882bf4da31c0c8d8f1949a4bc637c87a4" translate="yes" xml:space="preserve">
          <source>There is still a big part of the API not supported by</source>
          <target state="translated">아직 API에서 지원하지 않는 부분이 많이 있습니다</target>
        </trans-unit>
        <trans-unit id="808a7cbe8640b29d30d1f97308938be9ff6d1171" translate="yes" xml:space="preserve">
          <source>There is still a small theoretical chance that a signal will interrupt the system-level &lt;code&gt;&lt;a href=&quot;functions/write&quot;&gt;write()&lt;/a&gt;&lt;/code&gt; operation before completion. There is also a possibility that some STDIO implementations may call multiple system level &lt;code&gt;&lt;a href=&quot;functions/write&quot;&gt;write()&lt;/a&gt;&lt;/code&gt;s even if the buffer was empty to start. There may be some systems where this probability is reduced to zero, and this is not a concern when using &lt;code&gt;:perlio&lt;/code&gt; instead of your system's STDIO.</source>
          <target state="translated">신호가 완료되기 전에 시스템 수준 &lt;code&gt;&lt;a href=&quot;functions/write&quot;&gt;write()&lt;/a&gt;&lt;/code&gt; 작업을 중단 할 가능성은 여전히 ​​이론적으로 적습니다 . 버퍼가 비어 있어도 일부 STDIO 구현에서 여러 시스템 레벨 &lt;code&gt;&lt;a href=&quot;functions/write&quot;&gt;write()&lt;/a&gt;&lt;/code&gt; 호출 할 수도 있습니다 . 이 확률이 0으로 감소 된 일부 시스템이있을 수 있으며 이는 시스템의 STDIO 대신 &lt;code&gt;:perlio&lt;/code&gt; 를 사용할 때 문제가되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="0c9adb8b47f26bb800c4b672d40c4761b57cb21d" translate="yes" xml:space="preserve">
          <source>There is still a small theoretical chance that a signal will interrupt the system-level &lt;code&gt;write()&lt;/code&gt; operation before completion. There is also a possibility that some STDIO implementations may call multiple system level &lt;code&gt;write()&lt;/code&gt;s even if the buffer was empty to start. There may be some systems where this probability is reduced to zero, and this is not a concern when using &lt;code&gt;:perlio&lt;/code&gt; instead of your system's STDIO.</source>
          <target state="translated">신호가 완료되기 전에 시스템 수준 &lt;code&gt;write()&lt;/code&gt; 작업을 중단 할 수있는 이론적 가능성은 여전히 ​​작습니다 . 또한 일부 STDIO 구현은 버퍼가 시작하기 위해 비어있는 경우에도 여러 시스템 수준 &lt;code&gt;write()&lt;/code&gt; 호출 할 수 있습니다 . 이 확률이 0으로 감소하는 시스템이있을 수 있으며, 시스템의 STDIO 대신 &lt;code&gt;:perlio&lt;/code&gt; 를 사용할 때는 문제가되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="96312d6625c318df54bef83c86f5b35fb95ca06e" translate="yes" xml:space="preserve">
          <source>There is the &quot;next regnode&quot; from a given regnode, a value which is rarely useful except that sometimes it matches up in terms of value with one of the others, and that sometimes the code assumes this to always be so.</source>
          <target state="translated">주어진 regnode의 &quot;다음 regnode&quot;가 있습니다. 때로는 값이 다른 것 중 하나와 일치한다는 점을 제외하고는 거의 유용하지 않으며 때로는 코드가 항상 그런 것으로 가정합니다.</target>
        </trans-unit>
        <trans-unit id="7b46535959966668b5c0eb95890256b8fd5dc3c4" translate="yes" xml:space="preserve">
          <source>There is the &quot;next regop&quot; from a given regop/regnode. This is the regop physically located after the current one, as determined by the size of the current regop. This is often useful, such as when dumping the structure we use this order to traverse. Sometimes the code assumes that the &quot;next regnode&quot; is the same as the &quot;next regop&quot;, or in other words assumes that the sizeof a given regop type is always going to be one regnode large.</source>
          <target state="translated">주어진 regop / regnode의 &quot;다음 regop&quot;이 있습니다. 이것은 현재 regop의 크기에 의해 결정된대로 현재 regop 뒤에 물리적으로 위치한 regop입니다. 구조를 덤프 할 때와 같이이 순서를 사용하여 트래버스하는 경우와 같이 종종 유용합니다. 때때로 코드는 &quot;다음 regnode&quot;가 &quot;다음 regop&quot;과 동일하다고 가정하거나, 즉 주어진 regop 유형의 크기가 항상 하나의 regnode 크기라고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="e671500d0c7786e7f8681f40410ba60c12dae4fc" translate="yes" xml:space="preserve">
          <source>There is the &quot;regnext&quot; from a given regop. This is the regop which is reached by jumping forward by the value of &lt;code&gt;NEXT_OFF()&lt;/code&gt; , or in a few cases for longer jumps by the &lt;code&gt;arg1&lt;/code&gt; field of the &lt;code&gt;regnode_1&lt;/code&gt; structure. The subroutine &lt;code&gt;regnext()&lt;/code&gt; handles this transparently. This is the logical successor of the node, which in some cases, like that of the &lt;code&gt;BRANCH&lt;/code&gt; regop, has special meaning.</source>
          <target state="translated">주어진 regop의 &quot;regnext&quot;가 있습니다. 이것은 &lt;code&gt;NEXT_OFF()&lt;/code&gt; 값만큼 앞으로 점프 하거나, 몇몇 경우 에는 &lt;code&gt;regnode_1&lt;/code&gt; 구조 의 &lt;code&gt;arg1&lt;/code&gt; 필드에 의한 더 긴 점프 를 위해 도달 하는 regop 입니다. 서브 루틴 &lt;code&gt;regnext()&lt;/code&gt; 는 이것을 투명하게 처리합니다. 이것은 노드의 논리적 후계자이며, 일부 경우 &lt;code&gt;BRANCH&lt;/code&gt; 레고 와 마찬가지로 특별한 의미를 갖습니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
