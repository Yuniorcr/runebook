<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="perl">
    <body>
      <group id="perl">
        <trans-unit id="bed16d4ef44043e0ee787c3f181832f24be03ea6" translate="yes" xml:space="preserve">
          <source>When you speak one language and the computer thinks you&amp;rsquo;re speaking another. You&amp;rsquo;ll see odd translations when you send UTF‑8, for instance, but the computer thinks you sent Latin-1, showing all sorts of weird characters instead. The term is written 「文字化け」in Japanese and means &amp;ldquo;character rot&amp;rdquo;, an apt description. Pronounced [&lt;code&gt;modʑibake&lt;/code&gt; ] in standard &lt;b&gt;IPA&lt;/b&gt; phonetics, or approximately &amp;ldquo;moh-jee-bah-keh&amp;rdquo;.</source>
          <target state="translated">한 언어를 말할 때 컴퓨터가 다른 언어를 말하는 것으로 생각할 때 예를 들어 UTF-8을 보내면 이상한 번역이 표시되지만 컴퓨터는 라틴 -1을 보냈다고 생각합니다. 대신 모든 종류의 이상한 문자가 표시됩니다. 이 용어는 일본어로 &quot;文字 化 け&quot;로 작성되며 적절한 설명 인&amp;ldquo;문자 썩음&amp;rdquo;을 의미합니다. 표준 &lt;b&gt;IPA&lt;/b&gt; 음성학에서 약 [ &lt;code&gt;modʑibake&lt;/code&gt; ] 또는 약&amp;ldquo;moh-jee-bah-keh&amp;rdquo;.&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="7ef09f89e47adf28a99fbbb7052a436221dbcca0" translate="yes" xml:space="preserve">
          <source>When you speak one language and the computer thinks you&amp;rsquo;re speaking another. You&amp;rsquo;ll see odd translations when you send UTF‑8, for instance, but the computer thinks you sent Latin-1, showing all sorts of weird characters instead. The term is written 「文字化け」in Japanese and means &amp;ldquo;character rot&amp;rdquo;, an apt description. Pronounced [&lt;code&gt;modʑibake&lt;/code&gt;] in standard &lt;b&gt;IPA&lt;/b&gt; phonetics, or approximately &amp;ldquo;moh-jee-bah-keh&amp;rdquo;.</source>
          <target state="translated">당신이 한 언어를 말하고 컴퓨터는 당신이 다른 언어를 말하는 것으로 생각할 때. 예를 들어 UTF-8을 보낼 때 이상한 번역을 볼 수 있지만 컴퓨터는 대신 모든 종류의 이상한 문자를 보여주는 Latin-1을 보낸 것으로 생각합니다. 이 용어는 일본어로 「文字 化 け」이라고 적혀 있으며 적절한 설명 인&amp;ldquo;문자 썩음&amp;rdquo;을 의미합니다. 표준 &lt;b&gt;IPA&lt;/b&gt; 음성학 에서 [ &lt;code&gt;modʑibake&lt;/code&gt; ] 또는 대략 &quot;moh-jee-bah-keh&quot;로 발음됩니다.&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="665a5769943788c4623d27cfed3bae7f7e133317" translate="yes" xml:space="preserve">
          <source>When you specify arguments to routines in the .xs file, you are really passing three pieces of information for each argument listed. The first piece is the order of that argument relative to the others (first, second, etc). The second is the type of argument, and consists of the type declaration of the argument (e.g., int, char*, etc). The third piece is the calling convention for the argument in the call to the library function.</source>
          <target state="translated">.xs 파일에서 루틴에 인수를 지정하면 실제로 나열된 각 인수에 대해 세 가지 정보가 전달됩니다. 첫 번째 작품은 다른 사람에 대한 주장의 순서입니다 (첫 번째, 두 번째 등). 두 번째는 인수의 유형이며 인수의 유형 선언으로 구성됩니다 (예 : int, char * 등). 세 번째 부분은 라이브러리 함수 호출에서 인수에 대한 호출 규칙입니다.</target>
        </trans-unit>
        <trans-unit id="92bc744ea7824ccea4eeb23e82728fbc4ddab899" translate="yes" xml:space="preserve">
          <source>When you supply a separate display name it becomes possible to run a test more than once; the display name is effectively the alias by which the test is known inside the harness. The harness doesn't care if it runs the same test more than once when each invocation uses a different name.</source>
          <target state="translated">별도의 표시 이름을 제공하면 테스트를 두 번 이상 실행할 수 있습니다. 표시 이름은 사실상 테스트가 하네스 내부에서 알려진 별칭입니다. 하네스는 각 호출이 다른 이름을 사용할 때 동일한 테스트를 두 번 이상 실행하는지 상관하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f5d8e81bcb99e99cbe008b301dbaa4156e030e10" translate="yes" xml:space="preserve">
          <source>When you use &lt;code&gt;&lt;a href=&quot;../functions/flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; to lock the file, &lt;code&gt;Tie::File&lt;/code&gt; assumes that the read cache is no longer trustworthy, because another process might have modified the file since the last time it was read. Therefore, a successful call to &lt;code&gt;&lt;a href=&quot;../functions/flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; discards the contents of the read cache and the internal record offset table.</source>
          <target state="translated">당신이 사용할 때 &lt;code&gt;&lt;a href=&quot;../functions/flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; 파일을 잠글, &lt;code&gt;Tie::File&lt;/code&gt; 다른 프로세스가 읽은 마지막 시간 이후 파일을 수정 한 수 있기 때문에 읽기 캐시는 더 이상 신뢰할이 있다고 가정합니다. 따라서 &lt;code&gt;&lt;a href=&quot;../functions/flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; 성공적으로 호출 하면 읽기 캐시 및 내부 레코드 오프셋 테이블의 내용이 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="86d314b9ffee5484e299c428ac086a5864115f83" translate="yes" xml:space="preserve">
          <source>When you use &lt;code&gt;flock&lt;/code&gt; to lock the file, &lt;code&gt;Tie::File&lt;/code&gt; assumes that the read cache is no longer trustworthy, because another process might have modified the file since the last time it was read. Therefore, a successful call to &lt;code&gt;flock&lt;/code&gt; discards the contents of the read cache and the internal record offset table.</source>
          <target state="translated">당신이 사용할 때 &lt;code&gt;flock&lt;/code&gt; 파일을 잠글, &lt;code&gt;Tie::File&lt;/code&gt; 다른 프로세스가 읽은 마지막 시간 이후 파일을 수정 한 수 있기 때문에 읽기 캐시는 더 이상 신뢰할이 있다고 가정합니다. 따라서 &lt;code&gt;flock&lt;/code&gt; 을 성공적으로 호출 하면 읽기 캐시 및 내부 레코드 오프셋 테이블의 내용이 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="de1ea55b20ff67d97a482097e7d303cd94b1b34c" translate="yes" xml:space="preserve">
          <source>When you use Perl from C, your C program will--usually--allocate, &quot;run&quot;, and deallocate a</source>
          <target state="translated">C에서 Perl을 사용하면 C 프로그램은 일반적으로 a를 할당, &quot;실행&quot;및 할당 해제합니다.</target>
        </trans-unit>
        <trans-unit id="5b4b7e46fe751c099868927c5d1568ad4f11af65" translate="yes" xml:space="preserve">
          <source>When you use the &lt;b&gt;-n&lt;/b&gt; and &lt;b&gt;-p&lt;/b&gt; switches to Perl, &lt;code&gt;BEGIN&lt;/code&gt; and &lt;code&gt;END&lt;/code&gt; work just as they do in &lt;b&gt;awk&lt;/b&gt;, as a degenerate case. Both &lt;code&gt;BEGIN&lt;/code&gt; and &lt;code&gt;CHECK&lt;/code&gt; blocks are run when you use the &lt;b&gt;-c&lt;/b&gt; switch for a compile-only syntax check, although your main code is not.</source>
          <target state="translated">당신이 사용하는 경우 &lt;b&gt;-n&lt;/b&gt; 및 &lt;b&gt;-p&lt;/b&gt; 펄에 스위치를, &lt;code&gt;BEGIN&lt;/code&gt; 및 &lt;code&gt;END&lt;/code&gt; 의 그들이에서와 마찬가지로 작업 &lt;b&gt;AWK&lt;/b&gt; 퇴보 한 경우로,. 두 &lt;code&gt;BEGIN&lt;/code&gt; 및 &lt;code&gt;CHECK&lt;/code&gt; 당신이 사용하는 경우 블록이 실행됩니다 &lt;b&gt;-c&lt;/b&gt; 컴파일 전용 구문 점검을 위해 스위치를 메인 코드는 아니지만.</target>
        </trans-unit>
        <trans-unit id="6e7c5168dc3e4d09a86a5c07db61ae55b067c306" translate="yes" xml:space="preserve">
          <source>When you use the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings&lt;/code&gt; pragma or Perl's &lt;b&gt;-w&lt;/b&gt; command-line option, you may see warnings about useless uses of constants or functions in &quot;void context&quot;. Void context just means the value has been discarded, such as a statement containing only &lt;code&gt;&quot;fred&quot;;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/getpwuid&quot;&gt;getpwuid(0);&lt;/a&gt;&lt;/code&gt;. It still counts as scalar context for functions that care whether or not they're being called in list context.</source>
          <target state="translated">당신이 사용하는 경우 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings&lt;/code&gt; 프라그 펄의 &lt;b&gt;-w&lt;/b&gt; 명령 줄 옵션을, 당신은 &quot;무효 컨텍스트&quot;상수 또는 함수의 쓸모없는 사용에 대한 경고가 표시 될 수 있습니다. 공허한 문맥은 단지 &lt;code&gt;&quot;fred&quot;;&lt;/code&gt; 만을 포함하는 문장과 같이 값이 폐기되었음을 의미합니다 . 또는 &lt;code&gt;&lt;a href=&quot;functions/getpwuid&quot;&gt;getpwuid(0);&lt;/a&gt;&lt;/code&gt; . 리스트 컨텍스트에서 호출되는지 여부를 관리하는 함수의 스칼라 컨텍스트로 계산됩니다.</target>
        </trans-unit>
        <trans-unit id="21a0f043d5bac1b816d417902a549ec51099c064" translate="yes" xml:space="preserve">
          <source>When you use the &lt;code&gt;use warnings&lt;/code&gt; pragma or Perl's &lt;b&gt;-w&lt;/b&gt; command-line option, you may see warnings about useless uses of constants or functions in &quot;void context&quot;. Void context just means the value has been discarded, such as a statement containing only &lt;code&gt;&quot;fred&quot;;&lt;/code&gt; or &lt;code&gt;getpwuid(0);&lt;/code&gt;. It still counts as scalar context for functions that care whether or not they're being called in list context.</source>
          <target state="translated">당신이 사용하는 경우 &lt;code&gt;use warnings&lt;/code&gt; 프라그 펄의 &lt;b&gt;-w&lt;/b&gt; 명령 줄 옵션을, 당신은 &quot;무효 컨텍스트&quot;상수 또는 함수의 쓸모없는 사용에 대한 경고가 표시 될 수 있습니다. Void 컨텍스트는 &lt;code&gt;&quot;fred&quot;;&lt;/code&gt; 만 포함하는 명령문과 같이 값이 폐기되었음을 의미합니다 . 또는 &lt;code&gt;getpwuid(0);&lt;/code&gt; . 목록 컨텍스트에서 호출되는지 여부를 신경 쓰는 함수의 경우 여전히 스칼라 컨텍스트로 계산됩니다.</target>
        </trans-unit>
        <trans-unit id="f561cbf428cfa38a570f079c8fe3f1e6c4934924" translate="yes" xml:space="preserve">
          <source>When you want to encode Unicode for mails and web pages, however, do not use UTF-7 unless you are sure your recipients and readers can handle it. Very few MUAs and WWW Browsers support these days (only Mozilla seems to support one). For general cases, use UTF-8 for message body and MIME-Header for header instead.</source>
          <target state="translated">그러나 메일 및 웹 페이지 용 유니 코드를 인코딩하려는 경우 수신자 및 독자가 처리 할 수 ​​있다고 확신하지 않는 한 UTF-7을 사용하지 마십시오. 요즘 지원하는 MUA 및 WWW 브라우저는 거의 없습니다 (Mozilla 만 지원). 일반적인 경우에는 메시지 본문에 UTF-8을 사용하고 대신 헤더에 MIME- 헤더를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="d1594b9a6f30c884e42aa7810e12c05455ffa364" translate="yes" xml:space="preserve">
          <source>When you want to write to a file, you first have to decide what to do about any existing contents of that file. You have two basic choices here: to preserve or to clobber.</source>
          <target state="translated">파일에 쓰려면 먼저 해당 파일의 기존 내용에 대해 수행 할 작업을 결정해야합니다. 여기에는 두 가지 기본 선택이 있습니다 : 보존 또는 클로버.</target>
        </trans-unit>
        <trans-unit id="f729e16e6d70d308845c4e263f4f5d66444de2cc" translate="yes" xml:space="preserve">
          <source>When you're done with your filehandles, you should &lt;code&gt;&lt;a href=&quot;functions/close&quot;&gt;close()&lt;/a&gt;&lt;/code&gt; them (though to be honest, Perl will clean up after you if you forget):</source>
          <target state="translated">파일 핸들링을 마쳤 으면 &lt;code&gt;&lt;a href=&quot;functions/close&quot;&gt;close()&lt;/a&gt;&lt;/code&gt; 해야합니다 (솔직히 말하면 Perl은 잊어 버린 후에 정리합니다).</target>
        </trans-unit>
        <trans-unit id="1488b5ce874430f2891cff85427abec3fe4ed92a" translate="yes" xml:space="preserve">
          <source>When you're done with your filehandles, you should &lt;code&gt;close()&lt;/code&gt; them (though to be honest, Perl will clean up after you if you forget):</source>
          <target state="translated">파일 핸들 작업이 끝나면 &lt;code&gt;close()&lt;/code&gt; 해야합니다 (솔직히 말해서 Perl은 잊어 버린 후에 정리할 것입니다) :</target>
        </trans-unit>
        <trans-unit id="f855bc56e9b2d1a2f4296535cb927b2c13c9dd7d" translate="yes" xml:space="preserve">
          <source>When you're using RETVAL to return an &lt;code&gt;SV *&lt;/code&gt; , there's some magic going on behind the scenes that should be mentioned. When you're manipulating the argument stack using the ST(x) macro, for example, you usually have to pay special attention to reference counts. (For more about reference counts, see &lt;a href=&quot;perlguts&quot;&gt;perlguts&lt;/a&gt;.) To make your life easier, the typemap file automatically makes &lt;code&gt;RETVAL&lt;/code&gt; mortal when you're returning an &lt;code&gt;SV *&lt;/code&gt; . Thus, the following two XSUBs are more or less equivalent:</source>
          <target state="translated">RETVAL을 사용하여 &lt;code&gt;SV *&lt;/code&gt; 를 반환하는 경우 언급해야 할 장면 뒤에 약간의 마술이 있습니다. 예를 들어 ST (x) 매크로를 사용하여 인수 스택을 조작 할 때는 일반적으로 참조 횟수에 특별한주의를 기울여야합니다. 참조 횟수에 대한 자세한 내용은 &lt;a href=&quot;perlguts&quot;&gt;perlguts를&lt;/a&gt; 참조하십시오 .보다 편리하게 사용할 수 있도록 typemap 파일 은 &lt;code&gt;SV *&lt;/code&gt; 를 반환 할 때 &lt;code&gt;RETVAL&lt;/code&gt; 을 자동으로 치명적 으로 만듭니다 . 따라서 다음 두 XSUB는 거의 동일합니다.</target>
        </trans-unit>
        <trans-unit id="aff47fe5db562b3d2dbc867dc1c147d97de9621a" translate="yes" xml:space="preserve">
          <source>When you're using RETVAL to return an &lt;code&gt;SV *&lt;/code&gt;, there's some magic going on behind the scenes that should be mentioned. When you're manipulating the argument stack using the ST(x) macro, for example, you usually have to pay special attention to reference counts. (For more about reference counts, see &lt;a href=&quot;perlguts&quot;&gt;perlguts&lt;/a&gt;.) To make your life easier, the typemap file automatically makes &lt;code&gt;RETVAL&lt;/code&gt; mortal when you're returning an &lt;code&gt;SV *&lt;/code&gt;. Thus, the following two XSUBs are more or less equivalent:</source>
          <target state="translated">RETVAL을 사용하여 &lt;code&gt;SV *&lt;/code&gt; 를 반환 할 때 언급해야 할 몇 가지 마술이 뒤에서 진행되고 있습니다. 예를 들어 ST (x) 매크로를 사용하여 인수 스택을 조작 할 때 일반적으로 참조 카운트에 특별한주의를 기울여야합니다. (참조 횟수에 대한 자세한 내용은 &lt;a href=&quot;perlguts&quot;&gt;perlguts를&lt;/a&gt; 참조하십시오 .) 삶을 더 쉽게 만들기 위해 typemap 파일 은 &lt;code&gt;SV *&lt;/code&gt; 를 반환 할 때 자동으로 &lt;code&gt;RETVAL&lt;/code&gt; 을 필사적 으로 만듭니다 . 따라서 다음 두 XSUB는 다소 동등합니다.</target>
        </trans-unit>
        <trans-unit id="5829efde6fb988f406fa62c8ae4c250e14e41e30" translate="yes" xml:space="preserve">
          <source>When you've found that there isn't a module available for what you're trying to do, and you've had to write the code yourself, consider packaging up the solution into a module and uploading it to CPAN so that others can benefit.</source>
          <target state="translated">수행하려는 작업에 사용할 수있는 모듈이없고 코드를 직접 작성해야하는 경우 솔루션을 모듈에 패키징하고 CPAN에 업로드하여 다른 사용자가 할 수 있도록하십시오 이익.</target>
        </trans-unit>
        <trans-unit id="6b113771452e06c12bd2750d8700f91d2cc72def" translate="yes" xml:space="preserve">
          <source>When you've got your name sorted out and you're sure that your module is wanted and not currently available, it's time to start coding.</source>
          <target state="translated">이름을 정리하고 모듈을 원하고 현재 사용할 수없는 것이 확실한 경우 코딩을 시작할 차례입니다.</target>
        </trans-unit>
        <trans-unit id="baa149e5f728be9fcf5c842fafa04ad779a77d18" translate="yes" xml:space="preserve">
          <source>When your child is done running tests, you must call &lt;code&gt;finalize&lt;/code&gt; to clean up and tell the parent your pass/fail status.</source>
          <target state="translated">자녀가 시험을 &lt;code&gt;finalize&lt;/code&gt; 를 호출 하여 부모에게 합격 / 실패 상태를 알려야합니다.</target>
        </trans-unit>
        <trans-unit id="701f121f0767fb048f9a1e9cdd7bcb29143a3d18" translate="yes" xml:space="preserve">
          <source>When your module encounters an error it should do one or more of:</source>
          <target state="translated">모듈에 오류가 발생하면 다음 중 하나 이상을 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="7d300f1dcd786450162ec26ef8c71857af330be4" translate="yes" xml:space="preserve">
          <source>When, &lt;code&gt;$Archive::Tar::CHMOD&lt;/code&gt; is enabled, this setting controls whether the permissions on files from the archive are used without modification of if they are filtered by removing any setid bits and applying the current umask.</source>
          <target state="translated">시, &lt;code&gt;$Archive::Tar::CHMOD&lt;/code&gt; 활성화되어, 아카이브에서 파일에 대한 권한 여부를이 설정 컨트롤은 어떤 setid 비트를 제거하고 현재의 umask를 적용하여 필터링하는 경우의 수정없이 사용된다.</target>
        </trans-unit>
        <trans-unit id="c7c9dae84175d878d430d8cca64e61d718171eab" translate="yes" xml:space="preserve">
          <source>When, however, you assign a list of scalars to another list of scalars, the results differ according to whether the left-hand list -- the list being assigned to -- has the same, more or fewer elements than the right-hand list.</source>
          <target state="translated">그러나 스칼라 목록을 다른 스칼라 목록에 할당하면 왼쪽 목록 (할당되는 목록)에 오른쪽 목록과 동일한 요소가 있는지 여부에 따라 결과가 달라집니다. .</target>
        </trans-unit>
        <trans-unit id="d830d827614f19bd45afae435d976e89279e08bd" translate="yes" xml:space="preserve">
          <source>Whenever JSON allows whitespace, C++-style one-line comments are additionally allowed. They are terminated by the first carriage-return or line-feed character, after which more white-space and comments are allowed.</source>
          <target state="translated">JSON이 공백을 허용 할 때마다 C ++ 스타일의 한 줄 주석이 추가로 허용됩니다. 첫 번째 캐리지 리턴 또는 줄 바꿈 문자로 종료되며 그 이후에는 더 많은 공백과 주석이 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="042aae650b0c414ca1cd41812840fd2d72dec204" translate="yes" xml:space="preserve">
          <source>Whenever JSON allows whitespace, C-style multiple-line comments are additionally allowed. Everything between &lt;code&gt;/*&lt;/code&gt; and &lt;code&gt;*/&lt;/code&gt; is a comment, after which more white-space and comments are allowed.</source>
          <target state="translated">JSON이 공백을 허용 할 때마다 C 스타일의 여러 줄 주석이 추가로 허용됩니다. &lt;code&gt;/*&lt;/code&gt; 와 &lt;code&gt;*/&lt;/code&gt; 사이의 모든 것은 주석이며 그 이후에는 더 많은 공백과 주석이 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="99a2ef40caf9ba8f64a09af2f45cf33737585968" translate="yes" xml:space="preserve">
          <source>Whenever JSON allows whitespace, shell-style comments are additionally allowed. They are terminated by the first carriage-return or line-feed character, after which more white-space and comments are allowed.</source>
          <target state="translated">JSON이 공백을 허용 할 때마다 쉘 스타일 주석이 추가로 허용됩니다. 첫 번째 캐리지 리턴 또는 줄 바꿈 문자로 종료되며 그 이후에는 더 많은 공백과 주석이 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="cabccb147592c137e487eb001cea479dffb70830" translate="yes" xml:space="preserve">
          <source>Whenever a Berkeley DB function returns data via one of its parameters, the equivalent &lt;b&gt;DB_File&lt;/b&gt; method does exactly the same.</source>
          <target state="translated">Berkeley DB 함수가 매개 변수 중 하나를 통해 데이터를 리턴 할 때마다 동등한 &lt;b&gt;DB_File&lt;/b&gt; 메소드는 정확히 동일합니다.</target>
        </trans-unit>
        <trans-unit id="6a800aba7242513688fb7365bc61881077cd8882" translate="yes" xml:space="preserve">
          <source>Whenever a Perl subroutine is called using one of the</source>
          <target state="translated">Perl 서브 루틴이 다음 중 하나를 사용하여 호출 될 때마다</target>
        </trans-unit>
        <trans-unit id="6344d70f52ab5669e0f868bcc4766007019f0e1c" translate="yes" xml:space="preserve">
          <source>Whenever a reference is used as a field hash key, the object registry is checked and a new entry is made if necessary. The field hash is then added to the list of fields this reference has used.</source>
          <target state="translated">참조가 필드 해시 키로 사용될 때마다 오브젝트 레지스트리가 점검되고 필요한 경우 새 항목이 작성됩니다. 그런 다음이 참조가 사용한 필드 목록에 필드 해시가 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="ac59cb12b90f854e158e9f7e8d962f434ede4764" translate="yes" xml:space="preserve">
          <source>Whenever control returns from the</source>
          <target state="translated">제어가</target>
        </trans-unit>
        <trans-unit id="56847d63f6da95857482dd3497381b06019beb12" translate="yes" xml:space="preserve">
          <source>Whenever metadata consumers merge prerequisites, either from different phases or from &lt;code&gt;optional_features&lt;/code&gt;, they should merged in a way which preserves the intended semantics of the prerequisite structure. Generally, this means concatenating the version specifications using commas, as described in the &lt;a href=&quot;#Version-Ranges&quot;&gt;&quot;Version Ranges&quot;&lt;/a&gt; section.</source>
          <target state="translated">메타 데이터 소비자가 다른 단계 또는 &lt;code&gt;optional_features&lt;/code&gt; 에서 전제 조건을 병합 할 때마다 전제 조건 구조의 의도 된 의미를 보존하는 방식으로 병합되어야합니다. 일반적으로 이는 &lt;a href=&quot;#Version-Ranges&quot;&gt;&quot;버전 범위&quot;&lt;/a&gt; 섹션에 설명 된대로 쉼표를 사용하여 버전 사양을 연결하는 것을 의미 합니다.</target>
        </trans-unit>
        <trans-unit id="58a47aafac8fca0c788807bc11f865583b9a79dd" translate="yes" xml:space="preserve">
          <source>Whenever possible, new features should be prototyped in a CPAN module before they will be considered for the core.</source>
          <target state="translated">가능할 때마다 핵심 기능을 고려하기 전에 CPAN 모듈에서 새로운 기능을 프로토 타입해야합니다.</target>
        </trans-unit>
        <trans-unit id="a368a6c064c79ec6ec1d84f92fa7a58354e83dad" translate="yes" xml:space="preserve">
          <source>Whenever this is applied to a string which doesn't quite meet the pattern's expectations such as &lt;code&gt;&quot;abc  &quot;&lt;/code&gt; or &lt;code&gt;&quot;abc  def &quot;&lt;/code&gt; , the regex engine will backtrack, approximately once for each character in the string. But we know that there is no way around taking</source>
          <target state="translated">이것이 &lt;code&gt;&quot;abc &quot;&lt;/code&gt; 또는 &lt;code&gt;&quot;abc def &quot;&lt;/code&gt; 와 같은 패턴의 기대치를 충족시키지 못하는 문자열에 적용될 때마다 정규 표현식 엔진은 문자열의 각 문자에 대해 한 번 정도 역 추적합니다. 그러나 우리는 복용 주위에 방법이 없다는 것을 알고</target>
        </trans-unit>
        <trans-unit id="ff79b096fb177b1f29c2b3cfee678fdb53ec5582" translate="yes" xml:space="preserve">
          <source>Whenever this is applied to a string which doesn't quite meet the pattern's expectations such as &lt;code&gt;&quot;abc &quot;&lt;/code&gt; or &lt;code&gt;&quot;abc def &quot;&lt;/code&gt;, the regexp engine will backtrack, approximately once for each character in the string. But we know that there is no way around taking</source>
          <target state="translated">이것이 &lt;code&gt;&quot;abc &quot;&lt;/code&gt; 또는 &lt;code&gt;&quot;abc def &quot;&lt;/code&gt; 와 같은 패턴의 기대치를 충족하지 못하는 문자열에 적용될 때마다 정규 표현식 엔진은 문자열의 각 문자에 대해 약 한 번씩 역 추적합니다. 그러나 우리는 복용하는 방법이 없다는 것을 압니다.</target>
        </trans-unit>
        <trans-unit id="1d972aca2274b3be6437814e7f18c3f8fdf56c12" translate="yes" xml:space="preserve">
          <source>Whenever you do I/O on a file in Perl, you do so through what in Perl is called a &lt;b&gt;filehandle&lt;/b&gt;. A filehandle is an internal name for an external file. It is the job of the &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; function to make the association between the internal name and the external name, and it is the job of the &lt;code&gt;&lt;a href=&quot;functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; function to break that association.</source>
          <target state="translated">펄에서 파일 I / O를 할 때마다, 당신은 펄의 소위를 통해이를 &lt;b&gt;핸들&lt;/b&gt; . 파일 핸들은 외부 파일의 내부 이름입니다. 내부 이름과 외부 이름을 연결 하는 것은 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; 기능의 작업이며 해당 연결을 끊는 것은 &lt;code&gt;&lt;a href=&quot;functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; 기능 의 작업입니다 .</target>
        </trans-unit>
        <trans-unit id="2609a2feff469b602ec869a4ded1b4330334544b" translate="yes" xml:space="preserve">
          <source>Whenever you do I/O on a file in Perl, you do so through what in Perl is called a &lt;b&gt;filehandle&lt;/b&gt;. A filehandle is an internal name for an external file. It is the job of the &lt;code&gt;open&lt;/code&gt; function to make the association between the internal name and the external name, and it is the job of the &lt;code&gt;close&lt;/code&gt; function to break that association.</source>
          <target state="translated">Perl에서 파일에 대해 I / O를 수행 할 때마다 Perl에서 &lt;b&gt;filehandle&lt;/b&gt; 이라고하는 것을 통해 수행 합니다. 파일 핸들은 외부 파일의 내부 이름입니다. 내부 이름과 외부 이름을 연결 하는 것은 &lt;code&gt;open&lt;/code&gt; 기능의 작업이고, 그 연결을 끊는 것은 &lt;code&gt;close&lt;/code&gt; 기능 의 작업입니다 .</target>
        </trans-unit>
        <trans-unit id="ed7093ca3cc4a3c897e96991516ce1f4f0fcfd4e" translate="yes" xml:space="preserve">
          <source>Whenever you have more than one subprocess, you must be careful that each closes whichever half of any pipes created for interprocess communication it is not using. This is because any child process reading from the pipe and expecting an EOF will never receive it, and therefore never exit. A single process closing a pipe is not enough to close it; the last process with the pipe open must close it for it to read EOF.</source>
          <target state="translated">하나 이상의 서브 프로세스가있을 때마다 프로세스 간 통신을 위해 작성된 파이프 중 절반이 닫히지 않도록주의해야합니다. 이는 파이프에서 읽고 EOF를 기대하는 모든 하위 프로세스가이를 수신하지 않으므로 종료되지 않기 때문입니다. 파이프를 닫는 단일 프로세스로는 파이프를 닫을 수 없습니다. EOF를 읽으려면 파이프를 연 상태에서 마지막 프로세스를 닫아야합니다.</target>
        </trans-unit>
        <trans-unit id="cd1ee0eb738b950d883ab6c08ca29be20ef06df7" translate="yes" xml:space="preserve">
          <source>Whenever you're communicating text with anything that is external to your perl process, like a database, a text file, a socket, or another program. Even if the thing you're communicating with is also written in Perl.</source>
          <target state="translated">데이터베이스, 텍스트 파일, 소켓 또는 다른 프로그램과 같이 펄 프로세스 외부의 텍스트와 텍스트를 통신 할 때마다 당신이 의사 소통하고있는 것이 Perl로 쓰여져 있더라도.</target>
        </trans-unit>
        <trans-unit id="cc31f890f5831db8c47f9104a5fd72a40a9b958c" translate="yes" xml:space="preserve">
          <source>Whenever your encoded, binary string is used together with a text string, Perl will assume that your binary string was encoded with ISO-8859-1, also known as latin-1. If it wasn't latin-1, then your data is unpleasantly converted. For example, if it was UTF-8, the individual bytes of multibyte characters are seen as separate characters, and then again converted to UTF-8. Such double encoding can be compared to double HTML encoding (&lt;code&gt;&amp;amp;amp;gt;&lt;/code&gt; ), or double URI encoding (&lt;code&gt;%253E&lt;/code&gt; ).</source>
          <target state="translated">인코딩 된 이진 문자열이 텍스트 문자열과 함께 사용될 때마다 Perl은 이진 문자열이 라틴 -1이라고도하는 ISO-8859-1로 인코딩 된 것으로 가정합니다. 라틴 -1이 아닌 경우 데이터가 불쾌하게 변환됩니다. 예를 들어, UTF-8 인 경우 멀티 바이트 문자의 개별 바이트는 별도의 문자로 표시되고 다시 UTF-8로 변환됩니다. 이러한 이중 인코딩은 이중 HTML 인코딩 ( &lt;code&gt;&amp;amp;amp;gt;&lt;/code&gt; ) 또는 이중 URI 인코딩 ( &lt;code&gt;%253E&lt;/code&gt; ) 과 비교 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b8d5a9055801b14712a33d32b68e49a7db91b2d3" translate="yes" xml:space="preserve">
          <source>Whenever your encoded, binary string is used together with a text string, Perl will assume that your binary string was encoded with ISO-8859-1, also known as latin-1. If it wasn't latin-1, then your data is unpleasantly converted. For example, if it was UTF-8, the individual bytes of multibyte characters are seen as separate characters, and then again converted to UTF-8. Such double encoding can be compared to double HTML encoding (&lt;code&gt;&amp;amp;amp;gt;&lt;/code&gt;), or double URI encoding (&lt;code&gt;%253E&lt;/code&gt;).</source>
          <target state="translated">인코딩 된 이진 문자열이 텍스트 문자열과 함께 사용될 때마다 Perl은 이진 문자열이 latin-1이라고도하는 ISO-8859-1로 인코딩되었다고 가정합니다. latin-1이 아니라면 데이터가 불쾌하게 변환됩니다. 예를 들어 UTF-8 인 경우 멀티 바이트 문자의 개별 바이트는 별도의 문자로 표시되고 다시 UTF-8로 변환됩니다. 이러한 이중 인코딩은 이중 HTML 인코딩 ( &lt;code&gt;&amp;amp;amp;gt;&lt;/code&gt; ) 또는 이중 URI 인코딩 ( &lt;code&gt;%253E&lt;/code&gt; ) 과 비교할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e1d629f115a3e97bf6ae620fc76d3801dd8ef401" translate="yes" xml:space="preserve">
          <source>Whenever your program accesses data or resources that can be accessed by other threads, you must take steps to coordinate access or risk data inconsistency and race conditions. Note that Perl will protect its internals from your race conditions, but it won't protect you from you.</source>
          <target state="translated">프로그램이 다른 스레드가 액세스 할 수있는 데이터 또는 리소스에 액세스 할 때마다 액세스를 조정하거나 데이터 불일치 및 경쟁 조건을 위험에 빠뜨리기위한 조치를 취해야합니다. Perl은 경쟁 조건으로부터 내부를 보호하지만 귀하를 보호하지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="525f61b6729229b1a8854a9e50bcaa52ea96b131" translate="yes" xml:space="preserve">
          <source>Where</source>
          <target state="translated">Where</target>
        </trans-unit>
        <trans-unit id="59d37a0123152108bee6e05a64e55d45d68bc028" translate="yes" xml:space="preserve">
          <source>Where $directory_count % 10 is 1 (&quot;%&quot; for modulo, remember), assuming $directory count is an integer, and except where $directory_count % 100 is 11, &quot;directories&quot; is forced to become grammatically singular, which means it gets the ending for the accusative singular... You begin to visualize the code it'd take to test for the problem so far,</source>
          <target state="translated">$ directory_count % 10이 1 인 경우 (모듈로의 경우 &quot;%&quot;), $ directory count가 정수라고 가정하고 $ directory_count % 100이 11 인 경우를 제외하고 &quot;디렉토리&quot;는 문법적으로 단수가되어야합니다. 비난 단수로 끝납니다. 지금까지 문제를 테스트하는 데 필요한 코드를 시각화하기 시작합니다.</target>
        </trans-unit>
        <trans-unit id="fb9b184246f9c47c2085ba5fb400e91c6332924c" translate="yes" xml:space="preserve">
          <source>Where 1 is the position of the first char in the string. Note that position can be 0, or larger than the actual length of the pattern, likewise length can be zero.</source>
          <target state="translated">여기서 1은 문자열에서 첫 번째 문자의 위치입니다. 위치는 0이거나 패턴의 실제 길이보다 클 수 있으며, 마찬가지로 길이는 0 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="73e22419719a01d34b548da9ec30ecb83ae08c13" translate="yes" xml:space="preserve">
          <source>Where &lt;code&gt;$id1&lt;/code&gt; , &lt;code&gt;$id2&lt;/code&gt; are two byte subfield ID's.</source>
          <target state="translated">여기서 &lt;code&gt;$id1&lt;/code&gt; , &lt;code&gt;$id2&lt;/code&gt; 는 2 바이트 서브 필드 ID입니다.</target>
        </trans-unit>
        <trans-unit id="b9cb4e493b9dc9b7340611ceb99bc1cecceb2405" translate="yes" xml:space="preserve">
          <source>Where &lt;code&gt;$id1&lt;/code&gt; , &lt;code&gt;$id2&lt;/code&gt; are two byte subfield ID's. The second byte of the ID cannot be 0, unless the &lt;code&gt;Strict&lt;/code&gt; option has been disabled.</source>
          <target state="translated">여기서 &lt;code&gt;$id1&lt;/code&gt; , &lt;code&gt;$id2&lt;/code&gt; 는 2 바이트 서브 필드 ID입니다. &lt;code&gt;Strict&lt;/code&gt; 옵션이 비활성화되어 있지 않으면 ID의 두 번째 바이트는 0이 될 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="77383c70462fa701aace92ef9b074251586e9457" translate="yes" xml:space="preserve">
          <source>Where &lt;code&gt;$id1&lt;/code&gt;, &lt;code&gt;$id2&lt;/code&gt; are two byte subfield ID's.</source>
          <target state="translated">어디 &lt;code&gt;$id1&lt;/code&gt; , &lt;code&gt;$id2&lt;/code&gt; 두 바이트 서브 필드 ID의의입니다.</target>
        </trans-unit>
        <trans-unit id="2a738c1e73fe6ddbf768fa126f517ebb72454b3e" translate="yes" xml:space="preserve">
          <source>Where &lt;code&gt;$id1&lt;/code&gt;, &lt;code&gt;$id2&lt;/code&gt; are two byte subfield ID's. The second byte of the ID cannot be 0, unless the &lt;code&gt;Strict&lt;/code&gt; option has been disabled.</source>
          <target state="translated">어디 &lt;code&gt;$id1&lt;/code&gt; , &lt;code&gt;$id2&lt;/code&gt; 두 바이트 서브 필드 ID의의입니다. &lt;code&gt;Strict&lt;/code&gt; 옵션이 비활성화 되지 않은 경우 ID의 두 번째 바이트는 0이 될 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="de8d3be1468ab688b0e6e35d8cea1268cae0caa0" translate="yes" xml:space="preserve">
          <source>Where &lt;code&gt;$r1&lt;/code&gt; can be a reference to any kind of data structure you'd like. It will be deeply copied. Because &lt;code&gt;dclone&lt;/code&gt; takes and returns references, you'd have to add extra punctuation if you had a hash of arrays that you wanted to copy.</source>
          <target state="translated">여기서 &lt;code&gt;$r1&lt;/code&gt; 은 원하는 모든 종류의 데이터 구조에 대한 참조가 될 수 있습니다. 깊이 복사됩니다. 때문에 &lt;code&gt;dclone&lt;/code&gt; 이 소요 반환 참조, 당신은 당신이 복사 싶어 배열의 해시가 있다면 별도의 문장을 추가해야 할 것입니다.</target>
        </trans-unit>
        <trans-unit id="29126cbcaebf3032a0f200bdad16fd67b9d2ca9f" translate="yes" xml:space="preserve">
          <source>Where a &lt;b&gt;compiler&lt;/b&gt; remembers symbols. A program like Perl must somehow remember all the names of all the &lt;b&gt;variables&lt;/b&gt;, &lt;b&gt;filehandles&lt;/b&gt;, and &lt;b&gt;subroutines&lt;/b&gt; you&amp;rsquo;ve used. It does this by placing the names in a symbol table, which is implemented in Perl using a &lt;b&gt;hash table&lt;/b&gt;. There is a separate symbol table for each &lt;b&gt;package&lt;/b&gt; to give each package its own &lt;b&gt;namespace&lt;/b&gt;.</source>
          <target state="translated">&lt;b&gt;컴파일러가&lt;/b&gt; 기호를 기억 하는 곳 . Perl과 같은 프로그램은 사용했던 모든 &lt;b&gt;변수&lt;/b&gt; , &lt;b&gt;파일 핸들&lt;/b&gt; 및 &lt;b&gt;서브 루틴&lt;/b&gt; 의 모든 이름을 어떻게 든 기억해야합니다 . 이는 &lt;b&gt;해시 테이블을&lt;/b&gt; 사용하여 Perl에서 구현되는 기호 테이블에 이름을 배치하여 수행 &lt;b&gt;합니다&lt;/b&gt; . 각 &lt;b&gt;패키지&lt;/b&gt; 마다 고유 한 &lt;b&gt;네임 스페이스&lt;/b&gt; 를 제공하기 위해 각 패키지 마다 별도의 기호 테이블이 &lt;b&gt;있습니다&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="c27a5a0858ef6e994699b8e168fe5635708702fa" translate="yes" xml:space="preserve">
          <source>Where a layer opens or takes ownership of a file descriptor, that layer is responsible for getting the file descriptor's close-on-exec flag into the correct state. The flag should be clear for a file descriptor numbered less than or equal to &lt;code&gt;PL_maxsysfd&lt;/code&gt;, and set for any file descriptor numbered higher. For thread safety, when a layer opens a new file descriptor it should if possible open it with the close-on-exec flag initially set.</source>
          <target state="translated">계층이 파일 설명 자의 소유권을 열거 나 가져 오는 경우 해당 계층은 파일 설명 자의 close-on-exec 플래그를 올바른 상태로 가져 오는 책임이 있습니다. &lt;code&gt;PL_maxsysfd&lt;/code&gt; 이하로 번호가 매겨진 파일 설명자에 대해 플래그가 지워 져야 하며 더 높은 번호가 매겨진 파일 설명자에 대해 설정되어야합니다. 스레드 안전을 위해 레이어가 새 파일 설명자를 열 때 가능한 경우 초기에 설정된 close-on-exec 플래그를 사용하여 열어야합니다.</target>
        </trans-unit>
        <trans-unit id="841b8cfbd59c36bfe89c29e0da6a4675a6abce15" translate="yes" xml:space="preserve">
          <source>Where are modules installed?</source>
          <target state="translated">모듈은 어디에 설치되어 있습니까?</target>
        </trans-unit>
        <trans-unit id="77cc20dcc0c42287d0cc6c95ce660feb0b4c5aeb" translate="yes" xml:space="preserve">
          <source>Where can I buy a commercial version of Perl?</source>
          <target state="translated">Perl의 상용 버전은 어디에서 구입할 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="08cf7f142b0ee15a977fe964d0ddcdb1002739ae" translate="yes" xml:space="preserve">
          <source>Where can I get Perl macros for vi?</source>
          <target state="translated">vi 용 Perl 매크로를 어디서 구할 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="406cbb0495a55956cb84611a8d86c9d721557519" translate="yes" xml:space="preserve">
          <source>Where can I get information on Perl?</source>
          <target state="translated">Perl에 대한 정보는 어디서 얻을 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="c63d9dfa4f6d6dcfc8103ea7650db10cd8e27fea" translate="yes" xml:space="preserve">
          <source>Where can I get perl-mode or cperl-mode for emacs?</source>
          <target state="translated">emacs에 대한 펄 모드 또는 cperl 모드는 어디서 구할 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="b85fdb935a7a614522614b7feed541611e8d0a3e" translate="yes" xml:space="preserve">
          <source>Where can I get the latest libnet release</source>
          <target state="translated">최신 libnet 릴리스는 어디서 구할 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="f0f1c9d2159564047b740e7956f5640af04f1e3c" translate="yes" xml:space="preserve">
          <source>Where can I learn about CGI or Web programming in Perl?</source>
          <target state="translated">Perl에서 CGI 또는 웹 프로그래밍에 대해 어디서 배울 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="703366e9bd37f95d6d2b90762995773aff84d67e" translate="yes" xml:space="preserve">
          <source>Where can I learn about linking C with Perl?</source>
          <target state="translated">C와 Perl을 연결하는 방법은 어디에서 배울 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="ed8bfc60bd9d8b7923b8341ed07d83afc289bc35" translate="yes" xml:space="preserve">
          <source>Where can I learn about object-oriented Perl programming?</source>
          <target state="translated">객체 지향 Perl 프로그래밍에 대해 어디서 배울 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="210221a52d88064b34135e9105ebfd5d49152b00" translate="yes" xml:space="preserve">
          <source>Where can I post questions?</source>
          <target state="translated">질문을 어디에 게시 할 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="34466094d5547ae836abe0422810851106c8e987" translate="yes" xml:space="preserve">
          <source>Where do I get the include files to do ioctl() or syscall()?</source>
          <target state="translated">ioctl () 또는 syscall ()을 수행하기 위해 포함 파일을 어디서 구할 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="ae774b74efc34a0e83321577caf18754079572a2" translate="yes" xml:space="preserve">
          <source>Where do I send bug reports?</source>
          <target state="translated">버그 보고서를 어디로 보내야합니까?</target>
        </trans-unit>
        <trans-unit id="566e06889afcd4a7979069c8b0fd2da4dd9ed19e" translate="yes" xml:space="preserve">
          <source>Where file systems interfaces pass file names in and out of the program we also need care. The trend is for operating systems to use a fixed file encoding that don't actually depend on the locale; and this module determines the most appropriate encoding for file names. The &lt;a href=&quot;encode&quot;&gt;Encode&lt;/a&gt; module will know this encoding under the name &quot;locale_fs&quot;. For traditional Unix systems this will be an alias to the same encoding as &quot;locale&quot;.</source>
          <target state="translated">파일 시스템 인터페이스가 프로그램 안팎으로 파일 이름을 전달하는 경우에도주의가 필요합니다. 추세는 운영 체제가 실제로 로케일에 의존하지 않는 고정 파일 인코딩을 사용하는 것입니다. 이 모듈은 파일 이름에 가장 적합한 인코딩을 결정합니다. &lt;a href=&quot;encode&quot;&gt;인코딩&lt;/a&gt; 모듈은 이름이 &quot;locale_fs&quot;에서이 인코딩을 알 수 있습니다. 전통적인 Unix 시스템의 경우 &quot;locale&quot;과 동일한 인코딩에 대한 별칭입니다.</target>
        </trans-unit>
        <trans-unit id="93218aab454721cc4e38fe91ac1668248deeae63" translate="yes" xml:space="preserve">
          <source>Where is the implementation?</source>
          <target state="translated">구현은 어디에 있습니까?</target>
        </trans-unit>
        <trans-unit id="8a78c0649556030e4985847b409471ca9ebd9274" translate="yes" xml:space="preserve">
          <source>Where people get into trouble is here:</source>
          <target state="translated">사람들이 어려움에 처한 곳은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f616a42d8ce8b58cf95a9bfc5e5383c6c84dc620" translate="yes" xml:space="preserve">
          <source>Where prereqs are concerned, if META_MERGE is used, prerequisites are merged with their counterpart &lt;code&gt;WriteMakefile()&lt;/code&gt; argument (PREREQ_PM is merged into {prereqs}{runtime}{requires}, BUILD_REQUIRES into &lt;code&gt;{prereqs}{build}{requires}&lt;/code&gt; , CONFIGURE_REQUIRES into &lt;code&gt;{prereqs}{configure}{requires}&lt;/code&gt; , and TEST_REQUIRES into &lt;code&gt;{prereqs}{test}{requires})&lt;/code&gt; . When prereqs are specified with META_ADD, the only prerequisites added to the file come from the metadata, not &lt;code&gt;WriteMakefile()&lt;/code&gt; arguments.</source>
          <target state="translated">전제 조건과 관련하여 META_MERGE가 사용되는 경우 전제 조건은 해당 &lt;code&gt;WriteMakefile()&lt;/code&gt; 인수와 병합됩니다 (PREREQ_PM은 {prereqs} {runtime} {requires}에 병합되고, BUILD_REQUIRES는 &lt;code&gt;{prereqs}{build}{requires}&lt;/code&gt; prereqs } {build} {requires}에 , CONFIGURE_REQUIRES는 &lt;code&gt;{prereqs}{configure}{requires}&lt;/code&gt; prereqs } prereqs} {configure} {requires} 및 TEST_REQUIRES를 &lt;code&gt;{prereqs}{test}{requires})&lt;/code&gt; prereqs } {test} {requires}) 로 보냅니다 . META_ADD로 전제 조건을 지정하면 파일에 추가 된 유일한 전제 조건은 &lt;code&gt;WriteMakefile()&lt;/code&gt; 인수가 아닌 메타 데이터에서 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="9262bb4032137f4bd07b4f1a031c40996bf22f95" translate="yes" xml:space="preserve">
          <source>Where prereqs are concerned, if META_MERGE is used, prerequisites are merged with their counterpart &lt;code&gt;WriteMakefile()&lt;/code&gt; argument (PREREQ_PM is merged into {prereqs}{runtime}{requires}, BUILD_REQUIRES into &lt;code&gt;{prereqs}{build}{requires}&lt;/code&gt;, CONFIGURE_REQUIRES into &lt;code&gt;{prereqs}{configure}{requires}&lt;/code&gt;, and TEST_REQUIRES into &lt;code&gt;{prereqs}{test}{requires})&lt;/code&gt;. When prereqs are specified with META_ADD, the only prerequisites added to the file come from the metadata, not &lt;code&gt;WriteMakefile()&lt;/code&gt; arguments.</source>
          <target state="translated">전제 조건과 관련하여 META_MERGE가 사용되는 경우 전제 조건은 대응하는 &lt;code&gt;WriteMakefile()&lt;/code&gt; 인수와 병합됩니다 (PREREQ_PM은 {prereqs} {runtime} {requires}에 병합되고, BUILD_REQUIRES는 &lt;code&gt;{prereqs}{build}{requires}&lt;/code&gt; prereqs } {build} {requires}에 병합되고 , CONFIGURE_REQUIRES는 &lt;code&gt;{prereqs}{configure}{requires}&lt;/code&gt; , TEST_REQUIRES를 &lt;code&gt;{prereqs}{test}{requires})&lt;/code&gt; prereqs } {test} {requires}로) . 전제 조건이 META_ADD로 지정되면 파일에 추가되는 유일한 전제 조건은 &lt;code&gt;WriteMakefile()&lt;/code&gt; 인수가 아닌 메타 데이터에서 제공됩니다 .</target>
        </trans-unit>
        <trans-unit id="2578ad2cf7eb4212c4c2f76a99c66a64a699a6f4" translate="yes" xml:space="preserve">
          <source>Where the $way is a value from zero ($theta0, $phi0) to one ($theta1, $phi1). Note that antipodal points (where their distance is</source>
          <target state="translated">여기서 $ way는 0 ($ theta0, $ phi0)에서 1 ($ theta1, $ phi1) 사이의 값입니다. 대퇴 점 (거리가있는 곳)</target>
        </trans-unit>
        <trans-unit id="fd6d6e78410be236f0ee8b2e37126d4a25f62f65" translate="yes" xml:space="preserve">
          <source>Where the 'DSLIP' characters have the following meanings:</source>
          <target state="translated">'DSLIP'문자의 의미는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="843828ced3164063fc4c650d4b6af29aa8f9cb2c" translate="yes" xml:space="preserve">
          <source>Where the two must be separate, initially set the type to &lt;code&gt;CXt_NULL&lt;/code&gt; or &lt;code&gt;CXt_BLOCK&lt;/code&gt;, and later change it to &lt;code&gt;CXt_foo&lt;/code&gt; when doing the &lt;code&gt;cx_pushfoo&lt;/code&gt;. This is exactly what &lt;code&gt;pp_enteriter&lt;/code&gt; does, once it's determined which type of loop it's pushing.</source>
          <target state="translated">두 개의 별도해야하는 경우, 처음에 유형 설정 &lt;code&gt;CXt_NULL&lt;/code&gt; 또는 &lt;code&gt;CXt_BLOCK&lt;/code&gt; 을 하고, 나중에로 변경 &lt;code&gt;CXt_foo&lt;/code&gt; 할 때 &lt;code&gt;cx_pushfoo&lt;/code&gt; 을 . 이것은 &lt;code&gt;pp_enteriter&lt;/code&gt; 가 어떤 유형의 루프를 푸시하고 있는지 결정되면 정확히 수행하는 작업 입니다.</target>
        </trans-unit>
        <trans-unit id="3a57b05d69f49e2636c91eefc4c6774814129e12" translate="yes" xml:space="preserve">
          <source>Where there is only one operand (or only one operand with overloading) the checks in respect of the other operand above are skipped.</source>
          <target state="translated">피연산자가 하나만 있거나 오버로드가있는 피연산자 만 하나 인 경우 위의 다른 피연산자에 대한 검사는 건너 뜁니다.</target>
        </trans-unit>
        <trans-unit id="293c942f397777e729937e1824d906951d88e087" translate="yes" xml:space="preserve">
          <source>Where these steps occur in the actual execution of a perl program is determined by whether the pattern involves interpolating any string variables. If interpolation occurs, then compilation happens at run time. If it does not, then compilation is performed at compile time. (The &lt;code&gt;/o&lt;/code&gt; modifier changes this, as does &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt; to a certain extent.) The engine doesn't really care that much.</source>
          <target state="translated">이러한 단계가 실제 perl 프로그램 실행에서 발생하는 경우 패턴에 문자열 변수 보간이 포함되는지 여부에 따라 결정됩니다. 보간이 발생하면 런타임에 컴파일이 수행됩니다. 그렇지 않은 경우 컴파일시 컴파일이 수행됩니다. ( &lt;code&gt;/o&lt;/code&gt; 수정자는 &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt; 와 마찬가지로이를 변경합니다 .) 엔진은 실제로 그다지 신경 쓰지 않습니다.</target>
        </trans-unit>
        <trans-unit id="eb41b8cee1215605643716ae7b75d6423a86bb03" translate="yes" xml:space="preserve">
          <source>Where these steps occur in the actual execution of a perl program is determined by whether the pattern involves interpolating any string variables. If interpolation occurs, then compilation happens at run time. If it does not, then compilation is performed at compile time. (The &lt;code&gt;/o&lt;/code&gt; modifier changes this, as does &lt;code&gt;qr//&lt;/code&gt; to a certain extent.) The engine doesn't really care that much.</source>
          <target state="translated">Perl 프로그램의 실제 실행에서 이러한 단계가 발생하는 위치는 패턴에 문자열 변수 보간이 포함되는지 여부에 따라 결정됩니다. 보간이 발생하면 런타임에 컴파일이 발생합니다. 그렇지 않은 경우 컴파일 시간에 컴파일이 수행됩니다. ( &lt;code&gt;/o&lt;/code&gt; 수정자는 &lt;code&gt;qr//&lt;/code&gt; 와 마찬가지로 어느 정도 변경됩니다.) 엔진은 그다지 신경 쓰지 않습니다.</target>
        </trans-unit>
        <trans-unit id="cca423190a1a1c785b9d576f8083e40dd5389585" translate="yes" xml:space="preserve">
          <source>Where to Find the Community</source>
          <target state="translated">커뮤니티를 찾을 수있는 곳</target>
        </trans-unit>
        <trans-unit id="536ef5aba264e8d2aec71ea10430b9efa22dfe0c" translate="yes" xml:space="preserve">
          <source>Where to find the perlfaq</source>
          <target state="translated">perlfaq을 찾을 수있는 곳</target>
        </trans-unit>
        <trans-unit id="93683b8b8083dba6e071465301ae1d1c45028dec" translate="yes" xml:space="preserve">
          <source>Where to get this document</source>
          <target state="translated">이 문서를 얻을 수있는 곳</target>
        </trans-unit>
        <trans-unit id="4af9617f74f3fb16e775a0d165421fe00441bc1b" translate="yes" xml:space="preserve">
          <source>Where to start?</source>
          <target state="translated">어디서 시작하나요?</target>
        </trans-unit>
        <trans-unit id="74e10717c102dd0c9df4c18b5606b9aaf6912d10" translate="yes" xml:space="preserve">
          <source>Where you look to find a pointer to information somewhere else. (See &lt;b&gt;indirection&lt;/b&gt;.) References come in two flavors: &lt;b&gt;symbolic references&lt;/b&gt; and &lt;b&gt;hard references&lt;/b&gt;.</source>
          <target state="translated">다른 곳의 정보에 대한 포인터를 찾는 곳. (참조 &lt;b&gt;간접를&lt;/b&gt; .) 참고 문헌은 두 가지 종류로 제공 : &lt;b&gt;상징적 참조&lt;/b&gt; 및 &lt;b&gt;하드 참조&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="500583f76e5e2a57eb1022812ab875f23db70975" translate="yes" xml:space="preserve">
          <source>Where's the catch? Padding is neither required before the first field &lt;code&gt;count&lt;/code&gt; , nor between this and the next field &lt;code&gt;glyph&lt;/code&gt; , so why can't we simply pack like this:</source>
          <target state="translated">캐치는 어? 어? 첫 번째 필드 &lt;code&gt;count&lt;/code&gt; 이전 이나 다음 필드 &lt;code&gt;glyph&lt;/code&gt; 사이에 패딩이 필요하지 않으므로 다음 과 같이 간단하게 포장 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="2bdd0a720834494322577f4ab7718daee200802f" translate="yes" xml:space="preserve">
          <source>Where's the catch? Padding is neither required before the first field &lt;code&gt;count&lt;/code&gt;, nor between this and the next field &lt;code&gt;glyph&lt;/code&gt;, so why can't we simply pack like this:</source>
          <target state="translated">캐치는 어딨어? 패딩은 첫 번째 필드 &lt;code&gt;count&lt;/code&gt; 이전 이 &lt;code&gt;glyph&lt;/code&gt; 필드와 다음 필드 glyph 사이에 필요하지 않으므로 다음 과 같이 간단히 패킹 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="85ff01499d11ce21062a9b96027ab58ee226aad3" translate="yes" xml:space="preserve">
          <source>Where,</source>
          <target state="translated">Where,</target>
        </trans-unit>
        <trans-unit id="7e741bc3dcef0123eeda11543758853be2aac149" translate="yes" xml:space="preserve">
          <source>Where:</source>
          <target state="translated">Where:</target>
        </trans-unit>
        <trans-unit id="4d453f1163fdbba0e62b8cfe55db1c43bd938110" translate="yes" xml:space="preserve">
          <source>Whereas a QP decoder that works on both ASCII and EBCDIC platforms would look somewhat like the following:</source>
          <target state="translated">ASCII 및 EBCDIC 플랫폼 모두에서 작동하는 QP 디코더는 다음과 비슷합니다.</target>
        </trans-unit>
        <trans-unit id="4c1007108b497a2f8b15b3dc9255f03fbd82a20c" translate="yes" xml:space="preserve">
          <source>Whereas here's how a Perl programmer more comfortable with the idiom might do it:</source>
          <target state="translated">Perl 프로그래머가 관용구에 더 익숙한 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5db7dff8fd1589f3c435af6d45d16e0816b2e9c4" translate="yes" xml:space="preserve">
          <source>Whereas if you comment out the two lines I said you might wish to, then it shows it to you this way instead:</source>
          <target state="translated">내가 원한다고 말한 두 줄을 주석 처리하면 대신 다음과 같이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="ab440f8d11b8fd4e9e75cd6104ac553e6f04002a" translate="yes" xml:space="preserve">
          <source>Whereas other perl internal stacks store individual items all of the same type (usually SV pointers or integers), the items pushed to the save stack are formed of many different types, having multiple fields to them. For example, the &lt;code&gt;SAVEt_INT&lt;/code&gt; type needs to store both the address of the &lt;code&gt;int&lt;/code&gt; variable to restore, and the value to restore it to. This information could have been stored using fields of a &lt;code&gt;struct&lt;/code&gt;, but would have to be large enough to store three pointers in the largest case, which would waste a lot of space in most of the smaller cases.</source>
          <target state="translated">다른 perl 내부 스택은 동일한 유형 (일반적으로 SV 포인터 또는 정수)의 개별 항목을 모두 저장하는 반면, 저장 스택에 푸시되는 항목은 여러 필드가있는 다양한 유형으로 구성됩니다. 예를 들어 &lt;code&gt;SAVEt_INT&lt;/code&gt; 유형은 복원 할 &lt;code&gt;int&lt;/code&gt; 변수 의 주소 와이를 복원 할 값을 모두 저장 해야합니다. 이 정보는 &lt;code&gt;struct&lt;/code&gt; 의 필드를 사용하여 저장 될 수 있지만 가장 큰 경우에 세 개의 포인터를 저장할 수있을만큼 커야하므로 대부분의 작은 경우에 많은 공간을 낭비하게됩니다.</target>
        </trans-unit>
        <trans-unit id="aa7a6da1ef7f2699440e362142ae5565af060786" translate="yes" xml:space="preserve">
          <source>Wherever a list of operators can be given you can use one or more opsets. See also Manipulating Opsets below.</source>
          <target state="translated">운영자 목록을 제공 할 수있는 곳마다 하나 이상의 옵셋을 사용할 수 있습니다. 아래의 조작 조작을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="c457c17dce216494419135c71949242b8d09d0bb" translate="yes" xml:space="preserve">
          <source>Wherever possible, shareable images are preferred to object libraries, and object libraries to plain object files. In accordance with VMS naming conventions, ext() looks for files named</source>
          <target state="translated">가능하면 공유 가능한 이미지는 객체 라이브러리보다 선호되고 객체 라이브러리는 일반 객체 파일보다 선호됩니다. VMS 명명 규칙에 따라 ext ()는 이름이 지정된 파일을 찾습니다.</target>
        </trans-unit>
        <trans-unit id="a5ce0b5c076605e513279f0c54d153294cc237e9" translate="yes" xml:space="preserve">
          <source>Whether PadnamePV is in UTF-8. Currently, this is always true.</source>
          <target state="translated">PadnamePV가 UTF-8인지 여부. 현재 이것은 항상 사실입니다.</target>
        </trans-unit>
        <trans-unit id="60f21be64cee3c558562d0924a678b1007587a17" translate="yes" xml:space="preserve">
          <source>Whether PadnamePV is in UTF8. Currently, this is always true.</source>
          <target state="translated">PadnamePV가 UTF8인지 여부 현재 이것은 항상 사실입니다.</target>
        </trans-unit>
        <trans-unit id="0971615da14029bdca88814940e8de90b6be5147" translate="yes" xml:space="preserve">
          <source>Whether a &quot;signaling&quot; NaN is in any way different from a &quot;quiet&quot; NaN, depends on the platform. Also note that the payload of the default NaN (no argument to nan()) is not necessarily zero, use &lt;code&gt;setpayload&lt;/code&gt; to explicitly set the payload. On some platforms like the 32-bit x86, (unless using the 80-bit long doubles) the signaling bit is not supported at all.</source>
          <target state="translated">&quot;시그널링&quot;NaN이 &quot;조용한&quot;NaN과 어떤 식 으로든 다른지 여부는 플랫폼에 따라 다릅니다. 또한 기본 NaN의 페이로드 (nan ()에 대한 인수 없음)가 반드시 0 일 필요는 없습니다 . &lt;code&gt;setpayload&lt;/code&gt; 를 사용 하여 페이로드를 명시 적으로 설정하십시오. 32 비트 x86과 같은 일부 플랫폼에서는 (80 비트 long double을 사용하지 않는 한) 신호 비트가 전혀 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="63b3304921bf73755f27746fb53954b4a8c4de93" translate="yes" xml:space="preserve">
          <source>Whether command line arguments are allowed to be mixed with options. Default is disabled unless environment variable POSIXLY_CORRECT has been set, in which case &lt;code&gt;require_order&lt;/code&gt; is enabled.</source>
          <target state="translated">명령 행 인수를 옵션과 혼합 할 수 있는지 여부 환경 변수 POSIXLY_CORRECT가 설정되지 않은 경우 기본값은 사용 불가능하며,이 경우 &lt;code&gt;require_order&lt;/code&gt; 가 사용 가능합니다.</target>
        </trans-unit>
        <trans-unit id="faea90df33f36630a481da4cad34e4c79bf52fc5" translate="yes" xml:space="preserve">
          <source>Whether command line arguments are allowed to be mixed with options. Default is enabled unless environment variable POSIXLY_CORRECT has been set, in which case &lt;code&gt;permute&lt;/code&gt; is disabled. Note that &lt;code&gt;permute&lt;/code&gt; is the opposite of &lt;code&gt;require_order&lt;/code&gt; .</source>
          <target state="translated">명령 행 인수를 옵션과 혼합 할 수 있는지 여부 환경 변수 POSIXLY_CORRECT가 설정되어 있지 않으면 기본값이 사용되며,이 경우 &lt;code&gt;permute&lt;/code&gt; 가 사용되지 않습니다. 참고 &lt;code&gt;permute&lt;/code&gt; 반대입니다 &lt;code&gt;require_order&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7872b2f4a897e4a8ef1ea13c927afbc5f8e9bb5d" translate="yes" xml:space="preserve">
          <source>Whether command line arguments are allowed to be mixed with options. Default is enabled unless environment variable POSIXLY_CORRECT has been set, in which case &lt;code&gt;permute&lt;/code&gt; is disabled. Note that &lt;code&gt;permute&lt;/code&gt; is the opposite of &lt;code&gt;require_order&lt;/code&gt;.</source>
          <target state="translated">명령 줄 인수를 옵션과 혼합 할 수 있는지 여부입니다. 환경 변수 POSIXLY_CORRECT가 설정되지 않은 경우 기본값은 활성화되며,이 경우 &lt;code&gt;permute&lt;/code&gt; 가 비활성화됩니다. 참고 &lt;code&gt;permute&lt;/code&gt; 반대입니다 &lt;code&gt;require_order&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="457d6cfb1888790c7832bd27b66465f0cdcbd754" translate="yes" xml:space="preserve">
          <source>Whether dtrace accepts -xnolibs. If available we call dtrace -h and dtrace -G with -xnolibs to allow dtrace to run in a jail on FreeBSD.</source>
          <target state="translated">dtrace가 -xnolibs를 허용하는지 여부. 가능한 경우 dtrace -h 및 dtrace -G를 -xnolibs와 함께 호출하여 dtrace가 FreeBSD의 감옥에서 실행될 수 있도록합니다.</target>
        </trans-unit>
        <trans-unit id="bf16a187d3ac8048da2c0a9f49f8874167f5a83b" translate="yes" xml:space="preserve">
          <source>Whether or not the op has been optimized by the peephole optimizer.</source>
          <target state="translated">들여다 보는 구멍 최적화 프로그램에 의해 op가 최적화되었는지 여부</target>
        </trans-unit>
        <trans-unit id="99e430c2678f913bd7c7b93452d560622af7b626" translate="yes" xml:space="preserve">
          <source>Whether or not the test should output numbers. That is, this if true:</source>
          <target state="translated">테스트에서 숫자를 출력해야하는지 여부입니다. 즉, 이것이 사실이라면 :</target>
        </trans-unit>
        <trans-unit id="5f8067023624d336e348da355a79650c3095a919" translate="yes" xml:space="preserve">
          <source>Whether or not to be verbose about what it is doing -- it will default to $Module::Load::Conditional::VERBOSE</source>
          <target state="translated">수행중인 작업에 대한 자세한 여부-기본값은 $ Module :: Load :: Conditional :: VERBOSE입니다.</target>
        </trans-unit>
        <trans-unit id="835c4d9838e01fba8d1ac35f378ff2857c3bbf2f" translate="yes" xml:space="preserve">
          <source>Whether sorting is stable by default is an accident of implementation that can change (and has changed) between Perl versions. If stability is important, be sure to say so with a</source>
          <target state="translated">기본적으로 정렬이 안정적인지 여부는 Perl 버전간에 변경 될 수있는 (그리고 변경된) 구현의 우연입니다. 안정성이 중요하다면</target>
        </trans-unit>
        <trans-unit id="a8f7f78ec0e44e67b9396390cd1ee3bcf0e5e14e" translate="yes" xml:space="preserve">
          <source>Whether this entry belongs to an outer pad. Entries for which this is true are often referred to as 'fake'.</source>
          <target state="translated">이 항목이 외부 패드에 속하는지 여부 이것이 사실 인 항목을 종종 '가짜'라고합니다.</target>
        </trans-unit>
        <trans-unit id="6283322d116e1d51f7edcd1ec872a9eed355ceb1" translate="yes" xml:space="preserve">
          <source>Whether this is a &quot;state&quot; variable.</source>
          <target state="translated">이것이 &quot;상태&quot;변수인지 여부.</target>
        </trans-unit>
        <trans-unit id="e7034c09da28fdb3d58392534621cc03eebbd14d" translate="yes" xml:space="preserve">
          <source>Whether this is an &quot;our&quot; variable.</source>
          <target state="translated">이것이 &quot;우리&quot;변수인지 여부</target>
        </trans-unit>
        <trans-unit id="c084cfe6eeb06cc1ff5160c3c990367fe4946569" translate="yes" xml:space="preserve">
          <source>Whether this type of partition is support under Win32.</source>
          <target state="translated">이 유형의 파티션이 Win32에서 지원되는지 여부.</target>
        </trans-unit>
        <trans-unit id="8fe93610e6b23e15b98198b34ad48105c383339a" translate="yes" xml:space="preserve">
          <source>Whether to abort printing if debugger signal flag is raised.</source>
          <target state="translated">디버거 신호 플래그가 발생한 경우 인쇄 중단 여부입니다.</target>
        </trans-unit>
        <trans-unit id="2985490d3101108f328098168c5a21b3bc3c5a70" translate="yes" xml:space="preserve">
          <source>Whether to add a table-of-contents at the top of each page (called an index for the sake of tradition).</source>
          <target state="translated">각 페이지 맨 위에 목차를 추가할지 여부 (전통적으로 색인이라고 함).</target>
        </trans-unit>
        <trans-unit id="3a911a7e2bce47416920de6f21016acd3029366b" translate="yes" xml:space="preserve">
          <source>Whether to anchor every definition &lt;code&gt;=item&lt;/code&gt; directive. This needs to be enabled if you want to be able to link to specific &lt;code&gt;=item&lt;/code&gt; directives, which are output as &lt;code&gt;&amp;lt;dt&amp;gt;&lt;/code&gt; elements. Disabled by default.</source>
          <target state="translated">모든 정의 &lt;code&gt;=item&lt;/code&gt; 지시문 을 앵커할지 여부 &lt;code&gt;&amp;lt;dt&amp;gt;&lt;/code&gt; 요소 로 출력되는 특정 &lt;code&gt;=item&lt;/code&gt; 지시문 에 링크하려면이 기능을 활성화해야합니다 . 기본적으로 비활성화되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="626413839d3d50a20deaaad85828e47d347f236c" translate="yes" xml:space="preserve">
          <source>Whether to call these extended grapheme clusters &quot;characters&quot; depends on your point of view. If you are a programmer, you probably would tend towards seeing each element in the sequences as one unit, or &quot;character&quot;. However from the user's point of view, the whole sequence could be seen as one &quot;character&quot; since that's probably what it looks like in the context of the user's language. In this document, we take the programmer's point of view: one &quot;character&quot; is one Unicode code point.</source>
          <target state="translated">이러한 확장 된 grapheme 클러스터를 &quot;문자&quot;로 호출할지 여부는 사용자의 관점에 따라 다릅니다. 프로그래머라면 아마도 시퀀스의 각 요소를 하나의 단위 또는 &quot;문자&quot;로 보는 경향이있을 것입니다. 그러나 사용자 관점에서 전체 시퀀스는 하나의 &quot;문자&quot;로 표시 될 수 있습니다. 이는 아마도 사용자 언어의 맥락에서 보일 수 있기 때문일 것입니다. 이 문서에서 우리는 프로그래머의 관점을 취합니다. 하나의 &quot;문자&quot;는 하나의 유니 코드 코드 포인트입니다.</target>
        </trans-unit>
        <trans-unit id="ee66335b9db0c1d5103deb721dc40777dd212c3c" translate="yes" xml:space="preserve">
          <source>Whether to print chars with high bit set in binary or &quot;as is&quot;.</source>
          <target state="translated">높은 비트가 설정된 문자를 이진으로 인쇄할지 또는 &quot;있는 그대로&quot;인쇄할지 여부</target>
        </trans-unit>
        <trans-unit id="238ca87137bc56748ce05a002a71d9a6db9c7ebe" translate="yes" xml:space="preserve">
          <source>Whether to print contents of globs.</source>
          <target state="translated">글롭의 내용을 인쇄할지 여부.</target>
        </trans-unit>
        <trans-unit id="d3a12643fc63beef0ef6ccef6dae848daa691587" translate="yes" xml:space="preserve">
          <source>Whether to try to find the subroutine name given the reference.</source>
          <target state="translated">참조가 주어진 서브 루틴 이름을 찾으려고하는지 여부</target>
        </trans-unit>
        <trans-unit id="bfd0c6dfe7d4e4cba4e02f1a0ab33700dc1c327f" translate="yes" xml:space="preserve">
          <source>Whether to turn every =head1 directive into a link pointing to the top of the page (specifically, the opening body tag).</source>
          <target state="translated">모든 = head1 지시문을 페이지의 상단 (특히 여는 본문 태그)을 가리키는 링크로 변환할지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="c12251b6a52be9785616abd5b79f50c9699026bb" translate="yes" xml:space="preserve">
          <source>Whether to update this partition information. This field is not used by &lt;code&gt;IOCTL_DISK_GET_PARTITION_INFO&lt;/code&gt;. For &lt;code&gt;IOCTL_DISK_SET_DRIVE_LAYOUT&lt;/code&gt;, you must set this field to a true value for any partitions you wish to have changed, added, or deleted.</source>
          <target state="translated">이 파티션 정보를 업데이트할지 여부입니다. 이 필드는 &lt;code&gt;IOCTL_DISK_GET_PARTITION_INFO&lt;/code&gt; 에서 사용되지 않습니다 . 들어 &lt;code&gt;IOCTL_DISK_SET_DRIVE_LAYOUT&lt;/code&gt; , 당신은 당신이, 변경, 추가 또는 삭제 한하고자하는 파티션의 true 값이 필드를 설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="d26288162f4ab8ff9ae48923849befc89334a4a3" translate="yes" xml:space="preserve">
          <source>Whether to write the non-overloaded form of the stringify-overloaded objects.</source>
          <target state="translated">오버로드되지 않은 형식의 stringify-overloaded 객체를 작성할지 여부</target>
        </trans-unit>
        <trans-unit id="db40c6156e22d6cc6531821dd75bdcb0d45e3842" translate="yes" xml:space="preserve">
          <source>Whether various library calls are thread-safe is outside the control of Perl. Calls often suffering from not being thread-safe include: &lt;code&gt;&lt;a href=&quot;functions/localtime&quot;&gt;localtime()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/gmtime&quot;&gt;gmtime()&lt;/a&gt;&lt;/code&gt;, functions fetching user, group and network information (such as &lt;code&gt;&lt;a href=&quot;functions/getgrent&quot;&gt;getgrent()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/gethostent&quot;&gt;gethostent()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/getnetent&quot;&gt;getnetent()&lt;/a&gt;&lt;/code&gt; and so on), &lt;code&gt;&lt;a href=&quot;functions/readdir&quot;&gt;readdir()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/rand&quot;&gt;rand()&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;functions/srand&quot;&gt;srand()&lt;/a&gt;&lt;/code&gt;. In general, calls that depend on some global external state.</source>
          <target state="translated">다양한 라이브러리 호출이 스레드로부터 안전한지 여부는 Perl이 제어 할 수 없습니다. 스레드로부터 안전하지 않은 호출에는 &lt;code&gt;&lt;a href=&quot;functions/localtime&quot;&gt;localtime()&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/gmtime&quot;&gt;gmtime()&lt;/a&gt;&lt;/code&gt; , 사용자, 그룹 및 네트워크 정보를 가져 오는 함수 (예 : &lt;code&gt;&lt;a href=&quot;functions/getgrent&quot;&gt;getgrent()&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/gethostent&quot;&gt;gethostent()&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/getnetent&quot;&gt;getnetent()&lt;/a&gt;&lt;/code&gt; 등), &lt;code&gt;&lt;a href=&quot;functions/readdir&quot;&gt;readdir()&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/rand&quot;&gt;rand()&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;functions/srand&quot;&gt;srand()&lt;/a&gt;&lt;/code&gt; . 일반적으로 일부 글로벌 외부 상태에 의존하는 통화.</target>
        </trans-unit>
        <trans-unit id="d56e1a6230da252ffdc8d6662ae566d3f6b5ee2f" translate="yes" xml:space="preserve">
          <source>Whether various library calls are thread-safe is outside the control of Perl. Calls often suffering from not being thread-safe include: &lt;code&gt;localtime()&lt;/code&gt;, &lt;code&gt;gmtime()&lt;/code&gt;, functions fetching user, group and network information (such as &lt;code&gt;getgrent()&lt;/code&gt;, &lt;code&gt;gethostent()&lt;/code&gt;, &lt;code&gt;getnetent()&lt;/code&gt; and so on), &lt;code&gt;readdir()&lt;/code&gt;, &lt;code&gt;rand()&lt;/code&gt;, and &lt;code&gt;srand()&lt;/code&gt;. In general, calls that depend on some global external state.</source>
          <target state="translated">다양한 라이브러리 호출이 스레드로부터 안전한지 여부는 Perl에서 제어 할 수 없습니다. 스레드로부터 안전하지 않은 호출에는 &lt;code&gt;localtime()&lt;/code&gt; , &lt;code&gt;gmtime()&lt;/code&gt; , 사용자, 그룹 및 네트워크 정보를 가져 오는 함수 (예 : &lt;code&gt;getgrent()&lt;/code&gt; , &lt;code&gt;gethostent()&lt;/code&gt; , &lt;code&gt;getnetent()&lt;/code&gt; 등), &lt;code&gt;readdir()&lt;/code&gt; , &lt;code&gt;rand()&lt;/code&gt; 및 &lt;code&gt;srand()&lt;/code&gt; . 일반적으로 일부 글로벌 외부 상태에 의존하는 호출입니다.</target>
        </trans-unit>
        <trans-unit id="465a32753eace035273aaef17e2c639421b02dff" translate="yes" xml:space="preserve">
          <source>Whether we need to build an object file with the dtrace tool.</source>
          <target state="translated">dtrace 도구로 개체 파일을 빌드해야하는지 여부.</target>
        </trans-unit>
        <trans-unit id="201246e3611962dc1ed1a9edc779811bfcd3278b" translate="yes" xml:space="preserve">
          <source>Whether you are using NIS does not matter. Amazingly enough, the same bug also affects Solaris.</source>
          <target state="translated">NIS 사용 여부는 중요하지 않습니다. 놀랍게도 같은 버그는 Solaris에도 영향을 미칩니다.</target>
        </trans-unit>
        <trans-unit id="f8e039fc339d1036f86bd64ce844762f9417fe8b" translate="yes" xml:space="preserve">
          <source>Whether you use &lt;code&gt;perlbug&lt;/code&gt; or send the email manually, please make your Subject line informative. &quot;a bug&quot; is not informative. Neither is &quot;perl crashes&quot; nor is &quot;HELP!!!&quot;. These don't help. A compact description of what's wrong is fine.</source>
          <target state="translated">&lt;code&gt;perlbug&lt;/code&gt; 를 사용하든 이메일을 수동으로 보내든 , 제목 줄에 정보를 제공하십시오. &quot;버그&quot;는 유익하지 않습니다. &quot;perl crash&quot;도 &quot;HELP !!!&quot;도 아닙니다. 이것들은 도움이되지 않습니다. 무엇이 잘못되었는지 간략하게 설명하면 좋습니다.</target>
        </trans-unit>
        <trans-unit id="0cde069a15e713b9fe4a9a6b7078fade7daf5170" translate="yes" xml:space="preserve">
          <source>Whew! That is all the rest of the characters and character classes.</source>
          <target state="translated">아휴! 그것은 나머지 모든 문자와 문자 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="27e5de2ca1964d94a9ea629b708a58094f2d855e" translate="yes" xml:space="preserve">
          <source>Which &lt;a href=&quot;Tie::Hash&quot;&gt;Tie::Hash&lt;/a&gt; operation is being performed from the Perl level on &lt;code&gt;%+&lt;/code&gt; or &lt;code&gt;%+&lt;/code&gt;, if any:</source>
          <target state="translated">&lt;code&gt;%+&lt;/code&gt; 또는 &lt;code&gt;%+&lt;/code&gt; 의 Perl 수준에서 수행 되는 &lt;a href=&quot;Tie::Hash&quot;&gt;Tie :: Hash&lt;/a&gt; 작업 (있는 경우) :</target>
        </trans-unit>
        <trans-unit id="56043e0fa27cef8d93950adbdc599597748f590d" translate="yes" xml:space="preserve">
          <source>Which &lt;a href=&quot;tie/hash&quot;&gt;Tie::Hash&lt;/a&gt; operation is being performed from the Perl level on &lt;code&gt;%+&lt;/code&gt; or &lt;code&gt;%+&lt;/code&gt; , if any:</source>
          <target state="translated">어떤 &lt;a href=&quot;tie/hash&quot;&gt;타이 :: 해시&lt;/a&gt; 작업이에 펄 수준에서 수행되고 &lt;code&gt;%+&lt;/code&gt; 또는 &lt;code&gt;%+&lt;/code&gt; (있는 경우) :</target>
        </trans-unit>
        <trans-unit id="babf69836d4addec6f5a5308cb5825c678eb405e" translate="yes" xml:space="preserve">
          <source>Which Perl blogs should I read?</source>
          <target state="translated">어떤 Perl 블로그를 읽어야합니까?</target>
        </trans-unit>
        <trans-unit id="54a12a94c6d59fab4aeefed76c9781df10879a85" translate="yes" xml:space="preserve">
          <source>Which YAML implementation would you prefer?</source>
          <target state="translated">어떤 YAML 구현을 원하십니까?</target>
        </trans-unit>
        <trans-unit id="88e9358d41b432fbb58126174b7979a4235a746a" translate="yes" xml:space="preserve">
          <source>Which architecture dependent directory?</source>
          <target state="translated">어떤 아키텍처 종속 디렉토리?</target>
        </trans-unit>
        <trans-unit id="b7506b68ee68fa595a60659e338ae77c9646b01d" translate="yes" xml:space="preserve">
          <source>Which character set modifier is in effect?</source>
          <target state="translated">어떤 문자 세트 수정자가 적용됩니까?</target>
        </trans-unit>
        <trans-unit id="ee9b43c6b4875ca7c0a8fea57558205fc2e727ab" translate="yes" xml:space="preserve">
          <source>Which commit added the first file to match this regex?</source>
          <target state="translated">이 정규식과 일치하는 첫 번째 파일을 추가 한 커밋은 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="d004402710bbe1f74279bca91591607062854495" translate="yes" xml:space="preserve">
          <source>Which commit caused this example code to break?</source>
          <target state="translated">이 예제 코드가 중단되는 원인은 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="dd77891b19f04e8f4749d5465e616c7d548783ec" translate="yes" xml:space="preserve">
          <source>Which commit caused this example code to start working?</source>
          <target state="translated">이 예제 코드가 작동하기 시작한 커밋은 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="e0816de4aeeb375a395f682785a672eb7143a573" translate="yes" xml:space="preserve">
          <source>Which commit removed the last file to match this regex?</source>
          <target state="translated">이 정규식과 일치하는 마지막 파일을 제거한 커밋은 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="dc6d9abe75ea380074d1386fb6bc4638c51ca405" translate="yes" xml:space="preserve">
          <source>Which is checked first, &lt;code&gt;nomethod&lt;/code&gt; or &lt;code&gt;fallback&lt;/code&gt; ? If the two operands of an operator are of different types and both overload the operator, which implementation is used? The following are the precedence rules:</source>
          <target state="translated">어떤 방법을 먼저 확인 합니까 , &lt;code&gt;nomethod&lt;/code&gt; 또는 &lt;code&gt;fallback&lt;/code&gt; ? 연산자의 두 피연산자가 유형이 다르고 연산자에 과부하가 걸리면 어떤 구현이 사용됩니까? 다음은 우선 순위 규칙입니다.</target>
        </trans-unit>
        <trans-unit id="26892517e1a24be563151c63ed23ba887d7067cd" translate="yes" xml:space="preserve">
          <source>Which is checked first, &lt;code&gt;nomethod&lt;/code&gt; or &lt;code&gt;fallback&lt;/code&gt;? If the two operands of an operator are of different types and both overload the operator, which implementation is used? The following are the precedence rules:</source>
          <target state="translated">어떤 것이 먼저 확인 됩니까 , &lt;code&gt;nomethod&lt;/code&gt; 또는 &lt;code&gt;fallback&lt;/code&gt; ? 연산자의 두 피연산자가 서로 다른 유형이고 둘 다 연산자를 오버로드하는 경우 어떤 구현이 사용됩니까? 다음은 우선 순위 규칙입니다.</target>
        </trans-unit>
        <trans-unit id="2db62588fd2906af96c2fa483b06db407a80424f" translate="yes" xml:space="preserve">
          <source>Which is effectively just:</source>
          <target state="translated">실제로는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b3fbe5ee09cb06684cac7d1a3e427f0dd899daef" translate="yes" xml:space="preserve">
          <source>Which is what we might expect, the match finds the only &lt;code&gt;cat&lt;/code&gt; in the string and locks onto it. Consider, however, this regexp:</source>
          <target state="translated">우리가 기대할 수있는 것은 경기가 문자열에서 유일한 &lt;code&gt;cat&lt;/code&gt; 를 찾아서 고정시킵니다. 그러나 다음 정규 표현식을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="b248b8b60b90917a66aeb94063d05f7d477a94bd" translate="yes" xml:space="preserve">
          <source>Which magazines have Perl content?</source>
          <target state="translated">어떤 잡지에 Perl 컨텐츠가 있습니까?</target>
        </trans-unit>
        <trans-unit id="786c2c13e1b48f509ddfa13fe457e7ade1e2d5c4" translate="yes" xml:space="preserve">
          <source>Which makes $richard and $dick the same variable, but leaves @richard and @dick as separate arrays. Tricky, eh?</source>
          <target state="translated">$ richard와 $ dick를 같은 변수로 만들지 만 @richard와 @dick을 별도의 배열로 남겨 둡니다. 까다로운?</target>
        </trans-unit>
        <trans-unit id="c62379639a4b05982ed9a5d227696146f851a074" translate="yes" xml:space="preserve">
          <source>Which of the various &lt;code&gt;*OP&lt;/code&gt; structures this op uses. This should be one of the &lt;code&gt;OA_*&lt;/code&gt; constants from</source>
          <target state="translated">이 op가 사용 하는 다양한 &lt;code&gt;*OP&lt;/code&gt; 구조 중 이것은 &lt;code&gt;OA_*&lt;/code&gt; 상수 중 하나 여야합니다.</target>
        </trans-unit>
        <trans-unit id="a891db1882ed2a728a47d9d75117f36a4ff2a006" translate="yes" xml:space="preserve">
          <source>Which of these modifiers is in effect at any given point in a regular expression depends on a fairly complex set of interactions. These have been designed so that in general you don't have to worry about it, but this section gives the gory details. As explained below in &lt;a href=&quot;#Extended-Patterns&quot;&gt;&quot;Extended Patterns&quot;&lt;/a&gt; it is possible to explicitly specify modifiers that apply only to portions of a regular expression. The innermost always has priority over any outer ones, and one applying to the whole expression has priority over any of the default settings that are described in the remainder of this section.</source>
          <target state="translated">정규 표현식의 특정 지점에서 어떤 수정자가 적용되는지는 상당히 복잡한 상호 작용 집합에 따라 달라집니다. 이것들은 일반적으로 그것에 대해 걱정할 필요가 없도록 설계되었지만이 섹션에서는 피투성이의 세부 사항을 제공합니다. 아래의 &lt;a href=&quot;#Extended-Patterns&quot;&gt;&quot;확장 패턴&quot;&lt;/a&gt; 에 설명 된대로 정규 표현식의 일부에만 적용되는 수정자를 명시 적으로 지정할 수 있습니다. 가장 안쪽은 항상 바깥쪽에 우선하며 전체 표현식에 적용되는 것은이 섹션의 나머지 부분에서 설명하는 기본 설정보다 우선합니다.</target>
        </trans-unit>
        <trans-unit id="9c28a2fc8be0459fa3248ceb80936f8aba82ccd2" translate="yes" xml:space="preserve">
          <source>Which of these modifiers is in effect at any given point in a regular expression depends on a fairly complex set of interactions. These have been designed so that in general you don't have to worry about it, but this section gives the gory details. As explained below in &lt;a href=&quot;#Extended-Patterns&quot;&gt;Extended Patterns&lt;/a&gt; it is possible to explicitly specify modifiers that apply only to portions of a regular expression. The innermost always has priority over any outer ones, and one applying to the whole expression has priority over any of the default settings that are described in the remainder of this section.</source>
          <target state="translated">정규식의 특정 지점에서 이러한 수정 자 중 어느 것이 적용되는지는 상당히 복잡한 일련의 상호 작용에 달려 있습니다. 이것들은 일반적으로 당신이 그것에 대해 걱정할 필요가 없도록 설계되었지만,이 섹션은 까다로운 세부 사항을 제공합니다. &lt;a href=&quot;#Extended-Patterns&quot;&gt;확장 패턴&lt;/a&gt; 에서 아래에 설명 된 것처럼 정규 표현식의 일부에만 적용되는 수정자를 명시 적으로 지정할 수 있습니다. 가장 안쪽은 항상 바깥쪽에 우선하며, 전체 표현식에 적용되는 하나는이 섹션의 나머지 부분에서 설명하는 기본 설정보다 우선합니다.</target>
        </trans-unit>
        <trans-unit id="3d81e570041b9ef8c3716fd625de2184bc9fcbe4" translate="yes" xml:space="preserve">
          <source>Which one you pick depends on which of these expressions better reflects the above specification of comments.</source>
          <target state="translated">어떤 것을 고르는 지에 따라 위의 주석 사양을 더 잘 반영하는 표현이 달라집니다.</target>
        </trans-unit>
        <trans-unit id="79ee8492b912fab00990fc318850246c7ab7a4ba" translate="yes" xml:space="preserve">
          <source>Which perhaps unexpectedly yields:</source>
          <target state="translated">아마도 예기치 않게 산출되는</target>
        </trans-unit>
        <trans-unit id="05c36e4547159a2f896e1c4c828cfe54c70d84ef" translate="yes" xml:space="preserve">
          <source>Which rules apply are determined as described in &lt;a href=&quot;perlre#Which-character-set-modifier-is-in-effect%3F&quot;&gt;&quot;Which character set modifier is in effect?&quot; in perlre&lt;/a&gt;.</source>
          <target state="translated">적용되는 규칙은 &lt;a href=&quot;perlre#Which-character-set-modifier-is-in-effect%3F&quot;&gt;&quot;어떤 문자 세트 수정자가 적용됩니까?&quot;에&lt;/a&gt; 설명 된대로 결정됩니다. perlre에서 .</target>
        </trans-unit>
        <trans-unit id="4e550746bad7dcee6b1162b28bf7aedac094cd1e" translate="yes" xml:space="preserve">
          <source>Which rules apply are determined as described in &lt;a href=&quot;perlre#Which-character-set-modifier-is-in-effect%3f&quot;&gt;Which character set modifier is in effect? in perlre&lt;/a&gt;.</source>
          <target state="translated">적용 &lt;a href=&quot;perlre#Which-character-set-modifier-is-in-effect%3f&quot;&gt;되는 문자 집합 수정 자에&lt;/a&gt; 설명 된대로 적용되는 규칙은 무엇입니까? perlre에서 .</target>
        </trans-unit>
        <trans-unit id="b4ea6c1227777eb0d0611636fc0f0ce8660134f3" translate="yes" xml:space="preserve">
          <source>Which substring to check first.</source>
          <target state="translated">먼저 확인할 하위 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="627f14bbed51912496b6fb85cde41b9d90202d10" translate="yes" xml:space="preserve">
          <source>Which tar should I use on Windows?</source>
          <target state="translated">Windows에서는 어떤 tar를 사용해야합니까?</target>
        </trans-unit>
        <trans-unit id="2f094ffb275753431ba594c04d0d66a718fa1eda" translate="yes" xml:space="preserve">
          <source>Which text formatter to use. Default is &lt;a href=&quot;Pod::Text&quot;&gt;Pod::Text&lt;/a&gt;, or for very old Perl versions &lt;a href=&quot;Pod::PlainText&quot;&gt;Pod::PlainText&lt;/a&gt;. An alternative would be e.g. &lt;a href=&quot;Pod::Text::Termcap&quot;&gt;Pod::Text::Termcap&lt;/a&gt;.</source>
          <target state="translated">사용할 텍스트 포맷터. 기본값은 &lt;a href=&quot;Pod::Text&quot;&gt;Pod :: Text&lt;/a&gt; 또는 매우 오래된 Perl 버전의 경우 &lt;a href=&quot;Pod::PlainText&quot;&gt;Pod :: PlainText&lt;/a&gt; 입니다. 대안은 예를 들어 &lt;a href=&quot;Pod::Text::Termcap&quot;&gt;Pod :: Text :: Termcap&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="4b26c1ae972001db5809b34aeb5a2c0bda11feda" translate="yes" xml:space="preserve">
          <source>Which text formatter to use. Default is &lt;a href=&quot;pod/text&quot;&gt;Pod::Text&lt;/a&gt;, or for very old Perl versions &lt;a href=&quot;pod/plaintext&quot;&gt;Pod::PlainText&lt;/a&gt;. An alternative would be e.g. &lt;a href=&quot;pod/text/termcap&quot;&gt;Pod::Text::Termcap&lt;/a&gt;.</source>
          <target state="translated">사용할 텍스트 포맷터 기본값은 &lt;a href=&quot;pod/text&quot;&gt;Pod :: Text&lt;/a&gt; 또는 매우 오래된 Perl 버전 &lt;a href=&quot;pod/plaintext&quot;&gt;Pod :: PlainText&lt;/a&gt; 입니다. 대안은 예를 들어 &lt;a href=&quot;pod/text/termcap&quot;&gt;Pod :: Text :: Termcap&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="9b8afbe233aaf49239a07d2a4536a6d9be415fc8" translate="yes" xml:space="preserve">
          <source>Which version of Perl should I use?</source>
          <target state="translated">어떤 버전의 Perl을 사용해야합니까?</target>
        </trans-unit>
        <trans-unit id="ed3642f21edcd8b0db0bc9f8cee4ac46473a253a" translate="yes" xml:space="preserve">
          <source>Which version of perl do I need ?</source>
          <target state="translated">어떤 버전의 펄이 필요합니까?</target>
        </trans-unit>
        <trans-unit id="32a93a6b75c99229f45ca5666bf0720d67cc2e24" translate="yes" xml:space="preserve">
          <source>Which version of perl should I use?</source>
          <target state="translated">어떤 버전의 펄을 사용해야합니까?</target>
        </trans-unit>
        <trans-unit id="7631d79fe8017e212e81e096dcea8cb82517cdbf" translate="yes" xml:space="preserve">
          <source>Which web framework should I use?</source>
          <target state="translated">어떤 웹 프레임 워크를 사용해야합니까?</target>
        </trans-unit>
        <trans-unit id="ca95e2a8ef78e8e65dfe2ee661d1738206c25df7" translate="yes" xml:space="preserve">
          <source>Which will create the directory we need, and you can move on to the next step.</source>
          <target state="translated">필요한 디렉토리가 생성되고 다음 단계로 이동할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1bd7ff93be76f4f655ab909493a6705c72660d9c" translate="yes" xml:space="preserve">
          <source>Which will print</source>
          <target state="translated">어느 것이 인쇄 될 것인가</target>
        </trans-unit>
        <trans-unit id="03d7614f12de55df0b888753d3fa1d0fb28069d7" translate="yes" xml:space="preserve">
          <source>Which would attempt to set breakpoints on lines 4 and 6 immediately after debugger initialization. Note that @DB::typeahead is not a supported interface and is subject to change in future releases.</source>
          <target state="translated">디버거 초기화 직후 줄 4와 6에 중단 점을 설정하려고 시도합니다. @DB :: typeahead는 지원되는 인터페이스가 아니며 향후 릴리스에서 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c966532947a1e874f5fbb5570050ef3e1254690b" translate="yes" xml:space="preserve">
          <source>Which would generate a format looking something like this:</source>
          <target state="translated">다음과 같은 형식을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="d885d5ead32cef5d0d07c15652290de0ab57655a" translate="yes" xml:space="preserve">
          <source>Which zip should I use on Windows for '[ndg]make zipdist'?</source>
          <target state="translated">Windows에서 '[ndg] make zipdist'에 어떤 zip을 사용해야합니까?</target>
        </trans-unit>
        <trans-unit id="91c0db76a3c1130f40e63caacba5a278833ffb99" translate="yes" xml:space="preserve">
          <source>Which, in the degenerate case of using only ordinary arrays, gives you multidimensional arrays just like C's:</source>
          <target state="translated">일반 배열 만 사용하는 퇴화 된 경우 C와 같은 다차원 배열을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="49233da44986d650dd0c62f9412171689ae74192" translate="yes" xml:space="preserve">
          <source>Whichever version is used, the actual methods are called in the same context (list, scalar, or void) as the original call via &lt;code&gt;EVERY&lt;/code&gt; , and return:</source>
          <target state="translated">어떤 버전을 사용하든 실제 메소드는 &lt;code&gt;EVERY&lt;/code&gt; 를 통해 원래 호출과 동일한 컨텍스트 (리스트, 스칼라 또는 void)에서 호출 되고 다음을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="07d57e57f3a8ced4fc446692cf92ed5425c3284f" translate="yes" xml:space="preserve">
          <source>Whichever version is used, the actual methods are called in the same context (list, scalar, or void) as the original call via &lt;code&gt;EVERY&lt;/code&gt;, and return:</source>
          <target state="translated">어떤 버전을 사용하든 실제 메서드는 &lt;code&gt;EVERY&lt;/code&gt; 를 통해 원래 호출과 동일한 컨텍스트 (list, scalar 또는 void)에서 호출 되고 다음을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="fed29deaf6c9f70efd08af26605d88141ad2586b" translate="yes" xml:space="preserve">
          <source>While $FORMAT_TOP_NAME contains the name of the current header format, there is no corresponding mechanism to automatically do the same thing for a footer. Not knowing how big a format is going to be until you evaluate it is one of the major problems. It's on the TODO list.</source>
          <target state="translated">$ FORMAT_TOP_NAME에 현재 머리글 형식의 이름이 포함되어 있지만 바닥 글에 대해 자동으로 동일한 작업을 수행하는 해당 메커니즘은 없습니다. 형식이 얼마나 큰지 알지 못하면 큰 문제 중 하나입니다. TODO 목록에 있습니다.</target>
        </trans-unit>
        <trans-unit id="b0cd08c49ca70b961592a79d7ad5531909d37f26" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; integer&lt;/code&gt; provides integer-only arithmetic, there is no analogous mechanism to provide automatic rounding or truncation to a certain number of decimal places. For rounding to a certain number of digits, &lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf()&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf()&lt;/a&gt;&lt;/code&gt; is usually the easiest route. See &lt;a href=&quot;perlfaq4&quot;&gt;perlfaq4&lt;/a&gt;.</source>
          <target state="translated">동안 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; integer&lt;/code&gt; 의 정수 전용 산술 제공, 소수점의 특정 번호로 자동으로 반올림 또는 절단을 제공 할 유사한 메커니즘이 없습니다. 특정 자릿수로 반올림하는 경우 &lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf()&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf()&lt;/a&gt;&lt;/code&gt; 가 일반적으로 가장 쉬운 경로입니다. &lt;a href=&quot;perlfaq4&quot;&gt;perlfaq4를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="01f836f2c1198b05b58549da2eae8767a49ca6a1" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;STORABLE_freeze&lt;/code&gt; and &lt;code&gt;STORABLE_thaw&lt;/code&gt; are useful for classes where each instance is independent, this mechanism has difficulty (or is incompatible) with objects that exist as common process-level or system-level resources, such as singleton objects, database pools, caches or memoized objects.</source>
          <target state="translated">&lt;code&gt;STORABLE_freeze&lt;/code&gt; 및 &lt;code&gt;STORABLE_thaw&lt;/code&gt; 는 각 인스턴스가 독립적 인 클래스에 유용 하지만 이 메커니즘은 단일 프로세스, 데이터베이스 풀, 캐시 또는 메모 화 된 개체와 같은 공통 프로세스 수준 또는 시스템 수준 리소스로 존재하는 개체와 어려움이 있거나 호환되지 않습니다. .</target>
        </trans-unit>
        <trans-unit id="d9b242bc936842344ffd618aab5876b2850c2c1b" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;connect&lt;/code&gt; returns false, the value of &lt;code&gt;$!&lt;/code&gt; indicates whether it should be tried again (by being set to the value &lt;code&gt;EINPROGRESS&lt;/code&gt;, or &lt;code&gt;EWOULDBLOCK&lt;/code&gt; on MSWin32), or whether a permanent error has occurred (e.g. &lt;code&gt;ECONNREFUSED&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;connect&lt;/code&gt; 가 false를 반환 하는 동안 &lt;code&gt;$!&lt;/code&gt; 다시 시도 해야하는지 (MSWin32에서 &lt;code&gt;EINPROGRESS&lt;/code&gt; 또는 &lt;code&gt;EWOULDBLOCK&lt;/code&gt; 값으로 설정 ) 또는 영구적 인 오류가 발생했는지 (예 : &lt;code&gt;ECONNREFUSED&lt;/code&gt; ) 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="b9a9af13c711e35bbea687932bfa0e243bef5296" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;s///&lt;/code&gt; accepts the &lt;code&gt;/c&lt;/code&gt; flag, it has no effect beyond producing a warning if warnings are enabled.</source>
          <target state="translated">&lt;code&gt;s///&lt;/code&gt; 가 &lt;code&gt;/c&lt;/code&gt; 플래그를 받아들이는 동안 경고가 활성화 된 경우 경고를 생성하는 것 외에는 영향을주지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b8eb5c19a610d348554e2fa519e5457ab307a063" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;use integer&lt;/code&gt; provides integer-only arithmetic, there is no analogous mechanism to provide automatic rounding or truncation to a certain number of decimal places. For rounding to a certain number of digits, &lt;code&gt;sprintf()&lt;/code&gt; or &lt;code&gt;printf()&lt;/code&gt; is usually the easiest route. See &lt;a href=&quot;perlfaq4&quot;&gt;perlfaq4&lt;/a&gt;.</source>
          <target state="translated">동안 &lt;code&gt;use integer&lt;/code&gt; 의 정수 전용 산술 제공, 소수점의 특정 번호로 자동으로 반올림 또는 절단을 제공 할 유사한 메커니즘이 없습니다. 특정 자릿수로 반올림하려면 일반적으로 &lt;code&gt;sprintf()&lt;/code&gt; 또는 &lt;code&gt;printf()&lt;/code&gt; 가 가장 쉬운 경로입니다. &lt;a href=&quot;perlfaq4&quot;&gt;perlfaq4를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="4a400d769e405e7503768315d8de6e5c08fa4438" translate="yes" xml:space="preserve">
          <source>While B::Deparse goes to some lengths to try to figure out what your original program was doing, some parts of the language can still trip it up; it still fails even on some parts of Perl's own test suite. If you encounter a failure other than the most common ones described in the BUGS section below, you can help contribute to B::Deparse's ongoing development by submitting a bug report with a small example.</source>
          <target state="translated">B :: Deparse는 원래의 프로그램이 무엇을하는지 알아 내기 위해 어느 정도 노력을 기울이지 만 언어의 일부는 여전히 트립 될 수 있습니다. Perl 자체 테스트 스위트의 일부에서도 여전히 실패합니다. 아래의 BUGS 섹션에 설명 된 가장 일반적인 오류 이외의 오류가 발생하면 작은 예제를 통해 버그 보고서를 제출하여 B :: Deparse의 지속적인 개발에 기여할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1fb4e05a5830c846a9dc5981bceec998799ac3ed" translate="yes" xml:space="preserve">
          <source>While BigInt has extensive handling of inf and NaN, certain quirks remain.</source>
          <target state="translated">BigInt는 inf 및 NaN을 광범위하게 처리하지만 특정 문제는 남아 있습니다.</target>
        </trans-unit>
        <trans-unit id="fd702ed1f93515e973caeb556144e84284909d1e" translate="yes" xml:space="preserve">
          <source>While C guarantees the ordering specified in the struct definition, between different platforms the definitions might differ</source>
          <target state="translated">C는 구조체 정의에 지정된 순서를 보장하지만 다른 플랫폼 간에는 정의가 다를 수 있습니다</target>
        </trans-unit>
        <trans-unit id="cc4691f27fe5f793a7b1a252b87e1f8adf7ae71b" translate="yes" xml:space="preserve">
          <source>While Dan Kogai retains the copyright as a maintainer, credit should go to all those involved. See AUTHORS for a list of those who submitted code to the project.</source>
          <target state="translated">Dan Kogai는 저작권을 유지 관리자로 유지하지만 신용은 관련된 모든 사람에게 제공해야합니다. 프로젝트에 코드를 제출 한 사람들의 목록은 저자를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="5c4e91143f9c9ac2ab71808110a8709426a9bc1f" translate="yes" xml:space="preserve">
          <source>While Google doesn't provide a native toolchain for Android, you can still get one from the Play Store.</source>
          <target state="translated">Google은 Android 용 기본 도구 모음을 제공하지 않지만 Play 스토어에서 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c1a13f1442da82f36b90f68d9debc0cec8f1fff2" translate="yes" xml:space="preserve">
          <source>While Math::BigInt has extensive handling of inf and NaN, certain quirks remain.</source>
          <target state="translated">Math :: BigInt는 inf 및 NaN을 광범위하게 처리하지만 몇 가지 단점이 남아 있습니다.</target>
        </trans-unit>
        <trans-unit id="e79628255662d7502ebd0e9fa4c3c1aca53d77c4" translate="yes" xml:space="preserve">
          <source>While Perl attempts to keep the vaxc$errno value to be current, if errno is not EVMSERR, it may not be from the current operation.</source>
          <target state="translated">Perl은 vaxc $ errno 값을 현재 상태로 유지하려고 시도하지만 errno가 EVMSERR이 아닌 경우 현재 조작이 아닐 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="82ff355555ab6d2ce0a2840754c6edfffe9b0329" translate="yes" xml:space="preserve">
          <source>While Perl passes arguments to functions by reference, C passes arguments by value; to implement a C function which modifies data of one of the &quot;arguments&quot;, the actual argument of this C function would be a pointer to the data. Thus two C functions with declarations</source>
          <target state="translated">Perl은 참조로 함수에 인수를 전달하지만 C는 값으로 인수를 전달합니다. &quot;인수&quot;중 하나의 데이터를 수정하는 C 함수를 구현하려면이 C 함수의 실제 인수는 데이터에 대한 포인터입니다. 따라서 선언이있는 두 개의 C 함수</target>
        </trans-unit>
        <trans-unit id="c23f9c83568988309005d4ebe9f3a7a4c7b974ed" translate="yes" xml:space="preserve">
          <source>While System V IPC isn't so widely used as sockets, it still has some interesting uses. However, you cannot use SysV IPC or Berkeley mmap() to have a variable shared amongst several processes. That's because Perl would reallocate your string when you weren't wanting it to. You might look into the &lt;code&gt;IPC::Shareable&lt;/code&gt; or &lt;code&gt;threads::shared&lt;/code&gt; modules for that.</source>
          <target state="translated">System V IPC는 소켓으로 널리 사용되지는 않지만 여전히 흥미로운 용도로 사용됩니다. 그러나 SysV IPC 또는 Berkeley mmap ()을 사용하여 여러 프로세스간에 변수를 공유 할 수는 없습니다. 펄은 원하지 않을 때 문자열을 재 할당하기 때문입니다. 이를 위해 &lt;code&gt;IPC::Shareable&lt;/code&gt; 또는 &lt;code&gt;threads::shared&lt;/code&gt; 모듈을 살펴볼 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="95ba383e6ad59d1d5877dab883127e0598dee045" translate="yes" xml:space="preserve">
          <source>While a nice extension, it's not portable. The Perl code does admittedly use them if available to gain some extra speed (essentially as a funky form of inlining), but you shouldn't.</source>
          <target state="translated">멋진 확장 기능이지만 이식성이 없습니다. Perl 코드는 가능한 경우 여분의 속도를 얻는 데 사용되는 경우 (필수적으로 펑키 인라인 형태로) 인정하지만 사용해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="98ac33662fa3d3f638b9cfcc69effe66a6af5d40" translate="yes" xml:space="preserve">
          <source>While a search is in progress, the progress object's &lt;code&gt;reach&lt;/code&gt; and &lt;code&gt;done&lt;/code&gt; methods are called like this:</source>
          <target state="translated">검색이 진행되는 동안 진행률 객체의 &lt;code&gt;reach&lt;/code&gt; 및 &lt;code&gt;done&lt;/code&gt; 메소드는 다음과 같이 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="5af2731519a4e72226e3efaa5ed68cb8f21ac8fa" translate="yes" xml:space="preserve">
          <source>While apparently a whole nuther program,</source>
          <target state="translated">분명히 전체적인 프로그램이지만</target>
        </trans-unit>
        <trans-unit id="2192d44f9e946df5ee1f8628bb7cf84591b693e7" translate="yes" xml:space="preserve">
          <source>While building Perl some changes may be necessary to your Cygwin setup so that Perl builds cleanly. These changes are &lt;b&gt;not&lt;/b&gt; required for normal Perl usage.</source>
          <target state="translated">Perl을 빌드하는 동안 Perl이 깔끔하게 빌드되도록 Cygwin 설정에 일부 변경이 필요할 수 있습니다. 일반적인 Perl 사용 에는 이러한 변경이 필요 &lt;b&gt;하지 않습니다&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="917e67f81e56107e856d601af96f9ace961e9a9a" translate="yes" xml:space="preserve">
          <source>While checking, this module collects document properties, e.g. the nodes for hyperlinks (&lt;code&gt;=headX&lt;/code&gt; , &lt;code&gt;=item&lt;/code&gt; ) and index entries (&lt;code&gt;X&amp;lt;&amp;gt;&lt;/code&gt; ). POD translators can use this feature to syntax-check and get the nodes in a first pass before actually starting to convert. This is expensive in terms of execution time, but allows for very robust conversions.</source>
          <target state="translated">확인하는 동안이 모듈은 문서 속성, 예를 들어 하이퍼 링크 노드 ( &lt;code&gt;=headX&lt;/code&gt; , &lt;code&gt;=item&lt;/code&gt; ) 및 색인 항목 ( &lt;code&gt;X&amp;lt;&amp;gt;&lt;/code&gt; )을 수집합니다 . POD 변환기는이 기능을 사용하여 실제로 변환을 시작하기 전에 구문 검사하고 첫 번째 패스에서 노드를 가져올 수 있습니다. 실행 시간 측면에서 비용이 많이 들지만 매우 강력한 변환이 가능합니다.</target>
        </trans-unit>
        <trans-unit id="0b363ec28aa87cd5d2d84a791b40d48ed17d175f" translate="yes" xml:space="preserve">
          <source>While checking, this module collects document properties, e.g. the nodes for hyperlinks (&lt;code&gt;=headX&lt;/code&gt;, &lt;code&gt;=item&lt;/code&gt;) and index entries (&lt;code&gt;X&amp;lt;&amp;gt;&lt;/code&gt;). POD translators can use this feature to syntax-check and get the nodes in a first pass before actually starting to convert. This is expensive in terms of execution time, but allows for very robust conversions.</source>
          <target state="translated">확인하는 동안이 모듈은 하이퍼 링크 ( &lt;code&gt;=headX&lt;/code&gt; , &lt;code&gt;=item&lt;/code&gt; ) 및 색인 항목 ( &lt;code&gt;X&amp;lt;&amp;gt;&lt;/code&gt; )에 대한 노드와 같은 문서 속성을 수집합니다 . POD 변환기는이 기능을 사용하여 구문을 확인하고 실제로 변환을 시작하기 전에 첫 번째 단계에서 노드를 가져올 수 있습니다. 실행 시간 측면에서 비용이 많이 들지만 매우 강력한 변환이 가능합니다.</target>
        </trans-unit>
        <trans-unit id="ba738010d28065fd95a055094f45e1d958083828" translate="yes" xml:space="preserve">
          <source>While civility is required, kindness is encouraged; if you have any doubt about whether you are being civil, simply ask yourself, &quot;Am I being kind?&quot; and aspire to that.</source>
          <target state="translated">예의가 요구되지만 친절이 권장됩니다. 당신이 예의 바르게 행동하고 있는지 의심 스러우면 &quot;나는 친절합니까?&quot;라고 자문 해보십시오. 그리고 그것을 열망합니다.</target>
        </trans-unit>
        <trans-unit id="c337ad00b019970748effb87047bdf42ffb16bea" translate="yes" xml:space="preserve">
          <source>While experts may argue about these idioms, a novice to Perl guts may prefer a way which is as little Perl-guts-specific as possible, meaning automatic conversion and automatic call generation, as in &lt;a href=&quot;#Getting-the-fat-out-of-XSUBs&quot;&gt;&quot;Getting the fat out of XSUBs&quot;&lt;/a&gt;. This approach has the additional benefit of protecting the XSUB writer from future changes to the Perl API.</source>
          <target state="translated">전문가들은 이러한 관용구에 대해 논할 수 있지만 Perl guts에 대한 초보자는 &lt;a href=&quot;#Getting-the-fat-out-of-XSUBs&quot;&gt;&quot;XSUB에서 지방 제거&quot;&lt;/a&gt; 에서와 같이 자동 변환 및 자동 호출 생성을 의미하는 가능한 한 적은 Perl-guts 특정 방식을 선호 할 수 있습니다 . 이 접근 방식은 Perl API에 대한 향후 변경으로부터 XSUB 작성기를 보호하는 추가 이점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="6234d5fa2f6fac6ddbcf991bea921371b64250cc" translate="yes" xml:space="preserve">
          <source>While experts may argue about these idioms, a novice to Perl guts may prefer a way which is as little Perl-guts-specific as possible, meaning automatic conversion and automatic call generation, as in &lt;a href=&quot;#Getting-the-fat-out-of-XSUBs&quot;&gt;Getting the fat out of XSUBs&lt;/a&gt;. This approach has the additional benefit of protecting the XSUB writer from future changes to the Perl API.</source>
          <target state="translated">전문가들은 이러한 관용구에 대해 논쟁 할 수 있지만, Perl 내장 초보자 &lt;a href=&quot;#Getting-the-fat-out-of-XSUBs&quot;&gt;는 XSUB에서 지방을 빼내는&lt;/a&gt; 것과 같이 자동 변환 및 자동 호출 생성을 의미하는 Perl 내장에 대해 가능한 한 적은 방법을 선호 할 수 있습니다 . 이 접근 방식은 XSUB 기록기가 Perl API의 향후 변경으로부터 보호 할 수있는 추가 이점을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="601070e02f682375d5e25990b39de3389f3b8c49" translate="yes" xml:space="preserve">
          <source>While in principle the &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork&lt;/a&gt;&lt;/code&gt; operator could be implemented via (and with the same rather severe limitations as) the CRTL &lt;code&gt;vfork()&lt;/code&gt; routine, and while some internal support to do just that is in place, the implementation has never been completed, making &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork&lt;/a&gt;&lt;/code&gt; currently unavailable. A true kernel &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork()&lt;/a&gt;&lt;/code&gt; is expected in a future version of VMS, and the pseudo-fork based on interpreter threads may be available in a future version of Perl on VMS (see &lt;a href=&quot;perlfork&quot;&gt;perlfork&lt;/a&gt;). In the meantime, use &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt;, backticks, or piped filehandles to create subprocesses.</source>
          <target state="translated">원칙적으로 &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork&lt;/a&gt;&lt;/code&gt; 연산자는 CRTL &lt;code&gt;vfork()&lt;/code&gt; 루틴을 통해 구현할 수 있으며 (그와 동일한 제한이 있지만), 이를 수행하기위한 내부 지원이 있지만 구현은 완료되지 않았으며 현재 &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork&lt;/a&gt;&lt;/code&gt; 만듭니다. 없는. 향후 버전의 VMS에서는 실제 커널 &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork()&lt;/a&gt;&lt;/code&gt; 가 예상되며, 인터프리터 스레드를 기반으로하는 의사 포크는 VMS에서 Perl의 향후 버전에서 사용할 수 있습니다 ( &lt;a href=&quot;perlfork&quot;&gt;perlfork&lt;/a&gt; 참조 ). 그 동안 &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; , backticks 또는 piped 파일 핸들을 사용하여 서브 프로세스를 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="99369babd08034c16995edf0279e157f7f0775da" translate="yes" xml:space="preserve">
          <source>While in principle the &lt;code&gt;fork&lt;/code&gt; operator could be implemented via (and with the same rather severe limitations as) the CRTL &lt;code&gt;vfork()&lt;/code&gt; routine, and while some internal support to do just that is in place, the implementation has never been completed, making &lt;code&gt;fork&lt;/code&gt; currently unavailable. A true kernel &lt;code&gt;fork()&lt;/code&gt; is expected in a future version of VMS, and the pseudo-fork based on interpreter threads may be available in a future version of Perl on VMS (see &lt;a href=&quot;perlfork&quot;&gt;perlfork&lt;/a&gt;). In the meantime, use &lt;code&gt;system&lt;/code&gt;, backticks, or piped filehandles to create subprocesses.</source>
          <target state="translated">원칙적으로 &lt;code&gt;fork&lt;/code&gt; 연산자는 CRTL &lt;code&gt;vfork()&lt;/code&gt; 루틴을 통해 구현 될 수 있으며 (그리고 동일한 심각한 제한 사항으로) 이를 수행하기위한 일부 내부 지원이 제자리에 있지만 구현이 완료되지 않았기 때문에 현재 &lt;code&gt;fork&lt;/code&gt; 를 만들고 있습니다. 없는. 진정한 커널 &lt;code&gt;fork()&lt;/code&gt; 는 향후 버전의 VMS에서 예상되며 인터프리터 스레드를 기반으로하는 의사 포크는 VMS의 향후 버전의 Perl에서 사용할 수 있습니다 ( &lt;a href=&quot;perlfork&quot;&gt;perlfork&lt;/a&gt; 참조 ). 그 동안 &lt;code&gt;system&lt;/code&gt; , backticks 또는 piped 파일 핸들을 사용하여 하위 프로세스를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="a11b15d87bb1f9501075e6254f16292a57b123f0" translate="yes" xml:space="preserve">
          <source>While in this mode, Perl takes special precautions called</source>
          <target state="translated">이 모드에서 Perl은 특별한 예방 조치를 취합니다.</target>
        </trans-unit>
        <trans-unit id="177c27cbc619ded10f5ed086056984752bc53bbb" translate="yes" xml:space="preserve">
          <source>While it is common to see these two macros in pairs within an &lt;code&gt;ENTER&lt;/code&gt;/ &lt;code&gt;LEAVE&lt;/code&gt; pair, it is not necessary to match them. It is permitted to invoke &lt;code&gt;FREETMPS&lt;/code&gt; multiple times since the most recent &lt;code&gt;SAVETMPS&lt;/code&gt;; for example in a loop iterating over elements of a list. While you can invoke &lt;code&gt;SAVETMPS&lt;/code&gt; multiple times within a scope pair, it is unlikely to be useful. Subsequent invocations will move the temporaries floor further up, thus effectively trapping the existing temporaries to only be released at the end of the scope.</source>
          <target state="translated">이 두 매크로는 &lt;code&gt;ENTER&lt;/code&gt; / &lt;code&gt;LEAVE&lt;/code&gt; 쌍 내에서 쌍으로 표시되는 것이 일반적이지만 일치 할 필요는 없습니다. 가장 최근의 &lt;code&gt;SAVETMPS&lt;/code&gt; 이후 &lt;code&gt;FREETMPS&lt;/code&gt; 를 여러 번 호출 할 수 있습니다 . 예를 들어 목록의 요소를 반복하는 루프에서. 범위 쌍 내에서 &lt;code&gt;SAVETMPS&lt;/code&gt; 를 여러 번 호출 할 수 있지만 유용하지는 않습니다. 후속 호출은 임시 플로어를 더 위로 이동하므로 기존 임시를 효과적으로 트랩하여 범위의 끝에서만 해제됩니다.</target>
        </trans-unit>
        <trans-unit id="7c260f0d64ec7ed3061fae8a4547b586a55f37c5" translate="yes" xml:space="preserve">
          <source>While it is permissible to &lt;code&gt;&lt;a href=&quot;functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; a FileCache managed file, do not do so if you are calling &lt;code&gt;FileCache::cacheout&lt;/code&gt; from a package other than which it was imported, or with another module which overrides &lt;code&gt;&lt;a href=&quot;functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt;. If you must, use &lt;code&gt;FileCache::cacheout_close&lt;/code&gt; .</source>
          <target state="translated">FileCache 관리 파일 을 &lt;code&gt;&lt;a href=&quot;functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; 수는 있지만 &lt;code&gt;FileCache::cacheout&lt;/code&gt; 을 가져온 패키지가 아닌 패키지에서 또는 &lt;code&gt;&lt;a href=&quot;functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; 를 재정의하는 다른 모듈 로 호출하는 경우에는 그렇게하지 마십시오 . 필요한 경우 &lt;code&gt;FileCache::cacheout_close&lt;/code&gt; 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="9b707b74369a586a0cf2d7bbc0374b51314db5a7" translate="yes" xml:space="preserve">
          <source>While it is permissible to &lt;code&gt;close&lt;/code&gt; a FileCache managed file, do not do so if you are calling &lt;code&gt;FileCache::cacheout&lt;/code&gt; from a package other than which it was imported, or with another module which overrides &lt;code&gt;close&lt;/code&gt;. If you must, use &lt;code&gt;FileCache::cacheout_close&lt;/code&gt;.</source>
          <target state="translated">FileCache 관리 파일 을 &lt;code&gt;close&lt;/code&gt; 것이 허용되지만 가져온 패키지가 아닌 다른 패키지 또는 &lt;code&gt;close&lt;/code&gt; 를 재정의하는 다른 모듈에서 &lt;code&gt;FileCache::cacheout&lt;/code&gt; 을 호출하는 경우에는 그렇게하지 마십시오 . 필요한 경우 &lt;code&gt;FileCache::cacheout_close&lt;/code&gt; 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="41a78b4c64649b65dd4cad30d6943b6a01e662f0" translate="yes" xml:space="preserve">
          <source>While it would be nice to make this the default behavior, that would almost certainly break a lot of code, so you must explicitly import these subs and use them instead of the default &lt;code&gt;timelocal()&lt;/code&gt; and &lt;code&gt;timegm()&lt;/code&gt;.</source>
          <target state="translated">이 동작을 기본 동작으로 만드는 것이 좋지만 거의 확실하게 많은 코드를 손상시킬 수 있으므로 이러한 &lt;code&gt;timelocal()&lt;/code&gt; 명시 적으로 가져 와서 기본 timelocal () 및 &lt;code&gt;timegm()&lt;/code&gt; 대신 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="959732eaecdd2fded6d5f4730815e7ecfbb3c6a3" translate="yes" xml:space="preserve">
          <source>While it's not necessary for documentation changes, new tests or trivial patches, it's often worth explaining how your change works. Even if it's clear to you today, it may not be clear to a porter next month or next year.</source>
          <target state="translated">문서 변경, 새로운 테스트 또는 사소한 패치에는 필요하지 않지만 변경의 작동 방식을 설명하는 것이 좋습니다. 오늘 당신에게 분명하더라도, 다음 달 또는 내년에 포터에게는 명확하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="44568ef65eee77bd20a0348b5e9b725eb8d8f779" translate="yes" xml:space="preserve">
          <source>While it's possible to refer directly to these hash keys outside of the class, it's considered a best practice to wrap all access to the attribute with accessor methods.</source>
          <target state="translated">클래스 외부에서 이러한 해시 키를 직접 참조 할 수는 있지만 접근 자 메서드로 속성에 대한 모든 액세스를 래핑하는 것이 가장 좋습니다.</target>
        </trans-unit>
        <trans-unit id="d0849418f5c8269f5aff84704c4d9acb674dcdcc" translate="yes" xml:space="preserve">
          <source>While it's true that Perl's regular expressions resemble the DFAs (deterministic finite automata) of the egrep(1) program, they are in fact implemented as NFAs (non-deterministic finite automata) to allow backtracking and backreferencing. And they aren't POSIX-style either, because those guarantee worst-case behavior for all cases. (It seems that some people prefer guarantees of consistency, even when what's guaranteed is slowness.) See the book &quot;Mastering Regular Expressions&quot; (from O'Reilly) by Jeffrey Friedl for all the details you could ever hope to know on these matters (a full citation appears in &lt;a href=&quot;perlfaq2&quot;&gt;perlfaq2&lt;/a&gt;).</source>
          <target state="translated">Perl의 정규 표현식이 egrep (1) 프로그램의 DFA (결정적 유한 오토마타)와 유사하지만 사실 역 추적 및 역 참조를 허용하기 위해 NFA (비 결정적 유한 오토마타)로 구현됩니다. 그리고 POSIX 스타일도 아닙니다. 왜냐하면 모든 경우에 최악의 행동을 보장하기 때문입니다. (일부 사람들은 일관성 보장이 느린 경우에도 일관성 보장을 선호하는 것 같습니다.) Jeffrey Friedl의 &quot;정규 표현식 마스터 링 (O'Reilly)&quot;책에서 이러한 문제에 대해 알고 자하는 모든 세부 정보를 참조하십시오 ( 전체 인용이 &lt;a href=&quot;perlfaq2&quot;&gt;perlfaq2에&lt;/a&gt; 나타납니다 ).</target>
        </trans-unit>
        <trans-unit id="3329779b59b299850e8b68832610b0b339dc0b1f" translate="yes" xml:space="preserve">
          <source>While it's true that this documentation is somewhat subserious, if you use a program named</source>
          <target state="translated">이 문서가 다소 지루한 것이 사실이지만, 이름이 지정된 프로그램을 사용하는 경우</target>
        </trans-unit>
        <trans-unit id="10a36fcf99a8e338089d469f203ab0168ce94e49" translate="yes" xml:space="preserve">
          <source>While literal lists and named arrays are often interchangeable, that's not the case for hashes. Just because you can subscript a list value like a normal array does not mean that you can subscript a list value as a hash. Likewise, hashes included as parts of other lists (including parameters lists and return lists from functions) always flatten out into key/value pairs. That's why it's good to use references sometimes.</source>
          <target state="translated">리터럴 목록과 명명 된 배열은 종종 상호 교환이 가능하지만 해시에는 해당되지 않습니다. 일반 배열처럼 목록 값을 첨자화할 수 있다고해서 목록 값을 해시로 첨자화할 수있는 것은 아닙니다. 마찬가지로, 다른 목록의 일부로 포함 된 해시 (매개 변수 목록 및 함수의 반환 목록 포함)는 항상 키 / 값 쌍으로 전개됩니다. 따라서 때때로 참조를 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="eca6e56d146060aa14a3a670fa7ed2185164c9b5" translate="yes" xml:space="preserve">
          <source>While most important values in this file</source>
          <target state="translated">이 파일에서 가장 중요한 값은</target>
        </trans-unit>
        <trans-unit id="8f9b053b8a7e4dedb3bcc2addb9bbd5ef56b5365" translate="yes" xml:space="preserve">
          <source>While no_index tells you what must be ignored when indexing, this spec holds no opinion on how you should get your initial candidate list of things to possibly index. For &quot;normal&quot; distributions you might consider simply indexing the contents of lib/, but there are many fascinating oddities on CPAN and many dists from the days when it was normal to put the main .pm file in the root of the distribution archive - so PAUSE currently indexes all .pm and .PL files that are not either (a) specifically excluded by no_index (b) in &lt;code&gt;inc&lt;/code&gt;, &lt;code&gt;xt&lt;/code&gt;, or &lt;code&gt;t&lt;/code&gt; directories, or common 'mistake' directories such as &lt;code&gt;perl5&lt;/code&gt;.</source>
          <target state="translated">no_index는 인덱싱 할 때 무시해야하는 항목을 알려주지 만이 사양은 인덱싱 할 수있는 항목의 초기 후보 목록을 가져와야하는 방법에 대한 의견을 갖고 있지 않습니다. &quot;정상&quot;배포판의 경우 lib /의 내용을 간단히 인덱싱하는 것을 고려할 수 있지만 CPAN에는 많은 흥미로운 이상한 점이 있으며 배포 아카이브의 루트에 기본 .pm 파일을 넣는 것이 정상이었을 때부터 많은 dists가 있습니다. PAUSE는 현재 (a) &lt;code&gt;inc&lt;/code&gt; , &lt;code&gt;xt&lt;/code&gt; 또는 &lt;code&gt;t&lt;/code&gt; 디렉토리의 no_index (b) 또는 &lt;code&gt;perl5&lt;/code&gt; 와 같은 일반적인 '실수'디렉토리 중 하나에 의해 특별히 제외되지 않은 모든 .pm 및 .PL 파일을 인덱싱합니다 .</target>
        </trans-unit>
        <trans-unit id="393059c305b4f9157627b86935072088d84089d3" translate="yes" xml:space="preserve">
          <source>While none of the built-in data types have any arbitrary size limits (apart from memory size), there are still a few arbitrary limits: a given variable name may not be longer than 251 characters. Line numbers displayed by diagnostics are internally stored as short integers, so they are limited to a maximum of 65535 (higher numbers usually being affected by wraparound).</source>
          <target state="translated">내장 데이터 유형 중 임의의 크기 제한 (메모리 크기 제외)이없는 경우에도 여전히 임의의 제한이 있습니다. 주어진 변수 이름은 251자를 초과 할 수 없습니다. 진단에 의해 표시되는 행 번호는 내부적으로 짧은 정수로 저장되므로 최대 65535 (일반적으로 랩 어라운드의 영향을받는 숫자)로 제한됩니다.</target>
        </trans-unit>
        <trans-unit id="b09324869be41d3f63ee219787db6a6f9e7b0b52" translate="yes" xml:space="preserve">
          <source>While not currently implemented, it is possible that in the future this function will convert only parts of the path to FILENAME to a short form.</source>
          <target state="translated">현재 구현되지는 않았지만 앞으로이 함수는 FILENAME 경로의 일부만 짧은 형식으로 변환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1f300b76b4f41dcdc512a5b3661d8c1aa39ba74e" translate="yes" xml:space="preserve">
          <source>While not entirely limited to Unix-derived operating systems (e.g., WinSock on PCs provides socket support, as do some VMS libraries), you might not have sockets on your system, in which case this section probably isn't going to do you much good. With sockets, you can do both virtual circuits like TCP streams and datagrams like UDP packets. You may be able to do even more depending on your system.</source>
          <target state="translated">유닉스 파생 운영 체제 (예 : PC의 WinSock에서 일부 VMS 라이브러리와 같이 소켓 지원을 제공함)에만 전적으로 제한되지는 않지만 시스템에 소켓이 없을 수 있습니다. 좋은. 소켓을 사용하면 TCP 스트림과 같은 가상 회로와 UDP 패킷과 같은 데이터 그램을 모두 수행 할 수 있습니다. 시스템에 따라 더 많은 작업을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6ad3cf3a478c4f24fb9ef9675cf14d8e5c5a06f1" translate="yes" xml:space="preserve">
          <source>While running Configure and when building, you are likely to get quite a few of these warnings:</source>
          <target state="translated">Configure를 실행하거나 빌드 할 때 다음과 같은 경고가 나타납니다.</target>
        </trans-unit>
        <trans-unit id="9b58fa2736239282292bc4dda51122cd95ae2910" translate="yes" xml:space="preserve">
          <source>While short identifiers like &lt;code&gt;$gotit&lt;/code&gt; are probably ok, use underscores to separate words in longer identifiers. It is generally easier to read &lt;code&gt;$var_names_like_this&lt;/code&gt; than &lt;code&gt;$VarNamesLikeThis&lt;/code&gt; , especially for non-native speakers of English. It's also a simple rule that works consistently with &lt;code&gt;VAR_NAMES_LIKE_THIS&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;$gotit&lt;/code&gt; 과 같은 짧은 식별자는 괜찮을지 모르지만 밑줄을 사용하여 더 긴 식별자로 단어를 구분하십시오. 일반적으로 영어가 모국어가 아닌 사용자의 경우 &lt;code&gt;$VarNamesLikeThis&lt;/code&gt; 보다 &lt;code&gt;$var_names_like_this&lt;/code&gt; 를 읽는 것이 일반적으로 더 쉽습니다 . &lt;code&gt;VAR_NAMES_LIKE_THIS&lt;/code&gt; 와 일관되게 작동하는 간단한 규칙이기도합니다 .</target>
        </trans-unit>
        <trans-unit id="3d9fa3ada3b6c731a34ad67160b19f8a88213b51" translate="yes" xml:space="preserve">
          <source>While short identifiers like &lt;code&gt;$gotit&lt;/code&gt; are probably ok, use underscores to separate words in longer identifiers. It is generally easier to read &lt;code&gt;$var_names_like_this&lt;/code&gt; than &lt;code&gt;$VarNamesLikeThis&lt;/code&gt;, especially for non-native speakers of English. It's also a simple rule that works consistently with &lt;code&gt;VAR_NAMES_LIKE_THIS&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;$gotit&lt;/code&gt; 과 같은 짧은 식별자 는 괜찮지 만, 긴 식별자에서 단어를 구분하려면 밑줄을 사용하십시오. 일반적으로 &lt;code&gt;$VarNamesLikeThis&lt;/code&gt; 보다 &lt;code&gt;$var_names_like_this&lt;/code&gt; 를 읽는 것이 더 쉽습니다 . 특히 영어가 모국어가 아닌 경우 더욱 그렇습니다. 또한 &lt;code&gt;VAR_NAMES_LIKE_THIS&lt;/code&gt; 와 일관되게 작동하는 간단한 규칙입니다 .</target>
        </trans-unit>
        <trans-unit id="ae3268e08a1d3bd058ed6f797f7794fd47fc37b4" translate="yes" xml:space="preserve">
          <source>While some developers find fatalizing some warnings to be a useful defensive programming technique, using &lt;code&gt;FATAL =&amp;gt; 'all'&lt;/code&gt; to fatalize all possible warning categories -- including custom ones -- is particularly risky. Therefore, the use of &lt;code&gt;FATAL =&amp;gt; 'all'&lt;/code&gt; is &lt;a href=&quot;perlpolicy#discouraged&quot;&gt;discouraged&lt;/a&gt;.</source>
          <target state="translated">일부 개발자는 일부 경고를 유용한 방어 프로그래밍 기술로 &lt;code&gt;FATAL =&amp;gt; 'all'&lt;/code&gt; 을 사용하여 사용자 지정 범주를 포함하여 가능한 모든 경고 범주를 치 명화하는 것이 특히 위험합니다. 따라서, 사용 &lt;code&gt;FATAL =&amp;gt; 'all'&lt;/code&gt; 입니다 &lt;a href=&quot;perlpolicy#discouraged&quot;&gt;낙담&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9f10f744968048551bad6ee098cf44a11a372745" translate="yes" xml:space="preserve">
          <source>While still in that directory, type:</source>
          <target state="translated">해당 디렉토리에있는 동안 다음을 입력하십시오.</target>
        </trans-unit>
        <trans-unit id="42ffebb3bbe4e65d94b8f907df7dc389a8053ee0" translate="yes" xml:space="preserve">
          <source>While the GNU project includes Perl in its distributions, there's no such thing as &quot;GNU Perl&quot;. Perl is not produced nor maintained by the Free Software Foundation. Perl's licensing terms are also more open than GNU software's tend to be.</source>
          <target state="translated">GNU 프로젝트에는 배포판에 Perl이 포함되어 있지만 &quot;GNU Perl&quot;과 같은 것은 없습니다. Perl은 Free Software Foundation에서 생산하거나 유지 관리하지 않습니다. Perl의 라이센스 조건은 GNU 소프트웨어보다 더 개방적입니다.</target>
        </trans-unit>
        <trans-unit id="84896ae82951e28a26020293e6f0af332fef1cca" translate="yes" xml:space="preserve">
          <source>While the Unicode Standard defines two additional forms of casefolding, one for Turkic languages and one that never maps one character into multiple characters, these are not provided by the Perl core. However, the CPAN module &lt;a href=&quot;Unicode::Casing&quot;&gt;&lt;code&gt;Unicode::Casing&lt;/code&gt;&lt;/a&gt; may be used to provide an implementation.</source>
          <target state="translated">유니 코드 표준은 두 가지 추가 형식의 casefolding을 정의하지만 하나는 Turkic 언어 용이고 다른 하나는 한 문자를 여러 문자로 매핑하지 않지만 Perl 코어에서 제공하지 않습니다. 그러나 CPAN 모듈 &lt;a href=&quot;Unicode::Casing&quot;&gt; &lt;code&gt;Unicode::Casing&lt;/code&gt; &lt;/a&gt; 을 사용하여 구현을 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bcb3c100d2dfc2d28078ac3b93ee7e431111c075" translate="yes" xml:space="preserve">
          <source>While the Unicode Standard defines two additional forms of casefolding, one for Turkic languages and one that never maps one character into multiple characters, these are not provided by the Perl core; However, the CPAN module &lt;code&gt;Unicode::Casing&lt;/code&gt; may be used to provide an implementation.</source>
          <target state="translated">유니 코드 표준은 투르크어 언어와 하나의 문자를 여러 문자로 매핑하지 않는 두 가지 추가적인 케이스 폴딩 형식을 정의하지만 Perl 코어는이를 제공하지 않습니다. 그러나 CPAN 모듈 &lt;code&gt;Unicode::Casing&lt;/code&gt; 을 사용하여 구현을 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="761ba2f6d0a7dac9fb4c5d145960b451d6d26420" translate="yes" xml:space="preserve">
          <source>While the key must be a string value (since that's a basic restriction that Perl places on hash keys), the value in the lexicon can currently be of several types: a defined scalar, scalarref, or coderef. The use of these is explained above, in the section 'The &quot;maketext&quot; Method', and Bracket Notation for strings is discussed in the next section.</source>
          <target state="translated">키는 문자열 값이어야하지만 (Perl이 해시 키에 적용하는 기본 제한이므로) 사전의 값은 현재 정의 된 스칼라, 스칼라 참조 또는 코드 참조의 여러 유형일 수 있습니다. 이것의 사용법은 위에서 &quot;maketext&quot;메소드와 문자열에 대한 브라켓 표기법 섹션에서 설명됩니다.</target>
        </trans-unit>
        <trans-unit id="d08b05105bcedd2fb07dc0399888e4c9d241f3f1" translate="yes" xml:space="preserve">
          <source>While the list of arguments might work fine for one, two or even three arguments, any more arguments become hard for the module user to remember, and hard for the module author to manage. If you want to add a new parameter you will have to add it to the end of the list for backward compatibility, and this will probably make your list order unintuitive. Also, if many elements may be undefined you may see the following unattractive method calls:</source>
          <target state="translated">인수 목록은 하나, 둘 또는 세 개의 인수에 대해 잘 작동 할 수 있지만 더 이상 인수는 모듈 사용자가 기억하기 어렵고 모듈 작성자가 관리하기 어려워집니다. 새 매개 변수를 추가하려면 이전 버전과의 호환성을 위해 목록 끝에 추가해야합니다. 그러면 목록 순서가 직관적이지 않을 수 있습니다. 또한 많은 요소가 정의되지 않은 경우 다음과 같은 매력적이지 않은 메소드 호출이 표시 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="019950bbf16db8b6543648ebb335d2eaf049366f" translate="yes" xml:space="preserve">
          <source>While the mapping &quot;infin&quot; to the character &quot;\x{221E}&quot; will (hopefully) have been already handled by the Pod parser, the presence of the character in this file means that it's reasonably important enough to include in a formatter's table that maps from notable Unicode characters to the codes necessary for rendering them. So for a Unicode-to-*roff mapping, for example, this would merit the entry:</source>
          <target state="translated">&quot;\ x {221E}&quot;문자에 대한 &quot;infin&quot;매핑은 포드 파서에서 이미 처리 했음에도 불구하고이 파일에 문자가 있으면 포맷터의 테이블에 포함하기에 충분히 합리적이라는 것을 의미합니다. 주목할만한 유니 코드 문자를 렌더링에 필요한 코드로 매핑합니다. 예를 들어, 유니 코드-투-오프 매핑의 경우 다음과 같은 장점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="549c813f59b3276935336cbd28f55b4770622941" translate="yes" xml:space="preserve">
          <source>While the two classes may differ in many ways, when it comes to the &lt;code&gt;print_content()&lt;/code&gt; method, they are the same. This means that we can try to call the &lt;code&gt;print_content()&lt;/code&gt; method on an object of either class, and &lt;b&gt;we don't have to know what class the object belongs to!&lt;/b&gt;</source>
          <target state="translated">두 클래스는 여러면에서 다를 수 있지만 &lt;code&gt;print_content()&lt;/code&gt; 메소드와 관련하여 동일합니다. 이것은 우리 가 어느 클래스의 객체 에서 &lt;code&gt;print_content()&lt;/code&gt; 메소드 를 호출하려고 시도 할 수 있고 객체가 &lt;b&gt;어떤 클래스에 속하는지 알 필요가 없다는 것을 의미합니다!&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="76ea82c5269a1424cf449fcf0bff6de44af4f6d8" translate="yes" xml:space="preserve">
          <source>While the word combination &lt;code&gt;character set&lt;/code&gt; has lost this meaning in MIME context since [RFC 2130], the &lt;code&gt;charset&lt;/code&gt; abbreviation has retained it. This is how [RFC 2277] and [RFC 2278] bless &lt;code&gt;charset&lt;/code&gt;:</source>
          <target state="translated">단어를 조합하는 동안 &lt;code&gt;character set&lt;/code&gt; [RFC 2130] 이후 MIME 문맥이 의미를 잃었다는 &lt;code&gt;charset&lt;/code&gt; 약자를 유지하고있다. 다음은 [RFC 2277]과 [RFC 2278]이 &lt;code&gt;charset&lt;/code&gt; 을 축복하는 방법입니다 .</target>
        </trans-unit>
        <trans-unit id="b178eba62086e85a4d0b937f4f56029a87c5eae0" translate="yes" xml:space="preserve">
          <source>While there are Pod codes E&amp;lt;...&amp;gt; and Z&amp;lt;&amp;gt;, these</source>
          <target state="translated">포드 코드 E &amp;lt;...&amp;gt; 및 Z &amp;lt;&amp;gt;가 있지만</target>
        </trans-unit>
        <trans-unit id="05f8c54acc4d9406822b250e87f501917fa0a683" translate="yes" xml:space="preserve">
          <source>While there are currently no architecture-specific extensions or modules distributed with perl, the following directories can be used to hold such files (replace the string VERSION by the appropriate version number):</source>
          <target state="translated">현재 perl과 함께 배포 된 아키텍처 별 확장 또는 모듈은 없지만 다음 디렉토리를 사용하여 해당 파일을 보유 할 수 있습니다 (문자열 VERSION을 적절한 버전 번호로 대체).</target>
        </trans-unit>
        <trans-unit id="0c8516dbb58fd38e067d471797d458e282eb5b87" translate="yes" xml:space="preserve">
          <source>While these operations are not questions of life and death, they are needed for a lot of useful scripts. This forces &lt;code&gt;a.out&lt;/code&gt; -style compile of</source>
          <target state="translated">이러한 작업은 삶과 죽음의 문제는 아니지만 많은 유용한 스크립트에 필요합니다. 이것은 &lt;code&gt;a.out&lt;/code&gt; 스타일의 컴파일을 강제합니다.</target>
        </trans-unit>
        <trans-unit id="3d2455a51c401e0d0b17f4da15388c28c0528ee2" translate="yes" xml:space="preserve">
          <source>While these operations are not questions of life and death, they are needed for a lot of useful scripts. This forces &lt;code&gt;a.out&lt;/code&gt;-style compile of</source>
          <target state="translated">이러한 작업은 삶과 죽음의 문제는 아니지만 많은 유용한 스크립트에 필요합니다. 이것은 &lt;code&gt;a.out&lt;/code&gt; 스타일의 컴파일을 강제합니다.</target>
        </trans-unit>
        <trans-unit id="1849a634e96a61e2b3cdef3b11aa962d9aad4c39" translate="yes" xml:space="preserve">
          <source>While this actually can be done, it's much harder than you'd think. For example, this one-liner</source>
          <target state="translated">실제로이 작업을 수행 할 수는 있지만 생각보다 훨씬 어렵습니다. 예를 들어,이 하나의 라이너</target>
        </trans-unit>
        <trans-unit id="c8b72cb61463146c67f31be1d892fe7495f6bd9f" translate="yes" xml:space="preserve">
          <source>While this allows some (significant?) performance advantages, this makes life much harder for developers, since the above scheme makes it impossible for a DLL to be &quot;linked&quot; to a symbol in the</source>
          <target state="translated">이로 인해 일부 (유용한) 성능 이점이 허용되지만, 위의 구성표를 통해 DLL을 심볼에 &quot;링크&quot;할 수 없기 때문에 개발자의 삶이 훨씬 어려워집니다.</target>
        </trans-unit>
        <trans-unit id="5a4ded2cb5289b97c3775e062e86790bf5432277" translate="yes" xml:space="preserve">
          <source>While this class is currently implemented using the Class::Struct module to build a struct-like class, you shouldn't rely upon this.</source>
          <target state="translated">이 클래스는 현재 Class :: Struct 모듈을 사용하여 구현되어 구조체와 유사한 클래스를 작성하지만이 클래스에 의존해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="e68b146940f9324cc2fc3ad49971a5aa379db2a9" translate="yes" xml:space="preserve">
          <source>While this compiles and runs happily, it probably won't do what's expected, namely it doesn't print &quot;Hello World\n&quot; at all; It will on the other hand do exactly what it was told to do, computers being a bit that way inclined. That is, it will print out a newline character, and you'll get what looks like a blank line. It looks like there's 2 variables when (because of the typo) there's really 3:</source>
          <target state="translated">컴파일과 실행이 행복하지만, 예상대로하지 않을 것입니다. 즉 &quot;Hello World \ n&quot;을 전혀 인쇄하지 않습니다. 다른 한편으로는, 컴퓨터가 그렇게 기울어 지도록 지시받은대로 정확하게 할 것입니다. 즉, 줄 바꿈 문자를 인쇄하고 빈 줄처럼 보입니다. (오타 때문에) 실제로 3이있을 때 2 개의 변수가있는 것처럼 보입니다.</target>
        </trans-unit>
        <trans-unit id="b959fa7d0d0730d45d9d80c8527dc6a6d9341163" translate="yes" xml:space="preserve">
          <source>While this currently exists in all three implementations perl itself does not use it.</source>
          <target state="translated">이것은 현재 세 가지 구현 모두에 존재하지만 펄 자체는 그것을 사용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="386467fc98e2754e0e58a98e1b2d3e8dc8fa8075" translate="yes" xml:space="preserve">
          <source>While this currently exists in both implementations, perl itself does not use it.</source>
          <target state="translated">이것은 현재 두 구현 모두에 존재하지만 perl 자체는 그것을 사용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f084942a5c159bd226784a38fd066229baa22988" translate="yes" xml:space="preserve">
          <source>While this document is intended to be useful to all module authors, it is particularly aimed at authors who wish to publish their modules on CPAN.</source>
          <target state="translated">이 문서는 모든 모듈 작성자에게 유용하기는하지만 특히 CPAN에 모듈을 게시하려는 저자를 대상으로합니다.</target>
        </trans-unit>
        <trans-unit id="66c1c2ee830cc759765d36b85a240cf7d1bab82e" translate="yes" xml:space="preserve">
          <source>While this feature is most commonly used to explicitly call methods inherited from an ancestor class, there is no technical restriction that enforces this:</source>
          <target state="translated">이 기능은 조상 클래스에서 상속 된 메서드를 명시 적으로 호출하는 데 가장 일반적으로 사용되지만이를 적용하는 기술적 제한은 없습니다.</target>
        </trans-unit>
        <trans-unit id="1785d6466e3128c272757d8a3931f08ab9e01f53" translate="yes" xml:space="preserve">
          <source>While this is legal practice, it is certainly dubious, and downright fatal in at least one platform: for example VMS cc considers this a fatal error. One cause for people often making this mistake is that a &quot;naked char&quot; and therefore dereferencing a &quot;naked char pointer&quot; have an undefined signedness: it depends on the compiler and the flags of the compiler and the underlying platform whether the result is signed or unsigned. For this very same reason using a 'char' as an array index is bad.</source>
          <target state="translated">이것은 법적 관행이지만 적어도 하나의 플랫폼에서 확실히 모호하고 치명적입니다. 예를 들어 VMS cc는이를 치명적인 오류로 간주합니다. 사람들이 종종이 실수를 저지르는 한 가지 원인은 &quot;알몸 문자&quot;와 &quot;알몸 문자 포인터&quot;를 역 참조하는 것은 정의되지 않은 부호를 갖기 때문입니다. 결과는 서명 여부에 따라 컴파일러와 컴파일러의 플래그 및 기본 플랫폼에 따라 다릅니다. 부호없는. 이와 같은 이유로 'char'를 배열 인덱스로 사용하는 것은 좋지 않습니다.</target>
        </trans-unit>
        <trans-unit id="40200d6701039334e5e5bffbb6cca8ab91bc30ff" translate="yes" xml:space="preserve">
          <source>While this is true on the surface, it's much more efficient to process the file one line or record at a time because then you don't have to read the whole thing into memory at once. It also gives you finer control of the whole process, letting you kill off the child process early if you'd like.</source>
          <target state="translated">표면적으로는 사실이지만 한 번에 한 줄씩 파일을 처리하거나 한 번에 기록하는 것이 훨씬 효율적입니다. 따라서 전체 내용을 한 번에 메모리로 읽을 필요가 없기 때문입니다. 또한 전체 프로세스를보다 세밀하게 제어 할 수 있으므로 원하는 경우 하위 프로세스를 조기에 종료 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9790d6e959def47c7e50e558f607fe7ba4374a90" translate="yes" xml:space="preserve">
          <source>While this might be too cumbersome to implement in event-based Pod parsers, it is straightforward for parsers that return parse trees.</source>
          <target state="translated">이벤트 기반 포드 파서에서 구현하기에는 너무 번거로울 수 있지만 파싱 트리를 반환하는 파서는 간단합니다.</target>
        </trans-unit>
        <trans-unit id="81aa0dd02571c7973cd68f4d9f805b1c67ff2c9c" translate="yes" xml:space="preserve">
          <source>While this might by accident work in some platform (where IV happens to be an &lt;code&gt;&lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt;&lt;/code&gt;), in general it cannot. IV might be something larger. Even worse the situation is with more specific types (defined by Perl's configuration step in</source>
          <target state="translated">이것은 우연히 일부 플랫폼 (IV가 &lt;code&gt;&lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt;&lt;/code&gt; 인 경우 )에서 작동하지만 일반적으로는 불가능합니다. IV는 더 클 수도 있습니다. 더 나쁜 상황은보다 구체적인 유형 (Perl의 구성 단계에서 정의 됨)</target>
        </trans-unit>
        <trans-unit id="7f1683bf56a3090bff1bb086f826f7e09370112c" translate="yes" xml:space="preserve">
          <source>While this might by accident work in some platform (where IV happens to be an &lt;code&gt;int&lt;/code&gt;), in general it cannot. IV might be something larger. Even worse the situation is with more specific types (defined by Perl's configuration step in</source>
          <target state="translated">이것은 우연히 일부 플랫폼 (IV가 &lt;code&gt;int&lt;/code&gt; 인 경우 )에서 작동 할 수 있지만 일반적으로 불가능합니다. IV는 더 큰 것일 수 있습니다. 더 나쁜 상황은 더 구체적인 유형 (Perl의 구성 단계에 의해 정의 됨)입니다.</target>
        </trans-unit>
        <trans-unit id="82be9c7a2de102e2677bf88ba7443091644097cd" translate="yes" xml:space="preserve">
          <source>While this works reasonably well for unidirectional communication, what about bidirectional communication? The most obvious approach doesn't work:</source>
          <target state="translated">이것은 단방향 통신에 합리적으로 잘 작동하지만 양방향 통신은 어떻습니까? 가장 확실한 접근 방식이 효과가 없습니다.</target>
        </trans-unit>
        <trans-unit id="26ea84a69e787188d7dfd7dc7bac4a8b95950ee8" translate="yes" xml:space="preserve">
          <source>While threads bring a new set of useful tools, they also bring a number of pitfalls. One pitfall is the race condition:</source>
          <target state="translated">쓰레드는 새로운 유용한 도구 세트를 제공하지만 많은 함정을 가져옵니다. 하나의 함정은 경쟁 조건입니다.</target>
        </trans-unit>
        <trans-unit id="0369ef7f3a86c9ade18a8f113608ef11b27c9fcb" translate="yes" xml:space="preserve">
          <source>While thumbing through the &lt;a href=&quot;Date::ICal&quot;&gt;Date::ICal&lt;/a&gt; man page, I came across this:</source>
          <target state="translated">&lt;a href=&quot;Date::ICal&quot;&gt;Date :: ICal&lt;/a&gt; man 페이지 를 훑어 보면서 다음과 같은 사실을 발견했습니다.</target>
        </trans-unit>
        <trans-unit id="8fb55e176d75bb6afa2c9779e5d12c3767454404" translate="yes" xml:space="preserve">
          <source>While trying to read from his caller-id box, the notorious Jamie Zawinski &lt;code&gt;&amp;lt;jwz@netscape.com&amp;gt;&lt;/code&gt; , after much gnashing of teeth and fighting with &lt;code&gt;&lt;a href=&quot;functions/sysread&quot;&gt;sysread&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/sysopen&quot;&gt;sysopen&lt;/a&gt;&lt;/code&gt;, POSIX's &lt;code&gt;tcgetattr&lt;/code&gt; business, and various other functions that go bump in the night, finally came up with this:</source>
          <target state="translated">자신의 발신자 표시 상자에서 악명 높은 Jamie Zawinski &lt;code&gt;&amp;lt;jwz@netscape.com&amp;gt;&lt;/code&gt; 을 읽으려고 시도하는 동안 치아가 많이 &lt;code&gt;&lt;a href=&quot;functions/sysread&quot;&gt;sysread&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/sysopen&quot;&gt;sysopen&lt;/a&gt;&lt;/code&gt; , POSIX의 &lt;code&gt;tcgetattr&lt;/code&gt; 비즈니스 및 밤에 부딪히는 다양한 다른 기능 과 싸우고 나면 , 마침내 이것을 생각해 냈습니다.</target>
        </trans-unit>
        <trans-unit id="3d9a29cb2e71d84a90b207c5a091106e69ab3f88" translate="yes" xml:space="preserve">
          <source>While trying to read from his caller-id box, the notorious Jamie Zawinski &lt;code&gt;&amp;lt;jwz@netscape.com&amp;gt;&lt;/code&gt;, after much gnashing of teeth and fighting with &lt;code&gt;sysread&lt;/code&gt;, &lt;code&gt;sysopen&lt;/code&gt;, POSIX's &lt;code&gt;tcgetattr&lt;/code&gt; business, and various other functions that go bump in the night, finally came up with this:</source>
          <target state="translated">그의 발신자 ID 상자, 악명 높은 Jamie Zawinski &lt;code&gt;&amp;lt;jwz@netscape.com&amp;gt;&lt;/code&gt; 에서 읽기를 시도하는 동안 많은 양의이를 &lt;code&gt;sysread&lt;/code&gt; , &lt;code&gt;sysopen&lt;/code&gt; , POSIX의 &lt;code&gt;tcgetattr&lt;/code&gt; 비즈니스 및 밤에 충돌하는 다양한 기타 기능 과의 싸움 끝에 , 마침내 이것을 생각해 냈습니다.</target>
        </trans-unit>
        <trans-unit id="6d7592c228741a449aa83d6358c7b5dbac2c422e" translate="yes" xml:space="preserve">
          <source>While trying to resolve method call %s-&amp;gt;%s() can not locate package &quot;%s&quot; yet it is mentioned in @%s::ISA (perhaps you forgot to load &quot;%s&quot;?)</source>
          <target state="translated">메서드 호출 % s-&amp;gt; % s ()를 해결하는 동안 &quot;% s&quot;패키지를 찾을 수 없지만 @ % s :: ISA에 언급되어 있습니다 ( &quot;% s&quot;로드를 잊었습니까?).</target>
        </trans-unit>
        <trans-unit id="5ffa8b7afc028fdbcdab4b6dea3d1eb48e0f55ad" translate="yes" xml:space="preserve">
          <source>While using the standard</source>
          <target state="translated">표준을 사용하는 동안</target>
        </trans-unit>
        <trans-unit id="c059f6308f685a568f9b74b626f917b18a45a114" translate="yes" xml:space="preserve">
          <source>While version objects overload stringification, to portably convert &lt;code&gt;$^V&lt;/code&gt; into its string representation, use &lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf()&lt;/a&gt;&lt;/code&gt;'s &lt;code&gt;&quot;%vd&quot;&lt;/code&gt; conversion, which works for both v-strings or version objects:</source>
          <target state="translated">버전 객체 가 문자열 화를 오버로드하는 동안 &lt;code&gt;$^V&lt;/code&gt; 를 문자열 표현으로 이식 가능하게 변환 하려면 &lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf()&lt;/a&gt;&lt;/code&gt; 의 &lt;code&gt;&quot;%vd&quot;&lt;/code&gt; 변환을 사용하십시오. 이는 v- 문자열 또는 버전 객체 모두에서 작동합니다.</target>
        </trans-unit>
        <trans-unit id="7e7742e29582b552f48253992f05bd5349646ba9" translate="yes" xml:space="preserve">
          <source>While version objects overload stringification, to portably convert &lt;code&gt;$^V&lt;/code&gt; into its string representation, use &lt;code&gt;sprintf()&lt;/code&gt;'s &lt;code&gt;&quot;%vd&quot;&lt;/code&gt; conversion, which works for both v-strings or version objects:</source>
          <target state="translated">버전 객체 가 문자열 화를 오버로드하는 동안 &lt;code&gt;$^V&lt;/code&gt; 를 문자열 표현으로 이식 가능하게 변환 하려면 v- 문자열 또는 버전 객체 모두에 대해 작동 하는 &lt;code&gt;sprintf()&lt;/code&gt; 의 &lt;code&gt;&quot;%vd&quot;&lt;/code&gt; 변환을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="3a5995cddc89ffbbaa6e8a0013934033bfcd3e1f" translate="yes" xml:space="preserve">
          <source>While versions earlier than 5.8.1 had threads they contain too many bugs to support.</source>
          <target state="translated">5.8.1 이전 버전에는 스레드가 있지만 지원하기에는 너무 많은 버그가 있습니다.</target>
        </trans-unit>
        <trans-unit id="daa9a857c615b0eef13a54df6fdfd26532388959" translate="yes" xml:space="preserve">
          <source>While we normally think of patterns as being delimited with &lt;code&gt;/&lt;/code&gt; characters, they can be delimited by almost any character. &lt;a href=&quot;perlre&quot;&gt;perlre&lt;/a&gt; describes this. For example, the &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt; above uses braces as delimiters. Selecting another delimiter can avoid quoting the delimiter within the pattern:</source>
          <target state="translated">일반적으로 패턴은 &lt;code&gt;/&lt;/code&gt; 문자 로 구분되는 것으로 생각하지만 거의 모든 문자로 구분할 수 있습니다. &lt;a href=&quot;perlre&quot;&gt;perlre&lt;/a&gt; 는 이것을 설명합니다. 예를 들어, 위 의 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt; 는 중괄호를 구분 기호로 사용합니다. 다른 구분 기호를 선택하면 패턴 내에서 구분 기호를 인용하지 않아도됩니다.</target>
        </trans-unit>
        <trans-unit id="39f1ea1d3e2074839c9819aaf86819467fb5bb22" translate="yes" xml:space="preserve">
          <source>While we normally think of patterns as being delimited with &lt;code&gt;/&lt;/code&gt; characters, they can be delimited by almost any character. &lt;a href=&quot;perlre&quot;&gt;perlre&lt;/a&gt; describes this. For example, the &lt;code&gt;s///&lt;/code&gt; above uses braces as delimiters. Selecting another delimiter can avoid quoting the delimiter within the pattern:</source>
          <target state="translated">일반적으로 패턴은 &lt;code&gt;/&lt;/code&gt; 문자 로 구분되는 것으로 생각하지만 거의 모든 문자로 구분할 수 있습니다. &lt;a href=&quot;perlre&quot;&gt;perlre가&lt;/a&gt; 이것을 설명합니다. 예를 들어, 위 의 &lt;code&gt;s///&lt;/code&gt; 는 구분 기호로 중괄호를 사용합니다. 다른 구분 기호를 선택하면 패턴 내에서 구분 기호를 인용하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="09af51d2e240602d6d93896cb9f587c7a82f4e64" translate="yes" xml:space="preserve">
          <source>While we strongly suggest you don't build your objects from scratch, you should know the term &lt;b&gt;bless&lt;/b&gt;. A &lt;b&gt;blessed&lt;/b&gt; data structure (aka &quot;a referent&quot;) is an object. We sometimes say that an object has been &quot;blessed into a class&quot;.</source>
          <target state="translated">객체를 처음부터 만들지 말 것을 강력히 권하지만 &lt;b&gt;축복&lt;/b&gt; 이라는 용어를 알아야합니다 . &lt;b&gt;복&lt;/b&gt; 데이터 구조 (일명 &quot;는 지시 대상&quot;)는 목적으로한다. 우리는 때때로 어떤 대상이&amp;ldquo;계급으로 축복 받았다&amp;rdquo;고 말합니다.</target>
        </trans-unit>
        <trans-unit id="562c113d1f1007e0a6502247b3772bac3c2d33a2" translate="yes" xml:space="preserve">
          <source>While we usually think of quotes as literal values, in Perl they function as operators, providing various kinds of interpolating and pattern matching capabilities. Perl provides customary quote characters for these behaviors, but also provides a way for you to choose your quote character for any of them. In the following table, a &lt;code&gt;{}&lt;/code&gt; represents any pair of delimiters you choose.</source>
          <target state="translated">우리는 일반적으로 따옴표를 리터럴 값으로 생각하지만 Perl에서는 연산자로 기능하여 다양한 종류의 보간 및 패턴 일치 기능을 제공합니다. Perl은 이러한 동작에 대한 따옴표 문자를 제공하지만 따옴표 문자를 선택할 수있는 방법도 제공합니다. 다음 표에서 &lt;code&gt;{}&lt;/code&gt; 는 선택한 구분 기호 쌍을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="34200b2d58936bc37828d3e87d2eebbab2c0f898" translate="yes" xml:space="preserve">
          <source>While we're here, take a closer look at the '&lt;b&gt;x&lt;/b&gt;' command, it's really useful and will merrily dump out nested references, complete objects, partial objects - just about whatever you throw at it:</source>
          <target state="translated">우리가 여기있는 동안 ' &lt;b&gt;x&lt;/b&gt; '명령을 자세히 살펴보면 실제로 유용하며 중첩 된 참조, 완전한 객체, 부분 객체를 버릴 것입니다.</target>
        </trans-unit>
        <trans-unit id="00e2fed4a06f99f6100461a2d8cbb333f4d09501" translate="yes" xml:space="preserve">
          <source>While you can mix double colons with singles quotes, the quotes must come after the colons: &lt;code&gt;$::::'foo&lt;/code&gt; and &lt;code&gt;$foo::'bar&lt;/code&gt; are legal, but &lt;code&gt;$::'::foo&lt;/code&gt; and &lt;code&gt;$foo'::bar&lt;/code&gt; are not.</source>
          <target state="translated">이중 콜론을 단일 인용 부호와 혼합 할 수 있지만 인용 부호는 콜론 뒤에 와야합니다 : &lt;code&gt;$::::'foo&lt;/code&gt; 및 &lt;code&gt;$foo::'bar&lt;/code&gt; 는 합법적이지만 &lt;code&gt;$::'::foo&lt;/code&gt; 및 &lt;code&gt;$foo'::bar&lt;/code&gt; 아닙니다.</target>
        </trans-unit>
        <trans-unit id="078d591b0ade8bcb579420345c7df7b2c236f00e" translate="yes" xml:space="preserve">
          <source>While you can use arbitrary unique IDs for lexicon keys (like &quot;_min_larger_max_error&quot;), it is often useful for if an entry's key is itself a valid value, like this example error message:</source>
          <target state="translated">&quot;_min_larger_max_error&quot;와 같이 사전 키에 임의의 고유 ID를 사용할 수 있지만 다음 예제 오류 메시지와 같이 항목 키 자체가 유효한 값인 경우 유용합니다.</target>
        </trans-unit>
        <trans-unit id="59ac30a04c89545845f0a1e87ea492a8c9c597ff" translate="yes" xml:space="preserve">
          <source>While you're doing that, make really sure you haven't missed a module similar to the one you're about to write.</source>
          <target state="translated">그렇게하는 동안 작성하려는 모듈과 비슷한 모듈을 놓치지 않았는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="95a6dc4463afddf0b399fee2185874a12ea0df02" translate="yes" xml:space="preserve">
          <source>While:</source>
          <target state="translated">While:</target>
        </trans-unit>
        <trans-unit id="c6568ae799534002dc040ff86ba3511a9bd4bd58" translate="yes" xml:space="preserve">
          <source>Whilst control is in the library, an error condition occurs. You have previously set up a Perl callback to handle this situation, so it will get executed. Once the callback has finished, control will drop back to Perl again. Here is what the flow of control will be like in that situation</source>
          <target state="translated">제어가 라이브러리에있는 동안 오류 조건이 발생합니다. 이 상황을 처리하기 위해 이전에 Perl 콜백을 설정 했으므로 실행됩니다. 콜백이 완료되면 컨트롤은 다시 Perl로 돌아갑니다. 그 상황에서 제어 흐름은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="80e9be96d98a6599b821f35e0fd1d6289ce559ee" translate="yes" xml:space="preserve">
          <source>White space, hyphens, and underscores ARE significant except for:</source>
          <target state="translated">공백, 하이픈 및 밑줄은 다음을 제외하고 중요합니다.</target>
        </trans-unit>
        <trans-unit id="47b13cdb0607925057b8e9d36b0386d1a11eb54c" translate="yes" xml:space="preserve">
          <source>Whitespace</source>
          <target state="translated">Whitespace</target>
        </trans-unit>
        <trans-unit id="44c1e2cd5ccb90bd73774fc5e53e7773e341381c" translate="yes" xml:space="preserve">
          <source>Whitespace and IPC::Open3 / system()</source>
          <target state="translated">공백 및 IPC :: Open3 / system ()</target>
        </trans-unit>
        <trans-unit id="82098c40334ef85fcca05587546e9cc28f23e2a9" translate="yes" xml:space="preserve">
          <source>Whitespace and IPC::Run</source>
          <target state="translated">공백 및 IPC :: Run</target>
        </trans-unit>
        <trans-unit id="974608074eb6dc3e2345e2aa4e42c412340d3d49" translate="yes" xml:space="preserve">
          <source>Whitespace and special characters in the filename argument</source>
          <target state="translated">파일 이름 인수의 공백 및 특수 문자</target>
        </trans-unit>
        <trans-unit id="e3b1deb6ad1643a6518bffe011e47a1bbf2cd01d" translate="yes" xml:space="preserve">
          <source>Whitespace does not delimit fileglobs.</source>
          <target state="translated">공백은 파일 글로브를 구분하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="df7fa704cbceacef574fb86983159dfe4b06ae43" translate="yes" xml:space="preserve">
          <source>Whitespace in filenames is tolerated on most systems, but not all, and even on systems where it might be tolerated, some utilities might become confused by such whitespace.</source>
          <target state="translated">파일 이름의 공백은 대부분의 시스템에서 허용되지만 전부는 아니며 허용 될 수있는 시스템에서도 일부 유틸리티는 이러한 공백으로 인해 혼동 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="baf39f9fbe05bd8902b826d4b1716bd33c1e5022" translate="yes" xml:space="preserve">
          <source>Whitespace is ignored.</source>
          <target state="translated">공백은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="5899e5ae54fc72cc82eec99924af8577c33c2cbc" translate="yes" xml:space="preserve">
          <source>Whitespace is ignored. The alias value can be a single attribute or a space-separated list of attributes.</source>
          <target state="translated">공백은 무시됩니다. 별칭 값은 단일 속성이거나 공백으로 구분 된 속성 목록 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="09822d18c062da75d056f267dd113eb02444df2b" translate="yes" xml:space="preserve">
          <source>Whitespace is irrelevant:</source>
          <target state="translated">공백은 관련이 없습니다.</target>
        </trans-unit>
        <trans-unit id="e6027b651e819925aa47dc4c27f8a2f557b14aae" translate="yes" xml:space="preserve">
          <source>Who Needs Complicated Data Structures?</source>
          <target state="translated">복잡한 데이터 구조가 필요한 사람</target>
        </trans-unit>
        <trans-unit id="ce404d98012c2a69e116523288638e2bddf0b8c2" translate="yes" xml:space="preserve">
          <source>Who supports Perl? Who develops it? Why is it free?</source>
          <target state="translated">펄을 지원하는 사람 누가 개발합니까? 왜 무료입니까?</target>
        </trans-unit>
        <trans-unit id="6272068bf74683d289db3b55d0ea826c2bd453e3" translate="yes" xml:space="preserve">
          <source>Who wrote it (use AUTHORS for multiple people). It's a good idea to include your current e-mail address (or some e-mail address to which bug reports should be sent) or some other contact information so that users have a way of contacting you. Remember that program documentation tends to roam the wild for far longer than you expect and pick a contact method that's likely to last.</source>
          <target state="translated">누가 작성 했습니까 (여러 사람에게 AUTHORS 사용). 사용자가 연락 할 수 있도록 현재 전자 메일 주소 (또는 버그 보고서를 보내야하는 전자 메일 주소) 나 다른 연락처 정보를 포함시키는 것이 좋습니다. 프로그램 설명서는 예상보다 훨씬 오랫동안 야생을 로밍하고 지속될 수있는 연락 방법을 선택하는 경향이 있습니다.</target>
        </trans-unit>
        <trans-unit id="cf619e0d870f5f00d0e62715b2fa9d9354bf3093" translate="yes" xml:space="preserve">
          <source>Whoops! Looks like it's unimplemented. Assume you don't have the time to fix this. [11] Normally, you'd just comment out the test and put a note in a todo list somewhere. Instead, explicitly state &quot;this test will fail&quot; by wrapping it in a &lt;code&gt;TODO&lt;/code&gt; block:</source>
          <target state="translated">이런! 구현되지 않은 것 같습니다. 이 문제를 해결할 시간이 없다고 가정합니다. [11] 일반적으로 테스트를 주석 처리하고 어딘가에 할 일 목록에 메모를 추가합니다. 대신 &lt;code&gt;TODO&lt;/code&gt; 블록 으로 래핑하여 &quot;이 테스트는 실패합니다&quot;라고 명시 적으로 설명합니다 .</target>
        </trans-unit>
        <trans-unit id="d4357002b49a216cedec63d85f662f9560e6c2af" translate="yes" xml:space="preserve">
          <source>Whoops! You just put a tab and a formfeed into that filename! Remember that within double quoted strings (&quot;like\this&quot;), the backslash is an escape character. The full list of these is in &lt;a href=&quot;perlop#Quote-and-Quote-like-Operators&quot;&gt;&quot;Quote and Quote-like Operators&quot; in perlop&lt;/a&gt;. Unsurprisingly, you don't have a file called &quot;c:(tab)emp(formfeed)oo&quot; or &quot;c:(tab)emp(formfeed)oo.exe&quot; on your legacy DOS filesystem.</source>
          <target state="translated">이런! 해당 파일 이름에 탭과 폼 피드를 입력하기 만하면됩니다! 큰 따옴표로 묶인 문자열 ( &quot;like \ this&quot;) 내에서 백 슬래시는 이스케이프 문자라는 점을 기억하십시오. 이들의 전체 목록은 &lt;a href=&quot;perlop#Quote-and-Quote-like-Operators&quot;&gt;perlop의 &quot;Quote and Quote-like Operators&quot;에&lt;/a&gt; 있습니다. 당연히 기존 DOS 파일 시스템에 &quot;c : (tab) emp (formfeed) oo&quot;또는 &quot;c : (tab) emp (formfeed) oo.exe&quot;라는 파일이 없습니다.</target>
        </trans-unit>
        <trans-unit id="b22ef207f555182408b6d1958c0f8d72d42ebbcf" translate="yes" xml:space="preserve">
          <source>Whoops! You just put a tab and a formfeed into that filename! Remember that within double quoted strings (&quot;like\this&quot;), the backslash is an escape character. The full list of these is in &lt;a href=&quot;perlop#Quote-and-Quote-like-Operators&quot;&gt;Quote and Quote-like Operators in perlop&lt;/a&gt;. Unsurprisingly, you don't have a file called &quot;c:(tab)emp(formfeed)oo&quot; or &quot;c:(tab)emp(formfeed)oo.exe&quot; on your legacy DOS filesystem.</source>
          <target state="translated">으악! 그 파일 이름에 탭과 폼 피드를 넣으면됩니다! 큰 따옴표로 묶인 문자열 ( &quot;like \ this&quot;) 내에서 백 슬래시는 이스케이프 문자입니다. 이들의 전체 목록은 &lt;a href=&quot;perlop#Quote-and-Quote-like-Operators&quot;&gt;perlop의 Quote 및 Quote-like Operators에&lt;/a&gt; 있습니다. 당연히, 레거시 DOS 파일 시스템에 &quot;c : (tab) emp (formfeed) oo&quot;또는 &quot;c : (tab) emp (formfeed) oo.exe&quot;라는 파일이 없습니다.</target>
        </trans-unit>
        <trans-unit id="4b60ac899852ccb4f23a0cc5a329b0dd058c1185" translate="yes" xml:space="preserve">
          <source>Whoops, a failure! [4] &lt;a href=&quot;Test::Simple&quot;&gt;Test::Simple&lt;/a&gt; helpfully lets us know on what line the failure occurred, but not much else. We were supposed to get 17, but we didn't. What did we get?? Dunno. You could re-run the test in the debugger or throw in some print statements to find out.</source>
          <target state="translated">아, 실패! [4] &lt;a href=&quot;Test::Simple&quot;&gt;테스트 ::&lt;/a&gt; 실패가 발생한 라인에 대해 간단 하게 알려줍니다. 우리는 17 점을 받아야했지만 그렇지 않았습니다. 우리는 무엇을 얻었습니까 ?? Dunno. 디버거에서 테스트를 다시 실행하거나 몇 가지 print 문을 던져서 알아낼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8c0f41e4219d3445a18de71b89eb22ea90d39e82" translate="yes" xml:space="preserve">
          <source>Whoops. You should instead use this, which will fail if the file doesn't exist:</source>
          <target state="translated">으악. 대신이 파일을 사용하면 파일이 존재하지 않으면 실패합니다.</target>
        </trans-unit>
        <trans-unit id="21e2caea4476d26af34541ca7c909c7ff2fa4a7f" translate="yes" xml:space="preserve">
          <source>Why</source>
          <target state="translated">Why</target>
        </trans-unit>
        <trans-unit id="9560992747d1a6605928cb6a17f56014fb292bd8" translate="yes" xml:space="preserve">
          <source>Why am I getting long decimals (eg, 19.9499999999999) instead of the numbers I should be getting (eg, 19.95)?</source>
          <target state="translated">내가 가져와야하는 숫자 대신 십진수 (예 : 19.9499999999999)를 얻는 이유는 무엇입니까 (예 : 19.95)?</target>
        </trans-unit>
        <trans-unit id="dc84c992e3edcd39e94928310a7c42a03b0e34c8" translate="yes" xml:space="preserve">
          <source>Why aren't my random numbers random?</source>
          <target state="translated">왜 난수가 무작위가 아닌가?</target>
        </trans-unit>
        <trans-unit id="55451ebd45b1e100db71c6105ddc04433d37cb2f" translate="yes" xml:space="preserve">
          <source>Why can't I get the output of a command with system()?</source>
          <target state="translated">system ()으로 명령의 출력을 얻을 수없는 이유는 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="6283f33f8240aceff8b5bf7c89ea62586d7996ea" translate="yes" xml:space="preserve">
          <source>Why can't I just open(FH, &quot;&amp;gt;file.lock&quot;)?</source>
          <target state="translated">왜 그냥 열 수 없습니까 (FH, &quot;&amp;gt; file.lock&quot;)?</target>
        </trans-unit>
        <trans-unit id="45f36238b104ed9ce41136ab2cd5676c9546b754" translate="yes" xml:space="preserve">
          <source>Why can't I use &quot;C:\temp\foo&quot; in DOS paths? Why doesn't `C:\temp\foo.exe` work?</source>
          <target state="translated">DOS 경로에서 &quot;C : \ temp \ foo&quot;를 사용할 수없는 이유는 무엇입니까? 왜 C : \ temp \ foo.exe가 작동하지 않습니까?</target>
        </trans-unit>
        <trans-unit id="7cf9bf3687394740ded1b7a3b49b00f8b7f479e0" translate="yes" xml:space="preserve">
          <source>Why can't a method included in this same file be found?</source>
          <target state="translated">동일한 파일에 포함 된 방법을 찾을 수없는 이유는 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="c1b368f947117e2802b241b52fd0f345164c6250" translate="yes" xml:space="preserve">
          <source>Why can't my script read from STDIN after I gave it EOF (^D on Unix, ^Z on MS-DOS)?</source>
          <target state="translated">STDIN에 EOF (유닉스에서는 ^ D, MS-DOS에서는 ^ Z)를 지정한 후에 왜 스크립트를 STDIN에서 읽을 수 없습니까?</target>
        </trans-unit>
        <trans-unit id="12d1b0fba90164d9432c0961ee9c0f59f511f752" translate="yes" xml:space="preserve">
          <source>Why can't the part of an Email address after the @ be used as the hostname ?</source>
          <target state="translated">@ 뒤의 이메일 주소 일부를 호스트 이름으로 사용할 수없는 이유는 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="4a35a43f2543633bf09ecfd8ed381f93a2e351c4" translate="yes" xml:space="preserve">
          <source>Why chimera build?</source>
          <target state="translated">키메라가 왜 건설됩니까?</target>
        </trans-unit>
        <trans-unit id="4ad29870738240c44cf5d008e9ef6e5a830b4811" translate="yes" xml:space="preserve">
          <source>Why did MakeMaker reinvent the build configuration wheel? Why not just use autoconf or automake or ppm or Ant or ...</source>
          <target state="translated">MakeMaker가 빌드 구성 휠을 다시 발명 한 이유는 무엇입니까? 왜 autoconf 또는 automake 또는 ppm 또는 Ant 또는 ...를 사용하지 않습니까?</target>
        </trans-unit>
        <trans-unit id="9c94cf8ad35b8d40bcd1d8a24897df534e24a65c" translate="yes" xml:space="preserve">
          <source>Why do I get asked the same questions every time I start the shell?</source>
          <target state="translated">쉘을 시작할 때마다 왜 같은 질문을 받습니까?</target>
        </trans-unit>
        <trans-unit id="88d20a17cd64b1f5b322facdeee78dd428855e4f" translate="yes" xml:space="preserve">
          <source>Why do I get weird spaces when I print an array of lines?</source>
          <target state="translated">배열을 인쇄 할 때 왜 이상한 공백이 생기나요?</target>
        </trans-unit>
        <trans-unit id="22c242ee2f7e6a5499b05c8e9ef2302a328d950b" translate="yes" xml:space="preserve">
          <source>Why do I sometimes get an &quot;Argument list too long&quot; when I use &amp;lt;*&amp;gt;?</source>
          <target state="translated">&amp;lt;*&amp;gt;를 사용할 때 왜 때때로 &quot;인수 목록이 너무 깁니다&quot;가 표시됩니까?</target>
        </trans-unit>
        <trans-unit id="b24284283ebf1fc2287cf9d0bdc0093551feae63" translate="yes" xml:space="preserve">
          <source>Why do I sometimes get an &quot;Argument list too long&quot; when I use ?</source>
          <target state="translated">사용할 때 왜 &quot;인수 목록이 너무 깁니다&quot;가 표시됩니까?</target>
        </trans-unit>
        <trans-unit id="63e6abc6f1a440467925da9b75e53aa88bf445d6" translate="yes" xml:space="preserve">
          <source>Why do Perl operators have different precedence than C operators?</source>
          <target state="translated">Perl 연산자가 C 연산자와 우선 순위가 다른 이유는 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="ef2253bfbc8ad66388d03d0bb9e87b886d907b29" translate="yes" xml:space="preserve">
          <source>Why do regex character classes sometimes match only in the ASCII range?</source>
          <target state="translated">정규식 문자 클래스가 ASCII 범위에서만 일치하는 이유는 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="fe1dc5c347574cf3a08e8eebfbeb7750b39e6b8c" translate="yes" xml:space="preserve">
          <source>Why do setuid perl scripts complain about kernel problems?</source>
          <target state="translated">setuid perl 스크립트가 커널 문제에 대해 불평하는 이유는 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="026df39820ea4af121bee1f807b65636d02b2c10" translate="yes" xml:space="preserve">
          <source>Why do some characters not uppercase or lowercase correctly?</source>
          <target state="translated">일부 문자가 대문자 나 소문자가 아닌 이유는 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="c99d6ee81fb9e8a95f7bcc8c77d79b83dd80d118" translate="yes" xml:space="preserve">
          <source>Why do you want to do that? :-)</source>
          <target state="translated">왜 그렇게 하시겠습니까? :-)</target>
        </trans-unit>
        <trans-unit id="72bb63a51859ce8a03efe317ce769e0ebbe394ee" translate="yes" xml:space="preserve">
          <source>Why does Net::FTP not implement mput and mget methods</source>
          <target state="translated">Net :: FTP가 mput 및 mget 메서드를 구현하지 않는 이유</target>
        </trans-unit>
        <trans-unit id="c2f2d2fc2e6067abbcff0c6297133f00fea08094" translate="yes" xml:space="preserve">
          <source>Why does Net::SMTP not do DNS MX lookups ?</source>
          <target state="translated">Net :: SMTP가 DNS MX 조회를 수행하지 않는 이유는 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="bd94a8382da48e70b41ef67567b746b186c9a0e6" translate="yes" xml:space="preserve">
          <source>Why does Perl let me delete read-only files? Why does -i clobber protected files? Isn't this a bug in Perl?</source>
          <target state="translated">Perl에서 왜 읽기 전용 파일을 삭제할 수 있습니까? -i clobber로 파일을 보호하는 이유는 무엇입니까? 이것은 Perl의 버그가 아닌가?</target>
        </trans-unit>
        <trans-unit id="cc878c7b17c2f51ef8a429a9375cb383410dd74c" translate="yes" xml:space="preserve">
          <source>Why does Perl let me delete read-only files? Why does &lt;code&gt;-i&lt;/code&gt; clobber protected files? Isn't this a bug in Perl?</source>
          <target state="translated">Perl에서 왜 읽기 전용 파일을 삭제할 수 있습니까? &lt;code&gt;-i&lt;/code&gt; clobber로 파일을 보호하는 이유는 무엇 입니까? 이것은 Perl의 버그가 아닌가?</target>
        </trans-unit>
        <trans-unit id="cab7997afd3e855e0bc949d3ba08b5a07d77bad2" translate="yes" xml:space="preserve">
          <source>Why does defined() return true on empty arrays and hashes?</source>
          <target state="translated">빈 배열과 해시에서 defined ()가 true를 반환하는 이유는 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="a9078f034de31f1b296232dfb6a8a4e24d9d3fe0" translate="yes" xml:space="preserve">
          <source>Why does passing a subroutine an undefined element in a hash create it?</source>
          <target state="translated">해시에서 서브 루틴에 정의되지 않은 요소를 전달하면 왜 생성됩니까?</target>
        </trans-unit>
        <trans-unit id="7586fa4c0b5fc90f209bbbf4172abb17863eb05e" translate="yes" xml:space="preserve">
          <source>Why does using $&amp;amp;, $`, or $' slow my program down?</source>
          <target state="translated">$ &amp;amp;, $`또는 $ '를 사용하면 왜 프로그램 속도가 느려 집니까?</target>
        </trans-unit>
        <trans-unit id="d0d6812625a87b8571932c2c534a16df1d30c46a" translate="yes" xml:space="preserve">
          <source>Why doesn't &quot;my($foo) = &amp;lt;$fh&amp;gt;;&quot; work right?</source>
          <target state="translated">&quot;my ($ foo) = &amp;lt;$ fh&amp;gt;;&quot;가 아닌 이유 제대로 작동합니까?</target>
        </trans-unit>
        <trans-unit id="dce612b6a2414fd18ba042c0e4b6d8009b148ed5" translate="yes" xml:space="preserve">
          <source>Why doesn't &quot;my($foo) = ;&quot; work right?</source>
          <target state="translated">&quot;my ($ foo) =;&quot;가 아닌 이유 제대로 작동합니까?</target>
        </trans-unit>
        <trans-unit id="5027566591e947a691e8c94cf6484817ceca1f52" translate="yes" xml:space="preserve">
          <source>Why doesn't &amp;amp; work the way I want it to?</source>
          <target state="translated">원하는 방식으로 왜 작동하지 않습니까?</target>
        </trans-unit>
        <trans-unit id="4cf8f75bbab1ae3d6a9b3cc517f4738f093df66a" translate="yes" xml:space="preserve">
          <source>Why doesn't glob(&quot;*.*&quot;) get all the files?</source>
          <target state="translated">glob ( &quot;*. *&quot;)가 모든 파일을 가져 오지 않는 이유는 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="2deaa0032d55ad3bbe4d463b92dc4d6876271de7" translate="yes" xml:space="preserve">
          <source>Why doesn't my sockets program work under System V (Solaris)? What does the error message &quot;Protocol not supported&quot; mean?</source>
          <target state="translated">왜 소켓 프로그램이 System V (Solaris)에서 작동하지 않습니까? &quot;프로토콜이 지원되지 않습니다&quot;라는 오류 메시지는 무엇을 의미합니까?</target>
        </trans-unit>
        <trans-unit id="94b7e3ba62840111acddb7ecbcec36ba2e7bc4b2" translate="yes" xml:space="preserve">
          <source>Why doesn't open() return an error when a pipe open fails?</source>
          <target state="translated">파이프 열림에 실패했을 때 왜 open ()이 오류를 반환하지 않습니까?</target>
        </trans-unit>
        <trans-unit id="39d80c781157cb75a05623de25db34f558131470" translate="yes" xml:space="preserve">
          <source>Why don't Perl one-liners work on my DOS/Mac/VMS system?</source>
          <target state="translated">Perl one-liner가 DOS / Mac / VMS 시스템에서 작동하지 않는 이유는 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="7efb6bacfd459d208d2e83d3ccd6f5a6e06b31a2" translate="yes" xml:space="preserve">
          <source>Why don't my &amp;lt;</source>
          <target state="translated">왜 내 &amp;lt;</target>
        </trans-unit>
        <trans-unit id="d55b9cceedd9f6975831dcd97371f91faa17e9ba" translate="yes" xml:space="preserve">
          <source>Why don't my &amp;lt;&amp;lt;HERE documents work?</source>
          <target state="translated">&amp;lt;&amp;lt; HERE 문서가 작동하지 않는 이유는 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="1b729d456f5e2de755ce9ca47664753dfbd6fc06" translate="yes" xml:space="preserve">
          <source>Why don't my tied hashes make the defined/exists distinction?</source>
          <target state="translated">묶인 해시가 정의 / 존재를 구별하지 않는 이유는 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="ec879bc347cf004a28479d385b991508d06231e9" translate="yes" xml:space="preserve">
          <source>Why don't word-boundary searches with &lt;code&gt;\b&lt;/code&gt; work for me?</source>
          <target state="translated">&lt;code&gt;\b&lt;/code&gt; 단어 경계 검색이 작동 하지 않는 이유는 무엇 입니까?</target>
        </trans-unit>
        <trans-unit id="123e5244abcc6475513e58c7be3baf1e624a09b7" translate="yes" xml:space="preserve">
          <source>Why don't word-boundary searches with \b work for me?</source>
          <target state="translated">\ b로 단어 경계 검색이 작동하지 않는 이유는 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="aa0f337d4d9c4331ea81d21ad3497b56fec40614" translate="yes" xml:space="preserve">
          <source>Why dynamic linking?</source>
          <target state="translated">동적 연결이 필요한 이유</target>
        </trans-unit>
        <trans-unit id="4dfd253727c4f99a421a3b97c6c33e70ca139825" translate="yes" xml:space="preserve">
          <source>Why is int() broken?</source>
          <target state="translated">왜 int ()가 깨졌습니까?</target>
        </trans-unit>
        <trans-unit id="a9539bbca1f0e44580627232613c4e6433a9dda3" translate="yes" xml:space="preserve">
          <source>Why is there Perl source in my database?</source>
          <target state="translated">데이터베이스에 Perl 소스가있는 이유는 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="5376410df92e4e194b5ef26e3120b8356d39f687" translate="yes" xml:space="preserve">
          <source>Why isn't my octal data interpreted correctly?</source>
          <target state="translated">8 진 데이터가 왜 올바르게 해석되지 않습니까?</target>
        </trans-unit>
        <trans-unit id="76e636f7e8860a670fadde05e6d7c8a9de0467dd" translate="yes" xml:space="preserve">
          <source>Why not just use &amp;lt;insert other build config tool here&amp;gt;?</source>
          <target state="translated">&amp;lt;여기에 다른 빌드 구성 도구 삽입&amp;gt;을 사용하지 않는 이유는 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="8adf1b58b38027864f2d28cd98aeb834dee11ea7" translate="yes" xml:space="preserve">
          <source>Why strange names?</source>
          <target state="translated">왜 이상한 이름?</target>
        </trans-unit>
        <trans-unit id="d2f963c70a1ed1fc561f572fe023203fb76a83ae" translate="yes" xml:space="preserve">
          <source>Why the heck Encode API is different?</source>
          <target state="translated">도대체 Encode API가 다른 이유는 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="2d967f841c57d824cac2c9266688fd2aa1c5db9c" translate="yes" xml:space="preserve">
          <source>Why use ppport.h?</source>
          <target state="translated">왜 ppport.h를 사용합니까?</target>
        </trans-unit>
        <trans-unit id="df4212a2d988730cb90863e6978ac9cd91d10bdc" translate="yes" xml:space="preserve">
          <source>Why would you want a hash of lists? Let's take a simple example: You have a file of city and country names, like this:</source>
          <target state="translated">왜 목록 해시를 원하십니까? 간단한 예를 들어 보자. 다음과 같이 도시 및 국가 이름 파일이 있습니다.</target>
        </trans-unit>
        <trans-unit id="7f3771c096b7c324730a1a8a01295eb54a206ffa" translate="yes" xml:space="preserve">
          <source>Why, you may ask, would you need a chunk of memory containing some values in binary representation? One good reason is input and output accessing some file, a device, or a network connection, whereby this binary representation is either forced on you or will give you some benefit in processing. Another cause is passing data to some system call that is not available as a Perl function: &lt;code&gt;&lt;a href=&quot;functions/syscall&quot;&gt;syscall&lt;/a&gt;&lt;/code&gt; requires you to provide parameters stored in the way it happens in a C program. Even text processing (as shown in the next section) may be simplified with judicious usage of these two functions.</source>
          <target state="translated">왜 이진 표현으로 일부 값을 포함하는 메모리 청크가 필요합니까? 한 가지 이유는 입력 및 출력이 일부 파일, 장치 또는 네트워크 연결에 액세스하는 것입니다.이 이진 표현은 사용자에게 강요되거나 처리에 도움이됩니다. 또 다른 원인은 Perl 함수로는 사용할 수없는 일부 시스템 호출에 데이터를 전달하는 것입니다. &lt;code&gt;&lt;a href=&quot;functions/syscall&quot;&gt;syscall&lt;/a&gt;&lt;/code&gt; 을 사용 하려면 C 프로그램에서 발생하는 방식으로 저장된 매개 변수를 제공해야합니다. 이 두 기능을 신중하게 사용하면 텍스트 처리 (다음 섹션에 표시)도 단순화 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6ab0396ba481d1f15a966e8a80a53c0fff8a6b1e" translate="yes" xml:space="preserve">
          <source>Why, you may ask, would you need a chunk of memory containing some values in binary representation? One good reason is input and output accessing some file, a device, or a network connection, whereby this binary representation is either forced on you or will give you some benefit in processing. Another cause is passing data to some system call that is not available as a Perl function: &lt;code&gt;syscall&lt;/code&gt; requires you to provide parameters stored in the way it happens in a C program. Even text processing (as shown in the next section) may be simplified with judicious usage of these two functions.</source>
          <target state="translated">이진 표현으로 일부 값을 포함하는 메모리 덩어리가 필요한 이유는 무엇입니까? 한 가지 좋은 이유는 입력 및 출력이 일부 파일, 장치 또는 네트워크 연결에 액세스하는 것입니다. 이로 인해이 이진 표현이 강제되거나 처리에 약간의 이점을 제공합니다. 또 다른 원인은 Perl 함수로 사용할 수없는 일부 시스템 호출에 데이터를 전달하는 것입니다. &lt;code&gt;syscall&lt;/code&gt; 에서는 C 프로그램에서 발생하는 방식으로 저장된 매개 변수를 제공해야합니다. 텍스트 처리 (다음 섹션 참조)조차도이 두 기능을 적절히 사용하면 단순화 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d1b95af46a7dc5483f3c0502e26f80b536b33809" translate="yes" xml:space="preserve">
          <source>Why? Because &lt;code&gt;can&lt;/code&gt; returns a coderef to mean &quot;yes it can (and the method is this...)&quot;, and then &lt;code&gt;ok&lt;/code&gt; sees a coderef and thinks you're passing a function that you want it to call and consider the truth of the result of! I.e., just like:</source>
          <target state="translated">왜? 때문에 &lt;code&gt;can&lt;/code&gt; 반환 코드 참조 의미하고, 그 다음에 &quot;예는 수 (및 방법은이는 ...)는&quot; &lt;code&gt;ok&lt;/code&gt; 당신이 그것을 호출하고 결과의 진실을 고려할 것을 코드 참조를보고 당신이 함수를 전달하는 생각 의! 즉, 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c682a5bde8a3f0f1d13f9a9af66f849014ab6208" translate="yes" xml:space="preserve">
          <source>Why? Because &lt;code&gt;nasty_break()&lt;/code&gt; modifies &lt;code&gt;$\&lt;/code&gt; without localizing it first. The value you set in &lt;code&gt;nasty_break()&lt;/code&gt; is still there when you return. The fix is to add &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local()&lt;/a&gt;&lt;/code&gt; so the value doesn't leak out of &lt;code&gt;nasty_break()&lt;/code&gt; :</source>
          <target state="translated">왜? &lt;code&gt;nasty_break()&lt;/code&gt; 는 먼저 지역화하지 않고 &lt;code&gt;$\&lt;/code&gt; 를 수정 하기 때문 입니다. &lt;code&gt;nasty_break()&lt;/code&gt; 에서 설정 한 값 은 반환 할 때 여전히 존재합니다. 수정은 &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local()&lt;/a&gt;&lt;/code&gt; 을 추가 하여 값이 &lt;code&gt;nasty_break()&lt;/code&gt; 누출되지 않도록하는 것입니다 .</target>
        </trans-unit>
        <trans-unit id="a6faa641a92e7908b2759e3d399e519a97396eeb" translate="yes" xml:space="preserve">
          <source>Why? Because &lt;code&gt;nasty_break()&lt;/code&gt; modifies &lt;code&gt;$\&lt;/code&gt; without localizing it first. The value you set in &lt;code&gt;nasty_break()&lt;/code&gt; is still there when you return. The fix is to add &lt;code&gt;local()&lt;/code&gt; so the value doesn't leak out of &lt;code&gt;nasty_break()&lt;/code&gt;:</source>
          <target state="translated">왜? &lt;code&gt;nasty_break()&lt;/code&gt; 는 먼저 지역화하지 않고 &lt;code&gt;$\&lt;/code&gt; 를 수정 하기 때문 입니다. &lt;code&gt;nasty_break()&lt;/code&gt; 에서 설정 한 값 은 반환 할 때 그대로 유지됩니다. 수정 사항은 &lt;code&gt;local()&lt;/code&gt; 을 추가 하여 값이 &lt;code&gt;nasty_break()&lt;/code&gt; 밖으로 누출되지 않도록하는 것입니다 .</target>
        </trans-unit>
        <trans-unit id="e2a097ba046d774750c25655e60293a973b6be9d" translate="yes" xml:space="preserve">
          <source>Wide character (U+%X) in %s</source>
          <target state="translated">% s의 와이드 문자 (U + % X)</target>
        </trans-unit>
        <trans-unit id="745ada6d8a512f870963c08fe697c0dd823de817" translate="yes" xml:space="preserve">
          <source>Wide character in %s</source>
          <target state="translated">% s의 넓은 문자</target>
        </trans-unit>
        <trans-unit id="59af40d4a351e635fdbe369d7b681d20a590a23a" translate="yes" xml:space="preserve">
          <source>Wildcard expansion</source>
          <target state="translated">와일드 카드 확장</target>
        </trans-unit>
        <trans-unit id="47c9b4ee449bd8455aec29f4590e9aaa03c049f4" translate="yes" xml:space="preserve">
          <source>Wildcards in Property Values</source>
          <target state="translated">속성 값의 와일드 카드</target>
        </trans-unit>
        <trans-unit id="70477b387f14e0143de5873f3a9e791508ea1046" translate="yes" xml:space="preserve">
          <source>Will My Old Scripts Break?</source>
          <target state="translated">내 오래된 스크립트가 깨지나요?</target>
        </trans-unit>
        <trans-unit id="2873c6e6e5880b670c065bcdc4a78243fbadf06c" translate="yes" xml:space="preserve">
          <source>Will Sheppard &amp;lt;</source>
          <target state="translated">윌 셰퍼드 &amp;lt;</target>
        </trans-unit>
        <trans-unit id="2758b8d4c9377404295cf137b65b7a19678f3231" translate="yes" xml:space="preserve">
          <source>Will add a file to the in-memory archive, with name &lt;code&gt;$filename&lt;/code&gt; and content &lt;code&gt;$data&lt;/code&gt; . Specific properties can be set using &lt;code&gt;$opthashref&lt;/code&gt; . The following list of properties is supported: name, size, mtime (last modified date), mode, uid, gid, linkname, uname, gname, devmajor, devminor, prefix, type. (On MacOS, the file's path and modification times are converted to Unix equivalents.)</source>
          <target state="translated">이름이 &lt;code&gt;$filename&lt;/code&gt; 이고 content &lt;code&gt;$data&lt;/code&gt; 파일을 메모리 내 아카이브에 추가합니다 . &lt;code&gt;$opthashref&lt;/code&gt; 사용하여 특정 속성을 설정할 수 있습니다 . 이름, 크기, mtime (마지막 수정 날짜), mode, uid, gid, linkname, uname, gname, devmajor, devminor, prefix, type 등의 속성 목록이 지원됩니다. (MacOS에서는 파일의 경로와 수정 시간이 Unix로 변환됩니다.)</target>
        </trans-unit>
        <trans-unit id="93e582e568148c77bec33609334f756f428deffa" translate="yes" xml:space="preserve">
          <source>Will add a file to the in-memory archive, with name &lt;code&gt;$filename&lt;/code&gt; and content &lt;code&gt;$data&lt;/code&gt;. Specific properties can be set using &lt;code&gt;$opthashref&lt;/code&gt;. The following list of properties is supported: name, size, mtime (last modified date), mode, uid, gid, linkname, uname, gname, devmajor, devminor, prefix, type. (On MacOS, the file's path and modification times are converted to Unix equivalents.)</source>
          <target state="translated">이름이 &lt;code&gt;$filename&lt;/code&gt; 이고 내용이 &lt;code&gt;$data&lt;/code&gt; 인 메모리 내 아카이브에 파일을 추가합니다 . &lt;code&gt;$opthashref&lt;/code&gt; 사용하여 특정 속성을 설정할 수 있습니다 . 지원되는 속성 목록은 이름, 크기, mtime (마지막 수정 날짜), 모드, uid, gid, linkname, uname, gname, devmajor, devminor, prefix, type입니다. (MacOS에서는 파일의 경로와 수정 시간이 해당하는 Unix로 변환됩니다.)</target>
        </trans-unit>
        <trans-unit id="af66cccfd8aea183b531eebc0a74a7e923052ebf" translate="yes" xml:space="preserve">
          <source>Will be called when &lt;code&gt;&lt;a href=&quot;functions/untie&quot;&gt;untie&lt;/a&gt;&lt;/code&gt; happens. (See &lt;a href=&quot;#The-untie-Gotcha&quot;&gt;The untie Gotcha&lt;/a&gt; below.)</source>
          <target state="translated">때 호출 될 &lt;code&gt;&lt;a href=&quot;functions/untie&quot;&gt;untie&lt;/a&gt;&lt;/code&gt; 발생합니다. (아래 &lt;a href=&quot;#The-untie-Gotcha&quot;&gt;의 Unt Gotcha&lt;/a&gt; 참조)</target>
        </trans-unit>
        <trans-unit id="3135cfa6b9641d632048427137e9d839208222a7" translate="yes" xml:space="preserve">
          <source>Will be called when &lt;code&gt;untie&lt;/code&gt; happens. (See &lt;a href=&quot;#The-untie-Gotcha&quot;&gt;&quot;The &lt;code&gt;untie&lt;/code&gt; Gotcha&quot;&lt;/a&gt; below.)</source>
          <target state="translated">&lt;code&gt;untie&lt;/code&gt; 때 호출됩니다 . (아래의 &lt;a href=&quot;#The-untie-Gotcha&quot;&gt;&quot;The &lt;code&gt;untie&lt;/code&gt; Gotcha&quot;를&lt;/a&gt; 참조하십시오.)</target>
        </trans-unit>
        <trans-unit id="5c123e132f25bf178be9ea2aca72fafe2969081c" translate="yes" xml:space="preserve">
          <source>Will be loaded on demand and called automatically by BigInt.</source>
          <target state="translated">요청시로드되며 BigInt가 자동으로 호출합니다.</target>
        </trans-unit>
        <trans-unit id="a669aaf9a433f6903c152ca38a90c9c7cb258f3e" translate="yes" xml:space="preserve">
          <source>Will be prepended to each install path.</source>
          <target state="translated">각 설치 경로 앞에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="4532ff2be2d0615be4c0aa19707d4e886e5a1789" translate="yes" xml:space="preserve">
          <source>Will be set to a uuid if uuid tagging was enabled.</source>
          <target state="translated">uuid 태그 지정이 활성화 된 경우 uuid로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="9f18d29650d7b716edb7780278b512b0a8a59170" translate="yes" xml:space="preserve">
          <source>Will be used to modify the padding applied to string as described above.</source>
          <target state="translated">위에서 설명한 것처럼 문자열에 적용된 패딩을 수정하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="4e827c2a869b099543f874a4407588358567998d" translate="yes" xml:space="preserve">
          <source>Will both leave the sentence as is. Normally, when accepting literal string input from the user, &lt;a href=&quot;#quotemeta-EXPR&quot;&gt;&lt;code&gt;quotemeta&lt;/code&gt;&lt;/a&gt; or &lt;code&gt;\Q&lt;/code&gt; must be used.</source>
          <target state="translated">둘 다 문장을 그대로 둡니다. 일반적으로 사용자로부터 리터럴 문자열 입력을받을 때 &lt;a href=&quot;#quotemeta-EXPR&quot;&gt; &lt;code&gt;quotemeta&lt;/code&gt; &lt;/a&gt; 또는 &lt;code&gt;\Q&lt;/code&gt; 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="a659ce6bd28efeb251560042f49a1924dca7c4a4" translate="yes" xml:space="preserve">
          <source>Will both leave the sentence as is. Normally, when accepting literal string input from the user, quotemeta() or &lt;code&gt;\Q&lt;/code&gt; must be used.</source>
          <target state="translated">둘 다 문장을 그대로 둡니다. 일반적으로 사용자로부터 리터럴 문자열 입력을 승인 할 때는 quotemeta () 또는 &lt;code&gt;\Q&lt;/code&gt; 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="10fbb1ac2af71320cfd2110a94f422695cba5311" translate="yes" xml:space="preserve">
          <source>Will cause &lt;code&gt;$sentence&lt;/code&gt; to become &lt;code&gt;'The big bad wolf jumped over...'&lt;/code&gt; .</source>
          <target state="translated">원인이됩니다 &lt;code&gt;$sentence&lt;/code&gt; 이 될 &lt;code&gt;'The big bad wolf jumped over...'&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="10dc8768858451ca68c298fbc7a5ad46babe9c5d" translate="yes" xml:space="preserve">
          <source>Will cause &lt;code&gt;$sentence&lt;/code&gt; to become &lt;code&gt;'The big bad wolf jumped over...'&lt;/code&gt;.</source>
          <target state="translated">원인이됩니다 &lt;code&gt;$sentence&lt;/code&gt; 이 될 &lt;code&gt;'The big bad wolf jumped over...'&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="66fbedfbffb0f55bc116220f01908ca58f12e965" translate="yes" xml:space="preserve">
          <source>Will croak() if there is an error.</source>
          <target state="translated">오류가 있으면 croak ()합니다.</target>
        </trans-unit>
        <trans-unit id="a89e6d7112dafb5b2ad3a46406c0ced36b7d13b7" translate="yes" xml:space="preserve">
          <source>Will die() if called on r-magic.</source>
          <target state="translated">r-magic에서 호출하면 die ()됩니다.</target>
        </trans-unit>
        <trans-unit id="0768298b9a0627e90df27324883d97a236031b2a" translate="yes" xml:space="preserve">
          <source>Will dump the contents of any references in a human readable format. Handy for things like...</source>
          <target state="translated">참조의 내용을 사람이 읽을 수있는 형식으로 덤프합니다. 다음과 같은 것들에 편리합니다 ...</target>
        </trans-unit>
        <trans-unit id="481a8de568a61f103c3af4da9f82b1f103a46712" translate="yes" xml:space="preserve">
          <source>Will dump the contents of any references in a human readable format. Usually you want to pass this into &lt;code&gt;note&lt;/code&gt; or &lt;code&gt;diag&lt;/code&gt; .</source>
          <target state="translated">참조의 내용을 사람이 읽을 수있는 형식으로 덤프합니다. 보통 이것을 &lt;code&gt;note&lt;/code&gt; 또는 &lt;code&gt;diag&lt;/code&gt; 에 전달하려고합니다 .</target>
        </trans-unit>
        <trans-unit id="cdc14d4349b2640a0197394413323e6c4dc94091" translate="yes" xml:space="preserve">
          <source>Will dump the contents of any references in a human readable format. Usually you want to pass this into &lt;code&gt;note&lt;/code&gt; or &lt;code&gt;diag&lt;/code&gt;.</source>
          <target state="translated">참조 내용을 사람이 읽을 수있는 형식으로 덤프합니다. 일반적으로 이것을 &lt;code&gt;note&lt;/code&gt; 또는 &lt;code&gt;diag&lt;/code&gt; 로 전달합니다 .</target>
        </trans-unit>
        <trans-unit id="75f83221407c4472808dc0bb2139500f5229338d" translate="yes" xml:space="preserve">
          <source>Will force the generation of test code that uses the older &lt;code&gt;Test&lt;/code&gt; module.</source>
          <target state="translated">이전 &lt;code&gt;Test&lt;/code&gt; 모듈 을 사용하는 테스트 코드를 강제로 생성 합니다.</target>
        </trans-unit>
        <trans-unit id="a329a554ce0cef11ca3198cc6cf9ba23c8d4f77f" translate="yes" xml:space="preserve">
          <source>Will incorrectly print</source>
          <target state="translated">잘못 인쇄됩니다</target>
        </trans-unit>
        <trans-unit id="fe4d3313b3f93ee1361d2d67710393a85713398e" translate="yes" xml:space="preserve">
          <source>Will invoke a sub at the end of a (compile-time) scope. The sub is called once with no arguments. Can be called multiple times (even in the same &quot;compile-time&quot; scope) to install multiple subs. Subs are called in a &quot;first-in-last-out&quot;-order (FILO or &quot;stack&quot;-order).</source>
          <target state="translated">(컴파일 타임) 범위의 끝에서 하위를 호출합니다. 서브는 인수없이 한 번 호출됩니다. 여러 서브를 설치하기 위해 여러 번 호출 할 수 있습니다 (동일한 &quot;컴파일 타임&quot;범위에서도). 서브는 &quot;선입 선출&quot;순서 (FILO 또는 &quot;스택&quot;순서)로 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="c610d24bbac520a7e0e174e12fe1f23a3ae5f9e4" translate="yes" xml:space="preserve">
          <source>Will make sure that =head1 will become &amp;lt;h3&amp;gt; and =head2 will become &amp;lt;h4&amp;gt; etc...</source>
          <target state="translated">= head1이 &amp;lt;h3&amp;gt;이되고 = head2가 &amp;lt;h4&amp;gt;가되도록해야합니다.</target>
        </trans-unit>
        <trans-unit id="49024b4120de3dd67c62575e0a4eb5f193ed6c22" translate="yes" xml:space="preserve">
          <source>Will not cause &lt;code&gt;&lt;a href=&quot;functions/readdir&quot;&gt;readdir()&lt;/a&gt;&lt;/code&gt; to re-read the directory stream. The entries already read before the &lt;code&gt;&lt;a href=&quot;functions/rewinddir&quot;&gt;rewinddir()&lt;/a&gt;&lt;/code&gt; call will just be returned again from a cache buffer. (Win32)</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/readdir&quot;&gt;readdir()&lt;/a&gt;&lt;/code&gt; 이 디렉토리 스트림을 다시 읽지 않도록 합니다. &lt;code&gt;&lt;a href=&quot;functions/rewinddir&quot;&gt;rewinddir()&lt;/a&gt;&lt;/code&gt; 호출 전에 이미 읽은 항목 은 캐시 버퍼에서 다시 반환됩니다. (Win32)</target>
        </trans-unit>
        <trans-unit id="845d623fd40095b89ded11a672446e7d8d2933f3" translate="yes" xml:space="preserve">
          <source>Will not exceed this limit even if the string is not valid &quot;UTF-8&quot;.</source>
          <target state="translated">문자열이 유효한 &quot;UTF-8&quot;이 아닌 경우에도이 제한을 초과하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7706e40a252d341368a094f13349cb965c7bcf44" translate="yes" xml:space="preserve">
          <source>Will not exceed those limits even if the string is not valid &quot;UTF-8&quot;.</source>
          <target state="translated">문자열이 유효한 &quot;UTF-8&quot;이 아닌 경우에도 이러한 제한을 초과하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0b4b57e33203662ee1ddac498725ec0cbd902da5" translate="yes" xml:space="preserve">
          <source>Will not work on platforms that do not support the &lt;code&gt;-k&lt;/code&gt; test for sticky bit.</source>
          <target state="translated">고정 비트에 대한 &lt;code&gt;-k&lt;/code&gt; 테스트를 지원하지 않는 플랫폼에서는 작동하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="aff13c5ad9d691f5f29f20db0a92fc55a16499de" translate="yes" xml:space="preserve">
          <source>Will not work on platforms that do not support the C test for sticky bit.</source>
          <target state="translated">고정 비트에 대한 C 테스트를 지원하지 않는 플랫폼에서는 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="19ad79cf64559535aa01bc2039517ce48ed1f305" translate="yes" xml:space="preserve">
          <source>Will output 2, not 1. This is particularly important if you intend to compile the definitions with the &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt; operator, and later interpolate them in another pattern.</source>
          <target state="translated">1이 아닌 2를 출력합니다. 이것은 &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt; 연산자로 정의를 컴파일 하고 나중에 다른 패턴으로 보간 하려는 경우에 특히 중요합니다 .</target>
        </trans-unit>
        <trans-unit id="d7ba12340e687f11ed70710aaea6e46b38d77b8f" translate="yes" xml:space="preserve">
          <source>Will output 2, not 1. This is particularly important if you intend to compile the definitions with the &lt;code&gt;qr//&lt;/code&gt; operator, and later interpolate them in another pattern.</source>
          <target state="translated">1이 아닌 2를 출력합니다. 이것은 &lt;code&gt;qr//&lt;/code&gt; 연산자로 정의를 컴파일 하고 나중에 다른 패턴으로 보간 하려는 경우 특히 중요합니다 .</target>
        </trans-unit>
        <trans-unit id="10021ccb8e306fb831263dee40b8f7ca24084b5a" translate="yes" xml:space="preserve">
          <source>Will prevent the automatic use of INSTALL.SKIP as the install skip file.</source>
          <target state="translated">설치 건너 뛰기 파일로 INSTALL.SKIP를 자동으로 사용하지 못하게합니다.</target>
        </trans-unit>
        <trans-unit id="897aeeccb9736732e15f96f20d971e76dcd3a8ff" translate="yes" xml:space="preserve">
          <source>Will print &lt;code&gt;2&lt;/code&gt; , because &lt;code&gt;$string&lt;/code&gt; is upgraded as UTF-8. Without &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; encoding 'utf8';&lt;/code&gt; , it will print &lt;code&gt;4&lt;/code&gt; instead, since &lt;code&gt;$string&lt;/code&gt; is three octets when interpreted as Latin-1.</source>
          <target state="translated">인쇄 할 &lt;code&gt;2&lt;/code&gt; 를 하기 때문에, &lt;code&gt;$string&lt;/code&gt; UTF-8로 업그레이드됩니다. &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; encoding 'utf8';&lt;/code&gt; &lt;a href=&quot;functions/use&quot;&gt;사용&lt;/a&gt; 하지 않고 ; &lt;code&gt;$string&lt;/code&gt; 은 Latin-1로 해석 될 때 3 옥텟 이기 때문에 대신 &lt;code&gt;4&lt;/code&gt; 를 인쇄 합니다.</target>
        </trans-unit>
        <trans-unit id="c7912cc2705e39fd55074c6583f91d53d1be3b82" translate="yes" xml:space="preserve">
          <source>Will print &lt;code&gt;2&lt;/code&gt;, because &lt;code&gt;$string&lt;/code&gt; is upgraded as UTF-8. Without &lt;code&gt;use encoding 'utf8';&lt;/code&gt;, it will print &lt;code&gt;4&lt;/code&gt; instead, since &lt;code&gt;$string&lt;/code&gt; is three octets when interpreted as Latin-1.</source>
          <target state="translated">인쇄 할 &lt;code&gt;2&lt;/code&gt; 를 하기 때문에, &lt;code&gt;$string&lt;/code&gt; UTF-8로 업그레이드됩니다. &lt;code&gt;use encoding 'utf8';&lt;/code&gt; 하지 않고 ; , &lt;code&gt;$string&lt;/code&gt; 은 Latin-1로 해석 될 때 3 개의 옥텟 이므로 대신 &lt;code&gt;4&lt;/code&gt; 를 인쇄 합니다.</target>
        </trans-unit>
        <trans-unit id="ceca318096ebec569ca5ded9c24fde055f72cece" translate="yes" xml:space="preserve">
          <source>Will print just the value of &lt;code&gt;$x&lt;/code&gt;, believing that &lt;code&gt;$y&lt;/code&gt; is a numerically- equivalent value. This bug does not affect &lt;code&gt;uniqstr()&lt;/code&gt;, which will correctly observe that the two values stringify to different strings.</source>
          <target state="translated">&lt;code&gt;$y&lt;/code&gt; 가 수치 적으로 동등한 값 이라고 믿고 &lt;code&gt;$x&lt;/code&gt; 의 값만 인쇄 합니다. 이 버그는 &lt;code&gt;uniqstr()&lt;/code&gt; 영향을주지 않으며 두 값이 서로 다른 문자열로 문자열 화되는 것을 올바르게 관찰합니다.</target>
        </trans-unit>
        <trans-unit id="f950740e9c08c94cdc9c22017e9c8d9e11964004" translate="yes" xml:space="preserve">
          <source>Will produce something like this:</source>
          <target state="translated">다음과 같은 것을 생성 할 것입니다 :</target>
        </trans-unit>
        <trans-unit id="73c023c285973466729ee2bf21a0f578281a6002" translate="yes" xml:space="preserve">
          <source>Will return a list of two sockets created (read and write), or an empty list on failure.</source>
          <target state="translated">생성 된 두 개의 소켓 목록 (읽기 및 쓰기)을 반환하거나 실패시 빈 목록을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="b2e73c78b5d339922fd7fb53696709fc79fcc290" translate="yes" xml:space="preserve">
          <source>Will use &lt;a href=&quot;TAP::Harness::Archive&quot;&gt;TAP::Harness::Archive&lt;/a&gt; as the harness class, and save the TAP to &lt;code&gt;file.tgz&lt;/code&gt;</source>
          <target state="translated">사용 &lt;a href=&quot;TAP::Harness::Archive&quot;&gt;TAP :: 하네스 : 아카이브&lt;/a&gt; 하네스 클래스로, 그리고에 TAP 저장 &lt;code&gt;file.tgz&lt;/code&gt; 을</target>
        </trans-unit>
        <trans-unit id="db8fa98164c98267f0158f423a3da70d388112fe" translate="yes" xml:space="preserve">
          <source>Will use &lt;a href=&quot;http://search.cpan.org/perldoc/TAP::Harness::Archive&quot;&gt;TAP::Harness::Archive&lt;/a&gt; as the harness class, and save the TAP to &lt;code&gt;file.tgz&lt;/code&gt;</source>
          <target state="translated">사용 &lt;a href=&quot;http://search.cpan.org/perldoc/TAP::Harness::Archive&quot;&gt;TAP :: 하네스 : 아카이브&lt;/a&gt; 하네스 클래스로, 그리고에 TAP 저장 &lt;code&gt;file.tgz&lt;/code&gt; 을</target>
        </trans-unit>
        <trans-unit id="7b653c1a1342f29b6e1ca16ef44b1d14c98a11e3" translate="yes" xml:space="preserve">
          <source>Win32</source>
          <target state="translated">Win32</target>
        </trans-unit>
        <trans-unit id="193cb801459c22b68d471c2735c8916bade862e2" translate="yes" xml:space="preserve">
          <source>Win32 - Interfaces to some Win32 API Functions</source>
          <target state="translated">Win32-일부 Win32 API 함수에 대한 인터페이스</target>
        </trans-unit>
        <trans-unit id="d2fdadddae42eb18256ba3d6c7445968142a4fd2" translate="yes" xml:space="preserve">
          <source>Win32 CORE function stubs</source>
          <target state="translated">Win32 CORE 함수 스텁</target>
        </trans-unit>
        <trans-unit id="0cab5c56f7d1ce7bc278eb6ee5c4a8575346a7ef" translate="yes" xml:space="preserve">
          <source>Win32 implementation</source>
          <target state="translated">Win32 구현</target>
        </trans-unit>
        <trans-unit id="c331f9a552ce93a52bd3bbd4fbac9c58a662301b" translate="yes" xml:space="preserve">
          <source>Win32 support for Sys::Syslog</source>
          <target state="translated">Sys :: Syslog에 대한 Win32 지원</target>
        </trans-unit>
        <trans-unit id="263a800b140dc4fe3448979f4261e583bcee830e" translate="yes" xml:space="preserve">
          <source>Win32 users should use the real slash. If you really want to use backslashes, consider using Sarathy's File::DosGlob, which comes with the standard Perl distribution.</source>
          <target state="translated">Win32 사용자는 실제 슬래시를 사용해야합니다. 백 슬래시를 실제로 사용하려면 표준 Perl 배포판과 함께 제공되는 Sarathy의 File :: DosGlob 사용을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="6d0e1038c340ca3cf2b59ac852b5f2ef7407e5c9" translate="yes" xml:space="preserve">
          <source>Win32::AbortSystemShutdown(MACHINE)</source>
          <target state="translated">Win32::AbortSystemShutdown(MACHINE)</target>
        </trans-unit>
        <trans-unit id="6f12fa420b1205100cabb4570f237b3d345d86ca" translate="yes" xml:space="preserve">
          <source>Win32::BuildNumber()</source>
          <target state="translated">Win32::BuildNumber()</target>
        </trans-unit>
        <trans-unit id="99f20893b3ea998d83c35a43b1ddcaefd97d6b9f" translate="yes" xml:space="preserve">
          <source>Win32::CopyFile(FROM, TO, OVERWRITE)</source>
          <target state="translated">Win32::CopyFile(FROM, TO, OVERWRITE)</target>
        </trans-unit>
        <trans-unit id="d269bfa64c0a58bda1986a24d2c54a63190e288a" translate="yes" xml:space="preserve">
          <source>Win32::CreateDirectory(DIRECTORY)</source>
          <target state="translated">Win32::CreateDirectory(DIRECTORY)</target>
        </trans-unit>
        <trans-unit id="7a7983d24568164c28a76c5bb077686f88dad153" translate="yes" xml:space="preserve">
          <source>Win32::CreateFile(FILE)</source>
          <target state="translated">Win32::CreateFile(FILE)</target>
        </trans-unit>
        <trans-unit id="fa7c1f0bbed5b785d5607e1311dcb11968fd8fe9" translate="yes" xml:space="preserve">
          <source>Win32::DomainName()</source>
          <target state="translated">Win32::DomainName()</target>
        </trans-unit>
        <trans-unit id="1c453bb935414d8146aa602c45dd5159dab45ade" translate="yes" xml:space="preserve">
          <source>Win32::ExpandEnvironmentStrings(STRING)</source>
          <target state="translated">Win32::ExpandEnvironmentStrings(STRING)</target>
        </trans-unit>
        <trans-unit id="88134ad369f40cbd5ed8e6414b571501a615d721" translate="yes" xml:space="preserve">
          <source>Win32::FormatMessage(ERRORCODE)</source>
          <target state="translated">Win32::FormatMessage(ERRORCODE)</target>
        </trans-unit>
        <trans-unit id="02c33521b3e0cfb9be57585db645c4568be060cf" translate="yes" xml:space="preserve">
          <source>Win32::FreeLibrary(HANDLE)</source>
          <target state="translated">Win32::FreeLibrary(HANDLE)</target>
        </trans-unit>
        <trans-unit id="ec6d95684a511580632674e1e5dce99eca02ed2c" translate="yes" xml:space="preserve">
          <source>Win32::FsType()</source>
          <target state="translated">Win32::FsType()</target>
        </trans-unit>
        <trans-unit id="fdfbfe52059c529a42a7f79b351a29683dd786d2" translate="yes" xml:space="preserve">
          <source>Win32::GUI</source>
          <target state="translated">Win32::GUI</target>
        </trans-unit>
        <trans-unit id="cc575cb0ebbd64ea43f9c9ccc56237b0705f9732" translate="yes" xml:space="preserve">
          <source>Win32::GetACP()</source>
          <target state="translated">Win32::GetACP()</target>
        </trans-unit>
        <trans-unit id="7798f250e449938fcf7dadf70c029ad54f636245" translate="yes" xml:space="preserve">
          <source>Win32::GetANSIPathName(FILENAME)</source>
          <target state="translated">Win32::GetANSIPathName(FILENAME)</target>
        </trans-unit>
        <trans-unit id="58ac17861a87852820b146e725b1e3c3e23cbe3e" translate="yes" xml:space="preserve">
          <source>Win32::GetArchName()</source>
          <target state="translated">Win32::GetArchName()</target>
        </trans-unit>
        <trans-unit id="3834fcd21d4e7fa28d350d64b78639660bbeb2c1" translate="yes" xml:space="preserve">
          <source>Win32::GetChipName()</source>
          <target state="translated">Win32::GetChipName()</target>
        </trans-unit>
        <trans-unit id="202596ea6840cbe9f281840b431aa41aec8424c4" translate="yes" xml:space="preserve">
          <source>Win32::GetConsoleCP()</source>
          <target state="translated">Win32::GetConsoleCP()</target>
        </trans-unit>
        <trans-unit id="8aaff4afc4c9f3d83ba6558614d36b7f40e38e33" translate="yes" xml:space="preserve">
          <source>Win32::GetConsoleOutputCP()</source>
          <target state="translated">Win32::GetConsoleOutputCP()</target>
        </trans-unit>
        <trans-unit id="ebc6f60b70df25fd8c32e53de9a7c9ba577f15ee" translate="yes" xml:space="preserve">
          <source>Win32::GetCurrentProcessId()</source>
          <target state="translated">Win32::GetCurrentProcessId()</target>
        </trans-unit>
        <trans-unit id="41cb4ff89334195c85ec80a4293eee0fe84b1c77" translate="yes" xml:space="preserve">
          <source>Win32::GetCurrentThreadId()</source>
          <target state="translated">Win32::GetCurrentThreadId()</target>
        </trans-unit>
        <trans-unit id="06fb2ae0e34c762652f91cc4b24d288d543148dd" translate="yes" xml:space="preserve">
          <source>Win32::GetCwd()</source>
          <target state="translated">Win32::GetCwd()</target>
        </trans-unit>
        <trans-unit id="424bc0808437c0c40f8b8eca83c71486de0c2ce3" translate="yes" xml:space="preserve">
          <source>Win32::GetFileVersion(FILENAME)</source>
          <target state="translated">Win32::GetFileVersion(FILENAME)</target>
        </trans-unit>
        <trans-unit id="bd89672cc22e170bdb15759f5b2c202ee866d3af" translate="yes" xml:space="preserve">
          <source>Win32::GetFolderPath(FOLDER [, CREATE])</source>
          <target state="translated">Win32 :: GetFolderPath (폴더 [, 생성])</target>
        </trans-unit>
        <trans-unit id="f7750debc5964ef700caa1d205774c5c516e86b5" translate="yes" xml:space="preserve">
          <source>Win32::GetFullPathName(FILENAME)</source>
          <target state="translated">Win32::GetFullPathName(FILENAME)</target>
        </trans-unit>
        <trans-unit id="1779b4a74c4e9c74750b4883d1c3a13e7f082821" translate="yes" xml:space="preserve">
          <source>Win32::GetLastError()</source>
          <target state="translated">Win32::GetLastError()</target>
        </trans-unit>
        <trans-unit id="c1d2be25cd4c6103e621d159ba09f9b5f7b7f66d" translate="yes" xml:space="preserve">
          <source>Win32::GetLongPathName(PATHNAME)</source>
          <target state="translated">Win32::GetLongPathName(PATHNAME)</target>
        </trans-unit>
        <trans-unit id="9a5b08237dd1d9c044b42e330417a8ee6c2fddc5" translate="yes" xml:space="preserve">
          <source>Win32::GetNextAvailDrive()</source>
          <target state="translated">Win32::GetNextAvailDrive()</target>
        </trans-unit>
        <trans-unit id="424731cf281e1dda51d3e9681cc85bb2740bbe76" translate="yes" xml:space="preserve">
          <source>Win32::GetOEMCP()</source>
          <target state="translated">Win32::GetOEMCP()</target>
        </trans-unit>
        <trans-unit id="1015f265e18dde79b1939bf46d05753e1cb1fc0a" translate="yes" xml:space="preserve">
          <source>Win32::GetOSDisplayName()</source>
          <target state="translated">Win32::GetOSDisplayName()</target>
        </trans-unit>
        <trans-unit id="e9e643f122af1698a8771b07d042a8eb421add6b" translate="yes" xml:space="preserve">
          <source>Win32::GetOSName()</source>
          <target state="translated">Win32::GetOSName()</target>
        </trans-unit>
        <trans-unit id="9ac415285a2a80e417f87a22967bf20ef2c63935" translate="yes" xml:space="preserve">
          <source>Win32::GetOSVersion()</source>
          <target state="translated">Win32::GetOSVersion()</target>
        </trans-unit>
        <trans-unit id="bbb14f64d25ca5875dac81a570aa2578d64fe870" translate="yes" xml:space="preserve">
          <source>Win32::GetProcAddress(INSTANCE, PROCNAME)</source>
          <target state="translated">Win32 :: GetProcAddress (인스턴스, PROCNAME)</target>
        </trans-unit>
        <trans-unit id="0d4519c40934e76bc7c24e8acfe3fe14ba43d63f" translate="yes" xml:space="preserve">
          <source>Win32::GetProductInfo(OSMAJOR, OSMINOR, SPMAJOR, SPMINOR)</source>
          <target state="translated">Win32::GetProductInfo(OSMAJOR, OSMINOR, SPMAJOR, SPMINOR)</target>
        </trans-unit>
        <trans-unit id="976bea2f0bcf19569dea7f3dcd696ad17b85b2c9" translate="yes" xml:space="preserve">
          <source>Win32::GetShortPathName(PATHNAME)</source>
          <target state="translated">Win32::GetShortPathName(PATHNAME)</target>
        </trans-unit>
        <trans-unit id="85686486692a83787d94a67516a3d3724180155d" translate="yes" xml:space="preserve">
          <source>Win32::GetSystemMetrics(INDEX)</source>
          <target state="translated">Win32::GetSystemMetrics(INDEX)</target>
        </trans-unit>
        <trans-unit id="da2531353eddaf6094a844bf9d9cb759ae2af1e8" translate="yes" xml:space="preserve">
          <source>Win32::GetTickCount()</source>
          <target state="translated">Win32::GetTickCount()</target>
        </trans-unit>
        <trans-unit id="ae35ac71f2f974fbd4820718cb015468050c4f6c" translate="yes" xml:space="preserve">
          <source>Win32::GuidGen()</source>
          <target state="translated">Win32::GuidGen()</target>
        </trans-unit>
        <trans-unit id="6c1bb229532a2f942fc09792beca570bb3feca1b" translate="yes" xml:space="preserve">
          <source>Win32::InitiateSystemShutdown</source>
          <target state="translated">Win32::InitiateSystemShutdown</target>
        </trans-unit>
        <trans-unit id="f9fa2b44699da87d011d8d62354503f774420ab1" translate="yes" xml:space="preserve">
          <source>Win32::IsAdminUser()</source>
          <target state="translated">Win32::IsAdminUser()</target>
        </trans-unit>
        <trans-unit id="fe185f7f6aa0888454156f6b1dd0647b97f1c985" translate="yes" xml:space="preserve">
          <source>Win32::IsWin95()</source>
          <target state="translated">Win32::IsWin95()</target>
        </trans-unit>
        <trans-unit id="1f8c102705f38e11ded9cb1693b6ba04ed8d2aac" translate="yes" xml:space="preserve">
          <source>Win32::IsWinNT()</source>
          <target state="translated">Win32::IsWinNT()</target>
        </trans-unit>
        <trans-unit id="75e8f5dee14a6d1c4d34f99cde2cd05959a202c6" translate="yes" xml:space="preserve">
          <source>Win32::LoadLibrary(LIBNAME)</source>
          <target state="translated">Win32::LoadLibrary(LIBNAME)</target>
        </trans-unit>
        <trans-unit id="33e6daf26026220d0161fea28893d1e652b68f17" translate="yes" xml:space="preserve">
          <source>Win32::LoginName()</source>
          <target state="translated">Win32::LoginName()</target>
        </trans-unit>
        <trans-unit id="b7203bf8251626a9d020ee5f4922ecd6ff013788" translate="yes" xml:space="preserve">
          <source>Win32::LookupAccountName(SYSTEM, ACCOUNT, DOMAIN, SID, SIDTYPE)</source>
          <target state="translated">Win32::LookupAccountName(SYSTEM, ACCOUNT, DOMAIN, SID, SIDTYPE)</target>
        </trans-unit>
        <trans-unit id="e02105130675ffb73c863f2651d7886f32ce699c" translate="yes" xml:space="preserve">
          <source>Win32::LookupAccountSID(SYSTEM, SID, ACCOUNT, DOMAIN, SIDTYPE)</source>
          <target state="translated">Win32::LookupAccountSID(SYSTEM, SID, ACCOUNT, DOMAIN, SIDTYPE)</target>
        </trans-unit>
        <trans-unit id="c0b3757407e5968fe8497224d610a6b05e0fb867" translate="yes" xml:space="preserve">
          <source>Win32::MsgBox(MESSAGE [, FLAGS [, TITLE]])</source>
          <target state="translated">Win32::MsgBox(MESSAGE [, FLAGS [, TITLE]])</target>
        </trans-unit>
        <trans-unit id="e3c6c757d1a1e7f6e540ff3306434ee9703babbe" translate="yes" xml:space="preserve">
          <source>Win32::NodeName()</source>
          <target state="translated">Win32::NodeName()</target>
        </trans-unit>
        <trans-unit id="2712cf0c3d41deb65f7212a8f31b3f82a4ae6a9e" translate="yes" xml:space="preserve">
          <source>Win32::OutputDebugString(STRING)</source>
          <target state="translated">Win32::OutputDebugString(STRING)</target>
        </trans-unit>
        <trans-unit id="75ef631d3c7ea178f0c26bc47d12483cd8c3ea5d" translate="yes" xml:space="preserve">
          <source>Win32::RegisterServer(LIBRARYNAME)</source>
          <target state="translated">Win32::RegisterServer(LIBRARYNAME)</target>
        </trans-unit>
        <trans-unit id="ce0d098c41c01fd9b4d42374933b719c4874605c" translate="yes" xml:space="preserve">
          <source>Win32::SetChildShowWindow(SHOWWINDOW)</source>
          <target state="translated">Win32::SetChildShowWindow(SHOWWINDOW)</target>
        </trans-unit>
        <trans-unit id="6ec2ec156820380d471d8b8902107f69d0c48aac" translate="yes" xml:space="preserve">
          <source>Win32::SetConsoleCP(ID)</source>
          <target state="translated">Win32::SetConsoleCP(ID)</target>
        </trans-unit>
        <trans-unit id="d56fdac00362d0844cebe19c2fbea7797556a862" translate="yes" xml:space="preserve">
          <source>Win32::SetConsoleOutputCP(ID)</source>
          <target state="translated">Win32::SetConsoleOutputCP(ID)</target>
        </trans-unit>
        <trans-unit id="8ff2683659839e8f5dba46b5d4a8ac3aa4a62e14" translate="yes" xml:space="preserve">
          <source>Win32::SetCwd(NEWDIRECTORY)</source>
          <target state="translated">Win32::SetCwd(NEWDIRECTORY)</target>
        </trans-unit>
        <trans-unit id="721ad14df20038a886cdbbad6ec515e2dfd8ef41" translate="yes" xml:space="preserve">
          <source>Win32::SetLastError(ERROR)</source>
          <target state="translated">Win32::SetLastError(ERROR)</target>
        </trans-unit>
        <trans-unit id="70d34dd79a3d13ab005b5f95a3a341dc634b545c" translate="yes" xml:space="preserve">
          <source>Win32::Sleep(TIME)</source>
          <target state="translated">Win32::Sleep(TIME)</target>
        </trans-unit>
        <trans-unit id="0bd78719dddc468413b0b8cae64f7604c9b0760f" translate="yes" xml:space="preserve">
          <source>Win32::Spawn(COMMAND, ARGS, PID)</source>
          <target state="translated">Win32::Spawn(COMMAND, ARGS, PID)</target>
        </trans-unit>
        <trans-unit id="55cf1f14b3a9fb47a3d099c943c81a86f3bab76e" translate="yes" xml:space="preserve">
          <source>Win32::UnregisterServer(LIBRARYNAME)</source>
          <target state="translated">Win32::UnregisterServer(LIBRARYNAME)</target>
        </trans-unit>
        <trans-unit id="aa21f521370d6a588509094452635266c4468ce9" translate="yes" xml:space="preserve">
          <source>Win32API::File</source>
          <target state="translated">Win32API::File</target>
        </trans-unit>
        <trans-unit id="88c0b190dbad57a17cc677f51fa9c1ba74db87d0" translate="yes" xml:space="preserve">
          <source>Win32API::File - Low-level access to Win32 system API calls for files/dirs.</source>
          <target state="translated">Win32API :: File-파일 / 디렉터리에 대한 Win32 시스템 API 호출에 대한 저수준 액세스.</target>
        </trans-unit>
        <trans-unit id="b0a0edd9f797c147e0eca61b93c9942a6aada686" translate="yes" xml:space="preserve">
          <source>Win32CORE</source>
          <target state="translated">Win32CORE</target>
        </trans-unit>
        <trans-unit id="674b29c781e27ee904b0a31e2bca19f160dacd50" translate="yes" xml:space="preserve">
          <source>Win32CORE - Win32 CORE function stubs</source>
          <target state="translated">Win32CORE-Win32 CORE 함수 스텁</target>
        </trans-unit>
        <trans-unit id="823301860ab873ab455e9a7adb1aa457e7019586" translate="yes" xml:space="preserve">
          <source>Win32CORE was created to provide on cygwin those Win32:: functions that for regular win32 builds were provided by default in perl. In cygwin perl releases prior to 5.8.6, this module was standalone and had to be explicitly used. In 5.8.6 and later, it was statically linked into cygwin perl so this would no longer be necessary.</source>
          <target state="translated">Win32CORE는 cygwin에서 일반 win32 빌드를 위해 기본적으로 제공되는 Win32 :: 기능을 제공하기 위해 만들어졌습니다. 5.8.6 이전의 cygwin perl 릴리스에서이 모듈은 독립형이었으며 명시 적으로 사용해야했습니다. 5.8.6 이상에서는 cygwin perl에 정적으로 링크되었으므로 더 이상 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a64d38eb25949cf47b772e208780c5548dc84962" translate="yes" xml:space="preserve">
          <source>Win95 and Win98 and WinME are collectively Win9x and Win32</source>
          <target state="translated">Win95 및 Win98 및 WinME는 총체적으로 Win9x 및 Win32입니다.</target>
        </trans-unit>
        <trans-unit id="ea8db18a138027d52bc49a4789f983c73ef0f94f" translate="yes" xml:space="preserve">
          <source>Win95/NT</source>
          <target state="translated">Win95/NT</target>
        </trans-unit>
        <trans-unit id="38d123584917edd3d65a1c41ab99a9088beb8b64" translate="yes" xml:space="preserve">
          <source>Win98 chokes on things like Encode if we set the max length to nmake's max of 2K. So we go for a more conservative value of 1K.</source>
          <target state="translated">Win98을 최대 길이를 nmake의 최대 2K로 설정하면 Encode와 같은 것들에 질식합니다. 보다 보수적 인 1K 가치를 추구합니다.</target>
        </trans-unit>
        <trans-unit id="7e7afec2ee076635c5bdb3c20b397b563733e6cf" translate="yes" xml:space="preserve">
          <source>Win9x and &lt;code&gt;d_eofnblk&lt;/code&gt;</source>
          <target state="translated">Win9x 및 &lt;code&gt;d_eofnblk&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="dcb6e2235a0d088883e2901a983ef0e7377f83c0" translate="yes" xml:space="preserve">
          <source>Win9x can not &lt;code&gt;&lt;a href=&quot;functions/rename&quot;&gt;rename()&lt;/a&gt;&lt;/code&gt; an open file (although WinNT can).</source>
          <target state="translated">Win9x는 열린 파일의 &lt;code&gt;&lt;a href=&quot;functions/rename&quot;&gt;rename()&lt;/a&gt;&lt;/code&gt; 수 없습니다 ( ).</target>
        </trans-unit>
        <trans-unit id="de40f5b5690a0bb23e1bf760363cb6a5e8443821" translate="yes" xml:space="preserve">
          <source>Win9x can not &lt;code&gt;rename()&lt;/code&gt; an open file (although WinNT can).</source>
          <target state="translated">Win9x는 열린 파일의 &lt;code&gt;rename()&lt;/code&gt; 수 없습니다 (WinNT는 가능하지만).</target>
        </trans-unit>
        <trans-unit id="1865487f835d74c1a32dc51f7e3fd10d2bb1c87c" translate="yes" xml:space="preserve">
          <source>Win9x does not correctly report &lt;code&gt;EOF&lt;/code&gt; with a non-blocking read on a closed pipe. You will see the following messages:</source>
          <target state="translated">Win9x는 닫힌 파이프에서 비 차단 판독 값으로 &lt;code&gt;EOF&lt;/code&gt; 를 올바르게보고하지 않습니다 . 다음과 같은 메시지가 나타납니다.</target>
        </trans-unit>
        <trans-unit id="468c4f1d38914eeba7915aa856cfac9060a7a5fe" translate="yes" xml:space="preserve">
          <source>Win9x support was added in 5.6 (Benjamin Stuhl).</source>
          <target state="translated">Win9x 지원은 5.6 (Benjamin Stuhl)에 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="38c0fc63bcb91fe3116f8590745de1626f0dd16a" translate="yes" xml:space="preserve">
          <source>WinDisk.exe</source>
          <target state="translated">WinDisk.exe</target>
        </trans-unit>
        <trans-unit id="c816e89ffa10335823ff2ffbfd171adf35cada45" translate="yes" xml:space="preserve">
          <source>WinError.h</source>
          <target state="translated">WinError.h</target>
        </trans-unit>
        <trans-unit id="26d9c28d789c254f71ea99a3463b99a7ccc2f4fa" translate="yes" xml:space="preserve">
          <source>Windows</source>
          <target state="translated">Windows</target>
        </trans-unit>
        <trans-unit id="bf4f5bc6b10d099fc4024cb19c3bd9cf757e522e" translate="yes" xml:space="preserve">
          <source>Windows .NET Server supports the LLP64 data model on the Intel Itanium architecture.</source>
          <target state="translated">Windows .NET 서버는 Intel Itanium 아키텍처에서 LLP64 데이터 모델을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="f6a28970a521e035e5e254c78ec61c1026703f9b" translate="yes" xml:space="preserve">
          <source>Windows 2000</source>
          <target state="translated">Windows 2000</target>
        </trans-unit>
        <trans-unit id="94cada20ad68e1ffe3678826da4a09dc6377e803" translate="yes" xml:space="preserve">
          <source>Windows 7</source>
          <target state="translated">윈도우 7</target>
        </trans-unit>
        <trans-unit id="cca1d54534e769c83a6c85f5e6241a2523f2592c" translate="yes" xml:space="preserve">
          <source>Windows 95</source>
          <target state="translated">Windows 95</target>
        </trans-unit>
        <trans-unit id="bdae4500dcdb3f86e38c3347c9fe418dd6deff32" translate="yes" xml:space="preserve">
          <source>Windows 98</source>
          <target state="translated">Windows 98</target>
        </trans-unit>
        <trans-unit id="6578fbd48a0229e823dac38105b1950bd25957b3" translate="yes" xml:space="preserve">
          <source>Windows Event Log, &lt;a href=&quot;http://msdn.microsoft.com/library/default.asp?url=/library/en-us/wes/wes/windows_event_log.asp&quot;&gt;http://msdn.microsoft.com/library/default.asp?url=/library/en-us/wes/wes/windows_event_log.asp&lt;/a&gt;</source>
          <target state="translated">Windows 이벤트 로그, &lt;a href=&quot;http://msdn.microsoft.com/library/default.asp?url=/library/en-us/wes/wes/windows_event_log.asp&quot;&gt;http://msdn.microsoft.com/library/default.asp?url=/library/en-us/wes/wes/windows_event_log.asp&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="08fe8b7597a09dd3a844091de7163268dfe54cc6" translate="yes" xml:space="preserve">
          <source>Windows ME</source>
          <target state="translated">Windows ME</target>
        </trans-unit>
        <trans-unit id="83dc416748ad54d778d6b19e9f7fde1b7af83339" translate="yes" xml:space="preserve">
          <source>Windows NT4</source>
          <target state="translated">Windows NT4</target>
        </trans-unit>
        <trans-unit id="7d80809b5e98653b28bad4f8f5c33d52237b9226" translate="yes" xml:space="preserve">
          <source>Windows Server 2003</source>
          <target state="translated">윈도우 서버 2003</target>
        </trans-unit>
        <trans-unit id="2504575346cece1887f998d2d76408a38af5141e" translate="yes" xml:space="preserve">
          <source>Windows Server 2008</source>
          <target state="translated">윈도우 서버 2008</target>
        </trans-unit>
        <trans-unit id="7dc44c44b7a030798f3e511dc741ab9400f590ae" translate="yes" xml:space="preserve">
          <source>Windows Vista</source>
          <target state="translated">Windows Vista</target>
        </trans-unit>
        <trans-unit id="76f20bccfe3512339ad2cea01fc1c7809e7d3d15" translate="yes" xml:space="preserve">
          <source>Windows XP</source>
          <target state="translated">윈도우 XP</target>
        </trans-unit>
        <trans-unit id="3c2af17044bb2c5164875672fc2938f1968ed3a3" translate="yes" xml:space="preserve">
          <source>Windows has basically 2 sets of APIs. A wide API (based on passing UTF-16 strings) and a byte based API based a character set called ANSI. The regular Perl interfaces to the OS currently only uses the ANSI APIs. Unfortunately ANSI is not a single character set.</source>
          <target state="translated">Windows에는 기본적으로 2 개의 API 세트가 있습니다. 광범위한 API (UTF-16 문자열 전달 기반) 및 ANSI라는 문자 집합 기반의 바이트 기반 API. OS에 대한 일반 Perl 인터페이스는 현재 ANSI API 만 사용합니다. 불행히도 ANSI는 단일 문자 집합이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="32384d85bc892c2cec1cd8f151b8007b98fa13ff" translate="yes" xml:space="preserve">
          <source>Windows is Win32.</source>
          <target state="translated">Windows는 Win32입니다.</target>
        </trans-unit>
        <trans-unit id="15932d7727c0d0850847ee4a3aea588d05fd6a45" translate="yes" xml:space="preserve">
          <source>Windows is Windows telnet, Cygwin SSH is the OpenSSH implementation under Cygwin on Windows NT, and Mac Terminal is the Terminal application in Mac OS X. Where the entry is other than yes or no, that emulator displays the given attribute as something else instead. Note that on an aixterm, clear doesn't reset colors; you have to explicitly set the colors back to what you want. More entries in this table are welcome.</source>
          <target state="translated">Windows는 Windows 텔넷이고 Cygwin SSH는 Windows NT의 Cygwin에서 OpenSSH 구현이고 Mac Terminal은 Mac OS X의 터미널 응용 프로그램입니다. 항목이 예 또는 아니오가 아닌 경우 해당 에뮬레이터는 지정된 속성을 다른 것으로 표시합니다. aixterm에서 clear는 색상을 재설정하지 않습니다. 원하는 색상을 명시 적으로 다시 설정해야합니다. 이 표에서 더 많은 항목을 환영합니다.</target>
        </trans-unit>
        <trans-unit id="a8033e193c1409f4bd5db90d9880ca01290431d4" translate="yes" xml:space="preserve">
          <source>Windows systems also operate with another byte based character set. It's called the OEM code page. This is the encoding that the Console takes as input and output. It's common for the OEM code page to differ from the ANSI code page.</source>
          <target state="translated">Windows 시스템은 다른 바이트 기반 문자 집합으로도 작동합니다. 이를 OEM 코드 페이지라고합니다. 이것은 콘솔이 입력 및 출력으로 사용하는 인코딩입니다. 일반적으로 OEM 코드 페이지는 ANSI 코드 페이지와 다릅니다.</target>
        </trans-unit>
        <trans-unit id="3093bbeb765cee856b62debb98821ba39f27fcc6" translate="yes" xml:space="preserve">
          <source>Windows users who are using &lt;code&gt;nmake&lt;/code&gt; should note that due to a bug in &lt;code&gt;nmake&lt;/code&gt; , when specifying &lt;code&gt;TEST_FILES&lt;/code&gt; you must use back-slashes instead of forward-slashes.</source>
          <target state="translated">사용중인 Windows 사용자 &lt;code&gt;nmake&lt;/code&gt; 때문에 버그에주의해야 &lt;code&gt;nmake&lt;/code&gt; 를 지정하는 경우, &lt;code&gt;TEST_FILES&lt;/code&gt; 당신이 백 슬래시 대신 앞으로 슬래시를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="db6ab0003d513d80fd8056684fe349106fcdab74" translate="yes" xml:space="preserve">
          <source>Windows users who are using &lt;code&gt;nmake&lt;/code&gt; should note that due to a bug in &lt;code&gt;nmake&lt;/code&gt;, when specifying &lt;code&gt;TEST_FILES&lt;/code&gt; you must use back-slashes instead of forward-slashes.</source>
          <target state="translated">사용중인 Windows 사용자 &lt;code&gt;nmake&lt;/code&gt; 때문에 버그에주의해야 &lt;code&gt;nmake&lt;/code&gt; 를 지정하는 경우, &lt;code&gt;TEST_FILES&lt;/code&gt; 당신이 백 슬래시 대신 앞으로 슬래시를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="968c4aaba72bd2883444cce7386789debafb547b" translate="yes" xml:space="preserve">
          <source>Windows-specific tests.</source>
          <target state="translated">Windows 별 테스트</target>
        </trans-unit>
        <trans-unit id="52b2489ffd6eceb9bd13b6a8f90eac373db50b35" translate="yes" xml:space="preserve">
          <source>Wisconsin</source>
          <target state="translated">Wisconsin</target>
        </trans-unit>
        <trans-unit id="564f8c6e76fbd512be2e38dabdfdd61550d0c3cc" translate="yes" xml:space="preserve">
          <source>With</source>
          <target state="translated">With</target>
        </trans-unit>
        <trans-unit id="a51957fd22adb3afd697fb8ab328d3922f130d4b" translate="yes" xml:space="preserve">
          <source>With $k chosen carefully, and likely to be a small number like 1 or 2. In theory the larger the bucket array the less chance of collision.</source>
          <target state="translated">$ k를 신중하게 선택하고 1 또는 2와 같은 작은 숫자 일 수 있습니다. 이론적으로 버킷 배열이 클수록 충돌 가능성이 줄어 듭니다.</target>
        </trans-unit>
        <trans-unit id="8a3fad0711b1021538f5283d00839025799b6dad" translate="yes" xml:space="preserve">
          <source>With 1 causes this module to use Time::HiRes module, allowing milliseconds to be returned by subsequent calls to ping().</source>
          <target state="translated">1을 사용하면이 모듈이 Time :: HiRes 모듈을 사용하여 ping ()에 대한 후속 호출에서 밀리 초를 반환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6185bdea28758a42fc320398e067ab2654617d96" translate="yes" xml:space="preserve">
          <source>With 5005threads, you could also &lt;code&gt;&lt;a href=&quot;functions/lock&quot;&gt;lock&lt;/a&gt;&lt;/code&gt; a sub such that any calls to that sub from another thread would block until the lock was released.</source>
          <target state="translated">5005threads으로, 당신은 또한 수 &lt;code&gt;&lt;a href=&quot;functions/lock&quot;&gt;lock&lt;/a&gt;&lt;/code&gt; 잠금이 해제 될 때까지 다른 스레드에서 해당 하위에 대한 호출을 차단하는 것이라고 하위는.</target>
        </trans-unit>
        <trans-unit id="a8d11fe55a26fb99c192c4c169dd330b2ce5c5d6" translate="yes" xml:space="preserve">
          <source>With 5005threads, you could also &lt;code&gt;lock&lt;/code&gt; a sub such that any calls to that sub from another thread would block until the lock was released.</source>
          <target state="translated">5005threads으로, 당신은 또한 수 &lt;code&gt;lock&lt;/code&gt; 잠금이 해제 될 때까지 다른 스레드에서 해당 하위에 대한 호출을 차단하는 것이라고 하위는.</target>
        </trans-unit>
        <trans-unit id="c2c741524004c7f8613fe0df95f2304ad27bfaf6" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;/a&lt;/code&gt; , one can write &lt;code&gt;\d&lt;/code&gt; with confidence that it will only match ASCII characters, and should the need arise to match beyond ASCII, you can instead use &lt;code&gt;\p{Digit}&lt;/code&gt; (or &lt;code&gt;\p{Word}&lt;/code&gt; for &lt;code&gt;\w&lt;/code&gt; ). There are similar &lt;code&gt;\p{...}&lt;/code&gt; constructs that can match beyond ASCII both white space (see &lt;a href=&quot;perlrecharclass#Whitespace&quot;&gt;Whitespace in perlrecharclass&lt;/a&gt;), and Posix classes (see &lt;a href=&quot;perlrecharclass#POSIX-Character-Classes&quot;&gt;POSIX Character Classes in perlrecharclass&lt;/a&gt;). Thus, this modifier doesn't mean you can't use Unicode, it means that to get Unicode matching you must explicitly use a construct (&lt;code&gt;\p{}&lt;/code&gt; , &lt;code&gt;\P{}&lt;/code&gt; ) that signals Unicode.</source>
          <target state="translated">&lt;code&gt;/a&lt;/code&gt; 를 사용하면 ASCII 문자와 만 일치한다는 확신을 가지고 &lt;code&gt;\d&lt;/code&gt; 를 작성할 수 있으며 , ASCII 이외의 문자와 일치해야하는 경우 &lt;code&gt;\p{Digit}&lt;/code&gt; (또는 &lt;code&gt;\w&lt;/code&gt; &lt;code&gt;\p{Word}&lt;/code&gt; \ w {}) 를 대신 사용할 수 있습니다 . ASCII 이외의 &lt;a href=&quot;perlrecharclass#Whitespace&quot;&gt;공백 (perlrecharclass의 공백&lt;/a&gt; 참조 ) 및 Posix 클래스 ( &lt;a href=&quot;perlrecharclass#POSIX-Character-Classes&quot;&gt;perlrecharclass의 POSIX 문자 클래스&lt;/a&gt; 참조)를 모두 만족할 수 있는 유사한 &lt;code&gt;\p{...}&lt;/code&gt; 구문이 있습니다 . 따라서이 수정자는 유니 코드를 사용할 수 없다는 것을 의미하지는 않습니다. 즉, 유니 코드 일치를 가져 오려면 유니 코드를 알리는 구문 ( &lt;code&gt;\p{}&lt;/code&gt; , &lt;code&gt;\P{}&lt;/code&gt; )을 명시 적으로 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="d8c642a61a993b2822d327b2f6d2aa5b5cdb0c33" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;/a&lt;/code&gt;, one can write &lt;code&gt;\d&lt;/code&gt; with confidence that it will only match ASCII characters, and should the need arise to match beyond ASCII, you can instead use &lt;code&gt;\p{Digit}&lt;/code&gt; (or &lt;code&gt;\p{Word}&lt;/code&gt; for &lt;code&gt;\w&lt;/code&gt;). There are similar &lt;code&gt;\p{...}&lt;/code&gt; constructs that can match beyond ASCII both white space (see &lt;a href=&quot;perlrecharclass#Whitespace&quot;&gt;&quot;Whitespace&quot; in perlrecharclass&lt;/a&gt;), and Posix classes (see &lt;a href=&quot;perlrecharclass#POSIX-Character-Classes&quot;&gt;&quot;POSIX Character Classes&quot; in perlrecharclass&lt;/a&gt;). Thus, this modifier doesn't mean you can't use Unicode, it means that to get Unicode matching you must explicitly use a construct (&lt;code&gt;\p{}&lt;/code&gt;, &lt;code&gt;\P{}&lt;/code&gt;) that signals Unicode.</source>
          <target state="translated">으로 &lt;code&gt;/a&lt;/code&gt; , 하나는 쓸 수 &lt;code&gt;\d&lt;/code&gt; 대신 사용할 수 있습니다, 그것은 ASCII 문자 만 일치 것이라는 확신으로, 그리고 ASCII 이상 일치하도록 발생할 필요합니다 &lt;code&gt;\p{Digit}&lt;/code&gt; (또는 &lt;code&gt;\p{Word}&lt;/code&gt; 에 대한 &lt;code&gt;\w&lt;/code&gt; ). ASCII 이외의 공백 ( &lt;a href=&quot;perlrecharclass#Whitespace&quot;&gt;perlrecharclass의 &quot;공백&quot;&lt;/a&gt; 참조 ) 및 Posix 클래스 ( &lt;a href=&quot;perlrecharclass#POSIX-Character-Classes&quot;&gt;perlrecharclass의 &quot;POSIX 문자 클래스&quot;&lt;/a&gt; 참조)와 일치 할 수 있는 유사한 &lt;code&gt;\p{...}&lt;/code&gt; 구문이 있습니다 . 따라서이 수정자는 유니 코드를 사용할 수 없음을 의미하는 것이 아니라 유니 코드 일치를 얻으려면 유니 코드 를 신호 하는 구문 ( &lt;code&gt;\p{}&lt;/code&gt; , &lt;code&gt;\P{}&lt;/code&gt; )을 명시 적으로 사용해야 함을 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="5132b5fe6c695f29613169cf8ff9a2c949197d0f" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt;, you get around this by using a block and an expression where you would place the filehandle:</source>
          <target state="translated">함께 &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; 와 &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; , 당신은 블록 및 파일 핸들을 배치 할 표현식을 사용하여이 문제를 해결 얻을 :</target>
        </trans-unit>
        <trans-unit id="487baf6c93470e20c12688608403c20fbdb8e8f3" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system()&lt;/a&gt;&lt;/code&gt;, both STDOUT and STDERR will go the same place as the script's STDOUT and STDERR, unless the &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system()&lt;/a&gt;&lt;/code&gt; command redirects them. Backticks and &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; read &lt;b&gt;only&lt;/b&gt; the STDOUT of your command.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system()&lt;/a&gt;&lt;/code&gt; 사용하면 system ( &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system()&lt;/a&gt;&lt;/code&gt; 명령이 리디렉션 하지 않는 한 STDOUT 및 STDERR이 스크립트의 STDOUT 및 STDERR과 같은 위치로 이동합니다. 백틱 및 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; 은 명령의 STDOUT &lt;b&gt;만&lt;/b&gt; 읽습니다 .</target>
        </trans-unit>
        <trans-unit id="e6ba4c518cc989a85f1859e34fe5315e0670671f" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;Class::Tiny&lt;/code&gt; , all accessors are read-write. It generates a constructor for you, as well as the accessors you define.</source>
          <target state="translated">함께 &lt;code&gt;Class::Tiny&lt;/code&gt; 모든 접근은 읽기 - 쓰기를하고 있습니다. 정의한 접근 자뿐만 아니라 생성자를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="30133336b461bf131bf440d3b8937ae3c7286e54" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;Class::Tiny&lt;/code&gt;, all accessors are read-write. It generates a constructor for you, as well as the accessors you define.</source>
          <target state="translated">함께 &lt;code&gt;Class::Tiny&lt;/code&gt; 모든 접근은 읽기 - 쓰기를하고 있습니다. 생성자뿐만 아니라 사용자가 정의한 접근자를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="c6b55e3069c1cf271c20c8804a7b8c0dbfbb1f17" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;ignore_case&lt;/code&gt; , option specifications for options that only differ in case, e.g., &lt;code&gt;&quot;foo&quot;&lt;/code&gt; and &lt;code&gt;&quot;Foo&quot;&lt;/code&gt; , will be flagged as duplicates.</source>
          <target state="translated">&lt;code&gt;ignore_case&lt;/code&gt; 를 사용하면 &lt;code&gt;&quot;foo&quot;&lt;/code&gt; 및 &lt;code&gt;&quot;Foo&quot;&lt;/code&gt; 와 같이 경우에만 다른 옵션의 옵션 스펙이 중복으로 플래그 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="912c5dbb25de4eb33c760222cb62f248afb75050" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;ignore_case&lt;/code&gt;, option specifications for options that only differ in case, e.g., &lt;code&gt;&quot;foo&quot;&lt;/code&gt; and &lt;code&gt;&quot;Foo&quot;&lt;/code&gt;, will be flagged as duplicates.</source>
          <target state="translated">&lt;code&gt;ignore_case&lt;/code&gt; 를 사용하면 &lt;code&gt;&quot;foo&quot;&lt;/code&gt; 및 &lt;code&gt;&quot;Foo&quot;&lt;/code&gt; 와 같이 대소 문자 만 다른 옵션에 대한 옵션 사양이 중복으로 플래그 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="2fffc08f49ded4afbdfb2c00f9dcdbc7da340301" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;latin1&lt;/code&gt; (or &lt;code&gt;ascii&lt;/code&gt;) enabled, &lt;code&gt;encode&lt;/code&gt; will escape characters with ordinal values &amp;gt; 255 (&amp;gt; 127 with &lt;code&gt;ascii&lt;/code&gt;) and encode the remaining characters as specified by the &lt;code&gt;utf8&lt;/code&gt; flag.</source>
          <target state="translated">함께 &lt;code&gt;latin1&lt;/code&gt; (또는 &lt;code&gt;ascii&lt;/code&gt; ) 활성화, &lt;code&gt;encode&lt;/code&gt; &amp;gt; 255 (&amp;gt; 127 서수 값 문자를 탈출한다 &lt;code&gt;ascii&lt;/code&gt; ) 및 지정된대로 나머지 문자 인코딩 &lt;code&gt;utf8&lt;/code&gt; 플래그.</target>
        </trans-unit>
        <trans-unit id="ee71de233ae712db3a62ad0a5f3c845bcb07690d" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;pass_through&lt;/code&gt; anything that is unknown, ambiguous or supplied with an invalid option will not be flagged as an error. Instead the unknown option(s) will be passed to the catchall &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; if present, otherwise through to &lt;code&gt;@ARGV&lt;/code&gt; . This makes it possible to write wrapper scripts that process only part of the user supplied command line arguments, and pass the remaining options to some other program.</source>
          <target state="translated">&lt;code&gt;pass_through&lt;/code&gt; 를 통해 알 수 없거나 모호하거나 잘못된 옵션이 제공되는 것은 오류로 표시되지 않습니다. 대신 알 수없는 옵션은 존재하는 경우 catchall &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; 으로 전달되고 그렇지 않으면 &lt;code&gt;@ARGV&lt;/code&gt; 를 통해 전달됩니다 . 이를 통해 사용자 제공 명령 행 인수의 일부만 처리하고 나머지 옵션을 다른 프로그램에 전달하는 랩퍼 스크립트를 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f4663d47991fc6ad8f19a68b7dbd43ec5db93e1f" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;pass_through&lt;/code&gt; anything that is unknown, ambiguous or supplied with an invalid option will not be flagged as an error. Instead the unknown option(s) will be passed to the catchall &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; if present, otherwise through to &lt;code&gt;@ARGV&lt;/code&gt;. This makes it possible to write wrapper scripts that process only part of the user supplied command line arguments, and pass the remaining options to some other program.</source>
          <target state="translated">&lt;code&gt;pass_through&lt;/code&gt; 를 사용하면 알 수 없거나 모호하거나 잘못된 옵션이 제공된 것은 오류로 플래그가 지정되지 않습니다. 대신 알 수없는 옵션이 있으면 catchall &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; 로 전달되고 그렇지 않으면 &lt;code&gt;@ARGV&lt;/code&gt; 로 전달 됩니다. 이렇게하면 사용자가 제공 한 명령 줄 인수의 일부만 처리하고 나머지 옵션을 다른 프로그램에 전달하는 래퍼 스크립트를 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e21e85e4f08ba1ed663f7825a392d047ce118ae8" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;print&lt;/code&gt; and &lt;code&gt;printf&lt;/code&gt;, you get around this by using a block and an expression where you would place the filehandle:</source>
          <target state="translated">함께 &lt;code&gt;print&lt;/code&gt; 와 &lt;code&gt;printf&lt;/code&gt; , 당신은 블록 및 파일 핸들을 배치 할 표현식을 사용하여이 문제를 해결 얻을 :</target>
        </trans-unit>
        <trans-unit id="161b6ff35bc50314a49d188535255f199fcc9bb0" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;system()&lt;/code&gt;, both STDOUT and STDERR will go the same place as the script's STDOUT and STDERR, unless the &lt;code&gt;system()&lt;/code&gt; command redirects them. Backticks and &lt;code&gt;open()&lt;/code&gt; read &lt;b&gt;only&lt;/b&gt; the STDOUT of your command.</source>
          <target state="translated">&lt;code&gt;system()&lt;/code&gt; 사용하면 system ( &lt;code&gt;system()&lt;/code&gt; 명령이 리디렉션 하지 않는 한 STDOUT 및 STDERR 모두 스크립트의 STDOUT 및 STDERR과 동일한 위치로 이동합니다. 백틱과 &lt;code&gt;open()&lt;/code&gt; 은 명령의 STDOUT &lt;b&gt;만&lt;/b&gt; 읽습니다 .</target>
        </trans-unit>
        <trans-unit id="fb95ac886e1d528b24773e6c70b3ed1c1613335e" translate="yes" xml:space="preserve">
          <source>With EXPR, it returns some extra information that the debugger uses to print a stack trace. The value of EXPR indicates how many call frames to go back before the current one.</source>
          <target state="translated">EXPR을 사용하면 디버거가 스택 추적을 인쇄하는 데 사용하는 추가 정보를 반환합니다. EXPR의 값은 현재 호출 프레임으로 돌아가는 콜 프레임 수를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="a55096d08b5ad2fe54fd898185c93fb2c1c7dfdd" translate="yes" xml:space="preserve">
          <source>With Mac OS X 10.4 &quot;Tiger&quot; and newer, there is almost no performance penalty for non-prebound libraries. Earlier releases will suffer a greater load time than either the static library, or Apple's pre-bound dynamic library.</source>
          <target state="translated">Mac OS X 10.4 &quot;Tiger&quot;이상을 사용하면 비 사전 라이브러리에 대한 성능 저하가 거의 없습니다. 이전 릴리스는 정적 라이브러리 나 Apple의 사전 바인딩 된 동적 라이브러리보다로드 시간이 더 오래 걸립니다.</target>
        </trans-unit>
        <trans-unit id="5f9d3d0136d8a2d2276cb1a4c4f0bb0c82be3696" translate="yes" xml:space="preserve">
          <source>With NTFS (and no CYGWIN=nontsec), there should be no problems even if perl was built on FAT.</source>
          <target state="translated">NTFS를 사용하면 (CYGWIN = nontsec이 아님), perl이 FAT에 구축 된 경우에도 문제가 없습니다.</target>
        </trans-unit>
        <trans-unit id="783aaaca75cc72bad41475003df821affc75b7c5" translate="yes" xml:space="preserve">
          <source>With OO style, you can break the message arbitrarily. This means that we are no longer limited to have space for the whole message in memory, i.e. we can handle messages of any size.</source>
          <target state="translated">OO 스타일을 사용하면 메시지를 임의로 중단 할 수 있습니다. 이것은 우리가 더 이상 메모리에 전체 메시지를위한 공간을 갖도록 제한되지 않는다는 것을 의미합니다. 즉, 우리는 모든 크기의 메시지를 처리 ​​할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="aa5707019a9c4f2624f176a48761ef4f1b3f5952" translate="yes" xml:space="preserve">
          <source>With Perl &amp;gt;= 5.6.2, you can also use a line like this:</source>
          <target state="translated">Perl&amp;gt; = 5.6.2에서는 다음과 같은 행을 사용할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="c1bf2f77022cd9fed463a5704b297d6ff88b00d5" translate="yes" xml:space="preserve">
          <source>With Perl 5.004 you can also use the TIEHANDLE interface to access compressed files just like ordinary files:</source>
          <target state="translated">Perl 5.004를 사용하면 TIEHANDLE 인터페이스를 사용하여 일반 파일과 마찬가지로 압축 파일에 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9f110b40627d54799c1a5b4c023b449d3f05b59d" translate="yes" xml:space="preserve">
          <source>With Perl 5.10 and later, the smart match operator can give you the answer with the least amount of work:</source>
          <target state="translated">Perl 5.10 이상에서는 스마트 매치 운영자가 최소한의 작업으로 답변을 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4e55c608e124b42bf25bf02c154381796e1d9852" translate="yes" xml:space="preserve">
          <source>With a</source>
          <target state="translated">와</target>
        </trans-unit>
        <trans-unit id="cf7bad50138d4a906e034cdc8232445a6a34e8fb" translate="yes" xml:space="preserve">
          <source>With a &lt;a href=&quot;#code-point-argument&quot;&gt;&quot;code point argument&quot;&lt;/a&gt;, &lt;code&gt;charscript()&lt;/code&gt; returns the</source>
          <target state="translated">A의 &lt;a href=&quot;#code-point-argument&quot;&gt;&quot;코드 포인트 인수&quot;&lt;/a&gt; , &lt;code&gt;charscript()&lt;/code&gt; 반환</target>
        </trans-unit>
        <trans-unit id="ca805fd21b2d73d6d3fa38629cb4d7c77aac2c21" translate="yes" xml:space="preserve">
          <source>With a &lt;a href=&quot;#code-point-argument&quot;&gt;&quot;code point argument&quot;&lt;/a&gt;&lt;code&gt;charblock()&lt;/code&gt; returns the</source>
          <target state="translated">&lt;a href=&quot;#code-point-argument&quot;&gt;&quot;코드 포인트 인수&quot;를&lt;/a&gt; 사용하면 &lt;code&gt;charblock()&lt;/code&gt; 은</target>
        </trans-unit>
        <trans-unit id="f458d9e5c6b401d23a0ff93a93cac73ffa40d782" translate="yes" xml:space="preserve">
          <source>With a &lt;a href=&quot;#code-point-argument&quot;&gt;code point argument&lt;/a&gt;, &lt;code&gt;charscript()&lt;/code&gt; returns the</source>
          <target state="translated">A의 &lt;a href=&quot;#code-point-argument&quot;&gt;코드 포인트 인수&lt;/a&gt; , &lt;code&gt;charscript()&lt;/code&gt; 반환</target>
        </trans-unit>
        <trans-unit id="7cfd816e3af239ee8e3392fa5dd4b28e10c2cbf9" translate="yes" xml:space="preserve">
          <source>With a &lt;a href=&quot;#code-point-argument&quot;&gt;code point argument&lt;/a&gt;&lt;code&gt;charblock()&lt;/code&gt; returns the</source>
          <target state="translated">A의 &lt;a href=&quot;#code-point-argument&quot;&gt;코드 포인트 인수 &lt;/a&gt; &lt;code&gt;charblock()&lt;/code&gt; 반환</target>
        </trans-unit>
        <trans-unit id="cc06a9c18caf674053e4b44b132356a1c540f757" translate="yes" xml:space="preserve">
          <source>With a little extra work, you can get all of the groups in angle brackets even if they are in other angle brackets too. Each time you get a balanced match, remove its outer delimiter (that's the one you just matched so don't match it again) and add it to a queue of strings to process. Keep doing that until you get no matches:</source>
          <target state="translated">약간의 추가 작업으로 모든 그룹이 다른 꺾쇠 괄호 안에 있어도 꺾쇠 괄호로 묶을 수 있습니다. 균형 잡힌 일치를 얻을 때마다 외부 구분 기호를 제거하고 (즉, 일치하지 않았으므로 다시 일치시키지 마십시오) 처리 할 문자열 대기열에 추가하십시오. 일치하지 않을 때까지 계속하십시오.</target>
        </trans-unit>
        <trans-unit id="a69059588956460f70f3f90c71a968d5af85c118" translate="yes" xml:space="preserve">
          <source>With a non-&lt;code&gt;DEBUGGING&lt;/code&gt; perl, the buckets starting from &lt;code&gt;128&lt;/code&gt; have a 4-byte overhead, and thus an 8192-long bucket may take up to 8188-byte allocations.</source>
          <target state="translated">&lt;code&gt;DEBUGGING&lt;/code&gt; perl 이 아닌 경우 &lt;code&gt;128&lt;/code&gt; 에서 시작하는 버킷 은 4 바이트 오버 헤드를 가지므로 8192- 길이 버킷은 최대 8188 바이트 할당이 가능합니다.</target>
        </trans-unit>
        <trans-unit id="3f782793180910fe0c252c5c5e6b40299dd75d89" translate="yes" xml:space="preserve">
          <source>With a slurpy parameter in the signature, there is no upper limit on how many arguments may be passed. A slurpy array parameter may be nameless just like a positional parameter, in which case its only effect is to turn off the argument limit that would otherwise apply:</source>
          <target state="translated">서명에 slurpy 매개 변수를 사용하면 전달할 수있는 인수 수에 대한 상한이 없습니다. slurpy 배열 매개 변수는 위치 매개 변수와 마찬가지로 이름이 없을 수 있습니다.이 경우 유일한 효과는 그렇지 않은 경우 인수 제한을 해제하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="f9508f16c80ad6889c699daf40f43720b8251d92" translate="yes" xml:space="preserve">
          <source>With a technique called copy-on-write, the cost of copying with overload could be minimized or even completely avoided. A test implementation of COW did show performance gains for overloaded math, but introduced a performance loss due to a constant overhead for all other operations. So Math::BigInt does currently not COW.</source>
          <target state="translated">COW (Copy-On-Write)라는 기술을 사용하면 과부하로 복사하는 비용을 최소화하거나 완전히 피할 수 있습니다. COW의 테스트 구현은 오버로드 된 수학에 대한 성능 향상을 보여 주었지만 다른 모든 작업에 대한 지속적인 오버 헤드로 인해 성능 손실이 발생했습니다. 따라서 Math :: BigInt는 현재 COW하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="338611254651b6fbb00a03edfd8b2e0209a2413c" translate="yes" xml:space="preserve">
          <source>With a todo block, the tests inside are expected to fail. Test::More will run the tests normally, but print out special flags indicating they are &quot;todo&quot;. &lt;a href=&quot;Test::Harness&quot;&gt;Test::Harness&lt;/a&gt; will interpret failures as being ok. Should anything succeed, it will report it as an unexpected success. You then know the thing you had todo is done and can remove the TODO flag.</source>
          <target state="translated">할일 블록을 사용하면 내부 테스트가 실패 할 것으로 예상됩니다. Test :: More는 테스트를 정상적으로 실행하지만 &quot;todo&quot;임을 나타내는 특수 플래그를 인쇄합니다. &lt;a href=&quot;Test::Harness&quot;&gt;Test :: Harness&lt;/a&gt; 는 실패를 정상으로 해석합니다. 성공하면 예상치 못한 성공으로보고합니다. 그런 다음해야 할 일이 완료되었음을 알고 TODO 플래그를 제거 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0ebe6d7c43f224246d4ca3387c92f6cc94b15954" translate="yes" xml:space="preserve">
          <source>With a todo block, the tests inside are expected to fail. Test::More will run the tests normally, but print out special flags indicating they are &quot;todo&quot;. &lt;a href=&quot;harness&quot;&gt;Test::Harness&lt;/a&gt; will interpret failures as being ok. Should anything succeed, it will report it as an unexpected success. You then know the thing you had todo is done and can remove the TODO flag.</source>
          <target state="translated">todo 블록을 사용하면 내부 테스트가 실패 할 것으로 예상됩니다. Test :: More는 테스트를 정상적으로 실행하지만 &quot;todo&quot;임을 나타내는 특수 플래그를 인쇄합니다. &lt;a href=&quot;harness&quot;&gt;Test :: Harness&lt;/a&gt; 는 실패를 정상으로 해석합니다. 성공하면 예상치 못한 성공으로보고합니다. 그런 다음해야 할 일이 완료된 것을 알고 TODO 플래그를 제거 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="039f5d96db075baf2e35a9428955065fad856e3f" translate="yes" xml:space="preserve">
          <source>With all of the previous done, you're now ready to call Configure.</source>
          <target state="translated">이전 작업이 모두 완료되었으므로 이제 Configure를 호출 할 준비가되었습니다.</target>
        </trans-unit>
        <trans-unit id="2be7163284f82da14a87936dad63fbf983833559" translate="yes" xml:space="preserve">
          <source>With all of the regexes above, if the regex matched anywhere in the string, it was considered a match. To specify</source>
          <target state="translated">위의 모든 정규 표현식을 사용하여 정규 표현식이 문자열의 모든 위치와 일치하면 일치하는 것으로 간주됩니다. 지정하려면</target>
        </trans-unit>
        <trans-unit id="a49675e374380fe043aff3a5f63d6512021ecfd9" translate="yes" xml:space="preserve">
          <source>With all of the regexps above, if the regexp matched anywhere in the string, it was considered a match. Sometimes, however, we'd like to specify</source>
          <target state="translated">위의 모든 정규 표현식을 사용하여 정규 표현식이 문자열의 모든 위치와 일치하면 일치하는 것으로 간주됩니다. 그러나 때때로 우리는</target>
        </trans-unit>
        <trans-unit id="544d324c6a361c56f15aa84b4f308989bea67735" translate="yes" xml:space="preserve">
          <source>With an &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;, you should be especially careful to remember what's being looked at when:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 을 사용하면 다음과 같은 경우에 무엇을보고 있는지 기억해야합니다.</target>
        </trans-unit>
        <trans-unit id="250cfbca6e5e22d4d573a90cd37797d2cb8d3ac5" translate="yes" xml:space="preserve">
          <source>With an &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;, you should be especially careful to remember what's being looked at when:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 을 사용하면 다음과 같은 경우에 무엇을보고 있는지 기억해야합니다.</target>
        </trans-unit>
        <trans-unit id="8175ced4a0fd9d7cc491a3c946926864742f09d4" translate="yes" xml:space="preserve">
          <source>With an argument, can be used to generate a NaN with</source>
          <target state="translated">인수를 사용하면 다음을 사용하여 NaN을 생성하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="28933cd0405c565c32304d3c729c7e6f31006ad2" translate="yes" xml:space="preserve">
          <source>With any of these, you can change file descriptors before the call:</source>
          <target state="translated">이 중 하나를 사용하면 호출 전에 파일 디스크립터를 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="944f492857a1db6c839174233fd1c02f59c056dd" translate="yes" xml:space="preserve">
          <source>With any version of Perl 5 you can use the basic OO interface:</source>
          <target state="translated">Perl 5의 모든 버전에서 기본 OO 인터페이스를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d9bf5579433ea6ddabc4d916f0dbd99e9c0f39ff" translate="yes" xml:space="preserve">
          <source>With argument force $ENCODING_... variables to set to the given value.</source>
          <target state="translated">인수를 사용하면 $ ENCODING _... 변수가 주어진 값으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="aaaac305ec8d42934372356813b4624fa49a8ffc" translate="yes" xml:space="preserve">
          <source>With argument sets the option. Without returns the option value.</source>
          <target state="translated">인수로 옵션을 설정합니다. 미포함은 옵션 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="108bd0cf30895e3a18d32866a5ada0ba72c0b2d2" translate="yes" xml:space="preserve">
          <source>With bundling it is possible to set several single-character options at once. For example if &lt;code&gt;a&lt;/code&gt; , &lt;code&gt;v&lt;/code&gt; and &lt;code&gt;x&lt;/code&gt; are all valid options,</source>
          <target state="translated">번들로 여러 문자 옵션을 한 번에 설정할 수 있습니다. 예를 들어 &lt;code&gt;a&lt;/code&gt; , &lt;code&gt;v&lt;/code&gt; 및 &lt;code&gt;x&lt;/code&gt; 가 모두 유효한 옵션 인 경우</target>
        </trans-unit>
        <trans-unit id="6a3391ab50835b72ad746f9bc70f0861004cbe03" translate="yes" xml:space="preserve">
          <source>With bundling it is possible to set several single-character options at once. For example if &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;v&lt;/code&gt; and &lt;code&gt;x&lt;/code&gt; are all valid options,</source>
          <target state="translated">번들링을 사용하면 한 번에 여러 개의 단일 문자 옵션을 설정할 수 있습니다. 예를 들어 &lt;code&gt;a&lt;/code&gt; , &lt;code&gt;v&lt;/code&gt; 및 &lt;code&gt;x&lt;/code&gt; 가 모두 유효한 옵션이면</target>
        </trans-unit>
        <trans-unit id="bf9c20d6876f103320c9d9424556b25f81d7af24" translate="yes" xml:space="preserve">
          <source>With earlier versions of Perl, you have to do a bit more work. If you are going to make this query many times over arbitrary string values, the fastest way is probably to invert the original array and maintain a hash whose keys are the first array's values:</source>
          <target state="translated">이전 버전의 Perl에서는 조금 더 많은 작업을 수행해야합니다. 이 쿼리를 임의의 문자열 값보다 여러 번 만들려면 가장 빠른 방법은 원래 배열을 반전시키고 키가 첫 번째 배열 값인 해시를 유지하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="089c9811008b67cdbb35efdae3d3f3034c15c2b2" translate="yes" xml:space="preserve">
          <source>With excerpts from Perl, and contributions and suggestions from Ronald J. Kimball, Dave Mitchell, Dominic Dunlop, Mark Jason Dominus, Stephen McCamant, and David Landgren.</source>
          <target state="translated">Perl의 발췌 및 Ronald J. Kimball, Dave Mitchell, Dominic Dunlop, Mark Jason Dominus, Stephen McCamant 및 David Landgren의 공헌 및 제안.</target>
        </trans-unit>
        <trans-unit id="312cf396f9e4b4f5d83643b7fda95efc6c88ff9d" translate="yes" xml:space="preserve">
          <source>With hooks comes the ability to recurse back to the Storable engine. Indeed, hooks are regular Perl code, and Storable is convenient when it comes to serializing and deserializing things, so why not use it to handle the serialization string?</source>
          <target state="translated">후크를 사용하면 Storable 엔진으로 다시 돌아갈 수 있습니다. 실제로 후크는 일반적인 Perl 코드이며 Storable은 직렬화 및 직렬화 해제에 편리하므로 직렬화 문자열을 처리하는 데 사용하지 않는 이유는 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="2092bcf7558e6632164a74cbb09d09cc7943a0d7" translate="yes" xml:space="preserve">
          <source>With lots of help and suggestions from Dean Roehrich, Malcolm Beattie, Andreas Koenig, Paul Hudson, Ilya Zakharevich, Paul Marquess, Neil Bowers, Matthew Green, Tim Bunce, Spider Boardman, Ulrich Pfeifer, Stephen McCamant, and Gurusamy Sarathy.</source>
          <target state="translated">Dean Roehrich, Malcolm Beattie, Andreas Koenig, Paul Hudson, Ilya Zakharevich, Paul Marquess, Neil Bowers, Matthew Green, Tim Bunce, Spider Boardman, Ulrich Pfeifer, Stephen McCamant 및 Gurusamy Sarathy의 많은 도움과 제안이 있습니다.</target>
        </trans-unit>
        <trans-unit id="2f32ef7ca32db627a2acbe157dc6fb77e5ecddfd" translate="yes" xml:space="preserve">
          <source>With methods 2 and 3, Perl starts parsing the input file from the beginning, unless you've specified a &lt;a href=&quot;#-x&quot;&gt;&quot;-x&quot;&lt;/a&gt; switch, in which case it scans for the first line starting with &lt;code&gt;#!&lt;/code&gt; and containing the word &quot;perl&quot;, and starts there instead. This is useful for running a program embedded in a larger message. (In this case you would indicate the end of the program using the &lt;code&gt;__END__&lt;/code&gt; token.)</source>
          <target state="translated">방법 2와 3을 사용하면 Perl은 &lt;a href=&quot;#-x&quot;&gt;&quot;-x&quot;&lt;/a&gt; 스위치를 지정하지 않는 한 처음부터 입력 파일 구문 분석을 시작합니다. 이 경우 &lt;code&gt;#!&lt;/code&gt; 로 시작하는 첫 번째 줄을 검색합니다 . &quot;perl&quot;이라는 단어를 포함하고 대신 거기에서 시작합니다. 이것은 더 큰 메시지에 포함 된 프로그램을 실행하는 데 유용합니다. (이 경우 &lt;code&gt;__END__&lt;/code&gt; 토큰을 사용하여 프로그램의 끝을 표시합니다 .)</target>
        </trans-unit>
        <trans-unit id="6a2d0cebca8f8c753e2f714f5c39699038d3b25f" translate="yes" xml:space="preserve">
          <source>With methods 2 and 3, Perl starts parsing the input file from the beginning, unless you've specified a &lt;b&gt;-x&lt;/b&gt; switch, in which case it scans for the first line starting with &lt;code&gt;#!&lt;/code&gt; and containing the word &quot;perl&quot;, and starts there instead. This is useful for running a program embedded in a larger message. (In this case you would indicate the end of the program using the &lt;code&gt;__END__&lt;/code&gt; token.)</source>
          <target state="translated">방법 2와 3을 사용하면 &lt;b&gt;-x&lt;/b&gt; 스위치를 지정하지 않은 경우 Perl은 처음부터 입력 파일을 구문 분석하기 시작합니다. 이 경우 &lt;code&gt;#!&lt;/code&gt; 으로 시작하는 첫 번째 줄을 검색합니다 . &quot;perl&quot;이라는 단어를 포함하고 대신 시작합니다. 큰 메시지에 포함 된 프로그램을 실행하는 데 유용합니다. (이 경우 &lt;code&gt;__END__&lt;/code&gt; 토큰을 사용하여 프로그램의 끝을 나타냅니다 .)</target>
        </trans-unit>
        <trans-unit id="6316d5824ca52c312f770e770e783e4a6d5033d6" translate="yes" xml:space="preserve">
          <source>With mod_perl and the Apache::Registry module (distributed with mod_perl), httpd will run with an embedded Perl interpreter which pre-compiles your script and then executes it within the same address space without forking. The Apache extension also gives Perl access to the internal server API, so modules written in Perl can do just about anything a module written in C can. For more on mod_perl, see &lt;a href=&quot;http://perl.apache.org/&quot;&gt;http://perl.apache.org/&lt;/a&gt;</source>
          <target state="translated">mod_perl 및 Apache :: Registry 모듈 (mod_perl과 함께 배포)을 사용하면 httpd는 내장 된 Perl 인터프리터와 함께 실행되어 스크립트를 사전 컴파일 한 후 포크없이 동일한 주소 공간 내에서 실행합니다. Apache 확장은 또한 Perl에 내부 서버 API에 대한 액세스를 제공하므로 Perl로 작성된 모듈은 C로 작성된 모듈이 할 수있는 모든 작업을 수행 할 수 있습니다. mod_perl에 대한 자세한 내용은 &lt;a href=&quot;http://perl.apache.org/&quot;&gt;http://perl.apache.org/를&lt;/a&gt; 참조 하십시오.</target>
        </trans-unit>
        <trans-unit id="cc2eb3f9b78400953fa9a4ff9c87b68e20c7b681" translate="yes" xml:space="preserve">
          <source>With much assistance regarding shared libraries from Marc Sabatella.</source>
          <target state="translated">Marc Sabatella의 공유 라이브러리와 관련하여 많은 도움을 받았습니다.</target>
        </trans-unit>
        <trans-unit id="b462e2e8ccefffa9756bd47bbfa7c723db9b9b54" translate="yes" xml:space="preserve">
          <source>With negative offsets, it remembers its position from the end of the string when the target string is modified:</source>
          <target state="translated">음수 오프셋을 사용하면 대상 문자열이 수정 될 때 문자열 끝에서 위치를 기억합니다.</target>
        </trans-unit>
        <trans-unit id="00344cc849fc9376fff9de99085e79fa3cd552d0" translate="yes" xml:space="preserve">
          <source>With no MASK argument present, it returns the current operator mask of the compartment.</source>
          <target state="translated">MASK 인수가 없으면 구획의 현재 연산자 마스크를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="a35650496b577c95afdac0e1ebb0191fd46fd2e0" translate="yes" xml:space="preserve">
          <source>With no argument, the accessor returns a reference to the element's whole array (whether or not the element was specified as &lt;code&gt;'@'&lt;/code&gt; or &lt;code&gt;'*@'&lt;/code&gt; ).</source>
          <target state="translated">인수가 없으면 접근자는 요소의 전체 배열에 대한 참조를 반환합니다 (요소가 &lt;code&gt;'@'&lt;/code&gt; 또는 &lt;code&gt;'*@'&lt;/code&gt; 로 지정되었는지 여부 ).</target>
        </trans-unit>
        <trans-unit id="a8ef3568dccdeee73b65f3996dd1707e6feb3878" translate="yes" xml:space="preserve">
          <source>With no argument, the accessor returns a reference to the element's whole array (whether or not the element was specified as &lt;code&gt;'@'&lt;/code&gt; or &lt;code&gt;'*@'&lt;/code&gt;).</source>
          <target state="translated">인수가 없으면 접근자는 요소의 전체 배열에 대한 참조를 반환합니다 (요소가 &lt;code&gt;'@'&lt;/code&gt; 또는 &lt;code&gt;'*@'&lt;/code&gt; 로 지정되었는지 여부에 관계없이 ).</target>
        </trans-unit>
        <trans-unit id="3a4963e3a2e84181fb9a499ef49896fdab34cd7c" translate="yes" xml:space="preserve">
          <source>With no argument, the accessor returns a reference to the element's whole hash (whether or not the element was specified as &lt;code&gt;'%'&lt;/code&gt; or &lt;code&gt;'*%'&lt;/code&gt; ).</source>
          <target state="translated">인수가 없으면 접근자는 요소의 전체 해시에 대한 참조를 반환합니다 (요소가 &lt;code&gt;'%'&lt;/code&gt; 또는 &lt;code&gt;'*%'&lt;/code&gt; 로 지정되었는지 여부 ).</target>
        </trans-unit>
        <trans-unit id="988bcaf50ce8ee9902f007f6fc6c2b44abddd67d" translate="yes" xml:space="preserve">
          <source>With no argument, the accessor returns a reference to the element's whole hash (whether or not the element was specified as &lt;code&gt;'%'&lt;/code&gt; or &lt;code&gt;'*%'&lt;/code&gt;).</source>
          <target state="translated">인수가 없으면 접근자는 요소의 전체 해시에 대한 참조를 반환합니다 (요소가 &lt;code&gt;'%'&lt;/code&gt; 또는 &lt;code&gt;'*%'&lt;/code&gt; 로 지정되었는지 여부에 관계없이 ).</target>
        </trans-unit>
        <trans-unit id="6bae0e18d43bcb818e56d07261a055232eff0bf8" translate="yes" xml:space="preserve">
          <source>With no arguments (or using &lt;code&gt;threads::all&lt;/code&gt; ) and in a list context, returns a list of all non-joined, non-detached</source>
          <target state="translated">인수가 없거나 ( &lt;code&gt;threads::all&lt;/code&gt; ) 목록 컨텍스트에서 결합되지 않은 분리되지 않은 모든 목록을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="9a2c5169b8859351e115fccd32105029ad3b3e99" translate="yes" xml:space="preserve">
          <source>With no arguments (or using &lt;code&gt;threads::all&lt;/code&gt;) and in a list context, returns a list of all non-joined, non-detached</source>
          <target state="translated">인수없이 (또는 &lt;code&gt;threads::all&lt;/code&gt; ) 목록 컨텍스트에서 결합되지 않고 분리되지 않은 모든 목록을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="18cf8c9e6afcd23474d7fb3a81386e0988d7bd68" translate="yes" xml:space="preserve">
          <source>With older versions of Perl, the &lt;a href=&quot;IO::String&quot;&gt;IO::String&lt;/a&gt; module provides similar functionality.</source>
          <target state="translated">이전 버전의 Perl에서 &lt;a href=&quot;IO::String&quot;&gt;IO :: String&lt;/a&gt; 모듈은 유사한 기능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="d4cfb999178855ab18f46ce9c518e1bd1ef50096" translate="yes" xml:space="preserve">
          <source>With older versions of Perl, the &lt;a href=&quot;http://search.cpan.org/perldoc/IO::String&quot;&gt;IO::String&lt;/a&gt; module provides similar functionality.</source>
          <target state="translated">이전 버전의 Perl에서 &lt;a href=&quot;http://search.cpan.org/perldoc/IO::String&quot;&gt;IO :: String&lt;/a&gt; 모듈은 유사한 기능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="789c0f1114004fe97c889b4fd162dac50dbb4785" translate="yes" xml:space="preserve">
          <source>With one exception (below), if both strings look like numbers to Perl, the magic increment will not be applied, and the strings will be treated as numbers (more specifically, integers) instead.</source>
          <target state="translated">한 가지 예외 (아래)를 제외하고 두 문자열이 모두 Perl에 숫자처럼 보이면 매직 증분이 적용되지 않고 문자열이 대신 숫자 (더 구체적으로는 정수)로 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="c467eeeb4f15846c2e3c26d1b4d74776d4da75d4" translate="yes" xml:space="preserve">
          <source>With one or two arguments, the first argument is a key specifying one element of the hash; the second argument, if present, is assigned to the hash element. If the element type is &lt;code&gt;'%'&lt;/code&gt; , the accessor returns the hash element value. If the element type is &lt;code&gt;'*%'&lt;/code&gt; , a reference to the hash element is returned.</source>
          <target state="translated">하나 또는 두 개의 인수를 사용하면 첫 번째 인수는 해시의 한 요소를 지정하는 키입니다. 존재하는 경우, 두 번째 인수는 해시 요소에 할당됩니다. 요소 유형이 &lt;code&gt;'%'&lt;/code&gt; 이면 접근자는 해시 요소 값을 반환합니다. 요소 유형이 &lt;code&gt;'*%'&lt;/code&gt; 이면 해시 요소에 대한 참조가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="0bd4bcbdb7945f28a4390fecea625c7a59fd6d00" translate="yes" xml:space="preserve">
          <source>With one or two arguments, the first argument is a key specifying one element of the hash; the second argument, if present, is assigned to the hash element. If the element type is &lt;code&gt;'%'&lt;/code&gt;, the accessor returns the hash element value. If the element type is &lt;code&gt;'*%'&lt;/code&gt;, a reference to the hash element is returned.</source>
          <target state="translated">하나 또는 두 개의 인수와 함께 첫 번째 인수는 해시의 한 요소를 지정하는 키입니다. 두 번째 인수가있는 경우 해시 요소에 할당됩니다. 요소 유형이 &lt;code&gt;'%'&lt;/code&gt; 이면 접근자는 해시 요소 값을 반환합니다. 요소 유형이 &lt;code&gt;'*%'&lt;/code&gt; 이면 해시 요소에 대한 참조가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="043fe821df73a58116e971eada4906da49321cca" translate="yes" xml:space="preserve">
          <source>With one or two arguments, the first argument is an index specifying one element of the array; the second argument, if present, is assigned to the array element. If the element type is &lt;code&gt;'@'&lt;/code&gt; , the accessor returns the array element value. If the element type is &lt;code&gt;'*@'&lt;/code&gt; , a reference to the array element is returned.</source>
          <target state="translated">하나 또는 두 개의 인수를 사용하면 첫 번째 인수는 배열의 한 요소를 지정하는 인덱스입니다. 두 번째 인수 (있는 경우)는 배열 요소에 지정됩니다. 요소 유형이 &lt;code&gt;'@'&lt;/code&gt; 인 경우 접근자는 배열 요소 값을 반환합니다. 요소 유형이 &lt;code&gt;'*@'&lt;/code&gt; 인 경우 배열 요소에 대한 참조가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="eca88cd532fb52622336dc15fcd9f2fe4531eda4" translate="yes" xml:space="preserve">
          <source>With one or two arguments, the first argument is an index specifying one element of the array; the second argument, if present, is assigned to the array element. If the element type is &lt;code&gt;'@'&lt;/code&gt;, the accessor returns the array element value. If the element type is &lt;code&gt;'*@'&lt;/code&gt;, a reference to the array element is returned.</source>
          <target state="translated">하나 또는 두 개의 인수와 함께 첫 번째 인수는 배열의 한 요소를 지정하는 인덱스입니다. 두 번째 인수가있는 경우 배열 요소에 할당됩니다. 요소 유형이 &lt;code&gt;'@'&lt;/code&gt; 이면 접근자는 배열 요소 값을 반환합니다. 요소 유형이 &lt;code&gt;'*@'&lt;/code&gt; 이면 배열 요소에 대한 참조가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="d82587a9e3d9d950371c40dd7e06719bffb84440" translate="yes" xml:space="preserve">
          <source>With option -exec, walks tree in execute order, otherwise in basic order.</source>
          <target state="translated">-exec 옵션을 사용하면 실행 순서대로 트리를 이동하고 그렇지 않으면 기본 순서로 트리를 이동합니다.</target>
        </trans-unit>
        <trans-unit id="57d705a8d20354296c55ade02ce168e9aba3ea9c" translate="yes" xml:space="preserve">
          <source>With overloaded math, only the first two variants will result in a BigFloat:</source>
          <target state="translated">오버로드 된 수학에서는 처음 두 변형 만 BigFloat가됩니다.</target>
        </trans-unit>
        <trans-unit id="04cbc8f37da7397c953eb4dca3b6f0e0eee0dac0" translate="yes" xml:space="preserve">
          <source>With overloaded operators, it is the first (dominating) operand that determines which method is called. Here are some examples showing what actually gets called in various cases.</source>
          <target state="translated">오버로드 된 연산자를 사용하면 호출되는 메서드를 결정하는 첫 번째 (지배적 인) 피연산자입니다. 다음은 다양한 경우에 실제로 호출되는 것을 보여주는 몇 가지 예입니다.</target>
        </trans-unit>
        <trans-unit id="a2b46b3274ff332d0d8381195e802b804512dbcd" translate="yes" xml:space="preserve">
          <source>With proper care you may mix package and my (or state) &lt;code&gt;$a&lt;/code&gt; and/or &lt;code&gt;$b&lt;/code&gt;:</source>
          <target state="translated">적절한주의를 기울이면 패키지와 내 (또는 주) &lt;code&gt;$a&lt;/code&gt; 및 / 또는 &lt;code&gt;$b&lt;/code&gt; 혼합 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f7d4085fcb09a164c92639ac09b2aa2b53f4f318" translate="yes" xml:space="preserve">
          <source>With respect to character matching, there are a few more points you need to know about. First of all, not all characters can be used &quot;as is&quot; in a match. Some characters, called</source>
          <target state="translated">캐릭터 매칭과 관련하여 알아야 할 몇 가지 사항이 더 있습니다. 우선, 일치에서 모든 문자를 &quot;있는 그대로&quot;사용할 수있는 것은 아닙니다. 라는 일부 문자</target>
        </trans-unit>
        <trans-unit id="549d9ba8c522ce4226592827b058814ec17aafc9" translate="yes" xml:space="preserve">
          <source>With respect to character matching, there are a few more points you need to know about. First of all, not all characters can be used 'as is' in a match. Some characters, called</source>
          <target state="translated">문자 일치와 관련하여 알아야 할 몇 가지 사항이 더 있습니다. 우선, 모든 문자가 일치하는 '있는 그대로'사용될 수있는 것은 아닙니다. 일부 문자</target>
        </trans-unit>
        <trans-unit id="f52704b066745f4539042b4ca42ac5911b1eae8e" translate="yes" xml:space="preserve">
          <source>With respect to files, one that has the proper permission bit set to let you access the file. With respect to computer programs, one that&amp;rsquo;s written well enough that someone has a chance of figuring out what it&amp;rsquo;s trying to do.</source>
          <target state="translated">파일과 관련하여 파일에 액세스 할 수 있도록 적절한 권한 비트가 설정되어 있습니다. 컴퓨터 프로그램과 관련하여 누군가가하려는 일을 알아낼 수있을 정도로 충분히 잘 작성된 것입니다.</target>
        </trans-unit>
        <trans-unit id="3dc4eefad3d29ef780cb07bfc36df49d416959b4" translate="yes" xml:space="preserve">
          <source>With respect to loading &lt;code&gt;Exporter&lt;/code&gt; and inheriting, there are alternatives with the use of modules like &lt;code&gt;base&lt;/code&gt; and &lt;code&gt;parent&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;Exporter&lt;/code&gt; 로드 및 상속 과 관련하여 &lt;code&gt;base&lt;/code&gt; 및 &lt;code&gt;parent&lt;/code&gt; 와 같은 모듈을 사용하는 대안이 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6ddfefdcb8919ff4ad4881cdfab3eb3ea6c93a49" translate="yes" xml:space="preserve">
          <source>With respect to loading &lt;code&gt;Exporter&lt;/code&gt; and inheriting, there are alternatives with the use of modules like &lt;code&gt;base&lt;/code&gt; and &lt;code&gt;parent&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Exporter&lt;/code&gt; 로딩 및 상속 과 관련하여 &lt;code&gt;base&lt;/code&gt; 및 &lt;code&gt;parent&lt;/code&gt; 와 같은 모듈을 사용하는 대안이 있습니다 .</target>
        </trans-unit>
        <trans-unit id="64aab757411e3efe138dbb9f7787c6359c1eec8b" translate="yes" xml:space="preserve">
          <source>With some firewalls active mode does not work as the server cannot connect to your machine (because you are behind a firewall) and the firewall does not re-write the command. In this case you should set &lt;code&gt;ftp_ext_passive&lt;/code&gt; to a</source>
          <target state="translated">방화벽이있어 서버가 시스템에 연결할 수없고 방화벽이 명령을 다시 쓰지 않기 때문에 일부 방화벽의 경우 활성 모드가 작동하지 않습니다. 이 경우 &lt;code&gt;ftp_ext_passive&lt;/code&gt; 를</target>
        </trans-unit>
        <trans-unit id="39e7b288b06e2af98b83632e08ab80e03b9bf7c3" translate="yes" xml:space="preserve">
          <source>With source filters, you can store the text of your script compressed and use a source filter to uncompress it for Perl's parser:</source>
          <target state="translated">소스 필터를 사용하면 스크립트 텍스트를 압축하여 저장하고 소스 필터를 사용하여 Perl 파서에 대해 압축을 해제 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f3d0833032fe049783c845044de2a75767e40f62" translate="yes" xml:space="preserve">
          <source>With support for &lt;code&gt;LIBPATHSTRICT&lt;/code&gt; this may be circumvented - unless one of DLLs is started from</source>
          <target state="translated">&lt;code&gt;LIBPATHSTRICT&lt;/code&gt; 를 지원하면 DLL 중 하나가 시작되지 않는 한이를 피할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="741296e189dd1627ab6af5dc824e2c81acff153a" translate="yes" xml:space="preserve">
          <source>With that trick MakeMaker will only read the first line and thus read the underscore, while the perl interpreter will evaluate the $VERSION and convert the string into a number. Later operations that treat $VERSION as a number will then be able to do so without provoking a warning about $VERSION not being a number.</source>
          <target state="translated">이 트릭으로 MakeMaker는 첫 번째 줄만 읽으므로 밑줄을 읽습니다. 반면 펄 인터프리터는 $ VERSION을 평가하고 문자열을 숫자로 변환합니다. $ VERSION을 숫자로 취급하는 이후의 조작은 $ VERSION이 숫자가 아니라는 경고를 표시하지 않고이를 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fa542340f7199357b9ddb7d211923c323666ef12" translate="yes" xml:space="preserve">
          <source>With the &quot;tcp&quot; protocol the ping() method attempts to establish a connection to the remote host's echo port. If the connection is successfully established, the remote host is considered reachable. No data is actually echoed. This protocol does not require any special privileges but has higher overhead than the &quot;udp&quot; and &quot;icmp&quot; protocols.</source>
          <target state="translated">&quot;tcp&quot;프로토콜을 사용하여 ping () 메소드는 원격 호스트의 에코 포트에 연결을 시도합니다. 연결에 성공하면 원격 호스트에 연결할 수있는 것으로 간주됩니다. 실제로는 데이터가 에코되지 않습니다. 이 프로토콜에는 특별한 권한이 필요하지 않지만 &quot;udp&quot;및 &quot;icmp&quot;프로토콜보다 높은 오버 헤드가 있습니다.</target>
        </trans-unit>
        <trans-unit id="0c9c2cd66698ade01d6241c0c3475076fe41182f" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; pragma you can use the &lt;code&gt;:locale&lt;/code&gt; layer</source>
          <target state="translated">로 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; 프라 그마 당신이 사용할 수있는 &lt;code&gt;:locale&lt;/code&gt; 레이어를</target>
        </trans-unit>
        <trans-unit id="e4721b12184df4c626e83aff44b61b424dee2894" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt; operator, the matched variables &lt;code&gt;$1&lt;/code&gt; , &lt;code&gt;$2&lt;/code&gt; , etc. are immediately available for use in the replacement expression. With the global modifier, &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///g&lt;/a&gt;&lt;/code&gt; will search and replace all occurrences of the regex in the string:</source>
          <target state="translated">으로 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt; 연산자 유사한 변수 &lt;code&gt;$1&lt;/code&gt; , &lt;code&gt;$2&lt;/code&gt; 등 교체 식 즉시 사용 가능하다. 전역 수정자를 사용하면 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///g&lt;/a&gt;&lt;/code&gt; 는 문자열에서 모든 정규식을 검색하고 대체합니다.</target>
        </trans-unit>
        <trans-unit id="a5f3ac7301bb1927406401553bc7979a7058d48f" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt; pragma you can control the behaviour of the builtin &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort()&lt;/a&gt;&lt;/code&gt; function.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt; pragma를 사용하면 내장 &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort()&lt;/a&gt;&lt;/code&gt; 함수 의 동작을 제어 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ed30d894507576a6aff023249124e00f485a0445" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;IN&lt;/code&gt; subpragma you can declare the default layers of input streams, and with the &lt;code&gt;OUT&lt;/code&gt; subpragma you can declare the default layers of output streams. With the &lt;code&gt;IO&lt;/code&gt; subpragma (may be omitted for &lt;code&gt;:utf8&lt;/code&gt;, &lt;code&gt;:locale&lt;/code&gt;, or &lt;code&gt;:encoding&lt;/code&gt;) you can control both input and output streams simultaneously.</source>
          <target state="translated">&lt;code&gt;IN&lt;/code&gt; 서브 프라그 마를 사용하여 입력 스트림 의 기본 계층을 선언 할 수 있고 &lt;code&gt;OUT&lt;/code&gt; 서브 프라그 마를 사용하여 출력 스트림의 기본 계층을 선언 할 수 있습니다. 로 &lt;code&gt;IO&lt;/code&gt; 에 subpragma (생략 될 수있다 &lt;code&gt;:utf8&lt;/code&gt; , &lt;code&gt;:locale&lt;/code&gt; 또는 &lt;code&gt;:encoding&lt;/code&gt; )는 입력과 출력을 모두 제어 할 수있는 동시에 스트림.</target>
        </trans-unit>
        <trans-unit id="640e6849be58e830210cdb457742bd0e5d46239f" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;IN&lt;/code&gt; subpragma you can declare the default layers of input streams, and with the &lt;code&gt;OUT&lt;/code&gt; subpragma you can declare the default layers of output streams. With the &lt;code&gt;IO&lt;/code&gt; subpragma you can control both input and output streams simultaneously.</source>
          <target state="translated">으로 &lt;code&gt;IN&lt;/code&gt; 의 subpragma 당신은 입력 스트림의 기본 레이어를 선언 할 수 있고, 함께 &lt;code&gt;OUT&lt;/code&gt; 의 subpragma 당신은 출력 스트림의 기본 레이어를 선언 할 수 있습니다. 으로 &lt;code&gt;IO&lt;/code&gt; 의 subpragma 당신은 두 입력을 제어 할 수있는 출력을 동시에 스트리밍합니다.</target>
        </trans-unit>
        <trans-unit id="9a9bb48f29cda9ceed93d7949280d0a2ae7a947b" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;PERL_VMS_POSIX_EXIT&lt;/code&gt; logical name defined as &quot;ENABLE&quot;, setting &lt;code&gt;$?&lt;/code&gt; will cause the new value to be encoded into &lt;code&gt;$^E&lt;/code&gt; so that either the original parent or child exit status values 0 to 255 can be automatically recovered by C programs expecting _POSIX_EXIT behavior. If both a parent and a child exit value are non-zero, then it will be assumed that this is actually a VMS native status value to be passed through. The special value of 0xFFFF is almost a NOOP as it will cause the current native VMS status in the C library to become the current native Perl VMS status, and is handled this way as it is known to not be a valid native VMS status value. It is recommend that only values in the range of normal Unix parent or child status numbers, 0 to 255 are used.</source>
          <target state="translated">으로 &lt;code&gt;PERL_VMS_POSIX_EXIT&lt;/code&gt; 로 정의 논리 이름 설정 &quot;ENABLE&quot; &lt;code&gt;$?&lt;/code&gt; _POSIX_EXIT 동작을 예상하는 C 프로그램이 원래 상위 또는 하위 종료 상태 값 0-255를 자동으로 복구 할 수 있도록 새 값이 &lt;code&gt;$^E&lt;/code&gt; 로 인코딩됩니다 . 상위 및 하위 엑시트 값이 모두 0이 아닌 경우 실제로 전달되는 VMS 기본 상태 값인 것으로 가정합니다. 0xFFFF의 특수 값은 C 라이브러리의 현재 기본 VMS 상태가 현재 기본 Perl VMS 상태가되므로 유효한 기본 VMS 상태 값이 아닌 것으로 알려진 방식으로 처리되므로 거의 NOOP입니다. 일반 Unix 상위 또는 하위 상태 번호 범위 인 0-255 범위의 값만 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="d83714fab9481b19a76857b0c66b38bb676d9244" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;open&lt;/code&gt; pragma you can use the &lt;code&gt;:locale&lt;/code&gt; layer</source>
          <target state="translated">로 &lt;code&gt;open&lt;/code&gt; 프라 그마 당신이 사용할 수있는 &lt;code&gt;:locale&lt;/code&gt; 레이어를</target>
        </trans-unit>
        <trans-unit id="5aef762dfae7dd14d56c63866d88c9f9105ac20d" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;s///&lt;/code&gt; operator, the matched variables &lt;code&gt;$1&lt;/code&gt;, &lt;code&gt;$2&lt;/code&gt;, etc. are immediately available for use in the replacement expression. With the global modifier, &lt;code&gt;s///g&lt;/code&gt; will search and replace all occurrences of the regex in the string:</source>
          <target state="translated">으로 &lt;code&gt;s///&lt;/code&gt; 연산자 유사한 변수 &lt;code&gt;$1&lt;/code&gt; , &lt;code&gt;$2&lt;/code&gt; 등 교체 식 즉시 사용 가능하다. 전역 수정자를 사용하면 &lt;code&gt;s///g&lt;/code&gt; 는 문자열에서 모든 정규식을 검색하고 대체합니다.</target>
        </trans-unit>
        <trans-unit id="2822b5f3a724906c266471a5abc1878fe1a5daf9" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;sort&lt;/code&gt; pragma you can control the behaviour of the builtin &lt;code&gt;sort()&lt;/code&gt; function.</source>
          <target state="translated">&lt;code&gt;sort&lt;/code&gt; pragma를 사용하면 내장 &lt;code&gt;sort()&lt;/code&gt; 함수 의 동작을 제어 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d85c0b58283979a05b1d958cf7b8e77666b21187" translate="yes" xml:space="preserve">
          <source>With the C-style operators that would have been written like this:</source>
          <target state="translated">다음과 같이 작성된 C 스타일 연산자를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="12231f536f1fde7f945e73b86c0bb0963f5133af" translate="yes" xml:space="preserve">
          <source>With the FCGI module (from CPAN) and the mod_fastcgi module (available from &lt;a href=&quot;http://www.fastcgi.com/&quot;&gt;http://www.fastcgi.com/&lt;/a&gt; ) each of your Perl programs becomes a permanent CGI daemon process.</source>
          <target state="translated">CPAN의 FCGI 모듈 및 mod_fastcgi 모듈 ( &lt;a href=&quot;http://www.fastcgi.com/&quot;&gt;http://www.fastcgi.com/&lt;/a&gt; 에서 사용 가능 )을 사용하면 각 Perl 프로그램이 영구적 인 CGI 데몬 프로세스가됩니다.</target>
        </trans-unit>
        <trans-unit id="e9f0f761b750ef587b104ca22707f7d417110d25" translate="yes" xml:space="preserve">
          <source>With the MASK argument present, it sets the operator mask for the compartment (equivalent to calling the deny_only method).</source>
          <target state="translated">MASK 인수가 있으면 구획의 연산자 마스크를 설정합니다 (deny_only 메소드 호출과 동일).</target>
        </trans-unit>
        <trans-unit id="a26ddc37c924b20873cf0fb8deaac6c02f3c0643" translate="yes" xml:space="preserve">
          <source>With the _POSIX_EXIT macro set, the Unix exit value of zero is represented as a VMS native status of 1, and the Unix values from 2 to 255 are encoded by the equation:</source>
          <target state="translated">_POSIX_EXIT 매크로를 설정하면 Unix 종료 값 0은 VMS 기본 상태 1로 표시되고 2에서 255까지의 Unix 값은 다음 방정식으로 인코딩됩니다.</target>
        </trans-unit>
        <trans-unit id="ca23bf605fbab54b13a6b11fd9b026fcad525316" translate="yes" xml:space="preserve">
          <source>With the above regexp all content following (and including) any of the given &lt;code&gt;=head1&lt;/code&gt; headings will be shown. It is possible to restrict the output to particular subsections only, e.g.:</source>
          <target state="translated">위의 정규 표현식을 사용하면 주어진 &lt;code&gt;=head1&lt;/code&gt; 제목을 따르는 (포함) 모든 콘텐츠 가 표시됩니다. 출력을 특정 하위 섹션으로 만 제한 할 수 있습니다. 예 :</target>
        </trans-unit>
        <trans-unit id="b04e80858e882edcc84d0f324c4fa0f1bc41eaae" translate="yes" xml:space="preserve">
          <source>With the check_sigs parameter you can turn signature checking on and off. The default is off for now because the whole tool chain for the functionality is not yet considered mature by some. The author of CPAN.pm would recommend setting it to true most of the time and turning it off only if it turns out to be annoying.</source>
          <target state="translated">check_sigs 매개 변수를 사용하면 서명 확인을 켜거나 끌 수 있습니다. 기능에 대한 전체 툴 체인이 아직 성숙되지 않은 것으로 간주되어 기본값이 해제되어 있습니다. CPAN.pm의 작성자는 대부분의 경우 true로 설정하고 성가신 것으로 판명되는 경우에만 끄는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="65d6f831578499e9dbe5b97d3e54d9d6970d12d6" translate="yes" xml:space="preserve">
          <source>With the completion of Example 4, we now have an easy way to simulate some real-life libraries whose interfaces may not be the cleanest in the world. We shall now continue with a discussion of the arguments passed to the &lt;b&gt;xsubpp&lt;/b&gt; compiler.</source>
          <target state="translated">예제 4가 완성되면서 인터페이스가 세계에서 가장 깨끗하지 않을 수있는 실제 라이브러리를 쉽게 시뮬레이션 할 수 있습니다. 이제 &lt;b&gt;xsubpp&lt;/b&gt; 컴파일러에 전달 된 인수에 대한 논의를 계속하겠습니다 .</target>
        </trans-unit>
        <trans-unit id="1f205214a6ba2cf07a234149bf2d1460c5296c50" translate="yes" xml:space="preserve">
          <source>With the creation of the &lt;code&gt;IO::Compress&lt;/code&gt; and &lt;code&gt;IO::Uncompress&lt;/code&gt; modules no new features are planned for &lt;code&gt;Compress::Zlib&lt;/code&gt; - the new modules do everything that &lt;code&gt;Compress::Zlib&lt;/code&gt; does and then some. Development on &lt;code&gt;Compress::Zlib&lt;/code&gt; will be limited to bug fixes only.</source>
          <target state="translated">의 창조와 &lt;code&gt;IO::Compress&lt;/code&gt; 및 &lt;code&gt;IO::Uncompress&lt;/code&gt; 모듈은 어떤 새로운 기능에 대한 계획이 없습니다 &lt;code&gt;Compress::Zlib&lt;/code&gt; - 새로운 모듈은 모든 것을 할 &lt;code&gt;Compress::Zlib&lt;/code&gt; 다음 몇 가지 수행을합니다. &lt;code&gt;Compress::Zlib&lt;/code&gt; 개발은 버그 수정으로 만 제한됩니다.</target>
        </trans-unit>
        <trans-unit id="257b1120ebcd7fe1453a131da8ee68f42d2f7003" translate="yes" xml:space="preserve">
          <source>With the default setting of &lt;code&gt;$Storable::flags&lt;/code&gt; = 6, creating or destroying random objects, even renamed objects can be controlled by an attacker. See CVE-2015-1592 and its metasploit module.</source>
          <target state="translated">기본 설정 인 &lt;code&gt;$Storable::flags&lt;/code&gt; = 6을 사용하면 임의의 개체를 만들거나 제거 할 수 있으며 이름이 변경된 개체도 공격자가 제어 할 수 있습니다. CVE-2015-1592 및 해당 메타 스플로 잇 모듈을 참조하세요.</target>
        </trans-unit>
        <trans-unit id="23f3553b9522af30d1dac804157bedd65e6495d3" translate="yes" xml:space="preserve">
          <source>With the default setting the size is limited to 128MB. The -1 removes this limit. If the &quot;make test&quot; fails please change your /etc/security/limits as stated above.</source>
          <target state="translated">기본 설정에서는 크기가 128MB로 제한됩니다. -1은이 제한을 제거합니다. &quot;make test&quot;에 실패하면 위에서 설명한대로 / etc / security / limits를 변경하십시오.</target>
        </trans-unit>
        <trans-unit id="9b9699d8827c96371e7103bd01aa95e9549d18da" translate="yes" xml:space="preserve">
          <source>With the example above, you knew to look for &lt;code&gt;Perl_pp_add&lt;/code&gt; , but what if there were multiple calls to it all over the place, or you didn't know what the op was you were looking for?</source>
          <target state="translated">위의 예에서, 당신은 &lt;code&gt;Perl_pp_add&lt;/code&gt; 을 찾는 것을 알고 있었지만 , 여기저기서 여러 번의 호출이 있었거나, 당신이 찾고있는 op가 무엇인지 모른다면?</target>
        </trans-unit>
        <trans-unit id="cfa6b797e8e5233002fffa69434e7ca138b4ff32" translate="yes" xml:space="preserve">
          <source>With the example above, you knew to look for &lt;code&gt;Perl_pp_add&lt;/code&gt;, but what if there were multiple calls to it all over the place, or you didn't know what the op was you were looking for?</source>
          <target state="translated">위의 예를 사용하여 &lt;code&gt;Perl_pp_add&lt;/code&gt; 를 찾는 것을 알고 있었지만 여기 저기에서 여러 번 호출이 발생했거나 원하는 작업이 무엇인지 몰랐다면 어떻게 하시겠습니까?</target>
        </trans-unit>
        <trans-unit id="65607d779f766d1b6b4828b7428d0ded3d690325" translate="yes" xml:space="preserve">
          <source>With the following options you get a Perl version which passes all make tests in 32-bit mode.</source>
          <target state="translated">다음 옵션을 사용하면 모든 make 테스트를 32 비트 모드로 통과하는 Perl 버전이 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="a8358873bd6ba12b8e2a5bea80bf9adbb46e0a6e" translate="yes" xml:space="preserve">
          <source>With the following options you get a Perl version which passes all make tests in 64-bit mode.</source>
          <target state="translated">다음 옵션을 사용하면 64 비트 모드에서 모든 make 테스트를 통과하는 Perl 버전이 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="26bc1ab7fe70714950b9630e3ca1a3522b890186" translate="yes" xml:space="preserve">
          <source>With the following options you get a threaded Perl version which passes all make tests in 64-bit mode.</source>
          <target state="translated">다음 옵션을 사용하면 64 비트 모드에서 모든 테스트를 통과하는 스레드 된 Perl 버전이 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="653ecd70c393a4f98976d6cf49198158a3d68bae" translate="yes" xml:space="preserve">
          <source>With the following options you get a threaded Perl version which passes all make tests in threaded 32-bit mode, which is the default configuration for the Perl builds that AIX ships with.</source>
          <target state="translated">다음 옵션을 사용하면 모든 스레드 테스트를 스레드 32 비트 모드로 전달하는 스레드 Perl 버전이 제공되는데, 이는 AIX와 함께 제공되는 Perl 빌드의 기본 구성입니다.</target>
        </trans-unit>
        <trans-unit id="aeae9f602df12b1cbf706e0ffe90fc7d11fa8d65" translate="yes" xml:space="preserve">
          <source>With the help of Jarkko Hietaniemi the Configure system has been tweaked to run under abc-shell so the recommend build process is as follows.</source>
          <target state="translated">Jarkko Hietaniemi의 도움으로 Configure 시스템이 abc-shell에서 실행되도록 조정되었으므로 권장 빌드 프로세스는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="826dec98b275c7a952ab77d69c22223ec197d3b5" translate="yes" xml:space="preserve">
          <source>With the introduction of lexical warnings, mandatory warnings now become</source>
          <target state="translated">사전 경고가 도입됨에 따라 필수 경고는 이제</target>
        </trans-unit>
        <trans-unit id="cb83c7552e22c7b5119774691db23c4fd72dba00" translate="yes" xml:space="preserve">
          <source>With the introduction of the</source>
          <target state="translated">소개와 함께</target>
        </trans-unit>
        <trans-unit id="dd358809edabd87f2081065d37eb93940f155fac" translate="yes" xml:space="preserve">
          <source>With the lock released, process &quot;B&quot; can now continue. It also updates the database and unfortunately it too modifies the data that was in its initial buffer. Once that data gets flushed to disk it will overwrite some/all of the changes process &quot;A&quot; made to the database.</source>
          <target state="translated">잠금이 해제되면 &quot;B&quot;프로세스를 계속 진행할 수 있습니다. 또한 데이터베이스를 업데이트하고 불행히도 초기 버퍼에 있던 데이터도 수정합니다. 해당 데이터가 디스크로 플러시되면 데이터베이스에 대한 변경 프로세스 &quot;A&quot;의 일부 / 모든 내용을 덮어 씁니다.</target>
        </trans-unit>
        <trans-unit id="b4b71a45e3d179fe5db4257fdf8f0f1934140fcb" translate="yes" xml:space="preserve">
          <source>With the release 5.003_01 the dynamically loadable libraries should be rebuilt when a different version of Perl is compiled. In particular, DLLs (including</source>
          <target state="translated">5.003_01 릴리스에서는 다른 버전의 Perl이 컴파일 될 때 동적으로로드 가능한 라이브러리를 다시 빌드해야합니다. 특히 DLL (</target>
        </trans-unit>
        <trans-unit id="a313290bcf78e6ca63c8b821c60748978a4d212c" translate="yes" xml:space="preserve">
          <source>With this keyword present &lt;a href=&quot;#The-RETVAL-Variable&quot;&gt;&quot;The RETVAL Variable&quot;&lt;/a&gt; is created, and in the generated call to the subroutine this variable is assigned to, but the value of this variable is not going to be used in the auto-generated code.</source>
          <target state="translated">이 키워드가 있으면 &lt;a href=&quot;#The-RETVAL-Variable&quot;&gt;&quot;RETVAL 변수&quot;&lt;/a&gt; 가 생성되고 생성 된 서브 루틴 호출에서이 변수가 할당되지만이 변수의 값은 자동 생성 코드에서 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5325c34a4ae29cf34042f77f365e0b89df2159a0" translate="yes" xml:space="preserve">
          <source>With this keyword present &lt;a href=&quot;#The-RETVAL-Variable&quot;&gt;The RETVAL Variable&lt;/a&gt; is created, and in the generated call to the subroutine this variable is assigned to, but the value of this variable is not going to be used in the auto-generated code.</source>
          <target state="translated">이 키워드가 있으면 &lt;a href=&quot;#The-RETVAL-Variable&quot;&gt;RETVAL 변수&lt;/a&gt; 가 작성되고 서브 루틴에 대한 생성 된 호출에서이 변수가 지정되지만이 변수의 값은 자동 생성 코드에서 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="92fdd49156ba7199f10cc8d72686bcba30a111b6" translate="yes" xml:space="preserve">
          <source>With this method you can specify your own boolean values for decoding - on decode, JSON &lt;code&gt;false&lt;/code&gt; will be decoded as a copy of &lt;code&gt;$false&lt;/code&gt;, and JSON &lt;code&gt;true&lt;/code&gt; will be decoded as &lt;code&gt;$true&lt;/code&gt; (&quot;copy&quot; here is the same thing as assigning a value to another variable, i.e. &lt;code&gt;$copy = $false&lt;/code&gt;).</source>
          <target state="translated">이 방법을 사용하면 디코딩을위한 고유 한 부울 값을 지정할 수 있습니다. 디코딩시 JSON &lt;code&gt;false&lt;/code&gt; 는 &lt;code&gt;$false&lt;/code&gt; 의 복사본으로 디코딩 되고 JSON &lt;code&gt;true&lt;/code&gt; 는 &lt;code&gt;$true&lt;/code&gt; 로 디코딩됩니다 (여기서 &quot;복사&quot;는 값을 할당하는 것과 동일합니다. 다른 변수, 즉 &lt;code&gt;$copy = $false&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="666c6c1292ea8eefe8526f26c75c36dbe91118ff" translate="yes" xml:space="preserve">
          <source>With this module, simply change all &lt;code&gt;use_ok&lt;/code&gt; in test scripts to &lt;code&gt;use ok&lt;/code&gt;, and they will be executed at &lt;code&gt;BEGIN&lt;/code&gt; time.</source>
          <target state="translated">이 모듈 을 &lt;code&gt;use ok&lt;/code&gt; 하여 테스트 스크립트의 모든 &lt;code&gt;use_ok&lt;/code&gt; 를 ok 를 사용하도록 변경하면 &lt;code&gt;BEGIN&lt;/code&gt; 시간에 실행됩니다 .</target>
        </trans-unit>
        <trans-unit id="153c87b7fb53ffdf16b2513e4ef9fbf84bb1453a" translate="yes" xml:space="preserve">
          <source>With this module, simply change all &lt;code&gt;use_ok&lt;/code&gt; in test scripts to &lt;code&gt;use ok&lt;/code&gt;, and they will be executed at &lt;code&gt;BEGIN&lt;/code&gt; time. The explicit space after &lt;code&gt;use&lt;/code&gt; makes it clear that this is a single compile-time action.</source>
          <target state="translated">이 모듈 을 &lt;code&gt;use ok&lt;/code&gt; 하여 테스트 스크립트의 모든 &lt;code&gt;use_ok&lt;/code&gt; 를 ok 를 사용하도록 변경하면 &lt;code&gt;BEGIN&lt;/code&gt; 시간에 실행됩니다 . &lt;code&gt;use&lt;/code&gt; 후 명시적인 공간을 통해 이것이 단일 컴파일 타임 작업임을 분명히 알 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1f7c25b6745f51eae37c62a2374f7ba131484e1b" translate="yes" xml:space="preserve">
          <source>With this option, the rendering of each statement (starting with the nextstate OP) will be preceded by the 1st line of source code that generates it. For example:</source>
          <target state="translated">이 옵션을 사용하면 각 명령문의 렌더링 (다음 상태 OP로 시작) 앞에 생성 된 소스 코드의 첫 번째 줄이옵니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8f18c563efb0b7956e6e194500e98dba172fcbe5" translate="yes" xml:space="preserve">
          <source>With this syntax, the whitespace character(s) after the &quot;C&amp;lt;&amp;lt;&amp;lt;&quot; and before the &quot;&amp;gt;&amp;gt;&amp;gt;&quot; (or whatever letter) are</source>
          <target state="translated">이 구문에서 &quot;C &amp;lt;&amp;lt;&amp;lt;&quot;다음과 &quot;&amp;gt;&amp;gt;&amp;gt;&quot;앞의 공백 문자 (또는 문자)는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9b739cdb3f9d5a8eac7c3872d89896d374a02d63" translate="yes" xml:space="preserve">
          <source>With this, &quot;somepackage&quot; will be required, then the stash is inspected, and each function is rendered.</source>
          <target state="translated">이를 통해 &quot;somepackage&quot;가 필요하고 숨김이 검사되고 각 기능이 렌더링됩니다.</target>
        </trans-unit>
        <trans-unit id="a5fec2f4d5db8c4f13f212d9ea51033367a444e6" translate="yes" xml:space="preserve">
          <source>With this, &lt;code&gt;charinrange()&lt;/code&gt; will return &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; if its input code point maps to &lt;code&gt;$default&lt;/code&gt; . You can avoid this by omitting the &lt;code&gt;&lt;a href=&quot;../functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; statement, and adding a line after the loop to handle the final element of the inversion map.</source>
          <target state="translated">이것으로 &lt;code&gt;charinrange()&lt;/code&gt; 는 입력 코드 포인트가 &lt;code&gt;$default&lt;/code&gt; 매핑되면 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 를 반환 합니다. &lt;code&gt;&lt;a href=&quot;../functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; 명령문 을 생략하고 루프 뒤에 줄을 추가하여 반전 맵의 최종 요소를 처리하면 이를 피할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1fa4ea5d2b0cc15e776882f8e7626028cc55d8d1" translate="yes" xml:space="preserve">
          <source>With this, &lt;code&gt;charinrange()&lt;/code&gt; will return &lt;code&gt;undef&lt;/code&gt; if its input code point maps to &lt;code&gt;$default&lt;/code&gt;. You can avoid this by omitting the &lt;code&gt;next&lt;/code&gt; statement, and adding a line after the loop to handle the final element of the inversion map.</source>
          <target state="translated">이를 통해 &lt;code&gt;charinrange()&lt;/code&gt; 는 입력 코드 포인트가 &lt;code&gt;$default&lt;/code&gt; 매핑되면 &lt;code&gt;undef&lt;/code&gt; 를 반환 합니다. &lt;code&gt;next&lt;/code&gt; 문 을 생략하고 루프 뒤에 줄을 추가하여 반전 맵의 마지막 요소를 처리하여 이를 방지 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="cf65bbf1a94d413d2ba7d4e9b042fb1c11c5b955" translate="yes" xml:space="preserve">
          <source>With those two in hand, you should add</source>
          <target state="translated">이 두 가지를 손에 들고 다음을 추가해야합니다.</target>
        </trans-unit>
        <trans-unit id="6dae05359217975cb78e41e5b34deca474650edf" translate="yes" xml:space="preserve">
          <source>With threads one must be careful to make sure they all have a chance to run to completion, assuming that is what you want.</source>
          <target state="translated">스레드를 사용하면 원하는 것을 가정하고 모두 완료 될 수 있도록주의해야합니다.</target>
        </trans-unit>
        <trans-unit id="caa257633e4cd0d103eaaa262d9da80593127c23" translate="yes" xml:space="preserve">
          <source>With todo tests, it's best to have the tests actually run. That way you'll know when they start passing. Sometimes this isn't possible. Often a failing test will cause the whole program to die or hang, even inside an &lt;code&gt;&lt;a href=&quot;../functions/eval&quot;&gt;eval&lt;/a&gt; BLOCK&lt;/code&gt; with and using &lt;code&gt;&lt;a href=&quot;../functions/alarm&quot;&gt;alarm&lt;/a&gt;&lt;/code&gt;. In these extreme cases you have no choice but to skip over the broken tests entirely.</source>
          <target state="translated">할일 테스트에서는 실제로 테스트를 실행하는 것이 가장 좋습니다. 그렇게하면 그들이지나 가기 시작할 때 알게됩니다. 때때로 이것은 불가능합니다. 종종 테스트에 실패 하면 &lt;code&gt;&lt;a href=&quot;../functions/alarm&quot;&gt;alarm&lt;/a&gt;&lt;/code&gt; 사용하거나 사용 하는 &lt;code&gt;&lt;a href=&quot;../functions/eval&quot;&gt;eval&lt;/a&gt; BLOCK&lt;/code&gt; 내부에서도 전체 프로그램이 죽거나 정지 됩니다. 이러한 극단적 인 경우에는 깨진 테스트를 완전히 건너 뛸 수밖에 없습니다.</target>
        </trans-unit>
        <trans-unit id="72faa2ea768ae70d5c7c6ca8ac92ad17c2ec51b0" translate="yes" xml:space="preserve">
          <source>With todo tests, it's best to have the tests actually run. That way you'll know when they start passing. Sometimes this isn't possible. Often a failing test will cause the whole program to die or hang, even inside an &lt;code&gt;eval BLOCK&lt;/code&gt; with and using &lt;code&gt;alarm&lt;/code&gt;. In these extreme cases you have no choice but to skip over the broken tests entirely.</source>
          <target state="translated">할일 테스트를 사용하면 테스트를 실제로 실행하는 것이 가장 좋습니다. 그렇게하면 그들이지나 가기 시작할 때 알 수 있습니다. 때때로 이것은 불가능합니다. 종종 실패한 테스트는 &lt;code&gt;alarm&lt;/code&gt; 사용하고 있는 &lt;code&gt;eval BLOCK&lt;/code&gt; 내부에서도 전체 프로그램이 죽거나 멈추는 원인이됩니다 . 이러한 극단적 인 경우에는 깨진 테스트를 완전히 건너 뛸 수밖에 없습니다.</target>
        </trans-unit>
        <trans-unit id="ec0e094c2438c09cc3dbc2cdfeb2a697dd782dc5" translate="yes" xml:space="preserve">
          <source>Within &lt;code&gt;(?[ ])&lt;/code&gt; , no literal characters are allowed unless they are within an inner pair of square brackets, like</source>
          <target state="translated">&lt;code&gt;(?[ ])&lt;/code&gt; 내에서 리터럴 문자는 내부 대괄호 안에 있지 않으면 허용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2c0a661c629aabc7b0ae903d13c19ad238648286" translate="yes" xml:space="preserve">
          <source>Within &lt;code&gt;(?[ ])&lt;/code&gt;, no literal characters are allowed unless they are within an inner pair of square brackets, like</source>
          <target state="translated">&lt;code&gt;(?[ ])&lt;/code&gt; 내에서 리터럴 문자는 다음과 같이 내부 대괄호 쌍 안에 있지 않는 한 허용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2e8425db1df10e66ba739a46b6d044fcd9cc27fd" translate="yes" xml:space="preserve">
          <source>Within Perl, you may use this directly:</source>
          <target state="translated">Perl 내에서 직접 사용할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="34e265601157e7965a7e7bfdb3408a61baf139df" translate="yes" xml:space="preserve">
          <source>Within USS your /etc/profile or $HOME/.profile may limit your ulimit settings. Check that the following command returns reasonable values:</source>
          <target state="translated">USS 내에서 / etc / profile 또는 $ HOME / .profile이 ulimit 설정을 제한 할 수 있습니다. 다음 명령이 적절한 값을 반환하는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="a1b6f4407e8eee6ed8eafbd79c8d18589c6adc10" translate="yes" xml:space="preserve">
          <source>Within []-length '%c' not allowed</source>
          <target state="translated">[]-길이 '% c'이내는 허용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="29ba20619ba09719c47471e336e4ab5403150666" translate="yes" xml:space="preserve">
          <source>Within a Pod block, there are &lt;b&gt;Pod paragraphs&lt;/b&gt;. A Pod paragraph consists of non-blank lines of text, separated by one or more blank lines.</source>
          <target state="translated">포드 블록 내에는 &lt;b&gt;포드 단락이&lt;/b&gt; 있습니다. 포드 단락은 공백이 아닌 텍스트 줄로 구성되며 하나 이상의 빈 줄로 구분됩니다.</target>
        </trans-unit>
        <trans-unit id="e21031e24f9ec987f957a61688b27e62b9c110c1" translate="yes" xml:space="preserve">
          <source>Within a character class:</source>
          <target state="translated">캐릭터 클래스 내에서 :</target>
        </trans-unit>
        <trans-unit id="40c178236d58dee9559c7a2a4195e7fba2bd546e" translate="yes" xml:space="preserve">
          <source>Within a pattern, you may designate subpatterns for later reference by enclosing them in parentheses, and you may refer back to the</source>
          <target state="translated">패턴 내에서 나중에 참조 할 수 있도록 하위 패턴을 괄호로 묶어 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0cfdb7962d912e72a66b4f3d5343b1e5e212ac27" translate="yes" xml:space="preserve">
          <source>Within a subroutine the array &lt;code&gt;@_&lt;/code&gt; contains the parameters passed to that subroutine. Inside a subroutine, &lt;code&gt;@_&lt;/code&gt; is the default array for the array operators &lt;code&gt;&lt;a href=&quot;functions/push&quot;&gt;push&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/pop&quot;&gt;pop&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/shift&quot;&gt;shift&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;functions/unshift&quot;&gt;unshift&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">서브 루틴 내에서 배열 &lt;code&gt;@_&lt;/code&gt; 서브 루틴에 전달 된 매개 변수가 포함되어 있습니다. 서브 루틴 내에서 &lt;code&gt;@_&lt;/code&gt; 은 배열 연산자 &lt;code&gt;&lt;a href=&quot;functions/push&quot;&gt;push&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/pop&quot;&gt;pop&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/shift&quot;&gt;shift&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;functions/unshift&quot;&gt;unshift&lt;/a&gt;&lt;/code&gt; 의 기본 배열입니다 .</target>
        </trans-unit>
        <trans-unit id="e22e0024e5aeb5956fe2008749d86a9a403a100c" translate="yes" xml:space="preserve">
          <source>Within a subroutine the array &lt;code&gt;@_&lt;/code&gt; contains the parameters passed to that subroutine. Inside a subroutine, &lt;code&gt;@_&lt;/code&gt; is the default array for the array operators &lt;code&gt;pop&lt;/code&gt; and &lt;code&gt;shift&lt;/code&gt;.</source>
          <target state="translated">서브 루틴 내에서 배열 &lt;code&gt;@_&lt;/code&gt; 는 해당 서브 루틴에 전달 된 매개 변수를 포함합니다. 서브 루틴 내에서 &lt;code&gt;@_&lt;/code&gt; 는 배열 연산자 &lt;code&gt;pop&lt;/code&gt; 및 &lt;code&gt;shift&lt;/code&gt; 의 기본 배열입니다 .</target>
        </trans-unit>
        <trans-unit id="61eb6fb3f1061f743841ee282bbf0ef293486491" translate="yes" xml:space="preserve">
          <source>Within each function inside each Xsub, print to the</source>
          <target state="translated">각 Xsub 내부의 각 함수 내에서</target>
        </trans-unit>
        <trans-unit id="2ab4fe9703eceeab90b6dcb41e63f66c50a795d5" translate="yes" xml:space="preserve">
          <source>Within search patterns (which also undergo double-quotish substitution) there is an unfortunate ambiguity: Is &lt;code&gt;/$foo[bar]/&lt;/code&gt; to be interpreted as &lt;code&gt;/${foo}[bar]/&lt;/code&gt; (where &lt;code&gt;[bar]&lt;/code&gt; is a character class for the regular expression) or as &lt;code&gt;/${foo[bar]}/&lt;/code&gt; (where &lt;code&gt;[bar]&lt;/code&gt; is the subscript to array @foo)? If @foo doesn't otherwise exist, then it's obviously a character class. If @foo exists, Perl takes a good guess about &lt;code&gt;[bar]&lt;/code&gt; , and is almost always right. If it does guess wrong, or if you're just plain paranoid, you can force the correct interpretation with curly braces as above.</source>
          <target state="translated">검색 패턴 내에 (큰 따옴표로 대체 됨) 불행한 모호성이 있습니다. &lt;code&gt;/$foo[bar]/&lt;/code&gt; 는 &lt;code&gt;/${foo}[bar]/&lt;/code&gt; 로 해석되어야합니다 (여기서 &lt;code&gt;[bar]&lt;/code&gt; 는 정규 표현식) 또는 &lt;code&gt;/${foo[bar]}/&lt;/code&gt; (여기서 &lt;code&gt;[bar]&lt;/code&gt; 는 @foo를 배열하는 첨자입니다)? @foo가 존재하지 않으면 분명히 문자 클래스입니다. @foo가 존재한다면 Perl은 &lt;code&gt;[bar]&lt;/code&gt; 에 대해 좋은 추측을 하고 거의 항상 옳습니다. 그것이 잘못 추측되거나 평범한 편집증이라면 위와 같이 중괄호로 올바른 해석을 강요 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7cb74f80aa6eb14f52d2f4452df6c30aa1982c05" translate="yes" xml:space="preserve">
          <source>Within search patterns (which also undergo double-quotish substitution) there is an unfortunate ambiguity: Is &lt;code&gt;/$foo[bar]/&lt;/code&gt; to be interpreted as &lt;code&gt;/${foo}[bar]/&lt;/code&gt; (where &lt;code&gt;[bar]&lt;/code&gt; is a character class for the regular expression) or as &lt;code&gt;/${foo[bar]}/&lt;/code&gt; (where &lt;code&gt;[bar]&lt;/code&gt; is the subscript to array @foo)? If @foo doesn't otherwise exist, then it's obviously a character class. If @foo exists, Perl takes a good guess about &lt;code&gt;[bar]&lt;/code&gt;, and is almost always right. If it does guess wrong, or if you're just plain paranoid, you can force the correct interpretation with curly braces as above.</source>
          <target state="translated">검색 패턴 (큰 따옴표로 대체 됨) 내에는 불행한 모호성이 있습니다. &lt;code&gt;/$foo[bar]/&lt;/code&gt; 는 &lt;code&gt;/${foo}[bar]/&lt;/code&gt; 로 해석됩니다 (여기서 &lt;code&gt;[bar]&lt;/code&gt; 는 정규식) 또는 &lt;code&gt;/${foo[bar]}/&lt;/code&gt; (여기서 &lt;code&gt;[bar]&lt;/code&gt; 는 @foo 배열의 첨자 임)? @foo가 없으면 분명히 문자 클래스입니다. @foo가 존재하면 Perl은 &lt;code&gt;[bar]&lt;/code&gt; 에 대해 잘 추측 하고 거의 항상 옳습니다. 추측이 틀리거나 단순한 편집증이라면 위와 같이 중괄호를 사용하여 올바른 해석을 강요 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d84dbb525d8c49a11b671ff1144decfba831a5a9" translate="yes" xml:space="preserve">
          <source>Within strings that are to be displayed in a fixed-length text field, each control character is substituted by a space. (But remember the special meaning of &lt;code&gt;\r&lt;/code&gt; when using fill mode.) This is done to avoid misalignment when control characters &quot;disappear&quot; on some output media.</source>
          <target state="translated">고정 길이 텍스트 필드에 표시 될 문자열 내에서 각 제어 문자는 공백으로 대체됩니다. ( 채우기 모드를 사용할 때 &lt;code&gt;\r&lt;/code&gt; 의 특별한 의미를 기억하십시오 .) 이것은 일부 출력 매체에서 제어 문자가 &quot;사라질&quot;때 정렬 오류를 피하기 위해 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="4456754ccf74e411d5ea49ec8792a5f2c7c3945a" translate="yes" xml:space="preserve">
          <source>Within that basic form, add the parts that you need to insert, change, or delete lines.</source>
          <target state="translated">해당 기본 양식 내에 선을 삽입, 변경 또는 삭제하는 데 필요한 부품을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="8cbc5afc548aa028061d92c2e27d708ba5cdc361" translate="yes" xml:space="preserve">
          <source>Within that module, create an &lt;code&gt;&lt;a href=&quot;../functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; subroutine.</source>
          <target state="translated">해당 모듈 내에서 &lt;code&gt;&lt;a href=&quot;../functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; 서브 루틴을 작성하십시오 .</target>
        </trans-unit>
        <trans-unit id="dff20e9d902ef01082006d18ff0c36d8795b519a" translate="yes" xml:space="preserve">
          <source>Within that module, create an &lt;code&gt;import&lt;/code&gt; subroutine.</source>
          <target state="translated">해당 모듈 내에서 &lt;code&gt;import&lt;/code&gt; 서브 루틴을 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="8c44a88f26bc68b39089193962c587ad7e818543" translate="yes" xml:space="preserve">
          <source>Within the &lt;code&gt;&lt;a href=&quot;../functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; subroutine do a call to &lt;code&gt;filter_add&lt;/code&gt; , passing it either a subroutine reference.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; 서브 루틴 내에서 &lt;code&gt;filter_add&lt;/code&gt; 를 호출하여 서브 루틴 참조를 전달하십시오.</target>
        </trans-unit>
        <trans-unit id="5abecf0e7e2c92cb0f99df6a077dc9ac3a61e15b" translate="yes" xml:space="preserve">
          <source>Within the &lt;code&gt;import&lt;/code&gt; subroutine do a call to &lt;code&gt;filter_add&lt;/code&gt;, passing it either a subroutine reference.</source>
          <target state="translated">&lt;code&gt;import&lt;/code&gt; 서브 루틴 내에서 &lt;code&gt;filter_add&lt;/code&gt; 에 대한 호출을 수행 하여 서브 루틴 참조 중 하나를 전달합니다.</target>
        </trans-unit>
        <trans-unit id="66ccfeaad3b7f2de2f94c5b7b2a2afe57c62216c" translate="yes" xml:space="preserve">
          <source>Within the alternative numbering group, group numbers start at the same position for each alternative. After the group, numbering continues with one higher than the maximum reached across all the alternatives.</source>
          <target state="translated">대체 번호 그룹 내에서 그룹 번호는 각 대안에 대해 동일한 위치에서 시작합니다. 그룹 후에는 모든 대안에서 도달 한 최대 값보다 하나 높은 번호가 계속 부여됩니다.</target>
        </trans-unit>
        <trans-unit id="bee307dd55ae8e02f4730b754c6aca4828fa5f41" translate="yes" xml:space="preserve">
          <source>Within the anonymous subroutine or block that is passed to &lt;code&gt;FILTER&lt;/code&gt; , process the contents of $_ to change the source code in the desired manner.</source>
          <target state="translated">&lt;code&gt;FILTER&lt;/code&gt; 로 전달되는 익명 서브 루틴 또는 블록 내에서 $ _의 내용을 처리하여 원하는 방식으로 소스 코드를 변경하십시오.</target>
        </trans-unit>
        <trans-unit id="f2c9c97c479e458c15e3c5d21939c42abe0d2569" translate="yes" xml:space="preserve">
          <source>Within the anonymous subroutine or block that is passed to &lt;code&gt;FILTER&lt;/code&gt;, process the contents of $_ to change the source code in the desired manner.</source>
          <target state="translated">&lt;code&gt;FILTER&lt;/code&gt; 에 전달 된 익명 서브 루틴 또는 블록 내에서 $ _의 내용을 처리하여 원하는 방식으로 소스 코드를 변경합니다.</target>
        </trans-unit>
        <trans-unit id="4dffaf4183817eca592a98bbc21aa16f78f04d43" translate="yes" xml:space="preserve">
          <source>Within the scope of &lt;a href=&quot;feature#The-%27unicode_strings%27-feature&quot;&gt;&lt;code&gt;use feature 'unicode_strings'&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;feature#The-%27unicode_strings%27-feature&quot;&gt; &lt;code&gt;use feature 'unicode_strings'&lt;/code&gt; &lt;/a&gt; 의 범위 내</target>
        </trans-unit>
        <trans-unit id="00c20e56f1d9e34b6bd5de0acc2c9d7db7958c51" translate="yes" xml:space="preserve">
          <source>Within the scope of &lt;a href=&quot;feature#The-'unicode_strings'-feature&quot;&gt;use feature 'unicode_strings' &lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;feature#The-'unicode_strings'-feature&quot;&gt;사용&lt;/a&gt; 범위 내 기능 'unicode_strings'</target>
        </trans-unit>
        <trans-unit id="4f89e477d30d08ce7cdab550d7ebf952c865e297" translate="yes" xml:space="preserve">
          <source>Within the scope of &lt;a href=&quot;locale&quot;&gt;&lt;code&gt;use locale&lt;/code&gt;&lt;/a&gt;, all non-ASCII Latin1 code points are quoted whether the string is encoded as UTF-8 or not. As mentioned above, locale does not affect the quoting of ASCII-range characters. This protects against those locales where characters such as &lt;code&gt;&quot;|&quot;&lt;/code&gt; are considered to be word characters.</source>
          <target state="translated">&lt;a href=&quot;locale&quot;&gt; &lt;code&gt;use locale&lt;/code&gt; &lt;/a&gt; 범위 내에서 모든 비 ASCII Latin1 코드 포인트는 문자열이 UTF-8로 인코딩되었는지 여부에 관계없이 인용됩니다. 위에서 언급했듯이 로케일은 ASCII 범위 문자의 인용에 영향을주지 않습니다. 이것은 &lt;code&gt;&quot;|&quot;&lt;/code&gt; 와 같은 문자가있는 로케일로부터 보호합니다. 단어 문자로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="5cdd83d3707c192ff676dcfeb7f714897a412bb4" translate="yes" xml:space="preserve">
          <source>Within the scope of &lt;a href=&quot;perllocale#Unicode-and-UTF-8&quot;&gt;&lt;code&gt;use locale 'not_characters'&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;perllocale&quot;&gt;&lt;code&gt;use locale&lt;/code&gt;&lt;/a&gt; and the current locale is a UTF-8 locale.</source>
          <target state="translated">&lt;a href=&quot;perllocale#Unicode-and-UTF-8&quot;&gt; &lt;code&gt;use locale 'not_characters'&lt;/code&gt; &lt;/a&gt; 범위 내에서 또는 &lt;a href=&quot;perllocale&quot;&gt; &lt;code&gt;use locale&lt;/code&gt; &lt;/a&gt; 하고 현재 로케일은 UTF-8 로케일입니다.</target>
        </trans-unit>
        <trans-unit id="db5115b248b9b3a92796783fe0ad72c64d3ee250" translate="yes" xml:space="preserve">
          <source>Within the scope of &lt;a href=&quot;perllocale#Unicode-and-UTF-8&quot;&gt;use locale 'not_characters' &lt;/a&gt;, or &lt;a href=&quot;perllocale&quot;&gt;use locale &lt;/a&gt; and the current locale is a UTF-8 locale.</source>
          <target state="translated">&lt;a href=&quot;perllocale#Unicode-and-UTF-8&quot;&gt;사용&lt;/a&gt; 범위 내에서 로케일 'not_characters' 또는 &lt;a href=&quot;perllocale&quot;&gt;로케일을 사용&lt;/a&gt; 하고 현재 로케일은 UTF-8 로케일입니다.</target>
        </trans-unit>
        <trans-unit id="4b75686c25d4349996112a3e43d160bed9377b64" translate="yes" xml:space="preserve">
          <source>Within the scope of &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; 5.012&lt;/code&gt; or higher</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; 5.012&lt;/code&gt; 범위 5.012 이상</target>
        </trans-unit>
        <trans-unit id="921e8cdb506222d3c5cb715870308743278f73c9" translate="yes" xml:space="preserve">
          <source>Within the scope of &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; , all non-ASCII Latin1 code points are quoted whether the string is encoded as UTF-8 or not. As mentioned above, locale does not affect the quoting of ASCII-range characters. This protects against those locales where characters such as &lt;code&gt;&quot;|&quot;&lt;/code&gt; are considered to be word characters.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; 범위 locale 에서 모든 비 ASCII Latin1 코드 포인트는 문자열이 UTF-8로 인코딩되는지 여부에 따라 인용됩니다. 위에서 언급했듯이 로케일은 ASCII 범위 문자의 인용에 영향을 미치지 않습니다. 이것은 &lt;code&gt;&quot;|&quot;&lt;/code&gt; 와 같은 문자가있는 로케일로부터 보호합니다. 단어 문자로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="7f97b0baeb5c1f48ecb7c6036a913594c0cf832a" translate="yes" xml:space="preserve">
          <source>Within the scope of &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; 범위 내에서 utf8</target>
        </trans-unit>
        <trans-unit id="6c6da8dacdcff581b760f12d305142c260f19722" translate="yes" xml:space="preserve">
          <source>Within the scope of &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; , all non-ASCII Latin1 code points are quoted whether the string is encoded as UTF-8 or not. As mentioned above, locale does not affect the quoting of ASCII-range characters. This protects against those locales where characters such as &lt;code&gt;&quot;|&quot;&lt;/code&gt; are considered to be word characters.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; 범위 locale 에서 모든 비 ASCII Latin1 코드 포인트는 문자열이 UTF-8로 인코딩되는지 여부에 따라 인용됩니다. 위에서 언급했듯이 로케일은 ASCII 범위 문자의 인용에 영향을 미치지 않습니다. 이것은 &lt;code&gt;&quot;|&quot;&lt;/code&gt; 와 같은 문자가있는 로케일로부터 보호합니다. 단어 문자로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="9be64790ef4be673df7cd3468e821cd802e4c982" translate="yes" xml:space="preserve">
          <source>Within the scope of &lt;code&gt;use 5.012&lt;/code&gt; or higher</source>
          <target state="translated">&lt;code&gt;use 5.012&lt;/code&gt; 이상 사용 범위 내</target>
        </trans-unit>
        <trans-unit id="c2f08cf765adbbec5334990e6d1e73f436a06d62" translate="yes" xml:space="preserve">
          <source>Within the scope of &lt;code&gt;use re 'strict'&lt;/code&gt; in a regular expression pattern, you included an unescaped &lt;code&gt;}&lt;/code&gt; or &lt;code&gt;]&lt;/code&gt; which was interpreted literally. These two characters are sometimes metacharacters, and sometimes literals, depending on what precedes them in the pattern. This is unlike the similar &lt;code&gt;)&lt;/code&gt; which is always a metacharacter unless escaped.</source>
          <target state="translated">정규식 패턴 의 &lt;code&gt;use re 'strict'&lt;/code&gt; 범위 내에서 문자 그대로 해석되는 이스케이프 처리되지 않은 &lt;code&gt;}&lt;/code&gt; 또는 &lt;code&gt;]&lt;/code&gt; 를 포함했습니다 . 이 두 문자는 패턴에서 앞에 오는 문자에 따라 때때로 메타 문자이고 때로는 리터럴입니다. 이것은 이스케이프되지 않는 한 항상 메타 문자 인 유사한 &lt;code&gt;)&lt;/code&gt; 과는 다릅니다 .</target>
        </trans-unit>
        <trans-unit id="872708d75ba2c62155c9282b19d1ffd74c4ecb87" translate="yes" xml:space="preserve">
          <source>Within the scope of &lt;code&gt;use utf8&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;use utf8&lt;/code&gt; 범위 내 utf8</target>
        </trans-unit>
        <trans-unit id="b93e8b9c84e9c172138891ffbac960fd8330a481" translate="yes" xml:space="preserve">
          <source>Within the subroutine reference, call &lt;code&gt;filter_read&lt;/code&gt; or &lt;code&gt;filter_read_exact&lt;/code&gt; to &quot;prime&quot; $_ with source code data from the source file that will &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; your module. Check the status value returned to see if any source code was actually read in.</source>
          <target state="translated">서브 루틴 참조 내에서 &lt;code&gt;filter_read&lt;/code&gt; 또는 &lt;code&gt;filter_read_exact&lt;/code&gt; 를 호출 하여 모듈 을 &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 소스 파일의 소스 코드 데이터로 $ _를 &quot;프라임&quot;$ _ 하십시오. 리턴 된 상태 값을 확인하여 소스 코드를 실제로 읽었는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="de9983c2f6aa6265b66999a54845fc283501a6b7" translate="yes" xml:space="preserve">
          <source>Within the subroutine reference, call &lt;code&gt;filter_read&lt;/code&gt; or &lt;code&gt;filter_read_exact&lt;/code&gt; to &quot;prime&quot; $_ with source code data from the source file that will &lt;code&gt;use&lt;/code&gt; your module. Check the status value returned to see if any source code was actually read in.</source>
          <target state="translated">서브 루틴 참조 내에서 &lt;code&gt;filter_read&lt;/code&gt; 또는 &lt;code&gt;filter_read_exact&lt;/code&gt; 를 호출 하여 모듈 을 &lt;code&gt;use&lt;/code&gt; 소스 파일의 소스 코드 데이터로 $ _ &quot;prime&quot; 합니다. 반환 된 상태 값을 확인하여 소스 코드가 실제로 읽혔는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="7d5ec220eb3f4bb73f8ef5f923e39ec8ab09a071" translate="yes" xml:space="preserve">
          <source>Within the while loop we call accept() and check to see if it returns a false value. This would normally indicate a system error needs to be reported. However, the introduction of safe signals (see &lt;a href=&quot;#Deferred-Signals-%28Safe-Signals%29&quot;&gt;&quot;Deferred Signals (Safe Signals)&quot;&lt;/a&gt; above) in Perl 5.8.0 means that accept() might also be interrupted when the process receives a signal. This typically happens when one of the forked subprocesses exits and notifies the parent process with a CHLD signal.</source>
          <target state="translated">while 루프 내에서 accept ()를 호출하고 false 값을 반환하는지 확인합니다. 이는 일반적으로 시스템 오류를보고해야 함을 나타냅니다. 그러나 Perl 5.8.0에서 &lt;a href=&quot;#Deferred-Signals-%28Safe-Signals%29&quot;&gt;안전 신호 (&lt;/a&gt; 위의 &quot;지연된 신호 (안전 신호)&quot; 참조)를 도입하면 프로세스가 신호를 수신 할 때 accept ()도 중단 될 수 있습니다. 이는 일반적으로 분기 된 하위 프로세스 중 하나가 종료되고 부모 프로세스에 CHLD 신호로 알릴 때 발생합니다.</target>
        </trans-unit>
        <trans-unit id="4f5dc8da9477105396ff0284ea2a7a7433b232a3" translate="yes" xml:space="preserve">
          <source>Within the while loop we call accept() and check to see if it returns a false value. This would normally indicate a system error needs to be reported. However, the introduction of safe signals (see &lt;a href=&quot;#Deferred-Signals-(Safe-Signals)&quot;&gt;Deferred Signals (Safe Signals)&lt;/a&gt; above) in Perl 5.8.0 means that accept() might also be interrupted when the process receives a signal. This typically happens when one of the forked subprocesses exits and notifies the parent process with a CHLD signal.</source>
          <target state="translated">while 루프 내에서 accept ()를 호출하고 false 값을 반환하는지 확인합니다. 이는 일반적으로 시스템 오류가보고되어야 함을 나타냅니다. 그러나 Perl 5.8.0에 &lt;a href=&quot;#Deferred-Signals-(Safe-Signals)&quot;&gt;안전 신호 (&lt;/a&gt; 위의 지연 신호 (안전 신호) 참조)가 도입되면 프로세스가 신호를 수신 할 때 accept ()도 중단 될 수 있습니다. 이는 일반적으로 분기 된 하위 프로세스 중 하나가 종료되고 CHLD 신호로 상위 프로세스에 알릴 때 발생합니다.</target>
        </trans-unit>
        <trans-unit id="17b7808b8c8156fa9926b089d73ad2021671fe67" translate="yes" xml:space="preserve">
          <source>Without Readline support you may see the symbols &quot;^[[A&quot;, &quot;^[[C&quot;, &quot;^[[B&quot;, &quot;^[[D&quot;&quot;, &quot;^H&quot;, ... when using the arrow keys and/or the backspace key.</source>
          <target state="translated">Readline 지원이 없으면 화살표 키를 사용할 때 &quot;^ [[A&quot;, &quot;^ [[C&quot;, &quot;^ [[B&quot;, &quot;^ [[D&quot; &quot;,&quot;^ H &quot;, ...) 기호가 표시 될 수 있습니다. 및 / 또는 백 스페이스 키.</target>
        </trans-unit>
        <trans-unit id="7a72072ff5468f365a1052f00033c60b07221002" translate="yes" xml:space="preserve">
          <source>Without additional configuration, GetOptions() will ignore the case of option names, and allow the options to be abbreviated to uniqueness.</source>
          <target state="translated">추가 구성이 없으면 GetOptions ()는 옵션 이름의 경우를 무시하고 옵션을 고유성으로 줄여줍니다.</target>
        </trans-unit>
        <trans-unit id="6c913350e18f669953ddd82b1ef504eb99115e6c" translate="yes" xml:space="preserve">
          <source>Without any such configuration, or if Perl itself is built using the system's own IO, then write operations assume that the file handle accepts only</source>
          <target state="translated">그러한 구성이 없거나 Perl 자체가 시스템의 자체 IO를 사용하여 빌드 된 경우 쓰기 작업은 파일 핸들이</target>
        </trans-unit>
        <trans-unit id="298442b657e2392a0a1bf4ca9f3ba61c68419ef3" translate="yes" xml:space="preserve">
          <source>Without argument, it returns the currently used icmp protocol message type. By default, it returns 'echo'.</source>
          <target state="translated">인수없이 현재 사용되는 icmp 프로토콜 메시지 유형을 반환합니다. 기본적으로 'echo'를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d5efb30492f1c199d1a2c0cf117a4ad4a638df64" translate="yes" xml:space="preserve">
          <source>Without argument, retrieves a regular expression for simplifying the individual item strings once the list type has been determined. Usage: E.g. when converting to HTML, one might strip the leading number in an ordered list as &lt;code&gt;&amp;lt;OL&amp;gt;&lt;/code&gt; already prints numbers itself. This must have been set before by either specifying &lt;b&gt;-rx&lt;/b&gt; in the &lt;b&gt;new()&lt;/b&gt; method or by calling the &lt;b&gt;rx()&lt;/b&gt; method with a scalar argument.</source>
          <target state="translated">인수없이, 목록 유형이 결정되면 개별 항목 문자열을 단순화하기위한 정규식을 검색합니다. 사용법 : 예를 들어 HTML로 변환 할 때 &lt;code&gt;&amp;lt;OL&amp;gt;&lt;/code&gt; 이 이미 숫자 자체를 인쇄 하므로 순서 목록에서 선행 숫자를 제거 할 수 있습니다. &lt;b&gt;new ()&lt;/b&gt; 메소드 에서 &lt;b&gt;-rx&lt;/b&gt; 를 지정 하거나 스칼라 인수로 &lt;b&gt;rx ()&lt;/b&gt; 메소드를 호출하여 설정해야합니다 .&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="18657a3de0c78898530507337e291d8dba0f72cc" translate="yes" xml:space="preserve">
          <source>Without argument, retrieves information about the list tag, which can be any scalar. This must have been set before by either specifying &lt;b&gt;-tag&lt;/b&gt; in the &lt;b&gt;new()&lt;/b&gt; method or by calling the &lt;b&gt;tag()&lt;/b&gt; method with a scalar argument.</source>
          <target state="translated">인수없이, 스칼라 일 수있는 목록 태그에 대한 정보를 검색합니다. &lt;b&gt;new ()&lt;/b&gt; 메소드 에서 &lt;b&gt;-tag&lt;/b&gt; 를 지정 하거나 스칼라 인수로 &lt;b&gt;tag ()&lt;/b&gt; 메소드를 호출하여 이전에 설정되어 있어야합니다 .&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="8ccc25a668b5326c657bc2f5c79197991b145ee7" translate="yes" xml:space="preserve">
          <source>Without argument, retrieves information about the parent holding this list, which is represented as an arbitrary scalar. This must have been set before by either specifying &lt;b&gt;-parent&lt;/b&gt; in the &lt;b&gt;new()&lt;/b&gt; method or by calling the &lt;b&gt;parent()&lt;/b&gt; method with a scalar argument.</source>
          <target state="translated">인수없이이리스트를 보유하는 부모에 대한 정보를 검색하며, 이는 임의의 스칼라로 표시됩니다. &lt;b&gt;new ()&lt;/b&gt; 메소드 에서 &lt;b&gt;-parent&lt;/b&gt; 를 지정 하거나 스칼라 인수와 함께 &lt;b&gt;parent ()&lt;/b&gt; 메소드를 호출하여 설정해야합니다 .&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="c9f5dc6cba8c17ba8a8e789cb997502b75241827" translate="yes" xml:space="preserve">
          <source>Without argument, retrieves the array of the items in this list. The items may be represented by any scalar. If an argument has been given, it is pushed on the list of items.</source>
          <target state="translated">인수없이이 목록에있는 항목의 배열을 검색합니다. 항목은 임의의 스칼라로 표시 될 수 있습니다. 인수가 주어지면 항목 목록에서 푸시됩니다.</target>
        </trans-unit>
        <trans-unit id="b13b7cf761d2e7e6717a0226cb08e73a66d55812" translate="yes" xml:space="preserve">
          <source>Without argument, retrieves the file name the list is in. This must have been set before by either specifying &lt;b&gt;-file&lt;/b&gt; in the &lt;b&gt;new()&lt;/b&gt; method or by calling the &lt;b&gt;file()&lt;/b&gt; method with a scalar argument.</source>
          <target state="translated">인수가 없으면, 목록에있는 파일 이름을 검색합니다.이 틀림 설정을하기 전에 하나 지정에 의해 &lt;b&gt;- 파일&lt;/b&gt; 에서&lt;b&gt; new ()&lt;/b&gt; 메소드 하거나 스칼라 인수와 함께 &lt;b&gt;file ()&lt;/b&gt; 메소드를 호출하여 .</target>
        </trans-unit>
        <trans-unit id="1b1eba0344418f60cab2e73b154b51b8cc2fd939" translate="yes" xml:space="preserve">
          <source>Without argument, retrieves the indent level of the list as specified in &lt;code&gt;=over n&lt;/code&gt; . This must have been set before by either specifying &lt;b&gt;-indent&lt;/b&gt; in the &lt;b&gt;new()&lt;/b&gt; method or by calling the &lt;b&gt;indent()&lt;/b&gt; method with a scalar argument.</source>
          <target state="translated">인수가 없으면 &lt;code&gt;=over n&lt;/code&gt; 에 지정된대로 목록의 들여 쓰기 레벨을 검색합니다 . &lt;b&gt;new ()&lt;/b&gt; 에서 &lt;b&gt;-indent&lt;/b&gt; 를 지정하여 이전에 설정 &lt;b&gt;했어야&lt;/b&gt; 합니다.&lt;b&gt;&lt;/b&gt; 메소드 하거나 스칼라 인수로 &lt;b&gt;indent ()&lt;/b&gt; 메소드를 호출하여 .</target>
        </trans-unit>
        <trans-unit id="c3a863e0f35dbdfaea66e845edf4708bb6d53918" translate="yes" xml:space="preserve">
          <source>Without argument, retrieves the line number where the list started. This must have been set before by either specifying &lt;b&gt;-start&lt;/b&gt; in the &lt;b&gt;new()&lt;/b&gt; method or by calling the &lt;b&gt;start()&lt;/b&gt; method with a scalar argument.</source>
          <target state="translated">인수없이 목록이 시작된 행 번호를 검색합니다. &lt;b&gt;new ()&lt;/b&gt; 메소드 에서 &lt;b&gt;-start&lt;/b&gt; 를 지정 하거나 스칼라 인수와 함께 &lt;b&gt;start ()&lt;/b&gt; 메소드를 호출하여 설정해야합니다 .&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="914d0fa2ff8badbccd79dfd30e292a8ed73be0c1" translate="yes" xml:space="preserve">
          <source>Without argument, retrieves the list type, which can be an arbitrary value, e.g. &lt;code&gt;OL&lt;/code&gt; , &lt;code&gt;UL&lt;/code&gt; , ... when thinking the HTML way. This must have been set before by either specifying &lt;b&gt;-type&lt;/b&gt; in the &lt;b&gt;new()&lt;/b&gt; method or by calling the &lt;b&gt;type()&lt;/b&gt; method with a scalar argument.</source>
          <target state="translated">인수없이 , HTML 방식을 생각할 때 임의의 값이 될 수있는 목록 유형을 검색합니다 (예 : &lt;code&gt;OL&lt;/code&gt; , &lt;code&gt;UL&lt;/code&gt; , ...). &lt;b&gt;new ()&lt;/b&gt; 메소드 에서 &lt;b&gt;-type&lt;/b&gt; 을 지정 하거나 스칼라 인수로 &lt;b&gt;type ()&lt;/b&gt; 메소드를 호출하여 이전에 설정되어 있어야합니다 .&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="0c21aaff33380d9ba14cee3094239dfc4fb494ab" translate="yes" xml:space="preserve">
          <source>Without arguments libnetcfg displays the current configuration.</source>
          <target state="translated">인수없이 libnetcfg는 현재 구성을 표시합니다.</target>
        </trans-unit>
        <trans-unit id="4decffda157c9d482865e95a2bef98fbdd07c180" translate="yes" xml:space="preserve">
          <source>Without autodie (and assuming BAREWORD is an open filehandle/dirhandle) this is a valid call to chdir. But under autodie, &lt;code&gt;&lt;a href=&quot;functions/chdir&quot;&gt;chdir&lt;/a&gt;&lt;/code&gt; will behave like it had the prototype &quot;;$&quot; and thus BAREWORD will be a syntax error (under &quot;use strict&quot;. Without strict, it will interpreted as a filename).</source>
          <target state="translated">autodie가 없으면 (BAREWORD가 열린 파일 핸들 / 디렉토리라고 가정) 이것은 chdir에 대한 유효한 호출입니다. 그러나 오토 디에서는 &lt;code&gt;&lt;a href=&quot;functions/chdir&quot;&gt;chdir&lt;/a&gt;&lt;/code&gt; 은 &quot;; $&quot;프로토 타입이있는 것처럼 작동하므로 BAREWORD는 구문 오류 ( &quot;use strict&quot;아래에 있습니다. strict가 없으면 파일 이름으로 해석됩니다).</target>
        </trans-unit>
        <trans-unit id="4f60150307dd02c8b93f0a67955bd9770e2759c8" translate="yes" xml:space="preserve">
          <source>Without autodie (and assuming BAREWORD is an open filehandle/dirhandle) this is a valid call to chdir. But under autodie, &lt;code&gt;chdir&lt;/code&gt; will behave like it had the prototype &quot;;$&quot; and thus BAREWORD will be a syntax error (under &quot;use strict&quot;. Without strict, it will interpreted as a filename).</source>
          <target state="translated">autodie가 없으면 (그리고 BAREWORD가 열린 파일 핸들 / 디렉터리 핸들이라고 가정하면) 이것은 chdir에 대한 유효한 호출입니다. 그러나 autodie에서 &lt;code&gt;chdir&lt;/code&gt; 은 프로토 타입 &quot;; $&quot;이있는 것처럼 동작하므로 BAREWORD는 구문 오류가됩니다 ( &quot;use strict&quot;에서. strict가 없으면 파일 이름으로 해석 됨).</target>
        </trans-unit>
        <trans-unit id="157dc325ab3004964dba8cb99f25c548e59c3ee6" translate="yes" xml:space="preserve">
          <source>Without binmode this happens to work but without binmode, print() fails instead of write().</source>
          <target state="translated">binmode가 없으면 작동하지만 binmode가 없으면 write () 대신 print ()가 실패합니다.</target>
        </trans-unit>
        <trans-unit id="9fae572f92ad00688736431e8db34f7e13e97183" translate="yes" xml:space="preserve">
          <source>Without compiling a special Perl, there is no way to get the exact same behavior of any versions prior to Perl 5.18.0. The closest one can get is by setting PERL_PERTURB_KEYS to 0 and setting the PERL_HASH_SEED to a known value. We do not advise those settings for production use due to the above security considerations.</source>
          <target state="translated">특별한 Perl을 컴파일하지 않으면 Perl 5.18.0 이전 버전과 동일한 동작을 얻을 수있는 방법이 없습니다. 가장 가까운 것은 PERL_PERTURB_KEYS를 0으로 설정하고 PERL_HASH_SEED를 알려진 값으로 설정하는 것입니다. 위의 보안 고려 사항으로 인해 프로덕션 용 설정은 권장하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="40d89b93ede452cf3a3abe5db73cc3f6990cb465" translate="yes" xml:space="preserve">
          <source>Without sending mail to the address and seeing whether there's a human on the other end to answer you, you cannot fully answer part</source>
          <target state="translated">주소로 메일을 보내지 않고 상대방이 당신에게 답할 수있는 사람이 있는지를 보지 않으면, 당신은 완전히 대답 할 수 없습니다</target>
        </trans-unit>
        <trans-unit id="9dc761ae6cda1ca106ca429a9b91481691a414c5" translate="yes" xml:space="preserve">
          <source>Without tests provided by the original author, how can anyone else changing perl in the future be sure that they haven't unwittingly broken the behaviour the patch implements? And without tests, how can the patch's author be confident that his/her hard work put into the patch won't be accidentally thrown away by someone in the future?</source>
          <target state="translated">원래 작성자가 제공 한 테스트가 없다면, 미래에 펄을 바꾸는 다른 사람이 패치로 구현 된 동작을 무의식적으로 손상시키지 않았 음을 어떻게 확인할 수 있습니까? 그리고 테스트없이 패치 작성자는 패치에 넣은 노력이 미래에 누군가 실수로 버려지지 않을 것이라고 어떻게 확신 할 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="c1443d621edad5afbf828f718460ec1c38b6ccbc" translate="yes" xml:space="preserve">
          <source>Without that empty line before the &quot;=head1&quot;, many translators wouldn't have recognized the &quot;=head1&quot; as starting a Pod block.</source>
          <target state="translated">&quot;= head1&quot;앞에 빈 줄이 없으면 많은 번역가가 &quot;= head1&quot;을 Pod 블록을 시작하는 것으로 인식하지 못했을 것입니다.</target>
        </trans-unit>
        <trans-unit id="d67d28a004691a2df73ec622342b344f42349502" translate="yes" xml:space="preserve">
          <source>Without the &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt; $AUTOLOAD&lt;/code&gt; declaration, this code will not compile under the &lt;a href=&quot;strict&quot;&gt;strict&lt;/a&gt; pragma.</source>
          <target state="translated">포함하지 않는 &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt; $AUTOLOAD&lt;/code&gt; 선언이 코드는 아래에 컴파일되지 않습니다 &lt;a href=&quot;strict&quot;&gt;엄격한&lt;/a&gt; 프라그.</target>
        </trans-unit>
        <trans-unit id="e556997c8bdf4cc597d6477622db2033d0112438" translate="yes" xml:space="preserve">
          <source>Without the &lt;code&gt;our $AUTOLOAD&lt;/code&gt; declaration, this code will not compile under the &lt;a href=&quot;strict&quot;&gt;strict&lt;/a&gt; pragma.</source>
          <target state="translated">&lt;code&gt;our $AUTOLOAD&lt;/code&gt; 선언이 없으면 이 코드는 &lt;a href=&quot;strict&quot;&gt;엄격한&lt;/a&gt; pragma에서 컴파일되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="8106389e31f882e4de34e6fb1c8fa83f4529f426" translate="yes" xml:space="preserve">
          <source>Without the \ before the #, we'd have the start of a Makefile comment, and the macro would be incorrectly defined.</source>
          <target state="translated"># 앞에 \가 없으면 Makefile 주석이 시작되고 매크로가 잘못 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="9862e56ba4382f4550c0a053a28a9edc67cb29a8" translate="yes" xml:space="preserve">
          <source>Without the \\ before the #, we'd have the start of a Makefile comment, and the macro would be incorrectly defined.</source>
          <target state="translated"># 앞에 \\가 없으면 Makefile 주석이 시작되고 매크로가 잘못 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="c652adb6df9438fc28974e5263002f95713055c4" translate="yes" xml:space="preserve">
          <source>Without the all-critical &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; declaration, putting UTF‑8 in your literals and identifiers won&amp;rsquo;t work right. If you used the standard preamble just given above, this already happened. If you did, you can do things like this:</source>
          <target state="translated">모든 중요한없이 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; 선언, 당신의 리터럴 및 식별자 업무를 잘하지 않습니다에 UTF-8을 넣어. 위에서 주어진 표준 프리앰블을 사용했다면 이미 발생한 것입니다. 그렇게했다면 다음과 같이 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="022916bda3b0da7053428b82057c474802fe172c" translate="yes" xml:space="preserve">
          <source>Without the all-critical &lt;code&gt;use utf8&lt;/code&gt; declaration, putting UTF‑8 in your literals and identifiers won&amp;rsquo;t work right. If you used the standard preamble just given above, this already happened. If you did, you can do things like this:</source>
          <target state="translated">모든 중요한 &lt;code&gt;use utf8&lt;/code&gt; 선언이 없으면 리터럴과 식별자에 UTF-8을 넣는 것이 제대로 작동하지 않습니다. 위에 제공된 표준 서문을 사용했다면 이미 이런 일이 발생했습니다. 그렇게했다면 다음과 같이 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a805f73e432af03c931e3e4ebc6e43febdbb1b0f" translate="yes" xml:space="preserve">
          <source>Without the braces, Perl would have looked for a $whospeak, a &lt;code&gt;$who::0&lt;/code&gt; , and a &lt;code&gt;$who's&lt;/code&gt; variable. The last two would be the $0 and the $s variables in the (presumably) non-existent package &lt;code&gt;who&lt;/code&gt; .</source>
          <target state="translated">중괄호가 없으면 Perl은 $ whospeak, &lt;code&gt;$who::0&lt;/code&gt; 및 &lt;code&gt;$who's&lt;/code&gt; 변수를 찾았습니다 . 마지막 두 개는 (아마도) 존재하지 않는 패키지 &lt;code&gt;who&lt;/code&gt; 의 $ 0 및 $ s 변수 입니다 .</target>
        </trans-unit>
        <trans-unit id="b59ba0c86d5008d327ba4145261903f48586e59b" translate="yes" xml:space="preserve">
          <source>Without the braces, Perl would have looked for a $whospeak, a &lt;code&gt;$who::0&lt;/code&gt;, and a &lt;code&gt;$who's&lt;/code&gt; variable. The last two would be the $0 and the $s variables in the (presumably) non-existent package &lt;code&gt;who&lt;/code&gt;.</source>
          <target state="translated">중괄호가 없으면 Perl은 $ whospeak, &lt;code&gt;$who::0&lt;/code&gt; 및 &lt;code&gt;$who's&lt;/code&gt; 변수를 찾았을 것 입니다. 마지막 두 개는 존재하지 않는 패키지의 $ 0 및 $ s 변수 &lt;code&gt;who&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8b7119185642381b4835e616a2adfce6407060de" translate="yes" xml:space="preserve">
          <source>Without the file handle there is no straightforward way to map from the C callback to the Perl subroutine.</source>
          <target state="translated">파일 핸들이 없으면 C 콜백에서 Perl 서브 루틴으로 맵핑하는 간단한 방법이 없습니다.</target>
        </trans-unit>
        <trans-unit id="557fc723a913d1e3b2505b4094298be8eec2001a" translate="yes" xml:space="preserve">
          <source>Without the quotes Perl would convert the large number to a floating point constant at compile time and then hand the result to BigInt, which results in an truncated result or a NaN.</source>
          <target state="translated">따옴표가 없으면 Perl은 컴파일 타임에 큰 숫자를 부동 소수점 상수로 변환 한 다음 결과를 BigInt로 전달하여 결과가 잘 리거나 NaN이됩니다.</target>
        </trans-unit>
        <trans-unit id="cd8dcbc5d0ba46dab27a245d8542910769851151" translate="yes" xml:space="preserve">
          <source>Without the quotes Perl would convert the large number to a floating point constant at compile time and then hand the result to Math::BigInt, which results in an truncated result or a NaN.</source>
          <target state="translated">따옴표가 없으면 Perl은 컴파일 시간에 큰 숫자를 부동 소수점 상수로 변환 한 다음 결과를 Math :: BigInt에 전달하여 결과가 잘 리거나 NaN이됩니다.</target>
        </trans-unit>
        <trans-unit id="44d0e0ada47acb90500aed8583377dc7e9485f05" translate="yes" xml:space="preserve">
          <source>Without this function call, threads that use the &lt;a href=&quot;setlocale(3)&quot;&gt;&lt;code&gt;setlocale(3)&lt;/code&gt;&lt;/a&gt; system function will not work properly, as all the locale-sensitive functions will look at the per-thread locale, and &lt;code&gt;setlocale&lt;/code&gt; will have no effect on this thread.</source>
          <target state="translated">이 함수 호출이 없으면 &lt;a href=&quot;setlocale(3)&quot;&gt; &lt;code&gt;setlocale(3)&lt;/code&gt; &lt;/a&gt; 시스템 함수 를 사용하는 스레드가 제대로 작동하지 않습니다. 모든 로케일 구분 함수가 스레드 별 로케일을보고 &lt;code&gt;setlocale&lt;/code&gt; 이이 스레드에 영향을주지 않기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="ebd1a191c5e0195ae68815f767eadf66793aed3f" translate="yes" xml:space="preserve">
          <source>Without this pragma, if strings operating under byte semantics and strings with Unicode character data are concatenated, the new string will be created by decoding the byte strings as</source>
          <target state="translated">이 pragma가 없으면 바이트 시맨틱에서 작동하는 문자열과 유니 코드 문자 데이터가있는 문자열이 연결되면 바이트 문자열을 다음과 같이 디코딩하여 새 문자열이 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="4e3240128cc4ac6294817aa01c1437d4416b9150" translate="yes" xml:space="preserve">
          <source>Word characters</source>
          <target state="translated">단어 문자</target>
        </trans-unit>
        <trans-unit id="c1ab804bf377c2d02f25ebababbe5112fca26b12" translate="yes" xml:space="preserve">
          <source>Work Crew</source>
          <target state="translated">작업 대원</target>
        </trans-unit>
        <trans-unit id="73f4875bffaeefb6bc4c9e5de5982f1c956b5814" translate="yes" xml:space="preserve">
          <source>Work around DCL's 255 character limit several times,and use VMS-style command line quoting in a few cases.</source>
          <target state="translated">DCL의 255 자 제한을 여러 번 해결하고 경우에 따라 VMS 스타일 명령 줄 인용을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="beb03a8c30af39505328c268c1180c75604701a0" translate="yes" xml:space="preserve">
          <source>Work for the pumpking, work for Perl programmers, work for module authors, ... Perl is supposed to be easy.</source>
          <target state="translated">pumpking, Perl 프로그래머, 모듈 작성자를위한 작업, ... Perl은 쉬워야합니다.</target>
        </trans-unit>
        <trans-unit id="91f920f3d44c34d2ff6c9dd9603498397730bf04" translate="yes" xml:space="preserve">
          <source>Worked by applying a role that wrapped &lt;code&gt;Test::Builder-&amp;gt;_print_comment&lt;/code&gt;. Fixed by adding an event filter that modifies the message instead when running under Test2.</source>
          <target state="translated">&lt;code&gt;Test::Builder-&amp;gt;_print_comment&lt;/code&gt; 를 래핑 한 역할을 적용하여 작업했습니다 . Test2에서 실행할 때 대신 메시지를 수정하는 이벤트 필터를 추가하여 수정했습니다.</target>
        </trans-unit>
        <trans-unit id="b837e4f0aacd9d9f6074d443ecd309cef87e661e" translate="yes" xml:space="preserve">
          <source>Working code is always preferred to pie-in-the-sky ideas. A patch to add a feature stands a much higher chance of making it to the language than does a random feature request, no matter how fervently argued the request might be. This ties into &quot;Will it be useful?&quot;, as the fact that someone took the time to make the patch demonstrates a strong desire for the feature.</source>
          <target state="translated">작업 코드는 항상 최신 아이디어보다 선호됩니다. 기능을 추가하는 패치는 요청이 아무리 격렬하게 주장 되더라도 임의의 기능 요청보다 언어로 만들 가능성이 훨씬 높습니다. 누군가 패치를 작성하는 데 시간이 걸린다는 사실은이 기능에 대한 강한 열망을 보여주기 때문에 &quot;유용합니까?&quot;와 관련이 있습니다.</target>
        </trans-unit>
        <trans-unit id="791f0cf1a4866efe09fa052199378fd87a29a636" translate="yes" xml:space="preserve">
          <source>Working with AVs</source>
          <target state="translated">AV 작업</target>
        </trans-unit>
        <trans-unit id="fcf77865e202a40f39e6dc4633dec2c1c8b8542a" translate="yes" xml:space="preserve">
          <source>Working with HVs</source>
          <target state="translated">HV 작업</target>
        </trans-unit>
        <trans-unit id="9ba6b91bf263dc667dda1becd81a9fbef7358bbd" translate="yes" xml:space="preserve">
          <source>Working with Net::FTP</source>
          <target state="translated">Net :: FTP로 작업하기</target>
        </trans-unit>
        <trans-unit id="9522f5ef01714aab2e2d70111bf52346aa9851c3" translate="yes" xml:space="preserve">
          <source>Working with SVs</source>
          <target state="translated">SV 작업</target>
        </trans-unit>
        <trans-unit id="acaa1f9e891f841e4f55280185da1c9a0bc87b80" translate="yes" xml:space="preserve">
          <source>Working with files</source>
          <target state="translated">파일 작업</target>
        </trans-unit>
        <trans-unit id="7efe528e837c3e9dd842174c934d74e9c8e8af64" translate="yes" xml:space="preserve">
          <source>Works currently only for integers.</source>
          <target state="translated">현재 정수에만 작동합니다.</target>
        </trans-unit>
        <trans-unit id="c9cb7c59dae1a78441bca64b16b41d57dc70c3e5" translate="yes" xml:space="preserve">
          <source>Works exactly as &lt;code&gt;like()&lt;/code&gt; , only it checks if $got &lt;b&gt;does not&lt;/b&gt; match the given pattern.</source>
          <target state="translated">&lt;code&gt;like()&lt;/code&gt; 동일하게 작동하며 $ got &lt;b&gt;이&lt;/b&gt; 주어진 패턴과 일치 &lt;b&gt;하지 않는지&lt;/b&gt; 확인합니다 .</target>
        </trans-unit>
        <trans-unit id="6ffef90261775bf1446d64de441c14b751512d3c" translate="yes" xml:space="preserve">
          <source>Works exactly as &lt;code&gt;like()&lt;/code&gt;, only it checks if $got &lt;b&gt;does not&lt;/b&gt; match the given pattern.</source>
          <target state="translated">&lt;code&gt;like()&lt;/code&gt; 똑같이 작동하며 $ got &lt;b&gt;이&lt;/b&gt; 주어진 패턴과 일치 &lt;b&gt;하지 않는지&lt;/b&gt; 확인합니다 .</target>
        </trans-unit>
        <trans-unit id="54f0dce4381260fc309ade54b455e20a83cc12f0" translate="yes" xml:space="preserve">
          <source>Works just like &lt;a href=&quot;#index-STR%2CSUBSTR%2CPOSITION&quot;&gt;&lt;code&gt;index&lt;/code&gt;&lt;/a&gt; except that it returns the position of the</source>
          <target state="translated">위치를 반환한다는 점을 제외하면 &lt;a href=&quot;#index-STR%2CSUBSTR%2CPOSITION&quot;&gt; &lt;code&gt;index&lt;/code&gt; &lt;/a&gt; 동일하게 작동 합니다.</target>
        </trans-unit>
        <trans-unit id="9232c0576386ef7db9a66e0f3312f80aa2ae0362" translate="yes" xml:space="preserve">
          <source>Works just like &lt;a href=&quot;#localtime&quot;&gt;localtime&lt;/a&gt; but the returned values are localized for the standard Greenwich time zone.</source>
          <target state="translated">처럼 작품 &lt;a href=&quot;#localtime&quot;&gt;의 현지&lt;/a&gt; 하지만 반환 값은 표준 그리니치 시간대로 현지화되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="9839a604fd52293ec52fedd95d5b5d8df3818c2c" translate="yes" xml:space="preserve">
          <source>Works just like &lt;a href=&quot;#localtime-EXPR&quot;&gt;&lt;code&gt;localtime&lt;/code&gt;&lt;/a&gt; but the returned values are localized for the standard Greenwich time zone.</source>
          <target state="translated">처럼 작품 &lt;a href=&quot;#localtime-EXPR&quot;&gt; &lt;code&gt;localtime&lt;/code&gt; &lt;/a&gt; 하지만 반환 값은 표준 그리니치 시간대로 현지화되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="69a4f2f77bbe0fae40d114143aa5065b6ddabd02" translate="yes" xml:space="preserve">
          <source>Works just like &lt;a href=&quot;Test::More&quot;&gt;Test::More&lt;/a&gt;'s &lt;code&gt;cmp_ok()&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;Test::More&quot;&gt;Test :: More&lt;/a&gt; 의 &lt;code&gt;cmp_ok()&lt;/code&gt; 처럼 작동 합니다.</target>
        </trans-unit>
        <trans-unit id="63d895f5ba3197e6e250fa353d94a31dc5531f0f" translate="yes" xml:space="preserve">
          <source>Works just like &lt;a href=&quot;localtime&quot;&gt;localtime&lt;/a&gt; but the returned values are localized for the standard Greenwich time zone.</source>
          <target state="translated">처럼 작품 &lt;a href=&quot;localtime&quot;&gt;의 현지&lt;/a&gt; 하지만 반환 값은 표준 그리니치 시간대로 현지화되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="59edd54160d7f94a92175d3ce89e67babbe534fb" translate="yes" xml:space="preserve">
          <source>Works just like &lt;a href=&quot;more&quot;&gt;Test::More&lt;/a&gt;'s &lt;code&gt;cmp_ok()&lt;/code&gt; .</source>
          <target state="translated">&lt;a href=&quot;more&quot;&gt;Test :: More&lt;/a&gt; 의 &lt;code&gt;cmp_ok()&lt;/code&gt; 와 같이 작동 합니다.</target>
        </trans-unit>
        <trans-unit id="b054b39e72ec238653744e3a117cbf2b7bacaa18" translate="yes" xml:space="preserve">
          <source>Works just like index() except that it returns the position of the</source>
          <target state="translated">index ()와 동일하게 작동합니다.</target>
        </trans-unit>
        <trans-unit id="ff14a89d24955b4d292116a9dd09815095b69cb7" translate="yes" xml:space="preserve">
          <source>Works like &lt;code&gt;sv_catpvf&lt;/code&gt; but copies the text into the SV instead of appending it. Does not handle 'set' magic. See &lt;code&gt;&lt;a href=&quot;#sv_setpvf_mg&quot;&gt;&quot;sv_setpvf_mg&quot;&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;sv_catpvf&lt;/code&gt; 처럼 작동 하지만 텍스트를 추가하는 대신 SV에 복사합니다. '세트'마법을 처리하지 않습니다. &lt;code&gt;&lt;a href=&quot;#sv_setpvf_mg&quot;&gt;&quot;sv_setpvf_mg&quot;&lt;/a&gt;&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="62b7e0373549dae581f58b37784d19f9d489170e" translate="yes" xml:space="preserve">
          <source>Works like &lt;code&gt;sv_catpvf&lt;/code&gt; but copies the text into the SV instead of appending it. Does not handle 'set' magic. See &lt;code&gt;sv_setpvf_mg&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;sv_catpvf&lt;/code&gt; 처럼 작동 하지만 텍스트를 추가하는 대신 SV에 텍스트를 복사합니다. '세트'마법을 처리하지 않습니다. &lt;code&gt;sv_setpvf_mg&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c14d76b99d10ba25b831daac8203cd025304f5fc" translate="yes" xml:space="preserve">
          <source>Works like &lt;code&gt;sv_vcatpvf&lt;/code&gt; but copies the text into the SV instead of appending it. Does not handle 'set' magic. See &lt;code&gt;&lt;a href=&quot;#sv_vsetpvf_mg&quot;&gt;&quot;sv_vsetpvf_mg&quot;&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;sv_vcatpvf&lt;/code&gt; 처럼 작동 하지만 텍스트를 추가하는 대신 SV에 복사합니다. '세트'마법을 처리하지 않습니다. &lt;code&gt;&lt;a href=&quot;#sv_vsetpvf_mg&quot;&gt;&quot;sv_vsetpvf_mg&quot;&lt;/a&gt;&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="43ccfff897978a36d025fbdd87f7f80f29da36e5" translate="yes" xml:space="preserve">
          <source>Works like &lt;code&gt;sv_vcatpvf&lt;/code&gt; but copies the text into the SV instead of appending it. Does not handle 'set' magic. See &lt;code&gt;sv_vsetpvf_mg&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;sv_vcatpvf&lt;/code&gt; 처럼 작동 하지만 텍스트를 추가하는 대신 SV에 텍스트를 복사합니다. '세트'마법을 처리하지 않습니다. &lt;code&gt;sv_vsetpvf_mg&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ce9ad1c2559537d328f2e9ae5ccf06d2341106d3" translate="yes" xml:space="preserve">
          <source>Works like &lt;code&gt;sv_vcatpvfn&lt;/code&gt; but copies the text into the SV instead of appending it.</source>
          <target state="translated">&lt;code&gt;sv_vcatpvfn&lt;/code&gt; 처럼 작동 하지만 텍스트를 추가하는 대신 SV에 텍스트를 복사합니다.</target>
        </trans-unit>
        <trans-unit id="97569be8c378569cf569a2abd589e6182aac8aca" translate="yes" xml:space="preserve">
          <source>Works remotely similar to &lt;code&gt;filter_json_object&lt;/code&gt;, but is only called for JSON objects having a single key named &lt;code&gt;$key&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;filter_json_object&lt;/code&gt; 와 원격으로 유사하게 작동 하지만 &lt;code&gt;$key&lt;/code&gt; 라는 단일 키가있는 JSON 객체에 대해서만 호출 됩니다 .</target>
        </trans-unit>
        <trans-unit id="e28088b9057a774cbeb7647c942ba983be39b65a" translate="yes" xml:space="preserve">
          <source>Workshops</source>
          <target state="translated">Workshops</target>
        </trans-unit>
        <trans-unit id="aca31ad78f24eb8f34a6f1515e5ad96783f7a4c5" translate="yes" xml:space="preserve">
          <source>World Wide Web, HTML, HTTP, CGI, MIME</source>
          <target state="translated">월드 와이드 웹, HTML, HTTP, CGI, MIME</target>
        </trans-unit>
        <trans-unit id="dc354627de17c28e4a463874cb49fb69cf80c2d0" translate="yes" xml:space="preserve">
          <source>Worse still, if you've got a language like Chinese or Japanese that has hundreds or thousands of characters, then you really can't fit them into a mere 256, so they had to forget about ASCII altogether, and build their own systems using pairs of numbers to refer to one character.</source>
          <target state="translated">설상가상으로, 중국어 나 일본어와 같이 수백 또는 수천 개의 문자를 가진 언어를 가지고 있다면, 실제로 256 자에 맞지 않기 때문에 ASCII를 잊어 버리고 자체 시스템을 사용하여 자신의 시스템을 구축해야했습니다 한 문자를 나타내는 숫자 쌍.</target>
        </trans-unit>
        <trans-unit id="c5bfba3d49e2ee674235e330da88197da31a7c79" translate="yes" xml:space="preserve">
          <source>Would print '1', because &lt;code&gt;$foo&lt;/code&gt; holds a reference to the</source>
          <target state="translated">&lt;code&gt;$foo&lt;/code&gt; 는 '1'을 출력합니다. 왜냐하면 $ foo 는</target>
        </trans-unit>
        <trans-unit id="193007f64c59b1fb13236d0c41a89912a80da741" translate="yes" xml:space="preserve">
          <source>Would produce an event structure that does &lt;b&gt;not&lt;/b&gt; have the</source>
          <target state="translated">않는 이벤트 구조를 생산겠습니까 &lt;b&gt;하지&lt;/b&gt; 이를</target>
        </trans-unit>
        <trans-unit id="cb47f1ed4bc872fb3335bdefcb281f4424715abe" translate="yes" xml:space="preserve">
          <source>Would run bin/foobar.PL like this:</source>
          <target state="translated">bin / foobar.PL을 다음과 같이 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="ead2351e2ba0bd4c816a4c94cc5152ad666ddb3d" translate="yes" xml:space="preserve">
          <source>Wrapper around CPAN.pm without using any XS module</source>
          <target state="translated">XS 모듈을 사용하지 않고 CPAN.pm을 감싸는 래퍼</target>
        </trans-unit>
        <trans-unit id="84ac379977c898d123ab3b5be8e7d1ebcc793262" translate="yes" xml:space="preserve">
          <source>Wrapper around Config.pm</source>
          <target state="translated">Config.pm 주위 래퍼</target>
        </trans-unit>
        <trans-unit id="5e2ec9565586c686048d53d457fe37527f6aad30" translate="yes" xml:space="preserve">
          <source>Wrapper class for calling subs at end of scope</source>
          <target state="translated">범위 끝에서 서브를 호출하기위한 랩퍼 클래스</target>
        </trans-unit>
        <trans-unit id="49754b3431fd16ae1cf0d382c55b7fa7149dd942" translate="yes" xml:space="preserve">
          <source>Wrapping all die calls in a handler routine can be useful to see how, and from where, they're being called, &lt;a href=&quot;perlvar&quot;&gt;perlvar&lt;/a&gt; has more information:</source>
          <target state="translated">처리기 루틴에서 모든 다이 호출을 래핑하는 것은 &lt;a href=&quot;perlvar&quot;&gt;perlvar&lt;/a&gt; 가 어떻게 그리고 어디에서 호출되는지에 대한 정보를 얻는 데 유용 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c2c61b8accf065e529ff818a1a9f4549b7fc54ab" translate="yes" xml:space="preserve">
          <source>Wrapping with parenthesis allows the wildcard parts of the Input File Glob to be referenced by the second parameter to &lt;code&gt;globmap&lt;/code&gt; , &lt;code&gt;#1.tgz&lt;/code&gt; , the</source>
          <target state="translated">괄호로 &lt;code&gt;globmap&lt;/code&gt; 면 입력 파일 Glob의 와일드 카드 부분을 두 번째 매개 변수로 globmap , &lt;code&gt;#1.tgz&lt;/code&gt; 로 참조 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="17f822b6bdf6bec5271484d235680d74774f32cb" translate="yes" xml:space="preserve">
          <source>Wrapping with parenthesis allows the wildcard parts of the Input File Glob to be referenced by the second parameter to &lt;code&gt;globmap&lt;/code&gt;, &lt;code&gt;#1.tgz&lt;/code&gt;, the</source>
          <target state="translated">괄호로 감싸면 입력 파일 Glob의 와일드 카드 부분이 &lt;code&gt;globmap&lt;/code&gt; , &lt;code&gt;#1.tgz&lt;/code&gt; 에 대한 두 번째 매개 변수에 의해 참조 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="53f5b426a0effa25adf0da16850506b6dbd0cdcc" translate="yes" xml:space="preserve">
          <source>Wraps any CODE references found within the arguments by replacing each with the result of calling &lt;a href=&quot;#wrap_code_ref&quot;&gt;&quot;wrap_code_ref&quot;&lt;/a&gt; on the CODE reference. Any ARRAY or HASH references in the arguments are inspected recursively.</source>
          <target state="translated">각각을 CODE 참조에서 &lt;a href=&quot;#wrap_code_ref&quot;&gt;&quot;wrap_code_ref&quot;&lt;/a&gt; 를 호출 한 결과로 대체하여 인수 내에서 발견 된 모든 CODE 참조를 래핑합니다 . 인수의 모든 ARRAY 또는 HASH 참조는 재귀 적으로 검사됩니다.</target>
        </trans-unit>
        <trans-unit id="7ee0be976deb11b8b1d2de7c10091a2cf26d9d3d" translate="yes" xml:space="preserve">
          <source>Wraps any CODE references found within the arguments by replacing each with the result of calling &lt;a href=&quot;#wrap_code_ref&quot;&gt;wrap_code_ref&lt;/a&gt; on the CODE reference. Any ARRAY or HASH references in the arguments are inspected recursively.</source>
          <target state="translated">CODE 참조에서 &lt;a href=&quot;#wrap_code_ref&quot;&gt;wrap_code_ref&lt;/a&gt; 를 호출 한 결과로 각각을 대체하여 인수에서 찾은 CODE 참조를 랩핑합니다 . 인수의 ARRAY 또는 HASH 참조는 재귀 적으로 검사됩니다.</target>
        </trans-unit>
        <trans-unit id="c3415b34e4326194b5c5e94f65779568f9ab9142" translate="yes" xml:space="preserve">
          <source>Wraps up an op tree with some additional ops so that at runtime a dynamic scope will be created. The original ops run in the new dynamic scope, and then, provided that they exit normally, the scope will be unwound. The additional ops used to create and unwind the dynamic scope will normally be an &lt;code&gt;enter&lt;/code&gt; /&lt;code&gt;leave&lt;/code&gt; pair, but a &lt;code&gt;scope&lt;/code&gt; op may be used instead if the ops are simple enough to not need the full dynamic scope structure.</source>
          <target state="translated">런타임에 동적 범위가 작성되도록 일부 추가 op로 op 트리를 래핑합니다. 원래 op는 새 동적 범위에서 실행 된 다음 정상적으로 종료되면 범위가 풀립니다. 동적 범위를 생성 및 해제하는 데 사용되는 추가 ops는 일반적으로 &lt;code&gt;enter&lt;/code&gt; / &lt;code&gt;leave&lt;/code&gt; 쌍이지만 , ops가 전체 동적 범위 구조를 필요로하지 않을 정도로 단순하면 &lt;code&gt;scope&lt;/code&gt; op가 대신 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2c03a1841c6b03c290cd48f7ec63334ea2671fbe" translate="yes" xml:space="preserve">
          <source>Wraps up an op tree with some additional ops so that at runtime a dynamic scope will be created. The original ops run in the new dynamic scope, and then, provided that they exit normally, the scope will be unwound. The additional ops used to create and unwind the dynamic scope will normally be an &lt;code&gt;enter&lt;/code&gt;/&lt;code&gt;leave&lt;/code&gt; pair, but a &lt;code&gt;scope&lt;/code&gt; op may be used instead if the ops are simple enough to not need the full dynamic scope structure.</source>
          <target state="translated">런타임에 동적 범위가 생성되도록 몇 가지 추가 작업으로 작업 트리를 래핑합니다. 원래 작업은 새 동적 범위에서 실행되며 정상적으로 종료되면 범위가 해제됩니다. 동적 범위를 만들고 해제하는 데 사용되는 추가 작업은 일반적으로 &lt;code&gt;enter&lt;/code&gt; / &lt;code&gt;leave&lt;/code&gt; 쌍이지만 전체 동적 범위 구조가 필요하지 않을 정도로 작업이 간단 할 경우 대신 &lt;code&gt;scope&lt;/code&gt; 작업을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4a48932789d199bbed709777e2d743ca2bafdc6c" translate="yes" xml:space="preserve">
          <source>Write</source>
          <target state="translated">Write</target>
        </trans-unit>
        <trans-unit id="665e91485da7b1f4da854eb4a64d72b175917c29" translate="yes" xml:space="preserve">
          <source>Write &lt;code&gt;SIZE&lt;/code&gt; bytes of data from &lt;code&gt;BUFFER&lt;/code&gt; to the server, also performing any &amp;lt;CRLF&amp;gt; translation necessary. &lt;code&gt;TIMEOUT&lt;/code&gt; is optional, if not given, the timeout value from the command connection will be used.</source>
          <target state="translated">&lt;code&gt;BUFFER&lt;/code&gt; 에서 서버로 &lt;code&gt;SIZE&lt;/code&gt; 바이트의 데이터를 쓰고 필요한 &amp;lt;CRLF&amp;gt; 변환도 수행하십시오. &lt;code&gt;TIMEOUT&lt;/code&gt; 은 선택 사항이며, 지정하지 않으면 명령 연결의 시간 초과 값이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="9e9970521c52eb1a81f415505a29f59eba7d4c0c" translate="yes" xml:space="preserve">
          <source>Write &lt;code&gt;SIZE&lt;/code&gt; bytes to the shared memory segment at &lt;code&gt;POS&lt;/code&gt; . Returns true if successful, or false if there is an error. See &lt;a href=&quot;../functions/shmwrite&quot;&gt;shmwrite&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;POS&lt;/code&gt; 의 공유 메모리 세그먼트에 &lt;code&gt;SIZE&lt;/code&gt; 바이트를 씁니다 . 성공하면 true를, 오류가 있으면 false를 반환합니다. &lt;a href=&quot;../functions/shmwrite&quot;&gt;shmwrite를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e52c0034fc1cfc407469f1ff131f1cb98c7f427d" translate="yes" xml:space="preserve">
          <source>Write &lt;code&gt;SIZE&lt;/code&gt; bytes to the shared memory segment at &lt;code&gt;POS&lt;/code&gt;. Returns true if successful, or false if there is an error. See &lt;a href=&quot;shmwrite&quot;&gt;shmwrite&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;POS&lt;/code&gt; 의 공유 메모리 세그먼트에 &lt;code&gt;SIZE&lt;/code&gt; 바이트를 씁니다 . 성공하면 true를 반환하고 오류가 있으면 false를 반환합니다. &lt;a href=&quot;shmwrite&quot;&gt;shmwrite를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c4d6106f35288022310ffee038cda3aae849b282" translate="yes" xml:space="preserve">
          <source>Write MYMETA information to MYMETA.json and MYMETA.yml.</source>
          <target state="translated">MYMETA 정보를 MYMETA.json 및 MYMETA.yml에 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="a9b6c91570493bdee3be6eef5a6b183ad756cdab" translate="yes" xml:space="preserve">
          <source>Write RFC 1950 files/buffers</source>
          <target state="translated">RFC 1950 파일 / 버퍼 작성</target>
        </trans-unit>
        <trans-unit id="0909abf68380a212e21e5479f6396ce54f63b785" translate="yes" xml:space="preserve">
          <source>Write RFC 1951 files/buffers</source>
          <target state="translated">RFC 1951 파일 / 버퍼 작성</target>
        </trans-unit>
        <trans-unit id="0a1ef998109ed3777e0f667818ad2c1c3ea0b70e" translate="yes" xml:space="preserve">
          <source>Write RFC 1952 files/buffers</source>
          <target state="translated">RFC 1952 파일 / 버퍼 작성</target>
        </trans-unit>
        <trans-unit id="e52a7d8ae8bb89850d8b0bad0931a61da15a6992" translate="yes" xml:space="preserve">
          <source>Write YAMLish data</source>
          <target state="translated">YAMLish 데이터 작성</target>
        </trans-unit>
        <trans-unit id="77878a047db48550e0d5361bfb44d185b930e978" translate="yes" xml:space="preserve">
          <source>Write a formatter as a Pod::Simple subclass</source>
          <target state="translated">Pod :: Simple 서브 클래스로 포맷터 작성</target>
        </trans-unit>
        <trans-unit id="bc54db5c1b3d5ac212fb800fdd56f965140da3e5" translate="yes" xml:space="preserve">
          <source>Write access via git</source>
          <target state="translated">자식을 통한 쓰기 액세스</target>
        </trans-unit>
        <trans-unit id="935636e37a0f4339394c64f63b5cea6433c1f963" translate="yes" xml:space="preserve">
          <source>Write an entry, whose name is equivalent to the file name provided to disk. Optionally takes a second parameter, which is the full native path (including filename) the entry will be written to.</source>
          <target state="translated">이름이 디스크에 제공된 파일 이름과 동일한 항목을 작성하십시오. 선택적으로 두 번째 매개 변수를 사용합니다.이 매개 변수는 항목이 기록 될 전체 기본 경로 (파일 이름 포함)입니다.</target>
        </trans-unit>
        <trans-unit id="21bcad44913246d2e6442e5351456a0465facb2b" translate="yes" xml:space="preserve">
          <source>Write an event to the console.</source>
          <target state="translated">콘솔에 이벤트를 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="92e129f1755e34449f3a6e6df186f50990274c50" translate="yes" xml:space="preserve">
          <source>Write behind.</source>
          <target state="translated">뒤에 쓰십시오.</target>
        </trans-unit>
        <trans-unit id="e9db66c000d241fa8edccdd62e10c6678d855f50" translate="yes" xml:space="preserve">
          <source>Write bytes to a file or file-like device. Returns a true value if the operation was successful. For failure, returns a false value and sets &lt;code&gt;fileLastError()&lt;/code&gt; and &lt;code&gt;$^E&lt;/code&gt; for the reason for the failure.</source>
          <target state="translated">파일 또는 파일 류 장치에 바이트를 씁니다. 작업이 성공하면 참 값을 반환합니다. 실패의 경우 거짓 값을 반환 하고 실패 이유에 대해 &lt;code&gt;fileLastError()&lt;/code&gt; 및 &lt;code&gt;$^E&lt;/code&gt; 를 설정합니다.</target>
        </trans-unit>
        <trans-unit id="5769fe16b9b0cad42af9406c72e837bd0c18c816" translate="yes" xml:space="preserve">
          <source>Write bzip2 files/buffers</source>
          <target state="translated">bzip2 파일 / 버퍼 작성</target>
        </trans-unit>
        <trans-unit id="33c705dea45d707aeb4260372b955bd490cdccc3" translate="yes" xml:space="preserve">
          <source>Write check compare operation.</source>
          <target state="translated">쓰기 확인 비교 작업입니다.</target>
        </trans-unit>
        <trans-unit id="bafb7482744edca206da4c0baa12b4a11269c914" translate="yes" xml:space="preserve">
          <source>Write documentation in POD</source>
          <target state="translated">POD로 문서 작성</target>
        </trans-unit>
        <trans-unit id="01995de03181a3f8adb7e727e73e6dc5e4e106c7" translate="yes" xml:space="preserve">
          <source>Write files whose names are equivalent to any of the names in &lt;code&gt;@filenames&lt;/code&gt; to disk, creating subdirectories as necessary. This might not work too well under VMS. Under MacPerl, the file's modification time will be converted to the MacOS zero of time, and appropriate conversions will be done to the path. However, the length of each element of the path is not inspected to see whether it's longer than MacOS currently allows (32 characters).</source>
          <target state="translated">&lt;code&gt;@filenames&lt;/code&gt; 의 이름과 동일한 이름을 가진 파일 을 디스크에 쓰고 필요한 경우 하위 디렉토리를 만듭니다. VMS에서는 제대로 작동하지 않을 수 있습니다. MacPerl에서는 파일 수정 시간이 MacOS 0으로 변환되고 경로에 대한 적절한 변환이 수행됩니다. 그러나 경로의 각 요소 길이는 현재 MacOS가 허용하는 길이 (32 자)보다 긴지 검사하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="cbcd4ec744f6a0cc7a8100b555d7a1173e6952f5" translate="yes" xml:space="preserve">
          <source>Write linker options files for dynamic extension</source>
          <target state="translated">동적 확장을위한 링커 옵션 파일 작성</target>
        </trans-unit>
        <trans-unit id="a3530b843bc763ce23299f2f7a8c7169f29e11c4" translate="yes" xml:space="preserve">
          <source>Write simple routines to do simple things.</source>
          <target state="translated">간단한 루틴을 작성하여 간단한 일을하십시오.</target>
        </trans-unit>
        <trans-unit id="19494af103ef52570f65fb0c4441c4f5f25a19b7" translate="yes" xml:space="preserve">
          <source>Write some bytes to the scalar.</source>
          <target state="translated">스칼라에 몇 바이트를 씁니다.</target>
        </trans-unit>
        <trans-unit id="391b1a9608423cb9c4d16a7886b9e07fab1acb00" translate="yes" xml:space="preserve">
          <source>Write tests</source>
          <target state="translated">테스트 작성</target>
        </trans-unit>
        <trans-unit id="af9a89203723d4a9c54482e7a2f891829a872e2c" translate="yes" xml:space="preserve">
          <source>Write the</source>
          <target state="translated">쓰기</target>
        </trans-unit>
        <trans-unit id="f112fa7fb0b15b487e01a318607d918ca868eea9" translate="yes" xml:space="preserve">
          <source>Write the C code for miniperlmain.c and perlmain.c</source>
          <target state="translated">miniperlmain.c 및 perlmain.c에 대한 C 코드 작성</target>
        </trans-unit>
        <trans-unit id="dc5fd755a4779cecce293a2a1e919899f32cdf21" translate="yes" xml:space="preserve">
          <source>Write the C code for perlmain.c</source>
          <target state="translated">perlmain.c에 대한 C 코드 작성</target>
        </trans-unit>
        <trans-unit id="0a8eff4063a82696c6af1e9ea9cf555d97a3ea2c" translate="yes" xml:space="preserve">
          <source>Write the in-memory archive to disk. The first argument can either be the name of a file or a reference to an already open filehandle (a GLOB reference).</source>
          <target state="translated">메모리 내 아카이브를 디스크에 기록하십시오. 첫 번째 인수는 파일 이름이거나 이미 열려있는 파일 핸들에 대한 참조 (GLOB 참조) 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="af8f82dc202f24f05f3598bed445a87ed08771b7" translate="yes" xml:space="preserve">
          <source>Write the state to a file.</source>
          <target state="translated">상태를 파일에 씁니다.</target>
        </trans-unit>
        <trans-unit id="03e89de5415aa73b6bf8d4ce2e95f915540a35da" translate="yes" xml:space="preserve">
          <source>Write the typemap to a file. Optionally takes a &lt;code&gt;file&lt;/code&gt; argument. If given, the typemap will be written to the specified file. If not, the typemap is written to the currently stored file name (see &lt;a href=&quot;#file&quot;&gt;&quot;file&quot;&lt;/a&gt; above, this defaults to the file it was read from if any).</source>
          <target state="translated">typemap을 파일에 씁니다. 선택적으로 &lt;code&gt;file&lt;/code&gt; 인수를받습니다. 주어진 경우 typemap은 지정된 파일에 기록됩니다. 그렇지 않은 경우, 타입 맵은 현재 저장된 파일 이름에 기록됩니다 ( 위의 &lt;a href=&quot;#file&quot;&gt;&quot;파일&quot;&lt;/a&gt; 참조, 기본적으로 읽은 파일이있는 경우).</target>
        </trans-unit>
        <trans-unit id="5ea3036e84ed65b742580afd08f2cf97f36ee5c9" translate="yes" xml:space="preserve">
          <source>Write to a file. This uses file descriptors such as those obtained by calling &lt;code&gt;POSIX::open&lt;/code&gt; .</source>
          <target state="translated">파일에 씁니다. &lt;code&gt;POSIX::open&lt;/code&gt; 을 호출하여 얻은 것과 같은 파일 디스크립터를 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="1ddba3f84caaf1f7da5ab41258196ba4aa666d93" translate="yes" xml:space="preserve">
          <source>Write to a file. This uses file descriptors such as those obtained by calling &lt;code&gt;POSIX::open&lt;/code&gt;.</source>
          <target state="translated">파일에 씁니다. 이것은 &lt;code&gt;POSIX::open&lt;/code&gt; 을 호출하여 얻은 것과 같은 파일 설명자를 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="fff8491fc63b40787a6bc354a1c28b21cd65c0f1" translate="yes" xml:space="preserve">
          <source>Write to modules@perl.org explaining what you did to contact the current maintainer. The PAUSE admins will also try to reach the maintainer.</source>
          <target state="translated">현재 관리자에게 연락하기 위해 수행 한 작업을 설명하는 modules@perl.org에 문의하십시오. PAUSE 관리자는 관리자에게 연락을 시도합니다.</target>
        </trans-unit>
        <trans-unit id="ec3b4c2700310731999e0d7e25df0c587f5a195d" translate="yes" xml:space="preserve">
          <source>Write zip files/buffers</source>
          <target state="translated">zip 파일 / 버퍼 작성</target>
        </trans-unit>
        <trans-unit id="08d9173120127debf58115903083c7548d3871d3" translate="yes" xml:space="preserve">
          <source>Write-only access to the data in the file.</source>
          <target state="translated">파일의 데이터에 대한 쓰기 전용 액세스</target>
        </trans-unit>
        <trans-unit id="14518d4671890ab2fd2dc1aa9e641777a8f1afbc" translate="yes" xml:space="preserve">
          <source>WriteConstants ATTRIBUTE =&amp;gt; VALUE [, ...]</source>
          <target state="translated">WriteConstants 속성 =&amp;gt; 값 [, ...]</target>
        </trans-unit>
        <trans-unit id="94dee2fafe1d10d5ce6db659eb0c0fcb3d5842be" translate="yes" xml:space="preserve">
          <source>WriteFile</source>
          <target state="translated">WriteFile</target>
        </trans-unit>
        <trans-unit id="8a1db595bd4c07aab5da69c69b2b0b595010f3b7" translate="yes" xml:space="preserve">
          <source>WriteMakefile() now does some basic sanity checks on its parameters to protect against typos and malformatted values. This means some things which happened to work in the past will now throw warnings and possibly produce internal errors.</source>
          <target state="translated">WriteMakefile ()은 오타 및 형식이 잘못된 값으로부터 보호하기 위해 매개 변수에 대한 기본 무결성 검사를 수행합니다. 이는 과거에 작동했던 일부 문제가 이제 경고를 발생시키고 내부 오류를 발생시킬 수 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="97fe0c70bb91d9c9a985fa7a8dd506d2e586dde0" translate="yes" xml:space="preserve">
          <source>WriteMakefileSnippet</source>
          <target state="translated">WriteMakefileSnippet</target>
        </trans-unit>
        <trans-unit id="6e814e2d111b3599c2bf1ca192478a3ffbfc4053" translate="yes" xml:space="preserve">
          <source>WriteMakefileSnippet ATTRIBUTE =&amp;gt; VALUE [, ...]</source>
          <target state="translated">WriteMakefileSnippet ATTRIBUTE =&amp;gt; VALUE [, ...]</target>
        </trans-unit>
        <trans-unit id="7bdbf771b888449a861406dd116d15dd91371055" translate="yes" xml:space="preserve">
          <source>Writes SIZE bytes from STRING to a memory segment at ADDR starting at position POS. If STRING is too long, only SIZE bytes are used; if STRING is too short, nulls are written to fill out SIZE bytes. Returns true if successful, or false if there is an error.</source>
          <target state="translated">위치 POS에서 시작하여 ADDR의 STRING에서 메모리 세그먼트로 SIZE 바이트를 씁니다. STRING이 너무 길면 SIZE 바이트 만 사용됩니다. STRING이 너무 짧은 경우 SIZE 바이트를 채우기 위해 널이 작성됩니다. 성공하면 true를, 오류가 있으면 false를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="5d0ca93d68b5dc214818ef186a1bc3e2b3d7c8cd" translate="yes" xml:space="preserve">
          <source>Writes a file of C code and a file of XS code which you should &lt;code&gt;#include&lt;/code&gt; and &lt;code&gt;INCLUDE&lt;/code&gt; in the C and XS sections respectively of your module's XS code. You probably want to do this in your &lt;code&gt;Makefile.PL&lt;/code&gt; , so that you can easily edit the list of constants without touching the rest of your module. The attributes supported are</source>
          <target state="translated">C 코드 파일과 XS 코드 파일을 작성합니다.이 코드는 모듈 XS 코드의 C 및 XS 섹션에 각각 &lt;code&gt;#include&lt;/code&gt; 및 &lt;code&gt;INCLUDE&lt;/code&gt; 해야 합니다. &lt;code&gt;Makefile.PL&lt;/code&gt; 에서이 작업을 수행하고 싶을 수 있으므로 나머지 모듈을 건드리지 않고 상수 목록을 쉽게 편집 할 수 있습니다. 지원되는 속성은</target>
        </trans-unit>
        <trans-unit id="e0245702e3fa0201a8eb501ac9938357e48b7d01" translate="yes" xml:space="preserve">
          <source>Writes a file of C code and a file of XS code which you should &lt;code&gt;#include&lt;/code&gt; and &lt;code&gt;INCLUDE&lt;/code&gt; in the C and XS sections respectively of your module's XS code. You probably want to do this in your &lt;code&gt;Makefile.PL&lt;/code&gt;, so that you can easily edit the list of constants without touching the rest of your module. The attributes supported are</source>
          <target state="translated">모듈 XS 코드의 C 및 XS 섹션에 각각 &lt;code&gt;#include&lt;/code&gt; 및 &lt;code&gt;INCLUDE&lt;/code&gt; 해야하는 C 코드 파일과 XS 코드 파일을 작성합니다. 나머지 모듈을 건드리지 않고도 상수 목록을 쉽게 편집 할 수 있도록 &lt;code&gt;Makefile.PL&lt;/code&gt; 에서이 작업을 수행 할 수 있습니다. 지원되는 속성은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e8e7628595fe05e976f01b228c1371b889b4fb1c" translate="yes" xml:space="preserve">
          <source>Writes a formatted record (possibly multi-line) to the specified FILEHANDLE, using the format associated with that file. By default the format for a file is the one having the same name as the filehandle, but the format for the current output channel (see the &lt;a href=&quot;#select-FILEHANDLE&quot;&gt;&lt;code&gt;select&lt;/code&gt;&lt;/a&gt; function) may be set explicitly by assigning the name of the format to the &lt;a href=&quot;perlvar#%24~&quot;&gt;&lt;code&gt;$~&lt;/code&gt;&lt;/a&gt; variable.</source>
          <target state="translated">해당 파일과 연관된 형식을 사용하여 지정된 FILEHANDLE에 형식화 된 레코드 (여러 행)를 씁니다. 기본적으로 파일 형식은 파일 핸들과 이름이 같은 형식이지만 현재 출력 채널의 형식 ( &lt;a href=&quot;#select-FILEHANDLE&quot;&gt; &lt;code&gt;select&lt;/code&gt; &lt;/a&gt; 함수 참조 )은 형식 이름을 &lt;a href=&quot;perlvar#%24~&quot;&gt; &lt;code&gt;$~&lt;/code&gt; &lt;/a&gt; 변수 에 할당하여 명시 적으로 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="68caf753088df284b27998c0bc22c79c995c9f8a" translate="yes" xml:space="preserve">
          <source>Writes a formatted record (possibly multi-line) to the specified FILEHANDLE, using the format associated with that file. By default the format for a file is the one having the same name as the filehandle, but the format for the current output channel (see the &lt;code&gt;&lt;a href=&quot;functions/select&quot;&gt;select&lt;/a&gt;&lt;/code&gt; function) may be set explicitly by assigning the name of the format to the &lt;code&gt;$~&lt;/code&gt; variable.</source>
          <target state="translated">해당 파일과 연관된 형식을 사용하여 형식이 지정된 레코드 (여러 행)를 지정된 FILEHANDLE에 씁니다. 기본적으로 파일의 형식은 파일 핸들과 이름이 같은 형식이지만, 현재 출력 채널의 형식 ( &lt;code&gt;&lt;a href=&quot;functions/select&quot;&gt;select&lt;/a&gt;&lt;/code&gt; 기능 참조 )은 &lt;code&gt;$~&lt;/code&gt; 변수에 형식의 이름을 지정하여 명시 적으로 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3c8b534fc59790f52bbc323708c6a448e4336f1e" translate="yes" xml:space="preserve">
          <source>Writes a formatted record (possibly multi-line) to the specified FILEHANDLE, using the format associated with that file. By default the format for a file is the one having the same name as the filehandle, but the format for the current output channel (see the &lt;code&gt;&lt;a href=&quot;select&quot;&gt;select&lt;/a&gt;&lt;/code&gt; function) may be set explicitly by assigning the name of the format to the &lt;code&gt;$~&lt;/code&gt; variable.</source>
          <target state="translated">해당 파일과 연관된 형식을 사용하여 형식이 지정된 레코드 (여러 행)를 지정된 FILEHANDLE에 씁니다. 기본적으로 파일의 형식은 파일 핸들과 이름이 같은 형식이지만, 현재 출력 채널의 형식 ( &lt;code&gt;&lt;a href=&quot;select&quot;&gt;select&lt;/a&gt;&lt;/code&gt; 기능 참조 )은 &lt;code&gt;$~&lt;/code&gt; 변수에 형식의 이름을 지정하여 명시 적으로 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4e8961057173b914aa902d24e81d3c55d00dde52" translate="yes" xml:space="preserve">
          <source>Writes all files in and below the current directory to your</source>
          <target state="translated">현재 디렉토리 내외의 모든 파일을</target>
        </trans-unit>
        <trans-unit id="1ff3060cc065fe5dcf829a42d2a8d401fd64f6d8" translate="yes" xml:space="preserve">
          <source>Writes an empty FORCE: target.</source>
          <target state="translated">빈 FORCE : target을 씁니다.</target>
        </trans-unit>
        <trans-unit id="f5369d43b2f75bf65f1c9b2bf55177161b67ef85" translate="yes" xml:space="preserve">
          <source>Writes are permitted, i.e. opened as &quot;w&quot; or &quot;r+&quot; or &quot;a&quot;, etc.</source>
          <target state="translated">쓰기가 허용됩니다. 즉 &quot;w&quot;또는 &quot;r +&quot;또는 &quot;a&quot;로 열립니다.</target>
        </trans-unit>
        <trans-unit id="bc03658e3c61d9705d37afb50e35b60738df57d4" translate="yes" xml:space="preserve">
          <source>Writes the contents of &lt;code&gt;$buffer&lt;/code&gt; to the compressed file. Returns the number of bytes actually written, or 0 on error.</source>
          <target state="translated">&lt;code&gt;$buffer&lt;/code&gt; 의 내용을 압축 파일에 씁니다 . 실제로 쓴 바이트 수를 반환하거나 오류가 발생하면 0을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="3b30b2d9d9b94819a1a73fa66ad9fdb3aaf93cb5" translate="yes" xml:space="preserve">
          <source>Writes the file META.yml (YAML encoded meta-data) and META.json (JSON encoded meta-data) about the module in the distdir. The format follows Module::Build's as closely as possible.</source>
          <target state="translated">distdir의 모듈에 대한 파일 META.yml (YAML 인코딩 메타 데이터) 및 META.json (JSON 인코딩 메타 데이터)을 씁니다. 형식은 가능한 한 Module :: Build를 따릅니다.</target>
        </trans-unit>
        <trans-unit id="759cd7af683913d2e067b4f6ffe525a9a1d4a391" translate="yes" xml:space="preserve">
          <source>Writes the file SIGNATURE with &quot;cpansign -s&quot;.</source>
          <target state="translated">SIGNATURE 파일을 &quot;cpansign -s&quot;로 작성합니다.</target>
        </trans-unit>
        <trans-unit id="284cf58439290385abdec38ca7c004471227b097" translate="yes" xml:space="preserve">
          <source>Writes the output of</source>
          <target state="translated">출력을 씁니다.</target>
        </trans-unit>
        <trans-unit id="7576a6f2b013b505dded5e0784047fb79ad928e8" translate="yes" xml:space="preserve">
          <source>Writes to the &lt;code&gt;.c&lt;/code&gt; output file certain preprocessor directives and function headers needed in all such files.</source>
          <target state="translated">이러한 모든 파일에 필요한 특정 전 처리기 지시문 및 함수 헤더를 &lt;code&gt;.c&lt;/code&gt; 출력 파일에 씁니다 .</target>
        </trans-unit>
        <trans-unit id="fdd8d478482d63bc406cd41436757960d17780fb" translate="yes" xml:space="preserve">
          <source>Writing Accessors</source>
          <target state="translated">접근 자 작성</target>
        </trans-unit>
        <trans-unit id="1986c44b3bdced950b196d1c43f6cf37a6963d63" translate="yes" xml:space="preserve">
          <source>Writing Constructors</source>
          <target state="translated">작문 생성자</target>
        </trans-unit>
        <trans-unit id="2e43f89f29a3e136e02e547cac033fa128355bb0" translate="yes" xml:space="preserve">
          <source>Writing Perl on an EBCDIC platform is really no different than writing on an &lt;a href=&quot;#ASCII&quot;&gt;&quot;ASCII&quot;&lt;/a&gt; one, but with different underlying numbers, as we'll see shortly. You'll have to know something about those &lt;a href=&quot;#ASCII&quot;&gt;&quot;ASCII&quot;&lt;/a&gt; platforms because the documentation is biased and will frequently use example numbers that don't apply to EBCDIC. There are also very few CPAN modules that are written for EBCDIC and which don't work on ASCII; instead the vast majority of CPAN modules are written for ASCII, and some may happen to work on EBCDIC, while a few have been designed to portably work on both.</source>
          <target state="translated">EBCDIC 플랫폼에서 Perl을 작성하는 것은 &lt;a href=&quot;#ASCII&quot;&gt;&quot;ASCII&quot;&lt;/a&gt; 플랫폼에서 작성하는 것과 실제로 다르지 않지만 곧 살펴 보 겠지만 기본 숫자가 다릅니다. 문서가 편향되어 있고 EBCDIC에 적용되지 않는 예제 번호를 자주 사용하기 때문에 이러한 &lt;a href=&quot;#ASCII&quot;&gt;&quot;ASCII&quot;&lt;/a&gt; 플랫폼 에 대해 알아야합니다 . 또한 EBCDIC 용으로 작성되고 ASCII에서 작동하지 않는 CPAN 모듈이 거의 없습니다. 대신 대부분의 CPAN 모듈은 ASCII 용으로 작성되었으며 일부는 EBCDIC에서 작동 할 수 있으며 일부는 둘 다에서 이식 가능하도록 설계되었습니다.</target>
        </trans-unit>
        <trans-unit id="ac0e44a3a37a4109877068f7584a4c6e490675d8" translate="yes" xml:space="preserve">
          <source>Writing Perl on an EBCDIC platform is really no different than writing on an &lt;a href=&quot;#ASCII&quot;&gt;ASCII&lt;/a&gt; one, but with different underlying numbers, as we'll see shortly. You'll have to know something about those &lt;a href=&quot;#ASCII&quot;&gt;ASCII&lt;/a&gt; platforms because the documentation is biased and will frequently use example numbers that don't apply to EBCDIC. There are also very few CPAN modules that are written for EBCDIC and which don't work on ASCII; instead the vast majority of CPAN modules are written for ASCII, and some may happen to work on EBCDIC, while a few have been designed to portably work on both.</source>
          <target state="translated">EBCDIC 플랫폼에서 Perl을 작성하는 것은 실제로 &lt;a href=&quot;#ASCII&quot;&gt;ASCII에서&lt;/a&gt; 작성하는 것과 다르지 않지만 곧 알 수 있듯이 기본 숫자가 다릅니다. 설명서가 편향되어 있고 EBCDIC에 적용되지 않는 예제 번호를 자주 사용하므로 &lt;a href=&quot;#ASCII&quot;&gt;ASCII&lt;/a&gt; 플랫폼 에 대해 알아야합니다 . EBCDIC 용으로 작성되었으며 ASCII에서 작동하지 않는 CPAN 모듈도 거의 없습니다. 대신 대부분의 CPAN 모듈은 ASCII 용으로 작성되었으며 일부는 EBCDIC에서 작동 할 수 있지만 일부는 두 가지 모두에서 이식 가능하도록 설계되었습니다.</target>
        </trans-unit>
        <trans-unit id="b3e7a0572dc689213dcccc6f0ad9b2cbd894a46a" translate="yes" xml:space="preserve">
          <source>Writing Plugins</source>
          <target state="translated">플러그인 작성</target>
        </trans-unit>
        <trans-unit id="b23e7b02c4f050eb7a5f668109f71a414a28c33d" translate="yes" xml:space="preserve">
          <source>Writing Your Own Debugger</source>
          <target state="translated">자신의 디버거 작성</target>
        </trans-unit>
        <trans-unit id="12d7ef5d9c4d923fdecfc0a2ba03562ba21e7e82" translate="yes" xml:space="preserve">
          <source>Writing a Filter</source>
          <target state="translated">필터 작성</target>
        </trans-unit>
        <trans-unit id="7f135a17864ace6ae98bf7a3b9d9b4e20dd72358" translate="yes" xml:space="preserve">
          <source>Writing a module with MakeMaker</source>
          <target state="translated">MakeMaker로 모듈 작성</target>
        </trans-unit>
        <trans-unit id="f103eaa4bfb0cd111ad63870dfe99daf1dbfeefb" translate="yes" xml:space="preserve">
          <source>Writing a source filter as a separate executable works fine, but a small performance penalty is incurred. For example, if you execute the small example above, a separate subprocess will be created to run the Unix &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr&lt;/a&gt;&lt;/code&gt; command. Each use of the filter requires its own subprocess. If creating subprocesses is expensive on your system, you might want to consider one of the other options for creating source filters.</source>
          <target state="translated">소스 필터를 별도의 실행 파일로 작성하면 정상적으로 작동하지만 약간의 성능 저하가 발생합니다. 예를 들어, 위의 작은 예제를 실행하면 Unix &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr&lt;/a&gt;&lt;/code&gt; 명령 을 실행하기위한 별도의 하위 프로세스가 작성됩니다 . 필터를 사용할 때마다 자체 하위 프로세스가 필요합니다. 시스템에서 서브 프로세스 작성 비용이 비싸면 소스 필터 작성을위한 다른 옵션 중 하나를 고려할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="42340678aabb28dd8e04eb2e84c897c77707c165" translate="yes" xml:space="preserve">
          <source>Writing a source filter as a separate executable works fine, but a small performance penalty is incurred. For example, if you execute the small example above, a separate subprocess will be created to run the Unix &lt;code&gt;tr&lt;/code&gt; command. Each use of the filter requires its own subprocess. If creating subprocesses is expensive on your system, you might want to consider one of the other options for creating source filters.</source>
          <target state="translated">소스 필터를 별도의 실행 파일로 작성하면 잘 작동하지만 약간의 성능 저하가 발생합니다. 예를 들어 위의 작은 예제를 실행하면 Unix &lt;code&gt;tr&lt;/code&gt; 명령 을 실행하기 위해 별도의 하위 프로세스가 생성됩니다 . 필터를 사용할 때마다 자체 하위 프로세스가 필요합니다. 시스템에서 하위 프로세스를 만드는 데 비용이 많이 드는 경우 소스 필터를 만들기위한 다른 옵션 중 하나를 고려할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e224913e88be93885651c47ecb1638090afee7fe" translate="yes" xml:space="preserve">
          <source>Writing all these print statements rapidly gets tedious. Fortunately, there's &lt;a href=&quot;Test::Simple&quot;&gt;Test::Simple&lt;/a&gt;. It has one function, &lt;code&gt;ok()&lt;/code&gt;.</source>
          <target state="translated">이 모든 인쇄 문을 작성하는 것은 금방 지루해집니다. 다행히 &lt;a href=&quot;Test::Simple&quot;&gt;Test :: Simple이&lt;/a&gt; 있습니다. &lt;code&gt;ok()&lt;/code&gt; 함수가 하나 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fc88b791ccf860fd9df472625687a215e4594f7f" translate="yes" xml:space="preserve">
          <source>Writing backticks in your program sends a clear message to the readers of your code that you wanted to collect the output of the command. Why send a clear message that isn't true?</source>
          <target state="translated">프로그램에 백틱을 쓰면 명령의 출력을 수집하려는 코드 독자에게 명확한 메시지를 보냅니다. 사실이 아닌 명확한 메시지를 보내는 이유는 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="a44149bd1f420e38e67feec9febfbe47dcef5694" translate="yes" xml:space="preserve">
          <source>Writing good test scripts</source>
          <target state="translated">좋은 테스트 스크립트 작성</target>
        </trans-unit>
        <trans-unit id="0d1216f3de5359a11d177bd450454690960a8410" translate="yes" xml:space="preserve">
          <source>Writing subroutines</source>
          <target state="translated">서브 루틴 작성</target>
        </trans-unit>
        <trans-unit id="a553ca3bc37b04388da0cff3bc379f04cee8df42" translate="yes" xml:space="preserve">
          <source>Writing subroutines is easy:</source>
          <target state="translated">서브 루틴 작성은 쉽습니다.</target>
        </trans-unit>
        <trans-unit id="c828d0e28e2f569743446e2de56ca66e456c09b7" translate="yes" xml:space="preserve">
          <source>Writing the patch</source>
          <target state="translated">패치 작성</target>
        </trans-unit>
        <trans-unit id="5c10b682e330dccc302170e80493f9eb65449a91" translate="yes" xml:space="preserve">
          <source>Writing the short option first is recommended because it's easier to read. The long option is long enough to draw the eye to it anyway and the short option can otherwise get lost in visual noise.</source>
          <target state="translated">읽기 쉬운 옵션이므로 짧은 옵션을 먼저 작성하는 것이 좋습니다. 긴 옵션은 어쨌든 시선을 끌 정도로 길며 짧은 옵션은 시각적 노이즈로 인해 손실 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1b1d022be94ce5d1101d118c8c80cf3364019b48" translate="yes" xml:space="preserve">
          <source>Writing typemap Entries</source>
          <target state="translated">타입 맵 항목 작성</target>
        </trans-unit>
        <trans-unit id="1292edaa487b14cb74f82d4343628858075e0756" translate="yes" xml:space="preserve">
          <source>Wrong: the Storable engine creates an empty one for you. If you know Eiffel, you can view &lt;code&gt;STORABLE_thaw&lt;/code&gt; as an alternate creation routine.</source>
          <target state="translated">잘못됨 : 저장 가능 엔진이 비어 있습니다. Eiffel을 알고 있다면 &lt;code&gt;STORABLE_thaw&lt;/code&gt; 를 대체 작성 루틴으로 볼 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="efb99bcd657604ed5888480f20557abaea6afd06" translate="yes" xml:space="preserve">
          <source>Wx</source>
          <target state="translated">Wx</target>
        </trans-unit>
        <trans-unit id="c032adc1ff629c9b66f22749ad667e6beadf144b" translate="yes" xml:space="preserve">
          <source>X</source>
          <target state="translated">X</target>
        </trans-unit>
        <trans-unit id="af3f0530ce3709877b0c716af9417386f334acd7" translate="yes" xml:space="preserve">
          <source>X [vars]</source>
          <target state="translated">X [vars]</target>
        </trans-unit>
        <trans-unit id="75a98d9bf0f92217c5e8d8919ec41748402162fa" translate="yes" xml:space="preserve">
          <source>XCPT_CATCH</source>
          <target state="translated">XCPT_CATCH</target>
        </trans-unit>
        <trans-unit id="0bbce50dfafd43d2aea26e0a316ecb5bb2789444" translate="yes" xml:space="preserve">
          <source>XCPT_RETHROW</source>
          <target state="translated">XCPT_RETHROW</target>
        </trans-unit>
        <trans-unit id="1c8ec453fa062fcc4d8beb21dfeb7f00e0044e3e" translate="yes" xml:space="preserve">
          <source>XCPT_TRY_END</source>
          <target state="translated">XCPT_TRY_END</target>
        </trans-unit>
        <trans-unit id="62c03b6a034496de09dbf74c72c47fb4b194a801" translate="yes" xml:space="preserve">
          <source>XCPT_TRY_START</source>
          <target state="translated">XCPT_TRY_START</target>
        </trans-unit>
        <trans-unit id="42573a00146341106bb0f06ab931a0b8e20775e3" translate="yes" xml:space="preserve">
          <source>XEmacs</source>
          <target state="translated">XEmacs</target>
        </trans-unit>
        <trans-unit id="c0aa9ef764d832b80428d756a731a94251b0e3a1" translate="yes" xml:space="preserve">
          <source>XML</source>
          <target state="translated">XML</target>
        </trans-unit>
        <trans-unit id="494019465f27565c960f3085abca99be390bd01b" translate="yes" xml:space="preserve">
          <source>XML charref mode (</source>
          <target state="translated">XML charref 모드 (</target>
        </trans-unit>
        <trans-unit id="7a5fc108bfdd5d96d6f99a6eac89c9af874db7d8" translate="yes" xml:space="preserve">
          <source>XPG operability often implies the presence of an</source>
          <target state="translated">XPG 조작성은 종종</target>
        </trans-unit>
        <trans-unit id="0f082b9799dcb8475e7d6fcb04a5adfa774635d5" translate="yes" xml:space="preserve">
          <source>XPUSH args AND set RETVAL AND assign return value to array</source>
          <target state="translated">XPUSH 인수 및 RETVAL 설정 및 반환 값을 배열에 할당</target>
        </trans-unit>
        <trans-unit id="6e96c8ba90434c3991abef6b482029bbb705d617" translate="yes" xml:space="preserve">
          <source>XPUSHi</source>
          <target state="translated">XPUSHi</target>
        </trans-unit>
        <trans-unit id="a45f993c8bc95467cd94eca181fdf46437f5427b" translate="yes" xml:space="preserve">
          <source>XPUSHmortal</source>
          <target state="translated">XPUSHmortal</target>
        </trans-unit>
        <trans-unit id="b231a036815021c5444d064b7fcc1c528ade03e8" translate="yes" xml:space="preserve">
          <source>XPUSHn</source>
          <target state="translated">XPUSHn</target>
        </trans-unit>
        <trans-unit id="f47cdabf2ef1edeef2bd1fb53b6f18747c332149" translate="yes" xml:space="preserve">
          <source>XPUSHp</source>
          <target state="translated">XPUSHp</target>
        </trans-unit>
        <trans-unit id="1dab76d5986d1df120c308434288452972f88fb7" translate="yes" xml:space="preserve">
          <source>XPUSHs</source>
          <target state="translated">XPUSHs</target>
        </trans-unit>
        <trans-unit id="f596fc77ff9e6f6918218a1843202b6b44412bbc" translate="yes" xml:space="preserve">
          <source>XPUSHu</source>
          <target state="translated">XPUSHu</target>
        </trans-unit>
        <trans-unit id="bdb1d0d2760db0ae33b02dff5258e945e708b990" translate="yes" xml:space="preserve">
          <source>XS</source>
          <target state="translated">XS</target>
        </trans-unit>
        <trans-unit id="92bd1887109d3a53eb97d00630c2016c2f9abe52" translate="yes" xml:space="preserve">
          <source>XS VERSION</source>
          <target state="translated">XS 버전</target>
        </trans-unit>
        <trans-unit id="f150c9e4da4e74cdaf804a24288dd2d36c2aab56" translate="yes" xml:space="preserve">
          <source>XS code added by Greg Bacon &amp;lt;</source>
          <target state="translated">Greg Bacon이 추가 한 XS 코드 &amp;lt;</target>
        </trans-unit>
        <trans-unit id="1cf142c571c2183260c4664ac183845da5980944" translate="yes" xml:space="preserve">
          <source>XS code can usually be made to work with any platform, but dependent libraries, header files, etc., might not be readily available or portable, or the XS code itself might be platform-specific, just as Perl code might be. If the libraries and headers are portable, then it is normally reasonable to make sure the XS code is portable, too.</source>
          <target state="translated">XS 코드는 일반적으로 모든 플랫폼에서 작동하도록 만들 수 있지만 Perl 코드와 마찬가지로 종속 라이브러리, 헤더 파일 등을 쉽게 사용할 수 없거나 이식 가능하지 않거나 XS 코드 자체가 플랫폼에 따라 다를 수 있습니다. 라이브러리와 헤더가 이식 가능한 경우 XS 코드도 이식 가능한지 확인하는 것이 일반적입니다.</target>
        </trans-unit>
        <trans-unit id="292d659c22a7eedddefa474cf1aa726bcee0908b" translate="yes" xml:space="preserve">
          <source>XS code for using native C functions borrowed from &lt;code&gt;&lt;a href=&quot;Unix::Syslog&quot;&gt;Unix::Syslog&lt;/a&gt;&lt;/code&gt;, written by Marcus Harnisch &amp;lt;</source>
          <target state="translated">Marcus Harnisch가 작성한 &lt;code&gt;&lt;a href=&quot;Unix::Syslog&quot;&gt;Unix::Syslog&lt;/a&gt;&lt;/code&gt; 에서 빌린 네이티브 C 함수를 사용하기위한 XS 코드 &amp;lt;</target>
        </trans-unit>
        <trans-unit id="7e8ccd1927a425f4cd71fc5858f4ce61be503a94" translate="yes" xml:space="preserve">
          <source>XS code for using native C functions borrowed from &lt;code&gt;&lt;a href=&quot;http://search.cpan.org/perldoc/Unix::Syslog&quot;&gt;Unix::Syslog&lt;/a&gt;&lt;/code&gt;, written by Marcus Harnisch &amp;lt;</source>
          <target state="translated">Marcus Harnisch가 작성한 &lt;code&gt;&lt;a href=&quot;http://search.cpan.org/perldoc/Unix::Syslog&quot;&gt;Unix::Syslog&lt;/a&gt;&lt;/code&gt; 에서 빌린 네이티브 C 함수를 사용하기위한 XS 코드 &amp;lt;</target>
        </trans-unit>
        <trans-unit id="fe30568ef2d4c300e100572dbcce63bef5e87790" translate="yes" xml:space="preserve">
          <source>XS code has full access to system calls including C library functions. It thus has the capability of interfering with things that the Perl core or other modules have set up, such as signal handlers or file handles. It could mess with the memory, or any number of harmful things. Don't.</source>
          <target state="translated">XS 코드는 C 라이브러리 함수를 포함한 시스템 호출에 대한 모든 액세스 권한을 갖습니다. 따라서 신호 처리기 또는 파일 핸들과 같은 Perl 코어 또는 다른 모듈에서 설정 한 사항을 방해 할 수 있습니다. 메모리 나 여러 가지 유해한 것들을 망칠 수 있습니다. 하지마</target>
        </trans-unit>
        <trans-unit id="33d48b61f9e9a038a7aea1ef00483763c58f6eff" translate="yes" xml:space="preserve">
          <source>XS code is probably better using &quot;typemap&quot; if it expects FILE * arguments. The standard typemap will be adjusted to comprehend any changes in this area.</source>
          <target state="translated">XS 코드는 FILE * 인수가 필요한 경우 &quot;typemap&quot;을 사용하는 것이 좋습니다. 이 영역의 모든 변경 사항을 이해하기 위해 표준 유형 맵이 조정됩니다.</target>
        </trans-unit>
        <trans-unit id="89e8c193e223b649f3d44b4194d19ce56bb23e01" translate="yes" xml:space="preserve">
          <source>XS code is very sensitive to the module version number and will complain if the version number in your Perl module doesn't match. If you change your module's version # without rerunning Makefile.PL the old version number will remain in the Makefile, causing the XS code to be built with the wrong number.</source>
          <target state="translated">XS 코드는 모듈 버전 번호에 매우 민감하며 Perl 모듈의 버전 번호가 일치하지 않으면 불평합니다. Makefile.PL을 다시 실행하지 않고 모듈의 버전 번호를 변경하면 이전 버전 번호가 Makefile에 남아 XS 코드가 잘못된 번호로 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="9966dea2f0bef9d06ac3bd55d265441a4061b99f" translate="yes" xml:space="preserve">
          <source>XS code or C-language libraries called from it that use the system &lt;a href=&quot;setlocale(3)&quot;&gt;&lt;code&gt;setlocale(3)&lt;/code&gt;&lt;/a&gt; function (except on Windows) likely will not work from a multi-threaded application without changes. See &lt;a href=&quot;perlxs#Locale-aware-XS-code&quot;&gt;&quot;Locale-aware XS code&quot; in perlxs&lt;/a&gt;.</source>
          <target state="translated">시스템 &lt;a href=&quot;setlocale(3)&quot;&gt; &lt;code&gt;setlocale(3)&lt;/code&gt; &lt;/a&gt; 함수 (Windows 제외 ) 를 사용하는 XS 코드 또는 C 언어 라이브러리는 변경없이 다중 스레드 응용 프로그램에서 작동하지 않을 수 있습니다. &lt;a href=&quot;perlxs#Locale-aware-XS-code&quot;&gt;perlxs의 &quot;로케일 인식 XS 코드&quot;를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="def563b19b3d7a04b960dc4d401ac89d52a4e717" translate="yes" xml:space="preserve">
          <source>XS is an interface description file format used to create an extension interface between Perl and C code (or a C library) which one wishes to use with Perl. The XS interface is combined with the library to create a new library which can then be either dynamically loaded or statically linked into perl. The XS interface description is written in the XS language and is the core component of the Perl extension interface.</source>
          <target state="translated">XS는 Perl과 함께 사용하고자하는 Perl과 C 코드 (또는 C 라이브러리) 사이의 확장 인터페이스를 작성하는 데 사용되는 인터페이스 설명 파일 형식입니다. XS 인터페이스는 라이브러리와 결합되어 새 라이브러리를 생성 한 다음 동적으로로드하거나 정적으로 펄에 링크 할 수 있습니다. XS 인터페이스 설명은 XS 언어로 작성되었으며 Perl 확장 인터페이스의 핵심 구성 요소입니다.</target>
        </trans-unit>
        <trans-unit id="c1322757203b80e7b2662642555746c59f625860" translate="yes" xml:space="preserve">
          <source>XS modules for all categories but &lt;code&gt;LC_NUMERIC&lt;/code&gt; get the underlying locale, and hence any C library functions they call will use that underlying locale. For more discussion, see &lt;a href=&quot;perlxs#CAVEATS&quot;&gt;&quot;CAVEATS&quot; in perlxs&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;LC_NUMERIC&lt;/code&gt; 을 제외한 모든 범주에 대한 XS 모듈 은 기본 로케일을 가져 오므로 호출하는 모든 C 라이브러리 함수는 해당 기본 로케일을 사용합니다. 자세한 내용 &lt;a href=&quot;perlxs#CAVEATS&quot;&gt;은 perlxs의 &quot;CAVEATS&quot;를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c6e0da0571ab8b6cd13332fb1b92e13ef69723c3" translate="yes" xml:space="preserve">
          <source>XS modules for all categories but &lt;code&gt;LC_NUMERIC&lt;/code&gt; get the underlying locale, and hence any C library functions they call will use that underlying locale. For more discussion, see &lt;a href=&quot;perlxs#CAVEATS&quot;&gt;CAVEATS in perlxs&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;LC_NUMERIC&lt;/code&gt; 을 제외한 모든 범주의 XS 모듈 은 기본 로캘을 가져 오므로 호출하는 모든 C 라이브러리 함수는 해당 기본 로캘을 사용합니다. 자세한 내용 &lt;a href=&quot;perlxs#CAVEATS&quot;&gt;은 perlxs의주의 사항을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="cde8f9f4aa7dc1d35b0c98fee87c3ff3dfbc220c" translate="yes" xml:space="preserve">
          <source>XS-type modules do require re-linking the perl binary, because part of an XS module is written in &quot;C&quot;, and has to be linked together with the perl binary to be executed. This is required because perl under DJGPP is built with the &quot;static link&quot; option, due to the lack of &quot;dynamic linking&quot; in the DJGPP environment.</source>
          <target state="translated">XS 모듈의 일부는 &quot;C&quot;로 작성되고 실행되는 perl 바이너리와 함께 연결되어야하기 때문에 XS 유형 모듈은 perl 바이너리를 다시 연결해야합니다. 이는 DJGPP 환경에서 &quot;동적 연결&quot;이 없기 때문에 DJGPP의 perl이 &quot;정적 연결&quot;옵션으로 구축되기 때문에 필요합니다.</target>
        </trans-unit>
        <trans-unit id="ec2988beaa8676362d1ed3ab16467d9b855facea" translate="yes" xml:space="preserve">
          <source>XS::APItest</source>
          <target state="translated">XS::APItest</target>
        </trans-unit>
        <trans-unit id="f864391a1885990bb3986e5bb9cdfe1529118689" translate="yes" xml:space="preserve">
          <source>XS::APItest - Test the perl C API</source>
          <target state="translated">XS :: APItest-perl C API 테스트</target>
        </trans-unit>
        <trans-unit id="77965b88f2916dfa7ea799a1ecde83c5bade894f" translate="yes" xml:space="preserve">
          <source>XS::Typemap</source>
          <target state="translated">XS::Typemap</target>
        </trans-unit>
        <trans-unit id="1e9618266eb67d10623f9d27874dc8f7655ade73" translate="yes" xml:space="preserve">
          <source>XS::Typemap - module to test the XS typemaps distributed with perl</source>
          <target state="translated">XS :: Typemap-펄과 함께 배포 된 XS 타입 맵을 테스트하는 모듈</target>
        </trans-unit>
        <trans-unit id="abb06f137479712fdf29157a9f339063d581a30d" translate="yes" xml:space="preserve">
          <source>XSBUILD</source>
          <target state="translated">XSBUILD</target>
        </trans-unit>
        <trans-unit id="69f57ba624b38c0aa8389aea0ffe9fd217df0165" translate="yes" xml:space="preserve">
          <source>XSLoader</source>
          <target state="translated">XSLoader</target>
        </trans-unit>
        <trans-unit id="afd8fa1c6f48c528375edb581b5cfae64284c5a7" translate="yes" xml:space="preserve">
          <source>XSLoader - Dynamically load C libraries into Perl code</source>
          <target state="translated">XSLoader-C 라이브러리를 Perl 코드에 동적으로로드</target>
        </trans-unit>
        <trans-unit id="beb5f03415996a22eb7162d79a1cf0e450db5ba8" translate="yes" xml:space="preserve">
          <source>XSMULTI</source>
          <target state="translated">XSMULTI</target>
        </trans-unit>
        <trans-unit id="0921a161e9b005cd558f520ad84c3711a9234802" translate="yes" xml:space="preserve">
          <source>XSOPT</source>
          <target state="translated">XSOPT</target>
        </trans-unit>
        <trans-unit id="92e8e6dd254dabeb8537af4197e956a328b3ea2d" translate="yes" xml:space="preserve">
          <source>XSPROTOARG</source>
          <target state="translated">XSPROTOARG</target>
        </trans-unit>
        <trans-unit id="870a57e9b71b2a4c7d8b5d7661446dadbdc3d78c" translate="yes" xml:space="preserve">
          <source>XSRETURN</source>
          <target state="translated">XSRETURN</target>
        </trans-unit>
        <trans-unit id="4412705ffd15db1cc81dd4e97115e4240eed7c02" translate="yes" xml:space="preserve">
          <source>XSRETURN_EMPTY</source>
          <target state="translated">XSRETURN_EMPTY</target>
        </trans-unit>
        <trans-unit id="7516ad5d6afe7eff2028827f9d3ce25b91d747e1" translate="yes" xml:space="preserve">
          <source>XSRETURN_IV</source>
          <target state="translated">XSRETURN_IV</target>
        </trans-unit>
        <trans-unit id="7e5a22d1a7883f884227641cdf52bde57c7c0cd5" translate="yes" xml:space="preserve">
          <source>XSRETURN_NO</source>
          <target state="translated">XSRETURN_NO</target>
        </trans-unit>
        <trans-unit id="a72df091bba7b8d6d0f9b76040485b4a1059b320" translate="yes" xml:space="preserve">
          <source>XSRETURN_NV</source>
          <target state="translated">XSRETURN_NV</target>
        </trans-unit>
        <trans-unit id="c9bd2b450336e9a3992bddc7c7b4a884bb908613" translate="yes" xml:space="preserve">
          <source>XSRETURN_PV</source>
          <target state="translated">XSRETURN_PV</target>
        </trans-unit>
        <trans-unit id="31bb0caf5acf67711f8b48a53013782fa24d0e5c" translate="yes" xml:space="preserve">
          <source>XSRETURN_UNDEF</source>
          <target state="translated">XSRETURN_UNDEF</target>
        </trans-unit>
        <trans-unit id="75dd44c03d403bbc60a246b9a6263dd12586d022" translate="yes" xml:space="preserve">
          <source>XSRETURN_UV</source>
          <target state="translated">XSRETURN_UV</target>
        </trans-unit>
        <trans-unit id="6940b196422b14c137e4603100533585c01d3873" translate="yes" xml:space="preserve">
          <source>XSRETURN_YES</source>
          <target state="translated">XSRETURN_YES</target>
        </trans-unit>
        <trans-unit id="0071e55f0de2d741b86408cbdd221e6b71588408" translate="yes" xml:space="preserve">
          <source>XST_mIV</source>
          <target state="translated">XST_mIV</target>
        </trans-unit>
        <trans-unit id="8746b00346bb95fd6d7203847b95eace0e227af2" translate="yes" xml:space="preserve">
          <source>XST_mNO</source>
          <target state="translated">XST_mNO</target>
        </trans-unit>
        <trans-unit id="18b7e60b2312b4cdf84185a38f3105ba024df44d" translate="yes" xml:space="preserve">
          <source>XST_mNV</source>
          <target state="translated">XST_mNV</target>
        </trans-unit>
        <trans-unit id="f5704ef0a40693c861b7a0f79e6acb2f0a79e526" translate="yes" xml:space="preserve">
          <source>XST_mPV</source>
          <target state="translated">XST_mPV</target>
        </trans-unit>
        <trans-unit id="b30947135a6d0dc9cd094f1f5c672b0d8df27a87" translate="yes" xml:space="preserve">
          <source>XST_mUNDEF</source>
          <target state="translated">XST_mUNDEF</target>
        </trans-unit>
        <trans-unit id="c4c00149e31a863f36a4eccec4b30bed628c9d7b" translate="yes" xml:space="preserve">
          <source>XST_mUV</source>
          <target state="translated">XST_mUV</target>
        </trans-unit>
        <trans-unit id="850783c2d3d2b8cee3448cdaf150b58812cdd570" translate="yes" xml:space="preserve">
          <source>XST_mYES</source>
          <target state="translated">XST_mYES</target>
        </trans-unit>
        <trans-unit id="ddfc93741501a0abefa88da99d97e36deaed4cbc" translate="yes" xml:space="preserve">
          <source>XSUB</source>
          <target state="translated">XSUB</target>
        </trans-unit>
        <trans-unit id="4579138c9695c3de09b5142af11ef81d8446e749" translate="yes" xml:space="preserve">
          <source>XSUB.h</source>
          <target state="translated">XSUB.h</target>
        </trans-unit>
        <trans-unit id="df024d96e0c6354fb4e32675dd41d60e15bc6f98" translate="yes" xml:space="preserve">
          <source>XSUBANY</source>
          <target state="translated">XSUBANY</target>
        </trans-unit>
        <trans-unit id="4df5cfe3d83127b158a7d5a161b5570785b675ad" translate="yes" xml:space="preserve">
          <source>XSUBs and the Argument Stack</source>
          <target state="translated">XSUB와 인수 스택</target>
        </trans-unit>
        <trans-unit id="638efca4cf9c7b80e03f195d87e0ea4d39d29c81" translate="yes" xml:space="preserve">
          <source>XSUBs are also allowed to avoid automatic conversion of Perl function arguments to C function arguments. See &lt;a href=&quot;perlxs&quot;&gt;perlxs&lt;/a&gt; for details. Some people prefer manual conversion by inspecting &lt;code&gt;ST(i)&lt;/code&gt; even in the cases when automatic conversion will do, arguing that this makes the logic of an XSUB call clearer. Compare with &lt;a href=&quot;#Getting-the-fat-out-of-XSUBs&quot;&gt;&quot;Getting the fat out of XSUBs&quot;&lt;/a&gt; for a similar tradeoff of a complete separation of &quot;Perl glue&quot; and &quot;workhorse&quot; parts of an XSUB.</source>
          <target state="translated">XSUB는 또한 Perl 함수 인수가 C 함수 인수로 자동 변환되는 것을 방지 할 수 있습니다. 자세한 내용은 &lt;a href=&quot;perlxs&quot;&gt;perlxs&lt;/a&gt; 를 참조하십시오. 어떤 사람들은 자동 변환이 수행되는 경우에도 &lt;code&gt;ST(i)&lt;/code&gt; 를 검사하여 수동 변환을 선호 하며 이것이 XSUB 호출의 논리를 더 명확하게 만든다고 주장합니다. &lt;a href=&quot;#Getting-the-fat-out-of-XSUBs&quot;&gt;XSUB&lt;/a&gt; 의 &quot;Perl glue&quot;와 &quot;workhorse&quot;부분을 완전히 분리하는 유사한 절충점에 대해서는 &quot;XSUB에서 지방 제거&quot; 와 비교하십시오 .</target>
        </trans-unit>
        <trans-unit id="3b5999991ea7d60b38c8ca1802a3aa2e3198b825" translate="yes" xml:space="preserve">
          <source>XSUBs are also allowed to avoid automatic conversion of Perl function arguments to C function arguments. See &lt;a href=&quot;perlxs&quot;&gt;perlxs&lt;/a&gt; for details. Some people prefer manual conversion by inspecting &lt;code&gt;ST(i)&lt;/code&gt; even in the cases when automatic conversion will do, arguing that this makes the logic of an XSUB call clearer. Compare with &lt;a href=&quot;#Getting-the-fat-out-of-XSUBs&quot;&gt;Getting the fat out of XSUBs&lt;/a&gt; for a similar tradeoff of a complete separation of &quot;Perl glue&quot; and &quot;workhorse&quot; parts of an XSUB.</source>
          <target state="translated">XSUB는 또한 Perl 함수 인수가 C 함수 인수로 자동 변환되는 것을 피할 수 있습니다. 자세한 내용은 &lt;a href=&quot;perlxs&quot;&gt;perlxs&lt;/a&gt; 를 참조하십시오. 일부 사람들은 자동 변환이 수행되는 경우에도 &lt;code&gt;ST(i)&lt;/code&gt; 를 검사하여 수동 변환을 선호 하므로 XSUB 호출의 논리가 더 명확 해집니다. &lt;a href=&quot;#Getting-the-fat-out-of-XSUBs&quot;&gt;XSUB&lt;/a&gt; 의 &quot;Perl glue&quot;와 &quot;workhorse&quot;부분을 완전히 분리하는 것과 유사한 트레이드 오프 를 얻으려면 XSUB에서 지방 제거하기 와 비교하십시오 .</target>
        </trans-unit>
        <trans-unit id="54080bcfea2adf5c913b064ead22f355c2ce0033" translate="yes" xml:space="preserve">
          <source>XSUBs are also allowed to return lists, not just scalars. This must be done by manipulating stack values ST(0), ST(1), etc, in a subtly different way. See &lt;a href=&quot;perlxs&quot;&gt;perlxs&lt;/a&gt; for details.</source>
          <target state="translated">XSUB는 스칼라뿐만 아니라 목록도 리턴 할 수 있습니다. 이는 스택 값 ST (0), ST (1) 등을 미묘하게 다른 방식으로 조작하여 수행해야합니다. 자세한 내용은 &lt;a href=&quot;perlxs&quot;&gt;perlxs&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="88b3157d6a7563b7eeae312db4f170271aab7d57" translate="yes" xml:space="preserve">
          <source>XSUBs can have variable-length parameter lists by specifying an ellipsis &lt;code&gt;(...)&lt;/code&gt; in the parameter list. This use of the ellipsis is similar to that found in ANSI C. The programmer is able to determine the number of arguments passed to the XSUB by examining the &lt;code&gt;items&lt;/code&gt; variable which the &lt;b&gt;xsubpp&lt;/b&gt; compiler supplies for all XSUBs. By using this mechanism one can create an XSUB which accepts a list of parameters of unknown length.</source>
          <target state="translated">XSUB는 매개 변수 목록에서 줄임표 &lt;code&gt;(...)&lt;/code&gt; 를 지정하여 가변 길이 매개 변수 목록을 가질 수 있습니다 . 생략 부호의 사용은 ANSI C에있는 것과 유사합니다. 프로그래머는 &lt;b&gt;xsubpp&lt;/b&gt; 컴파일러가 모든 XSUB에 제공 하는 &lt;code&gt;items&lt;/code&gt; 변수를 검사하여 XSUB에 전달 된 인수 수를 판별 할 수 있습니다. 이 메커니즘을 사용하면 알 수없는 길이의 매개 변수 목록을 허용하는 XSUB를 만들 수 있습니다.&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="3be2c3082f6ee5ac4e24cba3fef031d150316f00" translate="yes" xml:space="preserve">
          <source>XSUBs do not have a &lt;code&gt;CvPADLIST&lt;/code&gt;. &lt;code&gt;dXSTARG&lt;/code&gt; fetches values from &lt;code&gt;PL_curpad&lt;/code&gt;, but that is really the callers pad (a slot of which is allocated by every entersub). Do not get or set &lt;code&gt;CvPADLIST&lt;/code&gt; if a CV is an XSUB (as determined by &lt;code&gt;CvISXSUB()&lt;/code&gt;), &lt;code&gt;CvPADLIST&lt;/code&gt; slot is reused for a different internal purpose in XSUBs.</source>
          <target state="translated">XSUB에는 &lt;code&gt;CvPADLIST&lt;/code&gt; 가 없습니다 . &lt;code&gt;dXSTARG&lt;/code&gt; 는 &lt;code&gt;PL_curpad&lt;/code&gt; 에서 값을 가져 오지만 실제로는 호출자 패드입니다 (각 슬롯은 모든 entersub에 의해 할당 됨). CV가 XSUB ( &lt;code&gt;CvISXSUB()&lt;/code&gt; 의해 결정됨) 인 경우 &lt;code&gt;CvPADLIST&lt;/code&gt; 를 가져 오거나 설정하지 마십시오 . &lt;code&gt;CvPADLIST&lt;/code&gt; 슬롯은 XSUB에서 다른 내부 용도로 재사용됩니다.</target>
        </trans-unit>
        <trans-unit id="3f2e0ddc3d17d87460a2a8a983be1c97c83b73d1" translate="yes" xml:space="preserve">
          <source>XSUBs do not have a CvPADLIST. dXSTARG fetches values from PL_curpad, but that is really the callers pad (a slot of which is allocated by every entersub). Do not get or set CvPADLIST if a CV is an XSUB (as determined by &lt;code&gt;CvISXSUB()&lt;/code&gt; ), CvPADLIST slot is reused for a different internal purpose in XSUBs.</source>
          <target state="translated">XSUB에는 CvPADLIST가 없습니다. dXSTARG는 PL_curpad에서 값을 가져 오지만 실제로는 호출자 패드입니다 (슬롯이 모든 entersub에 의해 할당 됨). CV가 XSUB ( &lt;code&gt;CvISXSUB()&lt;/code&gt; 의해 결정됨) 인 경우 CvPADLIST를 가져 오거나 설정하지 마십시오 . CvPADLIST 슬롯은 XSUB에서 다른 내부 목적으로 재사용됩니다.</target>
        </trans-unit>
        <trans-unit id="6daf3f5f97a3cf191b47d0b650ffb497515d3ee1" translate="yes" xml:space="preserve">
          <source>XSUBs refer to their stack arguments with the macro &lt;b&gt;ST(x)&lt;/b&gt;, where</source>
          <target state="translated">XSUB는 매크로 &lt;b&gt;ST (x)로&lt;/b&gt; 스택 인수를 참조합니다 . 여기서</target>
        </trans-unit>
        <trans-unit id="b948898c3205f86da22df7bb2aa8e0fc31385f66" translate="yes" xml:space="preserve">
          <source>XS_APIVERSION_BOOTCHECK</source>
          <target state="translated">XS_APIVERSION_BOOTCHECK</target>
        </trans-unit>
        <trans-unit id="45e92c706e14fc42e8a65549cfb504f51b80720e" translate="yes" xml:space="preserve">
          <source>XS_DEFINE_VERSION: -D line to set the xs version when compiling.</source>
          <target state="translated">XS_DEFINE_VERSION : 컴파일 할 때 xs 버전을 설정하는 -D 행.</target>
        </trans-unit>
        <trans-unit id="c079612ab9bf6b165676a675aeaa6f541c733506" translate="yes" xml:space="preserve">
          <source>XS_EXTERNAL</source>
          <target state="translated">XS_EXTERNAL</target>
        </trans-unit>
        <trans-unit id="b36c9e63716f92004705d5a5880b339795a114b1" translate="yes" xml:space="preserve">
          <source>XS_FH</source>
          <target state="translated">XS_FH</target>
        </trans-unit>
        <trans-unit id="0b91e170805a05f3fc3b4f1fe3e1c801a51a5cd9" translate="yes" xml:space="preserve">
          <source>XS_FILE</source>
          <target state="translated">XS_FILE</target>
        </trans-unit>
        <trans-unit id="5a72d7eb1d508bb628564c702b5adf9c962f07c6" translate="yes" xml:space="preserve">
          <source>XS_INTERNAL</source>
          <target state="translated">XS_INTERNAL</target>
        </trans-unit>
        <trans-unit id="c30e58ff83929eb55292bc3f56bfb117c5d6b82f" translate="yes" xml:space="preserve">
          <source>XS_SUBNAME</source>
          <target state="translated">XS_SUBNAME</target>
        </trans-unit>
        <trans-unit id="c3c54470969e9570024cbdc019515c6664650a72" translate="yes" xml:space="preserve">
          <source>XS_VERSION</source>
          <target state="translated">XS_VERSION</target>
        </trans-unit>
        <trans-unit id="f6c7bf9f42bb6c2a25e194ec60219f0a8150edce" translate="yes" xml:space="preserve">
          <source>XS_VERSION: version in your .xs file. Defaults to $(VERSION)</source>
          <target state="translated">XS_VERSION : .xs 파일의 버전입니다. 기본적으로 $ (VERSION)</target>
        </trans-unit>
        <trans-unit id="849ccfe7e642de7c6c2afec3b38bc17a103cbe71" translate="yes" xml:space="preserve">
          <source>XS_VERSION_BOOTCHECK</source>
          <target state="translated">XS_VERSION_BOOTCHECK</target>
        </trans-unit>
        <trans-unit id="53fccca1190b204bd667ec9d6791fd3b9d14df6c" translate="yes" xml:space="preserve">
          <source>XS_VERSION_MACRO: which macro represents the XS version.</source>
          <target state="translated">XS_VERSION_MACRO : XS 버전을 나타내는 매크로입니다.</target>
        </trans-unit>
        <trans-unit id="c3b618e9ce8bc3b3691008b5df681815a883cb69" translate="yes" xml:space="preserve">
          <source>XS_constant PACKAGE, TYPES, XS_SUBNAME, C_SUBNAME</source>
          <target state="translated">XS_constant PACKAGE, TYPES, XS_SUBNAME, C_SUBNAME</target>
        </trans-unit>
        <trans-unit id="20026dc165c030fe3a5d9609a6e61ab26210cbc1" translate="yes" xml:space="preserve">
          <source>XX</source>
          <target state="translated">XX</target>
        </trans-unit>
        <trans-unit id="a9674b19f8c56f785c91a555d0a144522bb318e6" translate="yes" xml:space="preserve">
          <source>XXX</source>
          <target state="translated">XXX</target>
        </trans-unit>
        <trans-unit id="efc0ac66700effcf3b5c6d5cfb0d3ed1e5da5cc1" translate="yes" xml:space="preserve">
          <source>XXX DAPM it would make more sense to make the arg a PADOFFSET void SAVEPADSV(PADOFFSET po)</source>
          <target state="translated">XXX DAPM arg를 PADOFFSET void SAVEPADSV (PADOFFSET po)로 만드는 것이 더 합리적입니다.</target>
        </trans-unit>
        <trans-unit id="0a8c3822391bb958edc27b75e5a6c90f50363bce" translate="yes" xml:space="preserve">
          <source>XXX.</source>
          <target state="translated">XXX.</target>
        </trans-unit>
        <trans-unit id="759d5f762181a933d7c0ff7fd8096838ff6b5ec3" translate="yes" xml:space="preserve">
          <source>XXX: Needs more docs.</source>
          <target state="translated">XXX : 더 많은 문서가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="e3a8809017dd76bd26557a5b923ab2ae16c0cdb3" translate="yes" xml:space="preserve">
          <source>XXXX</source>
          <target state="translated">XXXX</target>
        </trans-unit>
        <trans-unit id="034f1965ccdbdf9e642feeb9858da5096b6d1a9a" translate="yes" xml:space="preserve">
          <source>XY</source>
          <target state="translated">XY</target>
        </trans-unit>
        <trans-unit id="1ed31ab8e3d4874b1d94827212eca5617d49d812" translate="yes" xml:space="preserve">
          <source>XopDISABLE</source>
          <target state="translated">XopDISABLE</target>
        </trans-unit>
        <trans-unit id="fdee56cbf2dd3729d372ee9ddd71eeb3c584e3a0" translate="yes" xml:space="preserve">
          <source>XopENABLE</source>
          <target state="translated">XopENABLE</target>
        </trans-unit>
        <trans-unit id="d452a85c41b2e0aa7a38834ff3a3b101c7d4ac6f" translate="yes" xml:space="preserve">
          <source>XopENTRY</source>
          <target state="translated">XopENTRY</target>
        </trans-unit>
        <trans-unit id="12a6abfec4959cd21c68fcfdd5a310b6940a1038" translate="yes" xml:space="preserve">
          <source>XopENTRYCUSTOM</source>
          <target state="translated">XopENTRYCUSTOM</target>
        </trans-unit>
        <trans-unit id="f6bc06eec4d13090054285af25a6e8fdfa5cb801" translate="yes" xml:space="preserve">
          <source>XopENTRY_set</source>
          <target state="translated">XopENTRY_set</target>
        </trans-unit>
        <trans-unit id="b37b621154ed9fa599925b4a3aa2dcee68ee7486" translate="yes" xml:space="preserve">
          <source>XopFLAGS</source>
          <target state="translated">XopFLAGS</target>
        </trans-unit>
        <trans-unit id="23eb4d3f4155395a74e9d534f97ff4c1908f5aac" translate="yes" xml:space="preserve">
          <source>Y</source>
          <target state="translated">Y</target>
        </trans-unit>
        <trans-unit id="ffbcb202b09db426bae56cf2ffb88f18594f2258" translate="yes" xml:space="preserve">
          <source>YAML</source>
          <target state="translated">YAML</target>
        </trans-unit>
        <trans-unit id="50bc04e009ed4a61bc2c2e4c00258238b3cec732" translate="yes" xml:space="preserve">
          <source>YAML result token.</source>
          <target state="translated">YAML 결과 토큰.</target>
        </trans-unit>
        <trans-unit id="453e08045c54cb8be51989088de3dde3aad22542" translate="yes" xml:space="preserve">
          <source>YAML, &lt;a href=&quot;http://www.yaml.org/&quot;&gt;http://www.yaml.org/&lt;/a&gt;</source>
          <target state="translated">YAML, &lt;a href=&quot;http://www.yaml.org/&quot;&gt;http://www.yaml.org/&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8fff039853f5c2bbb8a28d056b579c7dcb7d137f" translate="yes" xml:space="preserve">
          <source>YES</source>
          <target state="translated">YES</target>
        </trans-unit>
        <trans-unit id="bf4ca579becca81a75bf09eee1a917765b24f975" translate="yes" xml:space="preserve">
          <source>YMMV.</source>
          <target state="translated">YMMV.</target>
        </trans-unit>
        <trans-unit id="f4577d4c77ab9c132acbb835cae3c75d2c81ffab" translate="yes" xml:space="preserve">
          <source>YOU HAVEN'T DISABLED SET-ID SCRIPTS IN THE KERNEL YET!</source>
          <target state="translated">아직 커널에서 SET-ID 스크립트를 비활성화하지 않았습니다!</target>
        </trans-unit>
        <trans-unit id="9a8fc610a3168e82e07390203ce40d7382c7da6f" translate="yes" xml:space="preserve">
          <source>YYYY-MM-DDThh:mm:ss</source>
          <target state="translated">YYYY-MM-DDThh:mm:ss</target>
        </trans-unit>
        <trans-unit id="76ac22fb38468218ad6552d9043d5bb2c7920d48" translate="yes" xml:space="preserve">
          <source>Year Value Interpretation</source>
          <target state="translated">연도 가치 해석</target>
        </trans-unit>
        <trans-unit id="44f6289f7e3326b30824a187cdb204e4dc7264b2" translate="yes" xml:space="preserve">
          <source>Years greater than 999 are interpreted as being the actual year, rather than the offset from 1900. Thus, 1964 would indicate the year Martin Luther King won the Nobel prize, not the year 3864.</source>
          <target state="translated">999보다 큰 연도는 1900의 상쇄가 아니라 실제 연도로 해석됩니다. 따라서 1964 년은 마틴 루터 킹이 3864 년이 아니라 노벨상을 수상한 연도를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="c9ec20e90ee8369d4a4738a1355fc718ca45a57e" translate="yes" xml:space="preserve">
          <source>Years in the range 0..99 are interpreted as shorthand for years in the rolling &quot;current century,&quot; defined as 50 years on either side of the current year. Thus, today, in 1999, 0 would refer to 2000, and 45 to 2045, but 55 would refer to 1955. Twenty years from now, 55 would instead refer to 2055. This is messy, but matches the way people currently think about two digit dates. Whenever possible, use an absolute four digit year instead.</source>
          <target state="translated">0..99 범위의 연도는 현재 연도의 양쪽에서 50 년으로 정의 된 롤링 &quot;현재 세기&quot;에서 연도의 약자로 해석됩니다. 따라서 오늘날 1999 년에 0은 2000을, 45는 2045를, 55는 1955를 나타냅니다. 20 년 후 55는 대신 2055를 가리 킵니다. 이것은 지저분하지만 사람들이 현재 두 가지에 대해 생각하는 방식과 일치 숫자 날짜. 가능할 때마다 절대 4 자리 연도를 대신 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="862a9bbc8aa08db48d5ef905c8dc85be457e6ea8" translate="yes" xml:space="preserve">
          <source>Years in the range 100..999 are interpreted as offset from 1900, so that 112 indicates 2012. This rule also applies to years less than zero (but see note below regarding date range).</source>
          <target state="translated">100..999 범위의 연도는 1900에서 오프셋으로 해석되므로 112는 2012를 나타냅니다.이 규칙은 0보다 작은 연도에도 적용됩니다 (그러나 날짜 범위에 대해서는 아래 참고 참조).</target>
        </trans-unit>
        <trans-unit id="dfc439a506f8ca9ae872d5d02c2ad4c82b034c13" translate="yes" xml:space="preserve">
          <source>Yes it is, see previous answer. Since &lt;code&gt;Compress::Zlib&lt;/code&gt; and therefore &lt;code&gt;IO::Zlib&lt;/code&gt; doesn't support &lt;code&gt;&lt;a href=&quot;../functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt; on their filehandles, there is little choice but to read the archive into memory. This is ok if you want to do in-memory manipulation of the archive.</source>
          <target state="translated">예, 이전 답변을 참조하십시오. 이후 &lt;code&gt;Compress::Zlib&lt;/code&gt; 따라서 &lt;code&gt;IO::Zlib&lt;/code&gt; 지원하지 않는 &lt;code&gt;&lt;a href=&quot;../functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt; 자신의 파일 핸들에가, 선택의 여지가 있지만, 메모리에 아카이브를 읽을 수 있습니다. 아카이브의 메모리 내 조작을 원한다면 괜찮습니다.</target>
        </trans-unit>
        <trans-unit id="4a483b69465fec8d9ad0abf1cb110a3cd5a4d0a4" translate="yes" xml:space="preserve">
          <source>Yes it is, see previous answer. Since &lt;code&gt;Compress::Zlib&lt;/code&gt; and therefore &lt;code&gt;IO::Zlib&lt;/code&gt; doesn't support &lt;code&gt;seek&lt;/code&gt; on their filehandles, there is little choice but to read the archive into memory. This is ok if you want to do in-memory manipulation of the archive.</source>
          <target state="translated">예, 이전 답변을 참조하십시오. 이후 &lt;code&gt;Compress::Zlib&lt;/code&gt; 따라서 &lt;code&gt;IO::Zlib&lt;/code&gt; 지원하지 않는 &lt;code&gt;seek&lt;/code&gt; 자신의 파일 핸들에가, 선택의 여지가 있지만, 메모리에 아카이브를 읽을 수 있습니다. 아카이브의 메모리 내 조작을 수행하려는 경우 괜찮습니다.</target>
        </trans-unit>
        <trans-unit id="acb5099459bfa43931dd4b78a628e1d113168a69" translate="yes" xml:space="preserve">
          <source>Yes it is. It's pure perl, so it's a lot slower then your &lt;code&gt;/bin/tar&lt;/code&gt; However, it's very portable. If speed is an issue, consider using &lt;code&gt;/bin/tar&lt;/code&gt; instead.</source>
          <target state="translated">네 그렇습니다. 순수한 펄이므로 &lt;code&gt;/bin/tar&lt;/code&gt; 보다 훨씬 느리지 만 이식성이 뛰어납니다. 속도가 문제라면 &lt;code&gt;/bin/tar&lt;/code&gt; 를 대신 사용해보십시오.</target>
        </trans-unit>
        <trans-unit id="bcbbf7da5377bd36deaae3d4c290fed0db7777c9" translate="yes" xml:space="preserve">
          <source>Yes, both the &lt;code&gt;IO-Compress-Zip&lt;/code&gt; and &lt;code&gt;IO-Uncompress-Unzip&lt;/code&gt; modules support the zip feature called</source>
          <target state="translated">예, &lt;code&gt;IO-Compress-Zip&lt;/code&gt; 및 &lt;code&gt;IO-Uncompress-Unzip&lt;/code&gt; 모듈은 모두라는 zip 기능을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="4107dbe8a030ec286ba38d4f763957128d667542" translate="yes" xml:space="preserve">
          <source>Yes, it does</source>
          <target state="translated">예, 그렇습니다</target>
        </trans-unit>
        <trans-unit id="3678471c058284ba4000bf6331c346c6bbd02a28" translate="yes" xml:space="preserve">
          <source>Yes, that's a lot of expansion.</source>
          <target state="translated">예, 그것은 많은 확장입니다.</target>
        </trans-unit>
        <trans-unit id="eb5a8cd62389870da5aba481f01f1a18a4a6e511" translate="yes" xml:space="preserve">
          <source>Yes, there's a lot of that :-) But more precisely, in UNIX systems there's a utility called &lt;code&gt;file&lt;/code&gt; , which recognizes data files based on their contents (usually their first few bytes). For this to work, a certain file called</source>
          <target state="translated">예, 많은 것들이 있습니다 :-) 그러나 더 정확하게는 UNIX 시스템에는 &lt;code&gt;file&lt;/code&gt; 이라는 유틸리티가 있습니다 .이 유틸리티는 내용 (일반적으로 처음 몇 바이트)을 기반으로 데이터 파일을 인식합니다. 이것이 작동하려면 특정 파일이</target>
        </trans-unit>
        <trans-unit id="f71f9d886920a4f49da8093935995672de9199c3" translate="yes" xml:space="preserve">
          <source>Yes, there's a lot of that :-) But more precisely, in UNIX systems there's a utility called &lt;code&gt;file&lt;/code&gt;, which recognizes data files based on their contents (usually their first few bytes). For this to work, a certain file called</source>
          <target state="translated">예, 많은 것들이 있습니다 :-)하지만 더 정확하게는 유닉스 시스템에는 &lt;code&gt;file&lt;/code&gt; 이라는 유틸리티가 있습니다 .이 유틸리티는 내용 (보통 처음 몇 바이트)을 기반으로 데이터 파일을 인식합니다. 이 작업을 수행하려면 다음과 같은 특정 파일이</target>
        </trans-unit>
        <trans-unit id="032ab970df677757a74b1c2b5fdbae010210746c" translate="yes" xml:space="preserve">
          <source>Yes, there's a mistake in the test suite. What! Me, contrived?</source>
          <target state="translated">예, 테스트 스위트에 실수가 있습니다. 뭐! 나, 인위?</target>
        </trans-unit>
        <trans-unit id="dc1e472e45c46619f7f9549ce98213f0173da937" translate="yes" xml:space="preserve">
          <source>Yes, you can do this by either using the &lt;code&gt;-T&lt;/code&gt; option, or by invoking the program as &lt;code&gt;perlthanks&lt;/code&gt; . Thank-you notes are good. It makes people smile.</source>
          <target state="translated">예, &lt;code&gt;-T&lt;/code&gt; 를 사용하여이 작업을 수행 할 수 있습니다. 옵션을 사용하거나 프로그램을 &lt;code&gt;perlthanks&lt;/code&gt; 로 호출 . 감사 노트가 좋습니다. 사람들을 웃게 만듭니다.</target>
        </trans-unit>
        <trans-unit id="8987958587b6289e3623984d6459696a8ad818f9" translate="yes" xml:space="preserve">
          <source>Yes, you can do this by either using the &lt;code&gt;-T&lt;/code&gt; option, or by invoking the program as &lt;code&gt;perlthanks&lt;/code&gt;. Thank-you notes are good. It makes people smile.</source>
          <target state="translated">예, &lt;code&gt;-T&lt;/code&gt; 옵션을 사용하거나 프로그램을 &lt;code&gt;perlthanks&lt;/code&gt; 로 호출 하여이를 수행 할 수 있습니다 . 감사 노트가 좋습니다. 사람들을 웃게 만듭니다.</target>
        </trans-unit>
        <trans-unit id="2c8d0f90fcceba5d3649946cef16ef6f0de57be0" translate="yes" xml:space="preserve">
          <source>Yes, you can! If your sources are UTF-8 encoded, you can indicate that with the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; pragma.</source>
          <target state="translated">그래 넌 할수있어! 소스가 UTF-8로 인코딩 된 경우 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; pragma를 .</target>
        </trans-unit>
        <trans-unit id="77a1a43bdaae65a00429084f6cd8a3dc8163734c" translate="yes" xml:space="preserve">
          <source>Yes, you can! If your sources are UTF-8 encoded, you can indicate that with the &lt;code&gt;use utf8&lt;/code&gt; pragma.</source>
          <target state="translated">그래 넌 할수있어! 소스가 UTF-8로 인코딩 된 &lt;code&gt;use utf8&lt;/code&gt; pragma를 사용 하여이를 나타낼 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fd3c0b60626749e4fb04200f5ac37da9c3ba6f91" translate="yes" xml:space="preserve">
          <source>Yes, you could probably do the same thing with code like $token-&amp;gt;isa('Pod::Simple::PullParserEndToken'), but that's not so pretty as using just $token-&amp;gt;type, or even the following shortcuts:</source>
          <target state="translated">예, 아마도 $ token-&amp;gt; isa ( 'Pod :: Simple :: PullParserEndToken')와 같은 코드로 똑같은 일을 할 수는 있지만 $ token-&amp;gt; type 또는 다음 단축키를 사용하는 것만 큼 좋지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="9ba10bd10462c10515a891999d5f144a0ef8db84" translate="yes" xml:space="preserve">
          <source>Yes. If you are building a web site with any level of interactivity (forms / users / databases), you will want to use a framework to make handling requests and responses easier.</source>
          <target state="translated">예. 대화 형 수준 (양식 / 사용자 / 데이터베이스)이있는 웹 사이트를 구축하는 경우 프레임 워크를 사용하여 요청 및 응답을보다 쉽게 ​​처리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="4131deed69500e1ce76a1aa4746c5be5d04540cb" translate="yes" xml:space="preserve">
          <source>Yes. Perl's garbage collection system takes care of this so everything works out right.</source>
          <target state="translated">예. Perl의 가비지 수집 시스템이이를 처리하므로 모든 것이 올바르게 작동합니다.</target>
        </trans-unit>
        <trans-unit id="3a7fae4176564291917eb6c0f952942b7ae63ec5" translate="yes" xml:space="preserve">
          <source>Yes. Read &lt;a href=&quot;perlrun&quot;&gt;perlrun&lt;/a&gt; for more information. Some examples follow. (These assume standard Unix shell quoting rules.)</source>
          <target state="translated">예. &lt;a href=&quot;perlrun&quot;&gt;펄런&lt;/a&gt; 읽기자세한 정보는 을 . 다음은 몇 가지 예입니다. (이것은 표준 유닉스 쉘 인용 규칙을 가정합니다.)</target>
        </trans-unit>
        <trans-unit id="64a64c9d49bc7ff568ef5c62aefe6945eee0a81a" translate="yes" xml:space="preserve">
          <source>Yes. Zip64 allows this. See previous question.</source>
          <target state="translated">예. Zip64는 이것을 허용합니다. 이전 질문을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="85739d75a309637ea84dea150d48798fe5f385f6" translate="yes" xml:space="preserve">
          <source>Yet Another Compiler Compiler. A parser generator without which Perl probably would not have existed. See the file</source>
          <target state="translated">또 다른 컴파일러 컴파일러. 펄이없는 파서 생성기는 아마도 존재하지 않았을 것이다. 파일보기</target>
        </trans-unit>
        <trans-unit id="7fafe5e36aa3122413d32c6d4c8b4284bb245038" translate="yes" xml:space="preserve">
          <source>Yet another capturing group numbering technique (also as from Perl 5.10) deals with the problem of referring to groups within a set of alternatives. Consider a pattern for matching a time of the day, civil or military style:</source>
          <target state="translated">또 다른 캡처 그룹 번호 매기기 기술 (또한 Perl 5.10에서)은 일련의 대안 내에서 그룹을 참조하는 문제를 처리합니다. 하루 중 시간, 시민 또는 군대 스타일을 일치시키는 패턴을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="a23e788a3e5975e13dc401fc7dc400a7d94469f5" translate="yes" xml:space="preserve">
          <source>Yet another framework for writing test scripts</source>
          <target state="translated">테스트 스크립트 작성을위한 또 다른 프레임 워크</target>
        </trans-unit>
        <trans-unit id="1f545787fad8ec88f6418a5e7cfe487632178eef" translate="yes" xml:space="preserve">
          <source>Yet another pseudo-class that &lt;code&gt;NEXT&lt;/code&gt; provides is &lt;code&gt;EVERY&lt;/code&gt;. Its behaviour is considerably simpler than that of the &lt;code&gt;NEXT&lt;/code&gt; family. A call to:</source>
          <target state="translated">&lt;code&gt;NEXT&lt;/code&gt; 가 제공 하는 또 다른 의사 클래스 는 &lt;code&gt;EVERY&lt;/code&gt; 입니다. 그 동작은 &lt;code&gt;NEXT&lt;/code&gt; 제품군 보다 훨씬 간단 합니다. 전화 :</target>
        </trans-unit>
        <trans-unit id="50d7418e5885441f0de4ccbd54d601d8993cfb34" translate="yes" xml:space="preserve">
          <source>Yet another pseudo-class that NEXT.pm provides is &lt;code&gt;EVERY&lt;/code&gt; . Its behaviour is considerably simpler than that of the &lt;code&gt;NEXT&lt;/code&gt; family. A call to:</source>
          <target state="translated">NEXT.pm이 제공하는 또 다른 의사 클래스는 &lt;code&gt;EVERY&lt;/code&gt; 입니다. 그 동작은 &lt;code&gt;NEXT&lt;/code&gt; 제품군 보다 훨씬 간단 합니다. 전화 :</target>
        </trans-unit>
        <trans-unit id="807fa18eacfa8333a4615b7233d28577520ce46b" translate="yes" xml:space="preserve">
          <source>Yet another way is to assign to a &lt;code&gt;foreach&lt;/code&gt; loop</source>
          <target state="translated">또 다른 방법은 &lt;code&gt;foreach&lt;/code&gt; 루프 에 할당하는 것입니다</target>
        </trans-unit>
        <trans-unit id="fb6a80ccd3cd48516fa10f2b5e43ec6135ec9451" translate="yes" xml:space="preserve">
          <source>Yet another way would be to use the Devel::Peek module:</source>
          <target state="translated">또 다른 방법은 Devel :: Peek 모듈을 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="8dd7850c540f0b2c7dd564faf5b435a82d533987" translate="yes" xml:space="preserve">
          <source>Yields the widest unsigned integer type on the platform, currently either &lt;code&gt;U32&lt;/code&gt; or &lt;code&gt;64&lt;/code&gt;. This can be used in declarations such as</source>
          <target state="translated">플랫폼에서 가장 넓은 부호없는 정수 유형 (현재 &lt;code&gt;U32&lt;/code&gt; 또는 &lt;code&gt;64&lt;/code&gt; )을 생성 합니다. 다음과 같은 선언에 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c970e3f1e790a2a4cd28b40401902501b9bc2d74" translate="yes" xml:space="preserve">
          <source>Yields:</source>
          <target state="translated">Yields:</target>
        </trans-unit>
        <trans-unit id="f551936e2c614f3a2dff9203d64b57c373086792" translate="yes" xml:space="preserve">
          <source>You &lt;b&gt;do not&lt;/b&gt; call &lt;code&gt;setlogsock&lt;/code&gt; .</source>
          <target state="translated">당신은 &lt;b&gt;하지 않는&lt;/b&gt; 전화 &lt;code&gt;setlogsock&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="c41e00d12c2bf30eb5c57363d593eb5f296a4201" translate="yes" xml:space="preserve">
          <source>You &lt;b&gt;do not&lt;/b&gt; call &lt;code&gt;setlogsock&lt;/code&gt;.</source>
          <target state="translated">당신은 &lt;b&gt;하지 않는&lt;/b&gt; 전화 &lt;code&gt;setlogsock&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="b83525859b43ad2ba983b59bc741a630d369a604" translate="yes" xml:space="preserve">
          <source>You &lt;b&gt;must not&lt;/b&gt; attempt to install by hand.</source>
          <target state="translated">당신은 &lt;b&gt;안&lt;/b&gt; 수동으로 설치하려고.</target>
        </trans-unit>
        <trans-unit id="adc6962b12f722ff929475c965699bd91420b623" translate="yes" xml:space="preserve">
          <source>You &lt;b&gt;must&lt;/b&gt; convert characters to UVs using the above functions if you're ever in a situation where you have to match UTF-8 and non-UTF-8 characters. You may not skip over UTF-8 characters in this case. If you do this, you'll lose the ability to match hi-bit non-UTF-8 characters; for instance, if your UTF-8 string contains &lt;code&gt;v196.172&lt;/code&gt; , and you skip that character, you can never match a &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr(200)&lt;/a&gt;&lt;/code&gt; in a non-UTF-8 string. So don't do that!</source>
          <target state="translated">당신은 &lt;b&gt;있어야&lt;/b&gt; 당신이 UTF-8 및 UTF-8이 아닌 문자와 일치 할 필요가 어디 상황에서 이제까지 인 경우 위의 기능을 사용하여의 UV로 문자를 변환합니다. 이 경우 UTF-8 문자를 건너 뛸 수 없습니다. 이 작업을 수행하면 UTF-8이 아닌 UTF-8 문자를 일치시키는 기능이 손실됩니다. 예를 들어, UTF-8 문자열에 &lt;code&gt;v196.172&lt;/code&gt; 가 포함되어 있고 해당 문자를 건너 뛰는 경우 비 UTF-8 문자열에서 &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr(200)&lt;/a&gt;&lt;/code&gt; 과 일치시킬 수 없습니다 . 그러지 마!</target>
        </trans-unit>
        <trans-unit id="fa9dba3c584a1276adf1e71be9d8031a3210c272" translate="yes" xml:space="preserve">
          <source>You &lt;b&gt;must&lt;/b&gt; convert characters to UVs using the above functions if you're ever in a situation where you have to match UTF-8 and non-UTF-8 characters. You may not skip over UTF-8 characters in this case. If you do this, you'll lose the ability to match hi-bit non-UTF-8 characters; for instance, if your UTF-8 string contains &lt;code&gt;v196.172&lt;/code&gt;, and you skip that character, you can never match a &lt;code&gt;chr(200)&lt;/code&gt; in a non-UTF-8 string. So don't do that!</source>
          <target state="translated">당신은 &lt;b&gt;있어야&lt;/b&gt; 당신이 UTF-8 및 UTF-8이 아닌 문자와 일치 할 필요가 어디 상황에서 이제까지 인 경우 위의 기능을 사용하여의 UV로 문자를 변환합니다. 이 경우 UTF-8 문자를 건너 뛸 수 없습니다. 이렇게하면 하이 비트 비 UTF-8 문자와 일치하는 기능을 잃게됩니다. 예를 들어 UTF-8 문자열에 &lt;code&gt;v196.172&lt;/code&gt; 가 포함되어 있고 해당 문자를 건너 뛰면 UTF-8이 아닌 문자열에서 &lt;code&gt;chr(200)&lt;/code&gt; 과 일치 할 수 없습니다 . 그러니 그러지 마세요!</target>
        </trans-unit>
        <trans-unit id="84f6ab55499a431ab963225e1b323e598c043cac" translate="yes" xml:space="preserve">
          <source>You &lt;b&gt;must&lt;/b&gt; have the BFD (-lbfd) library installed, otherwise &lt;code&gt;perl&lt;/code&gt; will fail to link. The BFD is usually distributed as part of the GNU binutils.</source>
          <target state="translated">당신은 &lt;b&gt;해야한다&lt;/b&gt; , 설치 BFD (-lbfd) 라이브러리가 다른 &lt;code&gt;perl&lt;/code&gt; 링크에 실패합니다. BFD는 일반적으로 GNU binutils의 일부로 배포됩니다.</target>
        </trans-unit>
        <trans-unit id="b5fb57ccedc3fdf63890d16c6dbd3e60731ff70f" translate="yes" xml:space="preserve">
          <source>You CAN say</source>
          <target state="translated">당신은 말할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="53a5cd5fed7f629c72dba4cfdfde9a745c8113d5" translate="yes" xml:space="preserve">
          <source>You MUST NOT pass context objects around</source>
          <target state="translated">컨텍스트 객체를 전달해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="9893e3bf74f00c1d618d88219ad526fbac0c0c29" translate="yes" xml:space="preserve">
          <source>You MUST NOT store or cache a context for later</source>
          <target state="translated">나중에 컨텍스트를 저장하거나 캐시하면 안됩니다.</target>
        </trans-unit>
        <trans-unit id="a142a3f1e08b559ac377684a245517410ece7ce4" translate="yes" xml:space="preserve">
          <source>You MUST always release the context when done with it</source>
          <target state="translated">작업이 끝나면 항상 컨텍스트를 해제해야합니다.</target>
        </trans-unit>
        <trans-unit id="f91a3f4c8d175f6cccdbd1ebd40641bce1aa24ca" translate="yes" xml:space="preserve">
          <source>You SHOULD obtain your context as soon as possible in a given tool</source>
          <target state="translated">주어진 도구에서 가능한 한 빨리 컨텍스트를 얻어야합니다.</target>
        </trans-unit>
        <trans-unit id="f4ab9d853c38812e284656a7bf6f62a6214856cd" translate="yes" xml:space="preserve">
          <source>You already learned that a &lt;b&gt;method&lt;/b&gt; is a subroutine that operates on an object. You can think of a method as the things that an object can</source>
          <target state="translated">이미 &lt;b&gt;방법을&lt;/b&gt; 배웠습니다&lt;b&gt;&lt;/b&gt; 는 오브젝트에서 작동하는 서브 루틴이라는 있습니다. 메소드를 객체가 할 수있는 것으로 생각할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="9a0c2a8aac855d59d1e419df17c0d8362fab4ef6" translate="yes" xml:space="preserve">
          <source>You also cannot exit out of the sort block or subroutine using any of the loop control operators described in &lt;a href=&quot;../perlsyn&quot;&gt;perlsyn&lt;/a&gt; or with &lt;code&gt;&lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;../perlsyn&quot;&gt;perlsyn&lt;/a&gt; 또는 &lt;code&gt;&lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; 에 설명 된 루프 제어 연산자를 사용하여 정렬 블록 또는 서브 루틴을 종료 할 수도 없습니다 .</target>
        </trans-unit>
        <trans-unit id="f67f30786418f2d13fcf93e360206e73fbe2ba5c" translate="yes" xml:space="preserve">
          <source>You also cannot exit out of the sort block or subroutine using any of the loop control operators described in &lt;a href=&quot;perlsyn&quot;&gt;perlsyn&lt;/a&gt; or with &lt;a href=&quot;#goto-LABEL&quot;&gt;&lt;code&gt;goto&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">또한 &lt;a href=&quot;perlsyn&quot;&gt;perlsyn&lt;/a&gt; 또는 &lt;a href=&quot;#goto-LABEL&quot;&gt; &lt;code&gt;goto&lt;/code&gt; 에&lt;/a&gt; 설명 된 루프 제어 연산자를 사용하여 정렬 블록 또는 서브 루틴을 종료 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="cce8f481cd5c5e068e4367b0b286efd66e3e8b5e" translate="yes" xml:space="preserve">
          <source>You also cannot exit out of the sort block or subroutine using any of the loop control operators described in &lt;a href=&quot;perlsyn&quot;&gt;perlsyn&lt;/a&gt; or with &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;perlsyn&quot;&gt;perlsyn&lt;/a&gt; 또는 &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; 에 설명 된 루프 제어 연산자를 사용하여 정렬 블록 또는 서브 루틴을 종료 할 수도 없습니다 .</target>
        </trans-unit>
        <trans-unit id="6462e3c6fa18441789982aade2cc057d4a5754fa" translate="yes" xml:space="preserve">
          <source>You also don't have to use push(). You could just make a direct assignment if you knew where you wanted to put it:</source>
          <target state="translated">push ()를 사용할 필요도 없습니다. 어디에 배치하고 싶은지 알고 있다면 직접 할당 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="762d8de62e5184e1ddd3f7df62b51251838a45ad" translate="yes" xml:space="preserve">
          <source>You also have to be careful about context. You can assign an array to a scalar to get the number of elements in the array. This only works for arrays, though:</source>
          <target state="translated">또한 상황에주의해야합니다. 배열의 요소 수를 얻기 위해 배열을 스칼라에 할당 할 수 있습니다. 그러나 배열에서만 작동합니다.</target>
        </trans-unit>
        <trans-unit id="c94e331eac1a6006813ffea35d4a89a5abaa1704" translate="yes" xml:space="preserve">
          <source>You also need dmake or gmake. See &lt;a href=&quot;#Make&quot;&gt;&quot;Make&quot;&lt;/a&gt; above on how to get it.</source>
          <target state="translated">dmake 또는 gmake도 필요합니다. 그것을 얻는 방법은 위의 &lt;a href=&quot;#Make&quot;&gt;&quot;Make&quot;를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e9900e6006f63d330e774e6c340305cdfb9e9fa2" translate="yes" xml:space="preserve">
          <source>You also need dmake. See &lt;a href=&quot;#Make&quot;&gt;Make&lt;/a&gt; above on how to get it.</source>
          <target state="translated">또한 dmake가 필요합니다. 얻는 방법에 대해서는 위의 &lt;a href=&quot;#Make&quot;&gt;확인을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="bae77dd846c87a6c6a294ef10cab8c218809dda8" translate="yes" xml:space="preserve">
          <source>You also need to take care with modules that enable warnings for you. A common example being Moose. In this example, warnings for the 'smartmatch' feature are first turned on by the warnings pragma, off by the experimental pragma and back on again by the Moose module (fix is to switch the last two lines):</source>
          <target state="translated">경고를 활성화하는 모듈도주의해야합니다. 일반적인 예는 무스입니다. 이 예에서 'smartmatch'기능에 대한 경고는 먼저 warnings pragma에 의해 켜지고, 실험적 pragma에 의해 꺼졌다가 Moose 모듈에 의해 다시 켜집니다 (수정은 마지막 두 줄을 전환하는 것입니다).</target>
        </trans-unit>
        <trans-unit id="d4f9457dec1ff1c62632c87a4b529a8a11409acd" translate="yes" xml:space="preserve">
          <source>You are &lt;b&gt;strongly&lt;/b&gt; encouraged to use these subs in any new code which uses this module. It will almost certainly make your code's behavior less surprising.</source>
          <target state="translated">당신이하는 &lt;b&gt;강력&lt;/b&gt; 이 모듈을 사용하는 새로운 코드에서 이러한 서브 우퍼를 사용하는 것이 좋습니다. 거의 확실하게 코드의 동작을 덜 놀라게 할 것입니다.</target>
        </trans-unit>
        <trans-unit id="ad4cae9e1d17ccae297619ff7a90fc58163adef4" translate="yes" xml:space="preserve">
          <source>You are allowed to use underscores (underbars) in numeric literals between digits for legibility (but not multiple underscores in a row: &lt;code&gt;23__500&lt;/code&gt; is not legal; &lt;code&gt;23_500&lt;/code&gt; is). You could, for example, group binary digits by threes (as for a Unix-style mode argument such as 0b110_100_100) or by fours (to represent nibbles, as in 0b1010_0110) or in other groups.</source>
          <target state="translated">가독성을 위해 숫자 사이의 숫자 리터럴에 밑줄 (밑줄)을 사용할 수 있습니다 (단, 행에 여러 개의 밑줄 이없는 경우 : &lt;code&gt;23__500&lt;/code&gt; 은 유효하지 않습니다; &lt;code&gt;23_500&lt;/code&gt; 은 유효합니다 ). 예를 들어, 이진수를 3 (0b110_100_100과 같은 유닉스 스타일 모드 인수의 경우) 또는 4 (0b1010_0110에서와 같이 니블을 나타 내기 위해) 또는 다른 그룹으로 그룹화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e9086be8aa3acbf107ed69aa30ed1efd2e29806d" translate="yes" xml:space="preserve">
          <source>You are chdir()'d to &lt;code&gt;$File::Find::dir&lt;/code&gt; when the function is called, unless &lt;code&gt;no_chdir&lt;/code&gt; was specified. Note that when changing to directories is in effect the root directory (</source>
          <target state="translated">&lt;code&gt;no_chdir&lt;/code&gt; 이 지정 되지 않은 경우 함수가 호출 될 때 chdir ()이 &lt;code&gt;$File::Find::dir&lt;/code&gt; 있습니다. 디렉토리로 변경하면 사실상 루트 디렉토리 (</target>
        </trans-unit>
        <trans-unit id="3b7c887092493d390ff632279a2e09dfaf7f8868" translate="yes" xml:space="preserve">
          <source>You are chdir()'d to &lt;code&gt;$File::Find::dir&lt;/code&gt; when the function is called, unless &lt;code&gt;no_chdir&lt;/code&gt; was specified. Note that when changing to directories is in effect, the root directory (</source>
          <target state="translated">&lt;code&gt;no_chdir&lt;/code&gt; 이 지정 되지 않은 경우 함수가 호출 될 때 &lt;code&gt;$File::Find::dir&lt;/code&gt; 에 chdir () 됩니다. 디렉토리 변경이 적용되면 루트 디렉토리 (</target>
        </trans-unit>
        <trans-unit id="765a24f0e7b225890131f993a03189d4db8249a5" translate="yes" xml:space="preserve">
          <source>You are either using a copy of zlib that is older than version 1.2.0 or you want your application code to be able to run with as many different versions of zlib as possible.</source>
          <target state="translated">버전 1.2.0 이전의 zlib 사본을 사용 중이거나 응용 프로그램 코드가 가능한 많은 다른 버전의 zlib와 함께 실행될 수 있기를 원합니다.</target>
        </trans-unit>
        <trans-unit id="a13d801950c0dc8ed9906d27d14a9952af5a263a" translate="yes" xml:space="preserve">
          <source>You are encouraged to participate in the discussion and advocate for your patch. Sometimes your patch may get lost in the shuffle. It's appropriate to send a reminder email to p5p if no action has been taken in a month. Please remember that the Perl 5 developers are all volunteers, and be polite.</source>
          <target state="translated">토론에 참여하고 패치를 옹호하는 것이 좋습니다. 때때로 셔플에서 패치가 손실 될 수 있습니다. 한 달 동안 아무런 조치도 취하지 않은 경우 p5p로 알림 이메일을 보내는 것이 좋습니다. Perl 5 개발자는 모두 자원 봉사자이며 예의 바르게 행동하십시오.</target>
        </trans-unit>
        <trans-unit id="719d41b23df4f3bd674c48a03b68b419d4539869" translate="yes" xml:space="preserve">
          <source>You are encouraged to use &lt;code&gt;is()&lt;/code&gt; and &lt;code&gt;isnt()&lt;/code&gt; over &lt;code&gt;ok()&lt;/code&gt; where possible, however do not be tempted to use them to find out if something is true or false!</source>
          <target state="translated">당신이 사용하는 것이 좋습니다 것은 &lt;code&gt;is()&lt;/code&gt; 과 &lt;code&gt;isnt()&lt;/code&gt; 이상 &lt;code&gt;ok()&lt;/code&gt; 가능한, 그러나 무언가가 참인지 거짓인지 확인하는 데 사용할 유혹하지 마십시오!</target>
        </trans-unit>
        <trans-unit id="5f7051dcae7048dda5b89cea1569b5b5dced0666" translate="yes" xml:space="preserve">
          <source>You are encouraged to use the explicitly quoted form if you wish to use an empty line as the terminator of the here-document:</source>
          <target state="translated">here-document의 종결 자로 빈 줄을 사용하려면 명시 적으로 인용 된 형식을 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="7231b46f1cb348d100d3ac2d2fb73b6bf57d8066" translate="yes" xml:space="preserve">
          <source>You are guaranteed that &lt;code&gt;$dirs . $filename . $suffix&lt;/code&gt; will denote the same location as the original $path.</source>
          <target state="translated">&lt;code&gt;$dirs . $filename . $suffix&lt;/code&gt; 보장 됩니다. $ filename 접미사 는 원래 $ path와 동일한 위치를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="845992c360c01c1fffb9e8ef6310e8cc47a34923" translate="yes" xml:space="preserve">
          <source>You are not supposed to modify arrays while they are being iterated over. For speed and efficiency reasons, Perl internally does not do full reference-counting of iterated items, hence deleting such an item in the middle of an iteration causes Perl to see a freed value.</source>
          <target state="translated">배열이 반복되는 동안 배열을 수정해서는 안됩니다. 속도 및 효율성상의 이유로 Perl은 내부적으로 반복 된 항목의 전체 참조 계산을 수행하지 않으므로 반복 중에 이러한 항목을 삭제하면 Perl이 해제 된 값을 보게됩니다.</target>
        </trans-unit>
        <trans-unit id="c4250931e7c7965b87b322df0e377d3c209e4074" translate="yes" xml:space="preserve">
          <source>You are recommended to change your code to set &lt;code&gt;$/&lt;/code&gt; to &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; explicitly if you wish to slurp the file. In future versions of Perl assigning a reference to will throw a fatal error.</source>
          <target state="translated">파일을 지우려면 &lt;code&gt;$/&lt;/code&gt; 를 명시 적으로 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 로 설정하도록 코드를 변경하는 것이 좋습니다 . 이후 버전의 Perl에서 참조를 할당하면 치명적인 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="25b41e2d5bdfaa0dfc36f2b04421c00c9e912434" translate="yes" xml:space="preserve">
          <source>You are recommended to change your code to set &lt;code&gt;$/&lt;/code&gt; to &lt;code&gt;undef&lt;/code&gt; explicitly if you wish to slurp the file.</source>
          <target state="translated">파일을 슬러 핑하려면 &lt;code&gt;$/&lt;/code&gt; 를 명시 적으로 &lt;code&gt;undef&lt;/code&gt; 로 설정하도록 코드를 변경하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="5d012b1e71664ae83bcc78214d293fa6e2c91aff" translate="yes" xml:space="preserve">
          <source>You are recommended to change your code to set &lt;code&gt;$/&lt;/code&gt; to &lt;code&gt;undef&lt;/code&gt; explicitly if you wish to slurp the file. As of Perl 5.28 assigning &lt;code&gt;$/&lt;/code&gt; to a reference to an integer which isn't positive is a fatal error.</source>
          <target state="translated">파일을 슬러 핑하려면 &lt;code&gt;$/&lt;/code&gt; 를 명시 적으로 &lt;code&gt;undef&lt;/code&gt; 로 설정하도록 코드를 변경하는 것이 좋습니다 . Perl 5.28에서 &lt;code&gt;$/&lt;/code&gt; 를 양수가 아닌 정수에 대한 참조에 할당 하는 것은 치명적인 오류입니다.</target>
        </trans-unit>
        <trans-unit id="d65f3a3a78dc9835626ba2ec61976c50a4907da1" translate="yes" xml:space="preserve">
          <source>You are responsible for &lt;code&gt;SvREFCNT_inc()&lt;/code&gt; on the return value if you plan to store it anywhere semi-permanently (otherwise it might be deleted out from under you the next time the cache is invalidated).</source>
          <target state="translated">반 영구적으로 &lt;code&gt;SvREFCNT_inc()&lt;/code&gt; 에 저장하려는 경우 반환 값에 대한 SvREFCNT_inc () 에 대한 책임 이 있습니다 (그렇지 않으면 다음에 캐시가 무효화 될 때 아래에서 삭제 될 수 있음).</target>
        </trans-unit>
        <trans-unit id="d2b17aed1d92752587b50f28c3736df1d3cdfde7" translate="yes" xml:space="preserve">
          <source>You are responsible for setting the decoding layers on &lt;code&gt;$handle&lt;/code&gt; if required.</source>
          <target state="translated">필요한 경우 &lt;code&gt;$handle&lt;/code&gt; 에서 디코딩 레이어를 설정 해야합니다.</target>
        </trans-unit>
        <trans-unit id="fda3d08b1d18c1ab40c3862a395af18d46e5f5cf" translate="yes" xml:space="preserve">
          <source>You are strongly discouraged from using this function directly. It is used by various core modules, like &lt;code&gt;Hash::Util&lt;/code&gt;, and the &lt;code&gt;constant&lt;/code&gt; pragma to implement higher-level behavior which should be used instead.</source>
          <target state="translated">이 기능을 직접 사용하지 않는 것이 좋습니다. &lt;code&gt;Hash::Util&lt;/code&gt; 과 같은 다양한 핵심 모듈 과 &lt;code&gt;constant&lt;/code&gt; pragma에서 대신 사용해야하는 상위 수준 동작을 구현하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="37e416f1d8fe7e351baa8b0e70e6dc37f69f6f41" translate="yes" xml:space="preserve">
          <source>You are strongly encouraged to implement methods below, at least either encode() or decode().</source>
          <target state="translated">적어도 encode () 또는 decode () 중 하나를 아래에서 구현하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="ff134e38e289cfa6f5f3d471d7e0e0fabcbe8c66" translate="yes" xml:space="preserve">
          <source>You are strongly encouraged to migrate any existing threaded code to the new model (i.e., use the &lt;code&gt;threads&lt;/code&gt; and &lt;code&gt;threads::shared&lt;/code&gt; modules) as soon as possible.</source>
          <target state="translated">기존 스레드 코드를 새 모델로 마이그레이션하는 것이 좋습니다 (예 : &lt;code&gt;threads&lt;/code&gt; 및 &lt;code&gt;threads::shared&lt;/code&gt; 가능한 빨리 모듈 사용)하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="2a08b19fff728f8eb38fe62f343715380f316ef9" translate="yes" xml:space="preserve">
          <source>You aren't allowed to modify constants in this way, of course. If an argument were actually literal and you tried to change it, you'd take a (presumably fatal) exception. For example, this won't work:</source>
          <target state="translated">물론 이런 식으로 상수를 수정할 수는 없습니다. 인수가 실제로 문자 그대로이고 변경하려고 시도하면 (아마도 치명적인) 예외가 발생합니다. 예를 들어, 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2ed4e9f522b1893c218a4950d5f8fc9530c317f7" translate="yes" xml:space="preserve">
          <source>You aren't limited to just a single &lt;code&gt;&quot;|&quot;&lt;/code&gt;.</source>
          <target state="translated">하나의 &lt;code&gt;&quot;|&quot;&lt;/code&gt; 에만 국한되지 않습니다. .</target>
        </trans-unit>
        <trans-unit id="6d1e1241acbf20a33264ba47e94319bd2c6bf6a8" translate="yes" xml:space="preserve">
          <source>You assigned a reference to a scalar to &lt;code&gt;$/&lt;/code&gt; where the referenced item is not a positive integer. In older perls this &lt;b&gt;appeared&lt;/b&gt; to work the same as setting it to &lt;code&gt;undef&lt;/code&gt; but was in fact internally different, less efficient and with very bad luck could have resulted in your file being split by a stringified form of the reference.</source>
          <target state="translated">참조 된 항목이 양의 정수가 아닌 &lt;code&gt;$/&lt;/code&gt; 스칼라에 대한 참조를 할당했습니다 . 이전 펄에서 이것은 &lt;code&gt;undef&lt;/code&gt; 로 설정하는 것과 동일하게 작동하는 &lt;b&gt;것처럼 보였지만&lt;/b&gt; 실제로는 내부적으로 다르고 효율성이 떨어지고 매우 불운으로 인해 파일이 문자열 형식의 참조로 분할 될 수있었습니다.</target>
        </trans-unit>
        <trans-unit id="1622820db3665cc19fb76f05a9e122011064bf68" translate="yes" xml:space="preserve">
          <source>You can &quot;make install&quot; already but you should test first.</source>
          <target state="translated">이미 &quot;설치&quot;를 할 수 있지만 먼저 테스트해야합니다.</target>
        </trans-unit>
        <trans-unit id="441d296a1602f9e39d91a622912b032dea66e8b8" translate="yes" xml:space="preserve">
          <source>You can (and should) read more about references in &lt;a href=&quot;perlref&quot;&gt;perlref&lt;/a&gt;. Briefly, references are rather like pointers that know what they point to. (Objects are also a kind of reference, but we won't be needing them right away--if ever.) This means that when you have something which looks to you like an access to a two-or-more-dimensional array and/or hash, what's really going on is that the base type is merely a one-dimensional entity that contains references to the next level. It's just that you can</source>
          <target state="translated">&lt;a href=&quot;perlref&quot;&gt;perlref의&lt;/a&gt; 참조에 대해 더 많이 읽을 수 있습니다 . 간단히 말해서, 참조는 가리키는 것을 아는 포인터와 같습니다. (객체도 일종의 참조이지만, 우리는 지금 당장 필요하지 않을 것입니다.) 이것은 2 차원 이상의 배열에 대한 접근처럼 보이는 것이있을 때 / 또는 해시, 실제로 진행되는 것은 기본 유형이 다음 수준에 대한 참조를 포함하는 1 차원 엔터티라는 것입니다. 단지 당신이 할 수있는 것입니다</target>
        </trans-unit>
        <trans-unit id="4c8d7d3437af9191b3b2ecdbf2e0cc22d58ff901" translate="yes" xml:space="preserve">
          <source>You can &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt;ize just one element of an aggregate. Usually this is done on dynamics:</source>
          <target state="translated">집계의 한 요소 만 &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; 화할 수 있습니다 . 일반적으로 이것은 역학에서 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="8ef093b34210f5147b5553d815c011dc81eff7de" translate="yes" xml:space="preserve">
          <source>You can &lt;code&gt;local&lt;/code&gt;ize just one element of an aggregate. Usually this is done on dynamics:</source>
          <target state="translated">당신은 할 수 있습니다 &lt;code&gt;local&lt;/code&gt; 집합의 한 요소이지는. 일반적으로 이것은 역학에서 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="3c3c57d183363a886eda26951cab8a3d873beb8e" translate="yes" xml:space="preserve">
          <source>You can access the first characters of a string with substr(). To get the first character, for example, start at position 0 and grab the string of length 1.</source>
          <target state="translated">substr ()을 사용하여 문자열의 첫 문자에 액세스 할 수 있습니다. 예를 들어 첫 번째 문자를 얻으려면 위치 0에서 시작하여 길이가 1 인 문자열을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="4b6168183223c539ff65f81f73941c2c4a8e59c2" translate="yes" xml:space="preserve">
          <source>You can actually chomp anything that's an lvalue, including an assignment:</source>
          <target state="translated">할당을 포함하여 실제로 lvalue 인 것을 숨길 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ab3659f896bba38cbe056eb37538d331f15d2fcc" translate="yes" xml:space="preserve">
          <source>You can actually chop anything that's an lvalue, including an assignment.</source>
          <target state="translated">실제로 과제를 포함하여 lvalue 인 것을 다질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="06e51b7968687b9d39d3fba6b7611216b01c17eb" translate="yes" xml:space="preserve">
          <source>You can actually put an array or hash anywhere in the list, but the first one in the list will soak up all the values, and anything after it will become undefined. This may be useful in a my() or local().</source>
          <target state="translated">실제로 목록의 어느 곳에 나 배열이나 해시를 넣을 수 있지만 목록의 첫 번째 값은 모든 값을 흡수하며 그 이후의 값은 정의되지 않습니다. 이것은 my () 또는 local ()에서 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="532505c0e3919310f7105bcc98c9ca0331dbfd6d" translate="yes" xml:space="preserve">
          <source>You can actually take this one step further and test the manual itself. Have a look at &lt;a href=&quot;Test::Inline&quot;&gt;Test::Inline&lt;/a&gt; (formerly &lt;a href=&quot;Pod::Tests&quot;&gt;Pod::Tests&lt;/a&gt;).</source>
          <target state="translated">실제로 한 단계 더 나아가 매뉴얼 자체를 테스트 할 수 있습니다. &lt;a href=&quot;Test::Inline&quot;&gt;Test :: Inline&lt;/a&gt; (이전 &lt;a href=&quot;Pod::Tests&quot;&gt;Pod :: Tests&lt;/a&gt; )을 살펴보세요 .</target>
        </trans-unit>
        <trans-unit id="9fcefecb0feb2b6d0223364636eebffcb896a89d" translate="yes" xml:space="preserve">
          <source>You can add customized aliases to standard (&lt;code&gt;:full&lt;/code&gt; ) Unicode naming conventions. The aliases override any standard definitions, so, if you're twisted enough, you can change &lt;code&gt;&quot;\N{LATIN CAPITAL LETTER A}&quot;&lt;/code&gt; to mean &lt;code&gt;&quot;B&quot;&lt;/code&gt; , etc.</source>
          <target state="translated">표준 ( &lt;code&gt;:full&lt;/code&gt; ) 유니 코드 이름 지정 규칙 에 사용자 정의 된 별명을 추가 할 수 있습니다 . 별칭은 표준 정의를 재정의하므로 충분히 꼬인 경우 &lt;code&gt;&quot;\N{LATIN CAPITAL LETTER A}&quot;&lt;/code&gt; 를 &lt;code&gt;&quot;B&quot;&lt;/code&gt; 등으로 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="665e29e63421d2fd846f895a1a1e9676c964ad4a" translate="yes" xml:space="preserve">
          <source>You can add customized aliases to standard (&lt;code&gt;:full&lt;/code&gt;) Unicode naming conventions. The aliases override any standard definitions, so, if you're twisted enough, you can change &lt;code&gt;&quot;\N{LATIN CAPITAL LETTER A}&quot;&lt;/code&gt; to mean &lt;code&gt;&quot;B&quot;&lt;/code&gt;, etc.</source>
          <target state="translated">표준 ( &lt;code&gt;:full&lt;/code&gt; ) 유니 코드 명명 규칙 에 사용자 정의 된 별칭을 추가 할 수 있습니다 . 별칭은 모든 표준 정의를 재정의하므로 충분히 왜곡 된 경우 &lt;code&gt;&quot;\N{LATIN CAPITAL LETTER A}&quot;&lt;/code&gt; 를 &lt;code&gt;&quot;B&quot;&lt;/code&gt; 등 을 의미하도록 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="422d4c1954392600b653163b725624c46d77f3f0" translate="yes" xml:space="preserve">
          <source>You can adjust the counter by assigning to &lt;code&gt;$.&lt;/code&gt; , but this will not actually move the seek pointer.</source>
          <target state="translated">&lt;code&gt;$.&lt;/code&gt; 에 할당하여 카운터를 조정할 수 있습니다 . 그러나 이것은 실제로 탐색 포인터를 이동시키지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1e12c1c150e8155af23e75fc04a29600af824216" translate="yes" xml:space="preserve">
          <source>You can adjust the counter by assigning to &lt;code&gt;$.&lt;/code&gt;, but this will not actually move the seek pointer.</source>
          <target state="translated">&lt;code&gt;$.&lt;/code&gt; 에 할당하여 카운터를 조정할 수 있습니다 . 그러나 이것은 실제로 탐색 포인터를 이동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="add234c624f206426ee8290a3ddfc9b8ceedcb89" translate="yes" xml:space="preserve">
          <source>You can also alter the way the output and logic of &lt;code&gt;Carp&lt;/code&gt; works, by changing some global variables in the &lt;code&gt;Carp&lt;/code&gt; namespace. See the section on &lt;code&gt;GLOBAL VARIABLES&lt;/code&gt; below.</source>
          <target state="translated">&lt;code&gt;Carp&lt;/code&gt; 네임 스페이스 에서 일부 전역 변수를 변경 하여 &lt;code&gt;Carp&lt;/code&gt; 의 출력 및 논리 작동 방식을 변경할 수도 있습니다 . 아래의 &lt;code&gt;GLOBAL VARIABLES&lt;/code&gt; 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="261bbd570ac37c0ad60f8d4ba64480f35ae30ac1" translate="yes" xml:space="preserve">
          <source>You can also call &lt;a href=&quot;#die-LIST&quot;&gt;&lt;code&gt;die&lt;/code&gt;&lt;/a&gt; with a reference argument, and if this is trapped within an &lt;a href=&quot;#eval-EXPR&quot;&gt;&lt;code&gt;eval&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;perlvar#%24%40&quot;&gt;&lt;code&gt;$@&lt;/code&gt;&lt;/a&gt; contains that reference. This permits more elaborate exception handling using objects that maintain arbitrary state about the exception. Such a scheme is sometimes preferable to matching particular string values of &lt;a href=&quot;perlvar#%24%40&quot;&gt;&lt;code&gt;$@&lt;/code&gt;&lt;/a&gt; with regular expressions.</source>
          <target state="translated">또한 호출 할 수 있습니다 &lt;a href=&quot;#die-LIST&quot;&gt; &lt;code&gt;die&lt;/code&gt; &lt;/a&gt; 참조 인수와 함께,이는 내 갇혀 경우 &lt;a href=&quot;#eval-EXPR&quot;&gt; &lt;code&gt;eval&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;perlvar#%24%40&quot;&gt; &lt;code&gt;$@&lt;/code&gt; &lt;/a&gt; 그 참조를 포함합니다. 이는 예외에 대한 임의의 상태를 유지하는 객체를 사용하여보다 정교한 예외 처리를 허용합니다. 이러한 체계는 경우에 따라 &lt;a href=&quot;perlvar#%24%40&quot;&gt; &lt;code&gt;$@&lt;/code&gt; &lt;/a&gt; 의 특정 문자열 값을 정규식과 일치시키는 것보다 선호됩니다 .</target>
        </trans-unit>
        <trans-unit id="0d61dd797cd63f1042bbffa35621af46e71f5b31" translate="yes" xml:space="preserve">
          <source>You can also call &lt;code&gt;&lt;a href=&quot;die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; with a reference argument, and if this is trapped within an &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;$@&lt;/code&gt; contains that reference. This permits more elaborate exception handling using objects that maintain arbitrary state about the exception. Such a scheme is sometimes preferable to matching particular string values of &lt;code&gt;$@&lt;/code&gt; with regular expressions. Because &lt;code&gt;$@&lt;/code&gt; is a global variable and &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; may be used within object implementations, be careful that analyzing the error object doesn't replace the reference in the global variable. It's easiest to make a local copy of the reference before any manipulations. Here's an example:</source>
          <target state="translated">또한 호출 할 수 있습니다 &lt;code&gt;&lt;a href=&quot;die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; 참조 인수와 함께,이는 내 갇혀 경우 &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;$@&lt;/code&gt; 그 참조를 포함합니다. 이를 통해 예외에 대한 임의의 상태를 유지하는 오브젝트를 사용하여보다 정교한 예외 처리가 가능합니다. 이러한 체계는 때때로 &lt;code&gt;$@&lt;/code&gt; 의 특정 문자열 값을 정규식과 일치시키는 것보다 선호됩니다 . 때문에 &lt;code&gt;$@&lt;/code&gt; 전역 변수이고 &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 객체 구현 내에서 사용할 수 있으며, 오류 개체를 분석하는 글로벌 변수에 대한 참조를 대체하지 않도록주의해야합니다. 조작하기 전에 참조의 로컬 사본을 만드는 것이 가장 쉽습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="151ae294544e5b15c198686df29c5202445b492a" translate="yes" xml:space="preserve">
          <source>You can also call &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; with a reference argument, and if this is trapped within an &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;$@&lt;/code&gt; contains that reference. This permits more elaborate exception handling using objects that maintain arbitrary state about the exception. Such a scheme is sometimes preferable to matching particular string values of &lt;code&gt;$@&lt;/code&gt; with regular expressions. Because &lt;code&gt;$@&lt;/code&gt; is a global variable and &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; may be used within object implementations, be careful that analyzing the error object doesn't replace the reference in the global variable. It's easiest to make a local copy of the reference before any manipulations. Here's an example:</source>
          <target state="translated">또한 호출 할 수 있습니다 &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; 참조 인수와 함께,이는 내 갇혀 경우 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;$@&lt;/code&gt; 그 참조를 포함합니다. 이를 통해 예외에 대한 임의의 상태를 유지하는 오브젝트를 사용하여보다 정교한 예외 처리가 가능합니다. 이러한 체계는 때때로 &lt;code&gt;$@&lt;/code&gt; 의 특정 문자열 값을 정규식과 일치시키는 것보다 선호됩니다 . 때문에 &lt;code&gt;$@&lt;/code&gt; 전역 변수이고 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 객체 구현 내에서 사용할 수 있으며, 오류 개체를 분석하는 글로벌 변수에 대한 참조를 대체하지 않도록주의해야합니다. 조작하기 전에 참조의 로컬 사본을 만드는 것이 가장 쉽습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9cdb85fa1e67a62d3e70dba3d5bf1c75c04f7e09" translate="yes" xml:space="preserve">
          <source>You can also call parse_lines() to parse an array of lines or parse_string_document() to parse a document already in memory. As with parse_file(), parse_lines() and parse_string_document() default to sending their output to &lt;code&gt;STDOUT&lt;/code&gt; unless changed with the output_fh() method.</source>
          <target state="translated">parse_lines ()를 호출하여 행 배열을 구문 분석하거나 parse_string_document ()를 사용하여 이미 메모리에있는 문서를 구문 분석 할 수도 있습니다. parse_file ()과 마찬가지로 parse_lines () 및 parse_string_document () 는 output_fh () 메소드로 변경하지 않는 한 기본적으로 출력을 &lt;code&gt;STDOUT&lt;/code&gt; 으로 전송합니다 .</target>
        </trans-unit>
        <trans-unit id="792416647ce701349df829839ca082b8dd50a041" translate="yes" xml:space="preserve">
          <source>You can also call parse_lines() to parse an array of lines or parse_string_document() to parse a document already in memory. As with parse_file(), parse_lines() and parse_string_document() default to sending their output to &lt;code&gt;STDOUT&lt;/code&gt; unless changed with the output_fh() method. Be aware that parse_lines() and parse_string_document() both expect raw bytes, not decoded characters.</source>
          <target state="translated">또한 parse_lines ()를 호출하여 행 배열을 구문 분석하거나 parse_string_document ()를 호출하여 이미 메모리에있는 문서를 구문 분석 할 수 있습니다. parse_file ()과 마찬가지로 parse_lines () 및 parse_string_document () 는 output_fh () 메서드로 변경하지 않는 한 기본적으로 출력을 &lt;code&gt;STDOUT&lt;/code&gt; 으로 보냅니다 . parse_lines () 및 parse_string_document () 모두 디코딩 된 문자가 아닌 원시 바이트를 예상합니다.</target>
        </trans-unit>
        <trans-unit id="61cf53df274337143d282caf711ce10831abe85c" translate="yes" xml:space="preserve">
          <source>You can also chain the calls like this, this first makes a copy and then multiply it by 2:</source>
          <target state="translated">다음과 같이 호출을 연결할 수도 있습니다. 먼저 복사본을 만든 다음 2를 곱합니다.</target>
        </trans-unit>
        <trans-unit id="e57fcafa1ea35942e9edb2cd8f5d66578716838d" translate="yes" xml:space="preserve">
          <source>You can also chain the calls like this, this will make first a copy and then multiply it by 2:</source>
          <target state="translated">이와 같이 호출을 연결하면 먼저 사본을 만든 다음 2를 곱합니다.</target>
        </trans-unit>
        <trans-unit id="029fcbbc45bf12d25b834057d9395bba7ab192ae" translate="yes" xml:space="preserve">
          <source>You can also change the internal suspects list via &lt;code&gt;set_suspects&lt;/code&gt; method.</source>
          <target state="translated">다음을 통해 내부 용의자 목록을 변경할 수도 있습니다 &lt;code&gt;set_suspects&lt;/code&gt; 메소드 .</target>
        </trans-unit>
        <trans-unit id="5c5a392365d6b99ba2358d8d79ba87643cdf832d" translate="yes" xml:space="preserve">
          <source>You can also cherry-pick commits from blead and another branch, by using the &lt;code&gt;git cherry-pick&lt;/code&gt; command. It is recommended to use the &lt;b&gt;-x&lt;/b&gt; option to &lt;code&gt;git cherry-pick&lt;/code&gt; in order to record the SHA1 of the original commit in the new commit message.</source>
          <target state="translated">&lt;code&gt;git cherry-pick&lt;/code&gt; 명령 을 사용하여 blead 및 다른 브랜치에서 커밋을 cherry-pick 할 수도 있습니다 . 새 커밋 메시지에 원래 커밋의 SHA1을 기록 하려면 &lt;b&gt;-x&lt;/b&gt; 옵션 을 사용하여 &lt;code&gt;git cherry-pick&lt;/code&gt; 을 사용하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="d2a2e4e937f2dcf302981b9beceb35f4afd812bf" translate="yes" xml:space="preserve">
          <source>You can also choose to use rsync to get a copy of the current source tree for the bleadperl branch and all maintenance branches:</source>
          <target state="translated">rsync를 사용하여 bleadperl 분기 및 모든 유지 보수 분기에 대한 현재 소스 트리의 사본을 가져 오도록 선택할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="06fef7ffb01d2e70116beb4b064bd4adf57f2910" translate="yes" xml:space="preserve">
          <source>You can also construct an empty set of prereqs with:</source>
          <target state="translated">다음을 사용하여 빈 사전 요구 사항 세트를 구성 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="69913c0f24daf22d2c432ea27b2a49c000488188" translate="yes" xml:space="preserve">
          <source>You can also control the 'hushed' flag at run-time, using the built-in routine vmsish::hushed(). Without argument, it returns the hushed status. Since vmsish::hushed is built-in, you do not need to &quot;use vmsish&quot; to call it.</source>
          <target state="translated">내장 루틴 vmsish :: hushed ()를 사용하여 런타임에 'hushed'플래그를 제어 할 수도 있습니다. 인수가 없으면 허쉬 상태를 반환합니다. vmsish :: hushed가 내장되어 있으므로 &quot;vmsish를 사용하여&quot;호출 할 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="563cd6bbc176ecbc734b5b0b439a546964280899" translate="yes" xml:space="preserve">
          <source>You can also control the character encoding and entities. For example, if you're sure that the POD is properly encoded (using the &lt;code&gt;=encoding&lt;/code&gt; command), you can prevent high-bit characters from being encoded as HTML entities and declare the output character set as UTF-8 before parsing, like so:</source>
          <target state="translated">문자 인코딩 및 엔터티를 제어 할 수도 있습니다. 예를 들어, POD가 올바르게 인코딩 된 경우 ( &lt;code&gt;=encoding&lt;/code&gt; 명령을 사용하여 ), 높은 비트 문자가 HTML 엔티티로 인코딩되는 것을 방지하고 구문 분석하기 전에 출력 문자 세트를 UTF-8로 선언 할 수 있습니다. :</target>
        </trans-unit>
        <trans-unit id="ce7cb29295e37cbd29b717e64482225d4d4ba414" translate="yes" xml:space="preserve">
          <source>You can also control the shell that perl uses to run system() and backtick commands via PERL5SHELL. See &lt;a href=&quot;perlrun&quot;&gt;perlrun&lt;/a&gt;.</source>
          <target state="translated">PERL5SHELL을 통해 perl이 system () 및 backtick 명령을 실행하는 데 사용하는 쉘을 제어 할 수도 있습니다. &lt;a href=&quot;perlrun&quot;&gt;perlrun을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="4b6274126a67429902f21b4ff102d4a5f157ec82" translate="yes" xml:space="preserve">
          <source>You can also create a circular reference with a single variable:</source>
          <target state="translated">단일 변수를 사용하여 순환 참조를 만들 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="fe319fa0895a7f47e55075d55fc2289e3b3f2bea" translate="yes" xml:space="preserve">
          <source>You can also do</source>
          <target state="translated">당신은 또한 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="9354065d75fb22856af80d6825be0de174fa14aa" translate="yes" xml:space="preserve">
          <source>You can also do the same things with the &lt;a href=&quot;datetime&quot;&gt;DateTime&lt;/a&gt; module:</source>
          <target state="translated">&lt;a href=&quot;datetime&quot;&gt;DateTime&lt;/a&gt; 모듈 에서도 동일한 작업을 수행 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="69a5ee6a0a8ad7101d445832b3faf4f8db8fd92c" translate="yes" xml:space="preserve">
          <source>You can also do the same things with the &lt;a href=&quot;http://search.cpan.org/perldoc/DateTime&quot;&gt;DateTime&lt;/a&gt; module:</source>
          <target state="translated">&lt;a href=&quot;http://search.cpan.org/perldoc/DateTime&quot;&gt;DateTime으로&lt;/a&gt; 동일한 작업을 수행 할 수도 있습니다. 모듈 .</target>
        </trans-unit>
        <trans-unit id="efdd9cfab2b6e73dabdc31999bde389ad6e9c40e" translate="yes" xml:space="preserve">
          <source>You can also do the wrapping explicitly by rad2rad(), deg2deg(), and grad2grad().</source>
          <target state="translated">rad2rad (), deg2deg () 및 grad2grad ()를 사용하여 래핑을 명시 적으로 수행 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="e971cca5e90229321a699ea5b197dee6a304b5cb" translate="yes" xml:space="preserve">
          <source>You can also do this directly in the match operator using the &lt;code&gt;\Q&lt;/code&gt; and &lt;code&gt;\E&lt;/code&gt; sequences. The &lt;code&gt;\Q&lt;/code&gt; tells Perl where to start escaping special characters, and the &lt;code&gt;\E&lt;/code&gt; tells it where to stop (see &lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt; for more details).</source>
          <target state="translated">&lt;code&gt;\Q&lt;/code&gt; 및 &lt;code&gt;\E&lt;/code&gt; 시퀀스를 사용하여 일치 연산자에서 직접이 작업을 수행 할 수도 있습니다 . &lt;code&gt;\Q&lt;/code&gt; 어디에서 특수 문자를 이스케이프 시작하는 펄을 알려줍니다, 그리고 &lt;code&gt;\E&lt;/code&gt; 곳 (참조 중지하는 방법을 알려줍니다 &lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt; 자세한 내용).</target>
        </trans-unit>
        <trans-unit id="5646b0b75475a7d6e7784a71e7f3baa1d3885cbc" translate="yes" xml:space="preserve">
          <source>You can also do this for most systems using the &lt;a href=&quot;Term::ReadKey&quot;&gt;Term::ReadKey&lt;/a&gt; module from CPAN, which is easier to use and in theory more portable.</source>
          <target state="translated">CPAN 의 &lt;a href=&quot;Term::ReadKey&quot;&gt;Term :: ReadKey&lt;/a&gt; 모듈을 사용하여 대부분의 시스템에서이 작업을 수행 할 수도 있습니다.이 모듈은 사용하기 쉽고 이론적으로 더 이식성이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="fe2d0afbbbfb95dc9ef1705dc46b6eb4a3e77627" translate="yes" xml:space="preserve">
          <source>You can also do this for most systems using the &lt;a href=&quot;http://search.cpan.org/perldoc/Term::ReadKey&quot;&gt;Term::ReadKey&lt;/a&gt; module from CPAN, which is easier to use and in theory more portable.</source>
          <target state="translated">CPAN 의 &lt;a href=&quot;http://search.cpan.org/perldoc/Term::ReadKey&quot;&gt;Term :: ReadKey&lt;/a&gt; 모듈을 사용하여 대부분의 시스템에서이 작업을 수행 할 수도 있습니다. CPAN은 사용하기 쉽고 이론적으로 이식성이 뛰어납니다.</target>
        </trans-unit>
        <trans-unit id="f3337ad9bcb6d402cd92e0314d2032a9a8dc4c0a" translate="yes" xml:space="preserve">
          <source>You can also easily say to use all categories but one, by either, for example,</source>
          <target state="translated">예를 들어 다음과 같이 두 가지 중 하나만 사용하여 모든 범주를 사용하도록 쉽게 말할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="317bed7b561a99db6e7463d3bee761b35a18aa16" translate="yes" xml:space="preserve">
          <source>You can also embed newlines directly in your strings, i.e., they can end on a different line than they begin. This is nice, but if you forget your trailing quote, the error will not be reported until Perl finds another line containing the quote character, which may be much further on in the script. Variable substitution inside strings is limited to scalar variables, arrays, and array or hash slices. (In other words, names beginning with $ or @, followed by an optional bracketed expression as a subscript.) The following code segment prints out &quot;The price is $100.&quot;</source>
          <target state="translated">또한 줄 바꿈을 문자열에 직접 포함시킬 수 있습니다. 즉, 시작 줄과 다른 줄에서 끝날 수 있습니다. 이것은 좋지만 후행 따옴표를 잊어 버린 경우 Perl이 따옴표 문자를 포함하는 다른 행을 찾을 때까지 오류가보고되지 않으며, 이는 스크립트에서 훨씬 더 진행될 수 있습니다. 문자열 내부의 변수 대체는 스칼라 변수, 배열 및 배열 또는 해시 슬라이스로 제한됩니다. 즉, 이름은 $ 또는 @로 시작하고 뒤에 괄호로 묶인 선택적 표현식이옵니다. 다음 코드 세그먼트는 &quot;가격은 $ 100입니다.&quot;를 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="6dc98b973b8e3861953362cf4137bf9098b40a23" translate="yes" xml:space="preserve">
          <source>You can also explicitly indicate that a single handler is meant to be used for all types of referents like so:</source>
          <target state="translated">또한 단일 핸들러가 다음과 같이 모든 유형의 참조에 사용되도록 명시 적으로 표시 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cc7d393dae203f89e29915d158bc84c0d091344a" translate="yes" xml:space="preserve">
          <source>You can also explicitly specify the argument number to use for the join string using something like &lt;code&gt;*2$v&lt;/code&gt;; for example:</source>
          <target state="translated">&lt;code&gt;*2$v&lt;/code&gt; 와 같은 것을 사용하여 결합 문자열에 사용할 인수 번호를 명시 적으로 지정할 수도 있습니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3c69b8b0664f8688a90139832b96e7b725fab5ec" translate="yes" xml:space="preserve">
          <source>You can also gain some minuscule measure of efficiency by pre-extending an array that is going to get big. You can also extend an array by assigning to an element that is off the end of the array. You can truncate an array down to nothing by assigning the null list () to it. The following are equivalent:</source>
          <target state="translated">또한 커질 어레이를 미리 확장하여 약간의 효율성 측정 값을 얻을 수도 있습니다. 배열의 끝에있는 요소에 할당하여 배열을 확장 할 수도 있습니다. 널 (null) 목록 ()을 지정하여 배열을 무단으로자를 수 있습니다. 다음은 동일합니다.</target>
        </trans-unit>
        <trans-unit id="87f6d7508324248bf5fa6b6a6e4e9d73a898fe92" translate="yes" xml:space="preserve">
          <source>You can also get a pointer to the end of the string stored in the SV with the macro:</source>
          <target state="translated">매크로를 사용하여 SV에 저장된 문자열 끝에 대한 포인터를 얻을 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="5c82629fae7a8fb986a942489f622aa4264ef7c4" translate="yes" xml:space="preserve">
          <source>You can also get differences with a subtraction, which returns a &lt;a href=&quot;Time::Seconds&quot;&gt;Time::Seconds&lt;/a&gt; object:</source>
          <target state="translated">&lt;a href=&quot;Time::Seconds&quot;&gt;Time :: Seconds&lt;/a&gt; 객체 를 반환하는 빼기로 차이를 얻을 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="843f7af3e5947338619464418b011d78b7714032" translate="yes" xml:space="preserve">
          <source>You can also get differences with a subtraction, which returns a &lt;a href=&quot;time/seconds&quot;&gt;Time::Seconds&lt;/a&gt; object:</source>
          <target state="translated">빼기를 사용하여 차이를 얻을 수도 있습니다.이 빼기는 &lt;a href=&quot;time/seconds&quot;&gt;Time :: Seconds&lt;/a&gt; 객체 를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="0da6f0ff3f9840990993a84402f300e13eb838e3" translate="yes" xml:space="preserve">
          <source>You can also get into subtle problems on those few operations in Perl that actually do care about the difference between a string and a number, such as the magical &lt;code&gt;++&lt;/code&gt; autoincrement operator or the syscall() function.</source>
          <target state="translated">마법의 &lt;code&gt;++&lt;/code&gt; 자동 증가 연산자 또는 syscall () 함수 와 같이 문자열과 숫자의 차이를 실제로 처리하는 Perl의 소수 작업에 대해서는 미묘한 문제가 발생할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="b13a71a702d5f9f57f9b335ced17d27c5c8c8136" translate="yes" xml:space="preserve">
          <source>You can also get the precision from the next argument using &lt;code&gt;.*&lt;/code&gt;, or from a specified argument (e.g., with &lt;code&gt;.*2$&lt;/code&gt;):</source>
          <target state="translated">&lt;code&gt;.*&lt;/code&gt; 를 사용하여 다음 인수 또는 지정된 인수 (예 : &lt;code&gt;.*2$&lt;/code&gt; ) 에서 정밀도를 가져올 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="dd7d480332101e4bfe5db6a1d74af4d69d28cfca" translate="yes" xml:space="preserve">
          <source>You can also get the precision from the next argument using &lt;code&gt;.*&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;.*&lt;/code&gt; 사용하여 다음 인수에서 정밀도를 얻을 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="31317a51fe6916c8950fb1738da08a3f662e794a" translate="yes" xml:space="preserve">
          <source>You can also go through each element and skip the ones you've seen before. Use a hash to keep track. The first time the loop sees an element, that element has no key in &lt;code&gt;%Seen&lt;/code&gt; . The &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; statement creates the key and immediately uses its value, which is &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;, so the loop continues to the &lt;code&gt;&lt;a href=&quot;functions/push&quot;&gt;push&lt;/a&gt;&lt;/code&gt; and increments the value for that key. The next time the loop sees that same element, its key exists in the hash</source>
          <target state="translated">각 요소를 살펴보고 이전에 본 요소를 건너 뛸 수도 있습니다. 해시를 사용하여 추적하십시오. 루프에서 요소를 처음 볼 때 해당 요소에는 &lt;code&gt;%Seen&lt;/code&gt; 키가 없습니다 . &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; 문장은 키를 생성하고 즉시 인 값, 사용하는 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 때문에 루프는 계속 &lt;code&gt;&lt;a href=&quot;functions/push&quot;&gt;push&lt;/a&gt;&lt;/code&gt; 및 해당 키의 값을 증가시킨다. 다음에 루프가 동일한 요소를 볼 때 해당 키가 해시에 존재합니다.</target>
        </trans-unit>
        <trans-unit id="edcb0c6ef0708a661ee9e625297a07b8efd27958" translate="yes" xml:space="preserve">
          <source>You can also go through each element and skip the ones you've seen before. Use a hash to keep track. The first time the loop sees an element, that element has no key in &lt;code&gt;%Seen&lt;/code&gt;. The &lt;code&gt;next&lt;/code&gt; statement creates the key and immediately uses its value, which is &lt;code&gt;undef&lt;/code&gt;, so the loop continues to the &lt;code&gt;push&lt;/code&gt; and increments the value for that key. The next time the loop sees that same element, its key exists in the hash</source>
          <target state="translated">각 요소를 살펴보고 이전에 본 요소를 건너 뛸 수도 있습니다. 해시를 사용하여 추적하십시오. 루프가 요소를 처음 볼 때 해당 요소는 &lt;code&gt;%Seen&lt;/code&gt; 키가 없습니다 . &lt;code&gt;next&lt;/code&gt; 문은 키를 생성하고 즉시 자사의 가치, 사용 &lt;code&gt;undef&lt;/code&gt; 루프가 계속 그래서, &lt;code&gt;push&lt;/code&gt; 및 해당 키의 값을 증가시킨다. 다음에 루프가 동일한 요소를 볼 때 해당 키가 해시에 존재합니다.</target>
        </trans-unit>
        <trans-unit id="dac992fa47e7fcb08307c37ff877628a10c26073" translate="yes" xml:space="preserve">
          <source>You can also import the symbolic &lt;code&gt;S_I*&lt;/code&gt; constants from the &lt;a href=&quot;fcntl&quot;&gt;&lt;code&gt;Fcntl&lt;/code&gt;&lt;/a&gt; module:</source>
          <target state="translated">&lt;a href=&quot;fcntl&quot;&gt; &lt;code&gt;Fcntl&lt;/code&gt; &lt;/a&gt; 모듈 에서 기호 &lt;code&gt;S_I*&lt;/code&gt; 상수를 가져올 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7930ef83d4a331d3e89d11f276bc35572519ad08" translate="yes" xml:space="preserve">
          <source>You can also import the symbolic &lt;code&gt;S_I*&lt;/code&gt; constants from the &lt;code&gt;Fcntl&lt;/code&gt; module:</source>
          <target state="translated">기호 &lt;code&gt;S_I*&lt;/code&gt; 상수를 가져올 수도 있습니다. &lt;code&gt;Fcntl&lt;/code&gt; 모듈 .</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
