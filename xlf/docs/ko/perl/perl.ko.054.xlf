<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="perl">
    <body>
      <group id="perl">
        <trans-unit id="944edb7108bfdb534265951ea7b5a33f9f4b73e0" translate="yes" xml:space="preserve">
          <source>Share =&amp;gt; $uShare</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8bf62db0a202cfe8b527778be027079163e0d35" translate="yes" xml:space="preserve">
          <source>Share what you did with the other people. Relax. Enjoy fruits of your work.</source>
          <target state="translated">다른 사람들과 자신이 한 일을 공유하십시오. 편하게 하다. 당신의 일의 과일을 즐기십시오.</target>
        </trans-unit>
        <trans-unit id="df3c637adb69abac13b29419d0cfa8b766ae4adc" translate="yes" xml:space="preserve">
          <source>Shared And Unshared Data</source>
          <target state="translated">공유 및 비공유 데이터</target>
        </trans-unit>
        <trans-unit id="2ad8427c8c9758999d3e74a7bdd5fb7162a57750" translate="yes" xml:space="preserve">
          <source>Shared libraries created on a platform using a particular PA-RISC version are not usable on platforms using an earlier PA-RISC version by default. However, this backwards compatibility may be enabled using the same +DAportable compiler flag (with the same PA-RISC 1.0 caveat mentioned above).</source>
          <target state="translated">특정 PA-RISC 버전을 사용하는 플랫폼에서 생성 된 공유 라이브러리는 기본적으로 이전 PA-RISC 버전을 사용하는 플랫폼에서는 사용할 수 없습니다. 그러나이 이전 버전과의 호환성은 동일한 + DAportable 컴파일러 플래그를 사용하여 활성화 할 수 있습니다 (위에서 언급 한 동일한 PA-RISC 1.0 경고와 함께).</target>
        </trans-unit>
        <trans-unit id="193a001ab941319380e15850d6f5c791732088df" translate="yes" xml:space="preserve">
          <source>Shared libraries created on an Itanium platform cannot be loaded on a PA-RISC platform. Shared libraries created on a PA-RISC platform can only be loaded on an Itanium platform if it is a PA-RISC executable that is attempting to load the PA-RISC library. A PA-RISC shared library cannot be loaded into an Itanium executable nor vice-versa.</source>
          <target state="translated">Itanium 플랫폼에서 생성 된 공유 라이브러리는 PA-RISC 플랫폼에로드 할 수 없습니다. PA-RISC 플랫폼에서 작성된 공유 라이브러리는 PA-RISC 라이브러리를로드하려는 PA-RISC 실행 파일 인 경우 Itanium 플랫폼에서만로드 할 수 있습니다. PA-RISC 공유 라이브러리는 Itanium 실행 파일로로드하거나 그 반대로로드 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="6953ee78fc5edeec2d6a50098821da893b0458f7" translate="yes" xml:space="preserve">
          <source>Shared references among objects will not stay shared: if we're serializing the list of object [A, C] where both object A and C refer to the SAME object B, and if there is a serializing hook in A that says freeze(B), then when deserializing, we'll get [A', C'] where A' refers to B', but C' refers to D, a deep clone of B'. The topology was not preserved.</source>
          <target state="translated">객체 간 공유 참조는 공유 상태를 유지하지 않습니다. 객체 A와 C가 모두 SAME 객체 B를 참조하는 객체 [A, C] 목록을 직렬화하는 경우, A에 직렬화 후크 (freeze (B)가 있음)가있는 경우 )를 deserialize 할 때 A '는 B'를 나타내지 만 C '는 B'의 깊은 클론 D를 나타냅니다. 토폴로지가 유지되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="f728eba8dfb3236f1667f74466840c95e5a7b8ee" translate="yes" xml:space="preserve">
          <source>Shared variables can only store scalars, refs of shared variables, or refs of shared data (discussed in next section):</source>
          <target state="translated">공유 변수는 스칼라, 공유 변수의 참조 또는 공유 데이터의 참조 만 저장할 수 있습니다 (다음 섹션에서 설명).</target>
        </trans-unit>
        <trans-unit id="001c163e34c30bd422c6c0b180836b52f1afdb17" translate="yes" xml:space="preserve">
          <source>Sharing Databases With C Applications</source>
          <target state="translated">C 애플리케이션과 데이터베이스 공유</target>
        </trans-unit>
        <trans-unit id="bd8715c47f235864c2ceb04d785a7b7ec14fa56b" translate="yes" xml:space="preserve">
          <source>Sharing typemaps Between CPAN Distributions</source>
          <target state="translated">CPAN 배포간에 유형 맵 공유</target>
        </trans-unit>
        <trans-unit id="0a07afc00eaa14a561ef50fb9dc88822e22b041a" translate="yes" xml:space="preserve">
          <source>Sharp shell programmers should take note of the following:</source>
          <target state="translated">샤프 쉘 프로그래머는 다음 사항에 유의해야합니다.</target>
        </trans-unit>
        <trans-unit id="f78065b15d0af880ad317e4f961cef2d5893c97c" translate="yes" xml:space="preserve">
          <source>Shawn H Corey &lt;code&gt;SHCOREY at cpan.org&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6aa79f294b4ff3f2bd0e6980c0d9d3429325e3b2" translate="yes" xml:space="preserve">
          <source>Shawn M Moore &lt;code&gt;sartak@gmail.com&lt;/code&gt;</source>
          <target state="translated">숀 M 무어 &lt;code&gt;sartak@gmail.com&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a14cc09b3426b2766b9650c676895c8481a40916" translate="yes" xml:space="preserve">
          <source>Shebang Race Condition</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bdc1fd5d3c0f3dcfd55d010426e61bf9451e680d" translate="yes" xml:space="preserve">
          <source>Shell</source>
          <target state="translated">Shell</target>
        </trans-unit>
        <trans-unit id="46f2fc676064cd202c006928e29b43973667f22c" translate="yes" xml:space="preserve">
          <source>Shell Traps</source>
          <target state="translated">쉘 트랩</target>
        </trans-unit>
        <trans-unit id="05e1aa29dff23edb2a5976ffe3e3f5926084ec96" translate="yes" xml:space="preserve">
          <source>Shell escapes newlines in $text.</source>
          <target state="translated">쉘은 $ text에서 줄 바꿈을 피합니다.</target>
        </trans-unit>
        <trans-unit id="411430d5faea18a48223083d430d03ec02723be9" translate="yes" xml:space="preserve">
          <source>Shell mode</source>
          <target state="translated">쉘 모드</target>
        </trans-unit>
        <trans-unit id="ae8110256e73e2d29bfd2b0361c6084818dcf5fb" translate="yes" xml:space="preserve">
          <source>Shell variables from the</source>
          <target state="translated">쉘 변수</target>
        </trans-unit>
        <trans-unit id="a5efec93b7817b727267bf3e97356065022021aa" translate="yes" xml:space="preserve">
          <source>Shell::Command which is these same functions but take arguments normally.</source>
          <target state="translated">Shell :: Command는 동일한 기능이지만 일반적으로 인수를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="5597033de9e3a9ee3ab28b086225929f8384f842" translate="yes" xml:space="preserve">
          <source>Shells (especially &lt;b&gt;csh&lt;/b&gt;) do several levels of substitution on each command line. Perl does substitution in only certain constructs such as double quotes, backticks, angle brackets, and search patterns.</source>
          <target state="translated">쉘 (특히 &lt;b&gt;csh&lt;/b&gt; )은 각 명령 행에서 여러 레벨의 대체를 수행합니다. Perl은 큰 따옴표, 백틱, 꺾쇠 괄호 및 검색 패턴과 같은 특정 구문에서만 대체를 수행합니다.</target>
        </trans-unit>
        <trans-unit id="c3085316e59739c3d0881dec21da7ebe8e1387d1" translate="yes" xml:space="preserve">
          <source>Shells interpret scripts a little bit at a time. Perl compiles the entire program before executing it (except for &lt;code&gt;BEGIN&lt;/code&gt; blocks, which execute at compile time).</source>
          <target state="translated">쉘은 한 번에 조금씩 스크립트를 해석합니다. Perl은 프로그램을 실행하기 전에 전체 프로그램을 컴파일합니다 ( 컴파일시 실행되는 &lt;code&gt;BEGIN&lt;/code&gt; 블록 제외 ).</target>
        </trans-unit>
        <trans-unit id="d740f71b4c0205327f8285c81beee6b58843073b" translate="yes" xml:space="preserve">
          <source>Shift Operators</source>
          <target state="translated">시프트 연산자</target>
        </trans-unit>
        <trans-unit id="53ffaf0e7e7ca17703b35ea2272d3800a2b8789e" translate="yes" xml:space="preserve">
          <source>Shift object N digits right in base B and return the resulting object. This is equivalent to performing integer division by B**N and discarding the remainder, except that it might be much faster, depending on how the number is represented internally.</source>
          <target state="translated">베이스 B에서 오브젝트 N 숫자를 오른쪽으로 시프트하고 결과 오브젝트를 리턴하십시오. 이것은 B ** N으로 정수 나누기를 수행하고 나머지가 버리는 것을 제외하고는 숫자가 내부적으로 표현되는 방식에 따라 훨씬 빠를 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="816ba91c6c549fed8497fc4ed9fd5be93db7467c" translate="yes" xml:space="preserve">
          <source>Shift the object N digits left in base B. This is equivalent to multiplying by B**N, except that it might be much faster, depending on how the number is represented internally.</source>
          <target state="translated">B 자의 왼쪽에있는 개체 N 자릿수를 이동합니다. 이는 숫자가 내부적으로 표현되는 방식에 따라 훨씬 빠를 수 있다는 점을 제외하고 B ** N을 곱하는 것과 같습니다.</target>
        </trans-unit>
        <trans-unit id="34ca9f2e9bedec059779353756117cfa0cd23d9b" translate="yes" xml:space="preserve">
          <source>Shift_JIS</source>
          <target state="translated">Shift_JIS</target>
        </trans-unit>
        <trans-unit id="c96929f71a3c235121f63b63fb9116d40dbf5a0d" translate="yes" xml:space="preserve">
          <source>Shifting by more bits than the size of the integers means most of the time zero (all bits fall off), except that under &lt;code&gt;use integer&lt;/code&gt; right overshifting a negative shiftee results in -1. This is unlike in C, where shifting by too many bits is undefined. A common C behavior is &quot;shift by modulo wordbits&quot;, so that for example</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c82c36060459ec37e9c46c5b4c7db69b11b3eb70" translate="yes" xml:space="preserve">
          <source>Shifting by negative number of bits means the reverse shift: left shift becomes right shift, right shift becomes left shift. This is unlike in C, where negative shift is undefined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2bbd5485928f42790ecd61230b448ed394726e75" translate="yes" xml:space="preserve">
          <source>Shifts $x right by $y in base $n. Default is base 2, used are usually 10 and 2, but others work, too.</source>
          <target state="translated">기본 $ n에서 $ x를 $ y만큼 오른쪽으로 이동합니다. 기본값은 기본 2이며, 일반적으로 10과 2가 사용되지만 다른 것도 작동합니다.</target>
        </trans-unit>
        <trans-unit id="84e5b666ca83223606a44c0968ce869e11125987" translate="yes" xml:space="preserve">
          <source>Shifts the first value of the array off and returns it, shortening the array by 1 and moving everything down. If there are no elements in the array, returns the undefined value. If ARRAY is omitted, shifts the &lt;a href=&quot;perlvar#%40_&quot;&gt;&lt;code&gt;@_&lt;/code&gt;&lt;/a&gt; array within the lexical scope of subroutines and formats, and the &lt;a href=&quot;perlvar#%40ARGV&quot;&gt;&lt;code&gt;@ARGV&lt;/code&gt;&lt;/a&gt; array outside a subroutine and also within the lexical scopes established by the &lt;code&gt;eval STRING&lt;/code&gt;, &lt;code&gt;BEGIN {}&lt;/code&gt;, &lt;code&gt;INIT {}&lt;/code&gt;, &lt;code&gt;CHECK {}&lt;/code&gt;, &lt;code&gt;UNITCHECK {}&lt;/code&gt;, and &lt;code&gt;END {}&lt;/code&gt; constructs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cab6779d1c4d586e5a686816d2490a5a885e59ca" translate="yes" xml:space="preserve">
          <source>Shifts the first value of the array off and returns it, shortening the array by 1 and moving everything down. If there are no elements in the array, returns the undefined value. If ARRAY is omitted, shifts the &lt;code&gt;@_&lt;/code&gt; array within the lexical scope of subroutines and formats, and the &lt;code&gt;@ARGV&lt;/code&gt; array outside a subroutine and also within the lexical scopes established by the &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt; STRING&lt;/code&gt; , &lt;code&gt;BEGIN {}&lt;/code&gt; , &lt;code&gt;INIT {}&lt;/code&gt; , &lt;code&gt;CHECK {}&lt;/code&gt; , &lt;code&gt;UNITCHECK {}&lt;/code&gt; , and &lt;code&gt;END {}&lt;/code&gt; constructs.</source>
          <target state="translated">배열의 첫 번째 값을 끄고 반환하여 배열을 1만큼 줄이고 모든 것을 아래로 이동합니다. 배열에 요소가 없으면 정의되지 않은 값을 반환합니다. ARRAY가 생략되면, 시프트 &lt;code&gt;@_&lt;/code&gt; 루틴과 형식의 어휘 범위 내에서 배열하고, &lt;code&gt;@ARGV&lt;/code&gt; 의 어휘 범위에 의해 설정된 서브 루틴 외부 또한 내에 배열 &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt; STRING&lt;/code&gt; , &lt;code&gt;BEGIN {}&lt;/code&gt; , &lt;code&gt;INIT {}&lt;/code&gt; , &lt;code&gt;CHECK {}&lt;/code&gt; , &lt;code&gt;UNITCHECK {}&lt;/code&gt; 및 &lt;code&gt;END {}&lt;/code&gt; 구문입니다.</target>
        </trans-unit>
        <trans-unit id="ceb6ece5170a4ff335501d527cf25219b25ce8af" translate="yes" xml:space="preserve">
          <source>Shifts the first value of the array off and returns it, shortening the array by 1 and moving everything down. If there are no elements in the array, returns the undefined value. If ARRAY is omitted, shifts the &lt;code&gt;@_&lt;/code&gt; array within the lexical scope of subroutines and formats, and the &lt;code&gt;@ARGV&lt;/code&gt; array outside a subroutine and also within the lexical scopes established by the &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; STRING&lt;/code&gt; , &lt;code&gt;BEGIN {}&lt;/code&gt; , &lt;code&gt;INIT {}&lt;/code&gt; , &lt;code&gt;CHECK {}&lt;/code&gt; , &lt;code&gt;UNITCHECK {}&lt;/code&gt; , and &lt;code&gt;END {}&lt;/code&gt; constructs.</source>
          <target state="translated">배열의 첫 번째 값을 끄고 반환하여 배열을 1만큼 줄이고 모든 것을 아래로 이동합니다. 배열에 요소가 없으면 정의되지 않은 값을 반환합니다. ARRAY가 생략되면, 시프트 &lt;code&gt;@_&lt;/code&gt; 루틴과 형식의 어휘 범위 내에서 배열하고, &lt;code&gt;@ARGV&lt;/code&gt; 의 어휘 범위에 의해 설정된 서브 루틴 외부 또한 내에 배열 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; STRING&lt;/code&gt; , &lt;code&gt;BEGIN {}&lt;/code&gt; , &lt;code&gt;INIT {}&lt;/code&gt; , &lt;code&gt;CHECK {}&lt;/code&gt; , &lt;code&gt;UNITCHECK {}&lt;/code&gt; 및 &lt;code&gt;END {}&lt;/code&gt; 구문입니다.</target>
        </trans-unit>
        <trans-unit id="a9246a967ab694917a93818e0c2f25b9c02d69c1" translate="yes" xml:space="preserve">
          <source>Shlomi Fish</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="531ae3a2e613d67a406a1e927931cfe1052049c5" translate="yes" xml:space="preserve">
          <source>Shoichi Kaji &amp;lt;skaji@cpan.org&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dece67ae205fea215adef783e8ddedd9ee8cd234" translate="yes" xml:space="preserve">
          <source>Short for</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e560762a5e85f4245145df0a3d5f14955ebfbe7e" translate="yes" xml:space="preserve">
          <source>Short for &amp;ldquo;an instance of a class&amp;rdquo;, meaning an &lt;b&gt;object&lt;/b&gt; of that &lt;b&gt;class&lt;/b&gt;.</source>
          <target state="translated">&quot;클래스의 인스턴스&quot;의 약어로, 해당 &lt;b&gt;클래스&lt;/b&gt; 의 &lt;b&gt;객체&lt;/b&gt; 를 의미합니다 .&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="bf0f9ba179007d01df18b67571c95890eacf53a2" translate="yes" xml:space="preserve">
          <source>Short for &amp;ldquo;array value&amp;rdquo;, which refers to one of Perl&amp;rsquo;s internal data types that holds an &lt;b&gt;array&lt;/b&gt;. The &lt;code&gt;AV&lt;/code&gt; type is a subclass of &lt;b&gt;SV&lt;/b&gt;.</source>
          <target state="translated">&amp;ldquo;배열 값&amp;rdquo;의 약어로, &lt;b&gt;배열&lt;/b&gt; 을 보유하는 Perl의 내부 데이터 유형 중 하나를 나타냅니다 . &lt;code&gt;AV&lt;/code&gt; 의 유형의 서브 클래스입니다 &lt;b&gt;SV&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="daa4e28096f49e40bca183e69c8dbf8fb7d81587" translate="yes" xml:space="preserve">
          <source>Short for &amp;ldquo;scalar value&amp;rdquo;. But within the Perl interpreter, every &lt;b&gt;referent&lt;/b&gt; is treated as a member of a class derived from SV, in an object-oriented sort of way. Every &lt;b&gt;value&lt;/b&gt; inside Perl is passed around as a C language &lt;code&gt;SV*&lt;/code&gt; pointer. The SV &lt;b&gt;struct&lt;/b&gt; knows its own &amp;ldquo;referent type&amp;rdquo;, and the code is smart enough (we hope) not to try to call a &lt;b&gt;hash&lt;/b&gt; function on a &lt;b&gt;subroutine&lt;/b&gt;.</source>
          <target state="translated">&quot;스칼라 값&quot;의 줄임말입니다. 그러나 Perl 인터프리터 내에서 모든 &lt;b&gt;지시자&lt;/b&gt; 는 객체 지향적 인 방식으로 SV에서 파생 된 클래스의 멤버로 취급됩니다. Perl 내부의 모든 &lt;b&gt;값&lt;/b&gt; 은 C 언어 &lt;code&gt;SV*&lt;/code&gt; 포인터 로 전달됩니다 . SV &lt;b&gt;구조체&lt;/b&gt; 는 자체 &quot;참조 유형&quot;을 알고 있으며 코드는 똑똑 하여 &lt;b&gt;서브 루틴&lt;/b&gt; 에서 &lt;b&gt;해시&lt;/b&gt; 함수 를 호출하지 않을 것 입니다.&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="5d19c4596f6bfea39cf19abcb0120dd79077a176" translate="yes" xml:space="preserve">
          <source>Short for &lt;b&gt;scratchpad&lt;/b&gt;.</source>
          <target state="translated">에 대한 짧은 &lt;b&gt;스크래치&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="11be5993935a64f6ec9ea9395f4cafbeb6afecc6" translate="yes" xml:space="preserve">
          <source>Short for Nevada, no part of which will ever be confused with civilization. NV also means an internal floating- point Numeric Value of the type a &lt;b&gt;scalar&lt;/b&gt; can hold, not to be confused with an &lt;b&gt;IV&lt;/b&gt;.</source>
          <target state="translated">네바다의 약자이며 그 어느 부분도 문명과 혼동되지 않습니다. NV는 또한 &lt;b&gt;스칼라&lt;/b&gt; 가 보유 할 수 있는 유형의 내부 부동 소수점 숫자 값을 의미 하며 &lt;b&gt;IV&lt;/b&gt; 와 혼동하지 않아야합니다 .</target>
        </trans-unit>
        <trans-unit id="753c68d3ba41db74e4df8914f2ce920431708ec4" translate="yes" xml:space="preserve">
          <source>Short for Transmission Control Protocol. A protocol wrapped around the Internet Protocol to make an unreliable packet transmission mechanism appear to the application program to be a reliable &lt;b&gt;stream&lt;/b&gt; of bytes. (Usually.)</source>
          <target state="translated">전송 제어 프로토콜의 약자. 신뢰할 수없는 패킷 전송 메커니즘이 응용 프로그램에 신뢰할 수있는 바이트 &lt;b&gt;스트림&lt;/b&gt; 인 것처럼 보이도록 인터넷 프로토콜을 감싸는 프로토콜 입니다. (보통.)</target>
        </trans-unit>
        <trans-unit id="dc5ee68c69bf44299748c4c256b80c120fb271e9" translate="yes" xml:space="preserve">
          <source>Short for a &amp;ldquo;hash value&amp;rdquo; typedef, which holds Perl&amp;rsquo;s internal representation of a hash. The &lt;code&gt;HV&lt;/code&gt; type is a subclass of &lt;b&gt;SV&lt;/b&gt;.</source>
          <target state="translated">&quot;해시 값&quot;typedef의 약자로, Perl의 내부 해시 표현을 보유합니다. &lt;code&gt;HV&lt;/code&gt; 의 유형의 서브 클래스입니다 &lt;b&gt;SV&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="641d12dc5680debd9252f30257e835d77f2b58b5" translate="yes" xml:space="preserve">
          <source>Short for a &amp;ldquo;terminal&amp;rdquo;&amp;mdash;that is, a leaf node of a &lt;b&gt;syntax tree&lt;/b&gt;. A thing that functions grammatically as an &lt;b&gt;operand&lt;/b&gt; for the operators in an expression.</source>
          <target state="translated">&quot;터미널&quot;의 약어, 즉 &lt;b&gt;구문 트리&lt;/b&gt; 의 리프 노드입니다 . 표현식에서 연산자 의 &lt;b&gt;피연산자&lt;/b&gt; 로 문법적으로 기능하는 것입니다 .</target>
        </trans-unit>
        <trans-unit id="2a34ff2be32b26b7b9b0b3b4f346552a9899d102" translate="yes" xml:space="preserve">
          <source>Short for one member of &lt;b&gt;Perl mongers&lt;/b&gt;, a purveyor of Perl.</source>
          <target state="translated">&lt;b&gt;Perl&lt;/b&gt; 의 공급 업체 인 Perl &lt;b&gt;mongers&lt;/b&gt; 의 한 멤버의 &lt;b&gt;약자&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="215e423928369d110ed59f1768219b3b38101a83" translate="yes" xml:space="preserve">
          <source>Short integers. This is equivalent to T_IV but explicitly casts the return to type &lt;code&gt;short&lt;/code&gt; . The default typemap for &lt;code&gt;short&lt;/code&gt; is T_IV.</source>
          <target state="translated">짧은 정수. 이것은 T_IV와 동일하지만 리턴 값을 &lt;code&gt;short&lt;/code&gt; 유형으로 명시 적으로 캐스트합니다 . &lt;code&gt;short&lt;/code&gt; 의 기본 유형 맵 은 T_IV입니다.</target>
        </trans-unit>
        <trans-unit id="12e34708f98b55fcfa0df10d0541bdc76b04003d" translate="yes" xml:space="preserve">
          <source>Short integers. This is equivalent to T_IV but explicitly casts the return to type &lt;code&gt;short&lt;/code&gt;. The default typemap for &lt;code&gt;short&lt;/code&gt; is T_IV.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e173f44ce033e23615a07008598ed98e0724ec82" translate="yes" xml:space="preserve">
          <source>Short of loading the file into a database or pre-indexing the lines in the file, there are a couple of things that you can do.</source>
          <target state="translated">파일을 데이터베이스에로드하거나 파일의 행을 사전 인덱싱하지 않으면 몇 가지 작업을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="84208312087b060594b7b3ab194603ca9b48cd14" translate="yes" xml:space="preserve">
          <source>Short string (usually 10 characters or less, not enforced, but may be truncated by renderers) categorizing the amnesty.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="342f19ffca54484d831bc22d60422377cb72128f" translate="yes" xml:space="preserve">
          <source>Short summary: You need to create a package that defines four methods:</source>
          <target state="translated">간단한 요약 : 네 가지 방법을 정의하는 패키지를 만들어야합니다.</target>
        </trans-unit>
        <trans-unit id="7d0c4499cb9c122a7211725e510477fa79e82bb6" translate="yes" xml:space="preserve">
          <source>Short tag to categorize the error. This is usually 10 characters or less, formatters may truncate longer tags.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5092f6331f83cfc30c23eb79579783db3e8793f1" translate="yes" xml:space="preserve">
          <source>Short tag to categorize the info. This is usually 10 characters or less, formatters may truncate longer tags.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1b21662873145e63208c0c220c63eecf3382545" translate="yes" xml:space="preserve">
          <source>Short tests may produce negative figures because perl can appear to take longer to execute the empty loop than a short test; try:</source>
          <target state="translated">펄은 짧은 테스트보다 빈 루프를 실행하는 데 더 오래 걸리는 것처럼 보일 수 있으므로 짧은 테스트는 음의 수치를 생성 할 수 있습니다. 시험:</target>
        </trans-unit>
        <trans-unit id="3c291d239a5572586d5800f8940e243040b2c7b5" translate="yes" xml:space="preserve">
          <source>Shortcomings of Perl under AmigaOS</source>
          <target state="translated">AmigaOS에서 Perl의 단점</target>
        </trans-unit>
        <trans-unit id="fa78e77c849e3197f1c80d2dbbfe4db374f3b001" translate="yes" xml:space="preserve">
          <source>Shortcomings of Perl under DOS</source>
          <target state="translated">DOS에서 Perl의 단점</target>
        </trans-unit>
        <trans-unit id="a84b9d9cc1ba4235d4b9a38a4443bc225f0a9d86" translate="yes" xml:space="preserve">
          <source>Should I do anything special if I call perl from multiple threads?</source>
          <target state="translated">여러 스레드에서 perl을 호출하면 특별한 작업을 수행해야합니까?</target>
        </trans-unit>
        <trans-unit id="41623a0ef32a13c7058b74719f5d1256441b7302" translate="yes" xml:space="preserve">
          <source>Should I use a web framework?</source>
          <target state="translated">웹 프레임 워크를 사용해야합니까?</target>
        </trans-unit>
        <trans-unit id="706821549d14c573be320aadd1615ad49253a11a" translate="yes" xml:space="preserve">
          <source>Should a user have the need for compiling Perl in the LP64 environment, use the -Duse64bitall flag to Configure. This will force Perl to be compiled in a pure LP64 environment (with the +DD64 flag for HP C-ANSI-C, with no additional options for GNU gcc 64-bit on PA-RISC, and with -mlp64 for GNU gcc on Itanium). If you want to compile Perl using gcc, you will have to get a version of the compiler that supports 64-bit operations.)</source>
          <target state="translated">LP64 환경에서 Perl을 컴파일해야하는 경우 -Duse64bitall 플래그를 사용하여 구성하십시오. 이렇게하면 Perl이 순수한 LP64 환경 (PA-RISC의 GNU gcc 64 비트에 대한 추가 옵션이없고 Itanium의 GNU gcc에 대한 -mlp64가없는 HP C-ANSI-C의 경우 + DD64 플래그)에서 컴파일됩니다. ). gcc를 사용하여 Perl을 컴파일하려면 64 비트 연산을 지원하는 컴파일러 버전을 가져와야합니다.)</target>
        </trans-unit>
        <trans-unit id="efca6f20e60abb6462f2115cc6f4f778b3e904aa" translate="yes" xml:space="preserve">
          <source>Should an &lt;code&gt;ok()&lt;/code&gt; fail, it will produce some diagnostics:</source>
          <target state="translated">해야 &lt;code&gt;ok()&lt;/code&gt; 는 몇 가지 진단을 생산할 예정 실패 :</target>
        </trans-unit>
        <trans-unit id="6ed2a6a9606e8c4524e86ab5840b45b4bc37bfbb" translate="yes" xml:space="preserve">
          <source>Should be true if this event should result in a test count increment.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7aa2401927f1002b79d1cf0dcfbafc98b85b5c42" translate="yes" xml:space="preserve">
          <source>Should be used if the perl library is moved from the default location in preference to &lt;code&gt;PERL(5)LIB&lt;/code&gt;, since this would not leave wrong entries in @INC. For example, if the compiled version of perl looks for @INC in</source>
          <target state="translated">@INC에 잘못된 항목이 남지 않으므로 perl 라이브러리가 환경 설정의 기본 위치에서 &lt;code&gt;PERL(5)LIB&lt;/code&gt; 로 이동 된 경우 사용해야합니다 . 예를 들어, 컴파일 된 버전의 perl이 @INC를 찾는 경우</target>
        </trans-unit>
        <trans-unit id="56e9538fa48dc5397d7704d11be1b316f1409e45" translate="yes" xml:space="preserve">
          <source>Should make stream's state consistent with layers below. That is, any buffered write data should be written, and file position of lower layers adjusted for data read from below but not actually consumed. (Should perhaps &lt;code&gt;Unread()&lt;/code&gt; such data to the lower layer.)</source>
          <target state="translated">스트림 상태를 아래 레이어와 일치시켜야합니다. 즉, 버퍼링 된 쓰기 데이터를 작성하고 하위 계층의 파일 위치는 아래에서 읽은 데이터에 맞게 조정되지만 실제로 소비되지는 않습니다. (아마도 이러한 데이터를 &lt;code&gt;Unread()&lt;/code&gt; 하위 계층으로 보내야합니다.)</target>
        </trans-unit>
        <trans-unit id="1c3d2c3d146bd37267ff2248c2cd5e844253f599" translate="yes" xml:space="preserve">
          <source>Should not be set with newer Perls, since this may hide some</source>
          <target state="translated">최신 Perls로 설정하면 안됩니다.</target>
        </trans-unit>
        <trans-unit id="ed8ff1c4976aa7b4301ba319829b15d5951b2c6e" translate="yes" xml:space="preserve">
          <source>Should probably be built into the core, and needs to stop pandering to DOS habits. Needs a dose of optimization too.</source>
          <target state="translated">아마도 코어에 내장되어 있어야하며 DOS 습관으로 넘어가는 것을 중단해야합니다. 최적화도 필요합니다.</target>
        </trans-unit>
        <trans-unit id="fbde5e966385ab1512ea67e3f35d08dd24d83ceb" translate="yes" xml:space="preserve">
          <source>Should return 0 on success, -1 on error. Optional.</source>
          <target state="translated">성공하면 0을, 에러이면 -1을 반환합니다. 선택 과목.</target>
        </trans-unit>
        <trans-unit id="f8c399f86acf033efef1e2751ef404b5ddaa2865" translate="yes" xml:space="preserve">
          <source>Should return 0 on success, -1 on error. Optional. Default is to fail, but that is likely to be changed in future.</source>
          <target state="translated">성공하면 0을, 에러이면 -1을 반환합니다. 선택 과목. 기본값은 실패이지만 향후 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="246758221cfd3e60868d6718c892fa1bb87177ab" translate="yes" xml:space="preserve">
          <source>Should return a string to be placed in the buffer. Optional. If not provided, must provide READ or reject handles open for reading in PUSHED.</source>
          <target state="translated">버퍼에 배치 할 문자열을 반환해야합니다. 선택 과목. 제공되지 않은 경우 PUSHED로 읽을 수 있도록 READ 또는 거부 핸들을 열어야합니다.</target>
        </trans-unit>
        <trans-unit id="d3cbfd0fcf4f24975313de4df8de49164d7ee2fd" translate="yes" xml:space="preserve">
          <source>Should return an object or the class, or -1 on failure. (Compare TIEHANDLE.) The arguments are an optional mode string (&quot;r&quot;, &quot;w&quot;, &quot;w+&quot;, ...) and a filehandle for the PerlIO layer below. Mandatory.</source>
          <target state="translated">객체 또는 클래스를 반환하거나 실패시 -1을 반환해야합니다. (TIEHANDLE 비교) 인수는 선택적 모드 문자열 ( &quot;r&quot;, &quot;w&quot;, &quot;w +&quot;, ...)이며 아래 PerlIO 레이어의 파일 핸들입니다. 필수.</target>
        </trans-unit>
        <trans-unit id="5642f34ce9dcd1c3ffa2dfc0c58640c6cb31044d" translate="yes" xml:space="preserve">
          <source>Should the $prefix fail to match</source>
          <target state="translated">$ prefix가 일치하지 않는 경우</target>
        </trans-unit>
        <trans-unit id="1690346ded0caeaa5dcdd766cbbfd423effb3884" translate="yes" xml:space="preserve">
          <source>Should yield no problems with AIX 5.1 / 5.2 / 5.3 / 6.1 / 7.1.</source>
          <target state="translated">AIX 5.1 / 5.2 / 5.3 / 6.1 / 7.1에서 문제가 발생하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="377f03a2a4c9b170d5d73c84fdd0fa6c29b00142" translate="yes" xml:space="preserve">
          <source>Should yield no problems.</source>
          <target state="translated">아무 문제가 없습니다.</target>
        </trans-unit>
        <trans-unit id="35f86593f3a7cab63ebec9bff3335371662e4b80" translate="yes" xml:space="preserve">
          <source>Should you be stuck with an ancient version of git (prior to 1.7), then &lt;code&gt;git push&lt;/code&gt; will not have the &lt;code&gt;-u&lt;/code&gt; switch, and you have to replace the last step with the following sequence:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b16df946245605727ff1e16d4791f2bf174400d" translate="yes" xml:space="preserve">
          <source>Should you wish to build a statically-linked executable on a system which can dynamically load libraries, you may, in all the following examples, where the command &quot;&lt;code&gt;make&lt;/code&gt; &quot; with no arguments is executed, run the command &quot;&lt;code&gt;make perl&lt;/code&gt; &quot; instead.</source>
          <target state="translated">라이브러리를 동적으로로드 할 수있는 시스템에 정적으로 링크 된 실행 파일을 빌드하려면 다음 예제에서 인수없이 &quot; &lt;code&gt;make&lt;/code&gt; &quot; 명령 이 실행되는 대신 &quot; &lt;code&gt;make perl&lt;/code&gt; &quot; 명령을 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="398654e660729596cb8454b7f800d571ef53f379" translate="yes" xml:space="preserve">
          <source>Should you wish to build a statically-linked executable on a system which can dynamically load libraries, you may, in all the following examples, where the command &quot;&lt;code&gt;make&lt;/code&gt;&quot; with no arguments is executed, run the command &quot;&lt;code&gt;make perl&lt;/code&gt;&quot; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ad198af5ed254b36c0129bab30cb66de4af9306" translate="yes" xml:space="preserve">
          <source>Show all individual modules that have a $VERSION of zero?</source>
          <target state="translated">$ VERSION이 0 인 모든 개별 모듈을 표시 하시겠습니까?</target>
        </trans-unit>
        <trans-unit id="5886e6a19b112ccca7d7e5c6a420d33f7dc320f4" translate="yes" xml:space="preserve">
          <source>Show all individual modules that have no $VERSION?</source>
          <target state="translated">$ VERSION이없는 모든 개별 모듈을 표시 하시겠습니까?</target>
        </trans-unit>
        <trans-unit id="432657faf9897211c68f4ccc299c680506ae0f85" translate="yes" xml:space="preserve">
          <source>Show lexical variables used in functions or files</source>
          <target state="translated">함수 또는 파일에 사용 된 어휘 변수 표시</target>
        </trans-unit>
        <trans-unit id="15563729135e9ba264fbcba30a709d66c8a1dd93" translate="yes" xml:space="preserve">
          <source>Show test comments (this is a no-op if &lt;code&gt;verbose&lt;/code&gt; is selected).</source>
          <target state="translated">테스트 설명 표시 ( &lt;code&gt;verbose&lt;/code&gt; 을 선택한 경우에는 작동하지 않습니다 ).</target>
        </trans-unit>
        <trans-unit id="453672f22864e2ecabd52010a0251f21457a02b2" translate="yes" xml:space="preserve">
          <source>Show test failures (this is a no-op if &lt;code&gt;verbose&lt;/code&gt; is selected).</source>
          <target state="translated">테스트 실패 표시 ( &lt;code&gt;verbose&lt;/code&gt; 를 선택한 경우에는 작동하지 않습니다 ).</target>
        </trans-unit>
        <trans-unit id="25af3a88c3b3773349dd8ac90b045308d5492ec5" translate="yes" xml:space="preserve">
          <source>Show the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07ccbb891469b1a972be7b689b1ec1c7304ecb2a" translate="yes" xml:space="preserve">
          <source>Show the module details. This prints one line for each out-of-date module (meaning, modules locally installed but have newer versions on CPAN). Each line has three columns: module name, local version, and CPAN version.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bad96a4d0e92d1a92a25032d1a69981cb8c4094d" translate="yes" xml:space="preserve">
          <source>Show the out-of-date modules.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3deb58d49160799c00454338107f604ea794ed5" translate="yes" xml:space="preserve">
          <source>Show usage.</source>
          <target state="translated">사용법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="7222550b5b66397acb151415418533c6a8f6f5fe" translate="yes" xml:space="preserve">
          <source>ShowMode</source>
          <target state="translated">ShowMode</target>
        </trans-unit>
        <trans-unit id="66970db782112b1077801cd655daa3c67c2cdecf" translate="yes" xml:space="preserve">
          <source>Shows if the given module is primarily maintained in perl core or on CPAN and bug tracker URL.</source>
          <target state="translated">주어진 모듈이 주로 perl 코어 또는 CPAN 및 버그 추적기 URL에서 유지 보수되는지 표시합니다.</target>
        </trans-unit>
        <trans-unit id="ab7d18eafb7bcc2a74ee000087e57646aecc2b0d" translate="yes" xml:space="preserve">
          <source>Shows the primary maintainers for the specified modules.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11a820735e69e06ccea6cc9de4ba8697b78a4549" translate="yes" xml:space="preserve">
          <source>Shuts down a Perl interpreter. See &lt;a href=&quot;perlembed&quot;&gt;perlembed&lt;/a&gt; for a tutorial.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac75e459283e311c2d85839794c7648cec7df9c2" translate="yes" xml:space="preserve">
          <source>Shuts down a Perl interpreter. See &lt;a href=&quot;perlembed&quot;&gt;perlembed&lt;/a&gt;.</source>
          <target state="translated">Perl 인터프리터를 종료합니다. &lt;a href=&quot;perlembed&quot;&gt;perlembed를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="90e62e13ea37ff3f7a2ddce5609c724fd7e64daf" translate="yes" xml:space="preserve">
          <source>Shuts down a socket connection in the manner indicated by HOW, which has the same interpretation as in the syscall of the same name.</source>
          <target state="translated">HOW로 표시된 방식으로 소켓 연결을 종료합니다. 이는 동일한 이름의 syscall에서와 동일한 해석을 갖습니다.</target>
        </trans-unit>
        <trans-unit id="7187637d0f34c57d8bea4681c13bb60273e1f7d1" translate="yes" xml:space="preserve">
          <source>Shuts down a socket connection in the manner indicated by the value passed in, which has the same interpretation as in the syscall of the same name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de95fa319fad54d4fda1efff03c4320b4f1bbba0" translate="yes" xml:space="preserve">
          <source>Shutsdown the specified MACHINE, notifying users with the supplied MESSAGE, within the specified TIMEOUT interval. Forces closing of all documents without prompting the user if FORCECLOSE is true, and reboots the machine if REBOOT is true. This function works only on WinNT.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b3d8d665a765918b70a3f5f0378d51df00b92dd" translate="yes" xml:space="preserve">
          <source>Sign</source>
          <target state="translated">Sign</target>
        </trans-unit>
        <trans-unit id="27bed13a88c60350c3de92ec3820e1cc4f7d6ec3" translate="yes" xml:space="preserve">
          <source>Signal</source>
          <target state="translated">Signal</target>
        </trans-unit>
        <trans-unit id="76e3a47c3cea2b4bc39210e8f1a7a4f458325f46" translate="yes" xml:space="preserve">
          <source>Signal flag. Will be set to a true value if a signal was caught. Clients may check for this flag to abort time-consuming operations.</source>
          <target state="translated">신호 플래그. 신호가 잡히면 참값으로 설정됩니다. 클라이언트는 시간이 많이 걸리는 작업을 중단하기 위해이 플래그를 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="47e8409eab6e54647df4cb7cecc41ee28c30a02b" translate="yes" xml:space="preserve">
          <source>Signal handlers deal with signal names, not numbers. Use &lt;code&gt;&lt;a href=&quot;functions/kill&quot;&gt;kill&lt;/a&gt; -l&lt;/code&gt; to find their names on your system.</source>
          <target state="translated">신호 처리기는 숫자가 아닌 신호 이름을 처리합니다. &lt;code&gt;&lt;a href=&quot;functions/kill&quot;&gt;kill&lt;/a&gt; -l&lt;/code&gt; 을 사용 하여 시스템에서 이름을 찾으십시오.</target>
        </trans-unit>
        <trans-unit id="f793004ac2bfb867d7b8c1fed8ccaa1370121adc" translate="yes" xml:space="preserve">
          <source>Signal handlers deal with signal names, not numbers. Use &lt;code&gt;kill -l&lt;/code&gt; to find their names on your system.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a89722759e06611996072c09d8d893f78366be03" translate="yes" xml:space="preserve">
          <source>Signal handlers need to be set up in the threads for the signals they are expected to act upon. Here's an example for</source>
          <target state="translated">신호 처리기는 스레드에서 처리 될 것으로 예상되는 신호에 대해 설정해야합니다. 다음은 예입니다</target>
        </trans-unit>
        <trans-unit id="4c81c67cfc40c99d8beeb124cd5a299ed53f7fa3" translate="yes" xml:space="preserve">
          <source>Signal handling is also used for timeouts in Unix. While safely protected within an &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval{}&lt;/a&gt;&lt;/code&gt; block, you set a signal handler to trap alarm signals and then schedule to have one delivered to you in some number of seconds. Then try your blocking operation, clearing the alarm when it's done but not before you've exited your &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval{}&lt;/a&gt;&lt;/code&gt; block. If it goes off, you'll use die() to jump out of the block.</source>
          <target state="translated">신호 처리는 Unix의 타임 아웃에도 사용됩니다. &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval{}&lt;/a&gt;&lt;/code&gt; 블록 내에서 안전하게 보호되는 동안 , 신호 처리기를 설정하여 경보 신호를 포착 한 다음 몇 초 안에 신호를 전달하도록 예약합니다. 그런 다음 차단 작업을 시도하여 완료되면 경보를 지우고 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval{}&lt;/a&gt;&lt;/code&gt; 블록을 종료하기 전에 경보를 해제하십시오 . 꺼지면 die ()를 사용하여 블록을 뛰어 넘습니다.</target>
        </trans-unit>
        <trans-unit id="d4984dbb18bb8f6d69231c1c5402b289b6cae3fd" translate="yes" xml:space="preserve">
          <source>Signal handling is also used for timeouts in Unix. While safely protected within an &lt;code&gt;eval{}&lt;/code&gt; block, you set a signal handler to trap alarm signals and then schedule to have one delivered to you in some number of seconds. Then try your blocking operation, clearing the alarm when it's done but not before you've exited your &lt;code&gt;eval{}&lt;/code&gt; block. If it goes off, you'll use die() to jump out of the block.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c9cd055a7cd87b137130bb8b93c1c2e53904764f" translate="yes" xml:space="preserve">
          <source>Signal handling may not behave as on Unix platforms (where it doesn't exactly &quot;behave&quot;, either :). For instance, calling &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die()&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit()&lt;/a&gt;&lt;/code&gt; from signal handlers will cause an exception, since most implementations of &lt;code&gt;signal()&lt;/code&gt; on Windows are severely crippled. Thus, signals may work only for simple things like setting a flag variable in the handler. Using signals under this port should currently be considered unsupported.</source>
          <target state="translated">신호 처리는 Unix 플랫폼에서와 같이 작동하지 않을 수 있습니다 (정확히 &quot;동작&quot;하지 않는 경우). 예를 들어, 신호 처리기에서 &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die()&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit()&lt;/a&gt;&lt;/code&gt; 를 호출 하면 예외가 발생합니다 . Windows에서 대부분의 &lt;code&gt;signal()&lt;/code&gt; 구현 은 심각하게 손상 되기 때문 입니다. 따라서 신호는 처리기에서 플래그 변수를 설정하는 것과 같은 간단한 작업에만 작동 할 수 있습니다. 이 포트에서 신호를 사용하는 것은 현재 지원되지 않는 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="a87648f8ff8510d519181cee20c22a292d601e89" translate="yes" xml:space="preserve">
          <source>Signal handling may not behave as on Unix platforms (where it doesn't exactly &quot;behave&quot;, either :). For instance, calling &lt;code&gt;die()&lt;/code&gt; or &lt;code&gt;exit()&lt;/code&gt; from signal handlers will cause an exception, since most implementations of &lt;code&gt;signal()&lt;/code&gt; on Windows are severely crippled. Thus, signals may work only for simple things like setting a flag variable in the handler. Using signals under this port should currently be considered unsupported.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e6c417fd537a17b001daa7dbea3a3b50cef51ef" translate="yes" xml:space="preserve">
          <source>Signal number zero may fail because you lack permission to send the signal when directed at a process whose real or saved UID is not identical to the real or effective UID of the sending process, even though the process is alive. You may be able to determine the cause of failure using &lt;code&gt;$!&lt;/code&gt; or &lt;code&gt;%!&lt;/code&gt; .</source>
          <target state="translated">실제 또는 저장된 UID가 전송 프로세스의 실제 또는 유효 UID와 동일하지 않은 프로세스를 지시 할 때 신호가 전송 될 수있는 권한이 없기 때문에 신호 번호 0이 실패 할 수 있습니다. &lt;code&gt;$!&lt;/code&gt; 를 사용하여 실패 원인을 판별 할 수 있습니다 . 또는 &lt;code&gt;%!&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2252f0feffa6900d113f918d18d91c133bf55365" translate="yes" xml:space="preserve">
          <source>Signal number zero may fail because you lack permission to send the signal when directed at a process whose real or saved UID is not identical to the real or effective UID of the sending process, even though the process is alive. You may be able to determine the cause of failure using &lt;code&gt;$!&lt;/code&gt; or &lt;code&gt;%!&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2346a18ea3002ff04eca3a130c7f40e65c56f0c9" translate="yes" xml:space="preserve">
          <source>Signals</source>
          <target state="translated">Signals</target>
        </trans-unit>
        <trans-unit id="fec07adfbf089fdf5b54412a5f3085422a9dd0ae" translate="yes" xml:space="preserve">
          <source>Signals are</source>
          <target state="translated">신호는</target>
        </trans-unit>
        <trans-unit id="fe837ae8c05b966bdccbee31fe8ed0fe5d881059" translate="yes" xml:space="preserve">
          <source>Signals as &quot;faults&quot;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43861fb85280c34c4b0e58573e896842254a1d10" translate="yes" xml:space="preserve">
          <source>Signals in Plan 9 Perl</source>
          <target state="translated">Plan 9 Perl의 신호</target>
        </trans-unit>
        <trans-unit id="259b4915ff9abfbb2a728a264509dffb23aed5c4" translate="yes" xml:space="preserve">
          <source>Signals that are intercepted:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e2f061cd789264d5433118e03b134a8734af9d2" translate="yes" xml:space="preserve">
          <source>Signals triggered by operating system state</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4cf0392296064579858651f856889aadbc2805e" translate="yes" xml:space="preserve">
          <source>Signatures</source>
          <target state="translated">Signatures</target>
        </trans-unit>
        <trans-unit id="d9d7c542958055b1904998cdb447122ec36a75ab" translate="yes" xml:space="preserve">
          <source>Signed bitwise operators.</source>
          <target state="translated">부호있는 비트 연산자.</target>
        </trans-unit>
        <trans-unit id="2622f509b356185fe6a42f6313ddbc8e57057af2" translate="yes" xml:space="preserve">
          <source>Significant performance improvements</source>
          <target state="translated">상당한 성능 향상</target>
        </trans-unit>
        <trans-unit id="ae6207f79c10c58b3e0ef4c08bbf6c86acc82fd9" translate="yes" xml:space="preserve">
          <source>Signum function. Set the number to -1, 0, or 1, depending on whether the number is negative, zero, or positive, respectively. Does not modify NaNs.</source>
          <target state="translated">부호 기능. 숫자가 각각 음수인지, 0인지, 양수인지에 따라 숫자를 -1, 0 또는 1로 설정하십시오. NaN을 수정하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="31506097adfa948440134c0119e5a52038393445" translate="yes" xml:space="preserve">
          <source>Silberschatz, Abraham, and Peter B. Galvin. Operating System Concepts, 4th ed. Addison-Wesley, 1995, ISBN 0-201-59292-4</source>
          <target state="translated">Silberschatz, Abraham, Peter B. Galvin. 운영 체제 개념, 제 4 판. 애디슨-웨슬리, 1995, ISBN 0-201-59292-4</target>
        </trans-unit>
        <trans-unit id="c1200bf449b67efb756e3194a25dcba2a224c7bd" translate="yes" xml:space="preserve">
          <source>Similar in functionality to &lt;a href=&quot;perlfunc#recv&quot;&gt;&quot;recv&quot; in perlfunc&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ebf91ecf8b9db2d36c3c4af1dda8c5294da5403f" translate="yes" xml:space="preserve">
          <source>Similar in functionality to &lt;a href=&quot;perlfunc#send&quot;&gt;&quot;send&quot; in perlfunc&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c4b469b48eb970781d347cff775a6eb6ed07b9c" translate="yes" xml:space="preserve">
          <source>Similar problems can occur when storing &lt;code&gt;&amp;amp;PL_sv_undef&lt;/code&gt; in HVs:</source>
          <target state="translated">HV에 &lt;code&gt;&amp;amp;PL_sv_undef&lt;/code&gt; 를 저장할 때 비슷한 문제가 발생할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0939c3fe5c0d5d2bff40d1b5db20a06321bba976" translate="yes" xml:space="preserve">
          <source>Similar to</source>
          <target state="translated">비슷하다</target>
        </trans-unit>
        <trans-unit id="ca29a7deeeb800f3b647ae8e447ace2495bd48e6" translate="yes" xml:space="preserve">
          <source>Similar to &quot;CHECK&quot;, but for &lt;code&gt;INIT&lt;/code&gt; -blocks, not &lt;code&gt;CHECK&lt;/code&gt; blocks.</source>
          <target state="translated">&quot;CHECK&quot;와 유사하지만 &lt;code&gt;INIT&lt;/code&gt; &lt;code&gt;CHECK&lt;/code&gt; 블록이 아닌 -blocks와 .</target>
        </trans-unit>
        <trans-unit id="f5ec53f333f04a2995b3e086134767c778243eaa" translate="yes" xml:space="preserve">
          <source>Similar to &quot;CHECK&quot;, but for &lt;code&gt;INIT&lt;/code&gt;-blocks, not &lt;code&gt;CHECK&lt;/code&gt; blocks.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a02dc2c9e4fd99225658784381bc57431376c4f2" translate="yes" xml:space="preserve">
          <source>Similar to $io-&amp;gt;seek, but sets the IO::File's position using the system call lseek(2) directly, so will confuse most perl IO operators except sysread and syswrite (see &lt;a href=&quot;../perlfunc&quot;&gt;perlfunc&lt;/a&gt; for full details)</source>
          <target state="translated">$ io-&amp;gt; seek와 비슷하지만 lseek (2) 시스템 호출을 사용하여 IO :: File의 위치를 ​​직접 설정하므로 sysread 및 syswrite를 제외한 대부분의 perl IO 연산자를 혼동합니다 (참조 &lt;a href=&quot;../perlfunc&quot;&gt; perlfunc&lt;/a&gt; 참조)</target>
        </trans-unit>
        <trans-unit id="68c4347f8fea5b416312257ca34ba342de4d10b9" translate="yes" xml:space="preserve">
          <source>Similar to $io-&amp;gt;seek, but sets the IO::File's position using the system call lseek(2) directly, so will confuse most perl IO operators except sysread and syswrite (see &lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt; for full details)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54a39eaf579340710bf4bd0f530bd675ee9e7a95" translate="yes" xml:space="preserve">
          <source>Similar to &lt;a href=&quot;#any&quot;&gt;&quot;any&quot;&lt;/a&gt; and &lt;a href=&quot;#all&quot;&gt;&quot;all&quot;&lt;/a&gt;, but with the return sense inverted. &lt;code&gt;none&lt;/code&gt; returns true only if no value in the &lt;code&gt;@list&lt;/code&gt; causes the &lt;code&gt;BLOCK&lt;/code&gt; to return true, and &lt;code&gt;notall&lt;/code&gt; returns true only if not all of the values do.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48998732d2d944be662f876c6215817f6203f325" translate="yes" xml:space="preserve">
          <source>Similar to &lt;a href=&quot;#any&quot;&gt;&quot;any&quot;&lt;/a&gt;, except that it requires all elements of the &lt;code&gt;@list&lt;/code&gt; to make the &lt;code&gt;BLOCK&lt;/code&gt; return true. If any element returns false, then it returns false. If the &lt;code&gt;BLOCK&lt;/code&gt; never returns false or the &lt;code&gt;@list&lt;/code&gt; was empty then it returns true.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aeabee18f75813e1d32d468eb7ba172bf546eaed" translate="yes" xml:space="preserve">
          <source>Similar to &lt;a href=&quot;#any&quot;&gt;any&lt;/a&gt; and &lt;a href=&quot;#all&quot;&gt;all&lt;/a&gt;, but with the return sense inverted. &lt;code&gt;none&lt;/code&gt; returns true only if no value in the &lt;code&gt;@list&lt;/code&gt; causes the &lt;code&gt;BLOCK&lt;/code&gt; to return true, and &lt;code&gt;notall&lt;/code&gt; returns true only if not all of the values do.</source>
          <target state="translated">마찬가지로 &lt;a href=&quot;#any&quot;&gt;어떤&lt;/a&gt; 및 &lt;a href=&quot;#all&quot;&gt;모든&lt;/a&gt; 하지만 반전 반환 감각. &lt;code&gt;none&lt;/code&gt; 의 값에만 true를 반환하지 &lt;code&gt;@list&lt;/code&gt; 이 원인없는 &lt;code&gt;BLOCK&lt;/code&gt; 을 true를 반환하고, &lt;code&gt;notall&lt;/code&gt; 사실 만 반환하지 않을 경우 모든 값은 않습니다.</target>
        </trans-unit>
        <trans-unit id="e0b3d2d208d62b5b40ff53db1e72a57e69459f20" translate="yes" xml:space="preserve">
          <source>Similar to &lt;a href=&quot;#any&quot;&gt;any&lt;/a&gt;, except that it requires all elements of the &lt;code&gt;@list&lt;/code&gt; to make the &lt;code&gt;BLOCK&lt;/code&gt; return true. If any element returns false, then it returns false. If the &lt;code&gt;BLOCK&lt;/code&gt; never returns false or the &lt;code&gt;@list&lt;/code&gt; was empty then it returns true.</source>
          <target state="translated">마찬가지로 &lt;a href=&quot;#any&quot;&gt;어떤&lt;/a&gt; , 그것은 모든 요소를 필요로한다는 점을 제외하고 &lt;code&gt;@list&lt;/code&gt; 을 하기 위해 &lt;code&gt;BLOCK&lt;/code&gt; 의 반환 사실. 어떤 요소가 false를 반환하면 false를 반환합니다. 는 IF &lt;code&gt;BLOCK&lt;/code&gt; 은 결코 반환 허위 또는 &lt;code&gt;@list&lt;/code&gt; 가 비어 그때는 true를 돌려줍니다.</target>
        </trans-unit>
        <trans-unit id="4be8eb83dc7372a8ceafe2d398607db21cbd0df8" translate="yes" xml:space="preserve">
          <source>Similar to &lt;a href=&quot;#max&quot;&gt;&quot;max&quot;&lt;/a&gt; but returns the entry in the list with the lowest numerical value. If the list is empty then &lt;code&gt;undef&lt;/code&gt; is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dfcb2ef3c4104f74e02c3a234af9ace81a7ab965" translate="yes" xml:space="preserve">
          <source>Similar to &lt;a href=&quot;#max&quot;&gt;&quot;max&quot;&lt;/a&gt;, but treats all the entries in the list as strings and returns the highest string as defined by the &lt;code&gt;gt&lt;/code&gt; operator. If the list is empty then &lt;code&gt;undef&lt;/code&gt; is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9665cd00110ac2a060c12898dd3b9d89a35f309" translate="yes" xml:space="preserve">
          <source>Similar to &lt;a href=&quot;#max&quot;&gt;max&lt;/a&gt; but returns the entry in the list with the lowest numerical value. If the list is empty then &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; is returned.</source>
          <target state="translated">&lt;a href=&quot;#max&quot;&gt;max&lt;/a&gt; 와 비슷 하지만 숫자 값이 가장 낮은 목록의 항목을 반환합니다. 목록이 비어 있으면 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="1acc3d00496e9a8972d2b21602c04ac03da5cacb" translate="yes" xml:space="preserve">
          <source>Similar to &lt;a href=&quot;#max&quot;&gt;max&lt;/a&gt;, but treats all the entries in the list as strings and returns the highest string as defined by the &lt;code&gt;gt&lt;/code&gt; operator. If the list is empty then &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; is returned.</source>
          <target state="translated">마찬가지로 &lt;a href=&quot;#max&quot;&gt;최대&lt;/a&gt; 문자열을 반환 가장 높은 문자열로 목록 만 취급하는 모든 항목은에 의해 정의 된 &lt;code&gt;gt&lt;/code&gt; 연산자입니다. 리스트가 비어 있으면 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="cfb0f506a775b443c104de0b0c91306a78f551b3" translate="yes" xml:space="preserve">
          <source>Similar to &lt;a href=&quot;#min&quot;&gt;&quot;min&quot;&lt;/a&gt;, but treats all the entries in the list as strings and returns the lowest string as defined by the &lt;code&gt;lt&lt;/code&gt; operator. If the list is empty then &lt;code&gt;undef&lt;/code&gt; is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a68b93abd1f3ba4015d6e167facf857ecad51b4" translate="yes" xml:space="preserve">
          <source>Similar to &lt;a href=&quot;#min&quot;&gt;min&lt;/a&gt;, but treats all the entries in the list as strings and returns the lowest string as defined by the &lt;code&gt;lt&lt;/code&gt; operator. If the list is empty then &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; is returned.</source>
          <target state="translated">유사 &lt;a href=&quot;#min&quot;&gt;분&lt;/a&gt; 문자열 복귀 최저 문자열로서리스트하지만, 취급하는 모든 항목은에 의해 정의 &lt;code&gt;lt&lt;/code&gt; 연산자. 목록이 비어 있으면 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="4ecb07a28c8b871910322942b1bd79e2ea6e867f" translate="yes" xml:space="preserve">
          <source>Similar to &lt;a href=&quot;#sum&quot;&gt;&quot;sum&quot;&lt;/a&gt;, except this returns 0 when given an empty list, rather than &lt;code&gt;undef&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="720744a95bf0e839c040c184fab6270aac42881d" translate="yes" xml:space="preserve">
          <source>Similar to &lt;a href=&quot;#sum&quot;&gt;sum&lt;/a&gt;, except this returns 0 when given an empty list, rather than &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 대신 빈 목록이 주어지면 0을 반환한다는 점을 제외하면 &lt;a href=&quot;#sum&quot;&gt;sum&lt;/a&gt; 과 비슷합니다. .</target>
        </trans-unit>
        <trans-unit id="de0c5d81a8f59f78025d72fb656f559ed47e0b02" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;%+&lt;/code&gt; , this variable allows access to the named capture groups in the last successful match in the currently active dynamic scope. To each capture group name found in the regular expression, it associates a reference to an array containing the list of values captured by all buffers with that name (should there be several of them), in the order where they appear.</source>
          <target state="translated">&lt;code&gt;%+&lt;/code&gt; 와 유사 와 변수를 사용하면 현재 활성화 된 동적 범위에서 마지막으로 성공적으로 일치하는 명명 된 캡처 그룹에 액세스 할 수 있습니다. 정규식에서 찾은 각 캡처 그룹 이름에, 모든 버퍼에 의해 캡처 된 값 목록이 포함 된 배열에 대한 참조를 해당 이름 (여러 개가 있어야 함)이 나타난 순서대로 연관시킵니다.</target>
        </trans-unit>
        <trans-unit id="fc5cb74e6a15c2726021f737c1b80fe548fe2cc2" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;%+&lt;/code&gt;, this variable allows access to the named capture groups in the last successful match in the currently active dynamic scope. To each capture group name found in the regular expression, it associates a reference to an array containing the list of values captured by all buffers with that name (should there be several of them), in the order where they appear.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc471f756f7e6a826fb6380627738dab038925d3" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;(??{ &lt;i&gt;code&lt;/i&gt; })&lt;/code&gt; except that it does not involve executing any code or potentially compiling a returned pattern string; instead it treats the part of the current pattern contained within a specified capture group as an independent pattern that must match at the current position. Also different is the treatment of capture buffers, unlike &lt;code&gt;(??{ &lt;i&gt;code&lt;/i&gt; })&lt;/code&gt; recursive patterns have access to their caller's match state, so one can use backreferences safely.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e85d1cf5a45c378c11b14a61c254003e40f86d06" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;(??{ code })&lt;/code&gt; except that it does not involve executing any code or potentially compiling a returned pattern string; instead it treats the part of the current pattern contained within a specified capture group as an independent pattern that must match at the current position. Also different is the treatment of capture buffers, unlike &lt;code&gt;(??{ code })&lt;/code&gt; recursive patterns have access to their callers match state, so one can use backreferences safely.</source>
          <target state="translated">&lt;code&gt;(??{ code })&lt;/code&gt; 실행하거나 잠재적으로 리턴 된 패턴 문자열을 컴파일하는 것을 포함하지 않는다는 점을 제외하고는 (?? {code}) 와 유사 합니다. 대신 지정된 캡처 그룹에 포함 된 현재 패턴의 일부를 현재 위치에서 일치해야하는 독립 패턴으로 처리합니다. 또한 캡처 버퍼 처리와는 달리 &lt;code&gt;(??{ code })&lt;/code&gt; 재귀 패턴이 발신자 일치 상태에 액세스 할 수있는 따라서 역 참조를 안전하게 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7b5e1028f59af1e35880841b72d98eb83a4ac03c" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;(R1)&lt;/code&gt; , this predicate checks to see if we're executing directly inside of the leftmost group with a given name (this is the same logic used by &lt;code&gt;(?&amp;amp;NAME)&lt;/code&gt; to disambiguate). It does not check the full stack, but only the name of the innermost active recursion.</source>
          <target state="translated">&lt;code&gt;(R1)&lt;/code&gt; 과 유사하게 ,이 술어는 주어진 이름으로 가장 왼쪽 그룹 내에서 직접 실행 중인지 확인합니다. &lt;code&gt;(?&amp;amp;NAME)&lt;/code&gt; 모호성)이다. 전체 스택을 확인하지 않고 가장 안쪽의 활성 재귀 이름 만 확인합니다.</target>
        </trans-unit>
        <trans-unit id="a58b4285d54a7974cddfaf2830c81dd7d35f40eb" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;(R1)&lt;/code&gt;, this predicate checks to see if we're executing directly inside of the leftmost group with a given name (this is the same logic used by &lt;code&gt;(?&amp;amp;&lt;i&gt;NAME&lt;/i&gt;)&lt;/code&gt; to disambiguate). It does not check the full stack, but only the name of the innermost active recursion. Full syntax: &lt;code&gt;(?(R&amp;amp;&lt;i&gt;name&lt;/i&gt;)&lt;i&gt;then&lt;/i&gt;|&lt;i&gt;else&lt;/i&gt;)&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d819c8539b4d29d94e8d4689944b0f7272e6c433" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;&lt;a href=&quot;../functions/grep&quot;&gt;grep&lt;/a&gt;&lt;/code&gt; in that it evaluates &lt;code&gt;BLOCK&lt;/code&gt; setting &lt;code&gt;$_&lt;/code&gt; to each element of &lt;code&gt;@list&lt;/code&gt; in turn. &lt;code&gt;any&lt;/code&gt; returns true if any element makes the &lt;code&gt;BLOCK&lt;/code&gt; return a true value. If &lt;code&gt;BLOCK&lt;/code&gt; never returns true or &lt;code&gt;@list&lt;/code&gt; was empty then it returns false.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../functions/grep&quot;&gt;grep&lt;/a&gt;&lt;/code&gt; 과 유사하게 &lt;code&gt;BLOCK&lt;/code&gt; 설정 &lt;code&gt;$_&lt;/code&gt; 을 &lt;code&gt;@list&lt;/code&gt; 의 각 요소 에 차례로 평가합니다. &lt;code&gt;any&lt;/code&gt; 요소라도 &lt;code&gt;BLOCK&lt;/code&gt; 이 참 값을 리턴하게하면 참을 리턴합니다. &lt;code&gt;BLOCK&lt;/code&gt; 이 true 또는 &lt;code&gt;@list&lt;/code&gt; 를 반환하지 않는 경우 비어 다음은 false를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="309f2e4aced8f70bc86983e34f644c5eeda43d60" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;&lt;a href=&quot;../functions/grep&quot;&gt;grep&lt;/a&gt;&lt;/code&gt; in that it evaluates &lt;code&gt;BLOCK&lt;/code&gt; setting &lt;code&gt;$_&lt;/code&gt; to each element of &lt;code&gt;@list&lt;/code&gt; in turn. &lt;code&gt;first&lt;/code&gt; returns the first element where the result from &lt;code&gt;BLOCK&lt;/code&gt; is a true value. If &lt;code&gt;BLOCK&lt;/code&gt; never returns true or &lt;code&gt;@list&lt;/code&gt; was empty then &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; is returned.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../functions/grep&quot;&gt;grep&lt;/a&gt;&lt;/code&gt; 과 유사하게 &lt;code&gt;BLOCK&lt;/code&gt; 설정 &lt;code&gt;$_&lt;/code&gt; 을 &lt;code&gt;@list&lt;/code&gt; 의 각 요소 에 차례로 평가합니다. &lt;code&gt;first&lt;/code&gt; 는 &lt;code&gt;BLOCK&lt;/code&gt; 의 결과 가 참 값인 첫 번째 요소를 리턴합니다 . 경우 &lt;code&gt;BLOCK&lt;/code&gt; 는 true를 돌려 결코 또는 &lt;code&gt;@list&lt;/code&gt; 는 다음 비어 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="1e075f217be25d05567036ad66b6856b5e68b562" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;@+&lt;/code&gt; , the &lt;code&gt;%+&lt;/code&gt; hash allows access to the named capture buffers, should they exist, in the last successful match in the currently active dynamic scope.</source>
          <target state="translated">&lt;code&gt;@+&lt;/code&gt; 와 유사하게 &lt;code&gt;%+&lt;/code&gt; 해시는 이름이 지정된 캡처 버퍼 (있는 경우)가 현재 활성화 된 동적 범위에서 마지막으로 성공적으로 일치 할 때 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c20f7b2090b36afe2f8cc1a28252ce82895a9532" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;@+&lt;/code&gt;, the &lt;code&gt;%+&lt;/code&gt; hash allows access to the named capture buffers, should they exist, in the last successful match in the currently active dynamic scope.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a8d5383c2abb4219427283869f7f92149d2a972c" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;Open&lt;/code&gt; , returns PerlIO* on success, &lt;code&gt;NULL&lt;/code&gt; on failure.</source>
          <target state="translated">&lt;code&gt;Open&lt;/code&gt; 과 유사하게 성공하면 PerlIO *를, 실패 하면 &lt;code&gt;NULL&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="1de2fbefa7ee02f134e1d332ea00e119a6f12731" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;Open&lt;/code&gt;, returns PerlIO* on success, &lt;code&gt;NULL&lt;/code&gt; on failure.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b9b990cdb77a226953210e003d5b8ec28f7e6d4" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;eq_array()&lt;/code&gt; , except the order of the elements is &lt;b&gt;not&lt;/b&gt; important. This is a deep check, but the irrelevancy of order only applies to the top level.</source>
          <target state="translated">&lt;code&gt;eq_array()&lt;/code&gt; 와 유사 하지만 요소의 순서는 중요 &lt;b&gt;하지 않습니다&lt;/b&gt; . 이것은 철저한 점검이지만 순서와 관련이없는 것은 최상위 레벨에만 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="c6f86f2d94dbcc71aafb977b9cc5434713d6b331" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;eq_array()&lt;/code&gt;, except the order of the elements is &lt;b&gt;not&lt;/b&gt; important. This is a deep check, but the irrelevancy of order only applies to the top level.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3701740d1ad6bfc649e15fd040627ffd1f305bbb" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;grep&lt;/code&gt; in that it evaluates &lt;code&gt;BLOCK&lt;/code&gt; setting &lt;code&gt;$_&lt;/code&gt; to each element of &lt;code&gt;@list&lt;/code&gt; in turn. &lt;code&gt;any&lt;/code&gt; returns true if any element makes the &lt;code&gt;BLOCK&lt;/code&gt; return a true value. If &lt;code&gt;BLOCK&lt;/code&gt; never returns true or &lt;code&gt;@list&lt;/code&gt; was empty then it returns false.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fbfbf42053ee4ef8969a4fa2ee7faff4e2fb6ee2" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;grep&lt;/code&gt; in that it evaluates &lt;code&gt;BLOCK&lt;/code&gt; setting &lt;code&gt;$_&lt;/code&gt; to each element of &lt;code&gt;@list&lt;/code&gt; in turn. &lt;code&gt;first&lt;/code&gt; returns the first element where the result from &lt;code&gt;BLOCK&lt;/code&gt; is a true value. If &lt;code&gt;BLOCK&lt;/code&gt; never returns true or &lt;code&gt;@list&lt;/code&gt; was empty then &lt;code&gt;undef&lt;/code&gt; is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="799cf1cf4afc49012909146223bfe3d0985a8027" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;htmlify()&lt;/code&gt; , but turns non-alphanumerics into underscores. Note that &lt;code&gt;anchorify()&lt;/code&gt; is not exported by default.</source>
          <target state="translated">&lt;code&gt;htmlify()&lt;/code&gt; 와 유사 하지만 영숫자가 아닌 문자를 밑줄로 바꿉니다. 참고 &lt;code&gt;anchorify()&lt;/code&gt; 기본적으로 내보내지지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c853c707bee9ff3b2aad37853128e372734e9e4d" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;htmlify()&lt;/code&gt;, but turns non-alphanumerics into underscores. Note that &lt;code&gt;anchorify()&lt;/code&gt; is not exported by default.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e12c5c9a9a0658e780b40222b20b1585f58ad997" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;is()&lt;/code&gt; , except that if $got and $expected are references, it does a deep comparison walking each data structure to see if they are equivalent. If the two structures are different, it will display the place where they start differing.</source>
          <target state="translated">$ got 및 $ expected가 참조 인 경우 &lt;code&gt;is()&lt;/code&gt; 와 유사하지만 각 데이터 구조가 동일한 지 확인하기 위해 각 데이터 구조를 자세히 비교합니다. 두 구조가 다른 경우 구조가 다른 곳을 표시합니다.</target>
        </trans-unit>
        <trans-unit id="5856aeb59fd6e40eddb32ad4b83e28afc3331a2a" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;is()&lt;/code&gt;, except that if $got and $expected are references, it does a deep comparison walking each data structure to see if they are equivalent. If the two structures are different, it will display the place where they start differing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78a60ea110d9d9e2f388b25322faf3b4d38a6a8c" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;list&lt;/code&gt; but only active groups that match the pattern are returned. &lt;code&gt;PATTERN&lt;/code&gt; can be a group pattern.</source>
          <target state="translated">마찬가지로 &lt;code&gt;list&lt;/code&gt; 패턴과 일치하지만, 활성 그룹이 반환됩니다. &lt;code&gt;PATTERN&lt;/code&gt; 은 그룹 패턴 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8394e4ee5f103a1c48fa6ce025d057e64f7170cc" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;lock_keys()&lt;/code&gt; , with the difference being that the optional key list specifies keys that may or may not be already in the hash. Essentially this is an easier way to say</source>
          <target state="translated">&lt;code&gt;lock_keys()&lt;/code&gt; 와 유사 하지만, 선택적 키 목록은 이미 해시에 있거나 없을 수있는 키를 지정한다는 점이 다릅니다. 본질적으로 이것은 말하기 쉬운 방법입니다</target>
        </trans-unit>
        <trans-unit id="fd28c174d303c48db24df8e8b11ae9ae4d26bc24" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;lock_keys()&lt;/code&gt;, with the difference being that the optional key list specifies keys that may or may not be already in the hash. Essentially this is an easier way to say</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ffb0fd1c6610a16c5e7d118e0a5ba89092c8069d" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;newUNOP&lt;/code&gt; , but creates an UNOP_AUX struct instead, with op_aux initialised to aux</source>
          <target state="translated">&lt;code&gt;newUNOP&lt;/code&gt; 와 유사 하지만 대신 op_aux가 aux로 초기화되어 UNOP_AUX 구조체가 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="5e858708a27caba519590b6fdb8853664bd94dce" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;newUNOP&lt;/code&gt;, but creates an &lt;code&gt;UNOP_AUX&lt;/code&gt; struct instead, with &lt;code&gt;op_aux&lt;/code&gt; initialised to &lt;code&gt;aux&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc376b4266acbbeb8358039fda2afe78067b9523" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;ok()&lt;/code&gt; , &lt;code&gt;is()&lt;/code&gt; and &lt;code&gt;isnt()&lt;/code&gt; compare their two arguments with &lt;code&gt;eq&lt;/code&gt; and &lt;code&gt;ne&lt;/code&gt; respectively and use the result of that to determine if the test succeeded or failed. So these:</source>
          <target state="translated">유사 &lt;code&gt;ok()&lt;/code&gt; , &lt;code&gt;is()&lt;/code&gt; 와 &lt;code&gt;isnt()&lt;/code&gt; 자신의 두 개의 인수를 비교 &lt;code&gt;eq&lt;/code&gt; 및 &lt;code&gt;ne&lt;/code&gt; 각각 시험 성공 또는 실패 여부를 결정하기 위해 그 결과를 사용합니다. 그래서 이것들 :</target>
        </trans-unit>
        <trans-unit id="2d613f276bedf9458ff8ce32e8990c5576137f0b" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;ok()&lt;/code&gt; , &lt;code&gt;like()&lt;/code&gt; matches $got against the regex &lt;code&gt;&lt;a href=&quot;../functions/qr&quot;&gt;qr/expected/&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">유사 &lt;code&gt;ok()&lt;/code&gt; , &lt;code&gt;like()&lt;/code&gt; 정규식에 대해 가지고 $ 일치 &lt;code&gt;&lt;a href=&quot;../functions/qr&quot;&gt;qr/expected/&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d80b81dd55578d43ab2dc56b52c4c8c56c375c2a" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;ok()&lt;/code&gt;, &lt;code&gt;is()&lt;/code&gt; and &lt;code&gt;isnt()&lt;/code&gt; compare their two arguments with &lt;code&gt;eq&lt;/code&gt; and &lt;code&gt;ne&lt;/code&gt; respectively and use the result of that to determine if the test succeeded or failed. So these:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b38f30f4277690cf45428e116cea438e779a9819" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;ok()&lt;/code&gt;, &lt;code&gt;like()&lt;/code&gt; matches $got against the regex &lt;code&gt;qr/expected/&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f443cdf5d4202dff7105c24c5a2b89e3df5ba0b" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;reduce&lt;/code&gt; except that it also returns the intermediate values along with the final result. As before, &lt;code&gt;$a&lt;/code&gt; is set to the first element of the given list, and the &lt;code&gt;BLOCK&lt;/code&gt; is then called once for remaining item in the list set into &lt;code&gt;$b&lt;/code&gt;, with the result being captured for return as well as becoming the new value for &lt;code&gt;$a&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="050d8bfd9d6dd81a6f8789b0e8d9cd7b8f6780b4" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;save_scalar&lt;/code&gt; , but localize &lt;code&gt;@gv&lt;/code&gt; and &lt;code&gt;%gv&lt;/code&gt; .</source>
          <target state="translated">유사 &lt;code&gt;save_scalar&lt;/code&gt; 하지만 지역화 &lt;code&gt;@gv&lt;/code&gt; 및 &lt;code&gt;%gv&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="07501a6bba290a81025a9cc58f969fd7da78b384" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;save_scalar&lt;/code&gt; , but will reinstate an &lt;code&gt;SV *&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;save_scalar&lt;/code&gt; 와 유사 하지만 &lt;code&gt;SV *&lt;/code&gt; 가 복원됩니다 .</target>
        </trans-unit>
        <trans-unit id="657ba45f71ac8c697cb507869c08178c868c5018" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;save_scalar&lt;/code&gt;, but localize &lt;code&gt;@gv&lt;/code&gt; and &lt;code&gt;%gv&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3fd7eb38494553782c4863edc348cc1335774a8b" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;save_scalar&lt;/code&gt;, but will reinstate an &lt;code&gt;SV *&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1390e677f6a0ebeb104aa1d188d2523b30d8bc4" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;save_svref&lt;/code&gt; , but localize &lt;code&gt;AV *&lt;/code&gt; and &lt;code&gt;HV *&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;save_svref&lt;/code&gt; 와 유사 하지만 &lt;code&gt;AV *&lt;/code&gt; 및 &lt;code&gt;HV *&lt;/code&gt; 를 현지화하십시오 .</target>
        </trans-unit>
        <trans-unit id="4f3780c5e475fc5db102e3fd087d1848086a6f08" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;save_svref&lt;/code&gt;, but localize &lt;code&gt;AV *&lt;/code&gt; and &lt;code&gt;HV *&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cdee7e1885c1d2ec3f4e4850b44e46e9ebce62cc" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;unlink0&lt;/code&gt; except after file comparison using cmpstat, the filehandle is closed prior to attempting to unlink the file. This allows the file to be removed without using an END block, but does mean that the post-unlink comparison of the filehandle state provided by &lt;code&gt;unlink0&lt;/code&gt; is not available.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7cf1c2a19f0b0ee74a54bd214a8ec4d84f8e3cf9" translate="yes" xml:space="preserve">
          <source>Similar to C</source>
          <target state="translated">C와 유사</target>
        </trans-unit>
        <trans-unit id="a64ea60affb2a9690ec81f413108d64202543e9b" translate="yes" xml:space="preserve">
          <source>Similar to T_PTR except that the pointer is stored in a scalar and the reference to that scalar is returned to the caller. This can be used to hide the actual pointer value from the programmer since it is usually not required directly from within perl.</source>
          <target state="translated">포인터가 스칼라에 저장되고 해당 스칼라에 대한 참조가 호출자에게 리턴된다는 점을 제외하면 T_PTR과 유사합니다. 이것은 일반적으로 perl 내에서 직접 필요하지 않기 때문에 프로그래머로부터 실제 포인터 값을 숨기는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4ed1b14b67aa9193491a3dd6d65f8409d185456b" translate="yes" xml:space="preserve">
          <source>Similar to T_PTROBJ in that the pointer is blessed into a scalar object. The difference is that when the object is passed back into XS it must be of the correct type (inheritance is not supported) while T_PTROBJ supports inheritance.</source>
          <target state="translated">포인터가 스칼라 객체로 축복된다는 점에서 T_PTROBJ와 유사합니다. 차이점은 오브젝트가 XS로 다시 전달 될 때 올바른 유형이어야하며 (상속은 지원되지 않음) T_PTROBJ는 상속을 지원한다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="98345bece5539f546d5a8e96d6aece125a75354c" translate="yes" xml:space="preserve">
          <source>Similar to T_PTRREF except that the reference is blessed into a class. This allows the pointer to be used as an object. Most commonly used to deal with C structs. The typemap checks that the perl object passed into the XS routine is of the correct class (or part of a subclass).</source>
          <target state="translated">참조가 클래스에 축복된다는 점을 제외하고 T_PTRREF와 유사합니다. 이를 통해 포인터를 객체로 사용할 수 있습니다. C 구조체를 다루는 데 가장 일반적으로 사용됩니다. 타입 맵은 XS 루틴으로 전달 된 perl 객체가 올바른 클래스 (또는 서브 클래스의 일부)인지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="a0e3f786e5320b6b926d5843480fabad22b49df4" translate="yes" xml:space="preserve">
          <source>Similar to T_PTRREF, except the pointer stored in the referenced scalar is dereferenced and copied to the output variable. This means that T_REFREF is to T_PTRREF as T_OPAQUE is to T_OPAQUEPTR. All clear?</source>
          <target state="translated">참조 된 스칼라에 저장된 포인터가 역 참조되어 출력 변수에 복사된다는 점을 제외하고 T_PTRREF와 유사합니다. 이는 T_OPAQUE가 T_OPAQUEPTR이므로 T_REFREF가 T_PTRREF임을 의미합니다. 공습 경보 해제?</target>
        </trans-unit>
        <trans-unit id="316a66a038c9003e3588353dd7b06b4570041574" translate="yes" xml:space="preserve">
          <source>Similar to key/value hash slices (and also introduced in Perl 5.20), the % array slice syntax returns a list of index/value pairs:</source>
          <target state="translated">키 / 값 해시 슬라이스와 유사하며 Perl 5.20에 도입 된 % 배열 슬라이스 구문은 인덱스 / 값 쌍의 목록을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="fcdb3335ff45dd421a45fea8e6567734b9ec0cac" translate="yes" xml:space="preserve">
          <source>Similar to mkstemp(), except that an extra argument can be supplied with a suffix to be appended to the template.</source>
          <target state="translated">템플릿에 추가 할 접미사를 추가 인수로 제공 할 수 있다는 점을 제외하고 mkstemp ()와 유사합니다.</target>
        </trans-unit>
        <trans-unit id="4cf9bfb3c81fe1275534c974c84d67c5db310bda" translate="yes" xml:space="preserve">
          <source>Similar to perl's &lt;code&gt;&lt;a href=&quot;../functions/grep&quot;&gt;grep&lt;/a&gt;&lt;/code&gt; keyword, but interprets the given list as an even-sized list of pairs. It invokes the &lt;code&gt;BLOCK&lt;/code&gt; multiple times, in scalar context, with &lt;code&gt;$a&lt;/code&gt; and &lt;code&gt;$b&lt;/code&gt; set to successive pairs of values from the &lt;code&gt;@kvlist&lt;/code&gt; .</source>
          <target state="translated">perl의 &lt;code&gt;&lt;a href=&quot;../functions/grep&quot;&gt;grep&lt;/a&gt;&lt;/code&gt; 키워드 와 유사 하지만 주어진 목록을 짝수 크기의 쌍 목록으로 해석합니다. 스칼라 컨텍스트에서 &lt;code&gt;$a&lt;/code&gt; 및 &lt;code&gt;$b&lt;/code&gt; 가 &lt;code&gt;@kvlist&lt;/code&gt; 에서 연속적인 값 쌍으로 설정되어 &lt;code&gt;BLOCK&lt;/code&gt; 을 여러 번 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="20605e6412e378f2426dfa2ecf790a73c30912ee" translate="yes" xml:space="preserve">
          <source>Similar to perl's &lt;code&gt;&lt;a href=&quot;../functions/map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; keyword, but interprets the given list as an even-sized list of pairs. It invokes the &lt;code&gt;BLOCK&lt;/code&gt; multiple times, in list context, with &lt;code&gt;$a&lt;/code&gt; and &lt;code&gt;$b&lt;/code&gt; set to successive pairs of values from the &lt;code&gt;@kvlist&lt;/code&gt; .</source>
          <target state="translated">perl의 &lt;code&gt;&lt;a href=&quot;../functions/map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; 키워드 와 유사 하지만 주어진 목록을 짝수 크기의 쌍 목록으로 해석합니다. &lt;code&gt;$a&lt;/code&gt; 와 &lt;code&gt;$b&lt;/code&gt; 가 &lt;code&gt;@kvlist&lt;/code&gt; 에서 연속적인 값 쌍으로 설정 되어 목록 컨텍스트에서 &lt;code&gt;BLOCK&lt;/code&gt; 을 여러 번 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="c8dc38a4899c208d20a94f1397e679f06553d540" translate="yes" xml:space="preserve">
          <source>Similar to perl's &lt;code&gt;grep&lt;/code&gt; keyword, but interprets the given list as an even-sized list of pairs. It invokes the &lt;code&gt;BLOCK&lt;/code&gt; multiple times, in scalar context, with &lt;code&gt;$a&lt;/code&gt; and &lt;code&gt;$b&lt;/code&gt; set to successive pairs of values from the &lt;code&gt;@kvlist&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6971d89c696879a9eeb673adbf4f23a22af252ce" translate="yes" xml:space="preserve">
          <source>Similar to perl's &lt;code&gt;map&lt;/code&gt; keyword, but interprets the given list as an even-sized list of pairs. It invokes the &lt;code&gt;BLOCK&lt;/code&gt; multiple times, in list context, with &lt;code&gt;$a&lt;/code&gt; and &lt;code&gt;$b&lt;/code&gt; set to successive pairs of values from the &lt;code&gt;@kvlist&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4e0979e74abc467bf78f9a39fbc983727e9baaf" translate="yes" xml:space="preserve">
          <source>Similar to strings, &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m''&lt;/a&gt;&lt;/code&gt; acts like apostrophes on a regexp; all other &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m&lt;/a&gt;&lt;/code&gt; delimiters act like quotes. If the regexp evaluates to the empty string, the regexp in the</source>
          <target state="translated">문자열과 유사하게, &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m''&lt;/a&gt;&lt;/code&gt; 은 정규 표현식에서 아포스트로피처럼 작동합니다. 다른 모든 &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m&lt;/a&gt;&lt;/code&gt; 구분 기호는 따옴표처럼 작동합니다. 정규 표현식이 빈 문자열로 평가되면</target>
        </trans-unit>
        <trans-unit id="19b88f89de77da98af72b4163220db2f0a7c8ecd" translate="yes" xml:space="preserve">
          <source>Similar to strings, &lt;code&gt;m''&lt;/code&gt; acts like apostrophes on a regexp; all other &lt;code&gt;'m'&lt;/code&gt; delimiters act like quotes. If the regexp evaluates to the empty string, the regexp in the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a82cc003c44f0253412b5190a2e4c975c854a684" translate="yes" xml:space="preserve">
          <source>Similar to the &lt;a href=&quot;#first&quot;&gt;&quot;first&quot;&lt;/a&gt; function, but interprets the given list as an even-sized list of pairs. It invokes the &lt;code&gt;BLOCK&lt;/code&gt; multiple times, in scalar context, with &lt;code&gt;$a&lt;/code&gt; and &lt;code&gt;$b&lt;/code&gt; set to successive pairs of values from the &lt;code&gt;@kvlist&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7ef33d2521670adf2f6b3cf61cae1999ab3778c" translate="yes" xml:space="preserve">
          <source>Similar to the &lt;a href=&quot;#first&quot;&gt;first&lt;/a&gt; function, but interprets the given list as an even-sized list of pairs. It invokes the &lt;code&gt;BLOCK&lt;/code&gt; multiple times, in scalar context, with &lt;code&gt;$a&lt;/code&gt; and &lt;code&gt;$b&lt;/code&gt; set to successive pairs of values from the &lt;code&gt;@kvlist&lt;/code&gt; .</source>
          <target state="translated">유사받는 &lt;a href=&quot;#first&quot;&gt;제&lt;/a&gt; 기능하지만 쌍 짝수 크기의 목록으로서 지정한리스트 해석한다. 스칼라 컨텍스트에서 &lt;code&gt;$a&lt;/code&gt; 및 &lt;code&gt;$b&lt;/code&gt; 가 &lt;code&gt;@kvlist&lt;/code&gt; 에서 연속적인 값 쌍으로 설정되어 &lt;code&gt;BLOCK&lt;/code&gt; 을 여러 번 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="f852487d7b194c670f738b8370d3735ea507b49e" translate="yes" xml:space="preserve">
          <source>Similar to the above, a sigil, followed by bareword text in braces, where the first character is a caret. The next character is any one of the characters &lt;code&gt;[][A-Z^_?\]&lt;/code&gt;, followed by ASCII word characters. An example is &lt;code&gt;${^GLOBAL_PHASE}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0747626402d2dd7f7c45b97cc24e9304db46b6d7" translate="yes" xml:space="preserve">
          <source>Similar to the above, a sigil, followed by bareword text in brackets, where the first character is either a caret followed by an uppercase letter, like &lt;code&gt;${^GLOBAL_PHASE}&lt;/code&gt; or a non-&lt;code&gt;NUL&lt;/code&gt; , non-space literal control like &lt;code&gt;${\7LOBAL_PHASE}&lt;/code&gt; . Like the above, when not under &lt;code&gt;&quot;use utf8&quot;&lt;/code&gt; , the characters in &lt;code&gt;[0x80-0xFF]&lt;/code&gt; are considered controls, but as of v5.22, the use of any that are non-graphical are deprecated, and as of v5.20 the use of any ASCII-range literal control is deprecated. Support for these will be removed in a future version of perl.</source>
          <target state="translated">위와 유사하게,시길 다음에 괄호로 묶인 베어 워드 텍스트가옵니다. 첫 번째 문자는 캐럿 뒤에 &lt;code&gt;${^GLOBAL_PHASE}&lt;/code&gt; 와 같은 대문자가 되거나 &lt;code&gt;${\7LOBAL_PHASE}&lt;/code&gt; 와 같은 &lt;code&gt;NUL&lt;/code&gt; 이 아닌 비 공백 리터럴 컨트롤입니다. 7LOBAL_PHASE} . 위와 같이 &lt;code&gt;&quot;use utf8&quot;&lt;/code&gt; 아닌 경우 &lt;code&gt;[0x80-0xFF]&lt;/code&gt; 의 문자는 제어로 간주되지만 v5.22에서는 그래픽이 아닌 문자는 더 이상 사용되지 않으며 v5.20부터는 ASCII 범위의 리터럴 제어는 더 이상 사용되지 않습니다. 이것에 대한 지원은 향후 버전의 perl에서 제거 될 것입니다.</target>
        </trans-unit>
        <trans-unit id="668df669d9efbd5ecee333d1f8978a303dbbc797" translate="yes" xml:space="preserve">
          <source>Similar to try, except that it does not catch exceptions. The idea here is to protect $@ and $! from changes. $@ and $! will be restored to whatever they were before the run so long as it is successful. If the run fails $! will still be restored, but $@ will contain the exception being thrown.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21000b274c1010d95d46737a373e917805b17d88" translate="yes" xml:space="preserve">
          <source>Similar to:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f2112c220c2b71523b70f673d7ec4dcde3c15e0" translate="yes" xml:space="preserve">
          <source>Similarly &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re 'Debug'&lt;/code&gt; produces debugging output, the difference being that it allows the fine tuning of what debugging output will be emitted. Options are divided into three groups, those related to compilation, those related to execution and those related to special purposes. The options are as follows:</source>
          <target state="translated">마찬가지로 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re 'Debug'&lt;/code&gt; 차이는 디버깅 출력 출사 될지의 미세 조정을 허용중인 디버깅 출력을 생성한다. 옵션은 컴파일 관련 그룹, 실행 관련 그룹, 특수 목적 관련 그룹으로 구분됩니다. 옵션은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c569ec67d5806423bac1b597854e2fd9a9cd8f16" translate="yes" xml:space="preserve">
          <source>Similarly &lt;code&gt;use re 'Debug'&lt;/code&gt; produces debugging output, the difference being that it allows the fine tuning of what debugging output will be emitted. Options are divided into three groups, those related to compilation, those related to execution and those related to special purposes. The options are as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="84d106c3869ea4929caecddf63406cc3cb977903" translate="yes" xml:space="preserve">
          <source>Similarly all warnings are disabled in a block by either of these:</source>
          <target state="translated">마찬가지로 모든 경고는 다음 중 하나에 의해 블록에서 비활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="55dea1c41dc940323d881fe12ebce9ec69c591cf" translate="yes" xml:space="preserve">
          <source>Similarly if you opened that handle &lt;code&gt;FH&lt;/code&gt; with regular &lt;code&gt;&lt;a href=&quot;../functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../functions/sysopen&quot;&gt;sysopen&lt;/a&gt;&lt;/code&gt;, you may use:</source>
          <target state="translated">마찬가지로 정규 &lt;code&gt;&lt;a href=&quot;../functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;../functions/sysopen&quot;&gt;sysopen&lt;/a&gt;&lt;/code&gt; 으로 핸들 &lt;code&gt;FH&lt;/code&gt; 를 열면 다음을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="64831f5e93834f6bf428903e01c563e7e7bece53" translate="yes" xml:space="preserve">
          <source>Similarly if you opened that handle &lt;code&gt;FH&lt;/code&gt; with regular &lt;code&gt;open&lt;/code&gt; or &lt;code&gt;sysopen&lt;/code&gt;, you may use:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53be67a31768325e220272f535bb98f85e3fcddf" translate="yes" xml:space="preserve">
          <source>Similarly one could take the output of the third numbers column from recipe 2 to obtain a &lt;code&gt;$cp_1047&lt;/code&gt; table. The fourth numbers column of the output from recipe 2 could provide a &lt;code&gt;$cp_posix_bc&lt;/code&gt; table suitable for transcoding as well.</source>
          <target state="translated">마찬가지로 레시피 2에서 세 번째 숫자 열의 출력을 &lt;code&gt;$cp_1047&lt;/code&gt; 테이블 을 얻을 수 있습니다. 레시피 2의 출력의 네 번째 숫자 열은 트랜스 코딩에도 적합한 &lt;code&gt;$cp_posix_bc&lt;/code&gt; 테이블을 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d0f4815a422eaba46c3d84f219793b24d2375a6b" translate="yes" xml:space="preserve">
          <source>Similarly the NULL needs to be taken into account when you are considering the length of existing keys/values.</source>
          <target state="translated">기존 키 / 값의 길이를 고려할 때 NULL도 고려해야합니다.</target>
        </trans-unit>
        <trans-unit id="15d5ffcdd52f893f6f74efb6a4803895765d4c4b" translate="yes" xml:space="preserve">
          <source>Similarly the name &quot;WinWin32s&quot; should have been &quot;Win32s&quot; but has been kept as-is for backwards compatibility reasons too.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b052290a572fb153a5a7598b50b12efdb7ef549e" translate="yes" xml:space="preserve">
          <source>Similarly unclear is what should be generated when the &lt;code&gt;\N{...}&lt;/code&gt; is used as one of the end points of the range, such as in</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04230c63a76d30ed5b83266e25e001a24b4eb855" translate="yes" xml:space="preserve">
          <source>Similarly with the one-shot interface, if the input is a buffer larger than 4 Gig, a zip64 complaint zip file will be created.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4baed99da5d9cf308161bde5e8cc00af2ab9d79" translate="yes" xml:space="preserve">
          <source>Similarly you can build in parallel with GNU make, type &quot;gmake -j2&quot; to build with two parallel jobs, or higher for more.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc4fb6a726563143c1c04086d201d673d7729dd3" translate="yes" xml:space="preserve">
          <source>Similarly,</source>
          <target state="translated">Similarly,</target>
        </trans-unit>
        <trans-unit id="90864fd67d3db4c105028d84006c631220f52597" translate="yes" xml:space="preserve">
          <source>Similarly, &lt;code&gt;$href-&amp;gt;{'red'}&lt;/code&gt; is part of the hash referred to by the scalar variable &lt;code&gt;$href&lt;/code&gt; , perhaps even one with no name. &lt;code&gt;$href{'red'}&lt;/code&gt; is part of the deceptively named &lt;code&gt;%href&lt;/code&gt; hash. It's easy to forget to leave out the &lt;code&gt;-&amp;gt;&lt;/code&gt; , and if you do, you'll get bizarre results when your program gets array and hash elements out of totally unexpected hashes and arrays that weren't the ones you wanted to use.</source>
          <target state="translated">마찬가지로 &lt;code&gt;$href-&amp;gt;{'red'}&lt;/code&gt; 는 스칼라 변수 &lt;code&gt;$href&lt;/code&gt; 에 의해 참조되는 해시의 일부이며 이름이없는 것입니다. &lt;code&gt;$href{'red'}&lt;/code&gt; 는 기만적으로 명명 된 &lt;code&gt;%href&lt;/code&gt; 해시의 일부입니다 . &lt;code&gt;-&amp;gt;&lt;/code&gt; 을 잊어 버리는 것은 잊어 버리기 쉬우 며 , 그렇게하면 프로그램이 사용하지 않을 완전히 예상치 못한 해시와 배열에서 배열과 해시 요소를 가져올 때 기괴한 결과를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b70d4728a23b61603feac7dca92ea80423288fd3" translate="yes" xml:space="preserve">
          <source>Similarly, &lt;code&gt;$href-&amp;gt;{'red'}&lt;/code&gt; is part of the hash referred to by the scalar variable &lt;code&gt;$href&lt;/code&gt;, perhaps even one with no name. &lt;code&gt;$href{'red'}&lt;/code&gt; is part of the deceptively named &lt;code&gt;%href&lt;/code&gt; hash. It's easy to forget to leave out the &lt;code&gt;-&amp;gt;&lt;/code&gt;, and if you do, you'll get bizarre results when your program gets array and hash elements out of totally unexpected hashes and arrays that weren't the ones you wanted to use.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d9f2629494d34ddc3413b1763638df2e3855408" translate="yes" xml:space="preserve">
          <source>Similarly, &lt;code&gt;-&amp;gt;autodefer(1)&lt;/code&gt; re-enables autodeferment, and &lt;code&gt;-&amp;gt;autodefer()&lt;/code&gt; recovers the current value of the autodefer setting.</source>
          <target state="translated">마찬가지로 &lt;code&gt;-&amp;gt;autodefer(1)&lt;/code&gt; 는 자동 지연을 다시 활성화하고 &lt;code&gt;-&amp;gt;autodefer()&lt;/code&gt; 는 자동 지연 설정의 현재 값을 복구합니다.</target>
        </trans-unit>
        <trans-unit id="ed0a74921b522c90d239c941839d98f9f544df9e" translate="yes" xml:space="preserve">
          <source>Similarly, &lt;code&gt;.=&lt;/code&gt; and &lt;code&gt;x=&lt;/code&gt; operators lose their mathemagical properties if the string conversion substitution is applied.</source>
          <target state="translated">마찬가지로 &lt;code&gt;.=&lt;/code&gt; 및 &lt;code&gt;x=&lt;/code&gt; 연산자는 문자열 변환 대체가 적용되면 수학 속성을 잃습니다.</target>
        </trans-unit>
        <trans-unit id="98381cd292cecc23499c5a97dc7663476a411916" translate="yes" xml:space="preserve">
          <source>Similarly, &lt;code&gt;PERL_MAGIC_uvar&lt;/code&gt; magic can be used much like tie() to call a C function any time a scalar's value is used or changed. The &lt;code&gt;MAGIC&lt;/code&gt; 's &lt;code&gt;mg_ptr&lt;/code&gt; field points to a &lt;code&gt;ufuncs&lt;/code&gt; structure:</source>
          <target state="translated">마찬가지로 &lt;code&gt;PERL_MAGIC_uvar&lt;/code&gt; 매직은 tie ()와 매우 유사하게 스칼라 값을 사용하거나 변경할 때마다 C 함수를 호출 할 수 있습니다. &lt;code&gt;MAGIC&lt;/code&gt; 의 &lt;code&gt;mg_ptr&lt;/code&gt; 의 A와 필드 점 &lt;code&gt;ufuncs&lt;/code&gt; 의 구조 :</target>
        </trans-unit>
        <trans-unit id="dd56bf6157ee2e5e27ea1785ce7250db948cb17e" translate="yes" xml:space="preserve">
          <source>Similarly, &lt;code&gt;PERL_MAGIC_uvar&lt;/code&gt; magic can be used much like tie() to call a C function any time a scalar's value is used or changed. The &lt;code&gt;MAGIC&lt;/code&gt;'s &lt;code&gt;mg_ptr&lt;/code&gt; field points to a &lt;code&gt;ufuncs&lt;/code&gt; structure:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="084028b0095b78ad708b249b88f8a8326808bba4" translate="yes" xml:space="preserve">
          <source>Similarly, &lt;code&gt;\x&lt;i&gt;nn&lt;/i&gt;&lt;/code&gt;, where</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1434bb43847966624ccbd7c82a8d888d8931593" translate="yes" xml:space="preserve">
          <source>Similarly, Perl's built-in &lt;code&gt;&lt;a href=&quot;functions/ref&quot;&gt;ref&lt;/a&gt;&lt;/code&gt; function treats a reference to a blessed object specially. If you call &lt;code&gt;&lt;a href=&quot;functions/ref&quot;&gt;ref($thing)&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;$thing&lt;/code&gt; holds a reference to an object, it will return the name of the class that the object has been blessed into.</source>
          <target state="translated">마찬가지로, Perl의 내장 &lt;code&gt;&lt;a href=&quot;functions/ref&quot;&gt;ref&lt;/a&gt;&lt;/code&gt; 함수는 축복 된 객체에 대한 참조를 특별히 처리합니다. &lt;code&gt;&lt;a href=&quot;functions/ref&quot;&gt;ref($thing)&lt;/a&gt;&lt;/code&gt; 을 호출 하고 &lt;code&gt;$thing&lt;/code&gt; 은 객체에 대한 참조를 보유하면 객체가 축복받은 클래스의 이름을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="3c79bdba87881c1ec05393b4d27a2c965c79a1a5" translate="yes" xml:space="preserve">
          <source>Similarly, Perl's built-in &lt;code&gt;ref&lt;/code&gt; function treats a reference to a blessed object specially. If you call &lt;code&gt;ref($thing)&lt;/code&gt; and &lt;code&gt;$thing&lt;/code&gt; holds a reference to an object, it will return the name of the class that the object has been blessed into.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed57441510534192d07967fc62d33e33379b4e80" translate="yes" xml:space="preserve">
          <source>Similarly, a list assignment in list context produces the list of lvalues assigned to, and a list assignment in scalar context returns the number of elements produced by the expression on the right hand side of the assignment.</source>
          <target state="translated">마찬가지로 목록 컨텍스트의 목록 할당은 할당 된 lvalue 목록을 생성하고 스칼라 컨텍스트의 목록 할당은 할당의 오른쪽에있는 표현식에 의해 생성 된 요소 수를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="105351b9ff1ce0c3b0da126c3158372b6f241c09" translate="yes" xml:space="preserve">
          <source>Similarly, a value assigned to &lt;code&gt;$)&lt;/code&gt; must also be a space-separated list of numbers. The first number sets the effective gid, and the rest (if any) are passed to &lt;code&gt;setgroups()&lt;/code&gt; . To get the effect of an empty list for &lt;code&gt;setgroups()&lt;/code&gt; , just repeat the new effective gid; that is, to force an effective gid of 5 and an effectively empty &lt;code&gt;setgroups()&lt;/code&gt; list, say &lt;code&gt; $) = &quot;5 5&quot; &lt;/code&gt; .</source>
          <target state="translated">마찬가지로 &lt;code&gt;$)&lt;/code&gt; 에 지정된 값 도 공백으로 구분 된 숫자 목록이어야합니다. 첫 번째 숫자는 유효 gid를 설정하고 나머지는 (있는 경우) &lt;code&gt;setgroups()&lt;/code&gt; 로 전달됩니다 . &lt;code&gt;setgroups()&lt;/code&gt; 에 대한 빈 목록의 효과를 얻으려면 새로운 유효 gid를 반복하십시오. 즉, 효과적인 gid 5 및 효과적으로 빈 &lt;code&gt;setgroups()&lt;/code&gt; 목록 을 강제 실행하려면 &lt;code&gt; $) = &quot;5 5&quot; &lt;/code&gt; 라고 말하십시오 .</target>
        </trans-unit>
        <trans-unit id="a9bfb808fae3d4ef85e01abecf018c96a424092b" translate="yes" xml:space="preserve">
          <source>Similarly, a value assigned to &lt;code&gt;$)&lt;/code&gt; must also be a space-separated list of numbers. The first number sets the effective gid, and the rest (if any) are passed to &lt;code&gt;setgroups()&lt;/code&gt;. To get the effect of an empty list for &lt;code&gt;setgroups()&lt;/code&gt;, just repeat the new effective gid; that is, to force an effective gid of 5 and an effectively empty &lt;code&gt;setgroups()&lt;/code&gt; list, say &lt;code&gt; $) = &quot;5 5&quot; &lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f830d9f2bf12f89de4edd3497ea1af8e153890fe" translate="yes" xml:space="preserve">
          <source>Similarly, an expression that returns a reference to a scalar can be dereferenced via &lt;code&gt;${...}&lt;/code&gt; . Thus, the above expression may be written as:</source>
          <target state="translated">마찬가지로 스칼라에 대한 참조를 리턴하는 표현식은 &lt;code&gt;${...}&lt;/code&gt; 통해 역 참조 될 수 있습니다 . 따라서 위의 표현은 다음과 같이 쓸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6c0225a1fecb24141de2c67cfa637dd7b4544c6f" translate="yes" xml:space="preserve">
          <source>Similarly, an expression that returns a reference to a scalar can be dereferenced via &lt;code&gt;${...}&lt;/code&gt;. Thus, the above expression may be written as:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1370fc5b87a4deef9433fab962c63dda2bb0891" translate="yes" xml:space="preserve">
          <source>Similarly, autogeneration for keys &lt;code&gt;'+='&lt;/code&gt; and &lt;code&gt;'++'&lt;/code&gt; is analogous to &lt;code&gt;'-='&lt;/code&gt; and &lt;code&gt;'--'&lt;/code&gt; above:</source>
          <target state="translated">마찬가지로 &lt;code&gt;'+='&lt;/code&gt; 및 &lt;code&gt;'++'&lt;/code&gt; 키 의 자동 생성은 위의 &lt;code&gt;'-='&lt;/code&gt; 및 &lt;code&gt;'--'&lt;/code&gt; 와 유사합니다 .</target>
        </trans-unit>
        <trans-unit id="22f4fe3ff0b7318ce2f9a1f22a4a30c916f48517" translate="yes" xml:space="preserve">
          <source>Similarly, because of all the subscripting that is done using single words, the same rule applies to any bareword that is used for subscripting a hash. So now, instead of writing</source>
          <target state="translated">마찬가지로 단일 단어를 사용하여 수행 된 모든 첨자 때문에 동일한 규칙이 해시를 첨자하는 데 사용되는 모든 베어 워드에 적용됩니다. 지금은 글을 쓰는 대신</target>
        </trans-unit>
        <trans-unit id="1ef17c2e729b74afc14b925795781df60a813811" translate="yes" xml:space="preserve">
          <source>Similarly, decimal strings can represent only those numbers which have a finite decimal expansion. Being strings, and thus of arbitrary length, there is no practical limit for the exponent or number of decimal digits for these numbers. (But realize that what we are discussing the rules for just the</source>
          <target state="translated">마찬가지로, 십진 문자열은 유한 한 십진 확장을 갖는 숫자 만 나타낼 수 있습니다. 문자열이므로 임의의 길이이므로 이러한 숫자의 지수 또는 소수 자릿수에 대한 실제 제한은 없습니다. (그러나 우리가 단지</target>
        </trans-unit>
        <trans-unit id="d345f5b26d91c2f90c4bf682659d17c36e269cb0" translate="yes" xml:space="preserve">
          <source>Similarly, for repeated &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m/()/g&lt;/a&gt;&lt;/code&gt; the second-best match is the match at the position one notch further in the string.</source>
          <target state="translated">마찬가지로, 반복 된 &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m/()/g&lt;/a&gt;&lt;/code&gt; 의 경우 두 번째로 가장 일치하는 것은 문자열에서 한 단계 더 떨어진 위치에서의 일치입니다.</target>
        </trans-unit>
        <trans-unit id="120bba2aa7dfcc858de2e7ae463e7151de6901e1" translate="yes" xml:space="preserve">
          <source>Similarly, for repeated &lt;code&gt;m/()/g&lt;/code&gt; the second-best match is the match at the position one notch further in the string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dee2c36ef0fdac4abda9dcad28ab4aed983df538" translate="yes" xml:space="preserve">
          <source>Similarly, functions that return text data--such as a function that fetches a web page--should sometimes translate newlines before returning the data, if they've not yet been translated to the local newline representation. A single line of code will often suffice:</source>
          <target state="translated">마찬가지로 웹 페이지를 가져 오는 함수와 같이 텍스트 데이터를 반환하는 함수는 로컬 개행 표시로 아직 변환되지 않은 경우 데이터를 반환하기 전에 개행을 번역해야하는 경우가 있습니다. 한 줄의 코드로 충분합니다.</target>
        </trans-unit>
        <trans-unit id="6397152c0c35f4b75972d06222dcea4b97f1756f" translate="yes" xml:space="preserve">
          <source>Similarly, if the &lt;code&gt;compress&lt;/code&gt; program is available, you can use this to write a &lt;code&gt;.tar.Z&lt;/code&gt; file</source>
          <target state="translated">마찬가지로 &lt;code&gt;compress&lt;/code&gt; 프로그램을 사용할 수있는 경우이를 사용하여 &lt;code&gt;.tar.Z&lt;/code&gt; 파일 을 작성할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5e75a2bb501471358d82a9998e95b65710f45b03" translate="yes" xml:space="preserve">
          <source>Similarly, if you need the threads object, but your thread will not be returning a value (i.e.,</source>
          <target state="translated">마찬가지로 threads 객체가 필요하지만 스레드가 값을 반환하지 않는 경우 (예 :</target>
        </trans-unit>
        <trans-unit id="5871ebe0fa13ed14449c1f6ca87d126616162345" translate="yes" xml:space="preserve">
          <source>Similarly, in the failure branch we could use &lt;code&gt;PUSHs&lt;/code&gt;</source>
          <target state="translated">마찬가지로 실패 지점에서 &lt;code&gt;PUSHs&lt;/code&gt; 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9077bdc5741605a4137fa6215e60fd225b8f3e44" translate="yes" xml:space="preserve">
          <source>Similarly, it would be better to use &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature 'unicode_strings'&lt;/code&gt; instead of,</source>
          <target state="translated">마찬가지로 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature 'unicode_strings'&lt;/code&gt; 을 사용 &lt;a href=&quot;functions/use&quot;&gt;하는&lt;/a&gt; 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="14a6593d35c0dd5a226aba97a86d554f0e84ed18" translate="yes" xml:space="preserve">
          <source>Similarly, it would be better to use &lt;code&gt;use feature 'unicode_strings'&lt;/code&gt; instead of,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c46d4cfe15f7f292996d268d497a4ca8dd6bd83c" translate="yes" xml:space="preserve">
          <source>Similarly, just because an operator lets you assume default arguments doesn't mean that you have to make use of the defaults. The defaults are there for lazy systems programmers writing one-shot programs. If you want your program to be readable, consider supplying the argument.</source>
          <target state="translated">마찬가지로 연산자가 기본 인수를 가정한다고해서 기본값을 사용해야한다는 의미는 아닙니다. 게으른 시스템 프로그래머가 원샷 프로그램을 작성하는 경우 기본값이 있습니다. 프로그램을 읽을 수있게하려면 인수를 제공하십시오.</target>
        </trans-unit>
        <trans-unit id="65a3c4117ed70cbe8d3af699e5cf5e22b4df58b4" translate="yes" xml:space="preserve">
          <source>Similarly, mixing signals and threads may be problematic. Implementations are platform-dependent, and even the POSIX semantics may not be what you expect (and Perl doesn't even give you the full POSIX API). For example, there is no way to guarantee that a signal sent to a multi-threaded Perl application will get intercepted by any particular thread. (However, a recently added feature does provide the capability to send signals between threads. See &lt;a href=&quot;threads#THREAD-SIGNALLING&quot;&gt;&quot;THREAD SIGNALLING&quot; in threads&lt;/a&gt; for more details.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aab81862aa9c1688c2206840c0db77adfc7697fb" translate="yes" xml:space="preserve">
          <source>Similarly, mixing signals and threads may be problematic. Implementations are platform-dependent, and even the POSIX semantics may not be what you expect (and Perl doesn't even give you the full POSIX API). For example, there is no way to guarantee that a signal sent to a multi-threaded Perl application will get intercepted by any particular thread. (However, a recently added feature does provide the capability to send signals between threads. See &lt;a href=&quot;threads#THREAD-SIGNALLING&quot;&gt;THREAD SIGNALLING in threads&lt;/a&gt; for more details.)</source>
          <target state="translated">마찬가지로, 신호와 스레드를 혼합하는 데 문제가있을 수 있습니다. 구현은 플랫폼에 따라 다르며 POSIX 시맨틱조차 기대하지 않을 수 있습니다 (Perl은 전체 POSIX API도 제공하지 않습니다). 예를 들어, 다중 스레드 Perl 응용 프로그램으로 전송 된 신호가 특정 스레드에 의해 차단 될 수있는 방법은 없습니다. (그러나, 최근에 추가 된 기능은 스레드 사이에 신호를 보낼 수있는 기능을 제공한다. 참조 &lt;a href=&quot;threads#THREAD-SIGNALLING&quot;&gt;스레드 스레드 신호를&lt;/a&gt; 자세한 내용은.)</target>
        </trans-unit>
        <trans-unit id="cd7a72bba4a729c17beea354c31212e7918a1056" translate="yes" xml:space="preserve">
          <source>Similarly, syswrite() and send() use only the &lt;code&gt;:utf8&lt;/code&gt; flag, otherwise ignoring any layers. If the flag is set, both write the value UTF-8 encoded, even if the layer is some different encoding, such as the example above.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0b7335ed3c7d05707d8547cd24aeb6b264218d7" translate="yes" xml:space="preserve">
          <source>Similarly, syswrite() and send() used only the &lt;code&gt;:utf8&lt;/code&gt; flag, otherwise ignoring any layers. If the flag is set, both wrote the value UTF-8 encoded, even if the layer is some different encoding, such as the example above.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9312c4a2cb541668748a3ea749dc0d9f12c2cf9" translate="yes" xml:space="preserve">
          <source>Similarly, the &lt;code&gt;UNICODE_WARN_NONCHAR&lt;/code&gt; and &lt;code&gt;UNICODE_DISALLOW_NONCHAR&lt;/code&gt; flags affect how the function handles a Unicode non-character.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2fa030e076fa248a433f0f83ee4a1aceaeee249f" translate="yes" xml:space="preserve">
          <source>Similarly, the parameter &lt;code&gt;inc_override&lt;/code&gt; may be a reference to an array which is used in place of the default module search paths from &lt;code&gt;@INC&lt;/code&gt; .</source>
          <target state="translated">마찬가지로 &lt;code&gt;inc_override&lt;/code&gt; 매개 변수 는 &lt;code&gt;@INC&lt;/code&gt; 의 기본 모듈 검색 경로 대신 사용되는 배열에 대한 참조 일 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1c747d6cbaa1a9a827f93122d97bf098849b7485" translate="yes" xml:space="preserve">
          <source>Similarly, the parameter &lt;code&gt;inc_override&lt;/code&gt; may be a reference to an array which is used in place of the default module search paths from &lt;code&gt;@INC&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1497da8abe3ed6eca13bd6302e3d281ea65007d7" translate="yes" xml:space="preserve">
          <source>Similarly, the resultant filespec will contain the file version only if one was present in the input filespec.</source>
          <target state="translated">마찬가지로 결과 파일 스펙에는 입력 파일 스펙에 파일 버전이있는 경우에만 파일 버전이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="0dacead88183b1e9c6304a4ceec665b6c24796d7" translate="yes" xml:space="preserve">
          <source>Similarly, they can be used in regular expression literals</source>
          <target state="translated">마찬가지로 정규 표현식 리터럴에서 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="395326d4967b38aae5eb742109108213c899c254" translate="yes" xml:space="preserve">
          <source>Similarly, this is invalid:</source>
          <target state="translated">마찬가지로, 이것은 유효하지 않습니다 :</target>
        </trans-unit>
        <trans-unit id="6c8f54b856913d21b69f361a1a90203715ac01de" translate="yes" xml:space="preserve">
          <source>Similarly, this recipe can be used for properties that do require adjustments:</source>
          <target state="translated">마찬가지로이 레시피는 조정이 필요한 특성에 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="838e649b773f393ab1e3e6ec2fd3f5756cf00ea3" translate="yes" xml:space="preserve">
          <source>Similarly, this will silence warnings from this module, and preserve the default behaviour:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4b2e4fdd23d41dfea9d8225a12a424a715230bb" translate="yes" xml:space="preserve">
          <source>Similarly, this:</source>
          <target state="translated">마찬가지로, 이것은 :</target>
        </trans-unit>
        <trans-unit id="d1bdda2be136926ef9a893301ff91d18747c507f" translate="yes" xml:space="preserve">
          <source>Similarly, to copy an anonymous hash, you can use</source>
          <target state="translated">마찬가지로 익명 해시를 복사하려면</target>
        </trans-unit>
        <trans-unit id="7850beac28db723d025cfad11fb93ce97e2ced9b" translate="yes" xml:space="preserve">
          <source>Similarly, using &lt;code&gt;$^W&lt;/code&gt; to either disable or enable blocks of code is fundamentally flawed. For a start, say you want to disable warnings in a block of code. You might expect this to be enough to do the trick:</source>
          <target state="translated">마찬가지로 &lt;code&gt;$^W&lt;/code&gt; 를 사용하여 코드 블록을 비활성화하거나 활성화하는 것은 근본적으로 결함이 있습니다. 시작하려면 코드 블록에서 경고를 비활성화한다고 가정하십시오. 트릭을 수행하기에 충분할 것으로 예상 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2664530a7df4eabf1ac2e9d54c9f06c6deee6b41" translate="yes" xml:space="preserve">
          <source>Similarly, with this code</source>
          <target state="translated">마찬가지로이 코드로</target>
        </trans-unit>
        <trans-unit id="b0293d771b0de8656e1c85bf1faad486bf545599" translate="yes" xml:space="preserve">
          <source>Similarly, you may use these I/O layers on output streams to automatically convert Unicode to the specified encoding when it is written to the stream. For example, the following snippet copies the contents of the file &quot;text.jis&quot; (encoded as ISO-2022-JP, aka JIS) to the file &quot;text.utf8&quot;, encoded as UTF-8:</source>
          <target state="translated">마찬가지로 출력 스트림에서 이러한 I / O 레이어를 사용하여 유니 코드가 스트림에 기록 될 때 지정된 인코딩으로 자동 변환 할 수 있습니다. 예를 들어, 다음 스 니펫은 &quot;text.jis&quot;파일 (ISO-2022-JP, 일명 JIS)의 내용을 UTF-8로 인코딩 된 &quot;text.utf8&quot;파일에 복사합니다.</target>
        </trans-unit>
        <trans-unit id="a9548affa7e4acbe2593b885978a8755658bc00f" translate="yes" xml:space="preserve">
          <source>Similary to</source>
          <target state="translated">와 유사</target>
        </trans-unit>
        <trans-unit id="d038c3b0b4f25db2b86d3e73c906bad029553a54" translate="yes" xml:space="preserve">
          <source>Simon Cozens &amp;lt;simon AT brecon DOT co DOT uk&amp;gt; - Being there to answer zillions of annoying questions</source>
          <target state="translated">Simon Cozens &amp;lt;simon AT brecon DOT co DOT uk&amp;gt;-성가신 질문에 답하기 위해 거기에있는 것</target>
        </trans-unit>
        <trans-unit id="db6a8ce8a7b56a60b15a1e81509c2149cf995dfb" translate="yes" xml:space="preserve">
          <source>Simon Cozens and Wolfgang Laun.</source>
          <target state="translated">Simon Cozens와 Wolfgang Laun.</target>
        </trans-unit>
        <trans-unit id="911ebed02457e684e0b32e14a35ae78fa21f67e0" translate="yes" xml:space="preserve">
          <source>Simon Cozens, &lt;code&gt;simon@cpan.org&lt;/code&gt;</source>
          <target state="translated">사이먼 코 ​​젠스, &lt;code&gt;simon@cpan.org&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c339f709f7b43634c7fbcb9cbd9eccd0f9cc3ac2" translate="yes" xml:space="preserve">
          <source>Simple Mail Transfer Protocol Client</source>
          <target state="translated">단순 메일 전송 프로토콜 클라이언트</target>
        </trans-unit>
        <trans-unit id="0b80f19dce22ed4ff1ea0703ed5ec7dc2f2434d5" translate="yes" xml:space="preserve">
          <source>Simple Perl scalars (any scalar that is not a reference) are the most difficult objects to encode: JSON::PP will encode undefined scalars as JSON &lt;code&gt;null&lt;/code&gt; values, scalars that have last been used in a string context before encoding as JSON strings, and anything else as number value:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bee009eadcb45691f1eecbe3d87057665862d1bd" translate="yes" xml:space="preserve">
          <source>Simple Scalar</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83f59937d173df040577971290f0e1cacd671a9c" translate="yes" xml:space="preserve">
          <source>Simple Statements</source>
          <target state="translated">간단한 진술</target>
        </trans-unit>
        <trans-unit id="84ffc80b7ca3fcee70bdb32bddd613a718e0b12c" translate="yes" xml:space="preserve">
          <source>Simple assignment is not overloadable (the &lt;code&gt;'='&lt;/code&gt; key is used for the &lt;a href=&quot;#Copy-Constructor&quot;&gt;&quot;Copy Constructor&quot;&lt;/a&gt;). Perl does have a way to make assignments to an object do whatever you want, but this involves using tie(), not overload - see &lt;a href=&quot;perlfunc#tie&quot;&gt;&quot;tie&quot; in perlfunc&lt;/a&gt; and the &lt;a href=&quot;#COOKBOOK&quot;&gt;&quot;COOKBOOK&quot;&lt;/a&gt; examples below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd89bedbaeb791041cff4fe148dbfde653b95d00" translate="yes" xml:space="preserve">
          <source>Simple assignment is not overloadable (the &lt;code&gt;'='&lt;/code&gt; key is used for the &lt;a href=&quot;#Copy-Constructor&quot;&gt;Copy Constructor&lt;/a&gt;). Perl does have a way to make assignments to an object do whatever you want, but this involves using tie(), not overload - see &lt;a href=&quot;functions/tie&quot;&gt;tie&lt;/a&gt; and the &lt;a href=&quot;#COOKBOOK&quot;&gt;COOKBOOK&lt;/a&gt; examples below.</source>
          <target state="translated">단순 할당은 오버로드 할 수 없습니다 ( &lt;code&gt;'='&lt;/code&gt; 키가 &lt;a href=&quot;#Copy-Constructor&quot;&gt;복사 생성자에&lt;/a&gt; 사용됨 ). Perl은 객체에 할당하는 방법이 있지만 원하는 것은 오버로드가 아닌 tie ()를 사용 합니다. 아래의 &lt;a href=&quot;functions/tie&quot;&gt;tie&lt;/a&gt; 및 &lt;a href=&quot;#COOKBOOK&quot;&gt;COOKBOOK&lt;/a&gt; 예를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="8605c0b660faa7b5703ee9847774a8d43e86ed05" translate="yes" xml:space="preserve">
          <source>Simple delegatees for misc parameters derived from distribution</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94eac8882772ef72bea55863ece1200dedf301b7" translate="yes" xml:space="preserve">
          <source>Simple enough. Now compile and run:</source>
          <target state="translated">충분히 간단합니다. 이제 컴파일하고 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="ba971c7177cc7a0849b0167e7f954b49b5a4aaf2" translate="yes" xml:space="preserve">
          <source>Simple examples</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="764eff41a5149cfadde2c6b72cdd2e21368ca43b" translate="yes" xml:space="preserve">
          <source>Simple examples to open a file for reading:</source>
          <target state="translated">읽을 파일을 여는 간단한 예 :</target>
        </trans-unit>
        <trans-unit id="8bbdbbffdc1d0c057f0470ba8573e7773f1d085a" translate="yes" xml:space="preserve">
          <source>Simple interface to Locale::Maketext::Lexicon</source>
          <target state="translated">Locale :: Maketext :: Lexicon에 대한 간단한 인터페이스</target>
        </trans-unit>
        <trans-unit id="7b8b7240c656011159c28f4357d2c8a844877df6" translate="yes" xml:space="preserve">
          <source>Simple matching</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1a65de4566d838633c7cfe8d2f3954d6165e02e" translate="yes" xml:space="preserve">
          <source>Simple methods for simple tasks</source>
          <target state="translated">간단한 작업을위한 간단한 방법</target>
        </trans-unit>
        <trans-unit id="107deb5b12e566d319794bc7ce2d8bcc70c508d0" translate="yes" xml:space="preserve">
          <source>Simple options</source>
          <target state="translated">간단한 옵션</target>
        </trans-unit>
        <trans-unit id="b3c11d00394d5efd68e3089882ea99ef88db2b49" translate="yes" xml:space="preserve">
          <source>Simple subroutine to insert the macros defined by the macro attribute into the Makefile.</source>
          <target state="translated">매크로 속성으로 정의 된 매크로를 Makefile에 삽입하는 간단한 서브 루틴.</target>
        </trans-unit>
        <trans-unit id="adadcc42c8be98750be33acd4bfac36bd737f651" translate="yes" xml:space="preserve">
          <source>Simple substitution</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f78d32b59c097fb10ad26d36f2e74fdbebe4e64" translate="yes" xml:space="preserve">
          <source>Simple word matching</source>
          <target state="translated">간단한 단어 매칭</target>
        </trans-unit>
        <trans-unit id="f7b02d0f94f21913ddb8d295324658b8720d69e0" translate="yes" xml:space="preserve">
          <source>Simple, eh?</source>
          <target state="translated">간단 해요?</target>
        </trans-unit>
        <trans-unit id="5ab4a74caba11b1370fe119fe34f9f5db826dbbf" translate="yes" xml:space="preserve">
          <source>Simple, one-off commits pushed to the 'blead' branch should be simple commits that apply cleanly. In other words, you should make sure your work is committed against the current position of blead, so that you can push back to the master repository without merging.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ee1790ba48c5c5f5aec6b6de12f218c366e78db" translate="yes" xml:space="preserve">
          <source>Simple... Now look:</source>
          <target state="translated">간단 ... 이제보세요 :</target>
        </trans-unit>
        <trans-unit id="6c9330b7a2ff965f7db6cafb9f575b4d58374515" translate="yes" xml:space="preserve">
          <source>Simpler definition of attribute handlers</source>
          <target state="translated">속성 핸들러의 간단한 정의</target>
        </trans-unit>
        <trans-unit id="50c361747016ee3aff5355a6c96f0c2b139551ef" translate="yes" xml:space="preserve">
          <source>Simplest way to do it automatically is to use your version control system's revision number (you are using version control, right?).</source>
          <target state="translated">자동으로 수행하는 가장 간단한 방법은 버전 관리 시스템의 개정 번호를 사용하는 것입니다 (버전 관리를 사용하고 있습니까?).</target>
        </trans-unit>
        <trans-unit id="68be18029150583164f9438753e32a72fd3e4c87" translate="yes" xml:space="preserve">
          <source>Simplified source filtering</source>
          <target state="translated">단순화 된 소스 필터링</target>
        </trans-unit>
        <trans-unit id="66f7f6fe24549ec54694a312ab799bde4d89b2f3" translate="yes" xml:space="preserve">
          <source>Simply not portable. Get your lvalue to be of the right type, or maybe use temporary variables, or dirty tricks with unions.</source>
          <target state="translated">휴대용이 아닙니다. lvalue를 올바른 유형으로 만들거나 임시 변수를 사용하거나 공용체를 사용하여 더티 트릭을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="20084b93a5f754ce0ccd01de74eb0172d18babfc" translate="yes" xml:space="preserve">
          <source>Simply put:</source>
          <target state="translated">간단히 말해서:</target>
        </trans-unit>
        <trans-unit id="991f810db6d12637f2fd5bbddcb5e86f7ab43bb2" translate="yes" xml:space="preserve">
          <source>Simply put: for each extension linked with your Perl executable (determined during its initial configuration on your computer or when adding a new extension), a Perl subroutine is created to incorporate the extension's routines. Normally, that subroutine is named</source>
          <target state="translated">간단히 말해 : Perl 실행 파일과 연결된 각 확장 (컴퓨터의 초기 구성 중 또는 새 확장을 추가 할 때 결정)에 대해 확장의 루틴을 통합하기 위해 Perl 서브 루틴이 작성됩니다. 일반적으로 해당 서브 루틴의 이름은</target>
        </trans-unit>
        <trans-unit id="86b802f817d8db47f98e358e0df4e43c122569da" translate="yes" xml:space="preserve">
          <source>Simply run</source>
          <target state="translated">간단히 실행</target>
        </trans-unit>
        <trans-unit id="14c3e2e53d9dfb6b8072093e8b927f77f6a76d42" translate="yes" xml:space="preserve">
          <source>Simply says that we're Unix.</source>
          <target state="translated">단순히 우리가 유닉스라고 말합니다.</target>
        </trans-unit>
        <trans-unit id="22a4ed66c623d273a571652cc9ae1a89577a837f" translate="yes" xml:space="preserve">
          <source>Since</source>
          <target state="translated">Since</target>
        </trans-unit>
        <trans-unit id="60dbe9f3bc2001b2c722387a7d49aaabb3da33d1" translate="yes" xml:space="preserve">
          <source>Since # can be used for comments, # must be escaped.</source>
          <target state="translated">#은 주석에 사용될 수 있으므로 #는 이스케이프되어야합니다.</target>
        </trans-unit>
        <trans-unit id="7f16eb993aa5b4126dadedc6b4f7941b4f104c6b" translate="yes" xml:space="preserve">
          <source>Since 3.26, using &lt;code&gt;-F&lt;/code&gt; as the superuser also implies &lt;code&gt;-U&lt;/code&gt; as opening most files and traversing directories requires privileges that are above the nobody/nogroup level.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d18dd63133c168a4767fcb87b71a43b938682e1a" translate="yes" xml:space="preserve">
          <source>Since &lt;a href=&quot;#system-LIST&quot;&gt;&lt;code&gt;system&lt;/code&gt;&lt;/a&gt; does a &lt;a href=&quot;#fork&quot;&gt;&lt;code&gt;fork&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt; it may affect a &lt;code&gt;SIGCHLD&lt;/code&gt; handler. See &lt;a href=&quot;perlipc&quot;&gt;perlipc&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ded02f76d7e8f2623d74fdc5f26a66cd0a132c8" translate="yes" xml:space="preserve">
          <source>Since &lt;a href=&quot;http://man.he.net/man3/flock&quot;&gt;flock(3)&lt;/a&gt; is present in EMX, but is not functional, it is emulated by perl. To disable the emulations, set environment variable &lt;code&gt;USE_PERL_FLOCK=0&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af160de91abb536123124eac1ecabfc37de02e74" translate="yes" xml:space="preserve">
          <source>Since &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; does a &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait&lt;/a&gt;&lt;/code&gt; it may affect a &lt;code&gt;SIGCHLD&lt;/code&gt; handler. See &lt;a href=&quot;perlipc&quot;&gt;perlipc&lt;/a&gt; for details.</source>
          <target state="translated">이후 &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; 않습니다 &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork&lt;/a&gt;&lt;/code&gt; 와 &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait&lt;/a&gt;&lt;/code&gt; 그것은 영향을 미칠 수 &lt;code&gt;SIGCHLD&lt;/code&gt; 의 핸들러를. 자세한 내용은 &lt;a href=&quot;perlipc&quot;&gt;perlipc&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="aba59b2cf00e40d21bac4c0a192544510ddcbae0" translate="yes" xml:space="preserve">
          <source>Since &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; will also call the &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; method, the actual value for &lt;code&gt;MODULE&lt;/code&gt; must be a bareword. That is, &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; cannot load files by name, although &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; can:</source>
          <target state="translated">때문에 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 또한 호출 &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; 방법에 대한 실제 값 &lt;code&gt;MODULE&lt;/code&gt; bareword는 있어야합니다. 즉, &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 하지만, 이름으로 파일을로드 할 수 없습니다 &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; 캔 :</target>
        </trans-unit>
        <trans-unit id="73d2921b742823e6f578c98791a72739f4a21337" translate="yes" xml:space="preserve">
          <source>Since &lt;code&gt;&lt;a href=&quot;system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; does a &lt;code&gt;&lt;a href=&quot;fork&quot;&gt;fork&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;wait&quot;&gt;wait&lt;/a&gt;&lt;/code&gt; it may affect a &lt;code&gt;SIGCHLD&lt;/code&gt; handler. See &lt;a href=&quot;../perlipc&quot;&gt;perlipc&lt;/a&gt; for details.</source>
          <target state="translated">이후 &lt;code&gt;&lt;a href=&quot;system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; 않습니다 &lt;code&gt;&lt;a href=&quot;fork&quot;&gt;fork&lt;/a&gt;&lt;/code&gt; 와 &lt;code&gt;&lt;a href=&quot;wait&quot;&gt;wait&lt;/a&gt;&lt;/code&gt; 그것은 영향을 미칠 수 &lt;code&gt;SIGCHLD&lt;/code&gt; 의 핸들러를. 자세한 내용은 &lt;a href=&quot;../perlipc&quot;&gt;perlipc&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="53cc6266d93eb2a78be0857ad5ecd43af7e2b644" translate="yes" xml:space="preserve">
          <source>Since &lt;code&gt;Archive::Tar&lt;/code&gt; doesn't change the current directory internally while it is extracting the items in a tarball, all calls to &lt;code&gt;Cwd::cwd()&lt;/code&gt; can be avoided if we can guarantee that the current directory doesn't get changed externally.</source>
          <target state="translated">이후 &lt;code&gt;Archive::Tar&lt;/code&gt; 가에 타르에있는 항목, 모든 통화를 추출하는 동안 내부적으로 현재 디렉토리를 변경하지 않습니다 &lt;code&gt;Cwd::cwd()&lt;/code&gt; 우리가 현재 디렉토리 외부에서 변경되지 않음을 보장 할 수있는 경우를 피할 수있다.</target>
        </trans-unit>
        <trans-unit id="42aa5efcb3e75000fce11592bd84e59ec314928e" translate="yes" xml:space="preserve">
          <source>Since &lt;code&gt;SIGINT&lt;/code&gt; and &lt;code&gt;SIGQUIT&lt;/code&gt; are ignored during the execution of &lt;a href=&quot;#system-LIST&quot;&gt;&lt;code&gt;system&lt;/code&gt;&lt;/a&gt;, if you expect your program to terminate on receipt of these signals you will need to arrange to do so yourself based on the return value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c3c7a53144e6a3302e2a2f9e7b6229b194fa174" translate="yes" xml:space="preserve">
          <source>Since &lt;code&gt;SIGINT&lt;/code&gt; and &lt;code&gt;SIGQUIT&lt;/code&gt; are ignored during the execution of &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt;, if you expect your program to terminate on receipt of these signals you will need to arrange to do so yourself based on the return value.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; 실행 중에 &lt;code&gt;SIGINT&lt;/code&gt; 및 &lt;code&gt;SIGQUIT&lt;/code&gt; 는 무시 되므로 이러한 신호를 수신하여 프로그램이 종료 될 것으로 예상되는 경우 반환 값을 기준으로 직접 조치를 취해야합니다.</target>
        </trans-unit>
        <trans-unit id="e4f45d5c1543b43feed600201b8df9285b671829" translate="yes" xml:space="preserve">
          <source>Since &lt;code&gt;SIGINT&lt;/code&gt; and &lt;code&gt;SIGQUIT&lt;/code&gt; are ignored during the execution of &lt;code&gt;&lt;a href=&quot;system&quot;&gt;system&lt;/a&gt;&lt;/code&gt;, if you expect your program to terminate on receipt of these signals you will need to arrange to do so yourself based on the return value.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; 실행 중에 &lt;code&gt;SIGINT&lt;/code&gt; 및 &lt;code&gt;SIGQUIT&lt;/code&gt; 는 무시 되므로 이러한 신호를 수신하여 프로그램이 종료 될 것으로 예상되는 경우 반환 값을 기준으로 직접 조치를 취해야합니다.</target>
        </trans-unit>
        <trans-unit id="c78eaa920d9b2c6c4c17bb6231c81108ebdc9ea7" translate="yes" xml:space="preserve">
          <source>Since &lt;code&gt;XSRETURN_*&lt;/code&gt; macros can be used with CODE blocks as well, one can rewrite this example as:</source>
          <target state="translated">이후 &lt;code&gt;XSRETURN_*&lt;/code&gt; 매크로뿐만 아니라 코드 블록을 사용할 수 있습니다, 하나는이 예제를 다시 작성할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="ddeb2559b4a933dbff6f6bd50711c077c5250a4a" translate="yes" xml:space="preserve">
          <source>Since &lt;code&gt;use&lt;/code&gt; will also call the &lt;code&gt;import&lt;/code&gt; method, the actual value for &lt;code&gt;MODULE&lt;/code&gt; must be a bareword. That is, &lt;code&gt;use&lt;/code&gt; cannot load files by name, although &lt;code&gt;require&lt;/code&gt; can:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ae1fb90f2e2a999e504c7cb0f71e0777fa542ca" translate="yes" xml:space="preserve">
          <source>Since CPAN.pm version 1.88_51 modules declared as &lt;code&gt;build_requires&lt;/code&gt; by a distribution are treated differently depending on the config variable &lt;code&gt;build_requires_install_policy&lt;/code&gt; . By setting &lt;code&gt;build_requires_install_policy&lt;/code&gt; to &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt;&lt;/code&gt;, such a module is not installed. It is only built and tested, and then kept in the list of tested but uninstalled modules. As such, it is available during the build of the dependent module by integrating the path to the &lt;code&gt;blib/arch&lt;/code&gt; and &lt;code&gt;blib/lib&lt;/code&gt; directories in the environment variable PERL5LIB. If &lt;code&gt;build_requires_install_policy&lt;/code&gt; is set ti &lt;code&gt;yes&lt;/code&gt; , then both modules declared as &lt;code&gt;requires&lt;/code&gt; and those declared as &lt;code&gt;build_requires&lt;/code&gt; are treated alike. By setting to &lt;code&gt;ask/yes&lt;/code&gt; or &lt;code&gt;ask/&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt;&lt;/code&gt; , CPAN.pm asks the user and sets the default accordingly.</source>
          <target state="translated">분배에 의해 &lt;code&gt;build_requires&lt;/code&gt; 로 선언 된 CPAN.pm 버전 1.88_51 모듈 은 구성 변수 &lt;code&gt;build_requires_install_policy&lt;/code&gt; 에 따라 다르게 처리 됩니다. &lt;code&gt;build_requires_install_policy&lt;/code&gt; 를 &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt;&lt;/code&gt; 로 설정 하면 해당 모듈이 설치되지 않습니다. 빌드 및 테스트 된 다음 테스트되었지만 제거 된 모듈 목록에 보관됩니다. 따라서 환경 변수 PERL5LIB 의 &lt;code&gt;blib/arch&lt;/code&gt; 및 &lt;code&gt;blib/lib&lt;/code&gt; 디렉토리에 대한 경로를 통합하여 종속 모듈을 빌드하는 동안 사용 가능합니다 . &lt;code&gt;build_requires_install_policy&lt;/code&gt; 가 ti &lt;code&gt;yes&lt;/code&gt; 로 설정된 경우 모듈로 선언 된 모듈 &lt;code&gt;requires&lt;/code&gt; 과 모듈로 선언 된 모듈 &lt;code&gt;build_requires&lt;/code&gt; 로 동일 하게 취급됩니다. 을 설정하여 &lt;code&gt;ask/yes&lt;/code&gt; 또는 &lt;code&gt;ask/&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt;&lt;/code&gt; , CPAN.pm은 사용자에게 요청하고 그에 따라 기본값을 설정합니다.</target>
        </trans-unit>
        <trans-unit id="92bd94b93ba7aa98da9b694cc55416c0183aa164" translate="yes" xml:space="preserve">
          <source>Since DLLs may be loaded at run time, to have the same mechanism for DLLs one needs to have the address range of</source>
          <target state="translated">DLL은 런타임에로드 될 수 있으므로 DLL에 대해 동일한 메커니즘을 가지려면 주소 범위가 다음과 같아야합니다.</target>
        </trans-unit>
        <trans-unit id="b8d7eab0940cbd19c7e5c0a0410f1af9f2b70a97" translate="yes" xml:space="preserve">
          <source>Since Emacs version 19 patchlevel 22 or so, there have been both a perl-mode.el and support for the Perl debugger built in. These should come with the standard Emacs 19 distribution.</source>
          <target state="translated">Emacs 버전 19 패치 레벨 22 정도 이후로는 perl-mode.el과 Perl 디버거가 내장되어 있습니다. 표준 Emacs 19 배포판이 함께 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="ae992899a872766d28cfb8b692b2e7f7ecf24212" translate="yes" xml:space="preserve">
          <source>Since File::Spec is object oriented, subroutines should not be called directly, as in:</source>
          <target state="translated">File :: Spec은 객체 지향이므로 서브 루틴은 다음과 같이 직접 호출하면 안됩니다.</target>
        </trans-unit>
        <trans-unit id="58330cb00aafa72e888d41a23aef159c39b70e0c" translate="yes" xml:space="preserve">
          <source>Since INPUT sections allow declaration of C variables which do not appear in the parameter list of a subroutine, this may be shortened to:</source>
          <target state="translated">INPUT 섹션은 서브 루틴의 매개 변수리스트에 나타나지 않는 C 변수의 선언을 허용하므로 다음과 같이 단축 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="45546e69c804ad74560b03b1bfa0ada21545dbab" translate="yes" xml:space="preserve">
          <source>Since Math::BigInt and BigFloat also overload the normal math operations, the following line will still work:</source>
          <target state="translated">Math :: BigInt 및 BigFloat도 일반 수학 연산을 오버로드하므로 다음 행은 계속 작동합니다.</target>
        </trans-unit>
        <trans-unit id="1a22aa5b5825f973b9ba76849397ffcf019b0d3e" translate="yes" xml:space="preserve">
          <source>Since OS/2 port of perl uses a remarkable EMX environment, it can run (and build extensions, and - possibly - be built itself) under any environment which can run EMX. The current list is DOS, DOS-inside-OS/2, Win0.3*, Win0.95 and WinNT. Out of many perl flavors, only one works, see &lt;a href=&quot;#perl_.exe&quot;&gt;&quot;&lt;i&gt;perl_.exe&lt;/i&gt;&quot;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bfdb84eddf5f43124818a551b78d4d19bef89ac6" translate="yes" xml:space="preserve">
          <source>Since OS/2 port of perl uses a remarkable EMX environment, it can run (and build extensions, and - possibly - be built itself) under any environment which can run EMX. The current list is DOS, DOS-inside-OS/2, Win0.3*, Win0.95 and WinNT. Out of many perl flavors, only one works, see &lt;a href=&quot;#perl_.exe&quot;&gt;perl_.exe&lt;/a&gt;.</source>
          <target state="translated">perl의 OS / 2 포트는 현저한 EMX 환경을 사용하므로 EMX를 실행할 수있는 모든 환경에서 확장 (빌드 및 빌드 확장 가능)을 실행할 수 있습니다. 현재 목록은 DOS, DOS-inside-OS / 2, Win0.3 *, Win0.95 및 WinNT입니다. 많은 perl 풍미 중 하나만 작동합니다 ( &lt;a href=&quot;#perl_.exe&quot;&gt;perl_.exe&lt;/a&gt; 참조) .</target>
        </trans-unit>
        <trans-unit id="6084ebce66f9d95008fbd76add0c4721f5880c4b" translate="yes" xml:space="preserve">
          <source>Since PERL_SYS_INIT3() may change &lt;code&gt;env&lt;/code&gt; , it may be more appropriate to provide &lt;code&gt;env&lt;/code&gt; as an argument to perl_parse().</source>
          <target state="translated">PERL_SYS_INIT3 ()는 &lt;code&gt;env&lt;/code&gt; 를 변경할 수 있으므로 &lt;code&gt;env&lt;/code&gt; 를 perl_parse ()에 인수로 제공하는 것이 더 적절할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f7f8af64efb04a46b462c34b5604a1102a5d4309" translate="yes" xml:space="preserve">
          <source>Since PERL_SYS_INIT3() may change &lt;code&gt;env&lt;/code&gt;, it may be more appropriate to provide &lt;code&gt;env&lt;/code&gt; as an argument to perl_parse().</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="908c64d54ba36fa8efadd65bbb91e193ec071dc5" translate="yes" xml:space="preserve">
          <source>Since Perl 5.004, however, this situation is a special case and Perl creates the hash key only when you make the assignment:</source>
          <target state="translated">그러나 Perl 5.004 이후로이 상황은 특별한 경우이며 Perl은 지정을 할 때만 해시 키를 작성합니다.</target>
        </trans-unit>
        <trans-unit id="a9ff67b0f4d57746c4f60694c82d05a6c7b9009b" translate="yes" xml:space="preserve">
          <source>Since Perl 5.16.0, the &lt;code&gt;&lt;a href=&quot;functions/__sub__&quot;&gt;__SUB__&lt;/a&gt;&lt;/code&gt; token is available under &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature
'current_sub'&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; 5.16.0&lt;/code&gt; . It will evaluate to a reference to the currently-running sub, which allows for recursive calls without knowing your subroutine's name.</source>
          <target state="translated">펄 5.16.0 이후 &lt;code&gt;&lt;a href=&quot;functions/__sub__&quot;&gt;__SUB__&lt;/a&gt;&lt;/code&gt; 의 토큰은 아래에서 볼 수 있습니다 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature 'current_sub'&lt;/code&gt; 와 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; 5.16.0&lt;/code&gt; 합니다. 현재 실행중인 서브에 대한 참조로 평가되어 서브 루틴의 이름을 모르고 재귀 호출을 허용합니다.</target>
        </trans-unit>
        <trans-unit id="d1a3d1fb600646bfa2800199a2796c986b7ed30e" translate="yes" xml:space="preserve">
          <source>Since Perl 5.16.0, the &lt;code&gt;__SUB__&lt;/code&gt; token is available under &lt;code&gt;use feature 'current_sub'&lt;/code&gt; and &lt;code&gt;use 5.16.0&lt;/code&gt;. It will evaluate to a reference to the currently-running sub, which allows for recursive calls without knowing your subroutine's name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3fae0c1bd1740225eb42eb57769894f0dc25fdf8" translate="yes" xml:space="preserve">
          <source>Since Perl 5.18, the option &lt;code&gt;--libpods&lt;/code&gt; has been deprecated, and using this option did not do anything other than producing a warning.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8fd0c9118f331aebc3c70bcab476c8b369f379f5" translate="yes" xml:space="preserve">
          <source>Since Perl 5.26, this functionality with the extra parameter has been available by using a corresponding macro to each one of these, and whose name is formed by appending &lt;code&gt;_safe&lt;/code&gt; to the base name. There is no change to the functionality of those. For example, &lt;code&gt;isDIGIT_utf8_safe&lt;/code&gt; corresponds to &lt;code&gt;isDIGIT_utf8&lt;/code&gt;, and both now behave identically. All are documented in &lt;a href=&quot;perlapi#Character-case-changing&quot;&gt;&quot;Character case changing&quot; in perlapi&lt;/a&gt; and &lt;a href=&quot;perlapi#Character-classification&quot;&gt;&quot;Character classification&quot; in perlapi&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1fd1865b1bb90979ee802c45310e91e7b7152674" translate="yes" xml:space="preserve">
          <source>Since Perl 5.6.1 the special variables @- and @+ can functionally replace $`, $&amp;amp; and $'. These arrays contain pointers to the beginning and end of each match (see perlvar for the full story), so they give you essentially the same information, but without the risk of excessive string copying.</source>
          <target state="translated">Perl 5.6.1부터 특수 변수 @-및 @ +는 기능적으로 $`, $ &amp;amp; 및 $ '를 대체 할 수 있습니다. 이 배열에는 각 경기의 시작과 끝에 대한 포인터가 포함되어 있으므로 (전체 기사는 perlvar 참조) 본질적으로 동일한 정보를 제공하지만 과도한 문자열 복사의 위험이 없습니다.</target>
        </trans-unit>
        <trans-unit id="0c3b5811fc581b714a97d98184d154d442e77a68" translate="yes" xml:space="preserve">
          <source>Since Perl 5.8, thread programming has been available using a model called</source>
          <target state="translated">Perl 5.8부터 스레드 프로그래밍은</target>
        </trans-unit>
        <trans-unit id="8b1528960c7f653f3987ab48deb0e1d4226f3c72" translate="yes" xml:space="preserve">
          <source>Since Perl 5.8.0 a file handle referring to a string can be created by calling open with a reference to that string instead of the filename. This file handle can then be used to read from or write to the string:</source>
          <target state="translated">Perl 5.8.0부터는 파일 이름 대신 해당 문자열을 참조하여 open을 호출하여 문자열을 참조하는 파일 핸들을 작성할 수 있습니다. 그런 다음이 파일 핸들을 사용하여 문자열을 읽거나 문자열에 쓸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e4d8eb9b8b02c94511ca94b8a0081bc372e591a2" translate="yes" xml:space="preserve">
          <source>Since Perl 5.8.0, if the first two elements of the list are &lt;a href=&quot;#undef-EXPR&quot;&gt;&lt;code&gt;undef&lt;/code&gt;&lt;/a&gt;, the &lt;a href=&quot;http://man.he.net/man2/utime&quot;&gt;utime(2)&lt;/a&gt; syscall from your C library is called with a null second argument. On most systems, this will set the file's access and modification times to the current time (i.e., equivalent to the example above) and will work even on files you don't own provided you have write permission:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd9a4f3a496c7e0b6fbb6d2a333860ae199a0774" translate="yes" xml:space="preserve">
          <source>Since Perl 5.8.0, if the first two elements of the list are &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;, the utime(2) syscall from your C library is called with a null second argument. On most systems, this will set the file's access and modification times to the current time (i.e., equivalent to the example above) and will work even on files you don't own provided you have write permission:</source>
          <target state="translated">Perl 5.8.0부터 목록의 처음 두 요소가 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 인 경우 C 라이브러리의 utime (2) syscall이 널 (null) 초 인수와 함께 호출됩니다. 대부분의 시스템에서 이것은 파일의 액세스 및 수정 시간을 현재 시간으로 설정하고 (예 : 위의 예와 동일) 쓰기 권한이있는 경우 소유하지 않은 파일에서도 작동합니다.</target>
        </trans-unit>
        <trans-unit id="82732a952fbe092bd928ea5f2a3dfaabc967f5cd" translate="yes" xml:space="preserve">
          <source>Since Perl 5.8.0, if the first two elements of the list are &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;, the utime(2) syscall from your C library is called with a null second argument. On most systems, this will set the file's access and modification times to the current time (i.e., equivalent to the example above) and will work even on files you don't own provided you have write permission:</source>
          <target state="translated">Perl 5.8.0부터 목록의 처음 두 요소가 &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 인 경우 C 라이브러리의 utime (2) syscall이 널 (null) 초 인수와 함께 호출됩니다. 대부분의 시스템에서 이것은 파일의 액세스 및 수정 시간을 현재 시간으로 설정하고 (예 : 위의 예와 동일) 쓰기 권한이있는 경우 소유하지 않은 파일에서도 작동합니다.</target>
        </trans-unit>
        <trans-unit id="e51f3522d03a5b3a232bf4033ea382564508f931" translate="yes" xml:space="preserve">
          <source>Since Perl 5.8.0, signals have been made safer in Perl by postponing their handling until the interpreter is in a</source>
          <target state="translated">Perl 5.8.0 이후로, 통역사가</target>
        </trans-unit>
        <trans-unit id="f2d46e3f9d2d01548c43a50c625a8e637b891700" translate="yes" xml:space="preserve">
          <source>Since Perl 5.8.0, you can also use the list form of &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; for pipes. This is preferred when you wish to avoid having the shell interpret metacharacters that may be in your command string.</source>
          <target state="translated">Perl 5.8.0부터 파이프에 대해 목록 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; 형식을 사용할 수도 있습니다 . 쉘이 명령 문자열에있을 수있는 메타 문자를 해석하지 않도록하려는 경우에 선호됩니다.</target>
        </trans-unit>
        <trans-unit id="718a678663da5c7f9393577cff7fa0dc58227371" translate="yes" xml:space="preserve">
          <source>Since Perl 5.8.0, you can also use the list form of &lt;code&gt;open&lt;/code&gt; for pipes. This is preferred when you wish to avoid having the shell interpret metacharacters that may be in your command string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3480b6dbc008fbf05d437030616ffbd60db1a205" translate="yes" xml:space="preserve">
          <source>Since Perl 5.9.5</source>
          <target state="translated">Perl 이후 5.9.5</target>
        </trans-unit>
        <trans-unit id="ce3c317911640225ca1493860827b3b6d9d6a56f" translate="yes" xml:space="preserve">
          <source>Since Perl doesn't currently do anything with the &lt;code&gt;LC_MONETARY&lt;/code&gt; category, specifying &lt;code&gt;:monetary&lt;/code&gt; does effectively nothing. Some systems have other categories, such as &lt;code&gt;LC_PAPER&lt;/code&gt;, but Perl also doesn't do anything with them, and there is no way to specify them in this pragma's arguments.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83749785256b2bd98e45a0b0907ae739a924facc" translate="yes" xml:space="preserve">
          <source>Since Perl doesn't currently do anything with the &lt;code&gt;LC_MONETARY&lt;/code&gt; category, specifying &lt;code&gt;:monetary&lt;/code&gt; does effectively nothing. Some systems have other categories, such as &lt;code&gt;LC_PAPER_SIZE&lt;/code&gt; , but Perl also doesn't know anything about them, and there is no way to specify them in this pragma's arguments.</source>
          <target state="translated">Perl은 현재 &lt;code&gt;LC_MONETARY&lt;/code&gt; 범주를 사용하여 작업을 수행하지 않으므로 &lt;code&gt;:monetary&lt;/code&gt; 를 지정 하면 사실상 아무 작업도 수행되지 않습니다. 일부 시스템에는 &lt;code&gt;LC_PAPER_SIZE&lt;/code&gt; 와 같은 다른 범주가 있지만 Perl은 이에 대해 아무것도 알지 못 하므로이 pragma의 인수에서 시스템을 지정할 방법이 없습니다.</target>
        </trans-unit>
        <trans-unit id="7873f3b494192ca12067337abef4df445eb77998" translate="yes" xml:space="preserve">
          <source>Since Perl may compile the pattern at the moment of execution of the &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr()&lt;/a&gt;&lt;/code&gt; operator, using &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr()&lt;/a&gt;&lt;/code&gt; may have speed advantages in some situations, notably if the result of &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr()&lt;/a&gt;&lt;/code&gt; is used standalone:</source>
          <target state="translated">펄의 실행 시점의 패턴을 컴파일 할 수 있으므로 &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr()&lt;/a&gt;&lt;/code&gt; 하여, 운영자 &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr()&lt;/a&gt;&lt;/code&gt; 한 결과, 특히 경우, 어떤 상황에서는 고속의 장점을 가질 수있다 &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr()&lt;/a&gt;&lt;/code&gt; 사용하는 독립이다 :</target>
        </trans-unit>
        <trans-unit id="7ee8fc05b2f265e0275f90b02e962f3d6fb61694" translate="yes" xml:space="preserve">
          <source>Since Perl may compile the pattern at the moment of execution of the &lt;code&gt;qr()&lt;/code&gt; operator, using &lt;code&gt;qr()&lt;/code&gt; may have speed advantages in some situations, notably if the result of &lt;code&gt;qr()&lt;/code&gt; is used standalone:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a306c8d466811a3ef5f554b084c63b5f925fc7a3" translate="yes" xml:space="preserve">
          <source>Since Perl processes the &lt;code&gt;#!&lt;/code&gt; -line (cf. &lt;a href=&quot;perlrun#DESCRIPTION&quot;&gt;DESCRIPTION in perlrun&lt;/a&gt;, &lt;a href=&quot;perlrun#Command-Switches&quot;&gt;Command Switches in perlrun&lt;/a&gt;, &lt;a href=&quot;perldiag#No-Perl-script-found-in-input&quot;&gt;No Perl script found in input in perldiag&lt;/a&gt;), it should know when a program</source>
          <target state="translated">Perl은 &lt;code&gt;#!&lt;/code&gt; -line (참조 &lt;a href=&quot;perlrun#DESCRIPTION&quot;&gt;perlrun의 설명, perlrun&lt;/a&gt; 의 &lt;a href=&quot;perlrun#Command-Switches&quot;&gt;명령 스위치&lt;/a&gt; , &lt;a href=&quot;perldiag#No-Perl-script-found-in-input&quot;&gt;perldiag의 입력에서 Perl 스크립트를 찾을 수 없음&lt;/a&gt; ), 프로그램 시간을 알아야합니다</target>
        </trans-unit>
        <trans-unit id="15eed331802dca8328c200227a6895f19cb9da5d" translate="yes" xml:space="preserve">
          <source>Since Perl processes the &lt;code&gt;#!&lt;/code&gt;-line (cf. &lt;a href=&quot;perlrun#DESCRIPTION&quot;&gt;&quot;DESCRIPTION&quot; in perlrun&lt;/a&gt;, &lt;a href=&quot;perlrun#Command-Switches&quot;&gt;&quot;Command Switches&quot; in perlrun&lt;/a&gt;, &lt;a href=&quot;perldiag#No-Perl-script-found-in-input&quot;&gt;&quot;No Perl script found in input&quot; in perldiag&lt;/a&gt;), it should know when a program</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b7890be1aa1eaa7cb9334a73bda7962f1d481f1" translate="yes" xml:space="preserve">
          <source>Since Perl recognizes a Unicode Byte Order Mark at the start of files as signaling that the file is Unicode encoded as in UTF-16 (whether big-endian or little-endian) or UTF-8, Pod parsers should do the same. Otherwise, the character encoding should be understood as being UTF-8 if the first highbit byte sequence in the file seems valid as a UTF-8 sequence, or otherwise as CP-1252 (earlier versions of this specification used Latin-1 instead of CP-1252).</source>
          <target state="translated">Perl은 파일 시작 부분에서 파일이 UTF-16 (big-endian 또는 little-endian) 또는 UTF-8에서와 같이 유니 코드로 인코딩됨을 나타내는 신호로 유니 코드 바이트 순서 표시를 인식하므로 포드 파서는 동일하게 수행해야합니다. 그렇지 않으면 파일의 첫 번째 하이 비트 바이트 시퀀스가 ​​UTF-8 시퀀스로 유효하거나 CP-1252 (이 사양의 이전 버전에서는 CP 대신 라틴 -1을 사용함)로 문자 인코딩을 UTF-8로 이해해야합니다. -1252).</target>
        </trans-unit>
        <trans-unit id="ca8e547d2675a51d87227fd5471e1262dc702174" translate="yes" xml:space="preserve">
          <source>Since Perl v5.10.0 includes the version.pm comparison logic anyways, you don't need to do anything at all.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b73dcb8330d72308d60b51669745466fec012ac" translate="yes" xml:space="preserve">
          <source>Since Perl v5.22.0, calls to this function are optimized out on ASCII platforms, so there is no performance hit in using it there.</source>
          <target state="translated">Perl v5.22.0부터이 기능에 대한 호출은 ASCII 플랫폼에서 최적화되었으므로이 기능을 사용할 때 성능이 저하되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3b795b95acb54fe26d52c3d9e0c84f28d54d781c" translate="yes" xml:space="preserve">
          <source>Since Perl v5.6.0, Perl variable names may also be alphanumeric strings preceded by a caret. These must all be written in the form &lt;code&gt;${^Foo}&lt;/code&gt;; the braces are not optional. &lt;code&gt;${^Foo}&lt;/code&gt; denotes the scalar variable whose name is considered to be a control-&lt;code&gt;F&lt;/code&gt; followed by two &lt;code&gt;o&lt;/code&gt;'s. These variables are reserved for future special uses by Perl, except for the ones that begin with &lt;code&gt;^_&lt;/code&gt; (caret-underscore). No name that begins with &lt;code&gt;^_&lt;/code&gt; will acquire a special meaning in any future version of Perl; such names may therefore be used safely in programs. &lt;code&gt;$^_&lt;/code&gt; itself, however,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9077183204414786a18b0b5b41280a8b58d8fe93" translate="yes" xml:space="preserve">
          <source>Since Perl v5.6.0, Perl variable names may be alphanumeric strings that begin with a caret (or a control character, but this form is deprecated). These variables must be written in the form &lt;code&gt;${^Foo}&lt;/code&gt; ; the braces are not optional. &lt;code&gt;${^Foo}&lt;/code&gt; denotes the scalar variable whose name is a control-&lt;code&gt;F&lt;/code&gt; followed by two &lt;code&gt;o&lt;/code&gt; 's. These variables are reserved for future special uses by Perl, except for the ones that begin with &lt;code&gt;^_&lt;/code&gt; (control-underscore or caret-underscore). No control-character name that begins with &lt;code&gt;^_&lt;/code&gt; will acquire a special meaning in any future version of Perl; such names may therefore be used safely in programs. &lt;code&gt;$^_&lt;/code&gt; itself, however,</source>
          <target state="translated">Perl v5.6.0부터 Perl 변수 이름은 캐럿 (또는 제어 문자로 시작하지만이 양식은 더 이상 사용되지 않음)으로 시작하는 영숫자 문자열 일 수 있습니다. 이 변수는 &lt;code&gt;${^Foo}&lt;/code&gt; 형식으로 작성해야합니다 . 중괄호는 선택 사항이 아닙니다. &lt;code&gt;${^Foo}&lt;/code&gt; 는 이름이 control- &lt;code&gt;F&lt;/code&gt; 이고 두 개의 &lt;code&gt;o&lt;/code&gt; 가 오는 스칼라 변수를 나타냅니다 . 이 변수는 &lt;code&gt;^_&lt;/code&gt; (제어 밑줄 또는 캐럿 밑줄)로 시작하는 변수를 제외하고 Perl이 나중에 특수하게 사용하도록 예약되어 있습니다 . &lt;code&gt;^_&lt;/code&gt; 시작하는 제어 문자 이름은 향후 Perl 버전에서 특별한 의미를 갖지 않습니다. 따라서 이러한 이름은 프로그램에서 안전하게 사용할 수 있습니다. 그러나 &lt;code&gt;$^_&lt;/code&gt; 자체는</target>
        </trans-unit>
        <trans-unit id="33f810cef075561e9d829f100d7d5982e746f4f2" translate="yes" xml:space="preserve">
          <source>Since PodParser-1.24 the &lt;b&gt;Pod::Checker&lt;/b&gt; module uses only the &lt;b&gt;poderror&lt;/b&gt; method to print errors and warnings. The summary output (e.g. &quot;Pod syntax OK&quot;) has been dropped from the module and has been included in &lt;b&gt;podchecker&lt;/b&gt; (the script). This allows users of &lt;b&gt;Pod::Checker&lt;/b&gt; to control completely the output behavior. Users of &lt;b&gt;podchecker&lt;/b&gt; (the script) get the well-known behavior.</source>
          <target state="translated">PodParser-1.24부터 &lt;b&gt;Pod :: Checker&lt;/b&gt; 모듈은 &lt;b&gt;poderror&lt;/b&gt; 메소드 만 사용하여 오류 및 경고를 인쇄합니다. 요약 출력 (예 : &quot;Pod syntax OK&quot;)이 모듈에서 삭제되었으며 &lt;b&gt;podchecker&lt;/b&gt; (스크립트) 에 포함되었습니다 . 이를 통해 &lt;b&gt;Pod :: Checker&lt;/b&gt; 사용자 는 출력 동작을 완전히 제어 할 수 있습니다. &lt;b&gt;podchecker&lt;/b&gt; (스크립트) 사용자는 잘 알려진 동작을 얻습니다.</target>
        </trans-unit>
        <trans-unit id="25c4aa2f7c7ea22cd03f6256eb0cf383feb5378c" translate="yes" xml:space="preserve">
          <source>Since Storable version 2.05, CODE references may be serialized with the help of &lt;a href=&quot;B::Deparse&quot;&gt;B::Deparse&lt;/a&gt;. To enable this feature, set &lt;code&gt;$Storable::Deparse&lt;/code&gt; to a true value. To enable deserialization, &lt;code&gt;$Storable::Eval&lt;/code&gt; should be set to a true value. Be aware that deserialization is done through &lt;code&gt;eval&lt;/code&gt;, which is dangerous if the Storable file contains malicious data. You can set &lt;code&gt;$Storable::Eval&lt;/code&gt; to a subroutine reference which would be used instead of &lt;code&gt;eval&lt;/code&gt;. See below for an example using a &lt;a href=&quot;safe&quot;&gt;Safe&lt;/a&gt; compartment for deserialization of CODE references.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c62ae1b79550d7e8d8b071446dadbd144fa9a44a" translate="yes" xml:space="preserve">
          <source>Since Storable version 2.05, CODE references may be serialized with the help of &lt;a href=&quot;b/deparse&quot;&gt;B::Deparse&lt;/a&gt;. To enable this feature, set &lt;code&gt;$Storable::Deparse&lt;/code&gt; to a true value. To enable deserialization, &lt;code&gt;$Storable::Eval&lt;/code&gt; should be set to a true value. Be aware that deserialization is done through &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;, which is dangerous if the Storable file contains malicious data. You can set &lt;code&gt;$Storable::Eval&lt;/code&gt; to a subroutine reference which would be used instead of &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;. See below for an example using a &lt;a href=&quot;safe&quot;&gt;Safe&lt;/a&gt; compartment for deserialization of CODE references.</source>
          <target state="translated">Storable 버전 2.05부터 &lt;a href=&quot;b/deparse&quot;&gt;B :: Deparse&lt;/a&gt; 의 도움으로 CODE 참조가 직렬화 될 수 있습니다 . 이 기능을 사용하려면 &lt;code&gt;$Storable::Deparse&lt;/code&gt; 를 true 값으로 설정하십시오. 역 직렬화를 활성화하려면 &lt;code&gt;$Storable::Eval&lt;/code&gt; 을 true로 설정해야합니다. deserialization은 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 을 통해 수행 되므로 Storable 파일에 악성 데이터가 포함되어 있으면 위험합니다. &lt;code&gt;$Storable::Eval&lt;/code&gt; 을 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 대신 사용되는 서브 루틴 참조로 설정할 수 있습니다 . 코드 참조의 역 직렬화를 위해 &lt;a href=&quot;safe&quot;&gt;안전&lt;/a&gt; 구획을 사용하는 예는 아래를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c88a8ad5ec93e93fc48a98cd339628a0d0dbcb2e" translate="yes" xml:space="preserve">
          <source>Since UTF-7 is a 7-bit (re)encoded version of UTF-16BE, It is not part of Unicode's Character Encoding Scheme. It is separately implemented in Encode::Unicode::UTF7. For details see &lt;a href=&quot;Encode::Unicode::UTF7&quot;&gt;Encode::Unicode::UTF7&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0441a16b2e74d4d0e51c5a02d816d3fcef92571" translate="yes" xml:space="preserve">
          <source>Since UTF-7 is a 7-bit (re)encoded version of UTF-16BE, It is not part of Unicode's Character Encoding Scheme. It is separately implemented in Encode::Unicode::UTF7. For details see &lt;a href=&quot;unicode/utf7&quot;&gt;Encode::Unicode::UTF7&lt;/a&gt;.</source>
          <target state="translated">UTF-7은 UTF-16BE의 7 비트 (재) 인코딩 된 버전이므로 유니 코드의 문자 인코딩 체계에 포함되지 않습니다. Encode :: Unicode :: UTF7에서 별도로 구현됩니다. 자세한 내용은 &lt;a href=&quot;unicode/utf7&quot;&gt;Encode :: Unicode :: UTF7을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="2162d18e9f113918db80108542b383e4720b61a0" translate="yes" xml:space="preserve">
          <source>Since Unicode rules are not defined on these code points, if a Unicode-defined operation is done on them, Perl uses what we believe are sensible rules, while generally warning, using the &lt;code&gt;&quot;non_unicode&quot;&lt;/code&gt; category. For example, &lt;code&gt;&lt;a href=&quot;functions/uc&quot;&gt;uc(&quot;\x{11_0000}&quot;)&lt;/a&gt;&lt;/code&gt; will generate such a warning, returning the input parameter as its result, since Perl defines the uppercase of every non-Unicode code point to be the code point itself. (All the case changing operations, not just uppercasing, work this way.)</source>
          <target state="translated">이러한 코드 포인트에는 유니 코드 규칙이 정의되어 있지 않기 때문에 유니 코드 정의 작업이 수행되면 Perl은 &lt;code&gt;&quot;non_unicode&quot;&lt;/code&gt; 범주를 사용하여 일반적으로 경고하면서 합리적인 규칙을 사용합니다 . 예를 들어, &lt;code&gt;&lt;a href=&quot;functions/uc&quot;&gt;uc(&quot;\x{11_0000}&quot;)&lt;/a&gt;&lt;/code&gt; 는 이러한 경고를 생성하고 Perl은 모든 비 유니 코드 코드 포인트의 대문자를 코드 포인트 자체로 정의하므로 입력 매개 변수를 결과로 리턴합니다. (대문자뿐만 아니라 모든 경우 변경 작업은 이런 식으로 작동합니다.)</target>
        </trans-unit>
        <trans-unit id="e37eae9f276840962a41c4b116e9f1cbc6df456a" translate="yes" xml:space="preserve">
          <source>Since Unicode rules are not defined on these code points, if a Unicode-defined operation is done on them, Perl uses what we believe are sensible rules, while generally warning, using the &lt;code&gt;&quot;non_unicode&quot;&lt;/code&gt; category. For example, &lt;code&gt;uc(&quot;\x{11_0000}&quot;)&lt;/code&gt; will generate such a warning, returning the input parameter as its result, since Perl defines the uppercase of every non-Unicode code point to be the code point itself. (All the case changing operations, not just uppercasing, work this way.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7285a56d9c4d213c9ad280d3cdcf143edd27d7d8" translate="yes" xml:space="preserve">
          <source>Since VMS keeps track of files according to a different scheme than Unix, it's not really possible to represent the file's ID in the &lt;code&gt;st_dev&lt;/code&gt; and &lt;code&gt;st_ino&lt;/code&gt; fields of a &lt;code&gt;struct &lt;a href=&quot;functions/stat&quot;&gt;stat&lt;/a&gt;&lt;/code&gt; . Perl tries its best, though, and the values it uses are pretty unlikely to be the same for two different files. We can't guarantee this, though, so caveat scriptor.</source>
          <target state="translated">VMS는 Unix와 다른 방식으로 파일을 추적하기 때문에 &lt;code&gt;struct &lt;a href=&quot;functions/stat&quot;&gt;stat&lt;/a&gt;&lt;/code&gt; &lt;a href=&quot;functions/stat&quot;&gt;stat&lt;/a&gt; 의 &lt;code&gt;st_dev&lt;/code&gt; 및 &lt;code&gt;st_ino&lt;/code&gt; 필드 에서 파일의 ID를 나타내는 것은 실제로 불가능합니다 . Perl은 최선을 다하지만, 사용하는 값이 서로 다른 두 파일에서 동일하지는 않습니다. 그러나 이것을 보증 할 수는 없으므로주의해야합니다.</target>
        </trans-unit>
        <trans-unit id="f97165e0cc621ecf8ede47b3bb388f24e3bbd9ef" translate="yes" xml:space="preserve">
          <source>Since VMS keeps track of files according to a different scheme than Unix, it's not really possible to represent the file's ID in the &lt;code&gt;st_dev&lt;/code&gt; and &lt;code&gt;st_ino&lt;/code&gt; fields of a &lt;code&gt;struct stat&lt;/code&gt;. Perl tries its best, though, and the values it uses are pretty unlikely to be the same for two different files. We can't guarantee this, though, so caveat scriptor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c5a9b6174ae871df152be709da101732e21f32c" translate="yes" xml:space="preserve">
          <source>Since Windows has nothing as simple as an executable bit, we check the file extension.</source>
          <target state="translated">Windows는 실행 가능한 비트만큼 단순하지 않으므로 파일 확장자를 확인합니다.</target>
        </trans-unit>
        <trans-unit id="fd9730169823a0770803a5925e2496af06ca17b1" translate="yes" xml:space="preserve">
          <source>Since a TODO test does not need a reason, this function can return an empty string even when inside a TODO block. Use &lt;code&gt;$Test-&amp;gt;in_todo&lt;/code&gt; to determine if you are currently inside a TODO block.</source>
          <target state="translated">TODO 테스트는 이유가 필요하지 않으므로이 함수는 TODO 블록 내부에있는 경우에도 빈 문자열을 리턴 할 수 있습니다. &lt;code&gt;$Test-&amp;gt;in_todo&lt;/code&gt; 를 사용 하여 현재 TODO 블록 안에 있는지 판별하십시오.</target>
        </trans-unit>
        <trans-unit id="9ae46893bafbcba3b5e81c0b6866dc9c42e9443c" translate="yes" xml:space="preserve">
          <source>Since a wide character does not fit into a byte, the Digest::SHA routines croak if they encounter one. Whereas if a Unicode string contains no wide characters, the module accepts it quite happily. The following code illustrates the two cases:</source>
          <target state="translated">넓은 문자는 바이트에 맞지 않기 때문에 Digest :: SHA 루틴은 1을 만나면 삐걱 거립니다. 유니 코드 문자열에 넓은 문자가 포함되어 있지 않으면 모듈은이를 행복하게 받아들입니다. 다음 코드는 두 가지 경우를 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="cf5ecd8beadbfc6894afc9b33f8c568a935ac82c" translate="yes" xml:space="preserve">
          <source>Since all &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; directives are executed at compile-time, the only way to change overloading during run-time is to</source>
          <target state="translated">모든 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 지시문은 컴파일 타임에 실행 되므로 런타임 동안 오버로드를 변경하는 유일한 방법은</target>
        </trans-unit>
        <trans-unit id="993a10b235330ad1f20f4c41c806f9d2c3a4329f" translate="yes" xml:space="preserve">
          <source>Since all &lt;code&gt;use&lt;/code&gt; directives are executed at compile-time, the only way to change overloading during run-time is to</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="121e9d461e86db932f5cbbcefdf834cbc71c32ee" translate="yes" xml:space="preserve">
          <source>Since all numbers are not objects, you can use all functions that are part of the BigInt or BigFloat API. It is wise to use only the bxxx() notation, and not the fxxx() notation, though. This makes you independent on the fact that the underlying object might morph into a different class than BigFloat.</source>
          <target state="translated">모든 숫자는 객체가 아니므로 BigInt 또는 BigFloat API의 일부인 모든 함수를 사용할 수 있습니다. fxxx () 표기법이 아닌 bxxx () 표기법 만 사용하는 것이 좋습니다. 따라서 기본 개체가 BigFloat와 다른 클래스로 변형 될 수 있다는 사실에 독립적으로 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a8ab3cbd0a89b8927ddf254335c455bf7a9e0853" translate="yes" xml:space="preserve">
          <source>Since all numbers are now objects, you can use all functions that are part of the BigInt API. You can only use the bxxx() notation, and not the fxxx() notation, though.</source>
          <target state="translated">모든 숫자는 이제 객체이므로 BigInt API의 일부인 모든 함수를 사용할 수 있습니다. 그러나 fxxx () 표기법이 아닌 bxxx () 표기법 만 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4e2f7ef257d55f0fed05e16ea09bffefc9e8b92c" translate="yes" xml:space="preserve">
          <source>Since all numbers are now objects, you can use all functions that are part of the BigInt or BigFloat API. It is wise to use only the bxxx() notation, and not the fxxx() notation, though. This makes it possible that the underlying object might morph into a different class than BigFloat.</source>
          <target state="translated">모든 숫자는 이제 객체이므로 BigInt 또는 BigFloat API의 일부인 모든 함수를 사용할 수 있습니다. fxxx () 표기법이 아닌 bxxx () 표기법 만 사용하는 것이 좋습니다. 따라서 기본 개체가 BigFloat와 다른 클래스로 변형 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6baa6e390f30e8a9126d448dab3ed477bfa1776f" translate="yes" xml:space="preserve">
          <source>Since an expression &lt;code&gt;&quot;ab$cd,,&quot;&lt;/code&gt; is just a shortcut for &lt;code&gt;'ab' . $cd . ',,'&lt;/code&gt; , it is expected that overloaded constant strings are equipped with reasonable overloaded catenation operator, otherwise absurd results will result. Similarly, negative numbers are considered as negations of positive constants.</source>
          <target state="translated">표현식 &lt;code&gt;&quot;ab$cd,,&quot;&lt;/code&gt; 는 &lt;code&gt;'ab' . $cd . ',,'&lt;/code&gt; 바로 가기입니다 . $ cd. ',,' , 오버로드 된 상수 문자열에는 적절한 오버로드 된 catenation 연산자가 장착되어 있어야합니다. 그렇지 않으면 터무니없는 결과가 나타납니다. 마찬가지로 음수는 양의 상수에 대한 부정으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="9eab2e484706387d3cb0dc782cf2ac19206003e5" translate="yes" xml:space="preserve">
          <source>Since an expression &lt;code&gt;&quot;ab$cd,,&quot;&lt;/code&gt; is just a shortcut for &lt;code&gt;'ab' . $cd . ',,'&lt;/code&gt;, it is expected that overloaded constant strings are equipped with reasonable overloaded catenation operator, otherwise absurd results will result. Similarly, negative numbers are considered as negations of positive constants.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ad22ba0685e5d4fac9ab43140e5e8b95922e320" translate="yes" xml:space="preserve">
          <source>Since any scalar can be passed as a pattern, it's possible to implement an engine that does something with an array (&lt;code&gt;&quot;ook&quot; =~ [ qw/ eek
hlagh / ]&lt;/code&gt; ) or with the non-stringified form of a compiled regular expression (&lt;code&gt;&quot;ook&quot; =~ qr/eek/&lt;/code&gt; ). Perl's own engine will always stringify everything using the snippet above, but that doesn't mean other engines have to.</source>
          <target state="translated">스칼라를 패턴으로 전달할 수 있으므로 배열 ( &lt;code&gt;&quot;ook&quot; =~ [ qw/ eek hlagh / ]&lt;/code&gt; ) 또는 문자열 화되지 않은 형식의 컴파일 된 정규 표현식 ( &lt;code&gt;&quot;ook&quot; =~ qr/eek/&lt;/code&gt; 을 수행하는 엔진을 구현할 수 있습니다. ook &quot;= ~ qr / eek / ). Perl의 자체 엔진은 항상 위의 스 니펫을 사용하여 모든 것을 문자열 화하지만 다른 엔진이 그렇지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="a96aedcf3c01c8994f2ad1304c88bcd0b989eae9" translate="yes" xml:space="preserve">
          <source>Since any scalar can be passed as a pattern, it's possible to implement an engine that does something with an array (&lt;code&gt;&quot;ook&quot; =~ [ qw/ eek hlagh / ]&lt;/code&gt;) or with the non-stringified form of a compiled regular expression (&lt;code&gt;&quot;ook&quot; =~ qr/eek/&lt;/code&gt;). Perl's own engine will always stringify everything using the snippet above, but that doesn't mean other engines have to.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="641d084a3985af991bd9e2608e23022b03d9ab2f" translate="yes" xml:space="preserve">
          <source>Since blessed objects are actually stored as RV's, it is useful to use the typemap features to preprocess parameters and extract the actual SV stored within the blessed RV. See the sample for T_PTROBJ_SPECIAL below.</source>
          <target state="translated">축복받은 객체는 실제로 RV로 저장되므로 타입 맵 기능을 사용하여 매개 변수를 사전 처리하고 축복받은 RV에 저장된 실제 SV를 추출하는 것이 유용합니다. 아래의 T_PTROBJ_SPECIAL 샘플을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="8c4a595ff52b120e783068a746cfa5bbb3e02fd1" translate="yes" xml:space="preserve">
          <source>Since changing a slice changes the original array or hash that it's slicing, a &lt;code&gt;foreach&lt;/code&gt; construct will alter some--or even all--of the values of the array or hash.</source>
          <target state="translated">슬라이스를 변경하면 슬라이스하는 원래 배열이나 해시 가 변경되므로 &lt;code&gt;foreach&lt;/code&gt; 구문은 배열 또는 해시 값의 일부 또는 전체를 변경합니다.</target>
        </trans-unit>
        <trans-unit id="fe77918163189e19fb5ee32ad02fe79f3b55c3d3" translate="yes" xml:space="preserve">
          <source>Since code that runs both with and without threads is usually pretty messy, it's best to isolate the thread-specific code in its own module. In our example above, that's what &lt;code&gt;MyMod_threaded&lt;/code&gt; is, and it's only imported if we're running on a threaded Perl.</source>
          <target state="translated">스레드 유무에 관계없이 실행되는 코드는 일반적으로 매우 지저분하므로 스레드 특정 코드를 자체 모듈로 분리하는 것이 가장 좋습니다. 위의 예에서 이는 &lt;code&gt;MyMod_threaded&lt;/code&gt; 와 같 으며 스레드 된 Perl에서 실행중인 경우에만 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="7cbe078e4c38d00728f285597cf545219cabca7e" translate="yes" xml:space="preserve">
          <source>Since cygwin-1.7 pathnames are UTF-8 encoded.</source>
          <target state="translated">cygwin-1.7 경로 이름은 UTF-8로 인코딩되므로.</target>
        </trans-unit>
        <trans-unit id="266d3a18d9d36b211495f4b1c929d7f21c8d9c1c" translate="yes" xml:space="preserve">
          <source>Since cygwin-1.7 textmounts are deprecated and strongly discouraged.</source>
          <target state="translated">cygwin-1.7 텍스트 마운트는 더 이상 사용되지 않으며 사용하지 않는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="d1be23ed029f3a9d2b3315834beff1a066fe092b" translate="yes" xml:space="preserve">
          <source>Since environment variables are normally in all uppercase, no additional special formatting is generally needed; they're glaring enough as it is.</source>
          <target state="translated">환경 변수는 일반적으로 모두 대문자이므로 일반적으로 추가 특수 형식이 필요하지 않습니다. 그들은 충분히 눈부신 것입니다.</target>
        </trans-unit>
        <trans-unit id="7b1f94f3541d2fa04906c8d0560fd0adccde7ea8" translate="yes" xml:space="preserve">
          <source>Since evaluation of the translation function (see &lt;a href=&quot;#CUSTOM-TRANSLATORS&quot;&gt;&quot;CUSTOM TRANSLATORS&quot;&lt;/a&gt;) happens in the middle of compilation (of a string literal), the translation function should not do any &lt;code&gt;eval&lt;/code&gt;s or &lt;code&gt;require&lt;/code&gt;s. This restriction should be lifted (but is low priority) in a future version of Perl.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af76bf7b4202770a0de3b09fc13dec72dab7c4f4" translate="yes" xml:space="preserve">
          <source>Since evaluation of the translation function (see &lt;a href=&quot;#CUSTOM-TRANSLATORS&quot;&gt;CUSTOM TRANSLATORS&lt;/a&gt;) happens in the middle of compilation (of a string literal), the translation function should not do any &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;s or &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt;s. This restriction should be lifted (but is low priority) in a future version of Perl.</source>
          <target state="translated">번역 함수의 평가 ( &lt;a href=&quot;#CUSTOM-TRANSLATORS&quot;&gt;CUSTOM TRANSLATORS&lt;/a&gt; 참조 )는 컴파일 도중 (문자열 리터럴) 수행되므로 변환 함수는 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 수행 하거나 &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; 하지 않아야합니다 . 이후 버전의 Perl에서는이 제한을 해제해야합니다 (그러나 우선 순위는 낮음).</target>
        </trans-unit>
        <trans-unit id="e702e67c36d5f56f32c4ca887c029adc55bb2d25" translate="yes" xml:space="preserve">
          <source>Since file associations don't work everywhere, and there are reportedly bugs with file associations where it does work, the old method of wrapping the perl script to make it look like a regular batch file to the OS, may be used. The install process makes available the &quot;pl2bat.bat&quot; script which can be used to wrap perl scripts into batch files. For example:</source>
          <target state="translated">파일 연결은 모든 곳에서 작동하지 않으며 파일 연결과 관련하여 버그가있는 것으로 알려져 있기 때문에 펄 스크립트를 랩핑하여 일반 배치 파일처럼 보이도록하는 오래된 방법이 OS에 사용될 수 있습니다. 설치 프로세스는 &quot;pl2bat.bat&quot;스크립트를 사용하여 perl 스크립트를 배치 파일로 랩핑하는 데 사용할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="23fd0e0c0c88af650bd14da915c09ac6e76b1837" translate="yes" xml:space="preserve">
          <source>Since hash keys are strings, the default normalizer will not distinguish between &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; and the empty string. It also won't work when the function's arguments are references. For example, consider a function &lt;code&gt;g&lt;/code&gt; which gets two arguments: A number, and a reference to an array of numbers:</source>
          <target state="translated">해시 키는 문자열이므로 기본 노멀 라이저는 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 와 빈 문자열을 구분하지 않습니다 . 함수의 인수가 참조 인 경우에도 작동하지 않습니다. 예를 들어, 두 개의 인수, 숫자 및 숫자 배열에 대한 참조를 얻는 함수 &lt;code&gt;g&lt;/code&gt; 를 고려하십시오 .</target>
        </trans-unit>
        <trans-unit id="5436c585986115252a0eaae5572a50baa0e6e228" translate="yes" xml:space="preserve">
          <source>Since hash keys are strings, the default normalizer will not distinguish between &lt;code&gt;undef&lt;/code&gt; and the empty string. It also won't work when the function's arguments are references. For example, consider a function &lt;code&gt;g&lt;/code&gt; which gets two arguments: A number, and a reference to an array of numbers:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa1b02458a611387371114bfc83a2b6bef610aa1" translate="yes" xml:space="preserve">
          <source>Since in this example only the hostname was used, the redundant conversion of the port number into a service name may be omitted by passing the &lt;code&gt;NIx_NOSERV&lt;/code&gt; flag.</source>
          <target state="translated">이 예제에서는 호스트 이름 만 사용 &lt;code&gt;NIx_NOSERV&lt;/code&gt; 포트 번호를 서비스 이름으로 중복 변환하는 것은 NIx_NOSERV 플래그 를 전달하여 생략 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="43ba5f496d72ffff6bead4e713df055d0751d289" translate="yes" xml:space="preserve">
          <source>Since it is an actual &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt;&lt;/code&gt; (not a &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt;),</source>
          <target state="translated">실제 &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt;&lt;/code&gt; 이므로 ( &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; 아님),</target>
        </trans-unit>
        <trans-unit id="55f0899d2eb4523813b05345316dcef5758fc23e" translate="yes" xml:space="preserve">
          <source>Since it is an actual &lt;code&gt;do&lt;/code&gt; (not a &lt;code&gt;require&lt;/code&gt;),</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb621853d8928b75d75f89c40a84cc2ef109eca4" translate="yes" xml:space="preserve">
          <source>Since it is based on Linux, the NAS can run many popular Linux software packages, including Perl. In fact, Synology provides a ready-to-install package for Perl, depending on the version of DSM the installed perl ranges from 5.8.6 on DSM-4.3 to 5.24.0 on DSM-6.1.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d7acf7de7efee5f314675d9545729adcf4f4695" translate="yes" xml:space="preserve">
          <source>Since it is only at the compilation stage that the operator mask applies, controlled access to potentially unsafe operations can be achieved by having a handle to a wrapper subroutine (written outside the compartment) placed into the compartment. For example,</source>
          <target state="translated">오퍼레이터 마스크가 적용되는 것은 컴파일 단계에만 있기 때문에, 컴 파트먼트에 배치 된 래퍼 서브 루틴 (컴 파트먼트 외부에 기록됨)에 대한 핸들을 가짐으로써 잠재적으로 안전하지 않은 조작에 대한 제어 된 액세스를 달성 할 수 있습니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="1f11ca56ce1f8e288941a46d45decb0b96762c16" translate="yes" xml:space="preserve">
          <source>Since it's a common mistake to use &lt;a href=&quot;#exec-LIST&quot;&gt;&lt;code&gt;exec&lt;/code&gt;&lt;/a&gt; instead of &lt;a href=&quot;#system-LIST&quot;&gt;&lt;code&gt;system&lt;/code&gt;&lt;/a&gt;, Perl warns you if &lt;a href=&quot;#exec-LIST&quot;&gt;&lt;code&gt;exec&lt;/code&gt;&lt;/a&gt; is called in void context and if there is a following statement that isn't &lt;a href=&quot;#die-LIST&quot;&gt;&lt;code&gt;die&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#warn-LIST&quot;&gt;&lt;code&gt;warn&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;#exit-EXPR&quot;&gt;&lt;code&gt;exit&lt;/code&gt;&lt;/a&gt; (if &lt;a href=&quot;warnings&quot;&gt;warnings&lt;/a&gt; are enabled--but you always do that, right?). If you</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="194e3b48a27a3bdaa4b431c05b89584d736f7041" translate="yes" xml:space="preserve">
          <source>Since it's a common mistake to use &lt;code&gt;&lt;a href=&quot;exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; instead of &lt;code&gt;&lt;a href=&quot;system&quot;&gt;system&lt;/a&gt;&lt;/code&gt;, Perl warns you if &lt;code&gt;&lt;a href=&quot;exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; is called in void context and if there is a following statement that isn't &lt;code&gt;&lt;a href=&quot;die&quot;&gt;die&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;warn&quot;&gt;warn&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;exit&quot;&gt;exit&lt;/a&gt;&lt;/code&gt; (if &lt;code&gt;-w&lt;/code&gt; is set--but you always do that, right?). If you</source>
          <target state="translated">그것을 사용하는 일반적인 실수 때문에 &lt;code&gt;&lt;a href=&quot;exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; 대신 &lt;code&gt;&lt;a href=&quot;system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; , 펄 경우 경고 &lt;code&gt;&lt;a href=&quot;exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; 무효 컨텍스트에서 호출되고 다음되지 않은 문이있는 경우 &lt;code&gt;&lt;a href=&quot;die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;warn&quot;&gt;warn&lt;/a&gt;&lt;/code&gt; , 또는 &lt;code&gt;&lt;a href=&quot;exit&quot;&gt;exit&lt;/a&gt;&lt;/code&gt; 하는 경우 ( &lt;code&gt;-w&lt;/code&gt; 가 설정 -하지만 항상 당신을 그렇죠?) 만약 너라면</target>
        </trans-unit>
        <trans-unit id="84dfc8fed05280b5766bcde26ffe3ad58754f68f" translate="yes" xml:space="preserve">
          <source>Since it's a common mistake to use &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; instead of &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt;, Perl warns you if &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; is called in void context and if there is a following statement that isn't &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/warn&quot;&gt;warn&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit&lt;/a&gt;&lt;/code&gt; (if &lt;code&gt;-w&lt;/code&gt; is set--but you always do that, right?). If you</source>
          <target state="translated">그것을 사용하는 일반적인 실수 때문에 &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; 대신 &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; , 펄 경우 경고 &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; 무효 컨텍스트에서 호출되고 다음되지 않은 문이있는 경우 &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/warn&quot;&gt;warn&lt;/a&gt;&lt;/code&gt; , 또는 &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit&lt;/a&gt;&lt;/code&gt; 하는 경우 ( &lt;code&gt;-w&lt;/code&gt; 가 설정 -하지만 항상 당신을 그렇죠?) 만약 너라면</target>
        </trans-unit>
        <trans-unit id="738084392e8e6e74486d375f063b4666c3458a7c" translate="yes" xml:space="preserve">
          <source>Since just passing an SV to an XS function and copying the data of the SV is not enough to copy the UTF8 flags, even less right is just passing a &lt;code&gt;char *&lt;/code&gt; to an XS function.</source>
          <target state="translated">SV를 XS 함수에 전달하고 SV의 데이터를 복사하는 것만으로는 UTF8 플래그를 복사하기에 충분하지 않으므로 &lt;code&gt;char *&lt;/code&gt; 를 XS 함수에 전달하는 것만으로는 부족 합니다.</target>
        </trans-unit>
        <trans-unit id="b9469e3eb840b801f9d7d7208ec99b06d836b6ea" translate="yes" xml:space="preserve">
          <source>Since kernel threading can interrupt a thread at any time, they will uncover some of the implicit locking assumptions you may make in your program. For example, something as simple as &lt;code&gt;$x = $x + 2&lt;/code&gt; can behave unpredictably with kernel threads if &lt;code&gt;$x&lt;/code&gt; is visible to other threads, as another thread may have changed &lt;code&gt;$x&lt;/code&gt; between the time it was fetched on the right hand side and the time the new value is stored.</source>
          <target state="translated">커널 스레딩은 언제든지 스레드를 중단 할 수 있으므로 프로그램에서 내재 된 잠금 가정 중 일부를 발견합니다. 예를 들어, 간단하게 무언가에 대해서는 &lt;code&gt;$x = $x + 2&lt;/code&gt; 있으면 커널 스레드 예기치 못한 방식으로 동작 할 수 &lt;code&gt;$x&lt;/code&gt; 다른 스레드에 보이는 다른 스레드가 변경 될 수 있으므로, &lt;code&gt;$x&lt;/code&gt; 그 우측 및에 페치 된 시간 사이 새로운 값이 저장되는 시간.</target>
        </trans-unit>
        <trans-unit id="50bf4cd3ab25a16dfb39690f40c89ca9d71697ee" translate="yes" xml:space="preserve">
          <source>Since many pieces of code create tiny subroutines consisting of only a few ops, and since a huge slab would be quite a bit of baggage for those to carry around, the first slab is always very small. To avoid allocating too many slabs for a single CV, each subsequent slab is twice the size of the previous.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c3c7d09052cf4af0cf4ad320357c5a1a11966392" translate="yes" xml:space="preserve">
          <source>Since numbers are actually objects, you can call all the usual methods from BigInt/BigFloat on them. This even works to some extent on expressions:</source>
          <target state="translated">숫자는 실제로 객체이므로 BigInt / BigFloat에서 모든 일반적인 메소드를 호출 할 수 있습니다. 이것은 표현식에서도 어느 정도 작동합니다.</target>
        </trans-unit>
        <trans-unit id="ae2a46b8ade0fb9460587cc2799fe61eb4a8fb37" translate="yes" xml:space="preserve">
          <source>Since perl 5.17.1</source>
          <target state="translated">펄 5.17.1 이후</target>
        </trans-unit>
        <trans-unit id="3f51453ac56d21d59ae3e879a25ac51097e95502" translate="yes" xml:space="preserve">
          <source>Since perl does not (yet?) support constant objects, these constants are in seconds only, so you cannot, for example, do this: &lt;code&gt;&lt;a href=&quot;../functions/print&quot;&gt;print&lt;/a&gt; ONE_WEEK-&amp;gt;minutes;&lt;/code&gt;</source>
          <target state="translated">perl은 상수 객체를 지원하지 않기 때문에 이러한 상수는 초 단위이므로 예를 들어 다음을 수행 할 수 없습니다. &lt;code&gt;&lt;a href=&quot;../functions/print&quot;&gt;print&lt;/a&gt; ONE_WEEK-&amp;gt;minutes;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="cab6e87a3c1e5785b11343a6d4dd9e12fc5fa718" translate="yes" xml:space="preserve">
          <source>Since perl does not (yet?) support constant objects, these constants are in seconds only, so you cannot, for example, do this: &lt;code&gt;print ONE_WEEK-&amp;gt;minutes;&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ea4faada9587774e63ccd6c739ed955f5067def" translate="yes" xml:space="preserve">
          <source>Since pi &amp;asymp; 355/116 is only accurate to 6 decimal places, you would want to say:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6206d48617efe1643080f044370ee3db2757b71" translate="yes" xml:space="preserve">
          <source>Since release 1.77, CPAN.pm has been able to verify cryptographically signed module distributions using Module::Signature. The CPAN modules can be signed by their authors, thus giving more security. The simple unsigned MD5 checksums that were used before by CPAN protect mainly against accidental file corruption.</source>
          <target state="translated">릴리스 1.77부터 CPAN.pm은 Module :: Signature를 사용하여 암호화 서명 된 모듈 배포를 확인할 수있었습니다. CPAN 모듈은 작성자가 서명 할 수 있으므로 보안이 강화됩니다. CPAN에 의해 ​​이전에 사용되었던 단순한 서명되지 않은 MD5 체크섬은 주로 우발적 인 파일 손상으로부터 보호합니다.</target>
        </trans-unit>
        <trans-unit id="f410d2ff83f136d497487286db5d2eccb910e974" translate="yes" xml:space="preserve">
          <source>Since some operations can be automatically generated from others, there is a minimal set of operations that need to be overloaded in order to have the complete set of overloaded operations at one's disposal. Of course, the autogenerated operations may not do exactly what the user expects. The minimal set is:</source>
          <target state="translated">일부 작업은 다른 작업에서 자동으로 생성 될 수 있으므로 사용자가 원하는대로 전체 오버로드 작업 집합을 갖기 위해 오버로드해야하는 최소 작업 집합이 있습니다. 물론, 자동 생성 된 작업은 사용자가 기대하는 것과 정확히 일치하지 않을 수 있습니다. 최소 설정은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9e13ee98073f6b6ff77b6bcc87f449d4c9298e6d" translate="yes" xml:space="preserve">
          <source>Since static extensions are incorporated directly into</source>
          <target state="translated">정적 확장은</target>
        </trans-unit>
        <trans-unit id="a88aba659efeb2d72344fd5945ed041580ceab14" translate="yes" xml:space="preserve">
          <source>Since storage is performed recursively, you might want to stuff references to objects that share a lot of common data into a single array or hash table, and then store that object. That way, when you retrieve back the whole thing, the objects will continue to share what they originally shared.</source>
          <target state="translated">스토리지는 재귀 적으로 수행되므로 많은 공통 데이터를 공유하는 오브젝트에 대한 참조를 단일 배열 또는 해시 테이블에 넣은 다음 해당 오브젝트를 저장하려고 할 수 있습니다. 이렇게하면 전체를 다시 검색 할 때 객체가 원래 공유 한 내용을 계속 공유합니다.</target>
        </trans-unit>
        <trans-unit id="9ba4735b13fee2b9416d8bafb7be0fc636ca00de" translate="yes" xml:space="preserve">
          <source>Since subroutines implementing assignment operators are not required to modify their operands (see &lt;a href=&quot;#Overloadable-Operations&quot;&gt;&quot;Overloadable Operations&quot;&lt;/a&gt; above), we do not need anything special to make &lt;code&gt;+=&lt;/code&gt; and friends work, besides adding these operators to %subr and defining a copy constructor (needed since Perl has no way to know that the implementation of &lt;code&gt;'+='&lt;/code&gt; does not mutate the argument - see &lt;a href=&quot;#Copy-Constructor&quot;&gt;&quot;Copy Constructor&quot;&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4b31e0831fe480c7543658e6a5c02d003d2e334" translate="yes" xml:space="preserve">
          <source>Since subroutines implementing assignment operators are not required to modify their operands (see &lt;a href=&quot;#Overloadable-Operations&quot;&gt;Overloadable Operations&lt;/a&gt; above), we do not need anything special to make &lt;code&gt;+=&lt;/code&gt; and friends work, besides adding these operators to %subr and defining a copy constructor (needed since Perl has no way to know that the implementation of &lt;code&gt;'+='&lt;/code&gt; does not mutate the argument - see &lt;a href=&quot;#Copy-Constructor&quot;&gt;Copy Constructor&lt;/a&gt;).</source>
          <target state="translated">할당 연산자를 구현하는 서브 루틴은 피연산자를 수정하지 않아도되므로 ( 위의 &lt;a href=&quot;#Overloadable-Operations&quot;&gt;오버로드 가능한 연산&lt;/a&gt; 참조), % subr에 이러한 연산자를 추가하고 복사 생성자를 정의하는 것 외에 &lt;code&gt;+=&lt;/code&gt; 와 친구를 작동 시키는 데 특별한 것이 필요하지 않습니다 (Perl은 &lt;code&gt;'+='&lt;/code&gt; 의 구현이 인수를 변경하지 않는다는 것을 알 수있는 방법 은 없습니다 ( &lt;a href=&quot;#Copy-Constructor&quot;&gt;복사 생성자&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="39828fbb336c2f70993a4540589d36ff13c1f2fe" translate="yes" xml:space="preserve">
          <source>Since such a construct is equivalent to using an empty string, you are recommended to remove such &lt;code&gt;\N{}&lt;/code&gt; constructs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="24efb6846ccb0dd586c9a2d632cd24665dcacdba" translate="yes" xml:space="preserve">
          <source>Since the &lt;code&gt;UNIVERSAL::VERSION&lt;/code&gt; method treats the &lt;code&gt;$VERSION&lt;/code&gt; number as a simple numeric value it will regard version 1.10 as lower than 1.9. For this reason it is strongly recommended that you use numbers with at least two decimal places, e.g., 1.09.</source>
          <target state="translated">때문에 &lt;code&gt;UNIVERSAL::VERSION&lt;/code&gt; 메소드를 대우 &lt;code&gt;$VERSION&lt;/code&gt; 간단한 숫자 값 번호는보다 낮은 1.9 버전 1.10 간주한다. 이러한 이유로 소수점 이하 두 자리 이상 (예 : 1.09)의 숫자를 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="9984a40959f39d46f91cc9c90e354da67e76965d" translate="yes" xml:space="preserve">
          <source>Since the &lt;code&gt;ops&lt;/code&gt; pragma currently has an irreversible global effect, it is only of significant practical use with the &lt;code&gt;-M&lt;/code&gt; option on the command line.</source>
          <target state="translated">때문에 &lt;code&gt;ops&lt;/code&gt; 프라그는 현재 돌이킬 수없는 글로벌 효과가있다, 그것은 단지와 중요한 실용적이다 &lt;code&gt;-M&lt;/code&gt; 의 명령 행 옵션을 선택합니다.</target>
        </trans-unit>
        <trans-unit id="953376be0c1beefb5a7844380d81b187b71cbf9b" translate="yes" xml:space="preserve">
          <source>Since the CV takes ownership of its slab when flagged, that flag is never copied when a CV is cloned, as one CV could free a slab that another CV still points to, since forced freeing of ops ignores the reference count (but asserts that it looks right).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="926a29507017e24c08c49eb96c57773fd03c95dd" translate="yes" xml:space="preserve">
          <source>Since the MD5 algorithm is byte oriented you might only add bits as multiples of 8, so you probably want to just use add() instead. The add_bits() method is provided for compatibility with other digest implementations. See &lt;a href=&quot;../digest&quot;&gt;Digest&lt;/a&gt; for description of the arguments that add_bits() take.</source>
          <target state="translated">MD5 알고리즘은 바이트 지향이므로 비트를 8의 배수로 만 추가 할 수 있으므로 add ()를 대신 사용하려고합니다. add_bits () 메소드는 다른 다이제스트 구현과의 호환성을 위해 제공됩니다. add_bits ()가 취하는 인수에 대한 설명은 &lt;a href=&quot;../digest&quot;&gt;Digest&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b38cceb121fc001ce43895b005634147912b7f28" translate="yes" xml:space="preserve">
          <source>Since the MD5 algorithm is byte oriented you might only add bits as multiples of 8, so you probably want to just use add() instead. The add_bits() method is provided for compatibility with other digest implementations. See &lt;a href=&quot;digest&quot;&gt;Digest&lt;/a&gt; for description of the arguments that add_bits() take.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fcf00ba41dfb6029d72bbfa314d984c685681962" translate="yes" xml:space="preserve">
          <source>Since the MD5 algorithm is only defined for strings of bytes, it can not be used on strings that contains chars with ordinal number above 255 (Unicode strings). The MD5 functions and methods will croak if you try to feed them such input data:</source>
          <target state="translated">MD5 알고리즘은 바이트 문자열에만 정의되므로 서 수가 255 (유니 코드 문자열)보다 큰 문자를 포함하는 문자열에는 사용할 수 없습니다. MD5 함수 및 메소드는 이러한 입력 데이터를 제공하려고 시도하면 사라집니다.</target>
        </trans-unit>
        <trans-unit id="4504893c7038fe54de5cf229bf7abc99b79c512f" translate="yes" xml:space="preserve">
          <source>Since the Perl extension DLLs are always loaded with the full path, there is no need to mangle their names in a version-specific ways: their directory already reflects the corresponding version of perl, and @INC takes into account binary compatibility with older version. Starting from &lt;code&gt;5.6.2&lt;/code&gt; the name mangling scheme is fixed to be the same as for Perl 5.005_53 (same as in a popular binary release). Thus new Perls will be able to</source>
          <target state="translated">Perl 확장 DLL은 항상 전체 경로로로드되므로 버전 별 방식으로 이름을 엉망으로 만들 필요가 없습니다. 디렉토리에는 이미 해당 버전의 perl이 반영되어 있으며 @INC는 이전 버전과의 이진 호환성을 고려합니다. &lt;code&gt;5.6.2&lt;/code&gt; 부터 이름 관리 체계는 Perl 5.005_53과 동일하도록 수정되었습니다 (일반적인 바이너리 릴리스와 동일). 따라서 새로운 Perls는</target>
        </trans-unit>
        <trans-unit id="d9753e3adbb08c389f10d17cb835e755759949e1" translate="yes" xml:space="preserve">
          <source>Since the VMS linker distinguishes symbols based only on the first 31 characters of their names, it is occasionally necessary to shorten symbol names in order to avoid collisions. (This is especially true of names generated by xsubpp, since prefixes generated by nested package names can become quite long.) &lt;code&gt;ExtUtils::XSSymSet&lt;/code&gt; provides functions to shorten names in a consistent fashion, and to track a set of names to insure that each is unique. While designed with</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3bc7c77475d3cf936d8648a172f314719ec1f56" translate="yes" xml:space="preserve">
          <source>Since the first character of $x matched the regex, &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; prepended an empty initial element to the list.</source>
          <target state="translated">$ x의 첫 문자가 정규식과 일치했기 때문에 &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; 은 빈 초기 요소 앞에 목록을 추가했습니다.</target>
        </trans-unit>
        <trans-unit id="e30d9369cb9f674a0338e525db18f9f146fc0752" translate="yes" xml:space="preserve">
          <source>Since the first character of $x matched the regex, &lt;code&gt;split&lt;/code&gt; prepended an empty initial element to the list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2334de3a289af7777d7979b79868746517ddea3f" translate="yes" xml:space="preserve">
          <source>Since the first character of $x matched the regexp, &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; prepended an empty initial element to the list.</source>
          <target state="translated">$ x의 첫 문자가 정규 표현식과 일치하므로 &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; 은 빈 초기 요소 앞에 목록을 추가했습니다.</target>
        </trans-unit>
        <trans-unit id="dfb32be28d90dd8cfadf42b0da79f140a1aebe0c" translate="yes" xml:space="preserve">
          <source>Since the first character of &lt;code&gt;$x&lt;/code&gt; matched the regexp, &lt;code&gt;split&lt;/code&gt; prepended an empty initial element to the list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c9108eba2d411db85e70e8df1569d830e2a5d25c" translate="yes" xml:space="preserve">
          <source>Since the fork() emulation runs code in multiple threads, extensions calling into non-thread-safe libraries may not work reliably when calling fork(). As Perl's threading support gradually becomes more widely adopted even on platforms with a native fork(), such extensions are expected to be fixed for thread-safety.</source>
          <target state="translated">fork () 에뮬레이션은 여러 스레드에서 코드를 실행하기 때문에 스레드가 안전하지 않은 라이브러리를 호출하는 확장은 fork ()를 호출 할 때 안정적으로 작동하지 않을 수 있습니다. Perl의 스레딩 지원은 기본 포크 ()가있는 플랫폼에서도 점점 더 널리 채택됨에 따라 이러한 확장은 스레드 안전성을 위해 수정 될 것으로 예상됩니다.</target>
        </trans-unit>
        <trans-unit id="b5c6d6292298eef29abac825fb611cdb8dbc410b" translate="yes" xml:space="preserve">
          <source>Since the logging doesn't use PerlIO, all SV allocations are logged and no extra SV allocations are introduced by enabling the logging. If compiled with &lt;code&gt;-DDEBUG_LEAKING_SCALARS&lt;/code&gt; , the serial number for each SV allocation is also logged.</source>
          <target state="translated">로깅은 PerlIO를 사용하지 않으므로 모든 SV 할당이 기록되고 로깅을 활성화하여 추가 SV 할당이 도입되지 않습니다. &lt;code&gt;-DDEBUG_LEAKING_SCALARS&lt;/code&gt; 로 컴파일하면 각 SV 할당의 일련 번호도 기록됩니다.</target>
        </trans-unit>
        <trans-unit id="3e539eeb6fc84357572fa6a057c29a86c8133533" translate="yes" xml:space="preserve">
          <source>Since the logging doesn't use PerlIO, all SV allocations are logged and no extra SV allocations are introduced by enabling the logging. If compiled with &lt;code&gt;-DDEBUG_LEAKING_SCALARS&lt;/code&gt;, the serial number for each SV allocation is also logged.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3279571aa6d0a69a5a2abdeb30f262cc44dbbdae" translate="yes" xml:space="preserve">
          <source>Since the match operator &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m//&lt;/a&gt;&lt;/code&gt;, the substitution operator &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt;, and the regular expression quoting operator &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt; are double-quotish constructs, you can interpolate variables into the pattern. See the answer to &quot;How can I quote a variable to use in a regex?&quot; for more details.</source>
          <target state="translated">일치 연산자 &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m//&lt;/a&gt;&lt;/code&gt; , 대체 연산자 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt; 및 정규식 인용 연산자 &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt; 는 큰 따옴표 구조이므로 변수를 패턴에 보간 할 수 있습니다. &quot;정규식에서 사용할 변수를 어떻게 인용 할 수 있습니까?&quot;에 대한 답변을 참조하십시오. 상세 사항은.</target>
        </trans-unit>
        <trans-unit id="7344ea0eab36d0c1c0f9a8a859bf628b21f3791b" translate="yes" xml:space="preserve">
          <source>Since the match operator &lt;code&gt;m//&lt;/code&gt;, the substitution operator &lt;code&gt;s///&lt;/code&gt;, and the regular expression quoting operator &lt;code&gt;qr//&lt;/code&gt; are double-quotish constructs, you can interpolate variables into the pattern. See the answer to &quot;How can I quote a variable to use in a regex?&quot; for more details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="84b10458d44f04e31c63c483bc8240735b5e37c7" translate="yes" xml:space="preserve">
          <source>Since the null filehandle uses the two argument form of &lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt; it interprets special characters, so if you have a script like this:</source>
          <target state="translated">널 파일 핸들은 &lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt; 의 두 인수 형식을 사용 하므로 특수 문자를 해석하므로 다음과 같은 스크립트가있는 경우 :</target>
        </trans-unit>
        <trans-unit id="66fb7ce305be412987d9aacf9b06a1422f1fe031" translate="yes" xml:space="preserve">
          <source>Since the null filehandle uses the two argument form of &lt;a href=&quot;perlfunc#open&quot;&gt;&quot;open&quot; in perlfunc&lt;/a&gt; it interprets special characters, so if you have a script like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd81accbd1bb6c167fba1a41e5f2407058ac7a87" translate="yes" xml:space="preserve">
          <source>Since the object is also a hash, you can treat it as one, using it to store data associated with the object. Typically, code inside the class can treat the hash as an accessible data structure, while code outside the class should always treat the object as opaque. This is called &lt;b&gt;encapsulation&lt;/b&gt;. Encapsulation means that the user of an object does not have to know how it is implemented. The user simply calls documented methods on the object.</source>
          <target state="translated">객체도 해시이므로 객체와 관련된 데이터를 저장하기 위해 객체를 사용하여 객체로 취급 할 수 있습니다. 일반적으로 클래스 내부의 코드는 해시를 액세스 가능한 데이터 구조로 취급 할 수 있지만 클래스 외부의 코드는 항상 객체를 불투명하게 처리해야합니다. 이것을 &lt;b&gt;캡슐화&lt;/b&gt; 라고 &lt;b&gt;합니다&lt;/b&gt; . 캡슐화는 객체의 사용자가 어떻게 구현되는지 알 필요가 없음을 의미합니다. 사용자는 단순히 객체에 대해 문서화 된 메소드를 호출합니다.</target>
        </trans-unit>
        <trans-unit id="db12f27020b74e90b153b0c7282afabc69308986" translate="yes" xml:space="preserve">
          <source>Since the original &lt;code&gt;big5&lt;/code&gt; encoding (1984) is not supported anywhere (glibc and DOS-based systems uses &lt;code&gt;big5&lt;/code&gt; to mean &lt;code&gt;big5-eten&lt;/code&gt; ; Microsoft uses &lt;code&gt;big5&lt;/code&gt; to mean &lt;code&gt;cp950&lt;/code&gt; ), a conscious decision was made to alias &lt;code&gt;big5&lt;/code&gt; to &lt;code&gt;big5-eten&lt;/code&gt; , which is the de facto superset of the original big5.</source>
          <target state="translated">원래부터 &lt;code&gt;big5&lt;/code&gt; 인코딩 (1984)는 어디서나 지원되지 않습니다 (glibc에와 DOS 기반 시스템 사용의 &lt;code&gt;big5&lt;/code&gt; 에 평균 &lt;code&gt;big5-eten&lt;/code&gt; , Microsoft에서 사용 &lt;code&gt;big5&lt;/code&gt; 의미하는 &lt;code&gt;cp950&lt;/code&gt; ) 의식적인 결정이 별명에 만들어진, &lt;code&gt;big5&lt;/code&gt; 에 &lt;code&gt;big5-eten&lt;/code&gt; 이다 원래 big5의 사실상 수퍼 셋.</target>
        </trans-unit>
        <trans-unit id="d8d087310b96c8a2161d52fb071f50cb14fd5ed5" translate="yes" xml:space="preserve">
          <source>Since the original &lt;code&gt;big5&lt;/code&gt; encoding (1984) is not supported anywhere (glibc and DOS-based systems uses &lt;code&gt;big5&lt;/code&gt; to mean &lt;code&gt;big5-eten&lt;/code&gt;; Microsoft uses &lt;code&gt;big5&lt;/code&gt; to mean &lt;code&gt;cp950&lt;/code&gt;), a conscious decision was made to alias &lt;code&gt;big5&lt;/code&gt; to &lt;code&gt;big5-eten&lt;/code&gt;, which is the de facto superset of the original big5.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e096824f5ca19792394259581d18c44d0fb48327" translate="yes" xml:space="preserve">
          <source>Since the path separators are different on some operating systems ('/' on Unix, ':' on MacPerl, etc...) we recommend you use the File::Spec modules wherever portability is a concern.</source>
          <target state="translated">경로 구분 기호는 일부 운영 체제 (Unix의 경우 '/', MacPerl의 경우 ':'등)가 다르므로 이식성이 문제가되는 곳에서는 File :: Spec 모듈을 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="8b814beacf19306d64e3fcdb9e9e2ebc37bd2f9a" translate="yes" xml:space="preserve">
          <source>Since the return value of EXPR is executed as a block within the lexical context of the current Perl program, any outer lexical variables are visible to it, and any package variable settings or subroutine and format definitions remain afterwards.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="afc1d2d6e3b782b2dd5e1481aef1464f9b2e04bc" translate="yes" xml:space="preserve">
          <source>Since the scope wasn't lexical, other modules' use of &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/ord&quot;&gt;ord&lt;/a&gt;&lt;/code&gt;,</source>
          <target state="translated">범위가 어휘 적이 지 않기 때문에 다른 모듈의 &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/ord&quot;&gt;ord&lt;/a&gt;&lt;/code&gt; 사용 ,</target>
        </trans-unit>
        <trans-unit id="a424c04edb43b51178f65103d1803116d4fd0aaa" translate="yes" xml:space="preserve">
          <source>Since the scope wasn't lexical, other modules' use of &lt;code&gt;chr&lt;/code&gt;, &lt;code&gt;ord&lt;/code&gt;,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0b947b7b4bc7b90e1cd94b89023d67ed8fe406b" translate="yes" xml:space="preserve">
          <source>Since the symbols listed within &lt;code&gt;%EXPORT_TAGS&lt;/code&gt; must also appear in either &lt;code&gt;@EXPORT&lt;/code&gt; or &lt;code&gt;@EXPORT_OK&lt;/code&gt; , two utility functions are provided which allow you to easily add tagged sets of symbols to &lt;code&gt;@EXPORT&lt;/code&gt; or &lt;code&gt;@EXPORT_OK&lt;/code&gt; :</source>
          <target state="translated">내 나열된 문자 때문에 &lt;code&gt;%EXPORT_TAGS&lt;/code&gt; 또한 중 하나에 표시되어야 &lt;code&gt;@EXPORT&lt;/code&gt; 또는 &lt;code&gt;@EXPORT_OK&lt;/code&gt; , 두 개의 유틸리티 기능을 쉽게에 기호 태그 세트를 추가 할 수있는 제공됩니다 &lt;code&gt;@EXPORT&lt;/code&gt; 또는 &lt;code&gt;@EXPORT_OK&lt;/code&gt; 를 :</target>
        </trans-unit>
        <trans-unit id="12348ccf02ace58fde57dcb8fdfe6146a5174932" translate="yes" xml:space="preserve">
          <source>Since the symbols listed within &lt;code&gt;%EXPORT_TAGS&lt;/code&gt; must also appear in either &lt;code&gt;@EXPORT&lt;/code&gt; or &lt;code&gt;@EXPORT_OK&lt;/code&gt;, two utility functions are provided which allow you to easily add tagged sets of symbols to &lt;code&gt;@EXPORT&lt;/code&gt; or &lt;code&gt;@EXPORT_OK&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a1ad4491daa19cab8cfcffcbf76d31fdb6dedaa" translate="yes" xml:space="preserve">
          <source>Since the text to insert should be different in &lt;code&gt;bytes&lt;/code&gt; mode and out of it, the function should check the current state of &lt;code&gt;bytes&lt;/code&gt; -flag as in:</source>
          <target state="translated">삽입 할 텍스트가 &lt;code&gt;bytes&lt;/code&gt; 모드 에서 달라야 하므로이 함수는 다음과 같이 &lt;code&gt;bytes&lt;/code&gt; -flag 의 현재 상태를 확인해야합니다 .</target>
        </trans-unit>
        <trans-unit id="a18ac7a6a5b44dc9939056baa28ada3143807b7e" translate="yes" xml:space="preserve">
          <source>Since the text to insert should be different in &lt;code&gt;bytes&lt;/code&gt; mode and out of it, the function should check the current state of &lt;code&gt;bytes&lt;/code&gt;-flag as in:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b57f88b4da7c64e61f7bcbc6480133424225f899" translate="yes" xml:space="preserve">
          <source>Since the total size of all Perl SIS files once installed is over 2 MB, it is recommended to do the installation into a memory card (drive E:) instead of the C: drive.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50530d766e72e0b6fff4d2cca6e94d3aad2090a6" translate="yes" xml:space="preserve">
          <source>Since there are relatively few objects in a picture, there are only a few colors, which get looked up over and over again. Memoizing &lt;code&gt;ColorToRGB&lt;/code&gt; sped up the program by several percent.</source>
          <target state="translated">그림에는 비교적 적은 수의 물체가 있기 때문에 몇 번의 색상 만 있으며,이 색은 계속해서 또 다시 조회됩니다. ColorToRGB를 &lt;code&gt;ColorToRGB&lt;/code&gt; 하면 프로그램이 몇 퍼센트 나 빨라졌습니다.</target>
        </trans-unit>
        <trans-unit id="6cb6a83a2f2c3167da777a122214abb67623928e" translate="yes" xml:space="preserve">
          <source>Since there are so many, they are presented in table format with languages and corresponding encoding names by vendors. Note that the table is sorted in order of ISO-8859 and the corresponding vendor mappings are slightly different from that of ISO. See &lt;a href=&quot;http://czyborra.com/charsets/iso8859.html&quot;&gt;http://czyborra.com/charsets/iso8859.html&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b29f8659dcd90c4211c87b64479756be9287fa54" translate="yes" xml:space="preserve">
          <source>Since there is a bijection between a point in the 2D plane and a complex number (i.e. the mapping is unique and reciprocal), a complex number can also be uniquely identified with polar coordinates:</source>
          <target state="translated">2D 평면의 한 점과 복소수 사이에 bijection이 있으므로 (즉, 매핑이 고유하고 상호적임) 복소수도 극좌표로 고유하게 식별 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bc706817bd3a8e95c1023efd45beb0908b6a5e49" translate="yes" xml:space="preserve">
          <source>Since these aren't legal POSIX class specifications, but are legal bracketed character classes, Perl treats them as the latter. In the first example, it matches the characters &lt;code&gt;&quot;:&quot;&lt;/code&gt;, &lt;code&gt;&quot;[&quot;&lt;/code&gt;, &lt;code&gt;&quot;a&quot;&lt;/code&gt;, &lt;code&gt;&quot;l&quot;&lt;/code&gt;, &lt;code&gt;&quot;m&quot;&lt;/code&gt;, &lt;code&gt;&quot;n&quot;&lt;/code&gt;, and &lt;code&gt;&quot;u&quot;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3716c24306b4924201a3a983711259349f4d7b7c" translate="yes" xml:space="preserve">
          <source>Since these functions are different for most operating systems, each set of OS specific routines is available in a separate module, including:</source>
          <target state="translated">이러한 기능은 대부분의 운영 체제에 따라 다르므로 각 OS 특정 루틴 세트는 다음을 포함하여 별도의 모듈에서 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="61e7fa1fca7db47b0de02fb29d8bdc7a036c2ad4" translate="yes" xml:space="preserve">
          <source>Since these macros have side-effects don't use them as arguments to macros that may evaluate their argument several times, for example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c3d20e57f802de1056f71e94f07efcc76036480f" translate="yes" xml:space="preserve">
          <source>Since things like &lt;code&gt;&lt;a href=&quot;../functions/sqrt&quot;&gt;sqrt(2)&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;1 / 3&lt;/code&gt; must presented with a limited accuracy lest a operation consumes all resources, each operation produces no more than the requested number of digits.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../functions/sqrt&quot;&gt;sqrt(2)&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;1 / 3&lt;/code&gt; 과 같은 것은 연산이 모든 리소스를 소비하지 않도록 제한된 정확도를 제공해야하기 때문에 각 연산은 요청 된 자릿수를 넘지 않습니다.</target>
        </trans-unit>
        <trans-unit id="55385d26f11babeaaffc540cfe07e740a0d30a4d" translate="yes" xml:space="preserve">
          <source>Since things like &lt;code&gt;sqrt(2)&lt;/code&gt; or &lt;code&gt;1 / 3&lt;/code&gt; must presented with a limited accuracy lest a operation consumes all resources, each operation produces no more than the requested number of digits.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1a21b989b9d575d7d2eef7cf2bea0c2bc7b6c1e" translate="yes" xml:space="preserve">
          <source>Since this document was first written, the convention has become more and more to use hexadecimal notation for code points. To do this with the recipes and to also sort is a multi-step process, so here, for convenience, is the table from above, re-sorted to be in Code Page 1047 order, and using hex notation.</source>
          <target state="translated">이 문서는 처음 작성되었으므로 코드 포인트에 16 진 표기법을 사용하는 규칙이 점점 더 커지고 있습니다. 레시피로이 작업을 수행하고 정렬하는 것도 다단계 프로세스이므로 여기에서는 편의상 위의 표를 코드 순서대로 정렬하고 16 진 표기법을 사용하여 정렬합니다.</target>
        </trans-unit>
        <trans-unit id="ef4f428bd8f59049b7e023a3a37d2ecfa135c01b" translate="yes" xml:space="preserve">
          <source>Since this is 0.something release, any future releases are almost guaranteed to be binary incompatible. As a sign of this the Symbian symbol exports are kept unfrozen and the .def files fully rebuilt every time.</source>
          <target state="translated">이것은 0.something 릴리스이므로 향후 릴리스는 바이너리와 호환되지 않는 것이 거의 보장됩니다. 이 표시로 Symbian 기호 내보내기는 고정되지 않고 .def 파일은 매번 완전히 다시 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="a29b3865557e1b6dfb498bcdde9cd5a7a83c05b9" translate="yes" xml:space="preserve">
          <source>Since this module is most often used only indirectly from extension &lt;code&gt;Makefile.PL&lt;/code&gt; files, here is an example &lt;code&gt;Makefile.PL&lt;/code&gt; entry to add a library to the build process for an extension:</source>
          <target state="translated">이 모듈은 대부분 확장 &lt;code&gt;Makefile.PL&lt;/code&gt; 파일 에서 간접적으로 만 사용되므로 확장 을위한 빌드 프로세스에 라이브러리를 추가 하는 예제 &lt;code&gt;Makefile.PL&lt;/code&gt; 항목은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="01f476f0532c2e2f8ff2160a3485f37336e92c5d" translate="yes" xml:space="preserve">
          <source>Since this module refers to perl core's Unicode database in the directory</source>
          <target state="translated">이 모듈은 디렉토리에서 펄 코어의 유니 코드 데이터베이스를 참조하기 때문에</target>
        </trans-unit>
        <trans-unit id="e87fdde57834ef3e5b68a023cf000c8017fe6842" translate="yes" xml:space="preserve">
          <source>Since this procedure may take quite a long time to complete, it makes sense to &quot;freeze&quot; your CPAN configuration by disabling periodic updates of the local copy of CPAN index: set &lt;code&gt;index_expire&lt;/code&gt; to some big value (I use 365), then save the settings</source>
          <target state="translated">이 절차를 완료하는 데 시간이 오래 걸릴 수 있으므로 CPAN 인덱스의 로컬 사본에 대한 주기적 업데이트를 비활성화하여 CPAN 구성을 &quot;고정&quot;하는 것이 좋습니다. &lt;code&gt;index_expire&lt;/code&gt; 를 큰 값으로 설정 한 다음 (365를 사용) 설정을 저장하십시오.</target>
        </trans-unit>
        <trans-unit id="db30ab250873c1062c4781e4e7b7fad867ddcab0" translate="yes" xml:space="preserve">
          <source>Since this will lead to issues as described above.</source>
          <target state="translated">위에서 설명한대로 문제가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5b8353c61df27001cdfae1689cea0393e824247d" translate="yes" xml:space="preserve">
          <source>Since threads are also subroutines, they can return values. To wait for a thread to exit and extract any values it might return, you can use the &lt;code&gt;&lt;a href=&quot;functions/join&quot;&gt;join()&lt;/a&gt;&lt;/code&gt; method:</source>
          <target state="translated">스레드도 서브 루틴이므로 값을 리턴 할 수 있습니다. 스레드가 종료되고 리턴 될 수있는 값을 추출하기 위해 &lt;code&gt;&lt;a href=&quot;functions/join&quot;&gt;join()&lt;/a&gt;&lt;/code&gt; 메소드를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9bad1409df4464c147cc94bb57065c1ad067150c" translate="yes" xml:space="preserve">
          <source>Since threads are also subroutines, they can return values. To wait for a thread to exit and extract any values it might return, you can use the &lt;code&gt;join()&lt;/code&gt; method:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="865359543cead83315159b60389211a49302275e" translate="yes" xml:space="preserve">
          <source>Since to call certain OS/2 API one needs to have a correctly initialized &lt;code&gt;Win&lt;/code&gt; subsystem, OS/2-specific extensions may require getting &lt;code&gt;HAB&lt;/code&gt; s and &lt;code&gt;HMQ&lt;/code&gt; s. If an extension would do it on its own, another extension could fail to initialize.</source>
          <target state="translated">특정 OS / 2 API를 호출하려면 올바르게 초기화 된 &lt;code&gt;Win&lt;/code&gt; 서브 시스템이 있어야하므로 OS / 2 특정 확장에는 &lt;code&gt;HAB&lt;/code&gt; 및 &lt;code&gt;HMQ&lt;/code&gt; 가 필요합니다 . 확장이 자체적으로 확장하는 경우 다른 확장이 초기화되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a707076963b2deddc0e47770d659e4e4346ffd5b" translate="yes" xml:space="preserve">
          <source>Since to call certain OS/2 API one needs to have a correctly initialized &lt;code&gt;Win&lt;/code&gt; subsystem, OS/2-specific extensions may require getting &lt;code&gt;HAB&lt;/code&gt;s and &lt;code&gt;HMQ&lt;/code&gt;s. If an extension would do it on its own, another extension could fail to initialize.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac123183aa461484cfbda02f53a1d46605cce417" translate="yes" xml:space="preserve">
          <source>Since v1.24 the &lt;b&gt;Pod::Checker&lt;/b&gt; module uses only the &lt;b&gt;poderror&lt;/b&gt; method to print errors and warnings. The summary output (e.g. &quot;Pod syntax OK&quot;) has been dropped from the module and has been included in &lt;b&gt;podchecker&lt;/b&gt; (the script). This allows users of &lt;b&gt;Pod::Checker&lt;/b&gt; to control completely the output behavior. Users of &lt;b&gt;podchecker&lt;/b&gt; (the script) get the well-known behavior.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31c16cb5be350777f69ddd741df453e37c786546" translate="yes" xml:space="preserve">
          <source>Since v5.6.0, Perl's CORE::glob() is implemented in terms of bsd_glob(). Note that they don't share the same prototype--CORE::glob() only accepts a single argument. Due to historical reasons, CORE::glob() will also split its argument on whitespace, treating it as multiple patterns, whereas bsd_glob() considers them as one pattern. But see &lt;code&gt;:bsd_glob&lt;/code&gt; under &lt;a href=&quot;#EXPORTS&quot;&gt;&quot;EXPORTS&quot;&lt;/a&gt;, below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="993c2506a3b501e251a227378341211573ee7139" translate="yes" xml:space="preserve">
          <source>Since v5.6.0, Perl's CORE::glob() is implemented in terms of bsd_glob(). Note that they don't share the same prototype--CORE::glob() only accepts a single argument. Due to historical reasons, CORE::glob() will also split its argument on whitespace, treating it as multiple patterns, whereas bsd_glob() considers them as one pattern. But see &lt;code&gt;:bsd_glob&lt;/code&gt; under &lt;a href=&quot;#EXPORTS&quot;&gt;EXPORTS&lt;/a&gt;, below.</source>
          <target state="translated">v5.6.0부터 Perl의 CORE :: glob ()는 bsd_glob ()로 구현됩니다. 동일한 프로토 타입을 공유하지 않습니다. CORE :: glob ()는 단일 인수 만 허용합니다. 역사적 이유로 인해 CORE :: glob ()는 공백에 대한 인수를 여러 패턴으로 취급하지만 bsd_glob ()는이를 하나의 패턴으로 간주합니다. 그러나 아래 &lt;a href=&quot;#EXPORTS&quot;&gt;EXPORTS&lt;/a&gt; 아래의 &lt;code&gt;:bsd_glob&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="4ad68534057bbff035849577fdc9d02265e92498" translate="yes" xml:space="preserve">
          <source>Since valgrind adds significant overhead, tests will take much longer to run. The valgrind tests support being run in parallel to help with this:</source>
          <target state="translated">valgrind는 상당한 오버 헤드를 추가하므로 테스트 실행 시간이 훨씬 더 오래 걸립니다. valgrind 테스트는이를 돕기 위해 병렬로 실행되도록 지원합니다.</target>
        </trans-unit>
        <trans-unit id="cddab41a34bae01a0c375cc55e93affd1f3991b2" translate="yes" xml:space="preserve">
          <source>Since version 1.26.</source>
          <target state="translated">버전 1.26부터.</target>
        </trans-unit>
        <trans-unit id="6b04b338e1bf6330ffba84da282f69c260eb86f1" translate="yes" xml:space="preserve">
          <source>Since version 1.29.</source>
          <target state="translated">버전 1.29부터.</target>
        </trans-unit>
        <trans-unit id="90fa8ea868e9b39ffa1222c302c6573df472b992" translate="yes" xml:space="preserve">
          <source>Since version 1.30.</source>
          <target state="translated">버전 1.30부터.</target>
        </trans-unit>
        <trans-unit id="b46b7661e42d1c9773df584f5695782bec0ddb2f" translate="yes" xml:space="preserve">
          <source>Since version 1.33.</source>
          <target state="translated">버전 1.33부터.</target>
        </trans-unit>
        <trans-unit id="4b40436a29419119d4b78bb2f402e947b823a0e2" translate="yes" xml:space="preserve">
          <source>Since version 1.35.</source>
          <target state="translated">버전 1.35부터.</target>
        </trans-unit>
        <trans-unit id="3a2c4273e02619f5ed86c67adac94047a5ca0b70" translate="yes" xml:space="preserve">
          <source>Since version 1.36.</source>
          <target state="translated">버전 1.36부터.</target>
        </trans-unit>
        <trans-unit id="828428c704d4b18c115ba845d9cbbc499bb7c74e" translate="yes" xml:space="preserve">
          <source>Since version 1.40.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="623e941c243fc86dd1af6f5b5214ee2ab1b54b93" translate="yes" xml:space="preserve">
          <source>Since version 1.42.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0995e25b2df10d5239bf46e745e3af66bfa38ff9" translate="yes" xml:space="preserve">
          <source>Since version 1.44.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85fc2cbdcb50a3cca10d3657cdf7b3d3b631c2f4" translate="yes" xml:space="preserve">
          <source>Since version 1.45.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20faedc97370e5707a72fd235e65122603a7fcc7" translate="yes" xml:space="preserve">
          <source>Since version 1.50.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21a1a8817578d6cd5474a6b1a0cb684b5b5d0681" translate="yes" xml:space="preserve">
          <source>Since version 1.54.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52ea051224d185be13b4a3d24b650c0164b10687" translate="yes" xml:space="preserve">
          <source>Since version 1.55.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aefe381ec383217e51c9e6b76ef75c74617d1b90" translate="yes" xml:space="preserve">
          <source>Since version 2.22 (part of Encode 2.83), the MIME encoder should be fully compliant to &lt;a href=&quot;https://tools.ietf.org/html/rfc2047&quot;&gt;RFC 2047&lt;/a&gt; and &lt;a href=&quot;https://tools.ietf.org/html/rfc2231&quot;&gt;RFC 2231&lt;/a&gt;. Due to the aforementioned bugs in previous versions of the MIME encoder, there is a</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="991cb9597f8a402ad66b55672ad9333f3ec6c358" translate="yes" xml:space="preserve">
          <source>Since version 2.91_01, JSON::PP uses a different number detection logic that converts a scalar that is possible to turn into a number safely. The new logic is slightly faster, and tends to help people who use older perl or who want to encode complicated data structure. However, this may results in a different JSON text from the one JSON::XS encodes (and thus may break tests that compare entire JSON texts). If you do need the previous behavior for compatibility or for finer control, set PERL_JSON_PP_USE_B environmental variable to true before you &lt;code&gt;use&lt;/code&gt; JSON::PP (or JSON.pm).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2498504f50455260e9635ae498353ef8c9decaca" translate="yes" xml:space="preserve">
          <source>Since version 5.8 Perl uses the PerlIO I/O library. This enables you to use different encodings per IO channel. For example you may use</source>
          <target state="translated">버전 5.8부터 Perl은 PerlIO I / O 라이브러리를 사용합니다. 이를 통해 IO 채널마다 다른 인코딩을 사용할 수 있습니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="656ca296455da01a08e031bd90f196ae0bd4a55c" translate="yes" xml:space="preserve">
          <source>Since version 5.8 Perl uses the new PerlIO on BS2000. This enables you using different encodings per IO channel. For example you may use</source>
          <target state="translated">버전 5.8부터 Perl은 BS2000에서 새로운 PerlIO를 사용합니다. 이를 통해 IO 채널마다 다른 인코딩을 사용할 수 있습니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="5792847b18d8585cbe32d073b79aab824b6fbb3d" translate="yes" xml:space="preserve">
          <source>Since version 5.8.0, hashes can be</source>
          <target state="translated">버전 5.8.0부터 해시는</target>
        </trans-unit>
        <trans-unit id="a80731504bb0fcf1278621181ce230d90a8fe55c" translate="yes" xml:space="preserve">
          <source>Since version &lt;code&gt;1.39&lt;/code&gt; these &lt;code&gt;ARRAY&lt;/code&gt; references are blessed objects, recognising the two methods &lt;code&gt;key&lt;/code&gt; and &lt;code&gt;value&lt;/code&gt;. The following code is equivalent:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3045986b0102a2064e1410bb295874d9fe22b31d" translate="yes" xml:space="preserve">
          <source>Since version &lt;code&gt;1.39&lt;/code&gt; these ARRAY references are blessed objects, recognising the two methods &lt;code&gt;key&lt;/code&gt; and &lt;code&gt;value&lt;/code&gt; . The following code is equivalent:</source>
          <target state="translated">버전 &lt;code&gt;1.39&lt;/code&gt; 부터이 ARRAY 참조는 &lt;code&gt;key&lt;/code&gt; 와 &lt;code&gt;value&lt;/code&gt; 두 가지 방법을 인식하는 축복 된 객체 입니다. 다음 코드는 동일합니다.</target>
        </trans-unit>
        <trans-unit id="d22b88a2ec6cf389267a717ce7fbb228afb24d03" translate="yes" xml:space="preserve">
          <source>Since version &lt;code&gt;1.51&lt;/code&gt; they also have a &lt;code&gt;TO_JSON&lt;/code&gt; method to ease serialisation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4da1ba2b2bc63ba7f5a165684b362132feb79be8" translate="yes" xml:space="preserve">
          <source>Since version v1.33, Math::BigInt and Math::BigFloat have full support for accuracy and precision based rounding, both automatically after every operation, as well as manually.</source>
          <target state="translated">버전 v1.33부터 Math :: BigInt 및 Math :: BigFloat는 모든 작업 후 자동 및 수동으로 정확도 및 정밀도 기반 반올림을 완벽하게 지원합니다.</target>
        </trans-unit>
        <trans-unit id="75e1e7b33ae8faf22bfba9121d2d99d1efb7768e" translate="yes" xml:space="preserve">
          <source>Since we didn't define a &lt;code&gt;save()&lt;/code&gt; method in the &lt;code&gt;File::MP3&lt;/code&gt; class, Perl will look at the &lt;code&gt;File::MP3&lt;/code&gt; class's parent classes to find the &lt;code&gt;save()&lt;/code&gt; method. If Perl cannot find a &lt;code&gt;save()&lt;/code&gt; method anywhere in the inheritance hierarchy, it will die.</source>
          <target state="translated">&lt;code&gt;File::MP3&lt;/code&gt; 클래스 에서 &lt;code&gt;save()&lt;/code&gt; 메소드를 정의하지 않았으므로 Perl은 &lt;code&gt;File::MP3&lt;/code&gt; 클래스의 상위 클래스를보고 &lt;code&gt;save()&lt;/code&gt; 메소드 를 찾습니다 . Perl 이 상속 계층의 어느 곳에서나 &lt;code&gt;save()&lt;/code&gt; 메소드를 찾을 수 없으면 죽습니다.</target>
        </trans-unit>
        <trans-unit id="3e236441f92cccda5b2d49a5d2e52d11313518e5" translate="yes" xml:space="preserve">
          <source>Since we don't have an NV for &lt;code&gt;$b&lt;/code&gt; , we'll have to use &lt;code&gt;sv_2nv&lt;/code&gt; to convert it. If we step again, we'll find ourselves there:</source>
          <target state="translated">&lt;code&gt;$b&lt;/code&gt; NV가 없으므로 &lt;code&gt;sv_2nv&lt;/code&gt; 를 사용 하여 변환해야합니다. 우리가 다시 밟으면, 우리는 그곳에있을 것입니다 :</target>
        </trans-unit>
        <trans-unit id="43d65fe03aac7da5dd4ef49b28b5012afba90c77" translate="yes" xml:space="preserve">
          <source>Since we don't have an NV for &lt;code&gt;$b&lt;/code&gt;, we'll have to use &lt;code&gt;sv_2nv&lt;/code&gt; to convert it. If we step again, we'll find ourselves there:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3708f0927e1925f92bdee0634ab63e7742c6b549" translate="yes" xml:space="preserve">
          <source>Since we don't know if &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; works, or even subroutines, use ad hoc tests for these three. Step carefully to avoid using the feature being tested. Tests in</source>
          <target state="translated">우리는 작품이나 서브 루틴이 &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; 알지 못 하므로이 세 가지에 대해 임시 테스트를 사용하십시오. 테스트중인 기능을 사용하지 않도록 신중하게 단계를 수행하십시오. 테스트</target>
        </trans-unit>
        <trans-unit id="959f38fbc36ca9c82998d3e370dda38e5dddb0bf" translate="yes" xml:space="preserve">
          <source>Since we don't know if &lt;code&gt;require&lt;/code&gt; works, or even subroutines, use ad hoc tests for these three. Step carefully to avoid using the feature being tested. Tests in</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3f9ededf0cd07d09b1ffd3609acb21770a40353" translate="yes" xml:space="preserve">
          <source>Since we feed a list of ten 2-digit hexadecimal strings to &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt;, the pack template should contain ten pack codes. If this is run on a computer with ASCII character coding, it will print &lt;code&gt;0123456789&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; 할 2 자리 16 진수 문자열 10 개의 목록을 제공 하므로 팩 템플릿에는 10 개의 팩 코드가 포함되어야합니다. ASCII 문자 코딩이있는 컴퓨터에서 실행되면 &lt;code&gt;0123456789&lt;/code&gt; 가 인쇄 됩니다.</target>
        </trans-unit>
        <trans-unit id="c3e96dcf9d6747abca3c34da42f376ec3097c3d9" translate="yes" xml:space="preserve">
          <source>Since we feed a list of ten 2-digit hexadecimal strings to &lt;code&gt;pack&lt;/code&gt;, the pack template should contain ten pack codes. If this is run on a computer with ASCII character coding, it will print &lt;code&gt;0123456789&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1a3bb738728020d7b3d2bd56167deba0672548c" translate="yes" xml:space="preserve">
          <source>Since we said earlier:</source>
          <target state="translated">앞서 말한 이후 :</target>
        </trans-unit>
        <trans-unit id="78829eafb6296e19175ed55a3097f673b5dc1d5f" translate="yes" xml:space="preserve">
          <source>Since you can assign to a list of variables, you can also assign to an array or hash slice.</source>
          <target state="translated">변수 목록에 할당 할 수 있으므로 배열 또는 해시 슬라이스에 할당 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="35b796faff1e6866bc3d8ff9ecdff8f636cea4f9" translate="yes" xml:space="preserve">
          <source>Since you only run one test per program &lt;code&gt;new&lt;/code&gt; always returns the same Test::Builder object. No matter how many times you call &lt;code&gt;new()&lt;/code&gt; , you're getting the same object. This is called a singleton. This is done so that multiple modules share such global information as the test counter and where test output is going.</source>
          <target state="translated">프로그램 당 하나의 테스트 만 실행하므로 &lt;code&gt;new&lt;/code&gt; 는 항상 동일한 Test :: Builder 객체를 반환합니다. &lt;code&gt;new()&lt;/code&gt; 몇 번 호출 하더라도 동일한 객체를 얻습니다. 이것을 싱글 톤이라고합니다. 이는 여러 모듈이 테스트 카운터와 같은 글로벌 정보를 공유하고 테스트 출력이 진행되는 위치를 공유하기 위해 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="d6632404c7510ee37ef12fec086b1b9886c3c039" translate="yes" xml:space="preserve">
          <source>Since you only run one test per program &lt;code&gt;new&lt;/code&gt; always returns the same Test::Builder object. No matter how many times you call &lt;code&gt;new()&lt;/code&gt;, you're getting the same object. This is called a singleton. This is done so that multiple modules share such global information as the test counter and where test output is going.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5df43da3b7bd5966cc2c20737e50dc599284dd8e" translate="yes" xml:space="preserve">
          <source>Since you want to be a good programmer, you probably want to use a lexical filehandle, even though formats are designed to work with bareword filehandles since the default format names take the filehandle name. However, you can control this with some Perl special per-filehandle variables: &lt;code&gt;$^&lt;/code&gt; , which names the top-of-page format, and &lt;code&gt;$~&lt;/code&gt; which shows the line format. You have to change the default filehandle to set these variables:</source>
          <target state="translated">훌륭한 프로그래머가 되려면 기본 형식 이름이 파일 핸들 이름을 갖기 때문에 형식이 베어 워드 파일 핸들과 함께 작동하도록 설계 되었더라도 어휘 파일 핸들을 사용하고 싶을 것입니다. 그러나 페이지 단위 형식의 이름을 지정하는 &lt;code&gt;$^&lt;/code&gt; 및 행 형식을 나타내는 &lt;code&gt;$~&lt;/code&gt; 와 같은 일부 Perl 특수 파일 핸들 변수 를 사용하여이를 제어 할 수 있습니다 . 다음 변수를 설정하려면 기본 파일 핸들을 변경해야합니다.</target>
        </trans-unit>
        <trans-unit id="8a72acc5d7f8358918f3a719037cabf59df13c37" translate="yes" xml:space="preserve">
          <source>Since you want to be a good programmer, you probably want to use a lexical filehandle, even though formats are designed to work with bareword filehandles since the default format names take the filehandle name. However, you can control this with some Perl special per-filehandle variables: &lt;code&gt;$^&lt;/code&gt;, which names the top-of-page format, and &lt;code&gt;$~&lt;/code&gt; which shows the line format. You have to change the default filehandle to set these variables:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31ee6b56ac231ef340b4b0ce7a9b1c774baa56bb" translate="yes" xml:space="preserve">
          <source>Since you're assigning to a scalar, the righthand side is in scalar context. The comma operator (yes, it's an operator!) in scalar context evaluates its lefthand side, throws away the result, and evaluates it's righthand side and returns the result. In effect, that list-lookalike assigns to &lt;code&gt;$scalar&lt;/code&gt; it's rightmost value. Many people mess this up because they choose a list-lookalike whose last element is also the count they expect:</source>
          <target state="translated">스칼라에 할당하기 때문에 오른쪽은 스칼라 컨텍스트에 있습니다. 스칼라 컨텍스트의 쉼표 연산자 (예, 연산자입니다!)는 왼쪽을 평가하고 결과를 버리고 오른쪽을 평가하여 결과를 반환합니다. 실제로, 그 목록처럼 보이는 것은 &lt;code&gt;$scalar&lt;/code&gt; 가장 오른쪽에 할당됩니다 . 많은 사람들이 마지막 요소가 기대하는 개수 인 목록과 비슷한 것을 선택하기 때문에 이것을 망칩니다.</target>
        </trans-unit>
        <trans-unit id="b1e4d1f3b6584286a7b1e87475e6b68a4163f836" translate="yes" xml:space="preserve">
          <source>Since you're using ssh, you'll have to pass some extra arguments to Configure:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9e2d6a9962eddfc9f09d9986a8e8b8277588e75" translate="yes" xml:space="preserve">
          <source>Since, as mentioned above, bitwise operators may take extra arguments, you may want to use something like &lt;code&gt;(lobj, robj, swap, ...)&lt;/code&gt; (with literal &lt;code&gt;...&lt;/code&gt;) as your parameter list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20c0b7bdab70ca2cc9c844a0d74a3af0bbf41c3e" translate="yes" xml:space="preserve">
          <source>Singapore</source>
          <target state="translated">Singapore</target>
        </trans-unit>
        <trans-unit id="b227b1e063b8171583fca32f48c11de71e845c84" translate="yes" xml:space="preserve">
          <source>Single 8-bit characters.</source>
          <target state="translated">단일 8 비트 문자</target>
        </trans-unit>
        <trans-unit id="62539aaf022cade9262a4b6494d3943b6956e5a8" translate="yes" xml:space="preserve">
          <source>Single Byte Encodings</source>
          <target state="translated">단일 바이트 인코딩</target>
        </trans-unit>
        <trans-unit id="4530f93a4bcf9d5873d117244d6fb7434ad7291d" translate="yes" xml:space="preserve">
          <source>Single Quotes</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="012b49ff1827b6d4c0bd35ca2f9e9f57f854cb53" translate="yes" xml:space="preserve">
          <source>Single form (&lt;code&gt;\p{name}&lt;/code&gt;) tighter rules:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a8a4e28358318025ab4a8b973931c58f9de9358" translate="yes" xml:space="preserve">
          <source>Single quotes indicate the text is to be treated literally with no interpolation of its content. This is similar to single quoted strings except that backslashes have no special meaning, with &lt;code&gt;\\&lt;/code&gt; being treated as two backslashes and not one as they would in every other quoting construct.</source>
          <target state="translated">작은 따옴표는 텍스트를 내용의 보간없이 문자 그대로 처리해야 함을 나타냅니다. 그 백 슬래시는 특별한 의미가없는 것을 제외하고이 함께 단일 인용 문자열과 유사하다 &lt;code&gt;\\&lt;/code&gt; 두 개의 백 슬래시로 취급하지 하나가 다른 모든 인용 구조에서와 같은된다.</target>
        </trans-unit>
        <trans-unit id="2988b7ce72e4ef43941b210b5d2de77bb3a0210b" translate="yes" xml:space="preserve">
          <source>Single space after keywords that are followed by parens, no space between function name and following paren</source>
          <target state="translated">키워드 뒤에 단일 공백이 있고 그 뒤에 공백이 있고 함수 이름과 다음에 오는 공백이 없습니다</target>
        </trans-unit>
        <trans-unit id="998773a99793919677d4844303decc2eb2f960f3" translate="yes" xml:space="preserve">
          <source>Single step. Executes until the beginning of another statement, descending into subroutine calls. If an expression is supplied that includes function calls, it too will be single-stepped.</source>
          <target state="translated">한 걸음 서브 루틴 호출로 내림차순으로 다른 명령문이 시작될 때까지 실행합니다. 함수 호출을 포함하는 표현식이 제공되면 한 단계 씩 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="b39e88e61083334da27e22ac3304f5322910c7a2" translate="yes" xml:space="preserve">
          <source>Single-letter properties match all characters in any of the two-letter sub-properties starting with the same letter. &lt;code&gt;LC&lt;/code&gt; and &lt;code&gt;L&amp;amp;&lt;/code&gt; are special: both are aliases for the set consisting of everything matched by &lt;code&gt;Ll&lt;/code&gt; , &lt;code&gt;Lu&lt;/code&gt; , and &lt;code&gt;Lt&lt;/code&gt; .</source>
          <target state="translated">단일 문자 특성은 동일한 문자로 시작하는 두 문자 하위 특성의 모든 문자와 일치합니다. &lt;code&gt;LC&lt;/code&gt; 및 &lt;code&gt;L&amp;amp;&lt;/code&gt; 는 특별합니다. 둘 다 &lt;code&gt;Ll&lt;/code&gt; , &lt;code&gt;Lu&lt;/code&gt; 및 &lt;code&gt;Lt&lt;/code&gt; 와 일치하는 모든 항목으로 구성된 세트의 별명입니다 .</target>
        </trans-unit>
        <trans-unit id="d8acda7f90b42defaf44562897d2b28bbd83f4e8" translate="yes" xml:space="preserve">
          <source>Single-letter properties match all characters in any of the two-letter sub-properties starting with the same letter. &lt;code&gt;LC&lt;/code&gt; and &lt;code&gt;L&amp;amp;&lt;/code&gt; are special: both are aliases for the set consisting of everything matched by &lt;code&gt;Ll&lt;/code&gt;, &lt;code&gt;Lu&lt;/code&gt;, and &lt;code&gt;Lt&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47784ae534e76f07f938e74b6b49c2e04c524d60" translate="yes" xml:space="preserve">
          <source>Single-step flag. Will be true if the API will stop at the next statement.</source>
          <target state="translated">단일 단계 플래그. 다음 명령문에서 API가 중지되면 true입니다.</target>
        </trans-unit>
        <trans-unit id="3fd72cbf421902beaf4893343701c7e9f292181e" translate="yes" xml:space="preserve">
          <source>Sinograms like &amp;ldquo;東京&amp;rdquo; come back with character names of &lt;code&gt;CJK UNIFIED IDEOGRAPH-6771&lt;/code&gt; and &lt;code&gt;CJK UNIFIED IDEOGRAPH-4EAC&lt;/code&gt; , because their &amp;ldquo;names&amp;rdquo; vary. The CPAN &lt;code&gt;Unicode::Unihan&lt;/code&gt; module has a large database for decoding these (and a whole lot more), provided you know how to understand its output.</source>
          <target state="translated">&amp;ldquo;東京&amp;rdquo;과 같은 사이 &lt;code&gt;CJK UNIFIED IDEOGRAPH-4EAC&lt;/code&gt; 은&amp;ldquo;이름&amp;rdquo;이 다르기 때문에 &lt;code&gt;CJK UNIFIED IDEOGRAPH-6771&lt;/code&gt; 및 CJK UNIFIED IDEOGRAPH-4EAC 의 문자 이름으로 돌아옵니다 . CPAN &lt;code&gt;Unicode::Unihan&lt;/code&gt; 모듈에는 출력을 이해하는 방법을 알고있는 경우이를 디코딩하기위한 큰 데이터베이스가 있습니다.</target>
        </trans-unit>
        <trans-unit id="b9df3910d077951b174aefd94b54e0bc3ac87d77" translate="yes" xml:space="preserve">
          <source>Sinograms like &amp;ldquo;東京&amp;rdquo; come back with character names of &lt;code&gt;CJK UNIFIED IDEOGRAPH-6771&lt;/code&gt; and &lt;code&gt;CJK UNIFIED IDEOGRAPH-4EAC&lt;/code&gt;, because their &amp;ldquo;names&amp;rdquo; vary. The CPAN &lt;code&gt;Unicode::Unihan&lt;/code&gt; module has a large database for decoding these (and a whole lot more), provided you know how to understand its output.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="28e8fd907b0e11131190209772e747eaed820c59" translate="yes" xml:space="preserve">
          <source>Site-specific perl extensions and modules can be installed in one of two places. Put architecture-independent files into:</source>
          <target state="translated">사이트 별 perl 확장 및 모듈은 두 위치 중 하나에 설치할 수 있습니다. 아키텍처 독립적 인 파일을 다음에 넣습니다.</target>
        </trans-unit>
        <trans-unit id="00832815e260edfba2e83c2f4b5a6a35db1c2d1c" translate="yes" xml:space="preserve">
          <source>Six such conversions are possible:</source>
          <target state="translated">6 가지 변환이 가능합니다 :</target>
        </trans-unit>
        <trans-unit id="ab71370c759f98b4c2c5f12f621583aa7cb9faf2" translate="yes" xml:space="preserve">
          <source>Sixth:</source>
          <target state="translated">Sixth:</target>
        </trans-unit>
        <trans-unit id="43701334f4b3da3fdeb3363278217ac0f215873d" translate="yes" xml:space="preserve">
          <source>Size of the function table. This is compared against the value PerlIO code &quot;knows&quot; as a compatibility check. Future versions</source>
          <target state="translated">기능 테이블의 크기. 이것은 PerlIO 코드 값과 호환성 검사로 &quot;알고&quot;비교됩니다. 향후 버전</target>
        </trans-unit>
        <trans-unit id="936d52e1c615ea7024397f6ff1aeb7c89ebd5bad" translate="yes" xml:space="preserve">
          <source>Size, Endianness, and BOM</source>
          <target state="translated">크기, 엔디안 및 BOM</target>
        </trans-unit>
        <trans-unit id="0ec62bfb6670c34f50ed4190d4e6017dc34d76d5" translate="yes" xml:space="preserve">
          <source>Skip a package when throwing autodie exceptions</source>
          <target state="translated">Autodie 예외가 발생할 때 패키지 건너 뛰기</target>
        </trans-unit>
        <trans-unit id="73e856b6ebf6aeb3a630b124c6e02c2a78566450" translate="yes" xml:space="preserve">
          <source>Skip all tests.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99c526a5770e20da3a4179e52c1b052314f790b3" translate="yes" xml:space="preserve">
          <source>Skip event type</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31ffbfd6b2e06775aaf14afc6238b4599cf532c4" translate="yes" xml:space="preserve">
          <source>Skip events bump test counts just like &lt;a href=&quot;Test2::Event::Ok&quot;&gt;Test2::Event::Ok&lt;/a&gt; events, but they can never fail.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57a18bbc33fb3b107b0f37ec04073b6f8f1aa7be" translate="yes" xml:space="preserve">
          <source>Skip sub-char mapping should there be no code point.</source>
          <target state="translated">코드 포인트가 없으면 하위 문자 매핑을 건너 뜁니다.</target>
        </trans-unit>
        <trans-unit id="fa22bcdeb4f395bdc09dc2fd5b11b93a885994fb" translate="yes" xml:space="preserve">
          <source>Skip the real Pod formatting, and just show the raw Pod source (&lt;b&gt;U&lt;/b&gt;nformatted)</source>
          <target state="translated">실제 포드 형식을 건너 뛰고 원시 포드 소스 만 표시하십시오 ( &lt;b&gt;U&lt;/b&gt; nformatted).</target>
        </trans-unit>
        <trans-unit id="e6cd533514432f62bafda9ad5f9825a972ff6179" translate="yes" xml:space="preserve">
          <source>Skip this section if the XSUB functions are supposed to be called from other modules only; read it only if you call your XSUBs from the code in your module, or have a &lt;code&gt;BOOT:&lt;/code&gt; section in your XS file (see &lt;a href=&quot;perlxs#The-BOOT%3A-Keyword&quot;&gt;&quot;The BOOT: Keyword&quot; in perlxs&lt;/a&gt;). What is described here is equally applicable to the &lt;a href=&quot;dynaloader&quot;&gt;DynaLoader&lt;/a&gt; interface.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e59adfb26a9113df0d5c476d39a18d0087952f5" translate="yes" xml:space="preserve">
          <source>Skip this section if the XSUB functions are supposed to be called from other modules only; read it only if you call your XSUBs from the code in your module, or have a &lt;code&gt;BOOT:&lt;/code&gt; section in your XS file (see &lt;a href=&quot;perlxs#The-BOOT%3a-Keyword&quot;&gt;The BOOT: Keyword in perlxs&lt;/a&gt;). What is described here is equally applicable to the &lt;a href=&quot;dynaloader&quot;&gt;DynaLoader&lt;/a&gt; interface.</source>
          <target state="translated">XSUB 함수가 다른 모듈에서만 호출되어야하는 경우이 섹션을 건너 뛰십시오. 모듈의 코드에서 XSUB를 호출하거나 XS 파일에 &lt;code&gt;BOOT:&lt;/code&gt; 섹션 이있는 경우에만 읽으십시오 ( &lt;a href=&quot;perlxs#The-BOOT%3a-Keyword&quot;&gt;BOOT : perlxs의 키워드&lt;/a&gt; 참조 ). 여기에 설명 된 내용은 &lt;a href=&quot;dynaloader&quot;&gt;DynaLoader&lt;/a&gt; 에도 동일하게 적용됩니다. 인터페이스 .</target>
        </trans-unit>
        <trans-unit id="a516a3ce4b9fd1e3a2a9186564fe4ca0d9da8218" translate="yes" xml:space="preserve">
          <source>Skipping tests</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54ab6781ff6514e41583039acc42db3e0f3c9201" translate="yes" xml:space="preserve">
          <source>Skips all the tests, using the given &lt;code&gt;$reason&lt;/code&gt; . Exits immediately with 0.</source>
          <target state="translated">주어진 &lt;code&gt;$reason&lt;/code&gt; 사용하여 모든 테스트를 건너 뜁니다 . 0으로 즉시 종료합니다.</target>
        </trans-unit>
        <trans-unit id="9d406363c0222ce5a6c71553ed555dc077dda244" translate="yes" xml:space="preserve">
          <source>Skips all the tests, using the given &lt;code&gt;$reason&lt;/code&gt;. Exits immediately with 0.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="563adc0d862d00d2bcc7549833d1039985aead2a" translate="yes" xml:space="preserve">
          <source>Skips the current test, reporting &lt;code&gt;$why&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;$why&lt;/code&gt; 보고하여 현재 테스트를 건너 뜁니다 .</target>
        </trans-unit>
        <trans-unit id="9c9a19a668210cd54ae808f068a27dac1e967c53" translate="yes" xml:space="preserve">
          <source>Skips the current test, reporting &lt;code&gt;$why&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca1ac1071abc2c48fe8c683c23437c17bcd0e5ba" translate="yes" xml:space="preserve">
          <source>Skips to the next compressed data stream in the input file/buffer. If a new compressed data stream is found, the eof marker will be cleared and &lt;code&gt;$.&lt;/code&gt; will be reset to 0.</source>
          <target state="translated">입력 파일 / 버퍼에서 다음 압축 데이터 스트림으로 건너 뜁니다. 새로운 압축 데이터 스트림이 발견되면 eof 마커가 지워지고 &lt;code&gt;$.&lt;/code&gt; 0으로 재설정됩니다.</target>
        </trans-unit>
        <trans-unit id="4249f92b08fd3ea49d1d4587b0dc45efe6514ff5" translate="yes" xml:space="preserve">
          <source>SkyMarshal &amp;lt;skymarshal1729@gmail.com&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa1af20e2176a0b7a938bf7cbbbf01e3f656d901" translate="yes" xml:space="preserve">
          <source>Skye Shaw &amp;lt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41574ecb0de77a7fed0beca1f4434e4a44173169" translate="yes" xml:space="preserve">
          <source>Slab leaked from cv %p</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d051f41b7de19e7acc50c00d91bed9bc77c2a243" translate="yes" xml:space="preserve">
          <source>Slab-based operator allocation</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="28422baab3fe565caf66be5cefa3539fc1817282" translate="yes" xml:space="preserve">
          <source>Slab_Alloc</source>
          <target state="translated">Slab_Alloc</target>
        </trans-unit>
        <trans-unit id="dfee07ce355211f20f3bdab2cb3fa2a9def9c336" translate="yes" xml:space="preserve">
          <source>Slab_Free</source>
          <target state="translated">Slab_Free</target>
        </trans-unit>
        <trans-unit id="8b86eb2caadb21d205d9d0ad56cf031153fb8e27" translate="yes" xml:space="preserve">
          <source>Slab_to_ro</source>
          <target state="translated">Slab_to_ro</target>
        </trans-unit>
        <trans-unit id="b4128d18330a7f45f087418a9b524193204735bc" translate="yes" xml:space="preserve">
          <source>Slab_to_rw</source>
          <target state="translated">Slab_to_rw</target>
        </trans-unit>
        <trans-unit id="147d6799969166c3bb4c81176bc4c31ac64ac6bd" translate="yes" xml:space="preserve">
          <source>Slaven Rezic &amp;lt;slaven.rezic@idealo.de&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ac691e6a9650a28847ff59e7d257f5f29d2f4fa" translate="yes" xml:space="preserve">
          <source>Slaven Rezic &amp;lt;slaven@rezic.de&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e59d0602eb0550fd0dbf5d82907d6271ae4af6ea" translate="yes" xml:space="preserve">
          <source>Sleeps for the number of microseconds (millionths of a second) specified. Returns the number of microseconds actually slept. Can sleep for more than one second, unlike the &lt;code&gt;usleep&lt;/code&gt; system call. Can also sleep for zero seconds, which often works like a</source>
          <target state="translated">지정된 마이크로 초 (밀리 초) 동안 대기합니다. 실제로 잠든 시간 (마이크로 초)을 반환합니다. &lt;code&gt;usleep&lt;/code&gt; 시스템 호출 과 달리 1 초 이상 잠을 잘 수 있습니다. 0 초 동안 절전 모드로 전환 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="a7c111ccc19a7463efac9caa48bfd176015106c5" translate="yes" xml:space="preserve">
          <source>Sleeps for the number of nanoseconds (1e9ths of a second) specified. Returns the number of nanoseconds actually slept (accurate only to microseconds, the nearest thousand of them). Can sleep for more than one second. Can also sleep for zero seconds, which often works like a</source>
          <target state="translated">지정된 나노초 (1e9 초) 동안 대기합니다. 실제로 잠든 나노초의 수를 반환합니다 (마이크로 초, 가장 가까운 천 단위). 1 초 이상 잠을 잘 수 있습니다. 0 초 동안 절전 모드로 전환 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="858360f4742bec3dbad2b4b1586f95ca8cfce48d" translate="yes" xml:space="preserve">
          <source>Sleeps for the number of nanoseconds (1e9ths of a second) specified. Returns the number of nanoseconds actually slept. The $which is the &quot;clock id&quot;, as with clock_gettime() and clock_getres(). The flags default to zero but &lt;code&gt;TIMER_ABSTIME&lt;/code&gt; can specified (must be exported explicitly) which means that &lt;code&gt;$nanoseconds&lt;/code&gt; is not a time interval (as is the default) but instead an absolute time. Can sleep for more than one second. Can also sleep for zero seconds, which often works like a</source>
          <target state="translated">지정된 나노초 (1e9 초) 동안 대기합니다. 실제로 잠은 나노초 수를 반환합니다. clock_gettime () 및 clock_getres ()와 같이 &quot;클럭 ID&quot;인 $입니다. 플래그는 기본적으로 0이지만 &lt;code&gt;TIMER_ABSTIME&lt;/code&gt; 을 지정할 수 있습니다 (명시 적으로 내 보내야 함). 이는 &lt;code&gt;$nanoseconds&lt;/code&gt; 가 시간 간격 (기본값)이 아니라 절대 시간 임을 의미합니다 . 1 초 이상 잠을 잘 수 있습니다. 0 초 동안 절전 모드로 전환 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="bfc9358c36664745e87042ffeea926ba49acc8f0" translate="yes" xml:space="preserve">
          <source>Sleeps for the specified amount of seconds. Returns the number of seconds actually slept (a floating point value). This function can be imported, resulting in a nice drop-in replacement for the &lt;code&gt;&lt;a href=&quot;../functions/sleep&quot;&gt;sleep&lt;/a&gt;&lt;/code&gt; provided with perl, see the &lt;a href=&quot;#EXAMPLES&quot;&gt;EXAMPLES&lt;/a&gt; below.</source>
          <target state="translated">지정된 시간 (초) 동안 대기합니다. 실제로 잠은 시간 (초)을 반환합니다 (부동 소수점 값). 이 기능을 가져 와서 perl과 함께 제공 되는 &lt;code&gt;&lt;a href=&quot;../functions/sleep&quot;&gt;sleep&lt;/a&gt;&lt;/code&gt; 를 대체 할 수 있습니다 ( 아래 &lt;a href=&quot;#EXAMPLES&quot;&gt;예&lt;/a&gt; 참조).</target>
        </trans-unit>
        <trans-unit id="18ae77017c85766e5d3a71c2d083fdfba9357fdb" translate="yes" xml:space="preserve">
          <source>Sleeps for the specified amount of seconds. Returns the number of seconds actually slept (a floating point value). This function can be imported, resulting in a nice drop-in replacement for the &lt;code&gt;sleep&lt;/code&gt; provided with perl, see the &lt;a href=&quot;#EXAMPLES&quot;&gt;&quot;EXAMPLES&quot;&lt;/a&gt; below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a455933ba1827ec6d2d6cea6cb61c05bd3954351" translate="yes" xml:space="preserve">
          <source>Slices</source>
          <target state="translated">Slices</target>
        </trans-unit>
        <trans-unit id="de97696f04df2d455746fc0459c7a0334ac08b94" translate="yes" xml:space="preserve">
          <source>Slices in scalar context return the last item of the slice.</source>
          <target state="translated">스칼라 컨텍스트의 조각은 조각의 마지막 항목을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="fade4867f2281855741bb2fdfae6ec6bfe669774" translate="yes" xml:space="preserve">
          <source>Slicing operations and parentheses cause the right-hand side to be evaluated in list context:</source>
          <target state="translated">슬라이싱 작업과 괄호로 인해 목록 컨텍스트에서 오른쪽이 평가됩니다.</target>
        </trans-unit>
        <trans-unit id="dcf621083da44b050ec0828499127db4dc13006b" translate="yes" xml:space="preserve">
          <source>SlickEdit</source>
          <target state="translated">SlickEdit</target>
        </trans-unit>
        <trans-unit id="71625e10c96350176b8faecaf24d1d897cf6efce" translate="yes" xml:space="preserve">
          <source>Slightly modified by Arthur Bergman to fit the new thread model/module.</source>
          <target state="translated">새로운 스레드 모델 / 모듈에 맞게 Arthur Bergman이 약간 수정했습니다.</target>
        </trans-unit>
        <trans-unit id="b6c149c3e00467fba347629a63ed02fed098d061" translate="yes" xml:space="preserve">
          <source>Slovakia</source>
          <target state="translated">Slovakia</target>
        </trans-unit>
        <trans-unit id="d1aa0503612aa4168939b77b59ca74532a11951a" translate="yes" xml:space="preserve">
          <source>Slovenia</source>
          <target state="translated">Slovenia</target>
        </trans-unit>
        <trans-unit id="945d75b6ccb37accbc9182a048ffec51dcd1a47f" translate="yes" xml:space="preserve">
          <source>Slurpy parameter not last</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c84511f9de85f2a5bea737ad0651170f5fc9c55" translate="yes" xml:space="preserve">
          <source>Smart matching a non-overloaded object breaks encapsulation</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c05c92e1201b3c7a99b14a3196c426c41067b9ce" translate="yes" xml:space="preserve">
          <source>Smartmatch Operator</source>
          <target state="translated">스마트 매치 연산자</target>
        </trans-unit>
        <trans-unit id="853b5644d464d7aa87bcee31b98647e7b0076053" translate="yes" xml:space="preserve">
          <source>Smartmatch expects to be able to allocate an op at run time, run it, and then throw it away. For that to work the op is simply malloced when PL_compcv hasn't been set up. So all slab-allocated ops are marked as such (&lt;code&gt;-&amp;gt;op_slabbed&lt;/code&gt;), to distinguish them from malloced ops.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="226b6fe8f9e2cd4e8ca8e6e55a94a83ba3f2cf5a" translate="yes" xml:space="preserve">
          <source>Smartmatch is experimental</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4adce585ab904a3b57996c9eacd1526a8856e59" translate="yes" xml:space="preserve">
          <source>Smartmatching of Objects</source>
          <target state="translated">객체의 스마트 매칭</target>
        </trans-unit>
        <trans-unit id="fcef3abf224b18a1a9539b5cd1a74a21f40eb21d" translate="yes" xml:space="preserve">
          <source>Smartmatching one hash against another reports whether both contain the same keys, no more and no less. This could be used to see whether two records have the same field names, without caring what values those fields might have. For example:</source>
          <target state="translated">하나의 해시를 다른 해시에 스마트 매칭하면 둘 다 동일한 키를 포함하는지 여부를보고합니다. 이를 통해 두 필드가 어떤 값을 가질 지 신경 쓰지 않고 두 레코드가 동일한 필드 이름을 갖는지 확인할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f02489100f7e7550e46dc3c0c8c28f36daa00353" translate="yes" xml:space="preserve">
          <source>Smoke testing Perl 5</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c177aabcbd4f359e0aaa8a530199381f4cf98371" translate="yes" xml:space="preserve">
          <source>Snooping</source>
          <target state="translated">Snooping</target>
        </trans-unit>
        <trans-unit id="4460e52ce30ee2f7dab472f65e7bc2c1c88dffad" translate="yes" xml:space="preserve">
          <source>So I got smart: I decided to be lazy and let the C compiler parse the C, which would spit out debugger stabs for me to read. These were much easier to parse. It's still not a pretty program, but at least it's more robust.</source>
          <target state="translated">그래서 나는 똑똑해졌다 : 나는 게으 르기로 결정하고 C 컴파일러가 C를 파싱하게하여 디버거 스테 이브를 읽을 수있게했다. 이것들은 파싱하기가 훨씬 쉬웠습니다. 그것은 여전히 ​​예쁜 프로그램은 아니지만 적어도 더 강력합니다.</target>
        </trans-unit>
        <trans-unit id="a1f5ce193c65cebf4de4614792ca39a016541f36" translate="yes" xml:space="preserve">
          <source>So a typical call to check would look like this:</source>
          <target state="translated">따라서 일반적인 확인 호출은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="32bf3b4ebf1dd24fdccf516f7c267bd10f4fed6f" translate="yes" xml:space="preserve">
          <source>So assuming the database created above, we can use &lt;code&gt;get_dup&lt;/code&gt; like this:</source>
          <target state="translated">위에서 만든 데이터베이스를 가정하면 다음 과 같이 &lt;code&gt;get_dup&lt;/code&gt; 을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9531481e3958e36f87e15fe09a502608d674e17a" translate="yes" xml:space="preserve">
          <source>So called because of a similar construct in &lt;b&gt;shells&lt;/b&gt; that pretends that the &lt;b&gt;lines&lt;/b&gt; following the &lt;b&gt;command&lt;/b&gt; are a separate &lt;b&gt;file&lt;/b&gt; to be fed to the command, up to some terminating string. In Perl, however, it&amp;rsquo;s just a fancy form of quoting.</source>
          <target state="translated">그래서 때문에 비슷한 구조의라는 &lt;b&gt;쉘&lt;/b&gt; 그 척 것을 &lt;b&gt;선&lt;/b&gt; 다음 &lt;b&gt;명령은&lt;/b&gt; 별도입니다 &lt;b&gt;파일&lt;/b&gt; 일부 종료 문자열로 명령에 공급되는 최대. 그러나 Perl에서는 단지 멋진 인용 형식 일뿐입니다.</target>
        </trans-unit>
        <trans-unit id="93e9a6ece24ada54b55dc7612c9389e7a638c36b" translate="yes" xml:space="preserve">
          <source>So each subroutine is born with an array of scratchpads (of length 1). On each entry to the subroutine it is checked that the current depth of the recursion is not more than the length of this array, and if it is, new scratchpad is created and pushed into the array.</source>
          <target state="translated">따라서 각 서브 루틴은 길이가 1 인 스크래치 패드 배열로 생성됩니다. 서브 루틴의 각 항목에서 재귀의 현재 깊이가이 배열의 길이보다 크지 않은지 확인하고, 새 스크래치 패드가 작성되어 배열로 푸시됩니다.</target>
        </trans-unit>
        <trans-unit id="c0f1f69e80ab7ebe217f8989a490d4af7ac57aa2" translate="yes" xml:space="preserve">
          <source>So far I've shown you nothing that</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bfd2a2cfe6e08c35c8f0019242b9920756d8258f" translate="yes" xml:space="preserve">
          <source>So far so good. But suppose the way you're implementing this is:</source>
          <target state="translated">여태까지는 그런대로 잘됐다. 그러나 이것을 구현하는 방법이 다음과 같다고 가정하십시오.</target>
        </trans-unit>
        <trans-unit id="99d938c6031e3ad535ec502cea56c5d218d4389a" translate="yes" xml:space="preserve">
          <source>So far so good. Those of you who have been paying attention will have spotted that the tied object hasn't been used so far. So lets add an extra method to the Remember class to allow comments to be included in the file; say, something like this:</source>
          <target state="translated">여태까지는 그런대로 잘됐다. 주의를 기울인 사람들은 지금까지 묶인 물체가 사용되지 않았 음을 발견했을 것입니다. 주석을 파일에 포함 할 수 있도록 Remember 클래스에 추가 메소드를 추가하십시오. 다음과 같이 말하십시오.</target>
        </trans-unit>
        <trans-unit id="438b9b4e31229df657e054c261ee9d298ca8b103" translate="yes" xml:space="preserve">
          <source>So far we've merely tried to find and list the experimental features and infer their inception, versions, etc. There's a lot of speculation here.</source>
          <target state="translated">지금까지 우리는 단지 실험적인 특징을 찾아서 나열하고 그것들의 시작, 버전 등을 추론하려고 시도했습니다.</target>
        </trans-unit>
        <trans-unit id="10bc3a4c124b48037408d12298d27779d339f321" translate="yes" xml:space="preserve">
          <source>So far, so good. With the knowledge above you can already perform searches with just about any literal string regexp you can dream up. Here is a</source>
          <target state="translated">여태까지는 그런대로 잘됐다. 위의 지식을 사용하면 상상할 수있는 리터럴 문자열 정규 표현식으로 이미 검색을 수행 할 수 있습니다. 여기에</target>
        </trans-unit>
        <trans-unit id="8af65d96d3224572aaaeff6426ae992e0bd5b192" translate="yes" xml:space="preserve">
          <source>So far, we're using just the normal list return mechanism. What happens if you want to pass or return a hash? Well, if you're using only one of them, or you don't mind them concatenating, then the normal calling convention is ok, although a little expensive.</source>
          <target state="translated">지금까지는 일반적인 목록 반환 메커니즘 만 사용하고 있습니다. 해시를 전달하거나 반환하려는 경우 어떻게됩니까? 글쎄, 당신이 그들 중 하나만 사용하거나 연결을 신경 쓰지 않는다면, 약간의 비싸지 만 정상적인 호출 규칙은 괜찮습니다.</target>
        </trans-unit>
        <trans-unit id="6a1a83e9f4437f40c54f1506b859ac7294d0d128" translate="yes" xml:space="preserve">
          <source>So far, we've seen literals used as templates. If the list of pack items doesn't have fixed length, an expression constructing the template is required (whenever, for some reason, &lt;code&gt;()*&lt;/code&gt; cannot be used). Here's an example: To store named string values in a way that can be conveniently parsed by a C program, we create a sequence of names and null terminated ASCII strings, with &lt;code&gt;=&lt;/code&gt; between the name and the value, followed by an additional delimiting null byte. Here's how:</source>
          <target state="translated">지금까지 템플릿으로 사용 된 리터럴을 보았습니다. 팩 항목 목록의 길이가 고정되어 있지 않으면 템플릿을 구성하는식이 필요합니다 (어떤 이유로 든 &lt;code&gt;()*&lt;/code&gt; 를 사용할 수없는 경우). 예를 들면 다음과 같습니다. C 프로그램에서 편리하게 구문 분석 할 수있는 방식으로 명명 된 문자열 값을 저장하기 위해 &lt;code&gt;=&lt;/code&gt; 와 함께 일련의 이름과 null로 끝나는 ASCII 문자열을 만듭니다. 사이에 가 포함 다음 추가로 구분되는 null 바이트 . 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7a5692420708108a4d7ad47094be88b57cf9bf66" translate="yes" xml:space="preserve">
          <source>So for English (with Bracket Notation) &lt;code&gt;&quot;...[quant,_1,file]...&quot;&lt;/code&gt; is fine (for 0 it returns &quot;0 files&quot;, for 1 it returns &quot;1 file&quot;, and for more it returns &quot;2 files&quot;, etc.)</source>
          <target state="translated">따라서 영어 (괄호 표기법 포함)의 경우 &lt;code&gt;&quot;...[quant,_1,file]...&quot;&lt;/code&gt; 은 괜찮습니다 (0의 경우 &quot;0 파일&quot;을 반환하고 1의 경우 &quot;1 파일&quot;을 반환 함). 2 개 파일 &quot;등)</target>
        </trans-unit>
        <trans-unit id="8477c048b776b6250b8d3a6b206bd8a95a79a9ff" translate="yes" xml:space="preserve">
          <source>So for example, instead of using:</source>
          <target state="translated">예를 들어 다음을 사용하는 대신</target>
        </trans-unit>
        <trans-unit id="23a15c81788a2c5aff56ccaef77af7e0b8ce44eb" translate="yes" xml:space="preserve">
          <source>So given the diagram above, Perl will search &lt;code&gt;Child&lt;/code&gt; , &lt;code&gt;Father&lt;/code&gt; , &lt;code&gt;PaternalGrandparent&lt;/code&gt; , &lt;code&gt;SharedGreatGrandParent&lt;/code&gt; , &lt;code&gt;Mother&lt;/code&gt; , and finally &lt;code&gt;MaternalGrandparent&lt;/code&gt; . This may be a problem because now we're looking in &lt;code&gt;SharedGreatGrandParent&lt;/code&gt;</source>
          <target state="translated">따라서 위의 다이어그램을 통해 Perl은 &lt;code&gt;Child&lt;/code&gt; , &lt;code&gt;Father&lt;/code&gt; , &lt;code&gt;PaternalGrandparent&lt;/code&gt; , &lt;code&gt;SharedGreatGrandParent&lt;/code&gt; , &lt;code&gt;Mother&lt;/code&gt; 및 &lt;code&gt;MaternalGrandparent&lt;/code&gt; 검색 합니다. 이것은 우리가 &lt;code&gt;SharedGreatGrandParent&lt;/code&gt; 를 보고 있기 때문에 문제가 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5f8c16c38e4b1347fbe4bd6bed13c87b6b97a967" translate="yes" xml:space="preserve">
          <source>So given the diagram above, Perl will search &lt;code&gt;Child&lt;/code&gt;, &lt;code&gt;Father&lt;/code&gt;, &lt;code&gt;PaternalGrandparent&lt;/code&gt;, &lt;code&gt;SharedGreatGrandParent&lt;/code&gt;, &lt;code&gt;Mother&lt;/code&gt;, and finally &lt;code&gt;MaternalGrandparent&lt;/code&gt;. This may be a problem because now we're looking in &lt;code&gt;SharedGreatGrandParent&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="91f4e47cc018c4b1c4ca9fc78408994ad8035bd1" translate="yes" xml:space="preserve">
          <source>So here is the bottom line--if you are sure that control will revert back to the enclosing Perl scope fairly quickly after the end of your callback, then it isn't absolutely necessary to dispose explicitly of any temporaries you may have created. Mind you, if you are at all uncertain about what to do, it doesn't do any harm to tidy up anyway.</source>
          <target state="translated">결론은 다음과 같습니다. 콜백이 끝난 후 컨트롤이 엔 클로징 Perl 스코프로 상당히 빠르게 되돌아 갈 것이라고 확신한다면 생성 한 임시 파일을 명시 적으로 폐기 할 필요는 없습니다. 당신이 무엇을 해야할지 전혀 확실하지 않다면 어쨌든 정리해도 아무런 해를 끼치 지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4443d502fbd614fe670f624b7a8d6e87d74c5b32" translate="yes" xml:space="preserve">
          <source>So hopefully you've now got a few ideas about what's good to modularise. Let's now see how it's done.</source>
          <target state="translated">이제 모듈화하기에 좋은 아이디어가 생겼기를 바랍니다. 이제 어떻게되는지 봅시다.</target>
        </trans-unit>
        <trans-unit id="6d3a27421600e7d4abecd702bd20845b8466123d" translate="yes" xml:space="preserve">
          <source>So how do I use a proxy with File::Fetch?</source>
          <target state="translated">그렇다면 File :: Fetch와 함께 프록시를 어떻게 사용합니까?</target>
        </trans-unit>
        <trans-unit id="9d00ee45ac1982b7db0dbf721dd3e3787ed6d62f" translate="yes" xml:space="preserve">
          <source>So how do you use a source filter in a Perl script? Above, I said that a source filter is just a special kind of module. Like all Perl modules, a source filter is invoked with a use statement.</source>
          <target state="translated">그렇다면 Perl 스크립트에서 소스 필터를 어떻게 사용합니까? 위에서 소스 필터는 특별한 종류의 모듈이라고 말했습니다. 모든 Perl 모듈과 마찬가지로 소스 필터는 use 문으로 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="6cca2cb75a50d0827a566440232066af85d09fbe" translate="yes" xml:space="preserve">
          <source>So how does it work?</source>
          <target state="translated">어떻게 작동합니까?</target>
        </trans-unit>
        <trans-unit id="7fc04ce8d1c409ed6d44985cf7b3c46dd155a24f" translate="yes" xml:space="preserve">
          <source>So how hard could that be? You look at the code that produces the first item, and it reads:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9612f816ae3d1d599129006ddc23ec570699e275" translate="yes" xml:space="preserve">
          <source>So if you take for example the shell command</source>
          <target state="translated">예를 들어 쉘 명령을 사용하면</target>
        </trans-unit>
        <trans-unit id="557e6fd5bed4c1d07e89cc778dd5ffa04e712afb" translate="yes" xml:space="preserve">
          <source>So if you want to check the validity of the encoding, surround the expression with &lt;code&gt;&lt;a href=&quot;../functions/eval&quot;&gt;eval&lt;/a&gt; {}&lt;/code&gt; block as follows;</source>
          <target state="translated">따라서 인코딩의 유효성을 확인하려면 다음과 같이 식을 &lt;code&gt;&lt;a href=&quot;../functions/eval&quot;&gt;eval&lt;/a&gt; {}&lt;/code&gt; 블록으로 묶습니다.</target>
        </trans-unit>
        <trans-unit id="a821fbe9858bdf4860678fd5e1e7551e3704e346" translate="yes" xml:space="preserve">
          <source>So if you want to check the validity of the encoding, surround the expression with &lt;code&gt;eval {}&lt;/code&gt; block as follows;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7e30a7ebf49e6593b8da91cf7504894e9cfa473" translate="yes" xml:space="preserve">
          <source>So if you were to supply a new, complete, top-level source file to add to Perl, you should conform to this peculiar practice by yourself selecting an appropriate quotation from Tolkien, retaining the original spelling and punctuation and using the same format the rest of the quotes are in. Indirect and oblique is just fine; remember, it's a metaphor, so being meta is, after all, what it's for.</source>
          <target state="translated">따라서 Perl에 추가 할 새롭고 완전한 최상위 소스 파일을 제공하려면 Tolkien에서 적절한 견적을 선택하고 원래 철자와 구두점을 유지하고 나머지 형식과 동일한 형식을 사용하여이 고유 한 방법을 준수해야합니다. 인용 부호가있다. 간접적이고 비스듬한 것은 괜찮다. 메타포는 메타포라는 사실을 기억하십시오. 결국 메타라는 것은 그 목적을위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="02bb4252af15d73e7777da1a95cce444353d918a" translate="yes" xml:space="preserve">
          <source>So if you're working with Unicode data, consult the documentation of every module you're using if there are any issues with Unicode data exchange. If the documentation does not talk about Unicode at all, suspect the worst and probably look at the source to learn how the module is implemented. Modules written completely in Perl shouldn't cause problems. Modules that directly or indirectly access code written in other programming languages are at risk.</source>
          <target state="translated">따라서 유니 코드 데이터로 작업하는 경우 유니 코드 데이터 교환에 문제가있는 경우 사용중인 모든 모듈의 설명서를 참조하십시오. 문서가 유니 코드에 대해 전혀 이야기하지 않는다면 최악의 상황을 의심하고 소스를보고 모듈이 어떻게 구현되는지 알아보십시오. Perl로 완전히 작성된 모듈은 문제를 일으키지 않아야합니다. 다른 프로그래밍 언어로 작성된 코드에 직접 또는 간접적으로 액세스하는 모듈이 위험합니다.</target>
        </trans-unit>
        <trans-unit id="e319523cadbb2780f0ef0af26ce5a7a559c73594" translate="yes" xml:space="preserve">
          <source>So in VMS its pm_to_blib.ts.</source>
          <target state="translated">VMS에서는 pm_to_blib.ts입니다.</target>
        </trans-unit>
        <trans-unit id="3bce9b15392a6c8658669f57b4a2decac3558eb6" translate="yes" xml:space="preserve">
          <source>So instead you'll want to do something like this:</source>
          <target state="translated">따라서 대신 다음과 같은 작업을 원할 것입니다.</target>
        </trans-unit>
        <trans-unit id="6161c23b3048d528f32556aeffc6deb23d6328c9" translate="yes" xml:space="preserve">
          <source>So it is round-trip safe for \xF9\xF9. But if the line above is upside down, here is what happens.</source>
          <target state="translated">따라서 \ xF9 \ xF9에 대해 왕복 안전합니다. 그러나 위의 줄이 거꾸로되어 있으면 다음과 같이됩니다.</target>
        </trans-unit>
        <trans-unit id="c06ae4675003e825258b16549181d9f72cc7560a" translate="yes" xml:space="preserve">
          <source>So it's clearer and best to use the compound form when specifying blocks. And be sure that is what you really really want to do. In most cases scripts are what you want instead.</source>
          <target state="translated">따라서 블록을 지정할 때 복합 형식을 사용하는 것이 더 명확하고 가장 좋습니다. 그리고 그것이 당신이 정말로하고 싶은 일인지 확인하십시오. 대부분의 경우 스크립트가 대신 원하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="3007e0313fdaf4be553a40db748fe3ab3979d2d6" translate="yes" xml:space="preserve">
          <source>So just remember always to use the array or hash constructors with &lt;code&gt;[]&lt;/code&gt; or &lt;code&gt;{}&lt;/code&gt; , and you'll be fine, although it's not always optimally efficient.</source>
          <target state="translated">따라서 항상 &lt;code&gt;[]&lt;/code&gt; 또는 &lt;code&gt;{}&lt;/code&gt; 과 함께 배열 또는 해시 생성자를 사용하는 것을 잊지 마십시오. 항상 최적의 효율은 아니지만 괜찮습니다.</target>
        </trans-unit>
        <trans-unit id="d027afb082f340c36adda48951c99192de3bf3d9" translate="yes" xml:space="preserve">
          <source>So just remember always to use the array or hash constructors with &lt;code&gt;[]&lt;/code&gt; or &lt;code&gt;{}&lt;/code&gt;, and you'll be fine, although it's not always optimally efficient.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="28f6b3059bd71a14d4d6430ebaa792ae77f9b5ae" translate="yes" xml:space="preserve">
          <source>So much for textual data. Let's get onto the meaty stuff that &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; are best at: handling binary formats for numbers. There is, of course, not just one binary format - life would be too simple - but Perl will do all the finicky labor for you.</source>
          <target state="translated">텍스트 데이터의 경우 너무 많습니다. 이제 그 고기 물건에하자 &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; 숫자 바이너리 형식을 처리 :에 최고입니다. 물론 이진 형식은 하나뿐입니다. 인생은 너무 단순 할 것입니다. 그러나 Perl은 모든 까다로운 작업을 수행 할 것입니다.</target>
        </trans-unit>
        <trans-unit id="c03e630c08b97b3f5b437a4e7c4b378ae3776973" translate="yes" xml:space="preserve">
          <source>So much for textual data. Let's get onto the meaty stuff that &lt;code&gt;pack&lt;/code&gt; and &lt;code&gt;unpack&lt;/code&gt; are best at: handling binary formats for numbers. There is, of course, not just one binary format - life would be too simple - but Perl will do all the finicky labor for you.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6434510a7a13803f70088fd4384a0dc891e9b671" translate="yes" xml:space="preserve">
          <source>So neither &lt;code&gt;latin1&lt;/code&gt; nor &lt;code&gt;ascii&lt;/code&gt; are incompatible with the &lt;code&gt;utf8&lt;/code&gt; flag - they only govern when the JSON output engine escapes a character or not.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f6d818d0bc8716d4413f806e54c839d9543bd1d" translate="yes" xml:space="preserve">
          <source>So now &lt;code&gt;tie $scalar&lt;/code&gt; will always tie the scalar, not the handle it holds. To tie the handle, use &lt;code&gt;tie *$scalar&lt;/code&gt; (with an explicit asterisk). The same applies to &lt;code&gt;tied *$scalar&lt;/code&gt; and &lt;code&gt;untie *$scalar&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19e5670a7ba385b708ff4bcfadcd36a0825afece" translate="yes" xml:space="preserve">
          <source>So now this code would be written:</source>
          <target state="translated">이제이 코드가 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="7ec657e348cc94be548b290696e0a818e7f982d5" translate="yes" xml:space="preserve">
          <source>So now you have a file ending in .tar.gz (or, less often, .zip). You know there's a tasty module inside. There are four steps you must now take:</source>
          <target state="translated">이제 .tar.gz (또는 .zip)로 끝나는 파일이 있습니다. 당신은 내부에 맛있는 모듈이 있다는 것을 알고 있습니다. 이제 네 단계를 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="9f7f09ef2fcd4d20ffdab1795e6c221c8b2cdf50" translate="yes" xml:space="preserve">
          <source>So please select carefully what library you want to use.</source>
          <target state="translated">사용할 라이브러리를 신중하게 선택하십시오.</target>
        </trans-unit>
        <trans-unit id="fc4d504736579a86ac1ba1abd47d391cec08a768" translate="yes" xml:space="preserve">
          <source>So put in parentheses to say what you really mean.</source>
          <target state="translated">괄호로 묶어 실제로 의미하는 바를 말하십시오.</target>
        </trans-unit>
        <trans-unit id="291a379872204cd90f4de2f2a608af9f0d7dabed" translate="yes" xml:space="preserve">
          <source>So specifically, autoloaded functions cannot see package lexicals (this applies to both the &lt;b&gt;SelfLoader&lt;/b&gt; and the Autoloader). The &lt;code&gt;vars&lt;/code&gt; pragma provides an alternative to defining package-level globals that will be visible to autoloaded routines. See the documentation on &lt;b&gt;vars&lt;/b&gt; in the pragma section of &lt;a href=&quot;perlmod&quot;&gt;perlmod&lt;/a&gt;.</source>
          <target state="translated">그래서 특히, 자동으로 적재 기능 (이것은 모두 적용 패키지 lexicals을 볼 수 &lt;b&gt;SelfLoader&lt;/b&gt; 및 오토로더). 은 &lt;code&gt;vars&lt;/code&gt; 프라그가 자동으로 적재 루틴 표시되는 패키지 레벨의 전역을 정의의 대안을 제공한다. &lt;a href=&quot;perlmod&quot;&gt;perlmod&lt;/a&gt; 의 pragma 섹션 에서 &lt;b&gt;vars&lt;/b&gt; 에 대한 문서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="178e0296c43b2c22ca3149a0d363aa4b6a82de7c" translate="yes" xml:space="preserve">
          <source>So that's how we consume and produce fixed-width data. Let's recap what we've seen of &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; so far:</source>
          <target state="translated">이것이 우리가 고정 폭 데이터를 소비하고 생산하는 방법입니다. 우리가 무엇을 본 적이하자 정리해 &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; 지금까지 :</target>
        </trans-unit>
        <trans-unit id="ae19d4915e0b62760549bd4eeb2c1e92ef2ac7db" translate="yes" xml:space="preserve">
          <source>So that's how we consume and produce fixed-width data. Let's recap what we've seen of &lt;code&gt;pack&lt;/code&gt; and &lt;code&gt;unpack&lt;/code&gt; so far:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da5a5de8356ec781cae3674738f4fa4085230f11" translate="yes" xml:space="preserve">
          <source>So the Perl interface would look like this</source>
          <target state="translated">따라서 Perl 인터페이스는 다음과 같습니다</target>
        </trans-unit>
        <trans-unit id="eb361df349469f52fd13dc7f637fd6d3f4002c01" translate="yes" xml:space="preserve">
          <source>So the Perl subroutine would look like this:</source>
          <target state="translated">따라서 Perl 서브 루틴은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f9e5e29abec6c42a24502ee051f01eb881622a3a" translate="yes" xml:space="preserve">
          <source>So the exit codes are...</source>
          <target state="translated">종료 코드는 ...</target>
        </trans-unit>
        <trans-unit id="ecdcbf5b6eec0983bdba576e908b1b991d7bdaa0" translate="yes" xml:space="preserve">
          <source>So the methods &lt;code&gt;PrintID&lt;/code&gt; and &lt;code&gt;Display&lt;/code&gt; can be invoked like this:</source>
          <target state="translated">따라서 &lt;code&gt;PrintID&lt;/code&gt; 및 &lt;code&gt;Display&lt;/code&gt; 메소드를 다음 과 같이 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fc02af530f320939749f4c5dd232069afbb23ee8" translate="yes" xml:space="preserve">
          <source>So the return value will be true if the seek operation was successful. For failure, a false value is returned and &lt;code&gt;fileLastError()&lt;/code&gt; and &lt;code&gt;$^E&lt;/code&gt; are set to the reason for the failure.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc7fd8e534a0a64d6932df0e7228b52bddc2accd" translate="yes" xml:space="preserve">
          <source>So these now have simple defaults rather than probing at build-time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="050bc5740a1b6bb30a161c3c46fabef260c75737" translate="yes" xml:space="preserve">
          <source>So this:</source>
          <target state="translated">그래서 이거:</target>
        </trans-unit>
        <trans-unit id="65f64a88a88a2a42947aa812e415dc968ce4fc3b" translate="yes" xml:space="preserve">
          <source>So to repeat always use SvOK() to check whether an sv is defined.</source>
          <target state="translated">따라서 반복하려면 항상 SvOK ()를 사용하여 sv가 정의되어 있는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="ec007077340f2b45239679ca4cc61f38315a3433" translate="yes" xml:space="preserve">
          <source>So what happened to dTHR?</source>
          <target state="translated">그래서 dTHR은 어떻게 되었습니까?</target>
        </trans-unit>
        <trans-unit id="dd71b3066f2c37ca89d49c13416a448baf2ad1f1" translate="yes" xml:space="preserve">
          <source>So what has this got to do with &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt;? Well, if you want to compose a Unicode string (that is internally encoded as UTF-8), you can do so by using template code &lt;code&gt;U&lt;/code&gt; . As an example, let's produce the Euro currency symbol (code number 0x20AC):</source>
          <target state="translated">이것이 &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; 과 어떤 관련이 있습니까? 내부적으로 UTF-8로 인코딩 된 유니 코드 문자열을 작성하려면 템플릿 코드 &lt;code&gt;U&lt;/code&gt; 를 사용하면됩니다 . 예를 들어, 유로화 기호 (코드 번호 0x20AC)를 만들어 봅시다.</target>
        </trans-unit>
        <trans-unit id="be8214c7c17783a92e4d370b91d6755f26454042" translate="yes" xml:space="preserve">
          <source>So what has this got to do with &lt;code&gt;pack&lt;/code&gt;? Well, if you want to compose a Unicode string (that is internally encoded as UTF-8), you can do so by using template code &lt;code&gt;U&lt;/code&gt;. As an example, let's produce the Euro currency symbol (code number 0x20AC):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76db05e5ac37110bc4537d598a8e57f24d0e7d58" translate="yes" xml:space="preserve">
          <source>So what is the big problem? Well, if you are expecting Perl to tidy up those temporaries for you, you might be in for a long wait. For Perl to dispose of your temporaries, control must drop back to the enclosing scope at some stage. In the event driven scenario that may never happen. This means that, as time goes on, your program will create more and more temporaries, none of which will ever be freed. As each of these temporaries consumes some memory your program will eventually consume all the available memory in your system--kapow!</source>
          <target state="translated">그렇다면 큰 문제는 무엇입니까? 글쎄, 만약 당신이 Perl이 당신을 위해 그 임시를 정리할 것을 기대한다면, 당신은 오래 기다릴지도 모른다. Perl이 임시를 처리하려면 제어가 어떤 단계에서 둘러싸는 범위로 되돌아 가야합니다. 발생하지 않는 이벤트 중심 시나리오에서. 이것은 시간이 지남에 따라 프로그램이 점점 더 많은 임시를 만들 것임을 의미합니다. 이러한 각 임시 메모리가 약간의 메모리를 소비함에 따라 프로그램은 결국 시스템에서 사용 가능한 모든 메모리 인 kapow를 소비하게됩니다!</target>
        </trans-unit>
        <trans-unit id="49dd0c06fd8f279176f457e7dd90bd0af2090341" translate="yes" xml:space="preserve">
          <source>So what's new?</source>
          <target state="translated">새로운 소식있어?</target>
        </trans-unit>
        <trans-unit id="8be287051544a93972a5fe33ce5f2eed6334bad0" translate="yes" xml:space="preserve">
          <source>So when the output is a filehandle it will carry out a seek to the eof before writing any compressed data. If the output is a filename, it will be opened for appending. If the output is a buffer, all compressed data will be appended to the existing buffer.</source>
          <target state="translated">따라서 출력이 파일 핸들 인 경우 압축 된 데이터를 쓰기 전에 eof를 검색합니다. 출력이 파일 이름이면 추가를 위해 열립니다. 출력이 버퍼 인 경우 모든 압축 된 데이터가 기존 버퍼에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="2b16151fbc25d8d9908507f5cf41dca81006fcb5" translate="yes" xml:space="preserve">
          <source>So when the output is a filehandle it will carry out a seek to the eof before writing any uncompressed data. If the output is a filename, it will be opened for appending. If the output is a buffer, all uncompressed data will be appended to the existing buffer.</source>
          <target state="translated">따라서 출력이 파일 핸들 인 경우 압축되지 않은 데이터를 쓰기 전에 eof를 검색합니다. 출력이 파일 이름이면 추가를 위해 열립니다. 출력이 버퍼 인 경우 압축되지 않은 모든 데이터가 기존 버퍼에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="faf320f95dede4954f64d637d17b4ef0ec2ac56b" translate="yes" xml:space="preserve">
          <source>So when we parse &lt;code&gt;/foo/&lt;/code&gt; we see something like the following table. The left shows what is being parsed, and the number indicates where the next regop would go. The stuff on the right is the trace output of the graph. The names are chosen to be short to make it less dense on the screen. 'tsdy' is a special form of &lt;code&gt;regtail()&lt;/code&gt; which does some extra analysis.</source>
          <target state="translated">따라서 &lt;code&gt;/foo/&lt;/code&gt; 파싱 하면 다음 표와 같은 것이 보입니다. 왼쪽은 구문 분석중인 내용을 나타내고 숫자는 다음 regop의 위치를 ​​나타냅니다. 오른쪽에있는 것은 그래프의 트레이스 출력입니다. 이름은 화면에서 밀도가 떨어지도록 짧게 선택됩니다. 'tsdy'는 추가적인 분석을 수행 하는 특별한 형태의 &lt;code&gt;regtail()&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="4ca42b2545bb9f74c7dfcf26ad336456861738d0" translate="yes" xml:space="preserve">
          <source>So why is UNINST=1 not the default?</source>
          <target state="translated">그렇다면 UNINST = 1이 기본값이 아닌 이유는 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="5764d39b6b45dd4fdf0407e6dadfbf8730c1c2c3" translate="yes" xml:space="preserve">
          <source>So why use these? They produce better diagnostics on failure. &lt;code&gt;ok()&lt;/code&gt; cannot know what you are testing for (beyond the name), but &lt;code&gt;is()&lt;/code&gt; and &lt;code&gt;isnt()&lt;/code&gt; know what the test was and why it failed. For example this test:</source>
          <target state="translated">왜 이것을 사용합니까? 고장에 대한 진단이 향상됩니다. &lt;code&gt;ok()&lt;/code&gt; 는 (이름을 넘어서) 무엇을 테스트하고 있는지 알 수 없지만 &lt;code&gt;is()&lt;/code&gt; 와 &lt;code&gt;isnt()&lt;/code&gt; 는 테스트가 무엇이며 왜 실패했는지 알 수 있습니다. 예를 들어이 테스트는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0723871c8efb4af11337b70788bc11e5f341de34" translate="yes" xml:space="preserve">
          <source>So why would you ever want to use a Unix domain socket instead of a simpler named pipe? Because a named pipe doesn't give you sessions. You can't tell one process's data from another's. With socket programming, you get a separate session for each client; that's why accept() takes two arguments.</source>
          <target state="translated">그렇다면 왜 단순한 이름의 파이프 대신 유닉스 도메인 소켓을 사용하고 싶습니까? 명명 된 파이프는 세션을 제공하지 않기 때문입니다. 한 프로세스의 데이터를 다른 프로세스의 데이터로 알 수 없습니다. 소켓 프로그래밍을 사용하면 각 클라이언트마다 별도의 세션이 있습니다. 따라서 accept ()는 두 개의 인수를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="907dfd8f705f1e1d725ffd018f44b3318d9e84e1" translate="yes" xml:space="preserve">
          <source>So you can figure out what went wrong without rerunning the test.</source>
          <target state="translated">따라서 테스트를 다시 실행하지 않고 무엇이 잘못되었는지 파악할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="23330e80d1d5c0a1be567b0263265e46b7f62019" translate="yes" xml:space="preserve">
          <source>So you rewrite it to read:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85a109f19c85f2e155b7bae45252c43e85217d92" translate="yes" xml:space="preserve">
          <source>So you should instead try this;</source>
          <target state="translated">따라서 대신 이것을 시도해야합니다.</target>
        </trans-unit>
        <trans-unit id="99368e21d7e985fc9382de7cbad3270d6b572550" translate="yes" xml:space="preserve">
          <source>So you want to know what &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; actually does?</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; 실제로 무엇을하는지 알고 싶 습니까?</target>
        </trans-unit>
        <trans-unit id="f880312d8311a1d75dbe80304cdf01f9913e6eb1" translate="yes" xml:space="preserve">
          <source>So you want to know what &lt;code&gt;import&lt;/code&gt; actually does?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d98457d69f47757522cf080b8cba6d90757ec58b" translate="yes" xml:space="preserve">
          <source>So, beside calls like</source>
          <target state="translated">그래서, 같은 통화 옆에</target>
        </trans-unit>
        <trans-unit id="8b676466aa2043751e164c60e8f768fad4f2409b" translate="yes" xml:space="preserve">
          <source>So, for classes and subclasses to have inheritance correctly work with autoloading, you need to ensure stubs are loaded.</source>
          <target state="translated">따라서 클래스와 서브 클래스에서 상속이 자동로드와 올바르게 작동하게하려면 스텁이로드되어 있는지 확인해야합니다.</target>
        </trans-unit>
        <trans-unit id="3fdc850c88acfeea0034b4d0a5ecf1cbe8955116" translate="yes" xml:space="preserve">
          <source>So, for example, &quot;wb9&quot; means open for writing with the maximum compression using the default strategy and &quot;wb4R&quot; means open for writing with compression level 4 and run-length encoding.</source>
          <target state="translated">예를 들어, &quot;wb9&quot;는 기본 전략을 사용하여 최대 압축으로 쓰기 위해 열기를 의미하고 &quot;wb4R&quot;은 압축 레벨 4 및 실행 길이 인코딩으로 쓰기 위해 열려 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="ef8d2c630e8e6fd22bf1a2656520cdc24a0e732f" translate="yes" xml:space="preserve">
          <source>So, for example, say you have a file compressed with gzip that you want to recompress with bzip2. Here is all that is needed to carry out the recompression.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98d3c65256a4087c70ab29c5923eefef7208b53e" translate="yes" xml:space="preserve">
          <source>So, for instance, to pack 20302 to a signed 16 bit integer in your computer's representation you write</source>
          <target state="translated">예를 들어, 컴퓨터 표현에서 부호있는 16 비트 정수로 20302를 패킹하려면</target>
        </trans-unit>
        <trans-unit id="5a026df42e6a15ca497ded704c00f477c0e8e518" translate="yes" xml:space="preserve">
          <source>So, if you see two terms with an &lt;code&gt;=&lt;/code&gt; or &lt;code&gt;+&lt;/code&gt; , between them, you can turn them into a single expression. When you do this, you execute the code in the block on the next line: if you see &lt;code&gt;=&lt;/code&gt; , you'll do the code in line 2. If you see &lt;code&gt;+&lt;/code&gt; , you'll do the code in line 4. It's this code which contributes to the op tree.</source>
          <target state="translated">따라서 &lt;code&gt;=&lt;/code&gt; 또는 &lt;code&gt;+&lt;/code&gt; 가 포함 된 두 개의 용어가 있으면 그 용어를 하나의 표현식으로 바꿀 수 있습니다. 이 작업을 수행하면 다음 줄의 블록에서 코드를 실행합니다. &lt;code&gt;=&lt;/code&gt; 가 표시 되면 2 행에서 코드를 수행합니다. &lt;code&gt;+&lt;/code&gt; 가 표시되면 4 행에서 코드를 수행하는 것입니다.이 코드입니다 op 트리에 기여합니다.</target>
        </trans-unit>
        <trans-unit id="0379bb60c338fa89d5d14562ac618c3cb90f2526" translate="yes" xml:space="preserve">
          <source>So, if you see two terms with an &lt;code&gt;=&lt;/code&gt; or &lt;code&gt;+&lt;/code&gt;, between them, you can turn them into a single expression. When you do this, you execute the code in the block on the next line: if you see &lt;code&gt;=&lt;/code&gt;, you'll do the code in line 2. If you see &lt;code&gt;+&lt;/code&gt;, you'll do the code in line 4. It's this code which contributes to the op tree.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f012b7bad59a01daf6da8ed100b9c040ae573c55" translate="yes" xml:space="preserve">
          <source>So, if you want to collect memory info in a cycle, you may call</source>
          <target state="translated">따라서주기마다 메모리 정보를 수집하려는 경우</target>
        </trans-unit>
        <trans-unit id="f33ef09895b9595e58c40994534996d41b9b84f6" translate="yes" xml:space="preserve">
          <source>So, in general, &quot;state&quot; subroutines are faster. But &quot;my&quot; subs are necessary if you want to create closures:</source>
          <target state="translated">따라서 일반적으로 &quot;상태&quot;서브 루틴이 더 빠릅니다. 그러나 클로저를 만들려면 &quot;my&quot;하위가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="b92446e0fc5150a550f9b239a78e7589775be2a5" translate="yes" xml:space="preserve">
          <source>So, let's say you want to add a custom element called 'foo'. In your subclass's &lt;code&gt;new&lt;/code&gt; method, after calling &lt;code&gt;SUPER::new&lt;/code&gt; you'd call:</source>
          <target state="translated">'foo'라는 사용자 정의 요소를 추가한다고 가정 해 봅시다. 서브 클래스의 &lt;code&gt;new&lt;/code&gt; 메소드에서 &lt;code&gt;SUPER::new&lt;/code&gt; 를 호출 한 후 다음을 호출합니다.</target>
        </trans-unit>
        <trans-unit id="6f5a18b784416c2faf1e8dee13b0302a69a860cf" translate="yes" xml:space="preserve">
          <source>So, on the advice of the gettext manual, you rewrite:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04546d861006181e7076b52be007eeaf163f592b" translate="yes" xml:space="preserve">
          <source>So, rather than having to say:</source>
          <target state="translated">따라서 말하기보다는</target>
        </trans-unit>
        <trans-unit id="ce7cf438ffd137d4b9ae434030e4dd1bac347bb0" translate="yes" xml:space="preserve">
          <source>So, saying &lt;code&gt;11 &amp;amp; 3&lt;/code&gt; performs the &quot;and&quot; operation on numbers (yielding &lt;code&gt;3&lt;/code&gt; ). Saying &lt;code&gt;&quot;11&quot; &amp;amp; &quot;3&quot;&lt;/code&gt; performs the &quot;and&quot; operation on strings (yielding &lt;code&gt;&quot;1&quot;&lt;/code&gt; ).</source>
          <target state="translated">따라서 &lt;code&gt;11 &amp;amp; 3&lt;/code&gt; 은 숫자에 대해 &quot;and&quot;연산을 수행합니다 (수량 &lt;code&gt;3&lt;/code&gt; ). 말하는 &lt;code&gt;&quot;11&quot; &amp;amp; &quot;3&quot;&lt;/code&gt; 을 수행 문자열에서 &quot;및&quot;동작 (항복 &lt;code&gt;&quot;1&quot;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="82342d83c583203ac699858cccf76690e3807bf1" translate="yes" xml:space="preserve">
          <source>So, saying &lt;code&gt;11 &amp;amp; 3&lt;/code&gt; performs the &quot;and&quot; operation on numbers (yielding &lt;code&gt;3&lt;/code&gt;). Saying &lt;code&gt;&quot;11&quot; &amp;amp; &quot;3&quot;&lt;/code&gt; performs the &quot;and&quot; operation on strings (yielding &lt;code&gt;&quot;1&quot;&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a687b4464c81c65ad71b0b242c9a17889c06be5" translate="yes" xml:space="preserve">
          <source>So, sometimes you might want to use symbolic references to manipulate the symbol table directly. This doesn't matter for formats, handles, and subroutines, because they are always global--you can't use my() on them. For scalars, arrays, and hashes, though--and usually for subroutines-- you probably only want to use hard references.</source>
          <target state="translated">따라서 때로는 기호 참조를 사용하여 기호 테이블을 직접 조작 할 수도 있습니다. 형식, 핸들 및 서브 루틴은 중요하므로 항상 전역 적이므로 my ()를 사용할 수 없습니다. 스칼라, 배열 및 해시 (보통 서브 루틴의 경우)의 경우 하드 참조 만 사용하려고합니다.</target>
        </trans-unit>
        <trans-unit id="988f750cf0c3c51b512a9cb6f00133978c0404e1" translate="yes" xml:space="preserve">
          <source>So, the following examples now works as expected:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b62c1a83484ac0f80542a2de9bd04874ec15952" translate="yes" xml:space="preserve">
          <source>So, the following examples will now work all as expected:</source>
          <target state="translated">따라서 다음 예제는 이제 예상대로 작동합니다.</target>
        </trans-unit>
        <trans-unit id="b83b5043b490e39d23dba00f7ce754a2ed020ba9" translate="yes" xml:space="preserve">
          <source>So, the following line:</source>
          <target state="translated">따라서 다음 줄은</target>
        </trans-unit>
        <trans-unit id="e43264c4b337b0feb1da1b34ab4669d9bfde22ae" translate="yes" xml:space="preserve">
          <source>So, the following two statements do the same thing:</source>
          <target state="translated">따라서 다음 두 문장은 같은 일을합니다.</target>
        </trans-unit>
        <trans-unit id="0f5b24deb12867f441d62aa11cf38e02b6693a70" translate="yes" xml:space="preserve">
          <source>So, the string of Martian &quot;I am CVSGXX!&quot; uses 12 bytes to encode the nine characters 'I', ' ', 'a', 'm', ' ', 'CV', 'SG', 'XX', '!'.</source>
          <target state="translated">그래서 화성의 문자열 &quot;나는 CVSGXX입니다!&quot; 12 바이트를 사용하여 9 개의 문자 'I', '', 'a', 'm', '', 'CV', 'SG', 'XX', '!'를 인코딩합니다.</target>
        </trans-unit>
        <trans-unit id="93058ef0377751cf8a22fa887d9f94acca14dc08" translate="yes" xml:space="preserve">
          <source>So, this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23a65604ac4ef3bcdf6fdcf41ebba719fc161bed" translate="yes" xml:space="preserve">
          <source>So, what needs to replace gettext is a system that supports lexicons of functions instead of lexicons of strings. An entry in a lexicon from such a system should</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="666f233dad00e2e027af2bcddbc736103b174459" translate="yes" xml:space="preserve">
          <source>So, what's the big problem with that? It looks right, doesn't it? After all, I just told you that you need an array of references, so by golly, you've made me one!</source>
          <target state="translated">그렇다면 큰 문제는 무엇입니까? 맞아 보이죠? 결국, 나는 단지 당신에게 일련의 참조가 필요하다고 말 했으므로, 당신은 나에게 하나를 만들었습니다!</target>
        </trans-unit>
        <trans-unit id="c5f7a9040d43fdd63e7b31365a3279f444817139" translate="yes" xml:space="preserve">
          <source>So, you email your various translators (the boss decides that the languages du jour are Chinese, Arabic, Russian, and Italian, so you have one translator for each), asking for translations for &quot;I scanned %g directory.&quot; and &quot;I scanned %g directories.&quot;. When they reply, you'll put that in the lexicons for gettext to use when it localizes your software, so that when the user is running under the &quot;zh&quot; (Chinese) locale, gettext(&quot;I scanned %g directory.&quot;) will return the appropriate Chinese text, with a &quot;%g&quot; in there where printf can then interpolate $dir_scan.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14b8aecd3aaaa33e35d9724dfec4e61ddcb14189" translate="yes" xml:space="preserve">
          <source>So:</source>
          <target state="translated">So:</target>
        </trans-unit>
        <trans-unit id="93c6a1f183694628e37ced41591147bfc0da1908" translate="yes" xml:space="preserve">
          <source>Socket</source>
          <target state="translated">Socket</target>
        </trans-unit>
        <trans-unit id="1a669dbe9f824af2034872bc98a2b6823a4c09af" translate="yes" xml:space="preserve">
          <source>Socket option level constant for setsockopt() and getsockopt().</source>
          <target state="translated">setsockopt () 및 getsockopt ()에 대한 소켓 옵션 레벨 상수.</target>
        </trans-unit>
        <trans-unit id="e89a311c363b4ef4dc4be93eaeb6560498486275" translate="yes" xml:space="preserve">
          <source>Socket option name constants for IPv4 socket options at the &lt;code&gt;IPPROTO_IP&lt;/code&gt; level.</source>
          <target state="translated">&lt;code&gt;IPPROTO_IP&lt;/code&gt; 레벨 의 IPv4 소켓 옵션에 대한 소켓 옵션 이름 상수 .</target>
        </trans-unit>
        <trans-unit id="d741b5bebfd867658e744ca3a901afeae953cecf" translate="yes" xml:space="preserve">
          <source>Socket option name constants for IPv6 socket options at the &lt;code&gt;IPPROTO_IPV6&lt;/code&gt; level.</source>
          <target state="translated">&lt;code&gt;IPPROTO_IPV6&lt;/code&gt; 레벨 의 IPv6 소켓 옵션에 대한 소켓 옵션 이름 상수 .</target>
        </trans-unit>
        <trans-unit id="1bea3c52b1b205afb6610aaf669b9a46fdff261d" translate="yes" xml:space="preserve">
          <source>Socket option name constants for TCP socket options at the &lt;code&gt;IPPROTO_TCP&lt;/code&gt; level.</source>
          <target state="translated">&lt;code&gt;IPPROTO_TCP&lt;/code&gt; 레벨 의 TCP 소켓 옵션에 대한 소켓 옵션 이름 상수 .</target>
        </trans-unit>
        <trans-unit id="8943cecdeb64eeb6c75caac188d81a6e580de3c7" translate="yes" xml:space="preserve">
          <source>Socket option name constants for setsockopt() and getsockopt() at the &lt;code&gt;SOL_SOCKET&lt;/code&gt; level.</source>
          <target state="translated">&lt;code&gt;SOL_SOCKET&lt;/code&gt; 레벨의 setsockopt () 및 getsockopt ()에 대한 소켓 옵션 이름 상수 .</target>
        </trans-unit>
        <trans-unit id="8a16f3d4e350888989be5c310a53b83649d06948" translate="yes" xml:space="preserve">
          <source>Socket option value constants for &lt;code&gt;IP_TOS&lt;/code&gt; socket option.</source>
          <target state="translated">&lt;code&gt;IP_TOS&lt;/code&gt; 소켓 옵션의 소켓 옵션 값 상수</target>
        </trans-unit>
        <trans-unit id="fa50a464d89f205a80a64569fe1c6e97815468d2" translate="yes" xml:space="preserve">
          <source>Socket option value contants for &lt;code&gt;IP_MTU_DISCOVER&lt;/code&gt; socket option.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="734337896e45cc2ebeff48479a66b46bdd05ddb4" translate="yes" xml:space="preserve">
          <source>Socket type constants to use as the second argument to socket(), or the value of the &lt;code&gt;SO_TYPE&lt;/code&gt; socket option.</source>
          <target state="translated">socket ()의 두 번째 인수 또는 &lt;code&gt;SO_TYPE&lt;/code&gt; 소켓 옵션 의 값으로 사용할 소켓 유형 상수 .</target>
        </trans-unit>
        <trans-unit id="5bedda872ecdb70c2a2d140ada477f5b294eb6f0" translate="yes" xml:space="preserve">
          <source>Socket.</source>
          <target state="translated">Socket.</target>
        </trans-unit>
        <trans-unit id="ebe92a08483968e414740930bf0a0a08483ad931" translate="yes" xml:space="preserve">
          <source>Socket.a</source>
          <target state="translated">Socket.a</target>
        </trans-unit>
        <trans-unit id="848572346180cfeef643ccd7fddcc1762d26f13a" translate="yes" xml:space="preserve">
          <source>Sockets: Client/Server Communication</source>
          <target state="translated">소켓 : 클라이언트 / 서버 통신</target>
        </trans-unit>
        <trans-unit id="7ec10a4e74fb45054402ed905e46c34443ecf08d" translate="yes" xml:space="preserve">
          <source>Sockopts =&amp;gt; ARRAY</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96898c7bdde72d33b35d72cb9458ecfe538b1436" translate="yes" xml:space="preserve">
          <source>Software distributions released to the CPAN include a</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad9951caf8addf9e39a4e5a9ec448dfc26c21d1a" translate="yes" xml:space="preserve">
          <source>Solaris (x86, SPARC)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bbfadcc007c702d16ecd0e6f6d3baeefff3d72aa" translate="yes" xml:space="preserve">
          <source>Solaris 10 documentation on syslog, &lt;a href=&quot;http://docs.sun.com/app/docs/doc/816-5168/syslog-3c?a=view&quot;&gt;http://docs.sun.com/app/docs/doc/816-5168/syslog-3c?a=view&lt;/a&gt;</source>
          <target state="translated">syslog에 대한 Solaris 10 설명서, &lt;a href=&quot;http://docs.sun.com/app/docs/doc/816-5168/syslog-3c?a=view&quot;&gt;http://docs.sun.com/app/docs/doc/816-5168/syslog-3c?a=view&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6c7dc4f9a32286dc36b6fd2393ea8eff49fa670d" translate="yes" xml:space="preserve">
          <source>Solaris 11 documentation on syslog, &lt;a href=&quot;https://docs.oracle.com/cd/E53394_01/html/E54766/syslog-3c.html&quot;&gt;https://docs.oracle.com/cd/E53394_01/html/E54766/syslog-3c.html&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98fa552d1b28be69cf1da96419b8a90307162871" translate="yes" xml:space="preserve">
          <source>Solaris 7 and above will run in either 32 bit or 64 bit mode on SPARC CPUs, via a reboot. You can build 64 bit apps whilst running 32 bit mode and vice-versa. 32 bit apps will run under Solaris running in either 32 or 64 bit mode. 64 bit apps require Solaris to be running 64 bit mode.</source>
          <target state="translated">Solaris 7 이상은 재부팅을 통해 SPARC CPU에서 32 비트 또는 64 비트 모드로 실행됩니다. 32 비트 모드를 실행하거나 그 반대로 64 비트 앱을 빌드 할 수 있습니다. 32 비트 응용 프로그램은 32 비트 또는 64 비트 모드로 실행되는 Solaris에서 실행됩니다. 64 비트 응용 프로그램에서는 Solaris에서 64 비트 모드를 실행해야합니다.</target>
        </trans-unit>
        <trans-unit id="bd381ce5f7739cf9ac8dad77ffda2188f3978def" translate="yes" xml:space="preserve">
          <source>Solaris Documentation</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed34c43c64cf4558fcdec9f488cfa58f0a1b6fe3" translate="yes" xml:space="preserve">
          <source>Solaris FAQ</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ef2766b707c501497b46c746afec2754f6fc860" translate="yes" xml:space="preserve">
          <source>Solaris Version Numbers.</source>
          <target state="translated">Solaris 버전 번호.</target>
        </trans-unit>
        <trans-unit id="cc61dfb91810e5a0313350199a1b65c0af136cfa" translate="yes" xml:space="preserve">
          <source>Solaris global loading added by Nick Ing-Simmons with design/coding assistance from Tim Bunce, January 1996.</source>
          <target state="translated">1996 년 1 월 Tim Bunce의 설계 / 코딩 지원으로 Nick Ing-Simmons에 의해 Solaris 전역로드가 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="708154fc528413c51483abd6933e68d503e36bdc" translate="yes" xml:space="preserve">
          <source>Solaris may include two versions of perl, e.g. Solaris 9 includes both 5.005_03 and 5.6.1. This is to provide stability across Solaris releases, in cases where a later perl version has incompatibilities with the version included in the preceding Solaris release. The default perl version will always be the most recent, and in general the old version will only be retained for one Solaris release. Note also that the default perl will NOT be configured to search for modules in the older version, again due to compatibility/stability concerns. As a consequence if you upgrade Solaris, you will have to rebuild/reinstall any additional CPAN modules that you installed for the previous Solaris version. See the CPAN manpage under 'autobundle' for a quick way of doing this.</source>
          <target state="translated">Solaris에는 두 가지 버전의 perl이 포함될 수 있습니다. 예를 들어 Solaris 9에는 5.005_03과 5.6.1이 모두 포함됩니다. 이는 이후의 perl 버전이 이전 Solaris 릴리스에 포함 된 버전과 호환되지 않는 경우 Solaris 릴리스간에 안정성을 제공하기위한 것입니다. 기본 perl 버전은 항상 최신 버전이며 일반적으로 이전 버전은 하나의 Solaris 릴리스에 대해서만 유지됩니다. 호환성 / 안정성 문제로 인해 기본 펄은 이전 버전의 모듈을 검색하도록 구성되지 않습니다. 결과적으로 Solaris를 업그레이드하는 경우 이전 Solaris 버전 용으로 설치 한 추가 CPAN 모듈을 다시 빌드 / 다시 설치해야합니다. 이를 수행하는 빠른 방법은 'autobundle'아래 CPAN 맨 페이지를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="4bfa1cd2c976e4c546cb366d1dac1622384583a6" translate="yes" xml:space="preserve">
          <source>Solaris provides some BSD-compatibility functions in /usr/ucblib/libucb.a. Perl will not build and run correctly if linked against -lucb since it contains routines that are incompatible with the standard Solaris libc. Normally this is not a problem since the solaris hints file prevents Configure from even looking in /usr/ucblib for libraries, and also explicitly omits -lucb.</source>
          <target state="translated">Solaris는 /usr/ucblib/libucb.a에 일부 BSD 호환 기능을 제공합니다. -lucb에 링크 된 경우 표준 Solaris libc와 호환되지 않는 루틴이 포함되어 있으므로 Perl은 올바르게 빌드 및 실행되지 않습니다. solaris hints 파일로 인해 Configure가 라이브러리의 / usr / ucblib를 찾지 못하고 -lucb도 명시 적으로 생략하기 때문에 일반적으로 이것은 문제가되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d0c3f51965773ced91efb778a3671a3477592fd4" translate="yes" xml:space="preserve">
          <source>Solaris ships with a range of Solaris-specific modules. If you choose to install your own version of perl you will find the source of many of these modules is available on CPAN under the Sun::Solaris:: namespace.</source>
          <target state="translated">Solaris는 다양한 Solaris 특정 모듈과 함께 제공됩니다. 고유 한 버전의 perl을 설치하도록 선택하면 CPAN에서 Sun :: Solaris :: 네임 스페이스의 여러 모듈 소스를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b4f91bdb0e1b0e40fff4debcd0fea22f1999f491" translate="yes" xml:space="preserve">
          <source>Solution</source>
          <target state="translated">Solution</target>
        </trans-unit>
        <trans-unit id="05b004a92e5eda3ec6e47516b582fc25b61b35b9" translate="yes" xml:space="preserve">
          <source>Solutions</source>
          <target state="translated">Solutions</target>
        </trans-unit>
        <trans-unit id="9cdf28d779226e286e9b065703a4425b88267886" translate="yes" xml:space="preserve">
          <source>Solving the problem</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00b2aad45d07b70e1b7eefea74316913901b6e42" translate="yes" xml:space="preserve">
          <source>Some</source>
          <target state="translated">Some</target>
        </trans-unit>
        <trans-unit id="5f679f54e4d0cf2197954f773a392f8d165d2696" translate="yes" xml:space="preserve">
          <source>Some (minor) parts copyright 2009 Adam Kennedy.</source>
          <target state="translated">일부 (사소한) 부품은 2009 Adam Kennedy에게 저작권이 있습니다.</target>
        </trans-unit>
        <trans-unit id="3a644bfc8b4acacc1b56f8b5a49f0fbd16c47364" translate="yes" xml:space="preserve">
          <source>Some *nix programs use fork() a lot; with the mostly useful flavors of perl for OS/2 (there are several built simultaneously) this is supported; but some flavors do not support this (e.g., when Perl is called from inside REXX). Using fork() after</source>
          <target state="translated">일부 * nix 프로그램은 fork ()를 많이 사용합니다. OS / 2에 가장 유용한 펄의 풍미로 (여러 개가 동시에 구축되어 있음) 이것이 지원됩니다. 그러나 일부 맛은이를 지원하지 않습니다 (예 : Perl이 REXX 내부에서 호출 될 때). 다음에 fork () 사용</target>
        </trans-unit>
        <trans-unit id="6a808c47f9491da438c1507c81067e0d0ad1d610" translate="yes" xml:space="preserve">
          <source>Some / became \ in pdksh.</source>
          <target state="translated">pdksh에서 일부가 \가되었습니다.</target>
        </trans-unit>
        <trans-unit id="2ced2108dbb21d847b539e5bf8d6eae4e6952b9e" translate="yes" xml:space="preserve">
          <source>Some &lt;code&gt;/&lt;/code&gt; became &lt;code&gt;\&lt;/code&gt; in pdksh.</source>
          <target state="translated">일부 &lt;code&gt;/&lt;/code&gt; 가 되었다 &lt;code&gt;\&lt;/code&gt; pdksh 같은 년.</target>
        </trans-unit>
        <trans-unit id="aee5f872bb2cc36da4c3ed1ff4e14aea96b6faa3" translate="yes" xml:space="preserve">
          <source>Some &lt;code&gt;Win*&lt;/code&gt; entry points also overload a &quot;meaningful&quot; return value with the error indicator; having a 0 return value indicates an error. Yet some other &lt;code&gt;Win*&lt;/code&gt; entry points overload things even more, and 0 return value may mean a successful call returning a valid value 0, as well as an error condition; in the case of a 0 return value one should call WinGetLastError() API to distinguish a successful call from a failing one.</source>
          <target state="translated">일부 &lt;code&gt;Win*&lt;/code&gt; 진입 점에는 오류 표시기와 함께 &quot;의미있는&quot;반환 값이 오버로드됩니다. 리턴 값이 0이면 오류를 나타냅니다. 그러나 다른 &lt;code&gt;Win*&lt;/code&gt; 진입 점은 더 많은 것들을 오버로드하며, 반환 값이 0이면 오류 조건뿐만 아니라 유효한 값 0을 반환하는 성공적인 호출을 의미 할 수 있습니다. 리턴 값이 0 인 경우 성공적인 호출과 실패한 호출을 구별하기 위해 WinGetLastError () API를 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="7d77130c6b6fd9352c737bed1bb1dcb935bd9ca9" translate="yes" xml:space="preserve">
          <source>Some DLLs are only present in some versions of OS/2, or in some configurations of OS/2. Some exported entry points are present only in DLLs shipped with some versions of OS/2. If these DLLs and entry points were linked directly for a Perl executable/DLL or from a Perl extensions, this binary would work only with the specified versions/setups. Even if these entry points were not needed, the</source>
          <target state="translated">일부 DLL은 일부 OS / 2 버전 또는 일부 OS / 2 구성에만 있습니다. 내 보낸 일부 진입 점은 일부 OS / 2 버전과 함께 제공된 DLL에만 있습니다. 이러한 DLL과 진입 점이 Perl 실행 파일 / DLL 또는 Perl 확장을 위해 직접 연결된 경우이 바이너리는 지정된 버전 / 설정에서만 작동합니다. 이러한 진입 점이 필요하지 않더라도</target>
        </trans-unit>
        <trans-unit id="8e4ba3d45352907bcc89de2a6a57c8be8f5ee286" translate="yes" xml:space="preserve">
          <source>Some Filters Clobber the &lt;code&gt;DATA&lt;/code&gt; Handle</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14adc2a370c74e9f0b7a6eb136961fb44f4e9d5e" translate="yes" xml:space="preserve">
          <source>Some IBM EBCDIC character sets may be known by character code set identification numbers (CCSID numbers) or code page numbers.</source>
          <target state="translated">일부 IBM EBCDIC 문자 세트는 문자 코드 세트 식별 번호 (CCSID 번호) 또는 코드 페이지 번호로 알려질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="20970d609d169c267b614af470114dc6b026c453" translate="yes" xml:space="preserve">
          <source>Some Irix cc versions, e.g. 7.3.1.1m (try cc -version) have been known to have issues (coredumps) when compiling perl.c. If you've used -OPT:fast_io=ON and this happens, try removing it. If that fails, or you didn't use that, then try adjusting other optimization options (-LNO, -INLINE, -O3 to -O2, etcetera). The compiler bug has been reported to SGI. (Allen Smith &amp;lt;easmith@beatrice.rutgers.edu&amp;gt;)</source>
          <target state="translated">7.3.1.1m (try cc -version)과 같은 일부 Irix cc 버전은 perl.c를 컴파일 할 때 문제 (코어 덤프)가있는 것으로 알려져 있습니다. -OPT : fast_io = ON을 사용한 경우이 문제를 제거하십시오. 실패하거나 사용하지 않은 경우 다른 최적화 옵션 (-LNO, -INLINE, -O3에서 -O2 등)을 조정하십시오. 컴파일러 버그가 SGI에보고되었습니다. (앨런 스미스 &amp;lt;easmith@beatrice.rutgers.edu&amp;gt;)</target>
        </trans-unit>
        <trans-unit id="e270800f9e2c9ef58198c6c9f8463f63bac86a3b" translate="yes" xml:space="preserve">
          <source>Some Linux platforms have a maximum stack size. Setting too large of a stack size will cause thread creation to fail.</source>
          <target state="translated">일부 Linux 플랫폼은 최대 스택 크기를 갖습니다. 스택 크기를 너무 크게 설정하면 스레드 생성이 실패합니다.</target>
        </trans-unit>
        <trans-unit id="bad9f67e1f3cb77c4fe9db59234d0c5d6bb841b2" translate="yes" xml:space="preserve">
          <source>Some OSes do not need these in which case leave it blank.</source>
          <target state="translated">일부 OS는이를 필요로하지 않으며,이 경우 비워 두십시오.</target>
        </trans-unit>
        <trans-unit id="69e7c8fdafb5d76df4c8f736ecf437657f4dc150" translate="yes" xml:space="preserve">
          <source>Some Pod formatters output to formats that implement non-breaking spaces as an individual character (which I'll call &quot;NBSP&quot;), and others output to formats that implement non-breaking spaces just as spaces wrapped in a &quot;don't break this across lines&quot; code. Note that at the level of Pod, both sorts of codes can occur: Pod can contain a NBSP character (whether as a literal, or as a &quot;E&amp;lt;160&amp;gt;&quot; or &quot;E&amp;lt;nbsp&amp;gt;&quot; code); and Pod can contain &quot;S&amp;lt;foo I&amp;lt;bar&amp;gt; baz&amp;gt;&quot; codes, where &quot;mere spaces&quot; (character 32) in such codes are taken to represent non-breaking spaces. Pod parsers should consider supporting the optional parsing of &quot;S&amp;lt;foo I&amp;lt;bar&amp;gt; baz&amp;gt;&quot; as if it were &quot;foo</source>
          <target state="translated">일부 포드 포맷터는 줄 바꿈하지 않는 공백을 개별 문자 ( &quot;NBSP&quot;라고 함)로 구현하는 형식으로 출력하고, 다른 포드 포맷터는 줄 바꿈되지 않은 공백을 &quot;줄 바꿈하지 마십시오. 여러 줄에 걸쳐 &quot;코드. 포드 수준에서 두 종류의 코드가 모두 발생할 수 있습니다. 포드에는 NBSP 문자 (리터럴이든 &quot;E &amp;lt;160&amp;gt;&quot;또는 &quot;E &amp;lt;nbsp&amp;gt;&quot;코드)가 포함될 수 있습니다. 포드는 &quot;S &amp;lt;foo I &amp;lt;bar&amp;gt; baz&amp;gt;&quot;코드를 포함 할 수 있으며, 이러한 코드에서 &quot;단지 공백&quot;(문자 32)은 비 분리 공백을 나타 내기 위해 사용됩니다. 포드 파서는 &quot;S &amp;lt;foo I &amp;lt;bar&amp;gt; baz&amp;gt;&quot;의 선택적 파싱을 &quot;foo&quot;처럼 지원하는 것을 고려해야합니다.</target>
        </trans-unit>
        <trans-unit id="f04294d93d5e63f6eed93e1148616595ef1487e2" translate="yes" xml:space="preserve">
          <source>Some Sys-V based systems, notably Solaris 2.X, redefined some of the standard socket constants. Since these were constant across all architectures, they were often hardwired into perl code. The proper way to deal with this is to &quot;use Socket&quot; to get the correct values.</source>
          <target state="translated">일부 Sys-V 기반 시스템, 특히 Solaris 2.X는 일부 표준 소켓 상수를 재정의했습니다. 이것들은 모든 아키텍처에서 일정하기 때문에 종종 펄 코드로 고정되어 있습니다. 이를 처리하는 올바른 방법은 올바른 값을 얻기 위해 &quot;소켓 사용&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="a5a0c5f6bf86975f2c301ba492652230f705bf5a" translate="yes" xml:space="preserve">
          <source>Some Unicode properties have a restricted set of legal values. For example, all binary properties are restricted to just &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt; ; and there are only a few dozen possible General Categories.</source>
          <target state="translated">일부 유니 코드 속성에는 제한된 법적 값 집합이 있습니다. 예를 들어 모든 이진 속성은 &lt;code&gt;true&lt;/code&gt; 또는 &lt;code&gt;false&lt;/code&gt; 로 제한됩니다 . 수십 개의 가능한 일반 범주 만 있습니다.</target>
        </trans-unit>
        <trans-unit id="9e6eb6762559c642717c0b35b0e9407b4ea3c431" translate="yes" xml:space="preserve">
          <source>Some Unicode properties have a restricted set of legal values. For example, all binary properties are restricted to just &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt; ; and there are only a few dozen possible General Categories. Use &lt;code&gt;prop_values&lt;/code&gt; to find out if a given property is one such, and if so, to get a list of the values:</source>
          <target state="translated">일부 유니 코드 속성에는 제한된 법적 값 집합이 있습니다. 예를 들어 모든 이진 속성은 &lt;code&gt;true&lt;/code&gt; 또는 &lt;code&gt;false&lt;/code&gt; 로 제한됩니다 . 수십 개의 가능한 일반 범주 만 있습니다. &lt;code&gt;prop_values&lt;/code&gt; 를 사용 하여 주어진 속성이 그러한 속성인지 확인하고, 그렇다면 속성 목록을 얻으려면 :</target>
        </trans-unit>
        <trans-unit id="5c1e962daca68404a4b5aeb9ebaf19ea3e632a80" translate="yes" xml:space="preserve">
          <source>Some Unicode properties have a restricted set of legal values. For example, all binary properties are restricted to just &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;; and there are only a few dozen possible General Categories.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f826abadcb88c4b8481c939d03177c526f688d85" translate="yes" xml:space="preserve">
          <source>Some Unicode properties have a restricted set of legal values. For example, all binary properties are restricted to just &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;; and there are only a few dozen possible General Categories. Use &lt;code&gt;prop_values&lt;/code&gt; to find out if a given property is one such, and if so, to get a list of the values:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da934a0c72e4b177f3b0df8a238ca7ff76fadba5" translate="yes" xml:space="preserve">
          <source>Some Unixes, especially more recent ones, are free of this inherent security bug. On such systems, when the kernel passes the name of the set-id script to open to the interpreter, rather than using a pathname subject to meddling, it instead passes</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b16213d61f5d76543cce7f4b52c976b8f28e064a" translate="yes" xml:space="preserve">
          <source>Some approximate operating system names and their &lt;a href=&quot;perlvar#%24%5EO&quot;&gt;&lt;code&gt;$^O&lt;/code&gt;&lt;/a&gt; values in the &quot;OTHER&quot; category include:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="abd2e23e9cee0c22d7103f4f9a78d73d761dd3aa" translate="yes" xml:space="preserve">
          <source>Some approximate operating system names and their &lt;code&gt;$^O&lt;/code&gt; values in the &quot;OTHER&quot; category include:</source>
          <target state="translated">&quot;OTHER&quot;범주의 대략적인 운영 체제 이름 및 &lt;code&gt;$^O&lt;/code&gt; 값은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="fc63731ea34f43c4af1c4ec405f7ea69ef1d9704" translate="yes" xml:space="preserve">
          <source>Some authors have strange characters in their names.</source>
          <target state="translated">일부 저자는 이름에 이상한 문자가 있습니다.</target>
        </trans-unit>
        <trans-unit id="6877eb2746dbad4bb0e9e27d968022bfea3412f0" translate="yes" xml:space="preserve">
          <source>Some background on thread implementations from the operating system viewpoint. There are three basic categories of threads: user-mode threads, kernel threads, and multiprocessor kernel threads.</source>
          <target state="translated">운영 체제 관점에서 스레드 구현에 대한 배경 지식. 스레드에는 기본적으로 사용자 모드 스레드, 커널 스레드 및 다중 프로세서 커널 스레드의 세 가지 범주가 있습니다.</target>
        </trans-unit>
        <trans-unit id="fc0d6a626635ac5ae4291cc3487e50efd6ae5a14" translate="yes" xml:space="preserve">
          <source>Some bits may be relevant at compile-time only, some at run-time only. This is a new mechanism and the details may change. See also &lt;a href=&quot;perldebguts&quot;&gt;perldebguts&lt;/a&gt;.</source>
          <target state="translated">일부 비트는 컴파일 타임에만 관련되고 일부 비트는 런타임에만 관련 될 수 있습니다. 이것은 새로운 메커니즘이며 세부 사항이 변경 될 수 있습니다. &lt;a href=&quot;perldebguts&quot;&gt;perldebguts&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="fd8e9b1766f0e1e6eaaded7abc870a37e4571ff0" translate="yes" xml:space="preserve">
          <source>Some brief examples:</source>
          <target state="translated">몇 가지 간단한 예 :</target>
        </trans-unit>
        <trans-unit id="61327002f5b3861abd79c62e144ccb79536f4f22" translate="yes" xml:space="preserve">
          <source>Some builtins (e.g. &lt;code&gt;&lt;a href=&quot;functions/chdir&quot;&gt;chdir&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/truncate&quot;&gt;truncate&lt;/a&gt;&lt;/code&gt;) has a call signature that cannot completely be representated with a Perl prototype. This means that some valid Perl code will be invalid under autodie. As an example:</source>
          <target state="translated">일부 내장 (예 : &lt;code&gt;&lt;a href=&quot;functions/chdir&quot;&gt;chdir&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;functions/truncate&quot;&gt;truncate&lt;/a&gt;&lt;/code&gt; )에는 Perl 프로토 타입으로 완전히 표현할 수없는 호출 서명이 있습니다. 이는 일부 유효한 Perl 코드가 autodie에서 유효하지 않음을 의미합니다. 예로서:</target>
        </trans-unit>
        <trans-unit id="7e79ef5917eeda28b646e901197de5a6a38623ed" translate="yes" xml:space="preserve">
          <source>Some builtins (e.g. &lt;code&gt;chdir&lt;/code&gt; or &lt;code&gt;truncate&lt;/code&gt;) has a call signature that cannot completely be representated with a Perl prototype. This means that some valid Perl code will be invalid under autodie. As an example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21eaccc7842c81c4d4f8ac981ea6b511271286ba" translate="yes" xml:space="preserve">
          <source>Some calls simply aren't available, real or emulated, on every platform.</source>
          <target state="translated">일부 플랫폼에서는 모든 통화를 실제 통화 또는 에뮬레이션으로 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="f873ff9032d8b5cf7f774b66c05c986170a4cd42" translate="yes" xml:space="preserve">
          <source>Some characters have multiple names (synonyms).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7144ad6e6fa073f902e93d5905df49ebac937d92" translate="yes" xml:space="preserve">
          <source>Some code points also have abbreviated names, such as &quot;LF&quot; or &quot;NL&quot;. &lt;code&gt;viacode&lt;/code&gt; never returns these.</source>
          <target state="translated">일부 코드 포인트에는 &quot;LF&quot;또는 &quot;NL&quot;과 같은 약어 이름이 있습니다. &lt;code&gt;viacode&lt;/code&gt; 는 이것을 반환하지 않습니다</target>
        </trans-unit>
        <trans-unit id="73ac6d49c092929d2ed08d514c7b1beb64ede02a" translate="yes" xml:space="preserve">
          <source>Some code taken from &lt;a href=&quot;../more&quot;&gt;Test::More&lt;/a&gt; and &lt;a href=&quot;http://search.cpan.org/perldoc/Test::Catch&quot;&gt;Test::Catch&lt;/a&gt;, written by Michael G Schwern &amp;lt;schwern@pobox.com&amp;gt;. Hence, those parts Copyright Micheal G Schwern 2001. Used and distributed with permission.</source>
          <target state="translated">Michael G Schwern &amp;lt;schwern@pobox.com&amp;gt;이 작성한 &lt;a href=&quot;../more&quot;&gt;Test :: More&lt;/a&gt; 및 &lt;a href=&quot;http://search.cpan.org/perldoc/Test::Catch&quot;&gt;Test :: Catch&lt;/a&gt; 에서 가져온 일부 코드 입니다. 따라서 해당 부분의 저작권은 Micheal G Schwern 2001에 있습니다.</target>
        </trans-unit>
        <trans-unit id="5561c8c582f640440613f3fca93ddc04efa36da2" translate="yes" xml:space="preserve">
          <source>Some code taken from &lt;a href=&quot;Test::More&quot;&gt;Test::More&lt;/a&gt; and &lt;a href=&quot;Test::Catch&quot;&gt;Test::Catch&lt;/a&gt;, written by Michael G Schwern &amp;lt;schwern@pobox.com&amp;gt;. Hence, those parts Copyright Micheal G Schwern 2001. Used and distributed with permission.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82e5cd1d1e32143aa0622aa3ff5ac884d8c3a28f" translate="yes" xml:space="preserve">
          <source>Some comparison operators, as their associativity,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1339e50839100723841e8e48747e9f9a1f5bed3" translate="yes" xml:space="preserve">
          <source>Some constants and functions are exported by default by this module; but for backward-compatibility any recently-added symbols are not exported by default and must be requested explicitly. When an import list is provided to the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; Socket&lt;/code&gt; line, the default exports are not automatically imported. It is therefore best practice to always to explicitly list all the symbols required.</source>
          <target state="translated">일부 상수 및 함수는이 모듈에서 기본적으로 내보내집니다. 그러나 이전 버전과의 호환성을 위해 최근에 추가 한 모든 심볼은 기본적으로 내보내지지 않으므로 명시 적으로 요청해야합니다. &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; Socket&lt;/code&gt; &lt;a href=&quot;functions/use&quot;&gt;사용&lt;/a&gt; 행에 가져 오기 목록이 제공 되면 기본 내보내기는 자동으로 가져 오지 않습니다. 따라서 필요한 모든 기호를 항상 명시 적으로 나열하는 것이 가장 좋습니다.</target>
        </trans-unit>
        <trans-unit id="54e9eafb99e932590ca2a179b6517831860be80f" translate="yes" xml:space="preserve">
          <source>Some constants and functions are exported by default by this module; but for backward-compatibility any recently-added symbols are not exported by default and must be requested explicitly. When an import list is provided to the &lt;code&gt;use Socket&lt;/code&gt; line, the default exports are not automatically imported. It is therefore best practice to always to explicitly list all the symbols required.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="078dd465c32a4795a8e3e38bd49c7d92d32009a8" translate="yes" xml:space="preserve">
          <source>Some constants don't print correctly either with or without &lt;b&gt;-d&lt;/b&gt;. For instance, neither B::Deparse nor Data::Dumper know how to print dual-valued scalars correctly, as in:</source>
          <target state="translated">일부 상수는 &lt;b&gt;-d&lt;/b&gt; 를 사용하거나 사용하지 않고 올바르게 인쇄되지 않습니다 . 예를 들어 B :: Deparse와 Data :: Dumper는 다음과 같이 이중 값 스칼라를 올바르게 인쇄하는 방법을 모릅니다.</target>
        </trans-unit>
        <trans-unit id="c475f4b24c437233a2b88333a558801f98c19297" translate="yes" xml:space="preserve">
          <source>Some contexts allow 2 or even 1 digit, but any usage without exactly three digits, the first being a zero, may give unintended results. (For example, in a regular expression it may be confused with a backreference; see &lt;a href=&quot;perlrebackslash#Octal-escapes&quot;&gt;&quot;Octal escapes&quot; in perlrebackslash&lt;/a&gt;.) Starting in Perl 5.14, you may use &lt;code&gt;\o{}&lt;/code&gt; instead, which avoids all these problems. Otherwise, it is best to use this construct only for ordinals &lt;code&gt;\077&lt;/code&gt; and below, remembering to pad to the left with zeros to make three digits. For larger ordinals, either use &lt;code&gt;\o{}&lt;/code&gt;, or convert to something else, such as to hex and use &lt;code&gt;\N{U+}&lt;/code&gt; (which is portable between platforms with different character sets) or &lt;code&gt;\x{}&lt;/code&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e689eba4cf9a38a4acdff5d45d4adaf1f020711" translate="yes" xml:space="preserve">
          <source>Some contexts allow 2 or even 1 digit, but any usage without exactly three digits, the first being a zero, may give unintended results. (For example, in a regular expression it may be confused with a backreference; see &lt;a href=&quot;perlrebackslash#Octal-escapes&quot;&gt;Octal escapes in perlrebackslash&lt;/a&gt;.) Starting in Perl 5.14, you may use &lt;code&gt;\o{}&lt;/code&gt; instead, which avoids all these problems. Otherwise, it is best to use this construct only for ordinals &lt;code&gt;\077&lt;/code&gt; and below, remembering to pad to the left with zeros to make three digits. For larger ordinals, either use &lt;code&gt;\o{}&lt;/code&gt; , or convert to something else, such as to hex and use &lt;code&gt;\N{U+}&lt;/code&gt; (which is portable between platforms with different character sets) or &lt;code&gt;\x{}&lt;/code&gt; instead.</source>
          <target state="translated">일부 컨텍스트는 2 자리 또는 1 자리를 허용하지만 정확히 3 자리가없는 경우 (처음은 0 임) 의도하지 않은 결과를 초래할 수 있습니다. (예를 들어, 정규 표현식에서는 역 참조와 혼동 될 수 있습니다 . &lt;a href=&quot;perlrebackslash#Octal-escapes&quot;&gt;perlrebackslash에서 8 진 이스케이프를&lt;/a&gt; 참조하십시오 .) Perl 5.14부터는 &lt;code&gt;\o{}&lt;/code&gt; 대신 사용 하면 이러한 모든 문제를 피할 수 있습니다. 그렇지 않으면,이 구성은 서수 &lt;code&gt;\077&lt;/code&gt; 이하에 대해서만 사용하는 것이 가장 좋습니다 . 세 자리수를 만들기 위해 왼쪽으로 0을 채우는 것을 기억하십시오. 더 큰 서수의 경우 &lt;code&gt;\o{}&lt;/code&gt; 을 사용하거나 16 진수와 같은 다른 것으로 변환하고 &lt;code&gt;\N{U+}&lt;/code&gt; (다른 문자 집합을 가진 플랫폼간에 이식 가능) 또는 &lt;code&gt;\x{}&lt;/code&gt; 대신 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="17469d7643e0741d1ada43cbcada6ad7b4213174" translate="yes" xml:space="preserve">
          <source>Some cool command line examples to impress the Python crowd ;)</source>
          <target state="translated">파이썬 군중에게 감동을주는 멋진 명령 줄 예제;)</target>
        </trans-unit>
        <trans-unit id="4f597c06196db5dfae23debf5b526fce9cd25685" translate="yes" xml:space="preserve">
          <source>Some cool command line examples to impress the Python crowd ;) You might want to compare them to the results under -Mbignum or -Mbigrat:</source>
          <target state="translated">파이썬 군중을 감동시키는 멋진 명령 행 예제;) -Mbignum 또는 -Mbigrat의 결과와 비교할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c6746b978d2a5bd75b46a34b757950222f7e2d87" translate="yes" xml:space="preserve">
          <source>Some database drivers for DBI can also automatically encode and decode, but that is sometimes limited to the UTF-8 encoding.</source>
          <target state="translated">DBI 용 일부 데이터베이스 드라이버는 자동으로 인코딩 및 디코딩 할 수 있지만 때때로 UTF-8 인코딩으로 제한됩니다.</target>
        </trans-unit>
        <trans-unit id="20c968c59a29a0ad6a0ddbad176bb82749120644" translate="yes" xml:space="preserve">
          <source>Some devices will be expecting a &quot;\r&quot; at the end of each line rather than a &quot;\n&quot;. In some ports of perl, &quot;\r&quot; and &quot;\n&quot; are different from their usual (Unix) ASCII values of &quot;\015&quot; and &quot;\012&quot;. You may have to give the numeric values you want directly, using octal (&quot;\015&quot;), hex (&quot;0x0D&quot;), or as a control-character specification (&quot;\cM&quot;).</source>
          <target state="translated">일부 장치는 각 줄 끝에 &quot;\ n&quot;이 아닌 &quot;\ r&quot;을 기대합니다. perl의 일부 포트에서 &quot;\ r&quot;및 &quot;\ n&quot;은 일반적인 &quot;Unix) ASCII 값&quot;\ 015 &quot;및&quot;\ 012 &quot;와 다릅니다. 8 진수 ( &quot;\ 015&quot;), 16 진수 ( &quot;0x0D&quot;) 또는 제어 문자 사양 ( &quot;\ cM&quot;)을 사용하여 원하는 숫자 값을 직접 제공해야 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="29952c75d7a51b190a8cddfeefebadadc1b42414" translate="yes" xml:space="preserve">
          <source>Some digits that &lt;code&gt;\d&lt;/code&gt; matches look like some of the [0-9] ones, but have different values. For example, BENGALI DIGIT FOUR (U+09EA) looks very much like an ASCII DIGIT EIGHT (U+0038), and LEPCHA DIGIT SIX (U+1C46) looks very much like an ASCII DIGIT FIVE (U+0035). An application that is expecting only the ASCII digits might be misled, or if the match is &lt;code&gt;\d+&lt;/code&gt;, the matched string might contain a mixture of digits from different writing systems that look like they signify a number different than they actually do. &lt;a href=&quot;Unicode::UCD#num%28%29&quot;&gt;&quot;num()&quot; in Unicode::UCD&lt;/a&gt; can be used to safely calculate the value, returning &lt;code&gt;undef&lt;/code&gt; if the input string contains such a mixture. Otherwise, for example, a displayed price might be deliberately different than it appears.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b15270299f74ddedc9cb2a27cec0a8d56d430a18" translate="yes" xml:space="preserve">
          <source>Some digits that &lt;code&gt;\d&lt;/code&gt; matches look like some of the [0-9] ones, but have different values. For example, BENGALI DIGIT FOUR (U+09EA) looks very much like an ASCII DIGIT EIGHT (U+0038). An application that is expecting only the ASCII digits might be misled, or if the match is &lt;code&gt;\d+&lt;/code&gt; , the matched string might contain a mixture of digits from different writing systems that look like they signify a number different than they actually do. &lt;a href=&quot;unicode/ucd#num()&quot;&gt;num() in Unicode::UCD&lt;/a&gt; can be used to safely calculate the value, returning &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; if the input string contains such a mixture.</source>
          <target state="translated">&lt;code&gt;\d&lt;/code&gt; 와 일치 하는 일부 숫자 는 [0-9] 숫자 중 일부와 비슷하지만 값이 다릅니다. 예를 들어 BENGALI DIGIT FOUR (U + 09EA)는 ASCII DIGIT EIGHT (U + 0038)와 매우 유사합니다. ASCII 숫자 만 예상되는 응용 프로그램이 잘못 표시되거나 일치하는 항목이 &lt;code&gt;\d+&lt;/code&gt; 인 경우 일치하는 문자열에는 실제와는 다른 숫자를 나타내는 것처럼 다른 쓰기 시스템의 숫자가 혼합되어있을 수 있습니다. &lt;a href=&quot;unicode/ucd#num()&quot;&gt;Unicode :: UCD의 num ()을&lt;/a&gt; 사용하여 값을 안전하게 계산 하여 입력 문자열에 이러한 혼합이 포함되어 있으면 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 를 반환 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="eb6208f023afd54f9f4acc30a7d493bf14dc6378" translate="yes" xml:space="preserve">
          <source>Some distributions may fail some tests, but you may want to install them anyway (as above, or via &lt;code&gt;force install&lt;/code&gt; command of &lt;code&gt;CPAN.pm&lt;/code&gt; shell-mode).</source>
          <target state="translated">일부 배포판은 일부 테스트에 실패 할 수 있지만 어쨌든 (위와 같이 또는 &lt;code&gt;CPAN.pm&lt;/code&gt; 쉘 모드 의 &lt;code&gt;force install&lt;/code&gt; 명령을 통해) 설치할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="673083d85e2bc8b38798cec75fcc0568d074003d" translate="yes" xml:space="preserve">
          <source>Some distributions may need to link to libraries or other third-party code and their build and installation sequences may be more complicated. Check any</source>
          <target state="translated">일부 배포판은 라이브러리 또는 다른 타사 코드에 연결해야 할 수 있으며 빌드 및 설치 순서가 더 복잡 할 수 있습니다. 확인</target>
        </trans-unit>
        <trans-unit id="1c42a00c69d1bae42ece6b69f30632a5649a6c28" translate="yes" xml:space="preserve">
          <source>Some documentation is not available as man pages, so if a cross-reference is not found by man, try it with &lt;a href=&quot;perldoc&quot;&gt;perldoc&lt;/a&gt;. Perldoc can also take you directly to documentation for functions (with the &lt;b&gt;-f&lt;/b&gt; switch). See &lt;code&gt;perldoc --help&lt;/code&gt; (or &lt;a href=&quot;perldoc&quot;&gt;&lt;code&gt;perldoc perldoc&lt;/code&gt;&lt;/a&gt; or &lt;code&gt;man perldoc&lt;/code&gt;) for other helpful options &lt;a href=&quot;perldoc&quot;&gt;perldoc&lt;/a&gt; has to offer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e14b5226c1b3194a20df87855367bd2962c1e595" translate="yes" xml:space="preserve">
          <source>Some documentation is not available as man pages, so if a cross-reference is not found by man, try it with &lt;a href=&quot;perldoc&quot;&gt;perldoc&lt;/a&gt;. Perldoc can also take you directly to documentation for functions (with the &lt;b&gt;-f&lt;/b&gt; switch). See &lt;code&gt;perldoc --help&lt;/code&gt; (or &lt;code&gt;perldoc perldoc&lt;/code&gt; or &lt;code&gt;man perldoc&lt;/code&gt; ) for other helpful options &lt;a href=&quot;perldoc&quot;&gt;perldoc&lt;/a&gt; has to offer.</source>
          <target state="translated">일부 문서는 매뉴얼 페이지로 제공되지 않으므로 man이 상호 참조를 찾을 수없는 경우 &lt;a href=&quot;perldoc&quot;&gt;perldoc로&lt;/a&gt; 시도하십시오 . Perldoc은 또한 &lt;b&gt;-f&lt;/b&gt; 스위치를 사용하여 기능에 대한 문서로 직접 이동할 수 있습니다 . &lt;a href=&quot;perldoc&quot;&gt;perldoc&lt;/a&gt; 이 제공하는 다른 유용한 옵션 은 &lt;code&gt;perldoc --help&lt;/code&gt; (또는 &lt;code&gt;perldoc perldoc&lt;/code&gt; 또는 &lt;code&gt;man perldoc&lt;/code&gt; )를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="24f338e775f9d8f25e87916116198ed5fdfd8fac" translate="yes" xml:space="preserve">
          <source>Some earlier versions of this module had docs with some confusing typos in the description of &lt;code&gt;skip(...)&lt;/code&gt; .</source>
          <target state="translated">이 모듈의 일부 이전 버전은 &lt;code&gt;skip(...)&lt;/code&gt; 설명에 혼란스러운 오타가있는 문서가 있습니다 .</target>
        </trans-unit>
        <trans-unit id="755fe62cf032f564de90de30771b7c019c165183" translate="yes" xml:space="preserve">
          <source>Some earlier versions of this module had docs with some confusing typos in the description of &lt;code&gt;skip(...)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d5fff71fc694b06c17e66dad87b134506e2302b" translate="yes" xml:space="preserve">
          <source>Some essentially obsolete locales that aren't supersets of ASCII, mainly those in ISO 646 or other 7-bit locales, such as ASMO 449, can also have problems, depending on what portions of the ASCII character set get changed by the locale and are also used by the program. The warning message lists the determinable conflicting characters.</source>
          <target state="translated">ASCII의 수퍼 셋이 아닌 일부 기본적으로 사용되지 않는 로케일, 주로 ISO 646 또는 ASMO 449와 같은 기타 7 비트 로케일의 로케일에 따라 ASCII 문자 세트의 일부가 로케일에 의해 변경되어 문제가있을 수 있습니다. 프로그램에서도 사용됩니다. 경고 메시지는 결정 가능한 충돌 문자를 나열합니다.</target>
        </trans-unit>
        <trans-unit id="e8b38cbb77fcb476bf8e2983ccfda5ed33f46a79" translate="yes" xml:space="preserve">
          <source>Some example section specifications follow.</source>
          <target state="translated">다음은 일부 예제 섹션 사양입니다.</target>
        </trans-unit>
        <trans-unit id="6e29ae8ec1bfc30435ce56e5aeb3c20b82d6940f" translate="yes" xml:space="preserve">
          <source>Some examples of lists include:</source>
          <target state="translated">목록의 일부 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ae84b84bf5612613743104cf4d1d3f624e770f5d" translate="yes" xml:space="preserve">
          <source>Some examples of syntactically invalid attribute lists (with annotation):</source>
          <target state="translated">구문 상 유효하지 않은 속성 목록의 몇 가지 예 (주석 포함) :</target>
        </trans-unit>
        <trans-unit id="9c0e82c6c1b276d5dbb162e62c1346aa697136e3" translate="yes" xml:space="preserve">
          <source>Some examples of syntactically valid attribute lists:</source>
          <target state="translated">구문 적으로 유효한 속성 목록의 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9ef77adb00cc27df250473773f43482c29f3a24d" translate="yes" xml:space="preserve">
          <source>Some examples of valid string input</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01706013cfdbcb0fc543d3c97784f3f4c235d630" translate="yes" xml:space="preserve">
          <source>Some examples:</source>
          <target state="translated">몇 가지 예 :</target>
        </trans-unit>
        <trans-unit id="75d23fa0c37e5a03812b09ef6b9c46fbb0fa3389" translate="yes" xml:space="preserve">
          <source>Some extensions provide filters on data entry/exit points, such as &lt;code&gt;DB_File::filter_store_key&lt;/code&gt; and family. Look out for such filters in the documentation of your extensions; they can make the transition to Unicode data much easier.</source>
          <target state="translated">일부 확장은 &lt;code&gt;DB_File::filter_store_key&lt;/code&gt; 및 제품군과 같은 데이터 시작 / 종료 지점에 대한 필터를 제공합니다 . 확장 문서에서 이러한 필터를 찾으십시오. 유니 코드 데이터로 훨씬 쉽게 전환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1ba2d8223f5d5832c6d62c8b546d87c608dd84fc" translate="yes" xml:space="preserve">
          <source>Some extensions, like DB_File and Compress::Zlib use/require prebuilt libraries for the perl extensions/modules to work. If these libraries are built using the default configuration, it might happen that you run into an error like &quot;invalid loader fixup&quot; during load phase. HP is aware of this problem. Search the HP-UX cxx-dev forums for discussions about the subject. The short answer is that &lt;b&gt;everything&lt;/b&gt; (all libraries, everything) must be compiled with &lt;code&gt;+z&lt;/code&gt; or &lt;code&gt;+Z&lt;/code&gt; to be PIC (position independent code). (For gcc, that would be &lt;code&gt;-fpic&lt;/code&gt; or &lt;code&gt;-fPIC&lt;/code&gt; ). In HP-UX 11.00 or newer the linker error message should tell the name of the offending object file.</source>
          <target state="translated">DB_File 및 Compress :: Zlib와 같은 일부 확장자는 perl 확장자 / 모듈이 작동하기 위해 사전 빌드 된 라이브러리를 사용 / 필요합니다. 이러한 라이브러리가 기본 구성을 사용하여 빌드 된 경우로드 단계 중에 &quot;잘못된 로더 수정&quot;과 같은 오류가 발생할 수 있습니다. HP는이 문제를 알고 있습니다. 주제에 대한 토론은 HP-UX cxx-dev 포럼을 검색하십시오. 짧은 대답은 &lt;b&gt;모든 것&lt;/b&gt; (모든 라이브러리, 모든 것)이 &lt;code&gt;+z&lt;/code&gt; 또는 &lt;code&gt;+Z&lt;/code&gt; 로 컴파일되어 PIC (위치 독립적 인 코드)가되어야한다는 것입니다. gcc의 경우 &lt;code&gt;-fpic&lt;/code&gt; 또는 &lt;code&gt;-fPIC&lt;/code&gt; 입니다. HP-UX 11.00 이상에서는 링커 오류 메시지에 문제가있는 객체 파일의 이름이 표시되어야합니다.</target>
        </trans-unit>
        <trans-unit id="97e5fb9532f2e63b2e8307d7b53c5f2c9628f824" translate="yes" xml:space="preserve">
          <source>Some extensions, like DB_File and Compress::Zlib use/require prebuilt libraries for the perl extensions/modules to work. If these libraries are built using the default configuration, it might happen that you run into an error like &quot;invalid loader fixup&quot; during load phase. HP is aware of this problem. Search the HP-UX cxx-dev forums for discussions about the subject. The short answer is that &lt;b&gt;everything&lt;/b&gt; (all libraries, everything) must be compiled with &lt;code&gt;+z&lt;/code&gt; or &lt;code&gt;+Z&lt;/code&gt; to be PIC (position independent code). (For gcc, that would be &lt;code&gt;-fpic&lt;/code&gt; or &lt;code&gt;-fPIC&lt;/code&gt;). In HP-UX 11.00 or newer the linker error message should tell the name of the offending object file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96048dd05a92d52cf8eb93ed66aaff949feef0b8" translate="yes" xml:space="preserve">
          <source>Some features of Storable can lead to security vulnerabilities if you accept Storable documents from untrusted sources with the default flags. Most obviously, the optional (off by default) CODE reference serialization feature allows transfer of code to the deserializing process. Furthermore, any serialized object will cause Storable to helpfully load the module corresponding to the class of the object in the deserializing module. For manipulated module names, this can load almost arbitrary code. Finally, the deserialized object's destructors will be invoked when the objects get destroyed in the deserializing process. Maliciously crafted Storable documents may put such objects in the value of a hash key that is overridden by another key/value pair in the same hash, thus causing immediate destructor execution.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b7fd53f722062eada03c99c5c0131726fe7cb4c" translate="yes" xml:space="preserve">
          <source>Some features of Storable can lead to security vulnerabilities if you accept Storable documents from untrusted sources. Most obviously, the optional (off by default) CODE reference serialization feature allows transfer of code to the deserializing process. Furthermore, any serialized object will cause Storable to helpfully load the module corresponding to the class of the object in the deserializing module. For manipulated module names, this can load almost arbitrary code. Finally, the deserialized object's destructors will be invoked when the objects get destroyed in the deserializing process. Maliciously crafted Storable documents may put such objects in the value of a hash key that is overridden by another key/value pair in the same hash, thus causing immediate destructor execution.</source>
          <target state="translated">신뢰할 수없는 출처의 저장 가능한 문서를 수락하면 Storable의 일부 기능으로 보안 취약점이 발생할 수 있습니다. 가장 명백하게, 선택적 (기본적으로 해제되어있는) CODE 참조 직렬화 기능을 사용하면 코드를 역 직렬화 프로세스로 전송할 수 있습니다. 또한 직렬화 된 객체는 Storable이 직렬화 해제 모듈의 객체 클래스에 해당하는 모듈을 유용하게로드하게합니다. 조작 된 모듈 이름의 경우 거의 임의의 코드를로드 할 수 있습니다. 마지막으로 역 직렬화 객체의 소멸자는 역 직렬화 프로세스에서 객체가 파괴 될 때 호출됩니다. 악의적으로 제작 된 저장 가능한 문서는 이러한 객체를 동일한 해시의 다른 키 / 값 쌍으로 재정의 된 해시 키 값에 넣을 수 있으므로 즉시 소멸자가 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="f752a90675005dd54235d7444500f6345be768a8" translate="yes" xml:space="preserve">
          <source>Some fields (prereq, optional_features) indicate the particular version(s) of some other module that may be required as a prerequisite. This section details the Version Range type used to provide this information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4359f8aa4aabe1dad1748bdef1a7b9a37c1bbf67" translate="yes" xml:space="preserve">
          <source>Some fields are marked</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5db1ec9986268b7b9f60738685c3882e9bc3347c" translate="yes" xml:space="preserve">
          <source>Some fields require a version specification (ex. &lt;a href=&quot;#requires&quot;&gt;&quot;requires&quot;&lt;/a&gt;, &lt;a href=&quot;#recommends&quot;&gt;&quot;recommends&quot;&lt;/a&gt;, &lt;a href=&quot;#build_requires&quot;&gt;&quot;build_requires&quot;&lt;/a&gt;, etc.) to indicate the particular version(s) of some other module that may be required as a prerequisite. This section details the version specification formats that are currently supported.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97585d9b5872f5fb97ab1bbd9ba4d3f871bc3309" translate="yes" xml:space="preserve">
          <source>Some fields require a version specification (ex. &lt;a href=&quot;#requires&quot;&gt;&quot;requires&quot;&lt;/a&gt;, &lt;a href=&quot;#recommends&quot;&gt;&quot;recommends&quot;&lt;/a&gt;, &lt;a href=&quot;#build_requires&quot;&gt;&quot;build_requires&quot;&lt;/a&gt;, etc.). This section details the version specifications that are currently supported.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f1a5845f2d183141d3d5841eae9982c91a04a877" translate="yes" xml:space="preserve">
          <source>Some filesystems may not support UTF-8 file names, or they may be supported incompatibly with Perl. Therefore UTF-8 names that are visible to the filesystem, such as module names may not work.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="410f15ec6c766d4ad924aef6bed79d8486d14679" translate="yes" xml:space="preserve">
          <source>Some folks are surprised that &lt;code&gt;make distclean&lt;/code&gt; does not delete everything not listed in their MANIFEST (thus making a clean distribution) but only tells them what they need to delete. This is done because it is considered too dangerous. While developing your module you might write a new file, not add it to the MANIFEST, then run a &lt;code&gt;distclean&lt;/code&gt; and be sad because your new work was deleted.</source>
          <target state="translated">일부 사람들은 &lt;code&gt;make distclean&lt;/code&gt; 을 작성하면 MANIFEST에 나열되지 않은 모든 항목을 삭제하지 않고 (따라서 깨끗하게 배 포함) 삭제해야 할 내용 만 알려줍니다. 이것은 너무 위험한 것으로 간주되기 때문에 수행됩니다. 모듈을 개발하는 동안 새 파일을 작성하고 MANIFEST에 추가하지 않은 다음 새 작업이 삭제 되어 &lt;code&gt;distclean&lt;/code&gt; 하지 않고 슬프게 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="278e93ddc6a44b33edbb2aa1b1e3252bdefc68ee" translate="yes" xml:space="preserve">
          <source>Some folks would prefer full alphanumeric prototypes. Alphanumerics have been intentionally left out of prototypes for the express purpose of someday in the future adding named, formal parameters. The current mechanism's main goal is to let module writers provide better diagnostics for module users. Larry feels the notation quite understandable to Perl programmers, and that it will not intrude greatly upon the meat of the module, nor make it harder to read. The line noise is visually encapsulated into a small pill that's easy to swallow.</source>
          <target state="translated">어떤 사람들은 완전한 영숫자 프로토 타입을 선호 할 것입니다. 미래에 언젠가는 명명 된 형식 매개 변수를 추가하기 위해 표현 목적으로 영숫자가 의도적으로 프로토 타입에서 제외되었습니다. 현재 메커니즘의 주요 목표는 모듈 작성자가 모듈 사용자에게 더 나은 진단을 제공 할 수 있도록하는 것입니다. Larry는 Perl 프로그래머에게이 표기법을 이해할 수 있다고 느끼며 모듈의 고기에 크게 침입하거나 읽기가 더 어려워지지 않을 것이라고 생각합니다. 라인 노이즈는 시각적으로 삼키기 쉬운 작은 알약으로 캡슐화됩니다.</target>
        </trans-unit>
        <trans-unit id="97b6babea6d7a1882a7f9edff1a7d1c57e6e6a28" translate="yes" xml:space="preserve">
          <source>Some format names that formatters currently are known to accept include &quot;roff&quot;, &quot;man&quot;, &quot;latex&quot;, &quot;tex&quot;, &quot;text&quot;, and &quot;html&quot;. (Some formatters will treat some of these as synonyms.)</source>
          <target state="translated">포맷터가 현재 허용하는 것으로 알려진 일부 형식 이름에는 &quot;roff&quot;, &quot;man&quot;, &quot;latex&quot;, &quot;tex&quot;, &quot;text&quot;및 &quot;html&quot;이 있습니다. 일부 포매터는이 중 일부를 동의어로 취급합니다.</target>
        </trans-unit>
        <trans-unit id="947f64f8eb13b365edd8f2a637d714cf57c4bdc9" translate="yes" xml:space="preserve">
          <source>Some formatter subclasses use this as a flag for whether output should have prologue and epilogue code omitted. For example, setting this to true for an HTML formatter class should omit the &quot;&amp;lt;html&amp;gt;&amp;lt;head&amp;gt;&amp;lt;title&amp;gt;...&amp;lt;/title&amp;gt;&amp;lt;body&amp;gt;...&quot; prologue and the &quot;&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;&quot; epilogue.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bae9c58f7596d57c13463eeb374970b17faa09ff" translate="yes" xml:space="preserve">
          <source>Some frequently seen examples:</source>
          <target state="translated">자주 볼 수있는 몇 가지 예 :</target>
        </trans-unit>
        <trans-unit id="5f63fbe742ecc7df05393f6e705a1b34f98dd874" translate="yes" xml:space="preserve">
          <source>Some functions are provided to simplify customization.</source>
          <target state="translated">사용자 정의를 단순화하기 위해 일부 기능이 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="37fca23bc4f77bc45e835fb641ab69a99facbd7e" translate="yes" xml:space="preserve">
          <source>Some functions are slower when working on UTF-8 encoded strings than on byte encoded strings. All functions that need to hop over characters such as &lt;code&gt;&lt;a href=&quot;functions/length&quot;&gt;length()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/substr&quot;&gt;substr()&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/index&quot;&gt;index()&lt;/a&gt;&lt;/code&gt;, or matching regular expressions can work &lt;b&gt;much&lt;/b&gt; faster when the underlying data are byte-encoded.</source>
          <target state="translated">바이트 인코딩 문자열보다 UTF-8 인코딩 문자열에서 작업 할 때 일부 기능이 느려집니다. &lt;code&gt;&lt;a href=&quot;functions/length&quot;&gt;length()&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/substr&quot;&gt;substr()&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;functions/index&quot;&gt;index()&lt;/a&gt;&lt;/code&gt; 와 같은 문자를 건너 뛰 거나 정규 표현식과 일치 해야하는 모든 함수 는 기본 데이터를 바이트 인코딩 할 때 &lt;b&gt;훨씬&lt;/b&gt; 빠르게 작동 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="29d81f6ce46ee6c8888e985a057496dc42144979" translate="yes" xml:space="preserve">
          <source>Some functions are slower when working on UTF-8 encoded strings than on byte encoded strings. All functions that need to hop over characters such as &lt;code&gt;length()&lt;/code&gt;, &lt;code&gt;substr()&lt;/code&gt; or &lt;code&gt;index()&lt;/code&gt;, or matching regular expressions can work &lt;b&gt;much&lt;/b&gt; faster when the underlying data are byte-encoded.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83116620b210d6b01d6ea586806a731e05a2beb8" translate="yes" xml:space="preserve">
          <source>Some functions available based on the version of VMS. (VMS)</source>
          <target state="translated">VMS 버전에 따라 일부 기능을 사용할 수 있습니다. (VMS)</target>
        </trans-unit>
        <trans-unit id="851bf3122418d781546b0c8256e17049b7be4c91" translate="yes" xml:space="preserve">
          <source>Some languages work directly with the memory addresses of values, but this can be like playing with fire. Perl provides a set of asbestos gloves for handling all memory management. The closest to an address operator in Perl is the backslash operator, but it gives you a &lt;b&gt;hard reference&lt;/b&gt;, which is much safer than a memory address.</source>
          <target state="translated">일부 언어는 값의 메모리 주소와 직접 작동하지만 불을 가지고 노는 것과 같습니다. Perl은 모든 메모리 관리를 처리하기위한 석면 장갑 세트를 제공합니다. Perl에서 주소 연산자와 가장 가까운 것은 백 슬래시 연산자이지만, &lt;b&gt;하드&lt;/b&gt; 주소보다 훨씬 안전한 &lt;b&gt;하드 레퍼런스를&lt;/b&gt; 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="3b63ca608d0f3df96b959d17a1dcc8d27338725f" translate="yes" xml:space="preserve">
          <source>Some layers will automatically insert required lower level layers if not present; for example &lt;code&gt;:perlio&lt;/code&gt; will insert &lt;code&gt;:unix&lt;/code&gt; below itself for low level IO, and &lt;code&gt;:encoding&lt;/code&gt; will insert the platform defaults for buffered IO.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2879836a3b0aef43a136fc41d29e15e272723203" translate="yes" xml:space="preserve">
          <source>Some libraries use methods that don't modify their argument, and some libraries don't even use objects, but rather unblessed references. Because of this, liberary methods are always called as class methods, not instance methods:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2704cdd835e2ffc2151c5b3e73d345acc2100f0" translate="yes" xml:space="preserve">
          <source>Some locales have special sorting rules.</source>
          <target state="translated">일부 로케일에는 특별한 정렬 규칙이 있습니다.</target>
        </trans-unit>
        <trans-unit id="4cbad0bcc8b3efd678863ec66e302790409bbb20" translate="yes" xml:space="preserve">
          <source>Some methods take slightly different arguments to those defined in &lt;a href=&quot;../perlfunc&quot;&gt;perlfunc&lt;/a&gt; in attempt to make the interface more flexible. These are</source>
          <target state="translated">일부 메소드 는 인터페이스를보다 유연하게 만들기 위해 &lt;a href=&quot;../perlfunc&quot;&gt;perlfunc&lt;/a&gt; 에 정의 된 것과 약간 다른 인수를 취 합니다. 이것들은</target>
        </trans-unit>
        <trans-unit id="4d5ca2cd44839d0147fa7ed895887914f1a8f96d" translate="yes" xml:space="preserve">
          <source>Some modules have an event loop, waiting for user-input. It is highly unlikely that two such modules would work adequately together in a single Perl application.</source>
          <target state="translated">일부 모듈에는 사용자 입력을 기다리는 이벤트 루프가 있습니다. 이러한 두 모듈이 단일 Perl 응용 프로그램에서 적절하게 함께 작동 할 가능성은 거의 없습니다.</target>
        </trans-unit>
        <trans-unit id="e535cd54feac531816f027ba1cdedeba3dabdc08" translate="yes" xml:space="preserve">
          <source>Some modules have validation for particular types of input, such as &lt;a href=&quot;Business::ISBN&quot;&gt;Business::ISBN&lt;/a&gt;, &lt;a href=&quot;Business::CreditCard&quot;&gt;Business::CreditCard&lt;/a&gt;, &lt;a href=&quot;Email::Valid&quot;&gt;Email::Valid&lt;/a&gt;, and &lt;a href=&quot;Data::Validate::IP&quot;&gt;Data::Validate::IP&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99aeed54cc1e7c695f296661c28f743d9f582de7" translate="yes" xml:space="preserve">
          <source>Some modules have validation for particular types of input, such as &lt;a href=&quot;http://search.cpan.org/perldoc/Business::ISBN&quot;&gt;Business::ISBN&lt;/a&gt;, &lt;a href=&quot;http://search.cpan.org/perldoc/Business::CreditCard&quot;&gt;Business::CreditCard&lt;/a&gt;, &lt;a href=&quot;http://search.cpan.org/perldoc/Email::Valid&quot;&gt;Email::Valid&lt;/a&gt;, and &lt;a href=&quot;http://search.cpan.org/perldoc/Data::Validate::IP&quot;&gt;Data::Validate::IP&lt;/a&gt;.</source>
          <target state="translated">일부 모듈에는 &lt;a href=&quot;http://search.cpan.org/perldoc/Business::ISBN&quot;&gt;Business :: ISBN&lt;/a&gt; , &lt;a href=&quot;http://search.cpan.org/perldoc/Business::CreditCard&quot;&gt;Business :: CreditCard&lt;/a&gt; , &lt;a href=&quot;http://search.cpan.org/perldoc/Email::Valid&quot;&gt;Email :: Valid&lt;/a&gt; 및 &lt;a href=&quot;http://search.cpan.org/perldoc/Data::Validate::IP&quot;&gt;Data :: Validate :: IP&lt;/a&gt; 와 같은 특정 유형의 입력에 대한 유효성 검사가 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8896acdebb142a8bf319a25d0ebc467b0372d0f5" translate="yes" xml:space="preserve">
          <source>Some modules live both in the &lt;b&gt;Standard Library&lt;/b&gt; and on &lt;b&gt;CPAN&lt;/b&gt;. These modules might be developed on two tracks as people modify either version. The trend currently is to untangle these situations.</source>
          <target state="translated">일부 모듈은 &lt;b&gt;표준 라이브러리&lt;/b&gt; 와 &lt;b&gt;CPAN에 모두&lt;/b&gt; 있습니다. 이 모듈은 사람들이 두 버전을 수정함에 따라 두 개의 트랙에서 개발 될 수 있습니다. 현재 추세는 이러한 상황을 해결하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="267ef3c8246a5b5e4dbd867563c1e64b65448f37" translate="yes" xml:space="preserve">
          <source>Some modules look directly at hash keys on the Test::Builder singleton. The problem here is that the Test::Builder singleton no longer holds anything important.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="215c8776bbaeb0d62cdfe5e95b87468adeef4092" translate="yes" xml:space="preserve">
          <source>Some modules may call a non-perl library that is locale-aware. This is fine as long as it doesn't try to query or change the locale using the system &lt;code&gt;setlocale&lt;/code&gt;. But if these do call the system &lt;code&gt;setlocale&lt;/code&gt;, those calls may be ineffective. Instead, &lt;a href=&quot;perlapi#Perl_setlocale&quot;&gt;&lt;code&gt;Perl_setlocale&lt;/code&gt;&lt;/a&gt; works in all circumstances. Plain setlocale is ineffective on multi-threaded POSIX 2008 systems. It operates only on the global locale, whereas each thread has its own locale, paying no attention to the global one. Since converting these non-Perl libraries to &lt;code&gt;Perl_setlocale&lt;/code&gt; is out of the question, there is a new function in v5.28 &lt;a href=&quot;perlapi#switch_to_global_locale&quot;&gt;&lt;code&gt;switch_to_global_locale&lt;/code&gt;&lt;/a&gt; that will switch the thread it is called from so that any system &lt;code&gt;setlocale&lt;/code&gt; calls will have their desired effect. The function &lt;a href=&quot;perlapi#sync_locale&quot;&gt;&lt;code&gt;sync_locale&lt;/code&gt;&lt;/a&gt; must be called before returning to perl.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2536c5611f03605401087c295c560b8c0a55966f" translate="yes" xml:space="preserve">
          <source>Some modules might have special reporting requirements, such as a Github or Google Code tracking system, so you should check the module documentation too.</source>
          <target state="translated">일부 모듈에는 Github 또는 Google 코드 추적 시스템과 같은 특별한보고 요구 사항이있을 수 있으므로 모듈 설명서도 확인해야합니다.</target>
        </trans-unit>
        <trans-unit id="9d3dcbb265761ea263567338345aa34c90c2eea2" translate="yes" xml:space="preserve">
          <source>Some modules, mainly extensions, provide their own AUTOLOAD subroutines. They typically need to check for some special cases (such as constants) and then fallback to &lt;b&gt;AutoLoader&lt;/b&gt;'s AUTOLOAD for the rest.</source>
          <target state="translated">주로 확장 인 일부 모듈은 자체 AUTOLOAD 서브 루틴을 제공합니다. 일반적으로 상수와 같은 특별한 경우를 확인한 다음 나머지는 &lt;b&gt;AutoLoader&lt;/b&gt; 의 AUTOLOAD 로 대체해야 합니다.</target>
        </trans-unit>
        <trans-unit id="f0adb7b022a9b5dadbc9c6aa9b58b0a54e7f8265" translate="yes" xml:space="preserve">
          <source>Some more examples, all returning 250:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c12ec8767768e2405ac12fa9dd3e5b3e02eaa4d" translate="yes" xml:space="preserve">
          <source>Some names known to &lt;code&gt;\N{...}&lt;/code&gt; refer to a sequence of multiple characters, instead of the usual single character. When one of these is included in the class, the entire sequence is matched. For example,</source>
          <target state="translated">&lt;code&gt;\N{...}&lt;/code&gt; 알려진 일부 이름 은 일반적인 단일 문자 대신 여러 문자 시퀀스를 나타냅니다. 이들 중 하나가 클래스에 포함되면 전체 시퀀스가 ​​일치합니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="86874fce71a4882d328a8877cd2a4fc52a6a4fe2" translate="yes" xml:space="preserve">
          <source>Some networking library functions like gethostbyname() are known to have their own implementations of timeouts which may conflict with your timeouts. If you have problems with such functions, try using the POSIX sigaction() function, which bypasses Perl safe signals. Be warned that this does subject you to possible memory corruption, as described above.</source>
          <target state="translated">gethostbyname ()과 같은 일부 네트워킹 라이브러리 함수에는 시간 초과와 충돌 할 수있는 자체 시간 초과 구현이있는 것으로 알려져 있습니다. 이러한 함수에 문제가 있으면 Perl 안전 신호를 무시하는 POSIX sigaction () 함수를 사용해보십시오. 위에서 설명한대로 메모리 손상이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0ce6014b84ac6fe075f649ff6034ad219b7b909a" translate="yes" xml:space="preserve">
          <source>Some non-Perl implementations of the Age property may change its meaning to be the same as the Perl &lt;code&gt;Present_In&lt;/code&gt; property; just be aware of that.</source>
          <target state="translated">Age 속성의 일부 Perl 이외의 구현은 그 의미가 Perl &lt;code&gt;Present_In&lt;/code&gt; 속성 과 동일하게 변경 될 수 있습니다 . 그냥 알아 둬</target>
        </trans-unit>
        <trans-unit id="020d12e0872ef168546404b52284bd6940ecd187" translate="yes" xml:space="preserve">
          <source>Some non-numeric HTML entity name, such as &lt;code&gt;E&amp;lt;eacute&amp;gt;&lt;/code&gt; , meaning the same thing as &lt;code&gt;&amp;amp;eacute;&lt;/code&gt; in HTML -- i.e., a lowercase e with an acute (/-shaped) accent.</source>
          <target state="translated">같은 일부 숫자가 아닌 HTML 엔티티 이름, &lt;code&gt;E&amp;lt;eacute&amp;gt;&lt;/code&gt; , 같은 일을 의미 &lt;code&gt;&amp;amp;eacute;&lt;/code&gt; HTML에서, 즉 예를 들어, 급성 (/ 모양) 악센트가있는 소문자 e.</target>
        </trans-unit>
        <trans-unit id="d647bb86c88fea55dd1fa79cef8c74e6a775c39b" translate="yes" xml:space="preserve">
          <source>Some non-numeric HTML entity name, such as &lt;code&gt;E&amp;lt;eacute&amp;gt;&lt;/code&gt;, meaning the same thing as &lt;code&gt;&amp;amp;eacute;&lt;/code&gt; in HTML -- i.e., a lowercase e with an acute (/-shaped) accent.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="742d524f056fc75f1015c7da11070249cb40a21b" translate="yes" xml:space="preserve">
          <source>Some notes about ftp archives: Please use a long descriptive file name that includes the version number. Most incoming directories will not be readable/listable, i.e., you won't be able to see your file after uploading it. Remember to send your email notification message as soon as possible after uploading else your file may get deleted automatically. Allow time for the file to be processed and/or check the file has been processed before announcing its location.</source>
          <target state="translated">ftp 아카이브에 대한 참고 사항 : 버전 번호가 포함 된 긴 설명 파일 이름을 사용하십시오. 대부분의 수신 디렉토리는 읽거나 나열 할 수 없습니다. 즉, 파일을 업로드 한 후에는 파일을 볼 수 없습니다. 업로드 후 가능한 빨리 이메일 알림 메시지를 보내야합니다. 그렇지 않으면 파일이 자동으로 삭제 될 수 있습니다. 파일을 처리하기위한 시간을 허용하거나 파일의 위치를 ​​알리기 전에 파일이 처리되었는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="7d0867bfec63bbea7b4c7184ee3d3a80f6c90eb5" translate="yes" xml:space="preserve">
          <source>Some of Test::Tester's functions return arrays of these hashes, just like Test::Builder-&amp;gt;details. That is, the hash for the first test will be array element 1 (not 0). Element 0 will not be a hash it will be a string which contains any diagnostic output that came before the first test. This should usually be empty, if it's not, it means something output diagnostics before any test results showed up.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc5039f425d422cec80636f2fe25c7aa8c335808" translate="yes" xml:space="preserve">
          <source>Some of the books we've listed appear almost ancient in internet scale, but we've included those books because they still describe the current way of doing things. Not everything in Perl changes every day. Many of the beginner-level books, too, go over basic features and techniques that are still valid today. In general though, we try to limit this list to books published in the past five years.</source>
          <target state="translated">우리가 나열한 책 중 일부는 인터넷 규모가 거의 고대인 것처럼 보이지만, 현재 진행중인 방식을 설명하기 때문에 해당 책을 포함 시켰습니다. Perl의 모든 것이 매일 바뀌지는 않습니다. 초보자 수준의 많은 책들도 오늘날에도 여전히 유효한 기본 기능과 기술을 살펴 봅니다. 그러나 일반적으로이 목록을 지난 5 년 동안 출판 된 책으로 제한하려고합니다.</target>
        </trans-unit>
        <trans-unit id="ec6365cb89577ea447484ee46de59521b7dffa94" translate="yes" xml:space="preserve">
          <source>Some of the built-in functions do not act exactly as documented in &lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt;, and a few are not implemented at all. To avoid surprises, particularly if you have had prior exposure to Perl in other operating environments or if you intend to write code that will be portable to other environments, see &lt;a href=&quot;perlport&quot;&gt;perlport&lt;/a&gt; for a reasonably definitive list of these differences.</source>
          <target state="translated">내장 함수 중 일부는 &lt;a href=&quot;perlfunc&quot;&gt;perlfunc에&lt;/a&gt; 설명 된대로 정확하게 작동하지 않으며 일부는 전혀 구현되지 않았습니다. 놀랍게도, 특히 다른 운영 환경에서 Perl에 사전 노출 된 적이 있거나 다른 환경에서 이식 가능한 코드를 작성하려는 경우 &lt;a href=&quot;perlport&quot;&gt;perlport&lt;/a&gt; 에서 이러한 차이점에 대한 합리적인 결정 목록을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0c8239353496c2009cfe543c3292467ce35311ef" translate="yes" xml:space="preserve">
          <source>Some of the configuration files in /etc used by the networking APIs are either missing or have the wrong names. In particular, make sure that there's either an /etc/resolv.conf or an /etc/hosts, so that gethostbyname() works, and make sure that the file /etc/proto has been renamed to /etc/protocol (NOT /etc/protocols, as used by other Unix systems). You may have to look for things like HOSTNAME and DOMAINORIGIN in the &quot;//'SYS1.TCPPARMS(TCPDATA)'&quot; PDS member in order to properly set up your /etc networking files.</source>
          <target state="translated">네트워킹 API가 사용하는 / etc의 일부 구성 파일이 누락되었거나 이름이 잘못되었습니다. 특히, gethostbyname ()이 작동하도록 /etc/resolv.conf 또는 / etc / hosts가 있는지 확인하고 / etc / proto 파일의 이름이 / etc / protocol (NOT / 기타 유닉스 시스템에서 사용되는 기타 / 프로토콜). / etc 네트워킹 파일을 올바르게 설정하기 위해 &quot;//'SYS1.TCPPARMS(TCPDATA) '&quot;PDS 멤버에서 HOSTNAME 및 DOMAINORIGIN과 같은 항목을 찾아야 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="1d2fcdaf6bf2b0dace2c66c8a0e3613f9f85f66f" translate="yes" xml:space="preserve">
          <source>Some of the entries in the list are marked as &quot;experimental&quot;. This means these should not generally be used. They may be removed or changed without notice. You can ask why they are experimental by sending email to &lt;a href=&quot;mailto:perl5-porters@perl.org&quot;&gt;mailto:perl5-porters@perl.org&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97b022f479803e9b4139aa894b3173d5ebd19950" translate="yes" xml:space="preserve">
          <source>Some of the examples later in &lt;a href=&quot;perlfaq4&quot;&gt;perlfaq4&lt;/a&gt; use the &lt;a href=&quot;Bit::Vector&quot;&gt;Bit::Vector&lt;/a&gt; module from CPAN. The reason you might choose &lt;a href=&quot;Bit::Vector&quot;&gt;Bit::Vector&lt;/a&gt; over the perl built-in functions is that it works with numbers of ANY size, that it is optimized for speed on some operations, and for at least some programmers the notation might be familiar.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4c6dd767013c78841ab05e0e012ebcc93f26f14" translate="yes" xml:space="preserve">
          <source>Some of the examples later in &lt;a href=&quot;perlfaq4&quot;&gt;perlfaq4&lt;/a&gt; use the &lt;a href=&quot;http://search.cpan.org/perldoc/Bit::Vector&quot;&gt;Bit::Vector&lt;/a&gt; module from CPAN. The reason you might choose &lt;a href=&quot;http://search.cpan.org/perldoc/Bit::Vector&quot;&gt;Bit::Vector&lt;/a&gt; over the perl built-in functions is that it works with numbers of ANY size, that it is optimized for speed on some operations, and for at least some programmers the notation might be familiar.</source>
          <target state="translated">&lt;a href=&quot;perlfaq4&quot;&gt;perlfaq4&lt;/a&gt; 에서 나중에 나오는 일부 예 는 CPAN 의 &lt;a href=&quot;http://search.cpan.org/perldoc/Bit::Vector&quot;&gt;Bit :: Vector&lt;/a&gt; 모듈을 사용합니다 . Perl 내장 함수보다 &lt;a href=&quot;http://search.cpan.org/perldoc/Bit::Vector&quot;&gt;Bit :: Vector&lt;/a&gt; 를 선택할 수있는 이유 는 모든 크기의 숫자에서 작동하고 일부 작업의 속도에 최적화되어 있으며 최소한 일부 프로그래머에게는 익숙한 표기법이기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="b1b52c56fd19edbbc0804a6b9841658fb64d4030" translate="yes" xml:space="preserve">
          <source>Some of the functionality of the debugging code can be achieved using XS modules.</source>
          <target state="translated">디버깅 코드의 일부 기능은 XS 모듈을 사용하여 달성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bf0e1ecb04bb221fe8c8c990742dfa2a73f01086" translate="yes" xml:space="preserve">
          <source>Some of the functionality of the debugging code can be achieved with a non-debugging perl by using XS modules:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="129d9d1e78c142ea547ff6b028cde8ebd0aadf7f" translate="yes" xml:space="preserve">
          <source>Some of the functions are called with a</source>
          <target state="translated">함수 중 일부는</target>
        </trans-unit>
        <trans-unit id="43704b45451eba3bea984abb31f94004f6ecfd41" translate="yes" xml:space="preserve">
          <source>Some of the highlights of &lt;a href=&quot;perlref&quot;&gt;perlref&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;perlref&quot;&gt;perlref&lt;/a&gt; 의 주요 특징 중 일부 :</target>
        </trans-unit>
        <trans-unit id="02ba05af57929b86c26da34f7202e0310b46aa70" translate="yes" xml:space="preserve">
          <source>Some of the methods defined in &lt;code&gt;Net::FTP&lt;/code&gt; return an object which will be derived from the &lt;code&gt;Net::FTP::dataconn&lt;/code&gt; class. See &lt;a href=&quot;Net::FTP::dataconn&quot;&gt;Net::FTP::dataconn&lt;/a&gt; for more details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c35b9e6be7b3bf5bc03040d536fb7da8f901aae2" translate="yes" xml:space="preserve">
          <source>Some of the methods defined in &lt;code&gt;Net::FTP&lt;/code&gt; return an object which will be derived from the &lt;code&gt;Net::FTP::dataconn&lt;/code&gt; class. See &lt;a href=&quot;ftp/dataconn&quot;&gt;Net::FTP::dataconn&lt;/a&gt; for more details.</source>
          <target state="translated">&lt;code&gt;Net::FTP&lt;/code&gt; 정의 된 일부 메소드 는 &lt;code&gt;Net::FTP::dataconn&lt;/code&gt; 클래스 에서 파생 된 오브젝트를 리턴합니다 . 자세한 내용은 &lt;a href=&quot;ftp/dataconn&quot;&gt;Net :: FTP :: dataconn&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="085f62b2598cb482a6875006e876358d6d804f21" translate="yes" xml:space="preserve">
          <source>Some of the methods defined in &lt;code&gt;Net::FTP&lt;/code&gt; return an object which will be derived from this class. The dataconn class itself is derived from the &lt;code&gt;IO::Socket::INET&lt;/code&gt; class, so any normal IO operations can be performed. However the following methods are defined in the dataconn class and IO should be performed using these.</source>
          <target state="translated">&lt;code&gt;Net::FTP&lt;/code&gt; 정의 된 일부 메서드 는이 클래스에서 파생 된 개체를 반환합니다. dataconn 클래스 자체는 &lt;code&gt;IO::Socket::INET&lt;/code&gt; 클래스 에서 파생 되므로 일반적인 IO 작업을 수행 할 수 있습니다. 그러나 다음 메소드는 dataconn 클래스에 정의되어 있으며이를 사용하여 IO를 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="fbd9bb2f70bdb8a22b7796ad4ee4aab43ab4a22a" translate="yes" xml:space="preserve">
          <source>Some of the modifiers require more explanation than given in the &lt;a href=&quot;#Overview&quot;&gt;&quot;Overview&quot;&lt;/a&gt; above.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a2754422800ffdc8654fa173c411cbbdaf9ca8a2" translate="yes" xml:space="preserve">
          <source>Some of the modules that use these libraries &lt;a href=&quot;Math::BigInt&quot;&gt;Math::BigInt&lt;/a&gt;, &lt;a href=&quot;Math::BigFloat&quot;&gt;Math::BigFloat&lt;/a&gt;, and &lt;a href=&quot;Math::BigRat&quot;&gt;Math::BigRat&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="312d5ef79ec3abd87646ed6a59f9c68ae862462d" translate="yes" xml:space="preserve">
          <source>Some of the most common mistakes:</source>
          <target state="translated">가장 일반적인 실수 중 일부 :</target>
        </trans-unit>
        <trans-unit id="5796d9bed54a4c270451442098ed19f9f0088003" translate="yes" xml:space="preserve">
          <source>Some of the most common values are &lt;code&gt;O_RDONLY&lt;/code&gt; for opening the file in read-only mode, &lt;code&gt;O_WRONLY&lt;/code&gt; for opening the file in write-only mode, and &lt;code&gt;O_RDWR&lt;/code&gt; for opening the file in read-write mode.</source>
          <target state="translated">가장 일반적인 값 중 일부는 파일을 읽기 전용 모드로 여는 경우 &lt;code&gt;O_RDONLY&lt;/code&gt; , 파일을 쓰기 전용 모드로 여는 경우 &lt;code&gt;O_WRONLY&lt;/code&gt; , 파일을 읽기 / 쓰기 모드로 여는 경우 &lt;code&gt;O_RDWR&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="d5f4367d2cd66fe5bca2400a4df459be12cf9924" translate="yes" xml:space="preserve">
          <source>Some of the parser default template files in /samples are needed in /etc. In particular be sure that you at least copy /samples/yyparse.c to /etc before running Perl's Configure. This step ensures successful extraction of EBCDIC versions of parser files such as perly.c and perly.h. This has to be done before running Configure the first time. If you failed to do so then the easiest way to re-Configure Perl is to delete your misconfigured build root and re-extract the source from the tar ball. Then you must ensure that /etc/yyparse.c is properly in place before attempting to re-run Configure.</source>
          <target state="translated">/ samples의 일부 파서 기본 템플릿 파일은 / etc에 필요합니다. 특히 Perl의 Configure를 실행하기 전에 최소한 /samples/yyparse.c를 / etc에 복사해야합니다. 이 단계는 perly.c 및 perly.h와 같은 구문 분석기 파일의 EBCDIC 버전을 성공적으로 추출합니다. 구성을 처음 실행하기 전에 수행해야합니다. 그렇지 않은 경우 Perl을 다시 구성하는 가장 쉬운 방법은 잘못 구성된 빌드 루트를 삭제하고 tar ball에서 소스를 다시 추출하는 것입니다. 그런 다음 Configure를 다시 실행하기 전에 /etc/yyparse.c가 제자리에 있는지 확인해야합니다.</target>
        </trans-unit>
        <trans-unit id="83c0811a95d044951ce0ba50edb2e9cd1f45c8cb" translate="yes" xml:space="preserve">
          <source>Some of the reported info, such as hex addresses, is not particularly valuable. Other information would be more useful for the typical programmer, such as line-numbers, pad-slot reuses, etc.. Given this, -newlex is not a particularly good flag-name.</source>
          <target state="translated">16 진 주소와 같은보고 된 정보 중 일부는 특별히 중요하지 않습니다. 행 번호, 패드 슬롯 재사용 등과 같은 다른 정보는 일반적인 프로그래머에게 더 유용 할 것입니다.이를 감안할 때 -newlex는 특히 좋은 플래그 이름이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="6116e5b7738fb6cac5aba2e6136f23c97d874e1d" translate="yes" xml:space="preserve">
          <source>Some of the standard Perl XS extensions (see &lt;a href=&quot;#HISTORY&quot;&gt;&quot;HISTORY&quot;&lt;/a&gt; are also available:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2180880e97e49639996064a1f6af7e81cac534b" translate="yes" xml:space="preserve">
          <source>Some of the standard Perl libraries are included, but not all: see &lt;a href=&quot;#HISTORY&quot;&gt;&quot;HISTORY&quot;&lt;/a&gt; or</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2cdf99bdb0c6c762dab8d358da246b612330e8fa" translate="yes" xml:space="preserve">
          <source>Some of these are also deprecated. You can exclude these from your compiled Perl by adding this option to Configure: &lt;code&gt;-Accflags='-DNO_MATHOMS'&lt;/code&gt;</source>
          <target state="translated">이들 중 일부는 더 이상 사용되지 않습니다. 이 옵션을 구성에 추가하여 컴파일 된 Perl에서이를 제외 할 수 있습니다. &lt;code&gt;-Accflags='-DNO_MATHOMS'&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d94da1d47f6dfef189dc9a92fab735da2e9c93d7" translate="yes" xml:space="preserve">
          <source>Some of these books are available as free downloads.</source>
          <target state="translated">이 책들 중 일부는 무료로 다운로드 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="55b425b2a6fe515905b997d3820e2d955eabc2cf" translate="yes" xml:space="preserve">
          <source>Some of these functions also combine dynaloading semantic with the error-propagation semantic discussed above.</source>
          <target state="translated">이러한 기능 중 일부는 또한 위에서 설명한 오류 전파 의미론과 dynaloading 의미론을 결합합니다.</target>
        </trans-unit>
        <trans-unit id="7a3b090758880601b5c97fb9b694e1e73a3369bc" translate="yes" xml:space="preserve">
          <source>Some of these methods might be of interest to general users, as well as of interest to formatter-writers.</source>
          <target state="translated">이러한 방법 중 일부는 일반 사용자뿐만 아니라 포맷터 작성자에게도 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="644a8605b72e956aa183e4a65e2c5fc19e8769dc" translate="yes" xml:space="preserve">
          <source>Some of these pseudo-modules import semantics into the current block scope (like &lt;a href=&quot;strict&quot;&gt;&lt;code&gt;strict&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;integer&quot;&gt;&lt;code&gt;integer&lt;/code&gt;&lt;/a&gt;, unlike ordinary modules, which import symbols into the current package (which are effective through the end of the file).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80eb2a0ac01474685656b9eca0e98318c5698b3f" translate="yes" xml:space="preserve">
          <source>Some of these pseudo-modules import semantics into the current block scope (like &lt;code&gt;strict&lt;/code&gt; or &lt;code&gt;integer&lt;/code&gt; , unlike ordinary modules, which import symbols into the current package (which are effective through the end of the file).</source>
          <target state="translated">이러한 의사 모듈 중 일부는 시맨틱을 현재 블록 범위로 가져옵니다 ( 일반 모듈과 달리 &lt;code&gt;strict&lt;/code&gt; 또는 &lt;code&gt;integer&lt;/code&gt; 와 같이). 심볼을 현재 패키지로 가져옵니다 (파일 끝까지 유효).</target>
        </trans-unit>
        <trans-unit id="f69cda68e897fa9c0b4882048fc82a98372f85df" translate="yes" xml:space="preserve">
          <source>Some of these shouldn't really be called in a Perl application, and for others there are thread-safe versions of these already implemented:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8fc82daea8e525be9f1657205fd39cc94c0720ec" translate="yes" xml:space="preserve">
          <source>Some of these specific cases are shown as examples in other answers in this section of the perlfaq.</source>
          <target state="translated">이러한 특정 사례 중 일부는 perlfaq의이 섹션에서 다른 답변의 예로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="7ac7dfacde52b03cada88bb1c11d6be2449d545b" translate="yes" xml:space="preserve">
          <source>Some of this may be confusing. Here's a handy reference to the ASCII CR and LF characters. You can print it out and stick it in your wallet.</source>
          <target state="translated">이 중 일부는 혼란 스러울 수 있습니다. 다음은 ASCII CR 및 LF 문자에 대한 편리한 참조입니다. 인쇄하여 지갑에 붙일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9436ec9fafb3dbaf8b6e8266e0c7a558118556b8" translate="yes" xml:space="preserve">
          <source>Some older Pod translators require paragraphs (including command paragraphs like &quot;=head2 Functions&quot;) to be separated by</source>
          <target state="translated">일부 구형 포드 번역기는 단락 ( &quot;= head2 Functions&quot;와 같은 명령 단락 포함)을 다음과 같이 구분해야합니다.</target>
        </trans-unit>
        <trans-unit id="530312ef21d84b684c5534cd434fe4d79ac602e0" translate="yes" xml:space="preserve">
          <source>Some older versions of Berkeley DB had problems with fixed length records using the RECNO file format. This problem has been fixed since version 1.85 of Berkeley DB.</source>
          <target state="translated">일부 이전 버전의 Berkeley DB는 RECNO 파일 형식을 사용하는 고정 길이 레코드에 문제가있었습니다. 이 문제는 Berkeley DB 버전 1.85부터 수정되었습니다.</target>
        </trans-unit>
        <trans-unit id="4c2cd6192ba71ba66f15fbdbb416f6e8ad76580e" translate="yes" xml:space="preserve">
          <source>Some operating systems don't ship the CORE directory with their base perl install. To solve the problem, you likely need to install a perl development package such as perl-devel (CentOS, Fedora and other Redhat systems) or perl (Ubuntu and other Debian systems).</source>
          <target state="translated">일부 운영 체제는 기본 perl 설치와 함께 CORE 디렉토리를 제공하지 않습니다. 이 문제를 해결하려면 perl-devel (CentOS, Fedora 및 기타 Redhat 시스템) 또는 perl (우분투 및 기타 데비안 시스템)과 같은 perl 개발 패키지를 설치해야합니다.</target>
        </trans-unit>
        <trans-unit id="a0bcdb116909bbaf782dcc8531648c8104b0144b" translate="yes" xml:space="preserve">
          <source>Some operating systems have bugs in the kernel that make setuid scripts inherently insecure. Perl gives you a number of options (described in &lt;a href=&quot;perlsec&quot;&gt;perlsec&lt;/a&gt;) to work around such systems.</source>
          <target state="translated">일부 운영 체제의 커널에는 setuid 스크립트가 본질적으로 안전하지 않은 버그가 있습니다. Perl은 이러한 시스템을 해결하기 위한 많은 옵션 ( &lt;a href=&quot;perlsec&quot;&gt;perlsec에&lt;/a&gt; 설명되어 있음 )을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="2250e1a4559063fcac9cec7cc104374f3f26f7ef" translate="yes" xml:space="preserve">
          <source>Some operating systems may perform &lt;code&gt;IO::File::new()&lt;/code&gt; or &lt;code&gt;IO::File::open()&lt;/code&gt; on a directory without errors. This behavior is not portable and not suggested for use. Using &lt;code&gt;&lt;a href=&quot;../functions/opendir&quot;&gt;opendir()&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../functions/readdir&quot;&gt;readdir()&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;IO::Dir&lt;/code&gt; are suggested instead.</source>
          <target state="translated">일부 운영 체제는 디렉토리에서 &lt;code&gt;IO::File::new()&lt;/code&gt; 또는 &lt;code&gt;IO::File::open()&lt;/code&gt; 을 오류없이 수행 할 수 있습니다. 이 동작은 이식 ​​가능하지 않으므로 사용하지 않는 것이 좋습니다. 사용 &lt;code&gt;&lt;a href=&quot;../functions/opendir&quot;&gt;opendir()&lt;/a&gt;&lt;/code&gt; 와 &lt;code&gt;&lt;a href=&quot;../functions/readdir&quot;&gt;readdir()&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;IO::Dir&lt;/code&gt; 대신 제안한다.</target>
        </trans-unit>
        <trans-unit id="69855bea0e31a33e7317d263f4ec459059c92ed3" translate="yes" xml:space="preserve">
          <source>Some operating systems may perform &lt;code&gt;IO::File::new()&lt;/code&gt; or &lt;code&gt;IO::File::open()&lt;/code&gt; on a directory without errors. This behavior is not portable and not suggested for use. Using &lt;code&gt;opendir()&lt;/code&gt; and &lt;code&gt;readdir()&lt;/code&gt; or &lt;code&gt;IO::Dir&lt;/code&gt; are suggested instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39015af4e836c35f8e25b30fad81d0e5afdfce43" translate="yes" xml:space="preserve">
          <source>Some operations may be slower for small numbers, but are significantly faster for big numbers. Other operations are now constant (O(1), like &lt;code&gt;bneg()&lt;/code&gt; , &lt;code&gt;babs()&lt;/code&gt; etc), instead of O(N) and thus nearly always take much less time. These optimizations were done on purpose.</source>
          <target state="translated">작은 숫자의 경우 일부 작업이 느릴 수 있지만 큰 숫자의 경우 훨씬 빠릅니다. 다른 연산은 이제 O (N) 대신 일정 (O (1), &lt;code&gt;bneg()&lt;/code&gt; , &lt;code&gt;babs()&lt;/code&gt; 등)이므로 거의 항상 훨씬 적은 시간이 걸립니다. 이러한 최적화는 일부러 이루어졌습니다.</target>
        </trans-unit>
        <trans-unit id="34443f21f05a44f91512261ff33473bdb84f64b0" translate="yes" xml:space="preserve">
          <source>Some operations may be slower for small numbers, but are significantly faster for big numbers. Other operations are now constant (O(1), like &lt;code&gt;bneg()&lt;/code&gt;, &lt;code&gt;babs()&lt;/code&gt; etc), instead of O(N) and thus nearly always take much less time. These optimizations were done on purpose.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c9f3e95144e8b33a9458895d77a0f239683f515" translate="yes" xml:space="preserve">
          <source>Some operators are instead non-associative, meaning that it is a syntax error to use a sequence of those operators of the same precedence. For example, &lt;code&gt;&quot;$x .. $y .. $z&quot;&lt;/code&gt; is an error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="62110d88a0d086d7fc7d0ffc86ee7f8031edd34d" translate="yes" xml:space="preserve">
          <source>Some options, in particular &lt;code&gt;-I&lt;/code&gt;, &lt;code&gt;-M&lt;/code&gt;, &lt;code&gt;PERL5LIB&lt;/code&gt; and &lt;code&gt;PERL5OPT&lt;/code&gt; can interact, and the order in which they are applied is important.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03ecacb543bf1cb170543843116f3f4c7e881ad8" translate="yes" xml:space="preserve">
          <source>Some other (not completely debugged) situations when FP flags change include some video drivers (?), and some operations related to creation of the windows. People who code &lt;b&gt;OpenGL&lt;/b&gt; may have more experience on this.</source>
          <target state="translated">FP 플래그가 변경 될 때 발생하는 일부 (완전히 디버깅되지 않은) 상황에는 일부 비디오 드라이버 (?) 및 창 생성과 관련된 일부 작업이 포함됩니다. &lt;b&gt;OpenGL&lt;/b&gt; 을 코딩 &lt;b&gt;하는&lt;/b&gt; 사람들 은 이에 대해 더 많은 경험을 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="377fbf88a15d635b8d6d486abdf4ac17224b10a7" translate="yes" xml:space="preserve">
          <source>Some other IO modules don't belong to the perl core but can be loaded as well if they have been installed from CPAN. You can discover which ones exist by searching for &quot;^IO::&quot; on &lt;a href=&quot;http://search.cpan.org&quot;&gt;http://search.cpan.org&lt;/a&gt;.</source>
          <target state="translated">다른 IO 모듈은 perl 코어에 속하지 않지만 CPAN에서 설치 한 경우에도로드 할 수 있습니다. &lt;a href=&quot;http://search.cpan.org&quot;&gt;http://search.cpan.org&lt;/a&gt; 에서 &quot;^ IO ::&quot;를 검색하여 존재하는 항목을 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2d0a736269bfee7b88f6f3d6b373b941a1d11276" translate="yes" xml:space="preserve">
          <source>Some other values are treated specially for internal use and should not be depended on.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7424cd4ab88fb33b2270b2db7bbe8e04cad5739e" translate="yes" xml:space="preserve">
          <source>Some output formats that do allow rendering &quot;L&amp;lt;...&amp;gt;&quot; codes as hypertext, might not allow the link-text to be formatted; in that case, formatters will have to just ignore that formatting.</source>
          <target state="translated">&quot;L &amp;lt;...&amp;gt;&quot;코드를 하이퍼 텍스트로 렌더링 할 수있는 일부 출력 형식은 링크 텍스트의 형식을 허용하지 않을 수 있습니다. 이 경우 포맷터는 해당 포맷을 무시해야합니다.</target>
        </trans-unit>
        <trans-unit id="256ae5437abb579a53a890ac8a995ac8070fd714" translate="yes" xml:space="preserve">
          <source>Some particular limitations of note include:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7659015df8ed2f8e8d7c6aab66109d4919b25a40" translate="yes" xml:space="preserve">
          <source>Some particular sequences of characters are given a single name, in addition to their individual ones.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1a79a974eeb026992ad7b1bb5fab50968d6932c" translate="yes" xml:space="preserve">
          <source>Some passes discussed below are performed concurrently, but because their results are the same, we consider them individually. For different quoting constructs, Perl performs different numbers of passes, from one to four, but these passes are always performed in the same order.</source>
          <target state="translated">아래에 설명 된 일부 패스는 동시에 수행되지만 결과가 동일하기 때문에 개별적으로 고려합니다. 다른 인용 구조의 경우, Perl은 1에서 4까지 다른 수의 패스를 수행하지만 이러한 패스는 항상 동일한 순서로 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="7ae8fed66b51985370778e2e29c81e03a37d1f13" translate="yes" xml:space="preserve">
          <source>Some people get too used to writing things like:</source>
          <target state="translated">어떤 사람들은 다음과 같은 글을 쓰는 데 너무 익숙합니다.</target>
        </trans-unit>
        <trans-unit id="970ff42e05d0088fd549cac2a995425a1e1eba68" translate="yes" xml:space="preserve">
          <source>Some people have reported encountering &quot;Out of memory!&quot; errors while trying to build Perl using GNU make binaries. If you encounter such trouble then try to download the source code kit and build GNU make from source to eliminate any such trouble. You might also find GNU make (as well as Perl and Apache) in the red-piece/book &quot;Open Source Software for OS/390 UNIX&quot;, SG24-5944-00 from IBM.</source>
          <target state="translated">어떤 사람들은 &quot;메모리 부족!&quot; GNU make 바이너리를 사용하여 Perl을 빌드하는 중에 오류가 발생했습니다. 이러한 문제가 발생하면 소스 코드 키트를 다운로드하고 소스에서 GNU make를 빌드하여 이러한 문제를 해결하십시오. IBM의 레드 피스 / 책 &quot;OS / 390 UNIX 용 오픈 소스 소프트웨어&quot;, SG24-5944-00에서 GNU make (Perl 및 Apache)를 찾을 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="98c7c01703d39bcc6345fdf8d617292db8f23d37" translate="yes" xml:space="preserve">
          <source>Some people may be inclined to include an explicit &lt;code&gt;&lt;a href=&quot;functions/return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; in the above XSUB, rather than letting control fall through to the end. In those situations &lt;code&gt;XSRETURN_EMPTY&lt;/code&gt; should be used, instead. This will ensure that the XSUB stack is properly adjusted. Consult &lt;a href=&quot;perlapi&quot;&gt;perlapi&lt;/a&gt; for other &lt;code&gt;XSRETURN&lt;/code&gt; macros.</source>
          <target state="translated">어떤 사람들은 통제권을 끝까지 넘어 뜨리지 않고 위의 XSUB에 명시적인 &lt;code&gt;&lt;a href=&quot;functions/return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; 을 포함 시키려는 경향이있을 수 있습니다 . 이러한 상황에서는 대신 &lt;code&gt;XSRETURN_EMPTY&lt;/code&gt; 를 사용해야합니다. 이렇게하면 XSUB 스택이 올바르게 조정됩니다. 다른 &lt;code&gt;XSRETURN&lt;/code&gt; 매크로에 대해서는 &lt;a href=&quot;perlapi&quot;&gt;perlapi&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b6b8960b846f5085f978f5b96b85b0906849df57" translate="yes" xml:space="preserve">
          <source>Some people may be inclined to include an explicit &lt;code&gt;return&lt;/code&gt; in the above XSUB, rather than letting control fall through to the end. In those situations &lt;code&gt;XSRETURN_EMPTY&lt;/code&gt; should be used, instead. This will ensure that the XSUB stack is properly adjusted. Consult &lt;a href=&quot;perlapi&quot;&gt;perlapi&lt;/a&gt; for other &lt;code&gt;XSRETURN&lt;/code&gt; macros.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b055a6a001cadf9ec7b3e638f2bc15cb8ed85e4" translate="yes" xml:space="preserve">
          <source>Some people may wish to outlaw barewords entirely. If you say</source>
          <target state="translated">일부 사람들은 베어 워드를 완전히 금지하고 싶을 수도 있습니다. 당신이 말하는 경우</target>
        </trans-unit>
        <trans-unit id="bae38a7d38c5d89eb67db6e4b702e604142997e5" translate="yes" xml:space="preserve">
          <source>Some people mistakenly regard this as a security problem. If your program does insecure things, and relies on people not knowing how to exploit those insecurities, it is not secure. It is often possible for someone to determine the insecure things and exploit them without viewing the source. Security through obscurity, the name for hiding your bugs instead of fixing them, is little security indeed.</source>
          <target state="translated">어떤 사람들은 이것을 보안 문제로 잘못 간주합니다. 프로그램이 안전하지 않은 작업을 수행하고 해당 보안 문제를 악용하는 방법을 모르는 사람들에게 의존하는 경우 안전하지 않습니다. 누군가가 불안전 한 것을 결정하고 소스를 보지 않고 악용하는 것이 종종 가능합니다. 버그를 수정하는 대신 숨기는 이름 인 모호함을 통한 보안은 실제로 보안이 거의 없습니다.</target>
        </trans-unit>
        <trans-unit id="df10001a5e994bd1a3232bcb5d3f173424f0cd78" translate="yes" xml:space="preserve">
          <source>Some people need this and some people avoid it. For Perl, it&amp;rsquo;s an old way to say &lt;b&gt;I/O layer&lt;/b&gt;.</source>
          <target state="translated">어떤 사람들은 이것을 필요로하고 어떤 사람들은 그것을 피합니다. Perl의 경우 &lt;b&gt;I / O 레이어&lt;/b&gt; 를 말하는 오래된 방법 입니다.</target>
        </trans-unit>
        <trans-unit id="37ecbcdb1f8127ee6539d97d23e8c04d2e848681" translate="yes" xml:space="preserve">
          <source>Some people regard this as a security problem. If your program does insecure things and relies on people not knowing how to exploit those insecurities, it is not secure. It is often possible for someone to determine the insecure things and exploit them without viewing the source. Security through obscurity, the name for hiding your bugs instead of fixing them, is little security indeed.</source>
          <target state="translated">어떤 사람들은 이것을 보안 문제로 간주합니다. 프로그램이 안전하지 않은 작업을 수행하고 해당 보안 문제를 악용하는 방법을 모르는 사람들에게 의존하는 경우 안전하지 않습니다. 누군가가 불안전 한 것을 결정하고 소스를 보지 않고 악용하는 것이 종종 가능합니다. 버그를 수정하는 대신 숨기는 이름 인 모호함을 통한 보안은 실제로 보안이 거의 없습니다.</target>
        </trans-unit>
        <trans-unit id="646207c2365abd1daf6b5c56b0451ba2ee5e82de" translate="yes" xml:space="preserve">
          <source>Some platforms (Win32, AIX, VMS, OS/2, to name a few) require any function that is part of the public API (the shared Perl library) to be explicitly marked as exported. See the discussion about</source>
          <target state="translated">일부 플랫폼 (Win32, AIX, VMS, OS / 2)은 공개 API (공유 Perl 라이브러리)의 일부인 기능을 명시 적으로 익스포트 된 것으로 표시해야합니다. 에 대한 토론을 참조하십시오</target>
        </trans-unit>
        <trans-unit id="f71f7e49e6244b0a28baf7e54c8479e2d307382e" translate="yes" xml:space="preserve">
          <source>Some platforms can't delete or rename files held open by the system, this limitation may also apply to changing filesystem metainformation like file permissions or owners. Remember to &lt;a href=&quot;perlfunc#close-FILEHANDLE&quot;&gt;&lt;code&gt;close&lt;/code&gt;&lt;/a&gt; files when you are done with them. Don't &lt;a href=&quot;perlfunc#unlink-LIST&quot;&gt;&lt;code&gt;unlink&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;perlfunc#rename-OLDNAME%2CNEWNAME&quot;&gt;&lt;code&gt;rename&lt;/code&gt;&lt;/a&gt; an open file. Don't &lt;a href=&quot;perlfunc#tie-VARIABLE%2CCLASSNAME%2CLIST&quot;&gt;&lt;code&gt;tie&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;perlfunc#open-FILEHANDLE%2CMODE%2CEXPR&quot;&gt;&lt;code&gt;open&lt;/code&gt;&lt;/a&gt; a file already tied or opened; &lt;a href=&quot;perlfunc#untie-VARIABLE&quot;&gt;&lt;code&gt;untie&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;perlfunc#close-FILEHANDLE&quot;&gt;&lt;code&gt;close&lt;/code&gt;&lt;/a&gt; it first.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29e0751f43cf70fa1b809101e7e4735cf3d63955" translate="yes" xml:space="preserve">
          <source>Some platforms can't delete or rename files held open by the system, this limitation may also apply to changing filesystem metainformation like file permissions or owners. Remember to &lt;code&gt;&lt;a href=&quot;functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; files when you are done with them. Don't &lt;code&gt;&lt;a href=&quot;functions/unlink&quot;&gt;unlink&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/rename&quot;&gt;rename&lt;/a&gt;&lt;/code&gt; an open file. Don't &lt;code&gt;&lt;a href=&quot;functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; a file already tied or opened; &lt;code&gt;&lt;a href=&quot;functions/untie&quot;&gt;untie&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; it first.</source>
          <target state="translated">일부 플랫폼은 시스템에서 열린 파일을 삭제하거나 이름을 바꿀 수 없습니다.이 제한은 파일 권한 또는 소유자와 같은 파일 시스템 메타 정보 변경에도 적용될 수 있습니다. 작업이 끝나면 파일 을 &lt;code&gt;&lt;a href=&quot;functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; 합니다. 열린 파일을 &lt;code&gt;&lt;a href=&quot;functions/unlink&quot;&gt;unlink&lt;/a&gt;&lt;/code&gt; 하거나 &lt;code&gt;&lt;a href=&quot;functions/rename&quot;&gt;rename&lt;/a&gt;&lt;/code&gt; 마십시오 . 하지 마십시오 &lt;code&gt;&lt;a href=&quot;functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; 이미 연결 또는 열린 파일을; 먼저 &lt;code&gt;&lt;a href=&quot;functions/untie&quot;&gt;untie&lt;/a&gt;&lt;/code&gt; 거나 &lt;code&gt;&lt;a href=&quot;functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; 십시오.</target>
        </trans-unit>
        <trans-unit id="da26b78199e00ef73fdfb4bbe53a1032367ab8a7" translate="yes" xml:space="preserve">
          <source>Some platforms have a minimum thread stack size. Trying to set the stack size below this value will result in a warning, and the minimum stack size will be used.</source>
          <target state="translated">일부 플랫폼에는 최소 스레드 스택 크기가 있습니다. 스택 크기를이 값 아래로 설정하려고하면 경고가 발생하고 최소 스택 크기가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="bcf43713051466cf97d586bae0917d51d61ca30f" translate="yes" xml:space="preserve">
          <source>Some platforms have a minimum thread stack size. Trying to set the stack size below this value will result in the above warning, and the stack size will be set to the minimum.</source>
          <target state="translated">일부 플랫폼에는 최소 스레드 스택 크기가 있습니다. 스택 크기를이 값 아래로 설정하려고하면 위의 경고가 발생하고 스택 크기가 최소로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="5105a7088de9859cd20060f09ecf9b0528ad1069" translate="yes" xml:space="preserve">
          <source>Some platforms have other categories, dealing with such things as measurement units and paper sizes. None of these are used directly by Perl, but outside operations that Perl interacts with may use these. See &lt;a href=&quot;#Not-within-the-scope-of-%22use-locale%22&quot;&gt;&quot;Not within the scope of &quot;use locale&quot;&quot;&lt;/a&gt; below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a11c8787b6044982e680d4ae9bfff407819b6d1c" translate="yes" xml:space="preserve">
          <source>Some platforms have other categories, dealing with such things as measurement units and paper sizes. None of these are used directly by Perl, but outside operations that Perl interacts with may use these. See &lt;a href=&quot;#Not-within-the-scope-of-%22use-locale%22&quot;&gt;Not within the scope of use locale&lt;/a&gt; below.</source>
          <target state="translated">일부 플랫폼에는 측정 단위 및 용지 크기와 같은 항목을 처리하는 다른 범주가 있습니다. 이들 중 어느 것도 Perl에 의해 직접 사용되지는 않지만 Perl과 상호 작용하는 외부 조작에서이를 사용할 수 있습니다. 아래 &lt;a href=&quot;#Not-within-the-scope-of-%22use-locale%22&quot;&gt;의 사용 범위 내에 있지 않음을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="27d67098e269de48eafdad3480b3920c43ba2cb7" translate="yes" xml:space="preserve">
          <source>Some points to note:</source>
          <target state="translated">참고할 사항 :</target>
        </trans-unit>
        <trans-unit id="4d3653fc867e65c669e5c29b359dbebb9253c5c0" translate="yes" xml:space="preserve">
          <source>Some possible reasons: your inheritance is getting confused, you've misspelled the method name, or the object is of the wrong type. Check out &lt;a href=&quot;perlootut&quot;&gt;perlootut&lt;/a&gt; for details about any of the above cases. You may also use &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt; &lt;a href=&quot;functions/ref&quot;&gt;ref&lt;/a&gt;($object)&lt;/code&gt; to find out the class &lt;code&gt;$object&lt;/code&gt; was blessed into.</source>
          <target state="translated">몇 가지 가능한 이유 : 상속이 혼동되거나 메소드 이름의 철자가 틀리거나 오브젝트의 유형이 잘못되었습니다. 위의 경우에 대한 자세한 내용은 &lt;a href=&quot;perlootut&quot;&gt;perlootut&lt;/a&gt; 를 확인하십시오 . &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt; &lt;a href=&quot;functions/ref&quot;&gt;ref&lt;/a&gt;($object)&lt;/code&gt; 를 사용하여 &lt;code&gt;$object&lt;/code&gt; 가 축복받은 클래스를 찾을 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="290c6b9cea94cfe13fbb802d97a5a0cd78346837" translate="yes" xml:space="preserve">
          <source>Some possible reasons: your inheritance is getting confused, you've misspelled the method name, or the object is of the wrong type. Check out &lt;a href=&quot;perlootut&quot;&gt;perlootut&lt;/a&gt; for details about any of the above cases. You may also use &lt;code&gt;print ref($object)&lt;/code&gt; to find out the class &lt;code&gt;$object&lt;/code&gt; was blessed into.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b61ffed7b1a69179adefb6f5756bdb1cb79574b" translate="yes" xml:space="preserve">
          <source>Some pragmas are lexically scoped--typically those that affect the &lt;code&gt;$^H&lt;/code&gt; hints variable. Others affect the current package instead, like &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; vars&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; subs&lt;/code&gt; , which allow you to predeclare a variables or subroutines within a particular</source>
          <target state="translated">일부 pragma는 일반적으로 &lt;code&gt;$^H&lt;/code&gt; hints 변수에 영향을 미치는 어휘 범위 입니다. 처럼 다른 사람들은 대신 현재 패키지에 영향을주는 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; vars&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; subs&lt;/code&gt; 특정 내에서 변수 나 서브 루틴을 미리 선언 할 수 있도록,</target>
        </trans-unit>
        <trans-unit id="7d87d5053d095f39938496538e49008745b231d2" translate="yes" xml:space="preserve">
          <source>Some pragmas are lexically scoped--typically those that affect the &lt;code&gt;$^H&lt;/code&gt; hints variable. Others affect the current package instead, like &lt;code&gt;use vars&lt;/code&gt; and &lt;code&gt;use subs&lt;/code&gt;, which allow you to predeclare a variables or subroutines within a particular</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca977f551e014badc60a278bfe97ad872b1a03f5" translate="yes" xml:space="preserve">
          <source>Some problem (forget which ;-)</source>
          <target state="translated">어떤 문제 (어떤 ;-)를 잊어 버려</target>
        </trans-unit>
        <trans-unit id="747d0cb3f2eb2365d2dd72ee766a74de28620e7d" translate="yes" xml:space="preserve">
          <source>Some problems are associated with using temporary files that reside on NFS file systems and it is recommended that a local filesystem is used whenever possible. Some of the security tests will most probably fail when the temp file is not local. Additionally, be aware that the performance of I/O operations over NFS will not be as good as for a local disk.</source>
          <target state="translated">일부 문제는 NFS 파일 시스템에 상주하는 임시 파일 사용과 관련이 있으며 가능할 때마다 로컬 파일 시스템을 사용하는 것이 좋습니다. 임시 파일이 로컬이 아닌 경우 일부 보안 테스트가 실패 할 수 있습니다. 또한 NFS를 통한 I / O 작업의 성능은 로컬 디스크만큼 좋지 않습니다.</target>
        </trans-unit>
        <trans-unit id="82690c6e6b8e4e473e3f2745d7358e432662fc95" translate="yes" xml:space="preserve">
          <source>Some processors may find that the &lt;code&gt;S&amp;lt;...&amp;gt;&lt;/code&gt; code is easiest to implement by replacing each space in the parse tree under the content of the S, with an NBSP. But note: the replacement should apply</source>
          <target state="translated">일부 프로세서는 &lt;code&gt;S&amp;lt;...&amp;gt;&lt;/code&gt; 코드가 구문 분석 트리의 각 공간을 S의 컨텐츠 아래에있는 NBSP로 대체하여 구현하기가 가장 쉽다 는 것을 알 수 있습니다 . 그러나 참고 : 교체가 적용되어야합니다</target>
        </trans-unit>
        <trans-unit id="229ed6abc320881bbd15c4ddf8619bff82e22293" translate="yes" xml:space="preserve">
          <source>Some programmers choose to use an explicit conversion so as to leave nothing to doubt:</source>
          <target state="translated">일부 프로그래머는 의심 할 여지가 없도록 명시 적 변환을 사용하도록 선택합니다.</target>
        </trans-unit>
        <trans-unit id="76cff92347a8a5dd33b0b88b52afc87676bbe1d1" translate="yes" xml:space="preserve">
          <source>Some programmers may prefer to think of filehandles as objects with methods, preferring to write the last example as:</source>
          <target state="translated">일부 프로그래머는 파일 핸들을 메소드가있는 객체로 생각하고 마지막 예제를 다음과 같이 작성하는 것을 선호합니다.</target>
        </trans-unit>
        <trans-unit id="9293db7d23e9765c2433258535b9e48d3fd5d563" translate="yes" xml:space="preserve">
          <source>Some properties are considered obsolete by Unicode, but still available. There are several varieties of obsolescence:</source>
          <target state="translated">일부 속성은 유니 코드에서 사용되지 않는 것으로 간주되지만 여전히 사용 가능합니다. 몇 가지 종류의 더 이상 사용되지 않는 기능이 있습니다.</target>
        </trans-unit>
        <trans-unit id="8e185e2d007b85b8d377436c39a0c68b4b4f4ab1" translate="yes" xml:space="preserve">
          <source>Some rare applications will need to create more than one interpreter during a session. Such an application might sporadically decide to release any resources associated with the interpreter.</source>
          <target state="translated">일부 드문 응용 프로그램은 세션 중에 둘 이상의 인터프리터를 작성해야합니다. 그러한 응용 프로그램은 산발적으로 해석기와 관련된 모든 자원을 해제하기로 결정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0314a7222da4e53e09e85e4d4942b044d7cacfc9" translate="yes" xml:space="preserve">
          <source>Some regular expressions use identical subpatterns in several places. Starting with Perl 5.10, it is possible to define named subpatterns in a section of the pattern so that they can be called up by name anywhere in the pattern. This syntactic pattern for this definition group is &lt;code&gt;(?(DEFINE)(?&amp;lt;&lt;i&gt;name&lt;/i&gt;&amp;gt;&lt;i&gt;pattern&lt;/i&gt;)...)&lt;/code&gt;. An insertion of a named pattern is written as &lt;code&gt;(?&amp;amp;&lt;i&gt;name&lt;/i&gt;)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c5ce3e6e9260f74f3afe8318024d986a7fd16de" translate="yes" xml:space="preserve">
          <source>Some regular expressions use identical subpatterns in several places. Starting with Perl 5.10, it is possible to define named subpatterns in a section of the pattern so that they can be called up by name anywhere in the pattern. This syntactic pattern for this definition group is &lt;code&gt;(?(DEFINE)(?&amp;lt;name&amp;gt;pattern)...)&lt;/code&gt;. An insertion of a named pattern is written as &lt;code&gt;(?&amp;amp;name)&lt;/code&gt;.</source>
          <target state="translated">일부 정규식은 여러 곳에서 동일한 하위 패턴을 사용합니다. Perl 5.10부터는 패턴의 섹션에서 이름 지정된 서브 패턴을 정의하여 패턴의 어느 곳에서나 이름으로 호출 할 수 있습니다. 이 정의 그룹의 구문 패턴은 &lt;code&gt;(?(DEFINE)(?&amp;lt;name&amp;gt;pattern)...)&lt;/code&gt; 입니다. 명명 된 패턴의 삽입은 &lt;code&gt;(?&amp;amp;name)&lt;/code&gt; 으로 작성됩니다 .</target>
        </trans-unit>
        <trans-unit id="58899e8b736f7c4726449bcec0f3b25df5fc7632" translate="yes" xml:space="preserve">
          <source>Some routines (&lt;code&gt;is_odd()&lt;/code&gt; , &lt;code&gt;is_even()&lt;/code&gt; , &lt;code&gt;is_zero()&lt;/code&gt; , &lt;code&gt;is_one()&lt;/code&gt; , &lt;code&gt;is_nan()&lt;/code&gt; ) return true or false, while others (&lt;code&gt;bcmp()&lt;/code&gt; , &lt;code&gt;bacmp()&lt;/code&gt; ) return either undef, &amp;lt;0, 0 or &amp;gt;0 and are suited for sort.</source>
          <target state="translated">일부 루틴 ( &lt;code&gt;is_odd()&lt;/code&gt; , &lt;code&gt;is_even()&lt;/code&gt; , &lt;code&gt;is_zero()&lt;/code&gt; , &lt;code&gt;is_one()&lt;/code&gt; , &lt;code&gt;is_nan()&lt;/code&gt; )은 true 또는 false를 반환하고 다른 &lt;code&gt;bacmp()&lt;/code&gt; &lt;code&gt;bcmp()&lt;/code&gt; , bacmp () )은 undef, &amp;lt;0, 0 또는&amp;gt; 0을 반환합니다. 그리고 정렬에 적합합니다.</target>
        </trans-unit>
        <trans-unit id="834cc437cec84afae22c004e80ee3d6149cb6f55" translate="yes" xml:space="preserve">
          <source>Some routines (&lt;code&gt;is_odd()&lt;/code&gt; , &lt;code&gt;is_even()&lt;/code&gt; , &lt;code&gt;is_zero()&lt;/code&gt; , &lt;code&gt;is_one()&lt;/code&gt; , &lt;code&gt;is_nan()&lt;/code&gt; , etc.) return true or false, while others (&lt;code&gt;bcmp()&lt;/code&gt; , &lt;code&gt;bacmp()&lt;/code&gt; ) return either undef (if NaN is involved), &amp;lt;0, 0 or &amp;gt;0 and are suited for sort.</source>
          <target state="translated">일부 루틴 ( &lt;code&gt;is_odd()&lt;/code&gt; , &lt;code&gt;is_even()&lt;/code&gt; , &lt;code&gt;is_zero()&lt;/code&gt; , &lt;code&gt;is_one()&lt;/code&gt; , &lt;code&gt;is_nan()&lt;/code&gt; 등)은 true 또는 false를 반환하고 다른 &lt;code&gt;bacmp()&lt;/code&gt; &lt;code&gt;bcmp()&lt;/code&gt; , bacmp () )은 undef를 반환합니다 (NaN이 관련된 경우) ), &amp;lt;0, 0 또는&amp;gt; 0이며 정렬에 적합합니다.</target>
        </trans-unit>
        <trans-unit id="b07ef2379b9c2b49ab7fe4b04878c3104f0be76f" translate="yes" xml:space="preserve">
          <source>Some scalar variables contain more than one type of scalar data. For example, the variable &lt;code&gt;$!&lt;/code&gt; contains either the numeric value of &lt;code&gt;errno&lt;/code&gt; or its string equivalent from either &lt;code&gt;strerror&lt;/code&gt; or &lt;code&gt;sys_errlist[]&lt;/code&gt; .</source>
          <target state="translated">일부 스칼라 변수에는 여러 유형의 스칼라 데이터가 포함됩니다. 예를 들어 변수 &lt;code&gt;$!&lt;/code&gt; &lt;code&gt;errno&lt;/code&gt; 의 숫자 값 또는 &lt;code&gt;strerror&lt;/code&gt; 또는 &lt;code&gt;sys_errlist[]&lt;/code&gt; 와 동등한 문자열을 포함합니다 .</target>
        </trans-unit>
        <trans-unit id="293877a0e77da8a8b9fbcbcd030c4833f67c96da" translate="yes" xml:space="preserve">
          <source>Some scalar variables contain more than one type of scalar data. For example, the variable &lt;code&gt;$!&lt;/code&gt; contains either the numeric value of &lt;code&gt;errno&lt;/code&gt; or its string equivalent from either &lt;code&gt;strerror&lt;/code&gt; or &lt;code&gt;sys_errlist[]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b802bf6a4f1848df9acbe46a4e2a4fe02ad51578" translate="yes" xml:space="preserve">
          <source>Some scripts, usually identified with a *.PL extension, are self-configuring and are able to correctly create their own shebang path from config information located in Plan 9 Perl. These you won't need to be worried about.</source>
          <target state="translated">일반적으로 * .PL 확장자로 식별되는 일부 스크립트는 자체 구성되며 Plan 9 Perl에있는 구성 정보에서 자체 Shebang 경로를 올바르게 작성할 수 있습니다. 이것들은 당신이 걱정할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="0de1611bc5300339bfc467a34c6fb8f9747fd7ed" translate="yes" xml:space="preserve">
          <source>Some servers are configured to only work in passive mode. If you have one of these you can force &lt;code&gt;Net::FTP&lt;/code&gt; to always transfer in passive mode; when not going via a firewall, by setting &lt;code&gt;ftp_int_passive&lt;/code&gt; to a</source>
          <target state="translated">일부 서버는 수동 모드에서만 작동하도록 구성되어 있습니다. 이 중 하나가 있으면 &lt;code&gt;Net::FTP&lt;/code&gt; 가 항상 수동 모드로 전송되도록 할 수 있습니다 . 방화벽을 통하지 않을 때 &lt;code&gt;ftp_int_passive&lt;/code&gt; 를</target>
        </trans-unit>
        <trans-unit id="ebc3655c5b01cc226f09d2ace7c8e5f430f35ebd" translate="yes" xml:space="preserve">
          <source>Some servers do not understand this command, but issuing it and ignoring the response is harmless.</source>
          <target state="translated">일부 서버는이 명령을 이해하지 못하지만 명령을 실행하고 응답을 무시하는 것은 무해합니다.</target>
        </trans-unit>
        <trans-unit id="c3d7fb888727f4ae5ed3bb068213cd5f194d2bf2" translate="yes" xml:space="preserve">
          <source>Some signals can be neither trapped nor ignored, such as the KILL and STOP (but not the TSTP) signals. Note that ignoring signals makes them disappear. If you only want them blocked temporarily without them getting lost you'll have to use POSIX' sigprocmask.</source>
          <target state="translated">KILL 및 STOP (TSTP는 아님) 신호와 같은 일부 신호는 트랩되거나 무시 될 수 없습니다. 신호를 무시하면 사라집니다. 분실하지 않고 일시적으로 만 차단하려면 POSIX의 sigprocmask를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="2b6d2a03109d9cfeb6b788931c3af13636a6e9ce" translate="yes" xml:space="preserve">
          <source>Some signals can be neither trapped nor ignored, such as the KILL and STOP (but not the TSTP) signals. Note that ignoring signals makes them disappear. If you only want them blocked temporarily without them getting lost you'll have to use the &lt;code&gt;POSIX&lt;/code&gt; module's &lt;a href=&quot;posix#sigprocmask&quot;&gt;sigprocmask&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2bcba60d06f3c08a852e1ccedb100d4bd2f6af23" translate="yes" xml:space="preserve">
          <source>Some simple style guidelines</source>
          <target state="translated">간단한 스타일 가이드 라인</target>
        </trans-unit>
        <trans-unit id="0a3063c3a46746b861b03ccbf2777db3ca544d44" translate="yes" xml:space="preserve">
          <source>Some simple tricks for determining if you are running on an EBCDIC platform could include any of the following (perhaps all):</source>
          <target state="translated">EBCDIC 플랫폼에서 실행 중인지 확인하기위한 몇 가지 간단한 트릭에는 다음 중 하나가 포함될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3f3c0a1f0f425bdd141982a9f345d9ad53284159" translate="yes" xml:space="preserve">
          <source>Some source filters use the &lt;code&gt;DATA&lt;/code&gt; handle to read the calling program. When using these source filters you cannot rely on this handle, nor expect any particular kind of behavior when operating on it. Filters based on Filter::Util::Call (and therefore Filter::Simple) do not alter the &lt;code&gt;DATA&lt;/code&gt; filehandle, but on the other hand totally ignore the text after &lt;code&gt;__DATA__&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="038ab8e08e45dcac2b1a2ba44edc5e7ade978952" translate="yes" xml:space="preserve">
          <source>Some source filters use the &lt;code&gt;DATA&lt;/code&gt; handle to read the calling program. When using these source filters you cannot rely on this handle, nor expect any particular kind of behavior when operating on it. Filters based on Filter::Util::Call (and therefore Filter::Simple) do not alter the &lt;code&gt;DATA&lt;/code&gt; filehandle.</source>
          <target state="translated">일부 소스 필터는 &lt;code&gt;DATA&lt;/code&gt; 핸들을 사용 하여 호출 프로그램을 읽습니다. 이러한 소스 필터를 사용할 때이 핸들에 의존하거나 작동 할 때 특정 종류의 동작을 기대할 수 없습니다. Filter :: Util :: Call 기반 필터 (따라서 Filter :: Simple)는 &lt;code&gt;DATA&lt;/code&gt; 파일 핸들을 변경하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="b1b44415edca47e18840114c042b3fbafad7d31e" translate="yes" xml:space="preserve">
          <source>Some special cases like a trailing 0x00 byte or a lone 0x1B byte are not well-defined and decode() will return an empty string for them. One possible workaround is</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="887e76ddfe1351446ffd243bda2aac92d02dd5a3" translate="yes" xml:space="preserve">
          <source>Some subclasses that indiscriminately dump event attributes (well, except for ones beginning with &quot;~&quot;) can use this object attribute for refraining to dump the &quot;start_line&quot; attribute.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0397fafffa0394e8352d14b65804f0f4b7e0e7f0" translate="yes" xml:space="preserve">
          <source>Some switches do care if they are processed twice, for instance combinations of &lt;a href=&quot;#-l%5Boctnum%5D&quot;&gt;-l&lt;/a&gt; and &lt;a href=&quot;#-0%5Boctal%2Fhexadecimal%5D&quot;&gt;-0&lt;/a&gt;. Either put all the switches after the 32-character boundary (if applicable), or replace the use of &lt;b&gt;-0&lt;/b&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b3ebd295e43b2c81df8bd4b9c3baef266ee5f66" translate="yes" xml:space="preserve">
          <source>Some switches do care if they are processed twice, for instance combinations of &lt;b&gt;-l&lt;/b&gt; and &lt;b&gt;-0&lt;/b&gt;. Either put all the switches after the 32-character boundary (if applicable), or replace the use of &lt;b&gt;-0&lt;/b&gt;</source>
          <target state="translated">일부 스위치는 스위치가 두 번 처리되는지 (예 : &lt;b&gt;-l&lt;/b&gt; 및 &lt;b&gt;-0&lt;/b&gt; 조합)주의합니다 . 모든 스위치를 32 자 경계 뒤에 넣거나 (해당되는 경우) &lt;b&gt;-0을&lt;/b&gt; 대신 사용하십시오.&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="109f18c999c7939dc43da5678ce045bdc21c20e9" translate="yes" xml:space="preserve">
          <source>Some systems define &lt;a href=&quot;#pipe-READHANDLE%2CWRITEHANDLE&quot;&gt;&lt;code&gt;pipe&lt;/code&gt;&lt;/a&gt; in terms of &lt;a href=&quot;#socketpair-SOCKET1%2CSOCKET2%2CDOMAIN%2CTYPE%2CPROTOCOL&quot;&gt;&lt;code&gt;socketpair&lt;/code&gt;&lt;/a&gt;, in which a call to &lt;code&gt;pipe($rdr, $wtr)&lt;/code&gt; is essentially:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c346e3627bcf4ba52fad903600add2510035afb4" translate="yes" xml:space="preserve">
          <source>Some systems defined &lt;code&gt;&lt;a href=&quot;functions/pipe&quot;&gt;pipe&lt;/a&gt;&lt;/code&gt; in terms of &lt;code&gt;&lt;a href=&quot;functions/socketpair&quot;&gt;socketpair&lt;/a&gt;&lt;/code&gt;, in which a call to &lt;code&gt;&lt;a href=&quot;functions/pipe&quot;&gt;pipe&lt;/a&gt;(Rdr, Wtr)&lt;/code&gt; is essentially:</source>
          <target state="translated">정의 된 일부 시스템 &lt;code&gt;&lt;a href=&quot;functions/pipe&quot;&gt;pipe&lt;/a&gt;&lt;/code&gt; 의 측면에서 &lt;code&gt;&lt;a href=&quot;functions/socketpair&quot;&gt;socketpair&lt;/a&gt;&lt;/code&gt; 의 를 호출하는, &lt;code&gt;&lt;a href=&quot;functions/pipe&quot;&gt;pipe&lt;/a&gt;(Rdr, Wtr)&lt;/code&gt; 본질적으로 :</target>
        </trans-unit>
        <trans-unit id="6fc6b04b810684b6c41fe63810499cab8b09c739" translate="yes" xml:space="preserve">
          <source>Some systems defined &lt;code&gt;&lt;a href=&quot;pipe&quot;&gt;pipe&lt;/a&gt;&lt;/code&gt; in terms of &lt;code&gt;&lt;a href=&quot;socketpair&quot;&gt;socketpair&lt;/a&gt;&lt;/code&gt;, in which a call to &lt;code&gt;&lt;a href=&quot;pipe&quot;&gt;pipe&lt;/a&gt;(Rdr, Wtr)&lt;/code&gt; is essentially:</source>
          <target state="translated">정의 된 일부 시스템 &lt;code&gt;&lt;a href=&quot;pipe&quot;&gt;pipe&lt;/a&gt;&lt;/code&gt; 의 측면에서 &lt;code&gt;&lt;a href=&quot;socketpair&quot;&gt;socketpair&lt;/a&gt;&lt;/code&gt; 의 를 호출하는, &lt;code&gt;&lt;a href=&quot;pipe&quot;&gt;pipe&lt;/a&gt;(Rdr, Wtr)&lt;/code&gt; 본질적으로 :</target>
        </trans-unit>
        <trans-unit id="ec2cddcb7714cb3145808dbf1959d4cf532d708d" translate="yes" xml:space="preserve">
          <source>Some systems have APIs but not implementations: for example QNX and Haiku have the interval timer APIs but not the functionality.</source>
          <target state="translated">일부 시스템에는 API가 있지만 구현은 없습니다. 예를 들어 QNX 및 Haiku에는 간격 타이머 API가 있지만 기능은 없습니다.</target>
        </trans-unit>
        <trans-unit id="af9e4e7dc8e2d766a51ba5d183c159f4967112d1" translate="yes" xml:space="preserve">
          <source>Some systems have thread-safe versions of some of the functions, such as &lt;code&gt;getpwnam_r()&lt;/code&gt; instead of &lt;code&gt;getpwnam()&lt;/code&gt;. There, Perl automatically and invisibly substitutes the thread-safe version, without notice. This means that code that safely runs on some systems can fail on others that lack the thread-safe versions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f1b5dcc57517fdbe334dfa953d44b8287e96b48c" translate="yes" xml:space="preserve">
          <source>Some systems may have even weirder byte orders such as</source>
          <target state="translated">일부 시스템은 다음과 같은 이상한 바이트 순서를 가질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6223cb44b81823af78522ece7689e7171de5236a" translate="yes" xml:space="preserve">
          <source>Some systems use CONFORMING TO to note conformance to relevant standards and MT-LEVEL to note safeness for use in threaded programs or signal handlers. These headings are primarily useful when documenting parts of a C library.</source>
          <target state="translated">일부 시스템은 CONFORMING TO를 사용하여 관련 표준을 준수하고 MT-LEVEL을 사용하여 스레드 프로그램 또는 신호 처리기에 사용하기위한 안전성을 기록합니다. 이 제목은 주로 C 라이브러리의 일부를 문서화 할 때 유용합니다.</target>
        </trans-unit>
        <trans-unit id="b5f78f639815d7596cee6bf607be57c18273af36" translate="yes" xml:space="preserve">
          <source>Some test failures may occur if you use a command shell other than the native &quot;cmd.exe&quot;, or if you are building from a path that contains spaces. So don't do that.</source>
          <target state="translated">기본 &quot;cmd.exe&quot;이외의 명령 셸을 사용하거나 공백이 포함 된 경로에서 빌드하는 경우 일부 테스트 실패가 발생할 수 있습니다. 그러지 마</target>
        </trans-unit>
        <trans-unit id="db2f4892c2d72b4b87094017ed92e99d93095f9c" translate="yes" xml:space="preserve">
          <source>Some test modules would replace the Test::Builder singleton instance with their own instance or subclass. This was usually done to intercept or modify results as they happened.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec70ba84fc671de1bea2095d64f0ecee13115e62" translate="yes" xml:space="preserve">
          <source>Some tests are known to fail:</source>
          <target state="translated">일부 테스트는 실패한 것으로 알려져 있습니다.</target>
        </trans-unit>
        <trans-unit id="6a89cc5c4b8e960cca98e5c9aef6613a37510494" translate="yes" xml:space="preserve">
          <source>Some tests depended on &lt;code&gt;$!&lt;/code&gt; and &lt;code&gt;$?&lt;/code&gt; being modified in subtle ways. A patch was applied to correct things that changed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75d98556687379d0793051b330180895e416a427" translate="yes" xml:space="preserve">
          <source>Some tests may complain under known circumstances.</source>
          <target state="translated">일부 테스트는 알려진 상황에서 불만을 제기 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c1340d9e04d7bf928c677a3bd6e8e8121f7021a3" translate="yes" xml:space="preserve">
          <source>Some tests may generate extra messages similar to</source>
          <target state="translated">일부 테스트는 다음과 유사한 추가 메시지를 생성 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="ed680f9db7c37de4a3fb02472a48fb5b299c3b28" translate="yes" xml:space="preserve">
          <source>Some tests were fragile and required base.pm to be loaded at a late stage. Test2 was loading base.pm too early. The tests were updated to fix this.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d3e7fb048dd3da6c3efee2236b9f7245e42c776" translate="yes" xml:space="preserve">
          <source>Some tests were fragile, but have been fixed. The actual breakage was from the subtest comment indentation change.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81c36c454152688ffa8f0d5944c5eae241cf584a" translate="yes" xml:space="preserve">
          <source>Some tests will be skipped because they need the fork() function:</source>
          <target state="translated">fork () 함수가 필요하기 때문에 일부 테스트는 건너 뜁니다.</target>
        </trans-unit>
        <trans-unit id="ae4dfb05b376af0b4aa8499ceeb5ad1587cfc612" translate="yes" xml:space="preserve">
          <source>Some things might not work as you expect them. Below is documented what is known to be troublesome:</source>
          <target state="translated">예상대로 작동하지 않을 수 있습니다. 아래는 성가신 것으로 알려진 문서입니다.</target>
        </trans-unit>
        <trans-unit id="c22086010db6828bca64b97b121f052c5aaeaeec" translate="yes" xml:space="preserve">
          <source>Some time ago I had reports it does not work. Nowadays it is checked in the Perl test suite, so grep</source>
          <target state="translated">얼마 전에 나는 작동하지 않는다고보고했다. 요즘에는 Perl 테스트 스위트에서 확인되므로 grep</target>
        </trans-unit>
        <trans-unit id="ff04f69dfe09fd05da827bf89d221c2f8cd81859" translate="yes" xml:space="preserve">
          <source>Some tools did do a good job setting these to the correct hub, but you cannot always rely on that. Use the 'hubs' facet list instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2d4257cf6ff6a8e43bd3c5319c1718bd7fb9ab6" translate="yes" xml:space="preserve">
          <source>Some type of removable media other than a floppy diskette.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="729fe9bb5c1721be7b9c47b47d38d0043a1d5be9" translate="yes" xml:space="preserve">
          <source>Some types of lvalues can be localized as well: hash and array elements and slices, conditionals (provided that their result is always localizable), and symbolic references. As for simple variables, this creates new, dynamically scoped values.</source>
          <target state="translated">해시 및 배열 요소와 슬라이스, 조건부 (결과가 항상 지역화 가능한 경우) 및 기호 참조와 같은 일부 유형의 lvalue도 현지화 할 수 있습니다. 간단한 변수에 관해서는 동적으로 범위가 지정된 새로운 값을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="36c279e82d37aef763f2dc425df33d302f2edc2c" translate="yes" xml:space="preserve">
          <source>Some unusual systems, such as VMS, require special filename handling in order to deal with symbolic names for files (i.e., VMS's Logical Names).</source>
          <target state="translated">VMS와 같은 일부 비정상적인 시스템은 파일의 기호 이름 (예 : VMS의 논리 이름)을 처리하기 위해 특별한 파일 이름 처리가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="6a39214b093577878080cd0246589b3e208ffeb5" translate="yes" xml:space="preserve">
          <source>Some user's however may feel that the above &quot;economy of expression&quot; is not particularly readable nor consistent and may instead choose to do something more like the following:</source>
          <target state="translated">그러나 일부 사용자는 위의 &quot;표현의 경제&quot;가 특별히 읽거나 일관성이 없으며 대신 다음과 같은 작업을 수행하도록 선택할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1ad295080cd8e985d193a33706aa64c82df7132f" translate="yes" xml:space="preserve">
          <source>Some users have expressed that they think this whole mechanism of having a &quot;fail&quot; attribute at all, seems a rather pointless complication. But I want Locale::Maketext to be usable for software projects of</source>
          <target state="translated">일부 사용자는 &quot;실패&quot;속성을 갖는이 전체 메커니즘이 전혀 무의미한 합병증으로 생각된다고 표현했습니다. 그러나 Locale :: Maketext를 다음과 같은 소프트웨어 프로젝트에 사용할 수 있기를 원합니다.</target>
        </trans-unit>
        <trans-unit id="7ab6d61e44a0f4b38225b697b64d41eb4c216b63" translate="yes" xml:space="preserve">
          <source>Some users may wish to encourage the use of lexically scoped variables. As an aid to catching implicit uses to package variables, which are always global, if you say</source>
          <target state="translated">일부 사용자는 어휘 범위 변수 사용을 권장 할 수 있습니다. 말할 때 항상 전역적인 변수를 패키징하는 암시 적 용도를 잡는 데 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="020ce1178f605ac1782ec8459fa4fa7fd0cf745e" translate="yes" xml:space="preserve">
          <source>Some versions of &lt;code&gt;DB_File&lt;/code&gt; won't let you store data under a key of length 0. That means that if you have a function &lt;code&gt;f&lt;/code&gt; which you memoized and the cache is in a &lt;code&gt;DB_File&lt;/code&gt; database, then the value of &lt;code&gt;f()&lt;/code&gt; (&lt;code&gt;f&lt;/code&gt; called with no arguments) will not be memoized. If this is a big problem, you can supply a normalizer function that prepends &lt;code&gt;&quot;x&quot;&lt;/code&gt; to every key.</source>
          <target state="translated">일부 버전의 &lt;code&gt;DB_File&lt;/code&gt; 을 사용 하면 길이가 0 인 키에 데이터를 저장할 수 없습니다. 즉 , &lt;code&gt;DB_File&lt;/code&gt; 한 함수 &lt;code&gt;f&lt;/code&gt; 가 있고 캐시가 DB_File 데이터베이스에 있으면 &lt;code&gt;f()&lt;/code&gt; 의 값 ( &lt;code&gt;f&lt;/code&gt; 는 인수 없음)이 메모되지 않습니다. 이것이 큰 문제인 경우 모든 키 앞에 &lt;code&gt;&quot;x&quot;&lt;/code&gt; 를 추가하는 노멀 라이저 기능을 제공 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8bb4498f94e563a623dff663cd55b4fc862752c4" translate="yes" xml:space="preserve">
          <source>Some versions of &lt;code&gt;make&lt;/code&gt; set the variable &lt;code&gt;MAKE&lt;/code&gt; . Others do not. This variable contains the string to be included in</source>
          <target state="translated">일부 버전의 &lt;code&gt;make&lt;/code&gt; 는 변수를 설정합니다 &lt;code&gt;MAKE&lt;/code&gt; 를 . 다른 사람들은 그렇지 않습니다. 이 변수는 포함 할 문자열을 포함합니다</target>
        </trans-unit>
        <trans-unit id="fd2f9dd996c82ce27f9d189fd038a8b3dc2b29cb" translate="yes" xml:space="preserve">
          <source>Some versions of &lt;code&gt;make&lt;/code&gt; set the variable &lt;code&gt;MAKE&lt;/code&gt;. Others do not. This variable contains the string to be included in</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="954f7aeec06323e12a6983f37a0846eca84625d3" translate="yes" xml:space="preserve">
          <source>Some versions of flock() can't lock files over a network (e.g. on NFS file systems), so you'd need to force the use of fcntl(2) when you build Perl. But even this is dubious at best. See the flock entry of &lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt; and the</source>
          <target state="translated">일부 버전의 flock ()은 네트워크 (예 : NFS 파일 시스템)를 통해 파일을 잠글 수 없으므로 Perl을 빌드 할 때 fcntl (2)을 강제로 사용해야합니다. 그러나 이것조차도 모호합니다. 의 무리 항목을 참조하십시오&lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt; 및</target>
        </trans-unit>
        <trans-unit id="dd60cc6568aba712fcca69343c88a2420637338a" translate="yes" xml:space="preserve">
          <source>Some, but not all, UTF-8 malformations are detected, and in fact, some malformed input could cause reading beyond the end of the input buffer, which is one reason why this function is deprecated. The other is that only in extremely limited circumstances should the Unicode versus native code point be of any interest to you. See &lt;a href=&quot;#utf8_to_uvuni_buf&quot;&gt;&quot;utf8_to_uvuni_buf&quot;&lt;/a&gt; for alternatives.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d311518a6bb3b8613076ce871f73cf8cb1a1e05f" translate="yes" xml:space="preserve">
          <source>Some, but not all, UTF-8 malformations are detected, and in fact, some malformed input could cause reading beyond the end of the input buffer, which is one reason why this function is deprecated. The other is that only in extremely limited circumstances should the Unicode versus native code point be of any interest to you. See &lt;a href=&quot;#utf8_to_uvuni_buf&quot;&gt;utf8_to_uvuni_buf&lt;/a&gt; for alternatives.</source>
          <target state="translated">전부는 아니지만 일부 UTF-8 기형이 감지되고 실제로 일부 기형의 입력이 입력 버퍼의 끝을 넘어 판독을 유발할 수 있으므로이 기능이 더 이상 사용되지 않습니다. 다른 하나는 극도로 제한된 상황에서만 유니 코드와 네이티브 코드 포인트가 관심을 가져야한다는 것입니다. 대안 은 &lt;a href=&quot;#utf8_to_uvuni_buf&quot;&gt;utf8_to_uvuni_buf&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f0f7251754bf0f46339bfaca2d9d1483409569f4" translate="yes" xml:space="preserve">
          <source>Some, but not all, UTF-8 malformations are detected, and in fact, some malformed input could cause reading beyond the end of the input buffer, which is why this function is deprecated. Use &lt;a href=&quot;#utf8_to_uvchr_buf&quot;&gt;&quot;utf8_to_uvchr_buf&quot;&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2fc9641c97ef26419e8b09582d42e0230f643449" translate="yes" xml:space="preserve">
          <source>Some, but not all, UTF-8 malformations are detected, and in fact, some malformed input could cause reading beyond the end of the input buffer, which is why this function is deprecated. Use &lt;a href=&quot;#utf8_to_uvchr_buf&quot;&gt;utf8_to_uvchr_buf&lt;/a&gt; instead.</source>
          <target state="translated">전부는 아니지만 일부 UTF-8 기형이 감지되며 실제로 기형이 잘못된 일부 입력은 입력 버퍼의 끝을 넘어 판독을 유발할 수 있으므로이 기능은 더 이상 사용되지 않습니다. &lt;a href=&quot;#utf8_to_uvchr_buf&quot;&gt;utf8_to_uvchr_buf&lt;/a&gt; 사용대신 를 .</target>
        </trans-unit>
        <trans-unit id="d5b99daee126bc167396885e5a173ca7e1b5727f" translate="yes" xml:space="preserve">
          <source>Some, such as &lt;code&gt;&lt;a href=&quot;functions/chown&quot;&gt;chown&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/umask&quot;&gt;umask&lt;/a&gt;&lt;/code&gt; aren't provided because the concept does not exist within Plan 9. Others, such as some of the socket-related functions, simply haven't been written yet. Many in the latter category may be supported in the future.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/chown&quot;&gt;chown&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;functions/umask&quot;&gt;umask&lt;/a&gt;&lt;/code&gt; 와 같은 일부 는 개념이 Plan 9에 없기 때문에 제공되지 않습니다. 소켓 관련 기능과 같은 일부는 아직 작성되지 않았습니다. 후자 범주의 많은 사람들이 앞으로 지원 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="63c9382b076dd9dd8161d9b49e86f36c6b0988c1" translate="yes" xml:space="preserve">
          <source>Some, such as &lt;code&gt;chown&lt;/code&gt; and &lt;code&gt;umask&lt;/code&gt; aren't provided because the concept does not exist within Plan 9. Others, such as some of the socket-related functions, simply haven't been written yet. Many in the latter category may be supported in the future.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b529d1f2a1daeac288a5dc3e3f1ad071820c7a2" translate="yes" xml:space="preserve">
          <source>Some/Module.pm</source>
          <target state="translated">Some/Module.pm</target>
        </trans-unit>
        <trans-unit id="75f6f0269318d3e6d862e35e227cdb78f8aa0076" translate="yes" xml:space="preserve">
          <source>Someone like Larry, or one of his peculiar friends. Also refers to the strange prefixes that Perl requires as noun markers on its variables.</source>
          <target state="translated">래리와 같은 누군가 또는 그의 독특한 친구 중 한 사람. 또한 Perl이 변수에 명사 마커로 요구하는 이상한 접두사를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="4645c18015bf5520c386fecd9f2627c0f851f491" translate="yes" xml:space="preserve">
          <source>Someone who &amp;ldquo;carries&amp;rdquo; software from one &lt;b&gt;platform&lt;/b&gt; to another. Porting programs written in platform-dependent languages such as C can be difficult work, but porting programs like Perl is very much worth the agony.</source>
          <target state="translated">하나의 &lt;b&gt;플랫폼&lt;/b&gt; 에서 소프트웨어를 &quot;운반&quot;하는 사람&lt;b&gt;&lt;/b&gt; 에서 다른 으로 하는 사람. C와 같은 플랫폼 종속 언어로 작성된 포팅 프로그램은 어려울 수 있지만 Perl과 같은 포팅 프로그램은 매우 가치가 있습니다.</target>
        </trans-unit>
        <trans-unit id="81901ca358030c454d79961747b435397961631e" translate="yes" xml:space="preserve">
          <source>Someone who breaks security on computer systems. A cracker may be a true &lt;b&gt;hacker&lt;/b&gt; or only a &lt;b&gt;script kiddie&lt;/b&gt;.</source>
          <target state="translated">컴퓨터 시스템의 보안을 깨는 사람. 크래커는 사실 일 수 있습니다 &lt;b&gt;해커&lt;/b&gt; 또는 단지 &lt;b&gt;스크립트 키디&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="1964ccb6039dfc22b78b8e0d35db2a914eb047cc" translate="yes" xml:space="preserve">
          <source>Someone who is brilliantly persistent in solving technical problems, whether these involve golfing, fighting orcs, or programming. Hacker is a neutral term, morally speaking. Good hackers are not to be confused with evil &lt;b&gt;crackers&lt;/b&gt; or clueless &lt;b&gt;script kiddies&lt;/b&gt;. If you confuse them, we will presume that you are either evil or clueless.</source>
          <target state="translated">골프, 오크 싸움, 프로그래밍 등 기술적 인 문제를 해결하는 데 현명한 사람. 해커는 도덕적으로 말하는 중립적 인 용어입니다. 훌륭한 해커는 사악한 &lt;b&gt;크래커&lt;/b&gt; 나 단서가없는 &lt;b&gt;스크립트 키드&lt;/b&gt; 와 혼동되어서는 안됩니다 . 당신이 그들을 혼동한다면, 우리는 당신이 사악하거나 우둔한 것으로 추정 할 것입니다.</target>
        </trans-unit>
        <trans-unit id="a06bdcd2151c9efce6b287181e34780a4956856f" translate="yes" xml:space="preserve">
          <source>Something &amp;ldquo;iffy&amp;rdquo;. See &lt;b&gt;Boolean context&lt;/b&gt;.</source>
          <target state="translated">뭔가 &quot;iffy&quot;입니다. &lt;b&gt;부울 컨텍스트&lt;/b&gt; 참조&lt;b&gt;&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="e155f24963deb993057b4c0bc7a9a37afd51cb22" translate="yes" xml:space="preserve">
          <source>Something extra that happens when you evaluate an &lt;b&gt;expression&lt;/b&gt;. Nowadays it can refer to almost anything. For example, evaluating a simple assignment statement typically has the &amp;ldquo;side effect&amp;rdquo; of assigning a value to a variable. (And you thought assigning the value was your primary intent in the first place!) Likewise, assigning a value to the special variable &lt;code&gt;$|&lt;/code&gt; (&lt;code&gt;$AUTOFLUSH&lt;/code&gt; ) has the side effect of forcing a flush after every &lt;code&gt;&lt;a href=&quot;functions/write&quot;&gt;write&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; on the currently selected filehandle.</source>
          <target state="translated">&lt;b&gt;식&lt;/b&gt; 을 평가할 때 발생하는 추가 사항 . 요즘에는 거의 모든 것을 가리킬 수 있습니다. 예를 들어, 간단한 대 입문을 평가하면 일반적으로 변수에 값을 대입하는 &quot;부작용&quot;이 있습니다. (그리고 당신은 값을 할당하는 것이 처음에 주요 의도라고 생각했습니다!) 마찬가지로, 특수 변수 &lt;code&gt;$|&lt;/code&gt; ( &lt;code&gt;$AUTOFLUSH&lt;/code&gt; )는 현재 선택된 파일 핸들에서 모든 &lt;code&gt;&lt;a href=&quot;functions/write&quot;&gt;write&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; 후 플러시를 강제하는 부작용 이 있습니다.</target>
        </trans-unit>
        <trans-unit id="4a7cb9b5327bb852f44f8593a79f045c7ad57891" translate="yes" xml:space="preserve">
          <source>Something extra that happens when you evaluate an &lt;b&gt;expression&lt;/b&gt;. Nowadays it can refer to almost anything. For example, evaluating a simple assignment statement typically has the &amp;ldquo;side effect&amp;rdquo; of assigning a value to a variable. (And you thought assigning the value was your primary intent in the first place!) Likewise, assigning a value to the special variable &lt;code&gt;$|&lt;/code&gt; (&lt;code&gt;$AUTOFLUSH&lt;/code&gt;) has the side effect of forcing a flush after every &lt;code&gt;write&lt;/code&gt; or &lt;code&gt;print&lt;/code&gt; on the currently selected filehandle.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="783e080adee89f0dfad650da0b7f44d322697c43" translate="yes" xml:space="preserve">
          <source>Something is rotten in the state of the program. An attributed subroutine ceased to exist between the point it was declared and the point at which its attribute handler(s) would have been called.</source>
          <target state="translated">프로그램 상태에 문제가 있습니다. 중요한 서브 루틴은 선언 된 시점과 해당 속성 핸들러가 호출 된 시점 사이에 존재하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9119b80c4db3125e0e5d3f36b18c5029258c49c9" translate="yes" xml:space="preserve">
          <source>Something is still amiss: consider the loop variable $cnt of the script. It was a number, not an object. We cannot make this value of type &lt;code&gt;symbolic&lt;/code&gt; , since then the loop will not terminate.</source>
          <target state="translated">여전히 문제가 있습니다. 스크립트의 루프 변수 $ cnt를 고려하십시오. 그것은 객체가 아니라 숫자였습니다. 루프가 종료되지 않기 때문에이 유형의 &lt;code&gt;symbolic&lt;/code&gt; 값을 만들 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="e0a55c1b08a5503b38a652a677cea0c95bbc3889" translate="yes" xml:space="preserve">
          <source>Something is still amiss: consider the loop variable $cnt of the script. It was a number, not an object. We cannot make this value of type &lt;code&gt;symbolic&lt;/code&gt;, since then the loop will not terminate.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b420f56b3a25fc6071dc9a2a0d9e492a4d5a4fac" translate="yes" xml:space="preserve">
          <source>Something like &lt;code&gt;&quot;-DHAVE_UNISTD_H&quot;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&quot;-DHAVE_UNISTD_H&quot;&lt;/code&gt; 와 같은 것</target>
        </trans-unit>
        <trans-unit id="2229723dcea531af53507e7f80155b0032f61e90" translate="yes" xml:space="preserve">
          <source>Something not owned by anybody. Perl is copyrighted and is thus</source>
          <target state="translated">아무도 소유하지 않은 것. Perl은 저작권이 있으며 따라서</target>
        </trans-unit>
        <trans-unit id="63320e06b401dd030b4898741e99304253f96385" translate="yes" xml:space="preserve">
          <source>Something of a hack but it prevents a lot of code duplication between MM_* variants.</source>
          <target state="translated">해킹이 있지만 MM_ * 변형 사이의 많은 코드 복제를 방지합니다.</target>
        </trans-unit>
        <trans-unit id="bbccb8a40149fe00b8fef910fa55b43eced89db6" translate="yes" xml:space="preserve">
          <source>Something similar to the offset hack is performed on AVs to enable efficient shifting and splicing off the beginning of the array; while &lt;code&gt;AvARRAY&lt;/code&gt; points to the first element in the array that is visible from Perl, &lt;code&gt;AvALLOC&lt;/code&gt; points to the real start of the C array. These are usually the same, but a &lt;code&gt;&lt;a href=&quot;functions/shift&quot;&gt;shift&lt;/a&gt;&lt;/code&gt; operation can be carried out by increasing &lt;code&gt;AvARRAY&lt;/code&gt; by one and decreasing &lt;code&gt;AvFILL&lt;/code&gt; and &lt;code&gt;AvMAX&lt;/code&gt; . Again, the location of the real start of the C array only comes into play when freeing the array. See &lt;code&gt;av_shift&lt;/code&gt; in</source>
          <target state="translated">오프셋 시작 해킹과 유사한 것이 AV에서 수행되어 어레이의 시작 부분에서 효율적으로 이동 및 스 플라이 싱 할 수 있습니다. 반면 &lt;code&gt;AvARRAY&lt;/code&gt; 는 펄에서 볼 어레이의 첫 번째 요소를 가리키는 &lt;code&gt;AvALLOC&lt;/code&gt; 의 C 어레이의 실제 시작 포인트. 이들은 일반적으로 동일하지만 &lt;code&gt;AvARRAY&lt;/code&gt; 를 1 씩 늘리고 &lt;code&gt;AvFILL&lt;/code&gt; 및 &lt;code&gt;AvMAX&lt;/code&gt; 를 줄이면 &lt;code&gt;&lt;a href=&quot;functions/shift&quot;&gt;shift&lt;/a&gt;&lt;/code&gt; 작업을 수행 할 수 있습니다 . 다시, C 어레이의 실제 시작 위치는 어레이를 해제 할 때만 작동합니다. 에 &lt;code&gt;av_shift&lt;/code&gt; 를 참조하십시오</target>
        </trans-unit>
        <trans-unit id="d8e742452f6bb725bfab3a5c5dba5836e7b3c368" translate="yes" xml:space="preserve">
          <source>Something similar to the offset hack is performed on AVs to enable efficient shifting and splicing off the beginning of the array; while &lt;code&gt;AvARRAY&lt;/code&gt; points to the first element in the array that is visible from Perl, &lt;code&gt;AvALLOC&lt;/code&gt; points to the real start of the C array. These are usually the same, but a &lt;code&gt;shift&lt;/code&gt; operation can be carried out by increasing &lt;code&gt;AvARRAY&lt;/code&gt; by one and decreasing &lt;code&gt;AvFILL&lt;/code&gt; and &lt;code&gt;AvMAX&lt;/code&gt;. Again, the location of the real start of the C array only comes into play when freeing the array. See &lt;code&gt;av_shift&lt;/code&gt; in</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4332fef1f22d39fca98466a0536a5b2d1aaa44ee" translate="yes" xml:space="preserve">
          <source>Something that tells your program what sort of variable you&amp;rsquo;d like. Perl doesn&amp;rsquo;t require you to declare variables, but you can use &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;functions/state&quot;&gt;state&lt;/a&gt;&lt;/code&gt; to denote that you want something other than the default.</source>
          <target state="translated">어떤 종류의 변수를 원하는지 프로그램에 알려주는 것. Perl은 변수 선언을 요구하지 않지만, &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;functions/state&quot;&gt;state&lt;/a&gt;&lt;/code&gt; 를 사용하여 기본값 이외의 것을 원한다는 것을 나타낼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e3fc8d53ca8cfa587374cbbfc4c208732524185a" translate="yes" xml:space="preserve">
          <source>Something that tells your program what sort of variable you&amp;rsquo;d like. Perl doesn&amp;rsquo;t require you to declare variables, but you can use &lt;code&gt;my&lt;/code&gt;, &lt;code&gt;our&lt;/code&gt;, or &lt;code&gt;state&lt;/code&gt; to denote that you want something other than the default.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ad3b77572daa04075d4890e62387b4b824f1955" translate="yes" xml:space="preserve">
          <source>Something to exclude, prefixed by &lt;code&gt;&quot;-&quot;&lt;/code&gt; : an existing character property (prefixed by &lt;code&gt;&quot;utf8::&quot;&lt;/code&gt; ) or a fully qualified (including package name) user-defined character property, to represent all the characters in that property; two hexadecimal code points for a range; or a single hexadecimal code point.</source>
          <target state="translated">접두사 &lt;code&gt;&quot;-&quot;&lt;/code&gt; 로 시작하는 것 : 기존 문자 속성 (접두사 &lt;code&gt;&quot;utf8::&quot;&lt;/code&gt; 접두어 ) 또는 정규화 된 (패키지 이름 포함) 사용자 정의 문자 속성으로 해당 속성의 모든 문자를 나타냅니다. 범위에 대한 두 개의 16 진 코드 포인트; 또는 단일 16 진 코드 포인트.</target>
        </trans-unit>
        <trans-unit id="7bf62f5d5b516cf40152d9946d4ef2a34c8991f7" translate="yes" xml:space="preserve">
          <source>Something to exclude, prefixed by &lt;code&gt;&quot;-&quot;&lt;/code&gt;: an existing character property (prefixed by &lt;code&gt;&quot;utf8::&quot;&lt;/code&gt;) or a fully qualified (including package name) user-defined character property, to represent all the characters in that property; two hexadecimal code points for a range; or a single hexadecimal code point.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f7458ff984e1016174a3ccc404733830b1557d4" translate="yes" xml:space="preserve">
          <source>Something to include, prefixed by &lt;code&gt;&quot;+&quot;&lt;/code&gt; : a built-in character property (prefixed by &lt;code&gt;&quot;utf8::&quot;&lt;/code&gt; ) or a fully qualified (including package name) user-defined character property, to represent all the characters in that property; two hexadecimal code points for a range; or a single hexadecimal code point.</source>
          <target state="translated">접두사 &lt;code&gt;&quot;+&quot;&lt;/code&gt; : 내장 문자 속성 ( &lt;code&gt;&quot;utf8::&quot;&lt;/code&gt; 접두사) ) 또는 정규화 된 (패키지 이름 포함) 사용자 정의 문자 속성으로 해당 속성의 모든 문자를 나타냅니다. 범위에 대한 두 개의 16 진 코드 포인트; 또는 단일 16 진 코드 포인트.</target>
        </trans-unit>
        <trans-unit id="bb71dc1c8ef0238d1cf6b1ff9fe27bbba1762fb7" translate="yes" xml:space="preserve">
          <source>Something to include, prefixed by &lt;code&gt;&quot;+&quot;&lt;/code&gt;: a built-in character property (prefixed by &lt;code&gt;&quot;utf8::&quot;&lt;/code&gt;) or a fully qualified (including package name) user-defined character property, to represent all the characters in that property; two hexadecimal code points for a range; or a single hexadecimal code point.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="691cfd6a9c9ef44b73a6c3b1fc2fc7e231422dbe" translate="yes" xml:space="preserve">
          <source>Something to intersect with, prefixed by &lt;code&gt;&quot;&amp;amp;&quot;&lt;/code&gt; : an existing character property (prefixed by &lt;code&gt;&quot;utf8::&quot;&lt;/code&gt; ) or a fully qualified (including package name) user-defined character property, for all the characters except the characters in the property; two hexadecimal code points for a range; or a single hexadecimal code point.</source>
          <target state="translated">접두사 &lt;code&gt;&quot;&amp;amp;&quot;&lt;/code&gt; 가 앞에 붙는 것 : 기존 문자 속성 (접두사 &lt;code&gt;&quot;utf8::&quot;&lt;/code&gt; 접두어 ) 또는 정규화 된 (패키지 이름 포함) 사용자 정의 문자 속성. 속성의 문자를 제외한 모든 문자 범위에 대한 두 개의 16 진 코드 포인트; 또는 단일 16 진 코드 포인트.</target>
        </trans-unit>
        <trans-unit id="4e94a757edcaa7aad7a0e5c39dc75f3c74ce6898" translate="yes" xml:space="preserve">
          <source>Something to intersect with, prefixed by &lt;code&gt;&quot;&amp;amp;&quot;&lt;/code&gt;: an existing character property (prefixed by &lt;code&gt;&quot;utf8::&quot;&lt;/code&gt;) or a fully qualified (including package name) user-defined character property, for all the characters except the characters in the property; two hexadecimal code points for a range; or a single hexadecimal code point.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6131959027de2eb65107afa87755cfdbae0af220" translate="yes" xml:space="preserve">
          <source>Something to negate, prefixed &lt;code&gt;&quot;!&quot;&lt;/code&gt; : an existing character property (prefixed by &lt;code&gt;&quot;utf8::&quot;&lt;/code&gt; ) or a fully qualified (including package name) user-defined character property, to represent all the characters in that property; two hexadecimal code points for a range; or a single hexadecimal code point.</source>
          <target state="translated">부정 할 것, 접두사 &lt;code&gt;&quot;!&quot;&lt;/code&gt; : 기존 문자 속성 ( &lt;code&gt;&quot;utf8::&quot;&lt;/code&gt; 접두사) ) 또는 완전한 (패키지 이름 포함) 사용자 정의 문자 특성으로 해당 특성의 모든 문자를 나타냅니다. 범위에 대한 두 개의 16 진 코드 포인트; 또는 단일 16 진 코드 포인트.</target>
        </trans-unit>
        <trans-unit id="1f4e74c8c058a6efc1c6982e3f86bee213dbdf3d" translate="yes" xml:space="preserve">
          <source>Something to negate, prefixed &lt;code&gt;&quot;!&quot;&lt;/code&gt;: an existing character property (prefixed by &lt;code&gt;&quot;utf8::&quot;&lt;/code&gt;) or a fully qualified (including package name) user-defined character property, to represent all the characters in that property; two hexadecimal code points for a range; or a single hexadecimal code point.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b29b35d3b7e27c5736fa04a9d5a9779f7c0d02b4" translate="yes" xml:space="preserve">
          <source>Something we&amp;rsquo;d call a &lt;b&gt;metacharacter&lt;/b&gt; except that it&amp;rsquo;s a sequence of more than one character. Generally, the first character in the sequence must be a true metacharacter to get the other characters in the metasymbol to misbehave along with it.</source>
          <target state="translated">하나 이상의 문자 시퀀스라는 것을 제외하고 &lt;b&gt;메타 문자&lt;/b&gt; 라고 부릅니다 . 일반적으로 시퀀스의 첫 번째 문자는 메타 심볼의 다른 문자가 오작동하도록하려면 실제 메타 문자 여야합니다.</target>
        </trans-unit>
        <trans-unit id="0939ed03ca5713b7d596d517d3a21d567b42a063" translate="yes" xml:space="preserve">
          <source>Something went horribly wrong-- the number of microseconds that cannot become negative just became negative. Maybe your compiler is broken?</source>
          <target state="translated">음이 될 수없는 마이크로 초의 수는 음이되었습니다. 어쩌면 컴파일러가 고장 났습니까?</target>
        </trans-unit>
        <trans-unit id="c59ba282daa2ae9441382d6bdd1d5cbb102eba6e" translate="yes" xml:space="preserve">
          <source>Something you can see from anywhere, usually used of &lt;b&gt;variables&lt;/b&gt; and &lt;b&gt;subroutines&lt;/b&gt; that are visible everywhere in your program. In Perl, only certain special variables are truly global&amp;mdash;most variables (and all subroutines) exist only in the current &lt;b&gt;package&lt;/b&gt;. Global variables can be declared with &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt;. See &amp;ldquo;Global Declarations&amp;rdquo; in Camel chapter 4, &amp;ldquo;Statements and Declarations&amp;rdquo;.</source>
          <target state="translated">프로그램의 어느 곳에서나 볼 수있는 &lt;b&gt;변수&lt;/b&gt; 와 &lt;b&gt;서브 루틴에&lt;/b&gt; 사용되는 어디에서나 볼 수있는 것. Perl에서는 특정 특수 변수 만 전역 적으로 사용됩니다. 대부분의 변수 (및 모든 서브 루틴)는 현재 &lt;b&gt;패키지&lt;/b&gt; 에만 존재 &lt;b&gt;합니다&lt;/b&gt; . 전역 변수로 선언 할 수 있습니다 &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; . Camel Chapter 4, &quot;Statement and Declarations&quot;의 &quot;Global Declarations&quot;를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="e2c9c959fabe06831c4dbb79467f69e8f2c98312" translate="yes" xml:space="preserve">
          <source>Something you can see from anywhere, usually used of &lt;b&gt;variables&lt;/b&gt; and &lt;b&gt;subroutines&lt;/b&gt; that are visible everywhere in your program. In Perl, only certain special variables are truly global&amp;mdash;most variables (and all subroutines) exist only in the current &lt;b&gt;package&lt;/b&gt;. Global variables can be declared with &lt;code&gt;our&lt;/code&gt;. See &amp;ldquo;Global Declarations&amp;rdquo; in Camel chapter 4, &amp;ldquo;Statements and Declarations&amp;rdquo;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07e88fa4cc64647b2e3278d50a97cb8b0618c720" translate="yes" xml:space="preserve">
          <source>Something you do for someone else to make them happy, like giving them the time of day (or of their life). On some machines, well-known services are listed by the &lt;code&gt;&lt;a href=&quot;functions/getservent&quot;&gt;getservent&lt;/a&gt;&lt;/code&gt; function.</source>
          <target state="translated">하루 중 시간 (또는 삶의 시간)을주는 것과 같이 다른 사람이 그들을 행복하게하기 위해하는 일. 일부 시스템에서는 잘 알려진 서비스가 &lt;code&gt;&lt;a href=&quot;functions/getservent&quot;&gt;getservent&lt;/a&gt;&lt;/code&gt; 함수 로 나열됩니다 .</target>
        </trans-unit>
        <trans-unit id="3583892f6ad6941063be20d46c43faa9b54da5ee" translate="yes" xml:space="preserve">
          <source>Something you do for someone else to make them happy, like giving them the time of day (or of their life). On some machines, well-known services are listed by the &lt;code&gt;getservent&lt;/code&gt; function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae96bed2910e868f1f0a103c503d2b55a0cc3496" translate="yes" xml:space="preserve">
          <source>Sometimes (see &lt;a href=&quot;#When-Unicode-Does-Not-Happen&quot;&gt;&quot;When Unicode Does Not Happen&quot;&lt;/a&gt; or &lt;a href=&quot;#The-%22Unicode-Bug%22&quot;&gt;&quot;The &quot;Unicode Bug&quot;&quot;&lt;/a&gt;) there are situations where you simply need to force a byte string into UTF-8, or vice versa. The standard module &lt;a href=&quot;encode&quot;&gt;Encode&lt;/a&gt; can be used for this, or the low-level calls &lt;a href=&quot;utf8#Utility-functions&quot;&gt;&lt;code&gt;utf8::upgrade($bytestring)&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;utf8#Utility-functions&quot;&gt;&lt;code&gt;utf8::downgrade($utf8string[, FAIL_OK])&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="457be77433ae10862116d65ca361c913afdc2edf" translate="yes" xml:space="preserve">
          <source>Sometimes (see &lt;a href=&quot;#When-Unicode-Does-Not-Happen&quot;&gt;When Unicode Does Not Happen&lt;/a&gt; or &lt;a href=&quot;#The-%22Unicode-Bug%22&quot;&gt;The Unicode Bug&lt;/a&gt;) there are situations where you simply need to force a byte string into UTF-8, or vice versa. The standard module &lt;a href=&quot;encode&quot;&gt;Encode&lt;/a&gt; can be used for this, or the low-level calls &lt;a href=&quot;utf8#Utility-functions&quot;&gt;utf8::upgrade($bytestring) &lt;/a&gt; and &lt;a href=&quot;utf8#Utility-functions&quot;&gt;utf8::downgrade($utf8string[, FAIL_OK]) &lt;/a&gt;.</source>
          <target state="translated">때때로 ( &lt;a href=&quot;#When-Unicode-Does-Not-Happen&quot;&gt;유니 코드가 발생하지 않는 경우&lt;/a&gt; 또는 &lt;a href=&quot;#The-%22Unicode-Bug%22&quot;&gt;유니 코드 버그 참조&lt;/a&gt; ) 바이트 문자열을 UTF-8로 강제 변환해야하는 상황이나 그 반대의 경우도 있습니다. 이를 위해 표준 모듈 &lt;a href=&quot;encode&quot;&gt;Encode&lt;/a&gt; 또는 저수준 호출 &lt;a href=&quot;utf8#Utility-functions&quot;&gt;utf8 :: upgrade ($ bytestring)&lt;/a&gt; 및 &lt;a href=&quot;utf8#Utility-functions&quot;&gt;utf8 :: downgrade ($ utf8string [, FAIL_OK])를 사용할 수&lt;/a&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="3f608ce8dd6d68e4a0eca5a70c40d0ca13048d16" translate="yes" xml:space="preserve">
          <source>Sometimes a change affects code paths which you cannot test on the OSes which are directly available to you and it would be wise to have users on other OSes test the change before you commit it to blead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c72f071a765fd3018bc7af5d49df36cbd9aae7b" translate="yes" xml:space="preserve">
          <source>Sometimes greed is not good. At times, we would like quantifiers to match a</source>
          <target state="translated">때로는 탐욕이 좋지 않습니다. 때때로, 우리는 정량자가</target>
        </trans-unit>
        <trans-unit id="0aa27e840004256e29009bb974e009bb34e90abf" translate="yes" xml:space="preserve">
          <source>Sometimes instead of zeroing the allocated heap by using Newxz() you should consider &quot;poisoning&quot; the data. This means writing a bit pattern into it that should be illegal as pointers (and floating point numbers), and also hopefully surprising enough as integers, so that any code attempting to use the data without forethought will break sooner rather than later. Poisoning can be done using the Poison() macros, which have similar arguments to Zero():</source>
          <target state="translated">때로는 Newxz ()를 사용하여 할당 된 힙을 제로화하는 대신 데이터 &quot;중독&quot;을 고려해야합니다. 즉, 포인터 (및 부동 소수점 숫자)로 불법이어야하고 정수로도 놀랍도록 비트 패턴을 작성하는 것은 의미하지 않고 데이터를 사용하려고 시도하는 모든 코드가 나중에보다 빨리 중단되도록합니다. 중독은 Zero ()와 유사한 인수를 갖는 Poison () 매크로를 사용하여 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cae5675054ecaa30b3d68d273e86faefe7bf19e0" translate="yes" xml:space="preserve">
          <source>Sometimes it is advantageous to construct a pattern from the</source>
          <target state="translated">때로는 패턴을 구성하는 것이 유리합니다</target>
        </trans-unit>
        <trans-unit id="fa5de12a356ae81ac7e15fb6c4fdf4f42322289c" translate="yes" xml:space="preserve">
          <source>Sometimes it may be necessary to make more than one pass over the input files. If this is the case you have several options. You can make the first pass using &lt;b&gt;Pod::Parser&lt;/b&gt; and override your methods to store the intermediate results in memory somewhere for the &lt;b&gt;end_pod()&lt;/b&gt; method to process. You could use &lt;b&gt;Pod::Parser&lt;/b&gt; for several passes with an appropriate state variable to control the operation for each pass. If your input source can't be reset to start at the beginning, you can store it in some other structure as a string or an array and have that structure implement a &lt;b&gt;getline()&lt;/b&gt; method (which is all that &lt;b&gt;parse_from_filehandle()&lt;/b&gt; uses to read input).</source>
          <target state="translated">때로는 입력 파일을 두 번 이상 통과해야 할 수도 있습니다. 이 경우 몇 가지 옵션이 있습니다. &lt;b&gt;Pod :: Parser를&lt;/b&gt; 사용하여 첫 번째 단계 를 수행하고 &lt;b&gt;end_pod ()&lt;/b&gt; 메서드가 처리 할 중간 위치에 메모리에 중간 결과를 저장하도록 메서드를 재정의 할 수 있습니다. 적절한 상태 변수를 가진 여러 패스에 &lt;b&gt;Pod :: Parser&lt;/b&gt; 를 사용 하여 각 패스에 대한 작업을 제어 할 수 있습니다. 입력 소스를 처음에 시작하도록 재설정 할 수없는 경우 다른 구조에 문자열 또는 배열로 저장하고 &lt;b&gt;getline ()&lt;/b&gt; 메소드 ( &lt;b&gt;parse_from_filehandle ()&lt;/b&gt; 가 읽기 위해 사용하는 모든 메소드 &lt;b&gt;)를&lt;/b&gt; 구현하도록 할 수 있습니다 입력).</target>
        </trans-unit>
        <trans-unit id="f6006f7823a5727b8006f191fa888a2e039ea099" translate="yes" xml:space="preserve">
          <source>Sometimes minimal matching can help a lot. Imagine you'd like to match everything between &quot;foo&quot; and &quot;bar&quot;. Initially, you write something like this:</source>
          <target state="translated">때로는 최소한의 일치가 많은 도움이 될 수 있습니다. &quot;foo&quot;와 &quot;bar&quot;사이의 모든 것을 일치시키고 싶다고 상상해보십시오. 처음에는 다음과 같이 작성합니다.</target>
        </trans-unit>
        <trans-unit id="7e0fb1495abd7611e5570cce2cb4d1976ffa0113" translate="yes" xml:space="preserve">
          <source>Sometimes older versions of the module you're installing live in other directories in @INC. Because Perl loads the first version of a module it finds, not the newest, you might accidentally get one of these older versions even after installing a brand new version. To delete</source>
          <target state="translated">때로는 설치하려는 이전 버전의 모듈이 @INC의 다른 디렉토리에 실시간으로 있습니다. Perl은 최신 버전이 아니라 발견 한 첫 번째 버전의 모듈을로드하기 때문에 새 버전을 설치 한 후에도 실수로 이전 버전 중 하나를 얻을 수 있습니다. 지우는 것</target>
        </trans-unit>
        <trans-unit id="eb753520a2d796d4f761ee04ddf336bdbe0915a3" translate="yes" xml:space="preserve">
          <source>Sometimes ops are executed within an inner runops loop, such as tie, sort or overload code. In this case, something like</source>
          <target state="translated">때로는 동점, 정렬 또는 과부하 코드와 같은 내부 runops 루프 내에서 op가 실행됩니다. 이 경우에는</target>
        </trans-unit>
        <trans-unit id="147ec757892c0aed445b0fb45a48e27c978e8a0c" translate="yes" xml:space="preserve">
          <source>Sometimes running a test under certain conditions will cause the test script to die. A certain function or method isn't implemented (such as &lt;code&gt;&lt;a href=&quot;../functions/fork&quot;&gt;fork()&lt;/a&gt;&lt;/code&gt; on MacOS), some resource isn't available (like a net connection) or a module isn't available. In these cases it's necessary to skip tests, or declare that they are supposed to fail but will work in the future (a todo test).</source>
          <target state="translated">때때로 특정 조건에서 테스트를 실행하면 테스트 스크립트가 종료 될 수 있습니다. 특정 함수 또는 메소드가 구현되지 않았거나 (예 : MacOS의 &lt;code&gt;&lt;a href=&quot;../functions/fork&quot;&gt;fork()&lt;/a&gt;&lt;/code&gt; ) 일부 리소스를 사용할 수 없거나 (네트 연결과 같은) 모듈을 사용할 수 없습니다. 이 경우 테스트를 건너 뛰거나 실패한다고 가정하지만 향후에는 할 일 (todo 테스트)을 수행 할 것이라고 선언해야합니다.</target>
        </trans-unit>
        <trans-unit id="7390e59acad33d69c3848b5a344152fa281f8af4" translate="yes" xml:space="preserve">
          <source>Sometimes running a test under certain conditions will cause the test script to die. A certain function or method isn't implemented (such as &lt;code&gt;fork()&lt;/code&gt; on MacOS), some resource isn't available (like a net connection) or a module isn't available. In these cases it's necessary to skip tests, or declare that they are supposed to fail but will work in the future (a todo test).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14a525fd22c2b653fcabe0c32c53b3975d5455dc" translate="yes" xml:space="preserve">
          <source>Sometimes the Test::Builder test counter is incremented without it printing any test output, for example, when &lt;code&gt;current_test()&lt;/code&gt; is changed. In these cases, Test::Builder doesn't know the result of the test, so its type is 'unknown'. These details for these tests are filled in. They are considered ok, but the name and actual_ok is left &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">경우에 따라 test :: Builder 테스트 카운터는 테스트 출력을 인쇄하지 않고 증분됩니다 &lt;code&gt;current_test()&lt;/code&gt; 예 : current_test () 가 변경된 경우). 이 경우 Test :: Builder는 테스트 결과를 알지 못하므로 해당 유형은 '알 수 없음'입니다. 이러한 테스트에 대한 자세한 내용은 채워져 있습니다. 괜찮은 것으로 간주되지만 이름과 actual_ok는 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 로 남아 있습니다.</target>
        </trans-unit>
        <trans-unit id="f02b8eb27bf0ac9011c417f61209efd72c4a3f25" translate="yes" xml:space="preserve">
          <source>Sometimes the Test::Builder test counter is incremented without it printing any test output, for example, when &lt;code&gt;current_test()&lt;/code&gt; is changed. In these cases, Test::Builder doesn't know the result of the test, so its type is 'unknown'. These details for these tests are filled in. They are considered ok, but the name and actual_ok is left &lt;code&gt;undef&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd534b46a8017bb548267c02f58ed840dafad837" translate="yes" xml:space="preserve">
          <source>Sometimes the Test::More interface isn't quite enough. Fortunately, Test::More is built on top of &lt;a href=&quot;Test::Builder&quot;&gt;Test::Builder&lt;/a&gt; which provides a single, unified backend for any test library to use. This means two test libraries which both use &amp;lt;Test::Builder&amp;gt; &lt;b&gt;can&lt;/b&gt; be used together in the same program&amp;gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c117b85f5735958c8ac918f5819ede8cc1b0ef4" translate="yes" xml:space="preserve">
          <source>Sometimes the Test::More interface isn't quite enough. Fortunately, Test::More is built on top of &lt;a href=&quot;builder&quot;&gt;Test::Builder&lt;/a&gt; which provides a single, unified backend for any test library to use. This means two test libraries which both use &amp;lt;Test::Builder&amp;gt; &lt;b&gt;can&lt;/b&gt; be used together in the same program&amp;gt;.</source>
          <target state="translated">때때로 Test :: More 인터페이스로는 충분하지 않습니다. 다행스럽게도 Test :: More는 &lt;a href=&quot;builder&quot;&gt;Test :: Builder&lt;/a&gt; 위에 구축되어 테스트 라이브러리에서 사용할 수있는 단일 통합 백엔드를 제공합니다. 이것은 &amp;lt;Test :: Builder&amp;gt;를 사용하는 두 개의 테스트 라이브러리가 같은 프로그램에서 함께 사용될 &lt;b&gt;수&lt;/b&gt; 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="df8dfca3bc58e211921f51d53ab1d95cb5cb75f5" translate="yes" xml:space="preserve">
          <source>Sometimes the tests are wrong</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff0436b0b7df1e2c343b73c639e499fd807b68f3" translate="yes" xml:space="preserve">
          <source>Sometimes there is some confusion about where &lt;code&gt;todo()&lt;/code&gt; should be looking for the &lt;code&gt;$TODO&lt;/code&gt; variable. If you want to be sure, tell it explicitly what $pack to use.</source>
          <target state="translated">때때로 &lt;code&gt;todo()&lt;/code&gt; 가 &lt;code&gt;$TODO&lt;/code&gt; 변수를 찾아야 할 곳에 혼란 이 있습니다 . 확실하게 사용하려면 $ pack을 사용할 것을 명시 적으로 알려주십시오.</target>
        </trans-unit>
        <trans-unit id="399765aa05845ba02b6fea1a15de4bf746fb4a9e" translate="yes" xml:space="preserve">
          <source>Sometimes we would like our regexp to be able to match different possible words or character strings. This is accomplished by using the</source>
          <target state="translated">때로는 정규 표현식이 가능한 다른 단어 나 문자열과 일치시킬 수 있기를 원합니다. 이것은</target>
        </trans-unit>
        <trans-unit id="c45fdfd630d6939174042d52a2669877eec8162b" translate="yes" xml:space="preserve">
          <source>Sometimes you don't want to pass the value of an array to a subroutine but rather the name of it, so that the subroutine can modify the global copy of it rather than working with a local copy. In perl you can refer to all objects of a particular name by prefixing the name with a star: &lt;code&gt;*foo&lt;/code&gt; . This is often known as a &quot;typeglob&quot;, because the star on the front can be thought of as a wildcard match for all the funny prefix characters on variables and subroutines and such.</source>
          <target state="translated">때때로 서브 루틴이 아닌 서브 루틴에 배열의 값을 전달하고 싶지 않아 서브 루틴이 로컬 사본으로 작업하는 대신 서브 루틴의 글로벌 사본을 수정할 수 있습니다. 펄에서 이름 앞에 별표 &lt;code&gt;*foo&lt;/code&gt; 를 붙여 특정 이름의 모든 객체를 참조 할 수 있습니다 . 전면의 별은 변수 및 서브 루틴 등의 모든 재미있는 접두사 문자에 대한 와일드 카드 일치로 생각할 수 있기 때문에 종종 &quot;typeglob&quot;라고합니다.</target>
        </trans-unit>
        <trans-unit id="5af3185bc4cb6153940818cc124ced30384d5bf0" translate="yes" xml:space="preserve">
          <source>Sometimes you don't want to pass the value of an array to a subroutine but rather the name of it, so that the subroutine can modify the global copy of it rather than working with a local copy. In perl you can refer to all objects of a particular name by prefixing the name with a star: &lt;code&gt;*foo&lt;/code&gt;. This is often known as a &quot;typeglob&quot;, because the star on the front can be thought of as a wildcard match for all the funny prefix characters on variables and subroutines and such.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd89c56c7d1482880d960bf6dbcdba4cb33c9a40" translate="yes" xml:space="preserve">
          <source>Sometimes you have a context that is not current, and you want things to use it as the current one. In these cases you can call &lt;code&gt;$ctx-&amp;gt;do_in_context(sub { ... })&lt;/code&gt;. The codeblock will be run, and anything inside of it that looks for a context will find the one on which the method was called.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3dc7c2918cdb381ad384c3d9167215ff71a8a0da" translate="yes" xml:space="preserve">
          <source>Sometimes you have to store undefined values in AVs or HVs. Although this may be a rare case, it can be tricky. That's because you're used to using &lt;code&gt;&amp;amp;PL_sv_undef&lt;/code&gt; if you need an undefined SV.</source>
          <target state="translated">때로는 AV 또는 HV에 정의되지 않은 값을 저장해야합니다. 이 경우는 드물지만 까다로울 수 있습니다. 정의되지 않은 SV가 필요한 경우 &lt;code&gt;&amp;amp;PL_sv_undef&lt;/code&gt; 를 사용하는 데 익숙하기 때문 입니다.</target>
        </trans-unit>
        <trans-unit id="ce5b78669327a1c5203b6d6638f97e91e235e173" translate="yes" xml:space="preserve">
          <source>Sometimes you just want to say that the tests have passed. Usually the case is you've got some complicated condition that is difficult to wedge into an &lt;code&gt;ok()&lt;/code&gt; . In this case, you can simply use &lt;code&gt;pass()&lt;/code&gt; (to declare the test ok) or fail (for not ok). They are synonyms for &lt;code&gt;ok(1)&lt;/code&gt; and &lt;code&gt;ok(0)&lt;/code&gt; .</source>
          <target state="translated">때로는 테스트가 통과되었다고 말하고 싶을 때가 있습니다. 일반적으로 &lt;code&gt;ok()&lt;/code&gt; 로 쐐기가 어려운 복잡한 조건이 있습니다. 이 경우 단순히 &lt;code&gt;pass()&lt;/code&gt; 를 사용 하여 (테스트 ok를 선언) 실패 (ok가 아닌)를 사용할 수 있습니다. 그것들은 &lt;code&gt;ok(1)&lt;/code&gt; 과 &lt;code&gt;ok(0)&lt;/code&gt; 동의어입니다 .</target>
        </trans-unit>
        <trans-unit id="a82677750f0ce8e378152fcb09ef45c3dffa03dc" translate="yes" xml:space="preserve">
          <source>Sometimes you just want to say that the tests have passed. Usually the case is you've got some complicated condition that is difficult to wedge into an &lt;code&gt;ok()&lt;/code&gt;. In this case, you can simply use &lt;code&gt;pass()&lt;/code&gt; (to declare the test ok) or fail (for not ok). They are synonyms for &lt;code&gt;ok(1)&lt;/code&gt; and &lt;code&gt;ok(0)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99ad657b111885cfb86229225ce3dd7e07ab7571" translate="yes" xml:space="preserve">
          <source>Sometimes you may want to truncate an already-existing file. This can be done using the &lt;code&gt;O_TRUNC&lt;/code&gt; flag. The behavior of &lt;code&gt;O_TRUNC&lt;/code&gt; with &lt;code&gt;O_RDONLY&lt;/code&gt; is undefined.</source>
          <target state="translated">때로는 기존 파일을자를 수도 있습니다. 이것은 &lt;code&gt;O_TRUNC&lt;/code&gt; 플래그를 사용하여 수행 할 수 있습니다 . &lt;code&gt;O_RDONLY&lt;/code&gt; 를 사용한 &lt;code&gt;O_TRUNC&lt;/code&gt; 의 동작 은 정의되어 있지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d108e62bce7d546642fdcfcda3e786d8361305f7" translate="yes" xml:space="preserve">
          <source>Sometimes you may wish to leave the processes run by CPAN alone without caring about them. Because the Makefile.PL or the Build.PL sometimes contains question you're expected to answer, you can set a timer that will kill a 'perl Makefile.PL' process after the specified time in seconds.</source>
          <target state="translated">때로는 CPAN이 단독으로 실행하는 프로세스를 신경 쓰지 않고 그대로두기를 원할 수도 있습니다. Makefile.PL 또는 Build.PL에 때때로 응답해야하는 질문이 포함되어 있으므로 지정된 시간 (초) 후에 'perl Makefile.PL'프로세스를 종료하는 타이머를 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c00f6f509d151b6fb1ea7605fa661bc15fbf5303" translate="yes" xml:space="preserve">
          <source>Sometimes you might really need to know the byte length of a string instead of the character length. For that use either the &lt;code&gt;Encode::encode_utf8()&lt;/code&gt; function or the &lt;code&gt;bytes&lt;/code&gt; pragma and the &lt;code&gt;&lt;a href=&quot;functions/length&quot;&gt;length()&lt;/a&gt;&lt;/code&gt; function:</source>
          <target state="translated">때로는 문자 길이 대신 문자열의 바이트 길이를 알아야 할 수도 있습니다. 이를 위해 &lt;code&gt;Encode::encode_utf8()&lt;/code&gt; 함수 또는 &lt;code&gt;bytes&lt;/code&gt; pragma 및 &lt;code&gt;&lt;a href=&quot;functions/length&quot;&gt;length()&lt;/a&gt;&lt;/code&gt; 함수를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="f11bb3346a94ad8679e866144b82f5a7774a030a" translate="yes" xml:space="preserve">
          <source>Sometimes you might really need to know the byte length of a string instead of the character length. For that use the &lt;code&gt;bytes&lt;/code&gt; pragma and the &lt;code&gt;length()&lt;/code&gt; function:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69ca48a72c9601cef59e5c67d6f3681c75e3b061" translate="yes" xml:space="preserve">
          <source>Sometimes you might want to build a statically linked perl although your system supports dynamic loading. In this case you may explicitly set the linktype with the invocation of the Makefile.PL or make:</source>
          <target state="translated">시스템이 동적 로딩을 지원하지만 정적으로 링크 된 perl을 빌드하고자 할 수도 있습니다. 이 경우 Makefile.PL을 호출하여 링크 유형을 명시 적으로 설정하거나 다음을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d30402c312d3b94f0c6f02a6509532f4e38398dd" translate="yes" xml:space="preserve">
          <source>Sometimes you might want to display Perl scalars containing Unicode as simple ASCII (or EBCDIC) text. The following subroutine converts its argument so that Unicode characters with code points greater than 255 are displayed as &lt;code&gt;\x{...}&lt;/code&gt; , control characters (like &lt;code&gt;\n&lt;/code&gt; ) are displayed as &lt;code&gt;\x..&lt;/code&gt; , and the rest of the characters as themselves:</source>
          <target state="translated">때로는 유니 코드를 포함하는 Perl 스칼라를 간단한 ASCII (또는 EBCDIC) 텍스트로 표시하려고 할 수 있습니다. 다음 서브 루틴은 인수가 255보다 큰 코드 포인트를 갖는 유니 코드 문자가 &lt;code&gt;\x{...}&lt;/code&gt; 로 표시되고 제어 문자 (예 : &lt;code&gt;\n&lt;/code&gt; )가 &lt;code&gt;\x..&lt;/code&gt; 로 표시되고 나머지 문자가 자체로 표시되도록 인수를 변환합니다 . :</target>
        </trans-unit>
        <trans-unit id="93f2d5137c1ee615f6cf1836ee85be0ea4a982af" translate="yes" xml:space="preserve">
          <source>Sometimes you might want to display Perl scalars containing Unicode as simple ASCII (or EBCDIC) text. The following subroutine converts its argument so that Unicode characters with code points greater than 255 are displayed as &lt;code&gt;\x{...}&lt;/code&gt;, control characters (like &lt;code&gt;\n&lt;/code&gt;) are displayed as &lt;code&gt;\x..&lt;/code&gt;, and the rest of the characters as themselves:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="93cab2a917ae8f995aa91a73cd34dbac7106cc0f" translate="yes" xml:space="preserve">
          <source>Sometimes you might want to provide some extra methods or subroutines to assist in making the interface between Perl and your extension simpler or easier to understand. These routines should live in the .pm file. Whether they are automatically loaded when the extension itself is loaded or only loaded when called depends on where in the .pm file the subroutine definition is placed. You can also consult &lt;a href=&quot;autoloader&quot;&gt;AutoLoader&lt;/a&gt; for an alternate way to store and load your extra subroutines.</source>
          <target state="translated">때로는 Perl과 확장 사이의 인터페이스를 더 단순하거나 이해하기 쉽게 만드는 데 도움이되는 몇 가지 추가 메소드 또는 서브 루틴을 제공 할 수 있습니다. 이 루틴은 .pm 파일에 있어야합니다. 확장자 자체가로드 될 때 자동으로로드되는지 또는 호출 될 때만로드되는지는 .pm 파일에서 서브 루틴 정의가있는 위치에 따라 다릅니다. 여분의 서브 루틴을 저장하고로드하는 다른 방법은 &lt;a href=&quot;autoloader&quot;&gt;AutoLoader&lt;/a&gt; 에 문의 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d50f25bb7791c3200f165a11a2621c66fc26aa1f" translate="yes" xml:space="preserve">
          <source>Sometimes you need to have two and more XS files in the same package. One way to go is to put them into separate directories, but sometimes this is not the most suitable solution. The following technique allows you to put two (and more) XS files in the same directory.</source>
          <target state="translated">때로는 동일한 패키지에 둘 이상의 XS 파일이 있어야합니다. 한 가지 방법은 별도의 디렉토리에 저장하는 것이지만 때로는 이것이 가장 적합한 솔루션이 아닙니다. 다음 기술을 사용하면 동일한 디렉토리에 두 개 이상의 XS 파일을 넣을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="aecdaaa113e37c215923d6d01ac79b4d26b62dd7" translate="yes" xml:space="preserve">
          <source>Sometimes you need to have two and more XS files in the same package. There are three ways: &lt;code&gt;XSMULTI&lt;/code&gt;, separate directories, and bootstrapping one XS from another.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1dc76b72e97adc6a2bca89e4051260b585b27319" translate="yes" xml:space="preserve">
          <source>Sometimes you need to invoke the same subroutine repeatedly. This usually happens with a function that acts on a list of values, such as Perl's built-in sort(). You can pass a comparison function to sort(), which will then be invoked for every pair of values that needs to be compared. The first() and reduce() functions from &lt;a href=&quot;List::Util&quot;&gt;List::Util&lt;/a&gt; follow a similar pattern.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d84ae75a88af76cd17f4e95ee970d0624fc53ec5" translate="yes" xml:space="preserve">
          <source>Sometimes you need to invoke the same subroutine repeatedly. This usually happens with a function that acts on a list of values, such as Perl's built-in sort(). You can pass a comparison function to sort(), which will then be invoked for every pair of values that needs to be compared. The first() and reduce() functions from &lt;a href=&quot;list/util&quot;&gt;List::Util&lt;/a&gt; follow a similar pattern.</source>
          <target state="translated">때때로 동일한 서브 루틴을 반복해서 호출해야합니다. 이것은 일반적으로 Perl의 내장 sort ()와 같은 값 목록에서 작동하는 함수에서 발생합니다. 비교 함수를 sort ()에 전달하면 비교해야하는 모든 값 쌍에 대해 호출됩니다. &lt;a href=&quot;list/util&quot;&gt;List :: Util&lt;/a&gt; 의 first () 및 reduce () 함수 는 비슷한 패턴을 따릅니다.</target>
        </trans-unit>
        <trans-unit id="74631c8a306d075a7cfb9919a67e89afd99fe44c" translate="yes" xml:space="preserve">
          <source>Sometimes you really don't know how many tests were run, or it's too difficult to calculate. In which case you can leave off $number_of_tests_run.</source>
          <target state="translated">때로는 얼마나 많은 테스트가 실행되었는지 알지 못하거나 계산하기가 너무 어렵습니다. 이 경우 $ number_of_tests_run을 남겨 둘 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="85a6426e0300f2135b305a518e04a9c8bcb36f5b" translate="yes" xml:space="preserve">
          <source>Sometimes you should change the positions of the constant and the variable. For example, let's say you wanted to test which of many answers you were given, but in a case-insensitive way that also allows abbreviations. You can use the following technique if the strings all start with different characters or if you want to arrange the matches so that one takes precedence over another, as &lt;code&gt;&quot;SEND&quot;&lt;/code&gt; has precedence over &lt;code&gt;&quot;STOP&quot;&lt;/code&gt; here:</source>
          <target state="translated">때로는 상수와 변수의 위치를 ​​변경해야합니다. 예를 들어, 어떤 답변을 받았지만 약어를 허용하는 대소 문자를 구분하지 않는 방식으로 테스트하려고한다고 가정 해 봅시다. 문자열이 모두 다른 문자로 시작하거나 일치 항목을 정렬하여 &lt;code&gt;&quot;SEND&quot;&lt;/code&gt; 가 &lt;code&gt;&quot;STOP&quot;&lt;/code&gt; 보다 우선 하여 일치하는 것을 정렬하려는 경우 다음 기술을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e295d93f5cf54bf6ebaedc8fedd1af1c66b62ba7" translate="yes" xml:space="preserve">
          <source>Sometimes you want to combine the best of hashes and arrays. For example, the command line:</source>
          <target state="translated">때로는 최고의 해시와 배열을 결합하려고합니다. 예를 들어, 명령 행은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="eb405d6eff8a4115aee698cb0c98540a6a3fb25a" translate="yes" xml:space="preserve">
          <source>Sometimes you want to test if a module, or a list of modules, can successfully load. For example, you'll often want a first test which simply loads all the modules in the distribution to make sure they work before going on to do more complicated testing.</source>
          <target state="translated">때로는 모듈 또는 모듈 목록이 성공적으로로드 될 수 있는지 테스트하려고합니다. 예를 들어,보다 복잡한 테스트를 진행하기 전에 배포판의 모든 모듈을로드하여 작동하는지 확인하는 첫 번째 테스트를 원할 경우가 종종 있습니다.</target>
        </trans-unit>
        <trans-unit id="39b7fbc0e51ead34509190d6590e14e10ef47adc" translate="yes" xml:space="preserve">
          <source>Sometimes, blead will move while you're building or testing your changes. When this happens, your push will be rejected with a message like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ddf8f669e0c9325d3a3aabdd507e3c59589ddd67" translate="yes" xml:space="preserve">
          <source>Sometimes, for example when there are a lot of options, having a separate variable for each of them can be cumbersome. GetOptions() supports, as an alternative mechanism, storing options values in a hash.</source>
          <target state="translated">예를 들어, 옵션이 많은 경우 각 옵션마다 별도의 변수를 갖는 것이 번거로울 수 있습니다. GetOptions ()는 대체 메커니즘으로 옵션 값을 해시에 저장하는 기능을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="02fbdd8083e416b0e9b5fb808fb524ba8afb9c15" translate="yes" xml:space="preserve">
          <source>Sometimes, however, linked lists can be useful in situations where you want to &quot;shard&quot; an array so you have many small arrays instead of a single big array. You can keep arrays longer than Perl's largest array index, lock smaller arrays separately in threaded programs, reallocate less memory, or quickly insert elements in the middle of the chain.</source>
          <target state="translated">그러나 때때로 링크 된 목록은 배열을 &quot;샤딩&quot;하려는 경우 큰 단일 배열 대신 작은 배열이 많이있는 경우에 유용 할 수 있습니다. 배열을 Perl의 가장 큰 배열 인덱스보다 길게 유지하고, 더 작은 배열을 스레드 프로그램에서 개별적으로 잠 그거나, 적은 메모리를 재 할당하거나, 체인 중간에 요소를 빠르게 삽입 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="97c577b8a14d559ea222f726e98e3c5c96ca2ea7" translate="yes" xml:space="preserve">
          <source>Sometimes, it can be necessary or useful to make sure that a certain function is fully loaded by AutoLoader. This is the case, for example, when you need to wrap a function to inject debugging code. It is also helpful to force early loading of code before forking to make use of copy-on-write as much as possible.</source>
          <target state="translated">때로는 특정 기능이 AutoLoader에 의해 완전히로드되도록하는 것이 필요하거나 유용 할 수 있습니다. 예를 들어 디버깅 코드를 주입하기 위해 함수를 래핑해야하는 경우입니다. 또한 COW (Copy-On-Write)를 최대한 활용하기 전에 코드를 조기에로드하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="135822a5181e82def02074d4f94c0948ca18c68d" translate="yes" xml:space="preserve">
          <source>Sometimes, when the extension does not convert data but just stores and retrieves it, you will be able to use the otherwise dangerous &lt;a href=&quot;encode#_utf8_on&quot;&gt;&lt;code&gt;Encode::_utf8_on()&lt;/code&gt;&lt;/a&gt; function. Let's say the popular &lt;code&gt;Foo::Bar&lt;/code&gt; extension, written in C, provides a &lt;code&gt;param&lt;/code&gt; method that lets you store and retrieve data according to these prototypes:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c69c69258cfab486eea48fb3f2e535b94c5ff785" translate="yes" xml:space="preserve">
          <source>Sometimes, when the extension does not convert data but just stores and retrieves it, you will be able to use the otherwise dangerous &lt;a href=&quot;encode#_utf8_on&quot;&gt;Encode::_utf8_on() &lt;/a&gt; function. Let's say the popular &lt;code&gt;Foo::Bar&lt;/code&gt; extension, written in C, provides a &lt;code&gt;param&lt;/code&gt; method that lets you store and retrieve data according to these prototypes:</source>
          <target state="translated">때로는 확장 프로그램이 데이터를 변환하지 않고 데이터를 저장하고 검색 할 때 위험한 &lt;a href=&quot;encode#_utf8_on&quot;&gt;Encode :: _ utf8_on ()&lt;/a&gt; 함수 를 사용할 수 있습니다. C로 작성된 인기있는 &lt;code&gt;Foo::Bar&lt;/code&gt; 확장은 다음 프로토 타입에 따라 데이터를 저장하고 검색 할 수 있는 &lt;code&gt;param&lt;/code&gt; 메소드를 제공 한다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="915dac0cd6a2dc4688c56bcdae8cb3044da9ebd2" translate="yes" xml:space="preserve">
          <source>Sometimes, you might not wish to extract a complete archive, just the files that are relevant to you, based on some criteria.</source>
          <target state="translated">때로는 일부 기준에 따라 완전한 아카이브를 추출하지 않고 자신과 관련된 파일 만 추출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f51205933e073241a85c203ffa02d17e6d6be23a" translate="yes" xml:space="preserve">
          <source>Somewhat obsolete (last update in 1996), but still useful. Also try</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fdb96cd07e3d9541f84e40d3e5c507a59f023fa2" translate="yes" xml:space="preserve">
          <source>Sorry, hash keys must be smaller than 2**31 bytes</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d2c8f1aa042b04053bafd03d4559b130a601b41" translate="yes" xml:space="preserve">
          <source>Sort an array, with various options.</source>
          <target state="translated">다양한 옵션으로 배열을 정렬하십시오.</target>
        </trans-unit>
        <trans-unit id="f11b2d382bb4d1812bd22f06feccfbd16f64c011" translate="yes" xml:space="preserve">
          <source>Sort an array. Here is an example:</source>
          <target state="translated">배열을 정렬하십시오. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4d31f4a6a4ae686389ba0f01ad7435ce3ff7f965" translate="yes" xml:space="preserve">
          <source>Sort speed and memory use impacts</source>
          <target state="translated">정렬 속도 및 메모리 사용 영향</target>
        </trans-unit>
        <trans-unit id="669dcc90bf40cd3f0218ee9881e32132c08114cc" translate="yes" xml:space="preserve">
          <source>Sort subroutines written using &lt;code&gt;$a&lt;/code&gt; and &lt;code&gt;$b&lt;/code&gt; are bound to their calling package. It is possible, but of limited interest, to define them in a different package, since the subroutine must still refer to the calling package's &lt;code&gt;$a&lt;/code&gt; and &lt;code&gt;$b&lt;/code&gt; :</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e86fa3b469953cdb9c0cfc2f27adce6dc70ff6d4" translate="yes" xml:space="preserve">
          <source>Sort your map in Unicode order.</source>
          <target state="translated">유니 코드 순서로 맵을 정렬하십시오.</target>
        </trans-unit>
        <trans-unit id="ba790800e4b9f3d3512c898b0e6088f4dbb30c87" translate="yes" xml:space="preserve">
          <source>Sorting - the quicksort algorithm used in Perls before 5.8.0 to implement the sort() function is very easy to trick into misbehaving so that it consumes a lot of time. Starting from Perl 5.8.0 a different sorting algorithm, mergesort, is used by default. Mergesort cannot misbehave on any input.</source>
          <target state="translated">정렬-sort () 함수를 구현하기 위해 5.8.0 이전의 Perls에서 사용 된 퀵 정렬 알고리즘은 오작동을 속이기 때문에 많은 시간을 소비합니다. Perl 5.8.0부터는 다른 정렬 알고리즘 인 mergesort가 기본적으로 사용됩니다. Mergesort는 모든 입력에서 오작동 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="375ce09517152463f4dde67936d2c7e3cbb12301" translate="yes" xml:space="preserve">
          <source>Sorting - the quicksort algorithm used in Perls before 5.8.0 to implement the sort() function was very easy to trick into misbehaving so that it consumes a lot of time. Starting from Perl 5.8.0 a different sorting algorithm, mergesort, is used by default. Mergesort cannot misbehave on any input.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88a6e89fe9499560d5c7c4f0eba879f0797fcbdf" translate="yes" xml:space="preserve">
          <source>Sorts a list of strings.</source>
          <target state="translated">문자열 목록을 정렬합니다.</target>
        </trans-unit>
        <trans-unit id="89989e7858233b758069d9e36e356e32ea1f4ab9" translate="yes" xml:space="preserve">
          <source>Sounds an awful lot like a process, doesn't it? Well, it should. Threads are one of the pieces of a process. Every process has at least one thread and, up until now, every process running Perl had only one thread. With 5.8, though, you can create extra threads. We're going to show you how, when, and why.</source>
          <target state="translated">프로세스처럼 끔찍하게 들립니다. 글쎄요. 스레드는 프로세스의 한 부분입니다. 모든 프로세스에는 최소한 하나의 스레드가 있으며 지금까지 Perl을 실행하는 모든 프로세스에는 스레드가 하나만있었습니다. 그러나 5.8을 사용하면 추가 스레드를 만들 수 있습니다. 방법,시기 및 이유를 보여 드리겠습니다.</target>
        </trans-unit>
        <trans-unit id="7b37110e5b01350732eac4676af2611966b9ccef" translate="yes" xml:space="preserve">
          <source>Source Code</source>
          <target state="translated">소스 코드</target>
        </trans-unit>
        <trans-unit id="f0a8c7951e6c30a3c63c9dfb78486cbdf3df91af" translate="yes" xml:space="preserve">
          <source>Source Documentation</source>
          <target state="translated">소스 문서</target>
        </trans-unit>
        <trans-unit id="c29ede2e39eca25683627a84bf1a76ac20119bd7" translate="yes" xml:space="preserve">
          <source>Source Filters</source>
          <target state="translated">소스 필터</target>
        </trans-unit>
        <trans-unit id="ade8f2661e9afaab2f2ac27ea8394747efc3b4bf" translate="yes" xml:space="preserve">
          <source>Source Handler</source>
          <target state="translated">소스 핸들러</target>
        </trans-unit>
        <trans-unit id="862ba12e5a4342d2fb92f862ee8e26706e1ba4d8" translate="yes" xml:space="preserve">
          <source>Source code locations, even if available, can often be missing or misleading if the compiler has e.g. inlined code. Optimizer can make matching the source code and the object code quite challenging.</source>
          <target state="translated">컴파일러에 인라인 코드가있는 경우 소스 코드 위치가 사용 가능하더라도 종종 누락되거나 오도 될 수 있습니다. 옵티마이 저는 소스 코드와 오브젝트 코드를 일치시키는 것을 매우 어렵게 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="145cfa7abc78d317a3cc42e7465f11df70966408" translate="yes" xml:space="preserve">
          <source>Source detection stuff added by Steve Purkis</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0272509bdb0dc4d43ea57d6e30f085a388335e1" translate="yes" xml:space="preserve">
          <source>Source documentation is created by putting POD comments into the C source, like this:</source>
          <target state="translated">소스 문서는 다음과 같이 POD 주석을 C 소스에 넣어서 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="4e42a4c9cdabac1017a64b490d8e6fd830b2d27a" translate="yes" xml:space="preserve">
          <source>Source filtering is an immensely powerful feature of recent versions of Perl. It allows one to extend the language itself (e.g. the Switch module), to simplify the language (e.g. Language::Pythonesque), or to completely recast the language (e.g. Lingua::Romana::Perligata). Effectively, it allows one to use the full power of Perl as its own, recursively applied, macro language.</source>
          <target state="translated">소스 필터링은 최신 버전의 Perl에서 엄청나게 강력한 기능입니다. 언어 자체 (예 : 스위치 모듈)를 확장하거나 언어 (예 : Language :: Pythonesque)를 단순화하거나 언어 (예 : Lingua :: Romana :: Perligata)를 완전히 다시 변환 할 수 있습니다. 실제로 Perl의 모든 기능을 자체적으로 재귀 적으로 적용되는 매크로 언어로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="83fa9e2aac616eaf300f336da8ba4cb15a670bf8" translate="yes" xml:space="preserve">
          <source>Source filters activated within &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; leak out into whichever</source>
          <target state="translated">내 활성화 소스 필터 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 어느로 누출</target>
        </trans-unit>
        <trans-unit id="29b60a7012567152c7f8bb1a380fa37b7673b6a3" translate="yes" xml:space="preserve">
          <source>Source filters activated within &lt;code&gt;eval&lt;/code&gt; leak out into whichever file scope is currently being compiled. To give an example with the CPAN module &lt;a href=&quot;Semi::Semicolons&quot;&gt;Semi::Semicolons&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="800c2a6e745195ecf7cc595cd16957a9d13fb318" translate="yes" xml:space="preserve">
          <source>Source filters activated within the evaluated code apply to the code itself.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da4d1a2fe52cc093111f41dbe07243489fb88fda" translate="yes" xml:space="preserve">
          <source>Source filters apply only to byte streams</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23c4984b5ea778bfe1a620b2921096dd64ef1a0a" translate="yes" xml:space="preserve">
          <source>Source filters only work on the string level, thus are highly limited in its ability to change source code on the fly. It cannot detect comments, quoted strings, heredocs, it is no replacement for a real parser. The only stable usage for source filters are encryption, compression, or the byteloader, to translate binary code back to source code.</source>
          <target state="translated">소스 필터는 문자열 수준에서만 작동하므로 소스 코드를 즉시 변경하는 기능이 크게 제한됩니다. 주석, 따옴표 붙은 문자열, heredocs를 감지 할 수 없으며 실제 구문 분석기를 대체하지 않습니다. 소스 필터의 안정적인 사용법은 이진 코드를 다시 소스 코드로 변환하는 암호화, 압축 또는 바이트 로더입니다.</target>
        </trans-unit>
        <trans-unit id="80de4aac92ca7a214fcac217051e36befa5aa31a" translate="yes" xml:space="preserve">
          <source>Source for Perl documentation</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6cf561fd42e8003d80556309fdb07a79bace6a7b" translate="yes" xml:space="preserve">
          <source>Source of the ISO 639-2 codes.</source>
          <target state="translated">ISO 639-2 코드의 출처.</target>
        </trans-unit>
        <trans-unit id="178db77b6a3b9b6df2ef880ae7bdafacae37b3c6" translate="yes" xml:space="preserve">
          <source>Source of the ISO 639-5 codes.</source>
          <target state="translated">ISO 639-5 코드의 출처.</target>
        </trans-unit>
        <trans-unit id="b69498a9aee25a26e6f9b5b4bc9ecc63222abc92" translate="yes" xml:space="preserve">
          <source>SourceHandler</source>
          <target state="translated">SourceHandler</target>
        </trans-unit>
        <trans-unit id="8644212c6ba60e5d4b37bed3eca56024c125205f" translate="yes" xml:space="preserve">
          <source>SourceHandlers</source>
          <target state="translated">SourceHandlers</target>
        </trans-unit>
        <trans-unit id="2eb56be3c2d93cdab0c52e677e3167dfddb30ac5" translate="yes" xml:space="preserve">
          <source>Sources</source>
          <target state="translated">Sources</target>
        </trans-unit>
        <trans-unit id="0933c3d8de99d538b1745c97c9ac4e0808ab779e" translate="yes" xml:space="preserve">
          <source>Sources of further information</source>
          <target state="translated">추가 정보 출처</target>
        </trans-unit>
        <trans-unit id="35fda17ff05f63e9061208c2dd2aaaf98790e921" translate="yes" xml:space="preserve">
          <source>South Africa</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1ffb4c07982ffdd1d32da2ad256d5f400cca0af" translate="yes" xml:space="preserve">
          <source>South America</source>
          <target state="translated">남아메리카</target>
        </trans-unit>
        <trans-unit id="ac6a60017b0bf8bff41d9bd208e6ef210c47fbdf" translate="yes" xml:space="preserve">
          <source>South Carolina</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f082fd9f31b253e1bc875b4f98b8b4196b3c96c9" translate="yes" xml:space="preserve">
          <source>Space after each comma.</source>
          <target state="translated">각 쉼표 뒤에 공백이 있습니다.</target>
        </trans-unit>
        <trans-unit id="b842d2b9fb013f376f25c0749d5ad88cdb3e09d2" translate="yes" xml:space="preserve">
          <source>Space after last parenthesis matching on current line.</source>
          <target state="translated">현재 줄에서 마지막 괄호 뒤의 공백.</target>
        </trans-unit>
        <trans-unit id="155b83258e151629b360ae86e49e0abf46f96413" translate="yes" xml:space="preserve">
          <source>Space around a &quot;complex&quot; subscript (inside brackets).</source>
          <target state="translated">&quot;복잡한&quot;첨자 주위 공간 (괄호 안에).</target>
        </trans-unit>
        <trans-unit id="3f9d9d7fddff18fb290d25d4e2d47eb10b024565" translate="yes" xml:space="preserve">
          <source>Space around most operators.</source>
          <target state="translated">대부분의 운영자 주변 공간.</target>
        </trans-unit>
        <trans-unit id="01ea9b6b043a2469906ded26f3a48de8eaf9e6e3" translate="yes" xml:space="preserve">
          <source>Space before the opening curly of a multi-line BLOCK.</source>
          <target state="translated">여러 줄의 블록이 열리기 전의 공백.</target>
        </trans-unit>
        <trans-unit id="1109418eced3ecb23f96484aec5504c863ea2053" translate="yes" xml:space="preserve">
          <source>Spaces in the argument delimit distinct patterns, so &lt;code&gt;&lt;a href=&quot;../functions/glob&quot;&gt;glob&lt;/a&gt;('*.exe *.dll')&lt;/code&gt; globs all filenames that end in &lt;code&gt;.exe&lt;/code&gt; or &lt;code&gt;.dll&lt;/code&gt;. If you want to put in literal spaces in the glob pattern, you can escape them with either double quotes, or backslashes. e.g. &lt;code&gt;&lt;a href=&quot;../functions/glob&quot;&gt;glob&lt;/a&gt;('c:/&quot;Program Files&quot;/*/*.dll')&lt;/code&gt; , or &lt;code&gt;&lt;a href=&quot;../functions/glob&quot;&gt;glob&lt;/a&gt;('c:/Program\ Files/*/*.dll')&lt;/code&gt; . The argument is tokenized using &lt;code&gt;Text::ParseWords::parse_line()&lt;/code&gt; , so see &lt;a href=&quot;../text/parsewords&quot;&gt;Text::ParseWords&lt;/a&gt; for details of the quoting rules used.</source>
          <target state="translated">인수의 공백은 고유 한 패턴을 구분하므로 &lt;code&gt;&lt;a href=&quot;../functions/glob&quot;&gt;glob&lt;/a&gt;('*.exe *.dll')&lt;/code&gt; 은 &lt;code&gt;.exe&lt;/code&gt; 또는 &lt;code&gt;.dll&lt;/code&gt; 로 끝나는 모든 파일 이름을 붙 입니다. glob 패턴으로 리터럴 공백을 넣으려면 큰 따옴표 또는 백 슬래시로 이스케이프 처리 할 수 ​​있습니다. 예를 들어 &lt;code&gt;&lt;a href=&quot;../functions/glob&quot;&gt;glob&lt;/a&gt;('c:/&quot;Program Files&quot;/*/*.dll')&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;../functions/glob&quot;&gt;glob&lt;/a&gt;('c:/Program\ Files/*/*.dll')&lt;/code&gt; 입니다. 인수는 &lt;code&gt;Text::ParseWords::parse_line()&lt;/code&gt; 사용하여 토큰 화 되므로 사용 된 인용 규칙에 대한 자세한 내용 은 &lt;a href=&quot;../text/parsewords&quot;&gt;Text :: ParseWords&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
