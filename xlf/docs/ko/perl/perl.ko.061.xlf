<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="perl">
    <body>
      <group id="perl">
        <trans-unit id="065d987b91e5e5831e84ee6eb6792bbd1900fe0e" translate="yes" xml:space="preserve">
          <source>The old behaviour of immediate croaking can be re-instated by setting &lt;code&gt;$Storable::accept_future_minor&lt;/code&gt; to some &lt;code&gt;FALSE&lt;/code&gt; value.</source>
          <target state="translated">&lt;code&gt;$Storable::accept_future_minor&lt;/code&gt; 를 &lt;code&gt;FALSE&lt;/code&gt; 값 으로 설정하면 즉각적인 크로 킹의 이전 동작을 다시 시작할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5b386f850ac3d208fd4890f0e6e16aecfa5e9221" translate="yes" xml:space="preserve">
          <source>The old display format style, which can have values &lt;code&gt;&quot;cartesian&quot;&lt;/code&gt; or &lt;code&gt;&quot;polar&quot;&lt;/code&gt; , can be changed using the &lt;code&gt;&quot;style&quot;&lt;/code&gt; parameter.</source>
          <target state="translated">&lt;code&gt;&quot;cartesian&quot;&lt;/code&gt; 또는 &lt;code&gt;&quot;polar&quot;&lt;/code&gt; 값을 가질 수있는 이전 표시 형식 스타일 은 &lt;code&gt;&quot;style&quot;&lt;/code&gt; 매개 변수를 사용하여 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e9569a2edc0d7e856dea14bff6ac690edcc52042" translate="yes" xml:space="preserve">
          <source>The old display format style, which can have values &lt;code&gt;&quot;cartesian&quot;&lt;/code&gt; or &lt;code&gt;&quot;polar&quot;&lt;/code&gt;, can be changed using the &lt;code&gt;&quot;style&quot;&lt;/code&gt; parameter.</source>
          <target state="translated">&lt;code&gt;&quot;cartesian&quot;&lt;/code&gt; 또는 &lt;code&gt;&quot;polar&quot;&lt;/code&gt; 값을 가질 수있는 이전 표시 형식 스타일 은 &lt;code&gt;&quot;style&quot;&lt;/code&gt; 매개 변수를 사용하여 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4ffd1da07401f04d08ba15b9c723b21da5d25d24" translate="yes" xml:space="preserve">
          <source>The old form of &lt;code&gt;gv_init_pvn()&lt;/code&gt;. It does not work with UTF-8 strings, as it has no flags parameter. If the &lt;code&gt;multi&lt;/code&gt; parameter is set, the &lt;code&gt;GV_ADDMULTI&lt;/code&gt; flag will be passed to &lt;code&gt;gv_init_pvn()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;gv_init_pvn()&lt;/code&gt; 의 이전 형식 . 플래그 매개 변수가 없기 때문에 UTF-8 문자열에서는 작동하지 않습니다. 경우] &lt;code&gt;multi&lt;/code&gt; 파라미터가 설정되어 &lt;code&gt;GV_ADDMULTI&lt;/code&gt; 의 플래그가 전달 될 &lt;code&gt;gv_init_pvn()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e3404a80aca7096e4f7cc6df65a56468be124f24" translate="yes" xml:space="preserve">
          <source>The old form of gv_init_pvn(). It does not work with UTF8 strings, as it has no flags parameter. If the &lt;code&gt;multi&lt;/code&gt; parameter is set, the GV_ADDMULTI flag will be passed to gv_init_pvn().</source>
          <target state="translated">gv_init_pvn ()의 이전 형식입니다. flags 매개 변수가 없으므로 UTF8 문자열에서는 작동하지 않습니다. 경우] &lt;code&gt;multi&lt;/code&gt; 파라미터가 설정되어 상기 플래그가 GV_ADDMULTI gv_init_pvn에 전달한다 ().</target>
        </trans-unit>
        <trans-unit id="79188e84f37b880e4a772b5ff3206627de3b874e" translate="yes" xml:space="preserve">
          <source>The old home for the module tests, you shouldn't put anything new in here. There are still some bits and pieces hanging around in here that need to be moved. Perhaps you could move them? Thanks!</source>
          <target state="translated">모듈 테스트를위한 오래된 집은 여기에 새로운 것을 넣지 말아야합니다. 여전히 움직일 필요가있는 몇 가지 비트와 조각이 여기에 있습니다. 아마도 당신은 그들을 움직일 수 있습니까? 감사!</target>
        </trans-unit>
        <trans-unit id="37d530fbe2e5d190496e0bd800701dfa6c514e1c" translate="yes" xml:space="preserve">
          <source>The old package delimiter was a single quote, but double colon is now the preferred delimiter, in part because it's more readable to humans, and in part because it's more readable to &lt;b&gt;emacs&lt;/b&gt; macros. It also makes C++ programmers feel like they know what's going on--as opposed to using the single quote as separator, which was there to make Ada programmers feel like they knew what was going on. Because the old-fashioned syntax is still supported for backwards compatibility, if you try to use a string like &lt;code&gt;&quot;This is $owner's house&quot;&lt;/code&gt; , you'll be accessing &lt;code&gt;$owner::s&lt;/code&gt; ; that is, the $s variable in package &lt;code&gt;owner&lt;/code&gt; , which is probably not what you meant. Use braces to disambiguate, as in &lt;code&gt;&quot;This is ${owner}'s house&quot;&lt;/code&gt; .</source>
          <target state="translated">이전 패키지 구분 기호는 작은 따옴표 였지만 이제는 이중 콜론이 선호되는 구분 기호입니다. 부분적으로는 사람이 더 읽기 쉽고 일부는 &lt;b&gt;emacs&lt;/b&gt; 매크로 에서 더 읽기 &lt;b&gt;쉽습니다&lt;/b&gt; . 또한 C ++ 프로그래머는 작은 따옴표를 구분 기호로 사용하는 것과 달리 Ada 프로그래머가 무슨 일이 일어나고 있는지 알고있는 것처럼 느끼게하는 것과는 달리 진행 상황을 알고있는 것처럼 느끼게합니다. 구식 구문은 이전 버전과의 호환성을 위해 계속 지원되므로 &lt;code&gt;&quot;This is $owner's house&quot;&lt;/code&gt; 와 같은 문자열을 사용하려고하면 &lt;code&gt;$owner::s&lt;/code&gt; 액세스하게됩니다 . 즉, package &lt;code&gt;owner&lt;/code&gt; 의 $ s 변수 는 아마도 의도하지 않은 것입니다. &lt;code&gt;&quot;This is ${owner}'s house&quot;&lt;/code&gt; 와 같이 중괄호를 사용하여 명확하게하십시오..</target>
        </trans-unit>
        <trans-unit id="511ae26f8725e1c7736ec75894aed8905e42064b" translate="yes" xml:space="preserve">
          <source>The old package delimiter was a single quote, but double colon is now the preferred delimiter, in part because it's more readable to humans, and in part because it's more readable to &lt;b&gt;emacs&lt;/b&gt; macros. It also makes C++ programmers feel like they know what's going on--as opposed to using the single quote as separator, which was there to make Ada programmers feel like they knew what was going on. Because the old-fashioned syntax is still supported for backwards compatibility, if you try to use a string like &lt;code&gt;&quot;This is $owner's house&quot;&lt;/code&gt;, you'll be accessing &lt;code&gt;$owner::s&lt;/code&gt;; that is, the $s variable in package &lt;code&gt;owner&lt;/code&gt;, which is probably not what you meant. Use braces to disambiguate, as in &lt;code&gt;&quot;This is ${owner}'s house&quot;&lt;/code&gt;.</source>
          <target state="translated">이전 패키지 구분 기호는 작은 따옴표 였지만 이중 콜론은 부분적으로는 사람이 더 쉽게 읽을 수 있고 부분적으로는 &lt;b&gt;emacs&lt;/b&gt; 매크로 가 더 쉽게 읽을 수 있기 때문에 이제 선호되는 구분 기호 입니다. 또한 C ++ 프로그래머는 작은 따옴표를 구분 기호로 사용하는 것과는 반대로 Ada 프로그래머가 무슨 일이 일어나고 있는지 알고있는 것처럼 느끼게하는 것과는 달리 무슨 일이 일어나고 있는지 알고있는 것처럼 느끼게합니다. 구식 구문은 이전 버전과의 호환성을 위해 여전히 지원되기 때문에 &lt;code&gt;&quot;This is $owner's house&quot;&lt;/code&gt; 와 같은 문자열을 사용하려고하면 &lt;code&gt;$owner::s&lt;/code&gt; 액세스하게됩니다 . 즉, 패키지 &lt;code&gt;owner&lt;/code&gt; 의 $ s 변수 는 아마도 당신이 의미 한 바가 아닐 것입니다. &lt;code&gt;&quot;This is ${owner}'s house&quot;&lt;/code&gt; 와 같이 중괄호를 사용하여 명확하게합니다..</target>
        </trans-unit>
        <trans-unit id="d9379928fc066063abf44caaff061ee5071ad9c7" translate="yes" xml:space="preserve">
          <source>The old style indented the note:</source>
          <target state="translated">이전 스타일은 메모를 들여 쓰기했습니다.</target>
        </trans-unit>
        <trans-unit id="3d9dec9262d361c18938bccf6c6a18acfa10894f" translate="yes" xml:space="preserve">
          <source>The older (and possibly obsolete) libraries &lt;a href=&quot;Pod::PXML&quot;&gt;Pod::PXML&lt;/a&gt;, &lt;a href=&quot;Pod::XML&quot;&gt;Pod::XML&lt;/a&gt;</source>
          <target state="translated">오래된 (그리고 쓸모없는) 라이브러리 &lt;a href=&quot;Pod::PXML&quot;&gt;Pod :: PXML&lt;/a&gt; , &lt;a href=&quot;Pod::XML&quot;&gt;Pod :: XML&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e6c9fb581904d8c9128af585c935239bf8557de2" translate="yes" xml:space="preserve">
          <source>The older (and possibly obsolete) libraries &lt;a href=&quot;http://search.cpan.org/perldoc/Pod::PXML&quot;&gt;Pod::PXML&lt;/a&gt;, &lt;a href=&quot;http://search.cpan.org/perldoc/Pod::XML&quot;&gt;Pod::XML&lt;/a&gt;</source>
          <target state="translated">오래된 (그리고 쓸모가없는) 라이브러리 &lt;a href=&quot;http://search.cpan.org/perldoc/Pod::PXML&quot;&gt;Pod :: PXML&lt;/a&gt; , &lt;a href=&quot;http://search.cpan.org/perldoc/Pod::XML&quot;&gt;Pod :: XML&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="bf3a69ba409143423723e457fea838a29577af44" translate="yes" xml:space="preserve">
          <source>The older libraries &lt;a href=&quot;Pod::PXML&quot;&gt;Pod::PXML&lt;/a&gt;, &lt;a href=&quot;Pod::XML&quot;&gt;Pod::XML&lt;/a&gt;, &lt;a href=&quot;Pod::SAX&quot;&gt;Pod::SAX&lt;/a&gt;</source>
          <target state="translated">이전 라이브러리 &lt;a href=&quot;Pod::PXML&quot;&gt;Pod :: PXML&lt;/a&gt; , &lt;a href=&quot;Pod::XML&quot;&gt;Pod :: XML&lt;/a&gt; , &lt;a href=&quot;Pod::SAX&quot;&gt;Pod :: SAX&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="da753c735f79a0349646d5159490ba674b8d624f" translate="yes" xml:space="preserve">
          <source>The older libraries &lt;a href=&quot;http://search.cpan.org/perldoc/Pod::PXML&quot;&gt;Pod::PXML&lt;/a&gt;, &lt;a href=&quot;http://search.cpan.org/perldoc/Pod::XML&quot;&gt;Pod::XML&lt;/a&gt;, &lt;a href=&quot;http://search.cpan.org/perldoc/Pod::SAX&quot;&gt;Pod::SAX&lt;/a&gt;</source>
          <target state="translated">이전 라이브러리 &lt;a href=&quot;http://search.cpan.org/perldoc/Pod::PXML&quot;&gt;Pod :: PXML&lt;/a&gt; , &lt;a href=&quot;http://search.cpan.org/perldoc/Pod::XML&quot;&gt;Pod :: XML&lt;/a&gt; , &lt;a href=&quot;http://search.cpan.org/perldoc/Pod::SAX&quot;&gt;Pod :: SAX&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="995ae7aa276ffe30824f52880be0efab53f1e92d" translate="yes" xml:space="preserve">
          <source>The one argument form of add_bits() takes a $bitstring of &quot;1&quot; and &quot;0&quot; chars as argument. It's a shorthand for &lt;code&gt;$ctx-&amp;gt;add_bits(&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;(&quot;B*&quot;,
$bitstring), &lt;a href=&quot;functions/length&quot;&gt;length&lt;/a&gt;($bitstring))&lt;/code&gt; .</source>
          <target state="translated">add_bits ()의 한 인수 형식은 $ bitstring &quot;1&quot;및 &quot;0&quot;문자를 인수로 사용합니다. &lt;code&gt;$ctx-&amp;gt;add_bits(&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;(&quot;B*&quot;, $bitstring), &lt;a href=&quot;functions/length&quot;&gt;length&lt;/a&gt;($bitstring))&lt;/code&gt; 의 줄임말입니다 .</target>
        </trans-unit>
        <trans-unit id="1b86570e54f795ca97d5fe14e7650da16943e0a5" translate="yes" xml:space="preserve">
          <source>The one argument form of add_bits() takes a $bitstring of &quot;1&quot; and &quot;0&quot; chars as argument. It's a shorthand for &lt;code&gt;$ctx-&amp;gt;add_bits(pack(&quot;B*&quot;, $bitstring), length($bitstring))&lt;/code&gt;.</source>
          <target state="translated">add_bits ()의 한 인수 형식은 &quot;1&quot;및 &quot;0&quot;문자의 $ bitstring을 인수로 사용합니다. &lt;code&gt;$ctx-&amp;gt;add_bits(pack(&quot;B*&quot;, $bitstring), length($bitstring))&lt;/code&gt; 의 약어입니다 .</target>
        </trans-unit>
        <trans-unit id="7fb0ed6067910ab4f7c54b4b88cf43df00178824" translate="yes" xml:space="preserve">
          <source>The one parameter calling convention also still works.</source>
          <target state="translated">하나의 매개 변수 호출 규칙도 여전히 작동합니다.</target>
        </trans-unit>
        <trans-unit id="80912f94b4001d6702c4a5ac8c13128730d9bdf7" translate="yes" xml:space="preserve">
          <source>The one user (apart from the superuser) who has absolute control over a &lt;b&gt;file&lt;/b&gt;. A file may also have a &lt;b&gt;group&lt;/b&gt; of users who may exercise joint ownership if the real owner permits it. See &lt;b&gt;permission bits&lt;/b&gt;.</source>
          <target state="translated">&lt;b&gt;파일을&lt;/b&gt; 완전히 제어 할 수있는 한 명의 사용자 (수퍼 유저 제외) . 파일 에는 실제 소유자가 허용하는 경우 공동 소유권을 행사할 수있는 사용자 &lt;b&gt;그룹&lt;/b&gt; 이 있을 수도 있습니다 . &lt;b&gt;권한 비트를&lt;/b&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ecb6da0a473e0cefde4e91abce89bab9a6e1b78a" translate="yes" xml:space="preserve">
          <source>The one-shot interface allows you to force the creation of a zip64 zip file by including the &lt;code&gt;Zip64&lt;/code&gt; option.</source>
          <target state="translated">원샷 인터페이스를 사용하면 &lt;code&gt;Zip64&lt;/code&gt; 옵션 을 포함하여 zip64 zip 파일을 강제로 생성 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="bf794f433c5b5ee5b62cabad4f9e0efe662e76bb" translate="yes" xml:space="preserve">
          <source>The only absolutely mandatory method. Called when the layer is pushed onto the stack. The &lt;code&gt;mode&lt;/code&gt; argument may be NULL if this occurs post-open. The &lt;code&gt;arg&lt;/code&gt; will be non-&lt;code&gt;NULL&lt;/code&gt; if an argument string was passed. In most cases this should call &lt;code&gt;PerlIOBase_pushed()&lt;/code&gt; to convert &lt;code&gt;mode&lt;/code&gt; into the appropriate &lt;code&gt;PERLIO_F_XXXXX&lt;/code&gt; flags in addition to any actions the layer itself takes. If a layer is not expecting an argument it need neither save the one passed to it, nor provide &lt;code&gt;Getarg()&lt;/code&gt; (it could perhaps &lt;code&gt;Perl_warn&lt;/code&gt; that the argument was un-expected).</source>
          <target state="translated">유일한 필수 방법입니다. 레이어가 스택으로 밀릴 때 호출됩니다. &lt;code&gt;mode&lt;/code&gt; 이 포스트 오픈 발생하면 인수는 NULL이 될 수 있습니다. &lt;code&gt;arg&lt;/code&gt; 아닌 것 &lt;code&gt;NULL&lt;/code&gt; 인수 문자열이 전달 된 경우. 대부분의 경우 레이어 자체에서 수행하는 작업 외에도 &lt;code&gt;PerlIOBase_pushed()&lt;/code&gt; 를 호출 하여 &lt;code&gt;mode&lt;/code&gt; 를 적절한 &lt;code&gt;PERLIO_F_XXXXX&lt;/code&gt; 플래그 로 변환 해야합니다 . 레이어가 인수를 기대하지 않으면 전달 된 레이어를 저장할 필요도없고 &lt;code&gt;Getarg()&lt;/code&gt; 제공 할 필요도 없습니다 (아마도 &lt;code&gt;Perl_warn&lt;/code&gt; 이 인수가 예상치 않았을 수도 있음 ).</target>
        </trans-unit>
        <trans-unit id="90a79e3c54ca5ed09d00dcfacad6096dece33202" translate="yes" xml:space="preserve">
          <source>The only characters this accepts are the decimal digits '0'..'9'.</source>
          <target state="translated">허용되는 유일한 문자는 십진수 '0'.. '9'입니다.</target>
        </trans-unit>
        <trans-unit id="8efd8a42e658c0f7e91c83e2d2d53f100f4033a8" translate="yes" xml:space="preserve">
          <source>The only differences are due to the fact that &lt;code&gt;string_vianame&lt;/code&gt; is run-time and &lt;code&gt;\N{}&lt;/code&gt; is compile time. You can't interpolate inside a &lt;code&gt;\N{}&lt;/code&gt; , (so &lt;code&gt;\N{$variable}&lt;/code&gt; doesn't work); and if the input name is unknown, &lt;code&gt;string_vianame&lt;/code&gt; returns &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; instead of it being a syntax error.</source>
          <target state="translated">유일한 차이점은 &lt;code&gt;string_vianame&lt;/code&gt; 이 런타임이고 &lt;code&gt;\N{}&lt;/code&gt; 이 컴파일 시간 이라는 사실 때문입니다 . &lt;code&gt;\N{}&lt;/code&gt; 내부에서 보간 할 수 없으므로 &lt;code&gt;\N{$variable}&lt;/code&gt; 이 작동하지 않습니다. 입력 이름을 알 수 없으면 &lt;code&gt;string_vianame&lt;/code&gt; 은 구문 오류가 아닌 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="77845b478b84dee4e594bd5bbec241147d4e6e80" translate="yes" xml:space="preserve">
          <source>The only differences are due to the fact that &lt;code&gt;string_vianame&lt;/code&gt; is run-time and &lt;code&gt;\N{}&lt;/code&gt; is compile time. You can't interpolate inside a &lt;code&gt;\N{}&lt;/code&gt;, (so &lt;code&gt;\N{$variable}&lt;/code&gt; doesn't work); and if the input name is unknown, &lt;code&gt;string_vianame&lt;/code&gt; returns &lt;code&gt;undef&lt;/code&gt; instead of it being a syntax error.</source>
          <target state="translated">유일한 차이점은 &lt;code&gt;string_vianame&lt;/code&gt; 이 런타임이고 &lt;code&gt;\N{}&lt;/code&gt; 이 컴파일 시간 이라는 사실 때문입니다 . &lt;code&gt;\N{}&lt;/code&gt; 내부를 보간 할 수 없습니다 (그래서 &lt;code&gt;\N{$variable}&lt;/code&gt; 는 작동하지 않습니다). 입력 이름을 알 수없는 경우 &lt;code&gt;string_vianame&lt;/code&gt; 은 구문 오류 대신 &lt;code&gt;undef&lt;/code&gt; 를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="341b8df1dab5c18fe08d27199395d7d12fe5908e" translate="yes" xml:space="preserve">
          <source>The only flag specified this time was G_SCALAR. That means that the &lt;code&gt;@_&lt;/code&gt; array will be created and that the value returned by</source>
          <target state="translated">이번에 지정된 유일한 플래그는 G_SCALAR입니다. 즉, &lt;code&gt;@_&lt;/code&gt; 배열이 만들어지고 값이</target>
        </trans-unit>
        <trans-unit id="1be9c07fcdeba873e922d933912b59d6dffd7f9b" translate="yes" xml:space="preserve">
          <source>The only interpolation is removal of &lt;code&gt;\&lt;/code&gt; from pairs of &lt;code&gt;\\&lt;/code&gt; . Therefore &lt;code&gt;&quot;-&quot;&lt;/code&gt; in &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr'''&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/y&quot;&gt;y'''&lt;/a&gt;&lt;/code&gt; is treated literally as a hyphen and no character range is available. &lt;code&gt;\1&lt;/code&gt; in the replacement of &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s'''&lt;/a&gt;&lt;/code&gt; does not work as &lt;code&gt;$1&lt;/code&gt; .</source>
          <target state="translated">유일한 보간은 &lt;code&gt;\\&lt;/code&gt; 쌍에서 &lt;code&gt;\&lt;/code&gt; 를 제거하는 것입니다 . 따라서 &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr'''&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;functions/y&quot;&gt;y'''&lt;/a&gt;&lt;/code&gt; &lt;code&gt;&quot;-&quot;&lt;/code&gt; 는 문자 그대로 하이픈으로 취급되며 사용 가능한 문자 범위가 없습니다. &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s'''&lt;/a&gt;&lt;/code&gt; 대신 &lt;code&gt;\1&lt;/code&gt; 은 &lt;code&gt;$1&lt;/code&gt; 작동하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="02eece87de941c6c62eda48e906abba6c3ece7c9" translate="yes" xml:space="preserve">
          <source>The only interpolation is removal of &lt;code&gt;\&lt;/code&gt; from pairs of &lt;code&gt;\\&lt;/code&gt;. Therefore &lt;code&gt;&quot;-&quot;&lt;/code&gt; in &lt;code&gt;tr'''&lt;/code&gt; and &lt;code&gt;y'''&lt;/code&gt; is treated literally as a hyphen and no character range is available. &lt;code&gt;\1&lt;/code&gt; in the replacement of &lt;code&gt;s'''&lt;/code&gt; does not work as &lt;code&gt;$1&lt;/code&gt;.</source>
          <target state="translated">유일한 보간법은 &lt;code&gt;\\&lt;/code&gt; 쌍에서 &lt;code&gt;\&lt;/code&gt; 를 제거하는 것입니다 . 따라서 &lt;code&gt;tr'''&lt;/code&gt; 및 &lt;code&gt;y'''&lt;/code&gt; &lt;code&gt;&quot;-&quot;&lt;/code&gt; 는 문자 그대로 하이픈으로 처리되며 문자 범위를 사용할 수 없습니다. &lt;code&gt;s'''&lt;/code&gt; 대체에서 &lt;code&gt;\1&lt;/code&gt; 은 &lt;code&gt;$1&lt;/code&gt; 로 작동하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="12717cd3a47ff8f730f2ca2276f3a722ee0a85b7" translate="yes" xml:space="preserve">
          <source>The only issue left is to how to bootstrap</source>
          <target state="translated">남아있는 유일한 문제는 부트 스트랩 방법입니다.</target>
        </trans-unit>
        <trans-unit id="77cda32153e2808e7ed17b43ef801a42c30a29bd" translate="yes" xml:space="preserve">
          <source>The only kind of simple statement is an expression evaluated for its side-effects. Every simple statement must be terminated with a semicolon, unless it is the final statement in a block, in which case the semicolon is optional. But put the semicolon in anyway if the block takes up more than one line, because you may eventually add another line. Note that there are operators like &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; {}&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/sub&quot;&gt;sub&lt;/a&gt; {}&lt;/code&gt; , and &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt; {}&lt;/code&gt; that</source>
          <target state="translated">유일한 간단한 설명은 부작용에 대해 평가 된 표현식입니다. 모든 간단한 명령문은 블록의 마지막 명령문이 아닌 경우 세미콜론으로 끝나야합니다.이 경우 세미콜론은 선택 사항입니다. 그러나 블록이 둘 이상의 라인을 차지하면 세미콜론을 넣으십시오. 결국 다른 라인을 추가 할 수 있습니다. 이 같은 사업자이다하는 것으로 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; {}&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/sub&quot;&gt;sub&lt;/a&gt; {}&lt;/code&gt; , 그리고 &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt; {}&lt;/code&gt; 있음</target>
        </trans-unit>
        <trans-unit id="f705477ccbb186a38ab86005af82f68dd900e475" translate="yes" xml:space="preserve">
          <source>The only kind of simple statement is an expression evaluated for its side-effects. Every simple statement must be terminated with a semicolon, unless it is the final statement in a block, in which case the semicolon is optional. But put the semicolon in anyway if the block takes up more than one line, because you may eventually add another line. Note that there are operators like &lt;code&gt;eval {}&lt;/code&gt;, &lt;code&gt;sub {}&lt;/code&gt;, and &lt;code&gt;do {}&lt;/code&gt; that</source>
          <target state="translated">유일한 종류의 간단한 명령문은 부작용에 대해 평가되는 표현식입니다. 모든 간단한 문은 세미콜론으로 끝나야합니다. 단, 블록의 마지막 문이 아닌 경우 세미콜론이 선택 사항입니다. 그러나 블록이 한 줄 이상을 차지하는 경우 어쨌든 세미콜론을 넣으십시오. 결국 다른 줄을 추가 할 수 있기 때문입니다. &lt;code&gt;eval {}&lt;/code&gt; , &lt;code&gt;sub {}&lt;/code&gt; 및 &lt;code&gt;do {}&lt;/code&gt; 와 같은 연산자 가 있습니다.</target>
        </trans-unit>
        <trans-unit id="e309b7f80a25c25de4d7facad82c2d1078752823" translate="yes" xml:space="preserve">
          <source>The only legitimate use of this pragma is almost certainly just one per file, near the top, with file scope, as the file is likely going to only be written in one encoding. Further restrictions apply in Perls before v5.22 (see &lt;a href=&quot;#Prior-to-Perl-v5.22&quot;&gt;&quot;Prior to Perl v5.22&quot;&lt;/a&gt;).</source>
          <target state="translated">이 pragma의 유일한 합법적 인 사용은 파일이 하나의 인코딩으로 만 작성 될 가능성이 높기 때문에 파일 범위가있는 파일 당 거의 확실하게 맨 위 근처에 있습니다. 추가 제한 사항은 v5.22 이전의 Perls에 적용됩니다 ( &lt;a href=&quot;#Prior-to-Perl-v5.22&quot;&gt;&quot;Perl v5.22 이전 버전&quot;참조&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="3f747c4ca5428591254eb88eeb68548667575b4e" translate="yes" xml:space="preserve">
          <source>The only legitimate use of this pragma is almost certainly just one per file, near the top, with file scope, as the file is likely going to only be written in one encoding. Further restrictions apply in Perls before v5.22 (see &lt;a href=&quot;#Prior-to-Perl-v5.22&quot;&gt;Prior to Perl v5.22&lt;/a&gt;).</source>
          <target state="translated">이 pragma의 합법적 인 사용은 파일이 하나의 인코딩으로 만 작성 될 가능성이 높기 때문에 파일 범위와 함께 파일 당 하나당 거의 확실하게 파일 당 하나입니다. v5.22 &lt;a href=&quot;#Prior-to-Perl-v5.22&quot;&gt;이전의&lt;/a&gt; Perls에는 추가 제한 사항이 적용됩니다 ( Perl v5.22 이전 참조 ).</target>
        </trans-unit>
        <trans-unit id="34c58516de1f8035b02dd5ba10465691170b3177" translate="yes" xml:space="preserve">
          <source>The only multi-byte (or wide character) locale that Perl is ever likely to support is UTF-8. This is due to the difficulty of implementation, the fact that high quality UTF-8 locales are now published for every area of the world (&lt;a href=&quot;http://unicode.org/Public/cldr/latest/&quot;&gt;http://unicode.org/Public/cldr/latest/&lt;/a&gt;), and that failing all that you can use the &lt;a href=&quot;encode&quot;&gt;Encode&lt;/a&gt; module to translate to/from your locale. So, you'll have to do one of those things if you're using one of these locales, such as Big5 or Shift JIS. For UTF-8 locales, in Perls (pre v5.20) that don't have full UTF-8 locale support, they may work reasonably well (depending on your C library implementation) simply because both they and Perl store characters that take up multiple bytes the same way. However, some, if not most, C library implementations may not process the characters in the upper half of the Latin-1 range (128 - 255) properly under &lt;code&gt;LC_CTYPE&lt;/code&gt; . To see if a character is a particular type under a locale, Perl uses the functions like &lt;code&gt;isalnum()&lt;/code&gt; . Your C library may not work for UTF-8 locales with those functions, instead only working under the newer wide library functions like &lt;code&gt;iswalnum()&lt;/code&gt; , which Perl does not use. These multi-byte locales are treated like single-byte locales, and will have the restrictions described below. Starting in Perl v5.22 a warning message is raised when Perl detects a multi-byte locale that it doesn't fully support.</source>
          <target state="translated">Perl이 지원할 수있는 유일한 멀티 바이트 (또는 넓은 문자) 로케일은 UTF-8입니다. 구현의 어려움, 고품질 UTF-8 로케일이 이제 전세계의 모든 영역 ( &lt;a href=&quot;http://unicode.org/Public/cldr/latest/&quot;&gt;http://unicode.org/Public/cldr/latest/&lt;/a&gt; )에 대해 게시되어 있으며 , 모든 것이 실패하기 때문입니다. &lt;a href=&quot;encode&quot;&gt;인코딩을&lt;/a&gt; 사용할 수 있습니다로케일로 /에서 번역 할 수있는 모듈. 따라서 Big5 또는 Shift JIS와 같은 이러한 로캘 중 하나를 사용하는 경우 이러한 작업 중 하나를 수행해야합니다. UTF-8 로케일의 경우, UTF-8 로케일이 완전히 지원되지 않는 Perls (이전 v5.20)에서는 로컬 라이브러리와 Perl이 모두 차지하는 문자를 저장하므로 C 라이브러리 구현에 따라 합리적으로 잘 작동 할 수 있습니다. 같은 방식으로 여러 바이트. 그러나 대부분은 아니지만 일부 C 라이브러리 구현은 &lt;code&gt;LC_CTYPE&lt;/code&gt; 에서 라틴 -1 범위 (128-255)의 상반부에있는 문자를 제대로 처리하지 못할 수 있습니다 . 로케일에서 문자가 특정 유형인지 확인하기 위해 Perl은 &lt;code&gt;isalnum()&lt;/code&gt; 과 같은 함수를 사용합니다 . C 라이브러리는 이러한 기능을 가진 UTF-8 로켈에서 작동하지 않을 수 있습니다.대신 다음과 같은 최신 라이브러리 기능에서만 작동합니다. &lt;code&gt;iswalnum()&lt;/code&gt; Perl이 사용하지 않는 iswalnum () 이러한 멀티 바이트 로케일은 단일 바이트 로케일처럼 취급되며 아래 설명 된 제한 사항이 있습니다. Perl v5.22부터 Perl이 완전히 지원하지 않는 멀티 바이트 로케일을 감지하면 경고 메시지가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="18871d07c0f1be22042f9cbee3498004b8a18ce9" translate="yes" xml:space="preserve">
          <source>The only multi-byte (or wide character) locale that Perl is ever likely to support is UTF-8. This is due to the difficulty of implementation, the fact that high quality UTF-8 locales are now published for every area of the world (&lt;a href=&quot;https://unicode.org/Public/cldr/2.0.1/&quot;&gt;https://unicode.org/Public/cldr/2.0.1/&lt;/a&gt; for ones that are already set-up, but from an earlier version; &lt;a href=&quot;https://unicode.org/Public/cldr/latest/&quot;&gt;https://unicode.org/Public/cldr/latest/&lt;/a&gt; for the most up-to-date, but you have to extract the POSIX information yourself), and that failing all that you can use the &lt;a href=&quot;encode&quot;&gt;Encode&lt;/a&gt; module to translate to/from your locale. So, you'll have to do one of those things if you're using one of these locales, such as Big5 or Shift JIS. For UTF-8 locales, in Perls (pre v5.20) that don't have full UTF-8 locale support, they may work reasonably well (depending on your C library implementation) simply because both they and Perl store characters that take up multiple bytes the same way. However, some, if not most, C library implementations may not process the characters in the upper half of the Latin-1 range (128 - 255) properly under &lt;code&gt;LC_CTYPE&lt;/code&gt;. To see if a character is a particular type under a locale, Perl uses the functions like &lt;code&gt;isalnum()&lt;/code&gt;. Your C library may not work for UTF-8 locales with those functions, instead only working under the newer wide library functions like &lt;code&gt;iswalnum()&lt;/code&gt;, which Perl does not use. These multi-byte locales are treated like single-byte locales, and will have the restrictions described below. Starting in Perl v5.22 a warning message is raised when Perl detects a multi-byte locale that it doesn't fully support.</source>
          <target state="translated">Perl이 지원할 가능성이있는 유일한 다중 바이트 (또는 와이드 문자) 로케일은 UTF-8입니다. 이는 구현의 어려움 때문이며, 고품질의 UTF-8 로케일이 이제 전 세계 모든 영역에 대해 게시된다는 사실입니다 ( 이미 설정된 항목의 경우 &lt;a href=&quot;https://unicode.org/Public/cldr/2.0.1/&quot;&gt;https://unicode.org/Public/cldr/2.0.1/).&lt;/a&gt; -up, 그러나 이전 버전에서; 가장 최신의 경우 &lt;a href=&quot;https://unicode.org/Public/cldr/latest/&quot;&gt;https://unicode.org/Public/cldr/latest/&lt;/a&gt; , 그러나 POSIX 정보를 직접 추출해야 함) 가능한 모든 것을 실패합니다. &lt;a href=&quot;encode&quot;&gt;인코딩&lt;/a&gt; 사용로케일로 /에서 번역 할 모듈. 따라서 Big5 또는 Shift JIS와 같은 이러한 로케일 중 하나를 사용하는 경우 이러한 작업 중 하나를 수행해야합니다. UTF-8 로케일의 경우 완전한 UTF-8 로케일을 지원하지 않는 Perls (v5.20 이전)에서는 둘 다 차지하는 문자를 저장하기 때문에 (C 라이브러리 구현에 따라) 합리적으로 잘 작동 할 수 있습니다. 같은 방식으로 여러 바이트. 그러나 대부분은 아니지만 일부 C 라이브러리 구현은 &lt;code&gt;LC_CTYPE&lt;/code&gt; 아래에서 Latin-1 범위 (128-255)의 위쪽 절반에있는 문자를 제대로 처리하지 못할 수 있습니다 . 문자가 로케일에서 특정 유형인지 확인하기 위해 Perl은 &lt;code&gt;isalnum()&lt;/code&gt; 과 같은 함수를 사용합니다 . C 라이브러리는 해당 함수를 사용하는 UTF-8 로케일에서 작동하지 않을 수 있으며 대신 다음과 같은 최신 라이브러리 함수에서만 작동합니다. &lt;code&gt;iswalnum()&lt;/code&gt; , Perl이 사용하지 않습니다. 이러한 멀티 바이트 로케일은 1 바이트 로케일처럼 취급되며 아래에 설명 된 제한 사항이 있습니다. Perl v5.22부터 Perl이 완전히 지원하지 않는 다중 바이트 로케일을 감지하면 경고 메시지가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="5c17b3d145791de4c679a21722f34ee793cec0ff" translate="yes" xml:space="preserve">
          <source>The only non-character property that Perl currently supports is Named Sequences, in which a sequence of code points is given a name and generally treated as a single entity. (Perl supports these via the &lt;code&gt;\N{...}&lt;/code&gt; double-quotish construct, &lt;a href=&quot;charnames#charnames%3A%3Astring_vianame%28name%29&quot;&gt;&quot;charnames::string_vianame(name)&quot; in charnames&lt;/a&gt;, and &lt;a href=&quot;Unicode::UCD#namedseq%28%29&quot;&gt;&quot;namedseq()&quot; in Unicode::UCD&lt;/a&gt;.</source>
          <target state="translated">Perl이 현재 지원하는 유일한 비 문자 속성은 명명 된 시퀀스로, 코드 포인트 시퀀스에 이름이 지정되고 일반적으로 단일 엔티티로 처리됩니다. (Perl은 &lt;code&gt;\N{...}&lt;/code&gt; 큰 따옴표 구조, &lt;a href=&quot;charnames#charnames%3A%3Astring_vianame%28name%29&quot;&gt;charnames의 &quot;charnames ::&lt;/a&gt; string_vianame (name)&quot; 및 &lt;a href=&quot;Unicode::UCD#namedseq%28%29&quot;&gt;Unicode :: UCD의 &quot;namedseq ()&quot;를 통해이를 지원&lt;/a&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="81ecbc2496d990405244fb5517f23afeb52e9228" translate="yes" xml:space="preserve">
          <source>The only non-character property that Perl currently supports is Named Sequences, in which a sequence of code points is given a name and generally treated as a single entity. (Perl supports these via the &lt;code&gt;\N{...}&lt;/code&gt; double-quotish construct, &lt;a href=&quot;charnames#charnames%3a%3astring_vianame(name)&quot;&gt;charnames::string_vianame(name) in charnames&lt;/a&gt;, and &lt;a href=&quot;unicode/ucd#namedseq()&quot;&gt;namedseq() in Unicode::UCD&lt;/a&gt;.</source>
          <target state="translated">Perl이 현재 지원하는 유일한 문자가 아닌 속성은 Named Sequences입니다. 여기서 일련의 코드 포인트에는 이름이 지정되고 일반적으로 단일 엔터티로 취급됩니다. Perl은 &lt;code&gt;\N{...}&lt;/code&gt; 큰 따옴표 구조, &lt;a href=&quot;charnames#charnames%3a%3astring_vianame(name)&quot;&gt;charnames의 charnames ::&lt;/a&gt; string_vianame (name) , 그리고 &lt;a href=&quot;unicode/ucd#namedseq()&quot;&gt;Unicode :: UCD의 namedseq ()를 통해이를 지원&lt;/a&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="4392ba6f21132243d1d665e363dbf9f2d5cd7f44" translate="yes" xml:space="preserve">
          <source>The only non-single-byte locale Perl supports is (starting in v5.20) UTF-8. This means that code points above 255 are treated as Unicode no matter what locale is in effect (since UTF-8 implies Unicode).</source>
          <target state="translated">1 바이트가 아닌 로케일 Perl이 지원하는 유일한 것은 (v5.20부터) UTF-8입니다. 즉, UTF-8이 유니 코드를 의미하기 때문에 255보다 큰 코드 포인트는 어떤 로캘이 적용되는지에 관계없이 유니 코드로 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="9a67bc69297226e55a92fe7a2acd416579cf6146" translate="yes" xml:space="preserve">
          <source>The only objective benefit to using &lt;code&gt;DirHandle&lt;/code&gt; is that it avoids namespace pollution by creating globs to hold directory handles.</source>
          <target state="translated">&lt;code&gt;DirHandle&lt;/code&gt; 사용의 유일한 객관적인 이점 은 디렉토리 핸들을 보유 할 glob를 작성하여 네임 스페이스 오염을 피한다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="29b92533d26d29124ecd17a1f17bcca141dd3115" translate="yes" xml:space="preserve">
          <source>The only other constraint is you must pre-declare how many tests you plan to run. This is in case something goes horribly wrong during the test and your test program aborts, or skips a test or whatever. You do this like so:</source>
          <target state="translated">다른 제약 조건은 실행할 테스트 수를 미리 선언해야한다는 것입니다. 테스트 중에 문제가 발생하여 테스트 프로그램이 중단되거나 테스트 등을 건너 뜁니다. 당신은 이렇게 이렇게 :</target>
        </trans-unit>
        <trans-unit id="c629e4aca342ff5d679b1354d5badb624d786fd5" translate="yes" xml:space="preserve">
          <source>The only place where the warning is not raised when it might ought to have been is if optimizations cause the whole pattern match to not even be attempted. For example, Perl may figure out that for a string to match a certain regular expression pattern, the string has to contain the substring &lt;code&gt;&quot;foobar&quot;&lt;/code&gt; . Before attempting the match, Perl may look for that substring, and if not found, immediately fail the match without actually trying it; so no warning gets generated even if the string contains an above-Unicode code point.</source>
          <target state="translated">경고가 발생했을 때 경고가 발생하지 않는 유일한 위치는 최적화로 인해 전체 패턴 일치가 시도되지 않는 경우입니다. 예를 들어, Perl은 문자열이 특정 정규식 패턴과 일치하기 위해서는 문자열에 &lt;code&gt;&quot;foobar&quot;&lt;/code&gt; 하위 문자열이 포함되어 있음을 알아낼 수 있습니다 . 일치를 시도하기 전에 Perl은 해당 하위 문자열을 찾을 수 있으며, 찾지 못하면 즉시 시도하지 않고 즉시 실패합니다. 따라서 문자열에 유니 코드 위의 코드 포인트가 포함되어 있어도 경고가 생성되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2a1424cb465056db403b0376b90df7285a39a496" translate="yes" xml:space="preserve">
          <source>The only place where the warning is not raised when it might ought to have been is if optimizations cause the whole pattern match to not even be attempted. For example, Perl may figure out that for a string to match a certain regular expression pattern, the string has to contain the substring &lt;code&gt;&quot;foobar&quot;&lt;/code&gt;. Before attempting the match, Perl may look for that substring, and if not found, immediately fail the match without actually trying it; so no warning gets generated even if the string contains an above-Unicode code point.</source>
          <target state="translated">그래야 할 때 경고가 발생하지 않는 유일한 곳은 최적화로 인해 전체 패턴 일치가 시도되지 않는 경우입니다. 예를 들어, Perl은 문자열이 특정 정규 표현식 패턴과 일치하려면 문자열에 하위 문자열 &lt;code&gt;&quot;foobar&quot;&lt;/code&gt; 가 포함되어야 함을 파악할 수 있습니다 . 일치를 시도하기 전에 Perl은 해당 하위 문자열을 찾을 수 있으며 발견되지 않으면 실제로 시도하지 않고 즉시 일치에 실패합니다. 따라서 문자열에 유니 코드 위의 코드 포인트가 포함되어 있어도 경고가 생성되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3f03961d151195642787106427ad37fb0df08a21" translate="yes" xml:space="preserve">
          <source>The only pragmas to be completely supported are: &lt;code&gt;use warnings&lt;/code&gt;, &lt;code&gt;use strict&lt;/code&gt;, &lt;code&gt;use bytes&lt;/code&gt;, &lt;code&gt;use integer&lt;/code&gt; and &lt;code&gt;use feature&lt;/code&gt;.</source>
          <target state="translated">완벽하게 지원하는 유일한 프라 그마은 다음과 같습니다 : &lt;code&gt;use warnings&lt;/code&gt; , &lt;code&gt;use strict&lt;/code&gt; , &lt;code&gt;use bytes&lt;/code&gt; , &lt;code&gt;use integer&lt;/code&gt; 및 &lt;code&gt;use feature&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c7dc3eb2b3b66b20134df38443b06998c7b78e71" translate="yes" xml:space="preserve">
          <source>The only purpose of this step is to create the needed directories, and let you know the names of these directories. From the output you can see that the directory for the extension is</source>
          <target state="translated">이 단계의 유일한 목적은 필요한 디렉토리를 작성하고 해당 디렉토리의 이름을 알려주는 것입니다. 출력에서 확장의 디렉토리가</target>
        </trans-unit>
        <trans-unit id="e4350c2629055827ad3a8b68cc619a2e785707ba" translate="yes" xml:space="preserve">
          <source>The only required argument is &lt;a href=&quot;IO::Socket#Domain&quot;&gt;&quot;Domain&quot; in IO::Socket&lt;/a&gt;.</source>
          <target state="translated">유일한 필수 인수는 &lt;a href=&quot;IO::Socket#Domain&quot;&gt;IO :: Socket의 &quot;Domain&quot;입니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8b743cce5d7490a9e24b6e3b1af9c9095cbf1cfd" translate="yes" xml:space="preserve">
          <source>The only required part is the first field, the name of a module (e.g. Foo::Bar, i.e.</source>
          <target state="translated">유일하게 필요한 부분은 모듈의 이름 인 첫 번째 필드입니다 (예 : Foo :: Bar, 즉</target>
        </trans-unit>
        <trans-unit id="18bf9d2d31226fde65cb844d15b4e9ac5dd2e6d9" translate="yes" xml:space="preserve">
          <source>The only significant values for &lt;code&gt;flags&lt;/code&gt; are &lt;code&gt;GV_SUPER&lt;/code&gt; and &lt;code&gt;SVf_UTF8&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;flags&lt;/code&gt; 에 대한 유일한 중요한 값 은 &lt;code&gt;GV_SUPER&lt;/code&gt; 및 &lt;code&gt;SVf_UTF8&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="a47d064470efbb85a4c64c4b51a76380fc85cda0" translate="yes" xml:space="preserve">
          <source>The only significant values for &lt;code&gt;flags&lt;/code&gt; are GV_SUPER and SVf_UTF8.</source>
          <target state="translated">&lt;code&gt;flags&lt;/code&gt; 중요한 값 은 GV_SUPER 및 SVf_UTF8입니다.</target>
        </trans-unit>
        <trans-unit id="27c03514e890f7e1e455be24f92d8de38867990a" translate="yes" xml:space="preserve">
          <source>The only thing to note is that, in both the static and virtual methods, the method name is not passed via the stack--it is used as the first parameter to</source>
          <target state="translated">정적 메소드와 가상 메소드 모두에서 메소드 이름이 스택을 통해 전달되지 않는다는 점에 주목해야합니다. 첫 번째 매개 변수로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="9a6d4c47eb4eb3548f61bca4b08d9e197f6e1287" translate="yes" xml:space="preserve">
          <source>The only thing you have to remember is that the &lt;code&gt;&lt;a href=&quot;../functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; subroutine</source>
          <target state="translated">기억해야 할 것은 &lt;code&gt;&lt;a href=&quot;../functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; 서브 루틴이라는 것입니다.</target>
        </trans-unit>
        <trans-unit id="3a8286223f476561d867d00238ced07bc0080bf9" translate="yes" xml:space="preserve">
          <source>The only thing you have to remember is that the &lt;code&gt;import&lt;/code&gt; subroutine</source>
          <target state="translated">기억해야 할 것은 &lt;code&gt;import&lt;/code&gt; 서브 루틴이</target>
        </trans-unit>
        <trans-unit id="befc7f9200d677e41e635df70642f3120f18f3ee" translate="yes" xml:space="preserve">
          <source>The only things you need to declare in Perl are report formats and subroutines (and sometimes not even subroutines). A scalar variable holds the undefined value (&lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;) until it has been assigned a defined value, which is anything other than &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;. When used as a number, &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; is treated as &lt;code&gt;0&lt;/code&gt; ; when used as a string, it is treated as the empty string, &lt;code&gt;&quot;&quot;&lt;/code&gt; ; and when used as a reference that isn't being assigned to, it is treated as an error. If you enable warnings, you'll be notified of an uninitialized value whenever you treat &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; as a string or a number. Well, usually. Boolean contexts, such as:</source>
          <target state="translated">Perl에서 선언해야 할 것은 보고서 형식과 서브 루틴뿐 아니라 때로는 서브 루틴도 아닙니다. 스칼라 변수가 정의되지 않은 값 (보유 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 그것 이외 인 정의 값이 할당 될 때까지) &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; . 숫자로 사용될 때 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 는 &lt;code&gt;0&lt;/code&gt; 으로 처리됩니다 . 문자열로 사용될 때 빈 문자열 &lt;code&gt;&quot;&quot;&lt;/code&gt; 로 취급됩니다 . 할당되지 않은 참조로 사용될 경우 오류로 취급됩니다. 경고를 활성화하면 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 를 문자열 또는 숫자로 취급 할 때마다 초기화되지 않은 값 이 표시됩니다. 보통은 다음과 같은 부울 컨텍스트</target>
        </trans-unit>
        <trans-unit id="8063526283668c78bfe80f0053d75f81f3e00c7f" translate="yes" xml:space="preserve">
          <source>The only things you need to declare in Perl are report formats and subroutines (and sometimes not even subroutines). A scalar variable holds the undefined value (&lt;code&gt;undef&lt;/code&gt;) until it has been assigned a defined value, which is anything other than &lt;code&gt;undef&lt;/code&gt;. When used as a number, &lt;code&gt;undef&lt;/code&gt; is treated as &lt;code&gt;0&lt;/code&gt;; when used as a string, it is treated as the empty string, &lt;code&gt;&quot;&quot;&lt;/code&gt;; and when used as a reference that isn't being assigned to, it is treated as an error. If you enable warnings, you'll be notified of an uninitialized value whenever you treat &lt;code&gt;undef&lt;/code&gt; as a string or a number. Well, usually. Boolean contexts, such as:</source>
          <target state="translated">Perl에서 선언해야하는 것은 보고서 형식과 서브 루틴뿐입니다 (때로는 서브 루틴도 아님). 스칼라 변수가 정의되지 않은 값 (보유 &lt;code&gt;undef&lt;/code&gt; 그것 이외 인 정의 값이 할당 될 때까지) &lt;code&gt;undef&lt;/code&gt; . 숫자로 사용하면 &lt;code&gt;undef&lt;/code&gt; 는 &lt;code&gt;0&lt;/code&gt; 으로 처리됩니다 . 문자열로 사용되면 빈 문자열 &lt;code&gt;&quot;&quot;&lt;/code&gt; 로 처리됩니다 . 할당되지 않은 참조로 사용되면 오류로 처리됩니다. 경고를 활성화하면 &lt;code&gt;undef&lt;/code&gt; 를 문자열이나 숫자로 취급 할 때마다 초기화되지 않은 값에 대한 알림을 받습니다. 글쎄, 보통. 다음과 같은 부울 컨텍스트 :</target>
        </trans-unit>
        <trans-unit id="31db2a79cbb61c12ae686554ebaa8cf24c12eba8" translate="yes" xml:space="preserve">
          <source>The only times that you absolutely</source>
          <target state="translated">당신이 절대적으로 유일한 시간</target>
        </trans-unit>
        <trans-unit id="cdb480d4e9cef712b05b3e3ca053bd2714b2800c" translate="yes" xml:space="preserve">
          <source>The only way to change this is to provide your own subroutine for &lt;code&gt;'|'&lt;/code&gt; .</source>
          <target state="translated">이를 변경하는 유일한 방법은 &lt;code&gt;'|'&lt;/code&gt; 에 대한 고유 한 서브 루틴을 제공하는 것입니다. .</target>
        </trans-unit>
        <trans-unit id="cc6185c346e8349db594c7e55f3c51f34e33f48b" translate="yes" xml:space="preserve">
          <source>The only way to change this is to provide your own subroutine for &lt;code&gt;'|'&lt;/code&gt;.</source>
          <target state="translated">이를 변경하는 유일한 방법은 &lt;code&gt;'|'&lt;/code&gt; 에 대한 자체 서브 루틴을 제공하는 것입니다. .</target>
        </trans-unit>
        <trans-unit id="c65da34730ca57e068ebb9d99972660fe1a63a25" translate="yes" xml:space="preserve">
          <source>The only way to override a lexical warnings setting is with the &lt;b&gt;-W&lt;/b&gt; or &lt;b&gt;-X&lt;/b&gt; command line flags.</source>
          <target state="translated">사전 경고 설정을 대체하는 유일한 방법은 &lt;b&gt;-W&lt;/b&gt; 또는 &lt;b&gt;-X&lt;/b&gt; 명령 행 플래그를 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="7ea2eaf8e5a3a274ae0f1dbb910613954b91ee9b" translate="yes" xml:space="preserve">
          <source>The only way you will ever be allowed to rebase or modify the history of a pushed branch is to delete it and push it as a new branch under the same name. Please think carefully about doing this. It may be better to sequentially rename your branches so that it is easier for others working with you to cherry-pick their local changes onto the new version. (XXX: needs explanation).</source>
          <target state="translated">푸시 된 분기의 기록을 리베이스하거나 수정할 수있는 유일한 방법은 해당 분기를 삭제하고 동일한 이름의 새 분기로 푸시하는 것입니다. 이 작업에 대해 신중하게 생각하십시오. 당신과 함께 일하는 다른 사람들이 새 버전에 대한 로컬 변경 사항을 선택하기 쉽도록 분기의 이름을 순차적으로 바꾸는 것이 더 나을 수 있습니다. (XXX : 설명 필요).</target>
        </trans-unit>
        <trans-unit id="cbd9c5131dd8145825db3c00e95fdf65545c95f3" translate="yes" xml:space="preserve">
          <source>The op tree is connected in two ways: you can imagine that there are two &quot;routes&quot; through it, two orders in which you can traverse the tree. First, parse order reflects how the parser understood the code, and secondly, execution order tells perl what order to perform the operations in.</source>
          <target state="translated">op 트리는 두 가지 방식으로 연결됩니다. 두 개의 &quot;라우트&quot;가 있다고 가정 할 수 있습니다. 두 개의 순서는 트리를 통과 할 수 있습니다. 먼저, 파싱 순서는 파서가 코드를 이해 한 방법을 반영하고, 둘째로 실행 순서는 펄에게 연산 수행 순서를 알려줍니다.</target>
        </trans-unit>
        <trans-unit id="87587f650625db0a4ecb1818a87bdf007aa521f9" translate="yes" xml:space="preserve">
          <source>The op tree representing the code block is returned. This is always a real op, never a null pointer. It will normally be a &lt;code&gt;lineseq&lt;/code&gt; list, including &lt;code&gt;nextstate&lt;/code&gt; or equivalent ops. No ops to construct any kind of runtime scope are included by virtue of it being a block.</source>
          <target state="translated">코드 블록을 나타내는 op 트리가 반환됩니다. 이것은 항상 실제 작업이며 null 포인터는 아닙니다. 일반적으로 &lt;code&gt;nextstate&lt;/code&gt; 또는 이와 동등한 op를 포함 하여 &lt;code&gt;lineseq&lt;/code&gt; 목록 이됩니다 . 모든 종류의 런타임 범위를 구성하는 작전은 그것이 블록이기 때문에 포함되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0ada1b492ff1e32feecd23ad2e48d8b585f13df5" translate="yes" xml:space="preserve">
          <source>The op tree representing the expression is returned. If an optional expression is absent, a null pointer is returned, otherwise the pointer will be non-null.</source>
          <target state="translated">식을 나타내는 op 트리가 반환됩니다. 선택적 표현식이 없으면 널 포인터가 리턴되고 그렇지 않으면 포인터가 널이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="e036bcd0d780fe688c97dce4eafd340bcf362abb" translate="yes" xml:space="preserve">
          <source>The op tree representing the statement is returned. This may be a null pointer if the statement is null, for example if it was actually a subroutine definition (which has compile-time side effects). If not null, it will be ops directly implementing the statement, suitable to pass to &lt;a href=&quot;#newSTATEOP&quot;&gt;&quot;newSTATEOP&quot;&lt;/a&gt;. It will not normally include a &lt;code&gt;nextstate&lt;/code&gt; or equivalent op (except for those embedded in a scope contained entirely within the statement).</source>
          <target state="translated">명령문을 나타내는 op 트리가 반환됩니다. 예를 들어 실제로 서브 루틴 정의 (컴파일 시간 부작용이 있음) 인 경우와 같이 명령문이 널인 경우 널 포인터가 될 수 있습니다. null이 아니면 &lt;a href=&quot;#newSTATEOP&quot;&gt;&quot;newSTATEOP&quot;&lt;/a&gt; 에 전달하기에 적합한 명령문을 직접 구현하는 작업이됩니다 . 일반적으로 &lt;code&gt;nextstate&lt;/code&gt; 또는 동등한 op를 포함하지 않습니다 (문 내에 완전히 포함 된 범위에 포함 된 경우 제외).</target>
        </trans-unit>
        <trans-unit id="b8ec717bc605b587bc78dee46e74bc74f77b59be" translate="yes" xml:space="preserve">
          <source>The op tree representing the statement is returned. This may be a null pointer if the statement is null, for example if it was actually a subroutine definition (which has compile-time side effects). If not null, it will be ops directly implementing the statement, suitable to pass to &lt;a href=&quot;#newSTATEOP&quot;&gt;newSTATEOP&lt;/a&gt;. It will not normally include a &lt;code&gt;nextstate&lt;/code&gt; or equivalent op (except for those embedded in a scope contained entirely within the statement).</source>
          <target state="translated">명령문을 나타내는 op 트리가 리턴됩니다. 명령문이 널 (null) 인 경우, 예를 들어 실제로 서브 루틴 정의 (컴파일 시간 부작용이있는) 인 경우 널 포인터 일 수 있습니다. null이 아닌 경우는, 문장을 직접 구현해 &lt;a href=&quot;#newSTATEOP&quot;&gt;opSTATEOP&lt;/a&gt; 에 건네주는 조작이 됩니다. 일반적으로 &lt;code&gt;nextstate&lt;/code&gt; 또는 이와 동등한 op를 포함하지 않습니다 (문에 완전히 포함 된 범위에 포함 된 것을 제외).</target>
        </trans-unit>
        <trans-unit id="2254139a8dcdd28ca766e4d41d0739d872c7e21b" translate="yes" xml:space="preserve">
          <source>The op tree representing the statement is returned. This may be a null pointer if the statement is null, for example if it was actually a subroutine definition (which has compile-time side effects). If not null, it will be the result of a &lt;a href=&quot;#newSTATEOP&quot;&gt;&quot;newSTATEOP&quot;&lt;/a&gt; call, normally including a &lt;code&gt;nextstate&lt;/code&gt; or equivalent op.</source>
          <target state="translated">명령문을 나타내는 op 트리가 반환됩니다. 예를 들어 실제로 서브 루틴 정의 (컴파일 시간 부작용이 있음) 인 경우와 같이 명령문이 널인 경우 널 포인터가 될 수 있습니다. null이 아닌 경우 일반적으로 &lt;code&gt;nextstate&lt;/code&gt; 또는 동등한 작업을 포함하는 &lt;a href=&quot;#newSTATEOP&quot;&gt;&quot;newSTATEOP&quot;&lt;/a&gt; 호출 의 결과입니다 .</target>
        </trans-unit>
        <trans-unit id="55a48ae410aca9d3fe9a16a19fa26233018ca671" translate="yes" xml:space="preserve">
          <source>The op tree representing the statement is returned. This may be a null pointer if the statement is null, for example if it was actually a subroutine definition (which has compile-time side effects). If not null, it will be the result of a &lt;a href=&quot;#newSTATEOP&quot;&gt;newSTATEOP&lt;/a&gt; call, normally including a &lt;code&gt;nextstate&lt;/code&gt; or equivalent op.</source>
          <target state="translated">명령문을 나타내는 op 트리가 리턴됩니다. 명령문이 널 (null) 인 경우, 예를 들어 실제로 서브 루틴 정의 (컴파일 시간 부작용이있는) 인 경우 널 포인터 일 수 있습니다. null가 아닌 경우는 결과가 될 것입니다 &lt;a href=&quot;#newSTATEOP&quot;&gt;newSTATEOP에&lt;/a&gt; 일반적으로 포함 호출, &lt;code&gt;nextstate&lt;/code&gt; 또는 이에 상응하는 연산.</target>
        </trans-unit>
        <trans-unit id="80258368ca90132ffffe94b685646de5d3e0a9ff" translate="yes" xml:space="preserve">
          <source>The op tree representing the statement sequence is returned. This may be a null pointer if the statements were all null, for example if there were no statements or if there were only subroutine definitions (which have compile-time side effects). If not null, it will be a &lt;code&gt;lineseq&lt;/code&gt; list, normally including &lt;code&gt;nextstate&lt;/code&gt; or equivalent ops.</source>
          <target state="translated">명령문 순서를 나타내는 op 트리가 리턴됩니다. 명령문이 모두 없거나 예를 들어 명령문이 없거나 서브 루틴 정의 만있는 경우 (컴파일 타임 부작용이있는 경우) 이는 널 포인터 일 수 있습니다. null이 &lt;code&gt;lineseq&lt;/code&gt; 일반적으로 &lt;code&gt;nextstate&lt;/code&gt; 또는 이와 동등한 ops를 포함 하는 lineseq 목록이됩니다 .</target>
        </trans-unit>
        <trans-unit id="535ccca6a54b74bb28aa7a40bc1a8b66e55f76db" translate="yes" xml:space="preserve">
          <source>The op tree to unpack the arguments from the stack at runtime is returned. This op tree should appear at the beginning of the compiled function. The caller may wish to use &lt;a href=&quot;#op_append_list&quot;&gt;&quot;op_append_list&quot;&lt;/a&gt; to build their function body after it, or splice it together with the body before calling &lt;a href=&quot;#newATTRSUB&quot;&gt;&quot;newATTRSUB&quot;&lt;/a&gt;.</source>
          <target state="translated">런타임에 스택에서 인수를 압축 해제하는 op 트리가 반환됩니다. 이 연산 트리는 컴파일 된 함수의 시작 부분에 나타나야합니다. 호출자는 &lt;a href=&quot;#op_append_list&quot;&gt;&quot;op_append_list&quot;&lt;/a&gt; 를 사용하여 그 뒤에 함수 본문을 빌드하거나 &lt;a href=&quot;#newATTRSUB&quot;&gt;&quot;newATTRSUB&quot;&lt;/a&gt; 를 호출하기 전에 본문과 함께 스플 라이스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c35c6433e7899b6be9854e9907788616c4dfa0ff" translate="yes" xml:space="preserve">
          <source>The op-flags (ex &lt;b&gt;'sK/2'&lt;/b&gt;) are described in (&lt;a href=&quot;#OP-flags-abbreviations&quot;&gt;&quot;OP flags abbreviations&quot;&lt;/a&gt;).</source>
          <target state="translated">op 플래그 (예 : &lt;b&gt;'sK / 2'&lt;/b&gt; )는 ( &lt;a href=&quot;#OP-flags-abbreviations&quot;&gt;&quot;OP 플래그 약어&quot;&lt;/a&gt; )에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="ee004e116194c04a5a9d3789b699d566539ba78d" translate="yes" xml:space="preserve">
          <source>The op-flags (ex &lt;b&gt;'sK/2'&lt;/b&gt;) are described in (&lt;a href=&quot;#OP-flags-abbreviations&quot;&gt;OP flags abbreviations&lt;/a&gt;).</source>
          <target state="translated">op 플래그 (예 : &lt;b&gt;'sK / 2'&lt;/b&gt; )는 ( &lt;a href=&quot;#OP-flags-abbreviations&quot;&gt;OP 플래그 약어&lt;/a&gt; )에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="8eec999d2cf9d026309d4e24a85ebd9a75290847" translate="yes" xml:space="preserve">
          <source>The open source license that Larry Wall created for Perl, maximizing Perl&amp;rsquo;s usefulness, availability, and modifiability. The current version is 2. (&lt;a href=&quot;http://www.opensource.org/licenses/artistic-license.php&quot;&gt;http://www.opensource.org/licenses/artistic-license.php&lt;/a&gt;).</source>
          <target state="translated">Larry Wall이 Perl을 위해 만든 오픈 소스 라이센스로 Perl의 유용성, 가용성 및 수정 성을 극대화합니다. 현재 버전은 2입니다 ( &lt;a href=&quot;http://www.opensource.org/licenses/artistic-license.php&quot;&gt;http://www.opensource.org/licenses/artistic-license.php&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="d076872f9624d7a17cf4c11c33523c71a8396f8e" translate="yes" xml:space="preserve">
          <source>The open2() function runs the given $cmd and connects $chld_out for reading and $chld_in for writing. It's what you think should work when you try</source>
          <target state="translated">open2 () 함수는 주어진 $ cmd를 실행하고 읽기를 위해 $ chld_out을 연결하고 쓰기를 위해 $ chld_in을 연결합니다. 시도 할 때 작동해야한다고 생각합니다.</target>
        </trans-unit>
        <trans-unit id="2904189d67cdca2709e7a78ebf9563187c0c5785" translate="yes" xml:space="preserve">
          <source>The open2() function runs the given command and connects $chld_out for reading and $chld_in for writing. It's what you think should work when you try</source>
          <target state="translated">open2 () 함수는 주어진 명령을 실행하고 읽기를 위해 $ chld_out을 연결하고 쓰기를 위해 $ chld_in을 연결합니다. 시도 할 때 작동해야한다고 생각하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="793bd01a6b2dc5e14b8e95bd14b22d7c8c213b3b" translate="yes" xml:space="preserve">
          <source>The operand of some types of regop is a literal string; for others, it is a regop leading into a sub-program. In particular, the operand of a &lt;code&gt;BRANCH&lt;/code&gt; node is the first regop of the branch.</source>
          <target state="translated">일부 유형의 regop 피연산자는 리터럴 문자열입니다. 다른 사람들에게는 하위 프로그램으로 이어지는 레고 프입니다. 특히, &lt;code&gt;BRANCH&lt;/code&gt; 노드 의 피연산자 는 분기의 첫 번째 regop입니다.</target>
        </trans-unit>
        <trans-unit id="cf8df21203ce7e715434391039cee96dd7ffc65d" translate="yes" xml:space="preserve">
          <source>The operating system, device drivers, C libraries, and Perl run-time system all conspire to let the programmer treat a single character (&lt;code&gt;\n&lt;/code&gt; ) as the line terminator, irrespective of external representation. On many operating systems, the native text file representation matches the internal representation, but on some platforms the external representation of &lt;code&gt;\n&lt;/code&gt; is made up of more than one character.</source>
          <target state="translated">운영 체제, 장치 드라이버, C 라이브러리 및 Perl 런타임 시스템은 모두 외부 표현에 관계없이 프로그래머가 단일 문자 ( &lt;code&gt;\n&lt;/code&gt; )를 줄 종결 자로 처리하도록 구성합니다 . 많은 운영 체제에서 기본 텍스트 파일 표현은 내부 표현과 일치하지만 일부 플랫폼에서는 &lt;code&gt;\n&lt;/code&gt; 의 외부 표현 이 둘 이상의 문자로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="3f9b4af2476a3677a8d756957b80eb4422b5ccdb" translate="yes" xml:space="preserve">
          <source>The operating system, device drivers, C libraries, and Perl run-time system all conspire to let the programmer treat a single character (&lt;code&gt;\n&lt;/code&gt;) as the line terminator, irrespective of external representation. On many operating systems, the native text file representation matches the internal representation, but on some platforms the external representation of &lt;code&gt;\n&lt;/code&gt; is made up of more than one character.</source>
          <target state="translated">운영 체제, 장치 드라이버, C 라이브러리 및 Perl 런타임 시스템은 모두 프로그래머 가 외부 표현에 관계없이 단일 문자 ( &lt;code&gt;\n&lt;/code&gt; )를 줄 종결 자로 취급 할 수 있도록 공모합니다 . 많은 운영 체제에서 기본 텍스트 파일 표현은 내부 표현과 일치하지만 일부 플랫폼에서는 &lt;code&gt;\n&lt;/code&gt; 의 외부 표현 이 둘 이상의 문자로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="8c6975d92732aba7cc117877a890c8662a217abc" translate="yes" xml:space="preserve">
          <source>The operation of the &lt;code&gt;%ENV&lt;/code&gt; array depends on the translation of the logical name</source>
          <target state="translated">&lt;code&gt;%ENV&lt;/code&gt; 배열 의 조작은 논리 이름의 변환에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="1fcdc1a8281a2698369d4d0c5ac8331125832af5" translate="yes" xml:space="preserve">
          <source>The operation of the bval option warrants some discussion. Here is the definition of bval from the Berkeley DB 1.85 recno manual page:</source>
          <target state="translated">bval 옵션의 작동은 약간의 논의를 보증합니다. 다음은 Berkeley DB 1.85 recno 매뉴얼 페이지의 bval 정의입니다.</target>
        </trans-unit>
        <trans-unit id="f8261c0231b653877a248b54abf80f0b93e9f204" translate="yes" xml:space="preserve">
          <source>The operation of this method is also affected by the &lt;code&gt;archlibexp&lt;/code&gt; , &lt;code&gt;cccdlflags&lt;/code&gt; , &lt;code&gt;ccflags&lt;/code&gt; , &lt;code&gt;optimize&lt;/code&gt; , and &lt;code&gt;cc&lt;/code&gt; entries in &lt;code&gt;Config.pm&lt;/code&gt; .</source>
          <target state="translated">이 방법의 작동은 &lt;code&gt;Config.pm&lt;/code&gt; 의 &lt;code&gt;archlibexp&lt;/code&gt; , &lt;code&gt;cccdlflags&lt;/code&gt; , &lt;code&gt;ccflags&lt;/code&gt; , &lt;code&gt;optimize&lt;/code&gt; 및 &lt;code&gt;cc&lt;/code&gt; 항목 에도 영향을받습니다 .</target>
        </trans-unit>
        <trans-unit id="ebf43357cdf326de3a784f122cc30174e4d696c9" translate="yes" xml:space="preserve">
          <source>The operation of this method is also affected by the &lt;code&gt;archlibexp&lt;/code&gt;, &lt;code&gt;cccdlflags&lt;/code&gt;, &lt;code&gt;ccflags&lt;/code&gt;, &lt;code&gt;optimize&lt;/code&gt;, and &lt;code&gt;cc&lt;/code&gt; entries in &lt;code&gt;Config.pm&lt;/code&gt;.</source>
          <target state="translated">이 방법의 작동은 &lt;code&gt;Config.pm&lt;/code&gt; 의 &lt;code&gt;archlibexp&lt;/code&gt; , &lt;code&gt;cccdlflags&lt;/code&gt; , &lt;code&gt;ccflags&lt;/code&gt; , &lt;code&gt;optimize&lt;/code&gt; 및 &lt;code&gt;cc&lt;/code&gt; 항목의 영향도받습니다 .</target>
        </trans-unit>
        <trans-unit id="1ea94336b097e013eb83f32bbba38514d8eaa887" translate="yes" xml:space="preserve">
          <source>The operation of this method is also affected by the &lt;code&gt;lddlflags&lt;/code&gt; , &lt;code&gt;shrpenv&lt;/code&gt; , and &lt;code&gt;ld&lt;/code&gt; entries in &lt;code&gt;Config.pm&lt;/code&gt; .</source>
          <target state="translated">이 방법의 작동은 &lt;code&gt;Config.pm&lt;/code&gt; 의 &lt;code&gt;lddlflags&lt;/code&gt; , &lt;code&gt;shrpenv&lt;/code&gt; 및 &lt;code&gt;ld&lt;/code&gt; 항목 에도 영향을받습니다 .</target>
        </trans-unit>
        <trans-unit id="9af43d4cfed7d96567a247c3d560f72f4c234173" translate="yes" xml:space="preserve">
          <source>The operation of this method is also affected by the &lt;code&gt;lddlflags&lt;/code&gt;, &lt;code&gt;shrpenv&lt;/code&gt;, and &lt;code&gt;ld&lt;/code&gt; entries in &lt;code&gt;Config.pm&lt;/code&gt;.</source>
          <target state="translated">이 메소드의 작동은 &lt;code&gt;Config.pm&lt;/code&gt; 의 &lt;code&gt;lddlflags&lt;/code&gt; , &lt;code&gt;shrpenv&lt;/code&gt; 및 &lt;code&gt;ld&lt;/code&gt; 항목의 영향도받습니다 .</target>
        </trans-unit>
        <trans-unit id="1cf8b3d14dd93250118a75dcead35353084d8d3c" translate="yes" xml:space="preserve">
          <source>The operations that are affected by locale are:</source>
          <target state="translated">로캘의 영향을받는 작업은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4ea8be07a0890d457a63bbbdc0361b2f2a0630bf" translate="yes" xml:space="preserve">
          <source>The operator &lt;code&gt;not&lt;/code&gt; is not a valid key for &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; overload&lt;/code&gt; . However, if the operator &lt;code&gt;!&lt;/code&gt; is overloaded then the same implementation will be used for &lt;code&gt;not&lt;/code&gt; (since the two operators differ only in precedence).</source>
          <target state="translated">운영자는 &lt;code&gt;not&lt;/code&gt; 에 대한 유효한 키가 아닌 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; overload&lt;/code&gt; . 그러나 연산자가 &lt;code&gt;!&lt;/code&gt; 오버로드 된 경우 동일한 구현이 사용 &lt;code&gt;not&lt;/code&gt; (두 연산자가 우선 순위가 다르기 때문에).</target>
        </trans-unit>
        <trans-unit id="e62d966af3836010344e801b17dfde35cf80a445" translate="yes" xml:space="preserve">
          <source>The operator &lt;code&gt;not&lt;/code&gt; is not a valid key for &lt;code&gt;use overload&lt;/code&gt;. However, if the operator &lt;code&gt;!&lt;/code&gt; is overloaded then the same implementation will be used for &lt;code&gt;not&lt;/code&gt; (since the two operators differ only in precedence).</source>
          <target state="translated">연산자 &lt;code&gt;not&lt;/code&gt; 은 &lt;code&gt;use overload&lt;/code&gt; 유효한 키가 아닙니다 . 그러나 연산자라면 &lt;code&gt;!&lt;/code&gt; 오버로드 된 경우 동일한 구현이 &lt;code&gt;not&lt;/code&gt; 에 사용됩니다 (두 연산자의 우선 순위 만 다르기 때문에).</target>
        </trans-unit>
        <trans-unit id="78cd830e88c435efad5c7c64c9421f0a7b44115d" translate="yes" xml:space="preserve">
          <source>The operator may be assigned to if both the 2nd and 3rd arguments are legal lvalues (meaning that you can assign to them):</source>
          <target state="translated">두 번째 인수와 세 번째 인수가 모두 합법적 인 lvalue 인 경우 연산자를 지정할 수 있습니다 (할당 할 수 있음).</target>
        </trans-unit>
        <trans-unit id="5904b513e41f7f0a3948a698bdf838835b48e7f3" translate="yes" xml:space="preserve">
          <source>The opname, as in &lt;b&gt;'add[t1]'&lt;/b&gt;, may be followed by op-specific information in parentheses or brackets (ex &lt;b&gt;'[t1]'&lt;/b&gt;).</source>
          <target state="translated">&lt;b&gt;'add [t1]'&lt;/b&gt; 에서와 같이 opname 뒤에 괄호 나 괄호로 묶인 op 관련 정보가있을 수 있습니다 (예 : &lt;b&gt;'[t1]'&lt;/b&gt; ).</target>
        </trans-unit>
        <trans-unit id="4a764821c24945c6b9d29fb8f23336e4895936b8" translate="yes" xml:space="preserve">
          <source>The opposite of &lt;a href=&quot;#catdir&quot;&gt;&quot;catdir&quot;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#catdir&quot;&gt;&quot;catdir&quot;&lt;/a&gt; 의 반대입니다 .</target>
        </trans-unit>
        <trans-unit id="18a01865affffe01d68458832d996fae1c28b752" translate="yes" xml:space="preserve">
          <source>The opposite of &lt;a href=&quot;#catdir&quot;&gt;catdir&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#catdir&quot;&gt;catdir&lt;/a&gt; 의 반대입니다 .</target>
        </trans-unit>
        <trans-unit id="da407a5a37cdd431c49815120665c0495df714be" translate="yes" xml:space="preserve">
          <source>The opposite of &lt;a href=&quot;#catdir%28%29&quot;&gt;&quot;catdir()&quot;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#catdir%28%29&quot;&gt;&quot;catdir ()&quot;&lt;/a&gt; 의 반대입니다 .</target>
        </trans-unit>
        <trans-unit id="e8b12f229c6486073ad774a1dc49a9e1e9fe1afd" translate="yes" xml:space="preserve">
          <source>The opposite of &lt;a href=&quot;#catdir()&quot;&gt;catdir()&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#catdir()&quot;&gt;catdir ()&lt;/a&gt; 의 반대입니다 .</target>
        </trans-unit>
        <trans-unit id="cd5ab607bfc9b28a62d0ee095cfa34da1a0a1edd" translate="yes" xml:space="preserve">
          <source>The opposite of &lt;a href=&quot;../spec#catdir&quot;&gt;catdir()&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../spec#catdir&quot;&gt;catdir ()&lt;/a&gt; 의 반대입니다 .</target>
        </trans-unit>
        <trans-unit id="72e60997864c75a6b42c630a5cd3b7d0d96cb145" translate="yes" xml:space="preserve">
          <source>The opposite of &lt;a href=&quot;File::Spec#catdir&quot;&gt;catdir()&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;File::Spec#catdir&quot;&gt;catdir ()&lt;/a&gt; 의 반대입니다 .</target>
        </trans-unit>
        <trans-unit id="1ebefb2669972c85d8b9e00b79503067268d1b9d" translate="yes" xml:space="preserve">
          <source>The opposite of &lt;code&gt;catdir()&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;catdir()&lt;/code&gt; 의 반대입니다 .</target>
        </trans-unit>
        <trans-unit id="ce2ff0fee10bb0851a17501763837139e03ed67c" translate="yes" xml:space="preserve">
          <source>The opposite of &lt;code&gt;catdir()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;catdir()&lt;/code&gt; 의 반대입니다 .</target>
        </trans-unit>
        <trans-unit id="9a36830f45796b87c226ab6318291313f5d62c75" translate="yes" xml:space="preserve">
          <source>The opposite of &lt;code&gt;encode&lt;/code&gt;: expects a JSON text and tries to parse it, returning the resulting simple scalar or reference. Croaks on error.</source>
          <target state="translated">&lt;code&gt;encode&lt;/code&gt; 의 반대 : JSON 텍스트를 예상하고 구문 분석을 시도하여 결과 단순 스칼라 또는 참조를 반환합니다. 오류에 대한 삐걱 거리는 소리.</target>
        </trans-unit>
        <trans-unit id="f81bb459c3e1d2a0353a3947d9d6ef14ef3f4c25" translate="yes" xml:space="preserve">
          <source>The opposite of &lt;code&gt;encode_json&lt;/code&gt;: expects an UTF-8 (binary) string and tries to parse that as an UTF-8 encoded JSON text, returning the resulting reference. Croaks on error.</source>
          <target state="translated">&lt;code&gt;encode_json&lt;/code&gt; 의 반대 : UTF-8 (바이너리) 문자열을 예상하고이를 UTF-8로 인코딩 된 JSON 텍스트로 구문 분석하여 결과 참조를 반환합니다. 오류에 대한 삐걱 거리는 소리.</target>
        </trans-unit>
        <trans-unit id="9058f904dc63789872dd9542a7b1316b89449f40" translate="yes" xml:space="preserve">
          <source>The opset and opset_to_ops functions can be used to convert from a list of operators to an opset and</source>
          <target state="translated">opset 및 opset_to_ops 함수를 사용하여 연산자 목록에서 opset으로 변환하고</target>
        </trans-unit>
        <trans-unit id="e0e7014b5567d7771bd0933f5acd1310aac22e0f" translate="yes" xml:space="preserve">
          <source>The optag name used must not be defined already (define_optag will croak if it is already defined). Optag names are global to the perl process and optag definitions cannot be altered or deleted once defined.</source>
          <target state="translated">사용 된 optag 이름은 아직 정의되어 있지 않아야합니다 (define_optag는 이미 정의 된 경우 축소됨). Optag 이름은 perl 프로세스에 대해 전역 적이며 일단 정의 된 optag 정의는 변경하거나 삭제할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="16ae99f8eb8c5eb6cf77bcb07b90faddacb6b646" translate="yes" xml:space="preserve">
          <source>The optimizer-specific information is used to avoid entering (a slow) regex engine on strings that will not definitely match. If the &lt;code&gt;isall&lt;/code&gt; flag is set, a call to the regex engine may be avoided even when the optimizer found an appropriate place for the match.</source>
          <target state="translated">최적화 프로그램 별 정보는 정확히 일치하지 않는 문자열에 (느린) 정규식 엔진을 입력하지 않도록하는 데 사용됩니다. 는 IF &lt;code&gt;isall&lt;/code&gt; 의 플래그가 설정되어 최적화 프로그램이 경기를보기 위해 적절한 장소를 발견 할 때, 정규식 엔진에 대한 호출도 피할 수있다.</target>
        </trans-unit>
        <trans-unit id="c2bcebf69d65f38d819f2ef47d3870130b4b4a34" translate="yes" xml:space="preserve">
          <source>The option does not take an argument and may be negated by prefixing it with &quot;no&quot; or &quot;no-&quot;. E.g. &lt;code&gt;&quot;foo!&quot;&lt;/code&gt; will allow &lt;code&gt;--foo&lt;/code&gt; (a value of 1 will be assigned) as well as &lt;code&gt;--nofoo&lt;/code&gt; and &lt;code&gt;--&lt;a href=&quot;../functions/no&quot;&gt;no&lt;/a&gt;-foo&lt;/code&gt; (a value of 0 will be assigned). If the option has aliases, this applies to the aliases as well.</source>
          <target state="translated">이 옵션은 인수를 사용하지 않으며 &quot;no&quot;또는 &quot;no-&quot;를 접두어로 붙여서 무시할 수 있습니다. 예 : &lt;code&gt;&quot;foo!&quot;&lt;/code&gt; 수 없다 &lt;code&gt;--foo&lt;/code&gt; (1의 값이 할당 될 것이다)로서뿐만 아니라 &lt;code&gt;--nofoo&lt;/code&gt; 및 &lt;code&gt;--&lt;a href=&quot;../functions/no&quot;&gt;no&lt;/a&gt;-foo&lt;/code&gt; (0의 값이 할당 될 것이다). 옵션에 별명이있는 경우 별명에도 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="d9db329442e437205bd55b086c5b9e99baf5686d" translate="yes" xml:space="preserve">
          <source>The option does not take an argument and may be negated by prefixing it with &quot;no&quot; or &quot;no-&quot;. E.g. &lt;code&gt;&quot;foo!&quot;&lt;/code&gt; will allow &lt;code&gt;--foo&lt;/code&gt; (a value of 1 will be assigned) as well as &lt;code&gt;--nofoo&lt;/code&gt; and &lt;code&gt;--no-foo&lt;/code&gt; (a value of 0 will be assigned). If the option has aliases, this applies to the aliases as well.</source>
          <target state="translated">이 옵션은 인수를 취하지 않으며 &quot;no&quot;또는 &quot;no-&quot;접두사를 붙여 부정 할 수 있습니다. 예 : &lt;code&gt;&quot;foo!&quot;&lt;/code&gt; 수 &lt;code&gt;--foo&lt;/code&gt; 뿐만 아니라, (1의 값이 할당 될 것이다) &lt;code&gt;--nofoo&lt;/code&gt; 및 &lt;code&gt;--no-foo&lt;/code&gt; 에 (0의 값이 할당 될 것이다). 옵션에 별칭이있는 경우 별칭에도 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="05bc04ade0e6f0bfb276419b00c5f9d55f933117" translate="yes" xml:space="preserve">
          <source>The option does not take an argument and will be incremented by 1 every time it appears on the command line. E.g. &lt;code&gt;&quot;more+&quot;&lt;/code&gt; , when used with &lt;code&gt;--more --more --more&lt;/code&gt;, will increment the value three times, resulting in a value of 3 (provided it was 0 or undefined at first).</source>
          <target state="translated">이 옵션은 인수를 사용하지 않으며 명령 행에 나타날 때마다 1 씩 증가합니다. 예를 들어 &lt;code&gt;--more --more --more&lt;/code&gt; 와 함께 사용되는 &lt;code&gt;&quot;more+&quot;&lt;/code&gt; 는 값을 3 번 증가시켜 값이 3이됩니다 (제공된 값이 0이거나 처음에 정의되지 않은 경우).</target>
        </trans-unit>
        <trans-unit id="d8e253e20697ea76ff418e0292092a5b47f9f4f6" translate="yes" xml:space="preserve">
          <source>The option does not take an argument and will be incremented by 1 every time it appears on the command line. E.g. &lt;code&gt;&quot;more+&quot;&lt;/code&gt;, when used with &lt;code&gt;--more --more --more&lt;/code&gt;, will increment the value three times, resulting in a value of 3 (provided it was 0 or undefined at first).</source>
          <target state="translated">이 옵션은 인수를 사용하지 않으며 명령 줄에 나타날 때마다 1 씩 증가합니다. 예를 들어 &lt;code&gt;&quot;more+&quot;&lt;/code&gt; 를 &lt;code&gt;--more --more --more&lt;/code&gt; 와 함께 사용 하면 값이 세 번 증가하여 값이 3이됩니다 (처음에는 0이거나 정의되지 않은 경우).</target>
        </trans-unit>
        <trans-unit id="e6c73626524fd7b39cf23cb6ceb0594624a4560f" translate="yes" xml:space="preserve">
          <source>The option name as specified to the GetOptions() function is called the option</source>
          <target state="translated">GetOptions () 함수에 지정된 옵션 이름을 옵션이라고합니다.</target>
        </trans-unit>
        <trans-unit id="28e883d6a03c91177fe93b06a907181312e7662a" translate="yes" xml:space="preserve">
          <source>The option names defined below are case insensitive and can be optionally prefixed by a '-'. So all of the following are valid</source>
          <target state="translated">아래에 정의 된 옵션 이름은 대소 문자를 구분하지 않으며 선택적으로 접두어에 '-'를 붙일 수 있습니다. 따라서 다음은 모두 유효합니다</target>
        </trans-unit>
        <trans-unit id="24d6abd722573e6cae42881df7cf4d56ac582b1b" translate="yes" xml:space="preserve">
          <source>The option requires an argument of the given type. Supported types are:</source>
          <target state="translated">옵션에는 주어진 유형의 인수가 필요합니다. 지원되는 유형은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="18b9f1ce4c729b2ded7edcf5db48cd7ab36a842d" translate="yes" xml:space="preserve">
          <source>The optional</source>
          <target state="translated">옵션</target>
        </trans-unit>
        <trans-unit id="3cb07c5a1f900e41d71b7af9007db9793c77a65e" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;rules&lt;/code&gt; attribute provides direction on which tests should be run in parallel and which should be run sequentially. If no rule data structure is provided, a default data structure is used which makes every test eligible to be run in parallel:</source>
          <target state="translated">선택적인 &lt;code&gt;rules&lt;/code&gt; 속성은 테스트를 병렬로 실행하고 순차적으로 실행해야하는 방향을 제공합니다. 규칙 데이터 구조가 제공되지 않으면 모든 테스트를 병렬로 실행할 수있는 기본 데이터 구조가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="0a173dcd400a0274b32b98f040a162b1b1782227" translate="yes" xml:space="preserve">
          <source>The optional arguments are considered as literal strings unless they start with &lt;code&gt;~&lt;/code&gt; or &lt;code&gt;!&lt;/code&gt; , in which case they are interpreted as regular expressions (possibly negated).</source>
          <target state="translated">선택적 인수는 &lt;code&gt;~&lt;/code&gt; 또는 &lt;code&gt;!&lt;/code&gt; 로 시작하지 않으면 리터럴 문자열로 간주됩니다 . 이 경우 정규 표현식으로 해석됩니다 (아마도 부정 될 수 있음).</target>
        </trans-unit>
        <trans-unit id="cf1d2e0ff9c2439cc3ca174e85a170cee0c435c9" translate="yes" xml:space="preserve">
          <source>The optional arguments are considered as literal strings unless they start with &lt;code&gt;~&lt;/code&gt; or &lt;code&gt;!&lt;/code&gt;, in which case they are interpreted as regular expressions (possibly negated).</source>
          <target state="translated">선택적 인수는 &lt;code&gt;~&lt;/code&gt; 또는 &lt;code&gt;!&lt;/code&gt; 로 시작하지 않는 한 리터럴 문자열로 간주됩니다 . ,이 경우 정규 표현식으로 해석됩니다 (부정 될 수 있음).</target>
        </trans-unit>
        <trans-unit id="2a457723dc3fc51f575186932ad8e9bfa084daea" translate="yes" xml:space="preserve">
          <source>The optional parameters for the one-shot function &lt;code&gt;anyinflate&lt;/code&gt; are (for the most part) identical to those used with the OO interface defined in the &lt;a href=&quot;#Constructor-Options&quot;&gt;&quot;Constructor Options&quot;&lt;/a&gt; section. The exceptions are listed below</source>
          <target state="translated">one-shot 함수 &lt;code&gt;anyinflate&lt;/code&gt; 에 대한 선택적 매개 변수 는 (대부분의 경우) &lt;a href=&quot;#Constructor-Options&quot;&gt;&quot;생성자 옵션&quot;&lt;/a&gt; 섹션에 정의 된 OO 인터페이스와 함께 사용되는 매개 변수 와 동일합니다 . 예외는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="caed88218bf3ae5d8b6dcab0958f36fc2927ec02" translate="yes" xml:space="preserve">
          <source>The optional parameters for the one-shot function &lt;code&gt;anyuncompress&lt;/code&gt; are (for the most part) identical to those used with the OO interface defined in the &lt;a href=&quot;#Constructor-Options&quot;&gt;&quot;Constructor Options&quot;&lt;/a&gt; section. The exceptions are listed below</source>
          <target state="translated">one-shot 함수 &lt;code&gt;anyuncompress&lt;/code&gt; 의 선택적 매개 변수 는 (대부분의 경우) &lt;a href=&quot;#Constructor-Options&quot;&gt;&quot;생성자 옵션&quot;&lt;/a&gt; 섹션에 정의 된 OO 인터페이스와 함께 사용되는 매개 변수 와 동일합니다 . 예외는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="131098ff902c48e8458d96c59269d22ab860e8b2" translate="yes" xml:space="preserve">
          <source>The optional parameters for the one-shot function &lt;code&gt;bunzip2&lt;/code&gt; are (for the most part) identical to those used with the OO interface defined in the &lt;a href=&quot;#Constructor-Options&quot;&gt;&quot;Constructor Options&quot;&lt;/a&gt; section. The exceptions are listed below</source>
          <target state="translated">원샷 함수 &lt;code&gt;bunzip2&lt;/code&gt; 의 선택적 매개 변수 는 (대부분) &lt;a href=&quot;#Constructor-Options&quot;&gt;&quot;생성자 옵션&quot;&lt;/a&gt; 섹션에 정의 된 OO 인터페이스와 함께 사용되는 매개 변수 와 동일합니다 . 예외는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6198111cc9801f305996de3eeaa06e0db91b4218" translate="yes" xml:space="preserve">
          <source>The optional parameters for the one-shot function &lt;code&gt;bzip2&lt;/code&gt; are (for the most part) identical to those used with the OO interface defined in the &lt;a href=&quot;#Constructor-Options&quot;&gt;&quot;Constructor Options&quot;&lt;/a&gt; section. The exceptions are listed below</source>
          <target state="translated">원샷 함수 &lt;code&gt;bzip2&lt;/code&gt; 의 선택적 매개 변수 는 (대부분) &lt;a href=&quot;#Constructor-Options&quot;&gt;&quot;생성자 옵션&quot;&lt;/a&gt; 섹션에 정의 된 OO 인터페이스와 함께 사용되는 매개 변수 와 동일합니다 . 예외는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="38c4c457d99260789b76c08eab24f06adc17d2c1" translate="yes" xml:space="preserve">
          <source>The optional parameters for the one-shot function &lt;code&gt;deflate&lt;/code&gt; are (for the most part) identical to those used with the OO interface defined in the &lt;a href=&quot;#Constructor-Options&quot;&gt;&quot;Constructor Options&quot;&lt;/a&gt; section. The exceptions are listed below</source>
          <target state="translated">원샷 함수 &lt;code&gt;deflate&lt;/code&gt; 에 대한 선택적 매개 변수 는 (대부분의 경우) &lt;a href=&quot;#Constructor-Options&quot;&gt;&quot;생성자 옵션&quot;&lt;/a&gt; 섹션에 정의 된 OO 인터페이스와 함께 사용되는 매개 변수 와 동일합니다 . 예외는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="aa1a96727af7ce5f83a4cb5ede379486da415347" translate="yes" xml:space="preserve">
          <source>The optional parameters for the one-shot function &lt;code&gt;gunzip&lt;/code&gt; are (for the most part) identical to those used with the OO interface defined in the &lt;a href=&quot;#Constructor-Options&quot;&gt;&quot;Constructor Options&quot;&lt;/a&gt; section. The exceptions are listed below</source>
          <target state="translated">원샷 기능 &lt;code&gt;gunzip&lt;/code&gt; 의 선택적 매개 변수 는 (대부분) &lt;a href=&quot;#Constructor-Options&quot;&gt;&quot;생성자 옵션&quot;&lt;/a&gt; 섹션에 정의 된 OO 인터페이스와 함께 사용되는 매개 변수 와 동일합니다 . 예외는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="32a1759e80fa595487da188a1ae20babdbb62651" translate="yes" xml:space="preserve">
          <source>The optional parameters for the one-shot function &lt;code&gt;gzip&lt;/code&gt; are (for the most part) identical to those used with the OO interface defined in the &lt;a href=&quot;#Constructor-Options&quot;&gt;&quot;Constructor Options&quot;&lt;/a&gt; section. The exceptions are listed below</source>
          <target state="translated">원샷 함수 &lt;code&gt;gzip&lt;/code&gt; 의 선택적 매개 변수 는 (대부분) &lt;a href=&quot;#Constructor-Options&quot;&gt;&quot;생성자 옵션&quot;&lt;/a&gt; 섹션에 정의 된 OO 인터페이스와 함께 사용되는 매개 변수 와 동일합니다 . 예외는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="81f90f77041e19f7f96b84e59406c9ba0fcd6ff0" translate="yes" xml:space="preserve">
          <source>The optional parameters for the one-shot function &lt;code&gt;inflate&lt;/code&gt; are (for the most part) identical to those used with the OO interface defined in the &lt;a href=&quot;#Constructor-Options&quot;&gt;&quot;Constructor Options&quot;&lt;/a&gt; section. The exceptions are listed below</source>
          <target state="translated">원샷 기능에 대한 선택적 매개 변수 &lt;code&gt;inflate&lt;/code&gt; 에 정의 객체 지향 인터페이스를 사용하는 것과 동일 (대부분의 경우)입니다 &lt;a href=&quot;#Constructor-Options&quot;&gt;&quot;생성자 옵션&quot;&lt;/a&gt; 절을 참조하십시오. 예외는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d34c4bd457be8b3eca1d1b50327dc8555ebf3e0c" translate="yes" xml:space="preserve">
          <source>The optional parameters for the one-shot function &lt;code&gt;rawdeflate&lt;/code&gt; are (for the most part) identical to those used with the OO interface defined in the &lt;a href=&quot;#Constructor-Options&quot;&gt;&quot;Constructor Options&quot;&lt;/a&gt; section. The exceptions are listed below</source>
          <target state="translated">원샷 함수 &lt;code&gt;rawdeflate&lt;/code&gt; 의 선택적 매개 변수 는 (대부분) &lt;a href=&quot;#Constructor-Options&quot;&gt;&quot;생성자 옵션&quot;&lt;/a&gt; 섹션에 정의 된 OO 인터페이스와 함께 사용되는 매개 변수 와 동일합니다 . 예외는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="da3088b2b3f74fb962460f08bf6c521a6489c8dc" translate="yes" xml:space="preserve">
          <source>The optional parameters for the one-shot function &lt;code&gt;rawinflate&lt;/code&gt; are (for the most part) identical to those used with the OO interface defined in the &lt;a href=&quot;#Constructor-Options&quot;&gt;&quot;Constructor Options&quot;&lt;/a&gt; section. The exceptions are listed below</source>
          <target state="translated">원샷 함수 &lt;code&gt;rawinflate&lt;/code&gt; 에 대한 선택적 매개 변수 는 (대부분) &lt;a href=&quot;#Constructor-Options&quot;&gt;&quot;생성자 옵션&quot;&lt;/a&gt; 섹션에 정의 된 OO 인터페이스와 함께 사용되는 매개 변수 와 동일합니다 . 예외는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="564a4703e441e1aa249188b7a46aeee40f3cb3e0" translate="yes" xml:space="preserve">
          <source>The optional parameters for the one-shot function &lt;code&gt;unzip&lt;/code&gt; are (for the most part) identical to those used with the OO interface defined in the &lt;a href=&quot;#Constructor-Options&quot;&gt;&quot;Constructor Options&quot;&lt;/a&gt; section. The exceptions are listed below</source>
          <target state="translated">원샷 기능 &lt;code&gt;unzip&lt;/code&gt; 에 대한 선택적 매개 변수 는 (대부분의 경우) &lt;a href=&quot;#Constructor-Options&quot;&gt;&quot;생성자 옵션&quot;&lt;/a&gt; 섹션에 정의 된 OO 인터페이스와 함께 사용되는 매개 변수 와 동일합니다 . 예외는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e1bd6c00e2144ea2637c42a56845ca5419370d66" translate="yes" xml:space="preserve">
          <source>The optional parameters for the one-shot function &lt;code&gt;zip&lt;/code&gt; are (for the most part) identical to those used with the OO interface defined in the &lt;a href=&quot;#Constructor-Options&quot;&gt;&quot;Constructor Options&quot;&lt;/a&gt; section. The exceptions are listed below</source>
          <target state="translated">원샷 함수 &lt;code&gt;zip&lt;/code&gt; 에 대한 선택적 매개 변수 는 &lt;a href=&quot;#Constructor-Options&quot;&gt;&quot;생성자 옵션&quot;&lt;/a&gt; 섹션에 정의 된 OO 인터페이스에 사용되는 것과 동일합니다 . 예외는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b6ca67d9f48cf9586e57f2ed1e1217218181099d" translate="yes" xml:space="preserve">
          <source>The optional second parameter is ignored if it is larger than the actual length of the first parameter string.</source>
          <target state="translated">선택적 두 번째 매개 변수가 첫 번째 매개 변수 문자열의 실제 길이보다 크면 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="a213bd4ecadb16ed12c21fa427d78bb53fa09a37" translate="yes" xml:space="preserve">
          <source>The options listed above customize parts of the default header, but setting &lt;code&gt;html_header&lt;/code&gt; or &lt;code&gt;html_footer&lt;/code&gt; completely overrides the built-in header or footer. These may be useful if you want to use template tags instead of literal HTML headers and footers or are integrating converted POD pages in a larger website.</source>
          <target state="translated">위에 나열된 옵션은 기본 머리글의 일부를 사용자 정의하지만 &lt;code&gt;html_header&lt;/code&gt; 또는 &lt;code&gt;html_footer&lt;/code&gt; 를 설정 하면 내장 머리글 또는 바닥 글이 완전히 무시됩니다. 리터럴 HTML 헤더 및 바닥 글 대신 템플릿 태그를 사용하거나 더 큰 웹 사이트에서 변환 된 POD 페이지를 통합하려는 경우에 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="01a4d13b9aa02b31aa3157b7bf6c6d232ea80269" translate="yes" xml:space="preserve">
          <source>The options listed in this section control how the</source>
          <target state="translated">이 섹션에 나열된 옵션은</target>
        </trans-unit>
        <trans-unit id="73d081dbc5fcc08b3b44f6576034c6838b070bec" translate="yes" xml:space="preserve">
          <source>The options to this argument is a list of either directories that are searched recursively, or files. (Usually you wouldn't specify files, but just dirs.) Or you can just specify an empty-list, as in $name2path; with the &lt;code&gt;inc&lt;/code&gt; option on, as it is by default.</source>
          <target state="translated">이 인수에 대한 옵션은 재귀 적으로 검색되는 디렉토리 또는 파일 목록입니다. (일반적으로 파일을 지정하지 않고 단지 dirs 일뿐입니다.) 또는 $ name2path와 같이 빈 목록을 지정할 수도 있습니다. 와 &lt;code&gt;inc&lt;/code&gt; 는 기본적으로 한,에 대한 옵션을 선택합니다.</target>
        </trans-unit>
        <trans-unit id="f0865be52cedbd9c729cf95a5b09eba31832648b" translate="yes" xml:space="preserve">
          <source>The optree is shared between threads. This means there is a possibility that the optree will outlive the particular thread (and therefore the interpreter instance) that created it, so true Perl scalars cannot be stored in the optree. Instead a compact form is used, which can only store values that are integers (signed and unsigned), strings or &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; - references and floating point values are stringified. If you need to store multiple values or complex structures, you should serialise them, for example with &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt;. The deletion of a hash key from &lt;code&gt;%^H&lt;/code&gt; is recorded, and as ever can be distinguished from the existence of a key with value &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; with &lt;code&gt;&lt;a href=&quot;functions/exists&quot;&gt;exists&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">optree는 스레드간에 공유됩니다. 이는 optree가이를 생성 한 특정 스레드 (및 인터프리터 인스턴스)보다 오래 지속될 가능성이 있으므로 true Perl 스칼라를 optree에 저장할 수 없음을 의미합니다. 대신 정수 (부호 및 부호없는), 문자열 또는 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 참조 값 및 부동 소수점 값만 문자열화할 수있는 간단한 형식이 사용됩니다 . 여러 값 또는 복잡한 구조를 저장해야하는 경우 &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; 과 같이 직렬화해야합니다 . &lt;code&gt;%^H&lt;/code&gt; 에서 해시 키 삭제 가 기록되며, &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 를 사용 하여 값이있는 키의 존재와 구별 될 수 있습니다. &lt;code&gt;&lt;a href=&quot;functions/exists&quot;&gt;exists&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="758267caaf6c4060844acf8b5ceecd9fefe29a51" translate="yes" xml:space="preserve">
          <source>The optree is shared between threads. This means there is a possibility that the optree will outlive the particular thread (and therefore the interpreter instance) that created it, so true Perl scalars cannot be stored in the optree. Instead a compact form is used, which can only store values that are integers (signed and unsigned), strings or &lt;code&gt;undef&lt;/code&gt; - references and floating point values are stringified. If you need to store multiple values or complex structures, you should serialise them, for example with &lt;code&gt;pack&lt;/code&gt;. The deletion of a hash key from &lt;code&gt;%^H&lt;/code&gt; is recorded, and as ever can be distinguished from the existence of a key with value &lt;code&gt;undef&lt;/code&gt; with &lt;code&gt;exists&lt;/code&gt;.</source>
          <target state="translated">optree는 스레드간에 공유됩니다. 이것은 optree가 그것을 생성 한 특정 쓰레드 (그리고 인터프리터 인스턴스)보다 오래 살아남을 가능성이 있다는 것을 의미합니다. 그래서 진정한 Perl 스칼라는 optree에 저장 될 수 없습니다. 대신 정수 (부호 및 부호 없음), 문자열 또는 &lt;code&gt;undef&lt;/code&gt; 인 값만 저장할 수있는 압축 형식이 사용됩니다. 참조 및 부동 소수점 값은 문자열 화됩니다. 여러 값이나 복잡한 구조를 저장해야하는 경우이를 직렬화해야합니다 (예 : &lt;code&gt;pack&lt;/code&gt; ) . 에서 해시 키를 삭제 &lt;code&gt;%^H&lt;/code&gt; 기록되고, 변함 값 키의 존재를 구별 할 수 &lt;code&gt;undef&lt;/code&gt; 로 &lt;code&gt;exists&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="96c80c62d3615e8dcdce9b967100a640447d19ae" translate="yes" xml:space="preserve">
          <source>The order in which objects are destroyed during the global destruction before the program exits is unpredictable. This means that any objects contained by your object may already have been destroyed. You should check that a contained object is defined before calling a method on it:</source>
          <target state="translated">프로그램이 종료되기 전에 전역 소멸 중에 오브젝트가 소멸되는 순서는 예측할 수 없습니다. 즉, 개체에 포함 된 모든 개체가 이미 손상되었을 수 있습니다. 메소드를 호출하기 전에 포함 된 오브젝트가 정의되어 있는지 확인해야합니다.</target>
        </trans-unit>
        <trans-unit id="1362f44821baf70a0c53e26c223d4e933d506d90" translate="yes" xml:space="preserve">
          <source>The order in which this test was run for the given test suite result.</source>
          <target state="translated">주어진 테스트 스위트 결과에 대해이 테스트가 실행 된 순서.</target>
        </trans-unit>
        <trans-unit id="49bfec1872d74cc3aa3b51bdca30781b5d81ee87" translate="yes" xml:space="preserve">
          <source>The order into which &lt;b&gt;characters&lt;/b&gt; sort. This is used by &lt;b&gt;string&lt;/b&gt; comparison routines to decide, for example, where in this glossary to put &amp;ldquo;collating sequence&amp;rdquo;.</source>
          <target state="translated">&lt;b&gt;문자가&lt;/b&gt; 정렬 되는 순서 입니다. 예를 들어이 용어집에서 &quot;collating sequence&quot;를 배치 할 위치를 결정하기 위해 &lt;b&gt;문자열&lt;/b&gt; 비교 루틴에 의해 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="90461643a4b9bcbbb16f181372c5e7705b398666" translate="yes" xml:space="preserve">
          <source>The order of any groups including scripts is not changed.</source>
          <target state="translated">스크립트를 포함한 그룹의 순서는 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="717cecbd54045d9533e4eb5b41c7c271d10ce913" translate="yes" xml:space="preserve">
          <source>The order of arguments differs from that of open2().</source>
          <target state="translated">인수의 순서는 open2 ()의 순서와 다릅니다.</target>
        </trans-unit>
        <trans-unit id="1338c98402171198f17cc3c818e89af7db3bfea3" translate="yes" xml:space="preserve">
          <source>The order of arguments differs from that of open3().</source>
          <target state="translated">인수의 순서는 open3 ()의 순서와 다릅니다.</target>
        </trans-unit>
        <trans-unit id="c7058991786845d90ace9e46987253e3ce531354" translate="yes" xml:space="preserve">
          <source>The ordering is the same as for the regular expression which is the result of</source>
          <target state="translated">순서는 다음의 결과 인 정규식과 동일합니다.</target>
        </trans-unit>
        <trans-unit id="e57a83be29caa0cba0eac2c66aec01c8ecc059c8" translate="yes" xml:space="preserve">
          <source>The ordering is the same as for the regular expression which is the result of EXPR, or the pattern contained by capture group</source>
          <target state="translated">순서는 EXPR의 결과 인 정규식 또는 캡처 그룹에 포함 된 패턴과 동일합니다.</target>
        </trans-unit>
        <trans-unit id="0f9c7f78b473deec8b2b7b3c5ae964aaebd4ae76" translate="yes" xml:space="preserve">
          <source>The original &lt;code&gt;MD5&lt;/code&gt; interface was written by Neil Winton (&lt;code&gt;N.Winton@axion.bt.co.uk&lt;/code&gt; ).</source>
          <target state="translated">원래 &lt;code&gt;MD5&lt;/code&gt; 인터페이스는 Neil Winton ( &lt;code&gt;N.Winton@axion.bt.co.uk&lt;/code&gt; ) 이 작성했습니다. ) .</target>
        </trans-unit>
        <trans-unit id="a967938ebcc10e8da7bfe2a06eaff58eb4186ec0" translate="yes" xml:space="preserve">
          <source>The original &lt;code&gt;MD5&lt;/code&gt; interface was written by Neil Winton (&lt;code&gt;N.Winton@axion.bt.co.uk&lt;/code&gt;).</source>
          <target state="translated">원래 &lt;code&gt;MD5&lt;/code&gt; 인터페이스는 Neil Winton ( &lt;code&gt;N.Winton@axion.bt.co.uk&lt;/code&gt; ) 이 작성했습니다 .</target>
        </trans-unit>
        <trans-unit id="7eb97de2fdb41a38605a8a09e6520652a52c56e7" translate="yes" xml:space="preserve">
          <source>The original Dylan paper</source>
          <target state="translated">딜런 원본</target>
        </trans-unit>
        <trans-unit id="50fea78ce2537fb78816d81a4d2374f6c7eff868" translate="yes" xml:space="preserve">
          <source>The original Pod::Text contained code to do formatting via termcap sequences, although it wasn't turned on by default and it was problematic to get it to work at all. This rewrite doesn't even try to do that, but a subclass of it does. Look for &lt;a href=&quot;Pod::Text::Termcap&quot;&gt;Pod::Text::Termcap&lt;/a&gt;.</source>
          <target state="translated">원래 Pod :: Text에는 termcap 시퀀스를 통해 서식을 지정하는 코드가 포함되어 있었지만 기본적으로 켜져 있지 않고 전혀 작동하지 않는 데 문제가있었습니다. 이 재 작성은 그렇게하려는 시도조차하지 않지만 하위 클래스는 수행합니다. &lt;a href=&quot;Pod::Text::Termcap&quot;&gt;Pod :: Text :: Termcap을&lt;/a&gt; 찾습니다 .</target>
        </trans-unit>
        <trans-unit id="af612d63faee2dc3856c86fd5cc671079598e557" translate="yes" xml:space="preserve">
          <source>The original Pod::Text contained code to do formatting via termcap sequences, although it wasn't turned on by default and it was problematic to get it to work at all. This rewrite doesn't even try to do that, but a subclass of it does. Look for &lt;a href=&quot;text/termcap&quot;&gt;Pod::Text::Termcap&lt;/a&gt;.</source>
          <target state="translated">원래 Pod :: Text에는 termcap 시퀀스를 통해 서식을 지정하는 코드가 포함되어 있지만 기본적으로 설정되어 있지 않으며 전혀 작동하지 않는 문제가있었습니다. 이 재 작성은 그렇게하려고 시도하지 않지만 하위 클래스는 그렇게합니다. &lt;a href=&quot;text/termcap&quot;&gt;Pod :: Text :: Termcap을&lt;/a&gt; 찾으십시오 .</target>
        </trans-unit>
        <trans-unit id="07dd5b1a0e82d303f2b0b28746eab063467b6ba7" translate="yes" xml:space="preserve">
          <source>The original UTF-8 specification allowed up to 6 bytes, to allow encoding of numbers up to &lt;code&gt;0x7FFF_FFFF&lt;/code&gt; . Perl continues to allow those, and has extended that up to 13 bytes to encode code points up to what can fit in a 64-bit word. However, Perl will warn if you output any of these as being non-portable; and under strict UTF-8 input protocols, they are forbidden.</source>
          <target state="translated">원래 UTF-8 사양은 최대 6 바이트를 허용하여 최대 &lt;code&gt;0x7FFF_FFFF&lt;/code&gt; 의 숫자 인코딩을 허용합니다. 합니다. Perl은이를 계속 허용하며 64 비트 워드에 맞는 코드 포인트를 인코딩하기 위해 최대 13 바이트까지 확장했습니다. 그러나 Perl은이 중 하나를 이식 불가능한 것으로 출력하면 경고합니다. 엄격한 UTF-8 입력 프로토콜에서는 금지되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="00b0e9de1cd640deb40f9e9ac2ea76a7fdd363f8" translate="yes" xml:space="preserve">
          <source>The original UTF-8 specification allowed up to 6 bytes, to allow encoding of numbers up to &lt;code&gt;0x7FFF_FFFF&lt;/code&gt;. Perl continues to allow those, and has extended that up to 13 bytes to encode code points up to what can fit in a 64-bit word. However, Perl will warn if you output any of these as being non-portable; and under strict UTF-8 input protocols, they are forbidden. In addition, it is now illegal to use a code point larger than what a signed integer variable on your system can hold. On 32-bit ASCII systems, this means &lt;code&gt;0x7FFF_FFFF&lt;/code&gt; is the legal maximum (much higher on 64-bit systems).</source>
          <target state="translated">원래 UTF-8 사양에서는 최대 6 바이트를 허용하여 최대 &lt;code&gt;0x7FFF_FFFF&lt;/code&gt; 까지 숫자를 인코딩 할 수 있습니다. Perl은이를 계속해서 허용하고 있으며 64 비트 워드에 들어갈 수있는 코드 포인트를 인코딩하기 위해 최대 13 바이트까지 확장했습니다. 그러나 Perl은 이들 중 하나라도 이식 불가능한 것으로 출력하면 경고합니다. 엄격한 UTF-8 입력 프로토콜에서는 금지되어 있습니다. 또한 시스템의 부호있는 정수 변수가 보유 할 수있는 것보다 큰 코드 포인트를 사용하는 것은 이제 불법입니다. 32 비트 ASCII 시스템에서 이는 &lt;code&gt;0x7FFF_FFFF&lt;/code&gt; 가 법적 최대 값 임을 의미 합니다 (64 비트 시스템에서는 훨씬 더 높음).</target>
        </trans-unit>
        <trans-unit id="a0e54c9386e1df6efdb32bc51b43d382c1fa2bb3" translate="yes" xml:space="preserve">
          <source>The original culture of the pre-populist Internet and the deeply-held beliefs of Perl's author, Larry Wall, gave rise to the free and open distribution policy of Perl. Perl is supported by its users. The core, the standard Perl library, the optional modules, and the documentation you're reading now were all written by volunteers.</source>
          <target state="translated">대중 대중 주의적 인터넷의 원래 문화와 Perl의 저자 Larry Wall의 깊은 신념은 Perl의 자유롭고 개방 된 배포 정책을 일으켰습니다. Perl은 사용자가 지원합니다. 핵심, 표준 Perl 라이브러리, 옵션 모듈 및 읽고있는 문서는 모두 자원 봉사자가 작성했습니다.</target>
        </trans-unit>
        <trans-unit id="12a169f5e5252000915162d740c1f7fb51701fdf" translate="yes" xml:space="preserve">
          <source>The original form of &lt;a href=&quot;#cv_get_call_checker_flags&quot;&gt;&quot;cv_get_call_checker_flags&quot;&lt;/a&gt;, which does not return checker flags. When using a checker function returned by this function, it is only safe to call it with a genuine GV as its &lt;code&gt;namegv&lt;/code&gt; argument.</source>
          <target state="translated">검사기 플래그를 반환하지 않는 &lt;a href=&quot;#cv_get_call_checker_flags&quot;&gt;&quot;cv_get_call_checker_flags&quot;&lt;/a&gt; 의 원래 형식입니다 . 이 함수에 의해 반환 된 검사기 함수를 사용할 때 정품 GV를 &lt;code&gt;namegv&lt;/code&gt; 인수 로 사용하여 호출하는 것이 안전합니다 .</target>
        </trans-unit>
        <trans-unit id="eb0e3050b313150315f2790edd37f73f93a916ca" translate="yes" xml:space="preserve">
          <source>The original form of &lt;a href=&quot;#cv_set_call_checker_flags&quot;&gt;&quot;cv_set_call_checker_flags&quot;&lt;/a&gt;, which passes it the &lt;code&gt;CALL_CHECKER_REQUIRE_GV&lt;/code&gt; flag for backward-compatibility. The effect of that flag setting is that the check function is guaranteed to get a genuine GV as its &lt;code&gt;namegv&lt;/code&gt; argument.</source>
          <target state="translated">이전 버전과의 호환성을 위해 &lt;code&gt;CALL_CHECKER_REQUIRE_GV&lt;/code&gt; 플래그를 전달하는 &lt;a href=&quot;#cv_set_call_checker_flags&quot;&gt;&quot;cv_set_call_checker_flags&quot;&lt;/a&gt; 의 원래 형식입니다 . 이 플래그 설정의 효과는 check 함수가 &lt;code&gt;namegv&lt;/code&gt; 인수 로 진짜 GV를 얻도록 보장 된다는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="124cee86525fe9ae3fd7e1b40184ae6b8c5be548" translate="yes" xml:space="preserve">
          <source>The original form of &lt;a href=&quot;#cv_set_call_checker_flags&quot;&gt;cv_set_call_checker_flags&lt;/a&gt;, which passes it the &lt;code&gt;CALL_CHECKER_REQUIRE_GV&lt;/code&gt; flag for backward-compatibility.</source>
          <target state="translated">&lt;a href=&quot;#cv_set_call_checker_flags&quot;&gt;cv_set_call_checker_flags&lt;/a&gt; 의 원래 형식으로 , 이전 버전과의 호환성을 위해 &lt;code&gt;CALL_CHECKER_REQUIRE_GV&lt;/code&gt; 플래그를 전달합니다 .</target>
        </trans-unit>
        <trans-unit id="03b164c5369f7a3512c3a8ff6e7ba584a97c85cb" translate="yes" xml:space="preserve">
          <source>The original format of CPAN Meta files was &lt;a href=&quot;http://search.cpan.org/perldoc/YAML&quot;&gt;YAML&lt;/a&gt; and the corresponding file was called</source>
          <target state="translated">CPAN 메타 파일의 원래 형식은 &lt;a href=&quot;http://search.cpan.org/perldoc/YAML&quot;&gt;YAML&lt;/a&gt; 이며 해당 파일이 호출되었습니다.</target>
        </trans-unit>
        <trans-unit id="12304d794d559e0c5fe4691017042f08f8d52e43" translate="yes" xml:space="preserve">
          <source>The original format of CPAN Meta files was &lt;a href=&quot;yaml&quot;&gt;YAML&lt;/a&gt; and the corresponding file was called</source>
          <target state="translated">CPAN Meta 파일의 원래 형식은 &lt;a href=&quot;yaml&quot;&gt;YAML&lt;/a&gt; 이었고 해당 파일은</target>
        </trans-unit>
        <trans-unit id="cc0efcec67bc372bca64df41283c31757275dca6" translate="yes" xml:space="preserve">
          <source>The original impetus for &lt;code&gt;Perl_langinfo()&lt;/code&gt; was so that code that needs to find out the current currency symbol, floating point radix character, or digit grouping separator can use, on all systems, the simpler and more thread-friendly &lt;code&gt;nl_langinfo&lt;/code&gt; API instead of &lt;code&gt;&lt;a href=&quot;http://man.he.net/man3/localeconv&quot;&gt;localeconv(3)&lt;/a&gt;&lt;/code&gt; which is a pain to make thread-friendly. For other fields returned by &lt;code&gt;localeconv&lt;/code&gt;, it is better to use the methods given in &lt;a href=&quot;perlcall&quot;&gt;perlcall&lt;/a&gt; to call &lt;a href=&quot;posix#localeconv&quot;&gt;&lt;code&gt;POSIX::localeconv()&lt;/code&gt;&lt;/a&gt;, which is thread-friendly.</source>
          <target state="translated">의 원래 자극 &lt;code&gt;Perl_langinfo()&lt;/code&gt; 필요 포인트 기수 문자를 부동, 또는, 현재의 통화 기호를 찾을 것을 그 코드 있도록 하였다 자리, 모든 시스템에서 사용할 수있는 간단하고 스레드 친화적 인 분리를 그룹화 &lt;code&gt;nl_langinfo&lt;/code&gt; 의 대신 API를 &lt;code&gt;&lt;a href=&quot;http://man.he.net/man3/localeconv&quot;&gt;localeconv(3)&lt;/a&gt;&lt;/code&gt; 스레드 친화적으로 만드는 것이 고통입니다. &lt;code&gt;localeconv&lt;/code&gt; 에 의해 반환 된 다른 필드의 경우 &lt;a href=&quot;perlcall&quot;&gt;perlcall&lt;/a&gt; 에 제공된 메서드를 사용하여 스레드 친화적 인 &lt;a href=&quot;posix#localeconv&quot;&gt; &lt;code&gt;POSIX::localeconv()&lt;/code&gt; &lt;/a&gt; 를 호출 하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="3411d71283c2f07e45c5a35c0fcbe60c51f6b9bb" translate="yes" xml:space="preserve">
          <source>The original purpose of source filters was to let you encrypt your program source to prevent casual piracy. This isn't all they can do, as you'll soon learn. But first, the basics.</source>
          <target state="translated">소스 필터의 원래 목적은 일반적인 불법 복제를 방지하기 위해 프로그램 소스를 암호화 할 수 있도록하는 것입니다. 곧 배울 수 있듯이 이것이 그들이 할 수있는 전부는 아닙니다. 그러나 먼저 기본 사항.</target>
        </trans-unit>
        <trans-unit id="af210dcaae99ceb3aa829035af3557a9ff65ef3a" translate="yes" xml:space="preserve">
          <source>The original stack mark for the XSUB. See &lt;code&gt;&lt;a href=&quot;#dORIGMARK&quot;&gt;&quot;dORIGMARK&quot;&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">XSUB의 원래 스택 표시입니다. &lt;code&gt;&lt;a href=&quot;#dORIGMARK&quot;&gt;&quot;dORIGMARK&quot;&lt;/a&gt;&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a310ea971545c067e472063428469fc1fad9aa30" translate="yes" xml:space="preserve">
          <source>The original stack mark for the XSUB. See &lt;code&gt;dORIGMARK&lt;/code&gt; .</source>
          <target state="translated">XSUB의 원래 스택 마크입니다. &lt;code&gt;dORIGMARK&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d9fdbd5653ee6341eabe4730cc34935e3db7a992" translate="yes" xml:space="preserve">
          <source>The original style uses blanks and hyphens in the block names (except for &lt;code&gt;No_Block&lt;/code&gt; ), like so:</source>
          <target state="translated">원래 스타일은 다음과 같이 블록 이름에 공백과 하이픈을 사용합니다 ( &lt;code&gt;No_Block&lt;/code&gt; 제외 ).</target>
        </trans-unit>
        <trans-unit id="5c736b5ceaedaf0c5b862acefcb315ae2bd5b9ab" translate="yes" xml:space="preserve">
          <source>The original style uses blanks and hyphens in the block names (except for &lt;code&gt;No_Block&lt;/code&gt;), like so:</source>
          <target state="translated">원래 스타일은 다음과 같이 블록 이름에 공백과 하이픈을 사용합니다 ( &lt;code&gt;No_Block&lt;/code&gt; 제외 ).</target>
        </trans-unit>
        <trans-unit id="8dcbc33a95cd67473b45a522488fc8cc805a4f47" translate="yes" xml:space="preserve">
          <source>The original title was</source>
          <target state="translated">원래 제목은</target>
        </trans-unit>
        <trans-unit id="07db5f54ef4c59c897a817d5ccebc37f60d9a5b6" translate="yes" xml:space="preserve">
          <source>The original true/false value of whatever was passed into the event (but reduced down to 1 or 0).</source>
          <target state="translated">이벤트에 전달 된 모든 항목의 원래 참 / 거짓 값 (그러나 1 또는 0으로 감소).</target>
        </trans-unit>
        <trans-unit id="9e60244f8f199981b052b42233461b69e602ecf3" translate="yes" xml:space="preserve">
          <source>The original usage can be accomplished by explicit (rather than this pragma's implicit) encoding using the &lt;a href=&quot;encode&quot;&gt;Encode&lt;/a&gt; module:</source>
          <target state="translated">원래 사용은 &lt;a href=&quot;encode&quot;&gt;Encode&lt;/a&gt; 모듈을 사용하여 명시 적 (이 pragma의 암시 적 대신) 인코딩으로 수행 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7ea4b9a6cd75e55515170d81fe9ec6a923c1c00a" translate="yes" xml:space="preserve">
          <source>The original version of B::Terse was written by Malcolm Beattie, &amp;lt;mbeattie@sable.ox.ac.uk&amp;gt;. This wrapper was written by Stephen McCamant, &amp;lt;smcc@MIT.EDU&amp;gt;.</source>
          <target state="translated">B :: Terse의 원래 버전은 Malcolm Beattie (&amp;lt;mbeattie@sable.ox.ac.uk&amp;gt;)가 작성했습니다. 이 래퍼는 Stephen McCamant, &amp;lt;smcc@MIT.EDU&amp;gt;에 의해 작성되었습니다.</target>
        </trans-unit>
        <trans-unit id="ba66fcf36669927e93622e0a65ee5e2d5c9bffdb" translate="yes" xml:space="preserve">
          <source>The original version of PA-RISC, HP no longer sells any system with this chip.</source>
          <target state="translated">PA-RISC의 원래 버전 인 HP는 더 이상이 칩이있는 시스템을 판매하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0705420ac769cdd445f5fb673329007ec7bccb68" translate="yes" xml:space="preserve">
          <source>The original version of this article originally appeared in The Perl Journal #10, and is copyright 1998 The Perl Journal. It appears courtesy of Jon Orwant and The Perl Journal. This document may be distributed under the same terms as Perl itself.</source>
          <target state="translated">이 기사의 원래 버전은 원래 Perl Journal # 10에 실 렸으며 1998 년 저작권 Perl Journal에 저작권이 있습니다. Jon Orwant와 The Perl Journal이 제공 한 것으로 보입니다. 이 문서는 Perl 자체와 동일한 용어로 배포 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9009e0d18f1d5f332e2819aa4a5b08efaa84ba15" translate="yes" xml:space="preserve">
          <source>The original was written by Andy Dougherty</source>
          <target state="translated">Andy Dougherty가 쓴 원본</target>
        </trans-unit>
        <trans-unit id="ac8cde9199e82022f2799533159dbf659a64016b" translate="yes" xml:space="preserve">
          <source>The other &lt;code&gt;OA_*&lt;/code&gt; constants should not be used.</source>
          <target state="translated">다른 &lt;code&gt;OA_*&lt;/code&gt; 상수는 사용하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="e99c9d2a05f195a52a6e3dccd804ac6a0edaa601" translate="yes" xml:space="preserve">
          <source>The other &lt;code&gt;parser_&lt;i&gt;whatever&lt;/i&gt;&lt;/code&gt; methods are meant to be called only once per &lt;code&gt;$parser&lt;/code&gt; object; but &lt;code&gt;parse_lines&lt;/code&gt; can be called as many times per &lt;code&gt;$parser&lt;/code&gt; object as you want, as long as the last call (and only the last call) ends with an &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; value.</source>
          <target state="translated">다른 &lt;code&gt;parser_&lt;i&gt;whatever&lt;/i&gt;&lt;/code&gt; 방법이 의미 만에 한 번 호출 할 수 &lt;code&gt;$parser&lt;/code&gt; 객체; 그러나 마지막 호출 (및 마지막 호출 만)이 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 값으로 끝나는 한 &lt;code&gt;$parser&lt;/code&gt; 객체 당 &lt;code&gt;parse_lines&lt;/code&gt; 를 원하는만큼 호출 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6c95c0f77be936d4feacc6aa823fe8dfa8595f61" translate="yes" xml:space="preserve">
          <source>The other &lt;code&gt;parser_&lt;i&gt;whatever&lt;/i&gt;&lt;/code&gt; methods are meant to be called only once per &lt;code&gt;$parser&lt;/code&gt; object; but &lt;code&gt;parse_lines&lt;/code&gt; can be called as many times per &lt;code&gt;$parser&lt;/code&gt; object as you want, as long as the last call (and only the last call) ends with an &lt;code&gt;undef&lt;/code&gt; value.</source>
          <target state="translated">다른 &lt;code&gt;parser_&lt;i&gt;whatever&lt;/i&gt;&lt;/code&gt; 메소드는 &lt;code&gt;$parser&lt;/code&gt; 객체 당 한 번만 호출됩니다 . 그러나 &lt;code&gt;parse_lines&lt;/code&gt; 는 마지막 호출 (및 마지막 호출 만)이 &lt;code&gt;undef&lt;/code&gt; 값으로 끝나는 한 &lt;code&gt;$parser&lt;/code&gt; 개체 당 원하는 만큼 여러 번 호출 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f0806e4bd09cd5bd6dbaceaf9c0baff74d032490" translate="yes" xml:space="preserve">
          <source>The other arguments should look familiar if you know &lt;code&gt;STORABLE_freeze&lt;/code&gt; :</source>
          <target state="translated">&lt;code&gt;STORABLE_freeze&lt;/code&gt; 를 알고 있다면 다른 인수는 익숙해 보일 것입니다 .</target>
        </trans-unit>
        <trans-unit id="6d6b16332403f12890e319d0cef347a3dc9b9bef" translate="yes" xml:space="preserve">
          <source>The other arguments should look familiar if you know &lt;code&gt;STORABLE_freeze&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;STORABLE_freeze&lt;/code&gt; 를 알고 있다면 다른 인수는 익숙해 보일 것입니다 .</target>
        </trans-unit>
        <trans-unit id="407b63c5d1d6303ca3afdf08c491fa75e0221db1" translate="yes" xml:space="preserve">
          <source>The other big problem with &lt;code&gt;$^W&lt;/code&gt; is the way you can inadvertently change the warning setting in unexpected places in your code. For example, when the code below is run (without the &lt;b&gt;-w&lt;/b&gt; flag), the second call to &lt;code&gt;doit&lt;/code&gt; will trip a &lt;code&gt;&quot;Use of uninitialized value&quot;&lt;/code&gt; warning, whereas the first will not.</source>
          <target state="translated">&lt;code&gt;$^W&lt;/code&gt; 또 다른 큰 문제 는 코드의 예기치 않은 위치에서 실수로 경고 설정을 변경할 수있는 방법입니다. 예를 들어, 아래 코드가 실행되면 ( &lt;b&gt;-w&lt;/b&gt; 플래그 없이 ) 두 번째 &lt;code&gt;doit&lt;/code&gt; 호출 은 &lt;code&gt;&quot;Use of uninitialized value&quot;&lt;/code&gt; 경고를 트립 하지만 첫 번째 코드는 그렇지 않습니다.</target>
        </trans-unit>
        <trans-unit id="fc649a384c23c44b5ba2efe0b85df4a20e6ec321" translate="yes" xml:space="preserve">
          <source>The other cases require a little bit more convoluted procedures. Below I suppose that the current version of Perl is &lt;code&gt;5.8.2&lt;/code&gt; , so the executables are named accordingly.</source>
          <target state="translated">다른 경우에는 좀 더 복잡한 절차가 필요합니다. 아래에서는 Perl의 현재 버전이 &lt;code&gt;5.8.2&lt;/code&gt; 라고 가정 하여 실행 파일의 이름이 적절하게 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="427a9edc8baf371e22d2821e2812db4f5b95659f" translate="yes" xml:space="preserve">
          <source>The other cases require a little bit more convoluted procedures. Below I suppose that the current version of Perl is &lt;code&gt;5.8.2&lt;/code&gt;, so the executables are named accordingly.</source>
          <target state="translated">다른 경우에는 좀 더 복잡한 절차가 필요합니다. 아래에서는 Perl의 현재 버전이 &lt;code&gt;5.8.2&lt;/code&gt; 라고 가정 하므로 실행 파일의 이름이 그에 따라 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="97290d4117a272682128f8d28555111afe13c240" translate="yes" xml:space="preserve">
          <source>The other common cause is for the characters</source>
          <target state="translated">다른 일반적인 원인은 캐릭터에 대한 것입니다.</target>
        </trans-unit>
        <trans-unit id="c457b75f143400140761950573f5b842848c756c" translate="yes" xml:space="preserve">
          <source>The other counterpart, in the column labelled &quot;Full-range Unicode&quot;, matches any appropriate characters in the full Unicode character set. For example, &lt;code&gt;\p{Alpha}&lt;/code&gt; matches not just the ASCII alphabetic characters, but any character in the entire Unicode character set considered alphabetic. An entry in the column labelled &quot;backslash sequence&quot; is a (short) equivalent.</source>
          <target state="translated">&quot;Full-range Unicode&quot;열에있는 다른 상대방은 전체 유니 코드 문자 집합의 해당 문자와 ​​일치합니다. 예를 들어, &lt;code&gt;\p{Alpha}&lt;/code&gt; 는 ASCII 알파벳 문자뿐만 아니라 전체 유니 코드 문자 집합의 모든 문자가 알파벳으로 간주됩니다. &quot;백 슬래시 시퀀스&quot;라고 표시된 열의 항목은 (짧은) 항목입니다.</target>
        </trans-unit>
        <trans-unit id="f185e517dca4682b63e353adac3daa559be38725" translate="yes" xml:space="preserve">
          <source>The other form is called &quot;block eval&quot;. It is less general than string eval, but the code within the BLOCK is parsed only once (at the same time the code surrounding the &lt;code&gt;eval&lt;/code&gt; itself was parsed) and executed within the context of the current Perl program. This form is typically used to trap exceptions more efficiently than the first, while also providing the benefit of checking the code within BLOCK at compile time. BLOCK is parsed and compiled just once. Since errors are trapped, it often is used to check if a given feature is available.</source>
          <target state="translated">다른 형식은 &quot;블록 평가&quot;라고합니다. 문자열 eval보다 덜 일반적이지만 BLOCK 내의 코드는 한 번만 구문 분석되고 (동시에 &lt;code&gt;eval&lt;/code&gt; 자체를 둘러싼 코드 가 구문 분석 됨) 현재 Perl 프로그램의 컨텍스트 내에서 실행됩니다. 이 형식은 일반적으로 첫 번째 형식보다 더 효율적으로 예외를 트랩하는 데 사용되는 동시에 컴파일 타임에 BLOCK 내에서 코드를 확인하는 이점을 제공합니다. BLOCK은 한 번만 구문 분석되고 컴파일됩니다. 오류가 트랩되기 때문에 주어진 기능을 사용할 수 있는지 확인하는 데 자주 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="ece66aa413156fc84b73d204d2d9bbbf0fe1c18a" translate="yes" xml:space="preserve">
          <source>The other hack is to restore FP flags after a call to dlopen(). This helps against similar damage done by DLLs _DLLInitTerm() at runtime. Currently no way to switch these hacks off is provided.</source>
          <target state="translated">다른 해킹은 dlopen () 호출 후 FP 플래그를 복원하는 것입니다. 이는 런타임시 DLL _DLLInitTerm ()에 의해 수행 된 유사한 손상을 방지하는 데 도움이됩니다. 현재 이러한 핵을 끄는 방법은 없습니다.</target>
        </trans-unit>
        <trans-unit id="9303fbfd8a21fb685b416cbb44c3a447eed84853" translate="yes" xml:space="preserve">
          <source>The other is to install the module in a temporary location.</source>
          <target state="translated">다른 하나는 임시 위치에 모듈을 설치하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="7370aa653e76af4b47e0ca0cfb340c944499961e" translate="yes" xml:space="preserve">
          <source>The other modification made is that</source>
          <target state="translated">다른 수정은</target>
        </trans-unit>
        <trans-unit id="5eaa26235f36f66db1f5d49d6f66d3b1d7e346a6" translate="yes" xml:space="preserve">
          <source>The other one is &quot;Common&quot;. This consists of mostly punctuation, emoji, and characters used in mathematics and music, the ASCII digits &lt;code&gt;0&lt;/code&gt; through &lt;code&gt;9&lt;/code&gt;, and full-width forms of these digits. These characters can appear intermixed in text in many of the world's scripts. These also don't cause a script run to not match. But like other scripts, all digits in a run must come from the same set of 10.</source>
          <target state="translated">다른 하나는 &quot;공통&quot;입니다. 대부분 구두점, 그림 이모티콘, 수학 및 음악에 사용되는 문자, ASCII 숫자 &lt;code&gt;0&lt;/code&gt; ~ &lt;code&gt;9&lt;/code&gt; 및 이러한 숫자의 전자 형식으로 구성됩니다. 이러한 문자는 전 세계의 많은 스크립트에서 텍스트에 혼합되어 나타날 수 있습니다. 이것들은 또한 스크립트 실행이 일치하지 않게하지 않습니다. 그러나 다른 스크립트와 마찬가지로 실행의 모든 ​​숫자는 동일한 10 개 집합에서 가져와야합니다.</target>
        </trans-unit>
        <trans-unit id="52e0e078ed7f59ceb7388f298d1ea1da0c3bdb08" translate="yes" xml:space="preserve">
          <source>The other reason why using a variable to hold the name of another variable is a bad idea is that the question often stems from a lack of understanding of Perl data structures, particularly hashes. By using symbolic references, you are just using the package's symbol-table hash (like &lt;code&gt;%main::&lt;/code&gt; ) instead of a user-defined hash. The solution is to use your own hash or a real reference instead.</source>
          <target state="translated">다른 변수의 이름을 유지하기 위해 변수를 사용하는 것이 나쁜 생각 인 또 다른 이유는 문제는 종종 Perl 데이터 구조, 특히 해시에 대한 이해가 부족하기 때문입니다. 기호 참조를 사용 하면 사용자 정의 해시 대신 패키지의 기호 테이블 해시 (예 : &lt;code&gt;%main::&lt;/code&gt; :)를 사용하면됩니다. 해결책은 자신의 해시 또는 실제 참조를 대신 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="14e65562914f1eda6c3850757c3e36b8e4c292d5" translate="yes" xml:space="preserve">
          <source>The other reason why using a variable to hold the name of another variable is a bad idea is that the question often stems from a lack of understanding of Perl data structures, particularly hashes. By using symbolic references, you are just using the package's symbol-table hash (like &lt;code&gt;%main::&lt;/code&gt;) instead of a user-defined hash. The solution is to use your own hash or a real reference instead.</source>
          <target state="translated">변수를 사용하여 다른 변수의 이름을 유지하는 것이 나쁜 생각 인 또 다른 이유는 질문이 종종 Perl 데이터 구조, 특히 해시에 대한 이해 부족에서 비롯된다는 것입니다. 기호 참조를 사용 하면 사용자 정의 해시 대신 패키지의 기호 테이블 해시 (예 : &lt;code&gt;%main::&lt;/code&gt; :)를 사용하는 것입니다. 해결책은 자신의 해시 또는 실제 참조를 대신 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="d23447e512ad32c2037041f02596c75ecf1a5899" translate="yes" xml:space="preserve">
          <source>The other scalar-returning list reduction functions are all specialisations of this generic idea.</source>
          <target state="translated">다른 스칼라 반환 목록 축소 함수는 모두이 일반적인 아이디어의 전문화입니다.</target>
        </trans-unit>
        <trans-unit id="5743b7f731fc10e9d1778f5bba7c58560baf6a5c" translate="yes" xml:space="preserve">
          <source>The other structure is pointed to by the &lt;code&gt;regexp&lt;/code&gt; struct's &lt;code&gt;pprivate&lt;/code&gt; and is in addition to &lt;code&gt;intflags&lt;/code&gt; in the same struct considered to be the property of the regex engine which compiled the regular expression;</source>
          <target state="translated">다른 구조는 &lt;code&gt;regexp&lt;/code&gt; 구조체의 &lt;code&gt;pprivate&lt;/code&gt; 에 의해 &lt;code&gt;intflags&lt;/code&gt; 되며 정규 표현식을 컴파일 한 regex 엔진의 속성으로 간주되는 동일한 구조체의 intflags 에 추가됩니다 .</target>
        </trans-unit>
        <trans-unit id="5b612d86c256526a7120d0f540436c62b7f8f79b" translate="yes" xml:space="preserve">
          <source>The other synchronization primitives described below can suffer from similar problems.</source>
          <target state="translated">아래에 설명 된 다른 동기화 프리미티브도 비슷한 문제를 겪을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="375bee995645e81f309660da902b757d6a8e656a" translate="yes" xml:space="preserve">
          <source>The other way works too, especially if you are sure that all your data are under the same encoding, or if compatibility with older versions of Perl is desired.</source>
          <target state="translated">다른 방법도 작동합니다. 특히 모든 데이터가 동일한 인코딩으로되어 있다고 확신하거나 이전 버전의 Perl과의 호환성이 필요한 경우 더욱 그렇습니다.</target>
        </trans-unit>
        <trans-unit id="46a4f63ad2418ff7f127884608b4d5e8c00d7b27" translate="yes" xml:space="preserve">
          <source>The others shouldn't be used in a threaded application.</source>
          <target state="translated">나머지는 스레드 응용 프로그램에서 사용해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="a811a8ea9dab8327d772322e2e441ab82ca0e86f" translate="yes" xml:space="preserve">
          <source>The output field separator for the print operator. If defined, this value is printed between each of print's arguments. Default is &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">인쇄 연산자의 출력 필드 구분 기호입니다. 정의 된 경우이 값은 각 인쇄 인수 사이에 인쇄됩니다. 기본값은 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="fdf1adf4fd2953bb9b8993988459b89f053c2344" translate="yes" xml:space="preserve">
          <source>The output field separator for the print operator. If defined, this value is printed between each of print's arguments. Default is &lt;code&gt;undef&lt;/code&gt;.</source>
          <target state="translated">인쇄 연산자의 출력 필드 구분 기호입니다. 정의 된 경우이 값은 각 인쇄의 인수 사이에 인쇄됩니다. 기본값은 &lt;code&gt;undef&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="4e6a9347f20222b252ad3782a91c8dbdeaeb1ab5" translate="yes" xml:space="preserve">
          <source>The output file to print to. If the special names &quot;-&quot; or &quot;&amp;gt;&amp;amp;1&quot; or &quot;&amp;gt;&amp;amp;STDOUT&quot; are used then standard output is used. If &quot;&amp;gt;&amp;amp;2&quot; or &quot;&amp;gt;&amp;amp;STDERR&quot; is used then standard error is used.</source>
          <target state="translated">인쇄 할 출력 파일입니다. 특수 이름 &quot;-&quot;또는 &quot;&amp;gt; &amp;amp; 1&quot;또는 &quot;&amp;gt; &amp;amp; STDOUT&quot;이 사용되면 표준 출력이 사용됩니다. &quot;&amp;gt; &amp;amp; 2&quot;또는 &quot;&amp;gt; &amp;amp; STDERR&quot;을 사용하면 표준 오류가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="cf7f158841e06623182985de04b67d3455d986ee" translate="yes" xml:space="preserve">
          <source>The output files are placed in the hierarchy rooted at Perl's architecture dependent library directory. You can specify a different hierarchy with a &lt;b&gt;-d&lt;/b&gt; switch.</source>
          <target state="translated">출력 파일은 Perl의 아키텍처 종속 라이브러리 디렉토리를 기반으로하는 계층 구조에 배치됩니다. &lt;b&gt;-d&lt;/b&gt; 스위치를 사용하여 다른 계층을 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c27fbec04d459297ba3b8649872110c7c0d3d15a" translate="yes" xml:space="preserve">
          <source>The output format is governed by multiple options described under &lt;a href=&quot;#Configurable-Options&quot;&gt;&quot;Configurable Options&quot;&lt;/a&gt;.</source>
          <target state="translated">출력 형식은 &lt;a href=&quot;#Configurable-Options&quot;&gt;&quot;구성 가능한 옵션&quot;에&lt;/a&gt; 설명 된 여러 옵션에 의해 관리됩니다 .</target>
        </trans-unit>
        <trans-unit id="5d7376e07f79489cad7f31d1cda9c5ba04d798cb" translate="yes" xml:space="preserve">
          <source>The output format is governed by multiple options described under &lt;a href=&quot;#Configurable-Options&quot;&gt;Configurable Options&lt;/a&gt;.</source>
          <target state="translated">출력 형식은 &lt;a href=&quot;#Configurable-Options&quot;&gt;구성&lt;/a&gt; 가능한 옵션에 설명 된 여러 옵션이 적용됩니다 .</target>
        </trans-unit>
        <trans-unit id="99376109c851932f74197e279ea101a89b6befe6" translate="yes" xml:space="preserve">
          <source>The output format of a &lt;a href=&quot;functions/write&quot;&gt;write&lt;/a&gt; is determined by an earlier format declaration (&lt;a href=&quot;functions/format&quot;&gt;format&lt;/a&gt;), so whether or not the output is affected by locale is determined by if the &lt;code&gt;&lt;a href=&quot;functions/format&quot;&gt;format()&lt;/a&gt;&lt;/code&gt; is within the scope of a &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; , not whether the &lt;code&gt;&lt;a href=&quot;functions/write&quot;&gt;write()&lt;/a&gt;&lt;/code&gt; is.</source>
          <target state="translated">&lt;a href=&quot;functions/write&quot;&gt;쓰기&lt;/a&gt; 의 출력 형식은 이전 형식 선언 ( &lt;a href=&quot;functions/format&quot;&gt;format&lt;/a&gt; )에 의해 결정 되므로 출력이 로케일의 영향을 받는지 여부는 &lt;code&gt;&lt;a href=&quot;functions/write&quot;&gt;write()&lt;/a&gt;&lt;/code&gt; 여부가 아니라 &lt;code&gt;&lt;a href=&quot;functions/format&quot;&gt;format()&lt;/a&gt;&lt;/code&gt; 이 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; 범위 내에 있는지 여부에 따라 결정됩니다. 입니다.</target>
        </trans-unit>
        <trans-unit id="c1530099f7317e5e8334f8069b6bb6b27df102d4" translate="yes" xml:space="preserve">
          <source>The output format of a &lt;a href=&quot;perlfunc#write&quot;&gt;write()&lt;/a&gt; is determined by an earlier format declaration (&lt;a href=&quot;perlfunc#format&quot;&gt;&quot;format&quot; in perlfunc&lt;/a&gt;), so whether or not the output is affected by locale is determined by if the &lt;code&gt;format()&lt;/code&gt; is within the scope of a &lt;code&gt;use locale&lt;/code&gt;, not whether the &lt;code&gt;write()&lt;/code&gt; is.</source>
          <target state="translated">&lt;a href=&quot;perlfunc#write&quot;&gt;write ()&lt;/a&gt; 의 출력 형식은 이전 형식 선언 ( &lt;a href=&quot;perlfunc#format&quot;&gt;perlfunc의 &quot;format&quot;)에&lt;/a&gt; 의해 결정되므로 출력이 로케일의 영향을 받는지 여부는 &lt;code&gt;format()&lt;/code&gt; 이 &lt;code&gt;use locale&lt;/code&gt; 범위 내에 있는지 여부에 따라 결정 됩니다 . &lt;code&gt;write()&lt;/code&gt; 여부가 아닙니다 .</target>
        </trans-unit>
        <trans-unit id="821335e2d4cef7b064fd271a1052ad49bb811014" translate="yes" xml:space="preserve">
          <source>The output from an XSUB which uses something like the T_PTRREF map, which doesn't bless the object, might look something like this:</source>
          <target state="translated">객체를 축복하지 않는 T_PTRREF 맵과 같은 것을 사용하는 XSUB의 출력은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0f57dea9a1d29f634f6f112b3d23937584062d88" translate="yes" xml:space="preserve">
          <source>The output from that will be</source>
          <target state="translated">그 결과는</target>
        </trans-unit>
        <trans-unit id="489ef92ce8f286ef5d6d82e8d178af124ae1bd61" translate="yes" xml:space="preserve">
          <source>The output is untainted. If you don't know what tainting is, don't worry about it.</source>
          <target state="translated">출력이 오염되지 않았습니다. 오염이 무엇인지 모른다면 걱정하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="74b4c8cfc7182db2977001aba6ce4cd0c9c3eff4" translate="yes" xml:space="preserve">
          <source>The output line can be used as a template in a &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; call:</source>
          <target state="translated">출력 라인은 &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; 호출 에서 템플릿으로 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ff265796f887227add453069160ce81043ae2ad9" translate="yes" xml:space="preserve">
          <source>The output line can be used as a template in a &lt;code&gt;pack&lt;/code&gt; or &lt;code&gt;unpack&lt;/code&gt; call:</source>
          <target state="translated">출력 라인은 &lt;code&gt;pack&lt;/code&gt; 또는 &lt;code&gt;unpack&lt;/code&gt; 호출 에서 템플릿으로 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="628776c99f7feeea9f3047213f9a74832f55bae9" translate="yes" xml:space="preserve">
          <source>The output of &lt;code&gt;uname -a&lt;/code&gt; if available, otherwise the hostname. The whole thing is then lower-cased and slashes and single quotes are removed.</source>
          <target state="translated">사용 가능한 경우 &lt;code&gt;uname -a&lt;/code&gt; 의 출력 , 그렇지 않은 경우 호스트 이름 그런 다음 모든 것이 소문자이며 슬래시와 작은 따옴표가 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="b50cc56cf670c43f6be20602b16c39970c70b1a0" translate="yes" xml:space="preserve">
          <source>The output record separator for the print operator. If defined, this value is printed after the last of print's arguments. Default is &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">인쇄 연산자의 출력 레코드 구분 기호입니다. 정의 된 경우이 값은 마지막 인쇄 인수 이후에 인쇄됩니다. 기본값은 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="bed1b55192d15d86c0d4204e8c0dbb14dedd4354" translate="yes" xml:space="preserve">
          <source>The output record separator for the print operator. If defined, this value is printed after the last of print's arguments. Default is &lt;code&gt;undef&lt;/code&gt;.</source>
          <target state="translated">인쇄 연산자의 출력 레코드 구분 기호입니다. 정의 된 경우이 값은 마지막 인쇄 인수 뒤에 인쇄됩니다. 기본값은 &lt;code&gt;undef&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="8366e38dbe1255a05a31be8b8ca8cff24bae31ce" translate="yes" xml:space="preserve">
          <source>The output shows all of the groups. The outermost matches show up first and the nested matches show up later:</source>
          <target state="translated">출력은 모든 그룹을 보여줍니다. 가장 바깥 쪽 일치 항목이 먼저 표시되고 중첩 된 일치 항목이 나중에 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="61a2ac718a159127bd64e67ec39c4e8e007d9514" translate="yes" xml:space="preserve">
          <source>The output shows that Perl found the two major groups:</source>
          <target state="translated">결과는 Perl이 두 가지 주요 그룹을 찾았 음을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="eb272330b66e99a860c17d412be21e54b237263f" translate="yes" xml:space="preserve">
          <source>The output shows that while in the &lt;code&gt;OUTER&lt;/code&gt; block, the values of &lt;code&gt;$1&lt;/code&gt; and &lt;code&gt;$2&lt;/code&gt; are from the match against &lt;code&gt;$outer&lt;/code&gt; . Inside the &lt;code&gt;INNER&lt;/code&gt; block, the values of &lt;code&gt;$1&lt;/code&gt; and &lt;code&gt;$2&lt;/code&gt; are from the match against &lt;code&gt;$inner&lt;/code&gt; , but only until the end of the block (i.e. the dynamic scope). After the &lt;code&gt;INNER&lt;/code&gt; block completes, the values of &lt;code&gt;$1&lt;/code&gt; and &lt;code&gt;$2&lt;/code&gt; return to the values for the match against &lt;code&gt;$outer&lt;/code&gt; even though we have not made another match:</source>
          <target state="translated">&lt;code&gt;OUTER&lt;/code&gt; 블록에서 &lt;code&gt;$1&lt;/code&gt; 및 &lt;code&gt;$2&lt;/code&gt; 값이 &lt;code&gt;$outer&lt;/code&gt; 와 일치 하는 결과가 출력에 표시 됩니다. &lt;code&gt;INNER&lt;/code&gt; 블록 내에서 &lt;code&gt;$1&lt;/code&gt; 과 &lt;code&gt;$2&lt;/code&gt; 의 값은 $ &lt;code&gt;$inner&lt;/code&gt; 와의 일치에서 블록의 끝까지 (예 : 동적 범위)까지입니다. &lt;code&gt;INNER&lt;/code&gt; 블록이 완료된 후 &lt;code&gt;$1&lt;/code&gt; 및 &lt;code&gt;$2&lt;/code&gt; 값 은 다른 일치 항목을 만들지 않았더라도 &lt;code&gt;$outer&lt;/code&gt; 와 일치하는 값으로 돌아갑니다 .</target>
        </trans-unit>
        <trans-unit id="3aeb115218152011de3493e1c2fea22949664e64" translate="yes" xml:space="preserve">
          <source>The output shows that while in the &lt;code&gt;OUTER&lt;/code&gt; block, the values of &lt;code&gt;$1&lt;/code&gt; and &lt;code&gt;$2&lt;/code&gt; are from the match against &lt;code&gt;$outer&lt;/code&gt;. Inside the &lt;code&gt;INNER&lt;/code&gt; block, the values of &lt;code&gt;$1&lt;/code&gt; and &lt;code&gt;$2&lt;/code&gt; are from the match against &lt;code&gt;$inner&lt;/code&gt;, but only until the end of the block (i.e. the dynamic scope). After the &lt;code&gt;INNER&lt;/code&gt; block completes, the values of &lt;code&gt;$1&lt;/code&gt; and &lt;code&gt;$2&lt;/code&gt; return to the values for the match against &lt;code&gt;$outer&lt;/code&gt; even though we have not made another match:</source>
          <target state="translated">출력은 &lt;code&gt;OUTER&lt;/code&gt; 블록 에있는 동안 &lt;code&gt;$1&lt;/code&gt; 및 &lt;code&gt;$2&lt;/code&gt; 의 값이 &lt;code&gt;$outer&lt;/code&gt; 에 대한 일치에서 나온 것임을 보여줍니다 . &lt;code&gt;INNER&lt;/code&gt; 블록 내에서 &lt;code&gt;$1&lt;/code&gt; 및 &lt;code&gt;$2&lt;/code&gt; 의 값은 $ &lt;code&gt;$inner&lt;/code&gt; 에 대한 일치 항목 이지만 블록이 끝날 때까지만 해당됩니다 (즉, 동적 범위). &lt;code&gt;INNER&lt;/code&gt; 블록이 완료된 후 &lt;code&gt;$1&lt;/code&gt; 및 &lt;code&gt;$2&lt;/code&gt; 의 값 은 다른 일치 항목을 만들지 않았더라도 &lt;code&gt;$outer&lt;/code&gt; 에 대한 일치 값으로 반환됩니다 .</target>
        </trans-unit>
        <trans-unit id="43b62e463d3539b36d5bc54872fb60071ea829c7" translate="yes" xml:space="preserve">
          <source>The output shows the constant() subroutine we're testing being replaced with the value of the &lt;code&gt;DEBUG&lt;/code&gt; constant: zero. The line to be tested has been completely optimized away, and you can't get much more efficient than that.</source>
          <target state="translated">출력은 테스트중인 constant () 서브 루틴을 &lt;code&gt;DEBUG&lt;/code&gt; 상수 값 0으로 바꿉니다 . 테스트 할 라인은 완전히 최적화되었으며 그보다 훨씬 더 효율적일 수는 없습니다.</target>
        </trans-unit>
        <trans-unit id="223632d9e65a77def5c7f3d1e26472458213d8c9" translate="yes" xml:space="preserve">
          <source>The output string will be returned.</source>
          <target state="translated">출력 문자열이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="5b1aa869d1f21ede1a6455013df56f91d9ec5d9c" translate="yes" xml:space="preserve">
          <source>The output strings for &lt;b&gt;Tputs&lt;/b&gt; are cached for counts of 1 for performance. &lt;b&gt;Tgoto&lt;/b&gt; and &lt;b&gt;Tpad&lt;/b&gt; do not cache. &lt;code&gt;$self-&amp;gt;{_xx}&lt;/code&gt; is the raw termcap data and &lt;code&gt;$self-&amp;gt;{xx}&lt;/code&gt; is the cached version.</source>
          <target state="translated">에 대한 출력 문자열 &lt;b&gt;Tputs&lt;/b&gt; 은 성능을 위해 1 카운트로 캐시됩니다. &lt;b&gt;Tgoto&lt;/b&gt; 와 &lt;b&gt;Tpad&lt;/b&gt; 는 캐시하지 않습니다. &lt;code&gt;$self-&amp;gt;{_xx}&lt;/code&gt; 는 원시 termcap 데이터이고 &lt;code&gt;$self-&amp;gt;{xx}&lt;/code&gt; 는 캐시 된 버전입니다.</target>
        </trans-unit>
        <trans-unit id="5e7202107b643ac3d564aacb4d094eef76b947a2" translate="yes" xml:space="preserve">
          <source>The output value, with its sign, must either be a positive value in the range 1,2,...,OBJ2-1 or the same value subtracted OBJ2. For instance, if the input arguments are objects representing the numbers 7 and 5, the method must either return an object representing the number 3 and a &quot;+&quot; sign, since (3*7) % 5 = 1 % 5, or an object representing the number 2 and &quot;-&quot; sign, since (-2*7) % 5 = 1 % 5.</source>
          <target state="translated">부호가있는 출력 값은 1,2, ..., OBJ2-1 범위의 양수 값이거나 OBJ2를 뺀 동일한 값이어야합니다. 예를 들어 입력 인수가 숫자 7과 5를 나타내는 객체 인 경우이 메서드는 (3 * 7) % 5 = 1 % 5이므로 숫자 3과 &quot;+&quot;부호를 나타내는 객체 또는 객체를 반환해야합니다. (-2 * 7) % 5 = 1 % 5이므로 숫자 2와 &quot;-&quot;부호를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="3b69a10a3a50934e50dc62235290b18744d8011f" translate="yes" xml:space="preserve">
          <source>The output value, with its sign, must either be a positive value in the range 1,2,...,OBJ2-1 or the same value subtracted OBJ2. For instance, if the input arguments are objects representing the numbers 7 and 5, the method must either return an object representing the number 3 and a &quot;+&quot; sign, since (3*7) % 5 = 1 % 5, or an object representing the number 2 and a &quot;-&quot; sign, since (-2*7) % 5 = 1 % 5.</source>
          <target state="translated">부호가있는 출력 값은 1,2, ..., OBJ2-1 범위의 양수 값이거나 OBJ2를 뺀 동일한 값이어야합니다. 예를 들어 입력 인수가 숫자 7과 5를 나타내는 객체 인 경우 메서드는 (3 * 7) % 5 = 1 % 5이기 때문에 숫자 3과 &quot;+&quot;기호를 나타내는 객체를 반환하거나 객체를 반환해야합니다. (-2 * 7) % 5 = 1 % 5이므로 숫자 2와 &quot;-&quot;기호를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="1eef73c78f4ba8f7baa5a469f4fff0d89cabb26a" translate="yes" xml:space="preserve">
          <source>The output you'll get when the script is executed:</source>
          <target state="translated">스크립트가 실행될 때 얻을 수있는 출력 :</target>
        </trans-unit>
        <trans-unit id="df416751e8a2d229d8b98d6297b404967b69b568" translate="yes" xml:space="preserve">
          <source>The output:</source>
          <target state="translated">출력 :</target>
        </trans-unit>
        <trans-unit id="0dc65b45e14d95f10af2c76613db8f6869035f53" translate="yes" xml:space="preserve">
          <source>The overall, or wallclock, time between when &lt;code&gt;&lt;a href=&quot;functions/time&quot;&gt;time&lt;/a&gt;&lt;/code&gt; was called, and when it terminates. The elapsed time includes both user and system times, and time spent waiting for other users and processes on the system. Inevitably, this is the most approximate of the measurements given.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/time&quot;&gt;time&lt;/a&gt;&lt;/code&gt; 이 호출 된 시점 과 종료 된 시점 사이의 전체 또는 벽시계 시간 . 경과 시간에는 사용자 및 시스템 시간과 시스템의 다른 사용자 및 프로세스를 기다리는 데 소요 된 시간이 포함됩니다. 필연적으로 이것은 주어진 측정치 중 가장 근사한 수치입니다.</target>
        </trans-unit>
        <trans-unit id="9571b6fa38431ae0c0fee13dd1186fe4dbf0046f" translate="yes" xml:space="preserve">
          <source>The overall, or wallclock, time between when &lt;code&gt;time&lt;/code&gt; was called, and when it terminates. The elapsed time includes both user and system times, and time spent waiting for other users and processes on the system. Inevitably, this is the most approximate of the measurements given.</source>
          <target state="translated">&lt;code&gt;time&lt;/code&gt; 이 호출 된 시점 과 종료 시점 사이의 전체 또는 wallclock 시간 입니다. 경과 시간에는 사용자 및 시스템 시간과 시스템에서 다른 사용자 및 프로세스를 기다리는 데 소요 된 시간이 포함됩니다. 필연적으로 이것은 주어진 측정 중 가장 근사치입니다.</target>
        </trans-unit>
        <trans-unit id="5407cf16873f519751b5a5a5e241e60dd7a6b88b" translate="yes" xml:space="preserve">
          <source>The pTHX_ symbol in the definition is a macro used by Perl under threading to provide an extra argument to the routine holding a pointer back to the interpreter that is executing the regexp. So under threading all routines get an extra argument.</source>
          <target state="translated">정의의 pTHX_ 기호는 스레딩에서 Perl이 정규 표현식을 실행하는 인터프리터에 대한 포인터를 다시 유지하는 추가 인수를 제공하기 위해 사용하는 매크로입니다. 따라서 스레딩에서 모든 루틴은 추가 인수를 얻습니다.</target>
        </trans-unit>
        <trans-unit id="f3fe23968698971d8ab162ac70a7f7b71df42802" translate="yes" xml:space="preserve">
          <source>The pack code &lt;code&gt;A*&lt;/code&gt; gobbles up all remaining bytes, and &lt;code&gt;$prio&lt;/code&gt; remains undefined! Before we let disappointment dampen the morale: Perl's got the trump card to make this trick too, just a little further up the sleeve. Watch this:</source>
          <target state="translated">팩 코드 &lt;code&gt;A*&lt;/code&gt; 남아있는 모든 바이트를 모으고 &lt;code&gt;$prio&lt;/code&gt; 는 정의되지 않은 상태로 유지됩니다! 실망이 사기를 약화시키기 전에 : Perl은이 트릭을 만들기 위해 트럼프 카드를 얻었습니다. 이것을보세요:</target>
        </trans-unit>
        <trans-unit id="7933b3c7848d20de1a22817261c68e6d7c53c8c0" translate="yes" xml:space="preserve">
          <source>The pack code &lt;code&gt;w&lt;/code&gt; has been added to support a portable binary data encoding scheme that goes way beyond simple integers. (Details can be found at &lt;a href=&quot;http://Casbah.org/&quot;&gt;http://Casbah.org/&lt;/a&gt;, the Scarab project.) A BER (Binary Encoded Representation) compressed unsigned integer stores base 128 digits, most significant digit first, with as few digits as possible. Bit eight (the high bit) is set on each byte except the last. There is no size limit to BER encoding, but Perl won't go to extremes.</source>
          <target state="translated">팩 코드 &lt;code&gt;w&lt;/code&gt; 는 단순한 정수 이상의 휴대용 이진 데이터 인코딩 체계를 지원하기 위해 추가되었습니다. (자세한 내용은 &lt;a href=&quot;http://Casbah.org/&quot;&gt;http://Casbah.org/&lt;/a&gt; , Scarab 프로젝트 에서 확인할 수 있습니다 .) BER (Binary Encoded Representation) 압축 부호없는 정수는 가능한 한 적은 수의 숫자로 기본 128 자리 (가장 중요한 자리)를 저장합니다. 비트 8 (상위 비트)은 마지막 바이트를 제외한 각 바이트에 설정됩니다. BER 인코딩에는 크기 제한이 없지만 Perl은 극단적으로 진행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b79ab5606b336d2e61cfa7238de19673ec485cc8" translate="yes" xml:space="preserve">
          <source>The pack code &lt;code&gt;w&lt;/code&gt; has been added to support a portable binary data encoding scheme that goes way beyond simple integers. (Details can be found at &lt;a href=&quot;https://github.com/mworks-project/mw_scarab/blob/master/Scarab-0.1.00d19/doc/binary-serialization.txt&quot;&gt;https://github.com/mworks-project/mw_scarab/blob/master/Scarab-0.1.00d19/doc/binary-serialization.txt&lt;/a&gt;, the Scarab project.) A BER (Binary Encoded Representation) compressed unsigned integer stores base 128 digits, most significant digit first, with as few digits as possible. Bit eight (the high bit) is set on each byte except the last. There is no size limit to BER encoding, but Perl won't go to extremes.</source>
          <target state="translated">팩 코드 &lt;code&gt;w&lt;/code&gt; 는 단순한 정수를 넘어서는 휴대용 바이너리 데이터 인코딩 체계를 지원하기 위해 추가되었습니다. (자세한 내용은 &lt;a href=&quot;https://github.com/mworks-project/mw_scarab/blob/master/Scarab-0.1.00d19/doc/binary-serialization.txt&quot;&gt;https://github.com/mworks-project/mw_scarab/blob/master/Scarab-0.1.00d19/doc/binary-serialization.txt&lt;/a&gt; , Scarab 프로젝트 에서 확인할 수 있습니다 .) A BER (Binary Encoded Representation) 압축 된 부호없는 정수는 가능한 한 적은 숫자로 기본 128 자리 숫자, 최상위 숫자를 먼저 저장합니다. 마지막을 제외한 각 바이트에 비트 8 (상위 비트)이 설정됩니다. BER 인코딩에는 크기 제한이 없지만 Perl은 극단적으로 가지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1cf9569df81623b7e7940e6c5aeacc511770e43a" translate="yes" xml:space="preserve">
          <source>The pack code for big-endian (high order byte at the lowest address) is &lt;code&gt;n&lt;/code&gt; for 16 bit and &lt;code&gt;N&lt;/code&gt; for 32 bit integers. You use these codes if you know that your data comes from a compliant architecture, but, surprisingly enough, you should also use these pack codes if you exchange binary data, across the network, with some system that you know next to nothing about. The simple reason is that this order has been chosen as the</source>
          <target state="translated">빅 엔디안 (가장 낮은 주소의 상위 바이트)에 대한 팩 코드는 &lt;code&gt;n&lt;/code&gt; 입니다. 16 비트의 경우 이고 32 비트 정수의 경우 &lt;code&gt;N&lt;/code&gt; 입니다. 데이터가 호환 아키텍처에서 나온다는 것을 알고 있으면이 코드를 사용하지만 놀랍게도 네트워크를 통해 이진 데이터를 전혀 모르는 시스템과 교환 할 경우이 팩 코드를 사용해야합니다. 간단한 이유는이 주문이</target>
        </trans-unit>
        <trans-unit id="57fad0d4b36d335f1fb095e9863848e373754e9c" translate="yes" xml:space="preserve">
          <source>The pack code preceding &lt;code&gt;/&lt;/code&gt; may be anything that's fit to represent a number: All the numeric binary pack codes, and even text codes such as &lt;code&gt;A4&lt;/code&gt; or &lt;code&gt;Z*&lt;/code&gt; :</source>
          <target state="translated">위의 팩 코드 &lt;code&gt;/&lt;/code&gt; 모든 숫자 이진 팩 코드 및 같은 심지어 텍스트 코드 :의 숫자를 표현하기 위해 맞는 것이있을 수 있습니다 아무것도 &lt;code&gt;A4&lt;/code&gt; 또는 &lt;code&gt;Z*&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="65094bdd21f0a1919cd6838b37b6c0d3bbee3405" translate="yes" xml:space="preserve">
          <source>The pack code preceding &lt;code&gt;/&lt;/code&gt; may be anything that's fit to represent a number: All the numeric binary pack codes, and even text codes such as &lt;code&gt;A4&lt;/code&gt; or &lt;code&gt;Z*&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;/&lt;/code&gt; 앞의 팩 코드 는 숫자를 나타내는 데 적합한 모든 것이 될 수 있습니다. 모든 숫자 이진 팩 코드, 심지어 &lt;code&gt;A4&lt;/code&gt; 또는 &lt;code&gt;Z*&lt;/code&gt; 와 같은 텍스트 코드 :</target>
        </trans-unit>
        <trans-unit id="7172e02890f0d23e60cb06f72d229c969bc3f33e" translate="yes" xml:space="preserve">
          <source>The pack format &lt;code&gt;A&lt;/code&gt; means &quot;any character&quot;; if you're &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt;ing and you've run out of things to pack, &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; will fill the rest up with spaces.</source>
          <target state="translated">팩 형식 &lt;code&gt;A&lt;/code&gt; 는 &quot;모든 문자&quot;를 의미합니다. &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; 하고 포장 할 물건이 부족한 경우 &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; 공백으로 나머지 부분을 채울 것입니다.</target>
        </trans-unit>
        <trans-unit id="44495eb674e0583287f2264fa02ffed62c8c4074" translate="yes" xml:space="preserve">
          <source>The pack format &lt;code&gt;A&lt;/code&gt; means &quot;any character&quot;; if you're &lt;code&gt;pack&lt;/code&gt;ing and you've run out of things to pack, &lt;code&gt;pack&lt;/code&gt; will fill the rest up with spaces.</source>
          <target state="translated">팩 형식 &lt;code&gt;A&lt;/code&gt; 는 &quot;모든 문자&quot;를 의미합니다. 당신이 경우 &lt;code&gt;pack&lt;/code&gt; ING하고 포장하는 일이 부족했습니다 &lt;code&gt;pack&lt;/code&gt; 공백으로 나머지 부분을 채울 것입니다.</target>
        </trans-unit>
        <trans-unit id="9582d05d51afa98d043db268f238bb511bec0a17" translate="yes" xml:space="preserve">
          <source>The package contains a session manager and a cache manager. The session manager keeps track of what has been fetched, built, and installed in the current session. The cache manager keeps track of the disk space occupied by the make processes and deletes excess space using a simple FIFO mechanism.</source>
          <target state="translated">패키지에는 세션 관리자와 캐시 관리자가 포함되어 있습니다. 세션 관리자는 현재 세션에서 페치, 빌드 및 설치된 것을 추적합니다. 캐시 관리자는 make 프로세스가 차지하는 디스크 공간을 추적하고 간단한 FIFO 메커니즘을 사용하여 초과 공간을 삭제합니다.</target>
        </trans-unit>
        <trans-unit id="f2c3c65c0d45b6b1fe4dfd7fdaf1376fd647a40b" translate="yes" xml:space="preserve">
          <source>The package from which the exceptional subroutine was called.</source>
          <target state="translated">예외적 인 서브 루틴이 호출 된 패키지입니다.</target>
        </trans-unit>
        <trans-unit id="fdc4d85fb172b2eb58f10fb1bda38f21c477922a" translate="yes" xml:space="preserve">
          <source>The package name argument will typically be the name of the class into which the subroutine was declared, but it may also be the name of a derived class (since handlers are inherited).</source>
          <target state="translated">패키지 이름 인수는 일반적으로 서브 루틴이 선언 된 클래스의 이름이지만 핸들러가 상속되므로 파생 클래스의 이름 일 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="91efffdbf8c7db0b4f5430206e2d6e6cd3563e8f" translate="yes" xml:space="preserve">
          <source>The package name uses the &lt;code&gt;DBM_Filter::&lt;/code&gt; prefix.</source>
          <target state="translated">패키지 이름은 &lt;code&gt;DBM_Filter::&lt;/code&gt; 두부를 .</target>
        </trans-unit>
        <trans-unit id="61ad7bd19c49da733338e6250d6950f088f8b981" translate="yes" xml:space="preserve">
          <source>The package representing the distribution. For example, &lt;code&gt;Test::More&lt;/code&gt; or &lt;code&gt;ExtUtils::MakeMaker&lt;/code&gt; . It will be used to derive information about the distribution such as the &lt;a href=&quot;#DISTNAME&quot;&gt;DISTNAME&lt;/a&gt;, installation locations within the Perl library and where XS files will be looked for by default (see &lt;a href=&quot;#XS&quot;&gt;XS&lt;/a&gt;).</source>
          <target state="translated">분포를 나타내는 패키지입니다. 예를 들어 &lt;code&gt;Test::More&lt;/code&gt; 또는 &lt;code&gt;ExtUtils::MakeMaker&lt;/code&gt; 입니다. &lt;a href=&quot;#DISTNAME&quot;&gt;DISTNAME&lt;/a&gt; , Perl 라이브러리 내의 설치 위치 및 기본적으로 XS 파일을 찾는 위치 와 같은 배포에 대한 정보를 도출하는 데 사용됩니다 (참조&lt;a href=&quot;#XS&quot;&gt; XS를&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="cf847620b5ea5a28241ef80f16dce588c1976c67" translate="yes" xml:space="preserve">
          <source>The package representing the distribution. For example, &lt;code&gt;Test::More&lt;/code&gt; or &lt;code&gt;ExtUtils::MakeMaker&lt;/code&gt;. It will be used to derive information about the distribution such as the &lt;a href=&quot;#DISTNAME&quot;&gt;&quot;DISTNAME&quot;&lt;/a&gt;, installation locations within the Perl library and where XS files will be looked for by default (see &lt;a href=&quot;#XS&quot;&gt;&quot;XS&quot;&lt;/a&gt;).</source>
          <target state="translated">배포를 나타내는 패키지입니다. 예를 들어 &lt;code&gt;Test::More&lt;/code&gt; 또는 &lt;code&gt;ExtUtils::MakeMaker&lt;/code&gt; 입니다. &lt;a href=&quot;#DISTNAME&quot;&gt;&quot;DISTNAME&quot;&lt;/a&gt; , Perl 라이브러리 내의 설치 위치 및 기본적으로 XS 파일이 검색되는 위치 ( &lt;a href=&quot;#XS&quot;&gt;&quot;XS&quot;&lt;/a&gt; 참조) 와 같은 배포에 대한 정보를 가져 오는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="4576d414ced67927c5747f7cd9e683dea9105380" translate="yes" xml:space="preserve">
          <source>The package the qr// magic object is blessed into (as seen by &lt;code&gt;&lt;a href=&quot;functions/ref&quot;&gt;ref&lt;/a&gt;
qr//&lt;/code&gt; ). It is recommended that engines change this to their package name for identification regardless of if they implement methods on the object.</source>
          <target state="translated">qr // magic 객체가 축복받은 패키지 &lt;code&gt;&lt;a href=&quot;functions/ref&quot;&gt;ref&lt;/a&gt; qr//&lt;/code&gt; ) 엔진은 객체에 메소드를 구현하는지 여부에 관계없이 식별을 위해 패키지 이름으로이를 변경하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="3eb8be4161caf31aed9851aac09981f2dc091cb7" translate="yes" xml:space="preserve">
          <source>The package the qr// magic object is blessed into (as seen by &lt;code&gt;ref qr//&lt;/code&gt;). It is recommended that engines change this to their package name for identification regardless of if they implement methods on the object.</source>
          <target state="translated">qr // 매직 객체가 축복 된 패키지 ( &lt;code&gt;ref qr//&lt;/code&gt; 볼 수 있음 ). 엔진은 개체에 메서드를 구현하는지 여부에 관계없이 식별을 위해이를 패키지 이름으로 변경하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="73079d10e9cd577552c5b87cfb22afa1b7851691" translate="yes" xml:space="preserve">
          <source>The package this method returns should also have the internal &lt;code&gt;Regexp&lt;/code&gt; package in its &lt;code&gt;@ISA&lt;/code&gt; . &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//-&amp;gt;isa(&quot;Regexp&quot;)&lt;/a&gt;&lt;/code&gt; should always be true regardless of what engine is being used.</source>
          <target state="translated">이 메소드가 리턴하는 패키지는 또한 &lt;code&gt;@ISA&lt;/code&gt; 에 내부 &lt;code&gt;Regexp&lt;/code&gt; 패키지를 가져야합니다. . &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//-&amp;gt;isa(&quot;Regexp&quot;)&lt;/a&gt;&lt;/code&gt; 는 사용중인 엔진에 관계없이 항상 참이어야합니다.</target>
        </trans-unit>
        <trans-unit id="890f0468ce1dfbaa3a848480f6a3e9f003f8a19f" translate="yes" xml:space="preserve">
          <source>The package this method returns should also have the internal &lt;code&gt;Regexp&lt;/code&gt; package in its &lt;code&gt;@ISA&lt;/code&gt;. &lt;code&gt;qr//-&amp;gt;isa(&quot;Regexp&quot;)&lt;/code&gt; should always be true regardless of what engine is being used.</source>
          <target state="translated">이 메서드가 반환하는 패키지에는 &lt;code&gt;@ISA&lt;/code&gt; 에 내부 &lt;code&gt;Regexp&lt;/code&gt; 패키지 도 있어야합니다 . &lt;code&gt;qr//-&amp;gt;isa(&quot;Regexp&quot;)&lt;/code&gt; 는 사용중인 엔진에 관계없이 항상 true 여야합니다.</target>
        </trans-unit>
        <trans-unit id="7b32ac926fcc794f5f7982e502e4686af4c595bf" translate="yes" xml:space="preserve">
          <source>The package variable &lt;code&gt;@EXPORT&lt;/code&gt; will determine which symbols will get exported when the caller simply says &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; Net::Acme&lt;/code&gt; - you will hardly ever want to put anything in there. &lt;code&gt;@EXPORT_OK&lt;/code&gt; , on the other hand, specifies which symbols you're willing to export. If you do want to export a bunch of symbols, use the &lt;code&gt;%EXPORT_TAGS&lt;/code&gt; and define a standard export set - look at &lt;a href=&quot;exporter&quot;&gt;Exporter&lt;/a&gt; for more details.</source>
          <target state="translated">&lt;code&gt;@EXPORT&lt;/code&gt; 패키지 변수 는 호출자가 단순히 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; Net::Acme&lt;/code&gt; &lt;a href=&quot;functions/use&quot;&gt;사용&lt;/a&gt; 한다고 말할 때 어떤 심볼을 내보낼 지 결정 합니다. &lt;code&gt;@EXPORT_OK&lt;/code&gt; 는 내보낼 심볼을 지정합니다. 여러 개의 심볼을 내보내려면 &lt;code&gt;%EXPORT_TAGS&lt;/code&gt; 사용하십시오. 를 사용하고 표준 내보내기 세트를 정의 하십시오. 자세한 내용 은 &lt;a href=&quot;exporter&quot;&gt;내보내기&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="9d8ef2409327fe0b3b34e7e40584004dedfbd9fc" translate="yes" xml:space="preserve">
          <source>The package variable &lt;code&gt;@EXPORT&lt;/code&gt; will determine which symbols will get exported when the caller simply says &lt;code&gt;use Net::Acme&lt;/code&gt; - you will hardly ever want to put anything in there. &lt;code&gt;@EXPORT_OK&lt;/code&gt;, on the other hand, specifies which symbols you're willing to export. If you do want to export a bunch of symbols, use the &lt;code&gt;%EXPORT_TAGS&lt;/code&gt; and define a standard export set - look at &lt;a href=&quot;exporter&quot;&gt;Exporter&lt;/a&gt; for more details.</source>
          <target state="translated">패키지 변수 &lt;code&gt;@EXPORT&lt;/code&gt; 는 호출자가 단순히 &lt;code&gt;use Net::Acme&lt;/code&gt; 한다고 말할 때 내보낼 심볼을 결정 합니다. &lt;code&gt;@EXPORT_OK&lt;/code&gt; 는 내보낼 기호를 지정합니다. 여러 기호를 내보내려면 &lt;code&gt;%EXPORT_TAGS&lt;/code&gt; 를 사용하고 표준 내보내기 세트를 정의 하십시오. 자세한 내용 은 &lt;a href=&quot;exporter&quot;&gt;내보내기&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="650111e5202c538679780ce9ea893a905f97b0fc" translate="yes" xml:space="preserve">
          <source>The packages relating to various DBM-related implementations (</source>
          <target state="translated">다양한 DBM 관련 구현과 관련된 패키지 (</target>
        </trans-unit>
        <trans-unit id="02ef2277604c9b31476ae26defa7602571798335" translate="yes" xml:space="preserve">
          <source>The pad names in the PADNAMELIST have their PV holding the name of the variable. The &lt;code&gt;COP_SEQ_RANGE_LOW&lt;/code&gt; and &lt;code&gt;_HIGH&lt;/code&gt; fields form a range (low+1..high inclusive) of cop_seq numbers for which the name is valid. During compilation, these fields may hold the special value PERL_PADSEQ_INTRO to indicate various stages:</source>
          <target state="translated">PADNAMELIST의 패드 이름에는 변수 이름이 포함 된 PV가 있습니다. &lt;code&gt;COP_SEQ_RANGE_LOW&lt;/code&gt; 및 &lt;code&gt;_HIGH&lt;/code&gt; 필드 이름가 유효한 cop_seq 번호의 범위 (낮은 + 1..high 포함)을 형성한다. 컴파일 중에 이러한 필드는 다양한 단계를 나타 내기 위해 특수 값 PERL_PADSEQ_INTRO를 보유 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c94813a5310ff08ec4ccbc37cd40783e0084e83e" translate="yes" xml:space="preserve">
          <source>The pad names in the PADNAMELIST have their PV holding the name of the variable. The COP_SEQ_RANGE_LOW and _HIGH fields form a range (low+1..high inclusive) of cop_seq numbers for which the name is valid. During compilation, these fields may hold the special value PERL_PADSEQ_INTRO to indicate various stages:</source>
          <target state="translated">PADNAMELIST의 패드 이름에는 변수 이름을 보유한 PV가 있습니다. COP_SEQ_RANGE_LOW 및 _HIGH 필드는 이름이 유효한 cop_seq 숫자의 범위 (낮은 +1 .. 포함)를 형성합니다. 컴파일 중에이 필드는 다양한 단계를 표시하기 위해 특수 값 PERL_PADSEQ_INTRO를 보유 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ad69ddb72e9f5b5565c26efc4eeac2130e2ed028" translate="yes" xml:space="preserve">
          <source>The padded $string is returned.</source>
          <target state="translated">채워진 $ string이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="d3a360c727f09061a32c58fb443bedffc200fc64" translate="yes" xml:space="preserve">
          <source>The paper &quot;How to Break MD5 and Other Hash Functions&quot; by Xiaoyun Wang and Hongbo Yu.</source>
          <target state="translated">Xiaoyun Wang과 Hongbo Yu의 논문 &quot;MD5 및 기타 해시 함수를 깨는 방법&quot;.</target>
        </trans-unit>
        <trans-unit id="9446a617fdf40553874ee589e7fc235690a0bb87" translate="yes" xml:space="preserve">
          <source>The paragraphs you give to &lt;a href=&quot;Text::Wrap&quot;&gt;Text::Wrap&lt;/a&gt; should not contain embedded newlines. &lt;a href=&quot;Text::Wrap&quot;&gt;Text::Wrap&lt;/a&gt; doesn't justify the lines (flush-right).</source>
          <target state="translated">&lt;a href=&quot;Text::Wrap&quot;&gt;Text :: Wrap에&lt;/a&gt; 제공하는 단락에는 줄 바꿈 이 포함되어서는 안됩니다. &lt;a href=&quot;Text::Wrap&quot;&gt;Text :: Wrap&lt;/a&gt; 은 줄을 정당화하지 않습니다 (오른쪽 플러시).</target>
        </trans-unit>
        <trans-unit id="6bcc7e86c6ab48d9801f437d7ce277bb0ef436bb" translate="yes" xml:space="preserve">
          <source>The paragraphs you give to &lt;a href=&quot;text/wrap&quot;&gt;Text::Wrap&lt;/a&gt; should not contain embedded newlines. &lt;a href=&quot;text/wrap&quot;&gt;Text::Wrap&lt;/a&gt; doesn't justify the lines (flush-right).</source>
          <target state="translated">&lt;a href=&quot;text/wrap&quot;&gt;Text :: Wrap에&lt;/a&gt; 제공하는 단락에는 줄 바꿈 문자가 포함되어서는 안됩니다. &lt;a href=&quot;text/wrap&quot;&gt;Text :: Wrap&lt;/a&gt; 은 행을 정당화하지 않습니다 (오른쪽 플러시).</target>
        </trans-unit>
        <trans-unit id="0d3c20158693e8f7ad6ce14151f5e71a493b3128" translate="yes" xml:space="preserve">
          <source>The parameter &lt;code&gt;$output_filename_or_reference&lt;/code&gt; is used to control the destination of the compressed data. This parameter can take one of these forms.</source>
          <target state="translated">&lt;code&gt;$output_filename_or_reference&lt;/code&gt; 매개 변수 는 압축 된 데이터의 대상을 제어하는 ​​데 사용됩니다. 이 매개 변수는 다음 양식 중 하나를 취할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2a2ee58982c19a9868c4499e7bd1b9d1531f2904" translate="yes" xml:space="preserve">
          <source>The parameter &lt;code&gt;$output_filename_or_reference&lt;/code&gt; is used to control the destination of the uncompressed data. This parameter can take one of these forms.</source>
          <target state="translated">&lt;code&gt;$output_filename_or_reference&lt;/code&gt; 매개 변수 는 압축되지 않은 데이터의 대상을 제어하는 ​​데 사용됩니다. 이 매개 변수는 다음 양식 중 하나를 취할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4380851c25da81befd83447bad55f6f9f369b966" translate="yes" xml:space="preserve">
          <source>The parameter &lt;code&gt;$text&lt;/code&gt; is a string or block of text to be parsed for interior sequences; and the parameter &lt;code&gt;$line_num&lt;/code&gt; is the line number corresponding to the beginning of &lt;code&gt;$text&lt;/code&gt; .</source>
          <target state="translated">매개 변수 &lt;code&gt;$text&lt;/code&gt; 는 내부 시퀀스에 대해 구문 분석 할 문자열 또는 텍스트 블록입니다. &lt;code&gt;$line_num&lt;/code&gt; 매개 변수 는 &lt;code&gt;$text&lt;/code&gt; 의 시작 부분에 해당하는 줄 번호 입니다.</target>
        </trans-unit>
        <trans-unit id="175733e4967510eadb5d4ab18e962461101eaed6" translate="yes" xml:space="preserve">
          <source>The parameter &lt;code&gt;extra_libs&lt;/code&gt; can be used to specify &lt;b&gt;additional&lt;/b&gt; paths to search for installed modules. For instance</source>
          <target state="translated">&lt;code&gt;extra_libs&lt;/code&gt; 매개 변수 는 설치된 모듈을 검색하기위한 &lt;b&gt;추가&lt;/b&gt; 경로를 지정하는 데 사용될 수 있습니다 . 예를 들어</target>
        </trans-unit>
        <trans-unit id="76679b1c7056137b35154fa4603dcc56a2e17eed" translate="yes" xml:space="preserve">
          <source>The parameter &lt;code&gt;type&lt;/code&gt; is an enumeration which specifies which of the 3 interface methods (DB_HASH, DB_BTREE or DB_RECNO) is to be used. Depending on which of these is actually chosen, the final parameter,</source>
          <target state="translated">매개 변수 &lt;code&gt;type&lt;/code&gt; 은 사용할 3 가지 인터페이스 메소드 (DB_HASH, DB_BTREE 또는 DB_RECNO)를 지정하는 열거입니다. 이 중 실제로 선택된 매개 변수에 따라</target>
        </trans-unit>
        <trans-unit id="6df79d8edafef2b8d47fc8b433ceb1dac071556d" translate="yes" xml:space="preserve">
          <source>The parameter list to my() may be assigned to if desired, which allows you to initialize your variables. (If no initializer is given for a particular variable, it is created with the undefined value.) Commonly this is used to name input parameters to a subroutine. Examples:</source>
          <target state="translated">원하는 경우 my ()에 대한 매개 변수 목록을 지정하여 변수를 초기화 할 수 있습니다. (특정 변수에 대해 이니셜 라이저가 제공되지 않으면 정의되지 않은 값으로 작성됩니다.) 일반적으로 이는 입력 매개 변수의 이름을 서브 루틴으로 지정하는 데 사용됩니다. 예 :</target>
        </trans-unit>
        <trans-unit id="42306ba107d404a6932eda2f03148007a2382a8a" translate="yes" xml:space="preserve">
          <source>The parameter's default value will still be evaluated if the corresponding argument isn't supplied, even though the value won't be stored anywhere. This is in case evaluating it has important side effects. However, it will be evaluated in void context, so if it doesn't have side effects and is not trivial it will generate a warning if the &quot;void&quot; warning category is enabled. If a nameless optional parameter's default value is not important, it may be omitted just as the parameter's name was:</source>
          <target state="translated">값이 어디에도 저장되지 않더라도 해당 인수가 제공되지 않으면 매개 변수의 기본값이 여전히 평가됩니다. 평가에 중요한 부작용이있는 경우입니다. 그러나 빈 공간에서 평가되므로 부작용이없고 사소하지 않은 경우 &quot;void&quot;경고 범주가 활성화되면 경고가 생성됩니다. 이름이없는 선택적 매개 변수의 기본값이 중요하지 않은 경우 매개 변수 이름이 다음과 같이 생략 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="59f23da7798f0b234972a256a92c78bcfb8c2aa3" translate="yes" xml:space="preserve">
          <source>The parameter, &lt;code&gt;$input_filename_or_reference&lt;/code&gt; , is used to define the source of the compressed data.</source>
          <target state="translated">&lt;code&gt;$input_filename_or_reference&lt;/code&gt; 매개 변수 는 압축 된 데이터의 소스를 정의하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="ed835ab2fa9d34eac4fd3a603940891a0a5eef62" translate="yes" xml:space="preserve">
          <source>The parameter, &lt;code&gt;$input_filename_or_reference&lt;/code&gt; , is used to define the source of the uncompressed data.</source>
          <target state="translated">&lt;code&gt;$input_filename_or_reference&lt;/code&gt; 매개 변수 는 압축되지 않은 데이터의 소스를 정의하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="4cb5c66abe58beef181f4c5d5c5b7b8d0a8b5206" translate="yes" xml:space="preserve">
          <source>The parameter, &lt;code&gt;$input_filename_or_reference&lt;/code&gt;, is used to define the source of the compressed data.</source>
          <target state="translated">매개 변수 &lt;code&gt;$input_filename_or_reference&lt;/code&gt; 는 압축 된 데이터의 소스를 정의하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="c7a676729b0be9ab28de0e8dc42a59d230912658" translate="yes" xml:space="preserve">
          <source>The parameter, &lt;code&gt;$input_filename_or_reference&lt;/code&gt;, is used to define the source of the uncompressed data.</source>
          <target state="translated">&lt;code&gt;$input_filename_or_reference&lt;/code&gt; 매개 변수 는 압축되지 않은 데이터의 소스를 정의하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="2e0cab04bcd8cbbda8dd4d2c9ce2cf18535f80ac" translate="yes" xml:space="preserve">
          <source>The parameters it accepts are:</source>
          <target state="translated">허용되는 매개 변수는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a830abc7b9d4b876164e2805f5f239e46c825485" translate="yes" xml:space="preserve">
          <source>The parameters to &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; lib&lt;/code&gt; are added to the start of the perl search path. Saying</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; lib&lt;/code&gt; 를 &lt;a href=&quot;functions/use&quot;&gt;사용&lt;/a&gt; 하는 매개 변수 는 perl 검색 경로의 시작 부분에 추가됩니다. 속담</target>
        </trans-unit>
        <trans-unit id="735cc433a3b6580bd3067e26aea227e52cc434e6" translate="yes" xml:space="preserve">
          <source>The parameters to &lt;code&gt;use lib&lt;/code&gt; are added to the start of the perl search path. Saying</source>
          <target state="translated">&lt;code&gt;use lib&lt;/code&gt; 를 사용 하는 매개 변수 는 perl 검색 경로의 시작 부분에 추가됩니다. 속담</target>
        </trans-unit>
        <trans-unit id="ea253e51dc3b40387e985b7980c9898cef5a3467" translate="yes" xml:space="preserve">
          <source>The parentheses about &lt;code&gt;XSLoader::load()&lt;/code&gt; arguments are needed since we replaced &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; XSLoader&lt;/code&gt; by &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt;, so the compiler does not know that a function &lt;code&gt;XSLoader::load()&lt;/code&gt; is present.</source>
          <target state="translated">&lt;code&gt;XSLoader::load()&lt;/code&gt; 인수 에 대한 괄호는 우리가 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; XSLoader&lt;/code&gt; 를 &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; 로 대체 했기 때문에 필요 하므로 컴파일러는 &lt;code&gt;XSLoader::load()&lt;/code&gt; 함수 가 존재 한다는 것을 알지 못합니다 .</target>
        </trans-unit>
        <trans-unit id="0d68003766a6505369e854c0eee6d10a747bd253" translate="yes" xml:space="preserve">
          <source>The parentheses about &lt;code&gt;XSLoader::load()&lt;/code&gt; arguments are needed since we replaced &lt;code&gt;use XSLoader&lt;/code&gt; by &lt;code&gt;require&lt;/code&gt;, so the compiler does not know that a function &lt;code&gt;XSLoader::load()&lt;/code&gt; is present.</source>
          <target state="translated">&lt;code&gt;use XSLoader&lt;/code&gt; 를 &lt;code&gt;require&lt;/code&gt; 로 대체했기 때문에 &lt;code&gt;XSLoader::load()&lt;/code&gt; 인수 에 대한 괄호 가 필요하므로 컴파일러는 함수 &lt;code&gt;XSLoader::load()&lt;/code&gt; 가 존재 하는지 알지 못합니다 .</target>
        </trans-unit>
        <trans-unit id="f992098d3a5a843dac6b8ae9c7b69d4a2fac46e8" translate="yes" xml:space="preserve">
          <source>The parse proceeds pretty much exactly as it does during the construction phase, except that most routines are short-circuited to change the size field &lt;code&gt;RExC_size&lt;/code&gt; and not do anything else.</source>
          <target state="translated">구문 분석은 대부분의 루틴이 단락되어 크기 필드 &lt;code&gt;RExC_size&lt;/code&gt; 를 변경하고 다른 작업을 수행하지 않는다는 점을 제외하고는 구성 단계와 거의 동일하게 진행 됩니다.</target>
        </trans-unit>
        <trans-unit id="ce842c5dcf2b13fb8c9e8394fe72be9c8b2663ca" translate="yes" xml:space="preserve">
          <source>The parser is heavily inspired from the one in &lt;a href=&quot;ExtUtils::ParseXS&quot;&gt;ExtUtils::ParseXS&lt;/a&gt;.</source>
          <target state="translated">파서는 &lt;a href=&quot;ExtUtils::ParseXS&quot;&gt;ExtUtils :: ParseXS&lt;/a&gt; 의 파서에서 크게 영감을 받았습니다 .</target>
        </trans-unit>
        <trans-unit id="93ac900e49339cc6ef6dea21ed4478644c93af89" translate="yes" xml:space="preserve">
          <source>The parser is nobly assisted by the lexer, which chunks up your input into tokens, and decides what type of thing each token is: a variable name, an operator, a bareword, a subroutine, a core function, and so on. The main point of entry to the lexer is &lt;code&gt;yylex&lt;/code&gt; , and that and its associated routines can be found in</source>
          <target state="translated">파서는 어휘 분석기로 도움을 받는다. 어휘 분석기는 어휘 분석기를 이용하여 입력을 토큰으로 청산하고 변수 명, 연산자, 베어 워드, 서브 루틴, 코어 함수 등 각 토큰의 유형을 결정한다. 렉서의 주요 진입 점은 &lt;code&gt;yylex&lt;/code&gt; 이며 해당 루틴 및 관련 루틴은</target>
        </trans-unit>
        <trans-unit id="22cd9c89b1bd366e42455f5006c44969bcb5bdee" translate="yes" xml:space="preserve">
          <source>The parser is nobly assisted by the lexer, which chunks up your input into tokens, and decides what type of thing each token is: a variable name, an operator, a bareword, a subroutine, a core function, and so on. The main point of entry to the lexer is &lt;code&gt;yylex&lt;/code&gt;, and that and its associated routines can be found in</source>
          <target state="translated">파서는 사용자의 입력을 토큰으로 묶어 변수 이름, 연산자, 베어 워드, 서브 루틴, 핵심 함수 등 각 토큰의 유형을 결정하는 어휘 분석기에 의해 고상하게 지원됩니다. 어휘 분석기에 대한 주요 진입 점은 &lt;code&gt;yylex&lt;/code&gt; 이며 해당 루틴과 관련 루틴은 다음에서 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c291c44225b529aa63eb30ed6a4d6cbe06294dcd" translate="yes" xml:space="preserve">
          <source>The parser then sees the following code:</source>
          <target state="translated">그런 다음 파서는 다음 코드를 봅니다.</target>
        </trans-unit>
        <trans-unit id="d30f0f58beb42ee5cf5d76db1412cac91e934bb2" translate="yes" xml:space="preserve">
          <source>The part of an Email address which follows the @ is not necessarily a hostname, it is a mail domain. To find the name of a host to connect for a mail domain you need to do a DNS MX lookup</source>
          <target state="translated">@ 뒤에 오는 이메일 주소 부분은 반드시 호스트 이름이 아니라 메일 도메인입니다. 메일 도메인에 연결할 호스트 이름을 찾으려면 DNS MX 조회를 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="09f50fcb4a70f717d3ac7b5f391fbd97a01ce899" translate="yes" xml:space="preserve">
          <source>The part of the address of a TCP or UDP socket that directs packets to the correct process after finding the right machine, something like the phone extension you give when you reach the company operator. Also the result of converting code to run on a different platform than originally intended, or the verb denoting this conversion.</source>
          <target state="translated">올바른 기계를 찾은 후 회사 운영자에게 연락 할 때 제공하는 전화 내선 번호와 같은 올바른 프로세스로 패킷을 전달하는 TCP 또는 UDP 소켓 주소 부분. 또한 원래 의도 한 것과 다른 플랫폼에서 실행되도록 코드를 변환 한 결과 또는이 변환을 나타내는 동사입니다.</target>
        </trans-unit>
        <trans-unit id="ae986ba9c61f4a263f7b3033ed66b7a9c47ca2ea" translate="yes" xml:space="preserve">
          <source>The particular copy of Perl that you're trying to use does not support the specified signal being used in a &lt;code&gt;-&amp;gt;kill()&lt;/code&gt; call.</source>
          <target state="translated">사용하려는 Perl의 특정 사본이 &lt;code&gt;-&amp;gt;kill()&lt;/code&gt; 호출 에 사용되는 지정된 신호를 지원하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="24e4beb9cede37117dbc38642ef9d4cdf73ef0f4" translate="yes" xml:space="preserve">
          <source>The particular copy of Perl that you're trying to use was not built using the &lt;code&gt;useithreads&lt;/code&gt; configuration option.</source>
          <target state="translated">사용하려는 Perl의 특정 사본은 &lt;code&gt;useithreads&lt;/code&gt; 구성 옵션을 사용하여 빌드되지 않았습니다 .</target>
        </trans-unit>
        <trans-unit id="e133c3129f1a418b83b69fbe9affe042d494a52e" translate="yes" xml:space="preserve">
          <source>The particular macro you must use depends on which &lt;code&gt;sv_set*v&lt;/code&gt; routine you called first. This is because every &lt;code&gt;sv_set*v&lt;/code&gt; routine turns on only the bit for the particular type of data being set, and turns off all the rest.</source>
          <target state="translated">사용해야하는 특정 매크로 는 먼저 호출 한 &lt;code&gt;sv_set*v&lt;/code&gt; 루틴 에 따라 다릅니다 . 모든 &lt;code&gt;sv_set*v&lt;/code&gt; 루틴은 설정중인 특정 유형의 데이터에 대한 비트 만 설정하고 나머지는 모두 해제하기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="9a1356c02587b997ee27ddf50eebcf831988fbcb" translate="yes" xml:space="preserve">
          <source>The passed-in property may be specified as any of the synonyms returned by &lt;a href=&quot;#prop_aliases%28%29&quot;&gt;&quot;prop_aliases()&quot;&lt;/a&gt;.</source>
          <target state="translated">전달 된 속성은 &lt;a href=&quot;#prop_aliases%28%29&quot;&gt;&quot;prop_aliases ()&quot;에서&lt;/a&gt; 반환 된 동의어로 지정 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1c24d584fffb94c2e195393379212bd0e772bba9" translate="yes" xml:space="preserve">
          <source>The passed-in property may be specified as any of the synonyms returned by &lt;a href=&quot;#prop_aliases()&quot;&gt;prop_aliases()&lt;/a&gt;.</source>
          <target state="translated">전달 된 속성은 &lt;a href=&quot;#prop_aliases()&quot;&gt;prop_aliases ()가&lt;/a&gt; 반환 한 동의어 중 하나로 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="515ad1971581ebeed29e0dfbff2e2ca6f9f34b5c" translate="yes" xml:space="preserve">
          <source>The patchlevel level of this package. The value of patchlevel comes from the</source>
          <target state="translated">이 패키지의 패치 수준입니다. patchlevel의 가치는</target>
        </trans-unit>
        <trans-unit id="6c9c1991e5426882e512831205056ad8d0cb53e5" translate="yes" xml:space="preserve">
          <source>The path Perl takes through &lt;code&gt;@INC&lt;/code&gt; . By default, this is a double depth first search, once looking for defined methods and once for &lt;code&gt;AUTOLOAD&lt;/code&gt; . However, Perl lets you configure this with &lt;code&gt;mro&lt;/code&gt; .</source>
          <target state="translated">Perl의 경로는 &lt;code&gt;@INC&lt;/code&gt; 를 통과 합니다. 기본적으로, 이것은 정의 된 메소드를 찾은 후 &lt;code&gt;AUTOLOAD&lt;/code&gt; 를 위한 한 번의 이중 심도 검색 입니다. 그러나 Perl에서는 &lt;code&gt;mro&lt;/code&gt; 로이 를 구성 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="bfd87cb3c63ce818c0482394b6803650584202ed" translate="yes" xml:space="preserve">
          <source>The path Perl takes through &lt;code&gt;@INC&lt;/code&gt;. By default, this is a double depth first search, once looking for defined methods and once for &lt;code&gt;AUTOLOAD&lt;/code&gt;. However, Perl lets you configure this with &lt;code&gt;mro&lt;/code&gt;.</source>
          <target state="translated">Perl이 &lt;code&gt;@INC&lt;/code&gt; 를 통과하는 경로 입니다. 기본적으로 이것은 정의 된 메소드를 한 번 찾고 &lt;code&gt;AUTOLOAD&lt;/code&gt; 에 대해 한 번은 이중 깊이 우선 검색 입니다. 그러나 Perl을 사용하면 &lt;code&gt;mro&lt;/code&gt; 로이 를 구성 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="97b7ffc6783961615c324915aaa3803b45441d58" translate="yes" xml:space="preserve">
          <source>The path from the uri, will be at least a single '/'.</source>
          <target state="translated">URI에서 경로는 적어도 하나의 '/'입니다.</target>
        </trans-unit>
        <trans-unit id="935a26d686af6b04ea7fea8358669d0caebc7249" translate="yes" xml:space="preserve">
          <source>The path of the file from which the history (assuming a usable Term::ReadLine backend) will be read on the debugger's startup, and to which it will be saved on shutdown (for persistence across sessions). Similar in concept to Bash's &lt;code&gt;.bash_history&lt;/code&gt; file.</source>
          <target state="translated">사용 가능한 Term :: ReadLine 백엔드를 사용하여 히스토리가 디버거 시작시 읽히고 종료시 저장되는 파일의 경로입니다 (세션 전체에 지속성을 위해). Bash의 &lt;code&gt;.bash_history&lt;/code&gt; 파일 과 개념이 비슷 합니다.</target>
        </trans-unit>
        <trans-unit id="b7867a311910479846a23412feb4307a4674c491" translate="yes" xml:space="preserve">
          <source>The path to the &lt;code&gt;git&lt;/code&gt; binary to use for the Git features. The default is &lt;code&gt;/usr/local/bin/git&lt;/code&gt;.</source>
          <target state="translated">Git 기능에 사용할 &lt;code&gt;git&lt;/code&gt; 바이너리 의 경로 입니다. 기본값은 &lt;code&gt;/usr/local/bin/git&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="3f73d1d0634237caab821e6e9c8fad9914a18a73" translate="yes" xml:space="preserve">
          <source>The path to the file is automatically converted to a Unix like equivalent for use in the archive, and, if on MacOS, the file's modification time is converted from the MacOS epoch to the Unix epoch. So tar archives created on MacOS with &lt;b&gt;Archive::Tar&lt;/b&gt; can be read both with</source>
          <target state="translated">파일 경로는 아카이브에서 사용하기 위해 자동으로 Unix로 변환되며, MacOS의 경우 파일 수정 시간이 MacOS 시대에서 Unix 시대로 변환됩니다. 따라서 &lt;b&gt;Archive :: Tar를 사용&lt;/b&gt; 하여 MacOS에서 생성 된 tar 아카이브 는</target>
        </trans-unit>
        <trans-unit id="2ab24d7b050cb5882eec74eec0cbc6ea2a2768dd" translate="yes" xml:space="preserve">
          <source>The pathname of a POD file to syntax-check (defaults to standard input).</source>
          <target state="translated">구문 검사를위한 POD 파일의 경로 이름 (기본값은 표준 입력)입니다.</target>
        </trans-unit>
        <trans-unit id="3091661abc10e8b933048a63287800c8286b8cec" translate="yes" xml:space="preserve">
          <source>The pathname of a file containing pod documentation to be output in usage message format (defaults to standard input).</source>
          <target state="translated">사용법 메시지 형식으로 출력 될 포드 문서를 포함하는 파일의 경로 이름입니다 (기본값은 표준 입력).</target>
        </trans-unit>
        <trans-unit id="5506a685c5fca482706d4108f11645e50bb17fd9" translate="yes" xml:space="preserve">
          <source>The pathname of a file from which to select sections of pod documentation (defaults to standard input).</source>
          <target state="translated">포드 설명서의 섹션을 선택할 파일의 경로 이름입니다 (기본값은 표준 입력).</target>
        </trans-unit>
        <trans-unit id="64067e36292a9c79bf92f0c4d392216daafe926d" translate="yes" xml:space="preserve">
          <source>The pattern begins with a class matching a subset of letters. Whenever this matches, a statement like &lt;code&gt;$count{'a'}++;&lt;/code&gt; is executed, incrementing the letter's counter. Then &lt;code&gt;(*FAIL)&lt;/code&gt; does what it says, and the regexp engine proceeds according to the book: as long as the end of the string hasn't been reached, the position is advanced before looking for another vowel. Thus, match or no match makes no difference, and the regexp engine proceeds until the entire string has been inspected. (It's remarkable that an alternative solution using something like</source>
          <target state="translated">패턴은 문자의 하위 집합과 일치하는 클래스로 시작합니다. 이것이 일치 할 때마다 &lt;code&gt;$count{'a'}++;&lt;/code&gt; 문자 카운터를 증가시키면서 실행됩니다. 그런 다음 &lt;code&gt;(*FAIL)&lt;/code&gt; 이 말한 것을 수행하고 정규식 엔진은 책에 따라 진행합니다. 줄의 끝에 도달하지 않으면 다른 모음을 찾기 전에 위치가 진행됩니다. 따라서 일치 또는 일치하지 않으면 차이가 없으며 정규식 엔진은 전체 문자열이 검사 될 때까지 진행됩니다. (다음과 같은 것을 사용하는 대체 솔루션은 놀랍습니다.</target>
        </trans-unit>
        <trans-unit id="a027102deb051cbffb2428b7b7a47e74a500b189" translate="yes" xml:space="preserve">
          <source>The pattern match succeeds and &lt;code&gt;$1&lt;/code&gt; is defined, although it matched &quot;nothing&quot;. It didn't really fail to match anything. Rather, it matched something that happened to be zero characters long. This is all very above-board and honest. When a function returns an undefined value, it's an admission that it couldn't give you an honest answer. So you should use &lt;a href=&quot;#defined-EXPR&quot;&gt;&lt;code&gt;defined&lt;/code&gt;&lt;/a&gt; only when questioning the integrity of what you're trying to do. At other times, a simple comparison to &lt;code&gt;0&lt;/code&gt; or &lt;code&gt;&quot;&quot;&lt;/code&gt; is what you want.</source>
          <target state="translated">패턴 일치가 성공하고 &lt;code&gt;$1&lt;/code&gt; 이 정의되지만 &quot;아무것도&quot;일치하지 않습니다. 실제로 어떤 것과도 일치하는 데 실패하지 않았습니다. 오히려 그것은 길이가 0자인 것과 일치했습니다. 이것은 모두 매우 정직하고 정직합니다. 함수가 정의되지 않은 값을 반환하면 정직한 대답을 할 수 없다는 것을 인정하는 것입니다. 따라서 수행하려는 작업의 무결성에 의문을 제기 할 때만 &lt;a href=&quot;#defined-EXPR&quot;&gt; &lt;code&gt;defined&lt;/code&gt; &lt;/a&gt; 를 사용해야합니다 . 다른 경우에는 &lt;code&gt;0&lt;/code&gt; 또는 &lt;code&gt;&quot;&quot;&lt;/code&gt; 에 대한 간단한 비교가 원하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="194b10f85ac928e670426276285fc77367b6bf3e" translate="yes" xml:space="preserve">
          <source>The pattern match succeeds and &lt;code&gt;$1&lt;/code&gt; is defined, although it matched &quot;nothing&quot;. It didn't really fail to match anything. Rather, it matched something that happened to be zero characters long. This is all very above-board and honest. When a function returns an undefined value, it's an admission that it couldn't give you an honest answer. So you should use &lt;code&gt;&lt;a href=&quot;defined&quot;&gt;defined&lt;/a&gt;&lt;/code&gt; only when questioning the integrity of what you're trying to do. At other times, a simple comparison to &lt;code&gt;0&lt;/code&gt; or &lt;code&gt;&quot;&quot;&lt;/code&gt; is what you want.</source>
          <target state="translated">패턴 일치가 성공하고 &lt;code&gt;$1&lt;/code&gt; &quot;nothing&quot;과 일치하지만 $ 1 이 정의됩니다. 실제로 아무것도 일치하지 않습니다. 오히려 0 자 길이의 항목과 일치합니다. 이것은 모두 매우 정직하고 정직합니다. 함수가 정의되지 않은 값을 반환하면 정직한 대답을 할 수 없다는 것이 인정됩니다. 따라서 수행하려는 작업의 무결성에 의문을 제기 할 때만 &lt;code&gt;&lt;a href=&quot;defined&quot;&gt;defined&lt;/a&gt;&lt;/code&gt; 를 사용해야합니다 . 다른 경우에는 &lt;code&gt;0&lt;/code&gt; 또는 &lt;code&gt;&quot;&quot;&lt;/code&gt; 에 대한 간단한 비교가 원하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="6ccde9606e998bb56b83482fdb0ce2d1cd2b87e5" translate="yes" xml:space="preserve">
          <source>The pattern match succeeds and &lt;code&gt;$1&lt;/code&gt; is defined, although it matched &quot;nothing&quot;. It didn't really fail to match anything. Rather, it matched something that happened to be zero characters long. This is all very above-board and honest. When a function returns an undefined value, it's an admission that it couldn't give you an honest answer. So you should use &lt;code&gt;&lt;a href=&quot;functions/defined&quot;&gt;defined&lt;/a&gt;&lt;/code&gt; only when questioning the integrity of what you're trying to do. At other times, a simple comparison to &lt;code&gt;0&lt;/code&gt; or &lt;code&gt;&quot;&quot;&lt;/code&gt; is what you want.</source>
          <target state="translated">패턴 일치가 성공하고 &lt;code&gt;$1&lt;/code&gt; &quot;nothing&quot;과 일치하지만 이 정의됩니다. 실제로 아무것도 일치하지 않습니다. 오히려 0 자 길이의 항목과 일치합니다. 이것은 모두 매우 정직하고 정직합니다. 함수가 정의되지 않은 값을 반환하면 정직한 대답을 할 수 없다는 것이 인정됩니다. 따라서 수행하려는 작업의 무결성에 의문을 제기 할 때만 &lt;code&gt;&lt;a href=&quot;functions/defined&quot;&gt;defined&lt;/a&gt;&lt;/code&gt; 를 사용해야합니다 . 다른 경우에는 &lt;code&gt;0&lt;/code&gt; 또는 &lt;code&gt;&quot;&quot;&lt;/code&gt; 에 대한 간단한 비교가 원하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="00e74cbb0f8570bc720cdf9f1dc73c5533c198b5" translate="yes" xml:space="preserve">
          <source>The pattern matching metacharacters &quot;(&quot;, &quot;)&quot;, and &quot;|&quot; do not have backslashes in front.</source>
          <target state="translated">패턴 일치 메타 문자 &quot;(&quot;, &quot;)&quot;및 &quot;|&quot; 앞에 백 슬래시가 없습니다.</target>
        </trans-unit>
        <trans-unit id="8647f015f186197cabe9c1508a8d5b1dddf875e9" translate="yes" xml:space="preserve">
          <source>The pattern matching operations &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m//&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr///&lt;/a&gt;&lt;/code&gt; (aka &lt;code&gt;&lt;a href=&quot;functions/y&quot;&gt;y///&lt;/a&gt;&lt;/code&gt;) when used without an &lt;code&gt;=~&lt;/code&gt; operator.</source>
          <target state="translated">패턴 매칭 연산 &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m//&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr///&lt;/a&gt;&lt;/code&gt; &lt;code&gt;=~&lt;/code&gt; 연산자없이 사용될 때 tr /// (일명 &lt;code&gt;&lt;a href=&quot;functions/y&quot;&gt;y///&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="86784bd21e39089878c5197cae9b26fe435b4866" translate="yes" xml:space="preserve">
          <source>The pattern matching operations &lt;code&gt;m//&lt;/code&gt;, &lt;code&gt;s///&lt;/code&gt; and &lt;code&gt;tr///&lt;/code&gt; (aka &lt;code&gt;y///&lt;/code&gt;) when used without an &lt;code&gt;=~&lt;/code&gt; operator.</source>
          <target state="translated">&lt;code&gt;=~&lt;/code&gt; 연산자 없이 사용될 때 패턴 일치 연산 &lt;code&gt;m//&lt;/code&gt; , &lt;code&gt;s///&lt;/code&gt; 및 &lt;code&gt;tr///&lt;/code&gt; (일명 &lt;code&gt;y///&lt;/code&gt; ) .</target>
        </trans-unit>
        <trans-unit id="216352b3a9f025091614aa329a166fdb30a18a8e" translate="yes" xml:space="preserve">
          <source>The pattern modifiers:</source>
          <target state="translated">패턴 수정 자 :</target>
        </trans-unit>
        <trans-unit id="a2c1a780666383b49402abd005e8fafffcab62b8" translate="yes" xml:space="preserve">
          <source>The pattern of macro calls is like this:</source>
          <target state="translated">매크로 호출 패턴은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3569af6a782c9884f9c5e89ba969f12fe42cf2da" translate="yes" xml:space="preserve">
          <source>The pattern really,</source>
          <target state="translated">패턴은 정말</target>
        </trans-unit>
        <trans-unit id="f373f7a0e4daf869b86fcbb5c4b5b4f2ee465c22" translate="yes" xml:space="preserve">
          <source>The pattern will be used as a Perl regular expression (as opposed to a simple grep regex).</source>
          <target state="translated">패턴은 Perl 정규식으로 사용됩니다 (단순 grep 정규식과 반대).</target>
        </trans-unit>
        <trans-unit id="8a46001019582eae5c4e5728c4a3fb31cd3dbf38" translate="yes" xml:space="preserve">
          <source>The patterns used in Perl pattern matching evolved from those supplied in the Version 8 regex routines. (The routines are derived (distantly) from Henry Spencer's freely redistributable reimplementation of the V8 routines.) See &lt;a href=&quot;#Version-8-Regular-Expressions&quot;&gt;Version 8 Regular Expressions&lt;/a&gt; for details.</source>
          <target state="translated">Perl 패턴 일치에 사용 된 패턴은 버전 8 정규식 루틴에서 제공되는 패턴에서 발전했습니다. (이 루틴은 Henry Spencer의 무료 재배포 가능한 V8 루틴의 재 구현에서 파생됩니다.)&lt;a href=&quot;#Version-8-Regular-Expressions&quot;&gt; 버전 8 정규식&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="e790c64d043de1336b86cfb89ee718b54cb057cd" translate="yes" xml:space="preserve">
          <source>The peephole optimiser should never be completely replaced. Rather, add code to it by wrapping the existing optimiser. The basic way to do this can be seen in &lt;a href=&quot;perlguts#Compile-pass-3%3A-peephole-optimization&quot;&gt;&quot;Compile pass 3: peephole optimization&quot; in perlguts&lt;/a&gt;. If the new code wishes to operate on ops throughout the subroutine's structure, rather than just at the top level, it is likely to be more convenient to wrap the &lt;a href=&quot;#PL_rpeepp&quot;&gt;&quot;PL_rpeepp&quot;&lt;/a&gt; hook.</source>
          <target state="translated">엿보기 옵티 마이저를 완전히 교체해서는 안됩니다. 오히려 기존 옵티 마이저를 래핑하여 코드를 추가하십시오. 이를 수행하는 기본 방법 &lt;a href=&quot;perlguts#Compile-pass-3%3A-peephole-optimization&quot;&gt;은 perlguts의 &quot;Compile pass 3 : peephole optimization&quot;에서&lt;/a&gt; 볼 수 있습니다 . 새 코드가 최상위 수준이 아닌 서브 루틴 구조 전체에서 작업을 수행하려는 경우 &lt;a href=&quot;#PL_rpeepp&quot;&gt;&quot;PL_rpeepp&quot;&lt;/a&gt; 후크 를 래핑하는 것이 더 편리 할 것 입니다.</target>
        </trans-unit>
        <trans-unit id="8569c5379da2f4cde343faebf02e081c76fc9c06" translate="yes" xml:space="preserve">
          <source>The peephole optimiser should never be completely replaced. Rather, add code to it by wrapping the existing optimiser. The basic way to do this can be seen in &lt;a href=&quot;perlguts#Compile-pass-3%3A-peephole-optimization&quot;&gt;&quot;Compile pass 3: peephole optimization&quot; in perlguts&lt;/a&gt;. If the new code wishes to operate only on ops at a subroutine's top level, rather than throughout the structure, it is likely to be more convenient to wrap the &lt;a href=&quot;#PL_peepp&quot;&gt;&quot;PL_peepp&quot;&lt;/a&gt; hook.</source>
          <target state="translated">엿보기 옵티 마이저를 완전히 교체해서는 안됩니다. 오히려 기존 옵티 마이저를 래핑하여 코드를 추가하십시오. 이를 수행하는 기본 방법 &lt;a href=&quot;perlguts#Compile-pass-3%3A-peephole-optimization&quot;&gt;은 perlguts의 &quot;Compile pass 3 : peephole optimization&quot;에서&lt;/a&gt; 볼 수 있습니다 . 새 코드가 구조 전체가 아닌 서브 루틴의 최상위 수준에있는 ops에서만 작동하려는 경우 &lt;a href=&quot;#PL_peepp&quot;&gt;&quot;PL_peepp&quot;&lt;/a&gt; 후크 를 래핑하는 것이 더 편리 할 것 입니다.</target>
        </trans-unit>
        <trans-unit id="dac0ad9b1d3df00129661ed1e95ffc2c13f0c968" translate="yes" xml:space="preserve">
          <source>The peephole optimiser should never be completely replaced. Rather, add code to it by wrapping the existing optimiser. The basic way to do this can be seen in &lt;a href=&quot;perlguts#Compile-pass-3%3a-peephole-optimization&quot;&gt;Compile pass 3: peephole optimization in perlguts&lt;/a&gt;. If the new code wishes to operate on ops throughout the subroutine's structure, rather than just at the top level, it is likely to be more convenient to wrap the &lt;a href=&quot;#PL_rpeepp&quot;&gt;PL_rpeepp&lt;/a&gt; hook.</source>
          <target state="translated">들여다 보는 구멍 최적화 장치를 완전히 교체해서는 안됩니다. 오히려 기존 옵티 마이저를 랩핑하여 코드를 추가하십시오. 이를 수행하는 기본 방법은 &lt;a href=&quot;perlguts#Compile-pass-3%3a-peephole-optimization&quot;&gt;컴파일 패스 3&lt;/a&gt; 에서 볼 수 있습니다 : perlguts의 구멍 최적화 . 새 코드가 최상위 수준이 아닌 서브 루틴 구조 전체에서 op에서 작동하려면 &lt;a href=&quot;#PL_rpeepp&quot;&gt;PL_rpeepp&lt;/a&gt; 후크 를 감싸는 것이 더 편리 할 것 입니다.</target>
        </trans-unit>
        <trans-unit id="db43041726026c591925cfc25e5688f00dc4bbac" translate="yes" xml:space="preserve">
          <source>The peephole optimiser should never be completely replaced. Rather, add code to it by wrapping the existing optimiser. The basic way to do this can be seen in &lt;a href=&quot;perlguts#Compile-pass-3%3a-peephole-optimization&quot;&gt;Compile pass 3: peephole optimization in perlguts&lt;/a&gt;. If the new code wishes to operate only on ops at a subroutine's top level, rather than throughout the structure, it is likely to be more convenient to wrap the &lt;a href=&quot;#PL_peepp&quot;&gt;PL_peepp&lt;/a&gt; hook.</source>
          <target state="translated">들여다 보는 구멍 최적화 장치를 완전히 교체해서는 안됩니다. 오히려 기존 옵티 마이저를 랩핑하여 코드를 추가하십시오. 이를 수행하는 기본 방법은 &lt;a href=&quot;perlguts#Compile-pass-3%3a-peephole-optimization&quot;&gt;컴파일 패스 3 : perlguts의 틈 구멍 최적화에서&lt;/a&gt; 볼 수 있습니다 . 새로운 코드가 구조 전체가 아닌 서브 루틴의 최상위 레벨에서만 작동하기를 원한다면 &lt;a href=&quot;#PL_peepp&quot;&gt;PL_peepp&lt;/a&gt; 훅 을 감싸는 것이 더 편리 할 것 입니다.</target>
        </trans-unit>
        <trans-unit id="ace3f1e6483238aa81eb601036e5dcd7d2b38b3a" translate="yes" xml:space="preserve">
          <source>The per-instance data are held in memory beyond the basic PerlIOl struct, by making a PerlIOl the first member of the layer's struct thus:</source>
          <target state="translated">PerlIOl을 레이어 구조의 첫 번째 멤버로 만들어 인스턴스 별 데이터를 기본 PerlIOl 구조체 이외의 메모리에 보관합니다.</target>
        </trans-unit>
        <trans-unit id="467fb902a44226db21d27e75dc641b031d86cd72" translate="yes" xml:space="preserve">
          <source>The per-instance data for a particular handle.</source>
          <target state="translated">특정 핸들에 대한 인스턴스 별 데이터.</target>
        </trans-unit>
        <trans-unit id="85e58f1f52dd9a0e84852e44b90f48bbed040fce" translate="yes" xml:space="preserve">
          <source>The per-record overhead will limit the maximum number of records you can access per file. Note that</source>
          <target state="translated">레코드 당 오버 헤드는 파일 당 액세스 할 수있는 최대 레코드 수를 제한합니다. 참고</target>
        </trans-unit>
        <trans-unit id="874d7f7aa12fc5ea3bd61b16d41289fe642a630c" translate="yes" xml:space="preserve">
          <source>The period '.' matches any character but &quot;\n&quot;</source>
          <target state="translated">기간 '.' &quot;\ n&quot;을 제외한 모든 문자와 일치</target>
        </trans-unit>
        <trans-unit id="e038fd297e6c1d463ecc98d5fcaacd0e4180bccd" translate="yes" xml:space="preserve">
          <source>The period '.' matches any character but &quot;\n&quot; (unless the modifier &lt;code&gt;//s&lt;/code&gt; is in effect, as explained below).</source>
          <target state="translated">기간 '.' &quot;\ n&quot;을 제외한 모든 문자와 일치합니다 (수정자가 &lt;code&gt;//s&lt;/code&gt; 가 아닌 한) 아래 설명 된대로 를 적용 ).</target>
        </trans-unit>
        <trans-unit id="bc11993ee6fae379fe2dbc40f494f74a38651177" translate="yes" xml:space="preserve">
          <source>The period &lt;code&gt;'.'&lt;/code&gt; matches any character but &lt;code&gt;&quot;\n&quot;&lt;/code&gt; (unless the modifier &lt;code&gt;/s&lt;/code&gt; is in effect, as explained below).</source>
          <target state="translated">마침표 &lt;code&gt;'.'&lt;/code&gt; &lt;code&gt;&quot;\n&quot;&lt;/code&gt; 제외한 모든 문자와 일치합니다 ( 아래에 설명 된대로 수정 자 &lt;code&gt;/s&lt;/code&gt; 가 적용 되지 않는 한 ).</target>
        </trans-unit>
        <trans-unit id="50625043a5bdab5548c251e25233bc0e03a34159" translate="yes" xml:space="preserve">
          <source>The perl code in PerlIO.pm then attempts to locate a layer by doing</source>
          <target state="translated">그런 다음 PerlIO.pm의 펄 코드는 다음을 수행하여 레이어를 찾습니다.</target>
        </trans-unit>
        <trans-unit id="634e60cc8e248b9b7ce51ac444bfec05dc82ef31" translate="yes" xml:space="preserve">
          <source>The perl command to use is determined by &lt;a href=&quot;#get_perl&quot;&gt;&quot;get_perl&quot;&lt;/a&gt;. The command generated is guaranteed to preserve:</source>
          <target state="translated">사용할 perl 명령은 &lt;a href=&quot;#get_perl&quot;&gt;&quot;get_perl&quot;에&lt;/a&gt; 의해 결정됩니다 . 생성 된 명령은 다음을 보존합니다.</target>
        </trans-unit>
        <trans-unit id="16b7e5af7739f86fd0e9e79d11ca97ac5649e9b1" translate="yes" xml:space="preserve">
          <source>The perl core wraps &lt;code&gt;setjmp()&lt;/code&gt; etc in the macros &lt;code&gt;JMPENV_PUSH&lt;/code&gt; and &lt;code&gt;JMPENV_JUMP&lt;/code&gt; . The basic rule of perl exceptions is that &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; (in the absence of &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;) perform a &lt;code&gt;JMPENV_JUMP(2)&lt;/code&gt; , while &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; within &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; does a &lt;code&gt;JMPENV_JUMP(3)&lt;/code&gt; .</source>
          <target state="translated">펄 코어 는 매크로 &lt;code&gt;JMPENV_PUSH&lt;/code&gt; 및 &lt;code&gt;JMPENV_JUMP&lt;/code&gt; 에서 &lt;code&gt;setjmp()&lt;/code&gt; 등을 래핑 합니다. perl 예외의 기본 규칙은 &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; ( &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 이없는 경우 )가 &lt;code&gt;JMPENV_JUMP(2)&lt;/code&gt; 수행하는 반면 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 내의 &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; 는 &lt;code&gt;JMPENV_JUMP(3)&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="d6c71858536e734e97d2970ba2f758d971d8a580" translate="yes" xml:space="preserve">
          <source>The perl core wraps &lt;code&gt;setjmp()&lt;/code&gt; etc in the macros &lt;code&gt;JMPENV_PUSH&lt;/code&gt; and &lt;code&gt;JMPENV_JUMP&lt;/code&gt;. The basic rule of perl exceptions is that &lt;code&gt;exit&lt;/code&gt;, and &lt;code&gt;die&lt;/code&gt; (in the absence of &lt;code&gt;eval&lt;/code&gt;) perform a &lt;code&gt;JMPENV_JUMP(2)&lt;/code&gt;, while &lt;code&gt;die&lt;/code&gt; within &lt;code&gt;eval&lt;/code&gt; does a &lt;code&gt;JMPENV_JUMP(3)&lt;/code&gt;.</source>
          <target state="translated">perl 코어 는 &lt;code&gt;JMPENV_PUSH&lt;/code&gt; 및 &lt;code&gt;JMPENV_JUMP&lt;/code&gt; 매크로에서 &lt;code&gt;setjmp()&lt;/code&gt; 등을 래핑 합니다. 펄 예외의 기본 규칙, 즉 &lt;code&gt;exit&lt;/code&gt; , 및 &lt;code&gt;die&lt;/code&gt; (의 부재 하에서 &lt;code&gt;eval&lt;/code&gt; )를 수행 &lt;code&gt;JMPENV_JUMP(2)&lt;/code&gt; 동시에 &lt;code&gt;die&lt;/code&gt; 내 &lt;code&gt;eval&lt;/code&gt; 않는 &lt;code&gt;JMPENV_JUMP(3)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3fdbc7e5dc74277662b153d8f95c93e631321b8b" translate="yes" xml:space="preserve">
          <source>The perl equivalent is &lt;code&gt;$sv = undef;&lt;/code&gt;. Note that it doesn't free any string buffer, unlike &lt;code&gt;undef $sv&lt;/code&gt;.</source>
          <target state="translated">perl에 해당하는 값은 &lt;code&gt;$sv = undef;&lt;/code&gt; . &lt;code&gt;undef $sv&lt;/code&gt; 와 달리 문자열 버퍼를 해제하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="6c474186075797ee40452934f04a51f573b827bb" translate="yes" xml:space="preserve">
          <source>The perl executable is obtained by linking</source>
          <target state="translated">Perl 실행 파일은 링크하여 얻습니다</target>
        </trans-unit>
        <trans-unit id="1d8ff0cddfb59dc7ae9ad6feb4a5e65da142f6d6" translate="yes" xml:space="preserve">
          <source>The perl history contains one mistake which was not caught in the conversion: a merge was recorded in the history between blead and maint-5.10 where no merge actually occurred. Due to the nature of git, this is now impossible to fix in the public repository. You can remove this mis-merge locally by adding the following line to your &lt;code&gt;.git/info/grafts&lt;/code&gt; file:</source>
          <target state="translated">Perl 히스토리는 변환에서 포착되지 않은 한 가지 실수를 포함합니다. 병합은 실제로 병합이 발생하지 않은 blead와 maint-5.10 사이의 히스토리에 기록되었습니다. git의 특성으로 인해 이제는 공용 저장소에서 수정할 수 없습니다. &lt;code&gt;.git/info/grafts&lt;/code&gt; 파일에 다음 줄을 추가하여이 잘못된 병합을 로컬에서 제거 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="06ded168a76972d517d9136275d2690412f2929f" translate="yes" xml:space="preserve">
          <source>The perl message comes out with &quot;Perl&quot; in front. The &lt;code&gt;BEGIN&lt;/code&gt; block works at compile time so all of the compilation errors and warnings get the &quot;Perl:&quot; prefix too.</source>
          <target state="translated">펄 메시지는 &quot;Perl&quot;과 함께 나옵니다. 은 &lt;code&gt;BEGIN&lt;/code&gt; 컴파일 오류 및 경고의 모두가 얻을 수 있도록 컴파일시에 블록 작품을 &quot;펄 :&quot;접두사를 너무.</target>
        </trans-unit>
        <trans-unit id="b63df2b573a7b7008051f6d3411e1d7de7dd31b6" translate="yes" xml:space="preserve">
          <source>The perl source is in a git repository. You can clone the repository with the following command:</source>
          <target state="translated">펄 소스는 자식 저장소에 있습니다. 다음 명령을 사용하여 저장소를 복제 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c5f10541bc3ed7ff03899b584c515233e642fba7" translate="yes" xml:space="preserve">
          <source>The perl tie function associates a variable with an object that implements the various GET, SET, etc methods. To perform the equivalent of the perl tie function from an XSUB, you must mimic this behaviour. The code below carries out the necessary steps -- firstly it creates a new hash, and then creates a second hash which it blesses into the class which will implement the tie methods. Lastly it ties the two hashes together, and returns a reference to the new tied hash. Note that the code below does NOT call the TIEHASH method in the MyTie class - see &lt;a href=&quot;#Calling-Perl-Routines-from-within-C-Programs&quot;&gt;&quot;Calling Perl Routines from within C Programs&quot;&lt;/a&gt; for details on how to do this.</source>
          <target state="translated">Perl tie 함수는 다양한 GET, SET 등의 메서드를 구현하는 개체와 변수를 연결합니다. XSUB에서 펄 타이 기능과 동일한 기능을 수행하려면이 동작을 모방해야합니다. 아래 코드는 필요한 단계를 수행합니다. 먼저 새 해시를 만든 다음 tie 메서드를 구현할 클래스에 축복하는 두 번째 해시를 만듭니다. 마지막으로 두 해시를 함께 연결하고 새로운 연결 해시에 대한 참조를 반환합니다. 아래 코드는 MyTie 클래스에서 TIEHASH 메서드를 호출하지 않습니다 .이를 수행하는 방법에 대한 자세한 내용은 &lt;a href=&quot;#Calling-Perl-Routines-from-within-C-Programs&quot;&gt;&quot;C 프로그램 내에서 Perl 루틴 호출&quot;&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="327d340c9d37adf78ea3fa44d3b1c6e9e8b77c71" translate="yes" xml:space="preserve">
          <source>The perl tie function associates a variable with an object that implements the various GET, SET, etc methods. To perform the equivalent of the perl tie function from an XSUB, you must mimic this behaviour. The code below carries out the necessary steps -- firstly it creates a new hash, and then creates a second hash which it blesses into the class which will implement the tie methods. Lastly it ties the two hashes together, and returns a reference to the new tied hash. Note that the code below does NOT call the TIEHASH method in the MyTie class - see &lt;a href=&quot;#Calling-Perl-Routines-from-within-C-Programs&quot;&gt;Calling Perl Routines from within C Programs&lt;/a&gt; for details on how to do this.</source>
          <target state="translated">perl tie 함수는 변수를 다양한 GET, SET 등 메소드를 구현하는 오브젝트와 연관시킵니다. XSUB에서 perl tie 기능과 동등한 기능을 수행하려면이 동작을 모방해야합니다. 아래 코드는 필요한 단계를 수행합니다. 먼저 새 해시를 만든 다음 두 번째 해시를 만들어 클래스에 축복하여 tie 메서드를 구현합니다. 마지막으로 두 해시를 함께 묶고 새로운 묶인 해시에 대한 참조를 반환합니다. 아래 코드는 MyTie 클래스에서 TIEHASH 메소드를 호출하지 않습니다 .이를 수행하는 방법에 대한 자세한 내용은 &lt;a href=&quot;#Calling-Perl-Routines-from-within-C-Programs&quot;&gt;C 프로그램 내에서 Perl 루틴 호출을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="123c31a7a632081aa07f5ab58c14ca27dc4643f2" translate="yes" xml:space="preserve">
          <source>The perl visible name of the XS subroutine generated which will return the constants. The default is &lt;code&gt;constant&lt;/code&gt; .</source>
          <target state="translated">상수를 리턴 할 생성 된 XS 서브 루틴의 perl 표시 이름. 기본값은 &lt;code&gt;constant&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="be6633f7068d6499b516b1dff2ff6cfb89ba5f0c" translate="yes" xml:space="preserve">
          <source>The perl visible name of the XS subroutine generated which will return the constants. The default is &lt;code&gt;constant&lt;/code&gt;.</source>
          <target state="translated">상수를 반환하는 생성 된 XS 서브 루틴의 Perl 표시 이름입니다. 기본값은 &lt;code&gt;constant&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="87baa838c319b67b0a259076dbfb27270de34c58" translate="yes" xml:space="preserve">
          <source>The perl-mvs@perl.org list is for discussion of porting issues as well as general usage issues for all EBCDIC Perls. Send a message body of &quot;subscribe perl-mvs&quot; to majordomo@perl.org.</source>
          <target state="translated">perl-mvs@perl.org 목록은 모든 EBCDIC Perls의 일반적인 사용 문제뿐만 아니라 이식 문제에 대한 토론을위한 것입니다. &quot;subscribe perl-mvs&quot;메시지 본문을 majordomo@perl.org로 보내십시오.</target>
        </trans-unit>
        <trans-unit id="5ba3dea55a126a532be4f9eaeca0422de96d0827" translate="yes" xml:space="preserve">
          <source>The perl5-changes mailing list receives a copy of each patch that gets submitted to the maintenance and development branches of the perl repository. See &lt;a href=&quot;http://lists.perl.org/list/perl5-changes.html&quot;&gt;http://lists.perl.org/list/perl5-changes.html&lt;/a&gt; for subscription and archive information.</source>
          <target state="translated">perl5 변경 메일 링리스트는 perl 저장소의 유지 보수 및 개발 브랜치에 제출되는 각 패치의 사본을 수신합니다. 가입 및 보관 정보는 &lt;a href=&quot;http://lists.perl.org/list/perl5-changes.html&quot;&gt;http://lists.perl.org/list/perl5-changes.html&lt;/a&gt; 을 참조 하십시오 .</target>
        </trans-unit>
        <trans-unit id="7ba06e1bf85435dc89a1bc7a3e1228003027ef95" translate="yes" xml:space="preserve">
          <source>The perl5-changes mailing list receives a copy of each patch that gets submitted to the maintenance and development branches of the perl repository. See &lt;a href=&quot;https://lists.perl.org/list/perl5-changes.html&quot;&gt;https://lists.perl.org/list/perl5-changes.html&lt;/a&gt; for subscription and archive information.</source>
          <target state="translated">perl5-changes 메일 링리스트는 perl 저장소의 유지 보수 및 개발 브랜치에 제출되는 각 패치의 사본을받습니다. 구독 및 아카이브 정보는 &lt;a href=&quot;https://lists.perl.org/list/perl5-changes.html&quot;&gt;https://lists.perl.org/list/perl5-changes.html&lt;/a&gt; 을 참조 하십시오 .</target>
        </trans-unit>
        <trans-unit id="9c029dc7e52d0d0d6369cc3ff0e62686a113c165" translate="yes" xml:space="preserve">
          <source>The perl5-porters (p5p) mailing list is where the Perl standard distribution is maintained and developed. The people who maintain Perl are also referred to as the &quot;Perl 5 Porters&quot;, &quot;p5p&quot; or just the &quot;porters&quot;.</source>
          <target state="translated">Perl5 포터 (p5p) 메일 링리스트는 Perl 표준 배포가 유지되고 개발되는 곳입니다. Perl을 유지 관리하는 사람들은 &quot;Perl 5 Porters&quot;, &quot;p5p&quot;또는 &quot;porter&quot;라고도합니다.</target>
        </trans-unit>
        <trans-unit id="3a8b72ced5fe1018b53d36c163e0f112a1621d18" translate="yes" xml:space="preserve">
          <source>The perlXYZ.sis includes only the Perl DLL: to create an additional SIS file which includes some of the standard (pure) Perl libraries, issue the command</source>
          <target state="translated">perlXYZ.sis에는 Perl DLL 만 포함되어 있습니다. 일부 표준 (순수) Perl 라이브러리를 포함하는 추가 SIS 파일을 생성하려면 다음 명령을 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="8239507ba48e88fe2cac6b5f08faa6b68602a3e2" translate="yes" xml:space="preserve">
          <source>The perlapp.sis (11 kB -&amp;gt; 16 kB) will be built in the symbian subdirectory, but a copy will also be made to the main directory.</source>
          <target state="translated">perlapp.sis (11kB-&amp;gt; 16kB)는 symbian 하위 디렉토리에 빌드되지만 주 디렉토리에도 복사본이 만들어집니다.</target>
        </trans-unit>
        <trans-unit id="55339a112f571a65cc173aaae9b60118d4926fb7" translate="yes" xml:space="preserve">
          <source>The perlbug program will ask you a few questions about your email address and the patch you're submitting. Once you've answered them it will submit your patch via email.</source>
          <target state="translated">perlbug 프로그램은 귀하의 이메일 주소와 제출 한 패치에 대해 몇 가지 질문을합니다. 응답하면 이메일을 통해 패치를 제출합니다.</target>
        </trans-unit>
        <trans-unit id="a319a07f2540ad16252f1fe55565bcf46c56c4bb" translate="yes" xml:space="preserve">
          <source>The perldoc for utime also has an example that has the same effect as touch(1) on files that</source>
          <target state="translated">utime 용 perldoc에는 파일에 대해 touch (1)과 동일한 효과를 갖는 예제가 있습니다.</target>
        </trans-unit>
        <trans-unit id="ed575d398752b423e73c91acec2e13e6122dc7e1" translate="yes" xml:space="preserve">
          <source>The perlfaq comprises several documents that answer the most commonly asked questions about Perl and Perl programming. It's divided by topic into nine major sections outlined in this document.</source>
          <target state="translated">perlfaq은 Perl 및 Perl 프로그래밍에 관해 가장 자주 묻는 질문에 대한 답변을 제공하는 여러 문서로 구성되어 있습니다. 주제별로이 문서에 요약 된 9 개의 주요 섹션으로 나뉩니다.</target>
        </trans-unit>
        <trans-unit id="bf571460e6819407bba20acb1eb1771f32d393cd" translate="yes" xml:space="preserve">
          <source>The perlfaq is an evolving document. Read the latest version at &lt;a href=&quot;http://learn.perl.org/faq/&quot;&gt;http://learn.perl.org/faq/&lt;/a&gt;. It is also included in the standard Perl distribution.</source>
          <target state="translated">perlfaq은 진화하는 문서입니다. &lt;a href=&quot;http://learn.perl.org/faq/&quot;&gt;http://learn.perl.org/faq/&lt;/a&gt; 에서 최신 버전을 읽으십시오 . 표준 Perl 배포판에도 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="d8ba3c9bbcf37ca492d8ac656f9c49509454f36e" translate="yes" xml:space="preserve">
          <source>The perlpod spec for a Verbatim paragraph is &quot;It should be reproduced exactly...&quot;, which means that the whitespace you've used to indent your verbatim blocks will be preserved in the output. This can be annoying for outputs such as HTML, where that whitespace will remain in front of every line. It's an unfortunate case where syntax is turned into semantics.</source>
          <target state="translated">축 어적 단락에 대한 perlpod 스펙은 &quot;정확히 재현되어야합니다 ...&quot;입니다. 즉, 축약어 블록을 들여 쓰는 데 사용 된 공백이 출력에 보존됩니다. 이것은 공백이 모든 줄 앞에 남아있는 HTML과 같은 출력에 성 가실 수 있습니다. 구문이 의미론으로 바뀌는 불행한 경우입니다.</target>
        </trans-unit>
        <trans-unit id="d320cdc510ba6fe180a797e4852d051df0ce9e8c" translate="yes" xml:space="preserve">
          <source>The perlstyle manual supplied with Perl has many helpful points.</source>
          <target state="translated">Perl과 함께 제공된 perlstyle 매뉴얼에는 많은 유용한 정보가 있습니다.</target>
        </trans-unit>
        <trans-unit id="f61630dfa6a2b75f5a9ee952e22583e2bdae4aef" translate="yes" xml:space="preserve">
          <source>The person whom the &lt;b&gt;operating system&lt;/b&gt; will let do almost anything. Typically your system administrator or someone pretending to be your system administrator. On Unix systems, the &lt;b&gt;root&lt;/b&gt; user. On Windows systems, usually the Administrator user.</source>
          <target state="translated">&lt;b&gt;운영 체제&lt;/b&gt; 가 거의 모든 작업을 수행 할 수 있는 사람 입니다. 일반적으로 시스템 관리자 또는 시스템 관리자 인 사람. 유닉스 시스템에서 &lt;b&gt;루트&lt;/b&gt; 사용자. Windows 시스템에서는 일반적으로 관리자입니다.</target>
        </trans-unit>
        <trans-unit id="4a687dacf6873e351f87d30c48226233e28a0761" translate="yes" xml:space="preserve">
          <source>The pinyin ordering includes some characters that are not CJK Unified Ideographs and can't utilize &lt;code&gt;weightPinyin()&lt;/code&gt; for collation. For them, use &lt;code&gt;entry&lt;/code&gt; instead.</source>
          <target state="translated">병음 순서에는 CJK 통합 표의 문자가 아니고 데이터 정렬에 &lt;code&gt;weightPinyin()&lt;/code&gt; 을 사용할 수없는 일부 문자가 포함됩니다 . 그들을 위해 대신 &lt;code&gt;entry&lt;/code&gt; 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="674e8f557a9263711bdd1bff3bb098f69b9e9b84" translate="yes" xml:space="preserve">
          <source>The pipeline model divides up a task into a series of steps, and passes the results of one step on to the thread processing the next. Each thread does one thing to each piece of data and passes the results to the next thread in line.</source>
          <target state="translated">파이프 라인 모델은 작업을 일련의 단계로 나누고 한 단계의 결과를 다음 단계를 처리하는 스레드로 전달합니다. 각 스레드는 각 데이터 조각에 대해 하나의 작업을 수행하고 결과를 다음 스레드에 줄로 전달합니다.</target>
        </trans-unit>
        <trans-unit id="e5963c8e8de82f4449d7ed9e1e51afdf5f459ee1" translate="yes" xml:space="preserve">
          <source>The pl2pm utility will get you started.</source>
          <target state="translated">pl2pm 유틸리티가 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="1d36c8a340c756f47102c1832b54cb16f13c0c7c" translate="yes" xml:space="preserve">
          <source>The plan (for example, '1..5'), must only come at the beginning or end of the TAP output.</source>
          <target state="translated">계획 (예 : '1..5')은 TAP 출력의 시작 또는 끝에 만 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="b8f929ee511ca422d9eb63d2f4f5d86c27217779" translate="yes" xml:space="preserve">
          <source>The plan event for the subtest</source>
          <target state="translated">하위 테스트를위한 계획 이벤트</target>
        </trans-unit>
        <trans-unit id="4326b3bc4ca816f9708e08eacb7250e5b64a4e86" translate="yes" xml:space="preserve">
          <source>The plugin system in the CPAN shell was introduced in version 2.07 and is still considered experimental.</source>
          <target state="translated">CPAN 쉘의 플러그인 시스템은 버전 2.07에서 도입되었으며 여전히 실험적인 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="b09a69221209bb270cc3034edeb1fb83d92c2242" translate="yes" xml:space="preserve">
          <source>The point of the function is to &quot;seed&quot; the &lt;a href=&quot;#rand-EXPR&quot;&gt;&lt;code&gt;rand&lt;/code&gt;&lt;/a&gt; function so that &lt;a href=&quot;#rand-EXPR&quot;&gt;&lt;code&gt;rand&lt;/code&gt;&lt;/a&gt; can produce a different sequence each time you run your program. When called with a parameter, &lt;a href=&quot;#srand-EXPR&quot;&gt;&lt;code&gt;srand&lt;/code&gt;&lt;/a&gt; uses that for the seed; otherwise it (semi-)randomly chooses a seed. In either case, starting with Perl 5.14, it returns the seed. To signal that your code will work</source>
          <target state="translated">함수의 요점은 &lt;a href=&quot;#rand-EXPR&quot;&gt; &lt;code&gt;rand&lt;/code&gt; &lt;/a&gt; 함수 를 &quot;시드&quot; 하여 프로그램을 실행할 때마다 &lt;a href=&quot;#rand-EXPR&quot;&gt; &lt;code&gt;rand&lt;/code&gt; &lt;/a&gt; 가 다른 시퀀스를 생성 할 수 있도록하는 것 입니다. 매개 변수와 함께 호출되면 &lt;a href=&quot;#srand-EXPR&quot;&gt; &lt;code&gt;srand&lt;/code&gt; &lt;/a&gt; 는이를 시드에 사용합니다. 그렇지 않으면 (반) 무작위로 시드를 선택합니다. 두 경우 모두 Perl 5.14부터 시작하여 시드를 반환합니다. 코드가 작동 함을 알리기 위해</target>
        </trans-unit>
        <trans-unit id="4fc2d017a3ab4b5deac17556464426823c475059" translate="yes" xml:space="preserve">
          <source>The point of the function is to &quot;seed&quot; the &lt;code&gt;&lt;a href=&quot;functions/rand&quot;&gt;rand&lt;/a&gt;&lt;/code&gt; function so that &lt;code&gt;&lt;a href=&quot;functions/rand&quot;&gt;rand&lt;/a&gt;&lt;/code&gt; can produce a different sequence each time you run your program. When called with a parameter, &lt;code&gt;&lt;a href=&quot;functions/srand&quot;&gt;srand&lt;/a&gt;&lt;/code&gt; uses that for the seed; otherwise it (semi-)randomly chooses a seed. In either case, starting with Perl 5.14, it returns the seed. To signal that your code will work</source>
          <target state="translated">함수의 핵심은 &lt;code&gt;&lt;a href=&quot;functions/rand&quot;&gt;rand&lt;/a&gt;&lt;/code&gt; 함수 를 &quot;시드&quot; 하여 프로그램을 실행할 때마다 &lt;code&gt;&lt;a href=&quot;functions/rand&quot;&gt;rand&lt;/a&gt;&lt;/code&gt; 가 다른 순서를 생성 할 수 있도록하는 것 입니다. 매개 변수와 함께 호출되면 &lt;code&gt;&lt;a href=&quot;functions/srand&quot;&gt;srand&lt;/a&gt;&lt;/code&gt; 는 시드에이를 사용합니다. 그렇지 않으면 (반) 임의로 씨앗을 선택합니다. 두 경우 모두 Perl 5.14로 시작하여 시드를 반환합니다. 코드가 작동한다는 신호</target>
        </trans-unit>
        <trans-unit id="2e1f3e31ba6a1b36a8c681657ab8caf017949b14" translate="yes" xml:space="preserve">
          <source>The point of the function is to &quot;seed&quot; the &lt;code&gt;&lt;a href=&quot;rand&quot;&gt;rand&lt;/a&gt;&lt;/code&gt; function so that &lt;code&gt;&lt;a href=&quot;rand&quot;&gt;rand&lt;/a&gt;&lt;/code&gt; can produce a different sequence each time you run your program. When called with a parameter, &lt;code&gt;&lt;a href=&quot;srand&quot;&gt;srand&lt;/a&gt;&lt;/code&gt; uses that for the seed; otherwise it (semi-)randomly chooses a seed. In either case, starting with Perl 5.14, it returns the seed. To signal that your code will work</source>
          <target state="translated">함수의 핵심은 &lt;code&gt;&lt;a href=&quot;rand&quot;&gt;rand&lt;/a&gt;&lt;/code&gt; 함수 를 &quot;시드&quot; 하여 프로그램을 실행할 때마다 &lt;code&gt;&lt;a href=&quot;rand&quot;&gt;rand&lt;/a&gt;&lt;/code&gt; 가 다른 순서를 생성 할 수 있도록하는 것 입니다. 매개 변수와 함께 호출되면 &lt;code&gt;&lt;a href=&quot;srand&quot;&gt;srand&lt;/a&gt;&lt;/code&gt; 는 시드에이를 사용합니다. 그렇지 않으면 (반) 임의로 씨앗을 선택합니다. 두 경우 모두 Perl 5.14로 시작하여 시드를 반환합니다. 코드가 작동한다는 신호</target>
        </trans-unit>
        <trans-unit id="d8e49cca1375307d0cbb7648d543980bc0807cf4" translate="yes" xml:space="preserve">
          <source>The pointer is blessed into a class that is derived from the name of type of the pointer but with all '*' in the name replaced with 'Ptr'.</source>
          <target state="translated">포인터는 포인터 유형의 이름에서 파생되지만 이름의 모든 '*'가 'Ptr'로 바뀐 클래스에 축복이 있습니다.</target>
        </trans-unit>
        <trans-unit id="549bcd1d7ae81c0474487c42c591f283db8f5fed" translate="yes" xml:space="preserve">
          <source>The pointer to the PV of the &lt;code&gt;dsv&lt;/code&gt; is returned.</source>
          <target state="translated">&lt;code&gt;dsv&lt;/code&gt; 의 PV에 대한 포인터 가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="7ab31953e34eba90fc36ab51df0189b64f65aae0" translate="yes" xml:space="preserve">
          <source>The points to note are</source>
          <target state="translated">주목해야 할 점은</target>
        </trans-unit>
        <trans-unit id="c1fdc510fd28f743532d0f8810f2c036e2bf9b84" translate="yes" xml:space="preserve">
          <source>The polar notation (also known as the trigonometric representation) is much more handy for performing multiplications and divisions of complex numbers, whilst the cartesian notation is better suited for additions and subtractions. Real numbers are on the</source>
          <target state="translated">극좌표 표기법 (삼각형 표현이라고도 함)은 복소수의 곱셈과 나눗셈을 수행하는 데 훨씬 더 편리한 반면, 데카르트 표기법은 덧셈과 뺄셈에 더 적합합니다. 실수는</target>
        </trans-unit>
        <trans-unit id="b5ec1158a1165100647b29065f9f5443b0e8eb69" translate="yes" xml:space="preserve">
          <source>The polar style attempts to emphasize arguments like</source>
          <target state="translated">극지 스타일은 다음과 같은 주장을 강조하려고 시도합니다.</target>
        </trans-unit>
        <trans-unit id="69fec36a5f0f42b7b7ddc49268b5d8cea58e3639" translate="yes" xml:space="preserve">
          <source>The popular tool &lt;code&gt;sudo&lt;/code&gt; provides a controlled way for users to be able to run programs as other users. It sanitises the execution environment to some extent, and will avoid the &lt;a href=&quot;#Shebang-Race-Condition&quot;&gt;shebang race condition&lt;/a&gt;. If you don't have the safe version of set-id scripts, then &lt;code&gt;sudo&lt;/code&gt; may be a more convenient way of executing a script as another user than writing a C wrapper would be.</source>
          <target state="translated">인기있는 도구 인 &lt;code&gt;sudo&lt;/code&gt; 는 사용자가 다른 사용자로 프로그램을 실행할 수있는 제어 된 방법을 제공합니다. 그것은 실행 환경을 어느 정도 삭제하고 &lt;a href=&quot;#Shebang-Race-Condition&quot;&gt;shebang 경쟁 조건을&lt;/a&gt; 피할 것 입니다. set-id 스크립트의 안전한 버전이없는 경우 &lt;code&gt;sudo&lt;/code&gt; 는 C 래퍼를 작성하는 것보다 다른 사용자로 스크립트를 실행하는 더 편리한 방법 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9c2c870c4a68cedcedbfdb919f7afe57be993942" translate="yes" xml:space="preserve">
          <source>The port for Win32 was used as a reference.</source>
          <target state="translated">Win32 용 포트가 참조로 사용되었습니다.</target>
        </trans-unit>
        <trans-unit id="e9a7460e24d0700d3e12dc5c76ead4d814126aa5" translate="yes" xml:space="preserve">
          <source>The port of Perl to Mac OS was officially removed as of Perl 5.12, though the last official production release of MacPerl corresponded to Perl 5.6. While Perl 5.10 included the port to Mac OS, ExtUtils::MakeMaker, a core part of Perl's module installation infrastructure officially dropped support for Mac OS in April 2004.</source>
          <target state="translated">Mac OS 로의 Perl 포트는 Perl 5.12에서 공식적으로 제거되었지만 MacPerl의 마지막 공식 프로덕션 릴리스는 Perl 5.6에 해당합니다. Perl 5.10에는 Mac OS에 대한 포트가 포함되어 있지만 Perl 모듈 설치 인프라의 핵심 부분 인 ExtUtils :: MakeMaker는 2004 년 4 월 공식적으로 Mac OS에 대한 지원을 중단했습니다.</target>
        </trans-unit>
        <trans-unit id="9181a3290f36ca81b3bb6720fe9893dc45df567f" translate="yes" xml:space="preserve">
          <source>The port of Perl to to Mac OS was officially removed as of Perl 5.12, though the last official production release of MacPerl corresponded to Perl 5.6. While Perl 5.10 included the port to Mac OS, ExtUtils::MakeMaker, a core part of Perl's module installation infrastructure officially dropped support for Mac OS in April 2004.</source>
          <target state="translated">MacPerl의 마지막 공식 프로덕션 릴리스는 Perl 5.6에 해당하지만 Perl 5.12부터 Perl의 포트는 공식적으로 Perl 5.12에서 제거되었습니다. Perl 5.10에는 Mac OS 포트가 포함되어 있지만 Perl 모듈 설치 인프라의 핵심 부분 인 ExtUtils :: MakeMaker는 2004 년 4 월 Mac OS에 대한 지원을 공식적으로 중단했습니다.</target>
        </trans-unit>
        <trans-unit id="f4180538d74696f5817f3f6feca9a1c65e2c02f2" translate="yes" xml:space="preserve">
          <source>The porters appreciate the time you spent helping to make Perl better. Thank you!</source>
          <target state="translated">포터들은 Perl을 개선하는 데 도움을 준 시간에 감사합니다. 감사합니다!</target>
        </trans-unit>
        <trans-unit id="54bd391c46a02c41cb9ecadecb266d6444c3a53a" translate="yes" xml:space="preserve">
          <source>The portion of the extension provided by the XS code may be connected to the rest of Perl in either of two ways. In the &lt;b&gt;static&lt;/b&gt; configuration, the object code for the extension is linked directly into</source>
          <target state="translated">XS 코드에서 제공하는 확장 부분은 두 가지 방법 중 하나로 Perl의 나머지 부분에 연결될 수 있습니다. 에서 &lt;b&gt;정적&lt;/b&gt; 구성, 확장을위한 오브젝트 코드에 직접 연결되어 있습니다</target>
        </trans-unit>
        <trans-unit id="2605e3cd341c048b0037bbd123fa8ea2ca949be7" translate="yes" xml:space="preserve">
          <source>The position in the file of FILEHANDLE is left unchanged. You may want to call &lt;a href=&quot;#seek-FILEHANDLE%2CPOSITION%2CWHENCE&quot;&gt;seek&lt;/a&gt; before writing to the file.</source>
          <target state="translated">FILEHANDLE 파일의 위치는 변경되지 않습니다. 파일에 쓰기 전에 &lt;a href=&quot;#seek-FILEHANDLE%2CPOSITION%2CWHENCE&quot;&gt;seek&lt;/a&gt; 를 호출 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4c71fa06187e2cb76d45cf6769bdd2d2cbe65fe5" translate="yes" xml:space="preserve">
          <source>The position in the file of FILEHANDLE is left unchanged. You may want to call &lt;a href=&quot;#seek-FILEHANDLE%2cPOSITION%2cWHENCE&quot;&gt;seek&lt;/a&gt; before writing to the file.</source>
          <target state="translated">FILEHANDLE 파일의 위치는 변경되지 않습니다. 파일에 쓰기 전에 &lt;a href=&quot;#seek-FILEHANDLE%2cPOSITION%2cWHENCE&quot;&gt;seek&lt;/a&gt; 를 호출 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="efdfff91986b015ed9943f5eed1ac7ffd6711ca2" translate="yes" xml:space="preserve">
          <source>The possessive forms (new in Perl 5.10) prevent backtracking: what gets matched by a pattern with a possessive quantifier will not be backtracked into, even if that causes the whole match to fail.</source>
          <target state="translated">소유 형태 (Perl 5.10의 새로운 기능)는 역 추적을 방지합니다. 소유 정량화가있는 패턴과 일치하는 항목은 전체 일치가 실패하더라도 역 추적되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5eab19b8b748f65afb0049c25c884441fbae1bc8" translate="yes" xml:space="preserve">
          <source>The possible categories are: &lt;code&gt;:collate&lt;/code&gt; , &lt;code&gt;:ctype&lt;/code&gt; , &lt;code&gt;:messages&lt;/code&gt; , &lt;code&gt;:monetary&lt;/code&gt; , &lt;code&gt;:numeric&lt;/code&gt; , &lt;code&gt;:&lt;a href=&quot;functions/time&quot;&gt;time&lt;/a&gt;&lt;/code&gt; , and the pseudo category &lt;code&gt;:characters&lt;/code&gt; (described below).</source>
          <target state="translated">가능한 범주는 : &lt;code&gt;:collate&lt;/code&gt; , &lt;code&gt;:ctype&lt;/code&gt; , &lt;code&gt;:messages&lt;/code&gt; , &lt;code&gt;:monetary&lt;/code&gt; , &lt;code&gt;:numeric&lt;/code&gt; , &lt;code&gt;:&lt;a href=&quot;functions/time&quot;&gt;time&lt;/a&gt;&lt;/code&gt; 및 pseudo category &lt;code&gt;:characters&lt;/code&gt; 입니다 (아래 설명 참조).</target>
        </trans-unit>
        <trans-unit id="b9cec0c735ea3bb0489e4ea0d12dfd9112e5e476" translate="yes" xml:space="preserve">
          <source>The possible categories are: &lt;code&gt;:collate&lt;/code&gt;, &lt;code&gt;:ctype&lt;/code&gt;, &lt;code&gt;:messages&lt;/code&gt;, &lt;code&gt;:monetary&lt;/code&gt;, &lt;code&gt;:numeric&lt;/code&gt;, &lt;code&gt;:time&lt;/code&gt;, and the pseudo category &lt;code&gt;:characters&lt;/code&gt; (described below).</source>
          <target state="translated">가능한 범주는 : &lt;code&gt;:collate&lt;/code&gt; , &lt;code&gt;:ctype&lt;/code&gt; , &lt;code&gt;:messages&lt;/code&gt; , &lt;code&gt;:monetary&lt;/code&gt; , &lt;code&gt;:numeric&lt;/code&gt; , &lt;code&gt;:time&lt;/code&gt; 및 의사 범주 &lt;code&gt;:characters&lt;/code&gt; (아래 설명)입니다.</target>
        </trans-unit>
        <trans-unit id="00fdb180b333447352b78de9f2313423642a41c9" translate="yes" xml:space="preserve">
          <source>The possible values and flag bits of the MODE parameter are system-dependent; they are available via the standard module &lt;a href=&quot;fcntl&quot;&gt;&lt;code&gt;Fcntl&lt;/code&gt;&lt;/a&gt;. See the documentation of your operating system's &lt;a href=&quot;http://man.he.net/man2/open&quot;&gt;open(2)&lt;/a&gt; syscall to see which values and flag bits are available. You may combine several flags using the &lt;code&gt;|&lt;/code&gt;-operator.</source>
          <target state="translated">MODE 매개 변수의 가능한 값과 플래그 비트는 시스템에 따라 다릅니다. 표준 모듈 &lt;a href=&quot;fcntl&quot;&gt; &lt;code&gt;Fcntl&lt;/code&gt; 을&lt;/a&gt; 통해 사용할 수 있습니다 . 사용 가능한 값과 플래그 비트를 확인하려면 운영 체제의 &lt;a href=&quot;http://man.he.net/man2/open&quot;&gt;open (2)&lt;/a&gt; syscall 설명서를 참조하십시오. &lt;code&gt;|&lt;/code&gt; 를 사용하여 여러 플래그를 결합 할 수 있습니다. -운영자.</target>
        </trans-unit>
        <trans-unit id="d6655e8efe41a46d2438d144ed4d6129c437e80b" translate="yes" xml:space="preserve">
          <source>The possible values and flag bits of the MODE parameter are system-dependent; they are available via the standard module &lt;code&gt;Fcntl&lt;/code&gt; . See the documentation of your operating system's</source>
          <target state="translated">MODE 매개 변수의 가능한 값과 플래그 비트는 시스템에 따라 다릅니다. 그것들은 표준 모듈 &lt;code&gt;Fcntl&lt;/code&gt; 을 통해 사용 가능합니다 . 운영 체제 설명서를 참조하십시오</target>
        </trans-unit>
        <trans-unit id="f5b739ecc638266d58487c7c88c27f4bcc3311ca" translate="yes" xml:space="preserve">
          <source>The possibly inferred link-text; i.e., if there was no real link text, then this is the text that we'll infer in its place. (E.g., for &quot;L&amp;lt;Getopt::Std&amp;gt;&quot;, the inferred link text is &quot;Getopt::Std&quot;.)</source>
          <target state="translated">추정되는 링크 텍스트 즉, 실제 링크 텍스트가없는 경우이 텍스트가 대신 사용됩니다. (예 : &quot;L &amp;lt;Getopt :: Std&amp;gt;&quot;의 경우 유추 링크 텍스트는 &quot;Getopt :: Std&quot;입니다.)</target>
        </trans-unit>
        <trans-unit id="4e5ec7c69ae0bd18f551874e75cc4c912902b3a0" translate="yes" xml:space="preserve">
          <source>The practice of saying, &amp;ldquo;If I had to do it all over, I&amp;rsquo;d do it differently,&amp;rdquo; and then actually going back and doing it all over differently. Mathematically speaking, it&amp;rsquo;s returning from an unsuccessful recursion on a tree of possibilities. Perl backtracks when it attempts to match patterns with a &lt;b&gt;regular expression&lt;/b&gt;, and its earlier attempts don&amp;rsquo;t pan out. See the section &amp;ldquo;The Little Engine That /Couldn(n&amp;rsquo;t)&amp;rdquo; in Camel chapter 5, &amp;ldquo;Pattern Matching&amp;rdquo;.</source>
          <target state="translated">&amp;ldquo;내가해야 할 일이 있으면 다르게 할 것&amp;rdquo;이라고 말하고 실제로 돌아가서 다르게하는 일을합니다. 수학적으로 말하면, 그것은 가능성의 나무에 대한 실패한 재귀에서 돌아옵니다. Perl은 패턴을 &lt;b&gt;정규식&lt;/b&gt; 과 일치 시키려고 시도 할 때 역 추적 하며 이전 시도는 팬 아웃되지 않습니다. Camel 챕터 5,&amp;ldquo;패턴 일치&amp;rdquo;의&amp;ldquo;작은 엔진은 불가능한&amp;rdquo;섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="03599d25f97c0e2d0192955c405d8519204aa81e" translate="yes" xml:space="preserve">
          <source>The practice of shifting an alphabet one or more characters for encipherment dates back thousands of years and was explicitly detailed by Gaius Julius Caesar in his &lt;b&gt;Gallic Wars&lt;/b&gt; text. A single alphabet shift is sometimes referred to as a rotation and the shift amount is given as a number $n after the string 'rot' or &quot;rot$n&quot;. Rot0 and rot26 would designate identity maps on the 26-letter English version of the Latin alphabet. Rot13 has the interesting property that alternate subsequent invocations are identity maps (thus rot13 is its own non-trivial inverse in the group of 26 alphabet rotations). Hence the following is a rot13 encoder and decoder that will work on ASCII and EBCDIC platforms:</source>
          <target state="translated">암호화를 위해 하나 이상의 문자를 알파벳으로 바꾸는 관행은 수천 년 전으로 거슬러 올라가며 Gaius Julius Caesar의 &lt;b&gt;Gallic Wars&lt;/b&gt; 텍스트 에 자세히 설명되어 있습니다. 단일 알파벳 이동은 때때로 회전이라고하며 이동량은 문자열 'rot'또는 &quot;rot $ n&quot;다음에 숫자 $ n으로 제공됩니다. Rot0 및 rot26은 영어 알파벳 26 자의 영어 알파벳으로 된 아이디 맵을 지정합니다. Rot13은 다른 후속 호출이 ID 맵이라는 흥미로운 속성을 가지고 있습니다 (따라서 rot13은 26 개의 알파벳 회전 그룹에서 사소한 역수입니다). 따라서 다음은 ASCII 및 EBCDIC 플랫폼에서 작동하는 rot13 인코더 및 디코더입니다.</target>
        </trans-unit>
        <trans-unit id="a4931fe0eefec05b185de502969d863746246773" translate="yes" xml:space="preserve">
          <source>The pragma &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; vmsish 'status'&lt;/code&gt; makes &lt;code&gt;$?&lt;/code&gt; reflect the actual VMS exit status instead of the default emulation of POSIX status described above. This pragma also disables the conversion of non-zero values to SS$_ABORT when setting &lt;code&gt;$?&lt;/code&gt; in an END block (but zero will still be converted to SS$_NORMAL).</source>
          <target state="translated">프라 그마 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; vmsish 'status'&lt;/code&gt; 수 &lt;code&gt;$?&lt;/code&gt; 위에서 설명한 POSIX 상태의 기본 에뮬레이션 대신 실제 VMS 종료 상태를 반영합니다. 이 pragma는 &lt;code&gt;$?&lt;/code&gt; 를 설정할 때 0이 아닌 값을 SS $ _ABORT로 변환하지 못하게합니다 . END 블록에서 (그러나 0은 여전히 ​​SS $ _NORMAL로 변환됩니다).</target>
        </trans-unit>
        <trans-unit id="91d3ea3fbae8cd7072d27f773df4ade3db8e3a56" translate="yes" xml:space="preserve">
          <source>The pragma &lt;code&gt;use vmsish 'status'&lt;/code&gt; makes &lt;code&gt;$?&lt;/code&gt; reflect the actual VMS exit status instead of the default emulation of POSIX status described above. This pragma also disables the conversion of non-zero values to SS$_ABORT when setting &lt;code&gt;$?&lt;/code&gt; in an END block (but zero will still be converted to SS$_NORMAL).</source>
          <target state="translated">pragma &lt;code&gt;use vmsish 'status'&lt;/code&gt; 사용하여 &lt;code&gt;$?&lt;/code&gt; 만듭니다 . 위에서 설명한 POSIX 상태의 기본 에뮬레이션 대신 실제 VMS 종료 상태를 반영합니다. 이 pragma는 &lt;code&gt;$?&lt;/code&gt; 를 설정할 때 0이 아닌 값을 SS $ _ABORT로 변환하는 것을 비활성화합니다 . END 블록에서 (하지만 0은 여전히 ​​SS $ _NORMAL로 변환됩니다).</target>
        </trans-unit>
        <trans-unit id="36ba59d998f30d35a2800e28be03d01cb711ce6c" translate="yes" xml:space="preserve">
          <source>The pragma was a per script, not a per block lexical. Only the last &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; encoding&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; encoding&lt;/code&gt; mattered, and it affected &lt;b&gt;the whole script&lt;/b&gt;. However, the &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; encoding&lt;/code&gt; pragma was supported and &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; encoding&lt;/code&gt; could appear as many times as you want in a given script (though only the last was effective).</source>
          <target state="translated">pragma는 블록 단위 어휘가 아니라 스크립트 단위입니다. 마지막 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; encoding&lt;/code&gt; 만 또는 &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; encoding&lt;/code&gt; 중요 &lt;a href=&quot;functions/no&quot;&gt;하지 않아&lt;/a&gt;&lt;b&gt; 전체 스크립트에&lt;/b&gt; 영향을 미쳤 &lt;b&gt;습니다&lt;/b&gt; . 그러나 &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; encoding&lt;/code&gt; pragma가 지원되어 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; encoding&lt;/code&gt; 으며 주어진 스크립트에서 원하는만큼 인코딩 이 나타날 수 있습니다 (마지막 스크립트 만 효과적 임).</target>
        </trans-unit>
        <trans-unit id="9e7b1da1b87c8f47d3de1bab74d0b204e260e393" translate="yes" xml:space="preserve">
          <source>The pragma was a per script, not a per block lexical. Only the last &lt;code&gt;use encoding&lt;/code&gt; or &lt;code&gt;no encoding&lt;/code&gt; mattered, and it affected &lt;b&gt;the whole script&lt;/b&gt;. However, the &lt;code&gt;no encoding&lt;/code&gt; pragma was supported and &lt;code&gt;use encoding&lt;/code&gt; could appear as many times as you want in a given script (though only the last was effective).</source>
          <target state="translated">pragma는 블록 단위 어휘가 아니라 스크립트 단위였습니다. 마지막 &lt;code&gt;use encoding&lt;/code&gt; 또는 &lt;code&gt;no encoding&lt;/code&gt; 중요 하지 않았 &lt;b&gt;으며 전체 스크립트에&lt;/b&gt; 영향을 미쳤 &lt;b&gt;습니다&lt;/b&gt; . 그러나 &lt;code&gt;no encoding&lt;/code&gt; pragma가 지원되었으며 &lt;code&gt;use encoding&lt;/code&gt; 은 주어진 스크립트에서 원하는만큼 여러 번 나타날 수 있습니다 (마지막 만 효과적 임).</target>
        </trans-unit>
        <trans-unit id="f8b4d970b42fbff322fe3d169272f393cc128f89" translate="yes" xml:space="preserve">
          <source>The pragmas &lt;a href=&quot;../bignum&quot;&gt;bignum&lt;/a&gt;, &lt;a href=&quot;../bigint&quot;&gt;bigint&lt;/a&gt; and &lt;a href=&quot;../bigrat&quot;&gt;bigrat&lt;/a&gt; also might be of interest because they solve the autoupgrading/downgrading issue, at least partly.</source>
          <target state="translated">pragmas &lt;a href=&quot;../bignum&quot;&gt;bignum&lt;/a&gt; , &lt;a href=&quot;../bigint&quot;&gt;bigint&lt;/a&gt; 및&lt;a href=&quot;../bigrat&quot;&gt; bigrat&lt;/a&gt; 도 자동 업그레이드 / 다운 그레이드 문제를 적어도 부분적으로 해결하기 때문에 관심이있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="76569ddba56c9f99056592d21ac1b2ff490f26ec" translate="yes" xml:space="preserve">
          <source>The pragmas &lt;a href=&quot;bignum&quot;&gt;bignum&lt;/a&gt;, &lt;a href=&quot;bigint&quot;&gt;bigint&lt;/a&gt; and &lt;a href=&quot;bigrat&quot;&gt;bigrat&lt;/a&gt; also might be of interest because they solve the autoupgrading/downgrading issue, at least partly.</source>
          <target state="translated">pragma &lt;a href=&quot;bignum&quot;&gt;bignum&lt;/a&gt; , &lt;a href=&quot;bigint&quot;&gt;bigint&lt;/a&gt; 및 &lt;a href=&quot;bigrat&quot;&gt;bigrat&lt;/a&gt; 는 자동 업그레이드 / 다운 그레이드 문제를 적어도 부분적으로 해결하기 때문에 관심이있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="984c1d7b1bad11977f9a25ba621b51c787c8e6c4" translate="yes" xml:space="preserve">
          <source>The preamble added to each output file is rather verbose, and most of it is only necessary in the presence of non-ASCII characters. It would ideally be nice if all of those definitions were only output if needed, perhaps on the fly as the characters are used.</source>
          <target state="translated">각 출력 파일에 추가 된 프리앰블은 다소 장황하며 대부분 ASCII가 아닌 문자가있는 경우에만 필요합니다. 문자가 사용될 때 즉석에서 모든 정의가 필요한 경우에만 출력되는 것이 이상적입니다.</target>
        </trans-unit>
        <trans-unit id="45357f49e477501b84ee9e2077b2244c8a2bb54d" translate="yes" xml:space="preserve">
          <source>The preamble code for the class is as follows:</source>
          <target state="translated">클래스의 프리앰블 코드는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b4c4542a57f99c1f10f3ac073718f1821e067ea0" translate="yes" xml:space="preserve">
          <source>The preference of the &lt;b&gt;regular expression&lt;/b&gt; engine to match the leftmost occurrence of a &lt;b&gt;pattern&lt;/b&gt;, then given a position at which a match will occur, the preference for the longest match (presuming the use of a &lt;b&gt;greedy&lt;/b&gt; quantifier). See Camel chapter 5, &amp;ldquo;Pattern Matching&amp;rdquo; for</source>
          <target state="translated">선호의 &lt;b&gt;정규 표현&lt;/b&gt; 엔진은 가장 왼쪽 발생 일치 &lt;b&gt;패턴을&lt;/b&gt; 다음 일치가 발생하는 위치는 가장 긴 매치에 대한 선호도 (a 사용 추정 주어진 &lt;b&gt;욕심&lt;/b&gt; 정량 참조). 자세한 내용은 Camel 5 장 &quot;패턴 일치&quot;를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="fb28a274f1049ea39bf5f7992f63f38b064b26ab" translate="yes" xml:space="preserve">
          <source>The preferred way to do this is to declare a plan when you &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; Test::More&lt;/code&gt; .</source>
          <target state="translated">이를 위해 선호되는 방법은 &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; Test::More&lt;/code&gt; 를 &lt;a href=&quot;../functions/use&quot;&gt;사용할&lt;/a&gt; 때 계획을 선언하는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="5006ab06a26ab8e5eca93c03d0291151f3f3136d" translate="yes" xml:space="preserve">
          <source>The preferred way to do this is to declare a plan when you &lt;code&gt;use Test::More&lt;/code&gt;.</source>
          <target state="translated">이를 수행하는 가장 좋은 방법은 &lt;code&gt;use Test::More&lt;/code&gt; 를 사용할 때 계획을 선언하는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="a070b02ec3ff7789ebf48e13bc147cc73129be84" translate="yes" xml:space="preserve">
          <source>The prefix specified by &lt;code&gt;$Data::Dumper::Varname&lt;/code&gt; will be used with a numeric suffix if the name for a value is undefined.</source>
          <target state="translated">&lt;code&gt;$Data::Dumper::Varname&lt;/code&gt; 지정된 접두어 는 값 이름이 정의되지 않은 경우 숫자 접미사와 함께 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="47b994ba12e424b0e632ed96c89a1498fbc470f8" translate="yes" xml:space="preserve">
          <source>The presence of the word &quot;FATAL&quot; in the category list will escalate warnings in those categories into fatal errors in that lexical scope.</source>
          <target state="translated">범주 목록에 &quot;FATAL&quot;이라는 단어가 있으면 해당 범주의 경고가 해당 어휘 범위에서 치명적인 오류로 에스컬레이션됩니다.</target>
        </trans-unit>
        <trans-unit id="7069f5b0b1dc1568e108cd084477a400c3f8668e" translate="yes" xml:space="preserve">
          <source>The previous assignments are exactly equivalent to</source>
          <target state="translated">이전 과제는 정확히</target>
        </trans-unit>
        <trans-unit id="131e26e34a6a280e8d155fa06c2fe106438c82bd" translate="yes" xml:space="preserve">
          <source>The previous behavior of putting the errors (converted to POSIX-style &lt;code&gt;E*&lt;/code&gt; error codes since Perl 5.20.0) into &lt;code&gt;$!&lt;/code&gt; was buggy due to the non-equivalence of like-named Winsock and POSIX error constants, a relationship between which has unfortunately been established in one way or another since Perl 5.8.0.</source>
          <target state="translated">오류 ( Perl 5.20.0 이후 POSIX 스타일 &lt;code&gt;E*&lt;/code&gt; 오류 코드 로 변환 됨 )를 &lt;code&gt;$!&lt;/code&gt; 같은 이름의 Winsock 및 POSIX 오류 상수가 동일하지 않아 버그가 발생했습니다.이 관계는 안타깝게도 Perl 5.8.0 이후로 어떤 방식 으로든 확립되었습니다.</target>
        </trans-unit>
        <trans-unit id="8d4bba88bb17e91a3967206974b895243970981e" translate="yes" xml:space="preserve">
          <source>The previous example was not particularly useful. To make it more general purpose we will make use of the context data and allow any arbitrary</source>
          <target state="translated">이전 예제는 특별히 유용하지 않았습니다. 보다 일반적인 목적으로 컨텍스트 데이터를 사용하고 임의의</target>
        </trans-unit>
        <trans-unit id="e9b3a0712244fd40d4ef0fb4f6b05e3de06f443f" translate="yes" xml:space="preserve">
          <source>The previous paragraph is applicable verbatim to tied hash access using the &lt;code&gt;hv_store&lt;/code&gt; and &lt;code&gt;hv_store_ent&lt;/code&gt; functions as well.</source>
          <target state="translated">이전 단락은 &lt;code&gt;hv_store&lt;/code&gt; 및 &lt;code&gt;hv_store_ent&lt;/code&gt; 함수를 있습니다.</target>
        </trans-unit>
        <trans-unit id="dd2b650563ddd2d2b6e29ef9f64d0b20b2f5e086" translate="yes" xml:space="preserve">
          <source>The previous section (introduced by a &lt;code&gt;=head&lt;/code&gt; command) does not contain any text. This usually indicates that something is missing. Note: A &lt;code&gt;=head1&lt;/code&gt; followed immediately by &lt;code&gt;=head2&lt;/code&gt; does not trigger this warning.</source>
          <target state="translated">이전 섹션 ( &lt;code&gt;=head&lt;/code&gt; 명령으로 소개 )에는 텍스트가 없습니다. 이것은 대개 무언가 빠진 것을 나타냅니다. 참고 : A &lt;code&gt;=head1&lt;/code&gt; 바로 뒤에 &lt;code&gt;=head2&lt;/code&gt; 는이 경고를 트리거하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b2d4d760a41ac2c4684274cd24041bdb5438342a" translate="yes" xml:space="preserve">
          <source>The previous section (introduced by a &lt;code&gt;=head&lt;/code&gt; command) does not contain any valid content. This usually indicates that something is missing. Note: A &lt;code&gt;=head1&lt;/code&gt; followed immediately by &lt;code&gt;=head2&lt;/code&gt; does not trigger this warning.</source>
          <target state="translated">&lt;code&gt;=head&lt;/code&gt; 명령으로 도입 된 이전 섹션 에는 유효한 내용이 포함되어 있지 않습니다. 이것은 일반적으로 무언가가 누락되었음을 나타냅니다. 참고 : &lt;code&gt;=head1&lt;/code&gt; 다음에 바로 &lt;code&gt;=head2&lt;/code&gt; 가 오면 이 경고가 트리거되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="186c5466a670230e882670fbcd9b5aa0c0353eb4" translate="yes" xml:space="preserve">
          <source>The previous step created</source>
          <target state="translated">이전 단계가 생성되었습니다</target>
        </trans-unit>
        <trans-unit id="d900c388659851ed663901ca396af85f982c5cba" translate="yes" xml:space="preserve">
          <source>The primary cause of the 'dlopen: stub interception failed' message is that the LD_LIBRARY_PATH environment variable includes a directory which is a symlink to /usr/lib (such as /lib). See &lt;a href=&quot;#LD_LIBRARY_PATH&quot;&gt;&quot;LD_LIBRARY_PATH&quot;&lt;/a&gt; above.</source>
          <target state="translated">'dlopen : stub interception failed'메시지의 주요 원인은 LD_LIBRARY_PATH 환경 변수에 / usr / lib (예 : / lib)에 대한 심볼릭 링크 인 디렉토리가 포함되어 있기 때문입니다. 위의 &lt;a href=&quot;#LD_LIBRARY_PATH&quot;&gt;&quot;LD_LIBRARY_PATH&quot;를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="340b1d36d10dcf0bc3c98148a5a96864b33866c8" translate="yes" xml:space="preserve">
          <source>The primary cause of the 'dlopen: stub interception failed' message is that the LD_LIBRARY_PATH environment variable includes a directory which is a symlink to /usr/lib (such as /lib). See &lt;a href=&quot;#LD_LIBRARY_PATH&quot;&gt;LD_LIBRARY_PATH&lt;/a&gt; above.</source>
          <target state="translated">'dlopen : stub interception failed'메시지의 주요 원인은 LD_LIBRARY_PATH 환경 변수에 / usr / lib에 대한 심볼릭 링크 디렉토리 (예 : / lib)가 포함되어 있기 때문입니다. 위의 &lt;a href=&quot;#LD_LIBRARY_PATH&quot;&gt;LD_LIBRARY_PATH를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="6b0f3d276de0b395d904df1ee65d02fbb91e800c" translate="yes" xml:space="preserve">
          <source>The primary purpose of this module is to provide streaming write access to zip files and buffers. It is not a general-purpose file archiver. If that is what you want, check out &lt;code&gt;Archive::Zip&lt;/code&gt; .</source>
          <target state="translated">이 모듈의 주요 목적은 zip 파일 및 버퍼에 대한 스트리밍 쓰기 액세스를 제공하는 것입니다. 범용 파일 아카이버가 아닙니다. 이것이 원하는 경우 &lt;code&gt;Archive::Zip&lt;/code&gt; 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="7109b8aae18759607febf6d98f672f7929c0c0ad" translate="yes" xml:space="preserve">
          <source>The primary purpose of this module is to provide streaming write access to zip files and buffers. It is not a general-purpose file archiver. If that is what you want, check out &lt;code&gt;Archive::Zip&lt;/code&gt; or &lt;code&gt;Archive::Zip::SimpleZip&lt;/code&gt;.</source>
          <target state="translated">이 모듈의 주요 목적은 zip 파일 및 버퍼에 대한 스트리밍 쓰기 액세스를 제공하는 것입니다. 범용 파일 아카이버가 아닙니다. 이것이 원하는 경우 &lt;code&gt;Archive::Zip&lt;/code&gt; 또는 &lt;code&gt;Archive::Zip::SimpleZip&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3562a709266ee6938735493658a732dcdd3f50d6" translate="yes" xml:space="preserve">
          <source>The primary reference for Zip files is the &quot;appnote&quot; document available at &lt;a href=&quot;http://www.pkware.com/documents/casestudies/APPNOTE.TXT&quot;&gt;http://www.pkware.com/documents/casestudies/APPNOTE.TXT&lt;/a&gt;.</source>
          <target state="translated">Zip 파일의 기본 참조는 &lt;a href=&quot;http://www.pkware.com/documents/casestudies/APPNOTE.TXT&quot;&gt;http://www.pkware.com/documents/casestudies/APPNOTE.TXT&lt;/a&gt; 에서 사용할 수있는 &quot;appnote&quot;문서 입니다.</target>
        </trans-unit>
        <trans-unit id="adaddbe76e40b85855bdb3acd3e478586223f423" translate="yes" xml:space="preserve">
          <source>The primary reference for gzip files is RFC 1952 &lt;a href=&quot;http://www.faqs.org/rfcs/rfc1952.html&quot;&gt;http://www.faqs.org/rfcs/rfc1952.html&lt;/a&gt;</source>
          <target state="translated">gzip 파일의 기본 참조는 RFC 1952 &lt;a href=&quot;http://www.faqs.org/rfcs/rfc1952.html&quot;&gt;http://www.faqs.org/rfcs/rfc1952.html입니다.&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="bc24d550b4fe8851d0897e687949d42067e8b5a9" translate="yes" xml:space="preserve">
          <source>The primary reference for zip files is the &quot;appnote&quot; document available at &lt;a href=&quot;http://www.pkware.com/documents/casestudies/APPNOTE.TXT&quot;&gt;http://www.pkware.com/documents/casestudies/APPNOTE.TXT&lt;/a&gt;</source>
          <target state="translated">zip 파일에 대한 기본 참조는 &lt;a href=&quot;http://www.pkware.com/documents/casestudies/APPNOTE.TXT&quot;&gt;http://www.pkware.com/documents/casestudies/APPNOTE.TXT&lt;/a&gt; 에서 사용할 수있는 &quot;appnote&quot;문서입니다 .</target>
        </trans-unit>
        <trans-unit id="1bcb3725358ae123bceedddb8d71ef7119024583" translate="yes" xml:space="preserve">
          <source>The primary site for bzip2 is &lt;a href=&quot;http://www.bzip.org&quot;&gt;http://www.bzip.org&lt;/a&gt;.</source>
          <target state="translated">bzip2의 기본 사이트는 &lt;a href=&quot;http://www.bzip.org&quot;&gt;http://www.bzip.org&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="0d840d1ff084fc0827d16e21e7b3094c84c9a7a3" translate="yes" xml:space="preserve">
          <source>The primary site for gzip is</source>
          <target state="translated">gzip의 기본 사이트는</target>
        </trans-unit>
        <trans-unit id="e859dd2ba7bc9bbaa39a1807494221205b0a4770" translate="yes" xml:space="preserve">
          <source>The primary site for gzip is &lt;a href=&quot;http://www.gzip.org&quot;&gt;http://www.gzip.org&lt;/a&gt;.</source>
          <target state="translated">gzip의 기본 사이트는 &lt;a href=&quot;http://www.gzip.org&quot;&gt;http://www.gzip.org&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="76b9d6c85592a8675b44ceb172e5fcc460f2a10f" translate="yes" xml:space="preserve">
          <source>The primary site for the</source>
          <target state="translated">의 기본 사이트</target>
        </trans-unit>
        <trans-unit id="dff39311adfb064fbb523d321b7e4b3dbea2499f" translate="yes" xml:space="preserve">
          <source>The primary site for the bzip2 program is</source>
          <target state="translated">bzip2 프로그램의 기본 사이트는</target>
        </trans-unit>
        <trans-unit id="6d5111f3cd60b1576c60bc8b7e186e70a9cf368f" translate="yes" xml:space="preserve">
          <source>The primary site for the bzip2 program is &lt;a href=&quot;https://sourceware.org/bzip2/&quot;&gt;https://sourceware.org/bzip2/&lt;/a&gt;.</source>
          <target state="translated">bzip2 프로그램의 기본 사이트는 &lt;a href=&quot;https://sourceware.org/bzip2/&quot;&gt;https://sourceware.org/bzip2/&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="20a7ebabe8aa28f193ee803e7dabf5b8ae97c28d" translate="yes" xml:space="preserve">
          <source>The principal value of the arc tangent of y/x</source>
          <target state="translated">y / x의 아크 탄젠트의 주요 값</target>
        </trans-unit>
        <trans-unit id="c3a6a975854cac68d0d2fce1f652f0011a15276f" translate="yes" xml:space="preserve">
          <source>The principle is that the number of objects found influences how an item is displayed. If the search finds one item, the result is displayed with the rather verbose method &lt;code&gt;as_string&lt;/code&gt; , but if more than one is found, each object is displayed with the terse method &lt;code&gt;as_glimpse&lt;/code&gt; .</source>
          <target state="translated">발견 된 객체의 수는 항목 표시 방법에 영향을줍니다. 검색에서 하나의 항목을 찾으면 결과는 다소 장황한 메소드 인 &lt;code&gt;as_string&lt;/code&gt; 으로 표시 되지만 둘 이상의 항목을 찾으면 각 오브젝트는 간단한 메소드 인 &lt;code&gt;as_glimpse&lt;/code&gt; 로 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="febd9a2b7b0ebfb667a62ab220755a864d89456a" translate="yes" xml:space="preserve">
          <source>The print() statement does not add field and record separators unless you set &lt;code&gt;$,&lt;/code&gt; and &lt;code&gt;$\&lt;/code&gt; . You can set $OFS and $ORS if you're using the English module.</source>
          <target state="translated">print () 문은 &lt;code&gt;$,&lt;/code&gt; 및 &lt;code&gt;$\&lt;/code&gt; 를 설정하지 않으면 필드 및 레코드 구분 기호를 추가하지 않습니다 . 영어 모듈을 사용하는 경우 $ OFS 및 $ ORS를 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2da7e391c9fd1ea8ee0cde415f9757d6cf29bace" translate="yes" xml:space="preserve">
          <source>The print() statement does not add field and record separators unless you set &lt;code&gt;$,&lt;/code&gt; and &lt;code&gt;$\&lt;/code&gt;. You can set $OFS and $ORS if you're using the English module.</source>
          <target state="translated">print () 문은 &lt;code&gt;$,&lt;/code&gt; 및 &lt;code&gt;$\&lt;/code&gt; 를 설정하지 않는 한 필드 및 레코드 구분 기호를 추가하지 않습니다 . 영어 모듈을 사용하는 경우 $ OFS 및 $ ORS를 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e38b92f2492beff5f39d922c93e2a6ed6bba00e9" translate="yes" xml:space="preserve">
          <source>The private &lt;code&gt;_installed_file_for_module&lt;/code&gt; method may be replaced with other methods for locating a module in &lt;code&gt;@INC&lt;/code&gt;.</source>
          <target state="translated">private &lt;code&gt;_installed_file_for_module&lt;/code&gt; 메서드는 &lt;code&gt;@INC&lt;/code&gt; 에서 모듈을 찾기위한 다른 메서드로 대체 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="39cbd438adc424d857eb231b91cd98738e10a91c" translate="yes" xml:space="preserve">
          <source>The private data cache will take ownership of a reference to private_sv, much the same way that &lt;code&gt;hv_store()&lt;/code&gt; takes ownership of a reference to the value that you pass it.</source>
          <target state="translated">개인 데이터 캐시는 &lt;code&gt;hv_store()&lt;/code&gt; 가 전달한 값에 대한 참조의 소유권 을 얻는 것과 거의 같은 방식으로 private_sv에 대한 참조의 소유권을 갖 습니다.</target>
        </trans-unit>
        <trans-unit id="7c29fbafe2b5b36ada501a03eca4a2fd699c674d" translate="yes" xml:space="preserve">
          <source>The private object hash keys like &lt;code&gt;$x-&amp;gt;{sign}&lt;/code&gt; may not be changed, but additional keys can be added, like &lt;code&gt;$x-&amp;gt;{_custom}&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;$x-&amp;gt;{sign}&lt;/code&gt; 과 같은 개인용 객체 해시 키는 변경되지 않지만 &lt;code&gt;$x-&amp;gt;{_custom}&lt;/code&gt; 과 같은 추가 키를 추가 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="22731711df90de28382d892b4f249e651429dc6f" translate="yes" xml:space="preserve">
          <source>The private object hash keys like &lt;code&gt;$x-&amp;gt;{sign}&lt;/code&gt; may not be changed, but additional keys can be added, like &lt;code&gt;$x-&amp;gt;{_custom}&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;$x-&amp;gt;{sign}&lt;/code&gt; 과 같은 개인 개체 해시 키는 변경할 수 없지만 &lt;code&gt;$x-&amp;gt;{_custom}&lt;/code&gt; 과 같은 추가 키를 추가 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="660e221c9f99f43f8d3110d11068349758eb697d" translate="yes" xml:space="preserve">
          <source>The private variable is used to save the current locale state, so that the requisite matching call to &lt;a href=&quot;#RESTORE_LC_NUMERIC&quot;&gt;&quot;RESTORE_LC_NUMERIC&quot;&lt;/a&gt; can restore it.</source>
          <target state="translated">개인 변수는 현재 로케일 상태를 저장하는 데 사용되므로 &lt;a href=&quot;#RESTORE_LC_NUMERIC&quot;&gt;&quot;RESTORE_LC_NUMERIC&quot;에&lt;/a&gt; 대한 필수 일치 호출이 이를 복원 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9da35a7db7a9991be43f0a35bab375b2fa2f7661" translate="yes" xml:space="preserve">
          <source>The private variable is used to save the current locale state, so that the requisite matching call to &lt;a href=&quot;#RESTORE_LC_NUMERIC&quot;&gt;RESTORE_LC_NUMERIC&lt;/a&gt; can restore it.</source>
          <target state="translated">개인 변수는 현재 로케일 상태를 저장하는 데 사용되므로 &lt;a href=&quot;#RESTORE_LC_NUMERIC&quot;&gt;RESTORE_LC_NUMERIC에&lt;/a&gt; 대한 필수 일치 호출이 이를 복원 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2ca51914e8f8318dafeffce74323b676d587ba34" translate="yes" xml:space="preserve">
          <source>The private_use feature is experimental</source>
          <target state="translated">private_use 기능은 실험적입니다.</target>
        </trans-unit>
        <trans-unit id="5290ff0dba8c2d4696fae469f418160732641247" translate="yes" xml:space="preserve">
          <source>The problem can be further examined in a roughly equivalent C program:</source>
          <target state="translated">대략 동등한 C 프로그램에서 문제를 추가로 조사 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="13328591f6760dcc09259e6c0b9735e71fa4da38" translate="yes" xml:space="preserve">
          <source>The problem comes in when you take your numbers from something that Perl thinks is a string, such as a command line argument in &lt;code&gt;@ARGV&lt;/code&gt; :</source>
          <target state="translated">&lt;code&gt;@ARGV&lt;/code&gt; 의 명령 행 인수와 같이 Perl이 생각하는 문자열에서 숫자를 가져올 때 문제가 발생합니다 .</target>
        </trans-unit>
        <trans-unit id="2c1b07cc8bfa77fdc4b2aa2cb8ca8cba9947e03f" translate="yes" xml:space="preserve">
          <source>The problem comes in when you take your numbers from something that Perl thinks is a string, such as a command line argument in &lt;code&gt;@ARGV&lt;/code&gt;:</source>
          <target state="translated">문제는 &lt;code&gt;@ARGV&lt;/code&gt; 의 명령 줄 인수와 같이 Perl이 문자열이라고 생각하는 것에서 숫자를 가져올 때 발생합니다 .</target>
        </trans-unit>
        <trans-unit id="cd8bb5622c99567256e6a98501e22410a2a7900d" translate="yes" xml:space="preserve">
          <source>The problem comes when you have, for instance, a string that isn't flagged as UTF-8, and contains a byte sequence that could be UTF-8 -- especially when combining non-UTF-8 and UTF-8 strings.</source>
          <target state="translated">예를 들어 UTF-8로 플래그가 지정되지 않은 문자열이 있고 UTF-8이 될 수있는 바이트 시퀀스가 ​​포함 된 경우 (특히 UTF-8이 아닌 문자열과 UTF-8 문자열을 결합 할 때)에 문제가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="e918e6ad2cf12f5152c6540799f1ea5ccc7d457e" translate="yes" xml:space="preserve">
          <source>The problem exists because the anonymous subroutine being assigned to the &lt;code&gt;*Foo::foo&lt;/code&gt; glob will show up in the call stack as being called &lt;code&gt;__ANON__&lt;/code&gt; and not &lt;code&gt;foo&lt;/code&gt; as you might expect. Since &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next::method&lt;/a&gt;&lt;/code&gt; uses &lt;code&gt;&lt;a href=&quot;functions/caller&quot;&gt;caller&lt;/a&gt;&lt;/code&gt; to find the name of the method it was called in, it will fail in this case.</source>
          <target state="translated">익명 서브 루틴이 할당되고 있기 때문에 문제가 존재 &lt;code&gt;*Foo::foo&lt;/code&gt; 글로브라는 것으로 호출 스택에 표시됩니다 &lt;code&gt;__ANON__&lt;/code&gt; 하지 &lt;code&gt;foo&lt;/code&gt; 는 예상대로. 이후 &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next::method&lt;/a&gt;&lt;/code&gt; 사용하는 &lt;code&gt;&lt;a href=&quot;functions/caller&quot;&gt;caller&lt;/a&gt;&lt;/code&gt; 가 호출 된 메소드의 이름을 찾기 위해,이 경우에 실패합니다.</target>
        </trans-unit>
        <trans-unit id="f6e3278fa9663415debfd4e39d0b068a1659902a" translate="yes" xml:space="preserve">
          <source>The problem exists because the anonymous subroutine being assigned to the &lt;code&gt;*Foo::foo&lt;/code&gt; glob will show up in the call stack as being called &lt;code&gt;__ANON__&lt;/code&gt; and not &lt;code&gt;foo&lt;/code&gt; as you might expect. Since &lt;code&gt;next::method&lt;/code&gt; uses &lt;code&gt;caller&lt;/code&gt; to find the name of the method it was called in, it will fail in this case.</source>
          <target state="translated">&lt;code&gt;*Foo::foo&lt;/code&gt; glob 에 할당되는 익명 서브 루틴이 예상대로 &lt;code&gt;foo&lt;/code&gt; 가 아닌 &lt;code&gt;__ANON__&lt;/code&gt; 으로 호출되는 것으로 호출 스택에 표시 되기 때문에 문제가 발생합니다 . 이후 &lt;code&gt;next::method&lt;/code&gt; 사용하는 &lt;code&gt;caller&lt;/code&gt; 가 호출 된 메소드의 이름을 찾기 위해,이 경우에 실패합니다.</target>
        </trans-unit>
        <trans-unit id="aea1a84a6e43b26958b1598b1f93e9a632b83a16" translate="yes" xml:space="preserve">
          <source>The problem here is that Uid_t might be not only not &lt;code&gt;&lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt;&lt;/code&gt;-wide but it might also be unsigned, in which case large uids would be printed as negative values.</source>
          <target state="translated">여기서 문제는 Uid_t가 &lt;code&gt;&lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt;&lt;/code&gt; - wide 일뿐만 아니라 부호도 없을 수 있다는 것입니다.이 경우 큰 uid는 음수 값으로 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="27a99efdaf6b6471f2df947f1f817dd0e909810c" translate="yes" xml:space="preserve">
          <source>The problem here is that Uid_t might be not only not &lt;code&gt;int&lt;/code&gt;-wide but it might also be unsigned, in which case large uids would be printed as negative values.</source>
          <target state="translated">여기서 문제는 Uid_t가 &lt;code&gt;int&lt;/code&gt; - wide 일뿐만 아니라 unsigned 일 수도 있다는 것입니다.이 경우 큰 uid는 음수 값으로 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="56bc12834cd035d1009997925f3d7abe998a9788" translate="yes" xml:space="preserve">
          <source>The problem here is that both the group named &lt;code&gt;a&lt;/code&gt; and the group named &lt;code&gt;b&lt;/code&gt; are aliases for the group belonging to &lt;code&gt;$1&lt;/code&gt; .</source>
          <target state="translated">여기서 문제는 그룹 둘이라는 점이다 &lt;code&gt;a&lt;/code&gt; 그 그룹의 이름 &lt;code&gt;b&lt;/code&gt; 속하는 그룹의 별칭 &lt;code&gt;$1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b18408c3bf47516e5c9af25c6047a1bd86154733" translate="yes" xml:space="preserve">
          <source>The problem here is that both the group named &lt;code&gt;a&lt;/code&gt; and the group named &lt;code&gt;b&lt;/code&gt; are aliases for the group belonging to &lt;code&gt;$1&lt;/code&gt;.</source>
          <target state="translated">여기서 문제는 그룹 둘이라는 점이다 &lt;code&gt;a&lt;/code&gt; 그 그룹의 이름 &lt;code&gt;b&lt;/code&gt; 속하는 그룹의 별칭 &lt;code&gt;$1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dda9a4d26fe1b0eb3aeffd7cffb748b622bb8f5f" translate="yes" xml:space="preserve">
          <source>The problem is that Perl has both compile-time and run-time warnings. To disable compile-time warnings you need to rewrite the code like this:</source>
          <target state="translated">문제는 Perl에 컴파일 타임과 런타임 경고가 모두 있다는 것입니다. 컴파일 타임 경고를 비활성화하려면 다음과 같이 코드를 다시 작성해야합니다.</target>
        </trans-unit>
        <trans-unit id="000d776ae8231195ffb025ac77c4f425f1c2ff6f" translate="yes" xml:space="preserve">
          <source>The problem is that both &lt;code&gt;rp&lt;/code&gt; and &lt;code&gt;dp&lt;/code&gt; are pointers to the same location in memory! In C, you'd have to remember to malloc() yourself some new memory. In Perl, you'll want to use the array constructor &lt;code&gt;[]&lt;/code&gt; or the hash constructor &lt;code&gt;{}&lt;/code&gt; instead. Here's the right way to do the preceding broken code fragments:</source>
          <target state="translated">문제는 &lt;code&gt;rp&lt;/code&gt; 와 &lt;code&gt;dp&lt;/code&gt; 가 메모리에서 같은 위치를 가리키는 포인터라는 것입니다! C에서는 새로운 메모리를 malloc ()으로 기억해야합니다. Perl에서는 대신 배열 생성자 &lt;code&gt;[]&lt;/code&gt; 또는 해시 생성자 &lt;code&gt;{}&lt;/code&gt; 를 사용하려고합니다 . 앞의 깨진 코드 조각을 수행하는 올바른 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="44e0ee462b8e8a33d77de1117d49fdbd0c841da5" translate="yes" xml:space="preserve">
          <source>The problem is that grep builds a return list, regardless of the context. This means you're making Perl go to the trouble of building a list that you then just throw away. If the list is large, you waste both time and space. If your intent is to iterate over the list, then use a for loop for this purpose.</source>
          <target state="translated">문제는 grep이 컨텍스트에 관계없이 리턴 목록을 작성한다는 것입니다. 이것은 Perl이리스트를 작성하는 데 어려움을 겪고 있다는 것을 의미합니다. 목록이 크면 시간과 공간을 모두 낭비하게됩니다. 의도가 목록을 반복하려는 경우 for 루프를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="6df859dc8cac16c31baff14e80c7d840e1cb3153" translate="yes" xml:space="preserve">
          <source>The problem is that none of these examples are reliable: they depend on the command interpreter. Under Unix, the first two often work. Under DOS, it's entirely possible that neither works. If 4DOS was the command shell, you'd probably have better luck like this:</source>
          <target state="translated">문제는 이러한 예제 중 어느 것도 신뢰할 수 없다는 것입니다. 명령 인터프리터에 따라 다릅니다. 유닉스에서는 처음 두 가지가 종종 작동합니다. DOS에서는 전혀 작동하지 않을 수 있습니다. 4DOS가 명령 쉘인 경우 다음과 같이 운이 좋을 것입니다.</target>
        </trans-unit>
        <trans-unit id="95485cb814321ef14b952e45ddf9a35301af1a5e" translate="yes" xml:space="preserve">
          <source>The problem is that none of this is reliable: it depends on the command and it is entirely possible neither works. If</source>
          <target state="translated">문제는 이것 중 어느 것도 신뢰할 수 없다는 것입니다. 명령에 따라 다르며 전혀 작동하지 않습니다. 만약</target>
        </trans-unit>
        <trans-unit id="88377fbeaf8b4fab35329a7e374ea24a4795a7c5" translate="yes" xml:space="preserve">
          <source>The problem is that this code will always be parsed and executed, even when the debug level set in the logging configuration file is zero. Once the debug() subroutine has been entered, and the internal &lt;code&gt;$debug&lt;/code&gt; variable confirmed to be zero, for example, the message which has been sent in will be discarded and the program will continue. In the example given though, the &lt;code&gt;\%INC&lt;/code&gt; hash will already have been dumped, and the message string constructed, all of which work could be bypassed by a debug variable at the statement level, like this:</source>
          <target state="translated">문제는 로깅 구성 파일에 설정된 디버그 수준이 0 인 경우에도이 코드가 항상 구문 분석되고 실행된다는 것입니다. debug () 서브 루틴이 입력되고 내부 &lt;code&gt;$debug&lt;/code&gt; 변수가 0으로 확인되면, 전송 된 메시지가 삭제되고 프로그램이 계속됩니다. 그러나 주어진 예에서, &lt;code&gt;\%INC&lt;/code&gt; 해시는 이미 덤프되고 메시지 문자열이 구성되며, 모든 작업은 다음과 같이 명령문 레벨에서 디버그 변수에 의해 무시 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="73cae6ed898e3261e96216aa07490bc469dc51e8" translate="yes" xml:space="preserve">
          <source>The problem is that this code would</source>
          <target state="translated">문제는이 코드가</target>
        </trans-unit>
        <trans-unit id="e6af2011607132108daf874aceb7c74f8abf4357" translate="yes" xml:space="preserve">
          <source>The problem is that those double-quotes force stringification--coercing numbers and references into strings--even when you don't want them to be strings. Think of it this way: double-quote expansion is used to produce new strings. If you already have a string, why do you need more?</source>
          <target state="translated">문제는 큰 따옴표가 문자열이되고 싶지 않은 경우에도 문자열과 숫자로의 참조를 강제로 묶는 것입니다. 이런 식으로 생각하십시오 : 큰 따옴표 확장은 새로운 문자열을 생성하는 데 사용됩니다. 이미 줄이 있다면 왜 더 필요한가?</target>
        </trans-unit>
        <trans-unit id="d0f76e9ccc888898fb7c8d297bdf6217c3b3b765" translate="yes" xml:space="preserve">
          <source>The problem is that various structures visible via procfs use off_t, and if you compile with largefile support these change from 32 bits to 64 bits. Thus what you get back from procfs doesn't match up with the structures in perl, resulting in garbage. See proc(4) for further discussion.</source>
          <target state="translated">문제는 procfs를 통해 볼 수있는 다양한 구조가 off_t를 사용하고 큰 파일 지원으로 컴파일하는 경우 이러한 변경 사항을 32 비트에서 64 비트로 변경한다는 것입니다. 따라서 procfs에서 얻은 내용이 perl의 구조와 일치하지 않아 가비지가 발생합니다. 자세한 내용은 proc (4)를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="36b3f29973dcb4084c4233c180d15ad0f5ad2090" translate="yes" xml:space="preserve">
          <source>The problem is the nested indeterminate quantifiers. There are many different ways of partitioning a string of length n between the &lt;code&gt;'+'&lt;/code&gt; and &lt;code&gt;'*'&lt;/code&gt;: one repetition with &lt;code&gt;b+&lt;/code&gt; of length n, two repetitions with the first &lt;code&gt;b+&lt;/code&gt; length k and the second with length n-k, m repetitions whose bits add up to length n,</source>
          <target state="translated">문제는 중첩 된 불확정 수량 자입니다. &lt;code&gt;'+'&lt;/code&gt; 와 &lt;code&gt;'*'&lt;/code&gt; 사이에 길이 n의 문자열을 분할하는 방법에는 여러 가지가 있습니다 . &lt;code&gt;b+&lt;/code&gt; 길이가 n 인 한 번 반복, 첫 번째 &lt;code&gt;b+&lt;/code&gt; 길이가 k 인 두 번 반복 , 길이가 nk 인 두 번째 반복, 비트가 추가되는 m 반복 최대 길이 n,</target>
        </trans-unit>
        <trans-unit id="fc4b1a9098877c5f0dfd053c053f3947a9421580" translate="yes" xml:space="preserve">
          <source>The problem is the nested indeterminate quantifiers. There are many different ways of partitioning a string of length n between the &lt;code&gt;+&lt;/code&gt; and &lt;code&gt;*&lt;/code&gt; : one repetition with &lt;code&gt;b+&lt;/code&gt; of length n, two repetitions with the first &lt;code&gt;b+&lt;/code&gt; length k and the second with length n-k, m repetitions whose bits add up to length n, etc. In fact there are an exponential number of ways to partition a string as a function of its length. A regexp may get lucky and match early in the process, but if there is no match, Perl will try</source>
          <target state="translated">문제는 내포 된 불확정 양자화 기입니다. 사이 길이 n의 스트링을 분할하는 방법에는 여러 가지가있다 &lt;code&gt;+&lt;/code&gt; 및 &lt;code&gt;*&lt;/code&gt; : 하나 반복 &lt;code&gt;b+&lt;/code&gt; 의 길이는 N, 첫 번째와 두 반복 &lt;code&gt;b+&lt;/code&gt; 길이 K와 길이 NK, 그 비트 길이 n까지 추가 m 반복 갖는 제 2 실제로 문자열을 길이의 함수로 분할하는 방법에는 기하 급수적 인 방법이 있습니다. 정규 표현식이 운이 좋으면 프로세스 초기에 일치하지만 일치하는 항목이 없으면 Perl이 시도합니다.</target>
        </trans-unit>
        <trans-unit id="57ef8306dabb66b8a3dd5849936f56c155cd391f" translate="yes" xml:space="preserve">
          <source>The problem is usually that the command interpreters on those systems have rather different ideas about quoting than the Unix shells under which the one-liners were created. On some systems, you may have to change single-quotes to double ones, which you must</source>
          <target state="translated">문제는 일반적으로 해당 시스템의 명령 인터프리터가 단일 라이너가 작성된 Unix 쉘과는 다른 인용 방식에 대한 아이디어를 가지고 있다는 것입니다. 일부 시스템에서는 작은 따옴표를 큰 따옴표로 변경해야 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="814a82003c2ef63857b1187789261eb0a14ef57b" translate="yes" xml:space="preserve">
          <source>The problem with this is that buffering is really going to ruin your day. Even though your &lt;code&gt;$writer&lt;/code&gt; filehandle is auto-flushed so the process on the other end gets your data in a timely manner, you can't usually do anything to force that process to give its data to you in a similarly quick fashion. In this special case, we could actually so, because we gave</source>
          <target state="translated">이것의 문제는 버퍼링이 당신의 하루를 정말로 망칠 것이라는 것입니다. 귀하의 경우에도 &lt;code&gt;$writer&lt;/code&gt; 다른 쪽 끝에 프로세스가 적시에 데이터를 얻을 수 있도록 핸들이 자동 플러시, 당신은 일반적으로 유사하게 빠른 방식으로 당신에게 데이터를 제공하는 해당 프로세스를 강제로 아무것도 할 수 없습니다. 이 특별한 경우에는 실제로 그렇게 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5ee9f00b1299262770f29ccbf33382cfb01278a2" translate="yes" xml:space="preserve">
          <source>The problem with this is that buffering is really going to ruin your day. Even though your &lt;code&gt;Writer&lt;/code&gt; filehandle is auto-flushed so the process on the other end gets your data in a timely manner, you can't usually do anything to force that process to give its data to you in a similarly quick fashion. In this special case, we could actually so, because we gave</source>
          <target state="translated">이것의 문제는 버퍼링이 실제로 하루를 망칠 것입니다. 당신 비록 &lt;code&gt;Writer&lt;/code&gt; 다른 쪽 끝에 프로세스가 적시에 데이터를 얻을 수 있도록 핸들이 자동 플러시, 당신은 일반적으로 유사하게 빠른 방식으로 당신에게 데이터를 제공하는 해당 프로세스를 강제로 아무것도 할 수 없습니다. 이 특별한 경우에 우리는 실제로 그렇게 할 수있었습니다.</target>
        </trans-unit>
        <trans-unit id="f6f3b81b70ac61e4574d6ebcd3e976b1d72049f0" translate="yes" xml:space="preserve">
          <source>The problems of garbage collection and thread safety are both addressed by the function &lt;code&gt;register()&lt;/code&gt; . It registers an object together with any number of hashes. Registry means that when the object dies, an entry in any of the hashes under the reference address of this object will be deleted. This guarantees garbage collection in these hashes. It also means that on thread cloning the object's entries in registered hashes will be replaced with updated entries whose key is the cloned object's reference address. Thus the object-data association becomes thread-safe.</source>
          <target state="translated">가비지 수집 및 스레드 안전성 문제는 &lt;code&gt;register()&lt;/code&gt; 함수로 해결됩니다 . 임의의 수의 해시와 함께 객체를 등록합니다. 레지스트리는 객체가 죽으면이 객체의 참조 주소 아래의 해시 항목이 삭제됨을 의미합니다. 이것은 이러한 해시에 가비지 콜렉션을 보장합니다. 또한 스레드 복제시 등록 된 해시의 객체 항목이 키가 복제 된 객체의 참조 주소 인 업데이트 된 항목으로 대체됨을 의미합니다. 따라서 객체 데이터 연결은 스레드로부터 안전 해집니다.</target>
        </trans-unit>
        <trans-unit id="d49a5cf6f714984f5d4aa1ae27ae4adaa45ad30d" translate="yes" xml:space="preserve">
          <source>The problems of garbage collection and thread safety are both addressed by the function &lt;code&gt;register()&lt;/code&gt;. It registers an object together with any number of hashes. Registry means that when the object dies, an entry in any of the hashes under the reference address of this object will be deleted. This guarantees garbage collection in these hashes. It also means that on thread cloning the object's entries in registered hashes will be replaced with updated entries whose key is the cloned object's reference address. Thus the object-data association becomes thread-safe.</source>
          <target state="translated">가비지 수집 및 스레드 안전성 문제는 모두 &lt;code&gt;register()&lt;/code&gt; 함수에 의해 해결됩니다 . 임의의 수의 해시와 함께 개체를 등록합니다. 레지스트리는 객체가 죽을 때이 객체의 참조 주소 아래에있는 해시의 항목이 삭제됨을 의미합니다. 이렇게하면 이러한 해시에서 가비지 수집이 보장됩니다. ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ 또한 스레드 복제시 등록 된 해시의 개체 항목이 복제 된 개체의 참조 주소 인 업데이트 된 항목으로 대체됨을 의미합니다. 따라서 객체-데이터 연관은 스레드로부터 안전합니다.</target>
        </trans-unit>
        <trans-unit id="4aef2d934929be669275ad225ef041e450d29108" translate="yes" xml:space="preserve">
          <source>The procedure for doing this is roughly as follows (using the example of tonyc's smoke-me branch called win32stat):</source>
          <target state="translated">이 작업을 수행하는 절차는 대략 다음과 같습니다 (win32stat라는 tonyc의 smoke-me 브랜치 예제 사용).</target>
        </trans-unit>
        <trans-unit id="9452ac7ff4d68965b2304a021a3f491d59cd9f05" translate="yes" xml:space="preserve">
          <source>The process ID in which the event was generated.</source>
          <target state="translated">이벤트가 생성 된 프로세스 ID입니다.</target>
        </trans-unit>
        <trans-unit id="95e6fb31b348934a4b1c0d293aa560867eaa2c02" translate="yes" xml:space="preserve">
          <source>The process number of the Perl running this script. Though you</source>
          <target state="translated">이 스크립트를 실행하는 Perl의 프로세스 번호. 당신은</target>
        </trans-unit>
        <trans-unit id="b93ffa0ee1718038fedc8009038c2d7f70371455" translate="yes" xml:space="preserve">
          <source>The process of converting a string to one of the four Unicode &lt;b&gt;casemaps&lt;/b&gt;; in Perl, it is implemented with the &lt;code&gt;&lt;a href=&quot;functions/fc&quot;&gt;fc&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/lc&quot;&gt;lc&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/ucfirst&quot;&gt;ucfirst&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;functions/uc&quot;&gt;uc&lt;/a&gt;&lt;/code&gt; functions.</source>
          <target state="translated">문자열을 4 개의 유니 코드 &lt;b&gt;케이스 맵&lt;/b&gt; 중 하나로 변환하는 프로세스 . Perl에서는 &lt;code&gt;&lt;a href=&quot;functions/fc&quot;&gt;fc&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/lc&quot;&gt;lc&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/ucfirst&quot;&gt;ucfirst&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;functions/uc&quot;&gt;uc&lt;/a&gt;&lt;/code&gt; 함수로 구현됩니다.</target>
        </trans-unit>
        <trans-unit id="7b3ce77cc42e100f56e2fb73208b06058b72b962" translate="yes" xml:space="preserve">
          <source>The process of converting a string to one of the four Unicode &lt;b&gt;casemaps&lt;/b&gt;; in Perl, it is implemented with the &lt;code&gt;fc&lt;/code&gt;, &lt;code&gt;lc&lt;/code&gt;, &lt;code&gt;ucfirst&lt;/code&gt;, and &lt;code&gt;uc&lt;/code&gt; functions.</source>
          <target state="translated">문자열을 네 개의 유니 코드 &lt;b&gt;케이스 맵&lt;/b&gt; 중 하나로 변환하는 프로세스입니다 . Perl에서는 &lt;code&gt;fc&lt;/code&gt; , &lt;code&gt;lc&lt;/code&gt; , &lt;code&gt;ucfirst&lt;/code&gt; 및 &lt;code&gt;uc&lt;/code&gt; 함수로 구현됩니다.</target>
        </trans-unit>
        <trans-unit id="2cf36cd26c284e1c84d9c66a1a4b1fbb69c4ead2" translate="yes" xml:space="preserve">
          <source>The process of determining what method should be used is called &lt;b&gt;method resolution&lt;/b&gt;. What Perl does is look at the object's class first (&lt;code&gt;File::MP3&lt;/code&gt; in this case). If that class defines the method, then that class's version of the method is called. If not, Perl looks at each parent class in turn. For &lt;code&gt;File::MP3&lt;/code&gt; , its only parent is &lt;code&gt;File&lt;/code&gt; . If &lt;code&gt;File::MP3&lt;/code&gt; does not define the method, but &lt;code&gt;File&lt;/code&gt; does, then Perl calls the method in &lt;code&gt;File&lt;/code&gt; .</source>
          <target state="translated">어떤 방법을 사용해야하는지 결정하는 과정을 &lt;b&gt;방법 분석&lt;/b&gt; 이라고 합니다. Perl이하는 일은 객체의 클래스를 먼저 보는 것입니다 ( 이 경우 &lt;code&gt;File::MP3&lt;/code&gt; ). 해당 클래스가 메소드를 정의하면 해당 클래스의 메소드 버전이 호출됩니다. 그렇지 않으면 Perl은 각 상위 클래스를 차례로 봅니다. 를 들어 &lt;code&gt;File::MP3&lt;/code&gt; , 유일한 부모입니다 &lt;code&gt;File&lt;/code&gt; . 경우 &lt;code&gt;File::MP3&lt;/code&gt; 방법을 정의하지 않지만, &lt;code&gt;File&lt;/code&gt; 수행 한 후 펄의 메소드를 호출 &lt;code&gt;File&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2d45b13e98be85d3a3cff56a4de1619efcb5c0e5" translate="yes" xml:space="preserve">
          <source>The process of determining what method should be used is called &lt;b&gt;method resolution&lt;/b&gt;. What Perl does is look at the object's class first (&lt;code&gt;File::MP3&lt;/code&gt; in this case). If that class defines the method, then that class's version of the method is called. If not, Perl looks at each parent class in turn. For &lt;code&gt;File::MP3&lt;/code&gt;, its only parent is &lt;code&gt;File&lt;/code&gt;. If &lt;code&gt;File::MP3&lt;/code&gt; does not define the method, but &lt;code&gt;File&lt;/code&gt; does, then Perl calls the method in &lt;code&gt;File&lt;/code&gt;.</source>
          <target state="translated">어떤 방법을 사용해야하는지 결정하는 과정을 &lt;b&gt;방법 확인&lt;/b&gt; 이라고 합니다. Perl이하는 일은 먼저 객체의 클래스를 보는 것입니다 ( 이 경우 &lt;code&gt;File::MP3&lt;/code&gt; ). 해당 클래스가 메서드를 정의하면 해당 클래스의 메서드 버전이 호출됩니다. 그렇지 않은 경우 Perl은 각 상위 클래스를 차례로 살펴 봅니다. 를 들어 &lt;code&gt;File::MP3&lt;/code&gt; , 유일한 부모입니다 &lt;code&gt;File&lt;/code&gt; . 경우 &lt;code&gt;File::MP3&lt;/code&gt; 방법을 정의하지 않지만, &lt;code&gt;File&lt;/code&gt; 수행 한 후 펄의 메소드를 호출 &lt;code&gt;File&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="080ae8ae51ff51ae8e5ac989879f84eb0a78985b" translate="yes" xml:space="preserve">
          <source>The process of gluing one cat&amp;rsquo;s nose to another cat&amp;rsquo;s tail. Also a similar operation on two &lt;b&gt;strings&lt;/b&gt;.</source>
          <target state="translated">한 고양이의 코를 다른 고양이의 꼬리에 붙이는 과정. 또한 두 &lt;b&gt;문자열&lt;/b&gt; 에서 비슷한 작업을 수행합니다 .</target>
        </trans-unit>
        <trans-unit id="908f91e0beaa0a05d55f4dc47581a39df63d9d61" translate="yes" xml:space="preserve">
          <source>The process of producing a &lt;b&gt;string&lt;/b&gt; representation of an abstract object.</source>
          <target state="translated">추상 객체 의 &lt;b&gt;문자열&lt;/b&gt; 표현 을 생성하는 프로세스입니다 .</target>
        </trans-unit>
        <trans-unit id="3e1e79f73acf8d324572f017b3dffb010974336f" translate="yes" xml:space="preserve">
          <source>The process of trying one alternative, seeing if it matches, and moving on to the next alternative, while going back in the string from where the previous alternative was tried, if it doesn't, is called</source>
          <target state="translated">하나의 대안을 시도하고, 대안이 일치하는지 확인하고, 다음 대안으로 넘어 가면서 이전 대안이 시도 된 곳에서 문자열로 돌아가는 프로세스가 호출되는 프로세스가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="74fa9d2e4258275e6ce9c275f9e0e82d2661aeb2" translate="yes" xml:space="preserve">
          <source>The process of turning source code into a machine-usable form. See &lt;b&gt;compile phase&lt;/b&gt;.</source>
          <target state="translated">소스 코드를 기계가 사용할 수있는 형태로 바꾸는 과정. &lt;b&gt;컴파일 단계를&lt;/b&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="2c86388b6b25502da94ef398d94ba381de4e7acd" translate="yes" xml:space="preserve">
          <source>The program assumes prior understanding of the internal structure of a Zip file. You should have a copy of the Zip APPNOTE file at hand to help understand the output from this program (&lt;a href=&quot;#SEE-ALSO&quot;&gt;&quot;SEE ALSO&quot;&lt;/a&gt; for details).</source>
          <target state="translated">이 프로그램은 Zip 파일의 내부 구조를 사전에 이해하고 있다고 가정합니다. 이 프로그램의 출력을 이해하는 데 도움이되는 Zip APPNOTE 파일의 복사본이 있어야합니다 ( 자세한 내용은 &lt;a href=&quot;#SEE-ALSO&quot;&gt;&quot;SEE ALSO&quot;&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="cc5a52491b0f391cb1ad331e975b3decd008b51b" translate="yes" xml:space="preserve">
          <source>The program can be made to run by &quot;laundering&quot; the tainted value through a regular expression: the second example--which still ignores locale information--runs, creating the file named on its command line if it can.</source>
          <target state="translated">정규식을 통해 오염 된 값을 &quot;세탁&quot;하여 프로그램을 실행할 수 있습니다. 두 번째 예제 (로케일 정보를 여전히 무시 함)가 실행되면 명령 행에 이름이 지정된 파일이 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="71e8e6b13bea2c8688fa8edfd4a4d7df9ffed609" translate="yes" xml:space="preserve">
          <source>The program crashes, &lt;code&gt;&lt;a href=&quot;../functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt;s, calls &lt;code&gt;closelog&lt;/code&gt; , the log is over.</source>
          <target state="translated">프로그램이 충돌하고 &lt;code&gt;&lt;a href=&quot;../functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; &lt;code&gt;closelog&lt;/code&gt; 를 호출 하면 로그가 끝납니다.</target>
        </trans-unit>
        <trans-unit id="acb249bf3e58472d9c05a98a3d9fd3a22a634ed9" translate="yes" xml:space="preserve">
          <source>The program crashes, &lt;code&gt;die&lt;/code&gt;s, calls &lt;code&gt;closelog&lt;/code&gt;, the log is over.</source>
          <target state="translated">프로그램이 충돌하고 &lt;code&gt;die&lt;/code&gt; &lt;code&gt;closelog&lt;/code&gt; 를 호출 하면 로그가 끝납니다.</target>
        </trans-unit>
        <trans-unit id="9f6e033c5ffe643ac5235dd0c4de96e8993b109b" translate="yes" xml:space="preserve">
          <source>The program h2xs is the starting point for creating extensions. In later examples we'll see how we can use h2xs to read header files and generate templates to connect to C routines.</source>
          <target state="translated">h2xs 프로그램은 확장을 작성하기위한 시작점입니다. 이후 예제에서 h2x를 사용하여 헤더 파일을 읽고 C 루틴에 연결하기위한 템플릿을 생성하는 방법을 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="6480e775a128a11d00bdb33611f7cc04c69a6a31" translate="yes" xml:space="preserve">
          <source>The program has two pieces: Lines 2--7 read the input and build a data structure, and lines 8-13 analyze the data and print out the report. We're going to have a hash, &lt;code&gt;%table&lt;/code&gt; , whose keys are country names, and whose values are references to arrays of city names. The data structure will look like this:</source>
          <target state="translated">이 프로그램은 2 ~ 7 행으로 입력을 읽고 데이터 구조를 작성하며 8 ~ 13 행은 데이터를 분석하고 보고서를 인쇄합니다. 키는 국가 이름이고 값은 도시 이름 배열에 대한 참조 인 해시 &lt;code&gt;%table&lt;/code&gt; 을 갖습니다 . 데이터 구조는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="467c57531a345de9ffd810bfeb5971919e96c865" translate="yes" xml:space="preserve">
          <source>The program has two pieces: Lines 2-7 read the input and build a data structure, and lines 8-13 analyze the data and print out the report. We're going to have a hash, &lt;code&gt;%table&lt;/code&gt;, whose keys are country names, and whose values are references to arrays of city names. The data structure will look like this:</source>
          <target state="translated">이 프로그램에는 두 부분이 있습니다. 2-7 행은 입력을 읽고 데이터 구조를 구축하고, 8-13 행은 데이터를 분석하고 보고서를 인쇄합니다. 우리는 키가 국가 이름이고 값이 도시 이름 배열에 대한 참조 인 해시 &lt;code&gt;%table&lt;/code&gt; 을 가질 것 입니다. 데이터 구조는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d46a6e0b6bbf3d5823709dce22271813109f1ce6" translate="yes" xml:space="preserve">
          <source>The program is represented by an array of &lt;code&gt;regnode&lt;/code&gt; structures, one or more of which represent a single regop of the program. Struct &lt;code&gt;regnode&lt;/code&gt; is the smallest struct needed, and has a field structure which is shared with all the other larger structures.</source>
          <target state="translated">프로그램은 &lt;code&gt;regnode&lt;/code&gt; 구조 의 배열로 표시되며 , 하나 이상의 프로그램이 단일 regop을 나타냅니다. Struct &lt;code&gt;regnode&lt;/code&gt; 는 필요한 가장 작은 구조체이며 다른 모든 더 큰 구조체와 공유되는 필드 구조를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="3ea55b0618cf1b22588d3366ef69169df7ae378e" translate="yes" xml:space="preserve">
          <source>The program is represented by an array of &lt;code&gt;regnode&lt;/code&gt; structures, one or more of which represent a single regop of the program. Struct &lt;code&gt;regnode&lt;/code&gt; is the smallest struct needed, and has a field structure which is shared with all the other larger structures. (Outside this document, the term &quot;regnode&quot; is sometimes used to mean &quot;regop&quot;, which could be confusing.)</source>
          <target state="translated">프로그램은 &lt;code&gt;regnode&lt;/code&gt; 구조 의 배열로 표시되며 , 그중 하나 이상은 프로그램의 단일 regop을 나타냅니다. 구조체 &lt;code&gt;regnode&lt;/code&gt; 는 필요한 가장 작은 구조체이며 다른 모든 큰 구조체와 공유되는 필드 구조를 가지고 있습니다. (이 문서 외부에서 &quot;regnode&quot;라는 용어는 때때로 &quot;regop&quot;을 의미하는 데 사용되며 혼동 될 수 있습니다.)</target>
        </trans-unit>
        <trans-unit id="135fe1206adbfe007b6735c772853b1eaf66848e" translate="yes" xml:space="preserve">
          <source>The program must take care to ensure that this takes place</source>
          <target state="translated">프로그램은 이것이 이루어 지도록주의를 기울여야합니다</target>
        </trans-unit>
        <trans-unit id="c1da64105b623d7426e31c12654e36ae7053e949" translate="yes" xml:space="preserve">
          <source>The program took just over 17 wallclock seconds to run. Note the different values &lt;code&gt;&lt;a href=&quot;functions/time&quot;&gt;time&lt;/a&gt;&lt;/code&gt; outputs, it's important to always use the same one, and to not confuse what each one means.</source>
          <target state="translated">이 프로그램은 실행하는 데 17 초 이상 걸렸습니다. 다른 값의 &lt;code&gt;&lt;a href=&quot;functions/time&quot;&gt;time&lt;/a&gt;&lt;/code&gt; 출력에 유의하십시오. 항상 같은 것을 사용하고 각각의 의미를 혼동하지 않는 것이 중요합니다.</target>
        </trans-unit>
        <trans-unit id="453564270c1c0cd5131ab07331c35f9b9398730b" translate="yes" xml:space="preserve">
          <source>The program took just over 17 wallclock seconds to run. Note the different values &lt;code&gt;time&lt;/code&gt; outputs, it's important to always use the same one, and to not confuse what each one means.</source>
          <target state="translated">이 프로그램을 실행하는 데 17 초가 조금 넘게 걸렸습니다. 서로 다른 값 &lt;code&gt;time&lt;/code&gt; 출력에 유의하십시오. 항상 동일한 값을 사용하고 각 값이 의미하는 바를 혼동하지 않는 것이 중요합니다.</target>
        </trans-unit>
        <trans-unit id="8912a00ba87d6cbf5df35a3207c6a72bfeb3c965" translate="yes" xml:space="preserve">
          <source>The program will halt</source>
          <target state="translated">프로그램이 중단됩니다</target>
        </trans-unit>
        <trans-unit id="267c6b23ea1ed3936b0ecbfc44abd9e2d8aa3502" translate="yes" xml:space="preserve">
          <source>The programming interface is easy to use: it's the same one found in CPAN's &lt;a href=&quot;../digest&quot;&gt;Digest&lt;/a&gt; module. So, if your applications currently use &lt;a href=&quot;md5&quot;&gt;Digest::MD5&lt;/a&gt; and you'd prefer the stronger security of SHA, it's a simple matter to convert them.</source>
          <target state="translated">프로그래밍 인터페이스는 사용하기 쉽습니다 . CPAN의 &lt;a href=&quot;../digest&quot;&gt;다이제스트&lt;/a&gt; 모듈 에서와 동일 합니다. 따라서 응용 프로그램에서 현재 &lt;a href=&quot;md5&quot;&gt;Digest :: MD5를&lt;/a&gt; 사용 하고 있고 더 강력한 SHA 보안을 원한다면 간단히 변환해야합니다.</target>
        </trans-unit>
        <trans-unit id="7b1493356cb4a3eba009f1a11b50de871f482665" translate="yes" xml:space="preserve">
          <source>The programming interface is easy to use: it's the same one found in CPAN's &lt;a href=&quot;digest&quot;&gt;Digest&lt;/a&gt; module. So, if your applications currently use &lt;a href=&quot;Digest::MD5&quot;&gt;Digest::MD5&lt;/a&gt; and you'd prefer the stronger security of SHA, it's a simple matter to convert them.</source>
          <target state="translated">프로그래밍 인터페이스는 사용하기 쉽습니다 . CPAN의 &lt;a href=&quot;digest&quot;&gt;Digest&lt;/a&gt; 모듈 에있는 것과 동일 합니다. 따라서 응용 프로그램이 현재 &lt;a href=&quot;Digest::MD5&quot;&gt;Digest :: MD5를 사용&lt;/a&gt; 하고 있고 SHA의 강력한 보안을 선호한다면 변환하는 것이 간단합니다.</target>
        </trans-unit>
        <trans-unit id="d0f12348b1996ab0ae0eb3467409b46f3ff517e5" translate="yes" xml:space="preserve">
          <source>The programs and documentation in this dist are distributed in the hope that they will be useful, but without any warranty; without even the implied warranty of merchantability or fitness for a particular purpose.</source>
          <target state="translated">이 영역의 프로그램과 설명서는 유용하지만 보증없이 제공 될 것입니다. 상업성이나 특정 목적에의 적합성에 대한 묵시적 보증없이.</target>
        </trans-unit>
        <trans-unit id="3b63891b0a81b9b51c173bac879417506124032c" translate="yes" xml:space="preserve">
          <source>The prompt of the cpan shell can contain the current command number for easier tracking of the session or be a plain string.</source>
          <target state="translated">cpan 쉘의 프롬프트는 세션을 쉽게 추적하기 위해 현재 명령 번호를 포함하거나 일반 문자열 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a9cf8b59c024e83e18267b0f8a6518d4ffcc35fc" translate="yes" xml:space="preserve">
          <source>The property of lowercase before uppercase letters in EBCDIC is even carried to the Latin 1 EBCDIC pages such as 0037 and 1047. An example would be that &quot;&amp;Euml;&quot; (&lt;code&gt;E WITH DIAERESIS&lt;/code&gt; , 203) comes before &quot;&amp;euml;&quot; (&lt;code&gt;e WITH DIAERESIS&lt;/code&gt; , 235) on an ASCII platform, but the latter (83) comes before the former (115) on an EBCDIC platform. (Astute readers will note that the uppercase version of &quot;&amp;szlig;&quot; &lt;code&gt;SMALL LETTER SHARP S&lt;/code&gt; is simply &quot;SS&quot; and that the upper case versions of &quot;&amp;yuml;&quot; (small &lt;code&gt;y WITH DIAERESIS&lt;/code&gt;) and &quot;&amp;micro;&quot; (&lt;code&gt;MICRO SIGN&lt;/code&gt; ) are not in the 0..255 range but are in Unicode, in a Unicode enabled Perl).</source>
          <target state="translated">EBCDIC에서 대문자 앞의 소문자 속성은 심지어 0037 및 1047과 같은 라틴어 1 EBCDIC 페이지로 전달됩니다. 예를 들어 &quot;&amp;Euml;&quot;( &lt;code&gt;E WITH DIAERESIS&lt;/code&gt; , 203)은 &quot;&amp;euml;&quot;( &lt;code&gt;e WITH DIAERESIS&lt;/code&gt; , 235 ) 앞에옵니다. )를 ASCII 플랫폼에서 사용하지만 후자 (83)는 EBCDIC 플랫폼에서 전자 (115) 앞에옵니다. (Astute 독자들은 &quot;&amp;szlig;&quot; &lt;code&gt;SMALL LETTER SHARP S&lt;/code&gt; 의 대문자 버전 은 단순히 &quot;SS&quot;이며 &quot;&amp;yuml;&quot;(작은 &lt;code&gt;y WITH DIAERESIS&lt;/code&gt; ) 및 &quot;&amp;micro;&quot;( &lt;code&gt;MICRO SIGN&lt;/code&gt; )의 대문자 버전은 0..255 범위이지만 유니 코드를 사용하는 유니 코드 사용 Perl).</target>
        </trans-unit>
        <trans-unit id="d068c61e1d2738a4b949032692f164ea749e79a4" translate="yes" xml:space="preserve">
          <source>The property of lowercase before uppercase letters in EBCDIC is even carried to the Latin 1 EBCDIC pages such as 0037 and 1047. An example would be that &quot;&amp;Euml;&quot; (&lt;code&gt;E WITH DIAERESIS&lt;/code&gt;, 203) comes before &quot;&amp;euml;&quot; (&lt;code&gt;e WITH DIAERESIS&lt;/code&gt;, 235) on an ASCII platform, but the latter (83) comes before the former (115) on an EBCDIC platform. (Astute readers will note that the uppercase version of &quot;&amp;szlig;&quot; &lt;code&gt;SMALL LETTER SHARP S&lt;/code&gt; is simply &quot;SS&quot; and that the upper case versions of &quot;&amp;yuml;&quot; (small &lt;code&gt;y WITH DIAERESIS&lt;/code&gt;) and &quot;&amp;micro;&quot; (&lt;code&gt;MICRO SIGN&lt;/code&gt;) are not in the 0..255 range but are in Unicode, in a Unicode enabled Perl).</source>
          <target state="translated">EBCDIC에서 대문자 앞의 소문자 속성은 0037 및 1047과 같은 라틴어 1 EBCDIC 페이지에도 전달됩니다. 예를 들어 &quot;&amp;Euml;&quot;( &lt;code&gt;E WITH DIAERESIS&lt;/code&gt; , 203)가 &quot;&amp;euml;&quot;앞에 오는 경우 ( &lt;code&gt;e WITH DIAERESIS&lt;/code&gt; , 235) )는 ASCII 플랫폼에서 사용되지만 EBCDIC 플랫폼에서는 후자 (83)가 전자 (115)보다 먼저 나옵니다. (예리한 독자들은 &quot;&amp;szlig;&quot; &lt;code&gt;SMALL LETTER SHARP S&lt;/code&gt; 의 대문자 버전 은 단순히 &quot;SS&quot;이고 &quot;&amp;yuml;&quot;(소형 &lt;code&gt;y WITH DIAERESIS&lt;/code&gt; ) 및 &quot;&amp;micro;&quot;( &lt;code&gt;MICRO SIGN&lt;/code&gt; )의 대문자 버전은 0..255 범위이지만 유니 코드 사용 가능 Perl에서 유니 코드로되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="09b7c3443c95713bb7f5c3a34ea900a666d3209c" translate="yes" xml:space="preserve">
          <source>The protocol (e.g. &lt;code&gt;IPPROTO_TCP&lt;/code&gt; )</source>
          <target state="translated">프로토콜 (예 : &lt;code&gt;IPPROTO_TCP&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="1d688930b159b0de8e063999fc12f1fc3e668a59" translate="yes" xml:space="preserve">
          <source>The protocol (e.g. &lt;code&gt;IPPROTO_TCP&lt;/code&gt;)</source>
          <target state="translated">프로토콜 (예 : &lt;code&gt;IPPROTO_TCP&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="16c98cd2a0bd15be4f172d1ada9a2ed6c4ba31c3" translate="yes" xml:space="preserve">
          <source>The protocol also defines several standard &lt;b&gt;translations&lt;/b&gt; which the file can undergo during transfer. These are ASCII, EBCDIC, binary, and byte. ASCII is the default type, and indicates that the sender of files will translate the ends of lines to a standard representation which the receiver will then translate back into their local representation. EBCDIC indicates the file being transferred is in EBCDIC format. Binary (also known as image) format sends the data as a contiguous bit stream. Byte format transfers the data as bytes, the values of which remain the same regardless of differences in byte size between the two machines (in theory - in practice you should only use this if you really know what you're doing). This class does not support the EBCDIC or byte formats, and will default to binary instead if they are attempted.</source>
          <target state="translated">이 프로토콜은 또한 여러 표준 &lt;b&gt;번역을&lt;/b&gt; 정의합니다&lt;b&gt;&lt;/b&gt;파일이 전송 중에 겪을 수 있습니다. ASCII, EBCDIC, 이진 및 바이트입니다. ASCII는 기본 유형이며 파일 발신자가 줄 끝을 표준 표현으로 변환 한 다음 수신자가 다시 로컬 표현으로 변환 함을 나타냅니다. EBCDIC은 전송중인 파일이 EBCDIC 형식임을 나타냅니다. 이진 (이미지라고도 함) 형식은 데이터를 연속 비트 스트림으로 보냅니다. 바이트 형식은 데이터를 바이트로 전송하며, 그 값은 두 시스템 간의 바이트 크기 차이와 상관없이 동일하게 유지됩니다 (이론상 실제로는 실제로 수행중인 작업을 알고있는 경우에만 사용해야합니다). 이 클래스는 EBCDIC 또는 바이트 형식을 지원하지 않으며, 시도하면 대신 이진을 기본값으로 사용합니다.</target>
        </trans-unit>
        <trans-unit id="3e54303b3641a865f35ca39d2a398386ca07567a" translate="yes" xml:space="preserve">
          <source>The prototype CV for a 'my' sub.</source>
          <target state="translated">'my'하위에 대한 프로토 타입 CV</target>
        </trans-unit>
        <trans-unit id="11a1d81ab8f0f4c68c1c261efa58242791ed97cf" translate="yes" xml:space="preserve">
          <source>The prototype attribute, and any other attributes, come after the signature.</source>
          <target state="translated">프로토 타입 속성 및 기타 속성은 서명 뒤에옵니다.</target>
        </trans-unit>
        <trans-unit id="571effb91670d02136e12104ead995a6cc16a1c2" translate="yes" xml:space="preserve">
          <source>The prototype attribute, and any other attributes, must come before the signature. The signature always immediately precedes the block of the subroutine's body.</source>
          <target state="translated">프로토 타입 속성 및 기타 속성은 서명 앞에 와야합니다. 서명은 항상 서브 루틴 본문의 블록 바로 앞에옵니다.</target>
        </trans-unit>
        <trans-unit id="420268bbe69f10bd1b6ed7fa6d80a149e32d8a64" translate="yes" xml:space="preserve">
          <source>The prototype from the attribute is assigned to the sub immediately after the prototype from the sub, which means that if both are declared at the same time, the traditionally defined prototype is ignored. In other words, &lt;code&gt;sub foo($$) : prototype(@) {}&lt;/code&gt; is indistinguishable from &lt;code&gt;sub foo(@){}&lt;/code&gt; .</source>
          <target state="translated">속성의 프로토 타입은 서브의 프로토 타입 바로 다음에 서브에 할당됩니다. 즉, 둘 다 동시에 선언되면 기존에 정의 된 프로토 타입이 무시됩니다. 즉, &lt;code&gt;sub foo($$) : prototype(@) {}&lt;/code&gt; 은 &lt;code&gt;sub foo(@){}&lt;/code&gt; 구별 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="a9e026f2d40529605b03137d9a9ed6ef4bb374c7" translate="yes" xml:space="preserve">
          <source>The prototype from the attribute is assigned to the sub immediately after the prototype from the sub, which means that if both are declared at the same time, the traditionally defined prototype is ignored. In other words, &lt;code&gt;sub foo($$) : prototype(@) {}&lt;/code&gt; is indistinguishable from &lt;code&gt;sub foo(@){}&lt;/code&gt;.</source>
          <target state="translated">속성의 프로토 타입은 서브의 프로토 타입 바로 뒤에 서브에 할당됩니다. 즉, 둘 다 동시에 선언되면 전통적으로 정의 된 프로토 타입은 무시됩니다. 즉, &lt;code&gt;sub foo($$) : prototype(@) {}&lt;/code&gt; 은 &lt;code&gt;sub foo(@){}&lt;/code&gt; 구별 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="d6eb998a9749fabedff565e15bacf235434a61b2" translate="yes" xml:space="preserve">
          <source>The provided argument MUST be equal to the string for the validation to pass.</source>
          <target state="translated">제공된 인수는 유효성 검사를 통과하기위한 문자열과 같아야합니다.</target>
        </trans-unit>
        <trans-unit id="113c257205a6110f9be3ea8173531d90a26a925b" translate="yes" xml:space="preserve">
          <source>The provided argument MUST equal one of the elements of the array ref for the validation to pass. An array ref can hold all the above values.</source>
          <target state="translated">제공된 인수는 유효성 검사를 통과하기위한 배열 참조 요소 중 하나와 같아야합니다. 배열 참조는 위의 모든 값을 보유 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f0175fe813dc359c6d5d92da9a9b07e142152ec0" translate="yes" xml:space="preserve">
          <source>The provided argument MUST match the regular expression for the validation to pass.</source>
          <target state="translated">제공된 인수는 유효성 검사를 통과하기 위해 정규식과 일치해야합니다.</target>
        </trans-unit>
        <trans-unit id="7028c08ff6edd9122ed07f747d04ab21bb6b6da9" translate="yes" xml:space="preserve">
          <source>The provided subroutine MUST return true in order for the validation to pass and the argument accepted.</source>
          <target state="translated">제공된 서브 루틴은 검증이 통과되고 인수가 승인 되려면 true를 리턴해야합니다.</target>
        </trans-unit>
        <trans-unit id="93c41fbabb74d3c7cddc4b5e78899f8faa1b1f17" translate="yes" xml:space="preserve">
          <source>The pseudo-hash feature was an experimental feature introduced in earlier versions of Perl and removed in 5.10.0. A pseudo-hash is an array reference which can be accessed using named keys like a hash. You may run in to some code in the wild which uses it. See the &lt;a href=&quot;fields&quot;&gt;fields&lt;/a&gt; pragma for more information.</source>
          <target state="translated">유사 해시 기능은 이전 버전의 Perl에서 도입되어 5.10.0에서 제거 된 실험 기능입니다. 의사 해시는 해시와 같은 명명 된 키를 사용하여 액세스 할 수있는 배열 참조입니다. 코드를 사용하는 일부 코드가 실행될 수 있습니다. 자세한 정보는 pragma &lt;a href=&quot;fields&quot;&gt;필드&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="2c3bf5ebc790603d27cda992131fe6f16a627371" translate="yes" xml:space="preserve">
          <source>The public API must remain consistent, i.e. if a sub-class is overloading addition, the sub-class must use the same name, in this case badd(). The reason for this is that Math::BigInt is optimized to call the object methods directly.</source>
          <target state="translated">퍼블릭 API는 일관성을 유지해야합니다. 즉 서브 클래스가 오버로드를 추가하는 경우 서브 클래스는 동일한 이름을 사용해야합니다 (이 경우 badd ()). 그 이유는 Math :: BigInt가 객체 메소드를 직접 호출하도록 최적화 되었기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="dc2995512c58b9b2e35d09bc546dc5a7fbc84663" translate="yes" xml:space="preserve">
          <source>The purpose of the macro &lt;code&gt;SPAGAIN&lt;/code&gt; is to refresh the local copy of the stack pointer. This is necessary because it is possible that the memory allocated to the Perl stack has been reallocated during the</source>
          <target state="translated">&lt;code&gt;SPAGAIN&lt;/code&gt; 매크로의 목적은 스택 포인터의 로컬 복사본을 새로 고치는 것입니다. 이는 Perl 스택에 할당 된 메모리가 재 할당 될 수 있기 때문에 필요합니다.</target>
        </trans-unit>
        <trans-unit id="211ca4f47d195354704ae118cbe1d64c1c871ea0" translate="yes" xml:space="preserve">
          <source>The purpose of the pragma is to alert users to the status of such a module by issuing a warning that encourages them to install the module from CPAN, so that a future upgrade to a perl which omits the module will not break their code.</source>
          <target state="translated">pragma의 목적은 CPAN에서 모듈을 설치하도록 권장하는 경고를 발행하여 사용자에게 이러한 모듈의 상태를 경고하여 모듈을 생략하는 펄로의 향후 업그레이드가 코드를 손상시키지 않도록하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="b29cd6102fd964c85b9f311d0c28db3fab69123d" translate="yes" xml:space="preserve">
          <source>The purpose of the testing is twofold: one, to help developers fix any problems in their code that crop up because of lack of testing on other platforms; two, to provide users with information about whether a given module works on a given platform.</source>
          <target state="translated">테스트의 목적은 두 가지입니다. 하나는 개발자가 다른 플랫폼에서의 테스트 부족으로 인해 코드에서 발생하는 문제를 해결하도록 돕는 것입니다. 주어진 모듈에서 특정 모듈이 작동하는지에 대한 정보를 사용자에게 제공합니다.</target>
        </trans-unit>
        <trans-unit id="a5dd5b4e9fced711b08542f3e0ab81c18273f9bd" translate="yes" xml:space="preserve">
          <source>The purpose of this document is to document what has been deprecated in Perl, and by which version the deprecated feature will disappear, or, for already removed features, when it was removed.</source>
          <target state="translated">이 문서의 목적은 Perl에서 더 이상 사용되지 않는 기능과 사용되지 않는 기능이 사라질 버전 또는 이미 제거 된 기능의 경우 제거되었을 때 문서화하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="843821edac19011f1a6d1c830e78298f0013f7a5" translate="yes" xml:space="preserve">
          <source>The purpose of this document is to show you how to call Perl subroutines directly from C, i.e., how to write</source>
          <target state="translated">이 문서의 목적은 C에서 직접 Perl 서브 루틴을 호출하는 방법, 즉 작성 방법을 보여주기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="414e7fd5b34fea33393baf5db076f7ff8658e79f" translate="yes" xml:space="preserve">
          <source>The purpose of this module is to provide a wide range of testing utilities. Various ways to say &quot;ok&quot; with better diagnostics, facilities to skip tests, test future features and compare complicated data structures. While you can do almost anything with a simple &lt;code&gt;ok()&lt;/code&gt; function, it doesn't provide good diagnostic output.</source>
          <target state="translated">이 모듈의 목적은 광범위한 테스트 유틸리티를 제공하는 것입니다. 더 나은 진단 기능, 테스트 건너 뛰기 기능, 향후 기능 테스트 및 복잡한 데이터 구조 비교와 함께 &quot;확인&quot;하는 다양한 방법. 간단한 &lt;code&gt;ok()&lt;/code&gt; 함수를 사용하면 거의 모든 작업을 수행 할 수 있지만 진단 결과는 양호하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9bfc8ef428f97c3f3e1176a68cf8e1112929bebf" translate="yes" xml:space="preserve">
          <source>The purpose, scope and target applications of your module</source>
          <target state="translated">모듈의 목적, 범위 및 대상 응용</target>
        </trans-unit>
        <trans-unit id="cb81c6a18976d12ebe998a0a0b9af8a1bf213151" translate="yes" xml:space="preserve">
          <source>The pyramids.</source>
          <target state="translated">피라미드.</target>
        </trans-unit>
        <trans-unit id="ddc9dd67da090624c445edfafa6830e5bccd4e64" translate="yes" xml:space="preserve">
          <source>The quality that makes you go to great effort to reduce overall energy expenditure. It makes you write labor-saving programs that other people will find useful, and then document what you wrote so you don&amp;rsquo;t have to answer so many questions about it. Hence, the first great virtue of a programmer. Also hence, this book. See also &lt;b&gt;impatience&lt;/b&gt; and &lt;b&gt;hubris&lt;/b&gt;.</source>
          <target state="translated">전반적인 에너지 소비를 줄이기 위해 많은 노력을 기울이는 품질. 다른 사람들이 유용하게 사용할 수있는 노동 절약 프로그램을 작성하고 작성한 내용을 문서화하므로 이에 대해 많은 질문에 대답 할 필요가 없습니다. 따라서 프로그래머의 첫 번째 미덕입니다. 따라서이 책도 마찬가지입니다. &lt;b&gt;조바심&lt;/b&gt; 과 &lt;b&gt;후부&lt;/b&gt; 참조 .</target>
        </trans-unit>
        <trans-unit id="52d7089e85ac35a7092bc58942f32bee7ca90b8d" translate="yes" xml:space="preserve">
          <source>The question of string equivalence turns somewhat complicated in Unicode: what do you mean by &quot;equal&quot;?</source>
          <target state="translated">문자열 동등성의 문제는 유니 코드에서 다소 복잡해집니다. &quot;같음&quot;은 무엇을 의미합니까?</target>
        </trans-unit>
        <trans-unit id="f2a24b3b2648553142b8c5a0c4598996a73f792a" translate="yes" xml:space="preserve">
          <source>The question remains on when the SVs which are</source>
          <target state="translated">SV가</target>
        </trans-unit>
        <trans-unit id="099c0ce39a19f948a86d0ea40fc49e8ea2b14385" translate="yes" xml:space="preserve">
          <source>The question, of course, is why would you do something like this? Why create a semaphore with a starting count that's not one, or why decrement or increment it by more than one? The answer is resource availability. Many resources that you want to manage access for can be safely used by more than one thread at once.</source>
          <target state="translated">물론 질문은 왜 이런 식으로 하시겠습니까? 시작 카운트가 아닌 세마포어를 만드는 이유 또는 왜 두 개 이상 감소 또는 증가합니까? 대답은 자원 가용성입니다. 액세스를 관리하려는 많은 자원을 한 번에 둘 이상의 스레드에서 안전하게 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7e4709a385e818a7adc04721b36836ff38439abe" translate="yes" xml:space="preserve">
          <source>The quick answer is because they are easy to implement yourself. The long answer is that to write these in such a way that multiple platforms are supported correctly would just require too much code. Below are some examples how you can implement these yourself.</source>
          <target state="translated">빠른 대답은 직접 구현하기 쉽기 때문입니다. 긴 대답은 여러 플랫폼이 올바르게 지원되는 방식으로 작성하려면 너무 많은 코드가 필요하다는 것입니다. 다음은이를 직접 구현할 수있는 몇 가지 예입니다.</target>
        </trans-unit>
        <trans-unit id="551d1aa8a1248eaf53c1cd9d606d72ab7488cd21" translate="yes" xml:space="preserve">
          <source>The quick-and-dirty method only works well when you don't plan to leave the commented code in the source. If a Pod parser comes along, your multiline comment is going to show up in the Pod translation. A better way hides it from Pod parsers as well.</source>
          <target state="translated">빠르고 더러운 방법은 주석 처리 된 코드를 소스에 남겨 두지 않을 경우에만 잘 작동합니다. 포드 파서가 나오면 여러 줄 주석이 포드 번역에 표시됩니다. 더 좋은 방법은 포드 파서에서도 숨길 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a41d7294035834639b17968992ffda16ae85e9a1" translate="yes" xml:space="preserve">
          <source>The quick-and-dirty way to comment out more than one line of Perl is to surround those lines with Pod directives. You have to put these directives at the beginning of the line and somewhere where Perl expects a new statement (so not in the middle of statements like the &lt;code&gt;#&lt;/code&gt; comments). You end the comment with &lt;code&gt;=cut&lt;/code&gt; , ending the Pod section:</source>
          <target state="translated">둘 이상의 Perl 행을 주석 처리하는 빠르고 더러운 방법은 해당 행을 포드 지시문으로 묶는 것입니다. 이 지시문은 줄의 시작 부분과 Perl이 새로운 문장을 기대하는 곳에 두어야합니다 (따라서 &lt;code&gt;#&lt;/code&gt; 주석 과 같은 문장의 중간 부분은 아님). &lt;code&gt;=cut&lt;/code&gt; 으로 주석을 끝내고 포드 섹션을 종료합니다.</target>
        </trans-unit>
        <trans-unit id="d90a105b257205ce48226d803e75858a07587fa6" translate="yes" xml:space="preserve">
          <source>The quick-and-dirty way to comment out more than one line of Perl is to surround those lines with Pod directives. You have to put these directives at the beginning of the line and somewhere where Perl expects a new statement (so not in the middle of statements like the &lt;code&gt;#&lt;/code&gt; comments). You end the comment with &lt;code&gt;=cut&lt;/code&gt;, ending the Pod section:</source>
          <target state="translated">두 줄 이상의 Perl을 주석 처리하는 빠르고 간단한 방법은 해당 줄을 Pod 지시문으로 묶는 것입니다. 이 지시문은 줄의 시작 부분과 Perl이 새로운 문을 예상하는 곳에 두어야합니다 ( &lt;code&gt;#&lt;/code&gt; 주석 과 같은 문 중간이 아님). &lt;code&gt;=cut&lt;/code&gt; 으로 주석을 끝내고 Pod 섹션을 끝냅니다.</target>
        </trans-unit>
        <trans-unit id="0c2f3594848e5558e5b1bcd7932b24c116883439" translate="yes" xml:space="preserve">
          <source>The quotient is always the greatest integer less than or equal to the real-valued quotient of the two operands, and the remainder (when it is non-zero) always has the same sign as the second operand; so, for example,</source>
          <target state="translated">몫은 항상 두 피연산자의 실제 몫보다 작거나 같은 가장 큰 정수이며, 나머지 (0이 아닌 경우)는 항상 두 번째 피연산자와 같은 부호를 갖습니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="04db20aec07e3c7b83de9b23243f0bb2ef9f279e" translate="yes" xml:space="preserve">
          <source>The random characters are provided by File::Temp and ensure that each module's individual build directory is unique. This makes running CPAN.pm in concurrent processes simultaneously safe.</source>
          <target state="translated">임의의 문자는 File :: Temp에서 제공되며 각 모듈의 개별 빌드 디렉토리가 고유한지 확인하십시오. 따라서 동시 프로세스에서 CPAN.pm을 동시에 안전하게 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="054e3d7058644b114207f253c83eb2c8a141a8e1" translate="yes" xml:space="preserve">
          <source>The range operator (in list context) makes use of the magical auto-increment algorithm if the operands are strings. You can say</source>
          <target state="translated">범위 연산자 (목록 컨텍스트에서)는 피연산자가 문자열 인 경우 마술 자동 증가 알고리즘을 사용합니다. 당신은 말할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="4828534433b64aecd95537d37d705a006ad5851e" translate="yes" xml:space="preserve">
          <source>The range operator &lt;code&gt;..&lt;/code&gt; cannot be overloaded.</source>
          <target state="translated">범위 연산자 &lt;code&gt;..&lt;/code&gt; 을 ( 를) 오버로드 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="bc508fe7a659eeced29e856ebc7b8d62470c6bbb" translate="yes" xml:space="preserve">
          <source>The range operator also works on strings, using the magical auto-increment, see below.</source>
          <target state="translated">범위 연산자는 마법의 자동 증가를 사용하여 문자열에서 작동합니다 (아래 참조).</target>
        </trans-unit>
        <trans-unit id="31d3e334c25d2382911ee65d3fae61de81e23584" translate="yes" xml:space="preserve">
          <source>The range operator in list context can make use of the magical auto-increment algorithm if both operands are strings, subject to the following rules:</source>
          <target state="translated">목록 컨텍스트의 범위 연산자는 다음 규칙에 따라 두 피연산자가 문자열 인 경우 마법의 자동 증가 알고리즘을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e7f8ca3eb25d07981f64e697003d81f247478aa9" translate="yes" xml:space="preserve">
          <source>The range operator is &quot;..&quot;, not comma. The comma operator works as in C.</source>
          <target state="translated">범위 연산자는 &quot;..&quot;이며 쉼표가 아닙니다. 쉼표 연산자는 C에서와 같이 작동합니다.</target>
        </trans-unit>
        <trans-unit id="6b43593ef7e3f96c529ec6f6490c77d15e8ee949" translate="yes" xml:space="preserve">
          <source>The range operator is &lt;code&gt;...&lt;/code&gt; , rather than comma.</source>
          <target state="translated">범위 연산자는 쉼표가 아닌 &lt;code&gt;...&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="6702b09bbe69f958fa5f9869c6ae81b0c789760d" translate="yes" xml:space="preserve">
          <source>The range operator is &lt;code&gt;...&lt;/code&gt;, rather than comma.</source>
          <target state="translated">범위 연산자는 쉼표가 아니라 &lt;code&gt;...&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="41fb6d64bc39d2dbbf811ff985ded944bd6951e6" translate="yes" xml:space="preserve">
          <source>The rationale for inclusion in this module is that the function performs some work for which an XS implementation is essential because it cannot be implemented in Pure Perl, and which is sufficiently-widely used across CPAN that its popularity warrants inclusion in a core module, which this is.</source>
          <target state="translated">이 모듈에 포함 된 이유는 함수가 Pure Perl에서 구현할 수 없기 때문에 XS 구현이 필수적인 일부 작업을 수행하고 CPAN 전체에서 충분히 널리 사용되어 인기가 코어 모듈에 포함되어야한다는 것입니다. 이것은.</target>
        </trans-unit>
        <trans-unit id="272be5d09f375bcf2f8787674ae6b79aa38f8abf" translate="yes" xml:space="preserve">
          <source>The rationale for requiring this is to not break older programs that rely on the way things worked before Unicode came along. Those older programs knew only about the ASCII character set, and so may not work properly for additional characters. When a string is encoded in UTF-8, Perl assumes that the program is prepared to deal with Unicode, but when the string isn't, Perl assumes that only ASCII is wanted, and so those characters that are not ASCII characters aren't recognized as to what they would be in Unicode. &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature 'unicode_strings'&lt;/code&gt; tells Perl to treat all characters as Unicode, whether the string is encoded in UTF-8 or not, thus avoiding the problem.</source>
          <target state="translated">이를 요구하는 이유는 유니 코드가 등장하기 전에 작동 방식에 의존하는 오래된 프로그램을 중단하지 않는 것입니다. 이러한 이전 프로그램은 ASCII 문자 세트에 대해서만 알고 있으므로 추가 문자에 대해 제대로 작동하지 않을 수 있습니다. 문자열이 UTF-8로 인코딩되면 Perl은 프로그램이 유니 코드를 처리 할 준비가되어 있다고 가정하지만 문자열이 그렇지 않으면 Perl은 ASCII 만 필요하다고 가정하므로 ASCII 문자가 아닌 문자는 그렇지 않습니다 그들이 유니 코드로 무엇인지에 대해 인식했습니다. &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature 'unicode_strings'&lt;/code&gt; &lt;a href=&quot;functions/use&quot;&gt;사용&lt;/a&gt; 하면 문자열이 UTF-8로 인코딩되는지 여부에 관계없이 모든 문자를 유니 코드로 처리하도록하여 Perl에 문제를 피할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cd600fcbf1a6b70419da39d25dfcf62c3af89b3f" translate="yes" xml:space="preserve">
          <source>The rationale for requiring this is to not break older programs that rely on the way things worked before Unicode came along. Those older programs knew only about the ASCII character set, and so may not work properly for additional characters. When a string is encoded in UTF-8, Perl assumes that the program is prepared to deal with Unicode, but when the string isn't, Perl assumes that only ASCII is wanted, and so those characters that are not ASCII characters aren't recognized as to what they would be in Unicode. &lt;code&gt;use feature 'unicode_strings'&lt;/code&gt; tells Perl to treat all characters as Unicode, whether the string is encoded in UTF-8 or not, thus avoiding the problem.</source>
          <target state="translated">이를 요구하는 이유는 유니 코드가 등장하기 전에 작동 방식에 의존하는 오래된 프로그램을 깨뜨리지 않기 위해서입니다. 이러한 오래된 프로그램은 ASCII 문자 집합에 대해서만 알고 있으므로 추가 문자에 대해서는 제대로 작동하지 않을 수 있습니다. 문자열이 UTF-8로 인코딩 될 때 Perl은 프로그램이 유니 코드를 처리 할 준비가되어 있다고 가정하지만 문자열이 그렇지 않은 경우 Perl은 ASCII 만 필요하다고 가정하므로 ASCII 문자가 아닌 문자는 그렇지 않습니다. 그들이 유니 코드로 무엇인지로 인식됩니다. &lt;code&gt;use feature 'unicode_strings'&lt;/code&gt; 는 문자열이 UTF-8로 인코딩되었는지 여부에 관계없이 모든 문자를 유니 코드로 처리하도록 Perl에 지시하여 문제를 방지합니다.</target>
        </trans-unit>
        <trans-unit id="062d7f6e6f9ffa42523f91b3b98af5b6e21dddc1" translate="yes" xml:space="preserve">
          <source>The raw floppy disk. Doesn't work under Windows 95. This allows you to read or write raw sectors of the floppy disk and to use &lt;code&gt;DeviceIoControl&lt;/code&gt; to perform miscellaneous queries and operations to the floppy disk or drive.</source>
          <target state="translated">원시 플로피 디스크. Windows 95에서는 작동하지 않습니다. 이렇게하면 플로피 디스크의 원시 섹터를 읽거나 쓸 수 있으며 &lt;code&gt;DeviceIoControl&lt;/code&gt; 을 사용 하여 플로피 디스크 나 드라이브에 대한 기타 쿼리 및 작업을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="62a00a9112198d60e9e6e148f4efbf8b5c8bde2f" translate="yes" xml:space="preserve">
          <source>The raw original L&amp;lt;...&amp;gt; content, before text is split on &quot;|&quot;, &quot;/&quot;, etc, and before E&amp;lt;...&amp;gt; codes are expanded.</source>
          <target state="translated">텍스트가 &quot;|&quot;, &quot;/&quot;등으로 분할되기 전과 E &amp;lt;...&amp;gt; 코드가 확장되기 전에 원시 원본 L &amp;lt;...&amp;gt; 컨텐츠.</target>
        </trans-unit>
        <trans-unit id="16f6921cb27bb9d796f9843804daa8d9f88db314" translate="yes" xml:space="preserve">
          <source>The read-only magic variable &lt;code&gt;${^UNICODE}&lt;/code&gt; reflects the numeric value of this setting. This variable is set during Perl startup and is thereafter read-only. If you want runtime effects, use the three-arg open() (see &lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;), the two-arg binmode() (see &lt;a href=&quot;functions/binmode&quot;&gt;binmode&lt;/a&gt;), and the &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; pragma (see &lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;).</source>
          <target state="translated">읽기 전용 매직 변수 &lt;code&gt;${^UNICODE}&lt;/code&gt; 는이 설정의 숫자 값을 반영합니다. 이 변수는 Perl 시작 중에 설정되며 이후 읽기 전용입니다. 런타임 효과를 원하면 three-arg open () ( &lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt; 참조 ), two-arg binmode () ( &lt;a href=&quot;functions/binmode&quot;&gt;binmode&lt;/a&gt; 참조 ) 및 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; pragma ( &lt;a href=&quot;open&quot;&gt;open&lt;/a&gt; 참조 )를 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="7133d99787afc8bed88333155f330e0814f3badc" translate="yes" xml:space="preserve">
          <source>The read-only magic variable &lt;code&gt;${^UNICODE}&lt;/code&gt; reflects the numeric value of this setting. This variable is set during Perl startup and is thereafter read-only. If you want runtime effects, use the three-arg open() (see &lt;a href=&quot;perlfunc#open&quot;&gt;&quot;open&quot; in perlfunc&lt;/a&gt;), the two-arg binmode() (see &lt;a href=&quot;perlfunc#binmode&quot;&gt;&quot;binmode&quot; in perlfunc&lt;/a&gt;), and the &lt;code&gt;open&lt;/code&gt; pragma (see &lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;).</source>
          <target state="translated">읽기 전용 매직 변수 &lt;code&gt;${^UNICODE}&lt;/code&gt; 는이 설정의 숫자 값을 반영합니다. 이 변수는 Perl 시작 중에 설정되며 이후 읽기 전용입니다. 런타임 효과를 원하면 3 인수 open () ( &lt;a href=&quot;perlfunc#open&quot;&gt;perlfunc의 &quot;open&quot;&lt;/a&gt; 참조 ), 2 인수 binmode () ( &lt;a href=&quot;perlfunc#binmode&quot;&gt;perlfunc의 &quot;binmode&quot;&lt;/a&gt; 참조 ) 및 &lt;code&gt;open&lt;/code&gt; pragma ( &lt;a href=&quot;open&quot;&gt;open&lt;/a&gt; 참조 )를 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="8ac185b6e70958a0bc2daae47b4a77ca571d1fad" translate="yes" xml:space="preserve">
          <source>The real gid of this process. If you are on a machine that supports membership in multiple groups simultaneously, gives a space separated list of groups you are in. The first number is the one returned by &lt;code&gt;getgid()&lt;/code&gt; , and the subsequent ones by &lt;code&gt;getgroups()&lt;/code&gt; , one of which may be the same as the first number.</source>
          <target state="translated">이 과정의 실제 모습. 당신이 컴퓨터에있는 경우 동시에 여러 그룹에서 지원하는 회원은 공간이 당신에있는 그룹의 목록을 분리 준다. 첫 번째 숫자에 의해 반환되는 것과 &lt;code&gt;getgid()&lt;/code&gt; , 그리고에 의해 이후의 것들 &lt;code&gt;getgroups()&lt;/code&gt; , 하나의 수도 첫 번째 숫자와 동일해야합니다.</target>
        </trans-unit>
        <trans-unit id="1b0d46bf2b89fe3b91282dbaf19dbfd7a631baf9" translate="yes" xml:space="preserve">
          <source>The real gid of this process. If you are on a machine that supports membership in multiple groups simultaneously, gives a space separated list of groups you are in. The first number is the one returned by &lt;code&gt;getgid()&lt;/code&gt;, and the subsequent ones by &lt;code&gt;getgroups()&lt;/code&gt;, one of which may be the same as the first number.</source>
          <target state="translated">이 과정의 진짜 길. 여러 그룹의 멤버쉽을 동시에 지원하는 시스템에있는 경우, 사용자가 속한 그룹의 공백으로 구분 된 목록을 제공합니다. 첫 번째 번호는 &lt;code&gt;getgid()&lt;/code&gt; 에서 반환 한 번호이고 후속 번호는 &lt;code&gt;getgroups()&lt;/code&gt; 에서 반환 한 번호입니다. 첫 번째 숫자와 동일해야합니다.</target>
        </trans-unit>
        <trans-unit id="c41410f8fa129356669d6ff84f5e22cd64e4d0cb" translate="yes" xml:space="preserve">
          <source>The real sequence number of the OP, as a regular number and not adjusted to be relative to the start of the real program. (This will generally be a fairly large number because all of &lt;b&gt;B::Concise&lt;/b&gt; is compiled before your program is).</source>
          <target state="translated">OP의 실제 시퀀스 번호는 일반 번호이며 실제 프로그램의 시작에 상대적으로 조정되지 않습니다. ( &lt;b&gt;B :: Concise&lt;/b&gt; 는 모두 프로그램이 컴파일되기 전에 컴파일되기 때문에 일반적으로 상당히 큰 숫자 입니다).</target>
        </trans-unit>
        <trans-unit id="520aa3cfc6d3d06d2079bcf3cd80538cdc94136b" translate="yes" xml:space="preserve">
          <source>The real time timing is done using time(2) and the granularity is therefore only one second.</source>
          <target state="translated">실시간 타이밍은 time (2)를 사용하여 수행되므로 세분성은 1 초에 불과합니다.</target>
        </trans-unit>
        <trans-unit id="000f9aa1d39e9791c956bd280884dcab10bddcf9" translate="yes" xml:space="preserve">
          <source>The real uid of this process. You can change both the real uid and the effective uid at the same time by using &lt;code&gt;POSIX::setuid()&lt;/code&gt; . Since changes to &lt;code&gt;$&amp;lt;&lt;/code&gt; require a system call, check &lt;code&gt;$!&lt;/code&gt; after a change attempt to detect any possible errors.</source>
          <target state="translated">이 과정의 실제 UID. &lt;code&gt;POSIX::setuid()&lt;/code&gt; 사용하여 실제 uid와 유효 uid를 동시에 변경할 수 있습니다 . &lt;code&gt;$&amp;lt;&lt;/code&gt; 로 변경 하면 시스템 호출이 필요하므로 &lt;code&gt;$!&lt;/code&gt; 를 확인하십시오 . 변경 후 가능한 오류를 감지하려고합니다.</target>
        </trans-unit>
        <trans-unit id="2ac048e62e66a7879f9411bea5e557339bb43fff" translate="yes" xml:space="preserve">
          <source>The real uid of this process. You can change both the real uid and the effective uid at the same time by using &lt;code&gt;POSIX::setuid()&lt;/code&gt;. Since changes to &lt;code&gt;$&amp;lt;&lt;/code&gt; require a system call, check &lt;code&gt;$!&lt;/code&gt; after a change attempt to detect any possible errors.</source>
          <target state="translated">이 프로세스의 실제 uid. &lt;code&gt;POSIX::setuid()&lt;/code&gt; 사용하여 실제 uid와 유효 uid를 동시에 변경할 수 있습니다 . &lt;code&gt;$&amp;lt;&lt;/code&gt; 로 변경하려면 시스템 호출이 필요하므로 &lt;code&gt;$!&lt;/code&gt; 변경 후 가능한 오류를 감지하려고 시도합니다.</target>
        </trans-unit>
        <trans-unit id="226998a781d1d6550060a07be6fe5dd8d2b4b4b4" translate="yes" xml:space="preserve">
          <source>The real work is done in the standard typemap.</source>
          <target state="translated">실제 작업은 표준 유형 맵에서 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="c08e193bbc2bcd92c562519697a3487f212bcddb" translate="yes" xml:space="preserve">
          <source>The reason &lt;code&gt;encode_language_tag&lt;/code&gt; exists is because different language tags may represent the same language; this is normally treatable with &lt;code&gt;same_language_tag&lt;/code&gt; , but consider this situation:</source>
          <target state="translated">&lt;code&gt;encode_language_tag&lt;/code&gt; 가 존재 하는 이유 는 다른 언어 태그가 동일한 언어를 나타낼 수 있기 때문입니다. 일반적으로 &lt;code&gt;same_language_tag&lt;/code&gt; 로 처리 할 수 있지만 다음 상황을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="3ce46cd4af70310d3ca26a396ea6fdf7fb3672f3" translate="yes" xml:space="preserve">
          <source>The reason &lt;code&gt;encode_language_tag&lt;/code&gt; exists is because different language tags may represent the same language; this is normally treatable with &lt;code&gt;same_language_tag&lt;/code&gt;, but consider this situation:</source>
          <target state="translated">&lt;code&gt;encode_language_tag&lt;/code&gt; 가 존재 하는 이유 는 다른 언어 태그가 동일한 언어를 나타낼 수 있기 때문입니다. 이것은 일반적으로 &lt;code&gt;same_language_tag&lt;/code&gt; 로 처리 할 수 있지만 다음 상황을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="ca772eb153fd56cb7e89f09b86319ec24565520e" translate="yes" xml:space="preserve">
          <source>The reason I said &quot;in this instance&quot; is because that</source>
          <target state="translated">내가 &quot;이 경우에&quot;라고 말한 이유는</target>
        </trans-unit>
        <trans-unit id="739ee83789116c83fd6d7b4456cdd5e4f5143663" translate="yes" xml:space="preserve">
          <source>The reason for not checking the return value from print() is because of pipe buffering; physical writes are delayed. That won't blow up until the close, and it will blow up with a SIGPIPE. To catch it, you could use this:</source>
          <target state="translated">print ()에서 리턴 값을 확인하지 않는 이유는 파이프 버퍼링 때문입니다. 물리적 쓰기가 지연됩니다. 닫힐 때까지 폭발하지 않으며 SIGPIPE와 함께 폭발합니다. 그것을 잡기 위해 이것을 사용할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="5243164bf937a2da41254af85f8953f57eda8b63" translate="yes" xml:space="preserve">
          <source>The reason for the bailout.</source>
          <target state="translated">구제 금융의 이유.</target>
        </trans-unit>
        <trans-unit id="ff2ad92ed56d2b83c1783a3daf037c2fcef9e124" translate="yes" xml:space="preserve">
          <source>The reason for the exception.</source>
          <target state="translated">예외의 이유입니다.</target>
        </trans-unit>
        <trans-unit id="58e74d3011543f0cacc6e865a92179ab3feabba8" translate="yes" xml:space="preserve">
          <source>The reason for the skip, todo etc. See &lt;a href=&quot;Test::Builder&quot;&gt;Test::Builder&lt;/a&gt; for more details.</source>
          <target state="translated">건너 뛰기, 할 일 등의 이유. 자세한 내용은 &lt;a href=&quot;Test::Builder&quot;&gt;Test :: Builder&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="b3e75d2f4213b8c35d2937b292cccac3d8a1e38d" translate="yes" xml:space="preserve">
          <source>The reason for this is that CPAN does not know the dependencies of all modules when it starts out. To decide about the additional items to install, it just uses data found in the META.yml file or the generated Makefile. An undetected missing piece breaks the process. But it may well be that your Bundle installs some prerequisite later than some depending item and thus your second try is able to resolve everything. Please note, CPAN.pm does not know the dependency tree in advance and cannot sort the queue of things to install in a topologically correct order. It resolves perfectly well &lt;b&gt;if&lt;/b&gt; all modules declare the prerequisites correctly with the PREREQ_PM attribute to MakeMaker or the &lt;code&gt;requires&lt;/code&gt; stanza of Module::Build. For bundles which fail and you need to install often, it is recommended to sort the Bundle definition file manually.</source>
          <target state="translated">그 이유는 CPAN이 시작할 때 모든 모듈의 종속성을 알지 못하기 때문입니다. 설치할 추가 항목을 결정하기 위해 META.yml 파일 또는 생성 된 Makefile에있는 데이터 만 사용합니다. 감지되지 않은 누락 된 조각은 프로세스를 중단시킵니다. 그러나 번들은 일부 종속 항목보다 나중에 일부 전제 조건을 설치하므로 두 번째 시도로 모든 것을 해결할 수 있습니다. CPAN.pm은 종속성 트리를 미리 알지 못하므로 설치할 항목 큐를 토폴로지 적으로 올바른 순서로 정렬 할 수 없습니다. 그것은 완벽하게 잘 해결 &lt;b&gt;하면&lt;/b&gt; 모든 모듈이 MakeMaker 또는에 PREREQ_PM 속성을 제대로 전제 조건을 선언이 &lt;code&gt;requires&lt;/code&gt; Module :: Build의 스탠자. 실패한 번들을 자주 설치해야하는 경우 번들 정의 파일을 수동으로 정렬하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="9dfe6b3d7e7af99fa8c5c069ac28ca23f9e16764" translate="yes" xml:space="preserve">
          <source>The reason for this is that the &lt;a href=&quot;version#numify%28%29&quot;&gt;numify()&lt;/a&gt; operator will turn &quot;v1.0&quot; into the equivalent string &quot;1.000000&quot;. Forcing the outer version object to &lt;a href=&quot;version#normal%28%29&quot;&gt;normal()&lt;/a&gt; form will display the mathematically equivalent &quot;v1.0.0&quot;.</source>
          <target state="translated">그 이유는 &lt;a href=&quot;version#numify%28%29&quot;&gt;numify ()&lt;/a&gt; 연산자가 &quot;v1.0&quot;을 동일한 문자열 &quot;1.000000&quot;으로 변환하기 때문입니다. 외부 버전 객체를 &lt;a href=&quot;version#normal%28%29&quot;&gt;normal ()&lt;/a&gt; 형식으로 강제하면 수학적으로 동일한 &quot;v1.0.0&quot;이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="5fa379384b7d494ede930080ac4d01947c2521a8" translate="yes" xml:space="preserve">
          <source>The reason for this unusability is that a fundamental assumption of Perl is that the characters it cares about for parsing and lexical analysis are the same whether or not the text is in UTF-8. For example, Perl expects the character &lt;code&gt;&quot;[&quot;&lt;/code&gt; to have the same representation, no matter if the string containing it (or program text) is UTF-8 encoded or not. To ensure this, Perl adapts UTF-EBCDIC to the particular code page so that all characters it expects to be UTF-8 invariant are in fact UTF-8 invariant. This means that text generated on a computer running one version of Perl's UTF-EBCDIC has to be translated to be intelligible to a computer running another.</source>
          <target state="translated">이 사용 불가능성에 대한 이유는 Perl의 기본 가정은 구문 분석 및 어휘 분석에 관심이있는 문자가 텍스트가 UTF-8인지 여부에 관계없이 동일하기 때문입니다. 예를 들어, Perl은 &lt;code&gt;&quot;[&quot;&lt;/code&gt; 문자를 포함하는 문자열 (또는 프로그램 텍스트)이 UTF-8로 인코딩되었는지 여부에 관계없이 문자 &quot;[&quot; 가 동일한 표현을 가질 것으로 예상합니다 . 이를 보장하기 위해 Perl은 UTF-EBCDIC을 특정 코드 페이지에 맞게 조정하여 UTF-8 불변 일 것으로 예상되는 모든 문자가 실제로 UTF-8 불변 일 수 있도록합니다. 이는 Perl의 UTF-EBCDIC 버전을 실행하는 컴퓨터에서 생성 된 텍스트가 다른 버전을 실행하는 컴퓨터에서 이해할 수 있도록 번역되어야 함을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="148e8f8b4033e043ed0349ade3e3972ed042dff2" translate="yes" xml:space="preserve">
          <source>The reason is that Encode::Guess guesses encoding by trial and error. It first splits $data into lines and tries to decode the line for each suspect. It keeps it going until all but one encoding is eliminated out of suspects list. ISO-8859 series is just too successful for most cases (because it fills almost all code points in \x00-\xff).</source>
          <target state="translated">그 이유는 Encode :: Guess가 시행 착오로 인코딩을 추측하기 때문입니다. 먼저 $ data를 줄로 나누고 각 용의자에 대한 줄을 해독하려고 시도합니다. 하나의 인코딩을 제외한 모든 인코딩이 용의자 목록에서 제거 될 때까지 계속 진행됩니다. ISO-8859 시리즈는 대부분의 경우 너무 성공합니다 (\ x00- \ xff의 거의 모든 코드 포인트를 채우므로).</target>
        </trans-unit>
        <trans-unit id="94742df1b378e1ee0c32933e905c9b3866f15f37" translate="yes" xml:space="preserve">
          <source>The reason is that variable interpolation and code expressions together pose a security risk. The combination is dangerous because many programmers who write search engines often take user input and plug it directly into a regexp:</source>
          <target state="translated">변수 보간과 코드 표현식이 함께 보안 상 위험하기 때문입니다. 검색 엔진을 작성하는 많은 프로그래머가 종종 사용자 입력을 받아 정규 표현식에 직접 연결하기 때문에이 조합은 위험합니다.</target>
        </trans-unit>
        <trans-unit id="c8fa70ef72504bbb3f7d6986506b4705b0ceb70a" translate="yes" xml:space="preserve">
          <source>The reason is that vendor encoding is usually a superset of national standard so it becomes too ambiguous for most cases.</source>
          <target state="translated">벤더 인코딩은 일반적으로 국가 표준의 상위 집합이므로 대부분의 경우 너무 모호해지기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="76e332a13c138bbbc50c17d9967b9928970c16a2" translate="yes" xml:space="preserve">
          <source>The reason it isn't quite a drop-in replacement is actually an advantage. The only difference is that it returns &lt;code&gt;const char *&lt;/code&gt;, whereas plain &lt;code&gt;nl_langinfo()&lt;/code&gt; returns &lt;code&gt;char *&lt;/code&gt;, but you are (only by documentation) forbidden to write into the buffer. By declaring this &lt;code&gt;const&lt;/code&gt;, the compiler enforces this restriction, so if it is violated, you know at compilation time, rather than getting segfaults at runtime.</source>
          <target state="translated">드롭 인 교체가 아닌 이유는 실제로 이점입니다. 유일한 차이점은 &lt;code&gt;const char *&lt;/code&gt; 를 반환 하는 반면 일반 &lt;code&gt;nl_langinfo()&lt;/code&gt; 는 &lt;code&gt;char *&lt;/code&gt; 를 반환 하지만 (문서에 의해서만) 버퍼에 쓸 수 없다는 것 입니다. 이 &lt;code&gt;const&lt;/code&gt; 를 선언 하면 컴파일러가이 제한을 적용하므로 위반 된 경우 런타임에 segfault를 가져 오는 대신 컴파일 시간에 알 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2e0f1d70e28ee48bb2440f0dfad9e2b39b29922f" translate="yes" xml:space="preserve">
          <source>The reason that &lt;code&gt;host $failed_ack_host&lt;/code&gt; did not receive a valid ACK. Useful to find out why when &lt;code&gt;ack($fail_ack_host)&lt;/code&gt; returns a false value.</source>
          <target state="translated">&lt;code&gt;host $failed_ack_host&lt;/code&gt; 가 유효한 ACK를받지 못한 이유입니다 . &lt;code&gt;ack($fail_ack_host)&lt;/code&gt; 가 거짓 값을 반환하는 이유를 알아내는 데 유용 합니다.</target>
        </trans-unit>
        <trans-unit id="fedf7056008fbc98297422a200d9b784c0b8db45" translate="yes" xml:space="preserve">
          <source>The reason that doesn't do what you want is because assigning a named array like that to a scalar is taking an array in scalar context, which means just counts the number of elements in @tmp.</source>
          <target state="translated">원하는 것을하지 않는 이유는 명명 된 배열을 스칼라에 할당하는 것이 스칼라 컨텍스트에서 배열을 취하기 때문입니다. 즉 @tmp의 요소 수를 계산합니다.</target>
        </trans-unit>
        <trans-unit id="550ff1bc08b0298c35cdd00d235a478cadb820d7" translate="yes" xml:space="preserve">
          <source>The reason that host $failed_ack_host did not receive a valid ACK. Useful to find out why when ack( $fail_ack_host ) returns a false value.</source>
          <target state="translated">호스트 $ failed_ack_host가 유효한 ACK를받지 못한 이유입니다. ack ($ fail_ack_host)가 false 값을 반환하는 이유를 찾는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="761e66631890fba3f96026c5ab632825150c6b23" translate="yes" xml:space="preserve">
          <source>The reason that using gettext runs into walls (as in the above second-person horror story) is that you're trying to use a string (or worse, a choice among a bunch of strings) to do what you really need a function for -- which is futile. Preforming (s)printf interpolation on the strings which you get back from gettext does allow you to do</source>
          <target state="translated">gettext를 사용하는 이유는 (위의 2 인칭 공포 이야기에서와 같이) 문자열을 사용하여 실제로 필요한 기능을 수행하려고하기 때문입니다. -쓸데없는 일입니다. gettext에서 얻은 문자열에 대한 (s) printf 보간을 미리 형성하면 다음을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="251bb3c15e15e0ec21516300833b60efe1125c75" translate="yes" xml:space="preserve">
          <source>The reason this function has &quot;_strictly&quot; in its name is that when you're processing an Accept-Language list according to the RFCs, if you interpret the RFCs quite strictly, then you would use implicate_supers_strictly, but for normal use (i.e., common-sense use, as far as I'm concerned) you'd use implicate_supers.</source>
          <target state="translated">이 함수의 이름에 &quot;_strictly&quot;가있는 이유는 RFC에 따라 Accept-Language 목록을 처리 할 때 RFC를 매우 엄격하게 해석하면 implicate_supers_strictly를 사용하지만 일반적으로 사용하기 때문입니다. -내가 아는 한, 감각 사용) 당신은 implicate_supers를 사용할 것입니다.</target>
        </trans-unit>
        <trans-unit id="00e0d83a9d5edf83f32ea0d0701c8b2f4b38f236" translate="yes" xml:space="preserve">
          <source>The reason this is considered to be only partially implemented is that Perl has &lt;a href=&quot;perlrebackslash#%5Cb%7Blb%7D&quot;&gt;&lt;code&gt;qr/\b{lb}/&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;&lt;a href=&quot;Unicode::LineBreak&quot;&gt;Unicode::LineBreak&lt;/a&gt;&lt;/code&gt; that are conformant with &lt;a href=&quot;https://www.unicode.org/reports/tr14&quot;&gt;UAX#14 &quot;Unicode Line Breaking Algorithm&quot;&lt;/a&gt;. The regular expression construct provides default behavior, while the heavier-weight module provides customizable line breaking.</source>
          <target state="translated">이것이 부분적으로 만 구현 된 것으로 간주되는 이유는 Perl이 &lt;a href=&quot;https://www.unicode.org/reports/tr14&quot;&gt;UAX # 14 &quot;Unicode Line Breaking Algorithm&quot;을&lt;/a&gt; 준수하는 &lt;a href=&quot;perlrebackslash#%5Cb%7Blb%7D&quot;&gt; &lt;code&gt;qr/\b{lb}/&lt;/code&gt; &lt;/a&gt; 및 &lt;code&gt;&lt;a href=&quot;Unicode::LineBreak&quot;&gt;Unicode::LineBreak&lt;/a&gt;&lt;/code&gt; 가지고 있기 때문 입니다. 정규식 구조는 기본 동작을 제공하는 반면 무거운 무게 모듈은 사용자 정의 가능한 줄 바꿈을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="e1005d9c83a9fa9fcbc88e4d2084838b8de52293" translate="yes" xml:space="preserve">
          <source>The reason this is necessary is that the area of the Perl stack which held them will very likely have been overwritten by something else by the time control returns from</source>
          <target state="translated">이것이 필요한 이유는 시간 제어가 반환 된 펄 스택 영역이 다른 것에 의해 덮어 쓰여졌 기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="7f8610d66bd9a8ef9ccb75cedd8c737641eb770d" translate="yes" xml:space="preserve">
          <source>The reason this is not default behaviour is because RFC 1951 content can only be detected by attempting to uncompress it. This process is error prone and can result is false positives.</source>
          <target state="translated">이것이 기본 동작이 아닌 이유는 압축을 풀어야 만 RFC 1951 컨텐츠를 감지 할 수 있기 때문입니다. 이 프로세스는 오류가 발생하기 쉽고 오 탐지가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="19bd78bd51bc1c56b13d7881beac1baa5b73fb31" translate="yes" xml:space="preserve">
          <source>The reason this is not default behaviour is because lzma_alone content can only be detected by attempting to uncompress it. This process is error prone and can result is false positives.</source>
          <target state="translated">이것이 기본 동작이 아닌 이유는 lzma_alone 컨텐츠는 압축 해제를 시도해야만 감지 할 수 있기 때문입니다. 이 프로세스는 오류가 발생하기 쉽고 오 탐지 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="28f02f8a8e5a76ee5006992d613d3802d772737a" translate="yes" xml:space="preserve">
          <source>The reason this is wrong is that, by the time you come to use the pointer &lt;code&gt;rememberSub&lt;/code&gt; in &lt;code&gt;CallSavedSub1&lt;/code&gt; , it may or may not still refer to the Perl subroutine that was recorded in &lt;code&gt;SaveSub1&lt;/code&gt; . This is particularly true for these cases:</source>
          <target state="translated">이 잘못된 이유는, 당신은 포인터 사용 오는 시간이다 &lt;code&gt;rememberSub&lt;/code&gt; 에서 &lt;code&gt;CallSavedSub1&lt;/code&gt; 를 , 그것은 또는 정지에 기록 된 펄 서브 루틴을 참조하지 않을 수 있습니다 &lt;code&gt;SaveSub1&lt;/code&gt; . 다음과 같은 경우에 특히 그렇습니다.</target>
        </trans-unit>
        <trans-unit id="e2bf2d952027d4fe995c4250ed0910c8a499fa98" translate="yes" xml:space="preserve">
          <source>The reason this is wrong is that, by the time you come to use the pointer &lt;code&gt;rememberSub&lt;/code&gt; in &lt;code&gt;CallSavedSub1&lt;/code&gt;, it may or may not still refer to the Perl subroutine that was recorded in &lt;code&gt;SaveSub1&lt;/code&gt;. This is particularly true for these cases:</source>
          <target state="translated">이것이 잘못된 이유는 &lt;code&gt;CallSavedSub1&lt;/code&gt; 에서 포인터 &lt;code&gt;rememberSub&lt;/code&gt; 를 사용할 때 까지 SaveSub1 에 기록 된 Perl 서브 루틴을 참조 할 수도 있고 참조하지 않을 수도 &lt;code&gt;SaveSub1&lt;/code&gt; 입니다. 이는 특히 다음과 같은 경우에 해당됩니다.</target>
        </trans-unit>
        <trans-unit id="1fc61e22be627df80a7651746e52decec2ded90a" translate="yes" xml:space="preserve">
          <source>The reasons for most important skipped tests are:</source>
          <target state="translated">가장 중요한 생략 된 테스트의 이유는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="cc1622b786a9a5b8c43f01f8734a1a12e356f528" translate="yes" xml:space="preserve">
          <source>The recognized bright background color attributes (colors 8 to 15) are:</source>
          <target state="translated">인식되는 밝은 배경색 속성 (8 ~ 15 색)은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6c5d4a5f4c9a09fda354809420b2cbe2f30c42f0" translate="yes" xml:space="preserve">
          <source>The recognized normal background color attributes (colors 0 to 7) are:</source>
          <target state="translated">인식되는 일반 배경색 속성 (색상 0 ~ 7)은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4a93814d53d2a583e73a218be86053c6699847f6" translate="yes" xml:space="preserve">
          <source>The recognized normal foreground color attributes (colors 0 to 7) are:</source>
          <target state="translated">인식되는 일반 전경색 속성 (색상 0 ~ 7)은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c8d8fb33b8f8ad299c896b38af940448a2194ca3" translate="yes" xml:space="preserve">
          <source>The recognized options to new() are as follows. All options take a single argument.</source>
          <target state="translated">new ()에 대해 인식되는 옵션은 다음과 같습니다. 모든 옵션은 단일 인수를 취합니다.</target>
        </trans-unit>
        <trans-unit id="1e562f76f9cdb0ef2aab453d2c38556cc6a6334d" translate="yes" xml:space="preserve">
          <source>The recommended compiler to use in Tru64 is the native C compiler. The native compiler produces much faster code (the speed difference is noticeable: several dozen percentages) and also more correct code: if you are considering using the GNU C compiler you should use at the very least the release of 2.95.3 since all older gcc releases are known to produce broken code when compiling Perl. One manifestation of this brokenness is the lib/sdbm test dumping core; another is many of the op/regexp and op/pat, or ext/Storable tests dumping core (the exact pattern of failures depending on the GCC release and optimization flags).</source>
          <target state="translated">Tru64에서 권장되는 컴파일러는 네이티브 C 컴파일러입니다. 네이티브 컴파일러는 훨씬 빠른 코드 (속도 차이가 눈에 띄게 : 수십 퍼센트)와 더 정확한 코드를 생성합니다. GNU C 컴파일러 사용을 고려하는 경우 모든 이전 gcc 이후로 최소한 2.95.3 릴리스를 사용해야합니다 릴리스는 Perl을 컴파일 할 때 깨진 코드를 생성하는 것으로 알려져 있습니다. 이러한 손상의 한 가지 징후는 lib / sdbm 테스트 덤핑 코어입니다. 또 다른 하나는 op / regexp 및 op / pat 또는 ext / Storable 테스트 덤프 코어 (GCC 릴리스 및 최적화 플래그에 따른 정확한 실패 패턴)입니다.</target>
        </trans-unit>
        <trans-unit id="a954751580ed0f6e74f6ae52a458e3decc2b6782" translate="yes" xml:space="preserve">
          <source>The recommended order of sections in Perl module documentation is:</source>
          <target state="translated">Perl 모듈 문서에서 권장되는 섹션 순서는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="da2bd70489cefb603292ce8b5cfe4c6cae04aaf7" translate="yes" xml:space="preserve">
          <source>The recommended way to build Perl for the OS/400 PASE is to build the Perl 5 source code (release 5.8.1 or later) under AIX.</source>
          <target state="translated">OS / 400 PASE에 Perl을 빌드하는 권장 방법은 AIX에서 Perl 5 소스 코드 (릴리스 5.8.1 이상)를 빌드하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="e06b04ad5d41fce493c0b00ecf1ca37dfa5afcff" translate="yes" xml:space="preserve">
          <source>The red() and green() functions would be similar. To create these, we'll assign a closure to a typeglob of the name of the function we're trying to build.</source>
          <target state="translated">red () 및 green () 함수는 비슷합니다. 이를 만들기 위해 빌드하려는 함수 이름의 typeglob에 클로저를 할당합니다.</target>
        </trans-unit>
        <trans-unit id="f9a173256f222e6807faedf390f953793a1d344d" translate="yes" xml:space="preserve">
          <source>The refcount of &lt;code&gt;sv&lt;/code&gt; will be decremented at the end of</source>
          <target state="translated">&lt;code&gt;sv&lt;/code&gt; 의 refcount 는</target>
        </trans-unit>
        <trans-unit id="1d461f380b420e2f92a59ecbfaa16c7256f214ff" translate="yes" xml:space="preserve">
          <source>The refcount of &lt;code&gt;sv&lt;/code&gt; would be decremented at the end of</source>
          <target state="translated">&lt;code&gt;sv&lt;/code&gt; 의 참조 횟수 는</target>
        </trans-unit>
        <trans-unit id="aa0554de1d883a744516c47aa9649afa91c2844b" translate="yes" xml:space="preserve">
          <source>The reference count for each specified &lt;code&gt;SV*&lt;/code&gt; parameter is decremented.</source>
          <target state="translated">지정된 각 &lt;code&gt;SV*&lt;/code&gt; 매개 변수 의 참조 카운트 가 감소합니다.</target>
        </trans-unit>
        <trans-unit id="2beb795bee8f23385c682524158dfa3883714ef0" translate="yes" xml:space="preserve">
          <source>The reference count of the pad name list.</source>
          <target state="translated">패드 이름 목록의 참조 횟수입니다.</target>
        </trans-unit>
        <trans-unit id="ed87a4c5aaea6eeced4317ed59578fe0847b6b0f" translate="yes" xml:space="preserve">
          <source>The reference count of the pad name.</source>
          <target state="translated">패드 이름의 참조 카운트.</target>
        </trans-unit>
        <trans-unit id="0f3b4f395e70b832ec180500f62bfe30abfdf04c" translate="yes" xml:space="preserve">
          <source>The reference count of the padlist. Currently this is always 1.</source>
          <target state="translated">패드리스트의 참조 카운트. 현재 이것은 항상 1입니다.</target>
        </trans-unit>
        <trans-unit id="b9e9c4a001467c1b7e5e43bb821f471e292d9d31" translate="yes" xml:space="preserve">
          <source>The reference from &lt;code&gt;$foo&lt;/code&gt; to &lt;code&gt;$bar&lt;/code&gt; has been weakened. When the &lt;code&gt;$bar&lt;/code&gt; variable goes out of scope, it will be garbage-collected. The next time you look at the value of the &lt;code&gt;$foo-&amp;gt;{bar}&lt;/code&gt; key, it will be &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;$foo&lt;/code&gt; 에서 &lt;code&gt;$bar&lt;/code&gt; 로의 참조 가 약해졌습니다. 때 &lt;code&gt;$bar&lt;/code&gt; 변수가 범위를 벗어나, 그것은 가비지 수집 될 것입니다. 다음에 &lt;code&gt;$foo-&amp;gt;{bar}&lt;/code&gt; 키 의 값을 보면 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 가 됩니다.</target>
        </trans-unit>
        <trans-unit id="a1de879124c2751ad3ecd4b63c57cecfe27d3f64" translate="yes" xml:space="preserve">
          <source>The reference from &lt;code&gt;$foo&lt;/code&gt; to &lt;code&gt;$bar&lt;/code&gt; has been weakened. When the &lt;code&gt;$bar&lt;/code&gt; variable goes out of scope, it will be garbage-collected. The next time you look at the value of the &lt;code&gt;$foo-&amp;gt;{bar}&lt;/code&gt; key, it will be &lt;code&gt;undef&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;$foo&lt;/code&gt; 에서 &lt;code&gt;$bar&lt;/code&gt; 로의 참조 가 약화되었습니다. 때 &lt;code&gt;$bar&lt;/code&gt; 변수가 범위를 벗어나, 그것은 가비지 수집 될 것입니다. 다음에 &lt;code&gt;$foo-&amp;gt;{bar}&lt;/code&gt; 키 의 값을 보면 &lt;code&gt;undef&lt;/code&gt; 가 됩니다.</target>
        </trans-unit>
        <trans-unit id="3fc857a94806f2c57cbbf2e2dd2d2b88b08c2fe6" translate="yes" xml:space="preserve">
          <source>The reference is truly dumped and we can finally see what we're dealing with. Our quoting was perfectly valid but wrong for our purposes, with 'and jerry' being treated as 2 separate words rather than a phrase, thus throwing the evenly paired hash structure out of alignment.</source>
          <target state="translated">참조는 실제로 버려지고 마침내 우리가 다루고있는 것을 볼 수 있습니다. 우리의 인용은 완벽하게 유효하지만 우리의 목적에 맞지 않습니다. '와 jerry'는 문구가 아닌 두 개의 분리 된 단어로 취급되어 고르게 짝을 이루는 해시 구조를 정렬에서 제외시킵니다.</target>
        </trans-unit>
        <trans-unit id="4adfd6b1f7abb309b66c9315a05ff37197f3a0fe" translate="yes" xml:space="preserve">
          <source>The references you get from rule 2 are the same kind of references that you get from rule 1:</source>
          <target state="translated">규칙 2에서 얻은 참조는 규칙 1에서 가져온 것과 동일한 종류의 참조입니다.</target>
        </trans-unit>
        <trans-unit id="4f2739050aee8d49851e25b790d128e1ca19fbde" translate="yes" xml:space="preserve">
          <source>The regex_sets feature is experimental</source>
          <target state="translated">regex_sets 기능은 실험적입니다.</target>
        </trans-unit>
        <trans-unit id="4c14a48971a0368f8bbf545f9e2905f7ac019ed5" translate="yes" xml:space="preserve">
          <source>The regexp has a single grouping which considers 4-letter combinations, then 3-letter combinations,</source>
          <target state="translated">정규 표현식에는 4 글자 조합, 3 글자 조합을 고려하는 단일 그룹이 있습니다.</target>
        </trans-unit>
        <trans-unit id="168bedf74d17b291ff7d2c437f9134d9006e0ffe" translate="yes" xml:space="preserve">
          <source>The regexp has a single grouping which considers 4-letter combinations, then 3-letter combinations, etc., and uses &lt;code&gt;\g1&lt;/code&gt; to look for a repeat. Although &lt;code&gt;$1&lt;/code&gt; and &lt;code&gt;\g1&lt;/code&gt; represent the same thing, care should be taken to use matched variables &lt;code&gt;$1&lt;/code&gt; , &lt;code&gt;$2&lt;/code&gt; ,... only</source>
          <target state="translated">정규 표현식에는 단일 문자 그룹화가 있으며 4 문자 조합, 3 문자 조합 등을 고려하고 &lt;code&gt;\g1&lt;/code&gt; 을 사용 하여 반복을 찾습니다. 하지만 &lt;code&gt;$1&lt;/code&gt; 과 &lt;code&gt;\g1&lt;/code&gt; 같은 일을 대표하는주의가 일치 변수를 사용하도록주의해야한다 &lt;code&gt;$1&lt;/code&gt; , &lt;code&gt;$2&lt;/code&gt; , ... 만</target>
        </trans-unit>
        <trans-unit id="d1eb9cbcdcc85f0afd97e3812b595b9e1f6b3fd8" translate="yes" xml:space="preserve">
          <source>The regexp matches an open parenthesis, one or more copies of an alternation, and a close parenthesis. The alternation is two-way, with the first alternative &lt;code&gt;[^()]+&lt;/code&gt; matching a substring with no parentheses and the second alternative &lt;code&gt;\([^()]*\)&lt;/code&gt; matching a substring delimited by parentheses. The problem with this regexp is that it is pathological: it has nested indeterminate quantifiers of the form &lt;code&gt;(a+|b)+&lt;/code&gt;. We discussed in Part 1 how nested quantifiers like this could take an exponentially long time to execute if there was no match possible. To prevent the exponential blowup, we need to prevent useless backtracking at some point. This can be done by enclosing the inner quantifier as an independent subexpression:</source>
          <target state="translated">정규 표현식은 열린 괄호, 하나 이상의 대체 사본 및 가까운 괄호와 일치합니다. 대체는 양방향이며, 첫 번째 대안 &lt;code&gt;[^()]+&lt;/code&gt; 는 괄호없이 하위 문자열과 일치하고 두 번째 대안 &lt;code&gt;\([^()]*\)&lt;/code&gt; 는 괄호로 구분 된 하위 문자열과 일치합니다. 이 정규 표현식의 문제점은 병리학 적이라는 것입니다. &lt;code&gt;(a+|b)+&lt;/code&gt; 형식의 불확실한 정량자가 중첩되어 있습니다. 1 부에서 이와 같은 중첩 수량 화기가 일치하는 항목이없는 경우 실행하는 데 시간이 오래 걸리는 방법에 대해 논의했습니다. 기하 급수적 인 폭파를 방지하기 위해 어느 시점에서 쓸모없는 역 추적을 방지해야합니다. 내부 정량자를 독립 하위 표현식으로 묶어 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="368bf455728e0cc079751b44e9fea4161849b273" translate="yes" xml:space="preserve">
          <source>The regexp structure contains all the data that perl needs to be aware of to properly work with the regular expression. It includes data about optimisations that perl can use to determine if the regex engine should really be used, and various other control info that is needed to properly execute patterns in various contexts such as is the pattern anchored in some way, or what flags were used during the compile, or whether the program contains special constructs that perl needs to be aware of.</source>
          <target state="translated">정규 표현식 구조에는 정규 표현식을 올바르게 사용하기 위해 perl이 알아야 할 모든 데이터가 포함됩니다. 여기에는 perl이 정규식 엔진을 실제로 사용해야하는지 여부를 결정하는 데 사용할 수있는 최적화에 대한 데이터와 어떤 방식으로 고정 된 패턴과 같은 다양한 컨텍스트에서 패턴을 올바르게 실행하는 데 필요한 다양한 기타 제어 정보 또는 사용 된 플래그가 포함됩니다. 컴파일 중 또는 프로그램에 perl이 알고 있어야하는 특수 구문이 포함되어 있는지 여부</target>
        </trans-unit>
        <trans-unit id="c3c54f92228f6f05bcc0bda8517b5a88720264e3" translate="yes" xml:space="preserve">
          <source>The regexp without the &lt;code&gt;//x&lt;/code&gt; modifier is</source>
          <target state="translated">&lt;code&gt;//x&lt;/code&gt; 수정자가 없는 정규식 은</target>
        </trans-unit>
        <trans-unit id="cd0504e6dcc01ce1582fd08d19ab6d72b18efd43" translate="yes" xml:space="preserve">
          <source>The regops are defined in</source>
          <target state="translated">레고는</target>
        </trans-unit>
        <trans-unit id="398b15f4cf9df5e68a324633c771b534053133cc" translate="yes" xml:space="preserve">
          <source>The regression tests for each operator live in</source>
          <target state="translated">각 운영자에 대한 회귀 테스트는</target>
        </trans-unit>
        <trans-unit id="1185c36b91985e4291f68ed8a08b57d301b0c6f7" translate="yes" xml:space="preserve">
          <source>The regular expression engine can be a weighty tool to wield. On long strings and complex patterns it can end up having to do a lot of work to find a match, and even more to decide that no match is possible. Consider a situation like the following pattern.</source>
          <target state="translated">정규식 엔진은 휘두르는 데 중요한 도구가 될 수 있습니다. 긴 문자열과 복잡한 패턴에서는 일치하는 항목을 찾기 위해 많은 작업을 수행해야하며 일치하는 항목이 없다고 결정해야 할 수도 있습니다. 다음 패턴과 같은 상황을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="550e74d9d02bffd01cf3b652c4e172b2d8cb3f39" translate="yes" xml:space="preserve">
          <source>The regular expression to execute.</source>
          <target state="translated">실행할 정규식입니다.</target>
        </trans-unit>
        <trans-unit id="8c3b3408d3eb9771532acb10a043be225a8f7a49" translate="yes" xml:space="preserve">
          <source>The regular expression to match the balanced text uses two new (to Perl 5.10) regular expression features. These are covered in &lt;a href=&quot;perlre&quot;&gt;perlre&lt;/a&gt; and this example is a modified version of one in that documentation.</source>
          <target state="translated">균형 잡힌 텍스트와 일치하는 정규 표현식은 두 가지 새로운 (Perl 5.10까지) 정규 표현식 기능을 사용합니다. 이것들은 &lt;a href=&quot;perlre&quot;&gt;perlre&lt;/a&gt; 에서 다루고 있으며이 예제는 그 문서에서 수정 된 버전입니다.</target>
        </trans-unit>
        <trans-unit id="7b89c7165c60ab0797d1970f7d1380e29eaa0008" translate="yes" xml:space="preserve">
          <source>The related &lt;code&gt;base&lt;/code&gt; pragma will combine fields from base classes and any fields declared using the &lt;code&gt;fields&lt;/code&gt; pragma. This enables field inheritance to work properly. Inherited fields can be overridden but will generate a warning if warnings are enabled.</source>
          <target state="translated">관련 &lt;code&gt;base&lt;/code&gt; pragma는 기본 클래스의 &lt;code&gt;fields&lt;/code&gt; pragma 필드를 사용하여 선언 된 모든 필드를 결합합니다 . 이를 통해 필드 상속이 올바르게 작동합니다. 상속 된 필드는 재정의 될 수 있지만 경고가 활성화되면 경고가 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="31c9eb432cfde9dbb8b6575337f7f66a6d53cbda" translate="yes" xml:space="preserve">
          <source>The relevant snippet from &lt;code&gt;Perl_pp_regcomp&lt;/code&gt; :</source>
          <target state="translated">&lt;code&gt;Perl_pp_regcomp&lt;/code&gt; 의 관련 스 니펫 :</target>
        </trans-unit>
        <trans-unit id="86d45b748524cf3c3ed19b4942d99f6682b785f8" translate="yes" xml:space="preserve">
          <source>The relevant snippet from &lt;code&gt;Perl_pp_regcomp&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;Perl_pp_regcomp&lt;/code&gt; 의 관련 스 니펫 :</target>
        </trans-unit>
        <trans-unit id="99cbb925914614f38c9cb5913b1dca990337342e" translate="yes" xml:space="preserve">
          <source>The remainder of the input string (i.e. the characters after the extracted string). On failure, the entire string is returned.</source>
          <target state="translated">입력 문자열의 나머지 (예 : 추출 된 문자열 뒤의 문자) 실패하면 전체 문자열이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="efbd63ef88d15920cb0b989c9bf11dcb1d2eacf4" translate="yes" xml:space="preserve">
          <source>The remaining arguments list the files to be included in the tar file. These files must all exist. Any files which don't exist or can't be read are silently ignored.</source>
          <target state="translated">나머지 인수는 tar 파일에 포함될 파일을 나열합니다. 이 파일들은 모두 존재해야합니다. 존재하지 않거나 읽을 수없는 파일은 자동으로 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="f73744579f886d96e9ed158f08b1414dc3c821e4" translate="yes" xml:space="preserve">
          <source>The remaining fields specify the starting and ending cylinder and head of the range of tracks to be formatted.</source>
          <target state="translated">나머지 필드는 포맷 할 트랙 범위의 시작 및 끝 실린더와 헤드를 지정합니다.</target>
        </trans-unit>
        <trans-unit id="1833f6078478dddd497b7e7b088899346fc9339d" translate="yes" xml:space="preserve">
          <source>The remaining list-reduction functions are all specialisations of this generic idea.</source>
          <target state="translated">나머지리스트-감소 함수는이 일반적인 아이디어의 모든 특수화입니다.</target>
        </trans-unit>
        <trans-unit id="5790bf8249cfb740e1105f12c204270f7d624a65" translate="yes" xml:space="preserve">
          <source>The remaining locale categories are not currently used by Perl itself. But again note that things Perl interacts with may use these, including extensions outside the standard Perl distribution, and by the operating system and its utilities. Note especially that the string value of &lt;code&gt;$!&lt;/code&gt; and the error messages given by external utilities may be changed by &lt;code&gt;LC_MESSAGES&lt;/code&gt; . If you want to have portable error codes, use &lt;code&gt;%!&lt;/code&gt; . See &lt;a href=&quot;errno&quot;&gt;Errno&lt;/a&gt;.</source>
          <target state="translated">나머지 로케일 범주는 현재 Perl 자체에서 사용되지 않습니다. 그러나 Perl과 상호 작용하는 것은 표준 Perl 배포 외부의 확장, 운영 체제 및 유틸리티에 의한 확장을 포함하여 이러한 기능을 사용할 수 있습니다. 특히 문자열 값은 &lt;code&gt;$!&lt;/code&gt; 외부 유틸리티가 제공 한 오류 메시지는 &lt;code&gt;LC_MESSAGES&lt;/code&gt; 에 의해 변경 될 수 있습니다 . 휴대용 오류 코드를 원하면 &lt;code&gt;%!&lt;/code&gt; 사용하십시오 ! . &lt;a href=&quot;errno&quot;&gt;Errno를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c93d95569d58cc954c309a9c37710dcae16b378b" translate="yes" xml:space="preserve">
          <source>The remaining locale categories are not currently used by Perl itself. But again note that things Perl interacts with may use these, including extensions outside the standard Perl distribution, and by the operating system and its utilities. Note especially that the string value of &lt;code&gt;$!&lt;/code&gt; and the error messages given by external utilities may be changed by &lt;code&gt;LC_MESSAGES&lt;/code&gt;. If you want to have portable error codes, use &lt;code&gt;%!&lt;/code&gt;. See &lt;a href=&quot;errno&quot;&gt;Errno&lt;/a&gt;.</source>
          <target state="translated">나머지 로케일 범주는 현재 Perl 자체에서 사용되지 않습니다. 그러나 다시 말하지만, Perl이 상호 작용하는 것은 표준 Perl 배포판 외부의 확장과 운영 체제 및 유틸리티에 의한 확장을 포함하여 이들을 사용할 수 있다는 점에 유의하십시오. 특히 &lt;code&gt;$!&lt;/code&gt; 외부 유틸리티에서 제공하는 오류 메시지는 &lt;code&gt;LC_MESSAGES&lt;/code&gt; 에 의해 변경 될 수 있습니다 . 이식 가능한 오류 코드를 원하면 &lt;code&gt;%!&lt;/code&gt; . &lt;a href=&quot;errno&quot;&gt;Errno를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="6f593d82b22de04a34fb6b00553893736966b088" translate="yes" xml:space="preserve">
          <source>The remaining three arguments to &lt;code&gt;autosplit&lt;/code&gt; govern other options to the autosplitter.</source>
          <target state="translated">&lt;code&gt;autosplit&lt;/code&gt; 에 대한 나머지 세 가지 인수는 다른 옵션을 autosplitter에 적용합니다.</target>
        </trans-unit>
        <trans-unit id="359f225886acbac14791dc5bc2f8daf71a950d7f" translate="yes" xml:space="preserve">
          <source>The remaining transformations (e.g. hex -&amp;gt; oct, bin -&amp;gt; hex, etc.) are left as an exercise to the inclined reader.</source>
          <target state="translated">나머지 변형 (예 : 16 진수-&amp;gt; oct, bin-&amp;gt; 16 진수 등)은 기울어 진 독자에게 연습으로 남습니다.</target>
        </trans-unit>
        <trans-unit id="24d565f51a3155e5d1586b0499680351e5378dc6" translate="yes" xml:space="preserve">
          <source>The repeat count for &lt;code&gt;u&lt;/code&gt; is interpreted as the maximal number of bytes to encode per line of output, with 0, 1 and 2 replaced by 45. The repeat count should not be more than 65.</source>
          <target state="translated">&lt;code&gt;u&lt;/code&gt; 의 반복 횟수 는 출력 라인 당 인코딩 할 최대 바이트 수로 해석되며 0, 1 및 2는 45로 대체됩니다. 반복 횟수는 65를 넘지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="f593cdc0477b84a5d137272da930d89fe6995081" translate="yes" xml:space="preserve">
          <source>The repertoire of characters that Perl can represent is a superset of those defined by the Unicode Consortium. On most platforms the ordinal values of a character as returned by &lt;code&gt;ord(&lt;i&gt;S&lt;/i&gt;)&lt;/code&gt; is the</source>
          <target state="translated">Perl이 표시 할 수있는 문자 레퍼토리는 Unicode Consortium에서 정의한 문자의 수퍼 세트입니다. 대부분의 플랫폼에 의해 반환되는 문자의 순서 값 &lt;code&gt;ord(&lt;i&gt;S&lt;/i&gt;)&lt;/code&gt; 은 IS</target>
        </trans-unit>
        <trans-unit id="b4becab04b9eae1dfa2922434e872f92f0ca7ffd" translate="yes" xml:space="preserve">
          <source>The replacement UNIVERSAL::VERSION, when used as a function, like this:</source>
          <target state="translated">대체 UNIVERSAL :: VERSION은 다음과 같이 함수로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="2b90d7584bfb12af61e5f1ab0554e525a346ffd6" translate="yes" xml:space="preserve">
          <source>The report generated is in the following format:</source>
          <target state="translated">생성 된 보고서는 다음 형식으로되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="c18cb003bcf6566604f8240405fff42c4ea43f6c" translate="yes" xml:space="preserve">
          <source>The report is then grouped by the &lt;b&gt;Package&lt;/b&gt; of each variable, subroutine or format with the special case &quot;(lexicals)&quot; meaning lexical variables. Each &lt;b&gt;object&lt;/b&gt; name (implicitly qualified by its containing &lt;b&gt;Package&lt;/b&gt;) includes its type character(s) at the beginning where possible. Lexical variables are easier to track and even included dereferencing information where possible.</source>
          <target state="translated">그런 다음 각 변수, 서브 루틴 또는 형식 의 &lt;b&gt;패키지&lt;/b&gt; 별로 어휘 변수를 의미하는 특수한 &quot;(lexicals)&quot; &lt;b&gt;패키지&lt;/b&gt; 로 보고서를 그룹화 합니다. 각 &lt;b&gt;객체&lt;/b&gt; 이름 (포함하는 &lt;b&gt;Package로&lt;/b&gt; 암시 적으로 규정 됨 )에는 가능한 경우 처음에 유형 문자가 포함됩니다. 어휘 변수는 추적하기 쉬우 며 가능한 경우 역 참조 정보도 포함합니다.</target>
        </trans-unit>
        <trans-unit id="a2f4b71d3df1e22731185a4eb5f4e73af9bf14da" translate="yes" xml:space="preserve">
          <source>The report with</source>
          <target state="translated">보고서</target>
        </trans-unit>
        <trans-unit id="32baff471ed8eb8f5ceead8f0fa06a41ab81b875" translate="yes" xml:space="preserve">
          <source>The request was judged to be small, so the possibility to trap it depends on the way perl was compiled. By default it is not trappable. However, if compiled for this, Perl may use the contents of &lt;code&gt;$^M&lt;/code&gt; as an emergency pool after die()ing with this message. In this case the error is trappable</source>
          <target state="translated">요청은 작은 것으로 판단되었으므로이를 포괄 할 수있는 가능성은 perl이 컴파일 된 방법에 따라 다릅니다. 기본적으로 트래핑 할 수 없습니다. 그러나이를 위해 컴파일 된 경우, Perl은 &lt;code&gt;$^M&lt;/code&gt; 의 내용을 이 메시지와 함께 die () 후 비상 풀로 사용할 수 있습니다 . 이 경우 오류를 잡을 수 있습니다</target>
        </trans-unit>
        <trans-unit id="e06f7be9330cffa7a55aee96bfbe8c1e1072f6a9" translate="yes" xml:space="preserve">
          <source>The requests do not necessarily go always all the way down to the operating system: that's where PerlIO buffering comes into play.</source>
          <target state="translated">요청이 항상 운영 체제로 항상 내려갈 필요는 없습니다. 바로 PerlIO 버퍼링이 작동합니다.</target>
        </trans-unit>
        <trans-unit id="c2923a29c348a827f2ff3da1221b43b0a603bfa9" translate="yes" xml:space="preserve">
          <source>The require function will actually look for the</source>
          <target state="translated">require 함수는 실제로</target>
        </trans-unit>
        <trans-unit id="d362ada26ee954875bdcbdb4ef3110ff77e350ef" translate="yes" xml:space="preserve">
          <source>The require function will actually look for the &quot;</source>
          <target state="translated">require 함수는 실제로 &quot;</target>
        </trans-unit>
        <trans-unit id="437fdd0ce3dd49b0cb6d8dbfa1617238f6bfc689" translate="yes" xml:space="preserve">
          <source>The require function will look for the</source>
          <target state="translated">require 함수는</target>
        </trans-unit>
        <trans-unit id="7925470de731575e163d706573142112baceaaab" translate="yes" xml:space="preserve">
          <source>The require function will look for the &quot;</source>
          <target state="translated">require 함수는 &quot;</target>
        </trans-unit>
        <trans-unit id="a4dd4536ee0a716833e52164851f465f831c0d1d" translate="yes" xml:space="preserve">
          <source>The required arguments during &lt;code&gt;&lt;a href=&quot;../functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; are the hash, the package, and the reference to the &lt;code&gt;FETCH&lt;/code&gt; ing function. The optional arguments are an arbitrary scalar $data, the reference to the &lt;code&gt;EXISTS&lt;/code&gt; function, and initial values of the hash and of the existence cache.</source>
          <target state="translated">동안 필요한 인수 &lt;code&gt;&lt;a href=&quot;../functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; 해시 패키지 및 대한 참조이다 &lt;code&gt;FETCH&lt;/code&gt; 보내고 기능. 선택적 인수는 임의의 스칼라 $ data, &lt;code&gt;EXISTS&lt;/code&gt; 함수에 대한 참조 및 해시 및 존재 캐시의 초기 값입니다.</target>
        </trans-unit>
        <trans-unit id="72b681659bb57f7021407ce5fd3ac4d104c48565" translate="yes" xml:space="preserve">
          <source>The required arguments during &lt;code&gt;tie&lt;/code&gt; are the hash, the package, and the reference to the &lt;code&gt;FETCH&lt;/code&gt;ing function. The optional arguments are an arbitrary scalar $data, the reference to the &lt;code&gt;EXISTS&lt;/code&gt; function, and initial values of the hash and of the existence cache.</source>
          <target state="translated">&lt;code&gt;tie&lt;/code&gt; 중에 필요한 인수 는 해시, 패키지 및 &lt;code&gt;FETCH&lt;/code&gt; 기능에 대한 참조 입니다. 선택적 인수는 임의의 스칼라 $ data, &lt;code&gt;EXISTS&lt;/code&gt; 함수에 대한 참조 , 해시 및 존재 캐시의 초기 값입니다.</target>
        </trans-unit>
        <trans-unit id="37cc4a6beddbd481d62d1aa4fb0c7078c9745a11" translate="yes" xml:space="preserve">
          <source>The requires and build_requires dependency declarations</source>
          <target state="translated">require 및 build_requires 종속성 선언</target>
        </trans-unit>
        <trans-unit id="68eca29cf3cefa1ee83b5c875c176fa92ac4b217" translate="yes" xml:space="preserve">
          <source>The rest is duplicate code from MM_Unix. Should move the linker code to its own method.</source>
          <target state="translated">나머지는 MM_Unix의 중복 코드입니다. 링커 코드를 자체 메서드로 이동해야합니다.</target>
        </trans-unit>
        <trans-unit id="5f0ee77d23f152cd1591836db1cbf485219544f6" translate="yes" xml:space="preserve">
          <source>The rest is for internal usage of this package. In particular, if TIEHASH is overwritten, it should call SUPER::TIEHASH.</source>
          <target state="translated">나머지는이 패키지의 내부 사용을위한 것입니다. 특히 TIEHASH를 덮어 쓰면 SUPER :: TIEHASH를 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="fe2906e8b2561874cbab3bd035dddc47777e922a" translate="yes" xml:space="preserve">
          <source>The rest of the</source>
          <target state="translated">나머지</target>
        </trans-unit>
        <trans-unit id="bf6a19c74f24c99c3610c0c4323af3d860d85c2f" translate="yes" xml:space="preserve">
          <source>The rest of the .pm file contains sample code for providing documentation for the extension.</source>
          <target state="translated">나머지 .pm 파일에는 확장에 대한 설명서를 제공하기위한 샘플 코드가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="7c74ae28959473b4a69a8f31fe847650cadce3cf" translate="yes" xml:space="preserve">
          <source>The rest of the META.yml file is one big YAML &lt;a href=&quot;http://yaml.org/spec/history/2002-10-31.html#syntax-mapping&quot;&gt;mapping&lt;/a&gt;, whose keys are described here.</source>
          <target state="translated">나머지 META.yml 파일은 하나의 큰 YAML &lt;a href=&quot;http://yaml.org/spec/history/2002-10-31.html#syntax-mapping&quot;&gt;매핑&lt;/a&gt; 이며 여기에 키가 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="6a0a96f4412d084abe1abbbb705cc005b4d7612f" translate="yes" xml:space="preserve">
          <source>The rest of the function description may be indented or left-adjusted. The following example shows a function with its body left-adjusted. Most examples in this document will indent the body for better readability.</source>
          <target state="translated">나머지 기능 설명은 들여 쓰기되거나 왼쪽으로 조정될 수 있습니다. 다음 예제는 본문이 왼쪽으로 조정 된 함수를 보여줍니다. 이 문서의 대부분의 예는 가독성을 높이기 위해 본문을 들여 씁니다.</target>
        </trans-unit>
        <trans-unit id="4748c8c8a6af67adc5b974371e823f12ce953a5d" translate="yes" xml:space="preserve">
          <source>The rest of this section may need updating, but we don't know what it should say. Please email comments to &lt;a href=&quot;http://search.cpan.org/perldoc/mailto:perlbug@perl.org&quot;&gt;perlbug@perl.org&lt;/a&gt;.</source>
          <target state="translated">이 섹션의 나머지 부분은 업데이트가 필요할 수 있지만 그 내용을 잘 모릅니다. &lt;a href=&quot;http://search.cpan.org/perldoc/mailto:perlbug@perl.org&quot;&gt;perlbug@perl.org&lt;/a&gt; 에게 의견을 보내주십시오 .</target>
        </trans-unit>
        <trans-unit id="b6c6c6a28aca9f64e81536b5041a7bd3a852dd99" translate="yes" xml:space="preserve">
          <source>The rest of this section may need updating, but we don't know what it should say. Please submit comments to &lt;a href=&quot;https://github.com/Perl/perl5/issues&quot;&gt;https://github.com/Perl/perl5/issues&lt;/a&gt;.</source>
          <target state="translated">이 섹션의 나머지 부분은 업데이트가 필요할 수 있지만 내용이 무엇인지 알 수 없습니다. &lt;a href=&quot;https://github.com/Perl/perl5/issues&quot;&gt;https://github.com/Perl/perl5/issues에&lt;/a&gt; 의견을 제출 하십시오 .</target>
        </trans-unit>
        <trans-unit id="fd5215ed25fc6b559f1f45b7ad436f4f9831272e" translate="yes" xml:space="preserve">
          <source>The rest which are already available are based upon the vendor mappings at &lt;a href=&quot;http://www.unicode.org/Public/MAPPINGS/VENDORS/APPLE/&quot;&gt;http://www.unicode.org/Public/MAPPINGS/VENDORS/APPLE/&lt;/a&gt; .</source>
          <target state="translated">이미 사용 가능한 나머지는 &lt;a href=&quot;http://www.unicode.org/Public/MAPPINGS/VENDORS/APPLE/&quot;&gt;http://www.unicode.org/Public/MAPPINGS/VENDORS/APPLE/&lt;/a&gt; 의 공급 업체 매핑을 기반으로합니다 .</target>
        </trans-unit>
        <trans-unit id="a3cb44cf97eef964df25c82472ad386e80122021" translate="yes" xml:space="preserve">
          <source>The restart was previously implemented using a &lt;code&gt;longjmp&lt;/code&gt; in &lt;code&gt;regatom()&lt;/code&gt; back to a &lt;code&gt;setjmp&lt;/code&gt; in &lt;code&gt;Perl_re_op_compile()&lt;/code&gt; , but this proved to be problematic as the latter is a large function containing many automatic variables, which interact badly with the emergent control flow of &lt;code&gt;setjmp&lt;/code&gt; .</source>
          <target state="translated">재가동 이전에 사용 구현 &lt;code&gt;longjmp&lt;/code&gt; 에 &lt;code&gt;regatom()&lt;/code&gt; (A)에 위로 &lt;code&gt;setjmp&lt;/code&gt; 는 에 &lt;code&gt;Perl_re_op_compile()&lt;/code&gt; 하지만, 후자는 많은 자동 변수를 포함하는 많은 기능이기 때문에 이것은 문제가 될 것으로 판명되는 인터랙트 심하게의 출사 제어 흐름 &lt;code&gt;setjmp&lt;/code&gt; 는 .</target>
        </trans-unit>
        <trans-unit id="0cb3a75ceb2d2ee1d3bf90c88d2151a6541e047d" translate="yes" xml:space="preserve">
          <source>The restart was previously implemented using a &lt;code&gt;longjmp&lt;/code&gt; in &lt;code&gt;regatom()&lt;/code&gt; back to a &lt;code&gt;setjmp&lt;/code&gt; in &lt;code&gt;Perl_re_op_compile()&lt;/code&gt;, but this proved to be problematic as the latter is a large function containing many automatic variables, which interact badly with the emergent control flow of &lt;code&gt;setjmp&lt;/code&gt;.</source>
          <target state="translated">재가동 이전에 사용 구현 &lt;code&gt;longjmp&lt;/code&gt; 에 &lt;code&gt;regatom()&lt;/code&gt; (A)에 위로 &lt;code&gt;setjmp&lt;/code&gt; 는 에 &lt;code&gt;Perl_re_op_compile()&lt;/code&gt; 하지만, 후자는 많은 자동 변수를 포함하는 많은 기능이기 때문에 이것은 문제가 될 것으로 판명되는 인터랙트 심하게의 출사 제어 흐름 &lt;code&gt;setjmp&lt;/code&gt; 는 .</target>
        </trans-unit>
        <trans-unit id="5e8310b48c79e713f14decd4088c7da40b8f8d5f" translate="yes" xml:space="preserve">
          <source>The restriction for the comparison operation is that even if, for example, &lt;code&gt;cmp&lt;/code&gt; should return a blessed reference, the autogenerated &lt;code&gt;lt&lt;/code&gt; function will produce only a standard logical value based on the numerical value of the result of &lt;code&gt;cmp&lt;/code&gt; . In particular, a working numeric conversion is needed in this case (possibly expressed in terms of other conversions).</source>
          <target state="translated">비교 연산에 대한 제한 사항은 예를 들어 &lt;code&gt;cmp&lt;/code&gt; 가 축복 된 참조를 리턴해야하더라도 자동 생성 된 &lt;code&gt;lt&lt;/code&gt; 함수는 &lt;code&gt;cmp&lt;/code&gt; 결과의 숫자 값을 기반으로 표준 논리 값 만 생성한다는 것입니다 . 특히이 경우 작동하는 숫자 변환이 필요합니다 (다른 변환으로 표현 될 수 있음).</target>
        </trans-unit>
        <trans-unit id="f937ca260b1eebc06f72a3641b2c030503e4317b" translate="yes" xml:space="preserve">
          <source>The restriction for the comparison operation is that even if, for example, &lt;code&gt;cmp&lt;/code&gt; should return a blessed reference, the autogenerated &lt;code&gt;lt&lt;/code&gt; function will produce only a standard logical value based on the numerical value of the result of &lt;code&gt;cmp&lt;/code&gt;. In particular, a working numeric conversion is needed in this case (possibly expressed in terms of other conversions).</source>
          <target state="translated">비교 연산의 제한 사항은 예를 들어 &lt;code&gt;cmp&lt;/code&gt; 가 축복 된 참조를 반환해야하는 경우에도 자동 생성 된 &lt;code&gt;lt&lt;/code&gt; 함수는 &lt;code&gt;cmp&lt;/code&gt; 결과의 숫자 값을 기반으로 표준 논리 값만 생성한다는 것입니다 . 특히이 경우에는 작동하는 숫자 변환이 필요합니다 (다른 변환으로 표현 될 수 있음).</target>
        </trans-unit>
        <trans-unit id="17095fb32ad5dc43587aca28eee99cc6fee8a6b5" translate="yes" xml:space="preserve">
          <source>The result &lt;code&gt;$^R&lt;/code&gt; is automatically localized, so that it will behave properly in the presence of backtracking.</source>
          <target state="translated">결과 &lt;code&gt;$^R&lt;/code&gt; 은 자동으로 현지화되므로 역 추적이있는 경우 올바르게 작동합니다.</target>
        </trans-unit>
        <trans-unit id="917b4b2d464d47448ca46f205a594a1f2094a00d" translate="yes" xml:space="preserve">
          <source>The result &lt;code&gt;Regexp&lt;/code&gt; indicates that the argument is a regular expression resulting from &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">결과 &lt;code&gt;Regexp&lt;/code&gt; 는 인수가 &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt; 의 결과 인 정규식 임을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="1beec82c5ad986daa3005ca6feae967035c22b78" translate="yes" xml:space="preserve">
          <source>The result &lt;code&gt;Regexp&lt;/code&gt; indicates that the argument is a regular expression resulting from &lt;code&gt;&lt;a href=&quot;qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">결과 &lt;code&gt;Regexp&lt;/code&gt; 는 인수가 &lt;code&gt;&lt;a href=&quot;qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt; 의 결과 인 정규식 임을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="fa60f0453236256bf9eae460e1101cb5ebaf3da0" translate="yes" xml:space="preserve">
          <source>The result has a dual nature: it is a NaN, but it also carries the integer inside it. The integer can be retrieved with &lt;a href=&quot;#getpayload&quot;&gt;&quot;getpayload&quot;&lt;/a&gt;. Note, though, that the payload is not propagated, not even on copies, and definitely not in arithmetic operations.</source>
          <target state="translated">결과는 이중 특성을 갖습니다. NaN이지만 내부에 정수도 포함합니다. 정수는 &lt;a href=&quot;#getpayload&quot;&gt;&quot;getpayload&quot;&lt;/a&gt; 로 검색 할 수 있습니다 . 그러나 페이로드는 복사본에서도 전파되지 않으며 산술 연산에서도 전파되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="413c5704399ec4e320c4b4de62416c60414146e3" translate="yes" xml:space="preserve">
          <source>The result is returned as two arguments. If the modular multiplicative inverse does not exist, both arguments are undefined. Otherwise, the arguments are a number (object) and its sign (&quot;+&quot; or &quot;-&quot;).</source>
          <target state="translated">결과는 두 개의 인수로 반환됩니다. 모듈 식 곱셈 역수가 존재하지 않으면 두 인수가 모두 정의되지 않습니다. 그렇지 않으면 인수는 숫자 (객체)와 그 부호 ( &quot;+&quot;또는 &quot;-&quot;)입니다.</target>
        </trans-unit>
        <trans-unit id="e2176289afdf7f655c62c369888f79d214a9f024" translate="yes" xml:space="preserve">
          <source>The result is that the contents of line 17 of the file will be replaced with &quot;Cherry pie&quot;; a newline character will separate line 17 from line 18. This means that this code will do nothing:</source>
          <target state="translated">결과적으로 파일의 17 행 내용이 &quot;Cherry pie&quot;로 대체됩니다. 개행 문자는 17 행을 18 행과 분리합니다. 이는이 코드가 아무 것도 수행하지 않음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="f863b8e99992f5c2a779d9ed98aecf9cef5b7a84" translate="yes" xml:space="preserve">
          <source>The result is the Unicode character or character sequence given by</source>
          <target state="translated">결과는 다음과 같이 유니 코드 문자 또는 문자 시퀀스입니다.</target>
        </trans-unit>
        <trans-unit id="f066226510a6a63558092d6e0a75383b46653b7b" translate="yes" xml:space="preserve">
          <source>The result is the character specified by the hexadecimal number between the braces. See &lt;a href=&quot;#%5B8%5D&quot;&gt;&quot;[8]&quot;&lt;/a&gt; below for details on which character.</source>
          <target state="translated">결과는 중괄호 사이의 16 진수로 지정된 문자입니다. 참조 &lt;a href=&quot;#%5B8%5D&quot;&gt;&quot;[8]&quot;&lt;/a&gt; 문자에 대한 자세한 내용은 아래에.</target>
        </trans-unit>
        <trans-unit id="17faf27e0d190c0297fec9a5baff8ccb279e91a8" translate="yes" xml:space="preserve">
          <source>The result is the character specified by the hexadecimal number between the braces. See &lt;a href=&quot;#%5b8%5d&quot;&gt;[8]&lt;/a&gt; below for details on which character.</source>
          <target state="translated">결과는 중괄호 사이의 16 진수로 지정된 문자입니다. 어떤 문자에 대한 자세한 내용은 아래 &lt;a href=&quot;#%5b8%5d&quot;&gt;[8]을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="7238c8e2e1333323c2dd62857b981306a7706e6a" translate="yes" xml:space="preserve">
          <source>The result is the character specified by the hexadecimal number in the range 0x00 to 0xFF. See &lt;a href=&quot;#%5B8%5D&quot;&gt;&quot;[8]&quot;&lt;/a&gt; below for details on which character.</source>
          <target state="translated">결과는 0x00에서 0xFF 범위의 16 진수로 지정된 문자입니다. 참조 &lt;a href=&quot;#%5B8%5D&quot;&gt;&quot;[8]&quot;&lt;/a&gt; 문자에 대한 자세한 내용은 아래에.</target>
        </trans-unit>
        <trans-unit id="1743ff5152c2110b7544e70901f154f3b6b46b92" translate="yes" xml:space="preserve">
          <source>The result is the character specified by the hexadecimal number in the range 0x00 to 0xFF. See &lt;a href=&quot;#%5b8%5d&quot;&gt;[8]&lt;/a&gt; below for details on which character.</source>
          <target state="translated">결과는 0x00에서 0xFF 범위의 16 진수로 지정된 문자입니다. 어떤 문자에 대한 자세한 내용은 아래 &lt;a href=&quot;#%5b8%5d&quot;&gt;[8]을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d86f6bbcc0ec2a19c70956057e4d3cc4063fc333" translate="yes" xml:space="preserve">
          <source>The result is the character specified by the octal number between the braces. See &lt;a href=&quot;#%5B8%5D&quot;&gt;&quot;[8]&quot;&lt;/a&gt; below for details on which character.</source>
          <target state="translated">결과는 중괄호 사이의 8 진수로 지정된 문자입니다. 참조 &lt;a href=&quot;#%5B8%5D&quot;&gt;&quot;[8]&quot;&lt;/a&gt; 문자에 대한 자세한 내용은 아래에.</target>
        </trans-unit>
        <trans-unit id="6bbe820fb63fd799e4d92d37fd1768342fc0ad13" translate="yes" xml:space="preserve">
          <source>The result is the character specified by the octal number between the braces. See &lt;a href=&quot;#%5b8%5d&quot;&gt;[8]&lt;/a&gt; below for details on which character.</source>
          <target state="translated">결과는 중괄호 사이의 8 진수로 지정된 문자입니다. 어떤 문자에 대한 자세한 내용은 아래 &lt;a href=&quot;#%5b8%5d&quot;&gt;[8]을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="2ca77b886ca2262e5c2630425a0b7e07037d32d3" translate="yes" xml:space="preserve">
          <source>The result is the character specified by the three-digit octal number in the range 000 to 777 (but best to not use above 077, see next paragraph). See &lt;a href=&quot;#%5B8%5D&quot;&gt;&quot;[8]&quot;&lt;/a&gt; below for details on which character.</source>
          <target state="translated">결과는 000에서 777 범위의 3 자리 8 진수로 지정된 문자입니다 (그러나 077 이상에서는 사용하지 않는 것이 가장 좋습니다. 다음 단락 참조). 참조 &lt;a href=&quot;#%5B8%5D&quot;&gt;&quot;[8]&quot;&lt;/a&gt; 문자에 대한 자세한 내용은 아래에.</target>
        </trans-unit>
        <trans-unit id="b5d07b8bddc1c5dd823f98677754aff0c68b0c00" translate="yes" xml:space="preserve">
          <source>The result is the character specified by the three-digit octal number in the range 000 to 777 (but best to not use above 077, see next paragraph). See &lt;a href=&quot;#%5b8%5d&quot;&gt;[8]&lt;/a&gt; below for details on which character.</source>
          <target state="translated">결과는 000에서 777 사이의 3 자리 8 진수로 지정된 문자입니다 (그러나 077 이상을 사용하지 않는 것이 가장 좋습니다. 다음 단락 참조). 어떤 문자에 대한 자세한 내용은 아래 &lt;a href=&quot;#%5b8%5d&quot;&gt;[8]을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="4d2ac189a7b892d497c3a957f821832172806b14" translate="yes" xml:space="preserve">
          <source>The result is the same as &lt;code&gt;xhdr&lt;/code&gt; except the is will be restricted to headers where the text of the header matches &lt;code&gt;PATTERN&lt;/code&gt;</source>
          <target state="translated">결과는 &lt;code&gt;xhdr&lt;/code&gt; 과 동일하지만 헤더의 텍스트가 &lt;code&gt;PATTERN&lt;/code&gt; 과 일치하는 헤더로 제한됩니다.</target>
        </trans-unit>
        <trans-unit id="37186ac3e81998654b9034f359d33c97b138b201" translate="yes" xml:space="preserve">
          <source>The result may be used as a subpattern in a match:</source>
          <target state="translated">결과는 일치하는 하위 패턴으로 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="aea5a1ac74300d067b63729d12ad0881314aa59c" translate="yes" xml:space="preserve">
          <source>The result of each test is captured in a hash. These hashes are the same as the hashes returned by Test::Builder-&amp;gt;details but with a couple of extra fields.</source>
          <target state="translated">각 테스트의 결과는 해시로 캡처됩니다. 이 해시는 Test :: Builder-&amp;gt; details에서 반환 한 해시와 동일하지만 몇 개의 추가 필드가 있습니다.</target>
        </trans-unit>
        <trans-unit id="30a38c7996159062562ab2957a6c23713b7a1d86" translate="yes" xml:space="preserve">
          <source>The result of evaluation of the last successful &lt;code&gt;(?{ code })&lt;/code&gt; regular expression assertion (see &lt;a href=&quot;perlre&quot;&gt;perlre&lt;/a&gt;). May be written to.</source>
          <target state="translated">마지막으로 성공한 &lt;code&gt;(?{ code })&lt;/code&gt; 정규식 어설 션 평가 결과 ( &lt;a href=&quot;perlre&quot;&gt;perlre&lt;/a&gt; 참조 ). 쓸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="66611e861a602cfa60591a93b737577becd37f08" translate="yes" xml:space="preserve">
          <source>The result of great_circle_direction is in radians, zero indicating straight north, pi or -pi straight south, pi/2 straight west, and -pi/2 straight east.</source>
          <target state="translated">great_circle_direction의 결과는 라디안으로 표시되며 0은 직선 북쪽, pi 또는 -pi 직선 남쪽, pi / 2 직선 서쪽 및 -pi / 2 직선 동쪽을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="f6846ed84b71cca2d8b5fb5477773187fbddddb3" translate="yes" xml:space="preserve">
          <source>The result of md5(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;) will be exactly the same as the result of md5(&quot;abc&quot;).</source>
          <target state="translated">md5 ( &quot;a&quot;, &quot;b&quot;, &quot;c&quot;)의 결과는 md5 ( &quot;abc&quot;)의 결과와 정확히 동일합니다.</target>
        </trans-unit>
        <trans-unit id="641d055cafe1e1ee3cae38ce56b7935f5d3bc2b3" translate="yes" xml:space="preserve">
          <source>The result of overflowing the range of the integers is undefined because it is undefined also in C. In other words, using 32-bit integers, &lt;code&gt;1 &amp;lt;&amp;lt; 32&lt;/code&gt; is undefined. Shifting by a negative number of bits is also undefined.</source>
          <target state="translated">정수 범위를 오버플로 한 결과는 C에서도 정의되지 않기 때문에 정의되지 않습니다. 즉, 32 비트 정수를 사용하면 &lt;code&gt;1 &amp;lt;&amp;lt; 32&lt;/code&gt; 는 정의되지 않습니다. 음의 비트 수만큼의 이동도 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="00de3247a1fa0dbaa5340672e75fce7f76fa569f" translate="yes" xml:space="preserve">
          <source>The result of this scenario is at best a database that doesn't contain what you expect. At worst the database will corrupt.</source>
          <target state="translated">이 시나리오의 결과는 기껏해야 기대하는 것을 포함하지 않는 데이터베이스입니다. 최악의 경우 데이터베이스가 손상됩니다.</target>
        </trans-unit>
        <trans-unit id="f6de57c3d8ec6b1611fc0077d370dda9fed1574d" translate="yes" xml:space="preserve">
          <source>The result returned will be one of the following:</source>
          <target state="translated">반환 된 결과는 다음 중 하나입니다.</target>
        </trans-unit>
        <trans-unit id="0b8a9a1357d52322f675cb2cb87488ac744f63b6" translate="yes" xml:space="preserve">
          <source>The result string containing interpolated material is tainted if a &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; form that includes &lt;code&gt;LC_CTYPE&lt;/code&gt; is in effect.</source>
          <target state="translated">&lt;code&gt;LC_CTYPE&lt;/code&gt; 을 포함 하는 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; 양식이 유효한 경우 보간 된 재료를 포함하는 결과 문자열이 오염됩니다 .</target>
        </trans-unit>
        <trans-unit id="dc181363eb40ff0bd863bde77567e9656e7a29d5" translate="yes" xml:space="preserve">
          <source>The result string containing interpolated material is tainted if a &lt;code&gt;use locale&lt;/code&gt; form that includes &lt;code&gt;LC_CTYPE&lt;/code&gt; is in effect.</source>
          <target state="translated">&lt;code&gt;LC_CTYPE&lt;/code&gt; 을 포함 하는 &lt;code&gt;use locale&lt;/code&gt; 양식이 유효한 경우 보간 된 자료를 포함하는 결과 문자열이 오염됩니다 .</target>
        </trans-unit>
        <trans-unit id="51fb17ca190a73d84710650cb1a592da2c670185" translate="yes" xml:space="preserve">
          <source>The result will be an array of 3 elements, each a reference to an array which will hold the handles that are ready for reading, writing and have exceptions respectively. Upon error an empty list is returned.</source>
          <target state="translated">결과는 각각 3 개의 요소로 구성된 배열이 될 것이며, 각각은 읽기, 쓰기 및 예외가있는 핸들을 보유 할 배열에 대한 참조입니다. 오류가 발생하면 빈 목록이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="a68ddca584ffd166b11e615f1b961f7dd364600e" translate="yes" xml:space="preserve">
          <source>The result will be up to be three times the number of layers: the first element will be a name, the second element the arguments (unspecified arguments will be &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;), the third element the flags, the fourth element a name again, and so forth.</source>
          <target state="translated">결과는 레이어 수의 3 배가됩니다 : 첫 번째 요소는 이름, 두 번째 요소는 인수 (지정되지 않은 인수는 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 일 것입니다 ), 세 번째 요소는 플래그, 네 번째 요소는 다시 이름입니다. 앞으로.</target>
        </trans-unit>
        <trans-unit id="3e9d88696af53de04206c2554e1cd6a14550e72c" translate="yes" xml:space="preserve">
          <source>The result will be up to be three times the number of layers: the first element will be a name, the second element the arguments (unspecified arguments will be &lt;code&gt;undef&lt;/code&gt;), the third element the flags, the fourth element a name again, and so forth.</source>
          <target state="translated">결과는 레이어 수의 최대 3 배가됩니다. 첫 번째 요소는 이름, 두 번째 요소는 인수 (지정되지 않은 인수는 &lt;code&gt;undef&lt;/code&gt; ), 세 번째 요소는 플래그, 네 번째 요소는 다시 이름이됩니다. 앞으로.</target>
        </trans-unit>
        <trans-unit id="e6e0c7dba94f1684aba5f4cd6501d599a99358de" translate="yes" xml:space="preserve">
          <source>The resulting $subdir_cmd has no leading tab nor trailing newline. This makes it easier to embed in a make string. For example.</source>
          <target state="translated">결과 $ subdir_cmd에는 선행 탭이나 후행 줄 바꿈이 없습니다. 이렇게하면 make 문자열에 쉽게 포함 할 수 있습니다. 예를 들어.</target>
        </trans-unit>
        <trans-unit id="5f6fcb4f54789b9c880bc0144fb1cf2ebd3b3159" translate="yes" xml:space="preserve">
          <source>The resulting byte sequence is most convenient for checking the checksum. Don't slow your program down with a for loop adding the &lt;code&gt;&lt;a href=&quot;functions/ord&quot;&gt;ord&lt;/a&gt;&lt;/code&gt; values of this string's bytes - the &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; code &lt;code&gt;%&lt;/code&gt; is the thing to use for computing the 8-bit sum of all bytes, which must be equal to zero:</source>
          <target state="translated">결과 바이트 시퀀스는 체크섬을 확인하는 데 가장 편리합니다. 이 문자열 바이트 의 &lt;code&gt;&lt;a href=&quot;functions/ord&quot;&gt;ord&lt;/a&gt;&lt;/code&gt; 값을 추가하는 for 루프로 프로그램 속도를 늦추지 마십시오 . &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; 코드 &lt;code&gt;%&lt;/code&gt; 는 모든 바이트의 8 비트 합계를 계산하는 데 사용하는 것으로 0과 같아야합니다.</target>
        </trans-unit>
        <trans-unit id="7e685873aa2576bcd6d048591b67cf99d300730d" translate="yes" xml:space="preserve">
          <source>The resulting byte sequence is most convenient for checking the checksum. Don't slow your program down with a for loop adding the &lt;code&gt;ord&lt;/code&gt; values of this string's bytes - the &lt;code&gt;unpack&lt;/code&gt; code &lt;code&gt;%&lt;/code&gt; is the thing to use for computing the 8-bit sum of all bytes, which must be equal to zero:</source>
          <target state="translated">결과 바이트 시퀀스는 체크섬을 확인하는 데 가장 편리합니다. 이 문자열의 바이트에 &lt;code&gt;ord&lt;/code&gt; 값을 추가하는 for 루프를 사용하여 프로그램 속도를 늦추지 마십시오 . &lt;code&gt;unpack&lt;/code&gt; 코드 &lt;code&gt;%&lt;/code&gt; 는 모든 바이트의 8 비트 합계를 계산하는 데 사용되며 0과 같아야합니다.</target>
        </trans-unit>
        <trans-unit id="421b5462923e8d16da2f8509620d57a56b898133" translate="yes" xml:space="preserve">
          <source>The resulting path is relative by default, i.e. the resulting path will have a leading colon.</source>
          <target state="translated">결과 경로는 기본적으로 상대적입니다. 즉 결과 경로에는 선행 콜론이 있습니다.</target>
        </trans-unit>
        <trans-unit id="d4b19b5c805ca56f431cfbcdeba1af9f3a6200a3" translate="yes" xml:space="preserve">
          <source>The resulting program then looks like:</source>
          <target state="translated">결과 프로그램은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e4aa8c76073812eb40b9e292fb100c683926c76e" translate="yes" xml:space="preserve">
          <source>The results can be passed to &lt;a href=&quot;#catpath&quot;&gt;&quot;catpath&quot;&lt;/a&gt; to get back a path equivalent to (usually identical to) the original path.</source>
          <target state="translated">결과는 &lt;a href=&quot;#catpath&quot;&gt;&quot;catpath&quot;&lt;/a&gt; 에 전달되어 원래 경로와 동일한 (일반적으로 동일한) 경로를 반환 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="bd638c59c5752a7ccfc83a3bf825d1784299cda6" translate="yes" xml:space="preserve">
          <source>The results can be passed to &lt;a href=&quot;#catpath&quot;&gt;catpath&lt;/a&gt; to get back a path equivalent to (usually identical to) the original path.</source>
          <target state="translated">결과는 &lt;a href=&quot;#catpath&quot;&gt;catpath&lt;/a&gt; 로 전달되어 원래 경로와 동일한 경로 (일반적으로 동일한 경로)를 가져올 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="156c1084cc95fa3e7b597345b8d09fde064a081b" translate="yes" xml:space="preserve">
          <source>The results can be passed to &lt;a href=&quot;#catpath%28%29&quot;&gt;&quot;catpath()&quot;&lt;/a&gt; to get back a path equivalent to (usually identical to) the original path.</source>
          <target state="translated">결과는 &lt;a href=&quot;#catpath%28%29&quot;&gt;&quot;catpath ()&quot;&lt;/a&gt; 에 전달되어 원래 경로와 동일한 (일반적으로 동일한) 경로를 반환 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fbae74b52e9e1a2f4034868dc967236dfb097109" translate="yes" xml:space="preserve">
          <source>The results can be passed to &lt;a href=&quot;#catpath()&quot;&gt;catpath()&lt;/a&gt; to get back a path equivalent to (usually identical to) the original path.</source>
          <target state="translated">결과는 &lt;a href=&quot;#catpath()&quot;&gt;catpath ()&lt;/a&gt; 로 전달되어 원래 경로와 동일한 경로 (일반적으로 동일한 경로 ) 를 가져올 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9fd6f04fef4668c0fb9b5436580855adbbe256e9" translate="yes" xml:space="preserve">
          <source>The results can be passed to &lt;code&gt;catpath()&lt;/code&gt; to get back a path equivalent to (usually identical to) the original path.</source>
          <target state="translated">결과는 &lt;code&gt;catpath()&lt;/code&gt; 로 전달되어 원래 경로와 동일한 경로 (일반적으로 동일한 경로 ) 를 가져올 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7b48baa73a171c70124bb46d586398a253fc305f" translate="yes" xml:space="preserve">
          <source>The results follow ASCII rules. Only the characters &lt;code&gt;A-Z&lt;/code&gt; change, to &lt;code&gt;a-z&lt;/code&gt; respectively.</source>
          <target state="translated">결과는 ASCII 규칙을 따릅니다. 문자 &lt;code&gt;A-Z&lt;/code&gt; 만 각각 &lt;code&gt;a-z&lt;/code&gt; 변경 됩니다.</target>
        </trans-unit>
        <trans-unit id="e6e1386230ca5a3e137558786aef0b9ef4ab7b59" translate="yes" xml:space="preserve">
          <source>The results of creating new symbol table entries directly or modifying any entries that are not already typeglobs are undefined and subject to change between releases of perl.</source>
          <target state="translated">새 기호 테이블 항목을 직접 작성하거나 아직 유형 글로브가 아닌 항목을 수정 한 결과는 정의되지 않으며 perl 릴리스간에 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7c1728e8e43393222dde9f78fe3123aaa1846fe7" translate="yes" xml:space="preserve">
          <source>The return from &lt;code&gt;VERSION&lt;/code&gt; will actually be the stringified version object using the package &lt;code&gt;$VERSION&lt;/code&gt; scalar, which is guaranteed to be equivalent but may not be precisely the contents of the &lt;code&gt;$VERSION&lt;/code&gt; scalar. If you want the actual contents of &lt;code&gt;$VERSION&lt;/code&gt; , use &lt;code&gt;$CLASS::VERSION&lt;/code&gt; instead.</source>
          <target state="translated">&lt;code&gt;VERSION&lt;/code&gt; 으로부터의 리턴 은 실제로 &lt;code&gt;$VERSION&lt;/code&gt; 스칼라 패키지를 사용하여 문자열 화 된 버전 오브젝트 가 될 것입니다. 이는 동일하지만 &lt;code&gt;$VERSION&lt;/code&gt; 스칼라 의 내용이 아닐 수도 있습니다 . 당신의 실제 내용하려면 &lt;code&gt;$VERSION&lt;/code&gt; 사용 &lt;code&gt;$CLASS::VERSION&lt;/code&gt; 대신.</target>
        </trans-unit>
        <trans-unit id="95e455ea284fe76f90c5b0d39ee105831c2e5eaa" translate="yes" xml:space="preserve">
          <source>The return from &lt;code&gt;VERSION&lt;/code&gt; will actually be the stringified version object using the package &lt;code&gt;$VERSION&lt;/code&gt; scalar, which is guaranteed to be equivalent but may not be precisely the contents of the &lt;code&gt;$VERSION&lt;/code&gt; scalar. If you want the actual contents of &lt;code&gt;$VERSION&lt;/code&gt;, use &lt;code&gt;$CLASS::VERSION&lt;/code&gt; instead.</source>
          <target state="translated">&lt;code&gt;VERSION&lt;/code&gt; 의 반환 은 실제로 패키지 &lt;code&gt;$VERSION&lt;/code&gt; 스칼라를 사용하는 문자열 화 된 버전 객체입니다 . 이는 동일하다고 보장되지만 &lt;code&gt;$VERSION&lt;/code&gt; 스칼라 의 내용이 정확하지 않을 수 있습니다 . 당신의 실제 내용하려면 &lt;code&gt;$VERSION&lt;/code&gt; 사용 &lt;code&gt;$CLASS::VERSION&lt;/code&gt; 대신.</target>
        </trans-unit>
        <trans-unit id="94b2a16af23a66e19e44621474dc0fa990710d75" translate="yes" xml:space="preserve">
          <source>The return list of the generated Perl function consists of the C return value from the function (unless the XSUB is of &lt;code&gt;void&lt;/code&gt; return type or &lt;code&gt;The NO_OUTPUT Keyword&lt;/code&gt; was used) followed by all the &lt;code&gt;OUTLIST&lt;/code&gt; and &lt;code&gt;IN_OUTLIST&lt;/code&gt; parameters (in the order of appearance). On the return from the XSUB the &lt;code&gt;IN_OUT&lt;/code&gt; /&lt;code&gt;OUT&lt;/code&gt; Perl parameter will be modified to have the values written by the C function.</source>
          <target state="translated">생성 된 Perl 함수의 리턴 목록은 함수의 C 리턴 값 (XSUB가 &lt;code&gt;void&lt;/code&gt; 리턴 유형이거나 &lt;code&gt;The NO_OUTPUT Keyword&lt;/code&gt; 가 사용 되지 않은 경우 )과 모든 &lt;code&gt;OUTLIST&lt;/code&gt; 및 &lt;code&gt;IN_OUTLIST&lt;/code&gt; 매개 변수 (모양 순서대로)로 구성됩니다. XSUB에서 복귀하면 &lt;code&gt;IN_OUT&lt;/code&gt; / &lt;code&gt;OUT&lt;/code&gt; Perl 매개 변수가 C 함수에 의해 쓰여진 값을 갖도록 수정됩니다.</target>
        </trans-unit>
        <trans-unit id="44655e68104aa5b50fd85988b88ae70262129b43" translate="yes" xml:space="preserve">
          <source>The return list of the generated Perl function consists of the C return value from the function (unless the XSUB is of &lt;code&gt;void&lt;/code&gt; return type or &lt;code&gt;The NO_OUTPUT Keyword&lt;/code&gt; was used) followed by all the &lt;code&gt;OUTLIST&lt;/code&gt; and &lt;code&gt;IN_OUTLIST&lt;/code&gt; parameters (in the order of appearance). On the return from the XSUB the &lt;code&gt;IN_OUT&lt;/code&gt;/&lt;code&gt;OUT&lt;/code&gt; Perl parameter will be modified to have the values written by the C function.</source>
          <target state="translated">생성 된 Perl 함수의 리턴 목록은 함수의 C 리턴 값 (XSUB이 &lt;code&gt;void&lt;/code&gt; 리턴 유형이거나 &lt;code&gt;The NO_OUTPUT Keyword&lt;/code&gt; 가 사용 된 경우 &lt;code&gt;OUTLIST&lt;/code&gt; 과 모든 OUTLIST 및 &lt;code&gt;IN_OUTLIST&lt;/code&gt; 매개 변수 (표시 순서대로)로 구성됩니다. XSUB에서 리턴 될 때 &lt;code&gt;IN_OUT&lt;/code&gt; / &lt;code&gt;OUT&lt;/code&gt; Perl 매개 변수는 C 함수에 의해 기록 된 값을 갖도록 수정됩니다.</target>
        </trans-unit>
        <trans-unit id="d71452936695d00a40f619faefe33e6d1a6ac20b" translate="yes" xml:space="preserve">
          <source>The return may be incorrect for those rare locales where the currency symbol replaces the radix character. Send email to &lt;a href=&quot;mailto:perlbug@perl.org&quot;&gt;mailto:perlbug@perl.org&lt;/a&gt; if you have examples of it needing to work differently.</source>
          <target state="translated">통화 기호가 기수 문자를 대체하는 드문 로케일의 경우 리턴이 올바르지 않을 수 있습니다. 다르게 작업해야하는 예제가있는 경우 &lt;a href=&quot;mailto:perlbug@perl.org&quot;&gt;mailto : perlbug@perl.org로&lt;/a&gt; 이메일을 보내십시오 .</target>
        </trans-unit>
        <trans-unit id="0420f753fa3324f9eec48f35a50efc8cee6a049e" translate="yes" xml:space="preserve">
          <source>The return points to a per-thread static buffer, which is overwritten the next time &lt;code&gt;Perl_setlocale&lt;/code&gt; is called from the same thread.</source>
          <target state="translated">반환 값은 스레드 당 정적 버퍼를 &lt;code&gt;Perl_setlocale&lt;/code&gt; 다음 번 에 동일한 스레드에서 Perl_setlocale 이 호출 될 때 덮어 씁니다 .</target>
        </trans-unit>
        <trans-unit id="a21da59cc5c1c0e700b109e9dda17411cbacb1df" translate="yes" xml:space="preserve">
          <source>The return true when the argument satisfies the condition. &lt;code&gt;NaN&lt;/code&gt; , &lt;code&gt;+inf&lt;/code&gt; , &lt;code&gt;-inf&lt;/code&gt; are not integers and are neither odd nor even.</source>
          <target state="translated">인수가 조건을 만족하면 true를 리턴합니다. &lt;code&gt;NaN&lt;/code&gt; , &lt;code&gt;+inf&lt;/code&gt; , &lt;code&gt;-inf&lt;/code&gt; 는 정수가 아니며 홀수도 짝수도 아닙니다.</target>
        </trans-unit>
        <trans-unit id="b8bfaca788fa3c0ddbe45ea5ad9f0da16e79efb8" translate="yes" xml:space="preserve">
          <source>The return value (if defined) is a Perl object, of class &lt;code&gt;PerlIO::Layer&lt;/code&gt; which is created by the C code in</source>
          <target state="translated">반환 값 (정의 된 경우)은 &lt;code&gt;PerlIO::Layer&lt;/code&gt; 클래스의 Perl 객체이며 C 코드에 의해 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="45642a1469744a5e7107d7873a8272d52cfce5d2" translate="yes" xml:space="preserve">
          <source>The return value &lt;code&gt;LVALUE&lt;/code&gt; indicates a reference to an lvalue that is not a variable. You get this from taking the reference of function calls like &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos()&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/substr&quot;&gt;substr()&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;VSTRING&lt;/code&gt; is returned if the reference points to a &lt;a href=&quot;perldata#Version-Strings&quot;&gt;version string&lt;/a&gt;.</source>
          <target state="translated">리턴 값 &lt;code&gt;LVALUE&lt;/code&gt; 는 변수가 아닌 lvalue에 대한 참조를 나타냅니다. &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos()&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;functions/substr&quot;&gt;substr()&lt;/a&gt;&lt;/code&gt; 과 같은 함수 호출의 참조를 가져 와서 이것을 얻습니다 . 참조가 &lt;a href=&quot;perldata#Version-Strings&quot;&gt;버전 문자열을&lt;/a&gt; 가리키는 경우 &lt;code&gt;VSTRING&lt;/code&gt; 이 리턴됩니다 .</target>
        </trans-unit>
        <trans-unit id="68a59800451bff6b585d75aa0febce039f889432" translate="yes" xml:space="preserve">
          <source>The return value &lt;code&gt;LVALUE&lt;/code&gt; indicates a reference to an lvalue that is not a variable. You get this from taking the reference of function calls like &lt;code&gt;&lt;a href=&quot;pos&quot;&gt;pos()&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;substr&quot;&gt;substr()&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;VSTRING&lt;/code&gt; is returned if the reference points to a &lt;a href=&quot;../perldata#Version-Strings&quot;&gt;version string&lt;/a&gt;.</source>
          <target state="translated">리턴 값 &lt;code&gt;LVALUE&lt;/code&gt; 는 변수가 아닌 lvalue에 대한 참조를 나타냅니다. &lt;code&gt;&lt;a href=&quot;pos&quot;&gt;pos()&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;substr&quot;&gt;substr()&lt;/a&gt;&lt;/code&gt; 과 같은 함수 호출의 참조를 가져 와서 이것을 얻습니다 . 참조가 &lt;a href=&quot;../perldata#Version-Strings&quot;&gt;버전 문자열을&lt;/a&gt; 가리키는 경우 &lt;code&gt;VSTRING&lt;/code&gt; 이 리턴됩니다 .</target>
        </trans-unit>
        <trans-unit id="d1b1a3b59d37e5fda7fca51bd6d7cc822e1098fc" translate="yes" xml:space="preserve">
          <source>The return value can be &lt;code&gt;&lt;a href=&quot;../functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;ed to get back an identical copy of the original reference structure. (Please do consider the security implications of eval'ing code from untrusted sources!)</source>
          <target state="translated">리턴 값은 다음 &lt;code&gt;&lt;a href=&quot;../functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 원래 기준 구조체의 동일한 복사본을 돌아갈 ED. (신뢰할 수없는 출처의 평가 코드가 보안에 미치는 영향을 고려하십시오!)</target>
        </trans-unit>
        <trans-unit id="341077e987e38231c6848bd510801f6ac305a364" translate="yes" xml:space="preserve">
          <source>The return value can be &lt;code&gt;eval&lt;/code&gt;ed to get back an identical copy of the original reference structure. (Please do consider the security implications of eval'ing code from untrusted sources!)</source>
          <target state="translated">반환 값은 원래 참조 구조의 동일한 복사본을 얻기 위해 &lt;code&gt;eval&lt;/code&gt; 될 수 있습니다 . (신뢰할 수없는 소스에서 코드를 평가할 때 보안에 미치는 영향을 고려하십시오!)</target>
        </trans-unit>
        <trans-unit id="5ce36c299811e6d9af00c0cefc9c75e073456ac7" translate="yes" xml:space="preserve">
          <source>The return value for &lt;code&gt;&lt;a href=&quot;atan2&quot;&gt;atan2(0,0)&lt;/a&gt;&lt;/code&gt; is implementation-defined; consult your atan2(3) manpage for more information.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;atan2&quot;&gt;atan2(0,0)&lt;/a&gt;&lt;/code&gt; 의 반환 값 은 구현 정의되어 있습니다. 자세한 내용은 atan2 (3) 맨 페이지를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="769d902022de1a90d1cd24370f703e7b45d5dad4" translate="yes" xml:space="preserve">
          <source>The return value for &lt;code&gt;&lt;a href=&quot;functions/atan2&quot;&gt;atan2(0,0)&lt;/a&gt;&lt;/code&gt; is implementation-defined; consult your atan2(3) manpage for more information.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/atan2&quot;&gt;atan2(0,0)&lt;/a&gt;&lt;/code&gt; 의 반환 값 은 구현 정의되어 있습니다. 자세한 내용은 atan2 (3) 맨 페이지를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="3f7e47c80e390cbc99d4bd2d52e4ac31f1eae4a5" translate="yes" xml:space="preserve">
          <source>The return value for &lt;code&gt;atan2(0,0)&lt;/code&gt; is implementation-defined; consult your &lt;a href=&quot;http://man.he.net/man3/atan2&quot;&gt;atan2(3)&lt;/a&gt; manpage for more information.</source>
          <target state="translated">&lt;code&gt;atan2(0,0)&lt;/code&gt; 의 반환 값 은 구현에 따라 정의됩니다. 자세한 내용 은 &lt;a href=&quot;http://man.he.net/man3/atan2&quot;&gt;atan2 (3)&lt;/a&gt; 맨 페이지를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="7fa7da95c4b58e8bb23e135f8795df5f9ac97aa0" translate="yes" xml:space="preserve">
          <source>The return value is &lt;code&gt;true&lt;/code&gt; if this is a valid prototype, and &lt;code&gt;false&lt;/code&gt; if it is not, regardless of whether &lt;code&gt;&lt;a href=&quot;functions/warn&quot;&gt;warn&lt;/a&gt;&lt;/code&gt; was &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt; .</source>
          <target state="translated">반환 값은 &lt;code&gt;true&lt;/code&gt; 이 유효한 프로토 타입 인 경우, 그리고 &lt;code&gt;false&lt;/code&gt; 이에 관계없이 여부되지 않은 경우 &lt;code&gt;&lt;a href=&quot;functions/warn&quot;&gt;warn&lt;/a&gt;&lt;/code&gt; 했다 &lt;code&gt;true&lt;/code&gt; 또는 &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5c3cd7efde35a3e831a5bdd29d0ed5265715cc55" translate="yes" xml:space="preserve">
          <source>The return value is &lt;code&gt;true&lt;/code&gt; if this is a valid prototype, and &lt;code&gt;false&lt;/code&gt; if it is not, regardless of whether &lt;code&gt;warn&lt;/code&gt; was &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">반환 값은 &lt;code&gt;true&lt;/code&gt; 이 유효한 프로토 타입 인 경우, 그리고 &lt;code&gt;false&lt;/code&gt; 이에 관계없이 여부되지 않은 경우 &lt;code&gt;warn&lt;/code&gt; 했다 &lt;code&gt;true&lt;/code&gt; 또는 &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bd97a8975a72082d0544ff1e498721e427862ae3" translate="yes" xml:space="preserve">
          <source>The return value is POSIX-like (shifted up by 8 bits), which only allows room for a made-up value derived from the severity bits of the native 32-bit condition code (unless overridden by &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; vmsish 'status'&lt;/code&gt; ). If the native condition code is one that has a POSIX value encoded, the POSIX value will be decoded to extract the expected exit value. For more details see &lt;a href=&quot;perlvms#%24%3f&quot;&gt;$? in perlvms&lt;/a&gt;. (VMS)</source>
          <target state="translated">리턴 값은 POSIX와 유사하며 (8 비트 씩 이동), 원시 32 비트 조건 코드의 심각도 비트에서 파생 된 구성 값만 허용합니다 ( &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; vmsish 'status'&lt;/code&gt; &lt;a href=&quot;functions/use&quot;&gt;사용하여&lt;/a&gt; 재정의하지 않는 한 ). 기본 조건 코드가 POSIX 값이 인코딩 된 코드 인 경우 예상 종료 값을 추출하기 위해 POSIX 값이 디코딩됩니다. 자세한 내용은 &lt;a href=&quot;perlvms#%24%3f&quot;&gt;$?를&lt;/a&gt; 참조하십시오 . perlvms에서 . (VMS)</target>
        </trans-unit>
        <trans-unit id="38f16262d38a09b1b50bf9932e5e395bae210a67" translate="yes" xml:space="preserve">
          <source>The return value is a boolean: TRUE if the global locale at the time of call was in effect; and FALSE if a per-thread locale was in effect. This can be used by the caller that needs to restore things as-they-were to decide whether or not to call &lt;a href=&quot;perlapi#switch_to_global_locale&quot;&gt;&lt;code&gt;Perl_switch_to_global_locale&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">반환 값은 부울입니다. 호출 당시 전역 로케일이 유효하면 TRUE입니다. 스레드 별 로케일이 유효한 경우 FALSE입니다. 이것은 &lt;a href=&quot;perlapi#switch_to_global_locale&quot;&gt; &lt;code&gt;Perl_switch_to_global_locale&lt;/code&gt; &lt;/a&gt; 호출 여부를 결정하기 위해 복원해야하는 호출자가 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f7f3af5a62c5a74bbd990f1648eb2762ff5d0f59" translate="yes" xml:space="preserve">
          <source>The return value is always a scalar, either a string or a number. For properties where there are synonyms for the values, the synonym returned by this function is the longest, most descriptive form, the one returned by &lt;a href=&quot;#prop_value_aliases%28%29&quot;&gt;&quot;prop_value_aliases()&quot;&lt;/a&gt; when called in a scalar context. Of course, you can call &lt;a href=&quot;#prop_value_aliases%28%29&quot;&gt;&quot;prop_value_aliases()&quot;&lt;/a&gt; on the result to get other synonyms.</source>
          <target state="translated">반환 값은 항상 스칼라 (문자열 또는 숫자)입니다. 값에 대한 동의어가있는 속성의 경우이 함수가 반환하는 동의어는 가장 길고 가장 설명적인 형식이며 스칼라 컨텍스트에서 호출 될 때 &lt;a href=&quot;#prop_value_aliases%28%29&quot;&gt;&quot;prop_value_aliases ()&quot;에&lt;/a&gt; 의해 반환됩니다 . 물론 결과에 대해 &lt;a href=&quot;#prop_value_aliases%28%29&quot;&gt;&quot;prop_value_aliases ()&quot;&lt;/a&gt; 를 호출 하여 다른 동의어를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="43901da674d6737b62ebf11f4c04c938005307af" translate="yes" xml:space="preserve">
          <source>The return value is always a scalar, either a string or a number. For properties where there are synonyms for the values, the synonym returned by this function is the longest, most descriptive form, the one returned by &lt;a href=&quot;#prop_value_aliases()&quot;&gt;prop_value_aliases()&lt;/a&gt; when called in a scalar context. Of course, you can call &lt;a href=&quot;#prop_value_aliases()&quot;&gt;prop_value_aliases()&lt;/a&gt; on the result to get other synonyms.</source>
          <target state="translated">반환 값은 항상 스칼라 (문자열 또는 숫자)입니다. 값에 대한 동의어가있는 특성의 경우이 함수가 리턴하는 동의어 는 스칼라 컨텍스트에서 호출 될 때 &lt;a href=&quot;#prop_value_aliases()&quot;&gt;prop_value_aliases ()에&lt;/a&gt; 의해 리턴되는 가장 길고 가장 설명적인 형식 입니다. 물론 결과에서 &lt;a href=&quot;#prop_value_aliases()&quot;&gt;prop_value_aliases ()&lt;/a&gt; 를 호출 하여 다른 동의어를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="897578330f8509b5163b4447af0b4daff044a33c" translate="yes" xml:space="preserve">
          <source>The return value is formatted according to OLE conventions, as groups of hex digits with surrounding braces. For example:</source>
          <target state="translated">반환 값은 OLE 규칙에 따라 중괄호를 둘러싼 16 진수 그룹으로 형식이 지정됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="01e2753bab1a4f25f52114a02dccb7b840c45d95" translate="yes" xml:space="preserve">
          <source>The return value is the $ctx object itself.</source>
          <target state="translated">반환 값은 $ ctx 객체 자체입니다.</target>
        </trans-unit>
        <trans-unit id="437a2be9f2de32d0576eb59aa85a5731812472a7" translate="yes" xml:space="preserve">
          <source>The return value is the exit status of the program as returned by the &lt;a href=&quot;#wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt; call. To get the actual exit value, shift right by eight (see below). See also &lt;a href=&quot;#exec-LIST&quot;&gt;&lt;code&gt;exec&lt;/code&gt;&lt;/a&gt;. This is</source>
          <target state="translated">반환 값은 &lt;a href=&quot;#wait&quot;&gt; &lt;code&gt;wait&lt;/code&gt; &lt;/a&gt; 호출에 의해 반환 된 프로그램의 종료 상태입니다 . 실제 종료 값을 얻으려면 오른쪽으로 8만큼 이동합니다 (아래 참조). &lt;a href=&quot;#exec-LIST&quot;&gt; &lt;code&gt;exec&lt;/code&gt; &lt;/a&gt; 도 참조하십시오 . 이것은</target>
        </trans-unit>
        <trans-unit id="52ee5d406f163544969cdcc538ef722336dcb763" translate="yes" xml:space="preserve">
          <source>The return value is the exit status of the program as returned by the &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait&lt;/a&gt;&lt;/code&gt; call. To get the actual exit value, shift right by eight (see below). See also &lt;a href=&quot;#exec&quot;&gt;exec&lt;/a&gt;. This is</source>
          <target state="translated">리턴 값은 &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait&lt;/a&gt;&lt;/code&gt; 호출에 의해 리턴 된 프로그램의 종료 상태입니다 . 실제 종료 값을 얻으려면 8만큼 오른쪽으로 이동하십시오 (아래 참조). &lt;a href=&quot;#exec&quot;&gt;exec&lt;/a&gt; 도 참조하십시오 . 이것은</target>
        </trans-unit>
        <trans-unit id="aadd087b1069c48b3ff2e37ed0925a6bb732b05e" translate="yes" xml:space="preserve">
          <source>The return value is the exit status of the program as returned by the &lt;code&gt;&lt;a href=&quot;wait&quot;&gt;wait&lt;/a&gt;&lt;/code&gt; call. To get the actual exit value, shift right by eight (see below). See also &lt;a href=&quot;exec&quot;&gt;exec&lt;/a&gt;. This is</source>
          <target state="translated">리턴 값은 &lt;code&gt;&lt;a href=&quot;wait&quot;&gt;wait&lt;/a&gt;&lt;/code&gt; 호출에 의해 리턴 된 프로그램의 종료 상태입니다 . 실제 종료 값을 얻으려면 8만큼 오른쪽으로 이동하십시오 (아래 참조). &lt;a href=&quot;exec&quot;&gt;exec&lt;/a&gt; 도 참조하십시오 . 이것은</target>
        </trans-unit>
        <trans-unit id="28ff84250f55ab2bea98fda52eb0b62db0c2d4bd" translate="yes" xml:space="preserve">
          <source>The return value is the total length &lt;code&gt;src&lt;/code&gt; would be if the copy completely succeeded. If it is larger than &lt;code&gt;size&lt;/code&gt;, the excess was not copied.</source>
          <target state="translated">반환 값은 복사가 완전히 성공한 경우 &lt;code&gt;src&lt;/code&gt; 의 총 길이 입니다. &lt;code&gt;size&lt;/code&gt; 보다 큰 경우 초과분은 복사되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="db618f76ec023ae4b98dae939007dd3399a79764" translate="yes" xml:space="preserve">
          <source>The return value is the total length that &lt;code&gt;dst&lt;/code&gt; would have if &lt;code&gt;size&lt;/code&gt; is sufficiently large. Thus it is the initial length of &lt;code&gt;dst&lt;/code&gt; plus the length of &lt;code&gt;src&lt;/code&gt;. If &lt;code&gt;size&lt;/code&gt; is smaller than the return, the excess was not appended.</source>
          <target state="translated">반환 값은 &lt;code&gt;size&lt;/code&gt; 가 충분히 큰 경우 &lt;code&gt;dst&lt;/code&gt; 가 가질 수 있는 총 길이입니다 . 따라서 &lt;code&gt;dst&lt;/code&gt; 의 초기 길이에 &lt;code&gt;src&lt;/code&gt; 의 길이를 더한 값 입니다. 경우 &lt;code&gt;size&lt;/code&gt; 반환보다 작은, 초과가 추가되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="857262cdace40b471947bb6d3b761ee596eafe64" translate="yes" xml:space="preserve">
          <source>The return value is the updated object itself.</source>
          <target state="translated">반환 값은 업데이트 된 객체 자체입니다.</target>
        </trans-unit>
        <trans-unit id="7f93f7b8be78580a6fdb8b5153d679ad923050d6" translate="yes" xml:space="preserve">
          <source>The return value may be a list containing zero or more of an arrayref, an integer, or &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">리턴 값은 0 이상의 arrayref, integer 또는 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 를 포함하는 목록 일 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3f37d26524cdd675f6f08be05c61f9223fd0378a" translate="yes" xml:space="preserve">
          <source>The return value may be a list containing zero or more of an arrayref, an integer, or &lt;code&gt;undef&lt;/code&gt;.</source>
          <target state="translated">반환 값은 0 개 이상의 arrayref, 정수 또는 &lt;code&gt;undef&lt;/code&gt; 가 포함 된 목록 일 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="36fd088c56b8f88cc2d2e8985a8fda08a71a63d3" translate="yes" xml:space="preserve">
          <source>The return value may be an arrayref of 1st to 4th weights as shown above. The return value may be an integer as the primary weight as shown below. If &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; is returned, the default derived collation element will be used.</source>
          <target state="translated">리턴 값은 상기 도시 된 바와 같이 제 1 내지 제 4 가중치의 배열 참조 일 수있다. 리턴 값은 아래와 같이 1 차 가중치로서 정수일 수있다. 경우 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 반환되고, 기본 파생 조합 요소가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="68d7e0ec957990f452acfaa57c18c8410bd4dda3" translate="yes" xml:space="preserve">
          <source>The return value may be an arrayref of 1st to 4th weights as shown above. The return value may be an integer as the primary weight as shown below. If &lt;code&gt;undef&lt;/code&gt; is returned, the default derived collation element will be used.</source>
          <target state="translated">반환 값은 위와 같이 1 번째에서 4 번째 가중치의 arrayref 일 수 있습니다. 반환 값은 아래와 같이 기본 가중치로 정수일 수 있습니다. 경우 &lt;code&gt;undef&lt;/code&gt; 반환되고, 기본 파생 조합 요소가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="222fe952afa9c24172c89b0f769d4878a2ea7ad7" translate="yes" xml:space="preserve">
          <source>The return value of &lt;a href=&quot;#ioctl-FILEHANDLE%2CFUNCTION%2CSCALAR&quot;&gt;&lt;code&gt;ioctl&lt;/code&gt;&lt;/a&gt; (and &lt;a href=&quot;#fcntl-FILEHANDLE%2CFUNCTION%2CSCALAR&quot;&gt;&lt;code&gt;fcntl&lt;/code&gt;&lt;/a&gt;) is as follows:</source>
          <target state="translated">&lt;a href=&quot;#ioctl-FILEHANDLE%2CFUNCTION%2CSCALAR&quot;&gt; &lt;code&gt;ioctl&lt;/code&gt; &lt;/a&gt; (및 &lt;a href=&quot;#fcntl-FILEHANDLE%2CFUNCTION%2CSCALAR&quot;&gt; &lt;code&gt;fcntl&lt;/code&gt; &lt;/a&gt; ) 의 반환 값은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a717c20899094357a3bea685885351b6040d8de0" translate="yes" xml:space="preserve">
          <source>The return value of &lt;a href=&quot;#tell-FILEHANDLE&quot;&gt;&lt;code&gt;tell&lt;/code&gt;&lt;/a&gt; for the standard streams like the STDIN depends on the operating system: it may return -1 or something else. &lt;a href=&quot;#tell-FILEHANDLE&quot;&gt;&lt;code&gt;tell&lt;/code&gt;&lt;/a&gt; on pipes, fifos, and sockets usually returns -1.</source>
          <target state="translated">STDIN과 같은 표준 스트림에 대한 &lt;a href=&quot;#tell-FILEHANDLE&quot;&gt; &lt;code&gt;tell&lt;/code&gt; &lt;/a&gt; 의 반환 값은 운영 체제에 따라 다릅니다. -1 또는 다른 것을 반환 할 수 있습니다. 파이프, fifo 및 소켓에 &lt;a href=&quot;#tell-FILEHANDLE&quot;&gt; &lt;code&gt;tell&lt;/code&gt; &lt;/a&gt; on 일반적으로 -1을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="9d5675dc8f958bc8634e0a1b5851a8577fc5c3bc" translate="yes" xml:space="preserve">
          <source>The return value of &lt;code&gt;&lt;a href=&quot;functions/ioctl&quot;&gt;ioctl&lt;/a&gt;&lt;/code&gt; (and &lt;code&gt;&lt;a href=&quot;functions/fcntl&quot;&gt;fcntl&lt;/a&gt;&lt;/code&gt;) is as follows:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/ioctl&quot;&gt;ioctl&lt;/a&gt;&lt;/code&gt; (및 &lt;code&gt;&lt;a href=&quot;functions/fcntl&quot;&gt;fcntl&lt;/a&gt;&lt;/code&gt; ) 의 리턴 값은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="03abb254ae6958b0d4d3e3d838f5570ae93832e6" translate="yes" xml:space="preserve">
          <source>The return value of &lt;code&gt;&lt;a href=&quot;ioctl&quot;&gt;ioctl&lt;/a&gt;&lt;/code&gt; (and &lt;code&gt;&lt;a href=&quot;fcntl&quot;&gt;fcntl&lt;/a&gt;&lt;/code&gt;) is as follows:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ioctl&quot;&gt;ioctl&lt;/a&gt;&lt;/code&gt; (및 &lt;code&gt;&lt;a href=&quot;fcntl&quot;&gt;fcntl&lt;/a&gt;&lt;/code&gt; ) 의 리턴 값은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="16085bf8175ff49a2dcc989db1bc66f5346f4ab0" translate="yes" xml:space="preserve">
          <source>The return value of &lt;code&gt;INLINED&lt;/code&gt; in this example will always be 54321, regardless of later modifications to $x. You can also put any arbitrary code inside the sub, at it will be executed immediately and its return value captured the same way.</source>
          <target state="translated">이 예에서 &lt;code&gt;INLINED&lt;/code&gt; 의 반환 값은 나중에 $ x 수정에 관계없이 항상 54321입니다. 서브 내에 임의의 코드를 넣을 수도 있습니다. 서브 코드는 즉시 실행되며 반환 값은 같은 방식으로 캡처됩니다.</target>
        </trans-unit>
        <trans-unit id="f23542316437f18c2dc0de0ad16ae0deb404671a" translate="yes" xml:space="preserve">
          <source>The return value of &lt;code&gt;survey&lt;/code&gt; is two hashes:</source>
          <target state="translated">&lt;code&gt;survey&lt;/code&gt; 의 반환 값 은 두 가지 해시입니다.</target>
        </trans-unit>
        <trans-unit id="6c7d2d6bce6775764986b9434f93f3fd3d99f22b" translate="yes" xml:space="preserve">
          <source>The return value of Pod::Perldoc::GetOptsOO::getopts is true if no errors, otherwise it's false.</source>
          <target state="translated">Pod :: Perldoc :: GetOptsOO :: getopts의 반환 값은 오류가 없으면 true이고, 그렇지 않으면 false입니다.</target>
        </trans-unit>
        <trans-unit id="57cb77ff2698d7727be628530d185f8aa579f00d" translate="yes" xml:space="preserve">
          <source>The return value of tell() for the standard streams like the STDIN depends on the operating system: it may return -1 or something else. tell() on pipes, fifos, and sockets usually returns -1.</source>
          <target state="translated">STDIN과 같은 표준 스트림에 대한 tell ()의 리턴 값은 운영 체제에 따라 다릅니다. -1 또는 다른 것을 리턴 할 수 있습니다. 파이프, fifo 및 소켓의 tell ()은 일반적으로 -1을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d4713d5655dc6e9b8c7a80e55df87e6a297b0b32" translate="yes" xml:space="preserve">
          <source>The return value will be &lt;code&gt;NULL&lt;/code&gt; if the operation failed or if the value did not need to be actually stored within the hash (as in the case of tied hashes). Otherwise it can be dereferenced to get the original &lt;code&gt;SV*&lt;/code&gt;. Note that the caller is responsible for suitably incrementing the reference count of &lt;code&gt;val&lt;/code&gt; before the call, and decrementing it if the function returned &lt;code&gt;NULL&lt;/code&gt;. Effectively a successful &lt;code&gt;hv_store&lt;/code&gt; takes ownership of one reference to &lt;code&gt;val&lt;/code&gt;. This is usually what you want; a newly created SV has a reference count of one, so if all your code does is create SVs then store them in a hash, &lt;code&gt;hv_store&lt;/code&gt; will own the only reference to the new SV, and your code doesn't need to do anything further to tidy up. &lt;code&gt;hv_store&lt;/code&gt; is not implemented as a call to &lt;code&gt;hv_store_ent&lt;/code&gt;, and does not create a temporary SV for the key, so if your key data is not already in SV form then use &lt;code&gt;hv_store&lt;/code&gt; in preference to &lt;code&gt;hv_store_ent&lt;/code&gt;.</source>
          <target state="translated">작업이 실패했거나 값이 실제로 해시 내에 저장 될 필요가없는 경우 (연결된 해시의 경우와 같이) 반환 값은 &lt;code&gt;NULL&lt;/code&gt; 입니다. 그렇지 않으면 원래 &lt;code&gt;SV*&lt;/code&gt; 를 얻기 위해 역 참조 될 수 있습니다 . 호출자는 호출 전에 &lt;code&gt;val&lt;/code&gt; 의 참조 카운트를 적절하게 증가 시키고 함수가 &lt;code&gt;NULL&lt;/code&gt; 을 반환하면이를 감소시킬 책임이 있습니다 . 실제로 성공적인 &lt;code&gt;hv_store&lt;/code&gt; 는 &lt;code&gt;val&lt;/code&gt; 에 대한 하나의 참조를 소유 합니다. 이것은 일반적으로 원하는 것입니다. 새로 생성 된 SV는 참조 횟수가 1이므로 코드가 SV를 생성 한 다음 해시 &lt;code&gt;hv_store&lt;/code&gt; 에 저장하기 만하면됩니다.새 SV에 대한 유일한 참조를 소유하며 코드를 정리하기 위해 추가 작업을 수행 할 필요가 없습니다. &lt;code&gt;hv_store&lt;/code&gt; 는 의 호출로 구현되지 &lt;code&gt;hv_store_ent&lt;/code&gt; 하고 주요 데이터는 다음 사용 SV 양식에없는 그렇다면, 키위한 임시 SV를 만들지 않습니다 &lt;code&gt;hv_store&lt;/code&gt; 을 에 우선 &lt;code&gt;hv_store_ent&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="972da9f747345510c81b2dc820fd0994a9799509" translate="yes" xml:space="preserve">
          <source>The return value will be NULL if the operation failed or if the value did not need to be actually stored within the hash (as in the case of tied hashes). Otherwise it can be dereferenced to get the original &lt;code&gt;SV*&lt;/code&gt; . Note that the caller is responsible for suitably incrementing the reference count of &lt;code&gt;val&lt;/code&gt; before the call, and decrementing it if the function returned NULL. Effectively a successful hv_store takes ownership of one reference to &lt;code&gt;val&lt;/code&gt; . This is usually what you want; a newly created SV has a reference count of one, so if all your code does is create SVs then store them in a hash, hv_store will own the only reference to the new SV, and your code doesn't need to do anything further to tidy up. hv_store is not implemented as a call to hv_store_ent, and does not create a temporary SV for the key, so if your key data is not already in SV form then use hv_store in preference to hv_store_ent.</source>
          <target state="translated">작업이 실패했거나 값이 실제로 해시 내에 저장 될 필요가없는 경우 반환 값은 NULL이됩니다 (연결된 해시의 경우). 그렇지 않으면 원래 &lt;code&gt;SV*&lt;/code&gt; 를 얻기 위해 역 참조 될 수 있습니다 . 호출자는 호출 전에 &lt;code&gt;val&lt;/code&gt; 의 참조 카운트를 적절하게 증가 시키고 함수가 NULL을 리턴하면 감소시킵니다. 효과적으로 성공적인 hv_store는 &lt;code&gt;val&lt;/code&gt; 에 대한 하나의 참조 소유권을 갖습니다.. 이것은 일반적으로 원하는 것입니다. 새로 생성 된 SV의 참조 카운트는 1입니다. 따라서 모든 코드에서 SV를 생성 한 다음 해시에 저장하면 hv_store는 새 SV에 대한 유일한 참조를 소유하며 코드는 더 이상 수행 할 작업이 없습니다. 치우다. hv_store는 hv_store_ent에 대한 호출로 구현되지 않으며 키에 대한 임시 SV를 작성하지 않으므로 키 데이터가 아직 SV 형식이 아닌 경우 hv_store를 기본적으로 hv_store_ent보다 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="9bfc61e3c5920efd0c58d16c1ed44649d2d5bb7c" translate="yes" xml:space="preserve">
          <source>The return value will be a list; the first value being an error condition, followed by the hostname and service name.</source>
          <target state="translated">반환 값은리스트가됩니다. 첫 번째 값은 오류 조건이며 호스트 이름과 서비스 이름이 뒤 따릅니다.</target>
        </trans-unit>
        <trans-unit id="080fb2b25b92c9701522bdcbe08ea5301edb65d9" translate="yes" xml:space="preserve">
          <source>The return value will be a list; the first value being an error indication, followed by a list of address structures (if no error occurred).</source>
          <target state="translated">반환 값은리스트가됩니다. 첫 번째 값은 오류 표시이며, 주소 구조 목록 (오류가 발생하지 않은 경우)이 뒤 따릅니다.</target>
        </trans-unit>
        <trans-unit id="e58ba0106a37355ff008e5789a74611883b7e6cc" translate="yes" xml:space="preserve">
          <source>The return value will be a reference to a hash where the keys are the message numbers and each value contains a reference to an array which contains the overview fields for that message.</source>
          <target state="translated">반환 값은 키가 메시지 번호이고 각 값에 해당 메시지의 개요 필드가 포함 된 배열에 대한 참조가 포함 된 해시에 대한 참조입니다.</target>
        </trans-unit>
        <trans-unit id="c8d88b4235e896d1cdf2637f38fe289f36609de1" translate="yes" xml:space="preserve">
          <source>The return value will be a reference to a hash where the keys are the message numbers and each value contains the text of the requested header for that message.</source>
          <target state="translated">반환 값은 키가 메시지 번호이고 각 값에 해당 메시지의 요청 된 헤더 텍스트가 포함 된 해시에 대한 참조입니다.</target>
        </trans-unit>
        <trans-unit id="7ff5356b785d18cf62379ed63c212e5a8a9ffb9a" translate="yes" xml:space="preserve">
          <source>The return values are more &quot;cooked&quot; than the &lt;a href=&quot;#charinfo%28%29&quot;&gt;&quot;charinfo()&quot;&lt;/a&gt; ones. For example, the &lt;code&gt;&quot;uc&quot;&lt;/code&gt; property value is the actual string containing the full uppercase mapping of the input code point. You have to go to extra trouble with &lt;code&gt;charinfo&lt;/code&gt; to get this value from its &lt;code&gt;upper&lt;/code&gt; hash element when the full mapping differs from the simple one.</source>
          <target state="translated">반환 값은 &lt;a href=&quot;#charinfo%28%29&quot;&gt;&quot;charinfo ()&quot;&lt;/a&gt; 값보다 더 &quot;요리 &quot; 됩니다. 예를 들어, &lt;code&gt;&quot;uc&quot;&lt;/code&gt; 속성 값은 입력 코드 포인트의 전체 대문자 매핑을 포함하는 실제 문자열입니다. 전체 매핑이 단순 매핑과 다를 때 &lt;code&gt;upper&lt;/code&gt; 해시 요소 에서이 값을 가져 오려면 &lt;code&gt;charinfo&lt;/code&gt; 에 추가 문제가 발생 해야 합니다.</target>
        </trans-unit>
        <trans-unit id="17d18fcb9f371a15bbc60a7727df47264e8d90a5" translate="yes" xml:space="preserve">
          <source>The return values are more &quot;cooked&quot; than the &lt;a href=&quot;#charinfo()&quot;&gt;charinfo()&lt;/a&gt; ones. For example, the &lt;code&gt;&quot;uc&quot;&lt;/code&gt; property value is the actual string containing the full uppercase mapping of the input code point. You have to go to extra trouble with &lt;code&gt;charinfo&lt;/code&gt; to get this value from its &lt;code&gt;upper&lt;/code&gt; hash element when the full mapping differs from the simple one.</source>
          <target state="translated">반환 값은 &lt;a href=&quot;#charinfo()&quot;&gt;charinfo ()&lt;/a&gt; 보다 &quot;요리&quot; 됩니다. 예를 들어, &lt;code&gt;&quot;uc&quot;&lt;/code&gt; 속성 값은 입력 코드 포인트의 전체 대문자 매핑을 포함하는 실제 문자열입니다. 전체 매핑이 간단한 것과 다를 때 &lt;code&gt;upper&lt;/code&gt; 해시 요소 에서이 값을 얻으려면 &lt;code&gt;charinfo&lt;/code&gt; 를 사용 하여 추가 문제를 해결 해야 합니다.</target>
        </trans-unit>
        <trans-unit id="a0c27b1b52fce6c8f2f090cdffac0089b776c9ec" translate="yes" xml:space="preserve">
          <source>The returned NaN is always a</source>
          <target state="translated">반환 된 NaN은 항상</target>
        </trans-unit>
        <trans-unit id="e761cd70527853f3676a64d7d2be637d80127b77" translate="yes" xml:space="preserve">
          <source>The returned hash consists of 4 parts:</source>
          <target state="translated">반환 된 해시는 다음 4 개 부분으로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="ac925fdbc70f038b7d79d3f22cbbb8542015b931" translate="yes" xml:space="preserve">
          <source>The returned list will begin with the initial value for &lt;code&gt;$a&lt;/code&gt;, followed by each return value from the block in order. The final value of the result will be identical to what the &lt;code&gt;reduce&lt;/code&gt; function would have returned given the same block and list.</source>
          <target state="translated">반환 된 목록은 &lt;code&gt;$a&lt;/code&gt; 의 초기 값으로 시작 하고 블록의 각 반환 값이 순서대로 이어집니다. 결과의 최종 값은 동일한 블록 및 목록이 주어 졌을 때 &lt;code&gt;reduce&lt;/code&gt; 함수가 반환 한 값과 동일합니다.</target>
        </trans-unit>
        <trans-unit id="3df12c311a5affa1878c7637ef497a0992643ca1" translate="yes" xml:space="preserve">
          <source>The returned object will only be valid as long as the underlying OPs and SVs continue to exist. Do not attempt to use the object after the underlying structures are freed.</source>
          <target state="translated">리턴 된 오브젝트는 기본 OP 및 SV가 계속 존재하는 한 유효합니다. 기본 구조가 해제 된 후 오브젝트를 사용하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="27c81be6b30926294699f4659627b6ffa79304d4" translate="yes" xml:space="preserve">
          <source>The returned script will be &lt;code&gt;SCX_Inherited&lt;/code&gt; iff all the code points in it are from the Inherited script.</source>
          <target state="translated">반환 된 스크립트는 모든 코드 포인트가 Inherited 스크립트에서 온 &lt;code&gt;SCX_Inherited&lt;/code&gt; 가됩니다.</target>
        </trans-unit>
        <trans-unit id="2c9c36a9cfb66d7244d884d86187f93dbed4c9d0" translate="yes" xml:space="preserve">
          <source>The returned value will have the characters that can't be decoded replaced by &quot;\x{FFFD}&quot;, the Unicode replacement character.</source>
          <target state="translated">반환 된 값에는 디코딩 할 수없는 문자가 유니 코드 대체 문자 인 &quot;\ x {FFFD}&quot;로 대체됩니다.</target>
        </trans-unit>
        <trans-unit id="afb88fca63fb7d940d0f8f78e07d1c80fa709c01" translate="yes" xml:space="preserve">
          <source>The returned values are copies of the original keys in the hash, so modifying them will not affect the original hash. Compare &lt;a href=&quot;#values&quot;&gt;values&lt;/a&gt;.</source>
          <target state="translated">반환 된 값은 해시의 원래 키 사본이므로 수정하면 원래 해시에 영향을 미치지 않습니다. &lt;a href=&quot;#values&quot;&gt;값을&lt;/a&gt; 비교하십시오 .</target>
        </trans-unit>
        <trans-unit id="a3aac40383199a850fb451c54d0b1c983a804515" translate="yes" xml:space="preserve">
          <source>The returned values are copies of the original keys in the hash, so modifying them will not affect the original hash. Compare &lt;a href=&quot;#values-HASH&quot;&gt;&lt;code&gt;values&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">반환 된 값은 해시에있는 원래 키의 복사본이므로 수정해도 원래 해시에는 영향을주지 않습니다. &lt;a href=&quot;#values-HASH&quot;&gt; &lt;code&gt;values&lt;/code&gt; &lt;/a&gt; 비교 합니다 .</target>
        </trans-unit>
        <trans-unit id="9d53dad6b674af04a6d84ac0aee48048c271fdde" translate="yes" xml:space="preserve">
          <source>The returned values are copies of the original keys in the hash, so modifying them will not affect the original hash. Compare &lt;a href=&quot;values&quot;&gt;values&lt;/a&gt;.</source>
          <target state="translated">반환 된 값은 해시의 원래 키 사본이므로 수정하면 원래 해시에 영향을 미치지 않습니다. &lt;a href=&quot;values&quot;&gt;값을&lt;/a&gt; 비교하십시오 .</target>
        </trans-unit>
        <trans-unit id="21a00c167788624d4ca90d4b617125a344dae47a" translate="yes" xml:space="preserve">
          <source>The returned values for the Perl extension properties, such as &lt;code&gt;Any&lt;/code&gt; and &lt;code&gt;Greek&lt;/code&gt; are somewhat misleading. The values are either &lt;code&gt;&quot;Y&quot;&lt;/code&gt; or &lt;code&gt;&quot;N&lt;/code&gt; &quot;. All Unicode properties are bipartite, so you can actually use the &lt;code&gt;&quot;Y&quot;&lt;/code&gt; or &lt;code&gt;&quot;N&lt;/code&gt; &quot; in a Perl regular rexpression for these, like &lt;code&gt;&lt;a href=&quot;../functions/qr&quot;&gt;qr/\p{ID_Start=Y/}&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../functions/qr&quot;&gt;qr/\p{Upper=N/}&lt;/a&gt;&lt;/code&gt;. But the Perl extensions aren't specified this way, only like &lt;code&gt;/qr/\p{Any}&lt;/code&gt; ,</source>
          <target state="translated">&lt;code&gt;Any&lt;/code&gt; 및 &lt;code&gt;Greek&lt;/code&gt; 과 같은 Perl 확장 등록 정보에 대해 리턴 된 값 은 다소 오해의 소지가 있습니다. 값은 &lt;code&gt;&quot;Y&quot;&lt;/code&gt; 또는 &lt;code&gt;&quot;N&lt;/code&gt; &quot;입니다. 모든 유니 코드 속성은이 분식이므로 &lt;code&gt;&lt;a href=&quot;../functions/qr&quot;&gt;qr/\p{ID_Start=Y/}&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;../functions/qr&quot;&gt;qr/\p{Upper=N/}&lt;/a&gt;&lt;/code&gt; 과 같이 Perl 정규 rexpression에서 &lt;code&gt;&quot;Y&quot;&lt;/code&gt; 또는 &lt;code&gt;&quot;N&lt;/code&gt; &quot;을 실제로 사용할 수 있습니다 . 그러나 Perl 확장은 &lt;code&gt;/qr/\p{Any}&lt;/code&gt; 와 같이이 방법으로 지정되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="0b00496e0ac48606a2b2f5ade4900470b3e5cc37" translate="yes" xml:space="preserve">
          <source>The returned values for the Perl extension properties, such as &lt;code&gt;Any&lt;/code&gt; and &lt;code&gt;Greek&lt;/code&gt; are somewhat misleading. The values are either &lt;code&gt;&quot;Y&quot;&lt;/code&gt; or &lt;code&gt;&quot;N&lt;/code&gt;&quot;. All Unicode properties are bipartite, so you can actually use the &lt;code&gt;&quot;Y&quot;&lt;/code&gt; or &lt;code&gt;&quot;N&lt;/code&gt;&quot; in a Perl regular expression for these, like &lt;code&gt;qr/\p{ID_Start=Y/}&lt;/code&gt; or &lt;code&gt;qr/\p{Upper=N/}&lt;/code&gt;. But the Perl extensions aren't specified this way, only like &lt;code&gt;/qr/\p{Any}&lt;/code&gt;,</source>
          <target state="translated">&lt;code&gt;Any&lt;/code&gt; 및 &lt;code&gt;Greek&lt;/code&gt; 과 같은 Perl 확장 속성에 대해 반환 된 값 은 다소 오해의 소지가 있습니다. 값은 &lt;code&gt;&quot;Y&quot;&lt;/code&gt; 또는 &lt;code&gt;&quot;N&lt;/code&gt; &quot;입니다. 모든 유니 코드 속성은 두 부분으로되어 있으므로 실제로 &lt;code&gt;qr/\p{ID_Start=Y/}&lt;/code&gt; 또는 &lt;code&gt;qr/\p{Upper=N/}&lt;/code&gt; 와 같이 Perl 정규식에서 &lt;code&gt;&quot;Y&quot;&lt;/code&gt; 또는 &lt;code&gt;&quot;N&lt;/code&gt; &quot;을 사용할 수 있습니다 . 그러나 Perl 확장은 이런 방식으로 지정되지 않습니다. &lt;code&gt;/qr/\p{Any}&lt;/code&gt; 처럼,</target>
        </trans-unit>
        <trans-unit id="f5eea968d1f523529d28fcd024fbb7e15c83c048" translate="yes" xml:space="preserve">
          <source>The revision, version, and subversion of the Perl interpreter, represented as a &lt;a href=&quot;version&quot;&gt;version&lt;/a&gt; object.</source>
          <target state="translated">Perl 인터프리터의 개정, 버전 및 하위 &lt;a href=&quot;version&quot;&gt;버전&lt;/a&gt; 은 버전 객체 로 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="85e9edc5bb272a0ee91c10e7c6d3172fdb763afd" translate="yes" xml:space="preserve">
          <source>The revision, version, and subversion of the Perl interpreter, represented as a decimal of the form 5.XXXYYY, where XXX is the version / 1e3 and YYY is the subversion / 1e6. For example, Perl v5.10.1 would be &quot;5.010001&quot;.</source>
          <target state="translated">Perl 인터프리터의 개정, 버전 및 하위 버전은 5.XXXYYY 형식의 10 진수로 표시됩니다. 여기서 XXX는 버전 / 1e3이고 YYY는 하위 버전 / 1e6입니다. 예를 들어 Perl v5.10.1은 &quot;5.010001&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="66e488be2f8483df95b9f037ffeda3de74384599" translate="yes" xml:space="preserve">
          <source>The rewritten version of this module (vs. v0.01) is slower on certain operations, like &lt;code&gt;new()&lt;/code&gt; , &lt;code&gt;bstr()&lt;/code&gt; and &lt;code&gt;numify()&lt;/code&gt; . The reason are that it does now more work and handles much more cases. The time spent in these operations is usually gained in the other math operations so that code on the average should get (much) faster. If they don't, please contact the author.</source>
          <target state="translated">이 모듈의 재 작성된 버전 (vs. v0.01)은 &lt;code&gt;new()&lt;/code&gt; , &lt;code&gt;bstr()&lt;/code&gt; 및 &lt;code&gt;numify()&lt;/code&gt; 와 같은 특정 작업에서 느립니다 . 그 이유는 이제 더 많은 작업을 수행하고 더 많은 사례를 처리하기 때문입니다. 이러한 연산에 소요되는 시간은 일반적으로 다른 수학 연산에서 얻으므로 평균 코드가 훨씬 빨라집니다. 그렇지 않은 경우 저자에게 문의하십시오.</target>
        </trans-unit>
        <trans-unit id="d648a5385a086d97fdf940828d9fd6d003974ab0" translate="yes" xml:space="preserve">
          <source>The rewritten version of this module (vs. v0.01) is slower on certain operations, like &lt;code&gt;new()&lt;/code&gt;, &lt;code&gt;bstr()&lt;/code&gt; and &lt;code&gt;numify()&lt;/code&gt;. The reason are that it does now more work and handles much more cases. The time spent in these operations is usually gained in the other math operations so that code on the average should get (much) faster. If they don't, please contact the author.</source>
          <target state="translated">이 모듈의 재 작성된 버전 (vs. v0.01)은 &lt;code&gt;new()&lt;/code&gt; , &lt;code&gt;bstr()&lt;/code&gt; 및 &lt;code&gt;numify()&lt;/code&gt; 와 같은 특정 작업에서 더 느립니다 . 그 이유는 이제 더 많은 작업을 수행하고 훨씬 더 많은 케이스를 처리하기 때문입니다. 이러한 연산에 소요되는 시간은 일반적으로 다른 수학 연산에서 얻어 지므로 평균적으로 코드가 (훨씬) 더 빨라질 것입니다. 그렇지 않은 경우 저자에게 문의하십시오.</target>
        </trans-unit>
        <trans-unit id="23622f986ab9be80262d33005c6066bc0cc050da" translate="yes" xml:space="preserve">
          <source>The right column will also caution you if a property means something different than what might normally be expected.</source>
          <target state="translated">속성이 일반적으로 예상되는 것과 다른 것을 의미하는 경우 오른쪽 열에도주의가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="ae21a75ed2b2f6ef4dbb92843a55ab639a296c6c" translate="yes" xml:space="preserve">
          <source>The right hand side, starting at line 5 is similar to what we've just seen: we have the &lt;code&gt;add&lt;/code&gt; op (&lt;code&gt;pp_add&lt;/code&gt; also in</source>
          <target state="translated">라인 5에서 시작하는 오른쪽은 방금 본 것과 유사합니다. &lt;code&gt;add&lt;/code&gt; op ( &lt;code&gt;pp_add&lt;/code&gt; in</target>
        </trans-unit>
        <trans-unit id="a97b5a9d26a8152b03235a227c2f7630aad78c10" translate="yes" xml:space="preserve">
          <source>The right hand side, starting at line 5 is similar to what we've just seen: we have the &lt;code&gt;add&lt;/code&gt; op (&lt;code&gt;pp_add&lt;/code&gt;, also in</source>
          <target state="translated">5 행에서 시작하는 오른쪽은 방금 본 것과 유사합니다. 우리는 &lt;code&gt;add&lt;/code&gt; op ( &lt;code&gt;pp_add&lt;/code&gt; ,</target>
        </trans-unit>
        <trans-unit id="88e3fe5f1905fd5d0642f37b1a353b457c2b5b66" translate="yes" xml:space="preserve">
          <source>The right operand is not evaluated while the operator is in the &quot;false&quot; state, and the left operand is not evaluated while the operator is in the &quot;true&quot; state. The precedence is a little lower than || and &amp;amp;&amp;amp;. The value returned is either the empty string for false, or a sequence number (beginning with 1) for true. The sequence number is reset for each range encountered. The final sequence number in a range has the string &lt;code&gt;&quot;E0&quot;&lt;/code&gt; appended to it, which doesn't affect its numeric value, but gives you something to search for if you want to exclude the endpoint. You can exclude the beginning point by waiting for the sequence number to be greater than 1.</source>
          <target state="translated">연산자가 &quot;false&quot;상태 인 동안 오른쪽 피연산자가 평가되지 않고 연산자가 &quot;true&quot;상태 인 동안 왼쪽 피연산자가 평가되지 않습니다. 우선 순위는 ||보다 약간 낮습니다. &amp;amp;&amp;amp;. 리턴 된 값은 false의 경우 빈 문자열이거나 true의 경우 시퀀스 번호 (1부터 시작)입니다. 시퀀스 번호는 발생한 각 범위에 대해 재설정됩니다. 범위의 최종 시퀀스 번호에는 문자열 &lt;code&gt;&quot;E0&quot;&lt;/code&gt; 이 추가되어 숫자 값에 영향을 미치지 않지만 엔드 포인트를 제외하려는 경우 검색 할 항목을 제공합니다. 시퀀스 번호가 1보다 커질 때까지 대기하여 시작점을 제외 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="712b7dd783ec62d03111b67512c4c71fb70fa066" translate="yes" xml:space="preserve">
          <source>The rightmost delimiter beginning the argument text to the interior sequence (should be &quot;&amp;gt;&quot;).</source>
          <target state="translated">내부 텍스트에서 인수 텍스트를 시작하는 가장 오른쪽 분리 문자 ( &quot;&amp;gt;&quot;여야 함).</target>
        </trans-unit>
        <trans-unit id="f1b13ab5c99b5028d035c2e34026b78f830a5ce1" translate="yes" xml:space="preserve">
          <source>The rmtree() function provide the legacy interface of remove_tree() with a different interpretation of the arguments passed. The behaviour and return value of the function is otherwise identical to remove_tree().</source>
          <target state="translated">rmtree () 함수는 전달 된 인수에 대한 다른 해석으로 remove_tree ()의 레거시 인터페이스를 제공합니다. 함수의 동작 및 반환 값은 그렇지 않으면 remove_tree ()와 동일합니다.</target>
        </trans-unit>
        <trans-unit id="97d9690fe48f5ed9ac8be9b70513653d3ab42339" translate="yes" xml:space="preserve">
          <source>The rot13 example was a trivial example. Here's another demonstration that shows off a few more features.</source>
          <target state="translated">rot13 예제는 간단한 예제였습니다. 몇 가지 추가 기능을 보여주는 또 다른 데모가 있습니다.</target>
        </trans-unit>
        <trans-unit id="4a28f646da84403da9a05e371721d016d1168285" translate="yes" xml:space="preserve">
          <source>The rough perl equivalent is &lt;code&gt;$myarray[$idx]&lt;/code&gt; .</source>
          <target state="translated">대략적인 perl은 &lt;code&gt;$myarray[$idx]&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="4b4a8606a49a46444c3a9ed277908732090e4141" translate="yes" xml:space="preserve">
          <source>The rough perl equivalent is &lt;code&gt;$myarray[$key]&lt;/code&gt;.</source>
          <target state="translated">대략적인 펄은 &lt;code&gt;$myarray[$key]&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="07cb0ce6d373861ed9384fe1d2dba7e82ae7d7eb" translate="yes" xml:space="preserve">
          <source>The routine &lt;code&gt;regtail()&lt;/code&gt; is called by both &lt;code&gt;reg()&lt;/code&gt; and &lt;code&gt;regbranch()&lt;/code&gt; in order to &quot;set the tail pointer&quot; correctly. When executing and we get to the end of a branch, we need to go to the node following the grouping parens. When parsing, however, we don't know where the end will be until we get there, so when we do we must go back and update the offsets as appropriate. &lt;code&gt;regtail&lt;/code&gt; is used to make this easier.</source>
          <target state="translated">&lt;code&gt;regtail()&lt;/code&gt; 루틴 은 &quot;꼬리 포인터&quot;를 올바르게 설정하기 위해 &lt;code&gt;reg()&lt;/code&gt; 와 &lt;code&gt;regbranch()&lt;/code&gt; 에 의해 호출 됩니다. 실행하고 분기가 끝날 때 그룹화 parens 다음에있는 노드로 이동해야합니다. 그러나 파싱 할 때 우리는 도착할 때까지 끝이 어디인지 알지 못하므로 돌아올 때 오프셋을 적절히 업데이트해야합니다. &lt;code&gt;regtail&lt;/code&gt; 은 이것을 쉽게하기 위해 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="96fb8a6192d6d2137dae358308fab281f2803684" translate="yes" xml:space="preserve">
          <source>The routine indicated by &lt;code&gt;$SIG{__DIE__}&lt;/code&gt; is called when a fatal exception is about to be thrown. The error message is passed as the first argument. When a &lt;code&gt;__DIE__&lt;/code&gt; hook routine returns, the exception processing continues as it would have in the absence of the hook, unless the hook routine itself exits via a &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt; &amp;amp;sub&lt;/code&gt; , a loop exit, or a &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die()&lt;/a&gt;&lt;/code&gt;. The &lt;code&gt;__DIE__&lt;/code&gt; handler is explicitly disabled during the call, so that you can die from a &lt;code&gt;__DIE__&lt;/code&gt; handler. Similarly for &lt;code&gt;__WARN__&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;$SIG{__DIE__}&lt;/code&gt; 로 표시된 루틴은 치명적인 예외가 발생하려고 할 때 호출됩니다. 오류 메시지가 첫 번째 인수로 전달됩니다. 경우 &lt;code&gt;__DIE__&lt;/code&gt; 의 후크 루틴 복귀가 후크 부재에있는 것처럼 후크 루틴 자체를 통해 배출되지 않는 한, 예외 처리가 계속 &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt; &amp;amp;sub&lt;/code&gt; 루프 종료 또는 &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die()&lt;/a&gt;&lt;/code&gt; . &lt;code&gt;__DIE__&lt;/code&gt; 의 핸들러는 명시 적으로 당신이 죽을 수 있도록하는 것이, 통화 중에 사용할 수 없습니다 &lt;code&gt;__DIE__&lt;/code&gt; 의 핸들러입니다. &lt;code&gt;__WARN__&lt;/code&gt; 의 경우와 유사합니다 .</target>
        </trans-unit>
        <trans-unit id="a3747082bcec8b320b157ca0f6db8a2c2a773d76" translate="yes" xml:space="preserve">
          <source>The routine indicated by &lt;code&gt;$SIG{__DIE__}&lt;/code&gt; is called when a fatal exception is about to be thrown. The error message is passed as the first argument. When a &lt;code&gt;__DIE__&lt;/code&gt; hook routine returns, the exception processing continues as it would have in the absence of the hook, unless the hook routine itself exits via a &lt;code&gt;goto &amp;amp;sub&lt;/code&gt;, a loop exit, or a &lt;code&gt;die()&lt;/code&gt;. The &lt;code&gt;__DIE__&lt;/code&gt; handler is explicitly disabled during the call, so that you can die from a &lt;code&gt;__DIE__&lt;/code&gt; handler. Similarly for &lt;code&gt;__WARN__&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;$SIG{__DIE__}&lt;/code&gt; 로 표시된 루틴은 치명적인 예외가 발생하려고 할 때 호출됩니다. 오류 메시지는 첫 번째 인수로 전달됩니다. 경우 &lt;code&gt;__DIE__&lt;/code&gt; 의 후크 루틴 복귀가 후크 부재에있는 것처럼 후크 루틴 자체를 통해 배출되지 않는 한, 예외 처리가 계속 &lt;code&gt;goto &amp;amp;sub&lt;/code&gt; 루프 종료 또는 &lt;code&gt;die()&lt;/code&gt; . &lt;code&gt;__DIE__&lt;/code&gt; 의 핸들러는 명시 적으로 당신이 죽을 수 있도록하는 것이, 통화 중에 사용할 수 없습니다 &lt;code&gt;__DIE__&lt;/code&gt; 의 핸들러입니다. &lt;code&gt;__WARN__&lt;/code&gt; 과 유사합니다 .</target>
        </trans-unit>
        <trans-unit id="c23e498d9e0f7b9916602bb81bb457e05dc15d28" translate="yes" xml:space="preserve">
          <source>The routine most often used is &lt;code&gt;call_sv&lt;/code&gt; . The &lt;code&gt;SV*&lt;/code&gt; argument contains either the name of the Perl subroutine to be called, or a reference to the subroutine. The second argument consists of flags that control the context in which the subroutine is called, whether or not the subroutine is being passed arguments, how errors should be trapped, and how to treat return values.</source>
          <target state="translated">가장 자주 사용되는 루틴은 &lt;code&gt;call_sv&lt;/code&gt; 입니다. &lt;code&gt;SV*&lt;/code&gt; 인수 중 펄 서브 루틴의 이름을 포함하는 호출 또는 서브 루틴을 참조한다. 두 번째 인수는 서브 루틴이 호출되는 컨텍스트, 서브 루틴의 인수 전달 여부, 오류 트랩 방법 및 리턴 값 처리 방법을 제어하는 ​​플래그로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="8b9d3fc2ab950a51903275842538b6aa8532b735" translate="yes" xml:space="preserve">
          <source>The routine most often used is &lt;code&gt;call_sv&lt;/code&gt;. The &lt;code&gt;SV*&lt;/code&gt; argument contains either the name of the Perl subroutine to be called, or a reference to the subroutine. The second argument consists of flags that control the context in which the subroutine is called, whether or not the subroutine is being passed arguments, how errors should be trapped, and how to treat return values.</source>
          <target state="translated">가장 자주 사용되는 루틴은 &lt;code&gt;call_sv&lt;/code&gt; 입니다. &lt;code&gt;SV*&lt;/code&gt; 인수 중 펄 서브 루틴의 이름을 포함하는 호출 또는 서브 루틴을 참조한다. 두 번째 인수는 서브 루틴이 호출되는 컨텍스트, 서브 루틴이 인수를 전달하는지 여부, 오류를 트랩하는 방법 및 반환 값을 처리하는 방법을 제어하는 ​​플래그로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="02aa17c916dde6540e50fc69118a82269239b3fa" translate="yes" xml:space="preserve">
          <source>The routine returns &lt;b&gt;false&lt;/b&gt; otherwise.</source>
          <target state="translated">그렇지 않으면 루틴은 &lt;b&gt;false를&lt;/b&gt; 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="2a6f415596eaaeb6ae6674de29690a406129631d" translate="yes" xml:space="preserve">
          <source>The routine returns &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; for I/O problems or other internal error, a true value otherwise. Serious errors are propagated as a &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; exception.</source>
          <target state="translated">루틴은 I / O 문제점 또는 기타 내부 오류에 대해 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 를 리턴 하고 그렇지 않으면 true 값을 리턴합니다 . 심각한 오류는 &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; 예외 로 전파됩니다 .</target>
        </trans-unit>
        <trans-unit id="274062f280eff9b69a72565df5a686a0a630e507" translate="yes" xml:space="preserve">
          <source>The routine returns &lt;code&gt;undef&lt;/code&gt; for I/O problems or other internal error, a true value otherwise. Serious errors are propagated as a &lt;code&gt;die&lt;/code&gt; exception.</source>
          <target state="translated">루틴은 I / O 문제 또는 기타 내부 오류에 대해 &lt;code&gt;undef&lt;/code&gt; 를 리턴 하고 그렇지 않으면 참 값을 리턴합니다 . 심각한 오류는 &lt;code&gt;die&lt;/code&gt; 예외 로 전파됩니다 .</target>
        </trans-unit>
        <trans-unit id="30cd5a5724b0cdff1db0ded8bf4cad313b5d3163" translate="yes" xml:space="preserve">
          <source>The routines &lt;code&gt;get&lt;/code&gt; and &lt;code&gt;reftype&lt;/code&gt; are exportable.</source>
          <target state="translated">루틴 &lt;code&gt;get&lt;/code&gt; 및 &lt;code&gt;reftype&lt;/code&gt; 은 내보낼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7978092db3768ef7e6d213d57a05b4b46c4c1d11" translate="yes" xml:space="preserve">
          <source>The routines &lt;code&gt;make_path&lt;/code&gt; and &lt;code&gt;remove_tree&lt;/code&gt; are &lt;b&gt;not&lt;/b&gt; exported by default. You must specify which ones you want to use.</source>
          <target state="translated">루틴은 &lt;code&gt;make_path&lt;/code&gt; 및 &lt;code&gt;remove_tree&lt;/code&gt; 되어 &lt;b&gt;있지&lt;/b&gt; 기본적으로 수출했다. 사용할 것을 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="5f252df425e68241a153a06fc0e9c8513b5f1aa7" translate="yes" xml:space="preserve">
          <source>The routines are called in string comparison order of KEY.</source>
          <target state="translated">루틴은 KEY의 문자열 비교 순서로 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="74358fa70816b0be14690b88380765bc85d1b11f" translate="yes" xml:space="preserve">
          <source>The routines provided are:</source>
          <target state="translated">제공되는 루틴은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="258695837b0d342f488ae3724d49cf11d73778d9" translate="yes" xml:space="preserve">
          <source>The rule by which Digest::SHA handles a Unicode string is easy to state, but potentially confusing to grasp: the string is interpreted as a sequence of byte values, where each byte value is equal to the ordinal value (viz. code point) of its corresponding Unicode character. That way, the Unicode string 'abc' has exactly the same digest value as the ordinary string 'abc'.</source>
          <target state="translated">Digest :: SHA가 유니 코드 문자열을 처리하는 규칙은 설명하기 쉽지만 이해하기 어려울 수 있습니다. 문자열은 일련의 바이트 값으로 해석되며 각 바이트 값은 서수 값 (즉, 코드 포인트)과 같습니다. 해당 유니 코드 문자 이렇게하면 유니 코드 문자열 'abc'는 일반 문자열 'abc'와 정확히 동일한 다이제스트 값을 갖습니다.</target>
        </trans-unit>
        <trans-unit id="6b4e5af62f9d03a0b5c8d39854ce10f47d56d0b1" translate="yes" xml:space="preserve">
          <source>The rule must only have one top level key: either 'par' for &quot;parallel&quot; or 'seq' for &quot;sequence&quot;.</source>
          <target state="translated">규칙에는 최상위 키가 하나만 있어야합니다. &quot;parallel&quot;의 경우 'par'또는 &quot;sequence&quot;의 경우 &quot;seq&quot;.</target>
        </trans-unit>
        <trans-unit id="2858e68dbb1d52d413ae8f5dae1d589d672ac788" translate="yes" xml:space="preserve">
          <source>The rule of thumb for portable code is: Do it all in portable Perl, or use a module (that may internally implement it with platform-specific code, but exposes a common interface).</source>
          <target state="translated">이식 가능한 코드의 기본 규칙은 다음과 같습니다. 이식 가능한 Perl에서 모두 수행하거나 모듈을 사용하십시오 (플랫폼 별 코드로 내부적으로 구현할 수 있지만 공통 인터페이스를 제공함).</target>
        </trans-unit>
        <trans-unit id="242ca7a8186e9298403d04b4bfd265a295183ebf" translate="yes" xml:space="preserve">
          <source>The rule of thumb is to use &lt;code&gt;UTF-8&lt;/code&gt; unless you know what you're doing and unless you really benefit from using &lt;code&gt;UTF-16&lt;/code&gt;.</source>
          <target state="translated">경험의 법칙은 당신이 무엇을하는지 잘 모르고 &lt;code&gt;UTF-16&lt;/code&gt; 을 사용하는 것으로부터 실제로 이익을 얻지 않는 한 &lt;code&gt;UTF-8&lt;/code&gt; 을 사용 하는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="d771186d9f060b8e39d56f4b8de80fe1694de984" translate="yes" xml:space="preserve">
          <source>The rules data structure is documented more in the next section.</source>
          <target state="translated">규칙 데이터 구조는 다음 섹션에 자세히 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="b2b47541d9fe53d041ea0cd594a357e270362960" translate="yes" xml:space="preserve">
          <source>The rules determining what it is are quite simple: if the character following the backslash is an ASCII punctuation (non-word) character (that is, anything that is not a letter, digit, or underscore), then the backslash just takes away any special meaning of the character following it.</source>
          <target state="translated">백 슬래시 뒤의 문자가 ASCII 문장 부호 (단어가 아닌) 문자 (즉, 문자, 숫자 또는 밑줄이 아닌 문자) 인 경우 백 슬래시는 그 뒤에 나오는 캐릭터의 특별한 의미.</target>
        </trans-unit>
        <trans-unit id="f747d6278f9a09b6ca106424547e7e55bc600835" translate="yes" xml:space="preserve">
          <source>The rules of conduct that, in the absence of other guidance, determine what should happen first. For example, in the absence of parentheses, you always do multiplication before addition.</source>
          <target state="translated">다른 지침이없는 경우 먼저해야 할 일을 결정하는 행동 규칙. 예를 들어, 괄호가없는 경우 항상 더하기 전에 곱셈을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="ba784b5f42a3cdb9214cd0e95e0cb55e8afe477c" translate="yes" xml:space="preserve">
          <source>The rules used by &lt;a href=&quot;re#%27strict%27-mode&quot;&gt;&lt;code&gt;use re 'strict&lt;/code&gt;&lt;/a&gt; apply to this construct.</source>
          <target state="translated">&lt;a href=&quot;re#%27strict%27-mode&quot;&gt; &lt;code&gt;use re 'strict&lt;/code&gt; 에서&lt;/a&gt; 사용하는 규칙 이이 구성에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="903df1a17859e1fa3a6b96e5e64488aec405db63" translate="yes" xml:space="preserve">
          <source>The rules used for matching decimal digits are slightly stricter. Many scripts have their own sets of digits equivalent to the Western &lt;code&gt;0&lt;/code&gt; through &lt;code&gt;9&lt;/code&gt; ones. A few, such as Arabic, have more than one set. For a string to be considered a script run, all digits in it must come from the same set of ten, as determined by the first digit encountered. As an example,</source>
          <target state="translated">십진수 일치에 사용되는 규칙은 약간 더 엄격합니다. 많은 스크립트에는 Western &lt;code&gt;0&lt;/code&gt; 에서 &lt;code&gt;9&lt;/code&gt; 까지의 숫자에 해당하는 고유 한 숫자 세트가 있습니다. 아랍어와 같은 일부는 둘 이상의 세트를 가지고 있습니다. 문자열이 스크립트 실행으로 간주 되려면 첫 번째 숫자에 따라 결정된대로 모든 숫자가 동일한 10 개 집합에서 나와야합니다. 예로서,</target>
        </trans-unit>
        <trans-unit id="4ac2685482eb75c8db66c436a646aa6e3d97f9ed" translate="yes" xml:space="preserve">
          <source>The runtime component should have the name</source>
          <target state="translated">런타임 구성 요소의 이름은</target>
        </trans-unit>
        <trans-unit id="9ac33bbce70d7ec48c4fcab9365b96ff1ebc5597" translate="yes" xml:space="preserve">
          <source>The runtime phase refers not only to when the distribution's contents are installed, but also to its continued use. Any library that is a prerequisite for regular use of this distribution should be indicated here.</source>
          <target state="translated">런타임 단계는 배포 내용이 설치된시기뿐만 아니라 지속적인 사용을 의미합니다. 이 배포판을 정기적으로 사용하기위한 전제 조건 인 모든 라이브러리를 여기에 표시해야합니다.</target>
        </trans-unit>
        <trans-unit id="763ace778385d85ae756e3844782d5cfee6e0e05" translate="yes" xml:space="preserve">
          <source>The same approach as a command line:</source>
          <target state="translated">명령 행과 동일한 접근 방식 :</target>
        </trans-unit>
        <trans-unit id="9976b6a81a6abb21b7cab5b632b4ad690c05665b" translate="yes" xml:space="preserve">
          <source>The same as for &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;, but if a missing operator cannot be autogenerated then, instead of issuing an error message, Perl is allowed to revert to what it would have done for that operator if there had been no &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; overload&lt;/code&gt; directive.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 와 동일 하지만 누락 된 연산자를 자동 생성 할 수없는 경우 오류 메시지를 발행하는 대신 Perl은 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; overload&lt;/code&gt; 지시문 이없는 경우 해당 연산자에 대해 수행 한 작업으로 되돌릴 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="aff3ca408715d6ed9bbfe43d93b70be580afe993" translate="yes" xml:space="preserve">
          <source>The same as for &lt;code&gt;undef&lt;/code&gt;, but if a missing operator cannot be autogenerated then, instead of issuing an error message, Perl is allowed to revert to what it would have done for that operator if there had been no &lt;code&gt;use overload&lt;/code&gt; directive.</source>
          <target state="translated">&lt;code&gt;undef&lt;/code&gt; 와 동일 하지만 누락 된 연산자를 자동 생성 할 수없는 경우 오류 메시지를 발행하는 대신, &lt;code&gt;use overload&lt;/code&gt; 지시문 이없는 경우 Perl은 해당 연산자에 대해 수행 한 작업으로 되돌릴 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4c7d5583bb4c7bf75d630d65c93bc37b198d69e0" translate="yes" xml:space="preserve">
          <source>The same caveats as the previous form apply: The non-graphic characters are no longer allowed with &quot;use utf8&quot;, it is unwise to use this form at all, and utf8ness makes a big difference.</source>
          <target state="translated">이전 형식과 동일한주의 사항이 적용됩니다. 그래픽이 아닌 문자는 더 이상 &quot;use utf8&quot;에 허용되지 않으며이 형식을 전혀 사용하는 것은 현명하지 않으며 utf8ness는 큰 차이를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="286499ca118e6aee1159ad012e0d0c293bc05679" translate="yes" xml:space="preserve">
          <source>The same checksum can also be calculated in OO style:</source>
          <target state="translated">동일한 체크섬을 OO 스타일로 계산할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="e7121397996c97368f3bf5006e5d7cf5183183f6" translate="yes" xml:space="preserve">
          <source>The same effect as the example above in a different way. The coderef takes the alias name as an argument and returns a canonical name on success or undef if not. Note the second argument is ignored if provided. Use this with even more caution than the regex version.</source>
          <target state="translated">위의 예와 다른 효과가 동일합니다. coderef는 별명 이름을 인수로 사용하고 성공하면 정식 이름을 반환하거나 그렇지 않으면 undef를 반환합니다. 제공된 경우 두 번째 인수는 무시됩니다. 정규식 버전보다 훨씬 신중하게 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="e43451146d37e633afabe95e907553562bae7cb9" translate="yes" xml:space="preserve">
          <source>The same holds for evaluated strings that contain subroutines, or which are currently being executed. The $filename for &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;ed strings looks like &lt;code&gt;(&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; 34)&lt;/code&gt; .</source>
          <target state="translated">서브 루틴을 포함하거나 현재 실행중인 평가 된 문자열도 마찬가지입니다. &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 문자열 의 $ filename은 다음과 같습니다 &lt;code&gt;(&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; 34)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6bfd670d25b13b1b3ec948c8f09f21523b3aecf7" translate="yes" xml:space="preserve">
          <source>The same holds for evaluated strings that contain subroutines, or which are currently being executed. The $filename for &lt;code&gt;eval&lt;/code&gt;ed strings looks like &lt;code&gt;(eval 34)&lt;/code&gt;.</source>
          <target state="translated">서브 루틴을 포함하거나 현재 실행중인 평가 된 문자열에 대해서도 동일하게 적용됩니다. &lt;code&gt;eval&lt;/code&gt; 문자열 의 $ filename은 &lt;code&gt;(eval 34)&lt;/code&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="a048bf53e27173e747513cb4000a6c6bd711ca9e" translate="yes" xml:space="preserve">
          <source>The same information is displayed at the end of the output from the command</source>
          <target state="translated">명령의 출력 끝에 동일한 정보가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="fe72bff5d187e52fa5d199f09887af6af2e32815" translate="yes" xml:space="preserve">
          <source>The same is not true of implementations of &lt;code&gt;++&lt;/code&gt; and &lt;code&gt;--&lt;/code&gt; : these are expected to modify their operand. An appropriate implementation of &lt;code&gt;--&lt;/code&gt; might look like</source>
          <target state="translated">&lt;code&gt;++&lt;/code&gt; 및 &lt;code&gt;--&lt;/code&gt; 의 구현에 대해서도 마찬가지입니다 . : 피연산자를 수정해야합니다. 의 적절한 구현 &lt;code&gt;--&lt;/code&gt; 처럼 보일 수 있습니다</target>
        </trans-unit>
        <trans-unit id="07cb6e84563964c1b3fb8a6ff37a2b4286b6b128" translate="yes" xml:space="preserve">
          <source>The same is not true of implementations of &lt;code&gt;++&lt;/code&gt; and &lt;code&gt;--&lt;/code&gt;: these are expected to modify their operand. An appropriate implementation of &lt;code&gt;--&lt;/code&gt; might look like</source>
          <target state="translated">&lt;code&gt;++&lt;/code&gt; 및 &lt;code&gt;--&lt;/code&gt; 구현의 경우도 마찬가지입니다 . 피연산자를 수정해야합니다. 의 적절한 구현 &lt;code&gt;--&lt;/code&gt; 처럼 보일 수 있습니다</target>
        </trans-unit>
        <trans-unit id="b9889316caadba38254c295ba1f667d08e692e37" translate="yes" xml:space="preserve">
          <source>The same might happen to AIX 5.1 or other OS levels. As a side note, Perl cannot be built without bos.adt.syscalls and bos.adt.libm installed</source>
          <target state="translated">AIX 5.1 또는 다른 OS 레벨에서도 마찬가지입니다. 참고로, bos.adt.syscalls 및 bos.adt.libm을 설치하지 않으면 Perl을 빌드 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="2d3beec233d4767fecd283497936fe00947a8d1a" translate="yes" xml:space="preserve">
          <source>The same package name can be used more than once, allowing for non-contiguous code. This is useful if you have a stronger ordering principle than package names.</source>
          <target state="translated">연속되지 않은 코드를 허용하는 동일한 패키지 이름을 두 번 이상 사용할 수 있습니다. 패키지 이름보다 강력한 순서 원칙이있는 경우 유용합니다.</target>
        </trans-unit>
        <trans-unit id="adf0ce12f9a7b11a4e4d148adc2353bc6022f25b" translate="yes" xml:space="preserve">
          <source>The same problems ensue if you enable automatic UTF-8-ification of your standard file handles, default &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; layer, and &lt;code&gt;@ARGV&lt;/code&gt; on non-ISO8859-1, non-UTF-8 locales (by using either the &lt;b&gt;-C&lt;/b&gt; command line switch or the &lt;code&gt;PERL_UNICODE&lt;/code&gt; environment variable; see &lt;a href=&quot;perlrun&quot;&gt;perlrun&lt;/a&gt;). Things are read in as UTF-8, which would normally imply a Unicode interpretation, but the presence of a locale causes them to be interpreted in that locale instead. For example, a 0xD7 code point in the Unicode input, which should mean the multiplication sign, won't be interpreted by Perl that way under the Greek locale. This is not a problem</source>
          <target state="translated">비 ISO8859-1 비 UTF-8 로케일에서 &lt;b&gt;-C&lt;/b&gt; 명령 행 을 사용 하여 표준 파일 핸들, 기본 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; 레이어 및 &lt;code&gt;@ARGV&lt;/code&gt; 의 자동 UTF-8 인증을 사용하는 경우에도 동일한 문제점이 발생합니다. 스위치 또는 &lt;code&gt;PERL_UNICODE&lt;/code&gt; 환경 변수 ( &lt;a href=&quot;perlrun&quot;&gt;perlrun&lt;/a&gt; 참조 ) 사물은 일반적으로 유니 코드 해석을 의미하는 UTF-8로 읽히지 만 로케일이 있으면 해당 로케일로 해석됩니다. 예를 들어, 유니 코드 입력의 0xD7 코드 포인트는 곱셈 부호를 의미해야하며 그리스어 로케일에서 Perl에 의해 해석되지 않습니다. 이것은 문제가되지 않습니다&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="44e618a0d24868bdeb405a4592271ed0ce58faad" translate="yes" xml:space="preserve">
          <source>The same problems ensue if you enable automatic UTF-8-ification of your standard file handles, default &lt;code&gt;open()&lt;/code&gt; layer, and &lt;code&gt;@ARGV&lt;/code&gt; on non-ISO8859-1, non-UTF-8 locales (by using either the &lt;b&gt;-C&lt;/b&gt; command line switch or the &lt;code&gt;PERL_UNICODE&lt;/code&gt; environment variable; see &lt;a href=&quot;perlrun#-C-%5Bnumber%2Flist%5D&quot;&gt;perlrun&lt;/a&gt;). Things are read in as UTF-8, which would normally imply a Unicode interpretation, but the presence of a locale causes them to be interpreted in that locale instead. For example, a 0xD7 code point in the Unicode input, which should mean the multiplication sign, won't be interpreted by Perl that way under the Greek locale. This is not a problem</source>
          <target state="translated">비 ISO8859-1, 비 UTF-8 로케일에서 표준 파일 핸들, 기본 &lt;code&gt;open()&lt;/code&gt; 레이어 및 &lt;code&gt;@ARGV&lt;/code&gt; 의 자동 UTF-8 화를 활성화하는 경우에도 동일한 문제가 발생 합니다 ( &lt;b&gt;-C&lt;/b&gt; 명령 줄 사용 스위치 또는 &lt;code&gt;PERL_UNICODE&lt;/code&gt; 환경 변수; &lt;a href=&quot;perlrun#-C-%5Bnumber%2Flist%5D&quot;&gt;perlrun&lt;/a&gt; 참조 ). 일반적으로 유니 코드 해석을 의미하는 UTF-8로 읽혀 지지만 로케일이 있으면 대신 해당 로케일로 해석됩니다. 예를 들어 유니 코드 입력의 0xD7 코드 포인트 (곱하기 기호를 의미해야 함)는 그리스 로케일에서 Perl에 의해 해석되지 않습니다. 이것은 문제가 아닙니다</target>
        </trans-unit>
        <trans-unit id="8104fdf41371cefa43c656a17bffde6b62386dd0" translate="yes" xml:space="preserve">
          <source>The same problems occur if you pass them Math::BigInt-&amp;gt;binf() objects. Since overloading these routines is not possible, this cannot be fixed from BigInt.</source>
          <target state="translated">Math :: BigInt-&amp;gt; binf () 객체를 전달하면 동일한 문제가 발생합니다. 이러한 루틴을 오버로드 할 수 없으므로 BigInt에서이를 수정할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="7dc30b04b9083d2f8edd85ddb5597b7e64cf1167" translate="yes" xml:space="preserve">
          <source>The same problems occur if you pass them Math::BigInt-&amp;gt;binf() objects. Since overloading these routines is not possible, this cannot be fixed from Math::BigInt.</source>
          <target state="translated">Math :: BigInt-&amp;gt; binf () 객체를 전달하면 동일한 문제가 발생합니다. 이러한 루틴을 오버로딩 할 수 없기 때문에 Math :: BigInt에서 수정할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="fd308e84d4bbc13d1645c341d0f0d15e57ef77b4" translate="yes" xml:space="preserve">
          <source>The same template may generally also be used in &lt;a href=&quot;#unpack-TEMPLATE%2CEXPR&quot;&gt;&lt;code&gt;unpack&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">일반적으로 같은 템플릿을 &lt;a href=&quot;#unpack-TEMPLATE%2CEXPR&quot;&gt; &lt;code&gt;unpack&lt;/code&gt; &lt;/a&gt; 에서도 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="70e999fed9c0e326d353539553d4a7555374fd82" translate="yes" xml:space="preserve">
          <source>The same template may generally also be used in unpack().</source>
          <target state="translated">동일한 템플릿이 일반적으로 unpack ()에서도 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6b6c7f4b6ab698dbba6b63d74e5bcb57fa5d9973" translate="yes" xml:space="preserve">
          <source>The same tests are run both times, but more information is provided when running as &lt;code&gt;./perl harness&lt;/code&gt;.</source>
          <target state="translated">동일한 테스트가 두 번 실행되지만 &lt;code&gt;./perl harness&lt;/code&gt; 로 실행할 때 더 많은 정보가 제공됩니다 .</target>
        </trans-unit>
        <trans-unit id="1f4add58be52aaba625e5f7ff33a20f204714d58" translate="yes" xml:space="preserve">
          <source>The sample program:</source>
          <target state="translated">샘플 프로그램 :</target>
        </trans-unit>
        <trans-unit id="81ca6bed72a326bbf775e3304829aa324851950b" translate="yes" xml:space="preserve">
          <source>The save stack is used by perl to implement the &lt;code&gt;local&lt;/code&gt; keyword and other similar behaviours; any cleanup operations that need to be performed when leaving the current scope. Items pushed to this stack generally capture the current value of some internal variable or state, which will be restored when the scope is unwound due to leaving, &lt;code&gt;return&lt;/code&gt;, &lt;code&gt;die&lt;/code&gt;, &lt;code&gt;goto&lt;/code&gt; or other reasons.</source>
          <target state="translated">저장 스택은 perl에서 &lt;code&gt;local&lt;/code&gt; 키워드 및 기타 유사한 동작 을 구현하는 데 사용됩니다 . 현재 범위를 벗어날 때 수행해야하는 정리 작업 이 스택으로 푸시 항목은 일반적으로 범위는 이탈에 기인 풀린 때 복원 될 일부 내부 변수 또는 상태의 현재 값을 포착 &lt;code&gt;return&lt;/code&gt; , &lt;code&gt;die&lt;/code&gt; , &lt;code&gt;goto&lt;/code&gt; 또는 다른 이유.</target>
        </trans-unit>
        <trans-unit id="f745bb5cbca08197cbed6d6403139abf437a8fa9" translate="yes" xml:space="preserve">
          <source>The scalar &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; value is stored in an SV instance called &lt;code&gt;PL_sv_undef&lt;/code&gt; .</source>
          <target state="translated">스칼라 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 값은 &lt;code&gt;PL_sv_undef&lt;/code&gt; 라는 SV 인스턴스에 저장됩니다 .</target>
        </trans-unit>
        <trans-unit id="7d200dc97f6deaa66b9415179bc13a97fa0cc3da" translate="yes" xml:space="preserve">
          <source>The scalar &lt;code&gt;undef&lt;/code&gt; value is stored in an SV instance called &lt;code&gt;PL_sv_undef&lt;/code&gt;.</source>
          <target state="translated">스칼라 &lt;code&gt;undef&lt;/code&gt; 값은 &lt;code&gt;PL_sv_undef&lt;/code&gt; 라는 SV 인스턴스에 저장됩니다 .</target>
        </trans-unit>
        <trans-unit id="6e858b562140c68ce32ea23e2b6e666b2e82798f" translate="yes" xml:space="preserve">
          <source>The scalar/list context for the subroutine and for the right-hand side of assignment is determined as if the subroutine call is replaced by a scalar. For example, consider:</source>
          <target state="translated">서브 루틴 및 할당의 오른쪽에 대한 스칼라 /리스트 컨텍스트는 서브 루틴 호출이 스칼라로 대체 된 것처럼 결정됩니다. 예를 들어, 다음을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="6c0b56c4841154473a184d3770a4651387051abe" translate="yes" xml:space="preserve">
          <source>The scalars for in-memory files are treated as octet strings: unless the file is being opened with truncation the scalar may not contain any code points over 0xFF.</source>
          <target state="translated">메모리 내 파일의 스칼라는 8 진수 문자열로 처리됩니다. 파일이 잘려서 열리지 않는 한 스칼라는 0xFF 이상의 코드 포인트를 포함 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="8a59c0bcb531b15ec7601a5c46eda41a994dbd08" translate="yes" xml:space="preserve">
          <source>The scheme above allows interpretation of a wide range of dates, particularly if 4-digit years are used.</source>
          <target state="translated">위의 체계를 통해 특히 4 자리 연도를 사용하는 경우 광범위한 날짜를 해석 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3fc0ce48ddfa00a9f249dd98501d09516efb57c0" translate="yes" xml:space="preserve">
          <source>The scheme from the uri (like 'file', 'http', etc)</source>
          <target state="translated">uri의 구성표 (예 : 'file', 'http'등)</target>
        </trans-unit>
        <trans-unit id="73f8b37079fc67e2d535d7e2f263c71e4f89003f" translate="yes" xml:space="preserve">
          <source>The scope of the &lt;code&gt;package&lt;/code&gt; declaration is from the declaration itself through the end of the enclosing block, &lt;code&gt;eval&lt;/code&gt;, or file, whichever comes first (the same scope as the my(), our(), state(), and local() operators, and also the effect of the experimental &quot;reference aliasing,&quot; which may change), or until the next &lt;code&gt;package&lt;/code&gt; declaration. Unqualified dynamic identifiers will be in this namespace, except for those few identifiers that, if unqualified, default to the main package instead of the current one as described below. A &lt;code&gt;package&lt;/code&gt; statement affects only dynamic global symbols, including subroutine names, and variables you've used local() on, but</source>
          <target state="translated">&lt;code&gt;package&lt;/code&gt; 선언 의 범위는 선언 자체부터 둘러싸는 블록, &lt;code&gt;eval&lt;/code&gt; 또는 파일 의 끝까지입니다 (my (), our (), state () 및 local () 연산자와 동일한 범위) , 변경 될 수있는 실험적 &quot;참조 앨리어싱&quot;의 효과) 또는 다음 &lt;code&gt;package&lt;/code&gt; 선언 까지 . 정규화되지 않은 동적 식별자는 정규화되지 않은 경우 아래에 설명 된 현재 패키지 대신 기본 패키지로 기본 설정되는 소수의 식별자를 제외하고이 네임 스페이스에 있습니다. &lt;code&gt;package&lt;/code&gt; , 문이 서브 루틴의 이름을 포함에만 동적 전역 심볼, 영향 변수는에 () 지역 사용했지만</target>
        </trans-unit>
        <trans-unit id="49277474cf2c3fa04e4e431396fc13bca0311697" translate="yes" xml:space="preserve">
          <source>The scope where &lt;code&gt;&lt;a href=&quot;functions/length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; is used has escalated the &lt;code&gt;void&lt;/code&gt; warnings category into a fatal error, so the program terminates immediately when it encounters the warning.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; 가 사용되는 범위에서 &lt;code&gt;void&lt;/code&gt; 경고 범주가 치명적 오류로 에스컬레이션 되었으므로 경고가 발생하면 프로그램이 즉시 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="3dbfebc1570cc3ef48ec03f51a2706061f280881" translate="yes" xml:space="preserve">
          <source>The scope where &lt;code&gt;length&lt;/code&gt; is used has escalated the &lt;code&gt;void&lt;/code&gt; warnings category into a fatal error, so the program terminates immediately when it encounters the warning.</source>
          <target state="translated">&lt;code&gt;length&lt;/code&gt; 가 사용되는 범위 는 &lt;code&gt;void&lt;/code&gt; 경고 범주를 치명적인 오류로 에스컬레이션 했으므로 프로그램은 경고가 발생하면 즉시 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="62f56ab0ebe6cfd894b851115a602d7f9f59ed1f" translate="yes" xml:space="preserve">
          <source>The script exits with zero if it thinks that everything worked, or a positive number if it thinks that something failed. Note, however, that in some cases it has to divine a failure by the output of things it does not control. For now, the exit codes are vague:</source>
          <target state="translated">스크립트는 모든 것이 작동했다고 생각하면 0으로 종료하고, 무언가 실패했다고 생각하면 양수로 종료합니다. 그러나 어떤 경우에는 통제하지 않는 것의 결과로 실패를 신성화해야한다는 점에 유의하십시오. 현재로서는 종료 코드가 모호합니다.</target>
        </trans-unit>
        <trans-unit id="05dbbff48c1e514e522b4520f47f1f9d051aaac1" translate="yes" xml:space="preserve">
          <source>The script first verifies the function of the &lt;code&gt;Name&lt;/code&gt; class.</source>
          <target state="translated">스크립트는 먼저 &lt;code&gt;Name&lt;/code&gt; 클래스 의 기능을 확인합니다 .</target>
        </trans-unit>
        <trans-unit id="bab70c074a8060d72a4a917d75cb758f3fdbebe9" translate="yes" xml:space="preserve">
          <source>The script is available from &lt;a href=&quot;https://gist.github.com/eqhmcow/5389877&quot;&gt;https://gist.github.com/eqhmcow/5389877&lt;/a&gt;</source>
          <target state="translated">스크립트는 &lt;a href=&quot;https://gist.github.com/eqhmcow/5389877&quot;&gt;https://gist.github.com/eqhmcow/5389877&lt;/a&gt; 에서 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="63775c5f58b6e8ca06f6c938a637be34887e3ffd" translate="yes" xml:space="preserve">
          <source>The script of a character is determined by the &lt;code&gt;Script_Extensions&lt;/code&gt; property as modified by UTS 39 (&lt;a href=&quot;https://unicode.org/reports/tr39/&quot;&gt;https://unicode.org/reports/tr39/&lt;/a&gt;), as described above.</source>
          <target state="translated">문자의 스크립트는 위에서 설명한대로 UTS 39 ( &lt;a href=&quot;https://unicode.org/reports/tr39/&quot;&gt;https://unicode.org/reports/tr39/&lt;/a&gt; )에 의해 수정 된 &lt;code&gt;Script_Extensions&lt;/code&gt; 속성에 의해 결정됩니다 .</target>
        </trans-unit>
        <trans-unit id="496da3e22e1e3340caf097640e4353358048134f" translate="yes" xml:space="preserve">
          <source>The sdbm file format was designed for speed and convenience, not for portability or security. A maliciously crafted file might cause perl to crash or even expose a security vulnerability.</source>
          <target state="translated">sdbm 파일 형식은 이식성이나 보안이 아닌 속도와 편의를 위해 설계되었습니다. 악의적으로 제작 된 파일로 인해 perl이 충돌하거나 보안 취약점이 노출 될 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="bc3001b62b3120b5e625f2291ab08a912ad78b79" translate="yes" xml:space="preserve">
          <source>The search engine will initially match &lt;code&gt;\D*&lt;/code&gt; with &quot;ABC&quot;. Then it will try to match &lt;code&gt;(?!123)&lt;/code&gt; with &quot;123&quot;, which fails. But because a quantifier (&lt;code&gt;\D*&lt;/code&gt; ) has been used in the regular expression, the search engine can backtrack and retry the match differently in the hope of matching the complete regular expression.</source>
          <target state="translated">검색 엔진은 처음에 &lt;code&gt;\D*&lt;/code&gt; 와 &quot;ABC&quot;를 일치 시킵니다. 그런 다음 &lt;code&gt;(?!123)&lt;/code&gt; 을 &quot;123&quot;과 일치 시키려고 하는데 실패합니다. 그러나 정규 표현식에 수량 자 ( &lt;code&gt;\D*&lt;/code&gt; )가 사용되었으므로 검색 엔진은 완전한 정규 표현식과 일치시키기 위해 일치하는 방식으로 역 추적하고 재 시도 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2dd6a24dc0c40439966d70dfb7faeebd4df837f5" translate="yes" xml:space="preserve">
          <source>The search engine will initially match &lt;code&gt;\D*&lt;/code&gt; with &quot;ABC&quot;. Then it will try to match &lt;code&gt;(?!123)&lt;/code&gt; with &quot;123&quot;, which fails. But because a quantifier (&lt;code&gt;\D*&lt;/code&gt;) has been used in the regular expression, the search engine can backtrack and retry the match differently in the hope of matching the complete regular expression.</source>
          <target state="translated">검색 엔진은 처음에 &lt;code&gt;\D*&lt;/code&gt; 를 &quot;ABC&quot;와 일치 시킵니다. 그런 다음 &lt;code&gt;(?!123)&lt;/code&gt; 을 &quot;123&quot;과 일치 시키려고 시도하지만 실패합니다. 그러나 정규식에 수량 자 ( &lt;code&gt;\D*&lt;/code&gt; )가 사용 되었기 때문에 검색 엔진은 완전한 정규식과 일치하기 위해 다르게 일치를 역 추적하고 재 시도 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4989338d675235ed7afc62322345e940a111f8d8" translate="yes" xml:space="preserve">
          <source>The second advantage is that embedded modifiers (except &lt;code&gt;//p&lt;/code&gt; , which modifies the entire regexp) only affect the regexp inside the group the embedded modifier is contained in. So grouping can be used to localize the modifier's effects:</source>
          <target state="translated">두 번째 장점은 포함 된 수정 자 ( 전체 정규 표현식을 수정하는 &lt;code&gt;//p&lt;/code&gt; 제외 )는 포함 된 수정자가 포함 된 그룹 내부의 정규 표현식에만 영향을 미친다는 것입니다. 따라서 그룹화를 사용하여 수정 자의 효과를 지역화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="344654afee619df186bd5aa49c470902771a22f7" translate="yes" xml:space="preserve">
          <source>The second advantage is that embedded modifiers (except &lt;code&gt;/p&lt;/code&gt;, which modifies the entire regexp) only affect the regexp inside the group the embedded modifier is contained in. So grouping can be used to localize the modifier's effects:</source>
          <target state="translated">두 번째 장점은 포함 된 수정 자 ( 전체 정규식을 수정하는 &lt;code&gt;/p&lt;/code&gt; 제외 )가 포함 된 수정자가 포함 된 그룹 내의 정규식에만 영향을 미친다는 것입니다. 따라서 그룹화를 사용하여 수정 자의 효과를 지역화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e6b19a99a58715509197b4fd3bb055452f4e6bb8" translate="yes" xml:space="preserve">
          <source>The second and third arguments &lt;code&gt;number&lt;/code&gt; and &lt;code&gt;type&lt;/code&gt; specify how many of the specified type of data structure should be allocated. The argument &lt;code&gt;type&lt;/code&gt; is passed to &lt;code&gt;sizeof&lt;/code&gt; . The final argument to &lt;code&gt;Newxc&lt;/code&gt; , &lt;code&gt;cast&lt;/code&gt; , should be used if the &lt;code&gt;pointer&lt;/code&gt; argument is different from the &lt;code&gt;type&lt;/code&gt; argument.</source>
          <target state="translated">두 번째 및 세 번째 인수 &lt;code&gt;number&lt;/code&gt; 및 &lt;code&gt;type&lt;/code&gt; 은 지정된 유형의 데이터 구조 중 몇 개를 할당해야하는지 지정합니다. 인수 &lt;code&gt;type&lt;/code&gt; 은 &lt;code&gt;sizeof&lt;/code&gt; 로 전달됩니다 . &lt;code&gt;pointer&lt;/code&gt; 인수가 &lt;code&gt;type&lt;/code&gt; 인수 와 다른 경우 &lt;code&gt;Newxc&lt;/code&gt; 의 마지막 인수 인 &lt;code&gt;cast&lt;/code&gt; 를 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="fea027e954f4ec8636256c0b94ce6f7f44ab6c0c" translate="yes" xml:space="preserve">
          <source>The second and third arguments &lt;code&gt;number&lt;/code&gt; and &lt;code&gt;type&lt;/code&gt; specify how many of the specified type of data structure should be allocated. The argument &lt;code&gt;type&lt;/code&gt; is passed to &lt;code&gt;sizeof&lt;/code&gt;. The final argument to &lt;code&gt;Newxc&lt;/code&gt;, &lt;code&gt;cast&lt;/code&gt;, should be used if the &lt;code&gt;pointer&lt;/code&gt; argument is different from the &lt;code&gt;type&lt;/code&gt; argument.</source>
          <target state="translated">두 번째 및 세 번째 인수의 &lt;code&gt;number&lt;/code&gt; 와 &lt;code&gt;type&lt;/code&gt; 은 지정된 데이터 구조 유형 중 몇 개를 할당해야하는지 지정합니다. 인수 &lt;code&gt;type&lt;/code&gt; 은 &lt;code&gt;sizeof&lt;/code&gt; 에 전달됩니다 . &lt;code&gt;Newxc&lt;/code&gt; 에 대한 마지막 인수 인 &lt;code&gt;cast&lt;/code&gt; 는 &lt;code&gt;pointer&lt;/code&gt; 인수가 &lt;code&gt;type&lt;/code&gt; 인수 와 다른 경우 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="1b7128198e8ffe79d47674dc971b588a148d07fe" translate="yes" xml:space="preserve">
          <source>The second and third highest priorities are to look in the parent of the current directory and a directory called</source>
          <target state="translated">두 번째와 세 번째로 높은 우선 순위는 현재 디렉터리의 부모와</target>
        </trans-unit>
        <trans-unit id="9372cc26ce11f225b78cb9001dded71987be37ab" translate="yes" xml:space="preserve">
          <source>The second argument ($eol) is the line-ending sequence to use. It is optional and defaults to &quot;\n&quot;. Every occurrence of &quot;\n&quot; is replaced with this string, and it is also used for additional &quot;soft line breaks&quot; to ensure that no line end up longer than 76 characters. Pass it as &quot;\015\012&quot; to produce data suitable for external consumption. The string &quot;\r\n&quot; produces the same result on many platforms, but not all.</source>
          <target state="translated">두 번째 인수 ($ eol)는 사용할 행 끝 순서입니다. 선택 사항이며 기본값은 &quot;\ n&quot;입니다. &quot;\ n&quot;이 나타날 때마다이 문자열로 바뀌고 추가 &quot;소프트 줄 바꿈&quot;에도 사용되어 줄이 76자를 넘지 않도록합니다. 외부 소비에 적합한 데이터를 생성하려면 &quot;\ 015 \ 012&quot;로 전달하십시오. 문자열 &quot;\ r \ n&quot;은 많은 플랫폼에서 동일한 결과를 생성하지만 전부는 아닙니다.</target>
        </trans-unit>
        <trans-unit id="691db7e7ba5b2eef57391203c3fd8b3455b42a9c" translate="yes" xml:space="preserve">
          <source>The second argument can be a hash reference with options, which are identical to the arguments passed to &lt;code&gt;&lt;a href=&quot;../functions/read&quot;&gt;read()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">두 번째 인수는 옵션이있는 해시 참조 일 수 있으며 &lt;code&gt;&lt;a href=&quot;../functions/read&quot;&gt;read()&lt;/a&gt;&lt;/code&gt; 전달 된 인수와 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="d9356e806771df85496c708eb7a467795a26a60f" translate="yes" xml:space="preserve">
          <source>The second argument can be a hash reference with options, which are identical to the arguments passed to &lt;code&gt;read()&lt;/code&gt;.</source>
          <target state="translated">두 번째 인수는 &lt;code&gt;read()&lt;/code&gt; 전달 된 인수와 동일한 옵션이있는 해시 참조 일 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="36e7dec2e6aed1723cd212b39460017f8772c38b" translate="yes" xml:space="preserve">
          <source>The second argument is a regular expression. It may be given as a regex reference (i.e. &lt;code&gt;&lt;a href=&quot;../functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt;) or (for better compatibility with older perls) as a string that looks like a regex (alternative delimiters are currently not supported):</source>
          <target state="translated">두 번째 인수는 정규식입니다. 정규 표현식 처럼 보이는 문자열로 정규 표현식 참조 (예 : &lt;code&gt;&lt;a href=&quot;../functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt; ) 또는 (이전의 perls와의 호환성을 높이기 위해) 제공 될 수 있습니다 (대체 구분 기호는 현재 지원되지 않습니다).</target>
        </trans-unit>
        <trans-unit id="851ff1e7afee5d9f26155a298af3215064fbafc8" translate="yes" xml:space="preserve">
          <source>The second argument is a regular expression. It may be given as a regex reference (i.e. &lt;code&gt;qr//&lt;/code&gt;) or (for better compatibility with older perls) as a string that looks like a regex (alternative delimiters are currently not supported):</source>
          <target state="translated">두 번째 인수는 정규식입니다. 정규식 참조 (예 : &lt;code&gt;qr//&lt;/code&gt; ) 또는 (이전 펄과의 더 나은 호환성을 위해) 정규식처럼 보이는 문자열로 제공 될 수 있습니다 (현재 대체 구분 기호는 지원되지 않음).</target>
        </trans-unit>
        <trans-unit id="e9cd8da657568e7bbba17b34028b2178bd5abb57" translate="yes" xml:space="preserve">
          <source>The second argument is considered a regex if it is either a regex object or a string that looks like a regex. Regex objects are constructed with the qr// operator in recent versions of perl. A string is considered to look like a regex if its first and last characters are &quot;/&quot;, or if the first character is &quot;m&quot; and its second and last characters are both the same non-alphanumeric non-whitespace character. These regexp</source>
          <target state="translated">두 번째 인수는 정규식 객체이거나 정규식처럼 보이는 문자열 인 경우 정규식으로 간주됩니다. 정규식 객체는 최신 버전의 perl에서 qr // 연산자로 구성됩니다. 첫 번째와 마지막 문자가 &quot;/&quot;이거나 첫 번째 문자가 &quot;m&quot;이고 두 번째와 마지막 문자가 모두 영숫자가 아닌 비 공백 문자 인 경우 문자열은 정규식처럼 보입니다. 이 정규 표현식</target>
        </trans-unit>
        <trans-unit id="ffe3c605f37afcab4c8601d801b588d13a566637" translate="yes" xml:space="preserve">
          <source>The second argument is the other operand, or &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; in the case of a unary operator.</source>
          <target state="translated">두 번째 인수는 다른 피연산자이거나 단항 연산자의 경우 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="e4f1fa234686b49496c4cac025cf1d9ea03f5c52" translate="yes" xml:space="preserve">
          <source>The second argument is the other operand, or &lt;code&gt;undef&lt;/code&gt; in the case of a unary operator.</source>
          <target state="translated">두 번째 인수는 다른 피연산자이거나 단항 연산자의 경우 &lt;code&gt;undef&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="a8f0c3f0ec389d3780a678c2cc02cdb14b452933" translate="yes" xml:space="preserve">
          <source>The second argument is used to indicate compression. You can compress using &lt;code&gt;gzip&lt;/code&gt;, &lt;code&gt;bzip2&lt;/code&gt; or &lt;code&gt;xz&lt;/code&gt;. If you pass a digit, it's assumed to be the &lt;code&gt;gzip&lt;/code&gt; compression level (between 1 and 9), but the use of constants is preferred:</source>
          <target state="translated">두 번째 인수는 압축을 나타내는 데 사용됩니다. &lt;code&gt;gzip&lt;/code&gt; , &lt;code&gt;bzip2&lt;/code&gt; 또는 &lt;code&gt;xz&lt;/code&gt; 를 사용하여 압축 할 수 있습니다 . 숫자를 전달하면 &lt;code&gt;gzip&lt;/code&gt; 압축 수준 (1과 9 사이)으로 간주 되지만 상수를 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="e99835175d57940dd272e3dc71fc2882ef5b0d66" translate="yes" xml:space="preserve">
          <source>The second argument is used to indicate compression. You can either compress using &lt;code&gt;gzip&lt;/code&gt; or &lt;code&gt;bzip2&lt;/code&gt; . If you pass a digit, it's assumed to be the &lt;code&gt;gzip&lt;/code&gt; compression level (between 1 and 9), but the use of constants is preferred:</source>
          <target state="translated">두 번째 인수는 압축을 나타내는 데 사용됩니다. &lt;code&gt;gzip&lt;/code&gt; 또는 &lt;code&gt;bzip2&lt;/code&gt; 를 사용하여 압축 할 수 있습니다 . 숫자를 전달하면 &lt;code&gt;gzip&lt;/code&gt; 압축 수준 (1과 9 사이)으로 가정되지만 상수를 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="a0c730e612ef3dd802df3a15f52c50f234217ccd" translate="yes" xml:space="preserve">
          <source>The second argument may be considered optional, but remains for backwards compatibility. Archive::Tar now looks at the file magic to determine what class should be used to open the file and will transparently Do The Right Thing.</source>
          <target state="translated">두 번째 인수는 선택 사항으로 간주 될 수 있지만 이전 버전과의 호환성을 위해 남아 있습니다. Archive :: Tar는 이제 파일 매직을보고 파일을 여는 데 사용할 클래스를 결정하고 투명하게 올바른 일을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="fc50752077e3b12e3cd10f78b06bb8c9b8f956b4" translate="yes" xml:space="preserve">
          <source>The second argument points to an array containing &lt;code&gt;num&lt;/code&gt;&lt;code&gt;SV*&lt;/code&gt; 's. Once the AV has been created, the SVs can be destroyed, if so desired.</source>
          <target state="translated">두 번째 인수는 &lt;code&gt;num&lt;/code&gt; &lt;code&gt;SV*&lt;/code&gt; 포함 된 배열을 가리 킵니다 . AV가 생성되면 원하는 경우 SV를 파괴 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="51ba89f615646daa0a3b0a56db80558ec7c78c30" translate="yes" xml:space="preserve">
          <source>The second argument points to an array containing &lt;code&gt;num&lt;/code&gt;&lt;code&gt;SV*&lt;/code&gt;'s. Once the AV has been created, the SVs can be destroyed, if so desired.</source>
          <target state="translated">두 번째 인수는 &lt;code&gt;num&lt;/code&gt; &lt;code&gt;SV*&lt;/code&gt; 포함 된 배열을 가리 킵니다 . AV가 생성되면 원하는 경우 SV를 삭제할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ae8c79378da8449512fbe01727cd6ac969d7ae7c" translate="yes" xml:space="preserve">
          <source>The second argument to &lt;code&gt;open&lt;/code&gt;, &lt;code&gt;&quot;-|&quot;&lt;/code&gt;, makes it a read-pipe into a separate program, rather than an ordinary filehandle into a file.</source>
          <target state="translated">두 번째 인수가 &lt;code&gt;open&lt;/code&gt; , &lt;code&gt;&quot;-|&quot;&lt;/code&gt; , 파일에 대한 일반 파일 핸들이 아닌 별도의 프로그램에 대한 읽기 파이프가됩니다.</target>
        </trans-unit>
        <trans-unit id="241df4a30fc4febc2cd9ef098abdb1cdbc871750" translate="yes" xml:space="preserve">
          <source>The second call to hex() will warn about a non-portable constant.</source>
          <target state="translated">hex ()에 대한 두 번째 호출은 이식 불가능한 상수에 대해 경고합니다.</target>
        </trans-unit>
        <trans-unit id="52f5fb6e434df4bf3ba2648b67634f2b93cdc1b5" translate="yes" xml:space="preserve">
          <source>The second call-back is optional if the call back is registered prior to the call to $term-&amp;gt;readline.</source>
          <target state="translated">$ term-&amp;gt; readline 호출 전에 콜백을 등록한 경우 두 번째 콜백은 선택 사항입니다.</target>
        </trans-unit>
        <trans-unit id="104d457b0581ca75e5a33a6cc382aa3d75495d54" translate="yes" xml:space="preserve">
          <source>The second call-back registered is the call back for registration. The input filehandle (often STDIN, but not necessarily) will be passed in.</source>
          <target state="translated">등록 된 두 번째 콜백은 등록을위한 콜백입니다. 입력 파일 핸들 (종종 STDIN이지만 반드시 그런 것은 아님)이 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="8a9a833fe2a8c9894ba16f1673e04b6df3b8c78c" translate="yes" xml:space="preserve">
          <source>The second case often turns out to have identical results to the first case, albeit only by accident.</source>
          <target state="translated">두 번째 사례는 우연에 의한 것이지만 첫 번째 사례와 동일한 결과를 갖는 것으로 밝혀졌습니다.</target>
        </trans-unit>
        <trans-unit id="9a2db73bb8959c9504bedfb024b1f19ea96655cb" translate="yes" xml:space="preserve">
          <source>The second class of portable ranges is invoked when one or both of the range's end points are expressed as &lt;code&gt;\N{...}&lt;/code&gt;</source>
          <target state="translated">범위의 끝점 중 하나 또는 둘 모두가 &lt;code&gt;\N{...}&lt;/code&gt; 으로 표현 될 때 두 번째 클래스의 이식 가능한 범위가 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="0d9c1d1eb4a7fe50e319b8d6cb4e544cda2638c9" translate="yes" xml:space="preserve">
          <source>The second column is the return type, the third column the name. Columns after that are the arguments. The first column is a set of flags:</source>
          <target state="translated">두 번째 열은 반환 유형이고 세 번째 열은 이름입니다. 그 후의 열이 인수입니다. 첫 번째 열은 플래그 집합입니다.</target>
        </trans-unit>
        <trans-unit id="833ac465c5bc76260e3533a8f5293c1a6cc4e353" translate="yes" xml:space="preserve">
          <source>The second example in the synopsis does something equivalent to this:</source>
          <target state="translated">시놉시스의 두 번째 예는 다음과 같은 기능을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="f7f8f6797190b2ee94971db1ba0f6aeb4ac8dc06" translate="yes" xml:space="preserve">
          <source>The second example prints entries with names &lt;code&gt;foo&lt;/code&gt; , and also entries with names which ends on &lt;code&gt;bar&lt;/code&gt; , or are shorter than 5 chars.</source>
          <target state="translated">두 번째 예는 이름이 &lt;code&gt;foo&lt;/code&gt; 인 항목과 이름이 &lt;code&gt;bar&lt;/code&gt; 로 끝나 거나 5 자보다 짧은 항목을 인쇄합니다 .</target>
        </trans-unit>
        <trans-unit id="ff08cd3ad532db8c5d5dd8a872abb6c4f322ba5e" translate="yes" xml:space="preserve">
          <source>The second example prints entries with names &lt;code&gt;foo&lt;/code&gt;, and also entries with names which ends on &lt;code&gt;bar&lt;/code&gt;, or are shorter than 5 chars.</source>
          <target state="translated">두 번째 예제는 이름이 &lt;code&gt;foo&lt;/code&gt; 인 항목과 &lt;code&gt;bar&lt;/code&gt; 로 끝나 거나 5 자보다 짧은 이름을 가진 항목도 인쇄합니다 .</target>
        </trans-unit>
        <trans-unit id="6b7ec951497cf0073403b17626a675e036c31257" translate="yes" xml:space="preserve">
          <source>The second exit point tests if there is any data left in the input buffer, &lt;code&gt;$input&lt;/code&gt; - remember that the &lt;code&gt;ConsumeInput&lt;/code&gt; option is automatically enabled when &lt;code&gt;LimitOutput&lt;/code&gt; is used. When the input buffer has been exhausted, the outer loop can run again and overwrite a now empty &lt;code&gt;$input&lt;/code&gt; .</source>
          <target state="translated">입력 버퍼에 남아있는 데이터가있을 경우 두 번째 종료점 테스트는 &lt;code&gt;$input&lt;/code&gt; - 기억 &lt;code&gt;ConsumeInput&lt;/code&gt; 의 경우 옵션이 자동으로 활성화됩니다 &lt;code&gt;LimitOutput&lt;/code&gt; 가 사용됩니다. 입력 버퍼가 소진되면 외부 루프가 다시 실행되고 이제 빈 &lt;code&gt;$input&lt;/code&gt; 덮어 쓸 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7cea8aa29f5d1b03f7b0a4cb746f125b76bdff01" translate="yes" xml:space="preserve">
          <source>The second exit point tests if there is any data left in the input buffer, &lt;code&gt;$input&lt;/code&gt; - remember that the &lt;code&gt;ConsumeInput&lt;/code&gt; option is automatically enabled when &lt;code&gt;LimitOutput&lt;/code&gt; is used. When the input buffer has been exhausted, the outer loop can run again and overwrite a now empty &lt;code&gt;$input&lt;/code&gt;.</source>
          <target state="translated">입력 버퍼에 남아있는 데이터가있을 경우 두 번째 종료점 테스트는 &lt;code&gt;$input&lt;/code&gt; - 기억 &lt;code&gt;ConsumeInput&lt;/code&gt; 의 경우 옵션이 자동으로 활성화됩니다 &lt;code&gt;LimitOutput&lt;/code&gt; 가 사용됩니다. 입력 버퍼가 소진되면 외부 루프가 다시 실행되어 현재 비어있는 &lt;code&gt;$input&lt;/code&gt; 덮어 쓸 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1dba4d9ed358b9b1b26a10b82c95880d18ef1ec5" translate="yes" xml:space="preserve">
          <source>The second form allows the filter to hold state information using a closure, thus:</source>
          <target state="translated">두 번째 형식은 필터가 클로저를 사용하여 상태 정보를 보유 할 수 있도록합니다.</target>
        </trans-unit>
        <trans-unit id="204d9fcc358796976a40cb62f3873844790ea690" translate="yes" xml:space="preserve">
          <source>The second form is strongly discouraged, because it breaks the ability of a subclass to reuse the parent's constructor, but you may still run across it in existing code.</source>
          <target state="translated">두 번째 형식은 서브 클래스가 부모의 생성자를 재사용 할 수있는 능력을 상실하기 때문에 권장하지 않지만 기존 코드에서 계속 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0819d819ae212b8e1bcdb9b5bc6d671458a8958e" translate="yes" xml:space="preserve">
          <source>The second form limits or expands the output with shell globbing as in the following examples:</source>
          <target state="translated">두 번째 양식은 다음 예와 같이 쉘 글 로빙으로 출력을 제한하거나 확장합니다.</target>
        </trans-unit>
        <trans-unit id="c407c89499b72c27a5a072472ddedf2b307bb4f0" translate="yes" xml:space="preserve">
          <source>The second form takes an ASCII string of &quot;0&quot; and &quot;1&quot; characters as its argument. It's equivalent to</source>
          <target state="translated">두 번째 형식은 &quot;0&quot;및 &quot;1&quot;문자의 ASCII 문자열을 인수로 사용합니다. 그것은 동등하다</target>
        </trans-unit>
        <trans-unit id="653b770c920437547bfd253af4e36f98e0dbfce5" translate="yes" xml:space="preserve">
          <source>The second form, for convenience, simply calls the &lt;code&gt;new&lt;/code&gt; method on its arguments before dumping the object immediately.</source>
          <target state="translated">편의상 두 번째 형식 은 개체를 즉시 덤프하기 전에 인수 에서 &lt;code&gt;new&lt;/code&gt; 메서드를 호출하기 만하면 됩니다.</target>
        </trans-unit>
        <trans-unit id="dc711c3d286876153bcbf61db541b42c9a9350fc" translate="yes" xml:space="preserve">
          <source>The second gives data on how many keys are at each depth in the chain, and gives an idea of how much work a fetch *hit* will take. The performance for an update or delete of an item in the hash is equivalent to this case.</source>
          <target state="translated">두 번째는 체인의 각 깊이에 몇 개의 키가 있는지에 대한 데이터를 제공하고 가져 오기 * hit *가 얼마나 많은 작업을 수행하는지에 대한 아이디어를 제공합니다. 해시에서 항목의 업데이트 또는 삭제 성능은이 경우와 같습니다.</target>
        </trans-unit>
        <trans-unit id="5995436678b8ce31e572994a72a1c15e94c7f93e" translate="yes" xml:space="preserve">
          <source>The second is</source>
          <target state="translated">두 번째는</target>
        </trans-unit>
        <trans-unit id="3d4dc00d964c0b0076b393752a2dfc8106f40760" translate="yes" xml:space="preserve">
          <source>The second is a question mark &lt;code&gt;?&lt;/code&gt; to match any single character. The third specifies a specific set of characters.</source>
          <target state="translated">두 번째는 물음표 &lt;code&gt;?&lt;/code&gt; 모든 단일 문자와 일치합니다. 세 번째는 특정 문자 집합을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="86badbc4e990f49a4a0e0309ce3e34af3acb8215" translate="yes" xml:space="preserve">
          <source>The second is, in short, more readable. In particular, it's obvious that the number of parameters you're feeding to that phrase (two) is the number of parameters that it</source>
          <target state="translated">두 번째는 요컨대 더 읽기 쉽습니다. 특히, 당신이 그 구에 공급하는 매개 변수의 수 (2)는 그것이 그 매개 변수의 수라는 것이 명백합니다</target>
        </trans-unit>
        <trans-unit id="7d7dcadbcc9256c73e53e45ca4167a8f00171936" translate="yes" xml:space="preserve">
          <source>The second method both creates the AV and initially populates it with SVs:</source>
          <target state="translated">두 번째 방법은 AV를 생성하고 처음에 SV로 채 웁니다.</target>
        </trans-unit>
        <trans-unit id="5a04571edd1042cba183eaac5eb081daffd5163c" translate="yes" xml:space="preserve">
          <source>The second method divides up the generated code into</source>
          <target state="translated">두 번째 방법은 생성 된 코드를</target>
        </trans-unit>
        <trans-unit id="30b5717864fa144252bae28ce0e68e9e2886c509" translate="yes" xml:space="preserve">
          <source>The second new display parameter is &lt;code&gt;&quot;polar_pretty_print&quot;&lt;/code&gt; , which can be set to true or false, the default being true. See the previous section for what this means.</source>
          <target state="translated">두 번째 새 디스플레이 매개 변수는 &lt;code&gt;&quot;polar_pretty_print&quot;&lt;/code&gt; 이며, 기본값은 true 또는 false로 설정할 수 있습니다. 이것이 의미하는 바는 이전 섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="a8d5bb3a74ae14b7cc834ba7cb47fc90749857de" translate="yes" xml:space="preserve">
          <source>The second new display parameter is &lt;code&gt;&quot;polar_pretty_print&quot;&lt;/code&gt;, which can be set to true or false, the default being true. See the previous section for what this means.</source>
          <target state="translated">두 번째 새 표시 매개 변수는 &lt;code&gt;&quot;polar_pretty_print&quot;&lt;/code&gt; 이며 true 또는 false로 설정할 수 있으며 기본값은 true입니다. 이것이 의미하는 바는 이전 섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="105094491ac9a931737afcae5ec00cc67ecea83f" translate="yes" xml:space="preserve">
          <source>The second option is to explicitly instruct Configure to detect the newer Berkeley DB installation, by supplying the right directories with &lt;code&gt;-Dlocincpth=/some/include&lt;/code&gt; and &lt;code&gt;-Dloclibpth=/some/lib&lt;/code&gt;&lt;b&gt;and&lt;/b&gt; before running &quot;make test&quot; setting your LD_LIBRARY_PATH to</source>
          <target state="translated">두 번째 옵션은 올바른 디렉토리에 &lt;code&gt;-Dlocincpth=/some/include&lt;/code&gt; 및 &lt;code&gt;-Dloclibpth=/some/lib&lt;/code&gt; 를 제공&lt;b&gt;하고&lt;/b&gt; &quot;make test&quot;를 실행하기 전에 LD_LIBRARY_PATH를</target>
        </trans-unit>
        <trans-unit id="b104d0289f2a63192d73ded4515b99bcffef5da9" translate="yes" xml:space="preserve">
          <source>The second parameter, &lt;code&gt;$mode&lt;/code&gt; , is used to specify whether the file is opened for reading or writing and to optionally specify a compression level and compression strategy when writing. The format of the &lt;code&gt;$mode&lt;/code&gt; parameter is similar to the mode parameter to the 'C' function &lt;code&gt;fopen&lt;/code&gt; , so &quot;rb&quot; is used to open for reading, &quot;wb&quot; for writing and &quot;ab&quot; for appending (writing at the end of the file).</source>
          <target state="translated">두 번째 매개 변수 &lt;code&gt;$mode&lt;/code&gt; 는 파일을 읽거나 쓸 수 있도록 열지 여부를 지정하고, 쓸 때 압축 수준과 압축 전략을 선택적으로 지정하는 데 사용됩니다. &lt;code&gt;$mode&lt;/code&gt; 매개 변수 의 형식은 'C'함수 &lt;code&gt;fopen&lt;/code&gt; 의 mode 매개 변수와 유사 하므로 &quot;rb&quot;는 읽기를 위해 열고, &quot;wb&quot;는 쓰기를 위해, 추가하려면 &quot;ab&quot;를 사용하여 추가합니다 ( 파일).</target>
        </trans-unit>
        <trans-unit id="40f3477c6f4b0d20844832da1b4bf48b8115879e" translate="yes" xml:space="preserve">
          <source>The second parameter, &lt;code&gt;$mode&lt;/code&gt;, is used to specify whether the file is opened for reading or writing and to optionally specify a compression level and compression strategy when writing. The format of the &lt;code&gt;$mode&lt;/code&gt; parameter is similar to the mode parameter to the 'C' function &lt;code&gt;fopen&lt;/code&gt;, so &quot;rb&quot; is used to open for reading, &quot;wb&quot; for writing and &quot;ab&quot; for appending (writing at the end of the file).</source>
          <target state="translated">두 번째 매개 변수 인 &lt;code&gt;$mode&lt;/code&gt; 는 파일이 읽기 또는 쓰기 용으로 열리는 지 여부를 지정하고 선택적으로 쓰기시 압축 수준 및 압축 전략을 지정하는 데 사용됩니다. &lt;code&gt;$mode&lt;/code&gt; 매개 변수 의 형식은 'C'함수 &lt;code&gt;fopen&lt;/code&gt; 에 대한 mode 매개 변수와 유사 하므로 &quot;rb&quot;는 읽기 용으로, &quot;wb&quot;는 쓰기 용, &quot;ab&quot;는 추가 용 (끝에 쓰기)에 사용됩니다. 파일).</target>
        </trans-unit>
        <trans-unit id="3411b2ade45037b8736308e07cf74ad1d92df3ee" translate="yes" xml:space="preserve">
          <source>The second regexp doesn't match because &lt;code&gt;'^'&lt;/code&gt; constrains &lt;code&gt;keeper&lt;/code&gt; to match only at the beginning of the string, but &lt;code&gt;&quot;housekeeper&quot;&lt;/code&gt; has keeper starting in the middle. The third regexp does match, since the &lt;code&gt;'$'&lt;/code&gt; constrains &lt;code&gt;keeper&lt;/code&gt; to match only at the end of the string.</source>
          <target state="translated">두 번째 정규식은 일치하지 않습니다. &lt;code&gt;'^'&lt;/code&gt; 는 &lt;code&gt;keeper&lt;/code&gt; 가 문자열의 시작 부분에서만 일치하도록 제한 하지만 &lt;code&gt;&quot;housekeeper&quot;&lt;/code&gt; 에는 중간에서 시작하는 키퍼가 있습니다. 세 번째 정규식은 일치합니다. &lt;code&gt;'$'&lt;/code&gt; 는 &lt;code&gt;keeper&lt;/code&gt; 가 문자열의 끝에서만 일치하도록 제한 하기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="9eae2bfeb40a7aaf7114e7fd8256ee81caccdbd3" translate="yes" xml:space="preserve">
          <source>The second regexp doesn't match because &lt;code&gt;^&lt;/code&gt; constrains &lt;code&gt;keeper&lt;/code&gt; to match only at the beginning of the string, but &lt;code&gt;&quot;housekeeper&quot;&lt;/code&gt; has keeper starting in the middle. The third regexp does match, since the &lt;code&gt;$&lt;/code&gt; constrains &lt;code&gt;keeper&lt;/code&gt; to match only at the end of the string.</source>
          <target state="translated">&lt;code&gt;^&lt;/code&gt; &lt;code&gt;keeper&lt;/code&gt; 가 문자열의 시작 부분에서만 일치하도록 제한 하기 때문에 두 번째 정규 표현식이 일치하지 않지만 &lt;code&gt;&quot;housekeeper&quot;&lt;/code&gt; 는 중간부터 시작합니다. &lt;code&gt;$&lt;/code&gt; 제한 &lt;code&gt;keeper&lt;/code&gt; 가 문자열의 끝에서만 일치하기 때문에 세 번째 정규 표현식이 일치 합니다.</target>
        </trans-unit>
        <trans-unit id="733da91fc44d8ab5e75ced78a6cc48a582c7d7b0" translate="yes" xml:space="preserve">
          <source>The second returned item and &lt;code&gt;$!&lt;/code&gt; can be used to check for valid input:</source>
          <target state="translated">두 번째 반품 및 &lt;code&gt;$!&lt;/code&gt; 유효한 입력을 확인하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2c1496bf9c5a01143ce96b1f9c010fe32e40f772" translate="yes" xml:space="preserve">
          <source>The second sentence is wrong. In actual fact bval will only default to &lt;code&gt;&quot;\n&quot;&lt;/code&gt; when the openinfo parameter in dbopen is NULL. If a non-NULL openinfo parameter is used at all, the value that happens to be in bval will be used. That means you always have to specify bval when making use of any of the options in the openinfo parameter. This documentation error will be fixed in the next release of Berkeley DB.</source>
          <target state="translated">두 번째 문장이 잘못되었습니다. 실제로 dbopen의 openinfo 매개 변수가 NULL 인 경우 bval의 기본값은 &lt;code&gt;&quot;\n&quot;&lt;/code&gt; 입니다. NULL이 아닌 openinfo 매개 변수가 전혀 사용되지 않으면 bval에있는 값이 사용됩니다. 즉, openinfo 매개 변수의 옵션을 사용할 때 항상 bval을 지정해야합니다. 이 설명서 오류는 다음 Berkeley DB 릴리스에서 수정 될 것입니다.</target>
        </trans-unit>
        <trans-unit id="aaad1f57fe700f2a9b2dd58ec708684feaf8128f" translate="yes" xml:space="preserve">
          <source>The second situation is caused by an eval accessing a lexical subroutine that has gone out of scope, for example,</source>
          <target state="translated">두 번째 상황은 예를 들어 범위를 벗어난 어휘 서브 루틴에 액세스하는 평가로 인해 발생합니다.</target>
        </trans-unit>
        <trans-unit id="9ade278ee614d31e9547b1781d35dc6ff90a8980" translate="yes" xml:space="preserve">
          <source>The second situation is caused by an eval accessing a variable that has gone out of scope, for example,</source>
          <target state="translated">두 번째 상황은 예를 들어 범위를 벗어난 변수에 액세스하는 평가로 인해 발생합니다.</target>
        </trans-unit>
        <trans-unit id="b47d8c8a23f4e0d763e99999d69c0c5eb0cb3a92" translate="yes" xml:space="preserve">
          <source>The second style of bundling lifts this restriction. It can be enabled with:</source>
          <target state="translated">번들링의 두 번째 스타일은이 제한을 해제합니다. 다음을 사용하여 활성화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ab8073e684e0f88cfe3fd5f9716b9c696bbef27e" translate="yes" xml:space="preserve">
          <source>The second value to be substituted in the output string (usually the row in cursor addressing capabilities)</source>
          <target state="translated">출력 문자열에서 대체 될 두 번째 값 (일반적으로 커서 주소 지정 기능의 행)</target>
        </trans-unit>
        <trans-unit id="72ec171fc6e9d8dd4e1917d8ba0d47a2f390d23d" translate="yes" xml:space="preserve">
          <source>The second, more efficient way is to use the following template for your Foo.xs:</source>
          <target state="translated">두 번째로 더 효율적인 방법은 Foo.xs에 다음 템플릿을 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="ea8fa202ee5b9df3dfb7272625ecae21681f7d7d" translate="yes" xml:space="preserve">
          <source>The section (AKA &quot;item&quot; in older perlpods), or &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; if none. E.g., in &quot;L&amp;lt;Getopt::Std/DESCRIPTION&amp;gt;&quot;, &quot;DESCRIPTION&quot; is the section. (Note that this is not the same as a manpage section like the &quot;5&quot; in &quot;man 5 crontab&quot;. &quot;Section Foo&quot; in the Pod sense means the part of the text that's introduced by the heading or item whose text is &quot;Foo&quot;.)</source>
          <target state="translated">섹션 (이전 perlpod의 AKA &quot;항목&quot;) 또는 정의 되지 않은 경우 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; . 예를 들어 &quot;L &amp;lt;Getopt :: Std / DESCRIPTION&amp;gt;&quot;에서 &quot;DESCRIPTION&quot;은 섹션입니다. (이것은 &quot;man 5 crontab&quot;의 &quot;5&quot;와 같은 맨 페이지 섹션과 동일하지 않습니다. 포드 의미의 &quot;섹션 Foo&quot;는 제목이 도입 한 텍스트 또는 텍스트가 &quot;Foo&quot;인 항목의 일부를 의미합니다. &quot;.)</target>
        </trans-unit>
        <trans-unit id="cd89b9d74f7d870dca4a759e8ab8f51f0dc1f9b2" translate="yes" xml:space="preserve">
          <source>The section (AKA &quot;item&quot; in older perlpods), or &lt;code&gt;undef&lt;/code&gt; if none. E.g., in &quot;L&amp;lt;Getopt::Std/DESCRIPTION&amp;gt;&quot;, &quot;DESCRIPTION&quot; is the section. (Note that this is not the same as a manpage section like the &quot;5&quot; in &quot;man 5 crontab&quot;. &quot;Section Foo&quot; in the Pod sense means the part of the text that's introduced by the heading or item whose text is &quot;Foo&quot;.)</source>
          <target state="translated">섹션 (이전 perlpod에서는 &quot;item&quot;이라고도 함) 또는 없는 경우 &lt;code&gt;undef&lt;/code&gt; . 예를 들어, &quot;L &amp;lt;Getopt :: Std / DESCRIPTION&amp;gt;&quot;에서 &quot;DESCRIPTION&quot;은 섹션입니다. (이것은 &quot;man 5 crontab&quot;의 &quot;5&quot;와 같은 맨 페이지 섹션과 다릅니다. Pod 의미의 &quot;Section Foo&quot;는 텍스트가 &quot;Foo&quot;인 제목 또는 항목에 의해 소개되는 텍스트 부분을 의미합니다. &quot;.)</target>
        </trans-unit>
        <trans-unit id="592a5f44132e9a3aa5e9a10cfa07afacf196746b" translate="yes" xml:space="preserve">
          <source>The security aspect of temporary file creation is emphasized such that a filehandle and filename are returned together. This helps guarantee that a race condition can not occur where the temporary file is created by another process between checking for the existence of the file and its opening. Additional security levels are provided to check, for example, that the sticky bit is set on world writable directories. See &lt;a href=&quot;#safe_level&quot;&gt;&quot;safe_level&quot;&lt;/a&gt; for more information.</source>
          <target state="translated">임시 파일 생성의 보안 측면이 강조되어 파일 핸들과 파일 이름이 함께 반환됩니다. 이렇게하면 파일의 존재 여부를 확인하고 파일을 여는 사이에 다른 프로세스에서 임시 파일을 만드는 경우 경합 상태가 발생하지 않도록 할 수 있습니다. 예를 들어, 고정 비트가 세계 쓰기 가능한 디렉토리에 설정되어 있는지 확인하기 위해 추가 보안 수준이 제공됩니다. 자세한 내용은 &lt;a href=&quot;#safe_level&quot;&gt;&quot;safe_level&quot;&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="8d5faf936bbea0ef6b4af3b53c6607ced9b3cdea" translate="yes" xml:space="preserve">
          <source>The security aspect of temporary file creation is emphasized such that a filehandle and filename are returned together. This helps guarantee that a race condition can not occur where the temporary file is created by another process between checking for the existence of the file and its opening. Additional security levels are provided to check, for example, that the sticky bit is set on world writable directories. See &lt;a href=&quot;#safe_level&quot;&gt;safe_level&lt;/a&gt; for more information.</source>
          <target state="translated">파일 핸들과 파일 이름이 함께 리턴되도록 임시 파일 작성의 보안 측면이 강조됩니다. 이렇게하면 파일 존재 여부와 열기를 확인하는 다른 프로세스에서 임시 파일을 만들 때 경쟁 조건이 발생하지 않도록 보장 할 수 있습니다. 예를 들어, 고정 비트가 세계 쓰기 가능 디렉토리에 설정되어 있는지 확인하기 위해 추가 보안 레벨이 제공됩니다. 자세한 내용은 &lt;a href=&quot;#safe_level&quot;&gt;safe_level&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="02ef1170c6c4276366f2c9602e48f300db3d9145" translate="yes" xml:space="preserve">
          <source>The seemingly equivalent construct in Perl, &lt;code&gt;$$aref[$i]&lt;/code&gt; first does the deref of $aref, making it take $aref as a reference to an array, and then dereference that, and finally tell you the</source>
          <target state="translated">Perl에서 겉으로 동등한 구성 인 &lt;code&gt;$$aref[$i]&lt;/code&gt; 먼저 $ aref의 deref를 수행하여 배열에 대한 참조로 $ aref를 취한 다음 역 참조하고 마지막으로</target>
        </trans-unit>
        <trans-unit id="5ae490ef8bae426993ed6639b51d33e36f67a5f8" translate="yes" xml:space="preserve">
          <source>The semantics of interval timers for multithreaded programs are system-specific, and some systems may support additional interval timers. For example, it is unspecified which thread gets the signals. See your &lt;a href=&quot;setitimer(2)&quot;&gt;&lt;code&gt;setitimer(2)&lt;/code&gt;&lt;/a&gt; documentation.</source>
          <target state="translated">다중 스레드 프로그램에 대한 간격 타이머의 의미는 시스템에 따라 다르며 일부 시스템은 추가 간격 타이머를 지원할 수 있습니다. 예를 들어, 어떤 스레드가 신호를 받는지는 지정되지 않았습니다. &lt;a href=&quot;setitimer(2)&quot;&gt; &lt;code&gt;setitimer(2)&lt;/code&gt; &lt;/a&gt; 문서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="5d3a7adddb69f2204deb61bd662439aeebd384d4" translate="yes" xml:space="preserve">
          <source>The semantics of interval timers for multithreaded programs are system-specific, and some systems may support additional interval timers. For example, it is unspecified which thread gets the signals. See your &lt;code&gt;setitimer()&lt;/code&gt; documentation.</source>
          <target state="translated">멀티 스레드 프로그램에 대한 간격 타이머의 의미는 시스템마다 다르며 일부 시스템은 추가 간격 타이머를 지원할 수 있습니다. 예를 들어 어떤 스레드가 신호를 가져 오는지는 지정되지 않습니다. &lt;code&gt;setitimer()&lt;/code&gt; 설명서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="65ef3e0624e679879b7ce02cec7d6809073f165d" translate="yes" xml:space="preserve">
          <source>The sense of the match can be reversed by using &lt;code&gt;!~&lt;/code&gt; operator:</source>
          <target state="translated">&lt;code&gt;!~&lt;/code&gt; 연산자 를 사용하여 일치를 반전시킬 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="571f2b8a003669439aca5df927f2bc3b59493e17" translate="yes" xml:space="preserve">
          <source>The sequence &lt;code&gt;\b&lt;/code&gt; is special inside a bracketed character class. While outside the character class, &lt;code&gt;\b&lt;/code&gt; is an assertion indicating a point that does not have either two word characters or two non-word characters on either side, inside a bracketed character class, &lt;code&gt;\b&lt;/code&gt; matches a backspace character.</source>
          <target state="translated">시퀀스 &lt;code&gt;\b&lt;/code&gt; 는 대괄호로 묶은 문자 클래스 내에서 특별합니다. 문자 클래스 외부에있는 &lt;code&gt;\b&lt;/code&gt; 는 괄호 문자 클래스 내부에서 양쪽에 두 개의 단어 문자 또는 두 개의 비 단어 문자가없는 지점을 나타내는 어설 션 입니다. &lt;code&gt;\b&lt;/code&gt; 는 백 스페이스 문자와 일치합니다.</target>
        </trans-unit>
        <trans-unit id="2e682f0e9f09d4fac48ccdb6cb912af9bfeddf7f" translate="yes" xml:space="preserve">
          <source>The sequence can also be extended to negative index n using the re-arranged recurrence relation</source>
          <target state="translated">순서는 다시 배열 된 반복 관계를 사용하여 음의 인덱스 n으로 확장 될 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="6b263532d25e62f98e230387976bd3e1a8c5cb59" translate="yes" xml:space="preserve">
          <source>The sequence number of the OP's next OP.</source>
          <target state="translated">OP의 다음 OP의 시퀀스 번호입니다.</target>
        </trans-unit>
        <trans-unit id="b45bacc53a5ed1f0afceaa4ff3006834edab117c" translate="yes" xml:space="preserve">
          <source>The sequence number of the OP, or a hyphen if it doesn't have one.</source>
          <target state="translated">OP의 시퀀스 번호 또는 하이픈이없는 경우 하이픈입니다.</target>
        </trans-unit>
        <trans-unit id="4f0a83d5889e74bacf92e475321b6ad01721beb5" translate="yes" xml:space="preserve">
          <source>The sequence number of the OP. Note that this is a sequence number generated by B::Concise.</source>
          <target state="translated">OP의 시퀀스 번호. 이것은 B :: Concise에 의해 생성 된 시퀀스 번호입니다.</target>
        </trans-unit>
        <trans-unit id="a1e46d38c7dda11bf03f174aca8ec057ac38a288" translate="yes" xml:space="preserve">
          <source>The sequence number of this partition. Partitions are numbered starting as &lt;code&gt;1&lt;/code&gt; [with &quot;partition 0&quot; meaning the entire disk]. Sometimes this field may be &lt;code&gt;0&lt;/code&gt; and you'll have to infer the partition sequence number from how many partitions precede it on the disk.</source>
          <target state="translated">이 파티션의 시퀀스 번호입니다. 파티션은 &lt;code&gt;1&lt;/code&gt; 부터 시작하여 번호가 지정됩니다 [ &quot;파티션 0&quot;은 전체 디스크를 의미 함]. 때로는이 필드가 &lt;code&gt;0&lt;/code&gt; 일 수 있으며 디스크에서 몇 개의 파티션이 앞에 있는지에서 파티션 시퀀스 번호를 추론해야합니다.</target>
        </trans-unit>
        <trans-unit id="c10dc949f49eb3d32cdb0534e93e9f1fddb641e8" translate="yes" xml:space="preserve">
          <source>The sequences &lt;code&gt;\a&lt;/code&gt; , &lt;code&gt;\c&lt;/code&gt; , &lt;code&gt;\e&lt;/code&gt; , &lt;code&gt;\f&lt;/code&gt; , &lt;code&gt;\n&lt;/code&gt; , &lt;code&gt;\N{&lt;i&gt;NAME&lt;/i&gt;}&lt;/code&gt;, &lt;code&gt;\N{U+&lt;i&gt;hex char&lt;/i&gt;}&lt;/code&gt;, &lt;code&gt;\r&lt;/code&gt; , &lt;code&gt;\t&lt;/code&gt; , and &lt;code&gt;\x&lt;/code&gt; are also special and have the same meanings as they do outside a bracketed character class.</source>
          <target state="translated">&lt;code&gt;\a&lt;/code&gt; , &lt;code&gt;\c&lt;/code&gt; , &lt;code&gt;\e&lt;/code&gt; , &lt;code&gt;\f&lt;/code&gt; , &lt;code&gt;\n&lt;/code&gt; , &lt;code&gt;\N{&lt;i&gt;NAME&lt;/i&gt;}&lt;/code&gt; , &lt;code&gt;\N{U+&lt;i&gt;hex char&lt;/i&gt;}&lt;/code&gt; , &lt;code&gt;\r&lt;/code&gt; , &lt;code&gt;\t&lt;/code&gt; 및 &lt;code&gt;\x&lt;/code&gt; 시퀀스 도 특별하며 동일한 의미를 갖습니다. 대괄호로 묶은 문자 클래스 외부에서 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="90a0a5f9a35ae3ea0a297068e4b1bab795815fcf" translate="yes" xml:space="preserve">
          <source>The sequences &lt;code&gt;\a&lt;/code&gt;, &lt;code&gt;\c&lt;/code&gt;, &lt;code&gt;\e&lt;/code&gt;, &lt;code&gt;\f&lt;/code&gt;, &lt;code&gt;\n&lt;/code&gt;, &lt;code&gt;\N{&lt;i&gt;NAME&lt;/i&gt;}&lt;/code&gt;, &lt;code&gt;\N{U+&lt;i&gt;hex char&lt;/i&gt;}&lt;/code&gt;, &lt;code&gt;\r&lt;/code&gt;, &lt;code&gt;\t&lt;/code&gt;, and &lt;code&gt;\x&lt;/code&gt; are also special and have the same meanings as they do outside a bracketed character class.</source>
          <target state="translated">&lt;code&gt;\a&lt;/code&gt; , &lt;code&gt;\c&lt;/code&gt; , &lt;code&gt;\e&lt;/code&gt; , &lt;code&gt;\f&lt;/code&gt; , &lt;code&gt;\n&lt;/code&gt; , &lt;code&gt;\N{&lt;i&gt;NAME&lt;/i&gt;}&lt;/code&gt; , &lt;code&gt;\N{U+&lt;i&gt;hex char&lt;/i&gt;}&lt;/code&gt; , &lt;code&gt;\r&lt;/code&gt; , &lt;code&gt;\t&lt;/code&gt; 및 &lt;code&gt;\x&lt;/code&gt; 시퀀스 도 특별하며 동일한 의미를 갖습니다. 대괄호 문자 클래스 외부에서 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="899a56478deaf614d4bf9d04537d9557616e32cf" translate="yes" xml:space="preserve">
          <source>The serialized structure will include a &lt;code&gt;x_serialization_backend&lt;/code&gt; entry giving the package and version used to serialize. Any existing key in the given &lt;code&gt;$meta&lt;/code&gt; object will be clobbered.</source>
          <target state="translated">직렬화 구조에는 직렬화에 사용되는 패키지 및 버전을 제공 하는 &lt;code&gt;x_serialization_backend&lt;/code&gt; 항목 이 포함 됩니다. 주어진 &lt;code&gt;$meta&lt;/code&gt; 개체 에있는 기존 키는 제거 됩니다.</target>
        </trans-unit>
        <trans-unit id="0d53186f69243fe4e7fc81db07bccfc51f977e9e" translate="yes" xml:space="preserve">
          <source>The serializing hook, called on the object during serialization. It can be inherited, or defined in the class itself, like any other method.</source>
          <target state="translated">직렬화 중에 객체에서 호출 된 직렬화 후크. 다른 메소드와 마찬가지로 상속되거나 클래스 자체에서 정의 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4e9ebcecc7a860f145ea8f9108514a4fa8316dfb" translate="yes" xml:space="preserve">
          <source>The service name supplied to getaddrinfo() is not available for the socket type given in the $hints.</source>
          <target state="translated">$ addts에 제공된 소켓 유형에 대해 getaddrinfo ()에 제공된 서비스 이름을 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="ba23ccf9d34101355ab34a3727e24a0a0f7b250a" translate="yes" xml:space="preserve">
          <source>The services a piece of code promises to provide forever, in contrast to its &lt;b&gt;implementation&lt;/b&gt;, which it should feel free to change whenever it likes.</source>
          <target state="translated">코드의 일부는 &lt;b&gt;구현&lt;/b&gt; 과 달리 영원히 제공하겠다고 약속하는 서비스로 , 언제든지 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="32c78a4d560dbf4474d5f3b5cef5e0e631bdf4c5" translate="yes" xml:space="preserve">
          <source>The set is specified as a list of characters, or as a range of characters where the beginning and end of the range are separated by a minus (or dash) character, or as any combination of lists and ranges. The dash can also be included in the set as a character it if is the beginning or end of the set. This set is enclosed in square brackets. The close square bracket &lt;code&gt;]&lt;/code&gt; may be used in a set if it is the first character in the set.</source>
          <target state="translated">세트는 문자 목록 또는 범위의 시작과 끝이 빼기 (또는 대시) 문자로 구분되는 문자 범위 또는 목록과 범위의 조합으로 지정됩니다. 또한 세트의 시작 또는 끝인 경우 대시를 문자로 세트에 포함시킬 수 있습니다. 이 세트는 대괄호로 묶습니다. 닫는 대괄호 &lt;code&gt;]&lt;/code&gt; 는 세트의 첫 번째 문자 인 경우 세트에 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="271c11282a628a982454242ec29109ed2ea23f1d" translate="yes" xml:space="preserve">
          <source>The set of characters that are deemed whitespace are those that Unicode calls &quot;Pattern White Space&quot;, namely:</source>
          <target state="translated">공백으로 간주되는 문자 세트는 유니 코드가 &quot;패턴 공백&quot;이라고하는 문자입니다.</target>
        </trans-unit>
        <trans-unit id="5e7d4549f7a90817f3e92cc9271f629864ca580a" translate="yes" xml:space="preserve">
          <source>The setlocale function</source>
          <target state="translated">setlocale 함수</target>
        </trans-unit>
        <trans-unit id="6cd53441a7a72535c4ff8e055f31a3a3fc042379" translate="yes" xml:space="preserve">
          <source>The setting of subroutine attributes happens at compile time. Variable attributes in &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; declarations are also applied at compile time. However, &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; variables get their attributes applied at run-time. This means that you have to</source>
          <target state="translated">서브 루틴 속성 설정은 컴파일시 발생합니다. 변수 속성 &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; 선언은 컴파일시에 적용됩니다. 그러나 &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; 변수는 런타임에 속성이 적용됩니다. 이것은 당신이해야한다는 것을 의미합니다</target>
        </trans-unit>
        <trans-unit id="229ecae54cd846eee20b1cbee543175ec9cd197e" translate="yes" xml:space="preserve">
          <source>The setting of subroutine attributes happens at compile time. Variable attributes in &lt;code&gt;our&lt;/code&gt; declarations are also applied at compile time. However, &lt;code&gt;my&lt;/code&gt; variables get their attributes applied at run-time. This means that you have to</source>
          <target state="translated">서브 루틴 속성 설정은 컴파일 시간에 발생합니다. 변수 속성 &lt;code&gt;our&lt;/code&gt; 선언은 컴파일시에 적용됩니다. 그러나 &lt;code&gt;my&lt;/code&gt; 변수는 런타임에 속성이 적용됩니다. 이것은 당신이</target>
        </trans-unit>
        <trans-unit id="ab1edc3ed4db36281da6290a4a02b6bb1d2f2a9a" translate="yes" xml:space="preserve">
          <source>The seven routines are:</source>
          <target state="translated">7 가지 루틴은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7db711982141cfb12b9e3602192ccba86ac4d921" translate="yes" xml:space="preserve">
          <source>The sheet</source>
          <target state="translated">시트</target>
        </trans-unit>
        <trans-unit id="67100f7fba2fe91ac3115331e86988966a0f9ad9" translate="yes" xml:space="preserve">
          <source>The shell offers to run in</source>
          <target state="translated">쉘은 다음과 같이 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="d2a4c575dba49342e824220d900f0c783780f4b9" translate="yes" xml:space="preserve">
          <source>The shell's &lt;code&gt;test&lt;/code&gt; uses &quot;=&quot;, &quot;!=&quot;, &quot;&amp;lt;&quot; etc for string comparisons and &quot;-eq&quot;, &quot;-ne&quot;, &quot;-lt&quot; etc for numeric comparisons. This is the reverse of Perl, which uses &lt;code&gt;eq&lt;/code&gt; , &lt;code&gt;ne&lt;/code&gt; , &lt;code&gt;lt&lt;/code&gt; for string comparisons, and &lt;code&gt;==&lt;/code&gt; , &lt;code&gt;!=&lt;/code&gt;&lt;code&gt;&amp;lt;&lt;/code&gt; etc for numeric comparisons.</source>
          <target state="translated">쉘의 &lt;code&gt;test&lt;/code&gt; 는 문자열 비교에 &quot;=&quot;, &quot;! =&quot;, &quot;&amp;lt;&quot;등을 사용하고 숫자 비교에 &quot;-eq&quot;, &quot;-ne&quot;, &quot;-lt&quot;등을 사용합니다. 이것은 사용하는 펄의 역이다 &lt;code&gt;eq&lt;/code&gt; , &lt;code&gt;ne&lt;/code&gt; , &lt;code&gt;lt&lt;/code&gt; 문자열 비교를 위해, 그리고 &lt;code&gt;==&lt;/code&gt; , &lt;code&gt;!=&lt;/code&gt; &lt;code&gt;&amp;lt;&lt;/code&gt; 등 수치 비교를 위해.</target>
        </trans-unit>
        <trans-unit id="a4421a2ab5bd2e622c5d0a683eecbd4f08bbe24b" translate="yes" xml:space="preserve">
          <source>The shell's &lt;code&gt;test&lt;/code&gt; uses &quot;=&quot;, &quot;!=&quot;, &quot;&amp;lt;&quot; etc for string comparisons and &quot;-eq&quot;, &quot;-ne&quot;, &quot;-lt&quot; etc for numeric comparisons. This is the reverse of Perl, which uses &lt;code&gt;eq&lt;/code&gt;, &lt;code&gt;ne&lt;/code&gt;, &lt;code&gt;lt&lt;/code&gt; for string comparisons, and &lt;code&gt;==&lt;/code&gt;, &lt;code&gt;!=&lt;/code&gt;&lt;code&gt;&amp;lt;&lt;/code&gt; etc for numeric comparisons.</source>
          <target state="translated">쉘의 &lt;code&gt;test&lt;/code&gt; 는 문자열 비교를 위해 &quot;=&quot;, &quot;! =&quot;, &quot;&amp;lt;&quot;등을 사용하고 숫자 비교를 위해 &quot;-eq&quot;, &quot;-ne&quot;, &quot;-lt&quot;등을 사용합니다. 이것은 사용하는 펄의 역이다 &lt;code&gt;eq&lt;/code&gt; , &lt;code&gt;ne&lt;/code&gt; , &lt;code&gt;lt&lt;/code&gt; 문자열 비교를 위해, 그리고 &lt;code&gt;==&lt;/code&gt; , &lt;code&gt;!=&lt;/code&gt; &lt;code&gt;&amp;lt;&lt;/code&gt; 등 수치 비교를 위해.</target>
        </trans-unit>
        <trans-unit id="fe36cec28443e99377776c6efc56682531e56f06" translate="yes" xml:space="preserve">
          <source>The short answer is that by default Perl compares equivalence (&lt;code&gt;eq&lt;/code&gt; , &lt;code&gt;ne&lt;/code&gt; ) based only on code points of the characters. In the above case, the answer is no (because 0x00C1 != 0x0041). But sometimes, any CAPITAL LETTER A's should be considered equal, or even A's of any case.</source>
          <target state="translated">짧은 대답은 기본적으로 Perl은 문자의 코드 포인트만을 기준으로 동등성 ( &lt;code&gt;eq&lt;/code&gt; , &lt;code&gt;ne&lt;/code&gt; )을 비교한다는 것입니다 . 위의 경우 대답은 아니요입니다 (0x00C1! = 0x0041). 그러나 때로는 대문자로 된 A가 모두 같거나 어떤 경우에도 A로 간주되어야합니다.</target>
        </trans-unit>
        <trans-unit id="84602cf60297d60acdefd80efdd1c60462b73b9b" translate="yes" xml:space="preserve">
          <source>The short answer is that by default Perl compares equivalence (&lt;code&gt;eq&lt;/code&gt;, &lt;code&gt;ne&lt;/code&gt;) based only on code points of the characters. In the above case, the answer is no (because 0x00C1 != 0x0041). But sometimes, any CAPITAL LETTER A's should be considered equal, or even A's of any case.</source>
          <target state="translated">짧은 대답은 기본적으로 Perl 이 문자의 코드 포인트만을 기반으로 동등성 ( &lt;code&gt;eq&lt;/code&gt; , &lt;code&gt;ne&lt;/code&gt; )을 비교한다는 것입니다 . 위의 경우 대답은 아니오입니다 (0x00C1! = 0x0041 때문에). 그러나 때로는 대문자 A가 동등하거나 어떤 경우에도 A로 간주되어야합니다.</target>
        </trans-unit>
        <trans-unit id="b57501930c25501b20f82b569d1ea16761a497e6" translate="yes" xml:space="preserve">
          <source>The short answer is that by default, Perl compares strings (&lt;code&gt;lt&lt;/code&gt; , &lt;code&gt;le&lt;/code&gt; , &lt;code&gt;cmp&lt;/code&gt; , &lt;code&gt;ge&lt;/code&gt; , &lt;code&gt;gt&lt;/code&gt; ) based only on the code points of the characters. In the above case, the answer is &quot;after&quot;, since &lt;code&gt;0x00C1&lt;/code&gt; &amp;gt; &lt;code&gt;0x00C0&lt;/code&gt; .</source>
          <target state="translated">짧은 대답은 기본적으로 Perl은 문자의 코드 포인트만을 기준으로 문자열 ( &lt;code&gt;lt&lt;/code&gt; , &lt;code&gt;le&lt;/code&gt; , &lt;code&gt;cmp&lt;/code&gt; , &lt;code&gt;ge&lt;/code&gt; , &lt;code&gt;gt&lt;/code&gt; )을 비교한다는 것입니다. 위의 경우 &lt;code&gt;0x00C1&lt;/code&gt; &amp;gt; &lt;code&gt;0x00C0&lt;/code&gt; 이기 때문에 대답은 &quot;after&quot; 입니다.</target>
        </trans-unit>
        <trans-unit id="d67ccb6666f81cda59931fcf7ad032ead024bc41" translate="yes" xml:space="preserve">
          <source>The short answer is that by default, Perl compares strings (&lt;code&gt;lt&lt;/code&gt;, &lt;code&gt;le&lt;/code&gt;, &lt;code&gt;cmp&lt;/code&gt;, &lt;code&gt;ge&lt;/code&gt;, &lt;code&gt;gt&lt;/code&gt;) based only on the code points of the characters. In the above case, the answer is &quot;after&quot;, since &lt;code&gt;0x00C1&lt;/code&gt; &amp;gt; &lt;code&gt;0x00C0&lt;/code&gt;.</source>
          <target state="translated">짧은 대답은 기본적으로 Perl 이 문자의 코드 포인트만을 기준으로 문자열 ( &lt;code&gt;lt&lt;/code&gt; , &lt;code&gt;le&lt;/code&gt; , &lt;code&gt;cmp&lt;/code&gt; , &lt;code&gt;ge&lt;/code&gt; , &lt;code&gt;gt&lt;/code&gt; )을 비교한다는 것입니다. 위의 경우 &lt;code&gt;0x00C1&lt;/code&gt; &amp;gt; &lt;code&gt;0x00C0&lt;/code&gt; 이므로 답은 &quot;이후&quot; 입니다.</target>
        </trans-unit>
        <trans-unit id="ace0e0cec639bb708cb2cf532e982971dd3748da" translate="yes" xml:space="preserve">
          <source>The short name of the general category of</source>
          <target state="translated">일반 카테고리의 짧은 이름</target>
        </trans-unit>
        <trans-unit id="02c6ec10d109a1b719286e329258adf56d502cef" translate="yes" xml:space="preserve">
          <source>The short story</source>
          <target state="translated">짧은 이야기</target>
        </trans-unit>
        <trans-unit id="eb4d2d85d25fb4d71e2225f2e7a3eb6515112128" translate="yes" xml:space="preserve">
          <source>The short story is that you should probably only use defined on scalars or functions, not on aggregates (arrays and hashes). See &lt;a href=&quot;functions/defined&quot;&gt;defined&lt;/a&gt; in the 5.004 release or later of Perl for more detail.</source>
          <target state="translated">짧은 이야기는 아마도 집계 (배열 및 해시)가 아닌 스칼라 또는 함수에서만 정의되어야한다는 것입니다. 자세한 내용 은 Perl 5.004 릴리스 이상에 &lt;a href=&quot;functions/defined&quot;&gt;정의&lt;/a&gt; 되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="53f5dab7a291daa9043df504d583260ae569f535" translate="yes" xml:space="preserve">
          <source>The short story is that you should probably only use defined on scalars or functions, not on aggregates (arrays and hashes). See &lt;a href=&quot;perlfunc#defined&quot;&gt;&quot;defined&quot; in perlfunc&lt;/a&gt; in the 5.004 release or later of Perl for more detail.</source>
          <target state="translated">짧은 이야기는 집계 (배열 및 해시)가 아닌 스칼라 또는 함수에서만 정의 된 것을 사용해야한다는 것입니다. 자세한 내용 은 Perl 5.004 릴리스 이상 &lt;a href=&quot;perlfunc#defined&quot;&gt;에서 perlfunc의 &quot;defined&quot;를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="be047f864fccecb4801e21c3ca26d33faa969dbf" translate="yes" xml:space="preserve">
          <source>The sign &lt;code&gt;/^[+-]$/&lt;/code&gt; is stored separately. The string 'NaN' is used to represent the result when input arguments are not numbers, as well as the result of dividing by zero.</source>
          <target state="translated">&lt;code&gt;/^[+-]$/&lt;/code&gt; 부호 는 별도로 저장됩니다. 문자열 'NaN'은 입력 인수가 숫자가 아닐 때의 결과와 0으로 나눈 결과를 나타내는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="5d535efa9748a7b51984807c3b0e47062fc14e19" translate="yes" xml:space="preserve">
          <source>The sign is either '+', '-', 'NaN', '+inf' or '-inf' and stored separately. You can access it with the sign() method.</source>
          <target state="translated">부호는 '+', '-', 'NaN', '+ inf'또는 '-inf'이며 별도로 저장됩니다. sign () 메소드로 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="be8bba598ba0bfbad37b038eb92c99bbb5b687ac" translate="yes" xml:space="preserve">
          <source>The sign is either '+', '-', 'NaN', '+inf' or '-inf'.</source>
          <target state="translated">부호는 '+', '-', 'NaN', '+ inf'또는 '-inf'입니다.</target>
        </trans-unit>
        <trans-unit id="32ee9fc8e75a1189426734a34b70183ae0bf5e08" translate="yes" xml:space="preserve">
          <source>The sign is either '+', '-', 'NaN', '+inf' or '-inf'. You can access it with the sign() method.</source>
          <target state="translated">부호는 '+', '-', 'NaN', '+ inf'또는 '-inf'입니다. sign () 메소드로 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="11646904ceab245420048654e9bde4a41bb7ec59" translate="yes" xml:space="preserve">
          <source>The signal Exec signal mask</source>
          <target state="translated">Signal Exec 신호 마스크</target>
        </trans-unit>
        <trans-unit id="104ebb4db613ce634a3b75383995774c2e797f04" translate="yes" xml:space="preserve">
          <source>The signature declares lexical variables that are in scope for the block. When the subroutine is called, the signature takes control first. It populates the signature variables from the list of arguments that were passed. If the argument list doesn't meet the requirements of the signature, then it will throw an exception. When the signature processing is complete, control passes to the block.</source>
          <target state="translated">서명은 블록 범위에있는 어휘 변수를 선언합니다. 서브 루틴이 호출되면 서명이 먼저 제어합니다. 전달 된 인수 목록에서 서명 변수를 채 웁니다. 인수 목록이 서명의 요구 사항을 충족하지 않으면 예외가 발생합니다. 서명 처리가 완료되면 제어가 블록으로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="1d781ab42c79199084a9c305d1ab2ed6d80e787b" translate="yes" xml:space="preserve">
          <source>The signature is part of a subroutine's body. Normally the body of a subroutine is simply a braced block of code, but when using a signature, the signature is a parenthesised list that goes immediately before the block, after any name or attributes.</source>
          <target state="translated">서명은 서브 루틴 본문의 일부입니다. 일반적으로 서브 루틴의 본문은 중괄호로 묶인 코드 블록이지만 서명을 사용할 때 서명은 블록 바로 앞, 이름 또는 속성 뒤에 괄호로 묶인 목록입니다.</target>
        </trans-unit>
        <trans-unit id="d68142e064ec1d6e704c7c13d44f8b02e77345ce" translate="yes" xml:space="preserve">
          <source>The signature is part of a subroutine's body. Normally the body of a subroutine is simply a braced block of code. When using a signature, the signature is a parenthesised list that goes immediately after the subroutine name. The signature declares lexical variables that are in scope for the block. When the subroutine is called, the signature takes control first. It populates the signature variables from the list of arguments that were passed. If the argument list doesn't meet the requirements of the signature, then it will throw an exception. When the signature processing is complete, control passes to the block.</source>
          <target state="translated">서명은 서브 루틴 본문의 일부입니다. 일반적으로 서브 루틴의 본문은 단순한 코드 블록입니다. 서명을 사용할 때 서명은 서브 루틴 이름 바로 뒤에 오는 괄호로 묶은 목록입니다. 서명은 블록 범위에있는 어휘 변수를 선언합니다. 서브 루틴이 호출되면 서명이 먼저 제어됩니다. 전달 된 인수 목록에서 서명 변수를 채 웁니다. 인수 목록이 서명의 요구 사항을 충족하지 않으면 예외가 발생합니다. 서명 처리가 완료되면 제어가 블록으로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="8bf79dd34df166da1a0a362d8a7c14bc52139481" translate="yes" xml:space="preserve">
          <source>The signatures feature is experimental</source>
          <target state="translated">서명 기능은 실험적입니다.</target>
        </trans-unit>
        <trans-unit id="ebf9d6090863be01051258238bf3ef2c8b46c7c9" translate="yes" xml:space="preserve">
          <source>The significance of each of these will be explained in the rest of the tutorial, but for now, it is important only to know that a metacharacter can be matched as-is by putting a backslash before it:</source>
          <target state="translated">이들 각각의 중요성은 튜토리얼의 나머지 부분에서 설명 할 것이지만, 지금은 메타 문자 앞에 백 슬래시를 두어있는 그대로 일치시킬 수 있다는 것을 아는 것이 중요합니다.</target>
        </trans-unit>
        <trans-unit id="2444d6c2a6baf7e1580c4abcb9b61735a0532f35" translate="yes" xml:space="preserve">
          <source>The significance of each of these will be explained in the rest of the tutorial, but for now, it is important only to know that a metacharacter can be matched by putting a backslash before it:</source>
          <target state="translated">이들 각각의 의미는 나머지 자습서에서 설명하지만 지금은 메타 문자를 백 슬래시 앞에 두어 일치시킬 수 있다는 것을 아는 것이 중요합니다.</target>
        </trans-unit>
        <trans-unit id="d05188639d7fd13d368b039de9eab91f22380450" translate="yes" xml:space="preserve">
          <source>The similarly named property, &lt;code&gt;\p{Punct}&lt;/code&gt; , matches a somewhat different set in the ASCII range, namely &lt;code&gt;[-!&quot;#%&amp;amp;'()*,./:;?@[\\\]_{}]&lt;/code&gt; . That is, it is missing the nine characters &lt;code&gt;[$+&amp;lt;=&amp;gt;^`|~]&lt;/code&gt; . This is because Unicode splits what POSIX considers to be punctuation into two categories, Punctuation and Symbols.</source>
          <target state="translated">비슷한 이름의 &lt;code&gt;\p{Punct}&lt;/code&gt; 속성 은 ASCII 범위의 다소 다른 세트, 즉 &lt;code&gt;[-!&quot;#%&amp;amp;'()*,./:;?@[\\\]_{}]&lt;/code&gt; ,. / :; @ [\\\] _ {}] 과 일치합니다 . 즉, 9 개의 문자 &lt;code&gt;[$+&amp;lt;=&amp;gt;^`|~]&lt;/code&gt; . 이것은 POSIX가 문장 부호로 간주하는 것을 문장 부호와 기호의 두 범주로 나누기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="8cd091ac264b3ba5cf264f4cd380086afff2aabf" translate="yes" xml:space="preserve">
          <source>The similarly named property, &lt;code&gt;\p{Punct}&lt;/code&gt;, matches a somewhat different set in the ASCII range, namely &lt;code&gt;[-!&quot;#%&amp;amp;'()*,./:;?@[\\\]_{}]&lt;/code&gt;. That is, it is missing the nine characters &lt;code&gt;[$+&amp;lt;=&amp;gt;^`|~]&lt;/code&gt;. This is because Unicode splits what POSIX considers to be punctuation into two categories, Punctuation and Symbols.</source>
          <target state="translated">비슷한 이름의 속성 &lt;code&gt;\p{Punct}&lt;/code&gt; 는 ASCII 범위의 다소 다른 집합, 즉 &lt;code&gt;[-!&quot;#%&amp;amp;'()*,./:;?@[\\\]_{}]&lt;/code&gt; ,. / :;? @ [\\\] _ {}] 와 일치합니다 . 즉, 9 개의 문자 &lt;code&gt;[$+&amp;lt;=&amp;gt;^`|~]&lt;/code&gt; 가 누락되었습니다 . 이는 유니 코드가 POSIX가 구두점으로 간주하는 것을 구두점과 기호의 두 범주로 분리하기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="a851643ae5a58ccc6f3ce68bfdab3a7ef68d1794" translate="yes" xml:space="preserve">
          <source>The simple rule is: Inheritance will not work when autoloading non-methods. The simple fix for old code is: In any module that used to depend on inheriting &lt;code&gt;AUTOLOAD&lt;/code&gt; for non-methods from a base class named &lt;code&gt;BaseClass&lt;/code&gt; , execute &lt;code&gt;*AUTOLOAD = \&amp;amp;BaseClass::AUTOLOAD&lt;/code&gt; during startup.</source>
          <target state="translated">간단한 규칙은 다음과 같습니다. 비 메소드를 자동로드 할 때 상속이 작동하지 않습니다. 이전 코드에 대한 간단한 수정 사항은 다음과 같습니다. &lt;code&gt;BaseClass&lt;/code&gt; 라는 기본 클래스에서 메소드가 아닌 메소드에 대한 &lt;code&gt;AUTOLOAD&lt;/code&gt; 상속에 의존하는 데 사용한 모든 모듈 에서 시작 중에 &lt;code&gt;*AUTOLOAD = \&amp;amp;BaseClass::AUTOLOAD&lt;/code&gt; 실행하십시오 .</target>
        </trans-unit>
        <trans-unit id="145065cb1f22a69e2ed6682015cb7947554b75d7" translate="yes" xml:space="preserve">
          <source>The simple rule is: Inheritance will not work when autoloading non-methods. The simple fix for old code is: In any module that used to depend on inheriting &lt;code&gt;AUTOLOAD&lt;/code&gt; for non-methods from a base class named &lt;code&gt;BaseClass&lt;/code&gt;, execute &lt;code&gt;*AUTOLOAD = \&amp;amp;BaseClass::AUTOLOAD&lt;/code&gt; during startup.</source>
          <target state="translated">간단한 규칙은 다음과 같습니다. 비 메소드를 자동로드 할 때 상속이 작동하지 않습니다. 이전 코드에 대한 간단한 수정 사항은 다음과 같습니다. &lt;code&gt;BaseClass&lt;/code&gt; 라는 기본 클래스에서 비 메서드에 대한 &lt;code&gt;AUTOLOAD&lt;/code&gt; 상속에 의존하던 모듈 에서 시작하는 동안 &lt;code&gt;*AUTOLOAD = \&amp;amp;BaseClass::AUTOLOAD&lt;/code&gt; 실행 합니다.</target>
        </trans-unit>
        <trans-unit id="f5af89b6d15a00a979315dfddae0b5f323e4af12" translate="yes" xml:space="preserve">
          <source>The simple rule to remember, if you want to match a literal &lt;code&gt;{&lt;/code&gt; character (U+007B &lt;code&gt;LEFT CURLY BRACKET&lt;/code&gt;) in a regular expression pattern, is to escape each literal instance of it in some way. Generally easiest is to precede it with a backslash, like &lt;code&gt;\{&lt;/code&gt; or enclose it in square brackets (&lt;code&gt;[{]&lt;/code&gt;). If the pattern delimiters are also braces, any matching right brace (&lt;code&gt;}&lt;/code&gt;) should also be escaped to avoid confusing the parser, for example,</source>
          <target state="translated">기억해야 할 간단한 규칙 은 정규 표현식 패턴에서 리터럴 &lt;code&gt;{&lt;/code&gt; 문자 (U + 007B &lt;code&gt;LEFT CURLY BRACKET&lt;/code&gt; ) 를 일치시키려는 경우 어떤 식 으로든 각 리터럴 인스턴스를 이스케이프하는 것입니다. 일반적으로 가장 쉬운 방법은 앞에 백 슬래시 (예 : &lt;code&gt;\{&lt;/code&gt; 하거나 대괄호 ( &lt;code&gt;[{]&lt;/code&gt; )로 묶는 것입니다 . 패턴 구분 기호도 중괄호 인 경우 구문 분석기를 혼동하지 않도록 일치하는 오른쪽 중괄호 ( &lt;code&gt;}&lt;/code&gt; )도 이스케이프해야합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="41d909120b343bfa9af89dc978321448d395292c" translate="yes" xml:space="preserve">
          <source>The simple stdio implementation creates the files</source>
          <target state="translated">간단한 stdio 구현은 파일을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="f2a9e9b7a3c97685eea0b1595b9417bb605f6809" translate="yes" xml:space="preserve">
          <source>The simplest XSUBs consist of 3 parts: a description of the return value, the name of the XSUB routine and the names of its arguments, and a description of types or formats of the arguments.</source>
          <target state="translated">가장 단순한 XSUB는 리턴 값 설명, XSUB 루틴 이름 및 인수 이름, 인수 유형 또는 형식에 대한 설명의 세 부분으로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="5cfe5e43e01ddc5838feef9195e0126bb74ada96" translate="yes" xml:space="preserve">
          <source>The simplest case is integers. These consist of a sequence of digits, with an optional sign in front. The digits we can represent with &lt;code&gt;\d+&lt;/code&gt; and the sign can be matched with &lt;code&gt;[+-]&lt;/code&gt; . Thus the integer regexp is</source>
          <target state="translated">가장 간단한 경우는 정수입니다. 선택적인 부호가 앞에있는 일련의 숫자로 구성됩니다. &lt;code&gt;\d+&lt;/code&gt; 나타낼 수있는 숫자 와 부호는 &lt;code&gt;[+-]&lt;/code&gt; 와 일치 할 수 있습니다 . 따라서 정수 정규 표현식은</target>
        </trans-unit>
        <trans-unit id="16ed7663dd31b0d719b95952e4dbcc002ac1e075" translate="yes" xml:space="preserve">
          <source>The simplest case is integers. These consist of a sequence of digits, with an optional sign in front. The digits we can represent with &lt;code&gt;\d+&lt;/code&gt; and the sign can be matched with &lt;code&gt;[+-]&lt;/code&gt;. Thus the integer regexp is</source>
          <target state="translated">가장 간단한 경우는 정수입니다. 이 숫자는 앞에 선택적 기호가있는 일련의 숫자로 구성됩니다. &lt;code&gt;\d+&lt;/code&gt; 표현할 수있는 숫자 와 기호는 &lt;code&gt;[+-]&lt;/code&gt; 와 일치시킬 수 있습니다 . 따라서 정수 정규식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f5ce4a00629ba2eb87550ae04e313683cd18e39d" translate="yes" xml:space="preserve">
          <source>The simplest format for a Version Range is just the version number itself, e.g. &lt;code&gt;2.4&lt;/code&gt;. This means that &lt;b&gt;at least&lt;/b&gt; version 2.4 must be present. To indicate that &lt;b&gt;any&lt;/b&gt; version of a prerequisite is okay, even if the prerequisite doesn't define a version at all, use the version &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">버전 범위의 가장 간단한 형식은 버전 번호 자체입니다 (예 : &lt;code&gt;2.4&lt;/code&gt; ) . 이는 &lt;b&gt;최소한&lt;/b&gt; 버전 2.4가 있어야 함을 의미합니다 . 전제 조건이 버전을 전혀 정의하지 않더라도 &lt;b&gt;모든&lt;/b&gt; 버전의 전제 조건이 괜찮음 을 나타내려면 버전 &lt;code&gt;0&lt;/code&gt; 을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="205579583087d3f83514fed292a979acc1fd2056" translate="yes" xml:space="preserve">
          <source>The simplest format for a version specification is just the version number itself, e.g. &lt;code&gt;2.4&lt;/code&gt;. This means that &lt;b&gt;at least&lt;/b&gt; version 2.4 must be present. To indicate that &lt;b&gt;any&lt;/b&gt; version of a prerequisite is okay, even if the prerequisite doesn't define a version at all, use the version &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">버전 사양의 가장 간단한 형식은 버전 번호 자체입니다 (예 : &lt;code&gt;2.4&lt;/code&gt; ) . 이는 &lt;b&gt;최소한&lt;/b&gt; 버전 2.4가 있어야 함을 의미합니다 . 전제 조건이 버전을 전혀 정의하지 않더라도 &lt;b&gt;모든&lt;/b&gt; 버전의 전제 조건이 괜찮음 을 나타내려면 버전 &lt;code&gt;0&lt;/code&gt; 을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="90f647a57152f0376dead3744742f9e10945d73a" translate="yes" xml:space="preserve">
          <source>The simplest method uses the &lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf&lt;/a&gt;&lt;/code&gt; function. It can pad on the left or right with blanks and on the left with zeroes and it will not truncate the result. The &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; function can only pad strings on the right with blanks and it will truncate the result to a maximum length of &lt;code&gt;$pad_len&lt;/code&gt; .</source>
          <target state="translated">가장 간단한 방법은 &lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf&lt;/a&gt;&lt;/code&gt; 함수를 사용합니다 . 왼쪽 또는 오른쪽을 공백으로 채우고 왼쪽을 0으로 채울 수 있으며 결과가 잘리지 않습니다. &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; 기능은 패드 공백으로 오른쪽에 문자열과 그것의 최대 길이로 결과를 자릅니다 수 &lt;code&gt;$pad_len&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="60ef9faadf39e8b6092ce866661076ad7721c8c1" translate="yes" xml:space="preserve">
          <source>The simplest method uses the &lt;code&gt;sprintf&lt;/code&gt; function. It can pad on the left or right with blanks and on the left with zeroes and it will not truncate the result. The &lt;code&gt;pack&lt;/code&gt; function can only pad strings on the right with blanks and it will truncate the result to a maximum length of &lt;code&gt;$pad_len&lt;/code&gt;.</source>
          <target state="translated">가장 간단한 방법은 &lt;code&gt;sprintf&lt;/code&gt; 함수를 사용합니다 . 왼쪽 또는 오른쪽은 공백으로 채우고 왼쪽은 0으로 채울 수 있으며 결과를 자르지 않습니다. &lt;code&gt;pack&lt;/code&gt; 기능은 패드 공백으로 오른쪽에 문자열과 그것의 최대 길이로 결과를 자릅니다 수 &lt;code&gt;$pad_len&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cc3e208a9819c2ed872df1040ec4eed39730cc50" translate="yes" xml:space="preserve">
          <source>The simplest regex is simply a word, or more generally, a string of characters. A regex consisting of a word matches any string that contains that word:</source>
          <target state="translated">가장 간단한 정규식은 단순히 단어 또는 더 일반적으로 문자열입니다. 단어로 구성된 정규식은 해당 단어가 포함 된 모든 문자열과 일치합니다.</target>
        </trans-unit>
        <trans-unit id="e7349953e0f225a36578668e9ad5be25a2093d5b" translate="yes" xml:space="preserve">
          <source>The simplest regexp is simply a word, or more generally, a string of characters. A regexp consisting of a word matches any string that contains that word:</source>
          <target state="translated">가장 간단한 정규 표현식은 단순히 단어 또는 더 일반적으로 문자열입니다. 단어로 구성된 정규 표현식은 해당 단어가 포함 된 모든 문자열과 일치합니다.</target>
        </trans-unit>
        <trans-unit id="0eaf5ad324e3121e2a83d8b08987e28055dbf879" translate="yes" xml:space="preserve">
          <source>The simplest regexp is simply a word, or more generally, a string of characters. A regexp consisting of just a word matches any string that contains that word:</source>
          <target state="translated">가장 간단한 정규식은 단순히 단어이거나보다 일반적으로 문자열입니다. 단어만으로 구성된 정규 표현식은 해당 단어를 포함하는 모든 문자열과 일치합니다.</target>
        </trans-unit>
        <trans-unit id="f93ecdae42936826d9c1b25b5229a95d439104b0" translate="yes" xml:space="preserve">
          <source>The simplest style of bundling can be enabled with:</source>
          <target state="translated">가장 간단한 번들링 스타일은 다음을 사용하여 활성화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7cd479644d912e323fa369ec3403c930944ff04b" translate="yes" xml:space="preserve">
          <source>The simplest two-level data structure to build in Perl is an array of arrays, sometimes casually called a list of lists. It's reasonably easy to understand, and almost everything that applies here will also be applicable later on with the fancier data structures.</source>
          <target state="translated">Perl에서 빌드하는 가장 간단한 2 단계 데이터 구조는 배열의 배열이며, 때로는 목록 목록이라고도합니다. 합리적으로 이해하기 쉽고 여기에 적용되는 거의 모든 것이 나중에 더 멋진 데이터 구조로 적용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6e9b91e3cec9f10bb3ce35088b75f0be6c8e9b0d" translate="yes" xml:space="preserve">
          <source>The simplest type of op structure is &lt;code&gt;OP&lt;/code&gt; : this has no children. Unary operators, &lt;code&gt;UNOP&lt;/code&gt; s, have one child, and this is pointed to by the &lt;code&gt;op_first&lt;/code&gt; field. Binary operators (&lt;code&gt;BINOP&lt;/code&gt; s) have not only an &lt;code&gt;op_first&lt;/code&gt; field but also an &lt;code&gt;op_last&lt;/code&gt; field. The most complex type of op is a &lt;code&gt;LISTOP&lt;/code&gt; , which has any number of children. In this case, the first child is pointed to by &lt;code&gt;op_first&lt;/code&gt; and the last child by &lt;code&gt;op_last&lt;/code&gt; . The children in between can be found by iteratively following the &lt;code&gt;OpSIBLING&lt;/code&gt; pointer from the first child to the last (but see below).</source>
          <target state="translated">가장 간단한 유형의 op 구조는 &lt;code&gt;OP&lt;/code&gt; 입니다 . 여기에는 자식이 없습니다. 단항 연산자 ( &lt;code&gt;UNOP&lt;/code&gt; )에는 자식이 하나 있으며 &lt;code&gt;op_first&lt;/code&gt; 필드 가이를 지적 합니다. 이진 연산자 ( &lt;code&gt;BINOP&lt;/code&gt; )에는 &lt;code&gt;op_first&lt;/code&gt; 필드뿐만 아니라 &lt;code&gt;op_last&lt;/code&gt; 필드도 있습니다. 가장 복잡한 유형의 op는 &lt;code&gt;LISTOP&lt;/code&gt; 이며 많은 수의 자식이 있습니다. 이 경우 첫 번째 자식은 &lt;code&gt;op_first&lt;/code&gt; 로 가리 킵니다. 로, 마지막 자식은 &lt;code&gt;op_last&lt;/code&gt; 로 가리 킵니다 . 그 사이의 자식은 첫 번째 자식에서 마지막 자식까지 &lt;code&gt;OpSIBLING&lt;/code&gt; 포인터를 반복적으로 따라 가면서 찾을 수 있습니다 (아래 참조).</target>
        </trans-unit>
        <trans-unit id="ffb373ae1dc958f6e57c2a91fb253380e617f734" translate="yes" xml:space="preserve">
          <source>The simplest type of op structure is &lt;code&gt;OP&lt;/code&gt;: this has no children. Unary operators, &lt;code&gt;UNOP&lt;/code&gt;s, have one child, and this is pointed to by the &lt;code&gt;op_first&lt;/code&gt; field. Binary operators (&lt;code&gt;BINOP&lt;/code&gt;s) have not only an &lt;code&gt;op_first&lt;/code&gt; field but also an &lt;code&gt;op_last&lt;/code&gt; field. The most complex type of op is a &lt;code&gt;LISTOP&lt;/code&gt;, which has any number of children. In this case, the first child is pointed to by &lt;code&gt;op_first&lt;/code&gt; and the last child by &lt;code&gt;op_last&lt;/code&gt;. The children in between can be found by iteratively following the &lt;code&gt;OpSIBLING&lt;/code&gt; pointer from the first child to the last (but see below).</source>
          <target state="translated">가장 간단한 유형의 op 구조는 &lt;code&gt;OP&lt;/code&gt; 입니다 . 여기에는 자식이 없습니다. 단항 연산자 &lt;code&gt;UNOP&lt;/code&gt; 에는 자식이 하나 있으며 이것은 &lt;code&gt;op_first&lt;/code&gt; 필드 에서 가리 킵니다 . 이진 연산자 ( &lt;code&gt;BINOP&lt;/code&gt; )에는 &lt;code&gt;op_first&lt;/code&gt; 필드뿐만 아니라 &lt;code&gt;op_last&lt;/code&gt; 필드도 있습니다. 가장 복잡한 유형의 op는 자식 수에 관계없이 &lt;code&gt;LISTOP&lt;/code&gt; 입니다. 이 경우 첫 번째 자식은 &lt;code&gt;op_first&lt;/code&gt; 로 가리키고 마지막 자식은 &lt;code&gt;op_last&lt;/code&gt; 로 가리 킵니다 . 그 사이의 자식은 첫 번째 자식에서 마지막 자식까지 &lt;code&gt;OpSIBLING&lt;/code&gt; 포인터를 반복적으로 따라 가면 찾을 수 있습니다 (아래 참조).</target>
        </trans-unit>
        <trans-unit id="48570eadf16f561f7ed2c5fd05e1b77f1b97a0a9" translate="yes" xml:space="preserve">
          <source>The simplest way to build up a decent testing suite is to just test what the manual says it does. [3] Let's pull something out of the &lt;a href=&quot;Date::ICal#SYNOPSIS&quot;&gt;&quot;SYNOPSIS&quot; in Date::ICal&lt;/a&gt; and test that all its bits work.</source>
          <target state="translated">괜찮은 테스트 스위트를 구축하는 가장 간단한 방법은 매뉴얼이 말하는대로 테스트하는 것입니다. [3] &lt;a href=&quot;Date::ICal#SYNOPSIS&quot;&gt;Date :: ICal&lt;/a&gt; 의 &quot;SYNOPSIS&quot;에서 무언가를 꺼내 모든 비트가 작동하는지 테스트 해 보겠습니다 .</target>
        </trans-unit>
        <trans-unit id="2054b09e7b3505e051c925e118baa9402ac5d4ec" translate="yes" xml:space="preserve">
          <source>The simplest way to do this is:</source>
          <target state="translated">이를 수행하는 가장 간단한 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="388dab005124e81f16d269b4ee944aa3b8003908" translate="yes" xml:space="preserve">
          <source>The simplest way to use this library is to import the md5_hex() function (or one of its cousins):</source>
          <target state="translated">이 라이브러리를 사용하는 가장 간단한 방법은 md5_hex () 함수 (또는 그 사촌 중 하나)를 가져 오는 것입니다.</target>
        </trans-unit>
        <trans-unit id="5ecd63cfa076538859f9d50a754ce0ea42b734ec" translate="yes" xml:space="preserve">
          <source>The simplest, most straightforward way to create a thread is with &lt;code&gt;create()&lt;/code&gt; :</source>
          <target state="translated">스레드를 만드는 가장 간단하고 간단한 방법은 &lt;code&gt;create()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="aedaa034bc02c59e2080c491aee6d14703ba3b58" translate="yes" xml:space="preserve">
          <source>The simplest, most straightforward way to create a thread is with &lt;code&gt;create()&lt;/code&gt;:</source>
          <target state="translated">스레드를 만드는 가장 간단하고 직접적인 방법은 &lt;code&gt;create()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="142891f6dfc36054413e16ddc5cd0b102274ac48" translate="yes" xml:space="preserve">
          <source>The single parameter &lt;code&gt;cb1&lt;/code&gt; is a pointer to a function, so you must have defined &lt;code&gt;cb1&lt;/code&gt; in your code, say something like this</source>
          <target state="translated">단일 매개 변수 &lt;code&gt;cb1&lt;/code&gt; 은 함수에 대한 포인터이므로 정의해야합니다. &lt;code&gt;cb1&lt;/code&gt; 코드에서 cb1 을</target>
        </trans-unit>
        <trans-unit id="c390613e0b451f9ebc65ddd44ea3f2cbf88c23f5" translate="yes" xml:space="preserve">
          <source>The situation in which an &lt;b&gt;expression&lt;/b&gt; is expected by its surroundings (the code calling it) to return a list of values rather than a single value. Functions that want a</source>
          <target state="translated">의 상황 &lt;b&gt;&lt;/b&gt;주변 환경 (코드를 호출하는 코드)에서 단일 값이 아닌 값 목록을 반환&lt;b&gt; 식이&lt;/b&gt; 예상되는 . 원하는 기능</target>
        </trans-unit>
        <trans-unit id="d86701b02acab027c0d49bd429316b14b358d71d" translate="yes" xml:space="preserve">
          <source>The situation in which an &lt;b&gt;expression&lt;/b&gt; is expected by its surroundings (the code calling it) to return a single &lt;b&gt;value&lt;/b&gt; rather than a &lt;b&gt;list&lt;/b&gt; of values. See also &lt;b&gt;context&lt;/b&gt; and &lt;b&gt;list context&lt;/b&gt;. A scalar context sometimes imposes additional constraints on the return value&amp;mdash;see &lt;b&gt;string context&lt;/b&gt; and &lt;b&gt;numeric context&lt;/b&gt;. Sometimes we talk about a &lt;b&gt;Boolean context&lt;/b&gt; inside conditionals, but this imposes no additional constraints, since any scalar value, whether numeric or &lt;b&gt;string&lt;/b&gt;, is already true or false.</source>
          <target state="translated">주변 ( &lt;b&gt;표현식&lt;/b&gt; 코드)에서 &lt;b&gt;표현식&lt;/b&gt; 이 &lt;b&gt;값 &lt;/b&gt;&lt;b&gt;목록&lt;/b&gt; 이 아닌 단일 &lt;b&gt;값&lt;/b&gt; 을 반환 할 것으로 예상되는 상황입니다 . &lt;b&gt;context&lt;/b&gt; 및 &lt;b&gt;list context&lt;/b&gt; 도 참조하십시오 . 스칼라 컨텍스트는 때때로 반환 값에 추가 제약을 부과 &lt;b&gt;합니다 (문자열 컨텍스트&lt;/b&gt; 및 &lt;b&gt;숫자 컨텍스트 참조)&lt;/b&gt; . 때로는 조건부 내부 의 &lt;b&gt;부울 컨텍스트&lt;/b&gt; 에 대해 이야기 하지만 numeric 또는 &lt;b&gt;string&lt;/b&gt; 스칼라 값 이 이미 true 또는 false 이므로 스칼라 값이 추가로 적용되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="5bf519df1d56695e3fe7b5f2cac71014a6a10291" translate="yes" xml:space="preserve">
          <source>The situation in which an expression is expected by its surroundings (the code calling it) to return a &lt;b&gt;string&lt;/b&gt;. See also &lt;b&gt;context&lt;/b&gt; and &lt;b&gt;numeric context&lt;/b&gt;.</source>
          <target state="translated">주변 (코드를 호출하는 코드)에서 표현식이 &lt;b&gt;문자열&lt;/b&gt; 을 리턴 할 것으로 예상되는 상황입니다 . 도 참조 &lt;b&gt;컨텍스트&lt;/b&gt; 및&lt;b&gt; numeric context&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="d5278b812a3307d0ee6951ce2678ae1eab81add9" translate="yes" xml:space="preserve">
          <source>The situation in which an expression is expected by its surroundings (the code calling it) to return a number. See also &lt;b&gt;context&lt;/b&gt; and &lt;b&gt;string context&lt;/b&gt;.</source>
          <target state="translated">주변 (코드를 호출하는 코드)에서 표현식이 숫자를 반환 할 것으로 예상되는 상황입니다. &lt;b&gt;context&lt;/b&gt; 및 &lt;b&gt;string context&lt;/b&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="1778a01cc57bbb1bfba8f72e778c79445c3a36bf" translate="yes" xml:space="preserve">
          <source>The situation is even less clear for tools such as MakeMaker that can be used to install additional modules into non-standard places. For example, if a user intends to install a module into a private directory (perhaps by setting &lt;code&gt;PREFIX&lt;/code&gt; on the</source>
          <target state="translated">비표준 장소에 추가 모듈을 설치하는 데 사용할 수있는 MakeMaker와 같은 도구의 경우 상황이 훨씬 명확하지 않습니다. 예를 들어, 사용자가 개인 디렉토리에 모듈을 설치하려는 경우 (아마도 &lt;code&gt;PREFIX&lt;/code&gt; 를</target>
        </trans-unit>
        <trans-unit id="9a9c38132104cf7801e22419b38670f4a24614fb" translate="yes" xml:space="preserve">
          <source>The situation where this is necessary, is presumably quite rare.</source>
          <target state="translated">이것이 필요한 상황은 아마도 매우 드 rare니다.</target>
        </trans-unit>
        <trans-unit id="5a9a5af0a6298739507c5ced21852b79711a0a57" translate="yes" xml:space="preserve">
          <source>The situation with matching Unicode properties in regular expressions, the &lt;code&gt;\p{}&lt;/code&gt; and &lt;code&gt;\P{}&lt;/code&gt; constructs, against these code points is not as clear cut, and how these are handled has changed as we've gained experience.</source>
          <target state="translated">정규식에서 일치하는 유니 코드 속성 인 &lt;code&gt;\p{}&lt;/code&gt; 및 &lt;code&gt;\P{}&lt;/code&gt; 이러한 코드 포인트에 대해 구문 은 명확하지 않으며 경험을 통해 이러한 방식을 처리하는 방식이 변경되었습니다.</target>
        </trans-unit>
        <trans-unit id="88e6088a9ab77ba2f6a1ec54ad364f7fffa87f43" translate="yes" xml:space="preserve">
          <source>The size of the file will be determined, and sent to the server automatically for normal files so that this method need only be called if you are transferring data from a socket, named pipe, or other stream not associated with a normal file.</source>
          <target state="translated">파일의 크기가 결정되고 일반 파일을 위해 서버로 자동 전송되므로 소켓, 명명 된 파이프 또는 일반 파일과 관련되지 않은 다른 스트림에서 데이터를 전송하는 경우에만이 메소드를 호출하면됩니다.</target>
        </trans-unit>
        <trans-unit id="87d9309a72cdac9a52fd9593050f47fe997d18b5" translate="yes" xml:space="preserve">
          <source>The size of the per-instance data structure, e.g.:</source>
          <target state="translated">인스턴스 별 데이터 구조의 크기는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="52d0fd0e1a020955cbd4dc92e53211189e24cb93" translate="yes" xml:space="preserve">
          <source>The size of the perlXYZ.SIS is about 370 kB but once it is in the device it is about one 750 kB (according to the application manager).</source>
          <target state="translated">perlXYZ.SIS의 크기는 약 370kB이지만 일단 장치에 있으면 약 750kB입니다 (응용 프로그램 관리자에 따름).</target>
        </trans-unit>
        <trans-unit id="5877446a070972ed92cd79aed206f27b2111d714" translate="yes" xml:space="preserve">
          <source>The size of the pieces you&amp;rsquo;re dealing with, mentally speaking.</source>
          <target state="translated">다루고있는 작품의 크기, 정신적으로 말하면.</target>
        </trans-unit>
        <trans-unit id="1656b4f2fdda6835a902c9679ea0caaf9c6c13e1" translate="yes" xml:space="preserve">
          <source>The size specifier &lt;code&gt;V&lt;/code&gt; has no effect for Perl code, but is supported for compatibility with XS code. It means &quot;use the standard size for a Perl integer or floating-point number&quot;, which is the default.</source>
          <target state="translated">사이즈 지정자 &lt;code&gt;V&lt;/code&gt; 는 Perl 코드에는 영향을 미치지 않지만 XS 코드와의 호환성을 위해 지원됩니다. &quot;Perl 정수 또는 부동 소수점 숫자에 표준 크기 사용&quot;을 의미합니다. 이것이 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="0b86c8f6fcdbd6b3e5e7fca2359cdc4a25ce8c43" translate="yes" xml:space="preserve">
          <source>The skipped prefix (i.e. the characters before the extracted string). On failure, &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; is returned.</source>
          <target state="translated">생략 된 접두사 (예 : 추출 된 문자열 앞의 문자) 실패하면 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="954e32bdd5f83008c8f605b9e8dd386da5c77fb4" translate="yes" xml:space="preserve">
          <source>The skipped prefix (i.e. the characters before the extracted string). On failure, &lt;code&gt;undef&lt;/code&gt; is returned.</source>
          <target state="translated">건너 뛴 접두사 (즉, 추출 된 문자열 앞의 문자). 실패하면 &lt;code&gt;undef&lt;/code&gt; 가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="20ee3229175e42949ed9e43940ba571b504d8485" translate="yes" xml:space="preserve">
          <source>The slab allocator puts the ops at the end of the slab first. This will tend to allocate the leaves of the op tree first, and the layout will therefore hopefully be cache-friendly. In addition, this means that there's no need to store the size of the slab (see below on why slabs vary in size), because Perl can follow pointers to find the last op.</source>
          <target state="translated">slab 할당자는 먼저 slab 끝에 ops를 넣습니다. 이것은 op 트리의 잎을 먼저 할당하는 경향이 있으며 따라서 레이아웃이 캐시 친화적 일 것입니다. 또한 Perl은 포인터를 따라 마지막 작업을 찾을 수 있기 때문에 슬래브의 크기를 저장할 필요가 없습니다 (슬래브 크기가 다른 이유는 아래 참조).</target>
        </trans-unit>
        <trans-unit id="cca8448b9d4d7f08ec6d38447f60e1a5ccb09b43" translate="yes" xml:space="preserve">
          <source>The slower but superior fixes are when you may be able to yourself fix the misconfiguration of your own environment variables. The mis(sing)configuration of the whole system's locales usually requires the help of your friendly system administrator.</source>
          <target state="translated">느리지 만 뛰어난 수정은 환경 변수의 잘못된 구성을 직접 수정할 수있는 경우입니다. 전체 시스템 로케일의 잘못된 구성은 대개 친숙한 시스템 관리자의 도움이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="0fbe962e06d42462e7c0e18bd04f3db25354c94a" translate="yes" xml:space="preserve">
          <source>The smaller and more localized the change, the better. Similarly, a series of small patches is greatly preferred over a single large patch.</source>
          <target state="translated">변경 사항이 작고 지역화 될수록 좋습니다. 마찬가지로 일련의 작은 패치가 하나의 큰 패치보다 선호됩니다.</target>
        </trans-unit>
        <trans-unit id="f4b9fc3a5444ff6c99460c86f0eae40188849994" translate="yes" xml:space="preserve">
          <source>The smallest individual element of a string. Computers store characters as integers, but Perl lets you operate on them as text. The integer used to represent a particular character is called that character&amp;rsquo;s &lt;b&gt;codepoint&lt;/b&gt;.</source>
          <target state="translated">문자열의 가장 작은 개별 요소. 컴퓨터는 문자를 정수로 저장하지만 Perl을 사용하면 문자를 텍스트로 조작 할 수 있습니다. 특정 문자를 나타내는 데 사용되는 정수를 해당 문자의 &lt;b&gt;codepoint&lt;/b&gt; 라고합니다 .</target>
        </trans-unit>
        <trans-unit id="743692cb1b17807cb7e732ecae2c349fdebd6008" translate="yes" xml:space="preserve">
          <source>The smart match stops when it finds a match, so it doesn't have to try every expression.</source>
          <target state="translated">일치하는 것을 찾으면 스마트 일치가 중지되므로 모든 표현을 시도 할 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="936144db8d649469afd4d348dac4550c6a90cbd0" translate="yes" xml:space="preserve">
          <source>The smartmatch implicitly dereferences any non-blessed hash or array reference, so the &lt;code&gt;&lt;i&gt;HASH&lt;/i&gt;&lt;/code&gt; and &lt;code&gt;&lt;i&gt;ARRAY&lt;/i&gt;&lt;/code&gt; entries apply in those cases. For blessed references, the &lt;code&gt;&lt;i&gt;Object&lt;/i&gt;&lt;/code&gt; entries apply. Smartmatches involving hashes only consider hash keys, never hash values.</source>
          <target state="translated">스마트 매치는 암시되지 않은 해시 또는 배열 참조를 암시 적으로 역 참조하므로 이러한 경우 &lt;code&gt;&lt;i&gt;HASH&lt;/i&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;i&gt;ARRAY&lt;/i&gt;&lt;/code&gt; 항목이 적용됩니다. 축복받은 참고 문헌의 경우, &lt;code&gt;&lt;i&gt;Object&lt;/i&gt;&lt;/code&gt; 항목이 적용됩니다. 해시와 관련된 스마트 매치는 해시 키만 고려하고 값을 해시하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d02f6728ba4dcd43d024dc500f10ccfe28692eeb" translate="yes" xml:space="preserve">
          <source>The smartmatch operator is most often used as the implicit operator of a &lt;code&gt;when&lt;/code&gt; clause. See the section on &quot;Switch Statements&quot; in &lt;a href=&quot;perlsyn&quot;&gt;perlsyn&lt;/a&gt;.</source>
          <target state="translated">스마트 매치 연산자는 대부분 &lt;code&gt;when&lt;/code&gt; 절의 암시 적 연산자로 사용됩니다 . &lt;a href=&quot;perlsyn&quot;&gt;perlsyn의&lt;/a&gt; &quot;스위치 설명&quot;섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="1dbe6ac71d39b0bf15f7bc2e7a951d76ec82915a" translate="yes" xml:space="preserve">
          <source>The socket domain will define which subclass of &lt;code&gt;IO::Socket&lt;/code&gt; to use. The two options available along with this distribution are &lt;code&gt;AF_INET&lt;/code&gt; and &lt;code&gt;AF_UNIX&lt;/code&gt;.</source>
          <target state="translated">소켓 도메인은 사용할 &lt;code&gt;IO::Socket&lt;/code&gt; 하위 클래스를 정의 합니다. 이 배포와 함께 사용할 수있는 두 가지 옵션은 &lt;code&gt;AF_INET&lt;/code&gt; 및 &lt;code&gt;AF_UNIX&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="538eac64870e76a04cefadec7560ac9099d4a644" translate="yes" xml:space="preserve">
          <source>The socket tests may fail if the network is not configured. You have to make &quot;/hurd/pfinet&quot; the translator for &quot;/servers/socket/2&quot;, giving it the right arguments. Try &quot;/hurd/pfinet --help&quot; for more information.</source>
          <target state="translated">네트워크가 구성되어 있지 않으면 소켓 테스트에 실패 할 수 있습니다. &quot;/ hurd / pfinet&quot;를 &quot;/ servers / socket / 2&quot;에 대한 번역기로 지정하여 올바른 인수를 제공해야합니다. 자세한 내용은 &quot;/ hurd / pfinet --help&quot;를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="127dbba60bbfba8c121a95d45a5b1267637cec67" translate="yes" xml:space="preserve">
          <source>The socket type (e.g. &lt;code&gt;SOCK_STREAM&lt;/code&gt; )</source>
          <target state="translated">소켓 유형 (예 : &lt;code&gt;SOCK_STREAM&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="efab1ba183171d21de2ceaf72d5458d5f4bc8140" translate="yes" xml:space="preserve">
          <source>The socket type (e.g. &lt;code&gt;SOCK_STREAM&lt;/code&gt;)</source>
          <target state="translated">소켓 유형 (예 : &lt;code&gt;SOCK_STREAM&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="da232edd2d10d943e919b3b650a030d3ad1934c2" translate="yes" xml:space="preserve">
          <source>The socket type that will be used. These are usually &lt;code&gt;SOCK_STREAM&lt;/code&gt;, &lt;code&gt;SOCK_DGRAM&lt;/code&gt;, or &lt;code&gt;SOCK_RAW&lt;/code&gt;. If this argument is left undefined an attempt will be made to infer the type from the service name.</source>
          <target state="translated">사용할 소켓 유형입니다. 일반적으로 &lt;code&gt;SOCK_STREAM&lt;/code&gt; , &lt;code&gt;SOCK_DGRAM&lt;/code&gt; 또는 &lt;code&gt;SOCK_RAW&lt;/code&gt; 입니다. 이 인수가 정의되지 않은 상태로두면 서비스 이름에서 유형을 유추하려고 시도합니다.</target>
        </trans-unit>
        <trans-unit id="5ab88d47102ad5dc69b949fcce35b1a58247bf52" translate="yes" xml:space="preserve">
          <source>The socket type to pass to &lt;code&gt;getaddrinfo&lt;/code&gt; (e.g. &lt;code&gt;SOCK_STREAM&lt;/code&gt;, &lt;code&gt;SOCK_DGRAM&lt;/code&gt;). Normally defined by the caller; if left undefined &lt;code&gt;getaddrinfo&lt;/code&gt; may attempt to infer the type from the service name.</source>
          <target state="translated">&lt;code&gt;getaddrinfo&lt;/code&gt; 에 전달할 소켓 유형 (예 : &lt;code&gt;SOCK_STREAM&lt;/code&gt; , &lt;code&gt;SOCK_DGRAM&lt;/code&gt; ). 일반적으로 호출자가 정의합니다. 정의되지 않은 상태로두면 &lt;code&gt;getaddrinfo&lt;/code&gt; 가 서비스 이름에서 유형을 유추 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d10c516fba6283faccc420f0f1f0ddca597fd882" translate="yes" xml:space="preserve">
          <source>The sole purpose of this module is to enable colour highlighting from the command line.</source>
          <target state="translated">이 모듈의 유일한 목적은 명령 줄에서 색상을 강조 표시하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="165006648b6cdcfa730ff63bd97b9430605a3ca6" translate="yes" xml:space="preserve">
          <source>The solution is to &lt;code&gt;&lt;a href=&quot;../functions/chdir&quot;&gt;chdir&lt;/a&gt;&lt;/code&gt; out of the child directory to a place outside the directory tree to be removed.</source>
          <target state="translated">해결책은 하위 디렉토리 에서 &lt;code&gt;&lt;a href=&quot;../functions/chdir&quot;&gt;chdir&lt;/a&gt;&lt;/code&gt; 을 제거 할 디렉토리 트리 외부에 배치하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="25857c787c988fd69fb48ac1af38665d7f387a1d" translate="yes" xml:space="preserve">
          <source>The solution is to &lt;code&gt;chdir&lt;/code&gt; out of the child directory to a place outside the directory tree to be removed.</source>
          <target state="translated">해결책은 자식 디렉터리에서 제거 할 디렉터리 트리 외부의 위치 로 &lt;code&gt;chdir&lt;/code&gt; 하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="f7391f9903f693d17725f8ae77b7a179797082b4" translate="yes" xml:space="preserve">
          <source>The solution is to use &lt;a href=&quot;perlfunc#__SUB__&quot;&gt;&lt;code&gt;__SUB__&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">해결책은 &lt;a href=&quot;perlfunc#__SUB__&quot;&gt; &lt;code&gt;__SUB__&lt;/code&gt; &lt;/a&gt; 를 사용하는 것입니다 .</target>
        </trans-unit>
        <trans-unit id="8bd1e61d4eb0bbe0f75b3581782eef3e8dfaf4b4" translate="yes" xml:space="preserve">
          <source>The sort of characters we put into words. In Unicode, this is all letters including all ideographs and certain diacritics, letter numbers like Roman numerals, and various combining marks.</source>
          <target state="translated">우리가 단어에 넣는 캐릭터의 종류. 유니 코드에서 이것은 모든 표의 문자 및 분음 부호, 로마 숫자와 같은 문자 번호 및 다양한 결합 표시를 포함한 모든 문자입니다.</target>
        </trans-unit>
        <trans-unit id="a1d44ffc9ae032aff54b02af9e8455f31b34d012" translate="yes" xml:space="preserve">
          <source>The sort order will cause differences between results obtained on ASCII platforms versus EBCDIC platforms. What follows are some suggestions on how to deal with these differences.</source>
          <target state="translated">정렬 순서는 ASCII 플랫폼과 EBCDIC 플랫폼에서 얻은 결과간에 차이가 발생합니다. 다음은 이러한 차이점을 처리하는 방법에 대한 제안입니다.</target>
        </trans-unit>
        <trans-unit id="89da5c4101906ac148b9121db995bfdaa11ef39f" translate="yes" xml:space="preserve">
          <source>The source buffer can either be a scalar or a scalar reference.</source>
          <target state="translated">소스 버퍼는 스칼라 또는 스칼라 참조 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="67687b08f8914b53b7f3846fac38e3b4363d7a5e" translate="yes" xml:space="preserve">
          <source>The source buffer, &lt;code&gt;$source&lt;/code&gt; , can either be a scalar or a scalar reference.</source>
          <target state="translated">소스 버퍼 &lt;code&gt;$source&lt;/code&gt; 는 스칼라 또는 스칼라 참조 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8ca49df053b6c5ef6b6ff31bd8c0aacb4709988b" translate="yes" xml:space="preserve">
          <source>The source buffer, &lt;code&gt;$source&lt;/code&gt;, can either be a scalar or a scalar reference.</source>
          <target state="translated">소스 버퍼 &lt;code&gt;$source&lt;/code&gt; 는 스칼라 또는 스칼라 참조 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1b7e9fa2ae5c5f428ffd5cfef77286b08b69792f" translate="yes" xml:space="preserve">
          <source>The source code for an extension usually resides in its own directory. At least three files are generally provided:</source>
          <target state="translated">확장의 소스 코드는 일반적으로 자체 디렉토리에 있습니다. 일반적으로 3 개 이상의 파일이 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="1e4ee98da0c8794c248be818bce3b87507488dbe" translate="yes" xml:space="preserve">
          <source>The source code includes multiple hash algorithms to choose from. While we believe that the default perl hash is robust to attack, we have included the hash function Siphash as a fall-back option. At the time of release of Perl 5.18.0 Siphash is believed to be of cryptographic strength. This is not the default as it is much slower than the default hash.</source>
          <target state="translated">소스 코드에는 선택할 수있는 여러 해시 알고리즘이 포함되어 있습니다. 우리는 기본 펄 해시가 공격하기에 강력하다고 생각하지만 해시 함수 Siphash를 대체 옵션으로 포함 시켰습니다. Perl 5.18.0의 출시 시점에서 Siphash는 암호화 수준으로 여겨집니다. 기본 해시보다 훨씬 느리므로 기본값이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="7a62a8b0275fb02e9e7293cb89d71dd692b01164" translate="yes" xml:space="preserve">
          <source>The source code is available on Git Hub: &lt;a href=&quot;https://github.com/maddingue/Sys-Syslog/&quot;&gt;https://github.com/maddingue/Sys-Syslog/&lt;/a&gt;</source>
          <target state="translated">소스 코드는 Git Hub에서 사용할 수 있습니다 : &lt;a href=&quot;https://github.com/maddingue/Sys-Syslog/&quot;&gt;https://github.com/maddingue/Sys-Syslog/&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d0caf29be420bbd199849ea512093a83580509aa" translate="yes" xml:space="preserve">
          <source>The source code locations are supported &lt;b&gt;only&lt;/b&gt; if you have the Developer Tools installed. (BFD is &lt;b&gt;not&lt;/b&gt; needed.)</source>
          <target state="translated">소스 코드 위치는 개발자 도구가 설치된 경우 &lt;b&gt;에만&lt;/b&gt; 지원 &lt;b&gt;됩니다&lt;/b&gt; . (BFD는 필요 &lt;b&gt;하지&lt;/b&gt; 않습니다.)</target>
        </trans-unit>
        <trans-unit id="077f75395915a901ad7c5804374f7d2b053abae0" translate="yes" xml:space="preserve">
          <source>The source code repository for HashBase can be found at</source>
          <target state="translated">HashBase의 소스 코드 저장소는 다음 위치에서 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="88b90b5da908771ba4301d860153882353d321fc" translate="yes" xml:space="preserve">
          <source>The source code repository for Test2 can be found at</source>
          <target state="translated">Test2의 소스 코드 저장소는 다음 위치에서 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="edb2a3de91b362ca2b61febe5041a5a32501556d" translate="yes" xml:space="preserve">
          <source>The source code repository for Test::More can be found at</source>
          <target state="translated">Test :: More의 소스 코드 저장소는 다음에서 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cf7f81d91f75175f1d8405190d2d3c385759d791" translate="yes" xml:space="preserve">
          <source>The source code repository for Time-Local can be found at &lt;a href=&quot;https://github.com/houseabsolute/Time-Local&quot;&gt;https://github.com/houseabsolute/Time-Local&lt;/a&gt;.</source>
          <target state="translated">Time-Local의 소스 코드 저장소는 &lt;a href=&quot;https://github.com/houseabsolute/Time-Local&quot;&gt;https://github.com/houseabsolute/Time-Local&lt;/a&gt; 에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="449ffcdb319b9addd8fd6dc6fc9226340b95b72f" translate="yes" xml:space="preserve">
          <source>The source filter distribution includes two modules that simplify this task: &lt;code&gt;Filter::exec&lt;/code&gt; and &lt;code&gt;Filter::sh&lt;/code&gt; . Both allow you to run any external executable. Both use a coprocess to control the flow of data into and out of the external executable. (For details on coprocesses, see Stephens, W.R., &quot;Advanced Programming in the UNIX Environment.&quot; Addison-Wesley, ISBN 0-210-56317-7, pages 441-445.) The difference between them is that &lt;code&gt;Filter::exec&lt;/code&gt; spawns the external command directly, while &lt;code&gt;Filter::sh&lt;/code&gt; spawns a shell to execute the external command. (Unix uses the Bourne shell; NT uses the cmd shell.) Spawning a shell allows you to make use of the shell metacharacters and redirection facilities.</source>
          <target state="translated">소스 필터 배포에는이 작업을 단순화하는 &lt;code&gt;Filter::exec&lt;/code&gt; 및 &lt;code&gt;Filter::sh&lt;/code&gt; 두 모듈이 포함되어 있습니다. 둘 다 외부 실행 파일을 실행할 수 있습니다. 둘 다 코 프로세스를 사용하여 외부 실행 파일의 데이터 흐름을 제어합니다. (coprocesses에 대한 자세한 내용은 스티븐스, WR, &quot;유닉스 환경에서 고급 프로그래밍&quot;을 참조하십시오. 애디슨 - 웨슬리, ISBN 0-210-56317-7, 페이지 441-445입니다.) 그들 사이의 차이는 즉 &lt;code&gt;Filter::exec&lt;/code&gt; 급부상을 직접 외부 명령, 동안 &lt;code&gt;Filter::sh&lt;/code&gt; 급부상 쉘은 외부 명령을 실행합니다. (Unix는 Bourne 쉘을 사용하고 NT는 cmd 쉘을 사용합니다.) 쉘을 생성하면 쉘 메타 문자 및 리디렉션 기능을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="806a2d069e5b8127ce418989da98faab2d6211ce" translate="yes" xml:space="preserve">
          <source>The source filter distribution includes two modules that simplify this task: &lt;code&gt;Filter::exec&lt;/code&gt; and &lt;code&gt;Filter::sh&lt;/code&gt;. Both allow you to run any external executable. Both use a coprocess to control the flow of data into and out of the external executable. (For details on coprocesses, see Stephens, W.R., &quot;Advanced Programming in the UNIX Environment.&quot; Addison-Wesley, ISBN 0-210-56317-7, pages 441-445.) The difference between them is that &lt;code&gt;Filter::exec&lt;/code&gt; spawns the external command directly, while &lt;code&gt;Filter::sh&lt;/code&gt; spawns a shell to execute the external command. (Unix uses the Bourne shell; NT uses the cmd shell.) Spawning a shell allows you to make use of the shell metacharacters and redirection facilities.</source>
          <target state="translated">소스 필터 배포에는이 작업을 단순화하는 두 개의 모듈 인 &lt;code&gt;Filter::exec&lt;/code&gt; 및 &lt;code&gt;Filter::sh&lt;/code&gt; 됩니다. 둘 다 외부 실행 파일을 실행할 수 있습니다. 둘 다 코 프로세스를 사용하여 외부 실행 파일로 들어오고 나가는 데이터 흐름을 제어합니다. (코 프로세스에 대한 자세한 내용은 Stephens, WR, &quot;UNIX 환경의 고급 프로그래밍&quot;을 참조하십시오. Addison-Wesley, ISBN 0-210-56317-7, 441-445 페이지) 둘 사이의 차이점은 &lt;code&gt;Filter::exec&lt;/code&gt; 생성 된다는 것입니다. 외부 명령을 직접 실행하는 반면 &lt;code&gt;Filter::sh&lt;/code&gt; 는 외부 명령을 실행하기 위해 쉘을 생성합니다. (Unix는 Bourne 쉘을 사용하고 NT는 cmd 쉘을 사용합니다.) 쉘을 생성하면 쉘 메타 문자 및 리디렉션 기능을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ea0efb50a1d96794619b6be6780ccfe01a3a3f70" translate="yes" xml:space="preserve">
          <source>The source has to be set before you can parse anything. The lowest-level way is to call &lt;code&gt;set_source&lt;/code&gt; :</source>
          <target state="translated">소스를 설정해야 구문 분석 할 수 있습니다. 가장 낮은 수준의 방법은 &lt;code&gt;set_source&lt;/code&gt; 를 호출하는 것입니다 .</target>
        </trans-unit>
        <trans-unit id="25772fbca2fac712b2b730121903ca4af8245b2c" translate="yes" xml:space="preserve">
          <source>The source has to be set before you can parse anything. The lowest-level way is to call &lt;code&gt;set_source&lt;/code&gt;:</source>
          <target state="translated">무엇이든 파싱하기 전에 소스를 설정해야합니다. 가장 낮은 수준의 방법은 &lt;code&gt;set_source&lt;/code&gt; 를 호출하는 것입니다 .</target>
        </trans-unit>
        <trans-unit id="30a7a830852a264986b70187999506a317874b7f" translate="yes" xml:space="preserve">
          <source>The source of ISO 3166-1 two-letter codes used by this module.</source>
          <target state="translated">이 모듈에서 사용되는 ISO 3166-1 2 자리 코드의 소스.</target>
        </trans-unit>
        <trans-unit id="26888526042c45b79818c80cb5da539324a9402b" translate="yes" xml:space="preserve">
          <source>The source of the official ISO 3166-1 three-letter codes and three-digit codes.</source>
          <target state="translated">공식 ISO 3166-1 3 자리 코드 및 3 자리 코드의 출처.</target>
        </trans-unit>
        <trans-unit id="047e8113455a3b20776511dcfa749213b66f27f0" translate="yes" xml:space="preserve">
          <source>The source used to be tracked separately in another GitHub repo, but the canonical source is now in the above repo.</source>
          <target state="translated">소스는 다른 GitHub 리포지토리에서 별도로 추적되었지만 이제 표준 소스는 위의 리포지토리에 있습니다.</target>
        </trans-unit>
        <trans-unit id="454a907e32531c807293e3735238b43baf267920" translate="yes" xml:space="preserve">
          <source>The special argument of &lt;code&gt;h h&lt;/code&gt; produces the entire help page, which is quite long.</source>
          <target state="translated">&lt;code&gt;h h&lt;/code&gt; 의 특별한 인수 는 전체 도움말 페이지를 생성하는데, 이는 상당히 길다.</target>
        </trans-unit>
        <trans-unit id="c6f65c11625ca6f6efd4fce69ae54247f9d5fb65" translate="yes" xml:space="preserve">
          <source>The special bookkeeping Perl does to track the flow of external data through your program and disallow their use in system commands.</source>
          <target state="translated">특별 부기 Perl은 프로그램을 통한 외부 데이터의 흐름을 추적하고 시스템 명령에서 사용을 허용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="fbeef28b2f2c3763e9cdd6d44783f63733b4347f" translate="yes" xml:space="preserve">
          <source>The special character &lt;code&gt;'-'&lt;/code&gt; acts as a range operator within character classes, so that a contiguous set of characters can be written as a range. With ranges, the unwieldy &lt;code&gt;[0123456789]&lt;/code&gt; and &lt;code&gt;[abc...xyz]&lt;/code&gt; become the svelte &lt;code&gt;[0-9]&lt;/code&gt; and &lt;code&gt;[a-z]&lt;/code&gt; . Some examples are</source>
          <target state="translated">특수 문자 &lt;code&gt;'-'&lt;/code&gt; 는 문자 클래스 내에서 범위 연산자로 작동하므로 연속 된 문자 세트를 범위로 작성할 수 있습니다. 범위가 있으면 다루기 힘든 &lt;code&gt;[0123456789]&lt;/code&gt; 및 &lt;code&gt;[abc...xyz]&lt;/code&gt; 가 날카로운 &lt;code&gt;[0-9]&lt;/code&gt; 및 &lt;code&gt;[a-z]&lt;/code&gt; 됩니다. 몇 가지 예는</target>
        </trans-unit>
        <trans-unit id="51484dcb28cfa30c1085fd011a68713265cc9b21" translate="yes" xml:space="preserve">
          <source>The special character &lt;code&gt;'-'&lt;/code&gt; acts as a range operator within character classes, so that a contiguous set of characters can be written as a range. With ranges, the unwieldy &lt;code&gt;[0123456789]&lt;/code&gt; and &lt;code&gt;[abc...xyz]&lt;/code&gt; become the svelte &lt;code&gt;[0-9]&lt;/code&gt; and &lt;code&gt;[a-z]&lt;/code&gt;. Some examples are</source>
          <target state="translated">특수 문자 &lt;code&gt;'-'&lt;/code&gt; 는 문자 클래스 내에서 범위 연산자 역할을하므로 연속 된 문자 집합을 범위로 쓸 수 있습니다. 범위를 사용하면 다루기 힘든 &lt;code&gt;[0123456789]&lt;/code&gt; 및 &lt;code&gt;[abc...xyz]&lt;/code&gt; 가 날렵한 &lt;code&gt;[0-9]&lt;/code&gt; 및 &lt;code&gt;[a-z]&lt;/code&gt; 됩니다. 몇 가지 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3a71b165b4e188832e186d5361505b47059b1afc" translate="yes" xml:space="preserve">
          <source>The special character &lt;code&gt;'-'&lt;/code&gt; acts as a range operator within character classes, so that the unwieldy &lt;code&gt;[0123456789]&lt;/code&gt; and &lt;code&gt;[abc...xyz]&lt;/code&gt; become the svelte &lt;code&gt;[0-9]&lt;/code&gt; and &lt;code&gt;[a-z]&lt;/code&gt; :</source>
          <target state="translated">특수 문자 &lt;code&gt;'-'&lt;/code&gt; 는 문자 클래스 내에서 범위 연산자로 작동하므로 다루기 어려운 &lt;code&gt;[0123456789]&lt;/code&gt; 및 &lt;code&gt;[abc...xyz]&lt;/code&gt; 가 스 벨트 &lt;code&gt;[0-9]&lt;/code&gt; 및 &lt;code&gt;[a-z]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="283724a0a196c8e1912b746979d3d1ad3654c817" translate="yes" xml:space="preserve">
          <source>The special character &lt;code&gt;'-'&lt;/code&gt; acts as a range operator within character classes, so that the unwieldy &lt;code&gt;[0123456789]&lt;/code&gt; and &lt;code&gt;[abc...xyz]&lt;/code&gt; become the svelte &lt;code&gt;[0-9]&lt;/code&gt; and &lt;code&gt;[a-z]&lt;/code&gt;:</source>
          <target state="translated">특수 문자 &lt;code&gt;'-'&lt;/code&gt; 는 문자 클래스 내에서 범위 연산자 역할을하므로 다루기 힘든 &lt;code&gt;[0123456789]&lt;/code&gt; 및 &lt;code&gt;[abc...xyz]&lt;/code&gt; 는 날렵한 &lt;code&gt;[0-9]&lt;/code&gt; 및 &lt;code&gt;[a-z]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9e3d6c0c10b1c629e2125d262c610ffe5039c3e0" translate="yes" xml:space="preserve">
          <source>The special character &lt;code&gt;'^'&lt;/code&gt; in the first position of a character class denotes a</source>
          <target state="translated">문자 클래스의 첫 번째 위치에있는 특수 문자 &lt;code&gt;'^'&lt;/code&gt; 는</target>
        </trans-unit>
        <trans-unit id="c1d9d9306fb9aa515c3bd892587a0587d3baf9f6" translate="yes" xml:space="preserve">
          <source>The special character &lt;code&gt;^&lt;/code&gt; in the first position of a character class denotes a</source>
          <target state="translated">문자 클래스의 첫 번째 위치에서 특수 문자 &lt;code&gt;^&lt;/code&gt; 는</target>
        </trans-unit>
        <trans-unit id="8afc59f37c7b54c4d8a636841474cf58beb13e84" translate="yes" xml:space="preserve">
          <source>The special character &lt;code&gt;^&lt;/code&gt; in the first position of a character class denotes a &lt;b&gt;negated character class&lt;/b&gt;, which matches any character but those in the brackets. Both &lt;code&gt;[...]&lt;/code&gt; and &lt;code&gt;[^...]&lt;/code&gt; must match a character, or the match fails. Then</source>
          <target state="translated">문자 클래스의 첫 번째 위치에서 특수 문자 &lt;code&gt;^&lt;/code&gt; 는 괄호 안에있는 문자 이외의 문자와 일치 하는 &lt;b&gt;부정 문자 클래스를&lt;/b&gt; 나타냅니다 . 두 &lt;code&gt;[...]&lt;/code&gt; 및 &lt;code&gt;[^...]&lt;/code&gt; 문자와 일치해야하며, 일치에 실패합니다. 그때</target>
        </trans-unit>
        <trans-unit id="94d7fdb99f703e5dc3a7ffcb7bb005616b504881" translate="yes" xml:space="preserve">
          <source>The special filehandle that iterates over command-line filenames in &lt;code&gt;@ARGV&lt;/code&gt; . Usually written as the null filehandle in the angle operator &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; . Note that currently &lt;code&gt;ARGV&lt;/code&gt; only has its magical effect within the &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; operator; elsewhere it is just a plain filehandle corresponding to the last file opened by &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; . In particular, passing &lt;code&gt;\*ARGV&lt;/code&gt; as a parameter to a function that expects a filehandle may not cause your function to automatically read the contents of all the files in &lt;code&gt;@ARGV&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;@ARGV&lt;/code&gt; 의 명령 줄 파일 이름을 반복하는 특수 파일 핸들입니다 . 일반적으로 각도 연산자 &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; 에서 널 파일 핸들로 작성됩니다 . 현재 &lt;code&gt;ARGV&lt;/code&gt; 는 &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; 연산자 내에서만 마법 효과를 나타냅니다 . 다른 곳에서는 &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; 에 의해 열린 마지막 파일에 해당하는 일반 파일 핸들 입니다. 특히, 파일 핸들을 기대하는 함수에 매개 변수로 &lt;code&gt;\*ARGV&lt;/code&gt; 를 전달 하면 함수가 &lt;code&gt;@ARGV&lt;/code&gt; 에있는 모든 파일의 내용을 자동으로 읽지 못할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ac1da88fc9d1c37eca9b801363ceb623fe61bad6" translate="yes" xml:space="preserve">
          <source>The special filehandle that iterates over command-line filenames in &lt;code&gt;@ARGV&lt;/code&gt;. Usually written as the null filehandle in the angle operator &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt;. Note that currently &lt;code&gt;ARGV&lt;/code&gt; only has its magical effect within the &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; operator; elsewhere it is just a plain filehandle corresponding to the last file opened by &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt;. In particular, passing &lt;code&gt;\*ARGV&lt;/code&gt; as a parameter to a function that expects a filehandle may not cause your function to automatically read the contents of all the files in &lt;code&gt;@ARGV&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;@ARGV&lt;/code&gt; 의 명령 줄 파일 이름을 반복하는 특수 파일 핸들입니다 . 일반적으로 각도 연산자 &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; 에서 null 파일 핸들로 작성됩니다 . 현재 &lt;code&gt;ARGV&lt;/code&gt; 는 &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; 연산자 내에서만 마법 효과가 있습니다 . 다른 곳에서는 &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; 에 의해 열린 마지막 파일에 해당하는 일반 파일 핸들 입니다. 특히, &lt;code&gt;\*ARGV&lt;/code&gt; 를 파일 핸들이 필요한 함수에 매개 변수로 전달하면 함수가 &lt;code&gt;@ARGV&lt;/code&gt; 에있는 모든 파일의 내용을 자동으로 읽지 못할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f805e5a7fa6e6a7379f92a69ce80440a9d42a7c7" translate="yes" xml:space="preserve">
          <source>The special filehandle that points to the currently open output file when doing edit-in-place processing with &lt;b&gt;-i&lt;/b&gt;. Useful when you have to do a lot of inserting and don't want to keep modifying &lt;code&gt;$_&lt;/code&gt; . See &lt;a href=&quot;perlrun&quot;&gt;perlrun&lt;/a&gt; for the &lt;b&gt;-i&lt;/b&gt; switch.</source>
          <target state="translated">&lt;b&gt;-i&lt;/b&gt; 로 내부 편집 처리를 수행 할 때 현재 열려있는 출력 파일을 가리키는 특수 파일 핸들입니다 . 많은 삽입 작업을 수행해야하고 &lt;code&gt;$_&lt;/code&gt; 수정을 계속하고 싶지 않을 때 유용합니다 . &lt;b&gt;-i&lt;/b&gt; 스위치에 대해서는 &lt;a href=&quot;perlrun&quot;&gt;perlrun&lt;/a&gt; 을 참조하십시오 .&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="b0f0f7c3f4bb49e8602e83db9899cb43d8c4eab1" translate="yes" xml:space="preserve">
          <source>The special filehandle that points to the currently open output file when doing edit-in-place processing with &lt;b&gt;-i&lt;/b&gt;. Useful when you have to do a lot of inserting and don't want to keep modifying &lt;code&gt;$_&lt;/code&gt;. See &lt;a href=&quot;perlrun#-i%5Bextension%5D&quot;&gt;perlrun&lt;/a&gt; for the &lt;b&gt;-i&lt;/b&gt; switch.</source>
          <target state="translated">&lt;b&gt;-i를 사용&lt;/b&gt; 하여 내부 편집 처리를 수행 할 때 현재 열려있는 출력 파일을 가리키는 특수 파일 핸들입니다 . 많은 삽입을해야하고 &lt;code&gt;$_&lt;/code&gt; 을 계속 수정하고 싶지 않을 때 유용합니다 . &lt;b&gt;-i&lt;/b&gt; 스위치에 대해서는 &lt;a href=&quot;perlrun#-i%5Bextension%5D&quot;&gt;perlrun&lt;/a&gt; 을 참조하십시오 .&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="1c54707234ac101d1520e7aec3c57187de852952" translate="yes" xml:space="preserve">
          <source>The special filename &quot;-&quot; can be used as a standin for both &lt;code&gt;\*STDIN&lt;/code&gt; and &lt;code&gt;\*STDOUT&lt;/code&gt;, so the above can be rewritten as</source>
          <target state="translated">특수 파일 이름 &quot;-&quot;는 &lt;code&gt;\*STDIN&lt;/code&gt; 및 &lt;code&gt;\*STDOUT&lt;/code&gt; 모두에 대한 standin으로 사용할 수 있으므로 위의 내용을 다음과 같이 다시 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="25d2e9e8733979d7b1492fbdd9a7cb623d57628f" translate="yes" xml:space="preserve">
          <source>The special literals __FILE__, __LINE__, and __PACKAGE__ represent the current filename, line number, and package name at that point in your program. __SUB__ gives a reference to the current subroutine. They may be used only as separate tokens; they will not be interpolated into strings. If there is no current package (due to an empty &lt;code&gt;&lt;a href=&quot;functions/package&quot;&gt;package;&lt;/a&gt;&lt;/code&gt; directive), __PACKAGE__ is the undefined value. (But the empty &lt;code&gt;&lt;a href=&quot;functions/package&quot;&gt;package;&lt;/a&gt;&lt;/code&gt; is no longer supported, as of version 5.10.) Outside of a subroutine, __SUB__ is the undefined value. __SUB__ is only available in 5.16 or higher, and only with a &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; v5.16&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature &quot;current_sub&quot;&lt;/code&gt; declaration.</source>
          <target state="translated">특수 리터럴 __FILE__, __LINE__ 및 __PACKAGE__은 프로그램의 해당 시점에서 현재 파일 이름, 줄 번호 및 패키지 이름을 나타냅니다. __SUB__는 현재 서브 루틴에 대한 참조를 제공합니다. 개별 토큰으로 만 사용할 수 있습니다. 문자열로 보간되지 않습니다. 빈 &lt;code&gt;&lt;a href=&quot;functions/package&quot;&gt;package;&lt;/a&gt;&lt;/code&gt; 지시문 으로 인해 현재 패키지가없는 경우 __PACKAGE__는 정의되지 않은 값입니다. 그러나 빈 &lt;code&gt;&lt;a href=&quot;functions/package&quot;&gt;package;&lt;/a&gt;&lt;/code&gt; 는 버전 5.10부터 더 이상 지원되지 않습니다. 서브 루틴 외부에서 __SUB__는 정의되지 않은 값입니다. __SUB__는 5.16 이상에서만 사용 가능하고 만 함께 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; v5.16&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature &quot;current_sub&quot;&lt;/code&gt; 선언.</target>
        </trans-unit>
        <trans-unit id="320950a977dc3e4b6b51f0cd126847e374ebbae7" translate="yes" xml:space="preserve">
          <source>The special literals __FILE__, __LINE__, and __PACKAGE__ represent the current filename, line number, and package name at that point in your program. __SUB__ gives a reference to the current subroutine. They may be used only as separate tokens; they will not be interpolated into strings. If there is no current package (due to an empty &lt;code&gt;package;&lt;/code&gt; directive), __PACKAGE__ is the undefined value. (But the empty &lt;code&gt;package;&lt;/code&gt; is no longer supported, as of version 5.10.) Outside of a subroutine, __SUB__ is the undefined value. __SUB__ is only available in 5.16 or higher, and only with a &lt;code&gt;use v5.16&lt;/code&gt; or &lt;code&gt;use feature &quot;current_sub&quot;&lt;/code&gt; declaration.</source>
          <target state="translated">특수 리터럴 __FILE__, __LINE__ 및 __PACKAGE__는 프로그램의 해당 지점에서 현재 파일 이름, 줄 번호 및 패키지 이름을 나타냅니다. __SUB__는 현재 서브 루틴에 대한 참조를 제공합니다. 별도의 토큰으로 만 사용할 수 있습니다. 문자열로 보간되지 않습니다. 현재 패키지가없는 경우 (빈 &lt;code&gt;package;&lt;/code&gt; 지시문 으로 인해 ) __PACKAGE__는 정의되지 않은 값입니다. (그러나 빈 &lt;code&gt;package;&lt;/code&gt; 는 버전 5.10부터 더 이상 지원되지 않습니다.) 서브 루틴 외부에서 __SUB__는 정의되지 않은 값입니다. __SUB__는 5.16 이상에서만 사용할 수 있으며 &lt;code&gt;use v5.16&lt;/code&gt; &lt;code&gt;use feature &quot;current_sub&quot;&lt;/code&gt; 하거나 기능 &quot;current_sub&quot; 선언을 사용 하는 경우 에만 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6af0b63b67806c6dfb7b9ddb2d398096248ddab4" translate="yes" xml:space="preserve">
          <source>The special mark that tells the operating system it can run this program. There are actually three execute bits under Unix, and which bit gets used depends on whether you own the file singularly, collectively, or not at all.</source>
          <target state="translated">운영 체제에이 프로그램을 실행할 수 있음을 알리는 특수 표시입니다. 실제로 Unix에는 세 개의 실행 비트가 있으며 사용되는 비트는 파일을 단일, 집합 또는 소유하는지에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="6429c59caa249ed4d6719a4eab753f28d6cfd25d" translate="yes" xml:space="preserve">
          <source>The special methods &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next::method&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next::can&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;maybe::next::method&lt;/code&gt; are not available until this &lt;code&gt;mro&lt;/code&gt; module has been loaded via &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 &lt;code&gt;mro&lt;/code&gt; 모듈이 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; 를 통해로드 될 때까지 &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next::method&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next::can&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;maybe::next::method&lt;/code&gt; 특수 메소드를 사용할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="cc7c3c8f9444854b13225185a30e005803243a24" translate="yes" xml:space="preserve">
          <source>The special methods &lt;code&gt;next::method&lt;/code&gt;, &lt;code&gt;next::can&lt;/code&gt;, and &lt;code&gt;maybe::next::method&lt;/code&gt; are not available until this &lt;code&gt;mro&lt;/code&gt; module has been loaded via &lt;code&gt;use&lt;/code&gt; or &lt;code&gt;require&lt;/code&gt;.</source>
          <target state="translated">이 &lt;code&gt;mro&lt;/code&gt; 모듈이 &lt;code&gt;use&lt;/code&gt; 또는 &lt;code&gt;require&lt;/code&gt; 를 통해로드 될 때까지 &lt;code&gt;next::method&lt;/code&gt; , &lt;code&gt;next::can&lt;/code&gt; 및 &lt;code&gt;maybe::next::method&lt;/code&gt; 특수 메서드를 사용할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="c41f3d15a857df9bc04fff7f6a7434b18442c584" translate="yes" xml:space="preserve">
          <source>The special quoting behavior ignores precedence, and hence may apply to</source>
          <target state="translated">특수 인용 동작은 우선 순위를 무시하므로 다음에 적용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6bd162b2c252e6c76a44c9033fc601bb11a084ee" translate="yes" xml:space="preserve">
          <source>The special string &lt;code&gt;&quot;0 but true&quot;&lt;/code&gt; is exempt from &lt;a href=&quot;perldiag#Argument-%22%25s%22-isn%27t-numeric%25s&quot;&gt;&lt;code&gt;Argument &quot;...&quot; isn't numeric&lt;/code&gt;&lt;/a&gt;&lt;a href=&quot;warnings&quot;&gt;warnings&lt;/a&gt; on improper numeric conversions.</source>
          <target state="translated">특수 문자열 &lt;code&gt;&quot;0 but true&quot;&lt;/code&gt; 는 잘못된 숫자 변환에 대한 &lt;a href=&quot;perldiag#Argument-%22%25s%22-isn%27t-numeric%25s&quot;&gt; &lt;code&gt;Argument &quot;...&quot; isn't numeric&lt;/code&gt; &lt;/a&gt;&lt;a href=&quot;warnings&quot;&gt; 경고 &lt;/a&gt;가 아닙니다. 인수 &quot;...&quot; 에서 제외됩니다 .</target>
        </trans-unit>
        <trans-unit id="79a2544429fe460799a8292535fcaefc5e4c6c60" translate="yes" xml:space="preserve">
          <source>The special string &lt;code&gt;&quot;0 but true&quot;&lt;/code&gt; is exempt from &lt;b&gt;-w&lt;/b&gt; complaints about improper numeric conversions.</source>
          <target state="translated">특수 문자열 &lt;code&gt;&quot;0 but true&quot;&lt;/code&gt; 는 부적절한 숫자 변환에 대한 &lt;b&gt;-w&lt;/b&gt; 불만 에서 제외됩니다 .</target>
        </trans-unit>
        <trans-unit id="026f6dfd3d9c99c5a9bfd6afe8ee0f79daedf36d" translate="yes" xml:space="preserve">
          <source>The special symbol &lt;code&gt;__PACKAGE__&lt;/code&gt; contains the current package, but cannot (easily) be used to construct variable names.</source>
          <target state="translated">특수 기호 &lt;code&gt;__PACKAGE__&lt;/code&gt; 는 현재 패키지를 포함하지만 변수 이름을 구성하는 데 (쉽게) 사용할 수는 없습니다.</target>
        </trans-unit>
        <trans-unit id="ec16f658ce9778430c3bc19ca22d2cf08596e063" translate="yes" xml:space="preserve">
          <source>The special symbol &lt;code&gt;__PACKAGE__&lt;/code&gt; contains the current package, but cannot (easily) be used to construct variable names. After &lt;code&gt;my($foo)&lt;/code&gt; has hidden package variable &lt;code&gt;$foo&lt;/code&gt;, it can still be accessed, without knowing what package you are in, as &lt;code&gt;${__PACKAGE__.'::foo'}&lt;/code&gt;.</source>
          <target state="translated">특수 기호 &lt;code&gt;__PACKAGE__&lt;/code&gt; 는 현재 패키지를 포함하지만 변수 이름을 구성하는 데 (쉽게) 사용할 수 없습니다. 후 &lt;code&gt;my($foo)&lt;/code&gt; 패키지 변수 숨겨져있다 &lt;code&gt;$foo&lt;/code&gt; , 그것은 여전히, 당신은에있는 패키지 모르고, 액세스 할 수있는 &lt;code&gt;${__PACKAGE__.'::foo'}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8f36c55aa844c8a0dac4156e30712cffbcd8a9f0" translate="yes" xml:space="preserve">
          <source>The special two-argument form of Perl's open() function ignores trailing blanks in filenames and infers the mode from certain leading characters (or a trailing &quot;|&quot;). In older versions of Perl this was the only version of open() and so it is prevalent in old code and books.</source>
          <target state="translated">Perl의 open () 함수의 특수 2 인수 형식은 파일 이름에서 후행 공백을 무시하고 특정 선행 문자 (또는 후행 &quot;|&quot;)에서 모드를 유추합니다. 이전 버전의 Perl에서는이 버전이 open ()의 유일한 버전이므로 이전 코드 및 서적에서 널리 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="161a5a9075bb6b7595615ee16fc183085e48d829" translate="yes" xml:space="preserve">
          <source>The special value 00 will cause Perl to slurp files in paragraph mode. Any value 0400 or above will cause Perl to slurp files whole, but by convention the value 0777 is the one normally used for this purpose.</source>
          <target state="translated">특수 값 00은 Perl이 단락 모드에서 파일을 처리하게합니다. 값이 0400 이상이면 Perl이 파일 전체를 훔치 게되지만 일반적으로 값 0777은이 목적으로 일반적으로 사용되는 값입니다.</target>
        </trans-unit>
        <trans-unit id="510ff7ba673af9c07da4bdf1546cce9f48d4aa9d" translate="yes" xml:space="preserve">
          <source>The special variable &lt;code&gt;$#array&lt;/code&gt; tells you the index of the last element of an array:</source>
          <target state="translated">특수 변수 &lt;code&gt;$#array&lt;/code&gt; 는 배열 의 마지막 요소의 인덱스를 알려줍니다.</target>
        </trans-unit>
        <trans-unit id="7bf5f587af4320b4f6a337ef8e71a1acc59dbd84" translate="yes" xml:space="preserve">
          <source>The special variable &lt;code&gt;${^ENCODING}&lt;/code&gt; was used to implement the &lt;code&gt;encoding&lt;/code&gt; pragma. Setting this variable to anything other than &lt;code&gt;undef&lt;/code&gt; was deprecated in Perl 5.22. Full deprecation of the variable happened in Perl 5.25.3.</source>
          <target state="translated">특수 변수 &lt;code&gt;${^ENCODING}&lt;/code&gt; 이 &lt;code&gt;encoding&lt;/code&gt; pragma 를 구현하는 데 사용되었습니다 . 이 변수를 &lt;code&gt;undef&lt;/code&gt; 이외의 다른 것으로 설정하는 것은 Perl 5.22에서 더 이상 사용되지 않습니다. Perl 5.25.3에서 변수의 완전한 폐기가 발생했습니다.</target>
        </trans-unit>
        <trans-unit id="848d9f1e6794b744b742b40d6e30625dbd74dd9d" translate="yes" xml:space="preserve">
          <source>The special variables for formats are a subset of those for filehandles. See &lt;a href=&quot;perlform&quot;&gt;perlform&lt;/a&gt; for more information about Perl's formats.</source>
          <target state="translated">형식의 특수 변수는 파일 핸들 변수의 하위 집합입니다. Perl 형식에 대한 자세한 정보는 &lt;a href=&quot;perlform&quot;&gt;perlform&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d50e7fd9df415ed27a91da10839b57126db4d317" translate="yes" xml:space="preserve">
          <source>The special verbosity level 99 requires to also specify the -sections parameter; then these sections are extracted and printed.</source>
          <target state="translated">특수한 상세 레벨 99에서는 -sections 매개 변수도 지정해야합니다. 그런 다음이 섹션을 추출하여 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="79d7da7f02ba1ece997a8e1f533d9c05c192eb59" translate="yes" xml:space="preserve">
          <source>The specific task here is to sort the 286,525 lines of this file by Response Code, Query, Browser, Referring Url, and lastly Date. One solution might be to use the following code, which iterates over the files given on the command-line.</source>
          <target state="translated">여기서 구체적인 작업은 응답 코드, 쿼리, 브라우저, 참조 URL 및 마지막 날짜별로이 파일의 286,525 줄을 정렬하는 것입니다. 한 가지 해결책은 다음 코드를 사용하는 것입니다.이 코드는 명령 행에 제공된 파일을 반복합니다.</target>
        </trans-unit>
        <trans-unit id="ec45d65d2602c92bff90edfa34bc341572780991" translate="yes" xml:space="preserve">
          <source>The specification of ISO-2022 is available from the link above.</source>
          <target state="translated">ISO-2022 사양은 위 링크에서 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="61bf1ad08824c740b76048cd4f454fa0d05ebcf4" translate="yes" xml:space="preserve">
          <source>The specification which tar derives from; &lt;code&gt; &lt;a href=&quot;http://www.opengroup.org/onlinepubs/007904975/utilities/pax.html&quot;&gt;http://www.opengroup.org/onlinepubs/007904975/utilities/pax.html&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">타르에서 파생되는 사양; &lt;code&gt; &lt;a href=&quot;http://www.opengroup.org/onlinepubs/007904975/utilities/pax.html&quot;&gt;http://www.opengroup.org/onlinepubs/007904975/utilities/pax.html&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6cea1ce6b94b1cce0327c439743891bfb6f47d86" translate="yes" xml:space="preserve">
          <source>The specification which tar derives from; &lt;code&gt; http://www.opengroup.org/onlinepubs/007904975/utilities/pax.html&lt;/code&gt;</source>
          <target state="translated">tar가 파생 된 사양 &lt;code&gt; http://www.opengroup.org/onlinepubs/007904975/utilities/pax.html&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="040046de0f6316ea231530079dbf44ad18b9f542" translate="yes" xml:space="preserve">
          <source>The specifications are returned in increasing order of arguments starting at 0 (e.g. ';$') or 1 (e.g. '$@'). Note that if the prototype is &quot;slurpy&quot; (e.g. ends with a &quot;@&quot;), the number of arguments for the last specification is a &quot;minimum&quot; number rather than an exact number. This can be detected by the last member of the last specification matching m/[@#]_/.</source>
          <target state="translated">사양은 0 (예 : '; $') 또는 1 (예 : '$ @')에서 시작하는 인수의 오름차순으로 반환됩니다. 프로토 타입이 &quot;불량&quot;한 경우 (예 : &quot;@&quot;로 끝남) 마지막 사양의 인수 수는 정확한 숫자가 아니라 &quot;최소&quot;숫자입니다. 이것은 m / [@ #] _ /와 일치하는 마지막 사양의 마지막 멤버에 의해 감지 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5249ead0cea582438ce306dee2ff065c9121394e" translate="yes" xml:space="preserve">
          <source>The specified</source>
          <target state="translated">지정된</target>
        </trans-unit>
        <trans-unit id="0bbf6ce071adc9bbc621e13b2eb0c9adb5ed909d" translate="yes" xml:space="preserve">
          <source>The specified filtering subroutine is called every time a &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; BANG&lt;/code&gt; is encountered, and passed all the source code following that call, up to either the next &lt;code&gt;&lt;a href=&quot;../functions/no&quot;&gt;no&lt;/a&gt; BANG;&lt;/code&gt; (or whatever terminator you've set) or the end of the source file, whichever occurs first. By default, any &lt;code&gt;&lt;a href=&quot;../functions/no&quot;&gt;no&lt;/a&gt;
BANG;&lt;/code&gt; call must appear by itself on a separate line, or it is ignored.</source>
          <target state="translated">지정된 필터링 서브 루틴은 &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; BANG&lt;/code&gt; &lt;a href=&quot;../functions/use&quot;&gt;사용&lt;/a&gt; 이 발생할 때마다 호출되며 다음 호출이 &lt;code&gt;&lt;a href=&quot;../functions/no&quot;&gt;no&lt;/a&gt; BANG;&lt;/code&gt; 까지 해당 호출 다음의 모든 소스 코드를 전달합니다 . (또는 설정 한 터미네이터) 또는 소스 파일의 끝 (둘 중 먼저 발생) 기본적으로 어떤 &lt;code&gt;&lt;a href=&quot;../functions/no&quot;&gt;no&lt;/a&gt; BANG;&lt;/code&gt; 통화는 별도의 회선에 단독으로 나타나거나 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="4c32a119deb019c17dccde9cf5e6d747da8ced23" translate="yes" xml:space="preserve">
          <source>The specified filtering subroutine is called every time a &lt;code&gt;use BANG&lt;/code&gt; is encountered, and passed all the source code following that call, up to either the next &lt;code&gt;no BANG;&lt;/code&gt; (or whatever terminator you've set) or the end of the source file, whichever occurs first. By default, any &lt;code&gt;no BANG;&lt;/code&gt; call must appear by itself on a separate line, or it is ignored.</source>
          <target state="translated">지정된 필터링 서브 루틴은 &lt;code&gt;use BANG&lt;/code&gt; 이 발생할 때마다 호출되고 해당 호출 이후의 모든 소스 코드를 다음 &lt;code&gt;no BANG;&lt;/code&gt; 까지 전달합니다 . (또는 설정 한 종결 자) 또는 소스 파일의 끝 중 먼저 발생합니다. 기본적으로 &lt;code&gt;no BANG;&lt;/code&gt; 은 없습니다. call은 별도의 줄에 단독으로 나타나야합니다. 그렇지 않으면 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="888fda8ce1b72f373cbaac5341a6655b0d4c64f9" translate="yes" xml:space="preserve">
          <source>The splain Program</source>
          <target state="translated">스 플레인 프로그램</target>
        </trans-unit>
        <trans-unit id="c52324d25d30fa15232ecb990b5648a4dcfeb28a" translate="yes" xml:space="preserve">
          <source>The split function</source>
          <target state="translated">스플릿 기능</target>
        </trans-unit>
        <trans-unit id="ddfcdc05a5251df7fbf9a8a775f1e8025aac3f91" translate="yes" xml:space="preserve">
          <source>The split operator</source>
          <target state="translated">분할 연산자</target>
        </trans-unit>
        <trans-unit id="62b2eb8876cf935a6917a946dbc16da0fe289ddf" translate="yes" xml:space="preserve">
          <source>The square brackets explicitly turn a list value into a scalar value, while parentheses do not. So when a parenthesized list is evaluated in a scalar context, the comma is treated like C's comma operator, which throws away the left argument, which is not what you want. See &lt;a href=&quot;perlref&quot;&gt;perlref&lt;/a&gt; for more on this.</source>
          <target state="translated">대괄호는 목록 값을 스칼라 값으로 명시 적으로 바꾸지 만 괄호는 그렇지 않습니다. 따라서 괄호로 묶은 목록을 스칼라 컨텍스트에서 평가하면 쉼표는 C의 쉼표 연산자처럼 처리되어 왼쪽 인수를 버립니다. 이는 원하는 것이 아닙니다. &lt;a href=&quot;perlref&quot;&gt;perlref&lt;/a&gt; 참조 대한 자세한 를 .</target>
        </trans-unit>
        <trans-unit id="daa1d51a4ab5d5dc2b248180c01a452f38c9d08d" translate="yes" xml:space="preserve">
          <source>The square brackets make a reference to a new array with a</source>
          <target state="translated">대괄호는 다음과 같이 새 배열을 참조합니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
