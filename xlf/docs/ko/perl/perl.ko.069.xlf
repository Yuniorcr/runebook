<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="perl">
    <body>
      <group id="perl">
        <trans-unit id="9d8d0feb3edb0eff1e9ffe23486e4f54336c8d4e" translate="yes" xml:space="preserve">
          <source>Top-of-form processing is by default handled by a format with the same name as the current filehandle with &quot;_TOP&quot; concatenated to it. It's triggered at the top of each page. See &lt;a href=&quot;functions/write&quot;&gt;write&lt;/a&gt;.</source>
          <target state="translated">최상위 양식 처리는 기본적으로 &quot;_TOP&quot;이 연결된 현재 파일 핸들과 이름이 같은 형식으로 처리됩니다. 각 페이지 상단에서 트리거됩니다. &lt;a href=&quot;functions/write&quot;&gt;write&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="58ef03b2e7b2cce794df0ce3f4e46ce888251a1d" translate="yes" xml:space="preserve">
          <source>Top-of-form processing is by default handled by a format with the same name as the current filehandle with &quot;_TOP&quot; concatenated to it. It's triggered at the top of each page. See &lt;a href=&quot;perlfunc#write&quot;&gt;&quot;write&quot; in perlfunc&lt;/a&gt;.</source>
          <target state="translated">양식 상단 처리는 기본적으로 &quot;_TOP&quot;가 연결된 현재 파일 핸들과 이름이 같은 형식으로 처리됩니다. 각 페이지 상단에서 실행됩니다. &lt;a href=&quot;perlfunc#write&quot;&gt;perlfunc의 &quot;쓰기&quot;를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="cb98d71b2e229a477af401f7c4895167097dcb8a" translate="yes" xml:space="preserve">
          <source>TopSystemUID</source>
          <target state="translated">TopSystemUID</target>
        </trans-unit>
        <trans-unit id="f766dbf6de80a1783868b76b0ffdd16e6a94e83e" translate="yes" xml:space="preserve">
          <source>Topic branches and rewriting history</source>
          <target state="translated">주제 분기 및 재 작성 역사</target>
        </trans-unit>
        <trans-unit id="8e2f2b4afe1a913994b69be99455c56a7fc054ab" translate="yes" xml:space="preserve">
          <source>Torsten Schoenfeld</source>
          <target state="translated">Torsten Schoenfeld</target>
        </trans-unit>
        <trans-unit id="855b740deb0e234d1668b8ec10c825eb8a3450f0" translate="yes" xml:space="preserve">
          <source>Total CPU (User + System) of any children processes.</source>
          <target state="translated">모든 하위 프로세스의 총 CPU (사용자 + 시스템)</target>
        </trans-unit>
        <trans-unit id="3481164ed61c4f3a7713de67224c54bcab0e71f6" translate="yes" xml:space="preserve">
          <source>Total CPU (User + System) of the main (parent) process.</source>
          <target state="translated">기본 (부모) 프로세스의 총 CPU (사용자 + 시스템)</target>
        </trans-unit>
        <trans-unit id="1e2c196e8d42960075bf83565f85bd785a488f4c" translate="yes" xml:space="preserve">
          <source>Total CPU of parent and any children processes.</source>
          <target state="translated">상위 및 모든 하위 프로세스의 총 CPU</target>
        </trans-unit>
        <trans-unit id="32bbce2a356130ac460d0855ed4bb96cc9c277fe" translate="yes" xml:space="preserve">
          <source>Trace function calls</source>
          <target state="translated">추적 함수 호출</target>
        </trans-unit>
        <trans-unit id="4b32a7b148f732eb014244c4bbbcbbea6216c149" translate="yes" xml:space="preserve">
          <source>Trace mode (similar to &lt;code&gt;t&lt;/code&gt; command, but can be put into &lt;code&gt;PERLDB_OPTS&lt;/code&gt; ).</source>
          <target state="translated">추적 모드 ( &lt;code&gt;t&lt;/code&gt; 명령 과 유사 하지만 &lt;code&gt;PERLDB_OPTS&lt;/code&gt; 에 넣을 수 있음 )</target>
        </trans-unit>
        <trans-unit id="75ddac2cad68f5ef90bf266909b1cc9bff0811e0" translate="yes" xml:space="preserve">
          <source>Trace mode (similar to &lt;code&gt;t&lt;/code&gt; command, but can be put into &lt;code&gt;PERLDB_OPTS&lt;/code&gt;).</source>
          <target state="translated">추적 모드 ( &lt;code&gt;t&lt;/code&gt; 명령 과 유사 하지만 &lt;code&gt;PERLDB_OPTS&lt;/code&gt; 에 넣을 수 있음 ).</target>
        </trans-unit>
        <trans-unit id="4d8c4db1a294c0162454110ac7c8472297017033" translate="yes" xml:space="preserve">
          <source>Trace through execution of &lt;code&gt;expr&lt;/code&gt; . Optional first argument is the maximum number of levels to trace below the current one; anything deeper than that will be silent. See &lt;a href=&quot;perldebguts#Frame-Listing-Output-Examples&quot;&gt;Frame Listing Output Examples in perldebguts&lt;/a&gt; for examples.</source>
          <target state="translated">&lt;code&gt;expr&lt;/code&gt; 실행을 통해 추적합니다 . 선택적인 첫 번째 인수는 현재 수준 아래에서 추적 할 최대 수준 수입니다. 그보다 더 깊은 것은 침묵 할 것입니다. &lt;a href=&quot;perldebguts#Frame-Listing-Output-Examples&quot;&gt;예제는 perldebguts의 프레임 목록 출력 예제를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="41581b1e8642b813163a8ffec956716ae9f8f88d" translate="yes" xml:space="preserve">
          <source>Trace through execution of &lt;code&gt;expr&lt;/code&gt;. Optional first argument is the maximum number of levels to trace below the current one; anything deeper than that will be silent. See &lt;a href=&quot;perldebguts#Frame-Listing-Output-Examples&quot;&gt;&quot;Frame Listing Output Examples&quot; in perldebguts&lt;/a&gt; for examples.</source>
          <target state="translated">&lt;code&gt;expr&lt;/code&gt; 실행을 추적합니다 . 선택적 첫 번째 인수는 현재 값 아래에서 추적 할 최대 레벨 수입니다. 그보다 더 깊은 것은 침묵 할 것입니다. &lt;a href=&quot;perldebguts#Frame-Listing-Output-Examples&quot;&gt;예제는 perldebguts의 &quot;프레임 목록 출력 예제&quot;를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="21b60e7167b2cc35295d61cd8ed5b383229ffbac" translate="yes" xml:space="preserve">
          <source>Trace variable used when Perl is run in debugging mode, with the &lt;b&gt;-d&lt;/b&gt; switch. This is the C variable which corresponds to Perl's $DB::trace variable. See &lt;code&gt;&lt;a href=&quot;#PL_DBsingle&quot;&gt;&quot;PL_DBsingle&quot;&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;b&gt;-d&lt;/b&gt; 스위치를 사용하여 Perl이 디버깅 모드에서 실행될 때 사용되는 추적 변수 입니다. 이것은 Perl의 $ DB :: trace 변수에 해당하는 C 변수입니다. &lt;code&gt;&lt;a href=&quot;#PL_DBsingle&quot;&gt;&quot;PL_DBsingle&quot;&lt;/a&gt;&lt;/code&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="24be5dbb481a63442832782f4da3ef4f0dc024ff" translate="yes" xml:space="preserve">
          <source>Trace variable used when Perl is run in debugging mode, with the &lt;b&gt;-d&lt;/b&gt; switch. This is the C variable which corresponds to Perl's $DB::trace variable. See &lt;code&gt;PL_DBsingle&lt;/code&gt; .</source>
          <target state="translated">Perl이 &lt;b&gt;-d&lt;/b&gt; 스위치 와 함께 디버깅 모드에서 실행될 때 사용되는 추적 변수 입니다. 이것은 Perl의 $ DB :: trace 변수에 해당하는 C 변수입니다. &lt;code&gt;PL_DBsingle&lt;/code&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="411aea8f76aef96f5e36c8b291c19e9ceb9466d1" translate="yes" xml:space="preserve">
          <source>Traces changes to Perl's interpreter state. You can internalize this as tracing changes to Perl's &lt;code&gt;${^GLOBAL_PHASE}&lt;/code&gt; variable, especially since the values for &lt;code&gt;NEWPHASE&lt;/code&gt; and &lt;code&gt;OLDPHASE&lt;/code&gt; are the strings that &lt;code&gt;${^GLOBAL_PHASE}&lt;/code&gt; reports.</source>
          <target state="translated">Perl의 인터프리터 상태에 대한 변경 사항을 추적합니다. 특히 &lt;code&gt;NEWPHASE&lt;/code&gt; 및 &lt;code&gt;OLDPHASE&lt;/code&gt; 의 값 이 &lt;code&gt;${^GLOBAL_PHASE}&lt;/code&gt; 가보고 하는 문자열 이므로 Perl의 &lt;code&gt;${^GLOBAL_PHASE}&lt;/code&gt; 변수에 대한 변경 내용을 추적하여이를 내부화 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0786ec1507cde8f738cd5528e03a2b67d40c8c91" translate="yes" xml:space="preserve">
          <source>Traces the entry of any subroutine. Note that all of the variables refer to the subroutine that is being invoked; there is currently no way to get ahold of any information about the subroutine's</source>
          <target state="translated">서브 루틴의 항목을 추적합니다. 모든 변수는 호출되는 서브 루틴을 나타냅니다. 현재 서브 루틴에 대한 정보를 얻을 수있는 방법이 없습니다</target>
        </trans-unit>
        <trans-unit id="9f47af59eb569759ff1e8a42a52da14fba8b1705" translate="yes" xml:space="preserve">
          <source>Traces the execution of each opcode in the Perl runloop. This probe is fired before the opcode is executed. When the Perl debugger is enabled, the DTrace probe is fired</source>
          <target state="translated">Perl runloop에서 각 opcode의 실행을 추적합니다. 이 프로브는 opcode가 실행되기 전에 시작됩니다. Perl 디버거가 활성화되면 DTrace 프로브가 시작됩니다</target>
        </trans-unit>
        <trans-unit id="bbb01fbe6bfaaec090a44633982fb31ae18d0d39" translate="yes" xml:space="preserve">
          <source>Traces the exit of any subroutine. Note that all of the variables refer to the subroutine that is returning; there is currently no way to get ahold of any information about the subroutine's</source>
          <target state="translated">서브 루틴의 종료를 추적합니다. 모든 변수는 리턴되는 서브 루틴을 나타냅니다. 현재 서브 루틴에 대한 정보를 얻을 수있는 방법이 없습니다</target>
        </trans-unit>
        <trans-unit id="469260e080c9b35d7ee5b388f5235f91978c75b9" translate="yes" xml:space="preserve">
          <source>Traditional form:</source>
          <target state="translated">전통적인 형태 :</target>
        </trans-unit>
        <trans-unit id="0ad67b0aa9abbb10a0d4b2ca67f1c4ff5d61a0ed" translate="yes" xml:space="preserve">
          <source>Traditionally END blocks have been executed at the end of the perl_run. This causes problems for applications that never call perl_run. Since perl 5.7.2 you can specify &lt;code&gt;PL_exit_flags |= PERL_EXIT_DESTRUCT_END&lt;/code&gt; to get the new behaviour. This also enables the running of END blocks if the perl_parse fails and &lt;code&gt;perl_destruct&lt;/code&gt; will return the exit value.</source>
          <target state="translated">전통적으로 END 블록은 perl_run의 끝에서 실행되었습니다. perl_run을 호출하지 않는 응용 프로그램에 문제가 발생합니다. perl 5.7.2부터 &lt;code&gt;PL_exit_flags |= PERL_EXIT_DESTRUCT_END&lt;/code&gt; 를 지정 하여 새 동작을 얻을 수 있습니다. 또한 perl_parse가 실패하고 &lt;code&gt;perl_destruct&lt;/code&gt; 가 종료 값을 리턴하는 경우 END 블록을 실행할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0f62d4679a2de6656186513ec5b0145dfd0852c8" translate="yes" xml:space="preserve">
          <source>Traditionally in Perl, any use of any of the three variables &lt;code&gt;$`&lt;/code&gt; , &lt;code&gt;$&amp;amp;&lt;/code&gt; or &lt;code&gt;$'&lt;/code&gt; (or their &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; English&lt;/code&gt; equivalents) anywhere in the code, caused all subsequent successful pattern matches to make a copy of the matched string, in case the code might subsequently access one of those variables. This imposed a considerable performance penalty across the whole program, so generally the use of these variables has been discouraged.</source>
          <target state="translated">전통적으로 Perl에서는 코드 어디에서든 세 개의 변수 &lt;code&gt;$`&lt;/code&gt; , &lt;code&gt;$&amp;amp;&lt;/code&gt; 또는 &lt;code&gt;$'&lt;/code&gt; (또는 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; English&lt;/code&gt; 와 동등한 &lt;a href=&quot;functions/use&quot;&gt;사용&lt;/a&gt; )를 사용 하면 모든 후속 패턴 일치가 일치하는 문자열의 사본을 만들었습니다. 코드는 나중에 해당 변수 중 하나에 액세스 할 수 있습니다. 이로 인해 전체 프로그램에서 상당한 성능 저하가 발생하므로 일반적으로 이러한 변수의 사용을 권장하지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="b39057d081d4426f280d8e658ad98c69967c3dee" translate="yes" xml:space="preserve">
          <source>Traditionally in Perl, any use of any of the three variables &lt;code&gt;$`&lt;/code&gt;, &lt;code&gt;$&amp;amp;&lt;/code&gt; or &lt;code&gt;$'&lt;/code&gt; (or their &lt;code&gt;use English&lt;/code&gt; equivalents) anywhere in the code, caused all subsequent successful pattern matches to make a copy of the matched string, in case the code might subsequently access one of those variables. This imposed a considerable performance penalty across the whole program, so generally the use of these variables has been discouraged.</source>
          <target state="translated">전통적으로 Perl에서는 코드에서 세 가지 변수 &lt;code&gt;$`&lt;/code&gt; , &lt;code&gt;$&amp;amp;&lt;/code&gt; 또는 &lt;code&gt;$'&lt;/code&gt; (또는 이에 상응 &lt;code&gt;use English&lt;/code&gt; ) 중 하나를 사용하면 모든 후속 성공적인 패턴 일치가 일치하는 문자열의 복사본을 만듭니다. 나중에 코드가 이러한 변수 중 하나에 액세스 할 수 있습니다. 이로 인해 전체 프로그램에서 상당한 성능 저하가 발생하므로 일반적으로 이러한 변수를 사용하지 않는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="edc1e4ae8cd5bdd4ef52be4cd619be47a1e80306" translate="yes" xml:space="preserve">
          <source>Traditionally the result is a string of 13 bytes: two first bytes of the salt, followed by 11 bytes from the set &lt;code&gt;[./0-9A-Za-z]&lt;/code&gt;, and only the first eight bytes of PLAINTEXT mattered. But alternative hashing schemes (like MD5), higher level security schemes (like C2), and implementations on non-Unix platforms may produce different strings.</source>
          <target state="translated">전통적으로 결과는 13 바이트의 문자열입니다. 소금의 첫 번째 두 바이트, 그 다음에 세트 &lt;code&gt;[./0-9A-Za-z]&lt;/code&gt; 에서 11 바이트 , PLAINTEXT의 처음 8 바이트 만 중요합니다. 그러나 MD5와 같은 대체 해싱 구성표, C2와 같은 고급 보안 구성표 및 비 유닉스 플랫폼에서의 구현은 다른 문자열을 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="366ba2d0971221ce62e3e700bb5e4027a597313b" translate="yes" xml:space="preserve">
          <source>Traditionally, Perl has captured the value of the variable at that point and turned the subroutine into a constant eligible for inlining. In those cases where the variable can be modified elsewhere, this breaks the behavior of closures, in which the subroutine captures the variable itself, rather than its value, so future changes to the variable are reflected in the subroutine's return value.</source>
          <target state="translated">전통적으로 Perl은 그 시점에서 변수의 가치를 포착하여 서브 루틴을 인라인 할 수있는 상수로 바꿨습니다. 변수를 다른 곳에서 수정할 수있는 경우, 이는 서브 루틴이 값이 아닌 변수 자체를 캡처하는 클로저의 동작을 중단하므로 향후 변수의 변경 사항이 서브 루틴의 리턴 값에 반영됩니다.</target>
        </trans-unit>
        <trans-unit id="77c289ba4e5a8332a82b92e0a687ee8832b65763" translate="yes" xml:space="preserve">
          <source>Traditionally, the Perl function &lt;code&gt;&lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt;&lt;/code&gt; rounds to 0 (see &lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt;), and so for floating-point-like types one should follow the same semantic.</source>
          <target state="translated">전통적으로 Perl 함수 &lt;code&gt;&lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt;&lt;/code&gt; 는 0으로 반올림 되므로 ( &lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt; 참조 ) 부동 소수점 유사 유형의 경우 동일한 의미를 따라야합니다.</target>
        </trans-unit>
        <trans-unit id="adbc09d928775a73e398c4d99047b6c88a5a75f6" translate="yes" xml:space="preserve">
          <source>Traditionally, the Perl function &lt;code&gt;int&lt;/code&gt; rounds to 0 (see &lt;a href=&quot;perlfunc#int&quot;&gt;&quot;int&quot; in perlfunc&lt;/a&gt;), and so for floating-point-like types one should follow the same semantic.</source>
          <target state="translated">전통적으로 Perl 함수 &lt;code&gt;int&lt;/code&gt; 는 0으로 반올림하므로 ( &lt;a href=&quot;perlfunc#int&quot;&gt;perlfunc의 &quot;int&quot;&lt;/a&gt; 참조 ) 부동 소수점 유사 유형의 경우 동일한 의미를 따라야합니다.</target>
        </trans-unit>
        <trans-unit id="b2c93accaaddf881f0426884fd5fb319c6e78ef4" translate="yes" xml:space="preserve">
          <source>Traditionally, the definition of an inside-out class contains a bare block inside which a number of lexical hashes are declared and the basic accessor methods defined, usually through &lt;code&gt;Scalar::Util::refaddr&lt;/code&gt; . Further methods may be defined outside this block. There has to be a DESTROY method and, for thread support, a CLONE method.</source>
          <target state="translated">일반적으로 인사이드 아웃 클래스의 정의에는 다수의 어휘 해시가 선언되는 기본 블록이 포함되어 있으며 일반적으로 &lt;code&gt;Scalar::Util::refaddr&lt;/code&gt; 통해 기본 접근 자 메서드가 정의되어 있습니다. 이 블록 외부에 추가 방법이 정의 될 수 있습니다. 스레드 지원을 위해서는 DESTROY 메소드와 CLONE 메소드가 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="a7bba9f4132fe6d6098df9712bd5f009714f6811" translate="yes" xml:space="preserve">
          <source>Traditionally, the definition of an inside-out class contains a bare block inside which a number of lexical hashes are declared and the basic accessor methods defined, usually through &lt;code&gt;Scalar::Util::refaddr&lt;/code&gt;. Further methods may be defined outside this block. There has to be a DESTROY method and, for thread support, a CLONE method.</source>
          <target state="translated">전통적으로 인사이드-아웃 클래스의 정의에는 많은 어휘 해시가 선언 된 베어 블록과 일반적으로 &lt;code&gt;Scalar::Util::refaddr&lt;/code&gt; 통해 정의 된 기본 접근 자 메서드가 포함되어 있습니다. 이 블록 외부에서 추가 메서드를 정의 할 수 있습니다. DESTROY 메서드와 스레드 지원을 위해 CLONE 메서드가 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="56e30fa719825fef87897a9b73f8c643d6e27859" translate="yes" xml:space="preserve">
          <source>Traditionally, typemaps needed to be written to a separate file, conventionally called &lt;code&gt;typemap&lt;/code&gt; in a CPAN distribution. With ExtUtils::ParseXS (the XS compiler) version 3.12 or better which comes with perl 5.16, typemaps can also be embedded directly into XS code using a HERE-doc like syntax:</source>
          <target state="translated">전통적으로 타입 &lt;code&gt;typemap&lt;/code&gt; 은 CPAN 배포에서 타입 맵 이라고하는 별도의 파일에 기록되어야했습니다 . Perl 5.16과 함께 제공되는 ExtUtils :: ParseXS (XS 컴파일러) 버전 3.12 이상에서는 다음과 같은 구문을 사용하여 typemap을 XS 코드에 직접 포함시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="09f8c62448637990777ebfc05ef92616935bd9ae" translate="yes" xml:space="preserve">
          <source>Trailing \ in regex m/%s/</source>
          <target state="translated">정규식 m / % s /의 후행 \</target>
        </trans-unit>
        <trans-unit id="b116d15c8d0f591aea30acc14d32c8151254d15b" translate="yes" xml:space="preserve">
          <source>Transfer file in ASCII. CRLF translation will be done if required</source>
          <target state="translated">ASCII로 파일을 전송하십시오. 필요한 경우 CRLF 번역이 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="19b93b66a9a164099cf4c3e60d4b5f7a2c5a7780" translate="yes" xml:space="preserve">
          <source>Transfer file in binary mode. No transformation will be done.</source>
          <target state="translated">이진 모드로 파일을 전송하십시오. 변환이 수행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="71b54b146f4723aa8db4c8d0ffb0816f4aee31ad" translate="yes" xml:space="preserve">
          <source>Transforms the current application into a PM application and back. The argument true means that a real message loop is going to be served. OS2::MorphPM() returns the PM message queue handle as an integer.</source>
          <target state="translated">현재 응용 프로그램을 PM 응용 프로그램으로 변환합니다. true 인수는 실제 메시지 루프가 제공됨을 의미합니다. OS2 :: MorphPM ()은 PM 메시지 큐 핸들을 정수로 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="45a38a062b50bb87ecbfadb79c2d11cbaef46742" translate="yes" xml:space="preserve">
          <source>Transition notes when upgrading to Test2</source>
          <target state="translated">Test2로 업그레이드 할 때의 전환 참고 사항</target>
        </trans-unit>
        <trans-unit id="3ab5267ee01682b79d53eef55a6ec4c6169897d2" translate="yes" xml:space="preserve">
          <source>Translate logical name DCL$PATH as a searchlist, rather than trying to &lt;code&gt;&lt;a href=&quot;../../functions/split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; string value of &lt;code&gt;$ENV{'PATH'}&lt;/code&gt; .</source>
          <target state="translated">문자열 값 &lt;code&gt;$ENV{'PATH'}&lt;/code&gt; 를 &lt;code&gt;&lt;a href=&quot;../../functions/split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; 하지 않고 논리 이름 DCL $ PATH를 검색 목록으로 변환하십시오 .</target>
        </trans-unit>
        <trans-unit id="ff6fe6980843b217b9b010e6374cc31ac52dccf0" translate="yes" xml:space="preserve">
          <source>Translate logical name DCL$PATH as a searchlist, rather than trying to &lt;code&gt;split&lt;/code&gt; string value of &lt;code&gt;$ENV{'PATH'}&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;$ENV{'PATH'}&lt;/code&gt; 의 문자열 값 을 &lt;code&gt;split&lt;/code&gt; 하지 않고 논리적 이름 DCL $ PATH를 검색 목록으로 변환하십시오 .</target>
        </trans-unit>
        <trans-unit id="4df3684f8e1af9f3d36ff43ec1a39944ea62d252" translate="yes" xml:space="preserve">
          <source>Translates a Windows path to the corresponding cygwin path respecting the current mount points. With a second non-null argument returns an absolute path. Double-byte characters will not be translated.</source>
          <target state="translated">현재 마운트 지점을 기준으로 해당 cygwin 경로로 Windows 경로를 변환합니다. 두 번째 널이 아닌 인수를 사용하면 절대 경로가 리턴됩니다. 더블 바이트 문자는 번역되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="43c8972cdf7cbd4964f60ea0553934fab0c0bfe0" translate="yes" xml:space="preserve">
          <source>Translates a Windows pid to the corresponding cygwin pid (if any).</source>
          <target state="translated">Windows pid를 해당 cygwin pid (있는 경우)로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="582d5dcb01cd3d8be49a7bc9c562cc61d6d3a8c7" translate="yes" xml:space="preserve">
          <source>Translates a cygwin path to the corresponding cygwin path respecting the current mount points. With a second non-null argument returns an absolute path. Double-byte characters will not be translated.</source>
          <target state="translated">cygwin 경로를 현재 마운트 지점을 기준으로 해당 cygwin 경로로 변환합니다. 두 번째 널이 아닌 인수를 사용하면 절대 경로가 리턴됩니다. 더블 바이트 문자는 번역되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d0b7e8b1f9fa64e7df02a610ac8f751cbf79794f" translate="yes" xml:space="preserve">
          <source>Translates a cygwin pid to the corresponding Windows pid (which may or may not be the same).</source>
          <target state="translated">cygwin pid를 해당 Windows pid (동일하거나 동일하지 않음)로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="3cb9f5d38a91da3cb24f8ddc9ee0b78bc3316e7d" translate="yes" xml:space="preserve">
          <source>Translates the template as before except that a directory name is specified.</source>
          <target state="translated">디렉토리 이름이 지정된 것을 제외하고 템플리트를 이전과 같이 변환합니다.</target>
        </trans-unit>
        <trans-unit id="0e0c59b2d3a94d773b16fba8c10f9e6b9a4c8d83" translate="yes" xml:space="preserve">
          <source>Translators are available for converting Pod to various formats like plain text, HTML, man pages, and more.</source>
          <target state="translated">번역기를 사용하여 포드를 일반 텍스트, HTML, 매뉴얼 페이지 등과 같은 다양한 형식으로 변환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3d02c52d09a4e30f9d862205070306d13e0fd4bf" translate="yes" xml:space="preserve">
          <source>Translators may request clarification of the situation in which a particular phrase is found. For example, in English we are entirely happy saying &quot;</source>
          <target state="translated">번역 사는 특정 문구가 발견 된 상황에 대한 설명을 요청할 수 있습니다. 예를 들어 영어로 &quot;</target>
        </trans-unit>
        <trans-unit id="7cec7716cf837c5d26e64202c8e48b66fd1ee111" translate="yes" xml:space="preserve">
          <source>Transliterate characters missing in encoding to &amp;amp;#NNN; where NNN is the decimal Unicode code point.</source>
          <target state="translated">인코딩 할 때 문자를 &amp;amp; # NNN; 여기서 NNN은 십진 유니 코드 코드 포인트입니다.</target>
        </trans-unit>
        <trans-unit id="4a944de5b3bc5a013582ea0515548fdc64b85e91" translate="yes" xml:space="preserve">
          <source>Transliterate characters missing in encoding to &amp;amp;#xHHHH; where HHHH is the hexadecimal Unicode code point.</source>
          <target state="translated">&amp;amp; # xHHHH;로 인코딩 할 때 문자를 음역하지 못합니다. 여기서 HHHH는 16 진 유니 코드 코드 포인트입니다.</target>
        </trans-unit>
        <trans-unit id="7531ab4c38b927cd6bd26046089b6f931f4b9669" translate="yes" xml:space="preserve">
          <source>Transliterate characters missing in encoding to \x{HHHH} where HHHH is the hexadecimal Unicode code point.</source>
          <target state="translated">인코딩시 \ x {HHHH}로 음역 문자가 누락되었습니다. 여기서 HHHH는 16 진수 유니 코드 코드 포인트입니다.</target>
        </trans-unit>
        <trans-unit id="41fb5a616fd328877f09027e33238e8f08b825a7" translate="yes" xml:space="preserve">
          <source>Transliterates all occurrences of the characters found (or not found if the &lt;code&gt;/c&lt;/code&gt; modifier is specified) in the search list with the positionally corresponding character in the replacement list, possibly deleting some, depending on the modifiers specified. It returns the number of characters replaced or deleted. If no string is specified via the &lt;code&gt;=~&lt;/code&gt; or &lt;code&gt;!~&lt;/code&gt; operator, the &lt;code&gt;$_&lt;/code&gt; string is transliterated.</source>
          <target state="translated">검색 목록에서 발견 된 (또는 &lt;code&gt;/c&lt;/code&gt; 수정자가 지정된 경우 찾을 수없는) 모든 문자를 대체 목록에서 위치 적으로 해당하는 문자로 음역하여 지정된 수정 자에 따라 일부를 삭제할 수 있습니다. 대체되거나 삭제 된 문자 수를 반환합니다. &lt;code&gt;=~&lt;/code&gt; 또는 &lt;code&gt;!~&lt;/code&gt; 연산자 를 통해 지정된 문자열이 없으면 &lt;code&gt;$_&lt;/code&gt; 문자열이 음역됩니다.</target>
        </trans-unit>
        <trans-unit id="778ddecb6dcc9c5eac19efad6822ed838d8cfd37" translate="yes" xml:space="preserve">
          <source>Transliterates all occurrences of the characters found in the search list with the corresponding character in the replacement list. It returns the number of characters replaced or deleted. If no string is specified via the &lt;code&gt;=~&lt;/code&gt; or &lt;code&gt;!~&lt;/code&gt; operator, the &lt;code&gt;$_&lt;/code&gt; string is transliterated.</source>
          <target state="translated">검색 목록에서 찾은 모든 문자를 대체 목록의 해당 문자로 음역합니다. 교체되거나 삭제 된 문자 수를 반환합니다. &lt;code&gt;=~&lt;/code&gt; 또는 &lt;code&gt;!~&lt;/code&gt; 연산자 를 통해 문자열을 지정하지 않으면 &lt;code&gt;$_&lt;/code&gt; 문자열이 음역됩니다.</target>
        </trans-unit>
        <trans-unit id="31352bae87fe97a737e1fbb74f2d29f6b62133a0" translate="yes" xml:space="preserve">
          <source>Transliteration pattern not terminated</source>
          <target state="translated">음역 패턴이 종료되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="a70808fd22f433d5ec8e8c5f0aad4eb5242bb686" translate="yes" xml:space="preserve">
          <source>Transliteration replacement not terminated</source>
          <target state="translated">음역 대체가 종료되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="420a5e0771ab4a0b9e610c4b35eccba70828962b" translate="yes" xml:space="preserve">
          <source>Transparent BigInteger support for Perl</source>
          <target state="translated">Perl에 대한 투명한 BigInteger 지원</target>
        </trans-unit>
        <trans-unit id="7267fd5dd0f2d5cad0d4fdfbc6f406231fbc74c7" translate="yes" xml:space="preserve">
          <source>Transparent BigNumber support for Perl</source>
          <target state="translated">Perl에 대한 투명한 BigNumber 지원</target>
        </trans-unit>
        <trans-unit id="d53f15081d775673dd122d267a0fda505ffa50fe" translate="yes" xml:space="preserve">
          <source>Transparent BigNumber/BigRational support for Perl</source>
          <target state="translated">Perl에 대한 투명한 BigNumber / BigRational 지원</target>
        </trans-unit>
        <trans-unit id="1320fa0059bd04032c977af604f63823046e2bca" translate="yes" xml:space="preserve">
          <source>Trappable errors may be trapped using the eval operator. See &lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;. In almost all cases, warnings may be selectively disabled or promoted to fatal errors using the &lt;code&gt;warnings&lt;/code&gt; pragma. See &lt;a href=&quot;warnings&quot;&gt;warnings&lt;/a&gt;.</source>
          <target state="translated">평가 연산자를 사용하면 트래핑 가능한 오류가 발생할 수 있습니다. &lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; 참조하십시오 . 거의 모든 경우에 &lt;code&gt;warnings&lt;/code&gt; pragma를 사용하여 경고 를 선택적으로 비활성화하거나 치명적 오류로 승격시킬 수 있습니다 . &lt;a href=&quot;warnings&quot;&gt;경고를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="9594e634fc8d3b1ced220c4bc1c7249b17dcfd33" translate="yes" xml:space="preserve">
          <source>Trappable errors may be trapped using the eval operator. See &lt;a href=&quot;perlfunc#eval&quot;&gt;&quot;eval&quot; in perlfunc&lt;/a&gt;. In almost all cases, warnings may be selectively disabled or promoted to fatal errors using the &lt;code&gt;warnings&lt;/code&gt; pragma. See &lt;a href=&quot;warnings&quot;&gt;warnings&lt;/a&gt;.</source>
          <target state="translated">eval 연산자를 사용하여 트랩 가능한 오류를 트랩 할 수 있습니다. &lt;a href=&quot;perlfunc#eval&quot;&gt;perlfunc의 &quot;eval&quot;을&lt;/a&gt; 참조하십시오 . 거의 모든 경우에 &lt;code&gt;warnings&lt;/code&gt; pragma를 사용하여 경고 를 선택적으로 비활성화하거나 치명적인 오류로 승격시킬 수 있습니다 . &lt;a href=&quot;warnings&quot;&gt;경고를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a51ac6ee368e2e9218baa833ba69372fe936aae9" translate="yes" xml:space="preserve">
          <source>Trapping $SIG {__DIE__} other than during program exit.</source>
          <target state="translated">프로그램 종료 중에 $ SIG {__DIE__} 트래핑.</target>
        </trans-unit>
        <trans-unit id="17b071b49543aa19f12f2274e32fe9c1ba934844" translate="yes" xml:space="preserve">
          <source>Trapping &lt;code&gt;$SIG {__DIE__}&lt;/code&gt; other than during program exit.</source>
          <target state="translated">프로그램 종료 중에 &lt;code&gt;$SIG {__DIE__}&lt;/code&gt; 트래핑 .</target>
        </trans-unit>
        <trans-unit id="7f10d4d7cb6294c3306a64ba2969b74200be2428" translate="yes" xml:space="preserve">
          <source>Traverse a directory tree.</source>
          <target state="translated">디렉토리 트리를 탐색하십시오.</target>
        </trans-unit>
        <trans-unit id="b2a99160c9547d1ab75aaa55623e70b1b8573818" translate="yes" xml:space="preserve">
          <source>Treat string as multiple lines. That is, change &quot;^&quot; and &quot;$&quot; from matching the start of the string's first line and the end of its last line to matching the start and end of each line within the string.</source>
          <target state="translated">문자열을 여러 줄로 취급하십시오. 즉, &quot;^&quot;및 &quot;$&quot;는 문자열의 첫 번째 줄의 시작과 마지막 줄의 끝을 일치시키는 것에서 문자열 내 각 줄의 시작과 끝을 일치시키는 것으로 변경하십시오.</target>
        </trans-unit>
        <trans-unit id="93fa15e2fd4bd3f0707530f7f374f8fd00c44547" translate="yes" xml:space="preserve">
          <source>Treat string as single line. That is, change &quot;.&quot; to match any character whatsoever, even a newline, which normally it would not match.</source>
          <target state="translated">문자열을 한 줄로 취급하십시오. 즉, &quot;.&quot;를 변경하십시오. 줄 바꿈과 같은 문자를 일치 시키려면 일반적으로 일치하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="78e54c9da655d8dd5d453436c311823f0a02dca4" translate="yes" xml:space="preserve">
          <source>Treat the string as single line. That is, change &lt;code&gt;&quot;.&quot;&lt;/code&gt; to match any character whatsoever, even a newline, which normally it would not match.</source>
          <target state="translated">문자열을 한 줄로 처리합니다. 즉, &lt;code&gt;&quot;.&quot;&lt;/code&gt; 를 변경 합니다. 일반적으로 일치하지 않는 개행 문자를 포함하여 모든 문자와 일치합니다.</target>
        </trans-unit>
        <trans-unit id="72ce43ffe9e36e380be02d47d4ca4755e5f762f0" translate="yes" xml:space="preserve">
          <source>Treat the string being matched against as multiple lines. That is, change &lt;code&gt;&quot;^&quot;&lt;/code&gt; and &lt;code&gt;&quot;$&quot;&lt;/code&gt; from matching the start of the string's first line and the end of its last line to matching the start and end of each line within the string.</source>
          <target state="translated">일치하는 문자열을 여러 줄로 처리합니다. 즉, &lt;code&gt;&quot;^&quot;&lt;/code&gt; 및 &lt;code&gt;&quot;$&quot;&lt;/code&gt; 를 문자열의 첫 번째 줄의 시작과 마지막 줄의 끝을 일치에서 문자열 내 각 줄의 시작과 끝을 일치시키는 것으로 변경합니다.</target>
        </trans-unit>
        <trans-unit id="13d54adba605a60e729039d50fd8ece1d374030c" translate="yes" xml:space="preserve">
          <source>Treating errors reported by OS/2 API</source>
          <target state="translated">OS / 2 API에서보고 한 오류 처리</target>
        </trans-unit>
        <trans-unit id="369a3fe575602256c74f237530b2066156aadc25" translate="yes" xml:space="preserve">
          <source>Treats ARRAY as a stack by appending the values of LIST to the end of ARRAY. The length of ARRAY increases by the length of LIST. Has the same effect as</source>
          <target state="translated">LIST의 값을 ARRAY의 끝에 추가하여 ARRAY를 스택으로 취급합니다. ARRAY의 길이는 LIST의 길이만큼 증가합니다. 같은 효과가 있습니다</target>
        </trans-unit>
        <trans-unit id="4c2b22d2044144acb2e177299ffb0546b35d1302" translate="yes" xml:space="preserve">
          <source>Treats the complete zip file/buffer as a single compressed data stream. When reading in multi-stream mode each member of the zip file/buffer will be uncompressed in turn until the end of the file/buffer is encountered.</source>
          <target state="translated">완전한 zip 파일 / 버퍼를 단일 압축 데이터 스트림으로 취급합니다. 멀티 스트림 모드에서 읽을 때 zip 파일 / 버퍼의 각 멤버는 파일 / 버퍼의 끝이 나올 때까지 차례로 압축 해제됩니다.</target>
        </trans-unit>
        <trans-unit id="9170df3df869288dce7be7560494463cb05b5488" translate="yes" xml:space="preserve">
          <source>Treats the return value of the code block as the condition.</source>
          <target state="translated">코드 블록의 반환 값을 조건으로 취급합니다.</target>
        </trans-unit>
        <trans-unit id="a635e53ae97925c0c25ad3ddaf7be47457bf89eb" translate="yes" xml:space="preserve">
          <source>Treats the return value of the code block as the condition. Full syntax: &lt;code&gt;(?(?{ &lt;i&gt;code&lt;/i&gt; })&lt;i&gt;then&lt;/i&gt;|&lt;i&gt;else&lt;/i&gt;)&lt;/code&gt;</source>
          <target state="translated">코드 블록의 반환 값을 조건으로 처리합니다. 전체 구문 : &lt;code&gt;(?(?{ &lt;i&gt;code&lt;/i&gt; })&lt;i&gt;then&lt;/i&gt;|&lt;i&gt;else&lt;/i&gt;)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="076fbc2c1d84c79c360a6aaf693ed414200277af" translate="yes" xml:space="preserve">
          <source>Treats the string in EXPR as a bit vector made up of elements of width BITS and returns the value of the element specified by OFFSET as an unsigned integer. BITS therefore specifies the number of bits that are reserved for each element in the bit vector. This must be a power of two from 1 to 32 (or 64, if your platform supports that).</source>
          <target state="translated">EXPR의 문자열을 너비 BITS의 요소로 구성된 비트 벡터로 취급하고 OFFSET로 지정된 요소의 값을 부호없는 정수로 리턴합니다. 따라서 BITS는 비트 벡터의 각 요소에 예약 된 비트 수를 지정합니다. 1에서 32 사이의 2의 제곱이어야합니다 (또는 플랫폼에서 지원하는 경우 64).</target>
        </trans-unit>
        <trans-unit id="74c726e22e1ef4f0ff5d0f342fa4b671a8d7e3e6" translate="yes" xml:space="preserve">
          <source>Tree Contents</source>
          <target state="translated">나무 내용</target>
        </trans-unit>
        <trans-unit id="bc924ad99a31c83efb674a21a76798fdb63e8535" translate="yes" xml:space="preserve">
          <source>Tries to &lt;code&gt;&lt;a href=&quot;../functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; the given $module or $file. If it loads successfully, the test will pass. Otherwise it fails and displays the load error.</source>
          <target state="translated">주어진 $ module 또는 $ file 을 &lt;code&gt;&lt;a href=&quot;../functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; 합니다. 성공적으로로드되면 테스트에 통과합니다. 그렇지 않으면 실패하고로드 오류를 표시합니다.</target>
        </trans-unit>
        <trans-unit id="9e432f6da17926a8d04f67b7c7b25438f0d2078a" translate="yes" xml:space="preserve">
          <source>Tries to &lt;code&gt;require&lt;/code&gt; the given $module or $file. If it loads successfully, the test will pass. Otherwise it fails and displays the load error.</source>
          <target state="translated">주어진 $ module 또는 $ file 을 &lt;code&gt;require&lt;/code&gt; 하려고 합니다. 성공적으로로드되면 테스트가 통과됩니다. 그렇지 않으면 실패하고로드 오류를 표시합니다.</target>
        </trans-unit>
        <trans-unit id="82437a05f154f78a4ae190392aa21b46338d0c97" translate="yes" xml:space="preserve">
          <source>Tries to uses &lt;a href=&quot;../../../ipc/open3&quot;&gt;IPC::Open3&lt;/a&gt; &amp;amp; &lt;a href=&quot;../../../io/select&quot;&gt;IO::Select&lt;/a&gt; to communicate with the spawned process if they are available. Falls back onto &lt;code&gt;&lt;a href=&quot;../../../functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;../../../ipc/open3&quot;&gt;IPC :: Open3&lt;/a&gt; &amp;amp; &lt;a href=&quot;../../../io/select&quot;&gt;IO ::&lt;/a&gt; 를 사용하려고 시도합니다. 사용 가능한 경우 생성 된 프로세스와 통신하려면 선택하십시오 . &lt;code&gt;&lt;a href=&quot;../../../functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; 으로 폴백 합니다.</target>
        </trans-unit>
        <trans-unit id="576659556d288e025b94f7ce5ace34cc997c7d54" translate="yes" xml:space="preserve">
          <source>Tries to uses &lt;a href=&quot;IPC::Open3&quot;&gt;IPC::Open3&lt;/a&gt; &amp;amp; &lt;a href=&quot;IO::Select&quot;&gt;IO::Select&lt;/a&gt; to communicate with the spawned process if they are available. Falls back onto &lt;code&gt;open()&lt;/code&gt;.</source>
          <target state="translated">사용하려고 &lt;a href=&quot;IPC::Open3&quot;&gt;IPC :: 된 Open3&lt;/a&gt; 및 &lt;a href=&quot;IO::Select&quot;&gt;IO :: 선택은&lt;/a&gt; 그들이 사용할 수있는 경우 생성 된 프로세스와 통신합니다. &lt;code&gt;open()&lt;/code&gt; 돌아갑니다 .</target>
        </trans-unit>
        <trans-unit id="d0328d99f96d6b6cb2e5370be4979de91fb2ea44" translate="yes" xml:space="preserve">
          <source>Triggered by a delete from %^H, records the key to &lt;code&gt;PL_compiling.cop_hints_hash&lt;/code&gt; .</source>
          <target state="translated">% ^ H에서의 삭제에 의해 트리거되어 &lt;code&gt;PL_compiling.cop_hints_hash&lt;/code&gt; 의 키를 기록합니다 .</target>
        </trans-unit>
        <trans-unit id="4b83192144a37d41cc56666387a2897c4231e185" translate="yes" xml:space="preserve">
          <source>Triggered by a delete from &lt;code&gt;%^H&lt;/code&gt;, records the key to &lt;code&gt;PL_compiling.cop_hints_hash&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;%^H&lt;/code&gt; 에서 삭제에 의해 트리거되며 키를 &lt;code&gt;PL_compiling.cop_hints_hash&lt;/code&gt; 에 기록합니다 .</target>
        </trans-unit>
        <trans-unit id="ce25e5857867e6310e792d455213353087781834" translate="yes" xml:space="preserve">
          <source>Triggered by a store to %^H, records the key/value pair to &lt;code&gt;PL_compiling.cop_hints_hash&lt;/code&gt; . It is assumed that hints aren't storing anything that would need a deep copy. Maybe we should warn if we find a reference.</source>
          <target state="translated">% ^ H에 대한 상점에 ​​의해 트리거되어 키 / 값 쌍을 &lt;code&gt;PL_compiling.cop_hints_hash&lt;/code&gt; 에 기록합니다 . 힌트는 딥 카피가 필요한 것을 저장하지 않는 것으로 가정합니다. 참조를 찾으면 경고해야 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="d308cd2f0c07029bd86f512d81284ed366f6c445" translate="yes" xml:space="preserve">
          <source>Triggered by a store to &lt;code&gt;%^H&lt;/code&gt;, records the key/value pair to &lt;code&gt;PL_compiling.cop_hints_hash&lt;/code&gt;. It is assumed that hints aren't storing anything that would need a deep copy. Maybe we should warn if we find a reference.</source>
          <target state="translated">&lt;code&gt;%^H&lt;/code&gt; 에 대한 저장소에 의해 트리거되며 키 / 값 쌍을 &lt;code&gt;PL_compiling.cop_hints_hash&lt;/code&gt; 에 기록합니다 . 힌트는 딥 카피가 필요한 것을 저장하지 않는다고 가정합니다. 참고 문헌을 찾으면 경고해야 할 수도 있습니다. ㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ</target>
        </trans-unit>
        <trans-unit id="5e62fd5a7239de339d5bd00c0d3006bd6b133b17" translate="yes" xml:space="preserve">
          <source>Triggered by clearing %^H, resets &lt;code&gt;PL_compiling.cop_hints_hash&lt;/code&gt; .</source>
          <target state="translated">% ^ H를 지우면 트리거되며 &lt;code&gt;PL_compiling.cop_hints_hash&lt;/code&gt; 가 재설정 됩니다 .</target>
        </trans-unit>
        <trans-unit id="7b8a309606a54a3100175b28554ebbc2c0bf40e9" translate="yes" xml:space="preserve">
          <source>Triggered by clearing &lt;code&gt;%^H&lt;/code&gt;, resets &lt;code&gt;PL_compiling.cop_hints_hash&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;%^H&lt;/code&gt; 를 지우면 트리거되며 &lt;code&gt;PL_compiling.cop_hints_hash&lt;/code&gt; 를 재설정합니다 .</target>
        </trans-unit>
        <trans-unit id="b9e4c026492c440bf32166e0789393487d03b254" translate="yes" xml:space="preserve">
          <source>Trigonometric functions</source>
          <target state="translated">삼각 함수</target>
        </trans-unit>
        <trans-unit id="ce550b5479caa5cd0ed1b0d59ad15c9773c7bcdb" translate="yes" xml:space="preserve">
          <source>Trilogy, &lt;code&gt;In the beginning the
Universe was created. This has made a lot of people very angry and
been widely regarded as a bad move&lt;/code&gt; . Their mistake was not of this magnitude so let's forgive them.</source>
          <target state="translated">3 부작, &lt;code&gt;In the beginning the Universe was created. This has made a lot of people very angry and been widely regarded as a bad move&lt;/code&gt; . 그들의 실수는이 정도가 아니 었으므로 용서합시다.</target>
        </trans-unit>
        <trans-unit id="bd5caa14d9ae02b51776bb926be345cdff071829" translate="yes" xml:space="preserve">
          <source>Trilogy, &lt;code&gt;In the beginning the Universe was created. This has made a lot of people very angry and been widely regarded as a bad move&lt;/code&gt;. Their mistake was not of this magnitude so let's forgive them.</source>
          <target state="translated">삼부작, &lt;code&gt;In the beginning the Universe was created. This has made a lot of people very angry and been widely regarded as a bad move&lt;/code&gt; . 그들의 실수는이 정도의 규모가 아니 었으니 용서합시다.</target>
        </trans-unit>
        <trans-unit id="285ec850c11d78bac10f6bfa31b69a37f1b257c9" translate="yes" xml:space="preserve">
          <source>Troubleshooting</source>
          <target state="translated">Troubleshooting</target>
        </trans-unit>
        <trans-unit id="28e5d7df36d1a6dde25f3c09a31821344957a89c" translate="yes" xml:space="preserve">
          <source>Troubleshooting these Examples</source>
          <target state="translated">이 예제 문제 해결</target>
        </trans-unit>
        <trans-unit id="95a9fcae6cc7c433c5ecb181677d9e65f088ed3c" translate="yes" xml:space="preserve">
          <source>Tru64 5.1 documentation on syslog, &lt;a href=&quot;http://h30097.www3.hp.com/docs/base_doc/DOCUMENTATION/V51_HTML/MAN/MAN3/0193____.HTM&quot;&gt;http://h30097.www3.hp.com/docs/base_doc/DOCUMENTATION/V51_HTML/MAN/MAN3/0193____.HTM&lt;/a&gt;</source>
          <target state="translated">Syslog에 대한 Tru64 5.1 설명서, &lt;a href=&quot;http://h30097.www3.hp.com/docs/base_doc/DOCUMENTATION/V51_HTML/MAN/MAN3/0193____.HTM&quot;&gt;http://h30097.www3.hp.com/docs/base_doc/DOCUMENTATION/V51_HTML/MAN/MAN3/0193____.HTM&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="048a8987b7e7ec2f729db8f1f26dbe354039d137" translate="yes" xml:space="preserve">
          <source>Tru64 documentation on syslog, &lt;a href=&quot;http://nixdoc.net/man-pages/Tru64/man3/syslog.3.html&quot;&gt;http://nixdoc.net/man-pages/Tru64/man3/syslog.3.html&lt;/a&gt;</source>
          <target state="translated">syslog의 Tru64 문서, &lt;a href=&quot;http://nixdoc.net/man-pages/Tru64/man3/syslog.3.html&quot;&gt;http://nixdoc.net/man-pages/Tru64/man3/syslog.3.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="23888b0b14d45068fea9c016be17513c2fc8f457" translate="yes" xml:space="preserve">
          <source>True color and aliases are not supported by the constant interface.</source>
          <target state="translated">트루 컬러 및 별칭은 상수 인터페이스에서 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2032ae3fd0b83aa79eef0ab641b287df415a0ffd" translate="yes" xml:space="preserve">
          <source>True if all testing should be halted immediately.</source>
          <target state="translated">모든 테스트를 즉시 중지해야하는 경우 참입니다.</target>
        </trans-unit>
        <trans-unit id="9109071ad135094f2373ecd2b94d8dc48e87efa6" translate="yes" xml:space="preserve">
          <source>True if an external</source>
          <target state="translated">외부인 경우 참</target>
        </trans-unit>
        <trans-unit id="3d8c968cafa644831ebe062927600b2f8922bcb7" translate="yes" xml:space="preserve">
          <source>True if and only if the version object was created with a underscore, e.g.</source>
          <target state="translated">버전 객체가 밑줄로 생성 된 경우에만 true입니다. 예 :</target>
        </trans-unit>
        <trans-unit id="f3a74362a5094d39f2b42a3da4ab4b28a9691928" translate="yes" xml:space="preserve">
          <source>True if on an OS where qx operator (or backticks) can redirect &lt;code&gt;STDERR&lt;/code&gt; onto &lt;code&gt;STDOUT&lt;/code&gt; .</source>
          <target state="translated">qx 연산자 (또는 백틱)가 &lt;code&gt;STDERR&lt;/code&gt; 을 &lt;code&gt;STDOUT&lt;/code&gt; 으로 경로 재 지정할 수있는 OS에서 true 입니다.</target>
        </trans-unit>
        <trans-unit id="93fe8e82ddc3a4dc6131ed9782aa5f9370ee777e" translate="yes" xml:space="preserve">
          <source>True if on an OS where qx operator (or backticks) can redirect &lt;code&gt;STDERR&lt;/code&gt; onto &lt;code&gt;STDOUT&lt;/code&gt;.</source>
          <target state="translated">qx 연산자 (또는 백틱)가 &lt;code&gt;STDERR&lt;/code&gt; 을 &lt;code&gt;STDOUT&lt;/code&gt; 으로 리디렉션 할 수있는 OS에서 true 입니다.</target>
        </trans-unit>
        <trans-unit id="2ac2287aae7e1950a35f3972fa5317afd518e160" translate="yes" xml:space="preserve">
          <source>True if the &lt;code&gt;callback($hub)&lt;/code&gt; method on the event should be called.</source>
          <target state="translated">이벤트 의 &lt;code&gt;callback($hub)&lt;/code&gt; 메서드를 호출해야하는 경우 True 입니다.</target>
        </trans-unit>
        <trans-unit id="69954ea7da329e8cdabdea3ecd3ac1d75fce20fd" translate="yes" xml:space="preserve">
          <source>True if the assertion passed.</source>
          <target state="translated">어설 션이 통과되면 참입니다.</target>
        </trans-unit>
        <trans-unit id="df801d4537bfb58354fb108cdce7113cab9309ef" translate="yes" xml:space="preserve">
          <source>True if the event contains diagnostics info. This is useful because a non-verbose harness may choose to hide events that are not in this category. Some formatters may choose to send these to STDERR instead of STDOUT to ensure they are seen.</source>
          <target state="translated">이벤트에 진단 정보가 포함 된 경우 True입니다. 이것은 상세하지 않은 하네스가이 범주에 속하지 않는 이벤트를 숨기도록 선택할 수 있기 때문에 유용합니다. 일부 포맷터는 STDOUT 대신 STDERR로 전송하여 표시되도록 선택할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="54a8b59f97958ff045f6c01f8b83b5a2e2ebdf5c" translate="yes" xml:space="preserve">
          <source>True if the event is global in nature and should be seen by all hubs.</source>
          <target state="translated">이벤트가 본질적으로 글로벌이고 모든 허브에서 표시되어야하는 경우 true입니다.</target>
        </trans-unit>
        <trans-unit id="edd2a61baedabf880cbaef8af523d638bf533482" translate="yes" xml:space="preserve">
          <source>True if the event should be skipped by formatters.</source>
          <target state="translated">포맷터가 이벤트를 건너 뛰어야하는 경우 True입니다.</target>
        </trans-unit>
        <trans-unit id="0ea7f713bb50ee451a6daabd00c2427e62cfb9f7" translate="yes" xml:space="preserve">
          <source>True if the event was buffered and not sent to the formatter independent of a parent (This should never be set when nested is &lt;code&gt;0&lt;/code&gt; or &lt;code&gt;undef&lt;/code&gt;).</source>
          <target state="translated">이벤트가 버퍼링되고 부모와 독립적으로 포맷터로 전송되지 않은 경우 참 (중첩이 &lt;code&gt;0&lt;/code&gt; 또는 &lt;code&gt;undef&lt;/code&gt; 인 경우 설정해서는 안 됨 ).</target>
        </trans-unit>
        <trans-unit id="52369ee8420cce3f1adcdcc979064876449bf33b" translate="yes" xml:space="preserve">
          <source>True if the socket is currently positioned at the urgent data mark, false otherwise.</source>
          <target state="translated">소켓이 현재 긴급 데이터 표시에 있으면 true이고, 그렇지 않으면 false입니다.</target>
        </trans-unit>
        <trans-unit id="eac6f6323bc5d7181c78c2fb3ebd2b5d82dd47f8" translate="yes" xml:space="preserve">
          <source>True if the socket is currently positioned at the urgent data mark, false otherwise. If your system doesn't yet implement &lt;code&gt;sockatmark&lt;/code&gt; this will throw an exception.</source>
          <target state="translated">소켓이 현재 긴급 데이터 표시에 있으면 true이고 그렇지 않으면 false입니다. 시스템이 아직 &lt;code&gt;sockatmark&lt;/code&gt; 를 구현하지 않으면 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="263df4a03022b2922b4599d5befe15e4f094944e" translate="yes" xml:space="preserve">
          <source>True if the source has meta data.</source>
          <target state="translated">소스에 메타 데이터가 있으면 참입니다.</target>
        </trans-unit>
        <trans-unit id="1060dac952d58237b926360d8015317b306f2cf6" translate="yes" xml:space="preserve">
          <source>True if the subtest is buffered (meaning the formatter has probably not seen them yet).</source>
          <target state="translated">하위 테스트가 버퍼링 된 경우 참 (포맷터에서 아직 보지 못했을 것임).</target>
        </trans-unit>
        <trans-unit id="ead298b6e06af0e6aa6b218dfc1434b74a59946d" translate="yes" xml:space="preserve">
          <source>True if the subtest is buffered, that is all subevents render at once. If this is false it means all subevents render as they are produced.</source>
          <target state="translated">하위 테스트가 버퍼링 된 경우 참, 즉 모든 하위 이벤트가 한 번에 렌더링됩니다. 이것이 거짓이면 모든 하위 이벤트가 생성 될 때 렌더링됨을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="f4532ad71a145630727fdc99e9e7077d2ca07a8f" translate="yes" xml:space="preserve">
          <source>True if the system can really fork. This will be false for systems where fork is emulated.</source>
          <target state="translated">시스템이 실제로 포크 할 수 있으면 참입니다. fork가 에뮬레이트되는 시스템에서는 거짓입니다.</target>
        </trans-unit>
        <trans-unit id="a5626c52704625d46d51a67bed3154dc66584552" translate="yes" xml:space="preserve">
          <source>True if the testing has ended. This MAY return the stack frame of the tool that ended the test, but that is not guaranteed.</source>
          <target state="translated">테스트가 종료 된 경우 참입니다. 이것은 테스트를 종료 한 도구의 스택 프레임을 반환 할 수 있지만 보장되지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="001c945275af8c53e929fc8bb52b9331e9fa2beb" translate="yes" xml:space="preserve">
          <source>True if this op will be the return value of an lvalue subroutine</source>
          <target state="translated">이 op가 lvalue 서브 루틴의 리턴 값이면 참</target>
        </trans-unit>
        <trans-unit id="407715ca6f2feb3c98182b0f933855e8539ff50e" translate="yes" xml:space="preserve">
          <source>True if this system is capable of true or pseudo-fork.</source>
          <target state="translated">이 시스템이 참 또는 의사 포크가 가능한 경우 참입니다.</target>
        </trans-unit>
        <trans-unit id="0d5d7ce97ba71eed0cb8d5f95d0b08ebce27950e" translate="yes" xml:space="preserve">
          <source>True if this system is capable of using threads.</source>
          <target state="translated">이 시스템이 스레드를 사용할 수있는 경우 true입니다.</target>
        </trans-unit>
        <trans-unit id="a225ab817ea7fa5d168aaeda6fa091c3d9bf26a1" translate="yes" xml:space="preserve">
          <source>True is returned if the file name begins with &lt;code&gt;drive_letter:&lt;/code&gt; , and if not, File::Spec::Unix file_name_is_absolute() is called.</source>
          <target state="translated">파일 이름이 &lt;code&gt;drive_letter:&lt;/code&gt; 시작하면 True가 리턴 되고 그렇지 않으면 File :: Spec :: Unix file_name_is_absolute ()가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="feb89466cc01669fa065abcba450c743f09dda61" translate="yes" xml:space="preserve">
          <source>True is returned if the file name begins with &lt;code&gt;drive_letter:&lt;/code&gt;, and if not, File::Spec::Unix file_name_is_absolute() is called.</source>
          <target state="translated">파일 이름이 &lt;code&gt;drive_letter:&lt;/code&gt; 시작하면 True가 반환 되고, 그렇지 않으면 File :: Spec :: Unix file_name_is_absolute ()가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="fc30aa25ff3d01d64cda3e60440cb70eb23d7d54" translate="yes" xml:space="preserve">
          <source>True only if the version object is a dotted-decimal version, e.g.</source>
          <target state="translated">버전 객체가 점으로 구분 된 10 진수 버전 인 경우에만 참입니다. 예 :</target>
        </trans-unit>
        <trans-unit id="714a51854b847f734d4ad3e61a135b245522aeae" translate="yes" xml:space="preserve">
          <source>True while the most recent result was a TODO. Becomes true before the TODO result is returned and stays true until just before the next non- TODO test is returned.</source>
          <target state="translated">가장 최근의 결과는 TODO였습니다. TODO 결과가 리턴되기 전에 true가되고 다음 TODO 이외의 테스트가 리턴되기 직전까지 true를 유지합니다.</target>
        </trans-unit>
        <trans-unit id="1aceee4ee4f49927d115b3fc82be6c512d7c286c" translate="yes" xml:space="preserve">
          <source>True/false results are never tainted.</source>
          <target state="translated">참 / 거짓 결과는 결코 오염되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f8dc96e0b59ea3e8174d5b669fb89eb4295305d3" translate="yes" xml:space="preserve">
          <source>Truncate $x to an integer value.</source>
          <target state="translated">$ x를 정수 값으로 자릅니다.</target>
        </trans-unit>
        <trans-unit id="191dfbc6a35e73fdb5087a2421ab0ece27f48615" translate="yes" xml:space="preserve">
          <source>Truncate at end-of-file.</source>
          <target state="translated">파일 끝에서 자릅니다.</target>
        </trans-unit>
        <trans-unit id="11625b03167a879105d56ac5232340fe7c1e8727" translate="yes" xml:space="preserve">
          <source>Truncate file suggested by open mode.</source>
          <target state="translated">열린 모드에서 제안한 파일을 자릅니다.</target>
        </trans-unit>
        <trans-unit id="7b41166934a48e946fe5af0522939c8c4005a23a" translate="yes" xml:space="preserve">
          <source>Truncates the file opened on FILEHANDLE, or named by EXPR, to the specified length. Raises an exception if truncate isn't implemented on your system. Returns true if successful, &lt;a href=&quot;#undef-EXPR&quot;&gt;&lt;code&gt;undef&lt;/code&gt;&lt;/a&gt; on error.</source>
          <target state="translated">FILEHANDLE에서 열리거나 EXPR에 의해 명명 된 파일을 지정된 길이로 자릅니다. 시스템에서 자르기가 구현되지 않은 경우 예외를 발생시킵니다. 성공하면 true를 반환 하고 오류가 발생 하면 &lt;a href=&quot;#undef-EXPR&quot;&gt; &lt;code&gt;undef&lt;/code&gt; &lt;/a&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="69983876ff90a7fef773e08a772b817cd9bc808d" translate="yes" xml:space="preserve">
          <source>Truncates the file opened on FILEHANDLE, or named by EXPR, to the specified length. Raises an exception if truncate isn't implemented on your system. Returns true if successful, &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; on error.</source>
          <target state="translated">FILEHANDLE에서 열렸거나 EXPR에 의해 명명 된 파일을 지정된 길이로 자릅니다. 시스템에서 자르기가 구현되지 않은 경우 예외가 발생합니다. 성공하면 true를 반환하고 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 시 오류를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="e6b7268dfdb3e49fbc8b9714eadb8dee9d853cfb" translate="yes" xml:space="preserve">
          <source>Truncates the file opened on FILEHANDLE, or named by EXPR, to the specified length. Raises an exception if truncate isn't implemented on your system. Returns true if successful, &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; on error.</source>
          <target state="translated">FILEHANDLE에서 열렸거나 EXPR에 의해 명명 된 파일을 지정된 길이로 자릅니다. 시스템에서 자르기가 구현되지 않은 경우 예외가 발생합니다. 성공하면 true를 반환하고 &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 시 오류를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="59f6a9fc2fffb15b78c0b81473cdfd56174958cf" translate="yes" xml:space="preserve">
          <source>Truncation</source>
          <target state="translated">Truncation</target>
        </trans-unit>
        <trans-unit id="2975c0f92fcae4101065548cc1a5e6bfa7744574" translate="yes" xml:space="preserve">
          <source>Truncation to same-or-shorter lengths only. (VOS)</source>
          <target state="translated">동일하거나 짧은 길이로만 잘립니다. (VOS)</target>
        </trans-unit>
        <trans-unit id="07fcbd4e35869ee7c3769699235ad97c3caf7ea4" translate="yes" xml:space="preserve">
          <source>Truth and Falsehood</source>
          <target state="translated">진실과 거짓</target>
        </trans-unit>
        <trans-unit id="0ea36a88c9652f7de32e4b8cdc539660f9c8bb67" translate="yes" xml:space="preserve">
          <source>Truth. (&lt;code&gt;PL_sv_yes&lt;/code&gt; ) The value is not needed (and ignored).</source>
          <target state="translated">진실. ( &lt;code&gt;PL_sv_yes&lt;/code&gt; ) 값이 필요하지 않으며 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="fec0d66775a5a838fdce0113e0fc71a37b212e7d" translate="yes" xml:space="preserve">
          <source>Truth. (&lt;code&gt;PL_sv_yes&lt;/code&gt;) The value is not needed (and ignored).</source>
          <target state="translated">진실. ( &lt;code&gt;PL_sv_yes&lt;/code&gt; ) 값이 필요하지 않으며 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="820aa128934b824418f5ca61678f5828e0a9f3f1" translate="yes" xml:space="preserve">
          <source>Try 'which ld' and 'which ld' (or try 'ar --version' and 'ld --version', which work only for the GNU tools, and will announce themselves to be such), and adjust your PATH so that you are consistently using either the native tools or the GNU tools. After fixing your PATH, you should do 'make distclean' and start all the way from running the Configure since you may have quite a confused situation.</source>
          <target state="translated">'which ld'와 'which ld'(또는 GNU 도구에서만 작동하고 그렇게 발표 할 'ar --version'및 'ld --version'을 시도)하고 PATH를 조정하십시오. 기본 도구 또는 GNU 도구를 일관되게 사용하고 있습니다. PATH를 수정 한 후에는 혼란스러운 상황이 발생할 수 있으므로 'make distclean'을 수행하고 Configure 실행을 시작해야합니다.</target>
        </trans-unit>
        <trans-unit id="98c21aef49a5ddf4f1e39c55f7f2477e1906d688" translate="yes" xml:space="preserve">
          <source>Try &lt;code&gt;perldoc Amiga::ARexx&lt;/code&gt; for more info.</source>
          <target state="translated">자세한 내용은 &lt;code&gt;perldoc Amiga::ARexx&lt;/code&gt; 를 사용해보십시오 .</target>
        </trans-unit>
        <trans-unit id="8e033ddf358a130409c1ab5546e94f94b80bcb2f" translate="yes" xml:space="preserve">
          <source>Try &lt;code&gt;perldoc Amiga::Exec&lt;/code&gt; for more info.</source>
          <target state="translated">자세한 내용은 &lt;code&gt;perldoc Amiga::Exec&lt;/code&gt; 을 사용해보십시오 .</target>
        </trans-unit>
        <trans-unit id="dfec8d0f349c3c42fb9d1815573a589ac82ef522" translate="yes" xml:space="preserve">
          <source>Try and match a closing delimiter bracket. If the bracket was the same species as the last opening bracket, return the substring to that point. If the bracket was mismatched, return an error.</source>
          <target state="translated">닫는 구분 기호 괄호를 사용하십시오. 대괄호가 마지막 여는 대괄호와 같은 종이면 하위 문자열을 해당 지점으로 되돌립니다. 대괄호가 일치하지 않으면 오류를 리턴하십시오.</target>
        </trans-unit>
        <trans-unit id="3534e8ec8243f82da173a0a961f29a6061ccc5a4" translate="yes" xml:space="preserve">
          <source>Try every conceivable way to get hostname</source>
          <target state="translated">생각할 수있는 모든 방법으로 호스트 이름을 얻으십시오</target>
        </trans-unit>
        <trans-unit id="dfea66ec3b5d472c8a85f9f4143d2c2a2932e7a3" translate="yes" xml:space="preserve">
          <source>Try hard not to exceed 79-columns</source>
          <target state="translated">79 열을 초과하지 않도록 노력하십시오.</target>
        </trans-unit>
        <trans-unit id="71156f6966e318bbb69b3350da865612c3413590" translate="yes" xml:space="preserve">
          <source>Try keeping around the seekpointer and go there, like this:</source>
          <target state="translated">탐색 포인터 주위를 유지하고 다음과 같이하십시오.</target>
        </trans-unit>
        <trans-unit id="5ab49ef558819708ac26895c52750c3610705d02" translate="yes" xml:space="preserve">
          <source>Try not to launch headlong into developing your module without spending some time thinking first. A little forethought may save you a vast amount of effort later on.</source>
          <target state="translated">먼저 생각하지 않고 모듈 개발을 시작하지 마십시오. 조금만 생각하면 나중에 많은 노력을 아낄 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="66c86b400f1e32f25dbc921f7ed16eeea4ab2376" translate="yes" xml:space="preserve">
          <source>Try the &lt;a href=&quot;Net::FTP&quot;&gt;Net::FTP&lt;/a&gt;, &lt;a href=&quot;TCP::Client&quot;&gt;TCP::Client&lt;/a&gt;, and &lt;a href=&quot;Net::Telnet&quot;&gt;Net::Telnet&lt;/a&gt; modules (available from CPAN). &lt;a href=&quot;http://www.cpan.org/scripts/netstuff/telnet.emul.shar&quot;&gt;http://www.cpan.org/scripts/netstuff/telnet.emul.shar&lt;/a&gt; will also help for emulating the telnet protocol, but &lt;a href=&quot;Net::Telnet&quot;&gt;Net::Telnet&lt;/a&gt; is quite probably easier to use.</source>
          <target state="translated">&lt;a href=&quot;Net::FTP&quot;&gt;Net :: FTP&lt;/a&gt; , &lt;a href=&quot;TCP::Client&quot;&gt;TCP :: Client&lt;/a&gt; 및 &lt;a href=&quot;Net::Telnet&quot;&gt;Net :: Telnet&lt;/a&gt; 모듈 (CPAN에서 사용 가능)을 사용해보십시오 . &lt;a href=&quot;http://www.cpan.org/scripts/netstuff/telnet.emul.shar&quot;&gt;http://www.cpan.org/scripts/netstuff/telnet.emul.shar&lt;/a&gt; 도 텔넷 프로토콜을 에뮬레이션하는 데 도움이되지만 &lt;a href=&quot;Net::Telnet&quot;&gt;Net :: Telnet&lt;/a&gt; 은 사용하기가 훨씬 더 쉽습니다.</target>
        </trans-unit>
        <trans-unit id="1a2b567df2700cceb3e59d9f8a3eb3ca3092a77c" translate="yes" xml:space="preserve">
          <source>Try the &lt;a href=&quot;net/ftp&quot;&gt;Net::FTP&lt;/a&gt;, &lt;a href=&quot;http://search.cpan.org/perldoc/TCP::Client&quot;&gt;TCP::Client&lt;/a&gt;, and &lt;a href=&quot;http://search.cpan.org/perldoc/Net::Telnet&quot;&gt;Net::Telnet&lt;/a&gt; modules (available from CPAN). &lt;a href=&quot;http://www.cpan.org/scripts/netstuff/telnet.emul.shar&quot;&gt;http://www.cpan.org/scripts/netstuff/telnet.emul.shar&lt;/a&gt; will also help for emulating the telnet protocol, but &lt;a href=&quot;http://search.cpan.org/perldoc/Net::Telnet&quot;&gt;Net::Telnet&lt;/a&gt; is quite probably easier to use.</source>
          <target state="translated">&lt;a href=&quot;net/ftp&quot;&gt;Net :: FTP&lt;/a&gt; , &lt;a href=&quot;http://search.cpan.org/perldoc/TCP::Client&quot;&gt;TCP :: Client&lt;/a&gt; 및 &lt;a href=&quot;http://search.cpan.org/perldoc/Net::Telnet&quot;&gt;Net :: Telnet&lt;/a&gt; 모듈 (CPAN에서 사용 가능)을 사용해보십시오 . &lt;a href=&quot;http://www.cpan.org/scripts/netstuff/telnet.emul.shar&quot;&gt;http://www.cpan.org/scripts/netstuff/telnet.emul.shar&lt;/a&gt; 도 텔넷 프로토콜을 에뮬레이트하는 데 도움이되지만 &lt;a href=&quot;http://search.cpan.org/perldoc/Net::Telnet&quot;&gt;Net :: Telnet&lt;/a&gt; 이 훨씬 사용하기 쉽습니다.</target>
        </trans-unit>
        <trans-unit id="87f2df3af873276d11f18dcdfa6067907516ef82" translate="yes" xml:space="preserve">
          <source>Try the first alternative in the first group 'abd'.</source>
          <target state="translated">첫 번째 그룹 'abd'의 첫 번째 대안을 시도하십시오.</target>
        </trans-unit>
        <trans-unit id="8fdc9fd893f9837a30290ddcdb863de474cd49f7" translate="yes" xml:space="preserve">
          <source>Try the native, UDP socket then UNIX domain socket mechanisms:</source>
          <target state="translated">기본 UDP 소켓과 UNIX 도메인 소켓 메커니즘을 시도하십시오.</target>
        </trans-unit>
        <trans-unit id="6a75e271162bdc3d061e3493d3ce114d627fc256" translate="yes" xml:space="preserve">
          <source>Try the resources in &lt;a href=&quot;perlfaq2&quot;&gt;perlfaq2&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;perlfaq2&quot;&gt;perlfaq2&lt;/a&gt; 의 리소스를 사용해보십시오 .</target>
        </trans-unit>
        <trans-unit id="aacef041b76d57895de9d7f5cee32482707bd3b3" translate="yes" xml:space="preserve">
          <source>Try to &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict;&lt;/code&gt; (or &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict qw(...);&lt;/code&gt; ). Remember that you can add &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; strict qw(...);&lt;/code&gt; to individual blocks of code that need less strictness.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict;&lt;/code&gt; 것을 &lt;a href=&quot;functions/use&quot;&gt;사용&lt;/a&gt; 하십시오 ; (또는 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict qw(...);&lt;/code&gt; ). &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; strict qw(...);&lt;/code&gt; 추가 할 수 &lt;a href=&quot;functions/no&quot;&gt;없음을&lt;/a&gt; 기억하십시오 . 덜 엄격해야하는 개별 코드 블록에.</target>
        </trans-unit>
        <trans-unit id="dbe02bedd5bb36eab5b4bbe32b7d4940cf95d2ec" translate="yes" xml:space="preserve">
          <source>Try to &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings;&lt;/code&gt; (or &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings qw(...);&lt;/code&gt; ). Remember that you can add &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; warnings qw(...);&lt;/code&gt; to individual blocks of code that need less warnings.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings;&lt;/code&gt; 를 &lt;a href=&quot;functions/use&quot;&gt;사용&lt;/a&gt; 하십시오 . (또는 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings qw(...);&lt;/code&gt; ). &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; warnings qw(...);&lt;/code&gt; 추가 할 수 &lt;a href=&quot;functions/no&quot;&gt;없습니다.&lt;/a&gt; qw (...); 경고가 덜 필요한 개별 코드 블록에.</target>
        </trans-unit>
        <trans-unit id="38b826b6e348509b8760d8f24eae463b23ce7bf6" translate="yes" xml:space="preserve">
          <source>Try to &lt;code&gt;use strict;&lt;/code&gt; (or &lt;code&gt;use strict qw(...);&lt;/code&gt;). Remember that you can add &lt;code&gt;no strict qw(...);&lt;/code&gt; to individual blocks of code that need less strictness.</source>
          <target state="translated">&lt;code&gt;use strict;&lt;/code&gt; 시도하십시오 . (또는 &lt;code&gt;use strict qw(...);&lt;/code&gt; ). &lt;code&gt;no strict qw(...);&lt;/code&gt; 추가 할 수 없음을 기억하십시오 . 덜 엄격해야하는 개별 코드 블록에.</target>
        </trans-unit>
        <trans-unit id="2bf7f5a326028f0c812e9c509d8082b45d0e5a3e" translate="yes" xml:space="preserve">
          <source>Try to &lt;code&gt;use warnings;&lt;/code&gt; (or &lt;code&gt;use warnings qw(...);&lt;/code&gt;). Remember that you can add &lt;code&gt;no warnings qw(...);&lt;/code&gt; to individual blocks of code that need less warnings.</source>
          <target state="translated">&lt;code&gt;use warnings;&lt;/code&gt; 를 사용 하십시오 . (또는 &lt;code&gt;use warnings qw(...);&lt;/code&gt; ). &lt;code&gt;no warnings qw(...);&lt;/code&gt; 추가 할 수 없음을 기억하십시오. qw (...); 더 적은 경고가 필요한 개별 코드 블록에.</target>
        </trans-unit>
        <trans-unit id="1a50d23e31ca789a858a654feff08b918836c974" translate="yes" xml:space="preserve">
          <source>Try to color output. See &lt;a href=&quot;../tap/formatter/base#new&quot;&gt;new in TAP::Formatter::Base&lt;/a&gt;.</source>
          <target state="translated">컬러 출력을 시도하십시오. &lt;a href=&quot;../tap/formatter/base#new&quot;&gt;TAP :: Formatter :: Base의 새로운 기능을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="56802a31d085c41de140ede22328a67086473d5e" translate="yes" xml:space="preserve">
          <source>Try to color output. See &lt;a href=&quot;TAP::Formatter::Base#new&quot;&gt;&quot;new&quot; in TAP::Formatter::Base&lt;/a&gt;.</source>
          <target state="translated">컬러 출력을 시도하십시오. &lt;a href=&quot;TAP::Formatter::Base#new&quot;&gt;TAP :: Formatter :: Base의 &quot;new&quot;를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="2e97a54a5e20ef4c3c124d4963b017c39c1dad7b" translate="yes" xml:space="preserve">
          <source>Try to design the new module to be easy to extend and reuse.</source>
          <target state="translated">쉽게 확장하고 재사용 할 수 있도록 새 모듈을 설계하십시오.</target>
        </trans-unit>
        <trans-unit id="220ea4d529b6fa37d1fa97bbb19f2fed77ce5e5b" translate="yes" xml:space="preserve">
          <source>Try to determine name of extension being built. We begin with the name of the current directory. Since VMS filenames are case-insensitive, however, we look for a</source>
          <target state="translated">빌드중인 확장명을 결정하십시오. 우리는 현재 디렉토리의 이름으로 시작합니다. 그러나 VMS 파일 이름은 대소 문자를 구분하지 않으므로</target>
        </trans-unit>
        <trans-unit id="909a91fc6d3b48263691b246eef6c09eb4ec3bfc" translate="yes" xml:space="preserve">
          <source>Try to determine the width of the screen and the bold and underline sequences for the terminal from termcap, and use that information in formatting the output. Output will be wrapped at two columns less than the width of your terminal device. Using this option requires that your system have a termcap file somewhere where Term::Cap can find it and requires that your system support termios. With this option, the output of &lt;b&gt;pod2text&lt;/b&gt; will contain terminal control sequences for your current terminal type.</source>
          <target state="translated">termcap에서 화면의 너비와 터미널의 굵은 체와 밑줄 순서를 결정하고 해당 정보를 출력 형식화에 사용하십시오. 출력은 터미널 장치의 너비보다 작은 두 열로 줄 바꿈됩니다. 이 옵션을 사용하려면 시스템에 Term :: Cap에서 찾을 수있는 termcap 파일이 있어야하며 시스템에서 termios를 지원해야합니다. 이 옵션을 사용하면 &lt;b&gt;pod2text&lt;/b&gt; 출력에 현재 터미널 유형에 대한 터미널 제어 시퀀스가 ​​포함됩니다.</target>
        </trans-unit>
        <trans-unit id="08f15a05901602892a511e670ab4aa0307df4226" translate="yes" xml:space="preserve">
          <source>Try to document your code and use Pod formatting in a consistent way. Here are commonly expected conventions:</source>
          <target state="translated">코드를 문서화하고 일관된 방식으로 포드 형식을 사용하십시오. 일반적으로 예상되는 규칙은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c88c728349f5a2409f402906caa2d933f74c0865" translate="yes" xml:space="preserve">
          <source>Try to match a quote or quotelike operator. If found, call &lt;code&gt;extract_quotelike&lt;/code&gt; to eat it. If &lt;code&gt;extract_quotelike&lt;/code&gt; fails, return the error it returned. Otherwise go back to step 1.</source>
          <target state="translated">따옴표 나 따옴표와 같은 연산자를 일치 시키십시오. 발견되면 &lt;code&gt;extract_quotelike&lt;/code&gt; 를 호출 하여 먹습니다. 경우 &lt;code&gt;extract_quotelike&lt;/code&gt; 이 실패가 반환 된 오류를 반환합니다. 그렇지 않으면 1 단계로 돌아갑니다.</target>
        </trans-unit>
        <trans-unit id="fed009e07cf40a3bfaccb23b101b1df3951ecefd" translate="yes" xml:space="preserve">
          <source>Try to match an opening delimiter bracket. If found, call &lt;code&gt;extract_codeblock&lt;/code&gt; recursively to eat the embedded block. If the recursive call fails, return an error. Otherwise, go back to step 1.</source>
          <target state="translated">여는 구분 기호를 일치 시키십시오. 발견되면 내장 블록을 먹기 위해 재귀 적으로 &lt;code&gt;extract_codeblock&lt;/code&gt; 을 호출 하십시오. 재귀 호출이 실패하면 오류를 반환하십시오. 그렇지 않으면 1 단계로 돌아가십시오.</target>
        </trans-unit>
        <trans-unit id="1bf160ae95bc79040defdb4258d5fad8caa20a29" translate="yes" xml:space="preserve">
          <source>Try to obtain the latest version of the Windows SDK. Sometimes these packages contain a particular Windows OS version in their name, but actually work on other OS versions too. For example, the &quot;Windows Server 2003 R2 Platform SDK&quot; also runs on Windows XP SP2 and Windows 2000.</source>
          <target state="translated">최신 버전의 Windows SDK를 구하십시오. 때때로 이러한 패키지에는 이름에 특정 Windows OS 버전이 포함되어 있지만 실제로는 다른 OS 버전에서도 작동합니다. 예를 들어 &quot;Windows Server 2003 R2 플랫폼 SDK&quot;는 Windows XP SP2 및 Windows 2000에서도 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="962ca701cc2570a663505435d963dc55f234f4d9" translate="yes" xml:space="preserve">
          <source>Trying to create a new child with a previous child still active (i.e., &lt;code&gt;finalize&lt;/code&gt; not called) will &lt;code&gt;croak&lt;/code&gt; .</source>
          <target state="translated">(즉, 활성 상태 이전의 아이 새 자식 만들려고 &lt;code&gt;finalize&lt;/code&gt; 합니다 호출되지 않습니다) &lt;code&gt;croak&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e0c592184c4820418323672dd4337df40c4098b0" translate="yes" xml:space="preserve">
          <source>Trying to do too much</source>
          <target state="translated">너무 많은 일을하려고</target>
        </trans-unit>
        <trans-unit id="44d272c0c6193575553012dfbe62f22573eeb82f" translate="yes" xml:space="preserve">
          <source>Trying to run a test when you have an open child will also &lt;code&gt;croak&lt;/code&gt; and cause the test suite to fail.</source>
          <target state="translated">열린 아이가있을 때 테스트를 실행하려고하면 &lt;code&gt;croak&lt;/code&gt; 테스트 스위트가 실패하게됩니다.</target>
        </trans-unit>
        <trans-unit id="e1251ee8a07b3dea6c343e31961e5913e11f0ce3" translate="yes" xml:space="preserve">
          <source>Tune the internal settings for the deflate object &lt;code&gt;$d&lt;/code&gt; . This option is only available if you are running zlib 1.2.2.3 or better.</source>
          <target state="translated">수축 오브젝트 &lt;code&gt;$d&lt;/code&gt; 의 내부 설정을 조정하십시오 . 이 옵션은 zlib 1.2.2.3 이상을 실행중인 경우에만 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3896985029531ee0a442a6eafffd21b16e99bab0" translate="yes" xml:space="preserve">
          <source>Tune the internal settings for the deflate object &lt;code&gt;$d&lt;/code&gt;. This option is only available if you are running zlib 1.2.2.3 or better.</source>
          <target state="translated">deflate 개체 &lt;code&gt;$d&lt;/code&gt; 대한 내부 설정을 조정합니다 . 이 옵션은 zlib 1.2.2.3 이상을 실행하는 경우에만 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="008eee580921a65a5e935994d388ebe43c6df0cd" translate="yes" xml:space="preserve">
          <source>Tuning the way RESOLVE_SYMLINK will works</source>
          <target state="translated">RESOLVE_SYMLINK 작동 방식 조정</target>
        </trans-unit>
        <trans-unit id="8c3f4c8cc5ca57e1d0107a8c0347eb3646189c97" translate="yes" xml:space="preserve">
          <source>Tunnelling &lt;code&gt;https&lt;/code&gt; over an &lt;code&gt;http&lt;/code&gt; proxy using the CONNECT method is supported. If your proxy uses &lt;code&gt;https&lt;/code&gt; itself, you can not tunnel &lt;code&gt;https&lt;/code&gt; over it.</source>
          <target state="translated">CONNECT 메소드를 사용하여 &lt;code&gt;http&lt;/code&gt; 프록시를 통한 &lt;code&gt;https&lt;/code&gt; 터널링 이 지원됩니다. 프록시가 &lt;code&gt;https&lt;/code&gt; 자체를 사용하는 경우 &lt;code&gt;https&lt;/code&gt; 를 터널링 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="d7153e6702b4ea48c7c0d01affdef0e1b39fd6dc" translate="yes" xml:space="preserve">
          <source>Turkey</source>
          <target state="translated">Turkey</target>
        </trans-unit>
        <trans-unit id="f7db0bf3a9c02aa40e34f07d8431257fcf327327" translate="yes" xml:space="preserve">
          <source>Turn =head1 directives into links pointing to the top of the HTML file.</source>
          <target state="translated">= head1 지시문을 HTML 파일의 상단을 가리키는 링크로 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="00eb812c53d2b2fc577cde21da51d4b0a2dbeaba" translate="yes" xml:space="preserve">
          <source>Turn IPC off</source>
          <target state="translated">IPC 끄기</target>
        </trans-unit>
        <trans-unit id="33f87dc87ea378d835e56e5bfd248ea1a352c832" translate="yes" xml:space="preserve">
          <source>Turn Pod into XML</source>
          <target state="translated">포드를 XML로 바꾸기</target>
        </trans-unit>
        <trans-unit id="8e7cc74dfcc71c13798fc4a8a0bda3cb164ed4c1" translate="yes" xml:space="preserve">
          <source>Turn Pod::Simple events into method calls</source>
          <target state="translated">Pod :: Simple 이벤트를 메소드 호출로 전환</target>
        </trans-unit>
        <trans-unit id="87a4a4a475f00352f77a10d3ec1fd9eee936c4ee" translate="yes" xml:space="preserve">
          <source>Turn off Apple tar's tendency to copy resource forks as &quot;._foo&quot; files.</source>
          <target state="translated">리소스 포크를 &quot;._foo&quot;파일로 복사하는 Apple tar의 경향을 끕니다.</target>
        </trans-unit>
        <trans-unit id="002da87886e80eee99a8ca6dc4e3fe4cabdcf032" translate="yes" xml:space="preserve">
          <source>Turn off CPAN.pm's attempts to lock anything. You should be careful with this since you might end up with multiple scripts trying to muck in the same directory. This isn't so much of a concern if you're loading a special config with &lt;code&gt;-j&lt;/code&gt;, and that config sets up its own work directories.</source>
          <target state="translated">모든 것을 잠 그려는 CPAN.pm의 시도를 끄십시오. 동일한 디렉토리에서 여러 스크립트를 처리하려고 할 수 있으므로주의해야합니다. &lt;code&gt;-j&lt;/code&gt; 를 사용 하여 특수 구성을로드 하고 해당 구성이 자체 작업 디렉토리를 설정하는 경우 이는 그다지 문제가되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="75c822c937f705b4f59deefb9b7306dfc70d6869" translate="yes" xml:space="preserve">
          <source>Turn off IPC polling.</source>
          <target state="translated">IPC 폴링을 끕니다.</target>
        </trans-unit>
        <trans-unit id="a5f985f0fcda86b1c258609df3d266b43ed8ce4a" translate="yes" xml:space="preserve">
          <source>Turn on IPC for threading or forking support.</source>
          <target state="translated">스레딩 또는 분기 지원을 위해 IPC를 켭니다.</target>
        </trans-unit>
        <trans-unit id="48d8224908b27731eb611ee5800a332f08bd6efe" translate="yes" xml:space="preserve">
          <source>Turn on colour in Test::Builder::Tester</source>
          <target state="translated">Test :: Builder :: Tester에서 색상 켜기</target>
        </trans-unit>
        <trans-unit id="33bdb8453820e783c9ed80ead4da0eab3e622342" translate="yes" xml:space="preserve">
          <source>Turn on cpan warnings. This checks various things, like directory permissions, and tells you about problems you might have.</source>
          <target state="translated">cpan 경고를 켭니다. 이것은 디렉토리 권한과 같은 다양한 사항을 확인하고 발생할 수있는 문제에 대해 알려줍니다.</target>
        </trans-unit>
        <trans-unit id="3aaaf6cc176020f3991943f2032de33eccbdb645" translate="yes" xml:space="preserve">
          <source>Turn on debugging messages.</source>
          <target state="translated">디버깅 메시지를 켭니다.</target>
        </trans-unit>
        <trans-unit id="987617e4099bb6d10ab491d6ac24dec67dd616d3" translate="yes" xml:space="preserve">
          <source>Turn on polling. This will cull events from other processes and threads every time a context is created.</source>
          <target state="translated">폴링을 켭니다. 컨텍스트가 생성 될 때마다 다른 프로세스와 스레드에서 이벤트를 컬링합니다.</target>
        </trans-unit>
        <trans-unit id="c5afa3624933dbb94708b864157bd75149a4bc45" translate="yes" xml:space="preserve">
          <source>Turn on the UTF-8 status of an SV (the data is not changed, just the flag). Do not use frivolously.</source>
          <target state="translated">SV의 UTF-8 상태를 켭니다 (데이터는 변경되지 않고 플래그 만). 경박하게 사용하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="58ffd65543f8495b744e9f3f6c44eb3bd2d31977" translate="yes" xml:space="preserve">
          <source>Turn on the escaping of characters as described in the SPACES AND TABS section.</source>
          <target state="translated">공백 및 탭 섹션에 설명 된대로 문자 이스케이프를 켭니다.</target>
        </trans-unit>
        <trans-unit id="9903e627171cb3011421fef7af4a686d6ebc3e08" translate="yes" xml:space="preserve">
          <source>Turn on/off printing of warnings. Repeating &lt;b&gt;-warnings&lt;/b&gt; increases the warning level, i.e. more warnings are printed. Currently increasing to level two causes flagging of unescaped &quot;&amp;lt;,&amp;gt;&quot; characters.</source>
          <target state="translated">경고 인쇄를 켜거나 끕니다. 반복 &lt;b&gt;-warnings 것은&lt;/b&gt; 즉, 경고 수준, 더 경고가 인쇄됩니다 증가합니다. 현재 레벨 2로 증가하면 이스케이프되지 않은 &quot;&amp;lt;,&amp;gt;&quot;문자가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="d7dd646019946f4186b2c9415767806d113e6794" translate="yes" xml:space="preserve">
          <source>Turn warnings on/off.</source>
          <target state="translated">경고를 켜거나 끕니다.</target>
        </trans-unit>
        <trans-unit id="4c628137dd54154b5661d62a2c76528177ce2c0e" translate="yes" xml:space="preserve">
          <source>Turning on one of the character set flags with &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re&lt;/code&gt; takes precedence over the &lt;code&gt;locale&lt;/code&gt; pragma and the 'unicode_strings' &lt;code&gt;feature&lt;/code&gt; , for regular expressions. Turning off one of these flags when it is active reverts to the behaviour specified by whatever other pragmata are in scope. For example:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re&lt;/code&gt; 를 &lt;a href=&quot;functions/use&quot;&gt;사용&lt;/a&gt; 하여 문자 세트 플래그 중 하나를 설정 하면 정규 표현식 의 &lt;code&gt;locale&lt;/code&gt; pragma 및 'unicode_strings' &lt;code&gt;feature&lt;/code&gt; 보다 우선 합니다. 활성화 될 때이 플래그 중 하나를 끄면 다른 pragmata가 지정한 범위 내에서 지정된 동작으로 되돌아갑니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="bab3f5ad74d31e2186209289e3cd6bd581941efe" translate="yes" xml:space="preserve">
          <source>Turning on one of the character set flags with &lt;code&gt;use re&lt;/code&gt; takes precedence over the &lt;code&gt;locale&lt;/code&gt; pragma and the 'unicode_strings' &lt;code&gt;feature&lt;/code&gt;, for regular expressions. Turning off one of these flags when it is active reverts to the behaviour specified by whatever other pragmata are in scope. For example:</source>
          <target state="translated">&lt;code&gt;use re&lt;/code&gt; 를 사용 하여 문자 집합 플래그 중 하나를 켜는 것은 정규 표현식의 경우 &lt;code&gt;locale&lt;/code&gt; pragma 및 'unicode_strings' &lt;code&gt;feature&lt;/code&gt; 보다 우선 합니다. 활성 상태 일 때 이러한 플래그 중 하나를 끄면 범위에있는 다른 pragmata에서 지정한 동작으로 되돌아갑니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1dac2f62695f453fd439059f0a117cf373d1f773" translate="yes" xml:space="preserve">
          <source>Turns every &lt;code&gt;head1&lt;/code&gt; heading into a link back to the top of the page. By default, no backlinks are generated.</source>
          <target state="translated">모든 &lt;code&gt;head1&lt;/code&gt; 제목을 페이지 상단으로 돌아가는 링크로 바꿉니다 . 기본적으로 백 링크는 생성되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="488b4a24fda23c677bfd758dfeda4e2b3e28ea5b" translate="yes" xml:space="preserve">
          <source>Turns on all &quot;extra&quot; debugging options.</source>
          <target state="translated">모든 &quot;추가&quot;디버깅 옵션을 설정합니다.</target>
        </trans-unit>
        <trans-unit id="8a6abc6af101e3e68b329eb351f149732ea8c3d9" translate="yes" xml:space="preserve">
          <source>Turns on all compile related debug options.</source>
          <target state="translated">모든 컴파일 관련 디버그 옵션을 설정합니다.</target>
        </trans-unit>
        <trans-unit id="377f42734b94211c01fa848b2645c0c159ecedcd" translate="yes" xml:space="preserve">
          <source>Turns on all execute related debug options.</source>
          <target state="translated">모든 관련 디버그 옵션 실행을 설정합니다.</target>
        </trans-unit>
        <trans-unit id="16cf0e466a4f6fe0b3456839377f934eda051d4e" translate="yes" xml:space="preserve">
          <source>Turns on all non-extra compile related debug options.</source>
          <target state="translated">모든 비추가 컴파일 관련 디버그 옵션을 켭니다.</target>
        </trans-unit>
        <trans-unit id="bb0c3643227c9fa0f255763a21a1f9559b3e9dd1" translate="yes" xml:space="preserve">
          <source>Turns on all non-extra execute related debug options.</source>
          <target state="translated">모든 비추가 실행 관련 디버그 옵션을 켭니다.</target>
        </trans-unit>
        <trans-unit id="cf78d64b4c15f8d89c3f09aea595a015508f3471" translate="yes" xml:space="preserve">
          <source>Turns on autoflush, print ARGS and then restores the autoflush status of the &lt;code&gt;IO::Handle&lt;/code&gt; object. Returns the return value from print.</source>
          <target state="translated">자동 세척, ARGS 인쇄를 켜고 &lt;code&gt;IO::Handle&lt;/code&gt; 개체 의 자동 세척 상태를 복원 합니다. 인쇄 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="2d1676fcc040bdf1deeab307eee1f9a1faa4d87a" translate="yes" xml:space="preserve">
          <source>Turns on debug output related to the process of parsing the pattern.</source>
          <target state="translated">패턴 구문 분석 프로세스와 관련된 디버그 출력을 설정합니다.</target>
        </trans-unit>
        <trans-unit id="80ae89d796a9f5474c9cf55351133039b045499c" translate="yes" xml:space="preserve">
          <source>Turns on debugging</source>
          <target state="translated">디버깅을 켭니다</target>
        </trans-unit>
        <trans-unit id="0b71618ab3c580ced56e12be5afa8ca78d10b841" translate="yes" xml:space="preserve">
          <source>Turns on debugging of the main matching loop.</source>
          <target state="translated">기본 일치 루프의 디버깅을 설정합니다.</target>
        </trans-unit>
        <trans-unit id="821dfaade517bc8af20717058964e6e45387b304" translate="yes" xml:space="preserve">
          <source>Turns on the magical status of an SV. See &lt;code&gt;&lt;a href=&quot;#sv_magic&quot;&gt;&quot;sv_magic&quot;&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">SV의 마법 상태를 켭니다. &lt;code&gt;&lt;a href=&quot;#sv_magic&quot;&gt;&quot;sv_magic&quot;&lt;/a&gt;&lt;/code&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0d12b512bcc17c858f7f78847cab2c7f6461efd3" translate="yes" xml:space="preserve">
          <source>Turns on the magical status of an SV. See &lt;code&gt;sv_magic&lt;/code&gt; .</source>
          <target state="translated">SV의 마법 상태를 켭니다. &lt;code&gt;sv_magic&lt;/code&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b5ed69f1e400ca234d376650a653b6521d5c1651" translate="yes" xml:space="preserve">
          <source>Turns the @metadata_pairs into YAML.</source>
          <target state="translated">@metadata_pairs를 YAML로 바꿉니다.</target>
        </trans-unit>
        <trans-unit id="606c2af8d67a4d7dc7224ecdbb198b95627a3d18" translate="yes" xml:space="preserve">
          <source>Tutorial on making a new module.</source>
          <target state="translated">새로운 모듈 만들기에 대한 튜토리얼.</target>
        </trans-unit>
        <trans-unit id="654171647baa6be8557a5d627cf35c7075ebb257" translate="yes" xml:space="preserve">
          <source>Tutorials</source>
          <target state="translated">Tutorials</target>
        </trans-unit>
        <trans-unit id="4106aa6fe38782986e71b6df351f9eed9adc1100" translate="yes" xml:space="preserve">
          <source>Tutorials, end-user documentation, research papers, FAQs etc are not appropriate in a module's main documentation. If you really want to write these, include them as sub-documents such as &lt;code&gt;My::Module::Tutorial&lt;/code&gt; or &lt;code&gt;My::Module::FAQ&lt;/code&gt; and provide a link in the SEE ALSO section of the main documentation.</source>
          <target state="translated">모듈의 기본 설명서에는 자습서, 최종 사용자 설명서, 연구 논문, FAQ 등이 적합하지 않습니다. 실제로 작성하려면 &lt;code&gt;My::Module::Tutorial&lt;/code&gt; 또는 &lt;code&gt;My::Module::FAQ&lt;/code&gt; 와 같은 하위 문서로 포함시키고 기본 문서의 SEE ALSO 섹션에 링크를 제공하십시오.</target>
        </trans-unit>
        <trans-unit id="d4f6fcebc83fe08414440f2690253120c9bf99c3" translate="yes" xml:space="preserve">
          <source>Tweak the style of B::Deparse's output. The letters should follow directly after the 's', with no space or punctuation. The following options are available:</source>
          <target state="translated">B :: Deparse의 출력 스타일을 조정하십시오. 문자는 공백이나 문장 부호없이 's'바로 뒤에 와야합니다. 다음과 같은 옵션을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8b77b783948e5ce8fbd237831d47a3e2aa25c8cf" translate="yes" xml:space="preserve">
          <source>Two additional extensions by Andreas Kaiser, &lt;code&gt;OS2::UPM&lt;/code&gt; , and &lt;code&gt;OS2::FTP&lt;/code&gt; , are included into &lt;code&gt;ILYAZ&lt;/code&gt; directory, mirrored on CPAN. Other OS/2-related extensions are available too.</source>
          <target state="translated">Andreas Kaiser의 &lt;code&gt;OS2::UPM&lt;/code&gt; 및 &lt;code&gt;OS2::FTP&lt;/code&gt; 추가 확장이 CPAN에서 미러링 된 &lt;code&gt;ILYAZ&lt;/code&gt; 디렉토리에 포함됩니다 . 다른 OS / 2 관련 확장도 사용 가능합니다.</target>
        </trans-unit>
        <trans-unit id="e1e1c471607b1953c35055b694d94ae2115e7490" translate="yes" xml:space="preserve">
          <source>Two additional extensions by Andreas Kaiser, &lt;code&gt;OS2::UPM&lt;/code&gt;, and &lt;code&gt;OS2::FTP&lt;/code&gt;, are included into &lt;code&gt;ILYAZ&lt;/code&gt; directory, mirrored on CPAN. Other OS/2-related extensions are available too.</source>
          <target state="translated">Andreas Kaiser의 두 가지 추가 확장, &lt;code&gt;OS2::UPM&lt;/code&gt; 및 &lt;code&gt;OS2::FTP&lt;/code&gt; 는 CPAN에 미러링 된 &lt;code&gt;ILYAZ&lt;/code&gt; 디렉토리에 포함됩니다 . 다른 OS / 2 관련 확장도 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="225de66ed8612f5eaedcbe3517b9b8a030dd1dfb" translate="yes" xml:space="preserve">
          <source>Two additional fields &lt;code&gt;free&lt;/code&gt; , &lt;code&gt;used&lt;/code&gt; contain array references which provide per-bucket count of free and used chunks. Two other fields &lt;code&gt;mem_size&lt;/code&gt; , &lt;code&gt;available_size&lt;/code&gt; contain array references which provide the information about the allocated size and usable size of chunks in each bucket. Again, see &lt;a href=&quot;../perldebguts#Using-%24ENV%7bPERL_DEBUG_MSTATS%7d&quot;&gt;Using $ENV{PERL_DEBUG_MSTATS} in perldebguts&lt;/a&gt; for details.</source>
          <target state="translated">두 개의 추가 필드 &lt;code&gt;free&lt;/code&gt; , &lt;code&gt;used&lt;/code&gt; 무료로 사용 청크 당 버킷 수를 제공 배열 참조가 포함되어 있습니다. 다른 두 개의 필드 &lt;code&gt;mem_size&lt;/code&gt; , &lt;code&gt;available_size&lt;/code&gt; 에는 각 버킷에서 할당 된 크기 및 사용 가능한 청크 크기에 대한 정보를 제공하는 배열 참조가 포함됩니다. 또, 참조 &lt;a href=&quot;../perldebguts#Using-%24ENV%7bPERL_DEBUG_MSTATS%7d&quot;&gt;perldebguts에서 $ ENV {PERL_DEBUG_MSTATS}를 사용하여&lt;/a&gt; 자세한 내용은.</target>
        </trans-unit>
        <trans-unit id="645e14dd280baf021efadb33e4b6285cfb158d60" translate="yes" xml:space="preserve">
          <source>Two additional fields &lt;code&gt;free&lt;/code&gt;, &lt;code&gt;used&lt;/code&gt; contain array references which provide per-bucket count of free and used chunks. Two other fields &lt;code&gt;mem_size&lt;/code&gt;, &lt;code&gt;available_size&lt;/code&gt; contain array references which provide the information about the allocated size and usable size of chunks in each bucket. Again, see &lt;a href=&quot;perldebguts#Using-%24ENV%7BPERL_DEBUG_MSTATS%7D&quot;&gt;&quot;Using $ENV{PERL_DEBUG_MSTATS}&quot; in perldebguts&lt;/a&gt; for details.</source>
          <target state="translated">두 개의 추가 필드 &lt;code&gt;free&lt;/code&gt; 는 &lt;code&gt;used&lt;/code&gt; 가능한 청크 및 사용 된 청크의 버킷 당 수를 제공하는 배열 참조를 포함합니다. 두 개의 다른 필드 &lt;code&gt;mem_size&lt;/code&gt; , &lt;code&gt;available_size&lt;/code&gt; 는 각 버킷에서 할당 된 크기 및 사용 가능한 청크 크기에 대한 정보를 제공하는 배열 참조를 포함합니다. 다시 한 번, 자세한 내용 &lt;a href=&quot;perldebguts#Using-%24ENV%7BPERL_DEBUG_MSTATS%7D&quot;&gt;은 perldebguts의 &quot;$ ENV {PERL_DEBUG_MSTATS} 사용&quot;&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="959e1dbe5c03b6bf54bd2c7c42f5c06de670abcf" translate="yes" xml:space="preserve">
          <source>Two arrays smartmatch if each element in the first array smartmatches (that is, is &quot;in&quot;) the corresponding element in the second array, recursively.</source>
          <target state="translated">첫 번째 배열의 각 요소가 두 번째 배열의 해당 요소와 재귀 적으로 일치하는 경우 (즉, &quot;in&quot;) 두 개의 배열이 스마트 일치합니다.</target>
        </trans-unit>
        <trans-unit id="ef9d289482c44cedd928e08a539e06da234c1ea2" translate="yes" xml:space="preserve">
          <source>Two directories</source>
          <target state="translated">두 개의 디렉토리</target>
        </trans-unit>
        <trans-unit id="4932b4ce84c4a3c76d97d8ddc1677ad9583f731a" translate="yes" xml:space="preserve">
          <source>Two exceptions are fseek() and ftell(). 32-bit applications should use fseeko(3C) and ftello(3C). These will get automatically mapped to fseeko64() and ftello64().</source>
          <target state="translated">fseek ()와 ftell ()은 예외입니다. 32 비트 응용 프로그램은 fseeko (3C) 및 ftello (3C)를 사용해야합니다. 이들은 fseeko64 () 및 ftello64 ​​()에 자동으로 매핑됩니다.</target>
        </trans-unit>
        <trans-unit id="59e6099a51676c8b357d47058d648615908e9535" translate="yes" xml:space="preserve">
          <source>Two functions are provided by</source>
          <target state="translated">두 가지 기능이 제공됩니다</target>
        </trans-unit>
        <trans-unit id="362495d14b1f3b1a8e9077a2b6d2d038307cf755" translate="yes" xml:space="preserve">
          <source>Two functions are provided to perform in-memory compression/uncompression of RFC 1950 data streams. They are called &lt;code&gt;compress&lt;/code&gt; and &lt;code&gt;uncompress&lt;/code&gt; .</source>
          <target state="translated">RFC 1950 데이터 스트림의 메모리 내 압축 / 압축 해제를 수행하는 두 가지 기능이 제공됩니다. &lt;code&gt;compress&lt;/code&gt; 및 &lt;code&gt;uncompress&lt;/code&gt; 라고 합니다.</target>
        </trans-unit>
        <trans-unit id="60a9bef4c585c40271adbc6700cd51119d598e56" translate="yes" xml:space="preserve">
          <source>Two functions are provided to perform in-memory compression/uncompression of RFC 1950 data streams. They are called &lt;code&gt;compress&lt;/code&gt; and &lt;code&gt;uncompress&lt;/code&gt;.</source>
          <target state="translated">RFC 1950 데이터 스트림의 메모리 내 압축 / 압축 해제를 수행하기 위해 두 가지 기능이 제공됩니다. 이를 &lt;code&gt;compress&lt;/code&gt; 및 &lt;code&gt;uncompress&lt;/code&gt; 라고 합니다.</target>
        </trans-unit>
        <trans-unit id="a1fae0daa00d9847553b4c2af0e0bfcf15f43ad2" translate="yes" xml:space="preserve">
          <source>Two hexadecimal numbers separated by horizontal whitespace (space or tabular characters) denoting a range of code points to include.</source>
          <target state="translated">포함 할 코드 포인트 범위를 나타내는 가로 공백 (공백 또는 테이블 문자)으로 구분 된 두 개의 16 진수입니다.</target>
        </trans-unit>
        <trans-unit id="7fe7068b60f3e31f3d2f257534aa6f46077e516b" translate="yes" xml:space="preserve">
          <source>Two hexadecimal numbers separated by horizontal whitespace (space or tabular characters) denoting a range of code points to include. The second number must not be smaller than the first.</source>
          <target state="translated">포함 할 코드 포인트 범위를 나타내는 수평 공백 (공백 또는 표 문자)으로 구분 된 두 개의 16 진수입니다. 두 번째 숫자는 첫 번째 숫자보다 작아서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="fc8d21d4a74e99aae1a5fc40b83d3fff90123b23" translate="yes" xml:space="preserve">
          <source>Two nested identical markup commands have been found. Generally this does not make sense.</source>
          <target state="translated">두 개의 동일한 동일한 마크 업 명령이 발견되었습니다. 일반적으로 이것은 의미가 없습니다.</target>
        </trans-unit>
        <trans-unit id="5e76b53030582383f7d551a5e77c668c449dbb3b" translate="yes" xml:space="preserve">
          <source>Two of the codes specified by the standard (XTS which is reserved for testing purposes and XXX which is for transactions where no currency is involved) are omitted.</source>
          <target state="translated">표준에 의해 지정된 두 가지 코드 (테스트 목적으로 예약 된 XTS와 통화가없는 거래를위한 XXX)는 생략됩니다.</target>
        </trans-unit>
        <trans-unit id="a1d006aec19b5d26f771c4cb3b1aa7d14cd4a562" translate="yes" xml:space="preserve">
          <source>Two or more suspects remain</source>
          <target state="translated">두 명 이상의 용의자가 남아있다</target>
        </trans-unit>
        <trans-unit id="069f392f8b693bf3f912fa721edb551769786910" translate="yes" xml:space="preserve">
          <source>Two other &quot;encapsulation&quot; macros are the PERL_GLOBAL_STRUCT and PERL_GLOBAL_STRUCT_PRIVATE (the latter turns on the former, and the former turns on MULTIPLICITY.) The PERL_GLOBAL_STRUCT causes all the internal variables of Perl to be wrapped inside a single global struct, struct perl_vars, accessible as (globals) &amp;amp;PL_Vars or PL_VarsPtr or the function Perl_GetVars(). The PERL_GLOBAL_STRUCT_PRIVATE goes one step further, there is still a single struct (allocated in main() either from heap or from stack) but there are no global data symbols pointing to it. In either case the global struct should be initialized as the very first thing in main() using Perl_init_global_struct() and correspondingly tear it down after perl_free() using Perl_free_global_struct(), please see</source>
          <target state="translated">다른 두 개의 &quot;캡슐화&quot;매크로는 PERL_GLOBAL_STRUCT 및 PERL_GLOBAL_STRUCT_PRIVATE입니다 (후자는 전자를 켠 후 전자는 멀티를 켭니다). PERL_GLOBAL_STRUCT는 Perl의 모든 내부 변수가 단일 전역 구조체 내에 랩핑되도록합니다. (전역) &amp;amp; PL_Vars 또는 PL_VarsPtr 또는 Perl_GetVars () 함수. PERL_GLOBAL_STRUCT_PRIVATE는 한 단계 더 나아갑니다. 힙이나 스택에서 main ()에 할당 된 단일 구조체가 있지만이를 가리키는 전역 데이터 기호는 없습니다. 어느 경우 든 전역 구조체는 Perl_init_global_struct ()를 사용하여 main ()에서 가장 먼저 초기화해야하며, 이에 따라 Perl_free_global_struct ()를 사용하여 perl_free () 후에 해제해야합니다.</target>
        </trans-unit>
        <trans-unit id="9e4d897b2c15b7e4e4ca9fbaec8aab25f6b14e93" translate="yes" xml:space="preserve">
          <source>Two possible uses (besides ignoring the property) come to mind. A singleton class could be implemented this using the generic object. If necessary, an &lt;code&gt;init()&lt;/code&gt; method could die or ignore calls with actual objects (references), so only the generic object will ever exist.</source>
          <target state="translated">(재산을 무시하는 것 외에) 두 가지 가능한 용도가 떠 오릅니다. 단일 객체 클래스를 일반 객체를 사용하여 구현할 수 있습니다. 필요한 경우, &lt;code&gt;init()&lt;/code&gt; 메소드는 실제 객체 (참조)에 대한 호출을 죽이거나 무시할 수 있으므로 일반 객체 만 존재합니다.</target>
        </trans-unit>
        <trans-unit id="b02b6a9a4575d62354db7ec75686a98545f9466d" translate="yes" xml:space="preserve">
          <source>Two potentially non-obvious but traditional &lt;a href=&quot;#flock-FILEHANDLE%2COPERATION&quot;&gt;&lt;code&gt;flock&lt;/code&gt;&lt;/a&gt; semantics are that it waits indefinitely until the lock is granted, and that its locks are &lt;b&gt;merely advisory&lt;/b&gt;. Such discretionary locks are more flexible, but offer fewer guarantees. This means that programs that do not also use &lt;a href=&quot;#flock-FILEHANDLE%2COPERATION&quot;&gt;&lt;code&gt;flock&lt;/code&gt;&lt;/a&gt; may modify files locked with &lt;a href=&quot;#flock-FILEHANDLE%2COPERATION&quot;&gt;&lt;code&gt;flock&lt;/code&gt;&lt;/a&gt;. See &lt;a href=&quot;perlport&quot;&gt;perlport&lt;/a&gt;, your port's specific documentation, and your system-specific local manpages for details. It's best to assume traditional behavior if you're writing portable programs. (But if you're not, you should as always feel perfectly free to write for your own system's idiosyncrasies (sometimes called &quot;features&quot;). Slavish adherence to portability concerns shouldn't get in the way of your getting your job done.)</source>
          <target state="translated">잠재적으로 명확하지 않지만 전통적인 &lt;a href=&quot;#flock-FILEHANDLE%2COPERATION&quot;&gt; &lt;code&gt;flock&lt;/code&gt; &lt;/a&gt; 의미론은 잠금이 부여 될 때까지 무기한 대기하고 잠금이 &lt;b&gt;단지 자문이라는 것&lt;/b&gt; 입니다. 이러한 임의 잠금은 더 유연하지만 보장은 더 적습니다. 이 수단은 사용하지 않는 프로그램 것을 &lt;a href=&quot;#flock-FILEHANDLE%2COPERATION&quot;&gt; &lt;code&gt;flock&lt;/code&gt; &lt;/a&gt; 파일을 수정할 수는 잠겨 &lt;a href=&quot;#flock-FILEHANDLE%2COPERATION&quot;&gt; &lt;code&gt;flock&lt;/code&gt; &lt;/a&gt; . &lt;a href=&quot;perlport&quot;&gt;perlport&lt;/a&gt; 참조, 포트 별 설명서 및 시스템 별 로컬 맨 페이지를 참조하십시오. 이식 가능한 프로그램을 작성하는 경우 전통적인 동작을 가정하는 것이 가장 좋습니다. (그러나 그렇지 않다면, 자신의 시스템의 특이성 (때때로 &quot;기능&quot;이라고도 함)에 대해 작성하는 것이 항상 완벽하게 자유로 워야합니다. 휴대 성 문제에 대한 노예적인 고수가 작업을 완료하는 데 방해가되어서는 안됩니다.)</target>
        </trans-unit>
        <trans-unit id="70abff015732d480e204353f739476e826fe7dc6" translate="yes" xml:space="preserve">
          <source>Two potentially non-obvious but traditional &lt;code&gt;&lt;a href=&quot;flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; semantics are that it waits indefinitely until the lock is granted, and that its locks are &lt;b&gt;merely advisory&lt;/b&gt;. Such discretionary locks are more flexible, but offer fewer guarantees. This means that programs that do not also use &lt;code&gt;&lt;a href=&quot;flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; may modify files locked with &lt;code&gt;&lt;a href=&quot;flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt;. See &lt;a href=&quot;../perlport&quot;&gt;perlport&lt;/a&gt;, your port's specific documentation, and your system-specific local manpages for details. It's best to assume traditional behavior if you're writing portable programs. (But if you're not, you should as always feel perfectly free to write for your own system's idiosyncrasies (sometimes called &quot;features&quot;). Slavish adherence to portability concerns shouldn't get in the way of your getting your job done.)</source>
          <target state="translated">잠재적으로 불명확하지만 기존의 두 &lt;code&gt;&lt;a href=&quot;flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; 의미론은 잠금이 부여 될 때까지 무기한 대기하고 잠금은 &lt;b&gt;단지 자문이라는 것&lt;/b&gt; 입니다. 이러한 임의 잠금은 더 융통성이 있지만 보장은 적습니다. 이 수단은 사용하지 않는 프로그램 것을 &lt;code&gt;&lt;a href=&quot;flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; 파일을 수정할 수는 잠겨 &lt;code&gt;&lt;a href=&quot;flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; . &lt;a href=&quot;../perlport&quot;&gt;perlport&lt;/a&gt; 참조자세한 내용은 포트의 특정 설명서 및 시스템 별 로컬 맨 페이지를 참조하십시오. 휴대용 프로그램을 작성하는 경우 기존의 행동을 가정하는 것이 가장 좋습니다. (그렇지 않으면 항상 자신의 시스템 특질 ( &quot;기능&quot;이라고도 함)에 대해 자유롭게 작성해야합니다. 이식성 문제에 대한 엄격한 준수가 업무를 수행하는 데 방해가되지 않아야합니다.)</target>
        </trans-unit>
        <trans-unit id="3c9f59ec6423987c8c2fe5d0858f160205e3fc59" translate="yes" xml:space="preserve">
          <source>Two potentially non-obvious but traditional &lt;code&gt;&lt;a href=&quot;functions/flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; semantics are that it waits indefinitely until the lock is granted, and that its locks are &lt;b&gt;merely advisory&lt;/b&gt;. Such discretionary locks are more flexible, but offer fewer guarantees. This means that programs that do not also use &lt;code&gt;&lt;a href=&quot;functions/flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; may modify files locked with &lt;code&gt;&lt;a href=&quot;functions/flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt;. See &lt;a href=&quot;perlport&quot;&gt;perlport&lt;/a&gt;, your port's specific documentation, and your system-specific local manpages for details. It's best to assume traditional behavior if you're writing portable programs. (But if you're not, you should as always feel perfectly free to write for your own system's idiosyncrasies (sometimes called &quot;features&quot;). Slavish adherence to portability concerns shouldn't get in the way of your getting your job done.)</source>
          <target state="translated">잠재적으로 불명확하지만 기존의 두 &lt;code&gt;&lt;a href=&quot;functions/flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; 의미론은 잠금이 부여 될 때까지 무기한 대기하고 잠금은 &lt;b&gt;단지 자문이라는 것&lt;/b&gt; 입니다. 이러한 임의 잠금은 더 융통성이 있지만 보장은 적습니다. 이 수단은 사용하지 않는 프로그램 것을 &lt;code&gt;&lt;a href=&quot;functions/flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; 파일을 수정할 수는 잠겨 &lt;code&gt;&lt;a href=&quot;functions/flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; . &lt;a href=&quot;perlport&quot;&gt;perlport&lt;/a&gt; 참조자세한 내용은 포트의 특정 설명서 및 시스템 별 로컬 맨 페이지를 참조하십시오. 휴대용 프로그램을 작성하는 경우 기존의 행동을 가정하는 것이 가장 좋습니다. (그렇지 않으면 항상 자신의 시스템 특질 ( &quot;기능&quot;이라고도 함)에 대해 자유롭게 작성해야합니다. 이식성 문제에 대한 엄격한 준수가 업무를 수행하는 데 방해가되지 않아야합니다.)</target>
        </trans-unit>
        <trans-unit id="53df84b423920613232d12c96d5eb675ef01a9db" translate="yes" xml:space="preserve">
          <source>Two potentially non-obvious but traditional flock semantics are that it waits indefinitely until the lock is granted, and that its locks are</source>
          <target state="translated">잠재적으로 명확하지 않지만 기존의 두 무리 의미론은 잠금이 부여 될 때까지 무기한 대기하고 잠금이</target>
        </trans-unit>
        <trans-unit id="778a62aee9043b393531476babc83e7e729243c9" translate="yes" xml:space="preserve">
          <source>Two special locales are worth particular mention: &quot;C&quot; and &quot;POSIX&quot;. Currently these are effectively the same locale: the difference is mainly that the first one is defined by the C standard, the second by the POSIX standard. They define the &lt;b&gt;default locale&lt;/b&gt; in which every program starts in the absence of locale information in its environment. (The</source>
          <target state="translated">&quot;C&quot;와 &quot;POSIX&quot;라는 두 가지 특별한 로케일이 특별히 언급 될 가치가 있습니다. 현재 이들은 사실상 동일한 로케일입니다. 차이점은 주로 첫 번째는 C 표준으로, 두 번째는 POSIX 표준으로 정의된다는 것입니다. 환경에 로케일 정보가없는 상태에서 모든 프로그램이 시작되는 &lt;b&gt;기본 로케일&lt;/b&gt; 을 정의 합니다. (그만큼</target>
        </trans-unit>
        <trans-unit id="001ed180b265179aa35dbaf576484db20b8f3115" translate="yes" xml:space="preserve">
          <source>Two special marker lines will bracket debugging code, like this:</source>
          <target state="translated">두 개의 특수 마커 라인은 다음과 같이 디버깅 코드를 괄호로 묶습니다.</target>
        </trans-unit>
        <trans-unit id="fc4c89a57e0f51cea54d0e2e158fcc3083bc5fa2" translate="yes" xml:space="preserve">
          <source>Two threads both access &lt;code&gt;$x&lt;/code&gt; . Each thread can potentially be interrupted at any point, or be executed in any order. At the end, &lt;code&gt;$x&lt;/code&gt; could be 3 or 4, and both &lt;code&gt;$y&lt;/code&gt; and &lt;code&gt;$z&lt;/code&gt; could be 2 or 3.</source>
          <target state="translated">두 개의 스레드가 모두 &lt;code&gt;$x&lt;/code&gt; 액세스 합니다. 각 스레드는 잠재적으로 언제라도 중단되거나 순서에 관계없이 실행될 수 있습니다. 결국 &lt;code&gt;$x&lt;/code&gt; 는 3 또는 4가 될 수 있으며 &lt;code&gt;$y&lt;/code&gt; 와 &lt;code&gt;$z&lt;/code&gt; 는 2 또는 3이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ed596ad5315f7ee111b20fc3225326599075e7d0" translate="yes" xml:space="preserve">
          <source>Two threads both access &lt;code&gt;$x&lt;/code&gt;. Each thread can potentially be interrupted at any point, or be executed in any order. At the end, &lt;code&gt;$x&lt;/code&gt; could be 3 or 4, and both &lt;code&gt;$y&lt;/code&gt; and &lt;code&gt;$z&lt;/code&gt; could be 2 or 3.</source>
          <target state="translated">두 개의 스레드가 모두 &lt;code&gt;$x&lt;/code&gt; 액세스 합니다. 각 스레드는 잠재적으로 언제든지 중단되거나 임의의 순서로 실행될 수 있습니다. 결국 &lt;code&gt;$x&lt;/code&gt; 는 3 또는 4가 될 수 있으며 &lt;code&gt;$y&lt;/code&gt; 와 &lt;code&gt;$z&lt;/code&gt; 는 둘 다 2 또는 3이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a040608578e9e9c915007f47fc1e5b14ac218a6c" translate="yes" xml:space="preserve">
          <source>Two ways. One is to build the module normally...</source>
          <target state="translated">두 가지 방법. 하나는 모듈을 정상적으로 빌드하는 것입니다 ...</target>
        </trans-unit>
        <trans-unit id="aed361ca9a7b196027b5db9a2f0828216a331df8" translate="yes" xml:space="preserve">
          <source>Two's complement (bitwise not). This is equivalent to</source>
          <target state="translated">2의 보수 (비트 단위는 아님). 이것은</target>
        </trans-unit>
        <trans-unit id="1f8bb2682169008d50215675c388c14028479675" translate="yes" xml:space="preserve">
          <source>Two's complement (bitwise not). This is equivalent to, but faster than,</source>
          <target state="translated">2의 보수 (비트 아님). 이것은 동등하지만 더 빠릅니다.</target>
        </trans-unit>
        <trans-unit id="ec9798b2ceec50b36efb45258055740cd070510f" translate="yes" xml:space="preserve">
          <source>Two-arg &lt;a href=&quot;perlfunc#open-FILEHANDLE%2CMODE%2CEXPR&quot;&gt;&lt;code&gt;open&lt;/code&gt;&lt;/a&gt; is magic and can translate characters like &lt;code&gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;&lt;/code&gt;, and &lt;code&gt;|&lt;/code&gt; in filenames, which is usually the wrong thing to do. &lt;a href=&quot;perlfunc#sysopen-FILEHANDLE%2CFILENAME%2CMODE&quot;&gt;&lt;code&gt;sysopen&lt;/code&gt;&lt;/a&gt; and three-arg &lt;a href=&quot;perlfunc#open-FILEHANDLE%2CMODE%2CEXPR&quot;&gt;&lt;code&gt;open&lt;/code&gt;&lt;/a&gt; don't have this problem.</source>
          <target state="translated">Two-arg &lt;a href=&quot;perlfunc#open-FILEHANDLE%2CMODE%2CEXPR&quot;&gt; &lt;code&gt;open&lt;/code&gt; &lt;/a&gt; 은 마법이며 &lt;code&gt;&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;&lt;/code&gt; , &lt;code&gt;|&lt;/code&gt; 와 같은 문자를 번역 할 수 있습니다. 일반적으로 잘못된 작업입니다. &lt;a href=&quot;perlfunc#sysopen-FILEHANDLE%2CFILENAME%2CMODE&quot;&gt; &lt;code&gt;sysopen&lt;/code&gt; &lt;/a&gt; 및 three-arg &lt;a href=&quot;perlfunc#open-FILEHANDLE%2CMODE%2CEXPR&quot;&gt; &lt;code&gt;open&lt;/code&gt; &lt;/a&gt; 에는이 문제가 없습니다.</target>
        </trans-unit>
        <trans-unit id="639570380139caf69541c926ba46013c3318dc90" translate="yes" xml:space="preserve">
          <source>Two-face References</source>
          <target state="translated">양면 참조</target>
        </trans-unit>
        <trans-unit id="ae90b2c9e3f2f4b661468b3ddaef859dd9bff8a2" translate="yes" xml:space="preserve">
          <source>Two-face Scalars</source>
          <target state="translated">양면 스칼라</target>
        </trans-unit>
        <trans-unit id="f60980a56996745ba95f06a5f138b8e86a98d3dd" translate="yes" xml:space="preserve">
          <source>Tye McQueen, tye@metronet.com, http://perlmonks.org/?node=tye.</source>
          <target state="translated">Tye McQueen, tye@metronet.com, http://perlmonks.org/?node=tye.</target>
        </trans-unit>
        <trans-unit id="47708aacd7aae4d98506843c2ea25848ad8c524c" translate="yes" xml:space="preserve">
          <source>Tying Arrays</source>
          <target state="translated">배열 묶기</target>
        </trans-unit>
        <trans-unit id="29fe0e127980eab253dd9684cf8924d1439a9c07" translate="yes" xml:space="preserve">
          <source>Tying Arrays by Casey West &amp;lt;</source>
          <target state="translated">Casey West로 배열 묶기 &amp;lt;</target>
        </trans-unit>
        <trans-unit id="1cb864932b4ba6b40040bda147b28500825da685" translate="yes" xml:space="preserve">
          <source>Tying FileHandles</source>
          <target state="translated">파일 핸들링</target>
        </trans-unit>
        <trans-unit id="c44951e9133e5d8875fa8e60d17eb7ca4e5ec846" translate="yes" xml:space="preserve">
          <source>Tying Hashes</source>
          <target state="translated">해시 묶기</target>
        </trans-unit>
        <trans-unit id="c124692dc36c13d6ea9eefe451091514b3053308" translate="yes" xml:space="preserve">
          <source>Tying Scalars</source>
          <target state="translated">스칼라 매기</target>
        </trans-unit>
        <trans-unit id="dd441f6c670bdd175a4a06606b3ade32864a5013" translate="yes" xml:space="preserve">
          <source>Tying to an already-opened filehandle</source>
          <target state="translated">이미 열린 파일 핸들에 연결</target>
        </trans-unit>
        <trans-unit id="3deb7456519697ecf4eefc455516c969a3681bae" translate="yes" xml:space="preserve">
          <source>Type</source>
          <target state="translated">Type</target>
        </trans-unit>
        <trans-unit id="b987ff7b7058c91b5723d0647b696ba512fc503e" translate="yes" xml:space="preserve">
          <source>Type &quot;dmake install&quot; (or &quot;gmake install&quot;, &quot;nmake install&quot;). This will put the newly built perl and the libraries under whatever &lt;code&gt;INST_TOP&lt;/code&gt; points to in the Makefile. It will also install the pod documentation under &lt;code&gt;$INST_TOP\$INST_VER\lib\pod&lt;/code&gt; and HTML versions of the same under &lt;code&gt;$INST_TOP\$INST_VER\lib\pod\html&lt;/code&gt;.</source>
          <target state="translated">&quot;dmake install&quot;(또는 &quot;gmake install&quot;, &quot;nmake install&quot;)을 입력합니다. 이렇게하면 새로 빌드 된 펄과 라이브러리 가 Makefile에서 &lt;code&gt;INST_TOP&lt;/code&gt; 가 가리키는 모든 항목 아래에 놓이게 됩니다. 또한 &lt;code&gt;$INST_TOP\$INST_VER\lib\pod&lt;/code&gt; 아래에 포드 문서를 설치하고 &lt;code&gt;$INST_TOP\$INST_VER\lib\pod\html&lt;/code&gt; 아래에 동일한 HTML 버전을 설치합니다 .</target>
        </trans-unit>
        <trans-unit id="622fe690390119c9b2836b529615b923c08f64da" translate="yes" xml:space="preserve">
          <source>Type &quot;dmake install&quot; (or &quot;nmake install&quot;). This will put the newly built perl and the libraries under whatever &lt;code&gt;INST_TOP&lt;/code&gt; points to in the Makefile. It will also install the pod documentation under &lt;code&gt;$INST_TOP\$INST_VER\lib\pod&lt;/code&gt; and HTML versions of the same under &lt;code&gt;$INST_TOP\$INST_VER\lib\pod\html&lt;/code&gt; .</source>
          <target state="translated">&quot;dmake install&quot;(또는 &quot;nmake install&quot;)을 입력하십시오. 이렇게하면 새로 구축 된 perl과 라이브러리 가 Makefile에서 가리키는 &lt;code&gt;INST_TOP&lt;/code&gt; 아래에 놓 입니다. 또한 &lt;code&gt;$INST_TOP\$INST_VER\lib\pod&lt;/code&gt; 포드 문서를 설치하고 &lt;code&gt;$INST_TOP\$INST_VER\lib\pod\html&lt;/code&gt; HTML 버전을 설치합니다 .</target>
        </trans-unit>
        <trans-unit id="0bc4b446d209674d0e9fea7244b04c4c376a3eb5" translate="yes" xml:space="preserve">
          <source>Type &quot;dmake test&quot; (or &quot;gmake test&quot;, &quot;nmake test&quot;). This will run most of the tests from the testsuite (many tests will be skipped).</source>
          <target state="translated">&quot;dmake test&quot;(또는 &quot;gmake test&quot;, &quot;nmake test&quot;)를 입력합니다. 이것은 testsuite에서 대부분의 테스트를 실행합니다 (많은 테스트를 건너 뜁니다).</target>
        </trans-unit>
        <trans-unit id="48996994efbc36adb9197c655f8807f921339671" translate="yes" xml:space="preserve">
          <source>Type &quot;dmake test&quot; (or &quot;nmake test&quot;). This will run most of the tests from the testsuite (many tests will be skipped).</source>
          <target state="translated">&quot;dmake test&quot;(또는 &quot;nmake test&quot;)를 입력하십시오. 테스트 슈트에서 대부분의 테스트가 실행됩니다 (많은 테스트는 건너 뜁니다).</target>
        </trans-unit>
        <trans-unit id="ce74e5125b2ce8cfe1e9037bd6ca72c9f8e02d8e" translate="yes" xml:space="preserve">
          <source>Type &quot;dmake&quot; (&quot;gmake&quot; for GNU make, or &quot;nmake&quot; if you are using that make).</source>
          <target state="translated">&quot;dmake&quot;(GNU make의 경우 &quot;gmake&quot;, 해당 make를 사용하는 경우 &quot;nmake&quot;)를 입력합니다.</target>
        </trans-unit>
        <trans-unit id="e707f55e50471f8dc7a11eb61a45491656e65c20" translate="yes" xml:space="preserve">
          <source>Type &quot;dmake&quot; (or &quot;nmake&quot; if you are using that make).</source>
          <target state="translated">&quot;dmake&quot;(또는 해당 make를 사용하는 경우 &quot;nmake&quot;)를 입력하십시오.</target>
        </trans-unit>
        <trans-unit id="817cc5b4f0c413465ec1e98078f923e58ba436f8" translate="yes" xml:space="preserve">
          <source>Type &lt;code&gt;perl -v&lt;/code&gt; at the command line to find out.</source>
          <target state="translated">명령 행에 &lt;code&gt;perl -v&lt;/code&gt; 를 입력 하여 찾으십시오.</target>
        </trans-unit>
        <trans-unit id="9226639af847a9b60c06b437bbd1474fd6ad1ed2" translate="yes" xml:space="preserve">
          <source>Type =&amp;gt; INT</source>
          <target state="translated">유형 =&amp;gt; INT</target>
        </trans-unit>
        <trans-unit id="8d4464e66323935602a00348988e0d51aae9ab21" translate="yes" xml:space="preserve">
          <source>Type flag for I/O objects. See &lt;a href=&quot;#svtype&quot;&gt;&quot;svtype&quot;&lt;/a&gt;.</source>
          <target state="translated">I / O 개체에 대한 유형 플래그입니다. &lt;a href=&quot;#svtype&quot;&gt;&quot;svtype&quot;을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="470a91ba8a41cc959ff1b12a936c2603408f2a81" translate="yes" xml:space="preserve">
          <source>Type flag for I/O objects. See &lt;a href=&quot;#svtype&quot;&gt;svtype&lt;/a&gt;.</source>
          <target state="translated">I / O 오브젝트의 유형 플래그. &lt;a href=&quot;#svtype&quot;&gt;svtype을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0214e8a20ca847239102bda8ea4c8f57bc680a1d" translate="yes" xml:space="preserve">
          <source>Type flag for arrays. See &lt;a href=&quot;#svtype&quot;&gt;&quot;svtype&quot;&lt;/a&gt;.</source>
          <target state="translated">배열의 유형 플래그입니다. &lt;a href=&quot;#svtype&quot;&gt;&quot;svtype&quot;을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="115e0f5825d2a5e2437586f43a3052a4bc413be2" translate="yes" xml:space="preserve">
          <source>Type flag for arrays. See &lt;a href=&quot;#svtype&quot;&gt;svtype&lt;/a&gt;.</source>
          <target state="translated">배열의 타입 플래그. &lt;a href=&quot;#svtype&quot;&gt;svtype을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b619926ff72ff70acdcfb56667bc380fd10917da" translate="yes" xml:space="preserve">
          <source>Type flag for formats. See &lt;a href=&quot;#svtype&quot;&gt;&quot;svtype&quot;&lt;/a&gt;.</source>
          <target state="translated">형식에 대한 유형 플래그입니다. &lt;a href=&quot;#svtype&quot;&gt;&quot;svtype&quot;을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="5424ebb415da653ce11cbaa80efe5caaa204e71c" translate="yes" xml:space="preserve">
          <source>Type flag for formats. See &lt;a href=&quot;#svtype&quot;&gt;svtype&lt;/a&gt;.</source>
          <target state="translated">형식에 대한 유형 플래그. &lt;a href=&quot;#svtype&quot;&gt;svtype을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="862128cc96218003cbfad3b7ee14c34ad3105872" translate="yes" xml:space="preserve">
          <source>Type flag for hashes. See &lt;a href=&quot;#svtype&quot;&gt;&quot;svtype&quot;&lt;/a&gt;.</source>
          <target state="translated">해시에 대한 유형 플래그입니다. &lt;a href=&quot;#svtype&quot;&gt;&quot;svtype&quot;을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="11f3d189f9118d5a6a717d6df4d8bfc5dd5c80fb" translate="yes" xml:space="preserve">
          <source>Type flag for hashes. See &lt;a href=&quot;#svtype&quot;&gt;svtype&lt;/a&gt;.</source>
          <target state="translated">해시에 대한 유형 플래그. &lt;a href=&quot;#svtype&quot;&gt;svtype을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a9baa4a58d00e83fc0bcce1af37a4d54939255e4" translate="yes" xml:space="preserve">
          <source>Type flag for regular expressions. See &lt;a href=&quot;#svtype&quot;&gt;&quot;svtype&quot;&lt;/a&gt;.</source>
          <target state="translated">정규식에 대한 유형 플래그입니다. &lt;a href=&quot;#svtype&quot;&gt;&quot;svtype&quot;을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="7697ce082ff72de4bd1f6e232aec1e708c3e949b" translate="yes" xml:space="preserve">
          <source>Type flag for regular expressions. See &lt;a href=&quot;#svtype&quot;&gt;svtype&lt;/a&gt;.</source>
          <target state="translated">정규식에 대한 유형 플래그. &lt;a href=&quot;#svtype&quot;&gt;svtype을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="68fd7e6db2e32b4d1268770600fb508ba841fcb6" translate="yes" xml:space="preserve">
          <source>Type flag for scalars. See &lt;a href=&quot;#svtype&quot;&gt;&quot;svtype&quot;&lt;/a&gt;.</source>
          <target state="translated">스칼라에 대한 유형 플래그입니다. &lt;a href=&quot;#svtype&quot;&gt;&quot;svtype&quot;을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="8842ec0ce8ceed5f394b670f4b4d43838af8af85" translate="yes" xml:space="preserve">
          <source>Type flag for scalars. See &lt;a href=&quot;#svtype&quot;&gt;svtype&lt;/a&gt;.</source>
          <target state="translated">스칼라에 대한 유형 플래그. &lt;a href=&quot;#svtype&quot;&gt;svtype을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="dc19461206b9d4e886495f08f330852592ae56f4" translate="yes" xml:space="preserve">
          <source>Type flag for scalars. See &lt;a href=&quot;perlapi#svtype&quot;&gt;&quot;svtype&quot; in perlapi&lt;/a&gt;.</source>
          <target state="translated">스칼라에 대한 유형 플래그입니다. &lt;a href=&quot;perlapi#svtype&quot;&gt;perlapi의 &quot;svtype&quot;을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="fc3eaa4bcf13a8b0cfd50d989093647d196bc08a" translate="yes" xml:space="preserve">
          <source>Type flag for subroutines. See &lt;a href=&quot;#svtype&quot;&gt;&quot;svtype&quot;&lt;/a&gt;.</source>
          <target state="translated">서브 루틴에 대한 유형 플래그입니다. &lt;a href=&quot;#svtype&quot;&gt;&quot;svtype&quot;을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ba6e0906867866e6b4c76c1aa73ce8fb1ddab2a4" translate="yes" xml:space="preserve">
          <source>Type flag for subroutines. See &lt;a href=&quot;#svtype&quot;&gt;svtype&lt;/a&gt;.</source>
          <target state="translated">서브 루틴의 유형 플래그. &lt;a href=&quot;#svtype&quot;&gt;svtype을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b728a87739a1b53338d9a99924f6b87621554866" translate="yes" xml:space="preserve">
          <source>Type flag for typeglobs. See &lt;a href=&quot;#svtype&quot;&gt;&quot;svtype&quot;&lt;/a&gt;.</source>
          <target state="translated">typeglobs에 대한 유형 플래그입니다. &lt;a href=&quot;#svtype&quot;&gt;&quot;svtype&quot;을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="5d98af6202cdf505f81d6de89907f306acd604bb" translate="yes" xml:space="preserve">
          <source>Type flag for typeglobs. See &lt;a href=&quot;#svtype&quot;&gt;svtype&lt;/a&gt;.</source>
          <target state="translated">typeglobs의 타입 플래그. &lt;a href=&quot;#svtype&quot;&gt;svtype을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b83265a2400fad6fae10ac8b63f66f6aa5168ddc" translate="yes" xml:space="preserve">
          <source>Type of arg %d to %s must be %s (not %s)</source>
          <target state="translated">% d에서 % s까지의 인수 유형은 % s 여야합니다 (% s 아님).</target>
        </trans-unit>
        <trans-unit id="33daa9fc448c1a401c5c6eb564a12a3b5b0309c7" translate="yes" xml:space="preserve">
          <source>Type of arg %d to &amp;amp;CORE::%s must be %s</source>
          <target state="translated">% d에서 &amp;amp; CORE :: % s까지의 인수 유형은 % s 여야합니다.</target>
        </trans-unit>
        <trans-unit id="e47d64cc94d0acfc0cdbf0b2c9dd711351e0f339" translate="yes" xml:space="preserve">
          <source>Type of first matching node.</source>
          <target state="translated">첫 번째 일치 노드의 유형입니다.</target>
        </trans-unit>
        <trans-unit id="82be69629fdb03e428153252cb628a3089333b85" translate="yes" xml:space="preserve">
          <source>Type-casting operator.</source>
          <target state="translated">타입 캐스팅 연산자.</target>
        </trans-unit>
        <trans-unit id="3c6b62766a1a668fd13ee2f54c72526e46bdd675" translate="yes" xml:space="preserve">
          <source>Type-specific attribute handlers</source>
          <target state="translated">유형별 속성 핸들러</target>
        </trans-unit>
        <trans-unit id="ee3fb11d05c90c37311491cf33008925b13b487f" translate="yes" xml:space="preserve">
          <source>Type:</source>
          <target state="translated">Type:</target>
        </trans-unit>
        <trans-unit id="dacaa1ce7373acde846ee256ee267058f226c8cb" translate="yes" xml:space="preserve">
          <source>Typed lexicals</source>
          <target state="translated">유형 어휘</target>
        </trans-unit>
        <trans-unit id="764662b450b71457a1b7dac7680a6d81b8a030c7" translate="yes" xml:space="preserve">
          <source>Typeglob Slots</source>
          <target state="translated">Typeglob 슬롯</target>
        </trans-unit>
        <trans-unit id="35c58169317903405f89e446350d7099fc17650c" translate="yes" xml:space="preserve">
          <source>Typeglobs and Filehandles</source>
          <target state="translated">타입 글롭과 파일 핸들</target>
        </trans-unit>
        <trans-unit id="c93af0f29f506026f9bce190608810109efe41de" translate="yes" xml:space="preserve">
          <source>Typeglobs are also a way to create a local filehandle using the local() operator. These last until their block is exited, but may be passed back. For example:</source>
          <target state="translated">Typeglobs는 local () 연산자를 사용하여 로컬 파일 핸들을 만드는 방법이기도합니다. 블록이 종료 될 때까지 지속되지만 다시 전달 될 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ce5682fe2db39004dc33d1f245a642897d0ccef1" translate="yes" xml:space="preserve">
          <source>Typeless &lt;code&gt;abs&lt;/code&gt; or &lt;code&gt;fabs&lt;/code&gt;,</source>
          <target state="translated">Typeless &lt;code&gt;abs&lt;/code&gt; 또는 &lt;code&gt;fabs&lt;/code&gt; ,</target>
        </trans-unit>
        <trans-unit id="7c854e2c86ed5ebd580cf024fab8796f99c1a0f9" translate="yes" xml:space="preserve">
          <source>Types of Nodes</source>
          <target state="translated">노드의 종류</target>
        </trans-unit>
        <trans-unit id="54a79ea7d31cf3e80acf5e2ca6b3eef126289136" translate="yes" xml:space="preserve">
          <source>Typical frequently used settings:</source>
          <target state="translated">자주 사용되는 설정 :</target>
        </trans-unit>
        <trans-unit id="19f0351a6e0b3a0f7afdab28ba608c9abfed4106" translate="yes" xml:space="preserve">
          <source>Typical names for the single object key are &lt;code&gt;__class_whatever__&lt;/code&gt;, or &lt;code&gt;$__dollars_are_rarely_used__$&lt;/code&gt; or &lt;code&gt;}ugly_brace_placement&lt;/code&gt;, or even things like &lt;code&gt;__class_md5sum(classname)__&lt;/code&gt;, to reduce the risk of clashing with real hashes.</source>
          <target state="translated">단일 객체 키의 일반적인 이름은 &lt;code&gt;__class_whatever__&lt;/code&gt; 또는 &lt;code&gt;$__dollars_are_rarely_used__$&lt;/code&gt; 또는 &lt;code&gt;}ugly_brace_placement&lt;/code&gt; 또는 &lt;code&gt;__class_md5sum(classname)__&lt;/code&gt; 과 같은 이름 으로 실제 해시와의 충돌 위험을 줄입니다.</target>
        </trans-unit>
        <trans-unit id="eeee45f0582f2da790f6df23acb83c5b9ac37e5b" translate="yes" xml:space="preserve">
          <source>Typical usage is just:</source>
          <target state="translated">일반적인 사용법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9f433de3a09f2cf5cd13a827c57725457d725e39" translate="yes" xml:space="preserve">
          <source>Typical usage:</source>
          <target state="translated">일반적인 사용법 :</target>
        </trans-unit>
        <trans-unit id="f0a20c31caa817cfde9a5903c8d1331d2cc5ddae" translate="yes" xml:space="preserve">
          <source>Typical use is to do range checks on &lt;code&gt;uv&lt;/code&gt; before casting:</source>
          <target state="translated">일반적으로 캐스팅 전에 &lt;code&gt;uv&lt;/code&gt; 에서 범위 검사를 수행합니다 .</target>
        </trans-unit>
        <trans-unit id="0f7c555ca8af58d8be6641bce4c54e1f92594d54" translate="yes" xml:space="preserve">
          <source>Typical use of AutoSplit in the perl MakeMaker utility is via the command-line with:</source>
          <target state="translated">perl MakeMaker 유틸리티에서 AutoSplit의 일반적인 사용은 다음과 같은 명령 행을 통해 이루어집니다.</target>
        </trans-unit>
        <trans-unit id="2eb42fd8be2849b836904fd8c0478452015d5021" translate="yes" xml:space="preserve">
          <source>Typically displayed in italics. Example: &quot;&lt;code&gt;F&amp;lt;.cshrc&amp;gt;&lt;/code&gt; &quot;</source>
          <target state="translated">일반적으로 기울임 꼴로 표시됩니다. 예 : &quot; &lt;code&gt;F&amp;lt;.cshrc&amp;gt;&lt;/code&gt; &quot;</target>
        </trans-unit>
        <trans-unit id="b5d871a9c977277097fa4a829e659b06d6204d49" translate="yes" xml:space="preserve">
          <source>Typically displayed in italics. Example: &quot;&lt;code&gt;F&amp;lt;.cshrc&amp;gt;&lt;/code&gt;&quot;</source>
          <target state="translated">일반적으로 기울임 꼴로 표시됩니다. 예 : &quot; &lt;code&gt;F&amp;lt;.cshrc&amp;gt;&lt;/code&gt; &quot;</target>
        </trans-unit>
        <trans-unit id="e392be83caed3c91eae784a95dbf70091fef0bbc" translate="yes" xml:space="preserve">
          <source>Typically only necessary for debugging and testing, if you need to dump the internals of an SV, &lt;a href=&quot;Devel::Peek&quot;&gt;Devel::Peek's&lt;/a&gt; Dump() provides more detail in a compact form.</source>
          <target state="translated">일반적으로 디버깅 및 테스트에만 필요하며 SV의 내부를 덤프해야하는 경우 &lt;a href=&quot;Devel::Peek&quot;&gt;Devel :: Peek 's&lt;/a&gt; Dump ()는 압축 형식으로 더 자세한 정보를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="2a174345584e66d867781b1452d35dc4522e5c23" translate="yes" xml:space="preserve">
          <source>Typically only necessary for debugging and testing. Don't use this flag as a marker to distinguish character and binary data, that should be decided for each variable when you write your code.</source>
          <target state="translated">일반적으로 디버깅 및 테스트에만 필요합니다. 이 플래그를 문자 및 이진 데이터를 구분하는 마커로 사용하지 마십시오. 코드를 작성할 때 각 변수에 대해 결정해야합니다.</target>
        </trans-unit>
        <trans-unit id="0b14febd4050c6e9e7fff1ec1a1e04a32b2411b9" translate="yes" xml:space="preserve">
          <source>Typically render into NFD on input and NFC on output. Using NFKC or NFKD functions improves recall on searches, assuming you've already done to the same text to be searched. Note that this is about much more than just pre- combined compatibility glyphs; it also reorders marks according to their canonical combining classes and weeds out singletons.</source>
          <target state="translated">일반적으로 입력시 NFD로, 출력시 NFC로 렌더링합니다. NFKC 또는 NFKD 기능을 사용하면 검색 할 동일한 텍스트를 이미 수행했다고 가정 할 때 검색시 재 호출이 향상됩니다. 이것은 단지 사전 결합 된 호환성 글리프 이상이 아닙니다. 또한 정식 결합 클래스에 따라 마크를 재정렬하고 싱글 톤을 제거합니다.</target>
        </trans-unit>
        <trans-unit id="4aadd663fd22d97ef1413917c08e1ab3e9fe702e" translate="yes" xml:space="preserve">
          <source>Typically returns the string &lt;code&gt;at &amp;lt;FILE&amp;gt; line &amp;lt;LINE&amp;gt;&lt;/code&gt;. If &lt;code&gt;detail&lt;/code&gt; is set then its value will be returned instead.</source>
          <target state="translated">일반적으로 &lt;code&gt;at &amp;lt;FILE&amp;gt; line &amp;lt;LINE&amp;gt;&lt;/code&gt; 문자열 을 반환합니다 . &lt;code&gt;detail&lt;/code&gt; 가 설정 되면 해당 값이 대신 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="b5c564109e8a3afa5be0b031d855d9ae4aa0bbb3" translate="yes" xml:space="preserve">
          <source>Typically this is used to emulate &lt;code&gt;#!&lt;/code&gt; startup on platforms that don't support &lt;code&gt;#!&lt;/code&gt; . It's also convenient when debugging a script that uses &lt;code&gt;#!&lt;/code&gt; , and is thus normally found by the shell's $PATH search mechanism.</source>
          <target state="translated">일반적으로 &lt;code&gt;#!&lt;/code&gt; &lt;code&gt;#!&lt;/code&gt; 지원하지 않는 플랫폼에서 시작 ! . &lt;code&gt;#!&lt;/code&gt; 을 사용하는 스크립트를 디버깅 할 때도 편리합니다 ! 따라서 일반적으로 쉘의 $ PATH 검색 메커니즘에 의해 발견됩니다.</target>
        </trans-unit>
        <trans-unit id="0f7ce98ce055e01dae18470a5f2a3135a14234ad" translate="yes" xml:space="preserve">
          <source>Typically this is used to emulate &lt;code&gt;#!&lt;/code&gt; startup on platforms that don't support &lt;code&gt;#!&lt;/code&gt;. It's also convenient when debugging a script that uses &lt;code&gt;#!&lt;/code&gt;, and is thus normally found by the shell's $PATH search mechanism.</source>
          <target state="translated">일반적으로 이것은 &lt;code&gt;#!&lt;/code&gt; 지원하지 않는 플랫폼에서 시작 &lt;code&gt;#!&lt;/code&gt; . &lt;code&gt;#!&lt;/code&gt; 를 사용하는 스크립트를 디버깅 할 때도 편리합니다 . , 따라서 일반적으로 쉘의 $ PATH 검색 메커니즘에 의해 발견됩니다.</target>
        </trans-unit>
        <trans-unit id="687058d347f26c3b9dcf0508ed2f5930b5b6fa48" translate="yes" xml:space="preserve">
          <source>Typically used to finish the deflation. Any pending output will be returned via &lt;code&gt;$out&lt;/code&gt; . &lt;code&gt;$status&lt;/code&gt; will have a value &lt;code&gt;Z_OK&lt;/code&gt; if successful.</source>
          <target state="translated">일반적으로 수축을 완료하는 데 사용됩니다. 보류중인 출력은 &lt;code&gt;$out&lt;/code&gt; 통해 반환 됩니다 . 성공하면 &lt;code&gt;$status&lt;/code&gt; 의 값은 &lt;code&gt;Z_OK&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="4bb05899bf90c01639baa0fce37a7ffd38acaffb" translate="yes" xml:space="preserve">
          <source>Typically used to finish the deflation. Any pending output will be returned via &lt;code&gt;$out&lt;/code&gt;. &lt;code&gt;$status&lt;/code&gt; will have a value &lt;code&gt;Z_OK&lt;/code&gt; if successful.</source>
          <target state="translated">일반적으로 디플레이션을 완료하는 데 사용됩니다. 보류중인 출력은 &lt;code&gt;$out&lt;/code&gt; 통해 반환 됩니다 . &lt;code&gt;$status&lt;/code&gt; 는 성공하면 &lt;code&gt;Z_OK&lt;/code&gt; 값을 갖 습니다.</target>
        </trans-unit>
        <trans-unit id="01a46f6fee05faa753caaabc6b43de594c708bd4" translate="yes" xml:space="preserve">
          <source>Typically used to finish the deflation. Any pending output will be written to &lt;code&gt;$output&lt;/code&gt; .</source>
          <target state="translated">일반적으로 수축을 완료하는 데 사용됩니다. 보류중인 출력은 &lt;code&gt;$output&lt;/code&gt; 기록됩니다 .</target>
        </trans-unit>
        <trans-unit id="61eb0abe390afe612ea12baca62c7c474255a6b3" translate="yes" xml:space="preserve">
          <source>Typically used to finish the deflation. Any pending output will be written to &lt;code&gt;$output&lt;/code&gt;.</source>
          <target state="translated">일반적으로 디플레이션을 완료하는 데 사용됩니다. 보류중인 출력은 &lt;code&gt;$output&lt;/code&gt; 기록됩니다 .</target>
        </trans-unit>
        <trans-unit id="6622b7497b5ad854ceef3d9e6b7f39de4b5a746f" translate="yes" xml:space="preserve">
          <source>Typically will call &lt;code&gt;Fill&lt;/code&gt; and manipulate pointers (possibly via the API). &lt;code&gt;PerlIOBuf_read()&lt;/code&gt; may be suitable for derived classes which provide &quot;fast gets&quot; methods.</source>
          <target state="translated">일반적으로 &lt;code&gt;Fill&lt;/code&gt; 을 호출 하고 포인터를 조작합니다 (API를 통해 가능). &lt;code&gt;PerlIOBuf_read()&lt;/code&gt; 는 &quot;fast gets&quot;메소드를 제공하는 파생 클래스에 적합 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="eb1290094db39111daed12026731de41d874265c" translate="yes" xml:space="preserve">
          <source>Typically you only need to set this if you are using nonstandard prefixes and want some or all of them to have the same semantics as '--' does under normal circumstances.</source>
          <target state="translated">일반적으로 비표준 접두사를 사용하고 일부 또는 모든 접두사가 정상적인 상황에서 '-'와 동일한 의미를 갖기를 원할 경우에만 설정하면됩니다.</target>
        </trans-unit>
        <trans-unit id="bbb5689bb894bcd45bb2427b7ffbb2ba5d9ac28a" translate="yes" xml:space="preserve">
          <source>Typically you use the &lt;code&gt;\G&lt;/code&gt; anchor with the &lt;code&gt;c&lt;/code&gt; flag when you want to try a different match if one fails, such as in a tokenizer. Jeffrey Friedl offers this example which works in 5.004 or later.</source>
          <target state="translated">일반적으로 토크 나이저와 같이 다른 일치 항목이 실패하면 &lt;code&gt;\G&lt;/code&gt; 앵커를 &lt;code&gt;c&lt;/code&gt; 플래그 와 함께 사용합니다 . Jeffrey Friedl은 5.004 이상에서 작동하는이 예제를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="e42958c3877ca65db1e97bfa470cdaaff1d1e60d" translate="yes" xml:space="preserve">
          <source>Typically you use the &lt;code&gt;\G&lt;/code&gt; anchor with the &lt;code&gt;c&lt;/code&gt; modifier when you want to try a different match if one fails, such as in a tokenizer. Jeffrey Friedl offers this example which works in 5.004 or later.</source>
          <target state="translated">일반적으로 토크 나이저에서와 같이 실패한 경우 다른 일치를 시도하려는 경우 &lt;code&gt;c&lt;/code&gt; 수정 자 와 함께 &lt;code&gt;\G&lt;/code&gt; 앵커 를 사용합니다 . Jeffrey Friedl은 5.004 이상에서 작동하는이 예제를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="4d250975c35bc29bcb347189b99facfa0b3287b6" translate="yes" xml:space="preserve">
          <source>Typically you'll want to change how TAP gets</source>
          <target state="translated">일반적으로 TAP가 가져 오는 방식을 변경하고 싶을 것입니다.</target>
        </trans-unit>
        <trans-unit id="291f2d298dd4e6053c773023592956eee5655566" translate="yes" xml:space="preserve">
          <source>Typically, Perl tests are run through this. However, anything which spits out TAP is fine. You can use this argument to specify the name of the program (and optional switches) to run your tests with:</source>
          <target state="translated">일반적으로 Perl 테스트는이를 통해 실행됩니다. 그러나 TAP를 뱉어내는 것은 괜찮습니다. 이 인수를 사용하여 다음과 같이 테스트를 실행할 프로그램 이름 (및 선택적 스위치)을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b62868c79b9e92764b29688b63eb397e1c587dcb" translate="yes" xml:space="preserve">
          <source>Typically, a &lt;code&gt;package&lt;/code&gt; statement is the first declaration in a file included in a program by one of the &lt;code&gt;do&lt;/code&gt;, &lt;code&gt;require&lt;/code&gt;, or &lt;code&gt;use&lt;/code&gt; operators. You can switch into a package in more than one place: &lt;code&gt;package&lt;/code&gt; has no effect beyond specifying which symbol table the compiler will use for dynamic symbols for the rest of that block or until the next &lt;code&gt;package&lt;/code&gt; statement. You can refer to variables and filehandles in other packages by prefixing the identifier with the package name and a double colon: &lt;code&gt;$Package::Variable&lt;/code&gt;. If the package name is null, the &lt;code&gt;main&lt;/code&gt; package is assumed. That is, &lt;code&gt;$::sail&lt;/code&gt; is equivalent to &lt;code&gt;$main::sail&lt;/code&gt;.</source>
          <target state="translated">일반적으로 &lt;code&gt;package&lt;/code&gt; 문은 &lt;code&gt;do&lt;/code&gt; , &lt;code&gt;require&lt;/code&gt; 또는 &lt;code&gt;use&lt;/code&gt; 연산자 중 하나에 의해 프로그램에 포함 된 파일의 첫 번째 선언입니다 . 둘 이상의 위치에서 패키지로 전환 할 수 있습니다. &lt;code&gt;package&lt;/code&gt; 는 컴파일러가 해당 블록의 나머지 부분에 대해 또는 다음 &lt;code&gt;package&lt;/code&gt; 문 까지 동적 기호에 사용할 기호 테이블을 지정하는 것 외에는 영향을주지 않습니다 . 식별자 앞에 패키지 이름과 이중 콜론을 추가하여 다른 패키지의 변수 및 파일 핸들을 참조 할 수 있습니다. &lt;code&gt;$Package::Variable&lt;/code&gt; . 패키지 이름이 null이면 &lt;code&gt;main&lt;/code&gt; 패키지로 간주됩니다. 즉, &lt;code&gt;$::sail&lt;/code&gt; 은 &lt;code&gt;$main::sail&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bc1a3db1817e4391406ea8e4c10b938d812a2baf" translate="yes" xml:space="preserve">
          <source>Typically, a C compiler allocates 12 bytes to a &lt;code&gt;gappy_t&lt;/code&gt; variable, but requires only 8 bytes for a &lt;code&gt;dense_t&lt;/code&gt; . After investigating this further, we can draw memory maps, showing where the extra 4 bytes are hidden:</source>
          <target state="translated">일반적으로, C 컴파일러는 12 바이트를 할당 &lt;code&gt;gappy_t&lt;/code&gt; 의 가변이지만에만 8 바이트 요구 &lt;code&gt;dense_t&lt;/code&gt; 를 . 이것을 더 조사한 후, 여분의 4 바이트가 숨겨지는 곳을 보여주는 메모리 맵을 그릴 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="842e52cd2265b412e8f4aaf0dec34c2c2fc7c9ed" translate="yes" xml:space="preserve">
          <source>Typically, a C compiler allocates 12 bytes to a &lt;code&gt;gappy_t&lt;/code&gt; variable, but requires only 8 bytes for a &lt;code&gt;dense_t&lt;/code&gt;. After investigating this further, we can draw memory maps, showing where the extra 4 bytes are hidden:</source>
          <target state="translated">일반적으로, C 컴파일러는 12 바이트를 할당 &lt;code&gt;gappy_t&lt;/code&gt; 의 가변이지만에만 8 바이트 요구 &lt;code&gt;dense_t&lt;/code&gt; 를 . 이를 자세히 조사한 후 추가 4 바이트가 숨겨져있는 위치를 보여주는 메모리 맵을 그릴 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="83c91d2712bb90187ca081aa74ad37d202d5e800" translate="yes" xml:space="preserve">
          <source>Typically, however, things are the other way around: the tieable class expects its arguments as a flattened list, so the attribute looks like:</source>
          <target state="translated">그러나 일반적으로 다른 방법은 다음과 같습니다. 연결 가능한 클래스는 인수를 병합 된 목록으로 예상하므로 속성은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f8985e43d2d106574f328b34641196cf266af572" translate="yes" xml:space="preserve">
          <source>Typically, the</source>
          <target state="translated">일반적으로</target>
        </trans-unit>
        <trans-unit id="a2dcf9e9fce909e6d70f7fd2b928940489e6fad5" translate="yes" xml:space="preserve">
          <source>Typing &quot;buildtype d off&quot; or &quot;buildtype d&quot; at the command prompt causes the buildtype to be set to Debug type with D1 flag set.</source>
          <target state="translated">명령 프롬프트에서 &quot;buildtype d off&quot;또는 &quot;buildtype d&quot;를 입력하면 D1 플래그가 설정된 상태에서 빌드 유형이 디버그 유형으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="b2c7510e598f94047792f2e34322c55a1d654ee0" translate="yes" xml:space="preserve">
          <source>Typing &quot;buildtype d on&quot; at the command prompt causes the buildtype to be set to Debug type with D2 flag set.</source>
          <target state="translated">명령 프롬프트에서 &quot;buildtype d on&quot;을 입력하면 빌드 유형이 D2 플래그가 설정된 디버그 유형으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="6127511edf886df0417540a81474ffb3800e60b7" translate="yes" xml:space="preserve">
          <source>Typing &quot;buildtype r&quot; at the command prompt sets it to Release Build type.</source>
          <target state="translated">명령 프롬프트에서 &quot;buildtype r&quot;을 입력하면 Release Build type으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="b2c7c0caa10a0cca5ea7d69e54018ae0c0389dd6" translate="yes" xml:space="preserve">
          <source>U</source>
          <target state="translated">U</target>
        </trans-unit>
        <trans-unit id="70ae2f8ea36eac22765cdf44837146969d083d4c" translate="yes" xml:space="preserve">
          <source>U/WIN specific subclass of ExtUtils::MM_Unix</source>
          <target state="translated">ExtUtils :: MM_Unix의 U / WIN 특정 서브 클래스</target>
        </trans-unit>
        <trans-unit id="e87e721b92dfc3ce5a42bdc5529d628275269297" translate="yes" xml:space="preserve">
          <source>UAX #11: East Asian Width</source>
          <target state="translated">UAX # 11 : 동아시아 너비</target>
        </trans-unit>
        <trans-unit id="54e111693f7553557203eea396555ad20db941bc" translate="yes" xml:space="preserve">
          <source>UAX #14: Unicode Line Breaking Algorithm</source>
          <target state="translated">UAX # 14 : 유니 코드 줄 바꿈 알고리즘</target>
        </trans-unit>
        <trans-unit id="f62b71447bb2670ca75d2c60404b5335b86f48a9" translate="yes" xml:space="preserve">
          <source>UAX #15: Unicode Normalization Forms</source>
          <target state="translated">UAX # 15 : 유니 코드 정규화 양식</target>
        </trans-unit>
        <trans-unit id="57fbcb66826627051473f0031e536eaa29808986" translate="yes" xml:space="preserve">
          <source>UAX #29: Unicode Text Segmentation</source>
          <target state="translated">UAX # 29 : 유니 코드 텍스트 분할</target>
        </trans-unit>
        <trans-unit id="04846c59e74a6b4b2e534cd9cb9a90b44ec543b2" translate="yes" xml:space="preserve">
          <source>UAX #44: Unicode Character Database</source>
          <target state="translated">UAX # 44 : 유니 코드 문자 데이터베이스</target>
        </trans-unit>
        <trans-unit id="591e272980f29149d094e061515f3a24c2416346" translate="yes" xml:space="preserve">
          <source>UC</source>
          <target state="translated">UC</target>
        </trans-unit>
        <trans-unit id="3a333ea8bebfa50b73219f11f7bf0ebbb8c9a863" translate="yes" xml:space="preserve">
          <source>UCA recommends that out-of-range values should not be ignored for security reasons. Say, &lt;code&gt;&quot;pe\x{110000}rl&quot;&lt;/code&gt; should not be equal to &lt;code&gt;&quot;perl&quot;&lt;/code&gt; . However, &lt;code&gt;U+FFFD&lt;/code&gt; is wrongly mapped to a variable collation element in DUCET for Unicode 6.0.0 to 6.2.0, that means out-of-range values will be ignored when &lt;code&gt;variable&lt;/code&gt; isn't &lt;code&gt;Non-ignorable&lt;/code&gt; .</source>
          <target state="translated">UCA는 범위를 벗어난 값은 보안상의 이유로 무시하지 말 것을 권장합니다. 말, &lt;code&gt;&quot;pe\x{110000}rl&quot;&lt;/code&gt; 동일 안된다 &lt;code&gt;&quot;perl&quot;&lt;/code&gt; . 그러나 &lt;code&gt;U+FFFD&lt;/code&gt; 는 유니 코드 6.0.0 ~ 6.2.0 용 DUCET의 변수 데이터 정렬 요소에 잘못 맵핑됩니다. 즉, &lt;code&gt;variable&lt;/code&gt; 가 &lt;code&gt;Non-ignorable&lt;/code&gt; 없는 경우 범위를 벗어난 값은 무시됩니다 .</target>
        </trans-unit>
        <trans-unit id="492c906fc3f312af6ae908d9ffaf994fd07f46cc" translate="yes" xml:space="preserve">
          <source>UCA recommends that out-of-range values should not be ignored for security reasons. Say, &lt;code&gt;&quot;pe\x{110000}rl&quot;&lt;/code&gt; should not be equal to &lt;code&gt;&quot;perl&quot;&lt;/code&gt;. However, &lt;code&gt;U+FFFD&lt;/code&gt; is wrongly mapped to a variable collation element in DUCET for Unicode 6.0.0 to 6.2.0, that means out-of-range values will be ignored when &lt;code&gt;variable&lt;/code&gt; isn't &lt;code&gt;Non-ignorable&lt;/code&gt;.</source>
          <target state="translated">UCA는 보안상의 이유로 범위를 벗어난 값을 무시하지 않도록 권장합니다. 말, &lt;code&gt;&quot;pe\x{110000}rl&quot;&lt;/code&gt; 동일 안된다 &lt;code&gt;&quot;perl&quot;&lt;/code&gt; . 그러나 &lt;code&gt;U+FFFD&lt;/code&gt; 는 유니 코드 6.0.0에서 6.2.0까지 DUCET의 변수 데이터 정렬 요소에 잘못 매핑되어 &lt;code&gt;variable&lt;/code&gt; 가 &lt;code&gt;Non-ignorable&lt;/code&gt; 이 아닌 경우 범위를 벗어난 값이 무시됩니다 .</target>
        </trans-unit>
        <trans-unit id="46cc4029c87ef2347d0792acb85d7dbc180043ff" translate="yes" xml:space="preserve">
          <source>UCA_Version</source>
          <target state="translated">UCA_Version</target>
        </trans-unit>
        <trans-unit id="e80de0851d29f92f6e9e34856bbc13a9b674c12b" translate="yes" xml:space="preserve">
          <source>UCS</source>
          <target state="translated">UCS</target>
        </trans-unit>
        <trans-unit id="c3ba710b4e9b506e4750f6e24e9eeec383e609b3" translate="yes" xml:space="preserve">
          <source>UCS-2</source>
          <target state="translated">UCS-2</target>
        </trans-unit>
        <trans-unit id="206177d23e4d5ec0abfb5c6b0df396d679742e7c" translate="yes" xml:space="preserve">
          <source>UCS-2 is a fixed-length encoding with each character taking 16 bits. It &lt;b&gt;does not&lt;/b&gt; support</source>
          <target state="translated">UCS-2는 각 문자가 16 비트를 사용하는 고정 길이 인코딩입니다. 그것은 &lt;b&gt;하지 않습니다&lt;/b&gt; 지원</target>
        </trans-unit>
        <trans-unit id="daeba9311089266fcf0acd6d54c9e56ca13a992e" translate="yes" xml:space="preserve">
          <source>UCS-2, UCS-4</source>
          <target state="translated">UCS-2, UCS-4</target>
        </trans-unit>
        <trans-unit id="e9a6f622e340090feb219eb5c94b0df756e8e486" translate="yes" xml:space="preserve">
          <source>UDP</source>
          <target state="translated">UDP</target>
        </trans-unit>
        <trans-unit id="a392dc8e430c846ca90f8e40c79fda571eef8daf" translate="yes" xml:space="preserve">
          <source>UDP datagrams are</source>
          <target state="translated">UDP 데이터 그램은</target>
        </trans-unit>
        <trans-unit id="0b1ddbe7e9085079ee7967600cb1889fd0b548d1" translate="yes" xml:space="preserve">
          <source>UDP: Message Passing</source>
          <target state="translated">UDP : 메시지 전달</target>
        </trans-unit>
        <trans-unit id="d946adf52a4783929f122d341b29ac0fe188371c" translate="yes" xml:space="preserve">
          <source>UID</source>
          <target state="translated">UID</target>
        </trans-unit>
        <trans-unit id="6baa0c91c35738e244018a78ee06f9f0b5e589ea" translate="yes" xml:space="preserve">
          <source>UNDEF</source>
          <target state="translated">UNDEF</target>
        </trans-unit>
        <trans-unit id="bbb2722df9c1be9f9216f08d7da234a2e705e9d4" translate="yes" xml:space="preserve">
          <source>UNDERBAR</source>
          <target state="translated">UNDERBAR</target>
        </trans-unit>
        <trans-unit id="74ff590c1dac1161eec0fbaa8b7d8b3a98fff4d5" translate="yes" xml:space="preserve">
          <source>UNICODE AND SIDE EFFECTS</source>
          <target state="translated">유니 코드 및 부작용</target>
        </trans-unit>
        <trans-unit id="0f9d971f52bdd7a74ebeb786ec5143de4c2935d5" translate="yes" xml:space="preserve">
          <source>UNICODE IN OLDER PERLS</source>
          <target state="translated">오래된 PERLS의 유니 코드</target>
        </trans-unit>
        <trans-unit id="3d51f9ce7ad6a8a131760c17f51427e8bbfb85b1" translate="yes" xml:space="preserve">
          <source>UNICODE_REPLACEMENT</source>
          <target state="translated">UNICODE_REPLACEMENT</target>
        </trans-unit>
        <trans-unit id="94c5e5979031dbec3b6f240558b2bfaa36f46791" translate="yes" xml:space="preserve">
          <source>UNIMPLEMENTED</source>
          <target state="translated">UNIMPLEMENTED</target>
        </trans-unit>
        <trans-unit id="9392ee60535a3aa7bb3335f263044b78e27554ed" translate="yes" xml:space="preserve">
          <source>UNISTD</source>
          <target state="translated">UNISTD</target>
        </trans-unit>
        <trans-unit id="c070755890afd262edf57a1cfae99ffc017d2459" translate="yes" xml:space="preserve">
          <source>UNITCHECK</source>
          <target state="translated">UNITCHECK</target>
        </trans-unit>
        <trans-unit id="bc192a928ab3fe78a1c74cfa4d1027b44d52c868" translate="yes" xml:space="preserve">
          <source>UNIVERSAL</source>
          <target state="translated">UNIVERSAL</target>
        </trans-unit>
        <trans-unit id="1feda7e9d1b1a232e025eeb903dd53659f7b069c" translate="yes" xml:space="preserve">
          <source>UNIVERSAL - base class for ALL classes (blessed references)</source>
          <target state="translated">UNIVERSAL-모든 클래스의 기본 클래스 (축복 참조)</target>
        </trans-unit>
        <trans-unit id="b23387c60700d885c584c4f2b25855ad58b48b48" translate="yes" xml:space="preserve">
          <source>UNIX and POSIX systems provide an abstract access() operating system call, which should be used to query the read, write, and execute rights. This function hides various distinct approaches in additional operating system specific security features, like Access Control Lists (ACLs)</source>
          <target state="translated">UNIX 및 POSIX 시스템은 읽기, 쓰기 및 실행 권한을 쿼리하는 데 사용해야하는 추상 access () 운영 체제 호출을 제공합니다. 이 기능은 액세스 제어 목록 (ACL)과 같은 추가 운영 체제 별 보안 기능에서 다양한 접근 방식을 숨 깁니다.</target>
        </trans-unit>
        <trans-unit id="fa0c8b9587852cbf0dc08f98bcecbaed53f1e1c0" translate="yes" xml:space="preserve">
          <source>UNIX domain sockets added by Sean Robinson &amp;lt;</source>
          <target state="translated">Sean Robinson이 추가 한 UNIX 도메인 소켓 &amp;lt;</target>
        </trans-unit>
        <trans-unit id="85db2499d39f4696e02fb26511b230add2c1b670" translate="yes" xml:space="preserve">
          <source>UNIX file permissions are based on sets of mode bits for {read,write,execute} for each {user,group,other}. By default Cygwin only tracks the Win32 read-only attribute represented as the UNIX file user write bit (files are always readable, files are executable if they have a</source>
          <target state="translated">UNIX 파일 권한은 각 {user, group, other}에 대한 {read, write, execute}에 대한 모드 비트 세트를 기반으로합니다. 기본적으로 Cygwin은 UNIX 파일 사용자 쓰기 비트로 표시되는 Win32 읽기 전용 속성 만 추적합니다 (파일은 항상 읽을 수 있고 파일은</target>
        </trans-unit>
        <trans-unit id="1db53023f517a9c3a97970b2e62a29042045d3f0" translate="yes" xml:space="preserve">
          <source>UNI_TO_NATIVE</source>
          <target state="translated">UNI_TO_NATIVE</target>
        </trans-unit>
        <trans-unit id="36361e169f0479184326d85ebb47825bf51a5753" translate="yes" xml:space="preserve">
          <source>UNLIKELY</source>
          <target state="translated">UNLIKELY</target>
        </trans-unit>
        <trans-unit id="5c24b56d363871364a8198c1e16261b34c9bf761" translate="yes" xml:space="preserve">
          <source>UNLINK flag available since 0.10.</source>
          <target state="translated">0.10부터 UNLINK 플래그를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="265e8c38a269eb32604a5d0ed5924378784ee057" translate="yes" xml:space="preserve">
          <source>UNSHIFT this, LIST</source>
          <target state="translated">UNSHIFT this, LIST</target>
        </trans-unit>
        <trans-unit id="5b8f1af6e17a29d4f20f56ec6d442f59acfc755d" translate="yes" xml:space="preserve">
          <source>UNSUPPORTED</source>
          <target state="translated">UNSUPPORTED</target>
        </trans-unit>
        <trans-unit id="40cccdd49a4b2f7980664d02999aa7b9e3022b50" translate="yes" xml:space="preserve">
          <source>UNTIE by Nick Ing-Simmons &amp;lt;</source>
          <target state="translated">닉 잉 시몬스의 UNTIE &amp;lt;</target>
        </trans-unit>
        <trans-unit id="41304503568dff57766f35c33ebaca45f5e827b2" translate="yes" xml:space="preserve">
          <source>UNTIE this</source>
          <target state="translated">이것을 풀다</target>
        </trans-unit>
        <trans-unit id="ea518a7caeec27fa571544a1959010e8689298ab" translate="yes" xml:space="preserve">
          <source>UPGRADE SUGGESTED</source>
          <target state="translated">업그레이드 제안</target>
        </trans-unit>
        <trans-unit id="e3bb3273c3d27a35e7a79c09d285ae651319171c" translate="yes" xml:space="preserve">
          <source>UPGRADING</source>
          <target state="translated">UPGRADING</target>
        </trans-unit>
        <trans-unit id="a6b6b187a5dabe1711e09378ba034929cf5397f3" translate="yes" xml:space="preserve">
          <source>UPSTREAM indicates where patches should go. &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; implies that this hasn't been discussed for the module at hand. &lt;code&gt;blead&lt;/code&gt; indicates that the copy of the module in the blead sources is to be considered canonical, &lt;code&gt;cpan&lt;/code&gt; means that the module on CPAN is to be patched first. &lt;code&gt;first-come&lt;/code&gt; means that blead can be patched freely if it is in sync with the latest release on CPAN.</source>
          <target state="translated">UPSTREAM은 패치의 위치를 ​​나타냅니다. &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 는 현재 모듈에 대해서는 논의되지 않았 음을 의미합니다. &lt;code&gt;blead&lt;/code&gt; 는 블리드 소스의 모듈 사본이 정식으로 간주됨을 나타내며 &lt;code&gt;cpan&lt;/code&gt; 은 CPAN의 모듈을 먼저 패치해야 함을 의미합니다. &lt;code&gt;first-come&lt;/code&gt; 은 블리드가 CPAN의 최신 릴리스와 동기화 된 경우 자유롭게 패치 할 수 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="1b193f75bbf58b38858154a6e283a021406e55fd" translate="yes" xml:space="preserve">
          <source>UPSTREAM indicates where patches should go. &lt;code&gt;undef&lt;/code&gt; implies that this hasn't been discussed for the module at hand. &lt;code&gt;blead&lt;/code&gt; indicates that the copy of the module in the blead sources is to be considered canonical, &lt;code&gt;cpan&lt;/code&gt; means that the module on CPAN is to be patched first. &lt;code&gt;first-come&lt;/code&gt; means that blead can be patched freely if it is in sync with the latest release on CPAN.</source>
          <target state="translated">UPSTREAM은 패치가 이동해야하는 위치를 나타냅니다. &lt;code&gt;undef&lt;/code&gt; 는 이것이 당면한 모듈에 대해 논의되지 않았 음을 의미합니다. &lt;code&gt;blead&lt;/code&gt; 는 blead 소스의 모듈 사본이 표준으로 간주 됨을 나타내고 &lt;code&gt;cpan&lt;/code&gt; 은 CPAN의 모듈이 먼저 패치됨을 의미합니다. &lt;code&gt;first-come&lt;/code&gt; 이란 CPAN의 최신 릴리스와 동기화되면 blead를 자유롭게 패치 할 수 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="0e2d9b0777a485c1276de0803c12a7d76fbc5c39" translate="yes" xml:space="preserve">
          <source>URL</source>
          <target state="translated">URL</target>
        </trans-unit>
        <trans-unit id="ba5e5280eb88749f4ed2bd7802c151c1f77cb3d7" translate="yes" xml:space="preserve">
          <source>URL decoding and encoding</source>
          <target state="translated">URL 디코딩 및 인코딩</target>
        </trans-unit>
        <trans-unit id="a2c8158547717be782e140b2ad8b3a2b5e515fe5" translate="yes" xml:space="preserve">
          <source>URL for further information</source>
          <target state="translated">추가 정보를위한 URL</target>
        </trans-unit>
        <trans-unit id="61aff325c59f0125c7432101521fe8aef2d620f8" translate="yes" xml:space="preserve">
          <source>URLS</source>
          <target state="translated">URLS</target>
        </trans-unit>
        <trans-unit id="cf3bfa9a159c5a5ddc20da1eccd6bbddbdc037e4" translate="yes" xml:space="preserve">
          <source>USAGE</source>
          <target state="translated">USAGE</target>
        </trans-unit>
        <trans-unit id="11db5afeaceeb6d5fec1a6025012faccc762da50" translate="yes" xml:space="preserve">
          <source>USAGE DETAILS</source>
          <target state="translated">사용법 세부 사항</target>
        </trans-unit>
        <trans-unit id="3ca88d77aca2d323542d2e8f12b83151e0846c19" translate="yes" xml:space="preserve">
          <source>USE EXAMPLES</source>
          <target state="translated">사용 예</target>
        </trans-unit>
        <trans-unit id="48c336c391ccd32eaf0812999ba74a1243f916d3" translate="yes" xml:space="preserve">
          <source>USE Test2::Suite INSTEAD</source>
          <target state="translated">Test2 :: Suite INSTEAD 사용</target>
        </trans-unit>
        <trans-unit id="ce94de210299952d4167e1951445b8720839ce7f" translate="yes" xml:space="preserve">
          <source>USEFUL</source>
          <target state="translated">USEFUL</target>
        </trans-unit>
        <trans-unit id="6eb0c61201a96afc99cbf180f1c8d93c0a9fd8c8" translate="yes" xml:space="preserve">
          <source>USER</source>
          <target state="translated">USER</target>
        </trans-unit>
        <trans-unit id="045095377d72052bacadc70846f65ba919bc72ee" translate="yes" xml:space="preserve">
          <source>USER METHODS</source>
          <target state="translated">사용자 방법</target>
        </trans-unit>
        <trans-unit id="eff0e1414e1813c02157d57d3f325f32947a8413" translate="yes" xml:space="preserve">
          <source>USE_MULTI &amp;amp; USE_IMP_SYS defined and USE_ITHREADS not defined</source>
          <target state="translated">USE_MULTI &amp;amp; USE_IMP_SYS 정의 및 USE_ITHREADS 정의되지 않음</target>
        </trans-unit>
        <trans-unit id="5e29b7b3b7536de15b46013805cfeb875c7a61d3" translate="yes" xml:space="preserve">
          <source>USE_MULTI, USE_ITHREADS &amp;amp; USE_IMP_SYS defined</source>
          <target state="translated">USE_MULTI, USE_ITHREADS 및 USE_IMP_SYS 정의</target>
        </trans-unit>
        <trans-unit id="227996d58fdfdee97220bd395f44c03336330289" translate="yes" xml:space="preserve">
          <source>USE_PERL_FLOCK</source>
          <target state="translated">USE_PERL_FLOCK</target>
        </trans-unit>
        <trans-unit id="f8104e09349c8c6000afb7fc05a4ed027d50f4e3" translate="yes" xml:space="preserve">
          <source>USE_THREADS</source>
          <target state="translated">USE_THREADS</target>
        </trans-unit>
        <trans-unit id="eeb0c37772a1b806f230c8036c163dab104d01af" translate="yes" xml:space="preserve">
          <source>USING A CONTEXT</source>
          <target state="translated">컨텍스트 사용</target>
        </trans-unit>
        <trans-unit id="d403f19c30d9dafcf5b6a7bb8666159dacf7697f" translate="yes" xml:space="preserve">
          <source>USING B::Deparse AS A MODULE</source>
          <target state="translated">B :: 모듈로 사용</target>
        </trans-unit>
        <trans-unit id="2efa10816450d527d9e56d3271b7e34ea8c81a61" translate="yes" xml:space="preserve">
          <source>USING CONTEXT: THE DEBUG FILTER</source>
          <target state="translated">컨텍스트 사용하기 : 디버그 필터</target>
        </trans-unit>
        <trans-unit id="5dc41a076ce2820059919cbbf35a7c867770cef6" translate="yes" xml:space="preserve">
          <source>USING FILTERS</source>
          <target state="translated">필터 사용</target>
        </trans-unit>
        <trans-unit id="3d73074a3cddd39278e855bf130287734b3a28e3" translate="yes" xml:space="preserve">
          <source>USING LOCALES</source>
          <target state="translated">로캘 사용</target>
        </trans-unit>
        <trans-unit id="e914e6326e1588417f534e760a668a311b7406cd" translate="yes" xml:space="preserve">
          <source>USING PERL IN OPENVOS</source>
          <target state="translated">OPENVOS에서 PERL 사용</target>
        </trans-unit>
        <trans-unit id="99eec133fe1ada053200d233f3eaa4520c2bb5fb" translate="yes" xml:space="preserve">
          <source>USING THE CONSTRUCTOR</source>
          <target state="translated">건설자 사용</target>
        </trans-unit>
        <trans-unit id="ac35aec57e40ba482f8f9fa734ce439013d2f6b2" translate="yes" xml:space="preserve">
          <source>USING THE EXTERNAL GZIP</source>
          <target state="translated">외부 GZIP 사용</target>
        </trans-unit>
        <trans-unit id="ca105f51c68cd465fba8a30858f385516bc30dcf" translate="yes" xml:space="preserve">
          <source>USING UTF8</source>
          <target state="translated">UTF8 사용</target>
        </trans-unit>
        <trans-unit id="6af50db97d3b4d2d4a30cc3bc98a5ffb4cb39ec7" translate="yes" xml:space="preserve">
          <source>USourceData.txt</source>
          <target state="translated">USourceData.txt</target>
        </trans-unit>
        <trans-unit id="d96ff9257bc1dd5af725fa01d1ac6c3c64b3d707" translate="yes" xml:space="preserve">
          <source>USourceGlyphs.pdf</source>
          <target state="translated">USourceGlyphs.pdf</target>
        </trans-unit>
        <trans-unit id="618f65101275eae124d9a7c9c7a5431c588e88d8" translate="yes" xml:space="preserve">
          <source>UTF</source>
          <target state="translated">UTF</target>
        </trans-unit>
        <trans-unit id="6b28c2250a1cbb7c8f56dfcf0dd9e06201c35f2f" translate="yes" xml:space="preserve">
          <source>UTF stands for &quot;Unicode Transformation Format&quot;. UTF-8 is an encoding of Unicode into a sequence of 8-bit byte chunks, based on ASCII and Latin-1. The length of a sequence required to represent a Unicode code point depends on the ordinal number of that code point, with larger numbers requiring more bytes. UTF-EBCDIC is like UTF-8, but based on EBCDIC. They are enough alike that often, casual usage will conflate the two terms, and use &quot;UTF-8&quot; to mean both the UTF-8 found on ASCII platforms, and the UTF-EBCDIC found on EBCDIC ones.</source>
          <target state="translated">UTF는 &quot;유니 코드 변환 형식&quot;을 나타냅니다. UTF-8은 ASCII 및 Latin-1을 기반으로 유니 코드를 8 비트 바이트 청크 시퀀스로 인코딩 한 것입니다. 유니 코드 코드 포인트를 나타내는 데 필요한 시퀀스 길이는 해당 코드 포인트의 서수에 따라 달라지며 더 큰 숫자는 더 많은 바이트를 필요로합니다. UTF-EBCDIC는 UTF-8과 비슷하지만 EBCDIC를 기반으로합니다. 그것들은 종종 일상적인 사용법이 두 용어를 혼동하고 &quot;UTF-8&quot;을 사용하여 ASCII 플랫폼에서 발견되는 UTF-8과 EBCDIC에서 발견되는 UTF-EBCDIC을 모두 의미합니다.</target>
        </trans-unit>
        <trans-unit id="5a9da893be5fd5fae314bea8dcdeeee12beeec4b" translate="yes" xml:space="preserve">
          <source>UTF-16</source>
          <target state="translated">UTF-16</target>
        </trans-unit>
        <trans-unit id="c965e907f9d25c517a8e5bd79aea9417a0714217" translate="yes" xml:space="preserve">
          <source>UTF-16 is almost the same as UCS-2 but it supports</source>
          <target state="translated">UTF-16은 UCS-2와 거의 동일하지만 지원합니다</target>
        </trans-unit>
        <trans-unit id="6368ee0d76a2ca5c3d83c85e127ba1610670e64c" translate="yes" xml:space="preserve">
          <source>UTF-16 surrogate U+%X</source>
          <target state="translated">UTF-16 대리 U + % X</target>
        </trans-unit>
        <trans-unit id="5222e4ab75ba1ce305284f282ec30a73156a366c" translate="yes" xml:space="preserve">
          <source>UTF-16, UTF-16BE, UTF-16LE, Surrogates, and &lt;code&gt;BOM&lt;/code&gt; 's (Byte Order Marks)</source>
          <target state="translated">UTF-16, UTF-16BE, UTF-16LE, 대리 및 &lt;code&gt;BOM&lt;/code&gt; (바이트 순서 표시)</target>
        </trans-unit>
        <trans-unit id="ca51c01ddb04a5d5f4843a1045e4eb7fa59f4fe4" translate="yes" xml:space="preserve">
          <source>UTF-16, UTF-16BE, UTF-16LE, Surrogates, and &lt;code&gt;BOM&lt;/code&gt;'s (Byte Order Marks)</source>
          <target state="translated">UTF-16, UTF-16BE, UTF-16LE, 서로 게이트 및 &lt;code&gt;BOM&lt;/code&gt; (바이트 순서 표시)</target>
        </trans-unit>
        <trans-unit id="47a1ff59a1e826be6636526f502c21d7b7b97ead" translate="yes" xml:space="preserve">
          <source>UTF-32 (UCS-4) is a fixed-length encoding with each character taking 32 bits. Since it is 32-bit, there is no need for</source>
          <target state="translated">UTF-32 (UCS-4)는 각 문자가 32 비트를 사용하는 고정 길이 인코딩입니다. 32 비트이므로</target>
        </trans-unit>
        <trans-unit id="dfd8dce020ef601007001e4289b99a7908444d8a" translate="yes" xml:space="preserve">
          <source>UTF-32, UTF-32BE, UTF-32LE</source>
          <target state="translated">UTF-32, UTF-32BE, UTF-32LE</target>
        </trans-unit>
        <trans-unit id="20e199acc434517cd4a6e5977a48bae6e5af47a4" translate="yes" xml:space="preserve">
          <source>UTF-7</source>
          <target state="translated">UTF-7</target>
        </trans-unit>
        <trans-unit id="4d56cb8e2ad2a50613de9fa7d9d9a0d239c1aca9" translate="yes" xml:space="preserve">
          <source>UTF-7 encoding</source>
          <target state="translated">UTF-7 인코딩</target>
        </trans-unit>
        <trans-unit id="c69eadbe302e95901c2e20dc0780e1b33ffbf733" translate="yes" xml:space="preserve">
          <source>UTF-7 is a special encoding which &quot;re-encodes&quot; UTF-16BE into a 7-bit encoding. It is implemented separately by Encode::Unicode::UTF7.</source>
          <target state="translated">UTF-7은 UTF-16BE를 7 비트 인코딩으로 &quot;다시 인코딩&quot;하는 특수 인코딩입니다. Encode :: Unicode :: UTF7에 의해 별도로 구현됩니다.</target>
        </trans-unit>
        <trans-unit id="ba8308c0cebaf2cef9e02fb7f26e6c4f56ba6ce0" translate="yes" xml:space="preserve">
          <source>UTF-7 was not supported by Encode until version 1.95 because of that. But Unicode::String, a module by Gisle Aas which adds Unicode supports to non-utf8-savvy perl did support UTF-7, the UTF-7 support was added so Encode can supersede Unicode::String 100%.</source>
          <target state="translated">UTF-1은 버전 1.95까지 Encode에서 지원하지 않았습니다. 그러나 Gisle Aas의 모듈 인 UTF : UTF8이 아닌 perl에 유니 코드 지원을 추가하는 모듈 인 Unicode : : String은 UTF-7을 지원했으며 UTF-7 지원이 추가되어 Encode는 Unicode : : String 100 %를 대체 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="663b90c899fa25a111067be0c22ffc64dcf581c2" translate="yes" xml:space="preserve">
          <source>UTF-8</source>
          <target state="translated">UTF-8</target>
        </trans-unit>
        <trans-unit id="e2635de14b396bd81c2a4f587434aea9cfbf99fc" translate="yes" xml:space="preserve">
          <source>UTF-8 and UTF-EBCDIC are two different encodings used to represent Unicode code points as sequences of bytes. Macros with the same names (but different definitions) in</source>
          <target state="translated">UTF-8 및 UTF-EBCDIC는 유니 코드 코드 포인트를 바이트 시퀀스로 나타내는 데 사용되는 두 가지 다른 인코딩입니다. 이름이 같지만 정의가 다른 매크로</target>
        </trans-unit>
        <trans-unit id="8b4fe83acd749a66b827e068556fa7943eee22bb" translate="yes" xml:space="preserve">
          <source>UTF-8 and Unicode FAQ for Unix/Linux</source>
          <target state="translated">Unix / Linux에 대한 UTF-8 및 유니 코드 FAQ</target>
        </trans-unit>
        <trans-unit id="79cdcb7150e1254a38f057938e6f4012fc46b08a" translate="yes" xml:space="preserve">
          <source>UTF-8 is a variable-length (1 to 4 bytes), byte-order independent encoding. In most of Perl's documentation, including elsewhere in this document, the term &quot;UTF-8&quot; means also &quot;UTF-EBCDIC&quot;. But in this section, &quot;UTF-8&quot; refers only to the encoding used on ASCII platforms. It is a superset of 7-bit US-ASCII, so anything encoded in ASCII has the identical representation when encoded in UTF-8.</source>
          <target state="translated">UTF-8은 가변 길이 (1-4 바이트), 바이트 순서 독립적 인코딩입니다. 이 문서의 다른 부분을 포함하여 대부분의 Perl 설명서에서 &quot;UTF-8&quot;이라는 용어는 &quot;UTF-EBCDIC&quot;도 의미합니다. 그러나이 섹션에서 &quot;UTF-8&quot;은 ASCII 플랫폼에서 사용되는 인코딩 만 나타냅니다. 7 비트 US-ASCII의 상위 세트이므로 ASCII로 인코딩 된 것은 UTF-8로 인코딩 될 때 동일한 표현을 갖습니다.</target>
        </trans-unit>
        <trans-unit id="2d6c49b0c5ea97423fbd4064bf9d6fbd9eeb0509" translate="yes" xml:space="preserve">
          <source>UTF-8 is very structured, so many combinations of bytes are invalid. In the past, Perl tried to soldier on and make some sense of invalid combinations, but this can lead to security holes, so now, if the Perl core needs to process an invalid combination, it will either raise a fatal error, or will replace those bytes by the sequence that forms the Unicode REPLACEMENT CHARACTER, for which purpose Unicode created it.</source>
          <target state="translated">UTF-8은 매우 구조적이므로 많은 바이트 조합이 유효하지 않습니다. 과거에 Perl은 잘못된 조합을 이해하려고 노력했지만 보안 허점으로 이어질 수 있으므로 Perl 코어가 잘못된 조합을 처리해야하는 경우 치명적인 오류가 발생하거나 대체됩니다. 유니 코드 REPLACEMENT CHARACTER를 형성하는 시퀀스에 의해 해당 바이트는 유니 코드가 생성 한 용도로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="64b07e44d3986db9cf7499225144a4d1d394db97" translate="yes" xml:space="preserve">
          <source>UTF-8 treats the first 128 codepoints, 0..127, the same as ASCII. They take only one byte per character. All other characters are encoded as two to four bytes using a complex scheme. Fortunately, Perl handles this for us, so we don't have to worry about this.</source>
          <target state="translated">UTF-8은 처음 128 개의 코드 포인트 인 0..127을 ASCII와 동일하게 취급합니다. 문자 당 1 바이트 만 사용합니다. 다른 모든 문자는 복잡한 체계를 사용하여 2-4 바이트로 인코딩됩니다. 다행스럽게도 Perl이이를 처리하므로 걱정할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="7443ec4bd05d2044739a43a92206bcfe32f068b2" translate="yes" xml:space="preserve">
          <source>UTF-8 vs. utf8 vs. UTF8</source>
          <target state="translated">UTF-8 대 utf8 대 UTF8</target>
        </trans-unit>
        <trans-unit id="21357a91ac9a6238516304ecf3d0973befa29dc1" translate="yes" xml:space="preserve">
          <source>UTF-EBCDIC</source>
          <target state="translated">UTF-EBCDIC</target>
        </trans-unit>
        <trans-unit id="54206a5f5bcbb8b5ddd3ceb665085cec48ec6be8" translate="yes" xml:space="preserve">
          <source>UTF-EBCDIC is defined by &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fwww.unicode.org%2freports%2ftr16&quot;&gt;Unicode Technical Report #16&lt;/a&gt;. It is defined based on CCSID 1047, not allowing for the differences for other code pages. This allows for easy interchange of text between computers running different code pages, but makes it unusable, without adaptation, for Perl on those other code pages.</source>
          <target state="translated">UTF-EBCDIC는 &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fwww.unicode.org%2freports%2ftr16&quot;&gt;Unicode Technical Report # 16에&lt;/a&gt; 의해 정의됩니다 . CCSID 1047을 기반으로 정의되며 다른 코드 페이지의 차이를 허용하지 않습니다. 이렇게하면 다른 코드 페이지를 실행하는 컴퓨터간에 텍스트를 쉽게 교환 할 수 있지만 다른 코드 페이지의 Perl에서는 적응없이 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="d1acc50280127d54b308a40ab3c768e112572a85" translate="yes" xml:space="preserve">
          <source>UTF-EBCDIC is defined by &lt;a href=&quot;https://www.unicode.org/reports/tr16&quot;&gt;Unicode Technical Report #16&lt;/a&gt; (often referred to as just TR16). It is defined based on CCSID 1047, not allowing for the differences for other code pages. This allows for easy interchange of text between computers running different code pages, but makes it unusable, without adaptation, for Perl on those other code pages.</source>
          <target state="translated">UTF-EBCDIC는 &lt;a href=&quot;https://www.unicode.org/reports/tr16&quot;&gt;유니 코드 기술 보고서 ​​# 16&lt;/a&gt; (종종 TR16이라고도 함)에 의해 정의됩니다 . CCSID 1047을 기반으로 정의되며 다른 코드 페이지의 차이를 허용하지 않습니다. 이렇게하면 서로 다른 코드 페이지를 실행하는 컴퓨터간에 텍스트를 쉽게 교환 할 수 있지만 다른 코드 페이지에서 Perl에 대해 적용하지 않으면 사용할 수 없게됩니다.</target>
        </trans-unit>
        <trans-unit id="f9b0bbf585cedfbc65f392d0551056f49932bbd3" translate="yes" xml:space="preserve">
          <source>UTF-EBCDIC is used on EBCDIC platforms. It generally requires more bytes to represent a given code point than UTF-8 does; the largest Unicode code points take 5 bytes to represent (instead of 4 in UTF-8), and, extended for 64-bit words, it uses 14 bytes instead of 13 bytes in UTF-8.</source>
          <target state="translated">UTF-EBCDIC는 EBCDIC 플랫폼에서 사용됩니다. 일반적으로 주어진 코드 포인트를 나타내는 데 UTF-8보다 더 많은 바이트가 필요합니다. 가장 큰 유니 코드 코드 포인트는 나타내는 데 5 바이트 (UTF-8에서 4 바이트 대신)를 사용하며 64 비트 단어의 경우 확장하면 UTF-8에서 13 바이트 대신 14 바이트를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="fae1061497efd49ee6054c0a3d6e1ce19e05e6be" translate="yes" xml:space="preserve">
          <source>UTF-EBCDIC is used on EBCDIC platforms. The largest Unicode code points take 5 bytes to represent (instead of 4 in UTF-8), and Perl extends it to a maximum of 7 bytes to encode pode points up to what can fit in a 32-bit word (instead of 13 bytes and a 64-bit word in UTF-8).</source>
          <target state="translated">UTF-EBCDIC는 EBCDIC 플랫폼에서 사용됩니다. 가장 큰 유니 코드 코드 포인트는 5 바이트 (UTF-8에서는 4 대신)를 나타내며 펄 포인트는 최대 32 바이트까지 확장하여 32 비트 워드 (13 바이트 대신)에 해당하는 포인트를 인코딩합니다. UTF-8의 64 비트 단어).</target>
        </trans-unit>
        <trans-unit id="32e4aba336279eb247fca6069de55e692fafce3d" translate="yes" xml:space="preserve">
          <source>UTF-X</source>
          <target state="translated">UTF-X</target>
        </trans-unit>
        <trans-unit id="31c724652517aa38e02f9cc38046b12306389452" translate="yes" xml:space="preserve">
          <source>UTF8SKIP</source>
          <target state="translated">UTF8SKIP</target>
        </trans-unit>
        <trans-unit id="126afec887a4798caa07a768c2ae8b1e709d5df3" translate="yes" xml:space="preserve">
          <source>UTF8_CHK_SKIP</source>
          <target state="translated">UTF8_CHK_SKIP</target>
        </trans-unit>
        <trans-unit id="f98f9b7b4dfefa91df6e8d07ade4cdf88d2b3a4e" translate="yes" xml:space="preserve">
          <source>UTF8_IS_INVARIANT</source>
          <target state="translated">UTF8_IS_INVARIANT</target>
        </trans-unit>
        <trans-unit id="ce7018ef4c544b4117f40b9403d65042195dc6ca" translate="yes" xml:space="preserve">
          <source>UTF8_IS_NONCHAR</source>
          <target state="translated">UTF8_IS_NONCHAR</target>
        </trans-unit>
        <trans-unit id="43a7d7eb6f7a4999dcf643e96fc55bf3ed29e04b" translate="yes" xml:space="preserve">
          <source>UTF8_IS_SUPER</source>
          <target state="translated">UTF8_IS_SUPER</target>
        </trans-unit>
        <trans-unit id="41c64bb8f1a0503efaa4f02874d635fa7fb44ce4" translate="yes" xml:space="preserve">
          <source>UTF8_IS_SURROGATE</source>
          <target state="translated">UTF8_IS_SURROGATE</target>
        </trans-unit>
        <trans-unit id="45d5fa1bf0c167c3f6576cc7457645a65299cae3" translate="yes" xml:space="preserve">
          <source>UTF8_MAXBYTES</source>
          <target state="translated">UTF8_MAXBYTES</target>
        </trans-unit>
        <trans-unit id="0a897c1fa81d6a6686e912ed672c264e86acb2f9" translate="yes" xml:space="preserve">
          <source>UTF8_MAXBYTES_CASE</source>
          <target state="translated">UTF8_MAXBYTES_CASE</target>
        </trans-unit>
        <trans-unit id="8af74f37673e55aee8c36bf5b73bd668baf4075c" translate="yes" xml:space="preserve">
          <source>UTF8_SAFE_SKIP</source>
          <target state="translated">UTF8_SAFE_SKIP</target>
        </trans-unit>
        <trans-unit id="69870d763a319ff2077dd64b9f02bdfd1ad88546" translate="yes" xml:space="preserve">
          <source>UTF8_SKIP</source>
          <target state="translated">UTF8_SKIP</target>
        </trans-unit>
        <trans-unit id="17562b3d061f2f42586076a6b020ba8eb357a3ff" translate="yes" xml:space="preserve">
          <source>UTILITIES</source>
          <target state="translated">UTILITIES</target>
        </trans-unit>
        <trans-unit id="58bc809d31f639453a46636f9c8ab08c8b78bb44" translate="yes" xml:space="preserve">
          <source>UTILITY FUNCTIONS</source>
          <target state="translated">유틸리티 기능</target>
        </trans-unit>
        <trans-unit id="0df889160bec1efd3a376bc092db51a6960809d0" translate="yes" xml:space="preserve">
          <source>UTS #10: Unicode Collation Algorithm</source>
          <target state="translated">UTS # 10 : 유니 코드 데이터 정렬 알고리즘</target>
        </trans-unit>
        <trans-unit id="876d25fb5dd30a195bda72a305a7ba4a3acfcb55" translate="yes" xml:space="preserve">
          <source>UTS #18: Unicode Regular Expressions</source>
          <target state="translated">UTS # 18 : 유니 코드 정규식</target>
        </trans-unit>
        <trans-unit id="edd7d8b48471cc7bdfa22b6a7694cc46d2409bb0" translate="yes" xml:space="preserve">
          <source>UV</source>
          <target state="translated">UV</target>
        </trans-unit>
        <trans-unit id="b25ef34eb3a5137d61daf0def8b67fe626cd3875" translate="yes" xml:space="preserve">
          <source>UVCHR_IS_INVARIANT</source>
          <target state="translated">UVCHR_IS_INVARIANT</target>
        </trans-unit>
        <trans-unit id="626b2f1b7c0d475b14997cb2d1af0b7a04543371" translate="yes" xml:space="preserve">
          <source>UVCHR_SKIP</source>
          <target state="translated">UVCHR_SKIP</target>
        </trans-unit>
        <trans-unit id="9746ff9d4d7b1c241287393e4d9dd0cd6f1bbf03" translate="yes" xml:space="preserve">
          <source>UVX</source>
          <target state="translated">UVX</target>
        </trans-unit>
        <trans-unit id="e92904bce8026b3c1f8828b0ce882e6b081c7fb6" translate="yes" xml:space="preserve">
          <source>Uganda</source>
          <target state="translated">Uganda</target>
        </trans-unit>
        <trans-unit id="c951ec00f123510a00d1e3d9539b11b4631d4096" translate="yes" xml:space="preserve">
          <source>Ukraine</source>
          <target state="translated">Ukraine</target>
        </trans-unit>
        <trans-unit id="994023f4756ccee554f76e83b238ef8441ca987c" translate="yes" xml:space="preserve">
          <source>Ultimate control over what should be done when (actually: each time) an option is encountered on the command line can be achieved by designating a reference to a subroutine (or an anonymous subroutine) as the option destination. When GetOptions() encounters the option, it will call the subroutine with two or three arguments. The first argument is the name of the option. (Actually, it is an object that stringifies to the name of the option.) For a scalar or array destination, the second argument is the value to be stored. For a hash destination, the second argument is the key to the hash, and the third argument the value to be stored. It is up to the subroutine to store the value, or do whatever it thinks is appropriate.</source>
          <target state="translated">옵션 행으로 서브 루틴 (또는 익명 서브 루틴)에 대한 참조를 지정하여 명령 행에서 옵션이 발생할 때 (실제로 매번) 수행 할 작업을 궁극적으로 제어 할 수 있습니다. GetOptions ()가 옵션을 만나면 2 개 또는 3 개의 인수로 서브 루틴을 호출합니다. 첫 번째 인수는 옵션의 이름입니다. (실제로, 옵션 이름으로 문자열을 지정하는 객체입니다.) 스칼라 또는 배열 대상의 경우 두 번째 인수는 저장할 값입니다. 해시 대상의 경우 두 번째 인수는 해시의 키이고 세 번째 인수는 저장할 값입니다. 값을 저장하거나 적절하다고 생각되는 것을 수행하는 것은 서브 루틴에 달려 있습니다.</target>
        </trans-unit>
        <trans-unit id="3ee38d90a0334118e79056b8389ee44abc43742c" translate="yes" xml:space="preserve">
          <source>Unacceptable behavior will result in a public and clearly identified warning. A second instance of unacceptable behavior from the same individual will result in removal from the mailing list and GitHub issue tracker, for a period of one calendar month. The rationale for this is to provide an opportunity for the person to change the way they act.</source>
          <target state="translated">용납 할 수없는 행동은 공개되고 명확하게 식별 된 경고를 받게됩니다. 동일한 개인으로부터 허용되지 않는 행동이 두 번째로 발생하면 1 개월 동안 메일 링리스트 및 GitHub 문제 추적기에서 제거됩니다. 이에 대한 근거는 그 사람이 행동하는 방식을 바꿀 수있는 기회를 제공하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="fd11761cf7cb6cb9a563ded422bdfc4417516b2a" translate="yes" xml:space="preserve">
          <source>Unacceptable behavior will result in a public and clearly identified warning. Repeated unacceptable behavior will result in removal from the mailing list and revocation of rights to update rt.perl.org. The first removal is for one month. Subsequent removals will double in length. After six months with no warning, a user's ban length is reset. Removals, like warnings, are public.</source>
          <target state="translated">허용되지 않는 행동은 공개적이고 명확하게 식별 된 경고를 초래합니다. 허용되지 않는 동작이 반복되면 메일 링리스트에서 제거되고 rt.perl.org 업데이트 권한이 취소됩니다. 첫 번째 제거는 한 달입니다. 후속 제거 길이가 두 배가됩니다. 6 개월 후 경고없이 사용자의 금지 길이가 재설정됩니다. 경고와 같은 삭제는 공개입니다.</target>
        </trans-unit>
        <trans-unit id="7be1c42f094036e0d5e47ba36abcce7c417f4479" translate="yes" xml:space="preserve">
          <source>Unambiguous name: &lt;code&gt;CP932&lt;/code&gt;. &lt;code&gt;IANA&lt;/code&gt; name (also used by Mozilla, and provided as an alias by Encode): &lt;code&gt;Windows-31J&lt;/code&gt;.</source>
          <target state="translated">명확한 이름 : &lt;code&gt;CP932&lt;/code&gt; . &lt;code&gt;IANA&lt;/code&gt; 이름 (Mozilla에서도 사용되며 Encode에서 별칭으로 제공됨) : &lt;code&gt;Windows-31J&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8f645668eee1c03a85fb2473dd516adceaef3f2d" translate="yes" xml:space="preserve">
          <source>Unary &lt;code&gt;&quot;!&quot;&lt;/code&gt; performs logical negation, that is, &quot;not&quot;. See also &lt;a href=&quot;#Logical-Not&quot;&gt;&lt;code&gt;not&lt;/code&gt;&lt;/a&gt; for a lower precedence version of this.</source>
          <target state="translated">단항 &lt;code&gt;&quot;!&quot;&lt;/code&gt; 논리적 부정, 즉 &quot;아님&quot;을 수행합니다. 이것 의 더 낮은 우선 순위 버전에 대해서는 &lt;a href=&quot;#Logical-Not&quot;&gt; &lt;code&gt;not&lt;/code&gt; &lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="1f8a4652f1c5950bdfb9f442db5f7ff059a9e8ff" translate="yes" xml:space="preserve">
          <source>Unary &lt;code&gt;&quot;!&quot;&lt;/code&gt; performs logical negation, that is, &quot;not&quot;. See also &lt;code&gt;not&lt;/code&gt; for a lower precedence version of this.</source>
          <target state="translated">단항 &lt;code&gt;&quot;!&quot;&lt;/code&gt; 논리적 부정, 즉 &quot;아니오&quot;를 수행합니다. 참조 &lt;code&gt;not&lt;/code&gt; 이것의 우선 순위가 낮은 버전.</target>
        </trans-unit>
        <trans-unit id="9a531b0100d0a01bbebb12554267e4d3655767b7" translate="yes" xml:space="preserve">
          <source>Unary &lt;code&gt;&quot;+&quot;&lt;/code&gt; has no effect whatsoever, even on strings. It is useful syntactically for separating a function name from a parenthesized expression that would otherwise be interpreted as the complete list of function arguments. (See examples above under &lt;a href=&quot;#Terms-and-List-Operators-%28Leftward%29&quot;&gt;&quot;Terms and List Operators (Leftward)&quot;&lt;/a&gt;.)</source>
          <target state="translated">단항 &lt;code&gt;&quot;+&quot;&lt;/code&gt; 는 문자열에도 영향을주지 않습니다. 그렇지 않으면 함수 인수의 전체 목록으로 해석 될 괄호로 묶인 표현식에서 함수 이름을 분리하는 데 구문 상 유용합니다. (위의 &lt;a href=&quot;#Terms-and-List-Operators-%28Leftward%29&quot;&gt;&quot;용어 및 목록 연산자 (왼쪽)&quot;&lt;/a&gt; 아래의 예를 참조하십시오 .)</target>
        </trans-unit>
        <trans-unit id="975143052b1e27f57ec5fcc07f42eb1c0eae9dc3" translate="yes" xml:space="preserve">
          <source>Unary &lt;code&gt;&quot;+&quot;&lt;/code&gt; has no effect whatsoever, even on strings. It is useful syntactically for separating a function name from a parenthesized expression that would otherwise be interpreted as the complete list of function arguments. (See examples above under &lt;a href=&quot;#Terms-and-List-Operators-(Leftward)&quot;&gt;Terms and List Operators (Leftward)&lt;/a&gt;.)</source>
          <target state="translated">단항 &lt;code&gt;&quot;+&quot;&lt;/code&gt; 는 문자열에도 영향을 미치지 않습니다. 함수 인수의 전체 목록으로 해석되는 괄호로 묶은 표현식에서 함수 이름을 분리하는 데 구문 적으로 유용합니다. (위의 &lt;a href=&quot;#Terms-and-List-Operators-(Leftward)&quot;&gt;용어 및 목록 연산자 (왼쪽)&lt;/a&gt; 아래 예 참조 )</target>
        </trans-unit>
        <trans-unit id="cbc2e014fe3be3f69d01617e0a9853fb77867e55" translate="yes" xml:space="preserve">
          <source>Unary &lt;code&gt;&quot;-&quot;&lt;/code&gt; performs arithmetic negation if the operand is numeric, including any string that looks like a number. If the operand is an identifier, a string consisting of a minus sign concatenated with the identifier is returned. Otherwise, if the string starts with a plus or minus, a string starting with the opposite sign is returned. One effect of these rules is that &lt;code&gt;-bareword&lt;/code&gt; is equivalent to the string &lt;code&gt;&quot;-bareword&quot;&lt;/code&gt; . If, however, the string begins with a non-alphabetic character (excluding &lt;code&gt;&quot;+&quot;&lt;/code&gt; or &lt;code&gt;&quot;-&quot;&lt;/code&gt; ), Perl will attempt to convert the string to a numeric, and the arithmetic negation is performed. If the string cannot be cleanly converted to a numeric, Perl will give the warning &lt;b&gt;Argument &quot;the string&quot; isn't numeric in negation (-) at ...&lt;/b&gt;.</source>
          <target state="translated">단항 &lt;code&gt;&quot;-&quot;&lt;/code&gt; 는 숫자처럼 보이는 문자열을 포함하여 피연산자가 숫자 인 경우 산술 부정을 수행합니다. 피연산자가 식별자이면 식별자와 연결된 빼기 기호로 구성된 문자열이 반환됩니다. 그렇지 않으면 문자열이 플러스 또는 마이너스로 시작하면 반대 부호로 시작하는 문자열이 반환됩니다. 이러한 규칙의 효과 중 하나는 &lt;code&gt;-bareword&lt;/code&gt; 가 문자열 &lt;code&gt;&quot;-bareword&quot;&lt;/code&gt; 와 동일 하다는 것 입니다. 그러나 문자열이 알파벳이 아닌 문자로 시작하면 ( &lt;code&gt;&quot;+&quot;&lt;/code&gt; 또는 &lt;code&gt;&quot;-&quot;&lt;/code&gt; )로 시작하면 Perl은 문자열을 숫자로 변환하려고 시도하며 산술 부정이 수행됩니다. 문자열을 숫자로 깔끔하게 변환 할 수 없으면 Perl에서 경고를 표시합니다 제외) &lt;b&gt;인수 &quot;문자열&quot;은 음수 (-)에서 숫자가 아닙니다 (...)&lt;/b&gt; .&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="7bfdc53979623a8376c9812be313cb442d92714a" translate="yes" xml:space="preserve">
          <source>Unary &lt;code&gt;&quot;-&quot;&lt;/code&gt; performs arithmetic negation if the operand is numeric, including any string that looks like a number. If the operand is an identifier, a string consisting of a minus sign concatenated with the identifier is returned. Otherwise, if the string starts with a plus or minus, a string starting with the opposite sign is returned. One effect of these rules is that &lt;code&gt;-bareword&lt;/code&gt; is equivalent to the string &lt;code&gt;&quot;-bareword&quot;&lt;/code&gt;. If, however, the string begins with a non-alphabetic character (excluding &lt;code&gt;&quot;+&quot;&lt;/code&gt; or &lt;code&gt;&quot;-&quot;&lt;/code&gt;), Perl will attempt to convert the string to a numeric, and the arithmetic negation is performed. If the string cannot be cleanly converted to a numeric, Perl will give the warning &lt;b&gt;Argument &quot;the string&quot; isn't numeric in negation (-) at ...&lt;/b&gt;.</source>
          <target state="translated">단항 &lt;code&gt;&quot;-&quot;&lt;/code&gt; 는 숫자처럼 보이는 문자열을 포함하여 피연산자가 숫자이면 산술 부정을 수행합니다. 피연산자가 식별자이면 식별자와 연결된 빼기 기호로 구성된 문자열이 반환됩니다. 그렇지 않고 문자열이 더하기 또는 빼기로 시작하면 반대 부호로 시작하는 문자열이 반환됩니다. 이러한 규칙의 효과 중 하나는 &lt;code&gt;-bareword&lt;/code&gt; 가 문자열 &lt;code&gt;&quot;-bareword&quot;&lt;/code&gt; 와 동일 하다는 것 입니다. 그러나 문자열이 알파벳이 아닌 문자 ( &lt;code&gt;&quot;+&quot;&lt;/code&gt; 또는 &lt;code&gt;&quot;-&quot;&lt;/code&gt; 제외 )로 시작하면 Perl은 문자열을 숫자로 변환하려고 시도하고 산술 부정이 수행됩니다. 문자열을 숫자로 명확하게 변환 할 수없는 경우 Perl은 경고를 표시합니다.&lt;b&gt;인수 &quot;문자열&quot;이 ...에서 부정 (-) 숫자가 아닙니다&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="75765e3d8911e6ac713c74a3a1fc1d709b9ed2ea" translate="yes" xml:space="preserve">
          <source>Unary &lt;code&gt;&quot;\&quot;&lt;/code&gt; creates a reference to whatever follows it. See &lt;a href=&quot;perlreftut&quot;&gt;perlreftut&lt;/a&gt; and &lt;a href=&quot;perlref&quot;&gt;perlref&lt;/a&gt;. Do not confuse this behavior with the behavior of backslash within a string, although both forms do convey the notion of protecting the next thing from interpolation.</source>
          <target state="translated">단항 &lt;code&gt;&quot;\&quot;&lt;/code&gt; 는 뒤에 오는 모든 것에 대한 참조를 만듭니다. &lt;a href=&quot;perlreftut&quot;&gt;perlreftut&lt;/a&gt; 및 &lt;a href=&quot;perlref&quot;&gt;perlref를&lt;/a&gt; 참조하십시오 . 두 형식이 다음 항목을 보간으로부터 보호한다는 개념을 전달하지만이 동작을 문자열 내 백 슬래시 동작과 혼동하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="ebbcbdaf6ef9f2a6fa62770e3fce7999d3f8a59a" translate="yes" xml:space="preserve">
          <source>Unary &lt;code&gt;&quot;\&quot;&lt;/code&gt; creates references. If its operand is a single sigilled thing, it creates a reference to that object. If its operand is a parenthesised list, then it creates references to the things mentioned in the list. Otherwise it puts its operand in list context, and creates a list of references to the scalars in the list provided by the operand. See &lt;a href=&quot;perlreftut&quot;&gt;perlreftut&lt;/a&gt; and &lt;a href=&quot;perlref&quot;&gt;perlref&lt;/a&gt;. Do not confuse this behavior with the behavior of backslash within a string, although both forms do convey the notion of protecting the next thing from interpolation.</source>
          <target state="translated">단항 &lt;code&gt;&quot;\&quot;&lt;/code&gt; 는 참조를 만듭니다. 피연산자가 단일시길이면 해당 개체에 대한 참조를 만듭니다. 피연산자가 괄호로 묶인 목록이면 목록에 언급 된 항목에 대한 참조를 만듭니다. 그렇지 않으면 피연산자를 목록 컨텍스트에 넣고 피연산자가 제공하는 목록에 스칼라에 대한 참조 목록을 만듭니다. &lt;a href=&quot;perlreftut&quot;&gt;perlreftut&lt;/a&gt; 및 &lt;a href=&quot;perlref&quot;&gt;perlref를&lt;/a&gt; 참조하십시오 . 이 동작을 문자열 내의 백 슬래시 동작과 혼동하지 마십시오. 두 형식 모두 보간으로부터 다음 항목을 보호한다는 개념을 전달합니다.</target>
        </trans-unit>
        <trans-unit id="a440a050a6ba4df9312abb517ec0cbc1f89e1767" translate="yes" xml:space="preserve">
          <source>Unary &lt;code&gt;&quot;not&quot;&lt;/code&gt; returns the logical negation of the expression to its right. It's the equivalent of &lt;code&gt;&quot;!&quot;&lt;/code&gt; except for the very low precedence.</source>
          <target state="translated">단항 &lt;code&gt;&quot;not&quot;&lt;/code&gt; 은 표현식의 논리적 부정을 오른쪽으로 반환합니다. &lt;code&gt;&quot;!&quot;&lt;/code&gt; 와 같습니다 . 우선 순위가 매우 낮습니다.</target>
        </trans-unit>
        <trans-unit id="eafed7c0deddc83d38ef5898a025102a424aea2a" translate="yes" xml:space="preserve">
          <source>Unary &lt;code&gt;&quot;~&quot;&lt;/code&gt; performs bitwise negation, that is, 1's complement. For example, &lt;code&gt;0666 &amp;amp; ~027&lt;/code&gt; is 0640. (See also &lt;a href=&quot;#Integer-Arithmetic&quot;&gt;&quot;Integer Arithmetic&quot;&lt;/a&gt; and &lt;a href=&quot;#Bitwise-String-Operators&quot;&gt;&quot;Bitwise String Operators&quot;&lt;/a&gt;.) Note that the width of the result is platform-dependent: &lt;code&gt;~0&lt;/code&gt; is 32 bits wide on a 32-bit platform, but 64 bits wide on a 64-bit platform, so if you are expecting a certain bit width, remember to use the &lt;code&gt;&quot;&amp;amp;&quot;&lt;/code&gt; operator to mask off the excess bits.</source>
          <target state="translated">단항 &lt;code&gt;&quot;~&quot;&lt;/code&gt; 는 비트 부정, 즉 1의 보수를 수행합니다. 예를 들어, &lt;code&gt;0666 &amp;amp; ~027&lt;/code&gt; 은 0640입니다. ( &lt;a href=&quot;#Integer-Arithmetic&quot;&gt;&quot;Integer Arithmetic&quot;&lt;/a&gt; 및 &lt;a href=&quot;#Bitwise-String-Operators&quot;&gt;&quot;Bitwise String Operators&quot;참조&lt;/a&gt; ) 결과의 너비는 플랫폼에 따라 다릅니다. &lt;code&gt;~0&lt;/code&gt; 은 32 비트 플랫폼에서 32 비트 너비입니다. 그러나 64 비트 플랫폼에서는 64 비트 너비이므로 특정 비트 너비를 예상하는 경우 &lt;code&gt;&quot;&amp;amp;&quot;&lt;/code&gt; 연산자를 사용 하여 초과 비트를 가리는 것을 잊지 마십시오 .</target>
        </trans-unit>
        <trans-unit id="4dae9b42247425fb7e1e868bc6aec93255104f04" translate="yes" xml:space="preserve">
          <source>Unary &lt;code&gt;&quot;~&quot;&lt;/code&gt; performs bitwise negation, that is, 1's complement. For example, &lt;code&gt;0666 &amp;amp; ~027&lt;/code&gt; is 0640. (See also &lt;a href=&quot;#Integer-Arithmetic&quot;&gt;Integer Arithmetic&lt;/a&gt; and &lt;a href=&quot;#Bitwise-String-Operators&quot;&gt;Bitwise String Operators&lt;/a&gt;.) Note that the width of the result is platform-dependent: &lt;code&gt;~0&lt;/code&gt; is 32 bits wide on a 32-bit platform, but 64 bits wide on a 64-bit platform, so if you are expecting a certain bit width, remember to use the &lt;code&gt;&quot;&amp;amp;&quot;&lt;/code&gt; operator to mask off the excess bits.</source>
          <target state="translated">단항 &lt;code&gt;&quot;~&quot;&lt;/code&gt; 비트 단위 부정, 즉 1의 보수를 수행합니다. 예를 들어, &lt;code&gt;0666 &amp;amp; ~027&lt;/code&gt; 은 0640입니다 ( &lt;a href=&quot;#Integer-Arithmetic&quot;&gt;정수 산술&lt;/a&gt; 및 &lt;a href=&quot;#Bitwise-String-Operators&quot;&gt;비트 문자열 연산자 참조)&lt;/a&gt; . 결과 너비는 플랫폼에 따라 다릅니다. &lt;code&gt;~0&lt;/code&gt; 은 32 비트 플랫폼에서 32 비트 폭이지만 64 비트 폭입니다. 64 비트 플랫폼에서 특정 비트 너비를 예상하는 경우 &lt;code&gt;&quot;&amp;amp;&quot;&lt;/code&gt; 연산자를 사용 하여 초과 비트를 마스킹하십시오.</target>
        </trans-unit>
        <trans-unit id="121bb514c3415be69016271f5f8950c0aed3f161" translate="yes" xml:space="preserve">
          <source>Unbackslashed prototype characters have special meanings. Any unbackslashed &lt;code&gt;@&lt;/code&gt; or &lt;code&gt;%&lt;/code&gt; eats all remaining arguments, and forces list context. An argument represented by &lt;code&gt;$&lt;/code&gt; forces scalar context. An &lt;code&gt;&amp;amp;&lt;/code&gt; requires an anonymous subroutine, which, if passed as the first argument, does not require the &lt;code&gt;&lt;a href=&quot;functions/sub&quot;&gt;sub&lt;/a&gt;&lt;/code&gt; keyword or a subsequent comma.</source>
          <target state="translated">백 슬래시가없는 프로토 타입 문자에는 특별한 의미가 있습니다. 역 슬래시 &lt;code&gt;@&lt;/code&gt; 또는 &lt;code&gt;%&lt;/code&gt; 는 나머지 모든 인수를 먹고 목록 컨텍스트를 강제 실행합니다. &lt;code&gt;$&lt;/code&gt; 로 표시되는 인수는 스칼라 컨텍스트를 강제합니다. &lt;code&gt;&amp;amp;&lt;/code&gt; 은 첫 번째 인수로 전달하는 경우는 필요로하지 않는 익명 서브 루틴이 필요 &lt;code&gt;&lt;a href=&quot;functions/sub&quot;&gt;sub&lt;/a&gt;&lt;/code&gt; 키워드 또는 후속 쉼표.</target>
        </trans-unit>
        <trans-unit id="0f4206d3ad193e4f502eb8614314c82b73d3aac7" translate="yes" xml:space="preserve">
          <source>Unbackslashed prototype characters have special meanings. Any unbackslashed &lt;code&gt;@&lt;/code&gt; or &lt;code&gt;%&lt;/code&gt; eats all remaining arguments, and forces list context. An argument represented by &lt;code&gt;$&lt;/code&gt; forces scalar context. An &lt;code&gt;&amp;amp;&lt;/code&gt; requires an anonymous subroutine, which, if passed as the first argument, does not require the &lt;code&gt;sub&lt;/code&gt; keyword or a subsequent comma.</source>
          <target state="translated">백 슬래시가없는 프로토 타입 문자에는 특별한 의미가 있습니다. 백 슬래시가없는 &lt;code&gt;@&lt;/code&gt; 또는 &lt;code&gt;%&lt;/code&gt; 는 나머지 인수를 모두 먹고 목록 컨텍스트를 강제합니다. &lt;code&gt;$&lt;/code&gt; 로 표시되는 인수는 스칼라 컨텍스트를 강제합니다. &lt;code&gt;&amp;amp;&lt;/code&gt; 은 첫 번째 인수로 전달하는 경우는 필요로하지 않는 익명 서브 루틴이 필요 &lt;code&gt;sub&lt;/code&gt; 키워드 또는 후속 쉼표.</target>
        </trans-unit>
        <trans-unit id="3738795de70b96657adef7c7eb0d0399db5d1dfd" translate="yes" xml:space="preserve">
          <source>Unbalanced context: %d more PUSHes than POPs</source>
          <target state="translated">불균형 컨텍스트 : POP보다 PUSH가 % d 회 더 많습니다.</target>
        </trans-unit>
        <trans-unit id="fd301ac8b7825aca5986ed906c3a5149ebf3f404" translate="yes" xml:space="preserve">
          <source>Unbalanced saves: %d more saves than restores</source>
          <target state="translated">불균형 저장 : 복원보다 % d 더 많은 저장</target>
        </trans-unit>
        <trans-unit id="6c20914fff1ee5340b7195287825b168d65cf279" translate="yes" xml:space="preserve">
          <source>Unbalanced scopes: %d more ENTERs than LEAVEs</source>
          <target state="translated">불균형 범위 : LEAVE보다 % d 더 많은 ENTER</target>
        </trans-unit>
        <trans-unit id="353a68e15d6c873dffbe66b456319369d1b6b50f" translate="yes" xml:space="preserve">
          <source>Unbalanced string table refcount: (%d) for &quot;%s&quot;</source>
          <target state="translated">불균형 문자열 테이블 참조 횟수 : (% d) ( &quot;% s&quot;)</target>
        </trans-unit>
        <trans-unit id="d948ff04e713e8c3958319663d10246dfd6ee946" translate="yes" xml:space="preserve">
          <source>Unbalanced tmps: %d more allocs than frees</source>
          <target state="translated">불균형 tmps : 해제 된 것보다 % d 더 많은 할당</target>
        </trans-unit>
        <trans-unit id="825c40d18a2a673a59517a26d2876574d355db3e" translate="yes" xml:space="preserve">
          <source>Uncompress gzip, zip, bzip2 or lzop file/buffer</source>
          <target state="translated">gzip, zip, bzip2 또는 lzop 파일 / 버퍼 압축 해제</target>
        </trans-unit>
        <trans-unit id="d920a6c2ef6eab3bfedd330e8191658438c99755" translate="yes" xml:space="preserve">
          <source>Uncompress gzip, zip, bzip2, xz, lzma, lzip, lzf or lzop file/buffer</source>
          <target state="translated">gzip, zip, bzip2, xz, lzma, lzip, lzf 또는 lzop 파일 / 버퍼의 압축을 풉니 다.</target>
        </trans-unit>
        <trans-unit id="aed55ac0a8b1616e77c1e8b5f3fc823c056e7f68" translate="yes" xml:space="preserve">
          <source>Uncompress zlib-based (zip, gzip) file/buffer</source>
          <target state="translated">zlib 기반 (zip, gzip) 파일 / 버퍼 압축 해제</target>
        </trans-unit>
        <trans-unit id="5566ebf8e86133343de98e57588751d94f017699" translate="yes" xml:space="preserve">
          <source>Uncompresses &lt;code&gt;$input&lt;/code&gt; and writes the uncompressed data to &lt;code&gt;$output&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;$input&lt;/code&gt; 압축 해제 하고 압축되지 않은 데이터를 &lt;code&gt;$output&lt;/code&gt; 씁니다 .</target>
        </trans-unit>
        <trans-unit id="28f5f3ca9546807770e11a4b5cc0101b027504cd" translate="yes" xml:space="preserve">
          <source>Uncompresses &lt;code&gt;$input&lt;/code&gt; and writes the uncompressed data to &lt;code&gt;$output&lt;/code&gt;.</source>
          <target state="translated">압축 해제 &lt;code&gt;$input&lt;/code&gt; 하고 압축되지 않은 데이터를 기록 &lt;code&gt;$output&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3241d8b84b7531f4c85af8e73c024fd4504975c7" translate="yes" xml:space="preserve">
          <source>Uncompresses &lt;code&gt;$source&lt;/code&gt; . If successful it returns the uncompressed data. Otherwise it returns</source>
          <target state="translated">&lt;code&gt;$source&lt;/code&gt; 압축을 해제 합니다 . 성공하면 압축되지 않은 데이터를 반환합니다. 그렇지 않으면 반환</target>
        </trans-unit>
        <trans-unit id="3e3d7aabce04dc1ae1923e54e8345382bb871093" translate="yes" xml:space="preserve">
          <source>Uncompresses &lt;code&gt;$source&lt;/code&gt;. If successful it returns the uncompressed data. Otherwise it returns</source>
          <target state="translated">&lt;code&gt;$source&lt;/code&gt; 압축을 풉니 다 . 성공하면 압축되지 않은 데이터를 반환합니다. 그렇지 않으면 반환</target>
        </trans-unit>
        <trans-unit id="ac8d3226186ea01833996c8b65de3f2a8379790e" translate="yes" xml:space="preserve">
          <source>Uncompression</source>
          <target state="translated">Uncompression</target>
        </trans-unit>
        <trans-unit id="4189d548d277ce627b98749a55c3556ffc35219e" translate="yes" xml:space="preserve">
          <source>Unconditionally match a bareword or any other single character, and then go back to step 1.</source>
          <target state="translated">무조건 베어나 다른 단일 문자를 일치시킨 다음 1 단계로 돌아갑니다.</target>
        </trans-unit>
        <trans-unit id="577343970a5bf9b7cb8738f42c2797ca4589087a" translate="yes" xml:space="preserve">
          <source>Uncuddled elses and &quot;K&amp;amp;R&quot; style for indenting control constructs</source>
          <target state="translated">제어 구조를 들여 쓰기위한 다른 것들과 &quot;K &amp;amp; R&quot;스타일</target>
        </trans-unit>
        <trans-unit id="11c11d31d108dd964ce797e5076b1d8839850791" translate="yes" xml:space="preserve">
          <source>Uncuddled elses.</source>
          <target state="translated">껴안은 다른 사람들.</target>
        </trans-unit>
        <trans-unit id="5cd9e75daaa9152346601595647eb2d9696e6583" translate="yes" xml:space="preserve">
          <source>Undef if an external</source>
          <target state="translated">외부인 경우 undef</target>
        </trans-unit>
        <trans-unit id="a6e635cf2fd6fb596c7dbe39947e67bb7ea6fa49" translate="yes" xml:space="preserve">
          <source>Undefined format</source>
          <target state="translated">정의되지 않은 형식</target>
        </trans-unit>
        <trans-unit id="bc4f02e6922be60fefc3ec95167f2596c8a6d252" translate="yes" xml:space="preserve">
          <source>Undefined format &quot;%s&quot; called</source>
          <target state="translated">정의되지 않은 형식 &quot;% s&quot;이 (가) 호출되었습니다.</target>
        </trans-unit>
        <trans-unit id="3c4edf1aebafd67a9b05c592beff7f41d45d0d8d" translate="yes" xml:space="preserve">
          <source>Undefined sort subroutine &quot;%s&quot; called</source>
          <target state="translated">정의되지 않은 정렬 서브 루틴 &quot;% s&quot;이 (가) 호출되었습니다.</target>
        </trans-unit>
        <trans-unit id="4df75dc3ed124d993a3860e648584776b9c515c8" translate="yes" xml:space="preserve">
          <source>Undefined subroutine &amp;amp;%s called</source>
          <target state="translated">정의되지 않은 서브 루틴 &amp;amp; % s이 (가) 호출되었습니다.</target>
        </trans-unit>
        <trans-unit id="b410752a7d8baa31a708ac9e0618b37a2bdd788d" translate="yes" xml:space="preserve">
          <source>Undefined subroutine &amp;amp;main::GetOptions called</source>
          <target state="translated">정의되지 않은 서브 루틴 &amp;amp; main :: GetOptions 호출</target>
        </trans-unit>
        <trans-unit id="547eab04e6e04e1b4edec483ca694ca7539affef" translate="yes" xml:space="preserve">
          <source>Undefined subroutine called</source>
          <target state="translated">정의되지 않은 서브 루틴이 호출되었습니다.</target>
        </trans-unit>
        <trans-unit id="264796a21d9347fe1112a79c8f0b60a38d55c6c6" translate="yes" xml:space="preserve">
          <source>Undefined subroutine in sort</source>
          <target state="translated">정렬되지 않은 서브 루틴</target>
        </trans-unit>
        <trans-unit id="6d3680cc6661c9c64f65a5465eb19c791369f48e" translate="yes" xml:space="preserve">
          <source>Undefined top format &quot;%s&quot; called</source>
          <target state="translated">정의되지 않은 최상위 형식 &quot;% s&quot;이 (가) 호출되었습니다.</target>
        </trans-unit>
        <trans-unit id="fc0e7464ad33c8fd897b6e1f38879e9424a6041b" translate="yes" xml:space="preserve">
          <source>Undefined value assigned to typeglob</source>
          <target state="translated">typeglob에 할당 된 정의되지 않은 값</target>
        </trans-unit>
        <trans-unit id="4be1ae516287ece8c814ce973af8c8cef754916c" translate="yes" xml:space="preserve">
          <source>Undefines the array. Frees the memory used by the av to store its list of scalars. If any destructors are triggered as a result, the av itself may be freed.</source>
          <target state="translated">배열을 정의 해제합니다. av가 스칼라 목록을 저장하기 위해 사용하는 메모리를 해제합니다. 결과적으로 소멸자가 트리거되면 av 자체가 해제 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="54917ea2121718cf7348ee74d00c8feedc82f150" translate="yes" xml:space="preserve">
          <source>Undefines the array. The XS equivalent of &lt;code&gt;undef(@array)&lt;/code&gt;.</source>
          <target state="translated">배열을 정의 해제합니다. &lt;code&gt;undef(@array)&lt;/code&gt; 해당하는 XS 입니다.</target>
        </trans-unit>
        <trans-unit id="270b863b48b0c13c0b01735bf826d9b654084021" translate="yes" xml:space="preserve">
          <source>Undefines the collation element as if it were unassigned in the &lt;code&gt;table&lt;/code&gt; . This reduces the size of the table. If an unassigned character appears in the string to be collated, the sort key is made from its codepoint as a single-character collation element, as it is greater than any other assigned collation elements (in the codepoint order among the unassigned characters). But, it'd be better to ignore characters unfamiliar to you and maybe never used.</source>
          <target state="translated">데이터 정렬 요소가 마치 &lt;code&gt;table&lt;/code&gt; 에서 할당되지 않은 것처럼 정의 해제 합니다 . 테이블 크기가 줄어 듭니다. 할당되지 않은 문자가 정렬 될 문자열에 나타나면 정렬 키는 할당 된 다른 데이터 정렬 요소 (할당되지 않은 문자 중 코드 포인트 순서)보다 크기 때문에 코드 포인트에서 단일 문자 데이터 정렬 요소로 만들어집니다. 그러나 익숙하지 않은 문자는 무시하고 사용하지 않는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="6c572aa720a9e02b4868a08c5ea6700924c6a793" translate="yes" xml:space="preserve">
          <source>Undefines the collation element as if it were unassigned in the &lt;code&gt;table&lt;/code&gt;. This reduces the size of the table. If an unassigned character appears in the string to be collated, the sort key is made from its codepoint as a single-character collation element, as it is greater than any other assigned collation elements (in the codepoint order among the unassigned characters). But, it'd be better to ignore characters unfamiliar to you and maybe never used.</source>
          <target state="translated">&lt;code&gt;table&lt;/code&gt; 에서 할당되지 않은 것처럼 데이터 정렬 요소를 정의 해제 합니다 . 이것은 테이블의 크기를 줄입니다. 배열 할 문자열에 할당되지 않은 문자가 나타나면 정렬 키는 다른 할당 된 조합 요소보다 크기 때문에 단일 문자 조합 요소로 해당 코드 포인트에서 만들어집니다 (할당되지 않은 문자 사이의 코드 포인트 순서대로). 그러나 익숙하지 않거나 사용하지 않았을 수도있는 문자는 무시하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="7b61a323c52c38306eb024952539f4f8c5a7ffe3" translate="yes" xml:space="preserve">
          <source>Undefines the hash. The XS equivalent of &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef(%hash)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">해시를 정의 해제하십시오. &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef(%hash)&lt;/a&gt;&lt;/code&gt; 와 동일한 XS 입니다.</target>
        </trans-unit>
        <trans-unit id="1e5b088250fea82ab591b0cfc87d6babcdba55fe" translate="yes" xml:space="preserve">
          <source>Undefines the hash. The XS equivalent of &lt;code&gt;undef(%hash)&lt;/code&gt;.</source>
          <target state="translated">해시를 정의 해제합니다. &lt;code&gt;undef(%hash)&lt;/code&gt; 해당하는 XS 입니다.</target>
        </trans-unit>
        <trans-unit id="21918cc87ca44856538ac74361e547848b42b7b4" translate="yes" xml:space="preserve">
          <source>Undefines the value of EXPR, which must be an lvalue. Use only on a scalar value, an array (using &lt;code&gt;@&lt;/code&gt; ), a hash (using &lt;code&gt;%&lt;/code&gt; ), a subroutine (using &lt;code&gt;&amp;amp;&lt;/code&gt; ), or a typeglob (using &lt;code&gt;*&lt;/code&gt; ). Saying &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt; $hash{$key}&lt;/code&gt; will probably not do what you expect on most predefined variables or DBM list values, so don't do that; see &lt;a href=&quot;#delete&quot;&gt;delete&lt;/a&gt;. Always returns the undefined value. You can omit the EXPR, in which case nothing is undefined, but you still get an undefined value that you could, for instance, return from a subroutine, assign to a variable, or pass as a parameter. Examples:</source>
          <target state="translated">EXPR의 값을 정의하십시오. 이는 lvalue 여야합니다. 스칼라 값, 배열 ( &lt;code&gt;@&lt;/code&gt; 사용 ), 해시 ( &lt;code&gt;%&lt;/code&gt; 사용 ), 서브 루틴 ( &lt;code&gt;&amp;amp;&lt;/code&gt; 사용 ) 또는 typeglob ( &lt;code&gt;*&lt;/code&gt; 사용)에만 사용하십시오 . 말하는 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt; $hash{$key}&lt;/code&gt; 아마 당신이 그렇게 그렇게하지 않는 대부분의 미리 정의 된 변수 나 DBM 목록 값을 기대하지 않을 것이다; &lt;a href=&quot;#delete&quot;&gt;delete를&lt;/a&gt; 참조하십시오 . 항상 정의되지 않은 값을 반환합니다. EXPR을 생략 할 수 있습니다.이 경우 정의되지 않은 것은 없지만 서브 루틴에서 리턴하거나 변수에 지정하거나 매개 변수로 전달할 수있는 정의되지 않은 값을 계속 얻을 수 있습니다. 예 :</target>
        </trans-unit>
        <trans-unit id="12772c94a5d6a3598c32da79f4c1c4affc5b608e" translate="yes" xml:space="preserve">
          <source>Undefines the value of EXPR, which must be an lvalue. Use only on a scalar value, an array (using &lt;code&gt;@&lt;/code&gt; ), a hash (using &lt;code&gt;%&lt;/code&gt; ), a subroutine (using &lt;code&gt;&amp;amp;&lt;/code&gt; ), or a typeglob (using &lt;code&gt;*&lt;/code&gt; ). Saying &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt; $hash{$key}&lt;/code&gt; will probably not do what you expect on most predefined variables or DBM list values, so don't do that; see &lt;a href=&quot;delete&quot;&gt;delete&lt;/a&gt;. Always returns the undefined value. You can omit the EXPR, in which case nothing is undefined, but you still get an undefined value that you could, for instance, return from a subroutine, assign to a variable, or pass as a parameter. Examples:</source>
          <target state="translated">EXPR의 값을 정의하십시오. 이는 lvalue 여야합니다. 스칼라 값, 배열 ( &lt;code&gt;@&lt;/code&gt; 사용 ), 해시 ( &lt;code&gt;%&lt;/code&gt; 사용 ), 서브 루틴 ( &lt;code&gt;&amp;amp;&lt;/code&gt; 사용 ) 또는 typeglob ( &lt;code&gt;*&lt;/code&gt; 사용)에만 사용하십시오 . 말하는 &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt; $hash{$key}&lt;/code&gt; 아마 당신이 그렇게 그렇게하지 않는 대부분의 미리 정의 된 변수 나 DBM 목록 값을 기대하지 않을 것이다; &lt;a href=&quot;delete&quot;&gt;delete를&lt;/a&gt; 참조하십시오 . 항상 정의되지 않은 값을 반환합니다. EXPR을 생략 할 수 있습니다.이 경우 정의되지 않은 것은 없지만 서브 루틴에서 리턴하거나 변수에 지정하거나 매개 변수로 전달할 수있는 정의되지 않은 값을 계속 얻을 수 있습니다. 예 :</target>
        </trans-unit>
        <trans-unit id="638220651f84b9cd00c5941897d28ba69d79dc1a" translate="yes" xml:space="preserve">
          <source>Undefines the value of EXPR, which must be an lvalue. Use only on a scalar value, an array (using &lt;code&gt;@&lt;/code&gt;), a hash (using &lt;code&gt;%&lt;/code&gt;), a subroutine (using &lt;code&gt;&amp;amp;&lt;/code&gt;), or a typeglob (using &lt;code&gt;*&lt;/code&gt;). Saying &lt;code&gt;undef $hash{$key}&lt;/code&gt; will probably not do what you expect on most predefined variables or DBM list values, so don't do that; see &lt;a href=&quot;#delete-EXPR&quot;&gt;&lt;code&gt;delete&lt;/code&gt;&lt;/a&gt;. Always returns the undefined value. You can omit the EXPR, in which case nothing is undefined, but you still get an undefined value that you could, for instance, return from a subroutine, assign to a variable, or pass as a parameter. Examples:</source>
          <target state="translated">lvalue 여야하는 EXPR의 값을 정의 해제합니다. 스칼라 값, 배열 ( &lt;code&gt;@&lt;/code&gt; 사용 ), 해시 ( &lt;code&gt;%&lt;/code&gt; 사용 ), 서브 루틴 ( &lt;code&gt;&amp;amp;&lt;/code&gt; 사용 ) 또는 typeglob ( &lt;code&gt;*&lt;/code&gt; 사용)에만 사용하십시오 . &lt;code&gt;undef $hash{$key}&lt;/code&gt; 라고 말하면 대부분의 사전 정의 된 변수 나 DBM 목록 값에서 예상 한대로 작동하지 않을 수 있으므로 그렇게하지 마십시오. &lt;a href=&quot;#delete-EXPR&quot;&gt; &lt;code&gt;delete&lt;/code&gt; &lt;/a&gt; 참조하십시오 . 항상 정의되지 않은 값을 반환합니다. EXPR을 생략 할 수 있습니다.이 경우 정의되지 않은 것은 없지만, 예를 들어 서브 루틴에서 리턴하거나 변수에 할당하거나 매개 변수로 전달할 수있는 정의되지 않은 값을 계속 얻을 수 있습니다. 예 :</target>
        </trans-unit>
        <trans-unit id="8b42ea56822642513e4f112de38357bed9dd6a64" translate="yes" xml:space="preserve">
          <source>Undefining this symbol disables the PerlIO abstraction. PerlIO is now the default; it is not recommended to disable PerlIO.</source>
          <target state="translated">이 기호를 정의하지 않으면 PerlIO 추상화가 비활성화됩니다. PerlIO가 이제 기본값입니다. PerlIO를 비활성화하지 않는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="14931b1ffe46d4f806d87924392ea8d8ba051a3f" translate="yes" xml:space="preserve">
          <source>Undefining this symbol forces Perl to be compiled statically.</source>
          <target state="translated">이 기호를 정의하지 않으면 Perl이 정적으로 컴파일됩니다.</target>
        </trans-unit>
        <trans-unit id="55d31ccf7c7a9061158740ae0e4ba2a4be4c51d6" translate="yes" xml:space="preserve">
          <source>Under &quot;Classic&quot; MacOS, a perl program will have the appropriate Creator and Type, so that double-clicking them will invoke the MacPerl application. Under Mac OS X, clickable apps can be made from any &lt;code&gt;#!&lt;/code&gt; script using Wil Sanchez' DropScript utility: &lt;a href=&quot;http://www.wsanchez.net/software/&quot;&gt;http://www.wsanchez.net/software/&lt;/a&gt; .</source>
          <target state="translated">&quot;Classic&quot;MacOS 하에서 perl 프로그램은 적절한 Creator와 Type을 가지게되므로, 더블 클릭하면 MacPerl 응용 프로그램이 호출됩니다. Mac OS X에서는 클릭 가능한 앱을 &lt;code&gt;#!&lt;/code&gt; 에서 만들 수 있습니다 ! 스크립트를 사용하여 윌 산체스 'DropScript 유틸리티 : &lt;a href=&quot;http://www.wsanchez.net/software/&quot;&gt;http://www.wsanchez.net/software/&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7de147ca0cf42a020c2b34e4934080e8fbf00bba" translate="yes" xml:space="preserve">
          <source>Under &lt;a href=&quot;../test/harness&quot;&gt;Test::Harness&lt;/a&gt;, test number 2 would</source>
          <target state="translated">에서 &lt;a href=&quot;../test/harness&quot;&gt;테스트 : 하네스&lt;/a&gt; , 테스트 번호 2 것</target>
        </trans-unit>
        <trans-unit id="830e70bc7050b5ad58debeaf947b37217d6be21e" translate="yes" xml:space="preserve">
          <source>Under &lt;a href=&quot;Test::Harness&quot;&gt;Test::Harness&lt;/a&gt;, test number 2 would</source>
          <target state="translated">에서 &lt;a href=&quot;Test::Harness&quot;&gt;테스트 : 하네스&lt;/a&gt; , 테스트 번호 2 것</target>
        </trans-unit>
        <trans-unit id="50510298fcc80cb0b2cfe5fcb98eb1382cb9d484" translate="yes" xml:space="preserve">
          <source>Under &lt;code&gt;(normalization =&amp;gt; &lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;)&lt;/code&gt; , detection step of discontiguous contractions will be skipped.</source>
          <target state="translated">&lt;code&gt;(normalization =&amp;gt; &lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;)&lt;/code&gt; 아래에서 불연속 수축의 감지 단계를 건너 뜁니다.</target>
        </trans-unit>
        <trans-unit id="6a769e92dc491fba4fdaa440dbac9751e38e85b4" translate="yes" xml:space="preserve">
          <source>Under &lt;code&gt;(normalization =&amp;gt; undef)&lt;/code&gt;, detection step of discontiguous contractions will be skipped.</source>
          <target state="translated">아래 &lt;code&gt;(normalization =&amp;gt; undef)&lt;/code&gt; , 불연속 수축 검출 단계는 생략 될 것이다.</target>
        </trans-unit>
        <trans-unit id="da1bc7be7a27894ec56a14e00f77fdf88c07658e" translate="yes" xml:space="preserve">
          <source>Under &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; v5.16&lt;/code&gt; , or &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; feature &quot;array_base&quot;&lt;/code&gt; , &lt;code&gt;$[&lt;/code&gt; no longer has any effect, and always contains 0. Assigning 0 to it is permitted, but any other value will produce an error.</source>
          <target state="translated">에서 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; v5.16&lt;/code&gt; , 또는 &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; feature &quot;array_base&quot;&lt;/code&gt; , &lt;code&gt;$[&lt;/code&gt; 더 이상 효과가없고, 항상 0이 허용 할당 0을 포함하고 있지만, 다른 값은 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="bacf555aace53131b41a0f7ef63c9e3e7d03589b" translate="yes" xml:space="preserve">
          <source>Under &lt;code&gt;unicode_strings&lt;/code&gt; starting in Perl 5.12.0, Unicode rules are generally used. See &lt;a href=&quot;functions/lc&quot;&gt;lc&lt;/a&gt; for details on how this works in combination with various other pragmas.</source>
          <target state="translated">아래 &lt;code&gt;unicode_strings&lt;/code&gt; 펄 5.12.0에서 시작, 유니 코드 규칙이 일반적으로 사용된다. 이 방법이 다양한 다른 pragma와 함께 작동하는 방법에 대한 자세한 내용 은 &lt;a href=&quot;functions/lc&quot;&gt;lc&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f60303853e6438f23bfd0e7253ff8d6666354a3e" translate="yes" xml:space="preserve">
          <source>Under &lt;code&gt;unicode_strings&lt;/code&gt; starting in Perl 5.12.0, Unicode rules are generally used. See &lt;a href=&quot;perlfunc#lc&quot;&gt;&quot;lc&quot; in perlfunc&lt;/a&gt; for details on how this works in combination with various other pragmas.</source>
          <target state="translated">아래 &lt;code&gt;unicode_strings&lt;/code&gt; 펄 5.12.0에서 시작, 유니 코드 규칙이 일반적으로 사용된다. 이것이 다양한 다른 pragma와 함께 작동하는 방법에 대한 자세한 내용 &lt;a href=&quot;perlfunc#lc&quot;&gt;은 perlfunc의 &quot;lc&quot;를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="94fe5caf324bcb104f1845ec70df5cb17cd45071" translate="yes" xml:space="preserve">
          <source>Under Cygwin, $^E is the same as $!. When using &lt;a href=&quot;http://search.cpan.org/perldoc/Win32&quot;&gt;Win32 API Functions&lt;/a&gt;, use &lt;code&gt;Win32::GetLastError()&lt;/code&gt; to get the last Windows error.</source>
          <target state="translated">Cygwin에서 $ ^ E는 $!와 동일합니다. 사용하는 경우 &lt;a href=&quot;http://search.cpan.org/perldoc/Win32&quot;&gt;는 Win32 API 함수를&lt;/a&gt; 사용 &lt;code&gt;Win32::GetLastError()&lt;/code&gt; 마지막으로 Windows 오류를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bf1bd7b89a19b28d20d4df86f951acf9fc393dd7" translate="yes" xml:space="preserve">
          <source>Under Cygwin, $^E is the same as $!. When using &lt;a href=&quot;win32&quot;&gt;Win32 API Functions&lt;/a&gt;, use &lt;code&gt;Win32::GetLastError()&lt;/code&gt; to get the last Windows error.</source>
          <target state="translated">Cygwin에서 $ ^ E는 $!와 동일합니다. 사용하는 경우 &lt;a href=&quot;win32&quot;&gt;는 Win32 API 함수를&lt;/a&gt; 사용 &lt;code&gt;Win32::GetLastError()&lt;/code&gt; 마지막으로 Windows 오류를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="08490cc0df2a509f16cddc3cf2a4ae40e649767f" translate="yes" xml:space="preserve">
          <source>Under EBCDIC platforms, &lt;code&gt;e2char($n)&lt;/code&gt; may not always be the same as &lt;code&gt;&lt;a href=&quot;../functions/chr&quot;&gt;chr(e2charnum($n))&lt;/a&gt;&lt;/code&gt;, and ditto for &lt;code&gt;$Name2character{$name}&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../functions/chr&quot;&gt;chr($Name2character_number{$name})&lt;/a&gt;&lt;/code&gt;, because the strings are returned as native, and the numbers are returned as Unicode. However, for Perls starting with v5.8, &lt;code&gt;e2char($n)&lt;/code&gt; is the same as &lt;code&gt;&lt;a href=&quot;../functions/chr&quot;&gt;chr(utf8::unicode_to_native(e2charnum($n)))&lt;/a&gt;&lt;/code&gt;, and ditto for &lt;code&gt;$Name2character{$name}&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../functions/chr&quot;&gt;chr(utf8::unicode_to_native($Name2character_number{$name}))&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">EBCDIC 플랫폼에서 &lt;code&gt;e2char($n)&lt;/code&gt; 항상 동일하지 않을 수 있습니다 &lt;code&gt;&lt;a href=&quot;../functions/chr&quot;&gt;chr(e2charnum($n))&lt;/a&gt;&lt;/code&gt; 에 대한, 그리고 저두 &lt;code&gt;$Name2character{$name}&lt;/code&gt; 과 &lt;code&gt;&lt;a href=&quot;../functions/chr&quot;&gt;chr($Name2character_number{$name})&lt;/a&gt;&lt;/code&gt; , 문자열이 반환되기 때문에 기본으로, 숫자는 유니 코드로 반환됩니다. 그러나 v5.8로 시작하는 Perls의 경우 &lt;code&gt;e2char($n)&lt;/code&gt; 은 &lt;code&gt;&lt;a href=&quot;../functions/chr&quot;&gt;chr(utf8::unicode_to_native(e2charnum($n)))&lt;/a&gt;&lt;/code&gt; 과 동일하며 &lt;code&gt;$Name2character{$name}&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../functions/chr&quot;&gt;chr(utf8::unicode_to_native($Name2character_number{$name}))&lt;/a&gt;&lt;/code&gt; 대한 ditto ($ Name2character_number {$ name})) .</target>
        </trans-unit>
        <trans-unit id="24801e56e20625b1799dc0d5ebdcc72e9b0dcde9" translate="yes" xml:space="preserve">
          <source>Under EBCDIC platforms, &lt;code&gt;e2char($n)&lt;/code&gt; may not always be the same as &lt;code&gt;chr(e2charnum($n))&lt;/code&gt;, and ditto for &lt;code&gt;$Name2character{$name}&lt;/code&gt; and &lt;code&gt;chr($Name2character_number{$name})&lt;/code&gt;, because the strings are returned as native, and the numbers are returned as Unicode. However, for Perls starting with v5.8, &lt;code&gt;e2char($n)&lt;/code&gt; is the same as &lt;code&gt;chr(utf8::unicode_to_native(e2charnum($n)))&lt;/code&gt;, and ditto for &lt;code&gt;$Name2character{$name}&lt;/code&gt; and &lt;code&gt;chr(utf8::unicode_to_native($Name2character_number{$name}))&lt;/code&gt;.</source>
          <target state="translated">EBCDIC 플랫폼에서 &lt;code&gt;e2char($n)&lt;/code&gt; 은 항상 &lt;code&gt;chr(e2charnum($n))&lt;/code&gt; 과 &lt;code&gt;$Name2character{$name}&lt;/code&gt; 있으며 $ Name2character {$ name} 및 &lt;code&gt;chr($Name2character_number{$name})&lt;/code&gt; 경우도 마찬가지입니다 . 문자열이 반환되기 때문입니다. 네이티브로, 숫자는 유니 코드로 반환됩니다. 그러나 v5.8로 시작하는 Perls의 경우 &lt;code&gt;e2char($n)&lt;/code&gt; 은 &lt;code&gt;chr(utf8::unicode_to_native(e2charnum($n)))&lt;/code&gt; 과 동일하며 &lt;code&gt;$Name2character{$name}&lt;/code&gt; 및 &lt;code&gt;chr(utf8::unicode_to_native($Name2character_number{$name}))&lt;/code&gt; 마찬가지입니다. ($ Name2character_number {$ 이름})) .</target>
        </trans-unit>
        <trans-unit id="1fc50122941a9cec999fb031245122855f9d5976" translate="yes" xml:space="preserve">
          <source>Under NFS this will use the time of the NFS server, not the time of the local machine. If there is a time synchronization problem, the NFS server and local machine will have different times. The Unix &lt;a href=&quot;http://man.he.net/man1/touch&quot;&gt;touch(1)&lt;/a&gt; command will in fact normally use this form instead of the one shown in the first example.</source>
          <target state="translated">NFS에서는 로컬 시스템의 시간이 아닌 NFS 서버의 시간을 사용합니다. 시간 동기화 문제가있는 경우 NFS 서버와 로컬 시스템의 시간이 다릅니다. Unix &lt;a href=&quot;http://man.he.net/man1/touch&quot;&gt;touch (1)&lt;/a&gt; 명령은 실제로 일반적으로 첫 번째 예제에 표시된 형식 대신이 형식을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="18254acc65d18b7ddbf875f7bfc47db0d75ce39a" translate="yes" xml:space="preserve">
          <source>Under NFS this will use the time of the NFS server, not the time of the local machine. If there is a time synchronization problem, the NFS server and local machine will have different times. The Unix touch(1) command will in fact normally use this form instead of the one shown in the first example.</source>
          <target state="translated">NFS에서는 로컬 시스템의 시간이 아닌 NFS 서버의 시간을 사용합니다. 시간 동기화 문제가있는 경우 NFS 서버와 로컬 시스템의 시간이 다릅니다. Unix touch (1) 명령은 실제로 첫 번째 예제에 표시된 형식 대신이 형식을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="f3924a4fe96e1e85710f171a0842dfde3423eb52" translate="yes" xml:space="preserve">
          <source>Under OS/2, &lt;code&gt;$^E&lt;/code&gt; is set to the error code of the last call to OS/2 API either via CRT, or directly from perl.</source>
          <target state="translated">OS / 2에서 &lt;code&gt;$^E&lt;/code&gt; 는 CRT를 통해 또는 perl에서 직접 OS / 2 API에 대한 마지막 호출의 오류 코드로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="19dcdc34494760727e410f497dbed91a176d6c5e" translate="yes" xml:space="preserve">
          <source>Under Perl 5.10 only, using a string eval when &lt;code&gt;autodie&lt;/code&gt; is in effect can cause the autodie behaviour to leak into the surrounding scope. This can be worked around by using a &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; autodie&lt;/code&gt; at the end of the scope to explicitly remove autodie's effects, or by avoiding the use of string eval.</source>
          <target state="translated">Perl 5.10에서만 &lt;code&gt;autodie&lt;/code&gt; 가 유효 할 때 문자열 eval을 사용 하면 autodie 동작이 주변 범위로 누출 될 수 있습니다. 스코프 끝에 &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; autodie&lt;/code&gt; 를 사용 &lt;a href=&quot;functions/no&quot;&gt;하지 않고&lt;/a&gt; autodie의 효과를 명시 적으로 제거하거나 string eval을 사용하지 않아도됩니다.</target>
        </trans-unit>
        <trans-unit id="141394caeda9c5ad5a22f24134bab7c210cd57fb" translate="yes" xml:space="preserve">
          <source>Under Perl 5.10 only, using a string eval when &lt;code&gt;autodie&lt;/code&gt; is in effect can cause the autodie behaviour to leak into the surrounding scope. This can be worked around by using a &lt;code&gt;no autodie&lt;/code&gt; at the end of the scope to explicitly remove autodie's effects, or by avoiding the use of string eval.</source>
          <target state="translated">Perl 5.10에서만 &lt;code&gt;autodie&lt;/code&gt; 가 작동 중일 때 string eval을 사용 하면 autodie 동작이 주변 범위로 누출 될 수 있습니다. 이 문제는 스코프 끝에 &lt;code&gt;no autodie&lt;/code&gt; 를 사용하여 명시 적으로 autodie의 효과를 제거하거나 string eval의 사용을 피함으로써 해결할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1824d549ede70b3449b6bc94fa47857184a96f9f" translate="yes" xml:space="preserve">
          <source>Under Perl 5.18 and later, SvREADONLY only applies to read-only variables, and, under 5.20, copy-on-write scalars can also be read-only, so the above check is incorrect. You just want:</source>
          <target state="translated">Perl 5.18 이상에서 SvREADONLY는 읽기 전용 변수에만 적용되며 5.20에서는 쓰기시 복사 스칼라도 읽기 전용 일 수 있으므로 위의 점검이 올바르지 않습니다. 당신은 단지 원합니다 :</target>
        </trans-unit>
        <trans-unit id="8d107d150b9abd6d04d1d29a993fa6ea829d9209" translate="yes" xml:space="preserve">
          <source>Under Perl 5.8 only, &lt;code&gt;autodie&lt;/code&gt;</source>
          <target state="translated">Perl 5.8에서만 &lt;code&gt;autodie&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e28f5c058f0915564622ac46660d6f84c05ab318" translate="yes" xml:space="preserve">
          <source>Under Perl 5.8, the &lt;code&gt;given/when&lt;/code&gt; structure is not available, so the following structure may be used:</source>
          <target state="translated">Perl 5.8에서는 &lt;code&gt;given/when&lt;/code&gt; 구조를 사용할 수 없으므로 다음 구조를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ef993909ab6a97a91baf7e650bc7ce46f77c2516" translate="yes" xml:space="preserve">
          <source>Under QNX 6.2.0 there are still a few tests which fail. See below and hints/qnx.sh for more information.</source>
          <target state="translated">QNX 6.2.0에서는 여전히 실패한 몇 가지 테스트가 있습니다. 자세한 내용은 아래 및 힌트 /qnx.sh를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="66b5ec5cf7fb5924aee8dffa63eba13ccd60d52e" translate="yes" xml:space="preserve">
          <source>Under Unicode rules, there are a few case-insensitive matches that cross the 255/256 boundary. Except for UTF-8 locales in Perls v5.20 and later, these are disallowed under &lt;code&gt;/l&lt;/code&gt; . For example, 0xFF (on ASCII platforms) does not caselessly match the character at 0x178, &lt;code&gt;LATIN
CAPITAL LETTER Y WITH DIAERESIS&lt;/code&gt; , because 0xFF may not be &lt;code&gt;LATIN SMALL
LETTER Y WITH DIAERESIS&lt;/code&gt; in the current locale, and Perl has no way of knowing if that character even exists in the locale, much less what code point it is.</source>
          <target state="translated">유니 코드 규칙에 따라 255/256 경계를 넘는 대소 문자를 구분하지 않는 일치 항목이 있습니다. Perls v5.20 이상의 UTF-8 로켈을 제외하고는 &lt;code&gt;/l&lt;/code&gt; 에서 허용되지 않습니다 . 예를 들어, (ASCII 플랫폼)를 0xFF는 caselessly 0x178에있는 문자와 일치하지 않는, &lt;code&gt;LATIN CAPITAL LETTER Y WITH DIAERESIS&lt;/code&gt; , 0xFF로이되지 않을 수 있기 때문에 &lt;code&gt;LATIN SMALL LETTER Y WITH DIAERESIS&lt;/code&gt; 현재 로케일에서, 펄는 경우 알 수있는 방법이 있습니다 문자는 로케일에도 존재하며 코드 포인트가 훨씬 적습니다.</target>
        </trans-unit>
        <trans-unit id="a229f317f16db87320c5e41b43cc77785168f869" translate="yes" xml:space="preserve">
          <source>Under Unicode rules, there are a few case-insensitive matches that cross the 255/256 boundary. Except for UTF-8 locales in Perls v5.20 and later, these are disallowed under &lt;code&gt;/l&lt;/code&gt;. For example, 0xFF (on ASCII platforms) does not caselessly match the character at 0x178, &lt;code&gt;LATIN CAPITAL LETTER Y WITH DIAERESIS&lt;/code&gt;, because 0xFF may not be &lt;code&gt;LATIN SMALL LETTER Y WITH DIAERESIS&lt;/code&gt; in the current locale, and Perl has no way of knowing if that character even exists in the locale, much less what code point it is.</source>
          <target state="translated">유니 코드 규칙에는 255/256 경계를 넘는 대소 문자를 구분하지 않는 몇 가지 일치 항목이 있습니다. Perls v5.20 이상의 UTF-8 로케일을 제외하고는 &lt;code&gt;/l&lt;/code&gt; 아래에서 허용되지 않습니다 . 예를 들어, 0xFF (ASCII 플랫폼에서)는 0x178, &lt;code&gt;LATIN CAPITAL LETTER Y WITH DIAERESIS&lt;/code&gt; 의 문자와 대소 문자없이 일치하지 않습니다. 0xFF는 현재 로케일에서 &lt;code&gt;LATIN SMALL LETTER Y WITH DIAERESIS&lt;/code&gt; 가 아닐 수 있으며 Perl은 그 여부를 알 수 없습니다. 문자는 로케일에도 존재하지만 코드 포인트가 훨씬 적습니다.</target>
        </trans-unit>
        <trans-unit id="666da3b151d79c3526ad94c74b4a7b5272bc4ad7" translate="yes" xml:space="preserve">
          <source>Under Unicode rules, these upper-Latin1 characters are interpreted as Unicode code points, which means they have the same semantics as Latin-1 (ISO-8859-1) and C1 controls.</source>
          <target state="translated">유니 코드 규칙에서이 상위 라틴 문자는 유니 코드 코드 포인트로 해석되므로 Latin-1 (ISO-8859-1) 및 C1 컨트롤과 동일한 의미를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="15d191765263aacd2b7fcad31e78fb6cf886a85b" translate="yes" xml:space="preserve">
          <source>Under VMS this reflects the actual VMS exit status; i.e. it is the same as &lt;code&gt;$?&lt;/code&gt; when the pragma &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; vmsish 'status'&lt;/code&gt; is in effect.</source>
          <target state="translated">VMS에서는 실제 VMS 종료 상태를 반영합니다. 즉, &lt;code&gt;$?&lt;/code&gt; 와 동일 합니까? pragma &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; vmsish 'status'&lt;/code&gt; 가 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="c6482226ed3d921882dbfe662280c6e28493cbae" translate="yes" xml:space="preserve">
          <source>Under VMS this reflects the actual VMS exit status; i.e. it is the same as &lt;code&gt;$?&lt;/code&gt; when the pragma &lt;code&gt;use vmsish 'status'&lt;/code&gt; is in effect.</source>
          <target state="translated">VMS에서는 실제 VMS 종료 상태를 반영합니다. 즉 &lt;code&gt;$?&lt;/code&gt; 와 동일 합니까? pragma가 &lt;code&gt;use vmsish 'status'&lt;/code&gt; 때 '상태' 가 유효합니다.</target>
        </trans-unit>
        <trans-unit id="737324e93129014d33d4923a010ebe747aa167f7" translate="yes" xml:space="preserve">
          <source>Under VMS, &lt;code&gt;$^E&lt;/code&gt; provides the VMS status value from the last system error. This is more specific information about the last system error than that provided by &lt;code&gt;$!&lt;/code&gt; . This is particularly important when &lt;code&gt;$!&lt;/code&gt; is set to &lt;b&gt;EVMSERR&lt;/b&gt;.</source>
          <target state="translated">VMS에서 &lt;code&gt;$^E&lt;/code&gt; 는 마지막 시스템 오류의 VMS 상태 값을 제공합니다. &lt;code&gt;$!&lt;/code&gt; 에서 제공 한 것보다 마지막 시스템 오류에 대한보다 구체적인 정보입니다 . . &lt;code&gt;$!&lt;/code&gt; 때 특히 중요합니다 ! &lt;b&gt;EVMSERR&lt;/b&gt; 로 설정되었습니다 .</target>
        </trans-unit>
        <trans-unit id="76dfcc4ab4ed83661a267ed44726342ca382d02d" translate="yes" xml:space="preserve">
          <source>Under VMS, &lt;code&gt;$^E&lt;/code&gt; provides the VMS status value from the last system error. This is more specific information about the last system error than that provided by &lt;code&gt;$!&lt;/code&gt;. This is particularly important when &lt;code&gt;$!&lt;/code&gt; is set to &lt;b&gt;EVMSERR&lt;/b&gt;.</source>
          <target state="translated">VMS에서 &lt;code&gt;$^E&lt;/code&gt; 는 마지막 시스템 오류의 VMS 상태 값을 제공합니다. 이것은 &lt;code&gt;$!&lt;/code&gt; 에서 제공 한 것보다 마지막 시스템 오류에 대한보다 구체적인 정보입니다 . . 이것은 &lt;code&gt;$!&lt;/code&gt; &lt;b&gt;EVMSERR&lt;/b&gt; 로 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="50b3f98ca540bd0c81d34840956f838255c71318" translate="yes" xml:space="preserve">
          <source>Under VMS, if there is no directory information in the $path, then the current default device and directory is used.</source>
          <target state="translated">VMS에서 $ path에 디렉토리 정보가 없으면 현재 기본 장치 및 디렉토리가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="3aaae4cddb5ecef27b2c450c8cc4b4b174c7016f" translate="yes" xml:space="preserve">
          <source>Under VMS, the pragma &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; vmsish 'status'&lt;/code&gt; makes &lt;code&gt;$?&lt;/code&gt; reflect the actual VMS exit status, instead of the default emulation of POSIX status; see &lt;a href=&quot;perlvms#%24%3f&quot;&gt;$? in perlvms&lt;/a&gt; for details.</source>
          <target state="translated">VMS에서 pragma &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; vmsish 'status'&lt;/code&gt; 는 &lt;code&gt;$?&lt;/code&gt; POSIX 상태의 기본 에뮬레이션 대신 실제 VMS 종료 상태를 반영합니다. &lt;a href=&quot;perlvms#%24%3f&quot;&gt;$?&lt;/a&gt; 참조 자세한 내용 은 perlvms 에서.</target>
        </trans-unit>
        <trans-unit id="9fe540ff184660416cab5f62ce2d7a86b31b31b4" translate="yes" xml:space="preserve">
          <source>Under VMS, the pragma &lt;code&gt;use vmsish 'status'&lt;/code&gt; makes &lt;code&gt;$?&lt;/code&gt; reflect the actual VMS exit status, instead of the default emulation of POSIX status; see &lt;a href=&quot;perlvms#%24%3F&quot;&gt;&quot;$?&quot; in perlvms&lt;/a&gt; for details.</source>
          <target state="translated">VMS에서 pragma &lt;code&gt;use vmsish 'status'&lt;/code&gt; 사용하여 &lt;code&gt;$?&lt;/code&gt; POSIX 상태의 기본 에뮬레이션 대신 실제 VMS 종료 상태를 반영합니다. &lt;a href=&quot;perlvms#%24%3F&quot;&gt;&quot;$?&quot;를&lt;/a&gt; 참조하십시오. 자세한 내용 은 perlvms 에서 확인하세요.</target>
        </trans-unit>
        <trans-unit id="711e7c0754f84b5e7bda634825aa4039a4a70c54" translate="yes" xml:space="preserve">
          <source>Under Win32's &quot;test&quot; target you may use the TEST_SWITCHES and TEST_FILES environment variables to control the behaviour of</source>
          <target state="translated">Win32의 &quot;test&quot;대상에서 TEST_SWITCHES 및 TEST_FILES 환경 변수를 사용하여 다음 동작을 제어 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="53c6d0758bf54648c779157ed9111dd650df9efe" translate="yes" xml:space="preserve">
          <source>Under Win32, &lt;code&gt;$^E&lt;/code&gt; always returns the last error information reported by the Win32 call &lt;code&gt;GetLastError()&lt;/code&gt; which describes the last error from within the Win32 API. Most Win32-specific code will report errors via &lt;code&gt;$^E&lt;/code&gt; . ANSI C and Unix-like calls set &lt;code&gt;errno&lt;/code&gt; and so most portable Perl code will report errors via &lt;code&gt;$!&lt;/code&gt; .</source>
          <target state="translated">Win32에서 &lt;code&gt;$^E&lt;/code&gt; 항상 Win32 API 내에서 마지막 오류를 설명하는 Win32 호출 &lt;code&gt;GetLastError()&lt;/code&gt; 의해보고 된 마지막 오류 정보를 반환합니다 . 대부분의 Win32 특정 코드는 &lt;code&gt;$^E&lt;/code&gt; 를 통해 오류를보고합니다 . ANSI C 및 Unix와 유사한 호출은 &lt;code&gt;errno&lt;/code&gt; 를 설정 하므로 대부분의 이식 가능한 Perl 코드는 &lt;code&gt;$!&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9e14095c735f4241ba86445b598120697973ed27" translate="yes" xml:space="preserve">
          <source>Under Win32, &lt;code&gt;$^E&lt;/code&gt; always returns the last error information reported by the Win32 call &lt;code&gt;GetLastError()&lt;/code&gt; which describes the last error from within the Win32 API. Most Win32-specific code will report errors via &lt;code&gt;$^E&lt;/code&gt;. ANSI C and Unix-like calls set &lt;code&gt;errno&lt;/code&gt; and so most portable Perl code will report errors via &lt;code&gt;$!&lt;/code&gt;.</source>
          <target state="translated">Win32에서 &lt;code&gt;$^E&lt;/code&gt; 항상 Win32 API 내에서 마지막 오류를 설명하는 Win32 호출 &lt;code&gt;GetLastError()&lt;/code&gt; 의해보고 된 마지막 오류 정보를 반환합니다 . 대부분의 Win32 관련 코드는 &lt;code&gt;$^E&lt;/code&gt; 를 통해 오류를보고합니다 . ANSI C 및 Unix와 유사한 호출은 &lt;code&gt;errno&lt;/code&gt; 를 설정 하므로 대부분의 이식 가능한 Perl 코드는 &lt;code&gt;$!&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9f5b168779b6e4455afcf5fa22f2ddb16d807c4c" translate="yes" xml:space="preserve">
          <source>Under Windows NT, &lt;code&gt;$sPath&lt;/code&gt; can start with &lt;code&gt;&quot;//?/&quot;&lt;/code&gt; to allow the use of paths longer than &lt;code&gt;MAX_PATH&lt;/code&gt; [for UNC paths, replace the leading &lt;code&gt;&quot;//&quot;&lt;/code&gt; with &lt;code&gt;&quot;//?/UNC/&quot;&lt;/code&gt;, as in &lt;code&gt;&quot;//?/UNC/Server/Share/Dir/File.Ext&quot;&lt;/code&gt;].</source>
          <target state="translated">윈도우 NT에서 &lt;code&gt;$sPath&lt;/code&gt; 시작할 수 &lt;code&gt;&quot;//?/&quot;&lt;/code&gt; 이상 경로를 사용할 수 있도록 &lt;code&gt;MAX_PATH&lt;/code&gt; [UNC 경로에 대한 선도적 교체 &lt;code&gt;&quot;//&quot;&lt;/code&gt; 를 함께 &lt;code&gt;&quot;//?/UNC/&quot;&lt;/code&gt; 같이 &lt;code&gt;&quot;//?/UNC/Server/Share/Dir/File.Ext&quot;&lt;/code&gt; ].</target>
        </trans-unit>
        <trans-unit id="445377f279bee790252626a9efe4c710c5fb31ec" translate="yes" xml:space="preserve">
          <source>Under Windows and VMS the option file is named</source>
          <target state="translated">Windows 및 VMS에서 옵션 파일 이름은</target>
        </trans-unit>
        <trans-unit id="991af3b0df6455b17cae9de8484aa49771ee9333" translate="yes" xml:space="preserve">
          <source>Under a few operating systems, &lt;code&gt;$^E&lt;/code&gt; may contain a more verbose error indicator, such as in this case, &quot;CDROM tray not closed.&quot; Systems that do not support extended error messages leave &lt;code&gt;$^E&lt;/code&gt; the same as &lt;code&gt;$!&lt;/code&gt; .</source>
          <target state="translated">일부 운영 체제에서는 &lt;code&gt;$^E&lt;/code&gt; 에 &quot;CDROM tray not closed&quot;와 같은보다 자세한 오류 표시기가있을 수 있습니다. 확장 오류 메시지를 지원하지 않는 시스템은 &lt;code&gt;$^E&lt;/code&gt; 를 &lt;code&gt;$!&lt;/code&gt; 와 동일하게 둡니다 . .</target>
        </trans-unit>
        <trans-unit id="9cba04bbbcd7e6b0b58cb405fffa7701c6b86b43" translate="yes" xml:space="preserve">
          <source>Under a few operating systems, &lt;code&gt;$^E&lt;/code&gt; may contain a more verbose error indicator, such as in this case, &quot;CDROM tray not closed.&quot; Systems that do not support extended error messages leave &lt;code&gt;$^E&lt;/code&gt; the same as &lt;code&gt;$!&lt;/code&gt;.</source>
          <target state="translated">일부 운영 체제에서 &lt;code&gt;$^E&lt;/code&gt; 에는이 경우 &quot;CDROM 트레이가 닫혀 있지 않음&quot;과 같은보다 자세한 오류 표시기가 포함될 수 있습니다. 확장 오류 메시지를 지원하지 않는 시스템은 &lt;code&gt;$^E&lt;/code&gt; 를 &lt;code&gt;$!&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b8188d9bfb2c028e78df0c34f466ab12923ca95e" translate="yes" xml:space="preserve">
          <source>Under bignum (or bigint or bigrat), Perl will &quot;upgrade&quot; the numbers appropriately. This means that:</source>
          <target state="translated">bignum (또는 bigint 또는 bigrat)에서 Perl은 숫자를 적절하게 &quot;업그레이드&quot;합니다. 이것은 다음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="936167913e1d36052a60fe747af5e2acfb71f327" translate="yes" xml:space="preserve">
          <source>Under case-sensitive matching, these both match the same code points as &lt;code&gt;\p{General Category=Titlecase_Letter}&lt;/code&gt; (&lt;code&gt;\p{gc=&lt;a href=&quot;functions/lt&quot;&gt;lt&lt;/a&gt;}&lt;/code&gt; ). The difference is that under &lt;code&gt;/i&lt;/code&gt; caseless matching, these match the same as &lt;code&gt;\p{Cased}&lt;/code&gt; , whereas &lt;code&gt;\p{gc=&lt;a href=&quot;functions/lt&quot;&gt;lt&lt;/a&gt;}&lt;/code&gt; matches &lt;code&gt;\p{Cased_Letter&lt;/code&gt; ).</source>
          <target state="translated">대소 문자를 구분하여 일치하는 경우 둘 다 &lt;code&gt;\p{General Category=Titlecase_Letter}&lt;/code&gt; ( &lt;code&gt;\p{gc=&lt;a href=&quot;functions/lt&quot;&gt;lt&lt;/a&gt;}&lt;/code&gt; ) 와 동일한 코드 포인트와 일치합니다 . 차이점은 아래 &lt;code&gt;/i&lt;/code&gt; 대소 문자 구별 매칭 같은 이러한 매치 &lt;code&gt;\p{Cased}&lt;/code&gt; 반면 &lt;code&gt;\p{gc=&lt;a href=&quot;functions/lt&quot;&gt;lt&lt;/a&gt;}&lt;/code&gt; 일치 &lt;code&gt;\p{Cased_Letter&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="16d7375a7fe76f99800381f8b36c3f7a2c76e668" translate="yes" xml:space="preserve">
          <source>Under case-sensitive matching, these both match the same code points as &lt;code&gt;\p{General Category=Titlecase_Letter}&lt;/code&gt; (&lt;code&gt;\p{gc=lt}&lt;/code&gt;). The difference is that under &lt;code&gt;/i&lt;/code&gt; caseless matching, these match the same as &lt;code&gt;\p{Cased}&lt;/code&gt;, whereas &lt;code&gt;\p{gc=lt}&lt;/code&gt; matches &lt;code&gt;\p{Cased_Letter&lt;/code&gt;).</source>
          <target state="translated">대소 문자 구분 일치에서는 둘 다 &lt;code&gt;\p{General Category=Titlecase_Letter}&lt;/code&gt; ( &lt;code&gt;\p{gc=lt}&lt;/code&gt; ) 와 동일한 코드 포인트와 일치합니다 . 차이점은 아래 &lt;code&gt;/i&lt;/code&gt; 대소 문자 구별 매칭 같은 이러한 매치 &lt;code&gt;\p{Cased}&lt;/code&gt; 반면 &lt;code&gt;\p{gc=lt}&lt;/code&gt; 일치 &lt;code&gt;\p{Cased_Letter&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="58098e551f5eebaa46d0d3a19d00f14ced3f4d46" translate="yes" xml:space="preserve">
          <source>Under ithreads the optree is read only. If you want to enforce this, to check for write accesses from buggy code, compile with &lt;code&gt;-Accflags=-DPERL_DEBUG_READONLY_OPS&lt;/code&gt; to enable code that allocates op memory via &lt;code&gt;mmap&lt;/code&gt; , and sets it read-only when it is attached to a subroutine. Any write access to an op results in a &lt;code&gt;SIGBUS&lt;/code&gt; and abort.</source>
          <target state="translated">ithreads에서 optree는 읽기 전용입니다. 이를 적용하려면 버그가있는 코드의 쓰기 액세스를 확인하려면 &lt;code&gt;-Accflags=-DPERL_DEBUG_READONLY_OPS&lt;/code&gt; 로 컴파일하여 &lt;code&gt;mmap&lt;/code&gt; 를 통해 op 메모리를 할당 하고 서브 루틴에 연결될 때 읽기 전용으로 설정하는 코드를 활성화하십시오 . op에 대한 쓰기 권한이 있으면 &lt;code&gt;SIGBUS&lt;/code&gt; 가 중단되고 중단됩니다.</target>
        </trans-unit>
        <trans-unit id="21eb1ae9bcc07ffd150bd4cea8dca0ae9a233a36" translate="yes" xml:space="preserve">
          <source>Under ithreads the optree is read only. If you want to enforce this, to check for write accesses from buggy code, compile with &lt;code&gt;-Accflags=-DPERL_DEBUG_READONLY_OPS&lt;/code&gt; to enable code that allocates op memory via &lt;code&gt;mmap&lt;/code&gt;, and sets it read-only when it is attached to a subroutine. Any write access to an op results in a &lt;code&gt;SIGBUS&lt;/code&gt; and abort.</source>
          <target state="translated">ithreads에서 optree는 읽기 전용입니다. 이를 적용하려면 버그가있는 코드에서 쓰기 액세스를 확인하려면 &lt;code&gt;-Accflags=-DPERL_DEBUG_READONLY_OPS&lt;/code&gt; 로 컴파일하여 &lt;code&gt;mmap&lt;/code&gt; 을 통해 연산 메모리를 할당하는 코드를 활성화 하고 서브 루틴에 연결될 때 읽기 전용으로 설정합니다. op에 대한 모든 쓰기 액세스는 &lt;code&gt;SIGBUS&lt;/code&gt; 를 발생 시키고 중단됩니다.</target>
        </trans-unit>
        <trans-unit id="9d556cba6d79170127d0f04c67e73cd273a0ab83" translate="yes" xml:space="preserve">
          <source>Under normal circumstances, the CV forgets about its slab (decrementing the reference count) when the root is attached. So the slab reference counting that happens when ops are freed takes care of freeing the slab. In some cases, the CV is told to forget about the slab (&lt;code&gt;cv_forget_slab&lt;/code&gt;) precisely so that the ops can survive after the CV is done away with.</source>
          <target state="translated">정상적인 상황에서 CV는 루트가 연결될 때 슬래브를 잊어 버립니다 (참조 카운트 감소). 따라서 ops가 해제 될 때 발생하는 slab reference counting이 slab 해제를 처리합니다. 어떤 경우에는 CV가 종료 된 후에도 작업이 살아남을 수 있도록 슬래브 ( &lt;code&gt;cv_forget_slab&lt;/code&gt; )를 정확히 잊어 버리도록 CV에 지시를 받습니다 .</target>
        </trans-unit>
        <trans-unit id="41c5c0dce73b6a45e16e6c80203f13488d40f1dd" translate="yes" xml:space="preserve">
          <source>Under the &quot;switch&quot; feature, Perl gains the experimental keywords &lt;code&gt;given&lt;/code&gt; , &lt;code&gt;when&lt;/code&gt; , &lt;code&gt;default&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;break&lt;/code&gt; . Starting from Perl 5.16, one can prefix the switch keywords with &lt;code&gt;CORE::&lt;/code&gt; to access the feature without a &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature&lt;/code&gt; statement. The keywords &lt;code&gt;given&lt;/code&gt; and &lt;code&gt;when&lt;/code&gt; are analogous to &lt;code&gt;switch&lt;/code&gt; and &lt;code&gt;case&lt;/code&gt; in other languages, so the code in the previous section could be rewritten as</source>
          <target state="translated">&quot;스위치&quot;기능에서 Perl은 &lt;code&gt;given&lt;/code&gt; , &lt;code&gt;when&lt;/code&gt; , &lt;code&gt;default&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;break&lt;/code&gt; 실험 키워드를 얻 습니다 . 펄 5.16에서 시작, 하나와 스위치 키워드를 앞에 수 &lt;code&gt;CORE::&lt;/code&gt; 없이 기능에 액세스 할 수 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature&lt;/code&gt; 문. 키워드는 &lt;code&gt;given&lt;/code&gt; 과 &lt;code&gt;when&lt;/code&gt; 와 유사 &lt;code&gt;switch&lt;/code&gt; 및 &lt;code&gt;case&lt;/code&gt; , 다른 언어 이전 섹션의 코드는 다음과 같이 재 작성 될 수 있도록</target>
        </trans-unit>
        <trans-unit id="429aec7265e307e4dfd4174d6cfde74d06bbb3ef" translate="yes" xml:space="preserve">
          <source>Under the &quot;switch&quot; feature, Perl gains the experimental keywords &lt;code&gt;given&lt;/code&gt;, &lt;code&gt;when&lt;/code&gt;, &lt;code&gt;default&lt;/code&gt;, &lt;code&gt;continue&lt;/code&gt;, and &lt;code&gt;break&lt;/code&gt;. Starting from Perl 5.16, one can prefix the switch keywords with &lt;code&gt;CORE::&lt;/code&gt; to access the feature without a &lt;code&gt;use feature&lt;/code&gt; statement. The keywords &lt;code&gt;given&lt;/code&gt; and &lt;code&gt;when&lt;/code&gt; are analogous to &lt;code&gt;switch&lt;/code&gt; and &lt;code&gt;case&lt;/code&gt; in other languages -- though &lt;code&gt;continue&lt;/code&gt; is not -- so the code in the previous section could be rewritten as</source>
          <target state="translated">&quot;전환&quot;기능에서 Perl은 &lt;code&gt;given&lt;/code&gt; 실험 키워드 , &lt;code&gt;when&lt;/code&gt; , &lt;code&gt;default&lt;/code&gt; , &lt;code&gt;continue&lt;/code&gt; 및 &lt;code&gt;break&lt;/code&gt; 를 얻 습니다 . Perl 5.16부터는 &lt;code&gt;use feature&lt;/code&gt; 문 없이 기능에 액세스하기 위해 스위치 키워드 앞에 &lt;code&gt;CORE::&lt;/code&gt; 를 붙일 수 있습니다 . &lt;code&gt;given&lt;/code&gt; 키워드 와 &lt;code&gt;when&lt;/code&gt; 는 다른 언어의 &lt;code&gt;switch&lt;/code&gt; 및 &lt;code&gt;case&lt;/code&gt; 와 유사합니다 ( &lt;code&gt;continue&lt;/code&gt; 은 아니지만). 따라서 이전 섹션의 코드를 다음과 같이 다시 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f764edcb644a2a893a6fefa3a757e31fb881f9a7" translate="yes" xml:space="preserve">
          <source>Under the &lt;a href=&quot;feature#The-%27unicode_eval%27-and-%27evalbytes%27-features&quot;&gt;&lt;code&gt;&quot;unicode_eval&quot;&lt;/code&gt; feature&lt;/a&gt;</source>
          <target state="translated">세 이하 &lt;a href=&quot;feature#The-%27unicode_eval%27-and-%27evalbytes%27-features&quot;&gt; &lt;code&gt;&quot;unicode_eval&quot;&lt;/code&gt; 기능&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3dcedc6c33e9a6ba46a7f82a03dd4b7c259f61b3" translate="yes" xml:space="preserve">
          <source>Under the &lt;code&gt;unicode_eval&lt;/code&gt; feature, Perl's &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; function, when passed a string, will evaluate it as a string of characters, ignoring any &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; declarations. &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; exists to declare the encoding of the script, which only makes sense for a stream of bytes, not a string of characters. Source filters are forbidden, as they also really only make sense on strings of bytes. Any attempt to activate a source filter will result in an error.</source>
          <target state="translated">언더 &lt;code&gt;unicode_eval&lt;/code&gt; 기능, 펄의 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 문자열을 통과 할 때 기능은 어떤 무시하고, 문자열로 평가합니다 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; 선언을. &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; &lt;a href=&quot;functions/use&quot;&gt;사용&lt;/a&gt; 하면 스크립트의 인코딩을 선언 할 수 있습니다.이 인코딩은 문자열이 아닌 바이트 스트림에만 적합합니다. 소스 필터는 바이트 문자열에만 적용되므로 금지됩니다. 소스 필터를 활성화하려고하면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="3ed7e8de69faa9a39e5b719579b31e326e5e1ba3" translate="yes" xml:space="preserve">
          <source>Under the Mac, it depends which environment you are using. The MacPerl shell, or MPW, is much like Unix shells in its support for several quoting variants, except that it makes free use of the Mac's non-ASCII characters as control characters.</source>
          <target state="translated">Mac에서는 사용중인 환경에 따라 다릅니다. MacPerl 쉘 (MPW)은 Mac의 비 ASCII 문자를 제어 문자로 자유롭게 사용한다는 점을 제외하고는 몇 가지 인용 변형을 지원한다는 점에서 Unix 쉘과 매우 유사합니다.</target>
        </trans-unit>
        <trans-unit id="57a69bed4d30aeb2c23df15a4942d2f1bc4e9a99" translate="yes" xml:space="preserve">
          <source>Under the current implementation, the &lt;code&gt;foreach&lt;/code&gt; loop can be anywhere within the &lt;code&gt;when&lt;/code&gt; modifier's dynamic scope, but must be within the &lt;code&gt;given&lt;/code&gt; block's lexical scope. This restricted may be relaxed in a future release. See &lt;a href=&quot;#Switch-Statements&quot;&gt;Switch Statements&lt;/a&gt; below.</source>
          <target state="translated">현재 구현에서, &lt;code&gt;foreach&lt;/code&gt; 루프는 &lt;code&gt;when&lt;/code&gt; 한정자의 동적 범위 내의 어느 곳에 나있을 수 있지만 &lt;code&gt;given&lt;/code&gt; 블록의 어휘 범위 내에 있어야합니다 . 이 제한은 향후 릴리스에서 완화 될 수 있습니다. 아래의 &lt;a href=&quot;#Switch-Statements&quot;&gt;스위치 설명을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c2c16149ecdeeb74ed5502e1f6dbfb7232f42a07" translate="yes" xml:space="preserve">
          <source>Under the current implementation, the &lt;code&gt;foreach&lt;/code&gt; loop can be anywhere within the &lt;code&gt;when&lt;/code&gt; modifier's dynamic scope, but must be within the &lt;code&gt;given&lt;/code&gt; block's lexical scope. This restriction may be relaxed in a future release. See &lt;a href=&quot;#Switch-Statements&quot;&gt;&quot;Switch Statements&quot;&lt;/a&gt; below.</source>
          <target state="translated">현재 구현에서 &lt;code&gt;foreach&lt;/code&gt; 루프는 &lt;code&gt;when&lt;/code&gt; 수정 자의 동적 범위 내에있을 수 있지만 &lt;code&gt;given&lt;/code&gt; 블록의 어휘 범위 내에 있어야합니다 . 이 제한은 향후 릴리스에서 완화 될 수 있습니다. 아래의 &lt;a href=&quot;#Switch-Statements&quot;&gt;&quot;Switch 문&quot;을&lt;/a&gt; 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="e08f959b6899ef90dffb2ee9e0e0a8572c0a7c28" translate="yes" xml:space="preserve">
          <source>Under the hood, Perl filehandles are instances of the &lt;code&gt;IO::Handle&lt;/code&gt; or &lt;code&gt;IO::File&lt;/code&gt; class. Once you have an open filehandle, you can call methods on it. Additionally, you can call methods on the &lt;code&gt;STDIN&lt;/code&gt; , &lt;code&gt;STDOUT&lt;/code&gt; , and &lt;code&gt;STDERR&lt;/code&gt; filehandles.</source>
          <target state="translated">후드 아래에서 Perl 파일 핸들은 &lt;code&gt;IO::Handle&lt;/code&gt; 또는 &lt;code&gt;IO::File&lt;/code&gt; 클래스의 인스턴스입니다 . 열린 파일 핸들이 있으면 메소드를 호출 할 수 있습니다. 또한 &lt;code&gt;STDIN&lt;/code&gt; , &lt;code&gt;STDOUT&lt;/code&gt; 및 &lt;code&gt;STDERR&lt;/code&gt; 파일 핸들 에서 메소드를 호출 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="39f4d0de021895e742d4650602144370ddd79e3a" translate="yes" xml:space="preserve">
          <source>Under the hood, Perl filehandles are instances of the &lt;code&gt;IO::Handle&lt;/code&gt; or &lt;code&gt;IO::File&lt;/code&gt; class. Once you have an open filehandle, you can call methods on it. Additionally, you can call methods on the &lt;code&gt;STDIN&lt;/code&gt;, &lt;code&gt;STDOUT&lt;/code&gt;, and &lt;code&gt;STDERR&lt;/code&gt; filehandles.</source>
          <target state="translated">내부적으로 Perl 파일 핸들은 &lt;code&gt;IO::Handle&lt;/code&gt; 또는 &lt;code&gt;IO::File&lt;/code&gt; 클래스의 인스턴스입니다 . 열린 파일 핸들이 있으면 그에 대한 메서드를 호출 할 수 있습니다. 또한 &lt;code&gt;STDIN&lt;/code&gt; , &lt;code&gt;STDOUT&lt;/code&gt; 및 &lt;code&gt;STDERR&lt;/code&gt; 파일 핸들 에서 메소드를 호출 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="16abd29e91ee37c03769fcf588081b10ade9062f" translate="yes" xml:space="preserve">
          <source>Under the same license as Perl itself</source>
          <target state="translated">Perl 자체와 동일한 라이센스하에</target>
        </trans-unit>
        <trans-unit id="27e7e970c4cb85f5a1a451cbbaa7bb6fdbefed11" translate="yes" xml:space="preserve">
          <source>Underlying implementation for the &lt;code&gt;&lt;a href=&quot;functions/reset&quot;&gt;reset&lt;/a&gt;&lt;/code&gt; Perl function. Note that the perl-level function is vaguely deprecated.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/reset&quot;&gt;reset&lt;/a&gt;&lt;/code&gt; Perl 기능 의 기본 구현 . 펄 레벨 함수는 모호하게 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7f6fc2f81f4959a48ec9de583348cb6833131799" translate="yes" xml:space="preserve">
          <source>Underlying implementation for the &lt;code&gt;reset&lt;/code&gt; Perl function. Note that the perl-level function is vaguely deprecated.</source>
          <target state="translated">&lt;code&gt;reset&lt;/code&gt; Perl 기능 의 기본 구현입니다 . Perl 수준 함수는 모호하게 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3d53a031b5fe95ac3434bee7e57607b8155a1a48" translate="yes" xml:space="preserve">
          <source>Understand References Today</source>
          <target state="translated">오늘 참조 이해</target>
        </trans-unit>
        <trans-unit id="d2b515bbbe667df83c6f17f27b425a07b052435e" translate="yes" xml:space="preserve">
          <source>Understand that this removes the case-insensitivity feature of this module.</source>
          <target state="translated">이것이이 모듈의 대소 문자 구분 기능을 제거한다는 것을 이해하십시오.</target>
        </trans-unit>
        <trans-unit id="5dff374e163235318e5ce8f7742ec1049ed8b995" translate="yes" xml:space="preserve">
          <source>Understanding the Magic of Tied Hashes and Arrays</source>
          <target state="translated">묶인 해시 및 배열의 ​​마법 이해</target>
        </trans-unit>
        <trans-unit id="4fad51d89f7e0dadc266115be3afc11b52bc9806" translate="yes" xml:space="preserve">
          <source>Undertake to build a new set of Perl images using VMS commands. Since VMS does dynamic loading, it's not necessary to statically link each extension into the Perl image, so this isn't the normal build path. Consequently, it hasn't really been tested, and may well be incomplete.</source>
          <target state="translated">VMS 명령을 사용하여 새로운 Perl 이미지 세트를 빌드하십시오. VMS는 동적로드를 수행하므로 각 확장을 Perl 이미지에 정적으로 링크 할 필요가 없으므로 일반적인 빌드 경로가 아닙니다. 결과적으로 실제로 테스트되지 않았으며 불완전 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6b54be85a5a464cb36e53bbd5948681e9238101f" translate="yes" xml:space="preserve">
          <source>Undo various types of fakery on an SV, where fakery means &quot;more than&quot; a string: if the PV is a shared string, make a private copy; if we're a ref, stop refing; if we're a glob, downgrade to an &lt;code&gt;xpvmg&lt;/code&gt;; if we're a copy-on-write scalar, this is the on-write time when we do the copy, and is also used locally; if this is a vstring, drop the vstring magic. If &lt;code&gt;SV_COW_DROP_PV&lt;/code&gt; is set then a copy-on-write scalar drops its PV buffer (if any) and becomes &lt;code&gt;SvPOK_off&lt;/code&gt; rather than making a copy. (Used where this scalar is about to be set to some other value.) In addition, the &lt;code&gt;flags&lt;/code&gt; parameter gets passed to &lt;code&gt;sv_unref_flags()&lt;/code&gt; when unreffing. &lt;code&gt;sv_force_normal&lt;/code&gt; calls this function with flags set to 0.</source>
          <target state="translated">SV에서 다양한 유형의 위조를 실행 취소합니다. 여기서 위조는 문자열 &quot;이상&quot;을 의미합니다. PV가 공유 문자열 인 경우 개인 복사본을 만듭니다. 우리가 심판이라면 심판을 중지하십시오. 우리가 glob이라면 &lt;code&gt;xpvmg&lt;/code&gt; 로 다운 그레이드 하십시오 . 만약 우리가 copy-on-write 스칼라라면, 이것은 우리가 복사를 할 때의 쓰기 시간이며, 로컬에서도 사용됩니다. 이것이 vstring이라면 vstring 마법을 버리십시오. 경우 &lt;code&gt;SV_COW_DROP_PV&lt;/code&gt; 는 다음 설정 기록 중 복사 스칼라는 PV 버퍼 방울 (있는 경우)가된다 &lt;code&gt;SvPOK_off&lt;/code&gt; 을 복사본을 만들기보다는. (이 스칼라가 다른 값으로 설정 될 때 사용됩니다.) 추가로, &lt;code&gt;flags&lt;/code&gt; 매개 변수는 &lt;code&gt;sv_unref_flags()&lt;/code&gt; 전달됩니다 . &lt;code&gt;sv_force_normal&lt;/code&gt; 은 플래그가 0으로 설정된이 함수를 호출합니다.</target>
        </trans-unit>
        <trans-unit id="58380a9a71bcafd994016d7b4cb1383592a7215e" translate="yes" xml:space="preserve">
          <source>Undo various types of fakery on an SV, where fakery means &quot;more than&quot; a string: if the PV is a shared string, make a private copy; if we're a ref, stop refing; if we're a glob, downgrade to an xpvmg; if we're a copy-on-write scalar, this is the on-write time when we do the copy, and is also used locally; if this is a vstring, drop the vstring magic. If &lt;code&gt;SV_COW_DROP_PV&lt;/code&gt; is set then a copy-on-write scalar drops its PV buffer (if any) and becomes SvPOK_off rather than making a copy. (Used where this scalar is about to be set to some other value.) In addition, the &lt;code&gt;flags&lt;/code&gt; parameter gets passed to &lt;code&gt;sv_unref_flags()&lt;/code&gt; when unreffing. &lt;code&gt;sv_force_normal&lt;/code&gt; calls this function with flags set to 0.</source>
          <target state="translated">SV에서 다양한 유형의 위조를 실행 취소합니다. 여기에서 위조는 &quot;이상&quot;을 의미합니다. PV가 공유 스트링 인 경우 개인 사본을 만듭니다. 우리가 심판이라면 심판을 그만두십시오. 우리가 글로브라면 xpvmg로 다운 그레이드하십시오. copy-on-write 스칼라 인 경우, 복사 할 때의 쓰기시 시간이며 로컬에서도 사용됩니다. 이것이 vstring 인 경우 vstring 매직을 삭제하십시오. &lt;code&gt;SV_COW_DROP_PV&lt;/code&gt; 가 설정 되면 쓰기시 복사 스칼라는 PV 버퍼를 삭제하고 (있는 경우) 복사하지 않고 SvPOK_off가됩니다. (이 스칼라가 다른 값으로 설정 &lt;code&gt;sv_unref_flags()&lt;/code&gt; 경우에 사용됩니다 .) 또한 &lt;code&gt;flags&lt;/code&gt; 매개 변수는 unreffing시 sv_unref_flags ()로 전달됩니다 . &lt;code&gt;sv_force_normal&lt;/code&gt; 은 플래그를 0으로 설정하여이 함수를 호출합니다.</target>
        </trans-unit>
        <trans-unit id="6f1a942ff8c67eb2d1fc5bf7179e4670a0cecd7d" translate="yes" xml:space="preserve">
          <source>Undo various types of fakery on an SV: if the PV is a shared string, make a private copy; if we're a ref, stop refing; if we're a glob, downgrade to an &lt;code&gt;xpvmg&lt;/code&gt;. See also &lt;code&gt;&lt;a href=&quot;#sv_force_normal_flags&quot;&gt;&quot;sv_force_normal_flags&quot;&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">SV에서 다양한 유형의 위조를 취소하십시오. PV가 공유 문자열 인 경우 개인 사본을 만드십시오. 우리가 심판이라면 심판을 중지하십시오. 우리가 glob 인 경우 &lt;code&gt;xpvmg&lt;/code&gt; 로 다운 그레이드합니다 . &lt;code&gt;&lt;a href=&quot;#sv_force_normal_flags&quot;&gt;&quot;sv_force_normal_flags&quot;&lt;/a&gt;&lt;/code&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="2c0043167da52b5a8f43ef5ef3ae847c1d205a64" translate="yes" xml:space="preserve">
          <source>Undo various types of fakery on an SV: if the PV is a shared string, make a private copy; if we're a ref, stop refing; if we're a glob, downgrade to an xpvmg. See also &lt;code&gt;sv_force_normal_flags&lt;/code&gt; .</source>
          <target state="translated">SV에서 다양한 유형의 위조를 실행 취소합니다. PV가 공유 문자열 인 경우 개인 사본을 만듭니다. 우리가 심판이라면 심판을 그만두십시오. 우리가 글로브라면 xpvmg로 다운 그레이드하십시오. &lt;code&gt;sv_force_normal_flags&lt;/code&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f9b219af612756cb93e821fb5ae6c25750a8208b" translate="yes" xml:space="preserve">
          <source>Undocumented functions</source>
          <target state="translated">문서화되지 않은 기능</target>
        </trans-unit>
        <trans-unit id="e41716465542db7b5229d785ccf7cc674a9a2021" translate="yes" xml:space="preserve">
          <source>Unescaped left brace in regex is illegal here in regex; marked by &amp;lt;-- HERE in m/%s/</source>
          <target state="translated">정규식에서 이스케이프 처리되지 않은 왼쪽 중괄호는 정규식에서 불법입니다. &amp;lt;-HERE (m / % s /)로 표시</target>
        </trans-unit>
        <trans-unit id="6360e841155690a571fd019b59b2e90901cd664e" translate="yes" xml:space="preserve">
          <source>Unescaped left brace in regex is passed through in regex; marked by &amp;lt;-- HERE in m/%s/</source>
          <target state="translated">정규식에서 이스케이프되지 않은 왼쪽 중괄호는 정규식에서 전달됩니다. &amp;lt;-HERE (m / % s /)로 표시</target>
        </trans-unit>
        <trans-unit id="ebd43bbecc54b5a0f3d5534ed1867230c22e3ca4" translate="yes" xml:space="preserve">
          <source>Unescaped left braces in regular expressions</source>
          <target state="translated">정규식에서 이스케이프되지 않은 왼쪽 중괄호</target>
        </trans-unit>
        <trans-unit id="9cb80f3878ea015392dd87b05584ccec54611d89" translate="yes" xml:space="preserve">
          <source>Unescaped left braces in regular expressions (for 5.30)</source>
          <target state="translated">정규식에서 이스케이프되지 않은 왼쪽 중괄호 (5.30의 경우)</target>
        </trans-unit>
        <trans-unit id="9669238bade25c40c06b3f549ae09d7384574818" translate="yes" xml:space="preserve">
          <source>Unescaped literal '%c' in regex; marked by &amp;lt;-- HERE in m/%s/</source>
          <target state="translated">정규식에서 이스케이프되지 않은 리터럴 '% c'; &amp;lt;-HERE (m / % s /)로 표시</target>
        </trans-unit>
        <trans-unit id="22086bbd02aed990980d36b0db035a998bc6e3e0" translate="yes" xml:space="preserve">
          <source>Unexpected '(' with no preceding operator in regex; marked by &amp;lt;-- HERE in m/%s/</source>
          <target state="translated">정규식에 선행 연산자가없는 예기치 않은 '(', &amp;lt;-HERE (m / % s /)로 표시됨</target>
        </trans-unit>
        <trans-unit id="e8ad8043f2dbcf1dd017dcdb5209cbf492290eda" translate="yes" xml:space="preserve">
          <source>Unexpected ')' in regex; marked by &amp;lt;-- HERE in m/%s/</source>
          <target state="translated">정규식에 예기치 않은 ')'가 있습니다. &amp;lt;-HERE (m / % s /)로 표시</target>
        </trans-unit>
        <trans-unit id="d3baa204dcc0f34d9c04dd0cdbe5cd8bc491de0f" translate="yes" xml:space="preserve">
          <source>Unexpected ']' with no following ')' in (?[... in regex; marked by &amp;lt;-- HERE in m/%s/</source>
          <target state="translated">(? [... 정규식에서; m / % s /에서 HERE로 표시됨)에 다음 ')'이없는 예기치 않은 ']'</target>
        </trans-unit>
        <trans-unit id="3ceff2d23f8886ee7189841ccdf57932b12e7de9" translate="yes" xml:space="preserve">
          <source>Unexpected binary operator '%c' with no preceding operand in regex; marked by &amp;lt;-- HERE in m/%s/</source>
          <target state="translated">정규식에 선행 피연산자가없는 예기치 않은 이항 연산자 '% c'입니다. &amp;lt;-HERE (m / % s /)로 표시</target>
        </trans-unit>
        <trans-unit id="a6fd6877eeb4ca65b2ae370712af39b9caed0a2a" translate="yes" xml:space="preserve">
          <source>Unexpected character in regex; marked by &amp;lt;-- HERE in m/%s/</source>
          <target state="translated">정규식에 예기치 않은 문자가 있습니다. &amp;lt;-HERE (m / % s /)로 표시</target>
        </trans-unit>
        <trans-unit id="93bb4877e7bb13d05b3e08f4eae8e3dad1e4b888" translate="yes" xml:space="preserve">
          <source>Unexpected constant lvalue entersub entry via type/targ %d:%d</source>
          <target state="translated">유형 / targ % d : % d을 (를) 통해 예기치 않은 상수 lvalue entersub 항목</target>
        </trans-unit>
        <trans-unit id="f3d819fa6d0f62b6341c9587511dec4703500307" translate="yes" xml:space="preserve">
          <source>Unexpected exit %u</source>
          <target state="translated">예기치 않은 종료 % u</target>
        </trans-unit>
        <trans-unit id="8dbae700354867d121187e2a50e0cc20e0e1e77b" translate="yes" xml:space="preserve">
          <source>Unexpected exit failure %d</source>
          <target state="translated">예기치 않은 종료 실패 % d</target>
        </trans-unit>
        <trans-unit id="eed18284023acb946f22279a557b952faac276d4" translate="yes" xml:space="preserve">
          <source>Unfinished Tales</source>
          <target state="translated">미완성 된 이야기</target>
        </trans-unit>
        <trans-unit id="4df58040d6486eaa853729500be20c8509618322" translate="yes" xml:space="preserve">
          <source>Unfortunately it is not that difficult somehow manage to break one's Mac OS X Perl rather severely. If all else fails and you want to really, &lt;b&gt;REALLY&lt;/b&gt;, start from scratch and remove even your Apple Perl installation (which has become corrupted somehow), the following instructions should do it. &lt;b&gt;Please think twice before following these instructions: they are much like conducting brain surgery to yourself. Without anesthesia.&lt;/b&gt; We will &lt;b&gt;not&lt;/b&gt; come to fix your system if you do this.</source>
          <target state="translated">불행히도 어쨌든 Mac OS X Perl을 심하게 손상시키는 것은 어렵지 않습니다. 다른 모든 방법으로 문제가 발생하여 실제로 &lt;b&gt;REALLY&lt;/b&gt; 하려는 경우 처음부터 시작하여 Apple Perl 설치를 제거하십시오 (어쨌든 손상된 경우). &lt;b&gt;이 지시 사항을 따르기 전에 두 번 생각하십시오. 그것들은 뇌 수술을하는 것과 매우 흡사합니다. 마취없이. &lt;/b&gt;우리는 할 &lt;b&gt;수 없습니다&lt;/b&gt; 당신이 할 경우 시스템을 해결하기 위해 온다.</target>
        </trans-unit>
        <trans-unit id="378b677974afb6ec2935fe271f0a9219fbb154a8" translate="yes" xml:space="preserve">
          <source>Unfortunately this field is basically meaningless, since many distributions are hybrids of several kinds of things, or some new thing, or subjectively different in focus depending on who's using them. Tools like Module::Build and MakeMaker will likely stop generating this field.</source>
          <target state="translated">불행히도이 분야는 기본적으로 무의미합니다. 많은 배포판이 여러 종류의 하이브리드이거나 새로운 것이거나 누가 사용하는지에 따라 초점이 주관적으로 다르기 때문입니다. Module :: Build 및 MakeMaker와 같은 도구는이 필드 생성을 중지 할 가능성이 있습니다.</target>
        </trans-unit>
        <trans-unit id="59f5b94a3a1a43fcb76168bb8fa3d4bd048c2c1e" translate="yes" xml:space="preserve">
          <source>Unfortunately this is sometimes not enough, neither colour nor quotes will help you with problems involving tabs, other non-printing characters and certain kinds of problems inherent in Unicode. To deal with this, you can switch Test::Tester into a mode whereby all &quot;tricky&quot; characters are shown as \{xx}. Tricky characters are those with ASCII code less than 33 or higher than 126. This makes the output more difficult to read but much easier to find subtle differences between strings. To turn on this mode either call &lt;code&gt;show_space()&lt;/code&gt; in your test script or set the &lt;code&gt;TESTTESTERSPACE&lt;/code&gt; environment variable to be a true value. The example above would then look like</source>
          <target state="translated">불행히도 이것은 때때로 충분하지 않습니다. 색상이나 따옴표는 탭, 기타 인쇄되지 않는 문자 및 유니 코드 고유의 특정 종류의 문제와 관련된 문제를 해결하는 데 도움이되지 않습니다. 이를 처리하기 위해 Test :: Tester를 모든 &quot;까다로운&quot;문자가 \ {xx}로 표시되는 모드로 전환 할 수 있습니다. 까다로운 문자는 ASCII 코드가 33보다 작거나 126보다 큰 문자입니다. 이렇게하면 출력을 읽기가 더 어려워 지지만 문자열 간의 미묘한 차이를 훨씬 쉽게 찾을 수 있습니다. 이 모드를 켜 려면 테스트 스크립트에서 &lt;code&gt;show_space()&lt;/code&gt; 를 호출 하거나 &lt;code&gt;TESTTESTERSPACE&lt;/code&gt; 환경 변수를 true 값으로 설정하십시오. 위의 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="29de2b4590451aa9259989dd73cca2f011560c79" translate="yes" xml:space="preserve">
          <source>Unfortunately, I can't differentiate any further.</source>
          <target state="translated">불행히도, 나는 더 이상 구별 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="6e14820d498a0bc4a9f36bbc1285250e475a8eba" translate="yes" xml:space="preserve">
          <source>Unfortunately, a note cannot be used with the single argument style of &lt;code&gt;ok()&lt;/code&gt; . That is, if you try &lt;code&gt;ok(&lt;i&gt;arg1&lt;/i&gt;, &lt;i&gt;note&lt;/i&gt;)&lt;/code&gt;, then &lt;code&gt;Test&lt;/code&gt; will interpret this as &lt;code&gt;ok(&lt;i&gt;arg1&lt;/i&gt;, &lt;i&gt;arg2&lt;/i&gt;)&lt;/code&gt;, and probably end up testing &lt;code&gt;&lt;i&gt;arg1&lt;/i&gt; eq &lt;i&gt;arg2&lt;/i&gt;&lt;/code&gt; -- and that's not what you want!</source>
          <target state="translated">불행히도, 단일 인수 스타일 &lt;code&gt;ok()&lt;/code&gt; 와 함께 메모를 사용할 수 없습니다 . 당신이 시도하는 경우 즉, &lt;code&gt;ok(&lt;i&gt;arg1&lt;/i&gt;, &lt;i&gt;note&lt;/i&gt;)&lt;/code&gt; , 다음 &lt;code&gt;Test&lt;/code&gt; 로이 해석됩니다 &lt;code&gt;ok(&lt;i&gt;arg1&lt;/i&gt;, &lt;i&gt;arg2&lt;/i&gt;)&lt;/code&gt; , 그리고 아마도 테스트 결국 &lt;code&gt;&lt;i&gt;arg1&lt;/i&gt; eq &lt;i&gt;arg2&lt;/i&gt;&lt;/code&gt; - 당신이 원하는 게 아니에요 그!</target>
        </trans-unit>
        <trans-unit id="ef3c1b19c392ac342a5e6bd955e45b0b563788d1" translate="yes" xml:space="preserve">
          <source>Unfortunately, a note cannot be used with the single argument style of &lt;code&gt;ok()&lt;/code&gt;. That is, if you try &lt;code&gt;ok(&lt;i&gt;arg1&lt;/i&gt;, &lt;i&gt;note&lt;/i&gt;)&lt;/code&gt;, then &lt;code&gt;Test&lt;/code&gt; will interpret this as &lt;code&gt;ok(&lt;i&gt;arg1&lt;/i&gt;, &lt;i&gt;arg2&lt;/i&gt;)&lt;/code&gt;, and probably end up testing &lt;code&gt;&lt;i&gt;arg1&lt;/i&gt; eq &lt;i&gt;arg2&lt;/i&gt;&lt;/code&gt; -- and that's not what you want!</source>
          <target state="translated">불행히도, 노트는 &lt;code&gt;ok()&lt;/code&gt; 의 단일 인수 스타일과 함께 사용할 수 없습니다 . 당신이 시도하는 경우 즉, &lt;code&gt;ok(&lt;i&gt;arg1&lt;/i&gt;, &lt;i&gt;note&lt;/i&gt;)&lt;/code&gt; , 다음 &lt;code&gt;Test&lt;/code&gt; 로이 해석됩니다 &lt;code&gt;ok(&lt;i&gt;arg1&lt;/i&gt;, &lt;i&gt;arg2&lt;/i&gt;)&lt;/code&gt; , 그리고 아마도 테스트 결국 &lt;code&gt;&lt;i&gt;arg1&lt;/i&gt; eq &lt;i&gt;arg2&lt;/i&gt;&lt;/code&gt; - 당신이 원하는 게 아니에요 그!</target>
        </trans-unit>
        <trans-unit id="4ed74c92d4298d9e7fcce728b69ed6f5c8ab08c5" translate="yes" xml:space="preserve">
          <source>Unfortunately, for backwards compatibility reasons, an empty &lt;code&gt;\x&lt;/code&gt; is legal outside &lt;code&gt;use re 'strict'&lt;/code&gt; and expands to a NUL character.</source>
          <target state="translated">불행히도 이전 버전과의 호환성을 위해 빈 &lt;code&gt;\x&lt;/code&gt; 는 &lt;code&gt;use re 'strict'&lt;/code&gt; 밖에서 합법적 이며 NUL 문자로 확장됩니다.</target>
        </trans-unit>
        <trans-unit id="7f4f5938609da571758adb22fa6ce02f230693d9" translate="yes" xml:space="preserve">
          <source>Unfortunately, interpretation of colors 0 through 7 often depends on whether the emulator supports eight colors or sixteen colors. Emulators that only support eight colors (such as the Linux console) will display colors 0 through 7 with normal brightness and ignore colors 8 through 15, treating them the same as white. Emulators that support 16 colors, such as gnome-terminal, normally display colors 0 through 7 as dim or darker versions and colors 8 through 15 as normal brightness. On such emulators, the &quot;normal&quot; white (color 7) usually is shown as pale grey, requiring bright white (15) to be used to get a real white color. Bright black usually is a dark grey color, although some terminals display it as pure black. Some sixteen-color terminal emulators also treat normal yellow (color 3) as orange or brown, and bright yellow (color 11) as yellow.</source>
          <target state="translated">불행하게도, 0에서 7까지의 색상의 해석은 에뮬레이터가 8 개의 색상을 지원하는지 16 개의 색상을 지원하는지에 따라 달라집니다. Linux 콘솔과 같이 8 가지 색상 만 지원하는 에뮬레이터는 0에서 7까지의 색상을 일반 밝기로 표시하고 8에서 15까지의 색상은 무시하고 흰색과 동일하게 처리합니다. gnome-terminal과 같은 16 가지 색상을 지원하는 에뮬레이터는 일반적으로 0 ~ 7의 색상을 희미하거나 어두운 버전으로, 8 ~ 15의 색상을 일반 밝기로 표시합니다. 이러한 에뮬레이터에서 &quot;일반&quot;흰색 (컬러 7)은 일반적으로 옅은 회색으로 표시되며 실제 흰색을 얻으려면 밝은 흰색 (15)이 필요합니다. 밝은 검은 색은 보통 어두운 회색이지만 일부 터미널은 순수한 검은 색으로 표시됩니다. 일부 16 색 터미널 에뮬레이터도 일반 노란색 (3 색)을 주황색 또는 갈색으로 처리합니다.밝은 노란색 (색상 11)을 노란색으로 표시합니다.</target>
        </trans-unit>
        <trans-unit id="d3f96232328f4faede427c8ce3041998253135ab" translate="yes" xml:space="preserve">
          <source>Unfortunately, it may be that encodings are not &lt;code&gt;PerlIO&lt;/code&gt; -savvy. You can check to see whether your encoding is supported by &lt;code&gt;PerlIO&lt;/code&gt; by invoking the &lt;code&gt;perlio_ok&lt;/code&gt; method on it:</source>
          <target state="translated">불행하게도, 인코딩이 &lt;code&gt;PerlIO&lt;/code&gt; 에 정통 하지 않을 수 있습니다 . &lt;code&gt;perlio_ok&lt;/code&gt; 메소드를 호출하여 &lt;code&gt;PerlIO&lt;/code&gt; 가 인코딩을 지원하는지 여부를 확인할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7a881f618a75cd78f718468efd31960bdadb828c" translate="yes" xml:space="preserve">
          <source>Unfortunately, it may be that encodings are not &lt;code&gt;PerlIO&lt;/code&gt;-savvy. You can check to see whether your encoding is supported by &lt;code&gt;PerlIO&lt;/code&gt; by invoking the &lt;code&gt;perlio_ok&lt;/code&gt; method on it:</source>
          <target state="translated">불행히도 인코딩이 &lt;code&gt;PerlIO&lt;/code&gt; 에 익숙 하지 않을 수 있습니다 . &lt;code&gt;perlio_ok&lt;/code&gt; 메서드를 호출하여 &lt;code&gt;PerlIO&lt;/code&gt; 에서 인코딩을 지원하는지 확인할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fa870b38ba970158ffd4da6159a903c51d8f85af" translate="yes" xml:space="preserve">
          <source>Unfortunately, the original specification of UTF-8 leaves some room for interpretation of how many bytes of encoded output one should generate from one input Unicode character. Strictly speaking, the shortest possible sequence of UTF-8 bytes should be generated, because otherwise there is potential for an input buffer overflow at the receiving end of a UTF-8 connection. Perl always generates the shortest length UTF-8, and with warnings on, Perl will warn about non-shortest length UTF-8 along with other malformations, such as the surrogates, which are not Unicode code points valid for interchange.</source>
          <target state="translated">불행하게도, UTF-8의 원래 사양은 하나의 입력 유니 코드 문자에서 몇 바이트의 인코딩 된 출력을 생성해야 하는지를 해석 할 여지를 남겨둔다. 엄밀히 말하면, UTF-8 연결의 수신 끝에서 입력 버퍼 오버 플로우가 발생할 가능성이 있기 때문에 가능한 가장 짧은 UTF-8 바이트 시퀀스가 ​​생성되어야합니다. Perl은 항상 가장 짧은 길이의 UTF-8을 생성하며 경고가 표시되면 Perl은 가장 짧은 길이가 아닌 UTF-8에 대해 대리자와 같은 다른 기형 (교환에 유효한 유니 코드 코드 포인트가 아님)과 함께 경고합니다.</target>
        </trans-unit>
        <trans-unit id="a23a8e59abb3029d4c1dd279e145008516f63183" translate="yes" xml:space="preserve">
          <source>Unfortunately, there are quite a few deficiencies with the design (and often, the implementations) of locales. Unicode was invented (see &lt;a href=&quot;perlunitut&quot;&gt;perlunitut&lt;/a&gt; for an introduction to that) in part to address these design deficiencies, and nowadays, there is a series of &quot;UTF-8 locales&quot;, based on Unicode. These are locales whose character set is Unicode, encoded in UTF-8. Starting in v5.20, Perl fully supports UTF-8 locales, except for sorting and string comparisons like &lt;code&gt;lt&lt;/code&gt; and &lt;code&gt;ge&lt;/code&gt;. Starting in v5.26, Perl can handle these reasonably as well, depending on the platform's implementation. However, for earlier releases or for better control, use &lt;a href=&quot;Unicode::Collate&quot;&gt;Unicode::Collate&lt;/a&gt;. There are actually two slightly different types of UTF-8 locales: one for Turkic languages and one for everything else.</source>
          <target state="translated">불행히도 로케일의 디자인 (그리고 종종 구현)에 상당한 결함이 있습니다. 부분적으로 이러한 디자인 결함을 해결하기 위해 유니 코드가 발명되었습니다 ( &lt;a href=&quot;perlunitut&quot;&gt;이에&lt;/a&gt; 대한 소개는 perlunitut 참조 ). 현재는 유니 코드를 기반으로 한 일련의 &quot;UTF-8 로케일&quot;이 있습니다. 문자 세트가 UTF-8로 인코딩 된 유니 코드 인 로케일입니다. v5.20부터 Perl은 &lt;code&gt;lt&lt;/code&gt; 및 &lt;code&gt;ge&lt;/code&gt; 와 같은 정렬 및 문자열 비교를 제외하고 UTF-8 로케일을 완전히 지원합니다 . v5.26부터 Perl은 플랫폼의 구현에 따라이를 합리적으로 처리 할 수 ​​있습니다. 그러나 이전 릴리스 또는 더 나은 제어를 위해 &lt;a href=&quot;Unicode::Collate&quot;&gt;Unicode :: Collate를 사용하십시오.&lt;/a&gt;. 실제로 두 가지 약간 다른 유형의 UTF-8 로케일이 있습니다. 하나는 Turkic 언어 용이고 다른 하나는 다른 모든 언어 용입니다.</target>
        </trans-unit>
        <trans-unit id="1170c59a72df3e22ea0a090adf0e9824ff8c0b09" translate="yes" xml:space="preserve">
          <source>Unfortunately, there are quite a few deficiencies with the design (and often, the implementations) of locales. Unicode was invented (see &lt;a href=&quot;perlunitut&quot;&gt;perlunitut&lt;/a&gt; for an introduction to that) in part to address these design deficiencies, and nowadays, there is a series of &quot;UTF-8 locales&quot;, based on Unicode. These are locales whose character set is Unicode, encoded in UTF-8. Starting in v5.20, Perl fully supports UTF-8 locales, except for sorting and string comparisons. (Use &lt;a href=&quot;unicode/collate&quot;&gt;Unicode::Collate&lt;/a&gt; for these.) Perl continues to support the old non UTF-8 locales as well. There are currently no UTF-8 locales for EBCDIC platforms.</source>
          <target state="translated">불행히도 로케일의 디자인 (및 종종 구현)에는 꽤 많은 결함이 있습니다. 이러한 디자인 결함을 해결하기 위해 부분적으로 유니 코드가 개발되었고 ( 소개에 대해서는 &lt;a href=&quot;perlunitut&quot;&gt;perlunitut&lt;/a&gt; 참조 ), 오늘날에는 유니 코드를 기반으로 일련의 &quot;UTF-8 로케일&quot;이 있습니다. 문자 세트가 유니 코드이며 UTF-8로 인코딩 된 로케일입니다. v5.20부터 Perl은 정렬 및 문자열 비교를 제외하고 UTF-8 로케일을 완전히 지원합니다. (사용 &lt;a href=&quot;unicode/collate&quot;&gt;유니 코드 :: 부씩&lt;/a&gt; 이들에 대한이.) 펄은 물론 기존 비 UTF-8 로케일을 지원하고 있습니다. 현재 EBCDIC 플랫폼에는 UTF-8 로켈이 없습니다.</target>
        </trans-unit>
        <trans-unit id="c8d518114a049f78aefe7090de8efc32eccefc83" translate="yes" xml:space="preserve">
          <source>Unfortunately, this isn't true. In perl 5.18 and earlier, AVs use &lt;code&gt;&amp;amp;PL_sv_undef&lt;/code&gt; as a marker for indicating that an array element has not yet been initialized. Thus, &lt;code&gt;&lt;a href=&quot;functions/exists&quot;&gt;exists&lt;/a&gt; $av[0]&lt;/code&gt; would be true for the above Perl code, but false for the array generated by the XS code. In perl 5.20, storing &amp;amp;PL_sv_undef will create a read-only element, because the scalar &amp;amp;PL_sv_undef itself is stored, not a copy.</source>
          <target state="translated">불행히도, 이것은 사실이 아닙니다. perl 5.18 이하에서 AV 는 배열 요소가 아직 초기화되지 않았 음을 나타내는 마커로 &lt;code&gt;&amp;amp;PL_sv_undef&lt;/code&gt; 를 사용 합니다. 따라서 위의 Perl 코드의 &lt;code&gt;&lt;a href=&quot;functions/exists&quot;&gt;exists&lt;/a&gt; $av[0]&lt;/code&gt; 은 true이지만 XS 코드에서 생성 된 배열의 경우 false입니다. perl 5.20에서 &amp;amp; PL_sv_undef를 저장하면 스칼라 &amp;amp; PL_sv_undef 자체가 사본이 아니라 저장되므로 읽기 전용 요소가 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="6aaca93722126b600c61100d9e3813a48d2917af" translate="yes" xml:space="preserve">
          <source>Unfortunately, this isn't true. In perl 5.18 and earlier, AVs use &lt;code&gt;&amp;amp;PL_sv_undef&lt;/code&gt; as a marker for indicating that an array element has not yet been initialized. Thus, &lt;code&gt;exists $av[0]&lt;/code&gt; would be true for the above Perl code, but false for the array generated by the XS code. In perl 5.20, storing &amp;amp;PL_sv_undef will create a read-only element, because the scalar &amp;amp;PL_sv_undef itself is stored, not a copy.</source>
          <target state="translated">불행히도 이것은 사실이 아닙니다. Perl 5.18 및 이전 버전에서 AV 는 배열 요소가 아직 초기화되지 않았 음을 나타내는 마커로 &lt;code&gt;&amp;amp;PL_sv_undef&lt;/code&gt; 를 사용 합니다. 따라서 &lt;code&gt;exists $av[0]&lt;/code&gt; 이 존재 하면 위의 Perl 코드에 대해서는 참이되고 XS 코드에 의해 생성 된 배열에 대해서는 거짓이됩니다. perl 5.20에서 &amp;amp; PL_sv_undef를 저장하면 읽기 전용 요소가 생성됩니다. 스칼라 &amp;amp; PL_sv_undef 자체가 복사본이 아니라 저장되기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="4484d276f38b1e070d2bbc67b4f47022917572dc" translate="yes" xml:space="preserve">
          <source>Unfortunately, this scheme does not work well with escape-based encodings such as ISO-2022-JP.</source>
          <target state="translated">불행히도이 체계는 ISO-2022-JP와 같은 이스케이프 기반 인코딩에서는 잘 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5a9b09da1b70d953819b14bad175ad6e8c81c049" translate="yes" xml:space="preserve">
          <source>Unfortunately, while this &lt;code&gt;style&lt;/code&gt; variable is used to set defaults for all three directory hierarchies (core, vendor, and site), there is no guarantee that the same style is actually appropriate for all those directories. For example, $prefix might be</source>
          <target state="translated">불행히도이 &lt;code&gt;style&lt;/code&gt; 변수는 세 가지 디렉토리 계층 (핵심, 공급 업체 및 사이트) 모두에 대한 기본값을 설정하는 데 사용되지만 실제로 모든 해당 디렉토리에 동일한 스타일이 적절하다는 보장은 없습니다. 예를 들어 $ prefix는</target>
        </trans-unit>
        <trans-unit id="87c5d4faa14910842f5557a05819e468661f127e" translate="yes" xml:space="preserve">
          <source>Unfortunately, while this is true, it's still broken. All the references in @AoA refer to the</source>
          <target state="translated">불행히도 이것이 사실이지만 여전히 깨졌습니다. @AoA의 모든 참조는</target>
        </trans-unit>
        <trans-unit id="b3033d12e8c5e48f79875dd4cf162f90c243f353" translate="yes" xml:space="preserve">
          <source>Unfortunately, you may encounter Perl modules that are not</source>
          <target state="translated">불행히도, 당신은 아닌 펄 모듈이 발생할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="76435dad798e21eb71def4f2d3a46ed9708e4adf" translate="yes" xml:space="preserve">
          <source>Unget a line of text from the server.</source>
          <target state="translated">서버에서 한 줄의 텍스트를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="9ab0bd9a6126ee4b9d7538d5c6cba7aa587f31ed" translate="yes" xml:space="preserve">
          <source>Unicode</source>
          <target state="translated">Unicode</target>
        </trans-unit>
        <trans-unit id="eb802e96fd38e5e550d19f898a4fa941c45d6b21" translate="yes" xml:space="preserve">
          <source>Unicode 7.0 changed the wording so that they are &quot;&lt;b&gt;not recommended&lt;/b&gt; for use in open interchange of Unicode text data&quot;. The 7.0 Standard goes on to say:</source>
          <target state="translated">유니 코드 7.0은 &quot; 유니 코드 텍스트 데이터의 열린 교환에 사용 &lt;b&gt;하지 않는 것이 좋습니다&lt;/b&gt; &quot;라는 문구를 변경했습니다 . 7.0 표준은 다음과 같이 말합니다.</target>
        </trans-unit>
        <trans-unit id="8306b01ff9c220d1ce9274f85cf12d457904d299" translate="yes" xml:space="preserve">
          <source>Unicode Character Properties</source>
          <target state="translated">유니 코드 문자 속성</target>
        </trans-unit>
        <trans-unit id="2a76af7c10ae9a7945dc677634ff7f287d2f0d66" translate="yes" xml:space="preserve">
          <source>Unicode Collation Algorithm</source>
          <target state="translated">유니 코드 데이터 정렬 알고리즘</target>
        </trans-unit>
        <trans-unit id="c80690d5b1494bcf7f26319a35f4cf6977eedc42" translate="yes" xml:space="preserve">
          <source>Unicode Collation Algorithm - UTS #10</source>
          <target state="translated">유니 코드 데이터 정렬 알고리즘-UTS # 10</target>
        </trans-unit>
        <trans-unit id="8a8a7bf1ba1b9e4c2b07e9ad90fbd26463e5d980" translate="yes" xml:space="preserve">
          <source>Unicode Consortium</source>
          <target state="translated">유니 코드 컨소시엄</target>
        </trans-unit>
        <trans-unit id="0eb610a39db0d61541e877f8f7d93f1d2cd4e414" translate="yes" xml:space="preserve">
          <source>Unicode Consortium &lt;a href=&quot;http://www.unicode.org/&quot;&gt;http://www.unicode.org/&lt;/a&gt;</source>
          <target state="translated">유니 코드 컨소시엄 &lt;a href=&quot;http://www.unicode.org/&quot;&gt;http://www.unicode.org/&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b56cce9c1325a6619b09abb29a03b2934dad13be" translate="yes" xml:space="preserve">
          <source>Unicode Encodings</source>
          <target state="translated">유니 코드 인코딩</target>
        </trans-unit>
        <trans-unit id="20d826b4f354ace01634ff9215d461c1d2de2da2" translate="yes" xml:space="preserve">
          <source>Unicode FAQ</source>
          <target state="translated">유니 코드 FAQ</target>
        </trans-unit>
        <trans-unit id="be2c3b070e201b30c780f442801bee53720d3f02" translate="yes" xml:space="preserve">
          <source>Unicode Glossary</source>
          <target state="translated">유니 코드 용어집</target>
        </trans-unit>
        <trans-unit id="c37be50216d5f3d38f1ea9b4becfe8758aaff3f3" translate="yes" xml:space="preserve">
          <source>Unicode I/O</source>
          <target state="translated">유니 코드 I / O</target>
        </trans-unit>
        <trans-unit id="0b15b2a3ee7f250e6d79317da505977b8ac153a4" translate="yes" xml:space="preserve">
          <source>Unicode Locale Data Markup Language (LDML) - UTS #35</source>
          <target state="translated">유니 코드 LDML (로케일 데이터 마크 업 언어)-UTS # 35</target>
        </trans-unit>
        <trans-unit id="4f977034e8571e3a210188dcc1d8385457a8e9f6" translate="yes" xml:space="preserve">
          <source>Unicode Normalization Forms</source>
          <target state="translated">유니 코드 정규화 양식</target>
        </trans-unit>
        <trans-unit id="775e22294d31686679c1488c3a4e009b588fb93a" translate="yes" xml:space="preserve">
          <source>Unicode Normalization Forms - UAX #15</source>
          <target state="translated">유니 코드 정규화 양식-UAX # 15</target>
        </trans-unit>
        <trans-unit id="41086ae1277eac703b49ed9c64da7c4e1e028776" translate="yes" xml:space="preserve">
          <source>Unicode Properties</source>
          <target state="translated">유니 코드 속성</target>
        </trans-unit>
        <trans-unit id="ecfb52e522a545f9d54db78a273755a7cf69910d" translate="yes" xml:space="preserve">
          <source>Unicode Recommended Reading List</source>
          <target state="translated">유니 코드 권장 읽기 목록</target>
        </trans-unit>
        <trans-unit id="3dc43797a086d2e60b97e26ddbcd0e763ba2be44" translate="yes" xml:space="preserve">
          <source>Unicode Regular Expression Support Level</source>
          <target state="translated">유니 코드 정규식 지원 수준</target>
        </trans-unit>
        <trans-unit id="47be4025952fbf3894ef86d325a9d331d9d77d10" translate="yes" xml:space="preserve">
          <source>Unicode Support</source>
          <target state="translated">유니 코드 지원</target>
        </trans-unit>
        <trans-unit id="5477f70b1eea785630b35cd84e386522cded5715" translate="yes" xml:space="preserve">
          <source>Unicode Transformation Format</source>
          <target state="translated">유니 코드 변환 형식</target>
        </trans-unit>
        <trans-unit id="3b3c1f4d1dbf76960cd965f0a9ee21a6e35c74bd" translate="yes" xml:space="preserve">
          <source>Unicode Useful Resources</source>
          <target state="translated">유니 코드 유용한 자료</target>
        </trans-unit>
        <trans-unit id="0bd38e8f5dc5fab318029c6a0f6bf740c02237f9" translate="yes" xml:space="preserve">
          <source>Unicode aims to &lt;b&gt;UNI&lt;/b&gt;-fy the en-&lt;b&gt;CODE&lt;/b&gt;-ings of all the world's character sets into a single Standard. For quite a few of the various coding standards that existed when Unicode was first created, converting from each to Unicode essentially meant adding a constant to each code point in the original standard, and converting back meant just subtracting that same constant. For ASCII and ISO-8859-1, the constant is 0. For ISO-8859-5, (Cyrillic) the constant is 864; for Hebrew (ISO-8859-8), it's 1488; Thai (ISO-8859-11), 3424; and so forth. This made it easy to do the conversions, and facilitated the adoption of Unicode.</source>
          <target state="translated">유니 목표 &lt;b&gt;UNI는&lt;/b&gt; 엔 - -fy &lt;b&gt;코드의&lt;/b&gt; 하나의 표준으로 전 세계의 문자 세트의 -ings을. 유니 코드가 처음 만들어 졌을 때 존재했던 다양한 코딩 표준 중 일부의 경우, 각각을 유니 코드로 변환한다는 것은 원래 표준의 각 코드 포인트에 상수를 추가하는 것을 의미했으며, 다시 변환하는 것은 동일한 상수를 빼는 것을 의미했습니다. ASCII 및 ISO-8859-1의 경우 상수는 0입니다. ISO-8859-5의 경우 (키릴 자모) 상수는 864입니다. 히브리어 (ISO-8859-8)의 경우 1488입니다. 태국어 (ISO-8859-11), 3424; 기타 등등. 이로 인해 변환이 쉬워지고 유니 코드 채택이 용이 해졌습니다.</target>
        </trans-unit>
        <trans-unit id="292b5cfbcdb907b6b9b2852bab43a1e41959e1df" translate="yes" xml:space="preserve">
          <source>Unicode also defines various</source>
          <target state="translated">유니 코드는 또한 다양한 정의</target>
        </trans-unit>
        <trans-unit id="bfb017bed191925e52b6029168924ebfe8c5d26c" translate="yes" xml:space="preserve">
          <source>Unicode and EBCDIC</source>
          <target state="translated">유니 코드 및 EBCDIC</target>
        </trans-unit>
        <trans-unit id="e27520c25eb75e7d79e8f990eeb1be4ae1df41df" translate="yes" xml:space="preserve">
          <source>Unicode and ISO/IEC 10646 are coordinated standards that unify almost all other modern character set standards, covering more than 80 writing systems and hundreds of languages, including all commercially-important modern languages. All characters in the largest Chinese, Japanese, and Korean dictionaries are also encoded. The standards will eventually cover almost all characters in more than 250 writing systems and thousands of languages. Unicode 1.0 was released in October 1991, and 6.0 in October 2010.</source>
          <target state="translated">유니 코드 및 ISO / IEC 10646은 상업적으로 중요한 모든 현대 언어를 포함하여 80 개 이상의 필기 시스템과 수백 개의 언어를 포괄하는 거의 모든 다른 현대 문자 집합 표준을 통합하는 조정 된 표준입니다. 가장 큰 중국어, 일본어 및 한국어 사전의 모든 문자도 인코딩됩니다. 이 표준은 결국 250 개 이상의 필기 시스템과 수천 개의 언어로 된 거의 모든 문자를 포괄합니다. 유니 코드 1.0은 1991 년 10 월에, 6.0은 2010 년 10 월에 릴리스되었습니다.</target>
        </trans-unit>
        <trans-unit id="35759c0ae04781f6ce2a8261ef308a0d62267332" translate="yes" xml:space="preserve">
          <source>Unicode and Localisation Support</source>
          <target state="translated">유니 코드 및 지역화 지원</target>
        </trans-unit>
        <trans-unit id="c79347889e0d28fc8f7e3b48dc5c985da6b9c2b3" translate="yes" xml:space="preserve">
          <source>Unicode and Multilingual Support in HTML, Fonts, Web Browsers and Other Applications</source>
          <target state="translated">HTML, 글꼴, 웹 브라우저 및 기타 응용 프로그램에서 유니 코드 및 다국어 지원</target>
        </trans-unit>
        <trans-unit id="aa0a00bb85a8ade7272b8fa2d081ab3abd746b2c" translate="yes" xml:space="preserve">
          <source>Unicode and UTF</source>
          <target state="translated">유니 코드 및 UTF</target>
        </trans-unit>
        <trans-unit id="8e9632880dc5b73eee711bbb8acae51558160af7" translate="yes" xml:space="preserve">
          <source>Unicode and UTF-8</source>
          <target state="translated">유니 코드 및 UTF-8</target>
        </trans-unit>
        <trans-unit id="814213da4f2b17caa9167081f902458536e3ac5c" translate="yes" xml:space="preserve">
          <source>Unicode casing is very different from ASCII casing.</source>
          <target state="translated">유니 코드 케이싱은 ASCII 케이싱과 매우 다릅니다.</target>
        </trans-unit>
        <trans-unit id="3db087027c1f3fb2dafc91bf1aec8e28ed66555f" translate="yes" xml:space="preserve">
          <source>Unicode character database</source>
          <target state="translated">유니 코드 문자 데이터베이스</target>
        </trans-unit>
        <trans-unit id="90ce74ac0f978040e744ea5f9ee3a9fc0fdd5b56" translate="yes" xml:space="preserve">
          <source>Unicode character properties that are NOT accepted by Perl</source>
          <target state="translated">Perl이 허용하지 않는 유니 코드 문자 특성</target>
        </trans-unit>
        <trans-unit id="131ad96e9210c062a5a91bbff68adb3c52f574b9" translate="yes" xml:space="preserve">
          <source>Unicode characters are assigned to</source>
          <target state="translated">유니 코드 문자는</target>
        </trans-unit>
        <trans-unit id="9cd8bdcde375ab8cc6d64998c61f22e2b1db366b" translate="yes" xml:space="preserve">
          <source>Unicode characters have a Unicode name and numeric code point (ordinal) value. Use the &lt;code&gt;\N{}&lt;/code&gt; construct to specify a character by either of these values. Certain sequences of characters also have names.</source>
          <target state="translated">유니 코드 문자는 유니 코드 이름과 숫자 코드 포인트 (정수) 값을 갖습니다. 이러한 값 중 하나로 문자를 지정 하려면 &lt;code&gt;\N{}&lt;/code&gt; 구문을 사용하십시오. 특정 문자 시퀀스에도 이름이 있습니다.</target>
        </trans-unit>
        <trans-unit id="210080ef48f936087dda80492d9856fe5ec4b9bc" translate="yes" xml:space="preserve">
          <source>Unicode classes</source>
          <target state="translated">유니 코드 클래스</target>
        </trans-unit>
        <trans-unit id="0f01459324a40b9e6a3a0e387cbfebfba5b6c62c" translate="yes" xml:space="preserve">
          <source>Unicode code points versus EBCDIC code points</source>
          <target state="translated">유니 코드 코드 포인트와 EBCDIC 코드 포인트</target>
        </trans-unit>
        <trans-unit id="7625e9ef1dd87171eb4d5354c03dd9be33744a1d" translate="yes" xml:space="preserve">
          <source>Unicode codepoint</source>
          <target state="translated">유니 코드 코드 포인트</target>
        </trans-unit>
        <trans-unit id="329b02599470f15ed9e34472928160323f9fb081" translate="yes" xml:space="preserve">
          <source>Unicode coding schemes other than native utf8 are supported by Encode::Unicode, which will be autoloaded on demand.</source>
          <target state="translated">네이티브 utf8 이외의 유니 코드 코딩 체계는 요청시 자동로드되는 Encode :: Unicode에서 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="106885fd8f00b6d1d3909f50579c6a1e81f50c34" translate="yes" xml:space="preserve">
          <source>Unicode concept which most often is equal to uppercase, but for certain characters like the German &quot;sharp s&quot; there is a difference.</source>
          <target state="translated">대부분 대문자와 같은 유니 코드 개념이지만 독일어 &quot;sharp s&quot;와 같은 특정 문자에는 차이가 있습니다.</target>
        </trans-unit>
        <trans-unit id="be2f011fe43db39f9182b02fbc6580c3cfe62024" translate="yes" xml:space="preserve">
          <source>Unicode considers many code points to be illegal, or to be avoided. Perl generally accepts them, once they have passed through any input filters that may try to exclude them. These have been discussed above (see &quot;Surrogates&quot; under UTF-16 in &lt;a href=&quot;#Unicode-Encodings&quot;&gt;&quot;Unicode Encodings&quot;&lt;/a&gt;, &lt;a href=&quot;#Noncharacter-code-points&quot;&gt;&quot;Noncharacter code points&quot;&lt;/a&gt;, and &lt;a href=&quot;#Beyond-Unicode-code-points&quot;&gt;&quot;Beyond Unicode code points&quot;&lt;/a&gt;).</source>
          <target state="translated">유니 코드는 많은 코드 포인트를 불법이거나 피하는 것으로 간주합니다. Perl은 일반적으로이를 제외하려고 시도 할 수있는 입력 필터를 통과하면이를 승인합니다. 위에서 논의한 바 있습니다 ( &lt;a href=&quot;#Unicode-Encodings&quot;&gt;&quot;유니 코드 인코딩&quot;&lt;/a&gt; , &lt;a href=&quot;#Noncharacter-code-points&quot;&gt;&quot;비 문자 코드 포인트&quot;&lt;/a&gt; 및 &lt;a href=&quot;#Beyond-Unicode-code-points&quot;&gt;&quot;유니 코드 코드 포인트 이상&lt;/a&gt; &quot;에서 UTF-16의 &quot;대리&quot;참조 ).</target>
        </trans-unit>
        <trans-unit id="d49075f8dbc705f2f67ea7272b64074e286787f2" translate="yes" xml:space="preserve">
          <source>Unicode defines a fourth boundary type, accessible through the &lt;a href=&quot;http://search.cpan.org/perldoc/Unicode::LineBreak&quot;&gt;Unicode::LineBreak&lt;/a&gt; module.</source>
          <target state="translated">유니 코드는 &lt;a href=&quot;http://search.cpan.org/perldoc/Unicode::LineBreak&quot;&gt;Unicode :: LineBreak&lt;/a&gt; 모듈을 통해 액세스 할 수있는 네 번째 경계 유형을 정의 합니다.</target>
        </trans-unit>
        <trans-unit id="07aa50c4f0010de0db76a15f32c4e153b24a7275" translate="yes" xml:space="preserve">
          <source>Unicode defines all its properties in the compound form, so all single-form properties are Perl extensions. Most of these are just synonyms for the Unicode ones, but some are genuine extensions, including several that are in the compound form. And quite a few of these are actually recommended by Unicode (in &lt;a href=&quot;http://www.unicode.org/reports/tr18&quot;&gt;http://www.unicode.org/reports/tr18&lt;/a&gt;).</source>
          <target state="translated">유니 코드는 모든 속성을 복합 형식으로 정의하므로 모든 단일 양식 속성은 Perl 확장입니다. 이들 중 대부분은 유니 코드와 동의어이지만 일부는 복합 형식의 일부를 포함하여 진정한 확장입니다. 그리고 이들 중 상당수는 실제로 유니 코드 ( &lt;a href=&quot;http://www.unicode.org/reports/tr18&quot;&gt;http://www.unicode.org/reports/tr18&lt;/a&gt; ) 에서 권장합니다 .</target>
        </trans-unit>
        <trans-unit id="83740583eabf50f236d63ef1d8d25274281fb0cf" translate="yes" xml:space="preserve">
          <source>Unicode defines all its properties in the compound form, so all single-form properties are Perl extensions. Most of these are just synonyms for the Unicode ones, but some are genuine extensions, including several that are in the compound form. And quite a few of these are actually recommended by Unicode (in &lt;a href=&quot;https://www.unicode.org/reports/tr18&quot;&gt;https://www.unicode.org/reports/tr18&lt;/a&gt;).</source>
          <target state="translated">유니 코드는 모든 속성을 복합 형식으로 정의하므로 모든 단일 형식 속성은 Perl 확장입니다. 이들 중 대부분은 유니 코드의 동의어 일 뿐이지 만 일부는 복합 형식의 일부를 포함하여 진정한 확장입니다. 그리고 이들 중 상당수는 실제로 유니 코드에서 권장합니다 ( &lt;a href=&quot;https://www.unicode.org/reports/tr18&quot;&gt;https://www.unicode.org/reports/tr18&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="8557c4367cf0c9f30d95a470ee521928d669fb7c" translate="yes" xml:space="preserve">
          <source>Unicode defines characters like &lt;code&gt;LATIN CAPITAL LETTER A&lt;/code&gt; or &lt;code&gt;GREEK
SMALL LETTER ALPHA&lt;/code&gt; and unique numbers for the characters, in this case 0x0041 and 0x03B1, respectively. These unique numbers are called</source>
          <target state="translated">유니 코드는 &lt;code&gt;LATIN CAPITAL LETTER A&lt;/code&gt; 또는 &lt;code&gt;GREEK SMALL LETTER ALPHA&lt;/code&gt; 와 같은 문자와 문자의 고유 번호 (이 경우 각각 0x0041 및 0x03B1)를 정의합니다. 이 고유 번호는</target>
        </trans-unit>
        <trans-unit id="acaff2c7ef0e4ff533eb55c7b82bb8cb537cf6b5" translate="yes" xml:space="preserve">
          <source>Unicode does define several other decimal--and numeric--characters besides the familiar 0 to 9, such as the Arabic and Indic digits. Perl does not support string-to-number conversion for digits other than ASCII &lt;code&gt;0&lt;/code&gt; to &lt;code&gt;9&lt;/code&gt; (and ASCII &lt;code&gt;a&lt;/code&gt; to &lt;code&gt;f&lt;/code&gt; for hexadecimal). To get safe conversions from any Unicode string, use &lt;a href=&quot;Unicode::UCD#num%28%29&quot;&gt;&quot;num()&quot; in Unicode::UCD&lt;/a&gt;.</source>
          <target state="translated">유니 코드는 아랍어 및 인도 숫자와 같이 익숙한 0에서 9까지의 다른 소수 및 숫자 문자를 정의합니다. Perl은 ASCII &lt;code&gt;0&lt;/code&gt; 에서 &lt;code&gt;9&lt;/code&gt; ( 16 진수의 경우 ASCII &lt;code&gt;a&lt;/code&gt; 에서 &lt;code&gt;f&lt;/code&gt; ) 이외의 숫자에 대한 문자열-숫자 변환을 지원하지 않습니다 . 유니 코드 문자열에서 안전한 변환을 얻으려면 &lt;a href=&quot;Unicode::UCD#num%28%29&quot;&gt;Unicode :: UCD에서 &quot;num ()&quot;을&lt;/a&gt; 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="66287c5bc6e75d359bae32c20cfc35103e105bf3" translate="yes" xml:space="preserve">
          <source>Unicode does define several other decimal--and numeric--characters besides the familiar 0 to 9, such as the Arabic and Indic digits. Perl does not support string-to-number conversion for digits other than ASCII &lt;code&gt;0&lt;/code&gt; to &lt;code&gt;9&lt;/code&gt; (and ASCII &lt;code&gt;a&lt;/code&gt; to &lt;code&gt;f&lt;/code&gt; for hexadecimal). To get safe conversions from any Unicode string, use &lt;a href=&quot;unicode/ucd#num()&quot;&gt;num() in Unicode::UCD&lt;/a&gt;.</source>
          <target state="translated">유니 코드는 아라비아 숫자 및 인도 숫자와 같이 친숙한 0에서 9까지의 다른 10 진수 및 숫자를 정의합니다. 펄은 ASCII 이외의 숫자에 대한 문자열 - 투 - 수 전환 지원하지 않습니다 &lt;code&gt;0&lt;/code&gt; 으로 &lt;code&gt;9&lt;/code&gt; (및 ASCII 에 &lt;code&gt;f&lt;/code&gt; 진수를 들어). 유니 코드 문자열에서 안전하게 변환하려면 &lt;a href=&quot;unicode/ucd#num()&quot;&gt;Unicode :: UCD에서 num ()을&lt;/a&gt; 사용하십시오 . &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e0b4309884526bd11fe1ab30cc9fc6ed43648809" translate="yes" xml:space="preserve">
          <source>Unicode form that is useful when comparing strings regardless of case, as certain characters have complex one-to-many case mappings. Primarily a variant of lowercase.</source>
          <target state="translated">특정 문자에는 복잡한 일대 다 사례 매핑이 있으므로 대소 문자와 상관없이 문자열을 비교할 때 유용한 유니 코드 형식입니다. 주로 소문자의 변형입니다.</target>
        </trans-unit>
        <trans-unit id="71079ed61722f43474765527d68998144c7665d4" translate="yes" xml:space="preserve">
          <source>Unicode furnishes the &lt;code&gt;Age&lt;/code&gt; property from which this is derived. The problem with Age is that a strict interpretation of it (which Perl takes) has it matching the precise release a code point's meaning is introduced in. Thus &lt;code&gt;U+0041&lt;/code&gt; would match only 1.1; and &lt;code&gt;U+1EFF&lt;/code&gt; only 5.1. This is not usually what you want.</source>
          <target state="translated">유니 코드 는 이것이 파생 된 &lt;code&gt;Age&lt;/code&gt; 속성을 제공합니다 . Age의 문제점은 (Perl이 취하는) 엄격한 해석이 코드 포인트의 의미가 도입 된 정확한 릴리스와 일치한다는 것입니다. 따라서 &lt;code&gt;U+0041&lt;/code&gt; 은 1.1 과만 일치합니다. 및 &lt;code&gt;U+1EFF&lt;/code&gt; 에만 5.1. 이것은 일반적으로 원하는 것이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="fd3ab6b6f70f7431b1416e0f9107c1af48c38649" translate="yes" xml:space="preserve">
          <source>Unicode has some property-value pairs that currently don't match anything. This happens generally either because they are obsolete, or they exist for symmetry with other forms, but no language has yet been encoded that uses them. In this version of Unicode, the following match zero code points:</source>
          <target state="translated">유니 코드에는 현재 일치하지 않는 속성-값 쌍이 있습니다. 이것은 일반적으로 더 이상 사용되지 않거나 다른 형식과의 대칭을 위해 존재하지만이를 사용하는 언어는 아직 인코딩되지 않았기 때문에 발생합니다. 이 버전의 유니 코드에서 다음은 제로 코드 포인트와 일치합니다.</target>
        </trans-unit>
        <trans-unit id="598e8ae9c96e08e40d6e1a738b55c351268bc51b" translate="yes" xml:space="preserve">
          <source>Unicode has three pseudo scripts that are handled specially.</source>
          <target state="translated">유니 코드에는 특별히 처리되는 세 개의 의사 스크립트가 있습니다.</target>
        </trans-unit>
        <trans-unit id="73c49c9d36b230f185c7169c7475e8856ddbd520" translate="yes" xml:space="preserve">
          <source>Unicode in Perl on EBCDIC</source>
          <target state="translated">EBCDIC에서 Perl의 유니 코드</target>
        </trans-unit>
        <trans-unit id="5a2ff10d38459692f18fa8f0d5e12e0027770ead" translate="yes" xml:space="preserve">
          <source>Unicode is a character set standard which plans to codify all of the writing systems of the world, plus many other symbols.</source>
          <target state="translated">유니 코드는 세계의 모든 쓰기 시스템과 기타 여러 기호를 체계화 할 문자 세트 표준입니다.</target>
        </trans-unit>
        <trans-unit id="3bb1c5615f2383d427b4613073ef1ec435b5138c" translate="yes" xml:space="preserve">
          <source>Unicode is a character set that can represent most characters in most of the world's languages, providing room for over one million different characters. Unicode 3.1 specifies 94,140 characters: The Basic Latin characters are assigned to the numbers 0 - 127. The Latin-1 Supplement with characters that are used in several European languages is in the next range, up to 255. After some more Latin extensions we find the character sets from languages using non-Roman alphabets, interspersed with a variety of symbol sets such as currency symbols, Zapf Dingbats or Braille. (You might want to visit &lt;a href=&quot;http://www.unicode.org/&quot;&gt;http://www.unicode.org/&lt;/a&gt; for a look at some of them - my personal favourites are Telugu and Kannada.)</source>
          <target state="translated">유니 코드는 전 세계 대부분의 언어에서 대부분의 문자를 나타낼 수있는 문자 집합으로, 백만 가지 이상의 문자를위한 공간을 제공합니다. 유니 코드 3.1은 94,140자를 지정합니다. 기본 라틴 문자는 0-127의 숫자로 지정됩니다. 여러 유럽 언어로 사용되는 문자가 포함 된 Latin-1 Supplement는 다음 범위에 있으며 최대 255 개입니다. 비 로마자 알파벳을 사용하는 언어로 된 통화 세트, 통화 기호, Zapf Dingbats 또는 점자와 같은 다양한 기호 세트가 산재되어 있습니다. ( &lt;a href=&quot;http://www.unicode.org/&quot;&gt;http://www.unicode.org/&lt;/a&gt; 를 방문 하여 그중 일부를 살펴볼 수도 있습니다. 개인 즐겨 찾기는 Telugu와 Kannada입니다.)</target>
        </trans-unit>
        <trans-unit id="918d612f1c2574dce41b14dc2be8c0387758201b" translate="yes" xml:space="preserve">
          <source>Unicode is a character set that can represent most characters in most of the world's languages, providing room for over one million different characters. Unicode 3.1 specifies 94,140 characters: The Basic Latin characters are assigned to the numbers 0 - 127. The Latin-1 Supplement with characters that are used in several European languages is in the next range, up to 255. After some more Latin extensions we find the character sets from languages using non-Roman alphabets, interspersed with a variety of symbol sets such as currency symbols, Zapf Dingbats or Braille. (You might want to visit &lt;a href=&quot;https://www.unicode.org/&quot;&gt;https://www.unicode.org/&lt;/a&gt; for a look at some of them - my personal favourites are Telugu and Kannada.)</source>
          <target state="translated">유니 코드는 대부분의 전 세계 언어로 대부분의 문자를 나타낼 수있는 문자 집합으로 백만 개 이상의 다른 문자를위한 공간을 제공합니다. 유니 코드 3.1은 94,140자를 지정합니다. 기본 라틴 문자는 0-127의 숫자에 할당됩니다. 여러 유럽 언어에서 사용되는 문자가 포함 된 Latin-1 Supplement는 다음 범위 인 최대 255입니다. 라틴어 확장을 몇 개 더 추가하면 다음을 찾을 수 있습니다. 비 로마어 알파벳을 사용하는 언어의 문자 집합, 통화 기호, Zapf Dingbats 또는 Braille과 같은 다양한 기호 집합이 산재되어 있습니다. ( &lt;a href=&quot;https://www.unicode.org/&quot;&gt;https://www.unicode.org/&lt;/a&gt; 를 방문 하여 일부를 살펴볼 수 있습니다. 개인적으로 가장 좋아하는 것은 Telugu와 Kannada입니다.)</target>
        </trans-unit>
        <trans-unit id="bb4b52a0e0d40f8cd4680e731fa8661db40b7bfb" translate="yes" xml:space="preserve">
          <source>Unicode is a comprehensive standard. It specifies many things outside the scope of Perl, such as how to display sequences of characters. For a full discussion of all aspects of Unicode, see &lt;a href=&quot;http://www.unicode.org&quot;&gt;http://www.unicode.org&lt;/a&gt;.</source>
          <target state="translated">유니 코드는 포괄적 인 표준입니다. 일련의 문자를 표시하는 방법과 같이 Perl 범위 밖에서 많은 것을 지정합니다. 유니 코드의 모든 측면에 대한 자세한 내용은 &lt;a href=&quot;http://www.unicode.org&quot;&gt;http://www.unicode.org를&lt;/a&gt; 참조하십시오 . .</target>
        </trans-unit>
        <trans-unit id="0004a5b6be77b386fdac7a26a14cd8154c46e916" translate="yes" xml:space="preserve">
          <source>Unicode is a comprehensive standard. It specifies many things outside the scope of Perl, such as how to display sequences of characters. For a full discussion of all aspects of Unicode, see &lt;a href=&quot;https://www.unicode.org&quot;&gt;https://www.unicode.org&lt;/a&gt;.</source>
          <target state="translated">유니 코드는 포괄적 인 표준입니다. 문자 시퀀스를 표시하는 방법과 같이 Perl 범위 밖의 많은 것을 지정합니다. 유니 코드의 모든 측면에 대한 자세한 내용은 &lt;a href=&quot;https://www.unicode.org&quot;&gt;https://www.unicode.org를&lt;/a&gt; 참조 하십시오 .</target>
        </trans-unit>
        <trans-unit id="6b43e74b6aa7b2acf2d7d34cb97f083e42a3eb18" translate="yes" xml:space="preserve">
          <source>Unicode is a new and complex technology and one may easily overlook certain security pitfalls. See &lt;a href=&quot;perluniintro&quot;&gt;perluniintro&lt;/a&gt; for an overview and &lt;a href=&quot;perlunicode&quot;&gt;perlunicode&lt;/a&gt; for details, and &lt;a href=&quot;perlunicode#Security-Implications-of-Unicode&quot;&gt;&quot;Security Implications of Unicode&quot; in perlunicode&lt;/a&gt; for security implications in particular.</source>
          <target state="translated">유니 코드는 새롭고 복잡한 기술이며 특정 보안 위험을 쉽게 간과 할 수 있습니다. 참조 &lt;a href=&quot;perluniintro&quot;&gt;perluniintro&lt;/a&gt; 개요와 대한 &lt;a href=&quot;perlunicode&quot;&gt;perlunicode&lt;/a&gt; 자세한 내용 및 &lt;a href=&quot;perlunicode#Security-Implications-of-Unicode&quot;&gt;perlunicode에서 &quot;유니 코드의 보안 문제&quot;&lt;/a&gt; 특히 보안 문제에 대한.</target>
        </trans-unit>
        <trans-unit id="38d8bac67762b71e3e301bd389dd5bf647e3a7f7" translate="yes" xml:space="preserve">
          <source>Unicode is a new and complex technology and one may easily overlook certain security pitfalls. See &lt;a href=&quot;perluniintro&quot;&gt;perluniintro&lt;/a&gt; for an overview and &lt;a href=&quot;perlunicode&quot;&gt;perlunicode&lt;/a&gt; for details, and &lt;a href=&quot;perlunicode#Security-Implications-of-Unicode&quot;&gt;Security Implications of Unicode in perlunicode&lt;/a&gt; for security implications in particular.</source>
          <target state="translated">유니 코드는 새롭고 복잡한 기술이며 특정 보안 위험을 간과 할 수 있습니다. 참조 &lt;a href=&quot;perluniintro&quot;&gt;perluniintro&lt;/a&gt; 개요와 대한 &lt;a href=&quot;perlunicode&quot;&gt;perlunicode&lt;/a&gt; 자세한 내용 및 &lt;a href=&quot;perlunicode#Security-Implications-of-Unicode&quot;&gt;perlunicode 유니 코드의 보안 문제&lt;/a&gt; , 특히 보안 문제에 대한.</target>
        </trans-unit>
        <trans-unit id="2819bd58737a8580070f8ba307d9387529fe1cef" translate="yes" xml:space="preserve">
          <source>Unicode is encoded using several competing encodings, of which UTF-8 is the most used. In a Unicode encoding, multiple subsequent bytes can be used to store a single code point, or simply: character.</source>
          <target state="translated">유니 코드는 여러 경쟁 인코딩을 사용하여 인코딩되며 그 중 UTF-8이 가장 많이 사용됩니다. 유니 코드 인코딩에서 여러 개의 후속 바이트를 사용하여 단일 코드 포인트를 저장하거나 간단히 문자를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="eebcf5b59ea874094c8b9d89a4f67a602ded5273" translate="yes" xml:space="preserve">
          <source>Unicode is stored in &lt;code&gt;$oswBuffer&lt;/code&gt;. &lt;code&gt;$lwBufSize&lt;/code&gt; and &lt;code&gt;$olwOutLength&lt;/code&gt; are measured as number of &lt;code&gt;WCHAR&lt;/code&gt;s.</source>
          <target state="translated">유니 코드는 &lt;code&gt;$oswBuffer&lt;/code&gt; 저장됩니다 . &lt;code&gt;$lwBufSize&lt;/code&gt; 및 &lt;code&gt;$olwOutLength&lt;/code&gt; 는 &lt;code&gt;WCHAR&lt;/code&gt; 수로 측정됩니다 .</target>
        </trans-unit>
        <trans-unit id="5a66fde7942a6271294a3a5979cbe3017c3d5acd" translate="yes" xml:space="preserve">
          <source>Unicode is supported on EBCDIC platforms. See &lt;a href=&quot;perlebcdic&quot;&gt;perlebcdic&lt;/a&gt;.</source>
          <target state="translated">유니 코드는 EBCDIC 플랫폼에서 지원됩니다. &lt;a href=&quot;perlebcdic&quot;&gt;perlebcdic를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="9649076a02c41263127b2e79657012b62bed018f" translate="yes" xml:space="preserve">
          <source>Unicode non-character U+%X is not recommended for open interchange</source>
          <target state="translated">유니 코드 비 문자 U + % X는 개방형 교환에 권장되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4276af257ec826541933ef5d517bc7bb403fdca7" translate="yes" xml:space="preserve">
          <source>Unicode only allows code points up to 0x10FFFF, but Perl allows much larger ones. Up till Perl 5.28, it was allowed to use code points exceeding the maximum value of an integer (&lt;code&gt;IV_MAX&lt;/code&gt;). However, that did break the perl interpreter in some constructs, including causing it to hang in a few cases. The known problem areas were in &lt;code&gt;tr///&lt;/code&gt;, regular expression pattern matching using quantifiers, as quote delimiters in &lt;code&gt;q&lt;i&gt;X&lt;/i&gt;...&lt;i&gt;X&lt;/i&gt;&lt;/code&gt; (where</source>
          <target state="translated">유니 코드는 최대 0x10FFFF의 코드 포인트 만 허용하지만 Perl은 훨씬 더 큰 코드 포인트를 허용합니다. Perl 5.28까지는 정수의 최대 값 ( &lt;code&gt;IV_MAX&lt;/code&gt; )을 초과하는 코드 포인트를 사용할 수있었습니다 . 그러나 이로 인해 일부 구조에서 perl 인터프리터가 중단되었습니다. 공지 된 문제 영역이 있었다 &lt;code&gt;tr///&lt;/code&gt; 에서 인용 구분자로서 한정사를 사용 정규식 패턴 매칭, &lt;code&gt;q&lt;i&gt;X&lt;/i&gt;...&lt;i&gt;X&lt;/i&gt;&lt;/code&gt; (단,</target>
        </trans-unit>
        <trans-unit id="989d0062ad097f9dec3fa95782856724eb6165aa" translate="yes" xml:space="preserve">
          <source>Unicode promises that the set of code points that have these two properties will never change, so something that is not quoted in v5.16 will never need to be quoted in any future Perl release. (Not all the code points that match Pattern_Syntax have actually had characters assigned to them; so there is room to grow, but they are quoted whether assigned or not. Perl, of course, would never use an unassigned code point as an actual metacharacter.)</source>
          <target state="translated">유니 코드는 이러한 두 가지 속성을 가진 코드 포인트 세트가 절대 변경되지 않기 때문에 v5.16에서 인용되지 않은 것은 향후 Perl 릴리스에서 인용 할 필요가 없습니다. (Pattern_Syntax와 일치하는 모든 코드 포인트에 실제로 문자가 할당 된 것은 아니므로 확장 할 여지가 있지만 할당 여부에 따라 인용됩니다. 물론 Perl은 할당되지 않은 코드 포인트를 실제 메타 문자로 사용하지 않습니다. )</target>
        </trans-unit>
        <trans-unit id="fb2ca4e28ea7e22cfa06c89ba6c3b93dca994a19" translate="yes" xml:space="preserve">
          <source>Unicode properties are defined (surprise!) only on Unicode code points. Starting in v5.20, when matching against &lt;code&gt;\p&lt;/code&gt; and &lt;code&gt;\P&lt;/code&gt; , Perl treats non-Unicode code points (those above the legal Unicode maximum of 0x10FFFF) as if they were typical unassigned Unicode code points.</source>
          <target state="translated">유니 코드 속성은 유니 코드 코드 포인트에서만 정의됩니다 (놀람!). v5.20부터 &lt;code&gt;\p&lt;/code&gt; 및 &lt;code&gt;\P&lt;/code&gt; 와 일치 할 때 Perl은 비 유니 코드 코드 포인트 (법적 유니 코드 최대 값 0x10FFFF 이상)를 할당되지 않은 일반적인 유니 코드 코드 포인트처럼 취급합니다.</target>
        </trans-unit>
        <trans-unit id="a1b191780dd618f1a1adb03d6a73e2206a215bac" translate="yes" xml:space="preserve">
          <source>Unicode properties are defined (surprise!) only on Unicode code points. Starting in v5.20, when matching against &lt;code&gt;\p&lt;/code&gt; and &lt;code&gt;\P&lt;/code&gt;, Perl treats non-Unicode code points (those above the legal Unicode maximum of 0x10FFFF) as if they were typical unassigned Unicode code points.</source>
          <target state="translated">유니 코드 속성은 유니 코드 코드 포인트에서만 정의됩니다 (놀랍습니다!). v5.20부터 &lt;code&gt;\p&lt;/code&gt; 및 &lt;code&gt;\P&lt;/code&gt; 에 대해 일치 할 때 Perl은 비 유니 코드 코드 포인트 (적법한 유니 코드 최대 값 인 0x10FFFF 이상)를 일반적인 할당되지 않은 유니 코드 코드 포인트 인 것처럼 처리합니다.</target>
        </trans-unit>
        <trans-unit id="4421ab9f1aa61dc9cbda1e9f59175c1a3635d1e0" translate="yes" xml:space="preserve">
          <source>Unicode property wildcard not terminated</source>
          <target state="translated">유니 코드 속성 와일드 카드가 종료되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="139a9bb1fddefbaa23b5411336f2d45c5af1add3" translate="yes" xml:space="preserve">
          <source>Unicode publishes the names of blocks in two different styles, though the two are equivalent under Unicode's loose matching rules.</source>
          <target state="translated">유니 코드는 블록 이름을 서로 다른 두 가지 스타일로 게시하지만 둘은 유니 코드의 느슨한 일치 규칙에서 동일합니다.</target>
        </trans-unit>
        <trans-unit id="38ecc57a7a45e8fa0530ba908225186656979efa" translate="yes" xml:space="preserve">
          <source>Unicode rules are used for the case change.</source>
          <target state="translated">케이스 변경에는 유니 코드 규칙이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="1b41da839119c4860ed2bab536f19149822ad0f7" translate="yes" xml:space="preserve">
          <source>Unicode string</source>
          <target state="translated">유니 코드 문자열</target>
        </trans-unit>
        <trans-unit id="f63eb0aa495029030f8880e8159d4eda857dd8ed" translate="yes" xml:space="preserve">
          <source>Unicode string properties are not implemented in (?[...]) in regex; marked by &amp;lt;-- HERE in m/%s/</source>
          <target state="translated">유니 코드 문자열 속성은 정규식의 (? [...])에서 구현되지 않습니다. &amp;lt;-HERE (m / % s /)로 표시</target>
        </trans-unit>
        <trans-unit id="7088ba3066aa65d6bcc96771fbb92a42fd96dcd6" translate="yes" xml:space="preserve">
          <source>Unicode support is an extensive requirement. While Perl does not implement the Unicode standard or the accompanying technical reports from cover to cover, Perl does support many Unicode features.</source>
          <target state="translated">유니 코드 지원은 광범위한 요구 사항입니다. Perl은 유니 코드 표준 또는 그에 따른 기술 보고서를 구현하지 않지만 많은 유니 코드 기능을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="92c5fb67050f7cc6a07c62ea0f43698241d0a5b2" translate="yes" xml:space="preserve">
          <source>Unicode surrogate U+%X is illegal in UTF-8</source>
          <target state="translated">유니 코드 대리 U + % X는 UTF-8에서 유효하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b8b243e5f3e426dd36737b42e29d2ec9970a7c1a" translate="yes" xml:space="preserve">
          <source>Unicode, of course, assigns each of those code points a particular meaning (along with ones above 255). To preserve backward compatibility, Perl only uses the Unicode meanings when there is some indication that Unicode is what is intended; otherwise the non-ASCII code points remain treated as if they are unassigned.</source>
          <target state="translated">물론 유니 코드는 이러한 각 코드 포인트에 특정 의미를 부여합니다 (255 이상과 함께). 이전 버전과의 호환성을 유지하기 위해 Perl은 유니 코드가 의도 된 것임을 나타내는 표시가있을 때 유니 코드 의미 만 사용합니다. 그렇지 않으면 비 ASCII 코드 포인트는 할당되지 않은 것처럼 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="21276899f4cb4b0159879360c7526c4fe6c28316" translate="yes" xml:space="preserve">
          <source>Unicode/Collate</source>
          <target state="translated">Unicode/Collate</target>
        </trans-unit>
        <trans-unit id="37148638183749a1c0b03d85014634d4e43c64c4" translate="yes" xml:space="preserve">
          <source>Unicode/Collate/Foo.txt</source>
          <target state="translated">Unicode/Collate/Foo.txt</target>
        </trans-unit>
        <trans-unit id="f77e952a14d870cb3ae7b18f391e8c5f3d325575" translate="yes" xml:space="preserve">
          <source>Unicode::Collate</source>
          <target state="translated">Unicode::Collate</target>
        </trans-unit>
        <trans-unit id="3ff519c896603d01c9e76e4f19191f11d112327a" translate="yes" xml:space="preserve">
          <source>Unicode::Collate - Unicode Collation Algorithm</source>
          <target state="translated">Unicode :: Collate-유니 코드 데이터 정렬 알고리즘</target>
        </trans-unit>
        <trans-unit id="fdf0d75274a879104b0f1f8bc64ee18ff02c5b30" translate="yes" xml:space="preserve">
          <source>Unicode::Collate::CJK::Big5</source>
          <target state="translated">Unicode::Collate::CJK::Big5</target>
        </trans-unit>
        <trans-unit id="1d6f6aa49ee6fad5eca6f35948b7e1bb0ab65190" translate="yes" xml:space="preserve">
          <source>Unicode::Collate::CJK::Big5 - weighting CJK Unified Ideographs for Unicode::Collate</source>
          <target state="translated">Unicode :: Collate :: CJK :: Big5-Unicode :: Collate에 대한 CJK 통합 표의 문자 가중치 부여</target>
        </trans-unit>
        <trans-unit id="5df783cdcff877161e1582e96c9fee058c8ac391" translate="yes" xml:space="preserve">
          <source>Unicode::Collate::CJK::GB2312</source>
          <target state="translated">Unicode::Collate::CJK::GB2312</target>
        </trans-unit>
        <trans-unit id="69f6a1af4b9d7847bba5939a34148141b098e758" translate="yes" xml:space="preserve">
          <source>Unicode::Collate::CJK::GB2312 - weighting CJK Unified Ideographs for Unicode::Collate</source>
          <target state="translated">Unicode :: Collate :: CJK :: GB2312-Unicode :: Collate에 대한 CJK 통합 표의 문자 가중치 부여</target>
        </trans-unit>
        <trans-unit id="6a120ddf4b189ce790913ac61694171437406f3d" translate="yes" xml:space="preserve">
          <source>Unicode::Collate::CJK::JISX0208</source>
          <target state="translated">Unicode::Collate::CJK::JISX0208</target>
        </trans-unit>
        <trans-unit id="52137c04544cacc73939ff1aee0c874c9d8fee08" translate="yes" xml:space="preserve">
          <source>Unicode::Collate::CJK::JISX0208 - weighting JIS KANJI for Unicode::Collate</source>
          <target state="translated">Unicode :: Collate :: CJK :: JISX0208-Unicode :: Collate에 대한 JIS KANJI 가중치 부여</target>
        </trans-unit>
        <trans-unit id="522cc80239808b956014178ec75f366b2cd491f0" translate="yes" xml:space="preserve">
          <source>Unicode::Collate::CJK::Korean</source>
          <target state="translated">Unicode::Collate::CJK::Korean</target>
        </trans-unit>
        <trans-unit id="0ac8b48e92e15bda76c4fcc728f48f96352b283f" translate="yes" xml:space="preserve">
          <source>Unicode::Collate::CJK::Korean - weighting CJK Unified Ideographs for Unicode::Collate</source>
          <target state="translated">Unicode :: Collate :: CJK :: Korean-Unicode :: Collate에 대한 CJK 통합 표의 문자 가중치 부여</target>
        </trans-unit>
        <trans-unit id="19c59af510fe79c64655e756d8461e5d375c2fd6" translate="yes" xml:space="preserve">
          <source>Unicode::Collate::CJK::Pinyin</source>
          <target state="translated">Unicode::Collate::CJK::Pinyin</target>
        </trans-unit>
        <trans-unit id="42747836215aeadf69f9c614290fca82880640f7" translate="yes" xml:space="preserve">
          <source>Unicode::Collate::CJK::Pinyin - weighting CJK Unified Ideographs for Unicode::Collate</source>
          <target state="translated">Unicode :: Collate :: CJK :: Pinyin-Unicode :: Collate에 대한 CJK 통합 표의 문자 가중치 부여</target>
        </trans-unit>
        <trans-unit id="119a4f4d104376889a668529add1217787695cd3" translate="yes" xml:space="preserve">
          <source>Unicode::Collate::CJK::Stroke</source>
          <target state="translated">Unicode::Collate::CJK::Stroke</target>
        </trans-unit>
        <trans-unit id="f4760535296459fcd8959501743735349df70437" translate="yes" xml:space="preserve">
          <source>Unicode::Collate::CJK::Stroke - weighting CJK Unified Ideographs for Unicode::Collate</source>
          <target state="translated">Unicode :: Collate :: CJK :: Stroke-Unicode :: Collate에 대한 CJK 통합 표의 문자 가중치 부여</target>
        </trans-unit>
        <trans-unit id="935469afe79a7967133cbd5dc7a19cf8e8b7b28e" translate="yes" xml:space="preserve">
          <source>Unicode::Collate::CJK::Zhuyin</source>
          <target state="translated">Unicode::Collate::CJK::Zhuyin</target>
        </trans-unit>
        <trans-unit id="6bf20cf45b8ff713b3a40392be9d33f596934776" translate="yes" xml:space="preserve">
          <source>Unicode::Collate::CJK::Zhuyin - weighting CJK Unified Ideographs for Unicode::Collate</source>
          <target state="translated">Unicode :: Collate :: CJK :: Zhuyin-Unicode :: Collate에 대한 CJK 통합 표의 문자 가중치 부여</target>
        </trans-unit>
        <trans-unit id="1a163e245e5c3cf99dc2f5ab882390d17947426d" translate="yes" xml:space="preserve">
          <source>Unicode::Collate::Locale</source>
          <target state="translated">Unicode::Collate::Locale</target>
        </trans-unit>
        <trans-unit id="001480054455d7b56706418239469b08b55ae695" translate="yes" xml:space="preserve">
          <source>Unicode::Collate::Locale - Linguistic tailoring for DUCET via Unicode::Collate</source>
          <target state="translated">Unicode :: Collate :: Locale-Unicode :: Collate를 통한 DUCET의 언어 조정</target>
        </trans-unit>
        <trans-unit id="72b47eca97eb095d02921b6571fab1a6dfdb0bc0" translate="yes" xml:space="preserve">
          <source>Unicode::Normalize</source>
          <target state="translated">Unicode::Normalize</target>
        </trans-unit>
        <trans-unit id="2e61bd2963848230702b059b3f915c279424ceeb" translate="yes" xml:space="preserve">
          <source>Unicode::Normalize - Unicode Normalization Forms</source>
          <target state="translated">유니 코드 :: 정규화-유니 코드 정규화 양식</target>
        </trans-unit>
        <trans-unit id="58e1ebb138145877210bc1aaddb6a695f639333f" translate="yes" xml:space="preserve">
          <source>Unicode::UCD</source>
          <target state="translated">Unicode::UCD</target>
        </trans-unit>
        <trans-unit id="878eb3fe5907f3dbbef3993a9d210c838c3bd0a6" translate="yes" xml:space="preserve">
          <source>Unicode::UCD - Unicode character database</source>
          <target state="translated">유니 코드 :: UCD-유니 코드 문자 데이터베이스</target>
        </trans-unit>
        <trans-unit id="b0e10771734c32d2d9e8385457afb6c4bd746163" translate="yes" xml:space="preserve">
          <source>Unicode::UCD::UnicodeVersion</source>
          <target state="translated">Unicode::UCD::UnicodeVersion</target>
        </trans-unit>
        <trans-unit id="1147d047b52e119e77fa52566535f97fa00f2d54" translate="yes" xml:space="preserve">
          <source>Unified method to both set and get options in the &lt;code&gt;SOL_SOCKET&lt;/code&gt; level. If called with one argument then &lt;a href=&quot;IO::Socket#getsockopt&quot;&gt;&quot;getsockopt&quot; in IO::Socket&lt;/a&gt; is called, otherwise &lt;a href=&quot;IO::Socket#setsockopt&quot;&gt;&quot;setsockopt&quot; in IO::Socket&lt;/a&gt; is called.</source>
          <target state="translated">&lt;code&gt;SOL_SOCKET&lt;/code&gt; 수준 에서 옵션을 설정하고 가져 오는 통합 방법 입니다. 하나의 인수로 호출하면 &lt;a href=&quot;IO::Socket#getsockopt&quot;&gt;IO :: Socket의 &quot;getsockopt&quot;&lt;/a&gt; 가 호출되고, 그렇지 않으면 &lt;a href=&quot;IO::Socket#setsockopt&quot;&gt;IO :: Socket의 &quot;setsockopt&quot;&lt;/a&gt; 가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="c884d01b9429a9f7304a835d13687b8ca5872d3c" translate="yes" xml:space="preserve">
          <source>Unified method to both set and get options in the SOL_SOCKET level. If called with one argument then getsockopt is called, otherwise setsockopt is called.</source>
          <target state="translated">SOL_SOCKET 레벨에서 옵션을 설정하고 가져 오는 통합 된 방법. 하나의 인수로 호출하면 getsockopt가 호출되고, 그렇지 않으면 setsockopt가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="238642af65f3add9fa062158d9a8954a0d8cc5fc" translate="yes" xml:space="preserve">
          <source>Unimplemented, but you can use &lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt; and the &lt;a href=&quot;carp&quot;&gt;Carp&lt;/a&gt; module to achieve similar things.</source>
          <target state="translated">구현되지 않았지만 &lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt; 와 &lt;a href=&quot;carp&quot;&gt;Carp&lt;/a&gt; 모듈을 사용하여 비슷한 것을 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e6507a9fbb8009ec64673ec8cd6b7aa40be844fe" translate="yes" xml:space="preserve">
          <source>Unimplemented, but you can use &lt;a href=&quot;perlfunc#die&quot;&gt;&quot;die&quot; in perlfunc&lt;/a&gt; and the &lt;a href=&quot;carp&quot;&gt;Carp&lt;/a&gt; module to achieve similar things.</source>
          <target state="translated">구현되지 않았지만 &lt;a href=&quot;perlfunc#die&quot;&gt;perlfunc&lt;/a&gt; 및 &lt;a href=&quot;carp&quot;&gt;Carp&lt;/a&gt; 모듈 에서 &quot;die&quot;를 사용 하여 유사한 작업을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="afec59d2cbb0d42662480e51b0e7e50584f1e2e5" translate="yes" xml:space="preserve">
          <source>Unimplemented, except on Windows, due to the vagaries of vendor locale names, returning &lt;code&gt;&quot;&quot;&lt;/code&gt; on non-Windows.</source>
          <target state="translated">Windows를 제외하고는 구현되지 않았습니다. 공급 업체 로케일 이름이 다르기 때문에 Windows 가 아닌 경우 &lt;code&gt;&quot;&quot;&lt;/code&gt; 를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="4e456a7d2242bb697d1c62ca28710a65f1b354e3" translate="yes" xml:space="preserve">
          <source>Unimplemented, so returns &lt;code&gt;&quot;&quot;&lt;/code&gt;.</source>
          <target state="translated">구현되지 않았으므로 &lt;code&gt;&quot;&quot;&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="9769121f10f77079b27eb08e9ffa488cbcc37ed0" translate="yes" xml:space="preserve">
          <source>United Kingdom</source>
          <target state="translated">영국</target>
        </trans-unit>
        <trans-unit id="768685ca582abd0af2fbb57ca37752aa98c9372b" translate="yes" xml:space="preserve">
          <source>United States</source>
          <target state="translated">미국</target>
        </trans-unit>
        <trans-unit id="c6635fe323dcba6e8b8b2d5cdbb340361ce906ed" translate="yes" xml:space="preserve">
          <source>Universal Binary support</source>
          <target state="translated">범용 이진 지원</target>
        </trans-unit>
        <trans-unit id="a1a652fb80ef2238fc4c5e10930af87b4f3aac30" translate="yes" xml:space="preserve">
          <source>Universal Character Set</source>
          <target state="translated">범용 문자 세트</target>
        </trans-unit>
        <trans-unit id="cecc0d8500754b34f5bd7f11dfabb25c3a770aaf" translate="yes" xml:space="preserve">
          <source>Unix</source>
          <target state="translated">Unix</target>
        </trans-unit>
        <trans-unit id="2fb49d2b5adcca8ced12a532099ac9adce5647b1" translate="yes" xml:space="preserve">
          <source>Unix Network Programming, 2nd Edition, Volume 1</source>
          <target state="translated">유닉스 네트워크 프로그래밍, 2 판, 1 권</target>
        </trans-unit>
        <trans-unit id="b4c5506923f63fcc0ec2a3603b475130b23382af" translate="yes" xml:space="preserve">
          <source>Unix Review</source>
          <target state="translated">유닉스 검토</target>
        </trans-unit>
        <trans-unit id="4b39a128140df62988dc25aafca006880dd71ad2" translate="yes" xml:space="preserve">
          <source>Unix has no need of special linker flags.</source>
          <target state="translated">유닉스에는 특별한 링커 플래그가 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4547b2fe2a8711e2250c90726e47d0a32f9e7c0b" translate="yes" xml:space="preserve">
          <source>Unix style shell macros like &lt;code&gt;$(abcd)&lt;/code&gt; are passed through instead of being converted to &lt;code&gt;$^(abcd^)&lt;/code&gt; independent of the &lt;code&gt;DECC$EFS_CHARSET&lt;/code&gt; feature setting. Unix style shell macros should not use characters that are not in the ASCII character set, as the resulting specification may or may not be still in UTF8 format.</source>
          <target state="translated">&lt;code&gt;$(abcd)&lt;/code&gt; 와 같은 Unix 스타일 셸 매크로 는 &lt;code&gt;DECC$EFS_CHARSET&lt;/code&gt; 기능 설정 과 관계 없이 &lt;code&gt;$^(abcd^)&lt;/code&gt; 로 변환되는 대신 통과됩니다 . Unix 스타일 셸 매크로는 결과 사양이 여전히 UTF8 형식 일 수도 있고 아닐 수도 있으므로 ASCII 문자 집합에없는 문자를 사용해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="faa3f11d873bf24fcae352a27226c0c2e88d087f" translate="yes" xml:space="preserve">
          <source>Unix's &lt;code&gt;#!&lt;/code&gt; technique can be simulated on other systems:</source>
          <target state="translated">유닉스의 &lt;code&gt;#!&lt;/code&gt; 기술은 다른 시스템에서 시뮬레이션 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7f87c004392cd89a556aff5f86328de12b9ca773" translate="yes" xml:space="preserve">
          <source>Unix-Domain TCP Clients and Servers</source>
          <target state="translated">유닉스 도메인 TCP 클라이언트 및 서버</target>
        </trans-unit>
        <trans-unit id="4acfa258fe45e38658aa00a5dfda8b8abeddb8cc" translate="yes" xml:space="preserve">
          <source>Unix-domain sockets on OS/2 live in a pseudo-file-system &lt;code&gt;/sockets/...&lt;/code&gt; . To avoid a failure to create a socket with a name of a different form, &lt;code&gt;&quot;/socket/&quot;&lt;/code&gt; is prepended to the socket name (unless it starts with this already).</source>
          <target state="translated">OS / 2의 유닉스 도메인 소켓은 의사 파일 시스템 &lt;code&gt;/sockets/...&lt;/code&gt; 에 있습니다. 다른 형식의 이름으로 소켓을 작성하는 데 실패하지 않도록 &lt;code&gt;&quot;/socket/&quot;&lt;/code&gt; 이 소켓 이름 앞에 붙습니다 (이미 시작하지 않는 한).</target>
        </trans-unit>
        <trans-unit id="35779ed7c2718c03c2a679cc689368ba373e9248" translate="yes" xml:space="preserve">
          <source>Unix-domain sockets on OS/2 live in a pseudo-file-system &lt;code&gt;/sockets/...&lt;/code&gt;. To avoid a failure to create a socket with a name of a different form, &lt;code&gt;&quot;/socket/&quot;&lt;/code&gt; is prepended to the socket name (unless it starts with this already).</source>
          <target state="translated">OS / 2의 유닉스 도메인 소켓은 의사 파일 시스템 &lt;code&gt;/sockets/...&lt;/code&gt; 에 있습니다. 다른 형식의 이름으로 소켓을 만드는 데 실패하지 않도록 소켓 이름 앞에 &lt;code&gt;&quot;/socket/&quot;&lt;/code&gt; 이 추가됩니다 (이미이 이름으로 시작하지 않는 한).</target>
        </trans-unit>
        <trans-unit id="4f3c45c8b86738464ace2f8005c8fbdecfe76366" translate="yes" xml:space="preserve">
          <source>Unix.U</source>
          <target state="translated">Unix.U</target>
        </trans-unit>
        <trans-unit id="bc7819b34ff87570745fbe461e36a16f80e562ce" translate="yes" xml:space="preserve">
          <source>Unknown</source>
          <target state="translated">Unknown</target>
        </trans-unit>
        <trans-unit id="a8b5e7a7d509a7c62d93ee2bad1c35496336638f" translate="yes" xml:space="preserve">
          <source>Unknown &quot;re&quot; subpragma '%s' (known ones are: %s)</source>
          <target state="translated">알 수없는 &quot;re&quot;서브 프라 그마 '% s'(알려진 것 : % s)</target>
        </trans-unit>
        <trans-unit id="ae6c175629d52f8caa8d90709840d842ec6a24a8" translate="yes" xml:space="preserve">
          <source>Unknown &amp;lt;unknown@example.com&amp;gt;</source>
          <target state="translated">알 수 없음 &amp;lt;unknown@example.com&amp;gt;</target>
        </trans-unit>
        <trans-unit id="4260834064ed4da863200d4ab98727ee77cc0db4" translate="yes" xml:space="preserve">
          <source>Unknown '(*...)' construct '%s' in regex; marked by &amp;lt;-- HERE in m/%s/</source>
          <target state="translated">알 수없는 '(* ...)'는 정규식에서 '% s'을 (를) 구성합니다. &amp;lt;-HERE (m / % s /)로 표시</target>
        </trans-unit>
        <trans-unit id="516d733c8bf9db439f1f86408315d55784a8e43c" translate="yes" xml:space="preserve">
          <source>Unknown '=xxxx' commands, unknown 'X&amp;lt;...&amp;gt;' interior-sequences, and unterminated interior sequences.</source>
          <target state="translated">알 수없는 '= xxxx'명령, 알 수없는 'X &amp;lt;...&amp;gt;'내부 시퀀스 및 종료되지 않은 내부 시퀀스</target>
        </trans-unit>
        <trans-unit id="0c7f616921e8aa6ce31483dac2c125041fa7ff10" translate="yes" xml:space="preserve">
          <source>Unknown E content in E&amp;lt;</source>
          <target state="translated">E &amp;lt;의 알 수없는 E 콘텐츠</target>
        </trans-unit>
        <trans-unit id="b452be528de2ca72fbdca17c8a6b9000bd72960e" translate="yes" xml:space="preserve">
          <source>Unknown PerlIO layer &quot;%s&quot;</source>
          <target state="translated">알 수없는 PerlIO 계층 &quot;% s&quot;</target>
        </trans-unit>
        <trans-unit id="bcc9d502ba9bb87ff9a938ae6d50ef1785f93443" translate="yes" xml:space="preserve">
          <source>Unknown Unicode option letter '%c'</source>
          <target state="translated">알 수없는 유니 코드 옵션 문자 '% c'</target>
        </trans-unit>
        <trans-unit id="b383a6c76e59091add963d05eca879c2155929c3" translate="yes" xml:space="preserve">
          <source>Unknown Unicode option value %d</source>
          <target state="translated">알 수없는 유니 코드 옵션 값 % d</target>
        </trans-unit>
        <trans-unit id="63b64d99361c84dd2b785abb8dd250103d6a822f" translate="yes" xml:space="preserve">
          <source>Unknown charname '%s'</source>
          <target state="translated">알 수없는 문자 이름 '% s'</target>
        </trans-unit>
        <trans-unit id="4f8c284e5307746cdeea5551e2520dce4836d73d" translate="yes" xml:space="preserve">
          <source>Unknown directive:</source>
          <target state="translated">알 수없는 지시문 :</target>
        </trans-unit>
        <trans-unit id="e5fd9aa24c9417e7332e6f25936ae2a6ec8f1524" translate="yes" xml:space="preserve">
          <source>Unknown error</source>
          <target state="translated">알수없는 오류</target>
        </trans-unit>
        <trans-unit id="2ebda19c79ae8fdc09d9f934173a9e0b1dda8ac2" translate="yes" xml:space="preserve">
          <source>Unknown locale category %d; can't set it to %s</source>
          <target state="translated">알 수없는 로케일 범주 % d; % s로 설정할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="17e9349b86ed14bdbc36e717e0e54a45178a5709" translate="yes" xml:space="preserve">
          <source>Unknown open() mode '%s'</source>
          <target state="translated">알 수없는 open () 모드 '% s'</target>
        </trans-unit>
        <trans-unit id="7a9ce623a0a054e7c503d1bead726383200a08d0" translate="yes" xml:space="preserve">
          <source>Unknown option: %s</source>
          <target state="translated">알 수없는 옵션 : % s</target>
        </trans-unit>
        <trans-unit id="94063b188637c4358408514f0dec4be5138069da" translate="yes" xml:space="preserve">
          <source>Unknown process %x sent message to prime_env_iter: %s</source>
          <target state="translated">알 수없는 프로세스 % x이 (가) prime_env_iter에 메시지를 보냈습니다. % s</target>
        </trans-unit>
        <trans-unit id="5a27728149a20fa874d8e5d6ec5784571e435f85" translate="yes" xml:space="preserve">
          <source>Unknown regexp modifier &quot;/%s&quot;</source>
          <target state="translated">알 수없는 정규식 수정 자 &quot;/ % s&quot;</target>
        </trans-unit>
        <trans-unit id="48c5c163aa1fa71615dee0d3c90ca77bf54723d6" translate="yes" xml:space="preserve">
          <source>Unknown result token.</source>
          <target state="translated">알 수없는 결과 토큰.</target>
        </trans-unit>
        <trans-unit id="5362b9dbff55eae528c95c41a9cdfba23a42b91e" translate="yes" xml:space="preserve">
          <source>Unknown switch condition (?(...)) in regex; marked by &amp;lt;-- HERE in m/%s/</source>
          <target state="translated">정규식의 알 수없는 전환 조건 (? (...)) &amp;lt;-HERE (m / % s /)로 표시</target>
        </trans-unit>
        <trans-unit id="cc278b1f69a68c5fa1706993032fe0bce8d046fa" translate="yes" xml:space="preserve">
          <source>Unknown verb pattern '%s' in regex; marked by &amp;lt;-- HERE in m/%s/</source>
          <target state="translated">정규식에 알 수없는 동사 패턴 '% s'이 (가) 있습니다. &amp;lt;-HERE (m / % s /)로 표시</target>
        </trans-unit>
        <trans-unit id="faa3d10b86eac319b820b63f583e0a0a896d21a3" translate="yes" xml:space="preserve">
          <source>Unknown warnings category '%s'</source>
          <target state="translated">알 수없는 경고 범주 '% s'</target>
        </trans-unit>
        <trans-unit id="4013e411624fa8892f8200feafb69475d2458d0b" translate="yes" xml:space="preserve">
          <source>Unknowns are &lt;code&gt;&quot;-&quot;&lt;/code&gt; . Unknowns can happen unfortunately quite easily: if the platform doesn't support retrieving the information; if the binary is missing the debug information; if the optimizer has transformed the code by for example inlining.</source>
          <target state="translated">미지수는 &lt;code&gt;&quot;-&quot;&lt;/code&gt; 입니다. 플랫폼이 정보 검색을 지원하지 않는 경우 알 수없는 결과는 불행히도 매우 쉽게 발생할 수 있습니다. 바이너리에 디버그 정보가없는 경우; 옵티마이 저가 예를 들어 인라인으로 코드를 변환 한 경우</target>
        </trans-unit>
        <trans-unit id="e246db88408875913f8b8fd552f45cc3814a8897" translate="yes" xml:space="preserve">
          <source>Unknowns are &lt;code&gt;&quot;-&quot;&lt;/code&gt;. Unknowns can happen unfortunately quite easily: if the platform doesn't support retrieving the information; if the binary is missing the debug information; if the optimizer has transformed the code by for example inlining.</source>
          <target state="translated">알 수없는 것은 &lt;code&gt;&quot;-&quot;&lt;/code&gt; 입니다. 알 수없는 상황은 안타깝게도 매우 쉽게 발생할 수 있습니다. 플랫폼이 정보 검색을 지원하지 않는 경우; 바이너리에 디버그 정보가없는 경우 최적화 프로그램이 예를 들어 인라인으로 코드를 변환 한 경우.</target>
        </trans-unit>
        <trans-unit id="ce906b20ea9a7a0bf0bcbae85c1c9421e3de60b2" translate="yes" xml:space="preserve">
          <source>Unless %hash has already been locked the key/value could be deleted regardless of this setting.</source>
          <target state="translated">% hash가 이미 잠겨 있지 않으면이 설정에 관계없이 키 / 값을 삭제할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5c6af5673dc4ae00136df64bec88a6550bf388e5" translate="yes" xml:space="preserve">
          <source>Unless &lt;code&gt;${^UNICODE}&lt;/code&gt; (available starting in v5.8.2) exists and is non-zero, the PerlIO layers of &lt;code&gt;STDIN&lt;/code&gt; and &lt;code&gt;STDOUT&lt;/code&gt; are set to &quot;&lt;code&gt;:encoding(&lt;i&gt;ENCNAME&lt;/i&gt;)&lt;/code&gt;&quot;. Therefore,</source>
          <target state="translated">않는 &lt;code&gt;${^UNICODE}&lt;/code&gt; (v5.8.2 가능 시작)가 존재하고 비 제로의 층은 PerlIO &lt;code&gt;STDIN&lt;/code&gt; 및 &lt;code&gt;STDOUT&lt;/code&gt; 가 설정된다 &quot; &lt;code&gt;:encoding(&lt;i&gt;ENCNAME&lt;/i&gt;)&lt;/code&gt; &quot;. 따라서,</target>
        </trans-unit>
        <trans-unit id="d2c8c659e558ac6c6718a8a57a68dcfe5600f320" translate="yes" xml:space="preserve">
          <source>Unless &lt;code&gt;-DPERL_MEM_LOG_NOIMPL&lt;/code&gt; (&lt;code&gt;-Accflags=-DPERL_MEM_LOG_NOIMPL&lt;/code&gt;) is also compiled, the logging functions read $ENV{PERL_MEM_LOG} to determine whether to log the event, and if so how:</source>
          <target state="translated">&lt;code&gt;-DPERL_MEM_LOG_NOIMPL&lt;/code&gt; ( &lt;code&gt;-Accflags=-DPERL_MEM_LOG_NOIMPL&lt;/code&gt; )도 컴파일 되지 않는 한 , 로깅 함수는 $ ENV {PERL_MEM_LOG}를 읽어 이벤트를 로깅할지 여부를 결정합니다.</target>
        </trans-unit>
        <trans-unit id="c4a238cf9ea26a0e7ddfda497c5bf0d771bd8656" translate="yes" xml:space="preserve">
          <source>Unless &lt;code&gt;-DPERL_MEM_LOG_NOIMPL&lt;/code&gt; is also compiled, the logging functions read $ENV{PERL_MEM_LOG} to determine whether to log the event, and if so how:</source>
          <target state="translated">&lt;code&gt;-DPERL_MEM_LOG_NOIMPL&lt;/code&gt; 도 컴파일 되지 않으면 로깅 함수는 $ ENV {PERL_MEM_LOG}를 읽고 이벤트 로그 여부를 판별합니다.</target>
        </trans-unit>
        <trans-unit id="7183c27cf3fecde6bcc64c00a3a891d43f73c77b" translate="yes" xml:space="preserve">
          <source>Unless &lt;code&gt;LIBPATHSTRICT&lt;/code&gt; is set to &lt;code&gt;T&lt;/code&gt; (and the kernel is after 2000/09/01), such DLLs are considered to be global. When loading a global DLL it is first looked in the table of already-loaded global DLLs. Because of this the fact that one executable loaded a DLL from &lt;code&gt;BEGINLIBPATH&lt;/code&gt; and &lt;code&gt;ENDLIBPATH&lt;/code&gt; , or</source>
          <target state="translated">&lt;code&gt;LIBPATHSTRICT&lt;/code&gt; 가 &lt;code&gt;T&lt;/code&gt; 로 설정되어 있지 않으면 (그리고 커널이 2000/09/01 이후), 이러한 DLL은 전역으로 간주됩니다. 글로벌 DLL을로드 할 때 이미로드 된 글로벌 DLL 테이블에서 먼저 찾습니다. 이 때문에 하나의 실행 파일이 &lt;code&gt;BEGINLIBPATH&lt;/code&gt; 및 &lt;code&gt;ENDLIBPATH&lt;/code&gt; 에서 DLL을로드 했거나</target>
        </trans-unit>
        <trans-unit id="a9d2404af2307482983ff6743f035f7118e9d8f6" translate="yes" xml:space="preserve">
          <source>Unless &lt;code&gt;LIBPATHSTRICT&lt;/code&gt; is set to &lt;code&gt;T&lt;/code&gt; (and the kernel is after 2000/09/01), such DLLs are considered to be global. When loading a global DLL it is first looked in the table of already-loaded global DLLs. Because of this the fact that one executable loaded a DLL from &lt;code&gt;BEGINLIBPATH&lt;/code&gt; and &lt;code&gt;ENDLIBPATH&lt;/code&gt;, or</source>
          <target state="translated">&lt;code&gt;LIBPATHSTRICT&lt;/code&gt; 가 &lt;code&gt;T&lt;/code&gt; 로 설정 되지 않은 경우 (커널이 2000/09/01 이후 임) 이러한 DLL은 전역으로 간주됩니다. 전역 DLL을로드 할 때 이미로드 된 전역 DLL 표에서 먼저 확인됩니다. 이 때문에 하나의 실행 파일이 &lt;code&gt;BEGINLIBPATH&lt;/code&gt; 및 &lt;code&gt;ENDLIBPATH&lt;/code&gt; 에서 DLL을로드 했거나</target>
        </trans-unit>
        <trans-unit id="4244b98dff2bf774775c08e4df5afb2e645e4b77" translate="yes" xml:space="preserve">
          <source>Unless ASCII vs. EBCDIC issues are specifically being discussed, references to UTF-8 encoding in this document and elsewhere should be read as meaning UTF-EBCDIC on EBCDIC platforms. See &lt;a href=&quot;perlebcdic#Unicode-and-UTF&quot;&gt;&quot;Unicode and UTF&quot; in perlebcdic&lt;/a&gt;.</source>
          <target state="translated">ASCII 대 EBCDIC 문제가 구체적으로 논의되지 않는 한,이 문서 및 다른 곳에서 UTF-8 인코딩에 대한 참조는 EBCDIC 플랫폼에서 UTF-EBCDIC을 의미하는 것으로 읽어야합니다. &lt;a href=&quot;perlebcdic#Unicode-and-UTF&quot;&gt;perlebcdic의 &quot;유니 코드 및 UTF&quot;를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="025ed2d87cd53899da043f16934d54b56cb767cf" translate="yes" xml:space="preserve">
          <source>Unless ASCII vs. EBCDIC issues are specifically being discussed, references to UTF-8 encoding in this document and elsewhere should be read as meaning UTF-EBCDIC on EBCDIC platforms. See &lt;a href=&quot;perlebcdic#Unicode-and-UTF&quot;&gt;Unicode and UTF in perlebcdic&lt;/a&gt;.</source>
          <target state="translated">ASCII 대 EBCDIC 문제가 구체적으로 논의되지 않는 한,이 문서 및 다른 곳에서 UTF-8 인코딩에 대한 참조는 EBCDIC 플랫폼에서 UTF-EBCDIC를 의미하는 것으로 읽혀 져야합니다. &lt;a href=&quot;perlebcdic#Unicode-and-UTF&quot;&gt;perlebcdic의 유니 코드 및 UTF를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="763e516abf0169c17797549989072db7b3b436d9" translate="yes" xml:space="preserve">
          <source>Unless otherwise noted, functions return 0 on success, or a negative value (usually &lt;code&gt;EOF&lt;/code&gt; which is usually -1) and set &lt;code&gt;errno&lt;/code&gt; on error.</source>
          <target state="translated">달리 명시되지 않는 한, 함수는 성공하면 0을 반환하거나 음수 값 ( 보통 -1 인 &lt;code&gt;EOF&lt;/code&gt; ) 을 반환 하고 오류시 &lt;code&gt;errno&lt;/code&gt; 를 설정 합니다.</target>
        </trans-unit>
        <trans-unit id="843ebacc41e4317d9c7bf3f947fad475a9e1f11b" translate="yes" xml:space="preserve">
          <source>Unless otherwise notes, all examples below require this standard preamble to work correctly, with the &lt;code&gt;#!&lt;/code&gt; adjusted to work on your system:</source>
          <target state="translated">별도의 언급이없는 한, 아래의 모든 예제는이 표준 프리앰블이 &lt;code&gt;#!&lt;/code&gt; 시스템에서 작동하도록 조정 :</target>
        </trans-unit>
        <trans-unit id="a1410ee8e42e843fa403d9edd63361088b53c82a" translate="yes" xml:space="preserve">
          <source>Unless otherwise specified, version numbers &lt;b&gt;must&lt;/b&gt; appear in one of two formats:</source>
          <target state="translated">달리 지정하지 않는 한, 버전 번호 &lt;b&gt;는&lt;/b&gt; 다음 두 가지 형식 중 하나로 표시 &lt;b&gt;되어야합니다.&lt;/b&gt; ㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ</target>
        </trans-unit>
        <trans-unit id="519ecd12b4838877006c606ab377c9933076da06" translate="yes" xml:space="preserve">
          <source>Unless otherwise stated all methods return either a</source>
          <target state="translated">달리 명시되지 않는 한 모든 메소드는</target>
        </trans-unit>
        <trans-unit id="58c869a304e00ffd24d619f7d44db8d57f44a80c" translate="yes" xml:space="preserve">
          <source>Unless otherwise stated it works just like ExtUtils::MM_Unix</source>
          <target state="translated">달리 명시되지 않는 한 ExtUtils :: MM_Unix와 동일하게 작동합니다.</target>
        </trans-unit>
        <trans-unit id="ae0b84fa2af86714bff9b9ce409d73281e7852b8" translate="yes" xml:space="preserve">
          <source>Unless otherwise stated it works just like ExtUtils::MM_Unix.</source>
          <target state="translated">달리 명시되지 않는 한 ExtUtils :: MM_Unix처럼 작동합니다.</target>
        </trans-unit>
        <trans-unit id="caa9da45012bfbe0b5378d58f4fff0a9abfa58b5" translate="yes" xml:space="preserve">
          <source>Unless otherwise stated, it works just like ExtUtils::MM_Unix</source>
          <target state="translated">달리 명시되지 않는 한 ExtUtils :: MM_Unix와 동일하게 작동합니다.</target>
        </trans-unit>
        <trans-unit id="495362fe83affb77b166fe352e049869ffdf5946" translate="yes" xml:space="preserve">
          <source>Unless otherwise stated, it works just like ExtUtils::MM_Unix.</source>
          <target state="translated">달리 명시되지 않는 한 ExtUtils :: MM_Unix처럼 작동합니다.</target>
        </trans-unit>
        <trans-unit id="42e400a7ab19dec964d9377da14546fab4feb3ec" translate="yes" xml:space="preserve">
          <source>Unless specified below, the optional parameters for &lt;code&gt;anyinflate&lt;/code&gt; , &lt;code&gt;OPTS&lt;/code&gt; , are the same as those used with the OO interface defined in the &lt;a href=&quot;#Constructor-Options&quot;&gt;Constructor Options&lt;/a&gt; section below.</source>
          <target state="translated">아래에 명시되지 않는 한 &lt;code&gt;anyinflate&lt;/code&gt; 의 선택적 매개 변수 인 &lt;code&gt;OPTS&lt;/code&gt; 는 아래 &lt;a href=&quot;#Constructor-Options&quot;&gt;생성자 옵션&lt;/a&gt; 섹션에 정의 된 OO 인터페이스에 사용 된 것과 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="47a707f463b0bb3f1b25444c520600dbd6696505" translate="yes" xml:space="preserve">
          <source>Unless specified below, the optional parameters for &lt;code&gt;anyuncompress&lt;/code&gt; , &lt;code&gt;OPTS&lt;/code&gt; , are the same as those used with the OO interface defined in the &lt;a href=&quot;#Constructor-Options&quot;&gt;Constructor Options&lt;/a&gt; section below.</source>
          <target state="translated">아래에 명시하지 않는 한, 대한 선택적 매개 변수 &lt;code&gt;anyuncompress&lt;/code&gt; , &lt;code&gt;OPTS&lt;/code&gt; 은 의에 정의 된 OO 인터페이스에 사용 된 것과 동일 &lt;a href=&quot;#Constructor-Options&quot;&gt;생성자 옵션&lt;/a&gt; 아래 섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="d669d839575081392547a5a9cafaedbd09bec28c" translate="yes" xml:space="preserve">
          <source>Unless specified below, the optional parameters for &lt;code&gt;bunzip2&lt;/code&gt; , &lt;code&gt;OPTS&lt;/code&gt; , are the same as those used with the OO interface defined in the &lt;a href=&quot;#Constructor-Options&quot;&gt;Constructor Options&lt;/a&gt; section below.</source>
          <target state="translated">아래에서 지정하지 않는 한 &lt;code&gt;bunzip2&lt;/code&gt; 에 대한 선택적 매개 변수 인 &lt;code&gt;OPTS&lt;/code&gt; 는 아래 &lt;a href=&quot;#Constructor-Options&quot;&gt;생성자 옵션&lt;/a&gt; 섹션에 정의 된 OO 인터페이스에 사용 된 것과 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="5cd0d3bee7135d518d8ccc595535d8b3eccde37f" translate="yes" xml:space="preserve">
          <source>Unless specified below, the optional parameters for &lt;code&gt;bzip2&lt;/code&gt; , &lt;code&gt;OPTS&lt;/code&gt; , are the same as those used with the OO interface defined in the &lt;a href=&quot;#Constructor-Options&quot;&gt;Constructor Options&lt;/a&gt; section below.</source>
          <target state="translated">아래에 명시되지 않는 한 &lt;code&gt;bzip2&lt;/code&gt; 의 선택적 매개 변수 인 &lt;code&gt;OPTS&lt;/code&gt; 는 아래 의 &lt;a href=&quot;#Constructor-Options&quot;&gt;생성자 옵션&lt;/a&gt; 섹션에 정의 된 OO 인터페이스에 사용 된 것과 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="2d2f8a94031befaa66720968f47bd4dde9da6fcf" translate="yes" xml:space="preserve">
          <source>Unless specified below, the optional parameters for &lt;code&gt;deflate&lt;/code&gt; , &lt;code&gt;OPTS&lt;/code&gt; , are the same as those used with the OO interface defined in the &lt;a href=&quot;#Constructor-Options&quot;&gt;Constructor Options&lt;/a&gt; section below.</source>
          <target state="translated">아래에 명시되지 않는 한 &lt;code&gt;deflate&lt;/code&gt; 의 선택적 매개 변수 인 &lt;code&gt;OPTS&lt;/code&gt; 는 아래 의 &lt;a href=&quot;#Constructor-Options&quot;&gt;생성자 옵션&lt;/a&gt; 섹션에 정의 된 OO 인터페이스에 사용 된 것과 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="f180e51799fa543d0272bd825b3d860097f806c2" translate="yes" xml:space="preserve">
          <source>Unless specified below, the optional parameters for &lt;code&gt;gunzip&lt;/code&gt; , &lt;code&gt;OPTS&lt;/code&gt; , are the same as those used with the OO interface defined in the &lt;a href=&quot;#Constructor-Options&quot;&gt;Constructor Options&lt;/a&gt; section below.</source>
          <target state="translated">아래에서 지정하지 않는 한 &lt;code&gt;gunzip&lt;/code&gt; , &lt;code&gt;OPTS&lt;/code&gt; 의 선택적 매개 변수는 아래 &lt;a href=&quot;#Constructor-Options&quot;&gt;생성자 옵션&lt;/a&gt; 섹션에 정의 된 OO 인터페이스에 사용 된 매개 변수 와 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="43b54de84f56f9f511018d58087cdd33377321ec" translate="yes" xml:space="preserve">
          <source>Unless specified below, the optional parameters for &lt;code&gt;gzip&lt;/code&gt; , &lt;code&gt;OPTS&lt;/code&gt; , are the same as those used with the OO interface defined in the &lt;a href=&quot;#Constructor-Options&quot;&gt;Constructor Options&lt;/a&gt; section below.</source>
          <target state="translated">아래에 지정되지 않은 경우 &lt;code&gt;gzip&lt;/code&gt; , &lt;code&gt;OPTS&lt;/code&gt; 의 선택적 매개 변수는 아래 &lt;a href=&quot;#Constructor-Options&quot;&gt;생성자 옵션&lt;/a&gt; 섹션에 정의 된 OO 인터페이스에 사용 된 매개 변수 와 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="d8c0791fbf600370c86e6ae040e4b2abd896e9ba" translate="yes" xml:space="preserve">
          <source>Unless specified below, the optional parameters for &lt;code&gt;inflate&lt;/code&gt; , &lt;code&gt;OPTS&lt;/code&gt; , are the same as those used with the OO interface defined in the &lt;a href=&quot;#Constructor-Options&quot;&gt;Constructor Options&lt;/a&gt; section below.</source>
          <target state="translated">아래에 명시되지 않는 한, &lt;code&gt;inflate&lt;/code&gt; 의 선택적 매개 변수 인 &lt;code&gt;OPTS&lt;/code&gt; 는 아래 &lt;a href=&quot;#Constructor-Options&quot;&gt;생성자 옵션&lt;/a&gt; 섹션에 정의 된 OO 인터페이스에 사용 된 것과 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="e65e4b1379d48c357409defc2e3a088bfcc64051" translate="yes" xml:space="preserve">
          <source>Unless specified below, the optional parameters for &lt;code&gt;rawdeflate&lt;/code&gt; , &lt;code&gt;OPTS&lt;/code&gt; , are the same as those used with the OO interface defined in the &lt;a href=&quot;#Constructor-Options&quot;&gt;Constructor Options&lt;/a&gt; section below.</source>
          <target state="translated">아래에 명시되지 않는 한 &lt;code&gt;rawdeflate&lt;/code&gt; 의 선택적 매개 변수 인 &lt;code&gt;OPTS&lt;/code&gt; 는 아래 &lt;a href=&quot;#Constructor-Options&quot;&gt;생성자 옵션&lt;/a&gt; 섹션에 정의 된 OO 인터페이스에 사용 된 것과 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="f9aa434ca385a7cef6abc358c51e5f3189796565" translate="yes" xml:space="preserve">
          <source>Unless specified below, the optional parameters for &lt;code&gt;rawinflate&lt;/code&gt; , &lt;code&gt;OPTS&lt;/code&gt; , are the same as those used with the OO interface defined in the &lt;a href=&quot;#Constructor-Options&quot;&gt;Constructor Options&lt;/a&gt; section below.</source>
          <target state="translated">아래에 명시되지 않는 한 &lt;code&gt;rawinflate&lt;/code&gt; 의 선택적 매개 변수 인 &lt;code&gt;OPTS&lt;/code&gt; 는 아래 의 &lt;a href=&quot;#Constructor-Options&quot;&gt;생성자 옵션&lt;/a&gt; 섹션에 정의 된 OO 인터페이스에 사용 된 것과 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="e2285dec1544503fb1e6e19eb0aec81e1f5a9726" translate="yes" xml:space="preserve">
          <source>Unless specified below, the optional parameters for &lt;code&gt;unzip&lt;/code&gt; , &lt;code&gt;OPTS&lt;/code&gt; , are the same as those used with the OO interface defined in the &lt;a href=&quot;#Constructor-Options&quot;&gt;Constructor Options&lt;/a&gt; section below.</source>
          <target state="translated">아래에 명시되지 않는 한 &lt;code&gt;unzip&lt;/code&gt; , &lt;code&gt;OPTS&lt;/code&gt; 에 대한 선택적 매개 변수는 아래 &lt;a href=&quot;#Constructor-Options&quot;&gt;생성자 옵션&lt;/a&gt; 섹션에 정의 된 OO 인터페이스에 사용 된 매개 변수 와 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="f45874d912d180929ebed6cffec516fc7cf2fb97" translate="yes" xml:space="preserve">
          <source>Unless specified below, the optional parameters for &lt;code&gt;zip&lt;/code&gt; , &lt;code&gt;OPTS&lt;/code&gt; , are the same as those used with the OO interface defined in the &lt;a href=&quot;#Constructor-Options&quot;&gt;Constructor Options&lt;/a&gt; section below.</source>
          <target state="translated">아래에 지정되지 않은 경우 &lt;code&gt;zip&lt;/code&gt; 의 선택적 매개 변수 , &lt;code&gt;OPTS&lt;/code&gt; 아래 &lt;a href=&quot;#Constructor-Options&quot;&gt;생성자 옵션&lt;/a&gt; 섹션에 정의 된 OO 인터페이스에 사용 된 와 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="871cfac0f7d812719fa8ee355ce0991623ac4e0b" translate="yes" xml:space="preserve">
          <source>Unless specified otherwise all method can be called as class methods, or as object methods. If called as class methods then the &quot;default&quot; object will be used, and if necessary created using the current processes %Config and @INC. See the 'default' option to new() for details.</source>
          <target state="translated">달리 명시되지 않는 한 모든 메소드는 클래스 메소드 또는 오브젝트 메소드로 호출 될 수 있습니다. 클래스 메소드로 호출되면 &quot;default&quot;오브젝트가 사용되며 필요한 경우 현재 프로세스 % Config 및 @INC를 사용하여 작성됩니다. 자세한 내용은 'default'옵션을 new ()로 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="360b129724fa7c1c8235f3513edf30406e818a7b" translate="yes" xml:space="preserve">
          <source>Unless the &lt;code&gt;/r&lt;/code&gt; option is used, the string specified with &lt;code&gt;=~&lt;/code&gt; must be a scalar variable, an array element, a hash element, or an assignment to one of those; in other words, an lvalue.</source>
          <target state="translated">&lt;code&gt;/r&lt;/code&gt; 이 아니라면 옵션을 사용 &lt;code&gt;=~&lt;/code&gt; 로 지정된 문자열 은 스칼라 변수, 배열 요소, 해시 요소 또는 그 중 하나에 대한 지정이어야합니다. 다시 말해, lvalue입니다.</target>
        </trans-unit>
        <trans-unit id="9ef73743f2ca77d91834c677a3b2a131dd0854b0" translate="yes" xml:space="preserve">
          <source>Unless the above additional feature is enabled, nothing about the backtrace functionality is visible, except for the Perl/XS level.</source>
          <target state="translated">위의 추가 기능을 사용하지 않으면 Perl / XS 레벨을 제외하고 역 추적 기능에 대한 정보가 표시되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c2c4cb992d99b0b97748811097f97eea4d2ce81b" translate="yes" xml:space="preserve">
          <source>Unless the operator is an assignment (&lt;code&gt;+=&lt;/code&gt; , &lt;code&gt;-=&lt;/code&gt; , etc.), repeat step (1) in respect of the second operand.</source>
          <target state="translated">연산자가 할당이 아닌 한 ( &lt;code&gt;+=&lt;/code&gt; , &lt;code&gt;-=&lt;/code&gt; 등) 한 두 번째 피연산자에 대해 단계 (1)을 반복하십시오.</target>
        </trans-unit>
        <trans-unit id="05d7e76af21f11f9c892472417201fd8ed4cf910" translate="yes" xml:space="preserve">
          <source>Unless the operator is an assignment (&lt;code&gt;+=&lt;/code&gt;, &lt;code&gt;-=&lt;/code&gt;, etc.), repeat step (1) in respect of the second operand.</source>
          <target state="translated">연산자가 할당 ( &lt;code&gt;+=&lt;/code&gt; , &lt;code&gt;-=&lt;/code&gt; 등) 이 아닌 경우 두 번째 피연산자에 대해 단계 (1)을 반복합니다.</target>
        </trans-unit>
        <trans-unit id="2c6634c0ddc3b2fcdacf253fa92fd7c8403abaf0" translate="yes" xml:space="preserve">
          <source>Unless the pattern or string are encoded in UTF-8, only ASCII characters can match positively.</source>
          <target state="translated">패턴이나 문자열이 UTF-8로 인코딩되지 않은 경우 ASCII 문자 만 양의 값으로 일치 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="93f6520e33056598a5ce68e86d15794aa942a8a6" translate="yes" xml:space="preserve">
          <source>Unless they are explicitly specified, the default values for the exit status, verbose level, and output stream to use are determined as follows:</source>
          <target state="translated">명시 적으로 지정하지 않으면 종료 상태, 상세 레벨 및 사용할 출력 스트림의 기본값은 다음과 같이 결정됩니다.</target>
        </trans-unit>
        <trans-unit id="28631a8600ab2d0e4799cb9a021cc0306169b6f9" translate="yes" xml:space="preserve">
          <source>Unless you are accessing the CPAN on your filesystem via a file: URL, CPAN.pm needs to keep the source files it downloads somewhere. Please supply a directory where the downloaded files are to be kept.</source>
          <target state="translated">파일 : URL을 통해 파일 시스템의 CPAN에 액세스하지 않는 한 CPAN.pm은 다운로드 한 소스 파일을 어딘가에 보관해야합니다. 다운로드 한 파일을 보관할 디렉토리를 제공하십시오.</target>
        </trans-unit>
        <trans-unit id="6b861eac07037b268358d427fce8707b48f9500e" translate="yes" xml:space="preserve">
          <source>Unless you are using the &lt;code&gt;fields&lt;/code&gt; pragma, consider this module discouraged in favor of the lighter-weight &lt;code&gt;parent&lt;/code&gt; .</source>
          <target state="translated">pragma &lt;code&gt;fields&lt;/code&gt; 사용하지 않는 한이 모듈은 더 가벼운 &lt;code&gt;parent&lt;/code&gt; 를 선호하지 않는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="bd40baebc35d8dd113beed64e1b32df4e1666e49" translate="yes" xml:space="preserve">
          <source>Unless you are using the &lt;code&gt;fields&lt;/code&gt; pragma, consider this module discouraged in favor of the lighter-weight &lt;code&gt;parent&lt;/code&gt;.</source>
          <target state="translated">pragma &lt;code&gt;fields&lt;/code&gt; 사용하지 않는 한이 모듈은 더 가벼운 &lt;code&gt;parent&lt;/code&gt; 를 선호하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="84f0f4d743460958895c1346a2bcc4ae32486815" translate="yes" xml:space="preserve">
          <source>Unless you don't like the possibility of there being part of your Perl scripts embedded in a database file, this is nothing to worry about.</source>
          <target state="translated">데이터베이스 파일에 Perl 스크립트의 일부가 포함될 가능성이 마음에 들지 않으면 걱정할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="078c8b3d64fda031c2ca3a111adc19b05790c7fb" translate="yes" xml:space="preserve">
          <source>Unless you have a particular reason to use the two-argument form you should use the three-argument form of open() which does not treat any characters in the filename as special.</source>
          <target state="translated">두 인수 형식을 사용해야하는 특별한 이유가 없으면 파일 이름의 문자를 특수 문자로 취급하지 않는 open ()의 세 가지 인수 형식을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="bcd145902080112cd3bd3565e1aa0b2eb6698439" translate="yes" xml:space="preserve">
          <source>Unless you have good reasons for using some other format (for example, a format used within your company), the convention is to name your changelog file &lt;code&gt;Changes&lt;/code&gt; , and to follow the simple format described in &lt;a href=&quot;http://search.cpan.org/perldoc/CPAN::Changes::Spec&quot;&gt;CPAN::Changes::Spec&lt;/a&gt;.</source>
          <target state="translated">다른 형식 (예 : 회사 내에서 사용되는 형식)을 사용해야 할 이유가없는 경우 규칙은 변경 로그 파일의 이름을 &lt;code&gt;Changes&lt;/code&gt; 로 지정하고 &lt;a href=&quot;http://search.cpan.org/perldoc/CPAN::Changes::Spec&quot;&gt;CPAN :: Changes :: Spec에&lt;/a&gt; 설명 된 간단한 형식을 따르는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="87db3fba7e4f130f44369a6d247e1f97fe2c94e1" translate="yes" xml:space="preserve">
          <source>Unless you have good reasons for using some other format (for example, a format used within your company), the convention is to name your changelog file &lt;code&gt;Changes&lt;/code&gt;, and to follow the simple format described in &lt;a href=&quot;CPAN::Changes::Spec&quot;&gt;CPAN::Changes::Spec&lt;/a&gt;.</source>
          <target state="translated">다른 형식 (예 : 회사 내에서 사용되는 형식)을 사용해야하는 합당한 이유가없는 경우 규칙은 변경 로그 파일의 이름을 &lt;code&gt;Changes&lt;/code&gt; 로 지정하고 &lt;a href=&quot;CPAN::Changes::Spec&quot;&gt;CPAN :: Changes :: Spec에&lt;/a&gt; 설명 된 간단한 형식을 따르는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="ba7a1f205e8e2686b0c4b6d39cce725cef83741e" translate="yes" xml:space="preserve">
          <source>Unless you know better, serializing hook should always say:</source>
          <target state="translated">더 잘 알지 못하면 직렬화 후크는 항상 다음과 같이 말해야합니다.</target>
        </trans-unit>
        <trans-unit id="4f5f76f31b82833340ef52081bb4d0e79eab2cc2" translate="yes" xml:space="preserve">
          <source>Unless you know with 100% certainty that quux() is only ever available for the &quot;Foonix&quot; operating system &lt;b&gt;and&lt;/b&gt; that is available &lt;b&gt;and&lt;/b&gt; correctly working for &lt;b&gt;all&lt;/b&gt; past, present, &lt;b&gt;and&lt;/b&gt; future versions of &quot;Foonix&quot;, the above is very wrong. This is more correct (though still not perfect, because the below is a compile-time check):</source>
          <target state="translated">당신은 quux ()가 &quot;Foonix&quot;운영 체제에 대해 오직 사용할 수 있음을 100 % 확신 할 않는 &lt;b&gt;및&lt;/b&gt; 그이 가능 &lt;b&gt;하고&lt;/b&gt; 올바르게 일하는 &lt;b&gt;모든&lt;/b&gt; 과거, 현재, &lt;b&gt;그리고&lt;/b&gt; &quot;Foonix&quot;의 미래 버전, 위에서 언급 한 매우 잘못된 것입니다. 이것은 더 정확합니다 (아래는 컴파일 타임 검사이므로 여전히 완벽하지는 않습니다).</target>
        </trans-unit>
        <trans-unit id="93ff79231a3d36c0c3d8ce3114e701a1baebbf25" translate="yes" xml:space="preserve">
          <source>Unless you set this attribute to a false value, Pod::Search will recurse into subdirectories of the search directories.</source>
          <target state="translated">이 속성을 false로 설정하지 않으면 Pod :: Search는 검색 디렉토리의 하위 디렉토리로 반복됩니다.</target>
        </trans-unit>
        <trans-unit id="17c62f898b45d3be500e6c39bec8d493a60a2715" translate="yes" xml:space="preserve">
          <source>Unless you set this attribute to a true value, Pod::Search will apply Perl-specific heuristics to find the correct module PODs quickly. This attribute's default value is false. You won't normally need to set this to true.</source>
          <target state="translated">이 속성을 true로 설정하지 않으면 Pod :: Search는 Perl 특정 휴리스틱을 적용하여 올바른 모듈 POD를 빠르게 찾습니다. 이 속성의 기본값은 false입니다. 일반적으로 이것을 true로 설정할 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="9f9a16887abf4c916f1550cac344cc208f6c0b6b" translate="yes" xml:space="preserve">
          <source>Unless you set this attribute to a true value, Pod::Simple::Search will consider only the first file of a given modulename as it looks thru the specified directories; that is, with this option off, if Pod::Simple::Search has seen a &lt;code&gt;somepathdir/Foo/Bar.pm&lt;/code&gt; already in this search, then it won't bother looking at a &lt;code&gt;somelaterpathdir/Foo/Bar.pm&lt;/code&gt; later on in that search, because that file is merely a &quot;shadow&quot;. But if you turn on &lt;code&gt;$self-&amp;gt;shadows(1)&lt;/code&gt; , then these &quot;shadow&quot; files are inspected too, and are noted in the pathname2podname return hash.</source>
          <target state="translated">이 속성을 true로 설정하지 않으면 Pod :: Simple :: Search는 지정된 디렉토리를 통해 지정된 모듈 이름의 첫 번째 파일 만 고려합니다. 즉,이 옵션이 꺼져 있으면 포드 :: Simple :: Search 가이 검색에서 &lt;code&gt;somepathdir/Foo/Bar.pm&lt;/code&gt; 을 이미 본 경우 나중에 &lt;code&gt;somelaterpathdir/Foo/Bar.pm&lt;/code&gt; 을 보지 않아도 됩니다. 해당 파일은 &quot;그림자&quot;일뿐입니다. 그러나 &lt;code&gt;$self-&amp;gt;shadows(1)&lt;/code&gt; 을 켜면 이러한 &quot;shadow&quot;파일도 검사되며 pathname2podname return hash에 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="4fc995dcd124519ccc18ad86cc265d6cd653065c" translate="yes" xml:space="preserve">
          <source>Unless you set this attribute to a true value, Pod::Simple::Search will consider only the first file of a given modulename as it looks thru the specified directories; that is, with this option off, if Pod::Simple::Search has seen a &lt;code&gt;somepathdir/Foo/Bar.pm&lt;/code&gt; already in this search, then it won't bother looking at a &lt;code&gt;somelaterpathdir/Foo/Bar.pm&lt;/code&gt; later on in that search, because that file is merely a &quot;shadow&quot;. But if you turn on &lt;code&gt;$self-&amp;gt;shadows(1)&lt;/code&gt;, then these &quot;shadow&quot; files are inspected too, and are noted in the pathname2podname return hash.</source>
          <target state="translated">이 속성을 true 값으로 설정하지 않는 한 Pod :: Simple :: Search는 지정된 디렉토리를 통해 보이는 지정된 모듈 이름의 첫 번째 파일 만 고려합니다. 즉,이 옵션을 끈 상태에서 Pod :: Simple :: Search가 이미이 검색에서 &lt;code&gt;somepathdir/Foo/Bar.pm&lt;/code&gt; 을 본 경우 나중에 &lt;code&gt;somelaterpathdir/Foo/Bar.pm&lt;/code&gt; 을 살펴 보지 않습니다 . 그 파일은 단지 &quot;그림자&quot;이기 때문입니다. 그러나 &lt;code&gt;$self-&amp;gt;shadows(1)&lt;/code&gt; 를 켜면 이러한 &quot;shadow&quot;파일도 검사되고 pathname2podname 반환 해시에 기록됩니다.</target>
        </trans-unit>
        <trans-unit id="fa89971032de2d3d226811c31dc2014b63de305b" translate="yes" xml:space="preserve">
          <source>Unless you want to override the defaults, prefer META_MERGE so as to get the advantage of any future defaults.</source>
          <target state="translated">기본값을 재정의하지 않는 한, 향후 기본값을 활용하려면 META_MERGE를 선호하십시오.</target>
        </trans-unit>
        <trans-unit id="eb83985aa16dab9a13560a8e8f1159fe638efa8b" translate="yes" xml:space="preserve">
          <source>Unless you want to use its advanced features, this is probably all you need to know to use Exporter.</source>
          <target state="translated">고급 기능을 사용하지 않으려면 Exporter를 사용하기 위해 알아야 할 모든 것입니다.</target>
        </trans-unit>
        <trans-unit id="04c205c66e7bc90d55cfb8afb031ef118a5c83da" translate="yes" xml:space="preserve">
          <source>Unless you&amp;rsquo;ve used &lt;code&gt;/a&lt;/code&gt; or &lt;code&gt;/aa&lt;/code&gt; , &lt;code&gt;\d&lt;/code&gt; matches more than ASCII digits only, but Perl&amp;rsquo;s implicit string-to-number conversion does not current recognize these. Here&amp;rsquo;s how to convert such strings manually.</source>
          <target state="translated">당신이 사용하지 않는 한 &lt;code&gt;/a&lt;/code&gt; 나 &lt;code&gt;/aa&lt;/code&gt; , &lt;code&gt;\d&lt;/code&gt; 경우에만 ASCII 숫자보다 더 많은 경기를하지만, 펄의 암시 적 문자열에 번호 변환이 현재하지 않는 이러한 인식하고 있습니다. 이러한 문자열을 수동으로 변환하는 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="37d04e5bf67a8174972d88089473b77064f2c69b" translate="yes" xml:space="preserve">
          <source>Unless you&amp;rsquo;ve used &lt;code&gt;/a&lt;/code&gt; or &lt;code&gt;/aa&lt;/code&gt;, &lt;code&gt;\d&lt;/code&gt; matches more than ASCII digits only, but Perl&amp;rsquo;s implicit string-to-number conversion does not current recognize these. Here&amp;rsquo;s how to convert such strings manually.</source>
          <target state="translated">당신이 사용하지 않는 한 &lt;code&gt;/a&lt;/code&gt; 나 &lt;code&gt;/aa&lt;/code&gt; , &lt;code&gt;\d&lt;/code&gt; 경우에만 ASCII 숫자보다 더 많은 경기를하지만, 펄의 암시 적 문자열에 번호 변환이 현재하지 않는 이러한 인식하고 있습니다. 이러한 문자열을 수동으로 변환하는 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8a9444f4badd85c5a13fe02c22e0706b7a37804d" translate="yes" xml:space="preserve">
          <source>Unless you're writing a new &lt;a href=&quot;TAP::Parser::SourceHandler&quot;&gt;TAP::Parser::SourceHandler&lt;/a&gt;, a plugin or subclassing &lt;a href=&quot;TAP::Parser&quot;&gt;TAP::Parser&lt;/a&gt;, you probably won't need to use this module directly.</source>
          <target state="translated">새로운 &lt;a href=&quot;TAP::Parser::SourceHandler&quot;&gt;TAP :: Parser :: SourceHandler&lt;/a&gt; , 플러그인 또는 서브 클래 싱 &lt;a href=&quot;TAP::Parser&quot;&gt;TAP :: Parser를&lt;/a&gt; 작성하지 않는 한 , 아마도이 모듈을 직접 사용할 필요가 없을 것입니다.</target>
        </trans-unit>
        <trans-unit id="b006759734f26ef71ac954f172bdb96074166b64" translate="yes" xml:space="preserve">
          <source>Unless you're writing a new &lt;a href=&quot;TAP::Parser::SourceHandler&quot;&gt;TAP::Parser::SourceHandler&lt;/a&gt;, a plugin, or subclassing &lt;a href=&quot;TAP::Parser&quot;&gt;TAP::Parser&lt;/a&gt;, you probably won't need to use this module directly.</source>
          <target state="translated">새로운 &lt;a href=&quot;TAP::Parser::SourceHandler&quot;&gt;TAP :: Parser :: SourceHandler&lt;/a&gt; , 플러그인 또는 서브 클래 싱 &lt;a href=&quot;TAP::Parser&quot;&gt;TAP :: Parser&lt;/a&gt; 를 작성하지 않는 한이 모듈을 직접 사용할 필요가 없을 것입니다.</target>
        </trans-unit>
        <trans-unit id="5d5045afa1f26fa3558f3707783d1ac5db1ca1f3" translate="yes" xml:space="preserve">
          <source>Unless you're writing a new &lt;a href=&quot;sourcehandler&quot;&gt;TAP::Parser::SourceHandler&lt;/a&gt;, a plugin or subclassing &lt;a href=&quot;../parser&quot;&gt;TAP::Parser&lt;/a&gt;, you probably won't need to use this module directly.</source>
          <target state="translated">플러그인 또는 &lt;a href=&quot;../parser&quot;&gt;TAP :: Parser를&lt;/a&gt; 서브 클래 싱 하는 새로운 &lt;a href=&quot;sourcehandler&quot;&gt;TAP :: Parser :: SourceHandler를&lt;/a&gt; 작성하지 않는 한이 모듈을 직접 사용할 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="83a68b50b49a806ff511080c423ef60589d29433" translate="yes" xml:space="preserve">
          <source>Unless you're writing a plugin or subclassing &lt;a href=&quot;TAP::Parser&quot;&gt;TAP::Parser&lt;/a&gt;, you probably won't need to use this module directly.</source>
          <target state="translated">플러그인을 작성하거나 &lt;a href=&quot;TAP::Parser&quot;&gt;TAP :: Parser&lt;/a&gt; 하위 클래스를 작성하지 않는 한이 모듈을 직접 사용할 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="d54802d84b1114c8dea2af70188cfd6c295957d7" translate="yes" xml:space="preserve">
          <source>Unless your parameters specify &lt;code&gt;'formatter'&lt;/code&gt; or &lt;code&gt;'ipc'&lt;/code&gt; arguments, the formatter and IPC instance will be inherited from the current top hub. You can set the parameters to &lt;code&gt;undef&lt;/code&gt; to avoid having a formatter or IPC instance.</source>
          <target state="translated">매개 변수가 &lt;code&gt;'formatter'&lt;/code&gt; 또는 &lt;code&gt;'ipc'&lt;/code&gt; 인수를 지정하지 않는 한 , 포맷터 및 IPC 인스턴스는 현재 최상위 허브에서 상속됩니다. 포맷터 또는 IPC 인스턴스를 사용하지 않도록 매개 변수를 &lt;code&gt;undef&lt;/code&gt; 로 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e4fc409268936e0da48b9a4cfb9650b21029f3c0" translate="yes" xml:space="preserve">
          <source>Unlike</source>
          <target state="translated">Unlike</target>
        </trans-unit>
        <trans-unit id="0b93fd78908f06ac9f5039bb243a42a6b44ce01c" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;#Decimal-Versions&quot;&gt;&quot;Decimal Versions&quot;&lt;/a&gt;, Dotted-Decimal Versions have more than a single decimal point, e.g.:</source>
          <target state="translated">&lt;a href=&quot;#Decimal-Versions&quot;&gt;&quot;Decimal Versions&quot;&lt;/a&gt; 와 달리 Dotted-Decimal 버전은 소수점 하나 이상을가집니다. 예 :</target>
        </trans-unit>
        <trans-unit id="cb0a5bc8021cd6778eed9a88f7e5cfd7b53090d1" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;#charinfo%28%29&quot;&gt;&quot;charinfo()&quot;&lt;/a&gt;, this does not include the decomposition type. Use the &lt;code&gt;Decomposition_Type&lt;/code&gt; property to get that.</source>
          <target state="translated">&lt;a href=&quot;#charinfo%28%29&quot;&gt;&quot;charinfo ()&quot;&lt;/a&gt; 와 달리 여기에는 분해 유형이 포함되지 않습니다. 이를 얻으려면 &lt;code&gt;Decomposition_Type&lt;/code&gt; 속성을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="26769d51e7e8546d072ce687409eedaf6bbd7d27" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;#charinfo()&quot;&gt;charinfo()&lt;/a&gt;, this does not include the decomposition type. Use the &lt;code&gt;Decomposition_Type&lt;/code&gt; property to get that.</source>
          <target state="translated">&lt;a href=&quot;#charinfo()&quot;&gt;charinfo ()&lt;/a&gt; 와 달리 분해 유형은 포함되지 않습니다. 그것을 얻으려면 &lt;code&gt;Decomposition_Type&lt;/code&gt; 속성을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="9a41788c4603779b500b4b22e894cfcf25b5f9a6" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;#dbmopen-HASH%2CDBNAME%2CMASK&quot;&gt;&lt;code&gt;dbmopen&lt;/code&gt;&lt;/a&gt;, the &lt;a href=&quot;#tie-VARIABLE%2CCLASSNAME%2CLIST&quot;&gt;&lt;code&gt;tie&lt;/code&gt;&lt;/a&gt; function will not &lt;a href=&quot;#use-Module-VERSION-LIST&quot;&gt;&lt;code&gt;use&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#require-VERSION&quot;&gt;&lt;code&gt;require&lt;/code&gt;&lt;/a&gt; a module for you; you need to do that explicitly yourself. See &lt;a href=&quot;db_file&quot;&gt;DB_File&lt;/a&gt; or the &lt;a href=&quot;config&quot;&gt;Config&lt;/a&gt; module for interesting &lt;a href=&quot;#tie-VARIABLE%2CCLASSNAME%2CLIST&quot;&gt;&lt;code&gt;tie&lt;/code&gt;&lt;/a&gt; implementations.</source>
          <target state="translated">달리 &lt;a href=&quot;#dbmopen-HASH%2CDBNAME%2CMASK&quot;&gt; &lt;code&gt;dbmopen&lt;/code&gt; &lt;/a&gt; 의 &lt;a href=&quot;#tie-VARIABLE%2CCLASSNAME%2CLIST&quot;&gt; &lt;code&gt;tie&lt;/code&gt; &lt;/a&gt; 기능을하지 않습니다 &lt;a href=&quot;#use-Module-VERSION-LIST&quot;&gt; &lt;code&gt;use&lt;/code&gt; &lt;/a&gt; 하거나 &lt;a href=&quot;#require-VERSION&quot;&gt; &lt;code&gt;require&lt;/code&gt; &lt;/a&gt; 당신을위한 모듈; 명시 적으로 직접해야합니다. 흥미로운 &lt;a href=&quot;#tie-VARIABLE%2CCLASSNAME%2CLIST&quot;&gt; &lt;code&gt;tie&lt;/code&gt; &lt;/a&gt; 구현에 대해서는 &lt;a href=&quot;db_file&quot;&gt;DB_File&lt;/a&gt; 또는 &lt;a href=&quot;config&quot;&gt;Config&lt;/a&gt; 모듈을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="6a6202c7008c5edbd97e21466da5df4a59ec41a0" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;#printf-FILEHANDLE-FORMAT%2C-LIST&quot;&gt;&lt;code&gt;printf&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#sprintf-FORMAT%2C-LIST&quot;&gt;&lt;code&gt;sprintf&lt;/code&gt;&lt;/a&gt; does not do what you probably mean when you pass it an array as your first argument. The array is given scalar context, and instead of using the 0th element of the array as the format, Perl will use the count of elements in the array as the format, which is almost never useful.</source>
          <target state="translated">달리 &lt;a href=&quot;#printf-FILEHANDLE-FORMAT%2C-LIST&quot;&gt; &lt;code&gt;printf&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#sprintf-FORMAT%2C-LIST&quot;&gt; &lt;code&gt;sprintf&lt;/code&gt; 와는&lt;/a&gt; 당신이 당신의 첫 번째 인수로 배열을 통과 할 때 아마 당신은 무엇을 의미하지 않습니다. 배열에는 스칼라 컨텍스트가 주어지며 배열의 0 번째 요소를 형식으로 사용하는 대신 Perl은 배열의 요소 수를 형식으로 사용하므로 거의 유용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a68f9ca2a4829500bd2437e49a38f1fec56cc959" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;#utf8_to_bytes&quot;&gt;&quot;utf8_to_bytes&quot;&lt;/a&gt; but like &lt;a href=&quot;#bytes_to_utf8&quot;&gt;&quot;bytes_to_utf8&quot;&lt;/a&gt;, this is non-destructive of the input string.</source>
          <target state="translated">달리 &lt;a href=&quot;#utf8_to_bytes&quot;&gt;&quot;utf8_to_bytes&quot;&lt;/a&gt; 추천되지만 &lt;a href=&quot;#bytes_to_utf8&quot;&gt;&quot;bytes_to_utf8&quot;&lt;/a&gt; 이 입력 문자열의 비파괴이다.</target>
        </trans-unit>
        <trans-unit id="0f7823a1b5c73e2c047f503abcdbc0ee1982c031" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;integer&quot;&gt;integer&lt;/a&gt;, this pragma creates integer constants that are only limited in their size by the available memory and CPU time.</source>
          <target state="translated">&lt;a href=&quot;integer&quot;&gt;integer&lt;/a&gt; 와 달리이 pragma는 사용 가능한 메모리와 CPU 시간에 따라 크기가 제한된 정수 상수를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="ed386882eb03009cdfed1d7cc619e0742b192d68" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;&lt;a href=&quot;dbmopen&quot;&gt;dbmopen&lt;/a&gt;&lt;/code&gt;, the &lt;code&gt;&lt;a href=&quot;tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; function will not &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; a module for you; you need to do that explicitly yourself. See &lt;a href=&quot;../db_file&quot;&gt;DB_File&lt;/a&gt; or the</source>
          <target state="translated">달리 &lt;code&gt;&lt;a href=&quot;dbmopen&quot;&gt;dbmopen&lt;/a&gt;&lt;/code&gt; 의 &lt;code&gt;&lt;a href=&quot;tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; 기능을하지 않습니다 &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 하거나 &lt;code&gt;&lt;a href=&quot;require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; 당신을위한 모듈; 직접 명시 적으로해야합니다. &lt;a href=&quot;../db_file&quot;&gt;DB_File&lt;/a&gt; 참조 또는</target>
        </trans-unit>
        <trans-unit id="e6074edfe48b345d15827a75a36946caff143c7a" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;&lt;a href=&quot;functions/dbmopen&quot;&gt;dbmopen&lt;/a&gt;&lt;/code&gt;, the &lt;code&gt;&lt;a href=&quot;functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; function will not &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; a module for you; you need to do that explicitly yourself. See &lt;a href=&quot;db_file&quot;&gt;DB_File&lt;/a&gt; or the</source>
          <target state="translated">달리 &lt;code&gt;&lt;a href=&quot;functions/dbmopen&quot;&gt;dbmopen&lt;/a&gt;&lt;/code&gt; 의 &lt;code&gt;&lt;a href=&quot;functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; 기능을하지 않습니다 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 하거나 &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; 당신을위한 모듈; 직접 명시 적으로해야합니다. 참조 &lt;a href=&quot;db_file&quot;&gt;DB_File&lt;/a&gt; 또는</target>
        </trans-unit>
        <trans-unit id="7f221507f852d26a177998f0fca0127e91483ffd" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;&lt;a href=&quot;functions/for&quot;&gt;for...in&lt;/a&gt;&lt;/code&gt;, Perl's &lt;code&gt;for&lt;/code&gt; (also spelled &lt;code&gt;foreach&lt;/code&gt; ) does not allow the left-hand side to be an arbitrary expression. It must be a variable:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/for&quot;&gt;for...in&lt;/a&gt;&lt;/code&gt; 과 달리 Perl 's &lt;code&gt;for&lt;/code&gt; (또한 철자법 &lt;code&gt;foreach&lt;/code&gt; )는 왼쪽이 임의의 표현이 될 수 없습니다. 변수 여야합니다.</target>
        </trans-unit>
        <trans-unit id="2d1c847135806754dca42b817cb04eaf19cedf87" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf&lt;/a&gt;&lt;/code&gt; does not do what you probably mean when you pass it an array as your first argument. The array is given scalar context, and instead of using the 0th element of the array as the format, Perl will use the count of elements in the array as the format, which is almost never useful.</source>
          <target state="translated">달리 &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf&lt;/a&gt;&lt;/code&gt; 와 당신이 당신의 첫 번째 인수로 배열을 통과 할 때 아마 당신은 무엇을 의미하지 않습니다. 배열에는 스칼라 컨텍스트가 제공되며 배열의 0 번째 요소를 형식으로 사용하는 대신 Perl은 배열의 요소 수를 형식으로 사용하므로 거의 유용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="89ae4f74127125a7e7d48317841dc79dfceae6a6" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;&lt;a href=&quot;printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;sprintf&quot;&gt;sprintf&lt;/a&gt;&lt;/code&gt; does not do what you probably mean when you pass it an array as your first argument. The array is given scalar context, and instead of using the 0th element of the array as the format, Perl will use the count of elements in the array as the format, which is almost never useful.</source>
          <target state="translated">달리 &lt;code&gt;&lt;a href=&quot;printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;sprintf&quot;&gt;sprintf&lt;/a&gt;&lt;/code&gt; 와 당신이 당신의 첫 번째 인수로 배열을 통과 할 때 아마 당신은 무엇을 의미하지 않습니다. 배열에는 스칼라 컨텍스트가 제공되며 배열의 0 번째 요소를 형식으로 사용하는 대신 Perl은 배열의 요소 수를 형식으로 사용하므로 거의 유용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3b964f91b8b4881dd0085a0962dbd9390808f7e2" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;[[:digit:]]&lt;/code&gt; which matches digits in many writing systems, such as Thai and Devanagari, there are currently only two sets of hexadecimal digits, and it is unlikely that more will be added. This is because you not only need the ten digits, but also the six &lt;code&gt;[A-F]&lt;/code&gt; (and &lt;code&gt;[a-f]&lt;/code&gt;) to correspond. That means only the Latin script is suitable for these, and Unicode has only two sets of these, the familiar ASCII set, and the fullwidth forms starting at U+FF10 (FULLWIDTH DIGIT ZERO).</source>
          <target state="translated">태국어 및 데바 나가 리어와 같은 많은 문자 체계에서 숫자와 일치하는 &lt;code&gt;[[:digit:]]&lt;/code&gt; 와 달리 현재 16 진수 집합은 두 세트 뿐이며 더 이상 추가 될 가능성은 낮습니다. 이는 10 자리 숫자뿐만 아니라 해당하는 6 개의 &lt;code&gt;[A-F]&lt;/code&gt; (및 &lt;code&gt;[a-f]&lt;/code&gt; )도 필요하기 때문입니다. 즉, 라틴어 스크립트 만 이에 적합하며 유니 코드에는 익숙한 ASCII 세트와 U + FF10 (FULLWIDTH DIGIT ZERO)에서 시작하는 전각 형식의 두 세트 만 있습니다.</target>
        </trans-unit>
        <trans-unit id="b58c8c453430fd542b53059b23563075518c8ca7" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;for...in&lt;/code&gt;, Perl's &lt;code&gt;for&lt;/code&gt; (also spelled &lt;code&gt;foreach&lt;/code&gt;) does not allow the left-hand side to be an arbitrary expression. It must be a variable:</source>
          <target state="translated">&lt;code&gt;for...in&lt;/code&gt; 과 달리 Perl의 &lt;code&gt;for&lt;/code&gt; ( &lt;code&gt;foreach&lt;/code&gt; 라고도 함 )는 왼쪽이 임의의 표현식이되는 것을 허용하지 않습니다. 변수 여야합니다.</target>
        </trans-unit>
        <trans-unit id="08ee12c11bcd84febb2422b0c97e2cecef90b3a9" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;use feature &quot;:5.12&quot;&lt;/code&gt;, saying &lt;code&gt;use v5.12&lt;/code&gt; (or any higher version) also does the equivalent of &lt;code&gt;use strict&lt;/code&gt;; see &lt;a href=&quot;perlfunc#use&quot;&gt;&quot;use&quot; in perlfunc&lt;/a&gt; for details.</source>
          <target state="translated">달리 &lt;code&gt;use feature &quot;:5.12&quot;&lt;/code&gt; , 말을 &lt;code&gt;use v5.12&lt;/code&gt; (또는 상위 버전)도에 해당하지 &lt;code&gt;use strict&lt;/code&gt; ; 볼 &lt;a href=&quot;perlfunc#use&quot;&gt;을 perlfunc에서 &quot;사용&quot;&lt;/a&gt; 자세한 내용을.</target>
        </trans-unit>
        <trans-unit id="9885543c31cf8cf0906d34d4b26f89726d373169" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;which&lt;/code&gt; and &lt;code&gt;type&lt;/code&gt; , this function is platform independent and will also work on, for example, Win32.</source>
          <target state="translated">달리 &lt;code&gt;which&lt;/code&gt; 및 &lt;code&gt;type&lt;/code&gt; 기능은 플랫폼에 독립적이며 Win32와 같이 작동합니다.</target>
        </trans-unit>
        <trans-unit id="4fd10722655bcf3a1480d15b870f6c966069d54d" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;which&lt;/code&gt; and &lt;code&gt;type&lt;/code&gt;, this function is platform independent and will also work on, for example, Win32.</source>
          <target state="translated">&lt;code&gt;which&lt;/code&gt; 및 &lt;code&gt;type&lt;/code&gt; 과 달리이 함수는 플랫폼에 독립적이며 예를 들어 Win32에서도 작동합니다.</target>
        </trans-unit>
        <trans-unit id="8c1319ac66a745a073ad45b032e405d0c0606e8b" translate="yes" xml:space="preserve">
          <source>Unlike Perl 4, in which all the variables were dynamic and shared one global name space, causing maintainability problems, Perl 5 provides two mechanisms for protecting code from having its variables stomped on by other code: lexically scoped variables created with &lt;code&gt;my&lt;/code&gt; or &lt;code&gt;state&lt;/code&gt; and namespaced global variables, which are exposed via the &lt;code&gt;vars&lt;/code&gt; pragma, or the &lt;code&gt;our&lt;/code&gt; keyword. Any global variable is considered to be part of a namespace and can be accessed via a &quot;fully qualified form&quot;. Conversely, any lexically scoped variable is considered to be part of that lexical-scope, and does not have a &quot;fully qualified form&quot;.</source>
          <target state="translated">모든 변수는 동적 하였다 및 유지 문제를 일으키는 하나의 글로벌 네임 스페이스를 공유하는 펄 4 달리 펄 5는 변수가 다른 코드에 의해 밟은 않아도 코드를 보호하기위한 두 가지 메커니즘을 제공하여 생성 된 어휘 범위 변수 &lt;code&gt;my&lt;/code&gt; 또는 &lt;code&gt;state&lt;/code&gt; 와 네임 스페이스를 &lt;code&gt;vars&lt;/code&gt; pragma 또는 &lt;code&gt;our&lt;/code&gt; 키워드 를 통해 노출되는 전역 변수 . 모든 전역 변수는 네임 스페이스의 일부로 간주되며 &quot;완전한 형식&quot;을 통해 액세스 할 수 있습니다. 반대로, 어휘 범위 변수는 해당 어휘 범위의 일부로 간주되며 &quot;완전한 형식&quot;이 없습니다.</target>
        </trans-unit>
        <trans-unit id="a35eb11bdbc8f6461d7ed511f9bd108d79a6ba74" translate="yes" xml:space="preserve">
          <source>Unlike Perl's built-in hashes, it is not safe to &lt;code&gt;delete&lt;/code&gt; the current item from a GDBM_File tied hash while iterating over it with &lt;code&gt;each&lt;/code&gt;. This is a limitation of the gdbm library.</source>
          <target state="translated">Perl의 내장 해시와 달리 GDBM_File 연결 해시에서 현재 항목 을 &lt;code&gt;delete&lt;/code&gt; 하는 것은 &lt;code&gt;each&lt;/code&gt; . 이것은 gdbm 라이브러리의 제한 사항입니다.</target>
        </trans-unit>
        <trans-unit id="a93ac07922c6fc8a77d40224ee6574380d8e4055" translate="yes" xml:space="preserve">
          <source>Unlike Win32 build, miniperl will not have</source>
          <target state="translated">Win32 빌드와 달리 miniperl은</target>
        </trans-unit>
        <trans-unit id="a7c35c87e2cd92f458c69ed20a29518c1fc60ceb" translate="yes" xml:space="preserve">
          <source>Unlike constants in some languages, these cannot be overridden on the command line or via environment variables.</source>
          <target state="translated">일부 언어의 상수와 달리 명령 행 또는 환경 변수를 통해이를 재정의 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="2e9d61b3ed80ed71e7bbbb9d575bf23b5d77fb98" translate="yes" xml:space="preserve">
          <source>Unlike dbmopen(), the tie() function will not &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; a module for you--you need to do that explicitly yourself.</source>
          <target state="translated">dbmopen ()과 달리 tie () 함수는 모듈을 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 하지 않거나 &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; 로 하지 않으므로 직접 명시 적으로 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="ac457fcb4cff6e9b40b4fc09afe6c228026b2c13" translate="yes" xml:space="preserve">
          <source>Unlike dbmopen(), the tie() function will not &lt;code&gt;use&lt;/code&gt; or &lt;code&gt;require&lt;/code&gt; a module for you--you need to do that explicitly yourself.</source>
          <target state="translated">dbmopen ()과 달리 tie () 함수는 모듈을 &lt;code&gt;use&lt;/code&gt; 하거나 &lt;code&gt;require&lt;/code&gt; 로 하지 않습니다 . 명시 적으로 직접 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="ae7d99bfc8b3205da369ad185c97fc4f2004cc75" translate="yes" xml:space="preserve">
          <source>Unlike dynamic variables created by the &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; operator, lexical variables declared with &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; are totally hidden from the outside world, including any called subroutines. This is true if it's the same subroutine called from itself or elsewhere--every call gets its own copy.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; 연산자에 의해 생성 된 동적 변수와 달리 , &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; 로 선언 된 어휘 변수는 호출 된 서브 루틴을 포함하여 외부 세계에서 완전히 숨겨져 있습니다. 자체 또는 다른 곳에서 호출 된 동일한 서브 루틴 인 경우에 해당합니다. 모든 호출은 자체 사본을받습니다.</target>
        </trans-unit>
        <trans-unit id="ef30321397c8a6c2a145849a1e7eb34fc5044060" translate="yes" xml:space="preserve">
          <source>Unlike dynamic variables created by the &lt;code&gt;local&lt;/code&gt; operator, lexical variables declared with &lt;code&gt;my&lt;/code&gt; are totally hidden from the outside world, including any called subroutines. This is true if it's the same subroutine called from itself or elsewhere--every call gets its own copy.</source>
          <target state="translated">&lt;code&gt;local&lt;/code&gt; 연산자에 의해 생성 된 동적 변수와 달리 &lt;code&gt;my&lt;/code&gt; 로 선언 된 어휘 변수는 호출 된 모든 서브 루틴을 포함하여 외부 세계에서 완전히 숨겨집니다. 이는 자체 또는 다른 곳에서 호출 된 동일한 서브 루틴 인 경우에 해당됩니다. 모든 호출은 자체 복사본을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="f1d613b9dfee0f458298b76229e47572b9ad09a4" translate="yes" xml:space="preserve">
          <source>Unlike in C and Pascal, in Perl these are all defined in terms of BLOCKs, not statements. This means that the curly brackets are</source>
          <target state="translated">C 및 Pascal과 달리 Perl에서는 모두 명령문이 아니라 BLOCK으로 정의됩니다. 이것은 중괄호가</target>
        </trans-unit>
        <trans-unit id="f21336a91710bef15208089eafb11092016626b2" translate="yes" xml:space="preserve">
          <source>Unlike in C, the scalar assignment operator produces a valid lvalue. Modifying an assignment is equivalent to doing the assignment and then modifying the variable that was assigned to. This is useful for modifying a copy of something, like this:</source>
          <target state="translated">C와 달리 스칼라 대입 연산자는 유효한 lvalue를 생성합니다. 할당을 수정하는 것은 할당을 수행 한 다음 할당 된 변수를 수정하는 것과 같습니다. 다음과 같이 무언가의 사본을 수정하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="5f827eec6110de095ec9210c18c9cbffc634099b" translate="yes" xml:space="preserve">
          <source>Unlike in earlier versions of Perl, &lt;code&gt;:raw&lt;/code&gt; is</source>
          <target state="translated">이전 버전의 Perl과 달리 &lt;code&gt;:raw&lt;/code&gt; 는</target>
        </trans-unit>
        <trans-unit id="33bdaa80be75964fba31840d455d3822e7d396b4" translate="yes" xml:space="preserve">
          <source>Unlike just splitting the directories on the separator, empty directory names (&lt;code&gt;&quot;&quot;&lt;/code&gt; ) can be returned. Since &lt;code&gt;catdir()&lt;/code&gt; on Mac OS always appends a trailing colon to distinguish a directory path from a file path, a single trailing colon will be ignored, i.e. there's no empty directory name after it.</source>
          <target state="translated">구분 기호에서 디렉토리를 분할하는 것과 달리 빈 디렉토리 이름 ( &lt;code&gt;&quot;&quot;&lt;/code&gt; )이 리턴 될 수 있습니다. 이후 &lt;code&gt;catdir()&lt;/code&gt; 맥 OS에 항상 파일 경로에서 디렉토리 경로를 구분하기 위해 뒤에 콜론을 추가, 하나의 후행 콜론은 이후 빈 디렉토리 이름이 없다, 즉, 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="7e91e9b08f85424586bbe7fa7e02138bcae68a32" translate="yes" xml:space="preserve">
          <source>Unlike just splitting the directories on the separator, empty directory names (&lt;code&gt;&quot;&quot;&lt;/code&gt;) can be returned. Since &lt;code&gt;catdir()&lt;/code&gt; on Mac OS always appends a trailing colon to distinguish a directory path from a file path, a single trailing colon will be ignored, i.e. there's no empty directory name after it.</source>
          <target state="translated">구분 기호로 디렉터리를 분할하는 것과 달리 빈 디렉터리 이름 ( &lt;code&gt;&quot;&quot;&lt;/code&gt; )이 반환 될 수 있습니다. 이후 &lt;code&gt;catdir()&lt;/code&gt; 맥 OS에 항상 파일 경로에서 디렉토리 경로를 구분하기 위해 뒤에 콜론을 추가, 하나의 후행 콜론은 이후 빈 디렉토리 이름이 없다, 즉, 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="54463777f2a5a26bb28578fbecd0a237664559d0" translate="yes" xml:space="preserve">
          <source>Unlike just splitting the directories on the separator, empty directory names (&lt;code&gt;''&lt;/code&gt; ) can be returned, because these are significant on some OSes.</source>
          <target state="translated">구분 기호에서 디렉토리를 분할하는 것과 달리 빈 디렉토리 이름 ( &lt;code&gt;''&lt;/code&gt; )은 일부 OS에서 중요하기 때문에 리턴 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="86f74613bf49290364595249fc093a5b0e46c0b1" translate="yes" xml:space="preserve">
          <source>Unlike just splitting the directories on the separator, empty directory names (&lt;code&gt;''&lt;/code&gt; ) can be returned, because these are significant on some OSs.</source>
          <target state="translated">구분 기호에서 디렉토리를 분할하는 것과 달리 빈 디렉토리 이름 ( &lt;code&gt;''&lt;/code&gt; )은 일부 OS에서 중요하기 때문에 리턴 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a1dab7e402fccbdcf23288af9af78be14a2bd58c" translate="yes" xml:space="preserve">
          <source>Unlike just splitting the directories on the separator, empty directory names (&lt;code&gt;''&lt;/code&gt;) can be returned, because these are significant on some OSes.</source>
          <target state="translated">구분 기호로 디렉터리를 분할하는 것과 달리 일부 OS에서는 중요하므로 빈 디렉터리 이름 ( &lt;code&gt;''&lt;/code&gt; )이 반환 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6113c750f78736baa4aa9cd996719b663fd9d18d" translate="yes" xml:space="preserve">
          <source>Unlike just splitting the directories on the separator, empty directory names (&lt;code&gt;''&lt;/code&gt;) can be returned, because these are significant on some OSs.</source>
          <target state="translated">구분 기호로 디렉터리를 분할하는 것과 달리 일부 OS에서는 중요하므로 빈 디렉터리 이름 ( &lt;code&gt;''&lt;/code&gt; )이 반환 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f0601a2027041706b4a215c5ba97b0f2d038f55f" translate="yes" xml:space="preserve">
          <source>Unlike just splitting the directories on the separator, leading empty and trailing directory entries can be returned, because these are significant on some OSs. So,</source>
          <target state="translated">구분 기호에서 디렉토리를 분할하는 것과 달리 선행 OS 및 후행 디렉토리 항목은 일부 OS에서 중요하기 때문에 리턴 될 수 있습니다. 그래서,</target>
        </trans-unit>
        <trans-unit id="7934f43f05e561c630f325debe8a290638569198" translate="yes" xml:space="preserve">
          <source>Unlike local variables in C or C++, Perl's lexical variables don't necessarily get recycled just because their scope has exited. If something more permanent is still aware of the lexical, it will stick around. So long as something else references a lexical, that lexical won't be freed--which is as it should be. You wouldn't want memory being free until you were done using it, or kept around once you were done. Automatic garbage collection takes care of this for you.</source>
          <target state="translated">C 또는 C ++의 로컬 변수와 달리 Perl의 어휘 변수는 해당 범위가 종료되어 반드시 재활용되지는 않습니다. 더 영원한 무언가가 여전히 어휘를 알고 있다면, 그것은 붙어 있습니다. 다른 것이 어휘를 참조하는 한, 어휘는 풀리지 않을 것입니다. 메모리 사용이 끝날 때까지 또는 사용이 끝난 후에는 메모리를 비우기를 원하지 않을 것입니다. 자동 가비지 콜렉션이이를 처리합니다.</target>
        </trans-unit>
        <trans-unit id="61c2bf5d9fb9c4e4b449918bf685b7cd4c575760" translate="yes" xml:space="preserve">
          <source>Unlike many other languages which support object orientation, Perl does not provide any special syntax for constructing an object. Objects are merely Perl data structures (hashes, arrays, scalars, filehandles, etc.) that have been explicitly associated with a particular class.</source>
          <target state="translated">객체 지향을 지원하는 다른 많은 언어와 달리 Perl은 객체 구성을위한 특별한 구문을 제공하지 않습니다. 객체는 특정 클래스와 명시 적으로 연결된 Perl 데이터 구조 (해시, 배열, 스칼라, 파일 핸들 등) 일뿐입니다.</target>
        </trans-unit>
        <trans-unit id="96a17407e83fd96732a811a270065f8bf99b9560" translate="yes" xml:space="preserve">
          <source>Unlike most encodings which accept various ways to handle errors, Unicode encodings simply croaks.</source>
          <target state="translated">오류를 처리하는 다양한 방법을 허용하는 대부분의 인코딩과 달리 유니 코드 인코딩은 단순히 삐걱 거립니다.</target>
        </trans-unit>
        <trans-unit id="49b673e0d13d9cc508ff95ef6bf45edac94a0386" translate="yes" xml:space="preserve">
          <source>Unlike most locales, which are specific to a language and country pair, Unicode classifies all the characters that are letters</source>
          <target state="translated">언어 및 국가 쌍에 특정한 대부분의 로캘과 달리 유니 코드는 문자 인 모든 문자를 분류합니다</target>
        </trans-unit>
        <trans-unit id="de28345f4c14a0c66a5513ec93329ba001d9ced5" translate="yes" xml:space="preserve">
          <source>Unlike most named operators, this has the same precedence as assignment. It is also exempt from the looks-like-a-function rule, so &lt;code&gt;&lt;a href=&quot;dump&quot;&gt;dump&lt;/a&gt; (&quot;foo&quot;).&quot;bar&quot;&lt;/code&gt; will cause &quot;bar&quot; to be part of the argument to &lt;code&gt;&lt;a href=&quot;dump&quot;&gt;dump&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">대부분의 명명 된 연산자와 달리 할당과 동일한 우선 순위를 갖습니다. 또한 함수 모양과 같은 규칙에서 제외되므로 &lt;code&gt;&lt;a href=&quot;dump&quot;&gt;dump&lt;/a&gt; (&quot;foo&quot;).&quot;bar&quot;&lt;/code&gt; 는 &quot;bar&quot; 가 &lt;code&gt;&lt;a href=&quot;dump&quot;&gt;dump&lt;/a&gt;&lt;/code&gt; 인수의 일부가되도록합니다 .</target>
        </trans-unit>
        <trans-unit id="c0d9558dea8e06eb18c291c6122258af13477176" translate="yes" xml:space="preserve">
          <source>Unlike most named operators, this has the same precedence as assignment. It is also exempt from the looks-like-a-function rule, so &lt;code&gt;&lt;a href=&quot;functions/dump&quot;&gt;dump&lt;/a&gt; (&quot;foo&quot;).&quot;bar&quot;&lt;/code&gt; will cause &quot;bar&quot; to be part of the argument to &lt;code&gt;&lt;a href=&quot;functions/dump&quot;&gt;dump&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">대부분의 명명 된 연산자와 달리 할당과 동일한 우선 순위를 갖습니다. 또한 함수 모양과 같은 규칙에서 제외되므로 &lt;code&gt;&lt;a href=&quot;functions/dump&quot;&gt;dump&lt;/a&gt; (&quot;foo&quot;).&quot;bar&quot;&lt;/code&gt; 는 &quot;bar&quot; 가 &lt;code&gt;&lt;a href=&quot;functions/dump&quot;&gt;dump&lt;/a&gt;&lt;/code&gt; 인수의 일부가되도록합니다 .</target>
        </trans-unit>
        <trans-unit id="9b35f8dffb5619dd71375e3734d385be7cc68976" translate="yes" xml:space="preserve">
          <source>Unlike most named operators, this has the same precedence as assignment. It is also exempt from the looks-like-a-function rule, so &lt;code&gt;&lt;a href=&quot;functions/last&quot;&gt;last&lt;/a&gt; (&quot;foo&quot;).&quot;bar&quot;&lt;/code&gt; will cause &quot;bar&quot; to be part of the argument to &lt;code&gt;&lt;a href=&quot;functions/last&quot;&gt;last&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">대부분의 명명 된 연산자와 달리 할당과 동일한 우선 순위를 갖습니다. 또한 함수 모양과 같은 규칙에서 제외되므로 &lt;code&gt;&lt;a href=&quot;functions/last&quot;&gt;last&lt;/a&gt; (&quot;foo&quot;).&quot;bar&quot;&lt;/code&gt; 는 &quot;bar&quot;를 &lt;code&gt;&lt;a href=&quot;functions/last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; 인수의 일부로 만듭니다. .</target>
        </trans-unit>
        <trans-unit id="642dec0f5e46307ce9e97ef7e93a9392f0b1f7ab" translate="yes" xml:space="preserve">
          <source>Unlike most named operators, this has the same precedence as assignment. It is also exempt from the looks-like-a-function rule, so &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt; (&quot;foo&quot;).&quot;bar&quot;&lt;/code&gt; will cause &quot;bar&quot; to be part of the argument to &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">대부분의 명명 된 연산자와 달리 할당과 동일한 우선 순위를 갖습니다. 또한 look-like-a-function 규칙에서 제외되므로 &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt; (&quot;foo&quot;).&quot;bar&quot;&lt;/code&gt; 는 &quot;bar&quot; 가 &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; 에 대한 인수의 일부가되도록합니다 .</target>
        </trans-unit>
        <trans-unit id="8e8af66683db3fc2cddaa8cdf32b4f53ebab4445" translate="yes" xml:space="preserve">
          <source>Unlike most named operators, this has the same precedence as assignment. It is also exempt from the looks-like-a-function rule, so &lt;code&gt;&lt;a href=&quot;functions/redo&quot;&gt;redo&lt;/a&gt; (&quot;foo&quot;).&quot;bar&quot;&lt;/code&gt; will cause &quot;bar&quot; to be part of the argument to &lt;code&gt;&lt;a href=&quot;functions/redo&quot;&gt;redo&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">대부분의 명명 된 연산자와 달리 할당과 동일한 우선 순위를 갖습니다. 또한 함수처럼 보이는 규칙에서 제외되므로 &lt;code&gt;&lt;a href=&quot;functions/redo&quot;&gt;redo&lt;/a&gt; (&quot;foo&quot;).&quot;bar&quot;&lt;/code&gt; 는 &quot;bar&quot; 가 &lt;code&gt;&lt;a href=&quot;functions/redo&quot;&gt;redo&lt;/a&gt;&lt;/code&gt; 인수의 일부가되도록합니다 .</target>
        </trans-unit>
        <trans-unit id="5bec2254ea41ddda3ef06eefb12b88f8ff1170ba" translate="yes" xml:space="preserve">
          <source>Unlike most named operators, this has the same precedence as assignment. It is also exempt from the looks-like-a-function rule, so &lt;code&gt;&lt;a href=&quot;last&quot;&gt;last&lt;/a&gt; (&quot;foo&quot;).&quot;bar&quot;&lt;/code&gt; will cause &quot;bar&quot; to be part of the argument to &lt;code&gt;&lt;a href=&quot;last&quot;&gt;last&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">대부분의 명명 된 연산자와 달리 할당과 동일한 우선 순위를 갖습니다. 또한 함수 모양과 같은 규칙에서 제외되므로 &lt;code&gt;&lt;a href=&quot;last&quot;&gt;last&lt;/a&gt; (&quot;foo&quot;).&quot;bar&quot;&lt;/code&gt; 는 &quot;bar&quot; 가 &lt;code&gt;&lt;a href=&quot;last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; 인수의 일부가되도록합니다 .</target>
        </trans-unit>
        <trans-unit id="46f28e7c4c55184f01ee0fc59018a927acd8437c" translate="yes" xml:space="preserve">
          <source>Unlike most named operators, this has the same precedence as assignment. It is also exempt from the looks-like-a-function rule, so &lt;code&gt;&lt;a href=&quot;next&quot;&gt;next&lt;/a&gt; (&quot;foo&quot;).&quot;bar&quot;&lt;/code&gt; will cause &quot;bar&quot; to be part of the argument to &lt;code&gt;&lt;a href=&quot;next&quot;&gt;next&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">대부분의 명명 된 연산자와 달리 할당과 동일한 우선 순위를 갖습니다. 또한 look-like-a-function 규칙에서 제외되므로 &lt;code&gt;&lt;a href=&quot;next&quot;&gt;next&lt;/a&gt; (&quot;foo&quot;).&quot;bar&quot;&lt;/code&gt; 는 &quot;bar&quot; 가 &lt;code&gt;&lt;a href=&quot;next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; 에 대한 인수의 일부가되도록합니다 .</target>
        </trans-unit>
        <trans-unit id="fe0bcbfb6300fcbe2507c49b4631d20697de525c" translate="yes" xml:space="preserve">
          <source>Unlike most named operators, this has the same precedence as assignment. It is also exempt from the looks-like-a-function rule, so &lt;code&gt;&lt;a href=&quot;redo&quot;&gt;redo&lt;/a&gt; (&quot;foo&quot;).&quot;bar&quot;&lt;/code&gt; will cause &quot;bar&quot; to be part of the argument to &lt;code&gt;&lt;a href=&quot;redo&quot;&gt;redo&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">대부분의 명명 된 연산자와 달리 할당과 동일한 우선 순위를 갖습니다. 또한 함수처럼 보이는 규칙에서 제외되므로 &lt;code&gt;&lt;a href=&quot;redo&quot;&gt;redo&lt;/a&gt; (&quot;foo&quot;).&quot;bar&quot;&lt;/code&gt; 는 &quot;bar&quot; 가 &lt;code&gt;&lt;a href=&quot;redo&quot;&gt;redo&lt;/a&gt;&lt;/code&gt; 인수의 일부가되도록합니다 .</target>
        </trans-unit>
        <trans-unit id="34c00fe043d78656afd77828c738549c64c1fe0d" translate="yes" xml:space="preserve">
          <source>Unlike most named operators, this has the same precedence as assignment. It is also exempt from the looks-like-a-function rule, so &lt;code&gt;dump (&quot;foo&quot;).&quot;bar&quot;&lt;/code&gt; will cause &quot;bar&quot; to be part of the argument to &lt;a href=&quot;#dump-LABEL&quot;&gt;&lt;code&gt;dump&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">대부분의 명명 된 연산자와 달리 이것은 할당과 동일한 우선 순위를 갖습니다. 또한 함수처럼 보이는 규칙에서 제외되므로 &lt;code&gt;dump (&quot;foo&quot;).&quot;bar&quot;&lt;/code&gt; 는 &quot;bar&quot; 가 &lt;a href=&quot;#dump-LABEL&quot;&gt; &lt;code&gt;dump&lt;/code&gt; &lt;/a&gt; 인수의 일부가되도록합니다 .</target>
        </trans-unit>
        <trans-unit id="a22585aa0bd13d608250b8dcea334b07dd252021" translate="yes" xml:space="preserve">
          <source>Unlike most named operators, this has the same precedence as assignment. It is also exempt from the looks-like-a-function rule, so &lt;code&gt;last (&quot;foo&quot;).&quot;bar&quot;&lt;/code&gt; will cause &quot;bar&quot; to be part of the argument to &lt;a href=&quot;#last-LABEL&quot;&gt;&lt;code&gt;last&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">대부분의 명명 된 연산자와 달리 이것은 할당과 동일한 우선 순위를 갖습니다. 또한 함수처럼 보이는 규칙에서 제외되므로 &lt;code&gt;last (&quot;foo&quot;).&quot;bar&quot;&lt;/code&gt; 는 &quot;bar&quot; 가 &lt;a href=&quot;#last-LABEL&quot;&gt; &lt;code&gt;last&lt;/code&gt; &lt;/a&gt; 인수의 일부가되도록합니다 .</target>
        </trans-unit>
        <trans-unit id="bec12e43efad3d3a645f2714eff3a43a7be31992" translate="yes" xml:space="preserve">
          <source>Unlike most named operators, this has the same precedence as assignment. It is also exempt from the looks-like-a-function rule, so &lt;code&gt;next (&quot;foo&quot;).&quot;bar&quot;&lt;/code&gt; will cause &quot;bar&quot; to be part of the argument to &lt;a href=&quot;#next-LABEL&quot;&gt;&lt;code&gt;next&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">대부분의 명명 된 연산자와 달리 이것은 할당과 동일한 우선 순위를 갖습니다. 또한 함수처럼 보이는 규칙에서 제외되므로 &lt;code&gt;next (&quot;foo&quot;).&quot;bar&quot;&lt;/code&gt; 는 &quot;bar&quot; 가 &lt;a href=&quot;#next-LABEL&quot;&gt; &lt;code&gt;next&lt;/code&gt; &lt;/a&gt; 에 대한 인수의 일부가되도록합니다 .</target>
        </trans-unit>
        <trans-unit id="03dc19f120a0108be730d05ae2cc974e390f447d" translate="yes" xml:space="preserve">
          <source>Unlike most named operators, this has the same precedence as assignment. It is also exempt from the looks-like-a-function rule, so &lt;code&gt;redo (&quot;foo&quot;).&quot;bar&quot;&lt;/code&gt; will cause &quot;bar&quot; to be part of the argument to &lt;a href=&quot;#redo-LABEL&quot;&gt;&lt;code&gt;redo&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">대부분의 명명 된 연산자와 달리 이것은 할당과 동일한 우선 순위를 갖습니다. 또한 함수처럼 보이는 규칙에서 제외되므로 &lt;code&gt;redo (&quot;foo&quot;).&quot;bar&quot;&lt;/code&gt; 는 &quot;bar&quot; 가 &lt;a href=&quot;#redo-LABEL&quot;&gt; &lt;code&gt;redo&lt;/code&gt; &lt;/a&gt; 인수의 일부가되도록합니다 .</target>
        </trans-unit>
        <trans-unit id="3ee3973cea98d2564d41622c65ad1eadc9b20495" translate="yes" xml:space="preserve">
          <source>Unlike most named operators, this is also exempt from the looks-like-a-function rule, so &lt;code&gt;&lt;a href=&quot;functions/return&quot;&gt;return&lt;/a&gt; (&quot;foo&quot;).&quot;bar&quot;&lt;/code&gt; will cause &quot;bar&quot; to be part of the argument to &lt;code&gt;&lt;a href=&quot;functions/return&quot;&gt;return&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">대부분의 명명 된 연산자와는 달리, 이는 모양과 같은 규칙에서 제외되므로 &lt;code&gt;&lt;a href=&quot;functions/return&quot;&gt;return&lt;/a&gt; (&quot;foo&quot;).&quot;bar&quot;&lt;/code&gt; 는 &quot;bar&quot; 가 &lt;code&gt;&lt;a href=&quot;functions/return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; 의 인수의 일부가 됩니다.</target>
        </trans-unit>
        <trans-unit id="fd9949db65a27c0400a1254746b3e91b925c452b" translate="yes" xml:space="preserve">
          <source>Unlike most named operators, this is also exempt from the looks-like-a-function rule, so &lt;code&gt;&lt;a href=&quot;return&quot;&gt;return&lt;/a&gt; (&quot;foo&quot;).&quot;bar&quot;&lt;/code&gt; will cause &quot;bar&quot; to be part of the argument to &lt;code&gt;&lt;a href=&quot;return&quot;&gt;return&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">대부분의 명명 된 연산자와는 달리, 이는 모양과 같은 규칙에서 제외되므로 &lt;code&gt;&lt;a href=&quot;return&quot;&gt;return&lt;/a&gt; (&quot;foo&quot;).&quot;bar&quot;&lt;/code&gt; 는 &quot;bar&quot; 가 &lt;code&gt;&lt;a href=&quot;return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; 의 인수의 일부가 됩니다.</target>
        </trans-unit>
        <trans-unit id="c7a5022b5ad46573ca70c92672e20e032530725b" translate="yes" xml:space="preserve">
          <source>Unlike most named operators, this is also exempt from the looks-like-a-function rule, so &lt;code&gt;return (&quot;foo&quot;).&quot;bar&quot;&lt;/code&gt; will cause &lt;code&gt;&quot;bar&quot;&lt;/code&gt; to be part of the argument to &lt;a href=&quot;#return-EXPR&quot;&gt;&lt;code&gt;return&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">대부분의 명명 된 연산자와 달리 이것은 함수와 유사한 규칙에서도 제외되므로 &lt;code&gt;return (&quot;foo&quot;).&quot;bar&quot;&lt;/code&gt; 를 사용하면 &lt;code&gt;&quot;bar&quot;&lt;/code&gt; 가를 &lt;a href=&quot;#return-EXPR&quot;&gt; &lt;code&gt;return&lt;/code&gt; &lt;/a&gt; 하는 인수의 일부가 됩니다.</target>
        </trans-unit>
        <trans-unit id="728a32d1ef745efc09c9a2c8f8520f5d6f4c4b95" translate="yes" xml:space="preserve">
          <source>Unlike most of the other functions that have &lt;code&gt;utf8&lt;/code&gt; in their name, the input to this function is NOT a UTF-8-encoded string. The function name is slightly</source>
          <target state="translated">이름에 &lt;code&gt;utf8&lt;/code&gt; 이 있는 대부분의 다른 함수와 달리이 함수 에 대한 입력은 UTF-8로 인코딩 된 문자열이 아닙니다. 함수 이름은 약간</target>
        </trans-unit>
        <trans-unit id="d21a9fd801c4b5ff299a1a5bef8631136555ebd2" translate="yes" xml:space="preserve">
          <source>Unlike most operators, the smartmatch operator knows to treat &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; specially:</source>
          <target state="translated">대부분의 연산자와 달리 smartmatch 연산자는 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 를 특별히 처리하는 것을 알고 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a099365433c865a39830b29bcea8462ee44a1ac6" translate="yes" xml:space="preserve">
          <source>Unlike most operators, the smartmatch operator knows to treat &lt;code&gt;undef&lt;/code&gt; specially:</source>
          <target state="translated">대부분의 연산자와 달리 smartmatch 연산자는 &lt;code&gt;undef&lt;/code&gt; 를 특별히 처리하는 방법을 알고 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c52ae364f54ddc8596b506c3503500a0182fc785" translate="yes" xml:space="preserve">
          <source>Unlike most other encodings, the following always croaks on error for any $chk that evaluates to true.</source>
          <target state="translated">대부분의 다른 인코딩과 달리 다음은 true로 평가되는 $ chk에 대해 항상 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="3d20af86f51aab9cb74465f15c6036108807e949" translate="yes" xml:space="preserve">
          <source>Unlike non-user-defined &lt;code&gt;\p{}&lt;/code&gt; property matches, no warning is ever generated if these properties are matched against a non-Unicode code point (see &lt;a href=&quot;#Beyond-Unicode-code-points&quot;&gt;&quot;Beyond Unicode code points&quot;&lt;/a&gt; below).</source>
          <target state="translated">비 사용자 정의 &lt;code&gt;\p{}&lt;/code&gt; 속성 일치 와 달리 이러한 속성이 비 유니 코드 코드 포인트와 일치하는 경우 경고가 생성되지 않습니다 (아래의 &lt;a href=&quot;#Beyond-Unicode-code-points&quot;&gt;&quot;유니 코드 코드 포인트 이상&quot;&lt;/a&gt; 참조).</target>
        </trans-unit>
        <trans-unit id="a0be45e558750e70d5ad5d40843ef88fbc85d85e" translate="yes" xml:space="preserve">
          <source>Unlike non-user-defined &lt;code&gt;\p{}&lt;/code&gt; property matches, no warning is ever generated if these properties are matched against a non-Unicode code point (see &lt;a href=&quot;#Beyond-Unicode-code-points&quot;&gt;Beyond Unicode code points&lt;/a&gt; below).</source>
          <target state="translated">사용자가 정의하지 않은 &lt;code&gt;\p{}&lt;/code&gt; 속성 일치 와 달리 이러한 속성이 유니 코드가 아닌 코드 포인트와 일치하는 경우 경고가 생성되지 않습니다 ( 아래의 &lt;a href=&quot;#Beyond-Unicode-code-points&quot;&gt;유니 코드 코드 포인트를 넘어서&lt;/a&gt; 참조).</target>
        </trans-unit>
        <trans-unit id="54d85676113e32968ab38ead192e565266d17ce6" translate="yes" xml:space="preserve">
          <source>Unlike other DJGPP packages, which are normal &quot;zip&quot; files, most CPAN module packages are &quot;gzipped tarballs&quot;. Recent versions of WinZip will safely unpack and expand them, *UNLESS* they have zero-length files. It is a known WinZip bug (as of v7.0) that it will not extract zero-length files.</source>
          <target state="translated">일반적인 &quot;zip&quot;파일 인 다른 DJGPP 패키지와 달리 대부분의 CPAN 모듈 패키지는 &quot;gzipped tarballs&quot;입니다. 최신 버전의 WinZip은 안전하게 압축을 풀고 확장합니다. * UNLESS *에는 길이가 0 인 파일이 있습니다. 길이가 0 인 파일을 추출하지 않는 것으로 알려진 WinZip 버그 (v7.0 기준)입니다.</target>
        </trans-unit>
        <trans-unit id="7d1d9ddacb9cc957a1381975755b447def4208e7" translate="yes" xml:space="preserve">
          <source>Unlike other boolean options, this opotion is enabled by default beginning with version &lt;code&gt;4.0&lt;/code&gt;.</source>
          <target state="translated">다른 부울 옵션과 달리이 옵션은 버전 &lt;code&gt;4.0&lt;/code&gt; 부터 기본적으로 활성화됩니다 .</target>
        </trans-unit>
        <trans-unit id="83864ffb2b433053a7d93f1893b27cbe33018e20" translate="yes" xml:space="preserve">
          <source>Unlike other encodings where mappings are not one-to-one against Unicode, UTFs are supposed to map 100% against one another. So Encode is more strict on UTFs.</source>
          <target state="translated">유니 코드에 대한 매핑이 일대일이 아닌 다른 인코딩과 달리 UTF는 서로 100 %를 매핑해야합니다. 따라서 인코딩은 UTF에서 더 엄격합니다.</target>
        </trans-unit>
        <trans-unit id="9944da74f109a50432581cc20ef1a61578ffdb1c" translate="yes" xml:space="preserve">
          <source>Unlike other types of quote-like literals, a here document is rarely a contiguous substring. For example, a typical piece of code using here document might look like this:</source>
          <target state="translated">다른 유형의 따옴표와 같은 리터럴과 달리 here 문서는 연속 하위 문자열이 아닙니다. 예를 들어 here 문서를 사용하는 일반적인 코드는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="82bfb2284168959f095690d2be25e5ae6b5a6d2d" translate="yes" xml:space="preserve">
          <source>Unlike pragmas that affect the &lt;code&gt;$^H&lt;/code&gt; hints variable, the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; vars&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; subs&lt;/code&gt; declarations are not BLOCK-scoped. They are thus effective for the entire file in which they appear. You may not rescind such declarations with &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; vars&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; subs&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;$^H&lt;/code&gt; 힌트 변수에 영향을주는 pragma와 달리 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; vars&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; subs&lt;/code&gt; 선언은 BLOCK 범위가 아닙니다. 따라서 표시되는 전체 파일에 효과적입니다. 당신은 선언을 철회하지 않을 수 있습니다 &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; vars&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; subs&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="946dc8e2b9e4dbb1e056eab35da113b4edec1e74" translate="yes" xml:space="preserve">
          <source>Unlike pragmas that affect the &lt;code&gt;$^H&lt;/code&gt; hints variable, the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; vars&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; subs&lt;/code&gt; declarations are not BLOCK-scoped. They are thus effective for the entire package in which they appear. You may not rescind such declarations with &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; vars&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; subs&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;$^H&lt;/code&gt; 힌트 변수에 영향을주는 pragma와 달리 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; vars&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; subs&lt;/code&gt; 선언은 BLOCK 범위가 아닙니다. 따라서 표시되는 전체 패키지에 효과적입니다. 당신은 선언을 철회하지 않을 수 있습니다 &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; vars&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; subs&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ee09d59fb829cfd66034aa9b684c476eb3f881a3" translate="yes" xml:space="preserve">
          <source>Unlike pragmas that affect the &lt;code&gt;$^H&lt;/code&gt; hints variable, the &lt;code&gt;use vars&lt;/code&gt; and &lt;code&gt;use subs&lt;/code&gt; declarations are not lexically scoped to the block they appear in: they affect the entire package in which they appear. It is not possible to rescind these declarations with &lt;code&gt;no vars&lt;/code&gt; or &lt;code&gt;no subs&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;$^H&lt;/code&gt; 힌트 변수에 영향을주는 pragma와 달리 &lt;code&gt;use vars&lt;/code&gt; 및 &lt;code&gt;use subs&lt;/code&gt; 선언은 표시되는 블록에 어휘 적으로 범위가 지정되지 않습니다. 표시되는 전체 패키지에 영향을줍니다. &lt;code&gt;no vars&lt;/code&gt; 또는 &lt;code&gt;no subs&lt;/code&gt; 없이 이러한 선언을 취소 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="a62fc8b32926f79e07e4cd739d192b4db682422d" translate="yes" xml:space="preserve">
          <source>Unlike previous examples, we've now run h2xs on a real include file. This has caused some extra goodies to appear in both the .pm and .xs files.</source>
          <target state="translated">이전 예제와 달리 이제 실제 포함 파일에서 h2x를 실행했습니다. 이로 인해 .pm 및 .xs 파일에 일부 추가 기능이 나타납니다.</target>
        </trans-unit>
        <trans-unit id="1ef80340079fb27e8a35fae5de34324e0ae68abb" translate="yes" xml:space="preserve">
          <source>Unlike the &lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt; implementations, the directory used for the temporary file is not specified in a system include file (&lt;code&gt;P_tmpdir&lt;/code&gt;) but simply depends on the choice of tmpdir() returned by &lt;a href=&quot;File::Spec&quot;&gt;File::Spec&lt;/a&gt;. On some implementations this location can be set using the &lt;code&gt;TMPDIR&lt;/code&gt; environment variable, which may not be secure. If this is a problem, simply use mkstemp() and specify a template.</source>
          <target state="translated">&lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt; 구현 과 달리 임시 파일에 사용되는 디렉토리는 시스템 포함 파일 ( &lt;code&gt;P_tmpdir&lt;/code&gt; )에 지정되지 않고 단순히 &lt;a href=&quot;File::Spec&quot;&gt;File :: Spec에서&lt;/a&gt; 반환 된 tmpdir () 선택에 따라 달라집니다 . 일부 구현에서이 위치는 안전하지 않을 수 있는 &lt;code&gt;TMPDIR&lt;/code&gt; 환경 변수를 사용하여 설정할 수 있습니다 . 이것이 문제라면 mkstemp ()를 사용하고 템플릿을 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="82613342b350d8ac2d5e700389b419d73a2e8511" translate="yes" xml:space="preserve">
          <source>Unlike the &lt;code&gt;Newx&lt;/code&gt; and &lt;code&gt;Newxc&lt;/code&gt; macros, the &lt;code&gt;Newxz&lt;/code&gt; macro calls &lt;code&gt;memzero&lt;/code&gt; to zero out all the newly allocated memory.</source>
          <target state="translated">&lt;code&gt;Newx&lt;/code&gt; 및 &lt;code&gt;Newxc&lt;/code&gt; 매크로 와 달리 &lt;code&gt;Newxz&lt;/code&gt; 매크로는 &lt;code&gt;memzero&lt;/code&gt; 를 호출 하여 새로 할당 된 모든 메모리를 0으로 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="3459d8de61947e832dd8d6cc93a45a157f32fe5d" translate="yes" xml:space="preserve">
          <source>Unlike the GNU programs,</source>
          <target state="translated">GNU 프로그램과 달리</target>
        </trans-unit>
        <trans-unit id="675122bbd6fe9d02ab821cef4f122f1e2fdb7554" translate="yes" xml:space="preserve">
          <source>Unlike the L</source>
          <target state="translated">L과 달리</target>
        </trans-unit>
        <trans-unit id="00946f20f0f39de3fde945a1c4762c9a2eb54a4d" translate="yes" xml:space="preserve">
          <source>Unlike the old Unix fmt(1) utility, this module correctly accounts for any Unicode combining characters (such as diacriticals) that may occur in each line for both expansion and unexpansion. These are overstrike characters that do not increment the logical position. Make sure you have the appropriate Unicode settings enabled.</source>
          <target state="translated">이전 Unix fmt (1) 유틸리티와 달리이 모듈은 확장 및 확장 해제를 위해 각 줄에서 발생할 수있는 모든 유니 코드 결합 문자 (예 : 분음 부호)를 올바르게 설명합니다. 논리적 위치를 증가시키지 않는 초과 스트라이크 문자입니다. 적절한 유니 코드 설정이 활성화되어 있는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="0625a7948b2143bf8fa5b94abdec3d975bedca11" translate="yes" xml:space="preserve">
          <source>Unlike the old unix utilities, this module correctly accounts for any Unicode combining characters (such as diacriticals) that may occur in each line for both expansion and unexpansion. These are overstrike characters that do not increment the logical position. Make sure you have the appropriate Unicode settings enabled.</source>
          <target state="translated">이전 유닉스 유틸리티와 달리이 모듈은 확장 및 확장 해제를 위해 각 줄에서 발생할 수있는 모든 유니 코드 결합 문자 (예 : 분음 부호)를 올바르게 설명합니다. 논리적 위치를 증가시키지 않는 초과 스트라이크 문자입니다. 적절한 유니 코드 설정이 활성화되어 있는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="bbee11f3129dceedbb755c4927925d533e72e81f" translate="yes" xml:space="preserve">
          <source>Unlike the original coding of this example, the returned values are not accessed in reverse order. So &lt;code&gt;ST(0)&lt;/code&gt; refers to the first value returned by the Perl subroutine and &lt;code&gt;ST(count-1)&lt;/code&gt; refers to the last.</source>
          <target state="translated">이 예제의 원래 코딩과 달리 반환 된 값은 역순으로 액세스되지 않습니다. 따라서 &lt;code&gt;ST(0)&lt;/code&gt; 은 Perl 서브 루틴이 리턴 한 첫 번째 값을 나타내고 &lt;code&gt;ST(count-1)&lt;/code&gt; 은 마지막 값을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="038e468b7871a7585436a41ba81caefab5eb3568" translate="yes" xml:space="preserve">
          <source>Unlike the stringification operator, there is never any need to append trailing zeros to preserve the correct version value.</source>
          <target state="translated">문자열 화 연산자와 달리 올바른 버전 값을 유지하기 위해 뒤에 0을 추가 할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="daa5c6301a77bc0d8757cfca2a7141b60979b735" translate="yes" xml:space="preserve">
          <source>Unlike with &lt;a href=&quot;#croak&quot;&gt;&quot;croak&quot;&lt;/a&gt;, &lt;code&gt;pat&lt;/code&gt; is not permitted to be null.</source>
          <target state="translated">와는 달리 &lt;a href=&quot;#croak&quot;&gt;&quot;까악 까악 우는 소리&quot;&lt;/a&gt; , &lt;code&gt;pat&lt;/code&gt; null이 될 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="54921bfadbbc4d5488355e38753c36b606db5127" translate="yes" xml:space="preserve">
          <source>Unlike with &lt;a href=&quot;#croak&quot;&gt;croak&lt;/a&gt;, &lt;code&gt;pat&lt;/code&gt; is not permitted to be null.</source>
          <target state="translated">와 달리 &lt;a href=&quot;#croak&quot;&gt;까악 까악 우는 소리&lt;/a&gt; , &lt;code&gt;pat&lt;/code&gt; null이 될 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="ae0137e5db1f710b710a9bc0edfaf77e15650ab6" translate="yes" xml:space="preserve">
          <source>Unlike with &lt;a href=&quot;#vcroak&quot;&gt;&quot;vcroak&quot;&lt;/a&gt;, &lt;code&gt;pat&lt;/code&gt; is not permitted to be null.</source>
          <target state="translated">와는 달리 &lt;a href=&quot;#vcroak&quot;&gt;&quot;vcroak&quot;&lt;/a&gt; , &lt;code&gt;pat&lt;/code&gt; null이 될 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="8a7070baa0bba9b5c3411b37157873dd12da55ea" translate="yes" xml:space="preserve">
          <source>Unlike with &lt;a href=&quot;#vcroak&quot;&gt;vcroak&lt;/a&gt;, &lt;code&gt;pat&lt;/code&gt; is not permitted to be null.</source>
          <target state="translated">와 달리 &lt;a href=&quot;#vcroak&quot;&gt;vcroak&lt;/a&gt; , &lt;code&gt;pat&lt;/code&gt; null이 될 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="28eadad196509c659a3994d74f2858a30a637ebf" translate="yes" xml:space="preserve">
          <source>Unlink a file, this wraps &lt;code&gt;unlink()&lt;/code&gt; in a way that makes it more reliable cross-platform when trying to unlink files you recently altered.</source>
          <target state="translated">파일의 링크 를 해제하면 최근에 변경 한 파일의 링크를 해제 할 때보다 안정적인 크로스 플랫폼을 만드는 방식으로 &lt;code&gt;unlink()&lt;/code&gt; 가 래핑 됩니다.</target>
        </trans-unit>
        <trans-unit id="e5cefcdd918640639ca1153770063f61e285104d" translate="yes" xml:space="preserve">
          <source>Unlink any temporary files you create.</source>
          <target state="translated">생성 한 임시 파일을 연결 해제하십시오.</target>
        </trans-unit>
        <trans-unit id="3e77881bda9dd47b3e5c55a65b50384eb4b9609f" translate="yes" xml:space="preserve">
          <source>Unloads a previously loaded dynamic-link library. The HANDLE is no longer valid after this call. See &lt;a&gt;LoadLibrary&lt;/a&gt; for information on dynamically loading a library.</source>
          <target state="translated">이전에로드 된 동적 연결 라이브러리를 언로드합니다. 이 호출 후에는 HANDLE이 더 이상 유효하지 않습니다. 라이브러리 동적로드에 대한 정보는 &lt;a&gt;LoadLibrary&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="7f2c338fa9bfcccaac25268ab0ef12e64490b19e" translate="yes" xml:space="preserve">
          <source>Unlock and close the database.</source>
          <target state="translated">데이터베이스를 잠금 해제하고 닫으십시오.</target>
        </trans-unit>
        <trans-unit id="425b4daaa8be44cc037fb6c4f8a9c4ee47b576db" translate="yes" xml:space="preserve">
          <source>Unmatched ( in regex; marked by &amp;lt;-- HERE in m/%s/</source>
          <target state="translated">일치하지 않음 (정규식에서, &amp;lt;-HERE (m / % s /)로 표시됨)</target>
        </trans-unit>
        <trans-unit id="a6fca5f2f3ab74092e2301bc93cfd673ca1d5fb7" translate="yes" xml:space="preserve">
          <source>Unmatched ) in regex; marked by &amp;lt;-- HERE in m/%s/</source>
          <target state="translated">일치하지 않음) 정규식에서; &amp;lt;-HERE (m / % s /)로 표시</target>
        </trans-unit>
        <trans-unit id="87bab1d81d4066140528cdd5b267a8458e21ea97" translate="yes" xml:space="preserve">
          <source>Unmatched [ in regex; marked by &amp;lt;-- HERE in m/%s/</source>
          <target state="translated">일치하지 않음 [in regex; &amp;lt;-HERE (m / % s /)로 표시</target>
        </trans-unit>
        <trans-unit id="5582b12b8fb1f3004178fe6e1d310ea58d890611" translate="yes" xml:space="preserve">
          <source>Unmatched right %s bracket</source>
          <target state="translated">일치하지 않는 오른쪽 % s 대괄호</target>
        </trans-unit>
        <trans-unit id="bc2c3a3141852414ad16ff6056e8a91c4d6648f7" translate="yes" xml:space="preserve">
          <source>Unpack the main archive to a temporary location (RAM: is fine).</source>
          <target state="translated">임시 위치에 기본 아카이브의 압축을 풉니 다 (RAM : 괜찮음).</target>
        </trans-unit>
        <trans-unit id="3a1b8bde43d6985240bfa75345e6d99d943394fd" translate="yes" xml:space="preserve">
          <source>Unpack the result with</source>
          <target state="translated">로 결과의 압축을 풉니 다</target>
        </trans-unit>
        <trans-unit id="add77c91d022a17024fa5eba373c6e719da883a1" translate="yes" xml:space="preserve">
          <source>Unpack the result with &lt;code&gt;tar -xof yourmodule.tar&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;tar -xof yourmodule.tar&lt;/code&gt; 로 결과의 압축을 풉니 다.</target>
        </trans-unit>
        <trans-unit id="ae62392d2b4bc10cbedb53bdaea138dd0c54922e" translate="yes" xml:space="preserve">
          <source>Unpack the source package</source>
          <target state="translated">소스 패키지의 압축을 풉니 다</target>
        </trans-unit>
        <trans-unit id="3ba56861ba0d7e4bf096f38cb19b9bd9d11ad9ab" translate="yes" xml:space="preserve">
          <source>Unpacking CPAN Modules on DOS</source>
          <target state="translated">DOS에서 CPAN 모듈 포장 풀기</target>
        </trans-unit>
        <trans-unit id="a3e58138dfa89b35eb5a0a67e0ceb78fe71fb3cd" translate="yes" xml:space="preserve">
          <source>Unpacking Perl Distribution on BS2000</source>
          <target state="translated">BS2000에서 펄 배포 풀기</target>
        </trans-unit>
        <trans-unit id="1906a11a734d044847362b51bdd5c4ffec722822" translate="yes" xml:space="preserve">
          <source>Unpacking Perl distribution on OS/390</source>
          <target state="translated">OS / 390에서 Perl 분배 풀기</target>
        </trans-unit>
        <trans-unit id="1bfe6e7e13df7f1f795bc2c142ba9f8933ba83d0" translate="yes" xml:space="preserve">
          <source>Unpacking a Stack Frame</source>
          <target state="translated">스택 프레임 포장 풀기</target>
        </trans-unit>
        <trans-unit id="13585670fad4d52485b4ecff204569086b8b8bc7" translate="yes" xml:space="preserve">
          <source>Unpacking this message can be done with the same template:</source>
          <target state="translated">이 메시지의 압축을 풀려면 동일한 템플릿으로 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="65ab97485c132c2a06d23b7d99106c078eeca52f" translate="yes" xml:space="preserve">
          <source>Unpacking using the &lt;code&gt;U&lt;/code&gt; template code also works on UTF-8 encoded byte strings.</source>
          <target state="translated">&lt;code&gt;U&lt;/code&gt; 템플릿 코드를 사용하여 압축을 풀면 UTF-8로 인코딩 된 바이트 문자열에서도 작동합니다.</target>
        </trans-unit>
        <trans-unit id="72bbb6196a2774c03510ad2f9119cf1acefc342b" translate="yes" xml:space="preserve">
          <source>Unqualified &lt;code&gt;dump()&lt;/code&gt;</source>
          <target state="translated">규정되지 않은 &lt;code&gt;dump()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5e326cb1d4e10ed2c54308ac7f68f78f28b408a5" translate="yes" xml:space="preserve">
          <source>Unqualified dump()</source>
          <target state="translated">규정되지 않은 dump ()</target>
        </trans-unit>
        <trans-unit id="b99dd6692af960885bd57e60a35c0eb60eb31d7b" translate="yes" xml:space="preserve">
          <source>Unquoted string &quot;%s&quot; may clash with future reserved word</source>
          <target state="translated">인용되지 않은 문자열 &quot;% s&quot;이 (가) 향후 예약어와 충돌 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="07b032b56f7aa399f0c5a6580292f3e83d7b1fad" translate="yes" xml:space="preserve">
          <source>Unread</source>
          <target state="translated">Unread</target>
        </trans-unit>
        <trans-unit id="630c8dcab3eab70bdc2071c988078d95676c03b2" translate="yes" xml:space="preserve">
          <source>Unrecognized character %s; marked by &amp;lt;-- HERE after %s near column %d</source>
          <target state="translated">인식 할 수없는 문자 % s; &amp;lt;-HERE (여기 % s 후 열 % d 근처)로 표시됨</target>
        </trans-unit>
        <trans-unit id="35c8af17f83153420d0d873b2861766a589d6251" translate="yes" xml:space="preserve">
          <source>Unrecognized escape \%c in character class in regex; marked by &amp;lt;-- HERE in m/%s/</source>
          <target state="translated">정규식의 문자 클래스에서 인식 할 수없는 이스케이프 \ % c; &amp;lt;-HERE (m / % s /)로 표시</target>
        </trans-unit>
        <trans-unit id="435719049eae3b64ca346100529a4145c47781d5" translate="yes" xml:space="preserve">
          <source>Unrecognized escape \%c in character class passed through in regex; marked by &amp;lt;-- HERE in m/%s/</source>
          <target state="translated">정규식에서 전달 된 문자 클래스의 인식 할 수없는 이스케이프 \ % c; &amp;lt;-HERE (m / % s /)로 표시</target>
        </trans-unit>
        <trans-unit id="43f0a236cfaeb24a6d268ae857e2d6c9ca2477d8" translate="yes" xml:space="preserve">
          <source>Unrecognized escape \%c passed through</source>
          <target state="translated">인식 할 수없는 이스케이프 \ % c 통과</target>
        </trans-unit>
        <trans-unit id="6680e7a052c1c186addf84b706b28b2f52bdc84d" translate="yes" xml:space="preserve">
          <source>Unrecognized escape \%s passed through in regex; marked by &amp;lt;-- HERE in m/%s/</source>
          <target state="translated">인식 할 수없는 이스케이프 \ % s가 정규식에서 전달되었습니다. &amp;lt;-HERE (m / % s /)로 표시</target>
        </trans-unit>
        <trans-unit id="14f5901f9cf23090de8d1e00ed8502304a6736d2" translate="yes" xml:space="preserve">
          <source>Unrecognized signal name &quot;%s&quot;</source>
          <target state="translated">인식 할 수없는 신호 이름 &quot;% s&quot;</target>
        </trans-unit>
        <trans-unit id="3d60ad24f51432cfcd0acc6a239e8d374b5bdb9a" translate="yes" xml:space="preserve">
          <source>Unrecognized signal name: ...</source>
          <target state="translated">인식 할 수없는 신호 이름 : ...</target>
        </trans-unit>
        <trans-unit id="e72ab0d0741f2af5e4f61b7913215c68a19c3881" translate="yes" xml:space="preserve">
          <source>Unrecognized switch: -%s (-h will show valid options)</source>
          <target state="translated">인식 할 수없는 스위치 :-% s (-h는 유효한 옵션을 표시 함)</target>
        </trans-unit>
        <trans-unit id="7a7351144db986600fc42c362487972431c1fb70" translate="yes" xml:space="preserve">
          <source>Unsafe signals</source>
          <target state="translated">안전하지 않은 신호</target>
        </trans-unit>
        <trans-unit id="f5c52c7fb5fb7350d05f5400b468c41971c6a2ea" translate="yes" xml:space="preserve">
          <source>Unsets the IV status of an SV.</source>
          <target state="translated">SV의 IV 상태를 설정 해제합니다.</target>
        </trans-unit>
        <trans-unit id="4b35d98112909417a16d4e204369414a7012a63c" translate="yes" xml:space="preserve">
          <source>Unsets the NV status of an SV.</source>
          <target state="translated">SV의 NV 상태를 설정 해제합니다.</target>
        </trans-unit>
        <trans-unit id="8c346401fde7bad98f35f3a033aefb050144d4e1" translate="yes" xml:space="preserve">
          <source>Unsets the NV/IV status of an SV.</source>
          <target state="translated">SV의 NV / IV 상태를 설정 해제합니다.</target>
        </trans-unit>
        <trans-unit id="b2fe5f61df3d20003f435b822e60a53db4a67fca" translate="yes" xml:space="preserve">
          <source>Unsets the PV status of an SV.</source>
          <target state="translated">SV의 PV 상태를 설정 해제합니다.</target>
        </trans-unit>
        <trans-unit id="2b428943db3814d458253435d21b77a7039ff870" translate="yes" xml:space="preserve">
          <source>Unsets the RV status of an SV.</source>
          <target state="translated">SV의 RV 상태를 설정 해제합니다.</target>
        </trans-unit>
        <trans-unit id="167340ebdf7672f2c96a0ab5594ee87b55416719" translate="yes" xml:space="preserve">
          <source>Unsets the RV status of the SV, and decrements the reference count of whatever was being referenced by the RV. This can almost be thought of as a reversal of &lt;code&gt;newSVrv&lt;/code&gt; . The &lt;code&gt;cflags&lt;/code&gt; argument can contain &lt;code&gt;SV_IMMEDIATE_UNREF&lt;/code&gt; to force the reference count to be decremented (otherwise the decrementing is conditional on the reference count being different from one or the reference being a readonly SV). See &lt;code&gt;SvROK_off&lt;/code&gt; .</source>
          <target state="translated">SV의 RV 상태를 설정 해제하고 RV가 참조하고있는 대상의 참조 횟수를 줄입니다. 이것은 거의 &lt;code&gt;newSVrv&lt;/code&gt; 의 반전으로 생각할 수 있습니다. &lt;code&gt;cflags&lt;/code&gt; 인자가 포함될 수 &lt;code&gt;SV_IMMEDIATE_UNREF&lt;/code&gt; 은 레퍼런스 카운트가 감소되도록 강제 (그렇지 않으면 감소하는 레퍼런스 카운트가 하나 또는 상이한 기준이 판독 전용 인 SV의 조건으로). &lt;code&gt;SvROK_off&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="2213e6f5fdeb83ff58d3c894e858b5a7ff9788f0" translate="yes" xml:space="preserve">
          <source>Unsets the RV status of the SV, and decrements the reference count of whatever was being referenced by the RV. This can almost be thought of as a reversal of &lt;code&gt;newSVrv&lt;/code&gt; . This is &lt;code&gt;sv_unref_flags&lt;/code&gt; with the &lt;code&gt;flag&lt;/code&gt; being zero. See &lt;code&gt;SvROK_off&lt;/code&gt; .</source>
          <target state="translated">SV의 RV 상태를 설정 해제하고 RV가 참조하고있는 대상의 참조 횟수를 줄입니다. 이것은 거의 &lt;code&gt;newSVrv&lt;/code&gt; 의 반전으로 생각할 수 있습니다. 이다 &lt;code&gt;sv_unref_flags&lt;/code&gt; 와 &lt;code&gt;flag&lt;/code&gt; 제로가되는. &lt;code&gt;SvROK_off&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b4cffc0b1a0c243323d58c0b5fa0e4671c5ada28" translate="yes" xml:space="preserve">
          <source>Unsets the RV status of the SV, and decrements the reference count of whatever was being referenced by the RV. This can almost be thought of as a reversal of &lt;code&gt;newSVrv&lt;/code&gt;. The &lt;code&gt;cflags&lt;/code&gt; argument can contain &lt;code&gt;SV_IMMEDIATE_UNREF&lt;/code&gt; to force the reference count to be decremented (otherwise the decrementing is conditional on the reference count being different from one or the reference being a readonly SV). See &lt;code&gt;&lt;a href=&quot;#SvROK_off&quot;&gt;&quot;SvROK_off&quot;&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">SV의 RV 상태를 설정 해제하고 RV가 참조하는 항목의 참조 횟수를 줄입니다. 이것은 거의 &lt;code&gt;newSVrv&lt;/code&gt; 의 반전으로 생각할 수 있습니다. &lt;code&gt;cflags&lt;/code&gt; 인자가 포함될 수 &lt;code&gt;SV_IMMEDIATE_UNREF&lt;/code&gt; 은 레퍼런스 카운트가 감소되도록 강제 (그렇지 않으면 감소하는 레퍼런스 카운트가 하나 또는 상이한 기준이 판독 전용 인 SV의 조건으로). &lt;code&gt;&lt;a href=&quot;#SvROK_off&quot;&gt;&quot;SvROK_off&quot;&lt;/a&gt;&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="1f24f3b0f1eacb57c8cbf5e1328666ef8fc81abb" translate="yes" xml:space="preserve">
          <source>Unsets the RV status of the SV, and decrements the reference count of whatever was being referenced by the RV. This can almost be thought of as a reversal of &lt;code&gt;newSVrv&lt;/code&gt;. This is &lt;code&gt;sv_unref_flags&lt;/code&gt; with the &lt;code&gt;flag&lt;/code&gt; being zero. See &lt;code&gt;&lt;a href=&quot;#SvROK_off&quot;&gt;&quot;SvROK_off&quot;&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">SV의 RV 상태를 설정 해제하고 RV가 참조하는 항목의 참조 횟수를 줄입니다. 이것은 거의 &lt;code&gt;newSVrv&lt;/code&gt; 의 반전으로 생각할 수 있습니다. 이것은 &lt;code&gt;flag&lt;/code&gt; 가 0 인 &lt;code&gt;sv_unref_flags&lt;/code&gt; 입니다 . &lt;code&gt;&lt;a href=&quot;#SvROK_off&quot;&gt;&quot;SvROK_off&quot;&lt;/a&gt;&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="fcfacd26d54ec31883bc064dd4f33047f4f7aa58" translate="yes" xml:space="preserve">
          <source>Unsets the UTF-8 status of an SV (the data is not changed, just the flag). Do not use frivolously.</source>
          <target state="translated">SV의 UTF-8 상태를 설정 해제합니다 (데이터는 변경되지 않고 플래그 만). 경박하게 사용하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="d458cc7af0595ce52fa475113c58f925209c55f3" translate="yes" xml:space="preserve">
          <source>Unsets the script encoding. The layers of &lt;code&gt;STDIN&lt;/code&gt; , &lt;code&gt;STDOUT&lt;/code&gt; are reset to &quot;&lt;code&gt;:raw&lt;/code&gt; &quot; (the default unprocessed raw stream of bytes).</source>
          <target state="translated">스크립트 인코딩을 설정 해제합니다. &lt;code&gt;STDIN&lt;/code&gt; , &lt;code&gt;STDOUT&lt;/code&gt; 계층은 &quot; &lt;code&gt;:raw&lt;/code&gt; &quot;(기본 처리되지 않은 원시 바이트 스트림) 로 재설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="8ffc0139d7a33cda1bb74b572fbce39422237d1e" translate="yes" xml:space="preserve">
          <source>Unsets the script encoding. The layers of &lt;code&gt;STDIN&lt;/code&gt;, &lt;code&gt;STDOUT&lt;/code&gt; are reset to &quot;&lt;code&gt;:raw&lt;/code&gt;&quot; (the default unprocessed raw stream of bytes).</source>
          <target state="translated">스크립트 인코딩을 설정 해제합니다. &lt;code&gt;STDIN&lt;/code&gt; , &lt;code&gt;STDOUT&lt;/code&gt; 레이어는 &quot; &lt;code&gt;:raw&lt;/code&gt; &quot;(기본 처리되지 않은 원시 바이트 스트림) 로 재설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="f3f886677b52de9f164b2193f280f9e0b4fa4087" translate="yes" xml:space="preserve">
          <source>Unshift the given number of &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; values onto the beginning of the array. The array will grow automatically to accommodate the addition. You must then use &lt;code&gt;av_store&lt;/code&gt; to assign values to these new elements.</source>
          <target state="translated">주어진 수의 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 값을 배열의 시작 부분으로 이동하십시오. 추가를 수용하기 위해 배열이 자동으로 커집니다. 그런 다음 &lt;code&gt;av_store&lt;/code&gt; 를 사용 하여 이러한 새 요소에 값을 지정 해야합니다 .</target>
        </trans-unit>
        <trans-unit id="75a9c3204a7376541e1fbe9d2c8b5f9cdca1e7c3" translate="yes" xml:space="preserve">
          <source>Unshift the given number of &lt;code&gt;undef&lt;/code&gt; values onto the beginning of the array. The array will grow automatically to accommodate the addition.</source>
          <target state="translated">주어진 수의 &lt;code&gt;undef&lt;/code&gt; 값을 배열의 시작 부분으로 이동합니다. 어레이는 추가를 수용하기 위해 자동으로 확장됩니다.</target>
        </trans-unit>
        <trans-unit id="56c8806e91e8b07e1c8c5b623b330c5fc17f1e53" translate="yes" xml:space="preserve">
          <source>Unshifts an SV onto the beginning of the array, creating the array if necessary. A small internal helper function to remove a commonly duplicated idiom.</source>
          <target state="translated">SV를 어레이의 시작 부분으로 이동시켜 필요한 경우 어레이를 만듭니다. 자주 복제되는 관용구를 제거하는 작은 내부 도우미 기능입니다.</target>
        </trans-unit>
        <trans-unit id="ee9dd9a34e19860a5fcf0a7ebd745fb02d06f995" translate="yes" xml:space="preserve">
          <source>Unsigned long integers. This is equivalent to T_UV but explicitly casts the return to type &lt;code&gt;unsigned long&lt;/code&gt; . The default typemap for &lt;code&gt;unsigned long&lt;/code&gt; is T_UV.</source>
          <target state="translated">부호없는 긴 정수 이것은 T_UV와 동일하지만 리턴 값을 &lt;code&gt;unsigned long&lt;/code&gt; 유형으로 명시 적으로 캐스트합니다 . &lt;code&gt;unsigned long&lt;/code&gt; 의 기본 유형 맵 은 T_UV입니다.</target>
        </trans-unit>
        <trans-unit id="ced873325d4a96e8ef45785591aba3dcab16744b" translate="yes" xml:space="preserve">
          <source>Unsigned long integers. This is equivalent to T_UV but explicitly casts the return to type &lt;code&gt;unsigned long&lt;/code&gt;. The default typemap for &lt;code&gt;unsigned long&lt;/code&gt; is T_UV.</source>
          <target state="translated">부호없는 긴 정수. 이것은 T_UV와 동일하지만 반환을 &lt;code&gt;unsigned long&lt;/code&gt; 유형으로 명시 적으로 캐스팅합니다 . &lt;code&gt;unsigned long&lt;/code&gt; 의 기본 typemap 은 T_UV입니다.</target>
        </trans-unit>
        <trans-unit id="ef145f774c9c40a970f92057ceb7090d079d49a8" translate="yes" xml:space="preserve">
          <source>Unsigned short integers. This is equivalent to T_UV but explicitly casts the return to type &lt;code&gt;unsigned short&lt;/code&gt; . The default typemap for &lt;code&gt;unsigned short&lt;/code&gt; is T_UV.</source>
          <target state="translated">부호없는 짧은 정수 이것은 T_UV와 동일하지만 리턴 값을 &lt;code&gt;unsigned short&lt;/code&gt; 유형으로 명시 적으로 캐스트합니다 . &lt;code&gt;unsigned short&lt;/code&gt; 의 기본 유형 맵 은 T_UV입니다.</target>
        </trans-unit>
        <trans-unit id="df6c108aea89772b8a63a9edc5f87c844d4af0f5" translate="yes" xml:space="preserve">
          <source>Unsigned short integers. This is equivalent to T_UV but explicitly casts the return to type &lt;code&gt;unsigned short&lt;/code&gt;. The default typemap for &lt;code&gt;unsigned short&lt;/code&gt; is T_UV.</source>
          <target state="translated">부호없는 짧은 정수. 이것은 T_UV와 동일하지만 반환을 &lt;code&gt;unsigned short&lt;/code&gt; 유형으로 명시 적으로 캐스팅합니다 . &lt;code&gt;unsigned short&lt;/code&gt; 의 기본 typemap 은 T_UV입니다.</target>
        </trans-unit>
        <trans-unit id="e913109aa138d1120ee92917139364ad0e62c982" translate="yes" xml:space="preserve">
          <source>Unstable CPAN modules</source>
          <target state="translated">불안정한 CPAN 모듈</target>
        </trans-unit>
        <trans-unit id="9831cf1a4b45f856ff1bfb0d3f2cad82357c9d2d" translate="yes" xml:space="preserve">
          <source>Unsuccessful %s on filename containing newline</source>
          <target state="translated">줄 바꿈이 포함 된 파일 이름에서 % s 실패</target>
        </trans-unit>
        <trans-unit id="ea66a9b99cf0a2a1cdbce38ec66bd1c5b4a6472f" translate="yes" xml:space="preserve">
          <source>Unsupported directory function &quot;%s&quot; called</source>
          <target state="translated">지원되지 않는 디렉토리 함수 &quot;% s&quot;이 (가) 호출되었습니다.</target>
        </trans-unit>
        <trans-unit id="24f166b32e4b60fa7b2dcb9461bba55e0fc0824b" translate="yes" xml:space="preserve">
          <source>Unsupported encodings</source>
          <target state="translated">지원되지 않는 인코딩</target>
        </trans-unit>
        <trans-unit id="5eef5d64732b0acc7a8ccefeec52120ece754125" translate="yes" xml:space="preserve">
          <source>Unsupported function %s</source>
          <target state="translated">지원되지 않는 기능 % s</target>
        </trans-unit>
        <trans-unit id="75d9503b567ed143ca61aa16b0f7d9ae956dd496" translate="yes" xml:space="preserve">
          <source>Unsupported function fork</source>
          <target state="translated">지원되지 않는 함수 포크</target>
        </trans-unit>
        <trans-unit id="d2c5497b1a7cb7063234cce74ee916eac2bf6146" translate="yes" xml:space="preserve">
          <source>Unsupported script encoding %s</source>
          <target state="translated">지원되지 않는 스크립트 인코딩 % s</target>
        </trans-unit>
        <trans-unit id="d7eb67c38ebe84ebbe543f338c00dda69167f50e" translate="yes" xml:space="preserve">
          <source>Unsupported socket function &quot;%s&quot; called</source>
          <target state="translated">지원되지 않는 소켓 함수 &quot;% s&quot;이 (가) 호출되었습니다.</target>
        </trans-unit>
        <trans-unit id="36af1ae54977c39ffd1ead9641e29d3a83f91f42" translate="yes" xml:space="preserve">
          <source>Untaint an SV. Use &lt;code&gt;SvTAINTED_off&lt;/code&gt; instead.</source>
          <target state="translated">SV를 유지하십시오. 대신 &lt;code&gt;SvTAINTED_off&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="bf2cbcc095493f902db2ae40c30ea409c9c066e5" translate="yes" xml:space="preserve">
          <source>Untaints an SV. Be</source>
          <target state="translated">SV를 유지합니다. 있다</target>
        </trans-unit>
        <trans-unit id="c7caa469295aafcb97e51d949546f29d23659089" translate="yes" xml:space="preserve">
          <source>Unterminated</source>
          <target state="translated">Unterminated</target>
        </trans-unit>
        <trans-unit id="61f3c80e76746c97d6708a314163f8c2fd9b4bef" translate="yes" xml:space="preserve">
          <source>Unterminated &amp;lt;&amp;gt; operator</source>
          <target state="translated">종결되지 않은 &amp;lt;&amp;gt; 연산자</target>
        </trans-unit>
        <trans-unit id="82e068ea0edf1c7b4de3ae2e55c67d1e8b974e77" translate="yes" xml:space="preserve">
          <source>Unterminated '(*...' argument in regex; marked by &amp;lt;-- HERE in m/%s/</source>
          <target state="translated">정규식에서 종결되지 않은 '(* ...'인수; m / % s /에서 &amp;lt;-HERE로 표시됨</target>
        </trans-unit>
        <trans-unit id="624e8334756d23d133eedf0a6bc6607c292afcbb" translate="yes" xml:space="preserve">
          <source>Unterminated '(*...' construct in regex; marked by &amp;lt;-- HERE in m/%s/</source>
          <target state="translated">정규식에서 종결되지 않은 '(* ...'구문, &amp;lt;-HERE (m / % s /)로 표시됨</target>
        </trans-unit>
        <trans-unit id="c59551fb5498e7f4ecec0f9a669fcc525e52d708" translate="yes" xml:space="preserve">
          <source>Unterminated \g... pattern in regex; marked by &amp;lt;-- HERE in m/%s/</source>
          <target state="translated">정규식에서 종결되지 않은 \ g ... 패턴; &amp;lt;-HERE (m / % s /)로 표시</target>
        </trans-unit>
        <trans-unit id="4eed8703593e02aeec17f79e274dece7c2582459" translate="yes" xml:space="preserve">
          <source>Unterminated \g{...} pattern in regex; marked by &amp;lt;-- HERE in m/%s/</source>
          <target state="translated">정규식에서 종결되지 않은 \ g {...} 패턴; &amp;lt;-HERE (m / % s /)로 표시</target>
        </trans-unit>
        <trans-unit id="be2cc0e43ab8f9502433f110394b1a21ca55af23" translate="yes" xml:space="preserve">
          <source>Unterminated attribute list</source>
          <target state="translated">종결되지 않은 속성 목록</target>
        </trans-unit>
        <trans-unit id="9b0888b49dc0060324f0f2e9fa27010b029af92a" translate="yes" xml:space="preserve">
          <source>Unterminated attribute parameter in attribute list</source>
          <target state="translated">속성 목록에서 종결되지 않은 속성 매개 변수</target>
        </trans-unit>
        <trans-unit id="5b13c5c91a9b07a5b57b3a0636a5913145b68098" translate="yes" xml:space="preserve">
          <source>Unterminated compressed integer</source>
          <target state="translated">종결되지 않은 압축 정수</target>
        </trans-unit>
        <trans-unit id="2743d41a5029219fd527d8b196fe97e1ab034e0d" translate="yes" xml:space="preserve">
          <source>Unterminated delimiter for here document</source>
          <target state="translated">여기 문서의 종결되지 않은 구분 기호</target>
        </trans-unit>
        <trans-unit id="0d319b07743736c50cebc71660dfd18cd71390d3" translate="yes" xml:space="preserve">
          <source>Unterminated verb pattern argument in regex; marked by &amp;lt;-- HERE in m/%s/</source>
          <target state="translated">정규식에서 종결되지 않은 동사 패턴 인수입니다. &amp;lt;-HERE (m / % s /)로 표시</target>
        </trans-unit>
        <trans-unit id="31df085fb521f1474fc83e47e984ad35a507e50f" translate="yes" xml:space="preserve">
          <source>Unterminated verb pattern in regex; marked by &amp;lt;-- HERE in m/%s/</source>
          <target state="translated">정규식의 종결되지 않은 동사 패턴입니다. &amp;lt;-HERE (m / % s /)로 표시</target>
        </trans-unit>
        <trans-unit id="dd1c8a6c3311799ae1ea8e9badc636ca33ce5f06" translate="yes" xml:space="preserve">
          <source>Until May 1997, this document was maintained by Jeff Okamoto &amp;lt;okamoto@corp.hp.com&amp;gt;. It is now maintained as part of Perl itself by the Perl 5 Porters &amp;lt;perl5-porters@perl.org&amp;gt;.</source>
          <target state="translated">1997 년 5 월까지이 문서는 Jeff Okamoto &amp;lt;okamoto@corp.hp.com&amp;gt;에서 관리했습니다. 이제 Perl 5 Porters &amp;lt;perl5-porters@perl.org&amp;gt;에 의해 Perl 자체의 일부로 유지 보수됩니다.</target>
        </trans-unit>
        <trans-unit id="1831403e65413acb20ccb5893a29f9432e4a4a0c" translate="yes" xml:space="preserve">
          <source>Until May 1997, this document was maintained by Jeff Okamoto &amp;lt;okamoto@corp.hp.com&amp;gt;. It is now maintained as part of Perl itself.</source>
          <target state="translated">1997 년 5 월까지이 문서는 Jeff Okamoto &amp;lt;okamoto@corp.hp.com&amp;gt;에서 관리했습니다. 이제 Perl 자체의 일부로 유지 보수됩니다.</target>
        </trans-unit>
        <trans-unit id="c233457d919be5e7a3077c4ecc8aac8f0f4cca07" translate="yes" xml:space="preserve">
          <source>Until Unicode 3.1, it was legal for programs to accept this malformation, but it was discovered that this created security issues.</source>
          <target state="translated">유니 코드 3.1까지는 프로그램이이 기형을 받아들이는 것이 합법적 이었으나 이로 인해 보안 문제가 발생한다는 사실이 발견되었습니다.</target>
        </trans-unit>
        <trans-unit id="9377bbae85c5f3f0ba947e70ca82611c37d8697f" translate="yes" xml:space="preserve">
          <source>Until Unicode 6.1, the 4 control characters U+0080, U+0081, U+0084, and U+0099 did not have names nor aliases. To preserve backwards compatibility, any alias you define for these code points will be returned by this function, in preference to the official name.</source>
          <target state="translated">유니 코드 6.1까지 4 개의 제어 문자 U + 0080, U + 0081, U + 0084 및 U + 0099에는 이름이나 별명이 없습니다. 이전 버전과의 호환성을 유지하기 위해이 코드 포인트에 대해 정의한 별칭은 공식 이름보다이 함수에 의해 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="1eb5a9bdac4b575070ceef54e56442cbab9b46a4" translate="yes" xml:space="preserve">
          <source>Until Unicode 7.0, the noncharacters were &quot;&lt;b&gt;forbidden&lt;/b&gt; for use in open interchange of Unicode text data&quot;, so that code that processed those streams could use these code points as sentinels that could be mixed in with character data, and would always be distinguishable from that data. (Emphasis above and in the next paragraph are added in this document.)</source>
          <target state="translated">유니 코드 7.0까지, 비문자는 &quot; 유니 코드 텍스트 데이터의 공개 교환에 사용이 &lt;b&gt;금지&lt;/b&gt; &quot;되었으므로 해당 스트림을 처리 한 코드는이 코드 포인트를 문자 데이터와 혼합 될 수있는 센티넬로 사용할 수 있으며 항상 그 코드와 구별됩니다. 데이터. (이 문서에는 위와 다음 단락의 내용이 추가되어 있습니다.)</target>
        </trans-unit>
        <trans-unit id="cf0c5cc9e7d8c8770f1e88663df8d645526d47b8" translate="yes" xml:space="preserve">
          <source>Until the lexical &lt;code&gt;$_&lt;/code&gt; feature was removed, this function would find the position of the lexical &lt;code&gt;$_&lt;/code&gt; in the pad of the currently-executing function and return the offset in the current pad, or &lt;code&gt;NOT_IN_PAD&lt;/code&gt;.</source>
          <target state="translated">어휘 &lt;code&gt;$_&lt;/code&gt; 기능이 제거 될 때까지이 함수는 현재 실행중인 함수의 패드에서 어휘 &lt;code&gt;$_&lt;/code&gt; 의 위치를 ​​찾고 현재 패드의 오프셋 또는 &lt;code&gt;NOT_IN_PAD&lt;/code&gt; 를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="d4ab20108515e8dd588162df69f6581bf8cbeba9" translate="yes" xml:space="preserve">
          <source>Until then, users are alerted &lt;b&gt;NOT&lt;/b&gt; to rely on the value of &lt;code&gt;$_&lt;/code&gt; remaining unmodified between the outside and the inside of the control block. In particular, the following example is &lt;b&gt;UNSAFE&lt;/b&gt;:</source>
          <target state="translated">그때까지 사용자는 제어 블록의 외부와 내부 사이에 수정되지 않은 상태로 남아있는 &lt;code&gt;$_&lt;/code&gt; 값에 의존 &lt;b&gt;하지&lt;/b&gt; 않도록 경고를받습니다 . 특히 다음 예는 &lt;b&gt;UNSAFE입니다&lt;/b&gt; .&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="39e4b4459c9bb0a70e21b5f9e46e887914c2d11b" translate="yes" xml:space="preserve">
          <source>Until version 1.72 of this module, the recommended technique for locking &lt;b&gt;DB_File&lt;/b&gt; databases was to flock the filehandle returned from the &quot;fd&quot; function. Unfortunately this technique has been shown to be fundamentally flawed (Kudos to David Harris for tracking this down). Use it at your own peril!</source>
          <target state="translated">이 모듈의 버전 1.72까지 &lt;b&gt;DB_File&lt;/b&gt; 데이터베이스 를 잠그는 데 권장되는 기술 은 &quot;fd&quot;함수에서 리턴 된 파일 핸들을 &lt;b&gt;모으는&lt;/b&gt; 것입니다. 불행히도이 기술은 근본적으로 결함이있는 것으로 나타났습니다 (이것을 추적 해 준 David Harris에게 구도). 자신의 위험에 따라 사용하십시오!</target>
        </trans-unit>
        <trans-unit id="086839a55d5b993fe1e0e2c06b1920a0c4bb718d" translate="yes" xml:space="preserve">
          <source>Until version 1.88 CPAN.pm never trusted the contents of the build_dir directory between sessions. Since 1.88_58 CPAN.pm has a YAML-based mechanism that makes it possible to share the contents of the build_dir/ directory between different sessions with the same version of perl. People who prefer to test things several days before installing will like this feature because it saves a lot of time.</source>
          <target state="translated">버전 1.88까지 CPAN.pm은 세션 간 build_dir 디렉토리의 내용을 신뢰하지 않았습니다. 1.88_58부터 CPAN.pm에는 YAML 기반 메커니즘이있어 동일한 버전의 perl을 사용하여 다른 세션간에 build_dir / 디렉토리의 내용을 공유 할 수 있습니다. 설치하기 며칠 전에 테스트하는 것을 선호하는 사람들은이 기능이 시간을 절약하기 때문에 좋아합니다.</target>
        </trans-unit>
        <trans-unit id="3e8ce03700f57426d42c01b15a7e4b29915f11c3" translate="yes" xml:space="preserve">
          <source>Unused. Left in for compatibility with Perl 5.10.0.</source>
          <target state="translated">미사용. Perl 5.10.0과의 호환성을 위해 남겨졌습니다.</target>
        </trans-unit>
        <trans-unit id="06342bce5c18e1ce2d5790dec4f3e08db46e5f75" translate="yes" xml:space="preserve">
          <source>Unusually, the overloaded implementation of the smart match operator does not get full control of the smart match behaviour. In particular, in the following code:</source>
          <target state="translated">일반적으로 오버로드 된 스마트 일치 연산자 구현은 스마트 일치 동작을 완전히 제어 할 수 없습니다. 특히 다음 코드에서</target>
        </trans-unit>
        <trans-unit id="29dacba7bdce44332111c01c6b875e4536599d85" translate="yes" xml:space="preserve">
          <source>Unweaken a reference: Clear the &lt;code&gt;SvWEAKREF&lt;/code&gt; flag on this RV; remove the backreference to this RV from the array of backreferences associated with the target SV, increment the refcount of the target. Silently ignores &lt;code&gt;undef&lt;/code&gt; and warns on non-weak references.</source>
          <target state="translated">참조 해제 : 이 RV 에서 &lt;code&gt;SvWEAKREF&lt;/code&gt; 플래그를 지 웁니다 . 대상 SV와 관련된 역 참조 배열에서이 RV에 대한 역 참조를 제거하고 대상의 참조 횟수를 증가시킵니다. &lt;code&gt;undef&lt;/code&gt; 를 자동으로 무시 하고 약하지 않은 참조에 대해 경고합니다.</target>
        </trans-unit>
        <trans-unit id="2e6b69fad267beac964f8da92bb1c2cb8cf51e03" translate="yes" xml:space="preserve">
          <source>Unzipping a complete zip file to disk</source>
          <target state="translated">완전한 zip 파일을 디스크에 압축 해제</target>
        </trans-unit>
        <trans-unit id="3706919ae59d2c2aad143453aa2569b724a8dcba" translate="yes" xml:space="preserve">
          <source>Up to 3.14_05, the switch &lt;b&gt;-v&lt;/b&gt; was used to produce verbose messages of &lt;b&gt;perldoc&lt;/b&gt; operation, which is now enabled by &lt;b&gt;-D&lt;/b&gt;.</source>
          <target state="translated">최대 3.14_05까지 &lt;b&gt;-v&lt;/b&gt; 스위치 는 &lt;b&gt;perldoc&lt;/b&gt; 작업 의 자세한 메시지를 생성하는 데 사용되었으며 이제 &lt;b&gt;-D에&lt;/b&gt; 의해 활성화됩니다 .</target>
        </trans-unit>
        <trans-unit id="ccaf842ca15dd152998644a5cc6be29af2ba5d3b" translate="yes" xml:space="preserve">
          <source>Up to Perl 5.5, opendir() could not autovivify a directory handle from &lt;code&gt;undef&lt;/code&gt;, so using a lexical handle required using a function from &lt;a href=&quot;symbol&quot;&gt;Symbol&lt;/a&gt; to create an anonymous glob, which took a separate step. &lt;code&gt;DirHandle&lt;/code&gt; encapsulates this, which allowed cleaner code than opendir(). Since Perl 5.6, opendir() alone has been all you need for lexical handles.</source>
          <target state="translated">Perl 5.5까지 opendir ()은 &lt;code&gt;undef&lt;/code&gt; 에서 디렉토리 핸들을 자동으로 활성화 할 수 없었으므로 &lt;a href=&quot;symbol&quot;&gt;Symbol&lt;/a&gt; 의 함수를 사용하여 어휘 핸들 을 사용하여 익명의 glob을 생성해야했으며 별도의 단계가 필요했습니다. &lt;code&gt;DirHandle&lt;/code&gt; 은 이것을 캡슐화하여 opendir ()보다 더 깨끗한 코드를 허용합니다. Perl 5.6 이후로 opendir ()만으로 어휘 핸들이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="b37c83dafbe144687e4e64f7705c9303ba945d98" translate="yes" xml:space="preserve">
          <source>Up until Perl 5.18, the actual rules of what a valid identifier was were a bit fuzzy. However, in general, anything defined here should work on previous versions of Perl, while the opposite -- edge cases that work in previous versions, but aren't defined here -- probably won't work on newer versions. As an important side note, please note that the following only applies to bareword identifiers as found in Perl source code, not identifiers introduced through symbolic references, which have much fewer restrictions. If working under the effect of the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8;&lt;/code&gt; pragma, the following rules apply:</source>
          <target state="translated">Perl 5.18까지 유효한 식별자가 무엇인지에 대한 실제 규칙은 약간 모호했습니다. 그러나 일반적으로 여기에 정의 된 항목은 이전 버전의 Perl에서 작동해야하지만 반대 버전 (이전 버전에서는 작동하지만 여기서 정의되지 않은 경우)은 최신 버전에서는 작동하지 않을 수 있습니다. 중요한 참고 사항으로, 다음은 Perl 소스 코드에서 볼 수있는 기호 식별자에만 적용되며, 기호 참조를 통해 도입 된 식별자는 제한이 훨씬 적습니다. &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8;&lt;/code&gt; &lt;a href=&quot;functions/use&quot;&gt;사용&lt;/a&gt; 의 영향으로 작업하는 경우 ; pragma에는 다음 규칙이 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="6fc88db01ba5e7a05c82ebb02e9f5bce416f55ca" translate="yes" xml:space="preserve">
          <source>Up until Perl 5.18, the actual rules of what a valid identifier was were a bit fuzzy. However, in general, anything defined here should work on previous versions of Perl, while the opposite -- edge cases that work in previous versions, but aren't defined here -- probably won't work on newer versions. As an important side note, please note that the following only applies to bareword identifiers as found in Perl source code, not identifiers introduced through symbolic references, which have much fewer restrictions. If working under the effect of the &lt;code&gt;use utf8;&lt;/code&gt; pragma, the following rules apply:</source>
          <target state="translated">Perl 5.18까지 유효한 식별자가 무엇인지에 대한 실제 규칙은 약간 모호했습니다. 그러나 일반적으로 여기에 정의 된 모든 것은 이전 버전의 Perl에서 작동해야하며 반대의 경우 이전 버전에서 작동하지만 여기에서 정의되지 않은 경우는 아마도 최신 버전에서는 작동하지 않을 것입니다. 중요한 부수적으로 다음은 Perl 소스 코드에서 발견되는 베어 워드 식별자에만 적용되며 훨씬 적은 제한이있는 기호 참조를 통해 도입 된 식별자에는 적용되지 않습니다. &lt;code&gt;use utf8;&lt;/code&gt; 의 영향으로 작업하는 경우 ; pragma, 다음 규칙이 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="700db59a01b3167d63908b9389905b718c997451" translate="yes" xml:space="preserve">
          <source>Update the pad compilation state variables on entry to a new block.</source>
          <target state="translated">새 블록에 입력 할 때 패드 컴파일 상태 변수를 업데이트하십시오.</target>
        </trans-unit>
        <trans-unit id="8d41ca4ae9515e795255242cbd01a15b9d2f782f" translate="yes" xml:space="preserve">
          <source>Update the running test count during testing.</source>
          <target state="translated">테스트하는 동안 실행중인 테스트 수를 업데이트하십시오.</target>
        </trans-unit>
        <trans-unit id="38f04a1ce254f18542607a5049eadaa5aadd3a16" translate="yes" xml:space="preserve">
          <source>Updated 03 October 2019 for perl-5.32.0+</source>
          <target state="translated">perl-5.32.0 +에 대해 2019 년 10 월 3 일 업데이트 됨</target>
        </trans-unit>
        <trans-unit id="ee4df1b22166fed22f195ec39ac5348e1ad4b8f4" translate="yes" xml:space="preserve">
          <source>Updated 12 March 2001 to mention //'SYS1.TCPPARMS(TCPDATA)'.</source>
          <target state="translated">//'SYS1.TCPPARMS(TCPDATA) '를 언급하여 2001 년 3 월 12 일에 업데이트되었습니다.</target>
        </trans-unit>
        <trans-unit id="6a623978ea73cf3eae49fa257cd2b3aa518dc7a5" translate="yes" xml:space="preserve">
          <source>Updated 12 November 2000 for the 5.7.1 release of Perl.</source>
          <target state="translated">Perl 5.7.1 릴리스 용으로 2000 년 11 월 12 일에 업데이트되었습니다.</target>
        </trans-unit>
        <trans-unit id="dd3c1a655a151c3e2de2f2bcc426466b5deb0bf5" translate="yes" xml:space="preserve">
          <source>Updated 15 January 2001 for the 5.7.1 release of Perl.</source>
          <target state="translated">Perl 5.7.1 릴리스 용으로 2001 년 1 월 15 일에 업데이트되었습니다.</target>
        </trans-unit>
        <trans-unit id="5b24aab6b7b4ffb7848dd5c01694221d0200543c" translate="yes" xml:space="preserve">
          <source>Updated 24 January 2001 to mention dynamic loading.</source>
          <target state="translated">동적 로딩을 언급하기 위해 2001 년 1 월 24 일에 업데이트되었습니다.</target>
        </trans-unit>
        <trans-unit id="555d5c68c249342b429101141b4e668ed9316de1" translate="yes" xml:space="preserve">
          <source>Updated 28 November 2001 for broken URLs.</source>
          <target state="translated">깨진 URL에 대해 2001 년 11 월 28 일에 업데이트되었습니다.</target>
        </trans-unit>
        <trans-unit id="e62d7626efdd54a1045fbdd7ab753ad6e883c01e" translate="yes" xml:space="preserve">
          <source>Updated by Kirrily &quot;Skud&quot; Robert, &lt;code&gt;skud@cpan.org&lt;/code&gt;</source>
          <target state="translated">Kirrily &quot;Skud&quot;Robert, &lt;code&gt;skud@cpan.org&lt;/code&gt; 업데이트</target>
        </trans-unit>
        <trans-unit id="8d4259d34b695e49901c9de958534f87265a7f80" translate="yes" xml:space="preserve">
          <source>Updated to be autogenerated from comments in the source by Benjamin Stuhl.</source>
          <target state="translated">Benjamin Stuhl에 의해 소스의 주석에서 자동 생성되도록 업데이트되었습니다.</target>
        </trans-unit>
        <trans-unit id="76fadb0208f83533ce563882faa439aa56b4df27" translate="yes" xml:space="preserve">
          <source>Updates for 5.8.0 by Nicholas Clark &amp;lt;nick@ccl4.org&amp;gt;</source>
          <target state="translated">Nicholas Clark &amp;lt;nick@ccl4.org&amp;gt;의 5.8.0 업데이트</target>
        </trans-unit>
        <trans-unit id="1339cf8af116acbabf9923f4b5f205bd8b4522d5" translate="yes" xml:space="preserve">
          <source>Updates the current digest state by appending bits to it. The return value is the updated object itself.</source>
          <target state="translated">비트를 추가하여 현재 다이제스트 상태를 업데이트합니다. 반환 값은 업데이트 된 객체 자체입니다.</target>
        </trans-unit>
        <trans-unit id="0f2ec1c28ed80b9544a67d730b3a5ce7a7abddfc" translate="yes" xml:space="preserve">
          <source>Updates to dual-life modules should consist of minimal patches to fix crashing bugs or security issues (as above). Any changes made to dual-life modules for which CPAN is canonical should be coordinated with the upstream author.</source>
          <target state="translated">이중 수명 모듈 업데이트는 크래시 버그 또는 보안 문제 (위와 같이)를 수정하기위한 최소 패치로 구성되어야합니다. CPAN이 정식 인 이중 수명 모듈에 대한 모든 변경 사항은 업스트림 작성자와 조정해야합니다.</target>
        </trans-unit>
        <trans-unit id="6308607dfbe53993e815ce31d09f4ea8e48145b7" translate="yes" xml:space="preserve">
          <source>Updating Apple's Perl</source>
          <target state="translated">Apple Perl 업데이트</target>
        </trans-unit>
        <trans-unit id="e1215f678a578a0f9348858eb8435faef2c2b2a9" translate="yes" xml:space="preserve">
          <source>Updating perldelta</source>
          <target state="translated">펄 델타 업데이트</target>
        </trans-unit>
        <trans-unit id="a93c4eda9c6091f3f69d33443d08d2297a61d678" translate="yes" xml:space="preserve">
          <source>Upgrade all installed modules. Blindly doing this can really break things, so keep a backup.</source>
          <target state="translated">설치된 모든 모듈을 업그레이드하십시오. 맹목적으로 이렇게하면 정말 일이 망가질 수 있으므로 백업을 유지하십시오.</target>
        </trans-unit>
        <trans-unit id="2c9b320c5f351db0fa6eccf0f443242caa105988" translate="yes" xml:space="preserve">
          <source>Upgrade an SV to a more complex form. Generally adds a new body type to the SV, then copies across as much information as possible from the old body. It croaks if the SV is already in a more complex form than requested. You generally want to use the &lt;code&gt;SvUPGRADE&lt;/code&gt; macro wrapper, which checks the type before calling &lt;code&gt;sv_upgrade&lt;/code&gt; , and hence does not croak. See also &lt;code&gt;svtype&lt;/code&gt; .</source>
          <target state="translated">SV를 좀 더 복잡한 형태로 업그레이드하십시오. 일반적으로 SV에 새 바디 유형을 추가 한 다음 이전 바디에서 최대한 많은 정보를 복사합니다. SV가 이미 요청한 것보다 더 복잡한 형태 인 경우 멈 춥니 다. 일반적으로 &lt;code&gt;SvUPGRADE&lt;/code&gt; 를 호출하기 전에 유형을 확인 하는 SvUPGRADE 매크로 랩퍼 를 사용하려고 하므로 &lt;code&gt;sv_upgrade&lt;/code&gt; 되지 않습니다. &lt;code&gt;svtype&lt;/code&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="1d51dcaafe87398cb11a10ca76493ca177deff1c" translate="yes" xml:space="preserve">
          <source>Upgrade an SV to a more complex form. Generally adds a new body type to the SV, then copies across as much information as possible from the old body. It croaks if the SV is already in a more complex form than requested. You generally want to use the &lt;code&gt;SvUPGRADE&lt;/code&gt; macro wrapper, which checks the type before calling &lt;code&gt;sv_upgrade&lt;/code&gt;, and hence does not croak. See also &lt;code&gt;&lt;a href=&quot;#svtype&quot;&gt;&quot;svtype&quot;&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">SV를 더 복잡한 형식으로 업그레이드합니다. 일반적으로 SV에 새 바디 유형을 추가 한 다음 이전 바디에서 가능한 한 많은 정보를 복사합니다. SV가 이미 요청한 것보다 더 복잡한 형태이면 삐걱 거립니다. 일반적으로 &lt;code&gt;SvUPGRADE&lt;/code&gt; 를 호출하기 전에 유형을 확인 하는 SvUPGRADE 매크로 래퍼 를 사용 하기를 &lt;code&gt;sv_upgrade&lt;/code&gt; 하므로 삐걱 거리지 않습니다. &lt;code&gt;&lt;a href=&quot;#svtype&quot;&gt;&quot;svtype&quot;&lt;/a&gt;&lt;/code&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="add6ead95077aa4159bcce425fd97688bfe672e4" translate="yes" xml:space="preserve">
          <source>Upgrade both sides to unicode-strings</source>
          <target state="translated">양쪽을 유니 코드 문자열로 업그레이드</target>
        </trans-unit>
        <trans-unit id="bf9f028e2ed4c8dda78241c1ef169c062efd613f" translate="yes" xml:space="preserve">
          <source>Upgrade existing plain connection to SSL. Any arguments necessary for SSL must be given in &lt;code&gt;new&lt;/code&gt; already.</source>
          <target state="translated">기존 일반 연결을 SSL로 업그레이드하십시오. SSL에 필요한 모든 인수는 이미 &lt;code&gt;new&lt;/code&gt; 로 제공되어야합니다 .</target>
        </trans-unit>
        <trans-unit id="2e297ad00204348f72b48d82b1764d98805e45e0" translate="yes" xml:space="preserve">
          <source>Upgrade existing plain connection to SSL. The SSL arguments have to be given in &lt;code&gt;new&lt;/code&gt; already because they are needed for data connections too.</source>
          <target state="translated">기존 일반 연결을 SSL로 업그레이드하십시오. SSL 인수는 데이터 연결에도 필요하므로 이미 &lt;code&gt;new&lt;/code&gt; 인수해야합니다 .</target>
        </trans-unit>
        <trans-unit id="6f973497f8e7a213aaea7ca02f49b6eca9fd3bfc" translate="yes" xml:space="preserve">
          <source>Upgrade existing plain connection to SSL. You can use SSL arguments as documented in &lt;a href=&quot;IO::Socket::SSL&quot;&gt;IO::Socket::SSL&lt;/a&gt;, but it will usually use the right arguments already.</source>
          <target state="translated">기존 일반 연결을 SSL로 업그레이드하십시오. &lt;a href=&quot;IO::Socket::SSL&quot;&gt;IO :: Socket :: SSL에&lt;/a&gt; 설명 된대로 SSL 인수를 사용할 수 있지만 일반적으로 이미 올바른 인수를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="1fee598dc67371af303baa6134f7476c80299023" translate="yes" xml:space="preserve">
          <source>Upgrade existing plain connection to SSL. You can use SSL arguments as documented in &lt;a href=&quot;http://search.cpan.org/perldoc/IO::Socket::SSL&quot;&gt;IO::Socket::SSL&lt;/a&gt;, but it will usually use the right arguments already.</source>
          <target state="translated">기존 일반 연결을 SSL로 업그레이드하십시오. &lt;a href=&quot;http://search.cpan.org/perldoc/IO::Socket::SSL&quot;&gt;IO :: Socket :: SSL에&lt;/a&gt; 설명 된대로 SSL 인수를 사용할 수 있지만 일반적으로 올바른 인수를 이미 사용합니다.</target>
        </trans-unit>
        <trans-unit id="bd48bfd47491f661502b2059f5ddd29245e2ae65" translate="yes" xml:space="preserve">
          <source>Upgrade the input stream to handle UTF8.</source>
          <target state="translated">UTF8을 처리하도록 입력 스트림을 업그레이드하십시오.</target>
        </trans-unit>
        <trans-unit id="512167fc556180d756801a5133a4af3eea376b8d" translate="yes" xml:space="preserve">
          <source>Upload the tarball</source>
          <target state="translated">tarball 업로드</target>
        </trans-unit>
        <trans-unit id="1cd0f1b9998e13b00b78484f1fadbc538035dbb0" translate="yes" xml:space="preserve">
          <source>Upon a successful match, if &lt;code&gt;pe1&lt;/code&gt; is non-&lt;code&gt;NULL&lt;/code&gt;, it will be set to point to the beginning of the</source>
          <target state="translated">성공적으로 일치하면 &lt;code&gt;pe1&lt;/code&gt; 이 &lt;code&gt;NULL&lt;/code&gt; 이 아닌 경우 해당 항목 의 시작 부분을 가리 키도록 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="abc1ecb08d6b6e94555b0616aae01977c29165a2" translate="yes" xml:space="preserve">
          <source>Upon a successful match, if &lt;code&gt;pe1&lt;/code&gt; is non-NULL, it will be set to point to the beginning of the</source>
          <target state="translated">성공적으로 일치하면 &lt;code&gt;pe1&lt;/code&gt; 이 NULL이 아닌 경우 시작 부분을 가리 키도록 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="d6227a3769b7b8bef00a65fa576f89761ee6446f" translate="yes" xml:space="preserve">
          <source>Upon failure, returns &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">실패하면 &lt;code&gt;0&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="dfebf0d8d353544ce7a20fd6b2aa49b84d774da5" translate="yes" xml:space="preserve">
          <source>Upon return from the code that needs to use the global locale, &lt;a href=&quot;perlapi#sync_locale&quot;&gt;&lt;code&gt;sync_locale()&lt;/code&gt;&lt;/a&gt; should be called to restore the safe multi-thread operation.</source>
          <target state="translated">전역 로케일을 사용해야하는 코드에서 리턴되면 안전한 다중 스레드 작업을 복원하기 위해 &lt;a href=&quot;perlapi#sync_locale&quot;&gt; &lt;code&gt;sync_locale()&lt;/code&gt; &lt;/a&gt; 을 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="e9bbd1f38e3f10a7609320917c264db329d774df" translate="yes" xml:space="preserve">
          <source>Upon success, returns an &lt;a href=&quot;ExtUtils::Typemaps&quot;&gt;ExtUtils::Typemaps&lt;/a&gt; object.</source>
          <target state="translated">성공하면 &lt;a href=&quot;ExtUtils::Typemaps&quot;&gt;ExtUtils :: Typemaps&lt;/a&gt; 객체를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="00d3d32521b4b97a3ea7146d67bef7d8345970f3" translate="yes" xml:space="preserve">
          <source>Upon success, returns the same string passed as argument.</source>
          <target state="translated">성공하면 인수로 전달 된 동일한 문자열을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="3a843d4dab6f725af56da9a31e9ee6fb792722a4" translate="yes" xml:space="preserve">
          <source>Upon successful return, the number of variants in the string can be computed by having saved the value of &lt;code&gt;*lenp&lt;/code&gt; before the call, and subtracting it from the after-call value of &lt;code&gt;*lenp&lt;/code&gt;.</source>
          <target state="translated">성공적으로 반환되면 문자열의 변형 수 는 호출 전에 &lt;code&gt;*lenp&lt;/code&gt; 값을 저장 하고 호출 후 값 &lt;code&gt;*lenp&lt;/code&gt; 에서 빼서 계산할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="169eb65969db88df1163a98feb823fd7dda92b8b" translate="yes" xml:space="preserve">
          <source>Upon successful return, the number of variants in the string can be computed by having saved the value of &lt;code&gt;*lenp&lt;/code&gt; before the call, and subtracting the after-call value of &lt;code&gt;*lenp&lt;/code&gt; from it.</source>
          <target state="translated">성공적으로 반환되면 문자열의 변형 수 는 호출 전에 &lt;code&gt;*lenp&lt;/code&gt; 값을 저장 하고 호출 후 &lt;code&gt;*lenp&lt;/code&gt; 값을 빼서 계산할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7931625de6bea30c3520a42f1b48c8c7ccb1cf73" translate="yes" xml:space="preserve">
          <source>Upon the call, the &lt;code&gt;mg_obj&lt;/code&gt; field will hold the hash key to be accessed. Upon return, the &lt;code&gt;SV*&lt;/code&gt; value in &lt;code&gt;mg_obj&lt;/code&gt; will be used in place of the original key in the hash access. The integer index value in the first parameter will be the &lt;code&gt;action&lt;/code&gt; value from &lt;code&gt;hv_fetch_common&lt;/code&gt; , or -1 if the call is from &lt;code&gt;hv_delete_common&lt;/code&gt; .</source>
          <target state="translated">호출시 &lt;code&gt;mg_obj&lt;/code&gt; 필드는 액세스 할 해시 키를 보유합니다. 돌아 왔을 때, &lt;code&gt;mg_obj&lt;/code&gt; 의 &lt;code&gt;SV*&lt;/code&gt; 값 은 해시 액세스의 원래 키 대신 사용됩니다. 첫 번째 매개 변수의 정수 색인 값 은 &lt;code&gt;hv_fetch_common&lt;/code&gt; 의 &lt;code&gt;action&lt;/code&gt; 값 이거나 호출이 &lt;code&gt;hv_delete_common&lt;/code&gt; 의 경우 -1 입니다.</target>
        </trans-unit>
        <trans-unit id="5908c7f7cc15c0eccf74a3929a4b447274d6a72c" translate="yes" xml:space="preserve">
          <source>Upon the call, the &lt;code&gt;mg_obj&lt;/code&gt; field will hold the hash key to be accessed. Upon return, the &lt;code&gt;SV*&lt;/code&gt; value in &lt;code&gt;mg_obj&lt;/code&gt; will be used in place of the original key in the hash access. The integer index value in the first parameter will be the &lt;code&gt;action&lt;/code&gt; value from &lt;code&gt;hv_fetch_common&lt;/code&gt;, or -1 if the call is from &lt;code&gt;hv_delete_common&lt;/code&gt;.</source>
          <target state="translated">호출시 &lt;code&gt;mg_obj&lt;/code&gt; 필드는 액세스 할 해시 키를 보유합니다. 반환시 &lt;code&gt;mg_obj&lt;/code&gt; 의 &lt;code&gt;SV*&lt;/code&gt; 값 이 해시 액세스의 원래 키 대신 사용됩니다. 상기 제 파라미터의 정수 인덱스 값이 될 것이다 &lt;code&gt;action&lt;/code&gt; 으로부터 값 &lt;code&gt;hv_fetch_common&lt;/code&gt; -1에서 호출 인 경우 &lt;code&gt;hv_delete_common&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fa70849156e04d235d49fdb3686f0245d179ad8d" translate="yes" xml:space="preserve">
          <source>Upon tying a new hash to this package, the developer must specify the size of the keys that will be used, the size of the value fields that the keys will index, and the size of the overall table (in terms of key-value pairs, not size in hard memory).</source>
          <target state="translated">이 패키지에 새 해시를 연결할 때 개발자는 사용할 키의 크기, 키가 색인 할 값 필드의 크기 및 전체 테이블의 크기 (키-값 쌍으로)를 지정해야합니다. 하드 메모리의 크기가 아님).</target>
        </trans-unit>
        <trans-unit id="187b6d106a78abc992df989626da341b4759f5bf" translate="yes" xml:space="preserve">
          <source>Upper/lower case differences in property names and values are irrelevant; thus &lt;code&gt;\p{Upper}&lt;/code&gt; means the same thing as &lt;code&gt;\p{upper}&lt;/code&gt; or even &lt;code&gt;\p{UpPeR}&lt;/code&gt; . Similarly, you can add or subtract underscores anywhere in the middle of a word, so that these are also equivalent to &lt;code&gt;\p{U_p_p_e_r}&lt;/code&gt; . And white space is irrelevant adjacent to non-word characters, such as the braces and the equals or colon separators, so &lt;code&gt;\p{ Upper }&lt;/code&gt; and &lt;code&gt;\p{ Upper_case : Y }&lt;/code&gt; are equivalent to these as well. In fact, white space and even hyphens can usually be added or deleted anywhere. So even &lt;code&gt;\p{ Up-per case = Yes}&lt;/code&gt; is equivalent. All this is called &quot;loose-matching&quot; by Unicode. The few places where stricter matching is used is in the middle of numbers, and in the Perl extension properties that begin or end with an underscore. Stricter matching cares about white space (except adjacent to non-word characters), hyphens, and non-interior underscores.</source>
          <target state="translated">속성 이름과 값의 대 / 소문자는 관련이 없습니다. 따라서 &lt;code&gt;\p{Upper}&lt;/code&gt; 는 &lt;code&gt;\p{upper}&lt;/code&gt; 또는 &lt;code&gt;\p{UpPeR}&lt;/code&gt; 과 동일한 것을 의미합니다 . 마찬가지로 단어 중간에 밑줄을 추가하거나 빼서 &lt;code&gt;\p{U_p_p_e_r}&lt;/code&gt; 와 동일합니다 . 그리고 공백은 중괄호, 등호 또는 콜론 구분 기호와 같이 단어가 아닌 문자에 인접하지 않으므로 &lt;code&gt;\p{ Upper }&lt;/code&gt; 및 &lt;code&gt;\p{ Upper_case : Y }&lt;/code&gt; 도 이것과 같습니다. 실제로 공백과 하이픈도 일반적으로 어디에서나 추가하거나 삭제할 수 있습니다. 따라서 &lt;code&gt;\p{ Up-per case = Yes}&lt;/code&gt; 동일합니다. 이 모든 것을 유니 코드에 의해 &quot;느슨한 매칭&quot;이라고합니다. 보다 엄격한 일치가 사용되는 소수의 위치는 숫자의 중간과 밑줄로 시작하거나 끝나는 Perl 확장 등록 정보에 있습니다. 보다 엄격하게 일치하면 공백 (단어가 아닌 문자에 인접한 경우 제외), 하이픈 및 비 내부 밑줄이 중요합니다.</target>
        </trans-unit>
        <trans-unit id="4660b05f7ff6fc21af46a89123d4d2cc76b34ecd" translate="yes" xml:space="preserve">
          <source>Upper/lower case differences in property names and values are irrelevant; thus &lt;code&gt;\p{Upper}&lt;/code&gt; means the same thing as &lt;code&gt;\p{upper}&lt;/code&gt; or even &lt;code&gt;\p{UpPeR}&lt;/code&gt;. Similarly, you can add or subtract underscores anywhere in the middle of a word, so that these are also equivalent to &lt;code&gt;\p{U_p_p_e_r}&lt;/code&gt;. And white space is generally irrelevant adjacent to non-word characters, such as the braces and the equals or colon separators, so &lt;code&gt;\p{ Upper }&lt;/code&gt; and &lt;code&gt;\p{ Upper_case : Y }&lt;/code&gt; are equivalent to these as well. In fact, white space and even hyphens can usually be added or deleted anywhere. So even &lt;code&gt;\p{ Up-per case = Yes}&lt;/code&gt; is equivalent. All this is called &quot;loose-matching&quot; by Unicode. The &quot;name&quot; property has some restrictions on this due to a few outlier names. Full details are given in &lt;a href=&quot;https://www.unicode.org/reports/tr44/tr44-24.html#UAX44-LM2&quot;&gt;https://www.unicode.org/reports/tr44/tr44-24.html#UAX44-LM2&lt;/a&gt;.</source>
          <target state="translated">속성 이름과 값의 대 / 소문자 차이는 관련이 없습니다. 따라서 &lt;code&gt;\p{Upper}&lt;/code&gt; 는 &lt;code&gt;\p{upper}&lt;/code&gt; 또는 &lt;code&gt;\p{UpPeR}&lt;/code&gt; 과 같은 의미 입니다. 마찬가지로 단어 중간에 밑줄을 더하거나 뺄 수 있으므로 &lt;code&gt;\p{U_p_p_e_r}&lt;/code&gt; 와 동일합니다 . 그리고 공백은 일반적으로 중괄호 및 같음 또는 콜론 구분 기호와 같이 단어가 아닌 문자에 인접하여 관련이 없으므로 &lt;code&gt;\p{ Upper }&lt;/code&gt; 및 &lt;code&gt;\p{ Upper_case : Y }&lt;/code&gt; 도 이와 동일합니다. 실제로 공백과 하이픈도 일반적으로 어디에서나 추가하거나 삭제할 수 있습니다. 따라서 &lt;code&gt;\p{ Up-per case = Yes}&lt;/code&gt; 동등합니다. 이 모든 것을 유니 코드에서는 &quot;느슨한 일치&quot;라고합니다. &quot;name&quot;속성에는 몇 가지 특이 치 이름으로 인해 이에 대한 몇 가지 제한 사항이 있습니다. 자세한 내용은 &lt;a href=&quot;https://www.unicode.org/reports/tr44/tr44-24.html#UAX44-LM2&quot;&gt;https://www.unicode.org/reports/tr44/tr44-24.html#UAX44-LM2&lt;/a&gt; 에 나와 있습니다 .</target>
        </trans-unit>
        <trans-unit id="46cec56f3412b99de640a0bca5cebcfbc4f533b0" translate="yes" xml:space="preserve">
          <source>Urgh. No wonder. There's a big difference between &quot;a null byte&quot;, character zero, and &quot;a space&quot;, character 32. Perl's put something between the date and the description - but unfortunately, we can't see it!</source>
          <target state="translated">어. 당연하지 &quot;null byte&quot;, 문자 zero 및 &quot;space&quot;, 문자 32 사이에는 큰 차이가 있습니다. Perl은 날짜와 설명 사이에 무언가를 넣었습니다. 그러나 불행히도 우리는 그것을 볼 수 없습니다!</target>
        </trans-unit>
        <trans-unit id="da969c82ff05cdc8d49e5dc3d47bc17f0b801a39" translate="yes" xml:space="preserve">
          <source>Urgh. Well, it's a bit better, but - well, would you want to maintain that?</source>
          <target state="translated">어. 글쎄, 그것은 조금 나아지지만-글쎄, 그것을 유지하고 싶습니까?</target>
        </trans-unit>
        <trans-unit id="0bb18642b70b9f8a9c12ccf39487328f306b8e19" translate="yes" xml:space="preserve">
          <source>Usage</source>
          <target state="translated">Usage</target>
        </trans-unit>
        <trans-unit id="82706ecdf8b404a3d7af76c38e97c34669646ccc" translate="yes" xml:space="preserve">
          <source>Usage Hints for Perl on OS/390</source>
          <target state="translated">OS / 390에서 Perl에 대한 사용법 힌트</target>
        </trans-unit>
        <trans-unit id="96115201cdc9d452c0fc7c1a0ccadddf5148529a" translate="yes" xml:space="preserve">
          <source>Usage Hints for Perl on Windows</source>
          <target state="translated">Windows에서 Perl에 대한 사용법 힌트</target>
        </trans-unit>
        <trans-unit id="73e902d9c6da4a824d1ebe10f64b85e576698ee7" translate="yes" xml:space="preserve">
          <source>Usage is</source>
          <target state="translated">사용법</target>
        </trans-unit>
        <trans-unit id="b4adcf0ec968acb4f04ec349a0b19258b19ca830" translate="yes" xml:space="preserve">
          <source>Usage messages issued as a result of bad command-line syntax should go to &lt;code&gt;STDERR&lt;/code&gt; . However, usage messages issued due to an explicit request to print usage (like specifying &lt;b&gt;-help&lt;/b&gt; on the command line) should go to &lt;code&gt;STDOUT&lt;/code&gt; , just in case the user wants to pipe the output to a pager (such as &lt;b&gt;more(1)&lt;/b&gt;).</source>
          <target state="translated">잘못된 명령 행 구문의 결과로 발행 된 사용 메시지는 &lt;code&gt;STDERR&lt;/code&gt; 로 이동해야합니다 . 그러나 명시적인 인쇄 사용 요청 (예 : 명령 행에 &lt;b&gt;-help&lt;/b&gt; 지정)으로 인해 사용 된 사용 메시지 는 사용자가 출력을 페이저 (예 : &lt;b&gt;more (1)&lt;/b&gt; ) 로 파이프하려는 경우 를 위해 &lt;code&gt;STDOUT&lt;/code&gt; 으로 이동해야합니다 .&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="41d5df819d19562e6554eaedc6a7c783f798be7b" translate="yes" xml:space="preserve">
          <source>Usage messages issued as a result of bad command-line syntax should go to &lt;code&gt;STDERR&lt;/code&gt;. However, usage messages issued due to an explicit request to print usage (like specifying &lt;b&gt;-help&lt;/b&gt; on the command line) should go to &lt;code&gt;STDOUT&lt;/code&gt;, just in case the user wants to pipe the output to a pager (such as &lt;b&gt;more(1)&lt;/b&gt;).</source>
          <target state="translated">잘못된 명령 행 구문의 결과로 발행 된 사용법 메시지는 &lt;code&gt;STDERR&lt;/code&gt; 로 이동해야합니다 . 그러나 사용자가 출력을 호출기로 파이프하려는 경우 (예 : &lt;b&gt;more (1)&lt;/b&gt; ) 사용법을 인쇄하기위한 명시 적 요청 (예 : 명령 줄에 &lt;b&gt;-help&lt;/b&gt; 지정)으로 인해 발행 된 사용법 메시지는 &lt;code&gt;STDOUT&lt;/code&gt; 로 이동해야합니다 .&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="261136bd75aafd5cdd3130fb700c6549b50d82b1" translate="yes" xml:space="preserve">
          <source>Usage might be something like:</source>
          <target state="translated">사용법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="861a0e430ffac5e4ae6e11b7a947f2c32d388cf4" translate="yes" xml:space="preserve">
          <source>Usage:</source>
          <target state="translated">Usage:</target>
        </trans-unit>
        <trans-unit id="7e4b7de93d932c1efcbac56adf57dfdace4c1516" translate="yes" xml:space="preserve">
          <source>Usage: POSIX::%s(%s)</source>
          <target state="translated">사용법 : POSIX :: % s (% s)</target>
        </trans-unit>
        <trans-unit id="125a9a7f74a7b0dd6f1033bba99a6fa5c5199974" translate="yes" xml:space="preserve">
          <source>Usage: Win32::%s(%s)</source>
          <target state="translated">사용법 : Win32 :: % s (% s)</target>
        </trans-unit>
        <trans-unit id="1d4d43cc6f3a833e0340a0d1794b6d7b9958657e" translate="yes" xml:space="preserve">
          <source>Use</source>
          <target state="translated">Use</target>
        </trans-unit>
        <trans-unit id="4f798ffcb78d5a7f233440bdd6c6128bfc8e6fe0" translate="yes" xml:space="preserve">
          <source>Use &quot;%s&quot; instead of &quot;%s&quot;</source>
          <target state="translated">&quot;% s&quot;대신 &quot;% s&quot;사용</target>
        </trans-unit>
        <trans-unit id="82df0013720cd7586b2bc95bd024b2fab925070f" translate="yes" xml:space="preserve">
          <source>Use &quot;opaque&quot; data type for the C types matched by the regular expression, even if these types are &lt;code&gt;typedef&lt;/code&gt; -equivalent to types from typemaps. Should not be used without &lt;b&gt;-x&lt;/b&gt;.</source>
          <target state="translated">정규식과 일치하는 C 유형에 대해 &quot;불투명&quot;데이터 유형을 사용하십시오. 이러한 유형이 &lt;code&gt;typedef&lt;/code&gt; 인 경우에도 유형 맵의 유형과 같습니다. &lt;b&gt;-x&lt;/b&gt; 없이 사용하면 안됩니다 .</target>
        </trans-unit>
        <trans-unit id="f821e8c5dcdcc4f25432b67bcb287f73b2058efb" translate="yes" xml:space="preserve">
          <source>Use &quot;opaque&quot; data type for the C types matched by the regular expression, even if these types are &lt;code&gt;typedef&lt;/code&gt;-equivalent to types from typemaps. Should not be used without &lt;b&gt;-x&lt;/b&gt;.</source>
          <target state="translated">정규 표현식과 일치하는 C 유형에 대해 &quot;불투명 한&quot;데이터 유형을 사용하십시오. 이러한 유형이 typemap의 유형과 동등한 &lt;code&gt;typedef&lt;/code&gt; 인 경우에도 마찬가지 입니다. &lt;b&gt;-x&lt;/b&gt; 없이는 사용할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="3c21be167d639b35ddaa57a08912b97d5e9dff41" translate="yes" xml:space="preserve">
          <source>Use &quot;tie&quot; to open the database.</source>
          <target state="translated">&quot;tie&quot;를 사용하여 데이터베이스를 엽니 다.</target>
        </trans-unit>
        <trans-unit id="446b95fda0c14dcd166b6b7bb8452cd305935a5c" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;#is_utf8_string_flags&quot;&gt;&quot;is_utf8_string_flags&quot;&lt;/a&gt;, &lt;a href=&quot;#is_utf8_string_loc_flags&quot;&gt;&quot;is_utf8_string_loc_flags&quot;&lt;/a&gt;, and &lt;a href=&quot;#is_utf8_string_loclen_flags&quot;&gt;&quot;is_utf8_string_loclen_flags&quot;&lt;/a&gt; to check entire strings.</source>
          <target state="translated">전체 문자열을 확인 하려면 &lt;a href=&quot;#is_utf8_string_flags&quot;&gt;&quot;is_utf8_string_flags&quot;&lt;/a&gt; , &lt;a href=&quot;#is_utf8_string_loc_flags&quot;&gt;&quot;is_utf8_string_loc_flags&quot;&lt;/a&gt; 및 &lt;a href=&quot;#is_utf8_string_loclen_flags&quot;&gt;&quot;is_utf8_string_loclen_flags&quot;&lt;/a&gt; 를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="083bcfc1424d9243fc6a63bfbd611d517b2983c2" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;HTML::Strip&quot;&gt;HTML::Strip&lt;/a&gt;, or &lt;a href=&quot;HTML::FormatText&quot;&gt;HTML::FormatText&lt;/a&gt; which not only removes HTML but also attempts to do a little simple formatting of the resulting plain text.</source>
          <target state="translated">&lt;a href=&quot;HTML::Strip&quot;&gt;HTML :: Strip&lt;/a&gt; 또는 &lt;a href=&quot;HTML::FormatText&quot;&gt;HTML :: FormatText&lt;/a&gt; 를 사용하여 HTML을 제거 할뿐만 아니라 결과 일반 텍스트의 간단한 형식을 지정하려고 시도합니다.</target>
        </trans-unit>
        <trans-unit id="138b7329a1d9ab9236d2f4b1f41480a59ad859da" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;Test2::Suite&quot;&gt;Test2::Suite&lt;/a&gt; if at all possible.</source>
          <target state="translated">가능하면 &lt;a href=&quot;Test2::Suite&quot;&gt;Test2 :: Suite를&lt;/a&gt; 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="2a1c34e684465d646570e575678d89d88fa6eded" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;Text::Wrap&quot;&gt;Text::Wrap&lt;/a&gt; (part of the standard Perl distribution):</source>
          <target state="translated">&lt;a href=&quot;Text::Wrap&quot;&gt;Text :: Wrap&lt;/a&gt; 사용 (표준 Perl 배포의 일부) :</target>
        </trans-unit>
        <trans-unit id="2859b671be05bd5de57f7f8967124d35c1657098" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;carp&quot;&gt;Carp&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;carp&quot;&gt;잉어&lt;/a&gt; 사용</target>
        </trans-unit>
        <trans-unit id="328b2dd567925d497d9e667189af9a036b40b4b4" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;exporter&quot;&gt;Exporter&lt;/a&gt; - wisely!</source>
          <target state="translated">&lt;a href=&quot;exporter&quot;&gt;Exporter를&lt;/a&gt; 현명하게 사용하십시오 !</target>
        </trans-unit>
        <trans-unit id="4c6d07e8046e85c144f5081da5bd8baf9030e3a5" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;http://search.cpan.org/perldoc/HTML::Strip&quot;&gt;HTML::Strip&lt;/a&gt;, or &lt;a href=&quot;http://search.cpan.org/perldoc/HTML::FormatText&quot;&gt;HTML::FormatText&lt;/a&gt; which not only removes HTML but also attempts to do a little simple formatting of the resulting plain text.</source>
          <target state="translated">사용 &lt;a href=&quot;http://search.cpan.org/perldoc/HTML::Strip&quot;&gt;HTML :: 스트립&lt;/a&gt; , 또는 &lt;a href=&quot;http://search.cpan.org/perldoc/HTML::FormatText&quot;&gt;HTML :: FormatText&lt;/a&gt; HTML뿐만 아니라 결과 일반 텍스트의 서식 약간의 간단한 작업을 수행하는 시도 제거뿐만 아니라있다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
