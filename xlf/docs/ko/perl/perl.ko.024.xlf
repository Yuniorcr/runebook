<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="perl">
    <body>
      <group id="perl">
        <trans-unit id="5b5f076887ce0597a3fa01a1ea06dacb7c8fe5ad" translate="yes" xml:space="preserve">
          <source>A string representing a selection list for sections to be printed when -verbose is set to 99, e.g. &lt;code&gt;&quot;NAME|SYNOPSIS|DESCRIPTION|VERSION&quot;&lt;/code&gt; .</source>
          <target state="translated">-verbose가 99로 설정된 경우 인쇄 될 섹션의 선택 목록을 나타내는 문자열입니다 (예 : &lt;code&gt;&quot;NAME|SYNOPSIS|DESCRIPTION|VERSION&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="308056f61edbce292af89589357f11ee44fd726d" translate="yes" xml:space="preserve">
          <source>A string specifying a pattern to be matched as a prefix (which is to be skipped). If omitted, optional whitespace is skipped.</source>
          <target state="translated">접두사로 일치시킬 패턴을 지정하는 문자열입니다 (건너 뛸 것임). 생략하면 선택적 공백은 건너 뜁니다.</target>
        </trans-unit>
        <trans-unit id="e9bc4f6bfc82a7d474c7f1ed6bc1a706c74a685f" translate="yes" xml:space="preserve">
          <source>A string specifying a pattern to be matched as the opening tag. If the pattern string is omitted (or &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;) then a pattern that matches any standard XML tag is used.</source>
          <target state="translated">여는 태그와 일치시킬 패턴을 지정하는 문자열입니다. 패턴 문자열이 생략 된 경우 (또는 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; ) 표준 XML 태그와 일치하는 패턴이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="dfa783b3ec2bd497248d1e337a89db649190c94f" translate="yes" xml:space="preserve">
          <source>A string specifying a pattern to be matched as the opening tag. If the pattern string is omitted (or &lt;code&gt;undef&lt;/code&gt;) then a pattern that matches any standard XML tag is used.</source>
          <target state="translated">여는 태그로 일치시킬 패턴을 지정하는 문자열입니다. 패턴 문자열이 생략되면 (또는 &lt;code&gt;undef&lt;/code&gt; ) 표준 XML 태그와 일치하는 패턴이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="048410179c1d880e31b42e6134fee925ec940ae9" translate="yes" xml:space="preserve">
          <source>A string specifying a pattern to be matched at the closing tag. If the pattern string is omitted (or &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;) then the closing tag is constructed by inserting a &lt;code&gt;/&lt;/code&gt; after any leading bracket characters in the actual opening tag that was matched (</source>
          <target state="translated">닫는 태그에서 일치시킬 패턴을 지정하는 문자열입니다. 패턴 문자열이 생략 된 경우 (또는 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; ) 닫는 태그는 일치하는 실제 여는 태그에서 선행 대괄호 문자 뒤에 &lt;code&gt;/&lt;/code&gt; 를 삽입하여 구성됩니다 (</target>
        </trans-unit>
        <trans-unit id="e5788a69c88b131396f814045cc6b53ce0cc3890" translate="yes" xml:space="preserve">
          <source>A string specifying a pattern to be matched at the closing tag. If the pattern string is omitted (or &lt;code&gt;undef&lt;/code&gt;) then the closing tag is constructed by inserting a &lt;code&gt;/&lt;/code&gt; after any leading bracket characters in the actual opening tag that was matched (</source>
          <target state="translated">닫는 태그에서 일치시킬 패턴을 지정하는 문자열입니다. 패턴 문자열이 생략 된 경우 (또는 &lt;code&gt;undef&lt;/code&gt; ) 일치 된 실제 여는 태그의 선행 대괄호 문자 뒤에 &lt;code&gt;/&lt;/code&gt; 를 삽입하여 닫는 태그가 구성됩니다 (</target>
        </trans-unit>
        <trans-unit id="4ddc15672e491fc997c3e75cb530fdf3735fbd3c" translate="yes" xml:space="preserve">
          <source>A string that can suppress Perl's warning about failed locale settings at startup. Failure can occur if the locale support in the operating system is lacking (broken) in some way--or if you mistyped the name of a locale when you set up your environment. If this environment variable is absent, or has a value other than &quot;0&quot; or &quot;&quot;, Perl will complain about locale setting failures.</source>
          <target state="translated">시작시 로케일 설정 실패에 대한 Perl의 경고를 억제 할 수있는 문자열. 운영 체제의 로케일 지원이 부족하거나 (깨진) 환경을 설정할 때 로케일 이름을 잘못 입력하면 실패가 발생할 수 있습니다. 이 환경 변수가 없거나 &quot;0&quot;또는 &quot;&quot;이외의 값을 가진 경우 Perl은 로케일 설정 실패에 대해 불평합니다.</target>
        </trans-unit>
        <trans-unit id="a2db67434e3c04d01083072b7b914ae53b6902d9" translate="yes" xml:space="preserve">
          <source>A string to be processed (&lt;code&gt;$_&lt;/code&gt; if the string is omitted or &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;)</source>
          <target state="translated">처리 할 문자열 (문자열을 생략하거나 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 인 경우 &lt;code&gt;$_&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="8e5b03d931e2204b8a3d04d2a7f5abbae4ae2b0b" translate="yes" xml:space="preserve">
          <source>A string to be processed (&lt;code&gt;$_&lt;/code&gt; if the string is omitted or &lt;code&gt;undef&lt;/code&gt;)</source>
          <target state="translated">처리 할 문자열 (문자열이 생략 된 경우 &lt;code&gt;$_&lt;/code&gt; 또는 &lt;code&gt;undef&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="6e51f4c9fde9edecc0936ad5478d06f35a15c4b1" translate="yes" xml:space="preserve">
          <source>A string which is (possibly) interpolated and then executed as a system command with</source>
          <target state="translated">보간 된 다음 가능한 시스템 명령으로 실행되는 문자열</target>
        </trans-unit>
        <trans-unit id="9e71c5ca1dc6ef7670b395665e5d81dc1d113fc0" translate="yes" xml:space="preserve">
          <source>A string which is (possibly) interpolated and then executed as a system command, via</source>
          <target state="translated">(가능하면) 보간 된 후 시스템 명령으로 실행되는 문자열</target>
        </trans-unit>
        <trans-unit id="b7d502174d30a5e3436227bfef788bb331c8da57" translate="yes" xml:space="preserve">
          <source>A string with escapes for double-quotes and backslashes.</source>
          <target state="translated">큰 따옴표와 백 슬래시를위한 이스케이프가있는 문자열.</target>
        </trans-unit>
        <trans-unit id="541174c6780e47b0b7c46aee134212a478513335" translate="yes" xml:space="preserve">
          <source>A string with no brackety calls, like this:</source>
          <target state="translated">다음과 같이 대괄호 호출이없는 문자열 :</target>
        </trans-unit>
        <trans-unit id="91e95b380bb6e68f8d92ebbea2146b404a9530ac" translate="yes" xml:space="preserve">
          <source>A string.</source>
          <target state="translated">문자열.</target>
        </trans-unit>
        <trans-unit id="f332e2ab827e7ad888e10e40f020c6f2638261a6" translate="yes" xml:space="preserve">
          <source>A subclass for in-memory extracted file from Archive::Tar</source>
          <target state="translated">Archive :: Tar에서 메모리 내 추출 파일의 서브 클래스</target>
        </trans-unit>
        <trans-unit id="abd458b754cc911d966797f7f9e904a5bf421ea9" translate="yes" xml:space="preserve">
          <source>A subclass of Pod::Simple::PullParser should define a &lt;code&gt;run&lt;/code&gt; method that calls &lt;code&gt;$token = $parser-&amp;gt;get_token&lt;/code&gt; to pull tokens.</source>
          <target state="translated">Pod :: Simple :: PullParser의 하위 클래스는 &lt;code&gt;$token = $parser-&amp;gt;get_token&lt;/code&gt; 을 호출 하여 토큰을 가져 오는 &lt;code&gt;run&lt;/code&gt; 메소드를 정의해야합니다 .</target>
        </trans-unit>
        <trans-unit id="6da5549484c85ec07cefefac0b04929e1e4b68b4" translate="yes" xml:space="preserve">
          <source>A subdirectory</source>
          <target state="translated">서브 디렉토리</target>
        </trans-unit>
        <trans-unit id="f3c131323abddd429496c2a4e94519d28ee7cce1" translate="yes" xml:space="preserve">
          <source>A subform of &quot;Eskimo&quot;.</source>
          <target state="translated">&quot;에스키모&quot;의 하위 형태.</target>
        </trans-unit>
        <trans-unit id="2185f5ee89fe302e7bad5c0ce031b9136fe1881e" translate="yes" xml:space="preserve">
          <source>A subpattern &lt;b&gt;assertion&lt;/b&gt; matching the &lt;b&gt;null string&lt;/b&gt; between &lt;b&gt;characters&lt;/b&gt;.</source>
          <target state="translated">&lt;b&gt;문자&lt;/b&gt; 사이 의 &lt;b&gt;null 문자열&lt;/b&gt; 과 일치 하는 하위 패턴 &lt;b&gt;어설 션&lt;/b&gt; 입니다.&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="dcb76fdf91425256508047ecf8357fd1c432b0b3" translate="yes" xml:space="preserve">
          <source>A subroutine declaration or definition may have a list of attributes associated with it. If such an attribute list is present, it is broken up at space or colon boundaries and treated as though a &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; attributes&lt;/code&gt; had been seen. See &lt;a href=&quot;attributes&quot;&gt;attributes&lt;/a&gt; for details about what attributes are currently supported. Unlike the limitation with the obsolescent &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; attrs&lt;/code&gt; , the &lt;code&gt;sub : ATTRLIST&lt;/code&gt; syntax works to associate the attributes with a pre-declaration, and not just with a subroutine definition.</source>
          <target state="translated">서브 루틴 선언 또는 정의에는 연관된 속성 목록이있을 수 있습니다. 이러한 속성 목록이 있으면 공간 또는 콜론 경계에서 분리되고 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; attributes&lt;/code&gt; 이 표시된 것처럼 처리됩니다 . 현재 지원되는 &lt;a href=&quot;attributes&quot;&gt;속성에&lt;/a&gt; 대한 자세한 내용은 속성 을 참조하십시오 . 퇴행성로 제한 달리 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; attrs&lt;/code&gt; 의 &lt;code&gt;sub : ATTRLIST&lt;/code&gt; 구문은 미리 선언 속성을 연결하고, 단지 서브 루틴의 정의를 위해 노력하고 있습니다.</target>
        </trans-unit>
        <trans-unit id="99cebddb12f55a27302430e67378ac046d2c1eea" translate="yes" xml:space="preserve">
          <source>A subroutine declaration or definition may have a list of attributes associated with it. If such an attribute list is present, it is broken up at space or colon boundaries and treated as though a &lt;code&gt;use attributes&lt;/code&gt; had been seen. See &lt;a href=&quot;attributes&quot;&gt;attributes&lt;/a&gt; for details about what attributes are currently supported. Unlike the limitation with the obsolescent &lt;code&gt;use attrs&lt;/code&gt;, the &lt;code&gt;sub : ATTRLIST&lt;/code&gt; syntax works to associate the attributes with a pre-declaration, and not just with a subroutine definition.</source>
          <target state="translated">서브 루틴 선언 또는 정의에는 연관된 속성 목록이있을 수 있습니다. 이러한 속성 목록이있는 경우 공백 또는 콜론 경계에서 분리되고 &lt;code&gt;use attributes&lt;/code&gt; 이 표시된 것처럼 처리됩니다 . 현재 지원되는 &lt;a href=&quot;attributes&quot;&gt;속성에&lt;/a&gt; 대한 자세한 내용은 속성 을 참조하세요 . 퇴행성로 제한 달리 &lt;code&gt;use attrs&lt;/code&gt; 의 &lt;code&gt;sub : ATTRLIST&lt;/code&gt; 구문은 미리 선언 속성을 연결하고, 단지 서브 루틴의 정의를 위해 노력하고 있습니다.</target>
        </trans-unit>
        <trans-unit id="d523fe66bca5199af0174d9a0e394a363dbbca6f" translate="yes" xml:space="preserve">
          <source>A subroutine may be called using an explicit &lt;code&gt;&amp;amp;&lt;/code&gt; prefix. The &lt;code&gt;&amp;amp;&lt;/code&gt; is optional in modern Perl, as are parentheses if the subroutine has been predeclared. The &lt;code&gt;&amp;amp;&lt;/code&gt; is</source>
          <target state="translated">서브 루틴은 명시 적 &lt;code&gt;&amp;amp;&lt;/code&gt; 접 두부를 사용하여 호출 할 수 있습니다 . &lt;code&gt;&amp;amp;&lt;/code&gt; 서브 루틴이 미리 선언 된 경우 현대 펄에서 선택 사항이 아니라 괄호입니다. &lt;code&gt;&amp;amp;&lt;/code&gt; IS</target>
        </trans-unit>
        <trans-unit id="8248b9acb1464596db08abf7a96c03fe64a833e0" translate="yes" xml:space="preserve">
          <source>A subroutine reference to be run at the end of the test script, if any of the tests fail. See &lt;a href=&quot;#ONFAIL&quot;&gt;&quot;ONFAIL&quot;&lt;/a&gt;.</source>
          <target state="translated">테스트가 실패한 경우 테스트 스크립트의 끝에서 실행할 서브 루틴 참조입니다. &lt;a href=&quot;#ONFAIL&quot;&gt;&quot;ONFAIL&quot;을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="472af3789d6b7cf851a695ddbea3171cb9f6d23e" translate="yes" xml:space="preserve">
          <source>A subroutine reference to be run at the end of the test script, if any of the tests fail. See &lt;a href=&quot;#ONFAIL&quot;&gt;ONFAIL&lt;/a&gt;.</source>
          <target state="translated">테스트 중 하나라도 실패하면 테스트 스크립트의 끝에서 실행될 서브 루틴 참조. &lt;a href=&quot;#ONFAIL&quot;&gt;ONFAIL을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="3a8138bb418c6dab14df47bdb5b98c794bb069d9" translate="yes" xml:space="preserve">
          <source>A subroutine stub (or forward declaration) looks like</source>
          <target state="translated">서브 루틴 스텁 (또는 순방향 선언)은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5c6644152e307dff88d95b419866126c49ada182" translate="yes" xml:space="preserve">
          <source>A substitution can do this for you. For a single line, you want to replace all the leading or trailing whitespace with nothing. You can do that with a pair of substitutions:</source>
          <target state="translated">대체가 당신을 위해 이것을 할 수 있습니다. 한 줄의 경우 모든 선행 또는 후행 공백을 아무 것도 바꾸고 싶습니다. 한 쌍의 치환으로 그렇게 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c348ffb20315d847f6359bc6cf9c39166e27bc60" translate="yes" xml:space="preserve">
          <source>A substring &lt;b&gt;captured&lt;/b&gt; by a subpattern within unadorned parentheses in a &lt;b&gt;regex&lt;/b&gt;. Backslashed decimal numbers (&lt;code&gt;\1&lt;/code&gt; , &lt;code&gt;\2&lt;/code&gt; , etc.) later in the same pattern refer back to the corresponding subpattern in the current match. Outside the pattern, the numbered variables (&lt;code&gt;$1&lt;/code&gt; , &lt;code&gt;$2&lt;/code&gt; , etc.) continue to refer to these same values, as long as the pattern was the last successful match of the current &lt;b&gt;dynamic scope&lt;/b&gt;.</source>
          <target state="translated">&lt;b&gt;정규 표현식&lt;/b&gt; 에서 괄호 안의 하위 패턴으로 &lt;b&gt;캡처&lt;/b&gt; 된 하위 문자열 입니다. 같은 패턴으로 된 백 슬래시 10 진수 ( &lt;code&gt;\1&lt;/code&gt; , &lt;code&gt;\2&lt;/code&gt; 등)는 현재 일치하는 해당 하위 패턴을 다시 참조합니다. 패턴 외부에서 패턴 이 현재 &lt;b&gt;동적 범위&lt;/b&gt; 와 마지막으로 일치 하는 한 번호가 매겨진 변수 ( &lt;code&gt;$1&lt;/code&gt; , &lt;code&gt;$2&lt;/code&gt; 등)는 계속 동일한 값을 참조합니다 .&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="daaa383ddb585e6ea73f1cbfe236bb8b4da61e98" translate="yes" xml:space="preserve">
          <source>A substring &lt;b&gt;captured&lt;/b&gt; by a subpattern within unadorned parentheses in a &lt;b&gt;regex&lt;/b&gt;. Backslashed decimal numbers (&lt;code&gt;\1&lt;/code&gt;, &lt;code&gt;\2&lt;/code&gt;, etc.) later in the same pattern refer back to the corresponding subpattern in the current match. Outside the pattern, the numbered variables (&lt;code&gt;$1&lt;/code&gt;, &lt;code&gt;$2&lt;/code&gt;, etc.) continue to refer to these same values, as long as the pattern was the last successful match of the current &lt;b&gt;dynamic scope&lt;/b&gt;.</source>
          <target state="translated">&lt;b&gt;regex&lt;/b&gt; 에서 장식되지 않은 괄호 안에있는 하위 패턴에 의해 &lt;b&gt;캡처&lt;/b&gt; 된 하위 문자열 입니다. 나중에 동일한 패턴에서 백 슬래시 로 표시된 십진수 ( &lt;code&gt;\1&lt;/code&gt; , &lt;code&gt;\2&lt;/code&gt; 등)는 현재 일치하는 하위 패턴을 다시 참조합니다. 패턴 외부에서 번호가 매겨진 변수 ( &lt;code&gt;$1&lt;/code&gt; , &lt;code&gt;$2&lt;/code&gt; 등)는 패턴이 현재 &lt;b&gt;동적 범위&lt;/b&gt; 와 마지막으로 성공적으로 일치하는 한 계속 이러한 동일한 값을 참조합니다 .&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="315d0303e3aef241562f12b55669ceb9dfe96eb1" translate="yes" xml:space="preserve">
          <source>A subtest may call &lt;code&gt;skip_all&lt;/code&gt; . No tests will be run, but the subtest is considered a skip.</source>
          <target state="translated">하위 테스트는 &lt;code&gt;skip_all&lt;/code&gt; 을 호출 할 수 있습니다 . 테스트는 실행되지 않지만 하위 테스트는 건너 뛰기로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="f748083200a82ad373df61839abe0f808219917c" translate="yes" xml:space="preserve">
          <source>A subtest may call &lt;code&gt;skip_all&lt;/code&gt;. No tests will be run, but the subtest is considered a skip.</source>
          <target state="translated">하위 테스트는 &lt;code&gt;skip_all&lt;/code&gt; 을 호출 할 수 있습니다 . 테스트는 실행되지 않지만 하위 테스트는 건너 뛰기로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="37458279bba72a238643fe5627f2676bd36cfdcd" translate="yes" xml:space="preserve">
          <source>A subtest of the</source>
          <target state="translated">의 하위 테스트</target>
        </trans-unit>
        <trans-unit id="ddbd7203825cf4784baaa474ee9dd57475c72727" translate="yes" xml:space="preserve">
          <source>A subtlety of the parsing process means that a regex like &lt;code&gt;/foo/&lt;/code&gt; is originally parsed into an alternation with a single branch. It is only afterwards that the optimiser converts single branch alternations into the simpler form.</source>
          <target state="translated">구문 분석 프로세스의 미묘한 의미는 &lt;code&gt;/foo/&lt;/code&gt; 와 같은 정규식 이 원래 단일 분기를 사용하여 대체로 구문 분석 되었음을 의미합니다 . 옵티마이 저가 단일 브랜치 교체를 더 간단한 형태로 변환 한 후에 만 ​​가능합니다.</target>
        </trans-unit>
        <trans-unit id="ca8ecc01810919d80818935b434bfbed09194445" translate="yes" xml:space="preserve">
          <source>A sufficiently complicated module using XS would have both Perl code (defined in</source>
          <target state="translated">XS를 사용하는 충분히 복잡한 모듈에는 Perl 코드가 모두 있습니다 (</target>
        </trans-unit>
        <trans-unit id="ec7ba027499434cb4ad8ba5cfec6aea4c41ca3a7" translate="yes" xml:space="preserve">
          <source>A superset of stdio's &lt;code&gt;ungetc()&lt;/code&gt; . Should arrange for future reads to see the bytes in &lt;code&gt;vbuf&lt;/code&gt; . If there is no obviously better implementation then &lt;code&gt;PerlIOBase_unread()&lt;/code&gt; provides the function by pushing a &quot;fake&quot; &quot;pending&quot; layer above the calling layer.</source>
          <target state="translated">stdio의 &lt;code&gt;ungetc()&lt;/code&gt; 의 수퍼 세트 . &lt;code&gt;vbuf&lt;/code&gt; 의 바이트를 볼 수 있도록 향후 읽기를 준비해야 합니다. 더 나은 구현이 없다면 &lt;code&gt;PerlIOBase_unread()&lt;/code&gt; 는 호출 계층 위로 &quot;가짜&quot; &quot;보류&quot;계층을 밀어서 함수를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="f4c52ed44dcfe3669b2e0f81a285d105620f4890" translate="yes" xml:space="preserve">
          <source>A superset of stdio's &lt;code&gt;ungetc()&lt;/code&gt;. Should arrange for future reads to see the bytes in &lt;code&gt;vbuf&lt;/code&gt;. If there is no obviously better implementation then &lt;code&gt;PerlIOBase_unread()&lt;/code&gt; provides the function by pushing a &quot;fake&quot; &quot;pending&quot; layer above the calling layer.</source>
          <target state="translated">stdio의 &lt;code&gt;ungetc()&lt;/code&gt; 수퍼 세트 . &lt;code&gt;vbuf&lt;/code&gt; 의 바이트를보기 위해 향후 읽기를 준비해야 합니다. 분명히 더 나은 구현이 없다면 &lt;code&gt;PerlIOBase_unread()&lt;/code&gt; 는 호출 계층 위에 &quot;가짜&quot; &quot;보류&quot;계층을 밀어서 함수를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="98f5e38ca1ab11480faa9e1beadc0882ff7204ae" translate="yes" xml:space="preserve">
          <source>A synonym for &lt;a href=&quot;#grok_numeric_radix&quot;&gt;&quot;grok_numeric_radix&quot;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;#grok_numeric_radix&quot;&gt;&quot;grok_numeric_radix&quot;&lt;/a&gt; 의 동의어</target>
        </trans-unit>
        <trans-unit id="c626abd78031b8aca6600ea0c2440d7fd00d78cd" translate="yes" xml:space="preserve">
          <source>A synonym for abs_path().</source>
          <target state="translated">abs_path ()의 동의어</target>
        </trans-unit>
        <trans-unit id="e1b37e0c283299b17772ecb39d63c354cb1c21a5" translate="yes" xml:space="preserve">
          <source>A synopsis of the common uses of the module</source>
          <target state="translated">모듈의 일반적인 사용에 대한 개요</target>
        </trans-unit>
        <trans-unit id="cbedc357c1a8c0f556eb0ada80454f902c9b0495" translate="yes" xml:space="preserve">
          <source>A syntactic construct consisting of a sequence of Perl &lt;b&gt;statements&lt;/b&gt; that is delimited by braces. The &lt;code&gt;if&lt;/code&gt; and &lt;code&gt;while&lt;/code&gt; statements are defined in terms of</source>
          <target state="translated">중괄호로 구분 된 일련의 Perl &lt;b&gt;문&lt;/b&gt; 으로 구성된 구문 구성 . &lt;code&gt;if&lt;/code&gt; 와 &lt;code&gt;while&lt;/code&gt; 문으로 정의된다</target>
        </trans-unit>
        <trans-unit id="ad7124750e36065dd8c98d176b7da5958dc7cdde" translate="yes" xml:space="preserve">
          <source>A syntactic construct representing a comma- separated list of expressions, evaluated to produce a &lt;b&gt;list value&lt;/b&gt;. Each &lt;b&gt;expression&lt;/b&gt; in a</source>
          <target state="translated">쉼표로 구분 된 표현식 목록을 나타내는 구문 구조로, &lt;b&gt;목록 값&lt;/b&gt; 을 생성하도록 평가됩니다 . 각각의 &lt;b&gt;표현&lt;/b&gt; A의</target>
        </trans-unit>
        <trans-unit id="7291be1f4b56b7d225866ff464ea491e8b919184" translate="yes" xml:space="preserve">
          <source>A system that algorithmically writes code for you in a high-level language. See also &lt;b&gt;code generator&lt;/b&gt;.</source>
          <target state="translated">알고리즘을 통해 고급 언어로 코드를 작성하는 시스템입니다. &lt;b&gt;코드 생성기&lt;/b&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="87ef544f16a30a02ca093ea233165dcf6ff6a52e" translate="yes" xml:space="preserve">
          <source>A system that writes code for you in a low-level language, such as code to implement the backend of a compiler. See &lt;b&gt;program generator&lt;/b&gt;.</source>
          <target state="translated">컴파일러의 백엔드를 구현하기위한 코드와 같은 저수준 언어로 코드를 작성하는 시스템입니다. &lt;b&gt;프로그램 생성기를&lt;/b&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="57d745713dbf91df8c6f9ba2a699dab6d83ae07a" translate="yes" xml:space="preserve">
          <source>A template may be specified either with a leading template or with a TEMPLATE argument.</source>
          <target state="translated">템플릿은 선행 템플릿 또는 TEMPLATE 인수로 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="becc5a1b25927d1909dc38d940b77e72a5cc23a0" translate="yes" xml:space="preserve">
          <source>A template used in &lt;b&gt;pattern matching&lt;/b&gt;.</source>
          <target state="translated">&lt;b&gt;패턴 매칭에&lt;/b&gt; 사용되는 템플릿 .</target>
        </trans-unit>
        <trans-unit id="460ed5b4079db2b66835c9fa0b74f3db75b6b725" translate="yes" xml:space="preserve">
          <source>A temporary failure occurred during name resolution. The operation may be successful if it is retried later.</source>
          <target state="translated">이름 확인 중 일시적인 오류가 발생했습니다. 나중에 다시 시도하면 작업이 성공할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="36377f90ac483d31142c52a673f24ea229719c46" translate="yes" xml:space="preserve">
          <source>A temporary holding location for data. Data that are &lt;b&gt;Block buffering&lt;/b&gt; means that the data is passed on to its destination whenever the buffer is full. &lt;b&gt;Line buffering&lt;/b&gt; means that it&amp;rsquo;s passed on whenever a complete line is received. &lt;b&gt;Command buffering&lt;/b&gt; means that it&amp;rsquo;s passed every time you do a &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; command (or equivalent). If your output is unbuffered, the system processes it one byte at a time without the use of a holding area. This can be rather inefficient.</source>
          <target state="translated">데이터의 임시 보관 장소. 데이터가되는 &lt;b&gt;블록 버퍼링&lt;/b&gt; , 버퍼가 가득 할 때마다 데이터가 목적지에 전달된다는 것을 의미한다. &lt;b&gt;라인 버퍼링&lt;/b&gt; 은 완전한 라인이 수신 될 때마다 전달됨을 의미합니다. &lt;b&gt;명령 버퍼링&lt;/b&gt; 은 &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; 명령 (또는 이와 동등한) 을 수행 할 때마다 전달됩니다 . 출력이 버퍼링되지 않은 경우 시스템은 유지 영역을 사용하지 않고 한 번에 1 바이트 씩 처리합니다. 다소 비효율적 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d02e4e224456aef53b6a5261e669756881433c31" translate="yes" xml:space="preserve">
          <source>A temporary holding location for data. Data that are &lt;b&gt;Block buffering&lt;/b&gt; means that the data is passed on to its destination whenever the buffer is full. &lt;b&gt;Line buffering&lt;/b&gt; means that it&amp;rsquo;s passed on whenever a complete line is received. &lt;b&gt;Command buffering&lt;/b&gt; means that it&amp;rsquo;s passed every time you do a &lt;code&gt;print&lt;/code&gt; command (or equivalent). If your output is unbuffered, the system processes it one byte at a time without the use of a holding area. This can be rather inefficient.</source>
          <target state="translated">데이터의 임시 보관 위치입니다. 데이터가되는 &lt;b&gt;블록 버퍼링&lt;/b&gt; , 버퍼가 가득 할 때마다 데이터가 목적지에 전달된다는 것을 의미한다. &lt;b&gt;라인 버퍼링&lt;/b&gt; 은 완전한 라인이 수신 될 때마다 전달된다는 것을 의미합니다. &lt;b&gt;명령 버퍼링&lt;/b&gt; 은 &lt;code&gt;print&lt;/code&gt; 명령 (또는 이와 동등한 명령) 을 수행 할 때마다 전달됨을 의미합니다 . 출력이 버퍼링되지 않은 경우 시스템은 보유 영역을 사용하지 않고 한 번에 한 바이트 씩 처리합니다. 이것은 다소 비효율적 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f18ef7078604acdbaf428768e9818f7cd824fdb3" translate="yes" xml:space="preserve">
          <source>A temporary value scheduled to die when the current statement finishes.</source>
          <target state="translated">현재 명령문이 완료 될 때 종료되도록 임시 값입니다.</target>
        </trans-unit>
        <trans-unit id="4fcd07f97a40c6345fdc7ef192c1a8b71aed7321" translate="yes" xml:space="preserve">
          <source>A test broke because it depended on Scalar::Util not being loaded. Test2 loads Scalar::Util. The test was updated to load Test2 after checking Scalar::Util's load status.</source>
          <target state="translated">Scalar :: Util이로드되지 않았기 때문에 테스트가 중단되었습니다. Test2는 Scalar :: Util을로드합니다. 테스트는 Scalar :: Util의로드 상태를 확인한 후 Test2를로드하도록 업데이트되었습니다.</target>
        </trans-unit>
        <trans-unit id="65b58ce0e330b75ba737dac3ce554a8e833edf70" translate="yes" xml:space="preserve">
          <source>A test script can then compare the input and output to make sure they are the expected values. When only an input or output function is provided the function will be named after the typemap entry and have either '_IN' or '_OUT' appended.</source>
          <target state="translated">그런 다음 테스트 스크립트는 입력과 출력을 비교하여 예상 값인지 확인할 수 있습니다. 입력 또는 출력 함수 만 제공되는 경우 함수는 typemap 항목에 따라 이름이 지정되고 '_IN'또는 '_OUT'이 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="ffdb74e7322377b29b9419a20386899c648854d4" translate="yes" xml:space="preserve">
          <source>A test worked around a now-fixed planning bug. There is no need to upgrade if you have an old version installed. New versions install fine if you want them.</source>
          <target state="translated">테스트는 현재 수정 된 계획 버그를 해결했습니다. 이전 버전이 설치되어 있으면 업그레이드 할 필요가 없습니다. 새 버전은 원하는 경우 잘 설치됩니다.</target>
        </trans-unit>
        <trans-unit id="be309ca808fdd70439ad47732767ff0fa5bc7488" translate="yes" xml:space="preserve">
          <source>A text &lt;b&gt;file&lt;/b&gt; that is a program intended to be &lt;b&gt;executed&lt;/b&gt; directly rather than &lt;b&gt;compiled&lt;/b&gt; to another form of file before &lt;b&gt;execution&lt;/b&gt;.</source>
          <target state="translated">텍스트 &lt;b&gt;파일&lt;/b&gt; 은 &lt;b&gt;실행&lt;/b&gt; 전에 다른 형식의 파일로 &lt;b&gt;컴파일&lt;/b&gt; 되지 않고 직접 &lt;b&gt;실행&lt;/b&gt; 되도록하는 프로그램입니다 .&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="69f7603a0e21614f40b6c5bdc945d53c623ea439" translate="yes" xml:space="preserve">
          <source>A third argument is also passed to the handler, which contains a copy of the raw binary contents of the &lt;code&gt;siginfo&lt;/code&gt; structure: if a system has some non-POSIX fields, this third argument is where to &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack()&lt;/a&gt;&lt;/code&gt; them from.</source>
          <target state="translated">&lt;code&gt;siginfo&lt;/code&gt; 구조 의 원시 바이너리 내용의 사본을 포함하는 세 번째 인수도 핸들러에 전달 됩니다. 시스템에 POSIX 이외의 필드가있는 경우이 세 번째 인수는 &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack()&lt;/a&gt;&lt;/code&gt; 위치 입니다.</target>
        </trans-unit>
        <trans-unit id="32c2d3b6b4b2f2038155a957dfc51bdf39a45fb2" translate="yes" xml:space="preserve">
          <source>A third argument is also passed to the handler, which contains a copy of the raw binary contents of the &lt;code&gt;siginfo&lt;/code&gt; structure: if a system has some non-POSIX fields, this third argument is where to &lt;code&gt;unpack()&lt;/code&gt; them from.</source>
          <target state="translated">세 번째 인수는 &lt;code&gt;siginfo&lt;/code&gt; 구조 의 원시 이진 내용의 복사본을 포함하는 핸들러에도 전달 됩니다. 시스템에 POSIX가 아닌 필드가있는 경우이 세 번째 인수는 해당 필드를 &lt;code&gt;unpack()&lt;/code&gt; 할 위치입니다.</target>
        </trans-unit>
        <trans-unit id="6401a363806a46dc3a276adc43e53feeed2b394c" translate="yes" xml:space="preserve">
          <source>A third style of bundling allows only values to be bundled with options. It can be enabled with:</source>
          <target state="translated">세 번째 스타일의 번들링은 옵션에만 값을 묶을 수 있습니다. 다음을 사용하여 활성화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7390c57e18948db2c7311e3d6392b36faa8ca560" translate="yes" xml:space="preserve">
          <source>A thorough reference to &lt;code&gt;open&lt;/code&gt; follows. For a gentler introduction to the basics of &lt;code&gt;open&lt;/code&gt;, see also the &lt;a href=&quot;perlopentut&quot;&gt;perlopentut&lt;/a&gt; manual page.</source>
          <target state="translated">&lt;code&gt;open&lt;/code&gt; 에 대한 철저한 참조는 다음과 같습니다. &lt;code&gt;open&lt;/code&gt; 의 기본에 대한보다 부드러운 소개 는 &lt;a href=&quot;perlopentut&quot;&gt;perlopentut&lt;/a&gt; 매뉴얼 페이지를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="ec67162265d799cee7ba073ea5ae61361a099a71" translate="yes" xml:space="preserve">
          <source>A thread is a flow of control through a program with a single execution point.</source>
          <target state="translated">스레드는 단일 실행 지점이있는 프로그램을 통한 제어 흐름입니다.</target>
        </trans-unit>
        <trans-unit id="e05fa4d94d725ab6d1467a08643ac53ed8a48ab5" translate="yes" xml:space="preserve">
          <source>A thread terminated in some manner other than just returning from its entry point function, or by using &lt;code&gt;threads-&amp;gt;exit()&lt;/code&gt; . For example, the thread may have terminated because of an error, or by using &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">스레드는 진입 점 함수에서 반환하거나 &lt;code&gt;threads-&amp;gt;exit()&lt;/code&gt; 사용하는 것 이외의 방식으로 종료되었습니다 . 예를 들어, 오류로 인해 또는 &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; 를 사용하여 스레드가 종료되었을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="51ac91275952e664bda6e199578add8b9d972807" translate="yes" xml:space="preserve">
          <source>A thread terminated in some manner other than just returning from its entry point function, or by using &lt;code&gt;threads-&amp;gt;exit()&lt;/code&gt;. For example, the thread may have terminated because of an error, or by using &lt;code&gt;die&lt;/code&gt;.</source>
          <target state="translated">진입 점 함수에서 반환하거나 &lt;code&gt;threads-&amp;gt;exit()&lt;/code&gt; 사용하는 것 이외의 방식으로 스레드가 종료되었습니다 . 예를 들어 스레드가 오류로 인해 종료되었거나 &lt;code&gt;die&lt;/code&gt; 를 사용하여 종료되었을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d5f8dc4f0e564ede193fccb0795b819fd8f8f455" translate="yes" xml:space="preserve">
          <source>A tied hash can have any semantics at all. It is typically tied to an on-disk database, so that cached values are stored in the database and retrieved from it again when needed, and the disk file typically persists after your program has exited. See &lt;code&gt;perltie&lt;/code&gt; for more complete details about &lt;code&gt;&lt;a href=&quot;functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">묶인 해시는 의미를 전혀 가질 수 없습니다. 캐시 된 값은 데이터베이스에 저장되어 필요할 때 다시 검색되고 디스크 파일은 일반적으로 프로그램이 종료 된 후에도 유지됩니다. 참조 &lt;code&gt;perltie&lt;/code&gt; 에 대한 자세한 전체 내용은 &lt;code&gt;&lt;a href=&quot;functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b8ea0564fcf5384920d8ee2daa66e116f59b8821" translate="yes" xml:space="preserve">
          <source>A tied hash can have any semantics at all. It is typically tied to an on-disk database, so that cached values are stored in the database and retrieved from it again when needed, and the disk file typically persists after your program has exited. See &lt;code&gt;perltie&lt;/code&gt; for more complete details about &lt;code&gt;tie&lt;/code&gt;.</source>
          <target state="translated">연결된 해시는 모든 의미를 가질 수 있습니다. 일반적으로 온 디스크 데이터베이스에 연결되어 캐시 된 값이 데이터베이스에 저장되고 필요할 때 다시 검색되며 디스크 파일은 일반적으로 프로그램이 종료 된 후에도 유지됩니다. &lt;code&gt;tie&lt;/code&gt; 대한 자세한 내용은 &lt;code&gt;perltie&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="88fb398954c23d545a218b6f24145de7bcc79c9d" translate="yes" xml:space="preserve">
          <source>A token in a programming language, such as a number or &lt;b&gt;string&lt;/b&gt;, that gives you an actual &lt;b&gt;value&lt;/b&gt; instead of merely representing possible values as a &lt;b&gt;variable&lt;/b&gt; does.</source>
          <target state="translated">&lt;b&gt;변수&lt;/b&gt; 처럼 가능한 값을 나타내는 대신 실제 &lt;b&gt;값&lt;/b&gt; 을 제공 하는 프로그래밍 언어 (예 : 숫자 또는 &lt;b&gt;문자열)&lt;/b&gt; 의 토큰입니다 .&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="49a82ac17323d56d44189291d63111e25b7240b2" translate="yes" xml:space="preserve">
          <source>A top-level function, &lt;code&gt;anyinflate&lt;/code&gt; , is provided to carry out &quot;one-shot&quot; uncompression between buffers and/or files. For finer control over the uncompression process, see the &lt;a href=&quot;#OO-Interface&quot;&gt;OO Interface&lt;/a&gt; section.</source>
          <target state="translated">버퍼와 파일 사이에 &quot;원샷 (one-shot)&quot;압축 해제를 수행하기 위해 최상위 기능인 &lt;code&gt;anyinflate&lt;/code&gt; 가 제공됩니다. 압축 해제 프로세스를보다 세밀하게 제어하려면 &lt;a href=&quot;#OO-Interface&quot;&gt;OO 인터페이스&lt;/a&gt; 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d29bd38bb8619e697991b75f7b05d15001a0b12c" translate="yes" xml:space="preserve">
          <source>A top-level function, &lt;code&gt;anyinflate&lt;/code&gt;, is provided to carry out &quot;one-shot&quot; uncompression between buffers and/or files. For finer control over the uncompression process, see the &lt;a href=&quot;#OO-Interface&quot;&gt;&quot;OO Interface&quot;&lt;/a&gt; section.</source>
          <target state="translated">버퍼 및 / 또는 파일 간의 &quot;원샷&quot;압축 해제를 수행하기 위해 최상위 기능인 &lt;code&gt;anyinflate&lt;/code&gt; 가 제공됩니다. 압축 해제 프로세스에 대한보다 세밀한 제어는 &lt;a href=&quot;#OO-Interface&quot;&gt;&quot;OO 인터페이스&quot;&lt;/a&gt; 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="87c7fedbb8115b85609fa9659aa296d9a84a6510" translate="yes" xml:space="preserve">
          <source>A top-level function, &lt;code&gt;anyuncompress&lt;/code&gt; , is provided to carry out &quot;one-shot&quot; uncompression between buffers and/or files. For finer control over the uncompression process, see the &lt;a href=&quot;#OO-Interface&quot;&gt;OO Interface&lt;/a&gt; section.</source>
          <target state="translated">버퍼와 파일 사이에서 &quot;원샷&quot;압축 해제를 수행하기 위해 최상위 기능인 &lt;code&gt;anyuncompress&lt;/code&gt; 가 제공됩니다. 압축 해제 프로세스를보다 세밀하게 제어하려면 &lt;a href=&quot;#OO-Interface&quot;&gt;OO 인터페이스&lt;/a&gt; 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="3e9ee68461a1d97ac1d9a01a7954547eccc561e8" translate="yes" xml:space="preserve">
          <source>A top-level function, &lt;code&gt;anyuncompress&lt;/code&gt;, is provided to carry out &quot;one-shot&quot; uncompression between buffers and/or files. For finer control over the uncompression process, see the &lt;a href=&quot;#OO-Interface&quot;&gt;&quot;OO Interface&quot;&lt;/a&gt; section.</source>
          <target state="translated">최상위 기능 &lt;code&gt;anyuncompress&lt;/code&gt; 는 버퍼 및 / 또는 파일 간의 &quot;원샷&quot;압축 해제를 수행하기 위해 제공됩니다. 압축 해제 프로세스에 대한보다 세밀한 제어는 &lt;a href=&quot;#OO-Interface&quot;&gt;&quot;OO 인터페이스&quot;&lt;/a&gt; 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e389addc6410d492c7bd5a5e3cf1e11884bdfd29" translate="yes" xml:space="preserve">
          <source>A top-level function, &lt;code&gt;bunzip2&lt;/code&gt; , is provided to carry out &quot;one-shot&quot; uncompression between buffers and/or files. For finer control over the uncompression process, see the &lt;a href=&quot;#OO-Interface&quot;&gt;OO Interface&lt;/a&gt; section.</source>
          <target state="translated">버퍼 및 / 또는 파일간에 &quot;원샷&quot;압축 해제를 수행하기 위해 최상위 기능 &lt;code&gt;bunzip2&lt;/code&gt; 가 제공됩니다. 압축 해제 프로세스를보다 세밀하게 제어하려면 &lt;a href=&quot;#OO-Interface&quot;&gt;OO 인터페이스&lt;/a&gt; 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="493740e1a612413aadafd7b1301bbf610832c573" translate="yes" xml:space="preserve">
          <source>A top-level function, &lt;code&gt;bunzip2&lt;/code&gt;, is provided to carry out &quot;one-shot&quot; uncompression between buffers and/or files. For finer control over the uncompression process, see the &lt;a href=&quot;#OO-Interface&quot;&gt;&quot;OO Interface&quot;&lt;/a&gt; section.</source>
          <target state="translated">버퍼 및 / 또는 파일 간의 &quot;원샷&quot;압축 해제를 수행하기 위해 최상위 기능인 &lt;code&gt;bunzip2&lt;/code&gt; 가 제공됩니다. 압축 해제 프로세스에 대한보다 세밀한 제어는 &lt;a href=&quot;#OO-Interface&quot;&gt;&quot;OO 인터페이스&quot;&lt;/a&gt; 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="fb0024f5a7eefa6e10161c1ed9db11d9ebbc931e" translate="yes" xml:space="preserve">
          <source>A top-level function, &lt;code&gt;bzip2&lt;/code&gt; , is provided to carry out &quot;one-shot&quot; compression between buffers and/or files. For finer control over the compression process, see the &lt;a href=&quot;#OO-Interface&quot;&gt;OO Interface&lt;/a&gt; section.</source>
          <target state="translated">버퍼 및 / 또는 파일간에 &quot;원샷&quot;압축을 수행하기 위해 최상위 기능인 &lt;code&gt;bzip2&lt;/code&gt; 가 제공됩니다. 압축 프로세스를보다 세밀하게 제어하려면 &lt;a href=&quot;#OO-Interface&quot;&gt;OO 인터페이스&lt;/a&gt; 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c37a0d1ee81cf00099658284d063416ebb99ad67" translate="yes" xml:space="preserve">
          <source>A top-level function, &lt;code&gt;bzip2&lt;/code&gt;, is provided to carry out &quot;one-shot&quot; compression between buffers and/or files. For finer control over the compression process, see the &lt;a href=&quot;#OO-Interface&quot;&gt;&quot;OO Interface&quot;&lt;/a&gt; section.</source>
          <target state="translated">버퍼 및 / 또는 파일간에 &quot;원샷&quot;압축을 수행하기 위해 최상위 기능인 &lt;code&gt;bzip2&lt;/code&gt; 가 제공됩니다. 압축 프로세스에 대한 자세한 제어는 &lt;a href=&quot;#OO-Interface&quot;&gt;&quot;OO 인터페이스&quot;&lt;/a&gt; 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="565743b74071fd71d3b79fbb653796a00d3b13c8" translate="yes" xml:space="preserve">
          <source>A top-level function, &lt;code&gt;deflate&lt;/code&gt; , is provided to carry out &quot;one-shot&quot; compression between buffers and/or files. For finer control over the compression process, see the &lt;a href=&quot;#OO-Interface&quot;&gt;OO Interface&lt;/a&gt; section.</source>
          <target state="translated">버퍼 및 / 또는 파일간에 &quot;원샷&quot;압축을 수행하기 위해 최상위 기능인 &lt;code&gt;deflate&lt;/code&gt; 이 제공됩니다. 압축 프로세스를보다 세밀하게 제어하려면 &lt;a href=&quot;#OO-Interface&quot;&gt;OO 인터페이스&lt;/a&gt; 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="bff82540911c024ca186615e4403dd05a0cf4f35" translate="yes" xml:space="preserve">
          <source>A top-level function, &lt;code&gt;deflate&lt;/code&gt;, is provided to carry out &quot;one-shot&quot; compression between buffers and/or files. For finer control over the compression process, see the &lt;a href=&quot;#OO-Interface&quot;&gt;&quot;OO Interface&quot;&lt;/a&gt; section.</source>
          <target state="translated">버퍼 및 / 또는 파일간에 &quot;원샷&quot;압축을 수행하기 위해 최상위 기능인 &lt;code&gt;deflate&lt;/code&gt; 가 제공됩니다. 압축 프로세스에 대한 자세한 제어는 &lt;a href=&quot;#OO-Interface&quot;&gt;&quot;OO 인터페이스&quot;&lt;/a&gt; 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="9810b58473f41aaf89cef15b62322dda3e22aea6" translate="yes" xml:space="preserve">
          <source>A top-level function, &lt;code&gt;gunzip&lt;/code&gt; , is provided to carry out &quot;one-shot&quot; uncompression between buffers and/or files. For finer control over the uncompression process, see the &lt;a href=&quot;#OO-Interface&quot;&gt;OO Interface&lt;/a&gt; section.</source>
          <target state="translated">버퍼 및 / 또는 파일간에 &quot;원샷&quot;압축 해제를 수행하기 위해 최상위 기능인 &lt;code&gt;gunzip&lt;/code&gt; 이 제공됩니다. 압축 해제 프로세스를보다 세밀하게 제어하려면 &lt;a href=&quot;#OO-Interface&quot;&gt;OO 인터페이스&lt;/a&gt; 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="7badb6377fd4b8b2d62f64ab74c751ff2fd93c67" translate="yes" xml:space="preserve">
          <source>A top-level function, &lt;code&gt;gunzip&lt;/code&gt;, is provided to carry out &quot;one-shot&quot; uncompression between buffers and/or files. For finer control over the uncompression process, see the &lt;a href=&quot;#OO-Interface&quot;&gt;&quot;OO Interface&quot;&lt;/a&gt; section.</source>
          <target state="translated">버퍼 및 / 또는 파일 간의 &quot;원샷&quot;압축 해제를 수행하기 위해 최상위 기능인 &lt;code&gt;gunzip&lt;/code&gt; 이 제공됩니다. 압축 해제 프로세스에 대한보다 세밀한 제어는 &lt;a href=&quot;#OO-Interface&quot;&gt;&quot;OO 인터페이스&quot;&lt;/a&gt; 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e6e391619962954b4fb420d746dbc210bda397a8" translate="yes" xml:space="preserve">
          <source>A top-level function, &lt;code&gt;gzip&lt;/code&gt; , is provided to carry out &quot;one-shot&quot; compression between buffers and/or files. For finer control over the compression process, see the &lt;a href=&quot;#OO-Interface&quot;&gt;OO Interface&lt;/a&gt; section.</source>
          <target state="translated">버퍼 및 / 또는 파일간에 &quot;원샷&quot;압축을 수행하기 위해 최상위 기능인 &lt;code&gt;gzip&lt;/code&gt; 이 제공됩니다. 압축 프로세스를보다 세밀하게 제어하려면 &lt;a href=&quot;#OO-Interface&quot;&gt;OO 인터페이스&lt;/a&gt; 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="6030f52309ef00261ec0f923b10f4c609bd43290" translate="yes" xml:space="preserve">
          <source>A top-level function, &lt;code&gt;gzip&lt;/code&gt;, is provided to carry out &quot;one-shot&quot; compression between buffers and/or files. For finer control over the compression process, see the &lt;a href=&quot;#OO-Interface&quot;&gt;&quot;OO Interface&quot;&lt;/a&gt; section.</source>
          <target state="translated">버퍼 및 / 또는 파일간에 &quot;원샷&quot;압축을 수행하기 위해 최상위 함수 인 &lt;code&gt;gzip&lt;/code&gt; 이 제공됩니다. 압축 프로세스에 대한 자세한 제어는 &lt;a href=&quot;#OO-Interface&quot;&gt;&quot;OO 인터페이스&quot;&lt;/a&gt; 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="cb09dcc8a8a7122c93016ac58ef7ca78f87815eb" translate="yes" xml:space="preserve">
          <source>A top-level function, &lt;code&gt;inflate&lt;/code&gt; , is provided to carry out &quot;one-shot&quot; uncompression between buffers and/or files. For finer control over the uncompression process, see the &lt;a href=&quot;#OO-Interface&quot;&gt;OO Interface&lt;/a&gt; section.</source>
          <target state="translated">버퍼 및 / 또는 파일간에 &quot;원샷&quot;압축 해제를 수행하기 위해 &lt;code&gt;inflate&lt;/code&gt; 최상위 기능 이 제공됩니다. 압축 해제 프로세스를보다 세밀하게 제어하려면 &lt;a href=&quot;#OO-Interface&quot;&gt;OO 인터페이스&lt;/a&gt; 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="593396a26d871d3ccd3e4c4d01083746e0688751" translate="yes" xml:space="preserve">
          <source>A top-level function, &lt;code&gt;inflate&lt;/code&gt;, is provided to carry out &quot;one-shot&quot; uncompression between buffers and/or files. For finer control over the uncompression process, see the &lt;a href=&quot;#OO-Interface&quot;&gt;&quot;OO Interface&quot;&lt;/a&gt; section.</source>
          <target state="translated">버퍼 및 / 또는 파일 간의 &quot;원샷&quot;압축 해제를 수행하기 위해 최상위 기능인 &lt;code&gt;inflate&lt;/code&gt; 가 제공됩니다. 압축 해제 프로세스에 대한보다 세밀한 제어는 &lt;a href=&quot;#OO-Interface&quot;&gt;&quot;OO 인터페이스&quot;&lt;/a&gt; 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e6ff8dd50fc057dd45574766e64ed1ef729e4475" translate="yes" xml:space="preserve">
          <source>A top-level function, &lt;code&gt;rawdeflate&lt;/code&gt; , is provided to carry out &quot;one-shot&quot; compression between buffers and/or files. For finer control over the compression process, see the &lt;a href=&quot;#OO-Interface&quot;&gt;OO Interface&lt;/a&gt; section.</source>
          <target state="translated">버퍼 및 / 또는 파일간에 &quot;원샷&quot;압축을 수행하기 위해 최상위 기능인 &lt;code&gt;rawdeflate&lt;/code&gt; 가 제공됩니다. 압축 프로세스를보다 세밀하게 제어하려면 &lt;a href=&quot;#OO-Interface&quot;&gt;OO 인터페이스&lt;/a&gt; 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e07f7aa9b2e11715d969e7d7de3a8f095d0510a4" translate="yes" xml:space="preserve">
          <source>A top-level function, &lt;code&gt;rawdeflate&lt;/code&gt;, is provided to carry out &quot;one-shot&quot; compression between buffers and/or files. For finer control over the compression process, see the &lt;a href=&quot;#OO-Interface&quot;&gt;&quot;OO Interface&quot;&lt;/a&gt; section.</source>
          <target state="translated">버퍼 및 / 또는 파일간에 &quot;원샷&quot;압축을 수행하기 위해 최상위 기능인 &lt;code&gt;rawdeflate&lt;/code&gt; 가 제공됩니다. 압축 프로세스에 대한 자세한 제어는 &lt;a href=&quot;#OO-Interface&quot;&gt;&quot;OO 인터페이스&quot;&lt;/a&gt; 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="da007ab4cef02cbdbebe645067fd56f8debb93a1" translate="yes" xml:space="preserve">
          <source>A top-level function, &lt;code&gt;rawinflate&lt;/code&gt; , is provided to carry out &quot;one-shot&quot; uncompression between buffers and/or files. For finer control over the uncompression process, see the &lt;a href=&quot;#OO-Interface&quot;&gt;OO Interface&lt;/a&gt; section.</source>
          <target state="translated">버퍼와 파일 사이에 &quot;원샷 (one-shot)&quot;압축 해제를 수행하기 위해 최상위 기능인 &lt;code&gt;rawinflate&lt;/code&gt; 가 제공됩니다. 압축 해제 프로세스를보다 세밀하게 제어하려면 &lt;a href=&quot;#OO-Interface&quot;&gt;OO 인터페이스&lt;/a&gt; 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="181a224cf55cf1a34703cf3c62787fd4f2cb1b27" translate="yes" xml:space="preserve">
          <source>A top-level function, &lt;code&gt;rawinflate&lt;/code&gt;, is provided to carry out &quot;one-shot&quot; uncompression between buffers and/or files. For finer control over the uncompression process, see the &lt;a href=&quot;#OO-Interface&quot;&gt;&quot;OO Interface&quot;&lt;/a&gt; section.</source>
          <target state="translated">버퍼 및 / 또는 파일 간의 &quot;원샷&quot;압축 해제를 수행하기 위해 최상위 기능인 &lt;code&gt;rawinflate&lt;/code&gt; 가 제공됩니다. 압축 해제 프로세스에 대한보다 세밀한 제어는 &lt;a href=&quot;#OO-Interface&quot;&gt;&quot;OO 인터페이스&quot;&lt;/a&gt; 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="522a8c4c8a64b09e73f7b19d33d186f1963c38ba" translate="yes" xml:space="preserve">
          <source>A top-level function, &lt;code&gt;unzip&lt;/code&gt; , is provided to carry out &quot;one-shot&quot; uncompression between buffers and/or files. For finer control over the uncompression process, see the &lt;a href=&quot;#OO-Interface&quot;&gt;OO Interface&lt;/a&gt; section.</source>
          <target state="translated">버퍼 및 / 또는 파일간에 &quot;원샷&quot;압축 해제를 수행하기 위해 최상위 기능인 &lt;code&gt;unzip&lt;/code&gt; 이 제공됩니다. 압축 해제 프로세스를보다 세밀하게 제어하려면 &lt;a href=&quot;#OO-Interface&quot;&gt;OO 인터페이스&lt;/a&gt; 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b46148d3eace9f217f2c5cb71de1e5b53c2eb0a6" translate="yes" xml:space="preserve">
          <source>A top-level function, &lt;code&gt;unzip&lt;/code&gt;, is provided to carry out &quot;one-shot&quot; uncompression between buffers and/or files. For finer control over the uncompression process, see the &lt;a href=&quot;#OO-Interface&quot;&gt;&quot;OO Interface&quot;&lt;/a&gt; section.</source>
          <target state="translated">버퍼 및 / 또는 파일 간의 &quot;원샷&quot;압축 해제를 수행하기 위해 최상위 기능인 &lt;code&gt;unzip&lt;/code&gt; 이 제공됩니다. 압축 해제 프로세스에 대한보다 세밀한 제어는 &lt;a href=&quot;#OO-Interface&quot;&gt;&quot;OO 인터페이스&quot;&lt;/a&gt; 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="cf0562aa58382ee4296c753a78a1efd86d792dc1" translate="yes" xml:space="preserve">
          <source>A top-level function, &lt;code&gt;zip&lt;/code&gt; , is provided to carry out &quot;one-shot&quot; compression between buffers and/or files. For finer control over the compression process, see the &lt;a href=&quot;#OO-Interface&quot;&gt;OO Interface&lt;/a&gt; section.</source>
          <target state="translated">버퍼 및 / 또는 파일간에 &quot;원샷&quot;압축을 수행하기 위해 최상위 기능인 &lt;code&gt;zip&lt;/code&gt; 이 제공됩니다. 압축 프로세스를보다 세밀하게 제어하려면 &lt;a href=&quot;#OO-Interface&quot;&gt;OO 인터페이스&lt;/a&gt; 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="7d1de9f7e19cbe1751454358d979d818197cd4c0" translate="yes" xml:space="preserve">
          <source>A top-level function, &lt;code&gt;zip&lt;/code&gt;, is provided to carry out &quot;one-shot&quot; compression between buffers and/or files. For finer control over the compression process, see the &lt;a href=&quot;#OO-Interface&quot;&gt;&quot;OO Interface&quot;&lt;/a&gt; section.</source>
          <target state="translated">버퍼 및 / 또는 파일간에 &quot;원샷&quot;압축을 수행하기 위해 최상위 기능인 &lt;code&gt;zip&lt;/code&gt; 이 제공됩니다. 압축 프로세스에 대한 자세한 제어는 &lt;a href=&quot;#OO-Interface&quot;&gt;&quot;OO 인터페이스&quot;&lt;/a&gt; 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="8b8620967b93bad58d8aa8f79801bf38881ee8c9" translate="yes" xml:space="preserve">
          <source>A totally different approach is to create a hash of function references.</source>
          <target state="translated">완전히 다른 접근법은 함수 참조의 해시를 만드는 것입니다.</target>
        </trans-unit>
        <trans-unit id="980ba3b61619e7f53950a6b31a7df9b45b72edfd" translate="yes" xml:space="preserve">
          <source>A trailing colon is added automatically to the resulting path, to denote a directory.</source>
          <target state="translated">디렉토리를 표시하기 위해 후미 콜론이 결과 경로에 자동으로 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="7b8da94bbc0623b636921b1bb640e93b774abc6e" translate="yes" xml:space="preserve">
          <source>A translation-concealed rooted logical name that contains Perl and the logical device for the @INC path on VMS only. Other logical names that affect Perl on VMS include PERLSHR, PERL_ENV_TABLES, and SYS$TIMEZONE_DIFFERENTIAL, but are optional and discussed further in &lt;a href=&quot;perlvms&quot;&gt;perlvms&lt;/a&gt; and in</source>
          <target state="translated">VMS의 @INC 경로에 대한 논리 장치 및 Perl을 포함하는 변환으로 숨겨진 루트 논리 이름입니다. VMS에서 Perl에 영향을주는 다른 논리 이름에는 PERLSHR, PERL_ENV_TABLES 및 SYS $ TIMEZONE_DIFFERENTIAL이 있지만 선택적이며 &lt;a href=&quot;perlvms&quot;&gt;perlvms&lt;/a&gt; 및</target>
        </trans-unit>
        <trans-unit id="2dde805e9629b528928f950f1faf5f6602f0b7c5" translate="yes" xml:space="preserve">
          <source>A trivial application of this mechanism is to implement options that are related to each other. For example:</source>
          <target state="translated">이 메커니즘의 간단한 적용은 서로 관련된 옵션을 구현하는 것입니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a063d28faa82402e5b2d3d1ed31d0f1ad9c9dea3" translate="yes" xml:space="preserve">
          <source>A tutorial about writing really basic tests</source>
          <target state="translated">정말 기본적인 테스트 작성에 대한 튜토리얼</target>
        </trans-unit>
        <trans-unit id="e89f1de21c226b59a1d42d1a18c10afa08b69645" translate="yes" xml:space="preserve">
          <source>A twice as long string of lowercase hexadecimal digits.</source>
          <target state="translated">소문자 16 진수의 두 배 긴 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="d607f495a88ea6528e8578b9888418a4ffea3288" translate="yes" xml:space="preserve">
          <source>A type definition in the C and C++ languages.</source>
          <target state="translated">C 및 C ++ 언어의 유형 정의</target>
        </trans-unit>
        <trans-unit id="b268ce7d38ddd4cca20a237c3776e2eb1ce567ea" translate="yes" xml:space="preserve">
          <source>A typeglob may be dereferenced the same way a reference can, because the dereference syntax always indicates the type of reference desired. So &lt;code&gt;${*foo}&lt;/code&gt; and &lt;code&gt;${\$foo}&lt;/code&gt; both indicate the same scalar variable.</source>
          <target state="translated">역 참조 구문은 항상 원하는 참조 유형을 나타 내기 때문에 타입 글로브는 참조와 동일한 방식으로 역 참조 될 수 있습니다. 따라서 &lt;code&gt;${*foo}&lt;/code&gt; 와 &lt;code&gt;${\$foo}&lt;/code&gt; 모두 동일한 스칼라 변수를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="0bd7e8fb31d877d634438bee94398cae29fcf8b9" translate="yes" xml:space="preserve">
          <source>A typical %Lexicon entry is meant to signify a phrase, taking some number (0 or more) of parameters. An entry is meant to be accessed by via a string</source>
          <target state="translated">일반적인 % Lexicon 항목은 매개 변수를 몇 개 (0 개 이상) 사용하여 구를 나타냅니다. 항목은 문자열을 통해 액세스하도록되어 있습니다</target>
        </trans-unit>
        <trans-unit id="93815fb778bd83a6e1edff66afe56d2943dfbc74" translate="yes" xml:space="preserve">
          <source>A typical context stack pushing can be found in &lt;code&gt;pp_entersub&lt;/code&gt;; the following shows a simplified and stripped-down example of a non-XS call, along with comments showing roughly what each function does.</source>
          <target state="translated">일반적인 컨텍스트 스택 푸시는 &lt;code&gt;pp_entersub&lt;/code&gt; 에서 찾을 수 있습니다 . 다음은 각 함수가 수행하는 작업을 대략적으로 보여주는 주석과 함께 비 XS 호출의 단순화되고 제거 된 예제를 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="8cc65df0ae9490ead8aa8320483d71f0467ec4f8" translate="yes" xml:space="preserve">
          <source>A typical example is:</source>
          <target state="translated">일반적인 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c800528a6e2ea28289c5fcbc08ec77553e110ecf" translate="yes" xml:space="preserve">
          <source>A typical invocation of &lt;a href=&quot;h2xs&quot;&gt;h2xs&lt;/a&gt; for a pure Perl module is:</source>
          <target state="translated">순수한 Perl 모듈에 대한 &lt;a href=&quot;h2xs&quot;&gt;h2xs&lt;/a&gt; 의 일반적인 호출 은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="74d9b7c164412a45025b12444007449586d960a8" translate="yes" xml:space="preserve">
          <source>A typical module using &lt;a href=&quot;dynaloader&quot;&gt;DynaLoader&lt;/a&gt; starts like this:</source>
          <target state="translated">&lt;a href=&quot;dynaloader&quot;&gt;DynaLoader를&lt;/a&gt; 사용하는 일반적인 모듈 은 다음과 같이 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="42c5cd07f5670bfc29c548d8b58ba2ec35dd0a0d" translate="yes" xml:space="preserve">
          <source>A typical one is the version number of your OS specific module. (ie. MM_Unix_VERSION or MM_VMS_VERSION).</source>
          <target state="translated">일반적인 것은 OS 특정 모듈의 버전 번호입니다. (예 : MM_Unix_VERSION 또는 MM_VMS_VERSION).</target>
        </trans-unit>
        <trans-unit id="11ed3b2a4b5cffbd69ae6d23ab2fd650fceaafba" translate="yes" xml:space="preserve">
          <source>A typical use of &lt;code&gt;gen_delimited_pat&lt;/code&gt; would be to build special purpose tags for &lt;code&gt;extract_tagged&lt;/code&gt; . For example, to properly ignore &quot;empty&quot; XML elements (which might contain quoted strings):</source>
          <target state="translated">&lt;code&gt;gen_delimited_pat&lt;/code&gt; 의 일반적인 용도는 &lt;code&gt;extract_tagged&lt;/code&gt; 에 대한 특수 목적 태그를 작성하는 것 입니다. 예를 들어, &quot;빈&quot;XML 요소 (따옴표로 묶인 문자열을 포함 할 수 있음)를 올바르게 무시하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="d65643eaa341a620d95fa5e5dc282d3f90a8a53b" translate="yes" xml:space="preserve">
          <source>A typical use of &lt;code&gt;gen_delimited_pat&lt;/code&gt; would be to build special purpose tags for &lt;code&gt;extract_tagged&lt;/code&gt;. For example, to properly ignore &quot;empty&quot; XML elements (which might contain quoted strings):</source>
          <target state="translated">&lt;code&gt;gen_delimited_pat&lt;/code&gt; 의 일반적인 용도는 &lt;code&gt;extract_tagged&lt;/code&gt; 용 특수 목적 태그를 빌드하는 것 입니다. 예를 들어, &quot;빈&quot;XML 요소 (따옴표로 묶인 문자열을 포함 할 수 있음)를 올바르게 무시하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="5f737b1553f7b6183bb539125409a9e3f04fb617" translate="yes" xml:space="preserve">
          <source>A typical use of the returned seed is for a test program which has too many combinations to test comprehensively in the time available to it each run. It can test a random subset each time, and should there be a failure, log the seed used for that run so that it can later be used to reproduce the same results.</source>
          <target state="translated">리턴 된 시드의 일반적인 용도는 각 실행시 사용 가능한 시간에 종합적으로 테스트하기에 너무 많은 조합이있는 테스트 프로그램에 사용됩니다. 매번 무작위 서브 세트를 테스트 할 수 있으며, 실패가 발생하면 해당 실행에 사용 된 시드를 기록하여 나중에 동일한 결과를 재현하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0f2661e4e43f0aa25c0ad72f03a98747c0242a3a" translate="yes" xml:space="preserve">
          <source>A typical use would be in the destructors of a class hierarchy, as illustrated in the SYNOPSIS above. Each class in the hierarchy has a DESTROY method that performs some class-specific action and then redispatches the call up the hierarchy. As a result, when an object of class S is destroyed, the destructors of</source>
          <target state="translated">위의 SYNOPSIS에 설명 된 것처럼 일반적인 사용은 클래스 계층 구조의 소멸자입니다. 계층 구조의 각 클래스에는 일부 클래스 별 작업을 수행 한 다음 계층 호출을 다시 배포하는 DESTROY 메서드가 있습니다. 결과적으로 S 클래스의 객체가 파괴되면</target>
        </trans-unit>
        <trans-unit id="51560cf43fd833f1ac94f4446b3a3eeb2bb8e520" translate="yes" xml:space="preserve">
          <source>A typical use would be in the destructors of a class hierarchy, as illustrated in the synopsis above. Each class in the hierarchy has a DESTROY method that performs some class-specific action and then redispatches the call up the hierarchy. As a result, when an object of class D is destroyed, the destructors of</source>
          <target state="translated">위의 개요에서 설명 된 것처럼 클래스 계층의 소멸자에서 일반적으로 사용됩니다. 계층 구조의 각 클래스에는 일부 클래스 별 작업을 수행 한 다음 호출을 계층 구조로 다시 전달하는 DESTROY 메소드가 있습니다. 결과적으로 클래스 D의 객체가 파괴되면 소멸자는</target>
        </trans-unit>
        <trans-unit id="7966b50132f33654989f9cc4d535a23f71af99df" translate="yes" xml:space="preserve">
          <source>A typical way to define a collation element table without any file of table:</source>
          <target state="translated">테이블 파일없이 데이터 정렬 요소 테이블을 정의하는 일반적인 방법 :</target>
        </trans-unit>
        <trans-unit id="a7f9b84aae166f2ccc479317d7790aeb3b37e035" translate="yes" xml:space="preserve">
          <source>A unique (for the test job) identifier for the event.</source>
          <target state="translated">이벤트의 고유 한 (테스트 작업용) 식별자입니다.</target>
        </trans-unit>
        <trans-unit id="ef22865cf4abb8e03f585fab66316610e54ceffa" translate="yes" xml:space="preserve">
          <source>A useful construct you might consider using is:</source>
          <target state="translated">사용을 고려할 수있는 유용한 구성은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c66028a80a3f2cbd725150b289e7fb5dace10a6d" translate="yes" xml:space="preserve">
          <source>A useful idiom for &lt;code&gt;lex&lt;/code&gt; -like scanners is &lt;code&gt;/\G.../gc&lt;/code&gt; . You can combine several regexps like this to process a string part-by-part, doing different actions depending on which regexp matched. Each regexp tries to match where the previous one leaves off.</source>
          <target state="translated">&lt;code&gt;lex&lt;/code&gt; 와 같은 스캐너에 유용한 관용구 는 &lt;code&gt;/\G.../gc&lt;/code&gt; 입니다. 이와 같은 여러 정규 표현식을 결합하여 문자열을 부분적으로 처리하여 일치하는 정규 표현식에 따라 다른 조치를 수행 할 수 있습니다. 각 정규 표현식은 이전의 정규 표현식과 일치하는 부분을 찾습니다.</target>
        </trans-unit>
        <trans-unit id="1c822ecfcb927260c8676a672de6aa8120d59332" translate="yes" xml:space="preserve">
          <source>A useful idiom for &lt;code&gt;lex&lt;/code&gt;-like scanners is &lt;code&gt;/\G.../gc&lt;/code&gt;. You can combine several regexps like this to process a string part-by-part, doing different actions depending on which regexp matched. Each regexp tries to match where the previous one leaves off.</source>
          <target state="translated">&lt;code&gt;lex&lt;/code&gt; 와 유사한 스캐너에 대한 유용한 관용구 는 &lt;code&gt;/\G.../gc&lt;/code&gt; 입니다. 이와 같은 여러 정규 표현식을 결합하여 문자열을 부분적으로 처리하고 일치하는 정규 표현식에 따라 다른 작업을 수행 할 수 있습니다. 각 정규식은 이전 정규식이 중단되는 위치와 일치하려고합니다.</target>
        </trans-unit>
        <trans-unit id="6c232601ef6ab32c7a06536b5534313e59c1adfb" translate="yes" xml:space="preserve">
          <source>A useful variation of the above is the target &lt;code&gt;testdb&lt;/code&gt; . It runs the test under the Perl debugger (see &lt;a href=&quot;../perldebug&quot;&gt;perldebug&lt;/a&gt;). If the file</source>
          <target state="translated">위의 유용한 변형은 대상 &lt;code&gt;testdb&lt;/code&gt; 입니다. Perl 디버거에서 테스트를 실행합니다 ( &lt;a href=&quot;../perldebug&quot;&gt;perldebug&lt;/a&gt; 참조 ). 파일이</target>
        </trans-unit>
        <trans-unit id="9a4629e764504e5d714343e7f665ac8cbd7a6361" translate="yes" xml:space="preserve">
          <source>A useful variation of the above is the target &lt;code&gt;testdb&lt;/code&gt;. It runs the test under the Perl debugger (see &lt;a href=&quot;perldebug&quot;&gt;perldebug&lt;/a&gt;). If the file</source>
          <target state="translated">위의 유용한 변형은 target &lt;code&gt;testdb&lt;/code&gt; 입니다. Perl 디버거에서 테스트를 실행합니다 ( &lt;a href=&quot;perldebug&quot;&gt;perldebug&lt;/a&gt; 참조 ). 파일이</target>
        </trans-unit>
        <trans-unit id="260c8a8479b809c6dd9a69c354f54517ffc43b32" translate="yes" xml:space="preserve">
          <source>A user ID. Often used in the context of &lt;b&gt;file&lt;/b&gt; or &lt;b&gt;process&lt;/b&gt; ownership.</source>
          <target state="translated">사용자 ID &lt;b&gt;파일&lt;/b&gt; 또는 &lt;b&gt;프로세스&lt;/b&gt; 소유권 과 관련하여 종종 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="c3c861709ec338f51d30ce5477159ff491c5825e" translate="yes" xml:space="preserve">
          <source>A user of Perl does not normally need to know nor care how Perl happens to encode its internal strings, but it becomes relevant when outputting Unicode strings to a stream without a PerlIO layer (one with the &quot;default&quot; encoding). In such a case, the raw bytes used internally (the native character set or UTF-8, as appropriate for each string) will be used, and a &quot;Wide character&quot; warning will be issued if those strings contain a character beyond 0x00FF.</source>
          <target state="translated">Perl 사용자는 일반적으로 Perl이 내부 문자열을 인코딩하는 방법을 알거나 신경 쓸 필요가 없지만 PerlIO 레이어가없는 스트림 ( &quot;기본&quot;인코딩이있는 스트림)으로 유니 코드 문자열을 출력 할 때는 관련이 있습니다. 이 경우 내부적으로 사용되는 원시 바이트 (각 문자열에 적합한 고유 문자 세트 또는 UTF-8)가 사용되며 해당 문자열에 0x00FF 이상의 문자가 포함 된 경우 &quot;와이드 문자&quot;경고가 발행됩니다.</target>
        </trans-unit>
        <trans-unit id="58e51e01dfdc97593c823ef9c32c82bf5b645a0e" translate="yes" xml:space="preserve">
          <source>A user-defined &lt;b&gt;type&lt;/b&gt;, implemented in Perl via a &lt;b&gt;package&lt;/b&gt; that provides (either directly or by inheritance) &lt;b&gt;methods&lt;/b&gt; (that is, &lt;b&gt;subroutines&lt;/b&gt;) to handle &lt;b&gt;instances&lt;/b&gt; of the class (its &lt;b&gt;objects&lt;/b&gt;). See also &lt;b&gt;inheritance&lt;/b&gt;.</source>
          <target state="translated">사용자 정의 &lt;b&gt;형&lt;/b&gt; 비아 펄 구현 &lt;b&gt;패키지&lt;/b&gt; (직접 또는 상속에 의해) 제공 &lt;b&gt;방법&lt;/b&gt; (즉, &lt;b&gt;서브 루틴&lt;/b&gt; ) 처리하는 &lt;b&gt;인스턴스&lt;/b&gt; 클래스 (그것의 &lt;b&gt;개체&lt;/b&gt; ). &lt;b&gt;상속&lt;/b&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="049b62081eecdd58978da0961ea176048425ca09" translate="yes" xml:space="preserve">
          <source>A user-defined subroutine call or a method invocation.</source>
          <target state="translated">사용자 정의 서브 루틴 호출 또는 메소드 호출</target>
        </trans-unit>
        <trans-unit id="0655aa7eaac426bb455567c21c49258161952382" translate="yes" xml:space="preserve">
          <source>A utility function that returns the line number that the function was called on. You can pass it an offset which will be added to the result. This is very useful for working out the correct text of diagnostic functions that contain line numbers.</source>
          <target state="translated">함수가 호출 된 행 번호를 리턴하는 유틸리티 함수입니다. 결과에 추가 될 오프셋을 전달할 수 있습니다. 줄 번호가 포함 된 올바른 진단 기능 텍스트를 작성하는 데 매우 유용합니다.</target>
        </trans-unit>
        <trans-unit id="62abf9744bbb54e44124db26e468de26dab74a60" translate="yes" xml:space="preserve">
          <source>A value indicating whether unmatched substrings (see below) within the text should be skipped or returned as fields. If the value is true, such substrings are skipped. Otherwise, they are returned.</source>
          <target state="translated">텍스트 내에서 일치하지 않는 하위 문자열 (아래 참조)을 건너 뛰거나 필드로 반환해야하는지 여부를 나타내는 값입니다. 값이 true이면 해당 하위 문자열을 건너 뜁니다. 그렇지 않으면 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="9cb7aeb0b53152f8df982c234ecceb419398cf71" translate="yes" xml:space="preserve">
          <source>A value that happens to be a &lt;b&gt;scalar&lt;/b&gt; as opposed to a &lt;b&gt;list&lt;/b&gt;.</source>
          <target state="translated">&lt;b&gt;리스트&lt;/b&gt; 와는 반대로 &lt;b&gt;스칼라&lt;/b&gt; 가되는 값입니다 .&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="1e971228dd4d3b2de042f3e955105fd62424ff5a" translate="yes" xml:space="preserve">
          <source>A value that indicates the current Perl interpreter's phase. Possible values include &lt;code&gt;PERL_PHASE_CONSTRUCT&lt;/code&gt;, &lt;code&gt;PERL_PHASE_START&lt;/code&gt;, &lt;code&gt;PERL_PHASE_CHECK&lt;/code&gt;, &lt;code&gt;PERL_PHASE_INIT&lt;/code&gt;, &lt;code&gt;PERL_PHASE_RUN&lt;/code&gt;, &lt;code&gt;PERL_PHASE_END&lt;/code&gt;, and &lt;code&gt;PERL_PHASE_DESTRUCT&lt;/code&gt;.</source>
          <target state="translated">현재 Perl 인터프리터의 단계를 나타내는 값입니다. 가능한 값은 &lt;code&gt;PERL_PHASE_CONSTRUCT&lt;/code&gt; , &lt;code&gt;PERL_PHASE_START&lt;/code&gt; , &lt;code&gt;PERL_PHASE_CHECK&lt;/code&gt; , &lt;code&gt;PERL_PHASE_INIT&lt;/code&gt; , &lt;code&gt;PERL_PHASE_RUN&lt;/code&gt; , &lt;code&gt;PERL_PHASE_END&lt;/code&gt; 및 &lt;code&gt;PERL_PHASE_DESTRUCT&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="6cfc7b273de973b6dc0aacfe92aeb280b49228f1" translate="yes" xml:space="preserve">
          <source>A value that is either &lt;b&gt;true&lt;/b&gt; or &lt;b&gt;false&lt;/b&gt;.</source>
          <target state="translated">&lt;b&gt;true&lt;/b&gt; 또는 &lt;b&gt;false&lt;/b&gt; 값입니다 .</target>
        </trans-unit>
        <trans-unit id="a8f81a2763e41d6e30e66f64538647929ee6a4a5" translate="yes" xml:space="preserve">
          <source>A variable whose value is the name of another variable or subroutine. By &lt;b&gt;dereferencing&lt;/b&gt; the first variable, you can get at the second one. Symbolic references are illegal under &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict &quot;refs&quot;&lt;/code&gt; .</source>
          <target state="translated">값이 다른 변수 또는 서브 루틴의 이름 인 변수. 첫 번째 변수 를 &lt;b&gt;역 참조&lt;/b&gt; 하면 두 번째 변수를 얻을 수 있습니다. 기호 참조는 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict &quot;refs&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="95fd27453c9995852c3689cce9903262d89f1b17" translate="yes" xml:space="preserve">
          <source>A variable whose value is the name of another variable or subroutine. By &lt;b&gt;dereferencing&lt;/b&gt; the first variable, you can get at the second one. Symbolic references are illegal under &lt;code&gt;use strict &quot;refs&quot;&lt;/code&gt;.</source>
          <target state="translated">값이 다른 변수 또는 서브 루틴의 이름 인 변수. 첫 번째 변수 를 &lt;b&gt;역 참조&lt;/b&gt; 하면 두 번째 변수를 얻을 수 있습니다. 심볼릭 참조는 &lt;code&gt;use strict &quot;refs&quot;&lt;/code&gt; 하에서 불법 입니다.</target>
        </trans-unit>
        <trans-unit id="ca6ffd45b1cb28ce9dd386af1f375ee5391518d5" translate="yes" xml:space="preserve">
          <source>A variant of &lt;code&gt;save_item&lt;/code&gt; which takes multiple arguments via an array &lt;code&gt;sarg&lt;/code&gt; of &lt;code&gt;SV*&lt;/code&gt; of length &lt;code&gt;maxsarg&lt;/code&gt; .</source>
          <target state="translated">길이가 &lt;code&gt;maxsarg&lt;/code&gt; 인 &lt;code&gt;SV*&lt;/code&gt; 의 배열 &lt;code&gt;sarg&lt;/code&gt; 를 통해 여러 인수를 취하는 &lt;code&gt;save_item&lt;/code&gt; 의 변형입니다 .</target>
        </trans-unit>
        <trans-unit id="5fa8d9d2a392198522660733895422043b7a1e1c" translate="yes" xml:space="preserve">
          <source>A variant of &lt;code&gt;save_item&lt;/code&gt; which takes multiple arguments via an array &lt;code&gt;sarg&lt;/code&gt; of &lt;code&gt;SV*&lt;/code&gt; of length &lt;code&gt;maxsarg&lt;/code&gt;.</source>
          <target state="translated">길이가 &lt;code&gt;maxsarg&lt;/code&gt; 인 &lt;code&gt;SV*&lt;/code&gt; 의 배열 &lt;code&gt;sarg&lt;/code&gt; 를 통해 여러 인수를 취하는 &lt;code&gt;save_item&lt;/code&gt; 의 변형입니다 .</target>
        </trans-unit>
        <trans-unit id="7ccb1828da7b95bb5a049529fa23b72700a0cdfc" translate="yes" xml:space="preserve">
          <source>A venerable Stream EDitor from which Perl derives some of its ideas.</source>
          <target state="translated">Perl이 아이디어를 도출 할 수있는 훌륭한 스트림 교육자.</target>
        </trans-unit>
        <trans-unit id="695b604bb0917e749e0123615e9c577cb0315edf" translate="yes" xml:space="preserve">
          <source>A venerable typesetting language from which Perl derives the name of its &lt;code&gt;$%&lt;/code&gt; variable and which is secretly used in the production of Camel books.</source>
          <target state="translated">Perl이 &lt;code&gt;$%&lt;/code&gt; 변수 의 이름을 파생시키고 Camel 서적 제작에 비밀리에 사용되는 훌륭한 조판 언어 .</target>
        </trans-unit>
        <trans-unit id="c02ac9d5e79aa52379337adc725d78150bf24188" translate="yes" xml:space="preserve">
          <source>A verbatim paragraph is distinguished by having its first character be a space or a tab. (And commonly, all its lines begin with spaces and/or tabs.) It should be reproduced exactly, with tabs assumed to be on 8-column boundaries. There are no special formatting codes, so you can't italicize or anything like that. A \ means \, and nothing else.</source>
          <target state="translated">축약어 단락은 첫 문자를 공백 또는 탭으로 구분합니다. 일반적으로 모든 선은 공백 및 / 또는 탭으로 시작합니다. 탭은 8 열 경계에있는 것으로 가정하여 정확하게 재현해야합니다. 특별한 형식 코드가 없으므로 기울임 꼴 또는 이와 유사한 것을 사용할 수 없습니다. A는 \를 의미하며, 다른 것은 없습니다.</target>
        </trans-unit>
        <trans-unit id="22c613333ba591340aa305c94a11a4461a68dd5e" translate="yes" xml:space="preserve">
          <source>A version number without an operator is equivalent to specifying a minimum (&lt;code&gt;&amp;gt;=&lt;/code&gt;). Extra whitespace is allowed.</source>
          <target state="translated">연산자가없는 버전 번호는 최소값 ( &lt;code&gt;&amp;gt;=&lt;/code&gt; ) 을 지정하는 것과 같습니다 . 추가 공백이 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="b4ee89b787aaa148bf4a7c02399965cde2c89e83" translate="yes" xml:space="preserve">
          <source>A version of &lt;code&gt;SvPV&lt;/code&gt; which guarantees to evaluate &lt;code&gt;sv&lt;/code&gt; only once. Only use this if &lt;code&gt;sv&lt;/code&gt; is an expression with side effects, otherwise use the more efficient &lt;code&gt;SvPV&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;sv&lt;/code&gt; 를 한 번만 평가하도록 보장하는 &lt;code&gt;SvPV&lt;/code&gt; 버전 . &lt;code&gt;sv&lt;/code&gt; 가 부작용이있는 표현식 인 경우에만 사용 하고 그렇지 않으면보다 효율적인 &lt;code&gt;SvPV&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="90ef07f614e457f605b2b47a6d2def401106c68e" translate="yes" xml:space="preserve">
          <source>A version of &lt;code&gt;SvPV&lt;/code&gt; which guarantees to evaluate &lt;code&gt;sv&lt;/code&gt; only once. Only use this if &lt;code&gt;sv&lt;/code&gt; is an expression with side effects, otherwise use the more efficient &lt;code&gt;SvPV&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;sv&lt;/code&gt; 를 한 번만 평가하도록 보장하는 &lt;code&gt;SvPV&lt;/code&gt; 버전입니다 . &lt;code&gt;sv&lt;/code&gt; 가 부작용이있는 표현식 인 경우에만 사용 하고 그렇지 않으면 더 효율적인 &lt;code&gt;SvPV&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="800c2c1c70843eecf0d954a2a74fcb4ffc03b783" translate="yes" xml:space="preserve">
          <source>A version of &lt;code&gt;savepv()&lt;/code&gt; /&lt;code&gt;savepvn()&lt;/code&gt; which gets the string to duplicate from the passed in SV using &lt;code&gt;SvPV()&lt;/code&gt;</source>
          <target state="translated">(A)의 버전 &lt;code&gt;savepv()&lt;/code&gt; / &lt;code&gt;savepvn()&lt;/code&gt; 문자열을 얻는다 사용하여 SV 전달에서 복제하기 &lt;code&gt;SvPV()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="89a4a2fa99f32dbf2c67191e1f912497d7b97772" translate="yes" xml:space="preserve">
          <source>A version of &lt;code&gt;savepv()&lt;/code&gt; which allocates the duplicate string in memory which is shared between threads.</source>
          <target state="translated">스레드간에 공유되는 메모리에 중복 문자열을 할당하는 &lt;code&gt;savepv()&lt;/code&gt; 버전입니다 .</target>
        </trans-unit>
        <trans-unit id="ddb24d04582a4cc50d29e68434c725f208123c3e" translate="yes" xml:space="preserve">
          <source>A version of &lt;code&gt;savepv()&lt;/code&gt;/&lt;code&gt;savepvn()&lt;/code&gt; which gets the string to duplicate from the passed in SV using &lt;code&gt;SvPV()&lt;/code&gt;</source>
          <target state="translated">(A)의 버전 &lt;code&gt;savepv()&lt;/code&gt; / &lt;code&gt;savepvn()&lt;/code&gt; 문자열을 얻는다 사용하여 SV 전달에서 복제하기 &lt;code&gt;SvPV()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="565845504b0795e27ee455abaf7db0dd0b76d6ff" translate="yes" xml:space="preserve">
          <source>A version of &lt;code&gt;savepvn()&lt;/code&gt; which allocates the duplicate string in memory which is shared between threads. (With the specific difference that a &lt;code&gt;NULL&lt;/code&gt; pointer is not acceptable)</source>
          <target state="translated">스레드간에 공유되는 메모리에 중복 문자열을 할당하는 &lt;code&gt;savepvn()&lt;/code&gt; 버전입니다 . ( &lt;code&gt;NULL&lt;/code&gt; 포인터가 허용되지 않는다는 구체적인 차이점이 있습니다 )</target>
        </trans-unit>
        <trans-unit id="5d7f6a9127b04f3a28923aa726cf029e923caeca" translate="yes" xml:space="preserve">
          <source>A version of &lt;code&gt;savepvn()&lt;/code&gt; which allocates the duplicate string in memory which is shared between threads. (With the specific difference that a NULL pointer is not acceptable)</source>
          <target state="translated">스레드간에 공유되는 메모리에 중복 문자열을 할당하는 &lt;code&gt;savepvn()&lt;/code&gt; 버전입니다 . (NULL 포인터가 허용되지 않는다는 구체적인 차이점이 있음)</target>
        </trans-unit>
        <trans-unit id="d9a7ac8d6bb6f23e5af260b2b68521de71f4974c" translate="yes" xml:space="preserve">
          <source>A version of &lt;code&gt;savepvs()&lt;/code&gt; which allocates the duplicate string in memory which is shared between threads.</source>
          <target state="translated">스레드간에 공유되는 메모리에 중복 문자열을 할당하는 &lt;code&gt;savepvs()&lt;/code&gt; 버전입니다 .</target>
        </trans-unit>
        <trans-unit id="f84e0230ffdad6c151bf74824e07538ecfccd8ed" translate="yes" xml:space="preserve">
          <source>A version of &lt;code&gt;savesharedpv()&lt;/code&gt; which allocates the duplicate string in memory which is shared between threads.</source>
          <target state="translated">스레드간에 공유되는 메모리에 중복 문자열을 할당하는 &lt;code&gt;savesharedpv()&lt;/code&gt; 버전입니다 .</target>
        </trans-unit>
        <trans-unit id="8ab5e633d2c66281cffd9c60de281036938368fe" translate="yes" xml:space="preserve">
          <source>A very complete generic buffering layer which provides the whole of PerlIO API. It is also intended to be used as a &quot;base class&quot; for other layers. (For example its &lt;code&gt;Read()&lt;/code&gt; method is implemented in terms of the &lt;code&gt;Get_cnt()&lt;/code&gt; /&lt;code&gt;Get_ptr()&lt;/code&gt; /&lt;code&gt;Set_ptrcnt()&lt;/code&gt; methods).</source>
          <target state="translated">PerlIO API 전체를 제공하는 매우 완벽한 일반 버퍼링 계층입니다. 또한 다른 레이어의 &quot;기본 클래스&quot;로 사용되도록 고안되었습니다. (예를 들어 &lt;code&gt;Read()&lt;/code&gt; 메소드는 &lt;code&gt;Get_cnt()&lt;/code&gt; / &lt;code&gt;Get_ptr()&lt;/code&gt; / &lt;code&gt;Set_ptrcnt()&lt;/code&gt; 메소드로 구현됩니다).</target>
        </trans-unit>
        <trans-unit id="25e6348d550a8b48765f27b13660bf1212dac2ba" translate="yes" xml:space="preserve">
          <source>A very complete generic buffering layer which provides the whole of PerlIO API. It is also intended to be used as a &quot;base class&quot; for other layers. (For example its &lt;code&gt;Read()&lt;/code&gt; method is implemented in terms of the &lt;code&gt;Get_cnt()&lt;/code&gt;/&lt;code&gt;Get_ptr()&lt;/code&gt;/&lt;code&gt;Set_ptrcnt()&lt;/code&gt; methods).</source>
          <target state="translated">PerlIO API 전체를 제공하는 매우 완전한 일반 버퍼링 계층입니다. 또한 다른 레이어의 &quot;기본 클래스&quot;로 사용하기위한 것입니다. (예를 들어 &lt;code&gt;Read()&lt;/code&gt; 메서드는 &lt;code&gt;Get_cnt()&lt;/code&gt; / &lt;code&gt;Get_ptr()&lt;/code&gt; / &lt;code&gt;Set_ptrcnt()&lt;/code&gt; 메서드 측면에서 구현됩니다 ).</target>
        </trans-unit>
        <trans-unit id="cff43b9c47bd071d2d320e539e7c2ec5b836b1af" translate="yes" xml:space="preserve">
          <source>A very large and constantly evolving language with several alternative and largely incompatible syntaxes, in which anyone can define anything any way they choose, and usually do. Speakers of this language think it&amp;rsquo;s easy to learn because it&amp;rsquo;s so easily twisted to one&amp;rsquo;s own ends, but dialectical differences make tribal intercommunication nearly impossible, and travelers are often reduced to a pidgin-like subset of the language. To be universally understood, a Unix shell programmer must spend years of study in the art. Many have abandoned this discipline and now communicate via an Esperanto-like language called Perl.</source>
          <target state="translated">누구든지 원하는 방식으로 정의하고 일반적으로 수행 할 수있는 몇 가지 대체적이고 대체적으로 호환되지 않는 구문이 포함 된 매우 크고 지속적으로 발전하는 언어입니다. 이 언어를 사용하는 사람들은 자신의 목적에 따라 쉽게 뒤 틀릴 수 있기 때문에 배우기 쉽다고 생각하지만 변증 법적 차이로 인해 부족의 의사 소통이 거의 불가능 해지며 여행자는 종종 언어와 같은 언어의 하위 집합으로 축소됩니다. 보편적으로 이해되기 위해서는 유닉스 쉘 프로그래머가이 분야에서 수년간의 연구를해야합니다. 많은 사람들이이 규율을 버리고 이제는 Perl이라는 에스페란토와 같은 언어를 통해 의사 소통을합니다.</target>
        </trans-unit>
        <trans-unit id="b75485a79ff1cabe11e71e2c78ee68045837b121" translate="yes" xml:space="preserve">
          <source>A very thin wrapper around Config.pm so MakeMaker is easier to test.</source>
          <target state="translated">Config.pm 주변의 매우 얇은 래퍼이므로 MakeMaker를 쉽게 테스트 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d78336a8aa6af1a7a3b8d0aa36c1d974ee9b4017" translate="yes" xml:space="preserve">
          <source>A void* pointing to an engine-defined data structure. The Perl engine uses the &lt;code&gt;regexp_internal&lt;/code&gt; structure (see &lt;a href=&quot;perlreguts#Base-Structures&quot;&gt;&quot;Base Structures&quot; in perlreguts&lt;/a&gt;) but a custom engine should use something else.</source>
          <target state="translated">엔진 정의 데이터 구조를 가리키는 void *. Perl 엔진은 &lt;code&gt;regexp_internal&lt;/code&gt; 구조 ( perlreguts의 &lt;a href=&quot;perlreguts#Base-Structures&quot;&gt;&quot;기본 구조&quot;&lt;/a&gt; 참조 )를 사용하지만 사용자 정의 엔진은 다른 것을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="3816dce510c914716ac16326960ce66f1b1eab28" translate="yes" xml:space="preserve">
          <source>A void* pointing to an engine-defined data structure. The Perl engine uses the &lt;code&gt;regexp_internal&lt;/code&gt; structure (see &lt;a href=&quot;perlreguts#Base-Structures&quot;&gt;Base Structures in perlreguts&lt;/a&gt;) but a custom engine should use something else.</source>
          <target state="translated">엔진 정의 데이터 구조를 가리키는 void * Perl 엔진은 &lt;code&gt;regexp_internal&lt;/code&gt; 구조 ( perlreguts의 &lt;a href=&quot;perlreguts#Base-Structures&quot;&gt;기본 구조&lt;/a&gt; 참조 )를 사용하지만 사용자 정의 엔진은 다른 것을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="199fcb36f761477b8bc11025866dc8da66f59cd6" translate="yes" xml:space="preserve">
          <source>A walled off area that&amp;rsquo;s not supposed to affect beyond its walls. You let kids play in the sandbox instead of running in the road. See Camel chapter 20, &amp;ldquo;Security&amp;rdquo;.</source>
          <target state="translated">벽 너머에 영향을 미치지 않는 벽으로 둘러싸인 지역. 아이들은 도로에서 달리지 않고 샌드 박스에서 놀 수 있습니다. 낙타 20 장 &quot;보안&quot;을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="52bce4e77f028ccf4be5e2732e6cc0cda9d45ce4" translate="yes" xml:space="preserve">
          <source>A warning is issued if an attempt is made to register an operator not found above.</source>
          <target state="translated">위에서 찾을 수없는 운영자를 등록하려고하면 경고가 발행됩니다.</target>
        </trans-unit>
        <trans-unit id="a18ef0b74f65545d966263b3d3c2472e8453a59c" translate="yes" xml:space="preserve">
          <source>A warning is printed if more than one POD file with the same POD name is found, e.g.</source>
          <target state="translated">동일한 POD 이름을 가진 둘 이상의 POD 파일이 발견되면 경고가 인쇄됩니다 (예 :</target>
        </trans-unit>
        <trans-unit id="700f87e210bceec8357a7b2e426634dd3d25de48" translate="yes" xml:space="preserve">
          <source>A well-defined sequence of steps, explained clearly enough that even a computer could do them.</source>
          <target state="translated">잘 정의 된 일련의 단계는 컴퓨터조차도 수행 할 수있을 정도로 명확하게 설명되었습니다.</target>
        </trans-unit>
        <trans-unit id="69583ba800841309993f3cd8027c2138231fdd98" translate="yes" xml:space="preserve">
          <source>A whiz-bang hardware gizmo (like a disk or tape drive or a modem or a joystick or a mouse) attached to your computer, which the &lt;b&gt;operating system&lt;/b&gt; tries to make look like a &lt;b&gt;file&lt;/b&gt; (or a bunch of files). Under Unix, these fake files tend to live in the</source>
          <target state="translated">&lt;b&gt;운영 체제&lt;/b&gt; 가 &lt;b&gt;파일&lt;/b&gt; (또는 여러 파일) 처럼 보이도록 컴퓨터에 부착 된 위즈 뱅 하드웨어 기즈모 (예 : 디스크 또는 테이프 드라이브 또는 모뎀 또는 조이스틱 또는 마우스) 유닉스에서 이러한 가짜 파일은</target>
        </trans-unit>
        <trans-unit id="90dbb683e595bd8a442976ee525366f34cadb549" translate="yes" xml:space="preserve">
          <source>A word boundary (&lt;code&gt;\b&lt;/code&gt; ) is a spot between two characters that has a &lt;code&gt;\w&lt;/code&gt; on one side of it and a &lt;code&gt;\W&lt;/code&gt; on the other side of it (in either order), counting the imaginary characters off the beginning and end of the string as matching a &lt;code&gt;\W&lt;/code&gt; . (Within character classes &lt;code&gt;\b&lt;/code&gt; represents backspace rather than a word boundary, just as it normally does in any double-quoted string.) The &lt;code&gt;\A&lt;/code&gt; and &lt;code&gt;\Z&lt;/code&gt; are just like &quot;^&quot; and &quot;$&quot;, except that they won't match multiple times when the &lt;code&gt;/m&lt;/code&gt; modifier is used, while &quot;^&quot; and &quot;$&quot; will match at every internal line boundary. To match the actual end of the string and not ignore an optional trailing newline, use &lt;code&gt;\z&lt;/code&gt; .</source>
          <target state="translated">단어 경계 ( &lt;code&gt;\b&lt;/code&gt; )를 갖는 두 자의 스포트 &lt;code&gt;\w&lt;/code&gt; 그것과의 한쪽 &lt;code&gt;\W&lt;/code&gt; (두 순서로), 그것의 다른쪽에는 시작과 끝 오프 허수 문자 카운팅 &lt;code&gt;\W&lt;/code&gt; 와 일치하는 문자열 . 문자 클래스 내에서 &lt;code&gt;\b&lt;/code&gt; 는 일반적으로 큰 따옴표로 묶인 문자열에서와 같이 단어 경계가 아닌 백 스페이스를 나타냅니다. &lt;code&gt;\A&lt;/code&gt; 및 &lt;code&gt;\Z&lt;/code&gt; 는 &quot;^&quot;및 &quot;$&quot;와 같습니다. &lt;code&gt;/m&lt;/code&gt; 수정자를 사용 하면 여러 번 일치 하지만 &quot;^&quot;및 &quot;$&quot;는 모든 내부 줄 경계에서 일치합니다. 문자열의 실제 끝과 일치하고 선택적 후행 줄 바꿈을 무시하지 않으려면사용하다 &lt;code&gt;\z&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="39e1413576078848906e46e67f29b3c0eeaa0472" translate="yes" xml:space="preserve">
          <source>A word boundary (&lt;code&gt;\b&lt;/code&gt;) is a spot between two characters that has a &lt;code&gt;\w&lt;/code&gt; on one side of it and a &lt;code&gt;\W&lt;/code&gt; on the other side of it (in either order), counting the imaginary characters off the beginning and end of the string as matching a &lt;code&gt;\W&lt;/code&gt;. (Within character classes &lt;code&gt;\b&lt;/code&gt; represents backspace rather than a word boundary, just as it normally does in any double-quoted string.) The &lt;code&gt;\A&lt;/code&gt; and &lt;code&gt;\Z&lt;/code&gt; are just like &lt;code&gt;&quot;^&quot;&lt;/code&gt; and &lt;code&gt;&quot;$&quot;&lt;/code&gt;, except that they won't match multiple times when the &lt;code&gt;/m&lt;/code&gt; modifier is used, while &lt;code&gt;&quot;^&quot;&lt;/code&gt; and &lt;code&gt;&quot;$&quot;&lt;/code&gt; will match at every internal line boundary. To match the actual end of the string and not ignore an optional trailing newline, use &lt;code&gt;\z&lt;/code&gt;.</source>
          <target state="translated">단어 경계 ( &lt;code&gt;\b&lt;/code&gt; )는 한쪽에 &lt;code&gt;\w&lt;/code&gt; 가 있고 다른쪽에 &lt;code&gt;\W&lt;/code&gt; 가있는 (순서에 상관없이) 두 문자 사이의 지점으로 , 시작과 끝에서 가상 문자를 계산합니다. &lt;code&gt;\W&lt;/code&gt; 와 일치하는 문자열 . (문자 클래스 내에서 &lt;code&gt;\b&lt;/code&gt; 정상적으로 어떤 이중 인용 된 문자열에서와 마찬가지로, 오히려 단어 경계보다 백 스페이스를 나타냅니다.)이 &lt;code&gt;\A&lt;/code&gt; 와 &lt;code&gt;\Z&lt;/code&gt; 단지처럼 &lt;code&gt;&quot;^&quot;&lt;/code&gt; 와 &lt;code&gt;&quot;$&quot;&lt;/code&gt; 것을 제외하고 그들은하지 않습니다 &lt;code&gt;/m&lt;/code&gt; 수정자를 사용 하면 여러 번 일치 하지만 &lt;code&gt;&quot;^&quot;&lt;/code&gt; 및 &lt;code&gt;&quot;$&quot;&lt;/code&gt; 모든 내부 라인 경계에서 일치합니다. 문자열의 실제 끝을 일치시키고 선택적 후행 개행을 무시하지 않으려면 &lt;code&gt;\z&lt;/code&gt; 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="b9f5130c323d4b84b2e0887ec7513db659cf437f" translate="yes" xml:space="preserve">
          <source>A word on terminology: I shall use the term</source>
          <target state="translated">용어에 관한 단어 : 나는 그 용어를 사용할 것이다</target>
        </trans-unit>
        <trans-unit id="b1c5343ffbdad1e7ce4b8c849341bcb5442f07e1" translate="yes" xml:space="preserve">
          <source>A word sufficiently ambiguous to be deemed illegal under &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict 'subs'&lt;/code&gt; . In the absence of that stricture, a bareword is treated as if quotes were around it.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict 'subs'&lt;/code&gt; &lt;a href=&quot;functions/use&quot;&gt;사용하는 경우&lt;/a&gt; 불법으로 간주 될 정도로 모호한 단어 . 그 엄격함이 없으면, 따옴표가 그 주위에있는 것처럼 취급합니다.</target>
        </trans-unit>
        <trans-unit id="855daaf204247906f61907b818bcf2ad84c811cf" translate="yes" xml:space="preserve">
          <source>A word sufficiently ambiguous to be deemed illegal under &lt;code&gt;use strict 'subs'&lt;/code&gt;. In the absence of that stricture, a bareword is treated as if quotes were around it.</source>
          <target state="translated">&lt;code&gt;use strict 'subs'&lt;/code&gt; 하에서 불법으로 간주 될만큼 충분히 모호한 단어 입니다. 이러한 제한이 없으면 맨말은 따옴표가 주위에있는 것처럼 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="310f40f7f3f90c12a6b195eedcb48c5f8026ea77" translate="yes" xml:space="preserve">
          <source>A word that has no other interpretation in the grammar will be treated as if it were a quoted string. These are known as &quot;barewords&quot;. As with filehandles and labels, a bareword that consists entirely of lowercase letters risks conflict with future reserved words, and if you use the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings&lt;/code&gt; pragma or the &lt;b&gt;-w&lt;/b&gt; switch, Perl will warn you about any such words. Perl limits barewords (like identifiers) to about 250 characters. Future versions of Perl are likely to eliminate these arbitrary limitations.</source>
          <target state="translated">문법에 다른 해석이없는 단어는 인용 문자열 인 것처럼 처리됩니다. 이것을 &quot;베어 워드&quot;라고합니다. 파일 핸들 및 레이블과 마찬가지로 완전히 소문자로 구성된 베어 워드는 향후 예약어와 충돌 할 수 있으며 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings&lt;/code&gt; pragma 또는 &lt;b&gt;-w&lt;/b&gt; 스위치를 사용하면 Perl이 해당 단어에 대해 경고합니다. Perl은 식별자와 같은 베어 워드를 약 250 자로 제한합니다. 이후 버전의 Perl은 이러한 임의의 제한을 제거 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ff8af98833234cb11c9ca0881ff5f7ec34953efb" translate="yes" xml:space="preserve">
          <source>A word that has no other interpretation in the grammar will be treated as if it were a quoted string. These are known as &quot;barewords&quot;. As with filehandles and labels, a bareword that consists entirely of lowercase letters risks conflict with future reserved words, and if you use the &lt;code&gt;use warnings&lt;/code&gt; pragma or the &lt;b&gt;-w&lt;/b&gt; switch, Perl will warn you about any such words. Perl limits barewords (like identifiers) to about 250 characters. Future versions of Perl are likely to eliminate these arbitrary limitations.</source>
          <target state="translated">문법에서 다른 해석이없는 단어는 따옴표로 묶인 문자열처럼 처리됩니다. 이를 &quot;베어 워드&quot;라고합니다. 파일 핸들 및 레이블과 마찬가지로 소문자로만 구성된 베어 워드는 향후 예약어와 충돌 할 위험이 있으며, &lt;code&gt;use warnings&lt;/code&gt; pragma 또는 &lt;b&gt;-w&lt;/b&gt; 스위치를 사용하면 Perl이 이러한 단어에 대해 경고합니다. Perl은 식별자와 같은 베어 워드를 약 250 자로 제한합니다. Perl의 향후 버전은 이러한 임의의 제한을 제거 할 것입니다.</target>
        </trans-unit>
        <trans-unit id="41517852ad5f31fc26a5aada0fdb82adad0543c7" translate="yes" xml:space="preserve">
          <source>A word with a specific, built-in meaning to a &lt;b&gt;compiler&lt;/b&gt;, such as &lt;code&gt;if&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/delete&quot;&gt;delete&lt;/a&gt;&lt;/code&gt;. In many languages (not Perl), it&amp;rsquo;s illegal to use reserved words to name anything else. (Which is why they&amp;rsquo;re reserved, after all.) In Perl, you just can&amp;rsquo;t use them to name &lt;b&gt;labels&lt;/b&gt; or &lt;b&gt;filehandles&lt;/b&gt;. Also called &amp;ldquo;keywords&amp;rdquo;.</source>
          <target state="translated">특정와 단어, 내장의 의미를 &lt;b&gt;컴파일러&lt;/b&gt; 와 같은, &lt;code&gt;if&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;functions/delete&quot;&gt;delete&lt;/a&gt;&lt;/code&gt; . Perl이 아닌 많은 언어에서 예약어를 사용하여 다른 이름을 지정하는 것은 불법입니다. (결국 예약 된 이유는 무엇입니까?) Perl에서는 &lt;b&gt;레이블&lt;/b&gt; 이나 &lt;b&gt;파일 핸들의&lt;/b&gt; 이름을 지정할 수 없습니다 . &amp;ldquo;키워드&amp;rdquo;라고도합니다.</target>
        </trans-unit>
        <trans-unit id="8fdc573142b1f0ebed1c128d43b036415ea32660" translate="yes" xml:space="preserve">
          <source>A word with a specific, built-in meaning to a &lt;b&gt;compiler&lt;/b&gt;, such as &lt;code&gt;if&lt;/code&gt; or &lt;code&gt;delete&lt;/code&gt;. In many languages (not Perl), it&amp;rsquo;s illegal to use reserved words to name anything else. (Which is why they&amp;rsquo;re reserved, after all.) In Perl, you just can&amp;rsquo;t use them to name &lt;b&gt;labels&lt;/b&gt; or &lt;b&gt;filehandles&lt;/b&gt;. Also called &amp;ldquo;keywords&amp;rdquo;.</source>
          <target state="translated">&lt;code&gt;if&lt;/code&gt; 또는 &lt;code&gt;delete&lt;/code&gt; 와 같이 &lt;b&gt;컴파일러&lt;/b&gt; 에 대한 특정 기본 제공 의미를 가진 단어입니다 . Perl이 아닌 많은 언어에서 예약어를 사용하여 다른 이름을 지정하는 것은 불법입니다. (결국 예약 된 이유입니다.) Perl에서는 &lt;b&gt;레이블&lt;/b&gt; 이나 &lt;b&gt;파일 핸들의&lt;/b&gt; 이름을 지정하는 데 사용할 수 없습니다 . &quot;키워드&quot;라고도합니다.&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="435e32d3ce964aedd25193932afab04e1daf13f7" translate="yes" xml:space="preserve">
          <source>A work-around is the following:</source>
          <target state="translated">해결 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="07daf0448b91b826afed53a20124ecc976475c82" translate="yes" xml:space="preserve">
          <source>A workaround for this is to call the constants once in a &lt;code&gt;BEGIN&lt;/code&gt; block:</source>
          <target state="translated">이에 대한 해결 방법은 &lt;code&gt;BEGIN&lt;/code&gt; 블록 에서 상수를 한 번 호출하는 것입니다 .</target>
        </trans-unit>
        <trans-unit id="c5d091eede565087a31db8b62e48d4dd20b23599" translate="yes" xml:space="preserve">
          <source>A working knowledge of XSUB programming is incredibly useful for core hacking; XSUBs use techniques drawn from the PP code, the portion of the guts that actually executes a Perl program. It's a lot gentler to learn those techniques from simple examples and explanation than from the core itself.</source>
          <target state="translated">XSUB 프로그래밍에 대한 실무 지식은 코어 해킹에 매우 유용합니다. XSUB는 실제로 Perl 프로그램을 실행하는 내장 부분 인 PP 코드에서 가져온 기술을 사용합니다. 핵심 자체보다 간단한 예제와 설명을 통해 이러한 기술을 배우는 것이 훨씬 더 순조 롭습니다.</target>
        </trans-unit>
        <trans-unit id="ecdab41b6d91aa8f615325452505a14f3756b711" translate="yes" xml:space="preserve">
          <source>A wrapper around ExtUtils::Install::uninstall(). Warns that uninstallation is deprecated and doesn't actually perform the uninstallation.</source>
          <target state="translated">ExtUtils :: Install :: uninstall ()을 감싸는 래퍼입니다. 제거가 더 이상 사용되지 않으며 실제로 제거를 수행하지 않음을 경고합니다.</target>
        </trans-unit>
        <trans-unit id="779181d83e8b08c1257aaf544b122220cecb13f5" translate="yes" xml:space="preserve">
          <source>A wrapper for &lt;a href=&quot;dbi&quot;&gt;DBI&lt;/a&gt;&lt;code&gt;fetchrow_array&lt;/code&gt; and &lt;code&gt;fetchrow_hashref&lt;/code&gt;</source>
          <target state="translated">&lt;a href=&quot;dbi&quot;&gt;DBI &lt;/a&gt; &lt;code&gt;fetchrow_array&lt;/code&gt; 및 &lt;code&gt;fetchrow_hashref&lt;/code&gt; 의 래퍼</target>
        </trans-unit>
        <trans-unit id="7b1bd466739a9d9dd8c4b1931d422a782c699350" translate="yes" xml:space="preserve">
          <source>A wrapper for &lt;a href=&quot;http://search.cpan.org/perldoc/DBI&quot;&gt;DBI&lt;/a&gt;&lt;code&gt;fetchrow_array&lt;/code&gt; and &lt;code&gt;fetchrow_hashref&lt;/code&gt;</source>
          <target state="translated">&lt;a href=&quot;http://search.cpan.org/perldoc/DBI&quot;&gt;DBI &lt;/a&gt; &lt;code&gt;fetchrow_array&lt;/code&gt; 및 &lt;code&gt;fetchrow_hashref&lt;/code&gt; 의 랩퍼</target>
        </trans-unit>
        <trans-unit id="7aa0ebdb78cb0f32df6917cb0846a920af961e2a" translate="yes" xml:space="preserve">
          <source>A wrapper for the C library &lt;a href=&quot;http://man.he.net/man2/signal&quot;&gt;signal(2)&lt;/a&gt;. Don't use the latter, as the Perl version knows things that interact with the rest of the perl interpreter.</source>
          <target state="translated">C 라이브러리 &lt;a href=&quot;http://man.he.net/man2/signal&quot;&gt;signal (2)에&lt;/a&gt; 대한 래퍼입니다 . Perl 버전은 나머지 perl 인터프리터와 상호 작용하는 것을 알고 있으므로 후자를 사용하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="cd24954e4fcb535256ddd1580f43c63d6ef0dc01" translate="yes" xml:space="preserve">
          <source>A wrapper for the C library &lt;a href=&quot;http://man.he.net/man3/exit&quot;&gt;exit(3)&lt;/a&gt;, honoring what &lt;a href=&quot;perlapi#PL_exit_flags&quot;&gt;&quot;PL_exit_flags&quot; in perlapi&lt;/a&gt; say to do.</source>
          <target state="translated">&lt;a href=&quot;perlapi#PL_exit_flags&quot;&gt;perlapi의 &quot;PL_exit_flags&quot;가하는&lt;/a&gt; 일을 존중 하는 C 라이브러리 &lt;a href=&quot;http://man.he.net/man3/exit&quot;&gt;exit (3)&lt;/a&gt; 의 래퍼입니다 .</target>
        </trans-unit>
        <trans-unit id="3a6acce12e33a751306269659eff02f266708760" translate="yes" xml:space="preserve">
          <source>A wrapper for the C library &lt;a href=&quot;http://man.he.net/man3/setenv&quot;&gt;setenv(3)&lt;/a&gt;. Don't use the latter, as the perl version has desirable safeguards</source>
          <target state="translated">C 라이브러리 &lt;a href=&quot;http://man.he.net/man3/setenv&quot;&gt;setenv (3)에&lt;/a&gt; 대한 래퍼입니다 . Perl 버전에는 바람직한 보호 장치가 있으므로 후자를 사용하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="1d7f5dea12f6359a6636612f15ad99428ef6c1b4" translate="yes" xml:space="preserve">
          <source>A wrapper for the combination of &lt;code&gt;normalize()&lt;/code&gt; and &lt;code&gt;splitOnLastStarter()&lt;/code&gt; . Note that &lt;code&gt;$unprocessed&lt;/code&gt; will be modified as a side-effect.</source>
          <target state="translated">&lt;code&gt;normalize()&lt;/code&gt; 및 &lt;code&gt;splitOnLastStarter()&lt;/code&gt; 의 조합을위한 래퍼입니다 . 참고 &lt;code&gt;$unprocessed&lt;/code&gt; 부작용으로 수정됩니다.</target>
        </trans-unit>
        <trans-unit id="581d4a42c18609254d680720f0843e56fec5a482" translate="yes" xml:space="preserve">
          <source>A wrapper for the combination of &lt;code&gt;normalize()&lt;/code&gt; and &lt;code&gt;splitOnLastStarter()&lt;/code&gt;. Note that &lt;code&gt;$unprocessed&lt;/code&gt; will be modified as a side-effect.</source>
          <target state="translated">&lt;code&gt;normalize()&lt;/code&gt; 및 &lt;code&gt;splitOnLastStarter()&lt;/code&gt; 조합에 대한 래퍼입니다 . 참고 &lt;code&gt;$unprocessed&lt;/code&gt; 부작용으로 수정됩니다.</target>
        </trans-unit>
        <trans-unit id="9a971835f0cc905c4c81e0e15a1789f5da379aa1" translate="yes" xml:space="preserve">
          <source>A wrapper of pack_sockaddr_in() or unpack_sockaddr_in(). In list context, unpacks its argument and returns a list consisting of the port and IP address. In scalar context, packs its port and IP address arguments as a &lt;code&gt;sockaddr_in&lt;/code&gt; and returns it.</source>
          <target state="translated">pack_sockaddr_in () 또는 unpack_sockaddr_in ()의 랩퍼. 목록 컨텍스트에서 인수의 압축을 풀고 포트와 IP 주소로 구성된 목록을 반환합니다. 스칼라 컨텍스트에서 포트 및 IP 주소 인수를 &lt;code&gt;sockaddr_in&lt;/code&gt; 으로 압축하여 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="7da94d0b3d719c597383180b871afe1e809e7e59" translate="yes" xml:space="preserve">
          <source>A wrapper of pack_sockaddr_in6() or unpack_sockaddr_in6(). In list context, unpacks its argument according to unpack_sockaddr_in6(). In scalar context, packs its arguments according to pack_sockaddr_in6().</source>
          <target state="translated">pack_sockaddr_in6 () 또는 unpack_sockaddr_in6 ()의 랩퍼. 목록 컨텍스트에서 unpack_sockaddr_in6 ()에 따라 인수의 압축을 풉니 다. 스칼라 컨텍스트에서 pack_sockaddr_in6 ()에 따라 인수를 압축합니다.</target>
        </trans-unit>
        <trans-unit id="53a1600cfdb74295cdddc3a0923b5ac6c8e36129" translate="yes" xml:space="preserve">
          <source>A wrapper of pack_sockaddr_un() or unpack_sockaddr_un(). In a list context, unpacks its argument and returns a list consisting of the pathname. In a scalar context, packs its pathname as a &lt;code&gt;sockaddr_un&lt;/code&gt; and returns it.</source>
          <target state="translated">pack_sockaddr_un () 또는 unpack_sockaddr_un ()의 랩퍼. 목록 컨텍스트에서 인수의 압축을 풀고 경로 이름으로 구성된 목록을 반환합니다. 스칼라 컨텍스트에서 경로 이름을 &lt;code&gt;sockaddr_un&lt;/code&gt; 으로 압축하여 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="7fe6b1e666d9c00f78d39c2310ecc107997b967e" translate="yes" xml:space="preserve">
          <source>A zero is represented and returned as &lt;code&gt;0E1&lt;/code&gt; , &lt;b&gt;not&lt;/b&gt;&lt;code&gt;0E0&lt;/code&gt; (after Knuth).</source>
          <target state="translated">제로가 대표로 반환 &lt;code&gt;0E1&lt;/code&gt; , &lt;b&gt;하지 &lt;/b&gt; &lt;code&gt;0E0&lt;/code&gt; (누스 후).</target>
        </trans-unit>
        <trans-unit id="779899a127457434de92416389106f3b75e672b1" translate="yes" xml:space="preserve">
          <source>A zero return value of &amp;amp;Time::HiRes::d_hires_stat means that Time::HiRes::stat is a no-op passthrough for CORE::stat() (and likewise for lstat), and therefore the timestamps will stay integers. The same thing will happen if the filesystem does not do subsecond timestamps, even if the &amp;amp;Time::HiRes::d_hires_stat is non-zero.</source>
          <target state="translated">&amp;amp; Time :: HiRes :: d_hires_stat의 리턴 값이 0이면 Time :: HiRes :: stat는 CORE :: stat ()에 대한 no-op 패스 스루이며 lstat에 대해서도 마찬가지이므로 타임 스탬프는 정수로 유지됩니다. &amp;amp; Time :: HiRes :: d_hires_stat가 0이 아닌 경우에도 파일 시스템이 1 초 미만의 타임 스탬프를 수행하지 않는 경우에도 마찬가지입니다.</target>
        </trans-unit>
        <trans-unit id="8e38756e4b48f666771b0184686ead868d8da345" translate="yes" xml:space="preserve">
          <source>A zero-width negative look-ahead assertion. For example &lt;code&gt;/foo(?!bar)/&lt;/code&gt; matches any occurrence of &quot;foo&quot; that isn't followed by &quot;bar&quot;. Note however that look-ahead and look-behind are NOT the same thing. You cannot use this for look-behind.</source>
          <target state="translated">폭이 0 인 마이너스 미리보기 어설 션. 예를 들어 &lt;code&gt;/foo(?!bar)/&lt;/code&gt; 는 &quot;bar&quot;다음에 나오는 &quot;foo&quot;와 일치합니다. 그러나 미리보기와 뒤로보기는 같은 것이 아닙니다. 뒤보기에는 이것을 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="d3ff01c027bf2326d7c975449071a13cc0fdc9c3" translate="yes" xml:space="preserve">
          <source>A zero-width negative look-behind assertion. For example &lt;code&gt;/(?&amp;lt;!bar)foo/&lt;/code&gt; matches any occurrence of &quot;foo&quot; that does not follow &quot;bar&quot;. Works only for fixed-width look-behind.</source>
          <target state="translated">너비가 0 인 음수 룩 어설 션. 예를 들어 &lt;code&gt;/(?&amp;lt;!bar)foo/&lt;/code&gt; 는 &quot;bar&quot;뒤에 오지 않는 &quot;foo&quot;와 일치합니다. 고정 너비 룩백에만 작동합니다.</target>
        </trans-unit>
        <trans-unit id="9ea740ba11b545f6656aa2b6204bfb6a25c281c3" translate="yes" xml:space="preserve">
          <source>A zero-width negative lookahead assertion. For example &lt;code&gt;/foo(?!bar)/&lt;/code&gt; matches any occurrence of &quot;foo&quot; that isn't followed by &quot;bar&quot;. Note however that lookahead and lookbehind are NOT the same thing. You cannot use this for lookbehind.</source>
          <target state="translated">너비가 0 인 부정적인 예측 어설 션입니다. 예를 들어 &lt;code&gt;/foo(?!bar)/&lt;/code&gt; 는 &quot;bar&quot;가 뒤 따르지 않는 &quot;foo&quot;와 일치합니다. 그러나 lookahead와 lookbehind는 같은 것이 아닙니다. Lookbehind에는 이것을 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="4af952bb5746f173cd5ec48d2be9d1fb0c6c2cf0" translate="yes" xml:space="preserve">
          <source>A zero-width negative lookbehind assertion. For example &lt;code&gt;/(?&amp;lt;!bar)foo/&lt;/code&gt; matches any occurrence of &quot;foo&quot; that does not follow &quot;bar&quot;.</source>
          <target state="translated">너비가 0 인 네거티브 lookbehind 어설 션입니다. 예를 들어 &lt;code&gt;/(?&amp;lt;!bar)foo/&lt;/code&gt; 는 &quot;bar&quot;를 따르지 않는 &quot;foo&quot;와 일치합니다.</target>
        </trans-unit>
        <trans-unit id="31c71ae629ab72f59da90b044b041a0f3f38fe68" translate="yes" xml:space="preserve">
          <source>A zero-width positive look-ahead assertion. For example, &lt;code&gt;/\w+(?=\t)/&lt;/code&gt; matches a word followed by a tab, without including the tab in &lt;code&gt;$&amp;amp;&lt;/code&gt; .</source>
          <target state="translated">너비가 0 인 양수의 미리보기 어설 션입니다. 예를 들어, &lt;code&gt;/\w+(?=\t)/&lt;/code&gt; 는 &lt;code&gt;$&amp;amp;&lt;/code&gt; 탭을 포함하지 않고 단어 뒤에 탭이 오는 단어와 일치합니다 .</target>
        </trans-unit>
        <trans-unit id="65fa5c05e8082d01af830ede3afa1f43dd6607a8" translate="yes" xml:space="preserve">
          <source>A zero-width positive look-behind assertion. For example, &lt;code&gt;/(?&amp;lt;=\t)\w+/&lt;/code&gt; matches a word that follows a tab, without including the tab in &lt;code&gt;$&amp;amp;&lt;/code&gt; . Works only for fixed-width look-behind.</source>
          <target state="translated">너비가 0 인 양수 룩 어설 션. 예를 들어, &lt;code&gt;/(?&amp;lt;=\t)\w+/&lt;/code&gt; 는 &lt;code&gt;$&amp;amp;&lt;/code&gt; 탭을 포함시키지 않고 탭 뒤에 나오는 단어와 일치합니다 . 고정 너비 룩백에만 작동합니다.</target>
        </trans-unit>
        <trans-unit id="30b0a1f1290a40ce4c34b1a48caac8b2804ff4f2" translate="yes" xml:space="preserve">
          <source>A zero-width positive lookahead assertion. For example, &lt;code&gt;/\w+(?=\t)/&lt;/code&gt; matches a word followed by a tab, without including the tab in &lt;code&gt;$&amp;amp;&lt;/code&gt;.</source>
          <target state="translated">너비가 0 인 긍정적 예측 어설 션입니다. 예를 들어, &lt;code&gt;/\w+(?=\t)/&lt;/code&gt; 는 &lt;code&gt;$&amp;amp;&lt;/code&gt; 탭을 포함하지 않고 탭이 뒤에 오는 단어와 일치합니다 .</target>
        </trans-unit>
        <trans-unit id="d28325040f8a3f4d54ca2bb7d5a5858383bdcefb" translate="yes" xml:space="preserve">
          <source>A zero-width positive lookbehind assertion. For example, &lt;code&gt;/(?&amp;lt;=\t)\w+/&lt;/code&gt; matches a word that follows a tab, without including the tab in &lt;code&gt;$&amp;amp;&lt;/code&gt;.</source>
          <target state="translated">너비가 0 인 긍정 룩 비하인드 어설 션입니다. 예를 들어 &lt;code&gt;/(?&amp;lt;=\t)\w+/&lt;/code&gt; 는 &lt;code&gt;$&amp;amp;&lt;/code&gt; 탭을 포함하지 않고 탭 뒤에 오는 단어와 일치합니다 .</target>
        </trans-unit>
        <trans-unit id="dc0b9a147f28bb32361995feee47c5144b67bc3c" translate="yes" xml:space="preserve">
          <source>A. Compilation</source>
          <target state="translated">A. 편집</target>
        </trans-unit>
        <trans-unit id="34bdd106971288a6d920c5cf05705981d574d0c4" translate="yes" xml:space="preserve">
          <source>A. DECOMPRESS</source>
          <target state="translated">A. 감압</target>
        </trans-unit>
        <trans-unit id="8cdc3d01fbdde773bb6fbc3d8e1178b07d33f1a6" translate="yes" xml:space="preserve">
          <source>A. Sinan Unur &amp;lt;nanis@cpan.org&amp;gt;</source>
          <target state="translated">A. Sinan Unur &amp;lt;nanis@cpan.org&amp;gt;</target>
        </trans-unit>
        <trans-unit id="1ff759f92b74a05e1658516dbd8457b5a3483f7c" translate="yes" xml:space="preserve">
          <source>ABBREVIATIONS</source>
          <target state="translated">ABBREVIATIONS</target>
        </trans-unit>
        <trans-unit id="673a41f0cf51b17cfeaeef5b1ad0748f98430d4f" translate="yes" xml:space="preserve">
          <source>ABOUT EXTENDING POD</source>
          <target state="translated">포드 확장 정보</target>
        </trans-unit>
        <trans-unit id="dd2cb5069032eb76d119d2ed0164eb2a9e7c70ab" translate="yes" xml:space="preserve">
          <source>ABOUT LANGUAGE TAGS</source>
          <target state="translated">언어 태그 정보</target>
        </trans-unit>
        <trans-unit id="848db58438feb5d786eb1289cbafc6268e9d9307" translate="yes" xml:space="preserve">
          <source>ABOUT LOWERCASING</source>
          <target state="translated">하강에 대하여</target>
        </trans-unit>
        <trans-unit id="0bdf7f8075cb4fb7b28aefb1a128e561b3a0c204" translate="yes" xml:space="preserve">
          <source>ABOUT UNICODE PLAINTEXT LANGUAGE TAGS</source>
          <target state="translated">유니 코드 일반 텍스트 태그 정보</target>
        </trans-unit>
        <trans-unit id="e29c6cbd184a79deb8c1a9f477b3e3ad1f42e851" translate="yes" xml:space="preserve">
          <source>ABSTRACT</source>
          <target state="translated">ABSTRACT</target>
        </trans-unit>
        <trans-unit id="ff2cd7d6f125611b5a0abcf6463bc5622a042c1c" translate="yes" xml:space="preserve">
          <source>ABSTRACT_FROM</source>
          <target state="translated">ABSTRACT_FROM</target>
        </trans-unit>
        <trans-unit id="8e85cf5fbe6cfb533ae13301a76848fd25437a12" translate="yes" xml:space="preserve">
          <source>ACCESS</source>
          <target state="translated">ACCESS</target>
        </trans-unit>
        <trans-unit id="5250769dfb1b93d9576c113491830191c4db1d11" translate="yes" xml:space="preserve">
          <source>ACCESSING ZIP FILES</source>
          <target state="translated">ZIP 파일 액세스</target>
        </trans-unit>
        <trans-unit id="fcc3d0a1b75c8feef5b7b1c653cf0ea340c392c6" translate="yes" xml:space="preserve">
          <source>ACCESSOR METHODS</source>
          <target state="translated">액세서 방법</target>
        </trans-unit>
        <trans-unit id="60a7c20aebd64a886444bdd90a1b11f97a4a1e06" translate="yes" xml:space="preserve">
          <source>ACCESSORS</source>
          <target state="translated">ACCESSORS</target>
        </trans-unit>
        <trans-unit id="0d1e087885abb46b2e3a63da5ea3eb3f1e982bbe" translate="yes" xml:space="preserve">
          <source>ACCURACY AND PRECISION</source>
          <target state="translated">정확성과 정확성</target>
        </trans-unit>
        <trans-unit id="0ba6c220aaa591706073278a9ad280fa2fd653a4" translate="yes" xml:space="preserve">
          <source>ACCURACY and PRECISION</source>
          <target state="translated">정확성과 정밀성</target>
        </trans-unit>
        <trans-unit id="2cdc7ae734b454aa9217c09256c5559e6d697319" translate="yes" xml:space="preserve">
          <source>ACKNOWLEDGEMENTS</source>
          <target state="translated">ACKNOWLEDGEMENTS</target>
        </trans-unit>
        <trans-unit id="923060090571fbfd68775d7a6ad521d2f148ca46" translate="yes" xml:space="preserve">
          <source>ACKNOWLEDGMENTS</source>
          <target state="translated">ACKNOWLEDGMENTS</target>
        </trans-unit>
        <trans-unit id="44d15b33e9bdfa8cf1ced5727e4a50f9110eab0b" translate="yes" xml:space="preserve">
          <source>ADDITIONAL FUNCTIONS</source>
          <target state="translated">추가 기능</target>
        </trans-unit>
        <trans-unit id="377c8694e808f226461dfc561f7463499e97731b" translate="yes" xml:space="preserve">
          <source>ADDITIONAL LIBRARIES</source>
          <target state="translated">추가 라이브러리</target>
        </trans-unit>
        <trans-unit id="97b832ba91bb860f61c453123e346196e469e726" translate="yes" xml:space="preserve">
          <source>ADDR should be &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; unless you really know what you're doing.</source>
          <target state="translated">ADDR은해야 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 당신이 정말 당신이 무슨 일을하는지 알지 못한다.</target>
        </trans-unit>
        <trans-unit id="ec352bbc9125a2290bb41af189c87fa5a48ccde5" translate="yes" xml:space="preserve">
          <source>ADDR should be &lt;code&gt;undef&lt;/code&gt; unless you really know what you're doing.</source>
          <target state="translated">당신이 무엇을하는지 정말로 알지 못한다면 ADDR은 &lt;code&gt;undef&lt;/code&gt; 여야합니다 .</target>
        </trans-unit>
        <trans-unit id="55ecbd212eaf4944bfe6cc43f71cd52a01caf60b" translate="yes" xml:space="preserve">
          <source>ADDRESSES</source>
          <target state="translated">ADDRESSES</target>
        </trans-unit>
        <trans-unit id="64ec98c40972fdf68514c8da070992ffcab12ce8" translate="yes" xml:space="preserve">
          <source>ADVANCED METHODS</source>
          <target state="translated">고급 방법</target>
        </trans-unit>
        <trans-unit id="afb2b77214c93a1bf72d1a922cac35289d58c3c4" translate="yes" xml:space="preserve">
          <source>ADVISORY LOCKING</source>
          <target state="translated">조언 잠금</target>
        </trans-unit>
        <trans-unit id="97e745db372f952a45b14d78a0e017557b75da5f" translate="yes" xml:space="preserve">
          <source>AFS users</source>
          <target state="translated">AFS 사용자</target>
        </trans-unit>
        <trans-unit id="aedfd73052985c2f41211e623add2af653060807" translate="yes" xml:space="preserve">
          <source>AFTER</source>
          <target state="translated">AFTER</target>
        </trans-unit>
        <trans-unit id="496da957ccecd43014881eeb7de2e7be00a8b83f" translate="yes" xml:space="preserve">
          <source>AF_INET, AF_INET6, AF_UNIX, ...</source>
          <target state="translated">AF_INET, AF_INET6, AF_UNIX, ...</target>
        </trans-unit>
        <trans-unit id="38f79606c8b9ff7b459aef84fa34e37fb3f18a07" translate="yes" xml:space="preserve">
          <source>AHHHHHHH!!!! NOT TESTING! Anything but testing! Beat me, whip me, send me to Detroit, but don't make me write tests!</source>
          <target state="translated">AHHHHHHH !!!! 테스트가 아닙니다! 테스트를 제외한 모든 것! 날 때리고, 채찍질하고, 디트로이트로 보내십시오.하지만 시험을 쓰게 만들지는 마세요!</target>
        </trans-unit>
        <trans-unit id="7cd735bc88414abeac25ef102606e6871aeba944" translate="yes" xml:space="preserve">
          <source>AIX</source>
          <target state="translated">AIX</target>
        </trans-unit>
        <trans-unit id="8270308dd6281a640520a3b86d9717dc1578cb66" translate="yes" xml:space="preserve">
          <source>AIX 4.2 and extensions using C++ with statics</source>
          <target state="translated">static과 함께 C ++를 사용하는 AIX 4.2 및 확장</target>
        </trans-unit>
        <trans-unit id="cc22d23e0b7ef1b2efab2cb46a1e42c8fa854e52" translate="yes" xml:space="preserve">
          <source>AIX 5L 5.3 documentation on syslog, &lt;a href=&quot;http://publib.boulder.ibm.com/infocenter/pseries/v5r3/index.jsp?topic=/com.ibm.aix.basetechref/doc/basetrf2/syslog.htm&quot;&gt;http://publib.boulder.ibm.com/infocenter/pseries/v5r3/index.jsp?topic=/com.ibm.aix.basetechref/doc/basetrf2/syslog.htm&lt;/a&gt;</source>
          <target state="translated">syslog에 대한 AIX 5L 5.3 문서, &lt;a href=&quot;http://publib.boulder.ibm.com/infocenter/pseries/v5r3/index.jsp?topic=/com.ibm.aix.basetechref/doc/basetrf2/syslog.htm&quot;&gt;http://publib.boulder.ibm.com/infocenter/pseries/v5r3/index.jsp?topic=/com.ibm.aix.basetechref/doc/basetrf2/syslog.htm&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="bbc183716848102da5675f12c481c22f2bbe872f" translate="yes" xml:space="preserve">
          <source>AIX specific subclass of ExtUtils::MM_Unix</source>
          <target state="translated">ExtUtils :: MM_Unix의 AIX 특정 서브 클래스</target>
        </trans-unit>
        <trans-unit id="b844fff26ef204487899d430c3a31df1b5cc17d0" translate="yes" xml:space="preserve">
          <source>AIX supports dynamically loadable objects as well as shared libraries. Shared libraries by convention end with the suffix .a, which is a bit misleading, as an archive can contain static as well as dynamic members. For Perl dynamically loaded objects we use the .so suffix also used on many other platforms.</source>
          <target state="translated">AIX는 공유 라이브러리뿐만 아니라 동적으로로드 가능한 오브젝트를 지원합니다. 아카이브는 정적 멤버와 동적 멤버를 포함 할 수 있으므로 규칙에 따라 공유 라이브러리는 접미사 .a로 끝납니다. Perl 동적으로로드 된 객체의 경우 다른 플랫폼에서도 사용되는 .so 접미사를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="3537445adaca536cab2a7686d43dc5160e9a6779" translate="yes" xml:space="preserve">
          <source>AI_CANONNAME</source>
          <target state="translated">AI_CANONNAME</target>
        </trans-unit>
        <trans-unit id="4620c46aeacbc229eafc938539c71b493eb24304" translate="yes" xml:space="preserve">
          <source>AI_NUMERICHOST</source>
          <target state="translated">AI_NUMERICHOST</target>
        </trans-unit>
        <trans-unit id="09260387d29750af08963df2cc73f983c3e0f300" translate="yes" xml:space="preserve">
          <source>AI_PASSIVE</source>
          <target state="translated">AI_PASSIVE</target>
        </trans-unit>
        <trans-unit id="c930119fca1aaac13c47275f88a8f54f317dcf6d" translate="yes" xml:space="preserve">
          <source>ALIASES</source>
          <target state="translated">ALIASES</target>
        </trans-unit>
        <trans-unit id="6b42874e3cd20771d93096ec5ce36307a1f2ba14" translate="yes" xml:space="preserve">
          <source>ALL</source>
          <target state="translated">ALL</target>
        </trans-unit>
        <trans-unit id="3311a8d976d7aae7ce8e194719b592e7d83f6ff7" translate="yes" xml:space="preserve">
          <source>ALTERING OR REMOVING EVENTS</source>
          <target state="translated">이벤트 변경 또는 제거</target>
        </trans-unit>
        <trans-unit id="241f8a691bf6294c40554b54ad6e99801b55d29b" translate="yes" xml:space="preserve">
          <source>ALTERNATIVE: It may be desirable to present to the user which features depend on which modules so they can make an informed decision about which recommended modules to install.</source>
          <target state="translated">대안 : 어떤 기능이 어떤 모듈에 의존 하는지를 사용자에게 제시하여 어떤 권장 모듈을 설치할지에 대한 정보에 입각 한 결정을 내릴 수 있도록하는 것이 바람직 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="212ac4dd3c12194a505f91dc67c3c92083d6b847" translate="yes" xml:space="preserve">
          <source>ALTERNATIVES</source>
          <target state="translated">ALTERNATIVES</target>
        </trans-unit>
        <trans-unit id="a4406ec237fefa2186cbfcb898374ca2b35f123f" translate="yes" xml:space="preserve">
          <source>ANCHORS</source>
          <target state="translated">ANCHORS</target>
        </trans-unit>
        <trans-unit id="c2f934cb8cab6c1b3af0d4f2fdd824eabafb6bf4" translate="yes" xml:space="preserve">
          <source>AND</source>
          <target state="translated">AND</target>
        </trans-unit>
        <trans-unit id="f00aef29ec0d70fa98911d7d5c3619473dc02a1d" translate="yes" xml:space="preserve">
          <source>ANOTHER STEP SIDEWAYS</source>
          <target state="translated">다른 단계 옆</target>
        </trans-unit>
        <trans-unit id="dc8b5a685a1f3dfa4a578835317ceecf19e71828" translate="yes" xml:space="preserve">
          <source>ANSI C prototypes</source>
          <target state="translated">ANSI C 프로토 타입</target>
        </trans-unit>
        <trans-unit id="85c85842fa779a9f5e25a53ba642bca5f47b5048" translate="yes" xml:space="preserve">
          <source>ANSI_COLORS_ALIASES</source>
          <target state="translated">ANSI_COLORS_ALIASES</target>
        </trans-unit>
        <trans-unit id="e21a704282760d26b7a89f6a75aa39bcbdea5155" translate="yes" xml:space="preserve">
          <source>ANSI_COLORS_DISABLED</source>
          <target state="translated">ANSI_COLORS_DISABLED</target>
        </trans-unit>
        <trans-unit id="dfbdf15f452a4b9784443e1ff8b670a57ee46040" translate="yes" xml:space="preserve">
          <source>API CHANGES</source>
          <target state="translated">API 변경</target>
        </trans-unit>
        <trans-unit id="4f15dd61e10f028874d8ba2639996e9123298e0e" translate="yes" xml:space="preserve">
          <source>API Listing originally by Dean Roehrich &amp;lt;roehrich@cray.com&amp;gt;.</source>
          <target state="translated">API는 원래 Roeerich &amp;lt;roehrich@cray.com&amp;gt;에 의해 작성되었습니다.</target>
        </trans-unit>
        <trans-unit id="df325db8b77f500b6cdf947d62422aad373e0aea" translate="yes" xml:space="preserve">
          <source>API Methods</source>
          <target state="translated">API 메소드</target>
        </trans-unit>
        <trans-unit id="8454ac15101bc16638e3fcbf0a95ef8d316e2b31" translate="yes" xml:space="preserve">
          <source>API documentation corrected and extended by Peter John Acklam, &amp;lt;pjacklam@online.no&amp;gt;</source>
          <target state="translated">Peter John Acklam이 수정 및 확장 한 API 설명서, &amp;lt;pjacklam@online.no&amp;gt;</target>
        </trans-unit>
        <trans-unit id="277a0cf94bbf499b3b1ef2e01755b635f3035e77" translate="yes" xml:space="preserve">
          <source>API optional methods</source>
          <target state="translated">API 선택적 메소드</target>
        </trans-unit>
        <trans-unit id="9062babed18f073234a690694e7bfa973c074eed" translate="yes" xml:space="preserve">
          <source>API should be understandable by the average programmer</source>
          <target state="translated">API는 일반 프로그래머가 이해할 수 있어야합니다</target>
        </trans-unit>
        <trans-unit id="0dd3839d0c79b29685b54d3a4a1e4fbc6f050c94" translate="yes" xml:space="preserve">
          <source>API version</source>
          <target state="translated">API 버전</target>
        </trans-unit>
        <trans-unit id="a7438834ae98ed5eab86e235ece4b52b96a7675f" translate="yes" xml:space="preserve">
          <source>API version 1</source>
          <target state="translated">API 버전 1</target>
        </trans-unit>
        <trans-unit id="a0960ab95be5d294c9ff103e037a981d112d54d9" translate="yes" xml:space="preserve">
          <source>API version 2</source>
          <target state="translated">API 버전 2</target>
        </trans-unit>
        <trans-unit id="f6db2b825c2703e26c1c6b659f77956e578c5caf" translate="yes" xml:space="preserve">
          <source>ARGS</source>
          <target state="translated">ARGS</target>
        </trans-unit>
        <trans-unit id="d2a8b4f2260ca5da9545853c3c2e9c5c0777a776" translate="yes" xml:space="preserve">
          <source>ARGUMENT</source>
          <target state="translated">ARGUMENT</target>
        </trans-unit>
        <trans-unit id="253fb8ce8cc421dd2ece69eec435a50b11f94cfb" translate="yes" xml:space="preserve">
          <source>ARGUMENTS</source>
          <target state="translated">ARGUMENTS</target>
        </trans-unit>
        <trans-unit id="e34e974046ac7d5ed443828e19c1c6fd0873d9c4" translate="yes" xml:space="preserve">
          <source>ARGUMENTS:</source>
          <target state="translated">ARGUMENTS:</target>
        </trans-unit>
        <trans-unit id="3669288cabd0e6c21385584c21cb897733b8578f" translate="yes" xml:space="preserve">
          <source>ARGV</source>
          <target state="translated">ARGV</target>
        </trans-unit>
        <trans-unit id="58f29c4a3f70f6c5783cb6f812b7570e0f5a35fa" translate="yes" xml:space="preserve">
          <source>ARGVOUT</source>
          <target state="translated">ARGVOUT</target>
        </trans-unit>
        <trans-unit id="3e36d1ca2adf5962801ee67544d6b213480d0743" translate="yes" xml:space="preserve">
          <source>ARRAY</source>
          <target state="translated">ARRAY</target>
        </trans-unit>
        <trans-unit id="394961b04a3b6a1f6d02500eeded58332d3e595d" translate="yes" xml:space="preserve">
          <source>ARRAYREF [</source>
          <target state="translated">ARRAYREF [</target>
        </trans-unit>
        <trans-unit id="fdac805b3b41ae0fbcc577f93532803e87b2d665" translate="yes" xml:space="preserve">
          <source>ARRAYREF]</source>
          <target state="translated">ARRAYREF]</target>
        </trans-unit>
        <trans-unit id="939f4f9b79e0d63ec8eb10a421a9e30ccdc8ba12" translate="yes" xml:space="preserve">
          <source>ARRAYS OF ARRAYS</source>
          <target state="translated">배열의 배열</target>
        </trans-unit>
        <trans-unit id="a25c873f10f6ead60f25f2f80304660b76114969" translate="yes" xml:space="preserve">
          <source>ARRAYS OF HASHES</source>
          <target state="translated">해시의 배열</target>
        </trans-unit>
        <trans-unit id="33001c4a5e6064950ba3947c2ff95e716a4daff7" translate="yes" xml:space="preserve">
          <source>ARRAYelt</source>
          <target state="translated">ARRAYelt</target>
        </trans-unit>
        <trans-unit id="3a850a34d309cd690354487cdf0537837ddb2c56" translate="yes" xml:space="preserve">
          <source>AS FUNCTIONS</source>
          <target state="translated">기능으로</target>
        </trans-unit>
        <trans-unit id="62deab43d3dc43d1e1820db6e88541fd9e1d178d" translate="yes" xml:space="preserve">
          <source>AS METHODS</source>
          <target state="translated">방법으로</target>
        </trans-unit>
        <trans-unit id="54523fd188916df915063049c7391f98e0ecb17d" translate="yes" xml:space="preserve">
          <source>AS/400 Perl information at &lt;a href=&quot;http://as400.rochester.ibm.com/&quot;&gt;http://as400.rochester.ibm.com/&lt;/a&gt; as well as on CPAN in the</source>
          <target state="translated">&lt;a href=&quot;http://as400.rochester.ibm.com/&quot;&gt;http://as400.rochester.ibm.com/의&lt;/a&gt; AS / 400 Perl 정보 및 CPAN의</target>
        </trans-unit>
        <trans-unit id="94090230b1f8c256f7ac5dc5a70bd3b20ee4ff15" translate="yes" xml:space="preserve">
          <source>ASCII</source>
          <target state="translated">ASCII</target>
        </trans-unit>
        <trans-unit id="095009cc6353c09fd2d522eaac28b52d2906738f" translate="yes" xml:space="preserve">
          <source>ASCII Rules versus Unicode Rules</source>
          <target state="translated">ASCII 규칙과 유니 코드 규칙</target>
        </trans-unit>
        <trans-unit id="05b06e21b242818c80ba48f1806ad24f7869b69b" translate="yes" xml:space="preserve">
          <source>ASCII is a 7 bit encoding, but bytes have 8 bits in them. The 128 extra characters have different meanings depending on the locale. Absent a locale, currently these extra characters are generally considered to be unassigned, and this has presented some problems. This has being changed starting in 5.12 so that these characters can be considered to be Latin-1 (ISO-8859-1).</source>
          <target state="translated">ASCII는 7 비트 인코딩이지만 바이트는 8 비트입니다. 128 개의 추가 문자는 로케일에 따라 다른 의미를 갖습니다. 로케일이 없으면 현재 이러한 추가 문자는 일반적으로 할당되지 않은 것으로 간주되며 몇 가지 문제가 있습니다. 이 문자는 라틴어 (ISO-8859-1)로 간주 될 수 있도록 5.12부터 변경되었습니다.</target>
        </trans-unit>
        <trans-unit id="d77e7b08ca6fa993505fba8c81b3ac5f801abc6f" translate="yes" xml:space="preserve">
          <source>ASCII rules are used for the case change. The lowercase of any character outside the ASCII range is the character itself.</source>
          <target state="translated">ASCII 규칙은 대소 문자 변경에 사용됩니다. ASCII 범위를 벗어난 문자의 소문자는 문자 자체입니다.</target>
        </trans-unit>
        <trans-unit id="2265708eb994626faa95764187a1c4bc94aeb6df" translate="yes" xml:space="preserve">
          <source>ASCII_TO_NEED</source>
          <target state="translated">ASCII_TO_NEED</target>
        </trans-unit>
        <trans-unit id="933aa69818a860a8e89d214ed12386c4c9be9be4" translate="yes" xml:space="preserve">
          <source>AT&amp;amp;T 3b1</source>
          <target state="translated">AT&amp;amp;T 3b1</target>
        </trans-unit>
        <trans-unit id="4fb35c7230a646597450a190cacb284a7107da13" translate="yes" xml:space="preserve">
          <source>ATTRIBUTES</source>
          <target state="translated">ATTRIBUTES</target>
        </trans-unit>
        <trans-unit id="ece7d85b8cf901827daa3241607fc8b13d846059" translate="yes" xml:space="preserve">
          <source>ATTRIBUTION</source>
          <target state="translated">ATTRIBUTION</target>
        </trans-unit>
        <trans-unit id="8b61f8355a2ccf4ace40fd469d2de5233617a66b" translate="yes" xml:space="preserve">
          <source>AUTHOR</source>
          <target state="translated">AUTHOR</target>
        </trans-unit>
        <trans-unit id="57dab403a72cbeaee26142a3b342afaf3f988255" translate="yes" xml:space="preserve">
          <source>AUTHOR AND COPYRIGHT</source>
          <target state="translated">저자와 저작권</target>
        </trans-unit>
        <trans-unit id="612f07ef18eeaf3398b36342703c907f1f498930" translate="yes" xml:space="preserve">
          <source>AUTHOR and COPYRIGHT</source>
          <target state="translated">저자와 저작권</target>
        </trans-unit>
        <trans-unit id="d5195f9e1e4e9d40c97901347bc70f8c519bf1be" translate="yes" xml:space="preserve">
          <source>AUTHOR, COPYRIGHT AND LICENSE</source>
          <target state="translated">저자, 저작권 및 라이센스</target>
        </trans-unit>
        <trans-unit id="41d9cfc9cdf402f68e3f8ff8a8e41c4254e5f24e" translate="yes" xml:space="preserve">
          <source>AUTHOR, COPYRIGHT, AND LICENSE</source>
          <target state="translated">저자, 저작권 및 라이센스</target>
        </trans-unit>
        <trans-unit id="dad57a4c245a8007c90257aef0514c8b6a0f600c" translate="yes" xml:space="preserve">
          <source>AUTHORS</source>
          <target state="translated">AUTHORS</target>
        </trans-unit>
        <trans-unit id="10ca6d2dbfbe263ce3d2447e713540dbee649dd1" translate="yes" xml:space="preserve">
          <source>AUTHORS &amp;amp; ACKNOWLEDGEMENTS</source>
          <target state="translated">저자 및 승인</target>
        </trans-unit>
        <trans-unit id="85e022793224f31daf1d3314f296447a1c347850" translate="yes" xml:space="preserve">
          <source>AUTHORS / CONTRIBUTORS</source>
          <target state="translated">저자 / 참가자</target>
        </trans-unit>
        <trans-unit id="14d07abb959cf3e3fd8f53cf02fd844e461b3f7b" translate="yes" xml:space="preserve">
          <source>AUTHORS AND CONTRIBUTORS</source>
          <target state="translated">저자 및 기여자</target>
        </trans-unit>
        <trans-unit id="36cf502fc37ab4d36ef92580de3d24ac259c8d44" translate="yes" xml:space="preserve">
          <source>AUTHORS EMERITUS</source>
          <target state="translated">저자 EMERITUS</target>
        </trans-unit>
        <trans-unit id="4a70fded9361d1a1ecef0893e232626c6b2b54fd" translate="yes" xml:space="preserve">
          <source>AUTHORS, CONTRIBUTORS AND REVIEWERS</source>
          <target state="translated">저자, 기고자 및 검토 자</target>
        </trans-unit>
        <trans-unit id="a7c000e8a87845b58cc629ac11fab313f86076cc" translate="yes" xml:space="preserve">
          <source>AUTO LEXICONS</source>
          <target state="translated">자동 사전</target>
        </trans-unit>
        <trans-unit id="ba657d4270e0ee84198dc3f12f7f53cb0c332d2f" translate="yes" xml:space="preserve">
          <source>AUTOLOAD</source>
          <target state="translated">AUTOLOAD</target>
        </trans-unit>
        <trans-unit id="43af5166b3e71bcdd670318e774158ceaf10a942" translate="yes" xml:space="preserve">
          <source>AUTOLOADER</source>
          <target state="translated">AUTOLOADER</target>
        </trans-unit>
        <trans-unit id="886a23f1067d5ffd81046b592349f27bd44a8216" translate="yes" xml:space="preserve">
          <source>AUTOLOADed Constants</source>
          <target state="translated">자동로드 상수</target>
        </trans-unit>
        <trans-unit id="6ed729d5c732a41eb08d03f6337c79a35aa1083c" translate="yes" xml:space="preserve">
          <source>AUX</source>
          <target state="translated">AUX</target>
        </trans-unit>
        <trans-unit id="20ab2d9088d2ab458d63ed3bd729fda9297db5a4" translate="yes" xml:space="preserve">
          <source>AV</source>
          <target state="translated">AV</target>
        </trans-unit>
        <trans-unit id="68570adadeeae5fdaad94d20b4200b8cf0e0c4f0" translate="yes" xml:space="preserve">
          <source>AVAILABILITY</source>
          <target state="translated">AVAILABILITY</target>
        </trans-unit>
        <trans-unit id="9669bc4871af0ed7e9d16166bb30c227929eda52" translate="yes" xml:space="preserve">
          <source>AVAILABLE FEATURES</source>
          <target state="translated">사용 가능한 기능</target>
        </trans-unit>
        <trans-unit id="302ba7dc5c280998e54c1d7ee821e9c0c27afd54" translate="yes" xml:space="preserve">
          <source>AVs and HVs are more complicated, but SVs are by far the most common variable type being thrown around. Having seen something of how we manipulate these, let's go on and look at how the op tree is constructed.</source>
          <target state="translated">AV와 HV는 더 복잡하지만 SV는 가장 일반적인 변수 유형입니다. 우리가 이것들을 어떻게 조작하는지 보았으니 op 트리가 어떻게 구성되는지 봅시다.</target>
        </trans-unit>
        <trans-unit id="97658a3aca1866999e545fb8e0d412280826a4d3" translate="yes" xml:space="preserve">
          <source>AVs, HVs and undefined values</source>
          <target state="translated">AV, HV 및 정의되지 않은 값</target>
        </trans-unit>
        <trans-unit id="0938888fe01a59a31e6903705824b94517ab98d0" translate="yes" xml:space="preserve">
          <source>Abandon the tmp in the current pad at offset &lt;code&gt;po&lt;/code&gt; and replace with a new one.</source>
          <target state="translated">오프셋 &lt;code&gt;po&lt;/code&gt; 에서 현재 패드의 tmp를 버리고 새 것으로 교체하십시오.</target>
        </trans-unit>
        <trans-unit id="1ca83b983f42527b4fed4dd004cb7ec8d4f4a6f6" translate="yes" xml:space="preserve">
          <source>Abandon the tmp in the current pad at offset po and replace with a new one.</source>
          <target state="translated">오프셋 po에서 현재 패드의 tmp를 버리고 새로운 것으로 바꿉니다.</target>
        </trans-unit>
        <trans-unit id="57c67b6004d41befa99fa526f57a6625af549efe" translate="yes" xml:space="preserve">
          <source>Abbrev - create an abbreviation table from a list</source>
          <target state="translated">Abbrev-목록에서 약어 테이블 만들기</target>
        </trans-unit>
        <trans-unit id="807c421ac798eb9fc0d4cfcfce62f4a8d8412f16" translate="yes" xml:space="preserve">
          <source>Abc-shell can also launch programs via the #! syntax at the start of the program file, it's best use the form #!SDK:Local/C/perl so that the AmigaOS shell may also find perl in the same way. AmigaOS requires the script bit to be set for this to work</source>
          <target state="translated">Abc-shell은 #! 프로그램 파일의 시작 부분에서 구문을 사용하려면 #! SDK : Local / C / perl 형식을 사용하는 것이 가장 좋습니다. 그러면 AmigaOS 셸도 동일한 방식으로 perl을 찾을 수 있습니다. AmigaOS가 작동하려면 스크립트 비트를 설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="b58dff4b5e1845452d9882830cd3982aa792f290" translate="yes" xml:space="preserve">
          <source>Abigail &amp;lt;abigail@abigail.be&amp;gt;, Charles Bailey &amp;lt;bailey@newman.upenn.edu&amp;gt;, Graham Barr &amp;lt;gbarr@pobox.com&amp;gt;, Tom Christiansen &amp;lt;tchrist@perl.com&amp;gt;, Nicholas Clark &amp;lt;nick@ccl4.org&amp;gt;, Thomas Dorner &amp;lt;Thomas.Dorner@start.de&amp;gt;, Andy Dougherty &amp;lt;doughera@lafayette.edu&amp;gt;, Dominic Dunlop &amp;lt;domo@computer.org&amp;gt;, Neale Ferguson &amp;lt;neale@vma.tabnsw.com.au&amp;gt;, David J. Fiander &amp;lt;davidf@mks.com&amp;gt;, Paul Green &amp;lt;Paul.Green@stratus.com&amp;gt;, M.J.T. Guy &amp;lt;mjtg@cam.ac.uk&amp;gt;, Jarkko Hietaniemi &amp;lt;jhi@iki.fi&amp;gt;, Luther Huffman &amp;lt;lutherh@stratcom.com&amp;gt;, Nick Ing-Simmons &amp;lt;nick@ing-simmons.net&amp;gt;, Andreas J. K&amp;ouml;nig &amp;lt;a.koenig@mind.de&amp;gt;, Markus Laker &amp;lt;mlaker@contax.co.uk&amp;gt;, Andrew M. Langmead &amp;lt;aml@world.std.com&amp;gt;, Lukas Mai &amp;lt;l.mai@web.de&amp;gt;, Larry Moore &amp;lt;ljmoore@freespace.net&amp;gt;, Paul Moore &amp;lt;Paul.Moore@uk.origin-it.com&amp;gt;, Chris Nandor &amp;lt;pudge@pobox.com&amp;gt;, Matthias Neeracher &amp;lt;neeracher@mac.com&amp;gt;, Philip Newton &amp;lt;pne@cpan.org&amp;gt;, Gary Ng &amp;lt;71564.1743@CompuServe.COM&amp;gt;, Tom Phoenix &amp;lt;rootbeer@teleport.com&amp;gt;, Andr&amp;eacute; Pirard &amp;lt;A.Pirard@ulg.ac.be&amp;gt;, Peter Prymmer &amp;lt;pvhp@forte.com&amp;gt;, Hugo van der Sanden &amp;lt;hv@crypt0.demon.co.uk&amp;gt;, Gurusamy Sarathy &amp;lt;gsar@activestate.com&amp;gt;, Paul J. Schinder &amp;lt;schinder@pobox.com&amp;gt;, Michael G Schwern &amp;lt;schwern@pobox.com&amp;gt;, Dan Sugalski &amp;lt;dan@sidhe.org&amp;gt;, Nathan Torkington &amp;lt;gnat@frii.com&amp;gt;, John Malmberg &amp;lt;wb8tyw@qsl.net&amp;gt;</source>
          <target state="translated">Abigail &amp;lt;abigail@abigail.be&amp;gt;, Charles Bailey &amp;lt;bailey@newman.upenn.edu&amp;gt;, Graham Barr &amp;lt;gbarr@pobox.com&amp;gt;, Tom Christiansen &amp;lt;tchrist@perl.com&amp;gt;, Nicholas Clark &amp;lt;nick@ccl4.org&amp;gt; , Thomas Dorner &amp;lt;Thomas.Dorner@start.de&amp;gt;, Andy Dougherty &amp;lt;doughera@lafayette.edu&amp;gt;, Dominic Dunlop &amp;lt;domo@computer.org&amp;gt;, Neale Ferguson &amp;lt;neale@vma.tabnsw.com.au&amp;gt;, David J. Fiander &amp;lt;davidf@mks.com&amp;gt;, Paul Green &amp;lt;Paul.Green@stratus.com&amp;gt;, MJT Guy &amp;lt;mjtg@cam.ac.uk&amp;gt;, Jarkko Hietaniemi &amp;lt;jhi@iki.fi&amp;gt;, Luther Huffman &amp;lt;lutherh @ stratcom. com&amp;gt;, Nick Ing-Simmons &amp;lt;nick@ing-simmons.net&amp;gt;, Andreas J. K&amp;ouml;nig &amp;lt;a.koenig@mind.de&amp;gt;, Markus Laker &amp;lt;mlaker@contax.co.uk&amp;gt;, Andrew M. Langmead &amp;lt;aml @ world.std.com&amp;gt;, Lukas Mai &amp;lt;l.mai@web.de&amp;gt;, Larry Moore &amp;lt;ljmoore@freespace.net&amp;gt;, Paul Moore &amp;lt;Paul.Moore@uk.origin-it.com&amp;gt;, Chris Nandor &amp;lt;pudge@pobox.com&amp;gt;, Matthias Neeracher &amp;lt;neeracher@mac.com&amp;gt;, Philip Newton &amp;lt;pne@cpan.org&amp;gt;, Gary Ng &amp;lt;71564.1743@CompuServe.COM&amp;gt; , Tom Phoenix &amp;lt;rootbeer@teleport.com&amp;gt;, Andr&amp;eacute; Pirard &amp;lt;A.Pirard@ulg.ac.be&amp;gt;, Peter Prymmer &amp;lt;pvhp@forte.com&amp;gt;, Hugo van der Sanden &amp;lt;hv@crypt0.demon.co.uk&amp;gt; , Gurusamy Sarathy &amp;lt;gsar@activestate.com&amp;gt;, Paul J. Schinder &amp;lt;schinder@pobox.com&amp;gt;, Michael G Schwern &amp;lt;schwern@pobox.com&amp;gt;, Dan Sugalski &amp;lt;dan@sidhe.org&amp;gt;, Nathan Torkington &amp;lt;gnat @ frii .com&amp;gt;, John Malmberg &amp;lt;wb8tyw@qsl.net&amp;gt;Andr&amp;eacute; Pirard &amp;lt;A.Pirard@ulg.ac.be&amp;gt;, Peter Prymmer &amp;lt;pvhp@forte.com&amp;gt;, Hugo van der Sanden &amp;lt;hv@crypt0.demon.co.uk&amp;gt;, Gurusamy Sarathy &amp;lt;gsar@activestate.com&amp;gt;, Paul J. Schinder &amp;lt;schinder@pobox.com&amp;gt;, Michael G Schwern &amp;lt;schwern@pobox.com&amp;gt;, Dan Sugalski &amp;lt;dan@sidhe.org&amp;gt;, Nathan Torkington &amp;lt;gnat@frii.com&amp;gt;, John Malmberg &amp;lt;wb8tyw @ qsl. net&amp;gt;Andr&amp;eacute; Pirard &amp;lt;A.Pirard@ulg.ac.be&amp;gt;, Peter Prymmer &amp;lt;pvhp@forte.com&amp;gt;, Hugo van der Sanden &amp;lt;hv@crypt0.demon.co.uk&amp;gt;, Gurusamy Sarathy &amp;lt;gsar@activestate.com&amp;gt;, Paul J. Schinder &amp;lt;schinder@pobox.com&amp;gt;, Michael G Schwern &amp;lt;schwern@pobox.com&amp;gt;, Dan Sugalski &amp;lt;dan@sidhe.org&amp;gt;, Nathan Torkington &amp;lt;gnat@frii.com&amp;gt;, John Malmberg &amp;lt;wb8tyw @ qsl. net&amp;gt;</target>
        </trans-unit>
        <trans-unit id="953787278f84160153e00df3d74bff332f0acc7b" translate="yes" xml:space="preserve">
          <source>Abigail &amp;lt;abigail@foad.org&amp;gt;, Charles Bailey &amp;lt;bailey@newman.upenn.edu&amp;gt;, Graham Barr &amp;lt;gbarr@pobox.com&amp;gt;, Tom Christiansen &amp;lt;tchrist@perl.com&amp;gt;, Nicholas Clark &amp;lt;nick@ccl4.org&amp;gt;, Thomas Dorner &amp;lt;Thomas.Dorner@start.de&amp;gt;, Andy Dougherty &amp;lt;doughera@lafayette.edu&amp;gt;, Dominic Dunlop &amp;lt;domo@computer.org&amp;gt;, Neale Ferguson &amp;lt;neale@vma.tabnsw.com.au&amp;gt;, David J. Fiander &amp;lt;davidf@mks.com&amp;gt;, Paul Green &amp;lt;Paul.Green@stratus.com&amp;gt;, M.J.T. Guy &amp;lt;mjtg@cam.ac.uk&amp;gt;, Jarkko Hietaniemi &amp;lt;jhi@iki.fi&amp;gt;, Luther Huffman &amp;lt;lutherh@stratcom.com&amp;gt;, Nick Ing-Simmons &amp;lt;nick@ing-simmons.net&amp;gt;, Andreas J. K&amp;ouml;nig &amp;lt;a.koenig@mind.de&amp;gt;, Markus Laker &amp;lt;mlaker@contax.co.uk&amp;gt;, Andrew M. Langmead &amp;lt;aml@world.std.com&amp;gt;, Larry Moore &amp;lt;ljmoore@freespace.net&amp;gt;, Paul Moore &amp;lt;Paul.Moore@uk.origin-it.com&amp;gt;, Chris Nandor &amp;lt;pudge@pobox.com&amp;gt;, Matthias Neeracher &amp;lt;neeracher@mac.com&amp;gt;, Philip Newton &amp;lt;pne@cpan.org&amp;gt;, Gary Ng &amp;lt;71564.1743@CompuServe.COM&amp;gt;, Tom Phoenix &amp;lt;rootbeer@teleport.com&amp;gt;, Andr&amp;eacute; Pirard &amp;lt;A.Pirard@ulg.ac.be&amp;gt;, Peter Prymmer &amp;lt;pvhp@forte.com&amp;gt;, Hugo van der Sanden &amp;lt;hv@crypt0.demon.co.uk&amp;gt;, Gurusamy Sarathy &amp;lt;gsar@activestate.com&amp;gt;, Paul J. Schinder &amp;lt;schinder@pobox.com&amp;gt;, Michael G Schwern &amp;lt;schwern@pobox.com&amp;gt;, Dan Sugalski &amp;lt;dan@sidhe.org&amp;gt;, Nathan Torkington &amp;lt;gnat@frii.com&amp;gt;, John Malmberg &amp;lt;wb8tyw@qsl.net&amp;gt;</source>
          <target state="translated">Abigail &amp;lt;abigail@foad.org&amp;gt;, Charles Bailey &amp;lt;bailey@newman.upenn.edu&amp;gt;, Graham Barr &amp;lt;gbarr@pobox.com&amp;gt;, Tom Christiansen &amp;lt;tchrist@perl.com&amp;gt;, Nicholas Clark &amp;lt;nick@ccl4.org&amp;gt; , Thomas Dorner &amp;lt;Thomas.Dorner@start.de&amp;gt;, Andy Dougherty &amp;lt;doughera@lafayette.edu&amp;gt;, Dominic Dunlop &amp;lt;domo@computer.org&amp;gt;, Neale Ferguson &amp;lt;neale@vma.tabnsw.com.au&amp;gt;, David J. Fiander &amp;lt;davidf@mks.com&amp;gt;, Paul Green &amp;lt;Paul.Green@stratus.com&amp;gt;, MJT Guy &amp;lt;mjtg@cam.ac.uk&amp;gt;, Jarkko Hietaniemi &amp;lt;jhi@iki.fi&amp;gt;, Luther Huffman &amp;lt;lutherh @ stratcom. com&amp;gt;, Nick Ing-Simmons &amp;lt;nick@ing-simmons.net&amp;gt;, Andreas J. K&amp;ouml;nig &amp;lt;a.koenig@mind.de&amp;gt;, Markus Laker &amp;lt;mlaker@contax.co.uk&amp;gt;, Andrew M. Langmead &amp;lt;aml @ world.std.com&amp;gt;, Larry Moore &amp;lt;ljmoore@freespace.net&amp;gt;, Paul Moore &amp;lt;Paul.Moore@uk.origin-it.com&amp;gt;,Chris Nandor &amp;lt;pudge@pobox.com&amp;gt;, Matthias Neeracher &amp;lt;neeracher@mac.com&amp;gt;, Philip Newton &amp;lt;pne@cpan.org&amp;gt;, Gary Ng &amp;lt;71564.1743@CompuServe.COM&amp;gt;, Tom Phoenix &amp;lt;rootbeer@teleport.com&amp;gt;, Andr&amp;eacute; Pirard &amp;lt;A.Pirard@ulg.ac.be&amp;gt;, Peter Prymmer &amp;lt;pvhp@forte.com&amp;gt;, Hugo van der Sanden &amp;lt;hv@crypt0.demon.co.uk&amp;gt;, Gurusamy Sarathy &amp;lt;gsar@activestate.com&amp;gt;, Paul J. Schinder &amp;lt;schinder@pobox.com&amp;gt;, Michael G Schwern &amp;lt;schwern@pobox.com&amp;gt;, Dan Sugalski &amp;lt;dan@sidhe.org&amp;gt;, Nathan Torkington &amp;lt;gnat@frii.com&amp;gt;, John Malmberg &amp;lt;wb8tyw @ qsl. 넷&amp;gt;com&amp;gt;, Hugo van der Sanden &amp;lt;hv@crypt0.demon.co.uk&amp;gt;, Gurusamy Sarathy &amp;lt;gsar@activestate.com&amp;gt;, Paul J. Schinder &amp;lt;schinder@pobox.com&amp;gt;, Michael G Schwern &amp;lt;schwern@pobox.com &amp;gt;, Dan Sugalski &amp;lt;dan@sidhe.org&amp;gt;, Nathan Torkington &amp;lt;gnat@frii.com&amp;gt;, John Malmberg &amp;lt;wb8tyw@qsl.net&amp;gt;com&amp;gt;, Hugo van der Sanden &amp;lt;hv@crypt0.demon.co.uk&amp;gt;, Gurusamy Sarathy &amp;lt;gsar@activestate.com&amp;gt;, Paul J. Schinder &amp;lt;schinder@pobox.com&amp;gt;, Michael G Schwern &amp;lt;schwern@pobox.com &amp;gt;, Dan Sugalski &amp;lt;dan@sidhe.org&amp;gt;, Nathan Torkington &amp;lt;gnat@frii.com&amp;gt;, John Malmberg &amp;lt;wb8tyw@qsl.net&amp;gt;</target>
        </trans-unit>
        <trans-unit id="272ef4d46b3c0dabd3e502b3dc11c532d79932f2" translate="yes" xml:space="preserve">
          <source>Able to serve as an &lt;b&gt;lvalue&lt;/b&gt;.</source>
          <target state="translated">int로서 역할을 할 수 &lt;b&gt;좌변&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="a3f9c8141ea275b67bac5cb6c2da96e6b983db25" translate="yes" xml:space="preserve">
          <source>Abort the current data transfer.</source>
          <target state="translated">현재 데이터 전송을 중단하십시오.</target>
        </trans-unit>
        <trans-unit id="ef50c92d523e6a7f82af2cdf35a1ad71804df1e4" translate="yes" xml:space="preserve">
          <source>Aborts a system shutdown (started by the InitiateSystemShutdown function) on the specified MACHINE.</source>
          <target state="translated">지정된 MACHINE에서 시스템 종료 (InitiateSystemShutdown 함수에 의해 시작됨)를 중단합니다.</target>
        </trans-unit>
        <trans-unit id="f7989aafbbb3a9f050ae7d85ebd582349680eb97" translate="yes" xml:space="preserve">
          <source>About =over...=back Regions</source>
          <target state="translated">= over ... = 뒤 지역</target>
        </trans-unit>
        <trans-unit id="5766587271d36ba046e7fb9efb21f9b7e662efb7" translate="yes" xml:space="preserve">
          <source>About Compiler Versions of Irix</source>
          <target state="translated">컴파일러 버전의 Irix 정보</target>
        </trans-unit>
        <trans-unit id="bcf14899785f94972e5296a53e65daa2fad1f95c" translate="yes" xml:space="preserve">
          <source>About Data Paragraphs and &quot;=begin/=end&quot; Regions</source>
          <target state="translated">데이터 단락 및 &quot;= 시작 / = 종료&quot;영역 정보</target>
        </trans-unit>
        <trans-unit id="f134fee2fd6f61ab2515d5dfb15b7bc4b2f583f5" translate="yes" xml:space="preserve">
          <source>About L&amp;lt;...&amp;gt; Codes</source>
          <target state="translated">L &amp;lt;...&amp;gt; 코드 정보</target>
        </trans-unit>
        <trans-unit id="e5cab81ecabd091128b2d7c9329cceb43c780d87" translate="yes" xml:space="preserve">
          <source>About Perl</source>
          <target state="translated">Perl에 대해</target>
        </trans-unit>
        <trans-unit id="20348f0cd91058ac758340303c3ce91495980768" translate="yes" xml:space="preserve">
          <source>About filehandles</source>
          <target state="translated">파일 핸들 정보</target>
        </trans-unit>
        <trans-unit id="2bb268c52f27a73602478b866c73dabd9577e8f6" translate="yes" xml:space="preserve">
          <source>About modes</source>
          <target state="translated">모드 정보</target>
        </trans-unit>
        <trans-unit id="027e45f66497afa47c6fd09d682b0e1e7a6cedb2" translate="yes" xml:space="preserve">
          <source>Above the optimizer section is the list of</source>
          <target state="translated">최적화 섹션 위에는</target>
        </trans-unit>
        <trans-unit id="6d3fc598c606132c619a12609173fe6e49201e22" translate="yes" xml:space="preserve">
          <source>Absolute referencing</source>
          <target state="translated">절대 참조</target>
        </trans-unit>
        <trans-unit id="d79da395b5d7a09c6439a5f2660d8c568186ab7e" translate="yes" xml:space="preserve">
          <source>Abstract</source>
          <target state="translated">Abstract</target>
        </trans-unit>
        <trans-unit id="fd1c863c80384ee83334b3b3ad71ce0af37947bc" translate="yes" xml:space="preserve">
          <source>Abstract base class for harness output delegate</source>
          <target state="translated">하네스 출력 델리게이트의 추상 기본 클래스</target>
        </trans-unit>
        <trans-unit id="fc6cd410f445b57f3e0f74f4d7cfaf1d465c09ec" translate="yes" xml:space="preserve">
          <source>Abstract method</source>
          <target state="translated">추상 방법</target>
        </trans-unit>
        <trans-unit id="3782c0ad3a39a0cddf59f8a4587a6ac1e53f9c97" translate="yes" xml:space="preserve">
          <source>Acceptance of these code points is a Perl extension, and you should expect that nothing other than Perl can handle them; Perl itself on EBCDIC platforms before v5.24 does not handle them.</source>
          <target state="translated">이러한 코드 포인트를 받아들이는 것은 Perl 확장이며 Perl 외에는 아무것도 처리 할 수 ​​없습니다. v5.24 이전의 EBCDIC 플랫폼에서 Perl 자체는이를 처리하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="becdf5f42e43b7273698e72d5f4213f7c0a68cc4" translate="yes" xml:space="preserve">
          <source>Accepted before Perl 5.20.0. The Socket library is now primarily maintained on CPAN, rather than in the perl core.</source>
          <target state="translated">Perl 5.20.0 이전에 허용되었습니다. 소켓 라이브러리는 이제 주로 펄 코어가 아닌 CPAN에서 유지 보수됩니다.</target>
        </trans-unit>
        <trans-unit id="4dd1bc893614ac8f9bec65c912481578e5103c07" translate="yes" xml:space="preserve">
          <source>Accepted features</source>
          <target state="translated">허용되는 기능</target>
        </trans-unit>
        <trans-unit id="56a28ff20a71c3e8ac9c196f290eef557747b624" translate="yes" xml:space="preserve">
          <source>Accepted in Perl 5.20.0</source>
          <target state="translated">Perl 5.20.0에서 허용</target>
        </trans-unit>
        <trans-unit id="1576bf43d8822dbdd55b1f1ab39311d28be28187" translate="yes" xml:space="preserve">
          <source>Accepted in Perl 5.22.0</source>
          <target state="translated">Perl 5.22.0에서 허용</target>
        </trans-unit>
        <trans-unit id="675dec52d56b1b7035fe24d4e72f28a346a787af" translate="yes" xml:space="preserve">
          <source>Accepted in Perl 5.8.0</source>
          <target state="translated">Perl 5.8.0에서 허용</target>
        </trans-unit>
        <trans-unit id="90c2a9a8eb85f455955167b397c89e9d89539a74" translate="yes" xml:space="preserve">
          <source>Accepted in Perl 5.8.1</source>
          <target state="translated">Perl 5.8.1에서 허용</target>
        </trans-unit>
        <trans-unit id="8a68651daaebc69bcbc1b07f1e106b12188deb49" translate="yes" xml:space="preserve">
          <source>Accepting a patch</source>
          <target state="translated">패치 수락</target>
        </trans-unit>
        <trans-unit id="ad21c5596b645ba9637173674a45823b09fa37af" translate="yes" xml:space="preserve">
          <source>Accepts a hashref with the following key/value pairs:</source>
          <target state="translated">다음 키 / 값 쌍으로 해시 참조를 허용합니다.</target>
        </trans-unit>
        <trans-unit id="3cab88715458f5eb0aafb0a8b41682d6e4711e8a" translate="yes" xml:space="preserve">
          <source>Accepts a scalar value or array ref of scalar values indicating which paths to allowed libraries should be included if Perl tests are executed. Naturally, this only makes sense in the context of tests written in Perl.</source>
          <target state="translated">Perl 테스트가 실행될 때 허용되는 라이브러리에 대한 경로를 포함하는 스칼라 값 또는 스칼라 값의 배열 참조를 승인합니다. 당연히 이것은 Perl로 작성된 테스트 환경에서만 의미가 있습니다.</target>
        </trans-unit>
        <trans-unit id="fd709042dcc776319515489b90b122d3454c0825" translate="yes" xml:space="preserve">
          <source>Accepts a scalar value or array ref of scalar values indicating which switches should be included if Perl tests are executed. Naturally, this only makes sense in the context of tests written in Perl.</source>
          <target state="translated">Perl 테스트가 실행될 때 어떤 스위치를 포함해야하는지 나타내는 스칼라 값 또는 스칼라 값의 배열 참조를 승인합니다. 당연히 이것은 Perl로 작성된 테스트 환경에서만 의미가 있습니다.</target>
        </trans-unit>
        <trans-unit id="410a58b5c50383c8e3e3efac6ca6d02323a2e404" translate="yes" xml:space="preserve">
          <source>Accepts a version object and returns the normalized floating point representation. Call like:</source>
          <target state="translated">버전 객체를 받아들이고 정규화 된 부동 소수점 표현을 반환합니다. 다음과 같이 전화하십시오 :</target>
        </trans-unit>
        <trans-unit id="6925cd73aca9469cc1ca4115afb36b07a4f628be" translate="yes" xml:space="preserve">
          <source>Accepts a version object and returns the normalized string representation. Call like:</source>
          <target state="translated">버전 객체를 허용하고 정규화 된 문자열 표현을 반환합니다. 다음과 같이 전화하십시오 :</target>
        </trans-unit>
        <trans-unit id="2dc796d2ce674a48fb65979328ffb56b5f53f1a2" translate="yes" xml:space="preserve">
          <source>Accepts an array of &lt;code&gt;@tests&lt;/code&gt; to be run. This should generally be the names of test files, but this is not required. Each element in &lt;code&gt;@tests&lt;/code&gt; will be passed to &lt;code&gt;TAP::Parser::new()&lt;/code&gt; as a &lt;code&gt;source&lt;/code&gt; . See &lt;a href=&quot;parser&quot;&gt;TAP::Parser&lt;/a&gt; for more information.</source>
          <target state="translated">&lt;code&gt;@tests&lt;/code&gt; 배열을 실행할 수 있습니다. 일반적으로 테스트 파일 이름이어야하지만 필수는 아닙니다. &lt;code&gt;@tests&lt;/code&gt; 의 각 요소는 &lt;code&gt;TAP::Parser::new()&lt;/code&gt; 에 &lt;code&gt;source&lt;/code&gt; 로 전달됩니다 . 자세한 내용은 &lt;a href=&quot;parser&quot;&gt;TAP :: Parser&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="153201ceff12f9d62f4b764e4eec8629fe65e3ae" translate="yes" xml:space="preserve">
          <source>Accepts an array of &lt;code&gt;@tests&lt;/code&gt; to be run. This should generally be the names of test files, but this is not required. Each element in &lt;code&gt;@tests&lt;/code&gt; will be passed to &lt;code&gt;TAP::Parser::new()&lt;/code&gt; as a &lt;code&gt;source&lt;/code&gt;. See &lt;a href=&quot;TAP::Parser&quot;&gt;TAP::Parser&lt;/a&gt; for more information.</source>
          <target state="translated">실행할 &lt;code&gt;@tests&lt;/code&gt; 배열을 허용 합니다. 일반적으로 테스트 파일의 이름이어야하지만 필수는 아닙니다. 각 요소 &lt;code&gt;@tests&lt;/code&gt; 이 전달됩니다 &lt;code&gt;TAP::Parser::new()&lt;/code&gt; A와 &lt;code&gt;source&lt;/code&gt; . 자세한 내용은 &lt;a href=&quot;TAP::Parser&quot;&gt;TAP :: Parser&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="415cae88d4078bbe8d508015c3671569a70c4e7e" translate="yes" xml:space="preserve">
          <source>Accepts an incoming socket connect, just as &lt;a href=&quot;http://man.he.net/man2/accept&quot;&gt;accept(2)&lt;/a&gt; does. Returns the packed address if it succeeded, false otherwise. See the example in &lt;a href=&quot;perlipc#Sockets%3A-Client%2FServer-Communication&quot;&gt;&quot;Sockets: Client/Server Communication&quot; in perlipc&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://man.he.net/man2/accept&quot;&gt;accept (2)&lt;/a&gt; 처럼 들어오는 소켓 연결을 허용합니다 . 성공하면 패킹 된 주소를 반환하고 그렇지 않으면 false를 반환합니다. &lt;a href=&quot;perlipc#Sockets%3A-Client%2FServer-Communication&quot;&gt;perlipc의 &quot;소켓 : 클라이언트 / 서버 통신&quot;&lt;/a&gt; 의 예를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="2eb4b3520f8d8fe3fca980121310995272cd8962" translate="yes" xml:space="preserve">
          <source>Accepts an incoming socket connect, just as accept(2) does. Returns the packed address if it succeeded, false otherwise. See the example in &lt;a href=&quot;../perlipc#Sockets%3a-Client%2fServer-Communication&quot;&gt;Sockets: Client/Server Communication in perlipc&lt;/a&gt;.</source>
          <target state="translated">accept (2)와 마찬가지로 들어오는 소켓 연결을 수락합니다. 압축 된 주소가 성공하면 반환하고 그렇지 않으면 false를 반환합니다. &lt;a href=&quot;../perlipc#Sockets%3a-Client%2fServer-Communication&quot;&gt;소켓 : perlipc의 클라이언트 / 서버 통신&lt;/a&gt; 의 예제를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="9fa11f18dc906995a6c93c465d60382e345c0a77" translate="yes" xml:space="preserve">
          <source>Accepts an incoming socket connect, just as accept(2) does. Returns the packed address if it succeeded, false otherwise. See the example in &lt;a href=&quot;perlipc#Sockets%3a-Client%2fServer-Communication&quot;&gt;Sockets: Client/Server Communication in perlipc&lt;/a&gt;.</source>
          <target state="translated">accept (2)와 마찬가지로 들어오는 소켓 연결을 수락합니다. 압축 된 주소가 성공하면 반환하고 그렇지 않으면 false를 반환합니다. &lt;a href=&quot;perlipc#Sockets%3a-Client%2fServer-Communication&quot;&gt;소켓 : perlipc의 클라이언트 / 서버 통신&lt;/a&gt; 의 예제를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="37a976454ef0a6eae01758cd57c59bf29e52a50c" translate="yes" xml:space="preserve">
          <source>Accepts targets for &lt;code&gt;=begin/=for/=end&lt;/code&gt; sections of the POD.</source>
          <target state="translated">POD의 &lt;code&gt;=begin/=for/=end&lt;/code&gt; 섹션에 대한 대상을 허용 합니다.</target>
        </trans-unit>
        <trans-unit id="cede5a1af37a1d62c15ab2a9566e9d886f5d7670" translate="yes" xml:space="preserve">
          <source>Accepts targets for &lt;code&gt;=begin/=for/=end&lt;/code&gt; sections that should be parsed as POD. For details, see &lt;a href=&quot;../perlpodspec#About-Data-Paragraphs&quot;&gt;About Data Paragraphs in perlpodspec&lt;/a&gt;.</source>
          <target state="translated">POD로 구문 분석해야하는 &lt;code&gt;=begin/=for/=end&lt;/code&gt; 섹션에 대한 대상을 승인 합니다 . 자세한 내용 &lt;a href=&quot;../perlpodspec#About-Data-Paragraphs&quot;&gt;은 perlpodspec의 데이터 단락&lt;/a&gt; 정보를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="851ea1edc0df28d0ff8f9f27b6a32617e9a9daf8" translate="yes" xml:space="preserve">
          <source>Accepts targets for &lt;code&gt;=begin/=for/=end&lt;/code&gt; sections that should be parsed as POD. For details, see &lt;a href=&quot;perlpodspec#About-Data-Paragraphs&quot;&gt;&quot;About Data Paragraphs&quot; in perlpodspec&lt;/a&gt;.</source>
          <target state="translated">POD로 구문 분석되어야 하는 &lt;code&gt;=begin/=for/=end&lt;/code&gt; 섹션에 대한 대상을 허용 합니다 . 자세한 내용 &lt;a href=&quot;perlpodspec#About-Data-Paragraphs&quot;&gt;은 perlpodspec의 &quot;데이터 단락 정보&quot;를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="97988ce7469a2ec04985afb61d994b1c11cd933b" translate="yes" xml:space="preserve">
          <source>Access =&amp;gt; $sAccess</source>
          <target state="translated">액세스 =&amp;gt; $ sAccess</target>
        </trans-unit>
        <trans-unit id="f6af85a2542ec066bdb276d6d663ab04f9bea612" translate="yes" xml:space="preserve">
          <source>Access =&amp;gt; $uAccess</source>
          <target state="translated">액세스 =&amp;gt; $ uAccess</target>
        </trans-unit>
        <trans-unit id="7e56694c4d8d029e1bdf7a642cc8826a85758929" translate="yes" xml:space="preserve">
          <source>Access Perl configuration information</source>
          <target state="translated">Perl 구성 정보에 액세스</target>
        </trans-unit>
        <trans-unit id="8347e5dd48478a10f6aa983449d4b21d1a1af03b" translate="yes" xml:space="preserve">
          <source>Access and Printing</source>
          <target state="translated">액세스 및 인쇄</target>
        </trans-unit>
        <trans-unit id="6e5e899f8f49475c30613c0d5e03d1268e31be2c" translate="yes" xml:space="preserve">
          <source>Access and Printing of a HASH OF ARRAYS</source>
          <target state="translated">배열 해시 액세스 및 인쇄</target>
        </trans-unit>
        <trans-unit id="0a3d910a71354dc1a13d0c6e24e7384a561b0108" translate="yes" xml:space="preserve">
          <source>Access and Printing of a HASH OF HASHES</source>
          <target state="translated">해시 해시 액세스 및 인쇄</target>
        </trans-unit>
        <trans-unit id="7eae78c7526db834fa9958c243fe41a5cb62ea03" translate="yes" xml:space="preserve">
          <source>Access and Printing of an ARRAY OF ARRAYS</source>
          <target state="translated">배열의 액세스 및 인쇄</target>
        </trans-unit>
        <trans-unit id="5c93728a9e35642c958c51c0f97be500a59df202" translate="yes" xml:space="preserve">
          <source>Access and Printing of an ARRAY OF HASHES</source>
          <target state="translated">해시 배열 액세스 및 인쇄</target>
        </trans-unit>
        <trans-unit id="f42ea96011d2554db1787fd6d4c92a4571864cb4" translate="yes" xml:space="preserve">
          <source>Access methods correspond to the underlying C macros for field access, usually with the leading &quot;class indication&quot; prefix removed (Sv, Av, Hv, ...). The leading prefix is only left in cases where its removal would cause a clash in method name. For example, &lt;code&gt;GvREFCNT&lt;/code&gt; stays as-is since its abbreviation would clash with the &quot;superclass&quot; method &lt;code&gt;REFCNT&lt;/code&gt; (corresponding to the C function &lt;code&gt;SvREFCNT&lt;/code&gt; ).</source>
          <target state="translated">액세스 방법은 필드 액세스를위한 기본 C 매크로에 해당하며 일반적으로 선행 &quot;클래스 표시&quot;접두사가 제거됩니다 (Sv, Av, Hv, ...). 선행 접두사는 제거로 인해 메소드 이름이 충돌하는 경우에만 남습니다. 예를 들어, &lt;code&gt;GvREFCNT&lt;/code&gt; 는 약어가 &quot;수퍼 클래스&quot;메소드 &lt;code&gt;REFCNT&lt;/code&gt; (C 함수 &lt;code&gt;SvREFCNT&lt;/code&gt; 에 해당) 와 충돌하기 때문에 그대로 유지됩니다 .</target>
        </trans-unit>
        <trans-unit id="9efb96c27e44ebf09b5de1315ff44057610d7071" translate="yes" xml:space="preserve">
          <source>Access methods correspond to the underlying C macros for field access, usually with the leading &quot;class indication&quot; prefix removed (Sv, Av, Hv, ...). The leading prefix is only left in cases where its removal would cause a clash in method name. For example, &lt;code&gt;GvREFCNT&lt;/code&gt; stays as-is since its abbreviation would clash with the &quot;superclass&quot; method &lt;code&gt;REFCNT&lt;/code&gt; (corresponding to the C function &lt;code&gt;SvREFCNT&lt;/code&gt;).</source>
          <target state="translated">액세스 방법은 필드 액세스를위한 기본 C 매크로에 해당하며 일반적으로 선행 &quot;클래스 표시&quot;접두사가 제거됩니다 (Sv, Av, Hv, ...). 선행 접두사는 제거로 인해 메서드 이름이 충돌하는 경우에만 남습니다. 예를 들어, &lt;code&gt;GvREFCNT&lt;/code&gt; 는 그 약어가 &quot;수퍼 클래스&quot;메소드 &lt;code&gt;REFCNT&lt;/code&gt; (C 함수 &lt;code&gt;SvREFCNT&lt;/code&gt; 에 해당) 와 충돌하기 때문에있는 그대로 유지됩니다 .</target>
        </trans-unit>
        <trans-unit id="add7e6bb00f6c276fc0702f5d9311fd702f4d0cd" translate="yes" xml:space="preserve">
          <source>Access methods correspond to the underlying C structure field names, with the leading &quot;class indication&quot; prefix (&lt;code&gt;&quot;op_&quot;&lt;/code&gt; ) removed.</source>
          <target state="translated">액세스 방법은 선행 &quot;클래스 표시&quot;접두어 ( &lt;code&gt;&quot;op_&quot;&lt;/code&gt; )가 제거 된 기본 C 구조 필드 이름에 해당합니다 .</target>
        </trans-unit>
        <trans-unit id="82922d6d239bf81a906ba51a449f669156de40f1" translate="yes" xml:space="preserve">
          <source>Access methods correspond to the underlying C structure field names, with the leading &quot;class indication&quot; prefix (&lt;code&gt;&quot;op_&quot;&lt;/code&gt;) removed.</source>
          <target state="translated">액세스 방법은 선행 &quot;클래스 표시&quot;접두어 ( &lt;code&gt;&quot;op_&quot;&lt;/code&gt; )가 제거 된 기본 C 구조 필드 이름에 해당합니다 .</target>
        </trans-unit>
        <trans-unit id="9396a41f14cddbeb41d4b7aa1b84d15e3d72d6c2" translate="yes" xml:space="preserve">
          <source>Access permissions are mapped onto VOS access-control list changes. (VOS)</source>
          <target state="translated">액세스 권한은 VOS 액세스 제어 목록 변경 사항에 매핑됩니다. (VOS)</target>
        </trans-unit>
        <trans-unit id="4c6d1814a4ba9c61a3ee7ec315197dda1812fb41" translate="yes" xml:space="preserve">
          <source>Access the SV at offset &lt;code&gt;po&lt;/code&gt; in the saved current pad in the given context block structure (can be used as an lvalue).</source>
          <target state="translated">주어진 컨텍스트 블록 구조에서 저장된 현재 패드의 오프셋 &lt;code&gt;po&lt;/code&gt; 에서 SV에 액세스합니다 (lvalue로 사용할 수 있음).</target>
        </trans-unit>
        <trans-unit id="cf06121dd11c83b8ba81397ecad6cc2b95e65336" translate="yes" xml:space="preserve">
          <source>Access the SV at offset po in the saved current pad in the given context block structure (can be used as an lvalue).</source>
          <target state="translated">주어진 컨텍스트 블록 구조에서 저장된 전류 패드의 오프셋 po에서 SV에 액세스합니다 (l 값으로 사용할 수 있음).</target>
        </trans-unit>
        <trans-unit id="2cb44963f6bed203bb471252102ea353cd9644e0" translate="yes" xml:space="preserve">
          <source>Access the lines of a disk file via a Perl array</source>
          <target state="translated">Perl 배열을 통해 디스크 파일 라인에 액세스</target>
        </trans-unit>
        <trans-unit id="dfa61e115e0e8ce23ca07250a4a3499d896cdbc1" translate="yes" xml:space="preserve">
          <source>Access to Unicode character names and named character sequences; also define character names</source>
          <target state="translated">유니 코드 문자 이름 및 명명 된 문자 시퀀스에 액세스 또한 캐릭터 이름을 정의</target>
        </trans-unit>
        <trans-unit id="3f2a46103156b0b5a62f34c4352c1666092f35bc" translate="yes" xml:space="preserve">
          <source>Access to lexicals that change over time--like those in the &lt;code&gt;for&lt;/code&gt; loop above, basically aliases to elements from the surrounding lexical scopes-- only works with anonymous subs, not with named subroutines. Generally said, named subroutines do not nest properly and should only be declared in the main package scope.</source>
          <target state="translated">위 의 &lt;code&gt;for&lt;/code&gt; 루프 에서와 같이 시간이 지남에 따라 변하는 어휘에 대한 액세스 , 기본적으로 주변 어휘 범위의 요소에 대한 별명은 명명 된 서브 루틴이 아닌 익명의 서브에서만 작동합니다. 일반적으로 명명 된 서브 루틴은 올바르게 중첩되지 않으며 기본 패키지 범위에서만 선언해야합니다.</target>
        </trans-unit>
        <trans-unit id="7bc448fbe13d49ff8ac45ad2ec5aee25fed2364d" translate="yes" xml:space="preserve">
          <source>Accessing .tar.Z files</source>
          <target state="translated">.tar.Z 파일에 액세스</target>
        </trans-unit>
        <trans-unit id="c5656ffc833d5bac0703673d7cf0135c7d41a0d7" translate="yes" xml:space="preserve">
          <source>Accessing Formatting Internals</source>
          <target state="translated">서식 내부 액세스</target>
        </trans-unit>
        <trans-unit id="1370d87d951a33ab05354cde2d7a32967a2dbeb2" translate="yes" xml:space="preserve">
          <source>Accessing documentation</source>
          <target state="translated">문서에 액세스</target>
        </trans-unit>
        <trans-unit id="e54a40f7d6dbbb802431fdba39190e9b3cbe3ecd" translate="yes" xml:space="preserve">
          <source>Accessing socket options</source>
          <target state="translated">소켓 옵션에 액세스</target>
        </trans-unit>
        <trans-unit id="ee8cacdba63cbccd984c19db609590e2c60f68e6" translate="yes" xml:space="preserve">
          <source>Accessor functions are available for all existing object hash keys and should be used instead of directly accessing the internal hash keys. The reason for this is that Math::BigInt itself has a pluggable interface which permits it to support different storage methods.</source>
          <target state="translated">접근 자 기능은 기존의 모든 객체 해시 키에 사용할 수 있으며 내부 해시 키에 직접 액세스하는 대신 사용해야합니다. 그 이유는 Math :: BigInt 자체에 다른 저장 방법을 지원할 수있는 플러그 가능 인터페이스가 있기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="f5b0e226ed894764db92e76b6c1f1203c0b805bb" translate="yes" xml:space="preserve">
          <source>Accessors</source>
          <target state="translated">Accessors</target>
        </trans-unit>
        <trans-unit id="e401a3944ad3f6376d340de647f40b7e6ced2483" translate="yes" xml:space="preserve">
          <source>According to the &lt;b&gt;Test::More&lt;/b&gt; documentation, it is recommended to run &lt;code&gt;use_ok()&lt;/code&gt; inside a &lt;code&gt;BEGIN&lt;/code&gt; block, so functions are exported at compile-time and prototypes are properly honored.</source>
          <target state="translated">에 따르면 &lt;b&gt;테스트 : 더 많은&lt;/b&gt; 문서, 그것을 실행하는 것이 좋습니다 &lt;code&gt;use_ok()&lt;/code&gt; 내부는 &lt;code&gt;BEGIN&lt;/code&gt; 기능은 컴파일 시간에 수출하고 프로토 타입이 제대로 영광 있도록, 블록.</target>
        </trans-unit>
        <trans-unit id="c22eaa0601273fc83a6938a3e6df6517eb7bf99a" translate="yes" xml:space="preserve">
          <source>Accuracy (significant digits)</source>
          <target state="translated">정확도 (유효 숫자)</target>
        </trans-unit>
        <trans-unit id="4bc2c6535b52b04314dc544d8a82eac93deb00cf" translate="yes" xml:space="preserve">
          <source>Accuracy A</source>
          <target state="translated">정확도 A</target>
        </trans-unit>
        <trans-unit id="938afbd35a75ae9b5871a66f02d0250f1479aaac" translate="yes" xml:space="preserve">
          <source>Accuracy vs. Precision</source>
          <target state="translated">정확도 대 정밀도</target>
        </trans-unit>
        <trans-unit id="3e804ac1bc11e330fa5eacd1be133ab843f79bee" translate="yes" xml:space="preserve">
          <source>Accustomed &lt;b&gt;awk&lt;/b&gt; users should take special note of the following:</source>
          <target state="translated">익숙한 &lt;b&gt;awk&lt;/b&gt; 사용자는 다음 사항에주의해야합니다.</target>
        </trans-unit>
        <trans-unit id="082af44e6d89682179d27fdfd34277a7e0c2c9af" translate="yes" xml:space="preserve">
          <source>Acknowledgement</source>
          <target state="translated">Acknowledgement</target>
        </trans-unit>
        <trans-unit id="b0ebcfe59f276beb7f6238d812ac61ce48d3d9c0" translate="yes" xml:space="preserve">
          <source>Acknowledgements</source>
          <target state="translated">Acknowledgements</target>
        </trans-unit>
        <trans-unit id="5d9540ff93a75d47409d6a0aa37491da117ecdf8" translate="yes" xml:space="preserve">
          <source>Acknowledgments</source>
          <target state="translated">Acknowledgments</target>
        </trans-unit>
        <trans-unit id="708327daa641b57f7797d675f864c6465f65ebf5" translate="yes" xml:space="preserve">
          <source>Acorn RISC OS</source>
          <target state="translated">도토리 RISC OS</target>
        </trans-unit>
        <trans-unit id="8661bdb9b88159cdbca0d1b472228de45e5e9630" translate="yes" xml:space="preserve">
          <source>Actions in current file (keys are line numbers). The values are strings that have the sprintf(3) format &lt;code&gt;(&quot;%s\000%s&quot;, breakcondition, actioncode)&lt;/code&gt; .</source>
          <target state="translated">현재 파일의 작업 (키는 줄 번호) 값은 sprintf (3) 형식 &lt;code&gt;(&quot;%s\000%s&quot;, breakcondition, actioncode)&lt;/code&gt; 을 가진 문자열입니다 .</target>
        </trans-unit>
        <trans-unit id="7fcdbe2472b2255ea44bd3cae717a9eebf9b772b" translate="yes" xml:space="preserve">
          <source>Actions in current file (keys are line numbers). The values are strings that have the sprintf(3) format &lt;code&gt;(&quot;%s\000%s&quot;, breakcondition, actioncode)&lt;/code&gt;.</source>
          <target state="translated">현재 파일의 작업 (키는 줄 번호 임). 값은 sprintf (3) 형식 &lt;code&gt;(&quot;%s\000%s&quot;, breakcondition, actioncode)&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="74456291abea501ae7538be3d3218d24479cf1b8" translate="yes" xml:space="preserve">
          <source>Actions, watch variables, stack traces etc.: on the TODO list.</source>
          <target state="translated">TODO 목록의 조치, 감시 변수, 스택 추적 등</target>
        </trans-unit>
        <trans-unit id="0e67e479302a0fbdd5f8f5323bb053fb5c4640b0" translate="yes" xml:space="preserve">
          <source>ActiveState's cross-platform (as of October 2004, that's Windows, Linux, and Solaris), multi-language IDE has Perl support, including a regular expression debugger and remote debugging.</source>
          <target state="translated">ActiveState의 크로스 플랫폼 (2004 년 10 월 현재 Windows, Linux 및 Solaris)의 다국어 IDE는 정규식 디버거 및 원격 디버깅을 포함하여 Perl을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="3c54dc62dfe34bf8e3127c0ce1e38a91208c3d94" translate="yes" xml:space="preserve">
          <source>Acts like &lt;code&gt;FB_PERLQQ&lt;/code&gt; but U+</source>
          <target state="translated">&lt;code&gt;FB_PERLQQ&lt;/code&gt; 와 유사 하지만 U +</target>
        </trans-unit>
        <trans-unit id="3e5206894de994df5b433d801d3d018a747731e7" translate="yes" xml:space="preserve">
          <source>Acts like &lt;code&gt;pathify&lt;/code&gt;, but insures the returned path uses Unix syntax.</source>
          <target state="translated">&lt;code&gt;pathify&lt;/code&gt; 처럼 작동 하지만 반환 된 경로가 Unix 구문을 사용하도록합니다.</target>
        </trans-unit>
        <trans-unit id="25e47aa6fb1a8cefdd723523afa78155b3ebed86" translate="yes" xml:space="preserve">
          <source>Acts like &lt;code&gt;pathify&lt;/code&gt;, but insures the returned path uses VMS syntax.</source>
          <target state="translated">&lt;code&gt;pathify&lt;/code&gt; 처럼 작동 하지만 반환 된 경로가 VMS 구문을 사용하도록합니다.</target>
        </trans-unit>
        <trans-unit id="548322587aa8642fc346684844907ab3ffec74e4" translate="yes" xml:space="preserve">
          <source>Actual math is done by using the class defined with &lt;code&gt;with =&amp;gt; Class;&lt;/code&gt; (which defaults to BigInts) to represent the mantissa and exponent.</source>
          <target state="translated">실제 수학은 &lt;code&gt;with =&amp;gt; Class;&lt;/code&gt; 정의 된 클래스를 사용하여 수행됩니다 . 가수 및 지수를 나타내는 (기본값은 BigInts)입니다.</target>
        </trans-unit>
        <trans-unit id="defa153aecf01309cb026d878c1991031baa4a07" translate="yes" xml:space="preserve">
          <source>Actually &lt;code&gt;Term::ReadLine&lt;/code&gt; can use some other package, that will support a richer set of commands.</source>
          <target state="translated">실제로 &lt;code&gt;Term::ReadLine&lt;/code&gt; 은 더 많은 명령 세트를 지원하는 다른 패키지를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3803c01d8a976c5bf1f723681cc4bf39bad12043" translate="yes" xml:space="preserve">
          <source>Actually Perl will not</source>
          <target state="translated">실제로 펄은</target>
        </trans-unit>
        <trans-unit id="795eded018f6ab011486134b18f32e5ab2a7c100" translate="yes" xml:space="preserve">
          <source>Actually performs the output check testing the tests, comparing the data (with &lt;code&gt;eq&lt;/code&gt; ) that we have captured from &lt;a href=&quot;../builder&quot;&gt;Test::Builder&lt;/a&gt; against what was declared with &lt;code&gt;test_out&lt;/code&gt; and &lt;code&gt;test_err&lt;/code&gt; .</source>
          <target state="translated">실제로 &lt;a href=&quot;../builder&quot;&gt;Test :: Builder&lt;/a&gt; 에서 캡처 한 데이터 ( &lt;code&gt;eq&lt;/code&gt; ) 와 &lt;code&gt;test_out&lt;/code&gt; 및 &lt;code&gt;test_err&lt;/code&gt; 로 선언 된 데이터를 비교하여 테스트 테스트 출력 검사를 수행합니다 .</target>
        </trans-unit>
        <trans-unit id="9ce626e0ac60b7664d00caf1f10ac16f4d3c195a" translate="yes" xml:space="preserve">
          <source>Actually performs the output check testing the tests, comparing the data (with &lt;code&gt;eq&lt;/code&gt;) that we have captured from &lt;a href=&quot;Test::Builder&quot;&gt;Test::Builder&lt;/a&gt; against what was declared with &lt;code&gt;test_out&lt;/code&gt; and &lt;code&gt;test_err&lt;/code&gt;.</source>
          <target state="translated">실제로 &lt;a href=&quot;Test::Builder&quot;&gt;Test :: Builder&lt;/a&gt; 에서 캡처 한 데이터 ( &lt;code&gt;eq&lt;/code&gt; 사용 )를 &lt;code&gt;test_out&lt;/code&gt; 및 &lt;code&gt;test_err&lt;/code&gt; 로 선언 된 데이터와 비교하여 테스트를 테스트하는 출력 검사를 수행합니다 .</target>
        </trans-unit>
        <trans-unit id="6f88040d5de372b8d0dd6ff348f68d75945e5e13" translate="yes" xml:space="preserve">
          <source>Actually, Apple does not follow the Unicode NFD standard since not all character ranges are decomposed. The claim is that this avoids problems with round trip conversions from old Mac text encodings. See &lt;a href=&quot;Encode::UTF8Mac&quot;&gt;Encode::UTF8Mac&lt;/a&gt; for details.</source>
          <target state="translated">실제로 Apple은 모든 문자 범위가 분해되지 않기 때문에 유니 코드 NFD 표준을 따르지 않습니다. 주장은 이것이 오래된 Mac 텍스트 인코딩의 왕복 변환 문제를 피한다는 것입니다. 자세한 내용은 &lt;a href=&quot;Encode::UTF8Mac&quot;&gt;Encode :: UTF8Mac&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="5e55c0ee05ca269c1127b8a0393a10c58d229a08" translate="yes" xml:space="preserve">
          <source>Actually, on Mac OS, the &lt;code&gt;getcwd()&lt;/code&gt; , &lt;code&gt;fastgetcwd()&lt;/code&gt; and &lt;code&gt;fastcwd()&lt;/code&gt; functions are all aliases for the &lt;code&gt;cwd()&lt;/code&gt; function, which, on Mac OS, calls `pwd`. Likewise, the &lt;code&gt;abs_path()&lt;/code&gt; function is an alias for &lt;code&gt;fast_abs_path()&lt;/code&gt; .</source>
          <target state="translated">실제로 Mac OS에서 &lt;code&gt;getcwd()&lt;/code&gt; , &lt;code&gt;fastgetcwd()&lt;/code&gt; 및 &lt;code&gt;fastcwd()&lt;/code&gt; 함수는 &lt;code&gt;cwd()&lt;/code&gt; 함수 의 별명이며 Mac OS에서는`pwd`를 호출합니다. 마찬가지로, &lt;code&gt;abs_path()&lt;/code&gt; 함수의 별칭 &lt;code&gt;fast_abs_path()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2f828efd7d8d25d8d2437834055d546543161b8e" translate="yes" xml:space="preserve">
          <source>Actually, on Mac OS, the &lt;code&gt;getcwd()&lt;/code&gt;, &lt;code&gt;fastgetcwd()&lt;/code&gt; and &lt;code&gt;fastcwd()&lt;/code&gt; functions are all aliases for the &lt;code&gt;cwd()&lt;/code&gt; function, which, on Mac OS, calls `pwd`. Likewise, the &lt;code&gt;abs_path()&lt;/code&gt; function is an alias for &lt;code&gt;fast_abs_path()&lt;/code&gt;.</source>
          <target state="translated">실제로 Mac OS에서 &lt;code&gt;getcwd()&lt;/code&gt; , &lt;code&gt;fastgetcwd()&lt;/code&gt; 및 &lt;code&gt;fastcwd()&lt;/code&gt; 함수는 모두 Mac OS에서`pwd`를 호출 하는 &lt;code&gt;cwd()&lt;/code&gt; 함수 의 별칭입니다 . 마찬가지로, &lt;code&gt;abs_path()&lt;/code&gt; 함수의 별칭 &lt;code&gt;fast_abs_path()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="db3073222c40a74ba3591ee6ba65b3b3cd91207d" translate="yes" xml:space="preserve">
          <source>Actually, the log output of</source>
          <target state="translated">실제로, 로그 출력</target>
        </trans-unit>
        <trans-unit id="64a640de411740b3998c2d6a6e47de7a59b836d2" translate="yes" xml:space="preserve">
          <source>Actually, the log output of &lt;a href=&quot;http://man.he.net/man1/pod2ipf&quot;&gt;pod2ipf(1)&lt;/a&gt; during the step 6 gives a very detailed info about which modules are loaded from which place; so you may use it as an additional verification tool.</source>
          <target state="translated">실제로, 6 단계 동안 &lt;a href=&quot;http://man.he.net/man1/pod2ipf&quot;&gt;pod2ipf (1)&lt;/a&gt; 의 로그 출력 은 어떤 모듈이 어느 위치에서로드되었는지에 대한 매우 자세한 정보를 제공합니다. 추가 확인 도구로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="af7244e5a9d564e8f0d5e7e9d10e38f4ccd63f70" translate="yes" xml:space="preserve">
          <source>Actually, they don't. All C operators that Perl copies have the same precedence in Perl as they do in C. The problem is with operators that C doesn't have, especially functions that give a list context to everything on their right, eg. print, chmod, exec, and so on. Such functions are called &quot;list operators&quot; and appear as such in the precedence table in &lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt;.</source>
          <target state="translated">실제로는 그렇지 않습니다. Perl이 복사하는 모든 C 연산자는 Perl에서 C와 같은 우선 순위를 갖습니다. 문제는 C에없는 연산자, 특히 오른쪽에있는 모든 것에 목록 컨텍스트를 제공하는 함수입니다. print, chmod, exec 등. 이러한 함수를 &quot;목록 연산자&quot;라고하며 &lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt; 의 우선 순위 표에 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="07d8d521acda78914bf8936bc58119c26500077c" translate="yes" xml:space="preserve">
          <source>Actually, this was generated by a particular set of options. You can control the formatting of each column, whether you prefer wide or fat, hex or decimal, leading zeroes or whatever.</source>
          <target state="translated">실제로 이것은 특정 옵션 세트에 의해 생성되었습니다. 넓거나 뚱뚱한, 16 진수 또는 10 진수, 선행 0 또는 무엇이든 원하는대로 각 열의 서식을 제어 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="053a69cc613575e54728e4468a4f2f77a1d85f37" translate="yes" xml:space="preserve">
          <source>Adam Kennedy</source>
          <target state="translated">아담 케네디</target>
        </trans-unit>
        <trans-unit id="860c250cdfa0ae37812255641a707082591aa037" translate="yes" xml:space="preserve">
          <source>Adam Kennedy &amp;lt;adamk@cpan.org&amp;gt;</source>
          <target state="translated">아담 케네디 &amp;lt;adamk@cpan.org&amp;gt;</target>
        </trans-unit>
        <trans-unit id="26df0dc623b688e391494fde447ffec8a4ad7688" translate="yes" xml:space="preserve">
          <source>Adam Kennedy pointed out that &lt;code&gt;exit()&lt;/code&gt; causes problems on Windows where this script ends up with a .bat extension</source>
          <target state="translated">Adam Kennedy는 &lt;code&gt;exit()&lt;/code&gt; 가 Windows에서이 스크립트가 .bat 확장자로 끝나는 문제를 일으킨다 고 지적했습니다.</target>
        </trans-unit>
        <trans-unit id="59df5078ee8230620699668c2d6c69e2d9333374" translate="yes" xml:space="preserve">
          <source>Adam Kennedy pointed out that exit() causes problems on Windows where this script ends up with a .bat extension</source>
          <target state="translated">Adam Kennedy는 exit ()가 Windows에서이 스크립트가 .bat 확장자로 끝나는 문제를 일으킨다 고 지적했습니다.</target>
        </trans-unit>
        <trans-unit id="1e2354baf0563b5f6691f5eeff3c433c1c0e8b12" translate="yes" xml:space="preserve">
          <source>Adam Kennedy wrote &lt;a href=&quot;YAML::Tiny&quot;&gt;YAML::Tiny&lt;/a&gt; which provided the template and many of the YAML matching regular expressions for this module.</source>
          <target state="translated">Adam Kennedy는 이 모듈에 대한 템플릿과 많은 YAML 일치 정규식을 제공하는 &lt;a href=&quot;YAML::Tiny&quot;&gt;YAML :: Tiny&lt;/a&gt; 를 작성했습니다 .</target>
        </trans-unit>
        <trans-unit id="1a5c118dabaa69a69c89ab79443c5334f9b230a2" translate="yes" xml:space="preserve">
          <source>Adam Kennedy wrote &lt;a href=&quot;http://search.cpan.org/perldoc/YAML::Tiny&quot;&gt;YAML::Tiny&lt;/a&gt; which provided the template and many of the YAML matching regular expressions for this module.</source>
          <target state="translated">Adam Kennedy는 &lt;a href=&quot;http://search.cpan.org/perldoc/YAML::Tiny&quot;&gt;YAML :: Tiny&lt;/a&gt; 를 작성 하여이 모듈에 대한 템플릿과 일치하는 많은 YAML 정규식을 제공했습니다.</target>
        </trans-unit>
        <trans-unit id="87ca31f47d6b4fa489a87a9623f9489457ae7a2d" translate="yes" xml:space="preserve">
          <source>Adapted from Sys::Hostname by David Sundstrom &amp;lt;</source>
          <target state="translated">Sys :: Hostname by David Sundstrom &amp;lt;</target>
        </trans-unit>
        <trans-unit id="71fa483aae87548852e70b6939f5558689bdd714" translate="yes" xml:space="preserve">
          <source>Adapted from a suggestion by Dan Muey</source>
          <target state="translated">Dan Muey의 제안에서 수정 됨</target>
        </trans-unit>
        <trans-unit id="61cc55aa0453184734c3fa0b621eda6fa874bd83" translate="yes" xml:space="preserve">
          <source>Add</source>
          <target state="translated">Add</target>
        </trans-unit>
        <trans-unit id="bac28a1890b03ac016be9f9de8d1c17394eeee83" translate="yes" xml:space="preserve">
          <source>Add '#line' declarations to the output based on the line and file locations of the original code.</source>
          <target state="translated">원래 코드의 라인 및 파일 위치를 기반으로 출력에 '#line'선언을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="c4e7cfdfcf41d796fe22ef22535d39bf89e10e73" translate="yes" xml:space="preserve">
          <source>Add (if argument specified) and retrieve the hyperlinks (as defined by &lt;code&gt;L&amp;lt;&amp;gt;&lt;/code&gt; ) of the current POD. They consist of a 2-item array: line number and &lt;code&gt;Pod::Hyperlink&lt;/code&gt; object.</source>
          <target state="translated">(인수가 지정된 경우) 현재 POD 의 하이퍼 링크 ( &lt;code&gt;L&amp;lt;&amp;gt;&lt;/code&gt; 로 정의 된대로)를 추가하고 검색하십시오 . 행 번호와 &lt;code&gt;Pod::Hyperlink&lt;/code&gt; 객체 의 2 가지 항목으로 구성됩니다 .</target>
        </trans-unit>
        <trans-unit id="593bc3c347e611284226398e8eb5446a2cdf167c" translate="yes" xml:space="preserve">
          <source>Add (if argument specified) and retrieve the index entries (as defined by &lt;code&gt;X&amp;lt;&amp;gt;&lt;/code&gt; ) of the current POD. They consist of plain text, each piece of whitespace is collapsed to a single blank.</source>
          <target state="translated">(인수가 지정된 경우) 추가 하고 현재 POD 의 색인 항목 ( &lt;code&gt;X&amp;lt;&amp;gt;&lt;/code&gt; 정의 된대로)을 검색하십시오 . 그것들은 일반 텍스트로 구성되며, 각 공백은 단일 공백으로 축소됩니다.</target>
        </trans-unit>
        <trans-unit id="1fe12bc15fbb10fe94bc372bbfe93ad381dc4d9d" translate="yes" xml:space="preserve">
          <source>Add (if argument specified) and retrieve the index entries (as defined by &lt;code&gt;X&amp;lt;&amp;gt;&lt;/code&gt;) of the current POD. They consist of plain text, each piece of whitespace is collapsed to a single blank.</source>
          <target state="translated">현재 POD 의 색인 항목 ( &lt;code&gt;X&amp;lt;&amp;gt;&lt;/code&gt; 정의 된대로)을 추가하고 (인수가 지정된 경우) 검색합니다 . 일반 텍스트로 구성되며 각 공백은 단일 공백으로 축소됩니다.</target>
        </trans-unit>
        <trans-unit id="7205abf0d37c1a800710d7689075b8b7e0097f10" translate="yes" xml:space="preserve">
          <source>Add (if argument specified) and retrieve the nodes (as defined by &lt;code&gt;=headX&lt;/code&gt; and &lt;code&gt;=item&lt;/code&gt; ) of the current POD. The nodes are returned in the order of their occurrence. They consist of plain text, each piece of whitespace is collapsed to a single blank.</source>
          <target state="translated">(인수가 지정된 경우) 현재 POD 의 노드 ( &lt;code&gt;=headX&lt;/code&gt; 및 &lt;code&gt;=item&lt;/code&gt; 에 정의 된대로)를 추가하고 검색하십시오 . 노드는 발생 순서대로 리턴됩니다. 그것들은 일반 텍스트로 구성되며, 각 공백은 단일 공백으로 축소됩니다.</target>
        </trans-unit>
        <trans-unit id="e9849254645fc0214d84ddc69b97e054d149bcbc" translate="yes" xml:space="preserve">
          <source>Add (if argument specified) and retrieve the nodes (as defined by &lt;code&gt;=headX&lt;/code&gt; and &lt;code&gt;=item&lt;/code&gt;) of the current POD. The nodes are returned in the order of their occurrence. They consist of plain text, each piece of whitespace is collapsed to a single blank.</source>
          <target state="translated">현재 POD 의 노드 ( &lt;code&gt;=headX&lt;/code&gt; 및 &lt;code&gt;=item&lt;/code&gt; 에 정의 된대로)를 추가하고 (인수가 지정된 경우) 검색합니다 . 노드는 발생 순서대로 반환됩니다. 일반 텍스트로 구성되며 각 공백은 단일 공백으로 축소됩니다.</target>
        </trans-unit>
        <trans-unit id="874122d1d027ce488479a1cec7aca152094478e4" translate="yes" xml:space="preserve">
          <source>Add .USESHELL target for dmake.</source>
          <target state="translated">dmake에 .USESHELL 대상을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="d7fd295b806f9c0832ab6e0fa24fc58d699dd9d2" translate="yes" xml:space="preserve">
          <source>Add .err files corresponding to each .c file.</source>
          <target state="translated">각 .c 파일에 해당하는 .err 파일을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="74231505113c8782edaa10ddf555c5da9d24dda6" translate="yes" xml:space="preserve">
          <source>Add &lt;a href=&quot;#TERMINOLOGY&quot;&gt;&quot;TERMINOLOGY&quot;&lt;/a&gt; section to explain certain terms that may be ambiguous.</source>
          <target state="translated">모호 할 수있는 특정 용어를 설명하려면 &lt;a href=&quot;#TERMINOLOGY&quot;&gt;&quot;용어&quot;&lt;/a&gt; 섹션을 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="a2071ab1226f891c60e567774af03d596514feaf" translate="yes" xml:space="preserve">
          <source>Add &lt;a href=&quot;#keywords&quot;&gt;&quot;keywords&quot;&lt;/a&gt; field as a means to aid searching distributions.</source>
          <target state="translated">분포 검색에 도움이되는 수단으로 &lt;a href=&quot;#keywords&quot;&gt;&quot;키워드&quot;&lt;/a&gt; 필드를 추가 합니다.</target>
        </trans-unit>
        <trans-unit id="971e44a3c3bfac911c7f36aa74a2becf0b62b98e" translate="yes" xml:space="preserve">
          <source>Add &lt;code&gt;index&lt;/code&gt; field as a compliment to &lt;a href=&quot;#no_index&quot;&gt;&quot;no_index&quot;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;#no_index&quot;&gt;'no_index'에&lt;/a&gt; 대한 보완으로 &lt;code&gt;index&lt;/code&gt; 필드 추가</target>
        </trans-unit>
        <trans-unit id="ea6a5860866c436fec9d4ae108b1b47657c1c2fa" translate="yes" xml:space="preserve">
          <source>Add Collate Transform magic to an SV if it doesn't already have it. If the flags contain &lt;code&gt;SV_GMAGIC&lt;/code&gt;, it handles get-magic.</source>
          <target state="translated">SV에 아직없는 경우 Collate Transform 매직을 추가합니다. 플래그에 &lt;code&gt;SV_GMAGIC&lt;/code&gt; 이 포함되어 있으면 get-magic을 처리합니다.</target>
        </trans-unit>
        <trans-unit id="c4281d681d2b8d4904dd68ad15e4dae704a1bf89" translate="yes" xml:space="preserve">
          <source>Add Collate Transform magic to an SV if it doesn't already have it. If the flags contain SV_GMAGIC, it handles get-magic.</source>
          <target state="translated">SV에 Collate Transform Magic을 아직 추가하지 않은 경우 추가합니다. 플래그에 SV_GMAGIC이 포함되어 있으면 get-magic을 처리합니다.</target>
        </trans-unit>
        <trans-unit id="047c96ad9c325d237f1a6a46bb8af3410dff2f9a" translate="yes" xml:space="preserve">
          <source>Add MAXLINELENGTH for dmake before all the constants are output.</source>
          <target state="translated">모든 상수가 출력되기 전에 dmake에 MAXLINELENGTH를 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="94f0a7f38a5195aa6f33946dfa8058f9d2a857a9" translate="yes" xml:space="preserve">
          <source>Add MM_Unix_VERSION.</source>
          <target state="translated">MM_Unix_VERSION을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="eca289eb94f4122a1cb7f5b2bdff3d6769040fa8" translate="yes" xml:space="preserve">
          <source>Add MM_Win32_VERSION.</source>
          <target state="translated">MM_Win32_VERSION을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="8460c3bd39da428c04164ab6f8557a6dee2cb9dc" translate="yes" xml:space="preserve">
          <source>Add Netware macros initialized above to the Makefile.</source>
          <target state="translated">위에서 초기화 한 Netware 매크로를 Makefile에 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="b10d0c59d7d5f8f07519cfec5e7d10053270677d" translate="yes" xml:space="preserve">
          <source>Add Netware macros.</source>
          <target state="translated">Netware 매크로를 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="7a597e48edd2e108c64afde5e11638f77279428f" translate="yes" xml:space="preserve">
          <source>Add PERL_VMS, MM_VMS_REVISION and MM_VMS_VERSION.</source>
          <target state="translated">PERL_VMS, MM_VMS_REVISION 및 MM_VMS_VERSION을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="93d51f351ca51a56a5dbfcfefb634460272d4f03" translate="yes" xml:space="preserve">
          <source>Add a &lt;code&gt;TYPEMAP&lt;/code&gt; entry to the typemap.</source>
          <target state="translated">typemap에 &lt;code&gt;TYPEMAP&lt;/code&gt; 항목을 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="fb8b21b933335774c30773ac556f87eff4a5d7e6" translate="yes" xml:space="preserve">
          <source>Add a TAP::Parser to the multiplexer. &lt;code&gt;$stash&lt;/code&gt; is an optional opaque reference that will be returned from &lt;code&gt;&lt;a href=&quot;../../functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; along with the parser and the next result.</source>
          <target state="translated">멀티플렉서에 TAP :: Parser를 추가하십시오. &lt;code&gt;$stash&lt;/code&gt; 는 파서 및 다음 결과와 함께 &lt;code&gt;&lt;a href=&quot;../../functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; 에서 반환되는 선택적 불투명 참조입니다 .</target>
        </trans-unit>
        <trans-unit id="271cdeec599cca9e4b5c13aee063b654b7004d0b" translate="yes" xml:space="preserve">
          <source>Add a TAP::Parser to the multiplexer. &lt;code&gt;$stash&lt;/code&gt; is an optional opaque reference that will be returned from &lt;code&gt;next&lt;/code&gt; along with the parser and the next result.</source>
          <target state="translated">멀티플렉서에 TAP :: Parser를 추가합니다. &lt;code&gt;$stash&lt;/code&gt; 는 파서 및 다음 결과와 함께 &lt;code&gt;next&lt;/code&gt; 에서 반환되는 선택적 불투명 참조입니다 .</target>
        </trans-unit>
        <trans-unit id="9b79cb95223b1cd3ab37a1947c8b10858f53f09a" translate="yes" xml:space="preserve">
          <source>Add a callback that will be called every time a context is released. The callback will receive the released context as its only argument.</source>
          <target state="translated">컨텍스트가 해제 될 때마다 호출 될 콜백을 추가하십시오. 콜백은 해제 된 컨텍스트를 유일한 인수로받습니다.</target>
        </trans-unit>
        <trans-unit id="2b1d47693ec8eb3c1137e6c1d276ef0c253e2906" translate="yes" xml:space="preserve">
          <source>Add a callback that will be called every time a new context is created. The callback will receive the newly created context as its only argument.</source>
          <target state="translated">새 컨텍스트가 생성 될 때마다 호출 될 콜백을 추가합니다. 콜백은 새로 생성 된 컨텍스트를 유일한 인수로받습니다.</target>
        </trans-unit>
        <trans-unit id="4041e46a5d6433fdece7a493dd0a395d2127824f" translate="yes" xml:space="preserve">
          <source>Add a callback that will be called every time a subtest is going to be run. The callback will receive the subtest name, coderef, and any arguments.</source>
          <target state="translated">하위 테스트가 실행될 때마다 호출 될 콜백을 추가합니다. 콜백은 하위 테스트 이름, 코드 참조 및 모든 인수를 수신합니다.</target>
        </trans-unit>
        <trans-unit id="d62fdd818bdb4717eace512402ac80e7984a5c51" translate="yes" xml:space="preserve">
          <source>Add a callback that will be called every time someone tries to acquire a context. It gets a single argument, a reference of the hash of parameters being used the construct the context. This is your chance to change the parameters by directly altering the hash.</source>
          <target state="translated">누군가 컨텍스트를 얻으려고 할 때마다 호출되는 콜백을 추가하십시오. 컨텍스트를 구성하는 데 사용되는 매개 변수의 해시 참조 인 단일 인수를 가져옵니다. 해시를 직접 변경하여 매개 변수를 변경할 수있는 기회입니다.</target>
        </trans-unit>
        <trans-unit id="ad6cf519ff304b377e1026e19deb600993cefe39" translate="yes" xml:space="preserve">
          <source>Add a callback that will be called every time someone tries to acquire a context. This will be called on EVERY call to &lt;code&gt;context()&lt;/code&gt;. It gets a single argument, a reference to the hash of parameters being used the construct the context. This is your chance to change the parameters by directly altering the hash.</source>
          <target state="translated">누군가 컨텍스트를 얻으려고 할 때마다 호출되는 콜백을 추가하십시오. 이것은 &lt;code&gt;context()&lt;/code&gt; 에 대한 모든 호출에서 호출됩니다 . 컨텍스트를 구성하는 데 사용되는 매개 변수의 해시에 대한 참조 인 단일 인수를 가져옵니다. 해시를 직접 변경하여 매개 변수를 변경할 수있는 기회입니다.</target>
        </trans-unit>
        <trans-unit id="b76112279c4d7bc08a8f88058538f47580626a20" translate="yes" xml:space="preserve">
          <source>Add a callback that will be called when Test2 is finished loading. This means the callback will be run once, the first time a context is obtained. If Test2 has already finished loading then the callback will be run immediately.</source>
          <target state="translated">Test2가로드를 마쳤을 때 호출 될 콜백을 추가합니다. 이는 콜백이 컨텍스트를 처음 획득 할 때 한 번 실행됨을 의미합니다. Test2가 이미로드를 완료 한 경우 콜백이 즉시 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="6c9a55f0f275296ddc5fae317fffb28dd8faf3e9" translate="yes" xml:space="preserve">
          <source>Add a context init callback. Subs are called every time a context is created. Subs get the newly created context as their only argument.</source>
          <target state="translated">컨텍스트 초기화 콜백을 추가하십시오. 컨텍스트가 생성 될 때마다 Subs가 호출됩니다. Subs는 새로 생성 된 컨텍스트를 유일한 인수로받습니다.</target>
        </trans-unit>
        <trans-unit id="92a9d15f510d34d9b2e6669f1f7ddc09f3797c7e" translate="yes" xml:space="preserve">
          <source>Add a context release callback. Subs are called every time a context is released. Subs get the released context as their only argument. These callbacks should not call release on the context.</source>
          <target state="translated">컨텍스트 해제 콜백을 추가합니다. 컨텍스트가 해제 될 때마다 Subs가 호출됩니다. 구독자는 공개 된 컨텍스트를 유일한 인수로받습니다. 이러한 콜백은 컨텍스트에서 release를 호출해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="9047e2284dc63577e7faf2c89a8809b765789014" translate="yes" xml:space="preserve">
          <source>Add a filter to filter stack for the database, &lt;code&gt;$db&lt;/code&gt; . The three formats vary only in whether they apply to the DBM key, the DBM value or both.</source>
          <target state="translated">데이터베이스 &lt;code&gt;$db&lt;/code&gt; 대해 필터 스택을 필터하기 위해 필터를 추가하십시오 . 세 가지 형식은 DBM 키, DBM 값 또는 둘 다에 적용되는지에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="bdf9eb84aa78037b25d26e93ea6cdce8aea560bd" translate="yes" xml:space="preserve">
          <source>Add a filter to filter stack for the database, &lt;code&gt;$db&lt;/code&gt;. The three formats vary only in whether they apply to the DBM key, the DBM value or both.</source>
          <target state="translated">&lt;code&gt;$db&lt;/code&gt; 데이터베이스의 필터 스택에 필터를 추가하십시오 . 세 가지 형식은 DBM 키, DBM 값 또는 둘 다에 적용되는지 여부 만 다릅니다.</target>
        </trans-unit>
        <trans-unit id="c38d7316ecf7229664ad9222ed91f94becc25544" translate="yes" xml:space="preserve">
          <source>Add a formatter to the list. Last formatter added is used at initialization. If this is called after initialization a warning will be issued.</source>
          <target state="translated">목록에 포맷터를 추가하십시오. 추가 된 마지막 포맷터는 초기화시 사용됩니다. 초기화 후 호출하면 경고가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="4c67e221c9600dff222d68e72c24b75b35131a9f" translate="yes" xml:space="preserve">
          <source>Add a formatter. The most recently added formatter will become the global one during initialization. If a formatter is added after initialization has occurred a warning will be generated:</source>
          <target state="translated">포맷터를 추가하십시오. 가장 최근에 추가 된 포맷터는 초기화 중에 전역 포맷터가됩니다. 초기화가 발생한 후 포맷터가 추가되면 경고가 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="8ccc393bac52be3d964bfe9d752d1239af48b643" translate="yes" xml:space="preserve">
          <source>Add a global watch-expression. Whenever a watched global changes the debugger will stop and display the old and new values.</source>
          <target state="translated">글로벌 시계 식을 추가하십시오. 감시 된 전역 변경이있을 때마다 디버거가 중지되고 이전 값과 새 값이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="53d906e02ac64f82dea46944febfd026f128fa47" translate="yes" xml:space="preserve">
          <source>Add a new item to the cache. Without arguments, this method returns a list of all cache elements.</source>
          <target state="translated">캐시에 새 항목을 추가하십시오. 인수가 없으면이 메소드는 모든 캐시 요소의 목록을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="a7863f951963cec6a01e64fc9352ec7f1fe9c51d" translate="yes" xml:space="preserve">
          <source>Add a node (or a list of nodes) to the document's node list. Note that the order is kept, i.e. start with the first node and end with the last. If no argument is given, the current list of nodes is returned in the same order the nodes have been added. A node can be any scalar, but usually is a pair of node string and unique id for the &lt;code&gt;find_node&lt;/code&gt; method to work correctly.</source>
          <target state="translated">문서의 노드 목록에 노드 (또는 노드 목록)를 추가하십시오. 순서는 유지됩니다. 즉 첫 번째 노드로 시작하여 마지막 노드로 끝납니다. 인수가 제공되지 않으면 현재 노드 목록이 노드가 추가 된 순서와 동일한 순서로 리턴됩니다. 노드는 임의의 스칼라 일 수 있지만 일반적으로 &lt;code&gt;find_node&lt;/code&gt; 메소드가 올바르게 작동하기 위한 한 쌍의 노드 문자열 및 고유 ID입니다 .</target>
        </trans-unit>
        <trans-unit id="046e6f32f7f8535671af5b7c0861397ffbbc2a30" translate="yes" xml:space="preserve">
          <source>Add a post-load callback. If &lt;code&gt;load()&lt;/code&gt; has already been called then the callback will be immediately executed. If &lt;code&gt;load()&lt;/code&gt; has not been called then the callback will be stored and executed later when &lt;code&gt;load()&lt;/code&gt; is called.</source>
          <target state="translated">로드 후 콜백을 추가합니다. 경우 &lt;code&gt;load()&lt;/code&gt; 벌써 호출 된 콜백이 즉시 실행됩니다. 경우 &lt;code&gt;load()&lt;/code&gt; 를 호출 해되지 않은 콜백 저장 될 때 나중에 실행 &lt;code&gt;load()&lt;/code&gt; 호출된다.</target>
        </trans-unit>
        <trans-unit id="db33b0fd6386c3654a2e1eada103554324a64291" translate="yes" xml:space="preserve">
          <source>Add a pre-subtest callback. Subs are called every time a subtest is going to be run. Subs get the subtest name, coderef, and any arguments.</source>
          <target state="translated">사전 하위 테스트 콜백을 추가합니다. 서브 테스트가 실행될 때마다 서브가 호출됩니다. Subs는 하위 테스트 이름, 코드 참조 및 모든 인수를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="db481968c59a6adf87aa66b0a382f55c4cfeb499" translate="yes" xml:space="preserve">
          <source>Add a pretty-printer method to the module</source>
          <target state="translated">모듈에 예쁜 프린터 방법 추가</target>
        </trans-unit>
        <trans-unit id="b48e494719a297be81c5a3a9a30374bc318e93d9" translate="yes" xml:space="preserve">
          <source>Add a signal to a SigSet object.</source>
          <target state="translated">신호를 SigSet 객체에 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="abc744015695856d4c128987382f3ede0cf9f0fd" translate="yes" xml:space="preserve">
          <source>Add a sub to the stack. The sub will be called once the current compile-time &quot;scope&quot; is left. Multiple hooks can be added per scope</source>
          <target state="translated">스택에 서브를 추가하십시오. 현재 컴파일 시간 &quot;범위&quot;가 남아 있으면 하위가 호출됩니다. 범위 당 여러 개의 후크를 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="70b454679f6454970d507782ded710647bf0cf50" translate="yes" xml:space="preserve">
          <source>Add additional meta tags here, or blocks of inline CSS or JavaScript (wrapped in the appropriate tags).</source>
          <target state="translated">여기에 메타 태그를 추가하거나 인라인 CSS 또는 JavaScript 블록 (적절한 태그로 래핑)을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="d05603b01199af8d7cec368f69949fd361e906cb" translate="yes" xml:space="preserve">
          <source>Add alternative proposal to the &lt;a href=&quot;#recommends&quot;&gt;&quot;recommends&quot;&lt;/a&gt; field.</source>
          <target state="translated">&lt;a href=&quot;#recommends&quot;&gt;&quot;recommends&quot;&lt;/a&gt; 필드에 대체 제안을 추가 합니다.</target>
        </trans-unit>
        <trans-unit id="3ecfadad24f90f268420ef8859f572907f4ebd35" translate="yes" xml:space="preserve">
          <source>Add an &lt;code&gt;INPUT&lt;/code&gt; entry to the typemap.</source>
          <target state="translated">&lt;code&gt;INPUT&lt;/code&gt; 항목을 typemap에 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="eb0881f49c67243a319f84b547be8360e6690ed3" translate="yes" xml:space="preserve">
          <source>Add an &lt;code&gt;OUTPUT&lt;/code&gt; entry to the typemap. Works exactly the same as &lt;code&gt;add_inputmap&lt;/code&gt;.</source>
          <target state="translated">유형 맵에 &lt;code&gt;OUTPUT&lt;/code&gt; 항목을 추가하십시오 . &lt;code&gt;add_inputmap&lt;/code&gt; 과 정확히 동일하게 작동 합니다.</target>
        </trans-unit>
        <trans-unit id="6f36ef6ed11003d4ee946d87afa944c63fd757d6" translate="yes" xml:space="preserve">
          <source>Add an IPC driver to the list. The most recently added IPC driver will become the global one during initialization. If a driver is added after initialization has occurred a warning will be generated:</source>
          <target state="translated">목록에 IPC 드라이버를 추가하십시오. 가장 최근에 추가 된 IPC 드라이버는 초기화 중에 전역 드라이버가됩니다. 초기화가 발생한 후 드라이버가 추가되면 경고가 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="9a293399a4e50374fc3bc665d292143e00f55dce" translate="yes" xml:space="preserve">
          <source>Add an IPC driver to the list. This will add the driver to the start of the list.</source>
          <target state="translated">목록에 IPC 드라이버를 추가하십시오. 그러면 목록 시작 부분에 드라이버가 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="97aac284feaa85ca8cb91bcc63adaf65d2ec487a" translate="yes" xml:space="preserve">
          <source>Add an action (Perl command) to happen before every debugger prompt. A multi-line command may be entered by backwhacking the newlines.</source>
          <target state="translated">모든 디버거 프롬프트 전에 발생하는 조치 (Perl 명령)를 추가하십시오. 줄 바꿈을 backwhack하여 여러 줄 명령을 입력 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8abdf94b4d37de8dda8c5f5f2c3f6875f8d6cc2b" translate="yes" xml:space="preserve">
          <source>Add an action (debugger command) to happen before every debugger prompt. A multi-line command may be entered, if you can guess how: see above.</source>
          <target state="translated">모든 디버거 프롬프트 전에 수행 할 조치 (디버거 명령)를 추가하십시오. 방법을 추측 할 수있는 경우 여러 줄 명령을 입력 할 수 있습니다 (위 참조).</target>
        </trans-unit>
        <trans-unit id="b360d12a8c74ac3399385ff08d839994a5e14d6f" translate="yes" xml:space="preserve">
          <source>Add an exit callback. This callback will be called by &lt;code&gt;set_exit()&lt;/code&gt;.</source>
          <target state="translated">이탈 콜백을 추가합니다. 이 콜백은 &lt;code&gt;set_exit()&lt;/code&gt; 의해 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="f54d96a7a4eeff516086a73ed0f2969f141d74af" translate="yes" xml:space="preserve">
          <source>Add an index entry (or a list of them) to the document's index list. Note that the order is kept, i.e. start with the first node and end with the last. If no argument is given, the current list of index entries is returned in the same order the entries have been added. An index entry can be any scalar, but usually is a pair of string and unique id.</source>
          <target state="translated">색인 항목 (또는 그 목록)을 문서의 색인 목록에 추가하십시오. 순서는 유지됩니다. 즉 첫 번째 노드로 시작하여 마지막 노드로 끝납니다. 인수가 제공되지 않으면 항목이 추가 된 순서와 동일한 순서로 현재 색인 항목 목록이 리턴됩니다. 인덱스 항목은 스칼라 일 수 있지만 일반적으로 문자열과 고유 ID 쌍입니다.</target>
        </trans-unit>
        <trans-unit id="5616f22797b70b920c0fa62b5c1b757dfad0f607" translate="yes" xml:space="preserve">
          <source>Add any user-visible changes since the last release to your</source>
          <target state="translated">마지막 릴리스 이후 사용자가 볼 수있는 변경 사항을</target>
        </trans-unit>
        <trans-unit id="590b7a309d0f6d30b6eb1e4e5ab86b934b9e4cae" translate="yes" xml:space="preserve">
          <source>Add blib/* directories to @INC</source>
          <target state="translated">@INC에 blib / * 디렉토리 추가</target>
        </trans-unit>
        <trans-unit id="169a520f5b682ca9f865299c14fd2b5069cb099b" translate="yes" xml:space="preserve">
          <source>Add comments to the code explaining what you are testing for.</source>
          <target state="translated">테스트 대상을 설명하는 코드에 주석을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="de73e94e79dc3842d720fa32f69c99c36f54b7ec" translate="yes" xml:space="preserve">
          <source>Add data to hash when needed</source>
          <target state="translated">필요할 때 해시 할 데이터 추가</target>
        </trans-unit>
        <trans-unit id="feb3fc6fc0c77a11d7269c731b48b816c468c95b" translate="yes" xml:space="preserve">
          <source>Add flock() emulation using IDOS-&amp;gt;LockRecord thanks to Tony Cook for the suggestion.</source>
          <target state="translated">제안에 대한 Tony Cook 덕분에 IDOS-&amp;gt; LockRecord를 사용하여 flock () 에뮬레이션을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="c921fe11e2046d24652b8326a08d772aaf68c1c3" translate="yes" xml:space="preserve">
          <source>Add handling of NIL: to afstat()</source>
          <target state="translated">NIL 처리 추가 : afstat ()</target>
        </trans-unit>
        <trans-unit id="18c78e5255c3f304ba94a974b8fe59d440463b52" translate="yes" xml:space="preserve">
          <source>Add proposal for &lt;code&gt;auto_regenerate&lt;/code&gt; field.</source>
          <target state="translated">&lt;code&gt;auto_regenerate&lt;/code&gt; 필드에 대한 제안을 추가 합니다.</target>
        </trans-unit>
        <trans-unit id="1cac8cfdc9bc441ce91f87d33692898aa9f930b0" translate="yes" xml:space="preserve">
          <source>Add proposal for a &lt;code&gt;requires_build_tools&lt;/code&gt; field.</source>
          <target state="translated">&lt;code&gt;requires_build_tools&lt;/code&gt; 필드에 대한 제안을 추가 합니다.</target>
        </trans-unit>
        <trans-unit id="72d8179b381afab6c39843333e65697de042456c" translate="yes" xml:space="preserve">
          <source>Add the following to the end of Mytest.xs:</source>
          <target state="translated">Mytest.xs 끝에 다음을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="9f9a937939c6d51d4a74436ba1cd4f9a4a86f81c" translate="yes" xml:space="preserve">
          <source>Add the list of handles to the &lt;code&gt;IO::Select&lt;/code&gt; object. It is these values that will be returned when an event occurs. &lt;code&gt;IO::Select&lt;/code&gt; keeps these values in a cache which is indexed by the &lt;code&gt;&lt;a href=&quot;../functions/fileno&quot;&gt;fileno&lt;/a&gt;&lt;/code&gt; of the handle, so if more than one handle with the same &lt;code&gt;&lt;a href=&quot;../functions/fileno&quot;&gt;fileno&lt;/a&gt;&lt;/code&gt; is specified then only the last one is cached.</source>
          <target state="translated">핸들 목록을 &lt;code&gt;IO::Select&lt;/code&gt; 오브젝트에 추가 하십시오 . 이벤트가 발생할 때 리턴되는 값입니다. &lt;code&gt;IO::Select&lt;/code&gt; 는 핸들 의 &lt;code&gt;&lt;a href=&quot;../functions/fileno&quot;&gt;fileno&lt;/a&gt;&lt;/code&gt; 에 의해 인덱스 된 캐시에이 값을 유지 하므로, 같은 &lt;code&gt;&lt;a href=&quot;../functions/fileno&quot;&gt;fileno&lt;/a&gt;&lt;/code&gt; 를 가진 핸들이 둘 이상 지정된 경우 마지막 핸들 만 캐시됩니다.</target>
        </trans-unit>
        <trans-unit id="f4567144045299065c0165e151f58f272a347489" translate="yes" xml:space="preserve">
          <source>Add the list of handles to the &lt;code&gt;IO::Select&lt;/code&gt; object. It is these values that will be returned when an event occurs. &lt;code&gt;IO::Select&lt;/code&gt; keeps these values in a cache which is indexed by the &lt;code&gt;fileno&lt;/code&gt; of the handle, so if more than one handle with the same &lt;code&gt;fileno&lt;/code&gt; is specified then only the last one is cached.</source>
          <target state="translated">&lt;code&gt;IO::Select&lt;/code&gt; 객체 에 핸들 목록을 추가 합니다. 이벤트가 발생할 때 반환되는 값입니다. &lt;code&gt;IO::Select&lt;/code&gt; 는 핸들 의 &lt;code&gt;fileno&lt;/code&gt; 에 의해 인덱싱되는 캐시에 이러한 값을 유지 하므로 동일한 &lt;code&gt;fileno&lt;/code&gt; 를 가진 핸들이 둘 이상 지정되면 마지막 핸들 만 캐시됩니다.</target>
        </trans-unit>
        <trans-unit id="19f0b9a66897495c95aa10ee537c78ed856fd477" translate="yes" xml:space="preserve">
          <source>Add to your standard heading the following line:</source>
          <target state="translated">표준 제목에 다음 줄을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="08fc6af7d08fe5cff7ab3490908c8640f386f6f4" translate="yes" xml:space="preserve">
          <source>AddSubtract</source>
          <target state="translated">AddSubtract</target>
        </trans-unit>
        <trans-unit id="3d6444577bf119188b692f7bca855faa55a2401d" translate="yes" xml:space="preserve">
          <source>Added 'configure_requires' prerequisite type</source>
          <target state="translated">'configure_requires'전제 조건 유형 추가</target>
        </trans-unit>
        <trans-unit id="a64389ac9912e7d874e9b87db88fd58e122c0a0c" translate="yes" xml:space="preserve">
          <source>Added 'description' field for a longer description of the distribution</source>
          <target state="translated">배포에 대한 자세한 설명을 위해 '설명'필드를 추가했습니다.</target>
        </trans-unit>
        <trans-unit id="1aa6cacba4287823c21f5d5fd2353063c1ac8e55" translate="yes" xml:space="preserve">
          <source>Added 'keywords' field</source>
          <target state="translated">'키워드'필드 추가</target>
        </trans-unit>
        <trans-unit id="0e9df52fa1aa964d76c90813e2eab9d3c259770e" translate="yes" xml:space="preserve">
          <source>Added 'license_uri' field</source>
          <target state="translated">'license_uri'필드 추가</target>
        </trans-unit>
        <trans-unit id="836b1a4388e88eeef5b74e9af391dd06f54dc0ee" translate="yes" xml:space="preserve">
          <source>Added 'no_index' field and deprecated 'private' field. 'no_index' subkeys include 'file', 'dir', 'package' and 'namespace'</source>
          <target state="translated">'no_index'필드가 추가되고 '비공개'필드가 더 이상 사용되지 않습니다. 'no_index'하위 키에는 'file', 'dir', 'package'및 'namespace'가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="6a7fc17196989ffd6c55efc59972b7c53f7a3074" translate="yes" xml:space="preserve">
          <source>Added 'no_index' subkey 'directory' and removed 'dir' to match actual usage in the wild</source>
          <target state="translated">'no_index'하위 키 'directory'를 추가하고 'dir'을 제거하여 실제 사용과 일치하도록했습니다.</target>
        </trans-unit>
        <trans-unit id="7b01f92f459037312156b80744af7b20b7e23dc2" translate="yes" xml:space="preserve">
          <source>Added 'optional_features' field as an alternate under 'recommends'. Includes 'description', 'requires', 'build_requires', 'conflicts', 'requires_packages', 'requires_os' and 'excluded_os' as valid subkeys</source>
          <target state="translated">'recommends'아래에 'optional_features'필드가 대체 항목으로 추가되었습니다. 'description', 'requires', 'build_requires', 'conflicts', 'requires_packages', 'requires_os'및 'excluded_os'를 유효한 하위 키로 포함합니다.</target>
        </trans-unit>
        <trans-unit id="089abe8a28d09c43e8df68d5ec8f1f94d55fc4ae" translate="yes" xml:space="preserve">
          <source>Added 'private' field</source>
          <target state="translated">'비공개'필드 추가</target>
        </trans-unit>
        <trans-unit id="fdbb2058f98214a8d0241c7078a64d1d419ff315" translate="yes" xml:space="preserve">
          <source>Added 'provides' field</source>
          <target state="translated">'제공'필드 추가</target>
        </trans-unit>
        <trans-unit id="bdaa02362b8a343ff6228234d4ebd21baae0da33" translate="yes" xml:space="preserve">
          <source>Added 'release_status' field to indicate stable, testing or unstable status to provide hints to indexers</source>
          <target state="translated">인덱서에게 힌트를 제공하기 위해 안정, 테스트 또는 불안정 상태를 나타내는 'release_status'필드 추가</target>
        </trans-unit>
        <trans-unit id="4fe305328f9e4d7c6ec73fba7119f6482115cd60" translate="yes" xml:space="preserve">
          <source>Added 'resources' field with subkeys 'homepage', 'license', and 'bugtracker'</source>
          <target state="translated">'homepage', 'license'및 'bugtracker'하위 키가있는 'resources'필드 추가</target>
        </trans-unit>
        <trans-unit id="e144afdecf936badd362db9d94925954fc2bd138" translate="yes" xml:space="preserve">
          <source>Added &lt;a href=&quot;#abstract&quot;&gt;&quot;abstract&quot;&lt;/a&gt;, &lt;code&gt;configure&lt;/code&gt;, &lt;code&gt;requires_packages&lt;/code&gt;, &lt;code&gt;requires_os&lt;/code&gt;, &lt;code&gt;excludes_os&lt;/code&gt;, and &lt;a href=&quot;#no_index&quot;&gt;&quot;no_index&quot;&lt;/a&gt; fields.</source>
          <target state="translated">추가 된 &lt;a href=&quot;#abstract&quot;&gt;&quot;추상적&quot;&lt;/a&gt; , &lt;code&gt;configure&lt;/code&gt; , &lt;code&gt;requires_packages&lt;/code&gt; , &lt;code&gt;requires_os&lt;/code&gt; , &lt;code&gt;excludes_os&lt;/code&gt; 및 &lt;a href=&quot;#no_index&quot;&gt;&quot;no_index&quot;&lt;/a&gt; 필드.</target>
        </trans-unit>
        <trans-unit id="f63a9f5b36cd2185deceb95d3838a3926221e452" translate="yes" xml:space="preserve">
          <source>Added &lt;a href=&quot;#configure_requires&quot;&gt;&quot;configure_requires&quot;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#configure_requires&quot;&gt;&quot;configure_requires&quot;가&lt;/a&gt; 추가되었습니다 .</target>
        </trans-unit>
        <trans-unit id="91872b27306847166639d5e97330092ac7f4702a" translate="yes" xml:space="preserve">
          <source>Added &lt;code&gt;generation&lt;/code&gt;, &lt;code&gt;authored_by&lt;/code&gt; fields.</source>
          <target state="translated">&lt;code&gt;generation&lt;/code&gt; , &lt;code&gt;authored_by&lt;/code&gt; 필드가 추가되었습니다 .</target>
        </trans-unit>
        <trans-unit id="0a13f7aff584c83ebd1f9e84aae7b2d05d441e1f" translate="yes" xml:space="preserve">
          <source>Added &lt;code&gt;gztell&lt;/code&gt; .</source>
          <target state="translated">추가는 &lt;code&gt;gztell&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9d4e868f6631cb6b06a89e903757a8fcec841335" translate="yes" xml:space="preserve">
          <source>Added &lt;code&gt;gztell&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;gztell&lt;/code&gt; 을 추가했습니다 .</target>
        </trans-unit>
        <trans-unit id="ce4b7af5325c29b096cd0fa09b8e779e19ca7f6b" translate="yes" xml:space="preserve">
          <source>Added Amiga::Exec module with support for Wait() and AmigaOS signal numbers.</source>
          <target state="translated">Wait () 및 AmigaOS 신호 번호를 지원하는 Amiga :: Exec 모듈을 추가했습니다.</target>
        </trans-unit>
        <trans-unit id="690a903901c99f8294efdf7dfc5b9fb2e1a30517" translate="yes" xml:space="preserve">
          <source>Added a 'repository' subkey to 'resources'</source>
          <target state="translated">'자원'에 '저장소'하위 키를 추가했습니다.</target>
        </trans-unit>
        <trans-unit id="1529d69cfb2ad95dc93ff6b487c63438f267d03b" translate="yes" xml:space="preserve">
          <source>Added and deprecated the &lt;a href=&quot;#private&quot;&gt;&quot;private&quot;&lt;/a&gt; field.</source>
          <target state="translated">&lt;a href=&quot;#private&quot;&gt;&quot;비공개&quot;&lt;/a&gt; 필드가 추가 및 사용되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="a7467424ca435e045670d53563f164da161e1c7c" translate="yes" xml:space="preserve">
          <source>Added formal specification and usage guide instead of just example</source>
          <target state="translated">예시가 아닌 공식 사양 및 사용 가이드 추가</target>
        </trans-unit>
        <trans-unit id="1095a22478b4b66c2ae56250f944a8bfc247cdff" translate="yes" xml:space="preserve">
          <source>Added in perl 5.18.0, this flag indicates that a regular expression might perform an operation that would interfere with inplace substitution. For instance it might contain lookbehind, or assign to non-magical variables (such as $REGMARK and $REGERROR) during matching. &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt; will skip certain optimisations when this is set.</source>
          <target state="translated">perl 5.18.0에 추가 된이 플래그는 정규식이 대체 대체를 방해하는 조작을 수행 할 수 있음을 나타냅니다. 예를 들어 일치하는 동안 lookbehind를 포함하거나 마술이 아닌 변수 (예 : $ REGMARK 및 $ REGERROR)에 할당 할 수 있습니다. 이것이 설정되면 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt; 는 특정 최적화를 건너 뜁니다.</target>
        </trans-unit>
        <trans-unit id="277baaafd4042af758d6c63f3238b401fdd8bfc3" translate="yes" xml:space="preserve">
          <source>Added in perl 5.18.0, this flag indicates that a regular expression might perform an operation that would interfere with inplace substitution. For instance it might contain lookbehind, or assign to non-magical variables (such as $REGMARK and $REGERROR) during matching. &lt;code&gt;s///&lt;/code&gt; will skip certain optimisations when this is set.</source>
          <target state="translated">perl 5.18.0에 추가 된이 플래그는 정규식이 인플레 이스 대체를 방해하는 작업을 수행 할 수 있음을 나타냅니다. 예를 들어 lookbehind를 포함하거나 일치하는 동안 마법이 아닌 변수 (예 : $ REGMARK 및 $ REGERROR)에 할당 할 수 있습니다. &lt;code&gt;s///&lt;/code&gt; 가 설정되면 특정 최적화를 건너 뜁니다.</target>
        </trans-unit>
        <trans-unit id="b1d56423c29f7196bca0ef1618ba2dd3e888861c" translate="yes" xml:space="preserve">
          <source>Added in perl 5.22, this method returns the B::REGEXP associated with the op. While PMOPs do not actually have &lt;code&gt;pmregexp&lt;/code&gt; fields under threaded builds, this method returns the regexp under threads nonetheless, for convenience.</source>
          <target state="translated">perl 5.22에 추가 된이 메소드는 op와 연관된 B :: REGEXP를 리턴합니다. PMOP에는 스레드 빌드에서 실제로 &lt;code&gt;pmregexp&lt;/code&gt; 필드 가 없지만 이 메소드는 편의상 스레드에서 regexp를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="f51a6b7957e9c7cb904dc99843449a531ea1b689" translate="yes" xml:space="preserve">
          <source>Added in version 2.134.</source>
          <target state="translated">버전 2.134에 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="6b91664e6fd3b4816eccf4d391f086ad14efff2a" translate="yes" xml:space="preserve">
          <source>Added link to latest version of this specification on CPAN.</source>
          <target state="translated">CPAN에서이 사양의 최신 버전에 대한 링크를 추가했습니다.</target>
        </trans-unit>
        <trans-unit id="6bcf643636b7398a8e0e54e9c9fc1d9273c2b5e2" translate="yes" xml:space="preserve">
          <source>Added more YAML rationale articles.</source>
          <target state="translated">더 많은 YAML 근거 문서를 추가했습니다.</target>
        </trans-unit>
        <trans-unit id="33305109558673a1c9c69c1f25a4c2df594e30a8" translate="yes" xml:space="preserve">
          <source>Added required 'abstract' field</source>
          <target state="translated">필수 '추상'필드 추가</target>
        </trans-unit>
        <trans-unit id="af726294af9dc1265c8d0f3857527e7304abd333" translate="yes" xml:space="preserve">
          <source>Added required 'author' field</source>
          <target state="translated">필수 '저자'필드 추가</target>
        </trans-unit>
        <trans-unit id="e7866b1d9634973b54410fb3b09a8870c6e12c54" translate="yes" xml:space="preserve">
          <source>Added required 'meta-spec' field to define 'version' (and 'url') of the CPAN Meta Spec used for metadata</source>
          <target state="translated">메타 데이터에 사용되는 CPAN 메타 스펙의 '버전'(및 'URL')을 정의하기 위해 필수 '메타 스펙'필드가 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="bd2cc0964d8a12be83f56ab3950ae68e29c591b1" translate="yes" xml:space="preserve">
          <source>Added section &lt;a href=&quot;#VERSION-SPECIFICATIONS&quot;&gt;&quot;VERSION SPECIFICATIONS&quot;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#VERSION-SPECIFICATIONS&quot;&gt;&quot;버전 사양&quot;&lt;/a&gt; 섹션을 추가했습니다 .</target>
        </trans-unit>
        <trans-unit id="aef233fbd4347044329187d2b8f1ce4f52792b2d" translate="yes" xml:space="preserve">
          <source>Added support for 'develop' phase for requirements for maintaining a list of authoring tools</source>
          <target state="translated">저작 도구 목록을 유지하기위한 요구 사항에 대한 '개발'단계에 대한 지원이 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="4067cf30df05475c0b1f2362ec92ff1b94229189" translate="yes" xml:space="preserve">
          <source>Added the &quot;==&quot; operator to the list of supported version-checking operators.</source>
          <target state="translated">지원되는 버전 확인 연산자 목록에 &quot;==&quot;연산자를 추가했습니다.</target>
        </trans-unit>
        <trans-unit id="e23a873d3fc017deb2d7810db7b45a18d9b23384" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;#dynamic_config&quot;&gt;&quot;dynamic_config&quot;&lt;/a&gt; field, which was missing from the initial version.</source>
          <target state="translated">초기 버전에서 누락 된 &lt;a href=&quot;#dynamic_config&quot;&gt;&quot;dynamic_config&quot;&lt;/a&gt; 필드를 추가했습니다 .</target>
        </trans-unit>
        <trans-unit id="c21ca5e20439791dc77b0976300391ca4c56a8d6" translate="yes" xml:space="preserve">
          <source>Added version range specifications for prerequisites</source>
          <target state="translated">전제 조건에 대한 추가 된 버전 범위 사양</target>
        </trans-unit>
        <trans-unit id="2ba88f457f4acc695f5bcc5b53d0aed8e9a2a045" translate="yes" xml:space="preserve">
          <source>Adder</source>
          <target state="translated">Adder</target>
        </trans-unit>
        <trans-unit id="6d548b5512a4a3be1ad17c320cc40231db228d55" translate="yes" xml:space="preserve">
          <source>Adding &lt;code&gt;\W*&lt;/code&gt; at either end to eliminate what is to be ignored, we already have the full pattern:</source>
          <target state="translated">무시할 대상을 제거하기 위해 양쪽 끝에 &lt;code&gt;\W*&lt;/code&gt; 를 추가하면 이미 전체 패턴이 있습니다.</target>
        </trans-unit>
        <trans-unit id="75c6e513c1fb807d0884fb4286f8d06fe79494da" translate="yes" xml:space="preserve">
          <source>Adding a Copyright Notice.</source>
          <target state="translated">저작권 고지 추가.</target>
        </trans-unit>
        <trans-unit id="303fa6167f30afc58e107870ab55bef298f595d5" translate="yes" xml:space="preserve">
          <source>Adding a Perl interpreter to your C program</source>
          <target state="translated">C 프로그램에 Perl 인터프리터 추가</target>
        </trans-unit>
        <trans-unit id="3494708836bea1e13cb2fb34de6c0bb041485662" translate="yes" xml:space="preserve">
          <source>Adding a colon &quot;:&quot; or empty string &quot;&quot; to a path at</source>
          <target state="translated">경로에 콜론 &quot;:&quot;또는 빈 문자열 &quot;&quot;추가</target>
        </trans-unit>
        <trans-unit id="a53e4c0ef202bbd1f27920e920bc75f378ee45c9" translate="yes" xml:space="preserve">
          <source>Adding directories to @INC</source>
          <target state="translated">@INC에 디렉토리 추가</target>
        </trans-unit>
        <trans-unit id="32ef945c8ba780a6b4dd45ed8eb3b208531a653f" translate="yes" xml:space="preserve">
          <source>Adding hints to your module</source>
          <target state="translated">모듈에 힌트 추가</target>
        </trans-unit>
        <trans-unit id="ba2cfa47677f2dc11ab18dec23c28080c249d55d" translate="yes" xml:space="preserve">
          <source>Adding libraries</source>
          <target state="translated">라이브러리 추가</target>
        </trans-unit>
        <trans-unit id="b8ef134eb6c634200333aedff61c4a77cc1d0006" translate="yes" xml:space="preserve">
          <source>Adding new core tests</source>
          <target state="translated">새로운 핵심 테스트 추가</target>
        </trans-unit>
        <trans-unit id="b80f8c556c16b44d25bfbabc5e3f14bb1ae5d40d" translate="yes" xml:space="preserve">
          <source>Adding non-comment stuff after #endif or #else</source>
          <target state="translated">#endif 또는 #else 뒤에 주석이 아닌 내용 추가</target>
        </trans-unit>
        <trans-unit id="65ffd7a09837afed5bf94ab1e1f31e15cc6844fb" translate="yes" xml:space="preserve">
          <source>Adding, deprecating, or removing core features</source>
          <target state="translated">핵심 기능 추가, 폐기 또는 제거</target>
        </trans-unit>
        <trans-unit id="dd881a1fe5170572b503d70ad2a1b006df408296" translate="yes" xml:space="preserve">
          <source>Adding, deprecating, removing, or upgrading core or dual-life modules</source>
          <target state="translated">코어 또는 이중 수명 모듈 추가, 폐기, 제거 또는 업그레이드</target>
        </trans-unit>
        <trans-unit id="aa19c6fc6789672e5ea06b36cec0c6ea7c8038fa" translate="yes" xml:space="preserve">
          <source>Adding, removing, or significantly changing documentation in the</source>
          <target state="translated">문서를 추가, 제거 또는 크게 변경</target>
        </trans-unit>
        <trans-unit id="1d418e4d86845beab5da12aea1ba94a51ff3bc29" translate="yes" xml:space="preserve">
          <source>Addition of &lt;code&gt;gzseek&lt;/code&gt; to provide a restricted &lt;code&gt;&lt;a href=&quot;../functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt; interface.</source>
          <target state="translated">제한된 &lt;code&gt;&lt;a href=&quot;../functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt; 인터페이스 를 제공하기 위해 &lt;code&gt;gzseek&lt;/code&gt; 추가</target>
        </trans-unit>
        <trans-unit id="6552e79b6f2eba5d2c1c59df8b89aa7a3c1b078e" translate="yes" xml:space="preserve">
          <source>Addition of &lt;code&gt;gzseek&lt;/code&gt; to provide a restricted &lt;code&gt;seek&lt;/code&gt; interface.</source>
          <target state="translated">제한된 &lt;code&gt;seek&lt;/code&gt; 인터페이스 를 제공하기 위해 &lt;code&gt;gzseek&lt;/code&gt; 가 추가되었습니다 .</target>
        </trans-unit>
        <trans-unit id="c4dffe7b821c26dcbff0441f525605b623db0150" translate="yes" xml:space="preserve">
          <source>Additional Perl modules</source>
          <target state="translated">추가 Perl 모듈</target>
        </trans-unit>
        <trans-unit id="21cbac17404588ed0f4a75e1ba94b2723810229c" translate="yes" xml:space="preserve">
          <source>Additional allowable exit values can be supplied as an optional first argument to autodying &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">추가 허용 종료 값은 자동 염색 &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; 대한 선택적 첫 번째 인수로 제공 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f48107467db8714a6cbff8faff6baadd1f1ad23c" translate="yes" xml:space="preserve">
          <source>Additional allowable exit values can be supplied as an optional first argument to autodying &lt;code&gt;system&lt;/code&gt;:</source>
          <target state="translated">추가 허용 종료 값은 자동 염색 &lt;code&gt;system&lt;/code&gt; 대한 선택적 첫 번째 인수로 제공 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="95fcc23a5989c1d4707ef062b9c48e30e43e8eea" translate="yes" xml:space="preserve">
          <source>Additional arbitrary HTML tags for the header of the document. The default value is just a content type header tag:</source>
          <target state="translated">문서 헤더에 대한 추가 임의 HTML 태그 기본값은 컨텐츠 유형 헤더 태그입니다.</target>
        </trans-unit>
        <trans-unit id="d31c04c6385ec69608dc7b1dbfd4b8783d00f7f6" translate="yes" xml:space="preserve">
          <source>Additional beginning whitespace (beyond what preceded the delimiter) will be preserved:</source>
          <target state="translated">추가 시작 공백 (구분자 앞의 공백을 넘어서)은 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="93ccf6b3b0fed7eda8c1cf492ae71f85cc3c2416" translate="yes" xml:space="preserve">
          <source>Additional behaviors can be added to your &lt;code&gt;&lt;a href=&quot;../../functions/import&quot;&gt;import()&lt;/a&gt;&lt;/code&gt; method by overriding &lt;code&gt;import_extra()&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;import_extra()&lt;/code&gt; 를 재정 의하여 &lt;code&gt;&lt;a href=&quot;../../functions/import&quot;&gt;import()&lt;/a&gt;&lt;/code&gt; 메소드에 추가 동작을 추가 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fda1dbde949fe80b65f11ed406dd46d7077f6407" translate="yes" xml:space="preserve">
          <source>Additional behaviors can be added to your &lt;code&gt;import()&lt;/code&gt; method by overriding &lt;code&gt;import_extra()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;import_extra()&lt;/code&gt; 를 재정 의하여 &lt;code&gt;import()&lt;/code&gt; 메서드에 추가 비헤이비어를 추가 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b69974bf6d56e57936d88d6a5f708b80a863eea6" translate="yes" xml:space="preserve">
          <source>Additional code by Yves Orton.</source>
          <target state="translated">Yves Orton의 추가 코드.</target>
        </trans-unit>
        <trans-unit id="07c4a7582a6b085c26b5bc77e2d781374f6214f8" translate="yes" xml:space="preserve">
          <source>Additional context-dependent optimizations are performed at this time. Since at this moment the compile tree contains back-references (via &quot;thread&quot; pointers), nodes cannot be free()d now. To allow optimized-away nodes at this stage, such nodes are null()ified instead of free()ing (i.e. their type is changed to OP_NULL).</source>
          <target state="translated">현재 상황에 따른 추가 최적화가 수행됩니다. 이 시점에서 컴파일 트리에는 &quot;스레드&quot;포인터를 통한 역 참조가 포함되므로 노드를 해제 할 수 없습니다. 이 단계에서 최적화 된 노드를 허용하기 위해 이러한 노드는 free () 대신 널 ()로 지정됩니다 (예 : 유형이 OP_NULL로 변경됨).</target>
        </trans-unit>
        <trans-unit id="31fd46d11c3bbe73ad92eebf33f7553ded695d16" translate="yes" xml:space="preserve">
          <source>Additional contributions by The Perl 5 Porters.</source>
          <target state="translated">The Perl 5 Porters의 추가 공헌</target>
        </trans-unit>
        <trans-unit id="65d277fbf8e91201355e93559429e2b46f057ea7" translate="yes" xml:space="preserve">
          <source>Additional flags to specify to C preprocessor when scanning header for function declarations. Writes these options in the generated</source>
          <target state="translated">함수 선언을 위해 헤더를 스캔 할 때 C 프리 프로세서에 지정할 추가 플래그. 생성 된 옵션에 이러한 옵션을 씁니다.</target>
        </trans-unit>
        <trans-unit id="8fab7fe5b84df4c38b3df13c3aab585166d6f79c" translate="yes" xml:space="preserve">
          <source>Additional flags:</source>
          <target state="translated">추가 플래그 :</target>
        </trans-unit>
        <trans-unit id="224b8dd98beb03b9721f84cf4768d8e500e8a1d7" translate="yes" xml:space="preserve">
          <source>Additional functions not exported by default:</source>
          <target state="translated">기본적으로 내 보내지 않는 추가 기능 :</target>
        </trans-unit>
        <trans-unit id="c00e0d54188b0a52cda35b7ee1e5c81c6e17488d" translate="yes" xml:space="preserve">
          <source>Additional linker arguments to be considered.</source>
          <target state="translated">추가 링커 인수를 고려해야합니다.</target>
        </trans-unit>
        <trans-unit id="c75d2357555d61500cb561ea756aab492ce04979" translate="yes" xml:space="preserve">
          <source>Additional lowercase attributes</source>
          <target state="translated">추가 소문자 속성</target>
        </trans-unit>
        <trans-unit id="62669130426d053245d54e15329b7bbb244bddc3" translate="yes" xml:space="preserve">
          <source>Additional methods that are provided are:</source>
          <target state="translated">제공되는 추가 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c9f0c499a9f295c841e5042dc5fcae68b2718736" translate="yes" xml:space="preserve">
          <source>Additional modules:</source>
          <target state="translated">추가 모듈 :</target>
        </trans-unit>
        <trans-unit id="5cb0cfaa4bee3834bdbab722883416b06bf0e1b8" translate="yes" xml:space="preserve">
          <source>Additional option files may be specified with the &lt;code&gt;--rc&lt;/code&gt; option. Default option file processing is disabled by the &lt;code&gt;--norc&lt;/code&gt; option.</source>
          <target state="translated">&lt;code&gt;--rc&lt;/code&gt; 옵션으로 추가 옵션 파일을 지정할 수 있습니다 . 기본 옵션 파일 처리는 &lt;code&gt;--norc&lt;/code&gt; 옵션에 의해 비활성화됩니다 .</target>
        </trans-unit>
        <trans-unit id="a9910904f4a1f818c8f8c0fa7217add5b79e193c" translate="yes" xml:space="preserve">
          <source>Additional supported functions</source>
          <target state="translated">추가 지원 기능</target>
        </trans-unit>
        <trans-unit id="62f57b1281983cef6c2785663a1426c055f3a73b" translate="yes" xml:space="preserve">
          <source>Additional thanks to: Edward Avis / Mattia Barbon / Tom Christiansen / Gerrit Haase / Gurusamy Sarathy / Jarkko Hietaniemi (again) / Nikola Knezevic / John Kominetz / Nick Ing-Simmons / Tassilo von Parseval / H. Dieter Pearcey / Slaven Rezic / Eric Roode / Peter Scott / Peter Somu / Autrijus Tang (again) / Tels (again) / Juerd Waalboer / Todd Rinaldo</source>
          <target state="translated">추가 감사 : Edward Avis / Mattia Barbon / Tom Christiansen / Gerrit Haase / Gurusamy Sarathy / Jarkko Hietaniemi (다시) / Nikola Knezevic / John Kominetz / Nick Ing-Simmons / Tassilo von Parseval / H. Dieter Pearcey / Slaven Rezic / Eric Roode / Peter Scott / Peter Somu / Autrijus Tang (다시) / Tels (다시) / Juerd Waalboer / Todd Rinaldo</target>
        </trans-unit>
        <trans-unit id="2e074cb542b7d40047c757dcbf8e58304de85a1f" translate="yes" xml:space="preserve">
          <source>Additionally &lt;a href=&quot;#weaken&quot;&gt;&quot;weaken&quot;&lt;/a&gt; and &lt;a href=&quot;#isweak&quot;&gt;&quot;isweak&quot;&lt;/a&gt; which are</source>
          <target state="translated">또한 &lt;a href=&quot;#weaken&quot;&gt;&quot;약화&quot;&lt;/a&gt; 와 &lt;a href=&quot;#isweak&quot;&gt;&quot;isweak을&quot;&lt;/a&gt; 있는</target>
        </trans-unit>
        <trans-unit id="0faa935c5b1efc0ef2a1c52135455cd6a03aa947" translate="yes" xml:space="preserve">
          <source>Additionally &lt;a href=&quot;#weaken&quot;&gt;weaken&lt;/a&gt; and &lt;a href=&quot;#isweak&quot;&gt;isweak&lt;/a&gt; which are</source>
          <target state="translated">또한 &lt;a href=&quot;#weaken&quot;&gt;약화&lt;/a&gt; 및 &lt;a href=&quot;#isweak&quot;&gt;isweak&lt;/a&gt; 있는</target>
        </trans-unit>
        <trans-unit id="670b1ddc67f6054d3b05d014236af978c695794a" translate="yes" xml:space="preserve">
          <source>Additionally,</source>
          <target state="translated">Additionally,</target>
        </trans-unit>
        <trans-unit id="d13e57a8614451ac86ee80ef497567c6c1217ddd" translate="yes" xml:space="preserve">
          <source>Additionally, &lt;code&gt;reg()&lt;/code&gt; is responsible for parsing the one or more branches from the pattern, and for &quot;finishing them off&quot; by correctly setting their next pointers. In order to do the parsing, it repeatedly calls out to &lt;code&gt;regbranch()&lt;/code&gt; , which is responsible for handling up to the first &lt;code&gt;|&lt;/code&gt; symbol it sees.</source>
          <target state="translated">또한 &lt;code&gt;reg()&lt;/code&gt; 는 패턴에서 하나 이상의 분기를 구문 분석하고 다음 포인터를 올바르게 설정하여 &quot;종료&quot;하는 역할을합니다. 구문 분석을 수행하기 위해서는 반복적으로 부른다 &lt;code&gt;regbranch()&lt;/code&gt; 첫까지 처리에 대한 책임, &lt;code&gt;|&lt;/code&gt; 그것이 보이는 상징.</target>
        </trans-unit>
        <trans-unit id="bbe8dc06a5770f240c4afba81e88ad8d5991f28b" translate="yes" xml:space="preserve">
          <source>Additionally, &lt;code&gt;reg()&lt;/code&gt; is responsible for parsing the one or more branches from the pattern, and for &quot;finishing them off&quot; by correctly setting their next pointers. In order to do the parsing, it repeatedly calls out to &lt;code&gt;regbranch()&lt;/code&gt;, which is responsible for handling up to the first &lt;code&gt;|&lt;/code&gt; symbol it sees.</source>
          <target state="translated">또한 &lt;code&gt;reg()&lt;/code&gt; 는 패턴에서 하나 이상의 분기를 구문 분석하고 다음 포인터를 올바르게 설정하여 &quot;종료&quot;를 수행합니다. 구문 분석을 수행하기 위해 반복적으로 &lt;code&gt;regbranch()&lt;/code&gt; 를 호출합니다 . 이는 첫 번째 &lt;code&gt;|&lt;/code&gt; 보이는 상징.</target>
        </trans-unit>
        <trans-unit id="e0e807bcf6cc2e8c544c361c110388bef7a27722" translate="yes" xml:space="preserve">
          <source>Additionally, extra colons can be used to control formatting. A trailing colon suppresses the linefeed and terminator &quot;;&quot;, allowing you to embed queries into shell commands. (mnemonic: PATH separator &quot;:&quot;.)</source>
          <target state="translated">또한 추가 콜론을 사용하여 서식을 제어 할 수 있습니다. 후행 콜론은 줄 바꿈 및 종결 자 &quot;;&quot;를 억제하여 셸 명령에 쿼리를 포함 할 수 있습니다. (니모닉 : PATH separator &quot;:&quot;)</target>
        </trans-unit>
        <trans-unit id="de6bbc1e5f3a3539ae55f22169f7f3d830032c5c" translate="yes" xml:space="preserve">
          <source>Additionally, for more complicated requirements, the specification supports a list of versions, each of which may be optionally preceded by a relational operator.</source>
          <target state="translated">또한 더 복잡한 요구 사항을 위해 사양은 버전 목록을 지원하며, 각 버전은 선택적으로 관계형 연산자가 앞에 올 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e495cf9a286350e9c50957cc8351f8f292fd0e8c" translate="yes" xml:space="preserve">
          <source>Additionally, if the &lt;code&gt;h_errno&lt;/code&gt; variable is supported in C, its value is returned via &lt;code&gt;$?&lt;/code&gt; if any &lt;code&gt;gethost*()&lt;/code&gt; function fails.</source>
          <target state="translated">또한 &lt;code&gt;h_errno&lt;/code&gt; 변수가 C에서 지원되는 경우 해당 값은 &lt;code&gt;$?&lt;/code&gt; 어떤 경우 &lt;code&gt;gethost*()&lt;/code&gt; 함수가 실패.</target>
        </trans-unit>
        <trans-unit id="f146d2cdc65cbc8a75b0db4de74950e484d62ea3" translate="yes" xml:space="preserve">
          <source>Additionally, if the identifier is preceded by a sigil -- that is, if the identifier is part of a variable name -- it may optionally be enclosed in braces.</source>
          <target state="translated">또한 식별자 앞에시길이있을 경우 (즉, 식별자가 변수 이름의 일부인 경우) 선택적으로 중괄호로 묶을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="de325e0c3cf0c3d9113392e69ca77df0f19293fa" translate="yes" xml:space="preserve">
          <source>Additionally, if you quote your initializer, then the quoted value that goes &lt;b&gt;in&lt;/b&gt; will be exactly what comes &lt;b&gt;out&lt;/b&gt; when your $VERSION is printed (stringified). If you do not quote your value, Perl's normal numeric handling comes into play and you may not get back what you were expecting.</source>
          <target state="translated">당신이 당신의 초기화, 이동 한 후 인용 값 인용하는 경우 또한, &lt;b&gt;에&lt;/b&gt; 오는 정확히 될 것입니다 &lt;b&gt;밖으로&lt;/b&gt; 당신의 $ 버전이 인쇄 될 때를 (도 캐릭터 라인). 값을 인용하지 않으면 Perl의 일반적인 숫자 처리가 작동하고 예상했던 값을 얻지 못할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0a9aa35376d4ff22f823726940db699aadebfdc8" translate="yes" xml:space="preserve">
          <source>Additionally, implementations of the standard &lt;a href=&quot;../posix&quot;&gt;POSIX&lt;/a&gt; tmpnam() and tmpfile() functions are provided if required.</source>
          <target state="translated">또한 필요한 경우 표준 &lt;a href=&quot;../posix&quot;&gt;POSIX&lt;/a&gt; tmpnam () 및 tmpfile () 함수의 구현이 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="efb04423e282453ef73b22b8dc7638d920d2d0ae" translate="yes" xml:space="preserve">
          <source>Additionally, implementations of the standard &lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt; tmpnam() and tmpfile() functions are provided if required.</source>
          <target state="translated">또한 필요한 경우 표준 &lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt; tmpnam () 및 tmpfile () 함수의 구현이 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="ec069a599a9fe7b608d8c7621218dba9e34959bc" translate="yes" xml:space="preserve">
          <source>Additionally, it will create META.yml and META.json module meta-data file in the distdir and add this to the distdir's MANIFEST. You can shut this behavior off with the NO_META flag.</source>
          <target state="translated">또한 distdir에 META.yml 및 META.json 모듈 메타 데이터 파일을 작성하여 distdir의 MANIFEST에 추가합니다. NO_META 플래그를 사용하여이 동작을 종료 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cf43615b098124e15c13f1b6cb0b15882811c299" translate="yes" xml:space="preserve">
          <source>Additionally, on Solaris 8 and 9 you also need:</source>
          <target state="translated">또한 Solaris 8 및 9에서는 다음이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="803c31494436506f0b3634581565d9fa52a9d93a" translate="yes" xml:space="preserve">
          <source>Additionally, on Windows NT not all the fields returned by stat() can be compared. For example, the &lt;code&gt;dev&lt;/code&gt; and &lt;code&gt;rdev&lt;/code&gt; fields seem to be different. Also, it seems that the size of the file returned by stat() does not always agree, with &lt;code&gt;stat(FH)&lt;/code&gt; being more accurate than &lt;code&gt;stat(filename)&lt;/code&gt;, presumably because of caching issues even when using autoflush (this is usually overcome by waiting a while after writing to the tempfile before attempting to &lt;code&gt;unlink0&lt;/code&gt; it).</source>
          <target state="translated">또한 Windows NT에서는 stat ()에 의해 반환 된 모든 필드를 비교할 수 없습니다. 예를 들어, &lt;code&gt;dev&lt;/code&gt; 및 &lt;code&gt;rdev&lt;/code&gt; 필드는 다른 것처럼 보입니다. 또한, 합계 (에 의해 반환 된 파일의 크기가) 항상 함께, 동의하지 않는 것 같다 &lt;code&gt;stat(FH)&lt;/code&gt; 보다 더 정확 인 &lt;code&gt;stat(filename)&lt;/code&gt; 이 보통 대기에 의해 극복 (때문에의 autoflush를 사용하는 경우에도 문제가 캐시의 아마, &lt;code&gt;unlink0&lt;/code&gt; 를 시도하기 전에 임시 파일에 쓴 후 잠시 ).</target>
        </trans-unit>
        <trans-unit id="fdcb47de4e9258bc110d7122692a049db6fbb22a" translate="yes" xml:space="preserve">
          <source>Additionally, on Windows NT not all the fields returned by stat() can be compared. For example, the C</source>
          <target state="translated">또한 Windows NT에서 stat ()에 의해 리턴 된 모든 필드를 비교할 수있는 것은 아닙니다. 예를 들어 C</target>
        </trans-unit>
        <trans-unit id="51fffd62248577e35b4f056a4c962f40c15d81d6" translate="yes" xml:space="preserve">
          <source>Additionally, quoting rules for the end-of-string identifier are unrelated to Perl's quoting rules. &lt;code&gt;&lt;a href=&quot;functions/q&quot;&gt;q()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/qq&quot;&gt;qq()&lt;/a&gt;&lt;/code&gt;, and the like are not supported in place of &lt;code&gt;''&lt;/code&gt; and &lt;code&gt;&quot;&quot;&lt;/code&gt; , and the only interpolation is for backslashing the quoting character:</source>
          <target state="translated">또한 문자열 끝 식별자에 대한 인용 규칙은 Perl의 인용 규칙과 관련이 없습니다. &lt;code&gt;''&lt;/code&gt; 및 &lt;code&gt;&quot;&quot;&lt;/code&gt; 대신 &lt;code&gt;&lt;a href=&quot;functions/q&quot;&gt;q()&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/qq&quot;&gt;qq()&lt;/a&gt;&lt;/code&gt; 등은 지원되지 않으며 인용 문자 만 백 슬래시하기위한 유일한 보간입니다.</target>
        </trans-unit>
        <trans-unit id="412534d3423be2e1898577d3de74a34b369a730e" translate="yes" xml:space="preserve">
          <source>Additionally, quoting rules for the end-of-string identifier are unrelated to Perl's quoting rules. &lt;code&gt;q()&lt;/code&gt;, &lt;code&gt;qq()&lt;/code&gt;, and the like are not supported in place of &lt;code&gt;''&lt;/code&gt; and &lt;code&gt;&quot;&quot;&lt;/code&gt;, and the only interpolation is for backslashing the quoting character:</source>
          <target state="translated">또한 문자열 끝 식별자에 대한 인용 규칙은 Perl의 인용 규칙과 관련이 없습니다. &lt;code&gt;q()&lt;/code&gt; , &lt;code&gt;qq()&lt;/code&gt; 등은 &lt;code&gt;''&lt;/code&gt; 및 &lt;code&gt;&quot;&quot;&lt;/code&gt; 대신 지원되지 않으며 유일한 보간은 인용 문자를 백 슬래시하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="60224bb897c08e69d3d354606005d24af0b374cd" translate="yes" xml:space="preserve">
          <source>Additionally, the following still works:</source>
          <target state="translated">또한 다음은 여전히 ​​작동합니다.</target>
        </trans-unit>
        <trans-unit id="03aa6ebb82309c10827e49e960c12581e1baf1dc" translate="yes" xml:space="preserve">
          <source>Additionally, the type of each element is determined from the type of the array. If the array uses type &lt;code&gt;intArray *&lt;/code&gt; xsubpp will automatically work out that it contains variables of type &lt;code&gt;&lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt;&lt;/code&gt; and use that typemap entry to perform the copy of each element. All pointer '*' and 'Array' tags are removed from the name to determine the subtype.</source>
          <target state="translated">또한 각 요소의 유형은 배열 유형에서 결정됩니다. 배열이 &lt;code&gt;intArray *&lt;/code&gt; 유형을 사용하는 경우 xsubpp는 자동으로 &lt;code&gt;&lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt;&lt;/code&gt; 유형의 변수를 포함하고 해당 유형 맵 항목을 사용하여 각 요소의 복사를 수행합니다. 하위 유형을 결정하기 위해 모든 포인터 '*'및 'Array'태그가 이름에서 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="6c41af612d6b40d25dade58353a32d15c36d10a4" translate="yes" xml:space="preserve">
          <source>Additionally, the type of each element is determined from the type of the array. If the array uses type &lt;code&gt;intArray *&lt;/code&gt; xsubpp will automatically work out that it contains variables of type &lt;code&gt;int&lt;/code&gt; and use that typemap entry to perform the copy of each element. All pointer '*' and 'Array' tags are removed from the name to determine the subtype.</source>
          <target state="translated">또한 각 요소의 유형은 배열 유형에서 결정됩니다. 배열이 &lt;code&gt;intArray *&lt;/code&gt; 유형을 사용하는 경우 xsubpp는 자동으로 &lt;code&gt;int&lt;/code&gt; 유형의 변수를 포함하고 해당 유형 맵 항목을 사용하여 각 요소의 복사를 수행합니다. 하위 유형을 결정하기 위해 모든 포인터 '*'및 'Array'태그가 이름에서 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="07fc9a7d294284f6e102c0fc684f637e2ecfc37a" translate="yes" xml:space="preserve">
          <source>Additionally, there is now &lt;code&gt;UNI_DISPLAY_BACKSPACE&lt;/code&gt; which allows &lt;code&gt;\b&lt;/code&gt; for a backspace, but only when &lt;code&gt;UNI_DISPLAY_BACKSLASH&lt;/code&gt; also is set.</source>
          <target state="translated">또한 백 스페이스에 &lt;code&gt;\b&lt;/code&gt; 를 허용하는 &lt;code&gt;UNI_DISPLAY_BACKSPACE&lt;/code&gt; 가 있지만 &lt;code&gt;UNI_DISPLAY_BACKSLASH&lt;/code&gt; 도 설정된 경우에만 가능 합니다.</target>
        </trans-unit>
        <trans-unit id="5b8c86e3562fdf5c9d82a5e93b3d4cafa347de77" translate="yes" xml:space="preserve">
          <source>Additionally, unless the &lt;code&gt;safe&lt;/code&gt; parameter is set (or the third parameter in the traditional interface is TRUE), should a &lt;code&gt;remove_tree&lt;/code&gt; be interrupted, files that were originally in read-only mode may now have their permissions set to a read-write (or &quot;delete OK&quot;) mode.</source>
          <target state="translated">또한 &lt;code&gt;safe&lt;/code&gt; 매개 변수가 설정 되지 않은 경우 (또는 기존 인터페이스의 세 번째 매개 변수가 TRUE 인 경우) &lt;code&gt;remove_tree&lt;/code&gt; 가 중단되면 원래 읽기 전용 모드 인 파일의 권한이 읽기 / 쓰기로 설정 될 수 있습니다 (또는 &quot; 삭제 OK &quot;) 모드입니다.</target>
        </trans-unit>
        <trans-unit id="ec0f027d3baa565712bd5dc0ad0e80af4eb514d9" translate="yes" xml:space="preserve">
          <source>Additionally, you can enable and disable categories of warnings. You turn off the categories you want to ignore and you can still get other categories of warnings. See &lt;a href=&quot;perllexwarn&quot;&gt;perllexwarn&lt;/a&gt; for the complete details, including the category names and hierarchy.</source>
          <target state="translated">또한 경고 범주를 활성화 및 비활성화 할 수 있습니다. 무시하려는 카테고리를 끄고 다른 카테고리의 경고를 계속받을 수 있습니다. 카테고리 이름 및 계층 구조를 포함한 전체 세부 사항 은 &lt;a href=&quot;perllexwarn&quot;&gt;perllexwarn&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="3f10369c70dcbc4071416e4238c5876b81c9796c" translate="yes" xml:space="preserve">
          <source>Additionally, you might want to provide the following two globals to allow auto-upgrading and auto-downgrading to work correctly:</source>
          <target state="translated">또한 자동 업그레이드 및 자동 다운 그레이드가 올바르게 작동 할 수 있도록 다음 두 전역을 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0595fe59d92f01dd8f2cab1ee0be7afe3d67ccd0" translate="yes" xml:space="preserve">
          <source>Additionaly, on Solaris 8 and 9 you also need:</source>
          <target state="translated">또한 Solaris 8 및 9에서도 다음이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="bf73559c41806dc25286227ff308976c154c29de" translate="yes" xml:space="preserve">
          <source>Additive Operators</source>
          <target state="translated">부가 연산자</target>
        </trans-unit>
        <trans-unit id="15668d6e15430dae7c65fa496b4f2aa5393ff6b7" translate="yes" xml:space="preserve">
          <source>Address family constants used by the socket address structures, to pass to such functions as inet_pton() or getaddrinfo(), or are returned by such functions as sockaddr_family().</source>
          <target state="translated">소켓 주소 구조에 의해 사용되거나 inet_pton () 또는 getaddrinfo ()와 같은 함수에 전달되거나 sockaddr_family ()와 같은 함수에 의해 리턴되는 주소 패밀리 상수.</target>
        </trans-unit>
        <trans-unit id="ea43855ac57d81369dea84cf8dd61beb0a92ab13" translate="yes" xml:space="preserve">
          <source>Address to send copy of report to when sending report by mail. Defaults to the address of the local perl administrator (recorded when perl was built).</source>
          <target state="translated">우편으로 보고서를 보낼 때 보고서 사본을 보낼 주소입니다. 기본값은 로컬 perl 관리자의 주소입니다 (perl이 빌드 될 때 기록됨).</target>
        </trans-unit>
        <trans-unit id="398491e08f855e6e51bbd01773f98e6f34b68ef0" translate="yes" xml:space="preserve">
          <source>Address to send copy of report to. Defaults to the address of the local perl administrator (recorded when perl was built).</source>
          <target state="translated">보고서 사본을 보낼 주소입니다. 로컬 perl 관리자의 주소가 기본값입니다 (perl이 빌드 될 때 기록됨).</target>
        </trans-unit>
        <trans-unit id="b175bc4484e38539ad4d908d25e38cc037576a19" translate="yes" xml:space="preserve">
          <source>Address to send the report to instead of saving to a file.</source>
          <target state="translated">파일에 저장하는 대신 보고서를 보낼 주소입니다.</target>
        </trans-unit>
        <trans-unit id="866089dee6e89f6a5b436348a98fb9411f98472d" translate="yes" xml:space="preserve">
          <source>Address to send the report to. Defaults to &lt;b&gt;perlbug@perl.org&lt;/b&gt;.</source>
          <target state="translated">보고서를 보낼 주소입니다. 기본값은 &lt;b&gt;perlbug@perl.org&lt;/b&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="6b59857dd57932d5d50e4861a06a2080338435ed" translate="yes" xml:space="preserve">
          <source>Address-of operator. (But see the &lt;code&gt;&quot;\&quot;&lt;/code&gt; operator for taking a reference.)</source>
          <target state="translated">주소 연산자. (하지만 참조를 위해 &lt;code&gt;&quot;\&quot;&lt;/code&gt; 연산자를 참조하십시오.)</target>
        </trans-unit>
        <trans-unit id="875b1b8e40002002efb28f1a8fa46b6af7e34564" translate="yes" xml:space="preserve">
          <source>AddressSanitizer</source>
          <target state="translated">AddressSanitizer</target>
        </trans-unit>
        <trans-unit id="720546a46914bdc348b07d8d18a6b57bacd973ae" translate="yes" xml:space="preserve">
          <source>AddressSanitizer (&quot;ASan&quot;) consists of a compiler instrumentation module and a run-time &lt;code&gt;malloc&lt;/code&gt; library. ASan is available for a variety of architectures, operating systems, and compilers (see project link below). It checks for unsafe memory usage, such as use after free and buffer overflow conditions, and is fast enough that you can easily compile your debugging or optimized perl with it. Modern versions of ASan check for memory leaks by default on most platforms, otherwise (e.g. x86_64 OS X) this feature can be enabled via &lt;code&gt;ASAN_OPTIONS=detect_leaks=1&lt;/code&gt;.</source>
          <target state="translated">AddressSanitizer ( &quot;ASan&quot;)는 컴파일러 계측 모듈과 런타임 &lt;code&gt;malloc&lt;/code&gt; 라이브러리로 구성됩니다. ASan은 다양한 아키텍처, 운영 체제 및 컴파일러에서 사용할 수 있습니다 (아래 프로젝트 링크 참조). free after free 및 buffer overflow 조건과 같은 안전하지 않은 메모리 사용량을 확인하고 디버깅 또는 최적화 된 펄을 쉽게 컴파일 할 수있을만큼 빠릅니다. 최신 버전의 ASan은 대부분의 플랫폼에서 기본적으로 메모리 누수를 확인합니다. 그렇지 않은 경우 (예 : x86_64 OS X)이 기능은 &lt;code&gt;ASAN_OPTIONS=detect_leaks=1&lt;/code&gt; 을 통해 활성화 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="97d2869e530035313b88d71ffdc660bf28a9cf95" translate="yes" xml:space="preserve">
          <source>AddressSanitizer is a clang and gcc extension, included in clang since v3.1 and gcc since v4.8. It checks illegal heap pointers, global pointers, stack pointers and use after free errors, and is fast enough that you can easily compile your debugging or optimized perl with it. It does not check memory leaks though. AddressSanitizer is available for Linux, Mac OS X and soon on Windows.</source>
          <target state="translated">AddressSanitizer는 v3.1 이후 clang 및 v4.8 이후 gcc에 포함 된 clang 및 gcc 확장입니다. 불법 힙 포인터, 전역 포인터, 스택 포인터를 확인하고 빈 오류 발생 후 사용하며 디버깅 또는 최적화 된 펄을 쉽게 컴파일 할 수있을 정도로 빠릅니다. 메모리 누수는 확인하지 않습니다. AddressSanitizer는 Linux, Mac OS X 및 Windows에서 곧 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f7a02385815ee9f53e4e4bdfc174f0a5de504071" translate="yes" xml:space="preserve">
          <source>AddressSanitizer will ignore functions listed in the &lt;code&gt;asan_ignore&lt;/code&gt; file. (This file should contain a short explanation of why each of the functions is listed.)</source>
          <target state="translated">AddressSanitizer는 &lt;code&gt;asan_ignore&lt;/code&gt; 파일에 나열된 기능을 무시 합니다. (이 파일에는 각 기능이 나열된 이유에 대한 간단한 설명이 포함되어야합니다.)</target>
        </trans-unit>
        <trans-unit id="5be2ead2a35ea3568e7d0a94958a446ce541ca7c" translate="yes" xml:space="preserve">
          <source>Adds $y to $x and returns the result.</source>
          <target state="translated">$ y를 $ x에 더하고 결과를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="975fc2f37ec74ac4dc4429c1af7095af2a49e10a" translate="yes" xml:space="preserve">
          <source>Adds &lt;code&gt;#line&lt;/code&gt; directives to the C output so error messages will look like they came from the original XS file. Default is true.</source>
          <target state="translated">&lt;code&gt;#line&lt;/code&gt; 지시문을 C 출력에 추가 하여 오류 메시지가 원래 XS 파일에서 온 것처럼 보이게합니다. 기본값은 true입니다.</target>
        </trans-unit>
        <trans-unit id="14f679936dccdbe9d754f57ef3015e396a6c5718" translate="yes" xml:space="preserve">
          <source>Adds &lt;code&gt;extern &quot;C&quot;&lt;/code&gt; to the C code. Default is false.</source>
          <target state="translated">&lt;code&gt;extern &quot;C&quot;&lt;/code&gt; 를 C 코드에 추가합니다 . 기본값은 false입니다.</target>
        </trans-unit>
        <trans-unit id="9fbaf45d7bbf38840f610cf2fa4335deddb3f4a7" translate="yes" xml:space="preserve">
          <source>Adds a list of items onto the end of the queue.</source>
          <target state="translated">대기열 끝에 항목 목록을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="ec725714a66d8e380fad7b545ed61fc8b85dbabf" translate="yes" xml:space="preserve">
          <source>Adds a name to a stash's internal list of effective names. See &lt;code&gt;&lt;a href=&quot;#hv_ename_delete&quot;&gt;&quot;hv_ename_delete&quot;&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">숨김의 내부 유효 이름 목록에 이름을 추가합니다. &lt;code&gt;&lt;a href=&quot;#hv_ename_delete&quot;&gt;&quot;hv_ename_delete&quot;&lt;/a&gt;&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="973f265e0df96f52e35c5a95591ee9281a6a4277" translate="yes" xml:space="preserve">
          <source>Adds a name to a stash's internal list of effective names. See &lt;code&gt;hv_ename_delete&lt;/code&gt; .</source>
          <target state="translated">숨김의 유효 이름 목록에 이름을 추가합니다. &lt;code&gt;hv_ename_delete&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e689b98670881df4701aa3dac263f404709c80f2" translate="yes" xml:space="preserve">
          <source>Adds an action (Perl command) to happen after the prompt when you've just given a command to return to executing the script. A multi-line command may be entered by backslashing the newlines.</source>
          <target state="translated">스크립트 실행으로 돌아가라는 명령을 방금 주었을 때 프롬프트 후에 수행 할 조치 (Perl 명령)를 추가합니다. 개행을 백 슬래시하여 여러 줄 명령을 입력 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6f66738644531c5b87f8955ebdca5064179de491" translate="yes" xml:space="preserve">
          <source>Adds an entry to an existing</source>
          <target state="translated">기존 항목을 추가합니다</target>
        </trans-unit>
        <trans-unit id="0de7670702a5255a31f66440c4b7be5b815e4074" translate="yes" xml:space="preserve">
          <source>Adds directives to point C preprocessor to the right place when handling #include &amp;lt;sys/foo.h&amp;gt; directives. Also constructs CC command line a bit differently than MM_Unix method.</source>
          <target state="translated">#include &amp;lt;sys / foo.h&amp;gt; 지시문을 처리 할 때 C 전처리기를 올바른 위치에 지시하는 지시문을 추가합니다. 또한 CC 명령 행을 MM_Unix 메소드와 조금 다르게 구성합니다.</target>
        </trans-unit>
        <trans-unit id="57db6ceb50b20e26da1bd06687e1abc05f545a8e" translate="yes" xml:space="preserve">
          <source>Adds exception handling stubs to the C code.</source>
          <target state="translated">C 코드에 예외 처리 스텁을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="75f4dd4f96db4d1994f4da6375a60458e7848772" translate="yes" xml:space="preserve">
          <source>Adds exception handling stubs to the C code. Default is false.</source>
          <target state="translated">C 코드에 예외 처리 스텁을 추가합니다. 기본값은 false입니다.</target>
        </trans-unit>
        <trans-unit id="08e35eb9eb9d94e801f674df113993ee8f45e75c" translate="yes" xml:space="preserve">
          <source>Adds magic to a hash. See &lt;code&gt;&lt;a href=&quot;#sv_magic&quot;&gt;&quot;sv_magic&quot;&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">해시에 마법을 추가합니다. &lt;code&gt;&lt;a href=&quot;#sv_magic&quot;&gt;&quot;sv_magic&quot;&lt;/a&gt;&lt;/code&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="4af44986ac261800435ec27f11809711c0f2176e" translate="yes" xml:space="preserve">
          <source>Adds magic to a hash. See &lt;code&gt;sv_magic&lt;/code&gt; .</source>
          <target state="translated">해시에 마법을 추가합니다. &lt;code&gt;sv_magic&lt;/code&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="30db45551b4c37d676e3abf84ca96116307108ed" translate="yes" xml:space="preserve">
          <source>Adds magic to an SV, upgrading it if necessary. Applies the supplied &lt;code&gt;vtable&lt;/code&gt; and returns a pointer to the magic added.</source>
          <target state="translated">SV에 마법을 추가하고 필요한 경우 업그레이드합니다. 제공된 &lt;code&gt;vtable&lt;/code&gt; 을 적용하고 추가 된 매직에 대한 포인터를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="5d4c5e94cf59f9802d65e1e2f74c4b0b68104c99" translate="yes" xml:space="preserve">
          <source>Adds magic to an SV, upgrading it if necessary. Applies the supplied vtable and returns a pointer to the magic added.</source>
          <target state="translated">SV에 마법을 추가하여 필요한 경우 업그레이드합니다. 제공된 vtable을 적용하고 추가 된 마법에 대한 포인터를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="28665dcfafc5d1482673492d1c1b2b0ccfb32625" translate="yes" xml:space="preserve">
          <source>Adds magic to an SV. First upgrades &lt;code&gt;sv&lt;/code&gt; to type &lt;code&gt;SVt_PVMG&lt;/code&gt; if necessary, then adds a new magic item of type &lt;code&gt;how&lt;/code&gt; to the head of the magic list.</source>
          <target state="translated">SV에 마법을 추가합니다. 먼저 업그레이드 &lt;code&gt;sv&lt;/code&gt; 입력 &lt;code&gt;SVt_PVMG&lt;/code&gt; 을 필요가 입력 한 다음의 새로운 마법 아이템을 추가하는 경우 &lt;code&gt;how&lt;/code&gt; 마법리스트의 머리에.</target>
        </trans-unit>
        <trans-unit id="542cadc025698f26c94694489350a3b0f8078ab7" translate="yes" xml:space="preserve">
          <source>Adds the UTF-8 representation of the native code point &lt;code&gt;uv&lt;/code&gt; to the end of the string &lt;code&gt;d&lt;/code&gt; ; &lt;code&gt;d&lt;/code&gt; should have at least &lt;code&gt;UVCHR_SKIP(uv)+1&lt;/code&gt; (up to &lt;code&gt;UTF8_MAXBYTES+1&lt;/code&gt; ) free bytes available. The return value is the pointer to the byte after the end of the new character. In other words,</source>
          <target state="translated">고유 코드 포인트 &lt;code&gt;uv&lt;/code&gt; 의 UTF-8 표현을 문자열 &lt;code&gt;d&lt;/code&gt; 의 끝에 추가합니다 . &lt;code&gt;d&lt;/code&gt; 는 사용 가능한 바이트 가 최소한 &lt;code&gt;UVCHR_SKIP(uv)+1&lt;/code&gt; (최대 &lt;code&gt;UTF8_MAXBYTES+1&lt;/code&gt; ) 이상 이어야 합니다. 리턴 값은 새 문자의 끝 이후 바이트에 대한 포인터입니다. 다시 말해,</target>
        </trans-unit>
        <trans-unit id="ce163b2b2d4c6598625a233d6a9cfb6206d4b8ba" translate="yes" xml:space="preserve">
          <source>Adds the UTF-8 representation of the native code point &lt;code&gt;uv&lt;/code&gt; to the end of the string &lt;code&gt;d&lt;/code&gt;; &lt;code&gt;d&lt;/code&gt; should have at least &lt;code&gt;UVCHR_SKIP(uv)+1&lt;/code&gt; (up to &lt;code&gt;UTF8_MAXBYTES+1&lt;/code&gt;) free bytes available. The return value is the pointer to the byte after the end of the new character. In other words,</source>
          <target state="translated">문자열 &lt;code&gt;d&lt;/code&gt; 의 끝에 원시 코드 포인트 &lt;code&gt;uv&lt;/code&gt; 의 UTF-8 표현을 추가합니다 . &lt;code&gt;d&lt;/code&gt; 에는 사용 가능한 최소 &lt;code&gt;UVCHR_SKIP(uv)+1&lt;/code&gt; (최대 &lt;code&gt;UTF8_MAXBYTES+1&lt;/code&gt; )의 여유 바이트가 있어야합니다. 반환 값은 새 문자 끝 뒤의 바이트에 대한 포인터입니다. 다시 말해,</target>
        </trans-unit>
        <trans-unit id="05920eaea07a3bf7b3235f61833114608d265ccb" translate="yes" xml:space="preserve">
          <source>Adds the list of items to the queue at the specified index position (0 is the head of the list). Any existing items at and beyond that position are pushed back past the newly added items:</source>
          <target state="translated">지정된 인덱스 위치에서 큐에 항목 목록을 추가합니다 (0은 목록의 헤드 임). 해당 위치에 있거나 그 밖의 기존 항목이 새로 추가 된 항목을지나 뒤로 밀립니다.</target>
        </trans-unit>
        <trans-unit id="0e0d3dac3482cf17fed1b9381fe12a1473ad738e" translate="yes" xml:space="preserve">
          <source>Adds the standard Module prologue lines</source>
          <target state="translated">표준 모듈 프롤로그 라인 추가</target>
        </trans-unit>
        <trans-unit id="e8de0b7636a50e6e023d32d6c6819a0178b632ba" translate="yes" xml:space="preserve">
          <source>Adds the supplied opset to the current opmask. Note that there is currently</source>
          <target state="translated">제공된 opset을 현재 opmask에 추가합니다. 현재는</target>
        </trans-unit>
        <trans-unit id="ad3dde36a3137b653e95b59ad8f34b7ac4e19623" translate="yes" xml:space="preserve">
          <source>Adjust the read pointer and count of bytes to match &lt;code&gt;ptr&lt;/code&gt; and/or &lt;code&gt;cnt&lt;/code&gt; . The application (or layer above) must ensure they are consistent. (Checking is allowed by the paranoid.)</source>
          <target state="translated">&lt;code&gt;ptr&lt;/code&gt; 및 / 또는 &lt;code&gt;cnt&lt;/code&gt; 와 일치하도록 읽기 포인터 및 바이트 수를 조정하십시오 . 응용 프로그램 (또는 위의 계층)은 일관성을 유지해야합니다. (편집은 편집증에 의해 허용됩니다.)</target>
        </trans-unit>
        <trans-unit id="bfb3f75d00aa48b9559d9821194371bf47ab39b5" translate="yes" xml:space="preserve">
          <source>Adjust the read pointer and count of bytes to match &lt;code&gt;ptr&lt;/code&gt; and/or &lt;code&gt;cnt&lt;/code&gt;. The application (or layer above) must ensure they are consistent. (Checking is allowed by the paranoid.)</source>
          <target state="translated">읽기 포인터와 바이트 수를 &lt;code&gt;ptr&lt;/code&gt; 및 / 또는 &lt;code&gt;cnt&lt;/code&gt; 와 일치하도록 조정합니다 . 응용 프로그램 (또는 위의 계층)은 일관성이 있는지 확인해야합니다. ㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ (검사는 편집증에 의해 허용됩니다.)</target>
        </trans-unit>
        <trans-unit id="02eff1841c4085ce501a79933ae5da5167e9d1b8" translate="yes" xml:space="preserve">
          <source>Adjusting the system clock (either manually or by services like ntp) may cause problems, especially for long running programs that assume a monotonously increasing time (note that all platforms do not adjust time as gracefully as UNIX ntp does). For example in Win32 (and derived platforms like Cygwin and MinGW) the Time::HiRes::time() may temporarily drift off from the system clock (and the original time()) by up to 0.5 seconds. Time::HiRes will notice this eventually and recalibrate. Note that since Time::HiRes 1.77 the clock_gettime(CLOCK_MONOTONIC) might help in this (in case your system supports CLOCK_MONOTONIC).</source>
          <target state="translated">시스템 클럭을 수동으로 또는 ntp와 같은 서비스로 조정하면 특히 단시간에 시간이 오래 걸리는 장기 실행 프로그램의 경우 문제가 발생할 수 있습니다 (모든 플랫폼이 UNIX ntp만큼 우아하게 시간을 조정하지는 않습니다). 예를 들어 Win32 (및 Cygwin 및 MinGW와 같은 파생 플랫폼)에서 Time :: HiRes :: time ()은 시스템 시계 (및 원래 시간 ())에서 최대 0.5 초까지 일시적으로 벗어날 수 있습니다. Time :: HiRes가이 사실을 확인하고 다시 교정합니다. Time :: HiRes 1.77 이후 clock_gettime (CLOCK_MONOTONIC)이이를 지원할 수 있습니다 (시스템이 CLOCK_MONOTONIC를 지원하는 경우).</target>
        </trans-unit>
        <trans-unit id="e8d0942ed6347577c01feddee9c6edaf4ffde5a8" translate="yes" xml:space="preserve">
          <source>Adjustments are made for Borland's quirks needing -L to come first.</source>
          <target state="translated">-L이 필요한 볼랜드의 단점을 먼저 조정합니다.</target>
        </trans-unit>
        <trans-unit id="b8be3d1264310c3b8c848d4b90d5206179a40cc4" translate="yes" xml:space="preserve">
          <source>Administration</source>
          <target state="translated">Administration</target>
        </trans-unit>
        <trans-unit id="1eda23758be9e36e5e0d2a6a87de584aaca0193f" translate="yes" xml:space="preserve">
          <source>Administrator</source>
          <target state="translated">Administrator</target>
        </trans-unit>
        <trans-unit id="e6a9cb58c1721e13f0512658aa83841944c325f3" translate="yes" xml:space="preserve">
          <source>Admittedly, it's a little silly to use the curlies in this case, but the BLOCK can contain any arbitrary expression, in particular, subscripted expressions:</source>
          <target state="translated">분명히이 경우 curl을 사용하는 것은 약간 어리석은 일이지만 BLOCK은 임의의 표현, 특히 아래 첨자 표현을 포함 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3f189252acfcc32504fd3bc24de8b377486842c5" translate="yes" xml:space="preserve">
          <source>Adrian Howard</source>
          <target state="translated">애드리안 하워드</target>
        </trans-unit>
        <trans-unit id="96731dbaea6a5720dd33b64dc334ff765eec736a" translate="yes" xml:space="preserve">
          <source>Advanced Features</source>
          <target state="translated">고급 기능</target>
        </trans-unit>
        <trans-unit id="64e04a8cbc4193de6f65fd1544695b7f543269ac" translate="yes" xml:space="preserve">
          <source>Advanced Possibilities</source>
          <target state="translated">고급 가능성</target>
        </trans-unit>
        <trans-unit id="a79e7b92e71c562343b0e0c5c252eadade25490c" translate="yes" xml:space="preserve">
          <source>Advanced Semaphores</source>
          <target state="translated">고급 세마포어</target>
        </trans-unit>
        <trans-unit id="0d7049ed333121f6ad65eac902c5a2d1cec948e8" translate="yes" xml:space="preserve">
          <source>Advanced Topics</source>
          <target state="translated">고급 주제</target>
        </trans-unit>
        <trans-unit id="bf4a7a601b6308a708d2d443ffbc2bef624ad7f8" translate="yes" xml:space="preserve">
          <source>Advanced methods</source>
          <target state="translated">고급 방법</target>
        </trans-unit>
        <trans-unit id="d9df49ea7247202f690510939185a43595241825" translate="yes" xml:space="preserve">
          <source>Affects screen appearance of the command line (see &lt;a href=&quot;Term::ReadLine&quot;&gt;Term::ReadLine&lt;/a&gt;). There is currently no way to disable these, which can render some output illegible on some displays, or with some pagers. This is considered a bug.</source>
          <target state="translated">명령 줄의 화면 모양에 영향을줍니다 ( &lt;a href=&quot;Term::ReadLine&quot;&gt;Term :: ReadLine&lt;/a&gt; 참조 ). 현재 이러한 기능을 비활성화 할 수있는 방법이 없으며 일부 디스플레이 또는 일부 페이저에서 일부 출력을 읽을 수 없게 만들 수 있습니다. 이것은 버그로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="5646362e1c7206c24de0aa69540a4070b9eef4ad" translate="yes" xml:space="preserve">
          <source>Affects screen appearance of the command line (see &lt;a href=&quot;term/readline&quot;&gt;Term::ReadLine&lt;/a&gt;). There is currently no way to disable these, which can render some output illegible on some displays, or with some pagers. This is considered a bug.</source>
          <target state="translated">명령 행의 화면 모양에 영향을줍니다 ( &lt;a href=&quot;term/readline&quot;&gt;Term :: ReadLine&lt;/a&gt; 참조 ). 현재 이들을 비활성화하는 방법이 없으므로 일부 디스플레이에서 또는 일부 호출기에서 일부 출력을 읽을 수 없게 만들 수 있습니다. 이것은 버그로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="7ac09ae75b5fa764eed3b6f049863915415754f4" translate="yes" xml:space="preserve">
          <source>Affects the printing of messages upon entry and exit from subroutines. If &lt;code&gt;frame &amp;amp; 2&lt;/code&gt; is false, messages are printed on entry only. (Printing on exit might be useful if interspersed with other messages.)</source>
          <target state="translated">서브 루틴 시작 및 종료시 메시지 인쇄에 영향을줍니다. 경우 &lt;code&gt;frame &amp;amp; 2&lt;/code&gt; 거짓 메시지는 항목 만 인쇄되어 있습니다. (종료시 인쇄는 다른 메시지와 함께 산재 할 경우 유용 할 수 있습니다.)</target>
        </trans-unit>
        <trans-unit id="1d35114b8f34bf6224a46dac8d98b4ed3594b7f5" translate="yes" xml:space="preserve">
          <source>Africa</source>
          <target state="translated">Africa</target>
        </trans-unit>
        <trans-unit id="79ba5e1b3f99abfd54ef8d839ba12bd2ac4d79cb" translate="yes" xml:space="preserve">
          <source>After</source>
          <target state="translated">After</target>
        </trans-unit>
        <trans-unit id="5e27cc6169c8e48bde18cf63d6d83809f2b8a134" translate="yes" xml:space="preserve">
          <source>After &lt;a href=&quot;#each-HASH&quot;&gt;&lt;code&gt;each&lt;/code&gt;&lt;/a&gt; has returned all entries from the hash or array, the next call to &lt;a href=&quot;#each-HASH&quot;&gt;&lt;code&gt;each&lt;/code&gt;&lt;/a&gt; returns the empty list in list context and &lt;a href=&quot;#undef-EXPR&quot;&gt;&lt;code&gt;undef&lt;/code&gt;&lt;/a&gt; in scalar context; the next call following</source>
          <target state="translated">후 &lt;a href=&quot;#each-HASH&quot;&gt; &lt;code&gt;each&lt;/code&gt; &lt;/a&gt; 해시 또는 배열에 다음 호출에서 모든 항목 돌아왔다 &lt;a href=&quot;#each-HASH&quot;&gt; &lt;code&gt;each&lt;/code&gt; &lt;/a&gt; 반환리스트 문맥과 빈리스트 &lt;a href=&quot;#undef-EXPR&quot;&gt; &lt;code&gt;undef&lt;/code&gt; &lt;/a&gt; 스칼라 문맥을; 다음 전화</target>
        </trans-unit>
        <trans-unit id="87099a71e0044f05a4ae4680480a6ca9151bafd1" translate="yes" xml:space="preserve">
          <source>After &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; Math::BigFloat ':constant'&lt;/code&gt; all the floating point constants in the given scope are converted to &lt;code&gt;Math::BigFloat&lt;/code&gt; . This conversion happens at compile time.</source>
          <target state="translated">후 &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; Math::BigFloat ':constant'&lt;/code&gt; 가 지정된 범위에있는 모든 부동 소수점 상수로 변환됩니다 &lt;code&gt;Math::BigFloat&lt;/code&gt; . 이 변환은 컴파일 타임에 발생합니다.</target>
        </trans-unit>
        <trans-unit id="809e579562da8a6c62758fa5638ee2d5856559cc" translate="yes" xml:space="preserve">
          <source>After &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; Math::BigInt ':constant'&lt;/code&gt; all the &lt;b&gt;integer&lt;/b&gt; decimal, hexadecimal and binary constants in the given scope are converted to &lt;code&gt;Math::BigInt&lt;/code&gt; . This conversion happens at compile time.</source>
          <target state="translated">후 &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; Math::BigInt ':constant'&lt;/code&gt; 모든 &lt;b&gt;정수&lt;/b&gt; 주어진 범위 진수, 16 진수 이진 상수로 변환됩니다 &lt;code&gt;Math::BigInt&lt;/code&gt; . 이 변환은 컴파일 타임에 발생합니다.</target>
        </trans-unit>
        <trans-unit id="dc94e5687372ef5e696852ffc210ec8b3418a842" translate="yes" xml:space="preserve">
          <source>After &lt;code&gt;&lt;a href=&quot;each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; has returned all entries from the hash or array, the next call to &lt;code&gt;&lt;a href=&quot;each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; returns the empty list in list context and &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; in scalar context; the next call following</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; 해시 또는 배열에서 모든 항목을 반환 한 후 다음에 &lt;code&gt;&lt;a href=&quot;each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; 호출하면 목록 컨텍스트에서 빈 목록이 반환 되고 스칼라 컨텍스트에서 &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 가 반환 됩니다. 다음 전화</target>
        </trans-unit>
        <trans-unit id="655e7d0919e193463d83e3f9f9d5abefb149c7ea" translate="yes" xml:space="preserve">
          <source>After &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; has returned all entries from the hash or array, the next call to &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; returns the empty list in list context and &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; in scalar context; the next call following</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; 해시 또는 배열에서 모든 항목을 반환 한 후 다음에 &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; 호출하면 목록 컨텍스트에서 빈 목록이 반환 되고 스칼라 컨텍스트에서 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 가 반환 됩니다. 다음 전화</target>
        </trans-unit>
        <trans-unit id="e46798ad4d049ac6cc5760809be00336e1d1b9b6" translate="yes" xml:space="preserve">
          <source>After &lt;code&gt;use Math::BigFloat ':constant'&lt;/code&gt; all the floating point constants in the given scope are converted to &lt;code&gt;Math::BigFloat&lt;/code&gt;. This conversion happens at compile time.</source>
          <target state="translated">후 &lt;code&gt;use Math::BigFloat ':constant'&lt;/code&gt; 가 지정된 범위에있는 모든 부동 소수점 상수로 변환됩니다 &lt;code&gt;Math::BigFloat&lt;/code&gt; . 이 변환은 컴파일 타임에 발생합니다.</target>
        </trans-unit>
        <trans-unit id="4a5b2a2330b7b8678df243047f65b93b3e2a46bc" translate="yes" xml:space="preserve">
          <source>After &lt;code&gt;use Math::BigInt ':constant'&lt;/code&gt; all the &lt;b&gt;integer&lt;/b&gt; decimal, hexadecimal and binary constants in the given scope are converted to &lt;code&gt;Math::BigInt&lt;/code&gt;. This conversion happens at compile time.</source>
          <target state="translated">후 &lt;code&gt;use Math::BigInt ':constant'&lt;/code&gt; 모든 &lt;b&gt;정수&lt;/b&gt; 주어진 범위 진수, 16 진수 이진 상수로 변환됩니다 &lt;code&gt;Math::BigInt&lt;/code&gt; . 이 변환은 컴파일 타임에 발생합니다.</target>
        </trans-unit>
        <trans-unit id="7a43cbb4995a282f39330c5379623f425850e587" translate="yes" xml:space="preserve">
          <source>After CPAN RT #36136 (&lt;a href=&quot;https://rt.cpan.org/Ticket/Display.html?id=36136&quot;&gt;https://rt.cpan.org/Ticket/Display.html?id=36136&lt;/a&gt;)</source>
          <target state="translated">CPAN RT # 36136 이후 ( &lt;a href=&quot;https://rt.cpan.org/Ticket/Display.html?id=36136&quot;&gt;https://rt.cpan.org/Ticket/Display.html?id=36136&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="1d724f064157a1afcae77bb02216759e4c7bf880" translate="yes" xml:space="preserve">
          <source>After a match against some variable &lt;code&gt;$var&lt;/code&gt; :</source>
          <target state="translated">일부 변수 &lt;code&gt;$var&lt;/code&gt; 과 일치시킨 후 :</target>
        </trans-unit>
        <trans-unit id="a0a346767abcc70b84fbc11dca21132f94bd0d42" translate="yes" xml:space="preserve">
          <source>After a match against some variable &lt;code&gt;$var&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;$var&lt;/code&gt; 변수와 일치 한 후 :</target>
        </trans-unit>
        <trans-unit id="11d9dfb79da5f263a331eb311ab5576afc42a4b9" translate="yes" xml:space="preserve">
          <source>After a proper &lt;code&gt;POSIX::setlocale()&lt;/code&gt; call, and within the scope of a &lt;code&gt;use locale&lt;/code&gt; form that includes numerics, Perl obeys the &lt;code&gt;LC_NUMERIC&lt;/code&gt; locale information, which controls an application's idea of how numbers should be formatted for human readability. In most implementations the only effect is to change the character used for the decimal point--perhaps from &quot;.&quot; to &quot;,&quot;. The functions aren't aware of such niceties as thousands separation and so on. (See &lt;a href=&quot;#The-localeconv-function&quot;&gt;&quot;The localeconv function&quot;&lt;/a&gt; if you care about these things.)</source>
          <target state="translated">적절한 &lt;code&gt;POSIX::setlocale()&lt;/code&gt; 호출 후 숫자를 포함 하는 &lt;code&gt;use locale&lt;/code&gt; 양식 의 범위 내에서 Perl은 &lt;code&gt;LC_NUMERIC&lt;/code&gt; 로케일 정보를 준수합니다.이 정보는 사람이 쉽게 읽을 수 있도록 숫자를 형식화하는 방법에 대한 애플리케이션의 아이디어를 제어합니다. 대부분의 구현에서 유일한 효과는 소수점에 사용되는 문자를 변경하는 것입니다 (예 : &quot;.&quot;). &quot;,&quot;로. 함수는 수천 개의 분리 등과 같은 좋은 점을 인식하지 못합니다. ( 이러한 사항에 관심이 있다면 &lt;a href=&quot;#The-localeconv-function&quot;&gt;&quot;localeconv 함수&quot;를&lt;/a&gt; 참조하십시오 .)</target>
        </trans-unit>
        <trans-unit id="b84c3333b0e2cfaba4160f029890fe89d06d1d06" translate="yes" xml:space="preserve">
          <source>After a proper &lt;code&gt;POSIX::setlocale()&lt;/code&gt; call, and within the scope of of a &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; form that includes numerics, Perl obeys the &lt;code&gt;LC_NUMERIC&lt;/code&gt; locale information, which controls an application's idea of how numbers should be formatted for human readability. In most implementations the only effect is to change the character used for the decimal point--perhaps from &quot;.&quot; to &quot;,&quot;. The functions aren't aware of such niceties as thousands separation and so on. (See &lt;a href=&quot;#The-localeconv-function&quot;&gt;The localeconv function&lt;/a&gt; if you care about these things.)</source>
          <target state="translated">적절한 &lt;code&gt;POSIX::setlocale()&lt;/code&gt; 호출 후 그리고 숫자를 포함 하는 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; 양식 의 범위 내에서 Perl은 &lt;code&gt;LC_NUMERIC&lt;/code&gt; 로케일 정보를 준수하며 , 이는 사람이 읽을 수 있도록 숫자의 형식을 지정하는 방법에 대한 애플리케이션의 아이디어를 제어합니다. 대부분의 구현에서 유일한 효과는 소수점에 사용 된 문자를 변경하는 것입니다. 아마도 &quot;.&quot; &quot;,&quot; 함수는 수천 개의 분리와 같은 멋진 점을 인식하지 못합니다. ( 관심 사항이 있으면 &lt;a href=&quot;#The-localeconv-function&quot;&gt;localeconv 기능을&lt;/a&gt; 참조하십시오 .)</target>
        </trans-unit>
        <trans-unit id="1775073c0fe50242e57a96b412a98f0e94cc679a" translate="yes" xml:space="preserve">
          <source>After a successful compilation, you'll be able to use</source>
          <target state="translated">성공적으로 컴파일 한 후 사용할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="2e40e98b07f6b8de8575ba117b518f3063ffd7d8" translate="yes" xml:space="preserve">
          <source>After a successful send with &lt;code&gt;$to&lt;/code&gt;, further calls to &lt;code&gt;send&lt;/code&gt; on an unconnected socket without &lt;code&gt;$to&lt;/code&gt; will send to the same address, and &lt;code&gt;$to&lt;/code&gt; will be used as the result of &lt;a href=&quot;IO::Socket#peername&quot;&gt;&quot;peername&quot; in IO::Socket&lt;/a&gt;.</source>
          <target state="translated">성공적인 전송 후 &lt;code&gt;$to&lt;/code&gt; , 더 전화가 &lt;code&gt;send&lt;/code&gt; 하지 않고 연결되지 않은 소켓 &lt;code&gt;$to&lt;/code&gt; 동일한 주소로 보내는 것이고, &lt;code&gt;$to&lt;/code&gt; 의 결과로 사용되는 &lt;a href=&quot;IO::Socket#peername&quot;&gt;IO :: 소켓에서 &quot;PeerName에&quot;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f087a68cf0ba68c94dea17e31581c5258e5a685a" translate="yes" xml:space="preserve">
          <source>After all, the best thing about this pragma is that you don't have to resort to \x{....} just to spell your name in a native encoding. So feel free to put your strings in your encoding in quotes and regexes.</source>
          <target state="translated">결국,이 pragma의 가장 좋은 점은 \ x {....}에 의존 할 필요가 없다는 것입니다. 이름을 기본 인코딩으로 철자하기 만하면됩니다. 따라서 문자열을 따옴표와 정규식으로 인코딩에 자유롭게 넣으십시오.</target>
        </trans-unit>
        <trans-unit id="7593ddf636c03d07a5c407ca6961ab2d5ad931e8" translate="yes" xml:space="preserve">
          <source>After an environment variable is tied, merely use it like a normal variable. You may access its value</source>
          <target state="translated">환경 변수를 묶은 후에는 일반 변수처럼 사용하십시오. 당신은 그 가치에 접근 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="755e56a66bf3563f2fb9151f704977af6151c9b5" translate="yes" xml:space="preserve">
          <source>After an extension has been built and before it is installed it may be desirable to test it bypassing &lt;code&gt;make test&lt;/code&gt; . By adding</source>
          <target state="translated">확장을 빌드 한 후 설치하기 전에 &lt;code&gt;make test&lt;/code&gt; 거치지 않고 테스트하는 것이 바람직 할 수 있습니다 . 추가하여</target>
        </trans-unit>
        <trans-unit id="304be73f457497da9b044b938bde3acc398b9d4c" translate="yes" xml:space="preserve">
          <source>After an extension has been built and before it is installed it may be desirable to test it bypassing &lt;code&gt;make test&lt;/code&gt;. By adding</source>
          <target state="translated">확장을 빌드 한 후 설치하기 전에 &lt;code&gt;make test&lt;/code&gt; 를 우회하여 테스트하는 것이 바람직 할 수 있습니다 . 추가하여</target>
        </trans-unit>
        <trans-unit id="82f653c370563b01ec9f101f2aaad77e03914b8a" translate="yes" xml:space="preserve">
          <source>After command line parsing the following attributes reflect the values of the corresponding command line switches. They may be altered before calling &lt;code&gt;run&lt;/code&gt; .</source>
          <target state="translated">명령 행 구문 분석 후 다음 속성은 해당 명령 행 스위치의 값을 반영합니다. &lt;code&gt;run&lt;/code&gt; 호출하기 전에 변경 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0c132e008fbe1fb312b65ecf008e8f7d599a2076" translate="yes" xml:space="preserve">
          <source>After command line parsing the following attributes reflect the values of the corresponding command line switches. They may be altered before calling &lt;code&gt;run&lt;/code&gt;.</source>
          <target state="translated">명령 줄 구문 분석 후 다음 속성은 해당 명령 줄 스위치의 값을 반영합니다. &lt;code&gt;run&lt;/code&gt; 을 호출하기 전에 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5e251b544ae28a039470aaf55a5b7b59f40f8190" translate="yes" xml:space="preserve">
          <source>After each &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt;d file is compiled, but before it is executed, &lt;code&gt;DB::postponed(*{&quot;_&amp;lt;$filename&quot;})&lt;/code&gt; is called if the subroutine &lt;code&gt;DB::postponed&lt;/code&gt; exists. Here, the $filename is the expanded name of the &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt;d file, as found in the values of %INC.</source>
          <target state="translated">각 후 &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; D 파일을 컴파일하지만 실행되기 전에, &lt;code&gt;DB::postponed(*{&quot;_&amp;lt;$filename&quot;})&lt;/code&gt; 서브 루틴 경우라고 &lt;code&gt;DB::postponed&lt;/code&gt; 존재한다. 여기서 $ filename은 % INC 값에 있는 &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; d 파일 의 확장 이름입니다 .</target>
        </trans-unit>
        <trans-unit id="2e3674642d4245a266e59b17c4b1e94d7c037d9a" translate="yes" xml:space="preserve">
          <source>After each &lt;code&gt;require&lt;/code&gt;d file is compiled, but before it is executed, &lt;code&gt;DB::postponed(*{&quot;_&amp;lt;$filename&quot;})&lt;/code&gt; is called if the subroutine &lt;code&gt;DB::postponed&lt;/code&gt; exists. Here, the $filename is the expanded name of the &lt;code&gt;require&lt;/code&gt;d file, as found in the values of %INC.</source>
          <target state="translated">각 &lt;code&gt;require&lt;/code&gt; d 파일이 컴파일 된 후 실행되기 전에 서브 루틴 &lt;code&gt;DB::postponed&lt;/code&gt; 가 존재 하면 &lt;code&gt;DB::postponed(*{&quot;_&amp;lt;$filename&quot;})&lt;/code&gt; 가 호출됩니다 . 여기서 $ filename은 % INC의 값에 있는 &lt;code&gt;require&lt;/code&gt; d 파일 의 확장 된 이름입니다 .</target>
        </trans-unit>
        <trans-unit id="e73cebac8df604a03fa2c93d2c658b08259d94b6" translate="yes" xml:space="preserve">
          <source>After each subroutine &lt;code&gt;subname&lt;/code&gt; is compiled, the existence of &lt;code&gt;$DB::postponed{subname}&lt;/code&gt; is checked. If this key exists, &lt;code&gt;DB::postponed(subname)&lt;/code&gt; is called if the &lt;code&gt;DB::postponed&lt;/code&gt; subroutine also exists.</source>
          <target state="translated">각 서브 루틴 서브 &lt;code&gt;subname&lt;/code&gt; 이 컴파일 된 후 &lt;code&gt;$DB::postponed{subname}&lt;/code&gt; 의 존재 가 점검됩니다. 이 키가 존재 하면 &lt;code&gt;DB::postponed&lt;/code&gt; 서브 루틴도 존재 하면 &lt;code&gt;DB::postponed(subname)&lt;/code&gt; 이 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="e09c67a58e395afd52ffb2f20be8dce115f5694f" translate="yes" xml:space="preserve">
          <source>After each such removal you need to rerun the &lt;code&gt;Makefile.PL&lt;/code&gt; /&lt;code&gt;make&lt;/code&gt; process; usually this procedure converges soon. (But be sure to convert all the necessary external C libraries from</source>
          <target state="translated">이러한 제거 후에는 &lt;code&gt;Makefile.PL&lt;/code&gt; / &lt;code&gt;make&lt;/code&gt; 프로세스 를 다시 실행해야합니다 . 일반적으로이 절차는 곧 수렴됩니다. (그러나 필요한 모든 외부 C 라이브러리를</target>
        </trans-unit>
        <trans-unit id="a3a3a61b98b00b6b4e7a4b525c38605f6954e6af" translate="yes" xml:space="preserve">
          <source>After each such removal you need to rerun the &lt;code&gt;Makefile.PL&lt;/code&gt;/&lt;code&gt;make&lt;/code&gt; process; usually this procedure converges soon. (But be sure to convert all the necessary external C libraries from</source>
          <target state="translated">이러한 제거 후에는 &lt;code&gt;Makefile.PL&lt;/code&gt; / &lt;code&gt;make&lt;/code&gt; 프로세스 를 다시 실행해야합니다 . 일반적으로이 절차는 곧 수렴됩니다. (그러나 필요한 모든 외부 C 라이브러리를</target>
        </trans-unit>
        <trans-unit id="eb84d48b7946333a20d799fbde5105dfdef9cef8" translate="yes" xml:space="preserve">
          <source>After extracting the archive you copy the whole directory tree to your EBCDIC filesystem. &lt;b&gt;This time you use I/O-conversion&lt;/b&gt;:</source>
          <target state="translated">아카이브를 추출한 후 전체 디렉토리 트리를 EBCDIC 파일 시스템에 복사합니다. &lt;b&gt;이번에는 I / O 변환을 사용합니다&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="19dac0c58c8882858862b2f71b6cf8f32d646112" translate="yes" xml:space="preserve">
          <source>After having failed to remove a directory, &lt;code&gt;remove_tree&lt;/code&gt; was unable to restore its permissions from a permissive state back to a possibly more restrictive setting. (Permissions given in octal).</source>
          <target state="translated">디렉토리를 제거하지 못한 후 &lt;code&gt;remove_tree&lt;/code&gt; 가 권한을 허용 상태에서 더 제한적인 설정으로 복원 할 수 없습니다. (8 진수로 된 권한).</target>
        </trans-unit>
        <trans-unit id="82bcd3184999ba561b43a537f2cc4ce40931101a" translate="yes" xml:space="preserve">
          <source>After having failed to remove a file, &lt;code&gt;remove_tree&lt;/code&gt; was also unable to restore the permissions on the file to a possibly less permissive setting. (Permissions given in octal).</source>
          <target state="translated">파일 제거에 실패한 후, &lt;code&gt;remove_tree&lt;/code&gt; 는 파일에 대한 권한을 덜 허용되는 설정으로 복원 할 수도 없었습니다. (8 진수로 된 권한).</target>
        </trans-unit>
        <trans-unit id="23dac87df7f1fec6e0cffc03d2d5c4ff05ad76e5" translate="yes" xml:space="preserve">
          <source>After having this in the first part of .xs file, the &quot;Perl glue&quot; part becomes as simple as</source>
          <target state="translated">.xs 파일의 첫 번째 부분에서이 작업을 수행 한 후 &quot;Perl glue&quot;부분은 다음과 같이 간단 해집니다.</target>
        </trans-unit>
        <trans-unit id="2a05093cdd7b4cafe419584a2ca96b5327589ac9" translate="yes" xml:space="preserve">
          <source>After importing this module, when you use localtime or gmtime in a scalar context, rather than getting an ordinary scalar string representing the date and time, you get a Time::Piece object, whose stringification happens to produce the same effect as the localtime and gmtime functions. There is also a new() constructor provided, which is the same as localtime(), except when passed a Time::Piece object, in which case it's a copy constructor. The following methods are available on the object:</source>
          <target state="translated">이 모듈을 가져온 후 날짜 및 시간을 나타내는 일반 스칼라 문자열을 가져 오는 대신 스칼라 컨텍스트에서 localtime 또는 gmtime을 사용하면 현지화 시간과 동일한 효과를 생성하는 Time :: Piece 객체가 생성됩니다. gmtime 함수. 또한 time :: Piece 객체를 전달할 때를 제외하고는 localtime ()과 동일한 new () 생성자가 제공됩니다.이 경우 복사 생성자입니다. 객체에서 다음 방법을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="989e7c432fe7873dedca66b4efcb012930902467" translate="yes" xml:space="preserve">
          <source>After initialisation @dl_library_path can be manipulated by an application using push and unshift before calling dl_findfile(). Unshift can be used to add directories to the front of the search order either to save search time or to override libraries with the same name in the 'normal' directories.</source>
          <target state="translated">초기화 후 @dl_library_path는 dl_findfile ()을 호출하기 전에 push 및 unshift를 사용하여 응용 프로그램에서 조작 할 수 있습니다. Unshift는 검색 시간을 앞당기거나 디렉토리를 추가하여 검색 시간을 절약하거나 '일반'디렉토리에서 동일한 이름을 가진 라이브러리를 재정의하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="384ec4e8afa39c03a7ec5ccae79ea44f50b98953" translate="yes" xml:space="preserve">
          <source>After installation &amp;amp; testing processes will stabilize, information will be more precise.</source>
          <target state="translated">설치 및 테스트 프로세스가 안정화되면 정보가 더 정확 해집니다.</target>
        </trans-unit>
        <trans-unit id="2fb4a06d67a8330d3fbde3ddb1645d723c7e519d" translate="yes" xml:space="preserve">
          <source>After installing cpan-mac, drop the module archive on the &lt;b&gt;untarzipme&lt;/b&gt; droplet, which will decompress and unpack for you.</source>
          <target state="translated">cpan-mac을 설치 한 후 &lt;b&gt;untarzipme&lt;/b&gt; 액 &lt;b&gt;적에&lt;/b&gt; 모듈 아카이브를 &lt;b&gt;놓아&lt;/b&gt; 압축을 풀고 압축을 풉니 다.</target>
        </trans-unit>
        <trans-unit id="664cd686db2128a0a7a7f2b1ff03293801e0cf2e" translate="yes" xml:space="preserve">
          <source>After loading all typemap files or modules, it will merge them in the specified order and dump the result as an embeddable typemap.</source>
          <target state="translated">모든 타입 맵 파일 또는 모듈을로드 한 후 지정된 순서대로 병합하고 결과를 포함 가능한 타입 맵으로 덤프합니다.</target>
        </trans-unit>
        <trans-unit id="ebf5ce736aa7d823aae94b0fbadad820a15f7f86" translate="yes" xml:space="preserve">
          <source>After locating your program, Perl compiles the entire program to an internal form. If there are any compilation errors, execution of the program is not attempted. (This is unlike the typical shell script, which might run part-way through before finding a syntax error.)</source>
          <target state="translated">프로그램을 찾은 후 Perl은 전체 프로그램을 내부 형식으로 컴파일합니다. 컴파일 오류가 있으면 프로그램 실행이 시도되지 않습니다. (이것은 구문 오류를 찾기 전에 부분적으로 실행될 수있는 일반적인 쉘 스크립트와 다릅니다.)</target>
        </trans-unit>
        <trans-unit id="1f14adfb2016d61c246f44ef48217385e9787764" translate="yes" xml:space="preserve">
          <source>After much staring at the same piece of code and not seeing the wood for the trees for some time, we get a cup of coffee and try another approach. That is, we bring in the cavalry by giving perl the '&lt;b&gt;-d&lt;/b&gt;' switch on the command line:</source>
          <target state="translated">같은 코드 조각을 많이 쳐다보고 한동안 나무의 나무를 보지 않으면 커피 한 잔을 마시고 다른 접근법을 시도합니다. 즉 , 명령 행에 perl에 ' &lt;b&gt;-d&lt;/b&gt; '스위치를 제공하여 기병대를 불러옵니다 .</target>
        </trans-unit>
        <trans-unit id="2d5f14aa259693520ef9c62e9c5bcba015ca36fc" translate="yes" xml:space="preserve">
          <source>After normal processing of &lt;code&gt;-I&lt;/code&gt; switches from the command line, all the &lt;code&gt;-I&lt;/code&gt; switches in &lt;code&gt;PERL5OPT&lt;/code&gt; are extracted. They are processed from left to right instead of from right to left. Also note that while whitespace is allowed between a &lt;code&gt;-I&lt;/code&gt; and its directory on the command line, it is not allowed in &lt;code&gt;PERL5OPT&lt;/code&gt;.</source>
          <target state="translated">명령 줄에서 &lt;code&gt;-I&lt;/code&gt; 스위치를 정상적으로 처리 한 후 &lt;code&gt;PERL5OPT&lt;/code&gt; 의 모든 &lt;code&gt;-I&lt;/code&gt; 스위치 가 추출됩니다. 오른쪽에서 왼쪽이 아닌 왼쪽에서 오른쪽으로 처리됩니다. 또한 명령 줄에서 &lt;code&gt;-I&lt;/code&gt; 와 해당 디렉토리 사이에는 공백이 허용 &lt;code&gt;PERL5OPT&lt;/code&gt; 에서는 허용되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="18a0e77e891c78ca559c5ae3cd50b454d32a350f" translate="yes" xml:space="preserve">
          <source>After normal processing of &lt;code&gt;-M&lt;/code&gt; switches from the command line, all the &lt;code&gt;-M&lt;/code&gt; switches in &lt;code&gt;PERL5OPT&lt;/code&gt; are extracted. They are processed from left to right,</source>
          <target state="translated">명령 줄에서 &lt;code&gt;-M&lt;/code&gt; 스위치를 정상적으로 처리 한 후 &lt;code&gt;PERL5OPT&lt;/code&gt; 의 모든 &lt;code&gt;-M&lt;/code&gt; 스위치 가 추출됩니다. 왼쪽에서 오른쪽으로 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="88dec92da58c74e4620b3cd18d97733f553fa72c" translate="yes" xml:space="preserve">
          <source>After parsing the TAP, there are many methods available to let you dig through the results and determine what is meaningful to you.</source>
          <target state="translated">TAP를 구문 분석 한 후 결과를 탐색하고 의미있는 사항을 결정하는 데 사용할 수있는 방법이 많이 있습니다.</target>
        </trans-unit>
        <trans-unit id="b702243123830daddfd7ae611e2d0a89f36745c6" translate="yes" xml:space="preserve">
          <source>After parsing, this method returns any warnings encountered during the parsing process.</source>
          <target state="translated">구문 분석 후이 메소드는 구문 분석 프로세스 중에 발생한 모든 경고를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="cebf2b23cf8d6511ea00c15fa6633daadf530471" translate="yes" xml:space="preserve">
          <source>After positional parameters, additional arguments may be captured in a slurpy parameter. The simplest form of this is just an array variable:</source>
          <target state="translated">위치 매개 변수 이후에, 추가 인수는 거친 매개 변수로 캡처 될 수 있습니다. 가장 간단한 형태는 배열 변수입니다.</target>
        </trans-unit>
        <trans-unit id="79faa591ef4aa9c1048ecde8617caf4bb4f6e42f" translate="yes" xml:space="preserve">
          <source>After processing of the error using</source>
          <target state="translated">를 사용하여 오류를 처리 한 후</target>
        </trans-unit>
        <trans-unit id="de441b5d72f77ccdab32c953f236dc0929b26bfe" translate="yes" xml:space="preserve">
          <source>After reading &lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt; explaining how to use &lt;code&gt;&lt;a href=&quot;functions/syscall&quot;&gt;syscall&lt;/a&gt;&lt;/code&gt; we can write this Perl function copying a file to standard output:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/syscall&quot;&gt;syscall&lt;/a&gt;&lt;/code&gt; 사용법을 설명하는 &lt;a href=&quot;perlfunc&quot;&gt;perlfunc를&lt;/a&gt; 읽은 후 파일을 표준 출력으로 복사하는이 Perl 함수를 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f4adb1e6f911a20c20bb1e25698cad848af9e465" translate="yes" xml:space="preserve">
          <source>After reading &lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt; explaining how to use &lt;code&gt;syscall&lt;/code&gt; we can write this Perl function copying a file to standard output:</source>
          <target state="translated">&lt;code&gt;syscall&lt;/code&gt; 사용 방법을 설명하는 &lt;a href=&quot;perlfunc&quot;&gt;perlfunc를&lt;/a&gt; 읽은 후 파일을 표준 출력에 복사하는이 Perl 함수를 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="79b88eddec153e8e34fbe3804e13971f48b0d9e3" translate="yes" xml:space="preserve">
          <source>After reading this document, you ought to read &lt;a href=&quot;perlunifaq&quot;&gt;perlunifaq&lt;/a&gt; too, then &lt;a href=&quot;perluniintro&quot;&gt;perluniintro&lt;/a&gt;.</source>
          <target state="translated">이 문서를 읽은 &lt;a href=&quot;perlunifaq&quot;&gt;후에는 perlunifaq&lt;/a&gt; 도 읽은 다음 &lt;a href=&quot;perluniintro&quot;&gt;perluniintro&lt;/a&gt; 를 읽어야 합니다.</target>
        </trans-unit>
        <trans-unit id="bde067e2f6a70b830351def3b30472931261a063" translate="yes" xml:space="preserve">
          <source>After that,</source>
          <target state="translated">그 후</target>
        </trans-unit>
        <trans-unit id="7b937cd1c6408a87d424cf360c608a4cc3ea4ec3" translate="yes" xml:space="preserve">
          <source>After that, if the function is called in void context, it will simply return without doing anything further. This can be used to add more text in as many chunks as you want.</source>
          <target state="translated">그 후 함수가 void 컨텍스트에서 호출되면 더 이상 수행하지 않고 단순히 반환됩니다. 원하는만큼 많은 청크에 더 많은 텍스트를 추가하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="33a6f21294ecc8bfb003384c79fe3378bc362230" translate="yes" xml:space="preserve">
          <source>After the call to &lt;code&gt;inflate&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;inflate&lt;/code&gt; 전화 후</target>
        </trans-unit>
        <trans-unit id="82f20576e0d7a55f07ad388dd8a48aef5935809c" translate="yes" xml:space="preserve">
          <source>After the compile tree for a subroutine (or for an &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; or a file) is created, an additional pass over the code is performed. This pass is neither top-down or bottom-up, but in the execution order (with additional complications for conditionals). Optimizations performed at this stage are subject to the same restrictions as in the pass 2.</source>
          <target state="translated">서브 루틴 (또는 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 또는 파일)에 대한 컴파일 트리 가 작성된 후 코드에 대한 추가 패스가 수행됩니다. 이 패스는 하향식 또는 상향식이 아니라 실행 순서로 이루어집니다 (조건부에 대한 추가 합병증 포함). 이 단계에서 수행되는 최적화에는 패스 2와 동일한 제한이 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="f910f23b6624c5903e97e3142db0b72e45cd1efc" translate="yes" xml:space="preserve">
          <source>After the compile tree for a subroutine (or for an &lt;code&gt;eval&lt;/code&gt; or a file) is created, an additional pass over the code is performed. This pass is neither top-down or bottom-up, but in the execution order (with additional complications for conditionals). Optimizations performed at this stage are subject to the same restrictions as in the pass 2.</source>
          <target state="translated">서브 루틴 (또는 &lt;code&gt;eval&lt;/code&gt; 또는 파일)에 대한 컴파일 트리 가 생성 된 후 코드에 대한 추가 전달이 수행됩니다. 이 패스는 하향식 또는 상향식이 아닌 실행 순서 (조건부 추가 합병증 포함)입니다. 이 단계에서 수행되는 최적화에는 패스 2와 동일한 제한이 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="030398b98f864699ff503816f85c07e82cf00fe5" translate="yes" xml:space="preserve">
          <source>After the match fails at the letter &lt;code&gt;a&lt;/code&gt; , perl resets &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos()&lt;/a&gt;&lt;/code&gt; and the next match on the same string starts at the beginning.</source>
          <target state="translated">문자 &lt;code&gt;a&lt;/code&gt; 에서 일치가 실패하면 perl은 &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos()&lt;/a&gt;&lt;/code&gt; 재설정 하고 같은 문자열에서 다음 일치가 처음에 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="44718c4e9c72836902f7acc35cf27ebe46d1c162" translate="yes" xml:space="preserve">
          <source>After the match fails at the letter &lt;code&gt;a&lt;/code&gt;, perl resets &lt;code&gt;pos()&lt;/code&gt; and the next match on the same string starts at the beginning.</source>
          <target state="translated">문자 &lt;code&gt;a&lt;/code&gt; 에서 일치가 실패하면 perl은 &lt;code&gt;pos()&lt;/code&gt; 재설정 하고 동일한 문자열의 다음 일치는 처음부터 시작합니다.</target>
        </trans-unit>
        <trans-unit id="293c71dbddf34e425e567a76e0a301441dc6a8bc" translate="yes" xml:space="preserve">
          <source>After the rc file is read, the debugger reads the &lt;code&gt;$ENV{PERLDB_OPTS}&lt;/code&gt; environment variable and parses this as the remainder of a &quot;O ...&quot; line as one might enter at the debugger prompt. You may place the initialization options &lt;code&gt;TTY&lt;/code&gt; , &lt;code&gt;noTTY&lt;/code&gt; , &lt;code&gt;ReadLine&lt;/code&gt; , and &lt;code&gt;NonStop&lt;/code&gt; there.</source>
          <target state="translated">rc 파일을 읽은 후 디버거는 &lt;code&gt;$ENV{PERLDB_OPTS}&lt;/code&gt; 환경 변수를 읽고 디버거 프롬프트에서 입력 할 수있는 나머지 &quot;O ...&quot;줄로이를 구문 분석합니다. 초기화 옵션 &lt;code&gt;TTY&lt;/code&gt; , &lt;code&gt;noTTY&lt;/code&gt; , &lt;code&gt;ReadLine&lt;/code&gt; 및 &lt;code&gt;NonStop&lt;/code&gt; 을 배치 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="60a827bfb9302456ecc7d7f0aaf91ba51ce11408" translate="yes" xml:space="preserve">
          <source>After the rc file is read, the debugger reads the &lt;code&gt;$ENV{PERLDB_OPTS}&lt;/code&gt; environment variable and parses this as the remainder of a &quot;O ...&quot; line as one might enter at the debugger prompt. You may place the initialization options &lt;code&gt;TTY&lt;/code&gt;, &lt;code&gt;noTTY&lt;/code&gt;, &lt;code&gt;ReadLine&lt;/code&gt;, and &lt;code&gt;NonStop&lt;/code&gt; there.</source>
          <target state="translated">rc 파일을 읽은 후 디버거는 &lt;code&gt;$ENV{PERLDB_OPTS}&lt;/code&gt; 환경 변수를 읽고 디버거 프롬프트에 입력 할 수있는 &quot;O ...&quot;줄의 나머지로이를 구문 분석합니다. 여기에 초기화 옵션 &lt;code&gt;TTY&lt;/code&gt; , &lt;code&gt;noTTY&lt;/code&gt; , &lt;code&gt;ReadLine&lt;/code&gt; 및 &lt;code&gt;NonStop&lt;/code&gt; 을 배치 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9d1ae6b4dd14750a8aa5ca6bb9188a3898fd5425" translate="yes" xml:space="preserve">
          <source>After the rc file is read, the debugger reads the PERLDB_OPTS environment variable and uses it to set debugger options. The contents of this variable are treated as if they were the argument of an &lt;code&gt;o ...&lt;/code&gt; debugger command (q.v. in &lt;a href=&quot;perldebug#Configurable-Options&quot;&gt;&quot;Configurable Options&quot; in perldebug&lt;/a&gt;).</source>
          <target state="translated">rc 파일을 읽은 후 디버거는 PERLDB_OPTS 환경 변수를 읽고이를 사용하여 디버거 옵션을 설정합니다. 이 변수의 내용은 &lt;code&gt;o ...&lt;/code&gt; 디버거 명령 의 인수 인 것처럼 처리됩니다 ( &lt;a href=&quot;perldebug#Configurable-Options&quot;&gt;perldebug의 &quot;구성 가능한 옵션&quot;의 qv&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="e899e5cdac5e0e6b4bee21b7339405a7360957f3" translate="yes" xml:space="preserve">
          <source>After the rc file is read, the debugger reads the PERLDB_OPTS environment variable and uses it to set debugger options. The contents of this variable are treated as if they were the argument of an &lt;code&gt;o ...&lt;/code&gt; debugger command (q.v. in &lt;a href=&quot;perldebug#Configurable-Options&quot;&gt;Configurable Options in perldebug&lt;/a&gt;).</source>
          <target state="translated">rc 파일을 읽은 후 디버거는 PERLDB_OPTS 환경 변수를 읽고이를 사용하여 디버거 옵션을 설정합니다. 이 변수의 내용은 마치 &lt;code&gt;o ...&lt;/code&gt; 디버거 명령 의 인수 인 것처럼 처리됩니다 ( &lt;a href=&quot;perldebug#Configurable-Options&quot;&gt;perldebug의 구성 가능 옵션에서 qv&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="5914d10f08f8ac8f77b44277a2b9190d62853c27" translate="yes" xml:space="preserve">
          <source>After the time-limited ban has been lifted, a third instance of unacceptable behavior will result in a further public warning. A fourth or subsequent instance will result in an indefinite ban. The rationale is that, in the face of an apparent refusal to change behavior, we must protect other community members from future unacceptable actions. The moderators may choose to lift an indefinite ban if the person in question affirms they will not transgress again.</source>
          <target state="translated">시간 제한이 해제 된 후 용납 할 수없는 행동의 세 번째 사례는 추가 공개 경고를 받게됩니다. 네 번째 또는 그 이후의 인스턴스는 무기한 금지를 받게됩니다. 그 이유는 행동 변경을 명백히 거부하는 상황에서 우리는 미래의 용납 할 수없는 행동으로부터 다른 커뮤니티 구성원을 보호해야한다는 것입니다. 중재자는 문제의 사람이 다시 범법하지 않을 것이라고 단언하는 경우 무기한 금지를 해제하도록 선택할 수 있습니다. ㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ</target>
        </trans-unit>
        <trans-unit id="48e96da87f1b22f4a662b486f469bd089c2d194f" translate="yes" xml:space="preserve">
          <source>After this you can direct your browser the file</source>
          <target state="translated">이 후 브라우저에 파일을 지시 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="047aa94c055cd198e88e38eec23f2d3fb520f816" translate="yes" xml:space="preserve">
          <source>After this you can either copy Perl from your operating system media (you will need at least the /System/Library/Perl and /usr/bin/perl), or rebuild Perl from the source code with &lt;code&gt;Configure -Dprefix=/usr
-Duseshrplib&lt;/code&gt; NOTE: the &lt;code&gt;-Dprefix=/usr&lt;/code&gt; to replace the system Perl works much better with Perl 5.8.1 and later, in Perl 5.8.0 the settings were not quite right.</source>
          <target state="translated">그런 다음 운영 체제 매체에서 Perl을 복사하거나 (적어도 / System / Library / Perl 및 / usr / bin / perl이 &lt;code&gt;Configure -Dprefix=/usr -Duseshrplib&lt;/code&gt; ) 또는 Configure -Dprefix = / usr -Duseshrplib 를 사용하여 소스 코드에서 Perl을 다시 빌드 하십시오. 참고 : 시스템 Perl을 대체하기 위한 &lt;code&gt;-Dprefix=/usr&lt;/code&gt; 은 Perl 5.8.1 이상에서 훨씬 더 잘 작동합니다. Perl 5.8.0에서는 설정이 잘못되었습니다.</target>
        </trans-unit>
        <trans-unit id="afc63f5dda4ecced4f5f45482623e56ea1f306ab" translate="yes" xml:space="preserve">
          <source>After you have built perl using the Configure script, ensure that you have modify and default write permission to &lt;code&gt;&amp;gt;system&amp;gt;ported&lt;/code&gt; and all subdirectories. Then type</source>
          <target state="translated">Configure 스크립트를 사용하여 perl을 빌드 한 후 &lt;code&gt;&amp;gt;system&amp;gt;ported&lt;/code&gt; 및 모든 서브 디렉토리에 대한 수정 및 기본 쓰기 권한이 있는지 확인하십시오 . 그런 다음 입력</target>
        </trans-unit>
        <trans-unit id="8aca2e8c01b81a07c6eb69c26b8265b8e7beb0f1" translate="yes" xml:space="preserve">
          <source>After you installed the components you needed and updated the</source>
          <target state="translated">필요한 구성 요소를 설치하고 업데이트 한 후</target>
        </trans-unit>
        <trans-unit id="d33c7c8e8c88b02eadf2fda47995324b6f5d61c5" translate="yes" xml:space="preserve">
          <source>Afterwards, implicit upgrading of high-bit bytes will raise a warning. Ex.: &lt;code&gt;Bytes implicitly upgraded into wide characters as iso-8859-1 at - line 7&lt;/code&gt;.</source>
          <target state="translated">이후에 높은 비트 바이트를 암시 적으로 업그레이드하면 경고가 발생합니다. 예 : &lt;code&gt;Bytes implicitly upgraded into wide characters as iso-8859-1 at - line 7&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="61179f6b3dda7b5ee08dd7ce8f69dddb876677ab" translate="yes" xml:space="preserve">
          <source>Again assuming the existence of the &lt;code&gt;tree&lt;/code&gt; database</source>
          <target state="translated">다시 &lt;code&gt;tree&lt;/code&gt; 데이터베이스가 있다고 가정</target>
        </trans-unit>
        <trans-unit id="7c2b707160e59a8a50ca98c9028a92309952c8b9" translate="yes" xml:space="preserve">
          <source>Again like &lt;code&gt;cond_wait&lt;/code&gt; , waking up and reacquiring the lock are not atomic, and you should always check your desired condition after this function returns. Since the timeout is an absolute value, however, it does not have to be recalculated with each pass:</source>
          <target state="translated">다시 &lt;code&gt;cond_wait&lt;/code&gt; 와 같이 잠금을 해제하고 다시 획득하는 것은 원자 적이 지 않으므로이 함수가 반환 된 후에는 항상 원하는 조건을 확인해야합니다. 그러나 시간 초과는 절대 값이므로 각 패스와 함께 다시 계산할 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="80ceb6ccb0e00ef82fa454c0b81cfff6cc81ecb4" translate="yes" xml:space="preserve">
          <source>Again like &lt;code&gt;cond_wait&lt;/code&gt;, waking up and reacquiring the lock are not atomic, and you should always check your desired condition after this function returns. Since the timeout is an absolute value, however, it does not have to be recalculated with each pass:</source>
          <target state="translated">다시 &lt;code&gt;cond_wait&lt;/code&gt; 와 마찬가지로 잠금을 해제하고 다시 획득하는 것은 원 자성이 아니므로이 함수가 반환 된 후에는 항상 원하는 조건을 확인해야합니다. 그러나 시간 제한은 절대 값이므로 각 패스마다 다시 계산할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="ca8570b68f5ed102e2eaf1b90efb62ece24d489e" translate="yes" xml:space="preserve">
          <source>Again, for elementary pieces there is no such question, since at most one match at a given position is possible. This section describes the notion of better/worse for combining operators. In the description below &lt;code&gt;&quot;S&quot;&lt;/code&gt; and &lt;code&gt;&quot;T&quot;&lt;/code&gt; are regular subexpressions.</source>
          <target state="translated">다시 말하지만, 기본 작품의 경우 주어진 위치에서 최대 한 번의 일치가 가능하기 때문에 그러한 질문이 없습니다. 이 섹션에서는 연산자 결합에 대한 더 나은 / 나쁜 개념에 대해 설명합니다. 아래 설명에서 &lt;code&gt;&quot;S&quot;&lt;/code&gt; 와 &lt;code&gt;&quot;T&quot;&lt;/code&gt; 는 정규 하위 표현식입니다.</target>
        </trans-unit>
        <trans-unit id="f1807d38160980407aafc2417f04ad9be3af89ae" translate="yes" xml:space="preserve">
          <source>Again, for elementary pieces there is no such question, since at most one match at a given position is possible. This section describes the notion of better/worse for combining operators. In the description below &lt;code&gt;S&lt;/code&gt; and &lt;code&gt;T&lt;/code&gt; are regular subexpressions.</source>
          <target state="translated">다시 말하지만, 기본 조각의 경우 주어진 위치에서 최대 하나의 일치가 가능하기 때문에 그러한 질문은 없습니다. 이 섹션에서는 연산자 결합에 대한 더 나은 / 나쁜 개념을 설명합니다. 아래 설명에서 &lt;code&gt;S&lt;/code&gt; 와 &lt;code&gt;T&lt;/code&gt; 는 정규 하위 표현식입니다.</target>
        </trans-unit>
        <trans-unit id="5f5a18a4eff39b7d1528cf15b17087b5d8251fa1" translate="yes" xml:space="preserve">
          <source>Again, if you already have the data in memory or want to avoid the complexity of the above, you can use sv_setpvn().</source>
          <target state="translated">다시 말하지만 메모리에 이미 데이터가 있거나 위의 복잡성을 피하려면 sv_setpvn ()을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cf8e2e1b9b0e08a7a42ff9da61e6daf28394e96e" translate="yes" xml:space="preserve">
          <source>Again, the PERL_DL_NONLAZY thing.</source>
          <target state="translated">PERL_DL_NONLAZY도 마찬가지입니다.</target>
        </trans-unit>
        <trans-unit id="cc9355813d20c04f9885340bd38f5820f772f6ef" translate="yes" xml:space="preserve">
          <source>Again, the result is a string, now containing 2 bytes. If you print this string (which is, generally, not recommended) you might see &lt;code&gt;ON&lt;/code&gt; or &lt;code&gt;NO&lt;/code&gt; (depending on your system's byte ordering) - or something entirely different if your computer doesn't use ASCII character encoding. Unpacking &lt;code&gt;$ps&lt;/code&gt; with the same template returns the original integer value:</source>
          <target state="translated">다시 결과는 2 바이트를 포함하는 문자열입니다. 이 문자열을 인쇄하면 (일반적으로 권장되지 않음) &lt;code&gt;ON&lt;/code&gt; 또는 &lt;code&gt;NO&lt;/code&gt; (시스템의 바이트 순서에 따라 다름) 또는 컴퓨터에서 ASCII 문자 인코딩을 사용하지 않는 경우 완전히 다른 것이 표시 될 수 있습니다. 동일한 템플릿으로 &lt;code&gt;$ps&lt;/code&gt; 를 풀면 원래 정수 값이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="1336fb8f59fe4c2604eb97dc0557c0ec454667ba" translate="yes" xml:space="preserve">
          <source>Again, the same rule about having a valid invocand applies -- use an &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; block or &lt;code&gt;blessed&lt;/code&gt; if you need to be extra paranoid.</source>
          <target state="translated">다시 말하지만, 유효한 invocand있는에 관하여 같은 규칙이 적용됩니다 - 사용 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 블록 또는 &lt;code&gt;blessed&lt;/code&gt; 이 추가 편집증해야합니다.</target>
        </trans-unit>
        <trans-unit id="260a43f1a79644923915e467df41ceec66107f79" translate="yes" xml:space="preserve">
          <source>Again, the same rule about having a valid invocand applies -- use an &lt;code&gt;eval&lt;/code&gt; block or &lt;code&gt;blessed&lt;/code&gt; if you need to be extra paranoid.</source>
          <target state="translated">다시 말하지만, 유효한 발언자에 대한 동일한 규칙이 적용됩니다. &lt;code&gt;eval&lt;/code&gt; 블록을 사용하거나 추가 편집증이 필요한 경우 &lt;code&gt;blessed&lt;/code&gt; 를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="af48945727ba41522de6c011f314a4b843601653" translate="yes" xml:space="preserve">
          <source>Again, there is a distinction between omitting LIST (&lt;a href=&quot;#import-LIST&quot;&gt;&lt;code&gt;import&lt;/code&gt;&lt;/a&gt; called with no arguments) and an explicit empty LIST &lt;code&gt;()&lt;/code&gt; (&lt;a href=&quot;#import-LIST&quot;&gt;&lt;code&gt;import&lt;/code&gt;&lt;/a&gt; not called). Note that there is no comma after VERSION!</source>
          <target state="translated">다시 말하지만, LIST 생략 ( 인수없이 &lt;a href=&quot;#import-LIST&quot;&gt; &lt;code&gt;import&lt;/code&gt; &lt;/a&gt; 호출)과 명시 적 빈 LIST &lt;code&gt;()&lt;/code&gt; ( &lt;a href=&quot;#import-LIST&quot;&gt; &lt;code&gt;import&lt;/code&gt; &lt;/a&gt; not called) 사이에는 차이가 있습니다. VERSION 뒤에는 쉼표가 없습니다!</target>
        </trans-unit>
        <trans-unit id="f032390a780d79dd005854d30b600a71dcbdee7e" translate="yes" xml:space="preserve">
          <source>Again, there is a distinction between omitting LIST (&lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; called with no arguments) and an explicit empty LIST &lt;code&gt;()&lt;/code&gt; (&lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; not called). Note that there is no comma after VERSION!</source>
          <target state="translated">다시, LIST를 생략 사이의 구분 (가 &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; 인수없이 호출) 및 명시 적 빈 LIST &lt;code&gt;()&lt;/code&gt; ( &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; 라고하지 않음). VERSION 이후에는 쉼표가 없습니다!</target>
        </trans-unit>
        <trans-unit id="150579942e699af9662ec748d7e74bb724b4dd49" translate="yes" xml:space="preserve">
          <source>Again, there is a distinction between omitting LIST (&lt;code&gt;&lt;a href=&quot;import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; called with no arguments) and an explicit empty LIST &lt;code&gt;()&lt;/code&gt; (&lt;code&gt;&lt;a href=&quot;import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; not called). Note that there is no comma after VERSION!</source>
          <target state="translated">다시, LIST를 생략 사이의 구분 (가 &lt;code&gt;&lt;a href=&quot;import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; 인수없이 호출) 및 명시 적 빈 LIST &lt;code&gt;()&lt;/code&gt; ( &lt;code&gt;&lt;a href=&quot;import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; 라고하지 않음). VERSION 이후에는 쉼표가 없습니다!</target>
        </trans-unit>
        <trans-unit id="245e36d26002b84ee14a1352ac81744d3ee557bd" translate="yes" xml:space="preserve">
          <source>Again, this allows for very dynamic code.</source>
          <target state="translated">다시 말하지만, 이것은 매우 역동적 인 코드를 허용합니다.</target>
        </trans-unit>
        <trans-unit id="b538a15a09c26e00740fa45cdf77f8fdb9a0d9a7" translate="yes" xml:space="preserve">
          <source>Again, this procedure should not be absolutely smooth. Some &lt;code&gt;Makefile.PL&lt;/code&gt; 's in subdirectories may be buggy, and would not run as &quot;child&quot; scripts. The interdependency of modules can strike you; however, since non-XS modules are already installed, the prerequisites of most modules have a very good chance to be present.</source>
          <target state="translated">다시 말하지만이 절차는 절대적으로 매끄럽지 않아야합니다. 하위 디렉토리에있는 일부 &lt;code&gt;Makefile.PL&lt;/code&gt; 은 버그가있을 수 있으며 &quot;자식&quot;스크립트로 실행되지 않습니다. 모듈의 상호 의존성은 당신을 때릴 수 있습니다. 그러나 비 XS 모듈이 이미 설치되어 있기 때문에 대부분의 모듈의 필수 구성 요소가 존재할 가능성이 매우 높습니다.</target>
        </trans-unit>
        <trans-unit id="1d9afbd965216a5dfe321083c08133da31ca4ac4" translate="yes" xml:space="preserve">
          <source>Again, this procedure should not be absolutely smooth. Some &lt;code&gt;Makefile.PL&lt;/code&gt;'s in subdirectories may be buggy, and would not run as &quot;child&quot; scripts. The interdependency of modules can strike you; however, since non-XS modules are already installed, the prerequisites of most modules have a very good chance to be present.</source>
          <target state="translated">다시 말하지만,이 절차는 절대적으로 매끄럽지 않아야합니다. 하위 디렉토리의 일부 &lt;code&gt;Makefile.PL&lt;/code&gt; 은 버그가있을 수 있으며 &quot;하위&quot;스크립트로 실행되지 않습니다. 모듈의 상호 의존성은 당신에게 충격을 줄 수 있습니다. 그러나 비 XS 모듈이 이미 설치되어 있기 때문에 대부분의 모듈의 전제 조건이 존재할 가능성이 매우 높습니다.</target>
        </trans-unit>
        <trans-unit id="d29cd93346e769552a8195aadabaa89c166d289b" translate="yes" xml:space="preserve">
          <source>Again, this should be a last resort only. Ideally, this should never happen, and every possible effort at cooperation and compromise should be made before doing this. If it does prove necessary to fork a module for the overall health of Perl, proper credit must be given to the original author in perpetuity and the decision should be constantly re-evaluated to see if a remerging of the two branches is possible down the road.</source>
          <target state="translated">다시 말하지만 이것은 최후의 수단 일 것입니다. 이상적으로는 이런 일이 발생하지 않아야하며이를 수행하기 전에 협력 및 타협에 가능한 모든 노력을 기울여야합니다. Perl의 전반적인 건강 상태를 위해 모듈을 포크해야하는 경우, 원래 작성자에게 영구적으로 적절한 크레딧을 제공해야하며, 두 지점의 재결합이 가능한지 확인하기 위해 결정을 지속적으로 재평가해야합니다. .</target>
        </trans-unit>
        <trans-unit id="3a830cc268120c6d62fd1503dae1fe4595320a8c" translate="yes" xml:space="preserve">
          <source>Aggregate TAP::Parser results</source>
          <target state="translated">TAP :: Parser 결과 집계</target>
        </trans-unit>
        <trans-unit id="c99323987b877f0729176ba94246c79d0ffee75d" translate="yes" xml:space="preserve">
          <source>Ah, but what if you wanted a</source>
          <target state="translated">아,하지만 만약 당신이 원한다면</target>
        </trans-unit>
        <trans-unit id="357530061e8b631cc6eb25b6b21e6efa53ba5694" translate="yes" xml:space="preserve">
          <source>Aha. &lt;code&gt;$ical-&amp;gt;day&lt;/code&gt; returned 16, but we expected 17. A quick check shows that the code is working fine, we made a mistake when writing the tests. Change it to:</source>
          <target state="translated">아하. &lt;code&gt;$ical-&amp;gt;day&lt;/code&gt; 는 16 개를 반환했지만 17 개를 예상했습니다. 빠른 확인을 통해 코드가 제대로 작동하는 것으로 나타났습니다. 테스트를 작성할 때 실수를 저질렀습니다. 다음으로 변경하십시오.</target>
        </trans-unit>
        <trans-unit id="d1f92d7475bbcca0ddd4c10b283202094097cb17" translate="yes" xml:space="preserve">
          <source>Alabama</source>
          <target state="translated">Alabama</target>
        </trans-unit>
        <trans-unit id="fc54c7321882850cd59ca3c898a45a1866c62d48" translate="yes" xml:space="preserve">
          <source>Alan Burlison &amp;lt;Alan.Burlison@uk.sun.com&amp;gt;</source>
          <target state="translated">앨런 벌 리슨 &amp;lt;Alan.Burlison@uk.sun.com&amp;gt;</target>
        </trans-unit>
        <trans-unit id="23d7203c5a6f71d67327de67fa96591289ea39aa" translate="yes" xml:space="preserve">
          <source>Alan Gardner &amp;lt;gardner@pythian.com&amp;gt;</source>
          <target state="translated">앨런 가드너 &amp;lt;gardner@pythian.com&amp;gt;</target>
        </trans-unit>
        <trans-unit id="28819c4f1ea8b8ef6efc038b761b2ce064e6ebed" translate="yes" xml:space="preserve">
          <source>Alas, however simple this may appear, underneath it's a much more elaborate construct than meets the eye!</source>
          <target state="translated">아아, 그러나 이것이 간단하게 보일 수 있지만, 그 아래에는 눈을 만나는 것보다 훨씬 정교한 구조가 있습니다!</target>
        </trans-unit>
        <trans-unit id="60deebc91420b65bfc5133938fc33e7af7cddcdc" translate="yes" xml:space="preserve">
          <source>Albeit this is apt to be confusing: As a consequence of the length being implied by the string's length, a number after pack code &lt;code&gt;p&lt;/code&gt; is a repeat count, not a length as after &lt;code&gt;P&lt;/code&gt; .</source>
          <target state="translated">길이가 문자열의 길이에 의해 암시되기 때문에 팩 코드 &lt;code&gt;p&lt;/code&gt; 이후의 숫자 는 반복 횟수이며 &lt;code&gt;P&lt;/code&gt; 이후의 길이는 아닙니다 .</target>
        </trans-unit>
        <trans-unit id="df23ae23f5f2f6c9c33e5c8be5f1d9b8ccdf8644" translate="yes" xml:space="preserve">
          <source>Albeit this is apt to be confusing: As a consequence of the length being implied by the string's length, a number after pack code &lt;code&gt;p&lt;/code&gt; is a repeat count, not a length as after &lt;code&gt;P&lt;/code&gt;.</source>
          <target state="translated">이것은 혼란 스러울 수 있지만 : 길이가 문자열의 길이에 의해 암시되기 때문에 팩 코드 &lt;code&gt;p&lt;/code&gt; 뒤의 숫자 는 &lt;code&gt;P&lt;/code&gt; 뒤의 길이가 아니라 반복 횟수 입니다.</target>
        </trans-unit>
        <trans-unit id="488de67835b3659103e122692a6a41abad7cc229" translate="yes" xml:space="preserve">
          <source>Alessandro Ghedini &amp;lt;al3xbio@gmail.com&amp;gt;</source>
          <target state="translated">Alessandro Ghedini &amp;lt;al3xbio@gmail.com&amp;gt;</target>
        </trans-unit>
        <trans-unit id="08b652678025d31c86fae074be585e578cd5712b" translate="yes" xml:space="preserve">
          <source>Alex Vandiver</source>
          <target state="translated">알렉스 밴 디버</target>
        </trans-unit>
        <trans-unit id="c375d17736d5ba75bae4628bbac2b8464ec67f67" translate="yes" xml:space="preserve">
          <source>Alex Waugh &amp;lt;alex@alexwaugh.com&amp;gt;</source>
          <target state="translated">Alex Waugh &amp;lt;alex@alexwaugh.com&amp;gt;</target>
        </trans-unit>
        <trans-unit id="98410e18a5313b84b52dba6923f79fa84662fc78" translate="yes" xml:space="preserve">
          <source>Algorithmic Complexity Attacks</source>
          <target state="translated">알고리즘 복잡성 공격</target>
        </trans-unit>
        <trans-unit id="880e348dcb112fd7762be969b0a0f638889a7979" translate="yes" xml:space="preserve">
          <source>Alias 'great_circle_bearing' for 'great_circle_direction' is also available.</source>
          <target state="translated">'great_circle_direction'에 대한 별칭 'great_circle_bearing'도 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0898ef4b9ee98efd06a1a0a5dfd90a367c2cd721" translate="yes" xml:space="preserve">
          <source>Alias definitions to encodings</source>
          <target state="translated">인코딩에 대한 별명 정의</target>
        </trans-unit>
        <trans-unit id="2fd22032741764f6c7a3440c32bd355222cc06c7" translate="yes" xml:space="preserve">
          <source>Alias for &lt;a href=&quot;accept_codes&quot;&gt;accept_codes&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;accept_codes&quot;&gt;accept_codes의&lt;/a&gt; 별칭 .</target>
        </trans-unit>
        <trans-unit id="32561c689bd0872a58b1ef016b46a3306d05158a" translate="yes" xml:space="preserve">
          <source>Alias for &lt;a href=&quot;accept_targets&quot;&gt;accept_targets&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;accept_targets&quot;&gt;accept_targets의&lt;/a&gt; 별칭 .</target>
        </trans-unit>
        <trans-unit id="81a5ee4924b19ec7ec50c6564857d6e16abb3950" translate="yes" xml:space="preserve">
          <source>Alias for &lt;a href=&quot;accept_targets_as_text&quot;&gt;accept_targets_as_text&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;accept_targets_as_text&quot;&gt;accept_targets_as_text의&lt;/a&gt; 별칭입니다 .</target>
        </trans-unit>
        <trans-unit id="38f722ea341fc11c96b38a2a9a95013e2024c780" translate="yes" xml:space="preserve">
          <source>Alias for &lt;a href=&quot;http://search.cpan.org/perldoc/accept_codes&quot;&gt;accept_codes&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://search.cpan.org/perldoc/accept_codes&quot;&gt;accept_codes의&lt;/a&gt; 별명입니다 .</target>
        </trans-unit>
        <trans-unit id="f3ca2b4415e7c30e7f132f19403b5bffd02f19e2" translate="yes" xml:space="preserve">
          <source>Alias for &lt;a href=&quot;http://search.cpan.org/perldoc/accept_targets&quot;&gt;accept_targets&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://search.cpan.org/perldoc/accept_targets&quot;&gt;accept_targets의&lt;/a&gt; 별명입니다 .</target>
        </trans-unit>
        <trans-unit id="90cb0f686347b95e9bf9ac20dee8ecef9cc3e7cc" translate="yes" xml:space="preserve">
          <source>Alias for &lt;a href=&quot;http://search.cpan.org/perldoc/accept_targets_as_text&quot;&gt;accept_targets_as_text&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://search.cpan.org/perldoc/accept_targets_as_text&quot;&gt;accept_targets_as_text의&lt;/a&gt; 별명입니다 .</target>
        </trans-unit>
        <trans-unit id="d8a37b728f269336ef2b0d916cf56f8cff9a7dab" translate="yes" xml:space="preserve">
          <source>Alias for &lt;a href=&quot;http://search.cpan.org/perldoc/unaccept_codes&quot;&gt;unaccept_codes&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://search.cpan.org/perldoc/unaccept_codes&quot;&gt;unaccept_codes의&lt;/a&gt; 별명 .</target>
        </trans-unit>
        <trans-unit id="55942451ef5112cddaa2996d9b3ade198613f3aa" translate="yes" xml:space="preserve">
          <source>Alias for &lt;a href=&quot;http://search.cpan.org/perldoc/unaccept_directives&quot;&gt;unaccept_directives&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://search.cpan.org/perldoc/unaccept_directives&quot;&gt;unaccept_directives의&lt;/a&gt; 별명 .</target>
        </trans-unit>
        <trans-unit id="fc63b361fbc74519b267bcb5465524b93139434d" translate="yes" xml:space="preserve">
          <source>Alias for &lt;a href=&quot;http://search.cpan.org/perldoc/unaccept_targets&quot;&gt;unaccept_targets&lt;/a&gt;.</source>
          <target state="translated">에 대한 별칭 &lt;a href=&quot;http://search.cpan.org/perldoc/unaccept_targets&quot;&gt;unaccept_targets&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f57ee5c11f9123d120a1be6cb516c33a71d9d9b4" translate="yes" xml:space="preserve">
          <source>Alias for &lt;a href=&quot;unaccept_codes&quot;&gt;unaccept_codes&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;unaccept_codes&quot;&gt;unaccept_codes의&lt;/a&gt; 별칭 .</target>
        </trans-unit>
        <trans-unit id="57a077c1a7056873f59d1abe4f1a810b70548d85" translate="yes" xml:space="preserve">
          <source>Alias for &lt;a href=&quot;unaccept_directives&quot;&gt;unaccept_directives&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;unaccept_directives&quot;&gt;unaccept_directives의&lt;/a&gt; 별칭 .</target>
        </trans-unit>
        <trans-unit id="b1570978e3e8ee8b4e62f46b1edb2f40542fb2c9" translate="yes" xml:space="preserve">
          <source>Alias for &lt;a href=&quot;unaccept_targets&quot;&gt;unaccept_targets&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;unaccept_targets&quot;&gt;unaccept_targets의&lt;/a&gt; 별칭 .</target>
        </trans-unit>
        <trans-unit id="74c2c2daa5f5a0797029a2454513a78581202693" translate="yes" xml:space="preserve">
          <source>Alias overloading</source>
          <target state="translated">별칭 과부하</target>
        </trans-unit>
        <trans-unit id="f57cd105a2d625b230e3773e4d9ad4fd8007e4e8" translate="yes" xml:space="preserve">
          <source>Aliases are added either by the use of anonymous hashes:</source>
          <target state="translated">익명 해시를 사용하여 별칭을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="a04d03e091eed69bf0cabdf08f34999597a31b63" translate="yes" xml:space="preserve">
          <source>Aliases have no effect on the return value of uncolor().</source>
          <target state="translated">별칭은 uncolor ()의 반환 값에 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="bde3b653ba60660ff94a6811c58e93a5bf93107d" translate="yes" xml:space="preserve">
          <source>Aliases must begin with a character that is alphabetic. After that, each may contain any combination of word (&lt;code&gt;\w&lt;/code&gt; ) characters, SPACE (U+0020), HYPHEN-MINUS (U+002D), LEFT PARENTHESIS (U+0028), RIGHT PARENTHESIS (U+0029), and NO-BREAK SPACE (U+00A0). These last three should never have been allowed in names, and are retained for backwards compatibility only; NO-BREAK SPACE IS currently deprecated and scheduled for removal in Perl v5.26; the other two may also be deprecated and removed in future releases of Perl, so don't use them for new names. (More precisely, the first character of a name you specify must be something that matches all of &lt;code&gt;\p{ID_Start}&lt;/code&gt; , &lt;code&gt;\p{Alphabetic}&lt;/code&gt; , and &lt;code&gt;\p{Gc=Letter}&lt;/code&gt; . This makes sure it is what any reasonable person would view as an alphabetic character. And, the continuation characters that match &lt;code&gt;\w&lt;/code&gt; must also match &lt;code&gt;\p{ID_Continue}&lt;/code&gt; .) Starting with Perl v5.18, any Unicode characters meeting the above criteria may be used; prior to that only Latin1-range characters were acceptable.</source>
          <target state="translated">별명은 알파벳 문자로 시작해야합니다. 그 후, 각 단어 ( &lt;code&gt;\w&lt;/code&gt; ), 스페이스 (U + 0020), 하이픈-마이너스 (U + 002D), 왼쪽 PARENTHESIS (U + 0028), RIGHT PARENTHESIS (U + 0029) 및 NO의 조합을 포함 할 수 있습니다. -BREAK SPACE (U + 00A0). 이 마지막 세 개는 이름으로 허용해서는 안되며 이전 버전과의 호환성을 위해서만 유지됩니다. NO-BREAK SPACE는 현재 더 이상 사용되지 않으며 Perl v5.26에서 제거 될 예정입니다. 다른 두 버전은 향후 Perl 릴리스에서 더 이상 사용되지 않고 제거 될 수 있으므로 새 이름으로 사용하지 마십시오. (더 정확하게, 지정한 이름의 첫 문자는 &lt;code&gt;\p{ID_Start}&lt;/code&gt; , &lt;code&gt;\p{Alphabetic}&lt;/code&gt; 및 &lt;code&gt;\p{Gc=Letter}&lt;/code&gt; 와 모두 일치해야합니다.. 이것은 합리적 인 사람이 알파벳 문자로 볼 수있는 것입니다. &lt;code&gt;\w&lt;/code&gt; 와 일치하는 연속 문자 도 &lt;code&gt;\p{ID_Continue}&lt;/code&gt; 와 일치해야합니다 . Perl v5.18부터는 위의 기준을 충족하는 모든 유니 코드 문자를 사용할 수 있습니다. 그 전에는 라틴어 범위 문자 만 허용되었습니다.</target>
        </trans-unit>
        <trans-unit id="0fcc98867dee3ff48ba5340d53b05e4438818a3a" translate="yes" xml:space="preserve">
          <source>Aliases must begin with a character that is alphabetic. After that, each may contain any combination of word (&lt;code&gt;\w&lt;/code&gt;) characters, SPACE (U+0020), HYPHEN-MINUS (U+002D), LEFT PARENTHESIS (U+0028), and RIGHT PARENTHESIS (U+0029). These last two should never have been allowed in names, and are retained for backwards compatibility only, and may be deprecated and removed in future releases of Perl, so don't use them for new names. (More precisely, the first character of a name you specify must be something that matches all of &lt;code&gt;\p{ID_Start}&lt;/code&gt;, &lt;code&gt;\p{Alphabetic}&lt;/code&gt;, and &lt;code&gt;\p{Gc=Letter}&lt;/code&gt;. This makes sure it is what any reasonable person would view as an alphabetic character. And, the continuation characters that match &lt;code&gt;\w&lt;/code&gt; must also match &lt;code&gt;\p{ID_Continue}&lt;/code&gt;.) Starting with Perl v5.18, any Unicode characters meeting the above criteria may be used; prior to that only Latin1-range characters were acceptable.</source>
          <target state="translated">별칭은 알파벳 문자로 시작해야합니다. 그 후 각 단어 ( &lt;code&gt;\w&lt;/code&gt; ) 문자, 공백 (U + 0020), 하이픈 마이너스 (U + 002D), 왼쪽 괄호 (U + 0028) 및 오른쪽 괄호 (U + 0029)의 조합을 포함 할 수 있습니다. 이 마지막 두 개는 이름에 허용되어서는 안되며 이전 버전과의 호환성을 위해서만 유지되며 향후 Perl 릴리스에서 더 이상 사용되지 않고 제거 될 수 있으므로 새 이름에 사용하지 마십시오. (더 정확하게는, 지정한 이름의 첫 번째 문자는 &lt;code&gt;\p{ID_Start}&lt;/code&gt; , &lt;code&gt;\p{Alphabetic}&lt;/code&gt; , &lt;code&gt;\p{Gc=Letter}&lt;/code&gt; 모두와 일치해야합니다 . 이는 합리적인 사람이 할 수있는 일인지 확인합니다. 알파벳 문자로 볼 수 있습니다. 그리고 &lt;code&gt;\w&lt;/code&gt; 와 일치하는 연속 문자는 &lt;code&gt;\p{ID_Continue}&lt;/code&gt; 와도 일치해야합니다 .) Perl v5.18부터는 위의 기준을 충족하는 모든 유니 코드 문자를 사용할 수 있습니다. 그 이전에는 Latin1 범위의 문자 만 허용되었습니다.</target>
        </trans-unit>
        <trans-unit id="1e1e3bd44efd8fb4bdd5fb525cf0426565ed96d8" translate="yes" xml:space="preserve">
          <source>Aliasing via reference is experimental</source>
          <target state="translated">참조를 통한 별칭은 실험적입니다.</target>
        </trans-unit>
        <trans-unit id="91f975513dec5dd8e68b29fb075833bd77c269b1" translate="yes" xml:space="preserve">
          <source>Alignment, Take 2</source>
          <target state="translated">정렬, 테이크 2</target>
        </trans-unit>
        <trans-unit id="a1ea8b54954e0fde287940a149a033befa43e6c8" translate="yes" xml:space="preserve">
          <source>Alignment, Take 3</source>
          <target state="translated">정렬, 테이크 3</target>
        </trans-unit>
        <trans-unit id="6a72085653e4c5be8c7640c868ef787cbcf063d1" translate="yes" xml:space="preserve">
          <source>All</source>
          <target state="translated">All</target>
        </trans-unit>
        <trans-unit id="c0a3337aa85112ce1c8489ed0e15d622a157e478" translate="yes" xml:space="preserve">
          <source>All &lt;code&gt;--sources&lt;/code&gt; are combined into a hash, and passed to &lt;a href=&quot;TAP::Harness#new&quot;&gt;&quot;new&quot; in TAP::Harness&lt;/a&gt;'s &lt;code&gt;sources&lt;/code&gt; parameter.</source>
          <target state="translated">모든 &lt;code&gt;--sources&lt;/code&gt; 는 해시로 결합되고 &lt;a href=&quot;TAP::Harness#new&quot;&gt;TAP :: Harness&lt;/a&gt; 의 &lt;code&gt;sources&lt;/code&gt; 매개 변수 에서 &quot;new&quot;로 전달됩니다 .</target>
        </trans-unit>
        <trans-unit id="764199267e4fee8134969e2bb73e632b952ebdb3" translate="yes" xml:space="preserve">
          <source>All &lt;code&gt;--sources&lt;/code&gt; are combined into a hash, and passed to &lt;a href=&quot;tap/harness#new&quot;&gt;new in TAP::Harness&lt;/a&gt;'s &lt;code&gt;sources&lt;/code&gt; parameter.</source>
          <target state="translated">모든 &lt;code&gt;--sources&lt;/code&gt; 는 해시로 결합되고 &lt;a href=&quot;tap/harness#new&quot;&gt;TAP :: Harness&lt;/a&gt; 의 &lt;code&gt;sources&lt;/code&gt; 매개 변수 에서 new로 전달됩니다 .</target>
        </trans-unit>
        <trans-unit id="f52d6e40e6d60dfb65b7ff9829f21ad743f4c4af" translate="yes" xml:space="preserve">
          <source>All &lt;code&gt;Digest::&lt;/code&gt; modules provide the same programming interface. A functional interface for simple use, as well as an object oriented interface that can handle messages of arbitrary length and which can read files directly.</source>
          <target state="translated">모든 &lt;code&gt;Digest::&lt;/code&gt; 모듈은 동일한 프로그래밍 인터페이스를 제공합니다. 임의의 길이의 메시지를 처리 ​​할 수 ​​있고 파일을 직접 읽을 수있는 객체 지향 인터페이스뿐만 아니라 간단한 사용을위한 기능 인터페이스.</target>
        </trans-unit>
        <trans-unit id="0b4ba3097ed57d834b19bb582934af5c146d48ec" translate="yes" xml:space="preserve">
          <source>All &lt;code&gt;TAP::*&lt;/code&gt; objects inherit from &lt;a href=&quot;TAP::Object&quot;&gt;TAP::Object&lt;/a&gt;.</source>
          <target state="translated">모든 &lt;code&gt;TAP::*&lt;/code&gt; 객체는 &lt;a href=&quot;TAP::Object&quot;&gt;TAP :: Object&lt;/a&gt; 에서 상속됩니다 .</target>
        </trans-unit>
        <trans-unit id="457b3764fb61bab63f516bcecf7b3d7be10ba056" translate="yes" xml:space="preserve">
          <source>All &lt;code&gt;TAP::*&lt;/code&gt; objects inherit from &lt;a href=&quot;object&quot;&gt;TAP::Object&lt;/a&gt;.</source>
          <target state="translated">모든 &lt;code&gt;TAP::*&lt;/code&gt; 객체는&lt;a href=&quot;object&quot;&gt; TAP :: Object&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5afc429b1453c07f0d0baef120b89dcb6d31ac74" translate="yes" xml:space="preserve">
          <source>All I want to do is append a small amount of text to the end of a file. Do I still have to use locking?</source>
          <target state="translated">내가하고 싶은 것은 파일 끝에 작은 양의 텍스트를 추가하는 것입니다. 여전히 잠금을 사용해야합니까?</target>
        </trans-unit>
        <trans-unit id="364f430073ddd95c184ef6908813da97f63c8227" translate="yes" xml:space="preserve">
          <source>All NULs, returns, and newlines are removed from the result.</source>
          <target state="translated">모든 NUL, 리턴 및 줄 바꾸기가 결과에서 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="3357b46fb83adc9becdcce6c42b795ffab969cd7" translate="yes" xml:space="preserve">
          <source>All Perl applications that make use of the script will need to be changed (slightly) if the script is converted into a module. Is it worth it unless you plan to make other changes at the same time?</source>
          <target state="translated">스크립트를 모듈로 변환 할 경우 스크립트를 사용하는 모든 Perl 응용 프로그램을 약간 변경해야합니다. 동시에 다른 변경을 계획하지 않는 한 가치가 있습니까?</target>
        </trans-unit>
        <trans-unit id="c0556d5f4ef8cf5b2d75a71a511d88da552691b2" translate="yes" xml:space="preserve">
          <source>All Perl module files have the extension</source>
          <target state="translated">모든 Perl 모듈 파일의 확장자는</target>
        </trans-unit>
        <trans-unit id="c9df8c5103a954885f4c9cd5391cce1f658e5378" translate="yes" xml:space="preserve">
          <source>All Perl source filters are implemented as Perl classes and have the same basic structure as the example above.</source>
          <target state="translated">모든 Perl 소스 필터는 Perl 클래스로 구현되며 위 예제와 동일한 기본 구조를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="a24109cbe749713ab37960e5621fab63c25af84c" translate="yes" xml:space="preserve">
          <source>All SVs that contain strings should be terminated with a &lt;code&gt;NUL&lt;/code&gt; character. If it is not &lt;code&gt;NUL&lt;/code&gt; -terminated there is a risk of core dumps and corruptions from code which passes the string to C functions or system calls which expect a &lt;code&gt;NUL&lt;/code&gt; -terminated string. Perl's own functions typically add a trailing &lt;code&gt;NUL&lt;/code&gt; for this reason. Nevertheless, you should be very careful when you pass a string stored in an SV to a C function or system call.</source>
          <target state="translated">문자열을 포함하는 모든 SV는 &lt;code&gt;NUL&lt;/code&gt; 문자 로 끝나야 합니다. &lt;code&gt;NUL&lt;/code&gt; 종료 가 아닌 경우 문자열을 C 함수 또는 &lt;code&gt;NUL&lt;/code&gt; 종료 문자열 을 기대하는 시스템 호출로 전달하는 코드에서 코어 덤프 및 손상의 위험이 있습니다. 펄 자신의 함수는 일반적으로 후행 &lt;code&gt;NUL&lt;/code&gt; 을 추가합니다 이런 이유로 을 . 그럼에도 불구하고 SV에 저장된 문자열을 C 함수 나 시스템 호출에 전달할 때는 매우주의해야합니다.</target>
        </trans-unit>
        <trans-unit id="811244b951b8c0eb98e3e07cd16b2604bbbc05a1" translate="yes" xml:space="preserve">
          <source>All SVs that contain strings should be terminated with a &lt;code&gt;NUL&lt;/code&gt; character. If it is not &lt;code&gt;NUL&lt;/code&gt;-terminated there is a risk of core dumps and corruptions from code which passes the string to C functions or system calls which expect a &lt;code&gt;NUL&lt;/code&gt;-terminated string. Perl's own functions typically add a trailing &lt;code&gt;NUL&lt;/code&gt; for this reason. Nevertheless, you should be very careful when you pass a string stored in an SV to a C function or system call.</source>
          <target state="translated">문자열을 포함하는 모든 SV는 &lt;code&gt;NUL&lt;/code&gt; 문자 로 종료되어야합니다 . 그렇지 않은 경우 &lt;code&gt;NUL&lt;/code&gt; 은 C 함수 또는 기대 시스템 호출에 문자열을 통과 코드에서 코어 덤프 및 손상의 위험이로 끝나는 &lt;code&gt;NUL&lt;/code&gt; 은 문자열로 끝나는이. Perl의 자체 함수는 일반적으로 이러한 이유로 후행 &lt;code&gt;NUL&lt;/code&gt; 을 추가합니다 . 그럼에도 불구하고 SV에 저장된 문자열을 C 함수 또는 시스템 호출로 전달할 때는 매우주의해야합니다.</target>
        </trans-unit>
        <trans-unit id="48a5c9b581d8c7b87b13529ddc2ea4756cd71725" translate="yes" xml:space="preserve">
          <source>All Solaris documentation is available on-line at &lt;a href=&quot;http://docs.sun.com/&quot;&gt;http://docs.sun.com/&lt;/a&gt;.</source>
          <target state="translated">모든 Solaris 설명서는 &lt;a href=&quot;http://docs.sun.com/&quot;&gt;http://docs.sun.com/&lt;/a&gt; 에서 온라인으로 제공됩니다. .</target>
        </trans-unit>
        <trans-unit id="02a6fc4950c3ff395602f4e234c32b98fa8bbb9b" translate="yes" xml:space="preserve">
          <source>All Unicode-defined character properties may be written in these compound forms of &lt;code&gt;\p{&lt;i&gt;property&lt;/i&gt;=&lt;i&gt;value&lt;/i&gt;}&lt;/code&gt; or &lt;code&gt;\p{&lt;i&gt;property&lt;/i&gt;:&lt;i&gt;value&lt;/i&gt;}&lt;/code&gt;, but Perl provides some additional properties that are written only in the single form, as well as single-form short-cuts for all binary properties and certain others described below, in which you may omit the property name and the equals or colon separator.</source>
          <target state="translated">모든 유니 코드 정의 문자 특성은 이러한 복합 형식의 &lt;code&gt;\p{&lt;i&gt;property&lt;/i&gt;=&lt;i&gt;value&lt;/i&gt;}&lt;/code&gt; 또는 &lt;code&gt;\p{&lt;i&gt;property&lt;/i&gt;:&lt;i&gt;value&lt;/i&gt;}&lt;/code&gt; 로 작성 될 수 있지만 Perl은 단일 형식뿐만 아니라 단일 형식으로 만 작성된 일부 추가 특성을 제공합니다. 속성 이름과 등호 또는 콜론 구분 기호를 생략 할 수있는 모든 이진 속성 및 아래 설명 된 특정 속성에 대한 바로 가기를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="824a27b5a0842833d945bd7311a2e5202945d5f2" translate="yes" xml:space="preserve">
          <source>All above are #define'd to stdio functions or are trivial wrapper functions which call stdio. In this case</source>
          <target state="translated">위의 내용은 # stdio 함수로 정의되거나 stdio를 호출하는 간단한 래퍼 함수입니다. 이 경우</target>
        </trans-unit>
        <trans-unit id="480b6099af5b199261a0cc5b0a69906525b8aab5" translate="yes" xml:space="preserve">
          <source>All are zero-width assertions.</source>
          <target state="translated">모두 폭이 0 인 어설 션입니다.</target>
        </trans-unit>
        <trans-unit id="ea4147392f071907aee8241573927949a9171c29" translate="yes" xml:space="preserve">
          <source>All arguments are optional. If the escape characters are not specified, every delimiter is escaped with a backslash (&lt;code&gt;\&lt;/code&gt; ). If the prefix is not specified, the pattern &lt;code&gt;'\s*'&lt;/code&gt; - optional whitespace - is used. If the delimiter set is also not specified, the set &lt;code&gt;/[&quot;'`]/&lt;/code&gt; is used. If the text to be processed is not specified either, &lt;code&gt;$_&lt;/code&gt; is used.</source>
          <target state="translated">모든 인수는 선택 사항입니다. 이스케이프 문자를 지정하지 않으면 모든 구분 기호가 백 슬래시 ( &lt;code&gt;\&lt;/code&gt; )로 이스케이프됩니다 . 접두사가 지정되지 않으면 패턴 &lt;code&gt;'\s*'&lt;/code&gt; 선택적 공백)가 사용됩니다. 분리 문자 세트도 지정되지 않으면 세트 &lt;code&gt;/[&quot;'`]/&lt;/code&gt; 가 사용됩니다. 처리 될 텍스트도 지정되지 않으면 &lt;code&gt;$_&lt;/code&gt; 가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="0181edbc9494b74d89dc3b19084803fb4f26c83d" translate="yes" xml:space="preserve">
          <source>All arguments are optional. If the escape characters are not specified, every delimiter is escaped with a backslash (&lt;code&gt;\&lt;/code&gt;). If the prefix is not specified, the pattern &lt;code&gt;'\s*'&lt;/code&gt; - optional whitespace - is used. If the delimiter set is also not specified, the set &lt;code&gt;/[&quot;'`]/&lt;/code&gt; is used. If the text to be processed is not specified either, &lt;code&gt;$_&lt;/code&gt; is used.</source>
          <target state="translated">모든 인수는 선택 사항입니다. 이스케이프 문자를 지정하지 않으면 모든 구분 기호가 백 슬래시 ( &lt;code&gt;\&lt;/code&gt; )로 이스케이프됩니다 . 접두사가 지정되지 않으면 &lt;code&gt;'\s*'&lt;/code&gt; 패턴 ( 선택적 공백)이 사용됩니다. 구분자 집합도 지정하지 않으면 &lt;code&gt;/[&quot;'`]/&lt;/code&gt; 집합을 사용하고, 처리 할 텍스트도 지정하지 않으면 &lt;code&gt;$_&lt;/code&gt; 를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="9ae556487b52756ee168bee18fdadcf299ff8eb4" translate="yes" xml:space="preserve">
          <source>All arguments passed to &lt;code&gt;&lt;a href=&quot;../../functions/import&quot;&gt;import()&lt;/a&gt;&lt;/code&gt; are passed onto &lt;code&gt;Your::Module-&amp;gt;builder-&amp;gt;plan()&lt;/code&gt; with the exception of &lt;code&gt;import =&amp;gt;[qw(things to import)]&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../../functions/import&quot;&gt;import()&lt;/a&gt;&lt;/code&gt; 에 전달 된 모든 인수 는 &lt;code&gt;import =&amp;gt;[qw(things to import)]&lt;/code&gt; 제외 하고 &lt;code&gt;Your::Module-&amp;gt;builder-&amp;gt;plan()&lt;/code&gt; 으로 전달 됩니다.</target>
        </trans-unit>
        <trans-unit id="fdbd10dc9e3c80b9ba924c94c8cb38d914c05e64" translate="yes" xml:space="preserve">
          <source>All arguments passed to &lt;code&gt;import()&lt;/code&gt; are passed onto &lt;code&gt;Your::Module-&amp;gt;builder-&amp;gt;plan()&lt;/code&gt; with the exception of &lt;code&gt;import =&amp;gt;[qw(things to import)]&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;import()&lt;/code&gt; 에 전달 된 모든 인수 는 &lt;code&gt;import =&amp;gt;[qw(things to import)]&lt;/code&gt; 제외 하고 &lt;code&gt;Your::Module-&amp;gt;builder-&amp;gt;plan()&lt;/code&gt; 됩니다 .</target>
        </trans-unit>
        <trans-unit id="b2e982744f4ac0300218d6f294863226187db18a" translate="yes" xml:space="preserve">
          <source>All arguments passed to the &lt;b&gt;new()&lt;/b&gt; constructor will be treated as key/value pairs in a hash-table. The newly constructed object will be initialized by copying the contents of the given hash-table (which may have been empty). The &lt;b&gt;new()&lt;/b&gt; constructor for this class and all of its subclasses returns a blessed reference to the initialized object (hash-table).</source>
          <target state="translated">&lt;b&gt;new ()&lt;/b&gt; 생성자로 전달 된 모든 인수 는 해시 테이블에서 키 / 값 쌍으로 처리됩니다. 새로 생성 된 객체는 주어진 해시 테이블 (비어있을 수 있음)의 내용을 복사하여 초기화됩니다. &lt;b&gt;새로운 ()&lt;/b&gt; 이 클래스와 그 서브 클래스의 모든 생성자는 초기화 된 객체 (해시 테이블)에 축복 참조를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="ec83cba8a792f2692f5daa6167d2d16a27e37ea4" translate="yes" xml:space="preserve">
          <source>All arguments to bootstrap() are passed to the module's bootstrap function. The default code generated by</source>
          <target state="translated">bootstrap ()에 대한 모든 인수는 모듈의 부트 스트랩 함수로 전달됩니다. 에 의해 생성 된 기본 코드</target>
        </trans-unit>
        <trans-unit id="0afa74976449293b4a190730ab23181cbe3c7232" translate="yes" xml:space="preserve">
          <source>All binary formats in IEEE 754-2008 are accepted. For convenience, som aliases are recognized: &quot;half&quot; for &quot;binary16&quot;, &quot;single&quot; for &quot;binary32&quot;, &quot;double&quot; for &quot;binary64&quot;, &quot;quadruple&quot; for &quot;binary128&quot;, &quot;octuple&quot; for &quot;binary256&quot;, and &quot;sexdecuple&quot; for &quot;binary512&quot;.</source>
          <target state="translated">IEEE 754-2008의 모든 바이너리 형식이 허용됩니다. 편의상 일부 별칭은 &quot;binary16&quot;의 경우 &quot;half&quot;, &quot;binary32&quot;의 경우 &quot;single&quot;, &quot;binary64&quot;의 경우 &quot;double&quot;, &quot;binary128&quot;의 경우 &quot;quadruple&quot;, &quot;binary256&quot;의 경우 &quot;octuple&quot;, &quot; &quot;binary512&quot;의 경우 sexdecuple &quot;입니다.</target>
        </trans-unit>
        <trans-unit id="0641330064a33946ad2abf69443076e60a765bfc" translate="yes" xml:space="preserve">
          <source>All bytes in a multi-byte UTF-8 character will have the high bit set, so you can test if you need to do something special with this character like this (the &lt;code&gt;UTF8_IS_INVARIANT()&lt;/code&gt; is a macro that tests whether the byte is encoded as a single byte even in UTF-8):</source>
          <target state="translated">멀티 바이트 UTF-8 문자의 모든 바이트는 높은 비트 세트를 가지므로 다음과 &lt;code&gt;UTF8_IS_INVARIANT()&lt;/code&gt; 문자로 특별한 작업을 수행 해야하는지 테스트 할 수 있습니다 ( UTF8_IS_INVARIANT () 는 바이트가 다음과 같이 인코딩되는지 여부를 테스트하는 매크로입니다 ) UTF-8에서도 단일 바이트) :</target>
        </trans-unit>
        <trans-unit id="590dee2e50eabc45f58681f49c28cfb5697f75ac" translate="yes" xml:space="preserve">
          <source>All characters in the sequence come from the Common script and/or the Inherited script and/or a single other script.</source>
          <target state="translated">시퀀스의 모든 문자는 공통 스크립트 및 / 또는 상속 된 스크립트 및 / 또는 단일 다른 스크립트에서 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="3518d33b42f2dc03b1a9ce5a7bf1630a8c432554" translate="yes" xml:space="preserve">
          <source>All classes automatically inherit from the &lt;a href=&quot;universal&quot;&gt;UNIVERSAL&lt;/a&gt; class, which is built-in to the Perl core. This class provides a number of methods, all of which can be called on either a class or an object. You can also choose to override some of these methods in your class. If you do so, we recommend that you follow the built-in semantics described below.</source>
          <target state="translated">모든 클래스 는 Perl 코어에 내장 된 &lt;a href=&quot;universal&quot;&gt;UNIVERSAL&lt;/a&gt; 클래스 에서 자동으로 상속됩니다 . 이 클래스는 많은 메소드를 제공하며, 모두 클래스 또는 객체에서 호출 할 수 있습니다. 클래스에서 이러한 메소드 중 일부를 대체하도록 선택할 수도 있습니다. 그렇게하는 경우 아래 설명 된 내장 의미 체계를 따르는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="01913ce43f34cc16d63eaaa24a00e403aac3c548" translate="yes" xml:space="preserve">
          <source>All classes inherit from the &lt;a href=&quot;universal&quot;&gt;UNIVERSAL&lt;/a&gt; class implicitly. The &lt;a href=&quot;universal&quot;&gt;UNIVERSAL&lt;/a&gt; class is implemented by the Perl core, and provides several default methods, such as &lt;code&gt;isa()&lt;/code&gt; , &lt;code&gt;can()&lt;/code&gt; , and &lt;code&gt;VERSION()&lt;/code&gt; . The &lt;code&gt;UNIVERSAL&lt;/code&gt; class will</source>
          <target state="translated">모든 클래스는 &lt;a href=&quot;universal&quot;&gt;UNIVERSAL&lt;/a&gt; 클래스에서 암시 적으로 상속됩니다 . &lt;a href=&quot;universal&quot;&gt;UNIVERSAL의&lt;/a&gt; 클래스는 펄 코어로 구현하고 다음과 같은 몇 가지 기본 방법을 제공한다 &lt;code&gt;isa()&lt;/code&gt; , &lt;code&gt;can()&lt;/code&gt; , 및 &lt;code&gt;VERSION()&lt;/code&gt; . &lt;code&gt;UNIVERSAL&lt;/code&gt; 의 클래스 의지</target>
        </trans-unit>
        <trans-unit id="3d8786449350954bfaf5ebc4e26abe8061ed8466" translate="yes" xml:space="preserve">
          <source>All classes inherit from the &lt;a href=&quot;universal&quot;&gt;UNIVERSAL&lt;/a&gt; class implicitly. The &lt;a href=&quot;universal&quot;&gt;UNIVERSAL&lt;/a&gt; class is implemented by the Perl core, and provides several default methods, such as &lt;code&gt;isa()&lt;/code&gt;, &lt;code&gt;can()&lt;/code&gt;, and &lt;code&gt;VERSION()&lt;/code&gt;. The &lt;code&gt;UNIVERSAL&lt;/code&gt; class will</source>
          <target state="translated">모든 클래스는 &lt;a href=&quot;universal&quot;&gt;UNIVERSAL&lt;/a&gt; 클래스에서 암시 적으로 상속됩니다 . &lt;a href=&quot;universal&quot;&gt;UNIVERSAL의&lt;/a&gt; 클래스는 펄 코어로 구현하고 다음과 같은 몇 가지 기본 방법을 제공한다 &lt;code&gt;isa()&lt;/code&gt; , &lt;code&gt;can()&lt;/code&gt; , 및 &lt;code&gt;VERSION()&lt;/code&gt; . &lt;code&gt;UNIVERSAL&lt;/code&gt; 의 클래스 의지</target>
        </trans-unit>
        <trans-unit id="d7ed55b8e4e0eb9f903d01566d45c62ffc547221" translate="yes" xml:space="preserve">
          <source>All code points that would be matched by this are matched by either &quot;Script_Extensions=Katakana&quot; or &quot;Script_Extensions=Hiragana&quot;</source>
          <target state="translated">이것과 일치하는 모든 코드 포인트는 &quot;Script_Extensions = Katakana&quot;또는 &quot;Script_Extensions = Hiragana&quot;와 일치합니다.</target>
        </trans-unit>
        <trans-unit id="68b93a9f8c08d5ea78bcf3b0d94efaeadf4ebfe0" translate="yes" xml:space="preserve">
          <source>All command paragraphs (which are typically only one line long) start with &quot;=&quot;, followed by an identifier, followed by arbitrary text that the command can use however it pleases. Currently recognized commands are</source>
          <target state="translated">모든 명령 단락 (일반적으로 한 줄 길이 임)은 &quot;=&quot;로 시작하고, 식별자와 명령이 사용할 수있는 임의의 텍스트가 뒤 따릅니다. 현재 인식되는 명령은</target>
        </trans-unit>
        <trans-unit id="1de072221a4c4b45ef17376165aefcc6117f7cbb" translate="yes" xml:space="preserve">
          <source>All contributors are credited (by name and email address) in the AUTHORS file, which is part of the perl distribution, as well as the Git commit history.</source>
          <target state="translated">모든 기여자는 Perl 배포 및 Git 커밋 기록의 일부인 AUTHORS 파일에 이름과 이메일 주소로 크레딧이 부여됩니다.</target>
        </trans-unit>
        <trans-unit id="7bb1791a22508fb25f0ae8abd390beff83b2b84d" translate="yes" xml:space="preserve">
          <source>All cp* are also available as ibm-*, ms-*, and windows-* . See also &lt;a href=&quot;http://czyborra.com/charsets/codepages.html&quot;&gt;http://czyborra.com/charsets/codepages.html&lt;/a&gt;.</source>
          <target state="translated">모든 cp *는 ibm- *, ms- * 및 windows- *로도 제공됩니다. &lt;a href=&quot;http://czyborra.com/charsets/codepages.html&quot;&gt;http://czyborra.com/charsets/codepages.html&lt;/a&gt; 도 참조 하십시오 .</target>
        </trans-unit>
        <trans-unit id="982b67a682c875ad11cfce0a29c201661fc04837" translate="yes" xml:space="preserve">
          <source>All data in Perl is a scalar, an array of scalars, or a hash of scalars. A scalar may contain one single value in any of three different flavors: a number, a string, or a reference. In general, conversion from one form to another is transparent. Although a scalar may not directly hold multiple values, it may contain a reference to an array or hash which in turn contains multiple values.</source>
          <target state="translated">Perl의 모든 데이터는 스칼라, 스칼라 배열 또는 스칼라 해시입니다. 스칼라는 숫자, 문자열 또는 참조의 세 가지 맛 중 하나에 하나의 단일 값을 포함 할 수 있습니다. 일반적으로 한 형태에서 다른 형태로의 변환은 투명합니다. 스칼라는 여러 값을 직접 보유 할 수는 없지만 배열 또는 해시에 대한 참조를 포함 할 수 있으며이 값에는 여러 값이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="ed2d650047726f656af3f0a2c3d91d2c0b337ee7" translate="yes" xml:space="preserve">
          <source>All decimal digits in the sequence come from the same block of 10 consecutive digits.</source>
          <target state="translated">시퀀스의 모든 10 진수는 10 개의 연속 된 숫자로 구성된 동일한 블록에서 나옵니다.</target>
        </trans-unit>
        <trans-unit id="69c2eb01381ceb109c37169bc1329fc48f7a2dca" translate="yes" xml:space="preserve">
          <source>All decryption filters work on the principle of &quot;security through obscurity.&quot; Regardless of how well you write a decryption filter and how strong your encryption algorithm is, anyone determined enough can retrieve the original source code. The reason is quite simple - once the decryption filter has decrypted the source back to its original form, fragments of it will be stored in the computer's memory as Perl parses it. The source might only be in memory for a short period of time, but anyone possessing a debugger, skill, and lots of patience can eventually reconstruct your program.</source>
          <target state="translated">모든 암호 해독 필터는 &quot;모호함을 통한 보안&quot;원칙에 따라 작동합니다. 해독 필터를 얼마나 잘 작성하고 암호화 알고리즘이 얼마나 강력한 지에 관계없이 누구나 원본 소스 코드를 검색 할 수 있습니다. 그 이유는 매우 간단합니다. 일단 해독 필터가 소스를 원래 형태로 해독 한 후에는 Perl이 구문 분석 할 때 그 조각이 컴퓨터의 메모리에 저장됩니다. 소스는 짧은 시간 동안 만 메모리에있을 수 있지만 디버거, 기술 및 인내심이 많은 사람은 결국 프로그램을 재구성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ba741a80f2a14355d94b77c4ceb115a27afc7f18" translate="yes" xml:space="preserve">
          <source>All defaults for Configure can be used.</source>
          <target state="translated">구성의 모든 기본값을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="acfa01600fe34368d13dbcac106b2c8f27f49465" translate="yes" xml:space="preserve">
          <source>All development releases of perl since 5.9.0 are covered.</source>
          <target state="translated">5.9.0 이후 펄의 모든 개발 릴리스가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="df049cfa442a524a56259811400e36eee4811c18" translate="yes" xml:space="preserve">
          <source>All diagnostic output is sent to &lt;code&gt;STDERR&lt;/code&gt; .</source>
          <target state="translated">모든 진단 출력은 &lt;code&gt;STDERR&lt;/code&gt; 로 전송됩니다 .</target>
        </trans-unit>
        <trans-unit id="64e79b552ae9079b9dfb00241c55031cd0a6d511" translate="yes" xml:space="preserve">
          <source>All diagnostic output is sent to &lt;code&gt;STDERR&lt;/code&gt;.</source>
          <target state="translated">모든 진단 출력은 &lt;code&gt;STDERR&lt;/code&gt; 로 전송됩니다 .</target>
        </trans-unit>
        <trans-unit id="93306c0ef9fe5f266a659b8a075c1bae7f08ce4e" translate="yes" xml:space="preserve">
          <source>All dollar signs must be doubled in the $perl_code if you expect them to be interpreted normally, otherwise it will be considered a make macro. Also remember to quote make macros else it might be used as a bareword. For example:</source>
          <target state="translated">정상적으로 해석 될 것으로 예상되는 경우 모든 달러 기호는 $ perl_code에서 두 배가되어야합니다. 그렇지 않으면 make 매크로로 간주됩니다. 또한 매크로를 인용하면 다른 단어로 사용될 수도 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7a1f8634b122edec02ff5f85c8a73c5f24ae4096" translate="yes" xml:space="preserve">
          <source>All environment vars must be stored in HKLM\Environment as strings. They are read at process startup.</source>
          <target state="translated">모든 환경 변수는 HKLM \ Environment에 문자열로 저장해야합니다. 프로세스 시작시 읽습니다.</target>
        </trans-unit>
        <trans-unit id="92b87396d02d1c058e99dc606debd7ebb31b0abf" translate="yes" xml:space="preserve">
          <source>All error reporting is done with exceptions (die'ing).</source>
          <target state="translated">모든 오류보고는 예외 (다이닝)와 함께 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="aad7b02bc36afcc3c6ccb34581d934b2eb922003" translate="yes" xml:space="preserve">
          <source>All exports are optional.</source>
          <target state="translated">모든 내보내기는 선택 사항입니다.</target>
        </trans-unit>
        <trans-unit id="75a6a1a25e95f80ccec351dcecf8848cf88b4a03" translate="yes" xml:space="preserve">
          <source>All exports are optional. You must specify subs to import.</source>
          <target state="translated">모든 내보내기는 선택 사항입니다. 가져올 구독자를 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="a4598089b44f88002de1104436e43b04446e3730" translate="yes" xml:space="preserve">
          <source>All exports are optional. You need to list which ones you want at import time:</source>
          <target state="translated">모든 내보내기는 선택 사항입니다. 가져올 때 원하는 항목을 나열해야합니다.</target>
        </trans-unit>
        <trans-unit id="7a3f297670f9579dd31a61d74a21533ee88a594f" translate="yes" xml:space="preserve">
          <source>All features that combine Unicode and I/O also require using the new PerlIO feature. Almost all Perl 5.8 platforms do use PerlIO, though: you can see whether yours is by running &quot;perl -V&quot; and looking for &lt;code&gt;useperlio=define&lt;/code&gt; .</source>
          <target state="translated">유니 코드와 I / O를 결합한 모든 기능은 새로운 PerlIO 기능을 사용해야합니다. 그러나 대부분의 모든 Perl 5.8 플랫폼은 PerlIO를 사용합니다. &quot;perl -V&quot;를 실행하고 &lt;code&gt;useperlio=define&lt;/code&gt; 을 검색 하여 사용 중인지 확인할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="663418839693a934f145e368b817368ec9da8457" translate="yes" xml:space="preserve">
          <source>All features that combine Unicode and I/O also require using the new PerlIO feature. Almost all Perl 5.8 platforms do use PerlIO, though: you can see whether yours is by running &quot;perl -V&quot; and looking for &lt;code&gt;useperlio=define&lt;/code&gt;.</source>
          <target state="translated">유니 코드와 I / O를 결합하는 모든 기능은 새로운 PerlIO 기능을 사용해야합니다. 하지만 거의 모든 Perl 5.8 플랫폼은 PerlIO를 사용합니다. &quot;perl -V&quot;를 실행하고 &lt;code&gt;useperlio=define&lt;/code&gt; 을 검색 하면 현재 사용중인 플랫폼인지 확인할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ad80d55320f9dffac4aa0255715379a201879293" translate="yes" xml:space="preserve">
          <source>All file tests (&lt;code&gt;-f&lt;/code&gt; , &lt;code&gt;-d&lt;/code&gt; ) except for &lt;code&gt;-t&lt;/code&gt; , which defaults to STDIN. See &lt;a href=&quot;functions/-x&quot;&gt;-X&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;-t&lt;/code&gt; 를 제외한 모든 파일 테스트 ( &lt;code&gt;-f&lt;/code&gt; , &lt;code&gt;-d&lt;/code&gt; ) . 기본값은 STDIN입니다. &lt;a href=&quot;functions/-x&quot;&gt;-X&lt;/a&gt; 참조</target>
        </trans-unit>
        <trans-unit id="2b3536b700bffdda6d1f615511ebd63b36d79bc4" translate="yes" xml:space="preserve">
          <source>All file tests (&lt;code&gt;-f&lt;/code&gt;, &lt;code&gt;-d&lt;/code&gt;) except for &lt;code&gt;-t&lt;/code&gt;, which defaults to STDIN. See &lt;a href=&quot;perlfunc#-X&quot;&gt;&quot;-X&quot; in perlfunc&lt;/a&gt;</source>
          <target state="translated">기본값이 STDIN 인 &lt;code&gt;-t&lt;/code&gt; 를 제외한 모든 파일 테스트 ( &lt;code&gt;-f&lt;/code&gt; , &lt;code&gt;-d&lt;/code&gt; ) . &lt;a href=&quot;perlfunc#-X&quot;&gt;perlfunc의 &quot;-X&quot;&lt;/a&gt; 참조</target>
        </trans-unit>
        <trans-unit id="08be6efb337bd6c91da1907b6a743dc9f1f57549" translate="yes" xml:space="preserve">
          <source>All files are stored internally as &lt;code&gt;Archive::Tar::File&lt;/code&gt; objects. Please consult the &lt;a href=&quot;Archive::Tar::File&quot;&gt;Archive::Tar::File&lt;/a&gt; documentation for details.</source>
          <target state="translated">모든 파일은 내부적으로 &lt;code&gt;Archive::Tar::File&lt;/code&gt; 객체 로 저장 됩니다. 자세한 내용은 &lt;a href=&quot;Archive::Tar::File&quot;&gt;Archive :: Tar :: File&lt;/a&gt; 문서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="815b16d15ecd8197f8c89531e6b38bdaa59c037d" translate="yes" xml:space="preserve">
          <source>All files are stored internally as &lt;code&gt;Archive::Tar::File&lt;/code&gt; objects. Please consult the &lt;a href=&quot;tar/file&quot;&gt;Archive::Tar::File&lt;/a&gt; documentation for details.</source>
          <target state="translated">모든 파일은 내부적으로 &lt;code&gt;Archive::Tar::File&lt;/code&gt; 객체 로 저장 됩니다. 자세한 내용은 &lt;a href=&quot;tar/file&quot;&gt;Archive :: Tar :: File&lt;/a&gt; 문서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="f073482fc073c0918a2379dd16dc7865e1091f64" translate="yes" xml:space="preserve">
          <source>All files that match any regular expression in a file</source>
          <target state="translated">파일의 정규식과 일치하는 모든 파일</target>
        </trans-unit>
        <trans-unit id="cfa975a72f5514a96c923193276bf554b250a3e3" translate="yes" xml:space="preserve">
          <source>All files used by the program or function, normally presented as a list, and what it uses them for. File names should be enclosed in F&amp;lt;&amp;gt;. It's particularly important to document files that will be potentially modified.</source>
          <target state="translated">프로그램이나 기능에서 사용하는 모든 파일 (일반적으로 목록으로 표시됨) 파일 이름은 F &amp;lt;&amp;gt;로 묶어야합니다. 잠재적으로 수정 될 파일을 문서화하는 것이 특히 중요합니다.</target>
        </trans-unit>
        <trans-unit id="a2dd9a73e29796f6b2de6625428d9204a9270fdb" translate="yes" xml:space="preserve">
          <source>All filter methods return the existing filter, if present, or &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; if not.</source>
          <target state="translated">모든 필터 메소드는 기존 필터가있는 경우이를 리턴하거나 존재 하지 않으면 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 를 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="4139db9439a578bf12cb959a5143dbafa321c592" translate="yes" xml:space="preserve">
          <source>All filter methods return the existing filter, if present, or &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; in not.</source>
          <target state="translated">모든 필터 메소드는 존재하는 경우 기존 필터를 리턴하거나 그렇지 않은 경우 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 로 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="60b28d5e793ebb6f4e7dabaca1fb381c7f91a2f1" translate="yes" xml:space="preserve">
          <source>All filter methods return the existing filter, if present, or &lt;code&gt;undef&lt;/code&gt; if not.</source>
          <target state="translated">모든 필터 메서드는 기존 필터 (있는 경우)를 반환하고 그렇지 않은 경우 &lt;code&gt;undef&lt;/code&gt; 를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="f258f594dcd790bdcd378df3365ecaddd9a85f4a" translate="yes" xml:space="preserve">
          <source>All filter methods return the existing filter, if present, or &lt;code&gt;undef&lt;/code&gt; in not.</source>
          <target state="translated">모든 필터 메서드는 기존 필터 (있는 경우)를 반환하거나 그렇지 않은 경우 &lt;code&gt;undef&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="311ff967643c4d237a819b285dc4b5880471f22d" translate="yes" xml:space="preserve">
          <source>All forms of the pragma enable use of the following 3 functions:</source>
          <target state="translated">모든 형태의 pragma는 다음 3 가지 기능을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="74749eec650dc1a9457b607830f24533a5ba9c1c" translate="yes" xml:space="preserve">
          <source>All four routines return the number of arguments that the subroutine returned on the Perl stack.</source>
          <target state="translated">네 가지 루틴 모두 서브 루틴이 Perl 스택에서 리턴 한 인수 수를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="5e2132ad2da2d7aa2f6043aad2cc1232db0e47df" translate="yes" xml:space="preserve">
          <source>All functions have the following rules to decide what it thinks you want:</source>
          <target state="translated">모든 기능에는 원하는 규칙을 결정하기 위해 다음 규칙이 있습니다.</target>
        </trans-unit>
        <trans-unit id="7a4768442025565f5f815b90b4d35c19d4f3c9c1" translate="yes" xml:space="preserve">
          <source>All functions return 1 on success, 0 on failure. $! will be set if an error was encountered.</source>
          <target state="translated">모든 함수는 성공하면 1을, 실패하면 0을 반환합니다. $! 오류가 발생하면 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="6ff8d7d6682320cce258b48a2cf6142f6da6f3bb" translate="yes" xml:space="preserve">
          <source>All functions that are capable of creating filehandles (open(), opendir(), pipe(), socketpair(), sysopen(), socket(), and accept()) automatically create an anonymous filehandle if the handle passed to them is an uninitialized scalar variable. This allows the constructs such as &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;(&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; $fh, ...)&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;(&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt; $fh,...)&lt;/code&gt; to be used to create filehandles that will conveniently be closed automatically when the scope ends, provided there are no other references to them. This largely eliminates the need for typeglobs when opening filehandles that must be passed around, as in the following example:</source>
          <target state="translated">파일 핸들 (open (), opendir (), pipe (), socketpair (), sysopen (), socket () 및 accept ())을 작성할 수있는 모든 함수는 핸들이 전달 된 경우 익명 파일 핸들을 자동으로 작성합니다. 초기화되지 않은 스칼라 변수 이렇게하면 다른 참조가없는 경우 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;(&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; $fh, ...)&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;(&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt; $fh,...)&lt;/code&gt; 과 같은 구문을 사용하여 범위가 끝나면 자동으로 닫히는 파일 핸들을 만들 수 있습니다. 그들에게. 이렇게하면 다음 예제와 같이 전달해야하는 파일 핸들을 열 때 typeglob가 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="aaf8b5a1c33d35dc738f6386586e46de8c383c2d" translate="yes" xml:space="preserve">
          <source>All functions that are capable of creating filehandles (open(), opendir(), pipe(), socketpair(), sysopen(), socket(), and accept()) automatically create an anonymous filehandle if the handle passed to them is an uninitialized scalar variable. This allows the constructs such as &lt;code&gt;open(my $fh, ...)&lt;/code&gt; and &lt;code&gt;open(local $fh,...)&lt;/code&gt; to be used to create filehandles that will conveniently be closed automatically when the scope ends, provided there are no other references to them. This largely eliminates the need for typeglobs when opening filehandles that must be passed around, as in the following example:</source>
          <target state="translated">파일 핸들을 생성 할 수있는 모든 함수 (open (), opendir (), pipe (), socketpair (), sysopen (), socket () 및 accept ())는 전달 된 핸들이 다음과 같으면 자동으로 익명 파일 핸들을 생성합니다. 초기화되지 않은 스칼라 변수. 이를 통해 &lt;code&gt;open(my $fh, ...)&lt;/code&gt; 및 &lt;code&gt;open(local $fh,...)&lt;/code&gt; 과 같은 구문을 사용하여 다른 참조가없는 경우 범위가 종료 될 때 자동으로 자동으로 닫히는 파일 핸들을 만들 수 있습니다. 그들에게. 이렇게하면 다음 예제에서와 같이 전달해야하는 파일 핸들을 열 때 typeglob이 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d065cb3e4cae07d77952f2b16264cb466cd1342a" translate="yes" xml:space="preserve">
          <source>All functions, unless otherwise noted, return a true value for success and a false value for failure and set &lt;code&gt;$^E&lt;/code&gt; on failure.</source>
          <target state="translated">달리 명시되지 않는 한 모든 함수는 성공에 대해 true 값을 반환하고 실패에 대해 false 값을 반환하고 실패에 대해 &lt;code&gt;$^E&lt;/code&gt; 를 설정 합니다.</target>
        </trans-unit>
        <trans-unit id="8c0ff391fcad9c66a86b68973a78df205636b6ef" translate="yes" xml:space="preserve">
          <source>All information required to &quot;attach&quot; back to the shared resource object &lt;b&gt;must&lt;/b&gt; be contained &lt;b&gt;only&lt;/b&gt; in the &lt;code&gt;STORABLE_freeze&lt;/code&gt; return string. Otherwise, &lt;code&gt;STORABLE_freeze&lt;/code&gt; behaves as normal for &lt;code&gt;STORABLE_attach&lt;/code&gt; classes.</source>
          <target state="translated">공유 자원 오브젝트에 &quot;연결&quot;하는 데 필요한 모든 정보 는 &lt;code&gt;STORABLE_freeze&lt;/code&gt; 리턴 문자열 &lt;b&gt;에만&lt;/b&gt; 포함 &lt;b&gt;되어야&lt;/b&gt; 합니다. 그렇지 않으면 &lt;code&gt;STORABLE_freeze&lt;/code&gt; 는 &lt;code&gt;STORABLE_attach&lt;/code&gt; 클래스에서 정상적으로 동작 합니다.&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="0ca38b7907bcdd63b3829617b4fa2da1157cda75" translate="yes" xml:space="preserve">
          <source>All inputs to WriteMakefile are Unicode characters, not just octets. EUMM seeks to handle all of these correctly. It is currently still not possible to portably use Unicode characters in module names, because this requires Perl to handle Unicode filenames, which is not yet the case on Windows.</source>
          <target state="translated">WriteMakefile에 대한 모든 입력은 8 진수가 아닌 유니 코드 문자입니다. EUMM은이 모든 것을 올바르게 처리하려고합니다. Perl이 유니 코드 파일 이름을 처리해야하므로 아직 모듈 이름으로 유니 코드 문자를 이식 가능하게 사용할 수는 없습니다. 아직 Windows에서는 그렇지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d69ebadb686cb973f8c2cd133297ec1e0e33a51b" translate="yes" xml:space="preserve">
          <source>All invokes of</source>
          <target state="translated">모든 호출</target>
        </trans-unit>
        <trans-unit id="f7db4f7b59a73b241c425f0ac85ea3bc659ec79e" translate="yes" xml:space="preserve">
          <source>All length 0 or length 1 sequences are script runs.</source>
          <target state="translated">모든 길이 0 또는 길이 1 시퀀스는 스크립트 실행입니다.</target>
        </trans-unit>
        <trans-unit id="4ffd0a2ad25e2bbb80e9fa8d007272b04eac86d9" translate="yes" xml:space="preserve">
          <source>All list elements are numeric and come straight out of the C `struct tm'. &lt;code&gt;$sec&lt;/code&gt; , &lt;code&gt;$min&lt;/code&gt; , and &lt;code&gt;$hour&lt;/code&gt; are the seconds, minutes, and hours of the specified time.</source>
          <target state="translated">모든리스트 요소는 숫자이고 C`struct tm '에서 바로 나온다. &lt;code&gt;$sec&lt;/code&gt; , &lt;code&gt;$min&lt;/code&gt; 및 &lt;code&gt;$hour&lt;/code&gt; 는 지정된 시간의 초, 분 및 시간입니다.</target>
        </trans-unit>
        <trans-unit id="ff95eeb5b6dd6e265f0285a8d4265ffdc105283d" translate="yes" xml:space="preserve">
          <source>All list elements are numeric and come straight out of the C `struct tm'. &lt;code&gt;$sec&lt;/code&gt;, &lt;code&gt;$min&lt;/code&gt;, and &lt;code&gt;$hour&lt;/code&gt; are the seconds, minutes, and hours of the specified time.</source>
          <target state="translated">모든 목록 요소는 숫자이며 C`struct tm '에서 바로 나옵니다. &lt;code&gt;$sec&lt;/code&gt; , &lt;code&gt;$min&lt;/code&gt; 및 &lt;code&gt;$hour&lt;/code&gt; 는 지정된 시간의 초, 분 및 시간입니다.</target>
        </trans-unit>
        <trans-unit id="b0cbbd027f9d74998550632f8f717d3b9830f840" translate="yes" xml:space="preserve">
          <source>All memory meant to be used with the Perl API functions should be manipulated using the macros described in this section. The macros provide the necessary transparency between differences in the actual malloc implementation that is used within perl.</source>
          <target state="translated">Perl API 기능과 함께 사용되는 모든 메모리는이 섹션에서 설명하는 매크로를 사용하여 조작해야합니다. 매크로는 perl 내에서 사용되는 실제 malloc 구현의 차이점 사이에 필요한 투명성을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="9a9e166f6a8a9986486a965b0218230a1bd88001" translate="yes" xml:space="preserve">
          <source>All methods provided are accessible in a programmer style and in an interactive shell style.</source>
          <target state="translated">제공된 모든 메소드는 프로그래머 스타일 및 대화식 쉘 스타일로 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1459ac0067a9be1ca453815893a04263c9ab6fda" translate="yes" xml:space="preserve">
          <source>All modules should be tested before distribution (using &quot;make disttest&quot;), and the tests should also be available to people installing the modules (using &quot;make test&quot;). For Module::Build you would use the &lt;code&gt;make test&lt;/code&gt; equivalent &lt;code&gt;perl Build test&lt;/code&gt; .</source>
          <target state="translated">모든 모듈은 배포 전에 테스트해야하며 ( &quot;make disttest&quot;사용) 모듈을 설치하는 사용자 ( &quot;make test&quot;사용)도 테스트를 수행 할 수 있습니다. Module :: Build의 경우 &lt;code&gt;make test&lt;/code&gt; equivalent &lt;code&gt;perl Build test&lt;/code&gt; 를 사용 합니다.</target>
        </trans-unit>
        <trans-unit id="5be4c20a61c35592e0ce3783fe22b0e2f54e4b4b" translate="yes" xml:space="preserve">
          <source>All modules should be tested before distribution (using &quot;make disttest&quot;), and the tests should also be available to people installing the modules (using &quot;make test&quot;). For Module::Build you would use the &lt;code&gt;make test&lt;/code&gt; equivalent &lt;code&gt;perl Build test&lt;/code&gt;.</source>
          <target state="translated">모든 모듈은 배포 전에 테스트해야합니다 ( &quot;make disttest&quot;사용), 테스트는 모듈을 설치하는 사람들도 사용할 수 있어야합니다 ( &quot;make test&quot;사용). Module :: Build의 경우 &lt;code&gt;make test&lt;/code&gt; 에 해당하는 &lt;code&gt;perl Build test&lt;/code&gt; 를 사용 합니다.</target>
        </trans-unit>
        <trans-unit id="45a75ffb3c37d77e5c140116de26483a43d3e7a6" translate="yes" xml:space="preserve">
          <source>All objects belong to a specific class. For example, our</source>
          <target state="translated">모든 객체는 특정 클래스에 속합니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="2c7cf8e7b7dd53d3724b40007e6f359fb761d4a2" translate="yes" xml:space="preserve">
          <source>All objects that are involved in -Dusedl builds should be compiled for this, probably by adding to all ccflags</source>
          <target state="translated">-Dusedl 빌드에 관련된 모든 개체는이를 위해 모든 ccflag에 추가하여 컴파일해야합니다.</target>
        </trans-unit>
        <trans-unit id="155cadaa1628d8233a6288abc54bd74a4bddfdeb" translate="yes" xml:space="preserve">
          <source>All of &lt;code&gt;-I&lt;/code&gt;, &lt;code&gt;PERL5LIB&lt;/code&gt; and &lt;code&gt;use lib&lt;/code&gt; will also prepend arch and version subdirs if they are present</source>
          <target state="translated">모든 &lt;code&gt;-I&lt;/code&gt; , &lt;code&gt;PERL5LIB&lt;/code&gt; 및 &lt;code&gt;use lib&lt;/code&gt; 는 아치 및 버전 하위 디렉토리가있는 경우 앞에 추가합니다.</target>
        </trans-unit>
        <trans-unit id="758a43e77b8dfcfe840782d07ab7ccfb64e67a82" translate="yes" xml:space="preserve">
          <source>All of Perl's internal functions which will be exposed to the outside world are prefixed by &lt;code&gt;Perl_&lt;/code&gt; so that they will not conflict with XS functions or functions used in a program in which Perl is embedded. Similarly, all global variables begin with &lt;code&gt;PL_&lt;/code&gt; . (By convention, static functions start with &lt;code&gt;S_&lt;/code&gt; .)</source>
          <target state="translated">외부 세계에 노출 될 Perl의 모든 내부 함수 앞에는 &lt;code&gt;Perl_&lt;/code&gt; 이 붙어서 XS 함수 또는 Perl이 포함 된 프로그램에서 사용되는 함수와 충돌하지 않습니다. 마찬가지로 모든 전역 변수는 &lt;code&gt;PL_&lt;/code&gt; 로 시작합니다 . (일반적으로 정적 함수는 &lt;code&gt;S_&lt;/code&gt; 로 시작 합니다.)</target>
        </trans-unit>
        <trans-unit id="fdd02658f6f1cef4bb236db4f900317afb2e1336" translate="yes" xml:space="preserve">
          <source>All of Perl's internal functions which will be exposed to the outside world are prefixed by &lt;code&gt;Perl_&lt;/code&gt; so that they will not conflict with XS functions or functions used in a program in which Perl is embedded. Similarly, all global variables begin with &lt;code&gt;PL_&lt;/code&gt;. (By convention, static functions start with &lt;code&gt;S_&lt;/code&gt;.)</source>
          <target state="translated">외부 세계에 노출 될 Perl의 모든 내부 기능은 &lt;code&gt;Perl_&lt;/code&gt; 로 시작하여 Perl이 내장 된 프로그램에서 사용되는 XS 기능 또는 기능과 충돌하지 않습니다. 마찬가지로 모든 전역 변수는 &lt;code&gt;PL_&lt;/code&gt; 로 시작합니다 . (관습 적으로 정적 함수는 &lt;code&gt;S_&lt;/code&gt; 로 시작 합니다.)</target>
        </trans-unit>
        <trans-unit id="f0201779d13335d0611380b1efaab78cf7d99ae8" translate="yes" xml:space="preserve">
          <source>All of Perl's source code is kept centrally in a Git repository at</source>
          <target state="translated">Perl의 모든 소스 코드는 중앙의 Git 저장소에 보관됩니다.</target>
        </trans-unit>
        <trans-unit id="b835c5375c66baf3942c89d1ed7e134430d5d528" translate="yes" xml:space="preserve">
          <source>All of the above special cases can occasionally cause some problems. See &lt;a href=&quot;#BUGS-and-CAVEATS&quot;&gt;&quot;BUGS and CAVEATS&quot;&lt;/a&gt;.</source>
          <target state="translated">위의 모든 특수한 경우는 때때로 몇 가지 문제를 일으킬 수 있습니다. &lt;a href=&quot;#BUGS-and-CAVEATS&quot;&gt;&quot;버그 및주의 사항&quot;을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f5c3cc30932079fdea98918bb1694882d908dc3a" translate="yes" xml:space="preserve">
          <source>All of the above special cases can occasionally cause some problems. See &lt;a href=&quot;#BUGS-and-CAVEATS&quot;&gt;BUGS and CAVEATS&lt;/a&gt;.</source>
          <target state="translated">위의 모든 특수한 경우에 때때로 문제가 발생할 수 있습니다. &lt;a href=&quot;#BUGS-and-CAVEATS&quot;&gt;버그 및주의 사항을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e963123ae4ee166de73fb6fa8c1a51e4336a12f5" translate="yes" xml:space="preserve">
          <source>All of the above.</source>
          <target state="translated">무엇보다도.</target>
        </trans-unit>
        <trans-unit id="0e73d4a25ee89208a71c06aba4a44554f2676c3f" translate="yes" xml:space="preserve">
          <source>All of the core documentation intended for end users lives in</source>
          <target state="translated">최종 사용자를위한 모든 핵심 문서</target>
        </trans-unit>
        <trans-unit id="c9818c2268912a790c38afb3337fdbd1be57190f" translate="yes" xml:space="preserve">
          <source>All of the following &lt;code&gt;SvREFCNT_inc&lt;/code&gt;* are optimized versions of &lt;code&gt;SvREFCNT_inc&lt;/code&gt;, and can be replaced with &lt;code&gt;SvREFCNT_inc&lt;/code&gt;.</source>
          <target state="translated">다음의 모든 &lt;code&gt;SvREFCNT_inc&lt;/code&gt; *이 버전에 최적화되어 &lt;code&gt;SvREFCNT_inc&lt;/code&gt; 을 하고 교체 할 수 있습니다 &lt;code&gt;SvREFCNT_inc&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8bb2fabac85e17c62678907ad7293e4a29bfd44a" translate="yes" xml:space="preserve">
          <source>All of the following SvREFCNT_inc* macros are optimized versions of SvREFCNT_inc, and can be replaced with SvREFCNT_inc.</source>
          <target state="translated">다음 SvREFCNT_inc * 매크로는 모두 SvREFCNT_inc의 최적화 된 버전이며 SvREFCNT_inc로 대체 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="82ef093e61dfa9c43730994ceca5ef32106472a3" translate="yes" xml:space="preserve">
          <source>All of the following have helped. Bug reports, patches, (im)moral support, or just words of encouragement have all been forthcoming.</source>
          <target state="translated">다음은 모두 도움이되었습니다. 버그 보고서, 패치, 도덕적 지원 또는 격려의 말이 다가올 것입니다.</target>
        </trans-unit>
        <trans-unit id="7491564d89215b867c8e0fd7859217a07aea983b" translate="yes" xml:space="preserve">
          <source>All of the following print &quot;ok&quot; or &quot;not ok&quot; depending on if the test succeeded or failed. They all also return true or false, respectively.</source>
          <target state="translated">테스트의 성공 여부에 따라 다음 인쇄가 모두 &quot;ok&quot;또는 &quot;not ok&quot;입니다. 또한 모두 각각 true 또는 false를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="7b5b6c4bb9f864698edd88f10cead8ae59c894bd" translate="yes" xml:space="preserve">
          <source>All of the preceding examples are true whether or not the input value is quoted. The important feature is that the input value contains only a single decimal. See also &lt;a href=&quot;#Alpha-Versions&quot;&gt;&quot;Alpha Versions&quot;&lt;/a&gt;.</source>
          <target state="translated">위의 모든 예는 입력 값이 인용되었는지 여부에 관계없이 참입니다. 중요한 기능은 입력 값에 소수가 하나만 포함되어 있다는 것입니다. &lt;a href=&quot;#Alpha-Versions&quot;&gt;&quot;알파 버전&quot;을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="3b9d747c65bc72fcf845faeccec19d3166662ec7" translate="yes" xml:space="preserve">
          <source>All of the routines are available for export, though none are exported by default. All of the constants used by &lt;code&gt;vmssysopen&lt;/code&gt; to specify access modes are exported by default. The routines are associated with the Exporter tag FUNCTIONS, and the constants are associated with the Exporter tag CONSTANTS, so you can more easily choose what you'd like to import:</source>
          <target state="translated">기본적으로 내보내지는 루틴은 없지만 모든 루틴을 내보낼 수 있습니다. &lt;code&gt;vmssysopen&lt;/code&gt; 에서 액세스 모드를 지정 하는 데 사용하는 모든 상수 는 기본적으로 내보내집니다. 루틴은 Exporter 태그 FUNCTIONS와 연결되고 상수는 Exporter 태그 CONSTANTS와 연결되어 있으므로 가져올 항목을 더 쉽게 선택할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="41e3b701113b5066b37e3af11d04cea9cb6499ec" translate="yes" xml:space="preserve">
          <source>All of these functions will croak on read-only scalars (see the previous section for more on those).</source>
          <target state="translated">이 함수는 모두 읽기 전용 스칼라에서 작동하지 않습니다 (자세한 내용은 이전 섹션 참조).</target>
        </trans-unit>
        <trans-unit id="4ff83273a3484775dac4d0e13bc9dfb2d37a34a0" translate="yes" xml:space="preserve">
          <source>All of these interact with or use &lt;a href=&quot;http://search.cpan.org/perldoc/Plack&quot;&gt;Plack&lt;/a&gt; which is worth understanding the basics of when building a website in Perl (there is a lot of useful &lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2fmetacpan.org%2fsearch%3fq%3dplack%253A%253Amiddleware&quot;&gt;Plack::Middleware&lt;/a&gt;).</source>
          <target state="translated">이 모든 것들이 &lt;a href=&quot;http://search.cpan.org/perldoc/Plack&quot;&gt;Plack&lt;/a&gt; 과 웹 사이트를 만들 때의 기초를 이해하는 Plack 과 상호 작용하거나 사용합니다 (유용한 &lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2fmetacpan.org%2fsearch%3fq%3dplack%253A%253Amiddleware&quot;&gt;Plack :: Middleware&lt;/a&gt; 가 많이 있습니다 ).</target>
        </trans-unit>
        <trans-unit id="3afc762b9492fbc5a363157430531c61246ff071" translate="yes" xml:space="preserve">
          <source>All of these interact with or use &lt;a href=&quot;plack&quot;&gt;Plack&lt;/a&gt; which is worth understanding the basics of when building a website in Perl (there is a lot of useful &lt;a href=&quot;https://metacpan.org/search?q=plack%3A%3Amiddleware&quot;&gt;Plack::Middleware&lt;/a&gt;).</source>
          <target state="translated">이들 모두는 Perl에서 웹 사이트를 구축 할 때의 기본을 이해할 가치가있는 &lt;a href=&quot;plack&quot;&gt;Plack&lt;/a&gt; 과 상호 작용하거나 사용합니다 (유용한 &lt;a href=&quot;https://metacpan.org/search?q=plack%3A%3Amiddleware&quot;&gt;Plack :: Middleware&lt;/a&gt; 가 많이 있습니다 ).</target>
        </trans-unit>
        <trans-unit id="d7bd34b9f55dae4ebdd141f2d4462b30406b5d33" translate="yes" xml:space="preserve">
          <source>All of these recipes assume that you have put &quot;use CPAN&quot; at the top of your program.</source>
          <target state="translated">이러한 모든 레시피는 프로그램 맨 위에 &quot;CPAN 사용&quot;을 넣었다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="669764792c2fd17c1b68c9548896f6adc424fb5e" translate="yes" xml:space="preserve">
          <source>All of this is especially useful when perl is embedded in some other program, where output to STDOUT and STDERR may have to be redirected in some special way. See nvi and the Apache module for examples.</source>
          <target state="translated">이 모든 것은 특히 perl이 다른 프로그램에 임베드 될 때 특히 유용하며, STDOUT 및 STDERR 로의 출력을 특별한 방식으로 경로 재지 정해야 할 수도 있습니다. 예제는 nvi 및 Apache 모듈을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="f9469b3540381c36cb61f1bd013bbc92d5d1e0fa" translate="yes" xml:space="preserve">
          <source>All of this occurs in the routine &lt;code&gt;study_chunk()&lt;/code&gt; which uses a special structure &lt;code&gt;scan_data_t&lt;/code&gt; to store the analysis that it has performed, and does the &quot;peep-hole&quot; optimisations as it goes.</source>
          <target state="translated">이 모든 것은 특별한 구조 &lt;code&gt;scan_data_t&lt;/code&gt; 를 사용하여 수행 한 분석을 저장하고 &quot;peep-hole&quot;최적화를 수행 하는 &lt;code&gt;study_chunk()&lt;/code&gt; 루틴에서 발생합니다 .</target>
        </trans-unit>
        <trans-unit id="52f1e1f474a63fabc7410cc13bd34f20b84caea7" translate="yes" xml:space="preserve">
          <source>All of those strange functions with</source>
          <target state="translated">이상한 기능은 모두</target>
        </trans-unit>
        <trans-unit id="bd329654decca432a697c3105f88903a2261a243" translate="yes" xml:space="preserve">
          <source>All open handles are dup()-ed in pseudo-processes, so that closing any handles in one process does not affect the others. See below for some limitations.</source>
          <target state="translated">모든 열린 핸들은 의사 프로세스에서 dup ()으로 처리되므로 한 프로세스에서 핸들을 닫으면 다른 프로세스에는 영향을 미치지 않습니다. 몇 가지 제한 사항은 아래를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="f714b09d9b62651db015cac63428a3e648501bda" translate="yes" xml:space="preserve">
          <source>All operations above are performed simultaneously, left to right.</source>
          <target state="translated">위의 모든 작업은 왼쪽에서 오른쪽으로 동시에 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="2c5dee63173bc6728f471c2ffbe6ede7b9622657" translate="yes" xml:space="preserve">
          <source>All operators (including basic math operations) are overloaded if you declare your big floating point numbers as</source>
          <target state="translated">큰 부동 소수점 숫자를 다음과 같이 선언하면 모든 연산자 (기본 수학 연산 포함)가 오버로드됩니다</target>
        </trans-unit>
        <trans-unit id="47240c2bd1c42148438e132fbe97c4470bd81a8b" translate="yes" xml:space="preserve">
          <source>All operators (including basic math operations) are overloaded if you declare your big integers as</source>
          <target state="translated">큰 정수를 다음과 같이 선언하면 모든 연산자 (기본 수학 연산 포함)가 오버로드됩니다</target>
        </trans-unit>
        <trans-unit id="8aea450e6db040db0c87b5e94c4f04af81589adb" translate="yes" xml:space="preserve">
          <source>All operators (including basic math operations) are overloaded. Integer and floating-point constants are created as proper BigInts or BigFloats, respectively.</source>
          <target state="translated">모든 수학 연산자 (기본 수학 연산 포함)에 과부하가 걸렸습니다. 정수 및 부동 소수점 상수는 각각 적절한 BigInts 또는 BigFloats로 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="97e8744f2aba4f4c5299d3315f0e922fa7662452" translate="yes" xml:space="preserve">
          <source>All operators (including basic math operations) except the range operator &lt;code&gt;..&lt;/code&gt; are overloaded. Integer constants are created as proper BigInts.</source>
          <target state="translated">범위 연산자 제외 (기본 수학 연산 포함) 모든 사업자는 &lt;code&gt;..&lt;/code&gt; 오버로드. 정수 상수는 적절한 BigInts로 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="d94d5908e53102da28ed793d2b7b1e3aac035e25" translate="yes" xml:space="preserve">
          <source>All options are passed either via the &lt;code&gt;&lt;a href=&quot;../../functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; statement, or via an explicit &lt;code&gt;&lt;a href=&quot;../../functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">모든 옵션은 &lt;code&gt;&lt;a href=&quot;../../functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 문 또는 명시 적 &lt;code&gt;&lt;a href=&quot;../../functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; 를 통해 전달됩니다 .</target>
        </trans-unit>
        <trans-unit id="bb3a0e914f49235b08bf29fac5ca41e98d183a0b" translate="yes" xml:space="preserve">
          <source>All options are passed either via the &lt;code&gt;use&lt;/code&gt; statement, or via an explicit &lt;code&gt;import&lt;/code&gt;.</source>
          <target state="translated">모든 옵션은 &lt;code&gt;use&lt;/code&gt; 문 또는 명시 적 &lt;code&gt;import&lt;/code&gt; 를 통해 전달됩니다 .</target>
        </trans-unit>
        <trans-unit id="6af1c2304a59b49a5e4c4bb3624f5d7d2569e662" translate="yes" xml:space="preserve">
          <source>All other arguments are optional and should correspond to filehandles to read from or the names of input files containing POD sections. A file name of &quot;&quot;, &quot;-&quot; or &quot;&amp;lt;&amp;amp;STDIN&quot; will be interpreted to mean standard input (which is the default if no arguments are given).</source>
          <target state="translated">다른 모든 인수는 선택 사항이며 읽을 파일 핸들 또는 POD 섹션이 포함 된 입력 파일 이름과 일치해야합니다. &quot;&quot;, &quot;-&quot;또는 &quot;&amp;lt;&amp;amp; STDIN&quot;파일 이름은 표준 입력을 의미하는 것으로 해석됩니다 (인수가 지정되지 않은 경우 기본값 임).</target>
        </trans-unit>
        <trans-unit id="7f44679a6de4260413fa97b63aefa6bbb62b1b1f" translate="yes" xml:space="preserve">
          <source>All other code points corresponding to Unicode characters, including private use and those yet to be assigned, are never considered malformed and never warn.</source>
          <target state="translated">개인용 및 아직 할당되지 않은 코드를 포함하여 유니 코드 문자에 해당하는 다른 모든 코드 포인트는 잘못된 것으로 간주되어 경고하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9abb59ed9447dcd04c7f87e709793152669bc13e" translate="yes" xml:space="preserve">
          <source>All other errors may be trapped using the modern interface, otherwise they will be &lt;code&gt;carp&lt;/code&gt; ed about. Program execution will not be halted.</source>
          <target state="translated">다른 모든 오류는 그렇지 않은 경우가있을 것입니다, 현대적인 인터페이스를 사용하여 포획 할 수있다 &lt;code&gt;carp&lt;/code&gt; 에 대한 에디션. 프로그램 실행이 중단되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="faec86b55acacba2c827ed96c30e6b30d931267e" translate="yes" xml:space="preserve">
          <source>All other errors may be trapped using the modern interface, otherwise they will be &lt;code&gt;carp&lt;/code&gt;ed about. Program execution will not be halted.</source>
          <target state="translated">다른 모든 오류는 그렇지 않은 경우가있을 것입니다, 현대적인 인터페이스를 사용하여 포획 할 수있다 &lt;code&gt;carp&lt;/code&gt; 에 대한 에디션. 프로그램 실행은 중단되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="87f6ed6f32251cf3d91bc227de27a29b35179c3f" translate="yes" xml:space="preserve">
          <source>All other implemented styles of rounding attempt to round to the &quot;nearest digit.&quot; If the digit D immediately to the right of the rounding place (skipping the decimal point) is greater than 5, the number is incremented at the rounding place (possibly causing a cascade of incrementation): e.g. when rounding to units, 0.9 rounds to 1, and -19.9 rounds to -20. If D &amp;lt; 5, the number is similarly truncated at the rounding place: e.g. when rounding to units, 0.4 rounds to 0, and -19.4 rounds to -19.</source>
          <target state="translated">다른 모든 구현 된 반올림 스타일은 &quot;가장 가까운 자리&quot;로 반올림합니다. 반올림 자리 오른쪽에있는 숫자 D (소수점 건너 뛰기)가 5보다 큰 경우, 반올림 자리에서 숫자가 증가합니다 (증가 연속 발생 가능). 예를 들어 단위로 반올림하는 경우 0.9는 1로 반올림됩니다 -19.9는 -20으로 반올림됩니다. D &amp;lt;5 인 경우 반올림 위치에서 숫자가 비슷하게 잘립니다 (예 : 단위로 반올림 할 때 0.4는 0으로, -19.4는 -19로 반올림합니다).</target>
        </trans-unit>
        <trans-unit id="7dae17a178b56f669108181e39b9ef2af831e579" translate="yes" xml:space="preserve">
          <source>All other keys are ignored.</source>
          <target state="translated">다른 모든 키는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="8a9098d06193e15bfd29247a605d0c677298968e" translate="yes" xml:space="preserve">
          <source>All other locale-senstive functions automatically use the per-thread locale, if that is turned on, and failing that, the global locale. Thus calls to &lt;code&gt;setlocale&lt;/code&gt; are ineffective on POSIX systems for the current thread if that thread is using a per-thread locale. If perl is compiled for single-thread operation, it does not use the per-thread functions, so &lt;code&gt;setlocale&lt;/code&gt; does work as expected.</source>
          <target state="translated">다른 모든 로케일에 민감한 기능은 자동으로 스레드 별 로케일을 사용합니다.이 기능이 켜져 있으면 전역 로케일이 실패합니다. 따라서 &lt;code&gt;setlocale&lt;/code&gt; 에 대한 호출 은 해당 스레드가 스레드 별 로케일을 사용하는 경우 현재 스레드에 대한 POSIX 시스템에서 효과가 없습니다. perl이 단일 스레드 작업을 위해 컴파일 된 경우 스레드 별 함수를 사용하지 않으므로 &lt;code&gt;setlocale&lt;/code&gt; 이 예상대로 작동합니다.</target>
        </trans-unit>
        <trans-unit id="0673283fae5e4cb931ef195f174d0d6b1d1f68b5" translate="yes" xml:space="preserve">
          <source>All other methods upgrade themselves only when one (or all) of their arguments are of the class mentioned in $upgrade (This might change in later versions to a more sophisticated scheme):</source>
          <target state="translated">다른 모든 메소드는 인수 중 하나 (또는 ​​모두)가 $ upgrade에 언급 된 클래스에 해당하는 경우에만 자체적으로 업그레이드됩니다 (이는 이후 버전에서보다 복잡한 스키마로 변경 될 수 있음).</target>
        </trans-unit>
        <trans-unit id="cb6f2dfb3c6acf62470099509a2f6f369a6ffdf7" translate="yes" xml:space="preserve">
          <source>All other methods upgrade themselves only when one (or all) of their arguments are of the class mentioned in $upgrade.</source>
          <target state="translated">다른 모든 메서드는 인수 중 하나 (또는 ​​모두)가 $ upgrade에 언급 된 클래스 일 때만 자체적으로 업그레이드됩니다.</target>
        </trans-unit>
        <trans-unit id="5e2040cfcc351c3e2d5a5185b8c874a98a40126c" translate="yes" xml:space="preserve">
          <source>All other object methods and overloaded functions can be directly inherited from the parent class.</source>
          <target state="translated">다른 모든 객체 메소드와 오버로드 된 함수는 부모 클래스에서 직접 상속 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b83a0c68243d6a9c451b88def8620109da8b38fe" translate="yes" xml:space="preserve">
          <source>All other parameters that control the content of the gzip header will be ignored if this parameter is set to 1.</source>
          <target state="translated">이 매개 변수를 1로 설정하면 gzip 헤더의 내용을 제어하는 ​​다른 모든 매개 변수가 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="7dd23b69265fff0580e5c7fca763ddf4369a2041" translate="yes" xml:space="preserve">
          <source>All other return values (including the list of the single zero, and the list containing a single empty string) are considered successful. However, real-world code isn't always that easy. Perhaps the code you're working with returns a string containing the word &quot;FAIL&quot; upon failure, or a two element list containing &lt;code&gt;(undef, &quot;human error message&quot;)&lt;/code&gt;. To make autodie work with these sorts of subroutines, we have the</source>
          <target state="translated">다른 모든 반환 값 (단일 0 목록 및 단일 빈 문자열이 포함 된 목록 포함)은 성공한 것으로 간주됩니다. 그러나 실제 코드가 항상 그렇게 쉬운 것은 아닙니다. 작업중인 코드는 실패시 &quot;FAIL&quot;이라는 단어가 포함 된 문자열을 반환하거나 &lt;code&gt;(undef, &quot;human error message&quot;)&lt;/code&gt; 포함하는 두 개의 요소 목록을 반환 할 수 있습니다. 이러한 종류의 서브 루틴으로 autodie가 작동하도록하려면</target>
        </trans-unit>
        <trans-unit id="057550e163f77ce1c2c84330009e1ed5dc21c76b" translate="yes" xml:space="preserve">
          <source>All other strings are invalid in the license field.</source>
          <target state="translated">다른 모든 문자열은 라이센스 필드에서 유효하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="28d480a546a9a634515a6d0068d74dcc0f65e580" translate="yes" xml:space="preserve">
          <source>All other subdirectories of</source>
          <target state="translated">의 다른 모든 하위 디렉토리</target>
        </trans-unit>
        <trans-unit id="3d4278880bd5d7c0f0659132769c668b6b97349d" translate="yes" xml:space="preserve">
          <source>All output is to STDERR.</source>
          <target state="translated">모든 출력은 STDERR입니다.</target>
        </trans-unit>
        <trans-unit id="b9ddaef3946cbe872210302e8ceafb627dfba699" translate="yes" xml:space="preserve">
          <source>All parameters to &lt;code&gt;context&lt;/code&gt; are optional.</source>
          <target state="translated">&lt;code&gt;context&lt;/code&gt; 대한 모든 매개 변수 는 선택 사항입니다.</target>
        </trans-unit>
        <trans-unit id="6c37ee1b0941f972f146000c72b7c3b6715243db" translate="yes" xml:space="preserve">
          <source>All possible messages the program can print out and what they mean. You may wish to follow the same documentation style as the Perl documentation; see perldiag(1) for more details (and look at the POD source as well).</source>
          <target state="translated">프로그램이 인쇄 할 수있는 모든 가능한 메시지와 그 의미. Perl 문서와 동일한 문서 스타일을 따르기를 원할 수 있습니다. 자세한 내용은 perldiag (1)를 참조하십시오 (및 POD 소스도 확인하십시오).</target>
        </trans-unit>
        <trans-unit id="604e2a22c32db1e7a6f30a5a33e18c36a9822954" translate="yes" xml:space="preserve">
          <source>All printable characters, which is the set of all graphical characters plus those whitespace characters which are not also controls.</source>
          <target state="translated">인쇄 가능한 모든 문자 (모든 그래픽 문자 세트와 제어되지 않는 공백 문자)</target>
        </trans-unit>
        <trans-unit id="5f0cb252127c0b51324ce6af0cb1b37825719005" translate="yes" xml:space="preserve">
          <source>All questions related to building for WinCE devices could be asked in</source>
          <target state="translated">WinCE 장치 구축과 관련된 모든 질문은</target>
        </trans-unit>
        <trans-unit id="c9e683a0de1e5a544a3bb7d54d6d9928ee9237a9" translate="yes" xml:space="preserve">
          <source>All references to line numbers by the program (warnings, errors, ...) will treat the &lt;code&gt;#!&lt;/code&gt; line as the first line. Thus a warning on the 2nd line of the program, which is on the 100th line in the file will be reported as line 2, not as line 100. This can be overridden by using the &lt;code&gt;#line&lt;/code&gt; directive. (See &lt;a href=&quot;perlsyn#Plain-Old-Comments-%28Not%21%29&quot;&gt;&quot;Plain Old Comments (Not!)&quot; in perlsyn&lt;/a&gt;)</source>
          <target state="translated">프로그램에서 줄 번호에 대한 모든 참조 (경고, 오류, ...)는 &lt;code&gt;#!&lt;/code&gt; 첫 번째 줄로. 따라서 파일의 100 번째 줄에있는 프로그램의 두 번째 줄에있는 경고는 100 번째 줄이 아닌 2 번째 줄로보고됩니다. 이것은 &lt;code&gt;#line&lt;/code&gt; 지시문 을 사용하여 무시할 수 있습니다 . ( &lt;a href=&quot;perlsyn#Plain-Old-Comments-%28Not%21%29&quot;&gt;perlsyn의 &quot;Plain Old Comments (Not!)&quot;&lt;/a&gt; 참조 )</target>
        </trans-unit>
        <trans-unit id="af228b0481468b2f1d341e2655d2bfbf46fb813b" translate="yes" xml:space="preserve">
          <source>All references to line numbers by the program (warnings, errors, ...) will treat the &lt;code&gt;#!&lt;/code&gt; line as the first line. Thus a warning on the 2nd line of the program, which is on the 100th line in the file will be reported as line 2, not as line 100. This can be overridden by using the &lt;code&gt;#line&lt;/code&gt; directive. (See &lt;a href=&quot;perlsyn#Plain-Old-Comments-(Not!)&quot;&gt;Plain Old Comments (Not!) in perlsyn&lt;/a&gt;)</source>
          <target state="translated">프로그램에서 행 번호에 대한 모든 참조 (경고, 오류 등)는 &lt;code&gt;#!&lt;/code&gt; 첫 줄로. 따라서 파일의 100 번째 줄에있는 프로그램의 두 번째 줄에 대한 경고는 100 번 줄이 아니라 2 번 줄로보고됩니다 . &lt;code&gt;#line&lt;/code&gt; 지시문 을 사용하여 무시할 수 있습니다 . ( &lt;a href=&quot;perlsyn#Plain-Old-Comments-(Not!)&quot;&gt;perlsyn의 Plain Old Comments (Not!)&lt;/a&gt; 참조 )</target>
        </trans-unit>
        <trans-unit id="e60ba7561109a1c032c7ac0364a6dfa0ffa088bc" translate="yes" xml:space="preserve">
          <source>All results share some common attributes:</source>
          <target state="translated">모든 결과는 몇 가지 공통된 속성을 공유합니다.</target>
        </trans-unit>
        <trans-unit id="3639ec0f50b0f9a9a60809dc558a8b5d72fef67b" translate="yes" xml:space="preserve">
          <source>All rights reserved.</source>
          <target state="translated">판권 소유.</target>
        </trans-unit>
        <trans-unit id="1a067ae12ba3c0d999a29e551f40bb7142e1e1b0" translate="yes" xml:space="preserve">
          <source>All rounding functions take as a second parameter a rounding mode from one of the following: 'even', 'odd', '+inf', '-inf', 'zero', 'trunc' or 'common'.</source>
          <target state="translated">모든 반올림 함수는 'even', 'odd', '+ inf', '-inf', 'zero', 'trunc'또는 'common'중 하나에서 반올림 모드를 두 번째 매개 변수로 사용합니다.</target>
        </trans-unit>
        <trans-unit id="2b331c6fdc80ccf345de0513f8a62b9eab6492a7" translate="yes" xml:space="preserve">
          <source>All routines expect to be given real or complex numbers. Don't attempt to use BigFloat, since Perl has currently no rule to disambiguate a '+' operation (for instance) between two overloaded entities.</source>
          <target state="translated">모든 루틴에는 실수 또는 복소수가 부여됩니다. Perl은 현재 두 개의 오버로드 된 엔티티 사이에서 '+'조작을 명확하게하는 규칙이 없으므로 BigFloat를 사용하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="e55cf27d1ee5fe9a7d51e12a991cd2052b26c3ef" translate="yes" xml:space="preserve">
          <source>All single forms are Perl extensions; a few compound forms are as well, and are noted as such.</source>
          <target state="translated">모든 단일 형식은 Perl 확장입니다. 소수의 화합물 형태도 마찬가지로 언급되어있다.</target>
        </trans-unit>
        <trans-unit id="47270bc8154b38c6bf8c6928d77cd1d441578544" translate="yes" xml:space="preserve">
          <source>All stable releases of perl since 5.6.0 are covered.</source>
          <target state="translated">5.6.0 이후 펄의 모든 안정적인 릴리스가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="eab81422eaa753ceb04583bd0ca24dcc4c83f889" translate="yes" xml:space="preserve">
          <source>All subpatterns, either delivered as a list-context result or as &lt;code&gt;$1&lt;/code&gt;</source>
          <target state="translated">목록 컨텍스트 결과 또는 &lt;code&gt;$1&lt;/code&gt; 로 전달되는 모든 하위 패턴</target>
        </trans-unit>
        <trans-unit id="48589ddd875d011fdf990744a29e7ccd3465ffa6" translate="yes" xml:space="preserve">
          <source>All subsequent characters can be letters, numbers (0-9), hyphens (-), underscores (_), colons (:), and periods (.).</source>
          <target state="translated">모든 후속 문자는 문자, 숫자 (0-9), 하이픈 (-), 밑줄 (_), 콜론 (:) 및 마침표 (.) 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="42ba1038004475ab41cd7a5ef01656aad2449ad3" translate="yes" xml:space="preserve">
          <source>All systems use the virtual &lt;code&gt;&quot;\n&quot;&lt;/code&gt; to represent a line terminator, called a &quot;newline&quot;. There is no such thing as an unvarying, physical newline character. It is only an illusion that the operating system, device drivers, C libraries, and Perl all conspire to preserve. Not all systems read &lt;code&gt;&quot;\r&quot;&lt;/code&gt; as ASCII CR and &lt;code&gt;&quot;\n&quot;&lt;/code&gt; as ASCII LF. For example, on the ancient Macs (pre-MacOS X) of yesteryear, these used to be reversed, and on systems without a line terminator, printing &lt;code&gt;&quot;\n&quot;&lt;/code&gt; might emit no actual data. In general, use &lt;code&gt;&quot;\n&quot;&lt;/code&gt; when you mean a &quot;newline&quot; for your system, but use the literal ASCII when you need an exact character. For example, most networking protocols expect and prefer a CR+LF (&lt;code&gt;&quot;\015\012&quot;&lt;/code&gt; or &lt;code&gt;&quot;\cM\cJ&quot;&lt;/code&gt; ) for line terminators, and although they often accept just &lt;code&gt;&quot;\012&quot;&lt;/code&gt; , they seldom tolerate just &lt;code&gt;&quot;\015&quot;&lt;/code&gt; . If you get in the habit of using &lt;code&gt;&quot;\n&quot;&lt;/code&gt; for networking, you may be burned some day.</source>
          <target state="translated">모든 시스템은 가상 &lt;code&gt;&quot;\n&quot;&lt;/code&gt; 을 사용하여 &quot;newline&quot;이라고하는 줄 종결자를 나타냅니다. 변치 않는 물리적 개행 문자와 같은 것은 없습니다. 운영 체제, 장치 드라이버, C 라이브러리 및 Perl이 모두 보존하기 위해 모방하는 것은 환상 일뿐입니다. 모든 시스템이 &lt;code&gt;&quot;\r&quot;&lt;/code&gt; 을 ASCII CR로 읽고 &lt;code&gt;&quot;\n&quot;&lt;/code&gt; 을 ASCII LF로 읽는 것은 아닙니다 . 예를 들어, 과거의 고대 Mac (MacOS 이전 X)에서는 역전이 있었으며 줄 종결자가없는 시스템에서는 &lt;code&gt;&quot;\n&quot;&lt;/code&gt; 인쇄시 실제 데이터가 출력 되지 않을 수 있습니다. 일반적으로 시스템에 &quot;줄 바꾸기&quot;를 의미 할 때는 &lt;code&gt;&quot;\n&quot;&lt;/code&gt; 사용하지만 정확한 문자가 필요할 때는 리터럴 ASCII를 사용하십시오. 예를 들어대부분의 네트워킹 프로토콜은 CR + LF ( &lt;code&gt;&quot;\015\012&quot;&lt;/code&gt; 또는 &lt;code&gt;&quot;\cM\cJ&quot;&lt;/code&gt; 줄 종결 자에 대해서는 &quot;\ cM \ cJ&quot; )이며 종종 &lt;code&gt;&quot;\012&quot;&lt;/code&gt; 만 허용하지만 &lt;code&gt;&quot;\015&quot;&lt;/code&gt; 만 허용하는 경우는 거의 없습니다 . 네트워킹에 &lt;code&gt;&quot;\n&quot;&lt;/code&gt; 을 사용하는 습관이 있다면 언젠가 화상을 입을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="00abc5a8d9f5478ddf4c1b41afc80f5d39c110db" translate="yes" xml:space="preserve">
          <source>All systems use the virtual &lt;code&gt;&quot;\n&quot;&lt;/code&gt; to represent a line terminator, called a &quot;newline&quot;. There is no such thing as an unvarying, physical newline character. It is only an illusion that the operating system, device drivers, C libraries, and Perl all conspire to preserve. Not all systems read &lt;code&gt;&quot;\r&quot;&lt;/code&gt; as ASCII CR and &lt;code&gt;&quot;\n&quot;&lt;/code&gt; as ASCII LF. For example, on the ancient Macs (pre-MacOS X) of yesteryear, these used to be reversed, and on systems without a line terminator, printing &lt;code&gt;&quot;\n&quot;&lt;/code&gt; might emit no actual data. In general, use &lt;code&gt;&quot;\n&quot;&lt;/code&gt; when you mean a &quot;newline&quot; for your system, but use the literal ASCII when you need an exact character. For example, most networking protocols expect and prefer a CR+LF (&lt;code&gt;&quot;\015\012&quot;&lt;/code&gt; or &lt;code&gt;&quot;\cM\cJ&quot;&lt;/code&gt;) for line terminators, and although they often accept just &lt;code&gt;&quot;\012&quot;&lt;/code&gt;, they seldom tolerate just &lt;code&gt;&quot;\015&quot;&lt;/code&gt;. If you get in the habit of using &lt;code&gt;&quot;\n&quot;&lt;/code&gt; for networking, you may be burned some day.</source>
          <target state="translated">모든 시스템은 가상 &lt;code&gt;&quot;\n&quot;&lt;/code&gt; 을 사용하여 &quot;개행&quot;이라고하는 줄 종결자를 나타냅니다. 변하지 않는 물리적 개행 문자와 같은 것은 없습니다. 운영 체제, 장치 드라이버, C 라이브러리 및 Perl이 모두 보존하기 위해 공모하는 것은 환상 일뿐입니다. 모든 시스템이 &lt;code&gt;&quot;\r&quot;&lt;/code&gt; 을 ASCII CR로, &lt;code&gt;&quot;\n&quot;&lt;/code&gt; 을 ASCII LF로 읽는 것은 아닙니다 . 예를 들어, 과거의 고대 Mac (MacOS X 이전)에서는 이러한 방식이 반대로 사용되었으며, 줄 종결자가없는 시스템에서는 &lt;code&gt;&quot;\n&quot;&lt;/code&gt; 인쇄하면 실제 데이터가 출력 되지 않을 수 있습니다. 일반적으로 시스템의 &quot;개행&quot;을 의미 할 때는 &lt;code&gt;&quot;\n&quot;&lt;/code&gt; 사용하지만 정확한 문자가 필요할 때는 리터럴 ASCII를 사용하십시오. 예를 들면대부분의 네트워킹 프로토콜은 CR + LF ( &lt;code&gt;&quot;\015\012&quot;&lt;/code&gt; 또는 &lt;code&gt;&quot;\cM\cJ&quot;&lt;/code&gt; )는 줄 종결자를위한 것이며, 종종 &lt;code&gt;&quot;\012&quot;&lt;/code&gt; 만 허용하지만 &lt;code&gt;&quot;\015&quot;&lt;/code&gt; 만 허용하는 경우는 드뭅니다 . 네트워킹에 &lt;code&gt;&quot;\n&quot;&lt;/code&gt; 을 사용하는 습관이 생기면 언젠가는 화상을 입을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fb8ea7b6eceda9fa2e8d1025a7231d980eabe21a" translate="yes" xml:space="preserve">
          <source>All test functions take a name argument. It's optional, but highly suggested that you use it.</source>
          <target state="translated">모든 테스트 함수는 이름 인수를 사용합니다. 선택 사항이지만 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="08563314f6fd252cfab4add5f5d112e141d01e88" translate="yes" xml:space="preserve">
          <source>All tests are run in scalar context. So this:</source>
          <target state="translated">모든 테스트는 스칼라 컨텍스트에서 실행됩니다. 그래서 이거:</target>
        </trans-unit>
        <trans-unit id="9e1df8eee4a1033ecd0a19707416e97c2ada1eab" translate="yes" xml:space="preserve">
          <source>All tests should succeed (with some of them skipped). If you have the same version of Perl installed, it is crucial that you have &lt;code&gt;.&lt;/code&gt; early in your LIBPATH (or in BEGINLIBPATH), otherwise your tests will most probably test the wrong version of Perl.</source>
          <target state="translated">모든 테스트는 성공해야합니다 (일부는 생략). 동일한 버전의 Perl이 설치되어 있으면 반드시 설치해야 &lt;code&gt;.&lt;/code&gt; 초기에 LIBPATH (또는 BEGINLIBPATH)에서 그렇지 않으면 테스트에서 잘못된 버전의 Perl을 테스트합니다.</target>
        </trans-unit>
        <trans-unit id="525c6957ea6de35e124ab99764227b6cdf29f16d" translate="yes" xml:space="preserve">
          <source>All tests were conducted on the oldest supported AIX technology level with the latest support package applied. If the tested AIX version is out of support (AIX 4.3.3, 5.1, 5.2) then the last available support level was used.</source>
          <target state="translated">모든 테스트는 최신 지원 패키지가 적용된 가장 오래된 지원되는 AIX 기술 수준에서 수행되었습니다. 테스트 된 AIX 버전이 지원되지 않는 경우 (AIX 4.3.3, 5.1, 5.2) 사용 가능한 마지막 지원 레벨이 사용되었습니다.</target>
        </trans-unit>
        <trans-unit id="39ef06ab79291a214e8f7d5dbacda492f3f9bc96" translate="yes" xml:space="preserve">
          <source>All the</source>
          <target state="translated">모든</target>
        </trans-unit>
        <trans-unit id="6adc75ada238ccb6959bf3be512aa6c8d041cf3e" translate="yes" xml:space="preserve">
          <source>All the DLLs built with the current versions of Perl have ID strings identifying the name of the extension, its version, and the version of Perl required for this DLL. Run &lt;code&gt;bldlevel DLL-name&lt;/code&gt; to find this info.</source>
          <target state="translated">현재 버전의 Perl로 작성된 모든 DLL에는 확장명, 버전 및이 DLL에 필요한 Perl 버전을 식별하는 ID 문자열이 있습니다. 이 정보를 찾으 &lt;code&gt;bldlevel DLL-name&lt;/code&gt; 을 실행하십시오 .</target>
        </trans-unit>
        <trans-unit id="4e1fe3c41d4a92f980feaffab352908a5ae600b4" translate="yes" xml:space="preserve">
          <source>All the above</source>
          <target state="translated">모든것 위에</target>
        </trans-unit>
        <trans-unit id="bf0f04a776f7c27f1c272831fed2f282bc5d62df" translate="yes" xml:space="preserve">
          <source>All the above &quot;don't&quot;:s may look daunting, and they are, but the key is to degrade gracefully if one cannot reach the particular network service one wants. Croaking or hanging do not look very professional.</source>
          <target state="translated">위의 모든 &quot;하지 말아야 할 것&quot;는 어려워 보일 수 있지만, 핵심은 원하는 특정 네트워크 서비스에 도달 할 수없는 경우 우아하게 저하시키는 것입니다. 삐걱 거리거나 매달리는 것은 매우 전문적으로 보이지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4b15325c472386a4b2fcce8cfa22d048d90743b2" translate="yes" xml:space="preserve">
          <source>All the above operations</source>
          <target state="translated">위의 모든 작업</target>
        </trans-unit>
        <trans-unit id="18c65db4629a7b0de1b15db2854f6c3f0396dc3a" translate="yes" xml:space="preserve">
          <source>All the advice contained in this document has been gleaned from extensive conversations with experienced CPAN authors and users. Every piece of advice given here is the result of previous mistakes. This information is here to help you avoid the same mistakes and the extra work that would inevitably be required to fix them.</source>
          <target state="translated">이 문서에 포함 된 모든 조언은 숙련 된 CPAN 작성자 및 사용자와의 광범위한 대화에서 수집되었습니다. 여기에 제공된 모든 조언은 이전 실수의 결과입니다. 이 정보는 동일한 실수와 실수를 해결하기 위해 필연적으로 필요한 추가 작업을 피하는 데 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="035cec5a0531d1b6a2296cd59ca2814d6d18a1bb" translate="yes" xml:space="preserve">
          <source>All the binary operators left associate; &lt;code&gt;&quot;&amp;amp;&quot;&lt;/code&gt; is higher precedence than the others, which all have equal precedence. The unary operator right associates, and has highest precedence. Thus this follows the normal Perl precedence rules for logical operators. Use parentheses to override the default precedence and associativity.</source>
          <target state="translated">모든 이진 연산자는 연결되어 있습니다. &lt;code&gt;&quot;&amp;amp;&quot;&lt;/code&gt; 는 다른 것들보다 우선 순위가 높으며 모두 우선 순위가 동일합니다. 단항 연산자 권한이 연관되며 우선 순위가 가장 높습니다. 따라서 이것은 논리 연산자에 대한 일반적인 Perl 우선 순위 규칙을 따릅니다. 괄호를 사용하여 기본 우선 순위 및 연관성을 대체하십시오.</target>
        </trans-unit>
        <trans-unit id="3bed0ace25439f430502aa7b5d45bad3c074e505" translate="yes" xml:space="preserve">
          <source>All the block scope types share a common base, which corresponds to &lt;code&gt;CXt_BLOCK&lt;/code&gt;. This stores the old values of various scope-related variables like &lt;code&gt;PL_curpm&lt;/code&gt;, as well as information about the current scope, such as &lt;code&gt;gimme&lt;/code&gt;. On scope exit, the old variables are restored.</source>
          <target state="translated">모든 블록 범위 유형은 &lt;code&gt;CXt_BLOCK&lt;/code&gt; 에 해당하는 공통 기준을 공유합니다 . 이렇게 다양한 범위 점포 관련 등의 변수의 이전 값 &lt;code&gt;PL_curpm&lt;/code&gt; 등뿐만 아니라, 현재의 범위에 대한 정보 &lt;code&gt;gimme&lt;/code&gt; . 범위 종료시 이전 변수가 복원됩니다.</target>
        </trans-unit>
        <trans-unit id="a6d917ce9244febe094ff576631bcd960c5f5696" translate="yes" xml:space="preserve">
          <source>All the common mathematical functions defined on real numbers that are extended to complex numbers share that same property of working</source>
          <target state="translated">복소수로 확장되는 실수로 정의 된 모든 일반적인 수학 함수는 동일한 작업 속성을 공유합니다.</target>
        </trans-unit>
        <trans-unit id="c39940047cd8d69a382c58b19f467066fdda2d58" translate="yes" xml:space="preserve">
          <source>All the common operations that can be performed on a real number have been defined to work on complex numbers as well, and are merely</source>
          <target state="translated">실수로 수행 할 수있는 모든 공통 연산은 복소수에서도 작동하도록 정의되었으며 단지</target>
        </trans-unit>
        <trans-unit id="db007a143c6d593324e3d9c9ba86712c556ce380" translate="yes" xml:space="preserve">
          <source>All the constants defined in &lt;a href=&quot;dbopen&quot;&gt;dbopen&lt;/a&gt; for use in the flags parameters in the methods defined below are also available. Refer to the Berkeley DB documentation for the precise meaning of the flags values.</source>
          <target state="translated">아래 정의 된 메소드의 flags 매개 변수에서 사용하기 위해 &lt;a href=&quot;dbopen&quot;&gt;dbopen&lt;/a&gt; 에 정의 된 모든 상수도 사용할 수 있습니다. 플래그 값의 정확한 의미는 Berkeley DB 문서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="af40a4a3889be35304f9f526d3725dd711506782" translate="yes" xml:space="preserve">
          <source>All the constants defined in &lt;a href=&quot;http://search.cpan.org/perldoc/dbopen&quot;&gt;dbopen&lt;/a&gt; for use in the flags parameters in the methods defined below are also available. Refer to the Berkeley DB documentation for the precise meaning of the flags values.</source>
          <target state="translated">아래 정의 된 메소드의 플래그 매개 변수에 사용하기 위해 &lt;a href=&quot;http://search.cpan.org/perldoc/dbopen&quot;&gt;dbopen&lt;/a&gt; 에 정의 된 모든 상수도 사용 가능합니다. 플래그 값의 정확한 의미는 Berkeley DB 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="90dde32e9abf15d2dcbf6ab5b218367d1761ce60" translate="yes" xml:space="preserve">
          <source>All the data uses to generate the &lt;code&gt;%Extensions&lt;/code&gt; hash is already present in the &lt;code&gt;Config&lt;/code&gt; module, but not in such a convenient format to quickly reference.</source>
          <target state="translated">&lt;code&gt;%Extensions&lt;/code&gt; 해시 를 생성하는 데 사용되는 모든 데이터 는 이미 &lt;code&gt;Config&lt;/code&gt; 모듈에 있지만 빠른 참조를위한 편리한 형식은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="0d00162e91300896732fceff8f7c85a986709fae" translate="yes" xml:space="preserve">
          <source>All the examples so far have shown objects based on a blessed hash. However, it's possible to bless any type of data structure or referent, including scalars, globs, and subroutines. You may see this sort of thing when looking at code in the wild.</source>
          <target state="translated">지금까지의 모든 예제는 복된 해시를 기반으로 객체를 보여주었습니다. 그러나 스칼라, 글로브 및 서브 루틴을 포함하여 모든 유형의 데이터 구조 또는 참조를 축복 할 수 있습니다. 야생에서 코드를 볼 때 이런 종류의 것을 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f288780205f670aaf71d07523bf6fc9a50b071fd" translate="yes" xml:space="preserve">
          <source>All the exportable functions are listed below -- you're free to import only some, or none at all. By default, none are imported. If you say:</source>
          <target state="translated">내보낼 수있는 모든 기능이 아래에 나열되어 있습니다. 일부만 가져 오거나 전혀 가져올 수 없습니다. 기본적으로 아무 것도 가져 오지 않습니다. 당신이 말하는 경우:</target>
        </trans-unit>
        <trans-unit id="43419a516d44de92566e7a60ec2e03f7ca89325e" translate="yes" xml:space="preserve">
          <source>All the functionality for this class has been moved to &lt;a href=&quot;Test2::EventFacet::Trace&quot;&gt;Test2::EventFacet::Trace&lt;/a&gt;.</source>
          <target state="translated">이 클래스의 모든 기능은 &lt;a href=&quot;Test2::EventFacet::Trace&quot;&gt;Test2 :: EventFacet :: Trace&lt;/a&gt; 로 이동되었습니다 .</target>
        </trans-unit>
        <trans-unit id="8180d8d25bc965560b9cb924a878e4aa18900134" translate="yes" xml:space="preserve">
          <source>All the functions are exported. There is no reason not to do this since the entire purpose is for testing Perl. Namespace pollution will be limited to the test script.</source>
          <target state="translated">모든 기능이 내보내집니다. 전체 목적이 Perl을 테스트하기위한 것이므로이를 수행하지 않을 이유가 없습니다. 네임 스페이스 오염은 테스트 스크립트로 제한됩니다.</target>
        </trans-unit>
        <trans-unit id="9454c3cf6a190b5a295b972d4fa8fdee1a65e24b" translate="yes" xml:space="preserve">
          <source>All the functions defined in &lt;a href=&quot;dbopen&quot;&gt;dbopen&lt;/a&gt; are available except for close() and dbopen() itself. The &lt;b&gt;DB_File&lt;/b&gt; method interface to the supported functions have been implemented to mirror the way Berkeley DB works whenever possible. In particular note that:</source>
          <target state="translated">close () 및 dbopen () 자체를 제외하고 &lt;a href=&quot;dbopen&quot;&gt;dbopen에&lt;/a&gt; 정의 된 모든 함수를 사용할 수 있습니다. 지원되는 함수에 대한 &lt;b&gt;DB_File&lt;/b&gt; 메소드 인터페이스는 가능한 경우 Berkeley DB가 작동하는 방식을 미러링하도록 구현되었습니다. 특히 다음 사항에 유의하십시오.</target>
        </trans-unit>
        <trans-unit id="dc02c5d731db84c233601bd3b09aab07385ecc22" translate="yes" xml:space="preserve">
          <source>All the functions defined in &lt;a href=&quot;http://search.cpan.org/perldoc/dbopen&quot;&gt;dbopen&lt;/a&gt; are available except for close() and dbopen() itself. The &lt;b&gt;DB_File&lt;/b&gt; method interface to the supported functions have been implemented to mirror the way Berkeley DB works whenever possible. In particular note that:</source>
          <target state="translated">close () 및 dbopen () 자체를 제외하고 &lt;a href=&quot;http://search.cpan.org/perldoc/dbopen&quot;&gt;dbopen에&lt;/a&gt; 정의 된 모든 함수를 사용할 수 있습니다. 지원되는 함수에 대한 &lt;b&gt;DB_File&lt;/b&gt; 메소드 인터페이스는 Berkeley DB가 가능할 때마다 작동하는 방식을 반영하도록 구현되었습니다. 특히 다음 사항에 유의하십시오.</target>
        </trans-unit>
        <trans-unit id="85af2ce50ee2f541004fc9d53df5f4d00e80abb3" translate="yes" xml:space="preserve">
          <source>All the functions may be imported using the &lt;code&gt;:ALL&lt;/code&gt; tag.</source>
          <target state="translated">&lt;code&gt;:ALL&lt;/code&gt; 태그를 사용하여 모든 기능을 가져올 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e17de002dfef54a49f116af6d04ace151f1db1a1" translate="yes" xml:space="preserve">
          <source>All the functions return an integer. This is a count of the number of items returned by the Perl subroutine. The actual items returned by the subroutine are stored on the Perl stack.</source>
          <target state="translated">모든 함수는 정수를 반환합니다. Perl 서브 루틴이 리턴 한 항목 수입니다. 서브 루틴이 리턴 한 실제 항목은 Perl 스택에 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="52532a7385f2fd6662a92f143b996eb16f224ae0" translate="yes" xml:space="preserve">
          <source>All the gzip headers defined in RFC 1952 can be created using this module.</source>
          <target state="translated">RFC 1952에 정의 된 모든 gzip 헤더는이 모듈을 사용하여 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="51037cd1e5bef0efdf785304da29a37a7b0cdc06" translate="yes" xml:space="preserve">
          <source>All the modules and switches just described can be used in v5.20 with just plain &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; , and, should the input locales not be UTF-8, you'll get the less than ideal behavior, described below, that you get with pre-v5.16 Perls, or when you use the locale pragma without the &lt;code&gt;:not_characters&lt;/code&gt; parameter in v5.16 and v5.18. If you are using exclusively UTF-8 locales in v5.20 and higher, the rest of this section does not apply to you.</source>
          <target state="translated">방금 설명한 모든 모듈과 스위치는 v5.20에서 평범한 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; 로 사용할 수 있으며 입력 로케일이 UTF-8이 아닌 경우 아래에서 설명한 이상적이지 않은 동작을 얻을 수 있습니다. -v5.16 Perls 또는 v5.16 및 v5.18에서 &lt;code&gt;:not_characters&lt;/code&gt; 매개 변수 없이 로케일 pragma를 사용하는 경우 v5.20 이상에서 UTF-8 로케일을 독점적으로 사용하는 경우이 섹션의 나머지 부분은 적용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="23a7427a0c93da04ca9f121cb6df7f21a70360e5" translate="yes" xml:space="preserve">
          <source>All the modules and switches just described can be used in v5.20 with just plain &lt;code&gt;use locale&lt;/code&gt;, and, should the input locales not be UTF-8, you'll get the less than ideal behavior, described below, that you get with pre-v5.16 Perls, or when you use the locale pragma without the &lt;code&gt;:not_characters&lt;/code&gt; parameter in v5.16 and v5.18. If you are using exclusively UTF-8 locales in v5.20 and higher, the rest of this section does not apply to you.</source>
          <target state="translated">방금 설명한 모든 모듈과 스위치는 일반 &lt;code&gt;use locale&lt;/code&gt; 로 v5.20에서 사용할 수 있으며 , 입력 로케일이 UTF-8이 아닌 경우 아래에 설명 된 것과 같이 pre -v5.16 Perls 또는 v5.16 및 v5.18에서 &lt;code&gt;:not_characters&lt;/code&gt; 매개 변수 없이 로케일 pragma를 사용하는 경우 . v5.20 이상에서 UTF-8 로케일을 독점적으로 사용하는 경우이 섹션의 나머지 부분은 적용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6bcfac1e4c22e90a7b2f875c6b72f2c0d403c1be" translate="yes" xml:space="preserve">
          <source>All the operators which need an argument in the integer format treat the argument as in modular arithmetic, e.g., &lt;code&gt;mod 2**32&lt;/code&gt; on a 32-bit architecture. &lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf&lt;/a&gt; &quot;%u&quot;, -1&lt;/code&gt; therefore provides the same result as &lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf&lt;/a&gt; &quot;%u&quot;, ~0&lt;/code&gt; .</source>
          <target state="translated">정수 형식의 인수가 필요한 모든 연산자는 인수를 모듈 식 산술과 같이 취급합니다 (예 : 32 비트 아키텍처의 경우 &lt;code&gt;mod 2**32&lt;/code&gt; . &lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf&lt;/a&gt; &quot;%u&quot;, -1&lt;/code&gt; 따라서 &lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf&lt;/a&gt; &quot;%u&quot;, ~0&lt;/code&gt; 과 동일한 결과를 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="a94aac67d589e0f8e1d0781724ece6b565784e0e" translate="yes" xml:space="preserve">
          <source>All the operators which need an argument in the integer format treat the argument as in modular arithmetic, e.g., &lt;code&gt;mod 2**32&lt;/code&gt; on a 32-bit architecture. &lt;code&gt;sprintf &quot;%u&quot;, -1&lt;/code&gt; therefore provides the same result as &lt;code&gt;sprintf &quot;%u&quot;, ~0&lt;/code&gt;.</source>
          <target state="translated">정수 형식의 인수가 필요한 모든 연산자는 인수를 모듈 식 산술처럼 처리합니다 (예 : 32 비트 아키텍처의 &lt;code&gt;mod 2**32&lt;/code&gt; . &lt;code&gt;sprintf &quot;%u&quot;, -1&lt;/code&gt; 은 &lt;code&gt;sprintf &quot;%u&quot;, ~0&lt;/code&gt; 과 동일한 결과를 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="dd418ef6a96f4eda4f1d57d08d07998ad0cc52e2" translate="yes" xml:space="preserve">
          <source>All the other escapes accepted by normal bracketed character classes are accepted here as well.</source>
          <target state="translated">일반 대괄호 문자 클래스에서 허용되는 다른 모든 이스케이프도 여기에서 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="a4fb9683d7bd9f1429d51b7805c318a33084783c" translate="yes" xml:space="preserve">
          <source>All the other macros which will be used in this example require you to have used this macro.</source>
          <target state="translated">이 예제에서 사용될 다른 모든 매크로는이 매크로를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="dc1e1a6dd9bac655e5e0e61898ff5ebe0c2ee966" translate="yes" xml:space="preserve">
          <source>All the other methods are from &lt;a href=&quot;File::Spec::Unix&quot;&gt;File::Spec::Unix&lt;/a&gt;.</source>
          <target state="translated">다른 모든 메서드는 &lt;a href=&quot;File::Spec::Unix&quot;&gt;File :: Spec :: Unix&lt;/a&gt; 에서 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="b08b2f77f4eeb817def95bb1cac60c09fd5e4ffe" translate="yes" xml:space="preserve">
          <source>All the others are scalar types, that is, things that can be bound to a &lt;code&gt;$&lt;/code&gt; variable. For these, the internal types are mostly orthogonal to types in the Perl language.</source>
          <target state="translated">다른 모든 것은 스칼라 유형, 즉 &lt;code&gt;$&lt;/code&gt; 변수에 바인딩 할 수있는 것입니다 . 이를 위해 내부 유형은 대부분 Perl 언어의 유형과 직교합니다.</target>
        </trans-unit>
        <trans-unit id="813e0349f99be3e1ec9a99a0d6e9329cddd2f012" translate="yes" xml:space="preserve">
          <source>All the properties that begin with &lt;code&gt;\p&lt;/code&gt; (and its inverse &lt;code&gt;\P&lt;/code&gt; ) are actually character classes that are Unicode-aware. There are dozens of them, see &lt;a href=&quot;perluniprops&quot;&gt;perluniprops&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;\p&lt;/code&gt; 시작하는 모든 속성 (및 그 역 &lt;code&gt;\P&lt;/code&gt; )은 실제로 유니 코드를 인식하는 문자 클래스입니다. 수십 가지가 있습니다 ( &lt;a href=&quot;perluniprops&quot;&gt;perluniprops&lt;/a&gt; 참조) .</target>
        </trans-unit>
        <trans-unit id="5506ac6e7a7d731b7f67a3eafd003d6df2cdc5ce" translate="yes" xml:space="preserve">
          <source>All the properties that begin with &lt;code&gt;\p&lt;/code&gt; (and its inverse &lt;code&gt;\P&lt;/code&gt;) are actually character classes that are Unicode-aware. There are dozens of them, see &lt;a href=&quot;perluniprops&quot;&gt;perluniprops&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;\p&lt;/code&gt; (및 그 역 &lt;code&gt;\P&lt;/code&gt; )로 시작하는 모든 속성 은 실제로 유니 코드를 인식하는 문자 클래스입니다. 수십 가지가 있습니다 . &lt;a href=&quot;perluniprops&quot;&gt;perluniprops를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0b65a75a2da1466ad79df3a0e8287f617c933054" translate="yes" xml:space="preserve">
          <source>All the sequences and escapes</source>
          <target state="translated">모든 순서와 탈출</target>
        </trans-unit>
        <trans-unit id="6f5a47adb9e53e6ad59a65ed39b02f84d8f84ac1" translate="yes" xml:space="preserve">
          <source>All the supported functions should be called as methods, i.e., either as</source>
          <target state="translated">지원되는 모든 함수는 메소드로 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="7e345efa9c5194482201d78c3449d77663639ae8" translate="yes" xml:space="preserve">
          <source>All the talk in the world is useless without an implementation. In almost every case, the person or people who argue for a new feature will be expected to be the ones who implement it. Porters capable of coding new features have their own agendas, and are not available to implement your (possibly good) idea.</source>
          <target state="translated">세상의 모든 대화는 구현 없이는 쓸모가 없습니다. 거의 모든 경우에, 새로운 특징을 주장하는 사람 또는 사람들은 그것을 구현하는 사람 일 것으로 예상됩니다. 새로운 기능을 코딩 할 수있는 포터는 자신의 의제를 가지고 있으며 (아마도 좋은) 아이디어를 구현할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="93180c67bca739c994123a24439e25749e44ef95" translate="yes" xml:space="preserve">
          <source>All the tests will run but those that failed most recently will be run first. If no tests have failed since I started saving state all tests will run in their normal order. This combines full test coverage with early notification of failures.</source>
          <target state="translated">모든 테스트가 실행되지만 가장 최근에 실패한 테스트가 먼저 실행됩니다. 상태 저장을 시작한 이후 실패한 테스트가 없으면 모든 테스트가 정상적인 순서로 실행됩니다. 이는 전체 테스트 범위와 실패의 조기 알림을 결합합니다.</target>
        </trans-unit>
        <trans-unit id="8a484c468483007c96c3a2efbbc829000cb69672" translate="yes" xml:space="preserve">
          <source>All the usual warnings about file locking apply here. In particular, note that file locking in Perl is &lt;b&gt;advisory&lt;/b&gt;, which means that holding a lock will not prevent anyone else from reading, writing, or erasing the file; it only prevents them from getting another lock at the same time. Locks are analogous to green traffic lights: If you have a green light, that does not prevent the idiot coming the other way from plowing into you sideways; it merely guarantees to you that the idiot does not also have a green light at the same time.</source>
          <target state="translated">파일 잠금에 대한 모든 일반적인 경고가 여기에 적용됩니다. 특히, Perl의 파일 잠금은 &lt;b&gt;권고&lt;/b&gt; 사항입니다. 잠금 을 유지한다고해서 다른 사람이 파일을 읽거나 쓰거나 지우는 것을 막을 수는 없습니다. 단지 동시에 다른 잠금을 얻지 못하게합니다. 자물쇠는 초록색 신호등과 유사합니다. 초록색 표시등이 있어도 반대 방향으로 오는 바보가 옆으로 쟁기질하는 것을 막을 수는 없습니다. 단지 바보가 동시에 녹색 빛을 가지고 있지 않다는 것을 보증합니다.</target>
        </trans-unit>
        <trans-unit id="7e349ac65c026bbc32c4eb141cc9c0c2c6c1c9d7" translate="yes" xml:space="preserve">
          <source>All the work of numeric conversion is done in %subr and num(). Of course, %subr is not complete, it contains only operators used in the example below. Here is the extra-credit question: why do we need an explicit recursion in num()? (Answer is at the end of this section.)</source>
          <target state="translated">숫자 변환의 모든 작업은 % subr 및 num ()에서 수행됩니다. 물론 % subr은 완전하지 않으며 아래 예제에 사용 된 연산자 만 포함합니다. 여기에 여분의 질문이 있습니다 : 왜 우리는 num ()에서 명시적인 재귀가 필요합니까? (이 섹션의 끝에 답변이 있습니다.)</target>
        </trans-unit>
        <trans-unit id="0f15e65c6cfe10e49621033c9085af7927a8ea20" translate="yes" xml:space="preserve">
          <source>All these commands are callable via method interface and have names which conform to standard conventions with the leading &lt;code&gt;rl_&lt;/code&gt; stripped.</source>
          <target state="translated">이러한 모든 명령은 메소드 인터페이스를 통해 호출 할 수 있으며 선행 &lt;code&gt;rl_&lt;/code&gt; 을 제거한 표준 규칙을 따르는 이름을 갖습니다 .</target>
        </trans-unit>
        <trans-unit id="aef6bfec15b0c3e7aaddd8cd3a9fa0eb60d81533" translate="yes" xml:space="preserve">
          <source>All these flags require &lt;b&gt;-DDEBUGGING&lt;/b&gt; when you compile the Perl executable (but see &lt;code&gt;:opd&lt;/code&gt; in &lt;a href=&quot;Devel::Peek&quot;&gt;Devel::Peek&lt;/a&gt; or &lt;a href=&quot;re#%27debug%27-mode&quot;&gt;&quot;'debug' mode&quot; in re&lt;/a&gt; which may change this). See the</source>
          <target state="translated">이러한 모든 플래그는 필요 &lt;b&gt;-DDEBUGGING&lt;/b&gt; 는 펄 실행 파일을 컴파일 (하지만 볼 때 &lt;code&gt;:opd&lt;/code&gt; 에서 &lt;a href=&quot;Devel::Peek&quot;&gt;(STABLE) : 픽&lt;/a&gt; 또는 &lt;a href=&quot;re#%27debug%27-mode&quot;&gt;&quot; '디버그'모드를&quot;재에서&lt;/a&gt; 변경할 수 있음). 참조</target>
        </trans-unit>
        <trans-unit id="1a68fff09705709c0c5d238842991f6619aad537" translate="yes" xml:space="preserve">
          <source>All these flags require &lt;b&gt;-DDEBUGGING&lt;/b&gt; when you compile the Perl executable (but see &lt;code&gt;:opd&lt;/code&gt; in &lt;a href=&quot;devel/peek&quot;&gt;Devel::Peek&lt;/a&gt; or &lt;a href=&quot;re#'debug'-mode&quot;&gt;'debug' mode in re&lt;/a&gt; which may change this). See the</source>
          <target state="translated">이러한 모든 플래그는 필요 &lt;b&gt;-DDEBUGGING&lt;/b&gt; 는 펄 실행 파일을 컴파일 (하지만 볼 때 &lt;code&gt;:opd&lt;/code&gt; 에서 &lt;a href=&quot;devel/peek&quot;&gt;(STABLE) : 픽&lt;/a&gt; 또는 &lt;a href=&quot;re#'debug'-mode&quot;&gt;재에서 '디버그'모드&lt;/a&gt; 이 변경 될 수 있습니다). 참조</target>
        </trans-unit>
        <trans-unit id="4fa65daee4b35c0bdf01aba1673c1bba399f82d9" translate="yes" xml:space="preserve">
          <source>All these lines will have the same effect on the state of the $md5 object:</source>
          <target state="translated">이 모든 행은 $ md5 객체의 상태에 동일한 영향을 미칩니다.</target>
        </trans-unit>
        <trans-unit id="9bcd9b22dce2b631b5e9d54d48830f4469977758" translate="yes" xml:space="preserve">
          <source>All these variables have no effect on a newer Perl which supports the relevant feature.</source>
          <target state="translated">이러한 모든 변수는 관련 기능을 지원하는 최신 Perl에는 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="75179ef80cbabbf7cf9ad45aff86010dedc268e1" translate="yes" xml:space="preserve">
          <source>All this obviously requires a way for the Perl internal functions to be either subroutines taking some kind of structure as the first argument, or subroutines taking nothing as the first argument. To enable these two very different ways of building the interpreter, the Perl source (as it does in so many other situations) makes heavy use of macros and subroutine naming conventions.</source>
          <target state="translated">이 모든 것은 분명히 Perl 내부 함수가 어떤 종류의 구조를 첫 번째 인수로 사용하는 서브 루틴이거나 첫 번째 인수로 아무것도 수행하지 않는 서브 루틴이 될 수있는 방법이 필요합니다. 이 두 가지 매우 다른 방식으로 인터프리터를 빌드하기 위해 Perl 소스는 다른 많은 상황에서와 같이 매크로 및 서브 루틴 이름 지정 규칙을 많이 사용합니다.</target>
        </trans-unit>
        <trans-unit id="05bb57d634b2fcc45dc9babcad96740ee2e8f313" translate="yes" xml:space="preserve">
          <source>All this should be handled automatically by the hints file, if requested.</source>
          <target state="translated">요청 된 경우이 모든 것은 힌트 파일에 의해 자동으로 처리되어야합니다.</target>
        </trans-unit>
        <trans-unit id="7381ecad8164c50156cc34405ade99393869ea97" translate="yes" xml:space="preserve">
          <source>All those functions (red(), blue(), green(), etc.) appear to be separate, but the real code in the closure actually was compiled only once.</source>
          <target state="translated">모든 함수 (red (), blue (), green () 등)는 별개의 것으로 보이지만 클로저의 실제 코드는 실제로 한 번만 컴파일되었습니다.</target>
        </trans-unit>
        <trans-unit id="1eb3cfb093a32021b17dfa327362fe2a1ecb7499" translate="yes" xml:space="preserve">
          <source>All threads blocking on &lt;code&gt;dequeue()&lt;/code&gt; calls will be unblocked with any remaining items in the queue and/or &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; being returned. Any subsequent calls to &lt;code&gt;dequeue()&lt;/code&gt; will behave like &lt;code&gt;dequeue_nb()&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;dequeue()&lt;/code&gt; 호출 에 대한 모든 스레드 차단은 대기열에 남아있는 항목 및 / 또는 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 가 반환 되어 차단 해제됩니다 . 이후의 &lt;code&gt;dequeue()&lt;/code&gt; 호출 은 &lt;code&gt;dequeue_nb()&lt;/code&gt; 처럼 작동합니다 .</target>
        </trans-unit>
        <trans-unit id="5e0480f424427ee699ec4c6e37478b9b28b96374" translate="yes" xml:space="preserve">
          <source>All threads blocking on &lt;code&gt;dequeue()&lt;/code&gt; calls will be unblocked with any remaining items in the queue and/or &lt;code&gt;undef&lt;/code&gt; being returned. Any subsequent calls to &lt;code&gt;dequeue()&lt;/code&gt; will behave like &lt;code&gt;dequeue_nb()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;dequeue()&lt;/code&gt; 호출을 차단하는 모든 스레드 는 대기열에 남아있는 항목 및 / 또는 &lt;code&gt;undef&lt;/code&gt; 가 반환되면서 차단 해제됩니다 . 이후의 &lt;code&gt;dequeue()&lt;/code&gt; 호출 은 &lt;code&gt;dequeue_nb()&lt;/code&gt; 처럼 동작합니다 .</target>
        </trans-unit>
        <trans-unit id="31b59027aac85c24edba2402c4b5479124b0b5b8" translate="yes" xml:space="preserve">
          <source>All three APIs &lt;code&gt;fill_mstats($buf)&lt;/code&gt; , &lt;code&gt;mstats_fillhash(%hash)&lt;/code&gt; , and &lt;code&gt;mstats2hash($buf, %hash)&lt;/code&gt; are designed to allocate no memory if used</source>
          <target state="translated">세 가지 API &lt;code&gt;fill_mstats($buf)&lt;/code&gt; , &lt;code&gt;mstats_fillhash(%hash)&lt;/code&gt; 및 &lt;code&gt;mstats2hash($buf, %hash)&lt;/code&gt; 는 모두 사용되는 경우 메모리를 할당하지 않도록 설계되었습니다</target>
        </trans-unit>
        <trans-unit id="41286ac523d18ad20149b16f2b604b3802d50a45" translate="yes" xml:space="preserve">
          <source>All three APIs &lt;code&gt;fill_mstats($buf)&lt;/code&gt;, &lt;code&gt;mstats_fillhash(%hash)&lt;/code&gt;, and &lt;code&gt;mstats2hash($buf, %hash)&lt;/code&gt; are designed to allocate no memory if used</source>
          <target state="translated">세 API 모두 &lt;code&gt;fill_mstats($buf)&lt;/code&gt; , &lt;code&gt;mstats_fillhash(%hash)&lt;/code&gt; 및 &lt;code&gt;mstats2hash($buf, %hash)&lt;/code&gt; 사용시 메모리를 할당하지 않도록 설계되었습니다.</target>
        </trans-unit>
        <trans-unit id="93f405b3f1113c619eaa3ff8cf11a04161308e3b" translate="yes" xml:space="preserve">
          <source>All three types, namely &lt;code&gt;configure_requires&lt;/code&gt; , &lt;code&gt;build_requires&lt;/code&gt; , and &lt;code&gt;requires&lt;/code&gt; are supported in the way specified in the META.yml specification. The current implementation</source>
          <target state="translated">모든 세 가지 유형, 즉 &lt;code&gt;configure_requires&lt;/code&gt; , &lt;code&gt;build_requires&lt;/code&gt; 및 &lt;code&gt;requires&lt;/code&gt; META.yml 규격에 규정 된 방법으로 지원됩니다. 현재 구현</target>
        </trans-unit>
        <trans-unit id="e69868d20db4582400a5d6cd9bcd656e5299ed1b" translate="yes" xml:space="preserve">
          <source>All variants of Unix, Mac OS (old and new), and Stream_LF files on VMS use a single character to end each line in the external representation of text (even though that single character is CARRIAGE RETURN on old, pre-Darwin flavors of Mac OS, and is LINE FEED on Unix and most VMS files). In other systems like OS/2, DOS, and the various flavors of MS-Windows, your program sees a &lt;code&gt;\n&lt;/code&gt; as a simple &lt;code&gt;\cJ&lt;/code&gt; , but what's stored in text files are the two characters &lt;code&gt;\cM\cJ&lt;/code&gt; . That means that if you don't use binmode() on these systems, &lt;code&gt;\cM\cJ&lt;/code&gt; sequences on disk will be converted to &lt;code&gt;\n&lt;/code&gt; on input, and any &lt;code&gt;\n&lt;/code&gt; in your program will be converted back to &lt;code&gt;\cM\cJ&lt;/code&gt; on output. This is what you want for text files, but it can be disastrous for binary files.</source>
          <target state="translated">VMS의 모든 Unix, Mac OS (이전 및 신규) 및 Stream_LF 파일의 모든 변형은 단일 문자를 사용하여 텍스트의 외부 표현에서 각 줄을 종료합니다. OS이며 Unix 및 대부분의 VMS 파일에서 LINE FEED입니다). OS / 2, DOS 및 다양한 종류의 MS-Windows와 같은 다른 시스템에서 프로그램은 &lt;code&gt;\n&lt;/code&gt; 을 간단한 &lt;code&gt;\cJ&lt;/code&gt; 로 인식하지만 텍스트 파일에 저장되는 것은 &lt;code&gt;\cM\cJ&lt;/code&gt; 두 문자 입니다. 즉, 이러한 시스템에서 binmode ()를 사용하지 않으면 디스크의 &lt;code&gt;\cM\cJ&lt;/code&gt; 시퀀스가 입력시 &lt;code&gt;\n&lt;/code&gt; 으로 변환되고 프로그램의 &lt;code&gt;\n&lt;/code&gt; 은 &lt;code&gt;\cM\cJ&lt;/code&gt; 로 다시 변환됩니다.출력시. 이것은 텍스트 파일에서 원하는 것이지만 바이너리 파일의 경우 비참 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2225a59f0929103c1700eff0727135f74b745f47" translate="yes" xml:space="preserve">
          <source>All variants of Unix, Mac OS (old and new), and Stream_LF files on VMS use a single character to end each line in the external representation of text (even though that single character is CARRIAGE RETURN on old, pre-Darwin flavors of Mac OS, and is LINE FEED on Unix and most VMS files). In other systems like OS/2, DOS, and the various flavors of MS-Windows, your program sees a &lt;code&gt;\n&lt;/code&gt; as a simple &lt;code&gt;\cJ&lt;/code&gt;, but what's stored in text files are the two characters &lt;code&gt;\cM\cJ&lt;/code&gt;. That means that if you don't use &lt;a href=&quot;#binmode-FILEHANDLE%2C-LAYER&quot;&gt;&lt;code&gt;binmode&lt;/code&gt;&lt;/a&gt; on these systems, &lt;code&gt;\cM\cJ&lt;/code&gt; sequences on disk will be converted to &lt;code&gt;\n&lt;/code&gt; on input, and any &lt;code&gt;\n&lt;/code&gt; in your program will be converted back to &lt;code&gt;\cM\cJ&lt;/code&gt; on output. This is what you want for text files, but it can be disastrous for binary files.</source>
          <target state="translated">Unix, Mac OS (이전 및 신규) 및 VMS의 Stream_LF 파일의 모든 변형은 단일 문자를 사용하여 텍스트의 외부 표현에서 각 줄을 끝냅니다 (단일 문자가 이전의 다윈 이전 Mac 버전에서는 CARRIAGE RETURN 임에도 불구하고 OS이며 Unix 및 대부분의 VMS 파일에서 LINE FEED입니다). OS / 2, DOS 및 다양한 MS-Windows와 같은 다른 시스템에서 프로그램은 &lt;code&gt;\n&lt;/code&gt; 을 단순한 &lt;code&gt;\cJ&lt;/code&gt; 로 인식하지만 텍스트 파일에 저장되는 것은 두 문자 &lt;code&gt;\cM\cJ&lt;/code&gt; 입니다. 즉 , 이러한 시스템에서 &lt;a href=&quot;#binmode-FILEHANDLE%2C-LAYER&quot;&gt; &lt;code&gt;binmode&lt;/code&gt; &lt;/a&gt; 를 사용하지 않으면 디스크의 &lt;code&gt;\cM\cJ&lt;/code&gt; 시퀀스가 입력시 &lt;code&gt;\n&lt;/code&gt; 으로 변환되고 프로그램의 모든 &lt;code&gt;\n&lt;/code&gt; 이 다시 &lt;code&gt;\cM\cJ&lt;/code&gt; 로 변환됩니다.출력에. 이것은 텍스트 파일에 대해 원하는 것이지만 바이너리 파일에는 재앙이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ad579c08df3b605d9bcdf2dd854aada4ff50f1d7" translate="yes" xml:space="preserve">
          <source>All warnings are enabled in a block by either of these:</source>
          <target state="translated">모든 경고는 다음 중 하나에 의해 블록에서 활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="ac638dedbe9b121696313ec4c1b744224313d7b2" translate="yes" xml:space="preserve">
          <source>All warnings from these class elements are fatal, as well as some practices that don't currently warn. For example you cannot say</source>
          <target state="translated">이러한 클래스 요소의 모든 경고는 치명적이며 현재 경고하지 않는 일부 관행입니다. 예를 들어 말할 수 없습니다</target>
        </trans-unit>
        <trans-unit id="370cb67fce7c69dd6b28a7668dbdd050522c81c2" translate="yes" xml:space="preserve">
          <source>All we send is -nologo to nmake to prevent it from printing its damned banner.</source>
          <target state="translated">우리가 보내는 것은 nmake에 -nologo입니다. 배너가 인쇄되지 않도록합니다.</target>
        </trans-unit>
        <trans-unit id="89ae61e8070c7c0925079d83f7934e0eb3357598" translate="yes" xml:space="preserve">
          <source>All writes should be appends.</source>
          <target state="translated">모든 글은 추가해야합니다.</target>
        </trans-unit>
        <trans-unit id="d673c2e10445ecd4d4244da3c2339308139938ca" translate="yes" xml:space="preserve">
          <source>All you need to be able to use this is a C compiler than generates BSD/GCC-style stabs. The &lt;b&gt;-g&lt;/b&gt; option on native BSD compilers and GCC should get this for you.</source>
          <target state="translated">이것을 사용하려면 BSD / GCC 스타일의 스테 이브를 생성하는 것보다 C 컴파일러 만 있으면됩니다. 네이티브 BSD 컴파일러와 GCC 의 &lt;b&gt;-g&lt;/b&gt; 옵션이이를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="3703c85b2e19a742cbffc3e68e850016eb81f530" translate="yes" xml:space="preserve">
          <source>All you need to do is post a short summary of the module, its purpose and interfaces. A few lines on each of the main methods is probably enough. (If you post the whole module it might be ignored by busy people - generally the very people you want to read it!)</source>
          <target state="translated">모듈, 목적 및 인터페이스에 대한 간단한 요약을 게시하기 만하면됩니다. 각 주요 방법에 대한 몇 줄이 충분할 것입니다. (전체 모듈을 게시하면 바쁜 사람들이 무시할 수 있습니다-일반적으로 읽고 싶은 사람들이 있습니다!)</target>
        </trans-unit>
        <trans-unit id="42dd47aab008353520f505d14f8982da5b7ec66c" translate="yes" xml:space="preserve">
          <source>All you need to do is turn on caching outside of the lexicon hash itself like so:</source>
          <target state="translated">렉시콘 해시 자체 외부에서 캐싱을 켜면됩니다.</target>
        </trans-unit>
        <trans-unit id="97cf0e2918a9254a0eafa0498166116f753c3eef" translate="yes" xml:space="preserve">
          <source>All-in-one interface</source>
          <target state="translated">올인원 인터페이스</target>
        </trans-unit>
        <trans-unit id="7f586dbbf90de4b682fc6ca0175b6fbbe492b948" translate="yes" xml:space="preserve">
          <source>Allison Randal &lt;code&gt;allison@perl.org&lt;/code&gt;</source>
          <target state="translated">앨리슨 랜달 &lt;code&gt;allison@perl.org&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6fee78bc0546aa696412ff85a7bc963fbc9ca7d4" translate="yes" xml:space="preserve">
          <source>Allocate (if not already done so) the read buffer for this layer and return pointer to it. Return NULL on failure.</source>
          <target state="translated">이 계층에 대한 읽기 버퍼를 할당하고 (아직 그렇게하지 않은 경우) 포인터를 리턴하십시오. 실패하면 NULL을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="3b2ee334827d425691fcbfb9ca0bc34e49168fb9" translate="yes" xml:space="preserve">
          <source>Allocates a new Perl interpreter. See &lt;a href=&quot;perlembed&quot;&gt;perlembed&lt;/a&gt;.</source>
          <target state="translated">새로운 Perl 인터프리터를 할당합니다. &lt;a href=&quot;perlembed&quot;&gt;perlembed를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="df4156e41da421b335c923f2c42bc1eecd5696b9" translate="yes" xml:space="preserve">
          <source>Allocates a place in the currently-compiling pad (via &lt;a href=&quot;#pad_alloc&quot;&gt;&quot;pad_alloc&quot;&lt;/a&gt;) for an anonymous function that is lexically scoped inside the currently-compiling function. The function &lt;code&gt;func&lt;/code&gt; is linked into the pad, and its &lt;code&gt;CvOUTSIDE&lt;/code&gt; link to the outer scope is weakened to avoid a reference loop.</source>
          <target state="translated">현재 컴파일중인 함수 내에서 어휘 범위가 지정된 익명 함수 에 대해 현재 컴파일중인 패드 ( &lt;a href=&quot;#pad_alloc&quot;&gt;&quot;pad_alloc&quot;&lt;/a&gt; 를 통해 )에 위치를 할당 합니다. 함수 &lt;code&gt;func&lt;/code&gt; 는 패드에 연결되어 있고 참조 루프를 피하기 위해 외부 범위에 대한 &lt;code&gt;CvOUTSIDE&lt;/code&gt; 링크가 약화됩니다.</target>
        </trans-unit>
        <trans-unit id="204757b0500eb920f73e23856bcfacd06d0f5f77" translate="yes" xml:space="preserve">
          <source>Allocates a place in the currently-compiling pad (via &lt;a href=&quot;#pad_alloc&quot;&gt;pad_alloc&lt;/a&gt;) for an anonymous function that is lexically scoped inside the currently-compiling function. The function</source>
          <target state="translated">현재 컴파일중인 함수 내에서 어휘 범위가 지정된 익명 함수 에 대해 현재 컴파일중인 패드 ( &lt;a href=&quot;#pad_alloc&quot;&gt;pad_alloc&lt;/a&gt; 를 통해 ) 의 위치를 ​​할당 합니다. 함수</target>
        </trans-unit>
        <trans-unit id="a1b524487958fec05073f1d9fd025a1a4c0c42d8" translate="yes" xml:space="preserve">
          <source>Allocates a place in the currently-compiling pad (via &lt;a href=&quot;perlapi#pad_alloc&quot;&gt;&quot;pad_alloc&quot; in perlapi&lt;/a&gt;) and then stores a name for that entry. &lt;code&gt;name&lt;/code&gt; is adopted and becomes the name entry; it must already contain the name string. &lt;code&gt;typestash&lt;/code&gt; and &lt;code&gt;ourstash&lt;/code&gt; and the &lt;code&gt;padadd_STATE&lt;/code&gt; flag get added to &lt;code&gt;name&lt;/code&gt;. None of the other processing of &lt;a href=&quot;perlapi#pad_add_name_pvn&quot;&gt;&quot;pad_add_name_pvn&quot; in perlapi&lt;/a&gt; is done. Returns the offset of the allocated pad slot.</source>
          <target state="translated">현재 컴파일중인 패드 ( &lt;a href=&quot;perlapi#pad_alloc&quot;&gt;perlapi의 &quot;pad_alloc&quot;를&lt;/a&gt; 통해)에 위치를 할당 한 다음 해당 항목의 이름을 저장합니다. &lt;code&gt;name&lt;/code&gt; 이 채택되고 이름 항목이됩니다. 이름 문자열이 이미 포함되어 있어야합니다. &lt;code&gt;typestash&lt;/code&gt; 및 &lt;code&gt;ourstash&lt;/code&gt; 및 &lt;code&gt;padadd_STATE&lt;/code&gt; 플래그가 &lt;code&gt;name&lt;/code&gt; 에 추가됩니다 . &lt;a href=&quot;perlapi#pad_add_name_pvn&quot;&gt;perlapi에서 &quot;pad_add_name_pvn&quot;&lt;/a&gt; 의 다른 처리 는 수행되지 않습니다. 할당 된 패드 슬롯의 오프셋을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="cbc8fd0f139e1ed3d083e8bda55cb3c680701f85" translate="yes" xml:space="preserve">
          <source>Allocates a place in the currently-compiling pad (via &lt;a href=&quot;perlapi#pad_alloc&quot;&gt;pad_alloc in perlapi&lt;/a&gt;) and then stores a name for that entry.</source>
          <target state="translated">현재 컴파일중인 패드에 장소를 할당하고 ( &lt;a href=&quot;perlapi#pad_alloc&quot;&gt;perlapi의 pad_alloc을&lt;/a&gt; 통해 ) 해당 항목의 이름을 저장합니다.</target>
        </trans-unit>
        <trans-unit id="5c5b44a37c6737cadc335e0a4b7b826b48bad95f" translate="yes" xml:space="preserve">
          <source>Allocates a place in the currently-compiling pad for a named lexical variable. Stores the name and other metadata in the name part of the pad, and makes preparations to manage the variable's lexical scoping. Returns the offset of the allocated pad slot.</source>
          <target state="translated">명명 된 어휘 변수에 대해 현재 컴파일중인 패드의 위치를 ​​할당합니다. 패드의 이름 부분에 이름 및 기타 메타 데이터를 저장하고 변수의 어휘 범위를 관리 할 준비를합니다. 할당 된 패드 슬롯의 오프셋을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="b7b59f013b83c5b7e66a9f56292d13c76f0cfbe1" translate="yes" xml:space="preserve">
          <source>Allocates a place in the currently-compiling pad, returning the offset of the allocated pad slot. No name is initially attached to the pad slot.</source>
          <target state="translated">현재 컴파일중인 패드에 위치를 할당하여 할당 된 패드 슬롯의 오프셋을 반환합니다. 처음에는 패드 슬롯에 이름이 붙어 있지 않습니다.</target>
        </trans-unit>
        <trans-unit id="84242aa2ca41f95ab1ff81fab259e5cc74e97a0b" translate="yes" xml:space="preserve">
          <source>Allocates a place in the currently-compiling pad, returning the offset of the allocated pad slot. No name is initially attached to the pad slot. &lt;code&gt;tmptype&lt;/code&gt; is a set of flags indicating the kind of pad entry required, which will be set in the value SV for the allocated pad entry:</source>
          <target state="translated">현재 컴파일중인 패드에 위치를 할당하고 할당 된 패드 슬롯의 오프셋을 반환합니다. 처음에는 패드 슬롯에 이름이 붙어 있지 않습니다. &lt;code&gt;tmptype&lt;/code&gt; 은 필요한 패드 항목의 종류를 나타내는 플래그 집합이며 할당 된 패드 항목의 값 SV에 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="1b5c021aee14bea734803bc4262d3ac794a7f664" translate="yes" xml:space="preserve">
          <source>Allocation</source>
          <target state="translated">Allocation</target>
        </trans-unit>
        <trans-unit id="88c27f89af81badc5ef765d8b9d7ceca7c8b95fa" translate="yes" xml:space="preserve">
          <source>Allocation too large: %x</source>
          <target state="translated">할당이 너무 큼 : % x</target>
        </trans-unit>
        <trans-unit id="2e2f6a9fe9c75300156ed8faa2846a84de58e28c" translate="yes" xml:space="preserve">
          <source>Allow &lt;code&gt;+&lt;/code&gt; to start options. Default is enabled unless environment variable POSIXLY_CORRECT has been set, in which case &lt;code&gt;getopt_compat&lt;/code&gt; is disabled.</source>
          <target state="translated">허용 &lt;code&gt;+&lt;/code&gt; 옵션을 시작합니다. 환경 변수 POSIXLY_CORRECT가 설정되지 않은 경우 기본값이 사용되며,이 경우 &lt;code&gt;getopt_compat&lt;/code&gt; 가 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0469f1df12a2c7b2c199e00126b0c41472541bb8" translate="yes" xml:space="preserve">
          <source>Allow archives to be passed in as string</source>
          <target state="translated">아카이브가 문자열로 전달되도록 허용</target>
        </trans-unit>
        <trans-unit id="a59030efa024b93a6e819c9cb26054addbab292b" translate="yes" xml:space="preserve">
          <source>Allow option names to be abbreviated to uniqueness. Default is enabled unless environment variable POSIXLY_CORRECT has been set, in which case &lt;code&gt;auto_abbrev&lt;/code&gt; is disabled.</source>
          <target state="translated">옵션 이름을 고유성으로 축약 할 수 있습니다. 환경 변수 POSIXLY_CORRECT를 설정하지 않으면 기본값이 사용되며,이 경우 &lt;code&gt;auto_abbrev&lt;/code&gt; 가 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d0f866ca3f963d4349430b9a74345aafdac1f116" translate="yes" xml:space="preserve">
          <source>Allow third party tools to safely attach meta-data</source>
          <target state="translated">타사 도구가 메타 데이터를 안전하게 첨부하도록 허용</target>
        </trans-unit>
        <trans-unit id="daa78d2843413d350c8af8e2659c80ab1cc32bed" translate="yes" xml:space="preserve">
          <source>Allowing &quot;.&quot; as a version delimiter is simply incompatible with determining whether a pathname is in VMS format or in Unix format with extended file syntax. There is no way to know whether &quot;perl-5.8.6&quot; is a Unix &quot;perl-5.8.6&quot; or a VMS &quot;perl-5.8;6&quot; when passing it to unixify() or vmsify().</source>
          <target state="translated">&quot;.&quot;허용 버전 구분 기호는 경로 이름이 VMS 형식인지 아니면 확장 파일 구문을 사용하는 Unix 형식인지를 결정하는 데 단순히 호환되지 않습니다. unixify () 또는 vmsify ()에 전달할 때 &quot;perl-5.8.6&quot;이 Unix &quot;perl-5.8.6&quot;인지 또는 VMS &quot;perl-5.8; 6&quot;인지 알 수있는 방법이 없습니다.</target>
        </trans-unit>
        <trans-unit id="c408189be3311ef544fc6916d88f93932d6bdffc" translate="yes" xml:space="preserve">
          <source>Allowing this could have security implications, as a malicious tar archive could alter or replace any file the extracting user has permissions to. Therefor, the default is to not allow insecure extractions.</source>
          <target state="translated">악의적 인 tar 아카이브가 추출하는 사용자에게 권한이있는 파일을 변경하거나 대체 할 수 있으므로이를 허용하면 보안에 영향을 줄 수 있습니다. 따라서 기본값은 안전하지 않은 추출을 허용하지 않는 것입니다.</target>
        </trans-unit>
        <trans-unit id="ddbc44ff2a879d62f5a15a25c82d1c43a6e19ca9" translate="yes" xml:space="preserve">
          <source>Allows &lt;code&gt;$parser&lt;/code&gt; to accept a list of &lt;a href=&quot;../perlpod#Formatting-Codes&quot;&gt;Formatting Codes in perlpod&lt;/a&gt;. This can be used to implement user-defined codes.</source>
          <target state="translated">&lt;code&gt;$parser&lt;/code&gt; 가 &lt;a href=&quot;../perlpod#Formatting-Codes&quot;&gt;perlpod&lt;/a&gt; 의 형식화 코드 목록을 승인 할 수 있습니다. 사용자 정의 코드를 구현하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="74d0313a91b25e6669e15800af03ecffb23d0e60" translate="yes" xml:space="preserve">
          <source>Allows &lt;code&gt;$parser&lt;/code&gt; to accept a list of &lt;a href=&quot;perlpod#Formatting-Codes&quot;&gt;&quot;Formatting Codes&quot; in perlpod&lt;/a&gt;. This can be used to implement user-defined codes.</source>
          <target state="translated">&lt;code&gt;$parser&lt;/code&gt; 가 &lt;a href=&quot;perlpod#Formatting-Codes&quot;&gt;perlpod에서 &quot;형식화 코드&quot;&lt;/a&gt; 목록을 허용하도록 허용합니다 . 이것은 사용자 정의 코드를 구현하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="101aab8a8afb357465320bb5f121a4ac661795be" translate="yes" xml:space="preserve">
          <source>Allows &lt;code&gt;$parser&lt;/code&gt; to accept a list of directives for &lt;a href=&quot;../perlpod#Verbatim-Paragraph&quot;&gt;Verbatim Paragraph in perlpod&lt;/a&gt;. A directive is the label of a &lt;a href=&quot;../perlpod#Command-Paragraph&quot;&gt;Command Paragraph in perlpod&lt;/a&gt;. This can be used to implement user-defined directives.</source>
          <target state="translated">&lt;code&gt;$parser&lt;/code&gt; 가 &lt;a href=&quot;../perlpod#Verbatim-Paragraph&quot;&gt;perlpod의 Verbatim 단락에&lt;/a&gt; 대한 지시문 목록을 승인 할 수 있습니다. 지시문은 &lt;a href=&quot;../perlpod#Command-Paragraph&quot;&gt;perlpod&lt;/a&gt; 의 명령 단락 레이블입니다 . 이것은 사용자 정의 지시문을 구현하는 데 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c183b94856ce8e866ce5e58e72276cd992ab0cc9" translate="yes" xml:space="preserve">
          <source>Allows &lt;code&gt;$parser&lt;/code&gt; to accept a list of directives for &lt;a href=&quot;perlpod#Verbatim-Paragraph&quot;&gt;&quot;Verbatim Paragraph&quot; in perlpod&lt;/a&gt;. A directive is the label of a &lt;a href=&quot;perlpod#Command-Paragraph&quot;&gt;&quot;Command Paragraph&quot; in perlpod&lt;/a&gt;. This can be used to implement user-defined directives.</source>
          <target state="translated">수 &lt;code&gt;$parser&lt;/code&gt; 에 대한 지침의 목록을 받아 &lt;a href=&quot;perlpod#Verbatim-Paragraph&quot;&gt;perlpod에서 &quot;축 어적으로 단락을&quot;&lt;/a&gt; . 지시문은 &lt;a href=&quot;perlpod#Command-Paragraph&quot;&gt;perlpod&lt;/a&gt; 의 &quot;명령 단락&quot; 레이블입니다 . 이것은 사용자 정의 지시문을 구현하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f2a410a266e9f220f21c4f8d80b7768daa7e08ef" translate="yes" xml:space="preserve">
          <source>Allows &lt;code&gt;$parser&lt;/code&gt; to accept a list of directives for data paragraphs. A directive is the label of a &lt;a href=&quot;../perlpod#Command-Paragraph&quot;&gt;Command Paragraph in perlpod&lt;/a&gt;. A data paragraph is one delimited by &lt;code&gt;=begin/=for/=end&lt;/code&gt; directives. This can be used to implement user-defined directives.</source>
          <target state="translated">&lt;code&gt;$parser&lt;/code&gt; 가 데이터 단락에 대한 지시문 목록을 승인 할 수 있습니다. 지시문은 &lt;a href=&quot;../perlpod#Command-Paragraph&quot;&gt;perlpod&lt;/a&gt; 의 명령 단락 레이블입니다 . 데이터 단락은 &lt;code&gt;=begin/=for/=end&lt;/code&gt; 지시문으로 구분됩니다 . 이것은 사용자 정의 지시문을 구현하는 데 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="689b3259aa6ee42171e8ca85552dc69d81a2e636" translate="yes" xml:space="preserve">
          <source>Allows &lt;code&gt;$parser&lt;/code&gt; to accept a list of directives for data paragraphs. A directive is the label of a &lt;a href=&quot;perlpod#Command-Paragraph&quot;&gt;&quot;Command Paragraph&quot; in perlpod&lt;/a&gt;. A data paragraph is one delimited by &lt;code&gt;=begin/=for/=end&lt;/code&gt; directives. This can be used to implement user-defined directives.</source>
          <target state="translated">수 &lt;code&gt;$parser&lt;/code&gt; 데이터 단락에 대한 지침의 목록을 수용 할 수 있습니다. 지시문은 &lt;a href=&quot;perlpod#Command-Paragraph&quot;&gt;perlpod&lt;/a&gt; 의 &quot;명령 단락&quot; 레이블입니다 . 데이터 단락은 &lt;code&gt;=begin/=for/=end&lt;/code&gt; 지시문으로 구분 된 하나 입니다. 이것은 사용자 정의 지시문을 구현하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0abf6fb24aebd1865d65a4df47fe30a801298ce2" translate="yes" xml:space="preserve">
          <source>Allows &lt;code&gt;$parser&lt;/code&gt; to accept a list of directives for processed paragraphs. A directive is the label of a &lt;a href=&quot;../perlpod#Command-Paragraph&quot;&gt;Command Paragraph in perlpod&lt;/a&gt;. A processed paragraph is also known as &lt;a href=&quot;../perlpod#Ordinary-Paragraph&quot;&gt;Ordinary Paragraph in perlpod&lt;/a&gt;. This can be used to implement user-defined directives.</source>
          <target state="translated">&lt;code&gt;$parser&lt;/code&gt; 가 처리 된 단락에 대한 지시문 목록을 승인 할 수 있습니다. 지시문은 &lt;a href=&quot;../perlpod#Command-Paragraph&quot;&gt;perlpod&lt;/a&gt; 의 명령 단락 레이블입니다 . 처리 된 단락은 &lt;a href=&quot;../perlpod#Ordinary-Paragraph&quot;&gt;perlpod의 일반 단락이라고도&lt;/a&gt; 합니다. 이것은 사용자 정의 지시문을 구현하는 데 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8f5ef2e6771c903e2304c0c6130bf86ed3190914" translate="yes" xml:space="preserve">
          <source>Allows &lt;code&gt;$parser&lt;/code&gt; to accept a list of directives for processed paragraphs. A directive is the label of a &lt;a href=&quot;perlpod#Command-Paragraph&quot;&gt;&quot;Command Paragraph&quot; in perlpod&lt;/a&gt;. A processed paragraph is also known as &lt;a href=&quot;perlpod#Ordinary-Paragraph&quot;&gt;&quot;Ordinary Paragraph&quot; in perlpod&lt;/a&gt;. This can be used to implement user-defined directives.</source>
          <target state="translated">&lt;code&gt;$parser&lt;/code&gt; 가 처리 된 단락에 대한 지시문 목록을 허용 할 수 있습니다. 지시문은 &lt;a href=&quot;perlpod#Command-Paragraph&quot;&gt;perlpod&lt;/a&gt; 의 &quot;명령 단락&quot; 레이블입니다 . 처리 된 단락은 &lt;a href=&quot;perlpod#Ordinary-Paragraph&quot;&gt;perlpod에서 &quot;일반 단락&quot;이라고도&lt;/a&gt; 합니다. 이것은 사용자 정의 지시문을 구현하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a3735b17f2c2eb4921645bcf6a4d22392282447c" translate="yes" xml:space="preserve">
          <source>Allows a pre-existing extension directory to be overwritten.</source>
          <target state="translated">기존 확장 디렉토리를 덮어 쓸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4b9153c7965fe5ac4319d07a3a1e17ae8bc10ce3" translate="yes" xml:space="preserve">
          <source>Allows an extension to be created for a header even if that header is not found in standard include directories.</source>
          <target state="translated">표준 포함 디렉토리에 해당 헤더가없는 경우에도 헤더에 대한 확장을 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bcec857e4ee66e587abdab964de9867354784a70" translate="yes" xml:space="preserve">
          <source>Allows files [but not directories] to be moved between file systems by copying the &lt;code&gt;$sOldName&lt;/code&gt; file data and some attributes to &lt;code&gt;$sNewName&lt;/code&gt; and then deleting &lt;code&gt;$sOldName&lt;/code&gt;. If this bit is not set [or if &lt;code&gt;$sOldName&lt;/code&gt; denotes a directory] and &lt;code&gt;$sNewName&lt;/code&gt; refers to a different file system than &lt;code&gt;$sOldName&lt;/code&gt;, then &lt;code&gt;MoveFileEx&lt;/code&gt; will fail.</source>
          <target state="translated">&lt;code&gt;$sOldName&lt;/code&gt; 파일 데이터와 일부 속성을 &lt;code&gt;$sNewName&lt;/code&gt; 에 복사 한 다음 &lt;code&gt;$sOldName&lt;/code&gt; 을 삭제 하여 파일 시스템간에 파일을 이동할 수 있습니다 . 이 비트가 설정되어 있지 않은 경우 [경우 또는 &lt;code&gt;$sOldName&lt;/code&gt; 디렉토리를 의미]와 &lt;code&gt;$sNewName&lt;/code&gt; 아닌 다른 파일 시스템을 의미 &lt;code&gt;$sOldName&lt;/code&gt; , 다음 &lt;code&gt;MoveFileEx&lt;/code&gt; 는 실패합니다.</target>
        </trans-unit>
        <trans-unit id="daf02b11ffbf9506236d387546a93a50fc62cc0a" translate="yes" xml:space="preserve">
          <source>Allows files and directories to be moved to the Trashcan/Recycle Bin (where they may later be restored if necessary) if the operating system supports such functionality. This feature may one day be made available directly in &lt;code&gt;File::Path&lt;/code&gt; .</source>
          <target state="translated">운영 체제가 해당 기능을 지원하는 경우 파일 및 디렉토리를 휴지통 / 휴지통으로 이동시킬 수 있습니다 (필요한 경우 나중에 복원 할 수 있음). 이 기능은 언젠가 &lt;code&gt;File::Path&lt;/code&gt; 에서 직접 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4cb22b8db2618111bfbd2c865fb5ccd86bacea3b" translate="yes" xml:space="preserve">
          <source>Allows files and directories to be moved to the Trashcan/Recycle Bin (where they may later be restored if necessary) if the operating system supports such functionality. This feature may one day be made available directly in &lt;code&gt;File::Path&lt;/code&gt;.</source>
          <target state="translated">운영 체제가 이러한 기능을 지원하는 경우 파일 및 디렉토리를 휴지통 / 휴지통 (필요한 경우 나중에 복원 할 수 있음)으로 이동할 수 있습니다. 이 기능은 언젠가 &lt;code&gt;File::Path&lt;/code&gt; 에서 직접 사용할 수있게 될 것입니다 .</target>
        </trans-unit>
        <trans-unit id="36d9306aba93d39c5e49dee7ed3073ab03b67160" translate="yes" xml:space="preserve">
          <source>Allows mainstream access.</source>
          <target state="translated">주류 액세스를 허용합니다.</target>
        </trans-unit>
        <trans-unit id="559ebf2a9218f8c70716cdc11eee2f4b586a5213" translate="yes" xml:space="preserve">
          <source>Allows multiple concatenated compressed streams to be treated as a single compressed stream. Decompression will stop once either the end of the file/buffer is reached, an error is encountered (premature eof, corrupt compressed data) or the end of a stream is not immediately followed by the start of another stream.</source>
          <target state="translated">여러 개의 연결된 압축 스트림을 단일 압축 스트림으로 처리 할 수 ​​있습니다. 파일 / 버퍼의 끝에 도달하거나 오류가 발생하거나 (압축 된 데이터가 손상됨) 스트림의 끝에 즉시 다른 스트림이 시작되지 않으면 압축 해제가 중지됩니다.</target>
        </trans-unit>
        <trans-unit id="7e5261df1ca0e4f1432538fbf7dfbe931383691e" translate="yes" xml:space="preserve">
          <source>Allows newName to be used as an alias for ENCODING. ENCODING may be either the name of an encoding or an encoding object (as described in &lt;a href=&quot;../encode&quot;&gt;Encode&lt;/a&gt;).</source>
          <target state="translated">newName을 ENCODING의 별명으로 사용할 수 있습니다. ENCODING은 인코딩 이름 또는 인코딩 객체 일 수 있습니다 ( &lt;a href=&quot;../encode&quot;&gt;Encode에&lt;/a&gt; 설명 된대로 ).</target>
        </trans-unit>
        <trans-unit id="4bde81d715f5b99bcfab0870892bd353123e4037" translate="yes" xml:space="preserve">
          <source>Allows newName to be used as an alias for ENCODING. ENCODING may be either the name of an encoding or an encoding object (as described in &lt;a href=&quot;encode&quot;&gt;Encode&lt;/a&gt;).</source>
          <target state="translated">newName을 ENCODING의 별칭으로 사용할 수 있습니다. ENCODING은 인코딩의 이름이거나 인코딩 객체 ( &lt;a href=&quot;encode&quot;&gt;Encode에&lt;/a&gt; 설명 된대로 ) 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="25ad1ed959ffd436db5eb39db9c139500cedca08" translate="yes" xml:space="preserve">
          <source>Allows one or more writers.</source>
          <target state="translated">한 명 이상의 작성자를 허용합니다.</target>
        </trans-unit>
        <trans-unit id="fb055bc3bc4cb26c4e9f20094313100a4445739c" translate="yes" xml:space="preserve">
          <source>Allows put/write services using sequential record access mode to occur at any point in the file, truncating the file at that point.</source>
          <target state="translated">순차 레코드 액세스 모드를 사용하는 넣기 / 쓰기 서비스가 파일의 모든 지점에서 발생하도록 허용하고 해당 지점에서 파일을 자릅니다.</target>
        </trans-unit>
        <trans-unit id="76b238c6a405ca46725f72efca71d3c55969afb7" translate="yes" xml:space="preserve">
          <source>Allows source endpoint verification to be enabled or disabled. This is useful for those remote destinations with multiples interfaces where the response may not originate from the same endpoint that the original destination endpoint was sent to. This only affects udp and icmp protocol pings.</source>
          <target state="translated">소스 엔드 포인트 확인을 활성화하거나 비활성화 할 수 있습니다. 이는 원래 대상 엔드 포인트가 전송 된 동일한 엔드 포인트에서 응답이 시작되지 않을 수있는 다중 인터페이스가있는 원격 대상에 유용합니다. 이것은 udp 및 icmp 프로토콜 핑에만 영향을줍니다.</target>
        </trans-unit>
        <trans-unit id="99ef43d5cf353c0a40b7ebb05028a37d2a089bf4" translate="yes" xml:space="preserve">
          <source>Allows the device's media to be locked or unlocked. &lt;code&gt;$opOutBuf&lt;/code&gt; should be &lt;code&gt;[]&lt;/code&gt;. &lt;code&gt;$pInBuf&lt;/code&gt; should be a &lt;code&gt;PREVENT_MEDIA_REMOVAL&lt;/code&gt; data structure, which is simply an integer containing a boolean value:</source>
          <target state="translated">장치의 미디어를 잠 그거나 잠금 해제 할 수 있습니다. &lt;code&gt;$opOutBuf&lt;/code&gt; 는 &lt;code&gt;[]&lt;/code&gt; 이어야합니다 . &lt;code&gt;$pInBuf&lt;/code&gt; 되어야 &lt;code&gt;PREVENT_MEDIA_REMOVAL&lt;/code&gt; 의 단순 부울 값을 포함하는 정수이고, 데이터 구조 :</target>
        </trans-unit>
        <trans-unit id="216f93af2f31cbc4d87ad71fb2a6974460271a8c" translate="yes" xml:space="preserve">
          <source>Allows users to delete.</source>
          <target state="translated">사용자가 삭제할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a891c57f96709d16d1ec61f6f410ed213b624dc8" translate="yes" xml:space="preserve">
          <source>Allows users to read.</source>
          <target state="translated">사용자가 읽을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b0edc3cbaffc6df1795dfc34edcb443538e117ac" translate="yes" xml:space="preserve">
          <source>Allows users to update.</source>
          <target state="translated">사용자가 업데이트 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="885369750bdc4ecd0e0864b13fd3e9c0c578c8db" translate="yes" xml:space="preserve">
          <source>Allows users to write.</source>
          <target state="translated">사용자가 쓸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b46332805263e8790df0747eb20b444ed87a43b7" translate="yes" xml:space="preserve">
          <source>Allows you to both load one or more modules, while setting up inheritance from those modules at the same time. Mostly similar in effect to</source>
          <target state="translated">하나 이상의 모듈을로드하고 동시에 해당 모듈에서 상속을 설정할 수 있습니다. 대체로 비슷한 효과</target>
        </trans-unit>
        <trans-unit id="c9da0fc905ccf60ade5ca9f7c49a801a55f4a1c8" translate="yes" xml:space="preserve">
          <source>Allows you to both load one or more modules, while setting up inheritance from those modules at the same time. Roughly similar in effect to</source>
          <target state="translated">하나 이상의 모듈을로드하고 동시에 해당 모듈에서 상속을 설정할 수 있습니다. 대략 비슷한 효과</target>
        </trans-unit>
        <trans-unit id="22f08aec036591ac3a4e81d90d5af18a1bd7db2a" translate="yes" xml:space="preserve">
          <source>Allows you to choose the character encoding will be store in the DBM file.</source>
          <target state="translated">문자 인코딩이 DBM 파일에 저장되도록 선택할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dab85f86a937e724bd3f8c905ebc9700e2dbc47d" translate="yes" xml:space="preserve">
          <source>Allows you to write your script in non-ASCII and non-UTF-8</source>
          <target state="translated">비 ASCII 및 비 UTF-8로 스크립트를 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dce4c63a4fe0fe7df493313e47b4aaa4d8491416" translate="yes" xml:space="preserve">
          <source>Almost all properties are immune to case-insensitive matching. That is, adding a &lt;code&gt;/i&lt;/code&gt; regular expression modifier does not change what they match. There are two sets that are affected. The first set is &lt;code&gt;Uppercase_Letter&lt;/code&gt; , &lt;code&gt;Lowercase_Letter&lt;/code&gt; , and &lt;code&gt;Titlecase_Letter&lt;/code&gt; , all of which match &lt;code&gt;Cased_Letter&lt;/code&gt; under &lt;code&gt;/i&lt;/code&gt; matching. And the second set is &lt;code&gt;Uppercase&lt;/code&gt; , &lt;code&gt;Lowercase&lt;/code&gt; , and &lt;code&gt;Titlecase&lt;/code&gt; , all of which match &lt;code&gt;Cased&lt;/code&gt; under &lt;code&gt;/i&lt;/code&gt; matching. This set also includes its subsets &lt;code&gt;PosixUpper&lt;/code&gt; and &lt;code&gt;PosixLower&lt;/code&gt; both of which under &lt;code&gt;/i&lt;/code&gt; match &lt;code&gt;PosixAlpha&lt;/code&gt; . (The difference between these sets is that some things, such as Roman numerals, come in both upper and lower case so they are &lt;code&gt;Cased&lt;/code&gt; , but aren't considered letters, so they aren't &lt;code&gt;Cased_Letter&lt;/code&gt; 's.)</source>
          <target state="translated">거의 모든 속성은 대소 문자를 구분하지 않습니다. 즉, &lt;code&gt;/i&lt;/code&gt; 정규식 수정자를 추가해도 일치하는 내용은 변경되지 않습니다. 영향을받는 두 세트가 있습니다. 첫 번째 세트는 &lt;code&gt;Uppercase_Letter&lt;/code&gt; , &lt;code&gt;Lowercase_Letter&lt;/code&gt; 및 &lt;code&gt;Titlecase_Letter&lt;/code&gt; 일치, 모두 &lt;code&gt;Cased_Letter&lt;/code&gt; 를 아래 &lt;code&gt;/i&lt;/code&gt; 정합. 그리고, 두 번째 세트는 &lt;code&gt;Uppercase&lt;/code&gt; , &lt;code&gt;Lowercase&lt;/code&gt; 및 &lt;code&gt;Titlecase&lt;/code&gt; 모두 매치 그중 &lt;code&gt;Cased&lt;/code&gt; 아래 &lt;code&gt;/i&lt;/code&gt; 매칭. 이 세트에는 &lt;code&gt;PosixUpper&lt;/code&gt; 및 &lt;code&gt;PosixLower&lt;/code&gt; 하위 세트도 포함 되어 있습니다. &lt;code&gt;/i&lt;/code&gt; 는 &lt;code&gt;PosixAlpha&lt;/code&gt; 와 일치 합니다 . (이 세트의 차이는 로마 숫자로 몇 가지, 그들은 그래서 모두 소문자로 제공한다는 것입니다 &lt;code&gt;Cased&lt;/code&gt; 가되지 않도록,하지만, 문자로 간주되지 않습니다 &lt;code&gt;Cased_Letter&lt;/code&gt; 의를.)</target>
        </trans-unit>
        <trans-unit id="038ae65882d3a2fe4f693af91d367090a422911d" translate="yes" xml:space="preserve">
          <source>Almost all properties are immune to case-insensitive matching. That is, adding a &lt;code&gt;/i&lt;/code&gt; regular expression modifier does not change what they match. There are two sets that are affected. The first set is &lt;code&gt;Uppercase_Letter&lt;/code&gt;, &lt;code&gt;Lowercase_Letter&lt;/code&gt;, and &lt;code&gt;Titlecase_Letter&lt;/code&gt;, all of which match &lt;code&gt;Cased_Letter&lt;/code&gt; under &lt;code&gt;/i&lt;/code&gt; matching. And the second set is &lt;code&gt;Uppercase&lt;/code&gt;, &lt;code&gt;Lowercase&lt;/code&gt;, and &lt;code&gt;Titlecase&lt;/code&gt;, all of which match &lt;code&gt;Cased&lt;/code&gt; under &lt;code&gt;/i&lt;/code&gt; matching. This set also includes its subsets &lt;code&gt;PosixUpper&lt;/code&gt; and &lt;code&gt;PosixLower&lt;/code&gt; both of which under &lt;code&gt;/i&lt;/code&gt; match &lt;code&gt;PosixAlpha&lt;/code&gt;. (The difference between these sets is that some things, such as Roman numerals, come in both upper and lower case so they are &lt;code&gt;Cased&lt;/code&gt;, but aren't considered letters, so they aren't &lt;code&gt;Cased_Letter&lt;/code&gt;'s.)</source>
          <target state="translated">거의 모든 속성은 대소 문자를 구분하지 않는 일치에 영향을받지 않습니다. 즉, &lt;code&gt;/i&lt;/code&gt; 정규식 수정자를 추가해도 일치 항목이 변경되지 않습니다. 영향을받는 두 세트가 있습니다. 첫 번째 세트는 &lt;code&gt;Uppercase_Letter&lt;/code&gt; , &lt;code&gt;Lowercase_Letter&lt;/code&gt; 및 &lt;code&gt;Titlecase_Letter&lt;/code&gt; 일치, 모두 &lt;code&gt;Cased_Letter&lt;/code&gt; 를 아래 &lt;code&gt;/i&lt;/code&gt; 정합. 그리고, 두 번째 세트는 &lt;code&gt;Uppercase&lt;/code&gt; , &lt;code&gt;Lowercase&lt;/code&gt; 및 &lt;code&gt;Titlecase&lt;/code&gt; 모두 매치 그중 &lt;code&gt;Cased&lt;/code&gt; 아래 &lt;code&gt;/i&lt;/code&gt; 매칭. 이 집합에는 &lt;code&gt;/i&lt;/code&gt; 아래에있는 &lt;code&gt;PosixUpper&lt;/code&gt; 및 &lt;code&gt;PosixLower&lt;/code&gt; 하위 집합도 포함됩니다. &lt;code&gt;PosixAlpha&lt;/code&gt; 와 일치 합니다 . (이 세트의 차이는 로마 숫자로 몇 가지, 그들은 그래서 모두 소문자로 제공한다는 것입니다 &lt;code&gt;Cased&lt;/code&gt; 가되지 않도록,하지만, 문자로 간주되지 않습니다 &lt;code&gt;Cased_Letter&lt;/code&gt; 의를.)</target>
        </trans-unit>
        <trans-unit id="e26025e2ac0ac02421707ba70eeed5ab6641b4e6" translate="yes" xml:space="preserve">
          <source>Almost definitely only useful to people hacking on the offsets part of the debug engine.</source>
          <target state="translated">디버그 엔진의 오프셋 부분을 해킹하는 사람들에게만 유용합니다.</target>
        </trans-unit>
        <trans-unit id="38d90c72fc98727ed772fa67692cb8b8e8e09948" translate="yes" xml:space="preserve">
          <source>Along the same lines, just because you</source>
          <target state="translated">같은 줄을 따라</target>
        </trans-unit>
        <trans-unit id="bfe689be701eb0f2bfb705a857c3ee07252b9d77" translate="yes" xml:space="preserve">
          <source>Along with the Perl interpreter itself, the Perl distribution installs a range of utilities on your system. There are also several utilities which are used by the Perl distribution itself as part of the install process. This document exists to list all of these utilities, explain what they are for and provide pointers to each module's documentation, if appropriate.</source>
          <target state="translated">Perl 인터프리터 자체와 함께 Perl 분배는 시스템에 다양한 유틸리티를 설치합니다. 설치 프로세스의 일부로 Perl 배포 자체에서 사용되는 몇 가지 유틸리티도 있습니다. 이 문서는 이러한 유틸리티를 모두 나열하고 해당 유틸리티의 기능을 설명하고 필요한 경우 각 모듈 설명서에 대한 포인터를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="4a1d8165f9108b98ce92f1ef1ce011a72e3b1d99" translate="yes" xml:space="preserve">
          <source>Alpha (7.2 and later)</source>
          <target state="translated">알파 (7.2 이상)</target>
        </trans-unit>
        <trans-unit id="11e18d2ae9ad5a7899fdd3214dec5b3e21bea356" translate="yes" xml:space="preserve">
          <source>Alpha Status</source>
          <target state="translated">알파 상태</target>
        </trans-unit>
        <trans-unit id="18ffbc668a2b6a3556c2c52abe1122c215a8f600" translate="yes" xml:space="preserve">
          <source>Alpha Versions</source>
          <target state="translated">알파 버전</target>
        </trans-unit>
        <trans-unit id="e9e4db05fa3da393c5842e003969195c59714caf" translate="yes" xml:space="preserve">
          <source>Alphabetical Listing of Perl Functions</source>
          <target state="translated">펄 함수의 알파벳순 목록</target>
        </trans-unit>
        <trans-unit id="80fccab3dfff9e36d82c59e9e04d5dad46135ca5" translate="yes" xml:space="preserve">
          <source>Alphabetical Listing of Win32 Functions</source>
          <target state="translated">Win32 함수의 알파벳순 목록</target>
        </trans-unit>
        <trans-unit id="35100f76a7dd5f19974c02f54724529e98b1eb3a" translate="yes" xml:space="preserve">
          <source>Alphabetical index of Unicode characters</source>
          <target state="translated">유니 코드 문자의 알파벳순 색인</target>
        </trans-unit>
        <trans-unit id="834177335506d3ec099968dc2393bf176b00318d" translate="yes" xml:space="preserve">
          <source>Also Perl gives access to various C library functions through the &lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt; module. Some of those functions are always affected by the current locale. For example, &lt;code&gt;POSIX::strftime()&lt;/code&gt; uses &lt;code&gt;LC_TIME&lt;/code&gt; ; &lt;code&gt;POSIX::strtod()&lt;/code&gt; uses &lt;code&gt;LC_NUMERIC&lt;/code&gt; ; &lt;code&gt;POSIX::strcoll()&lt;/code&gt; and &lt;code&gt;POSIX::strxfrm()&lt;/code&gt; use &lt;code&gt;LC_COLLATE&lt;/code&gt; ; and character classification functions like &lt;code&gt;POSIX::isalnum()&lt;/code&gt; use &lt;code&gt;LC_CTYPE&lt;/code&gt; . All such functions will behave according to the current underlying locale, even if that locale isn't exposed to Perl space.</source>
          <target state="translated">또한 Perl은 &lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt; 모듈을 통해 다양한 C 라이브러리 기능에 액세스 할 수 있습니다 . 이러한 기능 중 일부는 항상 현재 로캘의 영향을받습니다. 예를 들어 &lt;code&gt;POSIX::strftime()&lt;/code&gt; 은 &lt;code&gt;LC_TIME&lt;/code&gt; 을 사용합니다 . &lt;code&gt;POSIX::strtod()&lt;/code&gt; 는 &lt;code&gt;LC_NUMERIC&lt;/code&gt; 을 사용합니다 . &lt;code&gt;POSIX::strcoll()&lt;/code&gt; 및 &lt;code&gt;POSIX::strxfrm()&lt;/code&gt; 은 &lt;code&gt;LC_COLLATE&lt;/code&gt; 를 사용합니다 . &lt;code&gt;POSIX::isalnum()&lt;/code&gt; 과 같은 문자 분류 함수는 &lt;code&gt;LC_CTYPE&lt;/code&gt; 을 사용 합니다. 해당 로케일이 Perl 공간에 노출되지 않은 경우에도 이러한 모든 기능은 현재 기본 로케일에 따라 작동합니다.</target>
        </trans-unit>
        <trans-unit id="806708a695d3bd3532b34e82cf3ce83d314474cc" translate="yes" xml:space="preserve">
          <source>Also Perl gives access to various C library functions through the &lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt; module. Some of those functions are always affected by the current locale. For example, &lt;code&gt;POSIX::strftime()&lt;/code&gt; uses &lt;code&gt;LC_TIME&lt;/code&gt;; &lt;code&gt;POSIX::strtod()&lt;/code&gt; uses &lt;code&gt;LC_NUMERIC&lt;/code&gt;; &lt;code&gt;POSIX::strcoll()&lt;/code&gt; and &lt;code&gt;POSIX::strxfrm()&lt;/code&gt; use &lt;code&gt;LC_COLLATE&lt;/code&gt;. All such functions will behave according to the current underlying locale, even if that locale isn't exposed to Perl space.</source>
          <target state="translated">또한 Perl은 &lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt; 모듈을 통해 다양한 C 라이브러리 기능에 대한 액세스를 제공 합니다. 이러한 기능 중 일부는 항상 현재 로케일의 영향을받습니다. 예를 들어, &lt;code&gt;POSIX::strftime()&lt;/code&gt; 은 &lt;code&gt;LC_TIME&lt;/code&gt; 을 사용합니다 . &lt;code&gt;POSIX::strtod()&lt;/code&gt; 는 &lt;code&gt;LC_NUMERIC&lt;/code&gt; 을 사용합니다 . &lt;code&gt;POSIX::strcoll()&lt;/code&gt; 및 &lt;code&gt;POSIX::strxfrm()&lt;/code&gt; 은 &lt;code&gt;LC_COLLATE&lt;/code&gt; 를 사용 합니다. 이러한 모든 함수는 해당 로케일이 Perl 공간에 노출되지 않더라도 현재 기본 로케일에 따라 작동합니다.</target>
        </trans-unit>
        <trans-unit id="80beb22d4bec02699379f749d87a910462f32ef7" translate="yes" xml:space="preserve">
          <source>Also add the following code segment to Mytest.t while incrementing the &quot;9&quot; tests to &quot;11&quot;:</source>
          <target state="translated">또한 &quot;9&quot;테스트를 &quot;11&quot;로 늘리면서 다음 코드 세그먼트를 Mytest.t에 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="66aac698dcfc875f49b6e4c3fd8ffd4424837a0d" translate="yes" xml:space="preserve">
          <source>Also available in the CPAN &lt;a href=&quot;Unicode::CaseFold&quot;&gt;Unicode::CaseFold&lt;/a&gt; module, the new &lt;code&gt;fc&lt;/code&gt; &amp;ldquo;foldcase&amp;rdquo; function from v5.16 grants access to the same Unicode casefolding as the &lt;code&gt;/i&lt;/code&gt; pattern modifier has always used:</source>
          <target state="translated">CPAN &lt;a href=&quot;Unicode::CaseFold&quot;&gt;Unicode :: CaseFold&lt;/a&gt; 모듈 에서도 사용할 수있는 v5.16 의 새로운 &lt;code&gt;fc&lt;/code&gt; &quot;foldcase&quot;함수는 &lt;code&gt;/i&lt;/code&gt; 패턴 수정자가 항상 사용 했던 것과 동일한 유니 코드 casefolding에 대한 액세스 권한을 부여합니다 .</target>
        </trans-unit>
        <trans-unit id="ac140b9c3d4faf5ff89331ade5065ee26ad2ce5b" translate="yes" xml:space="preserve">
          <source>Also available in the CPAN &lt;a href=&quot;http://search.cpan.org/perldoc/Unicode::CaseFold&quot;&gt;Unicode::CaseFold&lt;/a&gt; module, the new &lt;code&gt;&lt;a href=&quot;functions/fc&quot;&gt;fc&lt;/a&gt;&lt;/code&gt; &amp;ldquo;foldcase&amp;rdquo; function from v5.16 grants access to the same Unicode casefolding as the &lt;code&gt;/i&lt;/code&gt; pattern modifier has always used:</source>
          <target state="translated">CPAN &lt;a href=&quot;http://search.cpan.org/perldoc/Unicode::CaseFold&quot;&gt;Unicode :: CaseFold&lt;/a&gt; 모듈 에서도 사용 가능하며, v5.16 의 새로운 &lt;code&gt;&lt;a href=&quot;functions/fc&quot;&gt;fc&lt;/a&gt;&lt;/code&gt; &quot;foldcase&quot;함수는 &lt;code&gt;/i&lt;/code&gt; 패턴 수정자가 항상 사용 했던 것과 동일한 Unicode casefolding에 대한 액세스 권한을 부여합니다 .</target>
        </trans-unit>
        <trans-unit id="46cd58b57422283c68d064857c29c9de3e394325" translate="yes" xml:space="preserve">
          <source>Also change</source>
          <target state="translated">또한 변경</target>
        </trans-unit>
        <trans-unit id="c0abeeb67d5f473db892c8e04d0607c1def48eaa" translate="yes" xml:space="preserve">
          <source>Also compare &lt;code&gt;SAVEMORTALIZESV&lt;/code&gt; .</source>
          <target state="translated">또한 &lt;code&gt;SAVEMORTALIZESV&lt;/code&gt; 를 비교 하십시오 .</target>
        </trans-unit>
        <trans-unit id="ec1353ed582dbdd3a8cc64f4bfa77fcc41799879" translate="yes" xml:space="preserve">
          <source>Also compare &lt;code&gt;SAVEMORTALIZESV&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;SAVEMORTALIZESV&lt;/code&gt; 도 비교 하십시오 .</target>
        </trans-unit>
        <trans-unit id="05e4ad005c5681ba47d1d566b8e0cb49ffb2ad43" translate="yes" xml:space="preserve">
          <source>Also consider this valid structure:</source>
          <target state="translated">이 유효한 구조도 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="a7b339961adc2d21b9a876670a45b1f1d855a3be" translate="yes" xml:space="preserve">
          <source>Also create a file mylib.c that looks like this:</source>
          <target state="translated">또한 다음과 같은 mylib.c 파일을 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="c401faba028e376c88469287989685e42d637510" translate="yes" xml:space="preserve">
          <source>Also floating point numbers have endianness. Usually (but not always) this agrees with the integer endianness. Even though most platforms these days use the IEEE 754 binary format, there are differences, especially if the long doubles are involved. You can see the &lt;code&gt;Config&lt;/code&gt; variables &lt;code&gt;doublekind&lt;/code&gt; and &lt;code&gt;longdblkind&lt;/code&gt; (also &lt;code&gt;doublesize&lt;/code&gt; , &lt;code&gt;longdblsize&lt;/code&gt; ): the &quot;kind&quot; values are enums, unlike &lt;code&gt;byteorder&lt;/code&gt; .</source>
          <target state="translated">또한 부동 소수점 숫자에는 엔디안이 있습니다. 일반적으로 (항상 그런 것은 아니지만) 이것은 정수 엔디안과 일치합니다. 요즘 대부분의 플랫폼에서 IEEE 754 이진 형식을 사용하지만 특히 Long Double이 포함 된 경우 차이점이 있습니다. 당신이 볼 수있는 &lt;code&gt;Config&lt;/code&gt; 변수가 &lt;code&gt;doublekind&lt;/code&gt; 및 &lt;code&gt;longdblkind&lt;/code&gt; (또한 &lt;code&gt;doublesize&lt;/code&gt; , &lt;code&gt;longdblsize&lt;/code&gt; )은 &quot;종류&quot;값은 달리 열거 있습니다 &lt;code&gt;byteorder&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="379626cc299d524fecb163de196b94d66c798488" translate="yes" xml:space="preserve">
          <source>Also floating point numbers have endianness. Usually (but not always) this agrees with the integer endianness. Even though most platforms these days use the IEEE 754 binary format, there are differences, especially if the long doubles are involved. You can see the &lt;code&gt;Config&lt;/code&gt; variables &lt;code&gt;doublekind&lt;/code&gt; and &lt;code&gt;longdblkind&lt;/code&gt; (also &lt;code&gt;doublesize&lt;/code&gt;, &lt;code&gt;longdblsize&lt;/code&gt;): the &quot;kind&quot; values are enums, unlike &lt;code&gt;byteorder&lt;/code&gt;.</source>
          <target state="translated">또한 부동 소수점 숫자에는 엔디안이 있습니다. 일반적으로 (항상 그런 것은 아님) 정수 엔디안과 일치합니다. 요즘 대부분의 플랫폼은 IEEE 754 바이너리 형식을 사용하지만 특히 long double이 포함 된 경우에는 차이가 있습니다. 당신이 볼 수있는 &lt;code&gt;Config&lt;/code&gt; 변수가 &lt;code&gt;doublekind&lt;/code&gt; 및 &lt;code&gt;longdblkind&lt;/code&gt; (또한 &lt;code&gt;doublesize&lt;/code&gt; , &lt;code&gt;longdblsize&lt;/code&gt; )은 &quot;종류&quot;값은 달리 열거 있습니다 &lt;code&gt;byteorder&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d6a0632d09aa67f7c933563807a5dc4e1be43b5e" translate="yes" xml:space="preserve">
          <source>Also good for one-liners:</source>
          <target state="translated">하나의 라이너에도 좋습니다.</target>
        </trans-unit>
        <trans-unit id="801a4731c98561cdcf16aa86d636dfa32a54b0ca" translate="yes" xml:space="preserve">
          <source>Also keep around the old $(SAY) macro in case somebody's using it.</source>
          <target state="translated">누군가가 그것을 사용하고 있다면 이전 $ (SAY) 매크로를 유지하십시오.</target>
        </trans-unit>
        <trans-unit id="2c84ea90ff2c682d2dfed6ff8b041df2e7877e52" translate="yes" xml:space="preserve">
          <source>Also like the &quot;strict&quot; pragma, if there is more than one instance of the &lt;code&gt;warnings&lt;/code&gt; pragma in a given scope the cumulative effect is additive.</source>
          <target state="translated">또한 &quot;엄격한&quot;프라 그마처럼, 주어진 범위에 &lt;code&gt;warnings&lt;/code&gt; 프라그 마가 두 개 이상있는 경우 누적 효과는 부가 적입니다.</target>
        </trans-unit>
        <trans-unit id="8b1ee43d27cd54e3a73fd0b027a7a33d6ab24281" translate="yes" xml:space="preserve">
          <source>Also make sure that you have</source>
          <target state="translated">또한 당신이 가지고 있는지 확인하십시오</target>
        </trans-unit>
        <trans-unit id="40bb5340e74c1ea8c0aff8ce399c268adda872b8" translate="yes" xml:space="preserve">
          <source>Also make sure you read &lt;a href=&quot;#BUGS-AND-CAVEATS&quot;&gt;&quot;BUGS AND CAVEATS&quot;&lt;/a&gt; below for the known limitations of this port.</source>
          <target state="translated">또한 이 포트의 알려진 제한 사항에 대해 아래의 &lt;a href=&quot;#BUGS-AND-CAVEATS&quot;&gt;&quot;버그 및주의 사항&quot;&lt;/a&gt; 을 읽으십시오 .</target>
        </trans-unit>
        <trans-unit id="ccf329915f222131778e86ee9fd087f89f391e81" translate="yes" xml:space="preserve">
          <source>Also make sure you read &lt;a href=&quot;#BUGS-AND-CAVEATS&quot;&gt;BUGS AND CAVEATS&lt;/a&gt; below for the known limitations of this port.</source>
          <target state="translated">또한 이 포트의 알려진 제한 사항은 아래의 &lt;a href=&quot;#BUGS-AND-CAVEATS&quot;&gt;버그 및주의 사항&lt;/a&gt; 을 읽으십시오 .</target>
        </trans-unit>
        <trans-unit id="fe06cc0daccf4654b8c81c8f1faee5e0b7783c69" translate="yes" xml:space="preserve">
          <source>Also no attention is paid to &lt;code&gt;\c\&lt;/code&gt; (multichar control char syntax) during this search. Thus the second &lt;code&gt;\&lt;/code&gt; in &lt;code&gt;&lt;a href=&quot;functions/qq&quot;&gt;qq/\c\/&lt;/a&gt;&lt;/code&gt; is interpreted as a part of &lt;code&gt;\/&lt;/code&gt;, and the following &lt;code&gt;/&lt;/code&gt; is not recognized as a delimiter. Instead, use &lt;code&gt;\034&lt;/code&gt; or &lt;code&gt;\x1c&lt;/code&gt; at the end of quoted constructs.</source>
          <target state="translated">또한 이 검색 중에 &lt;code&gt;\c\&lt;/code&gt; (multichar control char 구문)에 주의를 기울이지 않습니다 . 따라서 두 번째 &lt;code&gt;\&lt;/code&gt; 에있는 &lt;code&gt;&lt;a href=&quot;functions/qq&quot;&gt;qq/\c\/&lt;/a&gt;&lt;/code&gt; 의 일환으로 해석됩니다 &lt;code&gt;\/&lt;/code&gt; , 및 다음 &lt;code&gt;/&lt;/code&gt; 구분 기호로 인식되지 않습니다. 대신 인용 된 구문의 끝에 &lt;code&gt;\034&lt;/code&gt; 또는 &lt;code&gt;\x1c&lt;/code&gt; 를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="b4748c09ad60564220ae82641c3695fd5eb7b587" translate="yes" xml:space="preserve">
          <source>Also no attention is paid to &lt;code&gt;\c\&lt;/code&gt; (multichar control char syntax) during this search. Thus the second &lt;code&gt;\&lt;/code&gt; in &lt;code&gt;qq/\c\/&lt;/code&gt; is interpreted as a part of &lt;code&gt;\/&lt;/code&gt;, and the following &lt;code&gt;/&lt;/code&gt; is not recognized as a delimiter. Instead, use &lt;code&gt;\034&lt;/code&gt; or &lt;code&gt;\x1c&lt;/code&gt; at the end of quoted constructs.</source>
          <target state="translated">또한 이 검색 중에 &lt;code&gt;\c\&lt;/code&gt; (다중 문자 제어 문자 구문)에 주의를 기울이지 않습니다 . 따라서 두 번째 &lt;code&gt;\&lt;/code&gt; 에있는 &lt;code&gt;qq/\c\/&lt;/code&gt; 의 일환으로 해석됩니다 &lt;code&gt;\/&lt;/code&gt; , 및 다음 &lt;code&gt;/&lt;/code&gt; 구분 기호로 인식되지 않습니다. 대신 인용 된 구문의 끝에 &lt;code&gt;\034&lt;/code&gt; 또는 &lt;code&gt;\x1c&lt;/code&gt; 를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="73a9b46957654b20ec65fb83845a1d68f2c4bbed" translate="yes" xml:space="preserve">
          <source>Also note that</source>
          <target state="translated">또한</target>
        </trans-unit>
        <trans-unit id="674fbb1e5f8c5ba4d4b18a90ede292ece92dabf5" translate="yes" xml:space="preserve">
          <source>Also note that &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; passes command line arguments to &lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;, which doesn't necessarily interpret them as file names. See &lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt; for possible security implications.</source>
          <target state="translated">또한 &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; 는 명령 행 인수를 &lt;a href=&quot;functions/open&quot;&gt;open에&lt;/a&gt; 전달하므로 반드시 파일 이름으로 해석 할 필요는 없습니다. 가능한 보안 영향에 대해서는 &lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="6e76aeddde8e8e63ee64b7f772d9f3c1b3f62e2a" translate="yes" xml:space="preserve">
          <source>Also note that &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; passes command line arguments to &lt;a href=&quot;perlfunc#open&quot;&gt;&quot;open&quot; in perlfunc&lt;/a&gt;, which doesn't necessarily interpret them as file names. See &lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt; for possible security implications.</source>
          <target state="translated">또한 &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; 는 &lt;a href=&quot;perlfunc#open&quot;&gt;perlfunc의 &quot;open&quot;에&lt;/a&gt; 명령 줄 인수를 전달 하므로 반드시 파일 이름으로 해석 할 필요는 없습니다. 가능한 보안 관련 사항 은 &lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="93e48d832329c669ef467acfbb855710b1f11c32" translate="yes" xml:space="preserve">
          <source>Also note that in order to be compatible with the shell command, &lt;code&gt;basename()&lt;/code&gt; does not strip off a suffix if it is identical to the remaining characters in the filename.</source>
          <target state="translated">또한 쉘 명령과 호환되도록 &lt;code&gt;basename()&lt;/code&gt; 은 파일 이름의 나머지 문자와 동일한 접미어를 제거하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6d4f64c4ffda1e49198c526880412a3685e89bbb" translate="yes" xml:space="preserve">
          <source>Also note that in some platforms trying to use the infinity in arithmetic operations may result in Perl crashing because using an infinity causes SIGFPE or its moral equivalent to be sent. The way to ignore this is</source>
          <target state="translated">또한 일부 플랫폼에서 산술 연산에 무한대를 사용하려고하면 무한대를 사용하면 SIGFPE 또는 그와 동등한 도덕적 결과가 전송되므로 Perl이 충돌 할 수 있습니다. 이것을 무시하는 방법은</target>
        </trans-unit>
        <trans-unit id="e93493c0471e07df3c4c3cbce58bbf69cdead50b" translate="yes" xml:space="preserve">
          <source>Also note that non-STD file handles remain unaffected. Use &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;
&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; to change the layers of those.</source>
          <target state="translated">또한 STD 이외의 파일 핸들은 영향을받지 않습니다. 사용은 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; &lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; 사람들의 층을 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="65a1eea4a01332917c07c49aead459f12a5fb083" translate="yes" xml:space="preserve">
          <source>Also note that non-STD file handles remain unaffected. Use &lt;code&gt;use open&lt;/code&gt; or &lt;code&gt;binmode&lt;/code&gt; to change the layers of those.</source>
          <target state="translated">또한 비 STD 파일 핸들은 영향을받지 않습니다. 사용이 &lt;code&gt;use open&lt;/code&gt; 또는 &lt;code&gt;binmode&lt;/code&gt; 사람들의 층을 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8343e14f16aa3f23ee42ee984961cfee3da48f48" translate="yes" xml:space="preserve">
          <source>Also note that the &lt;code&gt;sv_set*()&lt;/code&gt; and &lt;code&gt;sv_cat*()&lt;/code&gt; functions described earlier do &lt;b&gt;not&lt;/b&gt; invoke 'set' magic on their targets. This must be done by the user either by calling the &lt;code&gt;SvSETMAGIC()&lt;/code&gt; macro after calling these functions, or by using one of the &lt;code&gt;sv_set*_mg()&lt;/code&gt; or &lt;code&gt;sv_cat*_mg()&lt;/code&gt; functions. Similarly, generic C code must call the &lt;code&gt;SvGETMAGIC()&lt;/code&gt; macro to invoke any 'get' magic if they use an SV obtained from external sources in functions that don't handle magic. See &lt;a href=&quot;perlapi&quot;&gt;perlapi&lt;/a&gt; for a description of these functions. For example, calls to the &lt;code&gt;sv_cat*()&lt;/code&gt; functions typically need to be followed by &lt;code&gt;SvSETMAGIC()&lt;/code&gt; , but they don't need a prior &lt;code&gt;SvGETMAGIC()&lt;/code&gt; since their implementation handles 'get' magic.</source>
          <target state="translated">또한 앞에서 설명한 &lt;code&gt;sv_set*()&lt;/code&gt; 및 &lt;code&gt;sv_cat*()&lt;/code&gt; 함수는 대상에서 'set'마술을 호출 하지 &lt;b&gt;않습니다&lt;/b&gt; . 이 함수를 호출 한 후 &lt;code&gt;SvSETMAGIC()&lt;/code&gt; 매크로를 호출하거나 &lt;code&gt;sv_set*_mg()&lt;/code&gt; 또는 &lt;code&gt;sv_cat*_mg()&lt;/code&gt; 함수 중 하나를 사용하여 사용자가 수행해야합니다 . 마찬가지로, 일반 C 코드는 &lt;code&gt;SvGETMAGIC()&lt;/code&gt; 매크로를 호출하여 매직을 처리하지 않는 함수의 외부 소스에서 얻은 SV를 사용하는 경우 'get'매직을 호출해야합니다. 이 기능에 대한 설명은 &lt;a href=&quot;perlapi&quot;&gt;perlapi&lt;/a&gt; 를 참조하십시오 . 예를 들어 &lt;code&gt;sv_cat*()&lt;/code&gt; 함수를 호출하면 일반적으로 &lt;code&gt;SvSETMAGIC()&lt;/code&gt; 가 와야합니다.구현은 'get'매직을 처리하므로 이전 &lt;code&gt;SvGETMAGIC()&lt;/code&gt; 필요하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="04a13d83ef82898f68f016497d3a4a1f1464818f" translate="yes" xml:space="preserve">
          <source>Also note that the &lt;code&gt;sv_set*()&lt;/code&gt; and &lt;code&gt;sv_cat*()&lt;/code&gt; functions described earlier do &lt;b&gt;not&lt;/b&gt; invoke 'set' magic on their targets. This must be done by the user either by calling the &lt;code&gt;SvSETMAGIC()&lt;/code&gt; macro after calling these functions, or by using one of the &lt;code&gt;sv_set*_mg()&lt;/code&gt; or &lt;code&gt;sv_cat*_mg()&lt;/code&gt; functions. Similarly, generic C code must call the &lt;code&gt;SvGETMAGIC()&lt;/code&gt; macro to invoke any 'get' magic if they use an SV obtained from external sources in functions that don't handle magic. See &lt;a href=&quot;perlapi&quot;&gt;perlapi&lt;/a&gt; for a description of these functions. For example, calls to the &lt;code&gt;sv_cat*()&lt;/code&gt; functions typically need to be followed by &lt;code&gt;SvSETMAGIC()&lt;/code&gt;, but they don't need a prior &lt;code&gt;SvGETMAGIC()&lt;/code&gt; since their implementation handles 'get' magic.</source>
          <target state="translated">또한 앞에서 설명한 &lt;code&gt;sv_set*()&lt;/code&gt; 및 &lt;code&gt;sv_cat*()&lt;/code&gt; 함수는 대상에서 'set'마법을 호출 하지 &lt;b&gt;않습니다&lt;/b&gt; . 사용자는 이러한 함수를 호출 한 후 &lt;code&gt;SvSETMAGIC()&lt;/code&gt; 매크로를 호출하거나 &lt;code&gt;sv_set*_mg()&lt;/code&gt; 또는 &lt;code&gt;sv_cat*_mg()&lt;/code&gt; 함수 중 하나를 사용하여 수행해야합니다. 마찬가지로, 일반 C 코드는 매직을 처리하지 않는 함수에서 외부 소스에서 얻은 SV를 사용하는 경우 'get'매직을 호출하기 위해 &lt;code&gt;SvGETMAGIC()&lt;/code&gt; 매크로를 호출해야합니다. 이러한 기능에 대한 설명은 &lt;a href=&quot;perlapi&quot;&gt;perlapi&lt;/a&gt; 를 참조하십시오 . 예를 들어, &lt;code&gt;sv_cat*()&lt;/code&gt; 함수에 대한 호출은 일반적으로 &lt;code&gt;SvSETMAGIC()&lt;/code&gt; 다음에 와야합니다.하지만 구현이 'get'마법을 처리하기 때문에 이전 &lt;code&gt;SvGETMAGIC()&lt;/code&gt; 필요하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="e7be1aad912cf4ad5fcf4064cf6ab4309ca326be" translate="yes" xml:space="preserve">
          <source>Also note that the bval option only allows you to specify a single byte as a delimiter.</source>
          <target state="translated">또한 bval 옵션을 사용하면 단일 바이트 만 구분 기호로 지정할 수 있습니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
