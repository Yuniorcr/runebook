<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="perl">
    <body>
      <group id="perl">
        <trans-unit id="24ccbbac9acf528b1853df8a90343ca28c46e8a9" translate="yes" xml:space="preserve">
          <source>tell() on unopened filehandle</source>
          <target state="translated">열리지 않은 파일 핸들에 대해 tell ()</target>
        </trans-unit>
        <trans-unit id="92794ee7e6ac81c9d0817ebf20684a58c197e63c" translate="yes" xml:space="preserve">
          <source>telldir</source>
          <target state="translated">telldir</target>
        </trans-unit>
        <trans-unit id="0b71e99628dd6430e7fea176d4129b7a8ec37b08" translate="yes" xml:space="preserve">
          <source>telldir DIRHANDLE</source>
          <target state="translated">telldir DIRHANDLE</target>
        </trans-unit>
        <trans-unit id="6a572b7613a27b972a89c0d33e211e6fd612b18f" translate="yes" xml:space="preserve">
          <source>telldir() attempted on invalid dirhandle %s</source>
          <target state="translated">telldir ()이 잘못된 dirhandle % s에서 시도했습니다.</target>
        </trans-unit>
        <trans-unit id="b0c0a02ffde3c44fa00b63c51cbb72effceae586" translate="yes" xml:space="preserve">
          <source>telling the class of the argument [C99].</source>
          <target state="translated">논증의 클래스에게 말하는 것 [C99].</target>
        </trans-unit>
        <trans-unit id="2ee36cb83ce215ce088b9d61711445776b33c012" translate="yes" xml:space="preserve">
          <source>telling the class of the argument [C99]. &lt;code&gt;FP_INFINITE&lt;/code&gt; is positive or negative infinity, &lt;code&gt;FP_NAN&lt;/code&gt; is not-a-number. &lt;code&gt;FP_SUBNORMAL&lt;/code&gt; means subnormal numbers (also known as denormals), very small numbers with low precision. &lt;code&gt;FP_ZERO&lt;/code&gt; is zero. &lt;code&gt;FP_NORMAL&lt;/code&gt; is all the rest.</source>
          <target state="translated">인수 [C99]의 클래스를 알려줍니다. &lt;code&gt;FP_INFINITE&lt;/code&gt; 는 양수 또는 음수 무한대이고 &lt;code&gt;FP_NAN&lt;/code&gt; 은 숫자가 아닙니다. &lt;code&gt;FP_SUBNORMAL&lt;/code&gt; 은 비정규 숫자 (비정규라고도 함), 정밀도가 낮은 매우 작은 숫자를 의미합니다. &lt;code&gt;FP_ZERO&lt;/code&gt; 는 0입니다. 나머지는 &lt;code&gt;FP_NORMAL&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="59b3aa384d6a9c476a221a2eda4917392e16c2d7" translate="yes" xml:space="preserve">
          <source>tells Perl that the program is embedded in a larger chunk of unrelated text, such as in a mail message. Leading garbage will be discarded until the first line that starts with &lt;code&gt;#!&lt;/code&gt; and contains the string &quot;perl&quot;. Any meaningful switches on that line will be applied.</source>
          <target state="translated">프로그램이 메일 메시지와 같이 더 큰 관련이없는 텍스트에 포함되어 있음을 Perl에 알립니다. &lt;code&gt;#!&lt;/code&gt; 시작하는 첫 번째 줄까지는 가비지가 버립니다 . 문자열 &quot;perl&quot;을 포함합니다. 해당 회선의 의미있는 스위치가 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="22e9f56882c87c3da193be3fe6d8c77ffdaf27bc" translate="yes" xml:space="preserve">
          <source>telnet</source>
          <target state="translated">telnet</target>
        </trans-unit>
        <trans-unit id="a2b78cc26d8d7b69f3d90b096c3148c048990756" translate="yes" xml:space="preserve">
          <source>temporarily makes $Here::blue an alias for $There::green, but doesn't make @Here::blue an alias for @There::green, or %Here::blue an alias for %There::green, etc. See &lt;a href=&quot;perlmod#Symbol-Tables&quot;&gt;&quot;Symbol Tables&quot; in perlmod&lt;/a&gt; for more examples of this. Strange though this may seem, this is the basis for the whole module import/export system.</source>
          <target state="translated">일시적으로 $ Here :: blue를 $ There :: green의 별칭으로 만들지 만 @Here :: blue를 @There :: green의 별칭으로 만들지 않거나 % Here :: blue를 % There :: green의 별칭으로 만들지 않습니다. 더 많은 예제를 보려면 &lt;a href=&quot;perlmod#Symbol-Tables&quot;&gt;perlmod의 &quot;Symbol Tables&quot;를&lt;/a&gt; 참조하십시오 . 이상하게 보일지 모르지만 이것이 전체 모듈 가져 오기 / 내보내기 시스템의 기초입니다.</target>
        </trans-unit>
        <trans-unit id="e17be14d891796d29c88b561a3f5c6c8310bbdc3" translate="yes" xml:space="preserve">
          <source>temporarily makes $Here::blue an alias for $There::green, but doesn't make @Here::blue an alias for @There::green, or %Here::blue an alias for %There::green, etc. See &lt;a href=&quot;perlmod#Symbol-Tables&quot;&gt;Symbol Tables in perlmod&lt;/a&gt; for more examples of this. Strange though this may seem, this is the basis for the whole module import/export system.</source>
          <target state="translated">일시적으로 $ Here :: blue를 $ There :: green의 별칭으로 만들지 만 @Here :: blue를 @There :: green의 별칭으로 만들지 않거나 % Here :: blue를 % There :: green의 별칭으로 만들지 않습니다. 더 자세한 내용 &lt;a href=&quot;perlmod#Symbol-Tables&quot;&gt;은 perlmod의 기호 테이블을&lt;/a&gt; 참조하십시오 . 이상하게 보일 수 있지만 이것이 전체 모듈 가져 오기 / 내보내기 시스템의 기초입니다.</target>
        </trans-unit>
        <trans-unit id="35825a61520f1c2ed79153398a1a3b55fc959ba6" translate="yes" xml:space="preserve">
          <source>temporarily override assorted &lt;code&gt;CPAN.pm&lt;/code&gt; configuration variables</source>
          <target state="translated">분류 된 &lt;code&gt;CPAN.pm&lt;/code&gt; 구성 변수를 임시로 재정의</target>
        </trans-unit>
        <trans-unit id="91ad65ee0c085dfce15fcf8c596de36b7d3e5bed" translate="yes" xml:space="preserve">
          <source>tended Unicode character.</source>
          <target state="translated">경향이있는 유니 코드 문자.</target>
        </trans-unit>
        <trans-unit id="2a4c3b84009d0ba24c742a698f0adb23e6f1ea7c" translate="yes" xml:space="preserve">
          <source>term</source>
          <target state="translated">term</target>
        </trans-unit>
        <trans-unit id="87322b9c9cc91afda040e63a2f8b7eaa20045932" translate="yes" xml:space="preserve">
          <source>term_is_latin</source>
          <target state="translated">term_is_latin</target>
        </trans-unit>
        <trans-unit id="309a9072621594bd8460c0460ea64f66d7737da2" translate="yes" xml:space="preserve">
          <source>term_ornaments</source>
          <target state="translated">term_ornaments</target>
        </trans-unit>
        <trans-unit id="0c710463aba09fea37318d6a1e322bde072ae43c" translate="yes" xml:space="preserve">
          <source>termcap(5)</source>
          <target state="translated">termcap(5)</target>
        </trans-unit>
        <trans-unit id="9a9c106ef0b7b5f35055988715406d563a4b3327" translate="yes" xml:space="preserve">
          <source>terminal capacities</source>
          <target state="translated">터미널 용량</target>
        </trans-unit>
        <trans-unit id="e261fbd24a6484c58a56a1cf2750b8e0ddf8fada" translate="yes" xml:space="preserve">
          <source>terminate</source>
          <target state="translated">terminate</target>
        </trans-unit>
        <trans-unit id="11fee33453c427b3e6ebabb7d2d2120312c0e7c9" translate="yes" xml:space="preserve">
          <source>terminator</source>
          <target state="translated">terminator</target>
        </trans-unit>
        <trans-unit id="f974fb78f68b344f21a122a60b4e7bd3015b965b" translate="yes" xml:space="preserve">
          <source>ternary</source>
          <target state="translated">ternary</target>
        </trans-unit>
        <trans-unit id="a94a8fe5ccb19ba61c4c0873d391e987982fbbd3" translate="yes" xml:space="preserve">
          <source>test</source>
          <target state="translated">test</target>
        </trans-unit>
        <trans-unit id="20e9cc515535904762a7b02f44c6058d48f63a62" translate="yes" xml:space="preserve">
          <source>test (o)</source>
          <target state="translated">테스트 (o)</target>
        </trans-unit>
        <trans-unit id="e715ccd5a1a578c299a8d942b4b10bbeb1c3b460" translate="yes" xml:space="preserve">
          <source>test 4 may fail if you are on a tmpfs of some sort. Building in /tmp sometimes shows this behavior. The test suite detects if you are building in /tmp, but it may not be able to catch all tmpfs situations.</source>
          <target state="translated">tmpfs를 사용하는 경우 테스트 4가 실패 할 수 있습니다. / tmp로 빌드하면 때때로이 동작이 표시됩니다. 테스트 스위트는 / tmp에 빌드 중인지를 감지하지만 모든 tmpfs 상황을 포착하지 못할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="3baa493ec3f690bb6e71fbdecd667bead97dd08b" translate="yes" xml:space="preserve">
          <source>test and install by</source>
          <target state="translated">테스트 및 설치</target>
        </trans-unit>
        <trans-unit id="9d2932c4017f41d4e1347256378e44b58fbc1a3f" translate="yes" xml:space="preserve">
          <source>test directory is flat, with all test files located directly within it. However, you can nest tests within subdirectories, for example:</source>
          <target state="translated">테스트 디렉토리는 모든 테스트 파일이 바로 그 안에있는 플랫입니다. 그러나 다음과 같이 하위 디렉터리 내에 테스트를 중첩 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ab9e5c896f4e6e83350f7e6655ffaca65aa5faa7" translate="yes" xml:space="preserve">
          <source>test fails. More precisely: the subtests using datagram sockets fail. Unix datagram sockets aren't implemented in Haiku yet.</source>
          <target state="translated">테스트 실패 보다 정확하게는 데이터 그램 소켓을 사용한 하위 테스트가 실패합니다. Unix 데이터 그램 소켓은 아직 Haiku에서 구현되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="2e335b5beb93717af185fbf36192a610a92fac52" translate="yes" xml:space="preserve">
          <source>test fails. This is due to Haiku not implementing</source>
          <target state="translated">테스트 실패 이것은 Haiku가 구현하지 않았기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="46fa1990856d6bfc5aa426d6de0036a2f3e6f778" translate="yes" xml:space="preserve">
          <source>test hangs (subtest #51, FWIW) for some unknown reason. Just stop the test and kill that particular Perl process.</source>
          <target state="translated">알 수없는 이유로 테스트가 중단됩니다 (서브 테스트 # 51, FWIW). 테스트를 중단하고 특정 Perl 프로세스를 종료하십시오.</target>
        </trans-unit>
        <trans-unit id="1745a2b1e1df23d1d960c6a914693643c4d35ef0" translate="yes" xml:space="preserve">
          <source>test methods</source>
          <target state="translated">시험 방법</target>
        </trans-unit>
        <trans-unit id="06069cf41f09b0e9e006f68445efe0b43e5710d7" translate="yes" xml:space="preserve">
          <source>test which will simply check that your code compiles and stop &quot;make test&quot; prematurely if it doesn't. See &lt;a href=&quot;../test/more#BAIL_OUT&quot;&gt;BAIL_OUT in Test::More&lt;/a&gt; for more details.</source>
          <target state="translated">test는 단순히 코드가 컴파일되었는지 확인하고 그렇지 않은 경우 &quot;make test&quot;를 조기에 중지합니다. 자세한 내용 &lt;a href=&quot;../test/more#BAIL_OUT&quot;&gt;은 Test :: More의 BAIL_OUT&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="84a38298de25a69d0e952ceb6f7d05eacba89c5b" translate="yes" xml:space="preserve">
          <source>test which will simply check that your code compiles and stop &quot;make test&quot; prematurely if it doesn't. See &lt;a href=&quot;Test::More#BAIL_OUT&quot;&gt;&quot;BAIL_OUT&quot; in Test::More&lt;/a&gt; for more details.</source>
          <target state="translated">테스트는 단순히 코드가 컴파일되는지 확인하고 그렇지 않은 경우 &quot;make test&quot;를 조기에 중지합니다. 자세한 내용 &lt;a href=&quot;Test::More#BAIL_OUT&quot;&gt;은 Test :: More의 &quot;BAIL_OUT&quot;&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="5ab50aa4c10a2157c2768ce7cbfe05ab8151cfe2" translate="yes" xml:space="preserve">
          <source>test). Do not forget to unset &lt;code&gt;PERL_EMXLOAD_SEC&lt;/code&gt; in environment.</source>
          <target state="translated">테스트). 환경에서 &lt;code&gt;PERL_EMXLOAD_SEC&lt;/code&gt; 를 설정 해제하는 것을 잊지 마십시오 .</target>
        </trans-unit>
        <trans-unit id="cb4ad0365fddec4e49c57d1b284389abf82fc895" translate="yes" xml:space="preserve">
          <source>test-notty test_notty</source>
          <target state="translated">test-notty test_notty</target>
        </trans-unit>
        <trans-unit id="33c341554523e86b3f9130f24b43a7e89a4a0a09" translate="yes" xml:space="preserve">
          <source>test. These failures have been suppressed in the current release of Perl by making the test ignore the broken locale. If you need to use the eu_ES locale, you should contact Apple support.</source>
          <target state="translated">테스트. 테스트가 깨진 로케일을 무시하게함으로써 현재 릴리스의 Perl에서 이러한 실패가 억제되었습니다. eu_ES 로켈을 사용해야하는 경우 Apple 지원에 문의하십시오.</target>
        </trans-unit>
        <trans-unit id="a7cd61938a0a91df8c916296b3b0f681386d5536" translate="yes" xml:space="preserve">
          <source>test.pl</source>
          <target state="translated">test.pl</target>
        </trans-unit>
        <trans-unit id="78b8688474ffb49604b4678655c15d17692b3a0d" translate="yes" xml:space="preserve">
          <source>test.valgrind check.valgrind</source>
          <target state="translated">test.valgrind check.valgrind</target>
        </trans-unit>
        <trans-unit id="ce9c25bf64a16b39138018a1858085791b1cfc02" translate="yes" xml:space="preserve">
          <source>test2_add_callback_context_acquire(sub { ... })</source>
          <target state="translated">test2_add_callback_context_acquire(sub { ... })</target>
        </trans-unit>
        <trans-unit id="570bcb0ef3011ee203856f18456d8ce4f59a52c3" translate="yes" xml:space="preserve">
          <source>test2_add_callback_context_init(sub { ... })</source>
          <target state="translated">test2_add_callback_context_init(sub { ... })</target>
        </trans-unit>
        <trans-unit id="7a2fff7bbafb98233ee1767fb434b140b5489f21" translate="yes" xml:space="preserve">
          <source>test2_add_callback_context_release(sub { ... })</source>
          <target state="translated">test2_add_callback_context_release(sub { ... })</target>
        </trans-unit>
        <trans-unit id="aea2df16d3c7e33285ec55f6615d9b53c2465fa3" translate="yes" xml:space="preserve">
          <source>test2_add_callback_exit(sub { ... })</source>
          <target state="translated">test2_add_callback_exit(sub { ... })</target>
        </trans-unit>
        <trans-unit id="bb9ebfb6d14818d123dfe9438460fe74a3d30bf9" translate="yes" xml:space="preserve">
          <source>test2_add_callback_post_load(sub { ... })</source>
          <target state="translated">test2_add_callback_post_load(sub { ... })</target>
        </trans-unit>
        <trans-unit id="9b686e08464dc28ca52122bd9eab3f26d8c76f45" translate="yes" xml:space="preserve">
          <source>test2_add_callback_pre_subtest(sub { ... })</source>
          <target state="translated">test2_add_callback_pre_subtest(sub { ... })</target>
        </trans-unit>
        <trans-unit id="3e5a9e6ee1f7fd30e87755bebfc4f4fb2367ae19" translate="yes" xml:space="preserve">
          <source>test2_add_callback_testing_done(sub { ... })</source>
          <target state="translated">test2_add_callback_testing_done(sub { ... })</target>
        </trans-unit>
        <trans-unit id="cecdb4fa16df8d66093835618f393a17dec89b1e" translate="yes" xml:space="preserve">
          <source>test2_add_uuid_via(sub { ... })</source>
          <target state="translated">test2_add_uuid_via(sub { ... })</target>
        </trans-unit>
        <trans-unit id="763ed78b82cefe6b1139da2ee565b42f901f1426" translate="yes" xml:space="preserve">
          <source>test2_formatter_add($class_or_instance)</source>
          <target state="translated">test2_formatter_add($class_or_instance)</target>
        </trans-unit>
        <trans-unit id="9245e19b55946aec5c897d7f6cd4f7b571aa0c9b" translate="yes" xml:space="preserve">
          <source>test2_formatter_set($class_or_instance)</source>
          <target state="translated">test2_formatter_set($class_or_instance)</target>
        </trans-unit>
        <trans-unit id="97ef1945ad9a6f3060d15899a5f2fff13cb44c9a" translate="yes" xml:space="preserve">
          <source>test2_ipc_add_driver($DRIVER)</source>
          <target state="translated">test2_ipc_add_driver($DRIVER)</target>
        </trans-unit>
        <trans-unit id="d7bbd99b0ffe1aadc1d1e33ddd1ba41a525dbac7" translate="yes" xml:space="preserve">
          <source>test2_ipc_disable</source>
          <target state="translated">test2_ipc_disable</target>
        </trans-unit>
        <trans-unit id="d8aa143f32829e93fec9fef602fbf994b474638f" translate="yes" xml:space="preserve">
          <source>test2_ipc_disable_polling()</source>
          <target state="translated">test2_ipc_disable_polling()</target>
        </trans-unit>
        <trans-unit id="90209d460b70fa76fe7a0154d79046477cb73fb0" translate="yes" xml:space="preserve">
          <source>test2_ipc_enable_polling()</source>
          <target state="translated">test2_ipc_enable_polling()</target>
        </trans-unit>
        <trans-unit id="637abcfcef1ef3577c1c1b103f771ad4375f70e9" translate="yes" xml:space="preserve">
          <source>test2_ipc_enable_shm()</source>
          <target state="translated">test2_ipc_enable_shm()</target>
        </trans-unit>
        <trans-unit id="b669dac22d154729f32456c9e246b21c13e6ff3d" translate="yes" xml:space="preserve">
          <source>test2_ipc_set_pending($uniq_val)</source>
          <target state="translated">test2_ipc_set_pending($uniq_val)</target>
        </trans-unit>
        <trans-unit id="bcadd6e8667e52bd98eda7e259c38e12f8a43b32" translate="yes" xml:space="preserve">
          <source>test2_ipc_set_timeout($timeout)</source>
          <target state="translated">test2_ipc_set_timeout($timeout)</target>
        </trans-unit>
        <trans-unit id="e62027fcaf013c5eec5c5261112433813bf5be06" translate="yes" xml:space="preserve">
          <source>test2_ipc_wait_disable()</source>
          <target state="translated">test2_ipc_wait_disable()</target>
        </trans-unit>
        <trans-unit id="c07fa6bd5afc779c04466c6c4c2a502f8a522ecf" translate="yes" xml:space="preserve">
          <source>test2_ipc_wait_enable()</source>
          <target state="translated">test2_ipc_wait_enable()</target>
        </trans-unit>
        <trans-unit id="89d2782dfdac11013459d35d2b9deecb9ed7dc9c" translate="yes" xml:space="preserve">
          <source>test2_no_wait($bool)</source>
          <target state="translated">test2_no_wait($bool)</target>
        </trans-unit>
        <trans-unit id="1da6c75660226f340aea912e8e79dc6d1b1d6029" translate="yes" xml:space="preserve">
          <source>test2_reset_io()</source>
          <target state="translated">test2_reset_io()</target>
        </trans-unit>
        <trans-unit id="bbd333bfc61a38e6f494623be339b5e9e04ec506" translate="yes" xml:space="preserve">
          <source>test2_set_is_end($bool)</source>
          <target state="translated">test2_set_is_end($bool)</target>
        </trans-unit>
        <trans-unit id="9c86d5d1217e275f58f283f0f2ae7ece85eecdad" translate="yes" xml:space="preserve">
          <source>test2_set_is_end()</source>
          <target state="translated">test2_set_is_end()</target>
        </trans-unit>
        <trans-unit id="abcdea9505604adb409a5d5ccd0cb809dd18e42a" translate="yes" xml:space="preserve">
          <source>test; binary files are processed with no translation whatsoever.</source>
          <target state="translated">테스트; 이진 파일은 번역없이 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="dbf46b3b2b3672cfa54306d7d661d228078932b2" translate="yes" xml:space="preserve">
          <source>test_args</source>
          <target state="translated">test_args</target>
        </trans-unit>
        <trans-unit id="3513b382c069b0fd8b3d292ba2ef971e3becdb2a" translate="yes" xml:space="preserve">
          <source>test_class</source>
          <target state="translated">test_class</target>
        </trans-unit>
        <trans-unit id="15ec08254447516f2b4218337ce8c157561b1591" translate="yes" xml:space="preserve">
          <source>test_d</source>
          <target state="translated">test_d</target>
        </trans-unit>
        <trans-unit id="0c8e61fdfe68e3b9dae2d350cc2c76fd84e3df62" translate="yes" xml:space="preserve">
          <source>test_diag</source>
          <target state="translated">test_diag</target>
        </trans-unit>
        <trans-unit id="6beff880c64255205521e50e5ff6df815137536d" translate="yes" xml:space="preserve">
          <source>test_err</source>
          <target state="translated">test_err</target>
        </trans-unit>
        <trans-unit id="fc8237d65108d185ec12737c7b5f2a70a34942d3" translate="yes" xml:space="preserve">
          <source>test_exists</source>
          <target state="translated">test_exists</target>
        </trans-unit>
        <trans-unit id="33da57b7bc9ba8f61b4bab43712b1cde88c87a92" translate="yes" xml:space="preserve">
          <source>test_f</source>
          <target state="translated">test_f</target>
        </trans-unit>
        <trans-unit id="1447d546a6c9843204f706f830f01ed12b7ee9f4" translate="yes" xml:space="preserve">
          <source>test_fail</source>
          <target state="translated">test_fail</target>
        </trans-unit>
        <trans-unit id="5ee6f0ce0a1ce6d851d79349fde0807e696b3bf3" translate="yes" xml:space="preserve">
          <source>test_harness</source>
          <target state="translated">test_harness</target>
        </trans-unit>
        <trans-unit id="595b96f7cd4d026750d9e9ebbda9499313cd2ceb" translate="yes" xml:space="preserve">
          <source>test_hosts</source>
          <target state="translated">test_hosts</target>
        </trans-unit>
        <trans-unit id="7686b3101c108f7d2c1982ef13b251d8eb31d5ce" translate="yes" xml:space="preserve">
          <source>test_names</source>
          <target state="translated">test_names</target>
        </trans-unit>
        <trans-unit id="8311564e584210dcbbde4640d240506d2629e61d" translate="yes" xml:space="preserve">
          <source>test_out</source>
          <target state="translated">test_out</target>
        </trans-unit>
        <trans-unit id="f8c408ef7c6cefacfc68116f91df0a7f5e3fa75f" translate="yes" xml:space="preserve">
          <source>test_porting</source>
          <target state="translated">test_porting</target>
        </trans-unit>
        <trans-unit id="38b498a83ccfd03504a92959540de9fd9b454285" translate="yes" xml:space="preserve">
          <source>test_report</source>
          <target state="translated">test_report</target>
        </trans-unit>
        <trans-unit id="4d233e1542ec3318b99af696019def62ae670f68" translate="yes" xml:space="preserve">
          <source>test_test</source>
          <target state="translated">test_test</target>
        </trans-unit>
        <trans-unit id="7f1ada35b851823cf91787553404eba4704dc7a4" translate="yes" xml:space="preserve">
          <source>test_via_harness</source>
          <target state="translated">test_via_harness</target>
        </trans-unit>
        <trans-unit id="a9b171c7f94a913c05f1c5ee063f91fd1010ba4a" translate="yes" xml:space="preserve">
          <source>test_via_harness (override)</source>
          <target state="translated">test_via_harness (재정의)</target>
        </trans-unit>
        <trans-unit id="3bffec6eb2d501ce6398ddc2723cd9ac30610307" translate="yes" xml:space="preserve">
          <source>test_via_script</source>
          <target state="translated">test_via_script</target>
        </trans-unit>
        <trans-unit id="20be2666bac4ddcee3ac3c5176b6f821f040f4ac" translate="yes" xml:space="preserve">
          <source>test_via_script (override)</source>
          <target state="translated">test_via_script (재정의)</target>
        </trans-unit>
        <trans-unit id="3206488df435bc6923ead2447a155e7c1f00933c" translate="yes" xml:space="preserve">
          <source>testfile.valgrind</source>
          <target state="translated">testfile.valgrind</target>
        </trans-unit>
        <trans-unit id="f331dab08889cb5be2c4087db9e2e00c6aff6695" translate="yes" xml:space="preserve">
          <source>testhGji_w.dat</source>
          <target state="translated">testhGji_w.dat</target>
        </trans-unit>
        <trans-unit id="dc724af18fbdd4e59189f5fe768a5f8311527050" translate="yes" xml:space="preserve">
          <source>testing</source>
          <target state="translated">testing</target>
        </trans-unit>
        <trans-unit id="c1bb9bde819ec6d35d0f58572f8df6e36e4c2bf3" translate="yes" xml:space="preserve">
          <source>testname.valgrind</source>
          <target state="translated">testname.valgrind</target>
        </trans-unit>
        <trans-unit id="59e66e0e48871942840a17df9ee6e297fe40f6c2" translate="yes" xml:space="preserve">
          <source>testperl.cmd</source>
          <target state="translated">testperl.cmd</target>
        </trans-unit>
        <trans-unit id="e96f8663d0844a8d17b749192ecfb428c6302f95" translate="yes" xml:space="preserve">
          <source>testrules.yml</source>
          <target state="translated">testrules.yml</target>
        </trans-unit>
        <trans-unit id="04d13fd0aa6f0197cf2c999019a607c36c81eb9f" translate="yes" xml:space="preserve">
          <source>tests</source>
          <target state="translated">tests</target>
        </trans-unit>
        <trans-unit id="4750fbd33f325b538173caab03b023a713fab522" translate="yes" xml:space="preserve">
          <source>tests $name =&amp;gt; sub { ... }</source>
          <target state="translated">테스트 $ name =&amp;gt; sub {...}</target>
        </trans-unit>
        <trans-unit id="72b963d09735ce48f8a2653272a55e968e54eea7" translate="yes" xml:space="preserve">
          <source>tests) before pushing your changes as usual:</source>
          <target state="translated">테스트) 평소와 같이 변경 사항을 푸시하기 전에 :</target>
        </trans-unit>
        <trans-unit id="d44f2bc95b0b12466d2814becdc0fd3ca48f3c86" translate="yes" xml:space="preserve">
          <source>tests.</source>
          <target state="translated">tests.</target>
        </trans-unit>
        <trans-unit id="cb38c599ee30356d6db77e68ccf1bc117b277450" translate="yes" xml:space="preserve">
          <source>tests_planned</source>
          <target state="translated">tests_planned</target>
        </trans-unit>
        <trans-unit id="0ecf6f7959a889c4bfe2bdbc45b686913b2b0137" translate="yes" xml:space="preserve">
          <source>tests_run</source>
          <target state="translated">tests_run</target>
        </trans-unit>
        <trans-unit id="381c53b73f80ba38b12ab16a309f35591b7a80f5" translate="yes" xml:space="preserve">
          <source>tet.</source>
          <target state="translated">tet.</target>
        </trans-unit>
        <trans-unit id="372ea08cab33e71c02c651dbc83a474d32c676ea" translate="yes" xml:space="preserve">
          <source>text</source>
          <target state="translated">text</target>
        </trans-unit>
        <trans-unit id="441549601c13844544e8e096a23806454251355e" translate="yes" xml:space="preserve">
          <source>text of the POD interior sequence, exactly as it appeared in the input.</source>
          <target state="translated">입력에 나타난대로 POD 내부 시퀀스의 텍스트.</target>
        </trans-unit>
        <trans-unit id="5854731dd9ff4ac55f9ae30f794b63778a1f38b3" translate="yes" xml:space="preserve">
          <source>text of the POD paragraph, exactly as it appeared in the input.</source>
          <target state="translated">입력에 나타난대로 정확하게 POD 단락의 텍스트.</target>
        </trans-unit>
        <trans-unit id="ec9e1fb1bdd5ff95f2ef0e5a4bf1f898a6f466e1" translate="yes" xml:space="preserve">
          <source>text of the POD parse-tree exactly as it appeared in the input.</source>
          <target state="translated">입력에 나타난 POD 구문 분석 트리의 텍스트</target>
        </trans-unit>
        <trans-unit id="4c95279946893e6de448e06e614d4ac86b109eed" translate="yes" xml:space="preserve">
          <source>text should ignored.</source>
          <target state="translated">텍스트는 무시해야합니다.</target>
        </trans-unit>
        <trans-unit id="277cce1b28346a5d3e6beed7b13d25596188eaa9" translate="yes" xml:space="preserve">
          <source>text will appear only as the value of the</source>
          <target state="translated">텍스트는</target>
        </trans-unit>
        <trans-unit id="cb46ca32d20cdfb81305bac97aa109b83dc1b07c" translate="yes" xml:space="preserve">
          <source>text, but</source>
          <target state="translated">텍스트이지만</target>
        </trans-unit>
        <trans-unit id="99928878118e841388df9f386a36622511ce6080" translate="yes" xml:space="preserve">
          <source>text. (This distinction may or may not be evident in the particular tree/event model implemented by the Pod parser.) For example, consider this unusual case:</source>
          <target state="translated">본문. (이러한 차이점은 포드 파서가 구현 한 특정 트리 / 이벤트 모델에서 분명하거나 분명하지 않을 수 있습니다.) 예를 들어, 다음과 같은 예외적 인 경우를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="95271a946f22c453ade18117f4cca5dc0f833cc4" translate="yes" xml:space="preserve">
          <source>text...</source>
          <target state="translated">text...</target>
        </trans-unit>
        <trans-unit id="38e9be6401e62f7d1555230d9df956fb85c2ba6e" translate="yes" xml:space="preserve">
          <source>text1</source>
          <target state="translated">text1</target>
        </trans-unit>
        <trans-unit id="8057ce4541a822035c1ef56a5b6686508928ea3b" translate="yes" xml:space="preserve">
          <source>text2</source>
          <target state="translated">text2</target>
        </trans-unit>
        <trans-unit id="9ccace0a1ad010c2a1855debb151e0bb936e66ba" translate="yes" xml:space="preserve">
          <source>th element of this array holds the offset of the</source>
          <target state="translated">이 배열의 요소는</target>
        </trans-unit>
        <trans-unit id="0ecc97d66bd161e24f5253814be739b1ade3945b" translate="yes" xml:space="preserve">
          <source>th group before the &lt;code&gt;\g{-&lt;i&gt;N&lt;/i&gt;}&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;\g{-&lt;i&gt;N&lt;/i&gt;}&lt;/code&gt; 앞의 그룹 .</target>
        </trans-unit>
        <trans-unit id="8eb3ae1a9ace25086621583ab7192613b95dc786" translate="yes" xml:space="preserve">
          <source>th innermost &lt;code&gt;( )&lt;/code&gt; group, or to the start of the string if</source>
          <target state="translated">가장 안쪽 &lt;code&gt;( )&lt;/code&gt; 그룹 또는 문자열의 시작 부분 인 경우</target>
        </trans-unit>
        <trans-unit id="2ebcfb27ee2bfc8009de717d401cdb448c047d64" translate="yes" xml:space="preserve">
          <source>th root directly by &lt;code&gt;root(z, n, k)&lt;/code&gt; , indexing starting from</source>
          <target state="translated">&lt;code&gt;root(z, n, k)&lt;/code&gt; 의해 직접 루트 , 인덱싱</target>
        </trans-unit>
        <trans-unit id="e18a7e15fc3fad76bc7670c773c9698b53734a07" translate="yes" xml:space="preserve">
          <source>th root directly by &lt;code&gt;root(z, n, k)&lt;/code&gt;, indexing starting from</source>
          <target state="translated">&lt;code&gt;root(z, n, k)&lt;/code&gt; 의한 직접 루트 , 다음에서 시작하는 인덱싱</target>
        </trans-unit>
        <trans-unit id="3aa3461c082e7dae7d60c4657a925fe45e7c519d" translate="yes" xml:space="preserve">
          <source>th root for &lt;code&gt;z = [r,t]&lt;/code&gt; is given by:</source>
          <target state="translated">&lt;code&gt;z = [r,t]&lt;/code&gt; 루트 는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="055966868aa553760505967c00a7c5d6818ef82f" translate="yes" xml:space="preserve">
          <source>th submatch, so &lt;code&gt;$+[1]&lt;/code&gt; is the offset past where &lt;code&gt;$1&lt;/code&gt; ends, &lt;code&gt;$+[2]&lt;/code&gt; the offset past where &lt;code&gt;$2&lt;/code&gt; ends, and so on. You can use &lt;code&gt;$#+&lt;/code&gt; to determine how many subgroups were in the last successful match. See the examples given for the &lt;code&gt;@-&lt;/code&gt; variable.</source>
          <target state="translated">하위 일치 항목이므로 &lt;code&gt;$+[1]&lt;/code&gt; 은 &lt;code&gt;$1&lt;/code&gt; 끝나는 오프셋 과거 , &lt;code&gt;$+[2]&lt;/code&gt; 는 &lt;code&gt;$2&lt;/code&gt; 끝나는 오프셋 과거 등입니다. &lt;code&gt;$#+&lt;/code&gt; 를 사용 하여 마지막으로 성공한 하위 그룹 수를 확인할 수 있습니다 . &lt;code&gt;@-&lt;/code&gt; 변수에 제공된 예제를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b4d58221efef7dcc072ec5d5895f2fe6ca83de0e" translate="yes" xml:space="preserve">
          <source>th submatch, so &lt;code&gt;$-[1]&lt;/code&gt; is the offset where &lt;code&gt;$1&lt;/code&gt; begins, &lt;code&gt;$-[2]&lt;/code&gt; the offset where &lt;code&gt;$2&lt;/code&gt; begins, and so on.</source>
          <target state="translated">하위 일치이므로 &lt;code&gt;$-[1]&lt;/code&gt; 은 &lt;code&gt;$1&lt;/code&gt; 시작 되는 오프셋 , &lt;code&gt;$-[2]&lt;/code&gt; 는 &lt;code&gt;$2&lt;/code&gt; 가 시작 되는 오프셋 등입니다.</target>
        </trans-unit>
        <trans-unit id="b1fbf7c34837b574b0c78077af027bd61f3e43b9" translate="yes" xml:space="preserve">
          <source>th subpattern later in the pattern using the metacharacter \</source>
          <target state="translated">메타 문자를 사용하여 패턴에서 나중에 하위 패턴 \</target>
        </trans-unit>
        <trans-unit id="993c608b59dc5dfe8f8f24f36d08ea885a7e97f7" translate="yes" xml:space="preserve">
          <source>th time you access it. When a data item is looked up afresh, its number of uses is reset.</source>
          <target state="translated">당신이 그것에 접근하는 시간. 데이터 항목을 새로 조회하면 사용 횟수가 재설정됩니다.</target>
        </trans-unit>
        <trans-unit id="d820aa5f8750fdde33200083b0702a32578a6c95" translate="yes" xml:space="preserve">
          <source>than</source>
          <target state="translated">than</target>
        </trans-unit>
        <trans-unit id="f8d56f0d78517ccac80725a473ad26543c1149da" translate="yes" xml:space="preserve">
          <source>than the current value of $^F (by default 2 for &lt;code&gt;STDERR&lt;/code&gt; ). See &lt;a href=&quot;../perlvar#%24%5eF&quot;&gt;$^F in perlvar&lt;/a&gt;.</source>
          <target state="translated">현재 값 $ ^ F보다 (기본적으로 &lt;code&gt;STDERR&lt;/code&gt; 의 경우 2 ). &lt;a href=&quot;../perlvar#%24%5eF&quot;&gt;perlvar의 $ ^ F를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="37e161466a88c9a41a96b5e1a785469a7cc68706" translate="yes" xml:space="preserve">
          <source>than the current value of $^F (by default 2 for &lt;code&gt;STDERR&lt;/code&gt; ). See &lt;a href=&quot;perlvar#%24%5eF&quot;&gt;$^F in perlvar&lt;/a&gt;.</source>
          <target state="translated">현재 값 $ ^ F보다 (기본적으로 &lt;code&gt;STDERR&lt;/code&gt; 의 경우 2 ). &lt;a href=&quot;perlvar#%24%5eF&quot;&gt;perlvar의 $ ^ F를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ef86ed95e8128b88ef9711875ccfb123406ee80f" translate="yes" xml:space="preserve">
          <source>than the current value of &lt;a href=&quot;perlvar#%24%5EF&quot;&gt;&lt;code&gt;$^F&lt;/code&gt;&lt;/a&gt; (by default 2 for &lt;code&gt;STDERR&lt;/code&gt;). See &lt;a href=&quot;perlvar#%24%5EF&quot;&gt;&quot;$^F&quot; in perlvar&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;perlvar#%24%5EF&quot;&gt; &lt;code&gt;$^F&lt;/code&gt; &lt;/a&gt; 의 현재 값보다 (기본적으로 &lt;code&gt;STDERR&lt;/code&gt; 의 경우 2 ). &lt;a href=&quot;perlvar#%24%5EF&quot;&gt;perlvar의 &quot;$ ^ F&quot;를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="8ea263d2427ffcfcca02154008ed63f280ffe403" translate="yes" xml:space="preserve">
          <source>than the indentation level, followed by one copy of</source>
          <target state="translated">들여 쓰기 레벨보다</target>
        </trans-unit>
        <trans-unit id="33b82201081ec7c438cb5d9a36cd72bcb153050b" translate="yes" xml:space="preserve">
          <source>that</source>
          <target state="translated">that</target>
        </trans-unit>
        <trans-unit id="cf8d4f20403fb01bbebeb71f4878c662ca8b2922" translate="yes" xml:space="preserve">
          <source>that Mark Jason Dominus employs in his paper on &quot;Rx&quot; ([1] in &lt;a href=&quot;#REFERENCES&quot;&gt;&quot;REFERENCES&quot;&lt;/a&gt;).</source>
          <target state="translated">Mark Jason Dominus가 &quot;Rx&quot;( &lt;a href=&quot;#REFERENCES&quot;&gt;&quot;REFERENCES&quot;의&lt;/a&gt; [1])에 대한 논문에서 사용 합니다.</target>
        </trans-unit>
        <trans-unit id="712f902c58bdfbf92dc3035820fbc97dac3d7f9c" translate="yes" xml:space="preserve">
          <source>that Mark Jason Dominus employs in his paper on &quot;Rx&quot; ([1] in &lt;a href=&quot;#REFERENCES&quot;&gt;REFERENCES&lt;/a&gt;).</source>
          <target state="translated">마크 제이슨 도미 누스는 &quot;Rx&quot;( &lt;a href=&quot;#REFERENCES&quot;&gt;참조&lt;/a&gt; 1의 [1])에 관한 논문에서 사용하고있다 .</target>
        </trans-unit>
        <trans-unit id="2f2adb1e56aab7b81143942262fba43a45e15f39" translate="yes" xml:space="preserve">
          <source>that a collator uses should be identified by a combination of return values from &lt;code&gt;getlocale&lt;/code&gt; and &lt;code&gt;locale_version&lt;/code&gt;.</source>
          <target state="translated">콜 레이터가 사용하는 것은 &lt;code&gt;getlocale&lt;/code&gt; 및 &lt;code&gt;locale_version&lt;/code&gt; 의 반환 값 조합으로 식별되어야합니다 .</target>
        </trans-unit>
        <trans-unit id="1f328f55d9480211c4dfcf10b3a4366d300359a9" translate="yes" xml:space="preserve">
          <source>that a hint be used by prefixing an exclamation mark to the start of the subroutine name. A lone exclamation mark indicates that</source>
          <target state="translated">서브 루틴 이름의 시작 부분에 느낌표를 접두사로 붙이면 힌트를 사용할 수 있습니다. 외로운 느낌표는 다음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="a674914f8544983a679eb630e65e77f84c755863" translate="yes" xml:space="preserve">
          <source>that are attached to the currently-compiling CV. A slab is a chunk of allocated memory. New ops are allocated as regions of the slab. If the slab fills up, a new one is created (and linked from the previous one). When an error occurs and the CV is freed, any ops remaining are freed.</source>
          <target state="translated">현재 컴파일중인 CV에 첨부되어 있습니다. 슬래브는 할당 된 메모리 덩어리입니다. 새 작업은 슬래브의 영역으로 할당됩니다. 슬래브가 채워지면 새 슬래브가 작성되고 이전 슬래브에서 링크됩니다. 오류가 발생하고 CV가 해제되면 남은 모든 작업이 해제됩니다.</target>
        </trans-unit>
        <trans-unit id="c9c5244833fb206b954415ab3f54654400b7eb3c" translate="yes" xml:space="preserve">
          <source>that are not available in older versions of perl. The problem is that the version number for Fcntl is the same in perl 5.6.0 and in 5.005_03 even though they are different versions.</source>
          <target state="translated">이전 버전의 perl에서는 사용할 수 없습니다. 문제는 Fcntl의 버전 번호가 버전이 다르더라도 perl 5.6.0 및 5.005_03에서 동일하다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="9eee5aaf9d09fc3579f3f15ad3d8b52f452536af" translate="yes" xml:space="preserve">
          <source>that are not in the list of</source>
          <target state="translated">그 목록에없는</target>
        </trans-unit>
        <trans-unit id="0cf7d706e01a20eba1084de4b11365bb9dc0cc79" translate="yes" xml:space="preserve">
          <source>that behaviour. For example, the &lt;code&gt;CORE::open&lt;/code&gt; subroutine does &lt;code&gt;:file&lt;/code&gt;, &lt;code&gt;:io&lt;/code&gt; and &lt;code&gt;:all&lt;/code&gt;.</source>
          <target state="translated">그 행동. 예를 들어, &lt;code&gt;CORE::open&lt;/code&gt; 서브 루틴은 &lt;code&gt;:file&lt;/code&gt; , &lt;code&gt;:io&lt;/code&gt; 및 &lt;code&gt;:all&lt;/code&gt; 을 수행 합니다.</target>
        </trans-unit>
        <trans-unit id="97950f338e4ed29ff49961cf2229ebd2cb383e46" translate="yes" xml:space="preserve">
          <source>that can also be run as a Perl script. To generate</source>
          <target state="translated">그것은 또한 Perl 스크립트로 실행될 수 있습니다. 생성</target>
        </trans-unit>
        <trans-unit id="29212c899911ccfcbbe5cbf6f831e9088556a7bc" translate="yes" xml:space="preserve">
          <source>that comes with the package, if that</source>
          <target state="translated">패키지와 함께 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="4090dd20c552b4219c34c03221f437018fa823a5" translate="yes" xml:space="preserve">
          <source>that contains all the perlguts necessary to push the two arguments into</source>
          <target state="translated">여기에는 두 가지 주장을 푸는 데 필요한 모든 perlgut가 들어 있습니다</target>
        </trans-unit>
        <trans-unit id="790a9136b7f6543cf6261b9f3d3855c475910d3b" translate="yes" xml:space="preserve">
          <source>that doesn't have a correspondence in</source>
          <target state="translated">서신이없는</target>
        </trans-unit>
        <trans-unit id="d9a7d75f21aba5d2b3adbb588b8f62a714350deb" translate="yes" xml:space="preserve">
          <source>that function is called and is passed those OPTIONS (split on commas). It should return a sub ref to the main compilation function. After the user's program is loaded and parsed, that returned sub ref is invoked which can then go ahead and do the compilation, usually by making use of the &lt;code&gt;B&lt;/code&gt; module's functionality.</source>
          <target state="translated">해당 함수가 호출되고 해당 옵션 (쉼표에 쪼개짐)이 전달됩니다. 기본 컴파일 함수에 대한 하위 참조를 반환해야합니다. 사용자의 프로그램이로드되고 파싱 된 후, 반환 된 sub ref가 호출되어 보통 &lt;code&gt;B&lt;/code&gt; 모듈의 기능 을 사용하여 컴파일을 수행 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="eabd0246b05848472d07cdd46076e95d94e5464f" translate="yes" xml:space="preserve">
          <source>that indicate how prerequisites should be resolved.</source>
          <target state="translated">전제 조건을 해결하는 방법을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="49f6845d8cc6762655e9d8d5279b965b50bc34d9" translate="yes" xml:space="preserve">
          <source>that is the single character at &lt;code&gt;0xABC&lt;/code&gt; . Under &lt;code&gt;'strict'&lt;/code&gt; it is an error to not follow &lt;code&gt;\x&lt;/code&gt; with exactly two hex digits. When not under &lt;code&gt;'strict'&lt;/code&gt; a warning is generated if there is only one hex digit, and no warning is raised if there are more than two.</source>
          <target state="translated">그것은 &lt;code&gt;0xABC&lt;/code&gt; 의 단일 문자 입니다. 에서 &lt;code&gt;'strict'&lt;/code&gt; 이 따르지하면 오류가 &lt;code&gt;\x&lt;/code&gt; 와 정확히 두 개의 16 진수를. &lt;code&gt;'strict'&lt;/code&gt; 가 아닌 경우 16 진 숫자가 하나만 있으면 경고가 생성되고 두 개 이상이면 경고가 발생하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3f41e183e1bcbe93d658fa9db8acc24987456246" translate="yes" xml:space="preserve">
          <source>that is the single character at &lt;code&gt;0xABC&lt;/code&gt;. Under &lt;code&gt;'strict'&lt;/code&gt; it is an error to not follow &lt;code&gt;\x&lt;/code&gt; with exactly two hex digits. When not under &lt;code&gt;'strict'&lt;/code&gt; a warning is generated if there is only one hex digit, and no warning is raised if there are more than two.</source>
          <target state="translated">그것은 &lt;code&gt;0xABC&lt;/code&gt; 의 단일 문자 입니다. 에서 &lt;code&gt;'strict'&lt;/code&gt; 이 따르지하면 오류가 &lt;code&gt;\x&lt;/code&gt; 와 정확히 두 개의 16 진수를. &lt;code&gt;'strict'&lt;/code&gt; 이 아닌 경우 16 진수가 하나만 있으면 경고가 생성되고 두 개 이상이면 경고가 발생하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e4f20743e591fca32ea867ef45df47d1193856a5" translate="yes" xml:space="preserve">
          <source>that is to be analyzed and use the permissible values on the left hand side of the matching operations. As an example for this somewhat paradoxical situation, let's assume that our input contains a command verb which should match one out of a set of available command verbs, with the additional twist that commands may be abbreviated as long as the given string is unique. The program below demonstrates the basic algorithm.</source>
          <target state="translated">즉, 분석하고 일치하는 조작의 왼쪽에서 허용 가능한 값을 사용하십시오. 다소 역설적 인 상황의 예로, 입력에 사용 가능한 명령 동사 세트 중 하나와 일치해야하는 명령 동사가 포함되어 있고 주어진 문자열이 고유 한 한 명령이 약어 화 될 수 있다는 추가 왜곡이 있다고 가정 해 봅시다. 아래 프로그램은 기본 알고리즘을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="64e4455297c586a9db29d5096ca7b93d57de5fe5" translate="yes" xml:space="preserve">
          <source>that is, the character whose code point value is &lt;code&gt;0xAB&lt;/code&gt; , followed by the letter &lt;code&gt;C&lt;/code&gt; . But since &lt;code&gt;C&lt;/code&gt; is a a hex digit, there is a reasonable chance that the intent was</source>
          <target state="translated">즉, 코드 포인트 값이 &lt;code&gt;0xAB&lt;/code&gt; 인 문자 뒤에 문자 &lt;code&gt;C&lt;/code&gt; 가 있습니다. 그러나 &lt;code&gt;C&lt;/code&gt; 는 16 진수 이므로 의도가</target>
        </trans-unit>
        <trans-unit id="3ee63917b9a06a5ddca249ce8a8aeedd6f970968" translate="yes" xml:space="preserve">
          <source>that is, the character whose code point value is &lt;code&gt;0xAB&lt;/code&gt;, followed by the letter &lt;code&gt;C&lt;/code&gt;. But since &lt;code&gt;C&lt;/code&gt; is a hex digit, there is a reasonable chance that the intent was</source>
          <target state="translated">즉, 코드 포인트 값이 &lt;code&gt;0xAB&lt;/code&gt; 이고 뒤에 문자 &lt;code&gt;C&lt;/code&gt; 가 오는 문자 입니다. 그러나 &lt;code&gt;C&lt;/code&gt; 는 16 진수 이므로 의도가</target>
        </trans-unit>
        <trans-unit id="1bc56929a849385fc4d0db6d314427d5b8dbddcd" translate="yes" xml:space="preserve">
          <source>that it was compiled in the package &lt;code&gt;main&lt;/code&gt; ;</source>
          <target state="translated">패키지 &lt;code&gt;main&lt;/code&gt; 에 컴파일되었다 ;</target>
        </trans-unit>
        <trans-unit id="5e309b6abcbd8bc24969b50d8151d5151c0c9943" translate="yes" xml:space="preserve">
          <source>that it was compiled in the package &lt;code&gt;main&lt;/code&gt;;</source>
          <target state="translated">그것은 &lt;code&gt;main&lt;/code&gt; 패키지에서 컴파일되었다 .</target>
        </trans-unit>
        <trans-unit id="7fae6929e6ad295d23ed329c3477149c19ac13b1" translate="yes" xml:space="preserve">
          <source>that positionally corresponds to its mate in</source>
          <target state="translated">위치 적으로 해당 메이트에 해당하는</target>
        </trans-unit>
        <trans-unit id="5106349904c16b5fab53fb5e99dc60b9956ff5a3" translate="yes" xml:space="preserve">
          <source>that prints:</source>
          <target state="translated">그 인쇄 :</target>
        </trans-unit>
        <trans-unit id="2147c04b3cf47c1027e8b48decbbe54f8d12d79d" translate="yes" xml:space="preserve">
          <source>that specifies the value&amp;rsquo;s &lt;b&gt;offset&lt;/b&gt; in the sequence.</source>
          <target state="translated">시퀀스에서 값의 &lt;b&gt;오프셋&lt;/b&gt; 을 지정합니다 .</target>
        </trans-unit>
        <trans-unit id="9c0471ac111ba85b51a34c13abf7375fbf05cdbf" translate="yes" xml:space="preserve">
          <source>that superordinates of $lang1 are mutually intelligible with $lang1. Consider this carefully.</source>
          <target state="translated">$ lang1의 상위 항목은 $ lang1과 상호 이해하기 쉽습니다. 이것을 신중하게 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="2def5546b6eb47219f92a8fa7761c3e0fa1be7b9" translate="yes" xml:space="preserve">
          <source>that the STRING holds only well-formed UTF-8. Returns the previous state of the UTF8 flag (so please don't treat the return value as indicating success or failure), or &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; if</source>
          <target state="translated">STRING은 올바른 형식의 UTF-8 만 보유합니다. 반환은 UTF8 플래그의 이전 상태 (그래서 성공 또는 실패를 나타내는 등의 반환 값을 취급하지 마십시오), 또는 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 경우</target>
        </trans-unit>
        <trans-unit id="98bec115d9d5cfbf203741b8b69ceeaefa5668a0" translate="yes" xml:space="preserve">
          <source>that the STRING holds only well-formed UTF-8. Returns the previous state of the UTF8 flag (so please don't treat the return value as indicating success or failure), or &lt;code&gt;undef&lt;/code&gt; if</source>
          <target state="translated">STRING은 올바른 형식의 UTF-8 만 보유하고 있습니다. 반환은 UTF8 플래그의 이전 상태 (그래서 성공 또는 실패를 나타내는 등의 반환 값을 취급하지 마십시오), 또는 &lt;code&gt;undef&lt;/code&gt; 경우</target>
        </trans-unit>
        <trans-unit id="9330bf46ed7a31ad2571adf2313ea72910827fa1" translate="yes" xml:space="preserve">
          <source>that the parent has a &lt;code&gt;&amp;amp;&lt;/code&gt; pad slot pointing back to us. In this case, we set the &lt;code&gt;CvWEAKOUTSIDE&lt;/code&gt; flag in the child. This allows us to determine under what circumstances we should decrement the refcount of the parent when freeing the child.</source>
          <target state="translated">부모는 우리를 가리키는 &lt;code&gt;&amp;amp;&lt;/code&gt; 패드 슬롯을 가지고 있습니다. 이 경우 자식에서 &lt;code&gt;CvWEAKOUTSIDE&lt;/code&gt; 플래그를 설정합니다 . 이를 통해 우리는 자녀를 해방시킬 때 어떤 상황에서 부모의 체면을 감소시켜야하는지 결정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c4b9eedbce74c74b8ab418c048257b665e5984fc" translate="yes" xml:space="preserve">
          <source>that this package generates, if that</source>
          <target state="translated">이 패키지가 생성하는 경우</target>
        </trans-unit>
        <trans-unit id="eaf21ed55aa93ffd795263ddba3f077b7975f18c" translate="yes" xml:space="preserve">
          <source>that will almost never be a problem, but if you install a filtering subroutine by passing it directly to the &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; Filter::Simple&lt;/code&gt; statement:</source>
          <target state="translated">그것은 거의 문제가되지 않지만, 필터링 서브 루틴을 &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; Filter::Simple&lt;/code&gt; 하여 직접 Filter :: Simple 문을 사용하여 필터링 하는 경우 :</target>
        </trans-unit>
        <trans-unit id="d257c1b1af18f3aa508e27763eda712450f191e5" translate="yes" xml:space="preserve">
          <source>that will almost never be a problem, but if you install a filtering subroutine by passing it directly to the &lt;code&gt;use Filter::Simple&lt;/code&gt; statement:</source>
          <target state="translated">거의 문제가되지는 않지만 &lt;code&gt;use Filter::Simple&lt;/code&gt; 문에 직접 전달하여 필터링 서브 루틴을 설치하는 경우 :</target>
        </trans-unit>
        <trans-unit id="43ff8a3a166a462614bdb65ab39d8ce2844e2122" translate="yes" xml:space="preserve">
          <source>that will list all current DOS devices and their &quot;native&quot; definition. Again, note that this doesn't work under Win95 nor Win98.</source>
          <target state="translated">현재 모든 DOS 장치와 &quot;기본&quot;정의를 나열합니다. 다시 말하지만 이것은 Win95 나 Win98에서는 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="832edde3d5e2767ac60905e79c547b9f88b893ac" translate="yes" xml:space="preserve">
          <source>that you can find (e.g. by generating it with the latest &lt;code&gt;Devel::PPPort&lt;/code&gt; release from CPAN), copy it into your project, adjust your project to use it, and distribute the header along with your module.</source>
          <target state="translated">(예 : CPAN 의 최신 &lt;code&gt;Devel::PPPort&lt;/code&gt; 릴리스로 생성하여) 프로젝트에 복사하고 프로젝트를 사용하도록 조정 한 다음 모듈과 함께 헤더를 배포하십시오.</target>
        </trans-unit>
        <trans-unit id="05f3b82a1d8918c70b442c0b10493178addfca25" translate="yes" xml:space="preserve">
          <source>that you can load using either &lt;a href=&quot;prove&quot;&gt;prove&lt;/a&gt; or &lt;a href=&quot;Module::Build&quot;&gt;Module::Build&lt;/a&gt;; there are many examples to base mine on. For more details see &lt;a href=&quot;App::Prove&quot;&gt;App::Prove&lt;/a&gt;, &lt;a href=&quot;TAP::Parser::SourceHandler&quot;&gt;TAP::Parser::SourceHandler&lt;/a&gt;, and &lt;a href=&quot;TAP::Formatter::Base&quot;&gt;TAP::Formatter::Base&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;prove&quot;&gt;Prove&lt;/a&gt; 또는 &lt;a href=&quot;Module::Build&quot;&gt;Module :: Build를&lt;/a&gt; 사용하여로드 할 수 있습니다 . 내 기초가 될 많은 예가 있습니다. 자세한 내용은 &lt;a href=&quot;App::Prove&quot;&gt;App :: Prove&lt;/a&gt; , &lt;a href=&quot;TAP::Parser::SourceHandler&quot;&gt;TAP :: Parser :: SourceHandler&lt;/a&gt; 및 &lt;a href=&quot;TAP::Formatter::Base&quot;&gt;TAP :: Formatter :: Base를 참조하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="bbccdf2efb33b52e6c9d0a14dd70b2d415fbea6e" translate="yes" xml:space="preserve">
          <source>the</source>
          <target state="translated">the</target>
        </trans-unit>
        <trans-unit id="43ee0a4d7bd7571e12e2aa5bc32a8deb5eb6eeac" translate="yes" xml:space="preserve">
          <source>the &quot;Artistic License&quot; which comes with this Kit.</source>
          <target state="translated">이 키트와 함께 제공되는 &quot;예술적 라이센스&quot;.</target>
        </trans-unit>
        <trans-unit id="3cae9ee537196ab46dc21efa7928e411032b7c0e" translate="yes" xml:space="preserve">
          <source>the &lt;a href=&quot;local::lib&quot;&gt;local::lib&lt;/a&gt; module:</source>
          <target state="translated">&lt;a href=&quot;local::lib&quot;&gt;지역 :: lib 디렉토리의&lt;/a&gt; 모듈 :</target>
        </trans-unit>
        <trans-unit id="fb4c660642c3786a6682f598d0a3ab6b2413a9c7" translate="yes" xml:space="preserve">
          <source>the &lt;b&gt;preprocess_paragraph()&lt;/b&gt; method. After all (possibly preprocessed) lines in a paragraph have been assembled together and either it has been determined that the paragraph is part of the POD documentation from one of the selected sections or the &lt;code&gt;-want_nonPODs&lt;/code&gt; option is true, then &lt;b&gt;preprocess_paragraph()&lt;/b&gt; is invoked.</source>
          <target state="translated">&lt;b&gt;preprocess_paragraph ()&lt;/b&gt; 방법. 단락의 모든 (전처리 된) 행이 함께 어셈블되고 해당 단락이 선택된 섹션 중 하나에서 POD 문서의 일부이거나 &lt;code&gt;-want_nonPODs&lt;/code&gt; 옵션이 true 인 것으로 판별 되면 &lt;b&gt;preprocess_paragraph ()&lt;/b&gt; 가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="d015472d9b89357d87fe6b5b8a3955a70873fd98" translate="yes" xml:space="preserve">
          <source>the &lt;b&gt;preprocess_paragraph()&lt;/b&gt; method. After all (possibly preprocessed) lines in a paragraph have been assembled together and it has been determined that the paragraph is part of the POD documentation from one of the selected sections, then &lt;b&gt;preprocess_paragraph()&lt;/b&gt; is invoked.</source>
          <target state="translated">&lt;b&gt;preprocess_paragraph ()&lt;/b&gt; 방법. 단락의 모든 (전처리 된) 행이 함께 모여 선택된 섹션 중 하나에서 해당 단락이 POD 문서의 일부인 것으로 확인되면 &lt;b&gt;preprocess_paragraph ()&lt;/b&gt; 가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="5ee62fb8c1e088844615dfe6a08ffc91df4dd448" translate="yes" xml:space="preserve">
          <source>the &lt;code&gt;$1&lt;/code&gt;, &lt;code&gt;$2&lt;/code&gt;,... associated with the rightmost closing parenthesis used in the match).</source>
          <target state="translated">&lt;code&gt;$1&lt;/code&gt; , &lt;code&gt;$2&lt;/code&gt; 경기에서 사용되는 가장 오른쪽에 닫는 괄호와 관련, ...).</target>
        </trans-unit>
        <trans-unit id="6099028da64d1cf4076b26d62d6ea2a270693105" translate="yes" xml:space="preserve">
          <source>the &lt;code&gt;(*THEN)&lt;/code&gt; verb will backtrack and try</source>
          <target state="translated">&lt;code&gt;(*THEN)&lt;/code&gt; 동사는 역 추적 및 시도 할 것이다</target>
        </trans-unit>
        <trans-unit id="1ecf3d6a18b09451ed79cad0f9c2d47da85bdc74" translate="yes" xml:space="preserve">
          <source>the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; statement is finished.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 문이 완료됩니다.</target>
        </trans-unit>
        <trans-unit id="e3bb843654f3ee5433a3fce4b58e8c2a612c5951" translate="yes" xml:space="preserve">
          <source>the &lt;code&gt;PERL5LIB&lt;/code&gt; environment variable</source>
          <target state="translated">&lt;code&gt;PERL5LIB&lt;/code&gt; 의 환경 변수</target>
        </trans-unit>
        <trans-unit id="ebbb9b76289c3b1f85f3896ae9b329a9251122a3" translate="yes" xml:space="preserve">
          <source>the &lt;code&gt;PERLLIB&lt;/code&gt; environment variable</source>
          <target state="translated">&lt;code&gt;PERLLIB&lt;/code&gt; 의 환경 변수</target>
        </trans-unit>
        <trans-unit id="9da4ea008b0d3e45aac714865e3efcab30e81afa" translate="yes" xml:space="preserve">
          <source>the &lt;code&gt;SvPV&lt;/code&gt; call), and act accordingly:</source>
          <target state="translated">&lt;code&gt;SvPV&lt;/code&gt; 에 따라 전화), 행동 :</target>
        </trans-unit>
        <trans-unit id="48b242ae26b6c98b698e4993b7d40f01a95adf17" translate="yes" xml:space="preserve">
          <source>the &lt;code&gt;autodie::hints::provider&lt;/code&gt; role. This can be done by writing your own &lt;code&gt;DOES&lt;/code&gt; method, using a system such as &lt;code&gt;Class::DOES&lt;/code&gt; to handle the heavy-lifting for you, or declaring a &lt;code&gt;%DOES&lt;/code&gt; package variable with a &lt;code&gt;autodie::hints::provider&lt;/code&gt; key and a corresponding true value.</source>
          <target state="translated">&lt;code&gt;autodie::hints::provider&lt;/code&gt; 역할. 이것은 자신의 &lt;code&gt;DOES&lt;/code&gt; 메서드 를 작성하거나 &lt;code&gt;Class::DOES&lt;/code&gt; 와 같은 시스템 을 사용하여 무거운 작업을 처리하거나 &lt;code&gt;autodie::hints::provider&lt;/code&gt; 키와 해당 true 로 &lt;code&gt;%DOES&lt;/code&gt; 패키지 변수를 선언하여 수행 할 수 있습니다. 값.</target>
        </trans-unit>
        <trans-unit id="ddf75ed2ef030e8b21773cbe257ff0db3d85d56e" translate="yes" xml:space="preserve">
          <source>the &lt;code&gt;lib&lt;/code&gt; pragma:</source>
          <target state="translated">&lt;code&gt;lib&lt;/code&gt; 프라그 :</target>
        </trans-unit>
        <trans-unit id="784e76dddbbecf0d4890f2c51b5dc7f078e02a4a" translate="yes" xml:space="preserve">
          <source>the &lt;code&gt;perl -Idir&lt;/code&gt; command line flag</source>
          <target state="translated">&lt;code&gt;perl -Idir&lt;/code&gt; 명령 줄 플래그</target>
        </trans-unit>
        <trans-unit id="5dd0cd743954000fe899f9b9ea4dc6f27d4db45e" translate="yes" xml:space="preserve">
          <source>the &lt;code&gt;use&lt;/code&gt; statement is finished.</source>
          <target state="translated">&lt;code&gt;use&lt;/code&gt; 문이 완료됩니다.</target>
        </trans-unit>
        <trans-unit id="d3ee9bbc572a709eb30d7bbdde11096841bab10e" translate="yes" xml:space="preserve">
          <source>the &lt;code&gt;warnings::warnif&lt;/code&gt; function will detect this and die after displaying the warning message.</source>
          <target state="translated">&lt;code&gt;warnings::warnif&lt;/code&gt; 기능이이를 감지하고 경고 메시지를 표시 한 후 죽을 것이다.</target>
        </trans-unit>
        <trans-unit id="b7fd606bf49920275dd9bb325eb118eb6f011956" translate="yes" xml:space="preserve">
          <source>the GNU General Public License as published by the Free Software Foundation; either version 1, or (at your option) any later version, or</source>
          <target state="translated">Free Software Foundation에서 발행 한 GNU General Public License; 버전 1 또는 (귀하의 선택에 따라) 이후 버전 또는</target>
        </trans-unit>
        <trans-unit id="563f5302e5165ea55a9937aa65686bd1f41942a9" translate="yes" xml:space="preserve">
          <source>the PERL5LIB environment variable</source>
          <target state="translated">PERL5LIB 환경 변수</target>
        </trans-unit>
        <trans-unit id="f3652d44b9e6e8459b06c2b8eef2cad23e4ff961" translate="yes" xml:space="preserve">
          <source>the PERL5OPT environment variable</source>
          <target state="translated">PERL5OPT 환경 변수</target>
        </trans-unit>
        <trans-unit id="5c42b113d5039ee22489d974cb36f9a7666caa3f" translate="yes" xml:space="preserve">
          <source>the UTF8 flag</source>
          <target state="translated">UTF8 플래그</target>
        </trans-unit>
        <trans-unit id="ea839584ddb420310c9f3ec76a311a74c5cd61a6" translate="yes" xml:space="preserve">
          <source>the Unicode Standard</source>
          <target state="translated">유니 코드 표준</target>
        </trans-unit>
        <trans-unit id="35fcc443e2d015d49e54156560cccc0fe8aa8232" translate="yes" xml:space="preserve">
          <source>the XSUBs are made accessible from Perl</source>
          <target state="translated">XSUB는 Perl에서 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d8d781c395f2b10a1ab0f9dd5d80819da9e7f0c0" translate="yes" xml:space="preserve">
          <source>the absolute path to the file</source>
          <target state="translated">파일의 절대 경로</target>
        </trans-unit>
        <trans-unit id="59b69eb80989a1f9e7b09d9edab871ebd857e043" translate="yes" xml:space="preserve">
          <source>the access time stamp from t2 need not be greater-than the modify time stamp from t1: it may be equal or</source>
          <target state="translated">t2의 액세스 타임 스탬프는 t1의 수정 타임 스탬프보다 클 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="31ec033d4119bfbdee88e6c35979bdf5b199fb26" translate="yes" xml:space="preserve">
          <source>the actual open occurs, whether that be via &lt;code&gt;OPEN&lt;/code&gt; , &lt;code&gt;SYSOPEN&lt;/code&gt; , &lt;code&gt;FDOPEN&lt;/code&gt; or by letting a lower layer do the open.</source>
          <target state="translated">실제 열기는 &lt;code&gt;OPEN&lt;/code&gt; , &lt;code&gt;SYSOPEN&lt;/code&gt; , &lt;code&gt;FDOPEN&lt;/code&gt; 을 통해 또는 하위 계층에서 열기를 수행하도록합니다.</target>
        </trans-unit>
        <trans-unit id="7f9c419328af75394034fb970890b002b3a692ef" translate="yes" xml:space="preserve">
          <source>the actual open occurs, whether that be via &lt;code&gt;OPEN&lt;/code&gt;, &lt;code&gt;SYSOPEN&lt;/code&gt;, &lt;code&gt;FDOPEN&lt;/code&gt; or by letting a lower layer do the open.</source>
          <target state="translated">&lt;code&gt;OPEN&lt;/code&gt; , &lt;code&gt;SYSOPEN&lt;/code&gt; , &lt;code&gt;FDOPEN&lt;/code&gt; 을 통해 또는 하위 계층이 열리도록 하여 실제 열림이 발생합니다 .</target>
        </trans-unit>
        <trans-unit id="61f80c2f1cd841c0f568a34a400477ec514d3d76" translate="yes" xml:space="preserve">
          <source>the actually executed command is</source>
          <target state="translated">실제로 실행되는 명령은</target>
        </trans-unit>
        <trans-unit id="11c6e5f1977cc3206ae0e58800729e6f410a3e7c" translate="yes" xml:space="preserve">
          <source>the address, not the string!</source>
          <target state="translated">문자열이 아닌 주소!</target>
        </trans-unit>
        <trans-unit id="fd3d54ca662c0c2684de323985f811bec22bd1c7" translate="yes" xml:space="preserve">
          <source>the applications in the system, this means a complete unpredictability of floating point flags on systems using such HOOK DLLs. E.g.,</source>
          <target state="translated">시스템의 응용 프로그램은 이러한 HOOK DLL을 사용하는 시스템에서 부동 소수점 플래그를 완전히 예측할 수 없음을 의미합니다. 예 :</target>
        </trans-unit>
        <trans-unit id="05f3d9ddc3900af01143c7b2a3e5153aabb90af6" translate="yes" xml:space="preserve">
          <source>the arguments, but the signature variables get</source>
          <target state="translated">인수이지만 서명 변수는</target>
        </trans-unit>
        <trans-unit id="f4e158dd3c24f0129db3d82bff02272453579fe5" translate="yes" xml:space="preserve">
          <source>the bit-oriented &lt;code&gt;&lt;a href=&quot;functions/vec&quot;&gt;vec&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">비트 지향 &lt;code&gt;&lt;a href=&quot;functions/vec&quot;&gt;vec&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1750a1c019ccbead720af625d9055fb08de4c09e" translate="yes" xml:space="preserve">
          <source>the bit-oriented &lt;code&gt;vec&lt;/code&gt;</source>
          <target state="translated">비트 지향 &lt;code&gt;vec&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="44783b99ba624e2dd48d49637548b64060361a97" translate="yes" xml:space="preserve">
          <source>the block</source>
          <target state="translated">블록</target>
        </trans-unit>
        <trans-unit id="542b55c7fb7ff0a1d714925fc7ac958077c6109e" translate="yes" xml:space="preserve">
          <source>the block of text for the a POD paragraph</source>
          <target state="translated">POD 단락의 텍스트 블록</target>
        </trans-unit>
        <trans-unit id="aeeab916789b5b521be02e67178d8a43feaa0e51" translate="yes" xml:space="preserve">
          <source>the block of text for the verbatim paragraph</source>
          <target state="translated">완전 단락의 텍스트 블록</target>
        </trans-unit>
        <trans-unit id="c7bac64afd3313d8818026799b8430d1c87920d4" translate="yes" xml:space="preserve">
          <source>the byte ordering: whether the first byte is the least or most significant byte (or: little-endian or big-endian, respectively).</source>
          <target state="translated">바이트 순서 : 첫 번째 바이트가 가장 작은 바이트인지 또는 가장 중요한 바이트인지 (또는 각각 리틀 엔디안 또는 빅 엔디안)</target>
        </trans-unit>
        <trans-unit id="c938f5030b0fa62c0dd034b19c1afbd25a5be589" translate="yes" xml:space="preserve">
          <source>the byte-oriented &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt;/&lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt;&lt;code&gt;&quot;C&quot;&lt;/code&gt; format</source>
          <target state="translated">바이트 지향 &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; / &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; &lt;code&gt;&quot;C&quot;&lt;/code&gt; 형식</target>
        </trans-unit>
        <trans-unit id="bcc22309c831036ee3dd3f94fb9ac198616e6137" translate="yes" xml:space="preserve">
          <source>the byte-oriented &lt;code&gt;pack&lt;/code&gt;/&lt;code&gt;unpack&lt;/code&gt;&lt;code&gt;&quot;C&quot;&lt;/code&gt; format</source>
          <target state="translated">바이트 지향 &lt;code&gt;pack&lt;/code&gt; / &lt;code&gt;unpack&lt;/code&gt; &lt;code&gt;&quot;C&quot;&lt;/code&gt; 형식</target>
        </trans-unit>
        <trans-unit id="df0540c941ef1d583ac55c355b64fd5941bb42bc" translate="yes" xml:space="preserve">
          <source>the cached data. The argument may be a function name or a reference to a function. For finer control over when data is discarded or expired, see the documentation for &lt;code&gt;Memoize::Expire&lt;/code&gt; , included in this package.</source>
          <target state="translated">캐시 된 데이터 인수는 함수 이름이거나 함수에 대한 참조 일 수 있습니다. 데이터 삭제 또는 만료 시점을보다 세밀하게 제어하려면 이 패키지에 포함 된 &lt;code&gt;Memoize::Expire&lt;/code&gt; 설명서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a03572d6c92e8f1528a687e824ad1c7a1012b46f" translate="yes" xml:space="preserve">
          <source>the cached data. The argument may be a function name or a reference to a function. For finer control over when data is discarded or expired, see the documentation for &lt;code&gt;Memoize::Expire&lt;/code&gt;, included in this package.</source>
          <target state="translated">캐시 된 데이터. 인수는 함수 이름 또는 함수에 대한 참조 일 수 있습니다. 데이터가 폐기되거나 만료되는시기에 대한보다 세밀한 제어 는이 패키지에 포함 된 &lt;code&gt;Memoize::Expire&lt;/code&gt; 설명서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e041f64994f4ad602b51cc368e45321ce3435e4d" translate="yes" xml:space="preserve">
          <source>the character set to use it.</source>
          <target state="translated">사용할 문자 세트.</target>
        </trans-unit>
        <trans-unit id="2acb51fb1aaf7311d7872477d62b8f21a28f8ae1" translate="yes" xml:space="preserve">
          <source>the character strings.</source>
          <target state="translated">문자열</target>
        </trans-unit>
        <trans-unit id="c731556f14a6292f08e47a5dff92437af6238ab2" translate="yes" xml:space="preserve">
          <source>the closing delimiter of the here document), which would cause the earlier &quot; || die;\nexit;&quot; to be skipped in any sequence of code fragment extractions.</source>
          <target state="translated">이전 문서 &quot;|| die; \ nexit;&quot;의 원인이되는 여기 문서의 닫는 구분 기호). 코드 조각 추출 시퀀스에서 건너 뛰어야합니다.</target>
        </trans-unit>
        <trans-unit id="aab39bfbe0a7c70c1895d1af4eb651fc1e701058" translate="yes" xml:space="preserve">
          <source>the closing tag (or &quot;&quot; if no closing tag was found)</source>
          <target state="translated">닫는 태그 (또는 닫는 태그가없는 경우 &quot;&quot;)</target>
        </trans-unit>
        <trans-unit id="157b41d2b634c5bd10fddb35da9de75d247bc255" translate="yes" xml:space="preserve">
          <source>the code by adding</source>
          <target state="translated">추가하여 코드</target>
        </trans-unit>
        <trans-unit id="d315aab2b081580801bce5775047436139f6f3cc" translate="yes" xml:space="preserve">
          <source>the code does what it does, not</source>
          <target state="translated">코드가하는 일이 아니라</target>
        </trans-unit>
        <trans-unit id="61801a1e0739c9c513bb5a98dbb30d9d43a9bad8" translate="yes" xml:space="preserve">
          <source>the code point belongs to, e.g. &lt;code&gt;Basic Latin&lt;/code&gt; . The old-style block name is returned (see &lt;a href=&quot;#Old-style-versus-new-style-block-names&quot;&gt;Old-style versus new-style block names&lt;/a&gt;). The &lt;a href=&quot;#prop_value_aliases()&quot;&gt;prop_value_aliases()&lt;/a&gt; function can be used to get all the synonyms of the block name.</source>
          <target state="translated">코드 포인트는 예를 들어 &lt;code&gt;Basic Latin&lt;/code&gt; 에 속합니다 . 이전 스타일 블록 이름이 리턴됩니다 ( &lt;a href=&quot;#Old-style-versus-new-style-block-names&quot;&gt;이전 스타일 대 새 스타일 블록 이름 참조&lt;/a&gt; ). &lt;a href=&quot;#prop_value_aliases()&quot;&gt;prop_value_aliases ()&lt;/a&gt; 함수는 블록 이름의 모든 동의어를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="514f368b79fbe129970893c2e5acec6d96445778" translate="yes" xml:space="preserve">
          <source>the code point belongs to, e.g. &lt;code&gt;Basic Latin&lt;/code&gt;. The old-style block name is returned (see &lt;a href=&quot;#Old-style-versus-new-style-block-names&quot;&gt;&quot;Old-style versus new-style block names&quot;&lt;/a&gt;). The &lt;a href=&quot;#prop_value_aliases%28%29&quot;&gt;&quot;prop_value_aliases()&quot;&lt;/a&gt; function can be used to get all the synonyms of the block name.</source>
          <target state="translated">코드 포인트는 예를 들어 &lt;code&gt;Basic Latin&lt;/code&gt; 에 속합니다 . 이전 스타일 블록 이름이 반환됩니다 ( &lt;a href=&quot;#Old-style-versus-new-style-block-names&quot;&gt;&quot;이전 스타일 대 새 스타일 블록 이름&quot;참조&lt;/a&gt; ). &lt;a href=&quot;#prop_value_aliases%28%29&quot;&gt;&quot;prop_value_aliases ()&quot;&lt;/a&gt; 함수는 블록 이름의 모든 동의어를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3f740a37880db96fc9c17587892331ec08337334" translate="yes" xml:space="preserve">
          <source>the code point belongs to, e.g., &lt;code&gt;Latin&lt;/code&gt; , &lt;code&gt;Greek&lt;/code&gt; , &lt;code&gt;Han&lt;/code&gt; . If the code point is unassigned or the Unicode version being used is so early that it doesn't have scripts, this function returns &lt;code&gt;&quot;Unknown&quot;&lt;/code&gt; . The &lt;a href=&quot;#prop_value_aliases()&quot;&gt;prop_value_aliases()&lt;/a&gt; function can be used to get all the synonyms of the script name.</source>
          <target state="translated">코드 포인트는 예를 들어 &lt;code&gt;Latin&lt;/code&gt; , &lt;code&gt;Greek&lt;/code&gt; , &lt;code&gt;Han&lt;/code&gt; 에 속합니다 . 코드 포인트가 할당되지 않았거나 사용중인 유니 코드 버전이 너무 빠르면 스크립트가없는 경우이 함수는 &lt;code&gt;&quot;Unknown&quot;&lt;/code&gt; 을 반환합니다 . &lt;a href=&quot;#prop_value_aliases()&quot;&gt;prop_value_aliases ()&lt;/a&gt; 함수는 스크립트 이름의 모든 동의어를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="04700c3dfe612a41b3a85d5f4c8eb500d465b0ef" translate="yes" xml:space="preserve">
          <source>the code point belongs to, e.g., &lt;code&gt;Latin&lt;/code&gt;, &lt;code&gt;Greek&lt;/code&gt;, &lt;code&gt;Han&lt;/code&gt;. If the code point is unassigned or the Unicode version being used is so early that it doesn't have scripts, this function returns &lt;code&gt;&quot;Unknown&quot;&lt;/code&gt;. The &lt;a href=&quot;#prop_value_aliases%28%29&quot;&gt;&quot;prop_value_aliases()&quot;&lt;/a&gt; function can be used to get all the synonyms of the script name.</source>
          <target state="translated">코드 포인트는 예를 들어 &lt;code&gt;Latin&lt;/code&gt; , &lt;code&gt;Greek&lt;/code&gt; , &lt;code&gt;Han&lt;/code&gt; 에 속합니다 . 코드 포인트가 할당되지 않았거나 사용중인 유니 코드 버전이 너무 빨라서 스크립트가없는 경우이 함수는 &lt;code&gt;&quot;Unknown&quot;&lt;/code&gt; 을 반환합니다 . &lt;a href=&quot;#prop_value_aliases%28%29&quot;&gt;&quot;prop_value_aliases ()&quot;&lt;/a&gt; 함수는 스크립트 이름의 모든 동의어를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="17f78cf6f96569dfc482468db33ab5d6f1b57d15" translate="yes" xml:space="preserve">
          <source>the combining class number for</source>
          <target state="translated">에 대한 결합 클래스 번호</target>
        </trans-unit>
        <trans-unit id="2bd53f225cc971376af4c684c177d1bda41015ca" translate="yes" xml:space="preserve">
          <source>the command &lt;code&gt;cpan .&lt;/code&gt; does all of this at once. It figures out which of the two mantras is appropriate, fetches and installs all prerequisites, takes care of them recursively, and finally finishes the installation of the module in the current directory, be it a CPAN module or not.</source>
          <target state="translated">&lt;code&gt;cpan .&lt;/code&gt; 명령 . 이 모든 것을 한 번에 수행합니다. 두 가지 진언 중 어느 것이 적합한 지 알아 내고, 모든 전제 조건을 가져 와서 설치하고, 재귀 적으로 처리하며, CPAN 모듈이든 아니든 현재 디렉토리에 모듈 설치를 완료합니다.</target>
        </trans-unit>
        <trans-unit id="ce45a0fcb17adacd3ffe931949aa170517ea5839" translate="yes" xml:space="preserve">
          <source>the command generated will</source>
          <target state="translated">생성 된 명령은</target>
        </trans-unit>
        <trans-unit id="5612fc997c8cb9a486d63ef7bf675962eedd7639" translate="yes" xml:space="preserve">
          <source>the commas on the right of the &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt; are evaluated before the &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt;, but the commas on the left are evaluated after. In other words, list operators tend to gobble up all arguments that follow, and then act like a simple TERM with regard to the preceding expression. Be careful with parentheses:</source>
          <target state="translated">의 오른쪽에 쉼표 &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt; 전과 평가 &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt; ,하지만 왼쪽에 쉼표가 후 평가됩니다. 다시 말해,리스트 연산자는 뒤에 오는 모든 인수를 뒤섞 고 앞의 표현과 관련하여 간단한 TERM처럼 행동하는 경향이 있습니다. 괄호에주의하십시오 :</target>
        </trans-unit>
        <trans-unit id="537f1b748db8f4dea053a53c1763bb4deb56cd71" translate="yes" xml:space="preserve">
          <source>the commas on the right of the &lt;code&gt;sort&lt;/code&gt; are evaluated before the &lt;code&gt;sort&lt;/code&gt;, but the commas on the left are evaluated after. In other words, list operators tend to gobble up all arguments that follow, and then act like a simple TERM with regard to the preceding expression. Be careful with parentheses:</source>
          <target state="translated">&lt;code&gt;sort&lt;/code&gt; 오른쪽의 쉼표는 정렬 전에 평가 되지만 왼쪽의 쉼표 는 &lt;code&gt;sort&lt;/code&gt; 후에 평가됩니다. 즉, 목록 연산자는 뒤 따르는 모든 인수를 먹어 치우고 이전 표현식과 관련하여 간단한 TERM처럼 작동하는 경향이 있습니다. 괄호에주의하십시오.</target>
        </trans-unit>
        <trans-unit id="2ea5806650c2d66f92a06b399e855bb23c546b4e" translate="yes" xml:space="preserve">
          <source>the compiler precomputes the number which that expression represents so that the interpreter won't have to.</source>
          <target state="translated">컴파일러는 인터프리터가 필요하지 않도록 해당 표현식이 나타내는 숫자를 미리 계산합니다.</target>
        </trans-unit>
        <trans-unit id="b590edf2b5459e947f26c3b792a11ee5b69155bd" translate="yes" xml:space="preserve">
          <source>the condition is true (or while the condition is false):</source>
          <target state="translated">조건이 참 (또는 조건이 거짓 인 동안) :</target>
        </trans-unit>
        <trans-unit id="86884d36b82542d454bba7bddac4a77b22d6fb75" translate="yes" xml:space="preserve">
          <source>the condition is true (that is, if the condition is false).</source>
          <target state="translated">조건이 true입니다 (즉, 조건이 false 인 경우).</target>
        </trans-unit>
        <trans-unit id="86738aba36bf1e9b69717f18b87a414714746d9a" translate="yes" xml:space="preserve">
          <source>the condition is true (that is, if the condition is false). See &lt;a href=&quot;perldata#Scalar-values&quot;&gt;&quot;Scalar values&quot; in perldata&lt;/a&gt; for definitions of true and false.</source>
          <target state="translated">조건이 참 (즉, 조건이 거짓 인 경우)입니다. true 및 false의 정의는 &lt;a href=&quot;perldata#Scalar-values&quot;&gt;perldata의 &quot;스칼라 값&quot;을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="cd2f84b37e4990a4cdb084747345787afb430fab" translate="yes" xml:space="preserve">
          <source>the condition is true. &lt;code&gt;until&lt;/code&gt; does the opposite, it repeats the statement</source>
          <target state="translated">조건이 맞습니다. 반대가 &lt;code&gt;until&lt;/code&gt; 진술을 반복합니다.</target>
        </trans-unit>
        <trans-unit id="1187353e73891604eff05b9f4c5f98892d305bdc" translate="yes" xml:space="preserve">
          <source>the condition is true. Postfix &lt;code&gt;while&lt;/code&gt; has the same magic treatment of some kinds of condition that prefix &lt;code&gt;while&lt;/code&gt; has. &lt;code&gt;until&lt;/code&gt; does the opposite, it repeats the statement</source>
          <target state="translated">조건이 참입니다. 후위 &lt;code&gt;while&lt;/code&gt; 접두사 것을 조건으로 어떤 종류의 같은 마법 처리가 &lt;code&gt;while&lt;/code&gt; 가지고 있습니다. 반대가 &lt;code&gt;until&lt;/code&gt; 문을 반복합니다.</target>
        </trans-unit>
        <trans-unit id="0b85c87e5cffade4a9922fbfed79cacba15c13fb" translate="yes" xml:space="preserve">
          <source>the conditions for the mappings to be valid. If &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;, the mappings are always valid. When defined, this field is a list of conditions, all of which must be true for the mappings to be valid. The list consists of one or more</source>
          <target state="translated">매핑 조건이 유효합니다. 경우 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 를 , 매핑은 항상 유효합니다. 정의 된 경우이 필드는 조건 목록이며 맵핑이 유효하려면 모두 참이어야합니다. 목록은 하나 이상의 구성</target>
        </trans-unit>
        <trans-unit id="7d0b706aae679d88d15bfae4315f18d5be869881" translate="yes" xml:space="preserve">
          <source>the conditions for the mappings to be valid. If &lt;code&gt;undef&lt;/code&gt;, the mappings are always valid. When defined, this field is a list of conditions, all of which must be true for the mappings to be valid. The list consists of one or more</source>
          <target state="translated">매핑이 유효하기위한 조건. 경우 &lt;code&gt;undef&lt;/code&gt; 를 , 매핑은 항상 유효합니다. 정의 된 경우이 필드는 조건 목록이며 매핑이 유효하려면 모두 참이어야합니다. 목록은 하나 이상의</target>
        </trans-unit>
        <trans-unit id="9b0638bead3b3df68f86f19c3a14de1a6bd30e21" translate="yes" xml:space="preserve">
          <source>the correct subexpression to match the comment delimiter, because it may &quot;give up&quot; some whitespace if the remainder of the pattern can be made to match that way. The correct answer is either one of these:</source>
          <target state="translated">패턴의 나머지 부분이 그런 식으로 일치하도록 할 수 있으면 일부 공백을 &quot;포기&quot;할 수 있으므로 주석 구분 기호와 일치하는 올바른 하위 표현식입니다. 정답은 다음 중 하나입니다.</target>
        </trans-unit>
        <trans-unit id="49b2f2aa6cf4102d30e4466e987b20729a1c1858" translate="yes" xml:space="preserve">
          <source>the current one.</source>
          <target state="translated">현재의 것.</target>
        </trans-unit>
        <trans-unit id="f931ec421d5bf3d3b08aae794827e76698391462" translate="yes" xml:space="preserve">
          <source>the data is assumed to be in (Latin 1 and) Unicode, not in your native encoding. In other words, this will match in &quot;greek&quot;:</source>
          <target state="translated">데이터는 기본 인코딩이 아닌 (라틴 1 및) 유니 코드에있는 것으로 가정합니다. 다시 말해, &quot;greek&quot;과 일치합니다.</target>
        </trans-unit>
        <trans-unit id="ca54e1fd49bc4a6778d016e9f59ee0f6e72284bf" translate="yes" xml:space="preserve">
          <source>the data referred to by &lt;code&gt;$a&lt;/code&gt; is unchanged by the assignment to &lt;code&gt;$b&lt;/code&gt; of a reference to new object data.</source>
          <target state="translated">이 데이터가 참조 &lt;code&gt;$a&lt;/code&gt; 에 할당하여 변하지 &lt;code&gt;$b&lt;/code&gt; 새로운 데이터 객체에 대한 참조.</target>
        </trans-unit>
        <trans-unit id="73209f90d9d86d440950888ee02a95bcd44d45ad" translate="yes" xml:space="preserve">
          <source>the debugger hooks (but still before the opcode itself is executed).</source>
          <target state="translated">디버거 후크 (하지만 여전히 opcode 자체가 실행되기 전에).</target>
        </trans-unit>
        <trans-unit id="d4a89a5f8efeb10956bd5035175680bd86c4055c" translate="yes" xml:space="preserve">
          <source>the declaration. You cannot write &lt;code&gt;$x = 1; &lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; $x;&lt;/code&gt; and expect the first assignment to affect the same variable. It will instead assign to an &lt;code&gt;$x&lt;/code&gt; declared previously in an outer scope, or to a global variable.</source>
          <target state="translated">선언. &lt;code&gt;$x = 1; &lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; $x;&lt;/code&gt; 쓸 수 없습니다 . 내 $ x; 첫 번째 할당이 동일한 변수에 영향을 미칠 것으로 예상합니다. 대신 외부 범위에서 이전에 선언 된 &lt;code&gt;$x&lt;/code&gt; 또는 전역 변수에 할당됩니다 .</target>
        </trans-unit>
        <trans-unit id="8cb176c6fd354f18b7f49de2a7008bd7b2afb392" translate="yes" xml:space="preserve">
          <source>the declaration. You cannot write &lt;code&gt;$x = 1; my $x;&lt;/code&gt; and expect the first assignment to affect the same variable. It will instead assign to an &lt;code&gt;$x&lt;/code&gt; declared previously in an outer scope, or to a global variable.</source>
          <target state="translated">선언. &lt;code&gt;$x = 1; my $x;&lt;/code&gt; 쓸 수 없습니다 . 내 $ x; 첫 번째 할당이 동일한 변수에 영향을 미칠 것으로 예상합니다. 대신 이전에 외부 범위에서 선언 된 &lt;code&gt;$x&lt;/code&gt; 또는 전역 변수에 할당됩니다 .</target>
        </trans-unit>
        <trans-unit id="46179a28308cc7fb8ab0677d72c75826ed7e6254" translate="yes" xml:space="preserve">
          <source>the depth should be 1 and in</source>
          <target state="translated">깊이는 1이어야합니다.</target>
        </trans-unit>
        <trans-unit id="6bf7f3909d5cb420150d508cb1f4a30ca1987a1f" translate="yes" xml:space="preserve">
          <source>the differences being that it generates a real list at compile time, and in scalar context it returns the last element in the list. So this expression:</source>
          <target state="translated">컴파일 타임에 실제 목록을 생성한다는 점과 스칼라 컨텍스트에서 목록의 마지막 요소를 반환한다는 차이점이 있습니다. 그래서이 표현은 :</target>
        </trans-unit>
        <trans-unit id="0779f8d09eae634c4c3842adeac94c5ec175e24f" translate="yes" xml:space="preserve">
          <source>the differences being that it only splits on ASCII whitespace, generates a real list at compile time, and in scalar context it returns the last element in the list. So this expression:</source>
          <target state="translated">차이점은 ASCII 공백으로 만 분할되고 컴파일 타임에 실제 목록을 생성하며 스칼라 컨텍스트에서는 목록의 마지막 요소를 반환한다는 것입니다. 그래서이 표현은 :</target>
        </trans-unit>
        <trans-unit id="85b968ca06524fd795c08850a7f7f0ce5c3baeda" translate="yes" xml:space="preserve">
          <source>the directory the file was read from</source>
          <target state="translated">파일을 읽은 디렉토리</target>
        </trans-unit>
        <trans-unit id="b05011b947d845e0f9cffdcd079fb878ae1595be" translate="yes" xml:space="preserve">
          <source>the effect is to pass the &lt;code&gt;&lt;a href=&quot;../functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; call an extra reference to the variable being tied:</source>
          <target state="translated">결과는 연결되는 변수에 대한 추가 참조를 &lt;code&gt;&lt;a href=&quot;../functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; 호출 에 전달하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="6df0a3200913a9d17bcf5d57bd967d0b13edc58c" translate="yes" xml:space="preserve">
          <source>the effect is to pass the &lt;code&gt;tie&lt;/code&gt; call an extra reference to the variable being tied:</source>
          <target state="translated">효과는 연결되는 변수에 대한 추가 참조를 &lt;code&gt;tie&lt;/code&gt; 호출 에 전달하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="24fdc39732587c01a485c44d61e61763164109d8" translate="yes" xml:space="preserve">
          <source>the elements in the array, only several first (depending on how deep it already went into the report tree).</source>
          <target state="translated">배열의 요소, 처음 몇 개만 (보고서 트리에 이미 깊숙이 들어 갔는지에 따라).</target>
        </trans-unit>
        <trans-unit id="da9e783c4554e1b5cab3e0647438bcc9a853ead9" translate="yes" xml:space="preserve">
          <source>the end of the script.</source>
          <target state="translated">스크립트의 끝.</target>
        </trans-unit>
        <trans-unit id="f7db5864c9ae797ba455c07e9a33679734cf02a5" translate="yes" xml:space="preserve">
          <source>the error message (usually either &lt;code&gt;$!&lt;/code&gt; or a YAML error)</source>
          <target state="translated">오류 메시지 (보통 &lt;code&gt;$!&lt;/code&gt; 또는 YAML 오류)</target>
        </trans-unit>
        <trans-unit id="7e9cc741fe4b132b7994345e5740c2efe34cbcb9" translate="yes" xml:space="preserve">
          <source>the error might show something like:</source>
          <target state="translated">오류는 다음과 같이 표시 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8bb3b69c49ba7467556b8814bc9da23ade9275bf" translate="yes" xml:space="preserve">
          <source>the exact number of times &quot;a&quot; or &quot;b&quot; are printed out is unspecified for failure, but you may assume they will be printed at least once during a successful match, additionally you may assume that if &quot;b&quot; is printed, it will be preceded by at least one &quot;a&quot;.</source>
          <target state="translated">&quot;a&quot;또는 &quot;b&quot;가 인쇄되는 정확한 횟수는 실패로 지정되지 않았지만 일치하는 동안 최소 한 번 인쇄 될 것이라고 가정 할 수 있으며, &quot;b&quot;가 인쇄되면 하나 이상의 &quot;a&quot;가 앞에옵니다.</target>
        </trans-unit>
        <trans-unit id="8b97065928f4e5ab101ba04eabe3aabc4a4e79e7" translate="yes" xml:space="preserve">
          <source>the exceptional code.</source>
          <target state="translated">예외적 인 코드.</target>
        </trans-unit>
        <trans-unit id="af071f22416397889c6368582b0fa9e1dd2f95c7" translate="yes" xml:space="preserve">
          <source>the extension needs an &lt;code&gt;HMQ&lt;/code&gt; only because some API will not work otherwise. Use &lt;code&gt;serve = 0&lt;/code&gt; below.</source>
          <target state="translated">일부 API는 달리 작동하지 않기 때문에 확장에는 &lt;code&gt;HMQ&lt;/code&gt; 만 필요합니다 . 아래 &lt;code&gt;serve = 0&lt;/code&gt; 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="68653d9ba062184ae14c759dbc109e73f199c9ee" translate="yes" xml:space="preserve">
          <source>the extension needs an &lt;code&gt;HMQ&lt;/code&gt; since it wants to engage in a PM event loop. Use &lt;code&gt;serve = 1&lt;/code&gt; below.</source>
          <target state="translated">PM 이벤트 루프에 참여 하려면 확장에 &lt;code&gt;HMQ&lt;/code&gt; 가 필요합니다 . 아래 &lt;code&gt;serve = 1&lt;/code&gt; 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="6cf3f84a1f238cbd74e98add44f2ddd490e3387b" translate="yes" xml:space="preserve">
          <source>the external libraries to be linked to dynamic extensions. This may be needed if the linker is one-pass, and Perl includes some overrides for C RTL functions, such as malloc().</source>
          <target state="translated">동적 확장에 링크 될 외부 라이브러리 링커가 하나의 패스이고 Perl에 malloc ()과 같은 C RTL 함수에 대한 재정의가 포함 된 경우에 필요할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="66ad2c58db4994c73cc010974641256709477f2b" translate="yes" xml:space="preserve">
          <source>the extracted quotelike substring (including trailing modifiers),</source>
          <target state="translated">추출 된 따옴표와 같은 부분 문자열 (후행 수정 자 포함)</target>
        </trans-unit>
        <trans-unit id="42d35ba5b2fb00e37e2c984e477ebc13cdfdf21b" translate="yes" xml:space="preserve">
          <source>the extracted tagged substring (including the outermost tags),</source>
          <target state="translated">추출 된 태그가 지정된 하위 문자열 (가장 바깥 쪽 태그 포함)</target>
        </trans-unit>
        <trans-unit id="3b49d2c5db6f2ef2aea9cd05887358917fb03add" translate="yes" xml:space="preserve">
          <source>the extracted variable, or variablish expression</source>
          <target state="translated">추출 된 변수 또는 변수 표현</target>
        </trans-unit>
        <trans-unit id="81e65c5286ebd771d0a1fbb3ecab8a77d65eef17" translate="yes" xml:space="preserve">
          <source>the fields $quota, $comment, and $expire are special in that they are unsupported on many systems. If the $quota is unsupported, it is an empty scalar. If it is supported, it usually encodes the disk quota. If the $comment field is unsupported, it is an empty scalar. If it is supported it usually encodes some administrative comment about the user. In some systems the $quota field may be $change or $age, fields that have to do with password aging. In some systems the $comment field may be $class. The $expire field, if present, encodes the expiration period of the account or the password. For the availability and the exact meaning of these fields in your system, please consult &lt;a href=&quot;http://man.he.net/man3/getpwnam&quot;&gt;getpwnam(3)&lt;/a&gt; and your system's</source>
          <target state="translated">$ quota, $ comment 및 $ expire 필드는 많은 시스템에서 지원되지 않는다는 점에서 특별합니다. $ quota가 지원되지 않으면 빈 스칼라입니다. 지원되는 경우 일반적으로 디스크 할당량을 인코딩합니다. $ comment 필드가 지원되지 않으면 빈 스칼라입니다. 지원되는 경우 일반적으로 사용자에 대한 관리 설명을 인코딩합니다. 일부 시스템에서는 $ quota 필드가 $ change 또는 $ age 일 수 있으며,이 필드는 암호 에이징과 관련이 있습니다. 일부 시스템에서는 $ comment 필드가 $ class 일 수 있습니다. $ expire 필드 (있는 경우)는 계정 또는 암호의 만료 기간을 인코딩합니다. 시스템에서 이러한 필드의 가용성과 정확한 의미에 대해서는 &lt;a href=&quot;http://man.he.net/man3/getpwnam&quot;&gt;getpwnam (3)&lt;/a&gt; 및 시스템의</target>
        </trans-unit>
        <trans-unit id="016bf1faef4ea8a64bf0b8c954cc8c806ed5c738" translate="yes" xml:space="preserve">
          <source>the fields $quota, $comment, and $expire are special in that they are unsupported on many systems. If the $quota is unsupported, it is an empty scalar. If it is supported, it usually encodes the disk quota. If the $comment field is unsupported, it is an empty scalar. If it is supported it usually encodes some administrative comment about the user. In some systems the $quota field may be $change or $age, fields that have to do with password aging. In some systems the $comment field may be $class. The $expire field, if present, encodes the expiration period of the account or the password. For the availability and the exact meaning of these fields in your system, please consult getpwnam(3) and your system's</source>
          <target state="translated">$ quota, $ comment 및 $ expire 필드는 많은 시스템에서 지원되지 않는다는 점에서 특별합니다. $ quota가 지원되지 않으면 빈 스칼라입니다. 지원되는 경우 일반적으로 디스크 할당량을 인코딩합니다. $ comment 필드가 지원되지 않으면 빈 스칼라입니다. 지원되는 경우 일반적으로 사용자에 대한 일부 관리 설명을 인코딩합니다. 일부 시스템에서 $ quota 필드는 암호 변경과 관련된 $ change 또는 $ age 필드 일 수 있습니다. 일부 시스템에서 $ comment 필드는 $ class 일 수 있습니다. $ expire 필드 (있는 경우)는 계정 또는 비밀번호의 만료 기간을 인코딩합니다. 시스템에서 이러한 필드의 가용성과 정확한 의미에 대해서는 getpwnam (3) 및 시스템의</target>
        </trans-unit>
        <trans-unit id="4e6284d9ef77c16fa7441dbe48390b1ff7f11a75" translate="yes" xml:space="preserve">
          <source>the file from which these prefs were read, or to which this error refers (relative filename)</source>
          <target state="translated">이러한 prefs를 읽었거나이 오류가 참조한 파일 (상대 파일 이름)</target>
        </trans-unit>
        <trans-unit id="a49a7390520e745f712d707cf39a8ada8dd959c6" translate="yes" xml:space="preserve">
          <source>the file's extension, which determines how to load it</source>
          <target state="translated">로드 방법을 결정하는 파일 확장자</target>
        </trans-unit>
        <trans-unit id="8a39339004def4392cf2fce8539f1c9fa6e9e17a" translate="yes" xml:space="preserve">
          <source>the filename in which the handler is being invoked;</source>
          <target state="translated">핸들러가 호출되는 파일 이름;</target>
        </trans-unit>
        <trans-unit id="b5524a08a7a872ca1ac27bd75f06b0da87774a8b" translate="yes" xml:space="preserve">
          <source>the filter is installed. If you use &lt;code&gt;FILTER&lt;/code&gt; to install the filter:</source>
          <target state="translated">필터가 설치되었습니다. &lt;code&gt;FILTER&lt;/code&gt; 를 사용하여 필터 를 설치하는 경우 :</target>
        </trans-unit>
        <trans-unit id="836f7fa685865677b2a2c2f0109bf7a3edc63603" translate="yes" xml:space="preserve">
          <source>the first call to this function.</source>
          <target state="translated">이 함수에 대한 첫 번째 호출.</target>
        </trans-unit>
        <trans-unit id="3fc99dcf1fde0f1020c083b9f2e3c54eaa07013a" translate="yes" xml:space="preserve">
          <source>the first component of an absolute path is read as the device name for the VMS file specification). There are a set of functions provided in the &lt;code&gt;VMS::Filespec&lt;/code&gt; package for explicit interconversion between VMS and Unix syntax; its documentation provides more details.</source>
          <target state="translated">절대 경로의 첫 번째 구성 요소는 VMS 파일 사양의 장치 이름으로 읽습니다). VMS와 Unix 구문 사이의 명시적인 상호 변환을 위해 &lt;code&gt;VMS::Filespec&lt;/code&gt; 패키지에 제공되는 함수 세트가 있습니다 . 자세한 내용은 해당 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="637e558c791eda9940492a71c91f36f4329c09c6" translate="yes" xml:space="preserve">
          <source>the first run-time executable statement (but see below regarding compile-time statements) and ask you to enter a debugger command. Contrary to popular expectations, whenever the debugger halts and shows you a line of code, it always displays the line it's</source>
          <target state="translated">첫 번째 런타임 실행 문 (하지만 컴파일 타임 문에 대해서는 아래 참조)을 디버거 명령을 입력하도록 요청하십시오. 일반적인 기대와 달리 디버거가 중단되고 코드 줄을 표시 할 때마다 항상 줄을 표시합니다.</target>
        </trans-unit>
        <trans-unit id="27d75fc186bcb6caedfcf9d78e7e42f8dd826b81" translate="yes" xml:space="preserve">
          <source>the following (overloaded) operations are supported on complex numbers:</source>
          <target state="translated">복소수에서는 다음과 같은 (과부하 된) 연산이 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="9900b62173a80d309d8d5d7804ced752318e7429" translate="yes" xml:space="preserve">
          <source>the following can all be used:</source>
          <target state="translated">다음을 모두 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f663eecb1d5e037a8b3023bffacae20c2edff826" translate="yes" xml:space="preserve">
          <source>the following service is available:</source>
          <target state="translated">다음과 같은 서비스를 이용할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="6cf109d190f58d0cff05b560c507ed0c4b28dea2" translate="yes" xml:space="preserve">
          <source>the following two lines:</source>
          <target state="translated">다음 두 줄 :</target>
        </trans-unit>
        <trans-unit id="4255eecaa2211c75003fae1cac3a175c59a648c8" translate="yes" xml:space="preserve">
          <source>the following will be printed</source>
          <target state="translated">다음이 인쇄됩니다</target>
        </trans-unit>
        <trans-unit id="a359ea19d6e48fb338ab79b0de2cf3c5b08da2b3" translate="yes" xml:space="preserve">
          <source>the full Perl quotelike operations are all extracted correctly.</source>
          <target state="translated">전체 Perl 인용 유사 조작이 모두 올바르게 추출됩니다.</target>
        </trans-unit>
        <trans-unit id="665373964dd300520c5ea8a5e5f85dae234c0a3f" translate="yes" xml:space="preserve">
          <source>the function &lt;code&gt;f&lt;/code&gt; is called with the implicit context argument (if any), and &lt;code&gt;p&lt;/code&gt; .</source>
          <target state="translated">함수 &lt;code&gt;f&lt;/code&gt; 는 암시 적 컨텍스트 인수 (있는 경우)와 함께 호출되며 &lt;code&gt;p&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="b801e7d16291e7f191a96c1de0aea6d5dc921cdf" translate="yes" xml:space="preserve">
          <source>the function &lt;code&gt;f&lt;/code&gt; is called with the implicit context argument (if any), and &lt;code&gt;p&lt;/code&gt;.</source>
          <target state="translated">함수 &lt;code&gt;f&lt;/code&gt; 는 암시 적 컨텍스트 인수 (있는 경우) 및 &lt;code&gt;p&lt;/code&gt; 로 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="3e46835aaeb90870490c67b35e66c766b0c603b8" translate="yes" xml:space="preserve">
          <source>the function &lt;code&gt;f&lt;/code&gt; is called with the only argument &lt;code&gt;p&lt;/code&gt; .</source>
          <target state="translated">함수 &lt;code&gt;f&lt;/code&gt; 는 유일한 인수 &lt;code&gt;p&lt;/code&gt; 로 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="c68a8240124397ff432e604d7be8b16b61c30049" translate="yes" xml:space="preserve">
          <source>the function &lt;code&gt;f&lt;/code&gt; is called with the only argument &lt;code&gt;p&lt;/code&gt;.</source>
          <target state="translated">함수 &lt;code&gt;f&lt;/code&gt; 는 유일한 인수 &lt;code&gt;p&lt;/code&gt; 로 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="e170f142d7f95bacc791dc5ebd99ca0c3173218d" translate="yes" xml:space="preserve">
          <source>the function @langs = panic_languages(@accept_languages)</source>
          <target state="translated">@langs = panic_languages ​​(@accept_languages) 함수</target>
        </trans-unit>
        <trans-unit id="3ef99755057dce6bd70e148046c0358f276e64c2" translate="yes" xml:space="preserve">
          <source>the function alternate_language_tags($lang1)</source>
          <target state="translated">alternate_language_tags ($ lang1) 함수</target>
        </trans-unit>
        <trans-unit id="332c637811452c8eeeccc5e8c91a0cc2cdafbacf" translate="yes" xml:space="preserve">
          <source>the function encode_language_tag($lang1)</source>
          <target state="translated">encode_language_tag ($ lang1) 함수</target>
        </trans-unit>
        <trans-unit id="647a634587d7b0b3c7a5ce852bb5cc9392061ee3" translate="yes" xml:space="preserve">
          <source>the function extract_language_tags($whatever)</source>
          <target state="translated">extract_language_tags ($ whatever) 함수</target>
        </trans-unit>
        <trans-unit id="21730870f6a805704e1c9eae31dc153830679d66" translate="yes" xml:space="preserve">
          <source>the function implicate_supers( ...languages... )</source>
          <target state="translated">implicate_supers (... languages ​​...) 함수</target>
        </trans-unit>
        <trans-unit id="a87ea957b982d404907114a776391b16f7b6d563" translate="yes" xml:space="preserve">
          <source>the function implicate_supers_strictly( ...languages... )</source>
          <target state="translated">implicate_supers_strictly (... languages ​​...) 함수</target>
        </trans-unit>
        <trans-unit id="abac2654940e1d7f72be5f3ae8e30cb0913e5cd4" translate="yes" xml:space="preserve">
          <source>the function is_dialect_of($lang1, $lang2)</source>
          <target state="translated">함수 is_dialect_of ($ lang1, $ lang2)</target>
        </trans-unit>
        <trans-unit id="0f04f45089b6618c074f414f23655d0d0d12cc08" translate="yes" xml:space="preserve">
          <source>the function is_language_tag($lang1)</source>
          <target state="translated">함수 is_language_tag ($ lang1)</target>
        </trans-unit>
        <trans-unit id="abe47f46a06e8231f55e5617a406f260eec2b0c3" translate="yes" xml:space="preserve">
          <source>the function locale2language_tag($locale_identifier)</source>
          <target state="translated">locale2language_tag ($ locale_identifier) ​​함수</target>
        </trans-unit>
        <trans-unit id="69c9c89ad9b2d0228f4ee63261db26c1d4dbbbea" translate="yes" xml:space="preserve">
          <source>the function same_language_tag($lang1, $lang2)</source>
          <target state="translated">same_language_tag ($ lang1, $ lang2) 함수</target>
        </trans-unit>
        <trans-unit id="9e64a21af43387880f4536b4063d85a7287d24ce" translate="yes" xml:space="preserve">
          <source>the function similarity_language_tag($lang1, $lang2)</source>
          <target state="translated">similarity_language_tag ($ lang1, $ lang2) 함수</target>
        </trans-unit>
        <trans-unit id="bf202e88786f75a4c586f57b7daab821271f601b" translate="yes" xml:space="preserve">
          <source>the function super_languages($lang1)</source>
          <target state="translated">super_languages ​​($ lang1) 함수</target>
        </trans-unit>
        <trans-unit id="d2aa815ed61bb2b4a9c36c73dd79bb32bdb9bc2b" translate="yes" xml:space="preserve">
          <source>the given version. No other version would be considered acceptable.</source>
          <target state="translated">주어진 버전. 다른 버전은 허용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="850abfb0a7900ca16bb5b9403d6bbfc093cbaf0c" translate="yes" xml:space="preserve">
          <source>the global copy.</source>
          <target state="translated">글로벌 카피</target>
        </trans-unit>
        <trans-unit id="f434ae09e827a25a29a618e48cd45a236fb5d87c" translate="yes" xml:space="preserve">
          <source>the group it refers to, it is now possible to apply pattern matching to tasks that hitherto required a recursive parser.</source>
          <target state="translated">참조하는 그룹은 이제 재귀 파서를 필요로하는 작업에 패턴 일치를 적용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="31b2573e185373055654ad9f5422afaa202d6f6a" translate="yes" xml:space="preserve">
          <source>the handle of an open file</source>
          <target state="translated">열린 파일의 핸들</target>
        </trans-unit>
        <trans-unit id="b84befde5d1a886c007587e3a95889cb406da1f9" translate="yes" xml:space="preserve">
          <source>the hash &lt;code&gt;%defines&lt;/code&gt; (or &lt;code&gt;%$defines&lt;/code&gt; ) will contain two keys, &lt;code&gt;&quot;os&quot;&lt;/code&gt; with value &lt;code&gt;&quot;linux&quot;&lt;/code&gt; and &lt;code&gt;&quot;vendor&quot;&lt;/code&gt; with value &lt;code&gt;&quot;redhat&quot;&lt;/code&gt; . It is also possible to specify that only integer or floating point numbers are acceptable values. The keys are always taken to be strings.</source>
          <target state="translated">해시 &lt;code&gt;%defines&lt;/code&gt; (또는 &lt;code&gt;%$defines&lt;/code&gt; ), 두 개의 키를 포함 할 것이다 &lt;code&gt;&quot;os&quot;&lt;/code&gt; 값 &lt;code&gt;&quot;linux&quot;&lt;/code&gt; 와 &lt;code&gt;&quot;vendor&quot;&lt;/code&gt; 값 &lt;code&gt;&quot;redhat&quot;&lt;/code&gt; . 정수 또는 부동 소수점 숫자 만 허용되는 값으로 지정할 수도 있습니다. 키는 항상 문자열로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="fc2fa5bd85e7068c864661c3a95b0ca360810351" translate="yes" xml:space="preserve">
          <source>the hash &lt;code&gt;%defines&lt;/code&gt; (or &lt;code&gt;%$defines&lt;/code&gt;) will contain two keys, &lt;code&gt;&quot;os&quot;&lt;/code&gt; with value &lt;code&gt;&quot;linux&quot;&lt;/code&gt; and &lt;code&gt;&quot;vendor&quot;&lt;/code&gt; with value &lt;code&gt;&quot;redhat&quot;&lt;/code&gt;. It is also possible to specify that only integer or floating point numbers are acceptable values. The keys are always taken to be strings.</source>
          <target state="translated">해시 &lt;code&gt;%defines&lt;/code&gt; (또는 &lt;code&gt;%$defines&lt;/code&gt; ), 두 개의 키를 포함 할 것이다 &lt;code&gt;&quot;os&quot;&lt;/code&gt; 값 &lt;code&gt;&quot;linux&quot;&lt;/code&gt; 와 &lt;code&gt;&quot;vendor&quot;&lt;/code&gt; 값 &lt;code&gt;&quot;redhat&quot;&lt;/code&gt; . 정수 또는 부동 소수점 숫자 만 허용되는 값으로 지정할 수도 있습니다. 키는 항상 문자열로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="5de606e1b8fb6cf1a474fddc76a9d896f8dab695" translate="yes" xml:space="preserve">
          <source>the hash of dot file names and content mappings</source>
          <target state="translated">도트 파일명 및 컨텐츠 매핑의 해시</target>
        </trans-unit>
        <trans-unit id="f1cd96b5f21ad238f5015969ec918856f8eea2c7" translate="yes" xml:space="preserve">
          <source>the identifier &quot;html&quot; doesn't begin have a &quot;:&quot; prefix, the contents of this region are stored as data paragraphs, instead of being processed as ordinary paragraphs (or if they began with a spaces and/or tabs, as verbatim paragraphs).</source>
          <target state="translated">식별자 &quot;html&quot;에 &quot;:&quot;접두사가 붙지 않으면이 영역의 내용은 일반 단락으로 처리되지 않고 데이터 단락으로 저장됩니다 (공백 및 / 또는 탭으로 시작하는 경우 그대로의 단락으로). ).</target>
        </trans-unit>
        <trans-unit id="74997a5db61b1cd6b27805f5b2e5dd2aa25c9e37" translate="yes" xml:space="preserve">
          <source>the include files by hand:</source>
          <target state="translated">직접 포함 파일 :</target>
        </trans-unit>
        <trans-unit id="c32f7051d8182d6636642b4351c7cd573431f395" translate="yes" xml:space="preserve">
          <source>the input native &lt;a href=&quot;#code-point-argument&quot;&gt;&quot;code point argument&quot;&lt;/a&gt; expressed in hexadecimal, with leading zeros added if necessary to make it contain at least four hexdigits</source>
          <target state="translated">입력 네이티브 &lt;a href=&quot;#code-point-argument&quot;&gt;&quot;코드 포인트 인수&quot;&lt;/a&gt; 는 16 진수로 표현되며, 필요한 경우 선행 0이 추가되어 최소 4 개의 16 진수를 포함 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0639a40b39994bddd5c923a37a742c0525b745c4" translate="yes" xml:space="preserve">
          <source>the input native &lt;a href=&quot;#code-point-argument&quot;&gt;code point argument&lt;/a&gt; expressed in hexadecimal, with leading zeros added if necessary to make it contain at least four hexdigits</source>
          <target state="translated">16 진수로 표현 된 입력 고유 &lt;a href=&quot;#code-point-argument&quot;&gt;코드 포인트 인수&lt;/a&gt; . 최소 4 자리를 포함하기 위해 필요한 경우 선행 0이 추가됨</target>
        </trans-unit>
        <trans-unit id="61ca6011deda6931eab08814d67f17903705c3cc" translate="yes" xml:space="preserve">
          <source>the input stream used by the current invocation of this method.</source>
          <target state="translated">이 메소드의 현재의 호출로 사용되는 입력 스트림</target>
        </trans-unit>
        <trans-unit id="5de1329fbaf0573c7809c0fde48792ca86cde1a3" translate="yes" xml:space="preserve">
          <source>the integer operation provides scalar context for the &amp;lt;&amp;gt; operator, which responds by reading one line from STDIN and passing it back to the integer operation, which will then find the integer value of that line and return that. If, on the other hand, you say</source>
          <target state="translated">정수 연산은 &amp;lt;&amp;gt; 연산자에 스칼라 컨텍스트를 제공합니다. STDIN에서 한 줄을 읽고이를 정수 연산으로 다시 전달하면 해당 라인의 정수 값을 찾아서 반환합니다. 반면에</target>
        </trans-unit>
        <trans-unit id="3c6c16bacb789d14f0c6c80b16288c33e3f368b9" translate="yes" xml:space="preserve">
          <source>the invocand performs the operations, merely that it does. (&lt;code&gt;isa&lt;/code&gt; of course mandates an inheritance relationship. Other relationships include aggregation, delegation, and mocking.)</source>
          <target state="translated">요청자는 단순히 그 작업을 수행합니다. ( &lt;code&gt;isa&lt;/code&gt; 과정은 상속 관계를 의무화. 다른 관계 집합, 위임 및 조롱을 포함한다.)</target>
        </trans-unit>
        <trans-unit id="ebbeb0be019cd7f66404e317364ede716923212f" translate="yes" xml:space="preserve">
          <source>the key 12345 will get stored in the DBM database as the 5 byte string &quot;12345&quot;. If you actually want the key to be stored in the DBM database as a C int, you will have to use &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; when writing, and &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; when reading.</source>
          <target state="translated">키 12345는 DBM 데이터베이스에 5 바이트 문자열 &quot;12345&quot;로 저장됩니다. 실제로 키를 DBM 데이터베이스에 C int로 저장하려면 쓰기시 &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; 을 사용 하고 읽을 때는 &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="73b08d11786efcc88b210a0f577b181e82031245" translate="yes" xml:space="preserve">
          <source>the key 12345 will get stored in the DBM database as the 5 byte string &quot;12345&quot;. If you actually want the key to be stored in the DBM database as a C int, you will have to use &lt;code&gt;pack&lt;/code&gt; when writing, and &lt;code&gt;unpack&lt;/code&gt; when reading.</source>
          <target state="translated">12345 키는 5 바이트 문자열 &quot;12345&quot;로 DBM 데이터베이스에 저장됩니다. 실제로 키를 DBM 데이터베이스에 C int로 저장하려면 쓰기시 &lt;code&gt;pack&lt;/code&gt; 을 사용 하고 읽을 때 &lt;code&gt;unpack&lt;/code&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="694a92aa79066881fbe2b7e9a9a36e360c9a7d36" translate="yes" xml:space="preserve">
          <source>the key and value are expected to be in UTF-8.</source>
          <target state="translated">키와 값은 UTF-8이어야합니다.</target>
        </trans-unit>
        <trans-unit id="767f35eec2056ec4a9c8dfce5c06b61f7815ff96" translate="yes" xml:space="preserve">
          <source>the left delimiter of the first block of the operation,</source>
          <target state="translated">연산의 첫 번째 블록의 왼쪽 구분 기호</target>
        </trans-unit>
        <trans-unit id="76aa8b9cbe9e34630c0db1543914a121410c5ea7" translate="yes" xml:space="preserve">
          <source>the left delimiter of the second block of the operation (that is, if it is a &lt;code&gt;&lt;a href=&quot;../functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../functions/tr&quot;&gt;tr&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;../functions/y&quot;&gt;y&lt;/a&gt;&lt;/code&gt;),</source>
          <target state="translated">연산의 두 번째 블록의 왼쪽 구분 기호 (즉, &lt;code&gt;&lt;a href=&quot;../functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../functions/tr&quot;&gt;tr&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;../functions/y&quot;&gt;y&lt;/a&gt;&lt;/code&gt; 인 경우 )</target>
        </trans-unit>
        <trans-unit id="2b88d53e2045a03d52cc304406d96d59c9804a73" translate="yes" xml:space="preserve">
          <source>the left delimiter of the second block of the operation (that is, if it is a &lt;code&gt;s&lt;/code&gt;, &lt;code&gt;tr&lt;/code&gt;, or &lt;code&gt;y&lt;/code&gt;),</source>
          <target state="translated">연산의 두 번째 블록의 왼쪽 구분 기호 (즉, &lt;code&gt;s&lt;/code&gt; , &lt;code&gt;tr&lt;/code&gt; 또는 &lt;code&gt;y&lt;/code&gt; 인 경우 )</target>
        </trans-unit>
        <trans-unit id="b06df6449e28067bcdeaaba89205c5a942c211c0" translate="yes" xml:space="preserve">
          <source>the length of the array via &lt;code&gt;$x = &lt;a href=&quot;../functions/scalar&quot;&gt;scalar&lt;/a&gt; @tied_file&lt;/code&gt; accesses &lt;b&gt;all&lt;/b&gt; records and stores their offsets. The same for &lt;code&gt;foreach (@tied_file)&lt;/code&gt; , even if you exit the loop early.</source>
          <target state="translated">&lt;code&gt;$x = &lt;a href=&quot;../functions/scalar&quot;&gt;scalar&lt;/a&gt; @tied_file&lt;/code&gt; 를 통한 배열의 길이 @tied_file은 &lt;b&gt;모든&lt;/b&gt; 레코드에 액세스 하고 오프셋을 저장합니다. 루프를 일찍 종료하더라도 &lt;code&gt;foreach (@tied_file)&lt;/code&gt; 와 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="ca613324b2170c4d516cf028b92fd39e4d3e835d" translate="yes" xml:space="preserve">
          <source>the length of the array via &lt;code&gt;$x = scalar @tied_file&lt;/code&gt; accesses &lt;b&gt;all&lt;/b&gt; records and stores their offsets. The same for &lt;code&gt;foreach (@tied_file)&lt;/code&gt;, even if you exit the loop early.</source>
          <target state="translated">&lt;code&gt;$x = scalar @tied_file&lt;/code&gt; 통한 배열의 길이 는 &lt;b&gt;모든&lt;/b&gt; 레코드에 액세스 &lt;b&gt;하고&lt;/b&gt; 해당 오프셋을 저장합니다. 루프를 일찍 종료하더라도 &lt;code&gt;foreach (@tied_file)&lt;/code&gt; 에 대해서도 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="6ccb0b24c3db89622ef2ccbd74733225119dada0" translate="yes" xml:space="preserve">
          <source>the lexicals should be separate anyway!)</source>
          <target state="translated">어휘는 어쨌든 분리되어야합니다!)</target>
        </trans-unit>
        <trans-unit id="b3350ff0610525714cd0795ab7665285a8cf78f9" translate="yes" xml:space="preserve">
          <source>the line number in this file.</source>
          <target state="translated">이 파일의 줄 번호</target>
        </trans-unit>
        <trans-unit id="26eb9a372a343a276c4a513a17b9005def4ede8b" translate="yes" xml:space="preserve">
          <source>the line-number of the beginning of the paragraph</source>
          <target state="translated">단락 시작의 행 번호</target>
        </trans-unit>
        <trans-unit id="3b67453a7d975f1bc1459469c850c239cfab6efb" translate="yes" xml:space="preserve">
          <source>the list of statically loaded extensions. We discuss this case only here.</source>
          <target state="translated">정적으로로드 된 확장 목록 우리는이 사건에 대해서만 여기서 논의합니다.</target>
        </trans-unit>
        <trans-unit id="93446bd0983629992edcb855c487be89cebc2522" translate="yes" xml:space="preserve">
          <source>the listed namespace(s) its self.</source>
          <target state="translated">나열된 네임 스페이스 자체.</target>
        </trans-unit>
        <trans-unit id="051f0efa2b53b111aaca897cc0e249865ec7115d" translate="yes" xml:space="preserve">
          <source>the listed operators from being used when compiling code in the compartment (</source>
          <target state="translated">구획에서 코드를 컴파일 할 때 나열된 연산자 사용</target>
        </trans-unit>
        <trans-unit id="d8e84d0ea6af468855c18cc5c4165d6c2edf43f5" translate="yes" xml:space="preserve">
          <source>the listed operators to be used when compiling code in the compartment (</source>
          <target state="translated">구획에서 코드를 컴파일 할 때 사용되는 나열된 연산자 (</target>
        </trans-unit>
        <trans-unit id="54c630076c2e8af3cc172f5eaeb4a114afdb88df" translate="yes" xml:space="preserve">
          <source>the main CPAN.pm documentation</source>
          <target state="translated">주요 CPAN.pm 문서</target>
        </trans-unit>
        <trans-unit id="8d57dca9adfe6ef8a0ce4c6886f4411e9fe4c0da" translate="yes" xml:space="preserve">
          <source>the name of the POSIX class. The POSIX classes are &lt;code&gt;alpha&lt;/code&gt;, &lt;code&gt;alnum&lt;/code&gt;, &lt;code&gt;ascii&lt;/code&gt;, &lt;code&gt;cntrl&lt;/code&gt;, &lt;code&gt;digit&lt;/code&gt;, &lt;code&gt;graph&lt;/code&gt;, &lt;code&gt;lower&lt;/code&gt;, &lt;code&gt;print&lt;/code&gt;, &lt;code&gt;punct&lt;/code&gt;, &lt;code&gt;space&lt;/code&gt;, &lt;code&gt;upper&lt;/code&gt;, and &lt;code&gt;xdigit&lt;/code&gt;, and two extensions, &lt;code&gt;word&lt;/code&gt; (a Perl extension to match &lt;code&gt;\w&lt;/code&gt;), and &lt;code&gt;blank&lt;/code&gt; (a GNU extension). The &lt;code&gt;/a&lt;/code&gt; modifier restricts these to matching just in the ASCII range; otherwise they can match the same as their corresponding Perl Unicode classes: &lt;code&gt;[:upper:]&lt;/code&gt; is the same as &lt;code&gt;\p{IsUpper}&lt;/code&gt;,</source>
          <target state="translated">POSIX 클래스의 이름. POSIX 클래스는 &lt;code&gt;alpha&lt;/code&gt; , &lt;code&gt;alnum&lt;/code&gt; , &lt;code&gt;ascii&lt;/code&gt; , &lt;code&gt;cntrl&lt;/code&gt; , &lt;code&gt;digit&lt;/code&gt; , &lt;code&gt;graph&lt;/code&gt; , &lt;code&gt;lower&lt;/code&gt; , &lt;code&gt;print&lt;/code&gt; , &lt;code&gt;punct&lt;/code&gt; , &lt;code&gt;space&lt;/code&gt; , &lt;code&gt;upper&lt;/code&gt; , &lt;code&gt;xdigit&lt;/code&gt; , 두 개의 확장자, &lt;code&gt;word&lt;/code&gt; ( &lt;code&gt;\w&lt;/code&gt; 와 일치하는 Perl 확장자 ) 및 &lt;code&gt;blank&lt;/code&gt; (GNU 확장자)입니다. ). &lt;code&gt;/a&lt;/code&gt; 개질제 단지 ASCII 범위에서 일치 이러한 제한; 그렇지 않으면 해당 Perl 유니 코드 클래스와 동일하게 일치 할 수 있습니다. &lt;code&gt;[:upper:]&lt;/code&gt; 는 다음과 같습니다. &lt;code&gt;\p{IsUpper}&lt;/code&gt; ,</target>
        </trans-unit>
        <trans-unit id="31de264c7a353042751dac7324ee677917f37a3f" translate="yes" xml:space="preserve">
          <source>the name of the attribute;</source>
          <target state="translated">속성의 이름</target>
        </trans-unit>
        <trans-unit id="9a6dd96ba410443fbba39f655ba62d36a863540d" translate="yes" xml:space="preserve">
          <source>the name of the command for this POD paragraph</source>
          <target state="translated">이 POD 단락의 커멘드 명</target>
        </trans-unit>
        <trans-unit id="2c087f6dc6a4c7745ab845d35d36946b340507ca" translate="yes" xml:space="preserve">
          <source>the name of the distribution file). The rest of the line is optional. The comment part is delimited by a dash just as in the man page header.</source>
          <target state="translated">배포 파일의 이름). 나머지 줄은 선택 사항입니다. 주석 부분은 매뉴얼 페이지 헤더에서와 같이 대시로 구분됩니다.</target>
        </trans-unit>
        <trans-unit id="ca482cb8c936ba1473c739bc3144869ba0ef4341" translate="yes" xml:space="preserve">
          <source>the name of the package into which it was declared;</source>
          <target state="translated">패키지가 선언 된 패키지의 이름</target>
        </trans-unit>
        <trans-unit id="14146974f9eb8a14ac07caec61bf51bf5504d35b" translate="yes" xml:space="preserve">
          <source>the name of the phase in which the handler is being invoked;</source>
          <target state="translated">핸들러가 호출되는 단계의 이름;</target>
        </trans-unit>
        <trans-unit id="7cfba45823ccfce6febf457efcadfb34ef2605e6" translate="yes" xml:space="preserve">
          <source>the name of the quotelike operator (if any),</source>
          <target state="translated">따옴표와 같은 연산자의 이름 (있는 경우)</target>
        </trans-unit>
        <trans-unit id="138b6536484652815dd7efba0b7477cef6bf08bb" translate="yes" xml:space="preserve">
          <source>the namespace itself.</source>
          <target state="translated">네임 스페이스 자체.</target>
        </trans-unit>
        <trans-unit id="df3356a9e1aafc8181b5cb48884b965018953430" translate="yes" xml:space="preserve">
          <source>the new object &lt;b&gt;will not&lt;/b&gt; be a clone of the existing object. In the example case, $v2 will be an empty object of the same type as $v1.</source>
          <target state="translated">새 개체 &lt;b&gt;는&lt;/b&gt; 기존 개체의 복제본 &lt;b&gt;이 아닙니다&lt;/b&gt; . 예제의 경우 $ v2는 $ v1과 동일한 유형의 빈 개체입니다.</target>
        </trans-unit>
        <trans-unit id="89dfd16b868608208dc5e268bb3cefacf7817535" translate="yes" xml:space="preserve">
          <source>the newline. In general, lines in Perl do not need any form of continuation mark, because &lt;b&gt;whitespace&lt;/b&gt; (including newlines) is gleefully ignored. Usually.</source>
          <target state="translated">개행. 일반적으로 &lt;b&gt;공백&lt;/b&gt; ( &lt;b&gt;줄&lt;/b&gt; 바꿈 포함)이 무시 되므로 Perl의 행에는 연속 표시 형식이 필요하지 않습니다 . 보통.</target>
        </trans-unit>
        <trans-unit id="372fe5c4d24ded7bde11806c2356f0b5e1e0ace4" translate="yes" xml:space="preserve">
          <source>the next interpreter is constructed. By default, when perl is not built with any special options, the global variable &lt;code&gt;PL_perl_destruct_level&lt;/code&gt; is set to &lt;code&gt;0&lt;/code&gt; , since extra cleaning isn't usually needed when a program only ever creates a single interpreter in its entire lifetime.</source>
          <target state="translated">다음 통역사가 구성됩니다. 기본적으로 perl이 특수 옵션으로 빌드되지 않은 경우 전역 변수 &lt;code&gt;PL_perl_destruct_level&lt;/code&gt; 은 &lt;code&gt;0&lt;/code&gt; 으로 설정 됩니다. 프로그램이 전체 수명 동안 단일 인터프리터 만 작성하는 경우 일반적으로 추가 정리가 필요하지 않기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="99b4cadc5563351017cc970ef86e13495fc5f3cb" translate="yes" xml:space="preserve">
          <source>the next interpreter is constructed. By default, when perl is not built with any special options, the global variable &lt;code&gt;PL_perl_destruct_level&lt;/code&gt; is set to &lt;code&gt;0&lt;/code&gt;, since extra cleaning isn't usually needed when a program only ever creates a single interpreter in its entire lifetime.</source>
          <target state="translated">다음 인터프리터가 구성됩니다. 기본적으로 perl이 특별한 옵션으로 빌드되지 않은 경우 전역 변수 &lt;code&gt;PL_perl_destruct_level&lt;/code&gt; 은 &lt;code&gt;0&lt;/code&gt; 으로 설정 됩니다. 프로그램이 전체 수명 동안 단일 인터프리터 만 생성 할 때 일반적으로 추가 정리가 필요하지 않기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="39b65447e9246a75ec1295250c74aaaa79fc46a4" translate="yes" xml:space="preserve">
          <source>the number of bytes used for storing the integer,</source>
          <target state="translated">정수를 저장하는 데 사용되는 바이트 수</target>
        </trans-unit>
        <trans-unit id="6a32bdad61a31a90e6bb104533ea9d93e395672b" translate="yes" xml:space="preserve">
          <source>the number of elements of each. It's so easy to make that mistake in reading &lt;code&gt;ok @foo, @bar&lt;/code&gt; that you might want to be very explicit about it, and instead write &lt;code&gt;ok &lt;a href=&quot;functions/scalar&quot;&gt;scalar&lt;/a&gt;(@foo),
&lt;a href=&quot;functions/scalar&quot;&gt;scalar&lt;/a&gt;(@bar)&lt;/code&gt; .</source>
          <target state="translated">각각의 요소 수 &lt;code&gt;ok @foo, @bar&lt;/code&gt; 를 읽을 때 실수를 저지르면 매우 명확하게 표현할 수 있고 대신 &lt;code&gt;ok &lt;a href=&quot;functions/scalar&quot;&gt;scalar&lt;/a&gt;(@foo), &lt;a href=&quot;functions/scalar&quot;&gt;scalar&lt;/a&gt;(@bar)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="92cffcb996655915c6b0aa5beb305df5969a679d" translate="yes" xml:space="preserve">
          <source>the number of elements of each. It's so easy to make that mistake in reading &lt;code&gt;ok @foo, @bar&lt;/code&gt; that you might want to be very explicit about it, and instead write &lt;code&gt;ok scalar(@foo), scalar(@bar)&lt;/code&gt;.</source>
          <target state="translated">각 요소의 수. &lt;code&gt;ok @foo, @bar&lt;/code&gt; 를 읽을 때 실수하기가 너무 쉬워서 그것에 대해 매우 명시 적으로 작성하고 대신 &lt;code&gt;ok scalar(@foo), scalar(@bar)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="823166c6684adfe84aefb20864f10ef5d6cd3d28" translate="yes" xml:space="preserve">
          <source>the numeric value of $c becomes 13. There is no doubt now that the module symbolic provides a</source>
          <target state="translated">$ c의 숫자 값은 13이됩니다. 이제 상징적 인 모듈이</target>
        </trans-unit>
        <trans-unit id="1ac3c3d918bc81daf5c65f159136b230693ee8fc" translate="yes" xml:space="preserve">
          <source>the offset from SvPVX back to the true start of the allocated buffer, which will be non-zero if &lt;code&gt;sv_chop&lt;/code&gt; has been used to efficiently remove characters from start of the buffer. Implemented as a macro, which takes the address of</source>
          <target state="translated">SvPVX에서 할당 된 버퍼의 실제 시작으로의 오프셋. sv_chop을 사용하여 버퍼의 시작에서 문자를 효율적으로 제거하는 경우 0이 &lt;code&gt;sv_chop&lt;/code&gt; . 매크로로 구현되어 주소를</target>
        </trans-unit>
        <trans-unit id="7ea73421a1bf18378d7ef84367c0382aecac8634" translate="yes" xml:space="preserve">
          <source>the opening tag</source>
          <target state="translated">오프닝 태그</target>
        </trans-unit>
        <trans-unit id="8f61fcba295dad5a2720ef444bb841149cfcf31a" translate="yes" xml:space="preserve">
          <source>the opposite of &lt;a href=&quot;#read-FILEHANDLE%2CSCALAR%2CLENGTH%2COFFSET&quot;&gt;&lt;code&gt;read&lt;/code&gt;&lt;/a&gt;. Unfortunately.</source>
          <target state="translated">&lt;a href=&quot;#read-FILEHANDLE%2CSCALAR%2CLENGTH%2COFFSET&quot;&gt; &lt;code&gt;read&lt;/code&gt; &lt;/a&gt; 의 반대입니다 . 운수 나쁘게.</target>
        </trans-unit>
        <trans-unit id="3b0998471797c48420431e27eecb5eb2cb35a85a" translate="yes" xml:space="preserve">
          <source>the opposite of &lt;code&gt;&lt;a href=&quot;functions/read&quot;&gt;read&lt;/a&gt;&lt;/code&gt;. Unfortunately.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; 의 반대입니다 . 운수 나쁘게.</target>
        </trans-unit>
        <trans-unit id="80df94a93d5470e4069dee2128b3a3694259c404" translate="yes" xml:space="preserve">
          <source>the opposite of &lt;code&gt;&lt;a href=&quot;read&quot;&gt;read&lt;/a&gt;&lt;/code&gt;. Unfortunately.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; 의 반대입니다 . 운수 나쁘게.</target>
        </trans-unit>
        <trans-unit id="93d702a52abd879c9ef0db6a688f9798f839daa7" translate="yes" xml:space="preserve">
          <source>the option.</source>
          <target state="translated">옵션.</target>
        </trans-unit>
        <trans-unit id="350cdcf12a74c00b21d0c4d53a770475da27efeb" translate="yes" xml:space="preserve">
          <source>the other way round, some texts define the</source>
          <target state="translated">다른 방법으로, 일부 텍스트는</target>
        </trans-unit>
        <trans-unit id="2f75519c4c0e14572b57dc5211980f1b5e587f4d" translate="yes" xml:space="preserve">
          <source>the output produced should be the following:</source>
          <target state="translated">출력은 다음과 같아야합니다.</target>
        </trans-unit>
        <trans-unit id="5c767ed6a2f2639fc062b9d28d7dc0b33633147a" translate="yes" xml:space="preserve">
          <source>the output string will be UTF-8-encoded &lt;code&gt;ab\x80c = \x{100}\n&lt;/code&gt; , but &lt;code&gt;$a&lt;/code&gt; will stay byte-encoded.</source>
          <target state="translated">출력 문자열은 UTF-8로 인코딩 된 &lt;code&gt;ab\x80c = \x{100}\n&lt;/code&gt; 이지만 &lt;code&gt;$a&lt;/code&gt; 는 바이트 인코딩 된 상태로 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="2c2fa498e0e801d161dabd81ed0637a070d7eae3" translate="yes" xml:space="preserve">
          <source>the output string will be UTF-8-encoded &lt;code&gt;ab\x80c = \x{100}\n&lt;/code&gt;, but &lt;code&gt;$a&lt;/code&gt; will stay byte-encoded.</source>
          <target state="translated">출력 문자열은 UTF-8로 인코딩 된 &lt;code&gt;ab\x80c = \x{100}\n&lt;/code&gt; 이지만 &lt;code&gt;$a&lt;/code&gt; 는 바이트 인코딩 된 상태로 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="b4a8c523528b0d85f392e6ce4200ec9cbaf77eae" translate="yes" xml:space="preserve">
          <source>the paragraph text for the given POD paragraph command.</source>
          <target state="translated">지정된 POD 단락 명령의 단락 텍스트</target>
        </trans-unit>
        <trans-unit id="f822b49959962d70befcbfcacaf19dd9565d4689" translate="yes" xml:space="preserve">
          <source>the parser to provide an option for turning off whatever feature Y is (like expanding tabs in verbatim paragraphs), although it implicates that such an option</source>
          <target state="translated">구문 분석기는 Y가 무엇이든 기능을 끌 수있는 옵션을 제공하기위한 옵션입니다 (언어 적 단락의 탭 확장과 같은).</target>
        </trans-unit>
        <trans-unit id="88570ffa7933968d627f1b08ec22739c075ae741" translate="yes" xml:space="preserve">
          <source>the pattern explicitly mentions a code point that is above 255 (say by &lt;code&gt;\x{100}&lt;/code&gt; ); or</source>
          <target state="translated">패턴은 255보다 큰 코드 포인트를 명시 적으로 언급합니다 (예 : &lt;code&gt;\x{100}&lt;/code&gt; ). 또는</target>
        </trans-unit>
        <trans-unit id="5ebc56eade0f060f9f5ccc18ca98758fe940967c" translate="yes" xml:space="preserve">
          <source>the pattern explicitly mentions a code point that is above 255 (say by &lt;code&gt;\x{100}&lt;/code&gt;); or</source>
          <target state="translated">패턴은 255 이상의 코드 포인트를 명시 적으로 언급합니다 (예 : &lt;code&gt;\x{100}&lt;/code&gt; ). 또는</target>
        </trans-unit>
        <trans-unit id="d194fb71a02627a887a473822a155aa2e1f901a9" translate="yes" xml:space="preserve">
          <source>the pattern is encoded in UTF-8; or</source>
          <target state="translated">패턴은 UTF-8로 인코딩됩니다. 또는</target>
        </trans-unit>
        <trans-unit id="ce1751b05d1676c44a794cb888d1e90f057639f9" translate="yes" xml:space="preserve">
          <source>the pattern that matched the tag). For example, if the opening tag pattern is specified as &lt;code&gt;'{{\w+}}'&lt;/code&gt; and actually matched the opening tag &lt;code&gt;&quot;{{DATA}}&quot;&lt;/code&gt; , then the constructed closing tag would be &lt;code&gt;&quot;{{/DATA}}&quot;&lt;/code&gt; .</source>
          <target state="translated">태그와 일치하는 패턴). 예를 들어, 여는 태그 패턴이 &lt;code&gt;'{{\w+}}'&lt;/code&gt; 되고 실제로 여는 태그 &lt;code&gt;&quot;{{DATA}}&quot;&lt;/code&gt; 와 일치 하면 구성된 닫는 태그는 &lt;code&gt;&quot;{{/DATA}}&quot;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="bb9a9305d19a62486a52ef3dcc7174b59f9eb782" translate="yes" xml:space="preserve">
          <source>the pattern that matched the tag). For example, if the opening tag pattern is specified as &lt;code&gt;'{{\w+}}'&lt;/code&gt; and actually matched the opening tag &lt;code&gt;&quot;{{DATA}}&quot;&lt;/code&gt;, then the constructed closing tag would be &lt;code&gt;&quot;{{/DATA}}&quot;&lt;/code&gt;.</source>
          <target state="translated">태그와 일치하는 패턴). 예를 들어 여는 태그 패턴이 &lt;code&gt;'{{\w+}}'&lt;/code&gt; 되고 실제로 여는 태그 &lt;code&gt;&quot;{{DATA}}&quot;&lt;/code&gt; 와 일치 하면 생성 된 닫는 태그는 &lt;code&gt;&quot;{{/DATA}}&quot;&lt;/code&gt; 가 됩니다.</target>
        </trans-unit>
        <trans-unit id="e12980f98fa4e49f81778fa3eda24b699b14806c" translate="yes" xml:space="preserve">
          <source>the pattern uses &lt;a href=&quot;#%28%3F%5B-%5D%29&quot;&gt;&quot;&lt;code&gt;(?[ ])&lt;/code&gt;&quot;&lt;/a&gt;</source>
          <target state="translated">패턴은 &lt;a href=&quot;#%28%3F%5B-%5D%29&quot;&gt;&quot; &lt;code&gt;(?[ ])&lt;/code&gt; &quot;를 사용합니다.&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="805958852b9fabd97d8cb3a18bac20800a22b67b" translate="yes" xml:space="preserve">
          <source>the pattern uses &lt;a href=&quot;#(%3f%5b-%5d)&quot;&gt;(?[ ])&lt;/a&gt;</source>
          <target state="translated">패턴은 &lt;a href=&quot;#(%3f%5b-%5d)&quot;&gt;(? [])를 사용합니다.&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="45d1b9c98ec12cdba38fcccd9f5c31901700c61e" translate="yes" xml:space="preserve">
          <source>the pattern uses &lt;a href=&quot;#Script-Runs&quot;&gt;&lt;code&gt;(*script_run: ...)&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">패턴은 &lt;a href=&quot;#Script-Runs&quot;&gt; &lt;code&gt;(*script_run: ...)&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a8bb7e10331595813f75125fc26a7f202e7e37c1" translate="yes" xml:space="preserve">
          <source>the pattern uses a Unicode break (&lt;code&gt;\b{...}&lt;/code&gt; or &lt;code&gt;\B{...}&lt;/code&gt; ); or</source>
          <target state="translated">패턴은 유니 코드 구분 ( &lt;code&gt;\b{...}&lt;/code&gt; 또는 &lt;code&gt;\B{...}&lt;/code&gt; )을 사용합니다. 또는</target>
        </trans-unit>
        <trans-unit id="f2f2c22a430f50aa4219ed51f2a25b02249c0be9" translate="yes" xml:space="preserve">
          <source>the pattern uses a Unicode break (&lt;code&gt;\b{...}&lt;/code&gt; or &lt;code&gt;\B{...}&lt;/code&gt;); or</source>
          <target state="translated">패턴은 유니 코드 구분 ( &lt;code&gt;\b{...}&lt;/code&gt; 또는 &lt;code&gt;\B{...}&lt;/code&gt; )을 사용합니다. 또는</target>
        </trans-unit>
        <trans-unit id="a330eac785acc5b1bb1635b3789e2d14f4710fa2" translate="yes" xml:space="preserve">
          <source>the pattern uses a Unicode name (&lt;code&gt;\N{...}&lt;/code&gt; ); or</source>
          <target state="translated">패턴은 유니 코드 이름 ( &lt;code&gt;\N{...}&lt;/code&gt; )을 사용합니다. 또는</target>
        </trans-unit>
        <trans-unit id="9480c5100c7a0bf11df931665793aa7233347e66" translate="yes" xml:space="preserve">
          <source>the pattern uses a Unicode name (&lt;code&gt;\N{...}&lt;/code&gt;); or</source>
          <target state="translated">패턴은 유니 코드 이름 ( &lt;code&gt;\N{...}&lt;/code&gt; )을 사용합니다. 또는</target>
        </trans-unit>
        <trans-unit id="319de4125fd648dad000c6e1c9a4045715bad67c" translate="yes" xml:space="preserve">
          <source>the pattern uses a Unicode property (&lt;code&gt;\p{...}&lt;/code&gt; or &lt;code&gt;\P{...}&lt;/code&gt; ); or</source>
          <target state="translated">패턴은 유니 코드 속성 ( &lt;code&gt;\p{...}&lt;/code&gt; 또는 &lt;code&gt;\P{...}&lt;/code&gt; )을 사용합니다. 또는</target>
        </trans-unit>
        <trans-unit id="20491bd3313f19bce8377448dbe3596077438d9e" translate="yes" xml:space="preserve">
          <source>the pattern uses a Unicode property (&lt;code&gt;\p{...}&lt;/code&gt; or &lt;code&gt;\P{...}&lt;/code&gt;); or</source>
          <target state="translated">패턴은 유니 코드 속성 ( &lt;code&gt;\p{...}&lt;/code&gt; 또는 &lt;code&gt;\P{...}&lt;/code&gt; )을 사용합니다. 또는</target>
        </trans-unit>
        <trans-unit id="953fba431cfe195c351926c788501983650a8200" translate="yes" xml:space="preserve">
          <source>the perlfaq1 manpage: General Questions About Perl</source>
          <target state="translated">perlfaq1 맨 페이지 : Perl에 대한 일반적인 질문</target>
        </trans-unit>
        <trans-unit id="c962ba6946dbfccd85f3f5271a7003191ebd8887" translate="yes" xml:space="preserve">
          <source>the perlfaq2 manpage: Obtaining and Learning about Perl</source>
          <target state="translated">perlfaq2 맨 페이지 : Perl 획득 및 학습</target>
        </trans-unit>
        <trans-unit id="55228c77c8f20b7e875b18ee26f839f3183d399f" translate="yes" xml:space="preserve">
          <source>the perlfaq3 manpage: Programming Tools</source>
          <target state="translated">perlfaq3 맨 페이지 : 프로그래밍 도구</target>
        </trans-unit>
        <trans-unit id="c72ba9d1250ab34429dfe558dcf1ad599418504b" translate="yes" xml:space="preserve">
          <source>the perlfaq4 manpage: Data Manipulation</source>
          <target state="translated">perlfaq4 맨 페이지 : 데이터 조작</target>
        </trans-unit>
        <trans-unit id="05f2cb3f31b45754271926a93a37e613128fc1a3" translate="yes" xml:space="preserve">
          <source>the perlfaq5 manpage: Files and Formats</source>
          <target state="translated">perlfaq5 맨 페이지 : 파일 및 형식</target>
        </trans-unit>
        <trans-unit id="68004027bca85f0a1316b9b13a10b7b5846e0a1b" translate="yes" xml:space="preserve">
          <source>the perlfaq6 manpage: Regular Expressions</source>
          <target state="translated">perlfaq6 맨 페이지 : 정규식</target>
        </trans-unit>
        <trans-unit id="244f6e549e1a7c9b4840cdb2b7c4f9d9cf311f72" translate="yes" xml:space="preserve">
          <source>the perlfaq7 manpage: General Perl Language Issues</source>
          <target state="translated">perlfaq7 맨 페이지 : 일반 Perl 언어 문제</target>
        </trans-unit>
        <trans-unit id="b09ef579f2deb212ce34e20f6e0845f53a94647e" translate="yes" xml:space="preserve">
          <source>the perlfaq8 manpage: System Interaction</source>
          <target state="translated">perlfaq8 맨 페이지 : 시스템 상호 작용</target>
        </trans-unit>
        <trans-unit id="bbac669f56b77bc0a865f02b9aa3ccb0fa2fd2de" translate="yes" xml:space="preserve">
          <source>the perlfaq9 manpage: Web, Email and Networking</source>
          <target state="translated">perlfaq9 맨 페이지 : 웹, 이메일 및 네트워킹</target>
        </trans-unit>
        <trans-unit id="6bfc9a7a2833aaf0aa50c76f44094717b420d8b5" translate="yes" xml:space="preserve">
          <source>the pref information as a hashref, suitable for e.g. passing to Kwalify</source>
          <target state="translated">Kwalify에 전달하기에 적합한 해시 참조로서의 pref 정보</target>
        </trans-unit>
        <trans-unit id="d6f629b5712722c77da1582162b0d1da4ce910df" translate="yes" xml:space="preserve">
          <source>the prefix substring (if any),</source>
          <target state="translated">접두사 부분 문자열 (있는 경우)</target>
        </trans-unit>
        <trans-unit id="c7e0fd34e186fae12bf85657d77257670a5ce766" translate="yes" xml:space="preserve">
          <source>the processing of the declaration. In particular, this means that a subroutine reference will probably be for an undefined subroutine, even if this declaration is actually part of the definition.</source>
          <target state="translated">선언 처리 특히, 이는이 선언이 실제로 정의의 일부인 경우에도 서브 루틴 참조가 정의되지 않은 서브 루틴에 대한 것일 수 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="619fcabe5fc1a6adf037551b24229273d938e85e" translate="yes" xml:space="preserve">
          <source>the program's command name itself. See &lt;a href=&quot;#%240&quot;&gt;&quot;$0&quot;&lt;/a&gt; for the command name.</source>
          <target state="translated">프로그램의 명령 이름 자체. 명령 이름 은 &lt;a href=&quot;#%240&quot;&gt;&quot;$ 0&quot;&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b351ba6a6e6888ee3c37542cb09a710b8b82c7ea" translate="yes" xml:space="preserve">
          <source>the program's command name itself. See &lt;a href=&quot;#%240&quot;&gt;$0&lt;/a&gt; for the command name.</source>
          <target state="translated">프로그램의 명령 이름 자체 명령 이름 은 &lt;a href=&quot;#%240&quot;&gt;$ 0&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="3d7c7188cc51913744a65950d8ac98c6b2024d7e" translate="yes" xml:space="preserve">
          <source>the record separator string is not supported by this module. It will probably produce a reasonable result, but what this result will be may change in a future version. Use 'splice' to insert records or to replace one record with several.</source>
          <target state="translated">이 모듈은 레코드 분리 자 문자열을 지원하지 않습니다. 아마도 합리적인 결과를 낳을 것이지만,이 결과는 향후 버전에서 변경 될 수 있습니다. '스플 라이스'를 사용하여 레코드를 삽입하거나 한 레코드를 여러 레코드로 바꿉니다.</target>
        </trans-unit>
        <trans-unit id="9112f7c0bca72cadb1c4d4783a2f08bdb30a87f8" translate="yes" xml:space="preserve">
          <source>the regex (rather than the one that compiled it, where those differ). If necessary, you can use &lt;code&gt;local&lt;/code&gt; to localize changes to these variables to a specific scope before executing a regex.</source>
          <target state="translated">정규식 (컴파일 한 것이 아니라 서로 다른 경우). 필요한 경우 정규식을 실행하기 전에 &lt;code&gt;local&lt;/code&gt; 을 사용 하여 이러한 변수의 변경 사항을 특정 범위로 지역화 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d9590ce68e648fe5245544ed53294f3198783eab" translate="yes" xml:space="preserve">
          <source>the remainder of the input text,</source>
          <target state="translated">입력 텍스트의 나머지</target>
        </trans-unit>
        <trans-unit id="897a76723399d66c2d581cd9b78fa1dd3b22a4aa" translate="yes" xml:space="preserve">
          <source>the replacement of &lt;code&gt;s///&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;s///&lt;/code&gt; 의 교체</target>
        </trans-unit>
        <trans-unit id="2480552762ce0f7abb766d5aad5385526748ef25" translate="yes" xml:space="preserve">
          <source>the result is case-insensitive, but dotless and dotted I's are not distinguished</source>
          <target state="translated">결과는 대소 문자를 구분하지 않지만 점이 없으며 점으로 구분됩니다.</target>
        </trans-unit>
        <trans-unit id="e02477c839224237a3c3acbfe105933f3d8288fa" translate="yes" xml:space="preserve">
          <source>the result is not fully case-insensitive, but dotless and dotted I's are distinguished</source>
          <target state="translated">결과는 대소 문자를 구분하지 않지만 점이없는 점과 점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="0fe1d2372ef544a5efce8a965e686132c2b4c0e1" translate="yes" xml:space="preserve">
          <source>the result will be false).</source>
          <target state="translated">결과는 거짓입니다).</target>
        </trans-unit>
        <trans-unit id="b06be03c9501d35691a73d29665e3b477dbd827b" translate="yes" xml:space="preserve">
          <source>the result will be the undefined value).</source>
          <target state="translated">결과는 정의되지 않은 값이됩니다).</target>
        </trans-unit>
        <trans-unit id="27760396d0989c824fad36d89d509e322049bf0f" translate="yes" xml:space="preserve">
          <source>the result will be this:</source>
          <target state="translated">결과는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="367913a66fb3ed48526d213b1374566f40feb169" translate="yes" xml:space="preserve">
          <source>the result will be true).</source>
          <target state="translated">결과는 사실입니다).</target>
        </trans-unit>
        <trans-unit id="5be9ceecc2f03bc42e4d234aec808162f9c2f9d1" translate="yes" xml:space="preserve">
          <source>the result would be:</source>
          <target state="translated">결과는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="241bdcd79cc64588f799c8af99318c6a86f527b4" translate="yes" xml:space="preserve">
          <source>the returned arrays look like this:</source>
          <target state="translated">반환 된 배열은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4b13e4f057405f08d33690de1235c5ad2d9163da" translate="yes" xml:space="preserve">
          <source>the right delimiter of the first block of the operation,</source>
          <target state="translated">연산의 첫 번째 블록의 오른쪽 구분 기호</target>
        </trans-unit>
        <trans-unit id="60b10a956ccb270d29db4fedcf97954e7d906c61" translate="yes" xml:space="preserve">
          <source>the right delimiter of the second block of the operation (if any),</source>
          <target state="translated">작업의 두 번째 블록의 오른쪽 구분 기호 (있는 경우)</target>
        </trans-unit>
        <trans-unit id="ad88a8d6474f71e4dc65118e206ccce36d69c740" translate="yes" xml:space="preserve">
          <source>the right operand. That makes the order of the operands to the smartmatch operand often opposite that of the regular match operator. In other words, the &quot;smaller&quot; thing is usually placed in the left operand and the larger one in the right.</source>
          <target state="translated">올바른 피연산자. 이는 피연산자의 순서를 스마트 매치 피연산자에 대한 규칙으로 종종 정규 일치 연산자와 반대입니다. 다시 말해, &quot;더 작은&quot;것은 일반적으로 왼쪽 피연산자에, 큰 것은 오른쪽 피연산자에 배치됩니다.</target>
        </trans-unit>
        <trans-unit id="2cfb8735544da2f4a5ef7ac3c46c65d846bf586e" translate="yes" xml:space="preserve">
          <source>the run-time component of the &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; before those attributes will get applied. For example:</source>
          <target state="translated">해당 속성이 적용되기 전에 &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; 의 런타임 구성 요소 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4adbe9fee2eaa5b14cb05317bebc84aed0690141" translate="yes" xml:space="preserve">
          <source>the run-time component of the &lt;code&gt;my&lt;/code&gt; before those attributes will get applied. For example:</source>
          <target state="translated">&lt;code&gt;my&lt;/code&gt; before 해당 속성이 적용되는 런타임 구성 요소입니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6d94dd13fa0ce302453b0c13e41fb22167f72ae8" translate="yes" xml:space="preserve">
          <source>the same as</source>
          <target state="translated">와 동일</target>
        </trans-unit>
        <trans-unit id="80fcd9bedda2211b1f6f10894541429eff5c027c" translate="yes" xml:space="preserve">
          <source>the same as &lt;a href=&quot;http://man.he.net/man3/_control87&quot;&gt;_control87(3)&lt;/a&gt; of EMX. Takes integers as arguments, returns the previous coprocessor control word as an integer. Only bits in &lt;code&gt;new&lt;/code&gt; which are present in &lt;code&gt;mask&lt;/code&gt; are changed in the control word.</source>
          <target state="translated">EMX의 &lt;a href=&quot;http://man.he.net/man3/_control87&quot;&gt;_control87 (3)&lt;/a&gt; 과 동일 합니다. 정수를 인수로 취하고 이전 보조 프로세서 제어 단어를 정수로 리턴합니다. 에서만 비트 &lt;code&gt;new&lt;/code&gt; 존재하는 &lt;code&gt;mask&lt;/code&gt; 상기 제어 워드에 변경된다.</target>
        </trans-unit>
        <trans-unit id="5bc98976efd741af4ac9811ccd337d53abb45430" translate="yes" xml:space="preserve">
          <source>the same as calling a method with a fully-qualified name. See the earlier &lt;a href=&quot;#Inheritance&quot;&gt;&quot;Inheritance&quot;&lt;/a&gt; section for details.</source>
          <target state="translated">정규화 된 이름으로 메서드를 호출하는 것과 같습니다. 자세한 내용은 이전 &lt;a href=&quot;#Inheritance&quot;&gt;&quot;상속&quot;&lt;/a&gt; 섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="4a54b07cf28d2bc23ffe3bae6be39ad94b599265" translate="yes" xml:space="preserve">
          <source>the same as deleting the first quote-like pattern. For instance, if &lt;code&gt;$text&lt;/code&gt; contained the string:</source>
          <target state="translated">첫 번째 따옴표와 같은 패턴을 삭제하는 것과 같습니다. 예를 들어 &lt;code&gt;$text&lt;/code&gt; 에 문자열이 포함 된 경우 :</target>
        </trans-unit>
        <trans-unit id="4469a15edc678368007d1292ad39f49f19322ee8" translate="yes" xml:space="preserve">
          <source>the same as other handles and so can be compared to other handles with C&amp;lt;==&amp;gt;.</source>
          <target state="translated">다른 핸들과 동일하므로 C &amp;lt;==&amp;gt; 인 다른 핸들과 비교할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6b5e2a5e0bc0ec284b2d2c3c088213d01cf46e05" translate="yes" xml:space="preserve">
          <source>the same as saying</source>
          <target state="translated">말하는 것과 동일</target>
        </trans-unit>
        <trans-unit id="7ae8ddf779bd020abfea204ffb2252e0dbef0c38" translate="yes" xml:space="preserve">
          <source>the same as those on the command line.</source>
          <target state="translated">명령 줄에있는 것과 동일합니다.</target>
        </trans-unit>
        <trans-unit id="bec4472defb167aab839db0f227cd83d65a998d5" translate="yes" xml:space="preserve">
          <source>the same as writing:</source>
          <target state="translated">글쓰기와 동일 :</target>
        </trans-unit>
        <trans-unit id="f928cb2e61789033643a88e1121c24fc6aa53ad7" translate="yes" xml:space="preserve">
          <source>the same thing as &lt;code&gt;$array-&amp;gt;[$x]&lt;/code&gt; here:</source>
          <target state="translated">&lt;code&gt;$array-&amp;gt;[$x]&lt;/code&gt; 와 같은 것 :</target>
        </trans-unit>
        <trans-unit id="91044897520a9ec35dfefe133af9d3a8b6e5c7f7" translate="yes" xml:space="preserve">
          <source>the same way as a &lt;code&gt;(?{ &lt;i&gt;code&lt;/i&gt; })&lt;/code&gt; code block as described above, except that its return value, rather than being assigned to &lt;code&gt;$^R&lt;/code&gt;, is treated as a pattern, compiled if it's a string (or used as-is if its a qr// object), then matched as if it were inserted instead of this construct.</source>
          <target state="translated">&lt;code&gt;$^R&lt;/code&gt; 에 할당되지 않고 반환 값 이 패턴으로 처리되고 문자열이면 컴파일 된다는 점을 제외하면 위에서 설명한 &lt;code&gt;(?{ &lt;i&gt;code&lt;/i&gt; })&lt;/code&gt; 코드 블록과 동일한 방식 입니다 (또는 qr // 객체),이 구문 대신 삽입 된 것처럼 일치합니다.</target>
        </trans-unit>
        <trans-unit id="7166971113169815fd6133fa5f7f6afb0631ef1f" translate="yes" xml:space="preserve">
          <source>the same way as a &lt;code&gt;(?{ code })&lt;/code&gt; code block as described above, except that its return value, rather than being assigned to &lt;code&gt;$^R&lt;/code&gt; , is treated as a pattern, compiled if it's a string (or used as-is if its a qr// object), then matched as if it were inserted instead of this construct.</source>
          <target state="translated">&lt;code&gt;$^R&lt;/code&gt; 에 할당되지 않고 리턴 값 이 패턴으로 취급 된다는 점을 제외하고는 위에서 설명한대로 &lt;code&gt;(?{ code })&lt;/code&gt; 코드 블록과 같은 방식으로 문자열 인 경우 컴파일되거나 그것의 qr // 객체), 그런 다음이 구문 대신 삽입 된 것처럼 일치합니다.</target>
        </trans-unit>
        <trans-unit id="e89f36e67616aec49128c0b99a888a103286f66b" translate="yes" xml:space="preserve">
          <source>the same. The behavior is nearly the same as well: as of version 2.15, &lt;code&gt;cp&lt;/code&gt; will preserve the source file's permission bits like the shell utility &lt;code&gt;cp(1)&lt;/code&gt; would do, while &lt;code&gt;copy&lt;/code&gt; uses the default permissions for the target file (which may depend on the process' &lt;code&gt;&lt;a href=&quot;../functions/umask&quot;&gt;umask&lt;/a&gt;&lt;/code&gt;, file ownership, inherited ACLs, etc.). If an error occurs in setting permissions, &lt;code&gt;cp&lt;/code&gt; will return 0, regardless of whether the file was successfully copied.</source>
          <target state="translated">똑같다. 동작은 거의 동일합니다. 버전 2.15부터 &lt;code&gt;cp&lt;/code&gt; 는 쉘 유틸리티 &lt;code&gt;cp(1)&lt;/code&gt; 와 같이 소스 파일의 권한 비트를 유지 하지만 &lt;code&gt;copy&lt;/code&gt; 는 대상 파일의 기본 권한을 사용합니다 (프로세스에 따라 다름). ' &lt;code&gt;&lt;a href=&quot;../functions/umask&quot;&gt;umask&lt;/a&gt;&lt;/code&gt; , 파일 소유권, 상속 된 ACL 등). 권한 설정에 오류가 발생 하면 파일이 성공적으로 복사되었는지 여부에 관계없이 &lt;code&gt;cp&lt;/code&gt; 는 0을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="32ba072738fcf9ec1cd0df337aebaab029d1f611" translate="yes" xml:space="preserve">
          <source>the same. The behavior is nearly the same as well: as of version 2.15, &lt;code&gt;cp&lt;/code&gt; will preserve the source file's permission bits like the shell utility &lt;code&gt;cp(1)&lt;/code&gt; would do, while &lt;code&gt;copy&lt;/code&gt; uses the default permissions for the target file (which may depend on the process' &lt;code&gt;umask&lt;/code&gt;, file ownership, inherited ACLs, etc.). If an error occurs in setting permissions, &lt;code&gt;cp&lt;/code&gt; will return 0, regardless of whether the file was successfully copied.</source>
          <target state="translated">똑같다. 동작도 거의 동일합니다. 버전 2.15부터 &lt;code&gt;cp&lt;/code&gt; 는 쉘 유틸리티 &lt;code&gt;cp(1)&lt;/code&gt; 처럼 소스 파일의 권한 비트를 보존하는 반면 &lt;code&gt;copy&lt;/code&gt; 는 대상 파일에 대한 기본 권한을 사용합니다 (프로세스에 따라 달라질 수 있음). ' &lt;code&gt;umask&lt;/code&gt; , 파일 소유권, 상속 된 ACL 등). 권한 설정에 오류가 발생 하면 파일이 성공적으로 복사되었는지 여부에 관계없이 &lt;code&gt;cp&lt;/code&gt; 는 0을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="bf9d556cf0621f4c68ec518e9dbcab9943fe668e" translate="yes" xml:space="preserve">
          <source>the same:</source>
          <target state="translated">똑같다:</target>
        </trans-unit>
        <trans-unit id="b206e7d3cb65a64440529b75deccaa82d556a5da" translate="yes" xml:space="preserve">
          <source>the scope of $answer extends from its declaration through the rest of that conditional, including any &lt;code&gt;elsif&lt;/code&gt; and &lt;code&gt;else&lt;/code&gt; clauses, but not beyond it. See &lt;a href=&quot;perlsyn#Simple-Statements&quot;&gt;&quot;Simple Statements&quot; in perlsyn&lt;/a&gt; for information on the scope of variables in statements with modifiers.</source>
          <target state="translated">$ answer의 범위는 선언에서 &lt;code&gt;elsif&lt;/code&gt; 및 &lt;code&gt;else&lt;/code&gt; 절을 포함하여 나머지 조건부까지 확장 되지만 그 이상은 아닙니다. 수정자가있는 명령문의 변수 범위에 대한 정보 &lt;a href=&quot;perlsyn#Simple-Statements&quot;&gt;는 perlsyn의 &quot;단순 명령문&quot;을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="22e84aae25abedf582a9044f2441d71f8b951ea0" translate="yes" xml:space="preserve">
          <source>the scope of $answer extends from its declaration through the rest of that conditional, including any &lt;code&gt;elsif&lt;/code&gt; and &lt;code&gt;else&lt;/code&gt; clauses, but not beyond it. See &lt;a href=&quot;perlsyn#Simple-Statements&quot;&gt;Simple Statements in perlsyn&lt;/a&gt; for information on the scope of variables in statements with modifiers.</source>
          <target state="translated">$ answer의 범위는 선언에서 &lt;code&gt;elsif&lt;/code&gt; 및 &lt;code&gt;else&lt;/code&gt; 절을 포함한 나머지 조건부까지 확장 되지만 그 범위를 넘어서는 안됩니다. 수정자가있는 명령문의 변수 범위에 대한 정보 &lt;a href=&quot;perlsyn#Simple-Statements&quot;&gt;는 perlsyn의 단순 명령문을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="baa05056e9f40151df0cbff4c98ca1c83f4d8879" translate="yes" xml:space="preserve">
          <source>the scope of $i extends to the end of the loop, but not beyond it, rendering the value of $i inaccessible within &lt;code&gt;some_function()&lt;/code&gt; .</source>
          <target state="translated">$ i의 범위는 루프의 끝까지 확장되지만 그 이상은 아닙니다 . &lt;code&gt;some_function()&lt;/code&gt; 내에서 $ i의 값에 액세스 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="78b966550685330c11c45953edfc460c6eaa28ad" translate="yes" xml:space="preserve">
          <source>the scope of $i extends to the end of the loop, but not beyond it, rendering the value of $i inaccessible within &lt;code&gt;some_function()&lt;/code&gt;.</source>
          <target state="translated">$ i의 범위는 루프의 끝까지 확장되지만 그 이상은 아니지만 &lt;code&gt;some_function()&lt;/code&gt; 내에서 $ i 값에 액세스 할 수 없게됩니다 .</target>
        </trans-unit>
        <trans-unit id="0ea8f8d788deb7fb70a6641a871bdc6c17293aa9" translate="yes" xml:space="preserve">
          <source>the scope of $line extends from its declaration throughout the rest of the loop construct (including the &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; clause), but not beyond it. Similarly, in the conditional</source>
          <target state="translated">$ line의 범위는 선언에서 나머지 루프 구문 ( &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; 절 포함) 전반에 걸쳐 적용 되지만 그 범위를 넘어서는 안됩니다. 마찬가지로 조건부에서</target>
        </trans-unit>
        <trans-unit id="25227713430f6353006e81cb17a7a4d615ac7291" translate="yes" xml:space="preserve">
          <source>the scope of $line extends from its declaration throughout the rest of the loop construct (including the &lt;code&gt;continue&lt;/code&gt; clause), but not beyond it. Similarly, in the conditional</source>
          <target state="translated">$ line의 범위는 루프 구조의 나머지 부분 ( &lt;code&gt;continue&lt;/code&gt; 절 포함) 전체에 걸쳐 선언에서 확장 되지만 그 이상은 아닙니다. 마찬가지로 조건부에서</target>
        </trans-unit>
        <trans-unit id="3f6957153140ae22aa9fb9f71b401aed8cd16dbb" translate="yes" xml:space="preserve">
          <source>the script</source>
          <target state="translated">스크립트</target>
        </trans-unit>
        <trans-unit id="7da89157d34955ad49945f6b9e381b3b8cdb2cc8" translate="yes" xml:space="preserve">
          <source>the script itself changes the current working directory (see &lt;a href=&quot;../functions/chdir&quot;&gt;chdir&lt;/a&gt;)</source>
          <target state="translated">스크립트 자체는 현재 작업 디렉토리를 변경합니다 ( &lt;a href=&quot;../functions/chdir&quot;&gt;chdir&lt;/a&gt; 참조 )</target>
        </trans-unit>
        <trans-unit id="435a6b208201d36b05ef575faa9c7def8dfb7d3d" translate="yes" xml:space="preserve">
          <source>the script itself changes the current working directory (see &lt;a href=&quot;perlfunc#chdir&quot;&gt;&quot;chdir&quot; in perlfunc&lt;/a&gt;)</source>
          <target state="translated">스크립트 자체가 현재 작업 디렉토리를 변경합니다 ( &lt;a href=&quot;perlfunc#chdir&quot;&gt;perlfunc의 &quot;chdir&quot;&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="449cd9f9078af9f79eb882318ecbc550b179c573" translate="yes" xml:space="preserve">
          <source>the script name does not contain a directory, then Perl translates the logical name DCL$PATH as a searchlist, using each translation as a directory in which to look for the script. In addition, if no file type is specified, Perl looks in each directory for a file matching the name specified, with a blank type, a type of</source>
          <target state="translated">스크립트 이름에 디렉토리가 없으면 Perl은 논리적 이름 DCL $ PATH를 검색 목록으로 변환하고 각 변환을 스크립트를 찾을 디렉토리로 사용합니다. 또한 파일 유형이 지정되지 않은 경우 Perl은 각 디렉토리에서 지정된 이름과 일치하는 파일을 찾습니다.</target>
        </trans-unit>
        <trans-unit id="10c6aaa2aa56b4f5e5a61251f8e8a6475ffdd863" translate="yes" xml:space="preserve">
          <source>the second &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re&lt;/code&gt; does an implicit &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; re '/u'&lt;/code&gt; .</source>
          <target state="translated">두 번째 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re&lt;/code&gt; 는 암시 적 &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; re '/u'&lt;/code&gt; 를 수행 합니다.</target>
        </trans-unit>
        <trans-unit id="c2af5e39396a8ea136e313fc7b56827377df2294" translate="yes" xml:space="preserve">
          <source>the second &lt;code&gt;use re&lt;/code&gt; does an implicit &lt;code&gt;no re '/u'&lt;/code&gt;.</source>
          <target state="translated">두 번째 &lt;code&gt;use re&lt;/code&gt; 는 암시 적 &lt;code&gt;no re '/u'&lt;/code&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="c8b60cf9d6b9393388855bd42dd0e785a9edbee2" translate="yes" xml:space="preserve">
          <source>the second time</source>
          <target state="translated">두 번째</target>
        </trans-unit>
        <trans-unit id="9004c8b4d7ed31914a23183d7f8197de30d808db" translate="yes" xml:space="preserve">
          <source>the smart match does</source>
          <target state="translated">스마트 매치는</target>
        </trans-unit>
        <trans-unit id="69ddb9883cfc574376d43eb1558535cbc4c25d6f" translate="yes" xml:space="preserve">
          <source>the source name of a test to run</source>
          <target state="translated">실행할 테스트의 소스 이름</target>
        </trans-unit>
        <trans-unit id="5f48cb5160c020765cab557abdd0e5199b813f2e" translate="yes" xml:space="preserve">
          <source>the special symbol &lt;code&gt;(R)&lt;/code&gt;</source>
          <target state="translated">특수 기호 &lt;code&gt;(R)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="567e73c3060ea80a1dc0e2145bdf534f89c50aba" translate="yes" xml:space="preserve">
          <source>the specified dependencies with those declared by the package maintainer. In a future implementation this may be changed to override the original declaration.</source>
          <target state="translated">패키지 관리자에 의해 선언 된 것과의 의존성 향후 구현에서는 원래 선언을 무시하도록 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a0f147de093561ee2db74c7b373f2ce1b325340a" translate="yes" xml:space="preserve">
          <source>the stack size at build time might be different at run time, eg. the stack size may have been modified with ulimit(1). If it's larger at run time Storable may fail the freeze() or thaw() unnecessarily. If it's larger at build time Storable may segmentation fault when processing a deep structure at run time.</source>
          <target state="translated">빌드시 스택 크기는 런타임시 다를 수 있습니다. 스택 크기는 ulimit (1)로 수정되었을 수 있습니다. 런타임에 더 크면 Storable이 불필요하게 freeze () 또는 thaw ()에 실패 할 수 있습니다. 빌드 시간에 더 큰 경우 Storable은 런타임에 깊은 구조를 처리 할 때 세분화 오류가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5d41ddbc670b49a16ddece4abbfb35ed7961a884" translate="yes" xml:space="preserve">
          <source>the stack size might be different in a thread.</source>
          <target state="translated">스택 크기는 스레드에서 다를 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="42c5a1faa14a0d961afee6ffbea9c14d7c74f8e9" translate="yes" xml:space="preserve">
          <source>the subroutine is not an XSUB (since &lt;code&gt;START&lt;/code&gt; and &lt;code&gt;ROOT&lt;/code&gt; are non-zero, and &lt;code&gt;XSUB&lt;/code&gt; is not listed, and is thus null);</source>
          <target state="translated">서브 루틴은 XSUB가 아닙니다 ( &lt;code&gt;START&lt;/code&gt; 및 &lt;code&gt;ROOT&lt;/code&gt; 가 0 이 아니므로 &lt;code&gt;XSUB&lt;/code&gt; 가 나열되지 않으므로 널임 ).</target>
        </trans-unit>
        <trans-unit id="10fe1ebc16aeab11a3ad827ebaddc82decca14de" translate="yes" xml:space="preserve">
          <source>the substring is also matched by an opposite (right or left) delimiter bracket</source>
          <target state="translated">하위 문자열은 반대 (오른쪽 또는 왼쪽) 구분 기호 대괄호와도 일치합니다.</target>
        </trans-unit>
        <trans-unit id="31843bb5ce90f38eb71cec4b5f5deffaacdc2b46" translate="yes" xml:space="preserve">
          <source>the taint-check warnings.</source>
          <target state="translated">오염 검사 경고.</target>
        </trans-unit>
        <trans-unit id="dcde512fbbc017dd10c0c524e289f30144aabb32" translate="yes" xml:space="preserve">
          <source>the target string is encoded in UTF-8; or</source>
          <target state="translated">대상 문자열은 UTF-8로 인코딩됩니다. 또는</target>
        </trans-unit>
        <trans-unit id="78afcfad97482e9240ebe12dabc194b0f2c3b3ec" translate="yes" xml:space="preserve">
          <source>the test, not</source>
          <target state="translated">테스트가 아닌</target>
        </trans-unit>
        <trans-unit id="2d6be7e9a29d2284e4a1c1d564d8757213f95f64" translate="yes" xml:space="preserve">
          <source>the text between the opening and closing tags</source>
          <target state="translated">여는 태그와 닫는 태그 사이의 텍스트</target>
        </trans-unit>
        <trans-unit id="a58d49e34d8f22b121d4886a9dee68a05b2211a0" translate="yes" xml:space="preserve">
          <source>the text of the first block of the operation (that is, the contents of a quote, the regex of a match or substitution or the target list of a translation),</source>
          <target state="translated">연산의 첫 번째 블록의 텍스트 (즉, 인용의 내용, 일치 또는 대체의 정규식 또는 번역의 대상 목록)</target>
        </trans-unit>
        <trans-unit id="f5cb25bf17d198d49f2635bab666ce500ee6f816" translate="yes" xml:space="preserve">
          <source>the text of the second block of the operation (that is, the replacement of a substitution or the translation list of a translation),</source>
          <target state="translated">오퍼레이션의 두 번째 블록의 텍스트 (즉, 대체 대체 또는 번역의 번역 목록)</target>
        </trans-unit>
        <trans-unit id="54e46f0757b022318bd5a239679cf0f1339e841d" translate="yes" xml:space="preserve">
          <source>the tied array will appear to contain &lt;code&gt;(&quot;Gold&quot;, &quot;Frankincense&quot;,
&quot;Myrrh&quot;)&lt;/code&gt; . If you set &lt;code&gt;autochomp&lt;/code&gt; to a false value, the record separator will not be removed. If the file above was tied with</source>
          <target state="translated">묶인 배열은 &lt;code&gt;(&quot;Gold&quot;, &quot;Frankincense&quot;, &quot;Myrrh&quot;)&lt;/code&gt; 를 포함하는 것으로 보입니다 . 를 설정하면 &lt;code&gt;autochomp&lt;/code&gt; 을 거짓 값으로, 레코드 분리는 제거되지 않습니다. 위 파일이 묶인 경우</target>
        </trans-unit>
        <trans-unit id="2ff132cec051eee79b827f4cd78cb71b0cc3679b" translate="yes" xml:space="preserve">
          <source>the tied array will appear to contain &lt;code&gt;(&quot;Gold&quot;, &quot;Frankincense&quot;, &quot;Myrrh&quot;)&lt;/code&gt;. If you set &lt;code&gt;autochomp&lt;/code&gt; to a false value, the record separator will not be removed. If the file above was tied with</source>
          <target state="translated">묶인 배열은 &lt;code&gt;(&quot;Gold&quot;, &quot;Frankincense&quot;, &quot;Myrrh&quot;)&lt;/code&gt; 를 포함하는 것처럼 보입니다 . 를 설정하면 &lt;code&gt;autochomp&lt;/code&gt; 을 거짓 값으로, 레코드 분리는 제거되지 않습니다. 위의 파일이</target>
        </trans-unit>
        <trans-unit id="2fd283a094fc7f97781b054050f5816883290ed9" translate="yes" xml:space="preserve">
          <source>the trailing modifiers on the operation (if any).</source>
          <target state="translated">작업의 후행 수정 자 (있는 경우)</target>
        </trans-unit>
        <trans-unit id="a4ec6b78fa42f3cd953b215db4c6983e71fefe3b" translate="yes" xml:space="preserve">
          <source>the type specifier for files nor the name of the handle. It is the &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; operator applied to the handle FILE. It reads one line (well, record--see &lt;a href=&quot;perlvar#%24%2F&quot;&gt;&quot;$/&quot; in perlvar&lt;/a&gt;) from the handle FILE in scalar context, or</source>
          <target state="translated">파일의 유형 지정자 또는 핸들의 이름. 그것은 인 &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; 핸들 FILE인가 연산자. 스칼라 컨텍스트의 핸들 FILE에서 한 줄 (음, 레코드 &lt;a href=&quot;perlvar#%24%2F&quot;&gt;-perlvar의 &quot;$ /&quot;&lt;/a&gt; 참조)을 읽습니다.</target>
        </trans-unit>
        <trans-unit id="c2a06a77006eafdbaa9e871f0888edc9d2c95d03" translate="yes" xml:space="preserve">
          <source>the type specifier for files nor the name of the handle. It is the &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; operator applied to the handle FILE. It reads one line (well, record--see &lt;a href=&quot;perlvar#%24%2f&quot;&gt;$/ in perlvar&lt;/a&gt;) from the handle FILE in scalar context, or</source>
          <target state="translated">파일의 타입 지정자 또는 핸들의 이름 그것은 인 &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; 핸들 FILE인가 연산자. 스칼라 컨텍스트의 핸들 FILE에서 한 줄을 읽습니다 (음, 레코드 &lt;a href=&quot;perlvar#%24%2f&quot;&gt;-perlvar의 $ /&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="1c4360009fff54302b1156b6832fe5d026c5d637" translate="yes" xml:space="preserve">
          <source>the uncompressed data has been written to the output buffer - the size of &lt;code&gt;$output&lt;/code&gt; is unbounded.</source>
          <target state="translated">압축되지 않은 데이터가 출력 버퍼에 기록되었습니다 . &lt;code&gt;$output&lt;/code&gt; 의 크기 는 제한이 없습니다.</target>
        </trans-unit>
        <trans-unit id="72c4cb01ed9c295c259e9012dc844c21ed4b9c75" translate="yes" xml:space="preserve">
          <source>the user will see something like this:</source>
          <target state="translated">사용자는 다음과 같은 것을 보게 될 것입니다 :</target>
        </trans-unit>
        <trans-unit id="09d1d1059ffc788eba4027840dd9c61844d867ea" translate="yes" xml:space="preserve">
          <source>the value for that key is true (since it's not 0 or &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;), so the next skips that iteration and the loop goes to the next element.</source>
          <target state="translated">해당 키의 값은 true이므로 (0이 아니거나 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 이기 때문에) 다음은 해당 반복을 건너 뛰고 루프는 다음 요소로 이동합니다.</target>
        </trans-unit>
        <trans-unit id="c2543ae91169a19becb011bfd8da29ec62a8ec86" translate="yes" xml:space="preserve">
          <source>the value for that key is true (since it's not 0 or &lt;code&gt;undef&lt;/code&gt;), so the next skips that iteration and the loop goes to the next element.</source>
          <target state="translated">해당 키의 값은 true (0 또는 &lt;code&gt;undef&lt;/code&gt; 가 아니기 때문에)이므로 다음은 해당 반복을 건너 뛰고 루프는 다음 요소로 이동합니다.</target>
        </trans-unit>
        <trans-unit id="fe923301a11767676439948627df11b9a9b88012" translate="yes" xml:space="preserve">
          <source>the value of &lt;code&gt;SV&lt;/code&gt; will be restored using the stored value. It doesn't handle magic. Use &lt;code&gt;save_scalar&lt;/code&gt; if magic is affected.</source>
          <target state="translated">&lt;code&gt;SV&lt;/code&gt; 의 값은 저장된 값을 사용하여 복원됩니다. 마법을 다루지 않습니다. 마법이 영향을받는 경우 &lt;code&gt;save_scalar&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="10f60af7d3da39c8283e440b7b68c1b0162b43c3" translate="yes" xml:space="preserve">
          <source>the value to format. Where an argument is specified by an explicit index, this does not affect the normal order for the arguments, even when the explicitly specified index would have been the next argument.</source>
          <target state="translated">형식화 할 값 명시 적 색인에 의해 인수가 지정된 경우, 명시 적으로 지정된 색인이 다음 인수 일 때에도 인수의 정상적인 순서에 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="feb631c3518f36975ddf3388daec5c9e011d0e7d" translate="yes" xml:space="preserve">
          <source>the way &lt;a href=&quot;Test::Simple&quot;&gt;Test::Simple&lt;/a&gt; does. You can literally swap &lt;a href=&quot;Test::Simple&quot;&gt;Test::Simple&lt;/a&gt; out and put &lt;a href=&quot;Test::More&quot;&gt;Test::More&lt;/a&gt; in its place. That's just what we're going to do.</source>
          <target state="translated">&lt;a href=&quot;Test::Simple&quot;&gt;Test :: Simple이하&lt;/a&gt; 는 방식 입니다. 말 그대로 &lt;a href=&quot;Test::Simple&quot;&gt;Test :: Simple을&lt;/a&gt; 교체하고 &lt;a href=&quot;Test::More&quot;&gt;Test :: More&lt;/a&gt; 를 그 자리에 둘 수 있습니다 . 그것이 바로 우리가 할 일입니다.</target>
        </trans-unit>
        <trans-unit id="98edb59e477d5f73aabed933ed88c199f2e02581" translate="yes" xml:space="preserve">
          <source>the way you want.</source>
          <target state="translated">당신이 원하는 방식으로.</target>
        </trans-unit>
        <trans-unit id="fb6fef64bdf2aef98be4e3412576b2eb3744b578" translate="yes" xml:space="preserve">
          <source>them if you start &lt;code&gt;perl__.exe&lt;/code&gt; from a PM program which emulates a console window, like</source>
          <target state="translated">콘솔 창을 에뮬레이트하는 PM 프로그램에서 &lt;code&gt;perl__.exe&lt;/code&gt; 를 시작하면</target>
        </trans-unit>
        <trans-unit id="3357a0dbb533636fe93bb98a65677eb4dc6d5e09" translate="yes" xml:space="preserve">
          <source>them, in our case into octets. Unicode is (among other things) a codeset, UTF-8 is an encoding, and ISO-8859-1 (= latin 1) and ASCII are both codesets</source>
          <target state="translated">우리의 경우 옥텟으로. 유니 코드는 (무엇보다도) 코드 세트이고 UTF-8은 인코딩이며 ISO-8859-1 (= 라틴 1)과 ASCII는 둘 다 코드 세트입니다.</target>
        </trans-unit>
        <trans-unit id="6f8f8e9f767353d846d34ea5a451c83849c1b01b" translate="yes" xml:space="preserve">
          <source>then</source>
          <target state="translated">then</target>
        </trans-unit>
        <trans-unit id="88a7a77aa5c568f548a7b47a898fe68e7d901cc1" translate="yes" xml:space="preserve">
          <source>then $parser-&amp;gt;get_short_title on that document will return &quot;Hoo::Boy::Wowza&quot;.</source>
          <target state="translated">해당 문서의 $ parser-&amp;gt; get_short_title은 &quot;Hoo :: Boy :: Wowza&quot;를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="23f4cf92407a7fe5d8794a5c9a42f3e2ead3acdc" translate="yes" xml:space="preserve">
          <source>then $parser-&amp;gt;get_short_title on that document will return &quot;Hooboy, stuff wow yeah!&quot;. If the document starts with:</source>
          <target state="translated">해당 문서의 $ parser-&amp;gt; get_short_title은 &quot;Hooboy, stuff wow yeah!&quot;를 반환합니다. 문서가 다음으로 시작하는 경우 :</target>
        </trans-unit>
        <trans-unit id="29f40a8c4032e6fbcf21306bda70e2933fe3eafc" translate="yes" xml:space="preserve">
          <source>then &lt;code&gt;$a&lt;/code&gt; and &lt;code&gt;$b&lt;/code&gt; are &lt;code&gt;$main::a&lt;/code&gt; and &lt;code&gt;$main::b&lt;/code&gt; (or &lt;code&gt;$::a&lt;/code&gt; and &lt;code&gt;$::b&lt;/code&gt; ), but if you're in the &lt;code&gt;FooPack&lt;/code&gt; package, it's the same as typing</source>
          <target state="translated">다음 &lt;code&gt;$a&lt;/code&gt; 와 &lt;code&gt;$b&lt;/code&gt; 하다 &lt;code&gt;$main::a&lt;/code&gt; 와 &lt;code&gt;$main::b&lt;/code&gt; (또는 &lt;code&gt;$::a&lt;/code&gt; 및 &lt;code&gt;$::b&lt;/code&gt; ) 당신은에 있다면,하지만 &lt;code&gt;FooPack&lt;/code&gt; 의 패키지는 입력과 동일합니다</target>
        </trans-unit>
        <trans-unit id="d5a02d02cd5da551d503521fe8e892f975abdae4" translate="yes" xml:space="preserve">
          <source>then &lt;code&gt;$y&lt;/code&gt; is the number closest to zero, and with the same sign as &lt;code&gt;$mod&lt;/code&gt; , satisfying</source>
          <target state="translated">다음 &lt;code&gt;$y&lt;/code&gt; 숫자 제로에 가까운이며, 같은 기호 &lt;code&gt;$mod&lt;/code&gt; , 만족</target>
        </trans-unit>
        <trans-unit id="e43f8f8a0b30e5f8953286ad90511092a5d6aa64" translate="yes" xml:space="preserve">
          <source>then &lt;code&gt;$y&lt;/code&gt; is the number closest to zero, and with the same sign as &lt;code&gt;$mod&lt;/code&gt;, satisfying</source>
          <target state="translated">다음 &lt;code&gt;$y&lt;/code&gt; 숫자 제로에 가까운이며, 같은 기호 &lt;code&gt;$mod&lt;/code&gt; , 만족</target>
        </trans-unit>
        <trans-unit id="427cce61752fee17f0671abdaf38ee0fa428d694" translate="yes" xml:space="preserve">
          <source>then &lt;code&gt;%hash&lt;/code&gt; will have at least 200 buckets allocated for it--256 of them, in fact, since it rounds up to the next power of two. These buckets will be retained even if you do &lt;code&gt;%hash = ()&lt;/code&gt; , use &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;
%hash&lt;/code&gt; if you want to free the storage while &lt;code&gt;%hash&lt;/code&gt; is still in scope. You can't shrink the number of buckets allocated for the hash using &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt; in this way (but you needn't worry about doing this by accident, as trying has no effect). &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt; @array&lt;/code&gt; in an lvalue context is a syntax error.</source>
          <target state="translated">그러면 &lt;code&gt;%hash&lt;/code&gt; 는 적어도 200 개의 버킷을 할당하게되는데, 그 중 256 개는 다음 2의 거듭 제곱으로 올림되기 때문입니다. &lt;code&gt;%hash = ()&lt;/code&gt; 하더라도 이러한 버킷은 유지 되며, &lt;code&gt;%hash&lt;/code&gt; 가 여전히 범위에있는 동안 스토리지를 해제 하려면 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt; %hash&lt;/code&gt; 를 사용하십시오 . 이런 방식으로 &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt; 를 사용하여 해시에 할당 된 버킷 수를 줄일 수는 없습니다 (그러나 시도해도 아무런 효과가 없으므로 실수로이를 걱정할 필요는 없습니다). lvalue 컨텍스트의 &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt; @array&lt;/code&gt; @array 는 구문 오류입니다.</target>
        </trans-unit>
        <trans-unit id="0a4706c04d224c9ee392da7cf321cfda0cdbc86d" translate="yes" xml:space="preserve">
          <source>then &lt;code&gt;%hash&lt;/code&gt; will have at least 200 buckets allocated for it--256 of them, in fact, since it rounds up to the next power of two. These buckets will be retained even if you do &lt;code&gt;%hash = ()&lt;/code&gt; , use &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;
%hash&lt;/code&gt; if you want to free the storage while &lt;code&gt;%hash&lt;/code&gt; is still in scope. You can't shrink the number of buckets allocated for the hash using &lt;code&gt;&lt;a href=&quot;keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt; in this way (but you needn't worry about doing this by accident, as trying has no effect). &lt;code&gt;&lt;a href=&quot;keys&quot;&gt;keys&lt;/a&gt; @array&lt;/code&gt; in an lvalue context is a syntax error.</source>
          <target state="translated">그러면 &lt;code&gt;%hash&lt;/code&gt; 는 적어도 200 개의 버킷을 할당하게되는데, 그 중 256 개는 다음 2의 거듭 제곱으로 올림되기 때문입니다. &lt;code&gt;%hash = ()&lt;/code&gt; 하더라도 이러한 버킷은 유지 되며, &lt;code&gt;%hash&lt;/code&gt; 가 여전히 범위에있는 동안 스토리지를 해제 하려면 &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt; %hash&lt;/code&gt; 를 사용하십시오 . 이런 방식으로 &lt;code&gt;&lt;a href=&quot;keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt; 를 사용하여 해시에 할당 된 버킷 수를 줄일 수는 없습니다 (그러나 시도해도 아무런 효과가 없으므로 실수로이를 걱정할 필요는 없습니다). lvalue 컨텍스트의 &lt;code&gt;&lt;a href=&quot;keys&quot;&gt;keys&lt;/a&gt; @array&lt;/code&gt; @array 는 구문 오류입니다.</target>
        </trans-unit>
        <trans-unit id="c40c63fb0d7c1dda78a73cff0abc53b520e51a14" translate="yes" xml:space="preserve">
          <source>then &lt;code&gt;%hash&lt;/code&gt; will have at least 200 buckets allocated for it--256 of them, in fact, since it rounds up to the next power of two. These buckets will be retained even if you do &lt;code&gt;%hash = ()&lt;/code&gt;, use &lt;code&gt;undef %hash&lt;/code&gt; if you want to free the storage while &lt;code&gt;%hash&lt;/code&gt; is still in scope. You can't shrink the number of buckets allocated for the hash using &lt;a href=&quot;#keys-HASH&quot;&gt;&lt;code&gt;keys&lt;/code&gt;&lt;/a&gt; in this way (but you needn't worry about doing this by accident, as trying has no effect). &lt;code&gt;keys @array&lt;/code&gt; in an lvalue context is a syntax error.</source>
          <target state="translated">그러면 &lt;code&gt;%hash&lt;/code&gt; 는 최소한 200 개의 버킷이 할당됩니다. 실제로 256 개의 버킷이 다음 2의 거듭 제곱으로 반올림되기 때문입니다. 이러한 버킷은 &lt;code&gt;%hash = ()&lt;/code&gt; 을 수행하더라도 유지됩니다. &lt;code&gt;%hash&lt;/code&gt; 가 범위 내에있는 동안 스토리지를 해제 하려면 &lt;code&gt;undef %hash&lt;/code&gt; 를 사용하십시오 . 이런 방식으로 &lt;a href=&quot;#keys-HASH&quot;&gt; &lt;code&gt;keys&lt;/code&gt; &lt;/a&gt; 를 사용하여 해시에 할당 된 버킷 수를 줄일 수 없습니다 (하지만 시도해도 효과가 없으므로 실수로 수행하는 것에 대해 걱정할 필요가 없습니다). lvalue 컨텍스트의 &lt;code&gt;keys @array&lt;/code&gt; 는 구문 오류입니다.</target>
        </trans-unit>
        <trans-unit id="e0e0f1b2564679b330f3326cd8ff2c67fa198367" translate="yes" xml:space="preserve">
          <source>then &lt;code&gt;&lt;a href=&quot;../functions/mkdir&quot;&gt;mkdir&lt;/a&gt;&lt;/code&gt; will attempt to create all the directories in the given path.</source>
          <target state="translated">다음 &lt;code&gt;&lt;a href=&quot;../functions/mkdir&quot;&gt;mkdir&lt;/a&gt;&lt;/code&gt; 주어진 경로에있는 모든 디렉토리를 작성하려고합니다.</target>
        </trans-unit>
        <trans-unit id="07f9429b97c09875ec099fb7f4d7f8efc6e3196e" translate="yes" xml:space="preserve">
          <source>then &lt;code&gt;&lt;a href=&quot;../functions/rmdir&quot;&gt;rmdir&lt;/a&gt;&lt;/code&gt; will attempt to delete everything inside the directory.</source>
          <target state="translated">그러면 &lt;code&gt;&lt;a href=&quot;../functions/rmdir&quot;&gt;rmdir&lt;/a&gt;&lt;/code&gt; 은 디렉토리 내의 모든 것을 삭제하려고 시도합니다.</target>
        </trans-unit>
        <trans-unit id="be79a8197efa4a6581e5f87f07d768e642f44dc3" translate="yes" xml:space="preserve">
          <source>then &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort()&lt;/a&gt;&lt;/code&gt;. If you have a choice, it's better to lowercase things to avoid the problems of the two Latin-1 characters whose uppercase is outside Latin-1: &quot;&amp;yuml;&quot; (small &lt;code&gt;y WITH DIAERESIS&lt;/code&gt;) and &quot;&amp;micro;&quot; (&lt;code&gt;MICRO SIGN&lt;/code&gt; ). If you do need to upppercase, you can; with a Unicode-enabled Perl, do:</source>
          <target state="translated">그런 다음 &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort()&lt;/a&gt;&lt;/code&gt; . 선택 사항이 있으면 대문자가 라틴 -1 외부인 두 라틴 -1 문자의 문제점을 피하기 위해 소문자를 사용하는 것이 좋습니다. &quot;&amp;yuml;&quot;(작은 &lt;code&gt;y WITH DIAERESIS&lt;/code&gt; ) 및 &quot;&amp;micro;&quot;( &lt;code&gt;MICRO SIGN&lt;/code&gt; ). 대문자를 사용해야하는 경우 다음을 수행 할 수 있습니다. 유니 코드 가능 Perl을 사용하여 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="67a5bc4e464cc4d66f6ae6f8e29e5bc482871605" translate="yes" xml:space="preserve">
          <source>then &lt;code&gt;mkdir&lt;/code&gt; will attempt to create all the directories in the given path.</source>
          <target state="translated">그런 다음 &lt;code&gt;mkdir&lt;/code&gt; 은 주어진 경로에 모든 디렉토리를 생성하려고 시도합니다.</target>
        </trans-unit>
        <trans-unit id="c4df6b08143f1ed133e0751bce9a14ce00f15fee" translate="yes" xml:space="preserve">
          <source>then &lt;code&gt;mypush()&lt;/code&gt; takes arguments exactly like &lt;code&gt;&lt;a href=&quot;functions/push&quot;&gt;push()&lt;/a&gt;&lt;/code&gt; does.</source>
          <target state="translated">그러면 &lt;code&gt;mypush()&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;functions/push&quot;&gt;push()&lt;/a&gt;&lt;/code&gt; 와 똑같은 인수를 취 합니다.</target>
        </trans-unit>
        <trans-unit id="42bc39f7d06f4f54a3b38c49edcb05a8c9e4d275" translate="yes" xml:space="preserve">
          <source>then &lt;code&gt;mypush()&lt;/code&gt; takes arguments exactly like &lt;code&gt;push()&lt;/code&gt; does.</source>
          <target state="translated">그런 다음 &lt;code&gt;mypush()&lt;/code&gt; 는 &lt;code&gt;push()&lt;/code&gt; 와 똑같은 인수를받습니다 .</target>
        </trans-unit>
        <trans-unit id="11aeb7c4fef07bda2267e6f9d0f586fa126a914f" translate="yes" xml:space="preserve">
          <source>then &lt;code&gt;rmdir&lt;/code&gt; will attempt to delete everything inside the directory.</source>
          <target state="translated">그러면 &lt;code&gt;rmdir&lt;/code&gt; 은 디렉토리 내의 모든 것을 삭제하려고 시도합니다.</target>
        </trans-unit>
        <trans-unit id="91284e1190449da8d0d4f91b5c110a9475b20ab3" translate="yes" xml:space="preserve">
          <source>then &lt;code&gt;sort()&lt;/code&gt;. If you have a choice, it's better to lowercase things to avoid the problems of the two Latin-1 characters whose uppercase is outside Latin-1: &quot;&amp;yuml;&quot; (small &lt;code&gt;y WITH DIAERESIS&lt;/code&gt;) and &quot;&amp;micro;&quot; (&lt;code&gt;MICRO SIGN&lt;/code&gt;). If you do need to upppercase, you can; with a Unicode-enabled Perl, do:</source>
          <target state="translated">그런 다음 &lt;code&gt;sort()&lt;/code&gt; . 선택할 수있는 경우 대문자가 Latin-1 밖에있는 두 개의 Latin-1 문자 인 &quot;&amp;yuml;&quot;(소형 &lt;code&gt;y WITH DIAERESIS&lt;/code&gt; ) 및 &quot;&amp;micro;&quot;( &lt;code&gt;MICRO SIGN&lt;/code&gt; ) 의 문제를 피하기 위해 소문자를 사용하는 것이 좋습니다 . 대문자가 필요하면 할 수 있습니다. 유니 코드 사용 가능 Perl을 사용하여 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="d4963e7b580a13c7a47350916f5f4701a5cea5b0" translate="yes" xml:space="preserve">
          <source>then a call to &lt;code&gt;extract_bracketed&lt;/code&gt; in a list context:</source>
          <target state="translated">그런 다음 목록 컨텍스트에서 &lt;code&gt;extract_bracketed&lt;/code&gt; 를 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="8fa8d133f35b2e1ecd715f6ea92a4465b64cd21e" translate="yes" xml:space="preserve">
          <source>then a link to it would look like this:</source>
          <target state="translated">그런 다음 링크는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c2d9821598cc4028dc478ca6b184ee82c9a150e8" translate="yes" xml:space="preserve">
          <source>then a reference to an array containing the string &lt;code&gt;&quot;turn it up to 11, man!&quot;&lt;/code&gt; would be passed as the last argument.</source>
          <target state="translated">그런 다음 문자열을 포함하는 배열에 대한 참조는 &lt;code&gt;&quot;turn it up to 11, man!&quot;&lt;/code&gt; 마지막 인수로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="daefb5fdb08ac51e4ca09289fd271c065db65227" translate="yes" xml:space="preserve">
          <source>then after the deletion it would contain:</source>
          <target state="translated">삭제 후에는 다음이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="16a5f58b325c405e1b9bf68a059e0e8cba7507e5" translate="yes" xml:space="preserve">
          <source>then answer a few questions and go out for coffee (possibly even in a different city).</source>
          <target state="translated">그런 다음 몇 가지 질문에 대답하고 커피를 마시 러 가십시오 (아마 다른 도시에서도 가능).</target>
        </trans-unit>
        <trans-unit id="c864362dfe8b6f418c3b8afbb4438cb559f4ad66" translate="yes" xml:space="preserve">
          <source>then any bareword that would NOT be interpreted as a subroutine call produces a compile-time error instead. The restriction lasts to the end of the enclosing block. An inner block may countermand this by saying &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; strict 'subs'&lt;/code&gt; .</source>
          <target state="translated">서브 루틴 호출로 해석되지 않는 베어 워드는 대신 컴파일 타임 오류를 생성합니다. 제한은 둘러싸는 블록의 끝까지 지속됩니다. 이너 블록은 말을하지하여이를 취소 할 수있다 &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; strict 'subs'&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2ac2fb81ac091a8e96335d20fdbc3d18b0882dec" translate="yes" xml:space="preserve">
          <source>then any bareword that would NOT be interpreted as a subroutine call produces a compile-time error instead. The restriction lasts to the end of the enclosing block. An inner block may countermand this by saying &lt;code&gt;no strict 'subs'&lt;/code&gt;.</source>
          <target state="translated">그러면 서브 루틴 호출로 해석되지 않는 모든 베어 워드는 대신 컴파일 타임 오류를 생성합니다. 제한은 둘러싸는 블록의 끝까지 지속됩니다. 내부 블록은 &lt;code&gt;no strict 'subs'&lt;/code&gt; 말하지 않음 으로써 이것을 반박 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2a6042bd89492effbfd5f6e8c4f5ed13a20bf888" translate="yes" xml:space="preserve">
          <source>then any variable mentioned from there to the end of the enclosing block must either refer to a lexical variable, be predeclared via &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; vars&lt;/code&gt; , or else must be fully qualified with the package name. A compilation error results otherwise. An inner block may countermand this with &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; strict 'vars'&lt;/code&gt; .</source>
          <target state="translated">다음 중 어휘 변수를 참조해야합니다 포함하는 블록의 끝까지 거기에서 언급 된 모든 변수를 통해 미리 선언 할 &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; vars&lt;/code&gt; , 또는 다른 패키지 이름을 정규화해야합니다. 그렇지 않으면 컴파일 오류가 발생합니다. 내부 블록은 &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; strict 'vars'&lt;/code&gt; &lt;a href=&quot;functions/no&quot;&gt;없이&lt;/a&gt; 이것을 막을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="275292c69d83924bbc6c523d9801aa638dfc5854" translate="yes" xml:space="preserve">
          <source>then any variable mentioned from there to the end of the enclosing block must either refer to a lexical variable, be predeclared via &lt;code&gt;our&lt;/code&gt; or &lt;code&gt;use vars&lt;/code&gt;, or else must be fully qualified with the package name. A compilation error results otherwise. An inner block may countermand this with &lt;code&gt;no strict 'vars'&lt;/code&gt;.</source>
          <target state="translated">그런 다음 여기에서 둘러싸는 블록의 끝까지 언급 된 모든 변수는 어휘 변수를 참조 하거나 , &lt;code&gt;our&lt;/code&gt; 를 통해 미리 선언 되거나 , &lt;code&gt;use vars&lt;/code&gt; 하거나, 그렇지 않으면 패키지 이름으로 정규화되어야합니다. 그렇지 않으면 컴파일 오류가 발생합니다. 내부 블록은 &lt;code&gt;no strict 'vars'&lt;/code&gt; 이것을 대응시킬 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2a57900be2b5fa8c20199347f883e5b7b3be9857" translate="yes" xml:space="preserve">
          <source>then call the appropriate routines, casting the returned &lt;code&gt;SV*&lt;/code&gt; to either an &lt;code&gt;AV*&lt;/code&gt; or &lt;code&gt;HV*&lt;/code&gt; , if required.</source>
          <target state="translated">그런 다음 필요한 경우 반환 된 &lt;code&gt;SV*&lt;/code&gt; 를 &lt;code&gt;AV*&lt;/code&gt; 또는 &lt;code&gt;HV*&lt;/code&gt; 로 캐스팅하여 적절한 루틴을 호출하십시오 .</target>
        </trans-unit>
        <trans-unit id="72d8f8ee63c1eb983caca42f4df44d0e26187e07" translate="yes" xml:space="preserve">
          <source>then call the appropriate routines, casting the returned &lt;code&gt;SV*&lt;/code&gt; to either an &lt;code&gt;AV*&lt;/code&gt; or &lt;code&gt;HV*&lt;/code&gt;, if required.</source>
          <target state="translated">그런 다음 필요한 경우 반환 된 &lt;code&gt;SV*&lt;/code&gt; 를 &lt;code&gt;AV*&lt;/code&gt; 또는 &lt;code&gt;HV*&lt;/code&gt; 로 캐스팅하여 적절한 루틴을 호출 합니다.</target>
        </trans-unit>
        <trans-unit id="cce031356b0b879892fac5b8c3affe42a0c80ec7" translate="yes" xml:space="preserve">
          <source>then checkout your smoke-me branch once more and rebase it on blead:</source>
          <target state="translated">그런 다음 smoke-me 브랜치를 한 번 더 확인하고 blead에 리베이스하십시오.</target>
        </trans-unit>
        <trans-unit id="42e84eb677476703d809f722b1ff2f0066df6dbd" translate="yes" xml:space="preserve">
          <source>then derived classes may (re-)inherit base-class methods through two or more distinct paths (e.g. in the way &lt;code&gt;E&lt;/code&gt; inherits &lt;code&gt;A::foo&lt;/code&gt; twice -- through &lt;code&gt;C&lt;/code&gt; and &lt;code&gt;D&lt;/code&gt; ). In such cases, a sequence of &lt;code&gt;NEXT&lt;/code&gt; redispatches will invoke the multiply inherited method as many times as it is inherited. For example, the above code prints:</source>
          <target state="translated">파생 클래스는 두 개 이상의 고유 한 경로를 통해 기본 클래스 메소드를 (재 상속) 상속 할 수 있습니다 (예 : &lt;code&gt;E&lt;/code&gt; 가 &lt;code&gt;A::foo&lt;/code&gt; 두 번 상속 하는 방식으로 &lt;code&gt;C&lt;/code&gt; 와 &lt;code&gt;D&lt;/code&gt; 를 통해 ). 이러한 경우, 일련의 &lt;code&gt;NEXT&lt;/code&gt; 재발 포는 상속 된 메소드를 상속 된 횟수만큼 호출합니다. 예를 들어 위 코드는 다음과 같이 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="8f3d9e3fcb4dd79660857cfb0a345ee10dd72bdd" translate="yes" xml:space="preserve">
          <source>then derived classes may (re-)inherit base-class methods through two or more distinct paths (e.g. in the way &lt;code&gt;E&lt;/code&gt; inherits &lt;code&gt;A::foo&lt;/code&gt; twice -- through &lt;code&gt;C&lt;/code&gt; and &lt;code&gt;D&lt;/code&gt;). In such cases, a sequence of &lt;code&gt;NEXT&lt;/code&gt; redispatches will invoke the multiply inherited method as many times as it is inherited. For example, the above code prints:</source>
          <target state="translated">그런 다음 파생 클래스는 두 개 이상의 별개 경로를 통해 기본 클래스 메서드를 (재) 상속 할 수 있습니다 (예 : &lt;code&gt;E&lt;/code&gt; 가 &lt;code&gt;A::foo&lt;/code&gt; 두 번 상속 하는 방식 &lt;code&gt;C&lt;/code&gt; 및 &lt;code&gt;D&lt;/code&gt; 를 통해 ). 이러한 경우 &lt;code&gt;NEXT&lt;/code&gt; 재배치 시퀀스 는 상속 된 횟수만큼 곱하기 상속 된 메서드를 호출합니다. 예를 들어, 위 코드는 다음을 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="a614f37aaecfc8d29fe068560e973149cfa5cf7c" translate="yes" xml:space="preserve">
          <source>then here is the output</source>
          <target state="translated">다음은 출력입니다</target>
        </trans-unit>
        <trans-unit id="622feee1f62a60a311e5e227e74693233442f30c" translate="yes" xml:space="preserve">
          <source>then it would print:</source>
          <target state="translated">그런 다음 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="d3a00c98cd406c22e4b6f2f3ffd7a3f3467e5e23" translate="yes" xml:space="preserve">
          <source>then perl will recompile each time, even though the pattern string hasn't changed, to ensure that the current value of &lt;code&gt;$x&lt;/code&gt; is seen each time. Use &lt;code&gt;/o&lt;/code&gt; if you want to avoid this.</source>
          <target state="translated">그러면 perl은 패턴 문자열이 변경되지 않았어도 매번 &lt;code&gt;$x&lt;/code&gt; 의 현재 값을 볼 수 있도록 매번 다시 컴파일합니다 . 이것을 피 하려면 &lt;code&gt;/o&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="1c4f205545ab62b2b3e328d72a718521c54e0a64" translate="yes" xml:space="preserve">
          <source>then the &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; substitution will be performed silently.</source>
          <target state="translated">다음 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 교체를 자동으로 수행한다.</target>
        </trans-unit>
        <trans-unit id="3cbb088c80c134614593e2f6eee1e46c2fcede39" translate="yes" xml:space="preserve">
          <source>then the &lt;code&gt;@array&lt;/code&gt; would appear to have four elements:</source>
          <target state="translated">다음 &lt;code&gt;@array&lt;/code&gt; 는 네 가지 요소를 가지고 나타납니다 :</target>
        </trans-unit>
        <trans-unit id="b41426657844e708bd8823b764f9de71d42a09ad" translate="yes" xml:space="preserve">
          <source>then the &lt;code&gt;undef&lt;/code&gt; substitution will be performed silently.</source>
          <target state="translated">그러면 &lt;code&gt;undef&lt;/code&gt; 대체가 자동으로 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="51647320b30c0cdeeeedc259248ba22707613c81" translate="yes" xml:space="preserve">
          <source>then the array &lt;code&gt;@gifts&lt;/code&gt; would appear to contain &lt;code&gt;(&quot;Gold\n&quot;,
&quot;Frankincense\n&quot;, &quot;Myrrh\n&quot;)&lt;/code&gt; , or (on Win32 systems) &lt;code&gt;(&quot;Gold\r\n&quot;,
&quot;Frankincense\r\n&quot;, &quot;Myrrh\r\n&quot;)&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;@gifts&lt;/code&gt; 배열 에는 &lt;code&gt;(&quot;Gold\n&quot;, &quot;Frankincense\n&quot;, &quot;Myrrh\n&quot;)&lt;/code&gt; 또는 (Win32 시스템의 경우) &lt;code&gt;(&quot;Gold\r\n&quot;, &quot;Frankincense\r\n&quot;, &quot;Myrrh\r\n&quot;)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="50622336643f60a3b3a136d84ec317d586096b5c" translate="yes" xml:space="preserve">
          <source>then the array &lt;code&gt;@gifts&lt;/code&gt; would appear to contain &lt;code&gt;(&quot;Gold\n&quot;, &quot;Frankincense\n&quot;, &quot;Myrrh\n&quot;)&lt;/code&gt;, or (on Win32 systems) &lt;code&gt;(&quot;Gold\r\n&quot;, &quot;Frankincense\r\n&quot;, &quot;Myrrh\r\n&quot;)&lt;/code&gt;.</source>
          <target state="translated">배열 &lt;code&gt;@gifts&lt;/code&gt; 는 &lt;code&gt;(&quot;Gold\n&quot;, &quot;Frankincense\n&quot;, &quot;Myrrh\n&quot;)&lt;/code&gt; 또는 (Win32 시스템에서) &lt;code&gt;(&quot;Gold\r\n&quot;, &quot;Frankincense\r\n&quot;, &quot;Myrrh\r\n&quot;)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5705bd36756a8f0f099992bbd5c5e2309a6a622c" translate="yes" xml:space="preserve">
          <source>then the binary number may use '_' characters to separate digits.</source>
          <target state="translated">이진수는 '_'문자를 사용하여 숫자를 구분할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8cbf74d1a22f4c12bb5419eef66a0debb65f9111" translate="yes" xml:space="preserve">
          <source>then the external</source>
          <target state="translated">그런 다음 외부</target>
        </trans-unit>
        <trans-unit id="dabfa7fd2b9ed457d1e61c46bf829f66a1b108f0" translate="yes" xml:space="preserve">
          <source>then the hex number may use '_' characters to separate digits.</source>
          <target state="translated">16 진수는 '_'문자를 사용하여 숫자를 구분할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b631c3c134aba1a964ce5976afb151eddc3f3c1b" translate="yes" xml:space="preserve">
          <source>then the octal number may use '_' characters to separate digits.</source>
          <target state="translated">8 진수는 '_'문자를 사용하여 숫자를 구분할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="74fabb78efcde6da4ccf9db38ed749c11f7c9fa1" translate="yes" xml:space="preserve">
          <source>then the operation</source>
          <target state="translated">그런 다음 작업</target>
        </trans-unit>
        <trans-unit id="874355591d490dee5442696b955dde5b7234454e" translate="yes" xml:space="preserve">
          <source>then the output will be</source>
          <target state="translated">출력은</target>
        </trans-unit>
        <trans-unit id="045743d8f9d34f5f6f47ab4d7191f2b38f0e9606" translate="yes" xml:space="preserve">
          <source>then the sort operation provides list context for &amp;lt;&amp;gt;, which will proceed to read every line available up to the end of file, and pass that list of lines back to the sort routine, which will then sort those lines and return them as a list to whatever the context of the sort was.</source>
          <target state="translated">정렬 작업은 &amp;lt;&amp;gt;에 대한 목록 컨텍스트를 제공하여 파일 끝까지 사용 가능한 모든 행을 읽고 해당 행 목록을 정렬 루틴으로 다시 전달하여 해당 행을 정렬하고 목록으로 리턴합니다. 어떤 맥락에서든</target>
        </trans-unit>
        <trans-unit id="5bd76cb7e62e6f62cec2f5cdb5382c5e4a61f115" translate="yes" xml:space="preserve">
          <source>then there will be a problem later when the tarfile gets written out to disk via &lt;code&gt;$tar-&amp;gt;write()&lt;/code&gt;:</source>
          <target state="translated">그러면 나중에 &lt;code&gt;$tar-&amp;gt;write()&lt;/code&gt; 를 통해 tarfile이 디스크에 기록 될 때 문제가 발생합니다 .</target>
        </trans-unit>
        <trans-unit id="3009a9d43c2b1f0d7cb92e3fe3c04935627a9d8b" translate="yes" xml:space="preserve">
          <source>then there will be a problem later when the tarfile gets written out to disk via &lt;code&gt;$tar-&lt;/code&gt; write()&amp;gt;:</source>
          <target state="translated">tarfile이 &lt;code&gt;$tar-&lt;/code&gt; tar- write ()&amp;gt; 를 통해 디스크에 기록 될 때 나중에 문제가 발생합니다 .</target>
        </trans-unit>
        <trans-unit id="11f83d0fa9475f3a84586f0df189a5ef0cec1361" translate="yes" xml:space="preserve">
          <source>then use the following to get the package name itself:</source>
          <target state="translated">그런 다음 패키지 이름 자체를 얻으려면 다음을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="be0d3cf429c3ee73a23ab767015fb8466fde14fb" translate="yes" xml:space="preserve">
          <source>then use this to access the &lt;code&gt;&lt;a href=&quot;functions/index&quot;&gt;index&lt;/a&gt;&lt;/code&gt; member</source>
          <target state="translated">그런 다음 이것을 사용하여 &lt;code&gt;&lt;a href=&quot;functions/index&quot;&gt;index&lt;/a&gt;&lt;/code&gt; 멤버 에 액세스하십시오.</target>
        </trans-unit>
        <trans-unit id="a899eb8880a399b9821f06d5eba5317afd17cf5a" translate="yes" xml:space="preserve">
          <source>then use this to access the &lt;code&gt;index&lt;/code&gt; member</source>
          <target state="translated">그런 다음 이것을 사용하여 &lt;code&gt;index&lt;/code&gt; 멤버 에 액세스하십시오.</target>
        </trans-unit>
        <trans-unit id="063029591eda4124365817de430c9e3536123f63" translate="yes" xml:space="preserve">
          <source>then would use an #ifdef guard.</source>
          <target state="translated">#ifdef 가드를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="0113955e5061ba3159b9955669b9df7098bbf902" translate="yes" xml:space="preserve">
          <source>then you can do a non-blocking wait for all pending zombie processes (see &lt;a href=&quot;posix#WAIT&quot;&gt;&quot;WAIT&quot; in POSIX&lt;/a&gt;). Non-blocking wait is available on machines supporting either the &lt;a href=&quot;http://man.he.net/man2/waitpid&quot;&gt;waitpid(2)&lt;/a&gt; or &lt;a href=&quot;http://man.he.net/man2/wait4&quot;&gt;wait4(2)&lt;/a&gt; syscalls. However, waiting for a particular pid with FLAGS of &lt;code&gt;0&lt;/code&gt; is implemented everywhere. (Perl emulates the system call by remembering the status values of processes that have exited but have not been harvested by the Perl script yet.)</source>
          <target state="translated">그런 다음 보류중인 모든 좀비 프로세스에 대해 비 차단 대기를 수행 할 수 있습니다 ( &lt;a href=&quot;posix#WAIT&quot;&gt;POSIX의 &quot;WAIT&quot;&lt;/a&gt; 참조 ). 비 차단 대기는 &lt;a href=&quot;http://man.he.net/man2/waitpid&quot;&gt;waitpid (2)&lt;/a&gt; 또는 &lt;a href=&quot;http://man.he.net/man2/wait4&quot;&gt;wait4 (2)&lt;/a&gt; 시스템 호출을 지원하는 시스템에서 사용할 수 있습니다 . 그러나 FLAGS가 &lt;code&gt;0&lt;/code&gt; 인 특정 pid를 기다리는 것은 모든 곳에서 구현됩니다. (Perl은 종료되었지만 아직 Perl 스크립트에 의해 수집되지 않은 프로세스의 상태 값을 기억하여 시스템 호출을 에뮬레이트합니다.)</target>
        </trans-unit>
        <trans-unit id="bca9b0367ec1fa4243df295292555c374501f059" translate="yes" xml:space="preserve">
          <source>then you can do a non-blocking wait for all pending zombie processes. Non-blocking wait is available on machines supporting either the waitpid(2) or wait4(2) syscalls. However, waiting for a particular pid with FLAGS of &lt;code&gt;0&lt;/code&gt; is implemented everywhere. (Perl emulates the system call by remembering the status values of processes that have exited but have not been harvested by the Perl script yet.)</source>
          <target state="translated">그런 다음 보류중인 모든 좀비 프로세스에 대해 비 차단 대기를 수행 할 수 있습니다. 비 블로킹 대기는 waitpid (2) 또는 wait4 (2) syscall을 지원하는 시스템에서 사용 가능합니다. 그러나 FLAGS가 &lt;code&gt;0&lt;/code&gt; 인 특정 pid를 기다리는 것은 모든 곳에서 구현됩니다. Perl은 종료되었지만 아직 Perl 스크립트에 의해 수집되지 않은 프로세스의 상태 값을 기억하여 시스템 호출을 에뮬레이트합니다.</target>
        </trans-unit>
        <trans-unit id="7c28a01d2c2e58511a6dd44b120cb4e811b0360f" translate="yes" xml:space="preserve">
          <source>then you can set &lt;code&gt;$pSecAttr&lt;/code&gt; via:</source>
          <target state="translated">그런 다음 다음을 통해 &lt;code&gt;$pSecAttr&lt;/code&gt; 을 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="24e3673901b12a352e45bfe1a29cd357600f2223" translate="yes" xml:space="preserve">
          <source>then you must make sure that your &lt;code&gt;&lt;a href=&quot;../functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; subroutine appears before that &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; statement.</source>
          <target state="translated">그런 다음 해당 &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 문 앞에 &lt;code&gt;&lt;a href=&quot;../functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; 서브 루틴이 나타나는지 확인해야합니다 .</target>
        </trans-unit>
        <trans-unit id="8e8c671980178894f57c36a6d3adc15907cf4763" translate="yes" xml:space="preserve">
          <source>then you must make sure that your &lt;code&gt;import&lt;/code&gt; subroutine appears before that &lt;code&gt;use&lt;/code&gt; statement.</source>
          <target state="translated">그런 다음 해당 &lt;code&gt;use&lt;/code&gt; 문 앞에 &lt;code&gt;import&lt;/code&gt; 서브 루틴이 나타나는지 확인해야합니다 .</target>
        </trans-unit>
        <trans-unit id="fbcfd002f79bf258f39d2d725e545e20557407da" translate="yes" xml:space="preserve">
          <source>then you would configure CPAN.pm with the command</source>
          <target state="translated">그런 다음 명령을 사용하여 CPAN.pm을 구성합니다.</target>
        </trans-unit>
        <trans-unit id="fb0a1fd2595bcd62801102e76923b7858beb8c22" translate="yes" xml:space="preserve">
          <source>then your LIBPATH does not have the location of libperl.x and either libperl.dll or libperl.so in it. Add that directory to your LIBPATH and proceed.</source>
          <target state="translated">그런 다음 LIBPATH에는 libperl.x 및 libperl.dll 또는 libperl.so의 위치가 없습니다. 해당 디렉토리를 LIBPATH에 추가하고 계속하십시오.</target>
        </trans-unit>
        <trans-unit id="3d3083ee3ba5313a634dabd04c969303606edcbb" translate="yes" xml:space="preserve">
          <source>then your PWD environment variable will be kept up to date. Note that it will only be kept up to date if all packages which use chdir import it from Cwd.</source>
          <target state="translated">그러면 PWD 환경 변수가 최신 상태로 유지됩니다. chdir을 사용하는 모든 패키지가 Cwd에서 가져 오는 경우에만 최신 상태로 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="b677073f08588ee6a96aff7b9290e34f7f2c31d3" translate="yes" xml:space="preserve">
          <source>then your script will run without human intervention, putting trace information into the file</source>
          <target state="translated">그러면 스크립트는 사람의 개입없이 실행되어 추적 정보를 파일에 넣습니다.</target>
        </trans-unit>
        <trans-unit id="fdc01276daa17eba9f35c662cb1e1a3ce12fc436" translate="yes" xml:space="preserve">
          <source>there's more than one way to do it</source>
          <target state="translated">그것을 할 수있는 여러 가지 방법이 있습니다</target>
        </trans-unit>
        <trans-unit id="1460929c0c47b645e55308f3833bf025fb32ab4f" translate="yes" xml:space="preserve">
          <source>there.</source>
          <target state="translated">there.</target>
        </trans-unit>
        <trans-unit id="d0d231a4a98b662d880d7dc89cac579bab850eb2" translate="yes" xml:space="preserve">
          <source>there. In this case you can do:</source>
          <target state="translated">그곳에. 이 경우 다음을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8c5900f2075a21520e816c3509bd71ab5f03dcb9" translate="yes" xml:space="preserve">
          <source>thereby giving the user automatic anonymous login to machines not specified in .netrc.</source>
          <target state="translated">따라서 .netrc에 지정되지 않은 컴퓨터에 자동 익명 로그인을 사용자에게 제공합니다.</target>
        </trans-unit>
        <trans-unit id="844a579d2ac78e752d68592ad05f19175c7d315a" translate="yes" xml:space="preserve">
          <source>these EMX functions do not work if the path contains a trailing &lt;code&gt;/&lt;/code&gt;. Perl contains a workaround for this.</source>
          <target state="translated">경로에 후행 &lt;code&gt;/&lt;/code&gt; 가 포함 된 경우 이러한 EMX 기능이 작동하지 않습니다 . Perl에는 이에 대한 해결 방법이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="8f140f5b64c2fb4e240cd7cafc5e3b9a858bd13a" translate="yes" xml:space="preserve">
          <source>these days.</source>
          <target state="translated">요즈음.</target>
        </trans-unit>
        <trans-unit id="f24426b9ff82a9ecca01636f4317d4a7fdba1697" translate="yes" xml:space="preserve">
          <source>theta</source>
          <target state="translated">theta</target>
        </trans-unit>
        <trans-unit id="f9076a004ebe7521f2460d54a3606de78e10e9f7" translate="yes" xml:space="preserve">
          <source>they would get the default imports without overrides.</source>
          <target state="translated">재정의없이 기본 가져 오기를 수행합니다.</target>
        </trans-unit>
        <trans-unit id="6cbfdc0bdfd058e556cab999d13b108002e4754f" translate="yes" xml:space="preserve">
          <source>they would result in a change. If they would not alter the requirements, they have no effect.</source>
          <target state="translated">그들은 변화를 가져올 것입니다. 요구 사항을 변경하지 않으면 효과가 없습니다.</target>
        </trans-unit>
        <trans-unit id="a3381da6627be60591dc894ff1000a09075d2a79" translate="yes" xml:space="preserve">
          <source>they'll be politely informed that</source>
          <target state="translated">그들은 정중하게</target>
        </trans-unit>
        <trans-unit id="c9689e395e7bc64aae43613860f844d43818858a" translate="yes" xml:space="preserve">
          <source>thing and how did it get in my</source>
          <target state="translated">일과 어떻게 내</target>
        </trans-unit>
        <trans-unit id="a5409d55c4a06a27b55a5136e1dec7d1ae0285e0" translate="yes" xml:space="preserve">
          <source>things. The effective gid is the group that's</source>
          <target state="translated">소지품. 효과적인 gid는</target>
        </trans-unit>
        <trans-unit id="7d80d88438d6ad166c5f496a3372a4f27aea9bcf" translate="yes" xml:space="preserve">
          <source>things. The real gid is the group you</source>
          <target state="translated">소지품. 진짜 여자는 당신이 그룹입니다</target>
        </trans-unit>
        <trans-unit id="c2543fff3bfa6f144c2f06a7de6cd10c0b650cae" translate="yes" xml:space="preserve">
          <source>this</source>
          <target state="translated">this</target>
        </trans-unit>
        <trans-unit id="79df13086927aaa527620acac1e6650e2085d774" translate="yes" xml:space="preserve">
          <source>this TODO</source>
          <target state="translated">이 TODO</target>
        </trans-unit>
        <trans-unit id="852fdaa8c7ce7f8e6638658e6c5843489c4652e6" translate="yes" xml:space="preserve">
          <source>this code could and probably should be written as</source>
          <target state="translated">이 코드는 다음과 같이 작성 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="547fc135c0c908d9b4b5f50835f5c52b636693d6" translate="yes" xml:space="preserve">
          <source>this has the advantage of being backward compatible with how such things have had to be coded on some platforms for years.</source>
          <target state="translated">이것은 몇 년 동안 일부 플랫폼에서 그러한 것들을 어떻게 코딩해야했는지와 역 호환되는 장점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="5ab21a1ad37e0d8f33b9d32fccefe0d0f9927964" translate="yes" xml:space="preserve">
          <source>this last step may or may not require UID=0 privileges depending on how you answered the questions that Configure asked and whether or not you have write access to the directories you specified.</source>
          <target state="translated">이 마지막 단계는 Configure 질문에 응답 한 방법 및 지정한 디렉토리에 대한 쓰기 권한이 있는지 여부에 따라 UID = 0 권한을 요구하거나 요구하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e79946398c2004a40105bb60cf6415fc46dccd47" translate="yes" xml:space="preserve">
          <source>this script would output something like</source>
          <target state="translated">이 스크립트는 다음과 같이 출력합니다.</target>
        </trans-unit>
        <trans-unit id="f7030489b8bb3c6a1f199877396c1b8f99049140" translate="yes" xml:space="preserve">
          <source>this value. In fact this value may be inspected in debugger (see &lt;a href=&quot;perldebug&quot;&gt;perldebug&lt;/a&gt;), but only if &lt;code&gt;bareStringify&lt;/code&gt;&lt;b&gt;O&lt;/b&gt;ption is set, and not via &lt;code&gt;p&lt;/code&gt; command.</source>
          <target state="translated">이 값. 실제로이 값은 디버거에서 검사 할 수 있지만 ( &lt;a href=&quot;perldebug&quot;&gt;perldebug&lt;/a&gt; 참조 ) &lt;code&gt;bareStringify&lt;/code&gt; &lt;b&gt;O &lt;/b&gt;ption 이 설정되어 있고 &lt;code&gt;p&lt;/code&gt; 명령이 아닌 경우에만 가능합니다 .</target>
        </trans-unit>
        <trans-unit id="d54ca3cc20a62b1a149415f45240c3a04f288da6" translate="yes" xml:space="preserve">
          <source>this will attempt to remove '/usr' from the front of the $MM-&amp;gt;{INSTALLMAN1DIR} path (initializing it to $Config{installman1dir} if necessary) and replace it with '/home/foo'. If this fails it will simply use '/home/foo/man/man1'.</source>
          <target state="translated">$ MM-&amp;gt; {INSTALLMAN1DIR} 경로 앞부분에서 '/ usr'을 제거하고 (필요한 경우 $ Config {installman1dir}로 초기화) '/ home / foo'로 대체합니다. 이것이 실패하면 단순히 '/ home / foo / man / man1'을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="fd0e656077d9f358afa7e9b9153721303c8a986f" translate="yes" xml:space="preserve">
          <source>this will execute the is_mystyle_eq test, capturing its results and checking that they are what was expected.</source>
          <target state="translated">is_mystyle_eq 테스트를 실행하여 결과를 캡처하고 예상 한 결과인지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="cf99bf2a32d5b6c5bb486fc0e533a4767bda09be" translate="yes" xml:space="preserve">
          <source>thoroughly before using it to submit a bug report.</source>
          <target state="translated">버그 보고서를 제출하는 데 사용하기 전에 철저히 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="9f70a3b0dfe456892cdf57582747cdf3a63728a5" translate="yes" xml:space="preserve">
          <source>those loaded by the base name from &lt;code&gt;LIBPATH&lt;/code&gt; ; including those associated at link time;</source>
          <target state="translated">&lt;code&gt;LIBPATH&lt;/code&gt; 에서 기본 이름으로로드 된 것 ; 링크 타임에 관련된 것들을 포함하는 것;</target>
        </trans-unit>
        <trans-unit id="612c1e6f1a6c455fc76fc0a6674079ca31601b0f" translate="yes" xml:space="preserve">
          <source>those loaded by the base name from &lt;code&gt;LIBPATH&lt;/code&gt;; including those associated at link time;</source>
          <target state="translated">&lt;code&gt;LIBPATH&lt;/code&gt; 에서 기본 이름으로로드 된 것 ; 링크 타임에 관련된 것들을 포함;</target>
        </trans-unit>
        <trans-unit id="955beb1174948fda9b965e31c4faeddf904445b3" translate="yes" xml:space="preserve">
          <source>those phrases that are UK-specific, and for all the rest,</source>
          <target state="translated">영국 고유의 문구와 나머지 모든 문구는</target>
        </trans-unit>
        <trans-unit id="524cd37ee4c7405f7efcc0020d541eb55192c55c" translate="yes" xml:space="preserve">
          <source>though the use of these constructs during run-time is questionable.</source>
          <target state="translated">런타임 동안 이러한 구문의 사용은 의문의 여지가 있습니다.</target>
        </trans-unit>
        <trans-unit id="c283e375ed8cebf3b8d1b5101fd51bb522961656" translate="yes" xml:space="preserve">
          <source>thread</source>
          <target state="translated">thread</target>
        </trans-unit>
        <trans-unit id="ebb820ea5438310928a21485a7027cfe032626d2" translate="yes" xml:space="preserve">
          <source>thread and one or more</source>
          <target state="translated">실과 하나 이상</target>
        </trans-unit>
        <trans-unit id="be00c0bf8bd61a841d302e53df235310f4c7c683" translate="yes" xml:space="preserve">
          <source>thread associated with the specified thread ID. If &lt;code&gt;$tid&lt;/code&gt; is the value for the current thread, then this call works the same as &lt;code&gt;-&amp;gt;self()&lt;/code&gt; . Otherwise, returns &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; if there is no thread associated with the TID, if the thread is joined or detached, if no TID is specified or if the specified TID is undef.</source>
          <target state="translated">지정된 스레드 ID와 연관된 스레드 경우 &lt;code&gt;$tid&lt;/code&gt; 현재의 thread 값입니다,이 호출과 동일하게 작동 &lt;code&gt;-&amp;gt;self()&lt;/code&gt; . 그렇지 않으면, TID와 연관된 스레드가 없거나 스레드가 결합 또는 분리 된 경우, TID가 지정되지 않았거나 지정된 TID가 정의되지 않은 경우 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 를 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="150f9aba3774f0ad984c408f0298453cb749b6fc" translate="yes" xml:space="preserve">
          <source>thread associated with the specified thread ID. If &lt;code&gt;$tid&lt;/code&gt; is the value for the current thread, then this call works the same as &lt;code&gt;-&amp;gt;self()&lt;/code&gt;. Otherwise, returns &lt;code&gt;undef&lt;/code&gt; if there is no thread associated with the TID, if the thread is joined or detached, if no TID is specified or if the specified TID is undef.</source>
          <target state="translated">지정된 스레드 ID와 연관된 스레드입니다. 경우 &lt;code&gt;$tid&lt;/code&gt; 현재의 thread 값입니다,이 호출과 동일하게 작동 &lt;code&gt;-&amp;gt;self()&lt;/code&gt; . 그렇지 않으면 TID와 연관된 스레드가없는 경우, 스레드가 결합되거나 분리 된 경우, TID가 지정되지 않았거나 지정된 TID가 undef 인 경우 &lt;code&gt;undef&lt;/code&gt; 를 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="2b1aaf78f7385dec07cce860bf6f1ce1534ad089" translate="yes" xml:space="preserve">
          <source>thread exits, then this warning cannot be suppressed using &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; warnings 'threads';&lt;/code&gt; as suggested below.</source>
          <target state="translated">스레드가 종료가,이 경고는 사용을 억제 할 수 &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; warnings 'threads';&lt;/code&gt; 아래 제안 된대로.</target>
        </trans-unit>
        <trans-unit id="d599c14f895a853a8d3a978362d09c386b9ad772" translate="yes" xml:space="preserve">
          <source>thread exits, then this warning cannot be suppressed using &lt;code&gt;no warnings 'threads';&lt;/code&gt; as suggested below.</source>
          <target state="translated">스레드가 종료되면 &lt;code&gt;no warnings 'threads';&lt;/code&gt; 사용하여이 경고를 억제 할 수 없습니다 . 아래에 제안 된대로.</target>
        </trans-unit>
        <trans-unit id="df2e34e3cdb0a60c4d04443ed90e706147fd9b35" translate="yes" xml:space="preserve">
          <source>thread is unaffected by this call.</source>
          <target state="translated">스레드는이 호출의 영향을받지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1ba2970dd88ad4b4e72572ffdf22c1deb7f60a35" translate="yes" xml:space="preserve">
          <source>thread is unaffected by this setting.</source>
          <target state="translated">스레드는이 설정의 영향을받지 않습니다.</target>
        </trans-unit>
        <trans-unit id="dc0153b46f92c9aa69c2610e01a4d11d889157f9" translate="yes" xml:space="preserve">
          <source>thread safe when using the older (experimental and now obsolete) threads implementation that was added to Perl 5.005.</source>
          <target state="translated">Perl 5.005에 추가 된 구형 (실험적이면서 현재는 사용되지 않는) 스레드 구현을 사용할 때 스레드 안전.</target>
        </trans-unit>
        <trans-unit id="065606106bace6e1bb589c52e0923b46b92fe690" translate="yes" xml:space="preserve">
          <source>thread support</source>
          <target state="translated">스레드 지원</target>
        </trans-unit>
        <trans-unit id="d67afc3417d4958f3ed82fd0be1bd179bac68b33" translate="yes" xml:space="preserve">
          <source>thread yield</source>
          <target state="translated">스레드 수율</target>
        </trans-unit>
        <trans-unit id="f021c519858ead3d56da5875f6a26d3e07030faa" translate="yes" xml:space="preserve">
          <source>thread, this behaves the same as &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit(0)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">thread, 이것은 &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit(0)&lt;/a&gt;&lt;/code&gt; 과 동일하게 동작합니다 .</target>
        </trans-unit>
        <trans-unit id="7a6089c4861a7d61af8bfceb243bdda56ad1f409" translate="yes" xml:space="preserve">
          <source>thread, this behaves the same as &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit(status)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">thread의 경우, &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit(status)&lt;/a&gt;&lt;/code&gt; 와 동일하게 동작합니다 .</target>
        </trans-unit>
        <trans-unit id="eb7f5e8e226aaef9b83a989a55cb37c89699ed6c" translate="yes" xml:space="preserve">
          <source>thread, this behaves the same as &lt;code&gt;exit(0)&lt;/code&gt;.</source>
          <target state="translated">스레드, 이것은 &lt;code&gt;exit(0)&lt;/code&gt; 과 동일하게 작동합니다 .</target>
        </trans-unit>
        <trans-unit id="a5d2d9b489e1bf201d0678ac2e8706a3fe6a5325" translate="yes" xml:space="preserve">
          <source>thread, this behaves the same as &lt;code&gt;exit(status)&lt;/code&gt;.</source>
          <target state="translated">스레드, 이것은 &lt;code&gt;exit(status)&lt;/code&gt; 와 동일하게 작동합니다 .</target>
        </trans-unit>
        <trans-unit id="29c60465c379bf1644566a78609304cb3aa69b61" translate="yes" xml:space="preserve">
          <source>thread, try modifying your application so that the module is loaded (again using &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;-&amp;gt;import()&lt;/code&gt; ) after any threads are started, and in such a way that no other threads are started afterwards.</source>
          <target state="translated">스레드가 시작되면 스레드가 시작된 후 모듈이로드되도록 ( 그리고 &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;-&amp;gt;import()&lt;/code&gt; 사용하여 ) 나중에 다른 스레드가 시작되지 않도록 응용 프로그램을 수정하십시오 .</target>
        </trans-unit>
        <trans-unit id="ae060f4633a479b1c93a09c0389964646bc7330f" translate="yes" xml:space="preserve">
          <source>thread, try modifying your application so that the module is loaded (again using &lt;code&gt;require&lt;/code&gt; and &lt;code&gt;-&amp;gt;import()&lt;/code&gt;) after any threads are started, and in such a way that no other threads are started afterwards.</source>
          <target state="translated">스레드가 시작된 후 모듈이로드되도록 (다시 &lt;code&gt;require&lt;/code&gt; 및 &lt;code&gt;-&amp;gt;import()&lt;/code&gt; ) 애플리케이션을 수정하여 나중에 다른 스레드가 시작되지 않도록하십시오.</target>
        </trans-unit>
        <trans-unit id="0e92998455c09ed4e96524633947d3882bf21535" translate="yes" xml:space="preserve">
          <source>thread-safe</source>
          <target state="translated">thread-safe</target>
        </trans-unit>
        <trans-unit id="322b4598be3f1d250c204de6245d6c3281828f5e" translate="yes" xml:space="preserve">
          <source>thread. In other words, changes made to &lt;code&gt;%ENV&lt;/code&gt; in a thread will not be visible in</source>
          <target state="translated">실. 즉, 스레드에서 &lt;code&gt;%ENV&lt;/code&gt; 에 대한 변경 사항은</target>
        </trans-unit>
        <trans-unit id="c91e11a1f2a2f6f290fe5039f78f07f318049442" translate="yes" xml:space="preserve">
          <source>threads</source>
          <target state="translated">threads</target>
        </trans-unit>
        <trans-unit id="d87386329ab23fe84cf857fa28d7406622a9a3cb" translate="yes" xml:space="preserve">
          <source>threads - Perl interpreter-based threads</source>
          <target state="translated">스레드-Perl 인터프리터 기반 스레드</target>
        </trans-unit>
        <trans-unit id="64cc47f9346b8151a8e1bff1bf7a7575d5c6a720" translate="yes" xml:space="preserve">
          <source>threads is released under the same license as Perl.</source>
          <target state="translated">스레드는 Perl과 동일한 라이센스로 해제됩니다.</target>
        </trans-unit>
        <trans-unit id="7d21fa65b425cd5695416eb75d4129638deb06be" translate="yes" xml:space="preserve">
          <source>threads on MetaCPAN: &lt;a href=&quot;https://metacpan.org/release/threads&quot;&gt;https://metacpan.org/release/threads&lt;/a&gt;</source>
          <target state="translated">MetaCPAN의 스레드 : &lt;a href=&quot;https://metacpan.org/release/threads&quot;&gt;https://metacpan.org/release/threads&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="0845f72ee5a4a2716804978863f8393b6a1597f6" translate="yes" xml:space="preserve">
          <source>threads while there are still existing</source>
          <target state="translated">여전히 존재하는 동안 스레드</target>
        </trans-unit>
        <trans-unit id="3993e0399cfbc85dea3a7f9688259344d0dcf560" translate="yes" xml:space="preserve">
          <source>threads-&amp;gt;_handle()</source>
          <target state="translated">threads-&amp;gt;_handle()</target>
        </trans-unit>
        <trans-unit id="092fb6ffc72a52f11f85045c3596e33973d43576" translate="yes" xml:space="preserve">
          <source>threads-&amp;gt;create({'exit' =&amp;gt; 'thread_only'}, ...)</source>
          <target state="translated">threads-&amp;gt;create({'exit' =&amp;gt; 'thread_only'}, ...)</target>
        </trans-unit>
        <trans-unit id="ac50115916ba510986691a996616c73123d2266b" translate="yes" xml:space="preserve">
          <source>threads-&amp;gt;create({'stack_size' =&amp;gt; VALUE}, FUNCTION, ARGS)</source>
          <target state="translated">threads-&amp;gt;create({'stack_size' =&amp;gt; VALUE}, FUNCTION, ARGS)</target>
        </trans-unit>
        <trans-unit id="0c8ee7e54e4f13a0f65378d9025d523f946ac640" translate="yes" xml:space="preserve">
          <source>threads-&amp;gt;detach()</source>
          <target state="translated">threads-&amp;gt;detach()</target>
        </trans-unit>
        <trans-unit id="442c6a6cb4b4e73fc58875ac5966af7b78313947" translate="yes" xml:space="preserve">
          <source>threads-&amp;gt;exit()</source>
          <target state="translated">threads-&amp;gt;exit()</target>
        </trans-unit>
        <trans-unit id="855dc75ccafa0763c09a4cbd0350f60128116e6a" translate="yes" xml:space="preserve">
          <source>threads-&amp;gt;exit(status)</source>
          <target state="translated">threads-&amp;gt;exit(status)</target>
        </trans-unit>
        <trans-unit id="6c93971d77951fdd197455a656956d560aa0b425" translate="yes" xml:space="preserve">
          <source>threads-&amp;gt;get_stack_size();</source>
          <target state="translated">threads-&amp;gt;get_stack_size();</target>
        </trans-unit>
        <trans-unit id="75282d9b640f5f3fd84fa2a8e102c9c00c91e387" translate="yes" xml:space="preserve">
          <source>threads-&amp;gt;is_detached()</source>
          <target state="translated">threads-&amp;gt;is_detached()</target>
        </trans-unit>
        <trans-unit id="a46723e2fc13ba3a68257e29924c2d1dae397229" translate="yes" xml:space="preserve">
          <source>threads-&amp;gt;list()</source>
          <target state="translated">threads-&amp;gt;list()</target>
        </trans-unit>
        <trans-unit id="0cb042607414875c3e3e1ef5390f616f8627516f" translate="yes" xml:space="preserve">
          <source>threads-&amp;gt;list(threads::all)</source>
          <target state="translated">threads-&amp;gt;list(threads::all)</target>
        </trans-unit>
        <trans-unit id="814c00952de7a1ace1b4d8cfe42884818db16b52" translate="yes" xml:space="preserve">
          <source>threads-&amp;gt;list(threads::joinable)</source>
          <target state="translated">threads-&amp;gt;list(threads::joinable)</target>
        </trans-unit>
        <trans-unit id="250ebdebf166dbd721dd94e54f81d7e2c32feea2" translate="yes" xml:space="preserve">
          <source>threads-&amp;gt;list(threads::running)</source>
          <target state="translated">threads-&amp;gt;list(threads::running)</target>
        </trans-unit>
        <trans-unit id="7b166530bc317d270026d065ad5ccd3b2b333937" translate="yes" xml:space="preserve">
          <source>threads-&amp;gt;object($tid)</source>
          <target state="translated">threads-&amp;gt;object($tid)</target>
        </trans-unit>
        <trans-unit id="eb7134e6b8071c6a5de4bcb7e2825ac5ac01f123" translate="yes" xml:space="preserve">
          <source>threads-&amp;gt;self()</source>
          <target state="translated">threads-&amp;gt;self()</target>
        </trans-unit>
        <trans-unit id="487a46fa9775ac7bd21f991e1f6ec693569bde11" translate="yes" xml:space="preserve">
          <source>threads-&amp;gt;set_thread_exit_only(boolean)</source>
          <target state="translated">threads-&amp;gt;set_thread_exit_only(boolean)</target>
        </trans-unit>
        <trans-unit id="baaa861c1b4447594fd7074292c01d3e6ddb9dd0" translate="yes" xml:space="preserve">
          <source>threads-&amp;gt;tid()</source>
          <target state="translated">threads-&amp;gt;tid()</target>
        </trans-unit>
        <trans-unit id="b496a5f4b694561f23d5585cda62ccf1df1b03ee" translate="yes" xml:space="preserve">
          <source>threads-&amp;gt;wantarray()</source>
          <target state="translated">threads-&amp;gt;wantarray()</target>
        </trans-unit>
        <trans-unit id="4231a8a4a677aff7be24d3efa0757464bad07f44" translate="yes" xml:space="preserve">
          <source>threads-&amp;gt;yield()</source>
          <target state="translated">threads-&amp;gt;yield()</target>
        </trans-unit>
        <trans-unit id="3e03e1e2552cb929142ffa79d30112ff5706e673" translate="yes" xml:space="preserve">
          <source>threads.</source>
          <target state="translated">threads.</target>
        </trans-unit>
        <trans-unit id="f7f5cb25f9bc9773be646466ec1376299a475b0d" translate="yes" xml:space="preserve">
          <source>threads. The boss thread gathers or generates tasks that need to be done, then parcels those tasks out to the appropriate worker thread.</source>
          <target state="translated">스레드. 보스 스레드는 수행해야 할 작업을 수집하거나 생성 한 다음 해당 작업을 적절한 작업자 스레드로 소포합니다.</target>
        </trans-unit>
        <trans-unit id="d5a02881a442580d4c3de9e92a5357a1d6618663" translate="yes" xml:space="preserve">
          <source>threads.pm</source>
          <target state="translated">threads.pm</target>
        </trans-unit>
        <trans-unit id="74b6e8e1e1109a88c34e023c749582b0ed7d1e40" translate="yes" xml:space="preserve">
          <source>threads.xs</source>
          <target state="translated">threads.xs</target>
        </trans-unit>
        <trans-unit id="2faa69fbc196ece0d11da3fece8bb8cb4878a304" translate="yes" xml:space="preserve">
          <source>threads::shared</source>
          <target state="translated">threads::shared</target>
        </trans-unit>
        <trans-unit id="09e213c9ca6e90ca64b57886a4b8e0006db860c7" translate="yes" xml:space="preserve">
          <source>threads::shared - Perl extension for sharing data structures between threads</source>
          <target state="translated">threads :: shared-스레드간에 데이터 구조를 공유하기위한 Perl 확장</target>
        </trans-unit>
        <trans-unit id="a8527497cd0587a8b9759bc72fbec2309abe6a87" translate="yes" xml:space="preserve">
          <source>threads::shared is released under the same license as Perl.</source>
          <target state="translated">threads :: shared은 Perl과 동일한 라이센스에 따라 릴리스됩니다.</target>
        </trans-unit>
        <trans-unit id="fc8c4629f7ed08224758285316697cdca5d31af0" translate="yes" xml:space="preserve">
          <source>threads::shared on MetaCPAN: &lt;a href=&quot;https://metacpan.org/release/threads-shared&quot;&gt;https://metacpan.org/release/threads-shared&lt;/a&gt;</source>
          <target state="translated">threads::shared on MetaCPAN: &lt;a href=&quot;https://metacpan.org/release/threads-shared&quot;&gt;https://metacpan.org/release/threads-shared&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="621fe4e4982105807f1e73b6e4aa8e634c2f1b91" translate="yes" xml:space="preserve">
          <source>threadsv_names</source>
          <target state="translated">threadsv_names</target>
        </trans-unit>
        <trans-unit id="ee06316257bae7813945d7b7cd55387706b32fcf" translate="yes" xml:space="preserve">
          <source>three-argument</source>
          <target state="translated">three-argument</target>
        </trans-unit>
        <trans-unit id="48f476deb04384be740b2036dcbe7970821de566" translate="yes" xml:space="preserve">
          <source>through a microscope. (Also known as &lt;b&gt;static scoping&lt;/b&gt;, because dictionaries don&amp;rsquo;t change very fast.) Similarly, looking at variables stored in a private dictionary (namespace) for each scope, which are visible only from their point of declaration down to the end of the lexical scope in which they are declared. &amp;mdash;Syn. &lt;b&gt;static scoping&lt;/b&gt;. &amp;mdash;Ant. &lt;b&gt;dynamic scoping&lt;/b&gt;.</source>
          <target state="translated">현미경을 통해. ( 사전은 매우 빠르게 변하지 않기 때문에 &lt;b&gt;정적 범위&lt;/b&gt; 라고도합니다 .) 마찬가지로 각 범위에 대한 개인 사전 (네임 스페이스)에 저장된 변수를 보면 선언 지점부터 어휘 끝까지 만 볼 수 있습니다. 그들이 선언 된 범위. -신. &lt;b&gt;정적 범위&lt;/b&gt; . -개미. &lt;b&gt;동적 범위 지정&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="29f2cee527fde0875c30d4c1970d60bf9fb82780" translate="yes" xml:space="preserve">
          <source>throw an exception when it encounters values it cannot represent in JSON (for example, filehandles) but instead will encode a JSON &lt;code&gt;null&lt;/code&gt; value. Note that blessed objects are not included here and are handled separately by c&amp;lt;allow_blessed&amp;gt;.</source>
          <target state="translated">JSON으로 표현할 수없는 값 (예 : 파일 핸들)을 발견하면 예외가 발생하지만 대신 JSON &lt;code&gt;null&lt;/code&gt; 값을 인코딩 합니다. blessed 객체는 여기에 포함되지 않으며 c &amp;lt;allow_blessed&amp;gt;에 의해 별도로 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="7d093729d13d411c553442c16ac6b1f0df0bcc0c" translate="yes" xml:space="preserve">
          <source>tical</source>
          <target state="translated">tical</target>
        </trans-unit>
        <trans-unit id="f34b4213c9c9df74f809ff19495a798e4c761264" translate="yes" xml:space="preserve">
          <source>tid</source>
          <target state="translated">tid</target>
        </trans-unit>
        <trans-unit id="60d1ebb2c4d10c1bc5d180dd48d310bd17db0874" translate="yes" xml:space="preserve">
          <source>tidy_ctype</source>
          <target state="translated">tidy_ctype</target>
        </trans-unit>
        <trans-unit id="1e70a9a194b9190f5a65168d9a305705d0920936" translate="yes" xml:space="preserve">
          <source>tidy_type</source>
          <target state="translated">tidy_type</target>
        </trans-unit>
        <trans-unit id="d2aac84308e80b4fb63b151dc37c7c4a2e32fe22" translate="yes" xml:space="preserve">
          <source>tie</source>
          <target state="translated">tie</target>
        </trans-unit>
        <trans-unit id="180634635138be11bbf70fd5873f68be37acd53f" translate="yes" xml:space="preserve">
          <source>tie %hash, 'IO::Dir', DIRNAME [, OPTIONS ]</source>
          <target state="translated">타이 % hash, 'IO :: Dir', DIRNAME [, OPTIONS]</target>
        </trans-unit>
        <trans-unit id="b4e33c910b4e7eb71286c936a6c361332078399f" translate="yes" xml:space="preserve">
          <source>tie VARIABLE,CLASSNAME,LIST</source>
          <target state="translated">VARIABLE, CLASSNAME, LIST 넥타이</target>
        </trans-unit>
        <trans-unit id="e4928b42c73f84e34a4cbffbf2834087ad0cee19" translate="yes" xml:space="preserve">
          <source>tied</source>
          <target state="translated">tied</target>
        </trans-unit>
        <trans-unit id="df86b3e8a462b28b236db851a750887038103f20" translate="yes" xml:space="preserve">
          <source>tied VARIABLE</source>
          <target state="translated">묶인 변수</target>
        </trans-unit>
        <trans-unit id="2e85433b3daf97a99df2c23e8c90186004129d91" translate="yes" xml:space="preserve">
          <source>tied_fh ()</source>
          <target state="translated">tied_fh ()</target>
        </trans-unit>
        <trans-unit id="ff6cf2585f1e6e98c02e8d8cf1589002179bc1e1" translate="yes" xml:space="preserve">
          <source>tied_method</source>
          <target state="translated">tied_method</target>
        </trans-unit>
        <trans-unit id="714eea0f4c980736bde0065fe73f573487f08e3a" translate="yes" xml:space="preserve">
          <source>time</source>
          <target state="translated">time</target>
        </trans-unit>
        <trans-unit id="8bedd2d2426e26856d06978dcbc418664f08036f" translate="yes" xml:space="preserve">
          <source>time ()</source>
          <target state="translated">시각 ()</target>
        </trans-unit>
        <trans-unit id="09ac2572253aca925ef88ce7e1e28523c07089a9" translate="yes" xml:space="preserve">
          <source>time it extracts a</source>
          <target state="translated">추출 시간</target>
        </trans-unit>
        <trans-unit id="07286d112af431ae059ec72f379797b0649ee105" translate="yes" xml:space="preserve">
          <source>time.h</source>
          <target state="translated">time.h</target>
        </trans-unit>
        <trans-unit id="84630135a484572a5561a54e5368a00578330efe" translate="yes" xml:space="preserve">
          <source>time_hosts</source>
          <target state="translated">time_hosts</target>
        </trans-unit>
        <trans-unit id="2286fbb8052fb4f6613993a9b211d9e7b999ca2c" translate="yes" xml:space="preserve">
          <source>time_is_hires</source>
          <target state="translated">time_is_hires</target>
        </trans-unit>
        <trans-unit id="6d18e6cb5739120f4bf0c36d8185f766d9c9e762" translate="yes" xml:space="preserve">
          <source>time_report</source>
          <target state="translated">time_report</target>
        </trans-unit>
        <trans-unit id="0fa9094ae420cc07dd72cc2146bd0ac470eb7764" translate="yes" xml:space="preserve">
          <source>time_size.U</source>
          <target state="translated">time_size.U</target>
        </trans-unit>
        <trans-unit id="30b9eb943f11cc22be9b7bb47777b5888ff2cf27" translate="yes" xml:space="preserve">
          <source>time_t issues that may or may not be fixed</source>
          <target state="translated">수정되거나 수정되지 않을 수있는 time_t 문제</target>
        </trans-unit>
        <trans-unit id="75b1467ae0f80598de6dbbe7d6b7e128d5112c5e" translate="yes" xml:space="preserve">
          <source>timediff ( T1, T2 )</source>
          <target state="translated">timediff ( T1, T2 )</target>
        </trans-unit>
        <trans-unit id="f5cce0aae7b188c70da27428d158685b039f43e7" translate="yes" xml:space="preserve">
          <source>timeit - run a chunk of code and see how long it goes</source>
          <target state="translated">timeit-코드 덩어리를 실행하고 시간이 얼마나 걸리는지 확인하십시오</target>
        </trans-unit>
        <trans-unit id="daf88465d0bbfe6114869776415807e4a8a3d6dd" translate="yes" xml:space="preserve">
          <source>timeit(COUNT, CODE)</source>
          <target state="translated">timeit(COUNT, CODE)</target>
        </trans-unit>
        <trans-unit id="954670b8c73f5c7bb2168e45afdf2a0fb1c32f04" translate="yes" xml:space="preserve">
          <source>timelocal() and timegm()</source>
          <target state="translated">timelocal () 및 timegm ()</target>
        </trans-unit>
        <trans-unit id="ed78f7c9e2c8ab6ab52a4ef6959fb94fbbeefdd4" translate="yes" xml:space="preserve">
          <source>timelocal_modern() and timegm_modern()</source>
          <target state="translated">timelocal_modern () 및 timegm_modern ()</target>
        </trans-unit>
        <trans-unit id="5dd09c96f8b5aa673fdf3f282372ee443a332317" translate="yes" xml:space="preserve">
          <source>timelocal_nocheck() and timegm_nocheck()</source>
          <target state="translated">timelocal_nocheck () 및 timegm_nocheck ()</target>
        </trans-unit>
        <trans-unit id="56d3c9490be2608ac36f5a4805bfec2f21f7f982" translate="yes" xml:space="preserve">
          <source>timeout</source>
          <target state="translated">timeout</target>
        </trans-unit>
        <trans-unit id="7196b5875f713c826bd279dbda843c897e2a60c2" translate="yes" xml:space="preserve">
          <source>times</source>
          <target state="translated">times</target>
        </trans-unit>
        <trans-unit id="40c151f1b434bfdec799ea12f9046021f74822e8" translate="yes" xml:space="preserve">
          <source>times not implemented</source>
          <target state="translated">구현되지 않은 시간</target>
        </trans-unit>
        <trans-unit id="be23d236f3757f152a1f24f600012c1e1d600a93" translate="yes" xml:space="preserve">
          <source>times). Any attempt to sleep for X seconds will most probably end up sleeping &lt;b&gt;more&lt;/b&gt; than that, but don't be surprised if you end up sleeping slightly &lt;b&gt;less&lt;/b&gt;.</source>
          <target state="translated">타임스). X 초 동안 잠을 자려고하면 아마도 &lt;b&gt;그&lt;/b&gt; 이상 잠을 자게 되지만, 잠을 &lt;b&gt;적게&lt;/b&gt; 자더라도 놀라지 마십시오 .</target>
        </trans-unit>
        <trans-unit id="83964e02ade0c707f1586c4af57b14359233ab39" translate="yes" xml:space="preserve">
          <source>timestr ( TIMEDIFF, [ STYLE, [ FORMAT ] ] )</source>
          <target state="translated">timestr (시차, [스타일, [형식]])</target>
        </trans-unit>
        <trans-unit id="cf8ad37cddb8d3b315a3079d8cafc0725bbf58d7" translate="yes" xml:space="preserve">
          <source>timesum ( T1, T2 )</source>
          <target state="translated">타임 섬 (T1, T2)</target>
        </trans-unit>
        <trans-unit id="e6e99aa511e14f5e9b7cca90f1f8ed0e81bea66d" translate="yes" xml:space="preserve">
          <source>timethese ( COUNT, CODEHASHREF, [ STYLE ] )</source>
          <target state="translated">timethese ( COUNT, CODEHASHREF, [ STYLE ] )</target>
        </trans-unit>
        <trans-unit id="3019ee89018972ae13827b09b3ebf41868413d56" translate="yes" xml:space="preserve">
          <source>timethese - run several chunks of code several times</source>
          <target state="translated">timethese-여러 덩어리의 코드를 여러 번 실행</target>
        </trans-unit>
        <trans-unit id="a773faa2ca0cd2b3cadd22d6af4754899821cb46" translate="yes" xml:space="preserve">
          <source>timethis ( COUNT, CODE, [ TITLE, [ STYLE ]] )</source>
          <target state="translated">timethis ( COUNT, CODE, [ TITLE, [ STYLE ]] )</target>
        </trans-unit>
        <trans-unit id="926b35fe102bbad8d28cfd9994879a682f7cc677" translate="yes" xml:space="preserve">
          <source>timethis - run a chunk of code several times</source>
          <target state="translated">timethis-코드 덩어리를 여러 번 실행</target>
        </trans-unit>
        <trans-unit id="3c6de1b7dd91465d437ef415f94f36afc1fbc8a8" translate="yes" xml:space="preserve">
          <source>title</source>
          <target state="translated">title</target>
        </trans-unit>
        <trans-unit id="3c6b42a3d4284795db5726131c6ed5652c12aac9" translate="yes" xml:space="preserve">
          <source>title (synonym 'name', 'label')</source>
          <target state="translated">제목 (동의어 '이름', '라벨')</target>
        </trans-unit>
        <trans-unit id="79f74fe9e99b6f6214a6214ba235a7cd2a04e0fd" translate="yes" xml:space="preserve">
          <source>title_postfix</source>
          <target state="translated">title_postfix</target>
        </trans-unit>
        <trans-unit id="667355ec302a4f025bcf6e8ed2687c08bee45df9" translate="yes" xml:space="preserve">
          <source>title_prefix</source>
          <target state="translated">title_prefix</target>
        </trans-unit>
        <trans-unit id="7d41631407b52413c97b7d1100dc6276733f6fbb" translate="yes" xml:space="preserve">
          <source>title_prefix, title_postfix</source>
          <target state="translated">title_prefix, title_postfix</target>
        </trans-unit>
        <trans-unit id="49d2d366348ec849f3fe5293c35de479fceb1791" translate="yes" xml:space="preserve">
          <source>titlecase</source>
          <target state="translated">titlecase</target>
        </trans-unit>
        <trans-unit id="11a6a2b3d697cfef5e657a3e04cbf393218a9c74" translate="yes" xml:space="preserve">
          <source>tkpod</source>
          <target state="translated">tkpod</target>
        </trans-unit>
        <trans-unit id="b0a26c3b37c1a62d9dcf68d6f22a141ab62e31a5" translate="yes" xml:space="preserve">
          <source>tmd</source>
          <target state="translated">tmd</target>
        </trans-unit>
        <trans-unit id="17a6670cac3b6f92b17bd856c31f8df0eee856e0" translate="yes" xml:space="preserve">
          <source>tmo</source>
          <target state="translated">tmo</target>
        </trans-unit>
        <trans-unit id="b981ddeb66f4b1df5a5dfaebb954677651eb168a" translate="yes" xml:space="preserve">
          <source>tmo=INTEGER</source>
          <target state="translated">tmo=INTEGER</target>
        </trans-unit>
        <trans-unit id="d515a572ec8566ae3c51d8bbe24ee44fc7ce67ea" translate="yes" xml:space="preserve">
          <source>tmon.out</source>
          <target state="translated">tmon.out</target>
        </trans-unit>
        <trans-unit id="c6ffdb358391388f25ac1ed547e1a08a28877da3" translate="yes" xml:space="preserve">
          <source>tmp</source>
          <target state="translated">tmp</target>
        </trans-unit>
        <trans-unit id="9a759bfaf45eb64b8592c5dd90f60ca87c7fdcc8" translate="yes" xml:space="preserve">
          <source>tmpdir</source>
          <target state="translated">tmpdir</target>
        </trans-unit>
        <trans-unit id="43142f7ae0d8c0db32d6f7da478c605157a1e20a" translate="yes" xml:space="preserve">
          <source>tmpdir (override)</source>
          <target state="translated">tmpdir (재정의)</target>
        </trans-unit>
        <trans-unit id="7856988903cb6f9b1e8c44315fcc780abf2cd6b2" translate="yes" xml:space="preserve">
          <source>tmpfile</source>
          <target state="translated">tmpfile</target>
        </trans-unit>
        <trans-unit id="a023d509548d02140075de775db16fc7988c11fc" translate="yes" xml:space="preserve">
          <source>tmpfile=/tmp/bison.$$.y echo %pure_parser &amp;gt; $tmpfile cat $1 &amp;gt;&amp;gt; $tmpfile</source>
          <target state="translated">tmpfile=/tmp/bison.$$.y echo %pure_parser &amp;gt; $tmpfile cat $1 &amp;gt;&amp;gt; $tmpfile</target>
        </trans-unit>
        <trans-unit id="efa1858ae39d33be07d0ea70cf91a0217532af0d" translate="yes" xml:space="preserve">
          <source>tmpfile=/tmp/bison.$$.y echo %pure_parser &amp;gt; $tmpfile cat $1&amp;gt;&amp;gt; $tmpfile</source>
          <target state="translated">tmpfile = / tmp / bison. $$. y echo % pure_parser&amp;gt; $ tmpfile cat $ 1 &amp;gt;&amp;gt; $ tmpfile</target>
        </trans-unit>
        <trans-unit id="102acf75547aa83dec59b4fdf55fc88b9269087d" translate="yes" xml:space="preserve">
          <source>tmpnam</source>
          <target state="translated">tmpnam</target>
        </trans-unit>
        <trans-unit id="bc66386d79a7765bfa508f8d33c8bf8bf944ee97" translate="yes" xml:space="preserve">
          <source>tmps_grow_p</source>
          <target state="translated">tmps_grow_p</target>
        </trans-unit>
        <trans-unit id="f67b82204486a97f18d5668c8a238d5eb98d90cc" translate="yes" xml:space="preserve">
          <source>tmptype</source>
          <target state="translated">tmptype</target>
        </trans-unit>
        <trans-unit id="4374aaee247fb237ce6c97d5c8d64bbe474d16de" translate="yes" xml:space="preserve">
          <source>to</source>
          <target state="translated">to</target>
        </trans-unit>
        <trans-unit id="b899c9ed0d531493fcaa9ca1f45e5ad5beb34771" translate="yes" xml:space="preserve">
          <source>to ( ADDRESS [, ADDRESS [...]] )</source>
          <target state="translated">받는 사람 (ADDRESS [, ADDRESS [...]])</target>
        </trans-unit>
        <trans-unit id="185a97a9a27d738e3e05a1447711e0289b354cc0" translate="yes" xml:space="preserve">
          <source>to 0 if &lt;code&gt;SvOOK(sv)&lt;/code&gt; is false.</source>
          <target state="translated">&lt;code&gt;SvOOK(sv)&lt;/code&gt; 가 false 이면 0으로 설정합니다 .</target>
        </trans-unit>
        <trans-unit id="a7a8440a5b466b35a00b7232359b592f1e66aaab" translate="yes" xml:space="preserve">
          <source>to 0 when it calls your function - the parameter is provided to allow your implementation to track depth if it needs to recurse.</source>
          <target state="translated">함수를 호출 할 때 0으로 설정-매개 변수는 재귀가 필요한 경우 구현에서 깊이를 추적 할 수 있도록 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="ea2a29e8310cf767872af505eeae2dea9e6cd141" translate="yes" xml:space="preserve">
          <source>to &lt;code&gt;LIBPATH&lt;/code&gt; (here for Perl DLL</source>
          <target state="translated">에 &lt;code&gt;LIBPATH&lt;/code&gt; 여기에 펄 DLL에 대한 (</target>
        </trans-unit>
        <trans-unit id="267663db9589a3745d5aef238877fd9533c61f70" translate="yes" xml:space="preserve">
          <source>to &lt;code&gt;Moose&lt;/code&gt; , meaning you can switch from &lt;code&gt;Moo&lt;/code&gt; to &lt;code&gt;Moose&lt;/code&gt; quite easily.</source>
          <target state="translated">에 &lt;code&gt;Moose&lt;/code&gt; , 당신은 전환 할 수 있습니다 의미 &lt;code&gt;Moo&lt;/code&gt; 에 &lt;code&gt;Moose&lt;/code&gt; 아주 쉽게.</target>
        </trans-unit>
        <trans-unit id="da1a2f1af2cd70acb91c8c647da7909b37f1768e" translate="yes" xml:space="preserve">
          <source>to &lt;code&gt;Moose&lt;/code&gt;, meaning you can switch from &lt;code&gt;Moo&lt;/code&gt; to &lt;code&gt;Moose&lt;/code&gt; quite easily.</source>
          <target state="translated">에 &lt;code&gt;Moose&lt;/code&gt; , 당신은 전환 할 수 있습니다 의미 &lt;code&gt;Moo&lt;/code&gt; 에 &lt;code&gt;Moose&lt;/code&gt; 아주 쉽게.</target>
        </trans-unit>
        <trans-unit id="25de92114260dd84a38a4dd129b16fa441223f76" translate="yes" xml:space="preserve">
          <source>to &lt;code&gt;hv_common()&lt;/code&gt; .</source>
          <target state="translated">에 &lt;code&gt;hv_common()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fe07e01396c22caff0f6459d70e08d8504646eb7" translate="yes" xml:space="preserve">
          <source>to &lt;code&gt;hv_common()&lt;/code&gt;.</source>
          <target state="translated">에 &lt;code&gt;hv_common()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8d86da4acbcdf14e86c5caa9f3ed9dcbc5be77df" translate="yes" xml:space="preserve">
          <source>to EXPR1 only (which might itself be a higher-precedence AND operator, for example, and thus subject to the previous rule), not to EXPR2. If EXPR1 is to use smartmatching, then EXPR2 also does so, no matter what EXPR2 contains. But if EXPR2 does not get to use smartmatching, then the second argument will not be either. This is quite different from the &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; case just described, so be careful.</source>
          <target state="translated">EXPR1이 아닌 EXPR1에만 해당됩니다 (예 : 우선 순위가 높은 AND 연산자 일 수 있으므로 이전 규칙 적용). EXPR1이 스마트 매칭을 사용하는 경우 EXPR2에 포함 된 내용에 관계없이 EXPR2도 그렇게합니다. 그러나 EXPR2가 스마트 매칭을 사용하지 않으면 두 번째 인수도 마찬가지입니다. 이것은 방금 설명한 &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; 사례 와는 매우 다르 므로주의하십시오.</target>
        </trans-unit>
        <trans-unit id="6154e47cbb357e834cd236e827be6a1934f7b9d2" translate="yes" xml:space="preserve">
          <source>to Encode canonical encoding name.</source>
          <target state="translated">표준 인코딩 이름을 인코딩합니다.</target>
        </trans-unit>
        <trans-unit id="ddbb5ed60cafc5157e96fb7243d2b67c73cd14b3" translate="yes" xml:space="preserve">
          <source>to GetOptions(). For each option that is specified on the command line, the option value will be stored in the hash with the option name as key. Options that are not actually used on the command line will not be put in the hash, on other words, &lt;code&gt;&lt;a href=&quot;../functions/exists&quot;&gt;exists($h{option})&lt;/a&gt;&lt;/code&gt; (or defined()) can be used to test if an option was used. The drawback is that warnings will be issued if the program runs under &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; strict&lt;/code&gt; and uses &lt;code&gt;$h{option}&lt;/code&gt; without testing with exists() or defined() first.</source>
          <target state="translated">GetOptions (). 명령 행에 지정된 각 옵션에 대해 옵션 값은 옵션 이름을 키로 해시에 저장됩니다. 실제로 명령 행에서 사용되지 않는 옵션은 해시에 넣지 않습니다. 즉, &lt;code&gt;&lt;a href=&quot;../functions/exists&quot;&gt;exists($h{option})&lt;/a&gt;&lt;/code&gt; (또는 defined ())를 사용하여 옵션이 사용되었는지 테스트 할 수 있습니다. 단점은 경고가 프로그램이 실행되는 경우에 따라 발행 될 것입니다 &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; strict&lt;/code&gt; 하고 사용 &lt;code&gt;$h{option}&lt;/code&gt; 첫번째) (() 또는 정의 된 존재로 테스트하지 않고.</target>
        </trans-unit>
        <trans-unit id="b9f9e9bbdc9539c38d247953d0db0b2d232ee363" translate="yes" xml:space="preserve">
          <source>to GetOptions(). For each option that is specified on the command line, the option value will be stored in the hash with the option name as key. Options that are not actually used on the command line will not be put in the hash, on other words, &lt;code&gt;exists($h{option})&lt;/code&gt; (or defined()) can be used to test if an option was used. The drawback is that warnings will be issued if the program runs under &lt;code&gt;use strict&lt;/code&gt; and uses &lt;code&gt;$h{option}&lt;/code&gt; without testing with exists() or defined() first.</source>
          <target state="translated">GetOptions ()에. 명령 줄에 지정된 각 옵션에 대해 옵션 값은 옵션 이름을 키로 사용하여 해시에 저장됩니다. 명령 줄에서 실제로 사용되지 않는 옵션은 해시에 넣지 않습니다. 즉, 옵션이 사용되었는지 테스트하는 데 &lt;code&gt;exists($h{option})&lt;/code&gt; (또는 defined ())를 사용할 수 있습니다. 단점은 경고가 프로그램이 실행되는 경우에 따라 발행 될 것입니다 &lt;code&gt;use strict&lt;/code&gt; 하고 사용 &lt;code&gt;$h{option}&lt;/code&gt; 첫번째) (() 또는 정의 된 존재로 테스트하지 않고.</target>
        </trans-unit>
        <trans-unit id="bfed2d9357f25a5be1ef229590525d9382ab9044" translate="yes" xml:space="preserve">
          <source>to POSITION; &lt;code&gt;1&lt;/code&gt; to set it to the current position plus POSITION; and &lt;code&gt;2&lt;/code&gt; to set it to EOF plus POSITION, typically negative. For WHENCE you may use the constants &lt;code&gt;SEEK_SET&lt;/code&gt; , &lt;code&gt;SEEK_CUR&lt;/code&gt; , and &lt;code&gt;SEEK_END&lt;/code&gt; (start of the file, current position, end of the file) from the &lt;a href=&quot;../fcntl&quot;&gt;Fcntl&lt;/a&gt; module. Returns &lt;code&gt;1&lt;/code&gt; on success, false otherwise.</source>
          <target state="translated">위치에; &lt;code&gt;1&lt;/code&gt; 을 현재 위치 + POSITION으로 설정합니다. 과 &lt;code&gt;2&lt;/code&gt; EOF 플러스 위치, 일반적으로 부정적으로 설정합니다. 당신이 상수를 사용할 수 있습니다 WHENCE를 들어 &lt;code&gt;SEEK_SET&lt;/code&gt; , &lt;code&gt;SEEK_CUR&lt;/code&gt; , 그리고 &lt;code&gt;SEEK_END&lt;/code&gt; 로부터 (파일, 현재 위치, 파일의 끝의 시작) &lt;a href=&quot;../fcntl&quot;&gt;은 fcntl의&lt;/a&gt; 모듈. 반환 &lt;code&gt;1&lt;/code&gt; 성공, 그렇지 않은 경우는 false.</target>
        </trans-unit>
        <trans-unit id="defce8e2effd8a4c5cb2f53c0955b6344cd557d2" translate="yes" xml:space="preserve">
          <source>to POSITION; &lt;code&gt;1&lt;/code&gt; to set it to the current position plus POSITION; and &lt;code&gt;2&lt;/code&gt; to set it to EOF plus POSITION, typically negative. For WHENCE you may use the constants &lt;code&gt;SEEK_SET&lt;/code&gt; , &lt;code&gt;SEEK_CUR&lt;/code&gt; , and &lt;code&gt;SEEK_END&lt;/code&gt; (start of the file, current position, end of the file) from the &lt;a href=&quot;fcntl&quot;&gt;Fcntl&lt;/a&gt; module. Returns &lt;code&gt;1&lt;/code&gt; on success, false otherwise.</source>
          <target state="translated">위치에; &lt;code&gt;1&lt;/code&gt; 을 현재 위치 + POSITION으로 설정합니다. 과 &lt;code&gt;2&lt;/code&gt; EOF 플러스 위치, 일반적으로 부정적으로 설정합니다. 당신이 상수를 사용할 수 있습니다 WHENCE를 들어 &lt;code&gt;SEEK_SET&lt;/code&gt; , &lt;code&gt;SEEK_CUR&lt;/code&gt; , 그리고 &lt;code&gt;SEEK_END&lt;/code&gt; 로부터 (파일, 현재 위치, 파일의 끝의 시작) &lt;a href=&quot;fcntl&quot;&gt;은 fcntl의&lt;/a&gt; 모듈. 반환 &lt;code&gt;1&lt;/code&gt; 성공, 그렇지 않은 경우는 false.</target>
        </trans-unit>
        <trans-unit id="c8a686fe9869178853026e542d9819a8d5c9e56e" translate="yes" xml:space="preserve">
          <source>to POSITION; &lt;code&gt;1&lt;/code&gt; to set it to the current position plus POSITION; and &lt;code&gt;2&lt;/code&gt; to set it to EOF plus POSITION, typically negative. For WHENCE you may use the constants &lt;code&gt;SEEK_SET&lt;/code&gt;, &lt;code&gt;SEEK_CUR&lt;/code&gt;, and &lt;code&gt;SEEK_END&lt;/code&gt; (start of the file, current position, end of the file) from the &lt;a href=&quot;fcntl&quot;&gt;Fcntl&lt;/a&gt; module. Returns &lt;code&gt;1&lt;/code&gt; on success, false otherwise.</source>
          <target state="translated">POSITION에; &lt;code&gt;1&lt;/code&gt; 은 현재 위치에 POSITION을 더한 값으로 설정합니다. 과 &lt;code&gt;2&lt;/code&gt; EOF 플러스 위치, 일반적으로 부정적으로 설정합니다. 당신이 상수를 사용할 수 있습니다 WHENCE를 들어 &lt;code&gt;SEEK_SET&lt;/code&gt; , &lt;code&gt;SEEK_CUR&lt;/code&gt; , 그리고 &lt;code&gt;SEEK_END&lt;/code&gt; 로부터 (파일, 현재 위치, 파일의 끝의 시작) &lt;a href=&quot;fcntl&quot;&gt;은 fcntl의&lt;/a&gt; 모듈. 반환 &lt;code&gt;1&lt;/code&gt; 성공, 그렇지 않은 경우는 false.</target>
        </trans-unit>
        <trans-unit id="75b325578f050782c8fcb428bd57b6b901bcfa73" translate="yes" xml:space="preserve">
          <source>to ThisProject/I18N/en.pm, because if _AUTO is true there, then just looking for an entry with the key &quot;Couldn't find file \&quot;[_1]\&quot;!\n&quot; in that lexicon will cause it to be added, with that value!</source>
          <target state="translated">이 프로젝트 /I18N/en.pm에 _AUTO가 true 인 경우 사전에 &quot;\\ [[]] \&quot;! \ n &quot;파일을 찾을 수 없습니다. 그 가치로 추가!</target>
        </trans-unit>
        <trans-unit id="4e2bc466b469a38537db455063735391ac2b8708" translate="yes" xml:space="preserve">
          <source>to a fixed number of given keys. Methods for creating and dealing with restricted hashes are exported by the &lt;a href=&quot;Hash::Util&quot;&gt;Hash::Util&lt;/a&gt; module.</source>
          <target state="translated">주어진 키의 고정 된 수에. 제한된 해시를 만들고 처리하는 방법은 &lt;a href=&quot;Hash::Util&quot;&gt;Hash :: Util&lt;/a&gt; 모듈 에서 내 보냅니다 .</target>
        </trans-unit>
        <trans-unit id="e87b45ec9b1a049ec58cd24d01f2b883881dc6b1" translate="yes" xml:space="preserve">
          <source>to a fixed number of given keys. Methods for creating and dealing with restricted hashes are exported by the &lt;a href=&quot;hash/util&quot;&gt;Hash::Util&lt;/a&gt; module.</source>
          <target state="translated">주어진 키의 고정 된 수. 제한된 해시를 만들고 처리하는 방법은 &lt;a href=&quot;hash/util&quot;&gt;Hash :: Util&lt;/a&gt; 모듈 에서 내 보냅니다 .</target>
        </trans-unit>
        <trans-unit id="4e4a587937f5eb29db9d3748369255d25b711ed0" translate="yes" xml:space="preserve">
          <source>to a location on your LIBPATH.</source>
          <target state="translated">LIBPATH의 위치로.</target>
        </trans-unit>
        <trans-unit id="18bb49c1ef9ac587c558bd725670f0c267932208" translate="yes" xml:space="preserve">
          <source>to a location on your PATH,</source>
          <target state="translated">PATH상의 위치로</target>
        </trans-unit>
        <trans-unit id="2b3bd4b5b703698e2ad6b1562ddbab4a68189abf" translate="yes" xml:space="preserve">
          <source>to a location on your PATH.</source>
          <target state="translated">당신의 경로에 위치.</target>
        </trans-unit>
        <trans-unit id="939b8956446b9c496d5bc76687ea6d90606d1987" translate="yes" xml:space="preserve">
          <source>to a named subroutine, e.g. a counter that gets initialized at creation time of the sub and can only be modified from within the sub. This is sometimes used with a BEGIN block in package files to make sure a variable doesn't get meddled with during the lifetime of the package:</source>
          <target state="translated">명명 된 서브 루틴 (예 : 서브 생성시 초기화되어 서브 서브 내에서만 수정 될 수있는 카운터). 패키지의 수명 동안 변수가 방해받지 않도록 패키지 파일의 BEGIN 블록과 함께 사용되는 경우가 있습니다.</target>
        </trans-unit>
        <trans-unit id="8b7626ae679ea958fb7e5cdec6a9ba3c92474dbf" translate="yes" xml:space="preserve">
          <source>to a pipe, you should also trap SIGPIPE. Otherwise, think of what happens when you start up a pipe to a command that doesn't exist: the open() will in all likelihood succeed (it only reflects the fork()'s success), but then your output will fail--spectacularly. Perl can't know whether the command worked, because your command is actually running in a separate process whose exec() might have failed. Therefore, while readers of bogus commands return just a quick EOF, writers to bogus commands will get hit with a signal, which they'd best be prepared to handle. Consider:</source>
          <target state="translated">파이프에 SIGPIPE를 가두어 야합니다. 그렇지 않으면 존재하지 않는 명령에 파이프를 시작할 때 어떤 일이 발생하는지 생각해보십시오. open ()은 성공 가능성이 있지만 (fork ()의 ​​성공 만 반영) 출력은 실패합니다. -안경상. exec ()가 실패한 별도의 프로세스에서 명령이 실제로 실행되고 있기 때문에 Perl은 명령이 작동했는지 여부를 알 수 없습니다. 따라서 가짜 명령의 독자는 빠른 EOF를 반환하지만 가짜 명령의 작성자는 신호에 부딪 치므로 처리하기에 가장 적합합니다. 치다:</target>
        </trans-unit>
        <trans-unit id="b23d84faa8fd585b1ad0710623852a699603f544" translate="yes" xml:space="preserve">
          <source>to a test program the intermediate directories used by &lt;code&gt;make&lt;/code&gt; are added to @INC.</source>
          <target state="translated">테스트 프로그램에서 &lt;code&gt;make&lt;/code&gt; 가 사용하는 중간 디렉토리 가 @INC에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="526cecdce9a6fa0844944fe2657ec40470921035" translate="yes" xml:space="preserve">
          <source>to access documentation for different components of Perl. Start with</source>
          <target state="translated">Perl의 다른 구성 요소에 대한 문서에 액세스합니다. 로 시작</target>
        </trans-unit>
        <trans-unit id="a2ba8c1859afb35af5e779dbe13b3f995b3be717" translate="yes" xml:space="preserve">
          <source>to access the perl documentation in the text form (note that you may get better results using perl manpages).</source>
          <target state="translated">텍스트 형식으로 펄 문서에 액세스하려면 (펄 맨 페이지를 사용하면 더 나은 결과를 얻을 수 있습니다).</target>
        </trans-unit>
        <trans-unit id="35a2c51838834c5c5405f168c5893280ce6cc0fe" translate="yes" xml:space="preserve">
          <source>to access these files.</source>
          <target state="translated">이러한 파일에 액세스하십시오.</target>
        </trans-unit>
        <trans-unit id="a373051c463e8242de6c723e14201a15eb5f2163" translate="yes" xml:space="preserve">
          <source>to accommodate Unix conventions used in some ported software.</source>
          <target state="translated">일부 포팅 된 소프트웨어에서 사용되는 유닉스 규약을 수용합니다.</target>
        </trans-unit>
        <trans-unit id="96139e6ce18c0ad4b4fafb25595c35fdf4683fa4" translate="yes" xml:space="preserve">
          <source>to accomplish this, but full details are in &lt;a href=&quot;perllocale#Unicode-and-UTF-8&quot;&gt;&quot;Unicode and UTF-8&quot; in perllocale&lt;/a&gt;, including gotchas that happen if you don't specify &lt;code&gt;:not_characters&lt;/code&gt;.</source>
          <target state="translated">이를 수행하기 위해, 그러나 전체 세부 사항은 &lt;a href=&quot;perllocale#Unicode-and-UTF-8&quot;&gt;perllocale의 &quot;유니 코드 및 UTF-8&quot;에&lt;/a&gt; 있습니다 &lt;code&gt;:not_characters&lt;/code&gt; 에는 : not_characters를 지정하지 않으면 발생하는 문제도 포함됩니다 .</target>
        </trans-unit>
        <trans-unit id="190b00af4099b5490f23b24ef3dc8e2fe342b61b" translate="yes" xml:space="preserve">
          <source>to accomplish this, but full details are in &lt;a href=&quot;perllocale#Unicode-and-UTF-8&quot;&gt;Unicode and UTF-8 in perllocale&lt;/a&gt;, including gotchas that happen if you don't specify &lt;code&gt;:not_characters&lt;/code&gt; .</source>
          <target state="translated">이를 달성하기 위해, 그러나 &lt;code&gt;:not_characters&lt;/code&gt; 를 지정하지 않으면 발생하는 문제를 포함하여 &lt;a href=&quot;perllocale#Unicode-and-UTF-8&quot;&gt;perllocale의&lt;/a&gt; 전체 세부 사항은 Unicode 및 UTF-8로되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="a73a7bc7d432310b47d7dadb7338f6296927937c" translate="yes" xml:space="preserve">
          <source>to add your own encoding to perl. No knowledge of XS is necessary.</source>
          <target state="translated">펄에 자신의 인코딩을 추가합니다. XS에 대한 지식이 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b89fc290c98c21f78eb1c3d3de205c05b005a94d" translate="yes" xml:space="preserve">
          <source>to allocate memory for a Perl interpreter. It's quite a simple function, and the guts of it looks like this:</source>
          <target state="translated">Perl 인터프리터에 메모리를 할당합니다. 그것은 매우 간단한 함수이며, 그 내장은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5df238e4f59f47ed3e559a86abb5276789fd76b7" translate="yes" xml:space="preserve">
          <source>to and</source>
          <target state="translated">~에</target>
        </trans-unit>
        <trans-unit id="39a68d5c47c1ad6ff50ff1f20660276dfbe7b579" translate="yes" xml:space="preserve">
          <source>to any operators already permitted).</source>
          <target state="translated">이미 허용 된 모든 운영자에게).</target>
        </trans-unit>
        <trans-unit id="4e4aea7cc45e5a243b887f99efd85a8793d033fa" translate="yes" xml:space="preserve">
          <source>to apply &lt;code&gt;/aa&lt;/code&gt; to all regular expressions compiled within its scope. See &lt;a href=&quot;re&quot;&gt;re&lt;/a&gt;.</source>
          <target state="translated">범위 내에서 컴파일 된 모든 정규식에 &lt;code&gt;/aa&lt;/code&gt; 를 적용 합니다. &lt;a href=&quot;re&quot;&gt;다시&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="3a7e4483f93948ccc15b247fcdc95d124ee3e0d4" translate="yes" xml:space="preserve">
          <source>to be</source>
          <target state="translated">되려고</target>
        </trans-unit>
        <trans-unit id="e893999fc61c9f9942e8865609ed6dc8816fc20e" translate="yes" xml:space="preserve">
          <source>to be able to use these macros:</source>
          <target state="translated">이 매크로를 사용하려면 :</target>
        </trans-unit>
        <trans-unit id="cf5d8c9c97a4054f2de2d35e98379bb8f2987a69" translate="yes" xml:space="preserve">
          <source>to be an @AoA, but rather just a reference to it, you could do something more like this:</source>
          <target state="translated">@AoA가 아니라 오히려 그것에 대한 참조 인 경우 다음과 같이 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="019a46c6c83d83e2e7dd74db5f7d357036618f87" translate="yes" xml:space="preserve">
          <source>to be appended to the stream. The</source>
          <target state="translated">스트림에 추가됩니다. 그만큼</target>
        </trans-unit>
        <trans-unit id="138b1321ccfe075171a68061e5a1117b091492e4" translate="yes" xml:space="preserve">
          <source>to be considered as the location of an error. The &lt;code&gt;carp()&lt;/code&gt; and &lt;code&gt;cluck()&lt;/code&gt; functions will skip over callers when reporting where an error occurred.</source>
          <target state="translated">오류의 위치로 간주됩니다. &lt;code&gt;carp()&lt;/code&gt; 와 &lt;code&gt;cluck()&lt;/code&gt; 에러가 발생한 경우에보고하는 기능은 발신자를 스킵한다.</target>
        </trans-unit>
        <trans-unit id="3d8894d272d9670db059eb36fa388b92f6748964" translate="yes" xml:space="preserve">
          <source>to be created. The</source>
          <target state="translated">만들 수 있습니다. 그만큼</target>
        </trans-unit>
        <trans-unit id="2739734d586e1b9c33fdab5031065a4f1ef6fa45" translate="yes" xml:space="preserve">
          <source>to be different from the uncompressed filename or when the input is a filehandle or a buffer.</source>
          <target state="translated">압축되지 않은 파일 이름과 다르거 나 입력이 파일 핸들 또는 버퍼 인 경우.</target>
        </trans-unit>
        <trans-unit id="84fb3256daf84c2b7c36def5c86135fead88552e" translate="yes" xml:space="preserve">
          <source>to be fed. (Since you see _1 and a _2 being used in the key there.)</source>
          <target state="translated">먹일 것이다. (키에 _1과 _2가 사용되고있는 것을 볼 수 있습니다.)</target>
        </trans-unit>
        <trans-unit id="98524352b3e61275f42e3fc522841353e48b08c2" translate="yes" xml:space="preserve">
          <source>to be in effect when perl</source>
          <target state="translated">펄 때 효과가</target>
        </trans-unit>
        <trans-unit id="9097c450459841a2c90326c3983db931499d5b36" translate="yes" xml:space="preserve">
          <source>to be less precisely specified. Details are in &lt;a href=&quot;#LOOSE-MATCHES&quot;&gt;&quot;LOOSE MATCHES&quot;&lt;/a&gt;.</source>
          <target state="translated">덜 정확하게 지정됩니다. 자세한 내용은 &lt;a href=&quot;#LOOSE-MATCHES&quot;&gt;&quot;LOOSE MATCHES&quot;에&lt;/a&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="76f8048f660e2d2cd4ca7c267d990f0c9732b9fb" translate="yes" xml:space="preserve">
          <source>to be less precisely specified. Details are in &lt;a href=&quot;#LOOSE-MATCHES&quot;&gt;LOOSE MATCHES&lt;/a&gt;.</source>
          <target state="translated">덜 정확하게 지정해야합니다. 자세한 내용은 &lt;a href=&quot;#LOOSE-MATCHES&quot;&gt;LOOSE MATCHES에&lt;/a&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="5a25cde4d1302e9dba53eb4907caba9ff77c35bd" translate="yes" xml:space="preserve">
          <source>to be null. This function is also thread safe on the small scale. It uses appropriate locking to avoid race conditions in accessing &lt;a href=&quot;#PL_check&quot;&gt;PL_check&lt;/a&gt;.</source>
          <target state="translated">null이된다 이 기능은 소규모 스레드에서도 안전합니다. &lt;a href=&quot;#PL_check&quot;&gt;PL_check&lt;/a&gt; 에 액세스 할 때 경쟁 조건을 피하기 위해 적절한 잠금을 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="21dd034cad4a68cb0f3514ae6d7eeb39d86eb334" translate="yes" xml:space="preserve">
          <source>to be provided to &lt;code&gt;autodie&lt;/code&gt; on how it should detect failure from user-defined subroutines. While these</source>
          <target state="translated">사용자 정의 서브 루틴에서 실패를 감지하는 방법에 대해 &lt;code&gt;autodie&lt;/code&gt; 에 제공됩니다 . 이 동안</target>
        </trans-unit>
        <trans-unit id="3d0279bbb98c4fed8cbeea6e8338eb32180ee838" translate="yes" xml:space="preserve">
          <source>to be symlinks to the actual binary. If that can't be done, system administrators are strongly encouraged to put (symlinks to) perl and its accompanying utilities into a directory typically found along a user's PATH, or in some other obvious and convenient place.</source>
          <target state="translated">실제 바이너리에 대한 심볼릭 링크입니다. 그렇게 할 수없는 경우, 시스템 관리자는 perl 및 그와 함께 제공되는 유틸리티를 일반적으로 사용자의 PATH 또는 다른 명백하고 편리한 위치에있는 디렉토리에 넣는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="c1312f43c3145ddd16b2a7f06695a0db02e8b75a" translate="yes" xml:space="preserve">
          <source>to be used to determine if a constant is to be defined.</source>
          <target state="translated">상수 정의 여부를 결정하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="6dfaa48eefc09804912e9e020597db19ee8f8e41" translate="yes" xml:space="preserve">
          <source>to be written out later. Data in the deferred write buffer is also charged against the memory limit you set with the &lt;code&gt;memory&lt;/code&gt; option.</source>
          <target state="translated">나중에 작성합니다. 지연된 쓰기 버퍼의 데이터는 또한 &lt;code&gt;memory&lt;/code&gt; 옵션으로 설정 한 메모리 제한에 따라 청구 됩니다.</target>
        </trans-unit>
        <trans-unit id="f6eae6f36fad068d13506b3de1e258315a973b7f" translate="yes" xml:space="preserve">
          <source>to become the heir to MakeMaker. MakeMaker's maintainers have long said that it is a dead end and should be kept functioning, but not extended with new features. It's complicated enough as it is!</source>
          <target state="translated">MakeMaker의 상속자가됩니다. 메이크 메이커의 관리자는 오랫동안 막 다른 골목이며 기능을 유지해야하지만 새로운 기능으로 확장되어서는 안된다고 말했다. 그대로 복잡합니다!</target>
        </trans-unit>
        <trans-unit id="10bea89bc1bab84cd4aaf94aa297bb9d22e305dc" translate="yes" xml:space="preserve">
          <source>to become the heir to MakeMaker. MakeMaker's maintainers have long said that it is a dead end and should be kept functioning, while being cautious about extending with new features.</source>
          <target state="translated">MakeMaker의 상속자가되기 위해 MakeMaker의 메인테이너는 그것이 막 다른 길이며 새로운 기능으로 확장하는 것에 대해 조심하면서 계속 작동해야한다고 오랫동안 말했습니다.</target>
        </trans-unit>
        <trans-unit id="e42231196dcb18697b456290fa711408575dbc64" translate="yes" xml:space="preserve">
          <source>to both EXPR1 and EXPR2. Only if</source>
          <target state="translated">EXPR1과 EXPR2 모두에. 경우에만</target>
        </trans-unit>
        <trans-unit id="924eea1cd1b5f3404a8c17a7ccb24dd497472a1c" translate="yes" xml:space="preserve">
          <source>to build perl with support for 64-bit integers (&lt;code&gt;use64bitint&lt;/code&gt; ) or both 64-bit integers and 64-bit addressing (&lt;code&gt;use64bitall&lt;/code&gt; ). In the latter case, the resulting binary will run only on G5-based hosts.</source>
          <target state="translated">64 비트 정수 ( &lt;code&gt;use64bitint&lt;/code&gt; ) 또는 64 비트 정수 및 64 비트 주소 지정 ( &lt;code&gt;use64bitall&lt;/code&gt; )을 모두 지원하여 perl을 빌드 합니다. 후자의 경우 결과 바이너리는 G5 기반 호스트에서만 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="77d2914498ef18446b92ef1041d769819022c7fd" translate="yes" xml:space="preserve">
          <source>to build perl with support for 64-bit integers (&lt;code&gt;use64bitint&lt;/code&gt;) or both 64-bit integers and 64-bit addressing (&lt;code&gt;use64bitall&lt;/code&gt;). In the latter case, the resulting binary will run only on G5-based hosts.</source>
          <target state="translated">64 비트 정수 ( &lt;code&gt;use64bitint&lt;/code&gt; ) 또는 64 비트 정수와 64 비트 주소 지정 ( &lt;code&gt;use64bitall&lt;/code&gt; )을 모두 지원하는 perl을 빌드 합니다. 후자의 경우 결과 바이너리는 G5 기반 호스트에서만 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="c2960ffda3ff18124ff7f6c2b946df0ddafabbc1" translate="yes" xml:space="preserve">
          <source>to calculate checksums. For the Perl interface, the order of the two parameters in both functions has been reversed. This allows both running checksums and one off calculations to be done.</source>
          <target state="translated">체크섬을 계산합니다. Perl 인터페이스의 경우 두 기능에서 두 매개 변수의 순서가 반대로 바뀌 었습니다. 이를 통해 실행중인 체크섬과 일회성 계산을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f1ff4110b7f360c5f885656fb1f505733e089b06" translate="yes" xml:space="preserve">
          <source>to capture, if desired. You will have to do this if you plan to use &lt;a href=&quot;#%28%2AACCEPT%29-%28%2AACCEPT%3Aarg%29&quot;&gt;&quot;(*ACCEPT) (*ACCEPT:arg)&quot;&lt;/a&gt; and not have it bypass the script run checking.</source>
          <target state="translated">원하는 경우 캡처합니다. 사용하려는 경우이 작업을 수행해야 할 것이다 &lt;a href=&quot;#%28%2AACCEPT%29-%28%2AACCEPT%3Aarg%29&quot;&gt;&quot;(* 동의) (* 동의 : ARG)&quot;를&lt;/a&gt; 하고 스크립트 실행 검사를 건너 뛸 수를 가지고 있지.</target>
        </trans-unit>
        <trans-unit id="216f4d2f0bbcf6e74daa148b9f8a286adfde05e3" translate="yes" xml:space="preserve">
          <source>to change if the message change in some way. Another property is that digest functions are one-way functions, that is it should be</source>
          <target state="translated">메시지가 어떤 식 으로든 변경되면 또 다른 속성은 다이제스트 함수가 단방향 함수라는 것입니다.</target>
        </trans-unit>
        <trans-unit id="103883c712727958c6de7ae9820b677419a7e766" translate="yes" xml:space="preserve">
          <source>to check for DCL procedure. If this fails, checks directories in DCL$PATH and finally</source>
          <target state="translated">DCL 절차를 확인하십시오. 이것이 실패하면 DCL $ PATH에서 디렉토리를 확인하고 마지막으로</target>
        </trans-unit>
        <trans-unit id="731aa951e967b4db2f011ced9dc08b9a36920510" translate="yes" xml:space="preserve">
          <source>to command pipes is to use &lt;code&gt;&quot;|-&quot;&lt;/code&gt; in place of &lt;code&gt;&quot;-|&quot;&lt;/code&gt; .</source>
          <target state="translated">파이프를 명령하는 것은 &lt;code&gt;&quot;-|&quot;&lt;/code&gt; 대신 &lt;code&gt;&quot;|-&quot;&lt;/code&gt; 를 사용 하는 것입니다 .</target>
        </trans-unit>
        <trans-unit id="9321f1e814a77339784f9b764d2917e556840708" translate="yes" xml:space="preserve">
          <source>to command pipes is to use &lt;code&gt;&quot;|-&quot;&lt;/code&gt; in place of &lt;code&gt;&quot;-|&quot;&lt;/code&gt;.</source>
          <target state="translated">명령 파이프는 &lt;code&gt;&quot;-|&quot;&lt;/code&gt; 대신 &lt;code&gt;&quot;|-&quot;&lt;/code&gt; 를 사용 하는 것입니다. .</target>
        </trans-unit>
        <trans-unit id="33a43350f70aed99b64d60955734bbec9e9f87af" translate="yes" xml:space="preserve">
          <source>to compile Perl 32-bit. Don't bother with -n32 unless you have 7.1 or later compilers (use cc -version to check).</source>
          <target state="translated">Perl 32 비트를 컴파일합니다. 7.1 이상의 컴파일러가없는 경우 (cc -version을 사용하여 확인하지 않는 한) -n32를 사용하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="743d2eefcb5e3c10bbc64054994c2c15486d8e77" translate="yes" xml:space="preserve">
          <source>to convert perl utilities to</source>
          <target state="translated">펄 유틸리티를</target>
        </trans-unit>
        <trans-unit id="7b210708522f858c74dc655b94df0449b71778b2" translate="yes" xml:space="preserve">
          <source>to create a &lt;code&gt;float&lt;/code&gt; , and</source>
          <target state="translated">생성하는 &lt;code&gt;float&lt;/code&gt; 하고,</target>
        </trans-unit>
        <trans-unit id="5614b530ce8e2eabb42d0cdfa9a23acbb4f28bcf" translate="yes" xml:space="preserve">
          <source>to create a &lt;code&gt;float&lt;/code&gt;, and</source>
          <target state="translated">생성하는 &lt;code&gt;float&lt;/code&gt; 하고,</target>
        </trans-unit>
        <trans-unit id="cf2348a6ec6eaf3d48ed051b15a33749f439c666" translate="yes" xml:space="preserve">
          <source>to create a string:</source>
          <target state="translated">문자열을 만들려면</target>
        </trans-unit>
        <trans-unit id="1c8c7bdde3e8f34c6791da2b20254e6dd797fa43" translate="yes" xml:space="preserve">
          <source>to create an &lt;code&gt;&lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt;&lt;/code&gt;,</source>
          <target state="translated">만드는 &lt;code&gt;&lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt;&lt;/code&gt; ,</target>
        </trans-unit>
        <trans-unit id="7f9aec1698bb0ad388ae6a3304201276acf8ea00" translate="yes" xml:space="preserve">
          <source>to create an &lt;code&gt;int&lt;/code&gt;,</source>
          <target state="translated">만드는 &lt;code&gt;int&lt;/code&gt; ,</target>
        </trans-unit>
        <trans-unit id="6abff830d9aee9d0e01d8789752ed03356a1172e" translate="yes" xml:space="preserve">
          <source>to create an object with &lt;code&gt;&lt;a href=&quot;../functions/bless&quot;&gt;bless&lt;/a&gt; {Name =&amp;gt; ...}, $class&lt;/code&gt; , and call define_encoding. They inherit their &lt;code&gt;name&lt;/code&gt; method from &lt;code&gt;Encode::Encoding&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../functions/bless&quot;&gt;bless&lt;/a&gt; {Name =&amp;gt; ...}, $class&lt;/code&gt; 를 사용하여 객체를 만들고 define_encoding을 호출합니다. &lt;code&gt;Encode::Encoding&lt;/code&gt; 에서 &lt;code&gt;name&lt;/code&gt; 메소드를 상속합니다 .</target>
        </trans-unit>
        <trans-unit id="60590c166367e28cde493edfc500b971e66371a8" translate="yes" xml:space="preserve">
          <source>to create an object with &lt;code&gt;bless {Name =&amp;gt; ...}, $class&lt;/code&gt;, and call define_encoding. They inherit their &lt;code&gt;name&lt;/code&gt; method from &lt;code&gt;Encode::Encoding&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;bless {Name =&amp;gt; ...}, $class&lt;/code&gt; 를 사용하여 객체를 만들고 define_encoding을 호출합니다. &lt;code&gt;Encode::Encoding&lt;/code&gt; 에서 &lt;code&gt;name&lt;/code&gt; 메서드를 상속합니다 .</target>
        </trans-unit>
        <trans-unit id="13fb3853d5ec1540d5748eb0dd803110ae60da5e" translate="yes" xml:space="preserve">
          <source>to define a &lt;code&gt;run&lt;/code&gt; method. If you're writing a Pod-formatter class, you should define a &lt;code&gt;run&lt;/code&gt; just so that users can call &lt;code&gt;parse_file&lt;/code&gt; etc, but you don't</source>
          <target state="translated">&lt;code&gt;run&lt;/code&gt; 방법 을 정의합니다 . &lt;code&gt;parse_file&lt;/code&gt; 포매터 클래스를 작성하는 경우 사용자가 parse_file 등을 호출 할 수 있도록 &lt;code&gt;run&lt;/code&gt; 정의해야합니다.</target>
        </trans-unit>
        <trans-unit id="fa25e581ba33f3b37cb13af067edbde6e164f972" translate="yes" xml:space="preserve">
          <source>to denote a capturing group of the form &lt;a href=&quot;perlre#%28%3FPARNO%29-%28%3F-PARNO%29-%28%3F%2BPARNO%29-%28%3FR%29-%28%3F0%29&quot;&gt;&lt;code&gt;(?&lt;i&gt;PARNO&lt;/i&gt;)&lt;/code&gt;&lt;/a&gt;, but omitted the &lt;code&gt;&quot;)&quot;&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;perlre#%28%3FPARNO%29-%28%3F-PARNO%29-%28%3F%2BPARNO%29-%28%3FR%29-%28%3F0%29&quot;&gt; &lt;code&gt;(?&lt;i&gt;PARNO&lt;/i&gt;)&lt;/code&gt; &lt;/a&gt; 형식의 캡처 그룹을 &lt;i&gt;나타내지&lt;/i&gt; 만 &lt;code&gt;&quot;)&quot;&lt;/code&gt; 는 생략했습니다 .</target>
        </trans-unit>
        <trans-unit id="a5a63182de86c8a3e6163d98d58dd2623e455299" translate="yes" xml:space="preserve">
          <source>to denote a capturing group of the form &lt;a href=&quot;perlre#(%3fPARNO)-(%3f-PARNO)-(%3f%2bPARNO)-(%3fR)-(%3f0)&quot;&gt;(?PARNO)&lt;/a&gt;, but omitted the &lt;code&gt;&quot;)&quot;&lt;/code&gt; .</source>
          <target state="translated">&lt;a href=&quot;perlre#(%3fPARNO)-(%3f-PARNO)-(%3f%2bPARNO)-(%3fR)-(%3f0)&quot;&gt;(? PARNO)&lt;/a&gt; 형식의 캡처 그룹을 나타내지 만 &lt;code&gt;&quot;)&quot;&lt;/code&gt; 는 생략했습니다 .</target>
        </trans-unit>
        <trans-unit id="95c7af9d6ca4741280ae12ff21ab09e9cdf25647" translate="yes" xml:space="preserve">
          <source>to display it; if</source>
          <target state="translated">그것을 표시하기 위해; 만약</target>
        </trans-unit>
        <trans-unit id="e3e5845a22ed917abc0126267df7df44ea895291" translate="yes" xml:space="preserve">
          <source>to display the path to the module. In some cases (for example, the &lt;code&gt;AutoLoader&lt;/code&gt; module), this command will show the path to a separate &lt;code&gt;pod&lt;/code&gt; file; the module itself should be in the same directory, with a 'pm' file extension.</source>
          <target state="translated">모듈 경로를 표시합니다. 경우에 따라 (예 : &lt;code&gt;AutoLoader&lt;/code&gt; 모듈)이 명령은 별도의 &lt;code&gt;pod&lt;/code&gt; 파일에 대한 경로를 표시 합니다. 모듈 자체는 파일 확장자가 'pm'인 동일한 디렉토리에 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="876e43e0908079d66a492e080439c57dff35438a" translate="yes" xml:space="preserve">
          <source>to do so. And</source>
          <target state="translated">그렇게하기 위해. 과</target>
        </trans-unit>
        <trans-unit id="f1f436ccb34e6e74927261af818ca2c0ab267a46" translate="yes" xml:space="preserve">
          <source>to emphasize this.</source>
          <target state="translated">이것을 강조합니다.</target>
        </trans-unit>
        <trans-unit id="b947a7d83a90fd93960468bbd8002c295475ab0c" translate="yes" xml:space="preserve">
          <source>to enable an experimental switch feature. This is loosely based on an old version of a Perl 6 proposal, but it no longer resembles the Perl 6 construct. You also get the switch feature whenever you declare that your code prefers to run under a version of Perl that is 5.10 or later. For example:</source>
          <target state="translated">실험적인 스위치 기능을 활성화합니다. 이것은 이전 버전의 Perl 6 제안을 기반으로했지만 더 이상 Perl 6 구성과 유사하지 않습니다. 또한 코드가 5.10 이상인 Perl 버전에서 실행되는 것을 선호한다고 선언 할 때마다 스위치 기능을 사용할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4e9cda1f0976bb6ab88625f3e0eebd341d184d8c" translate="yes" xml:space="preserve">
          <source>to enable an experimental switch feature. This is loosely based on an old version of a Raku proposal, but it no longer resembles the Raku construct. You also get the switch feature whenever you declare that your code prefers to run under a version of Perl that is 5.10 or later. For example:</source>
          <target state="translated">실험적인 스위치 기능을 활성화합니다. 이는 이전 버전의 Raku 제안을 기반으로하지만 더 이상 Raku 구성과 유사하지 않습니다. 또한 코드가 5.10 이상의 Perl 버전에서 실행되는 것을 선호한다고 선언 할 때마다 스위치 기능을 사용할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="82473b502decf667eb5cf57e3f13cb772ed8ed58" translate="yes" xml:space="preserve">
          <source>to enable you to see what locales there are on the current platform.</source>
          <target state="translated">현재 플랫폼에 어떤 로캘이 있는지 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1f092c62aa2cf37ff8e36cf49d58d75de683036e" translate="yes" xml:space="preserve">
          <source>to execute, rather than the one it has just executed.</source>
          <target state="translated">방금 실행 한 것이 아니라 실행합니다.</target>
        </trans-unit>
        <trans-unit id="524e0ea0502df43dfa1f4421c6984ecb109dc7fd" translate="yes" xml:space="preserve">
          <source>to extract an ASCII tar archive on OS/390, try this:</source>
          <target state="translated">OS / 390에서 ASCII tar 아카이브를 추출하려면 다음을 시도하십시오.</target>
        </trans-unit>
        <trans-unit id="c7f1cc49694bdea53f292e349a4d22a16060be85" translate="yes" xml:space="preserve">
          <source>to extract the data itself, you'll need a dereference: $$s1</source>
          <target state="translated">데이터 자체를 추출하려면 역 참조가 필요합니다 : $$ s1</target>
        </trans-unit>
        <trans-unit id="4d5ac57125dea2095aaaa7c0c7b7f13d75e8dcb7" translate="yes" xml:space="preserve">
          <source>to fetch or store the record at line &lt;code&gt;$n&lt;/code&gt; , respectively; similarly the other tied array methods. (See &lt;a href=&quot;../perltie&quot;&gt;perltie&lt;/a&gt; for details.) You may also call the following methods on this object:</source>
          <target state="translated">&lt;code&gt;$n&lt;/code&gt; 행에서 레코드를 각각 가져 오거나 저장합니다 . 마찬가지로 다른 묶인 배열 방법. (자세한 내용은 &lt;a href=&quot;../perltie&quot;&gt;perltie&lt;/a&gt; 를 참조하십시오.)이 객체에 대해 다음 메소드를 호출 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="a31de509d5ceda8a6e6203c95aea66bba7c6215f" translate="yes" xml:space="preserve">
          <source>to fetch or store the record at line &lt;code&gt;$n&lt;/code&gt;, respectively; similarly the other tied array methods. (See &lt;a href=&quot;perltie&quot;&gt;perltie&lt;/a&gt; for details.) You may also call the following methods on this object:</source>
          <target state="translated">&lt;code&gt;$n&lt;/code&gt; 행에서 레코드를 가져 오거나 저장합니다 . 유사하게 다른 묶인 배열 방법. (자세한 내용은 &lt;a href=&quot;perltie&quot;&gt;perltie&lt;/a&gt; 를 참조하십시오.)이 개체에 대해 다음 메서드를 호출 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="c2fa42d27aad6d50b2bc31ff51bcae0729ca7103" translate="yes" xml:space="preserve">
          <source>to find a message that correspond to some given digest. Algorithms differ in how &quot;likely&quot; and how &quot;hard&quot;, as well as how efficient they are to compute.</source>
          <target state="translated">주어진 다이제스트에 해당하는 메시지를 찾습니다. 알고리즘은 계산 방법의 효율성뿐만 아니라 &quot;가능성&quot;과 &quot;하드&quot;방법이 다릅니다.</target>
        </trans-unit>
        <trans-unit id="3e21a74ff876d5884a9cd3e42c0a803a127bfc89" translate="yes" xml:space="preserve">
          <source>to find out more about how to use it.</source>
          <target state="translated">사용 방법에 대해 자세히 알아보십시오.</target>
        </trans-unit>
        <trans-unit id="8087a685db9dd787b7e7ce5d9406c7b5f62f7733" translate="yes" xml:space="preserve">
          <source>to find suspiciously skipped tests, and other fishy events.</source>
          <target state="translated">의심스럽게 건너 뛴 테스트 및 기타 비린내 이벤트를 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="05876fc85384e9a9cd4d1a17944b0c5c87fe2794" translate="yes" xml:space="preserve">
          <source>to get Perl to work well with them. The catch is that you have to translate from the locale character set to/from Unicode yourself. See &lt;a href=&quot;#Unicode-I%2FO&quot;&gt;&quot;Unicode I/O&quot;&lt;/a&gt; above for how to</source>
          <target state="translated">Perl이 그들과 잘 작동하도록합니다. 문제는 로케일 문자 세트에서 유니 코드로 /에서 직접 번역해야한다는 것입니다. 참조 &lt;a href=&quot;#Unicode-I%2FO&quot;&gt;&quot;유니 코드 I / O를&quot;&lt;/a&gt; 방법에 대한 위</target>
        </trans-unit>
        <trans-unit id="c3817e3dfa074e1068e390eca87ad8f05b3f5748" translate="yes" xml:space="preserve">
          <source>to get Perl to work well with them. The catch is that you have to translate from the locale character set to/from Unicode yourself. See &lt;a href=&quot;#Unicode-I%2fO&quot;&gt;Unicode I/O&lt;/a&gt; above for how to</source>
          <target state="translated">펄이 그들과 잘 어울리도록 캐치 로케일 문자 세트에서 유니 코드로 또는 유니 코드로 변환해야합니다. 방법은 위의 &lt;a href=&quot;#Unicode-I%2fO&quot;&gt;유니 코드 I / O를&lt;/a&gt; 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="ac0a825f6340f8ac1be51fe954ab53df2d302874" translate="yes" xml:space="preserve">
          <source>to get Unicode rules, as the &lt;code&gt;\L&lt;/code&gt; in the former (but not necessarily the latter) would also use Unicode rules.</source>
          <target state="translated">전자 의 &lt;code&gt;\L&lt;/code&gt; (후자는 아니지만)도 유니 코드 규칙을 사용하므로 유니 코드 규칙 을 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="cdb6284e25e399322757d97afb2ac2e493d2f13d" translate="yes" xml:space="preserve">
          <source>to get a hexadecimal digit, or</source>
          <target state="translated">16 진수를 얻거나</target>
        </trans-unit>
        <trans-unit id="27f7cc40b0d49d40409799e7b80753e06a93c82a" translate="yes" xml:space="preserve">
          <source>to get a hexadecimal digit.</source>
          <target state="translated">16 진수를 얻으려면.</target>
        </trans-unit>
        <trans-unit id="6dff39424d11acaf9846ad1872f40e67f2726554" translate="yes" xml:space="preserve">
          <source>to get a list of anonymous hashes each with only one entry apiece.</source>
          <target state="translated">각각 하나의 항목 만있는 익명 해시 목록을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="df95aa7d96ad35561dea936c7dfdb0c59259e424" translate="yes" xml:space="preserve">
          <source>to get all normal letters of the English alphabet, or</source>
          <target state="translated">영어 알파벳의 모든 일반 문자를 가져 오거나</target>
        </trans-unit>
        <trans-unit id="9453fbce4c219f28d8e1fe0f3939d307058adf72" translate="yes" xml:space="preserve">
          <source>to get both unique invocation</source>
          <target state="translated">두 가지 독특한 호출을 얻기 위해</target>
        </trans-unit>
        <trans-unit id="aa4caba4c31a5fb34a97e1d00d7e9e413e73365c" translate="yes" xml:space="preserve">
          <source>to get dates with leading zeros.</source>
          <target state="translated">선행 0으로 날짜를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="50762a3ff6749c2acd704a3da54e894b5fad43b6" translate="yes" xml:space="preserve">
          <source>to get four files containing &quot;Hello World!\n&quot; in ASCII, CP 0037 EBCDIC, ISO 8859-1 (Latin-1) (in this example identical to ASCII since only ASCII characters were printed), and UTF-EBCDIC (in this example identical to normal EBCDIC since only characters that don't differ between EBCDIC and UTF-EBCDIC were printed). See the documentation of &lt;a href=&quot;Encode::PerlIO&quot;&gt;Encode::PerlIO&lt;/a&gt; for details.</source>
          <target state="translated">ASCII, CP 0037 EBCDIC, ISO 8859-1 (Latin-1) (이 예에서는 ASCII 문자 만 인쇄되었으므로 ASCII와 동일) 및 UTF-EBCDIC (여기에서는 EBCDIC와 UTF-EBCDIC 사이에 차이가없는 문자 만 인쇄되었으므로 일반 EBCDIC와 동일한 예). 자세한 내용은 &lt;a href=&quot;Encode::PerlIO&quot;&gt;Encode :: PerlIO&lt;/a&gt; 문서를 참조 하십시오.</target>
        </trans-unit>
        <trans-unit id="42b10c1b27c37e1c3b1556a16293d2db17e7beb7" translate="yes" xml:space="preserve">
          <source>to get four files containing &quot;Hello World!\n&quot; in ASCII, CP 0037 EBCDIC, ISO 8859-1 (Latin-1) (in this example identical to ASCII since only ASCII characters were printed), and UTF-EBCDIC (in this example identical to normal EBCDIC since only characters that don't differ between EBCDIC and UTF-EBCDIC were printed). See the documentation of &lt;a href=&quot;encode/perlio&quot;&gt;Encode::PerlIO&lt;/a&gt; for details.</source>
          <target state="translated">ASCII, CP 0037 EBCDIC, ISO 8859-1 (Latin-1) (ASCII 문자 만 인쇄되었으므로 ASCII와 동일) 및 UTF-EBCDIC ( &quot; 예를 들어 EBCDIC과 UTF-EBCDIC간에 다르지 않은 문자 만 인쇄되었으므로 일반 EBCDIC과 동일합니다. 자세한 내용은 &lt;a href=&quot;encode/perlio&quot;&gt;Encode :: PerlIO&lt;/a&gt; 설명서를 참조 하십시오.</target>
        </trans-unit>
        <trans-unit id="de3ce866e70fbbb00ef331a4afcdb22c60892ea4" translate="yes" xml:space="preserve">
          <source>to get official Unicode named characters in regular expressions. Loose matching is always done for these.</source>
          <target state="translated">정규식에서 공식 유니 코드 명명 된 문자를 가져옵니다. 이들에 대해서는 항상 느슨한 일치가 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="28603ac6b28eec67b3e188373d6a6a06869faeb7" translate="yes" xml:space="preserve">
          <source>to get the correct function definitions. If</source>
          <target state="translated">올바른 기능 정의를 얻으려면. 만약</target>
        </trans-unit>
        <trans-unit id="470ba0f2f1c7ef2528debf493d9f58f588db9ebf" translate="yes" xml:space="preserve">
          <source>to get the repaired variant. For backward compatibility with older versions of perl, you can instead decrement the reference count manually when you're returning one of the aforementioned types using &lt;code&gt;sv_2mortal&lt;/code&gt; :</source>
          <target state="translated">수리 된 변종을 얻을 수 있습니다. 이전 버전의 perl과의 호환성을 위해 &lt;code&gt;sv_2mortal&lt;/code&gt; 을 사용하여 위에서 언급 한 유형 중 하나를 반환 할 때 참조 횟수를 수동으로 줄일 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="19730ebd61f1f4dc3ff2184e59d75cf2b22279ea" translate="yes" xml:space="preserve">
          <source>to get the repaired variant. For backward compatibility with older versions of perl, you can instead decrement the reference count manually when you're returning one of the aforementioned types using &lt;code&gt;sv_2mortal&lt;/code&gt;:</source>
          <target state="translated">수리 된 변형을 얻으려면. 이전 버전의 perl과의 하위 호환성을 위해 &lt;code&gt;sv_2mortal&lt;/code&gt; 을 사용하여 앞서 언급 한 유형 중 하나를 반환 할 때 참조 횟수를 수동으로 줄일 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="48d35469aac726018b9cbf58b42ec28989fe44ca" translate="yes" xml:space="preserve">
          <source>to get the value of this into the proper command. You must be prepared to do the</source>
          <target state="translated">이 값을 적절한 명령으로 가져옵니다. 당신은 할 준비가되어 있어야합니다</target>
        </trans-unit>
        <trans-unit id="abac24d2e236e321f06c59d2c39149a3827039e7" translate="yes" xml:space="preserve">
          <source>to get two files containing &quot;Hello World!\n&quot; in ASCII, EBCDIC, ISO Latin-1 (in this example identical to ASCII) respective UTF-EBCDIC (in this example identical to normal EBCDIC). See the documentation of Encode::PerlIO for details.</source>
          <target state="translated">ASCII, EBCDIC, ISO Latin-1 (이 예에서는 ASCII와 동일)에 각각의 UTF-EBCDIC (이 예에서는 일반 EBCDIC와 동일)에 &quot;Hello World! \ n&quot;을 포함하는 두 개의 파일을 가져옵니다. 자세한 내용은 Encode :: PerlIO 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="be7707df760253ac698371ee35058456da264ad3" translate="yes" xml:space="preserve">
          <source>to give the output</source>
          <target state="translated">출력을 제공하기 위해</target>
        </trans-unit>
        <trans-unit id="6234813623d065b30366ac94d161191137eaa4a6" translate="yes" xml:space="preserve">
          <source>to have the same value, namely &lt;code&gt;Larry&lt;/code&gt; . The problem is caused by the way that the associative array interface works. Basically, when the associative array interface is used to fetch the value associated with a given key, it will only ever retrieve the first value.</source>
          <target state="translated">같은 값, 즉 &lt;code&gt;Larry&lt;/code&gt; 입니다. 연관 배열 인터페이스가 작동하는 방식으로 인해 문제가 발생합니다. 기본적으로 연관 배열 인터페이스가 주어진 키와 연관된 값을 페치하는 데 사용될 때 첫 번째 값만 검색합니다.</target>
        </trans-unit>
        <trans-unit id="42ec5feec67a619524332260dd4a0336b3cb6d47" translate="yes" xml:space="preserve">
          <source>to have the same value, namely &lt;code&gt;Larry&lt;/code&gt;. The problem is caused by the way that the associative array interface works. Basically, when the associative array interface is used to fetch the value associated with a given key, it will only ever retrieve the first value.</source>
          <target state="translated">동일한 값, 즉 &lt;code&gt;Larry&lt;/code&gt; 를 갖도록합니다 . 이 문제는 연관 배열 인터페이스가 작동하는 방식으로 인해 발생합니다. 기본적으로 연관 배열 인터페이스를 사용하여 주어진 키와 관련된 값을 가져 오면 첫 번째 값만 검색됩니다.</target>
        </trans-unit>
        <trans-unit id="052b0b761fb9034f5ea9b20f5549120959dfbd83" translate="yes" xml:space="preserve">
          <source>to hold an entire symbol table entry. The type prefix of a typeglob is a &lt;code&gt;*&lt;/code&gt; , because it represents all types. This used to be the preferred way to pass arrays and hashes by reference into a function, but now that we have real references, this is seldom needed.</source>
          <target state="translated">전체 기호 테이블 항목을 보유합니다. typeglob의 타입 접두사 는 모든 타입을 나타 내기 때문에 &lt;code&gt;*&lt;/code&gt; 입니다. 이것은 참조로 배열과 해시를 함수에 전달하는 선호되는 방법 이었지만 이제는 실제 참조가 있으므로 거의 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7b35b0c1676a2a228feab13ef90fd760b4029c1c" translate="yes" xml:space="preserve">
          <source>to hold an entire symbol table entry. The type prefix of a typeglob is a &lt;code&gt;*&lt;/code&gt;, because it represents all types. This used to be the preferred way to pass arrays and hashes by reference into a function, but now that we have real references, this is seldom needed.</source>
          <target state="translated">전체 기호 테이블 항목을 보유합니다. typeglob의 유형 접두사 는 모든 유형을 나타 내기 때문에 &lt;code&gt;*&lt;/code&gt; 입니다. 이것은 참조로 배열과 해시를 함수에 전달하는 데 선호되는 방법 이었지만 이제는 실제 참조가 있으므로 거의 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2a7f2b88fab3883f2a61c5f5e56375cc228d7086" translate="yes" xml:space="preserve">
          <source>to implement your class.</source>
          <target state="translated">수업을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="9288e371db7100023b08879f0e4418c3566949b3" translate="yes" xml:space="preserve">
          <source>to incorporate the new code.</source>
          <target state="translated">새 코드를 통합합니다.</target>
        </trans-unit>
        <trans-unit id="82d8dafd0d3e9763c0065dba7872f47129cd0ee6" translate="yes" xml:space="preserve">
          <source>to install it locally. (Remember that if you do this, you'll have to put &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; lib &quot;/my/perl_directory&quot;;&lt;/code&gt; near the top of the program that is to use this module.</source>
          <target state="translated">로컬로 설치합니다. (이렇게 할 경우, 당신은 넣어해야 기억 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; lib &quot;/my/perl_directory&quot;;&lt;/code&gt; 이 모듈을 사용하는 프로그램의 상단에.</target>
        </trans-unit>
        <trans-unit id="57cda0d32989f491a2cb80337d3bbded0030404b" translate="yes" xml:space="preserve">
          <source>to install it locally. (Remember that if you do this, you'll have to put &lt;code&gt;use lib &quot;/my/perl_directory&quot;;&lt;/code&gt; near the top of the program that is to use this module.</source>
          <target state="translated">로컬로 설치합니다. (이렇게하면 이 모듈을 사용할 프로그램의 맨 위에 &lt;code&gt;use lib &quot;/my/perl_directory&quot;;&lt;/code&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="16a7203162e974acc6e6c3f1d7e8eb2095e9ba68" translate="yes" xml:space="preserve">
          <source>to invoke the Perl subroutine.</source>
          <target state="translated">Perl 서브 루틴을 호출합니다.</target>
        </trans-unit>
        <trans-unit id="d2094dc8f62bd8afcfca075e224337bbb8e418f3" translate="yes" xml:space="preserve">
          <source>to it, see &lt;code&gt;emxbind&lt;/code&gt; . Note that under DOS for best results one should use RSX runtime, which has much more functions working (like &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;popen&lt;/code&gt; and so on). In fact RSX is required if there is no VCPI present. Note the RSX requires DPMI. Many implementations of DPMI are known to be very buggy, beware!</source>
          <target state="translated">그것에 대해서는 &lt;code&gt;emxbind&lt;/code&gt; 를 참조하십시오 . DOS에서 최상의 결과를 얻으려면 RSX 런타임을 사용해야합니다.이 기능은 &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;popen&lt;/code&gt; 등과 같은 훨씬 더 많은 기능 을 수행합니다. 실제로 VCPI가없는 경우 RSX가 필요합니다. RSX에는 DPMI가 필요합니다. DPMI의 많은 구현은 매우 버그가있는 것으로 알려져 있습니다.</target>
        </trans-unit>
        <trans-unit id="d73f5cb44e3fe2b28001d8b08dfce02f88053026" translate="yes" xml:space="preserve">
          <source>to it, see &lt;code&gt;emxbind&lt;/code&gt;. Note that under DOS for best results one should use RSX runtime, which has much more functions working (like &lt;code&gt;fork&lt;/code&gt;, &lt;code&gt;popen&lt;/code&gt; and so on). In fact RSX is required if there is no VCPI present. Note the RSX requires DPMI. Many implementations of DPMI are known to be very buggy, beware!</source>
          <target state="translated">그것에 대해서는 &lt;code&gt;emxbind&lt;/code&gt; 를 참조하십시오 . DOS에서 최상의 결과를 얻으려면 훨씬 더 많은 기능 ( &lt;code&gt;fork&lt;/code&gt; , &lt;code&gt;popen&lt;/code&gt; 등)이 작동하는 RSX 런타임을 사용해야합니다 . 실제로 VCPI가 없으면 RSX가 필요합니다. RSX에는 DPMI가 필요합니다. DPMI의 많은 구현은 매우 버그가있는 것으로 알려져 있습니다.주의하십시오!</target>
        </trans-unit>
        <trans-unit id="f36471c25aedce46774baa311699fbc627e4ee94" translate="yes" xml:space="preserve">
          <source>to let Perl see the &lt;a href=&quot;#-p&quot;&gt;&quot;-p&quot;&lt;/a&gt; switch.</source>
          <target state="translated">Perl이 &lt;a href=&quot;#-p&quot;&gt;&quot;-p&quot;&lt;/a&gt; 스위치를 볼 수 있도록 합니다.</target>
        </trans-unit>
        <trans-unit id="1e7c69bdd02005a68c5a0491f7b22563882513e5" translate="yes" xml:space="preserve">
          <source>to let Perl see the &lt;b&gt;-p&lt;/b&gt; switch.</source>
          <target state="translated">Perl이 &lt;b&gt;-p&lt;/b&gt; 스위치 를 보도록 합니다.</target>
        </trans-unit>
        <trans-unit id="1ff1c6954004cf196e1c94a305ba6e22060530e7" translate="yes" xml:space="preserve">
          <source>to list some (not all may be available simultaneously), or it may be read</source>
          <target state="translated">일부를 나열하거나 (모두 동시에 사용 가능한 것은 아님) 읽거나 읽을 수 있습니다</target>
        </trans-unit>
        <trans-unit id="fb94ceb0e63eca810548f16a667eaaf1f49016f4" translate="yes" xml:space="preserve">
          <source>to loop through the</source>
          <target state="translated">를 통해 루프</target>
        </trans-unit>
        <trans-unit id="17fd8d3f491879c310e35f1017671959de50087e" translate="yes" xml:space="preserve">
          <source>to make Configure look only into the system libraries. If you have some extra library directories that you really want to use (such as newer Berkeley DB libraries in pre-Panther systems), add those to the libpth:</source>
          <target state="translated">Configure를 시스템 라이브러리에만 표시합니다. 실제로 사용하려는 추가 라이브러리 디렉토리 (예 : Panther 이전 시스템의 최신 Berkeley DB 라이브러리)가있는 경우 libpth에 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="fee487ddca5f479ff130a7872bae8c3bd3026aad" translate="yes" xml:space="preserve">
          <source>to make it loadable, that's not recommended. And while you may wish to INSTALL the image for performance reasons, you should not install it with privileges; if you do, the result will not be what you expect as image privileges are disabled during Perl start-up.</source>
          <target state="translated">로드 할 수있게하려면 권장하지 않습니다. 성능상의 이유로 이미지를 설치하려고 할 때 특권으로 이미지를 설치해서는 안됩니다. 그렇게하면 Perl 시작 중에 이미지 권한이 비활성화되어 예상 한 결과가되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7e8b91fe91200b67fd11849738943032a8974f07" translate="yes" xml:space="preserve">
          <source>to merely a lexically scoped</source>
          <target state="translated">어휘 범위 만</target>
        </trans-unit>
        <trans-unit id="65db7660c749d5fcb9c05bfb31af1aed3a85d7da" translate="yes" xml:space="preserve">
          <source>to not evaluate &lt;code&gt;foo($bar)&lt;/code&gt; and &lt;code&gt;baz($quux)&lt;/code&gt; when the test is being skipped. But in reality, they</source>
          <target state="translated">테스트를 건너 뛸 때 &lt;code&gt;foo($bar)&lt;/code&gt; 및 &lt;code&gt;baz($quux)&lt;/code&gt; 평가하지 않습니다 . 그러나 실제로는</target>
        </trans-unit>
        <trans-unit id="0b442daf0bb11680f2bfe3b64bf4e03e8bea49d4" translate="yes" xml:space="preserve">
          <source>to obtain the text of an HTML-file in an array with all the HTML-tags automagically removed.</source>
          <target state="translated">모든 HTML 태그가 자동으로 제거 된 배열에서 HTML 파일의 텍스트를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="4b2182d04008a6c4483613ec47473dff2770a53d" translate="yes" xml:space="preserve">
          <source>to other arrays or hashes.</source>
          <target state="translated">다른 배열이나 해시에.</target>
        </trans-unit>
        <trans-unit id="15de79039ea4eec6320dd0634c5be1d5bee366ab" translate="yes" xml:space="preserve">
          <source>to other threading models is the fact that for each new thread created, a complete copy of all the variables and data of the parent thread has to be taken. Thus, thread creation can be quite expensive, both in terms of memory usage and time spent in creation. The ideal way to reduce these costs is to have a relatively short number of long-lived threads, all created fairly early on (before the base thread has accumulated too much data). Of course, this may not always be possible, so compromises have to be made. However, after a thread has been created, its performance and extra memory usage should be little different than ordinary code.</source>
          <target state="translated">다른 스레딩 모델에는 새로 생성 된 각 스레드에 대해 상위 스레드의 모든 변수 및 데이터의 전체 사본을 가져와야합니다. 따라서 스레드 사용은 메모리 사용량과 생성에 소요 된 시간 측면에서 상당히 비쌀 수 있습니다. 이러한 비용을 줄이는 이상적인 방법은 비교적 짧은 수의 장기 스레드를 확보하는 것입니다 (모두 초기 스레드가 너무 많은 데이터를 축적하기 전에 상당히 초기에 작성 됨). 물론 이것이 항상 가능한 것은 아니므로 타협해야합니다. 그러나 스레드가 생성 된 후에는 성능과 추가 메모리 사용량이 일반 코드와 거의 다를 것입니다.</target>
        </trans-unit>
        <trans-unit id="6d9f660d23753136c732ed3417bb35f81b614dbf" translate="yes" xml:space="preserve">
          <source>to overload &lt;code&gt;&lt;a href=&quot;functions/q&quot;&gt;q&lt;/a&gt;&lt;/code&gt;-quoted strings, constant pieces of &lt;code&gt;&lt;a href=&quot;functions/qq&quot;&gt;qq&lt;/a&gt;&lt;/code&gt;- and &lt;code&gt;&lt;a href=&quot;functions/qx&quot;&gt;qx&lt;/a&gt;&lt;/code&gt;-quoted strings and here-documents,</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/q&quot;&gt;q&lt;/a&gt;&lt;/code&gt; 인용 문자열, 상수 &lt;code&gt;&lt;a href=&quot;functions/qq&quot;&gt;qq&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;functions/qx&quot;&gt;qx&lt;/a&gt;&lt;/code&gt; 인용 문자열 및 here-documents 를 오버로드하기 위해</target>
        </trans-unit>
        <trans-unit id="319c1af1aac0078a8652058b382fb6aaa659f685" translate="yes" xml:space="preserve">
          <source>to overload &lt;code&gt;q&lt;/code&gt;-quoted strings, constant pieces of &lt;code&gt;qq&lt;/code&gt;- and &lt;code&gt;qx&lt;/code&gt;-quoted strings and here-documents,</source>
          <target state="translated">&lt;code&gt;q&lt;/code&gt; 인용 문자열, &lt;code&gt;qq&lt;/code&gt; 상수 조각 및 &lt;code&gt;qx&lt;/code&gt; 인용 문자열 및 여기 문서 를 오버로드 합니다.</target>
        </trans-unit>
        <trans-unit id="fb28b87e78501f2d3eca0d75953390d95bf41915" translate="yes" xml:space="preserve">
          <source>to overload constant pieces of regular expressions.</source>
          <target state="translated">상수 정규 표현식에 과부하가 걸리도록합니다.</target>
        </trans-unit>
        <trans-unit id="7518dc6c2decddb256b0beec05b88725ea598d80" translate="yes" xml:space="preserve">
          <source>to overload floating point constants,</source>
          <target state="translated">부동 소수점 상수를 과부하</target>
        </trans-unit>
        <trans-unit id="a9ea6185dd3a9dac0c2c5aa1392ed399b440469d" translate="yes" xml:space="preserve">
          <source>to overload integer constants,</source>
          <target state="translated">정수 상수를 오버로드하기 위해</target>
        </trans-unit>
        <trans-unit id="1c08091b29060daf620ad3d7ec2c2d06ecc69649" translate="yes" xml:space="preserve">
          <source>to overload octal and hexadecimal constants,</source>
          <target state="translated">8 진 및 16 진 상수를 오버로드하기 위해</target>
        </trans-unit>
        <trans-unit id="d97647accfb12d624a3129c029044df4503b3f5c" translate="yes" xml:space="preserve">
          <source>to override this behavior for the overlong malformations, but don't do that except for very specialized purposes.</source>
          <target state="translated">지나치게 긴 기형에 대해이 동작을 재정의하되 매우 특수한 목적을 제외하고는 그렇게하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="9b474c3310dec8d9c670c459ff75dbe974576aea" translate="yes" xml:space="preserve">
          <source>to perform operations, it is strongly suggested you assure filesystem availability by reading the root of the mounted filesystem.</source>
          <target state="translated">작업을 수행하려면 마운트 된 파일 시스템의 루트를 읽어 파일 시스템 가용성을 보장하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="29f192cae973f004ae05716dbe6e5ada512317df" translate="yes" xml:space="preserve">
          <source>to prevent both obvious and subtle traps. Some of these checks are reasonably simple, such as verifying that path directories aren't writable by others; careful programmers have always used checks like these. Other checks, however, are best supported by the language itself, and it is these checks especially that contribute to making a set-id Perl program more secure than the corresponding C program.</source>
          <target state="translated">명백하고 미묘한 함정을 방지합니다. 이러한 검사 중 일부는 경로 디렉터리를 다른 사람이 쓸 수 없는지 확인하는 등 합리적으로 간단합니다. 신중한 프로그래머는 항상 이와 같은 검사를 사용했습니다. 그러나 다른 검사는 언어 자체에서 가장 잘 지원되며, 특히 이러한 검사는 set-id Perl 프로그램을 해당 C 프로그램보다 더 안전하게 만드는 데 기여합니다.</target>
        </trans-unit>
        <trans-unit id="51a61bd662ae21c882779433ed339801bd6a9c26" translate="yes" xml:space="preserve">
          <source>to properly restore the &lt;code&gt;LC_NUMERIC&lt;/code&gt; state.</source>
          <target state="translated">&lt;code&gt;LC_NUMERIC&lt;/code&gt; 상태 를 올바르게 복원합니다 .</target>
        </trans-unit>
        <trans-unit id="da0f2469f8436e8ff32aedc3a2323005a898d520" translate="yes" xml:space="preserve">
          <source>to put wrappers around your scripts.</source>
          <target state="translated">스크립트 주위에 래퍼를 넣습니다.</target>
        </trans-unit>
        <trans-unit id="cfa21274611a5bd065878064455b524270569032" translate="yes" xml:space="preserve">
          <source>to refer a cross-compilation that was created last time.</source>
          <target state="translated">마지막에 만들어진 크로스 컴파일을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="12fc5bdacdc78921dfce599673ebebe3fcce9f11" translate="yes" xml:space="preserve">
          <source>to reflect this.</source>
          <target state="translated">이것을 반영하기 위해.</target>
        </trans-unit>
        <trans-unit id="659a407adecfa0f6a484510887ce5ba33ab3d34a" translate="yes" xml:space="preserve">
          <source>to reflect where did you put the files. Note that if you have some primitive unzipper (like &lt;code&gt;pkunzip&lt;/code&gt; ), you may get a lot of warnings/errors during unzipping. Upgrade to &lt;code&gt;(w)unzip&lt;/code&gt;.</source>
          <target state="translated">파일을 어디에 넣었는지 반영합니다. &lt;code&gt;pkunzip&lt;/code&gt; 과 같은 원시 압축 해제 도구가 있으면 압축 해제 중에 많은 경고 / 오류가 발생할 수 있습니다. &lt;code&gt;(w)unzip&lt;/code&gt; 으로 업그레이드하십시오 .</target>
        </trans-unit>
        <trans-unit id="380acf54d5e76b2378c696e4441b58de93e91d2c" translate="yes" xml:space="preserve">
          <source>to reflect where did you put the files. Note that if you have some primitive unzipper (like &lt;code&gt;pkunzip&lt;/code&gt;), you may get a lot of warnings/errors during unzipping. Upgrade to &lt;code&gt;(w)unzip&lt;/code&gt;.</source>
          <target state="translated">파일을 어디에 넣었는지 반영합니다. 기본 압축 풀기 (예 : &lt;code&gt;pkunzip&lt;/code&gt; )가있는 경우 압축을 푸는 동안 많은 경고 / 오류가 발생할 수 있습니다. &lt;code&gt;(w)unzip&lt;/code&gt; 으로 업그레이드하십시오 .</target>
        </trans-unit>
        <trans-unit id="9d2ba7014727c3cc2499d98334c80eba94773412" translate="yes" xml:space="preserve">
          <source>to reflect your system and run it.</source>
          <target state="translated">시스템을 반영하고 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="db1fcc80f1845b94060d95e1b395529dd2239931" translate="yes" xml:space="preserve">
          <source>to remove all ignored untracked files, such as build and test byproduct, but leave any manually created files alone.</source>
          <target state="translated">빌드 및 테스트 부산물과 같이 추적되지 않은 모든 무시 된 파일을 제거하고 수동으로 생성 된 파일은 그대로 둡니다.</target>
        </trans-unit>
        <trans-unit id="30da90be3004960cc299558d7d829b8d3034dec1" translate="yes" xml:space="preserve">
          <source>to remove all the leading comments on the fly during the build. In order to be as portable as possible, please consider using a Perl one-liner rather than Unix (or other) utilities, as above. The # is escaped for the Makefile, since what is going to be generated will then be:</source>
          <target state="translated">빌드 중에 모든 주요 주석을 즉시 제거합니다. 가능한 한 이식하려면 위와 같이 Unix (또는 기타) 유틸리티 대신 Perl 한 줄짜리 유틸리티를 사용하는 것이 좋습니다. 생성 될 내용은 다음과 같으므로 #은 Makefile에 대해 이스케이프됩니다.</target>
        </trans-unit>
        <trans-unit id="ec73e98b9f1082cb61c5dad4025d258ca0df1374" translate="yes" xml:space="preserve">
          <source>to remove all the leading comments on the fly during the build. The extra \\ are necessary, unfortunately, because this variable is interpolated within the context of a Perl program built on the command line, and double quotes are what is used with the -e switch to build that command line. The # is escaped for the Makefile, since what is going to be generated will then be:</source>
          <target state="translated">빌드 중에 모든 주요 주석을 즉시 제거합니다. 불행히도이 변수는 명령 행에 빌드 된 Perl 프로그램의 컨텍스트 내에서 보간되기 때문에 여분의 \\가 필요하며, 큰 따옴표는 해당 명령 행을 빌드하기 위해 -e 스위치와 함께 사용됩니다. 생성 될 내용은 다음과 같으므로 #은 Makefile에서 이스케이프됩니다.</target>
        </trans-unit>
        <trans-unit id="9495b5887b6df8e7d2cf4b53399b33d3bb6d5092" translate="yes" xml:space="preserve">
          <source>to report and view bugs.</source>
          <target state="translated">버그를보고하고 봅니다.</target>
        </trans-unit>
        <trans-unit id="1b4afcbda2b19adfed5bf43ff3a2fceb0b887353" translate="yes" xml:space="preserve">
          <source>to resume where the calculation left off.</source>
          <target state="translated">계산이 중단 된 지점에서 다시 시작합니다.</target>
        </trans-unit>
        <trans-unit id="4dbe32b44e63c55a1908194065d741dad727fd9a" translate="yes" xml:space="preserve">
          <source>to return a list and we didn't check for that possibility and take appropriate action the Perl stack would end up in an inconsistent state. That is something you</source>
          <target state="translated">목록을 반환하고 해당 가능성을 확인하지 않았으며 Perl 스택이 일관성이없는 상태가되는 적절한 조치를 취했습니다. 그건 당신이 뭔가</target>
        </trans-unit>
        <trans-unit id="1de7ba1a0f349839e616c4dfb1b79ba2ff660b67" translate="yes" xml:space="preserve">
          <source>to run &lt;code&gt;make install&lt;/code&gt; . If you are not, you must have write access to the directories in question.</source>
          <target state="translated">&lt;code&gt;make install&lt;/code&gt; 을 실행하십시오 . 그렇지 않은 경우 해당 디렉토리에 대한 쓰기 권한이 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="c44b3602b064eda236b62cd237a66397b31d28cf" translate="yes" xml:space="preserve">
          <source>to run &lt;code&gt;make install&lt;/code&gt;. If you are not, you must have write access to the directories in question.</source>
          <target state="translated">&lt;code&gt;make install&lt;/code&gt; 을 실행합니다 . 그렇지 않은 경우 해당 디렉토리에 대한 쓰기 액세스 권한이 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="27c25c5a7db8dc8fe81c102692d1f0f0767d22d3" translate="yes" xml:space="preserve">
          <source>to run under DOS without any external support by binding</source>
          <target state="translated">바인딩을 통해 외부 지원없이 DOS에서 실행</target>
        </trans-unit>
        <trans-unit id="885ddcd0e32212c4767b159144995a96f781aa74" translate="yes" xml:space="preserve">
          <source>to run. A zero signifies the default of 3 seconds. For example to run at least for 10 seconds:</source>
          <target state="translated">실행합니다. 0은 기본값 3 초를 나타냅니다. 예를 들어 10 초 이상 실행하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="a9f69c5df4d7b34c9f46f4c5644a4993567dda9e" translate="yes" xml:space="preserve">
          <source>to safeguard against your test script blowing up.</source>
          <target state="translated">테스트 스크립트가 터지는 것을 방지합니다.</target>
        </trans-unit>
        <trans-unit id="3b5c2aba92e878120336a2bb3d81910b6a90f820" translate="yes" xml:space="preserve">
          <source>to see how Perl does this:</source>
          <target state="translated">Perl이 어떻게 하는지를 확인하려면 :</target>
        </trans-unit>
        <trans-unit id="9ec0179b4e855771865ee056ca147a37ba135ec0" translate="yes" xml:space="preserve">
          <source>to see the call stack at the time of death. By supplying the &lt;b&gt;-warntrace&lt;/b&gt; (or just &lt;b&gt;-w&lt;/b&gt;) flag, any warnings emitted will also come with a stack trace.</source>
          <target state="translated">사망시 호출 스택을 볼 수 있습니다. &lt;b&gt;-warntrace&lt;/b&gt; (또는 just &lt;b&gt;-w&lt;/b&gt; ) 플래그 를 제공하면 &lt;b&gt;생성&lt;/b&gt; 된 모든 경고에도 스택 추적이 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="1abae5e0b93215dca78b4df050c4b2bb23c4c165" translate="yes" xml:space="preserve">
          <source>to see whether it leads to the list of available locales (search for the</source>
          <target state="translated">사용 가능한 로케일 목록으로 연결되는지 확인하십시오 (</target>
        </trans-unit>
        <trans-unit id="48e0fbc5536b8ff51cbb0d8c98b627bbd206f258" translate="yes" xml:space="preserve">
          <source>to send a signal to it (that means, to be brief, that the process is owned by the same user, or we are the super-user). This is useful to check that a child process is still alive (even if only as a zombie) and hasn't changed its UID. See &lt;a href=&quot;../perlport&quot;&gt;perlport&lt;/a&gt; for notes on the portability of this construct.</source>
          <target state="translated">신호를 보내려면 (즉, 프로세스가 동일한 사용자가 소유하고 있거나 우리가 슈퍼 사용자라는 것을 의미합니다.) 이것은 자식 프로세스가 아직 살아 있고 (좀비로도) UID를 변경하지 않았는지 확인하는 데 유용합니다. 이 구문의 이식성에 대한 참고 사항 은 &lt;a href=&quot;../perlport&quot;&gt;perlport&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="db1b23209691204230924770cc7c68e2837b9854" translate="yes" xml:space="preserve">
          <source>to send a signal to it (that means, to be brief, that the process is owned by the same user, or we are the super-user). This is useful to check that a child process is still alive (even if only as a zombie) and hasn't changed its UID. See &lt;a href=&quot;perlport&quot;&gt;perlport&lt;/a&gt; for notes on the portability of this construct.</source>
          <target state="translated">신호를 보내려면 (즉, 프로세스가 동일한 사용자가 소유하고 있거나 우리가 슈퍼 사용자라는 것을 의미합니다.) 이것은 자식 프로세스가 아직 살아 있고 (좀비로도) UID를 변경하지 않았는지 확인하는 데 유용합니다. 이 구문의 이식성에 대한 참고 사항 은 &lt;a href=&quot;perlport&quot;&gt;perlport&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="66c3d5712202be593865ffc09e6eae08dff8cb30" translate="yes" xml:space="preserve">
          <source>to silence the warnings, otherwise you should correct the package name, or ensure that the package is loaded prior to the method call.</source>
          <target state="translated">경고를 무음으로 설정하려면 패키지 이름을 수정하거나 메서드 호출 전에 패키지가로드되었는지 확인해야합니다. ㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ</target>
        </trans-unit>
        <trans-unit id="8d97c2933b59d9259995298ef3fafce6e5797cd5" translate="yes" xml:space="preserve">
          <source>to spaces in</source>
          <target state="translated">공백으로</target>
        </trans-unit>
        <trans-unit id="47795bd83bb68151673944f901d2c50b79dcbeb8" translate="yes" xml:space="preserve">
          <source>to specify any code point portably. &lt;code&gt;LATIN1_TO_NATIVE(0xDF)&lt;/code&gt; is going to be the code point that means LATIN SMALL LETTER SHARP S on whatever platform you are running on (on ASCII platforms it compiles without adding any extra code, so there is zero performance hit on those). The acceptable inputs to &lt;code&gt;LATIN1_TO_NATIVE&lt;/code&gt; are from &lt;code&gt;0x00&lt;/code&gt; through &lt;code&gt;0xFF&lt;/code&gt; . If your input isn't guaranteed to be in that range, use &lt;code&gt;UNICODE_TO_NATIVE&lt;/code&gt; instead. &lt;code&gt;NATIVE_TO_LATIN1&lt;/code&gt; and &lt;code&gt;NATIVE_TO_UNICODE&lt;/code&gt; translate the opposite direction.</source>
          <target state="translated">코드 포인트를 이식 가능하게 지정합니다. &lt;code&gt;LATIN1_TO_NATIVE(0xDF)&lt;/code&gt; 는 실행중인 플랫폼에 관계없이 라틴 문자가 선명함 을 의미하는 코드 포인트가됩니다 (ASCII 플랫폼에서는 추가 코드를 추가하지 않고 컴파일하므로 성능이 저하되지 않습니다). &lt;code&gt;LATIN1_TO_NATIVE&lt;/code&gt; 에 허용되는 입력 은 &lt;code&gt;0x00&lt;/code&gt; ~ &lt;code&gt;0xFF&lt;/code&gt; 입니다. 입력이 그 범위 내에 있다고 보장되지 않으면 대신 &lt;code&gt;UNICODE_TO_NATIVE&lt;/code&gt; 를 사용하십시오. &lt;code&gt;NATIVE_TO_LATIN1&lt;/code&gt; 및 &lt;code&gt;NATIVE_TO_UNICODE&lt;/code&gt; 는 반대 방향으로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="7b1c0d6fc0c762a8b97f271bd411c3ac585bcb80" translate="yes" xml:space="preserve">
          <source>to specify any code point portably. &lt;code&gt;LATIN1_TO_NATIVE(0xDF)&lt;/code&gt; is going to be the code point that means LATIN SMALL LETTER SHARP S on whatever platform you are running on (on ASCII platforms it compiles without adding any extra code, so there is zero performance hit on those). The acceptable inputs to &lt;code&gt;LATIN1_TO_NATIVE&lt;/code&gt; are from &lt;code&gt;0x00&lt;/code&gt; through &lt;code&gt;0xFF&lt;/code&gt;. If your input isn't guaranteed to be in that range, use &lt;code&gt;UNICODE_TO_NATIVE&lt;/code&gt; instead. &lt;code&gt;NATIVE_TO_LATIN1&lt;/code&gt; and &lt;code&gt;NATIVE_TO_UNICODE&lt;/code&gt; translate the opposite direction.</source>
          <target state="translated">이식 가능하게 코드 포인트를 지정합니다. &lt;code&gt;LATIN1_TO_NATIVE(0xDF)&lt;/code&gt; 는 실행중인 플랫폼에 상관없이 LATIN SMALL LETTER SHARP S를 의미하는 코드 포인트가 될 것입니다 (ASCII 플랫폼에서는 추가 코드를 추가하지 않고 컴파일하므로 성능 저하가 없음). &lt;code&gt;LATIN1_TO_NATIVE&lt;/code&gt; 에 허용되는 입력 은 &lt;code&gt;0x00&lt;/code&gt; 에서 &lt;code&gt;0xFF&lt;/code&gt; 까지 입니다. 입력이 해당 범위에 속하지 않을 경우 대신 &lt;code&gt;UNICODE_TO_NATIVE&lt;/code&gt; 를 사용하세요. &lt;code&gt;NATIVE_TO_LATIN1&lt;/code&gt; 및 &lt;code&gt;NATIVE_TO_UNICODE&lt;/code&gt; 는 반대 방향으로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="1197feefbd9420667cdd5a4dd6a4aa3594104c2e" translate="yes" xml:space="preserve">
          <source>to start from the horizontal plane, some texts use</source>
          <target state="translated">수평면에서 시작하기 위해 일부 텍스트는</target>
        </trans-unit>
        <trans-unit id="5f251a862463ec2d75b253af31e6138a544bfb10" translate="yes" xml:space="preserve">
          <source>to suit the layout of current version of Perl first. Do not forget to pack the necessary external DLLs accordingly. Include the description of the bugs and test suite failures you could not fix. Include the small-stack versions of Perl executables from Perl build directory.</source>
          <target state="translated">현재 Perl의 현재 버전의 레이아웃에 적합합니다. 필요한 외부 DLL을 적절히 포장하는 것을 잊지 마십시오. 수정할 수없는 버그 및 테스트 스위트 실패에 대한 설명을 포함 시키십시오. Perl 빌드 디렉토리에서 작은 스택 버전의 Perl 실행 파일을 포함하십시오.</target>
        </trans-unit>
        <trans-unit id="d1c024f5a78b5c864f433d9aa8be1a594410912a" translate="yes" xml:space="preserve">
          <source>to text in verbatim paragraphs.</source>
          <target state="translated">구두 단락의 텍스트로.</target>
        </trans-unit>
        <trans-unit id="5c2898b75f58638f936243a608bc25011a6aa195" translate="yes" xml:space="preserve">
          <source>to the</source>
          <target state="translated">~로</target>
        </trans-unit>
        <trans-unit id="82ccf1b1bbc5c3b63172011418c70aeccf1f6b30" translate="yes" xml:space="preserve">
          <source>to the &quot;new&quot;</source>
          <target state="translated">&quot;새로운&quot;</target>
        </trans-unit>
        <trans-unit id="76d71a404d5345ef6d530d878a49399365e670e1" translate="yes" xml:space="preserve">
          <source>to the &lt;code&gt;Encode&lt;/code&gt; object that is used to convert the source code to Unicode. Thanks to this variable your Perl script does not have to be written in UTF-8. Default is &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">받는 &lt;code&gt;Encode&lt;/code&gt; 유니 코드로 소스 코드를 변환하는 데 사용되는 객체입니다. 이 변수 덕분에 Perl 스크립트를 UTF-8로 작성할 필요가 없습니다. 기본값은 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="8ac67a56e4a68a2c8064bbb01ae5d7ad965b09af" translate="yes" xml:space="preserve">
          <source>to the &lt;code&gt;Encode&lt;/code&gt; object that was used to convert the source code to Unicode.</source>
          <target state="translated">받는 &lt;code&gt;Encode&lt;/code&gt; 유니 코드로 소스 코드를 변환하는 데 사용 된 객체입니다.</target>
        </trans-unit>
        <trans-unit id="ef269923d5b7dae5520c4b226e661ab154e306ec" translate="yes" xml:space="preserve">
          <source>to the array. For example:</source>
          <target state="translated">배열에. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="216f5d19c604dee2234673a86b502cfd302349ee" translate="yes" xml:space="preserve">
          <source>to the corresponding character sequence. That is, it replaces each sequence of characters in the string whose ords represent a valid UTF-X byte sequence, with the corresponding single character. The UTF-8 flag is turned on only if the source string contains multiple-byte</source>
          <target state="translated">해당 문자 순서로. 즉, ords가 유효한 UTF-X 바이트 시퀀스를 나타내는 문자열의 각 문자 시퀀스를 해당 단일 문자로 바꿉니다. UTF-8 플래그는 소스 문자열에 멀티 바이트가 포함 된 경우에만 켜집니다</target>
        </trans-unit>
        <trans-unit id="df3d9a1670821c7cf27d25bf5204f4ccff8c1fdf" translate="yes" xml:space="preserve">
          <source>to the distribution. That file may contain typemaps that either map types that are specific to your code or that override the core typemap file's mappings for common C types.</source>
          <target state="translated">분포에. 이 파일에는 코드에 고유 한 맵 유형 또는 공통 C 유형에 대한 코어 유형 맵 파일의 맵핑을 대체하는 유형 맵이 포함될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5ec04bffb5a640e2121f16fb9848428ade56baa9" translate="yes" xml:space="preserve">
          <source>to the equivalent octet sequence in the native encoding (Latin-1 or EBCDIC). The logical character sequence itself is unchanged. If</source>
          <target state="translated">고유 인코딩 (라틴 -1 또는 EBCDIC)의 등가 옥텟 서열. 논리 문자 순서 자체는 변경되지 않습니다. 만약</target>
        </trans-unit>
        <trans-unit id="82e5d8f0d33f3fc1c4fe24b9dc376060a9b0b882" translate="yes" xml:space="preserve">
          <source>to the file</source>
          <target state="translated">파일로</target>
        </trans-unit>
        <trans-unit id="90227e286453c7d696a369902dc40165bb310c1b" translate="yes" xml:space="preserve">
          <source>to the internal suspects list.</source>
          <target state="translated">내부 용의자 목록에</target>
        </trans-unit>
        <trans-unit id="bd12956f16da3a5cd11f46459e6fbfa6aaa9eb4f" translate="yes" xml:space="preserve">
          <source>to the list of directories to search.</source>
          <target state="translated">검색 할 디렉토리 목록에 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="8b76166173a60a9172a00fdc4b02f8ec0fddaa92" translate="yes" xml:space="preserve">
          <source>to the package &lt;code&gt;symbolic&lt;/code&gt; . After this change one can do</source>
          <target state="translated">&lt;code&gt;symbolic&lt;/code&gt; 패키지에 . 이 변경 후에는 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="c55d687e85a880714b4763b5b19bc9f8898eaace" translate="yes" xml:space="preserve">
          <source>to the package &lt;code&gt;symbolic&lt;/code&gt;. After this change one can do</source>
          <target state="translated">패키지 &lt;code&gt;symbolic&lt;/code&gt; . 이 변경 후에는 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="127369588e3806f5dfab2b9107e9f8ad65279c04" translate="yes" xml:space="preserve">
          <source>to the root object is returned. In case an I/O error occurs while reading, &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; is returned instead. Other serious errors are propagated via &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">루트 개체에 반환됩니다. 읽는 동안 I / O 오류가 발생하면 대신 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 가 반환됩니다. 다른 심각한 오류는 &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; 를 통해 전파됩니다 .</target>
        </trans-unit>
        <trans-unit id="51ccbf902c395d70a02815e33154ccd2bc608f3d" translate="yes" xml:space="preserve">
          <source>to the root object is returned. In case an I/O error occurs while reading, &lt;code&gt;undef&lt;/code&gt; is returned instead. Other serious errors are propagated via &lt;code&gt;die&lt;/code&gt;.</source>
          <target state="translated">루트 개체에 반환됩니다. 읽는 동안 I / O 오류가 발생하면 대신 &lt;code&gt;undef&lt;/code&gt; 가 반환됩니다. 다른 심각한 오류는 &lt;code&gt;die&lt;/code&gt; 를 통해 전파됩니다 .</target>
        </trans-unit>
        <trans-unit id="f6e9d0a538125eee9f8d6f4cbaa30a1b1fff30fb" translate="yes" xml:space="preserve">
          <source>to the rounded value.</source>
          <target state="translated">반올림 된 값으로.</target>
        </trans-unit>
        <trans-unit id="6478ae00c5333b05a73a0c8922c4f89bb2887a54" translate="yes" xml:space="preserve">
          <source>to the smoke config, or by adding another patch that inserts</source>
          <target state="translated">연기 구성에 추가하거나</target>
        </trans-unit>
        <trans-unit id="8e225bf1778d80454bbe7a90c5d48ef2598d7c96" translate="yes" xml:space="preserve">
          <source>to this sample program ensures that the output is completely UTF-8, and removes the program's warning.</source>
          <target state="translated">이 샘플 프로그램은 출력이 완전히 UTF-8인지 확인하고 프로그램의 경고를 제거합니다.</target>
        </trans-unit>
        <trans-unit id="c2e0e9641a1cfa05ec7cd1760997deb3abf87d90" translate="yes" xml:space="preserve">
          <source>to translate POD (Plain Old Documentation - see &lt;a href=&quot;perlpod&quot;&gt;perlpod&lt;/a&gt; for an explanation) into a manpage, and then run</source>
          <target state="translated">POD 번역 (일반 문서) &lt;a href=&quot;perlpod&quot;&gt;-perlpod&lt;/a&gt; 참조 설명 )를 맨 페이지 한 다음 실행</target>
        </trans-unit>
        <trans-unit id="394511bb26b8cb98ffae20ceec14f71843c11b8f" translate="yes" xml:space="preserve">
          <source>to translate to the number of seconds which need to be added to UTC to get local time.</source>
          <target state="translated">현지 시간을 얻기 위해 UTC에 추가 해야하는 초 수로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="8b5522aa687ede8069f95ce7a57a06f86362ef8d" translate="yes" xml:space="preserve">
          <source>to undo the feature-enabling side effects of &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; VERSION&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; VERSION&lt;/code&gt; &lt;a href=&quot;functions/use&quot;&gt;사용&lt;/a&gt; 의 기능 사용 부작용을 취소합니다 .</target>
        </trans-unit>
        <trans-unit id="4c8814f0c0136ae299e1d978d9223309dc3f3753" translate="yes" xml:space="preserve">
          <source>to undo the feature-enabling side effects of &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; VERSION&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; VERSION&lt;/code&gt; &lt;a href=&quot;use&quot;&gt;사용&lt;/a&gt; 의 기능 사용 부작용을 취소합니다 .</target>
        </trans-unit>
        <trans-unit id="0db2813a9adcc53f8f0d5818db33d272ced931f3" translate="yes" xml:space="preserve">
          <source>to undo the feature-enabling side effects of &lt;code&gt;use VERSION&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;use VERSION&lt;/code&gt; 을 사용 하여 기능을 활성화하는 부작용을 취소합니다 .</target>
        </trans-unit>
        <trans-unit id="8ff66ab810bf6e49f296603698cb9fb951159b36" translate="yes" xml:space="preserve">
          <source>to update Encode::ConfigLocal, a module that controls local settings. After that, &quot;use Encode;&quot; is enough to load your encodings on demand.</source>
          <target state="translated">로컬 설정을 제어하는 ​​모듈 인 Encode :: ConfigLocal을 업데이트합니다. 그 후 &quot;Use Encode;&quot; 필요에 따라 인코딩을로드하기에 충분합니다.</target>
        </trans-unit>
        <trans-unit id="508860c3910e4168b4709c6d24074c802ac6c067" translate="yes" xml:space="preserve">
          <source>to use Perl debugger (see &lt;a href=&quot;perldebug&quot;&gt;perldebug&lt;/a&gt;) to debug your PM application (but beware of the message loop lockups - this will not work if you have a message queue to serve, unless you hook the serving into the getc() function of the debugger).</source>
          <target state="translated">PM 애플리케이션을 디버깅 하기 위해 Perl 디버거 ( &lt;a href=&quot;perldebug&quot;&gt;perldebug&lt;/a&gt; 참조 )를 사용하는 것 (하지만 메시지 루프 잠금을주의하십시오-디버거의 getc () 함수에 서빙을 연결하지 않으면 메시지 큐가있는 경우 작동하지 않습니다) .</target>
        </trans-unit>
        <trans-unit id="6c9ee0e1ac650adceaf23fd25a2609a5e096e7ba" translate="yes" xml:space="preserve">
          <source>to use literal backslashes within &lt;code&gt;\Q...\E&lt;/code&gt; , consult &lt;a href=&quot;perlop#Gory-details-of-parsing-quoted-constructs&quot;&gt;Gory details of parsing quoted constructs in perlop&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;\Q...\E&lt;/code&gt; 내에서 리터럴 백 슬래시를 사용하려면 &lt;a href=&quot;perlop#Gory-details-of-parsing-quoted-constructs&quot;&gt;인용 된 구문을 구문 분석하는 perry의 Gory 세부 사항을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="3ee089a754c74e94eb2a06557ebb705db5162cd3" translate="yes" xml:space="preserve">
          <source>to use literal backslashes within &lt;code&gt;\Q...\E&lt;/code&gt;, consult &lt;a href=&quot;perlop#Gory-details-of-parsing-quoted-constructs&quot;&gt;&quot;Gory details of parsing quoted constructs&quot; in perlop&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;\Q...\E&lt;/code&gt; 내에서 리터럴 백 슬래시를 사용하려면 &lt;a href=&quot;perlop#Gory-details-of-parsing-quoted-constructs&quot;&gt;perlop의 &quot;인용 된 구문 구문 분석에 대한 Gory 세부 사항&quot;을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="3f4243d26108dc891c09891b9e0d53323cc3f1aa" translate="yes" xml:space="preserve">
          <source>to use long longs for the 64-bit integer type, in case you don't have a 64-bit CPU.</source>
          <target state="translated">64 비트 CPU가없는 경우 64 비트 정수 유형에 대해 long long을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="71eaa770d8f526077b4f3192342bbb1dc3e73f22" translate="yes" xml:space="preserve">
          <source>to use the following @INC:</source>
          <target state="translated">다음 @INC를 사용하려면</target>
        </trans-unit>
        <trans-unit id="c41a5a2ce143dfaf438913c7854dc4c3a8171d12" translate="yes" xml:space="preserve">
          <source>to verify how your CLI passes the arguments to the program.</source>
          <target state="translated">CLI가 인수를 프로그램에 전달하는 방법을 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="c1b9231e94fd8b3c3cab617ce687784026021ccb" translate="yes" xml:space="preserve">
          <source>to work as expected.</source>
          <target state="translated">예상대로 작동합니다.</target>
        </trans-unit>
        <trans-unit id="656506a4ec42318e7739d114a54796115a5f5c23" translate="yes" xml:space="preserve">
          <source>to your &lt;code&gt;PATH&lt;/code&gt;, where &lt;code&gt;$ANDROID_NDK&lt;/code&gt; is the location where you unpacked the NDK, and &lt;code&gt;$TARGETARCH&lt;/code&gt; is your target's architecture.</source>
          <target state="translated">당신에 &lt;code&gt;PATH&lt;/code&gt; , &lt;code&gt;$ANDROID_NDK&lt;/code&gt; 당신이 NDK를 압축 해제하고, 위치 &lt;code&gt;$TARGETARCH&lt;/code&gt; 대상의 아키텍처입니다.</target>
        </trans-unit>
        <trans-unit id="d7e8b5b9930482d0974a966707cd0dee16c6857f" translate="yes" xml:space="preserve">
          <source>to your &lt;code&gt;PATH&lt;/code&gt;, which should give you access to adb. You'll now have to find your device's name using &lt;code&gt;adb devices&lt;/code&gt;, and later pass that to Configure through &lt;code&gt;-Dtargethost=$DEVICE&lt;/code&gt;.</source>
          <target state="translated">adb에 대한 액세스 권한을 제공해야하는 &lt;code&gt;PATH&lt;/code&gt; 에 추가합니다 . 이제 &lt;code&gt;adb devices&lt;/code&gt; 를 사용하여 장치 이름을 찾은 다음 나중에 &lt;code&gt;-Dtargethost=$DEVICE&lt;/code&gt; 통해 구성에 전달해야합니다 .</target>
        </trans-unit>
        <trans-unit id="86f28e5ec97934fa33153df2fc5e2b5b65583051" translate="yes" xml:space="preserve">
          <source>to.</source>
          <target state="translated">to.</target>
        </trans-unit>
        <trans-unit id="ba1cfdcd865f3b87bcc9595dd395087b084ac080" translate="yes" xml:space="preserve">
          <source>to:</source>
          <target state="translated">to:</target>
        </trans-unit>
        <trans-unit id="3886f38e697d677aa587bdd290cc3805566e8e79" translate="yes" xml:space="preserve">
          <source>toFOLD</source>
          <target state="translated">toFOLD</target>
        </trans-unit>
        <trans-unit id="dd7d2b83547e5f5fdabc7e9418f3038b97e9cb5b" translate="yes" xml:space="preserve">
          <source>toFOLD_utf8</source>
          <target state="translated">toFOLD_utf8</target>
        </trans-unit>
        <trans-unit id="f6e02273ceca62c3e682f5afa600659aed17ae3b" translate="yes" xml:space="preserve">
          <source>toFOLD_utf8_safe</source>
          <target state="translated">toFOLD_utf8_safe</target>
        </trans-unit>
        <trans-unit id="f83101a4dadcfe55aa744b086b87ca38e3889762" translate="yes" xml:space="preserve">
          <source>toFOLD_uvchr</source>
          <target state="translated">toFOLD_uvchr</target>
        </trans-unit>
        <trans-unit id="54b797de1df66dade96b240e8f59bf48c0320a74" translate="yes" xml:space="preserve">
          <source>toLOWER</source>
          <target state="translated">toLOWER</target>
        </trans-unit>
        <trans-unit id="6dfe7b68e04e0d7fc801aea079b49e3ffef25e70" translate="yes" xml:space="preserve">
          <source>toLOWER_L1</source>
          <target state="translated">toLOWER_L1</target>
        </trans-unit>
        <trans-unit id="b9d415eac5981e17df479c5aa26385deb10a657f" translate="yes" xml:space="preserve">
          <source>toLOWER_LC</source>
          <target state="translated">toLOWER_LC</target>
        </trans-unit>
        <trans-unit id="f5170ef52d05991714ca920fc52baa44877f2601" translate="yes" xml:space="preserve">
          <source>toLOWER_utf8</source>
          <target state="translated">toLOWER_utf8</target>
        </trans-unit>
        <trans-unit id="0eb9b47fb49ab4cf0f192825ba378e11bf87643b" translate="yes" xml:space="preserve">
          <source>toLOWER_utf8_safe</source>
          <target state="translated">toLOWER_utf8_safe</target>
        </trans-unit>
        <trans-unit id="26f701810edb168d35bd0f072e4c3081636f2970" translate="yes" xml:space="preserve">
          <source>toLOWER_uvchr</source>
          <target state="translated">toLOWER_uvchr</target>
        </trans-unit>
        <trans-unit id="e6fa6ade54a29cd366d02eaa2c156ca2e56220da" translate="yes" xml:space="preserve">
          <source>toTITLE</source>
          <target state="translated">toTITLE</target>
        </trans-unit>
        <trans-unit id="aba1a44f08b1a4e8d84b7cabe7cfd1ca1db914aa" translate="yes" xml:space="preserve">
          <source>toTITLE_utf8</source>
          <target state="translated">toTITLE_utf8</target>
        </trans-unit>
        <trans-unit id="0c103b8b4d23e69ab1ba828d84651aebf4394dd2" translate="yes" xml:space="preserve">
          <source>toTITLE_utf8_safe</source>
          <target state="translated">toTITLE_utf8_safe</target>
        </trans-unit>
        <trans-unit id="6d3bedff0bbe8d2e067c5faf169df2220dc01b4c" translate="yes" xml:space="preserve">
          <source>toTITLE_uvchr</source>
          <target state="translated">toTITLE_uvchr</target>
        </trans-unit>
        <trans-unit id="696bad035ca10a0d8da15c5d204537da4095ef06" translate="yes" xml:space="preserve">
          <source>toUPPER</source>
          <target state="translated">toUPPER</target>
        </trans-unit>
        <trans-unit id="e9899131f66740c55d55a2b4b92ec0b6e1341bf9" translate="yes" xml:space="preserve">
          <source>toUPPER_utf8</source>
          <target state="translated">toUPPER_utf8</target>
        </trans-unit>
        <trans-unit id="63a6f3f251e5d46183ae3249a191a1d1e61a02dd" translate="yes" xml:space="preserve">
          <source>toUPPER_utf8_safe</source>
          <target state="translated">toUPPER_utf8_safe</target>
        </trans-unit>
        <trans-unit id="84019b433cd4f0b55ccd2ab28afc113397737584" translate="yes" xml:space="preserve">
          <source>toUPPER_uvchr</source>
          <target state="translated">toUPPER_uvchr</target>
        </trans-unit>
        <trans-unit id="2dc265abc9d6556b5b35a2abad75e8bd586c1aaa" translate="yes" xml:space="preserve">
          <source>to_base()</source>
          <target state="translated">to_base()</target>
        </trans-unit>
        <trans-unit id="03ad9f757113a87d061a06ff11e03896c4b7aa14" translate="yes" xml:space="preserve">
          <source>to_bin()</source>
          <target state="translated">to_bin()</target>
        </trans-unit>
        <trans-unit id="3488b6914f66b12b544a26597e6b80dca3419fc1" translate="yes" xml:space="preserve">
          <source>to_bytes()</source>
          <target state="translated">to_bytes()</target>
        </trans-unit>
        <trans-unit id="fdec31a41e9e669a08d8f898082198ea5ee4b5af" translate="yes" xml:space="preserve">
          <source>to_encoding</source>
          <target state="translated">to_encoding</target>
        </trans-unit>
        <trans-unit id="706da2c06309e8bcc7b4abbf5df7f8f3a81b257d" translate="yes" xml:space="preserve">
          <source>to_hex()</source>
          <target state="translated">to_hex()</target>
        </trans-unit>
        <trans-unit id="6ae99be19af587f2c0ea6b8054c0c40eb77753a0" translate="yes" xml:space="preserve">
          <source>to_ieee754()</source>
          <target state="translated">to_ieee754()</target>
        </trans-unit>
        <trans-unit id="d534fe3e3678a5f848a46220d2c25e3bc0f7948c" translate="yes" xml:space="preserve">
          <source>to_oct()</source>
          <target state="translated">to_oct()</target>
        </trans-unit>
        <trans-unit id="37d7f573c70c698168c9a7674a4c08f6980d6278" translate="yes" xml:space="preserve">
          <source>to_uni_fold</source>
          <target state="translated">to_uni_fold</target>
        </trans-unit>
        <trans-unit id="42ac3323f020e71efa6737159f95465a63c38b33" translate="yes" xml:space="preserve">
          <source>to_uni_lower</source>
          <target state="translated">to_uni_lower</target>
        </trans-unit>
        <trans-unit id="3544e08776822456b1b3b4ea8b99c4679f526905" translate="yes" xml:space="preserve">
          <source>to_uni_title</source>
          <target state="translated">to_uni_title</target>
        </trans-unit>
        <trans-unit id="7f84e4e48c13ca88413e28fd749ba6159dcbc4da" translate="yes" xml:space="preserve">
          <source>to_uni_upper</source>
          <target state="translated">to_uni_upper</target>
        </trans-unit>
        <trans-unit id="05f20a71783db1a6f0c4e75ebb1914154e901af2" translate="yes" xml:space="preserve">
          <source>todo</source>
          <target state="translated">todo</target>
        </trans-unit>
        <trans-unit id="ea41a8c9a20f33e3b6029fd7a0cfc530555e108b" translate="yes" xml:space="preserve">
          <source>todo $reason =&amp;gt; sub { ... }</source>
          <target state="translated">할일 $ reason =&amp;gt; sub {...}</target>
        </trans-unit>
        <trans-unit id="cea220b11a2a4067478311e4d993aecab5a00fcc" translate="yes" xml:space="preserve">
          <source>todo_failed</source>
          <target state="translated">todo_failed</target>
        </trans-unit>
        <trans-unit id="cfd3d4badd0ccd550d36d3fe188fa041e7d46b76" translate="yes" xml:space="preserve">
          <source>todo_list</source>
          <target state="translated">todo_list</target>
        </trans-unit>
        <trans-unit id="8f1a2eafc3eca1cd784354c4089d7b2830b888c3" translate="yes" xml:space="preserve">
          <source>todo_passed</source>
          <target state="translated">todo_passed</target>
        </trans-unit>
        <trans-unit id="9461b677437869b4caa6ae020e205909485b9fed" translate="yes" xml:space="preserve">
          <source>toke.c</source>
          <target state="translated">toke.c</target>
        </trans-unit>
        <trans-unit id="ee977806d7286510da8b9a7492ba58e2484c0ecc" translate="yes" xml:space="preserve">
          <source>token</source>
          <target state="translated">token</target>
        </trans-unit>
        <trans-unit id="3b1ebaa6a9e7c2d892d7a35c0681619b6af90370" translate="yes" xml:space="preserve">
          <source>token are split out into separate files. Some routines may be placed prior to this marker to force their immediate loading and parsing.</source>
          <target state="translated">토큰은 별도의 파일로 분할됩니다. 이 마커 앞에 일부 루틴을 배치하여 즉시로드 및 구문 분석을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dfef88c92ae8353715029ce8b7ef3e86ca49d70b" translate="yes" xml:space="preserve">
          <source>token_types</source>
          <target state="translated">token_types</target>
        </trans-unit>
        <trans-unit id="eb4cee8f934e5d595a2c202695340507029ec772" translate="yes" xml:space="preserve">
          <source>tokener</source>
          <target state="translated">tokener</target>
        </trans-unit>
        <trans-unit id="70a62ec5d8473e2687167f889dfe377270114e99" translate="yes" xml:space="preserve">
          <source>tokenize</source>
          <target state="translated">tokenize</target>
        </trans-unit>
        <trans-unit id="c25571fea31e3c99195e8d5c414e30c1f7cb3ff2" translate="yes" xml:space="preserve">
          <source>tokenizing</source>
          <target state="translated">tokenizing</target>
        </trans-unit>
        <trans-unit id="681ae2540f4704c6471585ae03c5ad34d7587a65" translate="yes" xml:space="preserve">
          <source>tokuhirom &amp;lt;tokuhirom@gmail.com&amp;gt;</source>
          <target state="translated">tokuhirom &amp;lt;tokuhirom@gmail.com&amp;gt;</target>
        </trans-unit>
        <trans-unit id="ac1c3db3f21e326855ec671f236713cdbe520c2c" translate="yes" xml:space="preserve">
          <source>tolerate arbitrarily large amounts of text in the &quot;=item</source>
          <target state="translated">&quot;= 항목에 임의로 많은 양의 텍스트를 허용</target>
        </trans-unit>
        <trans-unit id="d9ae998ab9e8ebfc629710b723541fc505ed244c" translate="yes" xml:space="preserve">
          <source>tom (at) compton.nu</source>
          <target state="translated">톰 (at) compton.nu</target>
        </trans-unit>
        <trans-unit id="903d7da65d624842b5db58b63ef8eaae82b048be" translate="yes" xml:space="preserve">
          <source>tom@compton.nu</source>
          <target state="translated">tom@compton.nu</target>
        </trans-unit>
        <trans-unit id="8ab5f520c5bc598f6a23200477705ec0f56ef10f" translate="yes" xml:space="preserve">
          <source>tommylutz@gmail.com</source>
          <target state="translated">tommylutz@gmail.com</target>
        </trans-unit>
        <trans-unit id="164a5c24f5df5918f285228443ab87209785293f" translate="yes" xml:space="preserve">
          <source>too</source>
          <target state="translated">too</target>
        </trans-unit>
        <trans-unit id="b47f0da3aa6e0a239f5e94e0877b31f25e13bf8a" translate="yes" xml:space="preserve">
          <source>too.</source>
          <target state="translated">too.</target>
        </trans-unit>
        <trans-unit id="426267451d2aab91845a1f7b22772772450c1009" translate="yes" xml:space="preserve">
          <source>too. Add this line BEFORE any section definition:</source>
          <target state="translated">너무. 섹션 정의 전에이 행을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="90edf77c811db872526b3b484bef9279ab6440fb" translate="yes" xml:space="preserve">
          <source>tool can then display the collected data in various ways. Usually</source>
          <target state="translated">도구는 수집 된 데이터를 다양한 방식으로 표시 할 수 있습니다. 보통</target>
        </trans-unit>
        <trans-unit id="ccb51450d25446e81f4942d86de10a8c406492b5" translate="yes" xml:space="preserve">
          <source>tool included with Perl 5. Bug reports will be included in the Perl 5 ticket system at &lt;a href=&quot;http://rt.perl.org&quot;&gt;http://rt.perl.org&lt;/a&gt;.</source>
          <target state="translated">버그 보고서는 Perl 5 티켓 시스템 ( &lt;a href=&quot;http://rt.perl.org&quot;&gt;http://rt.perl.org)에 포함&lt;/a&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="07819fa05095cb2be15d10b89b2a7033c3b16f21" translate="yes" xml:space="preserve">
          <source>tool included with Perl 5. Bug reports will be included in the Perl 5 ticket system at &lt;a href=&quot;https://rt.perl.org&quot;&gt;https://rt.perl.org&lt;/a&gt;.</source>
          <target state="translated">Perl 5에 포함 된 도구입니다. 버그 보고서는 &lt;a href=&quot;https://rt.perl.org&quot;&gt;https://rt.perl.org&lt;/a&gt; 의 Perl 5 티켓 시스템에 포함됩니다 .</target>
        </trans-unit>
        <trans-unit id="8f39224c5c445b7f4c4eea9f381baa177eb7cb91" translate="yes" xml:space="preserve">
          <source>tool installed.</source>
          <target state="translated">도구가 설치되었습니다.</target>
        </trans-unit>
        <trans-unit id="2adced328d5d2ff8ee0e676e609a7ca3cf7538c7" translate="yes" xml:space="preserve">
          <source>tool is included in the &lt;code&gt;Storable&lt;/code&gt; distribution.</source>
          <target state="translated">도구는 &lt;code&gt;Storable&lt;/code&gt; 배포판에 포함되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="88aa984e8c2d55237b91314cbcf92140805cfef9" translate="yes" xml:space="preserve">
          <source>tool that comes with Perl tries to convert C include files to Perl code, which can be &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt;d. FIONREAD ends up defined as a function in the</source>
          <target state="translated">펄과 함께 제공 도구는 C가 할 수있는 펄 코드 파일 포함 변환하려고 할 &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; D를. FIONREAD는</target>
        </trans-unit>
        <trans-unit id="ebe27f24839435afef60aa8043822d82f37b617a" translate="yes" xml:space="preserve">
          <source>tool that comes with Perl tries to convert C include files to Perl code, which can be &lt;code&gt;require&lt;/code&gt;d. FIONREAD ends up defined as a function in the</source>
          <target state="translated">Perl과 함께 제공되는 도구는 C include 파일을 Perl 코드로 변환하려고 시도합니다 . 이는 d 가 &lt;code&gt;require&lt;/code&gt; 수 있습니다 . FIONREAD는</target>
        </trans-unit>
        <trans-unit id="f92adaa38df139e8b7202b087183871bcb1dd01c" translate="yes" xml:space="preserve">
          <source>tool. If you fix or enhance a performance issue, you may want to add a representative code sample to the file, then run</source>
          <target state="translated">수단. 성능 문제를 수정하거나 향상시키는 경우 대표 코드 샘플을 파일에 추가 한 후 다음을 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="8cd3fb1667a905290c5b0e870e6cf4f615dde4f7" translate="yes" xml:space="preserve">
          <source>tool_autosplit</source>
          <target state="translated">tool_autosplit</target>
        </trans-unit>
        <trans-unit id="353f522e35463b7e821000818d97c43f25c384e1" translate="yes" xml:space="preserve">
          <source>tool_xsubpp (o)</source>
          <target state="translated">tool_xsubpp (o)</target>
        </trans-unit>
        <trans-unit id="64249617bd5bdb892a4cfb6cbb526359c99e77fb" translate="yes" xml:space="preserve">
          <source>toolbox approach</source>
          <target state="translated">도구 상자 접근 방식</target>
        </trans-unit>
        <trans-unit id="b8623287e2d342133af98c4af1a3151d917692c2" translate="yes" xml:space="preserve">
          <source>tools_other</source>
          <target state="translated">tools_other</target>
        </trans-unit>
        <trans-unit id="52412a93868b5b1cf50b3d270c04ef47ba9f3ddf" translate="yes" xml:space="preserve">
          <source>tools_other (override)</source>
          <target state="translated">tools_other (재정의)</target>
        </trans-unit>
        <trans-unit id="6df097104885ecf49eeda77591edc71fc32a475e" translate="yes" xml:space="preserve">
          <source>top ( MSGNUM [, NUMLINES ] )</source>
          <target state="translated">맨 위 (MSGNUM [, NUMLINES])</target>
        </trans-unit>
        <trans-unit id="156806de8ef990a34b3ac6280c26b4ecca6c2b47" translate="yes" xml:space="preserve">
          <source>top_anchor</source>
          <target state="translated">top_anchor</target>
        </trans-unit>
        <trans-unit id="a4a517be2abf7b5cbbf48b28b90b2deafacb23fd" translate="yes" xml:space="preserve">
          <source>top_targets (o)</source>
          <target state="translated">top_targets (o)</target>
        </trans-unit>
        <trans-unit id="b415e16fbe4ca40f22707a97322b49cb9bc5e487" translate="yes" xml:space="preserve">
          <source>topic</source>
          <target state="translated">topic</target>
        </trans-unit>
        <trans-unit id="4f83d880aeb0e2a0498a5bc0e8ac975990e97449" translate="yes" xml:space="preserve">
          <source>tored by Gurusamy Sarathy (&amp;lt;gsar@activestate.com&amp;gt;), Tom Christiansen (&amp;lt;tchrist@perl.com&amp;gt;), Nathan Torkington (&amp;lt;gnat@frii.com&amp;gt;), Charles F. Randall (&amp;lt;cfr@pobox.com&amp;gt;), Mike Guy (&amp;lt;mjtg@cam.ac.uk&amp;gt;), Dominic Dunlop (&amp;lt;domo@computer.org&amp;gt;), Hugo van der Sanden (&amp;lt;hv@crypt.org&amp;gt;), Jarkko Hietaniemi (&amp;lt;jhi@iki.fi&amp;gt;), Chris Nandor (&amp;lt;pudge@pobox.com&amp;gt;), Jon Orwant (&amp;lt;orwant@media.mit.edu&amp;gt;, Richard Foley (&amp;lt;richard.foley@rfi.net&amp;gt;), Jesse Vincent (&amp;lt;jesse@bestpractical.com&amp;gt;), and Craig A. Berry (&amp;lt;craigberry@mac.com&amp;gt;).</source>
          <target state="translated">Gurusamy Sarathy (&amp;lt;gsar@activestate.com&amp;gt;), Tom Christiansen (&amp;lt;tchrist@perl.com&amp;gt;), Nathan Torkington (&amp;lt;gnat@frii.com&amp;gt;), Charles F. Randall (&amp;lt;cfr@pobox.com&amp;gt;) ), Mike Guy (&amp;lt;mjtg@cam.ac.uk&amp;gt;), Dominic Dunlop (&amp;lt;domo@computer.org&amp;gt;), Hugo van der Sanden (&amp;lt;hv@crypt.org&amp;gt;), Jarkko Hietaniemi (&amp;lt;jhi @ iki. fi&amp;gt;), Chris Nandor (&amp;lt;pudge@pobox.com&amp;gt;), Jon Orwant (&amp;lt;orwant@media.mit.edu&amp;gt;, Richard Foley (&amp;lt;richard.foley@rfi.net&amp;gt;)), Jesse Vincent (&amp;lt;jesse @ bestpractical .com&amp;gt; 및 Craig A. Berry (&amp;lt;craigberry@mac.com&amp;gt;).</target>
        </trans-unit>
        <trans-unit id="5a537e209151ae5fcccd6326b34b5622bcfb0578" translate="yes" xml:space="preserve">
          <source>total</source>
          <target state="translated">total</target>
        </trans-unit>
        <trans-unit id="f946bb4c412cec0161b446353e7e1a4ee67a20e7" translate="yes" xml:space="preserve">
          <source>total number of bytes</source>
          <target state="translated">총 바이트 수</target>
        </trans-unit>
        <trans-unit id="4ddb17cd3ef0d793512142788d255e17de1a217e" translate="yes" xml:space="preserve">
          <source>total_failures</source>
          <target state="translated">total_failures</target>
        </trans-unit>
        <trans-unit id="c1c8273aad4f9a7cacdfa5cac7b18b00d7494695" translate="yes" xml:space="preserve">
          <source>total_passes</source>
          <target state="translated">total_passes</target>
        </trans-unit>
        <trans-unit id="f4d1f0193879cba82d65c5752c4ba5cbb43a7188" translate="yes" xml:space="preserve">
          <source>touch</source>
          <target state="translated">touch</target>
        </trans-unit>
        <trans-unit id="e8937c0528189796d518e5700c56664fe7f52839" translate="yes" xml:space="preserve">
          <source>tpt</source>
          <target state="translated">tpt</target>
        </trans-unit>
        <trans-unit id="d9e83874d260f2f10d48d98c0b773b836096d426" translate="yes" xml:space="preserve">
          <source>tr</source>
          <target state="translated">tr</target>
        </trans-unit>
        <trans-unit id="c39522f52c3ec29023c219c19d4067a9b3eee877" translate="yes" xml:space="preserve">
          <source>tr///</source>
          <target state="translated">tr///</target>
        </trans-unit>
        <trans-unit id="2d7afbb0e384d30410fdf173188d5d4f21201da9" translate="yes" xml:space="preserve">
          <source>trace =&amp;gt; {...}</source>
          <target state="translated">추적 =&amp;gt; {...}</target>
        </trans-unit>
        <trans-unit id="536783780cbdb29a264e212e15753a5bedd082e3" translate="yes" xml:space="preserve">
          <source>trailingData</source>
          <target state="translated">trailingData</target>
        </trans-unit>
        <trans-unit id="2d3d774f797509aed854d6cdea0a59d83a6162c4" translate="yes" xml:space="preserve">
          <source>translate_substr_offsets</source>
          <target state="translated">translate_substr_offsets</target>
        </trans-unit>
        <trans-unit id="15c4593ae86e3bf2017dc51f07fb9e08cc13291e" translate="yes" xml:space="preserve">
          <source>translates a list of numbers to the corresponding characters.</source>
          <target state="translated">숫자 목록을 해당 문자로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="34d7fc1774ad1e06f48d4d6adb73b20c2ab97c2b" translate="yes" xml:space="preserve">
          <source>translates a list of numbers to their squared values.</source>
          <target state="translated">숫자 목록을 제곱 된 값으로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="b957f6243dc857b0d32b836fc652ac09fad6dc17" translate="yes" xml:space="preserve">
          <source>translates to any other string, that string is used as the name of a logical name table, which is consulted using</source>
          <target state="translated">다른 문자열로 변환합니다. 해당 문자열은 논리 이름 테이블의 이름으로 사용되며, 다음을 사용하여 참조됩니다.</target>
        </trans-unit>
        <trans-unit id="b83065734825ace6b5d6e623f5d8b917a787ab2d" translate="yes" xml:space="preserve">
          <source>translating the small parts into regexps,</source>
          <target state="translated">작은 부분을 정규 표현식으로 변환</target>
        </trans-unit>
        <trans-unit id="dd8a35d37cfae9df7f428bbc3d9a97c5906fd897" translate="yes" xml:space="preserve">
          <source>transliterate</source>
          <target state="translated">transliterate</target>
        </trans-unit>
        <trans-unit id="7982afa4ce12a15076ad30ff5a7c216bd7dd8013" translate="yes" xml:space="preserve">
          <source>transliterates into</source>
          <target state="translated">음역하다</target>
        </trans-unit>
        <trans-unit id="38bedfbdef70fc53b2e50e67a65d5f48bdccc217" translate="yes" xml:space="preserve">
          <source>trap (OP, ...), untrap (OP, ...)</source>
          <target state="translated">트랩 (OP, ...), 트랩 해제 (OP, ...)</target>
        </trans-unit>
        <trans-unit id="eb36d2f3d7dae65e6087de6be679219d1af5b693" translate="yes" xml:space="preserve">
          <source>traverse_op_tree</source>
          <target state="translated">traverse_op_tree</target>
        </trans-unit>
        <trans-unit id="ce03721ca3b28ce2f21226c122a3dc4ab883c73d" translate="yes" xml:space="preserve">
          <source>treated</source>
          <target state="translated">treated</target>
        </trans-unit>
        <trans-unit id="42dc828341bea99e4235ff61dd8d9128d8bccb29" translate="yes" xml:space="preserve">
          <source>trial.gz</source>
          <target state="translated">trial.gz</target>
        </trans-unit>
        <trans-unit id="d67deefa1e5c2dfdd8fc91aa3b6e2acaad1cff89" translate="yes" xml:space="preserve">
          <source>tries to load optional library but also dies if library is not available</source>
          <target state="translated">선택적 라이브러리를로드하려고 시도하지만 라이브러리를 사용할 수없는 경우에도 사망</target>
        </trans-unit>
        <trans-unit id="63d62d4aee9a5d4fe8539e53a9e3d05ffc210c9b" translate="yes" xml:space="preserve">
          <source>trigger</source>
          <target state="translated">trigger</target>
        </trans-unit>
        <trans-unit id="36f951df07c5aef7652954b112908952a2b30f49" translate="yes" xml:space="preserve">
          <source>trigger this warning.</source>
          <target state="translated">이 경고를 트리거합니다.</target>
        </trans-unit>
        <trans-unit id="85d5f2f5bfbf86fb0fb77296bec3b548a2f42af5" translate="yes" xml:space="preserve">
          <source>trim_whitespace()</source>
          <target state="translated">trim_whitespace()</target>
        </trans-unit>
        <trans-unit id="fe8141b320d3a24d3a892e79b8db92b4b4527f30" translate="yes" xml:space="preserve">
          <source>trimsym($name[,$maxlen[,$silent]])</source>
          <target state="translated">trimsym($name[,$maxlen[,$silent]])</target>
        </trans-unit>
        <trans-unit id="44f4ec0df5683ac806b7475ce06f2e050567bf2b" translate="yes" xml:space="preserve">
          <source>trinary</source>
          <target state="translated">trinary</target>
        </trans-unit>
        <trans-unit id="d32c5b68132ef2211100518b2ca2f7847b516c84" translate="yes" xml:space="preserve">
          <source>trnl.U</source>
          <target state="translated">trnl.U</target>
        </trans-unit>
        <trans-unit id="4d242be641b7deeef1d9477a81834d2589a3ba9b" translate="yes" xml:space="preserve">
          <source>troff</source>
          <target state="translated">troff</target>
        </trans-unit>
        <trans-unit id="cc4728d0763649871c56fd8cb6de629f5fbf5b84" translate="yes" xml:space="preserve">
          <source>troff(1)</source>
          <target state="translated">troff(1)</target>
        </trans-unit>
        <trans-unit id="5ffe533b830f08a0326348a9160afafc8ada44db" translate="yes" xml:space="preserve">
          <source>true</source>
          <target state="translated">true</target>
        </trans-unit>
        <trans-unit id="438789e48d4c0e2a17e93fb22d092028b03bb360" translate="yes" xml:space="preserve">
          <source>true if the Perl library was compiled in AOUT format.</source>
          <target state="translated">Perl 라이브러리가 AOUT 형식으로 컴파일 된 경우 true입니다.</target>
        </trans-unit>
        <trans-unit id="59e4766fb49e429a8314ef2500009926b97e90d6" translate="yes" xml:space="preserve">
          <source>true if the current executable is an AOUT EMX executable, so Perl can fork. Do not use this, use the portable check for $Config::Config{dfork}.</source>
          <target state="translated">현재 실행 파일이 AOUT EMX 실행 파일이면 펄은 포크 할 수 있습니다. 이것을 사용하지 말고 $ Config :: Config {dfork}에 대해 휴대용 검사를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="1bcf5542764919cf26fda2e66c73aa29f02ef9a2" translate="yes" xml:space="preserve">
          <source>true if this pref has a 'match' attribute and at least one valid match attribute</source>
          <target state="translated">이 pref에 'match'속성과 하나 이상의 유효한 match 속성이있는 경우 true</target>
        </trans-unit>
        <trans-unit id="3fce60a5697d8001beb7164eaf5a9b21b4de4c72" translate="yes" xml:space="preserve">
          <source>true if this pref has a 'match' attribute at all</source>
          <target state="translated">이 pref에 'match'속성이 있으면 true</target>
        </trans-unit>
        <trans-unit id="1e9cc6decc0c9571c723bb4ad00488c48abdc585" translate="yes" xml:space="preserve">
          <source>true if this pref matches the passed-in hashref, which must have a value for each of the &lt;code&gt;match_attributes&lt;/code&gt; (above)</source>
          <target state="translated">이 pref가 건네받은 hashref에 일치하는 경우는 true. 각 &lt;code&gt;match_attributes&lt;/code&gt; (상기) 의 값을 가져야한다</target>
        </trans-unit>
        <trans-unit id="cb4b42b99367dbaef3b308097c9d0a1cff17603b" translate="yes" xml:space="preserve">
          <source>true in &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval{}&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/sub&quot;&gt;sub{}&lt;/a&gt;&lt;/code&gt;, or contrary to popular belief &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do{}&lt;/a&gt;&lt;/code&gt; blocks, which do</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval{}&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/sub&quot;&gt;sub{}&lt;/a&gt;&lt;/code&gt; 에서 true 또는 대중적인 신념에 위배되는 &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do{}&lt;/a&gt;&lt;/code&gt; 블록</target>
        </trans-unit>
        <trans-unit id="1d2a4d210e124adf250fe001527a6e60a0d48719" translate="yes" xml:space="preserve">
          <source>true in &lt;code&gt;eval{}&lt;/code&gt;, &lt;code&gt;sub{}&lt;/code&gt;, or contrary to popular belief &lt;code&gt;do{}&lt;/code&gt; blocks, which do</source>
          <target state="translated">&lt;code&gt;eval{}&lt;/code&gt; , &lt;code&gt;sub{}&lt;/code&gt; 에서 참 또는 대중적인 믿음과 &lt;code&gt;do{}&lt;/code&gt; 반대로 do {} 블록은 다음을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="b4999f329cdfd3e993f8f4efa9d9ce2d2c1f0a5f" translate="yes" xml:space="preserve">
          <source>true, false</source>
          <target state="translated">허위 사실</target>
        </trans-unit>
        <trans-unit id="f137b2b3b4e3fc6aaa0e99ddd7a0b171b7598b68" translate="yes" xml:space="preserve">
          <source>true-or-false</source>
          <target state="translated">true-or-false</target>
        </trans-unit>
        <trans-unit id="00ec0d6c2044e8e1b719e93ece0d4740d510b9fa" translate="yes" xml:space="preserve">
          <source>true_or_false</source>
          <target state="translated">true_or_false</target>
        </trans-unit>
        <trans-unit id="66fe2fdee953072a309daa163ca5ed615049d0c2" translate="yes" xml:space="preserve">
          <source>trueop</source>
          <target state="translated">trueop</target>
        </trans-unit>
        <trans-unit id="90099b2e34aa9d96304e9cb4c2b9ae07073445c0" translate="yes" xml:space="preserve">
          <source>truly</source>
          <target state="translated">truly</target>
        </trans-unit>
        <trans-unit id="f283ea9bea0e80213ac091021420ffc9b3415914" translate="yes" xml:space="preserve">
          <source>truncate</source>
          <target state="translated">truncate</target>
        </trans-unit>
        <trans-unit id="a1261bf96d8d4c6b4b727d215938b97e14a121ae" translate="yes" xml:space="preserve">
          <source>truncate EXPR,LENGTH</source>
          <target state="translated">EXPR, LENGTH 자르기</target>
        </trans-unit>
        <trans-unit id="c0a4a0ea2c037915554ed29699877c89805a57bd" translate="yes" xml:space="preserve">
          <source>truncate FILEHANDLE,LENGTH</source>
          <target state="translated">FILEHANDLE, LENGTH 자르기</target>
        </trans-unit>
        <trans-unit id="fab8ceacac2e7216633cb9b84dab94ca5cf763d6" translate="yes" xml:space="preserve">
          <source>truncate not implemented</source>
          <target state="translated">자르기 구현되지 않음</target>
        </trans-unit>
        <trans-unit id="fd5fbc0b463cf9789d996b5f21e17e0748f34553" translate="yes" xml:space="preserve">
          <source>truncating</source>
          <target state="translated">truncating</target>
        </trans-unit>
        <trans-unit id="53028b90056316570dad36dc627a6b17c0330b6d" translate="yes" xml:space="preserve">
          <source>truncation invariably removes all digits following the rounding place, replacing them with zeros. Thus, 987.65 rounded to tens (P=1) becomes 980, and rounded to the fourth sigdig becomes 987.6 (A=4). 123.456 rounded to the second place after the decimal point (P=-2) becomes 123.46.</source>
          <target state="translated">잘림은 반올림 후 모든 숫자를 항상 제거하고 0으로 대체합니다. 따라서 10으로 반올림 한 987.65 (P = 1)는 980이되고, 4 번째 시그 디그로 반올림 한 것은 987.6 (A = 4)이됩니다. 소수점 (P = -2)이 123.46이 된 후 123.456은 두 번째 자리로 반올림됩니다.</target>
        </trans-unit>
        <trans-unit id="c974284acc2da6c604a9b9a760be398292dab020" translate="yes" xml:space="preserve">
          <source>trust_test_report_history</source>
          <target state="translated">trust_test_report_history</target>
        </trans-unit>
        <trans-unit id="45fa151bf9a11c0e25734df135de9edd4ff738df" translate="yes" xml:space="preserve">
          <source>truth</source>
          <target state="translated">truth</target>
        </trans-unit>
        <trans-unit id="823fca4f1093d64814a9d2afbcda71b935d03e40" translate="yes" xml:space="preserve">
          <source>try something like the following:</source>
          <target state="translated">다음과 같은 것을 시도하십시오 :</target>
        </trans-unit>
        <trans-unit id="ce6d1c45f4e5ab6843ee500a73af34957d4c92aa" translate="yes" xml:space="preserve">
          <source>try to equate new (and never-used, and unusable) ISO639-2 three-letter tags to old (and still in use) ISO639-1 two-letter equivalents -- like &quot;ara&quot; -&amp;gt; &quot;ar&quot; -- because &quot;ara&quot; has</source>
          <target state="translated">&quot;(ara&quot;-&amp;gt; &quot;ar&quot;와 같은 새로운 ISO639-2 3 글자 태그를 오래된 (그리고 여전히 사용중인) ISO639-1 2 글자 태그에 동일하게 사용하십시오. &quot; 아라 &quot;있다</target>
        </trans-unit>
        <trans-unit id="57e127eec090cbe9dea58f22f65ee320b138415f" translate="yes" xml:space="preserve">
          <source>try_amagic_bin</source>
          <target state="translated">try_amagic_bin</target>
        </trans-unit>
        <trans-unit id="38278cac64d395a35f6260473b7ab836ae167fce" translate="yes" xml:space="preserve">
          <source>try_amagic_un</source>
          <target state="translated">try_amagic_un</target>
        </trans-unit>
        <trans-unit id="cb050805b03c907314122eca2548681495db1636" translate="yes" xml:space="preserve">
          <source>tst.fil</source>
          <target state="translated">tst.fil</target>
        </trans-unit>
        <trans-unit id="9f160f66c4d781a33c60820b496697aaf2bd47ff" translate="yes" xml:space="preserve">
          <source>tty(1)</source>
          <target state="translated">tty(1)</target>
        </trans-unit>
        <trans-unit id="6b7c4b72eb87c9f9986fb12efd7d83af95caa365" translate="yes" xml:space="preserve">
          <source>turkic</source>
          <target state="translated">turkic</target>
        </trans-unit>
        <trans-unit id="bb900dfa419ab730b52dadfa0dfec48b9c5a6aba" translate="yes" xml:space="preserve">
          <source>turns debugging on for all packages.</source>
          <target state="translated">모든 패키지에 대한 디버깅을 설정합니다.</target>
        </trans-unit>
        <trans-unit id="8a1f73e9662f187f57c576ccd9399ebd14ab3421" translate="yes" xml:space="preserve">
          <source>turns into</source>
          <target state="translated">로 변하다</target>
        </trans-unit>
        <trans-unit id="85691f9a0ab6bb1c21ccb666a6135b2368136c66" translate="yes" xml:space="preserve">
          <source>turns on &quot;taint&quot; so you can test them. Ordinarily these checks are done only when running setuid or setgid. It's a good idea to turn them on explicitly for programs that run on behalf of someone else whom you might not necessarily trust, such as CGI programs or any internet servers you might write in Perl. See &lt;a href=&quot;perlsec&quot;&gt;perlsec&lt;/a&gt; for details. For security reasons, this option must be seen by Perl quite early; usually this means it must appear early on the command line or in the &lt;code&gt;#!&lt;/code&gt; line for systems which support that construct.</source>
          <target state="translated">테스트 할 수 있도록 &quot;오염 물질&quot;을 켭니다. 일반적으로 이러한 검사는 setuid 또는 setgid를 실행할 때만 수행됩니다. CGI 프로그램이나 Perl로 작성할 수있는 인터넷 서버와 같이 반드시 신뢰할 수없는 다른 사람을 대신하여 실행되는 프로그램에 대해 명시 적으로 설정하는 것이 좋습니다. 자세한 내용은 &lt;a href=&quot;perlsec&quot;&gt;perlsec&lt;/a&gt; 을 참조하십시오. 보안상의 이유로이 옵션은 Perl에서 매우 일찍 보여야합니다. 일반적으로 이것은 명령 행 또는 &lt;code&gt;#!&lt;/code&gt; 해당 구성을 지원하는 시스템 라인.</target>
        </trans-unit>
        <trans-unit id="9a81459b2cd105c6c761074bb2b4a9e022fbe42b" translate="yes" xml:space="preserve">
          <source>turns on autosplit mode when used with a &lt;a href=&quot;#-n&quot;&gt;&quot;-n&quot;&lt;/a&gt; or &lt;a href=&quot;#-p&quot;&gt;&quot;-p&quot;&lt;/a&gt;. An implicit split command to the @F array is done as the first thing inside the implicit while loop produced by the &lt;a href=&quot;#-n&quot;&gt;&quot;-n&quot;&lt;/a&gt; or &lt;a href=&quot;#-p&quot;&gt;&quot;-p&quot;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#-n&quot;&gt;&quot;-n&quot;&lt;/a&gt; 또는 &lt;a href=&quot;#-p&quot;&gt;&quot;-p&quot;&lt;/a&gt; 와 함께 사용하면 자동 분할 모드가 켜집니다 . @F 배열에 대한 암시 적 분할 명령은 &lt;a href=&quot;#-n&quot;&gt;&quot;-n&quot;&lt;/a&gt; 또는 &lt;a href=&quot;#-p&quot;&gt;&quot;-p&quot;에&lt;/a&gt; 의해 생성 된 암시 적 while 루프 내에서 첫 번째로 수행됩니다 .</target>
        </trans-unit>
        <trans-unit id="ef46c243925d2af48b614f7b9635e2daf263b6a6" translate="yes" xml:space="preserve">
          <source>turns on autosplit mode when used with a &lt;b&gt;-n&lt;/b&gt; or &lt;b&gt;-p&lt;/b&gt;. An implicit split command to the @F array is done as the first thing inside the implicit while loop produced by the &lt;b&gt;-n&lt;/b&gt; or &lt;b&gt;-p&lt;/b&gt;.</source>
          <target state="translated">&lt;b&gt;-n&lt;/b&gt; 또는 &lt;b&gt;-p&lt;/b&gt; 와 함께 사용하면 자동 분리 모드를 켭니다 . @F 배열에 대한 암시 적 분할 명령은 &lt;b&gt;-n&lt;/b&gt; 또는 &lt;b&gt;-p에&lt;/b&gt; 의해 생성 된 암시 적 while 루프 내에서 첫 번째로 수행됩니다 .</target>
        </trans-unit>
        <trans-unit id="d758a5e43d45f7b0023331c6222762129e429a5f" translate="yes" xml:space="preserve">
          <source>tv_interval</source>
          <target state="translated">tv_interval</target>
        </trans-unit>
        <trans-unit id="eee45a4f6e1f6f37d3488c8a9faeb95e80168595" translate="yes" xml:space="preserve">
          <source>tv_interval ( $ref_to_gettimeofday [, $ref_to_later_gettimeofday] )</source>
          <target state="translated">tv_interval ($ ref_to_gettimeofday [, $ ref_to_later_gettimeofday])</target>
        </trans-unit>
        <trans-unit id="ad782ecdac770fc6eb9a62e44f90873fb97fb26b" translate="yes" xml:space="preserve">
          <source>two</source>
          <target state="translated">two</target>
        </trans-unit>
        <trans-unit id="9c545de6bb84eb94b6126add62f1eef381366296" translate="yes" xml:space="preserve">
          <source>two-dimensional slice</source>
          <target state="translated">이차원 조각</target>
        </trans-unit>
        <trans-unit id="a123eaabf183286fe1b857fb9fc12040b8b4df03" translate="yes" xml:space="preserve">
          <source>two_face.pm</source>
          <target state="translated">two_face.pm</target>
        </trans-unit>
        <trans-unit id="d0a3e7f81a9885e99049d1cae0336d269d5e47a9" translate="yes" xml:space="preserve">
          <source>type</source>
          <target state="translated">type</target>
        </trans-unit>
        <trans-unit id="b753343b5da37d198843243dcf888d1616a6a3c3" translate="yes" xml:space="preserve">
          <source>type ( [ TYPE ] )</source>
          <target state="translated">유형 ([TYPE])</target>
        </trans-unit>
        <trans-unit id="c1cde45778b2661710b4012364ab45886b602002" translate="yes" xml:space="preserve">
          <source>type casting</source>
          <target state="translated">유형 캐스팅</target>
        </trans-unit>
        <trans-unit id="a7c447fadcff0742d1e431e49dd7e912c62d2f17" translate="yes" xml:space="preserve">
          <source>type is a subtype of String. It describes a range of Versions that may be present or installed to fulfill prerequisites. It is specified in detail in the &lt;a href=&quot;#Version-Ranges&quot;&gt;&quot;Version Ranges&quot;&lt;/a&gt; section.</source>
          <target state="translated">type은 String의 하위 유형입니다. 전제 조건을 충족하기 위해 존재하거나 설치할 수있는 다양한 버전에 대해 설명합니다. &lt;a href=&quot;#Version-Ranges&quot;&gt;&quot;버전 범위&quot;&lt;/a&gt; 섹션 에 자세히 지정되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="5f7b4d8120e3abb8a993bd8c9369e8e492554273" translate="yes" xml:space="preserve">
          <source>type of $bar is a scalar reference, and we do not overload the scalar dereference. Thus we can get the</source>
          <target state="translated">$ bar 유형은 스칼라 참조이며 스칼라 역 참조를 오버로드하지 않습니다. 따라서 우리는 얻을 수 있습니다</target>
        </trans-unit>
        <trans-unit id="0f846c66a3d5e2d04d7dad5376934b529b97a76f" translate="yes" xml:space="preserve">
          <source>type of &lt;code&gt;File&lt;/code&gt; . All mp3 files are files, but not all files are mp3 files.</source>
          <target state="translated">&lt;code&gt;File&lt;/code&gt; 유형 . 모든 mp3 파일은 파일이지만 모든 파일이 mp3 파일 인 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="43e7a1b89addad0cac64c9cc3f6a39dbecf1e9ee" translate="yes" xml:space="preserve">
          <source>type of &lt;code&gt;File&lt;/code&gt;. All mp3 files are files, but not all files are mp3 files.</source>
          <target state="translated">&lt;code&gt;File&lt;/code&gt; 유형 . 모든 mp3 파일은 파일이지만 모든 파일이 mp3 파일은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="4d48747c7234e695806a5ec0475ca088f8de7d2c" translate="yes" xml:space="preserve">
          <source>type of damage only: FP flags changed when loading a DLL.</source>
          <target state="translated">손상 유형 만 : DLL을로드 할 때 FP 플래그가 변경되었습니다.</target>
        </trans-unit>
        <trans-unit id="2f746d02fe588180e5eec4bbf6e7e14f76d8a306" translate="yes" xml:space="preserve">
          <source>type()</source>
          <target state="translated">type()</target>
        </trans-unit>
        <trans-unit id="da13ec01e5255e09772a528daf1dc927ea109a6a" translate="yes" xml:space="preserve">
          <source>typed lexical</source>
          <target state="translated">입력 된 어휘</target>
        </trans-unit>
        <trans-unit id="6dc2082b65ff3a9aefc09caca29756531dea041a" translate="yes" xml:space="preserve">
          <source>typedef</source>
          <target state="translated">typedef</target>
        </trans-unit>
        <trans-unit id="5052707d2072399e0334e151ef42c6217ebc242f" translate="yes" xml:space="preserve">
          <source>typedef my_cxt_t</source>
          <target state="translated">typedef my_cxt_t</target>
        </trans-unit>
        <trans-unit id="609d101b171f19730b086799c893b4bced74e281" translate="yes" xml:space="preserve">
          <source>typeglob</source>
          <target state="translated">typeglob</target>
        </trans-unit>
        <trans-unit id="3f6b0af8d4178fa799abd02b53080eb8e0e9d792" translate="yes" xml:space="preserve">
          <source>typemap</source>
          <target state="translated">typemap</target>
        </trans-unit>
        <trans-unit id="e7b1fff7007b635892a8f2c7c17f4fabc7aa2f8c" translate="yes" xml:space="preserve">
          <source>types</source>
          <target state="translated">types</target>
        </trans-unit>
        <trans-unit id="deb55915d36bd1424af6d03d22f72514c86c0621" translate="yes" xml:space="preserve">
          <source>types_in</source>
          <target state="translated">types_in</target>
        </trans-unit>
        <trans-unit id="c3c57ccf025216fd17025a5cd72ba43c150e0712" translate="yes" xml:space="preserve">
          <source>typestash</source>
          <target state="translated">typestash</target>
        </trans-unit>
        <trans-unit id="51e69892ab49df85c6230ccc57f8e1d1606caccc" translate="yes" xml:space="preserve">
          <source>u</source>
          <target state="translated">u</target>
        </trans-unit>
        <trans-unit id="0fd46ec5b330088197c4793972e00723f3f26a43" translate="yes" xml:space="preserve">
          <source>ualarm ( $useconds [, $interval_useconds ] )</source>
          <target state="translated">ualarm ( $useconds [, $interval_useconds ] )</target>
        </trans-unit>
        <trans-unit id="4914c57306212f2cc515f07c8cf90f3fabf5399e" translate="yes" xml:space="preserve">
          <source>ualarm(0) will cancel an outstanding ualarm().</source>
          <target state="translated">ualarm (0)은 미해결 ualarm ()을 취소합니다.</target>
        </trans-unit>
        <trans-unit id="3519ace88affd1d0bcd984e15dfaf7b1c1479e99" translate="yes" xml:space="preserve">
          <source>uc</source>
          <target state="translated">uc</target>
        </trans-unit>
        <trans-unit id="46680910c867722cf1e95037ec06eee09df4a0d5" translate="yes" xml:space="preserve">
          <source>uc EXPR</source>
          <target state="translated">UC EXPR</target>
        </trans-unit>
        <trans-unit id="62a2132e3a00127b1e64e2e50602c12c4f218bce" translate="yes" xml:space="preserve">
          <source>ucfirst</source>
          <target state="translated">ucfirst</target>
        </trans-unit>
        <trans-unit id="46c5616dab2749d151e0c53b59ef03e6d4e5ee52" translate="yes" xml:space="preserve">
          <source>ucfirst EXPR</source>
          <target state="translated">ucfirst EXPR</target>
        </trans-unit>
        <trans-unit id="92e6f746eff84e65c584e48e78614108b0c4500a" translate="yes" xml:space="preserve">
          <source>ucmlint</source>
          <target state="translated">ucmlint</target>
        </trans-unit>
        <trans-unit id="85b193ef62ce5bd8f0d8f72987c5acefe070a801" translate="yes" xml:space="preserve">
          <source>ucmsort</source>
          <target state="translated">ucmsort</target>
        </trans-unit>
        <trans-unit id="c9915ec6eb1c1121af4deacd2838d47d88af181c" translate="yes" xml:space="preserve">
          <source>ucsort</source>
          <target state="translated">ucsort</target>
        </trans-unit>
        <trans-unit id="59788463710c67e54b3959fdfe20dceea39a24ab" translate="yes" xml:space="preserve">
          <source>udf</source>
          <target state="translated">udf</target>
        </trans-unit>
        <trans-unit id="e2577dd78b54fe28c65ee56ffbc8bb73058e08c0" translate="yes" xml:space="preserve">
          <source>uid</source>
          <target state="translated">uid</target>
        </trans-unit>
        <trans-unit id="25e8bd4f798f4792cc4245013ee9965840283795" translate="yes" xml:space="preserve">
          <source>uid =&amp;gt; $owner</source>
          <target state="translated">uid =&amp;gt; $owner</target>
        </trans-unit>
        <trans-unit id="9ab3443b0dd255d92dea875958de03ac53cd401e" translate="yes" xml:space="preserve">
          <source>uid and gid, in that order. A value of -1 in either position is interpreted by most systems to leave that value unchanged. Returns the number of files successfully changed.</source>
          <target state="translated">순서대로 uid와 gid 어느 위치에서든 값 -1은 대부분의 시스템에서 해당 값을 변경하지 않은 상태로 해석합니다. 성공적으로 변경된 파일 수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="b14ef85c6823dc1f2ef811c9a63a44faab1dfccc" translate="yes" xml:space="preserve">
          <source>uidf.U</source>
          <target state="translated">uidf.U</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
