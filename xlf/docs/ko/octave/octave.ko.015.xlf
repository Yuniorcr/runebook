<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="octave">
    <body>
      <group id="octave">
        <trans-unit id="0df6c4c521e5a12fe0560d4f3d744c268cbb69b9" translate="yes" xml:space="preserve">
          <source>If the second argument is a cell array of strings, search each directory of the path for element of the cell array and return the first that matches.</source>
          <target state="translated">두 번째 인수가 문자열의 셀형 배열 인 경우 경로의 각 디렉토리에서 셀형 배열의 요소를 검색하고 일치하는 첫 번째를 리턴하십시오.</target>
        </trans-unit>
        <trans-unit id="06befb8d4304856e2bf87ceba2c158dcc0b95b38" translate="yes" xml:space="preserve">
          <source>If the second argument is a scalar integer, &lt;em&gt;k&lt;/em&gt;, perform the same test in a linear autoregression model of order &lt;em&gt;k&lt;/em&gt;, i.e., with</source>
          <target state="translated">두 번째 인수는 스칼라 정수인 경우, &lt;em&gt;K&lt;/em&gt; , 차 선형 자기 회귀 모형에서 동일한 테스트를 수행 &lt;em&gt;K&lt;/em&gt; 로, 즉</target>
        </trans-unit>
        <trans-unit id="aa5750ec4a5298173e1839bd440378adb7cde535" translate="yes" xml:space="preserve">
          <source>If the second argument is an integer &lt;var&gt;n&lt;/var&gt;, the arguments are &lt;code&gt;&quot;x&quot;&lt;/code&gt;, &lt;code&gt;&quot;P1&quot;&lt;/code&gt;, &amp;hellip;, &lt;code&gt;&quot;P&lt;var&gt;N&lt;/var&gt;&quot;&lt;/code&gt;.</source>
          <target state="translated">두 번째 인수가 정수 &lt;var&gt;n&lt;/var&gt; 이면 인수는 &lt;code&gt;&quot;x&quot;&lt;/code&gt; , &lt;code&gt;&quot;P1&quot;&lt;/code&gt; ,&amp;hellip;, &lt;code&gt;&quot;P&lt;var&gt;N&lt;/var&gt;&quot;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="d8ae7f5c0300665cd22170701ed0272e5aae7e47" translate="yes" xml:space="preserve">
          <source>If the second argument is exactly 0, then the choice of decomposition is based on the matrix &lt;var&gt;A&lt;/var&gt;. If &lt;var&gt;A&lt;/var&gt; has more rows than columns then an economy-sized decomposition is returned, otherwise a regular decomposition is calculated.</source>
          <target state="translated">두 번째 인수가 정확히 0이면 분해 선택은 행렬 &lt;var&gt;A&lt;/var&gt; 를 기반으로합니다 . 경우 &lt;var&gt;A&lt;/var&gt; 는 다음 열보다 더 많은 행이 경제 규모 분해, 그렇지 않으면 정규 분해가 계산되고, 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="21f3a2615a58f45e8500001d9723567171ecc761" translate="yes" xml:space="preserve">
          <source>If the second argument is not given, &lt;code&gt;p&amp;nbsp;=&amp;nbsp;2&lt;/code&gt; is used.</source>
          <target state="translated">두 번째 인수가 제공되지 않으면 &lt;code&gt;p&amp;nbsp;=&amp;nbsp;2&lt;/code&gt; 가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="95bed98cae0fe89b2777dfd192fdd2c3f9282100" translate="yes" xml:space="preserve">
          <source>If the second argument is omitted, it is taken to be</source>
          <target state="translated">두 번째 인수를 생략하면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="cac2105ae45e45a2e758850cc5a07104a752567d" translate="yes" xml:space="preserve">
          <source>If the second argument is omitted, the first row is taken to be the same as the first column. If the first element of &lt;var&gt;r&lt;/var&gt; is not the same as the first element of &lt;var&gt;c&lt;/var&gt;, the first element of &lt;var&gt;c&lt;/var&gt; is used.</source>
          <target state="translated">두 번째 인수를 생략하면 첫 번째 행이 첫 번째 열과 동일하게됩니다. 첫 번째 요소 경우 &lt;var&gt;r&lt;/var&gt; 첫 번째 요소와 동일하지 &lt;var&gt;c&lt;/var&gt; 의 첫 번째 요소 &lt;var&gt;c&lt;/var&gt; 사용한다.</target>
        </trans-unit>
        <trans-unit id="b156e49b773ef66cd6f39f8605dbaf4888d4e117" translate="yes" xml:space="preserve">
          <source>If the second argument is the string &lt;code&gt;&quot;grabdemo&quot;&lt;/code&gt;, the contents of any built-in demo blocks are extracted but not executed. The text for all code blocks is concatenated and returned as &lt;var&gt;code&lt;/var&gt; with &lt;var&gt;idx&lt;/var&gt; being a vector of positions of the ends of each demo block. For an easier way to extract demo blocks from files, See &lt;a href=&quot;demonstration-functions#XREFexample&quot;&gt;example&lt;/a&gt;.</source>
          <target state="translated">두 번째 인수가 문자열 &lt;code&gt;&quot;grabdemo&quot;&lt;/code&gt; 인 경우 내장 데모 블록의 컨텐츠가 추출되지만 실행되지는 않습니다. 모든 코드 블록의 텍스트는 연결되고 &lt;var&gt;idx&lt;/var&gt; 는 각 데모 블록의 끝 위치 벡터 로 &lt;var&gt;code&lt;/var&gt; 로 반환됩니다 . 파일에서 데모 블록을 추출하는 더 쉬운 방법은 &lt;a href=&quot;demonstration-functions#XREFexample&quot;&gt;예제를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="deb35d097b1261b6b483d28d5e7e167741b88fd6" translate="yes" xml:space="preserve">
          <source>If the second optional argument &lt;code&gt;&quot;all&quot;&lt;/code&gt; is supplied, return a cell array containing the list of all files that have the same name in the path. If no files are found, return an empty cell array.</source>
          <target state="translated">두 번째 선택적 인수 &lt;code&gt;&quot;all&quot;&lt;/code&gt; 이 제공되면 경로에서 이름이 같은 모든 파일 목록이 포함 된 셀형 배열을 반환합니다. 파일이 없으면 빈 셀형 배열을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="f8caca0dcc83f0731711218de2798af32f3ffba4" translate="yes" xml:space="preserve">
          <source>If the second output &lt;var&gt;V&lt;/var&gt; is requested the volume of the enclosing convex hull is calculated.</source>
          <target state="translated">제 2 출력 ( &lt;var&gt;V&lt;/var&gt; ) 이 요청되면, 둘러싸는 볼록 껍질의 부피가 계산된다.</target>
        </trans-unit>
        <trans-unit id="c2906c56aeeaff7b81889d3ea0fe0ce7b9d2f50d" translate="yes" xml:space="preserve">
          <source>If the second output &lt;var&gt;v&lt;/var&gt; is requested the volume of the enclosing convex hull is calculated.</source>
          <target state="translated">두 번째 출력 &lt;var&gt;v&lt;/var&gt; 가 요청되면, 둘러싸는 볼록 껍질의 부피가 계산됩니다.</target>
        </trans-unit>
        <trans-unit id="3d87b3c66ad09a211b9c5f7e7061d9412e583709" translate="yes" xml:space="preserve">
          <source>If the size of the coefficient matrix &lt;var&gt;A&lt;/var&gt; is n-by-p, the size of the vector/array of constant terms &lt;var&gt;b&lt;/var&gt; must be n-by-k.</source>
          <target state="translated">계수 행렬 &lt;var&gt;A&lt;/var&gt; 의 크기가 nxp 인 경우 상수 항 &lt;var&gt;b&lt;/var&gt; 의 벡터 / 배열의 크기는 nxk 여야합니다.</target>
        </trans-unit>
        <trans-unit id="b6fb64fbbf1c454cab9e5d9613b7e9e3edd69c42" translate="yes" xml:space="preserve">
          <source>If the sparse Cholesky factorization failed or the matrix is not Hermitian with a real positive diagonal, and the matrix is square, factorize, solve, and perform one refinement iteration using &lt;small&gt;UMFPACK&lt;/small&gt;.</source>
          <target state="translated">희소 한 Cholesky 인수 분해에 실패했거나 행렬이 양의 대각선을 갖는 Hermitian이 아니고 행렬이 정사각형 인 경우 &lt;small&gt;UMFPACK을&lt;/small&gt; 사용하여 하나의 정제 반복을 &lt;small&gt;수행&lt;/small&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="0aa50f26b186313753a1994ffee369a8ba66192e" translate="yes" xml:space="preserve">
          <source>If the special parameter name &lt;code&gt;varargin&lt;/code&gt; appears at the end of a function parameter list it indicates that the function takes a variable number of input arguments. Using &lt;code&gt;varargin&lt;/code&gt; the function looks like this</source>
          <target state="translated">특수 매개 변수 이름 &lt;code&gt;varargin&lt;/code&gt; 이 함수 매개 변수 목록의 끝에 나타나면 함수가 가변 개수의 입력 인수를 취함을 나타냅니다. &lt;code&gt;varargin&lt;/code&gt; 을 사용 하면 함수는 다음과 같습니다</target>
        </trans-unit>
        <trans-unit id="411979ed557508221faee0034bcca10239a01f7e" translate="yes" xml:space="preserve">
          <source>If the string &lt;var&gt;format&lt;/var&gt; is not present or is equal to &lt;code&gt;&quot;short&quot;&lt;/code&gt; then &lt;var&gt;s&lt;/var&gt; will contain the abbreviated name of the weekday. If &lt;var&gt;format&lt;/var&gt; is &lt;code&gt;&quot;long&quot;&lt;/code&gt; then &lt;var&gt;s&lt;/var&gt; will contain the full name.</source>
          <target state="translated">문자열의 경우 &lt;var&gt;format&lt;/var&gt; 존재하지 않거나 같다 &lt;code&gt;&quot;short&quot;&lt;/code&gt; 다음 &lt;var&gt;s&lt;/var&gt; 평일의 약식 이름이 포함됩니다. 경우 &lt;var&gt;format&lt;/var&gt; 입니다 &lt;code&gt;&quot;long&quot;&lt;/code&gt; 다음 &lt;var&gt;s&lt;/var&gt; 전체 이름이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="c48f8fe9e13454dfed7b770497ad25548cea05ab" translate="yes" xml:space="preserve">
          <source>If the string &lt;var&gt;line_spec&lt;/var&gt; is given it is passed to &lt;code&gt;plot&lt;/code&gt; and determines the appearance of the plot.</source>
          <target state="translated">문자열 &lt;var&gt;line_spec&lt;/var&gt; 이 제공되면 &lt;code&gt;plot&lt;/code&gt; 으로 전달되고 플롯 의 모양을 결정합니다.</target>
        </trans-unit>
        <trans-unit id="c80a5137395eded9fbd6974f21a8e44709dac807" translate="yes" xml:space="preserve">
          <source>If the string argument &lt;code&gt;&quot;pp&quot;&lt;/code&gt; is specified, then &lt;var&gt;xi&lt;/var&gt; should not be supplied and &lt;code&gt;interp1&lt;/code&gt; returns a piecewise polynomial object. This object can later be used with &lt;code&gt;ppval&lt;/code&gt; to evaluate the interpolation. There is an equivalence, such that &lt;code&gt;ppval (interp1 (&lt;var&gt;x&lt;/var&gt;,
&lt;var&gt;y&lt;/var&gt;, &lt;var&gt;method&lt;/var&gt;, &lt;code&gt;&quot;pp&quot;&lt;/code&gt;), &lt;var&gt;xi&lt;/var&gt;) == interp1 (&lt;var&gt;x&lt;/var&gt;,
&lt;var&gt;y&lt;/var&gt;, &lt;var&gt;xi&lt;/var&gt;, &lt;var&gt;method&lt;/var&gt;, &lt;code&gt;&quot;extrap&quot;&lt;/code&gt;)&lt;/code&gt;.</source>
          <target state="translated">문자열 인수 &lt;code&gt;&quot;pp&quot;&lt;/code&gt; 가 지정되면 &lt;var&gt;xi&lt;/var&gt; 를 제공하지 않아야하며 &lt;code&gt;interp1&lt;/code&gt; 은 부분 다항식 오브젝트를 리턴합니다. 이 오브젝트는 나중에 &lt;code&gt;ppval&lt;/code&gt; 과 함께 사용 하여 보간을 평가할 수 있습니다 . 등가 등이있다 &lt;code&gt;ppval (interp1 (&lt;var&gt;x&lt;/var&gt;, &lt;var&gt;y&lt;/var&gt;, &lt;var&gt;method&lt;/var&gt;, &lt;code&gt;&quot;pp&quot;&lt;/code&gt;), &lt;var&gt;xi&lt;/var&gt;) == interp1 (&lt;var&gt;x&lt;/var&gt;, &lt;var&gt;y&lt;/var&gt;, &lt;var&gt;xi&lt;/var&gt;, &lt;var&gt;method&lt;/var&gt;, &lt;code&gt;&quot;extrap&quot;&lt;/code&gt;)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f5c0f8d667568e752e5b2166403deeeb764b9b08" translate="yes" xml:space="preserve">
          <source>If the syntax of a conversion specification is invalid, the behavior is undefined. If there aren&amp;rsquo;t enough function arguments provided to supply addresses for all the conversion specifications in the template strings that perform assignments, or if the arguments are not of the correct types, the behavior is also undefined. On the other hand, extra arguments are simply ignored.</source>
          <target state="translated">변환 스펙의 구문이 유효하지 않은 경우 동작이 정의되지 않습니다. 할당을 수행하는 템플릿 문자열에 모든 변환 사양에 대한 주소를 제공하기 위해 함수 인수가 충분하지 않거나 인수가 올바른 유형이 아닌 경우 동작도 정의되지 않습니다. 반면에 추가 인수는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="dd56d4f811d6e2cbdc551e1ec1a9d13b19fd770f" translate="yes" xml:space="preserve">
          <source>If the syntax of a conversion specification is invalid, unpredictable things will happen, so don&amp;rsquo;t do this. In particular, &lt;small&gt;MATLAB&lt;/small&gt; allows a bare percentage sign &amp;lsquo;</source>
          <target state="translated">변환 사양의 구문이 유효하지 않으면 예측할 수없는 일이 발생하므로 그렇게하지 마십시오. 특히 &lt;small&gt;MATLAB&lt;/small&gt; 은 맨 백분율 기호 '</target>
        </trans-unit>
        <trans-unit id="11c8c537e9a44af9db951c3d725149c43311f13d" translate="yes" xml:space="preserve">
          <source>If the system is not square, or if the coefficient matrix is singular, a minimum norm solution is computed.</source>
          <target state="translated">시스템이 정사각형이 아니거나 계수 행렬이 특이한 경우 최소 표준 솔루션이 계산됩니다.</target>
        </trans-unit>
        <trans-unit id="7f7def31458d7ee4a3cd6fcf3610320929eb3af7" translate="yes" xml:space="preserve">
          <source>If the table is decreasing, then the tests are reversed. For non-strictly monotonic tables, empty intervals are always skipped. The result is undefined if &lt;var&gt;table&lt;/var&gt; is not monotonic, or if &lt;var&gt;table&lt;/var&gt; contains a NaN.</source>
          <target state="translated">테이블이 감소하면 테스트가 취소됩니다. 엄격하게 단조로운 테이블의 경우 빈 간격은 항상 건너 뜁니다. &lt;var&gt;table&lt;/var&gt; 이 단조롭지 않거나 &lt;var&gt;table&lt;/var&gt; 에 NaN이 포함 된 경우 결과가 정의되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="ceda42284f2e6478ceabd463e9e5884d1c665c0c" translate="yes" xml:space="preserve">
          <source>If the third argument &lt;code&gt;&quot;exact&quot;&lt;/code&gt; is not given, then &lt;var&gt;s&lt;/var&gt; only needs to match &lt;var&gt;A&lt;/var&gt; up to the length of &lt;var&gt;s&lt;/var&gt;. Trailing spaces and nulls in &lt;var&gt;s&lt;/var&gt; and &lt;var&gt;A&lt;/var&gt; are ignored when matching.</source>
          <target state="translated">세 번째 인수 &lt;code&gt;&quot;exact&quot;&lt;/code&gt; 가 제공되지 않으면 &lt;var&gt;s&lt;/var&gt; 는 &lt;var&gt;A&lt;/var&gt; 와 &lt;var&gt;s&lt;/var&gt; 의 길이까지만 일치 하면 됩니다. &lt;var&gt;s&lt;/var&gt; 및 &lt;var&gt;A&lt;/var&gt; 의 후행 공백과 널은 일치시 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="d0eaeadc3808e920cbad0a6cc89679e3f1549287" translate="yes" xml:space="preserve">
          <source>If the third optional argument &lt;code&gt;&quot;all&quot;&lt;/code&gt; is supplied, return a cell array containing the list of all files that have the same name in the path. If no files are found, return an empty cell array.</source>
          <target state="translated">세 번째 선택적 인수 &lt;code&gt;&quot;all&quot;&lt;/code&gt; 이 제공되면 경로에서 이름이 같은 모든 파일 목록이 포함 된 셀형 배열을 반환합니다. 파일이 없으면 빈 셀형 배열을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="79ca39746906984bb3f81258f06472b17d576369" translate="yes" xml:space="preserve">
          <source>If the user ID does not exist in the database, &lt;code&gt;getpwuid&lt;/code&gt; returns 0.</source>
          <target state="translated">데이터베이스에 사용자 ID가 없으면 &lt;code&gt;getpwuid&lt;/code&gt; 는 0을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="9afd446fbdded29059e6bd61a1de013556edeab0" translate="yes" xml:space="preserve">
          <source>If the user name does not exist in the database, &lt;code&gt;getpwname&lt;/code&gt; returns 0.</source>
          <target state="translated">데이터베이스에 사용자 이름이 없으면 &lt;code&gt;getpwname&lt;/code&gt; 은 0을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="af43816dc1972972e05c1dec9ffa5e78d9b37a02" translate="yes" xml:space="preserve">
          <source>If the user preference to request confirmation before exiting, Octave will display a dialog and give the user an option to cancel the exit process.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb46472d180db476853061352932e6236a988a7a" translate="yes" xml:space="preserve">
          <source>If the values are cell arrays, create a structure array and initialize its values. The dimensions of each cell array of values must match. Singleton cells and non-cell values are repeated so that they fill the entire array. If the cells are empty, create an empty structure array with the specified field names.</source>
          <target state="translated">값이 셀형 배열 인 경우 구조 배열을 만들고 해당 값을 초기화하십시오. 값의 각 셀형 배열의 차원이 일치해야합니다. 단일 셀과 비셀 값이 반복되어 전체 배열을 채 웁니다. 셀이 비어 있으면 지정된 필드 이름으로 빈 구조 배열을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="4277f70c61c1b8712828a8252c47029d2324ea8e" translate="yes" xml:space="preserve">
          <source>If the values passed to &lt;code&gt;struct&lt;/code&gt; are a mix of scalar and cell arrays, then the scalar arguments are expanded to create a structure array with a consistent dimension. For example:</source>
          <target state="translated">&lt;code&gt;struct&lt;/code&gt; 에 전달 된 값 이 스칼라와 셀형 배열의 혼합 인 경우 스칼라 인수가 확장되어 일관된 차원을 가진 구조형 배열이 만들어집니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d1f5d4f442fda24f59067bfb502d9de63bd23ba1" translate="yes" xml:space="preserve">
          <source>If the vertices are matrices of size MxN then each polygon patch has M vertices and a total of N polygons will be created. If some polygons do not have M vertices use NaN to represent &quot;no vertex&quot;. If the &lt;var&gt;z&lt;/var&gt; input is present then 3-D patches will be created.</source>
          <target state="translated">꼭짓점이 MxN 크기의 행렬이면 각 다각형 패치에는 M 개의 꼭짓점이 있고 총 N 개의 다각형이 만들어집니다. 일부 다각형에 M 꼭짓점이없는 경우 NaN을 사용하여 &quot;정점 없음&quot;을 나타냅니다. 경우] &lt;var&gt;z&lt;/var&gt; 입력이 존재하는 그 다음 3 차원의 패치가 생성 될 것이다.</target>
        </trans-unit>
        <trans-unit id="c7f859ad48c3c678ee2d34a33595989d371f6a23" translate="yes" xml:space="preserve">
          <source>If the warning message does not end with a newline character, Octave will print a traceback of all the function calls leading to the warning. If the warning message does end in a newline character, Octave will suppress the traceback messages as it returns control to the top level. For more details and examples, see &lt;a href=&quot;raising-errors#XREFerror&quot;&gt;error&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19c79da4dff816707d10d1953c16baa5690b903d" translate="yes" xml:space="preserve">
          <source>If there are &lt;em&gt;n&lt;/em&gt; intervals, and the dimensionality of &lt;var&gt;pp&lt;/var&gt; is &lt;em&gt;d&lt;/em&gt;, the resulting array has dimensions &lt;code&gt;[d, n-1]&lt;/code&gt;.</source>
          <target state="translated">이 경우 &lt;em&gt;해당&lt;/em&gt; 구간과의 차원 &lt;var&gt;pp&lt;/var&gt; 된다 &lt;em&gt;거라고&lt;/em&gt; , 생성 된 어레이는 크기 갖는다 &lt;code&gt;[d, n-1]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4f5708c5970afa52c84aa728ec44d21d1f3f8325" translate="yes" xml:space="preserve">
          <source>If there are more than two input arguments &lt;var&gt;A1&lt;/var&gt;, &lt;var&gt;A2&lt;/var&gt;, &amp;hellip;, &lt;var&gt;An&lt;/var&gt; the Kronecker product is computed as</source>
          <target state="translated">두 개 이상의 입력 인수 &lt;var&gt;A1&lt;/var&gt; , &lt;var&gt;A2&lt;/var&gt; ,&amp;hellip;가 &lt;var&gt;An&lt;/var&gt; 경우 크로네 커 곱은 다음과 같이 계산됩니다.</target>
        </trans-unit>
        <trans-unit id="5fff74736c09f9afd94e0ed0a903bb922d18bab8" translate="yes" xml:space="preserve">
          <source>If there are no more characters to read, &lt;code&gt;fgetl&lt;/code&gt; returns -1.</source>
          <target state="translated">읽을 문자가 더 없으면 &lt;code&gt;fgetl&lt;/code&gt; 은 -1을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d61554f6de707b465a89e5e65b3eeec342886df9" translate="yes" xml:space="preserve">
          <source>If there are no more characters to read, &lt;code&gt;fgets&lt;/code&gt; returns -1.</source>
          <target state="translated">읽을 문자가 더 없으면 &lt;code&gt;fgets&lt;/code&gt; 는 -1을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d9a77d7524b5df607f9e102e1fbdd2a3e1299ada" translate="yes" xml:space="preserve">
          <source>If there are not a perfect number &lt;var&gt;n&lt;/var&gt; of regularly spaced colors then the remaining entries in the colormap are gradients of pure red, green, blue, and gray.</source>
          <target state="translated">규칙적인 간격으로 색상 이 완벽한 &lt;var&gt;n&lt;/var&gt; 개가없는 경우 컬러 맵의 나머지 항목은 순수한 빨강, 녹색, 파랑 및 회색의 그라데이션입니다.</target>
        </trans-unit>
        <trans-unit id="f6d0c608152a6bc6a3dfcb08770431c7142b33f6" translate="yes" xml:space="preserve">
          <source>If there are three named outputs and &lt;var&gt;opts&lt;/var&gt;.milu != &lt;code&gt;&quot;row&quot;&lt;/code&gt;, &lt;var&gt;P&lt;/var&gt; is returned such that &lt;var&gt;L&lt;/var&gt; and &lt;var&gt;U&lt;/var&gt; are incomplete factors of &lt;code&gt;&lt;var&gt;P&lt;/var&gt;*&lt;var&gt;A&lt;/var&gt;&lt;/code&gt;. When &lt;var&gt;opts&lt;/var&gt;.milu == &lt;code&gt;&quot;row&quot;&lt;/code&gt;, &lt;var&gt;P&lt;/var&gt; is returned such that &lt;var&gt;L&lt;/var&gt; and &lt;var&gt;U&lt;/var&gt; are incomplete factors of &lt;code&gt;&lt;var&gt;A&lt;/var&gt;*&lt;var&gt;P&lt;/var&gt;&lt;/code&gt;.</source>
          <target state="translated">세라는 출력하고있는 경우 &lt;var&gt;opts&lt;/var&gt; .milu! = &lt;code&gt;&quot;row&quot;&lt;/code&gt; , &lt;var&gt;P&lt;/var&gt; 가 되도록 리턴 &lt;var&gt;L&lt;/var&gt; 을 그리고 &lt;var&gt;U&lt;/var&gt; 는 불완전 요인 &lt;code&gt;&lt;var&gt;P&lt;/var&gt;*&lt;var&gt;A&lt;/var&gt;&lt;/code&gt; . 경우 &lt;var&gt;opts&lt;/var&gt; == .milu &lt;code&gt;&quot;row&quot;&lt;/code&gt; , &lt;var&gt;P&lt;/var&gt; 가 되도록 리턴 &lt;var&gt;L&lt;/var&gt; 을 그리고 &lt;var&gt;U&lt;/var&gt; 는 불완전 요인 &lt;code&gt;&lt;var&gt;A&lt;/var&gt;*&lt;var&gt;P&lt;/var&gt;&lt;/code&gt; &lt;var&gt;P&lt;/var&gt; . &lt;var&gt;A&lt;/var&gt;</target>
        </trans-unit>
        <trans-unit id="8fb8c4db6c12b518ec653719b12258196d1d446b" translate="yes" xml:space="preserve">
          <source>If there aren&amp;rsquo;t enough function arguments provided to supply values for all the conversion specifications in the template string, or if the arguments are not of the correct types, the results are unpredictable. If you supply more arguments than conversion specifications, the extra argument values are simply ignored; this is sometimes useful.</source>
          <target state="translated">템플릿 문자열의 모든 변환 사양에 대한 값을 제공하기 위해 제공된 함수 인수가 충분하지 않거나 인수가 올바른 유형이 아닌 경우 결과를 예측할 수 없습니다. 변환 스펙보다 많은 인수를 제공하면 추가 인수 값은 무시됩니다. 이것은 때때로 유용하다.</target>
        </trans-unit>
        <trans-unit id="7d77672ea489d6625044df7c72dcc471ea8b4a6a" translate="yes" xml:space="preserve">
          <source>If there is no such occurrence, or if &lt;var&gt;pattern&lt;/var&gt; is longer than &lt;var&gt;str&lt;/var&gt;, or if &lt;var&gt;pattern&lt;/var&gt; itself is empty, then &lt;var&gt;idx&lt;/var&gt; is the empty array &lt;code&gt;[]&lt;/code&gt;.</source>
          <target state="translated">이 그러한 사건없는 경우, 또는하면 &lt;var&gt;pattern&lt;/var&gt; 보다 긴 &lt;var&gt;str&lt;/var&gt; 있으면, &lt;var&gt;pattern&lt;/var&gt; 자체가 비어 후 &lt;var&gt;idx&lt;/var&gt; 비어있는 배열이다 &lt;code&gt;[]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c30283e28d15374ce7afa68c7294756b2af60e0f" translate="yes" xml:space="preserve">
          <source>If this auto-joining feature is not desired then it is important to call &lt;code&gt;newplot&lt;/code&gt; first to prepare a new figure and axes for plotting. Alternatively, the easier way is to call a high-level graphics routine which will both create the plot and then populate it with low-level graphics objects. Instead of calling &lt;code&gt;line&lt;/code&gt;, use &lt;code&gt;plot&lt;/code&gt;. Or use &lt;code&gt;surf&lt;/code&gt; instead of &lt;code&gt;surface&lt;/code&gt;. Or use &lt;code&gt;fill&lt;/code&gt; instead of &lt;code&gt;patch&lt;/code&gt;.</source>
          <target state="translated">이 자동 결합 기능은 다음 바람직하지 않은 경우 호출하는 것이 중요하다 &lt;code&gt;newplot&lt;/code&gt; 첫번째 플롯에 대한 새로운 그림 도끼를 준비 할 수 있습니다. 또는 더 쉬운 방법은 플롯을 생성 한 다음 낮은 레벨의 그래픽 객체로 채우는 고급 그래픽 루틴을 호출하는 것입니다. &lt;code&gt;line&lt;/code&gt; 을 호출하는 대신 &lt;code&gt;plot&lt;/code&gt; 을 사용하십시오 . 또는 &lt;code&gt;surface&lt;/code&gt; 대신 &lt;code&gt;surf&lt;/code&gt; 를 사용하십시오 . 또는 &lt;code&gt;patch&lt;/code&gt; 대신 &lt;code&gt;fill&lt;/code&gt; 을 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="a073408ddc0c24f7b7e15b27fff80447048a9218" translate="yes" xml:space="preserve">
          <source>If this code is in the file</source>
          <target state="translated">이 코드가 파일에 있으면</target>
        </trans-unit>
        <trans-unit id="c186aa67163d53e071d9a1f94e7d3c040cec57d3" translate="yes" xml:space="preserve">
          <source>If this file exists here, its contents are also appended to the &lt;var&gt;static classpath&lt;/var&gt;. Note that the archives and class directories defined in this last step will affect all users.</source>
          <target state="translated">이 파일이 여기에 있으면 해당 내용도 &lt;var&gt;static classpath&lt;/var&gt; 추가됩니다 . 이 마지막 단계에서 정의 된 아카이브 및 클래스 디렉토리는 모든 사용자에게 영향을 미칩니다.</target>
        </trans-unit>
        <trans-unit id="9fe1b21e6677b5cde6bd4d871edfd41a5b0006b6" translate="yes" xml:space="preserve">
          <source>If this flag is set, the simplex solver uses the built-in LP presolver. Otherwise the LP presolver is not used.</source>
          <target state="translated">이 플래그가 설정되면 단순 솔버는 내장 LP 프리 솔버를 사용합니다. 그렇지 않으면 LP 프리 솔버가 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="425d9b3d3ac8383a187a702252cb78cd940c1df9" translate="yes" xml:space="preserve">
          <source>If this is not what you want, use a series of calls instead of just one.</source>
          <target state="translated">이것이 원하는 것이 아닌 경우에는 하나 대신 일련의 통화를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="71c9ac798f7a26afe6bf81e9c7f32d7fec18da82" translate="yes" xml:space="preserve">
          <source>If this option is disabled, Octave will display the results produced by evaluating expressions within a function body that are not terminated with a semicolon.</source>
          <target state="translated">이 옵션을 비활성화하면 Octave는 세미콜론으로 끝나지 않은 함수 본문 내에서 식을 평가하여 생성 된 결과를 표시합니다.</target>
        </trans-unit>
        <trans-unit id="07f0da3410b1db12e2687b408f9d6f936f52214a" translate="yes" xml:space="preserve">
          <source>If this option is set to a nonzero value, you must also set the &lt;code&gt;&quot;algebraic variables&quot;&lt;/code&gt; option to declare which variables in the problem are algebraic.</source>
          <target state="translated">이 옵션이 0이 아닌 값으로 설정되어 있으면 &lt;code&gt;&quot;algebraic variables&quot;&lt;/code&gt; 옵션을 설정 하여 문제에서 어떤 변수가 대수인지 선언 해야합니다 .</target>
        </trans-unit>
        <trans-unit id="7c819311db6560697d870fd9f74fb56f13b936c4" translate="yes" xml:space="preserve">
          <source>If this parameter is nonzero, save a copy of the problem in CPLEX LP format to the file</source>
          <target state="translated">이 매개 변수가 0이 아닌 경우 문제점의 사본을 CPLEX LP 형식으로 파일에 저장하십시오.</target>
        </trans-unit>
        <trans-unit id="46bcd3c544112adca42b202c0397e2a9dfa6e7bd" translate="yes" xml:space="preserve">
          <source>If this property is set to &lt;code&gt;&quot;auto&quot;&lt;/code&gt;, &lt;code&gt;facenormals&lt;/code&gt; are automatically calculated if the &lt;code&gt;edgelighting&lt;/code&gt; or &lt;code&gt;facelighting&lt;/code&gt; property are set to &lt;code&gt;&quot;flat&quot;&lt;/code&gt; and at least one &lt;code&gt;light&lt;/code&gt; object is present and visible in the same axes.</source>
          <target state="translated">이 속성이 설정된 경우 &lt;code&gt;&quot;auto&quot;&lt;/code&gt; , &lt;code&gt;facenormals&lt;/code&gt; 이 경우 생성 자동 계산 &lt;code&gt;edgelighting&lt;/code&gt; 또는 &lt;code&gt;facelighting&lt;/code&gt; 속성으로 설정되는 &lt;code&gt;&quot;flat&quot;&lt;/code&gt; 적어도 하나의 &lt;code&gt;light&lt;/code&gt; 객체가 동일한 축에 표시되고있는 것이다.</target>
        </trans-unit>
        <trans-unit id="6077e6f770f9107d66cd1585cc21d324b40c17e8" translate="yes" xml:space="preserve">
          <source>If this property is set to &lt;code&gt;&quot;auto&quot;&lt;/code&gt;, &lt;code&gt;vertexnormals&lt;/code&gt; are automatically calculated if the &lt;code&gt;edgelighting&lt;/code&gt; or &lt;code&gt;facelighting&lt;/code&gt; property are set to &lt;code&gt;&quot;gouraud&quot;&lt;/code&gt; and at least one &lt;code&gt;light&lt;/code&gt; object is present and visible in the same axes.</source>
          <target state="translated">이 속성이 설정된 경우 &lt;code&gt;&quot;auto&quot;&lt;/code&gt; , &lt;code&gt;vertexnormals&lt;/code&gt; 이 경우 생성 자동 계산 &lt;code&gt;edgelighting&lt;/code&gt; 또는 &lt;code&gt;facelighting&lt;/code&gt; 속성으로 설정되는 &lt;code&gt;&quot;gouraud&quot;&lt;/code&gt; 적어도 하나의 &lt;code&gt;light&lt;/code&gt; 객체는 동일한 축에 표시되고있는 것이다.</target>
        </trans-unit>
        <trans-unit id="9809a1c5546b6926d2e226fef68bd666c11d22ff" translate="yes" xml:space="preserve">
          <source>If this value is a nonzero scalar, then &lt;code&gt;amd&lt;/code&gt; performs aggressive absorption. The default is not to perform aggressive absorption.</source>
          <target state="translated">이 값이 0이 아닌 스칼라이면 &lt;code&gt;amd&lt;/code&gt; 는 적극적인 흡수를 수행합니다. 기본값은 적극적인 흡수를 수행하지 않는 것입니다.</target>
        </trans-unit>
        <trans-unit id="077abad53add4988eef61e00d1cbbece4128b0df" translate="yes" xml:space="preserve">
          <source>If three functions are passed, then plot the parametrically defined function &lt;code&gt;[&lt;var&gt;fx&lt;/var&gt;(&lt;var&gt;s&lt;/var&gt;, &lt;var&gt;t&lt;/var&gt;), &lt;var&gt;fy&lt;/var&gt;(&lt;var&gt;s&lt;/var&gt;, &lt;var&gt;t&lt;/var&gt;),
&lt;var&gt;fz&lt;/var&gt;(&lt;var&gt;s&lt;/var&gt;, &lt;var&gt;t&lt;/var&gt;)]&lt;/code&gt;.</source>
          <target state="translated">세 개의 함수가 전달되면 파라 메트릭 정의 함수 &lt;code&gt;[&lt;var&gt;fx&lt;/var&gt;(&lt;var&gt;s&lt;/var&gt;, &lt;var&gt;t&lt;/var&gt;), &lt;var&gt;fy&lt;/var&gt;(&lt;var&gt;s&lt;/var&gt;, &lt;var&gt;t&lt;/var&gt;), &lt;var&gt;fz&lt;/var&gt;(&lt;var&gt;s&lt;/var&gt;, &lt;var&gt;t&lt;/var&gt;)]&lt;/code&gt; 를 플로팅합니다 .</target>
        </trans-unit>
        <trans-unit id="5ad908d29eb5f73de31da68b0e7eef25038742fd" translate="yes" xml:space="preserve">
          <source>If three inputs are given, &lt;var&gt;direction&lt;/var&gt; should be one of &lt;code&gt;&quot;first&quot;&lt;/code&gt; or &lt;code&gt;&quot;last&quot;&lt;/code&gt;, requesting only the first or last &lt;var&gt;n&lt;/var&gt; indices, respectively. However, the indices are always returned in ascending order.</source>
          <target state="translated">세 개의 입력 값이 제공되면 &lt;var&gt;direction&lt;/var&gt; 은 &lt;code&gt;&quot;first&quot;&lt;/code&gt; 또는 &lt;code&gt;&quot;last&quot;&lt;/code&gt; 중 하나 여야하며 각각 첫 번째 또는 마지막 &lt;var&gt;n&lt;/var&gt; 개의 인덱스 만 요청합니다 . 그러나 인덱스는 항상 오름차순으로 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="da870583c622099cfd3e98a6aaa9069c692eb905" translate="yes" xml:space="preserve">
          <source>If three output arguments are requested, also return the byte order of the current system as a character (&lt;code&gt;&quot;B&quot;&lt;/code&gt; for big-endian or &lt;code&gt;&quot;L&quot;&lt;/code&gt; for little-endian).</source>
          <target state="translated">세 개의 출력 인수가 요청 된 경우 현재 시스템의 바이트 순서도 문자로 리턴합니다 ( big-endian의 경우 &lt;code&gt;&quot;L&quot;&lt;/code&gt; &lt;code&gt;&quot;B&quot;&lt;/code&gt; , little-endian의 경우 &quot;L&quot; ).</target>
        </trans-unit>
        <trans-unit id="48d46c0188d92f3001cef77475a4e340a8993323" translate="yes" xml:space="preserve">
          <source>If three outputs are requested, &lt;code&gt;find&lt;/code&gt; also returns a vector containing the nonzero values. For example:</source>
          <target state="translated">세 개의 출력이 요청되면 &lt;code&gt;find&lt;/code&gt; 는 0이 아닌 값을 포함하는 벡터도 반환합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="058383942e2b38e4ea4b4f88f036a3f1ab9a3ff6" translate="yes" xml:space="preserve">
          <source>If tolerances are left unspecified, and any integration limits or waypoints are of type &lt;code&gt;single&lt;/code&gt;, then Octave&amp;rsquo;s integral functions automatically reduce the default absolute and relative error tolerances as specified above. If tighter tolerances are desired they must be specified. &lt;small&gt;MATLAB&lt;/small&gt; leaves the tighter tolerances appropriate for &lt;code&gt;double&lt;/code&gt; inputs in place regardless of the class of the integration limits.</source>
          <target state="translated">공차를 지정하지 않고 통합 한계 또는 웨이 포인트가 &lt;code&gt;single&lt;/code&gt; 유형 인 경우 Octave의 적분 함수는 위에 지정된 기본 절대 및 상대 오차 공차를 자동으로 줄입니다. 더 엄격한 공차가 필요한 경우 지정해야합니다. &lt;small&gt;MATLAB&lt;/small&gt; 은 통합 한계 등급에 관계없이 &lt;code&gt;double&lt;/code&gt; 입력에 적절한 공차를 유지 합니다.</target>
        </trans-unit>
        <trans-unit id="eabfaadf49b106def1643ee191ebcabee27697bc" translate="yes" xml:space="preserve">
          <source>If true, &lt;var&gt;err&lt;/var&gt; is zero, and &lt;var&gt;yi&lt;/var&gt; is a matrix of the common size with all entries equal to &lt;var&gt;xi&lt;/var&gt; if this is a scalar or &lt;var&gt;xi&lt;/var&gt; otherwise. If the inputs cannot be brought to a common size, &lt;var&gt;err&lt;/var&gt; is 1, and &lt;var&gt;yi&lt;/var&gt; is &lt;var&gt;xi&lt;/var&gt;. For example:</source>
          <target state="translated">참이면, &lt;var&gt;err&lt;/var&gt; 제로이고, &lt;var&gt;yi&lt;/var&gt; 모든 항목이 동일하여, 공통 크기의 행렬이다 &lt;var&gt;xi&lt;/var&gt; 이 스칼라 경우 또는 &lt;var&gt;xi&lt;/var&gt; 달리. 입력을 공통 크기로 가져올 수 없으면 &lt;var&gt;err&lt;/var&gt; 은 1이고 &lt;var&gt;yi&lt;/var&gt; 는 &lt;var&gt;xi&lt;/var&gt; 입니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f9ec57d4dc8511b5ecadf25bb12feed945ad5ef0" translate="yes" xml:space="preserve">
          <source>If true, Octave will attempt to eliminate the redundant copying when calling the &lt;code&gt;subsasgn&lt;/code&gt; method of a user-defined class.</source>
          <target state="translated">true 인 경우 Octave는 사용자 정의 클래스 의 &lt;code&gt;subsasgn&lt;/code&gt; 메소드를 호출 할 때 중복 복사를 제거하려고 시도합니다 .</target>
        </trans-unit>
        <trans-unit id="f16640c34ecf8b245b8604998f3c74c3290f3681" translate="yes" xml:space="preserve">
          <source>If true, any zeros on the diagonal of the upper triangular factor are replaced by the local drop tolerance &lt;code&gt;droptol * norm (&lt;var&gt;A&lt;/var&gt;(:,j))/&lt;var&gt;U&lt;/var&gt;(j,j)&lt;/code&gt;. The default is false.</source>
          <target state="translated">true 인 경우 상단 삼각 계수의 대각선에있는 0은 로컬 드롭 허용 오차 드롭 &lt;code&gt;droptol * norm (&lt;var&gt;A&lt;/var&gt;(:,j))/&lt;var&gt;U&lt;/var&gt;(j,j)&lt;/code&gt; 로 대체됩니다 . 기본값은 false입니다.</target>
        </trans-unit>
        <trans-unit id="801975db54cd048ff722cb67d19db3ac5cc387e2" translate="yes" xml:space="preserve">
          <source>If true, values of struct array elements are printed. This variable does not affect scalar structures whose elements are always printed. In both cases, however, printing will be limited to the number of levels specified by &lt;var&gt;struct_levels_to_print&lt;/var&gt;.</source>
          <target state="translated">참이면 구조 체형 배열 요소의 값이 인쇄됩니다. 이 변수는 요소가 항상 인쇄되는 스칼라 구조체에는 영향을 미치지 않습니다. 그러나 두 경우 모두 인쇄는 &lt;var&gt;struct_levels_to_print&lt;/var&gt; 로 지정된 레벨 수로 제한됩니다 .</target>
        </trans-unit>
        <trans-unit id="80e0838cdde564ba270fbe5d460d5eb115636d22" translate="yes" xml:space="preserve">
          <source>If two functions are passed as inputs then the parametric function</source>
          <target state="translated">두 함수가 입력으로 전달되면 파라 메트릭 함수</target>
        </trans-unit>
        <trans-unit id="39c7333e5efe6add8e1d8fe35f287c82367e4946" translate="yes" xml:space="preserve">
          <source>If two inputs and two outputs are given, return the derivative of the polynomial quotient &lt;em&gt;&lt;var&gt;b&lt;/var&gt;/&lt;var&gt;a&lt;/var&gt;&lt;/em&gt;. The quotient numerator is in &lt;var&gt;q&lt;/var&gt; and the denominator in &lt;var&gt;d&lt;/var&gt;.</source>
          <target state="translated">두 개의 입력과 두 개의 출력이 제공되면 다항식 몫 &lt;em&gt; &lt;var&gt;b&lt;/var&gt; / &lt;var&gt;a&lt;/var&gt; &lt;/em&gt; 의 도함수를 반환합니다 . 몫 분자는 &lt;var&gt;q&lt;/var&gt; 에 있고 분모는 &lt;var&gt;d&lt;/var&gt; 에 있습니다.</target>
        </trans-unit>
        <trans-unit id="30b646081bc588df157bad0704464b9b740fec3e" translate="yes" xml:space="preserve">
          <source>If two inputs are given, &lt;var&gt;n&lt;/var&gt; indicates the maximum number of elements to find from the beginning of the matrix or vector.</source>
          <target state="translated">두 개의 입력이 주어지면 &lt;var&gt;n&lt;/var&gt; 은 행렬 또는 벡터의 시작 부분에서 찾을 최대 요소 수를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="5b08d76f7d1a6230436da0ce445673da8b15bf20" translate="yes" xml:space="preserve">
          <source>If two inputs are scalar, then &lt;code&gt;betaincinv (&lt;var&gt;y&lt;/var&gt;, &lt;var&gt;a&lt;/var&gt;, &lt;var&gt;b&lt;/var&gt;)&lt;/code&gt; is returned for each of the other inputs.</source>
          <target state="translated">두 입력 값이 스칼라이면 &lt;code&gt;betaincinv (&lt;var&gt;y&lt;/var&gt;, &lt;var&gt;a&lt;/var&gt;, &lt;var&gt;b&lt;/var&gt;)&lt;/code&gt; 가 다른 입력 값 각각에 대해 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="5896945a598ce4fab831563dd3b6f3d2cb41e7af" translate="yes" xml:space="preserve">
          <source>If two or more inputs are not scalar, the sizes of them must agree, and &lt;code&gt;betaincinv&lt;/code&gt; is applied element-by-element.</source>
          <target state="translated">둘 이상의 입력이 스칼라가 아닌 경우 입력의 크기가 일치해야하며 &lt;code&gt;betaincinv&lt;/code&gt; 가 요소별로 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="4935cefb74e40396dd704e81c5489eee1a04b027" translate="yes" xml:space="preserve">
          <source>If two output arguments are requested &lt;code&gt;pkg&lt;/code&gt; splits the list of installed packages into those which were installed by the current user, and those which were installed by the system administrator.</source>
          <target state="translated">두 개의 출력 인수가 요청되면 &lt;code&gt;pkg&lt;/code&gt; 는 설치된 패키지 목록을 현재 사용자가 설치 한 패키지 목록과 시스템 관리자가 설치 한 패키지 목록으로 분할합니다.</target>
        </trans-unit>
        <trans-unit id="b8af71b48da54ec542f81704b73a226d63fba8e9" translate="yes" xml:space="preserve">
          <source>If two output arguments are requested then no plot is made and the polar vectors necessary to plot the histogram are returned instead.</source>
          <target state="translated">두 개의 출력 인수가 요청되면 플롯이 작성되지 않고 히스토그램을 플롯하는 데 필요한 극 벡터가 대신 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="95621c2391f0f67242ed6f5d54af1ee849be71b3" translate="yes" xml:space="preserve">
          <source>If two output arguments are requested, also return the maximum number of elements for an array. This will depend on whether Octave has been compiled with 32-bit or 64-bit index vectors.</source>
          <target state="translated">두 개의 출력 인수가 요청되면 배열의 최대 요소 수도 반환합니다. 이는 Octave가 32 비트 또는 64 비트 인덱스 벡터로 컴파일되었는지에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="b834b05d9da1556ddfc94b4a5c5bf8196b90fafc" translate="yes" xml:space="preserve">
          <source>If two output arguments are requested, return the factors &lt;var&gt;c&lt;/var&gt; and &lt;var&gt;s&lt;/var&gt; rather than the Givens rotation matrix.</source>
          <target state="translated">두 개의 출력 인수가 요청되면 Givens 회전 행렬 대신 인수 &lt;var&gt;c&lt;/var&gt; 와 &lt;var&gt;s&lt;/var&gt; 를 반환하십시오 .</target>
        </trans-unit>
        <trans-unit id="46403707491c2a3b7bea09da5631ae8e044883a9" translate="yes" xml:space="preserve">
          <source>If two output values are requested, &lt;code&gt;balance&lt;/code&gt; returns the diagonal &lt;var&gt;D&lt;/var&gt; and the permutation &lt;var&gt;P&lt;/var&gt; separately as vectors. In this case, &lt;code&gt;&lt;var&gt;DD&lt;/var&gt; = eye(n)(:,&lt;var&gt;P&lt;/var&gt;) * diag (&lt;var&gt;D&lt;/var&gt;)&lt;/code&gt;, where &lt;em&gt;n&lt;/em&gt; is the matrix size.</source>
          <target state="translated">두 개의 출력 값이 요청되면 &lt;code&gt;balance&lt;/code&gt; 는 대각선 &lt;var&gt;D&lt;/var&gt; 와 순열 &lt;var&gt;P&lt;/var&gt; 를 벡터로 개별적으로 반환합니다 . 이 경우 &lt;code&gt;&lt;var&gt;DD&lt;/var&gt; = eye(n)(:,&lt;var&gt;P&lt;/var&gt;) * diag (&lt;var&gt;D&lt;/var&gt;)&lt;/code&gt; . 여기서 &lt;em&gt;n&lt;/em&gt; 은 행렬 크기입니다.</target>
        </trans-unit>
        <trans-unit id="d0de166a4c8053019c852cca35cb637f8be814e4" translate="yes" xml:space="preserve">
          <source>If two output values&lt;var&gt;dpath&lt;/var&gt; and &lt;var&gt;spath&lt;/var&gt; are requested, the first variable will contain the dynamic classpath and the second will contain the static classpath.</source>
          <target state="translated">두 개의 출력 값 &lt;var&gt;dpath&lt;/var&gt; 및 &lt;var&gt;spath&lt;/var&gt; 가 요청되면 첫 번째 변수는 동적 클래스 경로를 포함하고 두 번째 변수는 정적 클래스 경로를 포함합니다.</target>
        </trans-unit>
        <trans-unit id="c25dedba663b562642dd37044e12992748dd97f3" translate="yes" xml:space="preserve">
          <source>If two outputs are requested, &lt;code&gt;find&lt;/code&gt; returns the row and column indices of nonzero elements of a matrix. For example:</source>
          <target state="translated">두 개의 출력이 요청되면 &lt;code&gt;find&lt;/code&gt; 는 행렬의 0이 아닌 요소의 행 및 열 인덱스를 반환합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="54cab2bec46bb21483ac1dbe03d2ca5edfc2b488" translate="yes" xml:space="preserve">
          <source>If unspecified &lt;var&gt;n&lt;/var&gt; defaults to 10 (+/- 5 lines)</source>
          <target state="translated">지정되지 않은 &lt;var&gt;n&lt;/var&gt; 의 기본값이 10 (+/- 5 줄) 인 경우</target>
        </trans-unit>
        <trans-unit id="efcb1fa169a7c1ebc16a6260124b98a399d10702" translate="yes" xml:space="preserve">
          <source>If unspecified the default is to link both X and Y axes.</source>
          <target state="translated">지정되지 않은 경우 기본값은 X 및 Y 축을 모두 연결하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="8d93f7f6f6aa1f43ebcfaf5557260b45c53c87c5" translate="yes" xml:space="preserve">
          <source>If unspecified, &lt;var&gt;filename&lt;/var&gt; is set to</source>
          <target state="translated">지정하지 않으면 &lt;var&gt;filename&lt;/var&gt; 은</target>
        </trans-unit>
        <trans-unit id="b91502153a86a59cb05591f1f8f7976625fd659d" translate="yes" xml:space="preserve">
          <source>If unspecified, &lt;var&gt;h&lt;/var&gt; is the current figure as returned by &lt;code&gt;gcf&lt;/code&gt;.</source>
          <target state="translated">지정되지 않은 경우, &lt;var&gt;h&lt;/var&gt; 에 의해 반환되는 현재의 모습입니다 &lt;code&gt;gcf&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="67ca7f1acd8a5a57a4d108e73df9de6cee45c260" translate="yes" xml:space="preserve">
          <source>If unspecified, &lt;var&gt;h&lt;/var&gt; is the current figure returned by &lt;code&gt;gcf&lt;/code&gt;.</source>
          <target state="translated">지정되지 않은 경우 &lt;var&gt;h&lt;/var&gt; 는 &lt;code&gt;gcf&lt;/code&gt; 가 반환 한 현재 그림 입니다.</target>
        </trans-unit>
        <trans-unit id="c4ce42e24e07694c2ccca601eacc303aaaaa8baf" translate="yes" xml:space="preserve">
          <source>If unspecified, the default tolerance is &lt;code&gt;1e-6 * norm (&lt;var&gt;x&lt;/var&gt;(:), 1)&lt;/code&gt;.</source>
          <target state="translated">지정되지 않은 경우 기본 공차는 &lt;code&gt;1e-6 * norm (&lt;var&gt;x&lt;/var&gt;(:), 1)&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="4f0fe8db916ebae817b62d032c210eb01f064662" translate="yes" xml:space="preserve">
          <source>If used on the left-hand side of an assignment, a comma separated list generated with &lt;code&gt;{}&lt;/code&gt; can be assigned to. An example is</source>
          <target state="translated">과제의 왼쪽에서 사용될 경우 &lt;code&gt;{}&lt;/code&gt; 로 생성 된 쉼표로 구분 된 목록을 할당 할 수 있습니다. 예를 들면</target>
        </trans-unit>
        <trans-unit id="089929cb87fbfc29c012d425dc15a1a9656fd689" translate="yes" xml:space="preserve">
          <source>If using the &lt;code&gt;&quot;Events&quot;&lt;/code&gt; option then three additional outputs may be returned. &lt;var&gt;te&lt;/var&gt; holds the time when an Event function returned a zero. &lt;var&gt;ye&lt;/var&gt; holds the value of the solution at time &lt;var&gt;te&lt;/var&gt;. &lt;var&gt;ie&lt;/var&gt; contains an index indicating which Event function was triggered in the case of multiple Event functions.</source>
          <target state="translated">&lt;code&gt;&quot;Events&quot;&lt;/code&gt; 옵션을 사용하면 세 개의 추가 출력이 리턴 될 수 있습니다. &lt;var&gt;te&lt;/var&gt; 는 Event 함수가 0을 반환 한 시간을 유지합니다. &lt;var&gt;ye&lt;/var&gt; 은 시간 &lt;var&gt;te&lt;/var&gt; 에서 솔루션의 가치를 유지합니다 . &lt;var&gt;ie&lt;/var&gt; , 여러 이벤트 기능의 경우 어떤 이벤트 기능이 트리거되었는지를 나타내는 인덱스를 포함합니다.</target>
        </trans-unit>
        <trans-unit id="ea54b39edc0dcd3dcc5c9315187de258eeab9dc9" translate="yes" xml:space="preserve">
          <source>If we execute the two main functions, we get:</source>
          <target state="translated">두 가지 주요 기능을 실행하면 다음과 같은 이점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="47149e4d371ecc1719b46d805214f06f707b705d" translate="yes" xml:space="preserve">
          <source>If we had written &lt;code&gt;avg&lt;/code&gt; like this instead,</source>
          <target state="translated">대신 이와 같이 &lt;code&gt;avg&lt;/code&gt; 을 쓴 경우</target>
        </trans-unit>
        <trans-unit id="30cf0ee8492509ff3a28adcbaa980355cec5a311" translate="yes" xml:space="preserve">
          <source>If we were to try to guess the arguments, we would probably guess wrong and then we would not encounter the bug.</source>
          <target state="translated">만약 우리가 논증을 추측하려고한다면, 우리는 아마 틀린 추측을하고 버그를 만나지 않을 것입니다.</target>
        </trans-unit>
        <trans-unit id="5dc5ff37fb688d6b3c43704cfbac355555b12d12" translate="yes" xml:space="preserve">
          <source>If you also want to read the saved history commands of past Octave sessions from this different history file, then you need to use the additional command &lt;code&gt;history -r&lt;/code&gt; after setting the new value of the history file. Example code in Octave&amp;rsquo;s startup file to do this might look like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="938c8b50389b72da90007f2fb2d8b86f887b22a6" translate="yes" xml:space="preserve">
          <source>If you are an experienced user of programs like Octave, your suggestions for improvement are welcome in any case.</source>
          <target state="translated">Octave와 같은 숙련 된 사용자라면 언제든지 개선 제안을 환영합니다.</target>
        </trans-unit>
        <trans-unit id="44a26e0b595b10c2628339cd33754afe94f3454a" translate="yes" xml:space="preserve">
          <source>If you are more interested in the CPU time that your process used, you should use the &lt;code&gt;cputime&lt;/code&gt; function instead. The &lt;code&gt;tic&lt;/code&gt; and &lt;code&gt;toc&lt;/code&gt; functions report the actual wall clock time that elapsed between the calls. This may include time spent processing other jobs or doing nothing at all.</source>
          <target state="translated">프로세스가 사용한 CPU 시간에 더 관심이 있다면, 대신 &lt;code&gt;cputime&lt;/code&gt; 함수를 사용해야합니다 . &lt;code&gt;tic&lt;/code&gt; 및 &lt;code&gt;toc&lt;/code&gt; 기능은 호출 사이에 경과 실제 벽시계 시간을보고합니다. 여기에는 다른 작업을 처리하거나 전혀 수행하지 않은 시간이 포함될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bc8c708b3ae3f4c2b2ee9366537576430c69fc28" translate="yes" xml:space="preserve">
          <source>If you are new to Octave, we recommend that you try these examples to begin learning Octave by using it. Lines marked like so, &amp;lsquo;</source>
          <target state="translated">Octave를 처음 사용하는 경우 다음 예제를 사용하여 Octave 학습을 시작하는 것이 좋습니다. 이렇게 표시된 줄은 '</target>
        </trans-unit>
        <trans-unit id="d487c30846b2cb6ef27493ad9f9cff24f9f0fa9b" translate="yes" xml:space="preserve">
          <source>If you are not sure whether you have found a bug, here are some guidelines:</source>
          <target state="translated">버그를 발견했는지 확실하지 않은 경우 다음 지침을 따르십시오.</target>
        </trans-unit>
        <trans-unit id="ce6bd5df5c3ddf429d78dc599deb390d4c707e71" translate="yes" xml:space="preserve">
          <source>If you are only interested in getting a literal string value, you can call &lt;code&gt;input&lt;/code&gt; with the character string &lt;code&gt;&quot;s&quot;&lt;/code&gt; as the second argument. This tells Octave to return the string entered by the user directly, without evaluating it first.</source>
          <target state="translated">리터럴 문자열 값만 가져 오려면 두 번째 인수로 문자열 &lt;code&gt;&quot;s&quot;&lt;/code&gt; 를 사용하여 &lt;code&gt;input&lt;/code&gt; 을 호출 할 수 있습니다 . 이를 통해 Octave는 사용자가 입력 한 문자열을 먼저 평가하지 않고 직접 반환하도록 지시합니다.</target>
        </trans-unit>
        <trans-unit id="4b81ee9484bb8f0da52106172dfc457e423a08d6" translate="yes" xml:space="preserve">
          <source>If you are using &lt;code&gt;eval&lt;/code&gt; merely as an exception handling mechanism, and not because you need to execute some arbitrary text, use the &lt;code&gt;try&lt;/code&gt; statement instead. See &lt;a href=&quot;the-try-statement#The-try-Statement&quot;&gt;The try Statement&lt;/a&gt;.</source>
          <target state="translated">당신이 사용하는 경우 &lt;code&gt;eval&lt;/code&gt; 처리 메커니즘을 예외로 단지, 당신은 어떤 임의의 텍스트를 실행해야하기 때문에하지의 사용 &lt;code&gt;try&lt;/code&gt; 대신 문을. &lt;a href=&quot;the-try-statement#The-try-Statement&quot;&gt;try 문을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="23b97f40ec2207a15b63261d75470bc74db38f7f" translate="yes" xml:space="preserve">
          <source>If you don&amp;rsquo;t follow these guidelines, your information might still be useful, but using it will take extra work. Maintaining Octave is a lot of work in the best of circumstances, and we can&amp;rsquo;t keep up unless you do your best to help.</source>
          <target state="translated">이 지침을 따르지 않으면 정보가 여전히 유용 할 수 있지만 사용하는 데 추가 작업이 필요합니다. Octave를 유지하는 것은 최상의 환경에서 많은 작업이며, 최선을 다하지 않으면 계속 유지할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="0cb3e07e68e43fe7cdca0bda4c82fe1f44bd9ebc" translate="yes" xml:space="preserve">
          <source>If you encounter errors like</source>
          <target state="translated">다음과 같은 오류가 발생하면</target>
        </trans-unit>
        <trans-unit id="15c0bf37c472b6714ed5979234819006d8b7cf41" translate="yes" xml:space="preserve">
          <source>If you encounter errors while compiling Octave, first see &lt;a href=&quot;installation-problems#Installation-Problems&quot;&gt;Installation Problems&lt;/a&gt; for a list of known problems and if there is a workaround or solution for your problem. If not, see &lt;a href=&quot;trouble#Trouble&quot;&gt;Trouble&lt;/a&gt; for information about how to report bugs.</source>
          <target state="translated">Octave를 컴파일하는 동안 오류가 발생하면 먼저 알려진 문제 목록과 문제에 대한 해결 방법 또는 솔루션이 있는지 &lt;a href=&quot;installation-problems#Installation-Problems&quot;&gt;설치 문제&lt;/a&gt; 를 참조하십시오 . 그렇지 않은 경우 버그보고 방법에 대한 정보는 &lt;a href=&quot;trouble#Trouble&quot;&gt;문제점&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="2c83a744aa1ef52bf86a67ac1f4dae38adbc1ed6" translate="yes" xml:space="preserve">
          <source>If you get into trouble, you can usually interrupt Octave by typing</source>
          <target state="translated">문제가 발생하면 일반적으로 다음을 입력하여 옥타브를 중단 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="72a8d1763f7abb92b22e4424137c00cafec8b945" translate="yes" xml:space="preserve">
          <source>If you have GNU diff, use &amp;lsquo;</source>
          <target state="translated">GNU diff가 있다면 '</target>
        </trans-unit>
        <trans-unit id="d4b243f87e29acdd5b4584b57a3f6020bc1f259f" translate="yes" xml:space="preserve">
          <source>If you know that the solutions to your equations will always be non-negative, it may help to set this parameter to a nonzero value. However, it is probably best to try leaving this option set to zero first, and only setting it to a nonzero value if that doesn&amp;rsquo;t work very well.</source>
          <target state="translated">방정식에 대한 해가 항상 음수가 아닌 것을 알고 있으면이 매개 변수를 0이 아닌 값으로 설정하는 것이 도움이 될 수 있습니다. 그러나이 옵션을 먼저 0으로 설정하고 제대로 작동하지 않는 경우에만 0이 아닌 값으로 설정하는 것이 가장 좋습니다.</target>
        </trans-unit>
        <trans-unit id="4a1179d455b08d9b73851996d8958e287eee1dda" translate="yes" xml:space="preserve">
          <source>If you know that your own function files will not change while you are running Octave, you can improve performance by calling &lt;code&gt;ignore_function_time_stamp (&quot;all&quot;)&lt;/code&gt;, so that Octave will ignore the time stamps for all function files. Passing &lt;code&gt;&quot;system&quot;&lt;/code&gt; to this function resets the default behavior.</source>
          <target state="translated">Octave를 실행하는 동안 자신의 함수 파일이 변경되지 않는다는 것을 알면 &lt;code&gt;ignore_function_time_stamp (&quot;all&quot;)&lt;/code&gt; 를 호출 하여 Octave가 모든 함수 파일의 타임 스탬프를 무시하도록 성능을 향상시킬 수 있습니다. 이 기능에 &lt;code&gt;&quot;system&quot;&lt;/code&gt; 을 전달 하면 기본 동작이 재설정됩니다.</target>
        </trans-unit>
        <trans-unit id="773e06c5d71bd61af5bb91daebb02dda4d3b9645" translate="yes" xml:space="preserve">
          <source>If you make two changes for separate reasons, then we might not want to install them both. We might want to install just one.</source>
          <target state="translated">별도의 이유로 두 가지 변경을하는 경우 두 가지를 모두 설치하지 않을 수 있습니다. 하나만 설치하고 싶을 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="8ebaf462f2ba288f59ad4e1233a44f1081fa7278" translate="yes" xml:space="preserve">
          <source>If you need more detailed control, see &lt;a href=&quot;graphics-data-structures#Graphics-Data-Structures&quot;&gt;Graphics Data Structures&lt;/a&gt; and &lt;a href=&quot;advanced-plotting#Advanced-Plotting&quot;&gt;Advanced Plotting&lt;/a&gt;.</source>
          <target state="translated">더 자세한 제어가 필요한 경우 &lt;a href=&quot;graphics-data-structures#Graphics-Data-Structures&quot;&gt;그래픽 데이터 구조&lt;/a&gt; 및 &lt;a href=&quot;advanced-plotting#Advanced-Plotting&quot;&gt;고급 플로팅을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="5b19817bba0d43cf4088a4a796a1e69b546c34d9" translate="yes" xml:space="preserve">
          <source>If you plan to modify the parser you will also need GNU &lt;code&gt;bison&lt;/code&gt; and &lt;code&gt;flex&lt;/code&gt;. If you modify the documentation, you will need GNU Texinfo.</source>
          <target state="translated">파서를 수정하려는 경우 GNU &lt;code&gt;bison&lt;/code&gt; 및 &lt;code&gt;flex&lt;/code&gt; 도 필요합니다 . 문서를 수정하면 GNU Texinfo가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="b3251696f963b5c4b0bff3c5795fa3403db135a1" translate="yes" xml:space="preserve">
          <source>If you start Octave in your home directory, commands from the file</source>
          <target state="translated">홈 디렉토리에서 Octave를 시작하면 파일의 명령</target>
        </trans-unit>
        <trans-unit id="e95a884f71280b0f43e4f02547af313bf9d64adb" translate="yes" xml:space="preserve">
          <source>If you think you have found a bug in Octave or in the installation procedure, however, you should submit a complete bug report to the Octave bug tracker at &lt;a href=&quot;https://bugs.octave.org&quot;&gt;https://bugs.octave.org&lt;/a&gt;. But before you submit a bug report, please read &lt;a href=&quot;https://www.octave.org/bugs.html&quot;&gt;https://www.octave.org/bugs.html&lt;/a&gt; to learn how to submit a useful bug report.</source>
          <target state="translated">그러나 Octave 또는 설치 절차에서 버그를 발견했다고 생각되면 &lt;a href=&quot;https://bugs.octave.org&quot;&gt;https://bugs.octave.org&lt;/a&gt; 의 Octave 버그 추적기에 전체 버그 보고서를 제출해야합니다 . 그러나 버그 보고서를 제출하기 전에 &lt;a href=&quot;https://www.octave.org/bugs.html&quot;&gt;https://www.octave.org/bugs.html&lt;/a&gt; 을 읽고 유용한 버그 보고서를 제출하는 방법을 알아보십시오.</target>
        </trans-unit>
        <trans-unit id="7abfea9c6cccfd3ce74397d16cbb290ac84ffe02" translate="yes" xml:space="preserve">
          <source>If you try this, you will see that the value of the result changes dramatically between &lt;var&gt;t&lt;/var&gt; = 0 and 5, and again around &lt;var&gt;t&lt;/var&gt; = 305. A more efficient set of output points might be</source>
          <target state="translated">이 작업을 시도하면 결과 값이 &lt;var&gt;t&lt;/var&gt; = 0에서 5 사이 에서 &lt;var&gt;t&lt;/var&gt; = 305에서 크게 변하는 것을 볼 수 있습니다.보다 효율적인 출력 지점 세트는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="098bfb215adb07508bf12635e7acfe96b2b16deb" translate="yes" xml:space="preserve">
          <source>If you want to create a struct which contains a cell array as an individual field, you must wrap it in another cell array as shown in the following example:</source>
          <target state="translated">셀형 배열을 개별 필드로 포함하는 구조체를 만들려면 다음 예제와 같이 다른 셀형 배열로 래핑해야합니다.</target>
        </trans-unit>
        <trans-unit id="1ea727798d3fc86edb60b05fe18dacf52d1f8336" translate="yes" xml:space="preserve">
          <source>If you want to permanently change the location of Octave&amp;rsquo;s history file you need to issue the &lt;code&gt;history_file&lt;/code&gt; command in every new Octave session. This can be achieved by using Octave&amp;rsquo;s</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc19241496699086c1cdf929e7aebdbad68d7efb" translate="yes" xml:space="preserve">
          <source>If you want to temporarily disable a test block, put &lt;code&gt;#&lt;/code&gt; in place of the block type. This creates a comment block which is echoed in the log file but not executed. For example:</source>
          <target state="translated">테스트 블록을 일시적으로 비활성화 하려면 블록 유형 대신 &lt;code&gt;#&lt;/code&gt; 을 넣으십시오 . 이것은 주석 파일을 생성하고 로그 파일에는 반영되지만 실행되지는 않습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="24aa0dc8e13859884021a5d5bcd6c5c7a469a952" translate="yes" xml:space="preserve">
          <source>If you wish the points that are outside the tessellation to be flagged, then &lt;code&gt;dsearchn&lt;/code&gt; can be used as</source>
          <target state="translated">테셀레이션 외부에있는 점에 플래그를 지정하려면 &lt;code&gt;dsearchn&lt;/code&gt; 을 다음 과 같이 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="69b2becbdf6968d88df5a463ad29a090517efd28" translate="yes" xml:space="preserve">
          <source>If you wish to build Octave without GNU readline installed, you must use the</source>
          <target state="translated">GNU readline을 설치하지 않고 Octave를 빌드하려면</target>
        </trans-unit>
        <trans-unit id="247c1dedc5bbc103fbcf5e4d3a0d6912c19a01f5" translate="yes" xml:space="preserve">
          <source>If you wish to check if a variable exists at all, instead of properties its elements may have, consult &lt;a href=&quot;status-of-variables#Status-of-Variables&quot;&gt;Status of Variables&lt;/a&gt;.</source>
          <target state="translated">변수가 존재하는지 여부를 확인하려면 해당 요소의 특성 대신 &lt;a href=&quot;status-of-variables#Status-of-Variables&quot;&gt;변수 상태를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="cc39ee97be38e0111bc03570fbad091c41c76924" translate="yes" xml:space="preserve">
          <source>If you wish to refer to a function that users might expect to find in your package but is not there, providing a work around or pointing out that the function is available elsewhere, you can use:</source>
          <target state="translated">사용자가 패키지에서 찾을 것으로 예상하지만 존재하지 않는 기능을 참조하려는 경우, 해결 방법을 제공하거나 다른 곳에서 해당 기능을 사용할 수 있다고 지적하면 다음을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fed1ab9496f68ac0502804bcbdfda4bbfacfe4b5" translate="yes" xml:space="preserve">
          <source>If you wish to suggest changes to the Octave source, send them as context diffs. If you even discuss something in the Octave source, refer to it by context, not by line number, because the line numbers in the development sources probably won&amp;rsquo;t match those in your sources.</source>
          <target state="translated">옥타브 소스에 대한 변경 사항을 제안하려면 컨텍스트 차이로 보내십시오. Octave 소스에서 무언가를 논의하는 경우 개발 소스의 라인 번호가 소스의 라인 번호와 일치하지 않으므로 라인 번호가 아닌 컨텍스트별로 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="5c8e38015b5493fba0be84dabcd0500f95323fcd" translate="yes" xml:space="preserve">
          <source>If you wish to use the &lt;code&gt;end&lt;/code&gt; keyword in subscripted expressions of an object, then there must be an &lt;code&gt;end&lt;/code&gt; method defined. For example, the &lt;code&gt;end&lt;/code&gt; method for the polynomial class might look like</source>
          <target state="translated">오브젝트의 첨자 표현식에 &lt;code&gt;end&lt;/code&gt; 키워드 를 사용하려면 &lt;code&gt;end&lt;/code&gt; 메소드가 정의 되어 있어야합니다 . 예를 들어 다항식 클래스 의 &lt;code&gt;end&lt;/code&gt; 메소드는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a9592c1f70b09988164d97be51b56be13c526cdf" translate="yes" xml:space="preserve">
          <source>If you would like to write bug fixes or improvements for Octave, that is very helpful. When you send your changes, please follow these guidelines to avoid causing extra work for us in studying the patches.</source>
          <target state="translated">Octave에 대한 버그 수정 또는 개선 사항을 작성하려면 매우 유용합니다. 변경 사항을 보낼 때 패치를 연구하는 데 추가 작업이 발생하지 않도록이 지침을 따르십시오.</target>
        </trans-unit>
        <trans-unit id="78b996541d66ef6c9a6a21de09498e5de337eeb0" translate="yes" xml:space="preserve">
          <source>If you would like your name to appear in the header line for who made the change, send us the header line.</source>
          <target state="translated">누가 변경을했는지 헤더 행에 이름을 표시하려면 헤더 행을 보내주십시오.</target>
        </trans-unit>
        <trans-unit id="14503dc619a82c817fe6376a4747cff7ee2bda76" translate="yes" xml:space="preserve">
          <source>If you write an executable Octave script, &lt;code&gt;argv&lt;/code&gt; will return the list of arguments passed to the script. See &lt;a href=&quot;executable-octave-programs#Executable-Octave-Programs&quot;&gt;Executable Octave Programs&lt;/a&gt;, for an example of how to create an executable Octave script.</source>
          <target state="translated">실행 가능한 Octave 스크립트를 작성하면 &lt;code&gt;argv&lt;/code&gt; 는 스크립트에 전달 된 인수 목록을 반환합니다. 실행 가능한 Octave 스크립트를 작성하는 방법에 대한 예제는 &lt;a href=&quot;executable-octave-programs#Executable-Octave-Programs&quot;&gt;실행 가능한 Octave 프로그램을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e01074f3b36de511c7b671c2a718b455fc238580" translate="yes" xml:space="preserve">
          <source>If your application requires a large amount of memory from the beginning, you can also specify the initial amount of memory allocated to the JVM. Adding the following line to the</source>
          <target state="translated">애플리케이션에 처음부터 많은 양의 메모리가 필요한 경우 JVM에 할당 된 초기 메모리 양을 지정할 수도 있습니다. 에 다음 줄 추가</target>
        </trans-unit>
        <trans-unit id="0be2535b873f82857d666ae855201a629cacdaf7" translate="yes" xml:space="preserve">
          <source>If your system actually does support IEEE arithmetic, you should be able to fix this problem by modifying the function &lt;code&gt;octave_ieee_init&lt;/code&gt; in the file</source>
          <target state="translated">시스템이 실제로 IEEE 산술을 지원 하는 경우 파일에서 &lt;code&gt;octave_ieee_init&lt;/code&gt; 함수를 수정하여이 문제를 해결할 수 있어야 합니다.</target>
        </trans-unit>
        <trans-unit id="4ecb50aa9fb1ad688a5992a198e5d350a4da881b" translate="yes" xml:space="preserve">
          <source>If your system does not have a way to report CPU time usage, &lt;code&gt;cputime&lt;/code&gt; returns 0 for each of its output values.</source>
          <target state="translated">시스템에 CPU 시간 사용량을보고 할 방법이 없으면 &lt;code&gt;cputime&lt;/code&gt; 은 각 출력 값에 대해 0을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="2ee90caee7c07d6b11cdc7f98eaa50acf3575c04" translate="yes" xml:space="preserve">
          <source>If your system does not support IEEE arithmetic but Octave&amp;rsquo;s configure script incorrectly determined that it does, you can work around the problem by editing the file</source>
          <target state="translated">시스템에서 IEEE 산술을 지원하지 않지만 Octave의 구성 스크립트에서 지원하지 않는 것으로 판단한 경우 파일을 편집하여 문제를 해결할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2cc9a772bac1724d1394f150f80f85e0e292abbf" translate="yes" xml:space="preserve">
          <source>Ignore case when matching the pattern to the string.</source>
          <target state="translated">패턴을 문자열과 일치시킬 때는 대소 문자를 무시하십시오.</target>
        </trans-unit>
        <trans-unit id="a21344d93a6ebe7aacaf53da51184ce33b10744c" translate="yes" xml:space="preserve">
          <source>Ignoring Arguments</source>
          <target state="translated">인수 무시</target>
        </trans-unit>
        <trans-unit id="38b0381739fb0deecc26d8017f7f4b471ae496e2" translate="yes" xml:space="preserve">
          <source>Ill-conditioned matrix.</source>
          <target state="translated">조건부 매트릭스.</target>
        </trans-unit>
        <trans-unit id="e18bb0936914a1f7baa963963dcd3545254c6666" translate="yes" xml:space="preserve">
          <source>Image Processing</source>
          <target state="translated">이미지 처리</target>
        </trans-unit>
        <trans-unit id="70dd8abbad607739746fcf17bb0dd857c339c67b" translate="yes" xml:space="preserve">
          <source>Image Properties</source>
          <target state="translated">이미지 속성</target>
        </trans-unit>
        <trans-unit id="eedc4f75d0a3e64eefa7b4bd05374e21dc121331" translate="yes" xml:space="preserve">
          <source>Image Width in pixels.</source>
          <target state="translated">이미지 너비 (픽셀)입니다.</target>
        </trans-unit>
        <trans-unit id="0737ffad6130e268a0f55e7841e8e03f4f9a922e" translate="yes" xml:space="preserve">
          <source>Image comment.</source>
          <target state="translated">이미지 설명.</target>
        </trans-unit>
        <trans-unit id="2fd90764d79c65e072fa421bed30b86a49a3d74f" translate="yes" xml:space="preserve">
          <source>Image file</source>
          <target state="translated">이미지 파일</target>
        </trans-unit>
        <trans-unit id="735fe112afc92cdfad799df9aea4c168a875c53c" translate="yes" xml:space="preserve">
          <source>Image files that are distributed with Octave.</source>
          <target state="translated">Octave와 함께 배포되는 이미지 파일.</target>
        </trans-unit>
        <trans-unit id="ae1166f22aa26916268b0e7fd16a8afd063ec25e" translate="yes" xml:space="preserve">
          <source>Image format (e.g., &lt;code&gt;&quot;jpeg&quot;&lt;/code&gt;).</source>
          <target state="translated">이미지 형식 (예 : &lt;code&gt;&quot;jpeg&quot;&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="ff3dd6c7afcbe158b0468d5a6e8bd165cb04723f" translate="yes" xml:space="preserve">
          <source>Image height in pixels.</source>
          <target state="translated">이미지 높이 (픽셀)입니다.</target>
        </trans-unit>
        <trans-unit id="30bd186057f8a353cb4d5eeb2070ac9d226dd5c4" translate="yes" xml:space="preserve">
          <source>Image processing library (&lt;a href=&quot;http://www.graphicsmagick.org&quot;&gt;http://www.graphicsmagick.org&lt;/a&gt;). GraphicsMagick++ is used to provide the &lt;code&gt;imread&lt;/code&gt; and &lt;code&gt;imwrite&lt;/code&gt; functions.</source>
          <target state="translated">이미지 처리 라이브러리 ( &lt;a href=&quot;http://www.graphicsmagick.org&quot;&gt;http://www.graphicsmagick.org&lt;/a&gt; ) GraphicsMagick ++는 &lt;code&gt;imread&lt;/code&gt; 및 &lt;code&gt;imwrite&lt;/code&gt; 기능 을 제공하는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="6440f7112fff54b1cbf176318ed2602f9598cebc" translate="yes" xml:space="preserve">
          <source>Image processing tools. These functions require the X Window System.</source>
          <target state="translated">이미지 처리 도구. 이러한 기능에는 X 윈도우 시스템이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="4f5418da9102c5693aad9d21e0f27946df8447be" translate="yes" xml:space="preserve">
          <source>Image type. Value is &lt;code&gt;&quot;grayscale&quot;&lt;/code&gt;, &lt;code&gt;&quot;indexed&quot;&lt;/code&gt;, &lt;code&gt;&quot;truecolor&quot;&lt;/code&gt;, &lt;code&gt;&quot;CMYK&quot;&lt;/code&gt;, or &lt;code&gt;&quot;undefined&quot;&lt;/code&gt;.</source>
          <target state="translated">이미지 타입. 값은 &lt;code&gt;&quot;grayscale&quot;&lt;/code&gt; , &lt;code&gt;&quot;indexed&quot;&lt;/code&gt; , &lt;code&gt;&quot;truecolor&quot;&lt;/code&gt; , &lt;code&gt;&quot;CMYK&quot;&lt;/code&gt; 또는 &lt;code&gt;&quot;undefined&quot;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="ed6ce473b435881c7082c80a0d76f4575c5215cc" translate="yes" xml:space="preserve">
          <source>ImageDescription</source>
          <target state="translated">ImageDescription</target>
        </trans-unit>
        <trans-unit id="1db2d4e16d01a258e928546ee56a0191085c879e" translate="yes" xml:space="preserve">
          <source>Implementation Details:</source>
          <target state="translated">구현 세부 사항 :</target>
        </trans-unit>
        <trans-unit id="909e7b9e3b01690245cc4529c3a073eea2ed283f" translate="yes" xml:space="preserve">
          <source>Implementation Note: &lt;code&gt;close&lt;/code&gt; operates by making the handle &lt;var&gt;h&lt;/var&gt; the current figure, and then calling the function specified by the &lt;code&gt;&quot;closerequestfcn&quot;&lt;/code&gt; property of the figure. By default, the function &lt;code&gt;closereq&lt;/code&gt; is used. It is possible that the function invoked will delay or abort removing the figure. To remove a figure without executing any callback functions use &lt;code&gt;delete&lt;/code&gt;. When writing a callback function to close a window do not use &lt;code&gt;close&lt;/code&gt; to avoid recursion.</source>
          <target state="translated">구현 참고 : &lt;code&gt;close&lt;/code&gt; 는 핸들 &lt;var&gt;h&lt;/var&gt; 를 현재 Figure로 만든 다음 Figure의 &lt;code&gt;&quot;closerequestfcn&quot;&lt;/code&gt; 속성으로 지정된 함수를 호출하여 작동합니다 . 기본적으로 &lt;code&gt;closereq&lt;/code&gt; 함수 가 사용됩니다. 호출 된 함수가 그림 제거를 지연 시키거나 중단시킬 수 있습니다. 콜백 함수를 실행하지 않고 그림을 제거하려면 &lt;code&gt;delete&lt;/code&gt; 를 사용하십시오 . 창을 닫기 위해 콜백 함수를 작성할 때 재귀를 피하기 위해 &lt;code&gt;close&lt;/code&gt; 를 사용하지 마십시오 .</target>
        </trans-unit>
        <trans-unit id="303a442bf2a5a804909d963c347a0f470271f462" translate="yes" xml:space="preserve">
          <source>Implementation Note: &lt;code&gt;ginput&lt;/code&gt; is intenteded for 2-D plots. For 3-D plots see the &lt;var&gt;currentpoint&lt;/var&gt; property of the current axes which can be transformed with knowledge of the current &lt;code&gt;view&lt;/code&gt; into data units.</source>
          <target state="translated">구현 참고 사항 : &lt;code&gt;ginput&lt;/code&gt; 은 2 차원 플롯을위한 것입니다. 3 차원 플롯 의 경우 현재 &lt;code&gt;view&lt;/code&gt; 지식 으로 데이터 단위로 변환 할 수있는 현재 축의 &lt;var&gt;currentpoint&lt;/var&gt; 속성을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ce262fc9c7e92106a1470d0df6ee9d604511d9b4" translate="yes" xml:space="preserve">
          <source>Implementation Note: &lt;code&gt;randi&lt;/code&gt; relies internally on &lt;code&gt;rand&lt;/code&gt; which uses class &lt;code&gt;&quot;double&quot;&lt;/code&gt; to represent numbers. This limits the maximum integer (&lt;var&gt;imax&lt;/var&gt;) and range (&lt;var&gt;imax&lt;/var&gt; - &lt;var&gt;imin&lt;/var&gt;) to the value returned by the &lt;code&gt;flintmax&lt;/code&gt; function. For IEEE floating point numbers this value is &lt;em&gt;2^{53} - 1&lt;/em&gt;.</source>
          <target state="translated">구현 참고 사항 : &lt;code&gt;randi&lt;/code&gt; 는 내부적으로 &lt;code&gt;rand&lt;/code&gt; 에 의존 하여 숫자를 나타 내기 위해 &lt;code&gt;&quot;double&quot;&lt;/code&gt; 클래스를 사용 합니다. 그러면 최대 정수 ( &lt;var&gt;imax&lt;/var&gt; ) 및 범위 ( &lt;var&gt;imax&lt;/var&gt; - &lt;var&gt;imin&lt;/var&gt; )가 &lt;code&gt;flintmax&lt;/code&gt; 함수에 의해 반환되는 값으로 제한 됩니다. IEEE 부동 소수점 숫자의 경우이 값은 &lt;em&gt;2 ^ {53}-1&lt;/em&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="8439e1cb68b989dee4226e1b4ec1a6a86d547fee" translate="yes" xml:space="preserve">
          <source>Implementation Note: A colorbar is created as an additional axes object with the &lt;code&gt;&quot;tag&quot;&lt;/code&gt; property set to &lt;code&gt;&quot;colorbar&quot;&lt;/code&gt;. The created object has the extra property &lt;code&gt;&quot;location&quot;&lt;/code&gt; which controls the positioning of the colorbar.</source>
          <target state="translated">구현 참고 사항 : 컬러 &lt;code&gt;&quot;tag&quot;&lt;/code&gt; 는 &quot;tag&quot; 속성이 &lt;code&gt;&quot;colorbar&quot;&lt;/code&gt; 로 설정된 추가 좌표축 객체로 생성됩니다 . 생성 된 객체에는 컬러 바의 위치를 ​​제어하는 추가 속성 &lt;code&gt;&quot;location&quot;&lt;/code&gt; 이 있습니다.</target>
        </trans-unit>
        <trans-unit id="6f235239ac37a9f4df7f881a391c56fbe603efda" translate="yes" xml:space="preserve">
          <source>Implementation Note: Color definitions with RGB-triples are not valid.</source>
          <target state="translated">구현 참고 사항 : RGB 3 색을 사용한 색상 정의는 유효하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="118b06847df4e87adcd97d7158907f6dbe56993b" translate="yes" xml:space="preserve">
          <source>Implementation Note: For Octave versions &amp;le; 4.2, &lt;code&gt;quadcc&lt;/code&gt; accepted a single tolerance argument which specified the relative tolerance. For versions 4.4 and 5, &lt;code&gt;quadcc&lt;/code&gt; will issue a warning when called with a single tolerance argument indicating that the meaning of this input has changed from relative tolerance to absolute tolerance. The warning ID for this message is &lt;code&gt;&quot;Octave:quadcc:RelTol-conversion&quot;&lt;/code&gt;. The warning may be disabled with &lt;code&gt;warning (&quot;off&quot;, &quot;Octave:quadcc:RelTol-conversion&quot;)&lt;/code&gt;.</source>
          <target state="translated">구현 참고 : Octave 버전 &amp;le; 4.2의 경우 &lt;code&gt;quadcc&lt;/code&gt; 는 상대 허용 오차를 지정하는 단일 허용 오차 인수를 허용했습니다. 버전 4.4 및 5의 경우 &lt;code&gt;quadcc&lt;/code&gt; 는 단일 공차 인수와 함께 호출 될 때이 입력의 의미가 상대 공차에서 절대 공차로 변경되었음을 나타내는 경고를 발행합니다. 이 메시지의 경고 ID는 &lt;code&gt;&quot;Octave:quadcc:RelTol-conversion&quot;&lt;/code&gt; 입니다. 경고와 함께 &lt;code&gt;warning (&quot;off&quot;, &quot;Octave:quadcc:RelTol-conversion&quot;)&lt;/code&gt; 비활성화 할 수 있습니다 ( &quot;off&quot;, &quot;Octave : quadcc : RelTol-conversion&quot;) .</target>
        </trans-unit>
        <trans-unit id="1c627e763b597b9f40da472ffd9698a95158f13c" translate="yes" xml:space="preserve">
          <source>Implementation Note: For compatibility with &lt;small&gt;MATLAB&lt;/small&gt;, escape sequences in &lt;var&gt;pat&lt;/var&gt; (e.g., &lt;code&gt;&quot;\n&quot;&lt;/code&gt; =&amp;gt; newline) are expanded even when &lt;var&gt;pat&lt;/var&gt; has been defined with single quotes. To disable expansion use a second backslash before the escape sequence (e.g., &quot;\\n&quot;) or use the &lt;code&gt;regexptranslate&lt;/code&gt; function.</source>
          <target state="translated">구현 참고 : &lt;small&gt;MATLAB&lt;/small&gt; 과의 호환성을 위해 &lt;var&gt;pat&lt;/var&gt; 이 작은 따옴표로 정의 된 경우에도 &lt;var&gt;pat&lt;/var&gt; 의 이스케이프 시퀀스 (예 : &lt;code&gt;&quot;\n&quot;&lt;/code&gt; =&amp;gt; 줄 바꿈)가 확장됩니다 . 확장을 비활성화하려면 이스케이프 시퀀스 앞에 두 번째 백 슬래시 (예 : &quot;\\ n&quot;)를 사용하거나 &lt;code&gt;regexptranslate&lt;/code&gt; 함수를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="bb733da171cb7a13259b1444879a14fb91d08f67" translate="yes" xml:space="preserve">
          <source>Implementation Note: For compatibility with &lt;small&gt;MATLAB&lt;/small&gt;, escape sequences in &lt;var&gt;template&lt;/var&gt; (e.g., &lt;code&gt;&quot;\n&quot;&lt;/code&gt; =&amp;gt; newline) are processed regardless of whether &lt;var&gt;template&lt;/var&gt; has been defined with single quotes, as long as there are two or more input arguments. To disable escape sequence expansion use a second backslash before the sequence (e.g., &lt;code&gt;&quot;\\n&quot;&lt;/code&gt;) or use the &lt;code&gt;regexptranslate&lt;/code&gt; function.</source>
          <target state="translated">구현 참고 사항 : &lt;small&gt;MATLAB&lt;/small&gt; 과의 호환성을 위해 두 개 이상의 입력 인수가 있는 한 &lt;var&gt;template&lt;/var&gt; 이스케이프 시퀀스 (예 : &lt;code&gt;&quot;\n&quot;&lt;/code&gt; =&amp;gt; 개행)는 작은 따옴표로 &lt;var&gt;template&lt;/var&gt; 이 정의 되었는지 여부에 관계없이 처리됩니다 . 이스케이프 시퀀스 확장을 비활성화하려면 시퀀스 앞에 두 번째 백 슬래시 (예 : &lt;code&gt;&quot;\\n&quot;&lt;/code&gt; )를 사용하거나 &lt;code&gt;regexptranslate&lt;/code&gt; 함수를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="0b0e299230f177daf8a27deee59ff922df14990d" translate="yes" xml:space="preserve">
          <source>Implementation Note: For compatibility with &lt;small&gt;MATLAB&lt;/small&gt;, escape sequences in the template string (e.g., &lt;code&gt;&quot;\n&quot;&lt;/code&gt; =&amp;gt; newline) are expanded even when the template string is defined with single quotes.</source>
          <target state="translated">구현 노트 : &lt;small&gt;MATLAB&lt;/small&gt; 과의 호환성을 위해 템플릿 문자열이 작은 따옴표로 정의 된 경우에도 템플릿 문자열의 이스케이프 시퀀스 (예 : &lt;code&gt;&quot;\n&quot;&lt;/code&gt; =&amp;gt; 줄 바꿈)가 확장됩니다.</target>
        </trans-unit>
        <trans-unit id="f06bbe9d37b5e9554faba6969d1760ac2b285078" translate="yes" xml:space="preserve">
          <source>Implementation Note: If &lt;var&gt;script&lt;/var&gt; includes a path component, then &lt;code&gt;run&lt;/code&gt; first changes the working directory to the directory where &lt;var&gt;script&lt;/var&gt; is found. Next, the script is executed. Finally, &lt;code&gt;run&lt;/code&gt; returns to the original working directory &lt;em&gt;unless&lt;/em&gt;&lt;var&gt;script&lt;/var&gt; has specifically changed directories.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d77321cc3eab07d020759da34c3c653744793c9" translate="yes" xml:space="preserve">
          <source>Implementation Note: If &lt;var&gt;script&lt;/var&gt; includes a path component, then &lt;code&gt;run&lt;/code&gt; first changes the working directory to the directory where &lt;var&gt;script&lt;/var&gt; is found. Next, the script is executed. Finally, &lt;code&gt;run&lt;/code&gt; returns to the original working directory unless &lt;var&gt;script&lt;/var&gt; has specifically changed directories.</source>
          <target state="translated">구현 참고 : &lt;var&gt;script&lt;/var&gt; 에 경로 구성 요소가 포함 된 경우 , 먼저 &lt;code&gt;run&lt;/code&gt; 하면 작업 디렉토리를 &lt;var&gt;script&lt;/var&gt; 가 있는 디렉토리로 변경합니다 . 다음으로 스크립트가 실행됩니다. 마지막으로, &lt;var&gt;script&lt;/var&gt; 가 디렉토리를 특별히 변경 하지 않은 경우 &lt;code&gt;run&lt;/code&gt; 은 원래 작업 디렉토리로 돌아갑니다 .</target>
        </trans-unit>
        <trans-unit id="202bc6c5859637a76bb36326e2191181c8a97445" translate="yes" xml:space="preserve">
          <source>Implementation Note: Strings are first converted to double values before the checks for valid indices are made. Unless a string contains the NULL character &quot;\0&quot;, it will always be a valid index.</source>
          <target state="translated">구현 참고 사항 : 유효한 인덱스를 확인하기 전에 문자열이 먼저 이중 값으로 변환됩니다. 문자열에 NULL 문자 &quot;\ 0&quot;이 포함되어 있지 않으면 항상 유효한 인덱스가됩니다.</target>
        </trans-unit>
        <trans-unit id="b1825df68ad6e3cb77fbecc7e4564c322b59fc27" translate="yes" xml:space="preserve">
          <source>Implementation Note: The grayscale intensity is calculated as</source>
          <target state="translated">구현 참고 사항 : 회색조 강도는 다음과 같이 계산됩니다.</target>
        </trans-unit>
        <trans-unit id="c5fe5297fe400cfce0ede8fd4b3eaf996b960e5e" translate="yes" xml:space="preserve">
          <source>Implementation Note: The input &lt;var&gt;q&lt;/var&gt; must be less than &lt;code&gt;flintmax&lt;/code&gt; (9.0072e+15) in order to factor correctly.</source>
          <target state="translated">구현 참고 사항 : 입력 &lt;var&gt;q&lt;/var&gt; 는 올바르게 인수 분해하기 위해 &lt;code&gt;flintmax&lt;/code&gt; (9.0072e + 15) 보다 작아야 합니다.</target>
        </trans-unit>
        <trans-unit id="62fb29c4ef213d8dfa83f7459df69fc2eeefa882" translate="yes" xml:space="preserve">
          <source>Implementation Note: The legend label text is either provided in the call to &lt;code&gt;legend&lt;/code&gt; or is taken from the &lt;code&gt;DisplayName&lt;/code&gt; property of the graphics objects. Only data objects, such as line, patch, and surface, have this property whereas axes, figures, etc. do not so they are never present in a legend. If no labels or &lt;code&gt;DisplayName&lt;/code&gt; properties are available, then the label text is simply &lt;code&gt;&quot;data1&quot;&lt;/code&gt;, &lt;code&gt;&quot;data2&quot;&lt;/code&gt;, &amp;hellip;, &lt;code&gt;&quot;dataN&quot;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="baa8a8320e011f79363aa8d7f1869b6e3ebedd1f" translate="yes" xml:space="preserve">
          <source>Implementation Note: The legend label text is either provided in the call to &lt;code&gt;legend&lt;/code&gt; or is taken from the &lt;code&gt;DisplayName&lt;/code&gt; property of the graphics objects. Only data objects, such as line, patch, and surface, have this property whereas axes, figures, etc. do not so they are never present in a legend. If no labels or &lt;code&gt;DisplayName&lt;/code&gt; properties are available, then the label text is simply &lt;code&gt;&quot;data1&quot;&lt;/code&gt;, &lt;code&gt;&quot;data2&quot;&lt;/code&gt;, &amp;hellip;, &lt;code&gt;&quot;dataN&quot;&lt;/code&gt;. No more than 20 data labels will be automatically generated. To label more, call &lt;code&gt;legend&lt;/code&gt; explicitly and provide all labels.</source>
          <target state="translated">구현 참고 : 범례 레이블 텍스트 중 하나에 대한 호출에 제공되는 &lt;code&gt;legend&lt;/code&gt; 또는에서 가져옵니다 &lt;code&gt;DisplayName&lt;/code&gt; 그래픽 객체의 속성입니다. 선, 패치 및 표면과 같은 데이터 객체 만이 속성을 가지지 만 축, 그림 등은 범례에 존재하지 않습니다. 사용 가능한 레이블 또는 &lt;code&gt;DisplayName&lt;/code&gt; 속성이 없는 경우 레이블 텍스트는 단순히 &lt;code&gt;&quot;data1&quot;&lt;/code&gt; , &lt;code&gt;&quot;data2&quot;&lt;/code&gt; ,&amp;hellip;, &lt;code&gt;&quot;dataN&quot;&lt;/code&gt; 입니다. 20 개 이하의 데이터 레이블이 자동으로 생성됩니다. 더 많은 레이블을 지정하려면 &lt;code&gt;legend&lt;/code&gt; 를 명시 적으로 호출 하고 모든 레이블을 제공하십시오.</target>
        </trans-unit>
        <trans-unit id="226e79efb160feeb6c4c834a4d8976a31368782d" translate="yes" xml:space="preserve">
          <source>Implementation Note: The origin (0, 0) for images is located in the upper left. For ordinary plots, the origin is located in the lower left. Octave handles this inversion by plotting the data normally, and then reversing the direction of the y-axis by setting the &lt;code&gt;ydir&lt;/code&gt; property to &lt;code&gt;&quot;reverse&quot;&lt;/code&gt;. This has implications whenever an image and an ordinary plot need to be overlaid. The recommended solution is to display the image and then plot the reversed ydata using, for example, &lt;code&gt;flipud (ydata)&lt;/code&gt;.</source>
          <target state="translated">구현 참고 사항 : 이미지의 원점 (0, 0)은 왼쪽 상단에 있습니다. 일반 플롯의 경우 원점이 왼쪽 하단에 있습니다. Octave는 데이터를 정상적으로 플로팅 한 다음 &lt;code&gt;ydir&lt;/code&gt; 속성을 &lt;code&gt;&quot;reverse&quot;&lt;/code&gt; 로 설정하여 y 축 방향을 반대로하여이 반전을 처리합니다 . 이는 이미지와 일반 플롯을 오버레이해야 할 때마다 영향을 미칩니다. 권장되는 솔루션은 이미지를 표시 한 다음 예를 들어 &lt;code&gt;flipud (ydata)&lt;/code&gt; 를 사용하여 반전 된 ydata를 플로팅하는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="e1f47b5691014c52ab9e7dccb97817c7dc1aa941" translate="yes" xml:space="preserve">
          <source>Implementation Note: The polar axis is drawn using line and text objects encapsulated in an hggroup. The hggroup properties are linked to the original axes object such that altering an appearance property, for example &lt;code&gt;fontname&lt;/code&gt;, will update the polar axis. Two new properties are added to the original axes&amp;ndash;&lt;code&gt;rtick&lt;/code&gt;, &lt;code&gt;ttick&lt;/code&gt;&amp;ndash;which replace &lt;code&gt;xtick&lt;/code&gt;, &lt;code&gt;ytick&lt;/code&gt;. The first is a list of tick locations in the radial (rho) direction; The second is a list of tick locations in the angular (theta) direction specified in degrees, i.e., in the range 0&amp;ndash;359.</source>
          <target state="translated">구현 참고 사항 : 극좌표 축은 hggroup에 캡슐화 된 선 및 문자 객체를 사용하여 그려집니다. hggroup 속성은 모양 속성 (예 : &lt;code&gt;fontname&lt;/code&gt; ) 을 변경 하면 극축이 업데이트되도록 원본 axes 객체에 연결됩니다 . 두 개의 새로운 속성이 원래 axes-에 추가 &lt;code&gt;rtick&lt;/code&gt; , &lt;code&gt;ttick&lt;/code&gt; - 어떤 대체 &lt;code&gt;xtick&lt;/code&gt; , &lt;code&gt;ytick&lt;/code&gt; . 첫 번째는 방사형 (rho) 방향의 눈금 위치 목록입니다. 두 번째는 각도로 지정된 각도 (세타) 방향, 즉 0&amp;ndash;359 범위의 눈금 위치 목록입니다.</target>
        </trans-unit>
        <trans-unit id="803088a26e51e2955adcacc1324023c70137c420" translate="yes" xml:space="preserve">
          <source>Implementation Note: The search only includes objects with visible handles (HandleVisibility = &lt;code&gt;&quot;on&quot;&lt;/code&gt;). See &lt;a href=&quot;#XREFfindall&quot;&gt;findall&lt;/a&gt;, to search for all objects including hidden ones.</source>
          <target state="translated">구현 참고 : 검색에는 핸들이 보이는 객체 만 포함됩니다 (HandleVisibility = &lt;code&gt;&quot;on&quot;&lt;/code&gt; ). 숨겨진 객체를 포함한 모든 객체를 검색하려면 &lt;a href=&quot;#XREFfindall&quot;&gt;findall을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="141ccd3faeb739eff96ca31e86e456598dcf2541" translate="yes" xml:space="preserve">
          <source>Implementation Note: There are several ways of converting colors to grayscale intensities. This functions uses the luminance value obtained from &lt;code&gt;rgb2gray&lt;/code&gt; which is &lt;code&gt;I = 0.299*R + 0.587*G + 0.114*B&lt;/code&gt;. Other possibilities include the value component from &lt;code&gt;rgb2hsv&lt;/code&gt; or using a single color channel from &lt;code&gt;ind2rgb&lt;/code&gt;.</source>
          <target state="translated">구현 참고 사항 : 색상을 그레이 스케일 강도로 변환하는 방법에는 여러 가지가 있습니다. 이 함수로부터 얻어지는 휘도 값 사용 &lt;code&gt;rgb2gray&lt;/code&gt; 이고 &lt;code&gt;I = 0.299*R + 0.587*G + 0.114*B&lt;/code&gt; . 다른 가능성은 구성 요소의 값을 포함 &lt;code&gt;rgb2hsv&lt;/code&gt; 또는의 단일 컬러 채널 사용 &lt;code&gt;ind2rgb&lt;/code&gt; 를 .</target>
        </trans-unit>
        <trans-unit id="3f16656486015817b6684bcb14e86fdd6efb52a1" translate="yes" xml:space="preserve">
          <source>Implementation Note: This is equivalent to &lt;code&gt;sum (conj (&lt;var&gt;X&lt;/var&gt;) .* &lt;var&gt;Y&lt;/var&gt;, &lt;var&gt;dim&lt;/var&gt;)&lt;/code&gt;, but avoids forming a temporary array and is faster. When &lt;var&gt;X&lt;/var&gt; and &lt;var&gt;Y&lt;/var&gt; are column vectors, the result is equivalent to &lt;code&gt;&lt;var&gt;X&lt;/var&gt;' * &lt;var&gt;Y&lt;/var&gt;&lt;/code&gt;. Although, &lt;code&gt;dot&lt;/code&gt; is defined for integer arrays, the output may differ from the expected result due to the limited range of integer objects.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1cbb8d418def8003a66065b48deb7fee7f3f0e4" translate="yes" xml:space="preserve">
          <source>Import ASCII table using the specified number of header rows and the specified delimiter.</source>
          <target state="translated">지정된 수의 헤더 행과 지정된 구분 기호를 사용하여 ASCII 테이블을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="93d9d11dc6fd876d71a01fd8571c5aaee0ce4ca3" translate="yes" xml:space="preserve">
          <source>Import data from the file &lt;var&gt;fname&lt;/var&gt;.</source>
          <target state="translated">&lt;var&gt;fname&lt;/var&gt; 파일에서 데이터를 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="6b2120f0de6f95fb2fa704525bfaa3ab5b9b00d6" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;m&lt;/code&gt;-files a &lt;code&gt;PKG_ADD&lt;/code&gt; directive looks like this</source>
          <target state="translated">에서 &lt;code&gt;m&lt;/code&gt; -files &lt;code&gt;PKG_ADD&lt;/code&gt; 이 같은 지침의 모습을</target>
        </trans-unit>
        <trans-unit id="1bbe6d74cc2df94f447683914cc4658153ce3e7c" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;some_class&lt;/code&gt;, the method &lt;code&gt;func&lt;/code&gt; is defined within a &lt;code&gt;methods&lt;/code&gt; block setting the &lt;code&gt;Access&lt;/code&gt; attribute to &lt;var&gt;mode&lt;/var&gt;, which is one of:</source>
          <target state="translated">에서는 &lt;code&gt;some_class&lt;/code&gt; , 상기 방법 &lt;code&gt;func&lt;/code&gt; 내에 정의 된 &lt;code&gt;methods&lt;/code&gt; 상기 설정 블록 &lt;code&gt;Access&lt;/code&gt; 애트리뷰트 &lt;var&gt;mode&lt;/var&gt; 중 하나이다 :</target>
        </trans-unit>
        <trans-unit id="21cc0e17582609b077ede856f28cbdd297e040d2" translate="yes" xml:space="preserve">
          <source>In Octave custom formats are supported by implementing all callback subfunctions in a function file named &amp;lsquo;</source>
          <target state="translated">Octave에서 '콜백 하위 함수를 모두'라는 함수 파일에 구현하여 사용자 정의 형식을 지원</target>
        </trans-unit>
        <trans-unit id="40da613679b8f1c93a85923b0183cb94da6dfc1e" translate="yes" xml:space="preserve">
          <source>In Octave it is possible to provide limited Java reflection by listing the public fields and methods of a Java object, both static or not.</source>
          <target state="translated">Octave에서는 정적 또는 비 정적 Java 오브젝트의 공용 필드 및 메소드를 나열하여 제한된 Java 리플렉션을 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="36ff03f537742ac776fe5e1c01171a11a3a5da57" translate="yes" xml:space="preserve">
          <source>In Octave the &lt;code&gt;fieldnames&lt;/code&gt; function for structures has been overloaded to return the fields of a Java object. For example:</source>
          <target state="translated">Octave에서 구조에 대한 &lt;code&gt;fieldnames&lt;/code&gt; 함수는 Java 오브젝트의 필드를 리턴하도록 오버로드되었습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ff3d8c10f1eb7e65ce52a411d7a0a70b0734784e" translate="yes" xml:space="preserve">
          <source>In Octave the following idiom is seen frequently at the beginning of a function definition:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="244d401970e161be332758ea88cbe2ac7377470f" translate="yes" xml:space="preserve">
          <source>In Octave, a polynomial is represented by its coefficients (arranged in descending order). For example, a vector &lt;var&gt;c&lt;/var&gt; of length &lt;em&gt;N+1&lt;/em&gt; corresponds to the following polynomial of order &lt;var&gt;N&lt;/var&gt;</source>
          <target state="translated">옥타브에서 다항식은 계수 (내림차순으로 정렬)로 표시됩니다. 예를 들어, 길이 &lt;em&gt;N + 1&lt;/em&gt; 의 벡터 &lt;var&gt;c&lt;/var&gt; 는 차수 &lt;var&gt;N&lt;/var&gt; 의 다항식에 해당합니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6834620d5792153fc6620f3d6a92d748257a71b1" translate="yes" xml:space="preserve">
          <source>In Octave, unlike Fortran, function arguments are passed by value, which means that each argument in a function call is evaluated and assigned to a temporary location in memory before being passed to the function. There is currently no way to specify that a function parameter should be passed by reference instead of by value. This means that it is impossible to directly alter the value of a function parameter in the calling function. It can only change the local copy within the function body. For example, the function</source>
          <target state="translated">Octave에서는 Fortran과 달리 함수 인수가 값으로 전달됩니다. 즉, 함수 호출의 각 인수는 함수로 전달되기 전에 메모리의 임시 위치에 평가 및 할당됩니다. 현재 함수 매개 변수를 값 대신 참조로 전달하도록 지정할 방법이 없습니다. 이것은 호출 함수에서 함수 매개 변수의 값을 직접 변경할 수 없음을 의미합니다. 함수 본문 내에서만 로컬 사본을 변경할 수 있습니다. 예를 들어, 함수</target>
        </trans-unit>
        <trans-unit id="963cc3df1dd84baf3eaaa88c9f6c5a4ee4141db7" translate="yes" xml:space="preserve">
          <source>In a function description, the name of the function being described appears first. It is followed on the same line by a list of parameters. The names used for the parameters are also used in the body of the description.</source>
          <target state="translated">기능 설명에서 설명중인 기능의 이름이 먼저 나타납니다. 같은 줄에 매개 변수 목록이옵니다. 매개 변수에 사용 된 이름은 설명 본문에도 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="8bd7408149f4b6f2d450c1cafc3c337215a133bd" translate="yes" xml:space="preserve">
          <source>In a single-quoted string there is only one escape sequence: you may insert a single quote character using two single quote characters in succession. For example,</source>
          <target state="translated">작은 따옴표로 묶인 문자열에는 이스케이프 시퀀스가 ​​하나만 있습니다. 두 개의 작은 따옴표 문자를 연속해서 사용하여 작은 따옴표 문자를 삽입 할 수 있습니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="0d79a9045e7f64af0936e9bc0a5e3369db1fc3d1" translate="yes" xml:space="preserve">
          <source>In a thermal model, we want to calculate the temperature in Omega and know the boundary temperature (Dirichlet condition) or heat flux (from which we can calculate the Neumann condition by dividing by the thermal conductivity at the boundary). Similarly, in an electrical model, we want to calculate the voltage in Omega and know the boundary voltage (Dirichlet) or current (Neumann condition after diving by the electrical conductivity). In an electrical model, it is common for much of the boundary to be electrically isolated; this is a Neumann boundary condition with the current equal to zero.</source>
          <target state="translated">열 모델에서는 Omega의 온도를 계산하고 경계 온도 (Dirichlet condition) 또는 열 유속 (경계에서 열전도 도로 나누어 Neumann 조건을 계산할 수 있음)을 알고 싶습니다. 마찬가지로 전기 모델에서 Omega의 전압을 계산하고 경계 전압 (Dirichlet) 또는 전류 (전기 전도성으로 다이빙 한 후 뉴만 조건)를 알고 싶습니다. 전기 모델에서는 많은 경계가 전기적으로 절연되는 것이 일반적입니다. 이것은 전류가 0 인 Neumann 경계 조건입니다.</target>
        </trans-unit>
        <trans-unit id="dbc5f8cd6dc4dd05c94083d8616e2cd8437602d2" translate="yes" xml:space="preserve">
          <source>In addition all of the standard Octave mapper functions (i.e., basic math functions that take a single argument) such as &lt;em&gt;abs&lt;/em&gt;, etc. can accept sparse matrices. The reader is referred to the documentation supplied with these functions within Octave itself for further details.</source>
          <target state="translated">또한 &lt;em&gt;abs&lt;/em&gt; 등의 모든 표준 Octave 매퍼 함수 (예 : 단일 인수를 취하는 기본 수학 함수) 는 희소 행렬을 사용할 수 있습니다. 자세한 내용은 옥타브 자체에서 이러한 기능과 함께 제공된 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="a182f62668492bf4846688b7037bfa09d492fdd1" translate="yes" xml:space="preserve">
          <source>In addition the format may contain literal character strings; these will be skipped during reading.</source>
          <target state="translated">또한 형식에는 리터럴 문자열이 포함될 수 있습니다. 읽는 동안에는 건너 뜁니다.</target>
        </trans-unit>
        <trans-unit id="5e203b3cff1195513be987179959b5aa258b19b0" translate="yes" xml:space="preserve">
          <source>In addition the format may contain literal character strings; these will be skipped during reading. If the input string does not match this literal, the processing terminates.</source>
          <target state="translated">또한 형식에는 리터럴 문자열이 포함될 수 있습니다. 읽는 동안에는 건너 뜁니다. 입력 문자열이이 리터럴과 일치하지 않으면 처리가 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="9686c0e54ce4c696bc3c8e05581e2f1defc16feb" translate="yes" xml:space="preserve">
          <source>In addition the members of the group can also be linked to other graphics objects through callback functions. For example the baseline of the &lt;code&gt;bar&lt;/code&gt; or &lt;code&gt;stem&lt;/code&gt; functions is a line object, whose length and position are automatically adjusted, based on changes to the corresponding hggroup elements.</source>
          <target state="translated">또한 그룹의 멤버는 콜백 함수를 통해 다른 그래픽스 객체에 연결될 수도 있습니다. 예를 들어, &lt;code&gt;bar&lt;/code&gt; 또는 &lt;code&gt;stem&lt;/code&gt; 함수 의 기준선은 해당 hggroup 요소의 변경 사항에 따라 길이와 위치가 자동으로 조정되는 선 개체입니다.</target>
        </trans-unit>
        <trans-unit id="43e161e34cc10d18de1095d75d8f32ba14fe1b30" translate="yes" xml:space="preserve">
          <source>In addition to accepting individual directory arguments, lists of directory names separated by &lt;code&gt;pathsep&lt;/code&gt; are also accepted. For example:</source>
          <target state="translated">개별 디렉토리 인수를 승인하는 것 외에도 &lt;code&gt;pathsep&lt;/code&gt; 로 구분 된 디렉토리 이름 목록 도 승인됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a85925c959da1225104f5b932d4580c9cb058f5d" translate="yes" xml:space="preserve">
          <source>In addition to evaluating the polynomial, the second output represents the prediction interval, &lt;var&gt;y&lt;/var&gt; +/- &lt;var&gt;dy&lt;/var&gt;, which contains at least 50% of the future predictions. To calculate the prediction interval, the structured variable &lt;var&gt;s&lt;/var&gt;, originating from &lt;code&gt;polyfit&lt;/code&gt;, must be supplied.</source>
          <target state="translated">다항식을 평가하는 것 외에도, 두 번째 출력은 미래 예측의 50 % 이상을 포함 하는 예측 간격 &lt;var&gt;y&lt;/var&gt; +/- &lt;var&gt;dy&lt;/var&gt; 를 나타냅니다 . 예측 구간을 계산하려면 &lt;code&gt;polyfit&lt;/code&gt; 에서 시작된 구조화 된 변수 &lt;var&gt;s&lt;/var&gt; 가 제공되어야합니다.</target>
        </trans-unit>
        <trans-unit id="5c2c5777ae3552554dd801ec3e795dc736c85a43" translate="yes" xml:space="preserve">
          <source>In addition to knowing the size of a dispersion it is useful to know the shape of the data set. For example, are data points massed to the left or right of the mean? Octave provides several common measures to describe the shape of the data set. Octave can also calculate moments allowing arbitrary shape measures to be developed.</source>
          <target state="translated">분산의 크기를 아는 것 외에도 데이터 세트의 모양을 아는 것이 유용합니다. 예를 들어, 데이터 포인트가 평균의 왼쪽 또는 오른쪽에 질량이 있습니까? 옥타브는 데이터 세트의 모양을 설명하기위한 몇 가지 일반적인 측정 값을 제공합니다. 옥타브는 모멘트를 계산하여 임의의 형상 측정을 개발할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d89a43ff37478ffc6e874f8d0e4043e8d55b7d9b" translate="yes" xml:space="preserve">
          <source>In addition to setting &lt;code&gt;nargin&lt;/code&gt; each time a function is called, Octave also automatically initializes &lt;code&gt;nargout&lt;/code&gt; to the number of values that are expected to be returned. This allows you to write functions that behave differently depending on the number of values that the user of the function has requested. The implicit assignment to the built-in variable &lt;code&gt;ans&lt;/code&gt; does not figure in the count of output arguments, so the value of &lt;code&gt;nargout&lt;/code&gt; may be zero.</source>
          <target state="translated">Octave는 함수가 호출 될 때마다 &lt;code&gt;nargin&lt;/code&gt; 을 설정 하는 것 외에도 반환 될 것으로 예상되는 값의 수로 &lt;code&gt;nargout&lt;/code&gt; 을 자동으로 초기화 합니다. 이를 통해 함수 사용자가 요청한 값의 수에 따라 다르게 동작하는 함수를 작성할 수 있습니다. 내장 변수 &lt;code&gt;ans&lt;/code&gt; 에 대한 암시 적 할당 은 출력 인수의 수를 나타내지 않으므로 &lt;code&gt;nargout&lt;/code&gt; 의 값은 0 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2344bfa6bb4ccf00a0fa9c30a47f5f5cdd526550" translate="yes" xml:space="preserve">
          <source>In addition to the keyboard commands for moving through the history list, Octave provides three functions for viewing, editing, and re-running chunks of commands from the history list.</source>
          <target state="translated">옥타브는 히스토리 목록을 이동하기위한 키보드 명령 외에도 히스토리 목록에서 명령 덩어리를보고, 편집하고, 재실행하기위한 세 가지 기능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="785f267adae30c4271ed57cc0cd99f28823ec75c" translate="yes" xml:space="preserve">
          <source>In addition to the options supported by &lt;code&gt;strread&lt;/code&gt;, this function supports two more:</source>
          <target state="translated">&lt;code&gt;strread&lt;/code&gt; 가 지원하는 옵션 외에도이 함수는 두 가지를 더 지원합니다.</target>
        </trans-unit>
        <trans-unit id="04d5f7f37134f64cc8cb5750ddb18d6451d1c0bb" translate="yes" xml:space="preserve">
          <source>In addition to unwind_protect, Octave supports another form of exception handling, the &lt;code&gt;try&lt;/code&gt; block.</source>
          <target state="translated">unave_protect 외에도 Octave는 다른 형태의 예외 처리, &lt;code&gt;try&lt;/code&gt; 블록을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="90c0a3b34a6c55a0342f521a0015f0c7d7d8fc78" translate="yes" xml:space="preserve">
          <source>In addition, some function types may return more information in additional fields.</source>
          <target state="translated">또한 일부 함수 유형은 추가 필드에서 추가 정보를 리턴 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="64e4cdd186cedbe62ef109e00265261a9cca1bb6" translate="yes" xml:space="preserve">
          <source>In addition, the following escaped characters have special meaning.</source>
          <target state="translated">또한 다음 이스케이프 문자는 특별한 의미가 있습니다.</target>
        </trans-unit>
        <trans-unit id="45c11b9edc04548a3aa0d6e538adb06045e4ee04" translate="yes" xml:space="preserve">
          <source>In addition, the following functions are also provided:</source>
          <target state="translated">또한 다음 기능도 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="bcbafa7736318fb861b81a25c4c7d80f68797f74" translate="yes" xml:space="preserve">
          <source>In addition, the following keyword value pairs may appear at the end of the argument list:</source>
          <target state="translated">또한 인수 목록 끝에 다음 키워드 값 쌍이 나타날 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6456be77c141b303894b71d3574f23c5c809e9e2" translate="yes" xml:space="preserve">
          <source>In addition, the gnuplot program usually provides a number of different interfaces, known as terminals. Octave normally chooses a default terminal, but you can override this with the environment variable &lt;code&gt;GNUTERM&lt;/code&gt;. This variable may be set in the shell before starting Octave or from within Octave before plotting for the first time. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f100f9cb81fb50bc6555fcfd1f22d497403939ec" translate="yes" xml:space="preserve">
          <source>In addition, the root object contains information about the graphics system as a whole such as the &lt;code&gt;ScreenSize&lt;/code&gt;. Use &lt;code&gt;get&amp;nbsp;(groot)&lt;/code&gt; to find out what information is available.</source>
          <target state="translated">또한 루트 객체에는 &lt;code&gt;ScreenSize&lt;/code&gt; 와 같은 그래픽 시스템에 대한 정보가 포함됩니다 . 사용 가능한 정보를 찾으 &lt;code&gt;get&amp;nbsp;(groot)&lt;/code&gt; 을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="32324121a40e9bb343f1f3574d3bb17690762224" translate="yes" xml:space="preserve">
          <source>In addition, the support functions &lt;code&gt;spline&lt;/code&gt; and &lt;code&gt;lookup&lt;/code&gt; that underlie the &lt;code&gt;interp1&lt;/code&gt; function can be called directly.</source>
          <target state="translated">또한 &lt;code&gt;interp1&lt;/code&gt; 함수의 기반이되는 지원 함수 &lt;code&gt;spline&lt;/code&gt; 및 &lt;code&gt;lookup&lt;/code&gt; 를 직접 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6d6f1adbb9030d2e8ee81f9bab19dc7195fcb3a9" translate="yes" xml:space="preserve">
          <source>In addition, there are several other functions for concatenating string objects which can be useful in specific circumstances: &lt;code&gt;char&lt;/code&gt;, &lt;code&gt;strvcat&lt;/code&gt;, &lt;code&gt;strcat&lt;/code&gt;, and &lt;code&gt;cstrcat&lt;/code&gt;. Finally, the general purpose concatenation functions can be used: see &lt;a href=&quot;rearranging-matrices#XREFcat&quot;&gt;cat&lt;/a&gt;, &lt;a href=&quot;rearranging-matrices#XREFhorzcat&quot;&gt;horzcat&lt;/a&gt;, and &lt;a href=&quot;rearranging-matrices#XREFvertcat&quot;&gt;vertcat&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af8a0c08d4a47b3c3acb11897fba69f09ff76311" translate="yes" xml:space="preserve">
          <source>In addition, there are three non-specific parser customization functions. &lt;code&gt;add_input_event_hook&lt;/code&gt; can be used to schedule a user function for periodic evaluation. &lt;code&gt;remove_input_event_hook&lt;/code&gt; will stop a user function from being evaluated periodically.</source>
          <target state="translated">또한 세 가지 비 특정 파서 사용자 정의 기능이 있습니다. &lt;code&gt;add_input_event_hook&lt;/code&gt; 을 사용하여 주기적 평가를위한 사용자 기능을 예약 할 수 있습니다. &lt;code&gt;remove_input_event_hook&lt;/code&gt; 은 사용자 기능이 주기적으로 평가되지 않도록합니다.</target>
        </trans-unit>
        <trans-unit id="7f77916a1edf7d6d6a6ee10f7759ec1db3cb66ca" translate="yes" xml:space="preserve">
          <source>In all cases, typing CTRL-C stops program execution immediately.</source>
          <target state="translated">모든 경우에 CTRL-C를 입력하면 프로그램 실행이 즉시 중지됩니다.</target>
        </trans-unit>
        <trans-unit id="1d949a10577f92877a6250011b8f590db91a1d0c" translate="yes" xml:space="preserve">
          <source>In any case, please report this as a bug since it might be possible to modify Octave&amp;rsquo;s configuration script to automatically determine the proper thing to do.</source>
          <target state="translated">어쨌든 Octave의 구성 스크립트를 수정하여 적절한 조치를 자동으로 결정할 수 있으므로 버그로보고하십시오.</target>
        </trans-unit>
        <trans-unit id="cfa3699f58c603efe27c8c970cd227fa820ebf10" translate="yes" xml:space="preserve">
          <source>In binary mode there is no conversion of newlines from the remote representation to the local representation.</source>
          <target state="translated">이진 모드에서는 개행을 원격 표현에서 로컬 표현으로 변환하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b832653648286e2d9a0639a5977d1acc8f1ecbb0" translate="yes" xml:space="preserve">
          <source>In both cases &lt;code&gt;some_octave_command&lt;/code&gt; should be replaced by the command that should be placed in the &lt;code&gt;PKG_ADD&lt;/code&gt; file. &lt;code&gt;PKG_DEL&lt;/code&gt; directives work in the same way, except the &lt;code&gt;PKG_ADD&lt;/code&gt; keyword is replaced with &lt;code&gt;PKG_DEL&lt;/code&gt; and the commands get added to the &lt;code&gt;PKG_DEL&lt;/code&gt; file.</source>
          <target state="translated">두 경우 모두 &lt;code&gt;some_octave_command&lt;/code&gt; 는 &lt;code&gt;PKG_ADD&lt;/code&gt; 파일 에있는 명령으로 대체해야 합니다. &lt;code&gt;PKG_DEL&lt;/code&gt; 의 제외 지시어는 같은 방식으로 작동 &lt;code&gt;PKG_ADD&lt;/code&gt; 키워드로 교체 &lt;code&gt;PKG_DEL&lt;/code&gt; 와 명령이 추가 얻을 &lt;code&gt;PKG_DEL&lt;/code&gt; 의 파일.</target>
        </trans-unit>
        <trans-unit id="7f7ae3e0caa80fdb336a4d60efcd5dd20a600cb1" translate="yes" xml:space="preserve">
          <source>In case all dimensions are equal, no broadcasting occurs and ordinary element-by-element arithmetic takes place. For arrays of higher dimensions, if the number of dimensions isn&amp;rsquo;t the same, then missing trailing dimensions are treated as 1. When one of the dimensions is 1, the array with that singleton dimension gets copied along that dimension until it matches the dimension of the other array. For example, consider</source>
          <target state="translated">모든 차원이 동일한 경우 브로드 캐스트가 발생하지 않으며 일반적인 요소 별 산술이 수행됩니다. 차원이 더 높은 배열의 경우 차원 수가 동일하지 않으면 누락 된 후행 차원은 1로 처리됩니다. 차원 중 하나가 1 인 경우 해당 단일 톤 차원이있는 배열은 차원과 일치 할 때까지 해당 차원을 따라 복사됩니다. 다른 배열의. 예를 들어</target>
        </trans-unit>
        <trans-unit id="15510052af30543da0d56a4082bd9ddf7e3b1543" translate="yes" xml:space="preserve">
          <source>In cases where a loop cannot be avoided, or a number of values must be combined to form a larger matrix, it is generally faster to set the size of the matrix first (pre-allocate storage), and then insert elements using indexing commands. For example, given a matrix &lt;code&gt;a&lt;/code&gt;,</source>
          <target state="translated">더 큰 행렬을 형성하기 위해 루프를 피할 수 없거나 많은 값을 결합해야하는 경우 일반적으로 행렬의 크기를 먼저 설정 (사전 할당 저장) 한 다음 인덱싱 명령을 사용하여 요소를 삽입하는 것이 더 빠릅니다. 예를 들어 행렬이 주어지면 &lt;code&gt;a&lt;/code&gt; ,</target>
        </trans-unit>
        <trans-unit id="2423a36ae00d02b333ea61d9be1d0f1df5805928" translate="yes" xml:space="preserve">
          <source>In contrast to &lt;code&gt;mesh&lt;/code&gt;, which plots a mesh using rectangles, &lt;code&gt;trimesh&lt;/code&gt; plots the mesh using triangles.</source>
          <target state="translated">대조적으로 &lt;code&gt;mesh&lt;/code&gt; 사각형을 사용하여 메시을 나타내는, &lt;code&gt;trimesh&lt;/code&gt; 플롯 삼각형 메쉬를 사용.</target>
        </trans-unit>
        <trans-unit id="ecc7c1688b156d5cd74ccc58700611a6c5e7ed10" translate="yes" xml:space="preserve">
          <source>In contrast to &lt;code&gt;surf&lt;/code&gt;, which plots a surface mesh using rectangles, &lt;code&gt;trisurf&lt;/code&gt; plots the mesh using triangles.</source>
          <target state="translated">대조적으로 &lt;code&gt;surf&lt;/code&gt; 표면을 나타내는 직사각형을 사용하여 메쉬 &lt;code&gt;trisurf&lt;/code&gt; 는 삼각형을 사용하여 메시를 플롯합니다.</target>
        </trans-unit>
        <trans-unit id="d55f60a29d749426c8b8a61fb2f3dc494769c09a" translate="yes" xml:space="preserve">
          <source>In contrast to old style classes, the &lt;code&gt;properties&lt;/code&gt;-&lt;code&gt;endproperties&lt;/code&gt; block as well as the &lt;code&gt;methods&lt;/code&gt;-&lt;code&gt;endmethods&lt;/code&gt; block can be used to define properties and methods of the class. Because both blocks are empty, they can be omitted in this particular case.</source>
          <target state="translated">이전 스타일 클래스는 대조적으로, &lt;code&gt;properties&lt;/code&gt; - &lt;code&gt;endproperties&lt;/code&gt; 이 아니라 한 차단 &lt;code&gt;methods&lt;/code&gt; - &lt;code&gt;endmethods&lt;/code&gt; 의 속성과 클래스의 메서드를 정의 할 수 있습니다 블록. 두 블록 모두 비어 있기 때문에이 경우에는 생략 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b11c8fdef75cc0691f4017f224eb795340fafe76" translate="yes" xml:space="preserve">
          <source>In contrast, local packages are installed by default in the user&amp;rsquo;s home directory (profile on Windows) and are only available to that specific user. Usually, they can be installed without root access (or administrative privileges).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2520403eb65dfe1141904541ec62d7377fcf7a34" translate="yes" xml:space="preserve">
          <source>In debugging mode, execute the next &lt;var&gt;n&lt;/var&gt; lines of code.</source>
          <target state="translated">디버깅 모드에서 다음 &lt;var&gt;n&lt;/var&gt; 줄의 코드를 실행하십시오 .</target>
        </trans-unit>
        <trans-unit id="0a3fd41a5529fe498ac47e12d9e5cf03c878b0d1" translate="yes" xml:space="preserve">
          <source>In debugging mode, list &lt;var&gt;n&lt;/var&gt; lines of the function being debugged centered around the current line to be executed.</source>
          <target state="translated">디버깅 모드에서 실행할 현재 행을 중심으로 디버깅중인 함수의 &lt;var&gt;n&lt;/var&gt; 행을 나열하십시오 .</target>
        </trans-unit>
        <trans-unit id="89290617b68721433e26b7758d6363c868fab5b8" translate="yes" xml:space="preserve">
          <source>In debugging mode, move down the execution stack &lt;var&gt;n&lt;/var&gt; frames.</source>
          <target state="translated">디버깅 모드에서 실행 스택 &lt;var&gt;n&lt;/var&gt; 프레임 아래로 이동하십시오 .</target>
        </trans-unit>
        <trans-unit id="0a26365b5f3b779a5b1f5cda95fc4ab48376236e" translate="yes" xml:space="preserve">
          <source>In debugging mode, move up the execution stack &lt;var&gt;n&lt;/var&gt; frames.</source>
          <target state="translated">디버깅 모드에서 실행 스택 &lt;var&gt;n&lt;/var&gt; 프레임 위로 이동하십시오 .</target>
        </trans-unit>
        <trans-unit id="24e9e90413537da4d3aadaa484045340f05d0bbe" translate="yes" xml:space="preserve">
          <source>In debugging mode, report the current file and line number where execution is stopped.</source>
          <target state="translated">디버깅 모드에서 실행이 중지 된 현재 파일과 줄 번호를보고하십시오.</target>
        </trans-unit>
        <trans-unit id="972a3680b7e26de359defc0e0846b37cee4dde6e" translate="yes" xml:space="preserve">
          <source>In decimal notation, the numeric constant may be denoted as decimal fraction or even in scientific (exponential) notation. Note that this is not possible for hexadecimal or binary notation. Again, in the following example all numeric constants represent the same value:</source>
          <target state="translated">십진 표기법에서 숫자 상수는 십진 분수 또는 과학적 (지수) 표기법으로 표시 될 수 있습니다. 16 진 또는 2 진 표기법에서는 불가능합니다. 다시, 다음 예제에서 모든 숫자 상수는 동일한 값을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="548db5e472e39ee53ef51ca4fd1c40e1824dda84" translate="yes" xml:space="preserve">
          <source>In double-quoted strings, the backslash character is used to introduce &lt;em&gt;escape sequences&lt;/em&gt; that represent other characters. For example, &amp;lsquo;</source>
          <target state="translated">큰 따옴표로 묶인 문자열에서 백 슬래시 문자는 다른 문자를 나타내는 &lt;em&gt;이스케이프 시퀀스&lt;/em&gt; 를 도입하는 데 사용됩니다 . 예를 들어 '</target>
        </trans-unit>
        <trans-unit id="0873308864ef65a229ee1d2ba32e79be9afb1d9e" translate="yes" xml:space="preserve">
          <source>In each case it is easy to see what the final string will look like. This method is also the most efficient. When using matrix concatenation the parser immediately begins joining the strings without having to process the overhead of a function call and the input validation of the associated function.</source>
          <target state="translated">각각의 경우 최종 문자열이 어떻게 보이는지 쉽게 알 수 있습니다. 이 방법도 가장 효율적입니다. 매트릭스 연결을 사용할 때 구문 분석기는 함수 호출의 오버 헤드 및 연관된 함수의 입력 유효성 검증을 처리하지 않고 즉시 문자열 결합을 시작합니다.</target>
        </trans-unit>
        <trans-unit id="e651d26047ba8d65f5cdd8bcde7afa665eeb3ab2" translate="yes" xml:space="preserve">
          <source>In either case, initial values for the given components are input, and initial guesses for the unknown components must also be provided as input. Set this option to 1 to solve the first problem, or 2 to solve the second (the default is 0, so you must provide a set of initial conditions that are consistent).</source>
          <target state="translated">두 경우 모두 주어진 구성 요소의 초기 값이 입력되고 알 수없는 구성 요소의 초기 추측 값도 입력으로 제공되어야합니다. 첫 번째 문제점을 해결하려면이 옵션을 1로 설정하고 두 번째 문제점을 해결하려면 2로 설정하십시오 (기본값은 0이므로 일관된 초기 조건 세트를 제공해야합니다).</target>
        </trans-unit>
        <trans-unit id="8f4b3bcabb6f9ec4b1d6ac027d6e07ddbb6514ea" translate="yes" xml:space="preserve">
          <source>In expressions like this, the number of values in each part of the expression need not match. For example, the expression</source>
          <target state="translated">이와 같은 표현식에서 표현식의 각 부분에있는 값의 수가 일치하지 않아도됩니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="9889f85aafab1c7213f9444b3fb3072cc0c686f9" translate="yes" xml:space="preserve">
          <source>In fact, all three eigenvalues are exactly 1 which emphasizes that for numerical performance the &lt;code&gt;eig&lt;/code&gt; function should be used to compute eigenvalues.</source>
          <target state="translated">실제로, 3 개의 고유 값은 모두 정확히 1이며 수치 성능을 위해서는 고유 값 계산에 &lt;code&gt;eig&lt;/code&gt; 함수를 사용해야 한다는 것을 강조합니다 .</target>
        </trans-unit>
        <trans-unit id="117b6e152e6d6f87c37463f7bb08c2d852c10264" translate="yes" xml:space="preserve">
          <source>In fact, the column index contains one more element than the number of columns, with the first element always being zero. The advantage of this is a simplification in the code, in that there is no special case for the first or last columns. A short example, demonstrating this in C is.</source>
          <target state="translated">실제로, 열 색인은 열 수보다 하나 이상의 요소를 포함하며 첫 번째 요소는 항상 0입니다. 이것의 장점은 첫 번째 또는 마지막 열에 특별한 경우가 없기 때문에 코드가 단순화된다는 것입니다. C로 이것을 보여주는 짧은 예입니다.</target>
        </trans-unit>
        <trans-unit id="196307f8789439ecc95d4a25c693a331c686b344" translate="yes" xml:space="preserve">
          <source>In general Octave supports four different kinds of images, grayscale images, RGB images, binary images, and indexed images. A grayscale image is represented with an M-by-N matrix in which each element corresponds to the intensity of a pixel. An RGB image is represented with an M-by-N-by-3 array where each 3-vector corresponds to the red, green, and blue intensities of each pixel.</source>
          <target state="translated">일반적으로 Octave는 4 가지 종류의 이미지, 회색조 이미지, RGB 이미지, 이진 이미지 및 인덱스 이미지를 지원합니다. 그레이 스케일 이미지는 각각의 요소가 픽셀의 강도에 대응하는 MxN 매트릭스로 표현된다. RGB 이미지는 각각의 3 개 벡터가 각 픽셀의 적색, 녹색 및 청색 강도에 대응하는 mxnx3 배열로 표현됩니다.</target>
        </trans-unit>
        <trans-unit id="2bb07d8de1487b40ac9225cf990ddf657b1a3f4a" translate="yes" xml:space="preserve">
          <source>In general any function or operator used on a sparse matrix will result in a sparse matrix with the same or a larger number of nonzero elements than the original matrix. This is particularly true for the important case of sparse matrix factorizations. The usual way to address this is to reorder the matrix, such that its factorization is sparser than the factorization of the original matrix. That is the factorization of &lt;code&gt;L * U = P * S * Q&lt;/code&gt; has sparser terms &lt;code&gt;L&lt;/code&gt; and &lt;code&gt;U&lt;/code&gt; than the equivalent factorization &lt;code&gt;L * U = S&lt;/code&gt;.</source>
          <target state="translated">일반적으로 희소 행렬에 사용 된 함수 또는 연산자는 원래 행렬과 같거나 더 많은 수의 0이 아닌 요소를 갖는 희소 행렬을 생성합니다. 이것은 희소 행렬 인수 분해의 중요한 경우에 특히 해당됩니다. 이 문제를 해결하는 일반적인 방법은 행렬을 재정렬하여 인수 분해가 원래 행렬의 인수 분해보다 희박하도록하는 것입니다. 즉, &lt;code&gt;L * U = P * S * Q&lt;/code&gt; 인수 분해는 등가 인수 분해 &lt;code&gt;L * U = S&lt;/code&gt; 보다 희소 한 항 &lt;code&gt;L&lt;/code&gt; 과 &lt;code&gt;U&lt;/code&gt; 를 갖습니다 .</target>
        </trans-unit>
        <trans-unit id="add429a3abd006ee2156abfddbbd79f62d5d2ffb" translate="yes" xml:space="preserve">
          <source>In general it is best to avoid calculating the inverse of a matrix directly. For example, it is both faster and more accurate to solve systems of equations (&lt;var&gt;A&lt;/var&gt;*&lt;em&gt;x&lt;/em&gt; = &lt;em&gt;b&lt;/em&gt;) with &lt;code&gt;&lt;var&gt;y&lt;/var&gt; = &lt;var&gt;A&lt;/var&gt; \ &lt;em&gt;b&lt;/em&gt;&lt;/code&gt;, rather than &lt;code&gt;&lt;var&gt;y&lt;/var&gt; = inv (&lt;var&gt;A&lt;/var&gt;) * &lt;em&gt;b&lt;/em&gt;&lt;/code&gt;.</source>
          <target state="translated">일반적으로 행렬의 역을 직접 계산하지 않는 것이 가장 좋습니다. 예를 들어, &lt;code&gt;&lt;var&gt;y&lt;/var&gt; = inv (&lt;var&gt;A&lt;/var&gt;) * &lt;em&gt;b&lt;/em&gt;&lt;/code&gt; = inv ( &lt;var&gt;A&lt;/var&gt; ) * &lt;em&gt;b가&lt;/em&gt; 아니라 &lt;code&gt;&lt;var&gt;y&lt;/var&gt; = &lt;var&gt;A&lt;/var&gt; \ &lt;em&gt;b&lt;/em&gt;&lt;/code&gt; = &lt;var&gt;A&lt;/var&gt; \ &lt;em&gt;b&lt;/em&gt; 인 방정식 시스템 ( &lt;var&gt;A&lt;/var&gt; * &lt;em&gt;x&lt;/em&gt; = &lt;em&gt;b&lt;/em&gt; ) 을 해결하는 것이 더 빠르고 정확합니다 .&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="291127a0054b86fe2ce80db4cff57b53de85f2b9" translate="yes" xml:space="preserve">
          <source>In general most integer matrices are created by casting existing matrices to integers. The following example shows how to cast a matrix into 32 bit integers.</source>
          <target state="translated">일반적으로 대부분의 정수 행렬은 기존 행렬을 정수로 캐스트하여 생성됩니다. 다음 예제는 행렬을 32 비트 정수로 캐스트하는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="6fca9c71f6e29b95ddfe7fe244f41ed4f3191af7" translate="yes" xml:space="preserve">
          <source>In general nested cell arrays are displayed hierarchically as in the previous example. In some circumstances it makes sense to reference them by their index, and this can be performed by the &lt;code&gt;celldisp&lt;/code&gt; function.</source>
          <target state="translated">일반적으로 중첩 셀형 배열은 이전 예와 같이 계층 적으로 표시됩니다. 어떤 상황에서는 색인으로 참조하는 것이 합리적이며, 이는 &lt;code&gt;celldisp&lt;/code&gt; 함수에 의해 수행 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="119bfbc716ba33164aae53e4534144b3eadac5f7" translate="yes" xml:space="preserve">
          <source>In general the left division operator is more stable and faster than using the &lt;code&gt;spaugment&lt;/code&gt; function.</source>
          <target state="translated">일반적으로 왼쪽 나누기 연산자는 &lt;code&gt;spaugment&lt;/code&gt; 기능을 사용하는 것보다 더 안정적이고 빠릅니다 .</target>
        </trans-unit>
        <trans-unit id="0f76854f7b28b2463eb8eb295a667e6badc6a30c" translate="yes" xml:space="preserve">
          <source>In general the lower triangular factorization is significantly faster for sparse matrices.</source>
          <target state="translated">일반적으로 낮은 삼각 인수 분해는 희소 행렬의 경우 훨씬 빠릅니다.</target>
        </trans-unit>
        <trans-unit id="fbf11b51d0fcf6c34c59a159db15e8b2e3cc59a5" translate="yes" xml:space="preserve">
          <source>In general there are only three points on the circumference of any circum-circle. However, in some cases, and in particular for the case of a regular grid, 4 or more points can be on a single circum-circle. In this case the Delaunay triangulation is not unique.</source>
          <target state="translated">일반적으로 원주의 원주에는 세 지점 만 있습니다. 그러나 일부 경우, 특히 규칙적인 그리드의 경우 단일 원주에 4 개 이상의 점이있을 수 있습니다. 이 경우 들로네 삼각 분할 (Delaunay Triangulation)은 고유하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="138bfba5800d7c6cda951dd6eaa3300e8c1d6b92" translate="yes" xml:space="preserve">
          <source>In general there may be no way of knowing the best distribution of points ahead of time. Or the points may come from an experiment where there is no freedom to select the best distribution. In any case, one must remain aware of this issue when using &lt;code&gt;trapz&lt;/code&gt;.</source>
          <target state="translated">일반적으로 포인트의 최상의 분포를 미리 알 수있는 방법이 없을 수 있습니다. 또는 최상의 분포를 선택할 자유가없는 실험에서 비롯된 것일 수도 있습니다. &lt;code&gt;trapz&lt;/code&gt; 사용할 때이 문제를 알고 있어야합니다 .</target>
        </trans-unit>
        <trans-unit id="dffaabcf7d222942a470679a2d89f533082f9f08" translate="yes" xml:space="preserve">
          <source>In general, the first argument in a method definition is always the object that it is called from. Class methods can either be called by passing the object as the first argument to that method or by calling the object followed by a dot (&quot;&lt;code&gt;.&lt;/code&gt;&quot;) and the method&amp;rsquo;s name with subsequent arguments:</source>
          <target state="translated">일반적으로 메소드 정의의 첫 번째 인수는 항상 호출되는 오브젝트입니다. 클래스 메소드는 오브젝트를 해당 메소드에 대한 첫 번째 인수로 전달하거나 오브젝트 다음에 점 ( &quot;)을 호출하여 호출 할 수 &lt;code&gt;.&lt;/code&gt; &quot;)과 후속 인수가있는 메소드 이름을 .</target>
        </trans-unit>
        <trans-unit id="d8283e2d2b0e3ad5d0a6a3e80b86e018c2dfccd1" translate="yes" xml:space="preserve">
          <source>In general, user-defined classes should overload the &lt;code&gt;disp&lt;/code&gt; method to avoid the default output:</source>
          <target state="translated">일반적으로 사용자 정의 클래스는 &lt;code&gt;disp&lt;/code&gt; 를 오버로드해야합니다. 기본 출력을 피하기 위해 메소드를 합니다.</target>
        </trans-unit>
        <trans-unit id="b7dbf5a05108d044ae63fcd1fda983b7280f62e2" translate="yes" xml:space="preserve">
          <source>In index expressions the keyword &lt;code&gt;end&lt;/code&gt; automatically refers to the last entry for a particular dimension. This magic index can also be used in ranges and typically eliminates the needs to call &lt;code&gt;size&lt;/code&gt; or &lt;code&gt;length&lt;/code&gt; to gather array bounds before indexing. For example:</source>
          <target state="translated">인덱스 표현식에서 키워드 &lt;code&gt;end&lt;/code&gt; 는 자동으로 특정 차원의 마지막 항목을 참조합니다. 이 매직 인덱스는 범위 내에서도 사용할 수 있으며 일반적으로 &lt;code&gt;size&lt;/code&gt; 나 &lt;code&gt;length&lt;/code&gt; 를 호출 할 필요가 없습니다. 인덱싱하기 전에 배열 경계를 수집하기 위해 를 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e5887d25cc956d3db003e5390a14d12006ffd4be" translate="yes" xml:space="preserve">
          <source>In its simplest form, the definition of a function named &lt;var&gt;name&lt;/var&gt; looks like this:</source>
          <target state="translated">가장 간단한 형태로 &lt;var&gt;name&lt;/var&gt; 이라는 함수의 정의 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="68647321955f89a6ba82da9c050191c4a8606bf2" translate="yes" xml:space="preserve">
          <source>In many cases one function needs to access one or more helper functions. If the helper function is limited to the scope of a single function, then subfunctions as discussed above might be used. However, if a single helper function is used by more than one function, then this is no longer possible. In this case the helper functions might be placed in a subdirectory, called &quot;private&quot;, of the directory in which the functions needing access to this helper function are found.</source>
          <target state="translated">많은 경우 하나의 함수가 하나 이상의 도우미 함수에 액세스해야합니다. 도우미 기능이 단일 기능의 범위로 제한되면 위에서 설명한 하위 기능이 사용될 수 있습니다. 그러나 둘 이상의 함수가 단일 도우미 함수를 사용하면 더 이상 사용할 수 없습니다. 이 경우, 헬퍼 기능은이 헬퍼 기능에 액세스해야하는 기능이있는 디렉토리의 &quot;private&quot;이라는 서브 디렉토리에 위치 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fe8aebde5aae28ef447087c9f992c36de4950076" translate="yes" xml:space="preserve">
          <source>In more detail, an input conversion specification consists of an initial &amp;lsquo;</source>
          <target state="translated">보다 구체적으로, 입력 변환 사양은 초기 '</target>
        </trans-unit>
        <trans-unit id="9551a5c980428a21443621580dcce1b476b5803c" translate="yes" xml:space="preserve">
          <source>In more detail, output conversion specifications consist of an initial &amp;lsquo;</source>
          <target state="translated">보다 상세하게, 출력 변환 사양은 초기 '</target>
        </trans-unit>
        <trans-unit id="70b026bea3b18e803f73e45599cb3cd1129237c7" translate="yes" xml:space="preserve">
          <source>In most cases, the &lt;code&gt;nchoosek&lt;/code&gt; function is faster for small scalar integer arguments. It also warns about loss of precision for big arguments.</source>
          <target state="translated">대부분의 경우, &lt;code&gt;nchoosek&lt;/code&gt; 함수는 작은 스칼라 정수 인수에 대해 더 빠릅니다. 또한 큰 논증의 정확성 상실에 대해 경고합니다.</target>
        </trans-unit>
        <trans-unit id="363319d97fddd4554ac83dbfde390625fbf24af0" translate="yes" xml:space="preserve">
          <source>In most cases, the following functions simply decode their arguments and make the corresponding Unix system calls. For a complete example of how they can be used, look at the definition of the function &lt;code&gt;popen2&lt;/code&gt;.</source>
          <target state="translated">대부분의 경우 다음 함수는 단순히 인수를 해독하여 해당 Unix 시스템 호출을 수행합니다. 그것들이 어떻게 사용될 수 있는지에 대한 완전한 예를 보려면, &lt;code&gt;popen2&lt;/code&gt; 함수의 정의를보십시오 .</target>
        </trans-unit>
        <trans-unit id="19a13264ef052fd4fc1c049fa15898d41e751705" translate="yes" xml:space="preserve">
          <source>In most cases, you will also want to get some information back from the functions you define. Here is the syntax for writing a function that returns a single value:</source>
          <target state="translated">대부분의 경우 정의한 함수에서 일부 정보를 다시 얻으려고합니다. 단일 값을 반환하는 함수를 작성하는 구문은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3e472a6e46779b705dd4cff9d228dcad63bd391d" translate="yes" xml:space="preserve">
          <source>In much the same way a package can be removed from the Octave path by typing</source>
          <target state="translated">거의 같은 방식으로 다음을 입력하여 패키지를 옥타브 경로에서 제거 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="2c1eff95acb20c930eda9801a9eb9cc7c053fd6c" translate="yes" xml:space="preserve">
          <source>In order for a bug report to serve its purpose, you must include the information that makes it possible to fix the bug.</source>
          <target state="translated">버그 보고서가 목적에 부합하도록하려면 버그를 수정할 수있는 정보를 포함시켜야합니다.</target>
        </trans-unit>
        <trans-unit id="30aeb4af3f1b0b0721e4004b9cee8cbaad1a5d19" translate="yes" xml:space="preserve">
          <source>In order to change the contents of the object a &lt;code&gt;subsasgn&lt;/code&gt; method is needed. For example, the following code makes the polynomial field publicly writable</source>
          <target state="translated">객체의 내용을 변경하기 위해 &lt;code&gt;subsasgn&lt;/code&gt; 방법이 필요합니다. 예를 들어 다음 코드는 다항식 필드를 공개적으로 쓸 수있게합니다.</target>
        </trans-unit>
        <trans-unit id="5ab5af88f3872b0f31b668293f7fc9533a276e89" translate="yes" xml:space="preserve">
          <source>In order to execute Java code Octave creates a Java Virtual Machine (JVM). By default the version of the JVM is used that was detected during configuration on Unix-like systems or that is pointed to from the registry keys at</source>
          <target state="translated">Java 코드를 실행하기 위해 Octave는 JVM (Java Virtual Machine)을 작성합니다. 기본적으로 JVM 버전은 Unix 계열 시스템에서 구성하는 동안 발견되었거나 다음 위치의 레지스트리 키에서 가리키는 JVM이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="60ff32114a2c77ff44be1d0affa1fe8d410f2380" translate="yes" xml:space="preserve">
          <source>In order to get good help you first need to know the name of the command that you want to use. The name of this function may not always be obvious, but a good place to start is to type &lt;code&gt;help --list&lt;/code&gt;. This will show you all the operators, keywords, built-in functions, and loadable functions available in the current session of Octave. An alternative is to search the documentation using the &lt;code&gt;lookfor&lt;/code&gt; function (described in &lt;a href=&quot;getting-help#Getting-Help&quot;&gt;Getting Help&lt;/a&gt;).</source>
          <target state="translated">도움을 받으려면 먼저 사용하려는 명령의 이름을 알아야합니다. 이 함수의 이름이 항상 명확한 것은 아니지만 시작하기에 좋은 곳은 &lt;code&gt;help --list&lt;/code&gt; 를 입력 하는 것 입니다. 현재 옥타브 세션에서 사용할 수있는 모든 연산자, 키워드, 내장 함수 및로드 가능한 함수가 표시됩니다. 대안을 이용하여 문서를 검색 할 &lt;code&gt;lookfor&lt;/code&gt; 함수 (에 기재된&lt;a href=&quot;getting-help#Getting-Help&quot;&gt; 도움말 얻기&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="63fe6800074be8d7e2c0e642a562474ffb03f3e1" translate="yes" xml:space="preserve">
          <source>In order to motivate this application, we consider the boundary value Laplace equation. This system can model scalar potential fields, such as heat or electrical potential. Given a medium Omega with boundary dOmega. At all points on the dOmega the boundary conditions are known, and we wish to calculate the potential in Omega. Boundary conditions may specify the potential (Dirichlet boundary condition), its normal derivative across the boundary (Neumann boundary condition), or a weighted sum of the potential and its derivative (Cauchy boundary condition).</source>
          <target state="translated">이 응용 프로그램에 동기를 부여하기 위해 경계 값 Laplace 방정식을 고려합니다. 이 시스템은 열 또는 전위와 같은 스칼라 전위 필드를 모델링 할 수 있습니다. 경계 dOmega가있는 중간 오메가가 주어집니다. dOmega의 모든 지점에서 경계 조건이 알려져 있으며 Omega의 잠재력을 계산하려고합니다. 경계 조건은 전위 (Dirichlet 경계 조건), 경계를 가로 지르는 정규 미분 (Neumann 경계 조건) 또는 전위와 그 미분의 가중 합 (코치 경계 조건)을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="71d47710c3105debc3c8f52e7dc1f0a129273332" translate="yes" xml:space="preserve">
          <source>In other words, for &lt;var&gt;t&lt;/var&gt; &amp;gt; &lt;var&gt;k&lt;/var&gt;, &lt;code&gt;[1, &lt;var&gt;y&lt;/var&gt;(&lt;var&gt;t&lt;/var&gt;-1), &amp;hellip;, &lt;var&gt;y&lt;/var&gt;(&lt;var&gt;t&lt;/var&gt;-&lt;var&gt;k&lt;/var&gt;)]&lt;/code&gt; is the t-th row of the result.</source>
          <target state="translated">즉, &lt;var&gt;t&lt;/var&gt; &amp;gt; &lt;var&gt;k&lt;/var&gt; 에 대해 &lt;code&gt;[1, &lt;var&gt;y&lt;/var&gt;(&lt;var&gt;t&lt;/var&gt;-1), &amp;hellip;, &lt;var&gt;y&lt;/var&gt;(&lt;var&gt;t&lt;/var&gt;-&lt;var&gt;k&lt;/var&gt;)]&lt;/code&gt; 는 결과의 t 번째 행입니다.</target>
        </trans-unit>
        <trans-unit id="0438d072ff863ac57faf7ca26f3f4cc98bf6ab32" translate="yes" xml:space="preserve">
          <source>In other words, it is equivalent to the following code:</source>
          <target state="translated">즉, 다음 코드와 동일합니다.</target>
        </trans-unit>
        <trans-unit id="57c2afee37ae9077207c5de72e1a68a8e39ecbaa" translate="yes" xml:space="preserve">
          <source>In other words, the statement</source>
          <target state="translated">즉, 진술</target>
        </trans-unit>
        <trans-unit id="4604d3e4c26b8ac01aa105ff6ab4344d22814f52" translate="yes" xml:space="preserve">
          <source>In programming, a &lt;em&gt;loop&lt;/em&gt; means a part of a program that is (or at least can be) executed two or more times in succession.</source>
          <target state="translated">프로그래밍에서 &lt;em&gt;루프&lt;/em&gt; 는 연속해서 두 번 이상 실행되는 (또는 적어도 실행될 수있는) 프로그램의 일부를 의미합니다.</target>
        </trans-unit>
        <trans-unit id="5c06c7037a0caa7cd63b388b5d86090484b13919" translate="yes" xml:space="preserve">
          <source>In scripts the two different string types can be distinguished if necessary by using &lt;code&gt;is_dq_string&lt;/code&gt; and &lt;code&gt;is_sq_string&lt;/code&gt;.</source>
          <target state="translated">스크립트에서 필요한 경우 &lt;code&gt;is_dq_string&lt;/code&gt; 및 &lt;code&gt;is_sq_string&lt;/code&gt; 을 사용하여 두 개의 다른 문자열 유형을 구별 할 수 있습니다. .</target>
        </trans-unit>
        <trans-unit id="85f7530b695ed5c62bb10f25dd3c5295f3a26a8d" translate="yes" xml:space="preserve">
          <source>In situations where a single polynomial isn&amp;rsquo;t good enough, a solution is to use several polynomials pieced together. The function &lt;code&gt;splinefit&lt;/code&gt; fits a piecewise polynomial (spline) to a set of data.</source>
          <target state="translated">단일 다항식이 충분하지 않은 상황에서 해결책은 여러 다항식을 함께 사용하는 것입니다. 함수 &lt;code&gt;splinefit&lt;/code&gt; 스플라인 는 데이터 집합에 조각 별 다항식 (스플라인)을 맞 춥니 다.</target>
        </trans-unit>
        <trans-unit id="337dfa5a887e8e472def1508c3a4ca2a39d558d3" translate="yes" xml:space="preserve">
          <source>In some cases, matrix values that are returned by expressions are displayed like this</source>
          <target state="translated">경우에 따라 표현식에서 반환되는 행렬 값은 다음과 같이 표시됩니다</target>
        </trans-unit>
        <trans-unit id="226cb65291b07ca0c99d2d386b60a9e06819ebde" translate="yes" xml:space="preserve">
          <source>In such cases, it is possible suppress errors for specific statements by writing them with an extra set of parentheses. For example, writing the previous example as</source>
          <target state="translated">이러한 경우 추가 괄호로 특정 명령문을 작성하여 특정 명령문의 오류를 억제 할 수 있습니다. 예를 들어 이전 예제를 다음과 같이 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="ce21f586d1f665010168ceaea46535b780ebcb41" translate="yes" xml:space="preserve">
          <source>In summary, most image processing code will follow the structure of this code</source>
          <target state="translated">요약하면 대부분의 이미지 처리 코드는이 코드의 구조를 따릅니다.</target>
        </trans-unit>
        <trans-unit id="43a035d8cb4dcc881871499a93bf1c9b1d3fad11" translate="yes" xml:space="preserve">
          <source>In terms of the Z Transform, &lt;var&gt;y&lt;/var&gt; is the result of passing the discrete-time signal &lt;var&gt;x&lt;/var&gt; through a system characterized by the following rational system function:</source>
          <target state="translated">Z 변환의 관점에서, &lt;var&gt;y&lt;/var&gt; 는 다음과 같은 합리적인 시스템 기능을 특징으로하는 시스템을 통해 이산 시간 신호 &lt;var&gt;x&lt;/var&gt; 를 전달한 결과입니다 .</target>
        </trans-unit>
        <trans-unit id="b6abefb0ebc02351d5d08f8505d9c39811bfa807" translate="yes" xml:space="preserve">
          <source>In the</source>
          <target state="translated">에서</target>
        </trans-unit>
        <trans-unit id="bbb04efc026d389e45bb1d5cff0c1e14d5a55903" translate="yes" xml:space="preserve">
          <source>In the Octave language, a comment starts with either the sharp sign character, &amp;lsquo;</source>
          <target state="translated">옥타브 언어에서 주석은 날카로운 기호 문자 '</target>
        </trans-unit>
        <trans-unit id="5703e9bab7533d3a7c9333a0bf5c12b9474f468d" translate="yes" xml:space="preserve">
          <source>In the Octave language, most statements end with a newline character and you must tell Octave to ignore the newline character in order to continue a statement from one line to the next. Lines that end with the characters &lt;code&gt;...&lt;/code&gt; are joined with the following line before they are divided into tokens by Octave&amp;rsquo;s parser. For example, the lines</source>
          <target state="translated">Octave 언어에서 대부분의 명령문은 개행 문자로 끝나며 한 행에서 다음 행으로 명령문을 계속하려면 개행 문자를 무시하도록 Octave에 지시해야합니다. 문자로 끝나는 줄 &lt;code&gt;...&lt;/code&gt; 그들은 옥타브의 파서 토큰으로 분할하기 전에 다음 라인으로 연결된다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="f0fed091f2d4ffe00c21969771eb72d2428f3173" translate="yes" xml:space="preserve">
          <source>In the above case, the multi-dimensional matrix &lt;var&gt;c&lt;/var&gt; is reshaped to a two-dimensional matrix as &lt;code&gt;reshape (c, rows (c), prod (size (c)(2:end)))&lt;/code&gt; and then the same behavior as a loop over a two-dimensional matrix is produced.</source>
          <target state="translated">위의 경우, 다차원 행렬 &lt;var&gt;c&lt;/var&gt; 는 2 차원 행렬 &lt;code&gt;reshape (c, rows (c), prod (size (c)(2:end)))&lt;/code&gt; 차원 행렬로 재구성 되고 루프와 동일한 동작 2 차원 매트릭스를 통해 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="4d6e71a578832d2ac9f270d962451b148f8b0a25" translate="yes" xml:space="preserve">
          <source>In the array mask case, both &lt;var&gt;tval&lt;/var&gt; and &lt;var&gt;fval&lt;/var&gt; must be either scalars or arrays with dimensions equal to &lt;var&gt;mask&lt;/var&gt;. The result is constructed as follows:</source>
          <target state="translated">배열 마스크의 경우 &lt;var&gt;tval&lt;/var&gt; 과 &lt;var&gt;fval&lt;/var&gt; 은 모두 스칼라이거나 &lt;var&gt;mask&lt;/var&gt; 와 크기가 같은 배열이어야합니다 . 결과는 다음과 같이 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="8bb8edb2a7db30bbcb708fb3c707327782ed95ba" translate="yes" xml:space="preserve">
          <source>In the case of an asymmetric matrix, the appropriate sparsity preserving permutation is &lt;em&gt;colamd&lt;/em&gt; and the factorization using this reordering can be visualized using the command &lt;code&gt;q = colamd (A); [l, u, p] = lu (A(:,q)); spy (l+u)&lt;/code&gt;.</source>
          <target state="translated">비대칭 행렬의 경우, 적절한 희소성 보존 순열을 &lt;em&gt;칭량&lt;/em&gt; 하고이 순서를 사용한 인수 분해는 &lt;code&gt;q = colamd (A); [l, u, p] = lu (A(:,q)); spy (l+u)&lt;/code&gt; 명령을 사용하여 시각화 할 수 있습니다 . [l, u, p] = lu (A (:, q)); 스파이 (l + u) .</target>
        </trans-unit>
        <trans-unit id="a04c413c2088df8ecf3c674bb305bef628cfc0f3" translate="yes" xml:space="preserve">
          <source>In the case of an error, the string &lt;var&gt;msg&lt;/var&gt; will return the text of the error.</source>
          <target state="translated">오류가 발생하면 문자열 &lt;var&gt;msg&lt;/var&gt; 는 오류 텍스트를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="347dae530f110203be4d82754669e735bb095d15" translate="yes" xml:space="preserve">
          <source>In the case of mixed type indexed assignments, the type is not changed. For example,</source>
          <target state="translated">혼합 유형 인덱싱 된 할당의 경우 유형이 변경되지 않습니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="ca15f3231f206ff6494e1dbe89241c8b699f4ea4" translate="yes" xml:space="preserve">
          <source>In the case where &lt;var&gt;x&lt;/var&gt; is a square matrix, the polynomial given by &lt;var&gt;c&lt;/var&gt; is still well-defined. As when &lt;var&gt;x&lt;/var&gt; is a scalar the obvious implementation is easily expressed in Octave, but also in this case more elegant algorithms perform better. The &lt;code&gt;polyvalm&lt;/code&gt; function provides such an algorithm.</source>
          <target state="translated">경우에 &lt;var&gt;x&lt;/var&gt; 정방 행렬이며, 주어진 다항식 &lt;var&gt;c&lt;/var&gt; 아직 명확하게 정의된다. 때대로 &lt;var&gt;x&lt;/var&gt; 명백한 구현이 용이 옥타브로 표현되는 스칼라이지만,이 경우에 더 고급 알고리즘을 더 수행한다. 그만큼 &lt;code&gt;polyvalm&lt;/code&gt; 의 기능은 알고리즘을 제공한다.</target>
        </trans-unit>
        <trans-unit id="4ea0f149665b670ba23297b7870ef9f8709fa3e4" translate="yes" xml:space="preserve">
          <source>In the descriptions of the following functions, &lt;var&gt;z&lt;/var&gt; is the complex number &lt;var&gt;x&lt;/var&gt; + &lt;var&gt;i&lt;/var&gt;&lt;var&gt;y&lt;/var&gt;, where &lt;var&gt;i&lt;/var&gt; is defined as &lt;code&gt;sqrt (-1)&lt;/code&gt;.</source>
          <target state="translated">다음 함수의 설명에서 &lt;var&gt;z&lt;/var&gt; 는 복소수 &lt;var&gt;x&lt;/var&gt; + &lt;var&gt;i&lt;/var&gt; &lt;var&gt;y&lt;/var&gt; 이며 여기서 &lt;var&gt;i&lt;/var&gt; 는 다음과 같이 정의됩니다. &lt;code&gt;sqrt (-1)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="11947900e8e351231349859f6e48062eaeb9fab9" translate="yes" xml:space="preserve">
          <source>In the descriptions of the following functions, this data structure is referred to as a &lt;var&gt;grp_struct&lt;/var&gt;.</source>
          <target state="translated">이하의 기능의 설명에서,이 데이터 구조는 &lt;var&gt;grp_struct&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="cfb43776f2335fe426a14360b7422d39dd636905" translate="yes" xml:space="preserve">
          <source>In the descriptions of the following functions, this data structure is referred to as a &lt;var&gt;pw_struct&lt;/var&gt;.</source>
          <target state="translated">다음 함수에 대한 설명에서이 데이터 구조를 &lt;var&gt;pw_struct&lt;/var&gt; 라고합니다. .</target>
        </trans-unit>
        <trans-unit id="c4439f688e2c4919a169a170a437102ffc9c8d6f" translate="yes" xml:space="preserve">
          <source>In the descriptions of the following functions, this structure is referred to as a &lt;var&gt;tm_struct&lt;/var&gt;.</source>
          <target state="translated">다음 함수에 대한 설명에서이 구조를 &lt;var&gt;tm_struct&lt;/var&gt; 라고합니다. .</target>
        </trans-unit>
        <trans-unit id="79e15fe1454e1b2cff5f15773ba5948c603e79db" translate="yes" xml:space="preserve">
          <source>In the example above, the first line indicates that a variable named &amp;lsquo;</source>
          <target state="translated">위의 예에서 첫 번째 줄은 '</target>
        </trans-unit>
        <trans-unit id="4ce989efdfd5df8e7594500fe43c38c514f7372a" translate="yes" xml:space="preserve">
          <source>In the examples in this manual, results from expressions that you evaluate are indicated with &amp;lsquo;</source>
          <target state="translated">이 매뉴얼의 예제에서 평가 한 표현식의 결과는 '</target>
        </trans-unit>
        <trans-unit id="ee5a1bf15ba07b40baf02c4f839a538ce3cce544" translate="yes" xml:space="preserve">
          <source>In the first assignment, the right-hand side is &lt;code&gt;[]&lt;/code&gt; which is a special null value. As long as the index &lt;var&gt;I&lt;/var&gt; is not empty, this code should delete elements from &lt;var&gt;A&lt;/var&gt; rather than perform assignment.</source>
          <target state="translated">첫 번째 할당에서 오른쪽 은 특수 null 값인 &lt;code&gt;[]&lt;/code&gt; 입니다. 색인 &lt;var&gt;I&lt;/var&gt; 가 비어 있지 않으면이 코드는 요소를 삭제해야합니다. &lt;var&gt;A&lt;/var&gt; 할당을 수행하기보다는 A 합니다.</target>
        </trans-unit>
        <trans-unit id="d15952ac26887ee4c0e44e0a8d38bfd8f0e3862a" translate="yes" xml:space="preserve">
          <source>In the first form, program execution is suspended until the graphics object &lt;var&gt;h&lt;/var&gt; is destroyed. If the graphics handle is invalid or if &lt;var&gt;h&lt;/var&gt; is the root figure handle and no property &lt;var&gt;prop&lt;/var&gt; was provided, the function returns immediately.</source>
          <target state="translated">제 1 형태에서, 프로그램 실행은 그래픽스 객체 &lt;var&gt;h&lt;/var&gt; 가 파괴 될 때까지 정지된다 . 그래픽스 핸들이 유효하지 않거나 &lt;var&gt;h&lt;/var&gt; 가 루트 도형 핸들이고 속성이없는 경우 &lt;var&gt;prop&lt;/var&gt; 이 제공 경우 함수는 즉시 반환합니다.</target>
        </trans-unit>
        <trans-unit id="8b3eb722f69675c00f7d02c8de75d2659b0b21ee" translate="yes" xml:space="preserve">
          <source>In the first form, program execution is suspended until the graphics object &lt;var&gt;h&lt;/var&gt; is destroyed. If the graphics handle is invalid or if &lt;var&gt;h&lt;/var&gt; is the root graphics handle and no property &lt;var&gt;prop&lt;/var&gt; was provided, the function returns immediately.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ead297caf361b33c15ec7bdb29b32c28ca9cab6" translate="yes" xml:space="preserve">
          <source>In the first form, read from &lt;var&gt;fid&lt;/var&gt; according to &lt;var&gt;template&lt;/var&gt;, returning the result in the matrix &lt;var&gt;val&lt;/var&gt;.</source>
          <target state="translated">첫 번째 양식에서 &lt;var&gt;template&lt;/var&gt; 에 따라 &lt;var&gt;fid&lt;/var&gt; 에서 읽고 행렬 &lt;var&gt;val&lt;/var&gt; 에 결과를 반환합니다. .</target>
        </trans-unit>
        <trans-unit id="de5d0fa1fcdf3e05f7ec6cebd7136ce4ad8af1ed" translate="yes" xml:space="preserve">
          <source>In the first form, return an error if the number of arguments is not between &lt;var&gt;minargs&lt;/var&gt; and &lt;var&gt;maxargs&lt;/var&gt;. Otherwise, do nothing. Note that this function evaluates the value of &lt;code&gt;nargout&lt;/code&gt; on the caller so its value must have not been tampered with.</source>
          <target state="translated">첫 번째 형식에서 인수 수가 &lt;var&gt;minargs&lt;/var&gt; 와 &lt;var&gt;maxargs&lt;/var&gt; 사이에 있지 않으면 오류를 반환하십시오 . 그렇지 않으면 아무것도하지 마십시오. 이 함수 는 호출자 의 &lt;code&gt;nargout&lt;/code&gt; 값을 평가 하므로 해당 값이 변경되지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="5539311e03e7236f27edb235b9c771095e58c77d" translate="yes" xml:space="preserve">
          <source>In the first form, the word consists of the longest run consisting of only characters between the brackets. Ranges of characters can be specified by a hyphen; for example, %[0-9a-zA-Z] matches all alphanumeric characters (if the underlying character set is ASCII). Since &lt;small&gt;MATLAB&lt;/small&gt; treats hyphens literally, this expansion only applies to alphanumeric characters. To include &amp;rsquo;-&amp;rsquo; in the set, it should appear first or last in the brackets; to include &amp;rsquo;]&amp;rsquo;, it should be the first character. If the first character is &amp;rsquo;^&amp;rsquo; then the word consists of characters &lt;strong&gt;not&lt;/strong&gt; listed.</source>
          <target state="translated">첫 번째 형태에서 단어는 대괄호 사이의 문자로만 구성된 가장 긴 런으로 구성됩니다. 문자 범위는 하이픈으로 지정할 수 있습니다. 예를 들어 % [0-9a-zA-Z]는 모든 영숫자 문자 (기본 문자 집합이 ASCII 인 경우)와 일치합니다. 이후 &lt;small&gt;MATLAB의&lt;/small&gt; 취급 그대로 하이픈이 확장은 영숫자 문자 만 적용됩니다. 세트에 '-'를 포함 시키려면 괄호 안에 처음 또는 마지막에 나타나야합니다. ']'를 포함하려면 첫 번째 문자 여야합니다. 첫 번째 문자가 '^'인 경우 단어는 나열 &lt;strong&gt;되지 않은&lt;/strong&gt; 문자로 구성 됩니다.</target>
        </trans-unit>
        <trans-unit id="511e1f1e0ec90fd969199b37548de8eb31233977" translate="yes" xml:space="preserve">
          <source>In the following documentation default values are enclosed in { }.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b6e65864a987073d9a0578a7b07727dc271679b" translate="yes" xml:space="preserve">
          <source>In the following documentation, default values are enclosed in { }.</source>
          <target state="translated">다음 문서에서 기본값은 {}로 묶습니다.</target>
        </trans-unit>
        <trans-unit id="9f9cbe1be1c11faf09af0689e8cbb71790a7c790" translate="yes" xml:space="preserve">
          <source>In the following example, if the first condition is true (that is, the value of &lt;code&gt;x&lt;/code&gt; is divisible by 2), then the first &lt;code&gt;printf&lt;/code&gt; statement is executed. If it is false, then the second condition is tested, and if it is true (that is, the value of &lt;code&gt;x&lt;/code&gt; is divisible by 3), then the second &lt;code&gt;printf&lt;/code&gt; statement is executed. Otherwise, the third &lt;code&gt;printf&lt;/code&gt; statement is performed.</source>
          <target state="translated">다음 예제에서 첫 번째 조건이 true 인 경우 (즉, &lt;code&gt;x&lt;/code&gt; 값을 2로 나눌 수있는 경우) 첫 번째 &lt;code&gt;printf&lt;/code&gt; 문이 실행됩니다. False이면 두 번째 조건이 테스트되고, 참이면 (즉, &lt;code&gt;x&lt;/code&gt; 의 값을 3으로 나눌 수 있음) 두 번째 &lt;code&gt;printf&lt;/code&gt; 문이 실행됩니다. 그렇지 않으면, 세 번째 &lt;code&gt;printf&lt;/code&gt; 문이 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="467479998ee4f90fea3c9361ae2e8bb22fbb66ba" translate="yes" xml:space="preserve">
          <source>In the following example, the variables &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; refer to the very same object of class &lt;code&gt;handle_class&lt;/code&gt;:</source>
          <target state="translated">다음 예제에서 변수 &lt;code&gt;a&lt;/code&gt; 와 &lt;code&gt;b&lt;/code&gt; 는 &lt;code&gt;handle_class&lt;/code&gt; 클래스의 동일한 객체를 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="9179e002650dab186f6f921ce4a68a092eaf6df1" translate="yes" xml:space="preserve">
          <source>In the following, &lt;var&gt;file&lt;/var&gt; refers to a filename and &lt;code&gt;fid&lt;/code&gt; refers to an integer file number, as returned by &lt;code&gt;fopen&lt;/code&gt;.</source>
          <target state="translated">다음에서 &lt;var&gt;file&lt;/var&gt; 은 파일 이름을 나타내고 &lt;code&gt;fid&lt;/code&gt; 는 &lt;code&gt;fopen&lt;/code&gt; 에서 반환 된 정수 파일 번호를 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="9b1119ee143b6ffd5b232c9e303f7bfb1e8c5732" translate="yes" xml:space="preserve">
          <source>In the formal argument list, it is possible to use the dummy placeholder &lt;code&gt;~&lt;/code&gt; instead of a name. This indicates that the corresponding argument value should be ignored and not stored to any variable.</source>
          <target state="translated">공식적인 인수 목록에서, 더미 자리를 사용할 수 있습니다 &lt;code&gt;~&lt;/code&gt; 이름 대신 . 이는 해당 인수 값을 무시하고 변수에 저장하지 않아야 함을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="5fbba66befd556a2fd3f4cabfd63742dc45c70b8" translate="yes" xml:space="preserve">
          <source>In the function body the input arguments can be accessed through the variable &lt;code&gt;varargin&lt;/code&gt;. This variable is a cell array containing all the input arguments. See &lt;a href=&quot;cell-arrays#Cell-Arrays&quot;&gt;Cell Arrays&lt;/a&gt;, for details on working with cell arrays. The &lt;code&gt;smallest&lt;/code&gt; function can now be defined like this</source>
          <target state="translated">함수 본문에서 변수 &lt;code&gt;varargin&lt;/code&gt; 을 통해 입력 인수에 액세스 할 수 있습니다 . 이 변수는 모든 입력 인수를 포함하는 셀형 배열입니다. &lt;a href=&quot;cell-arrays#Cell-Arrays&quot;&gt;셀형 배열&lt;/a&gt; 작업에 대한 자세한 내용 은 셀형 배열을 참조하십시오 . &lt;code&gt;smallest&lt;/code&gt; 기능은 이제 다음과 같이 정의 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="f0309d1a2b28aca483feab26146f90d603178c8c" translate="yes" xml:space="preserve">
          <source>In the low-level calling form (50% higher performance) where the data is specified by name (&lt;code&gt;line (&quot;xdata&quot;, &lt;var&gt;x&lt;/var&gt;, &amp;hellip;)&lt;/code&gt;) the data must be vectors. If no data is specified (&lt;code&gt;line ()&lt;/code&gt;) then &lt;code&gt;&lt;var&gt;x&lt;/var&gt;&amp;nbsp;==&amp;nbsp;&lt;var&gt;y&lt;/var&gt;&amp;nbsp;=&amp;nbsp;[0,&amp;nbsp;1]&lt;/code&gt;.</source>
          <target state="translated">데이터가 이름 ( &lt;code&gt;line (&quot;xdata&quot;, &lt;var&gt;x&lt;/var&gt;, &amp;hellip;)&lt;/code&gt; ) 으로 지정되는 저수준 호출 양식 (50 % 더 높은 성능)에서 데이터는 벡터 여야합니다. 데이터가 지정되지 않은 경우 ( &lt;code&gt;line ()&lt;/code&gt; ) &lt;code&gt;&lt;var&gt;x&lt;/var&gt;&amp;nbsp;==&amp;nbsp;&lt;var&gt;y&lt;/var&gt;&amp;nbsp;=&amp;nbsp;[0,&amp;nbsp;1]&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="80749d9fedc2c7c1c3c963a1eed5c583eec3613f" translate="yes" xml:space="preserve">
          <source>In the result, element with certain indices is equal to the corresponding element of &lt;var&gt;x&lt;/var&gt; if the indices are within the bounds of &lt;var&gt;x&lt;/var&gt;; otherwise, the element is set to zero.</source>
          <target state="translated">결과에서 소정의 인덱스로 소자의 대응하는 요소와 동일하다 &lt;var&gt;x&lt;/var&gt; 인덱스가의 범위 내에있는 경우 &lt;var&gt;x&lt;/var&gt; ; 그렇지 않으면 요소가 0으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="0a4dce901c9d7a3a218ffdf8751a70b42f83cf01" translate="yes" xml:space="preserve">
          <source>In the second assignment, the right-hand side is empty (because &lt;var&gt;X&lt;/var&gt; is &lt;code&gt;[]&lt;/code&gt;), but it is &lt;strong&gt;not&lt;/strong&gt; null. This code should assign the empty value to elements in &lt;var&gt;A&lt;/var&gt;.</source>
          <target state="translated">두 번째 대입에서 오른쪽은 비어 있지만 ( &lt;var&gt;X&lt;/var&gt; 는 &lt;code&gt;[]&lt;/code&gt; 이므로 ) null 이 &lt;strong&gt;아닙니다&lt;/strong&gt; . 이 코드는 빈 값을 &lt;var&gt;A&lt;/var&gt; 의 요소에 할당해야합니다 .</target>
        </trans-unit>
        <trans-unit id="f720ed751e1f909ed0920b50771ab2bcc4b0166d" translate="yes" xml:space="preserve">
          <source>In the second form of the call, available options are specified directly with their default values given as name-value pairs. If &lt;var&gt;params&lt;/var&gt; do not form name-value pairs, or if an option occurs that does not match any of the available options, an error occurs.</source>
          <target state="translated">두 번째 호출 양식에서 사용 가능한 옵션은 이름-값 쌍으로 제공된 기본값으로 직접 지정됩니다. 만약 &lt;var&gt;params&lt;/var&gt; 이름 - 값 쌍을 형성하지 않거나 옵션이 발생하는 경우 그 사용 가능한 옵션 중 하나를 일치하지 않는 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="f3a3a9775766161b181d42885b570d36ef1aacf2" translate="yes" xml:space="preserve">
          <source>In the second form, execution is suspended until the graphics object is destroyed or the property named &lt;var&gt;prop&lt;/var&gt; is modified. If the graphics handle is invalid or the property does not exist, the function returns immediately.</source>
          <target state="translated">두 번째 형태에서는 그래픽스 객체가 손상되거나 &lt;var&gt;prop&lt;/var&gt; 이라는 속성 이 수정 될 때까지 실행이 일시 중단 됩니다. 그래픽스 핸들이 유효하지 않거나 속성이 존재하지 않으면 함수는 즉시 반환합니다.</target>
        </trans-unit>
        <trans-unit id="1702c91d247ee8ef591654b2ecef8777d34bfa2f" translate="yes" xml:space="preserve">
          <source>In the second form, read from &lt;var&gt;fid&lt;/var&gt; according to &lt;var&gt;template&lt;/var&gt;, with each conversion specifier in &lt;var&gt;template&lt;/var&gt; corresponding to a single scalar return value. This form is more &amp;ldquo;C-like&amp;rdquo;, and also compatible with previous versions of Octave. The number of successful conversions is returned in &lt;var&gt;count&lt;/var&gt;</source>
          <target state="translated">두 번째 형식에서 &lt;var&gt;template&lt;/var&gt; 에 따라 &lt;var&gt;fid&lt;/var&gt; 에서 읽고 , 각 변환 지정자는 &lt;var&gt;template&lt;/var&gt; 의 각 스칼라 리턴 값에 해당합니다. 이 형식은 &quot;C와 유사&quot;하며 이전 버전의 Octave와 호환됩니다. 성공적인 전환 수는 &lt;var&gt;count&lt;/var&gt; 로 반환됩니다</target>
        </trans-unit>
        <trans-unit id="411076e71647e42d7604581c5b6166e293a6d889" translate="yes" xml:space="preserve">
          <source>In the second usage,</source>
          <target state="translated">두 번째 사용법에서</target>
        </trans-unit>
        <trans-unit id="5f51b73b87e36a197023eba1410ae1ac574725e7" translate="yes" xml:space="preserve">
          <source>In the simplest case, 1) all components are scalars, and 2) the dimensionality of the index expression &lt;em&gt;M&lt;/em&gt; is equal to the dimensionality of the object it is applied to. For example:</source>
          <target state="translated">가장 간단한 경우에, 1)의 모든 구성 요소는 스칼라이고, 2) 인덱스 발현 차원 &lt;em&gt;M은&lt;/em&gt; 그것이 적용되는 객체의 차수와 같다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e8ab1510cdffa9a202236beb73b48b840fa708e0" translate="yes" xml:space="preserve">
          <source>In the standard calling form the data &lt;var&gt;x&lt;/var&gt;, &lt;var&gt;y&lt;/var&gt;, and &lt;var&gt;z&lt;/var&gt; may be scalars, vectors, or matrices. In the case of matrix inputs, &lt;code&gt;line&lt;/code&gt; will attempt to orient scalars and vectors so the results can be plotted. This requires that one of the dimensions of the vector match either the number of rows or the number of columns of the matrix.</source>
          <target state="translated">표준 호출 형식에서 데이터 &lt;var&gt;x&lt;/var&gt; , &lt;var&gt;y&lt;/var&gt; 및 &lt;var&gt;z&lt;/var&gt; 는 스칼라, 벡터 또는 행렬 일 수 있습니다. 행렬 입력의 경우 &lt;code&gt;line&lt;/code&gt; 은 스칼라와 벡터 방향을 지정하여 결과를 그릴 수 있습니다. 이를 위해서는 벡터의 차원 중 하나가 행렬의 행 수 또는 열 수와 일치해야합니다.</target>
        </trans-unit>
        <trans-unit id="642fc1d67b605fc31882810c4f69d7a3d94391aa" translate="yes" xml:space="preserve">
          <source>In the third form, execution is suspended until the graphics object is destroyed or the property named &lt;var&gt;prop&lt;/var&gt; is set to &lt;var&gt;value&lt;/var&gt;. The function &lt;code&gt;isequal&lt;/code&gt; is used to compare property values. If the graphics handle is invalid, the property does not exist or the property is already set to &lt;var&gt;value&lt;/var&gt;, the function returns immediately.</source>
          <target state="translated">세 번째 형태에서는 그래픽스 객체가 소멸되거나 &lt;var&gt;prop&lt;/var&gt; 이라는 속성 이 &lt;var&gt;value&lt;/var&gt; 로 설정 될 때까지 실행이 일시 중단 됩니다. &lt;code&gt;isequal&lt;/code&gt; 함수 는 속성 값을 비교하는 데 사용됩니다. 그래픽 핸들이 유효하지 않거나, 속성이 존재하지 않거나 속성이 이미 &lt;var&gt;value&lt;/var&gt; 로 설정된 경우 , 함수는 즉시 반환합니다.</target>
        </trans-unit>
        <trans-unit id="a789caf834a5e48707dc583669ea2f8cea23fa40" translate="yes" xml:space="preserve">
          <source>In this Section the graphics object properties are discussed in detail, starting with the root figure properties and continuing through the objects hierarchy. The documentation about a specific graphics object can be displayed using &lt;code&gt;doc&lt;/code&gt; function, e.g., &lt;code&gt;doc (&quot;axes properties&quot;)&lt;/code&gt; will show &lt;a href=&quot;axes-properties#Axes-Properties&quot;&gt;Axes Properties&lt;/a&gt;.</source>
          <target state="translated">이 섹션에서 그래픽 객체 속성은 루트 그림 속성부터 시작하여 객체 계층 구조를 통해 자세히 설명됩니다. &lt;code&gt;doc&lt;/code&gt; 기능을 사용하여 특정 그래픽스 객체에 대한 문서를 표시 할 수 있습니다 . 예를 들어 &lt;code&gt;doc (&quot;axes properties&quot;)&lt;/code&gt; 는 &lt;a href=&quot;axes-properties#Axes-Properties&quot;&gt;Axes Properties&lt;/a&gt; 를 표시 합니다.</target>
        </trans-unit>
        <trans-unit id="97b437774f0d27f58d9812db1fca7ce9c1a5b8be" translate="yes" xml:space="preserve">
          <source>In this case a range of algorithms to perform the transform is considered and the best is selected based on their execution time.</source>
          <target state="translated">이 경우 변환을 수행하는 다양한 알고리즘이 고려되며 실행 시간에 따라 최상의 알고리즘이 선택됩니다.</target>
        </trans-unit>
        <trans-unit id="f9ca5e233702b9f026930971b65eb5e9035587e0" translate="yes" xml:space="preserve">
          <source>In this case only version 1.0.0 of the &lt;code&gt;image&lt;/code&gt; package is installed. The &lt;code&gt;'*'&lt;/code&gt; character next to the package name shows that the image package is loaded and ready for use.</source>
          <target state="translated">이 경우 &lt;code&gt;image&lt;/code&gt; 패키지 버전 1.0.0 만 설치됩니다. 패키지 이름 옆 의 &lt;code&gt;'*'&lt;/code&gt; 문자는 이미지 패키지가로드되어 사용할 준비가되었음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="f98883311f42d6a3ac4702316fe843d31b634129" translate="yes" xml:space="preserve">
          <source>In this case the &lt;var&gt;state&lt;/var&gt; argument may only be &lt;code&gt;&quot;on&quot;&lt;/code&gt; or &lt;code&gt;&quot;off&quot;&lt;/code&gt;.</source>
          <target state="translated">이 경우 &lt;var&gt;state&lt;/var&gt; 인수는 &lt;code&gt;&quot;on&quot;&lt;/code&gt; 또는 &lt;code&gt;&quot;off&quot;&lt;/code&gt; 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6596939ba486b2eee735f35294b91d9bd4ba5f3a" translate="yes" xml:space="preserve">
          <source>In this case the variable &lt;code&gt;i&lt;/code&gt; takes on the value of the columns of the matrix or cell matrix. So the first loop iterates twice, producing two column vectors &lt;code&gt;[1;2]&lt;/code&gt;, followed by &lt;code&gt;[3;4]&lt;/code&gt;, and likewise for the loop over the cell array. This can be extended to loops over multi-dimensional arrays. For example:</source>
          <target state="translated">이 경우 변수 &lt;code&gt;i&lt;/code&gt; 는 행렬 또는 셀 행렬의 열 값을 갖습니다. 따라서 첫 번째 루프는 두 번 반복되어 두 개의 열 벡터 &lt;code&gt;[1;2]&lt;/code&gt; ,이어서 &lt;code&gt;[3;4]&lt;/code&gt; 가 생성되며 셀 배열에 대한 루프도 마찬가지입니다. 이것은 다차원 배열의 루프로 확장 될 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="94bdb27518366c8ecf41a14aa393a994688a7b0b" translate="yes" xml:space="preserve">
          <source>In this case, &lt;code&gt;&lt;var&gt;x&lt;/var&gt; = &lt;var&gt;A&lt;/var&gt; \ &lt;var&gt;b&lt;/var&gt;&lt;/code&gt; finds a particular solution &lt;var&gt;x&lt;/var&gt;. The general solution is &lt;var&gt;x&lt;/var&gt; plus the null space of matrix &lt;var&gt;A&lt;/var&gt;. The function &lt;code&gt;null&lt;/code&gt; may be used to compute a basis of the null space.</source>
          <target state="translated">이 경우 &lt;code&gt;&lt;var&gt;x&lt;/var&gt; = &lt;var&gt;A&lt;/var&gt; \ &lt;var&gt;b&lt;/var&gt;&lt;/code&gt; 는 특정 해 &lt;var&gt;x&lt;/var&gt; 를 찾습니다 . 일반적인 해는 &lt;var&gt;x&lt;/var&gt; 에 행렬 &lt;var&gt;A&lt;/var&gt; 의 영 공간을 더한 값 입니다. 널 공간의 기초를 계산하기 위해 &lt;code&gt;null&lt;/code&gt; 함수 가 사용될 수있다.</target>
        </trans-unit>
        <trans-unit id="b92e0a6abf074fa15d25641aebc263a0c6e0234c" translate="yes" xml:space="preserve">
          <source>In this case, Octave itself will worry about reference counting and variable scope and will properly free memory without programmer intervention.</source>
          <target state="translated">이 경우 Octave 자체는 참조 횟수 및 가변 범위에 대해 걱정하며 프로그래머의 개입없이 메모리를 적절히 비 웁니다.</target>
        </trans-unit>
        <trans-unit id="711b51c020cc7113789cad7120112467a906c687" translate="yes" xml:space="preserve">
          <source>In this case, the function that will be executed within Octave will be given by the mex-file, while the help string will come from the m-file. This can also be useful to allow a sample implementation of the mex-file within the Octave language itself for testing purposes.</source>
          <target state="translated">이 경우 Octave 내에서 실행될 함수는 mex 파일에 의해 제공되는 반면 help 문자열은 m 파일에서 제공됩니다. 또한 테스트 목적으로 Octave 언어 자체에서 mex 파일의 샘플 구현을 허용하는 데 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f7d4e642f316a4a24742227ad7bd9fe89c252b14" translate="yes" xml:space="preserve">
          <source>In this case, the number of columns of &lt;var&gt;values&lt;/var&gt; must match the number of elements in &lt;var&gt;properties&lt;/var&gt;. The first column of &lt;var&gt;values&lt;/var&gt; contains values for the first entry in &lt;var&gt;properties&lt;/var&gt;, etc. The number of rows of &lt;var&gt;values&lt;/var&gt; must be 1 or match the number of elements of &lt;var&gt;h&lt;/var&gt;. In the first case, each handle in &lt;var&gt;h&lt;/var&gt; will be assigned the same values. In the latter case, the first handle in &lt;var&gt;h&lt;/var&gt; will be assigned the values from the first row of &lt;var&gt;values&lt;/var&gt; and so on.</source>
          <target state="translated">이 경우 &lt;var&gt;values&lt;/var&gt; 의 열 수는 &lt;var&gt;properties&lt;/var&gt; 의 요소 수와 일치해야합니다 . 첫 번째 열의 &lt;var&gt;values&lt;/var&gt; 첫 번째 항목에 대한 값을 포함하는 &lt;var&gt;properties&lt;/var&gt; 등의 행수, &lt;var&gt;values&lt;/var&gt; 1 일 또는 소자의 수와 일치해야 &lt;var&gt;h&lt;/var&gt; . 첫 번째 경우 &lt;var&gt;h&lt;/var&gt; 의 각 핸들 에는 동일한 값이 할당됩니다. 후자의 경우에서, 제 1 핸들 &lt;var&gt;h&lt;/var&gt; 첫 번째 행의 값을 할당 할 &lt;var&gt;values&lt;/var&gt; 과에 있도록.</target>
        </trans-unit>
        <trans-unit id="f2dff70503fbf7f20603b229f7b1f3f27a388993" translate="yes" xml:space="preserve">
          <source>In this case, the test will run and any failure will be reported. However, testing is not aborted and subsequent test blocks will be processed normally. Another use of &lt;code&gt;xtest&lt;/code&gt; is for statistical tests which should pass most of the time but are known to fail occasionally.</source>
          <target state="translated">이 경우 테스트가 실행되고 모든 실패가보고됩니다. 그러나 테스트는 중단되지 않으며 후속 테스트 블록은 정상적으로 처리됩니다. &lt;code&gt;xtest&lt;/code&gt; 의 또 다른 용도는 대부분의 시간을 통과해야하지만 때때로 실패하는 것으로 알려진 통계 테스트입니다.</target>
        </trans-unit>
        <trans-unit id="ee35fb26254a3ca84ec9d88d29ed877e1bcf5a83" translate="yes" xml:space="preserve">
          <source>In this example &lt;code&gt;S&lt;/code&gt; contains the smoothed image, and &lt;code&gt;Dx&lt;/code&gt; and &lt;code&gt;Dy&lt;/code&gt; contains the partial spatial derivatives of the image.</source>
          <target state="translated">이 예에서, &lt;code&gt;S&lt;/code&gt; 는 평활화 된 이미지를 포함하고, &lt;code&gt;Dx&lt;/code&gt; 및 &lt;code&gt;Dy&lt;/code&gt; 는 이미지의 부분 공간 도함수를 포함한다.</target>
        </trans-unit>
        <trans-unit id="e52a3097c2d91f5be0cc16cd2f271a436fdfaa19" translate="yes" xml:space="preserve">
          <source>In this example both &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; would be 1. One way to write the &lt;code&gt;smallest&lt;/code&gt; function is</source>
          <target state="translated">이 예에서 &lt;code&gt;a&lt;/code&gt; 와 &lt;code&gt;b&lt;/code&gt; 는 모두 1입니다. &lt;code&gt;smallest&lt;/code&gt; 함수 를 작성하는 한 가지 방법 은</target>
        </trans-unit>
        <trans-unit id="0de615d44f976a94b7ba04ca367be7bc866e6289" translate="yes" xml:space="preserve">
          <source>In this example, if the expression &lt;code&gt;rem (x, 2) == 0&lt;/code&gt; is true (that is, the value of &lt;code&gt;x&lt;/code&gt; is divisible by 2), then the first &lt;code&gt;printf&lt;/code&gt; statement is evaluated, otherwise the second &lt;code&gt;printf&lt;/code&gt; statement is evaluated.</source>
          <target state="translated">이 예제에서 &lt;code&gt;rem (x, 2) == 0&lt;/code&gt; 표현식 이 true 인 경우 (즉, &lt;code&gt;x&lt;/code&gt; 의 값을 2로 나눌 수 있음) 첫 번째 &lt;code&gt;printf&lt;/code&gt; 문이 평가되고, 그렇지 않으면 두 번째 &lt;code&gt;printf&lt;/code&gt; 문이 평가됩니다.</target>
        </trans-unit>
        <trans-unit id="5d0c9fd4333bb6ada103ca1dfe6f07c5edfd5adc" translate="yes" xml:space="preserve">
          <source>In this example, the number of linearly independent rows is only 2 because the final row is a linear combination of the first two rows:</source>
          <target state="translated">이 예에서 마지막 행은 처음 두 행의 선형 조합이므로 선형 독립 행 수는 2입니다.</target>
        </trans-unit>
        <trans-unit id="9ef298b3f67967705be05b6013baf296bb8b538d" translate="yes" xml:space="preserve">
          <source>In this form of the &lt;code&gt;for&lt;/code&gt; statement, the value of &lt;var&gt;expression&lt;/var&gt; must be a structure. If it is, &lt;var&gt;key&lt;/var&gt; and &lt;var&gt;val&lt;/var&gt; are set to the name of the element and the corresponding value in turn, until there are no more elements. For example:</source>
          <target state="translated">이 형식의 &lt;code&gt;for&lt;/code&gt; 문에서 &lt;var&gt;expression&lt;/var&gt; 의 값은 구조 여야합니다. 이 경우 &lt;var&gt;key&lt;/var&gt; 와 &lt;var&gt;val&lt;/var&gt; 은 더 이상 요소가 없을 때까지 요소 이름과 해당 값으로 차례로 설정됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a1588fc5c3080e50762516405c025eb89897a4fd" translate="yes" xml:space="preserve">
          <source>In this particular case, the two values could have been returned as elements of a single array, but that is not always possible or convenient. The values to be returned may not have compatible dimensions, and it is often desirable to give the individual return values distinct names.</source>
          <target state="translated">이 경우 두 값이 단일 배열의 요소로 리턴 될 수 있었지만 항상 가능하거나 편리하지는 않습니다. 반환되는 값은 호환되는 차원을 갖지 않을 수 있으며 개별 반환 값에 고유 한 이름을 지정하는 것이 바람직합니다.</target>
        </trans-unit>
        <trans-unit id="05326d9ef1fe4ddbb75a4c5df378b877a1c3de97" translate="yes" xml:space="preserve">
          <source>In this section the graphics object properties are discussed in detail, starting with the root properties and continuing through the object hierarchy. The documentation about a specific graphics object can be displayed using &lt;code&gt;doc&lt;/code&gt; function, e.g., &lt;code&gt;doc (&quot;axes properties&quot;)&lt;/code&gt; will show &lt;a href=&quot;axes-properties#Axes-Properties&quot;&gt;Axes Properties&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23b88d0a71c00972dd44eb1ffc9580d7d5212805" translate="yes" xml:space="preserve">
          <source>Include all the comments that are appropriate to help people reading the source in the future understand why this change was needed.</source>
          <target state="translated">앞으로 소스를 읽는 사람들이이 변경이 필요한 이유를 이해하는 데 도움이되는 모든 의견을 포함하십시오.</target>
        </trans-unit>
        <trans-unit id="65d1601192045675af06555968ff92c97a186805" translate="yes" xml:space="preserve">
          <source>Include files distributed with Octave.</source>
          <target state="translated">Octave와 함께 배포 된 파일을 포함시킵니다.</target>
        </trans-unit>
        <trans-unit id="54610970dfb3d89af93803ad964913e5f4fb6e26" translate="yes" xml:space="preserve">
          <source>Included by</source>
          <target state="translated">포함</target>
        </trans-unit>
        <trans-unit id="c06aefbbf64fb9782c07b6b102c18d7b24821686" translate="yes" xml:space="preserve">
          <source>Included for compatibility. Not used. (default 0)</source>
          <target state="translated">호환성을 위해 포함되었습니다. 사용하지 않습니다. (기본 0)</target>
        </trans-unit>
        <trans-unit id="e3186596b007a7daca098a6465feedde9aa0ca8c" translate="yes" xml:space="preserve">
          <source>Included for compatibility. Not used. (default 0.5)</source>
          <target state="translated">호환성을 위해 포함되었습니다. 사용하지 않습니다. (기본 0.5)</target>
        </trans-unit>
        <trans-unit id="9069c57e04c66fc8cae28500e5ee49ec09a71cb9" translate="yes" xml:space="preserve">
          <source>Included for compatibility. Not used. (default 1)</source>
          <target state="translated">호환성을 위해 포함되었습니다. 사용하지 않습니다. (기본 1)</target>
        </trans-unit>
        <trans-unit id="0545f83f954f9921f48f5b371dffcda74604fd2c" translate="yes" xml:space="preserve">
          <source>Included for compatibility. Not used. (default 3)</source>
          <target state="translated">호환성을 위해 포함되었습니다. 사용하지 않습니다. (기본 3)</target>
        </trans-unit>
        <trans-unit id="8fdd8ece850ef78dc6e4491ed7385b240b5edbc6" translate="yes" xml:space="preserve">
          <source>Including File Content</source>
          <target state="translated">파일 내용 포함</target>
        </trans-unit>
        <trans-unit id="12fd56448d7c1e964a7c22b6c373d7d644758b66" translate="yes" xml:space="preserve">
          <source>Including Graphics</source>
          <target state="translated">그래픽 포함</target>
        </trans-unit>
        <trans-unit id="e057f434b62e3f0ae1cd4de1459f7b88e6eaffca" translate="yes" xml:space="preserve">
          <source>Including URLs</source>
          <target state="translated">URL 포함</target>
        </trans-unit>
        <trans-unit id="72834e4e17ec6f14ec77899d6b1a7d183966951a" translate="yes" xml:space="preserve">
          <source>Incomplete Cholesky factorization with no fill-in (IC(0)).</source>
          <target state="translated">필인이없는 불완전한 Cholesky 분해 (IC (0)).</target>
        </trans-unit>
        <trans-unit id="3f7ce096c9c40086903b2d2496bd4b411cb1edc7" translate="yes" xml:space="preserve">
          <source>Incomplete Cholesky factorization with threshold dropping (ICT).</source>
          <target state="translated">임계 값 드롭 (ICT)으로 불완전한 Cholesky 분해.</target>
        </trans-unit>
        <trans-unit id="a580e36ac71f53635997066b118c42f5bf57f05c" translate="yes" xml:space="preserve">
          <source>Increasing the Reliability of Adaptive Quadrature Using Explicit Interpolants</source>
          <target state="translated">명시 적 보간법을 사용하여 적응 구적법의 신뢰성 향상</target>
        </trans-unit>
        <trans-unit id="881291c106b69c3b1dfc507a02de30e69a2d1e11" translate="yes" xml:space="preserve">
          <source>Increment Operators</source>
          <target state="translated">증분 연산자</target>
        </trans-unit>
        <trans-unit id="4061ca27e7a24fb698de78907ad04fa27d3b727d" translate="yes" xml:space="preserve">
          <source>Increment Ops</source>
          <target state="translated">증분 작전</target>
        </trans-unit>
        <trans-unit id="7f755e41ce627af0222ceee4e0d6d2f3858e3aab" translate="yes" xml:space="preserve">
          <source>Index Entry</source>
          <target state="translated">색인 입력</target>
        </trans-unit>
        <trans-unit id="71c97279cf83fc58467572ececa55bdae6e798a5" translate="yes" xml:space="preserve">
          <source>Index Expressions</source>
          <target state="translated">인덱스 표현식</target>
        </trans-unit>
        <trans-unit id="63ac1b4d37f88c9257b699b22921543205cf4e8b" translate="yes" xml:space="preserve">
          <source>Index manipulation</source>
          <target state="translated">인덱스 조작</target>
        </trans-unit>
        <trans-unit id="c05e82732b4cfa9f6913e4ff6abd0b1afc55905a" translate="yes" xml:space="preserve">
          <source>Indexed Assignment Optimization</source>
          <target state="translated">인덱스 할당 최적화</target>
        </trans-unit>
        <trans-unit id="6f9a774d181dff5ea0cefb880b084cde4c56dfcc" translate="yes" xml:space="preserve">
          <source>Indexed assignment with such a null value on the right-hand side should delete array elements. This function is used in place of &lt;code&gt;isempty&lt;/code&gt; when overloading the indexed assignment method (&lt;code&gt;subsasgn&lt;/code&gt;) for user-defined classes. &lt;code&gt;isnull&lt;/code&gt; is used to distinguish between these two cases:</source>
          <target state="translated">오른쪽에 이러한 null 값이있는 인덱스 할당은 배열 요소를 삭제해야합니다. 이 함수 대신 사용한 &lt;code&gt;isempty&lt;/code&gt; 인덱싱 할당 방법 (과부하시 &lt;code&gt;subsasgn&lt;/code&gt; 사용자 정의 된 클래스들에 대한 참조). &lt;code&gt;isnull&lt;/code&gt; 은이 두 경우를 구별하는 데 사용됩니다</target>
        </trans-unit>
        <trans-unit id="d12d6ee0a5533fb0912c4566b13b5aeff1469a2c" translate="yes" xml:space="preserve">
          <source>Indexing Cell Arrays</source>
          <target state="translated">인덱싱 셀형 배열</target>
        </trans-unit>
        <trans-unit id="604a7a773690164fab1cc0640a7cbfac5c506a30" translate="yes" xml:space="preserve">
          <source>Indexing Objects</source>
          <target state="translated">인덱싱 객체</target>
        </trans-unit>
        <trans-unit id="800849664812edde30d8b9dbd1b419cf5a1f634d" translate="yes" xml:space="preserve">
          <source>Indicates a call to a function that is not defined. The function may exist but Octave is unable to find it in the search path.</source>
          <target state="translated">정의되지 않은 함수에 대한 호출을 나타냅니다. 기능이 존재할 수 있지만 Octave가 검색 경로에서 찾을 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="6ba231095a613a8cf86cc4ace6f851ac90c2674b" translate="yes" xml:space="preserve">
          <source>Indicates that a data-type was indexed incorrectly, e.g., real-value index for arrays, nonexistent field of a structure.</source>
          <target state="translated">데이터 유형이 배열에 존재하지 않는 배열의 실제 값 색인과 같이 잘못 색인화되었음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="8c15b8950a910b2e14797141ae5d92b18c66e715" translate="yes" xml:space="preserve">
          <source>Indicates that a function was called in an incorrect way, e.g., wrong number of input arguments.</source>
          <target state="translated">함수가 잘못된 수의 입력 인수와 같이 잘못된 방식으로 호출되었음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="65391eca3cb6873179afed70381b5ef62271a43f" translate="yes" xml:space="preserve">
          <source>Indicates that a function was called with invalid input arguments.</source>
          <target state="translated">유효하지 않은 입력 인수로 함수가 호출되었음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="175a598c93f1a66174c35970a8c5333e074c7636" translate="yes" xml:space="preserve">
          <source>Indicates that memory couldn&amp;rsquo;t be allocated.</source>
          <target state="translated">메모리를 할당 할 수 없음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="ba9d914b46ae6d112883ad497a8ef32d87a65bcd" translate="yes" xml:space="preserve">
          <source>Indicates the error was generated by an operation that cannot be executed in the scope from which it was called. For example, the function &lt;code&gt;print_usage ()&lt;/code&gt; when called from the Octave prompt raises this error.</source>
          <target state="translated">호출 된 범위에서 실행할 수없는 조작으로 오류가 생성되었음을 나타냅니다. 예를 들어 Octave 프롬프트에서 호출 될 때 &lt;code&gt;print_usage ()&lt;/code&gt; 함수 가이 오류를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="45f418781f5ba14f3a84c3bb99a59f3448d5dfb7" translate="yes" xml:space="preserve">
          <source>Indices may be scalars, vectors, ranges, or the special operator &amp;lsquo;</source>
          <target state="translated">인덱스는 스칼라, 벡터, 범위 또는 특수 연산자 '</target>
        </trans-unit>
        <trans-unit id="cb59924857768a48ed57e9e3929ae4cb63db282e" translate="yes" xml:space="preserve">
          <source>Indices of elements of the state vector to be passed to the output monitoring function.</source>
          <target state="translated">출력 모니터링 기능에 전달할 상태 벡터 요소의 인덱스.</target>
        </trans-unit>
        <trans-unit id="4185066794bf9deaa0564a765b5ee26984a17847" translate="yes" xml:space="preserve">
          <source>Indices of the frames in &lt;var&gt;mov&lt;/var&gt; that will be displayed.</source>
          <target state="translated">&lt;var&gt;mov&lt;/var&gt; 에서 표시 될 프레임의 인덱스 .</target>
        </trans-unit>
        <trans-unit id="a9e30e2654f1a72ed14621e6d809e8e98d718c9b" translate="yes" xml:space="preserve">
          <source>Individual elements of the structure array can be returned by indexing the variable like &lt;code&gt;&lt;var&gt;x&lt;/var&gt;(1)&lt;/code&gt;, which returns a structure with two fields:</source>
          <target state="translated">&lt;code&gt;&lt;var&gt;x&lt;/var&gt;(1)&lt;/code&gt; 과 같은 변수를 색인화하여 구조 배열의 개별 요소를 리턴 할 수 있습니다 . 그러면 두 개의 필드가있는 구조가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="a1d71ca242908209d7ea479076e7d5102e909486" translate="yes" xml:space="preserve">
          <source>Inf</source>
          <target state="translated">Inf</target>
        </trans-unit>
        <trans-unit id="3061eeadc501b7f962c60e5adb721dc1c457ce3c" translate="yes" xml:space="preserve">
          <source>Inf (&amp;hellip;, class)</source>
          <target state="translated">Inf (&amp;hellip;, 수업)</target>
        </trans-unit>
        <trans-unit id="b08bf59bb870a4a83bb31693e361bdf9a978d09c" translate="yes" xml:space="preserve">
          <source>Inf (n)</source>
          <target state="translated">Inf (n)</target>
        </trans-unit>
        <trans-unit id="64843c19f5c18011ef099ce9ba235cf203c2836d" translate="yes" xml:space="preserve">
          <source>Inf (n, m)</source>
          <target state="translated">Inf (n, m)</target>
        </trans-unit>
        <trans-unit id="aef6028292980955c227bd74c8e4490d52f415a8" translate="yes" xml:space="preserve">
          <source>Inf (n, m, k, &amp;hellip;)</source>
          <target state="translated">Inf (n, m, k,&amp;hellip;)</target>
        </trans-unit>
        <trans-unit id="c4dad01495f7a80fb891c30240cd48ae45c8ebcc" translate="yes" xml:space="preserve">
          <source>Infinity is produced when results are too large to be represented using the IEEE floating point format for numbers. Two common examples which produce infinity are division by zero and overflow.</source>
          <target state="translated">결과가 너무 커서 숫자로 IEEE 부동 소수점 형식을 사용하여 표현할 수없는 경우 무한대가 생성됩니다. 무한대를 생성하는 두 가지 일반적인 예는 0으로 나누기와 오버플로입니다.</target>
        </trans-unit>
        <trans-unit id="2b8096ac64af2ebe915cbe27765cd05e48a1b647" translate="yes" xml:space="preserve">
          <source>Infinity norm, the largest row sum of the absolute values of &lt;var&gt;A&lt;/var&gt;.</source>
          <target state="translated">무한 표준, &lt;var&gt;A&lt;/var&gt; 의 절대 값의 가장 큰 행 합 .</target>
        </trans-unit>
        <trans-unit id="083278e880dfe3fac60de06e4a641721df8655e3" translate="yes" xml:space="preserve">
          <source>Info files describing Octave.</source>
          <target state="translated">Octave를 설명하는 정보 파일.</target>
        </trans-unit>
        <trans-unit id="0eb5ed506e4923c28d7f4a8aa69efe99b3ad75d1" translate="yes" xml:space="preserve">
          <source>Information</source>
          <target state="translated">Information</target>
        </trans-unit>
        <trans-unit id="a3aae5282cec49a94bfc0fa0cf74a8d3329ae326" translate="yes" xml:space="preserve">
          <source>Information about a function or variable such as its location in the file system can also be acquired from within Octave. This is usually only useful during development of programs, and not within a program.</source>
          <target state="translated">파일 시스템에서의 위치와 같은 함수 또는 변수에 대한 정보는 Octave 내에서 얻을 수도 있습니다. 이것은 일반적으로 프로그램이 아닌 프로그램 개발 중에 만 유용합니다.</target>
        </trans-unit>
        <trans-unit id="4f69b87a9fc684b624743d91a629a012e098bf2f" translate="yes" xml:space="preserve">
          <source>Information structure returned from &lt;code&gt;stat&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;stat&lt;/code&gt; 에서 반환 된 정보 구조 .</target>
        </trans-unit>
        <trans-unit id="fdaddb9ce367c2ca746a97cc24d2e8817a51f27d" translate="yes" xml:space="preserve">
          <source>Inheritance</source>
          <target state="translated">Inheritance</target>
        </trans-unit>
        <trans-unit id="fd273097ac7c821e482c35d0ac283acd816fe8a3" translate="yes" xml:space="preserve">
          <source>Inheritance and Aggregation</source>
          <target state="translated">상속 및 집계</target>
        </trans-unit>
        <trans-unit id="eef8931850e3ffa73ba8dc211cc2308c76931660" translate="yes" xml:space="preserve">
          <source>Initial time step size.</source>
          <target state="translated">초기 시간 단계 크기.</target>
        </trans-unit>
        <trans-unit id="f87c93356c7e3527ef6eaef186128958cec43b4b" translate="yes" xml:space="preserve">
          <source>Initialization expression for function argument values. Use &lt;var&gt;k&lt;/var&gt; for the test number and &lt;var&gt;n&lt;/var&gt; for the size of the test. This should compute values for all variables used by &lt;var&gt;f&lt;/var&gt;. Note that &lt;var&gt;init&lt;/var&gt; will be evaluated first for &lt;em&gt;k = 0&lt;/em&gt;, so things which are constant throughout the test series can be computed once. The default value is &lt;code&gt;&lt;var&gt;x&lt;/var&gt; = randn (&lt;var&gt;n&lt;/var&gt;, 1)&lt;/code&gt;.</source>
          <target state="translated">함수 인수 값의 초기화 표현식. 테스트 번호는 &lt;var&gt;k&lt;/var&gt; 를, 테스트 크기는 &lt;var&gt;n&lt;/var&gt; 을 사용하십시오 . &lt;var&gt;f&lt;/var&gt; 가 사용하는 모든 변수의 값을 계산해야합니다 . 참고 &lt;var&gt;init&lt;/var&gt; 먼저 평가되는 &lt;em&gt;K = 0&lt;/em&gt; 시험 시리즈에 걸쳐 상수 것들 번 계산 될 수 있도록. 기본값은 &lt;code&gt;&lt;var&gt;x&lt;/var&gt; = randn (&lt;var&gt;n&lt;/var&gt;, 1)&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="aafc0d3ec3a9adf6b409ba51fecde9ee145b6363" translate="yes" xml:space="preserve">
          <source>Initialize a wall-clock timer.</source>
          <target state="translated">벽시계 타이머를 초기화합니다.</target>
        </trans-unit>
        <trans-unit id="0a3cc4e5aee9e8da0102c7cf3568bfceea0d4cc9" translate="yes" xml:space="preserve">
          <source>Inline Function</source>
          <target state="translated">인라인 기능</target>
        </trans-unit>
        <trans-unit id="b60019f47df04ae92897fa912c6748a6013313fa" translate="yes" xml:space="preserve">
          <source>Inline Functions</source>
          <target state="translated">인라인 함수</target>
        </trans-unit>
        <trans-unit id="26d8a12b03e81a73e136958e39938541ddcb777a" translate="yes" xml:space="preserve">
          <source>Input Conversion Syntax</source>
          <target state="translated">입력 변환 구문</target>
        </trans-unit>
        <trans-unit id="1b906d134f9587138bd1ced8c1bf3603522007e4" translate="yes" xml:space="preserve">
          <source>Input Parameter Checking in Oct-Files</source>
          <target state="translated">Oct 파일에서 입력 매개 변수 확인</target>
        </trans-unit>
        <trans-unit id="9577c15a328d9dece0ed4eff29cd79ab3bd98953" translate="yes" xml:space="preserve">
          <source>Input and Output</source>
          <target state="translated">입력과 출력</target>
        </trans-unit>
        <trans-unit id="15c36baf16dbdea83c26ebdfbdc7532355f2b3d4" translate="yes" xml:space="preserve">
          <source>Input arguments are specified in form of &lt;var&gt;key&lt;/var&gt;, &lt;var&gt;value&lt;/var&gt; pairs. The &lt;code&gt;&quot;ListString&quot;&lt;/code&gt; argument pair &lt;strong&gt;must&lt;/strong&gt; be specified.</source>
          <target state="translated">입력 인수는 다음 형식으로 지정됩니다. &lt;var&gt;key&lt;/var&gt; , &lt;var&gt;value&lt;/var&gt; pair . &lt;code&gt;&quot;ListString&quot;&lt;/code&gt; 인수 쌍은 &lt;strong&gt;있어야&lt;/strong&gt; 지정할 수.</target>
        </trans-unit>
        <trans-unit id="92141474d4a27359fe08996c20d3bbdc8b52b951" translate="yes" xml:space="preserve">
          <source>Input arguments:</source>
          <target state="translated">입력 인수 :</target>
        </trans-unit>
        <trans-unit id="69a1b0b6bab047eea8be25533b3930d55a33a65c" translate="yes" xml:space="preserve">
          <source>Input error, return &lt;code&gt;NaN&lt;/code&gt;.</source>
          <target state="translated">입력 오류가 반환 &lt;code&gt;NaN&lt;/code&gt; 이를 .</target>
        </trans-unit>
        <trans-unit id="7aa91cd73281a13b46a3cc00a4748c45ba203c07" translate="yes" xml:space="preserve">
          <source>Input parameters:</source>
          <target state="translated">입력 매개 변수 :</target>
        </trans-unit>
        <trans-unit id="bb93216448c59d56447272c2a4582870652ab9bb" translate="yes" xml:space="preserve">
          <source>Input that occurs inside parentheses can be continued to the next line without having to use a continuation marker. For example, it is possible to write statements like</source>
          <target state="translated">괄호 안에있는 입력은 연속 표시자를 사용하지 않고도 다음 줄로 계속 진행할 수 있습니다. 예를 들어, 다음과 같은 문장을 작성할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="aac0a36e6a493b5ef0dea6738a304e844b28d9aa" translate="yes" xml:space="preserve">
          <source>Input-output functions.</source>
          <target state="translated">입출력 기능.</target>
        </trans-unit>
        <trans-unit id="bbcf64a3a280c2e26bbf0237d5f1affec0d56857" translate="yes" xml:space="preserve">
          <source>Inputs</source>
          <target state="translated">Inputs</target>
        </trans-unit>
        <trans-unit id="fcadc5a2f2ce33e2ebb11bf51a1dd2322a5a729a" translate="yes" xml:space="preserve">
          <source>Inputs:</source>
          <target state="translated">Inputs:</target>
        </trans-unit>
        <trans-unit id="07f2b92624c2360f9888ededd31161b93f3b6d71" translate="yes" xml:space="preserve">
          <source>Insert a tab character.</source>
          <target state="translated">탭 문자를 삽입하십시오.</target>
        </trans-unit>
        <trans-unit id="6c1b2b5dd0206aab999e8c5e7596c47681f7b0b8" translate="yes" xml:space="preserve">
          <source>Insert blank lines above and below column number labels and between matrices to produce a more readable output with less data per page.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f495731d67a90ba79d3c0672ad9fb86232c729eb" translate="yes" xml:space="preserve">
          <source>Insert blank lines above and below column number labels and between matrices to produce a more readable output with less data per page. (default).</source>
          <target state="translated">열 번호 레이블 위와 아래 및 행렬 사이에 빈 줄을 삽입하여 페이지 당 적은 데이터로 더 읽기 쉬운 출력을 생성하십시오. (기본).</target>
        </trans-unit>
        <trans-unit id="d2e0fa20733984c5cda9b80b4d43835c0d8e44ff" translate="yes" xml:space="preserve">
          <source>Inside double-quoted string constants, the character &lt;code&gt;\&lt;/code&gt; has to be used as continuation marker. The &lt;code&gt;\&lt;/code&gt; must appear at the end of the line just before the newline character:</source>
          <target state="translated">큰 따옴표로 묶인 문자열 상수 내에서 문자 &lt;code&gt;\&lt;/code&gt; 는 연속 표시 자로 사용해야합니다. &lt;code&gt;\&lt;/code&gt; 는 단지 개행 문자 앞에 줄의 끝에서 나타나야합니다 :</target>
        </trans-unit>
        <trans-unit id="ef538aaaf6ebb60bfaa5b134fe3867a3baa655ad" translate="yes" xml:space="preserve">
          <source>Inside the square brackets that delimit a matrix expression, Octave looks at the surrounding context to determine whether spaces and newline characters should be converted into element and row separators, or simply ignored, so an expression like</source>
          <target state="translated">행렬 표현식을 구분하는 대괄호 안에서 옥타브는 주변 컨텍스트를보고 공백과 개행 문자를 요소와 행 구분자로 변환해야하는지 아니면 단순히 무시해야하는지 결정합니다.</target>
        </trans-unit>
        <trans-unit id="a60cbb316565a573f83114fe195b3708a0fa1fc4" translate="yes" xml:space="preserve">
          <source>Install Octave in subdirectories below &lt;var&gt;prefix&lt;/var&gt;. The default value of &lt;var&gt;prefix&lt;/var&gt; is</source>
          <target state="translated">&lt;var&gt;prefix&lt;/var&gt; 아래의 서브 디렉토리에 Octave를 설치하십시오 . &lt;var&gt;prefix&lt;/var&gt; 의 기본값 은</target>
        </trans-unit>
        <trans-unit id="987177b6af763309e113b03b94c2798c85d1151b" translate="yes" xml:space="preserve">
          <source>Install a different &lt;small&gt;BLAS&lt;/small&gt; library such as OpenBLAS or ATLAS to correct this issue.</source>
          <target state="translated">이 문제를 해결하려면 OpenBLAS 또는 ATLAS와 같은 다른 &lt;small&gt;BLAS&lt;/small&gt; 라이브러리를 설치 하십시오.</target>
        </trans-unit>
        <trans-unit id="2993f0f64c4f878d819ad8a0c2bd40c57f843865" translate="yes" xml:space="preserve">
          <source>Install a package directly from the Octave Forge repository. This requires an internet connection and the cURL library.</source>
          <target state="translated">Octave Forge 저장소에서 직접 패키지를 설치하십시오. 인터넷 연결 및 cURL 라이브러리가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="88fb6bacb4b440ec75a2678adfa7f624dfc56310" translate="yes" xml:space="preserve">
          <source>Install named packages. For example,</source>
          <target state="translated">명명 된 패키지를 설치하십시오. 예를 들어</target>
        </trans-unit>
        <trans-unit id="c81b79df3c6448eae7c4f80428b54cd5692a17d7" translate="yes" xml:space="preserve">
          <source>Installation</source>
          <target state="translated">Installation</target>
        </trans-unit>
        <trans-unit id="7989d21e50324845d106c157ca9121af45d745e8" translate="yes" xml:space="preserve">
          <source>Installing and Removing Packages</source>
          <target state="translated">패키지 설치 및 제거</target>
        </trans-unit>
        <trans-unit id="3e53df7c1a3f3848605e4165ed851e900f620c3a" translate="yes" xml:space="preserve">
          <source>Instances include matrix indexing, except for extracting a single element or a leading submatrix, indexed assignment, or applying most mapper functions, such as &lt;em&gt;exp&lt;/em&gt;.</source>
          <target state="translated">인스턴스에는 단일 요소 또는 선행 하위 행렬 추출, 인덱스 할당 또는 &lt;em&gt;exp&lt;/em&gt; 와 같은 대부분의 매퍼 함수 적용을 제외하고 매트릭스 인덱싱이 포함됩니다 .</target>
        </trans-unit>
        <trans-unit id="c957f0cd1ef5c9a10386cd7aeab5c3fdf2e02e16" translate="yes" xml:space="preserve">
          <source>Instead of creating the &lt;code&gt;idx&lt;/code&gt; array it is possible to replace &lt;code&gt;data(idx)&lt;/code&gt; with &lt;code&gt;data(&amp;nbsp;data&amp;nbsp;&amp;lt;=&amp;nbsp;2&amp;nbsp;)&lt;/code&gt; in the above code.</source>
          <target state="translated">&lt;code&gt;idx&lt;/code&gt; 배열 을 만드는 대신 위 코드에서 &lt;code&gt;data(idx)&lt;/code&gt; 를 &lt;code&gt;data(&amp;nbsp;data&amp;nbsp;&amp;lt;=&amp;nbsp;2&amp;nbsp;)&lt;/code&gt; 로 바꿀 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5fc1f53e13ad5cb1eee3816ef9cf771c9289a5e3" translate="yes" xml:space="preserve">
          <source>Instead of displaying which variables are in memory, it is possible to determine if a given variable is available. That way it is possible to alter the behavior of a program depending on the existence of a variable. The following example illustrates this.</source>
          <target state="translated">메모리에있는 변수를 표시하는 대신 지정된 변수를 사용할 수 있는지 확인할 수 있습니다. 이렇게하면 변수의 존재 여부에 따라 프로그램의 동작을 변경할 수 있습니다. 다음 예제는이를 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="f792a4a4e92965a9b0195bafade6716131a7104e" translate="yes" xml:space="preserve">
          <source>Instead of indexed color data &lt;var&gt;c&lt;/var&gt;, &lt;code&gt;isocolors&lt;/code&gt; can also be called with RGB values &lt;var&gt;r&lt;/var&gt;, &lt;var&gt;g&lt;/var&gt;, &lt;var&gt;b&lt;/var&gt;. If input arguments &lt;var&gt;x&lt;/var&gt;, &lt;var&gt;y&lt;/var&gt;, &lt;var&gt;z&lt;/var&gt; are not given then &lt;code&gt;meshgrid&lt;/code&gt; computed values are used.</source>
          <target state="translated">대신 인덱스 컬러 데이터의 &lt;var&gt;c&lt;/var&gt; , &lt;code&gt;isocolors&lt;/code&gt; 는 또한 RGB 값으로 호출 될 수 &lt;var&gt;r&lt;/var&gt; 에 , &lt;var&gt;g&lt;/var&gt; 를 , &lt;var&gt;b&lt;/var&gt; . 입력 인수 &lt;var&gt;x&lt;/var&gt; , &lt;var&gt;y&lt;/var&gt; , &lt;var&gt;z&lt;/var&gt; 가 제공되지 않으면 &lt;code&gt;meshgrid&lt;/code&gt; 계산 값이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="114ea304a5e23aede2cc09adf1f476f75fa1145d" translate="yes" xml:space="preserve">
          <source>Instead of specifying polygons by matrices &lt;var&gt;x&lt;/var&gt; and &lt;var&gt;y&lt;/var&gt;, it is possible to present a unique list of vertices and then a list of polygon faces created from those vertices. In this case the &lt;code&gt;&quot;Vertices&quot;&lt;/code&gt; matrix will be an Nx2 (2-D patch) or Nx3 (3-D patch). The MxN &lt;code&gt;&quot;Faces&quot;&lt;/code&gt; matrix describes M polygons having N vertices&amp;mdash;each row describes a single polygon and each column entry is an index into the &lt;code&gt;&quot;Vertices&quot;&lt;/code&gt; matrix to identify a vertex. The patch object can be created by directly passing the property/value pairs &lt;code&gt;&quot;Vertices&quot;&lt;/code&gt;/&lt;var&gt;verts&lt;/var&gt;, &lt;code&gt;&quot;Faces&quot;&lt;/code&gt;/&lt;var&gt;faces&lt;/var&gt; as inputs.</source>
          <target state="translated">행렬 &lt;var&gt;x&lt;/var&gt; 및 &lt;var&gt;y&lt;/var&gt; 로 다각형을 지정하는 대신 고유 한 정점 목록을 표시 한 다음 해당 정점에서 작성된 다각형면 목록을 표시 할 수 있습니다. 이 경우 &lt;code&gt;&quot;Vertices&quot;&lt;/code&gt; 매트릭스는 Nx2 (2-D 패치) 또는 Nx3 (3-D 패치)입니다. MxN &lt;code&gt;&quot;Faces&quot;&lt;/code&gt; 행렬은 N 개의 꼭짓점을 가진 M 개의 다각형을 나타냅니다. 각 행은 단일 다각형을 나타내고 각 열 항목은 꼭짓점을 식별하기 위해 &lt;code&gt;&quot;Vertices&quot;&lt;/code&gt; 행렬에 대한 인덱스 입니다. 패치 객체는 속성 / 값 쌍 &lt;code&gt;&quot;Vertices&quot;&lt;/code&gt; / &lt;var&gt;verts&lt;/var&gt; , &lt;code&gt;&quot;Faces&quot;&lt;/code&gt; / &lt;var&gt;faces&lt;/var&gt; 를 입력 으로 직접 전달하여 만들 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="841612ae6ebae1338593f4dedc72549916310fad" translate="yes" xml:space="preserve">
          <source>Instead of the current context, the script may be executed in either the context of the function that called the present function (&lt;code&gt;&quot;caller&quot;&lt;/code&gt;), or the top-level context (&lt;code&gt;&quot;base&quot;&lt;/code&gt;).</source>
          <target state="translated">현재 컨텍스트 대신 현재 함수를 호출 한 함수의 컨텍스트 ( &lt;code&gt;&quot;caller&quot;&lt;/code&gt; ) 또는 최상위 컨텍스트 ( &lt;code&gt;&quot;base&quot;&lt;/code&gt; ) 에서 스크립트를 실행할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="82b9016a43cfbe3fab36287289c0d43dba0d3e78" translate="yes" xml:space="preserve">
          <source>Instead of using property/value pairs, any property can be set by passing a structure &lt;var&gt;propstruct&lt;/var&gt; with the respective field names.</source>
          <target state="translated">속성 / 값 쌍을 사용하는 대신 각 필드 이름과 함께 구조 &lt;var&gt;propstruct&lt;/var&gt; 를 전달하여 모든 속성을 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="683987ee4aeb538cfdf37663a8c0ab7ac90a2019" translate="yes" xml:space="preserve">
          <source>Integer Arithmetic</source>
          <target state="translated">정수 산술</target>
        </trans-unit>
        <trans-unit id="76d810731f55778b9b205c5b368dede7b3459816" translate="yes" xml:space="preserve">
          <source>Integer Conversions</source>
          <target state="translated">정수 변환</target>
        </trans-unit>
        <trans-unit id="4200062b18d471d8d2fa3abf322674fc3d715dbf" translate="yes" xml:space="preserve">
          <source>Integer Data Types</source>
          <target state="translated">정수 데이터 타입</target>
        </trans-unit>
        <trans-unit id="7b4fb6be2361a1ed013cf60a89c0f4ab61cf16ab" translate="yes" xml:space="preserve">
          <source>Integer division with different rounding rules.</source>
          <target state="translated">다른 반올림 규칙이있는 정수 나누기.</target>
        </trans-unit>
        <trans-unit id="a6da27bbcbaa828c9737a0a1fa1aa5d318810f46" translate="yes" xml:space="preserve">
          <source>Integer parameters:</source>
          <target state="translated">정수 매개 변수 :</target>
        </trans-unit>
        <trans-unit id="ca4cad48895284bc515e4868a02e92d4489bbddf" translate="yes" xml:space="preserve">
          <source>Integer value comprising classes (u)int8, (u)int16, (u)int32, (u)int64.</source>
          <target state="translated">(u) int8, (u) int16, (u) int32, (u) int64 클래스를 포함하는 정수 값</target>
        </trans-unit>
        <trans-unit id="f17749bbfb4addccc082217b21b0003132c6281a" translate="yes" xml:space="preserve">
          <source>Integers larger than &lt;code&gt;flintmax&lt;/code&gt; may not be displayed correctly.</source>
          <target state="translated">&lt;code&gt;flintmax&lt;/code&gt; 보다 큰 정수 는 올바르게 표시되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c221ade3db33d04f45cfc13ea2604bcb00899c2e" translate="yes" xml:space="preserve">
          <source>Interacting with Plots</source>
          <target state="translated">플롯과 상호 작용</target>
        </trans-unit>
        <trans-unit id="515e0bdcedfe6773b7bc4b3192becd51fa704935" translate="yes" xml:space="preserve">
          <source>Interactive desktop is running.</source>
          <target state="translated">대화식 데스크톱이 실행 중입니다.</target>
        </trans-unit>
        <trans-unit id="891e39831cee216d8d18383a44ddc4dc0e2fc1ed" translate="yes" xml:space="preserve">
          <source>Interactive graphics program (&lt;a href=&quot;http://www.gnuplot.info&quot;&gt;http://www.gnuplot.info&lt;/a&gt;). gnuplot can be used as a graphics renderer for Octave; prior to Octave 4.0, gnuplot was the default graphics renderer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b4edfa194ce7b36cab8c9b2adf1c792e9847730" translate="yes" xml:space="preserve">
          <source>Interactive graphics program (&lt;a href=&quot;http://www.gnuplot.info&quot;&gt;http://www.gnuplot.info&lt;/a&gt;). gnuplot is currently the default graphics renderer for Octave.</source>
          <target state="translated">대화식 그래픽 프로그램 ( &lt;a href=&quot;http://www.gnuplot.info&quot;&gt;http://www.gnuplot.info&lt;/a&gt; ). gnuplot은 현재 Octave의 기본 그래픽 렌더러입니다.</target>
        </trans-unit>
        <trans-unit id="50dbe314bb7a33f8d98cc35b0de87160d52e6e4d" translate="yes" xml:space="preserve">
          <source>Interactively explore hierarchical profiler output.</source>
          <target state="translated">계층 적 프로파일 러 출력을 대화식으로 탐색합니다.</target>
        </trans-unit>
        <trans-unit id="6233da5a281da628d55bb5e93ed8a89d1ca19e55" translate="yes" xml:space="preserve">
          <source>Interior point method.</source>
          <target state="translated">내부 포인트 방법.</target>
        </trans-unit>
        <trans-unit id="45e79aac82cacf1e75c0073084cb8e8311590ff8" translate="yes" xml:space="preserve">
          <source>Internally a package is simply a gzipped tar file that contains a top level directory of any given name. This directory will in the following be referred to as &lt;code&gt;package&lt;/code&gt; and may contain the following files:</source>
          <target state="translated">내부적으로 패키지는 단순히 지정된 이름의 최상위 디렉토리를 포함하는 gzip 압축 tar 파일입니다. 이 디렉토리는 다음에서 &lt;code&gt;package&lt;/code&gt; 라고 하며 다음 파일을 포함 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4f3608b245750c4a5c9120709a49e418ee9c35aa" translate="yes" xml:space="preserve">
          <source>Internally, &lt;code&gt;pi&lt;/code&gt; is computed as &amp;lsquo;</source>
          <target state="translated">내부적으로 &lt;code&gt;pi&lt;/code&gt; 는 '</target>
        </trans-unit>
        <trans-unit id="7c319313557b773e9cb17e6a7e0b447aef0539ca" translate="yes" xml:space="preserve">
          <source>Interpolate input data to determine the value of &lt;var&gt;yi&lt;/var&gt; at the points &lt;var&gt;xi&lt;/var&gt;. If not specified, &lt;var&gt;x&lt;/var&gt; is taken to be the indices of &lt;var&gt;y&lt;/var&gt; (&lt;code&gt;1:length (&lt;var&gt;y&lt;/var&gt;)&lt;/code&gt;). If &lt;var&gt;y&lt;/var&gt; is a matrix or an N-dimensional array, the interpolation is performed on each column of &lt;var&gt;y&lt;/var&gt;.</source>
          <target state="translated">포인트 &lt;var&gt;xi&lt;/var&gt; 에서 &lt;var&gt;yi&lt;/var&gt; 값을 결정하기 위해 입력 데이터를 보간합니다 . 지정되지 않은 경우 &lt;var&gt;x&lt;/var&gt; 는 &lt;var&gt;y&lt;/var&gt; ( &lt;code&gt;1:length (&lt;var&gt;y&lt;/var&gt;)&lt;/code&gt; &lt;var&gt;y&lt;/var&gt; ) ) 의 인덱스로 간주 됩니다. 경우 &lt;var&gt;y&lt;/var&gt; 는 행렬 또는 N 차원 어레이는, 상기 보간은 각각의 칼럼에 대해 수행된다 &lt;var&gt;y&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="b16f9f0d02ec80cfe5cc2d2f44433f95414140cb" translate="yes" xml:space="preserve">
          <source>Interpolate reference data &lt;var&gt;x&lt;/var&gt;, &lt;var&gt;y&lt;/var&gt;, &lt;var&gt;z&lt;/var&gt; to determine &lt;var&gt;zi&lt;/var&gt; at the coordinates &lt;var&gt;xi&lt;/var&gt;, &lt;var&gt;yi&lt;/var&gt;. The reference data &lt;var&gt;x&lt;/var&gt;, &lt;var&gt;y&lt;/var&gt; can be matrices, as returned by &lt;code&gt;meshgrid&lt;/code&gt;, in which case the sizes of &lt;var&gt;x&lt;/var&gt;, &lt;var&gt;y&lt;/var&gt;, and &lt;var&gt;z&lt;/var&gt; must be equal. If &lt;var&gt;x&lt;/var&gt;, &lt;var&gt;y&lt;/var&gt; are vectors describing a grid then &lt;code&gt;length (&lt;var&gt;x&lt;/var&gt;) == columns (&lt;var&gt;z&lt;/var&gt;)&lt;/code&gt; and &lt;code&gt;length (&lt;var&gt;y&lt;/var&gt;) == rows (&lt;var&gt;z&lt;/var&gt;)&lt;/code&gt;. In either case the input data must be strictly monotonic.</source>
          <target state="translated">참조 데이터 &lt;var&gt;x&lt;/var&gt; , &lt;var&gt;y&lt;/var&gt; , &lt;var&gt;z&lt;/var&gt; 를 보간 하여 좌표 &lt;var&gt;xi&lt;/var&gt; , &lt;var&gt;yi&lt;/var&gt; 에서 &lt;var&gt;zi&lt;/var&gt; 를 결정 합니다. 참조 데이터 &lt;var&gt;x&lt;/var&gt; , &lt;var&gt;y&lt;/var&gt; 는 &lt;code&gt;meshgrid&lt;/code&gt; 에 의해 반환되는 행렬 일 수 있으며, 이 경우 &lt;var&gt;x&lt;/var&gt; , &lt;var&gt;y&lt;/var&gt; 및 &lt;var&gt;z&lt;/var&gt; 의 크기는 같아야합니다. 경우에 &lt;var&gt;x&lt;/var&gt; , &lt;var&gt;y&lt;/var&gt; 다음 그리드를 나타내는 벡터이다 &lt;code&gt;length (&lt;var&gt;x&lt;/var&gt;) == columns (&lt;var&gt;z&lt;/var&gt;)&lt;/code&gt; &lt;var&gt;x&lt;/var&gt; ) == 열 ( &lt;var&gt;z&lt;/var&gt; ) 과 &lt;code&gt;length (&lt;var&gt;y&lt;/var&gt;) == rows (&lt;var&gt;z&lt;/var&gt;)&lt;/code&gt; &lt;var&gt;y&lt;/var&gt; ) == 행 ( &lt;var&gt;z&lt;/var&gt; ). 두 경우 모두 입력 데이터는 엄격하게 단조로운 것이어야합니다.</target>
        </trans-unit>
        <trans-unit id="4d256f32bc31b9e52b4c48a936fc80374fc3b68e" translate="yes" xml:space="preserve">
          <source>Interpolate reference data &lt;var&gt;x&lt;/var&gt;, &lt;var&gt;y&lt;/var&gt;, &lt;var&gt;z&lt;/var&gt;, &lt;var&gt;v&lt;/var&gt; to determine &lt;var&gt;vi&lt;/var&gt; at the coordinates &lt;var&gt;xi&lt;/var&gt;, &lt;var&gt;yi&lt;/var&gt;, &lt;var&gt;zi&lt;/var&gt;. The reference data &lt;var&gt;x&lt;/var&gt;, &lt;var&gt;y&lt;/var&gt;, &lt;var&gt;z&lt;/var&gt; can be matrices, as returned by &lt;code&gt;meshgrid&lt;/code&gt;, in which case the sizes of &lt;var&gt;x&lt;/var&gt;, &lt;var&gt;y&lt;/var&gt;, &lt;var&gt;z&lt;/var&gt;, and &lt;var&gt;v&lt;/var&gt; must be equal. If &lt;var&gt;x&lt;/var&gt;, &lt;var&gt;y&lt;/var&gt;, &lt;var&gt;z&lt;/var&gt; are vectors describing a cubic grid then &lt;code&gt;length (&lt;var&gt;x&lt;/var&gt;) == columns (&lt;var&gt;v&lt;/var&gt;)&lt;/code&gt;, &lt;code&gt;length (&lt;var&gt;y&lt;/var&gt;) == rows (&lt;var&gt;v&lt;/var&gt;)&lt;/code&gt;, and &lt;code&gt;length (&lt;var&gt;z&lt;/var&gt;) == size (&lt;var&gt;v&lt;/var&gt;, 3)&lt;/code&gt;. In either case the input data must be strictly monotonic.</source>
          <target state="translated">참조 데이터 &lt;var&gt;x&lt;/var&gt; , &lt;var&gt;y&lt;/var&gt; , &lt;var&gt;z&lt;/var&gt; , &lt;var&gt;v&lt;/var&gt; 를 보간 하여 좌표 &lt;var&gt;xi&lt;/var&gt; , &lt;var&gt;yi&lt;/var&gt; , &lt;var&gt;zi&lt;/var&gt; 에서 &lt;var&gt;vi&lt;/var&gt; 를 결정 합니다. 참조 데이터 &lt;var&gt;x&lt;/var&gt; , &lt;var&gt;y&lt;/var&gt; , &lt;var&gt;z&lt;/var&gt; 는 &lt;code&gt;meshgrid&lt;/code&gt; 에 의해 반환되는 행렬 일 수 있으며 ,이 경우 &lt;var&gt;x&lt;/var&gt; , &lt;var&gt;y&lt;/var&gt; , &lt;var&gt;z&lt;/var&gt; 및 &lt;var&gt;v&lt;/var&gt; 의 크기는 같아야합니다. 경우에 &lt;var&gt;x&lt;/var&gt; , &lt;var&gt;y&lt;/var&gt; , &lt;var&gt;z&lt;/var&gt; 다음 입방 격자를 나타내는 벡터이다 &lt;code&gt;length (&lt;var&gt;x&lt;/var&gt;) == columns (&lt;var&gt;v&lt;/var&gt;)&lt;/code&gt; &lt;var&gt;x&lt;/var&gt; ) == 컬럼 ( &lt;var&gt;v&lt;/var&gt; ), &lt;code&gt;length (&lt;var&gt;y&lt;/var&gt;) == rows (&lt;var&gt;v&lt;/var&gt;)&lt;/code&gt; 및 &lt;code&gt;length (&lt;var&gt;z&lt;/var&gt;) == size (&lt;var&gt;v&lt;/var&gt;, 3)&lt;/code&gt; . 두 경우 모두 입력 데이터는 엄격하게 단조로운 것이어야합니다.</target>
        </trans-unit>
        <trans-unit id="6a9858c9bf3149456595f98943cf88e41039822e" translate="yes" xml:space="preserve">
          <source>Interpolation</source>
          <target state="translated">Interpolation</target>
        </trans-unit>
        <trans-unit id="7140de6620767d35cab46c66723df2d24f63d020" translate="yes" xml:space="preserve">
          <source>Interpolation on Scattered Data</source>
          <target state="translated">분산 데이터에 대한 보간</target>
        </trans-unit>
        <trans-unit id="2473e96bc614a911821242119918a241a41836d6" translate="yes" xml:space="preserve">
          <source>Introduction</source>
          <target state="translated">Introduction</target>
        </trans-unit>
        <trans-unit id="9ddfc3edc40f8f0a656b6254baa41b6149709cec" translate="yes" xml:space="preserve">
          <source>Introduction to Function and Script Files</source>
          <target state="translated">함수 및 스크립트 파일 소개</target>
        </trans-unit>
        <trans-unit id="08a1ad737c7922e15774ea4e1c5871fdcaa9d531" translate="yes" xml:space="preserve">
          <source>Introduction to Graphics Structures</source>
          <target state="translated">그래픽 구조 소개</target>
        </trans-unit>
        <trans-unit id="86228830623cb00e9c0e9fb3a8beccc5be8da5ff" translate="yes" xml:space="preserve">
          <source>Introduction to Plotting</source>
          <target state="translated">플로팅 소개</target>
        </trans-unit>
        <trans-unit id="82e7771ffb7ac801757923626250d1b4c92a16cf" translate="yes" xml:space="preserve">
          <source>Invalid basis.</source>
          <target state="translated">잘못된 기준입니다.</target>
        </trans-unit>
        <trans-unit id="b5015425e6fc873c55859830f8c055e7cc97bd14" translate="yes" xml:space="preserve">
          <source>Invalid bounds.</source>
          <target state="translated">유효하지 않은 범위입니다.</target>
        </trans-unit>
        <trans-unit id="0a1d7ae050fcf3238e8d5a73afe71b1b2ba076e5" translate="yes" xml:space="preserve">
          <source>Invalid data.</source>
          <target state="translated">유효하지 않은 데이터.</target>
        </trans-unit>
        <trans-unit id="99634ed37f8505f136bb95f16db7bf39bc7beabb" translate="yes" xml:space="preserve">
          <source>Invert a symmetric, positive definite square matrix from its Cholesky decomposition, &lt;var&gt;U&lt;/var&gt;.</source>
          <target state="translated">hole 레 스키 (Cholesky) 분해 &lt;var&gt;U&lt;/var&gt; 로부터 대칭적이고 양의 정한 정방 행렬을 반전 시킵니다.</target>
        </trans-unit>
        <trans-unit id="92a8bb99c6acece26dcb71f3aa8260c466cb71e7" translate="yes" xml:space="preserve">
          <source>Invert the colors in the current color scheme.</source>
          <target state="translated">현재 색 구성표에서 색을 반전시킵니다.</target>
        </trans-unit>
        <trans-unit id="1cd19d8a24e96caba633bd5f04f6ba654bd6c2bb" translate="yes" xml:space="preserve">
          <source>Invoke Perl script &lt;var&gt;scriptfile&lt;/var&gt;, possibly with a list of command line arguments.</source>
          <target state="translated">명령 행 인수 목록이있는 Perl 스크립트 &lt;var&gt;scriptfile&lt;/var&gt; 을 호출하십시오 .</target>
        </trans-unit>
        <trans-unit id="0084fc1034ede17895fb74f93212c4df2c6875e7" translate="yes" xml:space="preserve">
          <source>Invoke Python script &lt;var&gt;scriptfile&lt;/var&gt;, possibly with a list of command line arguments.</source>
          <target state="translated">명령 행 인수 목록이있는 Python 스크립트 &lt;var&gt;scriptfile&lt;/var&gt; 을 호출하십시오 .</target>
        </trans-unit>
        <trans-unit id="5e5594ae88f3da15da5a9449544a04c37292b68f" translate="yes" xml:space="preserve">
          <source>Invoke the method &lt;var&gt;methodname&lt;/var&gt; on the Java object &lt;var&gt;obj&lt;/var&gt; with the arguments &lt;var&gt;arg1&lt;/var&gt;, &amp;hellip;.</source>
          <target state="translated">인수 &lt;var&gt;arg1&lt;/var&gt; ,&amp;hellip; 을 사용하여 Java 오브젝트 &lt;var&gt;obj&lt;/var&gt; 에서 메소드 &lt;var&gt;methodname&lt;/var&gt; 을 호출하십시오 .</target>
        </trans-unit>
        <trans-unit id="39bf0d8828a426e948f5fd29d3afbfe4953d948e" translate="yes" xml:space="preserve">
          <source>Invoking Octave from the Command Line</source>
          <target state="translated">명령 행에서 옥타브 호출</target>
        </trans-unit>
        <trans-unit id="ec72b33ed5d70687b65266f4d53f305aef97cde8" translate="yes" xml:space="preserve">
          <source>Is a square matrix.</source>
          <target state="translated">정사각 행렬입니다.</target>
        </trans-unit>
        <trans-unit id="e727c64038065312a81610f80c21d8039ed45a32" translate="yes" xml:space="preserve">
          <source>Is the code thoroughly optimized for Octave?</source>
          <target state="translated">코드가 옥타브에 최적화되어 있습니까?</target>
        </trans-unit>
        <trans-unit id="77a7841f20297f312ec7c2a49f2126cc3db30138" translate="yes" xml:space="preserve">
          <source>Is the function called when this menu entry is executed. It can be either a function string (e.g., &lt;code&gt;&quot;myfun&quot;&lt;/code&gt;), a function handle (e.g., @myfun) or a cell array containing the function handle and arguments for the callback function (e.g., {@myfun, arg1, arg2}).</source>
          <target state="translated">이 메뉴 항목이 실행될 때 호출되는 함수입니다. 함수 문자열 (예 : &lt;code&gt;&quot;myfun&quot;&lt;/code&gt; ), 함수 핸들 (예 : @myfun) 또는 함수 핸들 및 콜백 함수에 대한 인수 (예 : {@myfun, arg1, arg2})를 포함하는 셀형 배열 일 수 있습니다. .</target>
        </trans-unit>
        <trans-unit id="236a991810407c3af30e61ed19f65cd748b84178" translate="yes" xml:space="preserve">
          <source>Is the type of the factorization and can be one of</source>
          <target state="translated">인수 분해의 유형이며 다음 중 하나 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="43e7548ed1a01cecdf8ba5c26249f5ddfd41f011" translate="yes" xml:space="preserve">
          <source>Issuing Warnings</source>
          <target state="translated">경고 발행</target>
        </trans-unit>
        <trans-unit id="3ed678c231bee222184fff3a08bc3f4e2f5bfb05" translate="yes" xml:space="preserve">
          <source>It can also be helpful to have all output arguments in a single cell in the following manner:</source>
          <target state="translated">다음과 같은 방식으로 모든 출력 인수를 단일 셀에 포함시키는 것이 도움이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5ac9df42f7a0c2795d46b0787bf203f2d6247ddb" translate="yes" xml:space="preserve">
          <source>It can be both necessary and convenient to store several variables of different size or type in one variable. A cell array is a container class able to do just that. In general cell arrays work just like &lt;em&gt;N&lt;/em&gt;-dimensional arrays with the exception of the use of &amp;lsquo;</source>
          <target state="translated">크기 나 유형이 다른 여러 변수를 하나의 변수에 저장하는 것이 필요하고 편리 할 수 ​​있습니다. 셀형 배열은이를 수행 할 수있는 컨테이너 클래스입니다. 일반적으로 셀형 배열은 '를 사용하는 것을 제외하고 &lt;em&gt;N&lt;/em&gt; 차원 배열과 동일하게 작동합니다.</target>
        </trans-unit>
        <trans-unit id="3dffa5a923011061649cbb456800e0e8aad508c4" translate="yes" xml:space="preserve">
          <source>It can be very convenient store a function in a variable so that it can be passed to a different function. For example, a function that performs numerical minimization needs access to the function that should be minimized.</source>
          <target state="translated">함수를 변수에 저장하면 다른 함수에 전달할 수있어 매우 편리합니다. 예를 들어, 수치 최소화를 수행하는 함수는 최소화해야하는 함수에 액세스해야합니다.</target>
        </trans-unit>
        <trans-unit id="442cadeed3186dedd021758473ee98fb5ab896b1" translate="yes" xml:space="preserve">
          <source>It is a non-complex matrix.</source>
          <target state="translated">비 복잡한 행렬입니다.</target>
        </trans-unit>
        <trans-unit id="59bb7a156346e847608ba60d4d9a3596b5dc9592" translate="yes" xml:space="preserve">
          <source>It is a scalar.</source>
          <target state="translated">스칼라입니다.</target>
        </trans-unit>
        <trans-unit id="6f9ab3310a6d3f49c20dc8fb459198b2d32bb375" translate="yes" xml:space="preserve">
          <source>It is also possible to access public fields of Java objects from within Octave using Java syntax, with the limitation of static fields:</source>
          <target state="translated">정적 필드의 제한을 사용하여 Java 구문을 사용하여 Octave 내에서 Java 오브젝트의 공용 필드에 액세스 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="fe5e48d9378e9fa14044e693f95c955f399d9c75" translate="yes" xml:space="preserve">
          <source>It is also possible to assign an identification string to a warning. If a warning has such an ID the user can enable and disable this warning as will be described in the next section. To assign an ID to a warning, simply call &lt;code&gt;warning&lt;/code&gt; with two string arguments, where the first is the identification string, and the second is the actual warning. Note that warning IDs are in the format &lt;code&gt;&quot;NAMESPACE:WARNING-NAME&quot;&lt;/code&gt;. The namespace &lt;code&gt;&quot;Octave&quot;&lt;/code&gt; is used for Octave&amp;rsquo;s own warnings. Any other string is available as a namespace for user&amp;rsquo;s own warnings.</source>
          <target state="translated">식별 문자열을 경고에 할당 할 수도 있습니다. 경고에 이러한 ID가있는 경우 사용자는 다음 섹션에서 설명하는 것처럼이 경고를 활성화 및 비활성화 할 수 있습니다. 경고에 ID를 할당하려면 두 개의 문자열 인수로 &lt;code&gt;warning&lt;/code&gt; 를 호출 하면됩니다. 첫 번째는 식별 문자열이고 두 번째는 실제 경고입니다. 경고 ID는 &lt;code&gt;&quot;NAMESPACE:WARNING-NAME&quot;&lt;/code&gt; 형식 입니다. 네임 스페이스 &lt;code&gt;&quot;Octave&quot;&lt;/code&gt; 는 옥타브 자체 경고에 사용됩니다. 다른 문자열은 사용자 자신의 경고를위한 네임 스페이스로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f0435cfc38b4687beb6eb9883f949226c69aab15" translate="yes" xml:space="preserve">
          <source>It is also possible to assign an identification string to an error. If an error has such an ID the user can catch this error as will be described in the next section. To assign an ID to an error, simply call &lt;code&gt;error&lt;/code&gt; with two string arguments, where the first is the identification string, and the second is the actual error. Note that error IDs are in the format &lt;code&gt;&quot;NAMESPACE:ERROR-NAME&quot;&lt;/code&gt;. The namespace &lt;code&gt;&quot;Octave&quot;&lt;/code&gt; is used for Octave&amp;rsquo;s own errors. Any other string is available as a namespace for user&amp;rsquo;s own errors.</source>
          <target state="translated">식별 문자열을 오류에 할당 할 수도 있습니다. 오류에 이러한 ID가있는 경우 사용자는 다음 섹션에서 설명하는 것처럼이 오류를 잡을 수 있습니다. 오류에 ID를 할당하려면 호출 &lt;code&gt;error&lt;/code&gt; 에 첫 번째로 식별 문자열이 개 문자열 인수로, 두 번째는 실제 오류입니다. 오류 ID는 &lt;code&gt;&quot;NAMESPACE:ERROR-NAME&quot;&lt;/code&gt; 형식 입니다. 네임 스페이스 &lt;code&gt;&quot;Octave&quot;&lt;/code&gt; 는 옥타브 자체 오류에 사용됩니다. 다른 문자열은 사용자 자신의 오류에 대한 네임 스페이스로 사용 가능합니다.</target>
        </trans-unit>
        <trans-unit id="26de3b2a26b8342fe6cb4e69a96a2c08f06634e1" translate="yes" xml:space="preserve">
          <source>It is also possible to change the fontname and size within the text</source>
          <target state="translated">텍스트 내에서 글꼴 이름과 크기를 변경할 수도 있습니다</target>
        </trans-unit>
        <trans-unit id="bb6a4f1c159e128ef118ee70f18cf986e9dbee74" translate="yes" xml:space="preserve">
          <source>It is also possible to cycle through all the elements of a structure in a loop, using a special form of the &lt;code&gt;for&lt;/code&gt; statement (see &lt;a href=&quot;looping-over-structure-elements#Looping-Over-Structure-Elements&quot;&gt;Looping Over Structure Elements&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;for&lt;/code&gt; 문의 특수 형식을 사용하여 루프에서 구조의 모든 요소를 ​​순환 할 수도 있습니다 ( &lt;a href=&quot;looping-over-structure-elements#Looping-Over-Structure-Elements&quot;&gt;구조 요소 반복&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="c2fbec51523b8489b443b5d57b8132bf5d6d8005" translate="yes" xml:space="preserve">
          <source>It is also possible to define new specialized data types by writing a small amount of C++ code. On some systems, new data types can be loaded dynamically while Octave is running, so it is not necessary to recompile all of Octave just to add a new type. See &lt;a href=&quot;external-code-interface#External-Code-Interface&quot;&gt;External Code Interface&lt;/a&gt;, for more information about Octave&amp;rsquo;s dynamic linking capabilities. &lt;a href=&quot;user_002ddefined-data-types#User_002ddefined-Data-Types&quot;&gt;User-defined Data Types&lt;/a&gt; describes what you must do to define a new data type for Octave.</source>
          <target state="translated">소량의 C ++ 코드를 작성하여 새로운 특수 데이터 유형을 정의 할 수도 있습니다. 일부 시스템에서는 Octave가 실행되는 동안 새로운 데이터 유형을 동적으로로드 할 수 있으므로 새로운 유형을 추가하기 위해 모든 Octave를 다시 컴파일 할 필요는 없습니다. Octave의 동적 연결 기능에 대한 자세한 정보는 &lt;a href=&quot;external-code-interface#External-Code-Interface&quot;&gt;외부 코드 인터페이스를&lt;/a&gt; 참조하십시오 . &lt;a href=&quot;user_002ddefined-data-types#User_002ddefined-Data-Types&quot;&gt;사용자 정의 데이터 형식&lt;/a&gt; 은 Octave에 대한 새 데이터 형식을 정의하기 위해 수행해야하는 작업을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="b13e772a5ee9a589129c3de4130960515d9cf00d" translate="yes" xml:space="preserve">
          <source>It is also possible to draw a tube along an arbitrary array of vertices &lt;var&gt;xyz&lt;/var&gt;. The tube diameter can be specified by the vertex array &lt;var&gt;dia&lt;/var&gt; or by a constant.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a63551a00035877a36274289d88007f657077a3e" translate="yes" xml:space="preserve">
          <source>It is also possible to enable and disable individual warnings through their string identifications. The following code will issue a warning</source>
          <target state="translated">문자열 식별을 통해 개별 경고를 활성화 및 비활성화 할 수도 있습니다. 다음 코드는 경고를 발행합니다</target>
        </trans-unit>
        <trans-unit id="3502a574f1f1f5934b3936191c6cc279a7f30c5c" translate="yes" xml:space="preserve">
          <source>It is also possible to overload built-in or inherited methods, like the &lt;code&gt;disp&lt;/code&gt; function in the example above to tell Octave how objects of &lt;code&gt;some_class&lt;/code&gt; should be displayed (see &lt;a href=&quot;class-methods#Class-Methods&quot;&gt;Class Methods&lt;/a&gt;).</source>
          <target state="translated">옥타브에게 &lt;code&gt;some_class&lt;/code&gt; 의 객체를 표시 하는 방법을 알려주기 위해 위 예제 의 &lt;code&gt;disp&lt;/code&gt; 함수 와 같이 내장 또는 상속 된 메소드를 오버로드 할 수도 있습니다 ( &lt;a href=&quot;class-methods#Class-Methods&quot;&gt;클래스 메소드&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="d971f23c1e756151e4f27a5f135d29ae884029a6" translate="yes" xml:space="preserve">
          <source>It is also possible to represent &lt;var&gt;A&lt;/var&gt; by a function denoted &lt;var&gt;af&lt;/var&gt;. &lt;var&gt;af&lt;/var&gt; must be followed by a scalar argument &lt;var&gt;n&lt;/var&gt; defining the length of the vector argument accepted by &lt;var&gt;af&lt;/var&gt;. &lt;var&gt;af&lt;/var&gt; can be a function handle, an inline function, or a string. When &lt;var&gt;af&lt;/var&gt; is a string it holds the name of the function to use.</source>
          <target state="translated">&lt;var&gt;af&lt;/var&gt; 로 표시된 함수로 &lt;var&gt;A&lt;/var&gt; 를 나타낼 수도 있습니다 . &lt;var&gt;af&lt;/var&gt; 스칼라 인자 와야 &lt;var&gt;n&lt;/var&gt; 수락 벡터 인수의 길이 정의 &lt;var&gt;af&lt;/var&gt; . &lt;var&gt;af&lt;/var&gt; 는 함수 핸들, 인라인 함수 또는 문자열 일 수 있습니다. 시 &lt;var&gt;af&lt;/var&gt; 문자열 인이 사용하는 함수의 이름을 보유하고 있습니다.</target>
        </trans-unit>
        <trans-unit id="85633c39b02976d40ae22624a98bb21c5507f4b1" translate="yes" xml:space="preserve">
          <source>It is also possible to use logical values as part of standard numerical calculations. In this case &lt;code&gt;true&lt;/code&gt; is converted to &lt;code&gt;1&lt;/code&gt;, and &lt;code&gt;false&lt;/code&gt; to 0, both represented using double precision floating point numbers. So, the result of &lt;code&gt;true*22 - false/6&lt;/code&gt; is &lt;code&gt;22&lt;/code&gt;.</source>
          <target state="translated">표준 수치 계산의 일부로 논리 값을 사용할 수도 있습니다. 이 경우 &lt;code&gt;true&lt;/code&gt; 는 &lt;code&gt;1&lt;/code&gt; 로 변환 되고 &lt;code&gt;false&lt;/code&gt; 는 0으로 변환되며 모두 배정 밀도 부동 소수점 숫자를 사용하여 나타냅니다. 따라서 &lt;code&gt;true*22 - false/6&lt;/code&gt; 의 결과 는 &lt;code&gt;22&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="23e681cb037bd4026059d02dd45b8dd547ac9200" translate="yes" xml:space="preserve">
          <source>It is an error to remove a nonexistent preference or group.</source>
          <target state="translated">존재하지 않는 환경 설정 또는 그룹을 제거하는 것은 오류입니다.</target>
        </trans-unit>
        <trans-unit id="59e44cdc80fe6e2a75ae32f863b213f3c044e1b9" translate="yes" xml:space="preserve">
          <source>It is currently not useful to call &lt;code&gt;scanf&lt;/code&gt; in interactive programs.</source>
          <target state="translated">현재 대화식 프로그램에서 &lt;code&gt;scanf&lt;/code&gt; 를 호출하는 것은 유용하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="bdcccf923849676b0974b787689e551daf94ce7e" translate="yes" xml:space="preserve">
          <source>It is easy to define a matrix of values in Octave. The size of the matrix is determined automatically, so it is not necessary to explicitly state the dimensions. The expression</source>
          <target state="translated">옥타브에서 값의 행렬을 쉽게 정의 할 수 있습니다. 매트릭스의 크기는 자동으로 결정되므로 치수를 명시 적으로 언급 할 필요가 없습니다. 표현식</target>
        </trans-unit>
        <trans-unit id="ecffcf6c9a6e60dfccbad835e8d08c01050bfaa0" translate="yes" xml:space="preserve">
          <source>It is good practice at the head of a function to verify that it has been called correctly. In Octave the following idiom is seen frequently</source>
          <target state="translated">함수 헤드에서 올바르게 호출되었는지 확인하는 것이 좋습니다. 옥타브에서 다음 관용구가 자주 보입니다.</target>
        </trans-unit>
        <trans-unit id="f346152f83c3cc12ac297f1025850f4342597b5f" translate="yes" xml:space="preserve">
          <source>It is good practice at the head of a function to verify that it has been called correctly. Octave offers several functions for this purpose.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="540a234a0ec2bb8bd85abe6ef525361958a2f12d" translate="yes" xml:space="preserve">
          <source>It is important to automate the tests as much as possible, however some tests require user interaction. These can be isolated into demo blocks, which if you are in batch mode, are only run when called with &lt;code&gt;demo&lt;/code&gt; or the &lt;code&gt;verbose&lt;/code&gt; option to &lt;code&gt;test&lt;/code&gt;. The code is displayed before it is executed. For example,</source>
          <target state="translated">테스트를 최대한 자동화하는 것이 중요하지만 일부 테스트에는 사용자 상호 작용이 필요합니다. 이것들은 데모 블록으로 분리 될 수 있으며, 배치 모드에있는 경우 &lt;code&gt;demo&lt;/code&gt; 또는 &lt;code&gt;verbose&lt;/code&gt; 옵션을 사용하여 &lt;code&gt;test&lt;/code&gt; 할 때만 실행될 수 있습니다 . 코드는 실행되기 전에 표시됩니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="b803542835eb4ad9b15d5bfc61116f515c367400" translate="yes" xml:space="preserve">
          <source>It is important to note that a file format is not actually defined by its file extension and that &lt;code&gt;GraphicsMagick&lt;/code&gt; is capable to read and write more file formats than the ones listed by &lt;code&gt;imformats&lt;/code&gt;. What this means is that even with an incorrect or missing extension the image may still be read correctly, and that even unlisted formats are not necessarily unsupported.</source>
          <target state="translated">파일 형식은 실제로 파일 확장자에 의해 정의되지 않으며 &lt;code&gt;GraphicsMagick&lt;/code&gt; 은 &lt;code&gt;imformats&lt;/code&gt; 에 나열된 형식보다 더 많은 파일 형식을 읽고 쓸 수 있습니다 . 이것이 의미하는 바는 확장명이 잘못되었거나 누락 된 경우에도 이미지를 여전히 올바르게 읽을 수 있으며 나열되지 않은 형식도 반드시 지원되지는 않는다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="7ce04ece8dabf4a2bf4f85a83b849115dadc2a69" translate="yes" xml:space="preserve">
          <source>It is important to note that the &lt;var&gt;x&lt;/var&gt; and &lt;var&gt;y&lt;/var&gt; in &lt;code&gt;foobar&lt;/code&gt; remain zero, as in &lt;code&gt;foo&lt;/code&gt; they are a return value and parameter respectively. The &lt;var&gt;x&lt;/var&gt; in &lt;code&gt;bat&lt;/code&gt; refers to the &lt;var&gt;x&lt;/var&gt; in &lt;code&gt;foo&lt;/code&gt;.</source>
          <target state="translated">것이 중요합니다 &lt;var&gt;x&lt;/var&gt; 및 &lt;var&gt;y&lt;/var&gt; 의 &lt;code&gt;foobar&lt;/code&gt; 에로, 제로 남아 &lt;code&gt;foo&lt;/code&gt; 는 그들이 각각 반환 값과 매개 변수입니다. &lt;var&gt;x&lt;/var&gt; 에서 &lt;code&gt;bat&lt;/code&gt; 받는 의미 &lt;var&gt;x&lt;/var&gt; 에서 &lt;code&gt;foo&lt;/code&gt; 는 .</target>
        </trans-unit>
        <trans-unit id="67c2ac1277264a7423ad3c6d257c0de94abfe03a" translate="yes" xml:space="preserve">
          <source>It is important to note that variables do &lt;em&gt;not&lt;/em&gt; have permanent types. The type of a variable is simply the type of whatever value it happens to hold at the moment. In the following program fragment, the variable &lt;code&gt;foo&lt;/code&gt; has a numeric value at first, and a string value later on:</source>
          <target state="translated">변수 에는 영구적 인 유형 이 &lt;em&gt;없습니다&lt;/em&gt; . 변수의 유형은 단순히 현재 보유하고있는 모든 값의 유형입니다. 다음 프로그램 조각에서 변수 &lt;code&gt;foo&lt;/code&gt; 는 처음에 숫자 값을 가지며 나중에 문자열 값을 갖습니다.</target>
        </trans-unit>
        <trans-unit id="e91e2f975b4a1b222cd78f2b1a4535dd28efa2e6" translate="yes" xml:space="preserve">
          <source>It is important to understand the implications that this optimization brings. Since no extra copy of &lt;code&gt;x&lt;/code&gt; will exist in the caller&amp;rsquo;s scope, it is &lt;em&gt;solely&lt;/em&gt; the callee&amp;rsquo;s responsibility to not leave &lt;code&gt;x&lt;/code&gt; in an invalid state if an error occurs during the execution. Also, if the method partially changes &lt;code&gt;x&lt;/code&gt; and then errors out, the changes &lt;em&gt;will&lt;/em&gt; affect &lt;code&gt;x&lt;/code&gt; in the caller&amp;rsquo;s scope. Deleting or completely replacing &lt;code&gt;x&lt;/code&gt; inside subsasgn will not do anything, however, only indexed assignments matter.</source>
          <target state="translated">이 최적화가 가져 오는 의미를 이해하는 것이 중요합니다. 호출자의 범위 에는 &lt;code&gt;x&lt;/code&gt; 의 추가 사본이 없으므로 실행 중에 오류가 발생하는 경우 &lt;code&gt;x&lt;/code&gt; 를 유효하지 않은 상태로 두지 않는 것은 &lt;em&gt;전적으로&lt;/em&gt; 수신자의 책임 입니다. 또한 메소드가 &lt;code&gt;x&lt;/code&gt; 를 부분적으로 변경 한 다음 오류가 발생하면 변경 사항 &lt;em&gt;이&lt;/em&gt; 호출자의 범위에서 &lt;code&gt;x&lt;/code&gt; 에 영향을줍니다 . subsasgn 내에서 &lt;code&gt;x&lt;/code&gt; 를 삭제하거나 완전히 바꾸면 아무 작업도 수행되지 않지만 인덱스 된 할당 만 중요합니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c9b55864b0011f98212749d9ac527909435534fb" translate="yes" xml:space="preserve">
          <source>It is more efficient to use indexing rather than the code construction &lt;code&gt;scalar * ones (M, N, &amp;hellip;)&lt;/code&gt; because it avoids the unnecessary multiplication operation. Moreover, multiplication may not be defined for the object to be replicated whereas indexing an array is always defined. The following code shows how to create a 2x3 cell array from a base unit which is not itself a scalar.</source>
          <target state="translated">불필요한 곱셈 연산을 피하기 때문에 코드 구성 &lt;code&gt;scalar * ones (M, N, &amp;hellip;)&lt;/code&gt; 보다는 인덱싱을 사용하는 것이 더 효율적 입니다. 또한 복제 할 개체에 대해 곱셈이 정의되지 않은 반면 배열 인덱싱이 항상 정의됩니다. 다음 코드는 스칼라가 아닌 기본 단위에서 2x3 셀형 배열을 만드는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="d0ad3527ac44549215866d715ee7b39d097faf2c" translate="yes" xml:space="preserve">
          <source>It is much easier to see the error if we rewrite the statements above like this,</source>
          <target state="translated">위와 같은 문장을 다시 작성하면 오류를 훨씬 쉽게 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1f6b300a78cc5952c6768bba2153b3958d75bc2e" translate="yes" xml:space="preserve">
          <source>It is necessary declare a variable as global within a function body in order to access it. For example,</source>
          <target state="translated">액세스하려면 함수 본문 내에서 변수를 전역 변수로 선언해야합니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="452f150255df240aea209829bf358f9c03896b83" translate="yes" xml:space="preserve">
          <source>It is necessary declare a variable as global within a function body in order to access the one universal variable. For example,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="801ddee654a4f5a60595b8d75b21f32c987f1616" translate="yes" xml:space="preserve">
          <source>It is not a sparse matrix.</source>
          <target state="translated">희소 행렬이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="526146d85026fc03d1315f38797e39731b6ab73d" translate="yes" xml:space="preserve">
          <source>It is not empty.</source>
          <target state="translated">비어 있지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d2d6d72cd91869be693c0b7cb09744dfe1d15585" translate="yes" xml:space="preserve">
          <source>It is not recommended to represent Java&amp;rsquo;s &lt;code&gt;null&lt;/code&gt; value by empty brackets &lt;code&gt;[]&lt;/code&gt;, because &lt;code&gt;null&lt;/code&gt; has no type whereas &lt;code&gt;[]&lt;/code&gt; has type &lt;code&gt;double&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;null&lt;/code&gt; 은 타입이없고, &lt;code&gt;[]&lt;/code&gt; 는 &lt;code&gt;double&lt;/code&gt; 타입 이므로 Java의 &lt;code&gt;null&lt;/code&gt; 값은 빈 괄호 &lt;code&gt;[]&lt;/code&gt; 로 나타내지 않는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="c304a4c82da4a3c1b982a182a0d45fd71d798c42" translate="yes" xml:space="preserve">
          <source>It is not strictly speaking necessary for the user to understand how sparse matrices are stored. However, such an understanding will help to get an understanding of the size of sparse matrices. Understanding the storage technique is also necessary for those users wishing to create their own oct-files.</source>
          <target state="translated">사용자가 희소 행렬이 저장되는 방법을 이해해야하는 것은 아닙니다. 그러나 이러한 이해는 희소 행렬의 크기를 이해하는 데 도움이됩니다. 자신의 oct 파일을 작성하려는 사용자에게는 저장 기술의 이해가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="04348c6155f5f8a33984df13f4dbbc5a056adc97" translate="yes" xml:space="preserve">
          <source>It is often necessary to find if two strings or files are identical. This might be done by comparing them character by character and looking for differences. However, this can be slow, and so comparing a hash of the string or file can be a rapid way of finding if the files differ.</source>
          <target state="translated">두 개의 문자열 또는 파일이 동일한 지 찾아야하는 경우가 종종 있습니다. 이것은 문자별로 비교하고 차이점을 찾아서 수행 할 수 있습니다. 그러나 속도가 느릴 수 있으므로 문자열 또는 파일의 해시를 비교하면 파일이 다른지 빠르게 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2aaddc667b95283238f47dc41d259f3a7ae1e314" translate="yes" xml:space="preserve">
          <source>It is often necessary to identify whether a particular point in the N-dimensional space is within the Delaunay tessellation of a set of points in this N-dimensional space, and if so which N-simplex contains the point and which point in the tessellation is closest to the desired point. The functions &lt;code&gt;tsearch&lt;/code&gt; and &lt;code&gt;dsearch&lt;/code&gt; perform this function in a triangulation, and &lt;code&gt;tsearchn&lt;/code&gt; and &lt;code&gt;dsearchn&lt;/code&gt; in an N-dimensional tessellation.</source>
          <target state="translated">N 차원 공간의 특정 점이이 N 차원 공간의 점 집합의 들로네 테셀레이션 내에 있는지 여부를 식별해야하며, 그렇다면 N- 심플 렉스가 점을 포함하고 테셀레이션의 어느 점이 원하는 지점에 가장 가깝습니다. &lt;code&gt;tsearch&lt;/code&gt; 및 &lt;code&gt;dsearch&lt;/code&gt; 기능 삼각에서이 기능을 수행하고, &lt;code&gt;tsearchn&lt;/code&gt; 및 &lt;code&gt;dsearchn&lt;/code&gt; 는 N 차원 공간 분할한다.</target>
        </trans-unit>
        <trans-unit id="3f24864a359ac7d98f26d3ca90d7f5983254ff80" translate="yes" xml:space="preserve">
          <source>It is often useful to calculate descriptive statistics over a subsection (i.e., window) of a full dataset. Octave provides the function &lt;code&gt;movfun&lt;/code&gt; which will call an arbitrary function handle with windows of data and accumulate the results. Many of the most commonly desired functions, such as the moving average over a window of data (&lt;code&gt;movmean&lt;/code&gt;), are already provided.</source>
          <target state="translated">전체 데이터 세트의 하위 섹션 (예 : 창)에 대한 설명 통계를 계산하는 것이 유용한 경우가 많습니다. 옥타브는 기능을 제공합니다 &lt;code&gt;movfun&lt;/code&gt; 는 임의의 함수 핸들을 데이터 창으로 호출하고 결과를 누적합니다. 데이터 창에 대한 이동 평균 ( &lt;code&gt;movmean&lt;/code&gt; ) 과 같이 가장 일반적으로 원하는 여러 기능 이 이미 제공되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="188fa50a78938dd69a91532a41a05070a5130f37" translate="yes" xml:space="preserve">
          <source>It is possible to achieve a wide range of output styles by using different values of &lt;code&gt;output_precision&lt;/code&gt;. Reasonable combinations can be set using the &lt;code&gt;format&lt;/code&gt; function. See &lt;a href=&quot;basic-input-and-output#Basic-Input-and-Output&quot;&gt;Basic Input and Output&lt;/a&gt;.</source>
          <target state="translated">다른 &lt;code&gt;output_precision&lt;/code&gt; 값을 사용하여 다양한 출력 스타일을 얻을 수 있습니다 . &lt;code&gt;format&lt;/code&gt; 사용하여 합리적인 조합을 설정할 수 있습니다 기능을 . &lt;a href=&quot;basic-input-and-output#Basic-Input-and-Output&quot;&gt;기본 입력 및 출력을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="4cbe064daff614d3025f82f1132e18f254ce15f6" translate="yes" xml:space="preserve">
          <source>It is possible to add or remove directories to or from the load path using &lt;code&gt;addpath&lt;/code&gt; and &lt;code&gt;rmpath&lt;/code&gt;. As an example, the following code adds &amp;lsquo;</source>
          <target state="translated">&lt;code&gt;addpath&lt;/code&gt; 및 &lt;code&gt;rmpath&lt;/code&gt; 를 사용하여로드 경로에 디렉토리를 추가하거나 제거 할 수 있습니다 . 예를 들어 다음 코드는 '</target>
        </trans-unit>
        <trans-unit id="98e341829fcf421014dea3c1e6bf41d80ebb8189" translate="yes" xml:space="preserve">
          <source>It is possible to avoid all warnings about such statements by disabling the &lt;code&gt;Octave:assign-as-truth-value&lt;/code&gt; warning, but that may also let real errors like</source>
          <target state="translated">&lt;code&gt;Octave:assign-as-truth-value&lt;/code&gt; 경고 를 비활성화하여 이러한 문장에 대한 모든 경고를 피할 수 있지만 실제 오류는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f780290d475d08391e464c4cd5cfcc7e795b0c9f" translate="yes" xml:space="preserve">
          <source>It is possible to call other Octave functions from within a mex-file using &lt;code&gt;mexCallMATLAB&lt;/code&gt;. An example of the use of &lt;code&gt;mexCallMATLAB&lt;/code&gt; can be see in the example below.</source>
          <target state="translated">&lt;code&gt;mexCallMATLAB&lt;/code&gt; 을 사용하여 mex 파일 내에서 다른 Octave 함수를 호출 할 수 있습니다 . &lt;code&gt;mexCallMATLAB&lt;/code&gt; 사용 예는 아래 예에서 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6a1e28590ae5b64287aa618a2a89223453ba375f" translate="yes" xml:space="preserve">
          <source>It is possible to change the way Octave manages file formats with the options &lt;code&gt;&quot;add&quot;&lt;/code&gt;, &lt;code&gt;&quot;remove&quot;&lt;/code&gt;, and &lt;code&gt;&quot;update&quot;&lt;/code&gt;, and supplying a structure &lt;var&gt;format&lt;/var&gt; with the required fields. The option &lt;code&gt;&quot;factory&quot;&lt;/code&gt; resets the configuration to the default.</source>
          <target state="translated">Octave가 &lt;code&gt;&quot;add&quot;&lt;/code&gt; , &lt;code&gt;&quot;remove&quot;&lt;/code&gt; 및 &lt;code&gt;&quot;update&quot;&lt;/code&gt; 옵션을 사용하여 파일 형식을 관리하는 방식을 변경하고 구조 &lt;var&gt;format&lt;/var&gt; 제공 할 수 있습니다. 하고 필요한 필드와 함께 을 제공 할 수 있습니다. &lt;code&gt;&quot;factory&quot;&lt;/code&gt; 옵션 은 구성을 기본값으로 재설정합니다.</target>
        </trans-unit>
        <trans-unit id="0e3a802de60dce7ac52b8d56bc4643a6b4e70645" translate="yes" xml:space="preserve">
          <source>It is possible to get information about an image file on disk, without actually reading it into Octave. This is done using the &lt;code&gt;imfinfo&lt;/code&gt; function which provides read access to many of the parameters stored in the header of the image file.</source>
          <target state="translated">실제로 Octave로 읽지 않고 디스크의 이미지 파일에 대한 정보를 얻을 수 있습니다. 이것은 &lt;code&gt;imfinfo&lt;/code&gt; 이미지 파일의 헤더에 저장된 많은 매개 변수에 대한 읽기 액세스를 제공 imfinfo 기능을 됩니다.</target>
        </trans-unit>
        <trans-unit id="a75fb5ef416bbc47bc7a67e78c779382bc9066f7" translate="yes" xml:space="preserve">
          <source>It is possible to get the current installation prefix by requesting an output argument. For example:</source>
          <target state="translated">출력 인수를 요청하여 현재 설치 접두사를 가져올 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8a731513a1ee5825051c6ebbeb00886920ea3d68" translate="yes" xml:space="preserve">
          <source>It is possible to get the current value of global_list with the following</source>
          <target state="translated">global_list의 현재 값을 다음과 같이 얻을 수 있습니다</target>
        </trans-unit>
        <trans-unit id="26516dbbee86ee4aa501260aa426a66a2b43cc77" translate="yes" xml:space="preserve">
          <source>It is possible to get the current value of local_list with the following</source>
          <target state="translated">local_list의 현재 값을 다음과 같이 얻을 수 있습니다</target>
        </trans-unit>
        <trans-unit id="b9a8b0420896d624ffb65d87b22596335ef7d21f" translate="yes" xml:space="preserve">
          <source>It is possible to invoke public member methods on Java objects in Java syntax:</source>
          <target state="translated">Java 구문으로 Java 오브젝트에서 공용 멤버 메소드를 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="587cc169ebff0d5635c1b8e2acf7be6d8a2dc0be" translate="yes" xml:space="preserve">
          <source>It is possible to issue warnings from any code using the &lt;code&gt;warning&lt;/code&gt; function. In its most simple form, the &lt;code&gt;warning&lt;/code&gt; function takes a string describing the warning as its input argument. As an example, the following code controls if the variable &amp;lsquo;</source>
          <target state="translated">&lt;code&gt;warning&lt;/code&gt; 기능을 사용하여 모든 코드에서 경고를 발행 할 수 있습니다. 가장 간단한 형태로 &lt;code&gt;warning&lt;/code&gt; 함수는 경고를 입력 인수로 설명하는 문자열을 사용합니다. 예를 들어 다음 코드는 변수 '</target>
        </trans-unit>
        <trans-unit id="a381bea7bd627e6a360bb3cad09aa216599c12e8" translate="yes" xml:space="preserve">
          <source>It is possible to remove a package from the system using the &lt;code&gt;pkg uninstall&lt;/code&gt; command like this</source>
          <target state="translated">&lt;code&gt;pkg uninstall&lt;/code&gt; 을 사용하여 시스템에서 패키지를 제거 할 수 있습니다 과 같이 명령을</target>
        </trans-unit>
        <trans-unit id="afa0034a88d031cdab12ba2d08462408042e4b71" translate="yes" xml:space="preserve">
          <source>It is possible to reorder the decomposition so that the positive eigenvalue is in the upper left corner, by doing:</source>
          <target state="translated">양의 고유 값이 왼쪽 상단에 있도록 분해를 재정렬 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8cc46405f59eb7d841a833ad47c2b9cf5ee38563" translate="yes" xml:space="preserve">
          <source>It is possible to represent missing data explicitly in Octave using &lt;code&gt;NA&lt;/code&gt; (short for &amp;ldquo;Not Available&amp;rdquo;). Missing data can only be represented when data is represented as floating point numbers. In this case missing data is represented as a special case of the representation of &lt;code&gt;NaN&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;NA&lt;/code&gt; 를 사용하여 옥타브에서 누락 된 데이터를 명시 적으로 나타낼 수 있습니다 ( &quot;사용할 수 없음&quot;의 줄임). 누락 된 데이터는 데이터가 부동 소수점 숫자로 표시 될 때만 나타낼 수 있습니다. 이 경우 누락 된 데이터는 &lt;code&gt;NaN&lt;/code&gt; 표현의 특수한 경우로 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="6a160b30dcf06c8fda7aee7cb2161dde65eb7e72" translate="yes" xml:space="preserve">
          <source>It is possible to return a variable number of output arguments from a function using a syntax that&amp;rsquo;s similar to the one used with the special &lt;code&gt;varargin&lt;/code&gt; parameter name. To let a function return a variable number of output arguments the special output parameter name &lt;code&gt;varargout&lt;/code&gt; is used. As with &lt;code&gt;varargin&lt;/code&gt;, &lt;code&gt;varargout&lt;/code&gt; is a cell array that will contain the requested output arguments.</source>
          <target state="translated">특수 &lt;code&gt;varargin&lt;/code&gt; 매개 변수 이름에 사용 된 구문과 유사한 구문을 사용하여 함수에서 가변 개수의 출력 인수를 반환 할 수 있습니다. 함수가 가변 개수의 출력 인수를 반환 할 수 있도록 특수 출력 매개 변수 이름 &lt;code&gt;varargout&lt;/code&gt; 이 사용됩니다. 처럼 &lt;code&gt;varargin&lt;/code&gt; , &lt;code&gt;varargout&lt;/code&gt; 가 요청한 출력 인자를 포함하는 셀 어레이이다.</target>
        </trans-unit>
        <trans-unit id="2becc65982958f31b08985c16d7171b3e3184369" translate="yes" xml:space="preserve">
          <source>It is possible to save all breakpoints and restore them at once by issuing the commands &lt;code&gt;bp_state = dbstatus; &amp;hellip;; dbstop (bp_state)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;bp_state = dbstatus; &amp;hellip;; dbstop (bp_state)&lt;/code&gt; 명령을 실행하여 모든 중단 점을 저장하고 한 번에 복원 할 수 있습니다 . &amp;hellip;; dbstop (bp_state) .</target>
        </trans-unit>
        <trans-unit id="4611f992df33b68644265905f12802aba69c468e" translate="yes" xml:space="preserve">
          <source>It is possible to specify that an object&amp;rsquo;s callbacks should not be interrupted by setting the object&amp;rsquo;s &lt;code&gt;interruptible&lt;/code&gt; property to &lt;code&gt;&quot;off&quot;&lt;/code&gt;. In this case, Octave decides what to do based on the &lt;code&gt;busyaction&lt;/code&gt; property of the &lt;strong&gt;interrupting&lt;/strong&gt; callback object:</source>
          <target state="translated">객체의 &lt;code&gt;interruptible&lt;/code&gt; 속성을 &lt;code&gt;&quot;off&quot;&lt;/code&gt; 로 설정하여 객체의 콜백을 중단하지 않도록 지정할 수 있습니다 . 이 경우 Octave는 &lt;strong&gt;인터럽트&lt;/strong&gt; 콜백 객체 의 &lt;code&gt;busyaction&lt;/code&gt; 속성 에 따라 수행 할 작업을 결정 합니다.&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a33fdc5ea3a79c0b83ad6b1eb262a13798c7315f" translate="yes" xml:space="preserve">
          <source>It is possible to use the &lt;code&gt;nthargout&lt;/code&gt; function to obtain only some of the return values or several at once in a cell array. See &lt;a href=&quot;cell-array-objects#Cell-Array-Objects&quot;&gt;Cell Array Objects&lt;/a&gt;.</source>
          <target state="translated">셀 배열에서 &lt;code&gt;nthargout&lt;/code&gt; 함수 를 사용하여 일부 반환 값만 또는 한 번에 여러 개를 얻을 수 있습니다. &lt;a href=&quot;cell-array-objects#Cell-Array-Objects&quot;&gt;셀형 배열 객체를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="8e4cb1b55c0878de8c24c8680c29ed641b0503d1" translate="yes" xml:space="preserve">
          <source>It is possible to write data to a file in a similar way to the &lt;code&gt;disp&lt;/code&gt; function for writing data to the screen. The &lt;code&gt;fdisp&lt;/code&gt; works just like &lt;code&gt;disp&lt;/code&gt; except its first argument is a file pointer as created by &lt;code&gt;fopen&lt;/code&gt;. As an example, the following code writes to data &amp;lsquo;</source>
          <target state="translated">화면에 데이터를 쓰는 &lt;code&gt;disp&lt;/code&gt; 기능 과 비슷한 방식으로 파일에 데이터를 쓸 수 있습니다. &lt;code&gt;fdisp&lt;/code&gt; 는 것처럼 작동 &lt;code&gt;disp&lt;/code&gt; 첫 번째 인자가 만든 같은 파일 포인터를 제외 &lt;code&gt;fopen&lt;/code&gt; . 예를 들어 다음 코드는 '</target>
        </trans-unit>
        <trans-unit id="dee07363ec67512d97caea59fe084fbeb2aff24b" translate="yes" xml:space="preserve">
          <source>It is possible to write functions that only set some return values. For example, calling the function</source>
          <target state="translated">일부 반환 값만 설정하는 함수를 작성할 수 있습니다. 예를 들어, 함수 호출</target>
        </trans-unit>
        <trans-unit id="3f1682d8f39928396b187dbaf883d626ef1ddcab" translate="yes" xml:space="preserve">
          <source>It is quite inefficient to create a vector using a loop like this. In this case, it would have been much more efficient to use the expression</source>
          <target state="translated">이와 같은 루프를 사용하여 벡터를 만드는 것은 매우 비효율적입니다. 이 경우 표현식을 사용하는 것이 훨씬 더 효율적이었을 것입니다</target>
        </trans-unit>
        <trans-unit id="a9cf2050a51cf23d108221afb27bbc9c0d343967" translate="yes" xml:space="preserve">
          <source>It is sometime desirable to lock a function into memory with the &lt;code&gt;mlock&lt;/code&gt; function. This is typically used for dynamically linked functions in oct-files or mex-files that contain some initialization, and it is desirable that calling &lt;code&gt;clear&lt;/code&gt; does not remove this initialization.</source>
          <target state="translated">&lt;code&gt;mlock&lt;/code&gt; 기능 을 사용하여 기능을 메모리에 잠그는 것이 때때로 바람직 합니다. 일반적으로 일부 초기화가 포함 된 oct 파일 또는 mex 파일의 동적으로 링크 된 함수에 사용되며 &lt;code&gt;clear&lt;/code&gt; 를 호출 해도이 초기화가 제거되지 않는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="0433499c73f41d32a3b3b8d5342d061d2837b20b" translate="yes" xml:space="preserve">
          <source>It is useful for displaying periodic functions. The map is obtained by linearly varying the hue through all possible values while keeping constant maximum saturation and value. The equivalent code is &lt;code&gt;hsv2rgb ([(0:N-1)'/N, ones(N,2)])&lt;/code&gt;.</source>
          <target state="translated">주기적 기능을 표시하는 데 유용합니다. 맵은 최대 채도와 값을 일정하게 유지하면서 가능한 모든 값을 통해 색조를 선형으로 변경하여 얻습니다. 동등한 코드는 &lt;code&gt;hsv2rgb ([(0:N-1)'/N, ones(N,2)])&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="6907f220ebd40ea5fc911110957f3c85432ea6c1" translate="yes" xml:space="preserve">
          <source>It is very common to take different actions depending on the value of one variable. This is possible using the &lt;code&gt;if&lt;/code&gt; statement in the following way</source>
          <target state="translated">하나의 변수 값에 따라 다른 조치를 취하는 것이 매우 일반적입니다. 이것은 다음과 같은 방법으로 &lt;code&gt;if&lt;/code&gt; 문을 사용하여 가능합니다</target>
        </trans-unit>
        <trans-unit id="c0ef1baccd2a68d90a570985390b94744f6fb3f6" translate="yes" xml:space="preserve">
          <source>It is worth re-iterating that, if only built-in functions are to be called from a C++ standalone program then it does not need to initialize the interpreter. The general rule is that for a built-in function named &lt;code&gt;function_name&lt;/code&gt; in the interpreter, there will be a C++ function named &lt;code&gt;Ffunction_name&lt;/code&gt; (note the prepended capital &lt;code&gt;F&lt;/code&gt;) accessible in the C++ API. The declarations for all built-in functions are collected in the header file &lt;code&gt;builtin-defun-decls.h&lt;/code&gt;. This feature should be used with care as the list of built-in functions can change. No guarantees can be made that a function that is currently a built-in won&amp;rsquo;t be implemented as a</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8189fddee002346d1345e22fd2f6b19799dc0af7" translate="yes" xml:space="preserve">
          <source>It is worth re-iterating that, if only built-in functions are to be called from a C++ standalone program then it does not need to initialize the interpreter. The general rule is that for a built-in function named &lt;code&gt;function_name&lt;/code&gt; in the interpreter, there will be a C++ function named &lt;code&gt;Ffunction_name&lt;/code&gt; (note the prepended capital &lt;code&gt;F&lt;/code&gt;) accessible in the C++ API. The declarations for all built-in functions are collected in the header file &lt;code&gt;builtin-defun-decls.h&lt;/code&gt;. This feature should be used with care as the list of built-in functions can change. No guarantees can be made that a function that is currently a built-in won&amp;rsquo;t be implemented as a .m file or as a dynamically linked function in the future. An example of how to call built-in functions from C++ can be seen in the code</source>
          <target state="translated">C ++ 독립형 프로그램에서 내장 함수 만 호출해야하는 경우 인터프리터를 초기화 할 필요가 없다는 점을 다시 한번 언급 할 필요가 있습니다. 일반적인 규칙은 내장에 대한 기능이라는 점이다 &lt;code&gt;function_name&lt;/code&gt; 인터프리터에,라는 C ++ 기능이있을 것 &lt;code&gt;Ffunction_name&lt;/code&gt; (추가되는 말머리 자본주의 &lt;code&gt;F&lt;/code&gt; 를 은 C ++ API에 액세스 할 수 있음). 모든 내장 함수에 대한 선언은 헤더 파일 &lt;code&gt;builtin-defun-decls.h&lt;/code&gt; 에 수집됩니다.. 내장 기능 목록이 변경 될 수 있으므로이 기능은주의해서 사용해야합니다. 현재 내장되어있는 함수가 .m 파일 또는 향후 동적으로 링크 된 함수로 구현되지 않을 것이라는 보장은 없습니다. C ++에서 내장 함수를 호출하는 방법의 예는 코드에서 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="97786bf1156caf091b459afd7d4ee517ae1dd7e3" translate="yes" xml:space="preserve">
          <source>It outputs an indexed image &lt;var&gt;x&lt;/var&gt; and a colormap &lt;var&gt;map&lt;/var&gt; to interpret an image exactly the same as the input. No dithering or other form of color quantization is performed. The output class of the indexed image &lt;var&gt;x&lt;/var&gt; can be uint8, uint16 or double, whichever is required to specify the number of unique colors in the image (which will be equal to the number of rows in &lt;var&gt;map&lt;/var&gt;) in order.</source>
          <target state="translated">인덱싱 된 이미지 &lt;var&gt;x&lt;/var&gt; 와 컬러 맵 &lt;var&gt;map&lt;/var&gt; 을 출력 하여 입력과 정확히 동일한 이미지를 해석합니다. 디더링 또는 다른 형태의 색상 양자화가 수행되지 않습니다. 색인화 된 이미지 &lt;var&gt;x&lt;/var&gt; 의 출력 클래스는 uint8, uint16 또는 double 일 수 있으며, 이미지에서 고유 한 색상 수 ( &lt;var&gt;map&lt;/var&gt; 의 행 수와 동일 )를 순서대로 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="cd0e0766e8ea169f51bd5b670cab6b828cd5ef2e" translate="yes" xml:space="preserve">
          <source>It should be noted that &lt;code&gt;ones (1, n)&lt;/code&gt; (a row vector of ones) results in a range object (with zero increment). A range is stored internally as a starting value, increment, end value, and total number of values; hence, it is more efficient for storage than a vector or matrix of ones whenever the number of elements is greater than 4. In particular, when &amp;lsquo;</source>
          <target state="translated">그것은 유의할 점 &lt;code&gt;ones (1, n)&lt;/code&gt; (사람의 행 벡터) (영 증가량) 범위 객체 초래한다. 범위는 내부적으로 시작 값, 증분, 종료 값 및 총 값 수로 저장됩니다. 따라서 요소의 수가 4보다 클 때마다 벡터 나 행렬보다 저장에 더 효율적입니다.</target>
        </trans-unit>
        <trans-unit id="9d8f9c312d847d5b9f3f42f2e3bc6261b85f9cd6" translate="yes" xml:space="preserve">
          <source>It should be noted that &lt;small&gt;MATLAB&lt;/small&gt; uses different definitions which apparently do not distinguish -0.</source>
          <target state="translated">주목해야한다 &lt;small&gt;MATLAB는&lt;/small&gt; 분명히 구분하지 않는 다른 정의를 사용 -0.</target>
        </trans-unit>
        <trans-unit id="f2b2514475518a90b907f559cb78d0c328f02b79" translate="yes" xml:space="preserve">
          <source>It should be noted that all values passed to the bit manipulation functions of Octave are treated as integers. Therefore, even though the example for &lt;code&gt;bitset&lt;/code&gt; above passes the floating point value &lt;code&gt;10&lt;/code&gt;, it is treated as the bits &lt;code&gt;[1, 0, 1, 0]&lt;/code&gt; rather than the bits of the native floating point format representation of &lt;code&gt;10&lt;/code&gt;.</source>
          <target state="translated">옥타브의 비트 조작 함수에 전달 된 모든 값은 정수로 취급됩니다. 이에 대한 예에도 &lt;code&gt;bitset&lt;/code&gt; 상기 부동 소수점 값을 전달한다 &lt;code&gt;10&lt;/code&gt; , 그것은 비트들로 취급된다 &lt;code&gt;[1, 0, 1, 0]&lt;/code&gt; 보다는의 기본 부동 소수점 형식으로 표현의 비트 &lt;code&gt;10&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3a57832782e814bf89e88ffc8515a92cf1c83f45" translate="yes" xml:space="preserve">
          <source>It should be noted that the mex-file contains no help string. To document mex-files, there should exist an m-file in the same directory as the mex-file itself. Taking the above as an example, there would need to be a file</source>
          <target state="translated">mex 파일에는 도움말 문자열이 포함되어 있지 않습니다. mex 파일을 문서화하려면 mex 파일 자체와 동일한 디렉토리에 m 파일이 있어야합니다. 위의 예를 예로 들면 파일이 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="501d2c49c6248e4cabc5706abac880c84dd8ec9d" translate="yes" xml:space="preserve">
          <source>It should be noted that the number of points determines the quality of the approximation. If the integration needs to be performed between &lt;em&gt;a&lt;/em&gt; and &lt;em&gt;b&lt;/em&gt;, instead of 0 and 1, then a change of variables is needed.</source>
          <target state="translated">점의 수는 근사치의 품질을 결정합니다. 0과 1 대신 &lt;em&gt;a&lt;/em&gt; 와 &lt;em&gt;b&lt;/em&gt; 사이에 적분을 수행해야하는 경우 변수를 변경해야합니다.</target>
        </trans-unit>
        <trans-unit id="cdac1197569db0b5b7c92fe04f15a2cdaefbdcef" translate="yes" xml:space="preserve">
          <source>It should be noted that the statistics functions don&amp;rsquo;t test for data containing NaN, NA, or Inf. These values need to be detected and dealt with explicitly. See &lt;a href=&quot;finding-elements-and-checking-conditions#XREFisnan&quot;&gt;isnan&lt;/a&gt;, &lt;a href=&quot;missing-data#XREFisna&quot;&gt;isna&lt;/a&gt;, &lt;a href=&quot;finding-elements-and-checking-conditions#XREFisinf&quot;&gt;isinf&lt;/a&gt;, &lt;a href=&quot;finding-elements-and-checking-conditions#XREFisfinite&quot;&gt;isfinite&lt;/a&gt;.</source>
          <target state="translated">통계 함수는 NaN, NA 또는 Inf를 포함하는 데이터를 테스트하지 않습니다. 이러한 값을 감지하고 명시 적으로 처리해야합니다. &lt;a href=&quot;finding-elements-and-checking-conditions#XREFisnan&quot;&gt;isnan&lt;/a&gt; , &lt;a href=&quot;missing-data#XREFisna&quot;&gt;isna&lt;/a&gt; , &lt;a href=&quot;finding-elements-and-checking-conditions#XREFisinf&quot;&gt;isinf&lt;/a&gt; , &lt;a href=&quot;finding-elements-and-checking-conditions#XREFisfinite&quot;&gt;isfinite를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="47eee20a4048d044576294c6c4af9aca5a353cdd" translate="yes" xml:space="preserve">
          <source>It should be noted that the test for whether a matrix is a candidate for Cholesky factorization, performed above, and by the &lt;code&gt;matrix_type&lt;/code&gt; function, does not make certain that the matrix is Hermitian. However, the attempt to factorize the matrix will quickly detect a non-Hermitian matrix.</source>
          <target state="translated">위에서 수행 한 행렬이 Cholesky 인수 분해의 후보인지 여부와 &lt;code&gt;matrix_type&lt;/code&gt; 함수 에 의한 테스트 는 행렬이 에르 미트 (Hermitian)임을 확신하지 못합니다. 그러나 행렬을 분해하려는 시도는 비-에르 미트 (Hermitian) 행렬을 신속하게 감지합니다.</target>
        </trans-unit>
        <trans-unit id="fbc776594f21bc0018d1b3dca60708db762804d2" translate="yes" xml:space="preserve">
          <source>It should be noted, that due to the way that the Octave assignment functions are written that the assignment will reallocate the memory used by the sparse matrix at each iteration of the above loop. Therefore the &lt;em&gt;spalloc&lt;/em&gt; function ignores the &lt;var&gt;nz&lt;/var&gt; argument and does not pre-assign the memory for the matrix. Therefore, it is vitally important that code using to above structure should be vectorized as much as possible to minimize the number of assignments and reduce the number of memory allocations.</source>
          <target state="translated">옥타브 할당 함수가 작성되는 방식으로 인해, 할당이 상기 루프의 각 반복에서 희소 행렬에 의해 사용 된 메모리를 재 할당한다는 점에 유의해야한다. 따라서 &lt;em&gt;spalloc&lt;/em&gt; 함수는 &lt;var&gt;nz&lt;/var&gt; 인수를 무시 하고 행렬의 메모리를 사전 할당하지 않습니다. 따라서 할당 수를 최소화하고 메모리 할당 수를 줄이려면 위의 구조에 사용하는 코드를 최대한 벡터화해야합니다.</target>
        </trans-unit>
        <trans-unit id="c2d6873909e7db5ab13bfd0e2173c8830c445d3d" translate="yes" xml:space="preserve">
          <source>It will take time to learn Octave&amp;rsquo;s interface for external code and there will inevitably be issues with tools such as compilers.</source>
          <target state="translated">외부 코드에 대한 Octave의 인터페이스를 배우는 데 시간이 걸리고 컴파일러와 같은 도구에 문제가있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="17dc8aaa3ef6a669d182fcea57b63457024207c1" translate="yes" xml:space="preserve">
          <source>It would be much better to use &lt;code&gt;prod (1:n)&lt;/code&gt;, or &lt;code&gt;gamma (n+1)&lt;/code&gt; instead, after first checking to ensure that the value &lt;code&gt;n&lt;/code&gt; is actually a positive integer.</source>
          <target state="translated">값 &lt;code&gt;n&lt;/code&gt; 이 실제로 양의 정수 인지 확인한 후에 대신 &lt;code&gt;prod (1:n)&lt;/code&gt; 또는 &lt;code&gt;gamma (n+1)&lt;/code&gt; 를 사용하는 것이 훨씬 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="3d4bb709bc89a683ed7f19ffc33601ad2c84854f" translate="yes" xml:space="preserve">
          <source>Italic font</source>
          <target state="translated">이탤릭체</target>
        </trans-unit>
        <trans-unit id="2818325a37d4282c94e21a91f2d7b36786af3e7f" translate="yes" xml:space="preserve">
          <source>Iteration limit (either &lt;code&gt;MaxIter&lt;/code&gt; or &lt;code&gt;MaxFunEvals&lt;/code&gt;) exceeded.</source>
          <target state="translated">반복 한계 ( &lt;code&gt;MaxIter&lt;/code&gt; 또는 &lt;code&gt;MaxFunEvals&lt;/code&gt; )를 초과했습니다.</target>
        </trans-unit>
        <trans-unit id="10aee0d73a473ebbdd3f771e0c394b0944dd3eb9" translate="yes" xml:space="preserve">
          <source>Iteration limit exceeded&amp;mdash;either maximum number of algorithm iterations &lt;code&gt;MaxIter&lt;/code&gt; or maximum number of function evaluations &lt;code&gt;MaxFunEvals&lt;/code&gt;.</source>
          <target state="translated">반복 제한이 초과 &lt;code&gt;MaxFunEvals&lt;/code&gt; . 최대 알고리즘 반복 수 &lt;code&gt;MaxIter&lt;/code&gt; 또는 최대 함수 평가 수 MaxFunEvals 입니다.</target>
        </trans-unit>
        <trans-unit id="0cbd40ef9ada118f75c9389b9b0eeeedcbdff506" translate="yes" xml:space="preserve">
          <source>Iterations limit exhausted.</source>
          <target state="translated">반복 한계가 소진되었습니다.</target>
        </trans-unit>
        <trans-unit id="7a404fa80a86fec2abfe5da6d968eda0723bd966" translate="yes" xml:space="preserve">
          <source>Iterative Methods for Linear and Nonlinear Equations</source>
          <target state="translated">선형 및 비선형 방정식에 대한 반복 방법</target>
        </trans-unit>
        <trans-unit id="029e8581922a3ab38668a2bc85b9dfba1866e4da" translate="yes" xml:space="preserve">
          <source>Iterative Methods for Sparse Linear Systems</source>
          <target state="translated">희소 선형 시스템에 대한 반복 방법</target>
        </trans-unit>
        <trans-unit id="1868e0dfe8f34027a357afdc2ce5a9d730fc2c9d" translate="yes" xml:space="preserve">
          <source>Iterative Solution of Large Sparse Systems of Equations</source>
          <target state="translated">큰 희소 방정식 시스템의 반복 솔루션</target>
        </trans-unit>
        <trans-unit id="5fc14c8d2f6874ad77aca3be527e5c7954146bfb" translate="yes" xml:space="preserve">
          <source>Iterative Techniques</source>
          <target state="translated">반복 기법</target>
        </trans-unit>
        <trans-unit id="3ae26d9dc773f98d7f469a50dcbcc86b07a7adde" translate="yes" xml:space="preserve">
          <source>Iterative Techniques Applied to Sparse Matrices</source>
          <target state="translated">희소 행렬에 적용되는 반복 기법</target>
        </trans-unit>
        <trans-unit id="ab29fdc21b447233d29d94f34606379199a34f8c" translate="yes" xml:space="preserve">
          <source>Iterative techniques:</source>
          <target state="translated">반복 기법 :</target>
        </trans-unit>
        <trans-unit id="7d420cfc61361a3f5f3df6a2c1985ea75ab70422" translate="yes" xml:space="preserve">
          <source>Its size has length equal to the values of the next in &lt;var&gt;attributes&lt;/var&gt;. The next value must is an array with the length for each dimension. To ignore the check for a certain dimension, the value of &lt;code&gt;NaN&lt;/code&gt; can be used.</source>
          <target state="translated">크기는 &lt;var&gt;attributes&lt;/var&gt; 에서 다음 값과 길이가 같습니다 . 다음 값은 각 차원의 길이를 가진 배열이어야합니다. 특정 차원의 검사를 무시하기 위해 &lt;code&gt;NaN&lt;/code&gt; 값을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4ab8c21b7fa633f90478f744ebb5e51317a27b92" translate="yes" xml:space="preserve">
          <source>Its value may be one of &lt;code&gt;&quot;centimeters&quot;&lt;/code&gt; | &lt;code&gt;&quot;characters&quot;&lt;/code&gt; | &lt;code&gt;&quot;inches&quot;&lt;/code&gt; | &lt;code&gt;&quot;{normalized}&quot;&lt;/code&gt; | &lt;code&gt;&quot;pixels&quot;&lt;/code&gt; | &lt;code&gt;&quot;points&quot;&lt;/code&gt;.</source>
          <target state="translated">값은 &lt;code&gt;&quot;centimeters&quot;&lt;/code&gt; 중 하나 일 수 있습니다. | &lt;code&gt;&quot;characters&quot;&lt;/code&gt; | &lt;code&gt;&quot;inches&quot;&lt;/code&gt; | &lt;code&gt;&quot;{normalized}&quot;&lt;/code&gt; | &lt;code&gt;&quot;pixels&quot;&lt;/code&gt; | &lt;code&gt;&quot;points&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="58668e7669fd564d99db5d581fcdb6a5618440b5" translate="yes" xml:space="preserve">
          <source>J</source>
          <target state="translated">J</target>
        </trans-unit>
        <trans-unit id="54a53f193f369a345a75c9cdf669f4899bfc3704" translate="yes" xml:space="preserve">
          <source>J = besselj (alpha, x)</source>
          <target state="translated">J = 베셀 지 (알파, x)</target>
        </trans-unit>
        <trans-unit id="ad24de198dbddac8dfacfca5242da694158e6e0f" translate="yes" xml:space="preserve">
          <source>J = besselj (alpha, x, opt)</source>
          <target state="translated">J = 베셀 지 (알파, x, 옵트)</target>
        </trans-unit>
        <trans-unit id="8b7feeec478e4706bd2bc45542f94e2b0a5eb73d" translate="yes" xml:space="preserve">
          <source>JIT Compiler</source>
          <target state="translated">JIT 컴파일러</target>
        </trans-unit>
        <trans-unit id="df134372d2a1a97c43ea25da5ebaeacc1ea67ea8" translate="yes" xml:space="preserve">
          <source>JPEG Image</source>
          <target state="translated">JPEG 이미지</target>
        </trans-unit>
        <trans-unit id="6876b7ffd1cc0a31f5401f27d6bbc78ee4191a46" translate="yes" xml:space="preserve">
          <source>JPEG image</source>
          <target state="translated">JPEG 이미지</target>
        </trans-unit>
        <trans-unit id="c8d75c42e35e518b4da3d6a025db4ef9bfe6202f" translate="yes" xml:space="preserve">
          <source>JPEG/MIFF/PNG compression level. Value is an integer in the range [0 100].</source>
          <target state="translated">JPEG / MIFF / PNG 압축 수준. 값은 [0 100] 범위의 정수입니다.</target>
        </trans-unit>
        <trans-unit id="44d9ab80f02c9ef3726b26c3ccb97d35aad0a281" translate="yes" xml:space="preserve">
          <source>Jacobian</source>
          <target state="translated">Jacobian</target>
        </trans-unit>
        <trans-unit id="b71df2ac565275f195e74f3c6d0166f28e9560c4" translate="yes" xml:space="preserve">
          <source>Jacobian matrix, specified as a constant matrix or a function of time and state.</source>
          <target state="translated">자 코비안 행렬로, 상수 행렬 또는 시간 및 상태 함수로 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="276bbd673319b8da1c62a0b5bc42a2ddcf6f5f5f" translate="yes" xml:space="preserve">
          <source>Java Development Kit</source>
          <target state="translated">자바 개발 키트</target>
        </trans-unit>
        <trans-unit id="49104a70b212d8061a12425d9455215d30d2fd8b" translate="yes" xml:space="preserve">
          <source>Java Interface</source>
          <target state="translated">자바 인터페이스</target>
        </trans-unit>
        <trans-unit id="8492290179530bec758b5fbef3094e48a8a35f1c" translate="yes" xml:space="preserve">
          <source>Java Interface Functions</source>
          <target state="translated">자바 인터페이스 기능</target>
        </trans-unit>
        <trans-unit id="8e8344d046492ebfed5d94dfd1b9d1af1baf4765" translate="yes" xml:space="preserve">
          <source>Java Virtual Machine.</source>
          <target state="translated">자바 가상 머신.</target>
        </trans-unit>
        <trans-unit id="ccd8a87d9506ef33b74c0ee015e1265b426159fc" translate="yes" xml:space="preserve">
          <source>Java finds classes by searching a &lt;var&gt;classpath&lt;/var&gt; which is a list of Java archive files and/or directories containing class files. In Octave the &lt;var&gt;classpath&lt;/var&gt; is composed of two parts:</source>
          <target state="translated">Java는 Java 아카이브 파일 및 / 또는 클래스 파일을 포함하는 디렉토리 목록 인 &lt;var&gt;classpath&lt;/var&gt; 를 검색하여 클래스 를 찾습니다 . 옥타브에서 &lt;var&gt;classpath&lt;/var&gt; 는 두 부분으로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="c82e0980f1c5a68ace2533373172cd47a3a24f22" translate="yes" xml:space="preserve">
          <source>Java programming language compiler and libraries. The OpenJDK free software implementation is recommended (&lt;a href=&quot;http://openjdk.java.net/&quot;&gt;http://openjdk.java.net/&lt;/a&gt;), although other JDK implementations may work. Java is required to be able to call Java functions from within Octave.</source>
          <target state="translated">Java 프로그래밍 언어 컴파일러 및 라이브러리 다른 JDK 구현이 작동 할 수 있지만 OpenJDK 자유 소프트웨어 구현이 권장됩니다 ( &lt;a href=&quot;http://openjdk.java.net/&quot;&gt;http://openjdk.java.net/&lt;/a&gt; ). Octave 내에서 Java 함수를 호출하려면 Java가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="f170b5fc3fb22363bbf624604eca6c80587383c7" translate="yes" xml:space="preserve">
          <source>Javascript-based drawing on an HTML5 canvas viewable in a web browser.</source>
          <target state="translated">웹 브라우저에서 볼 수있는 HTML5 캔버스의 Javascript 기반 도면.</target>
        </trans-unit>
        <trans-unit id="d649f36220db65d7994d32922dff21b6e0790b59" translate="yes" xml:space="preserve">
          <source>Join the elements of the cell string array, &lt;var&gt;cstr&lt;/var&gt;, into a single string.</source>
          <target state="translated">셀 문자열 배열 &lt;var&gt;cstr&lt;/var&gt; 의 요소를 단일 문자열로 결합하십시오.</target>
        </trans-unit>
        <trans-unit id="2c2839c644c3fadb37538bacc7c271c2c29d92e6" translate="yes" xml:space="preserve">
          <source>Joins any number of path components intelligently. The return value is the concatenation of each component with exactly one file separator between each non empty part and at most one leading and/or trailing file separator.</source>
          <target state="translated">여러 경로 구성 요소를 지능적으로 결합합니다. 반환 값은 비어 있지 않은 각 부분과 최대 하나의 선행 및 / 또는 후행 파일 구분 기호 사이에 정확히 하나의 파일 구분 기호가있는 각 구성 요소의 연결입니다.</target>
        </trans-unit>
        <trans-unit id="97334835cf3bd4ff49ed61b961b56ec9717c5314" translate="yes" xml:space="preserve">
          <source>Jump to:</source>
          <target state="translated">다음으로 이동 :</target>
        </trans-unit>
        <trans-unit id="312693745269a039b47fc6e71591980dede04cfa" translate="yes" xml:space="preserve">
          <source>Just as for numerical arrays, it is possible to use vectors as indices (see &lt;a href=&quot;index-expressions#Index-Expressions&quot;&gt;Index Expressions&lt;/a&gt;):</source>
          <target state="translated">숫자 형 배열과 마찬가지로 벡터를 인덱스로 사용할 수 있습니다 ( &lt;a href=&quot;index-expressions#Index-Expressions&quot;&gt;색인 식&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="750ef682e8526c26ef4561f690889ac6b3c39c0e" translate="yes" xml:space="preserve">
          <source>Just like numerical arrays, cell arrays can be multi-dimensional. The &lt;code&gt;cell&lt;/code&gt; function accepts any number of positive integers to describe the size of the returned cell array. It is also possible to set the size of the cell array through a vector of positive integers. In the following example two cell arrays of equal size are created, and the size of the first one is displayed</source>
          <target state="translated">숫자 형 배열과 마찬가지로 셀형 배열은 다차원 일 수 있습니다. &lt;code&gt;cell&lt;/code&gt; 함수 반환 셀 어레이의 크기를 설명하는 양의 정수의 숫자를 받아 들인다. 양의 정수로 구성된 벡터를 통해 셀형 배열의 크기를 설정할 수도 있습니다. 다음 예제에서는 동일한 크기의 두 셀 배열이 작성되고 첫 번째 셀 크기가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="b47bbf381595d68ae499a342afa5b8e80af5970c" translate="yes" xml:space="preserve">
          <source>Just-In-Time Compiler for loops</source>
          <target state="translated">루프 용 JIT (Just-In-Time) 컴파일러</target>
        </trans-unit>
        <trans-unit id="a7ee38bb7be4fc44198cb2685d9601dcf2b9f569" translate="yes" xml:space="preserve">
          <source>K</source>
          <target state="translated">K</target>
        </trans-unit>
        <trans-unit id="57689c620ffa83c8c2a534d93e670d9a87902165" translate="yes" xml:space="preserve">
          <source>K = besselk (alpha, x)</source>
          <target state="translated">K = 베셀 크 (알파, x)</target>
        </trans-unit>
        <trans-unit id="8dbca16e1f930c6fe67a473d14c8cb0887fba1df" translate="yes" xml:space="preserve">
          <source>K = besselk (alpha, x, opt)</source>
          <target state="translated">K = 베셀 크 (알파, x, opt)</target>
        </trans-unit>
        <trans-unit id="e9c17233a58fe8bc7d7a4be8d18ae702a42aed87" translate="yes" xml:space="preserve">
          <source>Keep in mind that the purpose of a bug report is to enable someone to fix the bug if it is not known. Always write your bug reports on the assumption that the bug is not known.</source>
          <target state="translated">버그 보고서의 목적은 누군가가 버그를 알 수없는 경우 수정하도록하는 것입니다. 버그를 알 수 없다는 가정하에 항상 버그 보고서를 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="057f5863b6a5e1daf5d379b714b799b838327941" translate="yes" xml:space="preserve">
          <source>Key press events: &lt;code&gt;evt&lt;/code&gt; is a structure with fields &lt;code&gt;Key&lt;/code&gt; (string), &lt;code&gt;Character&lt;/code&gt; (string), and &lt;code&gt;Modifier&lt;/code&gt; (cell array of strings).</source>
          <target state="translated">키 누름 이벤트 : &lt;code&gt;evt&lt;/code&gt; 는 &lt;code&gt;Key&lt;/code&gt; (문자열), &lt;code&gt;Character&lt;/code&gt; (문자열) 및 &lt;code&gt;Modifier&lt;/code&gt; (문자열의 셀 배열 ) 필드가있는 구조입니다 .</target>
        </trans-unit>
        <trans-unit id="584c30d92d820fafc106db0685ba87809df26702" translate="yes" xml:space="preserve">
          <source>KeyName</source>
          <target state="translated">KeyName</target>
        </trans-unit>
        <trans-unit id="bb3c05a548b50d8ab473aa91a3bc6c081c4b5c99" translate="yes" xml:space="preserve">
          <source>KeyValue</source>
          <target state="translated">KeyValue</target>
        </trans-unit>
        <trans-unit id="f530db58b3e5088dc7412c6d2298ba3f8456bdeb" translate="yes" xml:space="preserve">
          <source>Keywords</source>
          <target state="translated">Keywords</target>
        </trans-unit>
        <trans-unit id="bb3e53dde1051fa68b5f3059706baa347a65cb3b" translate="yes" xml:space="preserve">
          <source>Kill from the cursor to the end of the current word, or if between words, to the end of the next word.</source>
          <target state="translated">커서에서 현재 단어의 끝까지 또는 단어 사이에있는 경우 다음 단어의 끝까지 죽입니다.</target>
        </trans-unit>
        <trans-unit id="311a4cde3db454c3849e6ee13e45582356a552a1" translate="yes" xml:space="preserve">
          <source>Kill from the cursor to the previous whitespace. This is different than</source>
          <target state="translated">커서에서 이전 공백으로 죽입니다. 이것은 다른</target>
        </trans-unit>
        <trans-unit id="dd0b1d2577b52f29b4880fc67c15fb2fbe8fa80c" translate="yes" xml:space="preserve">
          <source>Kill from the cursor to the start of the previous word, or if between words, to the start of the previous word.</source>
          <target state="translated">커서에서 이전 단어의 시작으로 또는 단어 사이에있는 경우 이전 단어의 시작으로 죽입니다.</target>
        </trans-unit>
        <trans-unit id="a6ffad75f2cec42a116c1a0e5d568a0039830396" translate="yes" xml:space="preserve">
          <source>Kill the text from the current cursor position to the end of the line.</source>
          <target state="translated">현재 커서 위치에서 줄 끝까지 텍스트를 종료하십시오.</target>
        </trans-unit>
        <trans-unit id="a07775adc8882c71528193fd44d0c2fe8fad4361" translate="yes" xml:space="preserve">
          <source>Killing and Yanking</source>
          <target state="translated">죽이고 Yan 킹</target>
        </trans-unit>
        <trans-unit id="8adf8aee8da794b048790c9b3a2cef027fa664f5" translate="yes" xml:space="preserve">
          <source>Known &lt;small&gt;MATLAB&lt;/small&gt; incompatibilities:</source>
          <target state="translated">알려진 &lt;small&gt;MATLAB&lt;/small&gt; 비 호환성 :</target>
        </trans-unit>
        <trans-unit id="5ad1e1963d1eeaff6171a90eab990d5450c9d160" translate="yes" xml:space="preserve">
          <source>Known &lt;small&gt;MATLAB&lt;/small&gt; incompatibility: If tolerances are left unspecified, and any integration limits are of type &lt;code&gt;single&lt;/code&gt;, then Octave&amp;rsquo;s integral functions automatically reduce the default absolute and relative error tolerances as specified above. If tighter tolerances are desired they must be specified. &lt;small&gt;MATLAB&lt;/small&gt; leaves the tighter tolerances appropriate for &lt;code&gt;double&lt;/code&gt; inputs in place regardless of the class of the integration limits.</source>
          <target state="translated">알려진 &lt;small&gt;MATLAB&lt;/small&gt; 비 호환성 : 공차를 지정하지 않고 통합 한계가 &lt;code&gt;single&lt;/code&gt; 유형 인 경우 Octave의 적분 함수는 위에 지정된 기본 절대 및 상대 오차 공차를 자동으로 줄입니다. 더 엄격한 공차가 필요한 경우 지정해야합니다. &lt;small&gt;MATLAB&lt;/small&gt; 은 통합 한계 등급에 관계없이 &lt;code&gt;double&lt;/code&gt; 입력에 적절한 공차를 유지 합니다.</target>
        </trans-unit>
        <trans-unit id="d160e0986aca4714714a16f29ec605af90be704d" translate="yes" xml:space="preserve">
          <source>L</source>
          <target state="translated">L</target>
        </trans-unit>
        <trans-unit id="15bdb17cd8576bde365eefd0b126244078186b26" translate="yes" xml:space="preserve">
          <source>L = del2 (M)</source>
          <target state="translated">L = 델 2 (M)</target>
        </trans-unit>
        <trans-unit id="907f98b81a37777dce2e2af5fec9db4b232f9a77" translate="yes" xml:space="preserve">
          <source>L = del2 (M, dx, dy, &amp;hellip;)</source>
          <target state="translated">L = del2 (M, dx, dy,&amp;hellip;)</target>
        </trans-unit>
        <trans-unit id="b42396e10d4cd7349b5f17127136074fa0dfb04d" translate="yes" xml:space="preserve">
          <source>L = del2 (M, h)</source>
          <target state="translated">L = del2 (M, h)</target>
        </trans-unit>
        <trans-unit id="fcdef24a41b55b36260a718ebe36cf419b4d8b1f" translate="yes" xml:space="preserve">
          <source>L = ichol (A)</source>
          <target state="translated">L = ichol (A)</target>
        </trans-unit>
        <trans-unit id="992315675dab406248a40c07c3e0e6dc07927b00" translate="yes" xml:space="preserve">
          <source>L = ichol (A, opts)</source>
          <target state="translated">L = ichol (A, 선택)</target>
        </trans-unit>
        <trans-unit id="86cd089e40d0c606f2f0046e0b6420e629e115b6" translate="yes" xml:space="preserve">
          <source>L. Montanet, et al.,</source>
          <target state="translated">L. Montanet 등</target>
        </trans-unit>
        <trans-unit id="cf9e7dcbce935737e3132c8567095e62b32e357d" translate="yes" xml:space="preserve">
          <source>LAPACK</source>
          <target state="translated">LAPACK</target>
        </trans-unit>
        <trans-unit id="a60df4da6c9746262f598bbd8376da4500fb47e1" translate="yes" xml:space="preserve">
          <source>LFD</source>
          <target state="translated">LFD</target>
        </trans-unit>
        <trans-unit id="a230d4a66845b14c7d2a6ab825e82549a7f4cacc" translate="yes" xml:space="preserve">
          <source>LLVM</source>
          <target state="translated">LLVM</target>
        </trans-unit>
        <trans-unit id="6c62fb7313eb9d28efbca3e61ff13801b5b45a0a" translate="yes" xml:space="preserve">
          <source>LT</source>
          <target state="translated">LT</target>
        </trans-unit>
        <trans-unit id="db6d3a7d1de58d0e5681b2ec5404bb0734a30b3b" translate="yes" xml:space="preserve">
          <source>LaTeX Markup</source>
          <target state="translated">LaTeX 마크 업</target>
        </trans-unit>
        <trans-unit id="7a62d1b77798556d0ab1261eb31bd174c1cb067c" translate="yes" xml:space="preserve">
          <source>LaTeX picture environment and extended picture environment.</source>
          <target state="translated">LaTeX 사진 환경 및 확장 된 사진 환경.</target>
        </trans-unit>
        <trans-unit id="587b9347d2622a69e7c01940cb47ce5636a95ca5" translate="yes" xml:space="preserve">
          <source>Labels of x tick marks. Setting &lt;code&gt;xticklabel&lt;/code&gt; also forces the &lt;code&gt;xticklabelmode&lt;/code&gt; property to be set to &lt;code&gt;&quot;manual&quot;&lt;/code&gt;.</source>
          <target state="translated">x 눈금 표시의 레이블. &lt;code&gt;xticklabel&lt;/code&gt; 을 설정 하면 &lt;code&gt;xticklabelmode&lt;/code&gt; 등록 정보가 &lt;code&gt;&quot;manual&quot;&lt;/code&gt; 로 강제 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="c9f71215c27ab812c79ca46a24de90d704ce1d2f" translate="yes" xml:space="preserve">
          <source>Labels of y tick marks. Setting &lt;code&gt;yticklabel&lt;/code&gt; also forces the &lt;code&gt;yticklabelmode&lt;/code&gt; property to be set to &lt;code&gt;&quot;manual&quot;&lt;/code&gt;.</source>
          <target state="translated">y 눈금 표시의 레이블. &lt;code&gt;yticklabel&lt;/code&gt; 을 설정 하면 &lt;code&gt;yticklabelmode&lt;/code&gt; 특성이 &lt;code&gt;&quot;manual&quot;&lt;/code&gt; 로 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="6ac84f1d027997165e58cc346c81efa56aa31f75" translate="yes" xml:space="preserve">
          <source>Labels of z tick marks. Setting &lt;code&gt;zticklabel&lt;/code&gt; also forces the &lt;code&gt;zticklabelmode&lt;/code&gt; property to be set to &lt;code&gt;&quot;manual&quot;&lt;/code&gt;.</source>
          <target state="translated">z 눈금 표시의 레이블. &lt;code&gt;zticklabel&lt;/code&gt; 을 설정 하면 &lt;code&gt;zticklabelmode&lt;/code&gt; 특성이 &lt;code&gt;&quot;manual&quot;&lt;/code&gt; 로 강제 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="9f2c50daecde30b40e5f26dd88e01bd7c4656b28" translate="yes" xml:space="preserve">
          <source>Largest Algebraic (valid only for real symmetric problems).</source>
          <target state="translated">가장 큰 대수 (실제 대칭 문제에만 유효).</target>
        </trans-unit>
        <trans-unit id="4576dbf10320933cba3352caa2b8938c216425b9" translate="yes" xml:space="preserve">
          <source>Largest Imaginary part (valid only for complex or unsymmetric problems).</source>
          <target state="translated">가장 큰 허수 부분 (복잡하거나 비대칭 문제에만 유효).</target>
        </trans-unit>
        <trans-unit id="1bd096ec65cf389b55313c44574fd4a4837da83c" translate="yes" xml:space="preserve">
          <source>Largest Magnitude (default).</source>
          <target state="translated">가장 큰 크기 (기본값).</target>
        </trans-unit>
        <trans-unit id="7e9eace53eca8a79f2f66f9a3663049865c53ef3" translate="yes" xml:space="preserve">
          <source>Largest Real part (valid only for complex or unsymmetric problems).</source>
          <target state="translated">가장 큰 실수 부 (복잡하거나 비대칭 문제에만 유효).</target>
        </trans-unit>
        <trans-unit id="cb967472dd6ecb5171638fd33e391e9a748cbdec" translate="yes" xml:space="preserve">
          <source>Largest singular value of &lt;var&gt;A&lt;/var&gt;.</source>
          <target state="translated">&lt;var&gt;A&lt;/var&gt; 의 가장 큰 특이 값입니다 .</target>
        </trans-unit>
        <trans-unit id="6c0181b5412cccc52e1df28e49a5a652dda444f8" translate="yes" xml:space="preserve">
          <source>Last fractional variable.</source>
          <target state="translated">마지막 분수 변수.</target>
        </trans-unit>
        <trans-unit id="e88e0b124bb30b81a2b9941bd353f54e925d0351" translate="yes" xml:space="preserve">
          <source>Last relative change in function value was less than &lt;code&gt;TolFun&lt;/code&gt;.</source>
          <target state="translated">함수 값의 마지막 상대 변경이 &lt;code&gt;TolFun&lt;/code&gt; 보다 작 습니다 .</target>
        </trans-unit>
        <trans-unit id="170022d1815546c7ac385d0c063f2f9de3c5756b" translate="yes" xml:space="preserve">
          <source>Last relative decrease in residual was less than &lt;code&gt;TolFun&lt;/code&gt;.</source>
          <target state="translated">잔류의 마지막 상대적인 감소는 &lt;code&gt;TolFun&lt;/code&gt; 보다 작 습니다 .</target>
        </trans-unit>
        <trans-unit id="8c8df2e00a2456ffb151e69b88ebb5e6205b3e8b" translate="yes" xml:space="preserve">
          <source>Last relative step size was less than &lt;code&gt;TolX&lt;/code&gt;.</source>
          <target state="translated">마지막 상대 단계 크기는 &lt;code&gt;TolX&lt;/code&gt; 보다 작 습니다 .</target>
        </trans-unit>
        <trans-unit id="8541d11b47f3f4a46d776cd488514b6636d46d44" translate="yes" xml:space="preserve">
          <source>Last two digits of year (00-99).</source>
          <target state="translated">연도의 마지막 두 자리 (00-99).</target>
        </trans-unit>
        <trans-unit id="ba3ec335171242203551fa118476e51f704af516" translate="yes" xml:space="preserve">
          <source>Lazy copying applies to whole Octave objects such as matrices, cells, struct, and also individual cell or struct elements (not array elements).</source>
          <target state="translated">게으른 복사는 행렬, 셀, 구조체 및 개별 셀 또는 구조체 요소 (배열 요소 아님)와 같은 전체 Octave 객체에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="56a4be1595f58ac75c5fbbdb289963c484b1a642" translate="yes" xml:space="preserve">
          <source>Leading delimiters are ignored. If &lt;var&gt;delim&lt;/var&gt; is not specified, whitespace is assumed.</source>
          <target state="translated">선행 분리 문자는 무시됩니다. 경우 &lt;var&gt;delim&lt;/var&gt; 지정되지 않은 공백 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="759892c76f51dcbe9fa69042e3c6abea0f331e04" translate="yes" xml:space="preserve">
          <source>Leave command-line debugging mode and continue code execution normally.</source>
          <target state="translated">명령 행 디버깅 모드를 종료하고 코드 실행을 정상적으로 계속하십시오.</target>
        </trans-unit>
        <trans-unit id="8d47af1b3fb067e0f579c59dc23a58df336c8fdb" translate="yes" xml:space="preserve">
          <source>Leaving Debug Mode</source>
          <target state="translated">디버그 모드 떠나기</target>
        </trans-unit>
        <trans-unit id="93f128b07389dda53d61ac4d707ac819ef7babcf" translate="yes" xml:space="preserve">
          <source>Left alignment.</source>
          <target state="translated">왼쪽 정렬.</target>
        </trans-unit>
        <trans-unit id="cd24cc4dec471fdcd13d2657906d0fa67c962a68" translate="yes" xml:space="preserve">
          <source>Left center of the screen.</source>
          <target state="translated">화면의 왼쪽 중앙.</target>
        </trans-unit>
        <trans-unit id="6278d6c93e2ecce333624436f60f10abd1425157" translate="yes" xml:space="preserve">
          <source>Left division. This is conceptually equivalent to the expression</source>
          <target state="translated">왼쪽 부서. 이것은 개념적으로 표현과 같습니다.</target>
        </trans-unit>
        <trans-unit id="01402cf0211750fafe682676370dd5fef7ef5510" translate="yes" xml:space="preserve">
          <source>Left-click.</source>
          <target state="translated">Left-click.</target>
        </trans-unit>
        <trans-unit id="c5ed16bca4920ace31f862f7ac42bd6b86f740ef" translate="yes" xml:space="preserve">
          <source>Left-justify the result in the field (instead of the normal right-justification).</source>
          <target state="translated">필드에서 결과를 왼쪽에 맞 춥니 다 (일반적인 오른쪽 정렬 대신).</target>
        </trans-unit>
        <trans-unit id="6786f7c0719723c4e8a35593d9ed8a0c7268b868" translate="yes" xml:space="preserve">
          <source>Left-justify the result in the field. Normally the result is right-justified.</source>
          <target state="translated">필드에서 결과를 왼쪽으로 맞 춥니 다. 일반적으로 결과는 오른쪽 정렬됩니다.</target>
        </trans-unit>
        <trans-unit id="50796993bd8cbc0462858d934d817e906f6ca7ba" translate="yes" xml:space="preserve">
          <source>Left. For numeric lookups the leftmost subinterval shall be extended to minus infinity (i.e., all indices at least 1).</source>
          <target state="translated">왼쪽. 숫자 조회의 경우 가장 왼쪽 하위 간격을 빼기 무한대 (즉, 모든 지수는 1 이상)로 확장해야합니다.</target>
        </trans-unit>
        <trans-unit id="774298fa30dbdd6934a5f8bdf02fc102da344189" translate="yes" xml:space="preserve">
          <source>Legend Properties</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a199d7dfa3a668cd5df3794bf18f4e9629576774" translate="yes" xml:space="preserve">
          <source>Legend entries may be specified as individual character string arguments, a character array, or a cell array of character strings. When label names might be confused with legend properties, or &lt;var&gt;command&lt;/var&gt; arguments, the labels should be protected by specifying them as a cell array of strings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55e38c3052eebb9948a706802b690ceaf1df26ab" translate="yes" xml:space="preserve">
          <source>Legend entries may be specified as individual character string arguments, a character array, or a cell array of character strings. When label names might be confused with options to &lt;code&gt;legend&lt;/code&gt;, the labels should be protected by specifying them as a cell array of strings.</source>
          <target state="translated">범례 항목은 개별 문자열 인수, 문자 배열 또는 문자열의 셀 배열로 지정할 수 있습니다. 레이블 이름이 &lt;code&gt;legend&lt;/code&gt; 옵션과 혼동 될 수있는 경우 레이블을 문자열의 셀형 배열로 지정하여 레이블을 보호해야합니다.</target>
        </trans-unit>
        <trans-unit id="1e0d3ca79381f710352325e10f143a8112e3b5f5" translate="yes" xml:space="preserve">
          <source>Legend labels are associated with the axes&amp;rsquo; children; The first label is assigned to the first object that was plotted in the axes, the second label to the next object plotted, etc. To label specific data objects, without labeling all objects, provide their graphic handles in the input &lt;var&gt;hobjs&lt;/var&gt;.</source>
          <target state="translated">범례 레이블은 좌표축의 자식과 연결됩니다. 첫 번째 레이블은 축에 플로팅 된 첫 번째 개체에 할당되고 두 번째 레이블은 플로팅 된 다음 개체에 지정됩니다. 모든 개체에 레이블을 지정하지 않고 특정 데이터 개체에 레이블을 지정하려면 입력 &lt;var&gt;hobjs&lt;/var&gt; 에 그래픽 핸들을 제공 하십시오 .</target>
        </trans-unit>
        <trans-unit id="1d3d412a0852cc56c28ad0c2a1153229aa365b43" translate="yes" xml:space="preserve">
          <source>Less than</source>
          <target state="translated">이하</target>
        </trans-unit>
        <trans-unit id="33331a5bba7154831ad991e3d73f2368d8a52f4d" translate="yes" xml:space="preserve">
          <source>Less than or equal to</source>
          <target state="translated">이하</target>
        </trans-unit>
        <trans-unit id="2b67e2c9559015be4656b3fda9025464f1acfc5f" translate="yes" xml:space="preserve">
          <source>Less than or equal to zero.</source>
          <target state="translated">0보다 작거나 같습니다.</target>
        </trans-unit>
        <trans-unit id="603482da370f6f4e8cab51db743a45b2aaaba552" translate="yes" xml:space="preserve">
          <source>Less than zero.</source>
          <target state="translated">0보다 작습니다.</target>
        </trans-unit>
        <trans-unit id="bad3044fe47bef85e9119c1aa82f8a35292076ec" translate="yes" xml:space="preserve">
          <source>Let us consider a trivial problem with a diagonal matrix (we exploit the sparsity of A)</source>
          <target state="translated">대각선 행렬의 사소한 문제를 고려해 봅시다 (A의 희소성을 이용합니다)</target>
        </trans-unit>
        <trans-unit id="d1607a278a25b2ece5bb25a2ecebbe81c8c6149c" translate="yes" xml:space="preserve">
          <source>Let us consider a trivial problem with a tridiagonal matrix</source>
          <target state="translated">tridiagonal matrix의 사소한 문제를 생각해 보자</target>
        </trans-unit>
        <trans-unit id="5eaa1d501064d059b1266b678734d2b177ec5fbf" translate="yes" xml:space="preserve">
          <source>Letting Readline Type for You</source>
          <target state="translated">당신을 위해 readline 유형을 허용</target>
        </trans-unit>
        <trans-unit id="8283a89c4d467b70162851a7718b7ce860adf53b" translate="yes" xml:space="preserve">
          <source>Level of messages output by solver routines:</source>
          <target state="translated">솔버 루틴이 출력하는 메시지 레벨 :</target>
        </trans-unit>
        <trans-unit id="164d3e89bffb60941d4e91ea74289532409c3662" translate="yes" xml:space="preserve">
          <source>Lexer analyzer (&lt;a href=&quot;https://www.gnu.org/software/flex&quot;&gt;https://www.gnu.org/software/flex&lt;/a&gt;). You will need Flex if you modify the &lt;code&gt;lex.ll&lt;/code&gt; source file or if you delete the files that are generated from it.</source>
          <target state="translated">Lexer 분석기 ( &lt;a href=&quot;https://www.gnu.org/software/flex&quot;&gt;https://www.gnu.org/software/flex&lt;/a&gt; ). &lt;code&gt;lex.ll&lt;/code&gt; 소스 파일 을 수정 하거나이 파일에서 생성 된 파일을 삭제하는 경우 Flex가 필요 합니다.</target>
        </trans-unit>
        <trans-unit id="d4b06e4a557f39975792809007fcb2956278a344" translate="yes" xml:space="preserve">
          <source>Libraries like liboctave.a and liboctinterp.a.</source>
          <target state="translated">liboctave.a 및 liboctinterp.a와 같은 라이브러리</target>
        </trans-unit>
        <trans-unit id="5b118f1ca4885afa85044fcd2726741072ccaa46" translate="yes" xml:space="preserve">
          <source>Library for computing discrete Fourier transforms (&lt;a href=&quot;http://www.fftw.org&quot;&gt;http://www.fftw.org&lt;/a&gt;). FFTW3 is used to provide better performance for functions that compute discrete Fourier transforms (&lt;code&gt;fft&lt;/code&gt;, &lt;code&gt;ifft&lt;/code&gt;, &lt;code&gt;fft2&lt;/code&gt;, etc.)</source>
          <target state="translated">이산 푸리에 변환을 계산하기위한 라이브러리 ( &lt;a href=&quot;http://www.fftw.org&quot;&gt;http://www.fftw.org&lt;/a&gt; ) FFTW3은 이산 푸리에 변환 ( &lt;code&gt;fft&lt;/code&gt; , &lt;code&gt;ifft&lt;/code&gt; , &lt;code&gt;fft2&lt;/code&gt; 등) 을 계산하는 함수에 더 나은 성능을 제공하는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="bbba52533d5bef045710e1d3d63707be08bd0c63" translate="yes" xml:space="preserve">
          <source>Library for configuring and customizing font access (&lt;a href=&quot;https://www.freedesktop.org/wiki/Software/fontconfig&quot;&gt;https://www.freedesktop.org/wiki/Software/fontconfig&lt;/a&gt;). Fontconfig is used to manage fonts for Octave&amp;rsquo;s OpenGL-based graphics functions.</source>
          <target state="translated">글꼴 액세스 구성 및 사용자 정의를위한 라이브러리 ( &lt;a href=&quot;https://www.freedesktop.org/wiki/Software/fontconfig&quot;&gt;https://www.freedesktop.org/wiki/Software/fontconfig&lt;/a&gt; ) Fontconfig는 Octave의 OpenGL 기반 그래픽 기능을위한 글꼴을 관리하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="0c8aec366b5cd8fc6a99d17b7ed6e625f89f8912" translate="yes" xml:space="preserve">
          <source>Library for manipulating portable data files (&lt;a href=&quot;https://www.hdfgroup.org/HDF5&quot;&gt;https://www.hdfgroup.org/HDF5&lt;/a&gt;). &lt;small&gt;HDF5&lt;/small&gt; is required for Octave&amp;rsquo;s &lt;code&gt;load&lt;/code&gt; and &lt;code&gt;save&lt;/code&gt; commands to read and write HDF data files.</source>
          <target state="translated">휴대용 데이터 파일 조작을위한 라이브러리 ( &lt;a href=&quot;https://www.hdfgroup.org/HDF5&quot;&gt;https://www.hdfgroup.org/HDF5&lt;/a&gt; ) &lt;small&gt;HDF5&lt;/small&gt; 는 Octave의 &lt;code&gt;load&lt;/code&gt; 및 &lt;code&gt;save&lt;/code&gt; 명령이 HDF 데이터 파일을 읽고 쓰는 데 필요합니다.</target>
        </trans-unit>
        <trans-unit id="1c2d642b5848589d4b5b86a04f16da4d4dea4701" translate="yes" xml:space="preserve">
          <source>Library for the solution of large-scale eigenvalue problems (&lt;a href=&quot;https://forge.scilab.org/index.php/p/arpack-ng&quot;&gt;https://forge.scilab.org/index.php/p/arpack-ng&lt;/a&gt;). &lt;small&gt;ARPACK&lt;/small&gt; is required to provide the functions &lt;code&gt;eigs&lt;/code&gt; and &lt;code&gt;svds&lt;/code&gt;.</source>
          <target state="translated">대규모 고유 값 문제 해결을위한 라이브러리 ( &lt;a href=&quot;https://forge.scilab.org/index.php/p/arpack-ng&quot;&gt;https://forge.scilab.org/index.php/p/arpack-ng&lt;/a&gt; ) &lt;small&gt;ARPACK&lt;/small&gt; 은 &lt;code&gt;eigs&lt;/code&gt; 및 &lt;code&gt;svds&lt;/code&gt; 기능을 제공해야합니다 .</target>
        </trans-unit>
        <trans-unit id="19f0338eb48b5041aa9a7b825f708aa19ea0cc3d" translate="yes" xml:space="preserve">
          <source>Library for transferring data with URL syntax (&lt;a href=&quot;https://curl.haxx.se&quot;&gt;https://curl.haxx.se&lt;/a&gt;). cURL is required to provide the &lt;code&gt;urlread&lt;/code&gt; and &lt;code&gt;urlwrite&lt;/code&gt; functions and the &lt;code&gt;ftp&lt;/code&gt; class.</source>
          <target state="translated">URL 구문으로 데이터를 전송하기위한 라이브러리 ( &lt;a href=&quot;https://curl.haxx.se&quot;&gt;https://curl.haxx.se&lt;/a&gt; ) &lt;code&gt;urlread&lt;/code&gt; 및 &lt;code&gt;urlwrite&lt;/code&gt; 기능과 &lt;code&gt;ftp&lt;/code&gt; 클래스 를 제공하려면 cURL이 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="cf8f017afcb5592c55d48be277a2df204caa87e5" translate="yes" xml:space="preserve">
          <source>Libtool</source>
          <target state="translated">Libtool</target>
        </trans-unit>
        <trans-unit id="48efd407845516801aba1647ccf77e51d19e56c5" translate="yes" xml:space="preserve">
          <source>Light Properties</source>
          <target state="translated">라이트 속성</target>
        </trans-unit>
        <trans-unit id="b5c11eb4cc2cb48e6095118ec98e0a4240c5126c" translate="yes" xml:space="preserve">
          <source>Lighting is only supported for OpenGL graphic toolkits (i.e., &lt;code&gt;&quot;fltk&quot;&lt;/code&gt; and &lt;code&gt;&quot;qt&quot;&lt;/code&gt;).</source>
          <target state="translated">조명은 OpenGL 그래픽 툴킷 (예 : &lt;code&gt;&quot;fltk&quot;&lt;/code&gt; 및 &lt;code&gt;&quot;qt&quot;&lt;/code&gt; ) 에서만 지원됩니다 .</target>
        </trans-unit>
        <trans-unit id="e4b3d77db86f55149159c32cc85bb610074d745b" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&quot;measure&quot;&lt;/code&gt;, but all possible algorithms that may be used to treat the transform are considered.</source>
          <target state="translated">&lt;code&gt;&quot;measure&quot;&lt;/code&gt; 와 유사 하지만 변환을 처리하는 데 사용할 수있는 모든 가능한 알고리즘이 고려됩니다.</target>
        </trans-unit>
        <trans-unit id="35ee1dc7c514a634176de58d3c02ef95225f96d8" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;eval&lt;/code&gt;, except that the expressions are evaluated in the context &lt;var&gt;context&lt;/var&gt;, which may be either &lt;code&gt;&quot;caller&quot;&lt;/code&gt; or &lt;code&gt;&quot;base&quot;&lt;/code&gt;.</source>
          <target state="translated">마찬가지로 &lt;code&gt;eval&lt;/code&gt; , 표현은 문맥에서 평가된다는 점을 제외하고는 &lt;var&gt;context&lt;/var&gt; 이 될 수있다 &lt;code&gt;&quot;caller&quot;&lt;/code&gt; 또는 &lt;code&gt;&quot;base&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="769f70d9cd46b7fa83fdbe8df99ec8858ccfcb8b" translate="yes" xml:space="preserve">
          <source>Like an error, a warning is issued when something unexpected happens. Unlike an error, a warning doesn&amp;rsquo;t abort the currently running program. A simple example of a warning is when a number is divided by zero. In this case Octave will issue a warning and assign the value &lt;code&gt;Inf&lt;/code&gt; to the result.</source>
          <target state="translated">오류와 같이 예기치 않은 상황이 발생하면 경고가 발행됩니다. 오류와 달리 경고는 현재 실행중인 프로그램을 중단하지 않습니다. 경고의 간단한 예는 숫자를 0으로 나누는 경우입니다. 이 경우 Octave는 경고를 발행 하고 결과에 값 &lt;code&gt;Inf&lt;/code&gt; 를 지정합니다 .</target>
        </trans-unit>
        <trans-unit id="07f03b2420a3b3c12b8f45d855b1047247cecdcd" translate="yes" xml:space="preserve">
          <source>Like comparison operations, each element of an element-by-element boolean expression also has a numeric value (1 if true, 0 if false) that comes into play if the result of the boolean expression is stored in a variable, or used in arithmetic.</source>
          <target state="translated">비교 연산과 마찬가지로 요소 별 부울 표현식의 각 요소에는 부울 표현식의 결과가 변수에 저장되거나 산술에 사용되는 경우 숫자 값 (참이면 1, 거짓이면 0)이 있습니다. .</target>
        </trans-unit>
        <trans-unit id="8e43576d7f2c644c10bb08f749b89102603f847c" translate="yes" xml:space="preserve">
          <source>Like every other expression, the function call has a value, which is computed by the function based on the arguments you give it. In this example, the value of &lt;code&gt;sqrt (&lt;var&gt;argument&lt;/var&gt;)&lt;/code&gt; is the square root of the argument. A function can also have side effects, such as assigning the values of certain variables or doing input or output operations.</source>
          <target state="translated">다른 모든 표현식과 마찬가지로 함수 호출에는 값이 있으며이 값은 사용자가 제공 한 인수를 기반으로 함수에 의해 계산됩니다. 이 예에서 &lt;code&gt;sqrt (&lt;var&gt;argument&lt;/var&gt;)&lt;/code&gt; 값은 인수 의 제곱근 입니다. 함수는 특정 변수의 값을 할당하거나 입력 또는 출력 작업을 수행하는 등의 부작용이있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="59857a458398fa33466b8360f1c6c133d910246a" translate="yes" xml:space="preserve">
          <source>Like global variables, a persistent variable may only be initialized once. For example, after executing the following code</source>
          <target state="translated">전역 변수와 마찬가지로 영구 변수는 한 번만 초기화 될 수 있습니다. 예를 들어 다음 코드를 실행 한 후</target>
        </trans-unit>
        <trans-unit id="ca4b83486dececbc0f15bbfde1c31eb6f96f09e6" translate="yes" xml:space="preserve">
          <source>Likewise &lt;code&gt;&lt;var&gt;s&lt;/var&gt; .^ -2&lt;/code&gt; involves terms like &lt;code&gt;0 .^ -2&lt;/code&gt; which is infinity, and so &lt;code&gt;&lt;var&gt;s&lt;/var&gt; .^ -2&lt;/code&gt; is equally a full matrix.</source>
          <target state="translated">마찬가지로 &lt;code&gt;&lt;var&gt;s&lt;/var&gt; .^ -2&lt;/code&gt; 는 무한대 인 &lt;code&gt;0 .^ -2&lt;/code&gt; 와 같은 항을 포함 하므로 &lt;code&gt;&lt;var&gt;s&lt;/var&gt; .^ -2&lt;/code&gt; 는 전체 행렬입니다.</target>
        </trans-unit>
        <trans-unit id="0d70fbc0295df233618a52339d42db71a4d8f0a4" translate="yes" xml:space="preserve">
          <source>Line Properties</source>
          <target state="translated">선 속성</target>
        </trans-unit>
        <trans-unit id="1d9a82211d66c2814dff8cb20af66d0719db6eae" translate="yes" xml:space="preserve">
          <source>Line Series</source>
          <target state="translated">라인 시리즈</target>
        </trans-unit>
        <trans-unit id="64b6f0f1f015ec1498b05e5d8fce97f8960b5ce1" translate="yes" xml:space="preserve">
          <source>Line Styles</source>
          <target state="translated">선 스타일</target>
        </trans-unit>
        <trans-unit id="ad0b2cb40e450d2d7da3835f9e492d3ab1eacd1b" translate="yes" xml:space="preserve">
          <source>Line number from which to remove a breakpoint. Multiple lines may be given as separate arguments or as a vector.</source>
          <target state="translated">중단 점을 제거 할 줄 번호입니다. 여러 줄은 별도의 인수 또는 벡터로 제공 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="88b7e625ef0c72f2172fa1a6b6d497b30b5e5a8d" translate="yes" xml:space="preserve">
          <source>Line series objects are created by the &lt;code&gt;plot&lt;/code&gt; and &lt;code&gt;plot3&lt;/code&gt; functions and are of the type &lt;code&gt;line&lt;/code&gt;. The properties of the line series with the ability to add data sources.</source>
          <target state="translated">선 시리즈 객체는 &lt;code&gt;plot&lt;/code&gt; 및 &lt;code&gt;plot3&lt;/code&gt; 함수 로 만들어지며 &lt;code&gt;line&lt;/code&gt; 유형 입니다. 데이터 소스를 추가 할 수있는 기능을 가진 라인 시리즈의 속성.</target>
        </trans-unit>
        <trans-unit id="b8eba72ed44699ec4c150e81363f7d4c13bdf899" translate="yes" xml:space="preserve">
          <source>Line styles are specified by the following properties:</source>
          <target state="translated">선 스타일은 다음 속성으로 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="7be5f6b94d4dc78a46dcf8b276236486a8ac6305" translate="yes" xml:space="preserve">
          <source>Line-Oriented Input</source>
          <target state="translated">라인 지향 입력</target>
        </trans-unit>
        <trans-unit id="fcb739908d0a50031f680d3b4fffc6749c4002d3" translate="yes" xml:space="preserve">
          <source>Linear Algebra</source>
          <target state="translated">선형 대수</target>
        </trans-unit>
        <trans-unit id="fc929ed2e48e325efd9f30603022852bea2e81aa" translate="yes" xml:space="preserve">
          <source>Linear Algebra Package (&lt;a href=&quot;http://www.netlib.org/lapack&quot;&gt;http://www.netlib.org/lapack&lt;/a&gt;).</source>
          <target state="translated">선형 대수 패키지 ( &lt;a href=&quot;http://www.netlib.org/lapack&quot;&gt;http://www.netlib.org/lapack&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="658203e4e7b67c7910aaf832314afd0c7fa7e997" translate="yes" xml:space="preserve">
          <source>Linear Algebra and Its Applications</source>
          <target state="translated">선형 대수와 그 응용</target>
        </trans-unit>
        <trans-unit id="5c5a178392b8f22be591f0e49da8bd3a1cfe9423" translate="yes" xml:space="preserve">
          <source>Linear Algebra and Its Applications, 4th Edition</source>
          <target state="translated">선형 대수와 그 응용, 4 판</target>
        </trans-unit>
        <trans-unit id="a2fb207b7001421fc37166fdf7855b26ed42a2a2" translate="yes" xml:space="preserve">
          <source>Linear Algebra on Sparse Matrices</source>
          <target state="translated">희소 행렬의 선형 대수</target>
        </trans-unit>
        <trans-unit id="b6bfb212e65611271725413eb4a7b4e6f3ef7565" translate="yes" xml:space="preserve">
          <source>Linear Algebra with Diagonal/Permutation Matrices</source>
          <target state="translated">대각선 / 순열 행렬을 가진 선형 대수</target>
        </trans-unit>
        <trans-unit id="97a6cbe1eab16c723c090d4309e748a346122f99" translate="yes" xml:space="preserve">
          <source>Linear Least Squares</source>
          <target state="translated">선형 최소 제곱</target>
        </trans-unit>
        <trans-unit id="df040b02dfe212f9eaa259b4064e69db2c7c48f7" translate="yes" xml:space="preserve">
          <source>Linear Programming</source>
          <target state="translated">선형 프로그래밍</target>
        </trans-unit>
        <trans-unit id="3c30ecc4303851cf7ff13a9ae828fbb59100e77a" translate="yes" xml:space="preserve">
          <source>Linear algebra:</source>
          <target state="translated">선형 대수 :</target>
        </trans-unit>
        <trans-unit id="36c5d1785acc08ab0912f4f4fec5282121474dea" translate="yes" xml:space="preserve">
          <source>Linear interpolation from nearest neighbors.</source>
          <target state="translated">가장 가까운 이웃으로부터의 선형 보간.</target>
        </trans-unit>
        <trans-unit id="38edbd5020229cfdb2ffc4b61b65b7c9b602e973" translate="yes" xml:space="preserve">
          <source>Linear multistep methods</source>
          <target state="translated">선형 다단계 방법</target>
        </trans-unit>
        <trans-unit id="77b56e4a3cfa730ac4c99cca107a029eadc03c43" translate="yes" xml:space="preserve">
          <source>Lines beginning with &amp;lsquo;</source>
          <target state="translated">'로 시작하는 줄</target>
        </trans-unit>
        <trans-unit id="96f3f4e5b8de708fd07eae1cdd337509cf6f5233" translate="yes" xml:space="preserve">
          <source>Lines beginning with an alphabetical character indicates a new category of functions.</source>
          <target state="translated">알파벳 문자로 시작하는 줄은 새로운 범주의 기능을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="5a2c7ff2c9c172b8b8c7d3b397238bdc69765f05" translate="yes" xml:space="preserve">
          <source>Lines starting with &amp;lsquo;</source>
          <target state="translated">'로 시작하는 줄</target>
        </trans-unit>
        <trans-unit id="bc5a47d400f617e05c2dfdb4e6d14eeca7fba4c4" translate="yes" xml:space="preserve">
          <source>Lines starting with a blank character are continuations from the previous line.</source>
          <target state="translated">빈 문자로 시작하는 줄은 이전 줄의 연속입니다.</target>
        </trans-unit>
        <trans-unit id="5de8880bf6f459d9bbeec97d1bd594b57ca24728" translate="yes" xml:space="preserve">
          <source>Lines starting with a white space character indicate that the function names on the line belong to the last mentioned category.</source>
          <target state="translated">공백 문자로 시작하는 행은 행의 함수 이름이 마지막으로 언급 된 범주에 속함을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="39e30902aba652420ad939874f4811b9bdac3e73" translate="yes" xml:space="preserve">
          <source>Link a stand-alone executable file.</source>
          <target state="translated">독립형 실행 파일을 링크하십시오.</target>
        </trans-unit>
        <trans-unit id="1049230af86a60e165f38011cc42d0381566ad98" translate="yes" xml:space="preserve">
          <source>Link both axes</source>
          <target state="translated">두 축 연결</target>
        </trans-unit>
        <trans-unit id="90c8bf2cbda78f236c1240e9601dee76aa6c3739" translate="yes" xml:space="preserve">
          <source>Link graphic object properties, such that a change in one is propagated to the others.</source>
          <target state="translated">한 변경 사항이 다른 변경 사항으로 전파되도록 그래픽 개체 속성을 연결합니다.</target>
        </trans-unit>
        <trans-unit id="ba329a6cd79cad1832fabb825721ec97686dc197" translate="yes" xml:space="preserve">
          <source>Link the axis limits of 2-D plots such that a change in one is propagated to the others.</source>
          <target state="translated">하나의 변경 사항이 다른 변경 사항으로 전파되도록 2 차원 플롯의 축 제한을 연결합니다.</target>
        </trans-unit>
        <trans-unit id="95c2517982ed428b1d0830197bf27e777d66b4a4" translate="yes" xml:space="preserve">
          <source>Link x-axes</source>
          <target state="translated">x 축 연결</target>
        </trans-unit>
        <trans-unit id="fd22c5aab6286df7cdad3831a0314867cbdc07a8" translate="yes" xml:space="preserve">
          <source>Link y-axes</source>
          <target state="translated">Y 축 연결</target>
        </trans-unit>
        <trans-unit id="fe4a3e7a0442d1f1b63f3bda53fd1dfd2ffbdd5a" translate="yes" xml:space="preserve">
          <source>Linking external C code to Octave is relatively simple, as the C functions can easily be called directly from C++. One possible issue is that the declarations of the external C functions may need to be explicitly defined as C functions to the compiler. If the declarations of the external C functions are in the header</source>
          <target state="translated">C 함수를 C ++에서 직접 쉽게 호출 할 수 있으므로 외부 C 코드를 옥타브에 연결하는 것은 비교적 간단합니다. 가능한 한 가지 문제는 외부 C 함수 선언을 컴파일러에 C 함수로 명시 적으로 정의해야 할 수도 있다는 것입니다. 외부 C 함수의 선언이 헤더에있는 경우</target>
        </trans-unit>
        <trans-unit id="741d6eacac821111e10eca9f2781db84aa8628b2" translate="yes" xml:space="preserve">
          <source>List &lt;var&gt;toolkit&lt;/var&gt; as an available graphics toolkit.</source>
          <target state="translated">&lt;var&gt;toolkit&lt;/var&gt; 을 사용 가능한 그래픽 툴킷 으로 나열하십시오 .</target>
        </trans-unit>
        <trans-unit id="62180665372f30f42201443d854370e37253db49" translate="yes" xml:space="preserve">
          <source>List currently defined variables matching the given patterns.</source>
          <target state="translated">주어진 패턴과 일치하는 현재 정의 된 변수를 나열합니다.</target>
        </trans-unit>
        <trans-unit id="14d798e411eb26e9293882b955331f1c5346fff4" translate="yes" xml:space="preserve">
          <source>List directory contents.</source>
          <target state="translated">디렉토리 내용을 나열하십시오.</target>
        </trans-unit>
        <trans-unit id="c0c13e3be90d113015967081125c4f7dad3d3083" translate="yes" xml:space="preserve">
          <source>List of labels for the legend items. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="037f96d904f09db8754df9cfdd736b632422023a" translate="yes" xml:space="preserve">
          <source>List operators. The pattern will match any character listed between &lt;code&gt;&quot;[&quot;&lt;/code&gt; and &lt;code&gt;&quot;]&quot;&lt;/code&gt;. If the first character is &lt;code&gt;&quot;^&quot;&lt;/code&gt; then the pattern is inverted and any character except those listed between brackets will match.</source>
          <target state="translated">연산자를 나열하십시오. 패턴은 &lt;code&gt;&quot;[&quot;&lt;/code&gt; 와 &lt;code&gt;&quot;]&quot;&lt;/code&gt; 사이에 나열된 모든 문자와 일치합니다 . 첫 번째 문자가 &lt;code&gt;&quot;^&quot;&lt;/code&gt; 이면 패턴이 반전되고 대괄호 사이에 나열된 문자를 제외한 모든 문자가 일치합니다.</target>
        </trans-unit>
        <trans-unit id="de4b491ef4127722f345cb556cd0fad9b1871b9c" translate="yes" xml:space="preserve">
          <source>List remote directory contents</source>
          <target state="translated">원격 디렉토리 내용 나열</target>
        </trans-unit>
        <trans-unit id="b8f72d48b1791aea4c8b6d92c44badb997673a22" translate="yes" xml:space="preserve">
          <source>List the Octave specific files in directory &lt;var&gt;dir&lt;/var&gt;.</source>
          <target state="translated">&lt;var&gt;dir&lt;/var&gt; 디렉토리에 Octave 특정 파일을 나열하십시오 .</target>
        </trans-unit>
        <trans-unit id="78cfd1fcc2fef78ce2bf938acdc18ffdc4ce7779" translate="yes" xml:space="preserve">
          <source>List the current directory in verbose form for the FTP connection &lt;var&gt;f&lt;/var&gt;.</source>
          <target state="translated">FTP 연결을 위해 현재 디렉토리를 자세하게 나열하십시오 &lt;var&gt;f&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="48d9923558592ce06c1401781ce3ae9d798bd6e7" translate="yes" xml:space="preserve">
          <source>List the first &lt;var&gt;n&lt;/var&gt; primes.</source>
          <target state="translated">첫 &lt;var&gt;n&lt;/var&gt; 개의 소수를 나열하십시오 .</target>
        </trans-unit>
        <trans-unit id="2c26a7d72f14e4d4978e8e113a17469e66c59b04" translate="yes" xml:space="preserve">
          <source>List the names of the public methods for the object &lt;var&gt;obj&lt;/var&gt; or the named class &lt;var&gt;classname&lt;/var&gt;.</source>
          <target state="translated">객체 &lt;var&gt;obj&lt;/var&gt; 또는 명명 된 클래스 &lt;var&gt;classname&lt;/var&gt; 에 대한 공용 메소드의 이름을 나열하십시오 .</target>
        </trans-unit>
        <trans-unit id="a7b35bbf4697070626c8c7f78fd40fd53aad3076" translate="yes" xml:space="preserve">
          <source>List the possible completions of the text before the cursor.</source>
          <target state="translated">커서 앞에 텍스트의 가능한 완성을 나열하십시오.</target>
        </trans-unit>
        <trans-unit id="ae5f4d0c22fc1b12778892cdf131c8ae7741a6b6" translate="yes" xml:space="preserve">
          <source>List variables in the global scope rather than the current scope.</source>
          <target state="translated">현재 범위가 아닌 전역 범위의 변수를 나열하십시오.</target>
        </trans-unit>
        <trans-unit id="14879438f43f236adf0c361782851d5465735ab1" translate="yes" xml:space="preserve">
          <source>Literal character fields:</source>
          <target state="translated">리터럴 문자 필드 :</target>
        </trans-unit>
        <trans-unit id="1b83039d9f22c8606f7f29f09879f1012af6e99f" translate="yes" xml:space="preserve">
          <source>Load the figure</source>
          <target state="translated">그림을로드</target>
        </trans-unit>
        <trans-unit id="a39d50ceff4d7d8b41b6797827054cedf1a79cf1" translate="yes" xml:space="preserve">
          <source>Load the graphics objects in &lt;var&gt;filename&lt;/var&gt; into a vector of graphics handles &lt;var&gt;h&lt;/var&gt;.</source>
          <target state="translated">&lt;var&gt;filename&lt;/var&gt; 의 그래픽스 객체 를 그래픽스 핸들 벡터 &lt;var&gt;h&lt;/var&gt; 에 로드합니다 .</target>
        </trans-unit>
        <trans-unit id="15890278a03b599fa35aa8b175d3745cd16750cf" translate="yes" xml:space="preserve">
          <source>Load the named variables &lt;var&gt;v1&lt;/var&gt;, &lt;var&gt;v2&lt;/var&gt;, &amp;hellip;, from the file &lt;var&gt;file&lt;/var&gt;.</source>
          <target state="translated">파일 &lt;var&gt;file&lt;/var&gt; 에서 명명 된 변수 &lt;var&gt;v1&lt;/var&gt; , &lt;var&gt;v2&lt;/var&gt; ,&amp;hellip;을 로드 합니다 .</target>
        </trans-unit>
        <trans-unit id="7dcff9ac45368e7161cfcc7bee18b061570b8ff8" translate="yes" xml:space="preserve">
          <source>Loading and Saving Images</source>
          <target state="translated">이미지로드 및 저장</target>
        </trans-unit>
        <trans-unit id="feba37755bbad5d7188cc14b805f01696a3e2fa3" translate="yes" xml:space="preserve">
          <source>Locale&amp;rsquo;s AM or PM.</source>
          <target state="translated">로캘의 오전 또는 오후</target>
        </trans-unit>
        <trans-unit id="04096035a11a7791a0861aab96c500b73e720774" translate="yes" xml:space="preserve">
          <source>Locale&amp;rsquo;s abbreviated month name (Jan-Dec).</source>
          <target state="translated">로케일의 약식 월 이름 (Jan-Dec).</target>
        </trans-unit>
        <trans-unit id="067ce67325ff5112826d3e42db533982818d30fd" translate="yes" xml:space="preserve">
          <source>Locale&amp;rsquo;s abbreviated weekday name (Sun-Sat).</source>
          <target state="translated">로케일의 약식 요일 이름 (일요일)</target>
        </trans-unit>
        <trans-unit id="779fdac411a4bd39e70b2db42f1a598c4b059657" translate="yes" xml:space="preserve">
          <source>Locale&amp;rsquo;s date and time (Sat Nov 04 12:02:33 EST 1989).</source>
          <target state="translated">로케일의 날짜 및 시간 (11 월 04 일 12:02:33 EST 1989).</target>
        </trans-unit>
        <trans-unit id="0e721243e32d36695812be53ce1e3100173b4075" translate="yes" xml:space="preserve">
          <source>Locale&amp;rsquo;s date representation (mm/dd/yy).</source>
          <target state="translated">로케일 날짜 표시 (mm / dd / yy).</target>
        </trans-unit>
        <trans-unit id="5539c30e3bd5583eaec2a64dd8c7b880b234b004" translate="yes" xml:space="preserve">
          <source>Locale&amp;rsquo;s full month name, variable length (January-December).</source>
          <target state="translated">로케일의 전체 월 이름, 가변 길이 (1 월 -12 월).</target>
        </trans-unit>
        <trans-unit id="963abe2f13989f5bcb74506604df3fa3a9b00637" translate="yes" xml:space="preserve">
          <source>Locale&amp;rsquo;s full weekday name, variable length (Sunday-Saturday).</source>
          <target state="translated">로케일의 전체 요일 이름, 가변 길이 (일요일-토요일).</target>
        </trans-unit>
        <trans-unit id="b62a408d2be6e7f9ba6a6c8a829712a9b071b7cc" translate="yes" xml:space="preserve">
          <source>Locale&amp;rsquo;s time representation (%H:%M:%S).</source>
          <target state="translated">로케일의 시간 표현 (% H : % M : % S).</target>
        </trans-unit>
        <trans-unit id="37a991eee8f6aced535e7126d02c6c00ffb11360" translate="yes" xml:space="preserve">
          <source>Location of file or directory</source>
          <target state="translated">파일 또는 디렉토리의 위치</target>
        </trans-unit>
        <trans-unit id="e66c4a56f93aede0e6bd74537131c2b5ff72539a" translate="yes" xml:space="preserve">
          <source>Lock the current function into memory so that it can&amp;rsquo;t be removed with &lt;code&gt;clear&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;clear&lt;/code&gt; 로 제거 할 수 없도록 현재 기능을 메모리에 잠급니다 .</target>
        </trans-unit>
        <trans-unit id="c8bf1f632fed0779598e0ddb4c7a586c28b4cb21" translate="yes" xml:space="preserve">
          <source>Logical Values</source>
          <target state="translated">논리 값</target>
        </trans-unit>
        <trans-unit id="1b48e81d570127e70ff2d3e0e8d6213b3a7af3d4" translate="yes" xml:space="preserve">
          <source>Logical and</source>
          <target state="translated">논리 및</target>
        </trans-unit>
        <trans-unit id="8259ba986782d122f64779d389ceef58be13d6fd" translate="yes" xml:space="preserve">
          <source>Logical and character arrays are not considered to be numeric.</source>
          <target state="translated">논리 및 문자 배열은 숫자로 간주되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d4271943646b1e3b0742a5bd98a8e3f8d50325f4" translate="yes" xml:space="preserve">
          <source>Logical not</source>
          <target state="translated">논리적이 아님</target>
        </trans-unit>
        <trans-unit id="2b4453638fec41e78bf97d38a71502539ae079a2" translate="yes" xml:space="preserve">
          <source>Logical or</source>
          <target state="translated">논리 또는</target>
        </trans-unit>
        <trans-unit id="8beac902224ac2c5e1ac2fbe7669ded5bfa74968" translate="yes" xml:space="preserve">
          <source>Logical value if format supports alpha channel (transparency or matte).</source>
          <target state="translated">형식이 알파 채널 (투명도 또는 매트)을 지원하는 경우 논리 값입니다.</target>
        </trans-unit>
        <trans-unit id="63344b8be4f178580ea1611869b7552412448cba" translate="yes" xml:space="preserve">
          <source>Logical value if format supports multipage (multiple images per file).</source>
          <target state="translated">형식이 여러 페이지 (파일 당 여러 이미지)를 지원하는 경우 논리 값입니다.</target>
        </trans-unit>
        <trans-unit id="3c98452f92940d575de3ebb3be1ddc41aa8e7166" translate="yes" xml:space="preserve">
          <source>Logical values can also be constructed by casting numeric objects to logical values, or by using the &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt; functions.</source>
          <target state="translated">숫자 값을 논리 값으로 캐스트하거나 &lt;code&gt;true&lt;/code&gt; 또는 &lt;code&gt;false&lt;/code&gt; 함수를 사용하여 논리 값을 구성 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1f28c4bd90d5dc0816d77bf49cb27d7d3150fc38" translate="yes" xml:space="preserve">
          <source>Logical values can also be used to index matrices and cell arrays. When indexing with a logical array the result will be a vector containing the values corresponding to &lt;code&gt;true&lt;/code&gt; parts of the logical array. The following example illustrates this.</source>
          <target state="translated">논리 값을 사용하여 행렬 및 셀형 배열을 인덱싱 할 수도 있습니다. 논리 배열을 사용하여 인덱싱 할 때 결과는 논리 배열의 &lt;code&gt;true&lt;/code&gt; 부분에 해당하는 값을 포함하는 벡터가 됩니다. 다음 예제는이를 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="2896269f89f99b883af5d5887f46eec1bd34e27a" translate="yes" xml:space="preserve">
          <source>Look for Octave sources in the directory &lt;var&gt;dir&lt;/var&gt;.</source>
          <target state="translated">&lt;var&gt;dir&lt;/var&gt; 디렉토리에서 Octave 소스를 찾으십시오 .</target>
        </trans-unit>
        <trans-unit id="575139f3190d2b4b88613120908db2ef7406f3e8" translate="yes" xml:space="preserve">
          <source>Lookup values in a &lt;strong&gt;sorted&lt;/strong&gt; table.</source>
          <target state="translated">&lt;strong&gt;정렬 된&lt;/strong&gt; 테이블 에서 조회 값 .</target>
        </trans-unit>
        <trans-unit id="f6e1c0b9641bf33e1aaaec1b537963374682bddb" translate="yes" xml:space="preserve">
          <source>LoopCount</source>
          <target state="translated">LoopCount</target>
        </trans-unit>
        <trans-unit id="717116903a15a03352d771a8aa15a0648317a58b" translate="yes" xml:space="preserve">
          <source>Looping Over Structure Elements</source>
          <target state="translated">구조 요소 반복</target>
        </trans-unit>
        <trans-unit id="6b20132daaaa7e23261ab520dc4631f91968fefb" translate="yes" xml:space="preserve">
          <source>Loss of significance by argument reduction results in less than half of machine accuracy.</source>
          <target state="translated">인수 축소로 인한 중요성 상실로 기계 정확도의 절반 미만이됩니다.</target>
        </trans-unit>
        <trans-unit id="f6d49c31932354250a4044769b95016a2e38a39e" translate="yes" xml:space="preserve">
          <source>Loss of significance by argument reduction, output may be inaccurate.</source>
          <target state="translated">인수 축소로 인한 중요성 상실, 결과가 부정확 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="51bd1ef84a4f57ac3469f92b56324e8fcc14cd16" translate="yes" xml:space="preserve">
          <source>Low accuracy with nonsmooth integrands</source>
          <target state="translated">비 부드러운 정수로 낮은 정확도</target>
        </trans-unit>
        <trans-unit id="c3c3ad58b0ac62744c2bb94a50da4362b578cf90" translate="yes" xml:space="preserve">
          <source>Low to High accuracy with nonsmooth/smooth integrands</source>
          <target state="translated">비 부드러운 / 부드러운 정수로 낮은 정확도</target>
        </trans-unit>
        <trans-unit id="53a53d791037805c9eaa5d60f14672e2b3484f62" translate="yes" xml:space="preserve">
          <source>Lower limit of the objective function. If the objective function reaches this limit and continues decreasing, the solver stops the search. This parameter is used in the dual simplex method only.</source>
          <target state="translated">목적 함수의 하한. 목적 함수가이 한계에 도달하고 계속 감소하면 솔버가 검색을 중지합니다. 이 매개 변수는 이중 심플 렉스 방법에서만 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="12cda5599c2db74eafe9c0fbeeab20b5c3de25a8" translate="yes" xml:space="preserve">
          <source>Lower triangular. If the optional third argument &lt;var&gt;perm&lt;/var&gt; is given, the matrix is assumed to be a permuted lower triangular with the permutations defined by the vector &lt;var&gt;perm&lt;/var&gt;.</source>
          <target state="translated">더 낮은 삼각형. 선택적인 세 번째 인수 &lt;var&gt;perm&lt;/var&gt; 이 주어지면 행렬 &lt;var&gt;perm&lt;/var&gt; 에 의해 정의 된 순열을 갖는 순열 된 낮은 삼각형으로 가정됩니다 .</target>
        </trans-unit>
        <trans-unit id="86584d2a2be30257bd3b14d2fe233f59f8330c75" translate="yes" xml:space="preserve">
          <source>Lowercase the characters following the cursor to the end of the current (or following) word, moving the cursor to the end of the word.</source>
          <target state="translated">커서 뒤의 단어를 현재 (또는 다음) 단어의 끝까지 소문자로 이동하여 커서를 단어의 끝으로 이동하십시오.</target>
        </trans-unit>
        <trans-unit id="f94695b7a50ce03d4b08392048b4736551f27939" translate="yes" xml:space="preserve">
          <source>Lowercase value of the key</source>
          <target state="translated">키의 소문자 값</target>
        </trans-unit>
        <trans-unit id="c63ae6dd4fc9f9dda66970e827d13f7c73fe841c" translate="yes" xml:space="preserve">
          <source>M</source>
          <target state="translated">M</target>
        </trans-unit>
        <trans-unit id="1ccf33bf7d4cdbbdfbf3a0d2217f0170db648673" translate="yes" xml:space="preserve">
          <source>M = diag (v)</source>
          <target state="translated">M = 진단 (v)</target>
        </trans-unit>
        <trans-unit id="0b7748d1aa522d808c6aad90b9f8b6457d90cc0e" translate="yes" xml:space="preserve">
          <source>M = diag (v, k)</source>
          <target state="translated">M = 진단 (v, k)</target>
        </trans-unit>
        <trans-unit id="436d9e222b38cfba53b8813778892f4e5a312b95" translate="yes" xml:space="preserve">
          <source>M = diag (v, m, n)</source>
          <target state="translated">M = 진단 (v, m, n)</target>
        </trans-unit>
        <trans-unit id="29d20bcffe97e2e8582a7b36b7a5dcac5e58b8f7" translate="yes" xml:space="preserve">
          <source>M-&amp;gt;</source>
          <target state="translated">M-&amp;gt;</target>
        </trans-unit>
        <trans-unit id="37a5c39dff07a52dd3087c214ce1f8d1b29f0a8c" translate="yes" xml:space="preserve">
          <source>M-&amp;lt;</source>
          <target state="translated">M-&amp;lt;</target>
        </trans-unit>
        <trans-unit id="b691a0899cae20ded7f02bb823bbac9706646354" translate="yes" xml:space="preserve">
          <source>M-?</source>
          <target state="translated">M-?</target>
        </trans-unit>
        <trans-unit id="e286729ebdb433a6094d1271b49c5a2c6f950ccc" translate="yes" xml:space="preserve">
          <source>M-DEL</source>
          <target state="translated">M-DEL</target>
        </trans-unit>
        <trans-unit id="582c231510f999e4090021d4c4d24dd9d1083ddc" translate="yes" xml:space="preserve">
          <source>M-TAB</source>
          <target state="translated">M-TAB</target>
        </trans-unit>
        <trans-unit id="dfec75d824ab931885b10c2deb8b602ddf385540" translate="yes" xml:space="preserve">
          <source>M-b</source>
          <target state="translated">M-b</target>
        </trans-unit>
        <trans-unit id="9f9f196444744016cd3934727f5dbcbffc50a3e9" translate="yes" xml:space="preserve">
          <source>M-c</source>
          <target state="translated">M-c</target>
        </trans-unit>
        <trans-unit id="a213eb1de2d97fd8ab6c0c8486e553f7cdc3e521" translate="yes" xml:space="preserve">
          <source>M-d</source>
          <target state="translated">M-d</target>
        </trans-unit>
        <trans-unit id="add69bf7aa5e86e6ac1a17b8047a626986b67564" translate="yes" xml:space="preserve">
          <source>M-f</source>
          <target state="translated">M-f</target>
        </trans-unit>
        <trans-unit id="6e170e1d95a1d9c6cf3887b77b46419dd3d2ec71" translate="yes" xml:space="preserve">
          <source>M-l</source>
          <target state="translated">M-l</target>
        </trans-unit>
        <trans-unit id="0f8046567a7777233033e7c62fcbaaf077eb077a" translate="yes" xml:space="preserve">
          <source>M-r</source>
          <target state="translated">M-r</target>
        </trans-unit>
        <trans-unit id="3be7be38dbd525c399b8fea805511b112c44e358" translate="yes" xml:space="preserve">
          <source>M-t</source>
          <target state="translated">M-t</target>
        </trans-unit>
        <trans-unit id="9af0d95460fb2a783cd95c120c77b07cf4297a51" translate="yes" xml:space="preserve">
          <source>M-u</source>
          <target state="translated">M-u</target>
        </trans-unit>
        <trans-unit id="7555a33395fef6db20d121fb58c3221aa124e48c" translate="yes" xml:space="preserve">
          <source>M-y</source>
          <target state="translated">M-y</target>
        </trans-unit>
        <trans-unit id="1f7c41c1d830dd3294f09301a33b8ae5b4f2acee" translate="yes" xml:space="preserve">
          <source>M. Abramowitz and I.A. Stegun,</source>
          <target state="translated">M. Abramowitz와 IA Stegun,</target>
        </trans-unit>
        <trans-unit id="83bd2260257d398076a738813a94bd2f37d6f282" translate="yes" xml:space="preserve">
          <source>MD2</source>
          <target state="translated">MD2</target>
        </trans-unit>
        <trans-unit id="86e9fff1d00c68995ba96d3b00b707d9685f6995" translate="yes" xml:space="preserve">
          <source>MD4</source>
          <target state="translated">MD4</target>
        </trans-unit>
        <trans-unit id="b773bed04a48de200b96981bb79467413a222066" translate="yes" xml:space="preserve">
          <source>MD5</source>
          <target state="translated">MD5</target>
        </trans-unit>
        <trans-unit id="40bb78ac4a8f75b73057a2a259dcfa335c88dad4" translate="yes" xml:space="preserve">
          <source>META</source>
          <target state="translated">META</target>
        </trans-unit>
        <trans-unit id="4a3a8927b85daa16f0fe11b6bbb759eee3095858" translate="yes" xml:space="preserve">
          <source>MM</source>
          <target state="translated">MM</target>
        </trans-unit>
        <trans-unit id="ff6912e2f0ea1f0a272acab877e81da5e3f73b0e" translate="yes" xml:space="preserve">
          <source>Magenta</source>
          <target state="translated">Magenta</target>
        </trans-unit>
        <trans-unit id="585be2f64901aa53f098047f2916159507219a53" translate="yes" xml:space="preserve">
          <source>Maintainer of the package.</source>
          <target state="translated">패키지 관리자.</target>
        </trans-unit>
        <trans-unit id="a94431ee22f05f141107f9355ed3127d0f0c4d5a" translate="yes" xml:space="preserve">
          <source>Make</source>
          <target state="translated">Make</target>
        </trans-unit>
        <trans-unit id="11bd2c3419550f41d7b3ecb87a9243940e86d651" translate="yes" xml:space="preserve">
          <source>Make the axes visible.</source>
          <target state="translated">축을 표시합니다.</target>
        </trans-unit>
        <trans-unit id="f5ca5f1bb1e5cfc4a422a8956250e2478276ff95" translate="yes" xml:space="preserve">
          <source>Make the matching case sensitive. (default)</source>
          <target state="translated">대소 문자를 구분하십시오. (기본)</target>
        </trans-unit>
        <trans-unit id="e507428c30f7104bdede95c3fc076e52e3f587e8" translate="yes" xml:space="preserve">
          <source>Makeconf</source>
          <target state="translated">Makeconf</target>
        </trans-unit>
        <trans-unit id="836efb6e25a091dcb4ff8e1dbb2f0be6a5cbf14c" translate="yes" xml:space="preserve">
          <source>Makefile</source>
          <target state="translated">Makefile</target>
        </trans-unit>
        <trans-unit id="4faecea6d9857941b442698cdcbd38a141ff746e" translate="yes" xml:space="preserve">
          <source>Makefile.in</source>
          <target state="translated">Makefile.in</target>
        </trans-unit>
        <trans-unit id="44667609f7bfd36a2fd455f1d665c2ef5fd79b3d" translate="yes" xml:space="preserve">
          <source>Making Java Classes Available</source>
          <target state="translated">Java 클래스를 사용 가능하게 만들기</target>
        </trans-unit>
        <trans-unit id="b02d176b86b96c689850ef3621331eebffb231cc" translate="yes" xml:space="preserve">
          <source>Making diagonal and permutation matrices special matrix objects in their own right and the consequent usage of smarter algorithms for certain operations implies, as a side effect, small differences in treating zeros. The contents of this section apply also to sparse matrices, discussed in the following chapter. (see &lt;a href=&quot;sparse-matrices#Sparse-Matrices&quot;&gt;Sparse Matrices&lt;/a&gt;)</source>
          <target state="translated">대각 행렬과 순열 행렬을 자체적으로 특수 행렬 객체로 만들고 결과적으로 특정 연산에 대해 더 똑똑한 알고리즘을 사용하면 부작용으로 0을 처리하는 데 작은 차이가 있습니다. 이 섹션의 내용은 다음 장에서 논의 된 희소 행렬에도 적용됩니다. ( &lt;a href=&quot;sparse-matrices#Sparse-Matrices&quot;&gt;희소 행렬&lt;/a&gt; 참조 )</target>
        </trans-unit>
        <trans-unit id="ac2b3e996c71c5394060f486e04a9f90f2cc8f4e" translate="yes" xml:space="preserve">
          <source>Manage &lt;small&gt;FFTW&lt;/small&gt; wisdom data.</source>
          <target state="translated">&lt;small&gt;FFTW&lt;/small&gt; 지혜 데이터를 관리 합니다.</target>
        </trans-unit>
        <trans-unit id="8802d3d83edfe7ae97d0fa50e3fc68fb2a1c7627" translate="yes" xml:space="preserve">
          <source>Manage or query packages (groups of add-on functions) for Octave.</source>
          <target state="translated">Octave 용 패키지 (추가 기능 그룹)를 관리하거나 조회하십시오.</target>
        </trans-unit>
        <trans-unit id="35eed945f1cf48d3fc45539000459b17f2e0cb03" translate="yes" xml:space="preserve">
          <source>Manage supported image formats.</source>
          <target state="translated">지원되는 이미지 형식을 관리하십시오.</target>
        </trans-unit>
        <trans-unit id="6a22a2a719aa541725cb1641854142a209342abc" translate="yes" xml:space="preserve">
          <source>Managing Default Properties</source>
          <target state="translated">기본 속성 관리</target>
        </trans-unit>
        <trans-unit id="7f8da8dd2c428d66af482ef723ff82d361b49613" translate="yes" xml:space="preserve">
          <source>Manipulate sparse matrices</source>
          <target state="translated">희소 행렬 조작</target>
        </trans-unit>
        <trans-unit id="fe7c462390eddbbc284f5ed6ca2daa669cc9f0db" translate="yes" xml:space="preserve">
          <source>Manipulating Strings</source>
          <target state="translated">문자열 조작</target>
        </trans-unit>
        <trans-unit id="a4b413306cc0f71491eddb8e633cabfbdc1589fb" translate="yes" xml:space="preserve">
          <source>Manipulating Structures</source>
          <target state="translated">구조 조작</target>
        </trans-unit>
        <trans-unit id="b2403eed9206d2c9259e9df9b4fd436d5dbb7a6a" translate="yes" xml:space="preserve">
          <source>Manipulating the Load Path</source>
          <target state="translated">로드 경로 조작</target>
        </trans-unit>
        <trans-unit id="34b776bba97e37d9d0457b06c8a9591675c0e8c6" translate="yes" xml:space="preserve">
          <source>Manipulation of Plot Objects</source>
          <target state="translated">플롯 객체 조작</target>
        </trans-unit>
        <trans-unit id="669a86f5401e98336e12f516217c5a79ba32c871" translate="yes" xml:space="preserve">
          <source>Manipulation of Plot Windows</source>
          <target state="translated">플롯 창 조작</target>
        </trans-unit>
        <trans-unit id="4e836fdc2572ab23d5dc8c36bd613ac6b0f82d63" translate="yes" xml:space="preserve">
          <source>Manual</source>
          <target state="translated">Manual</target>
        </trans-unit>
        <trans-unit id="33a11ddeb40a5ea23b8ede803f8e1aa69d8e1704" translate="yes" xml:space="preserve">
          <source>Manual: Appendices</source>
          <target state="translated">매뉴얼 : 부록</target>
        </trans-unit>
        <trans-unit id="19cfb484b6178f6b9d15f8147a01c01331ec01b8" translate="yes" xml:space="preserve">
          <source>Manual: Indexes</source>
          <target state="translated">수동 : 색인</target>
        </trans-unit>
        <trans-unit id="7e1c8aea0e452b25c1c7b5d8441bd974f105cb16" translate="yes" xml:space="preserve">
          <source>Many Octave functions have been overloaded to work with either sparse or full matrices. There is no difference in calling convention when using an overloaded function with a sparse matrix, however, there is also no access to potentially sparse-specific features. At any time the sparse matrix specific version of a function can be used by explicitly calling its function name.</source>
          <target state="translated">희소 또는 전체 행렬과 함께 작동하도록 많은 Octave 기능이 오버로드되었습니다. 희소 행렬과 함께 오버로드 된 함수를 사용할 때 호출 규칙에는 차이가 없지만 잠재적으로 희소 특정 기능에는 액세스 할 수 없습니다. 언제든지 함수 이름을 명시 적으로 호출하여 희소 행렬 특정 버전의 함수를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f562383e075fb564b586bd8a2bc7e47a67306a04" translate="yes" xml:space="preserve">
          <source>Many different combinations of arguments are possible. The most common form is</source>
          <target state="translated">여러 가지 다른 인수 조합이 가능합니다. 가장 일반적인 형태는</target>
        </trans-unit>
        <trans-unit id="e02bd33b5cd8f5ca72c01309f7b5d0a762b4ada3" translate="yes" xml:space="preserve">
          <source>Many different combinations of arguments are possible. The simplest form is</source>
          <target state="translated">여러 가지 다른 인수 조합이 가능합니다. 가장 간단한 형태는</target>
        </trans-unit>
        <trans-unit id="9e04b396f0f9ca6c96cec012f12a63787fc1499b" translate="yes" xml:space="preserve">
          <source>Many functions and operators take two or more arguments and the situation can easily arise where these functions are called with objects of different classes. It is therefore necessary to determine the precedence of which method from which class to call when there are mixed objects given to a function or operator. To do this the &lt;code&gt;superiorto&lt;/code&gt; and &lt;code&gt;inferiorto&lt;/code&gt; functions can be used</source>
          <target state="translated">많은 함수와 연산자는 둘 이상의 인수를 사용하며 이러한 함수가 다른 클래스의 객체로 호출되는 경우 상황이 쉽게 발생할 수 있습니다. 따라서 함수 나 연산자에 혼합 된 객체가있을 때 어떤 클래스에서 어떤 메서드를 호출해야하는지 우선 순위를 결정해야합니다. 이를 위해 &lt;code&gt;superiorto&lt;/code&gt; 및 &lt;code&gt;inferiorto&lt;/code&gt; 기능을 사용할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="e41d37b092a564790596b73f7c8e369331382a6c" translate="yes" xml:space="preserve">
          <source>Many functions can also return single precision values directly. For example</source>
          <target state="translated">많은 함수가 단 정밀도 값을 직접 반환 할 수도 있습니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="7cf991840eb32a7245b4da11b0f7b60e7c471e3a" translate="yes" xml:space="preserve">
          <source>Many of Octave&amp;rsquo;s standard functions are distributed as function files. They are loosely organized by topic, in subdirectories of</source>
          <target state="translated">Octave의 표준 기능 중 다수는 기능 파일로 배포됩니다. 하위 디렉토리에서 주제별로 느슨하게 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="3900e36f1440eba0912ecb8023f8ae4ccf27c968" translate="yes" xml:space="preserve">
          <source>Many of the command-line editing functions operate using control characters. For example, the character</source>
          <target state="translated">많은 명령 줄 편집 기능은 제어 문자를 사용하여 작동합니다. 예를 들어, 캐릭터</target>
        </trans-unit>
        <trans-unit id="38a40ea0fe8ab86edf1a75b1f5266994ce55b242" translate="yes" xml:space="preserve">
          <source>Many of the examples in this manual print text when they are evaluated. In this manual the printed text resulting from an example is indicated by &amp;lsquo;</source>
          <target state="translated">이 설명서의 많은 예는 평가시 텍스트를 인쇄합니다. 이 매뉴얼에서 예제에서 출력 된 텍스트는 '</target>
        </trans-unit>
        <trans-unit id="71141635c97b09f7e98afd5fc99df53de927ccd8" translate="yes" xml:space="preserve">
          <source>Many operators and functions can work with mixed data types. For example,</source>
          <target state="translated">많은 연산자와 함수가 혼합 데이터 형식으로 작동 할 수 있습니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="ab478f3efc840eebab919dff1b9512286f70c10c" translate="yes" xml:space="preserve">
          <source>Map</source>
          <target state="translated">Map</target>
        </trans-unit>
        <trans-unit id="c27fb762163d83c328f0f6857b649896438e7ec6" translate="yes" xml:space="preserve">
          <source>Margins between the borders of the background area and the texts. The value is currently interpreted as pixels, regardless of the &lt;code&gt;&quot;fontunits&quot;&lt;/code&gt; property.</source>
          <target state="translated">배경 영역의 테두리와 텍스트 사이의 여백. 값은 &lt;code&gt;&quot;fontunits&quot;&lt;/code&gt; 속성에 관계없이 현재 픽셀로 해석됩니다 .</target>
        </trans-unit>
        <trans-unit id="b9a7d63bc466b2c637ee46063ebbbc554b0d7bb8" translate="yes" xml:space="preserve">
          <source>Mark the matrix as full.</source>
          <target state="translated">행렬을 전체로 표시하십시오.</target>
        </trans-unit>
        <trans-unit id="ca60857029de12f9c31cc854a5ce44b8d04989b5" translate="yes" xml:space="preserve">
          <source>Marker Styles</source>
          <target state="translated">마커 스타일</target>
        </trans-unit>
        <trans-unit id="91a9fe847f9d3f8e6e1991749b1798afe8937446" translate="yes" xml:space="preserve">
          <source>Marker styles are specified by the following properties:</source>
          <target state="translated">마커 스타일은 다음 속성으로 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="0e811bd456b0870161fbda266461c82767ceb94f" translate="yes" xml:space="preserve">
          <source>Mass matrix, specified as a constant matrix or a function of time and state.</source>
          <target state="translated">질량 행렬로, 상수 행렬 또는 시간과 상태의 함수로 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="21179eb842561276594d31f268fd74d4b7e421a5" translate="yes" xml:space="preserve">
          <source>Match &lt;var&gt;n&lt;/var&gt; or more times</source>
          <target state="translated">&lt;var&gt;n&lt;/var&gt; 번 이상 일치</target>
        </trans-unit>
        <trans-unit id="a8cbfd288a608a223d26e492ce0d179fd9f8a695" translate="yes" xml:space="preserve">
          <source>Match any character</source>
          <target state="translated">어떤 캐릭터와도 일치</target>
        </trans-unit>
        <trans-unit id="c840c66f2af3440ba0b64092dda1e2eb30b34076" translate="yes" xml:space="preserve">
          <source>Match any digit</source>
          <target state="translated">모든 숫자와 일치</target>
        </trans-unit>
        <trans-unit id="151197062086b7309df3fd98af8cb5e49600617c" translate="yes" xml:space="preserve">
          <source>Match any non-digit</source>
          <target state="translated">숫자가 아닌 문자와 일치</target>
        </trans-unit>
        <trans-unit id="3f5d63fc338720a62ba8c32df4a60a4fe5644bfa" translate="yes" xml:space="preserve">
          <source>Match any non-whitespace character</source>
          <target state="translated">공백이 아닌 문자와 일치</target>
        </trans-unit>
        <trans-unit id="746533a7d6414097d912452d04a0d9bf45980f8b" translate="yes" xml:space="preserve">
          <source>Match any non-word character</source>
          <target state="translated">비 단어 문자와 일치</target>
        </trans-unit>
        <trans-unit id="e46ae39742915128672beb91f687a6408aafd980" translate="yes" xml:space="preserve">
          <source>Match any single character.</source>
          <target state="translated">단일 문자와 일치하십시오.</target>
        </trans-unit>
        <trans-unit id="37bf78b3307e15750e359a38d7438608516895bc" translate="yes" xml:space="preserve">
          <source>Match any whitespace character</source>
          <target state="translated">공백 문자와 일치</target>
        </trans-unit>
        <trans-unit id="2c59b464a3783b6d983f2bb2c0a00f55c2684dec" translate="yes" xml:space="preserve">
          <source>Match any word character</source>
          <target state="translated">모든 단어 문자와 일치</target>
        </trans-unit>
        <trans-unit id="23b43cb57568b565bf6891ff4b59d68ed282c995" translate="yes" xml:space="preserve">
          <source>Match between &lt;var&gt;m&lt;/var&gt; and &lt;var&gt;n&lt;/var&gt; times</source>
          <target state="translated">간에 일치 &lt;var&gt;m&lt;/var&gt; 및 &lt;var&gt;n&lt;/var&gt; 은 회</target>
        </trans-unit>
        <trans-unit id="2cbc50325c07e20016f079019203809e2317b69e" translate="yes" xml:space="preserve">
          <source>Match exactly &lt;var&gt;n&lt;/var&gt; times</source>
          <target state="translated">정확히 &lt;var&gt;n&lt;/var&gt; 번 일치</target>
        </trans-unit>
        <trans-unit id="dc66c1063ec618cbd80ef9adb952e0cc553908ef" translate="yes" xml:space="preserve">
          <source>Match one or more times</source>
          <target state="translated">한 번 이상 일치</target>
        </trans-unit>
        <trans-unit id="693e11f000279abd98d382ba2c87bf21b6807c46" translate="yes" xml:space="preserve">
          <source>Match the anchor characters at the beginning and end of the line.</source>
          <target state="translated">줄의 시작과 끝에서 앵커 문자를 일치시킵니다.</target>
        </trans-unit>
        <trans-unit id="331fef5e0d249556e9831d696fa486caada19dc5" translate="yes" xml:space="preserve">
          <source>Match the anchor characters at the beginning and end of the string. (default)</source>
          <target state="translated">문자열의 시작과 끝에서 앵커 문자를 일치시킵니다. (기본)</target>
        </trans-unit>
        <trans-unit id="0775cf97dd4db0e5bd646b324d5a2a4e7259450f" translate="yes" xml:space="preserve">
          <source>Match the beginning of a word</source>
          <target state="translated">단어의 시작과 일치</target>
        </trans-unit>
        <trans-unit id="b1ed651216e302766d4931a0da96471372b5e0bf" translate="yes" xml:space="preserve">
          <source>Match the end of a word</source>
          <target state="translated">단어의 끝과 일치</target>
        </trans-unit>
        <trans-unit id="623052ec48f26ff003bea7adfaa7df581ef62384" translate="yes" xml:space="preserve">
          <source>Match the list of characters specified by &lt;var&gt;list&lt;/var&gt;. If the first character is &lt;code&gt;!&lt;/code&gt; or &lt;code&gt;^&lt;/code&gt;, match all characters except those specified by &lt;var&gt;list&lt;/var&gt;. For example, the pattern &lt;code&gt;[a-zA-Z]&lt;/code&gt; will match all lower and uppercase alphabetic characters.</source>
          <target state="translated">에 의해 지정된 문자 목록 일치 &lt;var&gt;list&lt;/var&gt; . 첫 번째 문자가 &lt;code&gt;!&lt;/code&gt; 또는 &lt;code&gt;^&lt;/code&gt; , &lt;var&gt;list&lt;/var&gt; 로 지정된 문자를 제외한 모든 문자를 일치시킵니다 . 예를 들어, 패턴 &lt;code&gt;[a-zA-Z]&lt;/code&gt; 는 모든 소문자 및 대문자 알파벳과 일치합니다.</target>
        </trans-unit>
        <trans-unit id="d2713b0482cbb41f7e94f58fe0ff1b93b9574444" translate="yes" xml:space="preserve">
          <source>Match the list of characters specified by &lt;var&gt;list&lt;/var&gt;. If the first character is &lt;code&gt;!&lt;/code&gt; or &lt;code&gt;^&lt;/code&gt;, match all characters except those specified by &lt;var&gt;list&lt;/var&gt;. For example, the pattern &lt;code&gt;[a-zA-Z]&lt;/code&gt; will match all lowercase and uppercase alphabetic characters.</source>
          <target state="translated">에 의해 지정된 문자 목록 일치 &lt;var&gt;list&lt;/var&gt; . 첫 번째 문자가 &lt;code&gt;!&lt;/code&gt; 또는 &lt;code&gt;^&lt;/code&gt; , &lt;var&gt;list&lt;/var&gt; 로 지정된 문자를 제외한 모든 문자를 일치시킵니다 . 예를 들어, 패턴 &lt;code&gt;[a-zA-Z]&lt;/code&gt; 는 모든 소문자 및 대문자 알파벳 문자와 일치합니다.</target>
        </trans-unit>
        <trans-unit id="91ff07971edeb08c3cdfecf47cdb4cf4fe41cfdd" translate="yes" xml:space="preserve">
          <source>Match within a word</source>
          <target state="translated">단어 내에서 일치</target>
        </trans-unit>
        <trans-unit id="c57bd8410b9f734891b7d82076ebbac9a8e56bb0" translate="yes" xml:space="preserve">
          <source>Match zero or more characters.</source>
          <target state="translated">0 개 이상의 문자를 일치시킵니다.</target>
        </trans-unit>
        <trans-unit id="a71e692e2df10ea31ec37f6a3edbd41c0051ab59" translate="yes" xml:space="preserve">
          <source>Match zero or more times</source>
          <target state="translated">0 번 이상 일치</target>
        </trans-unit>
        <trans-unit id="c144083cc612537c40d52f2cfc75eb6ae5cd4347" translate="yes" xml:space="preserve">
          <source>Match zero or one times</source>
          <target state="translated">0 번 또는 1 번 일치</target>
        </trans-unit>
        <trans-unit id="fb175971e4e7f517394474776c23e568499d13c9" translate="yes" xml:space="preserve">
          <source>Match. &lt;code&gt;table(idx(i)) == y(i)&lt;/code&gt; if &lt;code&gt;y(i)&lt;/code&gt; occurs in table; otherwise, &lt;code&gt;idx(i)&lt;/code&gt; is zero.</source>
          <target state="translated">시합. &lt;code&gt;table(idx(i)) == y(i)&lt;/code&gt; &lt;code&gt;y(i)&lt;/code&gt; 가 발생 하면 table (idx (i)) == y (i) ; 그렇지 않으면 &lt;code&gt;idx(i)&lt;/code&gt; 는 0입니다.</target>
        </trans-unit>
        <trans-unit id="223d55a22361b001efd74d1cb162b3faf8191dbe" translate="yes" xml:space="preserve">
          <source>Matches a string containing only non-whitespace characters. See &lt;a href=&quot;string-input-conversions#String-Input-Conversions&quot;&gt;String Input Conversions&lt;/a&gt;.</source>
          <target state="translated">공백이 아닌 문자 만 포함하는 문자열과 일치합니다. &lt;a href=&quot;string-input-conversions#String-Input-Conversions&quot;&gt;문자열 입력 변환을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="186adfae46bbe9d66bd2eaddd44d09a74ed81210" translate="yes" xml:space="preserve">
          <source>Matches a string of one or more characters; the number of characters read is controlled by the maximum field width given for the conversion. See &lt;a href=&quot;string-input-conversions#String-Input-Conversions&quot;&gt;String Input Conversions&lt;/a&gt;.</source>
          <target state="translated">하나 이상의 문자 문자열과 일치합니다. 읽은 문자 수는 변환에 지정된 최대 필드 너비에 의해 제어됩니다. 보다&lt;a href=&quot;string-input-conversions#String-Input-Conversions&quot;&gt;문자열 입력 변환을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="de108c6be394273b3926ced1f8b143c95b6173c2" translate="yes" xml:space="preserve">
          <source>Matches an optionally signed floating-point number. See &lt;a href=&quot;numeric-input-conversions#Numeric-Input-Conversions&quot;&gt;Numeric Input Conversions&lt;/a&gt;.</source>
          <target state="translated">선택적으로 부호있는 부동 소수점 숫자와 일치합니다. 보다&lt;a href=&quot;numeric-input-conversions#Numeric-Input-Conversions&quot;&gt;숫자 입력 변환을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1eba33e0383f3b3164f86e250ef3758f6b3b52f3" translate="yes" xml:space="preserve">
          <source>Matches an optionally signed integer in any of the formats that the C language defines for specifying an integer constant. See &lt;a href=&quot;numeric-input-conversions#Numeric-Input-Conversions&quot;&gt;Numeric Input Conversions&lt;/a&gt;.</source>
          <target state="translated">정수 상수를 지정하기 위해 C 언어가 정의하는 형식으로 선택적으로 부호있는 정수를 찾습니다. 보다&lt;a href=&quot;numeric-input-conversions#Numeric-Input-Conversions&quot;&gt;숫자 입력 변환을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="fa31f35fb0976da587f0ba9cb3c847ca2f8d091c" translate="yes" xml:space="preserve">
          <source>Matches an optionally signed integer written in decimal. See &lt;a href=&quot;numeric-input-conversions#Numeric-Input-Conversions&quot;&gt;Numeric Input Conversions&lt;/a&gt;.</source>
          <target state="translated">선택적으로 부호있는 정수를 10 진수로 기록합니다. 보다&lt;a href=&quot;numeric-input-conversions#Numeric-Input-Conversions&quot;&gt;숫자 입력 변환을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="199e91e2c732309924052084f3fa7948f9d84b9f" translate="yes" xml:space="preserve">
          <source>Matches an unsigned integer written in decimal radix. See &lt;a href=&quot;numeric-input-conversions#Numeric-Input-Conversions&quot;&gt;Numeric Input Conversions&lt;/a&gt;.</source>
          <target state="translated">십진 기수로 작성된 부호없는 정수와 일치합니다. 보다&lt;a href=&quot;numeric-input-conversions#Numeric-Input-Conversions&quot;&gt;숫자 입력 변환을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="21bcb830fe0f4b09cf477e4db8e22984b7d52b28" translate="yes" xml:space="preserve">
          <source>Matches an unsigned integer written in hexadecimal radix. See &lt;a href=&quot;numeric-input-conversions#Numeric-Input-Conversions&quot;&gt;Numeric Input Conversions&lt;/a&gt;.</source>
          <target state="translated">16 진 기수로 작성된 부호없는 정수와 일치합니다. 보다&lt;a href=&quot;numeric-input-conversions#Numeric-Input-Conversions&quot;&gt;숫자 입력 변환을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5cb6309c4ad104e90181011a0a7891d7ef28a5cc" translate="yes" xml:space="preserve">
          <source>Matches an unsigned integer written in octal radix. See &lt;a href=&quot;numeric-input-conversions#Numeric-Input-Conversions&quot;&gt;Numeric Input Conversions&lt;/a&gt;.</source>
          <target state="translated">8 진 기수로 작성된 부호없는 정수와 일치합니다. &lt;a href=&quot;numeric-input-conversions#Numeric-Input-Conversions&quot;&gt;숫자 입력 변환을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ff7356c177f3b51b109ef196d5ed5f6ab4cbdb73" translate="yes" xml:space="preserve">
          <source>Mathematical Considerations</source>
          <target state="translated">수학적 고려 사항</target>
        </trans-unit>
        <trans-unit id="bb100702636dc9b5fe68e1530d43e82eb5b763f7" translate="yes" xml:space="preserve">
          <source>Mathematical Constants</source>
          <target state="translated">수학 상수</target>
        </trans-unit>
        <trans-unit id="082c8f6068cb3a4496e061182a266bc16ecb2bf6" translate="yes" xml:space="preserve">
          <source>Mathematical Equations</source>
          <target state="translated">수학 방정식</target>
        </trans-unit>
        <trans-unit id="4e610d978c9a3934fde5a75a8af8a5b99d24d689" translate="yes" xml:space="preserve">
          <source>Mathematical Note:</source>
          <target state="translated">수학 노트 :</target>
        </trans-unit>
        <trans-unit id="b297fd446e50064884a5002ec806e0d82a4dcc8b" translate="yes" xml:space="preserve">
          <source>Mathematically, an identity matrix is both diagonal and permutation matrix. In Octave, &lt;code&gt;eye (n)&lt;/code&gt; returns a diagonal matrix, because a matrix can only have one class. You can convert this diagonal matrix to a permutation matrix by indexing it by an identity permutation, as shown below. This is a special property of the identity matrix; indexing other diagonal matrices generally produces a full matrix.</source>
          <target state="translated">수학적으로, 항등 행렬은 대각선 행렬과 순열 행렬입니다. 옥타브에서 &lt;code&gt;eye (n)&lt;/code&gt; 은 행렬이 하나의 클래스 만 가질 수 있으므로 대각 행렬을 반환합니다. 아래와 같이이 대각 행렬을 ID 순열로 색인화하여 순열 행렬로 변환 할 수 있습니다. 이것은 항등 행렬의 특별한 속성입니다. 다른 대각선 행렬을 인덱싱하면 일반적으로 전체 행렬이 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="78cbd3e265e7e07889fc75bca0204d4e0c790ade" translate="yes" xml:space="preserve">
          <source>Matlab-compatible solvers</source>
          <target state="translated">Matlab 호환 솔버</target>
        </trans-unit>
        <trans-unit id="cff7d0ab91ae7cae99d82ea0a8400f0788a6c4ae" translate="yes" xml:space="preserve">
          <source>Matrices</source>
          <target state="translated">Matrices</target>
        </trans-unit>
        <trans-unit id="449609c04cfe553af7942640fa8d66f7747de493" translate="yes" xml:space="preserve">
          <source>Matrices and Arrays in Oct-Files</source>
          <target state="translated">10 월 파일의 행렬 및 배열</target>
        </trans-unit>
        <trans-unit id="422ff3885fe30f822ee5b4ecd4fbb5e4d9713c20" translate="yes" xml:space="preserve">
          <source>Matrix &lt;code&gt;[xf, yf, zf; xb, yb, zb]&lt;/code&gt; which holds the coordinates (in axes data units) of the point over which the mouse pointer was when the mouse button was pressed. If a mouse callback function is defined, &lt;code&gt;currentpoint&lt;/code&gt; holds the pointer coordinates at the time the mouse button was pressed. For 3-D plots, the first row of the returned matrix specifies the point nearest to the current camera position and the second row the furthest point. The two points forms a line which is perpendicular to the screen.</source>
          <target state="translated">매트릭스 &lt;code&gt;[xf, yf, zf; xb, yb, zb]&lt;/code&gt; 는 마우스 버튼을 눌렀을 때 마우스 포인터가 있었던 지점의 좌표 (축 데이터 단위)를 유지합니다. 마우스 콜백 함수가 정의 된 경우 &lt;code&gt;currentpoint&lt;/code&gt; 는 마우스 버튼을 눌렀을 때의 포인터 좌표를 유지합니다. 3 차원 플롯의 경우 반환 된 행렬의 첫 번째 행은 현재 카메라 위치에 가장 가까운 점을 지정하고 두 번째 행은 가장 먼 점을 지정합니다. 두 점은 화면에 수직 인 선을 형성합니다.</target>
        </trans-unit>
        <trans-unit id="6918808379d67565d7976ba5b2f09775df994128" translate="yes" xml:space="preserve">
          <source>Matrix Computations (3rd Ed.)</source>
          <target state="translated">행렬 계산 (3 판)</target>
        </trans-unit>
        <trans-unit id="88f017a6c291a8e817ebad8cb764d6383bbd922c" translate="yes" xml:space="preserve">
          <source>Matrix Computations, 2nd Ed.</source>
          <target state="translated">매트릭스 계산, 2nd Ed.</target>
        </trans-unit>
        <trans-unit id="a2e2934d9d6adaee1ba12b09423ab0a6e374a297" translate="yes" xml:space="preserve">
          <source>Matrix Computations, 2nd edition</source>
          <target state="translated">매트릭스 계산, 2 판</target>
        </trans-unit>
        <trans-unit id="0cd3c03785c4a0368fc4db4275a4ff9eeda21093" translate="yes" xml:space="preserve">
          <source>Matrix Differential Calculus with Applications in Statistics and Econometrics</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="514777a8e49c596fe63b6dadb139ba2af42f8551" translate="yes" xml:space="preserve">
          <source>Matrix Differential Calculus with Applications in Statistics and Econometrics.</source>
          <target state="translated">통계 및 계량 경제학에서의 응용을 이용한 행렬 미분 미적분학.</target>
        </trans-unit>
        <trans-unit id="da4ac3de1ae53d84c3a085cd128907491664d133" translate="yes" xml:space="preserve">
          <source>Matrix Factorizations</source>
          <target state="translated">행렬 분해</target>
        </trans-unit>
        <trans-unit id="4f00cc643a55ff137a85df943134cd0667f824a0" translate="yes" xml:space="preserve">
          <source>Matrix Manipulation</source>
          <target state="translated">매트릭스 조작</target>
        </trans-unit>
        <trans-unit id="203396854a334f741a7a9130f36b7d06929f360d" translate="yes" xml:space="preserve">
          <source>Matrix left division</source>
          <target state="translated">매트릭스 왼쪽 분할</target>
        </trans-unit>
        <trans-unit id="f236c7e88a9ba81d56f84f98b359a6b31c818a95" translate="yes" xml:space="preserve">
          <source>Matrix multiplication</source>
          <target state="translated">행렬 곱셈</target>
        </trans-unit>
        <trans-unit id="b291edbffb27d988151b769c59f11a40ddca7bcc" translate="yes" xml:space="preserve">
          <source>Matrix multiplication. The number of columns of &lt;var&gt;x&lt;/var&gt; must agree with the number of rows of &lt;var&gt;y&lt;/var&gt;.</source>
          <target state="translated">행렬 곱셈. &lt;var&gt;x&lt;/var&gt; 의 열 수는 &lt;var&gt;y&lt;/var&gt; 의 행 수와 일치해야합니다 .</target>
        </trans-unit>
        <trans-unit id="c63880344de38a408a4ab9b34069473843485497" translate="yes" xml:space="preserve">
          <source>Matrix objects can be of any size, and can be dynamically reshaped and resized. It is easy to extract individual rows, columns, or submatrices using a variety of powerful indexing features. See &lt;a href=&quot;index-expressions#Index-Expressions&quot;&gt;Index Expressions&lt;/a&gt;.</source>
          <target state="translated">매트릭스 객체의 크기는 다양 할 수 있으며 동적으로 모양을 변경하고 크기를 조정할 수 있습니다. 다양한 강력한 색인 기능을 사용하여 개별 행, 열 또는 하위 행렬을 쉽게 추출 할 수 있습니다. &lt;a href=&quot;index-expressions#Index-Expressions&quot;&gt;인덱스 표현식을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a9925a66599504b03dd8e1183e8e9a0fb503961d" translate="yes" xml:space="preserve">
          <source>Matrix power</source>
          <target state="translated">매트릭스 파워</target>
        </trans-unit>
        <trans-unit id="b43ee02210f1201abb21bc1dc4dde802e1cae9ee" translate="yes" xml:space="preserve">
          <source>Matrix right division</source>
          <target state="translated">행렬 오른쪽 나누기</target>
        </trans-unit>
        <trans-unit id="53548fe345a00ba44ed5ba8ce3d525975528fd00" translate="yes" xml:space="preserve">
          <source>Matrix.cc</source>
          <target state="translated">Matrix.cc</target>
        </trans-unit>
        <trans-unit id="7cf8906c6c2d89469415b14e04fe08673c019632" translate="yes" xml:space="preserve">
          <source>MaxFunEvals</source>
          <target state="translated">MaxFunEvals</target>
        </trans-unit>
        <trans-unit id="3e3ce0d007c3fd51877c0db00425afcc67978e44" translate="yes" xml:space="preserve">
          <source>MaxIter</source>
          <target state="translated">MaxIter</target>
        </trans-unit>
        <trans-unit id="8f15c1027f08623d6e530d9b81dae89b9b51b0ba" translate="yes" xml:space="preserve">
          <source>Maximum data size.</source>
          <target state="translated">최대 데이터 크기</target>
        </trans-unit>
        <trans-unit id="94f8402b9e54fff35f9cbea70c648f5bd9ec01e4" translate="yes" xml:space="preserve">
          <source>Maximum number of Jacobian evaluations (default is 6).</source>
          <target state="translated">자 코비안 평가의 최대 수 (기본값은 6).</target>
        </trans-unit>
        <trans-unit id="83c604da874a6990730bbcab3ee0585fec56e4b1" translate="yes" xml:space="preserve">
          <source>Maximum number of Newton iterations (default is 5).</source>
          <target state="translated">최대 뉴턴 반복 횟수 (기본값은 5)입니다.</target>
        </trans-unit>
        <trans-unit id="890099ea689cfa3db2cecd226c83d8577c4c6bdc" translate="yes" xml:space="preserve">
          <source>Maximum number of algorithm iterations before optimization stops. Must be a positive integer.</source>
          <target state="translated">최적화가 중지되기 전의 최대 알고리즘 반복 횟수입니다. 양의 정수 여야합니다.</target>
        </trans-unit>
        <trans-unit id="1d37806971cf03cb1f9020630c346d8ba944aaf7" translate="yes" xml:space="preserve">
          <source>Maximum number of function evaluations before optimization stops. Must be a positive integer.</source>
          <target state="translated">최적화가 중지되기 전의 최대 기능 평가 수입니다. 양의 정수 여야합니다.</target>
        </trans-unit>
        <trans-unit id="e6cbff5cb78c44c2c2de2c197b92b7d7142f0c35" translate="yes" xml:space="preserve">
          <source>Maximum number of integration steps to attempt on a single call to the underlying Fortran code.</source>
          <target state="translated">기본 포트란 코드에 대한 단일 호출에서 시도 할 최대 통합 단계 수입니다.</target>
        </trans-unit>
        <trans-unit id="80284b9072691dcb08b05b0fc59da8439feb1f2f" translate="yes" xml:space="preserve">
          <source>Maximum number of iterations reached.</source>
          <target state="translated">최대 반복 횟수에 도달했습니다.</target>
        </trans-unit>
        <trans-unit id="3fcea6ff6580050eb63d7142d23e7d7896de7626" translate="yes" xml:space="preserve">
          <source>Maximum number of iterations.</source>
          <target state="translated">최대 반복 횟수입니다.</target>
        </trans-unit>
        <trans-unit id="1f4573514ec97a5bf66608800837376fb813c815" translate="yes" xml:space="preserve">
          <source>Maximum number of steps allowed (default is 100000).</source>
          <target state="translated">허용되는 최대 단계 수 (기본값은 100000)입니다.</target>
        </trans-unit>
        <trans-unit id="8cabee9949cf7b4333cf68f71446093aa82abc04" translate="yes" xml:space="preserve">
          <source>Maximum number of values of the artificial stepsize parameter to be tried if the &lt;code&gt;&quot;compute consistent initial condition&quot;&lt;/code&gt; option has been set to 1 (default is 5).</source>
          <target state="translated">&lt;code&gt;&quot;compute consistent initial condition&quot;&lt;/code&gt; 옵션이 1 (기본값은 5)로 설정된 경우 시도 할 인공 단계 화 매개 변수의 최대 값 수입니다 .</target>
        </trans-unit>
        <trans-unit id="a5845e6e7cda1dcf7e4f6a54f6e0d6e7e4670ab8" translate="yes" xml:space="preserve">
          <source>Maximum order of formula.</source>
          <target state="translated">수식의 최대 순서.</target>
        </trans-unit>
        <trans-unit id="a3039e679faa6ea13ad3447d25d2053e82aa65ce" translate="yes" xml:space="preserve">
          <source>Maximum time step value.</source>
          <target state="translated">최대 시간 단계 값.</target>
        </trans-unit>
        <trans-unit id="e610f2928fd86da6e640213fad7db9f89aba6d10" translate="yes" xml:space="preserve">
          <source>May be one of</source>
          <target state="translated">다음 중 하나 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="19cd7d185cfd95a703e62d43597e9ae28e0646e5" translate="yes" xml:space="preserve">
          <source>Meaning</source>
          <target state="translated">Meaning</target>
        </trans-unit>
        <trans-unit id="754ffd2f9269e6eb5ae888826998ad41fc0f286e" translate="yes" xml:space="preserve">
          <source>Measure elapsed time on a wall-clock timer.</source>
          <target state="translated">벽시계 타이머의 경과 시간을 측정합니다.</target>
        </trans-unit>
        <trans-unit id="16b984450655fb6f8a1d7415fa977721b1915e7d" translate="yes" xml:space="preserve">
          <source>MediaType</source>
          <target state="translated">MediaType</target>
        </trans-unit>
        <trans-unit id="c1c4076a197db33d974e23b7a48a2b0448b3b77a" translate="yes" xml:space="preserve">
          <source>Medium accuracy (1e-6 &amp;ndash; 1e-9) with smooth integrands.</source>
          <target state="translated">부드러운 정수로 중간 정확도 (1e-6 &amp;ndash; 1e-9).</target>
        </trans-unit>
        <trans-unit id="b93a8c7df926c952166299ed35057e9017664fe4" translate="yes" xml:space="preserve">
          <source>Medium accuracy with smooth integrands</source>
          <target state="translated">부드러운 정수로 중간 정도의 정확도</target>
        </trans-unit>
        <trans-unit id="6c8497d782d1b74ddf390d2ca5b79643d12f078d" translate="yes" xml:space="preserve">
          <source>Medium accuracy with smooth integrands. Slower than quadgk.</source>
          <target state="translated">부드러운 정수로 중간 정도의 정확도. quadgk보다 느립니다.</target>
        </trans-unit>
        <trans-unit id="33520ae75f0c1f9b00ea16d8c3bb31811c1ab19e" translate="yes" xml:space="preserve">
          <source>Merge elements of &lt;var&gt;true_val&lt;/var&gt; and &lt;var&gt;false_val&lt;/var&gt;, depending on the value of &lt;var&gt;mask&lt;/var&gt;.</source>
          <target state="translated">&lt;var&gt;mask&lt;/var&gt; 값에 따라 &lt;var&gt;true_val&lt;/var&gt; 및 &lt;var&gt;false_val&lt;/var&gt; 요소를 병합하십시오 .</target>
        </trans-unit>
        <trans-unit id="6013b165835c50b25c935b3da50fbec071436eb6" translate="yes" xml:space="preserve">
          <source>Mersenne Twister: A 623-dimensionally equidistributed uniform pseudorandom number generator</source>
          <target state="translated">Mersenne Twister : 623 차원으로 균일하게 분포 된 균일 한 의사 난수 생성기</target>
        </trans-unit>
        <trans-unit id="cd7ffd91b88ce75181ccb55a1fc783213775b802" translate="yes" xml:space="preserve">
          <source>Message-Digest Algorithm 2 (RFC 1319).</source>
          <target state="translated">메시지 요약 알고리즘 2 (RFC 1319).</target>
        </trans-unit>
        <trans-unit id="d18ff66d792317486b2538f262321cd23a51f43c" translate="yes" xml:space="preserve">
          <source>Message-Digest Algorithm 4 (RFC 1320).</source>
          <target state="translated">메시지 요약 알고리즘 4 (RFC 1320).</target>
        </trans-unit>
        <trans-unit id="571cf5f53a9233a59cc134c2c5d5ee97194cb62c" translate="yes" xml:space="preserve">
          <source>Message-Digest Algorithm 5 (RFC 1321).</source>
          <target state="translated">메시지 요약 알고리즘 5 (RFC 1321).</target>
        </trans-unit>
        <trans-unit id="ef033a131d7fc5bbea1c59e0a7573b49b52dca18" translate="yes" xml:space="preserve">
          <source>Meta-u</source>
          <target state="translated">Meta-u</target>
        </trans-unit>
        <trans-unit id="b99cd12eda7ca6fb6096c748d26bf3cc863e7740" translate="yes" xml:space="preserve">
          <source>Metafont</source>
          <target state="translated">Metafont</target>
        </trans-unit>
        <trans-unit id="88306943fea7e76f9cd57cae0ea6d8b32d2e8434" translate="yes" xml:space="preserve">
          <source>Method</source>
          <target state="translated">Method</target>
        </trans-unit>
        <trans-unit id="1e5053f31038b448af928216638c113bc9637ffa" translate="yes" xml:space="preserve">
          <source>Method 1: Inverse of empirical distribution function.</source>
          <target state="translated">방법 1 : 경험적 분포 함수의 역함.</target>
        </trans-unit>
        <trans-unit id="4241d55ad52d2c0a46dd2482311eca2c8fd9725f" translate="yes" xml:space="preserve">
          <source>Method 2: Similar to method 1 but with averaging at discontinuities.</source>
          <target state="translated">방법 2 : 방법 1과 유사하지만 불연속성이 평균입니다.</target>
        </trans-unit>
        <trans-unit id="67504c9c150b55ec9b21e8c64cd30af350d1f395" translate="yes" xml:space="preserve">
          <source>Method 3: SAS definition: nearest even order statistic.</source>
          <target state="translated">방법 3 : SAS 정의 : 가장 가까운 짝수 주문 통계.</target>
        </trans-unit>
        <trans-unit id="e1f57266d96317adef94812c9e31ee7896619996" translate="yes" xml:space="preserve">
          <source>Method 4: &lt;var&gt;p&lt;/var&gt;(k) = k / N. That is, linear interpolation of the empirical cdf, where &lt;em&gt;N&lt;/em&gt; is the length of &lt;var&gt;P&lt;/var&gt;.</source>
          <target state="translated">방법 4 : &lt;var&gt;p&lt;/var&gt; (k) = k / N. 즉 경험적 cdf의 선형 보간. 여기서 &lt;em&gt;N&lt;/em&gt; 은 &lt;var&gt;P&lt;/var&gt; 의 길이입니다 .</target>
        </trans-unit>
        <trans-unit id="2debfda8cf0c98f061643252ae4448ecef810baf" translate="yes" xml:space="preserve">
          <source>Method 5: &lt;var&gt;p&lt;/var&gt;(k) = (k - 0.5) / N. That is, a piecewise linear function where the knots are the values midway through the steps of the empirical cdf.</source>
          <target state="translated">방법 5 : &lt;var&gt;p&lt;/var&gt; (k) = (k-0.5) / N. 즉, 매듭이 경험적 cdf 단계의 중간 값인 부분 선형 함수.</target>
        </trans-unit>
        <trans-unit id="8eb217a3fcd7502eb577710527708537cd4ce4ac" translate="yes" xml:space="preserve">
          <source>Method 6: &lt;var&gt;p&lt;/var&gt;(k) = k / (N + 1).</source>
          <target state="translated">방법 6 : &lt;var&gt;p&lt;/var&gt; (k) = k / (N + 1).</target>
        </trans-unit>
        <trans-unit id="402d8ca279ac0b276951aad35d7c66aa2515ebf8" translate="yes" xml:space="preserve">
          <source>Method 7: &lt;var&gt;p&lt;/var&gt;(k) = (k - 1) / (N - 1).</source>
          <target state="translated">방법 7 : &lt;var&gt;p&lt;/var&gt; (k) = (k-1) / (N-1).</target>
        </trans-unit>
        <trans-unit id="5cc2da44954a565527a6043e19935b4ee5d7d783" translate="yes" xml:space="preserve">
          <source>Method 8: &lt;var&gt;p&lt;/var&gt;(k) = (k - 1/3) / (N + 1/3). The resulting quantile estimates are approximately median-unbiased regardless of the distribution of &lt;var&gt;x&lt;/var&gt;.</source>
          <target state="translated">방법 8 : &lt;var&gt;p&lt;/var&gt; (k) = (k-1/3) / (N + 1/3). 결과 Quantile 추정값은 &lt;var&gt;x&lt;/var&gt; 의 분포에 관계없이 대략 중앙값을 갖습니다 .</target>
        </trans-unit>
        <trans-unit id="fc0f027563268050f87975b3bc243a507bb46ea6" translate="yes" xml:space="preserve">
          <source>Method 9: &lt;var&gt;p&lt;/var&gt;(k) = (k - 3/8) / (N + 1/4). The resulting quantile estimates are approximately unbiased for the expected order statistics if &lt;var&gt;x&lt;/var&gt; is normally distributed.</source>
          <target state="translated">방법 9 : &lt;var&gt;p&lt;/var&gt; (k) = (k-3/8) / (N + 1/4). &lt;var&gt;x&lt;/var&gt; 가 정규 분포 를 따르는 경우 결과 Quantile 추정값은 예상 주문 통계에 대해 거의 편향되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="77e14ed46b33afe368780bd973786d92dabaa2b4" translate="yes" xml:space="preserve">
          <source>Method of a class to manipulate an object after loading it from a file.</source>
          <target state="translated">파일에서 객체를로드 한 후 조작하는 클래스의 메서드입니다.</target>
        </trans-unit>
        <trans-unit id="e9e642fd7b56363edc98cc7a00c6cc346da61f6d" translate="yes" xml:space="preserve">
          <source>Method of a class to manipulate an object prior to saving it to a file.</source>
          <target state="translated">객체를 파일로 저장하기 전에 조작하는 클래스의 메서드입니다.</target>
        </trans-unit>
        <trans-unit id="cc25c745d77ace7d1cffb4c351a36bb8a84c67a6" translate="yes" xml:space="preserve">
          <source>Method:</source>
          <target state="translated">Method:</target>
        </trans-unit>
        <trans-unit id="b97bf44087d41a627bf10d134ace8f3faada92b9" translate="yes" xml:space="preserve">
          <source>Method: T&amp;amp; elem (octave_idx_type)</source>
          <target state="translated">방법 : T &amp;amp; elem (octave_idx_type)</target>
        </trans-unit>
        <trans-unit id="98106616aa83c629bd6bcaf02f3dd0722a032db3" translate="yes" xml:space="preserve">
          <source>Method: T&amp;amp; operator () (octave_idx_type)</source>
          <target state="translated">방법 : T &amp;amp; 연산자 () (octave_idx_type)</target>
        </trans-unit>
        <trans-unit id="8fc693119bc3fe0f4700d6d8df3f7cda5998d806" translate="yes" xml:space="preserve">
          <source>Method: T* fortran_vec (void)</source>
          <target state="translated">방법 : T * fortran_vec (void)</target>
        </trans-unit>
        <trans-unit id="6b618903f4455202f1d1a5c2ba88f1d1e6c83972" translate="yes" xml:space="preserve">
          <source>Method: dim_vector dims (void) const</source>
          <target state="translated">방법 : dim_vector dims (void) const</target>
        </trans-unit>
        <trans-unit id="7d0d1969dc835d0def49f9e4e3fc7f09e0166163" translate="yes" xml:space="preserve">
          <source>Method: int ndims (void) const</source>
          <target state="translated">메소드 : int ndims (void) const</target>
        </trans-unit>
        <trans-unit id="bf943e73d7935cafcf688378efa09ccfe2790f51" translate="yes" xml:space="preserve">
          <source>Method: octave_idx_type numel (void) const</source>
          <target state="translated">방법 : octave_idx_type numel (void) const</target>
        </trans-unit>
        <trans-unit id="5b9e5c377b1d4aab4e051027f532dc9d97022f53" translate="yes" xml:space="preserve">
          <source>Method: size_t byte_size (void) const</source>
          <target state="translated">메소드 : size_t byte_size (void) const</target>
        </trans-unit>
        <trans-unit id="8d3389c26ac3557deb24bc299c82387cc74acdd1" translate="yes" xml:space="preserve">
          <source>Method: void resize (const dim_vector&amp;amp;)</source>
          <target state="translated">메소드 : void resize (const dim_vector &amp;amp;)</target>
        </trans-unit>
        <trans-unit id="da30289989397b5c1238f7d1576566c9de60ba1a" translate="yes" xml:space="preserve">
          <source>Method: void resize (nrows, ncols)</source>
          <target state="translated">방법 : void 크기 조정 (nrows, ncols)</target>
        </trans-unit>
        <trans-unit id="7e4ac6803c9159c694f63d089cb06b2519c16aba" translate="yes" xml:space="preserve">
          <source>Methods</source>
          <target state="translated">Methods</target>
        </trans-unit>
        <trans-unit id="384747e7e61f812c7640d6db88e88ac13fcf14b1" translate="yes" xml:space="preserve">
          <source>Methods are defined by m-files in the class directory and can have embedded documentation the same as any other m-file. The help for the constructor can be obtained by using the constructor name alone, that is, for the polynomial constructor &lt;code&gt;help polynomial&lt;/code&gt; will return the help string. Help can be restricted to a particular class by using the class directory name followed by the method. For example, &lt;code&gt;help @polynomial/polynomial&lt;/code&gt; is another way of displaying the help string for the polynomial constructor. This second means is the only way to obtain help for the overloaded methods and functions of a class.</source>
          <target state="translated">메소드는 클래스 디렉토리의 m 파일에 의해 정의되며 다른 m 파일과 동일한 문서를 내장 할 수 있습니다. 생성자 이름 만 사용하여 생성자에 대한 도움말을 얻을 수 있습니다. 즉, 다항식 생성자의 경우 &lt;code&gt;help polynomial&lt;/code&gt; 은 도움말 문자열을 반환합니다. 클래스 디렉토리 이름과 메소드를 사용하여 특정 클래스로 도움말을 제한 할 수 있습니다. 예를 들어 &lt;code&gt;help @polynomial/polynomial&lt;/code&gt; 은 다항식 생성자에 대한 도움말 문자열을 표시하는 또 다른 방법입니다. 이 두 번째 방법은 클래스의 오버로드 된 메소드 및 함수에 대한 도움말을 얻는 유일한 방법입니다.</target>
        </trans-unit>
        <trans-unit id="ecb53c3298ed4b301d5ba142dd8d8f038447597f" translate="yes" xml:space="preserve">
          <source>Mex-Files</source>
          <target state="translated">Mex-Files</target>
        </trans-unit>
        <trans-unit id="f9749c87ae4e0b201ec7f5c196384e38e10dafa2" translate="yes" xml:space="preserve">
          <source>Microseconds after the second (0-999999).</source>
          <target state="translated">초 후 마이크로 초 (0-999999).</target>
        </trans-unit>
        <trans-unit id="be274f51974de8703c2cf85b3742ef619e86e7ae" translate="yes" xml:space="preserve">
          <source>Microsoft Enhanced Metafile</source>
          <target state="translated">Microsoft Enhanced Metafile</target>
        </trans-unit>
        <trans-unit id="b0222f2a9bad0d7911b66bd31221c8eaf87b18ff" translate="yes" xml:space="preserve">
          <source>Milliseconds of second (padded with zeros)</source>
          <target state="translated">밀리 초 (0으로 채워짐)</target>
        </trans-unit>
        <trans-unit id="a0c3e23c34a0e3cd91446c5ef02171d3622bab34" translate="yes" xml:space="preserve">
          <source>Minimize &lt;code&gt;1/2*&lt;var&gt;x&lt;/var&gt;'*&lt;var&gt;c&lt;/var&gt;*&lt;var&gt;x&lt;/var&gt; + &lt;var&gt;d&lt;/var&gt;'*&lt;var&gt;x&lt;/var&gt;&lt;/code&gt; subject to &lt;code&gt;&lt;var&gt;x&lt;/var&gt; &amp;gt;= 0&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;var&gt;x&lt;/var&gt; &amp;gt;= 0&lt;/code&gt; &amp;gt; = 0에 따라 &lt;code&gt;1/2*&lt;var&gt;x&lt;/var&gt;'*&lt;var&gt;c&lt;/var&gt;*&lt;var&gt;x&lt;/var&gt; + &lt;var&gt;d&lt;/var&gt;'*&lt;var&gt;x&lt;/var&gt;&lt;/code&gt; 최소화하십시오 .</target>
        </trans-unit>
        <trans-unit id="48d16e077a07dbf3831b71949e6a6307b29742b5" translate="yes" xml:space="preserve">
          <source>Minimize &lt;code&gt;norm (&lt;var&gt;c&lt;/var&gt;*&lt;var&gt;x&lt;/var&gt; - &lt;var&gt;d&lt;/var&gt;)&lt;/code&gt; subject to &lt;code&gt;&lt;var&gt;x&lt;/var&gt; &amp;gt;= 0&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;var&gt;x&lt;/var&gt; &amp;gt;= 0&lt;/code&gt; &amp;gt; = 0에 따라 &lt;code&gt;norm (&lt;var&gt;c&lt;/var&gt;*&lt;var&gt;x&lt;/var&gt; - &lt;var&gt;d&lt;/var&gt;)&lt;/code&gt; 최소화하십시오 .</target>
        </trans-unit>
        <trans-unit id="461fb348c1c324884ebb7417f1563e30c2312fce" translate="yes" xml:space="preserve">
          <source>Minimize an objective function using sequential quadratic programming (SQP).</source>
          <target state="translated">순차 2 차 프로그래밍 (SQP)을 사용하여 목적 함수를 최소화하십시오.</target>
        </trans-unit>
        <trans-unit id="f1f13893991ee29d1b5d51a5cc35dfc8e613b0b7" translate="yes" xml:space="preserve">
          <source>Minimizers</source>
          <target state="translated">Minimizers</target>
        </trans-unit>
        <trans-unit id="50e6cfe93760a1933e29d988fe7ca021c37fe299" translate="yes" xml:space="preserve">
          <source>Minimum scaled step in linesearch algorithm (default is eps^(2/3)).</source>
          <target state="translated">라인 검색 알고리즘의 최소 스케일 단계 (기본값은 eps ^ (2/3))</target>
        </trans-unit>
        <trans-unit id="cb879eac977355045f51f16338cac5762308170f" translate="yes" xml:space="preserve">
          <source>Minute (00-59).</source>
          <target state="translated">분 (00-59).</target>
        </trans-unit>
        <trans-unit id="a906dd5a3364dcc3ccea6d5ff13962d684a2c147" translate="yes" xml:space="preserve">
          <source>Minute of hour (padded with zeros)</source>
          <target state="translated">분 (0으로 채워짐)</target>
        </trans-unit>
        <trans-unit id="099eed5035c86642e057ee264ea441ff256af3b3" translate="yes" xml:space="preserve">
          <source>Minutes after the hour (0-59).</source>
          <target state="translated">시간 후 분 (0-59).</target>
        </trans-unit>
        <trans-unit id="91a916c5ec4a5db582ba50bcb8f59b41a0add6d3" translate="yes" xml:space="preserve">
          <source>Misc Symbols Type Ord</source>
          <target state="translated">기타 기호 유형 Ord</target>
        </trans-unit>
        <trans-unit id="319c19b9e813f94557eb26c26b7b4388bfdc0145" translate="yes" xml:space="preserve">
          <source>Miscellaneous Functions</source>
          <target state="translated">기타 기능</target>
        </trans-unit>
        <trans-unit id="d481b51bec2b2cba223f8cce238d5312b36a6dd5" translate="yes" xml:space="preserve">
          <source>Miscellaneous Techniques</source>
          <target state="translated">기타 기법</target>
        </trans-unit>
        <trans-unit id="5957b6ad8581736101c715316c4e67e7f212fe57" translate="yes" xml:space="preserve">
          <source>Miscellaneous matrix manipulations, like &lt;code&gt;flipud&lt;/code&gt;, &lt;code&gt;rot90&lt;/code&gt;, and &lt;code&gt;triu&lt;/code&gt;, as well as other basic functions, like &lt;code&gt;ismatrix&lt;/code&gt;, &lt;code&gt;narginchk&lt;/code&gt;, etc.</source>
          <target state="translated">같은 기타 행렬 조작, &lt;code&gt;flipud&lt;/code&gt; , &lt;code&gt;rot90&lt;/code&gt; 및 &lt;code&gt;triu&lt;/code&gt; 등과 기타 기본적인 기능 &lt;code&gt;ismatrix&lt;/code&gt; , &lt;code&gt;narginchk&lt;/code&gt; 등</target>
        </trans-unit>
        <trans-unit id="082d0468f805408a80fa379ae325506920c80bb1" translate="yes" xml:space="preserve">
          <source>Miscellaneous string-handling functions.</source>
          <target state="translated">기타 문자열 처리 기능</target>
        </trans-unit>
        <trans-unit id="69aa5db4d8836546944b291814b1eee49b5a3b5d" translate="yes" xml:space="preserve">
          <source>Miscellaneous:</source>
          <target state="translated">Miscellaneous:</target>
        </trans-unit>
        <trans-unit id="56ddc5ad1b20569eb06f4afc4005e3ec95401542" translate="yes" xml:space="preserve">
          <source>Missing Components</source>
          <target state="translated">누락 된 구성 요소</target>
        </trans-unit>
        <trans-unit id="f9b302a6528230e8fad06287d3026dae18ccadf3" translate="yes" xml:space="preserve">
          <source>Missing Data</source>
          <target state="translated">누락 된 데이터</target>
        </trans-unit>
        <trans-unit id="1bfa6da4f5047a02ef7c654cff8a76f30501b384" translate="yes" xml:space="preserve">
          <source>Mixed Operation</source>
          <target state="translated">혼합 작업</target>
        </trans-unit>
        <trans-unit id="68c2cc7f0ceaa3e499ecb4db331feb4debbbcc23" translate="yes" xml:space="preserve">
          <source>Model</source>
          <target state="translated">Model</target>
        </trans-unit>
        <trans-unit id="081ef363b2b4a569322b8b235ce701231389272a" translate="yes" xml:space="preserve">
          <source>Modified incomplete Cholesky factorization:</source>
          <target state="translated">불완전한 Cholesky 인수 분해 수정 :</target>
        </trans-unit>
        <trans-unit id="5348887913f1cc632ccdcc744dcb6d004a5feccf" translate="yes" xml:space="preserve">
          <source>Modified incomplete LU factorization:</source>
          <target state="translated">불완전한 LU 인수 분해 수정 :</target>
        </trans-unit>
        <trans-unit id="bf8830a644c041a48c972525149c0430d046a4c5" translate="yes" xml:space="preserve">
          <source>Modify or display Octave&amp;rsquo;s load path.</source>
          <target state="translated">옥타브의로드 경로를 수정하거나 표시합니다.</target>
        </trans-unit>
        <trans-unit id="e0c1bb7420132c1632f35145ba816f6febf2d697" translate="yes" xml:space="preserve">
          <source>Modifying the up vector does not modify the camera target (see &lt;a href=&quot;#XREFcamtarget&quot;&gt;camtarget&lt;/a&gt;). Thus, the camera up vector might not be orthogonal to the direction of the camera&amp;rsquo;s view:</source>
          <target state="translated">위쪽 벡터를 수정해도 카메라 대상은 수정되지 않습니다 ( &lt;a href=&quot;#XREFcamtarget&quot;&gt;camtarget&lt;/a&gt; 참조 ). 따라서 카메라 업 벡터는 카메라 시야 방향과 직교하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="24b2a0993d0cfa93c44282d6bba72bcf58b300d6" translate="yes" xml:space="preserve">
          <source>Mon</source>
          <target state="translated">Mon</target>
        </trans-unit>
        <trans-unit id="932eeb1076c85e522f02e15441fa371e3fd000ac" translate="yes" xml:space="preserve">
          <source>Monday</source>
          <target state="translated">Monday</target>
        </trans-unit>
        <trans-unit id="74d53341ebf27a7b0b9e9c586694994119dc4670" translate="yes" xml:space="preserve">
          <source>Month (01-12).</source>
          <target state="translated">월 (01-12).</target>
        </trans-unit>
        <trans-unit id="62766b7ed2c391a5680e3378b34574e2c1d08694" translate="yes" xml:space="preserve">
          <source>Months below 1 are considered to be January.</source>
          <target state="translated">1 미만의 월은 1 월로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="efcfb5e0e3b0751f0daec55c68728ef6139d87e6" translate="yes" xml:space="preserve">
          <source>Months since January (0-11).</source>
          <target state="translated">1 월 이후의 달 (0-11).</target>
        </trans-unit>
        <trans-unit id="48a97d04c0198c13af3f28b6b88da3be965f53d6" translate="yes" xml:space="preserve">
          <source>More &lt;var&gt;R_j&lt;/var&gt; may be specified than the number of dimensions of &lt;var&gt;x&lt;/var&gt;. Any excess &lt;var&gt;R_j&lt;/var&gt; must be scalars (because &lt;var&gt;x&lt;/var&gt;&amp;rsquo;s size in those dimensions is only 1), and &lt;var&gt;x&lt;/var&gt; will be replicated in those dimensions accordingly.</source>
          <target state="translated">&lt;var&gt;x&lt;/var&gt; 의 차원 수보다 많은 &lt;var&gt;R_j&lt;/var&gt; 를 지정할 수 있습니다 . 초과 &lt;var&gt;R_j&lt;/var&gt; 는 스칼라 여야합니다 ( 해당 차원의 &lt;var&gt;x&lt;/var&gt; 크기는 1에 불과 하므로 ). &lt;var&gt;x&lt;/var&gt; 는 그에 따라 해당 차원에서 복제됩니다.</target>
        </trans-unit>
        <trans-unit id="55f051b536602262bcce45c433910afff6dc065b" translate="yes" xml:space="preserve">
          <source>More complex constraints may be added as well. For example, the code below illustrates a periodic fit with values that have been clamped at the endpoints, and a second periodic fit which is hinged at the endpoints.</source>
          <target state="translated">더 복잡한 구속 조건도 추가 될 수 있습니다. 예를 들어, 아래 코드는 끝점에 고정 된 값을 사용하는주기적인 맞춤과 끝점에 힌지가있는 두 번째 주기적 맞춤을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="754bbd6d917505e0487bb8bfca83939b74396492" translate="yes" xml:space="preserve">
          <source>More generally,</source>
          <target state="translated">더 일반적으로,</target>
        </trans-unit>
        <trans-unit id="4803c40a959d7beb1584a037b589ffd5e7bdc202" translate="yes" xml:space="preserve">
          <source>More precisely, &lt;code&gt;eps&lt;/code&gt; is the relative spacing between any two adjacent numbers in the machine&amp;rsquo;s floating point system. This number is obviously system dependent. On machines that support IEEE floating point arithmetic, &lt;code&gt;eps&lt;/code&gt; is approximately 2.2204e-16 for double precision and 1.1921e-07 for single precision.</source>
          <target state="translated">보다 정확하게 말하면 &lt;code&gt;eps&lt;/code&gt; 는 기계의 부동 소수점 시스템에서 인접한 두 숫자 사이의 상대적 간격입니다. 이 숫자는 분명히 시스템에 따라 다릅니다. IEEE 부동 소수점 산술을 지원하는 시스템에서 &lt;code&gt;eps&lt;/code&gt; 는 배정 밀도의 경우 약 2.2204e-16이고 단 정밀도의 경우 1.1921e-07입니다.</target>
        </trans-unit>
        <trans-unit id="102ca545bf54bb9420ae80dfbdfbd829222a6d84" translate="yes" xml:space="preserve">
          <source>More realistically, all of the functions that operate on strings can be used to build the correct field name before it is entered into the data structure.</source>
          <target state="translated">보다 현실적으로, 문자열에서 작동하는 모든 함수는 데이터 구조에 입력되기 전에 올바른 필드 이름을 작성하는 데 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5a037caba04aff4d4a26c59fa2a974c53fe2718a" translate="yes" xml:space="preserve">
          <source>More sophisticated user interaction mechanisms can be obtained using the ui* family of functions, see &lt;a href=&quot;ui-elements#UI-Elements&quot;&gt;UI Elements&lt;/a&gt;.</source>
          <target state="translated">보다 정교한 사용자 상호 작용 메커니즘은 ui * 함수 계열을 사용하여 얻을 수 있습니다 ( &lt;a href=&quot;ui-elements#UI-Elements&quot;&gt;UI 요소&lt;/a&gt; 참조) .</target>
        </trans-unit>
        <trans-unit id="3165c40460d25693c1dd7b0f0fddf03923935e21" translate="yes" xml:space="preserve">
          <source>More that one such class can be specified in a single call. This function may &lt;em&gt;only&lt;/em&gt; be called from a class constructor.</source>
          <target state="translated">한 번의 호출로 하나 이상의 이러한 클래스를 지정할 수 있습니다. 이 함수는 클래스 생성자 &lt;em&gt;에서만&lt;/em&gt; 호출 할 &lt;em&gt;수&lt;/em&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="dd6707e5647be904edea9eb961149fbcec8d0050" translate="yes" xml:space="preserve">
          <source>Most Octave functions are written with vector and array arguments in mind. If you find yourself writing a loop with a very simple operation, chances are that such a function already exists. The following functions occur frequently in vectorized code:</source>
          <target state="translated">대부분의 Octave 함수는 벡터 및 배열 인수를 염두에두고 작성되었습니다. 매우 간단한 조작으로 루프를 작성하면 그러한 기능이 이미 존재할 가능성이 있습니다. 벡터화 된 코드에서 다음 기능이 자주 발생합니다.</target>
        </trans-unit>
        <trans-unit id="0bf261148c83185447937821e5bde1628605666e" translate="yes" xml:space="preserve">
          <source>Most fractional variable.</source>
          <target state="translated">대부분의 분수 변수.</target>
        </trans-unit>
        <trans-unit id="96fdd53d40f764499dd3abc499539a9aae056873" translate="yes" xml:space="preserve">
          <source>Most indexing expressions do not live longer than their parent objects. In rare cases, however, a lazily copied slice outlasts its parent, in which case it becomes orphaned, still occupying unnecessarily more memory than needed. To provide a remedy working in most real cases, Octave checks for orphaned lazy slices at certain situations, when a value is stored into a &quot;permanent&quot; location, such as a named variable or cell or struct element, and possibly economizes them. For example:</source>
          <target state="translated">대부분의 인덱싱 표현식은 부모 개체보다 오래 살지 않습니다. 그러나 드문 경우지만 느리게 복사 된 슬라이스는 부모보다 오래 지속되며,이 경우 고아가되어 여전히 필요한 것보다 더 많은 메모리를 차지합니다. 대부분의 실제 상황에서 해결 방법을 제공하기 위해 Octave는 값이 명명 된 변수 또는 셀 또는 구조체 요소와 같은 &quot;영구적&quot;위치에 저장되어 있고 경제적 인 경우 특정 상황에서 고아 지연 슬라이스를 확인합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5e1837ed07b0adef845b49316a1479e7f76fbb7a" translate="yes" xml:space="preserve">
          <source>Most of the remaining functions described in this section are not patterned after the standard C library. Some are available for compatibility with &lt;small&gt;MATLAB&lt;/small&gt; and others are provided because they are useful.</source>
          <target state="translated">이 섹션에 설명 된 나머지 기능은 대부분 표준 C 라이브러리 이후에 패턴 화되지 않습니다. 일부는 &lt;small&gt;MATLAB&lt;/small&gt; 과의 호환성을 위해 사용 가능 하고 다른 일부는 유용하기 때문에 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="62a0194886176cd72d6007287aa1263d322aab30" translate="yes" xml:space="preserve">
          <source>Most of the same operators and functions for sparse matrices that are available from the Octave interpreter are also available within oct-files. The basic means of extracting a sparse matrix from an &lt;code&gt;octave_value&lt;/code&gt;, and returning it as an &lt;code&gt;octave_value&lt;/code&gt;, can be seen in the following example.</source>
          <target state="translated">옥타브 인터프리터에서 사용할 수있는 희소 행렬에 대한 대부분의 동일한 연산자와 함수는 oct 파일 내에서도 사용할 수 있습니다. 로부터 희소 행렬을 추출하는 기본적인 수단 &lt;code&gt;octave_value&lt;/code&gt; 및로 복귀 &lt;code&gt;octave_value&lt;/code&gt; 는 다음 예에서 알 수있다.</target>
        </trans-unit>
        <trans-unit id="9cc6cffa4096cc4c8425f60ce56d2c3ffa2c5548" translate="yes" xml:space="preserve">
          <source>Most operators (addition, concatenation, and so on) have no effect except to compute a value. If you ignore the value, you might as well not use the operator. An assignment operator is different. It does produce a value, but even if you ignore the value, the assignment still makes itself felt through the alteration of the variable. We call this a &lt;em&gt;side effect&lt;/em&gt;.</source>
          <target state="translated">대부분의 연산자 (더하기, 연결 등)는 값을 계산하는 것 외에는 아무런 영향을 미치지 않습니다. 값을 무시하면 연산자를 사용하지 않을 수도 있습니다. 할당 연산자가 다릅니다. 값을 생성하지만 값을 무시하더라도 할당은 변수의 변경을 통해 여전히 느껴집니다. 우리는 이것을 &lt;em&gt;부작용&lt;/em&gt; 이라고 부릅니다 .</target>
        </trans-unit>
        <trans-unit id="a9186e739eec375e8b772859ab85a97440b4125c" translate="yes" xml:space="preserve">
          <source>Mouse click events: &lt;code&gt;evt&lt;/code&gt; is a class &lt;code&gt;double&lt;/code&gt; value: 1 for left, 2 for middle, and 3 for right click.</source>
          <target state="translated">마우스 클릭 이벤트 : &lt;code&gt;evt&lt;/code&gt; 는 클래스 &lt;code&gt;double&lt;/code&gt; 값입니다. 왼쪽은 1, 가운데는 2, 오른쪽 클릭은 3입니다.</target>
        </trans-unit>
        <trans-unit id="cca622d465d11d8a5431e5dd0f0cfbe01d410767" translate="yes" xml:space="preserve">
          <source>Move &amp;lsquo;down&amp;rsquo; through the history list.</source>
          <target state="translated">히스토리 목록에서 '아래로'이동하십시오.</target>
        </trans-unit>
        <trans-unit id="f35df2487f0c4f4b174fc091ed9cd896679d8816" translate="yes" xml:space="preserve">
          <source>Move &amp;lsquo;up&amp;rsquo; through the history list.</source>
          <target state="translated">히스토리 목록에서 '위로'이동하십시오.</target>
        </trans-unit>
        <trans-unit id="fcb7ea50eacbfbafbbf342f2615fca27b76796a3" translate="yes" xml:space="preserve">
          <source>Move a figure specified by figure handle &lt;var&gt;h&lt;/var&gt; to a position on the screen defined by &lt;var&gt;pos&lt;/var&gt;.</source>
          <target state="translated">그림 핸들 &lt;var&gt;h&lt;/var&gt; 로 지정된 그림 을 &lt;var&gt;pos&lt;/var&gt; 로 정의 된 화면의 위치로 이동하십시오 .</target>
        </trans-unit>
        <trans-unit id="f03abbd943590e5b676ac24ffec0cb3457a839fb" translate="yes" xml:space="preserve">
          <source>Move back one character.</source>
          <target state="translated">한 문자 뒤로 이동하십시오.</target>
        </trans-unit>
        <trans-unit id="4b202f08f962725726cf136388f4e14e523a12a8" translate="yes" xml:space="preserve">
          <source>Move backward a word.</source>
          <target state="translated">한 단어 뒤로 이동하십시오.</target>
        </trans-unit>
        <trans-unit id="754d167675ac90bee540cc59026b7aa3fd43d8b6" translate="yes" xml:space="preserve">
          <source>Move forward a word.</source>
          <target state="translated">단어를 앞으로 이동하십시오.</target>
        </trans-unit>
        <trans-unit id="9b8cd052c7c7c6b3baf215b9ba57515984535bce" translate="yes" xml:space="preserve">
          <source>Move forward one character.</source>
          <target state="translated">한 문자 앞으로 이동하십시오.</target>
        </trans-unit>
        <trans-unit id="ecf018bcb16a54697edfab272e407ec8e95e073e" translate="yes" xml:space="preserve">
          <source>Move the camera &lt;var&gt;phi&lt;/var&gt; degrees up and &lt;var&gt;theta&lt;/var&gt; degrees to the right, as if it were in an orbit around its target. Example:</source>
          <target state="translated">마치 카메라를 대상 주위의 궤도에있는 것처럼 카메라 &lt;var&gt;phi&lt;/var&gt; 도를 위로, &lt;var&gt;theta&lt;/var&gt; 도를 오른쪽으로 이동하십시오 . 예:</target>
        </trans-unit>
        <trans-unit id="f19af0a930df6e6a8c874bddce91630dcb05b1cd" translate="yes" xml:space="preserve">
          <source>Move the camera and adjust its properties to look at objects.</source>
          <target state="translated">카메라를 움직이고 속성을 조정하여 물체를 봅니다.</target>
        </trans-unit>
        <trans-unit id="ab49f460987dc68a09db402a436a805213621056" translate="yes" xml:space="preserve">
          <source>Move the file pointer to the beginning of the file specified by file descriptor &lt;var&gt;fid&lt;/var&gt;.</source>
          <target state="translated">파일 디스크립터 &lt;var&gt;fid&lt;/var&gt; 로 지정된 파일의 시작 부분으로 파일 포인터를 이동하십시오 .</target>
        </trans-unit>
        <trans-unit id="b5e996f5d7888265eda971ccf52c60b93c91d15b" translate="yes" xml:space="preserve">
          <source>Move the source file or directory &lt;var&gt;f1&lt;/var&gt; to the destination &lt;var&gt;f2&lt;/var&gt;.</source>
          <target state="translated">소스 파일 또는 디렉토리 &lt;var&gt;f1&lt;/var&gt; 을 대상 &lt;var&gt;f2&lt;/var&gt; 로 이동하십시오 .</target>
        </trans-unit>
        <trans-unit id="45c0cf91d70e9f1ebf0f30e518c4cf144f2ecbbf" translate="yes" xml:space="preserve">
          <source>Move to the end of the input history, i.e., the line you are entering!</source>
          <target state="translated">입력 기록의 끝, 즉 입력하는 줄로 이동하십시오!</target>
        </trans-unit>
        <trans-unit id="2a6ce964c353d7fc77f5427c386721059f89e58e" translate="yes" xml:space="preserve">
          <source>Move to the end of the line.</source>
          <target state="translated">줄의 끝으로 이동하십시오.</target>
        </trans-unit>
        <trans-unit id="b197771ca8ea11c5879847015686b2f25546c56c" translate="yes" xml:space="preserve">
          <source>Move to the first line in the history.</source>
          <target state="translated">히스토리의 첫 번째 줄로 이동하십시오.</target>
        </trans-unit>
        <trans-unit id="4c0251a5384fa6d692664ca6c0665abebb12594c" translate="yes" xml:space="preserve">
          <source>Move to the start of the line.</source>
          <target state="translated">줄의 시작 부분으로 이동하십시오.</target>
        </trans-unit>
        <trans-unit id="cf2bcb058d3d8b59bd1c1a7704f3bf2cfe5d6a38" translate="yes" xml:space="preserve">
          <source>Mu-law values are 8-bit unsigned integers. Linear values use &lt;var&gt;n&lt;/var&gt;-bit signed integers or floating point values in the range -1 &amp;le; &lt;var&gt;y&lt;/var&gt; &amp;le; 1 if &lt;var&gt;n&lt;/var&gt; is 0.</source>
          <target state="translated">mu-law 값은 8 비트 부호없는 정수입니다. 선형 값 은 &lt;var&gt;n&lt;/var&gt; 이 0 인 경우 -1 &amp;le; &lt;var&gt;y&lt;/var&gt; &amp;le; 1 범위의 &lt;var&gt;n&lt;/var&gt; 비트 부호있는 정수 또는 부동 소수점 값을 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="d1880fa68b080d6cd122ae8b1205d93828b5de43" translate="yes" xml:space="preserve">
          <source>Mu-law values use 8-bit unsigned integers. Linear values use &lt;var&gt;n&lt;/var&gt;-bit signed integers or floating point values in the range -1 &amp;le; &lt;var&gt;x&lt;/var&gt; &amp;le; 1 if &lt;var&gt;n&lt;/var&gt; is 0.</source>
          <target state="translated">mu-law 값은 8 비트 부호없는 정수를 사용합니다. 선형 값 은 &lt;var&gt;n&lt;/var&gt; 이 0 인 경우 -1 &amp;le; &lt;var&gt;x&lt;/var&gt; &amp;le; 1 범위의 &lt;var&gt;n&lt;/var&gt; 비트 부호있는 정수 또는 부동 소수점 값을 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="6e60b1686c76f6145b7e31656665eb375b134a58" translate="yes" xml:space="preserve">
          <source>Much of the geometry code in Octave is based on the Qhull library&lt;a href=&quot;#FOOT12&quot; name=&quot;DOCF12&quot;&gt;&lt;sup&gt;12&lt;/sup&gt;&lt;/a&gt;. Some of the documentation for Qhull, particularly for the options that can be passed to &lt;code&gt;delaunay&lt;/code&gt;, &lt;code&gt;voronoi&lt;/code&gt; and &lt;code&gt;convhull&lt;/code&gt;, etc., is relevant to Octave users.</source>
          <target state="translated">Octave의 많은 지오메트리 코드는 Qhull 라이브러리 &lt;a href=&quot;#FOOT12&quot; name=&quot;DOCF12&quot;&gt;&lt;sup&gt;12를&lt;/sup&gt;&lt;/a&gt; 기반으로합니다 . 특히에 전달 될 수있는 옵션에 대한 Qhull에 대한 문서의 일부, &lt;code&gt;delaunay&lt;/code&gt; , &lt;code&gt;voronoi&lt;/code&gt; 와 &lt;code&gt;convhull&lt;/code&gt; 등, 옥타브 사용자에게 해당됩니다.</target>
        </trans-unit>
        <trans-unit id="5348b693bb31bab18cea3d4c910c8e198aa9ad27" translate="yes" xml:space="preserve">
          <source>Multi-dimensional Interpolation</source>
          <target state="translated">다차원 보간</target>
        </trans-unit>
        <trans-unit id="2e23dcb20c51eb3ff0cdae12de1e2fd144e54e5a" translate="yes" xml:space="preserve">
          <source>Multi-dimensional indexed images (of size MxNx1xK) are also supported.</source>
          <target state="translated">MxNx1xK 크기의 다차원 인덱스 이미지도 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="a756927127fc6bb4e513232ab3d68657066ff38a" translate="yes" xml:space="preserve">
          <source>Multi-dimensional indexed images (of size MxNx3xK) are also supported, both via a single input (&lt;var&gt;rgb&lt;/var&gt;) or its three color channels as separate variables.</source>
          <target state="translated">MxNx3xK 크기의 다차원 인덱스 이미지도 단일 입력 ( &lt;var&gt;rgb&lt;/var&gt; ) 또는 세 가지 색상 채널을 통해 개별 변수로 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="3f5f0448a9eed7ed475a1bb88cceab621fcae1b1" translate="yes" xml:space="preserve">
          <source>Multiple &lt;var&gt;name&lt;/var&gt;/&lt;var&gt;value&lt;/var&gt; pairs can be specified. Alternatively, a cell array of &lt;var&gt;names&lt;/var&gt; and a corresponding cell array of &lt;var&gt;values&lt;/var&gt; can be specified.</source>
          <target state="translated">여러 개의 &lt;var&gt;name&lt;/var&gt; / &lt;var&gt;value&lt;/var&gt; 쌍을 지정할 수 있습니다. 또는 &lt;var&gt;names&lt;/var&gt; 의 셀형 배열 과 해당하는 &lt;var&gt;values&lt;/var&gt; 셀형 배열을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5b69994c62c28e56cf9cb07f48e1b85923601a69" translate="yes" xml:space="preserve">
          <source>Multiple &lt;var&gt;name&lt;/var&gt;/&lt;var&gt;value&lt;/var&gt; pairs can be specified. Alternatively, a cell array of &lt;var&gt;names&lt;/var&gt; and a corresponding cell array of &lt;var&gt;values&lt;/var&gt; can be specified. Details on obtaining a list of valid application data properties can be found in &lt;a href=&quot;#XREFgetappdata&quot;&gt;getappdata&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3cf8cdd574e24662f082f0c9099612cc66b9cd76" translate="yes" xml:space="preserve">
          <source>Multiple Plot Windows</source>
          <target state="translated">다중 플롯 창</target>
        </trans-unit>
        <trans-unit id="43663f13d2b55b44c2db9342c79526a5392fc70c" translate="yes" xml:space="preserve">
          <source>Multiple Plots on One Page</source>
          <target state="translated">한 페이지에 여러 플롯</target>
        </trans-unit>
        <trans-unit id="a025ceee7b8b1c711d382e33043a2b3de0e6408b" translate="yes" xml:space="preserve">
          <source>Multiple Return Values</source>
          <target state="translated">여러 반환 값</target>
        </trans-unit>
        <trans-unit id="7b48a32f86a981a7c7025eac623837c90fbc5b29" translate="yes" xml:space="preserve">
          <source>Multiple functions in one script file.</source>
          <target state="translated">하나의 스크립트 파일에 여러 기능이 있습니다.</target>
        </trans-unit>
        <trans-unit id="069b6f4c0a3769570ec15dce4edc9cff247407c8" translate="yes" xml:space="preserve">
          <source>Multiple locations can be specified if &lt;var&gt;x&lt;/var&gt;, &lt;var&gt;y&lt;/var&gt;, (&lt;var&gt;z&lt;/var&gt;) are vectors. Multiple strings can be specified with a character matrix or a cell array of strings.</source>
          <target state="translated">&lt;var&gt;x&lt;/var&gt; , &lt;var&gt;y&lt;/var&gt; , ( &lt;var&gt;z&lt;/var&gt; )가 벡터 인 경우 여러 위치를 지정할 수 있습니다 . 문자 행렬이나 문자열의 셀형 배열로 여러 문자열을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="052e9a188e86407000b60071f8651ce1aca3e437" translate="yes" xml:space="preserve">
          <source>Multiple name and value pair arguments may be specified in any order as &lt;var&gt;name1&lt;/var&gt;, &lt;var&gt;value1&lt;/var&gt;, &lt;var&gt;name2&lt;/var&gt;, &lt;var&gt;value2&lt;/var&gt;, etc.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65cc39417765873c88cb9ba73e1e24f180f53369" translate="yes" xml:space="preserve">
          <source>Multiple property-value pairs may also be specified, but they must appear in pairs. These arguments are applied to the line objects drawn by &lt;code&gt;plot&lt;/code&gt;.</source>
          <target state="translated">여러 속성-값 쌍을 지정할 수도 있지만 쌍으로 나타나야합니다. 이 인수는 &lt;code&gt;plot&lt;/code&gt; 으로 그린 ​​선 객체에 적용됩니다 .</target>
        </trans-unit>
        <trans-unit id="438aaf0bddccb37c5310a918cd462e5dcec972ad" translate="yes" xml:space="preserve">
          <source>Multiple property-value pairs may be specified for the dialog object, but they must appear in pairs.</source>
          <target state="translated">대화 상자 객체에 여러 속성-값 쌍을 지정할 수 있지만 쌍으로 나타나야합니다.</target>
        </trans-unit>
        <trans-unit id="a265bbf11fbbdfe36a469c8b3ebd39d7bf6a8280" translate="yes" xml:space="preserve">
          <source>Multiple property-value pairs may be specified for the dialog object, but they must appear in pairs. The full list of properties is documented at &lt;a href=&quot;figure-properties#Figure-Properties&quot;&gt;Figure Properties&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75465b8499ef322418a8855f9d7d749bfca2df1b" translate="yes" xml:space="preserve">
          <source>Multiple property-value pairs may be specified for the figure object, but they must appear in pairs.</source>
          <target state="translated">그림 개체에 여러 속성-값 쌍을 지정할 수 있지만 쌍으로 나타나야합니다.</target>
        </trans-unit>
        <trans-unit id="55103752da452540e82ed74c54517346d800094c" translate="yes" xml:space="preserve">
          <source>Multiple property-value pairs may be specified for the line object, but they must appear in pairs.</source>
          <target state="translated">선 객체에 대해 여러 속성-값 쌍을 지정할 수 있지만 쌍으로 나타나야합니다.</target>
        </trans-unit>
        <trans-unit id="0571e78fa1b27894fc2a844058ac73168b601488" translate="yes" xml:space="preserve">
          <source>Multiple property-value pairs may be specified which will affect the line objects drawn by &lt;code&gt;plot3&lt;/code&gt;. If the &lt;var&gt;fmt&lt;/var&gt; argument is supplied it will format the line objects in the same manner as &lt;code&gt;plot&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;plot3&lt;/code&gt; 으로 그린 ​​선 객체에 영향을주는 여러 속성 값 쌍을 지정할 수 있습니다 . 경우] &lt;var&gt;fmt&lt;/var&gt; 인수가 공급되고 그와 동일한 방식으로 광고 객체를 포맷한다 &lt;code&gt;plot&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ad709598315d3d73d89311273852e6c57f11c24c" translate="yes" xml:space="preserve">
          <source>Multiple property-value pairs may be specified which will affect the line objects drawn by &lt;code&gt;plot3&lt;/code&gt;. If the &lt;var&gt;fmt&lt;/var&gt; argument is supplied it will format the line objects in the same manner as &lt;code&gt;plot&lt;/code&gt;. The full list of properties is documented at &lt;a href=&quot;line-properties#Line-Properties&quot;&gt;Line Properties&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b553b6eb10c7c7b0b009b69d8ca8446579adcf1" translate="yes" xml:space="preserve">
          <source>Multiple property-value pairs may be specified, but they must appear in pairs. These arguments are applied to the line objects drawn by &lt;code&gt;plot&lt;/code&gt;. Useful properties to modify are &lt;code&gt;&quot;linestyle&quot;&lt;/code&gt;, &lt;code&gt;&quot;linewidth&quot;&lt;/code&gt;, &lt;code&gt;&quot;color&quot;&lt;/code&gt;, &lt;code&gt;&quot;marker&quot;&lt;/code&gt;, &lt;code&gt;&quot;markersize&quot;&lt;/code&gt;, &lt;code&gt;&quot;markeredgecolor&quot;&lt;/code&gt;, &lt;code&gt;&quot;markerfacecolor&quot;&lt;/code&gt;. See &lt;a href=&quot;line-properties#Line-Properties&quot;&gt;Line Properties&lt;/a&gt;.</source>
          <target state="translated">여러 속성-값 쌍을 지정할 수 있지만 쌍으로 나타나야합니다. 이 인수는 다음에 의해 그려진 선 객체에 적용됩니다 &lt;code&gt;plot&lt;/code&gt; . 수정할 수있는 유용한 속성은 &lt;code&gt;&quot;linestyle&quot;&lt;/code&gt; , &lt;code&gt;&quot;linewidth&quot;&lt;/code&gt; , &lt;code&gt;&quot;color&quot;&lt;/code&gt; , &lt;code&gt;&quot;marker&quot;&lt;/code&gt; , &lt;code&gt;&quot;markersize&quot;&lt;/code&gt; , &lt;code&gt;&quot;markeredgecolor&quot;&lt;/code&gt; , &lt;code&gt;&quot;markerfacecolor&quot;&lt;/code&gt; . &lt;a href=&quot;line-properties#Line-Properties&quot;&gt;라인 속성을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="2575869c0308282400d590be994be06fd643ed41" translate="yes" xml:space="preserve">
          <source>Multiple property-value pairs may be specified, but they must appear in pairs. These arguments are applied to the line objects drawn by &lt;code&gt;plot&lt;/code&gt;. Useful properties to modify are &lt;code&gt;&quot;linestyle&quot;&lt;/code&gt;, &lt;code&gt;&quot;linewidth&quot;&lt;/code&gt;, &lt;code&gt;&quot;color&quot;&lt;/code&gt;, &lt;code&gt;&quot;marker&quot;&lt;/code&gt;, &lt;code&gt;&quot;markersize&quot;&lt;/code&gt;, &lt;code&gt;&quot;markeredgecolor&quot;&lt;/code&gt;, &lt;code&gt;&quot;markerfacecolor&quot;&lt;/code&gt;. The full list of properties is documented at &lt;a href=&quot;line-properties#Line-Properties&quot;&gt;Line Properties&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4bdfe78f5a9a610b22edadbb462e156148b4430e" translate="yes" xml:space="preserve">
          <source>Multiple property/value pairs for the underlying patch object may be specified, but they must appear in pairs.</source>
          <target state="translated">기본 패치 객체에 대해 여러 속성 / 값 쌍을 지정할 수 있지만 쌍으로 나타나야합니다.</target>
        </trans-unit>
        <trans-unit id="6973bee8e5c0a984497f158eb5694b4051176c60" translate="yes" xml:space="preserve">
          <source>Multiple property/value pairs for the underlying patch object may be specified, but they must appear in pairs. The full list of properties is documented at &lt;a href=&quot;patch-properties#Patch-Properties&quot;&gt;Patch Properties&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="644852d4dc88a7557c27e489f1ebff5ccea9f0fb" translate="yes" xml:space="preserve">
          <source>Multiple property/value pairs may be specified for the hggroup, but they must appear in pairs.</source>
          <target state="translated">hggroup에 여러 속성 / 값 쌍을 지정할 수 있지만 쌍으로 나타나야합니다.</target>
        </trans-unit>
        <trans-unit id="c9bdca40f6685fc2f6856da859b39d2576315816" translate="yes" xml:space="preserve">
          <source>Multiple property/value pairs may be specified for the hggroup, but they must appear in pairs. The full list of properties is documented at &lt;a href=&quot;axes-properties#Axes-Properties&quot;&gt;Axes Properties&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="308b37f1dd35508686a38110aa76f0f9c0fbac9c" translate="yes" xml:space="preserve">
          <source>Multiple property/value pairs may be specified for the image object, but they must appear in pairs.</source>
          <target state="translated">이미지 객체에 여러 속성 / 값 쌍을 지정할 수 있지만 쌍으로 나타나야합니다.</target>
        </trans-unit>
        <trans-unit id="968be4588f05c376e82696740da992c6b2ac5181" translate="yes" xml:space="preserve">
          <source>Multiple property/value pairs may be specified, but they must appear in pairs.</source>
          <target state="translated">여러 속성 / 값 쌍을 지정할 수 있지만 쌍으로 나타나야합니다.</target>
        </trans-unit>
        <trans-unit id="0b2366ac78624b342b504848a592da8f8cd96eee" translate="yes" xml:space="preserve">
          <source>Multiple property/value pairs may be specified, but they must appear in pairs. The full list of properties is documented at &lt;a href=&quot;line-properties#Line-Properties&quot;&gt;Line Properties&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0505491c23770efb1105bc1cfc1bb5be7ec5a815" translate="yes" xml:space="preserve">
          <source>Multiplication and division by diagonal matrices work efficiently also when combined with sparse matrices, i.e., &lt;code&gt;D*S&lt;/code&gt;, where &lt;var&gt;D&lt;/var&gt; is a diagonal matrix and &lt;var&gt;S&lt;/var&gt; is a sparse matrix scales the rows of the sparse matrix and returns a sparse matrix. The expressions &lt;code&gt;S*D&lt;/code&gt;, &lt;code&gt;D\S&lt;/code&gt;, &lt;code&gt;S/D&lt;/code&gt; work analogically.</source>
          <target state="translated">대각 행렬에 의한 곱셈과 나눗셈은 희소 행렬과 결합 될 때에도 효율적으로 작동합니다. &lt;code&gt;D*S&lt;/code&gt; . 여기서 &lt;var&gt;D&lt;/var&gt; 는 대각 행렬이고 &lt;var&gt;S&lt;/var&gt; 는 희소 행렬은 희소 행렬의 행을 스케일하고 희소 행렬을 반환합니다. &lt;code&gt;S*D&lt;/code&gt; , &lt;code&gt;D\S&lt;/code&gt; , &lt;code&gt;S/D&lt;/code&gt; 표현식은 유사하게 작동합니다.</target>
        </trans-unit>
        <trans-unit id="91b1ce45d8127b60ce6dfcfbf6b55e4bb183ec1c" translate="yes" xml:space="preserve">
          <source>Multiplication and division by permutation matrices works efficiently also when combined with sparse matrices, i.e., &lt;code&gt;P*S&lt;/code&gt;, where &lt;var&gt;P&lt;/var&gt; is a permutation matrix and &lt;var&gt;S&lt;/var&gt; is a sparse matrix permutes the rows of the sparse matrix and returns a sparse matrix. The expressions &lt;code&gt;S*P&lt;/code&gt;, &lt;code&gt;P\S&lt;/code&gt;, &lt;code&gt;S/P&lt;/code&gt; work analogically.</source>
          <target state="translated">순열 행렬에 의한 곱셈과 나눗셈은 희소 행렬과 결합 할 때에도 효율적으로 작동합니다. &lt;code&gt;P*S&lt;/code&gt; . 여기서 &lt;var&gt;P&lt;/var&gt; 는 순열 행렬이고 &lt;var&gt;S&lt;/var&gt; 는 희소 행렬은 희소 행렬의 행을 순열 하고 희소 행렬을 반환합니다. 표현식 &lt;code&gt;S*P&lt;/code&gt; , &lt;code&gt;P\S&lt;/code&gt; , &lt;code&gt;S/P&lt;/code&gt; 는 유사하게 작동합니다.</target>
        </trans-unit>
        <trans-unit id="af8d41489ec27c3890462d150897359d28431b22" translate="yes" xml:space="preserve">
          <source>Multiplying any row or column by -1 and the matrix will remain a Hadamard matrix.</source>
          <target state="translated">행이나 열에 -1을 곱하면 행렬은하다 마드 행렬로 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="b01d1caf864e26116e2219fa66895aad0a279d68" translate="yes" xml:space="preserve">
          <source>Must be set to &lt;code&gt;&quot;fminsearch&quot;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&quot;fminsearch&quot;&lt;/code&gt; 로 설정해야합니다 .</target>
        </trans-unit>
        <trans-unit id="b51a60734da64be0e618bacbea2865a8a7dcd669" translate="yes" xml:space="preserve">
          <source>N</source>
          <target state="translated">N</target>
        </trans-unit>
        <trans-unit id="8103c240a2f6a7e0c1b4e8b2be6c801900bd95be" translate="yes" xml:space="preserve">
          <source>N. Bleistein and R.A. Handelsman,</source>
          <target state="translated">N. Bleistein과 RA Handelsman,</target>
        </trans-unit>
        <trans-unit id="ebb9af4e80cf0041bea64b676c53303b5638ef2a" translate="yes" xml:space="preserve">
          <source>N.J. Higham and F. Tisseur,</source>
          <target state="translated">뉴저지 Higham과 F. Tisseur,</target>
        </trans-unit>
        <trans-unit id="3feda0153eee1380b496298450dc5a74324eb8c1" translate="yes" xml:space="preserve">
          <source>NA</source>
          <target state="translated">NA</target>
        </trans-unit>
        <trans-unit id="0ce6d6875bbb1adc8819edf49ce2d62dcb76fc84" translate="yes" xml:space="preserve">
          <source>NA (&amp;hellip;, class)</source>
          <target state="translated">NA (&amp;hellip;, 수업)</target>
        </trans-unit>
        <trans-unit id="a4d6c2a83ea4e5ea71d12d230bba8a67aa13cd71" translate="yes" xml:space="preserve">
          <source>NA (n)</source>
          <target state="translated">NA (n)</target>
        </trans-unit>
        <trans-unit id="ec82cfa239228493e6e10899c0deb8027ca470b7" translate="yes" xml:space="preserve">
          <source>NA (n, m)</source>
          <target state="translated">NA (n, m)</target>
        </trans-unit>
        <trans-unit id="4b0ca3b6e7ca0b78b19877e7b0109e342475939b" translate="yes" xml:space="preserve">
          <source>NA (n, m, k, &amp;hellip;)</source>
          <target state="translated">NA (n, m, k,&amp;hellip;)</target>
        </trans-unit>
        <trans-unit id="33043aa6a7fb1a5929803e38176815992b886d51" translate="yes" xml:space="preserve">
          <source>NA values are also considered NaN values. For example:</source>
          <target state="translated">NA 값은 NaN 값으로 간주됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9f621eb5fd3bcb2fa5c7bd228c9b1ad42edc46c8" translate="yes" xml:space="preserve">
          <source>NEWS</source>
          <target state="translated">NEWS</target>
        </trans-unit>
        <trans-unit id="f7fd9c68f804acda665d2ab082217bb1583318f2" translate="yes" xml:space="preserve">
          <source>NaN</source>
          <target state="translated">NaN</target>
        </trans-unit>
        <trans-unit id="86e83de142dd364b57c91ac75183da4843f81b90" translate="yes" xml:space="preserve">
          <source>NaN (&amp;hellip;, class)</source>
          <target state="translated">NaN (&amp;hellip;, 수업)</target>
        </trans-unit>
        <trans-unit id="b92d53e50e4d43391f346830614dcd62e3e46ac3" translate="yes" xml:space="preserve">
          <source>NaN (n)</source>
          <target state="translated">NaN (n)</target>
        </trans-unit>
        <trans-unit id="c06c99cd541aa0eb30a91dc8f92c80bb25e90474" translate="yes" xml:space="preserve">
          <source>NaN (n, m)</source>
          <target state="translated">NaN (n, m)</target>
        </trans-unit>
        <trans-unit id="224ad40af06995ff0ec6ab150861bc5a55a54f09" translate="yes" xml:space="preserve">
          <source>NaN (n, m, k, &amp;hellip;)</source>
          <target state="translated">NaN (n, m, k,&amp;hellip;)</target>
        </trans-unit>
        <trans-unit id="f816faac555bafa32e94381477cb6417d6430b59" translate="yes" xml:space="preserve">
          <source>NaN is the result of operations which do not produce a well defined numerical result. Common operations which produce a NaN are arithmetic with infinity (Inf - Inf), zero divided by zero (0/0), and any operation involving another NaN value (5 + NaN).</source>
          <target state="translated">NaN은 잘 정의 된 수치 결과를 생성하지 않는 연산의 결과입니다. NaN을 생성하는 일반적인 연산은 무한대 (Inf-Inf), 0을 0으로 나눈 값 (0/0) 및 다른 NaN 값 (5 + NaN)과 관련된 연산입니다.</target>
        </trans-unit>
        <trans-unit id="5fda41a35f872653f44450293bce4471aad17ca5" translate="yes" xml:space="preserve">
          <source>NaN values are treated as being greater than any other value and are sorted to the end of the list.</source>
          <target state="translated">NaN 값은 다른 값보다 큰 것으로 취급되어 목록 끝까지 정렬됩니다.</target>
        </trans-unit>
        <trans-unit id="709a23220f2c3d64d1e1d6d18c4d5280f8d82fca" translate="yes" xml:space="preserve">
          <source>Name</source>
          <target state="translated">Name</target>
        </trans-unit>
        <trans-unit id="7c703d97db75d2561db5e8826df701b25f37c98b" translate="yes" xml:space="preserve">
          <source>Name and version of the software or firmware of the camera or image input device used to generate the image.</source>
          <target state="translated">이미지 생성에 사용 된 카메라 또는 이미지 입력 ​​장치의 소프트웨어 또는 펌웨어의 이름과 버전.</target>
        </trans-unit>
        <trans-unit id="5c03300bc66637b889511b790544873bbe80cf03" translate="yes" xml:space="preserve">
          <source>Name of a vector in the current base workspace to use as x data.</source>
          <target state="translated">x 데이터로 사용할 현재 기본 작업 공간의 벡터 이름입니다.</target>
        </trans-unit>
        <trans-unit id="91b0e56b88edaade8237ab6836ab4d10ff5875c7" translate="yes" xml:space="preserve">
          <source>Name of a vector in the current base workspace to use as y data.</source>
          <target state="translated">y 데이터로 사용할 현재 기본 작업 공간의 벡터 이름입니다.</target>
        </trans-unit>
        <trans-unit id="3440a66b41662a78e168bc7e08e6bd50ec72f107" translate="yes" xml:space="preserve">
          <source>Name of a vector in the current base workspace to use as z data.</source>
          <target state="translated">z 데이터로 사용할 현재 기본 작업 공간의 벡터 이름입니다.</target>
        </trans-unit>
        <trans-unit id="b4707a0d46d7f94b451c43db3a1ab6c2377a48d4" translate="yes" xml:space="preserve">
          <source>Name of font used for text rendering. When setting this property, the text rendering engine will search for a matching font in your system. If none is found then text is rendered using a default sans serif font (same as the default &lt;code&gt;&quot;*&quot;&lt;/code&gt; value).</source>
          <target state="translated">텍스트 렌더링에 사용되는 글꼴 이름입니다. 이 속성을 설정하면 텍스트 렌더링 엔진이 시스템에서 일치하는 글꼴을 검색합니다. 찾을 수없는 경우 기본 sans serif 글꼴 (기본 &lt;code&gt;&quot;*&quot;&lt;/code&gt; 값 과 동일)을 사용하여 텍스트가 렌더링됩니다 .</target>
        </trans-unit>
        <trans-unit id="5cd53fbf82a5c921bb324eaf9549067ec85d65bb" translate="yes" xml:space="preserve">
          <source>Name of the audio file.</source>
          <target state="translated">오디오 파일의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="a5cd32a941d96dd33adae23b12bbc3237bcfab16" translate="yes" xml:space="preserve">
          <source>Name of the camera owner, photographer or image creator.</source>
          <target state="translated">카메라 소유자, 사진 작가 또는 이미지 제작자의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="ed6315d50ec82545ce6bc510f8d3d915833b4ece" translate="yes" xml:space="preserve">
          <source>Name of the mouse pointer shape associated with the canvas of the figure. When &lt;code&gt;pointer&lt;/code&gt; is &quot;custom&quot;, the shape is determined by the &lt;code&gt;pointershapecdata&lt;/code&gt; property.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dbc76c09232a27e737ef03ec160d0547bc322154" translate="yes" xml:space="preserve">
          <source>Name of the package.</source>
          <target state="translated">패키지 이름</target>
        </trans-unit>
        <trans-unit id="6842e62c791d8e217b935d3bbe2012bf33f1e6bb" translate="yes" xml:space="preserve">
          <source>Name of the paper used for printed output. Setting &lt;code&gt;papertype&lt;/code&gt; also changes &lt;code&gt;papersize&lt;/code&gt;, while maintaining consistency with the &lt;code&gt;paperorientation&lt;/code&gt; property.</source>
          <target state="translated">인쇄 출력에 사용되는 용지 이름. &lt;code&gt;papertype&lt;/code&gt; 을 설정 하면 &lt;code&gt;paperorientation&lt;/code&gt; 속성 과 일관성을 유지하면서 &lt;code&gt;papersize&lt;/code&gt; 도 변경 됩니다.</target>
        </trans-unit>
        <trans-unit id="0c7c5d3ba2ba568d2a5726a14fbaac7573a80e31" translate="yes" xml:space="preserve">
          <source>Name to be displayed in the figure title bar. The name is displayed to the right of any title determined by the &lt;code&gt;numbertitle&lt;/code&gt; property.</source>
          <target state="translated">그림 제목 표시 줄에 표시 될 이름입니다. 이름은 &lt;code&gt;numbertitle&lt;/code&gt; 속성에 의해 결정된 제목의 오른쪽에 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="63e3f44a6be846f5cbcdfc26533ca52626df2fde" translate="yes" xml:space="preserve">
          <source>Names and values of header fields, specified as an m-by-2 array of strings or cell array of character vectors to add to the HTTP request header. HeaderFields{i,1} is the name of a field and HeaderFields{i,2} is its value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e94de1f5e234baf66c12cf648757c06702b6ebf0" translate="yes" xml:space="preserve">
          <source>Negation.</source>
          <target state="translated">Negation.</target>
        </trans-unit>
        <trans-unit id="5eb21879f66ab1c7bed8ff054645faa8f4b87528" translate="yes" xml:space="preserve">
          <source>Negative values of &lt;var&gt;d&lt;/var&gt; represent diagonals below the main diagonal, and positive values of &lt;var&gt;d&lt;/var&gt; diagonals above the main diagonal.</source>
          <target state="translated">&lt;var&gt;d&lt;/var&gt; 의 음수 값은 주 대각선 아래의 대각선을 나타내며 기본 대각선 위 의 &lt;var&gt;d&lt;/var&gt; 대각선 의 양수 값을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="6ceba4234e15aa5ab2bd2d8b94c4dcba7693959f" translate="yes" xml:space="preserve">
          <source>Nested Functions</source>
          <target state="translated">중첩 함수</target>
        </trans-unit>
        <trans-unit id="cc679e90d5ed1694e23c1d99247568923aa26cad" translate="yes" xml:space="preserve">
          <source>Nested functions are similar to subfunctions in that only the main function is visible outside the file. However, they also allow for child functions to access the local variables in their parent function. This shared access mimics using a global variable to share information &amp;mdash; but a global variable which is not visible to the rest of Octave. As a programming strategy, sharing data this way can create code which is difficult to maintain. It is recommended to use subfunctions in place of nested functions when possible.</source>
          <target state="translated">중첩 함수는 주 함수 만 파일 외부에서 볼 수 있다는 점에서 하위 함수와 유사합니다. 그러나 하위 함수가 상위 함수의 로컬 변수에 액세스 할 수도 있습니다. 이 공유 액세스는 전역 변수를 사용하여 정보를 공유하지만 나머지 Octave에서는 보이지 않는 전역 변수를 모방합니다. 프로그래밍 전략으로서 이런 방식으로 데이터를 공유하면 유지하기 어려운 코드가 생성 될 수 있습니다. 가능하면 중첩 함수 대신 하위 함수를 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="3d3fc7f4a0a1ca25a6fb86aa1f5a1e4e3a6b9458" translate="yes" xml:space="preserve">
          <source>Nested functions.</source>
          <target state="translated">중첩 함수.</target>
        </trans-unit>
        <trans-unit id="f484ae1b450d6d1df5329e1917780d81a0d5705f" translate="yes" xml:space="preserve">
          <source>Networking Utilities</source>
          <target state="translated">네트워킹 유틸리티</target>
        </trans-unit>
        <trans-unit id="267429fbf99e3675f3f89422c90011d4cf73259e" translate="yes" xml:space="preserve">
          <source>Nevertheless, there are several other functions for concatenating string objects which can be useful in specific circumstances: &lt;code&gt;char&lt;/code&gt;, &lt;code&gt;strvcat&lt;/code&gt;, &lt;code&gt;strcat&lt;/code&gt;, and &lt;code&gt;cstrcat&lt;/code&gt;. Finally, the general purpose concatenation functions can be used: see &lt;a href=&quot;rearranging-matrices#XREFcat&quot;&gt;cat&lt;/a&gt;, &lt;a href=&quot;rearranging-matrices#XREFhorzcat&quot;&gt;horzcat&lt;/a&gt;, and &lt;a href=&quot;rearranging-matrices#XREFvertcat&quot;&gt;vertcat&lt;/a&gt;.</source>
          <target state="translated">그럼에도 불구하고 특정 상황에서 유용 할 수있는 문자열 객체를 연결하기위한 몇 가지 다른 함수가 있습니다 : &lt;code&gt;char&lt;/code&gt; , &lt;code&gt;strvcat&lt;/code&gt; , &lt;code&gt;strcat&lt;/code&gt; 및 &lt;code&gt;cstrcat&lt;/code&gt; . 마지막으로 범용 연결 기능을 사용할 수 있습니다 ( &lt;a href=&quot;rearranging-matrices#XREFcat&quot;&gt;cat&lt;/a&gt; , &lt;a href=&quot;rearranging-matrices#XREFhorzcat&quot;&gt;horzcat&lt;/a&gt; 및 &lt;a href=&quot;rearranging-matrices#XREFvertcat&quot;&gt;vertcat 참조)&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="24ab8464e1f70b6e778b76282b8eca9e46d30844" translate="yes" xml:space="preserve">
          <source>Newline character.</source>
          <target state="translated">줄 바꿈 문자.</target>
        </trans-unit>
        <trans-unit id="156f42ed828e8b596bb65e80ee975f9805f5ad38" translate="yes" xml:space="preserve">
          <source>Next, Octave searches in the user&amp;rsquo;s home directory. If a file</source>
          <target state="translated">다음으로 Octave는 사용자의 홈 디렉토리에서 검색합니다. 파일 인 경우</target>
        </trans-unit>
        <trans-unit id="cdfb9816a6da8b55dc6b83876630fbe046265472" translate="yes" xml:space="preserve">
          <source>Nineteen Dubious Ways to Compute the Exponential of a Matrix</source>
          <target state="translated">행렬의 지수를 계산하는 19 가지 모호한 방법</target>
        </trans-unit>
        <trans-unit id="ea9adb03bc9432c8d85a190a8df2a570355876e3" translate="yes" xml:space="preserve">
          <source>No Jacobian used (even if it is available).</source>
          <target state="translated">Jacobian을 사용하지 않았습니다 (사용 가능한 경우에도).</target>
        </trans-unit>
        <trans-unit id="4a76f110ba0569bf078529829be2f1767dab0c64" translate="yes" xml:space="preserve">
          <source>No actual tests are performed.</source>
          <target state="translated">실제 테스트는 수행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="72647315b2f15c1b26310b5d140f0c80e187a398" translate="yes" xml:space="preserve">
          <source>No check is done for the existence of &lt;var&gt;file&lt;/var&gt;.</source>
          <target state="translated">&lt;var&gt;file&lt;/var&gt; 이 있는지 검사하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="0b6b27854b5e6b978095dbaf3103720ecfa79f6b" translate="yes" xml:space="preserve">
          <source>No check is done for the existence of &lt;var&gt;file&lt;/var&gt;. No tilde expansion of &lt;var&gt;file&lt;/var&gt; is performed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="faff1342dad9919bbe2a2ffdaf4dcba79402405f" translate="yes" xml:space="preserve">
          <source>No checks are made for duplicate elements.</source>
          <target state="translated">중복 요소는 검사하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7cfb987067249b31fc3824dfa2aac42cf1fbe27d" translate="yes" xml:space="preserve">
          <source>No convergence.</source>
          <target state="translated">수렴이 없습니다.</target>
        </trans-unit>
        <trans-unit id="ae744b18f1531f50578dfdc1fd733c33e953aa60" translate="yes" xml:space="preserve">
          <source>No display.</source>
          <target state="translated">표시되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="641c0f50ba6c7f6fa40ed4b9121a7c0c62c0fda8" translate="yes" xml:space="preserve">
          <source>No dual feasible solution.</source>
          <target state="translated">이중 실행 가능한 솔루션이 없습니다.</target>
        </trans-unit>
        <trans-unit id="b2f69b3d1ffe4476f9895565ab3c472eb9a4deae" translate="yes" xml:space="preserve">
          <source>No error.</source>
          <target state="translated">오류가 없습니다.</target>
        </trans-unit>
        <trans-unit id="7d26577d89448b98ab61ebcd31cea5c25d90930e" translate="yes" xml:space="preserve">
          <source>No line. Points will still be marked using the current Marker Style.</source>
          <target state="translated">줄이 없습니다. 포인트는 여전히 현재 마커 스타일을 사용하여 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="64bbb2d2d3a0587efd7abf186fcfc2b1948eba7f" translate="yes" xml:space="preserve">
          <source>No output.</source>
          <target state="translated">출력이 없습니다.</target>
        </trans-unit>
        <trans-unit id="b330bed69473b0291eb7e09ceba27269cdb6d9f5" translate="yes" xml:space="preserve">
          <source>No primal feasible solution.</source>
          <target state="translated">원시 가능한 솔루션이 없습니다.</target>
        </trans-unit>
        <trans-unit id="3cce4b3efa8e51297e19ceaa379c1a199d3df228" translate="yes" xml:space="preserve">
          <source>No primal/dual feasible solution.</source>
          <target state="translated">원시 / 이중 실행 가능한 솔루션이 없습니다.</target>
        </trans-unit>
        <trans-unit id="e88eaa47e5307bdc10f51fa823e3f66a91a0185f" translate="yes" xml:space="preserve">
          <source>No value is &lt;var&gt;NaN&lt;/var&gt;, and each is greater than or equal to the preceding one.</source>
          <target state="translated">&lt;var&gt;NaN&lt;/var&gt; 값이 없고 각각이 이전 값보다 크거나 같습니다.</target>
        </trans-unit>
        <trans-unit id="24babdb294bc9d6d8b704781453133e16f672ae2" translate="yes" xml:space="preserve">
          <source>No value is &lt;var&gt;NaN&lt;/var&gt;, and each is greater than the preceding one.</source>
          <target state="translated">&lt;var&gt;NaN&lt;/var&gt; 값이 없으며 각 값이 이전 값보다 큽니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
